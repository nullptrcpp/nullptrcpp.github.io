<!DOCTYPE html>
<html>
  <head>
    <title>Plist HTML Viewer</title>

    <meta charset="UTF-8">

    <style type="text/css">
      .CodeMirror{font-family:monospace;height:300px;color:#000;direction:ltr}.CodeMirror-lines{padding:4px 0}.CodeMirror pre{padding:0 4px}.CodeMirror-gutter-filler,.CodeMirror-scrollbar-filler{background-color:#fff}.CodeMirror-gutters{border-right:1px solid #ddd;background-color:#f7f7f7;white-space:nowrap}.CodeMirror-linenumber{padding:0 3px 0 5px;min-width:20px;text-align:right;color:#999;white-space:nowrap}.CodeMirror-guttermarker{color:#000}.CodeMirror-guttermarker-subtle{color:#999}.CodeMirror-cursor{border-left:1px solid #000;border-right:none;width:0}.CodeMirror div.CodeMirror-secondarycursor{border-left:1px solid silver}.cm-fat-cursor .CodeMirror-cursor{width:auto;border:0!important;background:#7e7}.cm-fat-cursor div.CodeMirror-cursors{z-index:1}.cm-animate-fat-cursor{width:auto;border:0;-webkit-animation:blink 1.06s steps(1) infinite;-moz-animation:blink 1.06s steps(1) infinite;animation:blink 1.06s steps(1) infinite;background-color:#7e7}@-moz-keyframes blink{50%{background-color:transparent}}@-webkit-keyframes blink{50%{background-color:transparent}}@keyframes blink{50%{background-color:transparent}}.cm-tab{display:inline-block;text-decoration:inherit}.CodeMirror-rulers{position:absolute;left:0;right:0;top:-50px;bottom:-20px;overflow:hidden}.CodeMirror-ruler{border-left:1px solid #ccc;top:0;bottom:0;position:absolute}.cm-s-default .cm-header{color:#00f}.cm-s-default .cm-quote{color:#090}.cm-negative{color:#d44}.cm-positive{color:#292}.cm-header,.cm-strong{font-weight:700}.cm-em{font-style:italic}.cm-link{text-decoration:underline}.cm-strikethrough{text-decoration:line-through}.cm-s-default .cm-keyword{color:#708}.cm-s-default .cm-atom{color:#219}.cm-s-default .cm-number{color:#164}.cm-s-default .cm-def{color:#00f}.cm-s-default .cm-variable-2{color:#05a}.cm-s-default .cm-type,.cm-s-default .cm-variable-3{color:#085}.cm-s-default .cm-comment{color:#a50}.cm-s-default .cm-string{color:#a11}.cm-s-default .cm-string-2{color:#f50}.cm-s-default .cm-meta{color:#555}.cm-s-default .cm-qualifier{color:#555}.cm-s-default .cm-builtin{color:#30a}.cm-s-default .cm-bracket{color:#997}.cm-s-default .cm-tag{color:#170}.cm-s-default .cm-attribute{color:#00c}.cm-s-default .cm-hr{color:#999}.cm-s-default .cm-link{color:#00c}.cm-s-default .cm-error{color:red}.cm-invalidchar{color:red}.CodeMirror-composing{border-bottom:2px solid}div.CodeMirror span.CodeMirror-matchingbracket{color:#0f0}div.CodeMirror span.CodeMirror-nonmatchingbracket{color:#f22}.CodeMirror-matchingtag{background:rgba(255,150,0,.3)}.CodeMirror-activeline-background{background:#e8f2ff}.CodeMirror{position:relative;overflow:hidden;background:#fff}.CodeMirror-scroll{overflow:scroll!important;margin-bottom:-30px;margin-right:-30px;padding-bottom:30px;height:100%;outline:0;position:relative}.CodeMirror-sizer{position:relative;border-right:30px solid transparent}.CodeMirror-gutter-filler,.CodeMirror-hscrollbar,.CodeMirror-scrollbar-filler,.CodeMirror-vscrollbar{position:absolute;z-index:6;display:none}.CodeMirror-vscrollbar{right:0;top:0;overflow-x:hidden;overflow-y:scroll}.CodeMirror-hscrollbar{bottom:0;left:0;overflow-y:hidden;overflow-x:scroll}.CodeMirror-scrollbar-filler{right:0;bottom:0}.CodeMirror-gutter-filler{left:0;bottom:0}.CodeMirror-gutters{position:absolute;left:0;top:0;min-height:100%;z-index:3}.CodeMirror-gutter{white-space:normal;height:100%;display:inline-block;vertical-align:top;margin-bottom:-30px}.CodeMirror-gutter-wrapper{position:absolute;z-index:4;background:0 0!important;border:none!important}.CodeMirror-gutter-background{position:absolute;top:0;bottom:0;z-index:4}.CodeMirror-gutter-elt{position:absolute;cursor:default;z-index:4}.CodeMirror-gutter-wrapper ::selection{background-color:transparent}.CodeMirror-gutter-wrapper ::-moz-selection{background-color:transparent}.CodeMirror-lines{cursor:text;min-height:1px}.CodeMirror pre{-moz-border-radius:0;-webkit-border-radius:0;border-radius:0;border-width:0;background:0 0;font-family:inherit;font-size:inherit;margin:0;white-space:pre;word-wrap:normal;line-height:inherit;color:inherit;z-index:2;position:relative;overflow:visible;-webkit-tap-highlight-color:transparent;-webkit-font-variant-ligatures:contextual;font-variant-ligatures:contextual}.CodeMirror-wrap pre{word-wrap:break-word;white-space:pre-wrap;word-break:normal}.CodeMirror-linebackground{position:absolute;left:0;right:0;top:0;bottom:0;z-index:0}.CodeMirror-linewidget{position:relative;z-index:2;overflow:auto}.CodeMirror-rtl pre{direction:rtl}.CodeMirror-code{outline:0}.CodeMirror-gutter,.CodeMirror-gutters,.CodeMirror-linenumber,.CodeMirror-scroll,.CodeMirror-sizer{-moz-box-sizing:content-box;box-sizing:content-box}.CodeMirror-measure{position:absolute;width:100%;height:0;overflow:hidden;visibility:hidden}.CodeMirror-cursor{position:absolute;pointer-events:none}.CodeMirror-measure pre{position:static}div.CodeMirror-cursors{visibility:hidden;position:relative;z-index:3}div.CodeMirror-dragcursors{visibility:visible}.CodeMirror-focused div.CodeMirror-cursors{visibility:visible}.CodeMirror-selected{background:#d9d9d9}.CodeMirror-focused .CodeMirror-selected{background:#d7d4f0}.CodeMirror-crosshair{cursor:crosshair}.CodeMirror-line::selection,.CodeMirror-line>span::selection,.CodeMirror-line>span>span::selection{background:#d7d4f0}.CodeMirror-line::-moz-selection,.CodeMirror-line>span::-moz-selection,.CodeMirror-line>span>span::-moz-selection{background:#d7d4f0}.cm-searching{background-color:#ffa;background-color:rgba(255,255,0,.4)}.cm-force-border{padding-right:.1px}@media print{.CodeMirror div.CodeMirror-cursors{visibility:hidden}}.cm-tab-wrap-hack:after{content:''}span.CodeMirror-selectedtext{background:0 0}
/*# sourceMappingURL=codemirror.min.css.map */

      .severity-low {
  background-color: #669603;
}

.severity-low:after {
  content : 'L';
}

.severity-unspecified {
  background-color: #666666;
}

.severity-unspecified:after {
  content : 'U';
}

.severity-style {
  background-color: #9932cc;
}

.severity-style:after {
  content : 'S';
}

.severity-medium {
  background-color: #a9d323;
  color: black;
}

.severity-medium:after {
  content : 'M';
}

.severity-high {
  background-color: #ffa800;
}

.severity-high:after {
  content : 'H';
}

.severity-critical {
  background-color: #e92625;
}

.severity-critical:after {
  content : 'C';
}

i[class*="severity-"] {
  line-height: normal;
  text-transform: capitalize;
  font-size: 0.8em;
  font-weight: bold;
  color: white;
  display: inline-block;
  width: 16px;
  height: 16px;
  text-align: center;
  font-family: sans-serif;
}

      html, body {
  width: 100%;
  height: 100%;
  padding: 0px;
  margin: 0px;
}

div.container {
  padding: 10px;
}

#content {
  height: 100%;
  display: block;
  overflow: hidden;
}

#content > div {
  margin: 10px;
  overflow: hidden;
  border: 1px solid #ddd;
  border-radius: 3px;
  overflow: hidden;
  height: 97%;
}

.button {
  background-color: #f1f1f1;
  text-decoration: none;
  display: inline-block;
  padding: 8px 16px;
  color: black;
  cursor: pointer;
}

.button:hover {
  background-color: #ddd;
  color: black;
}

.review-status {
  color: white;
  text-align: center;
}

.review-status-confirmed {
  background-color: #e92625;
}

.review-status-false-positive {
  background-color: grey;
}

.review-status-intentional {
  background-color: #669603;
}

      div.container {
  width: 100%;
  height: 100%;
  padding: 0px;
}

#editor-wrapper {
  margin: 10px;
}

#side-bar {
  float: left;
  width: 260px;
  margin: 0px;
}

#report-nav ul {
  list-style-type: none;
  padding: 0;
  margin: 0;
  overflow-y: auto;
  height: 100%;
}

#report-nav ul > li {
  padding: .4em;
  background-color: #fff;
  border-bottom: 1px solid rgba(0,0,0,.125);
  text-align: left;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

#report-nav ul > li.active {
  background-color: #427ea9;
  color: white;
}

#report-nav ul > li:hover {
  background-color: #427ea9;
  color: white;
  cursor: pointer;
}

#report-nav ul a {
  text-decoration: none;
}

#report-nav i[class*="severity-"] {
  margin-right: 5px;
}

.header {
  border-bottom: 1px solid lightgrey;
  font-family: monospace;
  padding: 10px;
  background-color: #fafbfc;
  border-bottom: 1px solid #e1e4e8;
  border-top-left-radius: 2px;
  border-top-right-radius: 2px;
}

#report-nav .header {
  font-weight: bold;
}

#editor-wrapper .header > div {
  padding-top: 2px;
}

#file-path,
#checker-name {
  color: #195ea2;
}

#review-status {
  padding: 0px 5px;
}

#file-path {
  font-family: monospace;
}

.check-msg {
  display: inline-block;
  padding: 3px 6px;
  margin: 1px;
  -webkit-border-radius: 5px;
  -moz-border-radius: 5px;
  border-radius: 5px;
}

.check-msg.info {
  color: #00546f;
  background-color: #bfdfe9;
  border: 1px solid #87a8b3;
}

.check-msg.error {
  background-color: #f2dede;
  color: #a94442;
  border: 1px solid #ebcccc;
}

.check-msg.macro {
  background-color: #d7dac2;
  color: #4f5c6d;
  border: 1px solid #d7dac2;
}

.check-msg.note {
  background-color: #d7d7d7;
  color: #4f5c6d;
  border: 1px solid #bfbfbf;
}

.check-msg.current {
  border: 2px dashed #3692ff;
}

.check-msg .tag {
  padding: 1px 5px;
  text-align: center;
  border-radius: 2px;
  margin-right: 5px;
  text-decoration: inherit;
}

.check-msg .tag.macro {
  background-color: #83876a;
  color: white;
  text-transform: capitalize;
}

.check-msg .tag.note {
  background-color: #9299a1;
  color: white;
  text-transform: capitalize;
}

.checker-enum {
  color: white;
  padding: 1px 5px;
  text-align: center;
  border-radius: 25px;
  margin-right: 5px;
  text-decoration: inherit;
}

.checker-enum.info {
  background-color: #427ea9;
}

.checker-enum.error {
  background-color: #a94442;
}

.arrow {
  border: solid black;
  border-width: 0 3px 3px 0;
  display: inline-block;
  padding: 3px;
  cursor: pointer;
  margin: 0px 5px;
}

.arrow:hover {
  border: solid #437ea8;
  border-width: 0 3px 3px 0;
}

.left-arrow {
  transform: rotate(135deg);
  -webkit-transform: rotate(135deg);
}

.right-arrow {
  transform: rotate(-45deg);
  -webkit-transform: rotate(-45deg);
}

    </style>

    <script type="text/javascript">
      function setNonCompatibleBrowserMessage() {
  document.body.innerHTML =
    '<h2 style="margin-left: 20px;">Your browser is not compatible with CodeChecker Viewer!</h2> \
     <p style="margin-left: 20px;">The version required for the following browsers are:</p> \
     <ul style="margin-left: 20px;"> \
     <li>Internet Explorer: version 9 or newer</li> \
     <li>Firefox: version 22.0 or newer</li> \
     </ul>';
}

// http://stackoverflow.com/questions/5916900/how-can-you-detect-the-version-of-a-browser
var browserVersion = (function(){
  var ua = navigator.userAgent, tem,
    M = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];

  if (/trident/i.test(M[1])) {
    tem = /\brv[ :]+(\d+)/g.exec(ua) || [];
    return 'IE ' + (tem[1] || '');
  }

  if (M[1] === 'Chrome') {
    tem = ua.match(/\b(OPR|Edge)\/(\d+)/);
    if (tem != null) return tem.slice(1).join(' ').replace('OPR', 'Opera');
  }

  M = M[2] ? [M[1], M[2]] : [navigator.appName, navigator.appVersion, '-?'];
  if ((tem = ua.match(/version\/(\d+)/i)) != null) M.splice(1, 1, tem[1]);
    return M.join(' ');
})();

var pos = browserVersion.indexOf(' ');
var browser = browserVersion.substr(0, pos);
var version = parseInt(browserVersion.substr(pos + 1));

var browserCompatible
  = browser === 'Firefox'
  ? version >= 22
  : browser === 'IE'
  ? version >= 9
  : true;


      /* MIT License

Copyright (C) 2017 by Marijn Haverbeke <marijnh@gmail.com> and others

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
 */
      !function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):e.CodeMirror=t()}(this,function(){"use strict";function e(e){return new RegExp("(^|\\s)"+e+"(?:$|\\s)\\s*")}function t(e){for(var t=e.childNodes.length;t>0;--t)e.removeChild(e.firstChild);return e}function r(e,r){return t(e).appendChild(r)}function n(e,t,r,n){var i=document.createElement(e);if(r&&(i.className=r),n&&(i.style.cssText=n),"string"==typeof t)i.appendChild(document.createTextNode(t));else if(t)for(var o=0;o<t.length;++o)i.appendChild(t[o]);return i}function i(e,t,r,i){var o=n(e,t,r,i);return o.setAttribute("role","presentation"),o}function o(e,t){if(3==t.nodeType&&(t=t.parentNode),e.contains)return e.contains(t);do{if(11==t.nodeType&&(t=t.host),t==e)return!0}while(t=t.parentNode)}function l(){var e;try{e=document.activeElement}catch(t){e=document.body||null}for(;e&&e.shadowRoot&&e.shadowRoot.activeElement;)e=e.shadowRoot.activeElement;return e}function s(t,r){var n=t.className;e(r).test(n)||(t.className+=(n?" ":"")+r)}function a(t,r){for(var n=t.split(" "),i=0;i<n.length;i++)n[i]&&!e(n[i]).test(r)&&(r+=" "+n[i]);return r}function u(e){var t=Array.prototype.slice.call(arguments,1);return function(){return e.apply(null,t)}}function c(e,t,r){t||(t={});for(var n in e)!e.hasOwnProperty(n)||!1===r&&t.hasOwnProperty(n)||(t[n]=e[n]);return t}function f(e,t,r,n,i){null==t&&-1==(t=e.search(/[^\s\u00a0]/))&&(t=e.length);for(var o=n||0,l=i||0;;){var s=e.indexOf("\t",o);if(s<0||s>=t)return l+(t-o);l+=s-o,l+=r-l%r,o=s+1}}function h(e,t){for(var r=0;r<e.length;++r)if(e[r]==t)return r;return-1}function d(e,t,r){for(var n=0,i=0;;){var o=e.indexOf("\t",n);-1==o&&(o=e.length);var l=o-n;if(o==e.length||i+l>=t)return n+Math.min(l,t-i);if(i+=o-n,i+=r-i%r,n=o+1,i>=t)return n}}function p(e){for(;Kl.length<=e;)Kl.push(g(Kl)+" ");return Kl[e]}function g(e){return e[e.length-1]}function v(e,t){for(var r=[],n=0;n<e.length;n++)r[n]=t(e[n],n);return r}function m(e,t,r){for(var n=0,i=r(t);n<e.length&&r(e[n])<=i;)n++;e.splice(n,0,t)}function y(){}function b(e,t){var r;return Object.create?r=Object.create(e):(y.prototype=e,r=new y),t&&c(t,r),r}function w(e){return/\w/.test(e)||e>""&&(e.toUpperCase()!=e.toLowerCase()||jl.test(e))}function x(e,t){return t?!!(t.source.indexOf("\\w")>-1&&w(e))||t.test(e):w(e)}function C(e){for(var t in e)if(e.hasOwnProperty(t)&&e[t])return!1;return!0}function S(e){return e.charCodeAt(0)>=768&&Xl.test(e)}function L(e,t,r){for(;(r<0?t>0:t<e.length)&&S(e.charAt(t));)t+=r;return t}function k(e,t,r){for(var n=t>r?-1:1;;){if(t==r)return t;var i=(t+r)/2,o=n<0?Math.ceil(i):Math.floor(i);if(o==t)return e(o)?t:r;e(o)?r=o:t=o+n}}function T(e,t,r){var o=this;this.input=r,o.scrollbarFiller=n("div",null,"CodeMirror-scrollbar-filler"),o.scrollbarFiller.setAttribute("cm-not-content","true"),o.gutterFiller=n("div",null,"CodeMirror-gutter-filler"),o.gutterFiller.setAttribute("cm-not-content","true"),o.lineDiv=i("div",null,"CodeMirror-code"),o.selectionDiv=n("div",null,null,"position: relative; z-index: 1"),o.cursorDiv=n("div",null,"CodeMirror-cursors"),o.measure=n("div",null,"CodeMirror-measure"),o.lineMeasure=n("div",null,"CodeMirror-measure"),o.lineSpace=i("div",[o.measure,o.lineMeasure,o.selectionDiv,o.cursorDiv,o.lineDiv],null,"position: relative; outline: none");var l=i("div",[o.lineSpace],"CodeMirror-lines");o.mover=n("div",[l],null,"position: relative"),o.sizer=n("div",[o.mover],"CodeMirror-sizer"),o.sizerWidth=null,o.heightForcer=n("div",null,null,"position: absolute; height: "+Rl+"px; width: 1px;"),o.gutters=n("div",null,"CodeMirror-gutters"),o.lineGutter=null,o.scroller=n("div",[o.sizer,o.heightForcer,o.gutters],"CodeMirror-scroll"),o.scroller.setAttribute("tabIndex","-1"),o.wrapper=n("div",[o.scrollbarFiller,o.gutterFiller,o.scroller],"CodeMirror"),gl&&vl<8&&(o.gutters.style.zIndex=-1,o.scroller.style.paddingRight=0),ml||fl&&Tl||(o.scroller.draggable=!0),e&&(e.appendChild?e.appendChild(o.wrapper):e(o.wrapper)),o.viewFrom=o.viewTo=t.first,o.reportedViewFrom=o.reportedViewTo=t.first,o.view=[],o.renderedView=null,o.externalMeasured=null,o.viewOffset=0,o.lastWrapHeight=o.lastWrapWidth=0,o.updateLineNumbers=null,o.nativeBarWidth=o.barHeight=o.barWidth=0,o.scrollbarsClipped=!1,o.lineNumWidth=o.lineNumInnerWidth=o.lineNumChars=null,o.alignWidgets=!1,o.cachedCharWidth=o.cachedTextHeight=o.cachedPaddingH=null,o.maxLine=null,o.maxLineLength=0,o.maxLineChanged=!1,o.wheelDX=o.wheelDY=o.wheelStartX=o.wheelStartY=null,o.shift=!1,o.selForContextMenu=null,o.activeTouch=null,r.init(o)}function M(e,t){if((t-=e.first)<0||t>=e.size)throw new Error("There is no line "+(t+e.first)+" in the document.");for(var r=e;!r.lines;)for(var n=0;;++n){var i=r.children[n],o=i.chunkSize();if(t<o){r=i;break}t-=o}return r.lines[t]}function N(e,t,r){var n=[],i=t.line;return e.iter(t.line,r.line+1,function(e){var o=e.text;i==r.line&&(o=o.slice(0,r.ch)),i==t.line&&(o=o.slice(t.ch)),n.push(o),++i}),n}function O(e,t,r){var n=[];return e.iter(t,r,function(e){n.push(e.text)}),n}function A(e,t){var r=t-e.height;if(r)for(var n=e;n;n=n.parent)n.height+=r}function W(e){if(null==e.parent)return null;for(var t=e.parent,r=h(t.lines,e),n=t.parent;n;t=n,n=n.parent)for(var i=0;n.children[i]!=t;++i)r+=n.children[i].chunkSize();return r+t.first}function D(e,t){var r=e.first;e:do{for(var n=0;n<e.children.length;++n){var i=e.children[n],o=i.height;if(t<o){e=i;continue e}t-=o,r+=i.chunkSize()}return r}while(!e.lines);for(var l=0;l<e.lines.length;++l){var s=e.lines[l].height;if(t<s)break;t-=s}return r+l}function H(e,t){return t>=e.first&&t<e.first+e.size}function F(e,t){return String(e.lineNumberFormatter(t+e.firstLineNumber))}function E(e,t,r){if(void 0===r&&(r=null),!(this instanceof E))return new E(e,t,r);this.line=e,this.ch=t,this.sticky=r}function P(e,t){return e.line-t.line||e.ch-t.ch}function I(e,t){return e.sticky==t.sticky&&0==P(e,t)}function z(e){return E(e.line,e.ch)}function R(e,t){return P(e,t)<0?t:e}function B(e,t){return P(e,t)<0?e:t}function G(e,t){return Math.max(e.first,Math.min(t,e.first+e.size-1))}function U(e,t){if(t.line<e.first)return E(e.first,0);var r=e.first+e.size-1;return t.line>r?E(r,M(e,r).text.length):V(t,M(e,t.line).text.length)}function V(e,t){var r=e.ch;return null==r||r>t?E(e.line,t):r<0?E(e.line,0):e}function K(e,t){for(var r=[],n=0;n<t.length;n++)r[n]=U(e,t[n]);return r}function j(){Yl=!0}function X(){_l=!0}function Y(e,t,r){this.marker=e,this.from=t,this.to=r}function _(e,t){if(e)for(var r=0;r<e.length;++r){var n=e[r];if(n.marker==t)return n}}function $(e,t){for(var r,n=0;n<e.length;++n)e[n]!=t&&(r||(r=[])).push(e[n]);return r}function q(e,t){e.markedSpans=e.markedSpans?e.markedSpans.concat([t]):[t],t.marker.attachLine(e)}function Z(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t)||o.from==t&&"bookmark"==l.type&&(!r||!o.marker.insertLeft)){var s=null==o.to||(l.inclusiveRight?o.to>=t:o.to>t);(n||(n=[])).push(new Y(l,o.from,s?null:o.to))}}return n}function Q(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.to||(l.inclusiveRight?o.to>=t:o.to>t)||o.from==t&&"bookmark"==l.type&&(!r||o.marker.insertLeft)){var s=null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t);(n||(n=[])).push(new Y(l,s?null:o.from-t,null==o.to?null:o.to-t))}}return n}function J(e,t){if(t.full)return null;var r=H(e,t.from.line)&&M(e,t.from.line).markedSpans,n=H(e,t.to.line)&&M(e,t.to.line).markedSpans;if(!r&&!n)return null;var i=t.from.ch,o=t.to.ch,l=0==P(t.from,t.to),s=Z(r,i,l),a=Q(n,o,l),u=1==t.text.length,c=g(t.text).length+(u?i:0);if(s)for(var f=0;f<s.length;++f){var h=s[f];if(null==h.to){var d=_(a,h.marker);d?u&&(h.to=null==d.to?null:d.to+c):h.to=i}}if(a)for(var p=0;p<a.length;++p){var v=a[p];null!=v.to&&(v.to+=c),null==v.from?_(s,v.marker)||(v.from=c,u&&(s||(s=[])).push(v)):(v.from+=c,u&&(s||(s=[])).push(v))}s&&(s=ee(s)),a&&a!=s&&(a=ee(a));var m=[s];if(!u){var y,b=t.text.length-2;if(b>0&&s)for(var w=0;w<s.length;++w)null==s[w].to&&(y||(y=[])).push(new Y(s[w].marker,null,null));for(var x=0;x<b;++x)m.push(y);m.push(a)}return m}function ee(e){for(var t=0;t<e.length;++t){var r=e[t];null!=r.from&&r.from==r.to&&!1!==r.marker.clearWhenEmpty&&e.splice(t--,1)}return e.length?e:null}function te(e,t,r){var n=null;if(e.iter(t.line,r.line+1,function(e){if(e.markedSpans)for(var t=0;t<e.markedSpans.length;++t){var r=e.markedSpans[t].marker;!r.readOnly||n&&-1!=h(n,r)||(n||(n=[])).push(r)}}),!n)return null;for(var i=[{from:t,to:r}],o=0;o<n.length;++o)for(var l=n[o],s=l.find(0),a=0;a<i.length;++a){var u=i[a];if(!(P(u.to,s.from)<0||P(u.from,s.to)>0)){var c=[a,1],f=P(u.from,s.from),d=P(u.to,s.to);(f<0||!l.inclusiveLeft&&!f)&&c.push({from:u.from,to:s.from}),(d>0||!l.inclusiveRight&&!d)&&c.push({from:s.to,to:u.to}),i.splice.apply(i,c),a+=c.length-3}}return i}function re(e){var t=e.markedSpans;if(t){for(var r=0;r<t.length;++r)t[r].marker.detachLine(e);e.markedSpans=null}}function ne(e,t){if(t){for(var r=0;r<t.length;++r)t[r].marker.attachLine(e);e.markedSpans=t}}function ie(e){return e.inclusiveLeft?-1:0}function oe(e){return e.inclusiveRight?1:0}function le(e,t){var r=e.lines.length-t.lines.length;if(0!=r)return r;var n=e.find(),i=t.find(),o=P(n.from,i.from)||ie(e)-ie(t);if(o)return-o;var l=P(n.to,i.to)||oe(e)-oe(t);return l||t.id-e.id}function se(e,t){var r,n=_l&&e.markedSpans;if(n)for(var i=void 0,o=0;o<n.length;++o)(i=n[o]).marker.collapsed&&null==(t?i.from:i.to)&&(!r||le(r,i.marker)<0)&&(r=i.marker);return r}function ae(e){return se(e,!0)}function ue(e){return se(e,!1)}function ce(e,t,r,n,i){var o=M(e,t),l=_l&&o.markedSpans;if(l)for(var s=0;s<l.length;++s){var a=l[s];if(a.marker.collapsed){var u=a.marker.find(0),c=P(u.from,r)||ie(a.marker)-ie(i),f=P(u.to,n)||oe(a.marker)-oe(i);if(!(c>=0&&f<=0||c<=0&&f>=0)&&(c<=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.to,r)>=0:P(u.to,r)>0)||c>=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.from,n)<=0:P(u.from,n)<0)))return!0}}}function fe(e){for(var t;t=ae(e);)e=t.find(-1,!0).line;return e}function he(e){for(var t;t=ue(e);)e=t.find(1,!0).line;return e}function de(e){for(var t,r;t=ue(e);)e=t.find(1,!0).line,(r||(r=[])).push(e);return r}function pe(e,t){var r=M(e,t),n=fe(r);return r==n?t:W(n)}function ge(e,t){if(t>e.lastLine())return t;var r,n=M(e,t);if(!ve(e,n))return t;for(;r=ue(n);)n=r.find(1,!0).line;return W(n)+1}function ve(e,t){var r=_l&&t.markedSpans;if(r)for(var n=void 0,i=0;i<r.length;++i)if((n=r[i]).marker.collapsed){if(null==n.from)return!0;if(!n.marker.widgetNode&&0==n.from&&n.marker.inclusiveLeft&&me(e,t,n))return!0}}function me(e,t,r){if(null==r.to){var n=r.marker.find(1,!0);return me(e,n.line,_(n.line.markedSpans,r.marker))}if(r.marker.inclusiveRight&&r.to==t.text.length)return!0;for(var i=void 0,o=0;o<t.markedSpans.length;++o)if((i=t.markedSpans[o]).marker.collapsed&&!i.marker.widgetNode&&i.from==r.to&&(null==i.to||i.to!=r.from)&&(i.marker.inclusiveLeft||r.marker.inclusiveRight)&&me(e,t,i))return!0}function ye(e){for(var t=0,r=(e=fe(e)).parent,n=0;n<r.lines.length;++n){var i=r.lines[n];if(i==e)break;t+=i.height}for(var o=r.parent;o;r=o,o=r.parent)for(var l=0;l<o.children.length;++l){var s=o.children[l];if(s==r)break;t+=s.height}return t}function be(e){if(0==e.height)return 0;for(var t,r=e.text.length,n=e;t=ae(n);){var i=t.find(0,!0);n=i.from.line,r+=i.from.ch-i.to.ch}for(n=e;t=ue(n);){var o=t.find(0,!0);r-=n.text.length-o.from.ch,r+=(n=o.to.line).text.length-o.to.ch}return r}function we(e){var t=e.display,r=e.doc;t.maxLine=M(r,r.first),t.maxLineLength=be(t.maxLine),t.maxLineChanged=!0,r.iter(function(e){var r=be(e);r>t.maxLineLength&&(t.maxLineLength=r,t.maxLine=e)})}function xe(e,t,r,n){if(!e)return n(t,r,"ltr",0);for(var i=!1,o=0;o<e.length;++o){var l=e[o];(l.from<r&&l.to>t||t==r&&l.to==t)&&(n(Math.max(l.from,t),Math.min(l.to,r),1==l.level?"rtl":"ltr",o),i=!0)}i||n(t,r,"ltr")}function Ce(e,t,r){var n;$l=null;for(var i=0;i<e.length;++i){var o=e[i];if(o.from<t&&o.to>t)return i;o.to==t&&(o.from!=o.to&&"before"==r?n=i:$l=i),o.from==t&&(o.from!=o.to&&"before"!=r?n=i:$l=i)}return null!=n?n:$l}function Se(e,t){var r=e.order;return null==r&&(r=e.order=ql(e.text,t)),r}function Le(e,t){return e._handlers&&e._handlers[t]||Zl}function ke(e,t,r){if(e.removeEventListener)e.removeEventListener(t,r,!1);else if(e.detachEvent)e.detachEvent("on"+t,r);else{var n=e._handlers,i=n&&n[t];if(i){var o=h(i,r);o>-1&&(n[t]=i.slice(0,o).concat(i.slice(o+1)))}}}function Te(e,t){var r=Le(e,t);if(r.length)for(var n=Array.prototype.slice.call(arguments,2),i=0;i<r.length;++i)r[i].apply(null,n)}function Me(e,t,r){return"string"==typeof t&&(t={type:t,preventDefault:function(){this.defaultPrevented=!0}}),Te(e,r||t.type,e,t),He(t)||t.codemirrorIgnore}function Ne(e){var t=e._handlers&&e._handlers.cursorActivity;if(t)for(var r=e.curOp.cursorActivityHandlers||(e.curOp.cursorActivityHandlers=[]),n=0;n<t.length;++n)-1==h(r,t[n])&&r.push(t[n])}function Oe(e,t){return Le(e,t).length>0}function Ae(e){e.prototype.on=function(e,t){Ql(this,e,t)},e.prototype.off=function(e,t){ke(this,e,t)}}function We(e){e.preventDefault?e.preventDefault():e.returnValue=!1}function De(e){e.stopPropagation?e.stopPropagation():e.cancelBubble=!0}function He(e){return null!=e.defaultPrevented?e.defaultPrevented:0==e.returnValue}function Fe(e){We(e),De(e)}function Ee(e){return e.target||e.srcElement}function Pe(e){var t=e.which;return null==t&&(1&e.button?t=1:2&e.button?t=3:4&e.button&&(t=2)),Ml&&e.ctrlKey&&1==t&&(t=3),t}function Ie(e){if(null==Il){var t=n("span","​");r(e,n("span",[t,document.createTextNode("x")])),0!=e.firstChild.offsetHeight&&(Il=t.offsetWidth<=1&&t.offsetHeight>2&&!(gl&&vl<8))}var i=Il?n("span","​"):n("span"," ",null,"display: inline-block; width: 1px; margin-right: -1px");return i.setAttribute("cm-text",""),i}function ze(e){if(null!=zl)return zl;var n=r(e,document.createTextNode("AخA")),i=Wl(n,0,1).getBoundingClientRect(),o=Wl(n,1,2).getBoundingClientRect();return t(e),!(!i||i.left==i.right)&&(zl=o.right-i.right<3)}function Re(e){if(null!=ns)return ns;var t=r(e,n("span","x")),i=t.getBoundingClientRect(),o=Wl(t,0,1).getBoundingClientRect();return ns=Math.abs(i.left-o.left)>1}function Be(e,t){arguments.length>2&&(t.dependencies=Array.prototype.slice.call(arguments,2)),is[e]=t}function Ge(e){if("string"==typeof e&&os.hasOwnProperty(e))e=os[e];else if(e&&"string"==typeof e.name&&os.hasOwnProperty(e.name)){var t=os[e.name];"string"==typeof t&&(t={name:t}),(e=b(t,e)).name=t.name}else{if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+xml$/.test(e))return Ge("application/xml");if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+json$/.test(e))return Ge("application/json")}return"string"==typeof e?{name:e}:e||{name:"null"}}function Ue(e,t){t=Ge(t);var r=is[t.name];if(!r)return Ue(e,"text/plain");var n=r(e,t);if(ls.hasOwnProperty(t.name)){var i=ls[t.name];for(var o in i)i.hasOwnProperty(o)&&(n.hasOwnProperty(o)&&(n["_"+o]=n[o]),n[o]=i[o])}if(n.name=t.name,t.helperType&&(n.helperType=t.helperType),t.modeProps)for(var l in t.modeProps)n[l]=t.modeProps[l];return n}function Ve(e,t){c(t,ls.hasOwnProperty(e)?ls[e]:ls[e]={})}function Ke(e,t){if(!0===t)return t;if(e.copyState)return e.copyState(t);var r={};for(var n in t){var i=t[n];i instanceof Array&&(i=i.concat([])),r[n]=i}return r}function je(e,t){for(var r;e.innerMode&&(r=e.innerMode(t))&&r.mode!=e;)t=r.state,e=r.mode;return r||{mode:e,state:t}}function Xe(e,t,r){return!e.startState||e.startState(t,r)}function Ye(e,t,r,n){var i=[e.state.modeGen],o={};tt(e,t.text,e.doc.mode,r,function(e,t){return i.push(e,t)},o,n);for(var l=r.state,s=0;s<e.state.overlays.length;++s)!function(n){var l=e.state.overlays[n],s=1,a=0;r.state=!0,tt(e,t.text,l.mode,r,function(e,t){for(var r=s;a<e;){var n=i[s];n>e&&i.splice(s,1,e,i[s+1],n),s+=2,a=Math.min(e,n)}if(t)if(l.opaque)i.splice(r,s-r,e,"overlay "+t),s=r+2;else for(;r<s;r+=2){var o=i[r+1];i[r+1]=(o?o+" ":"")+"overlay "+t}},o)}(s);return r.state=l,{styles:i,classes:o.bgClass||o.textClass?o:null}}function _e(e,t,r){if(!t.styles||t.styles[0]!=e.state.modeGen){var n=$e(e,W(t)),i=t.text.length>e.options.maxHighlightLength&&Ke(e.doc.mode,n.state),o=Ye(e,t,n);i&&(n.state=i),t.stateAfter=n.save(!i),t.styles=o.styles,o.classes?t.styleClasses=o.classes:t.styleClasses&&(t.styleClasses=null),r===e.doc.highlightFrontier&&(e.doc.modeFrontier=Math.max(e.doc.modeFrontier,++e.doc.highlightFrontier))}return t.styles}function $e(e,t,r){var n=e.doc,i=e.display;if(!n.mode.startState)return new us(n,!0,t);var o=rt(e,t,r),l=o>n.first&&M(n,o-1).stateAfter,s=l?us.fromSaved(n,l,o):new us(n,Xe(n.mode),o);return n.iter(o,t,function(r){qe(e,r.text,s);var n=s.line;r.stateAfter=n==t-1||n%5==0||n>=i.viewFrom&&n<i.viewTo?s.save():null,s.nextLine()}),r&&(n.modeFrontier=s.line),s}function qe(e,t,r,n){var i=e.doc.mode,o=new ss(t,e.options.tabSize,r);for(o.start=o.pos=n||0,""==t&&Ze(i,r.state);!o.eol();)Qe(i,o,r.state),o.start=o.pos}function Ze(e,t){if(e.blankLine)return e.blankLine(t);if(e.innerMode){var r=je(e,t);return r.mode.blankLine?r.mode.blankLine(r.state):void 0}}function Qe(e,t,r,n){for(var i=0;i<10;i++){n&&(n[0]=je(e,r).mode);var o=e.token(t,r);if(t.pos>t.start)return o}throw new Error("Mode "+e.name+" failed to advance stream.")}function Je(e,t,r,n){var i,o,l=e.doc,s=l.mode,a=M(l,(t=U(l,t)).line),u=$e(e,t.line,r),c=new ss(a.text,e.options.tabSize,u);for(n&&(o=[]);(n||c.pos<t.ch)&&!c.eol();)c.start=c.pos,i=Qe(s,c,u.state),n&&o.push(new cs(c,i,Ke(l.mode,u.state)));return n?o:new cs(c,i,u.state)}function et(e,t){if(e)for(;;){var r=e.match(/(?:^|\s+)line-(background-)?(\S+)/);if(!r)break;e=e.slice(0,r.index)+e.slice(r.index+r[0].length);var n=r[1]?"bgClass":"textClass";null==t[n]?t[n]=r[2]:new RegExp("(?:^|s)"+r[2]+"(?:$|s)").test(t[n])||(t[n]+=" "+r[2])}return e}function tt(e,t,r,n,i,o,l){var s=r.flattenSpans;null==s&&(s=e.options.flattenSpans);var a,u=0,c=null,f=new ss(t,e.options.tabSize,n),h=e.options.addModeClass&&[null];for(""==t&&et(Ze(r,n.state),o);!f.eol();){if(f.pos>e.options.maxHighlightLength?(s=!1,l&&qe(e,t,n,f.pos),f.pos=t.length,a=null):a=et(Qe(r,f,n.state,h),o),h){var d=h[0].name;d&&(a="m-"+(a?d+" "+a:d))}if(!s||c!=a){for(;u<f.start;)i(u=Math.min(f.start,u+5e3),c);c=a}f.start=f.pos}for(;u<f.pos;){var p=Math.min(f.pos,u+5e3);i(p,c),u=p}}function rt(e,t,r){for(var n,i,o=e.doc,l=r?-1:t-(e.doc.mode.innerMode?1e3:100),s=t;s>l;--s){if(s<=o.first)return o.first;var a=M(o,s-1),u=a.stateAfter;if(u&&(!r||s+(u instanceof as?u.lookAhead:0)<=o.modeFrontier))return s;var c=f(a.text,null,e.options.tabSize);(null==i||n>c)&&(i=s-1,n=c)}return i}function nt(e,t){if(e.modeFrontier=Math.min(e.modeFrontier,t),!(e.highlightFrontier<t-10)){for(var r=e.first,n=t-1;n>r;n--){var i=M(e,n).stateAfter;if(i&&(!(i instanceof as)||n+i.lookAhead<t)){r=n+1;break}}e.highlightFrontier=Math.min(e.highlightFrontier,r)}}function it(e,t,r,n){e.text=t,e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null),null!=e.order&&(e.order=null),re(e),ne(e,r);var i=n?n(e):1;i!=e.height&&A(e,i)}function ot(e){e.parent=null,re(e)}function lt(e,t){if(!e||/^\s*$/.test(e))return null;var r=t.addModeClass?ps:ds;return r[e]||(r[e]=e.replace(/\S+/g,"cm-$&"))}function st(e,t){var r=i("span",null,null,ml?"padding-right: .1px":null),n={pre:i("pre",[r],"CodeMirror-line"),content:r,col:0,pos:0,cm:e,trailingSpace:!1,splitSpaces:(gl||ml)&&e.getOption("lineWrapping")};t.measure={};for(var o=0;o<=(t.rest?t.rest.length:0);o++){var l=o?t.rest[o-1]:t.line,s=void 0;n.pos=0,n.addToken=ut,ze(e.display.measure)&&(s=Se(l,e.doc.direction))&&(n.addToken=ft(n.addToken,s)),n.map=[],dt(l,n,_e(e,l,t!=e.display.externalMeasured&&W(l))),l.styleClasses&&(l.styleClasses.bgClass&&(n.bgClass=a(l.styleClasses.bgClass,n.bgClass||"")),l.styleClasses.textClass&&(n.textClass=a(l.styleClasses.textClass,n.textClass||""))),0==n.map.length&&n.map.push(0,0,n.content.appendChild(Ie(e.display.measure))),0==o?(t.measure.map=n.map,t.measure.cache={}):((t.measure.maps||(t.measure.maps=[])).push(n.map),(t.measure.caches||(t.measure.caches=[])).push({}))}if(ml){var u=n.content.lastChild;(/\bcm-tab\b/.test(u.className)||u.querySelector&&u.querySelector(".cm-tab"))&&(n.content.className="cm-tab-wrap-hack")}return Te(e,"renderLine",e,t.line,n.pre),n.pre.className&&(n.textClass=a(n.pre.className,n.textClass||"")),n}function at(e){var t=n("span","•","cm-invalidchar");return t.title="\\u"+e.charCodeAt(0).toString(16),t.setAttribute("aria-label",t.title),t}function ut(e,t,r,i,o,l,s){if(t){var a,u=e.splitSpaces?ct(t,e.trailingSpace):t,c=e.cm.state.specialChars,f=!1;if(c.test(t)){a=document.createDocumentFragment();for(var h=0;;){c.lastIndex=h;var d=c.exec(t),g=d?d.index-h:t.length-h;if(g){var v=document.createTextNode(u.slice(h,h+g));gl&&vl<9?a.appendChild(n("span",[v])):a.appendChild(v),e.map.push(e.pos,e.pos+g,v),e.col+=g,e.pos+=g}if(!d)break;h+=g+1;var m=void 0;if("\t"==d[0]){var y=e.cm.options.tabSize,b=y-e.col%y;(m=a.appendChild(n("span",p(b),"cm-tab"))).setAttribute("role","presentation"),m.setAttribute("cm-text","\t"),e.col+=b}else"\r"==d[0]||"\n"==d[0]?((m=a.appendChild(n("span","\r"==d[0]?"␍":"␤","cm-invalidchar"))).setAttribute("cm-text",d[0]),e.col+=1):((m=e.cm.options.specialCharPlaceholder(d[0])).setAttribute("cm-text",d[0]),gl&&vl<9?a.appendChild(n("span",[m])):a.appendChild(m),e.col+=1);e.map.push(e.pos,e.pos+1,m),e.pos++}}else e.col+=t.length,a=document.createTextNode(u),e.map.push(e.pos,e.pos+t.length,a),gl&&vl<9&&(f=!0),e.pos+=t.length;if(e.trailingSpace=32==u.charCodeAt(t.length-1),r||i||o||f||s){var w=r||"";i&&(w+=i),o&&(w+=o);var x=n("span",[a],w,s);return l&&(x.title=l),e.content.appendChild(x)}e.content.appendChild(a)}}function ct(e,t){if(e.length>1&&!/  /.test(e))return e;for(var r=t,n="",i=0;i<e.length;i++){var o=e.charAt(i);" "!=o||!r||i!=e.length-1&&32!=e.charCodeAt(i+1)||(o=" "),n+=o,r=" "==o}return n}function ft(e,t){return function(r,n,i,o,l,s,a){i=i?i+" cm-force-border":"cm-force-border";for(var u=r.pos,c=u+n.length;;){for(var f=void 0,h=0;h<t.length&&!((f=t[h]).to>u&&f.from<=u);h++);if(f.to>=c)return e(r,n,i,o,l,s,a);e(r,n.slice(0,f.to-u),i,o,null,s,a),o=null,n=n.slice(f.to-u),u=f.to}}}function ht(e,t,r,n){var i=!n&&r.widgetNode;i&&e.map.push(e.pos,e.pos+t,i),!n&&e.cm.display.input.needsContentAttribute&&(i||(i=e.content.appendChild(document.createElement("span"))),i.setAttribute("cm-marker",r.id)),i&&(e.cm.display.input.setUneditable(i),e.content.appendChild(i)),e.pos+=t,e.trailingSpace=!1}function dt(e,t,r){var n=e.markedSpans,i=e.text,o=0;if(n)for(var l,s,a,u,c,f,h,d=i.length,p=0,g=1,v="",m=0;;){if(m==p){a=u=c=f=s="",h=null,m=1/0;for(var y=[],b=void 0,w=0;w<n.length;++w){var x=n[w],C=x.marker;"bookmark"==C.type&&x.from==p&&C.widgetNode?y.push(C):x.from<=p&&(null==x.to||x.to>p||C.collapsed&&x.to==p&&x.from==p)?(null!=x.to&&x.to!=p&&m>x.to&&(m=x.to,u=""),C.className&&(a+=" "+C.className),C.css&&(s=(s?s+";":"")+C.css),C.startStyle&&x.from==p&&(c+=" "+C.startStyle),C.endStyle&&x.to==m&&(b||(b=[])).push(C.endStyle,x.to),C.title&&!f&&(f=C.title),C.collapsed&&(!h||le(h.marker,C)<0)&&(h=x)):x.from>p&&m>x.from&&(m=x.from)}if(b)for(var S=0;S<b.length;S+=2)b[S+1]==m&&(u+=" "+b[S]);if(!h||h.from==p)for(var L=0;L<y.length;++L)ht(t,0,y[L]);if(h&&(h.from||0)==p){if(ht(t,(null==h.to?d+1:h.to)-p,h.marker,null==h.from),null==h.to)return;h.to==p&&(h=!1)}}if(p>=d)break;for(var k=Math.min(d,m);;){if(v){var T=p+v.length;if(!h){var M=T>k?v.slice(0,k-p):v;t.addToken(t,M,l?l+a:a,c,p+M.length==m?u:"",f,s)}if(T>=k){v=v.slice(k-p),p=k;break}p=T,c=""}v=i.slice(o,o=r[g++]),l=lt(r[g++],t.cm.options)}}else for(var N=1;N<r.length;N+=2)t.addToken(t,i.slice(o,o=r[N]),lt(r[N+1],t.cm.options))}function pt(e,t,r){this.line=t,this.rest=de(t),this.size=this.rest?W(g(this.rest))-r+1:1,this.node=this.text=null,this.hidden=ve(e,t)}function gt(e,t,r){for(var n,i=[],o=t;o<r;o=n){var l=new pt(e.doc,M(e.doc,o),o);n=o+l.size,i.push(l)}return i}function vt(e){gs?gs.ops.push(e):e.ownsGroup=gs={ops:[e],delayedCallbacks:[]}}function mt(e){var t=e.delayedCallbacks,r=0;do{for(;r<t.length;r++)t[r].call(null);for(var n=0;n<e.ops.length;n++){var i=e.ops[n];if(i.cursorActivityHandlers)for(;i.cursorActivityCalled<i.cursorActivityHandlers.length;)i.cursorActivityHandlers[i.cursorActivityCalled++].call(null,i.cm)}}while(r<t.length)}function yt(e,t){var r=e.ownsGroup;if(r)try{mt(r)}finally{gs=null,t(r)}}function bt(e,t){var r=Le(e,t);if(r.length){var n,i=Array.prototype.slice.call(arguments,2);gs?n=gs.delayedCallbacks:vs?n=vs:(n=vs=[],setTimeout(wt,0));for(var o=0;o<r.length;++o)!function(e){n.push(function(){return r[e].apply(null,i)})}(o)}}function wt(){var e=vs;vs=null;for(var t=0;t<e.length;++t)e[t]()}function xt(e,t,r,n){for(var i=0;i<t.changes.length;i++){var o=t.changes[i];"text"==o?kt(e,t):"gutter"==o?Mt(e,t,r,n):"class"==o?Tt(e,t):"widget"==o&&Nt(e,t,n)}t.changes=null}function Ct(e){return e.node==e.text&&(e.node=n("div",null,null,"position: relative"),e.text.parentNode&&e.text.parentNode.replaceChild(e.node,e.text),e.node.appendChild(e.text),gl&&vl<8&&(e.node.style.zIndex=2)),e.node}function St(e,t){var r=t.bgClass?t.bgClass+" "+(t.line.bgClass||""):t.line.bgClass;if(r&&(r+=" CodeMirror-linebackground"),t.background)r?t.background.className=r:(t.background.parentNode.removeChild(t.background),t.background=null);else if(r){var i=Ct(t);t.background=i.insertBefore(n("div",null,r),i.firstChild),e.display.input.setUneditable(t.background)}}function Lt(e,t){var r=e.display.externalMeasured;return r&&r.line==t.line?(e.display.externalMeasured=null,t.measure=r.measure,r.built):st(e,t)}function kt(e,t){var r=t.text.className,n=Lt(e,t);t.text==t.node&&(t.node=n.pre),t.text.parentNode.replaceChild(n.pre,t.text),t.text=n.pre,n.bgClass!=t.bgClass||n.textClass!=t.textClass?(t.bgClass=n.bgClass,t.textClass=n.textClass,Tt(e,t)):r&&(t.text.className=r)}function Tt(e,t){St(e,t),t.line.wrapClass?Ct(t).className=t.line.wrapClass:t.node!=t.text&&(t.node.className="");var r=t.textClass?t.textClass+" "+(t.line.textClass||""):t.line.textClass;t.text.className=r||""}function Mt(e,t,r,i){if(t.gutter&&(t.node.removeChild(t.gutter),t.gutter=null),t.gutterBackground&&(t.node.removeChild(t.gutterBackground),t.gutterBackground=null),t.line.gutterClass){var o=Ct(t);t.gutterBackground=n("div",null,"CodeMirror-gutter-background "+t.line.gutterClass,"left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px; width: "+i.gutterTotalWidth+"px"),e.display.input.setUneditable(t.gutterBackground),o.insertBefore(t.gutterBackground,t.text)}var l=t.line.gutterMarkers;if(e.options.lineNumbers||l){var s=Ct(t),a=t.gutter=n("div",null,"CodeMirror-gutter-wrapper","left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px");if(e.display.input.setUneditable(a),s.insertBefore(a,t.text),t.line.gutterClass&&(a.className+=" "+t.line.gutterClass),!e.options.lineNumbers||l&&l["CodeMirror-linenumbers"]||(t.lineNumber=a.appendChild(n("div",F(e.options,r),"CodeMirror-linenumber CodeMirror-gutter-elt","left: "+i.gutterLeft["CodeMirror-linenumbers"]+"px; width: "+e.display.lineNumInnerWidth+"px"))),l)for(var u=0;u<e.options.gutters.length;++u){var c=e.options.gutters[u],f=l.hasOwnProperty(c)&&l[c];f&&a.appendChild(n("div",[f],"CodeMirror-gutter-elt","left: "+i.gutterLeft[c]+"px; width: "+i.gutterWidth[c]+"px"))}}}function Nt(e,t,r){t.alignable&&(t.alignable=null);for(var n=t.node.firstChild,i=void 0;n;n=i)i=n.nextSibling,"CodeMirror-linewidget"==n.className&&t.node.removeChild(n);At(e,t,r)}function Ot(e,t,r,n){var i=Lt(e,t);return t.text=t.node=i.pre,i.bgClass&&(t.bgClass=i.bgClass),i.textClass&&(t.textClass=i.textClass),Tt(e,t),Mt(e,t,r,n),At(e,t,n),t.node}function At(e,t,r){if(Wt(e,t.line,t,r,!0),t.rest)for(var n=0;n<t.rest.length;n++)Wt(e,t.rest[n],t,r,!1)}function Wt(e,t,r,i,o){if(t.widgets)for(var l=Ct(r),s=0,a=t.widgets;s<a.length;++s){var u=a[s],c=n("div",[u.node],"CodeMirror-linewidget");u.handleMouseEvents||c.setAttribute("cm-ignore-events","true"),Dt(u,c,r,i),e.display.input.setUneditable(c),o&&u.above?l.insertBefore(c,r.gutter||r.text):l.appendChild(c),bt(u,"redraw")}}function Dt(e,t,r,n){if(e.noHScroll){(r.alignable||(r.alignable=[])).push(t);var i=n.wrapperWidth;t.style.left=n.fixedPos+"px",e.coverGutter||(i-=n.gutterTotalWidth,t.style.paddingLeft=n.gutterTotalWidth+"px"),t.style.width=i+"px"}e.coverGutter&&(t.style.zIndex=5,t.style.position="relative",e.noHScroll||(t.style.marginLeft=-n.gutterTotalWidth+"px"))}function Ht(e){if(null!=e.height)return e.height;var t=e.doc.cm;if(!t)return 0;if(!o(document.body,e.node)){var i="position: relative;";e.coverGutter&&(i+="margin-left: -"+t.display.gutters.offsetWidth+"px;"),e.noHScroll&&(i+="width: "+t.display.wrapper.clientWidth+"px;"),r(t.display.measure,n("div",[e.node],null,i))}return e.height=e.node.parentNode.offsetHeight}function Ft(e,t){for(var r=Ee(t);r!=e.wrapper;r=r.parentNode)if(!r||1==r.nodeType&&"true"==r.getAttribute("cm-ignore-events")||r.parentNode==e.sizer&&r!=e.mover)return!0}function Et(e){return e.lineSpace.offsetTop}function Pt(e){return e.mover.offsetHeight-e.lineSpace.offsetHeight}function It(e){if(e.cachedPaddingH)return e.cachedPaddingH;var t=r(e.measure,n("pre","x")),i=window.getComputedStyle?window.getComputedStyle(t):t.currentStyle,o={left:parseInt(i.paddingLeft),right:parseInt(i.paddingRight)};return isNaN(o.left)||isNaN(o.right)||(e.cachedPaddingH=o),o}function zt(e){return Rl-e.display.nativeBarWidth}function Rt(e){return e.display.scroller.clientWidth-zt(e)-e.display.barWidth}function Bt(e){return e.display.scroller.clientHeight-zt(e)-e.display.barHeight}function Gt(e,t,r){var n=e.options.lineWrapping,i=n&&Rt(e);if(!t.measure.heights||n&&t.measure.width!=i){var o=t.measure.heights=[];if(n){t.measure.width=i;for(var l=t.text.firstChild.getClientRects(),s=0;s<l.length-1;s++){var a=l[s],u=l[s+1];Math.abs(a.bottom-u.bottom)>2&&o.push((a.bottom+u.top)/2-r.top)}}o.push(r.bottom-r.top)}}function Ut(e,t,r){if(e.line==t)return{map:e.measure.map,cache:e.measure.cache};for(var n=0;n<e.rest.length;n++)if(e.rest[n]==t)return{map:e.measure.maps[n],cache:e.measure.caches[n]};for(var i=0;i<e.rest.length;i++)if(W(e.rest[i])>r)return{map:e.measure.maps[i],cache:e.measure.caches[i],before:!0}}function Vt(e,t){var n=W(t=fe(t)),i=e.display.externalMeasured=new pt(e.doc,t,n);i.lineN=n;var o=i.built=st(e,i);return i.text=o.pre,r(e.display.lineMeasure,o.pre),i}function Kt(e,t,r,n){return Yt(e,Xt(e,t),r,n)}function jt(e,t){if(t>=e.display.viewFrom&&t<e.display.viewTo)return e.display.view[Lr(e,t)];var r=e.display.externalMeasured;return r&&t>=r.lineN&&t<r.lineN+r.size?r:void 0}function Xt(e,t){var r=W(t),n=jt(e,r);n&&!n.text?n=null:n&&n.changes&&(xt(e,n,r,br(e)),e.curOp.forceUpdate=!0),n||(n=Vt(e,t));var i=Ut(n,t,r);return{line:t,view:n,rect:null,map:i.map,cache:i.cache,before:i.before,hasHeights:!1}}function Yt(e,t,r,n,i){t.before&&(r=-1);var o,l=r+(n||"");return t.cache.hasOwnProperty(l)?o=t.cache[l]:(t.rect||(t.rect=t.view.text.getBoundingClientRect()),t.hasHeights||(Gt(e,t.view,t.rect),t.hasHeights=!0),(o=qt(e,t,r,n)).bogus||(t.cache[l]=o)),{left:o.left,right:o.right,top:i?o.rtop:o.top,bottom:i?o.rbottom:o.bottom}}function _t(e,t,r){for(var n,i,o,l,s,a,u=0;u<e.length;u+=3)if(s=e[u],a=e[u+1],t<s?(i=0,o=1,l="left"):t<a?o=(i=t-s)+1:(u==e.length-3||t==a&&e[u+3]>t)&&(i=(o=a-s)-1,t>=a&&(l="right")),null!=i){if(n=e[u+2],s==a&&r==(n.insertLeft?"left":"right")&&(l=r),"left"==r&&0==i)for(;u&&e[u-2]==e[u-3]&&e[u-1].insertLeft;)n=e[2+(u-=3)],l="left";if("right"==r&&i==a-s)for(;u<e.length-3&&e[u+3]==e[u+4]&&!e[u+5].insertLeft;)n=e[(u+=3)+2],l="right";break}return{node:n,start:i,end:o,collapse:l,coverStart:s,coverEnd:a}}function $t(e,t){var r=ms;if("left"==t)for(var n=0;n<e.length&&(r=e[n]).left==r.right;n++);else for(var i=e.length-1;i>=0&&(r=e[i]).left==r.right;i--);return r}function qt(e,t,r,n){var i,o=_t(t.map,r,n),l=o.node,s=o.start,a=o.end,u=o.collapse;if(3==l.nodeType){for(var c=0;c<4;c++){for(;s&&S(t.line.text.charAt(o.coverStart+s));)--s;for(;o.coverStart+a<o.coverEnd&&S(t.line.text.charAt(o.coverStart+a));)++a;if((i=gl&&vl<9&&0==s&&a==o.coverEnd-o.coverStart?l.parentNode.getBoundingClientRect():$t(Wl(l,s,a).getClientRects(),n)).left||i.right||0==s)break;a=s,s-=1,u="right"}gl&&vl<11&&(i=Zt(e.display.measure,i))}else{s>0&&(u=n="right");var f;i=e.options.lineWrapping&&(f=l.getClientRects()).length>1?f["right"==n?f.length-1:0]:l.getBoundingClientRect()}if(gl&&vl<9&&!s&&(!i||!i.left&&!i.right)){var h=l.parentNode.getClientRects()[0];i=h?{left:h.left,right:h.left+yr(e.display),top:h.top,bottom:h.bottom}:ms}for(var d=i.top-t.rect.top,p=i.bottom-t.rect.top,g=(d+p)/2,v=t.view.measure.heights,m=0;m<v.length-1&&!(g<v[m]);m++);var y=m?v[m-1]:0,b=v[m],w={left:("right"==u?i.right:i.left)-t.rect.left,right:("left"==u?i.left:i.right)-t.rect.left,top:y,bottom:b};return i.left||i.right||(w.bogus=!0),e.options.singleCursorHeightPerLine||(w.rtop=d,w.rbottom=p),w}function Zt(e,t){if(!window.screen||null==screen.logicalXDPI||screen.logicalXDPI==screen.deviceXDPI||!Re(e))return t;var r=screen.logicalXDPI/screen.deviceXDPI,n=screen.logicalYDPI/screen.deviceYDPI;return{left:t.left*r,right:t.right*r,top:t.top*n,bottom:t.bottom*n}}function Qt(e){if(e.measure&&(e.measure.cache={},e.measure.heights=null,e.rest))for(var t=0;t<e.rest.length;t++)e.measure.caches[t]={}}function Jt(e){e.display.externalMeasure=null,t(e.display.lineMeasure);for(var r=0;r<e.display.view.length;r++)Qt(e.display.view[r])}function er(e){Jt(e),e.display.cachedCharWidth=e.display.cachedTextHeight=e.display.cachedPaddingH=null,e.options.lineWrapping||(e.display.maxLineChanged=!0),e.display.lineNumChars=null}function tr(){return bl&&kl?-(document.body.getBoundingClientRect().left-parseInt(getComputedStyle(document.body).marginLeft)):window.pageXOffset||(document.documentElement||document.body).scrollLeft}function rr(){return bl&&kl?-(document.body.getBoundingClientRect().top-parseInt(getComputedStyle(document.body).marginTop)):window.pageYOffset||(document.documentElement||document.body).scrollTop}function nr(e){var t=0;if(e.widgets)for(var r=0;r<e.widgets.length;++r)e.widgets[r].above&&(t+=Ht(e.widgets[r]));return t}function ir(e,t,r,n,i){if(!i){var o=nr(t);r.top+=o,r.bottom+=o}if("line"==n)return r;n||(n="local");var l=ye(t);if("local"==n?l+=Et(e.display):l-=e.display.viewOffset,"page"==n||"window"==n){var s=e.display.lineSpace.getBoundingClientRect();l+=s.top+("window"==n?0:rr());var a=s.left+("window"==n?0:tr());r.left+=a,r.right+=a}return r.top+=l,r.bottom+=l,r}function or(e,t,r){if("div"==r)return t;var n=t.left,i=t.top;if("page"==r)n-=tr(),i-=rr();else if("local"==r||!r){var o=e.display.sizer.getBoundingClientRect();n+=o.left,i+=o.top}var l=e.display.lineSpace.getBoundingClientRect();return{left:n-l.left,top:i-l.top}}function lr(e,t,r,n,i){return n||(n=M(e.doc,t.line)),ir(e,n,Kt(e,n,t.ch,i),r)}function sr(e,t,r,n,i,o){function l(t,l){var s=Yt(e,i,t,l?"right":"left",o);return l?s.left=s.right:s.right=s.left,ir(e,n,s,r)}function s(e,t,r){var n=1==a[t].level;return l(r?e-1:e,n!=r)}n=n||M(e.doc,t.line),i||(i=Xt(e,n));var a=Se(n,e.doc.direction),u=t.ch,c=t.sticky;if(u>=n.text.length?(u=n.text.length,c="before"):u<=0&&(u=0,c="after"),!a)return l("before"==c?u-1:u,"before"==c);var f=Ce(a,u,c),h=$l,d=s(u,f,"before"==c);return null!=h&&(d.other=s(u,h,"before"!=c)),d}function ar(e,t){var r=0;t=U(e.doc,t),e.options.lineWrapping||(r=yr(e.display)*t.ch);var n=M(e.doc,t.line),i=ye(n)+Et(e.display);return{left:r,right:r,top:i,bottom:i+n.height}}function ur(e,t,r,n,i){var o=E(e,t,r);return o.xRel=i,n&&(o.outside=!0),o}function cr(e,t,r){var n=e.doc;if((r+=e.display.viewOffset)<0)return ur(n.first,0,null,!0,-1);var i=D(n,r),o=n.first+n.size-1;if(i>o)return ur(n.first+n.size-1,M(n,o).text.length,null,!0,1);t<0&&(t=0);for(var l=M(n,i);;){var s=pr(e,l,i,t,r),a=ue(l),u=a&&a.find(0,!0);if(!a||!(s.ch>u.from.ch||s.ch==u.from.ch&&s.xRel>0))return s;i=W(l=u.to.line)}}function fr(e,t,r,n){n-=nr(t);var i=t.text.length,o=k(function(t){return Yt(e,r,t-1).bottom<=n},i,0);return i=k(function(t){return Yt(e,r,t).top>n},o,i),{begin:o,end:i}}function hr(e,t,r,n){return r||(r=Xt(e,t)),fr(e,t,r,ir(e,t,Yt(e,r,n),"line").top)}function dr(e,t,r,n){return!(e.bottom<=r)&&(e.top>r||(n?e.left:e.right)>t)}function pr(e,t,r,n,i){i-=ye(t);var o=Xt(e,t),l=nr(t),s=0,a=t.text.length,u=!0,c=Se(t,e.doc.direction);if(c){var f=(e.options.lineWrapping?vr:gr)(e,t,r,o,c,n,i);s=(u=1!=f.level)?f.from:f.to-1,a=u?f.to:f.from-1}var h,d,p=null,g=null,v=k(function(t){var r=Yt(e,o,t);return r.top+=l,r.bottom+=l,!!dr(r,n,i,!1)&&(r.top<=i&&r.left<=n&&(p=t,g=r),!0)},s,a),m=!1;if(g){var y=n-g.left<g.right-n,b=y==u;v=p+(b?0:1),d=b?"after":"before",h=y?g.left:g.right}else{u||v!=a&&v!=s||v++,d=0==v?"after":v==t.text.length?"before":Yt(e,o,v-(u?1:0)).bottom+l<=i==u?"after":"before";var w=sr(e,E(r,v,d),"line",t,o);h=w.left,m=i<w.top||i>=w.bottom}return v=L(t.text,v,1),ur(r,v,d,m,n-h)}function gr(e,t,r,n,i,o,l){var s=k(function(s){var a=i[s],u=1!=a.level;return dr(sr(e,E(r,u?a.to:a.from,u?"before":"after"),"line",t,n),o,l,!0)},0,i.length-1),a=i[s];if(s>0){var u=1!=a.level,c=sr(e,E(r,u?a.from:a.to,u?"after":"before"),"line",t,n);dr(c,o,l,!0)&&c.top>l&&(a=i[s-1])}return a}function vr(e,t,r,n,i,o,l){for(var s=fr(e,t,n,l),a=s.begin,u=s.end,c=null,f=null,h=0;h<i.length;h++){var d=i[h];if(!(d.from>=u||d.to<=a)){var p=Yt(e,n,1!=d.level?Math.min(u,d.to)-1:Math.max(a,d.from)).right,g=p<o?o-p+1e9:p-o;(!c||f>g)&&(c=d,f=g)}}return c||(c=i[i.length-1]),c.from<a&&(c={from:a,to:c.to,level:c.level}),c.to>u&&(c={from:c.from,to:u,level:c.level}),c}function mr(e){if(null!=e.cachedTextHeight)return e.cachedTextHeight;if(null==hs){hs=n("pre");for(var i=0;i<49;++i)hs.appendChild(document.createTextNode("x")),hs.appendChild(n("br"));hs.appendChild(document.createTextNode("x"))}r(e.measure,hs);var o=hs.offsetHeight/50;return o>3&&(e.cachedTextHeight=o),t(e.measure),o||1}function yr(e){if(null!=e.cachedCharWidth)return e.cachedCharWidth;var t=n("span","xxxxxxxxxx"),i=n("pre",[t]);r(e.measure,i);var o=t.getBoundingClientRect(),l=(o.right-o.left)/10;return l>2&&(e.cachedCharWidth=l),l||10}function br(e){for(var t=e.display,r={},n={},i=t.gutters.clientLeft,o=t.gutters.firstChild,l=0;o;o=o.nextSibling,++l)r[e.options.gutters[l]]=o.offsetLeft+o.clientLeft+i,n[e.options.gutters[l]]=o.clientWidth;return{fixedPos:wr(t),gutterTotalWidth:t.gutters.offsetWidth,gutterLeft:r,gutterWidth:n,wrapperWidth:t.wrapper.clientWidth}}function wr(e){return e.scroller.getBoundingClientRect().left-e.sizer.getBoundingClientRect().left}function xr(e){var t=mr(e.display),r=e.options.lineWrapping,n=r&&Math.max(5,e.display.scroller.clientWidth/yr(e.display)-3);return function(i){if(ve(e.doc,i))return 0;var o=0;if(i.widgets)for(var l=0;l<i.widgets.length;l++)i.widgets[l].height&&(o+=i.widgets[l].height);return r?o+(Math.ceil(i.text.length/n)||1)*t:o+t}}function Cr(e){var t=e.doc,r=xr(e);t.iter(function(e){var t=r(e);t!=e.height&&A(e,t)})}function Sr(e,t,r,n){var i=e.display;if(!r&&"true"==Ee(t).getAttribute("cm-not-content"))return null;var o,l,s=i.lineSpace.getBoundingClientRect();try{o=t.clientX-s.left,l=t.clientY-s.top}catch(t){return null}var a,u=cr(e,o,l);if(n&&1==u.xRel&&(a=M(e.doc,u.line).text).length==u.ch){var c=f(a,a.length,e.options.tabSize)-a.length;u=E(u.line,Math.max(0,Math.round((o-It(e.display).left)/yr(e.display))-c))}return u}function Lr(e,t){if(t>=e.display.viewTo)return null;if((t-=e.display.viewFrom)<0)return null;for(var r=e.display.view,n=0;n<r.length;n++)if((t-=r[n].size)<0)return n}function kr(e){e.display.input.showSelection(e.display.input.prepareSelection())}function Tr(e,t){void 0===t&&(t=!0);for(var r=e.doc,n={},i=n.cursors=document.createDocumentFragment(),o=n.selection=document.createDocumentFragment(),l=0;l<r.sel.ranges.length;l++)if(t||l!=r.sel.primIndex){var s=r.sel.ranges[l];if(!(s.from().line>=e.display.viewTo||s.to().line<e.display.viewFrom)){var a=s.empty();(a||e.options.showCursorWhenSelecting)&&Mr(e,s.head,i),a||Or(e,s,o)}}return n}function Mr(e,t,r){var i=sr(e,t,"div",null,null,!e.options.singleCursorHeightPerLine),o=r.appendChild(n("div"," ","CodeMirror-cursor"));if(o.style.left=i.left+"px",o.style.top=i.top+"px",o.style.height=Math.max(0,i.bottom-i.top)*e.options.cursorHeight+"px",i.other){var l=r.appendChild(n("div"," ","CodeMirror-cursor CodeMirror-secondarycursor"));l.style.display="",l.style.left=i.other.left+"px",l.style.top=i.other.top+"px",l.style.height=.85*(i.other.bottom-i.other.top)+"px"}}function Nr(e,t){return e.top-t.top||e.left-t.left}function Or(e,t,r){function i(e,t,r,i){t<0&&(t=0),t=Math.round(t),i=Math.round(i),a.appendChild(n("div",null,"CodeMirror-selected","position: absolute; left: "+e+"px;\n                             top: "+t+"px; width: "+(null==r?f-e:r)+"px;\n                             height: "+(i-t)+"px"))}function o(t,r,n){function o(r,n){return lr(e,E(t,r),"div",u,n)}var l,a,u=M(s,t),h=u.text.length,d=Se(u,s.direction);return xe(d,r||0,null==n?h:n,function(t,s,p,g){var v=o(t,"ltr"==p?"left":"right"),m=o(s-1,"ltr"==p?"right":"left");if("ltr"==p){var y=null==r&&0==t?c:v.left,b=null==n&&s==h?f:m.right;m.top-v.top<=3?i(y,m.top,b-y,m.bottom):(i(y,v.top,null,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top),i(c,m.top,m.right,m.bottom))}else if(t<s){var w=null==r&&0==t?f:v.right,x=null==n&&s==h?c:m.left;if(m.top-v.top<=3)i(x,m.top,w-x,m.bottom);else{var C=c;if(g){var S=hr(e,u,null,t).end;C=o(S-(/\s/.test(u.text.charAt(S-1))?2:1),"left").left}i(C,v.top,w-C,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top);var L=null;d.length,L=o(hr(e,u,null,s).begin,"right").right-x,i(x,m.top,L,m.bottom)}}(!l||Nr(v,l)<0)&&(l=v),Nr(m,l)<0&&(l=m),(!a||Nr(v,a)<0)&&(a=v),Nr(m,a)<0&&(a=m)}),{start:l,end:a}}var l=e.display,s=e.doc,a=document.createDocumentFragment(),u=It(e.display),c=u.left,f=Math.max(l.sizerWidth,Rt(e)-l.sizer.offsetLeft)-u.right,h=t.from(),d=t.to();if(h.line==d.line)o(h.line,h.ch,d.ch);else{var p=M(s,h.line),g=M(s,d.line),v=fe(p)==fe(g),m=o(h.line,h.ch,v?p.text.length+1:null).end,y=o(d.line,v?0:null,d.ch).start;v&&(m.top<y.top-2?(i(m.right,m.top,null,m.bottom),i(c,y.top,y.left,y.bottom)):i(m.right,m.top,y.left-m.right,m.bottom)),m.bottom<y.top&&i(c,m.bottom,null,y.top)}r.appendChild(a)}function Ar(e){if(e.state.focused){var t=e.display;clearInterval(t.blinker);var r=!0;t.cursorDiv.style.visibility="",e.options.cursorBlinkRate>0?t.blinker=setInterval(function(){return t.cursorDiv.style.visibility=(r=!r)?"":"hidden"},e.options.cursorBlinkRate):e.options.cursorBlinkRate<0&&(t.cursorDiv.style.visibility="hidden")}}function Wr(e){e.state.focused||(e.display.input.focus(),Hr(e))}function Dr(e){e.state.delayingBlurEvent=!0,setTimeout(function(){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1,Fr(e))},100)}function Hr(e,t){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1),"nocursor"!=e.options.readOnly&&(e.state.focused||(Te(e,"focus",e,t),e.state.focused=!0,s(e.display.wrapper,"CodeMirror-focused"),e.curOp||e.display.selForContextMenu==e.doc.sel||(e.display.input.reset(),ml&&setTimeout(function(){return e.display.input.reset(!0)},20)),e.display.input.receivedFocus()),Ar(e))}function Fr(e,t){e.state.delayingBlurEvent||(e.state.focused&&(Te(e,"blur",e,t),e.state.focused=!1,Fl(e.display.wrapper,"CodeMirror-focused")),clearInterval(e.display.blinker),setTimeout(function(){e.state.focused||(e.display.shift=!1)},150))}function Er(e){for(var t=e.display,r=t.lineDiv.offsetTop,n=0;n<t.view.length;n++){var i=t.view[n],o=void 0;if(!i.hidden){if(gl&&vl<8){var l=i.node.offsetTop+i.node.offsetHeight;o=l-r,r=l}else{var s=i.node.getBoundingClientRect();o=s.bottom-s.top}var a=i.line.height-o;if(o<2&&(o=mr(t)),(a>.005||a<-.005)&&(A(i.line,o),Pr(i.line),i.rest))for(var u=0;u<i.rest.length;u++)Pr(i.rest[u])}}}function Pr(e){if(e.widgets)for(var t=0;t<e.widgets.length;++t)e.widgets[t].height=e.widgets[t].node.parentNode.offsetHeight}function Ir(e,t,r){var n=r&&null!=r.top?Math.max(0,r.top):e.scroller.scrollTop;n=Math.floor(n-Et(e));var i=r&&null!=r.bottom?r.bottom:n+e.wrapper.clientHeight,o=D(t,n),l=D(t,i);if(r&&r.ensure){var s=r.ensure.from.line,a=r.ensure.to.line;s<o?(o=s,l=D(t,ye(M(t,s))+e.wrapper.clientHeight)):Math.min(a,t.lastLine())>=l&&(o=D(t,ye(M(t,a))-e.wrapper.clientHeight),l=a)}return{from:o,to:Math.max(l,o+1)}}function zr(e){var t=e.display,r=t.view;if(t.alignWidgets||t.gutters.firstChild&&e.options.fixedGutter){for(var n=wr(t)-t.scroller.scrollLeft+e.doc.scrollLeft,i=t.gutters.offsetWidth,o=n+"px",l=0;l<r.length;l++)if(!r[l].hidden){e.options.fixedGutter&&(r[l].gutter&&(r[l].gutter.style.left=o),r[l].gutterBackground&&(r[l].gutterBackground.style.left=o));var s=r[l].alignable;if(s)for(var a=0;a<s.length;a++)s[a].style.left=o}e.options.fixedGutter&&(t.gutters.style.left=n+i+"px")}}function Rr(e){if(!e.options.lineNumbers)return!1;var t=e.doc,r=F(e.options,t.first+t.size-1),i=e.display;if(r.length!=i.lineNumChars){var o=i.measure.appendChild(n("div",[n("div",r)],"CodeMirror-linenumber CodeMirror-gutter-elt")),l=o.firstChild.offsetWidth,s=o.offsetWidth-l;return i.lineGutter.style.width="",i.lineNumInnerWidth=Math.max(l,i.lineGutter.offsetWidth-s)+1,i.lineNumWidth=i.lineNumInnerWidth+s,i.lineNumChars=i.lineNumInnerWidth?r.length:-1,i.lineGutter.style.width=i.lineNumWidth+"px",Wn(e),!0}return!1}function Br(e,t){if(!Me(e,"scrollCursorIntoView")){var r=e.display,i=r.sizer.getBoundingClientRect(),o=null;if(t.top+i.top<0?o=!0:t.bottom+i.top>(window.innerHeight||document.documentElement.clientHeight)&&(o=!1),null!=o&&!Sl){var l=n("div","​",null,"position: absolute;\n                         top: "+(t.top-r.viewOffset-Et(e.display))+"px;\n                         height: "+(t.bottom-t.top+zt(e)+r.barHeight)+"px;\n                         left: "+t.left+"px; width: "+Math.max(2,t.right-t.left)+"px;");e.display.lineSpace.appendChild(l),l.scrollIntoView(o),e.display.lineSpace.removeChild(l)}}}function Gr(e,t,r,n){null==n&&(n=0);var i;e.options.lineWrapping||t!=r||(r="before"==(t=t.ch?E(t.line,"before"==t.sticky?t.ch-1:t.ch,"after"):t).sticky?E(t.line,t.ch+1,"before"):t);for(var o=0;o<5;o++){var l=!1,s=sr(e,t),a=r&&r!=t?sr(e,r):s,u=Vr(e,i={left:Math.min(s.left,a.left),top:Math.min(s.top,a.top)-n,right:Math.max(s.left,a.left),bottom:Math.max(s.bottom,a.bottom)+n}),c=e.doc.scrollTop,f=e.doc.scrollLeft;if(null!=u.scrollTop&&(qr(e,u.scrollTop),Math.abs(e.doc.scrollTop-c)>1&&(l=!0)),null!=u.scrollLeft&&(Qr(e,u.scrollLeft),Math.abs(e.doc.scrollLeft-f)>1&&(l=!0)),!l)break}return i}function Ur(e,t){var r=Vr(e,t);null!=r.scrollTop&&qr(e,r.scrollTop),null!=r.scrollLeft&&Qr(e,r.scrollLeft)}function Vr(e,t){var r=e.display,n=mr(e.display);t.top<0&&(t.top=0);var i=e.curOp&&null!=e.curOp.scrollTop?e.curOp.scrollTop:r.scroller.scrollTop,o=Bt(e),l={};t.bottom-t.top>o&&(t.bottom=t.top+o);var s=e.doc.height+Pt(r),a=t.top<n,u=t.bottom>s-n;if(t.top<i)l.scrollTop=a?0:t.top;else if(t.bottom>i+o){var c=Math.min(t.top,(u?s:t.bottom)-o);c!=i&&(l.scrollTop=c)}var f=e.curOp&&null!=e.curOp.scrollLeft?e.curOp.scrollLeft:r.scroller.scrollLeft,h=Rt(e)-(e.options.fixedGutter?r.gutters.offsetWidth:0),d=t.right-t.left>h;return d&&(t.right=t.left+h),t.left<10?l.scrollLeft=0:t.left<f?l.scrollLeft=Math.max(0,t.left-(d?0:10)):t.right>h+f-3&&(l.scrollLeft=t.right+(d?0:10)-h),l}function Kr(e,t){null!=t&&(_r(e),e.curOp.scrollTop=(null==e.curOp.scrollTop?e.doc.scrollTop:e.curOp.scrollTop)+t)}function jr(e){_r(e);var t=e.getCursor();e.curOp.scrollToPos={from:t,to:t,margin:e.options.cursorScrollMargin}}function Xr(e,t,r){null==t&&null==r||_r(e),null!=t&&(e.curOp.scrollLeft=t),null!=r&&(e.curOp.scrollTop=r)}function Yr(e,t){_r(e),e.curOp.scrollToPos=t}function _r(e){var t=e.curOp.scrollToPos;t&&(e.curOp.scrollToPos=null,$r(e,ar(e,t.from),ar(e,t.to),t.margin))}function $r(e,t,r,n){var i=Vr(e,{left:Math.min(t.left,r.left),top:Math.min(t.top,r.top)-n,right:Math.max(t.right,r.right),bottom:Math.max(t.bottom,r.bottom)+n});Xr(e,i.scrollLeft,i.scrollTop)}function qr(e,t){Math.abs(e.doc.scrollTop-t)<2||(fl||On(e,{top:t}),Zr(e,t,!0),fl&&On(e),Cn(e,100))}function Zr(e,t,r){t=Math.min(e.display.scroller.scrollHeight-e.display.scroller.clientHeight,t),(e.display.scroller.scrollTop!=t||r)&&(e.doc.scrollTop=t,e.display.scrollbars.setScrollTop(t),e.display.scroller.scrollTop!=t&&(e.display.scroller.scrollTop=t))}function Qr(e,t,r,n){t=Math.min(t,e.display.scroller.scrollWidth-e.display.scroller.clientWidth),(r?t==e.doc.scrollLeft:Math.abs(e.doc.scrollLeft-t)<2)&&!n||(e.doc.scrollLeft=t,zr(e),e.display.scroller.scrollLeft!=t&&(e.display.scroller.scrollLeft=t),e.display.scrollbars.setScrollLeft(t))}function Jr(e){var t=e.display,r=t.gutters.offsetWidth,n=Math.round(e.doc.height+Pt(e.display));return{clientHeight:t.scroller.clientHeight,viewHeight:t.wrapper.clientHeight,scrollWidth:t.scroller.scrollWidth,clientWidth:t.scroller.clientWidth,viewWidth:t.wrapper.clientWidth,barLeft:e.options.fixedGutter?r:0,docHeight:n,scrollHeight:n+zt(e)+t.barHeight,nativeBarWidth:t.nativeBarWidth,gutterWidth:r}}function en(e,t){t||(t=Jr(e));var r=e.display.barWidth,n=e.display.barHeight;tn(e,t);for(var i=0;i<4&&r!=e.display.barWidth||n!=e.display.barHeight;i++)r!=e.display.barWidth&&e.options.lineWrapping&&Er(e),tn(e,Jr(e)),r=e.display.barWidth,n=e.display.barHeight}function tn(e,t){var r=e.display,n=r.scrollbars.update(t);r.sizer.style.paddingRight=(r.barWidth=n.right)+"px",r.sizer.style.paddingBottom=(r.barHeight=n.bottom)+"px",r.heightForcer.style.borderBottom=n.bottom+"px solid transparent",n.right&&n.bottom?(r.scrollbarFiller.style.display="block",r.scrollbarFiller.style.height=n.bottom+"px",r.scrollbarFiller.style.width=n.right+"px"):r.scrollbarFiller.style.display="",n.bottom&&e.options.coverGutterNextToScrollbar&&e.options.fixedGutter?(r.gutterFiller.style.display="block",r.gutterFiller.style.height=n.bottom+"px",r.gutterFiller.style.width=t.gutterWidth+"px"):r.gutterFiller.style.display=""}function rn(e){e.display.scrollbars&&(e.display.scrollbars.clear(),e.display.scrollbars.addClass&&Fl(e.display.wrapper,e.display.scrollbars.addClass)),e.display.scrollbars=new ws[e.options.scrollbarStyle](function(t){e.display.wrapper.insertBefore(t,e.display.scrollbarFiller),Ql(t,"mousedown",function(){e.state.focused&&setTimeout(function(){return e.display.input.focus()},0)}),t.setAttribute("cm-not-content","true")},function(t,r){"horizontal"==r?Qr(e,t):qr(e,t)},e),e.display.scrollbars.addClass&&s(e.display.wrapper,e.display.scrollbars.addClass)}function nn(e){e.curOp={cm:e,viewChanged:!1,startHeight:e.doc.height,forceUpdate:!1,updateInput:null,typing:!1,changeObjs:null,cursorActivityHandlers:null,cursorActivityCalled:0,selectionChanged:!1,updateMaxLine:!1,scrollLeft:null,scrollTop:null,scrollToPos:null,focus:!1,id:++xs},vt(e.curOp)}function on(e){yt(e.curOp,function(e){for(var t=0;t<e.ops.length;t++)e.ops[t].cm.curOp=null;ln(e)})}function ln(e){for(var t=e.ops,r=0;r<t.length;r++)sn(t[r]);for(var n=0;n<t.length;n++)an(t[n]);for(var i=0;i<t.length;i++)un(t[i]);for(var o=0;o<t.length;o++)cn(t[o]);for(var l=0;l<t.length;l++)fn(t[l])}function sn(e){var t=e.cm,r=t.display;Ln(t),e.updateMaxLine&&we(t),e.mustUpdate=e.viewChanged||e.forceUpdate||null!=e.scrollTop||e.scrollToPos&&(e.scrollToPos.from.line<r.viewFrom||e.scrollToPos.to.line>=r.viewTo)||r.maxLineChanged&&t.options.lineWrapping,e.update=e.mustUpdate&&new Cs(t,e.mustUpdate&&{top:e.scrollTop,ensure:e.scrollToPos},e.forceUpdate)}function an(e){e.updatedDisplay=e.mustUpdate&&Mn(e.cm,e.update)}function un(e){var t=e.cm,r=t.display;e.updatedDisplay&&Er(t),e.barMeasure=Jr(t),r.maxLineChanged&&!t.options.lineWrapping&&(e.adjustWidthTo=Kt(t,r.maxLine,r.maxLine.text.length).left+3,t.display.sizerWidth=e.adjustWidthTo,e.barMeasure.scrollWidth=Math.max(r.scroller.clientWidth,r.sizer.offsetLeft+e.adjustWidthTo+zt(t)+t.display.barWidth),e.maxScrollLeft=Math.max(0,r.sizer.offsetLeft+e.adjustWidthTo-Rt(t))),(e.updatedDisplay||e.selectionChanged)&&(e.preparedSelection=r.input.prepareSelection())}function cn(e){var t=e.cm;null!=e.adjustWidthTo&&(t.display.sizer.style.minWidth=e.adjustWidthTo+"px",e.maxScrollLeft<t.doc.scrollLeft&&Qr(t,Math.min(t.display.scroller.scrollLeft,e.maxScrollLeft),!0),t.display.maxLineChanged=!1);var r=e.focus&&e.focus==l();e.preparedSelection&&t.display.input.showSelection(e.preparedSelection,r),(e.updatedDisplay||e.startHeight!=t.doc.height)&&en(t,e.barMeasure),e.updatedDisplay&&Dn(t,e.barMeasure),e.selectionChanged&&Ar(t),t.state.focused&&e.updateInput&&t.display.input.reset(e.typing),r&&Wr(e.cm)}function fn(e){var t=e.cm,r=t.display,n=t.doc;e.updatedDisplay&&Nn(t,e.update),null==r.wheelStartX||null==e.scrollTop&&null==e.scrollLeft&&!e.scrollToPos||(r.wheelStartX=r.wheelStartY=null),null!=e.scrollTop&&Zr(t,e.scrollTop,e.forceScroll),null!=e.scrollLeft&&Qr(t,e.scrollLeft,!0,!0),e.scrollToPos&&Br(t,Gr(t,U(n,e.scrollToPos.from),U(n,e.scrollToPos.to),e.scrollToPos.margin));var i=e.maybeHiddenMarkers,o=e.maybeUnhiddenMarkers;if(i)for(var l=0;l<i.length;++l)i[l].lines.length||Te(i[l],"hide");if(o)for(var s=0;s<o.length;++s)o[s].lines.length&&Te(o[s],"unhide");r.wrapper.offsetHeight&&(n.scrollTop=t.display.scroller.scrollTop),e.changeObjs&&Te(t,"changes",t,e.changeObjs),e.update&&e.update.finish()}function hn(e,t){if(e.curOp)return t();nn(e);try{return t()}finally{on(e)}}function dn(e,t){return function(){if(e.curOp)return t.apply(e,arguments);nn(e);try{return t.apply(e,arguments)}finally{on(e)}}}function pn(e){return function(){if(this.curOp)return e.apply(this,arguments);nn(this);try{return e.apply(this,arguments)}finally{on(this)}}}function gn(e){return function(){var t=this.cm;if(!t||t.curOp)return e.apply(this,arguments);nn(t);try{return e.apply(this,arguments)}finally{on(t)}}}function vn(e,t,r,n){null==t&&(t=e.doc.first),null==r&&(r=e.doc.first+e.doc.size),n||(n=0);var i=e.display;if(n&&r<i.viewTo&&(null==i.updateLineNumbers||i.updateLineNumbers>t)&&(i.updateLineNumbers=t),e.curOp.viewChanged=!0,t>=i.viewTo)_l&&pe(e.doc,t)<i.viewTo&&yn(e);else if(r<=i.viewFrom)_l&&ge(e.doc,r+n)>i.viewFrom?yn(e):(i.viewFrom+=n,i.viewTo+=n);else if(t<=i.viewFrom&&r>=i.viewTo)yn(e);else if(t<=i.viewFrom){var o=bn(e,r,r+n,1);o?(i.view=i.view.slice(o.index),i.viewFrom=o.lineN,i.viewTo+=n):yn(e)}else if(r>=i.viewTo){var l=bn(e,t,t,-1);l?(i.view=i.view.slice(0,l.index),i.viewTo=l.lineN):yn(e)}else{var s=bn(e,t,t,-1),a=bn(e,r,r+n,1);s&&a?(i.view=i.view.slice(0,s.index).concat(gt(e,s.lineN,a.lineN)).concat(i.view.slice(a.index)),i.viewTo+=n):yn(e)}var u=i.externalMeasured;u&&(r<u.lineN?u.lineN+=n:t<u.lineN+u.size&&(i.externalMeasured=null))}function mn(e,t,r){e.curOp.viewChanged=!0;var n=e.display,i=e.display.externalMeasured;if(i&&t>=i.lineN&&t<i.lineN+i.size&&(n.externalMeasured=null),!(t<n.viewFrom||t>=n.viewTo)){var o=n.view[Lr(e,t)];if(null!=o.node){var l=o.changes||(o.changes=[]);-1==h(l,r)&&l.push(r)}}}function yn(e){e.display.viewFrom=e.display.viewTo=e.doc.first,e.display.view=[],e.display.viewOffset=0}function bn(e,t,r,n){var i,o=Lr(e,t),l=e.display.view;if(!_l||r==e.doc.first+e.doc.size)return{index:o,lineN:r};for(var s=e.display.viewFrom,a=0;a<o;a++)s+=l[a].size;if(s!=t){if(n>0){if(o==l.length-1)return null;i=s+l[o].size-t,o++}else i=s-t;t+=i,r+=i}for(;pe(e.doc,r)!=r;){if(o==(n<0?0:l.length-1))return null;r+=n*l[o-(n<0?1:0)].size,o+=n}return{index:o,lineN:r}}function wn(e,t,r){var n=e.display;0==n.view.length||t>=n.viewTo||r<=n.viewFrom?(n.view=gt(e,t,r),n.viewFrom=t):(n.viewFrom>t?n.view=gt(e,t,n.viewFrom).concat(n.view):n.viewFrom<t&&(n.view=n.view.slice(Lr(e,t))),n.viewFrom=t,n.viewTo<r?n.view=n.view.concat(gt(e,n.viewTo,r)):n.viewTo>r&&(n.view=n.view.slice(0,Lr(e,r)))),n.viewTo=r}function xn(e){for(var t=e.display.view,r=0,n=0;n<t.length;n++){var i=t[n];i.hidden||i.node&&!i.changes||++r}return r}function Cn(e,t){e.doc.highlightFrontier<e.display.viewTo&&e.state.highlight.set(t,u(Sn,e))}function Sn(e){var t=e.doc;if(!(t.highlightFrontier>=e.display.viewTo)){var r=+new Date+e.options.workTime,n=$e(e,t.highlightFrontier),i=[];t.iter(n.line,Math.min(t.first+t.size,e.display.viewTo+500),function(o){if(n.line>=e.display.viewFrom){var l=o.styles,s=o.text.length>e.options.maxHighlightLength?Ke(t.mode,n.state):null,a=Ye(e,o,n,!0);s&&(n.state=s),o.styles=a.styles;var u=o.styleClasses,c=a.classes;c?o.styleClasses=c:u&&(o.styleClasses=null);for(var f=!l||l.length!=o.styles.length||u!=c&&(!u||!c||u.bgClass!=c.bgClass||u.textClass!=c.textClass),h=0;!f&&h<l.length;++h)f=l[h]!=o.styles[h];f&&i.push(n.line),o.stateAfter=n.save(),n.nextLine()}else o.text.length<=e.options.maxHighlightLength&&qe(e,o.text,n),o.stateAfter=n.line%5==0?n.save():null,n.nextLine();if(+new Date>r)return Cn(e,e.options.workDelay),!0}),t.highlightFrontier=n.line,t.modeFrontier=Math.max(t.modeFrontier,n.line),i.length&&hn(e,function(){for(var t=0;t<i.length;t++)mn(e,i[t],"text")})}}function Ln(e){var t=e.display;!t.scrollbarsClipped&&t.scroller.offsetWidth&&(t.nativeBarWidth=t.scroller.offsetWidth-t.scroller.clientWidth,t.heightForcer.style.height=zt(e)+"px",t.sizer.style.marginBottom=-t.nativeBarWidth+"px",t.sizer.style.borderRightWidth=zt(e)+"px",t.scrollbarsClipped=!0)}function kn(e){if(e.hasFocus())return null;var t=l();if(!t||!o(e.display.lineDiv,t))return null;var r={activeElt:t};if(window.getSelection){var n=window.getSelection();n.anchorNode&&n.extend&&o(e.display.lineDiv,n.anchorNode)&&(r.anchorNode=n.anchorNode,r.anchorOffset=n.anchorOffset,r.focusNode=n.focusNode,r.focusOffset=n.focusOffset)}return r}function Tn(e){if(e&&e.activeElt&&e.activeElt!=l()&&(e.activeElt.focus(),e.anchorNode&&o(document.body,e.anchorNode)&&o(document.body,e.focusNode))){var t=window.getSelection(),r=document.createRange();r.setEnd(e.anchorNode,e.anchorOffset),r.collapse(!1),t.removeAllRanges(),t.addRange(r),t.extend(e.focusNode,e.focusOffset)}}function Mn(e,r){var n=e.display,i=e.doc;if(r.editorIsHidden)return yn(e),!1;if(!r.force&&r.visible.from>=n.viewFrom&&r.visible.to<=n.viewTo&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo)&&n.renderedView==n.view&&0==xn(e))return!1;Rr(e)&&(yn(e),r.dims=br(e));var o=i.first+i.size,l=Math.max(r.visible.from-e.options.viewportMargin,i.first),s=Math.min(o,r.visible.to+e.options.viewportMargin);n.viewFrom<l&&l-n.viewFrom<20&&(l=Math.max(i.first,n.viewFrom)),n.viewTo>s&&n.viewTo-s<20&&(s=Math.min(o,n.viewTo)),_l&&(l=pe(e.doc,l),s=ge(e.doc,s));var a=l!=n.viewFrom||s!=n.viewTo||n.lastWrapHeight!=r.wrapperHeight||n.lastWrapWidth!=r.wrapperWidth;wn(e,l,s),n.viewOffset=ye(M(e.doc,n.viewFrom)),e.display.mover.style.top=n.viewOffset+"px";var u=xn(e);if(!a&&0==u&&!r.force&&n.renderedView==n.view&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo))return!1;var c=kn(e);return u>4&&(n.lineDiv.style.display="none"),An(e,n.updateLineNumbers,r.dims),u>4&&(n.lineDiv.style.display=""),n.renderedView=n.view,Tn(c),t(n.cursorDiv),t(n.selectionDiv),n.gutters.style.height=n.sizer.style.minHeight=0,a&&(n.lastWrapHeight=r.wrapperHeight,n.lastWrapWidth=r.wrapperWidth,Cn(e,400)),n.updateLineNumbers=null,!0}function Nn(e,t){for(var r=t.viewport,n=!0;(n&&e.options.lineWrapping&&t.oldDisplayWidth!=Rt(e)||(r&&null!=r.top&&(r={top:Math.min(e.doc.height+Pt(e.display)-Bt(e),r.top)}),t.visible=Ir(e.display,e.doc,r),!(t.visible.from>=e.display.viewFrom&&t.visible.to<=e.display.viewTo)))&&Mn(e,t);n=!1){Er(e);var i=Jr(e);kr(e),en(e,i),Dn(e,i),t.force=!1}t.signal(e,"update",e),e.display.viewFrom==e.display.reportedViewFrom&&e.display.viewTo==e.display.reportedViewTo||(t.signal(e,"viewportChange",e,e.display.viewFrom,e.display.viewTo),e.display.reportedViewFrom=e.display.viewFrom,e.display.reportedViewTo=e.display.viewTo)}function On(e,t){var r=new Cs(e,t);if(Mn(e,r)){Er(e),Nn(e,r);var n=Jr(e);kr(e),en(e,n),Dn(e,n),r.finish()}}function An(e,r,n){function i(t){var r=t.nextSibling;return ml&&Ml&&e.display.currentWheelTarget==t?t.style.display="none":t.parentNode.removeChild(t),r}for(var o=e.display,l=e.options.lineNumbers,s=o.lineDiv,a=s.firstChild,u=o.view,c=o.viewFrom,f=0;f<u.length;f++){var d=u[f];if(d.hidden);else if(d.node&&d.node.parentNode==s){for(;a!=d.node;)a=i(a);var p=l&&null!=r&&r<=c&&d.lineNumber;d.changes&&(h(d.changes,"gutter")>-1&&(p=!1),xt(e,d,c,n)),p&&(t(d.lineNumber),d.lineNumber.appendChild(document.createTextNode(F(e.options,c)))),a=d.node.nextSibling}else{var g=Ot(e,d,c,n);s.insertBefore(g,a)}c+=d.size}for(;a;)a=i(a)}function Wn(e){var t=e.display.gutters.offsetWidth;e.display.sizer.style.marginLeft=t+"px"}function Dn(e,t){e.display.sizer.style.minHeight=t.docHeight+"px",e.display.heightForcer.style.top=t.docHeight+"px",e.display.gutters.style.height=t.docHeight+e.display.barHeight+zt(e)+"px"}function Hn(e){var r=e.display.gutters,i=e.options.gutters;t(r);for(var o=0;o<i.length;++o){var l=i[o],s=r.appendChild(n("div",null,"CodeMirror-gutter "+l));"CodeMirror-linenumbers"==l&&(e.display.lineGutter=s,s.style.width=(e.display.lineNumWidth||1)+"px")}r.style.display=o?"":"none",Wn(e)}function Fn(e){var t=h(e.gutters,"CodeMirror-linenumbers");-1==t&&e.lineNumbers?e.gutters=e.gutters.concat(["CodeMirror-linenumbers"]):t>-1&&!e.lineNumbers&&(e.gutters=e.gutters.slice(0),e.gutters.splice(t,1))}function En(e){var t=e.wheelDeltaX,r=e.wheelDeltaY;return null==t&&e.detail&&e.axis==e.HORIZONTAL_AXIS&&(t=e.detail),null==r&&e.detail&&e.axis==e.VERTICAL_AXIS?r=e.detail:null==r&&(r=e.wheelDelta),{x:t,y:r}}function Pn(e){var t=En(e);return t.x*=Ls,t.y*=Ls,t}function In(e,t){var r=En(t),n=r.x,i=r.y,o=e.display,l=o.scroller,s=l.scrollWidth>l.clientWidth,a=l.scrollHeight>l.clientHeight;if(n&&s||i&&a){if(i&&Ml&&ml)e:for(var u=t.target,c=o.view;u!=l;u=u.parentNode)for(var f=0;f<c.length;f++)if(c[f].node==u){e.display.currentWheelTarget=u;break e}if(n&&!fl&&!wl&&null!=Ls)return i&&a&&qr(e,Math.max(0,l.scrollTop+i*Ls)),Qr(e,Math.max(0,l.scrollLeft+n*Ls)),(!i||i&&a)&&We(t),void(o.wheelStartX=null);if(i&&null!=Ls){var h=i*Ls,d=e.doc.scrollTop,p=d+o.wrapper.clientHeight;h<0?d=Math.max(0,d+h-50):p=Math.min(e.doc.height,p+h+50),On(e,{top:d,bottom:p})}Ss<20&&(null==o.wheelStartX?(o.wheelStartX=l.scrollLeft,o.wheelStartY=l.scrollTop,o.wheelDX=n,o.wheelDY=i,setTimeout(function(){if(null!=o.wheelStartX){var e=l.scrollLeft-o.wheelStartX,t=l.scrollTop-o.wheelStartY,r=t&&o.wheelDY&&t/o.wheelDY||e&&o.wheelDX&&e/o.wheelDX;o.wheelStartX=o.wheelStartY=null,r&&(Ls=(Ls*Ss+r)/(Ss+1),++Ss)}},200)):(o.wheelDX+=n,o.wheelDY+=i))}}function zn(e,t){var r=e[t];e.sort(function(e,t){return P(e.from(),t.from())}),t=h(e,r);for(var n=1;n<e.length;n++){var i=e[n],o=e[n-1];if(P(o.to(),i.from())>=0){var l=B(o.from(),i.from()),s=R(o.to(),i.to()),a=o.empty()?i.from()==i.head:o.from()==o.head;n<=t&&--t,e.splice(--n,2,new Ts(a?s:l,a?l:s))}}return new ks(e,t)}function Rn(e,t){return new ks([new Ts(e,t||e)],0)}function Bn(e){return e.text?E(e.from.line+e.text.length-1,g(e.text).length+(1==e.text.length?e.from.ch:0)):e.to}function Gn(e,t){if(P(e,t.from)<0)return e;if(P(e,t.to)<=0)return Bn(t);var r=e.line+t.text.length-(t.to.line-t.from.line)-1,n=e.ch;return e.line==t.to.line&&(n+=Bn(t).ch-t.to.ch),E(r,n)}function Un(e,t){for(var r=[],n=0;n<e.sel.ranges.length;n++){var i=e.sel.ranges[n];r.push(new Ts(Gn(i.anchor,t),Gn(i.head,t)))}return zn(r,e.sel.primIndex)}function Vn(e,t,r){return e.line==t.line?E(r.line,e.ch-t.ch+r.ch):E(r.line+(e.line-t.line),e.ch)}function Kn(e,t,r){for(var n=[],i=E(e.first,0),o=i,l=0;l<t.length;l++){var s=t[l],a=Vn(s.from,i,o),u=Vn(Bn(s),i,o);if(i=s.to,o=u,"around"==r){var c=e.sel.ranges[l],f=P(c.head,c.anchor)<0;n[l]=new Ts(f?u:a,f?a:u)}else n[l]=new Ts(a,a)}return new ks(n,e.sel.primIndex)}function jn(e){e.doc.mode=Ue(e.options,e.doc.modeOption),Xn(e)}function Xn(e){e.doc.iter(function(e){e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null)}),e.doc.modeFrontier=e.doc.highlightFrontier=e.doc.first,Cn(e,100),e.state.modeGen++,e.curOp&&vn(e)}function Yn(e,t){return 0==t.from.ch&&0==t.to.ch&&""==g(t.text)&&(!e.cm||e.cm.options.wholeLineUpdateBefore)}function _n(e,t,r,n){function i(e){return r?r[e]:null}function o(e,r,i){it(e,r,i,n),bt(e,"change",e,t)}function l(e,t){for(var r=[],o=e;o<t;++o)r.push(new fs(u[o],i(o),n));return r}var s=t.from,a=t.to,u=t.text,c=M(e,s.line),f=M(e,a.line),h=g(u),d=i(u.length-1),p=a.line-s.line;if(t.full)e.insert(0,l(0,u.length)),e.remove(u.length,e.size-u.length);else if(Yn(e,t)){var v=l(0,u.length-1);o(f,f.text,d),p&&e.remove(s.line,p),v.length&&e.insert(s.line,v)}else if(c==f)if(1==u.length)o(c,c.text.slice(0,s.ch)+h+c.text.slice(a.ch),d);else{var m=l(1,u.length-1);m.push(new fs(h+c.text.slice(a.ch),d,n)),o(c,c.text.slice(0,s.ch)+u[0],i(0)),e.insert(s.line+1,m)}else if(1==u.length)o(c,c.text.slice(0,s.ch)+u[0]+f.text.slice(a.ch),i(0)),e.remove(s.line+1,p);else{o(c,c.text.slice(0,s.ch)+u[0],i(0)),o(f,h+f.text.slice(a.ch),d);var y=l(1,u.length-1);p>1&&e.remove(s.line+1,p-1),e.insert(s.line+1,y)}bt(e,"change",e,t)}function $n(e,t,r){function n(e,i,o){if(e.linked)for(var l=0;l<e.linked.length;++l){var s=e.linked[l];if(s.doc!=i){var a=o&&s.sharedHist;r&&!a||(t(s.doc,a),n(s.doc,e,a))}}}n(e,null,!0)}function qn(e,t){if(t.cm)throw new Error("This document is already in use.");e.doc=t,t.cm=e,Cr(e),jn(e),Zn(e),e.options.lineWrapping||we(e),e.options.mode=t.modeOption,vn(e)}function Zn(e){("rtl"==e.doc.direction?s:Fl)(e.display.lineDiv,"CodeMirror-rtl")}function Qn(e){hn(e,function(){Zn(e),vn(e)})}function Jn(e){this.done=[],this.undone=[],this.undoDepth=1/0,this.lastModTime=this.lastSelTime=0,this.lastOp=this.lastSelOp=null,this.lastOrigin=this.lastSelOrigin=null,this.generation=this.maxGeneration=e||1}function ei(e,t){var r={from:z(t.from),to:Bn(t),text:N(e,t.from,t.to)};return si(e,r,t.from.line,t.to.line+1),$n(e,function(e){return si(e,r,t.from.line,t.to.line+1)},!0),r}function ti(e){for(;e.length&&g(e).ranges;)e.pop()}function ri(e,t){return t?(ti(e.done),g(e.done)):e.done.length&&!g(e.done).ranges?g(e.done):e.done.length>1&&!e.done[e.done.length-2].ranges?(e.done.pop(),g(e.done)):void 0}function ni(e,t,r,n){var i=e.history;i.undone.length=0;var o,l,s=+new Date;if((i.lastOp==n||i.lastOrigin==t.origin&&t.origin&&("+"==t.origin.charAt(0)&&e.cm&&i.lastModTime>s-e.cm.options.historyEventDelay||"*"==t.origin.charAt(0)))&&(o=ri(i,i.lastOp==n)))l=g(o.changes),0==P(t.from,t.to)&&0==P(t.from,l.to)?l.to=Bn(t):o.changes.push(ei(e,t));else{var a=g(i.done);for(a&&a.ranges||li(e.sel,i.done),o={changes:[ei(e,t)],generation:i.generation},i.done.push(o);i.done.length>i.undoDepth;)i.done.shift(),i.done[0].ranges||i.done.shift()}i.done.push(r),i.generation=++i.maxGeneration,i.lastModTime=i.lastSelTime=s,i.lastOp=i.lastSelOp=n,i.lastOrigin=i.lastSelOrigin=t.origin,l||Te(e,"historyAdded")}function ii(e,t,r,n){var i=t.charAt(0);return"*"==i||"+"==i&&r.ranges.length==n.ranges.length&&r.somethingSelected()==n.somethingSelected()&&new Date-e.history.lastSelTime<=(e.cm?e.cm.options.historyEventDelay:500)}function oi(e,t,r,n){var i=e.history,o=n&&n.origin;r==i.lastSelOp||o&&i.lastSelOrigin==o&&(i.lastModTime==i.lastSelTime&&i.lastOrigin==o||ii(e,o,g(i.done),t))?i.done[i.done.length-1]=t:li(t,i.done),i.lastSelTime=+new Date,i.lastSelOrigin=o,i.lastSelOp=r,n&&!1!==n.clearRedo&&ti(i.undone)}function li(e,t){var r=g(t);r&&r.ranges&&r.equals(e)||t.push(e)}function si(e,t,r,n){var i=t["spans_"+e.id],o=0;e.iter(Math.max(e.first,r),Math.min(e.first+e.size,n),function(r){r.markedSpans&&((i||(i=t["spans_"+e.id]={}))[o]=r.markedSpans),++o})}function ai(e){if(!e)return null;for(var t,r=0;r<e.length;++r)e[r].marker.explicitlyCleared?t||(t=e.slice(0,r)):t&&t.push(e[r]);return t?t.length?t:null:e}function ui(e,t){var r=t["spans_"+e.id];if(!r)return null;for(var n=[],i=0;i<t.text.length;++i)n.push(ai(r[i]));return n}function ci(e,t){var r=ui(e,t),n=J(e,t);if(!r)return n;if(!n)return r;for(var i=0;i<r.length;++i){var o=r[i],l=n[i];if(o&&l)e:for(var s=0;s<l.length;++s){for(var a=l[s],u=0;u<o.length;++u)if(o[u].marker==a.marker)continue e;o.push(a)}else l&&(r[i]=l)}return r}function fi(e,t,r){for(var n=[],i=0;i<e.length;++i){var o=e[i];if(o.ranges)n.push(r?ks.prototype.deepCopy.call(o):o);else{var l=o.changes,s=[];n.push({changes:s});for(var a=0;a<l.length;++a){var u=l[a],c=void 0;if(s.push({from:u.from,to:u.to,text:u.text}),t)for(var f in u)(c=f.match(/^spans_(\d+)$/))&&h(t,Number(c[1]))>-1&&(g(s)[f]=u[f],delete u[f])}}}return n}function hi(e,t,r,n){if(n){var i=e.anchor;if(r){var o=P(t,i)<0;o!=P(r,i)<0?(i=t,t=r):o!=P(t,r)<0&&(t=r)}return new Ts(i,t)}return new Ts(r||t,t)}function di(e,t,r,n,i){null==i&&(i=e.cm&&(e.cm.display.shift||e.extend)),bi(e,new ks([hi(e.sel.primary(),t,r,i)],0),n)}function pi(e,t,r){for(var n=[],i=e.cm&&(e.cm.display.shift||e.extend),o=0;o<e.sel.ranges.length;o++)n[o]=hi(e.sel.ranges[o],t[o],null,i);bi(e,zn(n,e.sel.primIndex),r)}function gi(e,t,r,n){var i=e.sel.ranges.slice(0);i[t]=r,bi(e,zn(i,e.sel.primIndex),n)}function vi(e,t,r,n){bi(e,Rn(t,r),n)}function mi(e,t,r){var n={ranges:t.ranges,update:function(t){var r=this;this.ranges=[];for(var n=0;n<t.length;n++)r.ranges[n]=new Ts(U(e,t[n].anchor),U(e,t[n].head))},origin:r&&r.origin};return Te(e,"beforeSelectionChange",e,n),e.cm&&Te(e.cm,"beforeSelectionChange",e.cm,n),n.ranges!=t.ranges?zn(n.ranges,n.ranges.length-1):t}function yi(e,t,r){var n=e.history.done,i=g(n);i&&i.ranges?(n[n.length-1]=t,wi(e,t,r)):bi(e,t,r)}function bi(e,t,r){wi(e,t,r),oi(e,e.sel,e.cm?e.cm.curOp.id:NaN,r)}function wi(e,t,r){(Oe(e,"beforeSelectionChange")||e.cm&&Oe(e.cm,"beforeSelectionChange"))&&(t=mi(e,t,r)),xi(e,Si(e,t,r&&r.bias||(P(t.primary().head,e.sel.primary().head)<0?-1:1),!0)),r&&!1===r.scroll||!e.cm||jr(e.cm)}function xi(e,t){t.equals(e.sel)||(e.sel=t,e.cm&&(e.cm.curOp.updateInput=e.cm.curOp.selectionChanged=!0,Ne(e.cm)),bt(e,"cursorActivity",e))}function Ci(e){xi(e,Si(e,e.sel,null,!1))}function Si(e,t,r,n){for(var i,o=0;o<t.ranges.length;o++){var l=t.ranges[o],s=t.ranges.length==e.sel.ranges.length&&e.sel.ranges[o],a=ki(e,l.anchor,s&&s.anchor,r,n),u=ki(e,l.head,s&&s.head,r,n);(i||a!=l.anchor||u!=l.head)&&(i||(i=t.ranges.slice(0,o)),i[o]=new Ts(a,u))}return i?zn(i,t.primIndex):t}function Li(e,t,r,n,i){var o=M(e,t.line);if(o.markedSpans)for(var l=0;l<o.markedSpans.length;++l){var s=o.markedSpans[l],a=s.marker;if((null==s.from||(a.inclusiveLeft?s.from<=t.ch:s.from<t.ch))&&(null==s.to||(a.inclusiveRight?s.to>=t.ch:s.to>t.ch))){if(i&&(Te(a,"beforeCursorEnter"),a.explicitlyCleared)){if(o.markedSpans){--l;continue}break}if(!a.atomic)continue;if(r){var u=a.find(n<0?1:-1),c=void 0;if((n<0?a.inclusiveRight:a.inclusiveLeft)&&(u=Ti(e,u,-n,u&&u.line==t.line?o:null)),u&&u.line==t.line&&(c=P(u,r))&&(n<0?c<0:c>0))return Li(e,u,t,n,i)}var f=a.find(n<0?-1:1);return(n<0?a.inclusiveLeft:a.inclusiveRight)&&(f=Ti(e,f,n,f.line==t.line?o:null)),f?Li(e,f,t,n,i):null}}return t}function ki(e,t,r,n,i){var o=n||1,l=Li(e,t,r,o,i)||!i&&Li(e,t,r,o,!0)||Li(e,t,r,-o,i)||!i&&Li(e,t,r,-o,!0);return l||(e.cantEdit=!0,E(e.first,0))}function Ti(e,t,r,n){return r<0&&0==t.ch?t.line>e.first?U(e,E(t.line-1)):null:r>0&&t.ch==(n||M(e,t.line)).text.length?t.line<e.first+e.size-1?E(t.line+1,0):null:new E(t.line,t.ch+r)}function Mi(e){e.setSelection(E(e.firstLine(),0),E(e.lastLine()),Gl)}function Ni(e,t,r){var n={canceled:!1,from:t.from,to:t.to,text:t.text,origin:t.origin,cancel:function(){return n.canceled=!0}};return r&&(n.update=function(t,r,i,o){t&&(n.from=U(e,t)),r&&(n.to=U(e,r)),i&&(n.text=i),void 0!==o&&(n.origin=o)}),Te(e,"beforeChange",e,n),e.cm&&Te(e.cm,"beforeChange",e.cm,n),n.canceled?null:{from:n.from,to:n.to,text:n.text,origin:n.origin}}function Oi(e,t,r){if(e.cm){if(!e.cm.curOp)return dn(e.cm,Oi)(e,t,r);if(e.cm.state.suppressEdits)return}if(!(Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"))||(t=Ni(e,t,!0))){var n=Yl&&!r&&te(e,t.from,t.to);if(n)for(var i=n.length-1;i>=0;--i)Ai(e,{from:n[i].from,to:n[i].to,text:i?[""]:t.text,origin:t.origin});else Ai(e,t)}}function Ai(e,t){if(1!=t.text.length||""!=t.text[0]||0!=P(t.from,t.to)){var r=Un(e,t);ni(e,t,r,e.cm?e.cm.curOp.id:NaN),Hi(e,t,r,J(e,t));var n=[];$n(e,function(e,r){r||-1!=h(n,e.history)||(zi(e.history,t),n.push(e.history)),Hi(e,t,null,J(e,t))})}}function Wi(e,t,r){if(!e.cm||!e.cm.state.suppressEdits||r){for(var n,i=e.history,o=e.sel,l="undo"==t?i.done:i.undone,s="undo"==t?i.undone:i.done,a=0;a<l.length&&(n=l[a],r?!n.ranges||n.equals(e.sel):n.ranges);a++);if(a!=l.length){for(i.lastOrigin=i.lastSelOrigin=null;(n=l.pop()).ranges;){if(li(n,s),r&&!n.equals(e.sel))return void bi(e,n,{clearRedo:!1});o=n}var u=[];li(o,s),s.push({changes:u,generation:i.generation}),i.generation=n.generation||++i.maxGeneration;for(var c=Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"),f=n.changes.length-1;f>=0;--f){var d=function(r){var i=n.changes[r];if(i.origin=t,c&&!Ni(e,i,!1))return l.length=0,{};u.push(ei(e,i));var o=r?Un(e,i):g(l);Hi(e,i,o,ci(e,i)),!r&&e.cm&&e.cm.scrollIntoView({from:i.from,to:Bn(i)});var s=[];$n(e,function(e,t){t||-1!=h(s,e.history)||(zi(e.history,i),s.push(e.history)),Hi(e,i,null,ci(e,i))})}(f);if(d)return d.v}}}}function Di(e,t){if(0!=t&&(e.first+=t,e.sel=new ks(v(e.sel.ranges,function(e){return new Ts(E(e.anchor.line+t,e.anchor.ch),E(e.head.line+t,e.head.ch))}),e.sel.primIndex),e.cm)){vn(e.cm,e.first,e.first-t,t);for(var r=e.cm.display,n=r.viewFrom;n<r.viewTo;n++)mn(e.cm,n,"gutter")}}function Hi(e,t,r,n){if(e.cm&&!e.cm.curOp)return dn(e.cm,Hi)(e,t,r,n);if(t.to.line<e.first)Di(e,t.text.length-1-(t.to.line-t.from.line));else if(!(t.from.line>e.lastLine())){if(t.from.line<e.first){var i=t.text.length-1-(e.first-t.from.line);Di(e,i),t={from:E(e.first,0),to:E(t.to.line+i,t.to.ch),text:[g(t.text)],origin:t.origin}}var o=e.lastLine();t.to.line>o&&(t={from:t.from,to:E(o,M(e,o).text.length),text:[t.text[0]],origin:t.origin}),t.removed=N(e,t.from,t.to),r||(r=Un(e,t)),e.cm?Fi(e.cm,t,n):_n(e,t,n),wi(e,r,Gl)}}function Fi(e,t,r){var n=e.doc,i=e.display,o=t.from,l=t.to,s=!1,a=o.line;e.options.lineWrapping||(a=W(fe(M(n,o.line))),n.iter(a,l.line+1,function(e){if(e==i.maxLine)return s=!0,!0})),n.sel.contains(t.from,t.to)>-1&&Ne(e),_n(n,t,r,xr(e)),e.options.lineWrapping||(n.iter(a,o.line+t.text.length,function(e){var t=be(e);t>i.maxLineLength&&(i.maxLine=e,i.maxLineLength=t,i.maxLineChanged=!0,s=!1)}),s&&(e.curOp.updateMaxLine=!0)),nt(n,o.line),Cn(e,400);var u=t.text.length-(l.line-o.line)-1;t.full?vn(e):o.line!=l.line||1!=t.text.length||Yn(e.doc,t)?vn(e,o.line,l.line+1,u):mn(e,o.line,"text");var c=Oe(e,"changes"),f=Oe(e,"change");if(f||c){var h={from:o,to:l,text:t.text,removed:t.removed,origin:t.origin};f&&bt(e,"change",e,h),c&&(e.curOp.changeObjs||(e.curOp.changeObjs=[])).push(h)}e.display.selForContextMenu=null}function Ei(e,t,r,n,i){if(n||(n=r),P(n,r)<0){var o;r=(o=[n,r])[0],n=o[1]}"string"==typeof t&&(t=e.splitLines(t)),Oi(e,{from:r,to:n,text:t,origin:i})}function Pi(e,t,r,n){r<e.line?e.line+=n:t<e.line&&(e.line=t,e.ch=0)}function Ii(e,t,r,n){for(var i=0;i<e.length;++i){var o=e[i],l=!0;if(o.ranges){o.copied||((o=e[i]=o.deepCopy()).copied=!0);for(var s=0;s<o.ranges.length;s++)Pi(o.ranges[s].anchor,t,r,n),Pi(o.ranges[s].head,t,r,n)}else{for(var a=0;a<o.changes.length;++a){var u=o.changes[a];if(r<u.from.line)u.from=E(u.from.line+n,u.from.ch),u.to=E(u.to.line+n,u.to.ch);else if(t<=u.to.line){l=!1;break}}l||(e.splice(0,i+1),i=0)}}}function zi(e,t){var r=t.from.line,n=t.to.line,i=t.text.length-(n-r)-1;Ii(e.done,r,n,i),Ii(e.undone,r,n,i)}function Ri(e,t,r,n){var i=t,o=t;return"number"==typeof t?o=M(e,G(e,t)):i=W(t),null==i?null:(n(o,i)&&e.cm&&mn(e.cm,i,r),o)}function Bi(e){var t=this;this.lines=e,this.parent=null;for(var r=0,n=0;n<e.length;++n)e[n].parent=t,r+=e[n].height;this.height=r}function Gi(e){var t=this;this.children=e;for(var r=0,n=0,i=0;i<e.length;++i){var o=e[i];r+=o.chunkSize(),n+=o.height,o.parent=t}this.size=r,this.height=n,this.parent=null}function Ui(e,t,r){ye(t)<(e.curOp&&e.curOp.scrollTop||e.doc.scrollTop)&&Kr(e,r)}function Vi(e,t,r,n){var i=new Ms(e,r,n),o=e.cm;return o&&i.noHScroll&&(o.display.alignWidgets=!0),Ri(e,t,"widget",function(t){var r=t.widgets||(t.widgets=[]);if(null==i.insertAt?r.push(i):r.splice(Math.min(r.length-1,Math.max(0,i.insertAt)),0,i),i.line=t,o&&!ve(e,t)){var n=ye(t)<e.scrollTop;A(t,t.height+Ht(i)),n&&Kr(o,i.height),o.curOp.forceUpdate=!0}return!0}),bt(o,"lineWidgetAdded",o,i,"number"==typeof t?t:W(t)),i}function Ki(e,t,r,n,o){if(n&&n.shared)return ji(e,t,r,n,o);if(e.cm&&!e.cm.curOp)return dn(e.cm,Ki)(e,t,r,n,o);var l=new Os(e,o),s=P(t,r);if(n&&c(n,l,!1),s>0||0==s&&!1!==l.clearWhenEmpty)return l;if(l.replacedWith&&(l.collapsed=!0,l.widgetNode=i("span",[l.replacedWith],"CodeMirror-widget"),n.handleMouseEvents||l.widgetNode.setAttribute("cm-ignore-events","true"),n.insertLeft&&(l.widgetNode.insertLeft=!0)),l.collapsed){if(ce(e,t.line,t,r,l)||t.line!=r.line&&ce(e,r.line,t,r,l))throw new Error("Inserting collapsed marker partially overlapping an existing one");X()}l.addToHistory&&ni(e,{from:t,to:r,origin:"markText"},e.sel,NaN);var a,u=t.line,f=e.cm;if(e.iter(u,r.line+1,function(e){f&&l.collapsed&&!f.options.lineWrapping&&fe(e)==f.display.maxLine&&(a=!0),l.collapsed&&u!=t.line&&A(e,0),q(e,new Y(l,u==t.line?t.ch:null,u==r.line?r.ch:null)),++u}),l.collapsed&&e.iter(t.line,r.line+1,function(t){ve(e,t)&&A(t,0)}),l.clearOnEnter&&Ql(l,"beforeCursorEnter",function(){return l.clear()}),l.readOnly&&(j(),(e.history.done.length||e.history.undone.length)&&e.clearHistory()),l.collapsed&&(l.id=++Ns,l.atomic=!0),f){if(a&&(f.curOp.updateMaxLine=!0),l.collapsed)vn(f,t.line,r.line+1);else if(l.className||l.title||l.startStyle||l.endStyle||l.css)for(var h=t.line;h<=r.line;h++)mn(f,h,"text");l.atomic&&Ci(f.doc),bt(f,"markerAdded",f,l)}return l}function ji(e,t,r,n,i){(n=c(n)).shared=!1;var o=[Ki(e,t,r,n,i)],l=o[0],s=n.widgetNode;return $n(e,function(e){s&&(n.widgetNode=s.cloneNode(!0)),o.push(Ki(e,U(e,t),U(e,r),n,i));for(var a=0;a<e.linked.length;++a)if(e.linked[a].isParent)return;l=g(o)}),new As(o,l)}function Xi(e){return e.findMarks(E(e.first,0),e.clipPos(E(e.lastLine())),function(e){return e.parent})}function Yi(e,t){for(var r=0;r<t.length;r++){var n=t[r],i=n.find(),o=e.clipPos(i.from),l=e.clipPos(i.to);if(P(o,l)){var s=Ki(e,o,l,n.primary,n.primary.type);n.markers.push(s),s.parent=n}}}function _i(e){for(var t=0;t<e.length;t++)!function(t){var r=e[t],n=[r.primary.doc];$n(r.primary.doc,function(e){return n.push(e)});for(var i=0;i<r.markers.length;i++){var o=r.markers[i];-1==h(n,o.doc)&&(o.parent=null,r.markers.splice(i--,1))}}(t)}function $i(e){var t=this;if(Qi(t),!Me(t,e)&&!Ft(t.display,e)){We(e),gl&&(Hs=+new Date);var r=Sr(t,e,!0),n=e.dataTransfer.files;if(r&&!t.isReadOnly())if(n&&n.length&&window.FileReader&&window.File)for(var i=n.length,o=Array(i),l=0,s=0;s<i;++s)!function(e,n){if(!t.options.allowDropFileTypes||-1!=h(t.options.allowDropFileTypes,e.type)){var s=new FileReader;s.onload=dn(t,function(){var e=s.result;if(/[\x00-\x08\x0e-\x1f]{2}/.test(e)&&(e=""),o[n]=e,++l==i){var a={from:r=U(t.doc,r),to:r,text:t.doc.splitLines(o.join(t.doc.lineSeparator())),origin:"paste"};Oi(t.doc,a),yi(t.doc,Rn(r,Bn(a)))}}),s.readAsText(e)}}(n[s],s);else{if(t.state.draggingText&&t.doc.sel.contains(r)>-1)return t.state.draggingText(e),void setTimeout(function(){return t.display.input.focus()},20);try{var a=e.dataTransfer.getData("Text");if(a){var u;if(t.state.draggingText&&!t.state.draggingText.copy&&(u=t.listSelections()),wi(t.doc,Rn(r,r)),u)for(var c=0;c<u.length;++c)Ei(t.doc,"",u[c].anchor,u[c].head,"drag");t.replaceSelection(a,"around","paste"),t.display.input.focus()}}catch(e){}}}}function qi(e,t){if(gl&&(!e.state.draggingText||+new Date-Hs<100))Fe(t);else if(!Me(e,t)&&!Ft(e.display,t)&&(t.dataTransfer.setData("Text",e.getSelection()),t.dataTransfer.effectAllowed="copyMove",t.dataTransfer.setDragImage&&!xl)){var r=n("img",null,null,"position: fixed; left: 0; top: 0;");r.src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",wl&&(r.width=r.height=1,e.display.wrapper.appendChild(r),r._top=r.offsetTop),t.dataTransfer.setDragImage(r,0,0),wl&&r.parentNode.removeChild(r)}}function Zi(e,t){var i=Sr(e,t);if(i){var o=document.createDocumentFragment();Mr(e,i,o),e.display.dragCursor||(e.display.dragCursor=n("div",null,"CodeMirror-cursors CodeMirror-dragcursors"),e.display.lineSpace.insertBefore(e.display.dragCursor,e.display.cursorDiv)),r(e.display.dragCursor,o)}}function Qi(e){e.display.dragCursor&&(e.display.lineSpace.removeChild(e.display.dragCursor),e.display.dragCursor=null)}function Ji(e){if(document.getElementsByClassName)for(var t=document.getElementsByClassName("CodeMirror"),r=0;r<t.length;r++){var n=t[r].CodeMirror;n&&e(n)}}function eo(){Fs||(to(),Fs=!0)}function to(){var e;Ql(window,"resize",function(){null==e&&(e=setTimeout(function(){e=null,Ji(ro)},100))}),Ql(window,"blur",function(){return Ji(Fr)})}function ro(e){var t=e.display;t.lastWrapHeight==t.wrapper.clientHeight&&t.lastWrapWidth==t.wrapper.clientWidth||(t.cachedCharWidth=t.cachedTextHeight=t.cachedPaddingH=null,t.scrollbarsClipped=!1,e.setSize())}function no(e){var t=e.split(/-(?!$)/);e=t[t.length-1];for(var r,n,i,o,l=0;l<t.length-1;l++){var s=t[l];if(/^(cmd|meta|m)$/i.test(s))o=!0;else if(/^a(lt)?$/i.test(s))r=!0;else if(/^(c|ctrl|control)$/i.test(s))n=!0;else{if(!/^s(hift)?$/i.test(s))throw new Error("Unrecognized modifier name: "+s);i=!0}}return r&&(e="Alt-"+e),n&&(e="Ctrl-"+e),o&&(e="Cmd-"+e),i&&(e="Shift-"+e),e}function io(e){var t={};for(var r in e)if(e.hasOwnProperty(r)){var n=e[r];if(/^(name|fallthrough|(de|at)tach)$/.test(r))continue;if("..."==n){delete e[r];continue}for(var i=v(r.split(" "),no),o=0;o<i.length;o++){var l=void 0,s=void 0;o==i.length-1?(s=i.join(" "),l=n):(s=i.slice(0,o+1).join(" "),l="...");var a=t[s];if(a){if(a!=l)throw new Error("Inconsistent bindings for "+s)}else t[s]=l}delete e[r]}for(var u in t)e[u]=t[u];return e}function oo(e,t,r,n){var i=(t=uo(t)).call?t.call(e,n):t[e];if(!1===i)return"nothing";if("..."===i)return"multi";if(null!=i&&r(i))return"handled";if(t.fallthrough){if("[object Array]"!=Object.prototype.toString.call(t.fallthrough))return oo(e,t.fallthrough,r,n);for(var o=0;o<t.fallthrough.length;o++){var l=oo(e,t.fallthrough[o],r,n);if(l)return l}}}function lo(e){var t="string"==typeof e?e:Es[e.keyCode];return"Ctrl"==t||"Alt"==t||"Shift"==t||"Mod"==t}function so(e,t,r){var n=e;return t.altKey&&"Alt"!=n&&(e="Alt-"+e),(Dl?t.metaKey:t.ctrlKey)&&"Ctrl"!=n&&(e="Ctrl-"+e),(Dl?t.ctrlKey:t.metaKey)&&"Cmd"!=n&&(e="Cmd-"+e),!r&&t.shiftKey&&"Shift"!=n&&(e="Shift-"+e),e}function ao(e,t){if(wl&&34==e.keyCode&&e.char)return!1;var r=Es[e.keyCode];return null!=r&&!e.altGraphKey&&so(r,e,t)}function uo(e){return"string"==typeof e?Rs[e]:e}function co(e,t){for(var r=e.doc.sel.ranges,n=[],i=0;i<r.length;i++){for(var o=t(r[i]);n.length&&P(o.from,g(n).to)<=0;){var l=n.pop();if(P(l.from,o.from)<0){o.from=l.from;break}}n.push(o)}hn(e,function(){for(var t=n.length-1;t>=0;t--)Ei(e.doc,"",n[t].from,n[t].to,"+delete");jr(e)})}function fo(e,t,r){var n=L(e.text,t+r,r);return n<0||n>e.text.length?null:n}function ho(e,t,r){var n=fo(e,t.ch,r);return null==n?null:new E(t.line,n,r<0?"after":"before")}function po(e,t,r,n,i){if(e){var o=Se(r,t.doc.direction);if(o){var l,s=i<0?g(o):o[0],a=i<0==(1==s.level)?"after":"before";if(s.level>0){var u=Xt(t,r);l=i<0?r.text.length-1:0;var c=Yt(t,u,l).top;l=k(function(e){return Yt(t,u,e).top==c},i<0==(1==s.level)?s.from:s.to-1,l),"before"==a&&(l=fo(r,l,1))}else l=i<0?s.to:s.from;return new E(n,l,a)}}return new E(n,i<0?r.text.length:0,i<0?"before":"after")}function go(e,t,r,n){var i=Se(t,e.doc.direction);if(!i)return ho(t,r,n);r.ch>=t.text.length?(r.ch=t.text.length,r.sticky="before"):r.ch<=0&&(r.ch=0,r.sticky="after");var o=Ce(i,r.ch,r.sticky),l=i[o];if("ltr"==e.doc.direction&&l.level%2==0&&(n>0?l.to>r.ch:l.from<r.ch))return ho(t,r,n);var s,a=function(e,r){return fo(t,e instanceof E?e.ch:e,r)},u=function(r){return e.options.lineWrapping?(s=s||Xt(e,t),hr(e,t,s,r)):{begin:0,end:t.text.length}},c=u("before"==r.sticky?a(r,-1):r.ch);if("rtl"==e.doc.direction||1==l.level){var f=1==l.level==n<0,h=a(r,f?1:-1);if(null!=h&&(f?h<=l.to&&h<=c.end:h>=l.from&&h>=c.begin)){var d=f?"before":"after";return new E(r.line,h,d)}}var p=function(e,t,n){for(var o=function(e,t){return t?new E(r.line,a(e,1),"before"):new E(r.line,e,"after")};e>=0&&e<i.length;e+=t){var l=i[e],s=t>0==(1!=l.level),u=s?n.begin:a(n.end,-1);if(l.from<=u&&u<l.to)return o(u,s);if(u=s?l.from:a(l.to,-1),n.begin<=u&&u<n.end)return o(u,s)}},g=p(o+n,n,c);if(g)return g;var v=n>0?c.end:a(c.begin,-1);return null==v||n>0&&v==t.text.length||!(g=p(n>0?0:i.length-1,n,u(v)))?null:g}function vo(e,t){var r=M(e.doc,t),n=fe(r);return n!=r&&(t=W(n)),po(!0,e,n,t,1)}function mo(e,t){var r=M(e.doc,t),n=he(r);return n!=r&&(t=W(n)),po(!0,e,r,t,-1)}function yo(e,t){var r=vo(e,t.line),n=M(e.doc,r.line),i=Se(n,e.doc.direction);if(!i||0==i[0].level){var o=Math.max(0,n.text.search(/\S/)),l=t.line==r.line&&t.ch<=o&&t.ch;return E(r.line,l?0:o,r.sticky)}return r}function bo(e,t,r){if("string"==typeof t&&!(t=Bs[t]))return!1;e.display.input.ensurePolled();var n=e.display.shift,i=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),r&&(e.display.shift=!1),i=t(e)!=Bl}finally{e.display.shift=n,e.state.suppressEdits=!1}return i}function wo(e,t,r){for(var n=0;n<e.state.keyMaps.length;n++){var i=oo(t,e.state.keyMaps[n],r,e);if(i)return i}return e.options.extraKeys&&oo(t,e.options.extraKeys,r,e)||oo(t,e.options.keyMap,r,e)}function xo(e,t,r,n){var i=e.state.keySeq;if(i){if(lo(t))return"handled";Gs.set(50,function(){e.state.keySeq==i&&(e.state.keySeq=null,e.display.input.reset())}),t=i+" "+t}var o=wo(e,t,n);return"multi"==o&&(e.state.keySeq=t),"handled"==o&&bt(e,"keyHandled",e,t,r),"handled"!=o&&"multi"!=o||(We(r),Ar(e)),i&&!o&&/\'$/.test(t)?(We(r),!0):!!o}function Co(e,t){var r=ao(t,!0);return!!r&&(t.shiftKey&&!e.state.keySeq?xo(e,"Shift-"+r,t,function(t){return bo(e,t,!0)})||xo(e,r,t,function(t){if("string"==typeof t?/^go[A-Z]/.test(t):t.motion)return bo(e,t)}):xo(e,r,t,function(t){return bo(e,t)}))}function So(e,t,r){return xo(e,"'"+r+"'",t,function(t){return bo(e,t,!0)})}function Lo(e){var t=this;if(t.curOp.focus=l(),!Me(t,e)){gl&&vl<11&&27==e.keyCode&&(e.returnValue=!1);var r=e.keyCode;t.display.shift=16==r||e.shiftKey;var n=Co(t,e);wl&&(Us=n?r:null,!n&&88==r&&!rs&&(Ml?e.metaKey:e.ctrlKey)&&t.replaceSelection("",null,"cut")),18!=r||/\bCodeMirror-crosshair\b/.test(t.display.lineDiv.className)||ko(t)}}function ko(e){function t(e){18!=e.keyCode&&e.altKey||(Fl(r,"CodeMirror-crosshair"),ke(document,"keyup",t),ke(document,"mouseover",t))}var r=e.display.lineDiv;s(r,"CodeMirror-crosshair"),Ql(document,"keyup",t),Ql(document,"mouseover",t)}function To(e){16==e.keyCode&&(this.doc.sel.shift=!1),Me(this,e)}function Mo(e){var t=this;if(!(Ft(t.display,e)||Me(t,e)||e.ctrlKey&&!e.altKey||Ml&&e.metaKey)){var r=e.keyCode,n=e.charCode;if(wl&&r==Us)return Us=null,void We(e);if(!wl||e.which&&!(e.which<10)||!Co(t,e)){var i=String.fromCharCode(null==n?r:n);"\b"!=i&&(So(t,e,i)||t.display.input.onKeyPress(e))}}}function No(e,t){var r=+new Date;return js&&js.compare(r,e,t)?(Ks=js=null,"triple"):Ks&&Ks.compare(r,e,t)?(js=new Vs(r,e,t),Ks=null,"double"):(Ks=new Vs(r,e,t),js=null,"single")}function Oo(e){var t=this,r=t.display;if(!(Me(t,e)||r.activeTouch&&r.input.supportsTouch()))if(r.input.ensurePolled(),r.shift=e.shiftKey,Ft(r,e))ml||(r.scroller.draggable=!1,setTimeout(function(){return r.scroller.draggable=!0},100));else if(!zo(t,e)){var n=Sr(t,e),i=Pe(e),o=n?No(n,i):"single";window.focus(),1==i&&t.state.selectingText&&t.state.selectingText(e),n&&Ao(t,i,n,o,e)||(1==i?n?Do(t,n,o,e):Ee(e)==r.scroller&&We(e):2==i?(n&&di(t.doc,n),setTimeout(function(){return r.input.focus()},20)):3==i&&(Hl?Ro(t,e):Dr(t)))}}function Ao(e,t,r,n,i){var o="Click";return"double"==n?o="Double"+o:"triple"==n&&(o="Triple"+o),o=(1==t?"Left":2==t?"Middle":"Right")+o,xo(e,so(o,i),i,function(t){if("string"==typeof t&&(t=Bs[t]),!t)return!1;var n=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),n=t(e,r)!=Bl}finally{e.state.suppressEdits=!1}return n})}function Wo(e,t,r){var n=e.getOption("configureMouse"),i=n?n(e,t,r):{};if(null==i.unit){var o=Nl?r.shiftKey&&r.metaKey:r.altKey;i.unit=o?"rectangle":"single"==t?"char":"double"==t?"word":"line"}return(null==i.extend||e.doc.extend)&&(i.extend=e.doc.extend||r.shiftKey),null==i.addNew&&(i.addNew=Ml?r.metaKey:r.ctrlKey),null==i.moveOnDrag&&(i.moveOnDrag=!(Ml?r.altKey:r.ctrlKey)),i}function Do(e,t,r,n){gl?setTimeout(u(Wr,e),0):e.curOp.focus=l();var i,o=Wo(e,r,n),s=e.doc.sel;e.options.dragDrop&&Jl&&!e.isReadOnly()&&"single"==r&&(i=s.contains(t))>-1&&(P((i=s.ranges[i]).from(),t)<0||t.xRel>0)&&(P(i.to(),t)>0||t.xRel<0)?Ho(e,n,t,o):Eo(e,n,t,o)}function Ho(e,t,r,n){var i=e.display,o=!1,l=dn(e,function(t){ml&&(i.scroller.draggable=!1),e.state.draggingText=!1,ke(document,"mouseup",l),ke(document,"mousemove",s),ke(i.scroller,"dragstart",a),ke(i.scroller,"drop",l),o||(We(t),n.addNew||di(e.doc,r,null,null,n.extend),ml||gl&&9==vl?setTimeout(function(){document.body.focus(),i.input.focus()},20):i.input.focus())}),s=function(e){o=o||Math.abs(t.clientX-e.clientX)+Math.abs(t.clientY-e.clientY)>=10},a=function(){return o=!0};ml&&(i.scroller.draggable=!0),e.state.draggingText=l,l.copy=!n.moveOnDrag,i.scroller.dragDrop&&i.scroller.dragDrop(),Ql(document,"mouseup",l),Ql(document,"mousemove",s),Ql(i.scroller,"dragstart",a),Ql(i.scroller,"drop",l),Dr(e),setTimeout(function(){return i.input.focus()},20)}function Fo(e,t,r){if("char"==r)return new Ts(t,t);if("word"==r)return e.findWordAt(t);if("line"==r)return new Ts(E(t.line,0),U(e.doc,E(t.line+1,0)));var n=r(e,t);return new Ts(n.from,n.to)}function Eo(e,t,r,n){function i(t){if(0!=P(m,t))if(m=t,"rectangle"==n.unit){for(var i=[],o=e.options.tabSize,l=f(M(u,r.line).text,r.ch,o),s=f(M(u,t.line).text,t.ch,o),a=Math.min(l,s),g=Math.max(l,s),v=Math.min(r.line,t.line),y=Math.min(e.lastLine(),Math.max(r.line,t.line));v<=y;v++){var b=M(u,v).text,w=d(b,a,o);a==g?i.push(new Ts(E(v,w),E(v,w))):b.length>w&&i.push(new Ts(E(v,w),E(v,d(b,g,o))))}i.length||i.push(new Ts(r,r)),bi(u,zn(p.ranges.slice(0,h).concat(i),h),{origin:"*mouse",scroll:!1}),e.scrollIntoView(t)}else{var x,C=c,S=Fo(e,t,n.unit),L=C.anchor;P(S.anchor,L)>0?(x=S.head,L=B(C.from(),S.anchor)):(x=S.anchor,L=R(C.to(),S.head));var k=p.ranges.slice(0);k[h]=Po(e,new Ts(U(u,L),x)),bi(u,zn(k,h),Ul)}}function o(t){var r=++b,s=Sr(e,t,!0,"rectangle"==n.unit);if(s)if(0!=P(s,m)){e.curOp.focus=l(),i(s);var c=Ir(a,u);(s.line>=c.to||s.line<c.from)&&setTimeout(dn(e,function(){b==r&&o(t)}),150)}else{var f=t.clientY<y.top?-20:t.clientY>y.bottom?20:0;f&&setTimeout(dn(e,function(){b==r&&(a.scroller.scrollTop+=f,o(t))}),50)}}function s(t){e.state.selectingText=!1,b=1/0,We(t),a.input.focus(),ke(document,"mousemove",w),ke(document,"mouseup",x),u.history.lastSelOrigin=null}var a=e.display,u=e.doc;We(t);var c,h,p=u.sel,g=p.ranges;if(n.addNew&&!n.extend?(h=u.sel.contains(r),c=h>-1?g[h]:new Ts(r,r)):(c=u.sel.primary(),h=u.sel.primIndex),"rectangle"==n.unit)n.addNew||(c=new Ts(r,r)),r=Sr(e,t,!0,!0),h=-1;else{var v=Fo(e,r,n.unit);c=n.extend?hi(c,v.anchor,v.head,n.extend):v}n.addNew?-1==h?(h=g.length,bi(u,zn(g.concat([c]),h),{scroll:!1,origin:"*mouse"})):g.length>1&&g[h].empty()&&"char"==n.unit&&!n.extend?(bi(u,zn(g.slice(0,h).concat(g.slice(h+1)),0),{scroll:!1,origin:"*mouse"}),p=u.sel):gi(u,h,c,Ul):(h=0,bi(u,new ks([c],0),Ul),p=u.sel);var m=r,y=a.wrapper.getBoundingClientRect(),b=0,w=dn(e,function(e){Pe(e)?o(e):s(e)}),x=dn(e,s);e.state.selectingText=x,Ql(document,"mousemove",w),Ql(document,"mouseup",x)}function Po(e,t){var r=t.anchor,n=t.head,i=M(e.doc,r.line);if(0==P(r,n)&&r.sticky==n.sticky)return t;var o=Se(i);if(!o)return t;var l=Ce(o,r.ch,r.sticky),s=o[l];if(s.from!=r.ch&&s.to!=r.ch)return t;var a=l+(s.from==r.ch==(1!=s.level)?0:1);if(0==a||a==o.length)return t;var u;if(n.line!=r.line)u=(n.line-r.line)*("ltr"==e.doc.direction?1:-1)>0;else{var c=Ce(o,n.ch,n.sticky),f=c-l||(n.ch-r.ch)*(1==s.level?-1:1);u=c==a-1||c==a?f<0:f>0}var h=o[a+(u?-1:0)],d=u==(1==h.level),p=d?h.from:h.to,g=d?"after":"before";return r.ch==p&&r.sticky==g?t:new Ts(new E(r.line,p,g),n)}function Io(e,t,r,n){var i,o;if(t.touches)i=t.touches[0].clientX,o=t.touches[0].clientY;else try{i=t.clientX,o=t.clientY}catch(t){return!1}if(i>=Math.floor(e.display.gutters.getBoundingClientRect().right))return!1;n&&We(t);var l=e.display,s=l.lineDiv.getBoundingClientRect();if(o>s.bottom||!Oe(e,r))return He(t);o-=s.top-l.viewOffset;for(var a=0;a<e.options.gutters.length;++a){var u=l.gutters.childNodes[a];if(u&&u.getBoundingClientRect().right>=i)return Te(e,r,e,D(e.doc,o),e.options.gutters[a],t),He(t)}}function zo(e,t){return Io(e,t,"gutterClick",!0)}function Ro(e,t){Ft(e.display,t)||Bo(e,t)||Me(e,t,"contextmenu")||e.display.input.onContextMenu(t)}function Bo(e,t){return!!Oe(e,"gutterContextMenu")&&Io(e,t,"gutterContextMenu",!1)}function Go(e){e.display.wrapper.className=e.display.wrapper.className.replace(/\s*cm-s-\S+/g,"")+e.options.theme.replace(/(^|\s)\s*/g," cm-s-"),er(e)}function Uo(e){Hn(e),vn(e),zr(e)}function Vo(e,t,r){if(!t!=!(r&&r!=Xs)){var n=e.display.dragFunctions,i=t?Ql:ke;i(e.display.scroller,"dragstart",n.start),i(e.display.scroller,"dragenter",n.enter),i(e.display.scroller,"dragover",n.over),i(e.display.scroller,"dragleave",n.leave),i(e.display.scroller,"drop",n.drop)}}function Ko(e){e.options.lineWrapping?(s(e.display.wrapper,"CodeMirror-wrap"),e.display.sizer.style.minWidth="",e.display.sizerWidth=null):(Fl(e.display.wrapper,"CodeMirror-wrap"),we(e)),Cr(e),vn(e),er(e),setTimeout(function(){return en(e)},100)}function jo(e,t){var r=this;if(!(this instanceof jo))return new jo(e,t);this.options=t=t?c(t):{},c(Ys,t,!1),Fn(t);var n=t.value;"string"==typeof n&&(n=new Ds(n,t.mode,null,t.lineSeparator,t.direction)),this.doc=n;var i=new jo.inputStyles[t.inputStyle](this),o=this.display=new T(e,n,i);o.wrapper.CodeMirror=this,Hn(this),Go(this),t.lineWrapping&&(this.display.wrapper.className+=" CodeMirror-wrap"),rn(this),this.state={keyMaps:[],overlays:[],modeGen:0,overwrite:!1,delayingBlurEvent:!1,focused:!1,suppressEdits:!1,pasteIncoming:!1,cutIncoming:!1,selectingText:!1,draggingText:!1,highlight:new Pl,keySeq:null,specialChars:null},t.autofocus&&!Tl&&o.input.focus(),gl&&vl<11&&setTimeout(function(){return r.display.input.reset(!0)},20),Xo(this),eo(),nn(this),this.curOp.forceUpdate=!0,qn(this,n),t.autofocus&&!Tl||this.hasFocus()?setTimeout(u(Hr,this),20):Fr(this);for(var l in _s)_s.hasOwnProperty(l)&&_s[l](r,t[l],Xs);Rr(this),t.finishInit&&t.finishInit(this);for(var s=0;s<$s.length;++s)$s[s](r);on(this),ml&&t.lineWrapping&&"optimizelegibility"==getComputedStyle(o.lineDiv).textRendering&&(o.lineDiv.style.textRendering="auto")}function Xo(e){function t(){i.activeTouch&&(o=setTimeout(function(){return i.activeTouch=null},1e3),(l=i.activeTouch).end=+new Date)}function r(e){if(1!=e.touches.length)return!1;var t=e.touches[0];return t.radiusX<=1&&t.radiusY<=1}function n(e,t){if(null==t.left)return!0;var r=t.left-e.left,n=t.top-e.top;return r*r+n*n>400}var i=e.display;Ql(i.scroller,"mousedown",dn(e,Oo)),gl&&vl<11?Ql(i.scroller,"dblclick",dn(e,function(t){if(!Me(e,t)){var r=Sr(e,t);if(r&&!zo(e,t)&&!Ft(e.display,t)){We(t);var n=e.findWordAt(r);di(e.doc,n.anchor,n.head)}}})):Ql(i.scroller,"dblclick",function(t){return Me(e,t)||We(t)}),Hl||Ql(i.scroller,"contextmenu",function(t){return Ro(e,t)});var o,l={end:0};Ql(i.scroller,"touchstart",function(t){if(!Me(e,t)&&!r(t)&&!zo(e,t)){i.input.ensurePolled(),clearTimeout(o);var n=+new Date;i.activeTouch={start:n,moved:!1,prev:n-l.end<=300?l:null},1==t.touches.length&&(i.activeTouch.left=t.touches[0].pageX,i.activeTouch.top=t.touches[0].pageY)}}),Ql(i.scroller,"touchmove",function(){i.activeTouch&&(i.activeTouch.moved=!0)}),Ql(i.scroller,"touchend",function(r){var o=i.activeTouch;if(o&&!Ft(i,r)&&null!=o.left&&!o.moved&&new Date-o.start<300){var l,s=e.coordsChar(i.activeTouch,"page");l=!o.prev||n(o,o.prev)?new Ts(s,s):!o.prev.prev||n(o,o.prev.prev)?e.findWordAt(s):new Ts(E(s.line,0),U(e.doc,E(s.line+1,0))),e.setSelection(l.anchor,l.head),e.focus(),We(r)}t()}),Ql(i.scroller,"touchcancel",t),Ql(i.scroller,"scroll",function(){i.scroller.clientHeight&&(qr(e,i.scroller.scrollTop),Qr(e,i.scroller.scrollLeft,!0),Te(e,"scroll",e))}),Ql(i.scroller,"mousewheel",function(t){return In(e,t)}),Ql(i.scroller,"DOMMouseScroll",function(t){return In(e,t)}),Ql(i.wrapper,"scroll",function(){return i.wrapper.scrollTop=i.wrapper.scrollLeft=0}),i.dragFunctions={enter:function(t){Me(e,t)||Fe(t)},over:function(t){Me(e,t)||(Zi(e,t),Fe(t))},start:function(t){return qi(e,t)},drop:dn(e,$i),leave:function(t){Me(e,t)||Qi(e)}};var s=i.input.getField();Ql(s,"keyup",function(t){return To.call(e,t)}),Ql(s,"keydown",dn(e,Lo)),Ql(s,"keypress",dn(e,Mo)),Ql(s,"focus",function(t){return Hr(e,t)}),Ql(s,"blur",function(t){return Fr(e,t)})}function Yo(e,t,r,n){var i,o=e.doc;null==r&&(r="add"),"smart"==r&&(o.mode.indent?i=$e(e,t).state:r="prev");var l=e.options.tabSize,s=M(o,t),a=f(s.text,null,l);s.stateAfter&&(s.stateAfter=null);var u,c=s.text.match(/^\s*/)[0];if(n||/\S/.test(s.text)){if("smart"==r&&((u=o.mode.indent(i,s.text.slice(c.length),s.text))==Bl||u>150)){if(!n)return;r="prev"}}else u=0,r="not";"prev"==r?u=t>o.first?f(M(o,t-1).text,null,l):0:"add"==r?u=a+e.options.indentUnit:"subtract"==r?u=a-e.options.indentUnit:"number"==typeof r&&(u=a+r),u=Math.max(0,u);var h="",d=0;if(e.options.indentWithTabs)for(var g=Math.floor(u/l);g;--g)d+=l,h+="\t";if(d<u&&(h+=p(u-d)),h!=c)return Ei(o,h,E(t,0),E(t,c.length),"+input"),s.stateAfter=null,!0;for(var v=0;v<o.sel.ranges.length;v++){var m=o.sel.ranges[v];if(m.head.line==t&&m.head.ch<c.length){var y=E(t,c.length);gi(o,v,new Ts(y,y));break}}}function _o(e){qs=e}function $o(e,t,r,n,i){var o=e.doc;e.display.shift=!1,n||(n=o.sel);var l=e.state.pasteIncoming||"paste"==i,s=es(t),a=null;if(l&&n.ranges.length>1)if(qs&&qs.text.join("\n")==t){if(n.ranges.length%qs.text.length==0){a=[];for(var u=0;u<qs.text.length;u++)a.push(o.splitLines(qs.text[u]))}}else s.length==n.ranges.length&&e.options.pasteLinesPerSelection&&(a=v(s,function(e){return[e]}));for(var c,f=n.ranges.length-1;f>=0;f--){var h=n.ranges[f],d=h.from(),p=h.to();h.empty()&&(r&&r>0?d=E(d.line,d.ch-r):e.state.overwrite&&!l?p=E(p.line,Math.min(M(o,p.line).text.length,p.ch+g(s).length)):qs&&qs.lineWise&&qs.text.join("\n")==t&&(d=p=E(d.line,0))),c=e.curOp.updateInput;var m={from:d,to:p,text:a?a[f%a.length]:s,origin:i||(l?"paste":e.state.cutIncoming?"cut":"+input")};Oi(e.doc,m),bt(e,"inputRead",e,m)}t&&!l&&Zo(e,t),jr(e),e.curOp.updateInput=c,e.curOp.typing=!0,e.state.pasteIncoming=e.state.cutIncoming=!1}function qo(e,t){var r=e.clipboardData&&e.clipboardData.getData("Text");if(r)return e.preventDefault(),t.isReadOnly()||t.options.disableInput||hn(t,function(){return $o(t,r,0,null,"paste")}),!0}function Zo(e,t){if(e.options.electricChars&&e.options.smartIndent)for(var r=e.doc.sel,n=r.ranges.length-1;n>=0;n--){var i=r.ranges[n];if(!(i.head.ch>100||n&&r.ranges[n-1].head.line==i.head.line)){var o=e.getModeAt(i.head),l=!1;if(o.electricChars){for(var s=0;s<o.electricChars.length;s++)if(t.indexOf(o.electricChars.charAt(s))>-1){l=Yo(e,i.head.line,"smart");break}}else o.electricInput&&o.electricInput.test(M(e.doc,i.head.line).text.slice(0,i.head.ch))&&(l=Yo(e,i.head.line,"smart"));l&&bt(e,"electricInput",e,i.head.line)}}}function Qo(e){for(var t=[],r=[],n=0;n<e.doc.sel.ranges.length;n++){var i=e.doc.sel.ranges[n].head.line,o={anchor:E(i,0),head:E(i+1,0)};r.push(o),t.push(e.getRange(o.anchor,o.head))}return{text:t,ranges:r}}function Jo(e,t){e.setAttribute("autocorrect","off"),e.setAttribute("autocapitalize","off"),e.setAttribute("spellcheck",!!t)}function el(){var e=n("textarea",null,null,"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none"),t=n("div",[e],null,"overflow: hidden; position: relative; width: 3px; height: 0px;");return ml?e.style.width="1000px":e.setAttribute("wrap","off"),Ll&&(e.style.border="1px solid black"),Jo(e),t}function tl(e,t,r,n,i){function o(){var n=t.line+r;return!(n<e.first||n>=e.first+e.size)&&(t=new E(n,t.ch,t.sticky),u=M(e,n))}function l(n){var l;if(null==(l=i?go(e.cm,u,t,r):ho(u,t,r))){if(n||!o())return!1;t=po(i,e.cm,u,t.line,r)}else t=l;return!0}var s=t,a=r,u=M(e,t.line);if("char"==n)l();else if("column"==n)l(!0);else if("word"==n||"group"==n)for(var c=null,f="group"==n,h=e.cm&&e.cm.getHelper(t,"wordChars"),d=!0;!(r<0)||l(!d);d=!1){var p=u.text.charAt(t.ch)||"\n",g=x(p,h)?"w":f&&"\n"==p?"n":!f||/\s/.test(p)?null:"p";if(!f||d||g||(g="s"),c&&c!=g){r<0&&(r=1,l(),t.sticky="after");break}if(g&&(c=g),r>0&&!l(!d))break}var v=ki(e,t,s,a,!0);return I(s,v)&&(v.hitSide=!0),v}function rl(e,t,r,n){var i,o=e.doc,l=t.left;if("page"==n){var s=Math.min(e.display.wrapper.clientHeight,window.innerHeight||document.documentElement.clientHeight),a=Math.max(s-.5*mr(e.display),3);i=(r>0?t.bottom:t.top)+r*a}else"line"==n&&(i=r>0?t.bottom+3:t.top-3);for(var u;(u=cr(e,l,i)).outside;){if(r<0?i<=0:i>=o.height){u.hitSide=!0;break}i+=5*r}return u}function nl(e,t){var r=jt(e,t.line);if(!r||r.hidden)return null;var n=M(e.doc,t.line),i=Ut(r,n,t.line),o=Se(n,e.doc.direction),l="left";o&&(l=Ce(o,t.ch)%2?"right":"left");var s=_t(i.map,t.ch,l);return s.offset="right"==s.collapse?s.end:s.start,s}function il(e){for(var t=e;t;t=t.parentNode)if(/CodeMirror-gutter-wrapper/.test(t.className))return!0;return!1}function ol(e,t){return t&&(e.bad=!0),e}function ll(e,t,r,n,i){function o(e){return function(t){return t.id==e}}function l(){c&&(u+=f,c=!1)}function s(e){e&&(l(),u+=e)}function a(t){if(1==t.nodeType){var r=t.getAttribute("cm-text");if(null!=r)return void s(r||t.textContent.replace(/\u200b/g,""));var u,h=t.getAttribute("cm-marker");if(h){var d=e.findMarks(E(n,0),E(i+1,0),o(+h));return void(d.length&&(u=d[0].find(0))&&s(N(e.doc,u.from,u.to).join(f)))}if("false"==t.getAttribute("contenteditable"))return;var p=/^(pre|div|p)$/i.test(t.nodeName);p&&l();for(var g=0;g<t.childNodes.length;g++)a(t.childNodes[g]);p&&(c=!0)}else 3==t.nodeType&&s(t.nodeValue)}for(var u="",c=!1,f=e.doc.lineSeparator();a(t),t!=r;)t=t.nextSibling;return u}function sl(e,t,r){var n;if(t==e.display.lineDiv){if(!(n=e.display.lineDiv.childNodes[r]))return ol(e.clipPos(E(e.display.viewTo-1)),!0);t=null,r=0}else for(n=t;;n=n.parentNode){if(!n||n==e.display.lineDiv)return null;if(n.parentNode&&n.parentNode==e.display.lineDiv)break}for(var i=0;i<e.display.view.length;i++){var o=e.display.view[i];if(o.node==n)return al(o,t,r)}}function al(e,t,r){function n(t,r,n){for(var i=-1;i<(f?f.length:0);i++)for(var o=i<0?c.map:f[i],l=0;l<o.length;l+=3){var s=o[l+2];if(s==t||s==r){var a=W(i<0?e.line:e.rest[i]),u=o[l]+n;return(n<0||s!=t)&&(u=o[l+(n?1:0)]),E(a,u)}}}var i=e.text.firstChild,l=!1;if(!t||!o(i,t))return ol(E(W(e.line),0),!0);if(t==i&&(l=!0,t=i.childNodes[r],r=0,!t)){var s=e.rest?g(e.rest):e.line;return ol(E(W(s),s.text.length),l)}var a=3==t.nodeType?t:null,u=t;for(a||1!=t.childNodes.length||3!=t.firstChild.nodeType||(a=t.firstChild,r&&(r=a.nodeValue.length));u.parentNode!=i;)u=u.parentNode;var c=e.measure,f=c.maps,h=n(a,u,r);if(h)return ol(h,l);for(var d=u.nextSibling,p=a?a.nodeValue.length-r:0;d;d=d.nextSibling){if(h=n(d,d.firstChild,0))return ol(E(h.line,h.ch-p),l);p+=d.textContent.length}for(var v=u.previousSibling,m=r;v;v=v.previousSibling){if(h=n(v,v.firstChild,-1))return ol(E(h.line,h.ch+m),l);m+=v.textContent.length}}var ul=navigator.userAgent,cl=navigator.platform,fl=/gecko\/\d/i.test(ul),hl=/MSIE \d/.test(ul),dl=/Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(ul),pl=/Edge\/(\d+)/.exec(ul),gl=hl||dl||pl,vl=gl&&(hl?document.documentMode||6:+(pl||dl)[1]),ml=!pl&&/WebKit\//.test(ul),yl=ml&&/Qt\/\d+\.\d+/.test(ul),bl=!pl&&/Chrome\//.test(ul),wl=/Opera\//.test(ul),xl=/Apple Computer/.test(navigator.vendor),Cl=/Mac OS X 1\d\D([8-9]|\d\d)\D/.test(ul),Sl=/PhantomJS/.test(ul),Ll=!pl&&/AppleWebKit/.test(ul)&&/Mobile\/\w+/.test(ul),kl=/Android/.test(ul),Tl=Ll||kl||/webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(ul),Ml=Ll||/Mac/.test(cl),Nl=/\bCrOS\b/.test(ul),Ol=/win/i.test(cl),Al=wl&&ul.match(/Version\/(\d*\.\d*)/);Al&&(Al=Number(Al[1])),Al&&Al>=15&&(wl=!1,ml=!0);var Wl,Dl=Ml&&(yl||wl&&(null==Al||Al<12.11)),Hl=fl||gl&&vl>=9,Fl=function(t,r){var n=t.className,i=e(r).exec(n);if(i){var o=n.slice(i.index+i[0].length);t.className=n.slice(0,i.index)+(o?i[1]+o:"")}};Wl=document.createRange?function(e,t,r,n){var i=document.createRange();return i.setEnd(n||e,r),i.setStart(e,t),i}:function(e,t,r){var n=document.body.createTextRange();try{n.moveToElementText(e.parentNode)}catch(e){return n}return n.collapse(!0),n.moveEnd("character",r),n.moveStart("character",t),n};var El=function(e){e.select()};Ll?El=function(e){e.selectionStart=0,e.selectionEnd=e.value.length}:gl&&(El=function(e){try{e.select()}catch(e){}});var Pl=function(){this.id=null};Pl.prototype.set=function(e,t){clearTimeout(this.id),this.id=setTimeout(t,e)};var Il,zl,Rl=30,Bl={toString:function(){return"CodeMirror.Pass"}},Gl={scroll:!1},Ul={origin:"*mouse"},Vl={origin:"+move"},Kl=[""],jl=/[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/,Xl=/[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/,Yl=!1,_l=!1,$l=null,ql=function(){function e(e){return e<=247?r.charAt(e):1424<=e&&e<=1524?"R":1536<=e&&e<=1785?n.charAt(e-1536):1774<=e&&e<=2220?"r":8192<=e&&e<=8203?"w":8204==e?"b":"L"}function t(e,t,r){this.level=e,this.from=t,this.to=r}var r="bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN",n="nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111",i=/[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/,o=/[stwN]/,l=/[LRr]/,s=/[Lb1n]/,a=/[1n]/;return function(r,n){var u="ltr"==n?"L":"R";if(0==r.length||"ltr"==n&&!i.test(r))return!1;for(var c=r.length,f=[],h=0;h<c;++h)f.push(e(r.charCodeAt(h)));for(var d=0,p=u;d<c;++d){var v=f[d];"m"==v?f[d]=p:p=v}for(var m=0,y=u;m<c;++m){var b=f[m];"1"==b&&"r"==y?f[m]="n":l.test(b)&&(y=b,"r"==b&&(f[m]="R"))}for(var w=1,x=f[0];w<c-1;++w){var C=f[w];"+"==C&&"1"==x&&"1"==f[w+1]?f[w]="1":","!=C||x!=f[w+1]||"1"!=x&&"n"!=x||(f[w]=x),x=C}for(var S=0;S<c;++S){var L=f[S];if(","==L)f[S]="N";else if("%"==L){var k=void 0;for(k=S+1;k<c&&"%"==f[k];++k);for(var T=S&&"!"==f[S-1]||k<c&&"1"==f[k]?"1":"N",M=S;M<k;++M)f[M]=T;S=k-1}}for(var N=0,O=u;N<c;++N){var A=f[N];"L"==O&&"1"==A?f[N]="L":l.test(A)&&(O=A)}for(var W=0;W<c;++W)if(o.test(f[W])){var D=void 0;for(D=W+1;D<c&&o.test(f[D]);++D);for(var H="L"==(W?f[W-1]:u),F=H==("L"==(D<c?f[D]:u))?H?"L":"R":u,E=W;E<D;++E)f[E]=F;W=D-1}for(var P,I=[],z=0;z<c;)if(s.test(f[z])){var R=z;for(++z;z<c&&s.test(f[z]);++z);I.push(new t(0,R,z))}else{var B=z,G=I.length;for(++z;z<c&&"L"!=f[z];++z);for(var U=B;U<z;)if(a.test(f[U])){B<U&&I.splice(G,0,new t(1,B,U));var V=U;for(++U;U<z&&a.test(f[U]);++U);I.splice(G,0,new t(2,V,U)),B=U}else++U;B<z&&I.splice(G,0,new t(1,B,z))}return 1==I[0].level&&(P=r.match(/^\s+/))&&(I[0].from=P[0].length,I.unshift(new t(0,0,P[0].length))),1==g(I).level&&(P=r.match(/\s+$/))&&(g(I).to-=P[0].length,I.push(new t(0,c-P[0].length,c))),"rtl"==n?I.reverse():I}}(),Zl=[],Ql=function(e,t,r){if(e.addEventListener)e.addEventListener(t,r,!1);else if(e.attachEvent)e.attachEvent("on"+t,r);else{var n=e._handlers||(e._handlers={});n[t]=(n[t]||Zl).concat(r)}},Jl=function(){if(gl&&vl<9)return!1;var e=n("div");return"draggable"in e||"dragDrop"in e}(),es=3!="\n\nb".split(/\n/).length?function(e){for(var t=0,r=[],n=e.length;t<=n;){var i=e.indexOf("\n",t);-1==i&&(i=e.length);var o=e.slice(t,"\r"==e.charAt(i-1)?i-1:i),l=o.indexOf("\r");-1!=l?(r.push(o.slice(0,l)),t+=l+1):(r.push(o),t=i+1)}return r}:function(e){return e.split(/\r\n?|\n/)},ts=window.getSelection?function(e){try{return e.selectionStart!=e.selectionEnd}catch(e){return!1}}:function(e){var t;try{t=e.ownerDocument.selection.createRange()}catch(e){}return!(!t||t.parentElement()!=e)&&0!=t.compareEndPoints("StartToEnd",t)},rs=function(){var e=n("div");return"oncopy"in e||(e.setAttribute("oncopy","return;"),"function"==typeof e.oncopy)}(),ns=null,is={},os={},ls={},ss=function(e,t,r){this.pos=this.start=0,this.string=e,this.tabSize=t||8,this.lastColumnPos=this.lastColumnValue=0,this.lineStart=0,this.lineOracle=r};ss.prototype.eol=function(){return this.pos>=this.string.length},ss.prototype.sol=function(){return this.pos==this.lineStart},ss.prototype.peek=function(){return this.string.charAt(this.pos)||void 0},ss.prototype.next=function(){if(this.pos<this.string.length)return this.string.charAt(this.pos++)},ss.prototype.eat=function(e){var t=this.string.charAt(this.pos);if("string"==typeof e?t==e:t&&(e.test?e.test(t):e(t)))return++this.pos,t},ss.prototype.eatWhile=function(e){for(var t=this.pos;this.eat(e););return this.pos>t},ss.prototype.eatSpace=function(){for(var e=this,t=this.pos;/[\s\u00a0]/.test(this.string.charAt(this.pos));)++e.pos;return this.pos>t},ss.prototype.skipToEnd=function(){this.pos=this.string.length},ss.prototype.skipTo=function(e){var t=this.string.indexOf(e,this.pos);if(t>-1)return this.pos=t,!0},ss.prototype.backUp=function(e){this.pos-=e},ss.prototype.column=function(){return this.lastColumnPos<this.start&&(this.lastColumnValue=f(this.string,this.start,this.tabSize,this.lastColumnPos,this.lastColumnValue),this.lastColumnPos=this.start),this.lastColumnValue-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.indentation=function(){return f(this.string,null,this.tabSize)-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.match=function(e,t,r){if("string"!=typeof e){var n=this.string.slice(this.pos).match(e);return n&&n.index>0?null:(n&&!1!==t&&(this.pos+=n[0].length),n)}var i=function(e){return r?e.toLowerCase():e};if(i(this.string.substr(this.pos,e.length))==i(e))return!1!==t&&(this.pos+=e.length),!0},ss.prototype.current=function(){return this.string.slice(this.start,this.pos)},ss.prototype.hideFirstChars=function(e,t){this.lineStart+=e;try{return t()}finally{this.lineStart-=e}},ss.prototype.lookAhead=function(e){var t=this.lineOracle;return t&&t.lookAhead(e)};var as=function(e,t){this.state=e,this.lookAhead=t},us=function(e,t,r,n){this.state=t,this.doc=e,this.line=r,this.maxLookAhead=n||0};us.prototype.lookAhead=function(e){var t=this.doc.getLine(this.line+e);return null!=t&&e>this.maxLookAhead&&(this.maxLookAhead=e),t},us.prototype.nextLine=function(){this.line++,this.maxLookAhead>0&&this.maxLookAhead--},us.fromSaved=function(e,t,r){return t instanceof as?new us(e,Ke(e.mode,t.state),r,t.lookAhead):new us(e,Ke(e.mode,t),r)},us.prototype.save=function(e){var t=!1!==e?Ke(this.doc.mode,this.state):this.state;return this.maxLookAhead>0?new as(t,this.maxLookAhead):t};var cs=function(e,t,r){this.start=e.start,this.end=e.pos,this.string=e.current(),this.type=t||null,this.state=r},fs=function(e,t,r){this.text=e,ne(this,t),this.height=r?r(this):1};fs.prototype.lineNo=function(){return W(this)},Ae(fs);var hs,ds={},ps={},gs=null,vs=null,ms={left:0,right:0,top:0,bottom:0},ys=function(e,t,r){this.cm=r;var i=this.vert=n("div",[n("div",null,null,"min-width: 1px")],"CodeMirror-vscrollbar"),o=this.horiz=n("div",[n("div",null,null,"height: 100%; min-height: 1px")],"CodeMirror-hscrollbar");e(i),e(o),Ql(i,"scroll",function(){i.clientHeight&&t(i.scrollTop,"vertical")}),Ql(o,"scroll",function(){o.clientWidth&&t(o.scrollLeft,"horizontal")}),this.checkedZeroWidth=!1,gl&&vl<8&&(this.horiz.style.minHeight=this.vert.style.minWidth="18px")};ys.prototype.update=function(e){var t=e.scrollWidth>e.clientWidth+1,r=e.scrollHeight>e.clientHeight+1,n=e.nativeBarWidth;if(r){this.vert.style.display="block",this.vert.style.bottom=t?n+"px":"0";var i=e.viewHeight-(t?n:0);this.vert.firstChild.style.height=Math.max(0,e.scrollHeight-e.clientHeight+i)+"px"}else this.vert.style.display="",this.vert.firstChild.style.height="0";if(t){this.horiz.style.display="block",this.horiz.style.right=r?n+"px":"0",this.horiz.style.left=e.barLeft+"px";var o=e.viewWidth-e.barLeft-(r?n:0);this.horiz.firstChild.style.width=Math.max(0,e.scrollWidth-e.clientWidth+o)+"px"}else this.horiz.style.display="",this.horiz.firstChild.style.width="0";return!this.checkedZeroWidth&&e.clientHeight>0&&(0==n&&this.zeroWidthHack(),this.checkedZeroWidth=!0),{right:r?n:0,bottom:t?n:0}},ys.prototype.setScrollLeft=function(e){this.horiz.scrollLeft!=e&&(this.horiz.scrollLeft=e),this.disableHoriz&&this.enableZeroWidthBar(this.horiz,this.disableHoriz,"horiz")},ys.prototype.setScrollTop=function(e){this.vert.scrollTop!=e&&(this.vert.scrollTop=e),this.disableVert&&this.enableZeroWidthBar(this.vert,this.disableVert,"vert")},ys.prototype.zeroWidthHack=function(){var e=Ml&&!Cl?"12px":"18px";this.horiz.style.height=this.vert.style.width=e,this.horiz.style.pointerEvents=this.vert.style.pointerEvents="none",this.disableHoriz=new Pl,this.disableVert=new Pl},ys.prototype.enableZeroWidthBar=function(e,t,r){function n(){var i=e.getBoundingClientRect();("vert"==r?document.elementFromPoint(i.right-1,(i.top+i.bottom)/2):document.elementFromPoint((i.right+i.left)/2,i.bottom-1))!=e?e.style.pointerEvents="none":t.set(1e3,n)}e.style.pointerEvents="auto",t.set(1e3,n)},ys.prototype.clear=function(){var e=this.horiz.parentNode;e.removeChild(this.horiz),e.removeChild(this.vert)};var bs=function(){};bs.prototype.update=function(){return{bottom:0,right:0}},bs.prototype.setScrollLeft=function(){},bs.prototype.setScrollTop=function(){},bs.prototype.clear=function(){};var ws={native:ys,null:bs},xs=0,Cs=function(e,t,r){var n=e.display;this.viewport=t,this.visible=Ir(n,e.doc,t),this.editorIsHidden=!n.wrapper.offsetWidth,this.wrapperHeight=n.wrapper.clientHeight,this.wrapperWidth=n.wrapper.clientWidth,this.oldDisplayWidth=Rt(e),this.force=r,this.dims=br(e),this.events=[]};Cs.prototype.signal=function(e,t){Oe(e,t)&&this.events.push(arguments)},Cs.prototype.finish=function(){for(var e=this,t=0;t<this.events.length;t++)Te.apply(null,e.events[t])};var Ss=0,Ls=null;gl?Ls=-.53:fl?Ls=15:bl?Ls=-.7:xl&&(Ls=-1/3);var ks=function(e,t){this.ranges=e,this.primIndex=t};ks.prototype.primary=function(){return this.ranges[this.primIndex]},ks.prototype.equals=function(e){var t=this;if(e==this)return!0;if(e.primIndex!=this.primIndex||e.ranges.length!=this.ranges.length)return!1;for(var r=0;r<this.ranges.length;r++){var n=t.ranges[r],i=e.ranges[r];if(!I(n.anchor,i.anchor)||!I(n.head,i.head))return!1}return!0},ks.prototype.deepCopy=function(){for(var e=this,t=[],r=0;r<this.ranges.length;r++)t[r]=new Ts(z(e.ranges[r].anchor),z(e.ranges[r].head));return new ks(t,this.primIndex)},ks.prototype.somethingSelected=function(){for(var e=this,t=0;t<this.ranges.length;t++)if(!e.ranges[t].empty())return!0;return!1},ks.prototype.contains=function(e,t){var r=this;t||(t=e);for(var n=0;n<this.ranges.length;n++){var i=r.ranges[n];if(P(t,i.from())>=0&&P(e,i.to())<=0)return n}return-1};var Ts=function(e,t){this.anchor=e,this.head=t};Ts.prototype.from=function(){return B(this.anchor,this.head)},Ts.prototype.to=function(){return R(this.anchor,this.head)},Ts.prototype.empty=function(){return this.head.line==this.anchor.line&&this.head.ch==this.anchor.ch},Bi.prototype={chunkSize:function(){return this.lines.length},removeInner:function(e,t){for(var r=this,n=e,i=e+t;n<i;++n){var o=r.lines[n];r.height-=o.height,ot(o),bt(o,"delete")}this.lines.splice(e,t)},collapse:function(e){e.push.apply(e,this.lines)},insertInner:function(e,t,r){var n=this;this.height+=r,this.lines=this.lines.slice(0,e).concat(t).concat(this.lines.slice(e));for(var i=0;i<t.length;++i)t[i].parent=n},iterN:function(e,t,r){for(var n=this,i=e+t;e<i;++e)if(r(n.lines[e]))return!0}},Gi.prototype={chunkSize:function(){return this.size},removeInner:function(e,t){var r=this;this.size-=t;for(var n=0;n<this.children.length;++n){var i=r.children[n],o=i.chunkSize();if(e<o){var l=Math.min(t,o-e),s=i.height;if(i.removeInner(e,l),r.height-=s-i.height,o==l&&(r.children.splice(n--,1),i.parent=null),0==(t-=l))break;e=0}else e-=o}if(this.size-t<25&&(this.children.length>1||!(this.children[0]instanceof Bi))){var a=[];this.collapse(a),this.children=[new Bi(a)],this.children[0].parent=this}},collapse:function(e){for(var t=this,r=0;r<this.children.length;++r)t.children[r].collapse(e)},insertInner:function(e,t,r){var n=this;this.size+=t.length,this.height+=r;for(var i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<=l){if(o.insertInner(e,t,r),o.lines&&o.lines.length>50){for(var s=o.lines.length%25+25,a=s;a<o.lines.length;){var u=new Bi(o.lines.slice(a,a+=25));o.height-=u.height,n.children.splice(++i,0,u),u.parent=n}o.lines=o.lines.slice(0,s),n.maybeSpill()}break}e-=l}},maybeSpill:function(){if(!(this.children.length<=10)){var e=this;do{var t=new Gi(e.children.splice(e.children.length-5,5));if(e.parent){e.size-=t.size,e.height-=t.height;var r=h(e.parent.children,e);e.parent.children.splice(r+1,0,t)}else{var n=new Gi(e.children);n.parent=e,e.children=[n,t],e=n}t.parent=e.parent}while(e.children.length>10);e.parent.maybeSpill()}},iterN:function(e,t,r){for(var n=this,i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<l){var s=Math.min(t,l-e);if(o.iterN(e,s,r))return!0;if(0==(t-=s))break;e=0}else e-=l}}};var Ms=function(e,t,r){var n=this;if(r)for(var i in r)r.hasOwnProperty(i)&&(n[i]=r[i]);this.doc=e,this.node=t};Ms.prototype.clear=function(){var e=this,t=this.doc.cm,r=this.line.widgets,n=this.line,i=W(n);if(null!=i&&r){for(var o=0;o<r.length;++o)r[o]==e&&r.splice(o--,1);r.length||(n.widgets=null);var l=Ht(this);A(n,Math.max(0,n.height-l)),t&&(hn(t,function(){Ui(t,n,-l),mn(t,i,"widget")}),bt(t,"lineWidgetCleared",t,this,i))}},Ms.prototype.changed=function(){var e=this,t=this.height,r=this.doc.cm,n=this.line;this.height=null;var i=Ht(this)-t;i&&(A(n,n.height+i),r&&hn(r,function(){r.curOp.forceUpdate=!0,Ui(r,n,i),bt(r,"lineWidgetChanged",r,e,W(n))}))},Ae(Ms);var Ns=0,Os=function(e,t){this.lines=[],this.type=t,this.doc=e,this.id=++Ns};Os.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){var t=this.doc.cm,r=t&&!t.curOp;if(r&&nn(t),Oe(this,"clear")){var n=this.find();n&&bt(this,"clear",n.from,n.to)}for(var i=null,o=null,l=0;l<this.lines.length;++l){var s=e.lines[l],a=_(s.markedSpans,e);t&&!e.collapsed?mn(t,W(s),"text"):t&&(null!=a.to&&(o=W(s)),null!=a.from&&(i=W(s))),s.markedSpans=$(s.markedSpans,a),null==a.from&&e.collapsed&&!ve(e.doc,s)&&t&&A(s,mr(t.display))}if(t&&this.collapsed&&!t.options.lineWrapping)for(var u=0;u<this.lines.length;++u){var c=fe(e.lines[u]),f=be(c);f>t.display.maxLineLength&&(t.display.maxLine=c,t.display.maxLineLength=f,t.display.maxLineChanged=!0)}null!=i&&t&&this.collapsed&&vn(t,i,o+1),this.lines.length=0,this.explicitlyCleared=!0,this.atomic&&this.doc.cantEdit&&(this.doc.cantEdit=!1,t&&Ci(t.doc)),t&&bt(t,"markerCleared",t,this,i,o),r&&on(t),this.parent&&this.parent.clear()}},Os.prototype.find=function(e,t){var r=this;null==e&&"bookmark"==this.type&&(e=1);for(var n,i,o=0;o<this.lines.length;++o){var l=r.lines[o],s=_(l.markedSpans,r);if(null!=s.from&&(n=E(t?l:W(l),s.from),-1==e))return n;if(null!=s.to&&(i=E(t?l:W(l),s.to),1==e))return i}return n&&{from:n,to:i}},Os.prototype.changed=function(){var e=this,t=this.find(-1,!0),r=this,n=this.doc.cm;t&&n&&hn(n,function(){var i=t.line,o=W(t.line),l=jt(n,o);if(l&&(Qt(l),n.curOp.selectionChanged=n.curOp.forceUpdate=!0),n.curOp.updateMaxLine=!0,!ve(r.doc,i)&&null!=r.height){var s=r.height;r.height=null;var a=Ht(r)-s;a&&A(i,i.height+a)}bt(n,"markerChanged",n,e)})},Os.prototype.attachLine=function(e){if(!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;t.maybeHiddenMarkers&&-1!=h(t.maybeHiddenMarkers,this)||(t.maybeUnhiddenMarkers||(t.maybeUnhiddenMarkers=[])).push(this)}this.lines.push(e)},Os.prototype.detachLine=function(e){if(this.lines.splice(h(this.lines,e),1),!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;(t.maybeHiddenMarkers||(t.maybeHiddenMarkers=[])).push(this)}},Ae(Os);var As=function(e,t){var r=this;this.markers=e,this.primary=t;for(var n=0;n<e.length;++n)e[n].parent=r};As.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){this.explicitlyCleared=!0;for(var t=0;t<this.markers.length;++t)e.markers[t].clear();bt(this,"clear")}},As.prototype.find=function(e,t){return this.primary.find(e,t)},Ae(As);var Ws=0,Ds=function(e,t,r,n,i){if(!(this instanceof Ds))return new Ds(e,t,r,n,i);null==r&&(r=0),Gi.call(this,[new Bi([new fs("",null)])]),this.first=r,this.scrollTop=this.scrollLeft=0,this.cantEdit=!1,this.cleanGeneration=1,this.modeFrontier=this.highlightFrontier=r;var o=E(r,0);this.sel=Rn(o),this.history=new Jn(null),this.id=++Ws,this.modeOption=t,this.lineSep=n,this.direction="rtl"==i?"rtl":"ltr",this.extend=!1,"string"==typeof e&&(e=this.splitLines(e)),_n(this,{from:o,to:o,text:e}),bi(this,Rn(o),Gl)};Ds.prototype=b(Gi.prototype,{constructor:Ds,iter:function(e,t,r){r?this.iterN(e-this.first,t-e,r):this.iterN(this.first,this.first+this.size,e)},insert:function(e,t){for(var r=0,n=0;n<t.length;++n)r+=t[n].height;this.insertInner(e-this.first,t,r)},remove:function(e,t){this.removeInner(e-this.first,t)},getValue:function(e){var t=O(this,this.first,this.first+this.size);return!1===e?t:t.join(e||this.lineSeparator())},setValue:gn(function(e){var t=E(this.first,0),r=this.first+this.size-1;Oi(this,{from:t,to:E(r,M(this,r).text.length),text:this.splitLines(e),origin:"setValue",full:!0},!0),this.cm&&Xr(this.cm,0,0),bi(this,Rn(t),Gl)}),replaceRange:function(e,t,r,n){Ei(this,e,t=U(this,t),r=r?U(this,r):t,n)},getRange:function(e,t,r){var n=N(this,U(this,e),U(this,t));return!1===r?n:n.join(r||this.lineSeparator())},getLine:function(e){var t=this.getLineHandle(e);return t&&t.text},getLineHandle:function(e){if(H(this,e))return M(this,e)},getLineNumber:function(e){return W(e)},getLineHandleVisualStart:function(e){return"number"==typeof e&&(e=M(this,e)),fe(e)},lineCount:function(){return this.size},firstLine:function(){return this.first},lastLine:function(){return this.first+this.size-1},clipPos:function(e){return U(this,e)},getCursor:function(e){var t=this.sel.primary();return null==e||"head"==e?t.head:"anchor"==e?t.anchor:"end"==e||"to"==e||!1===e?t.to():t.from()},listSelections:function(){return this.sel.ranges},somethingSelected:function(){return this.sel.somethingSelected()},setCursor:gn(function(e,t,r){vi(this,U(this,"number"==typeof e?E(e,t||0):e),null,r)}),setSelection:gn(function(e,t,r){vi(this,U(this,e),U(this,t||e),r)}),extendSelection:gn(function(e,t,r){di(this,U(this,e),t&&U(this,t),r)}),extendSelections:gn(function(e,t){pi(this,K(this,e),t)}),extendSelectionsBy:gn(function(e,t){pi(this,K(this,v(this.sel.ranges,e)),t)}),setSelections:gn(function(e,t,r){var n=this;if(e.length){for(var i=[],o=0;o<e.length;o++)i[o]=new Ts(U(n,e[o].anchor),U(n,e[o].head));null==t&&(t=Math.min(e.length-1,this.sel.primIndex)),bi(this,zn(i,t),r)}}),addSelection:gn(function(e,t,r){var n=this.sel.ranges.slice(0);n.push(new Ts(U(this,e),U(this,t||e))),bi(this,zn(n,n.length-1),r)}),getSelection:function(e){for(var t,r=this,n=this.sel.ranges,i=0;i<n.length;i++){var o=N(r,n[i].from(),n[i].to());t=t?t.concat(o):o}return!1===e?t:t.join(e||this.lineSeparator())},getSelections:function(e){for(var t=this,r=[],n=this.sel.ranges,i=0;i<n.length;i++){var o=N(t,n[i].from(),n[i].to());!1!==e&&(o=o.join(e||t.lineSeparator())),r[i]=o}return r},replaceSelection:function(e,t,r){for(var n=[],i=0;i<this.sel.ranges.length;i++)n[i]=e;this.replaceSelections(n,t,r||"+input")},replaceSelections:gn(function(e,t,r){for(var n=this,i=[],o=this.sel,l=0;l<o.ranges.length;l++){var s=o.ranges[l];i[l]={from:s.from(),to:s.to(),text:n.splitLines(e[l]),origin:r}}for(var a=t&&"end"!=t&&Kn(this,i,t),u=i.length-1;u>=0;u--)Oi(n,i[u]);a?yi(this,a):this.cm&&jr(this.cm)}),undo:gn(function(){Wi(this,"undo")}),redo:gn(function(){Wi(this,"redo")}),undoSelection:gn(function(){Wi(this,"undo",!0)}),redoSelection:gn(function(){Wi(this,"redo",!0)}),setExtending:function(e){this.extend=e},getExtending:function(){return this.extend},historySize:function(){for(var e=this.history,t=0,r=0,n=0;n<e.done.length;n++)e.done[n].ranges||++t;for(var i=0;i<e.undone.length;i++)e.undone[i].ranges||++r;return{undo:t,redo:r}},clearHistory:function(){this.history=new Jn(this.history.maxGeneration)},markClean:function(){this.cleanGeneration=this.changeGeneration(!0)},changeGeneration:function(e){return e&&(this.history.lastOp=this.history.lastSelOp=this.history.lastOrigin=null),this.history.generation},isClean:function(e){return this.history.generation==(e||this.cleanGeneration)},getHistory:function(){return{done:fi(this.history.done),undone:fi(this.history.undone)}},setHistory:function(e){var t=this.history=new Jn(this.history.maxGeneration);t.done=fi(e.done.slice(0),null,!0),t.undone=fi(e.undone.slice(0),null,!0)},setGutterMarker:gn(function(e,t,r){return Ri(this,e,"gutter",function(e){var n=e.gutterMarkers||(e.gutterMarkers={});return n[t]=r,!r&&C(n)&&(e.gutterMarkers=null),!0})}),clearGutter:gn(function(e){var t=this;this.iter(function(r){r.gutterMarkers&&r.gutterMarkers[e]&&Ri(t,r,"gutter",function(){return r.gutterMarkers[e]=null,C(r.gutterMarkers)&&(r.gutterMarkers=null),!0})})}),lineInfo:function(e){var t;if("number"==typeof e){if(!H(this,e))return null;if(t=e,!(e=M(this,e)))return null}else if(null==(t=W(e)))return null;return{line:t,handle:e,text:e.text,gutterMarkers:e.gutterMarkers,textClass:e.textClass,bgClass:e.bgClass,wrapClass:e.wrapClass,widgets:e.widgets}},addLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass";if(t[i]){if(e(n).test(t[i]))return!1;t[i]+=" "+n}else t[i]=n;return!0})}),removeLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass",o=t[i];if(!o)return!1;if(null==n)t[i]=null;else{var l=o.match(e(n));if(!l)return!1;var s=l.index+l[0].length;t[i]=o.slice(0,l.index)+(l.index&&s!=o.length?" ":"")+o.slice(s)||null}return!0})}),addLineWidget:gn(function(e,t,r){return Vi(this,e,t,r)}),removeLineWidget:function(e){e.clear()},markText:function(e,t,r){return Ki(this,U(this,e),U(this,t),r,r&&r.type||"range")},setBookmark:function(e,t){var r={replacedWith:t&&(null==t.nodeType?t.widget:t),insertLeft:t&&t.insertLeft,clearWhenEmpty:!1,shared:t&&t.shared,handleMouseEvents:t&&t.handleMouseEvents};return e=U(this,e),Ki(this,e,e,r,"bookmark")},findMarksAt:function(e){var t=[],r=M(this,(e=U(this,e)).line).markedSpans;if(r)for(var n=0;n<r.length;++n){var i=r[n];(null==i.from||i.from<=e.ch)&&(null==i.to||i.to>=e.ch)&&t.push(i.marker.parent||i.marker)}return t},findMarks:function(e,t,r){e=U(this,e),t=U(this,t);var n=[],i=e.line;return this.iter(e.line,t.line+1,function(o){var l=o.markedSpans;if(l)for(var s=0;s<l.length;s++){var a=l[s];null!=a.to&&i==e.line&&e.ch>=a.to||null==a.from&&i!=e.line||null!=a.from&&i==t.line&&a.from>=t.ch||r&&!r(a.marker)||n.push(a.marker.parent||a.marker)}++i}),n},getAllMarks:function(){var e=[];return this.iter(function(t){var r=t.markedSpans;if(r)for(var n=0;n<r.length;++n)null!=r[n].from&&e.push(r[n].marker)}),e},posFromIndex:function(e){var t,r=this.first,n=this.lineSeparator().length;return this.iter(function(i){var o=i.text.length+n;if(o>e)return t=e,!0;e-=o,++r}),U(this,E(r,t))},indexFromPos:function(e){var t=(e=U(this,e)).ch;if(e.line<this.first||e.ch<0)return 0;var r=this.lineSeparator().length;return this.iter(this.first,e.line,function(e){t+=e.text.length+r}),t},copy:function(e){var t=new Ds(O(this,this.first,this.first+this.size),this.modeOption,this.first,this.lineSep,this.direction);return t.scrollTop=this.scrollTop,t.scrollLeft=this.scrollLeft,t.sel=this.sel,t.extend=!1,e&&(t.history.undoDepth=this.history.undoDepth,t.setHistory(this.getHistory())),t},linkedDoc:function(e){e||(e={});var t=this.first,r=this.first+this.size;null!=e.from&&e.from>t&&(t=e.from),null!=e.to&&e.to<r&&(r=e.to);var n=new Ds(O(this,t,r),e.mode||this.modeOption,t,this.lineSep,this.direction);return e.sharedHist&&(n.history=this.history),(this.linked||(this.linked=[])).push({doc:n,sharedHist:e.sharedHist}),n.linked=[{doc:this,isParent:!0,sharedHist:e.sharedHist}],Yi(n,Xi(this)),n},unlinkDoc:function(e){var t=this;if(e instanceof jo&&(e=e.doc),this.linked)for(var r=0;r<this.linked.length;++r)if(t.linked[r].doc==e){t.linked.splice(r,1),e.unlinkDoc(t),_i(Xi(t));break}if(e.history==this.history){var n=[e.id];$n(e,function(e){return n.push(e.id)},!0),e.history=new Jn(null),e.history.done=fi(this.history.done,n),e.history.undone=fi(this.history.undone,n)}},iterLinkedDocs:function(e){$n(this,e)},getMode:function(){return this.mode},getEditor:function(){return this.cm},splitLines:function(e){return this.lineSep?e.split(this.lineSep):es(e)},lineSeparator:function(){return this.lineSep||"\n"},setDirection:gn(function(e){"rtl"!=e&&(e="ltr"),e!=this.direction&&(this.direction=e,this.iter(function(e){return e.order=null}),this.cm&&Qn(this.cm))})}),Ds.prototype.eachLine=Ds.prototype.iter;for(var Hs=0,Fs=!1,Es={3:"Enter",8:"Backspace",9:"Tab",13:"Enter",16:"Shift",17:"Ctrl",18:"Alt",19:"Pause",20:"CapsLock",27:"Esc",32:"Space",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"Left",38:"Up",39:"Right",40:"Down",44:"PrintScrn",45:"Insert",46:"Delete",59:";",61:"=",91:"Mod",92:"Mod",93:"Mod",106:"*",107:"=",109:"-",110:".",111:"/",127:"Delete",173:"-",186:";",187:"=",188:",",189:"-",190:".",191:"/",192:"`",219:"[",220:"\\",221:"]",222:"'",63232:"Up",63233:"Down",63234:"Left",63235:"Right",63272:"Delete",63273:"Home",63275:"End",63276:"PageUp",63277:"PageDown",63302:"Insert"},Ps=0;Ps<10;Ps++)Es[Ps+48]=Es[Ps+96]=String(Ps);for(var Is=65;Is<=90;Is++)Es[Is]=String.fromCharCode(Is);for(var zs=1;zs<=12;zs++)Es[zs+111]=Es[zs+63235]="F"+zs;var Rs={};Rs.basic={Left:"goCharLeft",Right:"goCharRight",Up:"goLineUp",Down:"goLineDown",End:"goLineEnd",Home:"goLineStartSmart",PageUp:"goPageUp",PageDown:"goPageDown",Delete:"delCharAfter",Backspace:"delCharBefore","Shift-Backspace":"delCharBefore",Tab:"defaultTab","Shift-Tab":"indentAuto",Enter:"newlineAndIndent",Insert:"toggleOverwrite",Esc:"singleSelection"},Rs.pcDefault={"Ctrl-A":"selectAll","Ctrl-D":"deleteLine","Ctrl-Z":"undo","Shift-Ctrl-Z":"redo","Ctrl-Y":"redo","Ctrl-Home":"goDocStart","Ctrl-End":"goDocEnd","Ctrl-Up":"goLineUp","Ctrl-Down":"goLineDown","Ctrl-Left":"goGroupLeft","Ctrl-Right":"goGroupRight","Alt-Left":"goLineStart","Alt-Right":"goLineEnd","Ctrl-Backspace":"delGroupBefore","Ctrl-Delete":"delGroupAfter","Ctrl-S":"save","Ctrl-F":"find","Ctrl-G":"findNext","Shift-Ctrl-G":"findPrev","Shift-Ctrl-F":"replace","Shift-Ctrl-R":"replaceAll","Ctrl-[":"indentLess","Ctrl-]":"indentMore","Ctrl-U":"undoSelection","Shift-Ctrl-U":"redoSelection","Alt-U":"redoSelection",fallthrough:"basic"},Rs.emacsy={"Ctrl-F":"goCharRight","Ctrl-B":"goCharLeft","Ctrl-P":"goLineUp","Ctrl-N":"goLineDown","Alt-F":"goWordRight","Alt-B":"goWordLeft","Ctrl-A":"goLineStart","Ctrl-E":"goLineEnd","Ctrl-V":"goPageDown","Shift-Ctrl-V":"goPageUp","Ctrl-D":"delCharAfter","Ctrl-H":"delCharBefore","Alt-D":"delWordAfter","Alt-Backspace":"delWordBefore","Ctrl-K":"killLine","Ctrl-T":"transposeChars","Ctrl-O":"openLine"},Rs.macDefault={"Cmd-A":"selectAll","Cmd-D":"deleteLine","Cmd-Z":"undo","Shift-Cmd-Z":"redo","Cmd-Y":"redo","Cmd-Home":"goDocStart","Cmd-Up":"goDocStart","Cmd-End":"goDocEnd","Cmd-Down":"goDocEnd","Alt-Left":"goGroupLeft","Alt-Right":"goGroupRight","Cmd-Left":"goLineLeft","Cmd-Right":"goLineRight","Alt-Backspace":"delGroupBefore","Ctrl-Alt-Backspace":"delGroupAfter","Alt-Delete":"delGroupAfter","Cmd-S":"save","Cmd-F":"find","Cmd-G":"findNext","Shift-Cmd-G":"findPrev","Cmd-Alt-F":"replace","Shift-Cmd-Alt-F":"replaceAll","Cmd-[":"indentLess","Cmd-]":"indentMore","Cmd-Backspace":"delWrappedLineLeft","Cmd-Delete":"delWrappedLineRight","Cmd-U":"undoSelection","Shift-Cmd-U":"redoSelection","Ctrl-Up":"goDocStart","Ctrl-Down":"goDocEnd",fallthrough:["basic","emacsy"]},Rs.default=Ml?Rs.macDefault:Rs.pcDefault;var Bs={selectAll:Mi,singleSelection:function(e){return e.setSelection(e.getCursor("anchor"),e.getCursor("head"),Gl)},killLine:function(e){return co(e,function(t){if(t.empty()){var r=M(e.doc,t.head.line).text.length;return t.head.ch==r&&t.head.line<e.lastLine()?{from:t.head,to:E(t.head.line+1,0)}:{from:t.head,to:E(t.head.line,r)}}return{from:t.from(),to:t.to()}})},deleteLine:function(e){return co(e,function(t){return{from:E(t.from().line,0),to:U(e.doc,E(t.to().line+1,0))}})},delLineLeft:function(e){return co(e,function(e){return{from:E(e.from().line,0),to:e.from()}})},delWrappedLineLeft:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5;return{from:e.coordsChar({left:0,top:r},"div"),to:t.from()}})},delWrappedLineRight:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5,n=e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div");return{from:t.from(),to:n}})},undo:function(e){return e.undo()},redo:function(e){return e.redo()},undoSelection:function(e){return e.undoSelection()},redoSelection:function(e){return e.redoSelection()},goDocStart:function(e){return e.extendSelection(E(e.firstLine(),0))},goDocEnd:function(e){return e.extendSelection(E(e.lastLine()))},goLineStart:function(e){return e.extendSelectionsBy(function(t){return vo(e,t.head.line)},{origin:"+move",bias:1})},goLineStartSmart:function(e){return e.extendSelectionsBy(function(t){return yo(e,t.head)},{origin:"+move",bias:1})},goLineEnd:function(e){return e.extendSelectionsBy(function(t){return mo(e,t.head.line)},{origin:"+move",bias:-1})},goLineRight:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div")},Vl)},goLineLeft:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:0,top:r},"div")},Vl)},goLineLeftSmart:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5,n=e.coordsChar({left:0,top:r},"div");return n.ch<e.getLine(n.line).search(/\S/)?yo(e,t.head):n},Vl)},goLineUp:function(e){return e.moveV(-1,"line")},goLineDown:function(e){return e.moveV(1,"line")},goPageUp:function(e){return e.moveV(-1,"page")},goPageDown:function(e){return e.moveV(1,"page")},goCharLeft:function(e){return e.moveH(-1,"char")},goCharRight:function(e){return e.moveH(1,"char")},goColumnLeft:function(e){return e.moveH(-1,"column")},goColumnRight:function(e){return e.moveH(1,"column")},goWordLeft:function(e){return e.moveH(-1,"word")},goGroupRight:function(e){return e.moveH(1,"group")},goGroupLeft:function(e){return e.moveH(-1,"group")},goWordRight:function(e){return e.moveH(1,"word")},delCharBefore:function(e){return e.deleteH(-1,"char")},delCharAfter:function(e){return e.deleteH(1,"char")},delWordBefore:function(e){return e.deleteH(-1,"word")},delWordAfter:function(e){return e.deleteH(1,"word")},delGroupBefore:function(e){return e.deleteH(-1,"group")},delGroupAfter:function(e){return e.deleteH(1,"group")},indentAuto:function(e){return e.indentSelection("smart")},indentMore:function(e){return e.indentSelection("add")},indentLess:function(e){return e.indentSelection("subtract")},insertTab:function(e){return e.replaceSelection("\t")},insertSoftTab:function(e){for(var t=[],r=e.listSelections(),n=e.options.tabSize,i=0;i<r.length;i++){var o=r[i].from(),l=f(e.getLine(o.line),o.ch,n);t.push(p(n-l%n))}e.replaceSelections(t)},defaultTab:function(e){e.somethingSelected()?e.indentSelection("add"):e.execCommand("insertTab")},transposeChars:function(e){return hn(e,function(){for(var t=e.listSelections(),r=[],n=0;n<t.length;n++)if(t[n].empty()){var i=t[n].head,o=M(e.doc,i.line).text;if(o)if(i.ch==o.length&&(i=new E(i.line,i.ch-1)),i.ch>0)i=new E(i.line,i.ch+1),e.replaceRange(o.charAt(i.ch-1)+o.charAt(i.ch-2),E(i.line,i.ch-2),i,"+transpose");else if(i.line>e.doc.first){var l=M(e.doc,i.line-1).text;l&&(i=new E(i.line,1),e.replaceRange(o.charAt(0)+e.doc.lineSeparator()+l.charAt(l.length-1),E(i.line-1,l.length-1),i,"+transpose"))}r.push(new Ts(i,i))}e.setSelections(r)})},newlineAndIndent:function(e){return hn(e,function(){for(var t=e.listSelections(),r=t.length-1;r>=0;r--)e.replaceRange(e.doc.lineSeparator(),t[r].anchor,t[r].head,"+input");t=e.listSelections();for(var n=0;n<t.length;n++)e.indentLine(t[n].from().line,null,!0);jr(e)})},openLine:function(e){return e.replaceSelection("\n","start")},toggleOverwrite:function(e){return e.toggleOverwrite()}},Gs=new Pl,Us=null,Vs=function(e,t,r){this.time=e,this.pos=t,this.button=r};Vs.prototype.compare=function(e,t,r){return this.time+400>e&&0==P(t,this.pos)&&r==this.button};var Ks,js,Xs={toString:function(){return"CodeMirror.Init"}},Ys={},_s={};jo.defaults=Ys,jo.optionHandlers=_s;var $s=[];jo.defineInitHook=function(e){return $s.push(e)};var qs=null,Zs=function(e){this.cm=e,this.lastAnchorNode=this.lastAnchorOffset=this.lastFocusNode=this.lastFocusOffset=null,this.polling=new Pl,this.composing=null,this.gracePeriod=!1,this.readDOMTimeout=null};Zs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()}),"cut"==e.type&&i.replaceSelection("",null,"cut");else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type&&i.operation(function(){i.setSelections(t.ranges,0,Gl),i.replaceSelection("",null,"cut")})}if(e.clipboardData){e.clipboardData.clearData();var r=qs.text.join("\n");if(e.clipboardData.setData("Text",r),e.clipboardData.getData("Text")==r)return void e.preventDefault()}var l=el(),s=l.firstChild;i.display.lineSpace.insertBefore(l,i.display.lineSpace.firstChild),s.value=qs.text.join("\n");var a=document.activeElement;El(s),setTimeout(function(){i.display.lineSpace.removeChild(l),a.focus(),a==o&&n.showPrimarySelection()},50)}}var r=this,n=this,i=n.cm,o=n.div=e.lineDiv;Jo(o,i.options.spellcheck),Ql(o,"paste",function(e){Me(i,e)||qo(e,i)||vl<=11&&setTimeout(dn(i,function(){return r.updateFromDOM()}),20)}),Ql(o,"compositionstart",function(e){r.composing={data:e.data,done:!1}}),Ql(o,"compositionupdate",function(e){r.composing||(r.composing={data:e.data,done:!1})}),Ql(o,"compositionend",function(e){r.composing&&(e.data!=r.composing.data&&r.readFromDOMSoon(),r.composing.done=!0)}),Ql(o,"touchstart",function(){return n.forceCompositionEnd()}),Ql(o,"input",function(){r.composing||r.readFromDOMSoon()}),Ql(o,"copy",t),Ql(o,"cut",t)},Zs.prototype.prepareSelection=function(){var e=Tr(this.cm,!1);return e.focus=this.cm.state.focused,e},Zs.prototype.showSelection=function(e,t){e&&this.cm.display.view.length&&((e.focus||t)&&this.showPrimarySelection(),this.showMultipleSelections(e))},Zs.prototype.showPrimarySelection=function(){var e=window.getSelection(),t=this.cm,r=t.doc.sel.primary(),n=r.from(),i=r.to();if(t.display.viewTo==t.display.viewFrom||n.line>=t.display.viewTo||i.line<t.display.viewFrom)e.removeAllRanges();else{var o=sl(t,e.anchorNode,e.anchorOffset),l=sl(t,e.focusNode,e.focusOffset);if(!o||o.bad||!l||l.bad||0!=P(B(o,l),n)||0!=P(R(o,l),i)){var s=t.display.view,a=n.line>=t.display.viewFrom&&nl(t,n)||{node:s[0].measure.map[2],offset:0},u=i.line<t.display.viewTo&&nl(t,i);if(!u){var c=s[s.length-1].measure,f=c.maps?c.maps[c.maps.length-1]:c.map;u={node:f[f.length-1],offset:f[f.length-2]-f[f.length-3]}}if(a&&u){var h,d=e.rangeCount&&e.getRangeAt(0);try{h=Wl(a.node,a.offset,u.offset,u.node)}catch(e){}h&&(!fl&&t.state.focused?(e.collapse(a.node,a.offset),h.collapsed||(e.removeAllRanges(),e.addRange(h))):(e.removeAllRanges(),e.addRange(h)),d&&null==e.anchorNode?e.addRange(d):fl&&this.startGracePeriod()),this.rememberSelection()}else e.removeAllRanges()}}},Zs.prototype.startGracePeriod=function(){var e=this;clearTimeout(this.gracePeriod),this.gracePeriod=setTimeout(function(){e.gracePeriod=!1,e.selectionChanged()&&e.cm.operation(function(){return e.cm.curOp.selectionChanged=!0})},20)},Zs.prototype.showMultipleSelections=function(e){r(this.cm.display.cursorDiv,e.cursors),r(this.cm.display.selectionDiv,e.selection)},Zs.prototype.rememberSelection=function(){var e=window.getSelection();this.lastAnchorNode=e.anchorNode,this.lastAnchorOffset=e.anchorOffset,this.lastFocusNode=e.focusNode,this.lastFocusOffset=e.focusOffset},Zs.prototype.selectionInEditor=function(){var e=window.getSelection();if(!e.rangeCount)return!1;var t=e.getRangeAt(0).commonAncestorContainer;return o(this.div,t)},Zs.prototype.focus=function(){"nocursor"!=this.cm.options.readOnly&&(this.selectionInEditor()||this.showSelection(this.prepareSelection(),!0),this.div.focus())},Zs.prototype.blur=function(){this.div.blur()},Zs.prototype.getField=function(){return this.div},Zs.prototype.supportsTouch=function(){return!0},Zs.prototype.receivedFocus=function(){function e(){t.cm.state.focused&&(t.pollSelection(),t.polling.set(t.cm.options.pollInterval,e))}var t=this;this.selectionInEditor()?this.pollSelection():hn(this.cm,function(){return t.cm.curOp.selectionChanged=!0}),this.polling.set(this.cm.options.pollInterval,e)},Zs.prototype.selectionChanged=function(){var e=window.getSelection();return e.anchorNode!=this.lastAnchorNode||e.anchorOffset!=this.lastAnchorOffset||e.focusNode!=this.lastFocusNode||e.focusOffset!=this.lastFocusOffset},Zs.prototype.pollSelection=function(){if(null==this.readDOMTimeout&&!this.gracePeriod&&this.selectionChanged()){var e=window.getSelection(),t=this.cm;if(kl&&bl&&this.cm.options.gutters.length&&il(e.anchorNode))return this.cm.triggerOnKeyDown({type:"keydown",keyCode:8,preventDefault:Math.abs}),this.blur(),void this.focus();if(!this.composing){this.rememberSelection();var r=sl(t,e.anchorNode,e.anchorOffset),n=sl(t,e.focusNode,e.focusOffset);r&&n&&hn(t,function(){bi(t.doc,Rn(r,n),Gl),(r.bad||n.bad)&&(t.curOp.selectionChanged=!0)})}}},Zs.prototype.pollContent=function(){null!=this.readDOMTimeout&&(clearTimeout(this.readDOMTimeout),this.readDOMTimeout=null);var e=this.cm,t=e.display,r=e.doc.sel.primary(),n=r.from(),i=r.to();if(0==n.ch&&n.line>e.firstLine()&&(n=E(n.line-1,M(e.doc,n.line-1).length)),i.ch==M(e.doc,i.line).text.length&&i.line<e.lastLine()&&(i=E(i.line+1,0)),n.line<t.viewFrom||i.line>t.viewTo-1)return!1;var o,l,s;n.line==t.viewFrom||0==(o=Lr(e,n.line))?(l=W(t.view[0].line),s=t.view[0].node):(l=W(t.view[o].line),s=t.view[o-1].node.nextSibling);var a,u,c=Lr(e,i.line);if(c==t.view.length-1?(a=t.viewTo-1,u=t.lineDiv.lastChild):(a=W(t.view[c+1].line)-1,u=t.view[c+1].node.previousSibling),!s)return!1;for(var f=e.doc.splitLines(ll(e,s,u,l,a)),h=N(e.doc,E(l,0),E(a,M(e.doc,a).text.length));f.length>1&&h.length>1;)if(g(f)==g(h))f.pop(),h.pop(),a--;else{if(f[0]!=h[0])break;f.shift(),h.shift(),l++}for(var d=0,p=0,v=f[0],m=h[0],y=Math.min(v.length,m.length);d<y&&v.charCodeAt(d)==m.charCodeAt(d);)++d;for(var b=g(f),w=g(h),x=Math.min(b.length-(1==f.length?d:0),w.length-(1==h.length?d:0));p<x&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)++p;if(1==f.length&&1==h.length&&l==n.line)for(;d&&d>n.ch&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)d--,p++;f[f.length-1]=b.slice(0,b.length-p).replace(/^\u200b+/,""),f[0]=f[0].slice(d).replace(/\u200b+$/,"");var C=E(l,d),S=E(a,h.length?g(h).length-p:0);return f.length>1||f[0]||P(C,S)?(Ei(e.doc,f,C,S,"+input"),!0):void 0},Zs.prototype.ensurePolled=function(){this.forceCompositionEnd()},Zs.prototype.reset=function(){this.forceCompositionEnd()},Zs.prototype.forceCompositionEnd=function(){this.composing&&(clearTimeout(this.readDOMTimeout),this.composing=null,this.updateFromDOM(),this.div.blur(),this.div.focus())},Zs.prototype.readFromDOMSoon=function(){var e=this;null==this.readDOMTimeout&&(this.readDOMTimeout=setTimeout(function(){if(e.readDOMTimeout=null,e.composing){if(!e.composing.done)return;e.composing=null}e.updateFromDOM()},80))},Zs.prototype.updateFromDOM=function(){var e=this;!this.cm.isReadOnly()&&this.pollContent()||hn(this.cm,function(){return vn(e.cm)})},Zs.prototype.setUneditable=function(e){e.contentEditable="false"},Zs.prototype.onKeyPress=function(e){0!=e.charCode&&(e.preventDefault(),this.cm.isReadOnly()||dn(this.cm,$o)(this.cm,String.fromCharCode(null==e.charCode?e.keyCode:e.charCode),0))},Zs.prototype.readOnlyChanged=function(e){this.div.contentEditable=String("nocursor"!=e)},Zs.prototype.onContextMenu=function(){},Zs.prototype.resetPosition=function(){},Zs.prototype.needsContentAttribute=!0;var Qs=function(e){this.cm=e,this.prevInput="",this.pollingFast=!1,this.polling=new Pl,this.hasSelection=!1,this.composing=null};Qs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()});else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type?i.setSelections(t.ranges,null,Gl):(n.prevInput="",l.value=t.text.join("\n"),El(l))}"cut"==e.type&&(i.state.cutIncoming=!0)}}var r=this,n=this,i=this.cm,o=this.wrapper=el(),l=this.textarea=o.firstChild;e.wrapper.insertBefore(o,e.wrapper.firstChild),Ll&&(l.style.width="0px"),Ql(l,"input",function(){gl&&vl>=9&&r.hasSelection&&(r.hasSelection=null),n.poll()}),Ql(l,"paste",function(e){Me(i,e)||qo(e,i)||(i.state.pasteIncoming=!0,n.fastPoll())}),Ql(l,"cut",t),Ql(l,"copy",t),Ql(e.scroller,"paste",function(t){Ft(e,t)||Me(i,t)||(i.state.pasteIncoming=!0,n.focus())}),Ql(e.lineSpace,"selectstart",function(t){Ft(e,t)||We(t)}),Ql(l,"compositionstart",function(){var e=i.getCursor("from");n.composing&&n.composing.range.clear(),n.composing={start:e,range:i.markText(e,i.getCursor("to"),{className:"CodeMirror-composing"})}}),Ql(l,"compositionend",function(){n.composing&&(n.poll(),n.composing.range.clear(),n.composing=null)})},Qs.prototype.prepareSelection=function(){var e=this.cm,t=e.display,r=e.doc,n=Tr(e);if(e.options.moveInputWithCursor){var i=sr(e,r.sel.primary().head,"div"),o=t.wrapper.getBoundingClientRect(),l=t.lineDiv.getBoundingClientRect();n.teTop=Math.max(0,Math.min(t.wrapper.clientHeight-10,i.top+l.top-o.top)),n.teLeft=Math.max(0,Math.min(t.wrapper.clientWidth-10,i.left+l.left-o.left))}return n},Qs.prototype.showSelection=function(e){var t=this.cm.display;r(t.cursorDiv,e.cursors),r(t.selectionDiv,e.selection),null!=e.teTop&&(this.wrapper.style.top=e.teTop+"px",this.wrapper.style.left=e.teLeft+"px")},Qs.prototype.reset=function(e){if(!this.contextMenuPending&&!this.composing){var t=this.cm;if(t.somethingSelected()){this.prevInput="";var r=t.getSelection();this.textarea.value=r,t.state.focused&&El(this.textarea),gl&&vl>=9&&(this.hasSelection=r)}else e||(this.prevInput=this.textarea.value="",gl&&vl>=9&&(this.hasSelection=null))}},Qs.prototype.getField=function(){return this.textarea},Qs.prototype.supportsTouch=function(){return!1},Qs.prototype.focus=function(){if("nocursor"!=this.cm.options.readOnly&&(!Tl||l()!=this.textarea))try{this.textarea.focus()}catch(e){}},Qs.prototype.blur=function(){this.textarea.blur()},Qs.prototype.resetPosition=function(){this.wrapper.style.top=this.wrapper.style.left=0},Qs.prototype.receivedFocus=function(){this.slowPoll()},Qs.prototype.slowPoll=function(){var e=this;this.pollingFast||this.polling.set(this.cm.options.pollInterval,function(){e.poll(),e.cm.state.focused&&e.slowPoll()})},Qs.prototype.fastPoll=function(){function e(){r.poll()||t?(r.pollingFast=!1,r.slowPoll()):(t=!0,r.polling.set(60,e))}var t=!1,r=this;r.pollingFast=!0,r.polling.set(20,e)},Qs.prototype.poll=function(){var e=this,t=this.cm,r=this.textarea,n=this.prevInput;if(this.contextMenuPending||!t.state.focused||ts(r)&&!n&&!this.composing||t.isReadOnly()||t.options.disableInput||t.state.keySeq)return!1;var i=r.value;if(i==n&&!t.somethingSelected())return!1;if(gl&&vl>=9&&this.hasSelection===i||Ml&&/[\uf700-\uf7ff]/.test(i))return t.display.input.reset(),!1;if(t.doc.sel==t.display.selForContextMenu){var o=i.charCodeAt(0);if(8203!=o||n||(n="​"),8666==o)return this.reset(),this.cm.execCommand("undo")}for(var l=0,s=Math.min(n.length,i.length);l<s&&n.charCodeAt(l)==i.charCodeAt(l);)++l;return hn(t,function(){$o(t,i.slice(l),n.length-l,null,e.composing?"*compose":null),i.length>1e3||i.indexOf("\n")>-1?r.value=e.prevInput="":e.prevInput=i,e.composing&&(e.composing.range.clear(),e.composing.range=t.markText(e.composing.start,t.getCursor("to"),{className:"CodeMirror-composing"}))}),!0},Qs.prototype.ensurePolled=function(){this.pollingFast&&this.poll()&&(this.pollingFast=!1)},Qs.prototype.onKeyPress=function(){gl&&vl>=9&&(this.hasSelection=null),this.fastPoll()},Qs.prototype.onContextMenu=function(e){function t(){if(null!=l.selectionStart){var e=i.somethingSelected(),t="​"+(e?l.value:"");l.value="⇚",l.value=t,n.prevInput=e?"":"​",l.selectionStart=1,l.selectionEnd=t.length,o.selForContextMenu=i.doc.sel}}function r(){if(n.contextMenuPending=!1,n.wrapper.style.cssText=c,l.style.cssText=u,gl&&vl<9&&o.scrollbars.setScrollTop(o.scroller.scrollTop=a),null!=l.selectionStart){(!gl||gl&&vl<9)&&t();var e=0,r=function(){o.selForContextMenu==i.doc.sel&&0==l.selectionStart&&l.selectionEnd>0&&"​"==n.prevInput?dn(i,Mi)(i):e++<10?o.detectingSelectAll=setTimeout(r,500):(o.selForContextMenu=null,o.input.reset())};o.detectingSelectAll=setTimeout(r,200)}}var n=this,i=n.cm,o=i.display,l=n.textarea,s=Sr(i,e),a=o.scroller.scrollTop;if(s&&!wl){i.options.resetSelectionOnContextMenu&&-1==i.doc.sel.contains(s)&&dn(i,bi)(i.doc,Rn(s),Gl);var u=l.style.cssText,c=n.wrapper.style.cssText;n.wrapper.style.cssText="position: absolute";var f=n.wrapper.getBoundingClientRect();l.style.cssText="position: absolute; width: 30px; height: 30px;\n      top: "+(e.clientY-f.top-5)+"px; left: "+(e.clientX-f.left-5)+"px;\n      z-index: 1000; background: "+(gl?"rgba(255, 255, 255, .05)":"transparent")+";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";var h;if(ml&&(h=window.scrollY),o.input.focus(),ml&&window.scrollTo(null,h),o.input.reset(),i.somethingSelected()||(l.value=n.prevInput=" "),n.contextMenuPending=!0,o.selForContextMenu=i.doc.sel,clearTimeout(o.detectingSelectAll),gl&&vl>=9&&t(),Hl){Fe(e);var d=function(){ke(window,"mouseup",d),setTimeout(r,20)};Ql(window,"mouseup",d)}else setTimeout(r,50)}},Qs.prototype.readOnlyChanged=function(e){e||this.reset(),this.textarea.disabled="nocursor"==e},Qs.prototype.setUneditable=function(){},Qs.prototype.needsContentAttribute=!1,function(e){function t(t,n,i,o){e.defaults[t]=n,i&&(r[t]=o?function(e,t,r){r!=Xs&&i(e,t,r)}:i)}var r=e.optionHandlers;e.defineOption=t,e.Init=Xs,t("value","",function(e,t){return e.setValue(t)},!0),t("mode",null,function(e,t){e.doc.modeOption=t,jn(e)},!0),t("indentUnit",2,jn,!0),t("indentWithTabs",!1),t("smartIndent",!0),t("tabSize",4,function(e){Xn(e),er(e),vn(e)},!0),t("lineSeparator",null,function(e,t){if(e.doc.lineSep=t,t){var r=[],n=e.doc.first;e.doc.iter(function(e){for(var i=0;;){var o=e.text.indexOf(t,i);if(-1==o)break;i=o+t.length,r.push(E(n,o))}n++});for(var i=r.length-1;i>=0;i--)Ei(e.doc,t,r[i],E(r[i].line,r[i].ch+t.length))}}),t("specialChars",/[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff]/g,function(e,t,r){e.state.specialChars=new RegExp(t.source+(t.test("\t")?"":"|\t"),"g"),r!=Xs&&e.refresh()}),t("specialCharPlaceholder",at,function(e){return e.refresh()},!0),t("electricChars",!0),t("inputStyle",Tl?"contenteditable":"textarea",function(){throw new Error("inputStyle can not (yet) be changed in a running editor")},!0),t("spellcheck",!1,function(e,t){return e.getInputField().spellcheck=t},!0),t("rtlMoveVisually",!Ol),t("wholeLineUpdateBefore",!0),t("theme","default",function(e){Go(e),Uo(e)},!0),t("keyMap","default",function(e,t,r){var n=uo(t),i=r!=Xs&&uo(r);i&&i.detach&&i.detach(e,n),n.attach&&n.attach(e,i||null)}),t("extraKeys",null),t("configureMouse",null),t("lineWrapping",!1,Ko,!0),t("gutters",[],function(e){Fn(e.options),Uo(e)},!0),t("fixedGutter",!0,function(e,t){e.display.gutters.style.left=t?wr(e.display)+"px":"0",e.refresh()},!0),t("coverGutterNextToScrollbar",!1,function(e){return en(e)},!0),t("scrollbarStyle","native",function(e){rn(e),en(e),e.display.scrollbars.setScrollTop(e.doc.scrollTop),e.display.scrollbars.setScrollLeft(e.doc.scrollLeft)},!0),t("lineNumbers",!1,function(e){Fn(e.options),Uo(e)},!0),t("firstLineNumber",1,Uo,!0),t("lineNumberFormatter",function(e){return e},Uo,!0),t("showCursorWhenSelecting",!1,kr,!0),t("resetSelectionOnContextMenu",!0),t("lineWiseCopyCut",!0),t("pasteLinesPerSelection",!0),t("readOnly",!1,function(e,t){"nocursor"==t&&(Fr(e),e.display.input.blur()),e.display.input.readOnlyChanged(t)}),t("disableInput",!1,function(e,t){t||e.display.input.reset()},!0),t("dragDrop",!0,Vo),t("allowDropFileTypes",null),t("cursorBlinkRate",530),t("cursorScrollMargin",0),t("cursorHeight",1,kr,!0),t("singleCursorHeightPerLine",!0,kr,!0),t("workTime",100),t("workDelay",100),t("flattenSpans",!0,Xn,!0),t("addModeClass",!1,Xn,!0),t("pollInterval",100),t("undoDepth",200,function(e,t){return e.doc.history.undoDepth=t}),t("historyEventDelay",1250),t("viewportMargin",10,function(e){return e.refresh()},!0),t("maxHighlightLength",1e4,Xn,!0),t("moveInputWithCursor",!0,function(e,t){t||e.display.input.resetPosition()}),t("tabindex",null,function(e,t){return e.display.input.getField().tabIndex=t||""}),t("autofocus",null),t("direction","ltr",function(e,t){return e.doc.setDirection(t)},!0)}(jo),function(e){var t=e.optionHandlers,r=e.helpers={};e.prototype={constructor:e,focus:function(){window.focus(),this.display.input.focus()},setOption:function(e,r){var n=this.options,i=n[e];n[e]==r&&"mode"!=e||(n[e]=r,t.hasOwnProperty(e)&&dn(this,t[e])(this,r,i),Te(this,"optionChange",this,e))},getOption:function(e){return this.options[e]},getDoc:function(){return this.doc},addKeyMap:function(e,t){this.state.keyMaps[t?"push":"unshift"](uo(e))},removeKeyMap:function(e){for(var t=this.state.keyMaps,r=0;r<t.length;++r)if(t[r]==e||t[r].name==e)return t.splice(r,1),!0},addOverlay:pn(function(t,r){var n=t.token?t:e.getMode(this.options,t);if(n.startState)throw new Error("Overlays may not be stateful.");m(this.state.overlays,{mode:n,modeSpec:t,opaque:r&&r.opaque,priority:r&&r.priority||0},function(e){return e.priority}),this.state.modeGen++,vn(this)}),removeOverlay:pn(function(e){for(var t=this,r=this.state.overlays,n=0;n<r.length;++n){var i=r[n].modeSpec;if(i==e||"string"==typeof e&&i.name==e)return r.splice(n,1),t.state.modeGen++,void vn(t)}}),indentLine:pn(function(e,t,r){"string"!=typeof t&&"number"!=typeof t&&(t=null==t?this.options.smartIndent?"smart":"prev":t?"add":"subtract"),H(this.doc,e)&&Yo(this,e,t,r)}),indentSelection:pn(function(e){for(var t=this,r=this.doc.sel.ranges,n=-1,i=0;i<r.length;i++){var o=r[i];if(o.empty())o.head.line>n&&(Yo(t,o.head.line,e,!0),n=o.head.line,i==t.doc.sel.primIndex&&jr(t));else{var l=o.from(),s=o.to(),a=Math.max(n,l.line);n=Math.min(t.lastLine(),s.line-(s.ch?0:1))+1;for(var u=a;u<n;++u)Yo(t,u,e);var c=t.doc.sel.ranges;0==l.ch&&r.length==c.length&&c[i].from().ch>0&&gi(t.doc,i,new Ts(l,c[i].to()),Gl)}}}),getTokenAt:function(e,t){return Je(this,e,t)},getLineTokens:function(e,t){return Je(this,E(e),t,!0)},getTokenTypeAt:function(e){e=U(this.doc,e);var t,r=_e(this,M(this.doc,e.line)),n=0,i=(r.length-1)/2,o=e.ch;if(0==o)t=r[2];else for(;;){var l=n+i>>1;if((l?r[2*l-1]:0)>=o)i=l;else{if(!(r[2*l+1]<o)){t=r[2*l+2];break}n=l+1}}var s=t?t.indexOf("overlay "):-1;return s<0?t:0==s?null:t.slice(0,s-1)},getModeAt:function(t){var r=this.doc.mode;return r.innerMode?e.innerMode(r,this.getTokenAt(t).state).mode:r},getHelper:function(e,t){return this.getHelpers(e,t)[0]},getHelpers:function(e,t){var n=this,i=[];if(!r.hasOwnProperty(t))return i;var o=r[t],l=this.getModeAt(e);if("string"==typeof l[t])o[l[t]]&&i.push(o[l[t]]);else if(l[t])for(var s=0;s<l[t].length;s++){var a=o[l[t][s]];a&&i.push(a)}else l.helperType&&o[l.helperType]?i.push(o[l.helperType]):o[l.name]&&i.push(o[l.name]);for(var u=0;u<o._global.length;u++){var c=o._global[u];c.pred(l,n)&&-1==h(i,c.val)&&i.push(c.val)}return i},getStateAfter:function(e,t){var r=this.doc;return e=G(r,null==e?r.first+r.size-1:e),$e(this,e+1,t).state},cursorCoords:function(e,t){var r,n=this.doc.sel.primary();return r=null==e?n.head:"object"==typeof e?U(this.doc,e):e?n.from():n.to(),sr(this,r,t||"page")},charCoords:function(e,t){return lr(this,U(this.doc,e),t||"page")},coordsChar:function(e,t){return e=or(this,e,t||"page"),cr(this,e.left,e.top)},lineAtHeight:function(e,t){return e=or(this,{top:e,left:0},t||"page").top,D(this.doc,e+this.display.viewOffset)},heightAtLine:function(e,t,r){var n,i=!1;if("number"==typeof e){var o=this.doc.first+this.doc.size-1;e<this.doc.first?e=this.doc.first:e>o&&(e=o,i=!0),n=M(this.doc,e)}else n=e;return ir(this,n,{top:0,left:0},t||"page",r||i).top+(i?this.doc.height-ye(n):0)},defaultTextHeight:function(){return mr(this.display)},defaultCharWidth:function(){return yr(this.display)},getViewport:function(){return{from:this.display.viewFrom,to:this.display.viewTo}},addWidget:function(e,t,r,n,i){var o=this.display,l=(e=sr(this,U(this.doc,e))).bottom,s=e.left;if(t.style.position="absolute",t.setAttribute("cm-ignore-events","true"),this.display.input.setUneditable(t),o.sizer.appendChild(t),"over"==n)l=e.top;else if("above"==n||"near"==n){var a=Math.max(o.wrapper.clientHeight,this.doc.height),u=Math.max(o.sizer.clientWidth,o.lineSpace.clientWidth);("above"==n||e.bottom+t.offsetHeight>a)&&e.top>t.offsetHeight?l=e.top-t.offsetHeight:e.bottom+t.offsetHeight<=a&&(l=e.bottom),s+t.offsetWidth>u&&(s=u-t.offsetWidth)}t.style.top=l+"px",t.style.left=t.style.right="","right"==i?(s=o.sizer.clientWidth-t.offsetWidth,t.style.right="0px"):("left"==i?s=0:"middle"==i&&(s=(o.sizer.clientWidth-t.offsetWidth)/2),t.style.left=s+"px"),r&&Ur(this,{left:s,top:l,right:s+t.offsetWidth,bottom:l+t.offsetHeight})},triggerOnKeyDown:pn(Lo),triggerOnKeyPress:pn(Mo),triggerOnKeyUp:To,triggerOnMouseDown:pn(Oo),execCommand:function(e){if(Bs.hasOwnProperty(e))return Bs[e].call(null,this)},triggerElectric:pn(function(e){Zo(this,e)}),findPosH:function(e,t,r,n){var i=this,o=1;t<0&&(o=-1,t=-t);for(var l=U(this.doc,e),s=0;s<t&&!(l=tl(i.doc,l,o,r,n)).hitSide;++s);return l},moveH:pn(function(e,t){var r=this;this.extendSelectionsBy(function(n){return r.display.shift||r.doc.extend||n.empty()?tl(r.doc,n.head,e,t,r.options.rtlMoveVisually):e<0?n.from():n.to()},Vl)}),deleteH:pn(function(e,t){var r=this.doc.sel,n=this.doc;r.somethingSelected()?n.replaceSelection("",null,"+delete"):co(this,function(r){var i=tl(n,r.head,e,t,!1);return e<0?{from:i,to:r.head}:{from:r.head,to:i}})}),findPosV:function(e,t,r,n){var i=this,o=1,l=n;t<0&&(o=-1,t=-t);for(var s=U(this.doc,e),a=0;a<t;++a){var u=sr(i,s,"div");if(null==l?l=u.left:u.left=l,(s=rl(i,u,o,r)).hitSide)break}return s},moveV:pn(function(e,t){var r=this,n=this.doc,i=[],o=!this.display.shift&&!n.extend&&n.sel.somethingSelected();if(n.extendSelectionsBy(function(l){if(o)return e<0?l.from():l.to();var s=sr(r,l.head,"div");null!=l.goalColumn&&(s.left=l.goalColumn),i.push(s.left);var a=rl(r,s,e,t);return"page"==t&&l==n.sel.primary()&&Kr(r,lr(r,a,"div").top-s.top),a},Vl),i.length)for(var l=0;l<n.sel.ranges.length;l++)n.sel.ranges[l].goalColumn=i[l]}),findWordAt:function(e){var t=M(this.doc,e.line).text,r=e.ch,n=e.ch;if(t){var i=this.getHelper(e,"wordChars");"before"!=e.sticky&&n!=t.length||!r?++n:--r;for(var o=t.charAt(r),l=x(o,i)?function(e){return x(e,i)}:/\s/.test(o)?function(e){return/\s/.test(e)}:function(e){return!/\s/.test(e)&&!x(e)};r>0&&l(t.charAt(r-1));)--r;for(;n<t.length&&l(t.charAt(n));)++n}return new Ts(E(e.line,r),E(e.line,n))},toggleOverwrite:function(e){null!=e&&e==this.state.overwrite||((this.state.overwrite=!this.state.overwrite)?s(this.display.cursorDiv,"CodeMirror-overwrite"):Fl(this.display.cursorDiv,"CodeMirror-overwrite"),Te(this,"overwriteToggle",this,this.state.overwrite))},hasFocus:function(){return this.display.input.getField()==l()},isReadOnly:function(){return!(!this.options.readOnly&&!this.doc.cantEdit)},scrollTo:pn(function(e,t){Xr(this,e,t)}),getScrollInfo:function(){var e=this.display.scroller;return{left:e.scrollLeft,top:e.scrollTop,height:e.scrollHeight-zt(this)-this.display.barHeight,width:e.scrollWidth-zt(this)-this.display.barWidth,clientHeight:Bt(this),clientWidth:Rt(this)}},scrollIntoView:pn(function(e,t){null==e?(e={from:this.doc.sel.primary().head,to:null},null==t&&(t=this.options.cursorScrollMargin)):"number"==typeof e?e={from:E(e,0),to:null}:null==e.from&&(e={from:e,to:null}),e.to||(e.to=e.from),e.margin=t||0,null!=e.from.line?Yr(this,e):$r(this,e.from,e.to,e.margin)}),setSize:pn(function(e,t){var r=this,n=function(e){return"number"==typeof e||/^\d+$/.test(String(e))?e+"px":e};null!=e&&(this.display.wrapper.style.width=n(e)),null!=t&&(this.display.wrapper.style.height=n(t)),this.options.lineWrapping&&Jt(this);var i=this.display.viewFrom;this.doc.iter(i,this.display.viewTo,function(e){if(e.widgets)for(var t=0;t<e.widgets.length;t++)if(e.widgets[t].noHScroll){mn(r,i,"widget");break}++i}),this.curOp.forceUpdate=!0,Te(this,"refresh",this)}),operation:function(e){return hn(this,e)},startOperation:function(){return nn(this)},endOperation:function(){return on(this)},refresh:pn(function(){var e=this.display.cachedTextHeight;vn(this),this.curOp.forceUpdate=!0,er(this),Xr(this,this.doc.scrollLeft,this.doc.scrollTop),Wn(this),(null==e||Math.abs(e-mr(this.display))>.5)&&Cr(this),Te(this,"refresh",this)}),swapDoc:pn(function(e){var t=this.doc;return t.cm=null,qn(this,e),er(this),this.display.input.reset(),Xr(this,e.scrollLeft,e.scrollTop),this.curOp.forceScroll=!0,bt(this,"swapDoc",this,t),t}),getInputField:function(){return this.display.input.getField()},getWrapperElement:function(){return this.display.wrapper},getScrollerElement:function(){return this.display.scroller},getGutterElement:function(){return this.display.gutters}},Ae(e),e.registerHelper=function(t,n,i){r.hasOwnProperty(t)||(r[t]=e[t]={_global:[]}),r[t][n]=i},e.registerGlobalHelper=function(t,n,i,o){e.registerHelper(t,n,o),r[t]._global.push({pred:i,val:o})}}(jo);var Js="iter insert remove copy getEditor constructor".split(" ");for(var ea in Ds.prototype)Ds.prototype.hasOwnProperty(ea)&&h(Js,ea)<0&&(jo.prototype[ea]=function(e){return function(){return e.apply(this.doc,arguments)}}(Ds.prototype[ea]));return Ae(Ds),jo.inputStyles={textarea:Qs,contenteditable:Zs},jo.defineMode=function(e){jo.defaults.mode||"null"==e||(jo.defaults.mode=e),Be.apply(this,arguments)},jo.defineMIME=function(e,t){os[e]=t},jo.defineMode("null",function(){return{token:function(e){return e.skipToEnd()}}}),jo.defineMIME("text/plain","null"),jo.defineExtension=function(e,t){jo.prototype[e]=t},jo.defineDocExtension=function(e,t){Ds.prototype[e]=t},jo.fromTextArea=function(e,t){function r(){e.value=a.getValue()}if(t=t?c(t):{},t.value=e.value,!t.tabindex&&e.tabIndex&&(t.tabindex=e.tabIndex),!t.placeholder&&e.placeholder&&(t.placeholder=e.placeholder),null==t.autofocus){var n=l();t.autofocus=n==e||null!=e.getAttribute("autofocus")&&n==document.body}var i;if(e.form&&(Ql(e.form,"submit",r),!t.leaveSubmitMethodAlone)){var o=e.form;i=o.submit;try{var s=o.submit=function(){r(),o.submit=i,o.submit(),o.submit=s}}catch(e){}}t.finishInit=function(t){t.save=r,t.getTextArea=function(){return e},t.toTextArea=function(){t.toTextArea=isNaN,r(),e.parentNode.removeChild(t.getWrapperElement()),e.style.display="",e.form&&(ke(e.form,"submit",r),"function"==typeof e.form.submit&&(e.form.submit=i))}},e.style.display="none";var a=jo(function(t){return e.parentNode.insertBefore(t,e.nextSibling)},t);return a},function(e){e.off=ke,e.on=Ql,e.wheelEventPixels=Pn,e.Doc=Ds,e.splitLines=es,e.countColumn=f,e.findColumn=d,e.isWordChar=w,e.Pass=Bl,e.signal=Te,e.Line=fs,e.changeEnd=Bn,e.scrollbarModel=ws,e.Pos=E,e.cmpPos=P,e.modes=is,e.mimeModes=os,e.resolveMode=Ge,e.getMode=Ue,e.modeExtensions=ls,e.extendMode=Ve,e.copyState=Ke,e.startState=Xe,e.innerMode=je,e.commands=Bs,e.keyMap=Rs,e.keyName=ao,e.isModifierKey=lo,e.lookupKey=oo,e.normalizeKeyMap=io,e.StringStream=ss,e.SharedTextMarker=As,e.TextMarker=Os,e.LineWidget=Ms,e.e_preventDefault=We,e.e_stopPropagation=De,e.e_stop=Fe,e.addClass=s,e.contains=o,e.rmClass=Fl,e.keyNames=Es}(jo),jo.version="5.30.0",jo});
      !function(e){"object"==typeof exports&&"object"==typeof module?e(require("../../lib/codemirror")):"function"==typeof define&&define.amd?define(["../../lib/codemirror"],e):e(CodeMirror)}(function(e){"use strict";function t(e,t,n,r,o,a){this.indented=e,this.column=t,this.type=n,this.info=r,this.align=o,this.prev=a}function n(e,n,r,o){var a=e.indented;return e.context&&"statement"==e.context.type&&"statement"!=r&&(a=e.context.indented),e.context=new t(a,n,r,o,null,e.context)}function r(e){var t=e.context.type;return")"!=t&&"]"!=t&&"}"!=t||(e.indented=e.context.indented),e.context=e.context.prev}function o(e,t,n){return"variable"==t.prevToken||"type"==t.prevToken||(!!/\S(?:[^- ]>|[*\]])\s*$|\*$/.test(e.string.slice(0,n))||(!(!t.typeAtEndOfLine||e.column()!=e.indentation())||void 0))}function a(e){for(;;){if(!e||"top"==e.type)return!0;if("}"==e.type&&"namespace"!=e.prev.info)return!1;e=e.prev}}function i(e){for(var t={},n=e.split(" "),r=0;r<n.length;++r)t[n[r]]=!0;return t}function l(e,t){return"function"==typeof e?e(t):e.propertyIsEnumerable(t)}function s(e,t){if(!t.startOfLine)return!1;for(var n,r=null;n=e.peek();){if("\\"==n&&e.match(/^.$/)){r=s;break}if("/"==n&&e.match(/^\/[\/\*]/,!1))break;e.next()}return t.tokenize=r,"meta"}function c(e,t){return"type"==t.prevToken&&"type"}function u(e){return e.eatWhile(/[\w\.']/),"number"}function d(e,t){if(e.backUp(1),e.match(/(R|u8R|uR|UR|LR)/)){var n=e.match(/"([^\s\\()]{0,16})\(/);return!!n&&(t.cpp11RawStringDelim=n[1],t.tokenize=m,m(e,t))}return e.match(/(u8|u|U|L)/)?!!e.match(/["']/,!1)&&"string":(e.next(),!1)}function f(e){var t=/(\w+)::~?(\w+)$/.exec(e);return t&&t[1]==t[2]}function p(e,t){for(var n;null!=(n=e.next());)if('"'==n&&!e.eat('"')){t.tokenize=null;break}return"string"}function m(e,t){var n=t.cpp11RawStringDelim.replace(/[^\w\s]/g,"\\$&");return e.match(new RegExp(".*?\\)"+n+'"'))?t.tokenize=null:e.skipToEnd(),"string"}function h(t,n){function r(e){if(e)for(var t in e)e.hasOwnProperty(t)&&o.push(t)}"string"==typeof t&&(t=[t]);var o=[];r(n.keywords),r(n.types),r(n.builtin),r(n.atoms),o.length&&(n.helperType=t[0],e.registerHelper("hintWords",t[0],o));for(var a=0;a<t.length;++a)e.defineMIME(t[a],n)}function g(e,t){for(var n=!1;!e.eol();){if(!n&&e.match('"""')){t.tokenize=null;break}n="\\"==e.next()&&!n}return"string"}function y(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!e&&!o&&t.match('"')){a=!0;break}if(e&&t.match('"""')){a=!0;break}r=t.next(),!o&&"$"==r&&t.match("{")&&t.skipTo("}"),o=!o&&"\\"==r&&!e}return!a&&e||(n.tokenize=null),"string"}}function x(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!o&&t.match('"')&&("single"==e||t.match('""'))){a=!0;break}if(!o&&t.match("``")){w=x(e),a=!0;break}r=t.next(),o="single"==e&&!o&&"\\"==r}return a&&(n.tokenize=null),"string"}}e.defineMode("clike",function(i,s){function c(e,t){var n=e.next();if(S[n]){var r=S[n](e,t);if(!1!==r)return r}if('"'==n||"'"==n)return t.tokenize=u(n),t.tokenize(e,t);if(D.test(n))return p=n,null;if(L.test(n)){if(e.backUp(1),e.match(I))return"number";e.next()}if("/"==n){if(e.eat("*"))return t.tokenize=d,d(e,t);if(e.eat("/"))return e.skipToEnd(),"comment"}if(F.test(n)){for(;!e.match(/^\/[\/*]/,!1)&&e.eat(F););return"operator"}if(e.eatWhile(z),P)for(;e.match(P);)e.eatWhile(z);var o=e.current();return l(x,o)?(l(w,o)&&(p="newstatement"),l(v,o)&&(m=!0),"keyword"):l(b,o)?"type":l(k,o)?(l(w,o)&&(p="newstatement"),"builtin"):l(_,o)?"atom":"variable"}function u(e){return function(t,n){for(var r,o=!1,a=!1;null!=(r=t.next());){if(r==e&&!o){a=!0;break}o=!o&&"\\"==r}return(a||!o&&!C)&&(n.tokenize=null),"string"}}function d(e,t){for(var n,r=!1;n=e.next();){if("/"==n&&r){t.tokenize=null;break}r="*"==n}return"comment"}function f(e,t){s.typeFirstDefinitions&&e.eol()&&a(t.context)&&(t.typeAtEndOfLine=o(e,t,e.pos))}var p,m,h=i.indentUnit,g=s.statementIndentUnit||h,y=s.dontAlignCalls,x=s.keywords||{},b=s.types||{},k=s.builtin||{},w=s.blockKeywords||{},v=s.defKeywords||{},_=s.atoms||{},S=s.hooks||{},C=s.multiLineStrings,T=!1!==s.indentStatements,M=!1!==s.indentSwitch,P=s.namespaceSeparator,D=s.isPunctuationChar||/[\[\]{}\(\),;\:\.]/,L=s.numberStart||/[\d\.]/,I=s.number||/^(?:0x[a-f\d]+|0b[01]+|(?:\d+\.?\d*|\.\d+)(?:e[-+]?\d+)?)(u|ll?|l|f)?/i,F=s.isOperatorChar||/[+\-*&%=<>!?|\/]/,z=s.isIdentifierChar||/[\w\$_\xa1-\uffff]/;return{startState:function(e){return{tokenize:null,context:new t((e||0)-h,0,"top",null,!1),indented:0,startOfLine:!0,prevToken:null}},token:function(e,t){var i=t.context;if(e.sol()&&(null==i.align&&(i.align=!1),t.indented=e.indentation(),t.startOfLine=!0),e.eatSpace())return f(e,t),null;p=m=null;var l=(t.tokenize||c)(e,t);if("comment"==l||"meta"==l)return l;if(null==i.align&&(i.align=!0),";"==p||":"==p||","==p&&e.match(/^\s*(?:\/\/.*)?$/,!1))for(;"statement"==t.context.type;)r(t);else if("{"==p)n(t,e.column(),"}");else if("["==p)n(t,e.column(),"]");else if("("==p)n(t,e.column(),")");else if("}"==p){for(;"statement"==i.type;)i=r(t);for("}"==i.type&&(i=r(t));"statement"==i.type;)i=r(t)}else p==i.type?r(t):T&&(("}"==i.type||"top"==i.type)&&";"!=p||"statement"==i.type&&"newstatement"==p)&&n(t,e.column(),"statement",e.current());if("variable"==l&&("def"==t.prevToken||s.typeFirstDefinitions&&o(e,t,e.start)&&a(t.context)&&e.match(/^\s*\(/,!1))&&(l="def"),S.token){var u=S.token(e,t,l);void 0!==u&&(l=u)}return"def"==l&&!1===s.styleDefs&&(l="variable"),t.startOfLine=!1,t.prevToken=m?"def":l||p,f(e,t),l},indent:function(t,n){if(t.tokenize!=c&&null!=t.tokenize||t.typeAtEndOfLine)return e.Pass;var r=t.context,o=n&&n.charAt(0);if("statement"==r.type&&"}"==o&&(r=r.prev),s.dontIndentStatements)for(;"statement"==r.type&&s.dontIndentStatements.test(r.info);)r=r.prev;if(S.indent){var a=S.indent(t,r,n);if("number"==typeof a)return a}var i=o==r.type,l=r.prev&&"switch"==r.prev.info;if(s.allmanIndentation&&/[{(]/.test(o)){for(;"top"!=r.type&&"}"!=r.type;)r=r.prev;return r.indented}return"statement"==r.type?r.indented+("{"==o?0:g):!r.align||y&&")"==r.type?")"!=r.type||i?r.indented+(i?0:h)+(i||!l||/^(?:case|default)\b/.test(n)?0:h):r.indented+g:r.column+(i?0:1)},electricInput:M?/^\s*(?:case .*?:|default:|\{\}?|\})$/:/^\s*[{}]$/,blockCommentStart:"/*",blockCommentEnd:"*/",lineComment:"//",fold:"brace"}});var b="auto if break case register continue return default do sizeof static else struct switch extern typedef union for goto while enum const volatile",k="int long char short double float unsigned signed void size_t ptrdiff_t";h(["text/x-csrc","text/x-c","text/x-chdr"],{name:"clike",keywords:i(b),types:i(k+" bool _Complex _Bool float_t double_t intptr_t intmax_t int8_t int16_t int32_t int64_t uintptr_t uintmax_t uint8_t uint16_t uint32_t uint64_t"),blockKeywords:i("case do else for if switch while struct"),defKeywords:i("struct"),typeFirstDefinitions:!0,atoms:i("null true false"),hooks:{"#":s,"*":c},modeProps:{fold:["brace","include"]}}),h(["text/x-c++src","text/x-c++hdr"],{name:"clike",keywords:i(b+" asm dynamic_cast namespace reinterpret_cast try explicit new static_cast typeid catch operator template typename class friend private this using const_cast inline public throw virtual delete mutable protected alignas alignof constexpr decltype nullptr noexcept thread_local final static_assert override"),types:i(k+" bool wchar_t"),blockKeywords:i("catch class do else finally for if struct switch try while"),defKeywords:i("class namespace struct enum union"),typeFirstDefinitions:!0,atoms:i("true false null"),dontIndentStatements:/^template$/,isIdentifierChar:/[\w\$_~\xa1-\uffff]/,hooks:{"#":s,"*":c,u:d,U:d,L:d,R:d,0:u,1:u,2:u,3:u,4:u,5:u,6:u,7:u,8:u,9:u,token:function(e,t,n){if("variable"==n&&"("==e.peek()&&(";"==t.prevToken||null==t.prevToken||"}"==t.prevToken)&&f(e.current()))return"def"}},namespaceSeparator:"::",modeProps:{fold:["brace","include"]}}),h("text/x-java",{name:"clike",keywords:i("abstract assert break case catch class const continue default do else enum extends final finally float for goto if implements import instanceof interface native new package private protected public return static strictfp super switch synchronized this throw throws transient try volatile while @interface"),types:i("byte short int long float double boolean char void Boolean Byte Character Double Float Integer Long Number Object Short String StringBuffer StringBuilder Void"),blockKeywords:i("catch class do else finally for if switch try while"),defKeywords:i("class interface package enum @interface"),typeFirstDefinitions:!0,atoms:i("true false null"),number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,hooks:{"@":function(e){return!e.match("interface",!1)&&(e.eatWhile(/[\w\$_]/),"meta")}},modeProps:{fold:["brace","import"]}}),h("text/x-csharp",{name:"clike",keywords:i("abstract as async await base break case catch checked class const continue default delegate do else enum event explicit extern finally fixed for foreach goto if implicit in interface internal is lock namespace new operator out override params private protected public readonly ref return sealed sizeof stackalloc static struct switch this throw try typeof unchecked unsafe using virtual void volatile while add alias ascending descending dynamic from get global group into join let orderby partial remove select set value var yield"),types:i("Action Boolean Byte Char DateTime DateTimeOffset Decimal Double Func Guid Int16 Int32 Int64 Object SByte Single String Task TimeSpan UInt16 UInt32 UInt64 bool byte char decimal double short int long object sbyte float string ushort uint ulong"),blockKeywords:i("catch class do else finally for foreach if struct switch try while"),defKeywords:i("class interface namespace struct var"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"@":function(e,t){return e.eat('"')?(t.tokenize=p,p(e,t)):(e.eatWhile(/[\w\$_]/),"meta")}}}),h("text/x-scala",{name:"clike",keywords:i("abstract case catch class def do else extends final finally for forSome if implicit import lazy match new null object override package private protected return sealed super this throw trait try type val var while with yield _ assert assume require print println printf readLine readBoolean readByte readShort readChar readInt readLong readFloat readDouble"),types:i("AnyVal App Application Array BufferedIterator BigDecimal BigInt Char Console Either Enumeration Equiv Error Exception Fractional Function IndexedSeq Int Integral Iterable Iterator List Map Numeric Nil NotNull Option Ordered Ordering PartialFunction PartialOrdering Product Proxy Range Responder Seq Serializable Set Specializable Stream StringBuilder StringContext Symbol Throwable Traversable TraversableOnce Tuple Unit Vector Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),multiLineStrings:!0,blockKeywords:i("catch class enum do else finally for forSome if match switch try while"),defKeywords:i("class enum def object package trait type val var"),atoms:i("true false null"),indentStatements:!1,indentSwitch:!1,isOperatorChar:/[+\-*&%=<>!?|\/#:@]/,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return!!e.match('""')&&(t.tokenize=g,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},"=":function(e,n){var r=n.context;return!("}"!=r.type||!r.align||!e.eat(">"))&&(n.context=new t(r.indented,r.column,r.type,r.info,null,r.prev),"operator")}},modeProps:{closeBrackets:{triples:'"'}}}),h("text/x-kotlin",{name:"clike",keywords:i("package as typealias class interface this super val var fun for is in This throw return break continue object if else while do try when !in !is as? file import where by get set abstract enum open inner override private public internal protected catch finally out final vararg reified dynamic companion constructor init sealed field property receiver param sparam lateinit data inline noinline tailrec external annotation crossinline const operator infix suspend"),types:i("Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),intendSwitch:!1,indentStatements:!1,multiLineStrings:!0,number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,blockKeywords:i("catch class do else finally for if where try while enum"),defKeywords:i("class val var object package interface fun"),atoms:i("true false null this"),hooks:{'"':function(e,t){return t.tokenize=y(e.match('""')),t.tokenize(e,t)}},modeProps:{closeBrackets:{triples:'"'}}}),h(["x-shader/x-vertex","x-shader/x-fragment"],{name:"clike",keywords:i("sampler1D sampler2D sampler3D samplerCube sampler1DShadow sampler2DShadow const attribute uniform varying break continue discard return for while do if else struct in out inout"),types:i("float int bool void vec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4 mat2 mat3 mat4"),blockKeywords:i("for while do if else struct"),builtin:i("radians degrees sin cos tan asin acos atan pow exp log exp2 sqrt inversesqrt abs sign floor ceil fract mod min max clamp mix step smoothstep length distance dot cross normalize ftransform faceforward reflect refract matrixCompMult lessThan lessThanEqual greaterThan greaterThanEqual equal notEqual any all not texture1D texture1DProj texture1DLod texture1DProjLod texture2D texture2DProj texture2DLod texture2DProjLod texture3D texture3DProj texture3DLod texture3DProjLod textureCube textureCubeLod shadow1D shadow2D shadow1DProj shadow2DProj shadow1DLod shadow2DLod shadow1DProjLod shadow2DProjLod dFdx dFdy fwidth noise1 noise2 noise3 noise4"),atoms:i("true false gl_FragColor gl_SecondaryColor gl_Normal gl_Vertex gl_MultiTexCoord0 gl_MultiTexCoord1 gl_MultiTexCoord2 gl_MultiTexCoord3 gl_MultiTexCoord4 gl_MultiTexCoord5 gl_MultiTexCoord6 gl_MultiTexCoord7 gl_FogCoord gl_PointCoord gl_Position gl_PointSize gl_ClipVertex gl_FrontColor gl_BackColor gl_FrontSecondaryColor gl_BackSecondaryColor gl_TexCoord gl_FogFragCoord gl_FragCoord gl_FrontFacing gl_FragData gl_FragDepth gl_ModelViewMatrix gl_ProjectionMatrix gl_ModelViewProjectionMatrix gl_TextureMatrix gl_NormalMatrix gl_ModelViewMatrixInverse gl_ProjectionMatrixInverse gl_ModelViewProjectionMatrixInverse gl_TexureMatrixTranspose gl_ModelViewMatrixInverseTranspose gl_ProjectionMatrixInverseTranspose gl_ModelViewProjectionMatrixInverseTranspose gl_TextureMatrixInverseTranspose gl_NormalScale gl_DepthRange gl_ClipPlane gl_Point gl_FrontMaterial gl_BackMaterial gl_LightSource gl_LightModel gl_FrontLightModelProduct gl_BackLightModelProduct gl_TextureColor gl_EyePlaneS gl_EyePlaneT gl_EyePlaneR gl_EyePlaneQ gl_FogParameters gl_MaxLights gl_MaxClipPlanes gl_MaxTextureUnits gl_MaxTextureCoords gl_MaxVertexAttribs gl_MaxVertexUniformComponents gl_MaxVaryingFloats gl_MaxVertexTextureImageUnits gl_MaxTextureImageUnits gl_MaxFragmentUniformComponents gl_MaxCombineTextureImageUnits gl_MaxDrawBuffers"),indentSwitch:!1,hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-nesc",{name:"clike",keywords:i(b+"as atomic async call command component components configuration event generic implementation includes interface module new norace nx_struct nx_union post provides signal task uses abstract extends"),types:i(k),blockKeywords:i("case do else for if switch while struct"),atoms:i("null true false"),hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-objectivec",{name:"clike",keywords:i(b+"inline restrict _Bool _Complex _Imaginary BOOL Class bycopy byref id IMP in inout nil oneway out Protocol SEL self super atomic nonatomic retain copy readwrite readonly"),types:i(k),atoms:i("YES NO NULL NILL ON OFF true false"),hooks:{"@":function(e){return e.eatWhile(/[\w\$]/),"keyword"},"#":s,indent:function(e,t,n){if("statement"==t.type&&/^@\w/.test(n))return t.indented}},modeProps:{fold:"brace"}}),h("text/x-squirrel",{name:"clike",keywords:i("base break clone continue const default delete enum extends function in class foreach local resume return this throw typeof yield constructor instanceof static"),types:i(k),blockKeywords:i("case catch class else for foreach if switch try while"),defKeywords:i("function local class"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"#":s},modeProps:{fold:["brace","include"]}});var w=null;h("text/x-ceylon",{name:"clike",keywords:i("abstracts alias assembly assert assign break case catch class continue dynamic else exists extends finally for function given if import in interface is let module new nonempty object of out outer package return satisfies super switch then this throw try value void while"),types:function(e){var t=e.charAt(0);return t===t.toUpperCase()&&t!==t.toLowerCase()},blockKeywords:i("case catch class dynamic else finally for function if interface module new object switch try while"),defKeywords:i("class dynamic function interface module object package value"),builtin:i("abstract actual aliased annotation by default deprecated doc final formal late license native optional sealed see serializable shared suppressWarnings tagged throws variable"),isPunctuationChar:/[\[\]{}\(\),;\:\.`]/,isOperatorChar:/[+\-*&%=<>!?|^~:\/]/,numberStart:/[\d#$]/,number:/^(?:#[\da-fA-F_]+|\$[01_]+|[\d_]+[kMGTPmunpf]?|[\d_]+\.[\d_]+(?:[eE][-+]?\d+|[kMGTPmunpf]|)|)/i,multiLineStrings:!0,typeFirstDefinitions:!0,atoms:i("true false null larger smaller equal empty finished"),indentSwitch:!1,styleDefs:!1,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return t.tokenize=x(e.match('""')?"triple":"single"),t.tokenize(e,t)},"`":function(e,t){return!(!w||!e.match("`"))&&(t.tokenize=w,w=null,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},token:function(e,t,n){if(("variable"==n||"type"==n)&&"."==t.prevToken)return"variable-2"}},modeProps:{fold:["brace","import"],closeBrackets:{triples:'"'}}})});
      // -------------------------------------------------------------------------
//  Part of the CodeChecker project, under the Apache License v2.0 with
//  LLVM Exceptions. See LICENSE for license information.
//  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
// -------------------------------------------------------------------------

var BugViewer = {
  _files : [],
  _reports : [],
  _lineWidgets : [],
  _navigationMenuItems : [],
  _sourceFileData : null,
  _currentReport : null,
  _lastBugEvent  : null,

  init : function (files, reports) {
    this._files = files;
    this._reports = reports;

    this.initEscapeChars();
  },

  initEscapeChars : function () {
    this.escapeChars = {
      ' ' : 'nbsp',
      '<' : 'lt',
      '>' : 'gt',
      '"' : 'quot',
      '&' : 'amp'
    };

    var regexString = '[';
    for (var key in this.escapeChars) {
      regexString += key;
    }
    regexString += ']';

    this.escapeRegExp = new RegExp( regexString, 'g');
  },

  escapeHTML : function (str) {
    var that = this;

    return str.replace(this.escapeRegExp, function (m) {
      return '&' + that.escapeChars[m] + ';';
    });
  },

  initByUrl : function () {
    if (!this._reports) return;

    var state = {};
    window.location.hash.substr(1).split('&').forEach(function (s) {
      var parts = s.split('=');
      state[parts[0]] = parts[1];
    });

    for (var key in this._reports) {
      var report = this._reports[key];
      if (report.reportHash === state['reportHash']) {
        this.navigate(report);
        return;
      }
    }

    this.navigate(this._reports[0]);
  },

  create : function () {
    this._content = document.getElementById('editor-wrapper');
    this._filepath = document.getElementById('file-path');
    this._checkerName = document.getElementById('checker-name');
    this._reviewStatusWrapper =
      document.getElementById('review-status-wrapper');
    this._reviewStatus = document.getElementById('review-status');
    this._editor = document.getElementById('editor');

    this._codeMirror = CodeMirror(this._editor, {
      mode: 'text/x-c++src',
      matchBrackets : true,
      lineNumbers : true,
      readOnly : true,
      foldGutter : true,
      extraKeys : {},
      viewportMargin : 100
    });

    this._createNavigationMenu();
  },

  navigate : function (report, item) {
    if (!item) {
      var items = this._navigationMenuItems.filter(function (navItem) {
        return navItem.report.reportHash === report.reportHash;
      });

      if (!items.length) return;

      item = items[0].widget;
    }

    this._selectedReport.classList.remove('active');
    this._selectedReport = item;
    this._selectedReport.classList.add('active');
    this.setReport(report);
  },

  _createNavigationMenu : function () {
    var that = this;

    var nav = document.getElementById('report-nav');
    var list = document.createElement('ul');
    this._reports.forEach(function (report) {
      var events = report['events'];
      var lastBugEvent = events[events.length - 1];
      var item = document.createElement('li');

      var severity = document.createElement('i');
      severity.className = 'severity-' + report.severity.toLowerCase();

      item.appendChild(severity);
      item.appendChild(document.createTextNode(lastBugEvent.message));

      item.addEventListener('click', function () {
        that.navigate(report, item);
      })
      list.appendChild(item);
      that._navigationMenuItems.push({ report : report, widget : item });
    });

    if (!this._selectedReport && list.childNodes.length) {
      this._selectedReport = list.childNodes[0];
      this._selectedReport.classList.add('active');
    }

    nav.appendChild(list);
  },

  setReport : function (report) {
    this._currentReport = report;
    var events = report['events'];
    var lastBugEvent = events[events.length - 1];
    this.setCurrentBugEvent(lastBugEvent, events.length - 1);
    this.setCheckerName(report.checkerName);
    this.setReviewStatus(report.reviewStatus);

    window.location.hash = '#reportHash=' + report.reportHash;
  },

  setCurrentBugEvent : function (event, idx) {
    this._currentBugEvent = event;
    this.setSourceFileData(this._files[event.location.file]);
    this.drawBugPath();

    this.jumpTo(event.location.line, 0);
    this.highlightBugEvent(event, idx);
  },

  highlightBugEvent : function (event, idx) {
    this._lineWidgets.forEach(function (widget) {
      var lineIdx = widget.node.getAttribute('idx');
      if (parseInt(lineIdx) === idx) {
        widget.node.classList.add('current');
      }
    });
  },

  setCheckerName : function (checkerName) {
    this._checkerName.innerHTML = checkerName;
  },

  setReviewStatus : function (status) {
    if (status) {
      var className =
        'review-status-' + status.toLowerCase().split(' ').join('-');
      this._reviewStatus.className = "review-status " + className;

      this._reviewStatus.innerHTML = status;
      this._reviewStatusWrapper.style.display = 'block';
    } else {
      this._reviewStatusWrapper.style.display = 'none';
    }
  },

  setSourceFileData : function (file) {
    if (this._sourceFileData && file.id === this._sourceFileData.id) {
      return;
    }

    this._sourceFileData = file;
    this._filepath.innerHTML = file.path;
    this._codeMirror.doc.setValue(file.content);
    this._refresh();
  },

  _refresh : function () {
    var that = this;
    setTimeout(function () {
      var fullHeight = parseInt(that._content.clientHeight);
      var headerHeight = that._filepath.clientHeight;

      that._codeMirror.setSize('auto', fullHeight - headerHeight);
      that._codeMirror.refresh();
    }, 200);
  },

  clearBubbles : function () {
    this._lineWidgets.forEach(function (widget) { widget.clear(); });
    this._lineWidgets = [];
  },

  getMessage : function (event, kind) {
    if (kind === 'macro') {
      var name = 'macro expansion' + (event.name ? ': ' + event.name : '');

      return '<span class="tag macro">' + name + '</span>'
        + this.escapeHTML(event.expansion).replace(/(?:\r\n|\r|\n)/g, '<br>');
    } else if (kind === 'note') {
      return '<span class="tag note">note</span>'
        +  this.escapeHTML(event.message).replace(/(?:\r\n|\r|\n)/g, '<br>');
    }
  },

  addExtraPathEvents : function (events, kind) {
    var that = this;

    if (!events) {
      return;
    }

    events.forEach(function (event) {
      if (event.location.file !== that._currentBugEvent.location.file) {
        return;
      }

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + kind);

      var msg = document.createElement('span');
      msg.innerHTML = that.getMessage(event, kind);
      element.appendChild(msg);

      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  drawBugPath : function () {
    var that = this;

    this.clearBubbles();

    this.addExtraPathEvents(this._currentReport.macros, 'macro');
    this.addExtraPathEvents(this._currentReport.notes, 'note');

    // Processing bug path events.
    var currentEvents = this._currentReport.events;
    currentEvents.forEach(function (event, step) {
      if (event.location.file !== that._currentBugEvent.location.file)
        return;

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';
      var type = step === currentEvents.length - 1 ? 'error' : 'info';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + type);
      element.setAttribute('idx', step);

      var enumeration = document.createElement('span');
      enumeration.setAttribute('class', 'checker-enum ' + type);
      enumeration.innerHTML = step + 1;

      if (currentEvents.length > 1)
        element.appendChild(enumeration);

      var prevBugEvent = step - 1;
      if (step > 0) {
        var prevBug = document.createElement('span');
        prevBug.setAttribute('class', 'arrow left-arrow');
        prevBug.addEventListener('click', function () {
          var event = currentEvents[prevBugEvent];
          that.setCurrentBugEvent(event, prevBugEvent);
        });
        element.appendChild(prevBug);
      }

      var msg = document.createElement('span');
      msg.innerHTML = that.escapeHTML(event.message)
        .replace(/(?:\r\n|\r|\n)/g, '<br>');

      element.appendChild(msg);

      var nextBugEvent = step + 1;
      if (nextBugEvent < currentEvents.length) {
        var nextBug = document.createElement('span');
        nextBug.setAttribute('class', 'arrow right-arrow');
        nextBug.addEventListener('click', function () {
          var event = currentEvents[nextBugEvent];
          that.setCurrentBugEvent(event, nextBugEvent);
        });
        element.appendChild(nextBug);
      }


      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  jumpTo : function (line, column) {
    var that = this;

    setTimeout(function () {
      var selPosPixel
        = that._codeMirror.charCoords({ line : line, ch : column }, 'local');
      var editorSize = {
        width  : that._editor.clientWidth,
        height : that._editor.clientHeight
      };

      that._codeMirror.scrollIntoView({
        top    : selPosPixel.top - 100,
        bottom : selPosPixel.top + editorSize.height - 150,
        left   : selPosPixel.left < editorSize.width - 100
               ? 0
               : selPosPixel.left - 50,
        right  : selPosPixel.left < editorSize.width - 100
               ? 10
               : selPosPixel.left + editorSize.width - 100
      });
    }, 0);
  }
}


      var data = {"files": {"3": {"id": 3, "path": "/home/vsts/work/1/ccache/src/third_party/doctest.h", "content": "// ====================================================================== lgtm [cpp/missing-header-guard]\n// == DO NOT MODIFY THIS FILE BY HAND - IT IS AUTO GENERATED BY CMAKE! ==\n// ======================================================================\n//\n// doctest.h - the lightest feature-rich C++ single-header testing framework for unit tests and TDD\n//\n// Copyright (c) 2016-2021 Viktor Kirilov\n//\n// Distributed under the MIT Software License\n// See accompanying file LICENSE.txt or copy at\n// https://opensource.org/licenses/MIT\n//\n// The documentation can be found at the library's page:\n// https://github.com/onqtam/doctest/blob/master/doc/markdown/readme.md\n//\n// =================================================================================================\n// =================================================================================================\n// =================================================================================================\n//\n// The library is heavily influenced by Catch - https://github.com/catchorg/Catch2\n// which uses the Boost Software License - Version 1.0\n// see here - https://github.com/catchorg/Catch2/blob/master/LICENSE.txt\n//\n// The concept of subcases (sections in Catch) and expression decomposition are from there.\n// Some parts of the code are taken directly:\n// - stringification - the detection of \"ostream& operator<<(ostream&, const T&)\" and StringMaker<>\n// - the Approx() helper class for floating point comparison\n// - colors in the console\n// - breaking into a debugger\n// - signal / SEH handling\n// - timer\n// - XmlWriter class - thanks to Phil Nash for allowing the direct reuse (AKA copy/paste)\n//\n// The expression decomposing templates are taken from lest - https://github.com/martinmoene/lest\n// which uses the Boost Software License - Version 1.0\n// see here - https://github.com/martinmoene/lest/blob/master/LICENSE.txt\n//\n// =================================================================================================\n// =================================================================================================\n// =================================================================================================\n\n#ifndef DOCTEST_LIBRARY_INCLUDED\n#define DOCTEST_LIBRARY_INCLUDED\n\n// =================================================================================================\n// == VERSION ======================================================================================\n// =================================================================================================\n\n#define DOCTEST_VERSION_MAJOR 2\n#define DOCTEST_VERSION_MINOR 4\n#define DOCTEST_VERSION_PATCH 5\n#define DOCTEST_VERSION_STR \"2.4.5\"\n\n#define DOCTEST_VERSION                                                                            \\\n    (DOCTEST_VERSION_MAJOR * 10000 + DOCTEST_VERSION_MINOR * 100 + DOCTEST_VERSION_PATCH)\n\n// =================================================================================================\n// == COMPILER VERSION =============================================================================\n// =================================================================================================\n\n// ideas for the version stuff are taken from here: https://github.com/cxxstuff/cxx_detect\n\n#define DOCTEST_COMPILER(MAJOR, MINOR, PATCH) ((MAJOR)*10000000 + (MINOR)*100000 + (PATCH))\n\n// GCC/Clang and GCC/MSVC are mutually exclusive, but Clang/MSVC are not because of clang-cl...\n#if defined(_MSC_VER) && defined(_MSC_FULL_VER)\n#if _MSC_VER == _MSC_FULL_VER / 10000\n#define DOCTEST_MSVC DOCTEST_COMPILER(_MSC_VER / 100, _MSC_VER % 100, _MSC_FULL_VER % 10000)\n#else // MSVC\n#define DOCTEST_MSVC                                                                               \\\n    DOCTEST_COMPILER(_MSC_VER / 100, (_MSC_FULL_VER / 100000) % 100, _MSC_FULL_VER % 100000)\n#endif // MSVC\n#endif // MSVC\n#if defined(__clang__) && defined(__clang_minor__)\n#define DOCTEST_CLANG DOCTEST_COMPILER(__clang_major__, __clang_minor__, __clang_patchlevel__)\n#elif defined(__GNUC__) && defined(__GNUC_MINOR__) && defined(__GNUC_PATCHLEVEL__) &&              \\\n        !defined(__INTEL_COMPILER)\n#define DOCTEST_GCC DOCTEST_COMPILER(__GNUC__, __GNUC_MINOR__, __GNUC_PATCHLEVEL__)\n#endif // GCC\n\n#ifndef DOCTEST_MSVC\n#define DOCTEST_MSVC 0\n#endif // DOCTEST_MSVC\n#ifndef DOCTEST_CLANG\n#define DOCTEST_CLANG 0\n#endif // DOCTEST_CLANG\n#ifndef DOCTEST_GCC\n#define DOCTEST_GCC 0\n#endif // DOCTEST_GCC\n\n// =================================================================================================\n// == COMPILER WARNINGS HELPERS ====================================================================\n// =================================================================================================\n\n#if DOCTEST_CLANG\n#define DOCTEST_PRAGMA_TO_STR(x) _Pragma(#x)\n#define DOCTEST_CLANG_SUPPRESS_WARNING_PUSH _Pragma(\"clang diagnostic push\")\n#define DOCTEST_CLANG_SUPPRESS_WARNING(w) DOCTEST_PRAGMA_TO_STR(clang diagnostic ignored w)\n#define DOCTEST_CLANG_SUPPRESS_WARNING_POP _Pragma(\"clang diagnostic pop\")\n#define DOCTEST_CLANG_SUPPRESS_WARNING_WITH_PUSH(w)                                                \\\n    DOCTEST_CLANG_SUPPRESS_WARNING_PUSH DOCTEST_CLANG_SUPPRESS_WARNING(w)\n#else // DOCTEST_CLANG\n#define DOCTEST_CLANG_SUPPRESS_WARNING_PUSH\n#define DOCTEST_CLANG_SUPPRESS_WARNING(w)\n#define DOCTEST_CLANG_SUPPRESS_WARNING_POP\n#define DOCTEST_CLANG_SUPPRESS_WARNING_WITH_PUSH(w)\n#endif // DOCTEST_CLANG\n\n#if DOCTEST_GCC\n#define DOCTEST_PRAGMA_TO_STR(x) _Pragma(#x)\n#define DOCTEST_GCC_SUPPRESS_WARNING_PUSH _Pragma(\"GCC diagnostic push\")\n#define DOCTEST_GCC_SUPPRESS_WARNING(w) DOCTEST_PRAGMA_TO_STR(GCC diagnostic ignored w)\n#define DOCTEST_GCC_SUPPRESS_WARNING_POP _Pragma(\"GCC diagnostic pop\")\n#define DOCTEST_GCC_SUPPRESS_WARNING_WITH_PUSH(w)                                                  \\\n    DOCTEST_GCC_SUPPRESS_WARNING_PUSH DOCTEST_GCC_SUPPRESS_WARNING(w)\n#else // DOCTEST_GCC\n#define DOCTEST_GCC_SUPPRESS_WARNING_PUSH\n#define DOCTEST_GCC_SUPPRESS_WARNING(w)\n#define DOCTEST_GCC_SUPPRESS_WARNING_POP\n#define DOCTEST_GCC_SUPPRESS_WARNING_WITH_PUSH(w)\n#endif // DOCTEST_GCC\n\n#if DOCTEST_MSVC\n#define DOCTEST_MSVC_SUPPRESS_WARNING_PUSH __pragma(warning(push))\n#define DOCTEST_MSVC_SUPPRESS_WARNING(w) __pragma(warning(disable : w))\n#define DOCTEST_MSVC_SUPPRESS_WARNING_POP __pragma(warning(pop))\n#define DOCTEST_MSVC_SUPPRESS_WARNING_WITH_PUSH(w)                                                 \\\n    DOCTEST_MSVC_SUPPRESS_WARNING_PUSH DOCTEST_MSVC_SUPPRESS_WARNING(w)\n#else // DOCTEST_MSVC\n#define DOCTEST_MSVC_SUPPRESS_WARNING_PUSH\n#define DOCTEST_MSVC_SUPPRESS_WARNING(w)\n#define DOCTEST_MSVC_SUPPRESS_WARNING_POP\n#define DOCTEST_MSVC_SUPPRESS_WARNING_WITH_PUSH(w)\n#endif // DOCTEST_MSVC\n\n// =================================================================================================\n// == COMPILER WARNINGS ============================================================================\n// =================================================================================================\n\nDOCTEST_CLANG_SUPPRESS_WARNING_PUSH\nDOCTEST_CLANG_SUPPRESS_WARNING(\"-Wunknown-pragmas\")\nDOCTEST_CLANG_SUPPRESS_WARNING(\"-Wnon-virtual-dtor\")\nDOCTEST_CLANG_SUPPRESS_WARNING(\"-Wweak-vtables\")\nDOCTEST_CLANG_SUPPRESS_WARNING(\"-Wpadded\")\nDOCTEST_CLANG_SUPPRESS_WARNING(\"-Wdeprecated\")\nDOCTEST_CLANG_SUPPRESS_WARNING(\"-Wmissing-prototypes\")\nDOCTEST_CLANG_SUPPRESS_WARNING(\"-Wunused-local-typedef\")\nDOCTEST_CLANG_SUPPRESS_WARNING(\"-Wc++98-compat\")\nDOCTEST_CLANG_SUPPRESS_WARNING(\"-Wc++98-compat-pedantic\")\n\nDOCTEST_GCC_SUPPRESS_WARNING_PUSH\nDOCTEST_GCC_SUPPRESS_WARNING(\"-Wunknown-pragmas\")\nDOCTEST_GCC_SUPPRESS_WARNING(\"-Wpragmas\")\nDOCTEST_GCC_SUPPRESS_WARNING(\"-Weffc++\")\nDOCTEST_GCC_SUPPRESS_WARNING(\"-Wstrict-overflow\")\nDOCTEST_GCC_SUPPRESS_WARNING(\"-Wstrict-aliasing\")\nDOCTEST_GCC_SUPPRESS_WARNING(\"-Wctor-dtor-privacy\")\nDOCTEST_GCC_SUPPRESS_WARNING(\"-Wmissing-declarations\")\nDOCTEST_GCC_SUPPRESS_WARNING(\"-Wnon-virtual-dtor\")\nDOCTEST_GCC_SUPPRESS_WARNING(\"-Wunused-local-typedefs\")\nDOCTEST_GCC_SUPPRESS_WARNING(\"-Wuseless-cast\")\nDOCTEST_GCC_SUPPRESS_WARNING(\"-Wnoexcept\")\nDOCTEST_GCC_SUPPRESS_WARNING(\"-Wsign-promo\")\n\nDOCTEST_MSVC_SUPPRESS_WARNING_PUSH\nDOCTEST_MSVC_SUPPRESS_WARNING(4616) // invalid compiler warning\nDOCTEST_MSVC_SUPPRESS_WARNING(4619) // invalid compiler warning\nDOCTEST_MSVC_SUPPRESS_WARNING(4996) // The compiler encountered a deprecated declaration\nDOCTEST_MSVC_SUPPRESS_WARNING(4706) // assignment within conditional expression\nDOCTEST_MSVC_SUPPRESS_WARNING(4512) // 'class' : assignment operator could not be generated\nDOCTEST_MSVC_SUPPRESS_WARNING(4127) // conditional expression is constant\nDOCTEST_MSVC_SUPPRESS_WARNING(4820) // padding\nDOCTEST_MSVC_SUPPRESS_WARNING(4625) // copy constructor was implicitly defined as deleted\nDOCTEST_MSVC_SUPPRESS_WARNING(4626) // assignment operator was implicitly defined as deleted\nDOCTEST_MSVC_SUPPRESS_WARNING(5027) // move assignment operator was implicitly defined as deleted\nDOCTEST_MSVC_SUPPRESS_WARNING(5026) // move constructor was implicitly defined as deleted\nDOCTEST_MSVC_SUPPRESS_WARNING(4623) // default constructor was implicitly defined as deleted\nDOCTEST_MSVC_SUPPRESS_WARNING(4640) // construction of local static object is not thread-safe\n// static analysis\nDOCTEST_MSVC_SUPPRESS_WARNING(26439) // This kind of function may not throw. Declare it 'noexcept'\nDOCTEST_MSVC_SUPPRESS_WARNING(26495) // Always initialize a member variable\nDOCTEST_MSVC_SUPPRESS_WARNING(26451) // Arithmetic overflow ...\nDOCTEST_MSVC_SUPPRESS_WARNING(26444) // Avoid unnamed objects with custom construction and dtr...\nDOCTEST_MSVC_SUPPRESS_WARNING(26812) // Prefer 'enum class' over 'enum'\n\n// 4548 - expression before comma has no effect; expected expression with side - effect\n// 4265 - class has virtual functions, but destructor is not virtual\n// 4986 - exception specification does not match previous declaration\n// 4350 - behavior change: 'member1' called instead of 'member2'\n// 4668 - 'x' is not defined as a preprocessor macro, replacing with '0' for '#if/#elif'\n// 4365 - conversion from 'int' to 'unsigned long', signed/unsigned mismatch\n// 4774 - format string expected in argument 'x' is not a string literal\n// 4820 - padding in structs\n\n// only 4 should be disabled globally:\n// - 4514 # unreferenced inline function has been removed\n// - 4571 # SEH related\n// - 4710 # function not inlined\n// - 4711 # function 'x' selected for automatic inline expansion\n\n#define DOCTEST_MAKE_STD_HEADERS_CLEAN_FROM_WARNINGS_ON_WALL_BEGIN                                 \\\n    DOCTEST_MSVC_SUPPRESS_WARNING_PUSH                                                             \\\n    DOCTEST_MSVC_SUPPRESS_WARNING(4548)                                                            \\\n    DOCTEST_MSVC_SUPPRESS_WARNING(4265)                                                            \\\n    DOCTEST_MSVC_SUPPRESS_WARNING(4986)                                                            \\\n    DOCTEST_MSVC_SUPPRESS_WARNING(4350)                                                            \\\n    DOCTEST_MSVC_SUPPRESS_WARNING(4668)                                                            \\\n    DOCTEST_MSVC_SUPPRESS_WARNING(4365)                                                            \\\n    DOCTEST_MSVC_SUPPRESS_WARNING(4774)                                                            \\\n    DOCTEST_MSVC_SUPPRESS_WARNING(4820)                                                            \\\n    DOCTEST_MSVC_SUPPRESS_WARNING(4625)                                                            \\\n    DOCTEST_MSVC_SUPPRESS_WARNING(4626)                                                            \\\n    DOCTEST_MSVC_SUPPRESS_WARNING(5027)                                                            \\\n    DOCTEST_MSVC_SUPPRESS_WARNING(5026)                                                            \\\n    DOCTEST_MSVC_SUPPRESS_WARNING(4623)                                                            \\\n    DOCTEST_MSVC_SUPPRESS_WARNING(5039)                                                            \\\n    DOCTEST_MSVC_SUPPRESS_WARNING(5045)                                                            \\\n    DOCTEST_MSVC_SUPPRESS_WARNING(5105)\n\n#define DOCTEST_MAKE_STD_HEADERS_CLEAN_FROM_WARNINGS_ON_WALL_END DOCTEST_MSVC_SUPPRESS_WARNING_POP\n\n// =================================================================================================\n// == FEATURE DETECTION ============================================================================\n// =================================================================================================\n\n// general compiler feature support table: https://en.cppreference.com/w/cpp/compiler_support\n// MSVC C++11 feature support table: https://msdn.microsoft.com/en-us/library/hh567368.aspx\n// GCC C++11 feature support table: https://gcc.gnu.org/projects/cxx-status.html\n// MSVC version table:\n// https://en.wikipedia.org/wiki/Microsoft_Visual_C%2B%2B#Internal_version_numbering\n// MSVC++ 14.2 (16) _MSC_VER == 1920 (Visual Studio 2019)\n// MSVC++ 14.1 (15) _MSC_VER == 1910 (Visual Studio 2017)\n// MSVC++ 14.0      _MSC_VER == 1900 (Visual Studio 2015)\n// MSVC++ 12.0      _MSC_VER == 1800 (Visual Studio 2013)\n// MSVC++ 11.0      _MSC_VER == 1700 (Visual Studio 2012)\n// MSVC++ 10.0      _MSC_VER == 1600 (Visual Studio 2010)\n// MSVC++ 9.0       _MSC_VER == 1500 (Visual Studio 2008)\n// MSVC++ 8.0       _MSC_VER == 1400 (Visual Studio 2005)\n\n#if DOCTEST_MSVC && !defined(DOCTEST_CONFIG_WINDOWS_SEH)\n#define DOCTEST_CONFIG_WINDOWS_SEH\n#endif // MSVC\n#if defined(DOCTEST_CONFIG_NO_WINDOWS_SEH) && defined(DOCTEST_CONFIG_WINDOWS_SEH)\n#undef DOCTEST_CONFIG_WINDOWS_SEH\n#endif // DOCTEST_CONFIG_NO_WINDOWS_SEH\n\n#if !defined(_WIN32) && !defined(__QNX__) && !defined(DOCTEST_CONFIG_POSIX_SIGNALS) &&             \\\n        !defined(__EMSCRIPTEN__)\n#define DOCTEST_CONFIG_POSIX_SIGNALS\n#endif // _WIN32\n#if defined(DOCTEST_CONFIG_NO_POSIX_SIGNALS) && defined(DOCTEST_CONFIG_POSIX_SIGNALS)\n#undef DOCTEST_CONFIG_POSIX_SIGNALS\n#endif // DOCTEST_CONFIG_NO_POSIX_SIGNALS\n\n#ifndef DOCTEST_CONFIG_NO_EXCEPTIONS\n#if !defined(__cpp_exceptions) && !defined(__EXCEPTIONS) && !defined(_CPPUNWIND)\n#define DOCTEST_CONFIG_NO_EXCEPTIONS\n#endif // no exceptions\n#endif // DOCTEST_CONFIG_NO_EXCEPTIONS\n\n#ifdef DOCTEST_CONFIG_NO_EXCEPTIONS_BUT_WITH_ALL_ASSERTS\n#ifndef DOCTEST_CONFIG_NO_EXCEPTIONS\n#define DOCTEST_CONFIG_NO_EXCEPTIONS\n#endif // DOCTEST_CONFIG_NO_EXCEPTIONS\n#endif // DOCTEST_CONFIG_NO_EXCEPTIONS_BUT_WITH_ALL_ASSERTS\n\n#if defined(DOCTEST_CONFIG_NO_EXCEPTIONS) && !defined(DOCTEST_CONFIG_NO_TRY_CATCH_IN_ASSERTS)\n#define DOCTEST_CONFIG_NO_TRY_CATCH_IN_ASSERTS\n#endif // DOCTEST_CONFIG_NO_EXCEPTIONS && !DOCTEST_CONFIG_NO_TRY_CATCH_IN_ASSERTS\n\n#if defined(DOCTEST_CONFIG_IMPLEMENT_WITH_MAIN) && !defined(DOCTEST_CONFIG_IMPLEMENT)\n#define DOCTEST_CONFIG_IMPLEMENT\n#endif // DOCTEST_CONFIG_IMPLEMENT_WITH_MAIN\n\n#if defined(_WIN32) || defined(__CYGWIN__)\n#if DOCTEST_MSVC\n#define DOCTEST_SYMBOL_EXPORT __declspec(dllexport)\n#define DOCTEST_SYMBOL_IMPORT __declspec(dllimport)\n#else // MSVC\n#define DOCTEST_SYMBOL_EXPORT __attribute__((dllexport))\n#define DOCTEST_SYMBOL_IMPORT __attribute__((dllimport))\n#endif // MSVC\n#else  // _WIN32\n#define DOCTEST_SYMBOL_EXPORT __attribute__((visibility(\"default\")))\n#define DOCTEST_SYMBOL_IMPORT\n#endif // _WIN32\n\n#ifdef DOCTEST_CONFIG_IMPLEMENTATION_IN_DLL\n#ifdef DOCTEST_CONFIG_IMPLEMENT\n#define DOCTEST_INTERFACE DOCTEST_SYMBOL_EXPORT\n#else // DOCTEST_CONFIG_IMPLEMENT\n#define DOCTEST_INTERFACE DOCTEST_SYMBOL_IMPORT\n#endif // DOCTEST_CONFIG_IMPLEMENT\n#else  // DOCTEST_CONFIG_IMPLEMENTATION_IN_DLL\n#define DOCTEST_INTERFACE\n#endif // DOCTEST_CONFIG_IMPLEMENTATION_IN_DLL\n\n#define DOCTEST_EMPTY\n\n#if DOCTEST_MSVC\n#define DOCTEST_NOINLINE __declspec(noinline)\n#define DOCTEST_UNUSED\n#define DOCTEST_ALIGNMENT(x)\n#elif DOCTEST_CLANG && DOCTEST_CLANG < DOCTEST_COMPILER(3, 5, 0)\n#define DOCTEST_NOINLINE\n#define DOCTEST_UNUSED\n#define DOCTEST_ALIGNMENT(x)\n#else\n#define DOCTEST_NOINLINE __attribute__((noinline))\n#define DOCTEST_UNUSED __attribute__((unused))\n#define DOCTEST_ALIGNMENT(x) __attribute__((aligned(x)))\n#endif\n\n#ifndef DOCTEST_NORETURN\n#define DOCTEST_NORETURN [[noreturn]]\n#endif // DOCTEST_NORETURN\n\n#ifndef DOCTEST_NOEXCEPT\n#define DOCTEST_NOEXCEPT noexcept\n#endif // DOCTEST_NOEXCEPT\n\n// =================================================================================================\n// == FEATURE DETECTION END ========================================================================\n// =================================================================================================\n\n// internal macros for string concatenation and anonymous variable name generation\n#define DOCTEST_CAT_IMPL(s1, s2) s1##s2\n#define DOCTEST_CAT(s1, s2) DOCTEST_CAT_IMPL(s1, s2)\n#ifdef __COUNTER__ // not standard and may be missing for some compilers\n#define DOCTEST_ANONYMOUS(x) DOCTEST_CAT(x, __COUNTER__)\n#else // __COUNTER__\n#define DOCTEST_ANONYMOUS(x) DOCTEST_CAT(x, __LINE__)\n#endif // __COUNTER__\n\n#define DOCTEST_TOSTR(x) #x\n\n#ifndef DOCTEST_CONFIG_ASSERTION_PARAMETERS_BY_VALUE\n#define DOCTEST_REF_WRAP(x) x&\n#else // DOCTEST_CONFIG_ASSERTION_PARAMETERS_BY_VALUE\n#define DOCTEST_REF_WRAP(x) x\n#endif // DOCTEST_CONFIG_ASSERTION_PARAMETERS_BY_VALUE\n\n// not using __APPLE__ because... this is how Catch does it\n#ifdef __MAC_OS_X_VERSION_MIN_REQUIRED\n#define DOCTEST_PLATFORM_MAC\n#elif defined(__IPHONE_OS_VERSION_MIN_REQUIRED)\n#define DOCTEST_PLATFORM_IPHONE\n#elif defined(_WIN32)\n#define DOCTEST_PLATFORM_WINDOWS\n#else // DOCTEST_PLATFORM\n#define DOCTEST_PLATFORM_LINUX\n#endif // DOCTEST_PLATFORM\n\n#define DOCTEST_GLOBAL_NO_WARNINGS(var)                                                            \\\n    DOCTEST_CLANG_SUPPRESS_WARNING_WITH_PUSH(\"-Wglobal-constructors\")                              \\\n    DOCTEST_CLANG_SUPPRESS_WARNING(\"-Wunused-variable\")                                            \\\n    static const int var DOCTEST_UNUSED // NOLINT(fuchsia-statically-constructed-objects,cert-err58-cpp)\n#define DOCTEST_GLOBAL_NO_WARNINGS_END() DOCTEST_CLANG_SUPPRESS_WARNING_POP\n\n#ifndef DOCTEST_BREAK_INTO_DEBUGGER\n// should probably take a look at https://github.com/scottt/debugbreak\n#ifdef DOCTEST_PLATFORM_LINUX\n#if defined(__GNUC__) && (defined(__i386) || defined(__x86_64))\n// Break at the location of the failing check if possible\n#define DOCTEST_BREAK_INTO_DEBUGGER() __asm__(\"int $3\\n\" : :) // NOLINT (hicpp-no-assembler)\n#else\n#include <signal.h>\n#define DOCTEST_BREAK_INTO_DEBUGGER() raise(SIGTRAP)\n#endif\n#elif defined(DOCTEST_PLATFORM_MAC)\n#if defined(__x86_64) || defined(__x86_64__) || defined(__amd64__) || defined(__i386)\n#define DOCTEST_BREAK_INTO_DEBUGGER() __asm__(\"int $3\\n\" : :) // NOLINT (hicpp-no-assembler)\n#else\n#define DOCTEST_BREAK_INTO_DEBUGGER() __asm__(\"brk #0\"); // NOLINT (hicpp-no-assembler)\n#endif\n#elif DOCTEST_MSVC\n#define DOCTEST_BREAK_INTO_DEBUGGER() __debugbreak()\n#elif defined(__MINGW32__)\nDOCTEST_GCC_SUPPRESS_WARNING_WITH_PUSH(\"-Wredundant-decls\")\nextern \"C\" __declspec(dllimport) void __stdcall DebugBreak();\nDOCTEST_GCC_SUPPRESS_WARNING_POP\n#define DOCTEST_BREAK_INTO_DEBUGGER() ::DebugBreak()\n#else // linux\n#define DOCTEST_BREAK_INTO_DEBUGGER() (static_cast<void>(0))\n#endif // linux\n#endif // DOCTEST_BREAK_INTO_DEBUGGER\n\n// this is kept here for backwards compatibility since the config option was changed\n#ifdef DOCTEST_CONFIG_USE_IOSFWD\n#define DOCTEST_CONFIG_USE_STD_HEADERS\n#endif // DOCTEST_CONFIG_USE_IOSFWD\n\n#ifdef DOCTEST_CONFIG_USE_STD_HEADERS\n#ifndef DOCTEST_CONFIG_INCLUDE_TYPE_TRAITS\n#define DOCTEST_CONFIG_INCLUDE_TYPE_TRAITS\n#endif // DOCTEST_CONFIG_INCLUDE_TYPE_TRAITS\n#include <iosfwd>\n#include <cstddef>\n#include <ostream>\n#else // DOCTEST_CONFIG_USE_STD_HEADERS\n\n#if DOCTEST_CLANG\n// to detect if libc++ is being used with clang (the _LIBCPP_VERSION identifier)\n#include <ciso646>\n#endif // clang\n\n#ifdef _LIBCPP_VERSION\n#define DOCTEST_STD_NAMESPACE_BEGIN _LIBCPP_BEGIN_NAMESPACE_STD\n#define DOCTEST_STD_NAMESPACE_END _LIBCPP_END_NAMESPACE_STD\n#else // _LIBCPP_VERSION\n#define DOCTEST_STD_NAMESPACE_BEGIN namespace std {\n#define DOCTEST_STD_NAMESPACE_END }\n#endif // _LIBCPP_VERSION\n\n// Forward declaring 'X' in namespace std is not permitted by the C++ Standard.\nDOCTEST_MSVC_SUPPRESS_WARNING_WITH_PUSH(4643)\n\nDOCTEST_STD_NAMESPACE_BEGIN // NOLINT (cert-dcl58-cpp)\ntypedef decltype(nullptr) nullptr_t;\ntemplate <class charT>\nstruct char_traits;\ntemplate <>\nstruct char_traits<char>;\ntemplate <class charT, class traits>\nclass basic_ostream;\ntypedef basic_ostream<char, char_traits<char>> ostream;\ntemplate <class... Types>\nclass tuple;\n#if DOCTEST_MSVC >= DOCTEST_COMPILER(19, 20, 0)\n// see this issue on why this is needed: https://github.com/onqtam/doctest/issues/183\ntemplate <class _Ty>\nclass allocator;\ntemplate <class _Elem, class _Traits, class _Alloc>\nclass basic_string;\nusing string = basic_string<char, char_traits<char>, allocator<char>>;\n#endif // VS 2019\nDOCTEST_STD_NAMESPACE_END\n\nDOCTEST_MSVC_SUPPRESS_WARNING_POP\n\n#endif // DOCTEST_CONFIG_USE_STD_HEADERS\n\n#ifdef DOCTEST_CONFIG_INCLUDE_TYPE_TRAITS\n#include <type_traits>\n#endif // DOCTEST_CONFIG_INCLUDE_TYPE_TRAITS\n\nnamespace doctest {\n\nDOCTEST_INTERFACE extern bool is_running_in_test;\n\n// A 24 byte string class (can be as small as 17 for x64 and 13 for x86) that can hold strings with length\n// of up to 23 chars on the stack before going on the heap - the last byte of the buffer is used for:\n// - \"is small\" bit - the highest bit - if \"0\" then it is small - otherwise its \"1\" (128)\n// - if small - capacity left before going on the heap - using the lowest 5 bits\n// - if small - 2 bits are left unused - the second and third highest ones\n// - if small - acts as a null terminator if strlen() is 23 (24 including the null terminator)\n//              and the \"is small\" bit remains \"0\" (\"as well as the capacity left\") so its OK\n// Idea taken from this lecture about the string implementation of facebook/folly - fbstring\n// https://www.youtube.com/watch?v=kPR8h4-qZdk\n// TODO:\n// - optimizations - like not deleting memory unnecessarily in operator= and etc.\n// - resize/reserve/clear\n// - substr\n// - replace\n// - back/front\n// - iterator stuff\n// - find & friends\n// - push_back/pop_back\n// - assign/insert/erase\n// - relational operators as free functions - taking const char* as one of the params\nclass DOCTEST_INTERFACE String\n{\n    static const unsigned len  = 24;      //!OCLINT avoid private static members\n    static const unsigned last = len - 1; //!OCLINT avoid private static members\n\n    struct view // len should be more than sizeof(view) - because of the final byte for flags\n    {\n        char*    ptr;\n        unsigned size;\n        unsigned capacity;\n    };\n\n    union\n    {\n        char buf[len];\n        view data;\n    };\n\n    bool isOnStack() const { return (buf[last] & 128) == 0; }\n    void setOnHeap();\n    void setLast(unsigned in = last);\n\n    void copy(const String& other);\n\npublic:\n    String();\n    ~String();\n\n    // cppcheck-suppress noExplicitConstructor\n    String(const char* in);\n    String(const char* in, unsigned in_size);\n\n    String(const String& other);\n    String& operator=(const String& other);\n\n    String& operator+=(const String& other);\n    String  operator+(const String& other) const;\n\n    String(String&& other);\n    String& operator=(String&& other);\n\n    char  operator[](unsigned i) const;\n    char& operator[](unsigned i);\n\n    // the only functions I'm willing to leave in the interface - available for inlining\n    const char* c_str() const { return const_cast<String*>(this)->c_str(); } // NOLINT\n    char*       c_str() {\n        if(isOnStack())\n            return reinterpret_cast<char*>(buf);\n        return data.ptr;\n    }\n\n    unsigned size() const;\n    unsigned capacity() const;\n\n    int compare(const char* other, bool no_case = false) const;\n    int compare(const String& other, bool no_case = false) const;\n};\n\nDOCTEST_INTERFACE bool operator==(const String& lhs, const String& rhs);\nDOCTEST_INTERFACE bool operator!=(const String& lhs, const String& rhs);\nDOCTEST_INTERFACE bool operator<(const String& lhs, const String& rhs);\nDOCTEST_INTERFACE bool operator>(const String& lhs, const String& rhs);\nDOCTEST_INTERFACE bool operator<=(const String& lhs, const String& rhs);\nDOCTEST_INTERFACE bool operator>=(const String& lhs, const String& rhs);\n\nDOCTEST_INTERFACE std::ostream& operator<<(std::ostream& s, const String& in);\n\nnamespace Color {\n    enum Enum\n    {\n        None = 0,\n        White,\n        Red,\n        Green,\n        Blue,\n        Cyan,\n        Yellow,\n        Grey,\n\n        Bright = 0x10,\n\n        BrightRed   = Bright | Red,\n        BrightGreen = Bright | Green,\n        LightGrey   = Bright | Grey,\n        BrightWhite = Bright | White\n    };\n\n    DOCTEST_INTERFACE std::ostream& operator<<(std::ostream& s, Color::Enum code);\n} // namespace Color\n\nnamespace assertType {\n    enum Enum\n    {\n        // macro traits\n\n        is_warn    = 1,\n        is_check   = 2 * is_warn,\n        is_require = 2 * is_check,\n\n        is_normal      = 2 * is_require,\n        is_throws      = 2 * is_normal,\n        is_throws_as   = 2 * is_throws,\n        is_throws_with = 2 * is_throws_as,\n        is_nothrow     = 2 * is_throws_with,\n\n        is_false = 2 * is_nothrow,\n        is_unary = 2 * is_false, // not checked anywhere - used just to distinguish the types\n\n        is_eq = 2 * is_unary,\n        is_ne = 2 * is_eq,\n\n        is_lt = 2 * is_ne,\n        is_gt = 2 * is_lt,\n\n        is_ge = 2 * is_gt,\n        is_le = 2 * is_ge,\n\n        // macro types\n\n        DT_WARN    = is_normal | is_warn,\n        DT_CHECK   = is_normal | is_check,\n        DT_REQUIRE = is_normal | is_require,\n\n        DT_WARN_FALSE    = is_normal | is_false | is_warn,\n        DT_CHECK_FALSE   = is_normal | is_false | is_check,\n        DT_REQUIRE_FALSE = is_normal | is_false | is_require,\n\n        DT_WARN_THROWS    = is_throws | is_warn,\n        DT_CHECK_THROWS   = is_throws | is_check,\n        DT_REQUIRE_THROWS = is_throws | is_require,\n\n        DT_WARN_THROWS_AS    = is_throws_as | is_warn,\n        DT_CHECK_THROWS_AS   = is_throws_as | is_check,\n        DT_REQUIRE_THROWS_AS = is_throws_as | is_require,\n\n        DT_WARN_THROWS_WITH    = is_throws_with | is_warn,\n        DT_CHECK_THROWS_WITH   = is_throws_with | is_check,\n        DT_REQUIRE_THROWS_WITH = is_throws_with | is_require,\n        \n        DT_WARN_THROWS_WITH_AS    = is_throws_with | is_throws_as | is_warn,\n        DT_CHECK_THROWS_WITH_AS   = is_throws_with | is_throws_as | is_check,\n        DT_REQUIRE_THROWS_WITH_AS = is_throws_with | is_throws_as | is_require,\n\n        DT_WARN_NOTHROW    = is_nothrow | is_warn,\n        DT_CHECK_NOTHROW   = is_nothrow | is_check,\n        DT_REQUIRE_NOTHROW = is_nothrow | is_require,\n\n        DT_WARN_EQ    = is_normal | is_eq | is_warn,\n        DT_CHECK_EQ   = is_normal | is_eq | is_check,\n        DT_REQUIRE_EQ = is_normal | is_eq | is_require,\n\n        DT_WARN_NE    = is_normal | is_ne | is_warn,\n        DT_CHECK_NE   = is_normal | is_ne | is_check,\n        DT_REQUIRE_NE = is_normal | is_ne | is_require,\n\n        DT_WARN_GT    = is_normal | is_gt | is_warn,\n        DT_CHECK_GT   = is_normal | is_gt | is_check,\n        DT_REQUIRE_GT = is_normal | is_gt | is_require,\n\n        DT_WARN_LT    = is_normal | is_lt | is_warn,\n        DT_CHECK_LT   = is_normal | is_lt | is_check,\n        DT_REQUIRE_LT = is_normal | is_lt | is_require,\n\n        DT_WARN_GE    = is_normal | is_ge | is_warn,\n        DT_CHECK_GE   = is_normal | is_ge | is_check,\n        DT_REQUIRE_GE = is_normal | is_ge | is_require,\n\n        DT_WARN_LE    = is_normal | is_le | is_warn,\n        DT_CHECK_LE   = is_normal | is_le | is_check,\n        DT_REQUIRE_LE = is_normal | is_le | is_require,\n\n        DT_WARN_UNARY    = is_normal | is_unary | is_warn,\n        DT_CHECK_UNARY   = is_normal | is_unary | is_check,\n        DT_REQUIRE_UNARY = is_normal | is_unary | is_require,\n\n        DT_WARN_UNARY_FALSE    = is_normal | is_false | is_unary | is_warn,\n        DT_CHECK_UNARY_FALSE   = is_normal | is_false | is_unary | is_check,\n        DT_REQUIRE_UNARY_FALSE = is_normal | is_false | is_unary | is_require,\n    };\n} // namespace assertType\n\nDOCTEST_INTERFACE const char* assertString(assertType::Enum at);\nDOCTEST_INTERFACE const char* failureString(assertType::Enum at);\nDOCTEST_INTERFACE const char* skipPathFromFilename(const char* file);\n\nstruct DOCTEST_INTERFACE TestCaseData\n{\n    String      m_file;       // the file in which the test was registered (using String - see #350)\n    unsigned    m_line;       // the line where the test was registered\n    const char* m_name;       // name of the test case\n    const char* m_test_suite; // the test suite in which the test was added\n    const char* m_description;\n    bool        m_skip;\n    bool        m_no_breaks;\n    bool        m_no_output;\n    bool        m_may_fail;\n    bool        m_should_fail;\n    int         m_expected_failures;\n    double      m_timeout;\n};\n\nstruct DOCTEST_INTERFACE AssertData\n{\n    // common - for all asserts\n    const TestCaseData* m_test_case;\n    assertType::Enum    m_at;\n    const char*         m_file;\n    int                 m_line;\n    const char*         m_expr;\n    bool                m_failed;\n\n    // exception-related - for all asserts\n    bool   m_threw;\n    String m_exception;\n\n    // for normal asserts\n    String m_decomp;\n\n    // for specific exception-related asserts\n    bool        m_threw_as;\n    const char* m_exception_type;\n    const char* m_exception_string;\n};\n\nstruct DOCTEST_INTERFACE MessageData\n{\n    String           m_string;\n    const char*      m_file;\n    int              m_line;\n    assertType::Enum m_severity;\n};\n\nstruct DOCTEST_INTERFACE SubcaseSignature\n{\n    String      m_name;\n    const char* m_file;\n    int         m_line;\n\n    bool operator<(const SubcaseSignature& other) const;\n};\n\nstruct DOCTEST_INTERFACE IContextScope\n{\n    IContextScope();\n    virtual ~IContextScope();\n    virtual void stringify(std::ostream*) const = 0;\n};\n\nnamespace detail {\n    struct DOCTEST_INTERFACE TestCase;\n} // namespace detail\n\nstruct ContextOptions //!OCLINT too many fields\n{\n    std::ostream* cout;        // stdout stream - std::cout by default\n    std::ostream* cerr;        // stderr stream - std::cerr by default\n    String        binary_name; // the test binary name\n\n    const detail::TestCase* currentTest = nullptr;\n\n    // == parameters from the command line\n    String   out;       // output filename\n    String   order_by;  // how tests should be ordered\n    unsigned rand_seed; // the seed for rand ordering\n\n    unsigned first; // the first (matching) test to be executed\n    unsigned last;  // the last (matching) test to be executed\n\n    int abort_after;           // stop tests after this many failed assertions\n    int subcase_filter_levels; // apply the subcase filters for the first N levels\n\n    bool success;              // include successful assertions in output\n    bool case_sensitive;       // if filtering should be case sensitive\n    bool exit;                 // if the program should be exited after the tests are ran/whatever\n    bool duration;             // print the time duration of each test case\n    bool no_throw;             // to skip exceptions-related assertion macros\n    bool no_exitcode;          // if the framework should return 0 as the exitcode\n    bool no_run;               // to not run the tests at all (can be done with an \"*\" exclude)\n    bool no_version;           // to not print the version of the framework\n    bool no_colors;            // if output to the console should be colorized\n    bool force_colors;         // forces the use of colors even when a tty cannot be detected\n    bool no_breaks;            // to not break into the debugger\n    bool no_skip;              // don't skip test cases which are marked to be skipped\n    bool gnu_file_line;        // if line numbers should be surrounded with :x: and not (x):\n    bool no_path_in_filenames; // if the path to files should be removed from the output\n    bool no_line_numbers;      // if source code line numbers should be omitted from the output\n    bool no_debug_output;      // no output in the debug console when a debugger is attached\n    bool no_skipped_summary;   // don't print \"skipped\" in the summary !!! UNDOCUMENTED !!!\n    bool no_time_in_output;    // omit any time/timestamps from output !!! UNDOCUMENTED !!!\n\n    bool help;             // to print the help\n    bool version;          // to print the version\n    bool count;            // if only the count of matching tests is to be retrieved\n    bool list_test_cases;  // to list all tests matching the filters\n    bool list_test_suites; // to list all suites matching the filters\n    bool list_reporters;   // lists all registered reporters\n};\n\nnamespace detail {\n    template <bool CONDITION, typename TYPE = void>\n    struct enable_if\n    {};\n\n    template <typename TYPE>\n    struct enable_if<true, TYPE>\n    { typedef TYPE type; };\n\n    // clang-format off\n    template<class T> struct remove_reference      { typedef T type; };\n    template<class T> struct remove_reference<T&>  { typedef T type; };\n    template<class T> struct remove_reference<T&&> { typedef T type; };\n\n    template<class T> struct remove_const          { typedef T type; };\n    template<class T> struct remove_const<const T> { typedef T type; };\n#ifdef DOCTEST_CONFIG_INCLUDE_TYPE_TRAITS\n    template<class T> struct is_enum : public std::is_enum<T> {};\n    template<class T> struct underlying_type : public std::underlying_type<T> {};\n#else\n    // Use compiler intrinsics\n    template<class T> struct is_enum { constexpr static bool value = __is_enum(T); };\n    template<class T> struct underlying_type { typedef __underlying_type(T) type; };\n#endif\n    // clang-format on\n\n    template <typename T>\n    struct deferred_false\n    // cppcheck-suppress unusedStructMember\n    { static const bool value = false; };\n\n    namespace has_insertion_operator_impl {\n        std::ostream &os();\n        template<class T>\n        DOCTEST_REF_WRAP(T) val();\n\n        template<class, class = void>\n        struct check {\n            static constexpr bool value = false;\n        };\n\n        template<class T>\n        struct check<T, decltype(os() << val<T>(), void())> {\n            static constexpr bool value = true;\n        };\n    } // namespace has_insertion_operator_impl\n\n    template<class T>\n    using has_insertion_operator = has_insertion_operator_impl::check<const T>;\n\n    DOCTEST_INTERFACE void my_memcpy(void* dest, const void* src, unsigned num);\n\n    DOCTEST_INTERFACE std::ostream* getTlsOss(); // returns a thread-local ostringstream\n    DOCTEST_INTERFACE String getTlsOssResult();\n\n    template <bool C>\n    struct StringMakerBase\n    {\n        template <typename T>\n        static String convert(const DOCTEST_REF_WRAP(T)) {\n            return \"{?}\";\n        }\n    };\n\n    template <>\n    struct StringMakerBase<true>\n    {\n        template <typename T>\n        static String convert(const DOCTEST_REF_WRAP(T) in) {\n            *getTlsOss() << in;\n            return getTlsOssResult();\n        }\n    };\n\n    DOCTEST_INTERFACE String rawMemoryToString(const void* object, unsigned size);\n\n    template <typename T>\n    String rawMemoryToString(const DOCTEST_REF_WRAP(T) object) {\n        return rawMemoryToString(&object, sizeof(object));\n    }\n\n    template <typename T>\n    const char* type_to_string() {\n        return \"<>\";\n    }\n} // namespace detail\n\ntemplate <typename T>\nstruct StringMaker : public detail::StringMakerBase<detail::has_insertion_operator<T>::value>\n{};\n\ntemplate <typename T>\nstruct StringMaker<T*>\n{\n    template <typename U>\n    static String convert(U* p) {\n        if(p)\n            return detail::rawMemoryToString(p);\n        return \"NULL\";\n    }\n};\n\ntemplate <typename R, typename C>\nstruct StringMaker<R C::*>\n{\n    static String convert(R C::*p) {\n        if(p)\n            return detail::rawMemoryToString(p);\n        return \"NULL\";\n    }\n};\n\ntemplate <typename T, typename detail::enable_if<!detail::is_enum<T>::value, bool>::type = true>\nString toString(const DOCTEST_REF_WRAP(T) value) {\n    return StringMaker<T>::convert(value);\n}\n\n#ifdef DOCTEST_CONFIG_TREAT_CHAR_STAR_AS_STRING\nDOCTEST_INTERFACE String toString(char* in);\nDOCTEST_INTERFACE String toString(const char* in);\n#endif // DOCTEST_CONFIG_TREAT_CHAR_STAR_AS_STRING\nDOCTEST_INTERFACE String toString(bool in);\nDOCTEST_INTERFACE String toString(float in);\nDOCTEST_INTERFACE String toString(double in);\nDOCTEST_INTERFACE String toString(double long in);\n\nDOCTEST_INTERFACE String toString(char in);\nDOCTEST_INTERFACE String toString(char signed in);\nDOCTEST_INTERFACE String toString(char unsigned in);\nDOCTEST_INTERFACE String toString(int short in);\nDOCTEST_INTERFACE String toString(int short unsigned in);\nDOCTEST_INTERFACE String toString(int in);\nDOCTEST_INTERFACE String toString(int unsigned in);\nDOCTEST_INTERFACE String toString(int long in);\nDOCTEST_INTERFACE String toString(int long unsigned in);\nDOCTEST_INTERFACE String toString(int long long in);\nDOCTEST_INTERFACE String toString(int long long unsigned in);\nDOCTEST_INTERFACE String toString(std::nullptr_t in);\n\ntemplate <typename T, typename detail::enable_if<detail::is_enum<T>::value, bool>::type = true>\nString toString(const DOCTEST_REF_WRAP(T) value) {\n    typedef typename detail::underlying_type<T>::type UT;\n    return toString(static_cast<UT>(value));\n}\n\n#if DOCTEST_MSVC >= DOCTEST_COMPILER(19, 20, 0)\n// see this issue on why this is needed: https://github.com/onqtam/doctest/issues/183\nDOCTEST_INTERFACE String toString(const std::string& in);\n#endif // VS 2019\n\nclass DOCTEST_INTERFACE Approx\n{\npublic:\n    explicit Approx(double value);\n\n    Approx operator()(double value) const;\n\n#ifdef DOCTEST_CONFIG_INCLUDE_TYPE_TRAITS\n    template <typename T>\n    explicit Approx(const T& value,\n                    typename detail::enable_if<std::is_constructible<double, T>::value>::type* =\n                            static_cast<T*>(nullptr)) {\n        *this = Approx(static_cast<double>(value));\n    }\n#endif // DOCTEST_CONFIG_INCLUDE_TYPE_TRAITS\n\n    Approx& epsilon(double newEpsilon);\n\n#ifdef DOCTEST_CONFIG_INCLUDE_TYPE_TRAITS\n    template <typename T>\n    typename detail::enable_if<std::is_constructible<double, T>::value, Approx&>::type epsilon(\n            const T& newEpsilon) {\n        m_epsilon = static_cast<double>(newEpsilon);\n        return *this;\n    }\n#endif //  DOCTEST_CONFIG_INCLUDE_TYPE_TRAITS\n\n    Approx& scale(double newScale);\n\n#ifdef DOCTEST_CONFIG_INCLUDE_TYPE_TRAITS\n    template <typename T>\n    typename detail::enable_if<std::is_constructible<double, T>::value, Approx&>::type scale(\n            const T& newScale) {\n        m_scale = static_cast<double>(newScale);\n        return *this;\n    }\n#endif // DOCTEST_CONFIG_INCLUDE_TYPE_TRAITS\n\n    // clang-format off\n    DOCTEST_INTERFACE friend bool operator==(double lhs, const Approx & rhs);\n    DOCTEST_INTERFACE friend bool operator==(const Approx & lhs, double rhs);\n    DOCTEST_INTERFACE friend bool operator!=(double lhs, const Approx & rhs);\n    DOCTEST_INTERFACE friend bool operator!=(const Approx & lhs, double rhs);\n    DOCTEST_INTERFACE friend bool operator<=(double lhs, const Approx & rhs);\n    DOCTEST_INTERFACE friend bool operator<=(const Approx & lhs, double rhs);\n    DOCTEST_INTERFACE friend bool operator>=(double lhs, const Approx & rhs);\n    DOCTEST_INTERFACE friend bool operator>=(const Approx & lhs, double rhs);\n    DOCTEST_INTERFACE friend bool operator< (double lhs, const Approx & rhs);\n    DOCTEST_INTERFACE friend bool operator< (const Approx & lhs, double rhs);\n    DOCTEST_INTERFACE friend bool operator> (double lhs, const Approx & rhs);\n    DOCTEST_INTERFACE friend bool operator> (const Approx & lhs, double rhs);\n\n    DOCTEST_INTERFACE friend String toString(const Approx& in);\n\n#ifdef DOCTEST_CONFIG_INCLUDE_TYPE_TRAITS\n#define DOCTEST_APPROX_PREFIX \\\n    template <typename T> friend typename detail::enable_if<std::is_constructible<double, T>::value, bool>::type\n\n    DOCTEST_APPROX_PREFIX operator==(const T& lhs, const Approx& rhs) { return operator==(double(lhs), rhs); }\n    DOCTEST_APPROX_PREFIX operator==(const Approx& lhs, const T& rhs) { return operator==(rhs, lhs); }\n    DOCTEST_APPROX_PREFIX operator!=(const T& lhs, const Approx& rhs) { return !operator==(lhs, rhs); }\n    DOCTEST_APPROX_PREFIX operator!=(const Approx& lhs, const T& rhs) { return !operator==(rhs, lhs); }\n    DOCTEST_APPROX_PREFIX operator<=(const T& lhs, const Approx& rhs) { return double(lhs) < rhs.m_value || lhs == rhs; }\n    DOCTEST_APPROX_PREFIX operator<=(const Approx& lhs, const T& rhs) { return lhs.m_value < double(rhs) || lhs == rhs; }\n    DOCTEST_APPROX_PREFIX operator>=(const T& lhs, const Approx& rhs) { return double(lhs) > rhs.m_value || lhs == rhs; }\n    DOCTEST_APPROX_PREFIX operator>=(const Approx& lhs, const T& rhs) { return lhs.m_value > double(rhs) || lhs == rhs; }\n    DOCTEST_APPROX_PREFIX operator< (const T& lhs, const Approx& rhs) { return double(lhs) < rhs.m_value && lhs != rhs; }\n    DOCTEST_APPROX_PREFIX operator< (const Approx& lhs, const T& rhs) { return lhs.m_value < double(rhs) && lhs != rhs; }\n    DOCTEST_APPROX_PREFIX operator> (const T& lhs, const Approx& rhs) { return double(lhs) > rhs.m_value && lhs != rhs; }\n    DOCTEST_APPROX_PREFIX operator> (const Approx& lhs, const T& rhs) { return lhs.m_value > double(rhs) && lhs != rhs; }\n#undef DOCTEST_APPROX_PREFIX\n#endif // DOCTEST_CONFIG_INCLUDE_TYPE_TRAITS\n\n    // clang-format on\n\nprivate:\n    double m_epsilon;\n    double m_scale;\n    double m_value;\n};\n\nDOCTEST_INTERFACE String toString(const Approx& in);\n\nDOCTEST_INTERFACE const ContextOptions* getContextOptions();\n\n#if !defined(DOCTEST_CONFIG_DISABLE)\n\nnamespace detail {\n    // clang-format off\n#ifdef DOCTEST_CONFIG_TREAT_CHAR_STAR_AS_STRING\n    template<class T>               struct decay_array       { typedef T type; };\n    template<class T, unsigned N>   struct decay_array<T[N]> { typedef T* type; };\n    template<class T>               struct decay_array<T[]>  { typedef T* type; };\n\n    template<class T>   struct not_char_pointer              { enum { value = 1 }; };\n    template<>          struct not_char_pointer<char*>       { enum { value = 0 }; };\n    template<>          struct not_char_pointer<const char*> { enum { value = 0 }; };\n\n    template<class T> struct can_use_op : public not_char_pointer<typename decay_array<T>::type> {};\n#endif // DOCTEST_CONFIG_TREAT_CHAR_STAR_AS_STRING\n    // clang-format on\n\n    struct DOCTEST_INTERFACE TestFailureException\n    {\n    };\n\n    DOCTEST_INTERFACE bool checkIfShouldThrow(assertType::Enum at);\n\n#ifndef DOCTEST_CONFIG_NO_EXCEPTIONS\n    DOCTEST_NORETURN\n#endif // DOCTEST_CONFIG_NO_EXCEPTIONS\n    DOCTEST_INTERFACE void throwException();\n\n    struct DOCTEST_INTERFACE Subcase\n    {\n        SubcaseSignature m_signature;\n        bool             m_entered = false;\n\n        Subcase(const String& name, const char* file, int line);\n        ~Subcase();\n\n        operator bool() const;\n    };\n\n    template <typename L, typename R>\n    String stringifyBinaryExpr(const DOCTEST_REF_WRAP(L) lhs, const char* op,\n                               const DOCTEST_REF_WRAP(R) rhs) {\n        // NOLINTNEXTLINE(clang-analyzer-cplusplus.NewDeleteLeaks)\n        return toString(lhs) + op + toString(rhs);\n    }\n\n#define DOCTEST_DO_BINARY_EXPRESSION_COMPARISON(op, op_str, op_macro)                              \\\n    template <typename R>                                                                          \\\n    DOCTEST_NOINLINE Result operator op(const DOCTEST_REF_WRAP(R) rhs) {                           \\\n        bool res = op_macro(lhs, rhs);                                                             \\\n        if(m_at & assertType::is_false)                                                            \\\n            res = !res;                                                                            \\\n        if(!res || doctest::getContextOptions()->success)                                          \\\n            return Result(res, stringifyBinaryExpr(lhs, op_str, rhs));                             \\\n        return Result(res);                                                                        \\\n    }\n\n    // more checks could be added - like in Catch:\n    // https://github.com/catchorg/Catch2/pull/1480/files\n    // https://github.com/catchorg/Catch2/pull/1481/files\n#define DOCTEST_FORBIT_EXPRESSION(rt, op)                                                          \\\n    template <typename R>                                                                          \\\n    rt& operator op(const R&) {                                                                    \\\n        static_assert(deferred_false<R>::value,                                                    \\\n                      \"Expression Too Complex Please Rewrite As Binary Comparison!\");              \\\n        return *this;                                                                              \\\n    }\n\n    struct DOCTEST_INTERFACE Result\n    {\n        bool   m_passed;\n        String m_decomp;\n\n        Result(bool passed, const String& decomposition = String());\n\n        // forbidding some expressions based on this table: https://en.cppreference.com/w/cpp/language/operator_precedence\n        DOCTEST_FORBIT_EXPRESSION(Result, &)\n        DOCTEST_FORBIT_EXPRESSION(Result, ^)\n        DOCTEST_FORBIT_EXPRESSION(Result, |)\n        DOCTEST_FORBIT_EXPRESSION(Result, &&)\n        DOCTEST_FORBIT_EXPRESSION(Result, ||)\n        DOCTEST_FORBIT_EXPRESSION(Result, ==)\n        DOCTEST_FORBIT_EXPRESSION(Result, !=)\n        DOCTEST_FORBIT_EXPRESSION(Result, <)\n        DOCTEST_FORBIT_EXPRESSION(Result, >)\n        DOCTEST_FORBIT_EXPRESSION(Result, <=)\n        DOCTEST_FORBIT_EXPRESSION(Result, >=)\n        DOCTEST_FORBIT_EXPRESSION(Result, =)\n        DOCTEST_FORBIT_EXPRESSION(Result, +=)\n        DOCTEST_FORBIT_EXPRESSION(Result, -=)\n        DOCTEST_FORBIT_EXPRESSION(Result, *=)\n        DOCTEST_FORBIT_EXPRESSION(Result, /=)\n        DOCTEST_FORBIT_EXPRESSION(Result, %=)\n        DOCTEST_FORBIT_EXPRESSION(Result, <<=)\n        DOCTEST_FORBIT_EXPRESSION(Result, >>=)\n        DOCTEST_FORBIT_EXPRESSION(Result, &=)\n        DOCTEST_FORBIT_EXPRESSION(Result, ^=)\n        DOCTEST_FORBIT_EXPRESSION(Result, |=)\n    };\n\n#ifndef DOCTEST_CONFIG_NO_COMPARISON_WARNING_SUPPRESSION\n\n    DOCTEST_CLANG_SUPPRESS_WARNING_PUSH\n    DOCTEST_CLANG_SUPPRESS_WARNING(\"-Wsign-conversion\")\n    DOCTEST_CLANG_SUPPRESS_WARNING(\"-Wsign-compare\")\n    //DOCTEST_CLANG_SUPPRESS_WARNING(\"-Wdouble-promotion\")\n    //DOCTEST_CLANG_SUPPRESS_WARNING(\"-Wconversion\")\n    //DOCTEST_CLANG_SUPPRESS_WARNING(\"-Wfloat-equal\")\n\n    DOCTEST_GCC_SUPPRESS_WARNING_PUSH\n    DOCTEST_GCC_SUPPRESS_WARNING(\"-Wsign-conversion\")\n    DOCTEST_GCC_SUPPRESS_WARNING(\"-Wsign-compare\")\n    //DOCTEST_GCC_SUPPRESS_WARNING(\"-Wdouble-promotion\")\n    //DOCTEST_GCC_SUPPRESS_WARNING(\"-Wconversion\")\n    //DOCTEST_GCC_SUPPRESS_WARNING(\"-Wfloat-equal\")\n\n    DOCTEST_MSVC_SUPPRESS_WARNING_PUSH\n    // https://stackoverflow.com/questions/39479163 what's the difference between 4018 and 4389\n    DOCTEST_MSVC_SUPPRESS_WARNING(4388) // signed/unsigned mismatch\n    DOCTEST_MSVC_SUPPRESS_WARNING(4389) // 'operator' : signed/unsigned mismatch\n    DOCTEST_MSVC_SUPPRESS_WARNING(4018) // 'expression' : signed/unsigned mismatch\n    //DOCTEST_MSVC_SUPPRESS_WARNING(4805) // 'operation' : unsafe mix of type 'type' and type 'type' in operation\n\n#endif // DOCTEST_CONFIG_NO_COMPARISON_WARNING_SUPPRESSION\n\n    // clang-format off\n#ifndef DOCTEST_CONFIG_TREAT_CHAR_STAR_AS_STRING\n#define DOCTEST_COMPARISON_RETURN_TYPE bool\n#else // DOCTEST_CONFIG_TREAT_CHAR_STAR_AS_STRING\n#define DOCTEST_COMPARISON_RETURN_TYPE typename enable_if<can_use_op<L>::value || can_use_op<R>::value, bool>::type\n    // NOLINTNEXTLINE(clang-analyzer-cplusplus.NewDeleteLeaks)\n    inline bool eq(const char* lhs, const char* rhs) { return String(lhs) == String(rhs); }\n    inline bool ne(const char* lhs, const char* rhs) { return String(lhs) != String(rhs); }\n    inline bool lt(const char* lhs, const char* rhs) { return String(lhs) <  String(rhs); }\n    inline bool gt(const char* lhs, const char* rhs) { return String(lhs) >  String(rhs); }\n    inline bool le(const char* lhs, const char* rhs) { return String(lhs) <= String(rhs); }\n    inline bool ge(const char* lhs, const char* rhs) { return String(lhs) >= String(rhs); }\n#endif // DOCTEST_CONFIG_TREAT_CHAR_STAR_AS_STRING\n    // clang-format on\n\n#define DOCTEST_RELATIONAL_OP(name, op)                                                            \\\n    template <typename L, typename R>                                                              \\\n    DOCTEST_COMPARISON_RETURN_TYPE name(const DOCTEST_REF_WRAP(L) lhs,                             \\\n                                        const DOCTEST_REF_WRAP(R) rhs) {                           \\\n        return lhs op rhs;                                                                         \\\n    }\n\n    DOCTEST_RELATIONAL_OP(eq, ==)\n    DOCTEST_RELATIONAL_OP(ne, !=)\n    DOCTEST_RELATIONAL_OP(lt, <)\n    DOCTEST_RELATIONAL_OP(gt, >)\n    DOCTEST_RELATIONAL_OP(le, <=)\n    DOCTEST_RELATIONAL_OP(ge, >=)\n\n#ifndef DOCTEST_CONFIG_TREAT_CHAR_STAR_AS_STRING\n#define DOCTEST_CMP_EQ(l, r) l == r\n#define DOCTEST_CMP_NE(l, r) l != r\n#define DOCTEST_CMP_GT(l, r) l > r\n#define DOCTEST_CMP_LT(l, r) l < r\n#define DOCTEST_CMP_GE(l, r) l >= r\n#define DOCTEST_CMP_LE(l, r) l <= r\n#else // DOCTEST_CONFIG_TREAT_CHAR_STAR_AS_STRING\n#define DOCTEST_CMP_EQ(l, r) eq(l, r)\n#define DOCTEST_CMP_NE(l, r) ne(l, r)\n#define DOCTEST_CMP_GT(l, r) gt(l, r)\n#define DOCTEST_CMP_LT(l, r) lt(l, r)\n#define DOCTEST_CMP_GE(l, r) ge(l, r)\n#define DOCTEST_CMP_LE(l, r) le(l, r)\n#endif // DOCTEST_CONFIG_TREAT_CHAR_STAR_AS_STRING\n\n    template <typename L>\n    // cppcheck-suppress copyCtorAndEqOperator\n    struct Expression_lhs\n    {\n        L                lhs;\n        assertType::Enum m_at;\n\n        explicit Expression_lhs(L in, assertType::Enum at)\n                : lhs(in)\n                , m_at(at) {}\n\n        DOCTEST_NOINLINE operator Result() {\n            bool res = !!lhs;\n            if(m_at & assertType::is_false) //!OCLINT bitwise operator in conditional\n                res = !res;\n\n            if(!res || getContextOptions()->success)\n                return Result(res, toString(lhs));\n            return Result(res);\n        }\n\n        // clang-format off\n        DOCTEST_DO_BINARY_EXPRESSION_COMPARISON(==, \" == \", DOCTEST_CMP_EQ) //!OCLINT bitwise operator in conditional\n        DOCTEST_DO_BINARY_EXPRESSION_COMPARISON(!=, \" != \", DOCTEST_CMP_NE) //!OCLINT bitwise operator in conditional\n        DOCTEST_DO_BINARY_EXPRESSION_COMPARISON(>,  \" >  \", DOCTEST_CMP_GT) //!OCLINT bitwise operator in conditional\n        DOCTEST_DO_BINARY_EXPRESSION_COMPARISON(<,  \" <  \", DOCTEST_CMP_LT) //!OCLINT bitwise operator in conditional\n        DOCTEST_DO_BINARY_EXPRESSION_COMPARISON(>=, \" >= \", DOCTEST_CMP_GE) //!OCLINT bitwise operator in conditional\n        DOCTEST_DO_BINARY_EXPRESSION_COMPARISON(<=, \" <= \", DOCTEST_CMP_LE) //!OCLINT bitwise operator in conditional\n        // clang-format on\n\n        // forbidding some expressions based on this table: https://en.cppreference.com/w/cpp/language/operator_precedence\n        DOCTEST_FORBIT_EXPRESSION(Expression_lhs, &)\n        DOCTEST_FORBIT_EXPRESSION(Expression_lhs, ^)\n        DOCTEST_FORBIT_EXPRESSION(Expression_lhs, |)\n        DOCTEST_FORBIT_EXPRESSION(Expression_lhs, &&)\n        DOCTEST_FORBIT_EXPRESSION(Expression_lhs, ||)\n        DOCTEST_FORBIT_EXPRESSION(Expression_lhs, =)\n        DOCTEST_FORBIT_EXPRESSION(Expression_lhs, +=)\n        DOCTEST_FORBIT_EXPRESSION(Expression_lhs, -=)\n        DOCTEST_FORBIT_EXPRESSION(Expression_lhs, *=)\n        DOCTEST_FORBIT_EXPRESSION(Expression_lhs, /=)\n        DOCTEST_FORBIT_EXPRESSION(Expression_lhs, %=)\n        DOCTEST_FORBIT_EXPRESSION(Expression_lhs, <<=)\n        DOCTEST_FORBIT_EXPRESSION(Expression_lhs, >>=)\n        DOCTEST_FORBIT_EXPRESSION(Expression_lhs, &=)\n        DOCTEST_FORBIT_EXPRESSION(Expression_lhs, ^=)\n        DOCTEST_FORBIT_EXPRESSION(Expression_lhs, |=)\n        // these 2 are unfortunate because they should be allowed - they have higher precedence over the comparisons, but the\n        // ExpressionDecomposer class uses the left shift operator to capture the left operand of the binary expression...\n        DOCTEST_FORBIT_EXPRESSION(Expression_lhs, <<)\n        DOCTEST_FORBIT_EXPRESSION(Expression_lhs, >>)\n    };\n\n#ifndef DOCTEST_CONFIG_NO_COMPARISON_WARNING_SUPPRESSION\n\n    DOCTEST_CLANG_SUPPRESS_WARNING_POP\n    DOCTEST_MSVC_SUPPRESS_WARNING_POP\n    DOCTEST_GCC_SUPPRESS_WARNING_POP\n\n#endif // DOCTEST_CONFIG_NO_COMPARISON_WARNING_SUPPRESSION\n\n    struct DOCTEST_INTERFACE ExpressionDecomposer\n    {\n        assertType::Enum m_at;\n\n        ExpressionDecomposer(assertType::Enum at);\n\n        // The right operator for capturing expressions is \"<=\" instead of \"<<\" (based on the operator precedence table)\n        // but then there will be warnings from GCC about \"-Wparentheses\" and since \"_Pragma()\" is problematic this will stay for now...\n        // https://github.com/catchorg/Catch2/issues/870\n        // https://github.com/catchorg/Catch2/issues/565\n        template <typename L>\n        Expression_lhs<const DOCTEST_REF_WRAP(L)> operator<<(const DOCTEST_REF_WRAP(L) operand) {\n            return Expression_lhs<const DOCTEST_REF_WRAP(L)>(operand, m_at);\n        }\n    };\n\n    struct DOCTEST_INTERFACE TestSuite\n    {\n        const char* m_test_suite;\n        const char* m_description;\n        bool        m_skip;\n        bool        m_no_breaks;\n        bool        m_no_output;\n        bool        m_may_fail;\n        bool        m_should_fail;\n        int         m_expected_failures;\n        double      m_timeout;\n\n        TestSuite& operator*(const char* in);\n\n        template <typename T>\n        TestSuite& operator*(const T& in) {\n            in.fill(*this);\n            return *this;\n        }\n    };\n\n    typedef void (*funcType)();\n\n    struct DOCTEST_INTERFACE TestCase : public TestCaseData\n    {\n        funcType m_test; // a function pointer to the test case\n\n        const char* m_type; // for templated test cases - gets appended to the real name\n        int m_template_id; // an ID used to distinguish between the different versions of a templated test case\n        String m_full_name; // contains the name (only for templated test cases!) + the template type\n\n        TestCase(funcType test, const char* file, unsigned line, const TestSuite& test_suite,\n                 const char* type = \"\", int template_id = -1);\n\n        TestCase(const TestCase& other);\n\n        DOCTEST_MSVC_SUPPRESS_WARNING_WITH_PUSH(26434) // hides a non-virtual function\n        TestCase& operator=(const TestCase& other);\n        DOCTEST_MSVC_SUPPRESS_WARNING_POP\n\n        TestCase& operator*(const char* in);\n\n        template <typename T>\n        TestCase& operator*(const T& in) {\n            in.fill(*this);\n            return *this;\n        }\n\n        bool operator<(const TestCase& other) const;\n    };\n\n    // forward declarations of functions used by the macros\n    DOCTEST_INTERFACE int  regTest(const TestCase& tc);\n    DOCTEST_INTERFACE int  setTestSuite(const TestSuite& ts);\n    DOCTEST_INTERFACE bool isDebuggerActive();\n\n    template<typename T>\n    int instantiationHelper(const T&) { return 0; }\n\n    namespace binaryAssertComparison {\n        enum Enum\n        {\n            eq = 0,\n            ne,\n            gt,\n            lt,\n            ge,\n            le\n        };\n    } // namespace binaryAssertComparison\n\n    // clang-format off\n    template <int, class L, class R> struct RelationalComparator     { bool operator()(const DOCTEST_REF_WRAP(L),     const DOCTEST_REF_WRAP(R)    ) const { return false;        } };\n\n#define DOCTEST_BINARY_RELATIONAL_OP(n, op) \\\n    template <class L, class R> struct RelationalComparator<n, L, R> { bool operator()(const DOCTEST_REF_WRAP(L) lhs, const DOCTEST_REF_WRAP(R) rhs) const { return op(lhs, rhs); } };\n    // clang-format on\n\n    DOCTEST_BINARY_RELATIONAL_OP(0, doctest::detail::eq)\n    DOCTEST_BINARY_RELATIONAL_OP(1, doctest::detail::ne)\n    DOCTEST_BINARY_RELATIONAL_OP(2, doctest::detail::gt)\n    DOCTEST_BINARY_RELATIONAL_OP(3, doctest::detail::lt)\n    DOCTEST_BINARY_RELATIONAL_OP(4, doctest::detail::ge)\n    DOCTEST_BINARY_RELATIONAL_OP(5, doctest::detail::le)\n\n    struct DOCTEST_INTERFACE ResultBuilder : public AssertData\n    {\n        ResultBuilder(assertType::Enum at, const char* file, int line, const char* expr,\n                      const char* exception_type = \"\", const char* exception_string = \"\");\n\n        void setResult(const Result& res);\n\n        template <int comparison, typename L, typename R>\n        DOCTEST_NOINLINE void binary_assert(const DOCTEST_REF_WRAP(L) lhs,\n                                            const DOCTEST_REF_WRAP(R) rhs) {\n            m_failed = !RelationalComparator<comparison, L, R>()(lhs, rhs);\n            if(m_failed || getContextOptions()->success)\n                m_decomp = stringifyBinaryExpr(lhs, \", \", rhs);\n        }\n\n        template <typename L>\n        DOCTEST_NOINLINE void unary_assert(const DOCTEST_REF_WRAP(L) val) {\n            m_failed = !val;\n\n            if(m_at & assertType::is_false) //!OCLINT bitwise operator in conditional\n                m_failed = !m_failed;\n\n            if(m_failed || getContextOptions()->success)\n                m_decomp = toString(val);\n        }\n\n        void translateException();\n\n        bool log();\n        void react() const;\n    };\n\n    namespace assertAction {\n        enum Enum\n        {\n            nothing     = 0,\n            dbgbreak    = 1,\n            shouldthrow = 2\n        };\n    } // namespace assertAction\n\n    DOCTEST_INTERFACE void failed_out_of_a_testing_context(const AssertData& ad);\n\n    DOCTEST_INTERFACE void decomp_assert(assertType::Enum at, const char* file, int line,\n                                         const char* expr, Result result);\n\n#define DOCTEST_ASSERT_OUT_OF_TESTS(decomp)                                                        \\\n    do {                                                                                           \\\n        if(!is_running_in_test) {                                                                  \\\n            if(failed) {                                                                           \\\n                ResultBuilder rb(at, file, line, expr);                                            \\\n                rb.m_failed = failed;                                                              \\\n                rb.m_decomp = decomp;                                                              \\\n                failed_out_of_a_testing_context(rb);                                               \\\n                if(isDebuggerActive() && !getContextOptions()->no_breaks)                          \\\n                    DOCTEST_BREAK_INTO_DEBUGGER();                                                 \\\n                if(checkIfShouldThrow(at))                                                         \\\n                    throwException();                                                              \\\n            }                                                                                      \\\n            return;                                                                                \\\n        }                                                                                          \\\n    } while(false)\n\n#define DOCTEST_ASSERT_IN_TESTS(decomp)                                                            \\\n    ResultBuilder rb(at, file, line, expr);                                                        \\\n    rb.m_failed = failed;                                                                          \\\n    if(rb.m_failed || getContextOptions()->success)                                                \\\n        rb.m_decomp = decomp;                                                                      \\\n    if(rb.log())                                                                                   \\\n        DOCTEST_BREAK_INTO_DEBUGGER();                                                             \\\n    if(rb.m_failed && checkIfShouldThrow(at))                                                      \\\n    throwException()\n\n    template <int comparison, typename L, typename R>\n    DOCTEST_NOINLINE void binary_assert(assertType::Enum at, const char* file, int line,\n                                        const char* expr, const DOCTEST_REF_WRAP(L) lhs,\n                                        const DOCTEST_REF_WRAP(R) rhs) {\n        bool failed = !RelationalComparator<comparison, L, R>()(lhs, rhs);\n\n        // ###################################################################################\n        // IF THE DEBUGGER BREAKS HERE - GO 1 LEVEL UP IN THE CALLSTACK FOR THE FAILING ASSERT\n        // THIS IS THE EFFECT OF HAVING 'DOCTEST_CONFIG_SUPER_FAST_ASSERTS' DEFINED\n        // ###################################################################################\n        DOCTEST_ASSERT_OUT_OF_TESTS(stringifyBinaryExpr(lhs, \", \", rhs));\n        DOCTEST_ASSERT_IN_TESTS(stringifyBinaryExpr(lhs, \", \", rhs));\n    }\n\n    template <typename L>\n    DOCTEST_NOINLINE void unary_assert(assertType::Enum at, const char* file, int line,\n                                       const char* expr, const DOCTEST_REF_WRAP(L) val) {\n        bool failed = !val;\n\n        if(at & assertType::is_false) //!OCLINT bitwise operator in conditional\n            failed = !failed;\n\n        // ###################################################################################\n        // IF THE DEBUGGER BREAKS HERE - GO 1 LEVEL UP IN THE CALLSTACK FOR THE FAILING ASSERT\n        // THIS IS THE EFFECT OF HAVING 'DOCTEST_CONFIG_SUPER_FAST_ASSERTS' DEFINED\n        // ###################################################################################\n        DOCTEST_ASSERT_OUT_OF_TESTS(toString(val));\n        DOCTEST_ASSERT_IN_TESTS(toString(val));\n    }\n\n    struct DOCTEST_INTERFACE IExceptionTranslator\n    {\n        IExceptionTranslator();\n        virtual ~IExceptionTranslator();\n        virtual bool translate(String&) const = 0;\n    };\n\n    template <typename T>\n    class ExceptionTranslator : public IExceptionTranslator //!OCLINT destructor of virtual class\n    {\n    public:\n        explicit ExceptionTranslator(String (*translateFunction)(T))\n                : m_translateFunction(translateFunction) {}\n\n        bool translate(String& res) const override {\n#ifndef DOCTEST_CONFIG_NO_EXCEPTIONS\n            try {\n                throw; // lgtm [cpp/rethrow-no-exception]\n                // cppcheck-suppress catchExceptionByValue\n            } catch(T ex) {                    // NOLINT\n                res = m_translateFunction(ex); //!OCLINT parameter reassignment\n                return true;\n            } catch(...) {}         //!OCLINT -  empty catch statement\n#endif                              // DOCTEST_CONFIG_NO_EXCEPTIONS\n            static_cast<void>(res); // to silence -Wunused-parameter\n            return false;\n        }\n\n    private:\n        String (*m_translateFunction)(T);\n    };\n\n    DOCTEST_INTERFACE void registerExceptionTranslatorImpl(const IExceptionTranslator* et);\n\n    template <bool C>\n    struct StringStreamBase\n    {\n        template <typename T>\n        static void convert(std::ostream* s, const T& in) {\n            *s << toString(in);\n        }\n\n        // always treat char* as a string in this context - no matter\n        // if DOCTEST_CONFIG_TREAT_CHAR_STAR_AS_STRING is defined\n        static void convert(std::ostream* s, const char* in) { *s << String(in); }\n    };\n\n    template <>\n    struct StringStreamBase<true>\n    {\n        template <typename T>\n        static void convert(std::ostream* s, const T& in) {\n            *s << in;\n        }\n    };\n\n    template <typename T>\n    struct StringStream : public StringStreamBase<has_insertion_operator<T>::value>\n    {};\n\n    template <typename T>\n    void toStream(std::ostream* s, const T& value) {\n        StringStream<T>::convert(s, value);\n    }\n\n#ifdef DOCTEST_CONFIG_TREAT_CHAR_STAR_AS_STRING\n    DOCTEST_INTERFACE void toStream(std::ostream* s, char* in);\n    DOCTEST_INTERFACE void toStream(std::ostream* s, const char* in);\n#endif // DOCTEST_CONFIG_TREAT_CHAR_STAR_AS_STRING\n    DOCTEST_INTERFACE void toStream(std::ostream* s, bool in);\n    DOCTEST_INTERFACE void toStream(std::ostream* s, float in);\n    DOCTEST_INTERFACE void toStream(std::ostream* s, double in);\n    DOCTEST_INTERFACE void toStream(std::ostream* s, double long in);\n\n    DOCTEST_INTERFACE void toStream(std::ostream* s, char in);\n    DOCTEST_INTERFACE void toStream(std::ostream* s, char signed in);\n    DOCTEST_INTERFACE void toStream(std::ostream* s, char unsigned in);\n    DOCTEST_INTERFACE void toStream(std::ostream* s, int short in);\n    DOCTEST_INTERFACE void toStream(std::ostream* s, int short unsigned in);\n    DOCTEST_INTERFACE void toStream(std::ostream* s, int in);\n    DOCTEST_INTERFACE void toStream(std::ostream* s, int unsigned in);\n    DOCTEST_INTERFACE void toStream(std::ostream* s, int long in);\n    DOCTEST_INTERFACE void toStream(std::ostream* s, int long unsigned in);\n    DOCTEST_INTERFACE void toStream(std::ostream* s, int long long in);\n    DOCTEST_INTERFACE void toStream(std::ostream* s, int long long unsigned in);\n\n    // ContextScope base class used to allow implementing methods of ContextScope \n    // that don't depend on the template parameter in doctest.cpp.\n    class DOCTEST_INTERFACE ContextScopeBase : public IContextScope {\n    protected:\n        ContextScopeBase();\n\n        void destroy();\n    };\n\n    template <typename L> class ContextScope : public ContextScopeBase\n    {\n        const L &lambda_;\n\n    public:\n        explicit ContextScope(const L &lambda) : lambda_(lambda) {}\n\n        ContextScope(ContextScope &&other) : lambda_(other.lambda_) {}\n\n        void stringify(std::ostream* s) const override { lambda_(s); }\n\n        ~ContextScope() override { destroy(); }\n    };\n\n    struct DOCTEST_INTERFACE MessageBuilder : public MessageData\n    {\n        std::ostream* m_stream;\n\n        MessageBuilder(const char* file, int line, assertType::Enum severity);\n        MessageBuilder() = delete;\n        ~MessageBuilder();\n\n        // the preferred way of chaining parameters for stringification\n        template <typename T>\n        MessageBuilder& operator,(const T& in) {\n            toStream(m_stream, in);\n            return *this;\n        }\n\n        // kept here just for backwards-compatibility - the comma operator should be preferred now\n        template <typename T>\n        MessageBuilder& operator<<(const T& in) { return this->operator,(in); }\n\n        // the `,` operator has the lowest operator precedence - if `<<` is used by the user then\n        // the `,` operator will be called last which is not what we want and thus the `*` operator\n        // is used first (has higher operator precedence compared to `<<`) so that we guarantee that\n        // an operator of the MessageBuilder class is called first before the rest of the parameters\n        template <typename T>\n        MessageBuilder& operator*(const T& in) { return this->operator,(in); }\n\n        bool log();\n        void react();\n    };\n    \n    template <typename L>\n    ContextScope<L> MakeContextScope(const L &lambda) {\n        return ContextScope<L>(lambda);\n    }\n} // namespace detail\n\n#define DOCTEST_DEFINE_DECORATOR(name, type, def)                                                  \\\n    struct name                                                                                    \\\n    {                                                                                              \\\n        type data;                                                                                 \\\n        name(type in = def)                                                                        \\\n                : data(in) {}                                                                      \\\n        void fill(detail::TestCase& state) const { state.DOCTEST_CAT(m_, name) = data; }           \\\n        void fill(detail::TestSuite& state) const { state.DOCTEST_CAT(m_, name) = data; }          \\\n    }\n\nDOCTEST_DEFINE_DECORATOR(test_suite, const char*, \"\");\nDOCTEST_DEFINE_DECORATOR(description, const char*, \"\");\nDOCTEST_DEFINE_DECORATOR(skip, bool, true);\nDOCTEST_DEFINE_DECORATOR(no_breaks, bool, true);\nDOCTEST_DEFINE_DECORATOR(no_output, bool, true);\nDOCTEST_DEFINE_DECORATOR(timeout, double, 0);\nDOCTEST_DEFINE_DECORATOR(may_fail, bool, true);\nDOCTEST_DEFINE_DECORATOR(should_fail, bool, true);\nDOCTEST_DEFINE_DECORATOR(expected_failures, int, 0);\n\ntemplate <typename T>\nint registerExceptionTranslator(String (*translateFunction)(T)) {\n    DOCTEST_CLANG_SUPPRESS_WARNING_WITH_PUSH(\"-Wexit-time-destructors\")\n    static detail::ExceptionTranslator<T> exceptionTranslator(translateFunction);\n    DOCTEST_CLANG_SUPPRESS_WARNING_POP\n    detail::registerExceptionTranslatorImpl(&exceptionTranslator);\n    return 0;\n}\n\n} // namespace doctest\n\n// in a separate namespace outside of doctest because the DOCTEST_TEST_SUITE macro\n// introduces an anonymous namespace in which getCurrentTestSuite gets overridden\nnamespace doctest_detail_test_suite_ns {\nDOCTEST_INTERFACE doctest::detail::TestSuite& getCurrentTestSuite();\n} // namespace doctest_detail_test_suite_ns\n\nnamespace doctest {\n#else  // DOCTEST_CONFIG_DISABLE\ntemplate <typename T>\nint registerExceptionTranslator(String (*)(T)) {\n    return 0;\n}\n#endif // DOCTEST_CONFIG_DISABLE\n\nnamespace detail {\n    typedef void (*assert_handler)(const AssertData&);\n    struct ContextState;\n} // namespace detail\n\nclass DOCTEST_INTERFACE Context\n{\n    detail::ContextState* p;\n\n    void parseArgs(int argc, const char* const* argv, bool withDefaults = false);\n\npublic:\n    explicit Context(int argc = 0, const char* const* argv = nullptr);\n\n    ~Context();\n\n    void applyCommandLine(int argc, const char* const* argv);\n\n    void addFilter(const char* filter, const char* value);\n    void clearFilters();\n    void setOption(const char* option, int value);\n    void setOption(const char* option, const char* value);\n\n    bool shouldExit();\n\n    void setAsDefaultForAssertsOutOfTestCases();\n\n    void setAssertHandler(detail::assert_handler ah);\n\n    int run();\n};\n\nnamespace TestCaseFailureReason {\n    enum Enum\n    {\n        None                     = 0,\n        AssertFailure            = 1,   // an assertion has failed in the test case\n        Exception                = 2,   // test case threw an exception\n        Crash                    = 4,   // a crash...\n        TooManyFailedAsserts     = 8,   // the abort-after option\n        Timeout                  = 16,  // see the timeout decorator\n        ShouldHaveFailedButDidnt = 32,  // see the should_fail decorator\n        ShouldHaveFailedAndDid   = 64,  // see the should_fail decorator\n        DidntFailExactlyNumTimes = 128, // see the expected_failures decorator\n        FailedExactlyNumTimes    = 256, // see the expected_failures decorator\n        CouldHaveFailedAndDid    = 512  // see the may_fail decorator\n    };\n} // namespace TestCaseFailureReason\n\nstruct DOCTEST_INTERFACE CurrentTestCaseStats\n{\n    int    numAssertsCurrentTest;\n    int    numAssertsFailedCurrentTest;\n    double seconds;\n    int    failure_flags; // use TestCaseFailureReason::Enum\n};\n\nstruct DOCTEST_INTERFACE TestCaseException\n{\n    String error_string;\n    bool   is_crash;\n};\n\nstruct DOCTEST_INTERFACE TestRunStats\n{\n    unsigned numTestCases;\n    unsigned numTestCasesPassingFilters;\n    unsigned numTestSuitesPassingFilters;\n    unsigned numTestCasesFailed;\n    int      numAsserts;\n    int      numAssertsFailed;\n};\n\nstruct QueryData\n{\n    const TestRunStats*  run_stats = nullptr;\n    const TestCaseData** data      = nullptr;\n    unsigned             num_data  = 0;\n};\n\nstruct DOCTEST_INTERFACE IReporter\n{\n    // The constructor has to accept \"const ContextOptions&\" as a single argument\n    // which has most of the options for the run + a pointer to the stdout stream\n    // Reporter(const ContextOptions& in)\n\n    // called when a query should be reported (listing test cases, printing the version, etc.)\n    virtual void report_query(const QueryData&) = 0;\n\n    // called when the whole test run starts\n    virtual void test_run_start() = 0;\n    // called when the whole test run ends (caching a pointer to the input doesn't make sense here)\n    virtual void test_run_end(const TestRunStats&) = 0;\n\n    // called when a test case is started (safe to cache a pointer to the input)\n    virtual void test_case_start(const TestCaseData&) = 0;\n    // called when a test case is reentered because of unfinished subcases (safe to cache a pointer to the input)\n    virtual void test_case_reenter(const TestCaseData&) = 0;\n    // called when a test case has ended\n    virtual void test_case_end(const CurrentTestCaseStats&) = 0;\n\n    // called when an exception is thrown from the test case (or it crashes)\n    virtual void test_case_exception(const TestCaseException&) = 0;\n\n    // called whenever a subcase is entered (don't cache pointers to the input)\n    virtual void subcase_start(const SubcaseSignature&) = 0;\n    // called whenever a subcase is exited (don't cache pointers to the input)\n    virtual void subcase_end() = 0;\n\n    // called for each assert (don't cache pointers to the input)\n    virtual void log_assert(const AssertData&) = 0;\n    // called for each message (don't cache pointers to the input)\n    virtual void log_message(const MessageData&) = 0;\n\n    // called when a test case is skipped either because it doesn't pass the filters, has a skip decorator\n    // or isn't in the execution range (between first and last) (safe to cache a pointer to the input)\n    virtual void test_case_skipped(const TestCaseData&) = 0;\n\n    // doctest will not be managing the lifetimes of reporters given to it but this would still be nice to have\n    virtual ~IReporter();\n\n    // can obtain all currently active contexts and stringify them if one wishes to do so\n    static int                         get_num_active_contexts();\n    static const IContextScope* const* get_active_contexts();\n\n    // can iterate through contexts which have been stringified automatically in their destructors when an exception has been thrown\n    static int           get_num_stringified_contexts();\n    static const String* get_stringified_contexts();\n};\n\nnamespace detail {\n    typedef IReporter* (*reporterCreatorFunc)(const ContextOptions&);\n\n    DOCTEST_INTERFACE void registerReporterImpl(const char* name, int prio, reporterCreatorFunc c, bool isReporter);\n\n    template <typename Reporter>\n    IReporter* reporterCreator(const ContextOptions& o) {\n        return new Reporter(o);\n    }\n} // namespace detail\n\ntemplate <typename Reporter>\nint registerReporter(const char* name, int priority, bool isReporter) {\n    detail::registerReporterImpl(name, priority, detail::reporterCreator<Reporter>, isReporter);\n    return 0;\n}\n} // namespace doctest\n\n// if registering is not disabled\n#if !defined(DOCTEST_CONFIG_DISABLE)\n\n// common code in asserts - for convenience\n#define DOCTEST_ASSERT_LOG_AND_REACT(b)                                                            \\\n    if(b.log())                                                                                    \\\n        DOCTEST_BREAK_INTO_DEBUGGER();                                                             \\\n    b.react()\n\n#ifdef DOCTEST_CONFIG_NO_TRY_CATCH_IN_ASSERTS\n#define DOCTEST_WRAP_IN_TRY(x) x;\n#else // DOCTEST_CONFIG_NO_TRY_CATCH_IN_ASSERTS\n#define DOCTEST_WRAP_IN_TRY(x)                                                                     \\\n    try {                                                                                          \\\n        x;                                                                                         \\\n    } catch(...) { _DOCTEST_RB.translateException(); }\n#endif // DOCTEST_CONFIG_NO_TRY_CATCH_IN_ASSERTS\n\n#ifdef DOCTEST_CONFIG_VOID_CAST_EXPRESSIONS\n#define DOCTEST_CAST_TO_VOID(...)                                                                  \\\n    DOCTEST_GCC_SUPPRESS_WARNING_WITH_PUSH(\"-Wuseless-cast\")                                       \\\n    static_cast<void>(__VA_ARGS__);                                                                \\\n    DOCTEST_GCC_SUPPRESS_WARNING_POP\n#else // DOCTEST_CONFIG_VOID_CAST_EXPRESSIONS\n#define DOCTEST_CAST_TO_VOID(...) __VA_ARGS__;\n#endif // DOCTEST_CONFIG_VOID_CAST_EXPRESSIONS\n\n// registers the test by initializing a dummy var with a function\n#define DOCTEST_REGISTER_FUNCTION(global_prefix, f, decorators)                                    \\\n    global_prefix DOCTEST_GLOBAL_NO_WARNINGS(DOCTEST_ANONYMOUS(_DOCTEST_ANON_VAR_)) =              \\\n            doctest::detail::regTest(                                                              \\\n                    doctest::detail::TestCase(                                                     \\\n                            f, __FILE__, __LINE__,                                                 \\\n                            doctest_detail_test_suite_ns::getCurrentTestSuite()) *                 \\\n                    decorators);                                                                   \\\n    DOCTEST_GLOBAL_NO_WARNINGS_END()\n\n#define DOCTEST_IMPLEMENT_FIXTURE(der, base, func, decorators)                                     \\\n    namespace {                                                                                    \\\n        struct der : public base                                                                   \\\n        {                                                                                          \\\n            void f();                                                                              \\\n        };                                                                                         \\\n        static void func() {                                                                       \\\n            der v;                                                                                 \\\n            v.f();                                                                                 \\\n        }                                                                                          \\\n        DOCTEST_REGISTER_FUNCTION(DOCTEST_EMPTY, func, decorators)                                 \\\n    }                                                                                              \\\n    inline DOCTEST_NOINLINE void der::f()\n\n#define DOCTEST_CREATE_AND_REGISTER_FUNCTION(f, decorators)                                        \\\n    static void f();                                                                               \\\n    DOCTEST_REGISTER_FUNCTION(DOCTEST_EMPTY, f, decorators)                                        \\\n    static void f()\n\n#define DOCTEST_CREATE_AND_REGISTER_FUNCTION_IN_CLASS(f, proxy, decorators)                        \\\n    static doctest::detail::funcType proxy() { return f; }                                         \\\n    DOCTEST_REGISTER_FUNCTION(inline const, proxy(), decorators)                                   \\\n    static void f()\n\n// for registering tests\n#define DOCTEST_TEST_CASE(decorators)                                                              \\\n    DOCTEST_CREATE_AND_REGISTER_FUNCTION(DOCTEST_ANONYMOUS(_DOCTEST_ANON_FUNC_), decorators)\n\n// for registering tests in classes - requires C++17 for inline variables!\n#if __cplusplus >= 201703L || (DOCTEST_MSVC >= DOCTEST_COMPILER(19, 12, 0) && _MSVC_LANG >= 201703L)\n#define DOCTEST_TEST_CASE_CLASS(decorators)                                                        \\\n    DOCTEST_CREATE_AND_REGISTER_FUNCTION_IN_CLASS(DOCTEST_ANONYMOUS(_DOCTEST_ANON_FUNC_),          \\\n                                                  DOCTEST_ANONYMOUS(_DOCTEST_ANON_PROXY_),         \\\n                                                  decorators)\n#else // DOCTEST_TEST_CASE_CLASS\n#define DOCTEST_TEST_CASE_CLASS(...)                                                               \\\n    TEST_CASES_CAN_BE_REGISTERED_IN_CLASSES_ONLY_IN_CPP17_MODE_OR_WITH_VS_2017_OR_NEWER\n#endif // DOCTEST_TEST_CASE_CLASS\n\n// for registering tests with a fixture\n#define DOCTEST_TEST_CASE_FIXTURE(c, decorators)                                                   \\\n    DOCTEST_IMPLEMENT_FIXTURE(DOCTEST_ANONYMOUS(_DOCTEST_ANON_CLASS_), c,                          \\\n                              DOCTEST_ANONYMOUS(_DOCTEST_ANON_FUNC_), decorators)\n\n// for converting types to strings without the <typeinfo> header and demangling\n#define DOCTEST_TYPE_TO_STRING_IMPL(...)                                                           \\\n    template <>                                                                                    \\\n    inline const char* type_to_string<__VA_ARGS__>() {                                             \\\n        return \"<\" #__VA_ARGS__ \">\";                                                               \\\n    }\n#define DOCTEST_TYPE_TO_STRING(...)                                                                \\\n    namespace doctest { namespace detail {                                                         \\\n            DOCTEST_TYPE_TO_STRING_IMPL(__VA_ARGS__)                                               \\\n        }                                                                                          \\\n    }                                                                                              \\\n    typedef int DOCTEST_ANONYMOUS(_DOCTEST_ANON_FOR_SEMICOLON_)\n\n#define DOCTEST_TEST_CASE_TEMPLATE_DEFINE_IMPL(dec, T, iter, func)                                 \\\n    template <typename T>                                                                          \\\n    static void func();                                                                            \\\n    namespace {                                                                                    \\\n        template <typename Tuple>                                                                  \\\n        struct iter;                                                                               \\\n        template <typename Type, typename... Rest>                                                 \\\n        struct iter<std::tuple<Type, Rest...>>                                                     \\\n        {                                                                                          \\\n            iter(const char* file, unsigned line, int index) {                                     \\\n                doctest::detail::regTest(doctest::detail::TestCase(func<Type>, file, line,         \\\n                                            doctest_detail_test_suite_ns::getCurrentTestSuite(),   \\\n                                            doctest::detail::type_to_string<Type>(),               \\\n                                            int(line) * 1000 + index)                              \\\n                                         * dec);                                                   \\\n                iter<std::tuple<Rest...>>(file, line, index + 1);                                  \\\n            }                                                                                      \\\n        };                                                                                         \\\n        template <>                                                                                \\\n        struct iter<std::tuple<>>                                                                  \\\n        {                                                                                          \\\n            iter(const char*, unsigned, int) {}                                                    \\\n        };                                                                                         \\\n    }                                                                                              \\\n    template <typename T>                                                                          \\\n    static void func()\n\n#define DOCTEST_TEST_CASE_TEMPLATE_DEFINE(dec, T, id)                                              \\\n    DOCTEST_TEST_CASE_TEMPLATE_DEFINE_IMPL(dec, T, DOCTEST_CAT(id, ITERATOR),                      \\\n                                           DOCTEST_ANONYMOUS(_DOCTEST_ANON_TMP_))\n\n#define DOCTEST_TEST_CASE_TEMPLATE_INSTANTIATE_IMPL(id, anon, ...)                                 \\\n    DOCTEST_GLOBAL_NO_WARNINGS(DOCTEST_CAT(anon, DUMMY)) =                                         \\\n        doctest::detail::instantiationHelper(DOCTEST_CAT(id, ITERATOR)<__VA_ARGS__>(__FILE__, __LINE__, 0));\\\n    DOCTEST_GLOBAL_NO_WARNINGS_END()\n\n#define DOCTEST_TEST_CASE_TEMPLATE_INVOKE(id, ...)                                                 \\\n    DOCTEST_TEST_CASE_TEMPLATE_INSTANTIATE_IMPL(id, DOCTEST_ANONYMOUS(_DOCTEST_ANON_TMP_), std::tuple<__VA_ARGS__>) \\\n    typedef int DOCTEST_ANONYMOUS(_DOCTEST_ANON_FOR_SEMICOLON_)\n\n#define DOCTEST_TEST_CASE_TEMPLATE_APPLY(id, ...)                                                  \\\n    DOCTEST_TEST_CASE_TEMPLATE_INSTANTIATE_IMPL(id, DOCTEST_ANONYMOUS(_DOCTEST_ANON_TMP_), __VA_ARGS__) \\\n    typedef int DOCTEST_ANONYMOUS(_DOCTEST_ANON_FOR_SEMICOLON_)\n\n#define DOCTEST_TEST_CASE_TEMPLATE_IMPL(dec, T, anon, ...)                                         \\\n    DOCTEST_TEST_CASE_TEMPLATE_DEFINE_IMPL(dec, T, DOCTEST_CAT(anon, ITERATOR), anon);             \\\n    DOCTEST_TEST_CASE_TEMPLATE_INSTANTIATE_IMPL(anon, anon, std::tuple<__VA_ARGS__>)               \\\n    template <typename T>                                                                          \\\n    static void anon()\n\n#define DOCTEST_TEST_CASE_TEMPLATE(dec, T, ...)                                                    \\\n    DOCTEST_TEST_CASE_TEMPLATE_IMPL(dec, T, DOCTEST_ANONYMOUS(_DOCTEST_ANON_TMP_), __VA_ARGS__)\n\n// for subcases\n#define DOCTEST_SUBCASE(name)                                                                      \\\n    if(const doctest::detail::Subcase & DOCTEST_ANONYMOUS(_DOCTEST_ANON_SUBCASE_) DOCTEST_UNUSED = \\\n               doctest::detail::Subcase(name, __FILE__, __LINE__))\n\n// for grouping tests in test suites by using code blocks\n#define DOCTEST_TEST_SUITE_IMPL(decorators, ns_name)                                               \\\n    namespace ns_name { namespace doctest_detail_test_suite_ns {                                   \\\n            static DOCTEST_NOINLINE doctest::detail::TestSuite& getCurrentTestSuite() {            \\\n                DOCTEST_MSVC_SUPPRESS_WARNING_WITH_PUSH(4640)                                      \\\n                DOCTEST_CLANG_SUPPRESS_WARNING_WITH_PUSH(\"-Wexit-time-destructors\")                \\\n                static doctest::detail::TestSuite data;                                            \\\n                static bool                       inited = false;                                  \\\n                DOCTEST_MSVC_SUPPRESS_WARNING_POP                                                  \\\n                DOCTEST_CLANG_SUPPRESS_WARNING_POP                                                 \\\n                if(!inited) {                                                                      \\\n                    data* decorators;                                                              \\\n                    inited = true;                                                                 \\\n                }                                                                                  \\\n                return data;                                                                       \\\n            }                                                                                      \\\n        }                                                                                          \\\n    }                                                                                              \\\n    namespace ns_name\n\n#define DOCTEST_TEST_SUITE(decorators)                                                             \\\n    DOCTEST_TEST_SUITE_IMPL(decorators, DOCTEST_ANONYMOUS(_DOCTEST_ANON_SUITE_))\n\n// for starting a testsuite block\n#define DOCTEST_TEST_SUITE_BEGIN(decorators)                                                       \\\n    DOCTEST_GLOBAL_NO_WARNINGS(DOCTEST_ANONYMOUS(_DOCTEST_ANON_VAR_)) =                            \\\n            doctest::detail::setTestSuite(doctest::detail::TestSuite() * decorators);              \\\n    DOCTEST_GLOBAL_NO_WARNINGS_END()                                                               \\\n    typedef int DOCTEST_ANONYMOUS(_DOCTEST_ANON_FOR_SEMICOLON_)\n\n// for ending a testsuite block\n#define DOCTEST_TEST_SUITE_END                                                                     \\\n    DOCTEST_GLOBAL_NO_WARNINGS(DOCTEST_ANONYMOUS(_DOCTEST_ANON_VAR_)) =                            \\\n            doctest::detail::setTestSuite(doctest::detail::TestSuite() * \"\");                      \\\n    DOCTEST_GLOBAL_NO_WARNINGS_END()                                                               \\\n    typedef int DOCTEST_ANONYMOUS(_DOCTEST_ANON_FOR_SEMICOLON_)\n\n// for registering exception translators\n#define DOCTEST_REGISTER_EXCEPTION_TRANSLATOR_IMPL(translatorName, signature)                      \\\n    inline doctest::String translatorName(signature);                                              \\\n    DOCTEST_GLOBAL_NO_WARNINGS(DOCTEST_ANONYMOUS(_DOCTEST_ANON_TRANSLATOR_)) =                     \\\n            doctest::registerExceptionTranslator(translatorName);                                  \\\n    DOCTEST_GLOBAL_NO_WARNINGS_END()                                                               \\\n    doctest::String translatorName(signature)\n\n#define DOCTEST_REGISTER_EXCEPTION_TRANSLATOR(signature)                                           \\\n    DOCTEST_REGISTER_EXCEPTION_TRANSLATOR_IMPL(DOCTEST_ANONYMOUS(_DOCTEST_ANON_TRANSLATOR_),       \\\n                                               signature)\n\n// for registering reporters\n#define DOCTEST_REGISTER_REPORTER(name, priority, reporter)                                        \\\n    DOCTEST_GLOBAL_NO_WARNINGS(DOCTEST_ANONYMOUS(_DOCTEST_ANON_REPORTER_)) =                       \\\n            doctest::registerReporter<reporter>(name, priority, true);                             \\\n    DOCTEST_GLOBAL_NO_WARNINGS_END() typedef int DOCTEST_ANONYMOUS(_DOCTEST_ANON_FOR_SEMICOLON_)\n\n// for registering listeners\n#define DOCTEST_REGISTER_LISTENER(name, priority, reporter)                                        \\\n    DOCTEST_GLOBAL_NO_WARNINGS(DOCTEST_ANONYMOUS(_DOCTEST_ANON_REPORTER_)) =                       \\\n            doctest::registerReporter<reporter>(name, priority, false);                            \\\n    DOCTEST_GLOBAL_NO_WARNINGS_END() typedef int DOCTEST_ANONYMOUS(_DOCTEST_ANON_FOR_SEMICOLON_)\n\n// for logging\n#define DOCTEST_INFO(...)                                                                          \\\n    DOCTEST_INFO_IMPL(DOCTEST_ANONYMOUS(_DOCTEST_CAPTURE_), DOCTEST_ANONYMOUS(_DOCTEST_CAPTURE_),  \\\n                      DOCTEST_ANONYMOUS(_DOCTEST_CAPTURE_), __VA_ARGS__)\n\n#define DOCTEST_INFO_IMPL(lambda_name, mb_name, s_name, ...)                                       \\\n    DOCTEST_MSVC_SUPPRESS_WARNING_WITH_PUSH(4626)                                                  \\\n    auto lambda_name = [&](std::ostream* s_name) {                                                 \\\n        doctest::detail::MessageBuilder mb_name(__FILE__, __LINE__, doctest::assertType::is_warn); \\\n        mb_name.m_stream = s_name;                                                                 \\\n        mb_name * __VA_ARGS__;                                                                     \\\n    };                                                                                             \\\n    DOCTEST_MSVC_SUPPRESS_WARNING_POP                                                              \\\n    auto DOCTEST_ANONYMOUS(_DOCTEST_CAPTURE_) = doctest::detail::MakeContextScope(lambda_name)\n\n#define DOCTEST_CAPTURE(x) DOCTEST_INFO(#x \" := \", x)\n\n#define DOCTEST_ADD_AT_IMPL(type, file, line, mb, ...)                                             \\\n    do {                                                                                           \\\n        doctest::detail::MessageBuilder mb(file, line, doctest::assertType::type);                 \\\n        mb * __VA_ARGS__;                                                                          \\\n        DOCTEST_ASSERT_LOG_AND_REACT(mb);                                                          \\\n    } while(false)\n\n// clang-format off\n#define DOCTEST_ADD_MESSAGE_AT(file, line, ...) DOCTEST_ADD_AT_IMPL(is_warn, file, line, DOCTEST_ANONYMOUS(_DOCTEST_MESSAGE_), __VA_ARGS__)\n#define DOCTEST_ADD_FAIL_CHECK_AT(file, line, ...) DOCTEST_ADD_AT_IMPL(is_check, file, line, DOCTEST_ANONYMOUS(_DOCTEST_MESSAGE_), __VA_ARGS__)\n#define DOCTEST_ADD_FAIL_AT(file, line, ...) DOCTEST_ADD_AT_IMPL(is_require, file, line, DOCTEST_ANONYMOUS(_DOCTEST_MESSAGE_), __VA_ARGS__)\n// clang-format on\n\n#define DOCTEST_MESSAGE(...) DOCTEST_ADD_MESSAGE_AT(__FILE__, __LINE__, __VA_ARGS__)\n#define DOCTEST_FAIL_CHECK(...) DOCTEST_ADD_FAIL_CHECK_AT(__FILE__, __LINE__, __VA_ARGS__)\n#define DOCTEST_FAIL(...) DOCTEST_ADD_FAIL_AT(__FILE__, __LINE__, __VA_ARGS__)\n\n#define DOCTEST_TO_LVALUE(...) __VA_ARGS__ // Not removed to keep backwards compatibility.\n\n#ifndef DOCTEST_CONFIG_SUPER_FAST_ASSERTS\n\n#define DOCTEST_ASSERT_IMPLEMENT_2(assert_type, ...)                                               \\\n    DOCTEST_CLANG_SUPPRESS_WARNING_WITH_PUSH(\"-Woverloaded-shift-op-parentheses\")                  \\\n    doctest::detail::ResultBuilder _DOCTEST_RB(doctest::assertType::assert_type, __FILE__,         \\\n                                               __LINE__, #__VA_ARGS__);                            \\\n    DOCTEST_WRAP_IN_TRY(_DOCTEST_RB.setResult(                                                     \\\n            doctest::detail::ExpressionDecomposer(doctest::assertType::assert_type)                \\\n            << __VA_ARGS__))                                                                       \\\n    DOCTEST_ASSERT_LOG_AND_REACT(_DOCTEST_RB)                                                      \\\n    DOCTEST_CLANG_SUPPRESS_WARNING_POP\n\n#define DOCTEST_ASSERT_IMPLEMENT_1(assert_type, ...)                                               \\\n    do {                                                                                           \\\n        DOCTEST_ASSERT_IMPLEMENT_2(assert_type, __VA_ARGS__);                                      \\\n    } while(false)\n\n#else // DOCTEST_CONFIG_SUPER_FAST_ASSERTS\n\n// necessary for <ASSERT>_MESSAGE\n#define DOCTEST_ASSERT_IMPLEMENT_2 DOCTEST_ASSERT_IMPLEMENT_1\n\n#define DOCTEST_ASSERT_IMPLEMENT_1(assert_type, ...)                                               \\\n    DOCTEST_CLANG_SUPPRESS_WARNING_WITH_PUSH(\"-Woverloaded-shift-op-parentheses\")                  \\\n    doctest::detail::decomp_assert(                                                                \\\n            doctest::assertType::assert_type, __FILE__, __LINE__, #__VA_ARGS__,                    \\\n            doctest::detail::ExpressionDecomposer(doctest::assertType::assert_type)                \\\n                    << __VA_ARGS__) DOCTEST_CLANG_SUPPRESS_WARNING_POP\n\n#endif // DOCTEST_CONFIG_SUPER_FAST_ASSERTS\n\n#define DOCTEST_WARN(...) DOCTEST_ASSERT_IMPLEMENT_1(DT_WARN, __VA_ARGS__)\n#define DOCTEST_CHECK(...) DOCTEST_ASSERT_IMPLEMENT_1(DT_CHECK, __VA_ARGS__)\n#define DOCTEST_REQUIRE(...) DOCTEST_ASSERT_IMPLEMENT_1(DT_REQUIRE, __VA_ARGS__)\n#define DOCTEST_WARN_FALSE(...) DOCTEST_ASSERT_IMPLEMENT_1(DT_WARN_FALSE, __VA_ARGS__)\n#define DOCTEST_CHECK_FALSE(...) DOCTEST_ASSERT_IMPLEMENT_1(DT_CHECK_FALSE, __VA_ARGS__)\n#define DOCTEST_REQUIRE_FALSE(...) DOCTEST_ASSERT_IMPLEMENT_1(DT_REQUIRE_FALSE, __VA_ARGS__)\n\n// clang-format off\n#define DOCTEST_WARN_MESSAGE(cond, ...) do { DOCTEST_INFO(__VA_ARGS__); DOCTEST_ASSERT_IMPLEMENT_2(DT_WARN, cond); } while(false)\n#define DOCTEST_CHECK_MESSAGE(cond, ...) do { DOCTEST_INFO(__VA_ARGS__); DOCTEST_ASSERT_IMPLEMENT_2(DT_CHECK, cond); } while(false)\n#define DOCTEST_REQUIRE_MESSAGE(cond, ...) do { DOCTEST_INFO(__VA_ARGS__); DOCTEST_ASSERT_IMPLEMENT_2(DT_REQUIRE, cond); } while(false)\n#define DOCTEST_WARN_FALSE_MESSAGE(cond, ...) do { DOCTEST_INFO(__VA_ARGS__); DOCTEST_ASSERT_IMPLEMENT_2(DT_WARN_FALSE, cond); } while(false)\n#define DOCTEST_CHECK_FALSE_MESSAGE(cond, ...) do { DOCTEST_INFO(__VA_ARGS__); DOCTEST_ASSERT_IMPLEMENT_2(DT_CHECK_FALSE, cond); } while(false)\n#define DOCTEST_REQUIRE_FALSE_MESSAGE(cond, ...) do { DOCTEST_INFO(__VA_ARGS__); DOCTEST_ASSERT_IMPLEMENT_2(DT_REQUIRE_FALSE, cond); } while(false)\n// clang-format on\n\n#define DOCTEST_ASSERT_THROWS_AS(expr, assert_type, message, ...)                                  \\\n    do {                                                                                           \\\n        if(!doctest::getContextOptions()->no_throw) {                                              \\\n            doctest::detail::ResultBuilder _DOCTEST_RB(doctest::assertType::assert_type, __FILE__, \\\n                                                       __LINE__, #expr, #__VA_ARGS__, message);    \\\n            try {                                                                                  \\\n                DOCTEST_CAST_TO_VOID(expr)                                                         \\\n            } catch(const typename doctest::detail::remove_const<                                  \\\n                    typename doctest::detail::remove_reference<__VA_ARGS__>::type>::type&) {       \\\n                _DOCTEST_RB.translateException();                                                  \\\n                _DOCTEST_RB.m_threw_as = true;                                                     \\\n            } catch(...) { _DOCTEST_RB.translateException(); }                                     \\\n            DOCTEST_ASSERT_LOG_AND_REACT(_DOCTEST_RB);                                             \\\n        }                                                                                          \\\n    } while(false)\n\n#define DOCTEST_ASSERT_THROWS_WITH(expr, expr_str, assert_type, ...)                               \\\n    do {                                                                                           \\\n        if(!doctest::getContextOptions()->no_throw) {                                              \\\n            doctest::detail::ResultBuilder _DOCTEST_RB(doctest::assertType::assert_type, __FILE__, \\\n                                                       __LINE__, expr_str, \"\", __VA_ARGS__);       \\\n            try {                                                                                  \\\n                DOCTEST_CAST_TO_VOID(expr)                                                         \\\n            } catch(...) { _DOCTEST_RB.translateException(); }                                     \\\n            DOCTEST_ASSERT_LOG_AND_REACT(_DOCTEST_RB);                                             \\\n        }                                                                                          \\\n    } while(false)\n\n#define DOCTEST_ASSERT_NOTHROW(assert_type, ...)                                                   \\\n    do {                                                                                           \\\n        doctest::detail::ResultBuilder _DOCTEST_RB(doctest::assertType::assert_type, __FILE__,     \\\n                                                   __LINE__, #__VA_ARGS__);                        \\\n        try {                                                                                      \\\n            DOCTEST_CAST_TO_VOID(__VA_ARGS__)                                                      \\\n        } catch(...) { _DOCTEST_RB.translateException(); }                                         \\\n        DOCTEST_ASSERT_LOG_AND_REACT(_DOCTEST_RB);                                                 \\\n    } while(false)\n\n// clang-format off\n#define DOCTEST_WARN_THROWS(...) DOCTEST_ASSERT_THROWS_WITH((__VA_ARGS__), #__VA_ARGS__, DT_WARN_THROWS, \"\")\n#define DOCTEST_CHECK_THROWS(...) DOCTEST_ASSERT_THROWS_WITH((__VA_ARGS__), #__VA_ARGS__, DT_CHECK_THROWS, \"\")\n#define DOCTEST_REQUIRE_THROWS(...) DOCTEST_ASSERT_THROWS_WITH((__VA_ARGS__), #__VA_ARGS__, DT_REQUIRE_THROWS, \"\")\n\n#define DOCTEST_WARN_THROWS_AS(expr, ...) DOCTEST_ASSERT_THROWS_AS(expr, DT_WARN_THROWS_AS, \"\", __VA_ARGS__)\n#define DOCTEST_CHECK_THROWS_AS(expr, ...) DOCTEST_ASSERT_THROWS_AS(expr, DT_CHECK_THROWS_AS, \"\", __VA_ARGS__)\n#define DOCTEST_REQUIRE_THROWS_AS(expr, ...) DOCTEST_ASSERT_THROWS_AS(expr, DT_REQUIRE_THROWS_AS, \"\", __VA_ARGS__)\n\n#define DOCTEST_WARN_THROWS_WITH(expr, ...) DOCTEST_ASSERT_THROWS_WITH(expr, #expr, DT_WARN_THROWS_WITH, __VA_ARGS__)\n#define DOCTEST_CHECK_THROWS_WITH(expr, ...) DOCTEST_ASSERT_THROWS_WITH(expr, #expr, DT_CHECK_THROWS_WITH, __VA_ARGS__)\n#define DOCTEST_REQUIRE_THROWS_WITH(expr, ...) DOCTEST_ASSERT_THROWS_WITH(expr, #expr, DT_REQUIRE_THROWS_WITH, __VA_ARGS__)\n\n#define DOCTEST_WARN_THROWS_WITH_AS(expr, message, ...) DOCTEST_ASSERT_THROWS_AS(expr, DT_WARN_THROWS_WITH_AS, message, __VA_ARGS__)\n#define DOCTEST_CHECK_THROWS_WITH_AS(expr, message, ...) DOCTEST_ASSERT_THROWS_AS(expr, DT_CHECK_THROWS_WITH_AS, message, __VA_ARGS__)\n#define DOCTEST_REQUIRE_THROWS_WITH_AS(expr, message, ...) DOCTEST_ASSERT_THROWS_AS(expr, DT_REQUIRE_THROWS_WITH_AS, message, __VA_ARGS__)\n\n#define DOCTEST_WARN_NOTHROW(...) DOCTEST_ASSERT_NOTHROW(DT_WARN_NOTHROW, __VA_ARGS__)\n#define DOCTEST_CHECK_NOTHROW(...) DOCTEST_ASSERT_NOTHROW(DT_CHECK_NOTHROW, __VA_ARGS__)\n#define DOCTEST_REQUIRE_NOTHROW(...) DOCTEST_ASSERT_NOTHROW(DT_REQUIRE_NOTHROW, __VA_ARGS__)\n\n#define DOCTEST_WARN_THROWS_MESSAGE(expr, ...) do { DOCTEST_INFO(__VA_ARGS__); DOCTEST_WARN_THROWS(expr); } while(false)\n#define DOCTEST_CHECK_THROWS_MESSAGE(expr, ...) do { DOCTEST_INFO(__VA_ARGS__); DOCTEST_CHECK_THROWS(expr); } while(false)\n#define DOCTEST_REQUIRE_THROWS_MESSAGE(expr, ...) do { DOCTEST_INFO(__VA_ARGS__); DOCTEST_REQUIRE_THROWS(expr); } while(false)\n#define DOCTEST_WARN_THROWS_AS_MESSAGE(expr, ex, ...) do { DOCTEST_INFO(__VA_ARGS__); DOCTEST_WARN_THROWS_AS(expr, ex); } while(false)\n#define DOCTEST_CHECK_THROWS_AS_MESSAGE(expr, ex, ...) do { DOCTEST_INFO(__VA_ARGS__); DOCTEST_CHECK_THROWS_AS(expr, ex); } while(false)\n#define DOCTEST_REQUIRE_THROWS_AS_MESSAGE(expr, ex, ...) do { DOCTEST_INFO(__VA_ARGS__); DOCTEST_REQUIRE_THROWS_AS(expr, ex); } while(false)\n#define DOCTEST_WARN_THROWS_WITH_MESSAGE(expr, with, ...) do { DOCTEST_INFO(__VA_ARGS__); DOCTEST_WARN_THROWS_WITH(expr, with); } while(false)\n#define DOCTEST_CHECK_THROWS_WITH_MESSAGE(expr, with, ...) do { DOCTEST_INFO(__VA_ARGS__); DOCTEST_CHECK_THROWS_WITH(expr, with); } while(false)\n#define DOCTEST_REQUIRE_THROWS_WITH_MESSAGE(expr, with, ...) do { DOCTEST_INFO(__VA_ARGS__); DOCTEST_REQUIRE_THROWS_WITH(expr, with); } while(false)\n#define DOCTEST_WARN_THROWS_WITH_AS_MESSAGE(expr, with, ex, ...) do { DOCTEST_INFO(__VA_ARGS__); DOCTEST_WARN_THROWS_WITH_AS(expr, with, ex); } while(false)\n#define DOCTEST_CHECK_THROWS_WITH_AS_MESSAGE(expr, with, ex, ...) do { DOCTEST_INFO(__VA_ARGS__); DOCTEST_CHECK_THROWS_WITH_AS(expr, with, ex); } while(false)\n#define DOCTEST_REQUIRE_THROWS_WITH_AS_MESSAGE(expr, with, ex, ...) do { DOCTEST_INFO(__VA_ARGS__); DOCTEST_REQUIRE_THROWS_WITH_AS(expr, with, ex); } while(false)\n#define DOCTEST_WARN_NOTHROW_MESSAGE(expr, ...) do { DOCTEST_INFO(__VA_ARGS__); DOCTEST_WARN_NOTHROW(expr); } while(false)\n#define DOCTEST_CHECK_NOTHROW_MESSAGE(expr, ...) do { DOCTEST_INFO(__VA_ARGS__); DOCTEST_CHECK_NOTHROW(expr); } while(false)\n#define DOCTEST_REQUIRE_NOTHROW_MESSAGE(expr, ...) do { DOCTEST_INFO(__VA_ARGS__); DOCTEST_REQUIRE_NOTHROW(expr); } while(false)\n// clang-format on\n\n#ifndef DOCTEST_CONFIG_SUPER_FAST_ASSERTS\n\n#define DOCTEST_BINARY_ASSERT(assert_type, comp, ...)                                              \\\n    do {                                                                                           \\\n        doctest::detail::ResultBuilder _DOCTEST_RB(doctest::assertType::assert_type, __FILE__,     \\\n                                                   __LINE__, #__VA_ARGS__);                        \\\n        DOCTEST_WRAP_IN_TRY(                                                                       \\\n                _DOCTEST_RB.binary_assert<doctest::detail::binaryAssertComparison::comp>(          \\\n                        __VA_ARGS__))                                                              \\\n        DOCTEST_ASSERT_LOG_AND_REACT(_DOCTEST_RB);                                                 \\\n    } while(false)\n\n#define DOCTEST_UNARY_ASSERT(assert_type, ...)                                                     \\\n    do {                                                                                           \\\n        doctest::detail::ResultBuilder _DOCTEST_RB(doctest::assertType::assert_type, __FILE__,     \\\n                                                   __LINE__, #__VA_ARGS__);                        \\\n        DOCTEST_WRAP_IN_TRY(_DOCTEST_RB.unary_assert(__VA_ARGS__))                                 \\\n        DOCTEST_ASSERT_LOG_AND_REACT(_DOCTEST_RB);                                                 \\\n    } while(false)\n\n#else // DOCTEST_CONFIG_SUPER_FAST_ASSERTS\n\n#define DOCTEST_BINARY_ASSERT(assert_type, comparison, ...)                                        \\\n    doctest::detail::binary_assert<doctest::detail::binaryAssertComparison::comparison>(           \\\n            doctest::assertType::assert_type, __FILE__, __LINE__, #__VA_ARGS__, __VA_ARGS__)\n\n#define DOCTEST_UNARY_ASSERT(assert_type, ...)                                                     \\\n    doctest::detail::unary_assert(doctest::assertType::assert_type, __FILE__, __LINE__,            \\\n                                  #__VA_ARGS__, __VA_ARGS__)\n\n#endif // DOCTEST_CONFIG_SUPER_FAST_ASSERTS\n\n#define DOCTEST_WARN_EQ(...) DOCTEST_BINARY_ASSERT(DT_WARN_EQ, eq, __VA_ARGS__)\n#define DOCTEST_CHECK_EQ(...) DOCTEST_BINARY_ASSERT(DT_CHECK_EQ, eq, __VA_ARGS__)\n#define DOCTEST_REQUIRE_EQ(...) DOCTEST_BINARY_ASSERT(DT_REQUIRE_EQ, eq, __VA_ARGS__)\n#define DOCTEST_WARN_NE(...) DOCTEST_BINARY_ASSERT(DT_WARN_NE, ne, __VA_ARGS__)\n#define DOCTEST_CHECK_NE(...) DOCTEST_BINARY_ASSERT(DT_CHECK_NE, ne, __VA_ARGS__)\n#define DOCTEST_REQUIRE_NE(...) DOCTEST_BINARY_ASSERT(DT_REQUIRE_NE, ne, __VA_ARGS__)\n#define DOCTEST_WARN_GT(...) DOCTEST_BINARY_ASSERT(DT_WARN_GT, gt, __VA_ARGS__)\n#define DOCTEST_CHECK_GT(...) DOCTEST_BINARY_ASSERT(DT_CHECK_GT, gt, __VA_ARGS__)\n#define DOCTEST_REQUIRE_GT(...) DOCTEST_BINARY_ASSERT(DT_REQUIRE_GT, gt, __VA_ARGS__)\n#define DOCTEST_WARN_LT(...) DOCTEST_BINARY_ASSERT(DT_WARN_LT, lt, __VA_ARGS__)\n#define DOCTEST_CHECK_LT(...) DOCTEST_BINARY_ASSERT(DT_CHECK_LT, lt, __VA_ARGS__)\n#define DOCTEST_REQUIRE_LT(...) DOCTEST_BINARY_ASSERT(DT_REQUIRE_LT, lt, __VA_ARGS__)\n#define DOCTEST_WARN_GE(...) DOCTEST_BINARY_ASSERT(DT_WARN_GE, ge, __VA_ARGS__)\n#define DOCTEST_CHECK_GE(...) DOCTEST_BINARY_ASSERT(DT_CHECK_GE, ge, __VA_ARGS__)\n#define DOCTEST_REQUIRE_GE(...) DOCTEST_BINARY_ASSERT(DT_REQUIRE_GE, ge, __VA_ARGS__)\n#define DOCTEST_WARN_LE(...) DOCTEST_BINARY_ASSERT(DT_WARN_LE, le, __VA_ARGS__)\n#define DOCTEST_CHECK_LE(...) DOCTEST_BINARY_ASSERT(DT_CHECK_LE, le, __VA_ARGS__)\n#define DOCTEST_REQUIRE_LE(...) DOCTEST_BINARY_ASSERT(DT_REQUIRE_LE, le, __VA_ARGS__)\n\n#define DOCTEST_WARN_UNARY(...) DOCTEST_UNARY_ASSERT(DT_WARN_UNARY, __VA_ARGS__)\n#define DOCTEST_CHECK_UNARY(...) DOCTEST_UNARY_ASSERT(DT_CHECK_UNARY, __VA_ARGS__)\n#define DOCTEST_REQUIRE_UNARY(...) DOCTEST_UNARY_ASSERT(DT_REQUIRE_UNARY, __VA_ARGS__)\n#define DOCTEST_WARN_UNARY_FALSE(...) DOCTEST_UNARY_ASSERT(DT_WARN_UNARY_FALSE, __VA_ARGS__)\n#define DOCTEST_CHECK_UNARY_FALSE(...) DOCTEST_UNARY_ASSERT(DT_CHECK_UNARY_FALSE, __VA_ARGS__)\n#define DOCTEST_REQUIRE_UNARY_FALSE(...) DOCTEST_UNARY_ASSERT(DT_REQUIRE_UNARY_FALSE, __VA_ARGS__)\n\n#ifdef DOCTEST_CONFIG_NO_EXCEPTIONS\n\n#undef DOCTEST_WARN_THROWS\n#undef DOCTEST_CHECK_THROWS\n#undef DOCTEST_REQUIRE_THROWS\n#undef DOCTEST_WARN_THROWS_AS\n#undef DOCTEST_CHECK_THROWS_AS\n#undef DOCTEST_REQUIRE_THROWS_AS\n#undef DOCTEST_WARN_THROWS_WITH\n#undef DOCTEST_CHECK_THROWS_WITH\n#undef DOCTEST_REQUIRE_THROWS_WITH\n#undef DOCTEST_WARN_THROWS_WITH_AS\n#undef DOCTEST_CHECK_THROWS_WITH_AS\n#undef DOCTEST_REQUIRE_THROWS_WITH_AS\n#undef DOCTEST_WARN_NOTHROW\n#undef DOCTEST_CHECK_NOTHROW\n#undef DOCTEST_REQUIRE_NOTHROW\n\n#undef DOCTEST_WARN_THROWS_MESSAGE\n#undef DOCTEST_CHECK_THROWS_MESSAGE\n#undef DOCTEST_REQUIRE_THROWS_MESSAGE\n#undef DOCTEST_WARN_THROWS_AS_MESSAGE\n#undef DOCTEST_CHECK_THROWS_AS_MESSAGE\n#undef DOCTEST_REQUIRE_THROWS_AS_MESSAGE\n#undef DOCTEST_WARN_THROWS_WITH_MESSAGE\n#undef DOCTEST_CHECK_THROWS_WITH_MESSAGE\n#undef DOCTEST_REQUIRE_THROWS_WITH_MESSAGE\n#undef DOCTEST_WARN_THROWS_WITH_AS_MESSAGE\n#undef DOCTEST_CHECK_THROWS_WITH_AS_MESSAGE\n#undef DOCTEST_REQUIRE_THROWS_WITH_AS_MESSAGE\n#undef DOCTEST_WARN_NOTHROW_MESSAGE\n#undef DOCTEST_CHECK_NOTHROW_MESSAGE\n#undef DOCTEST_REQUIRE_NOTHROW_MESSAGE\n\n#ifdef DOCTEST_CONFIG_NO_EXCEPTIONS_BUT_WITH_ALL_ASSERTS\n\n#define DOCTEST_WARN_THROWS(...) (static_cast<void>(0))\n#define DOCTEST_CHECK_THROWS(...) (static_cast<void>(0))\n#define DOCTEST_REQUIRE_THROWS(...) (static_cast<void>(0))\n#define DOCTEST_WARN_THROWS_AS(expr, ...) (static_cast<void>(0))\n#define DOCTEST_CHECK_THROWS_AS(expr, ...) (static_cast<void>(0))\n#define DOCTEST_REQUIRE_THROWS_AS(expr, ...) (static_cast<void>(0))\n#define DOCTEST_WARN_THROWS_WITH(expr, ...) (static_cast<void>(0))\n#define DOCTEST_CHECK_THROWS_WITH(expr, ...) (static_cast<void>(0))\n#define DOCTEST_REQUIRE_THROWS_WITH(expr, ...) (static_cast<void>(0))\n#define DOCTEST_WARN_THROWS_WITH_AS(expr, with, ...) (static_cast<void>(0))\n#define DOCTEST_CHECK_THROWS_WITH_AS(expr, with, ...) (static_cast<void>(0))\n#define DOCTEST_REQUIRE_THROWS_WITH_AS(expr, with, ...) (static_cast<void>(0))\n#define DOCTEST_WARN_NOTHROW(...) (static_cast<void>(0))\n#define DOCTEST_CHECK_NOTHROW(...) (static_cast<void>(0))\n#define DOCTEST_REQUIRE_NOTHROW(...) (static_cast<void>(0))\n\n#define DOCTEST_WARN_THROWS_MESSAGE(expr, ...) (static_cast<void>(0))\n#define DOCTEST_CHECK_THROWS_MESSAGE(expr, ...) (static_cast<void>(0))\n#define DOCTEST_REQUIRE_THROWS_MESSAGE(expr, ...) (static_cast<void>(0))\n#define DOCTEST_WARN_THROWS_AS_MESSAGE(expr, ex, ...) (static_cast<void>(0))\n#define DOCTEST_CHECK_THROWS_AS_MESSAGE(expr, ex, ...) (static_cast<void>(0))\n#define DOCTEST_REQUIRE_THROWS_AS_MESSAGE(expr, ex, ...) (static_cast<void>(0))\n#define DOCTEST_WARN_THROWS_WITH_MESSAGE(expr, with, ...) (static_cast<void>(0))\n#define DOCTEST_CHECK_THROWS_WITH_MESSAGE(expr, with, ...) (static_cast<void>(0))\n#define DOCTEST_REQUIRE_THROWS_WITH_MESSAGE(expr, with, ...) (static_cast<void>(0))\n#define DOCTEST_WARN_THROWS_WITH_AS_MESSAGE(expr, with, ex, ...) (static_cast<void>(0))\n#define DOCTEST_CHECK_THROWS_WITH_AS_MESSAGE(expr, with, ex, ...) (static_cast<void>(0))\n#define DOCTEST_REQUIRE_THROWS_WITH_AS_MESSAGE(expr, with, ex, ...) (static_cast<void>(0))\n#define DOCTEST_WARN_NOTHROW_MESSAGE(expr, ...) (static_cast<void>(0))\n#define DOCTEST_CHECK_NOTHROW_MESSAGE(expr, ...) (static_cast<void>(0))\n#define DOCTEST_REQUIRE_NOTHROW_MESSAGE(expr, ...) (static_cast<void>(0))\n\n#else // DOCTEST_CONFIG_NO_EXCEPTIONS_BUT_WITH_ALL_ASSERTS\n\n#undef DOCTEST_REQUIRE\n#undef DOCTEST_REQUIRE_FALSE\n#undef DOCTEST_REQUIRE_MESSAGE\n#undef DOCTEST_REQUIRE_FALSE_MESSAGE\n#undef DOCTEST_REQUIRE_EQ\n#undef DOCTEST_REQUIRE_NE\n#undef DOCTEST_REQUIRE_GT\n#undef DOCTEST_REQUIRE_LT\n#undef DOCTEST_REQUIRE_GE\n#undef DOCTEST_REQUIRE_LE\n#undef DOCTEST_REQUIRE_UNARY\n#undef DOCTEST_REQUIRE_UNARY_FALSE\n\n#endif // DOCTEST_CONFIG_NO_EXCEPTIONS_BUT_WITH_ALL_ASSERTS\n\n#endif // DOCTEST_CONFIG_NO_EXCEPTIONS\n\n// =================================================================================================\n// == WHAT FOLLOWS IS VERSIONS OF THE MACROS THAT DO NOT DO ANY REGISTERING!                      ==\n// == THIS CAN BE ENABLED BY DEFINING DOCTEST_CONFIG_DISABLE GLOBALLY!                            ==\n// =================================================================================================\n#else // DOCTEST_CONFIG_DISABLE\n\n#define DOCTEST_IMPLEMENT_FIXTURE(der, base, func, name)                                           \\\n    namespace {                                                                                    \\\n        template <typename DOCTEST_UNUSED_TEMPLATE_TYPE>                                           \\\n        struct der : public base                                                                   \\\n        { void f(); };                                                                             \\\n    }                                                                                              \\\n    template <typename DOCTEST_UNUSED_TEMPLATE_TYPE>                                               \\\n    inline void der<DOCTEST_UNUSED_TEMPLATE_TYPE>::f()\n\n#define DOCTEST_CREATE_AND_REGISTER_FUNCTION(f, name)                                              \\\n    template <typename DOCTEST_UNUSED_TEMPLATE_TYPE>                                               \\\n    static inline void f()\n\n// for registering tests\n#define DOCTEST_TEST_CASE(name)                                                                    \\\n    DOCTEST_CREATE_AND_REGISTER_FUNCTION(DOCTEST_ANONYMOUS(_DOCTEST_ANON_FUNC_), name)\n\n// for registering tests in classes\n#define DOCTEST_TEST_CASE_CLASS(name)                                                              \\\n    DOCTEST_CREATE_AND_REGISTER_FUNCTION(DOCTEST_ANONYMOUS(_DOCTEST_ANON_FUNC_), name)\n\n// for registering tests with a fixture\n#define DOCTEST_TEST_CASE_FIXTURE(x, name)                                                         \\\n    DOCTEST_IMPLEMENT_FIXTURE(DOCTEST_ANONYMOUS(_DOCTEST_ANON_CLASS_), x,                          \\\n                              DOCTEST_ANONYMOUS(_DOCTEST_ANON_FUNC_), name)\n\n// for converting types to strings without the <typeinfo> header and demangling\n#define DOCTEST_TYPE_TO_STRING(...) typedef int DOCTEST_ANONYMOUS(_DOCTEST_ANON_FOR_SEMICOLON_)\n#define DOCTEST_TYPE_TO_STRING_IMPL(...)\n\n// for typed tests\n#define DOCTEST_TEST_CASE_TEMPLATE(name, type, ...)                                                \\\n    template <typename type>                                                                       \\\n    inline void DOCTEST_ANONYMOUS(_DOCTEST_ANON_TMP_)()\n\n#define DOCTEST_TEST_CASE_TEMPLATE_DEFINE(name, type, id)                                          \\\n    template <typename type>                                                                       \\\n    inline void DOCTEST_ANONYMOUS(_DOCTEST_ANON_TMP_)()\n\n#define DOCTEST_TEST_CASE_TEMPLATE_INVOKE(id, ...)                                                 \\\n    typedef int DOCTEST_ANONYMOUS(_DOCTEST_ANON_FOR_SEMICOLON_)\n\n#define DOCTEST_TEST_CASE_TEMPLATE_APPLY(id, ...)                                                  \\\n    typedef int DOCTEST_ANONYMOUS(_DOCTEST_ANON_FOR_SEMICOLON_)\n\n// for subcases\n#define DOCTEST_SUBCASE(name)\n\n// for a testsuite block\n#define DOCTEST_TEST_SUITE(name) namespace\n\n// for starting a testsuite block\n#define DOCTEST_TEST_SUITE_BEGIN(name) typedef int DOCTEST_ANONYMOUS(_DOCTEST_ANON_FOR_SEMICOLON_)\n\n// for ending a testsuite block\n#define DOCTEST_TEST_SUITE_END typedef int DOCTEST_ANONYMOUS(_DOCTEST_ANON_FOR_SEMICOLON_)\n\n#define DOCTEST_REGISTER_EXCEPTION_TRANSLATOR(signature)                                           \\\n    template <typename DOCTEST_UNUSED_TEMPLATE_TYPE>                                               \\\n    static inline doctest::String DOCTEST_ANONYMOUS(_DOCTEST_ANON_TRANSLATOR_)(signature)\n\n#define DOCTEST_REGISTER_REPORTER(name, priority, reporter)\n#define DOCTEST_REGISTER_LISTENER(name, priority, reporter)\n\n#define DOCTEST_INFO(...) (static_cast<void>(0))\n#define DOCTEST_CAPTURE(x) (static_cast<void>(0))\n#define DOCTEST_ADD_MESSAGE_AT(file, line, ...) (static_cast<void>(0))\n#define DOCTEST_ADD_FAIL_CHECK_AT(file, line, ...) (static_cast<void>(0))\n#define DOCTEST_ADD_FAIL_AT(file, line, ...) (static_cast<void>(0))\n#define DOCTEST_MESSAGE(...) (static_cast<void>(0))\n#define DOCTEST_FAIL_CHECK(...) (static_cast<void>(0))\n#define DOCTEST_FAIL(...) (static_cast<void>(0))\n\n#define DOCTEST_WARN(...) (static_cast<void>(0))\n#define DOCTEST_CHECK(...) (static_cast<void>(0))\n#define DOCTEST_REQUIRE(...) (static_cast<void>(0))\n#define DOCTEST_WARN_FALSE(...) (static_cast<void>(0))\n#define DOCTEST_CHECK_FALSE(...) (static_cast<void>(0))\n#define DOCTEST_REQUIRE_FALSE(...) (static_cast<void>(0))\n\n#define DOCTEST_WARN_MESSAGE(cond, ...) (static_cast<void>(0))\n#define DOCTEST_CHECK_MESSAGE(cond, ...) (static_cast<void>(0))\n#define DOCTEST_REQUIRE_MESSAGE(cond, ...) (static_cast<void>(0))\n#define DOCTEST_WARN_FALSE_MESSAGE(cond, ...) (static_cast<void>(0))\n#define DOCTEST_CHECK_FALSE_MESSAGE(cond, ...) (static_cast<void>(0))\n#define DOCTEST_REQUIRE_FALSE_MESSAGE(cond, ...) (static_cast<void>(0))\n\n#define DOCTEST_WARN_THROWS(...) (static_cast<void>(0))\n#define DOCTEST_CHECK_THROWS(...) (static_cast<void>(0))\n#define DOCTEST_REQUIRE_THROWS(...) (static_cast<void>(0))\n#define DOCTEST_WARN_THROWS_AS(expr, ...) (static_cast<void>(0))\n#define DOCTEST_CHECK_THROWS_AS(expr, ...) (static_cast<void>(0))\n#define DOCTEST_REQUIRE_THROWS_AS(expr, ...) (static_cast<void>(0))\n#define DOCTEST_WARN_THROWS_WITH(expr, ...) (static_cast<void>(0))\n#define DOCTEST_CHECK_THROWS_WITH(expr, ...) (static_cast<void>(0))\n#define DOCTEST_REQUIRE_THROWS_WITH(expr, ...) (static_cast<void>(0))\n#define DOCTEST_WARN_THROWS_WITH_AS(expr, with, ...) (static_cast<void>(0))\n#define DOCTEST_CHECK_THROWS_WITH_AS(expr, with, ...) (static_cast<void>(0))\n#define DOCTEST_REQUIRE_THROWS_WITH_AS(expr, with, ...) (static_cast<void>(0))\n#define DOCTEST_WARN_NOTHROW(...) (static_cast<void>(0))\n#define DOCTEST_CHECK_NOTHROW(...) (static_cast<void>(0))\n#define DOCTEST_REQUIRE_NOTHROW(...) (static_cast<void>(0))\n\n#define DOCTEST_WARN_THROWS_MESSAGE(expr, ...) (static_cast<void>(0))\n#define DOCTEST_CHECK_THROWS_MESSAGE(expr, ...) (static_cast<void>(0))\n#define DOCTEST_REQUIRE_THROWS_MESSAGE(expr, ...) (static_cast<void>(0))\n#define DOCTEST_WARN_THROWS_AS_MESSAGE(expr, ex, ...) (static_cast<void>(0))\n#define DOCTEST_CHECK_THROWS_AS_MESSAGE(expr, ex, ...) (static_cast<void>(0))\n#define DOCTEST_REQUIRE_THROWS_AS_MESSAGE(expr, ex, ...) (static_cast<void>(0))\n#define DOCTEST_WARN_THROWS_WITH_MESSAGE(expr, with, ...) (static_cast<void>(0))\n#define DOCTEST_CHECK_THROWS_WITH_MESSAGE(expr, with, ...) (static_cast<void>(0))\n#define DOCTEST_REQUIRE_THROWS_WITH_MESSAGE(expr, with, ...) (static_cast<void>(0))\n#define DOCTEST_WARN_THROWS_WITH_AS_MESSAGE(expr, with, ex, ...) (static_cast<void>(0))\n#define DOCTEST_CHECK_THROWS_WITH_AS_MESSAGE(expr, with, ex, ...) (static_cast<void>(0))\n#define DOCTEST_REQUIRE_THROWS_WITH_AS_MESSAGE(expr, with, ex, ...) (static_cast<void>(0))\n#define DOCTEST_WARN_NOTHROW_MESSAGE(expr, ...) (static_cast<void>(0))\n#define DOCTEST_CHECK_NOTHROW_MESSAGE(expr, ...) (static_cast<void>(0))\n#define DOCTEST_REQUIRE_NOTHROW_MESSAGE(expr, ...) (static_cast<void>(0))\n\n#define DOCTEST_WARN_EQ(...) (static_cast<void>(0))\n#define DOCTEST_CHECK_EQ(...) (static_cast<void>(0))\n#define DOCTEST_REQUIRE_EQ(...) (static_cast<void>(0))\n#define DOCTEST_WARN_NE(...) (static_cast<void>(0))\n#define DOCTEST_CHECK_NE(...) (static_cast<void>(0))\n#define DOCTEST_REQUIRE_NE(...) (static_cast<void>(0))\n#define DOCTEST_WARN_GT(...) (static_cast<void>(0))\n#define DOCTEST_CHECK_GT(...) (static_cast<void>(0))\n#define DOCTEST_REQUIRE_GT(...) (static_cast<void>(0))\n#define DOCTEST_WARN_LT(...) (static_cast<void>(0))\n#define DOCTEST_CHECK_LT(...) (static_cast<void>(0))\n#define DOCTEST_REQUIRE_LT(...) (static_cast<void>(0))\n#define DOCTEST_WARN_GE(...) (static_cast<void>(0))\n#define DOCTEST_CHECK_GE(...) (static_cast<void>(0))\n#define DOCTEST_REQUIRE_GE(...) (static_cast<void>(0))\n#define DOCTEST_WARN_LE(...) (static_cast<void>(0))\n#define DOCTEST_CHECK_LE(...) (static_cast<void>(0))\n#define DOCTEST_REQUIRE_LE(...) (static_cast<void>(0))\n\n#define DOCTEST_WARN_UNARY(...) (static_cast<void>(0))\n#define DOCTEST_CHECK_UNARY(...) (static_cast<void>(0))\n#define DOCTEST_REQUIRE_UNARY(...) (static_cast<void>(0))\n#define DOCTEST_WARN_UNARY_FALSE(...) (static_cast<void>(0))\n#define DOCTEST_CHECK_UNARY_FALSE(...) (static_cast<void>(0))\n#define DOCTEST_REQUIRE_UNARY_FALSE(...) (static_cast<void>(0))\n\n#endif // DOCTEST_CONFIG_DISABLE\n\n// clang-format off\n// KEPT FOR BACKWARDS COMPATIBILITY - FORWARDING TO THE RIGHT MACROS\n#define DOCTEST_FAST_WARN_EQ             DOCTEST_WARN_EQ\n#define DOCTEST_FAST_CHECK_EQ            DOCTEST_CHECK_EQ\n#define DOCTEST_FAST_REQUIRE_EQ          DOCTEST_REQUIRE_EQ\n#define DOCTEST_FAST_WARN_NE             DOCTEST_WARN_NE\n#define DOCTEST_FAST_CHECK_NE            DOCTEST_CHECK_NE\n#define DOCTEST_FAST_REQUIRE_NE          DOCTEST_REQUIRE_NE\n#define DOCTEST_FAST_WARN_GT             DOCTEST_WARN_GT\n#define DOCTEST_FAST_CHECK_GT            DOCTEST_CHECK_GT\n#define DOCTEST_FAST_REQUIRE_GT          DOCTEST_REQUIRE_GT\n#define DOCTEST_FAST_WARN_LT             DOCTEST_WARN_LT\n#define DOCTEST_FAST_CHECK_LT            DOCTEST_CHECK_LT\n#define DOCTEST_FAST_REQUIRE_LT          DOCTEST_REQUIRE_LT\n#define DOCTEST_FAST_WARN_GE             DOCTEST_WARN_GE\n#define DOCTEST_FAST_CHECK_GE            DOCTEST_CHECK_GE\n#define DOCTEST_FAST_REQUIRE_GE          DOCTEST_REQUIRE_GE\n#define DOCTEST_FAST_WARN_LE             DOCTEST_WARN_LE\n#define DOCTEST_FAST_CHECK_LE            DOCTEST_CHECK_LE\n#define DOCTEST_FAST_REQUIRE_LE          DOCTEST_REQUIRE_LE\n\n#define DOCTEST_FAST_WARN_UNARY          DOCTEST_WARN_UNARY\n#define DOCTEST_FAST_CHECK_UNARY         DOCTEST_CHECK_UNARY\n#define DOCTEST_FAST_REQUIRE_UNARY       DOCTEST_REQUIRE_UNARY\n#define DOCTEST_FAST_WARN_UNARY_FALSE    DOCTEST_WARN_UNARY_FALSE\n#define DOCTEST_FAST_CHECK_UNARY_FALSE   DOCTEST_CHECK_UNARY_FALSE\n#define DOCTEST_FAST_REQUIRE_UNARY_FALSE DOCTEST_REQUIRE_UNARY_FALSE\n\n#define DOCTEST_TEST_CASE_TEMPLATE_INSTANTIATE(id, ...) DOCTEST_TEST_CASE_TEMPLATE_INVOKE(id,__VA_ARGS__)\n// clang-format on\n\n// BDD style macros\n// clang-format off\n#define DOCTEST_SCENARIO(name) DOCTEST_TEST_CASE(\"  Scenario: \" name)\n#define DOCTEST_SCENARIO_CLASS(name) DOCTEST_TEST_CASE_CLASS(\"  Scenario: \" name)\n#define DOCTEST_SCENARIO_TEMPLATE(name, T, ...)  DOCTEST_TEST_CASE_TEMPLATE(\"  Scenario: \" name, T, __VA_ARGS__)\n#define DOCTEST_SCENARIO_TEMPLATE_DEFINE(name, T, id) DOCTEST_TEST_CASE_TEMPLATE_DEFINE(\"  Scenario: \" name, T, id)\n\n#define DOCTEST_GIVEN(name)     DOCTEST_SUBCASE(\"   Given: \" name)\n#define DOCTEST_WHEN(name)      DOCTEST_SUBCASE(\"    When: \" name)\n#define DOCTEST_AND_WHEN(name)  DOCTEST_SUBCASE(\"And when: \" name)\n#define DOCTEST_THEN(name)      DOCTEST_SUBCASE(\"    Then: \" name)\n#define DOCTEST_AND_THEN(name)  DOCTEST_SUBCASE(\"     And: \" name)\n// clang-format on\n\n// == SHORT VERSIONS OF THE MACROS\n#if !defined(DOCTEST_CONFIG_NO_SHORT_MACRO_NAMES)\n\n#define TEST_CASE(name) DOCTEST_TEST_CASE(name)\n#define TEST_CASE_CLASS(name) DOCTEST_TEST_CASE_CLASS(name)\n#define TEST_CASE_FIXTURE(x, name) DOCTEST_TEST_CASE_FIXTURE(x, name)\n#define TYPE_TO_STRING(...) DOCTEST_TYPE_TO_STRING(__VA_ARGS__)\n#define TEST_CASE_TEMPLATE(name, T, ...) DOCTEST_TEST_CASE_TEMPLATE(name, T, __VA_ARGS__)\n#define TEST_CASE_TEMPLATE_DEFINE(name, T, id) DOCTEST_TEST_CASE_TEMPLATE_DEFINE(name, T, id)\n#define TEST_CASE_TEMPLATE_INVOKE(id, ...) DOCTEST_TEST_CASE_TEMPLATE_INVOKE(id, __VA_ARGS__)\n#define TEST_CASE_TEMPLATE_APPLY(id, ...) DOCTEST_TEST_CASE_TEMPLATE_APPLY(id, __VA_ARGS__)\n#define SUBCASE(name) DOCTEST_SUBCASE(name)\n#define TEST_SUITE(decorators) DOCTEST_TEST_SUITE(decorators)\n#define TEST_SUITE_BEGIN(name) DOCTEST_TEST_SUITE_BEGIN(name)\n#define TEST_SUITE_END DOCTEST_TEST_SUITE_END\n#define REGISTER_EXCEPTION_TRANSLATOR(signature) DOCTEST_REGISTER_EXCEPTION_TRANSLATOR(signature)\n#define REGISTER_REPORTER(name, priority, reporter) DOCTEST_REGISTER_REPORTER(name, priority, reporter)\n#define REGISTER_LISTENER(name, priority, reporter) DOCTEST_REGISTER_LISTENER(name, priority, reporter)\n#define INFO(...) DOCTEST_INFO(__VA_ARGS__)\n#define CAPTURE(x) DOCTEST_CAPTURE(x)\n#define ADD_MESSAGE_AT(file, line, ...) DOCTEST_ADD_MESSAGE_AT(file, line, __VA_ARGS__)\n#define ADD_FAIL_CHECK_AT(file, line, ...) DOCTEST_ADD_FAIL_CHECK_AT(file, line, __VA_ARGS__)\n#define ADD_FAIL_AT(file, line, ...) DOCTEST_ADD_FAIL_AT(file, line, __VA_ARGS__)\n#define MESSAGE(...) DOCTEST_MESSAGE(__VA_ARGS__)\n#define FAIL_CHECK(...) DOCTEST_FAIL_CHECK(__VA_ARGS__)\n#define FAIL(...) DOCTEST_FAIL(__VA_ARGS__)\n#define TO_LVALUE(...) DOCTEST_TO_LVALUE(__VA_ARGS__)\n\n#define WARN(...) DOCTEST_WARN(__VA_ARGS__)\n#define WARN_FALSE(...) DOCTEST_WARN_FALSE(__VA_ARGS__)\n#define WARN_THROWS(...) DOCTEST_WARN_THROWS(__VA_ARGS__)\n#define WARN_THROWS_AS(expr, ...) DOCTEST_WARN_THROWS_AS(expr, __VA_ARGS__)\n#define WARN_THROWS_WITH(expr, ...) DOCTEST_WARN_THROWS_WITH(expr, __VA_ARGS__)\n#define WARN_THROWS_WITH_AS(expr, with, ...) DOCTEST_WARN_THROWS_WITH_AS(expr, with, __VA_ARGS__)\n#define WARN_NOTHROW(...) DOCTEST_WARN_NOTHROW(__VA_ARGS__)\n#define CHECK(...) DOCTEST_CHECK(__VA_ARGS__)\n#define CHECK_FALSE(...) DOCTEST_CHECK_FALSE(__VA_ARGS__)\n#define CHECK_THROWS(...) DOCTEST_CHECK_THROWS(__VA_ARGS__)\n#define CHECK_THROWS_AS(expr, ...) DOCTEST_CHECK_THROWS_AS(expr, __VA_ARGS__)\n#define CHECK_THROWS_WITH(expr, ...) DOCTEST_CHECK_THROWS_WITH(expr, __VA_ARGS__)\n#define CHECK_THROWS_WITH_AS(expr, with, ...) DOCTEST_CHECK_THROWS_WITH_AS(expr, with, __VA_ARGS__)\n#define CHECK_NOTHROW(...) DOCTEST_CHECK_NOTHROW(__VA_ARGS__)\n#define REQUIRE(...) DOCTEST_REQUIRE(__VA_ARGS__)\n#define REQUIRE_FALSE(...) DOCTEST_REQUIRE_FALSE(__VA_ARGS__)\n#define REQUIRE_THROWS(...) DOCTEST_REQUIRE_THROWS(__VA_ARGS__)\n#define REQUIRE_THROWS_AS(expr, ...) DOCTEST_REQUIRE_THROWS_AS(expr, __VA_ARGS__)\n#define REQUIRE_THROWS_WITH(expr, ...) DOCTEST_REQUIRE_THROWS_WITH(expr, __VA_ARGS__)\n#define REQUIRE_THROWS_WITH_AS(expr, with, ...) DOCTEST_REQUIRE_THROWS_WITH_AS(expr, with, __VA_ARGS__)\n#define REQUIRE_NOTHROW(...) DOCTEST_REQUIRE_NOTHROW(__VA_ARGS__)\n\n#define WARN_MESSAGE(cond, ...) DOCTEST_WARN_MESSAGE(cond, __VA_ARGS__)\n#define WARN_FALSE_MESSAGE(cond, ...) DOCTEST_WARN_FALSE_MESSAGE(cond, __VA_ARGS__)\n#define WARN_THROWS_MESSAGE(expr, ...) DOCTEST_WARN_THROWS_MESSAGE(expr, __VA_ARGS__)\n#define WARN_THROWS_AS_MESSAGE(expr, ex, ...) DOCTEST_WARN_THROWS_AS_MESSAGE(expr, ex, __VA_ARGS__)\n#define WARN_THROWS_WITH_MESSAGE(expr, with, ...) DOCTEST_WARN_THROWS_WITH_MESSAGE(expr, with, __VA_ARGS__)\n#define WARN_THROWS_WITH_AS_MESSAGE(expr, with, ex, ...) DOCTEST_WARN_THROWS_WITH_AS_MESSAGE(expr, with, ex, __VA_ARGS__)\n#define WARN_NOTHROW_MESSAGE(expr, ...) DOCTEST_WARN_NOTHROW_MESSAGE(expr, __VA_ARGS__)\n#define CHECK_MESSAGE(cond, ...) DOCTEST_CHECK_MESSAGE(cond, __VA_ARGS__)\n#define CHECK_FALSE_MESSAGE(cond, ...) DOCTEST_CHECK_FALSE_MESSAGE(cond, __VA_ARGS__)\n#define CHECK_THROWS_MESSAGE(expr, ...) DOCTEST_CHECK_THROWS_MESSAGE(expr, __VA_ARGS__)\n#define CHECK_THROWS_AS_MESSAGE(expr, ex, ...) DOCTEST_CHECK_THROWS_AS_MESSAGE(expr, ex, __VA_ARGS__)\n#define CHECK_THROWS_WITH_MESSAGE(expr, with, ...) DOCTEST_CHECK_THROWS_WITH_MESSAGE(expr, with, __VA_ARGS__)\n#define CHECK_THROWS_WITH_AS_MESSAGE(expr, with, ex, ...) DOCTEST_CHECK_THROWS_WITH_AS_MESSAGE(expr, with, ex, __VA_ARGS__)\n#define CHECK_NOTHROW_MESSAGE(expr, ...) DOCTEST_CHECK_NOTHROW_MESSAGE(expr, __VA_ARGS__)\n#define REQUIRE_MESSAGE(cond, ...) DOCTEST_REQUIRE_MESSAGE(cond, __VA_ARGS__)\n#define REQUIRE_FALSE_MESSAGE(cond, ...) DOCTEST_REQUIRE_FALSE_MESSAGE(cond, __VA_ARGS__)\n#define REQUIRE_THROWS_MESSAGE(expr, ...) DOCTEST_REQUIRE_THROWS_MESSAGE(expr, __VA_ARGS__)\n#define REQUIRE_THROWS_AS_MESSAGE(expr, ex, ...) DOCTEST_REQUIRE_THROWS_AS_MESSAGE(expr, ex, __VA_ARGS__)\n#define REQUIRE_THROWS_WITH_MESSAGE(expr, with, ...) DOCTEST_REQUIRE_THROWS_WITH_MESSAGE(expr, with, __VA_ARGS__)\n#define REQUIRE_THROWS_WITH_AS_MESSAGE(expr, with, ex, ...) DOCTEST_REQUIRE_THROWS_WITH_AS_MESSAGE(expr, with, ex, __VA_ARGS__)\n#define REQUIRE_NOTHROW_MESSAGE(expr, ...) DOCTEST_REQUIRE_NOTHROW_MESSAGE(expr, __VA_ARGS__)\n\n#define SCENARIO(name) DOCTEST_SCENARIO(name)\n#define SCENARIO_CLASS(name) DOCTEST_SCENARIO_CLASS(name)\n#define SCENARIO_TEMPLATE(name, T, ...) DOCTEST_SCENARIO_TEMPLATE(name, T, __VA_ARGS__)\n#define SCENARIO_TEMPLATE_DEFINE(name, T, id) DOCTEST_SCENARIO_TEMPLATE_DEFINE(name, T, id)\n#define GIVEN(name) DOCTEST_GIVEN(name)\n#define WHEN(name) DOCTEST_WHEN(name)\n#define AND_WHEN(name) DOCTEST_AND_WHEN(name)\n#define THEN(name) DOCTEST_THEN(name)\n#define AND_THEN(name) DOCTEST_AND_THEN(name)\n\n#define WARN_EQ(...) DOCTEST_WARN_EQ(__VA_ARGS__)\n#define CHECK_EQ(...) DOCTEST_CHECK_EQ(__VA_ARGS__)\n#define REQUIRE_EQ(...) DOCTEST_REQUIRE_EQ(__VA_ARGS__)\n#define WARN_NE(...) DOCTEST_WARN_NE(__VA_ARGS__)\n#define CHECK_NE(...) DOCTEST_CHECK_NE(__VA_ARGS__)\n#define REQUIRE_NE(...) DOCTEST_REQUIRE_NE(__VA_ARGS__)\n#define WARN_GT(...) DOCTEST_WARN_GT(__VA_ARGS__)\n#define CHECK_GT(...) DOCTEST_CHECK_GT(__VA_ARGS__)\n#define REQUIRE_GT(...) DOCTEST_REQUIRE_GT(__VA_ARGS__)\n#define WARN_LT(...) DOCTEST_WARN_LT(__VA_ARGS__)\n#define CHECK_LT(...) DOCTEST_CHECK_LT(__VA_ARGS__)\n#define REQUIRE_LT(...) DOCTEST_REQUIRE_LT(__VA_ARGS__)\n#define WARN_GE(...) DOCTEST_WARN_GE(__VA_ARGS__)\n#define CHECK_GE(...) DOCTEST_CHECK_GE(__VA_ARGS__)\n#define REQUIRE_GE(...) DOCTEST_REQUIRE_GE(__VA_ARGS__)\n#define WARN_LE(...) DOCTEST_WARN_LE(__VA_ARGS__)\n#define CHECK_LE(...) DOCTEST_CHECK_LE(__VA_ARGS__)\n#define REQUIRE_LE(...) DOCTEST_REQUIRE_LE(__VA_ARGS__)\n#define WARN_UNARY(...) DOCTEST_WARN_UNARY(__VA_ARGS__)\n#define CHECK_UNARY(...) DOCTEST_CHECK_UNARY(__VA_ARGS__)\n#define REQUIRE_UNARY(...) DOCTEST_REQUIRE_UNARY(__VA_ARGS__)\n#define WARN_UNARY_FALSE(...) DOCTEST_WARN_UNARY_FALSE(__VA_ARGS__)\n#define CHECK_UNARY_FALSE(...) DOCTEST_CHECK_UNARY_FALSE(__VA_ARGS__)\n#define REQUIRE_UNARY_FALSE(...) DOCTEST_REQUIRE_UNARY_FALSE(__VA_ARGS__)\n\n// KEPT FOR BACKWARDS COMPATIBILITY\n#define FAST_WARN_EQ(...) DOCTEST_FAST_WARN_EQ(__VA_ARGS__)\n#define FAST_CHECK_EQ(...) DOCTEST_FAST_CHECK_EQ(__VA_ARGS__)\n#define FAST_REQUIRE_EQ(...) DOCTEST_FAST_REQUIRE_EQ(__VA_ARGS__)\n#define FAST_WARN_NE(...) DOCTEST_FAST_WARN_NE(__VA_ARGS__)\n#define FAST_CHECK_NE(...) DOCTEST_FAST_CHECK_NE(__VA_ARGS__)\n#define FAST_REQUIRE_NE(...) DOCTEST_FAST_REQUIRE_NE(__VA_ARGS__)\n#define FAST_WARN_GT(...) DOCTEST_FAST_WARN_GT(__VA_ARGS__)\n#define FAST_CHECK_GT(...) DOCTEST_FAST_CHECK_GT(__VA_ARGS__)\n#define FAST_REQUIRE_GT(...) DOCTEST_FAST_REQUIRE_GT(__VA_ARGS__)\n#define FAST_WARN_LT(...) DOCTEST_FAST_WARN_LT(__VA_ARGS__)\n#define FAST_CHECK_LT(...) DOCTEST_FAST_CHECK_LT(__VA_ARGS__)\n#define FAST_REQUIRE_LT(...) DOCTEST_FAST_REQUIRE_LT(__VA_ARGS__)\n#define FAST_WARN_GE(...) DOCTEST_FAST_WARN_GE(__VA_ARGS__)\n#define FAST_CHECK_GE(...) DOCTEST_FAST_CHECK_GE(__VA_ARGS__)\n#define FAST_REQUIRE_GE(...) DOCTEST_FAST_REQUIRE_GE(__VA_ARGS__)\n#define FAST_WARN_LE(...) DOCTEST_FAST_WARN_LE(__VA_ARGS__)\n#define FAST_CHECK_LE(...) DOCTEST_FAST_CHECK_LE(__VA_ARGS__)\n#define FAST_REQUIRE_LE(...) DOCTEST_FAST_REQUIRE_LE(__VA_ARGS__)\n\n#define FAST_WARN_UNARY(...) DOCTEST_FAST_WARN_UNARY(__VA_ARGS__)\n#define FAST_CHECK_UNARY(...) DOCTEST_FAST_CHECK_UNARY(__VA_ARGS__)\n#define FAST_REQUIRE_UNARY(...) DOCTEST_FAST_REQUIRE_UNARY(__VA_ARGS__)\n#define FAST_WARN_UNARY_FALSE(...) DOCTEST_FAST_WARN_UNARY_FALSE(__VA_ARGS__)\n#define FAST_CHECK_UNARY_FALSE(...) DOCTEST_FAST_CHECK_UNARY_FALSE(__VA_ARGS__)\n#define FAST_REQUIRE_UNARY_FALSE(...) DOCTEST_FAST_REQUIRE_UNARY_FALSE(__VA_ARGS__)\n\n#define TEST_CASE_TEMPLATE_INSTANTIATE(id, ...) DOCTEST_TEST_CASE_TEMPLATE_INSTANTIATE(id, __VA_ARGS__)\n\n#endif // DOCTEST_CONFIG_NO_SHORT_MACRO_NAMES\n\n#if !defined(DOCTEST_CONFIG_DISABLE)\n\n// this is here to clear the 'current test suite' for the current translation unit - at the top\nDOCTEST_TEST_SUITE_END();\n\n// add stringification for primitive/fundamental types\nnamespace doctest { namespace detail {\n    DOCTEST_TYPE_TO_STRING_IMPL(bool)\n    DOCTEST_TYPE_TO_STRING_IMPL(float)\n    DOCTEST_TYPE_TO_STRING_IMPL(double)\n    DOCTEST_TYPE_TO_STRING_IMPL(long double)\n    DOCTEST_TYPE_TO_STRING_IMPL(char)\n    DOCTEST_TYPE_TO_STRING_IMPL(signed char)\n    DOCTEST_TYPE_TO_STRING_IMPL(unsigned char)\n#if !DOCTEST_MSVC || defined(_NATIVE_WCHAR_T_DEFINED)\n    DOCTEST_TYPE_TO_STRING_IMPL(wchar_t)\n#endif // not MSVC or wchar_t support enabled\n    DOCTEST_TYPE_TO_STRING_IMPL(short int)\n    DOCTEST_TYPE_TO_STRING_IMPL(unsigned short int)\n    DOCTEST_TYPE_TO_STRING_IMPL(int)\n    DOCTEST_TYPE_TO_STRING_IMPL(unsigned int)\n    DOCTEST_TYPE_TO_STRING_IMPL(long int)\n    DOCTEST_TYPE_TO_STRING_IMPL(unsigned long int)\n    DOCTEST_TYPE_TO_STRING_IMPL(long long int)\n    DOCTEST_TYPE_TO_STRING_IMPL(unsigned long long int)\n}} // namespace doctest::detail\n\n#endif // DOCTEST_CONFIG_DISABLE\n\nDOCTEST_CLANG_SUPPRESS_WARNING_POP\nDOCTEST_MSVC_SUPPRESS_WARNING_POP\nDOCTEST_GCC_SUPPRESS_WARNING_POP\n\n#endif // DOCTEST_LIBRARY_INCLUDED\n\n#ifndef DOCTEST_SINGLE_HEADER\n#define DOCTEST_SINGLE_HEADER\n#endif // DOCTEST_SINGLE_HEADER\n\n#if defined(DOCTEST_CONFIG_IMPLEMENT) || !defined(DOCTEST_SINGLE_HEADER)\n\n#ifndef DOCTEST_SINGLE_HEADER\n#include \"doctest_fwd.h\"\n#endif // DOCTEST_SINGLE_HEADER\n\nDOCTEST_CLANG_SUPPRESS_WARNING_WITH_PUSH(\"-Wunused-macros\")\n\n#ifndef DOCTEST_LIBRARY_IMPLEMENTATION\n#define DOCTEST_LIBRARY_IMPLEMENTATION\n\nDOCTEST_CLANG_SUPPRESS_WARNING_POP\n\nDOCTEST_CLANG_SUPPRESS_WARNING_PUSH\nDOCTEST_CLANG_SUPPRESS_WARNING(\"-Wunknown-pragmas\")\nDOCTEST_CLANG_SUPPRESS_WARNING(\"-Wpadded\")\nDOCTEST_CLANG_SUPPRESS_WARNING(\"-Wweak-vtables\")\nDOCTEST_CLANG_SUPPRESS_WARNING(\"-Wglobal-constructors\")\nDOCTEST_CLANG_SUPPRESS_WARNING(\"-Wexit-time-destructors\")\nDOCTEST_CLANG_SUPPRESS_WARNING(\"-Wmissing-prototypes\")\nDOCTEST_CLANG_SUPPRESS_WARNING(\"-Wsign-conversion\")\nDOCTEST_CLANG_SUPPRESS_WARNING(\"-Wshorten-64-to-32\")\nDOCTEST_CLANG_SUPPRESS_WARNING(\"-Wmissing-variable-declarations\")\nDOCTEST_CLANG_SUPPRESS_WARNING(\"-Wswitch\")\nDOCTEST_CLANG_SUPPRESS_WARNING(\"-Wswitch-enum\")\nDOCTEST_CLANG_SUPPRESS_WARNING(\"-Wcovered-switch-default\")\nDOCTEST_CLANG_SUPPRESS_WARNING(\"-Wmissing-noreturn\")\nDOCTEST_CLANG_SUPPRESS_WARNING(\"-Wunused-local-typedef\")\nDOCTEST_CLANG_SUPPRESS_WARNING(\"-Wdisabled-macro-expansion\")\nDOCTEST_CLANG_SUPPRESS_WARNING(\"-Wmissing-braces\")\nDOCTEST_CLANG_SUPPRESS_WARNING(\"-Wmissing-field-initializers\")\nDOCTEST_CLANG_SUPPRESS_WARNING(\"-Wc++98-compat\")\nDOCTEST_CLANG_SUPPRESS_WARNING(\"-Wc++98-compat-pedantic\")\nDOCTEST_CLANG_SUPPRESS_WARNING(\"-Wunused-member-function\")\nDOCTEST_CLANG_SUPPRESS_WARNING(\"-Wnonportable-system-include-path\")\n\nDOCTEST_GCC_SUPPRESS_WARNING_PUSH\nDOCTEST_GCC_SUPPRESS_WARNING(\"-Wunknown-pragmas\")\nDOCTEST_GCC_SUPPRESS_WARNING(\"-Wpragmas\")\nDOCTEST_GCC_SUPPRESS_WARNING(\"-Wconversion\")\nDOCTEST_GCC_SUPPRESS_WARNING(\"-Weffc++\")\nDOCTEST_GCC_SUPPRESS_WARNING(\"-Wsign-conversion\")\nDOCTEST_GCC_SUPPRESS_WARNING(\"-Wstrict-overflow\")\nDOCTEST_GCC_SUPPRESS_WARNING(\"-Wstrict-aliasing\")\nDOCTEST_GCC_SUPPRESS_WARNING(\"-Wmissing-field-initializers\")\nDOCTEST_GCC_SUPPRESS_WARNING(\"-Wmissing-braces\")\nDOCTEST_GCC_SUPPRESS_WARNING(\"-Wmissing-declarations\")\nDOCTEST_GCC_SUPPRESS_WARNING(\"-Wswitch\")\nDOCTEST_GCC_SUPPRESS_WARNING(\"-Wswitch-enum\")\nDOCTEST_GCC_SUPPRESS_WARNING(\"-Wswitch-default\")\nDOCTEST_GCC_SUPPRESS_WARNING(\"-Wunsafe-loop-optimizations\")\nDOCTEST_GCC_SUPPRESS_WARNING(\"-Wold-style-cast\")\nDOCTEST_GCC_SUPPRESS_WARNING(\"-Wunused-local-typedefs\")\nDOCTEST_GCC_SUPPRESS_WARNING(\"-Wuseless-cast\")\nDOCTEST_GCC_SUPPRESS_WARNING(\"-Wunused-function\")\nDOCTEST_GCC_SUPPRESS_WARNING(\"-Wmultiple-inheritance\")\nDOCTEST_GCC_SUPPRESS_WARNING(\"-Wnoexcept\")\nDOCTEST_GCC_SUPPRESS_WARNING(\"-Wsuggest-attribute\")\n\nDOCTEST_MSVC_SUPPRESS_WARNING_PUSH\nDOCTEST_MSVC_SUPPRESS_WARNING(4616) // invalid compiler warning\nDOCTEST_MSVC_SUPPRESS_WARNING(4619) // invalid compiler warning\nDOCTEST_MSVC_SUPPRESS_WARNING(4996) // The compiler encountered a deprecated declaration\nDOCTEST_MSVC_SUPPRESS_WARNING(4267) // 'var' : conversion from 'x' to 'y', possible loss of data\nDOCTEST_MSVC_SUPPRESS_WARNING(4706) // assignment within conditional expression\nDOCTEST_MSVC_SUPPRESS_WARNING(4512) // 'class' : assignment operator could not be generated\nDOCTEST_MSVC_SUPPRESS_WARNING(4127) // conditional expression is constant\nDOCTEST_MSVC_SUPPRESS_WARNING(4530) // C++ exception handler used, but unwind semantics not enabled\nDOCTEST_MSVC_SUPPRESS_WARNING(4577) // 'noexcept' used with no exception handling mode specified\nDOCTEST_MSVC_SUPPRESS_WARNING(4774) // format string expected in argument is not a string literal\nDOCTEST_MSVC_SUPPRESS_WARNING(4365) // conversion from 'int' to 'unsigned', signed/unsigned mismatch\nDOCTEST_MSVC_SUPPRESS_WARNING(4820) // padding in structs\nDOCTEST_MSVC_SUPPRESS_WARNING(4640) // construction of local static object is not thread-safe\nDOCTEST_MSVC_SUPPRESS_WARNING(5039) // pointer to potentially throwing function passed to extern C\nDOCTEST_MSVC_SUPPRESS_WARNING(5045) // Spectre mitigation stuff\nDOCTEST_MSVC_SUPPRESS_WARNING(4626) // assignment operator was implicitly defined as deleted\nDOCTEST_MSVC_SUPPRESS_WARNING(5027) // move assignment operator was implicitly defined as deleted\nDOCTEST_MSVC_SUPPRESS_WARNING(5026) // move constructor was implicitly defined as deleted\nDOCTEST_MSVC_SUPPRESS_WARNING(4625) // copy constructor was implicitly defined as deleted\nDOCTEST_MSVC_SUPPRESS_WARNING(4800) // forcing value to bool 'true' or 'false' (performance warning)\n// static analysis\nDOCTEST_MSVC_SUPPRESS_WARNING(26439) // This kind of function may not throw. Declare it 'noexcept'\nDOCTEST_MSVC_SUPPRESS_WARNING(26495) // Always initialize a member variable\nDOCTEST_MSVC_SUPPRESS_WARNING(26451) // Arithmetic overflow ...\nDOCTEST_MSVC_SUPPRESS_WARNING(26444) // Avoid unnamed objects with custom construction and dtor...\nDOCTEST_MSVC_SUPPRESS_WARNING(26812) // Prefer 'enum class' over 'enum'\n\nDOCTEST_MAKE_STD_HEADERS_CLEAN_FROM_WARNINGS_ON_WALL_BEGIN\n\n// required includes - will go only in one translation unit!\n#include <ctime>\n#include <cmath>\n#include <climits>\n// borland (Embarcadero) compiler requires math.h and not cmath - https://github.com/onqtam/doctest/pull/37\n#ifdef __BORLANDC__\n#include <math.h>\n#endif // __BORLANDC__\n#include <new>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <limits>\n#include <utility>\n#include <fstream>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <iomanip>\n#include <vector>\n#include <atomic>\n#include <mutex>\n#include <set>\n#include <map>\n#include <exception>\n#include <stdexcept>\n#include <csignal>\n#include <cfloat>\n#include <cctype>\n#include <cstdint>\n\n#ifdef DOCTEST_PLATFORM_MAC\n#include <sys/types.h>\n#include <unistd.h>\n#include <sys/sysctl.h>\n#endif // DOCTEST_PLATFORM_MAC\n\n#ifdef DOCTEST_PLATFORM_WINDOWS\n\n// defines for a leaner windows.h\n#ifndef WIN32_LEAN_AND_MEAN\n#define WIN32_LEAN_AND_MEAN\n#endif // WIN32_LEAN_AND_MEAN\n#ifndef NOMINMAX\n#define NOMINMAX\n#endif // NOMINMAX\n\n// not sure what AfxWin.h is for - here I do what Catch does\n#ifdef __AFXDLL\n#include <AfxWin.h>\n#else\n#include <windows.h>\n#endif\n#include <io.h>\n\n#else // DOCTEST_PLATFORM_WINDOWS\n\n#include <sys/time.h>\n#include <unistd.h>\n\n#endif // DOCTEST_PLATFORM_WINDOWS\n\n// this is a fix for https://github.com/onqtam/doctest/issues/348\n// https://mail.gnome.org/archives/xml/2012-January/msg00000.html\n#if !defined(HAVE_UNISTD_H) && !defined(STDOUT_FILENO)\n#define STDOUT_FILENO fileno(stdout)\n#endif // HAVE_UNISTD_H\n\nDOCTEST_MAKE_STD_HEADERS_CLEAN_FROM_WARNINGS_ON_WALL_END\n\n// counts the number of elements in a C array\n#define DOCTEST_COUNTOF(x) (sizeof(x) / sizeof(x[0]))\n\n#ifdef DOCTEST_CONFIG_DISABLE\n#define DOCTEST_BRANCH_ON_DISABLED(if_disabled, if_not_disabled) if_disabled\n#else // DOCTEST_CONFIG_DISABLE\n#define DOCTEST_BRANCH_ON_DISABLED(if_disabled, if_not_disabled) if_not_disabled\n#endif // DOCTEST_CONFIG_DISABLE\n\n#ifndef DOCTEST_CONFIG_OPTIONS_PREFIX\n#define DOCTEST_CONFIG_OPTIONS_PREFIX \"dt-\"\n#endif\n\n#ifndef DOCTEST_THREAD_LOCAL\n#define DOCTEST_THREAD_LOCAL thread_local\n#endif\n\n#ifndef DOCTEST_MULTI_LANE_ATOMICS_THREAD_LANES\n#define DOCTEST_MULTI_LANE_ATOMICS_THREAD_LANES 32\n#endif\n\n#ifndef DOCTEST_MULTI_LANE_ATOMICS_CACHE_LINE_SIZE\n#define DOCTEST_MULTI_LANE_ATOMICS_CACHE_LINE_SIZE 64\n#endif\n\n#ifdef DOCTEST_CONFIG_NO_UNPREFIXED_OPTIONS\n#define DOCTEST_OPTIONS_PREFIX_DISPLAY DOCTEST_CONFIG_OPTIONS_PREFIX\n#else\n#define DOCTEST_OPTIONS_PREFIX_DISPLAY \"\"\n#endif\n\nnamespace doctest {\n\nbool is_running_in_test = false;\n\nnamespace {\n    using namespace detail;\n    // case insensitive strcmp\n    int stricmp(const char* a, const char* b) {\n        for(;; a++, b++) {\n            const int d = tolower(*a) - tolower(*b);\n            if(d != 0 || !*a)\n                return d;\n        }\n    }\n\n    template <typename T>\n    String fpToString(T value, int precision) {\n        std::ostringstream oss;\n        oss << std::setprecision(precision) << std::fixed << value;\n        std::string d = oss.str();\n        size_t      i = d.find_last_not_of('0');\n        if(i != std::string::npos && i != d.size() - 1) {\n            if(d[i] == '.')\n                i++;\n            d = d.substr(0, i + 1);\n        }\n        return d.c_str();\n    }\n\n    struct Endianness\n    {\n        enum Arch\n        {\n            Big,\n            Little\n        };\n\n        static Arch which() {\n            int x = 1;\n            // casting any data pointer to char* is allowed\n            auto ptr = reinterpret_cast<char*>(&x);\n            if(*ptr)\n                return Little;\n            return Big;\n        }\n    };\n} // namespace\n\nnamespace detail {\n    void my_memcpy(void* dest, const void* src, unsigned num) { memcpy(dest, src, num); }\n\n    String rawMemoryToString(const void* object, unsigned size) {\n        // Reverse order for little endian architectures\n        int i = 0, end = static_cast<int>(size), inc = 1;\n        if(Endianness::which() == Endianness::Little) {\n            i   = end - 1;\n            end = inc = -1;\n        }\n\n        unsigned const char* bytes = static_cast<unsigned const char*>(object);\n        std::ostringstream   oss;\n        oss << \"0x\" << std::setfill('0') << std::hex;\n        for(; i != end; i += inc)\n            oss << std::setw(2) << static_cast<unsigned>(bytes[i]);\n        return oss.str().c_str();\n    }\n\n    DOCTEST_THREAD_LOCAL std::ostringstream g_oss; // NOLINT(cert-err58-cpp)\n\n    std::ostream* getTlsOss() {\n        g_oss.clear(); // there shouldn't be anything worth clearing in the flags\n        g_oss.str(\"\"); // the slow way of resetting a string stream\n        //g_oss.seekp(0); // optimal reset - as seen here: https://stackoverflow.com/a/624291/3162383\n        return &g_oss;\n    }\n\n    String getTlsOssResult() {\n        //g_oss << std::ends; // needed - as shown here: https://stackoverflow.com/a/624291/3162383\n        return g_oss.str().c_str();\n    }\n\n#ifndef DOCTEST_CONFIG_DISABLE\n\nnamespace timer_large_integer\n{\n    \n#if defined(DOCTEST_PLATFORM_WINDOWS)\n    typedef ULONGLONG type;\n#else // DOCTEST_PLATFORM_WINDOWS\n    using namespace std;\n    typedef uint64_t type;\n#endif // DOCTEST_PLATFORM_WINDOWS\n}\n\ntypedef timer_large_integer::type ticks_t;\n\n#ifdef DOCTEST_CONFIG_GETCURRENTTICKS\n    ticks_t getCurrentTicks() { return DOCTEST_CONFIG_GETCURRENTTICKS(); }\n#elif defined(DOCTEST_PLATFORM_WINDOWS)\n    ticks_t getCurrentTicks() {\n        static LARGE_INTEGER hz = {0}, hzo = {0};\n        if(!hz.QuadPart) {\n            QueryPerformanceFrequency(&hz);\n            QueryPerformanceCounter(&hzo);\n        }\n        LARGE_INTEGER t;\n        QueryPerformanceCounter(&t);\n        return ((t.QuadPart - hzo.QuadPart) * LONGLONG(1000000)) / hz.QuadPart;\n    }\n#else  // DOCTEST_PLATFORM_WINDOWS\n    ticks_t getCurrentTicks() {\n        timeval t;\n        gettimeofday(&t, nullptr);\n        return static_cast<ticks_t>(t.tv_sec) * 1000000 + static_cast<ticks_t>(t.tv_usec);\n    }\n#endif // DOCTEST_PLATFORM_WINDOWS\n\n    struct Timer\n    {\n        void         start() { m_ticks = getCurrentTicks(); }\n        unsigned int getElapsedMicroseconds() const {\n            return static_cast<unsigned int>(getCurrentTicks() - m_ticks);\n        }\n        //unsigned int getElapsedMilliseconds() const {\n        //    return static_cast<unsigned int>(getElapsedMicroseconds() / 1000);\n        //}\n        double getElapsedSeconds() const { return static_cast<double>(getCurrentTicks() - m_ticks) / 1000000.0; }\n\n    private:\n        ticks_t m_ticks = 0;\n    };\n\n#ifdef DOCTEST_CONFIG_NO_MULTI_LANE_ATOMICS\n    template <typename T>\n    using AtomicOrMultiLaneAtomic = std::atomic<T>;\n#else // DOCTEST_CONFIG_NO_MULTI_LANE_ATOMICS\n    // Provides a multilane implementation of an atomic variable that supports add, sub, load,\n    // store. Instead of using a single atomic variable, this splits up into multiple ones,\n    // each sitting on a separate cache line. The goal is to provide a speedup when most\n    // operations are modifying. It achieves this with two properties:\n    //\n    // * Multiple atomics are used, so chance of congestion from the same atomic is reduced.\n    // * Each atomic sits on a separate cache line, so false sharing is reduced.\n    //\n    // The disadvantage is that there is a small overhead due to the use of TLS, and load/store\n    // is slower because all atomics have to be accessed.\n    template <typename T>\n    class MultiLaneAtomic\n    {\n        struct CacheLineAlignedAtomic\n        {\n            std::atomic<T> atomic{};\n            char padding[DOCTEST_MULTI_LANE_ATOMICS_CACHE_LINE_SIZE - sizeof(std::atomic<T>)];\n        };\n        CacheLineAlignedAtomic m_atomics[DOCTEST_MULTI_LANE_ATOMICS_THREAD_LANES];\n\n        static_assert(sizeof(CacheLineAlignedAtomic) == DOCTEST_MULTI_LANE_ATOMICS_CACHE_LINE_SIZE,\n                      \"guarantee one atomic takes exactly one cache line\");\n\n    public:\n        T operator++() noexcept { return fetch_add(1) + 1; }\n\n        T operator++(int) noexcept { return fetch_add(1); }\n\n        T fetch_add(T arg, std::memory_order order = std::memory_order_seq_cst) noexcept {\n            return myAtomic().fetch_add(arg, order);\n        }\n\n        T fetch_sub(T arg, std::memory_order order = std::memory_order_seq_cst) noexcept {\n            return myAtomic().fetch_sub(arg, order);\n        }\n\n        operator T() const noexcept { return load(); }\n\n        T load(std::memory_order order = std::memory_order_seq_cst) const noexcept {\n            auto result = T();\n            for(auto const& c : m_atomics) {\n                result += c.atomic.load(order);\n            }\n            return result;\n        }\n\n        T operator=(T desired) noexcept {\n            store(desired);\n            return desired;\n        }\n\n        void store(T desired, std::memory_order order = std::memory_order_seq_cst) noexcept {\n            // first value becomes desired\", all others become 0.\n            for(auto& c : m_atomics) {\n                c.atomic.store(desired, order);\n                desired = {};\n            }\n        }\n\n    private:\n        // Each thread has a different atomic that it operates on. If more than NumLanes threads\n        // use this, some will use the same atomic. So performance will degrate a bit, but still\n        // everything will work.\n        //\n        // The logic here is a bit tricky. The call should be as fast as possible, so that there\n        // is minimal to no overhead in determining the correct atomic for the current thread.\n        //\n        // 1. A global static counter laneCounter counts continuously up.\n        // 2. Each successive thread will use modulo operation of that counter so it gets an atomic\n        //    assigned in a round-robin fashion.\n        // 3. This tlsLaneIdx is stored in the thread local data, so it is directly available with\n        //    little overhead.\n        std::atomic<T>& myAtomic() noexcept {\n            static std::atomic<size_t> laneCounter;\n            DOCTEST_THREAD_LOCAL size_t tlsLaneIdx =\n                    laneCounter++ % DOCTEST_MULTI_LANE_ATOMICS_THREAD_LANES;\n\n            return m_atomics[tlsLaneIdx].atomic;\n        }\n    };\n\n    template <typename T>\n    using AtomicOrMultiLaneAtomic = MultiLaneAtomic<T>;\n#endif // DOCTEST_CONFIG_NO_MULTI_LANE_ATOMICS\n\n    // this holds both parameters from the command line and runtime data for tests\n    struct ContextState : ContextOptions, TestRunStats, CurrentTestCaseStats\n    {\n        AtomicOrMultiLaneAtomic<int> numAssertsCurrentTest_atomic;\n        AtomicOrMultiLaneAtomic<int> numAssertsFailedCurrentTest_atomic;\n\n        std::vector<std::vector<String>> filters = decltype(filters)(9); // 9 different filters\n\n        std::vector<IReporter*> reporters_currently_used;\n\n        assert_handler ah = nullptr;\n\n        Timer timer;\n\n        std::vector<String> stringifiedContexts; // logging from INFO() due to an exception\n\n        // stuff for subcases\n        std::vector<SubcaseSignature>     subcasesStack;\n        std::set<decltype(subcasesStack)> subcasesPassed;\n        int                               subcasesCurrentMaxLevel;\n        bool                              should_reenter;\n        std::atomic<bool>                 shouldLogCurrentException;\n\n        void resetRunData() {\n            numTestCases                = 0;\n            numTestCasesPassingFilters  = 0;\n            numTestSuitesPassingFilters = 0;\n            numTestCasesFailed          = 0;\n            numAsserts                  = 0;\n            numAssertsFailed            = 0;\n            numAssertsCurrentTest       = 0;\n            numAssertsFailedCurrentTest = 0;\n        }\n\n        void finalizeTestCaseData() {\n            seconds = timer.getElapsedSeconds();\n\n            // update the non-atomic counters\n            numAsserts += numAssertsCurrentTest_atomic;\n            numAssertsFailed += numAssertsFailedCurrentTest_atomic;\n            numAssertsCurrentTest       = numAssertsCurrentTest_atomic;\n            numAssertsFailedCurrentTest = numAssertsFailedCurrentTest_atomic;\n\n            if(numAssertsFailedCurrentTest)\n                failure_flags |= TestCaseFailureReason::AssertFailure;\n\n            if(Approx(currentTest->m_timeout).epsilon(DBL_EPSILON) != 0 &&\n               Approx(seconds).epsilon(DBL_EPSILON) > currentTest->m_timeout)\n                failure_flags |= TestCaseFailureReason::Timeout;\n\n            if(currentTest->m_should_fail) {\n                if(failure_flags) {\n                    failure_flags |= TestCaseFailureReason::ShouldHaveFailedAndDid;\n                } else {\n                    failure_flags |= TestCaseFailureReason::ShouldHaveFailedButDidnt;\n                }\n            } else if(failure_flags && currentTest->m_may_fail) {\n                failure_flags |= TestCaseFailureReason::CouldHaveFailedAndDid;\n            } else if(currentTest->m_expected_failures > 0) {\n                if(numAssertsFailedCurrentTest == currentTest->m_expected_failures) {\n                    failure_flags |= TestCaseFailureReason::FailedExactlyNumTimes;\n                } else {\n                    failure_flags |= TestCaseFailureReason::DidntFailExactlyNumTimes;\n                }\n            }\n\n            bool ok_to_fail = (TestCaseFailureReason::ShouldHaveFailedAndDid & failure_flags) ||\n                              (TestCaseFailureReason::CouldHaveFailedAndDid & failure_flags) ||\n                              (TestCaseFailureReason::FailedExactlyNumTimes & failure_flags);\n\n            // if any subcase has failed - the whole test case has failed\n            if(failure_flags && !ok_to_fail)\n                numTestCasesFailed++;\n        }\n    };\n\n    ContextState* g_cs = nullptr;\n\n    // used to avoid locks for the debug output\n    // TODO: figure out if this is indeed necessary/correct - seems like either there still\n    // could be a race or that there wouldn't be a race even if using the context directly\n    DOCTEST_THREAD_LOCAL bool g_no_colors;\n\n#endif // DOCTEST_CONFIG_DISABLE\n} // namespace detail\n\nvoid String::setOnHeap() { *reinterpret_cast<unsigned char*>(&buf[last]) = 128; }\nvoid String::setLast(unsigned in) { buf[last] = char(in); }\n\nvoid String::copy(const String& other) {\n    using namespace std;\n    if(other.isOnStack()) {\n        memcpy(buf, other.buf, len);\n    } else {\n        setOnHeap();\n        data.size     = other.data.size;\n        data.capacity = data.size + 1;\n        data.ptr      = new char[data.capacity];\n        memcpy(data.ptr, other.data.ptr, data.size + 1);\n    }\n}\n\nString::String() {\n    buf[0] = '\\0';\n    setLast();\n}\n\nString::~String() {\n    if(!isOnStack())\n        delete[] data.ptr;\n    // NOLINTNEXTLINE(clang-analyzer-cplusplus.NewDeleteLeaks)\n}\n\nString::String(const char* in)\n        : String(in, strlen(in)) {}\n\nString::String(const char* in, unsigned in_size) {\n    using namespace std;\n    if(in_size <= last) {\n        memcpy(buf, in, in_size);\n        buf[in_size] = '\\0';\n        setLast(last - in_size);\n    } else {\n        setOnHeap();\n        data.size     = in_size;\n        data.capacity = data.size + 1;\n        data.ptr      = new char[data.capacity];\n        memcpy(data.ptr, in, in_size);\n        data.ptr[in_size] = '\\0';\n    }\n}\n\nString::String(const String& other) { copy(other); }\n\nString& String::operator=(const String& other) {\n    if(this != &other) {\n        if(!isOnStack())\n            delete[] data.ptr;\n\n        copy(other);\n    }\n\n    return *this;\n}\n\nString& String::operator+=(const String& other) {\n    const unsigned my_old_size = size();\n    const unsigned other_size  = other.size();\n    const unsigned total_size  = my_old_size + other_size;\n    using namespace std;\n    if(isOnStack()) {\n        if(total_size < len) {\n            // append to the current stack space\n            memcpy(buf + my_old_size, other.c_str(), other_size + 1);\n            // NOLINTNEXTLINE(clang-analyzer-cplusplus.NewDeleteLeaks)\n            setLast(last - total_size);\n        } else {\n            // alloc new chunk\n            char* temp = new char[total_size + 1];\n            // copy current data to new location before writing in the union\n            memcpy(temp, buf, my_old_size); // skip the +1 ('\\0') for speed\n            // update data in union\n            setOnHeap();\n            data.size     = total_size;\n            data.capacity = data.size + 1;\n            data.ptr      = temp;\n            // transfer the rest of the data\n            memcpy(data.ptr + my_old_size, other.c_str(), other_size + 1);\n        }\n    } else {\n        if(data.capacity > total_size) {\n            // append to the current heap block\n            data.size = total_size;\n            memcpy(data.ptr + my_old_size, other.c_str(), other_size + 1);\n        } else {\n            // resize\n            data.capacity *= 2;\n            if(data.capacity <= total_size)\n                data.capacity = total_size + 1;\n            // alloc new chunk\n            char* temp = new char[data.capacity];\n            // copy current data to new location before releasing it\n            memcpy(temp, data.ptr, my_old_size); // skip the +1 ('\\0') for speed\n            // release old chunk\n            delete[] data.ptr;\n            // update the rest of the union members\n            data.size = total_size;\n            data.ptr  = temp;\n            // transfer the rest of the data\n            memcpy(data.ptr + my_old_size, other.c_str(), other_size + 1);\n        }\n    }\n\n    return *this;\n}\n\n// NOLINTNEXTLINE(clang-analyzer-cplusplus.NewDeleteLeaks)\nString String::operator+(const String& other) const { return String(*this) += other; }\n\nString::String(String&& other) {\n    using namespace std;\n    memcpy(buf, other.buf, len);\n    other.buf[0] = '\\0';\n    other.setLast();\n}\n\nString& String::operator=(String&& other) {\n    using namespace std;\n    if(this != &other) {\n        if(!isOnStack())\n            delete[] data.ptr;\n        memcpy(buf, other.buf, len);\n        other.buf[0] = '\\0';\n        other.setLast();\n    }\n    return *this;\n}\n\nchar String::operator[](unsigned i) const {\n    return const_cast<String*>(this)->operator[](i); // NOLINT\n}\n\nchar& String::operator[](unsigned i) {\n    if(isOnStack())\n        return reinterpret_cast<char*>(buf)[i];\n    return data.ptr[i];\n}\n\nDOCTEST_GCC_SUPPRESS_WARNING_WITH_PUSH(\"-Wmaybe-uninitialized\")\nunsigned String::size() const {\n    if(isOnStack())\n        return last - (unsigned(buf[last]) & 31); // using \"last\" would work only if \"len\" is 32\n    return data.size;\n}\nDOCTEST_GCC_SUPPRESS_WARNING_POP\n\nunsigned String::capacity() const {\n    if(isOnStack())\n        return len;\n    return data.capacity;\n}\n\nint String::compare(const char* other, bool no_case) const {\n    if(no_case)\n        return doctest::stricmp(c_str(), other);\n    return std::strcmp(c_str(), other);\n}\n\nint String::compare(const String& other, bool no_case) const {\n    return compare(other.c_str(), no_case);\n}\n\n// clang-format off\nbool operator==(const String& lhs, const String& rhs) { return lhs.compare(rhs) == 0; }\nbool operator!=(const String& lhs, const String& rhs) { return lhs.compare(rhs) != 0; }\nbool operator< (const String& lhs, const String& rhs) { return lhs.compare(rhs) < 0; }\nbool operator> (const String& lhs, const String& rhs) { return lhs.compare(rhs) > 0; }\nbool operator<=(const String& lhs, const String& rhs) { return (lhs != rhs) ? lhs.compare(rhs) < 0 : true; }\nbool operator>=(const String& lhs, const String& rhs) { return (lhs != rhs) ? lhs.compare(rhs) > 0 : true; }\n// clang-format on\n\nstd::ostream& operator<<(std::ostream& s, const String& in) { return s << in.c_str(); }\n\nnamespace {\n    void color_to_stream(std::ostream&, Color::Enum) DOCTEST_BRANCH_ON_DISABLED({}, ;)\n} // namespace\n\nnamespace Color {\n    std::ostream& operator<<(std::ostream& s, Color::Enum code) {\n        color_to_stream(s, code);\n        return s;\n    }\n} // namespace Color\n\n// clang-format off\nconst char* assertString(assertType::Enum at) {\n    DOCTEST_MSVC_SUPPRESS_WARNING_WITH_PUSH(4062) // enum 'x' in switch of enum 'y' is not handled\n    switch(at) {  //!OCLINT missing default in switch statements\n        case assertType::DT_WARN                    : return \"WARN\";\n        case assertType::DT_CHECK                   : return \"CHECK\";\n        case assertType::DT_REQUIRE                 : return \"REQUIRE\";\n\n        case assertType::DT_WARN_FALSE              : return \"WARN_FALSE\";\n        case assertType::DT_CHECK_FALSE             : return \"CHECK_FALSE\";\n        case assertType::DT_REQUIRE_FALSE           : return \"REQUIRE_FALSE\";\n\n        case assertType::DT_WARN_THROWS             : return \"WARN_THROWS\";\n        case assertType::DT_CHECK_THROWS            : return \"CHECK_THROWS\";\n        case assertType::DT_REQUIRE_THROWS          : return \"REQUIRE_THROWS\";\n\n        case assertType::DT_WARN_THROWS_AS          : return \"WARN_THROWS_AS\";\n        case assertType::DT_CHECK_THROWS_AS         : return \"CHECK_THROWS_AS\";\n        case assertType::DT_REQUIRE_THROWS_AS       : return \"REQUIRE_THROWS_AS\";\n\n        case assertType::DT_WARN_THROWS_WITH        : return \"WARN_THROWS_WITH\";\n        case assertType::DT_CHECK_THROWS_WITH       : return \"CHECK_THROWS_WITH\";\n        case assertType::DT_REQUIRE_THROWS_WITH     : return \"REQUIRE_THROWS_WITH\";\n\n        case assertType::DT_WARN_THROWS_WITH_AS     : return \"WARN_THROWS_WITH_AS\";\n        case assertType::DT_CHECK_THROWS_WITH_AS    : return \"CHECK_THROWS_WITH_AS\";\n        case assertType::DT_REQUIRE_THROWS_WITH_AS  : return \"REQUIRE_THROWS_WITH_AS\";\n\n        case assertType::DT_WARN_NOTHROW            : return \"WARN_NOTHROW\";\n        case assertType::DT_CHECK_NOTHROW           : return \"CHECK_NOTHROW\";\n        case assertType::DT_REQUIRE_NOTHROW         : return \"REQUIRE_NOTHROW\";\n\n        case assertType::DT_WARN_EQ                 : return \"WARN_EQ\";\n        case assertType::DT_CHECK_EQ                : return \"CHECK_EQ\";\n        case assertType::DT_REQUIRE_EQ              : return \"REQUIRE_EQ\";\n        case assertType::DT_WARN_NE                 : return \"WARN_NE\";\n        case assertType::DT_CHECK_NE                : return \"CHECK_NE\";\n        case assertType::DT_REQUIRE_NE              : return \"REQUIRE_NE\";\n        case assertType::DT_WARN_GT                 : return \"WARN_GT\";\n        case assertType::DT_CHECK_GT                : return \"CHECK_GT\";\n        case assertType::DT_REQUIRE_GT              : return \"REQUIRE_GT\";\n        case assertType::DT_WARN_LT                 : return \"WARN_LT\";\n        case assertType::DT_CHECK_LT                : return \"CHECK_LT\";\n        case assertType::DT_REQUIRE_LT              : return \"REQUIRE_LT\";\n        case assertType::DT_WARN_GE                 : return \"WARN_GE\";\n        case assertType::DT_CHECK_GE                : return \"CHECK_GE\";\n        case assertType::DT_REQUIRE_GE              : return \"REQUIRE_GE\";\n        case assertType::DT_WARN_LE                 : return \"WARN_LE\";\n        case assertType::DT_CHECK_LE                : return \"CHECK_LE\";\n        case assertType::DT_REQUIRE_LE              : return \"REQUIRE_LE\";\n\n        case assertType::DT_WARN_UNARY              : return \"WARN_UNARY\";\n        case assertType::DT_CHECK_UNARY             : return \"CHECK_UNARY\";\n        case assertType::DT_REQUIRE_UNARY           : return \"REQUIRE_UNARY\";\n        case assertType::DT_WARN_UNARY_FALSE        : return \"WARN_UNARY_FALSE\";\n        case assertType::DT_CHECK_UNARY_FALSE       : return \"CHECK_UNARY_FALSE\";\n        case assertType::DT_REQUIRE_UNARY_FALSE     : return \"REQUIRE_UNARY_FALSE\";\n    }\n    DOCTEST_MSVC_SUPPRESS_WARNING_POP\n    return \"\";\n}\n// clang-format on\n\nconst char* failureString(assertType::Enum at) {\n    if(at & assertType::is_warn) //!OCLINT bitwise operator in conditional\n        return \"WARNING\";\n    if(at & assertType::is_check) //!OCLINT bitwise operator in conditional\n        return \"ERROR\";\n    if(at & assertType::is_require) //!OCLINT bitwise operator in conditional\n        return \"FATAL ERROR\";\n    return \"\";\n}\n\nDOCTEST_CLANG_SUPPRESS_WARNING_WITH_PUSH(\"-Wnull-dereference\")\nDOCTEST_GCC_SUPPRESS_WARNING_WITH_PUSH(\"-Wnull-dereference\")\n// depending on the current options this will remove the path of filenames\nconst char* skipPathFromFilename(const char* file) {\n#ifndef DOCTEST_CONFIG_DISABLE\n    if(getContextOptions()->no_path_in_filenames) {\n        auto back    = std::strrchr(file, '\\\\');\n        auto forward = std::strrchr(file, '/');\n        if(back || forward) {\n            if(back > forward)\n                forward = back;\n            return forward + 1;\n        }\n    }\n#endif // DOCTEST_CONFIG_DISABLE\n    return file;\n}\nDOCTEST_CLANG_SUPPRESS_WARNING_POP\nDOCTEST_GCC_SUPPRESS_WARNING_POP\n\nbool SubcaseSignature::operator<(const SubcaseSignature& other) const {\n    if(m_line != other.m_line)\n        return m_line < other.m_line;\n    if(std::strcmp(m_file, other.m_file) != 0)\n        return std::strcmp(m_file, other.m_file) < 0;\n    return m_name.compare(other.m_name) < 0;\n}\n\nIContextScope::IContextScope()  = default;\nIContextScope::~IContextScope() = default;\n\n#ifdef DOCTEST_CONFIG_TREAT_CHAR_STAR_AS_STRING\nString toString(char* in) { return toString(static_cast<const char*>(in)); }\n// NOLINTNEXTLINE(clang-analyzer-cplusplus.NewDeleteLeaks)\nString toString(const char* in) { return String(\"\\\"\") + (in ? in : \"{null string}\") + \"\\\"\"; }\n#endif // DOCTEST_CONFIG_TREAT_CHAR_STAR_AS_STRING\nString toString(bool in) { return in ? \"true\" : \"false\"; }\nString toString(float in) { return fpToString(in, 5) + \"f\"; }\nString toString(double in) { return fpToString(in, 10); }\nString toString(double long in) { return fpToString(in, 15); }\n\n#define DOCTEST_TO_STRING_OVERLOAD(type, fmt)                                                      \\\n    String toString(type in) {                                                                     \\\n        char buf[64];                                                                              \\\n        std::sprintf(buf, fmt, in);                                                                \\\n        return buf;                                                                                \\\n    }\n\nDOCTEST_TO_STRING_OVERLOAD(char, \"%d\")\nDOCTEST_TO_STRING_OVERLOAD(char signed, \"%d\")\nDOCTEST_TO_STRING_OVERLOAD(char unsigned, \"%u\")\nDOCTEST_TO_STRING_OVERLOAD(int short, \"%d\")\nDOCTEST_TO_STRING_OVERLOAD(int short unsigned, \"%u\")\nDOCTEST_TO_STRING_OVERLOAD(int, \"%d\")\nDOCTEST_TO_STRING_OVERLOAD(unsigned, \"%u\")\nDOCTEST_TO_STRING_OVERLOAD(int long, \"%ld\")\nDOCTEST_TO_STRING_OVERLOAD(int long unsigned, \"%lu\")\nDOCTEST_TO_STRING_OVERLOAD(int long long, \"%lld\")\nDOCTEST_TO_STRING_OVERLOAD(int long long unsigned, \"%llu\")\n\nString toString(std::nullptr_t) { return \"NULL\"; }\n\n#if DOCTEST_MSVC >= DOCTEST_COMPILER(19, 20, 0)\n// see this issue on why this is needed: https://github.com/onqtam/doctest/issues/183\nString toString(const std::string& in) { return in.c_str(); }\n#endif // VS 2019\n\nApprox::Approx(double value)\n        : m_epsilon(static_cast<double>(std::numeric_limits<float>::epsilon()) * 100)\n        , m_scale(1.0)\n        , m_value(value) {}\n\nApprox Approx::operator()(double value) const {\n    Approx approx(value);\n    approx.epsilon(m_epsilon);\n    approx.scale(m_scale);\n    return approx;\n}\n\nApprox& Approx::epsilon(double newEpsilon) {\n    m_epsilon = newEpsilon;\n    return *this;\n}\nApprox& Approx::scale(double newScale) {\n    m_scale = newScale;\n    return *this;\n}\n\nbool operator==(double lhs, const Approx& rhs) {\n    // Thanks to Richard Harris for his help refining this formula\n    return std::fabs(lhs - rhs.m_value) <\n           rhs.m_epsilon * (rhs.m_scale + std::max<double>(std::fabs(lhs), std::fabs(rhs.m_value)));\n}\nbool operator==(const Approx& lhs, double rhs) { return operator==(rhs, lhs); }\nbool operator!=(double lhs, const Approx& rhs) { return !operator==(lhs, rhs); }\nbool operator!=(const Approx& lhs, double rhs) { return !operator==(rhs, lhs); }\nbool operator<=(double lhs, const Approx& rhs) { return lhs < rhs.m_value || lhs == rhs; }\nbool operator<=(const Approx& lhs, double rhs) { return lhs.m_value < rhs || lhs == rhs; }\nbool operator>=(double lhs, const Approx& rhs) { return lhs > rhs.m_value || lhs == rhs; }\nbool operator>=(const Approx& lhs, double rhs) { return lhs.m_value > rhs || lhs == rhs; }\nbool operator<(double lhs, const Approx& rhs) { return lhs < rhs.m_value && lhs != rhs; }\nbool operator<(const Approx& lhs, double rhs) { return lhs.m_value < rhs && lhs != rhs; }\nbool operator>(double lhs, const Approx& rhs) { return lhs > rhs.m_value && lhs != rhs; }\nbool operator>(const Approx& lhs, double rhs) { return lhs.m_value > rhs && lhs != rhs; }\n\nString toString(const Approx& in) {\n    // NOLINTNEXTLINE(clang-analyzer-cplusplus.NewDeleteLeaks)\n    return String(\"Approx( \") + doctest::toString(in.m_value) + \" )\";\n}\nconst ContextOptions* getContextOptions() { return DOCTEST_BRANCH_ON_DISABLED(nullptr, g_cs); }\n\n} // namespace doctest\n\n#ifdef DOCTEST_CONFIG_DISABLE\nnamespace doctest {\nContext::Context(int, const char* const*) {}\nContext::~Context() = default;\nvoid Context::applyCommandLine(int, const char* const*) {}\nvoid Context::addFilter(const char*, const char*) {}\nvoid Context::clearFilters() {}\nvoid Context::setOption(const char*, int) {}\nvoid Context::setOption(const char*, const char*) {}\nbool Context::shouldExit() { return false; }\nvoid Context::setAsDefaultForAssertsOutOfTestCases() {}\nvoid Context::setAssertHandler(detail::assert_handler) {}\nint  Context::run() { return 0; }\n\nIReporter::~IReporter() = default;\n\nint                         IReporter::get_num_active_contexts() { return 0; }\nconst IContextScope* const* IReporter::get_active_contexts() { return nullptr; }\nint                         IReporter::get_num_stringified_contexts() { return 0; }\nconst String*               IReporter::get_stringified_contexts() { return nullptr; }\n\nint registerReporter(const char*, int, IReporter*) { return 0; }\n\n} // namespace doctest\n#else // DOCTEST_CONFIG_DISABLE\n\n#if !defined(DOCTEST_CONFIG_COLORS_NONE)\n#if !defined(DOCTEST_CONFIG_COLORS_WINDOWS) && !defined(DOCTEST_CONFIG_COLORS_ANSI)\n#ifdef DOCTEST_PLATFORM_WINDOWS\n#define DOCTEST_CONFIG_COLORS_WINDOWS\n#else // linux\n#define DOCTEST_CONFIG_COLORS_ANSI\n#endif // platform\n#endif // DOCTEST_CONFIG_COLORS_WINDOWS && DOCTEST_CONFIG_COLORS_ANSI\n#endif // DOCTEST_CONFIG_COLORS_NONE\n\nnamespace doctest_detail_test_suite_ns {\n// holds the current test suite\ndoctest::detail::TestSuite& getCurrentTestSuite() {\n    static doctest::detail::TestSuite data;\n    return data;\n}\n} // namespace doctest_detail_test_suite_ns\n\nnamespace doctest {\nnamespace {\n    // the int (priority) is part of the key for automatic sorting - sadly one can register a\n    // reporter with a duplicate name and a different priority but hopefully that won't happen often :|\n    typedef std::map<std::pair<int, String>, reporterCreatorFunc> reporterMap;\n\n    reporterMap& getReporters() {\n        static reporterMap data;\n        return data;\n    }\n    reporterMap& getListeners() {\n        static reporterMap data;\n        return data;\n    }\n} // namespace\nnamespace detail {\n#define DOCTEST_ITERATE_THROUGH_REPORTERS(function, ...)                                           \\\n    for(auto& curr_rep : g_cs->reporters_currently_used)                                           \\\n    curr_rep->function(__VA_ARGS__)\n\n    bool checkIfShouldThrow(assertType::Enum at) {\n        if(at & assertType::is_require) //!OCLINT bitwise operator in conditional\n            return true;\n\n        if((at & assertType::is_check) //!OCLINT bitwise operator in conditional\n           && getContextOptions()->abort_after > 0 &&\n           (g_cs->numAssertsFailed + g_cs->numAssertsFailedCurrentTest_atomic) >=\n                   getContextOptions()->abort_after)\n            return true;\n\n        return false;\n    }\n\n#ifndef DOCTEST_CONFIG_NO_EXCEPTIONS\n    DOCTEST_NORETURN void throwException() {\n        g_cs->shouldLogCurrentException = false;\n        throw TestFailureException();\n    } // NOLINT(cert-err60-cpp)\n#else // DOCTEST_CONFIG_NO_EXCEPTIONS\n    void throwException() {}\n#endif // DOCTEST_CONFIG_NO_EXCEPTIONS\n} // namespace detail\n\nnamespace {\n    using namespace detail;\n    // matching of a string against a wildcard mask (case sensitivity configurable) taken from\n    // https://www.codeproject.com/Articles/1088/Wildcard-string-compare-globbing\n    int wildcmp(const char* str, const char* wild, bool caseSensitive) {\n        const char* cp = str;\n        const char* mp = wild;\n\n        while((*str) && (*wild != '*')) {\n            if((caseSensitive ? (*wild != *str) : (tolower(*wild) != tolower(*str))) &&\n               (*wild != '?')) {\n                return 0;\n            }\n            wild++;\n            str++;\n        }\n\n        while(*str) {\n            if(*wild == '*') {\n                if(!*++wild) {\n                    return 1;\n                }\n                mp = wild;\n                cp = str + 1;\n            } else if((caseSensitive ? (*wild == *str) : (tolower(*wild) == tolower(*str))) ||\n                      (*wild == '?')) {\n                wild++;\n                str++;\n            } else {\n                wild = mp;   //!OCLINT parameter reassignment\n                str  = cp++; //!OCLINT parameter reassignment\n            }\n        }\n\n        while(*wild == '*') {\n            wild++;\n        }\n        return !*wild;\n    }\n\n    //// C string hash function (djb2) - taken from http://www.cse.yorku.ca/~oz/hash.html\n    //unsigned hashStr(unsigned const char* str) {\n    //    unsigned long hash = 5381;\n    //    char          c;\n    //    while((c = *str++))\n    //        hash = ((hash << 5) + hash) + c; // hash * 33 + c\n    //    return hash;\n    //}\n\n    // checks if the name matches any of the filters (and can be configured what to do when empty)\n    bool matchesAny(const char* name, const std::vector<String>& filters, bool matchEmpty,\n                    bool caseSensitive) {\n        if(filters.empty() && matchEmpty)\n            return true;\n        for(auto& curr : filters)\n            if(wildcmp(name, curr.c_str(), caseSensitive))\n                return true;\n        return false;\n    }\n} // namespace\nnamespace detail {\n\n    Subcase::Subcase(const String& name, const char* file, int line)\n            : m_signature({name, file, line}) {\n        auto* s = g_cs;\n\n        // check subcase filters\n        if(s->subcasesStack.size() < size_t(s->subcase_filter_levels)) {\n            if(!matchesAny(m_signature.m_name.c_str(), s->filters[6], true, s->case_sensitive))\n                return;\n            if(matchesAny(m_signature.m_name.c_str(), s->filters[7], false, s->case_sensitive))\n                return;\n        }\n        \n        // if a Subcase on the same level has already been entered\n        if(s->subcasesStack.size() < size_t(s->subcasesCurrentMaxLevel)) {\n            s->should_reenter = true;\n            return;\n        }\n\n        // push the current signature to the stack so we can check if the\n        // current stack + the current new subcase have been traversed\n        s->subcasesStack.push_back(m_signature);\n        if(s->subcasesPassed.count(s->subcasesStack) != 0) {\n            // pop - revert to previous stack since we've already passed this\n            s->subcasesStack.pop_back();\n            return;\n        }\n\n        s->subcasesCurrentMaxLevel = s->subcasesStack.size();\n        m_entered = true;\n\n        DOCTEST_ITERATE_THROUGH_REPORTERS(subcase_start, m_signature);\n    }\n\n    DOCTEST_MSVC_SUPPRESS_WARNING_WITH_PUSH(4996) // std::uncaught_exception is deprecated in C++17\t\n    DOCTEST_GCC_SUPPRESS_WARNING_WITH_PUSH(\"-Wdeprecated-declarations\")\t\n    DOCTEST_CLANG_SUPPRESS_WARNING_WITH_PUSH(\"-Wdeprecated-declarations\")\n\n    Subcase::~Subcase() {\n        if(m_entered) {\n            // only mark the subcase stack as passed if no subcases have been skipped\n            if(g_cs->should_reenter == false)\n                g_cs->subcasesPassed.insert(g_cs->subcasesStack);\n            g_cs->subcasesStack.pop_back();\n\n#if defined(__cpp_lib_uncaught_exceptions) && __cpp_lib_uncaught_exceptions >= 201411L\n            if(std::uncaught_exceptions() > 0\n#else\n            if(std::uncaught_exception()\n#endif\n            && g_cs->shouldLogCurrentException) {\n                DOCTEST_ITERATE_THROUGH_REPORTERS(\n                        test_case_exception, {\"exception thrown in subcase - will translate later \"\n                                              \"when the whole test case has been exited (cannot \"\n                                              \"translate while there is an active exception)\",\n                                              false});\n                g_cs->shouldLogCurrentException = false;\n            }\n            DOCTEST_ITERATE_THROUGH_REPORTERS(subcase_end, DOCTEST_EMPTY);\n        }\n    }\n\n    DOCTEST_CLANG_SUPPRESS_WARNING_POP\t\n    DOCTEST_GCC_SUPPRESS_WARNING_POP\t\n    DOCTEST_MSVC_SUPPRESS_WARNING_POP\n\n    Subcase::operator bool() const { return m_entered; }\n\n    Result::Result(bool passed, const String& decomposition)\n            : m_passed(passed)\n            , m_decomp(decomposition) {}\n\n    ExpressionDecomposer::ExpressionDecomposer(assertType::Enum at)\n            : m_at(at) {}\n\n    TestSuite& TestSuite::operator*(const char* in) {\n        m_test_suite = in;\n        // clear state\n        m_description       = nullptr;\n        m_skip              = false;\n        m_no_breaks         = false;\n        m_no_output         = false;\n        m_may_fail          = false;\n        m_should_fail       = false;\n        m_expected_failures = 0;\n        m_timeout           = 0;\n        return *this;\n    }\n\n    TestCase::TestCase(funcType test, const char* file, unsigned line, const TestSuite& test_suite,\n                       const char* type, int template_id) {\n        m_file              = file;\n        m_line              = line;\n        m_name              = nullptr; // will be later overridden in operator*\n        m_test_suite        = test_suite.m_test_suite;\n        m_description       = test_suite.m_description;\n        m_skip              = test_suite.m_skip;\n        m_no_breaks         = test_suite.m_no_breaks;\n        m_no_output         = test_suite.m_no_output;\n        m_may_fail          = test_suite.m_may_fail;\n        m_should_fail       = test_suite.m_should_fail;\n        m_expected_failures = test_suite.m_expected_failures;\n        m_timeout           = test_suite.m_timeout;\n\n        m_test        = test;\n        m_type        = type;\n        m_template_id = template_id;\n    }\n\n    TestCase::TestCase(const TestCase& other)\n            : TestCaseData() {\n        *this = other;\n    }\n\n    DOCTEST_MSVC_SUPPRESS_WARNING_WITH_PUSH(26434) // hides a non-virtual function\n    DOCTEST_MSVC_SUPPRESS_WARNING(26437)           // Do not slice\n    TestCase& TestCase::operator=(const TestCase& other) {\n        static_cast<TestCaseData&>(*this) = static_cast<const TestCaseData&>(other);\n\n        m_test        = other.m_test;\n        m_type        = other.m_type;\n        m_template_id = other.m_template_id;\n        m_full_name   = other.m_full_name;\n\n        if(m_template_id != -1)\n            m_name = m_full_name.c_str();\n        return *this;\n    }\n    DOCTEST_MSVC_SUPPRESS_WARNING_POP\n\n    TestCase& TestCase::operator*(const char* in) {\n        m_name = in;\n        // make a new name with an appended type for templated test case\n        if(m_template_id != -1) {\n            m_full_name = String(m_name) + m_type;\n            // redirect the name to point to the newly constructed full name\n            m_name = m_full_name.c_str();\n        }\n        return *this;\n    }\n\n    bool TestCase::operator<(const TestCase& other) const {\n        // this will be used only to differentiate between test cases - not relevant for sorting\n        if(m_line != other.m_line)\n            return m_line < other.m_line;\n        const int name_cmp = strcmp(m_name, other.m_name);\n        if(name_cmp != 0)\n            return name_cmp < 0;\n        const int file_cmp = m_file.compare(other.m_file);\n        if(file_cmp != 0)\n            return file_cmp < 0;\n        return m_template_id < other.m_template_id;\n    }\n} // namespace detail\nnamespace {\n    using namespace detail;\n    // for sorting tests by file/line\n    bool fileOrderComparator(const TestCase* lhs, const TestCase* rhs) {\n        // this is needed because MSVC gives different case for drive letters\n        // for __FILE__ when evaluated in a header and a source file\n        const int res = lhs->m_file.compare(rhs->m_file, bool(DOCTEST_MSVC));\n        if(res != 0)\n            return res < 0;\n        if(lhs->m_line != rhs->m_line)\n            return lhs->m_line < rhs->m_line;\n        return lhs->m_template_id < rhs->m_template_id;\n    }\n\n    // for sorting tests by suite/file/line\n    bool suiteOrderComparator(const TestCase* lhs, const TestCase* rhs) {\n        const int res = std::strcmp(lhs->m_test_suite, rhs->m_test_suite);\n        if(res != 0)\n            return res < 0;\n        return fileOrderComparator(lhs, rhs);\n    }\n\n    // for sorting tests by name/suite/file/line\n    bool nameOrderComparator(const TestCase* lhs, const TestCase* rhs) {\n        const int res = std::strcmp(lhs->m_name, rhs->m_name);\n        if(res != 0)\n            return res < 0;\n        return suiteOrderComparator(lhs, rhs);\n    }\n\n    // all the registered tests\n    std::set<TestCase>& getRegisteredTests() {\n        static std::set<TestCase> data;\n        return data;\n    }\n\n#ifdef DOCTEST_CONFIG_COLORS_WINDOWS\n    HANDLE g_stdoutHandle;\n    WORD   g_origFgAttrs;\n    WORD   g_origBgAttrs;\n    bool   g_attrsInitted = false;\n\n    int colors_init() {\n        if(!g_attrsInitted) {\n            g_stdoutHandle = GetStdHandle(STD_OUTPUT_HANDLE);\n            g_attrsInitted = true;\n            CONSOLE_SCREEN_BUFFER_INFO csbiInfo;\n            GetConsoleScreenBufferInfo(g_stdoutHandle, &csbiInfo);\n            g_origFgAttrs = csbiInfo.wAttributes & ~(BACKGROUND_GREEN | BACKGROUND_RED |\n                                                     BACKGROUND_BLUE | BACKGROUND_INTENSITY);\n            g_origBgAttrs = csbiInfo.wAttributes & ~(FOREGROUND_GREEN | FOREGROUND_RED |\n                                                     FOREGROUND_BLUE | FOREGROUND_INTENSITY);\n        }\n        return 0;\n    }\n\n    int dumy_init_console_colors = colors_init();\n#endif // DOCTEST_CONFIG_COLORS_WINDOWS\n\n    DOCTEST_CLANG_SUPPRESS_WARNING_WITH_PUSH(\"-Wdeprecated-declarations\")\n    void color_to_stream(std::ostream& s, Color::Enum code) {\n        static_cast<void>(s);    // for DOCTEST_CONFIG_COLORS_NONE or DOCTEST_CONFIG_COLORS_WINDOWS\n        static_cast<void>(code); // for DOCTEST_CONFIG_COLORS_NONE\n#ifdef DOCTEST_CONFIG_COLORS_ANSI\n        if(g_no_colors ||\n           (isatty(STDOUT_FILENO) == false && getContextOptions()->force_colors == false))\n            return;\n\n        auto col = \"\";\n        // clang-format off\n            switch(code) { //!OCLINT missing break in switch statement / unnecessary default statement in covered switch statement\n                case Color::Red:         col = \"[0;31m\"; break;\n                case Color::Green:       col = \"[0;32m\"; break;\n                case Color::Blue:        col = \"[0;34m\"; break;\n                case Color::Cyan:        col = \"[0;36m\"; break;\n                case Color::Yellow:      col = \"[0;33m\"; break;\n                case Color::Grey:        col = \"[1;30m\"; break;\n                case Color::LightGrey:   col = \"[0;37m\"; break;\n                case Color::BrightRed:   col = \"[1;31m\"; break;\n                case Color::BrightGreen: col = \"[1;32m\"; break;\n                case Color::BrightWhite: col = \"[1;37m\"; break;\n                case Color::Bright: // invalid\n                case Color::None:\n                case Color::White:\n                default:                 col = \"[0m\";\n            }\n        // clang-format on\n        s << \"\\033\" << col;\n#endif // DOCTEST_CONFIG_COLORS_ANSI\n\n#ifdef DOCTEST_CONFIG_COLORS_WINDOWS\n        if(g_no_colors ||\n           (isatty(fileno(stdout)) == false && getContextOptions()->force_colors == false))\n            return;\n\n#define DOCTEST_SET_ATTR(x) SetConsoleTextAttribute(g_stdoutHandle, x | g_origBgAttrs)\n\n        // clang-format off\n        switch (code) {\n            case Color::White:       DOCTEST_SET_ATTR(FOREGROUND_GREEN | FOREGROUND_RED | FOREGROUND_BLUE); break;\n            case Color::Red:         DOCTEST_SET_ATTR(FOREGROUND_RED);                                      break;\n            case Color::Green:       DOCTEST_SET_ATTR(FOREGROUND_GREEN);                                    break;\n            case Color::Blue:        DOCTEST_SET_ATTR(FOREGROUND_BLUE);                                     break;\n            case Color::Cyan:        DOCTEST_SET_ATTR(FOREGROUND_BLUE | FOREGROUND_GREEN);                  break;\n            case Color::Yellow:      DOCTEST_SET_ATTR(FOREGROUND_RED | FOREGROUND_GREEN);                   break;\n            case Color::Grey:        DOCTEST_SET_ATTR(0);                                                   break;\n            case Color::LightGrey:   DOCTEST_SET_ATTR(FOREGROUND_INTENSITY);                                break;\n            case Color::BrightRed:   DOCTEST_SET_ATTR(FOREGROUND_INTENSITY | FOREGROUND_RED);               break;\n            case Color::BrightGreen: DOCTEST_SET_ATTR(FOREGROUND_INTENSITY | FOREGROUND_GREEN);             break;\n            case Color::BrightWhite: DOCTEST_SET_ATTR(FOREGROUND_INTENSITY | FOREGROUND_GREEN | FOREGROUND_RED | FOREGROUND_BLUE); break;\n            case Color::None:\n            case Color::Bright: // invalid\n            default:                 DOCTEST_SET_ATTR(g_origFgAttrs);\n        }\n            // clang-format on\n#endif // DOCTEST_CONFIG_COLORS_WINDOWS\n    }\n    DOCTEST_CLANG_SUPPRESS_WARNING_POP\n\n    std::vector<const IExceptionTranslator*>& getExceptionTranslators() {\n        static std::vector<const IExceptionTranslator*> data;\n        return data;\n    }\n\n    String translateActiveException() {\n#ifndef DOCTEST_CONFIG_NO_EXCEPTIONS\n        String res;\n        auto&  translators = getExceptionTranslators();\n        for(auto& curr : translators)\n            if(curr->translate(res))\n                return res;\n        // clang-format off\n        DOCTEST_GCC_SUPPRESS_WARNING_WITH_PUSH(\"-Wcatch-value\")\n        try {\n            throw;\n        } catch(std::exception& ex) {\n            return ex.what();\n        } catch(std::string& msg) {\n            return msg.c_str();\n        } catch(const char* msg) {\n            return msg;\n        } catch(...) {\n            return \"unknown exception\";\n        }\n        DOCTEST_GCC_SUPPRESS_WARNING_POP\n// clang-format on\n#else  // DOCTEST_CONFIG_NO_EXCEPTIONS\n        return \"\";\n#endif // DOCTEST_CONFIG_NO_EXCEPTIONS\n    }\n} // namespace\n\nnamespace detail {\n    // used by the macros for registering tests\n    int regTest(const TestCase& tc) {\n        getRegisteredTests().insert(tc);\n        return 0;\n    }\n\n    // sets the current test suite\n    int setTestSuite(const TestSuite& ts) {\n        doctest_detail_test_suite_ns::getCurrentTestSuite() = ts;\n        return 0;\n    }\n\n#ifdef DOCTEST_IS_DEBUGGER_ACTIVE\n    bool isDebuggerActive() { return DOCTEST_IS_DEBUGGER_ACTIVE(); }\n#else // DOCTEST_IS_DEBUGGER_ACTIVE\n#ifdef DOCTEST_PLATFORM_LINUX\n    class ErrnoGuard {\n    public:\n        ErrnoGuard() : m_oldErrno(errno) {}\n        ~ErrnoGuard() { errno = m_oldErrno; }\n    private:\n        int m_oldErrno;\n    };\n    // See the comments in Catch2 for the reasoning behind this implementation:\n    // https://github.com/catchorg/Catch2/blob/v2.13.1/include/internal/catch_debugger.cpp#L79-L102\n    bool isDebuggerActive() {\n        ErrnoGuard guard;\n        std::ifstream in(\"/proc/self/status\");\n        for(std::string line; std::getline(in, line);) {\n            static const int PREFIX_LEN = 11;\n            if(line.compare(0, PREFIX_LEN, \"TracerPid:\\t\") == 0) {\n                return line.length() > PREFIX_LEN && line[PREFIX_LEN] != '0';\n            }\n        }\n        return false;\n    }\n#elif defined(DOCTEST_PLATFORM_MAC)\n    // The following function is taken directly from the following technical note:\n    // https://developer.apple.com/library/archive/qa/qa1361/_index.html\n    // Returns true if the current process is being debugged (either\n    // running under the debugger or has a debugger attached post facto).\n    bool isDebuggerActive() {\n        int        mib[4];\n        kinfo_proc info;\n        size_t     size;\n        // Initialize the flags so that, if sysctl fails for some bizarre\n        // reason, we get a predictable result.\n        info.kp_proc.p_flag = 0;\n        // Initialize mib, which tells sysctl the info we want, in this case\n        // we're looking for information about a specific process ID.\n        mib[0] = CTL_KERN;\n        mib[1] = KERN_PROC;\n        mib[2] = KERN_PROC_PID;\n        mib[3] = getpid();\n        // Call sysctl.\n        size = sizeof(info);\n        if(sysctl(mib, DOCTEST_COUNTOF(mib), &info, &size, 0, 0) != 0) {\n            std::cerr << \"\\nCall to sysctl failed - unable to determine if debugger is active **\\n\";\n            return false;\n        }\n        // We're being debugged if the P_TRACED flag is set.\n        return ((info.kp_proc.p_flag & P_TRACED) != 0);\n    }\n#elif DOCTEST_MSVC || defined(__MINGW32__) || defined(__MINGW64__)\n    bool isDebuggerActive() { return ::IsDebuggerPresent() != 0; }\n#else\n    bool isDebuggerActive() { return false; }\n#endif // Platform\n#endif // DOCTEST_IS_DEBUGGER_ACTIVE\n\n    void registerExceptionTranslatorImpl(const IExceptionTranslator* et) {\n        if(std::find(getExceptionTranslators().begin(), getExceptionTranslators().end(), et) ==\n           getExceptionTranslators().end())\n            getExceptionTranslators().push_back(et);\n    }\n\n#ifdef DOCTEST_CONFIG_TREAT_CHAR_STAR_AS_STRING\n    void toStream(std::ostream* s, char* in) { *s << in; }\n    void toStream(std::ostream* s, const char* in) { *s << in; }\n#endif // DOCTEST_CONFIG_TREAT_CHAR_STAR_AS_STRING\n    void toStream(std::ostream* s, bool in) { *s << std::boolalpha << in << std::noboolalpha; }\n    void toStream(std::ostream* s, float in) { *s << in; }\n    void toStream(std::ostream* s, double in) { *s << in; }\n    void toStream(std::ostream* s, double long in) { *s << in; }\n\n    void toStream(std::ostream* s, char in) { *s << in; }\n    void toStream(std::ostream* s, char signed in) { *s << in; }\n    void toStream(std::ostream* s, char unsigned in) { *s << in; }\n    void toStream(std::ostream* s, int short in) { *s << in; }\n    void toStream(std::ostream* s, int short unsigned in) { *s << in; }\n    void toStream(std::ostream* s, int in) { *s << in; }\n    void toStream(std::ostream* s, int unsigned in) { *s << in; }\n    void toStream(std::ostream* s, int long in) { *s << in; }\n    void toStream(std::ostream* s, int long unsigned in) { *s << in; }\n    void toStream(std::ostream* s, int long long in) { *s << in; }\n    void toStream(std::ostream* s, int long long unsigned in) { *s << in; }\n\n    DOCTEST_THREAD_LOCAL std::vector<IContextScope*> g_infoContexts; // for logging with INFO()\n\n    ContextScopeBase::ContextScopeBase() {\n        g_infoContexts.push_back(this);\n    }\n\n    DOCTEST_MSVC_SUPPRESS_WARNING_WITH_PUSH(4996) // std::uncaught_exception is deprecated in C++17\t\n    DOCTEST_GCC_SUPPRESS_WARNING_WITH_PUSH(\"-Wdeprecated-declarations\")\t\n    DOCTEST_CLANG_SUPPRESS_WARNING_WITH_PUSH(\"-Wdeprecated-declarations\")\n\n    // destroy cannot be inlined into the destructor because that would mean calling stringify after\n    // ContextScope has been destroyed (base class destructors run after derived class destructors).\n    // Instead, ContextScope calls this method directly from its destructor.\n    void ContextScopeBase::destroy() {\n#if defined(__cpp_lib_uncaught_exceptions) && __cpp_lib_uncaught_exceptions >= 201411L\n        if(std::uncaught_exceptions() > 0) {\n#else\n        if(std::uncaught_exception()) {\n#endif\n            std::ostringstream s;\n            this->stringify(&s);\n            g_cs->stringifiedContexts.push_back(s.str().c_str());\n        }\n        g_infoContexts.pop_back();\n    }\n\n    DOCTEST_CLANG_SUPPRESS_WARNING_POP\t\n    DOCTEST_GCC_SUPPRESS_WARNING_POP\t\n    DOCTEST_MSVC_SUPPRESS_WARNING_POP\n} // namespace detail\nnamespace {\n    using namespace detail;\n\n#if !defined(DOCTEST_CONFIG_POSIX_SIGNALS) && !defined(DOCTEST_CONFIG_WINDOWS_SEH)\n    struct FatalConditionHandler\n    {\n        void reset() {}\n    };\n#else // DOCTEST_CONFIG_POSIX_SIGNALS || DOCTEST_CONFIG_WINDOWS_SEH\n\n    void reportFatal(const std::string&);\n\n#ifdef DOCTEST_PLATFORM_WINDOWS\n\n    struct SignalDefs\n    {\n        DWORD id;\n        const char* name;\n    };\n    // There is no 1-1 mapping between signals and windows exceptions.\n    // Windows can easily distinguish between SO and SigSegV,\n    // but SigInt, SigTerm, etc are handled differently.\n    SignalDefs signalDefs[] = {\n            {static_cast<DWORD>(EXCEPTION_ILLEGAL_INSTRUCTION),\n             \"SIGILL - Illegal instruction signal\"},\n            {static_cast<DWORD>(EXCEPTION_STACK_OVERFLOW), \"SIGSEGV - Stack overflow\"},\n            {static_cast<DWORD>(EXCEPTION_ACCESS_VIOLATION),\n             \"SIGSEGV - Segmentation violation signal\"},\n            {static_cast<DWORD>(EXCEPTION_INT_DIVIDE_BY_ZERO), \"Divide by zero error\"},\n    };\n\n    struct FatalConditionHandler\n    {\n        static LONG CALLBACK handleException(PEXCEPTION_POINTERS ExceptionInfo) {\n            // Multiple threads may enter this filter/handler at once. We want the error message to be printed on the\n            // console just once no matter how many threads have crashed.\n            static std::mutex mutex;\n            static bool execute = true;\n            {\n                std::lock_guard<std::mutex> lock(mutex);\n                if(execute) {\n                    bool reported = false;\n                    for(size_t i = 0; i < DOCTEST_COUNTOF(signalDefs); ++i) {\n                        if(ExceptionInfo->ExceptionRecord->ExceptionCode == signalDefs[i].id) {\n                            reportFatal(signalDefs[i].name);\n                            reported = true;\n                            break;\n                        }\n                    }\n                    if(reported == false)\n                        reportFatal(\"Unhandled SEH exception caught\");\n                    if(isDebuggerActive() && !g_cs->no_breaks)\n                        DOCTEST_BREAK_INTO_DEBUGGER();\n                }\n                execute = false;\n            }\n            std::exit(EXIT_FAILURE);\n        }\n\n        FatalConditionHandler() {\n            isSet = true;\n            // 32k seems enough for doctest to handle stack overflow,\n            // but the value was found experimentally, so there is no strong guarantee\n            guaranteeSize = 32 * 1024;\n            // Register an unhandled exception filter\n            previousTop = SetUnhandledExceptionFilter(handleException);\n            // Pass in guarantee size to be filled\n            SetThreadStackGuarantee(&guaranteeSize);\n\n            // On Windows uncaught exceptions from another thread, exceptions from\n            // destructors, or calls to std::terminate are not a SEH exception\n\n            // The terminal handler gets called when:\n            // - std::terminate is called FROM THE TEST RUNNER THREAD\n            // - an exception is thrown from a destructor FROM THE TEST RUNNER THREAD\n            original_terminate_handler = std::get_terminate();\n            std::set_terminate([]() noexcept {\n                reportFatal(\"Terminate handler called\");\n                if(isDebuggerActive() && !g_cs->no_breaks)\n                    DOCTEST_BREAK_INTO_DEBUGGER();\n                std::exit(EXIT_FAILURE); // explicitly exit - otherwise the SIGABRT handler may be called as well\n            });\n\n            // SIGABRT is raised when:\n            // - std::terminate is called FROM A DIFFERENT THREAD\n            // - an exception is thrown from a destructor FROM A DIFFERENT THREAD\n            // - an uncaught exception is thrown FROM A DIFFERENT THREAD\n            prev_sigabrt_handler = std::signal(SIGABRT, [](int signal) noexcept {\n                if(signal == SIGABRT) {\n                    reportFatal(\"SIGABRT - Abort (abnormal termination) signal\");\n                    if(isDebuggerActive() && !g_cs->no_breaks)\n                        DOCTEST_BREAK_INTO_DEBUGGER();\n                    std::exit(EXIT_FAILURE);\n                }\n            });\n\n            // The following settings are taken from google test, and more\n            // specifically from UnitTest::Run() inside of gtest.cc\n\n            // the user does not want to see pop-up dialogs about crashes\n            prev_error_mode_1 = SetErrorMode(SEM_FAILCRITICALERRORS | SEM_NOALIGNMENTFAULTEXCEPT |\n                                             SEM_NOGPFAULTERRORBOX | SEM_NOOPENFILEERRORBOX);\n            // This forces the abort message to go to stderr in all circumstances.\n            prev_error_mode_2 = _set_error_mode(_OUT_TO_STDERR);\n            // In the debug version, Visual Studio pops up a separate dialog\n            // offering a choice to debug the aborted program - we want to disable that.\n            prev_abort_behavior = _set_abort_behavior(0x0, _WRITE_ABORT_MSG | _CALL_REPORTFAULT);\n            // In debug mode, the Windows CRT can crash with an assertion over invalid\n            // input (e.g. passing an invalid file descriptor). The default handling\n            // for these assertions is to pop up a dialog and wait for user input.\n            // Instead ask the CRT to dump such assertions to stderr non-interactively.\n            prev_report_mode = _CrtSetReportMode(_CRT_ASSERT, _CRTDBG_MODE_FILE | _CRTDBG_MODE_DEBUG);\n            prev_report_file = _CrtSetReportFile(_CRT_ASSERT, _CRTDBG_FILE_STDERR);\n        }\n\n        static void reset() {\n            if(isSet) {\n                // Unregister handler and restore the old guarantee\n                SetUnhandledExceptionFilter(previousTop);\n                SetThreadStackGuarantee(&guaranteeSize);\n                std::set_terminate(original_terminate_handler);\n                std::signal(SIGABRT, prev_sigabrt_handler);\n                SetErrorMode(prev_error_mode_1);\n                _set_error_mode(prev_error_mode_2);\n                _set_abort_behavior(prev_abort_behavior, _WRITE_ABORT_MSG | _CALL_REPORTFAULT);\n                static_cast<void>(_CrtSetReportMode(_CRT_ASSERT, prev_report_mode));\n                static_cast<void>(_CrtSetReportFile(_CRT_ASSERT, prev_report_file));\n                isSet = false;\n            }\n        }\n\n        ~FatalConditionHandler() { reset(); }\n\n    private:\n        static UINT         prev_error_mode_1;\n        static int          prev_error_mode_2;\n        static unsigned int prev_abort_behavior;\n        static int          prev_report_mode;\n        static _HFILE       prev_report_file;\n        static void (*prev_sigabrt_handler)(int);\n        static std::terminate_handler original_terminate_handler;\n        static bool isSet;\n        static ULONG guaranteeSize;\n        static LPTOP_LEVEL_EXCEPTION_FILTER previousTop;\n    };\n\n    UINT         FatalConditionHandler::prev_error_mode_1;\n    int          FatalConditionHandler::prev_error_mode_2;\n    unsigned int FatalConditionHandler::prev_abort_behavior;\n    int          FatalConditionHandler::prev_report_mode;\n    _HFILE       FatalConditionHandler::prev_report_file;\n    void (*FatalConditionHandler::prev_sigabrt_handler)(int);\n    std::terminate_handler FatalConditionHandler::original_terminate_handler;\n    bool FatalConditionHandler::isSet = false;\n    ULONG FatalConditionHandler::guaranteeSize = 0;\n    LPTOP_LEVEL_EXCEPTION_FILTER FatalConditionHandler::previousTop = nullptr;\n\n#else // DOCTEST_PLATFORM_WINDOWS\n\n    struct SignalDefs\n    {\n        int         id;\n        const char* name;\n    };\n    SignalDefs signalDefs[] = {{SIGINT, \"SIGINT - Terminal interrupt signal\"},\n                               {SIGILL, \"SIGILL - Illegal instruction signal\"},\n                               {SIGFPE, \"SIGFPE - Floating point error signal\"},\n                               {SIGSEGV, \"SIGSEGV - Segmentation violation signal\"},\n                               {SIGTERM, \"SIGTERM - Termination request signal\"},\n                               {SIGABRT, \"SIGABRT - Abort (abnormal termination) signal\"}};\n\n    struct FatalConditionHandler\n    {\n        static bool             isSet;\n        static struct sigaction oldSigActions[DOCTEST_COUNTOF(signalDefs)];\n        static stack_t          oldSigStack;\n        static char             altStackMem[4 * SIGSTKSZ];\n\n        static void handleSignal(int sig) {\n            const char* name = \"<unknown signal>\";\n            for(std::size_t i = 0; i < DOCTEST_COUNTOF(signalDefs); ++i) {\n                SignalDefs& def = signalDefs[i];\n                if(sig == def.id) {\n                    name = def.name;\n                    break;\n                }\n            }\n            reset();\n            reportFatal(name);\n            raise(sig);\n        }\n\n        FatalConditionHandler() {\n            isSet = true;\n            stack_t sigStack;\n            sigStack.ss_sp    = altStackMem;\n            sigStack.ss_size  = sizeof(altStackMem);\n            sigStack.ss_flags = 0;\n            sigaltstack(&sigStack, &oldSigStack);\n            struct sigaction sa = {};\n            sa.sa_handler       = handleSignal; // NOLINT\n            sa.sa_flags         = SA_ONSTACK;\n            for(std::size_t i = 0; i < DOCTEST_COUNTOF(signalDefs); ++i) {\n                sigaction(signalDefs[i].id, &sa, &oldSigActions[i]);\n            }\n        }\n\n        ~FatalConditionHandler() { reset(); }\n        static void reset() {\n            if(isSet) {\n                // Set signals back to previous values -- hopefully nobody overwrote them in the meantime\n                for(std::size_t i = 0; i < DOCTEST_COUNTOF(signalDefs); ++i) {\n                    sigaction(signalDefs[i].id, &oldSigActions[i], nullptr);\n                }\n                // Return the old stack\n                sigaltstack(&oldSigStack, nullptr);\n                isSet = false;\n            }\n        }\n    };\n\n    bool             FatalConditionHandler::isSet                                      = false;\n    struct sigaction FatalConditionHandler::oldSigActions[DOCTEST_COUNTOF(signalDefs)] = {};\n    stack_t          FatalConditionHandler::oldSigStack                                = {};\n    char             FatalConditionHandler::altStackMem[]                              = {};\n\n#endif // DOCTEST_PLATFORM_WINDOWS\n#endif // DOCTEST_CONFIG_POSIX_SIGNALS || DOCTEST_CONFIG_WINDOWS_SEH\n\n} // namespace\n\nnamespace {\n    using namespace detail;\n\n#ifdef DOCTEST_PLATFORM_WINDOWS\n#define DOCTEST_OUTPUT_DEBUG_STRING(text) ::OutputDebugStringA(text)\n#else\n    // TODO: integration with XCode and other IDEs\n#define DOCTEST_OUTPUT_DEBUG_STRING(text) // NOLINT(clang-diagnostic-unused-macros)\n#endif // Platform\n\n    void addAssert(assertType::Enum at) {\n        if((at & assertType::is_warn) == 0) //!OCLINT bitwise operator in conditional\n            g_cs->numAssertsCurrentTest_atomic++;\n    }\n\n    void addFailedAssert(assertType::Enum at) {\n        if((at & assertType::is_warn) == 0) //!OCLINT bitwise operator in conditional\n            g_cs->numAssertsFailedCurrentTest_atomic++;\n    }\n\n#if defined(DOCTEST_CONFIG_POSIX_SIGNALS) || defined(DOCTEST_CONFIG_WINDOWS_SEH)\n    void reportFatal(const std::string& message) {\n        g_cs->failure_flags |= TestCaseFailureReason::Crash;\n\n        DOCTEST_ITERATE_THROUGH_REPORTERS(test_case_exception, {message.c_str(), true});\n\n        while(g_cs->subcasesStack.size()) {\n            g_cs->subcasesStack.pop_back();\n            DOCTEST_ITERATE_THROUGH_REPORTERS(subcase_end, DOCTEST_EMPTY);\n        }\n\n        g_cs->finalizeTestCaseData();\n\n        DOCTEST_ITERATE_THROUGH_REPORTERS(test_case_end, *g_cs);\n\n        DOCTEST_ITERATE_THROUGH_REPORTERS(test_run_end, *g_cs);\n    }\n#endif // DOCTEST_CONFIG_POSIX_SIGNALS || DOCTEST_CONFIG_WINDOWS_SEH\n} // namespace\nnamespace detail {\n\n    ResultBuilder::ResultBuilder(assertType::Enum at, const char* file, int line, const char* expr,\n                                 const char* exception_type, const char* exception_string) {\n        m_test_case        = g_cs->currentTest;\n        m_at               = at;\n        m_file             = file;\n        m_line             = line;\n        m_expr             = expr;\n        m_failed           = true;\n        m_threw            = false;\n        m_threw_as         = false;\n        m_exception_type   = exception_type;\n        m_exception_string = exception_string;\n#if DOCTEST_MSVC\n        if(m_expr[0] == ' ') // this happens when variadic macros are disabled under MSVC\n            ++m_expr;\n#endif // MSVC\n    }\n\n    void ResultBuilder::setResult(const Result& res) {\n        m_decomp = res.m_decomp;\n        m_failed = !res.m_passed;\n    }\n\n    void ResultBuilder::translateException() {\n        m_threw     = true;\n        m_exception = translateActiveException();\n    }\n\n    bool ResultBuilder::log() {\n        if(m_at & assertType::is_throws) { //!OCLINT bitwise operator in conditional\n            m_failed = !m_threw;\n        } else if((m_at & assertType::is_throws_as) && (m_at & assertType::is_throws_with)) { //!OCLINT\n            m_failed = !m_threw_as || (m_exception != m_exception_string);\n        } else if(m_at & assertType::is_throws_as) { //!OCLINT bitwise operator in conditional\n            m_failed = !m_threw_as;\n        } else if(m_at & assertType::is_throws_with) { //!OCLINT bitwise operator in conditional\n            m_failed = m_exception != m_exception_string;\n        } else if(m_at & assertType::is_nothrow) { //!OCLINT bitwise operator in conditional\n            m_failed = m_threw;\n        }\n\n        if(m_exception.size())\n            m_exception = String(\"\\\"\") + m_exception + \"\\\"\";\n\n        if(is_running_in_test) {\n            addAssert(m_at);\n            DOCTEST_ITERATE_THROUGH_REPORTERS(log_assert, *this);\n\n            if(m_failed)\n                addFailedAssert(m_at);\n        } else if(m_failed) {\n            failed_out_of_a_testing_context(*this);\n        }\n\n        return m_failed && isDebuggerActive() && !getContextOptions()->no_breaks &&\n            (g_cs->currentTest == nullptr || !g_cs->currentTest->m_no_breaks); // break into debugger\n    }\n\n    void ResultBuilder::react() const {\n        if(m_failed && checkIfShouldThrow(m_at))\n            throwException();\n    }\n\n    void failed_out_of_a_testing_context(const AssertData& ad) {\n        if(g_cs->ah)\n            g_cs->ah(ad);\n        else\n            std::abort();\n    }\n\n    void decomp_assert(assertType::Enum at, const char* file, int line, const char* expr,\n                       Result result) {\n        bool failed = !result.m_passed;\n\n        // ###################################################################################\n        // IF THE DEBUGGER BREAKS HERE - GO 1 LEVEL UP IN THE CALLSTACK FOR THE FAILING ASSERT\n        // THIS IS THE EFFECT OF HAVING 'DOCTEST_CONFIG_SUPER_FAST_ASSERTS' DEFINED\n        // ###################################################################################\n        DOCTEST_ASSERT_OUT_OF_TESTS(result.m_decomp);\n        DOCTEST_ASSERT_IN_TESTS(result.m_decomp);\n        // NOLINTNEXTLINE(clang-analyzer-cplusplus.NewDeleteLeaks)\n    }\n\n    MessageBuilder::MessageBuilder(const char* file, int line, assertType::Enum severity) {\n        m_stream   = getTlsOss();\n        m_file     = file;\n        m_line     = line;\n        m_severity = severity;\n    }\n\n    IExceptionTranslator::IExceptionTranslator()  = default;\n    IExceptionTranslator::~IExceptionTranslator() = default;\n\n    bool MessageBuilder::log() {\n        m_string = getTlsOssResult();\n        DOCTEST_ITERATE_THROUGH_REPORTERS(log_message, *this);\n\n        const bool isWarn = m_severity & assertType::is_warn;\n\n        // warn is just a message in this context so we don't treat it as an assert\n        if(!isWarn) {\n            addAssert(m_severity);\n            addFailedAssert(m_severity);\n        }\n\n        return isDebuggerActive() && !getContextOptions()->no_breaks && !isWarn &&\n            (g_cs->currentTest == nullptr || !g_cs->currentTest->m_no_breaks); // break into debugger\n    }\n\n    void MessageBuilder::react() {\n        if(m_severity & assertType::is_require) //!OCLINT bitwise operator in conditional\n            throwException();\n    }\n\n    MessageBuilder::~MessageBuilder() = default;\n} // namespace detail\nnamespace {\n    using namespace detail;\n\n    template <typename Ex>\n    DOCTEST_NORETURN void throw_exception(Ex const& e) {\n#ifndef DOCTEST_CONFIG_NO_EXCEPTIONS\n        throw e;\n#else  // DOCTEST_CONFIG_NO_EXCEPTIONS\n        std::cerr << \"doctest will terminate because it needed to throw an exception.\\n\"\n                  << \"The message was: \" << e.what() << '\\n';\n        std::terminate();\n#endif // DOCTEST_CONFIG_NO_EXCEPTIONS\n    }\n\n#ifndef DOCTEST_INTERNAL_ERROR\n#define DOCTEST_INTERNAL_ERROR(msg)                                                                \\\n    throw_exception(std::logic_error(                                                              \\\n            __FILE__ \":\" DOCTEST_TOSTR(__LINE__) \": Internal doctest error: \" msg))\n#endif // DOCTEST_INTERNAL_ERROR\n\n    // clang-format off\n\n// =================================================================================================\n// The following code has been taken verbatim from Catch2/include/internal/catch_xmlwriter.h/cpp\n// This is done so cherry-picking bug fixes is trivial - even the style/formatting is untouched.\n// =================================================================================================\n\n    class XmlEncode {\n    public:\n        enum ForWhat { ForTextNodes, ForAttributes };\n\n        XmlEncode( std::string const& str, ForWhat forWhat = ForTextNodes );\n\n        void encodeTo( std::ostream& os ) const;\n\n        friend std::ostream& operator << ( std::ostream& os, XmlEncode const& xmlEncode );\n\n    private:\n        std::string m_str;\n        ForWhat m_forWhat;\n    };\n\n    class XmlWriter {\n    public:\n\n        class ScopedElement {\n        public:\n            ScopedElement( XmlWriter* writer );\n\n            ScopedElement( ScopedElement&& other ) DOCTEST_NOEXCEPT;\n            ScopedElement& operator=( ScopedElement&& other ) DOCTEST_NOEXCEPT;\n\n            ~ScopedElement();\n\n            ScopedElement& writeText( std::string const& text, bool indent = true );\n\n            template<typename T>\n            ScopedElement& writeAttribute( std::string const& name, T const& attribute ) {\n                m_writer->writeAttribute( name, attribute );\n                return *this;\n            }\n\n        private:\n            mutable XmlWriter* m_writer = nullptr;\n        };\n\n        XmlWriter( std::ostream& os = std::cout );\n        ~XmlWriter();\n\n        XmlWriter( XmlWriter const& ) = delete;\n        XmlWriter& operator=( XmlWriter const& ) = delete;\n\n        XmlWriter& startElement( std::string const& name );\n\n        ScopedElement scopedElement( std::string const& name );\n\n        XmlWriter& endElement();\n\n        XmlWriter& writeAttribute( std::string const& name, std::string const& attribute );\n\n        XmlWriter& writeAttribute( std::string const& name, const char* attribute );\n\n        XmlWriter& writeAttribute( std::string const& name, bool attribute );\n\n        template<typename T>\n        XmlWriter& writeAttribute( std::string const& name, T const& attribute ) {\n        std::stringstream rss;\n            rss << attribute;\n            return writeAttribute( name, rss.str() );\n        }\n\n        XmlWriter& writeText( std::string const& text, bool indent = true );\n\n        //XmlWriter& writeComment( std::string const& text );\n\n        //void writeStylesheetRef( std::string const& url );\n\n        //XmlWriter& writeBlankLine();\n\n        void ensureTagClosed();\n\n    private:\n\n        void writeDeclaration();\n\n        void newlineIfNecessary();\n\n        bool m_tagIsOpen = false;\n        bool m_needsNewline = false;\n        std::vector<std::string> m_tags;\n        std::string m_indent;\n        std::ostream& m_os;\n    };\n\n// =================================================================================================\n// The following code has been taken verbatim from Catch2/include/internal/catch_xmlwriter.h/cpp\n// This is done so cherry-picking bug fixes is trivial - even the style/formatting is untouched.\n// =================================================================================================\n\nusing uchar = unsigned char;\n\nnamespace {\n\n    size_t trailingBytes(unsigned char c) {\n        if ((c & 0xE0) == 0xC0) {\n            return 2;\n        }\n        if ((c & 0xF0) == 0xE0) {\n            return 3;\n        }\n        if ((c & 0xF8) == 0xF0) {\n            return 4;\n        }\n        DOCTEST_INTERNAL_ERROR(\"Invalid multibyte utf-8 start byte encountered\");\n    }\n\n    uint32_t headerValue(unsigned char c) {\n        if ((c & 0xE0) == 0xC0) {\n            return c & 0x1F;\n        }\n        if ((c & 0xF0) == 0xE0) {\n            return c & 0x0F;\n        }\n        if ((c & 0xF8) == 0xF0) {\n            return c & 0x07;\n        }\n        DOCTEST_INTERNAL_ERROR(\"Invalid multibyte utf-8 start byte encountered\");\n    }\n\n    void hexEscapeChar(std::ostream& os, unsigned char c) {\n        std::ios_base::fmtflags f(os.flags());\n        os << \"\\\\x\"\n            << std::uppercase << std::hex << std::setfill('0') << std::setw(2)\n            << static_cast<int>(c);\n        os.flags(f);\n    }\n\n} // anonymous namespace\n\n    XmlEncode::XmlEncode( std::string const& str, ForWhat forWhat )\n    :   m_str( str ),\n        m_forWhat( forWhat )\n    {}\n\n    void XmlEncode::encodeTo( std::ostream& os ) const {\n        // Apostrophe escaping not necessary if we always use \" to write attributes\n        // (see: https://www.w3.org/TR/xml/#syntax)\n\n        for( std::size_t idx = 0; idx < m_str.size(); ++ idx ) {\n            uchar c = m_str[idx];\n            switch (c) {\n            case '<':   os << \"&lt;\"; break;\n            case '&':   os << \"&amp;\"; break;\n\n            case '>':\n                // See: https://www.w3.org/TR/xml/#syntax\n                if (idx > 2 && m_str[idx - 1] == ']' && m_str[idx - 2] == ']')\n                    os << \"&gt;\";\n                else\n                    os << c;\n                break;\n\n            case '\\\"':\n                if (m_forWhat == ForAttributes)\n                    os << \"&quot;\";\n                else\n                    os << c;\n                break;\n\n            default:\n                // Check for control characters and invalid utf-8\n\n                // Escape control characters in standard ascii\n                // see https://stackoverflow.com/questions/404107/why-are-control-characters-illegal-in-xml-1-0\n                if (c < 0x09 || (c > 0x0D && c < 0x20) || c == 0x7F) {\n                    hexEscapeChar(os, c);\n                    break;\n                }\n\n                // Plain ASCII: Write it to stream\n                if (c < 0x7F) {\n                    os << c;\n                    break;\n                }\n\n                // UTF-8 territory\n                // Check if the encoding is valid and if it is not, hex escape bytes.\n                // Important: We do not check the exact decoded values for validity, only the encoding format\n                // First check that this bytes is a valid lead byte:\n                // This means that it is not encoded as 1111 1XXX\n                // Or as 10XX XXXX\n                if (c <  0xC0 ||\n                    c >= 0xF8) {\n                    hexEscapeChar(os, c);\n                    break;\n                }\n\n                auto encBytes = trailingBytes(c);\n                // Are there enough bytes left to avoid accessing out-of-bounds memory?\n                if (idx + encBytes - 1 >= m_str.size()) {\n                    hexEscapeChar(os, c);\n                    break;\n                }\n                // The header is valid, check data\n                // The next encBytes bytes must together be a valid utf-8\n                // This means: bitpattern 10XX XXXX and the extracted value is sane (ish)\n                bool valid = true;\n                uint32_t value = headerValue(c);\n                for (std::size_t n = 1; n < encBytes; ++n) {\n                    uchar nc = m_str[idx + n];\n                    valid &= ((nc & 0xC0) == 0x80);\n                    value = (value << 6) | (nc & 0x3F);\n                }\n\n                if (\n                    // Wrong bit pattern of following bytes\n                    (!valid) ||\n                    // Overlong encodings\n                    (value < 0x80) ||\n                    (                 value < 0x800   && encBytes > 2) || // removed \"0x80 <= value &&\" because redundant\n                    (0x800 < value && value < 0x10000 && encBytes > 3) ||\n                    // Encoded value out of range\n                    (value >= 0x110000)\n                    ) {\n                    hexEscapeChar(os, c);\n                    break;\n                }\n\n                // If we got here, this is in fact a valid(ish) utf-8 sequence\n                for (std::size_t n = 0; n < encBytes; ++n) {\n                    os << m_str[idx + n];\n                }\n                idx += encBytes - 1;\n                break;\n            }\n        }\n    }\n\n    std::ostream& operator << ( std::ostream& os, XmlEncode const& xmlEncode ) {\n        xmlEncode.encodeTo( os );\n        return os;\n    }\n\n    XmlWriter::ScopedElement::ScopedElement( XmlWriter* writer )\n    :   m_writer( writer )\n    {}\n\n    XmlWriter::ScopedElement::ScopedElement( ScopedElement&& other ) DOCTEST_NOEXCEPT\n    :   m_writer( other.m_writer ){\n        other.m_writer = nullptr;\n    }\n    XmlWriter::ScopedElement& XmlWriter::ScopedElement::operator=( ScopedElement&& other ) DOCTEST_NOEXCEPT {\n        if ( m_writer ) {\n            m_writer->endElement();\n        }\n        m_writer = other.m_writer;\n        other.m_writer = nullptr;\n        return *this;\n    }\n\n\n    XmlWriter::ScopedElement::~ScopedElement() {\n        if( m_writer )\n            m_writer->endElement();\n    }\n\n    XmlWriter::ScopedElement& XmlWriter::ScopedElement::writeText( std::string const& text, bool indent ) {\n        m_writer->writeText( text, indent );\n        return *this;\n    }\n\n    XmlWriter::XmlWriter( std::ostream& os ) : m_os( os )\n    {\n        writeDeclaration();\n    }\n\n    XmlWriter::~XmlWriter() {\n        while( !m_tags.empty() )\n            endElement();\n    }\n\n    XmlWriter& XmlWriter::startElement( std::string const& name ) {\n        ensureTagClosed();\n        newlineIfNecessary();\n        m_os << m_indent << '<' << name;\n        m_tags.push_back( name );\n        m_indent += \"  \";\n        m_tagIsOpen = true;\n        return *this;\n    }\n\n    XmlWriter::ScopedElement XmlWriter::scopedElement( std::string const& name ) {\n        ScopedElement scoped( this );\n        startElement( name );\n        return scoped;\n    }\n\n    XmlWriter& XmlWriter::endElement() {\n        newlineIfNecessary();\n        m_indent = m_indent.substr( 0, m_indent.size()-2 );\n        if( m_tagIsOpen ) {\n            m_os << \"/>\";\n            m_tagIsOpen = false;\n        }\n        else {\n            m_os << m_indent << \"</\" << m_tags.back() << \">\";\n        }\n        m_os << std::endl;\n        m_tags.pop_back();\n        return *this;\n    }\n\n    XmlWriter& XmlWriter::writeAttribute( std::string const& name, std::string const& attribute ) {\n        if( !name.empty() && !attribute.empty() )\n            m_os << ' ' << name << \"=\\\"\" << XmlEncode( attribute, XmlEncode::ForAttributes ) << '\"';\n        return *this;\n    }\n\n    XmlWriter& XmlWriter::writeAttribute( std::string const& name, const char* attribute ) {\n        if( !name.empty() && attribute && attribute[0] != '\\0' )\n            m_os << ' ' << name << \"=\\\"\" << XmlEncode( attribute, XmlEncode::ForAttributes ) << '\"';\n        return *this;\n    }\n\n    XmlWriter& XmlWriter::writeAttribute( std::string const& name, bool attribute ) {\n        m_os << ' ' << name << \"=\\\"\" << ( attribute ? \"true\" : \"false\" ) << '\"';\n        return *this;\n    }\n\n    XmlWriter& XmlWriter::writeText( std::string const& text, bool indent ) {\n        if( !text.empty() ){\n            bool tagWasOpen = m_tagIsOpen;\n            ensureTagClosed();\n            if( tagWasOpen && indent )\n                m_os << m_indent;\n            m_os << XmlEncode( text );\n            m_needsNewline = true;\n        }\n        return *this;\n    }\n\n    //XmlWriter& XmlWriter::writeComment( std::string const& text ) {\n    //    ensureTagClosed();\n    //    m_os << m_indent << \"<!--\" << text << \"-->\";\n    //    m_needsNewline = true;\n    //    return *this;\n    //}\n\n    //void XmlWriter::writeStylesheetRef( std::string const& url ) {\n    //    m_os << \"<?xml-stylesheet type=\\\"text/xsl\\\" href=\\\"\" << url << \"\\\"?>\\n\";\n    //}\n\n    //XmlWriter& XmlWriter::writeBlankLine() {\n    //    ensureTagClosed();\n    //    m_os << '\\n';\n    //    return *this;\n    //}\n\n    void XmlWriter::ensureTagClosed() {\n        if( m_tagIsOpen ) {\n            m_os << \">\" << std::endl;\n            m_tagIsOpen = false;\n        }\n    }\n\n    void XmlWriter::writeDeclaration() {\n        m_os << \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\\n\";\n    }\n\n    void XmlWriter::newlineIfNecessary() {\n        if( m_needsNewline ) {\n            m_os << std::endl;\n            m_needsNewline = false;\n        }\n    }\n\n// =================================================================================================\n// End of copy-pasted code from Catch\n// =================================================================================================\n\n    // clang-format on\n\n    struct XmlReporter : public IReporter\n    {\n        XmlWriter  xml;\n        std::mutex mutex;\n\n        // caching pointers/references to objects of these types - safe to do\n        const ContextOptions& opt;\n        const TestCaseData*   tc = nullptr;\n\n        XmlReporter(const ContextOptions& co)\n                : xml(*co.cout)\n                , opt(co) {}\n\n        void log_contexts() {\n            int num_contexts = get_num_active_contexts();\n            if(num_contexts) {\n                auto              contexts = get_active_contexts();\n                std::stringstream ss;\n                for(int i = 0; i < num_contexts; ++i) {\n                    contexts[i]->stringify(&ss);\n                    xml.scopedElement(\"Info\").writeText(ss.str());\n                    ss.str(\"\");\n                }\n            }\n        }\n\n        unsigned line(unsigned l) const { return opt.no_line_numbers ? 0 : l; }\n\n        void test_case_start_impl(const TestCaseData& in) {\n            bool open_ts_tag = false;\n            if(tc != nullptr) { // we have already opened a test suite\n                if(std::strcmp(tc->m_test_suite, in.m_test_suite) != 0) {\n                    xml.endElement();\n                    open_ts_tag = true;\n                }\n            }\n            else {\n                open_ts_tag = true; // first test case ==> first test suite\n            }\n\n            if(open_ts_tag) {\n                xml.startElement(\"TestSuite\");\n                xml.writeAttribute(\"name\", in.m_test_suite);\n            }\n\n            tc = &in;\n            xml.startElement(\"TestCase\")\n                    .writeAttribute(\"name\", in.m_name)\n                    .writeAttribute(\"filename\", skipPathFromFilename(in.m_file.c_str()))\n                    .writeAttribute(\"line\", line(in.m_line))\n                    .writeAttribute(\"description\", in.m_description);\n\n            if(Approx(in.m_timeout) != 0)\n                xml.writeAttribute(\"timeout\", in.m_timeout);\n            if(in.m_may_fail)\n                xml.writeAttribute(\"may_fail\", true);\n            if(in.m_should_fail)\n                xml.writeAttribute(\"should_fail\", true);\n        }\n\n        // =========================================================================================\n        // WHAT FOLLOWS ARE OVERRIDES OF THE VIRTUAL METHODS OF THE REPORTER INTERFACE\n        // =========================================================================================\n\n        void report_query(const QueryData& in) override {\n            test_run_start();\n            if(opt.list_reporters) {\n                for(auto& curr : getListeners())\n                    xml.scopedElement(\"Listener\")\n                            .writeAttribute(\"priority\", curr.first.first)\n                            .writeAttribute(\"name\", curr.first.second);\n                for(auto& curr : getReporters())\n                    xml.scopedElement(\"Reporter\")\n                            .writeAttribute(\"priority\", curr.first.first)\n                            .writeAttribute(\"name\", curr.first.second);\n            } else if(opt.count || opt.list_test_cases) {\n                for(unsigned i = 0; i < in.num_data; ++i) {\n                    xml.scopedElement(\"TestCase\").writeAttribute(\"name\", in.data[i]->m_name)\n                        .writeAttribute(\"testsuite\", in.data[i]->m_test_suite)\n                        .writeAttribute(\"filename\", skipPathFromFilename(in.data[i]->m_file.c_str()))\n                        .writeAttribute(\"line\", line(in.data[i]->m_line));\n                }\n                xml.scopedElement(\"OverallResultsTestCases\")\n                        .writeAttribute(\"unskipped\", in.run_stats->numTestCasesPassingFilters);\n            } else if(opt.list_test_suites) {\n                for(unsigned i = 0; i < in.num_data; ++i)\n                    xml.scopedElement(\"TestSuite\").writeAttribute(\"name\", in.data[i]->m_test_suite);\n                xml.scopedElement(\"OverallResultsTestCases\")\n                        .writeAttribute(\"unskipped\", in.run_stats->numTestCasesPassingFilters);\n                xml.scopedElement(\"OverallResultsTestSuites\")\n                        .writeAttribute(\"unskipped\", in.run_stats->numTestSuitesPassingFilters);\n            }\n            xml.endElement();\n        }\n\n        void test_run_start() override {\n            // remove .exe extension - mainly to have the same output on UNIX and Windows\n            std::string binary_name = skipPathFromFilename(opt.binary_name.c_str());\n#ifdef DOCTEST_PLATFORM_WINDOWS\n            if(binary_name.rfind(\".exe\") != std::string::npos)\n                binary_name = binary_name.substr(0, binary_name.length() - 4);\n#endif // DOCTEST_PLATFORM_WINDOWS\n\n            xml.startElement(\"doctest\").writeAttribute(\"binary\", binary_name);\n            if(opt.no_version == false)\n                xml.writeAttribute(\"version\", DOCTEST_VERSION_STR);\n\n            // only the consequential ones (TODO: filters)\n            xml.scopedElement(\"Options\")\n                    .writeAttribute(\"order_by\", opt.order_by.c_str())\n                    .writeAttribute(\"rand_seed\", opt.rand_seed)\n                    .writeAttribute(\"first\", opt.first)\n                    .writeAttribute(\"last\", opt.last)\n                    .writeAttribute(\"abort_after\", opt.abort_after)\n                    .writeAttribute(\"subcase_filter_levels\", opt.subcase_filter_levels)\n                    .writeAttribute(\"case_sensitive\", opt.case_sensitive)\n                    .writeAttribute(\"no_throw\", opt.no_throw)\n                    .writeAttribute(\"no_skip\", opt.no_skip);\n        }\n\n        void test_run_end(const TestRunStats& p) override {\n            if(tc) // the TestSuite tag - only if there has been at least 1 test case\n                xml.endElement();\n\n            xml.scopedElement(\"OverallResultsAsserts\")\n                    .writeAttribute(\"successes\", p.numAsserts - p.numAssertsFailed)\n                    .writeAttribute(\"failures\", p.numAssertsFailed);\n\n            xml.startElement(\"OverallResultsTestCases\")\n                    .writeAttribute(\"successes\",\n                                    p.numTestCasesPassingFilters - p.numTestCasesFailed)\n                    .writeAttribute(\"failures\", p.numTestCasesFailed);\n            if(opt.no_skipped_summary == false)\n                xml.writeAttribute(\"skipped\", p.numTestCases - p.numTestCasesPassingFilters);\n            xml.endElement();\n\n            xml.endElement();\n        }\n\n        void test_case_start(const TestCaseData& in) override {\n            test_case_start_impl(in);\n            xml.ensureTagClosed();\n        }\n        \n        void test_case_reenter(const TestCaseData&) override {}\n\n        void test_case_end(const CurrentTestCaseStats& st) override {\n            xml.startElement(\"OverallResultsAsserts\")\n                    .writeAttribute(\"successes\",\n                                    st.numAssertsCurrentTest - st.numAssertsFailedCurrentTest)\n                    .writeAttribute(\"failures\", st.numAssertsFailedCurrentTest);\n            if(opt.duration)\n                xml.writeAttribute(\"duration\", st.seconds);\n            if(tc->m_expected_failures)\n                xml.writeAttribute(\"expected_failures\", tc->m_expected_failures);\n            xml.endElement();\n\n            xml.endElement();\n        }\n\n        void test_case_exception(const TestCaseException& e) override {\n            std::lock_guard<std::mutex> lock(mutex);\n\n            xml.scopedElement(\"Exception\")\n                    .writeAttribute(\"crash\", e.is_crash)\n                    .writeText(e.error_string.c_str());\n        }\n\n        void subcase_start(const SubcaseSignature& in) override {\n            std::lock_guard<std::mutex> lock(mutex);\n\n            xml.startElement(\"SubCase\")\n                    .writeAttribute(\"name\", in.m_name)\n                    .writeAttribute(\"filename\", skipPathFromFilename(in.m_file))\n                    .writeAttribute(\"line\", line(in.m_line));\n            xml.ensureTagClosed();\n        }\n\n        void subcase_end() override { xml.endElement(); }\n\n        void log_assert(const AssertData& rb) override {\n            if(!rb.m_failed && !opt.success)\n                return;\n\n            std::lock_guard<std::mutex> lock(mutex);\n\n            xml.startElement(\"Expression\")\n                    .writeAttribute(\"success\", !rb.m_failed)\n                    .writeAttribute(\"type\", assertString(rb.m_at))\n                    .writeAttribute(\"filename\", skipPathFromFilename(rb.m_file))\n                    .writeAttribute(\"line\", line(rb.m_line));\n\n            xml.scopedElement(\"Original\").writeText(rb.m_expr);\n\n            if(rb.m_threw)\n                xml.scopedElement(\"Exception\").writeText(rb.m_exception.c_str());\n\n            if(rb.m_at & assertType::is_throws_as)\n                xml.scopedElement(\"ExpectedException\").writeText(rb.m_exception_type);\n            if(rb.m_at & assertType::is_throws_with)\n                xml.scopedElement(\"ExpectedExceptionString\").writeText(rb.m_exception_string);\n            if((rb.m_at & assertType::is_normal) && !rb.m_threw)\n                xml.scopedElement(\"Expanded\").writeText(rb.m_decomp.c_str());\n\n            log_contexts();\n\n            xml.endElement();\n        }\n\n        void log_message(const MessageData& mb) override {\n            std::lock_guard<std::mutex> lock(mutex);\n\n            xml.startElement(\"Message\")\n                    .writeAttribute(\"type\", failureString(mb.m_severity))\n                    .writeAttribute(\"filename\", skipPathFromFilename(mb.m_file))\n                    .writeAttribute(\"line\", line(mb.m_line));\n\n            xml.scopedElement(\"Text\").writeText(mb.m_string.c_str());\n\n            log_contexts();\n\n            xml.endElement();\n        }\n\n        void test_case_skipped(const TestCaseData& in) override {\n            if(opt.no_skipped_summary == false) {\n                test_case_start_impl(in);\n                xml.writeAttribute(\"skipped\", \"true\");\n                xml.endElement();\n            }\n        }\n    };\n\n    DOCTEST_REGISTER_REPORTER(\"xml\", 0, XmlReporter);\n\n    void fulltext_log_assert_to_stream(std::ostream& s, const AssertData& rb) {\n        if((rb.m_at & (assertType::is_throws_as | assertType::is_throws_with)) ==\n            0) //!OCLINT bitwise operator in conditional\n            s << Color::Cyan << assertString(rb.m_at) << \"( \" << rb.m_expr << \" ) \"\n                << Color::None;\n\n        if(rb.m_at & assertType::is_throws) { //!OCLINT bitwise operator in conditional\n            s << (rb.m_threw ? \"threw as expected!\" : \"did NOT throw at all!\") << \"\\n\";\n        } else if((rb.m_at & assertType::is_throws_as) &&\n                    (rb.m_at & assertType::is_throws_with)) { //!OCLINT\n            s << Color::Cyan << assertString(rb.m_at) << \"( \" << rb.m_expr << \", \\\"\"\n                << rb.m_exception_string << \"\\\", \" << rb.m_exception_type << \" ) \" << Color::None;\n            if(rb.m_threw) {\n                if(!rb.m_failed) {\n                    s << \"threw as expected!\\n\";\n                } else {\n                    s << \"threw a DIFFERENT exception! (contents: \" << rb.m_exception << \")\\n\";\n                }\n            } else {\n                s << \"did NOT throw at all!\\n\";\n            }\n        } else if(rb.m_at &\n                    assertType::is_throws_as) { //!OCLINT bitwise operator in conditional\n            s << Color::Cyan << assertString(rb.m_at) << \"( \" << rb.m_expr << \", \"\n                << rb.m_exception_type << \" ) \" << Color::None\n                << (rb.m_threw ? (rb.m_threw_as ? \"threw as expected!\" :\n                                                \"threw a DIFFERENT exception: \") :\n                                \"did NOT throw at all!\")\n                << Color::Cyan << rb.m_exception << \"\\n\";\n        } else if(rb.m_at &\n                    assertType::is_throws_with) { //!OCLINT bitwise operator in conditional\n            s << Color::Cyan << assertString(rb.m_at) << \"( \" << rb.m_expr << \", \\\"\"\n                << rb.m_exception_string << \"\\\" ) \" << Color::None\n                << (rb.m_threw ? (!rb.m_failed ? \"threw as expected!\" :\n                                                \"threw a DIFFERENT exception: \") :\n                                \"did NOT throw at all!\")\n                << Color::Cyan << rb.m_exception << \"\\n\";\n        } else if(rb.m_at & assertType::is_nothrow) { //!OCLINT bitwise operator in conditional\n            s << (rb.m_threw ? \"THREW exception: \" : \"didn't throw!\") << Color::Cyan\n                << rb.m_exception << \"\\n\";\n        } else {\n            s << (rb.m_threw ? \"THREW exception: \" :\n                                (!rb.m_failed ? \"is correct!\\n\" : \"is NOT correct!\\n\"));\n            if(rb.m_threw)\n                s << rb.m_exception << \"\\n\";\n            else\n                s << \"  values: \" << assertString(rb.m_at) << \"( \" << rb.m_decomp << \" )\\n\";\n        }\n    }\n\n    // TODO:\n    // - log_message()\n    // - respond to queries\n    // - honor remaining options\n    // - more attributes in tags\n    struct JUnitReporter : public IReporter\n    {\n        XmlWriter  xml;\n        std::mutex mutex;\n        Timer timer;\n        std::vector<String> deepestSubcaseStackNames;\n\n        struct JUnitTestCaseData\n        {\n            static std::string getCurrentTimestamp() {\n                // Beware, this is not reentrant because of backward compatibility issues\n                // Also, UTC only, again because of backward compatibility (%z is C++11)\n                time_t rawtime;\n                std::time(&rawtime);\n                auto const timeStampSize = sizeof(\"2017-01-16T17:06:45Z\");\n\n                std::tm timeInfo;\n#ifdef DOCTEST_PLATFORM_WINDOWS\n                gmtime_s(&timeInfo, &rawtime);\n#else // DOCTEST_PLATFORM_WINDOWS\n                gmtime_r(&rawtime, &timeInfo);\n#endif // DOCTEST_PLATFORM_WINDOWS\n\n                char timeStamp[timeStampSize];\n                const char* const fmt = \"%Y-%m-%dT%H:%M:%SZ\";\n\n                std::strftime(timeStamp, timeStampSize, fmt, &timeInfo);\n                return std::string(timeStamp);\n            }\n\n            struct JUnitTestMessage\n            {\n                JUnitTestMessage(const std::string& _message, const std::string& _type, const std::string& _details)\n                    : message(_message), type(_type), details(_details) {}\n\n                JUnitTestMessage(const std::string& _message, const std::string& _details)\n                    : message(_message), type(), details(_details) {}\n\n                std::string message, type, details;\n            };\n\n            struct JUnitTestCase\n            {\n                JUnitTestCase(const std::string& _classname, const std::string& _name)\n                    : classname(_classname), name(_name), time(0), failures() {}\n\n                std::string classname, name;\n                double time;\n                std::vector<JUnitTestMessage> failures, errors;\n            };\n\n            void add(const std::string& classname, const std::string& name) {\n                testcases.emplace_back(classname, name);\n            }\n\n            void appendSubcaseNamesToLastTestcase(std::vector<String> nameStack) {\n                for(auto& curr: nameStack)\n                    if(curr.size())\n                        testcases.back().name += std::string(\"/\") + curr.c_str();\n            }\n\n            void addTime(double time) {\n                if(time < 1e-4)\n                    time = 0;\n                testcases.back().time = time;\n                totalSeconds += time;\n            }\n\n            void addFailure(const std::string& message, const std::string& type, const std::string& details) {\n                testcases.back().failures.emplace_back(message, type, details);\n                ++totalFailures;\n            }\n\n            void addError(const std::string& message, const std::string& details) {\n                testcases.back().errors.emplace_back(message, details);\n                ++totalErrors;\n            }\n\n            std::vector<JUnitTestCase> testcases;\n            double totalSeconds = 0;\n            int totalErrors = 0, totalFailures = 0;\n        };\n\n        JUnitTestCaseData testCaseData;\n\n        // caching pointers/references to objects of these types - safe to do\n        const ContextOptions& opt;\n        const TestCaseData*   tc = nullptr;\n\n        JUnitReporter(const ContextOptions& co)\n                : xml(*co.cout)\n                , opt(co) {}\n\n        unsigned line(unsigned l) const { return opt.no_line_numbers ? 0 : l; }\n\n        // =========================================================================================\n        // WHAT FOLLOWS ARE OVERRIDES OF THE VIRTUAL METHODS OF THE REPORTER INTERFACE\n        // =========================================================================================\n\n        void report_query(const QueryData&) override {}\n\n        void test_run_start() override {}\n\n        void test_run_end(const TestRunStats& p) override {\n            // remove .exe extension - mainly to have the same output on UNIX and Windows\n            std::string binary_name = skipPathFromFilename(opt.binary_name.c_str());\n#ifdef DOCTEST_PLATFORM_WINDOWS\n            if(binary_name.rfind(\".exe\") != std::string::npos)\n                binary_name = binary_name.substr(0, binary_name.length() - 4);\n#endif // DOCTEST_PLATFORM_WINDOWS\n            xml.startElement(\"testsuites\");\n            xml.startElement(\"testsuite\").writeAttribute(\"name\", binary_name)\n                    .writeAttribute(\"errors\", testCaseData.totalErrors)\n                    .writeAttribute(\"failures\", testCaseData.totalFailures)\n                    .writeAttribute(\"tests\", p.numAsserts);\n            if(opt.no_time_in_output == false) {\n                xml.writeAttribute(\"time\", testCaseData.totalSeconds);\n                xml.writeAttribute(\"timestamp\", JUnitTestCaseData::getCurrentTimestamp());\n            }\n            if(opt.no_version == false)\n                xml.writeAttribute(\"doctest_version\", DOCTEST_VERSION_STR);\n\n            for(const auto& testCase : testCaseData.testcases) {\n                xml.startElement(\"testcase\")\n                    .writeAttribute(\"classname\", testCase.classname)\n                    .writeAttribute(\"name\", testCase.name);\n                if(opt.no_time_in_output == false)\n                    xml.writeAttribute(\"time\", testCase.time);\n                // This is not ideal, but it should be enough to mimic gtest's junit output.\n                xml.writeAttribute(\"status\", \"run\");\n\n                for(const auto& failure : testCase.failures) {\n                    xml.scopedElement(\"failure\")\n                        .writeAttribute(\"message\", failure.message)\n                        .writeAttribute(\"type\", failure.type)\n                        .writeText(failure.details, false);\n                }\n\n                for(const auto& error : testCase.errors) {\n                    xml.scopedElement(\"error\")\n                        .writeAttribute(\"message\", error.message)\n                        .writeText(error.details);\n                }\n\n                xml.endElement();\n            }\n            xml.endElement();\n            xml.endElement();\n        }\n\n        void test_case_start(const TestCaseData& in) override {\n            testCaseData.add(skipPathFromFilename(in.m_file.c_str()), in.m_name);\n            timer.start();\n        }\n\n        void test_case_reenter(const TestCaseData& in) override {\n            testCaseData.addTime(timer.getElapsedSeconds());\n            testCaseData.appendSubcaseNamesToLastTestcase(deepestSubcaseStackNames);\n            deepestSubcaseStackNames.clear();\n\n            timer.start();\n            testCaseData.add(skipPathFromFilename(in.m_file.c_str()), in.m_name);\n        }\n\n        void test_case_end(const CurrentTestCaseStats&) override {\n            testCaseData.addTime(timer.getElapsedSeconds());\n            testCaseData.appendSubcaseNamesToLastTestcase(deepestSubcaseStackNames);\n            deepestSubcaseStackNames.clear();\n        }\n\n        void test_case_exception(const TestCaseException& e) override {\n            std::lock_guard<std::mutex> lock(mutex);\n            testCaseData.addError(\"exception\", e.error_string.c_str());\n        }\n\n        void subcase_start(const SubcaseSignature& in) override {\n            std::lock_guard<std::mutex> lock(mutex);\n            deepestSubcaseStackNames.push_back(in.m_name);\n        }\n\n        void subcase_end() override {}\n\n        void log_assert(const AssertData& rb) override {\n            if(!rb.m_failed) // report only failures & ignore the `success` option\n                return;\n\n            std::lock_guard<std::mutex> lock(mutex);\n\n            std::ostringstream os;\n            os << skipPathFromFilename(rb.m_file) << (opt.gnu_file_line ? \":\" : \"(\")\n              << line(rb.m_line) << (opt.gnu_file_line ? \":\" : \"):\") << std::endl;\n\n            fulltext_log_assert_to_stream(os, rb);\n            log_contexts(os);\n            testCaseData.addFailure(rb.m_decomp.c_str(), assertString(rb.m_at), os.str());\n        }\n\n        void log_message(const MessageData&) override {}\n\n        void test_case_skipped(const TestCaseData&) override {}\n\n        void log_contexts(std::ostringstream& s) {\n            int num_contexts = get_num_active_contexts();\n            if(num_contexts) {\n                auto contexts = get_active_contexts();\n\n                s << \"  logged: \";\n                for(int i = 0; i < num_contexts; ++i) {\n                    s << (i == 0 ? \"\" : \"          \");\n                    contexts[i]->stringify(&s);\n                    s << std::endl;\n                }\n            }\n        }\n    };\n\n    DOCTEST_REGISTER_REPORTER(\"junit\", 0, JUnitReporter);\n\n    struct Whitespace\n    {\n        int nrSpaces;\n        explicit Whitespace(int nr)\n                : nrSpaces(nr) {}\n    };\n\n    std::ostream& operator<<(std::ostream& out, const Whitespace& ws) {\n        if(ws.nrSpaces != 0)\n            out << std::setw(ws.nrSpaces) << ' ';\n        return out;\n    }\n\n    struct ConsoleReporter : public IReporter\n    {\n        std::ostream&                 s;\n        bool                          hasLoggedCurrentTestStart;\n        std::vector<SubcaseSignature> subcasesStack;\n        size_t                        currentSubcaseLevel;\n        std::mutex                    mutex;\n\n        // caching pointers/references to objects of these types - safe to do\n        const ContextOptions& opt;\n        const TestCaseData*   tc;\n\n        ConsoleReporter(const ContextOptions& co)\n                : s(*co.cout)\n                , opt(co) {}\n\n        ConsoleReporter(const ContextOptions& co, std::ostream& ostr)\n                : s(ostr)\n                , opt(co) {}\n\n        // =========================================================================================\n        // WHAT FOLLOWS ARE HELPERS USED BY THE OVERRIDES OF THE VIRTUAL METHODS OF THE INTERFACE\n        // =========================================================================================\n\n        void separator_to_stream() {\n            s << Color::Yellow\n              << \"===============================================================================\"\n                 \"\\n\";\n        }\n\n        const char* getSuccessOrFailString(bool success, assertType::Enum at,\n                                           const char* success_str) {\n            if(success)\n                return success_str;\n            return failureString(at);\n        }\n\n        Color::Enum getSuccessOrFailColor(bool success, assertType::Enum at) {\n            return success ? Color::BrightGreen :\n                             (at & assertType::is_warn) ? Color::Yellow : Color::Red;\n        }\n\n        void successOrFailColoredStringToStream(bool success, assertType::Enum at,\n                                                const char* success_str = \"SUCCESS\") {\n            s << getSuccessOrFailColor(success, at)\n              << getSuccessOrFailString(success, at, success_str) << \": \";\n        }\n\n        void log_contexts() {\n            int num_contexts = get_num_active_contexts();\n            if(num_contexts) {\n                auto contexts = get_active_contexts();\n\n                s << Color::None << \"  logged: \";\n                for(int i = 0; i < num_contexts; ++i) {\n                    s << (i == 0 ? \"\" : \"          \");\n                    contexts[i]->stringify(&s);\n                    s << \"\\n\";\n                }\n            }\n\n            s << \"\\n\";\n        }\n\n        // this was requested to be made virtual so users could override it\n        virtual void file_line_to_stream(const char* file, int line,\n                                        const char* tail = \"\") {\n            s << Color::LightGrey << skipPathFromFilename(file) << (opt.gnu_file_line ? \":\" : \"(\")\n            << (opt.no_line_numbers ? 0 : line) // 0 or the real num depending on the option\n            << (opt.gnu_file_line ? \":\" : \"):\") << tail;\n        }\n\n        void logTestStart() {\n            if(hasLoggedCurrentTestStart)\n                return;\n\n            separator_to_stream();\n            file_line_to_stream(tc->m_file.c_str(), tc->m_line, \"\\n\");\n            if(tc->m_description)\n                s << Color::Yellow << \"DESCRIPTION: \" << Color::None << tc->m_description << \"\\n\";\n            if(tc->m_test_suite && tc->m_test_suite[0] != '\\0')\n                s << Color::Yellow << \"TEST SUITE: \" << Color::None << tc->m_test_suite << \"\\n\";\n            if(strncmp(tc->m_name, \"  Scenario:\", 11) != 0)\n                s << Color::Yellow << \"TEST CASE:  \";\n            s << Color::None << tc->m_name << \"\\n\";\n\n            for(size_t i = 0; i < currentSubcaseLevel; ++i) {\n                if(subcasesStack[i].m_name[0] != '\\0')\n                    s << \"  \" << subcasesStack[i].m_name << \"\\n\";\n            }\n\n            if(currentSubcaseLevel != subcasesStack.size()) {\n                s << Color::Yellow << \"\\nDEEPEST SUBCASE STACK REACHED (DIFFERENT FROM THE CURRENT ONE):\\n\" << Color::None;\n                for(size_t i = 0; i < subcasesStack.size(); ++i) {\n                    if(subcasesStack[i].m_name[0] != '\\0')\n                        s << \"  \" << subcasesStack[i].m_name << \"\\n\";\n                }\n            }\n\n            s << \"\\n\";\n\n            hasLoggedCurrentTestStart = true;\n        }\n\n        void printVersion() {\n            if(opt.no_version == false)\n                s << Color::Cyan << \"[doctest] \" << Color::None << \"doctest version is \\\"\"\n                  << DOCTEST_VERSION_STR << \"\\\"\\n\";\n        }\n\n        void printIntro() {\n            printVersion();\n            s << Color::Cyan << \"[doctest] \" << Color::None\n              << \"run with \\\"--\" DOCTEST_OPTIONS_PREFIX_DISPLAY \"help\\\" for options\\n\";\n        }\n\n        void printHelp() {\n            int sizePrefixDisplay = static_cast<int>(strlen(DOCTEST_OPTIONS_PREFIX_DISPLAY));\n            printVersion();\n            // clang-format off\n            s << Color::Cyan << \"[doctest]\\n\" << Color::None;\n            s << Color::Cyan << \"[doctest] \" << Color::None;\n            s << \"boolean values: \\\"1/on/yes/true\\\" or \\\"0/off/no/false\\\"\\n\";\n            s << Color::Cyan << \"[doctest] \" << Color::None;\n            s << \"filter  values: \\\"str1,str2,str3\\\" (comma separated strings)\\n\";\n            s << Color::Cyan << \"[doctest]\\n\" << Color::None;\n            s << Color::Cyan << \"[doctest] \" << Color::None;\n            s << \"filters use wildcards for matching strings\\n\";\n            s << Color::Cyan << \"[doctest] \" << Color::None;\n            s << \"something passes a filter if any of the strings in a filter matches\\n\";\n#ifndef DOCTEST_CONFIG_NO_UNPREFIXED_OPTIONS\n            s << Color::Cyan << \"[doctest]\\n\" << Color::None;\n            s << Color::Cyan << \"[doctest] \" << Color::None;\n            s << \"ALL FLAGS, OPTIONS AND FILTERS ALSO AVAILABLE WITH A \\\"\" DOCTEST_CONFIG_OPTIONS_PREFIX \"\\\" PREFIX!!!\\n\";\n#endif\n            s << Color::Cyan << \"[doctest]\\n\" << Color::None;\n            s << Color::Cyan << \"[doctest] \" << Color::None;\n            s << \"Query flags - the program quits after them. Available:\\n\\n\";\n            s << \" -\" DOCTEST_OPTIONS_PREFIX_DISPLAY \"?,   --\" DOCTEST_OPTIONS_PREFIX_DISPLAY \"help, -\" DOCTEST_OPTIONS_PREFIX_DISPLAY \"h                      \"\n              << Whitespace(sizePrefixDisplay*0) <<  \"prints this message\\n\";\n            s << \" -\" DOCTEST_OPTIONS_PREFIX_DISPLAY \"v,   --\" DOCTEST_OPTIONS_PREFIX_DISPLAY \"version                       \"\n              << Whitespace(sizePrefixDisplay*1) << \"prints the version\\n\";\n            s << \" -\" DOCTEST_OPTIONS_PREFIX_DISPLAY \"c,   --\" DOCTEST_OPTIONS_PREFIX_DISPLAY \"count                         \"\n              << Whitespace(sizePrefixDisplay*1) << \"prints the number of matching tests\\n\";\n            s << \" -\" DOCTEST_OPTIONS_PREFIX_DISPLAY \"ltc, --\" DOCTEST_OPTIONS_PREFIX_DISPLAY \"list-test-cases               \"\n              << Whitespace(sizePrefixDisplay*1) << \"lists all matching tests by name\\n\";\n            s << \" -\" DOCTEST_OPTIONS_PREFIX_DISPLAY \"lts, --\" DOCTEST_OPTIONS_PREFIX_DISPLAY \"list-test-suites              \"\n              << Whitespace(sizePrefixDisplay*1) << \"lists all matching test suites\\n\";\n            s << \" -\" DOCTEST_OPTIONS_PREFIX_DISPLAY \"lr,  --\" DOCTEST_OPTIONS_PREFIX_DISPLAY \"list-reporters                \"\n              << Whitespace(sizePrefixDisplay*1) << \"lists all registered reporters\\n\\n\";\n            // ================================================================================== << 79\n            s << Color::Cyan << \"[doctest] \" << Color::None;\n            s << \"The available <int>/<string> options/filters are:\\n\\n\";\n            s << \" -\" DOCTEST_OPTIONS_PREFIX_DISPLAY \"tc,  --\" DOCTEST_OPTIONS_PREFIX_DISPLAY \"test-case=<filters>           \"\n              << Whitespace(sizePrefixDisplay*1) << \"filters     tests by their name\\n\";\n            s << \" -\" DOCTEST_OPTIONS_PREFIX_DISPLAY \"tce, --\" DOCTEST_OPTIONS_PREFIX_DISPLAY \"test-case-exclude=<filters>   \"\n              << Whitespace(sizePrefixDisplay*1) << \"filters OUT tests by their name\\n\";\n            s << \" -\" DOCTEST_OPTIONS_PREFIX_DISPLAY \"sf,  --\" DOCTEST_OPTIONS_PREFIX_DISPLAY \"source-file=<filters>         \"\n              << Whitespace(sizePrefixDisplay*1) << \"filters     tests by their file\\n\";\n            s << \" -\" DOCTEST_OPTIONS_PREFIX_DISPLAY \"sfe, --\" DOCTEST_OPTIONS_PREFIX_DISPLAY \"source-file-exclude=<filters> \"\n              << Whitespace(sizePrefixDisplay*1) << \"filters OUT tests by their file\\n\";\n            s << \" -\" DOCTEST_OPTIONS_PREFIX_DISPLAY \"ts,  --\" DOCTEST_OPTIONS_PREFIX_DISPLAY \"test-suite=<filters>          \"\n              << Whitespace(sizePrefixDisplay*1) << \"filters     tests by their test suite\\n\";\n            s << \" -\" DOCTEST_OPTIONS_PREFIX_DISPLAY \"tse, --\" DOCTEST_OPTIONS_PREFIX_DISPLAY \"test-suite-exclude=<filters>  \"\n              << Whitespace(sizePrefixDisplay*1) << \"filters OUT tests by their test suite\\n\";\n            s << \" -\" DOCTEST_OPTIONS_PREFIX_DISPLAY \"sc,  --\" DOCTEST_OPTIONS_PREFIX_DISPLAY \"subcase=<filters>             \"\n              << Whitespace(sizePrefixDisplay*1) << \"filters     subcases by their name\\n\";\n            s << \" -\" DOCTEST_OPTIONS_PREFIX_DISPLAY \"sce, --\" DOCTEST_OPTIONS_PREFIX_DISPLAY \"subcase-exclude=<filters>     \"\n              << Whitespace(sizePrefixDisplay*1) << \"filters OUT subcases by their name\\n\";\n            s << \" -\" DOCTEST_OPTIONS_PREFIX_DISPLAY \"r,   --\" DOCTEST_OPTIONS_PREFIX_DISPLAY \"reporters=<filters>           \"\n              << Whitespace(sizePrefixDisplay*1) << \"reporters to use (console is default)\\n\";\n            s << \" -\" DOCTEST_OPTIONS_PREFIX_DISPLAY \"o,   --\" DOCTEST_OPTIONS_PREFIX_DISPLAY \"out=<string>                  \"\n              << Whitespace(sizePrefixDisplay*1) << \"output filename\\n\";\n            s << \" -\" DOCTEST_OPTIONS_PREFIX_DISPLAY \"ob,  --\" DOCTEST_OPTIONS_PREFIX_DISPLAY \"order-by=<string>             \"\n              << Whitespace(sizePrefixDisplay*1) << \"how the tests should be ordered\\n\";\n            s << Whitespace(sizePrefixDisplay*3) << \"                                       <string> - [file/suite/name/rand/none]\\n\";\n            s << \" -\" DOCTEST_OPTIONS_PREFIX_DISPLAY \"rs,  --\" DOCTEST_OPTIONS_PREFIX_DISPLAY \"rand-seed=<int>               \"\n              << Whitespace(sizePrefixDisplay*1) << \"seed for random ordering\\n\";\n            s << \" -\" DOCTEST_OPTIONS_PREFIX_DISPLAY \"f,   --\" DOCTEST_OPTIONS_PREFIX_DISPLAY \"first=<int>                   \"\n              << Whitespace(sizePrefixDisplay*1) << \"the first test passing the filters to\\n\";\n            s << Whitespace(sizePrefixDisplay*3) << \"                                       execute - for range-based execution\\n\";\n            s << \" -\" DOCTEST_OPTIONS_PREFIX_DISPLAY \"l,   --\" DOCTEST_OPTIONS_PREFIX_DISPLAY \"last=<int>                    \"\n              << Whitespace(sizePrefixDisplay*1) << \"the last test passing the filters to\\n\";\n            s << Whitespace(sizePrefixDisplay*3) << \"                                       execute - for range-based execution\\n\";\n            s << \" -\" DOCTEST_OPTIONS_PREFIX_DISPLAY \"aa,  --\" DOCTEST_OPTIONS_PREFIX_DISPLAY \"abort-after=<int>             \"\n              << Whitespace(sizePrefixDisplay*1) << \"stop after <int> failed assertions\\n\";\n            s << \" -\" DOCTEST_OPTIONS_PREFIX_DISPLAY \"scfl,--\" DOCTEST_OPTIONS_PREFIX_DISPLAY \"subcase-filter-levels=<int>   \"\n              << Whitespace(sizePrefixDisplay*1) << \"apply filters for the first <int> levels\\n\";\n            s << Color::Cyan << \"\\n[doctest] \" << Color::None;\n            s << \"Bool options - can be used like flags and true is assumed. Available:\\n\\n\";\n            s << \" -\" DOCTEST_OPTIONS_PREFIX_DISPLAY \"s,   --\" DOCTEST_OPTIONS_PREFIX_DISPLAY \"success=<bool>                \"\n              << Whitespace(sizePrefixDisplay*1) << \"include successful assertions in output\\n\";\n            s << \" -\" DOCTEST_OPTIONS_PREFIX_DISPLAY \"cs,  --\" DOCTEST_OPTIONS_PREFIX_DISPLAY \"case-sensitive=<bool>         \"\n              << Whitespace(sizePrefixDisplay*1) << \"filters being treated as case sensitive\\n\";\n            s << \" -\" DOCTEST_OPTIONS_PREFIX_DISPLAY \"e,   --\" DOCTEST_OPTIONS_PREFIX_DISPLAY \"exit=<bool>                   \"\n              << Whitespace(sizePrefixDisplay*1) << \"exits after the tests finish\\n\";\n            s << \" -\" DOCTEST_OPTIONS_PREFIX_DISPLAY \"d,   --\" DOCTEST_OPTIONS_PREFIX_DISPLAY \"duration=<bool>               \"\n              << Whitespace(sizePrefixDisplay*1) << \"prints the time duration of each test\\n\";\n            s << \" -\" DOCTEST_OPTIONS_PREFIX_DISPLAY \"nt,  --\" DOCTEST_OPTIONS_PREFIX_DISPLAY \"no-throw=<bool>               \"\n              << Whitespace(sizePrefixDisplay*1) << \"skips exceptions-related assert checks\\n\";\n            s << \" -\" DOCTEST_OPTIONS_PREFIX_DISPLAY \"ne,  --\" DOCTEST_OPTIONS_PREFIX_DISPLAY \"no-exitcode=<bool>            \"\n              << Whitespace(sizePrefixDisplay*1) << \"returns (or exits) always with success\\n\";\n            s << \" -\" DOCTEST_OPTIONS_PREFIX_DISPLAY \"nr,  --\" DOCTEST_OPTIONS_PREFIX_DISPLAY \"no-run=<bool>                 \"\n              << Whitespace(sizePrefixDisplay*1) << \"skips all runtime doctest operations\\n\";\n            s << \" -\" DOCTEST_OPTIONS_PREFIX_DISPLAY \"nv,  --\" DOCTEST_OPTIONS_PREFIX_DISPLAY \"no-version=<bool>             \"\n              << Whitespace(sizePrefixDisplay*1) << \"omit the framework version in the output\\n\";\n            s << \" -\" DOCTEST_OPTIONS_PREFIX_DISPLAY \"nc,  --\" DOCTEST_OPTIONS_PREFIX_DISPLAY \"no-colors=<bool>              \"\n              << Whitespace(sizePrefixDisplay*1) << \"disables colors in output\\n\";\n            s << \" -\" DOCTEST_OPTIONS_PREFIX_DISPLAY \"fc,  --\" DOCTEST_OPTIONS_PREFIX_DISPLAY \"force-colors=<bool>           \"\n              << Whitespace(sizePrefixDisplay*1) << \"use colors even when not in a tty\\n\";\n            s << \" -\" DOCTEST_OPTIONS_PREFIX_DISPLAY \"nb,  --\" DOCTEST_OPTIONS_PREFIX_DISPLAY \"no-breaks=<bool>              \"\n              << Whitespace(sizePrefixDisplay*1) << \"disables breakpoints in debuggers\\n\";\n            s << \" -\" DOCTEST_OPTIONS_PREFIX_DISPLAY \"ns,  --\" DOCTEST_OPTIONS_PREFIX_DISPLAY \"no-skip=<bool>                \"\n              << Whitespace(sizePrefixDisplay*1) << \"don't skip test cases marked as skip\\n\";\n            s << \" -\" DOCTEST_OPTIONS_PREFIX_DISPLAY \"gfl, --\" DOCTEST_OPTIONS_PREFIX_DISPLAY \"gnu-file-line=<bool>          \"\n              << Whitespace(sizePrefixDisplay*1) << \":n: vs (n): for line numbers in output\\n\";\n            s << \" -\" DOCTEST_OPTIONS_PREFIX_DISPLAY \"npf, --\" DOCTEST_OPTIONS_PREFIX_DISPLAY \"no-path-filenames=<bool>      \"\n              << Whitespace(sizePrefixDisplay*1) << \"only filenames and no paths in output\\n\";\n            s << \" -\" DOCTEST_OPTIONS_PREFIX_DISPLAY \"nln, --\" DOCTEST_OPTIONS_PREFIX_DISPLAY \"no-line-numbers=<bool>        \"\n              << Whitespace(sizePrefixDisplay*1) << \"0 instead of real line numbers in output\\n\";\n            // ================================================================================== << 79\n            // clang-format on\n\n            s << Color::Cyan << \"\\n[doctest] \" << Color::None;\n            s << \"for more information visit the project documentation\\n\\n\";\n        }\n\n        void printRegisteredReporters() {\n            printVersion();\n            auto printReporters = [this] (const reporterMap& reporters, const char* type) {\n                if(reporters.size()) {\n                    s << Color::Cyan << \"[doctest] \" << Color::None << \"listing all registered \" << type << \"\\n\";\n                    for(auto& curr : reporters)\n                        s << \"priority: \" << std::setw(5) << curr.first.first\n                          << \" name: \" << curr.first.second << \"\\n\";\n                }\n            };\n            printReporters(getListeners(), \"listeners\");\n            printReporters(getReporters(), \"reporters\");\n        }\n\n        void list_query_results() {\n            separator_to_stream();\n            if(opt.count || opt.list_test_cases) {\n                s << Color::Cyan << \"[doctest] \" << Color::None\n                  << \"unskipped test cases passing the current filters: \"\n                  << g_cs->numTestCasesPassingFilters << \"\\n\";\n            } else if(opt.list_test_suites) {\n                s << Color::Cyan << \"[doctest] \" << Color::None\n                  << \"unskipped test cases passing the current filters: \"\n                  << g_cs->numTestCasesPassingFilters << \"\\n\";\n                s << Color::Cyan << \"[doctest] \" << Color::None\n                  << \"test suites with unskipped test cases passing the current filters: \"\n                  << g_cs->numTestSuitesPassingFilters << \"\\n\";\n            }\n        }\n\n        // =========================================================================================\n        // WHAT FOLLOWS ARE OVERRIDES OF THE VIRTUAL METHODS OF THE REPORTER INTERFACE\n        // =========================================================================================\n\n        void report_query(const QueryData& in) override {\n            if(opt.version) {\n                printVersion();\n            } else if(opt.help) {\n                printHelp();\n            } else if(opt.list_reporters) {\n                printRegisteredReporters();\n            } else if(opt.count || opt.list_test_cases) {\n                if(opt.list_test_cases) {\n                    s << Color::Cyan << \"[doctest] \" << Color::None\n                      << \"listing all test case names\\n\";\n                    separator_to_stream();\n                }\n\n                for(unsigned i = 0; i < in.num_data; ++i)\n                    s << Color::None << in.data[i]->m_name << \"\\n\";\n\n                separator_to_stream();\n\n                s << Color::Cyan << \"[doctest] \" << Color::None\n                  << \"unskipped test cases passing the current filters: \"\n                  << g_cs->numTestCasesPassingFilters << \"\\n\";\n\n            } else if(opt.list_test_suites) {\n                s << Color::Cyan << \"[doctest] \" << Color::None << \"listing all test suites\\n\";\n                separator_to_stream();\n\n                for(unsigned i = 0; i < in.num_data; ++i)\n                    s << Color::None << in.data[i]->m_test_suite << \"\\n\";\n\n                separator_to_stream();\n\n                s << Color::Cyan << \"[doctest] \" << Color::None\n                  << \"unskipped test cases passing the current filters: \"\n                  << g_cs->numTestCasesPassingFilters << \"\\n\";\n                s << Color::Cyan << \"[doctest] \" << Color::None\n                  << \"test suites with unskipped test cases passing the current filters: \"\n                  << g_cs->numTestSuitesPassingFilters << \"\\n\";\n            }\n        }\n\n        void test_run_start() override { printIntro(); }\n\n        void test_run_end(const TestRunStats& p) override {\n            separator_to_stream();\n            s << std::dec;\n\n            auto totwidth = int(std::ceil(log10((std::max(p.numTestCasesPassingFilters, static_cast<unsigned>(p.numAsserts))) + 1)));\n            auto passwidth = int(std::ceil(log10((std::max(p.numTestCasesPassingFilters - p.numTestCasesFailed, static_cast<unsigned>(p.numAsserts - p.numAssertsFailed))) + 1)));\n            auto failwidth = int(std::ceil(log10((std::max(p.numTestCasesFailed, static_cast<unsigned>(p.numAssertsFailed))) + 1)));\n            const bool anythingFailed = p.numTestCasesFailed > 0 || p.numAssertsFailed > 0;\n            s << Color::Cyan << \"[doctest] \" << Color::None << \"test cases: \" << std::setw(totwidth)\n              << p.numTestCasesPassingFilters << \" | \"\n              << ((p.numTestCasesPassingFilters == 0 || anythingFailed) ? Color::None :\n                                                                          Color::Green)\n              << std::setw(passwidth) << p.numTestCasesPassingFilters - p.numTestCasesFailed << \" passed\"\n              << Color::None << \" | \" << (p.numTestCasesFailed > 0 ? Color::Red : Color::None)\n              << std::setw(failwidth) << p.numTestCasesFailed << \" failed\" << Color::None << \" |\";\n            if(opt.no_skipped_summary == false) {\n                const int numSkipped = p.numTestCases - p.numTestCasesPassingFilters;\n                s << \" \" << (numSkipped == 0 ? Color::None : Color::Yellow) << numSkipped\n                  << \" skipped\" << Color::None;\n            }\n            s << \"\\n\";\n            s << Color::Cyan << \"[doctest] \" << Color::None << \"assertions: \" << std::setw(totwidth)\n              << p.numAsserts << \" | \"\n              << ((p.numAsserts == 0 || anythingFailed) ? Color::None : Color::Green)\n              << std::setw(passwidth) << (p.numAsserts - p.numAssertsFailed) << \" passed\" << Color::None\n              << \" | \" << (p.numAssertsFailed > 0 ? Color::Red : Color::None) << std::setw(failwidth)\n              << p.numAssertsFailed << \" failed\" << Color::None << \" |\\n\";\n            s << Color::Cyan << \"[doctest] \" << Color::None\n              << \"Status: \" << (p.numTestCasesFailed > 0 ? Color::Red : Color::Green)\n              << ((p.numTestCasesFailed > 0) ? \"FAILURE!\" : \"SUCCESS!\") << Color::None << std::endl;\n        }\n\n        void test_case_start(const TestCaseData& in) override {\n            hasLoggedCurrentTestStart = false;\n            tc                        = &in;\n            subcasesStack.clear();\n            currentSubcaseLevel = 0;\n        }\n        \n        void test_case_reenter(const TestCaseData&) override {\n            subcasesStack.clear();\n        }\n\n        void test_case_end(const CurrentTestCaseStats& st) override {\n            if(tc->m_no_output)\n                return;\n\n            // log the preamble of the test case only if there is something\n            // else to print - something other than that an assert has failed\n            if(opt.duration ||\n               (st.failure_flags && st.failure_flags != TestCaseFailureReason::AssertFailure))\n                logTestStart();\n\n            if(opt.duration)\n                s << Color::None << std::setprecision(6) << std::fixed << st.seconds\n                  << \" s: \" << tc->m_name << \"\\n\";\n\n            if(st.failure_flags & TestCaseFailureReason::Timeout)\n                s << Color::Red << \"Test case exceeded time limit of \" << std::setprecision(6)\n                  << std::fixed << tc->m_timeout << \"!\\n\";\n\n            if(st.failure_flags & TestCaseFailureReason::ShouldHaveFailedButDidnt) {\n                s << Color::Red << \"Should have failed but didn't! Marking it as failed!\\n\";\n            } else if(st.failure_flags & TestCaseFailureReason::ShouldHaveFailedAndDid) {\n                s << Color::Yellow << \"Failed as expected so marking it as not failed\\n\";\n            } else if(st.failure_flags & TestCaseFailureReason::CouldHaveFailedAndDid) {\n                s << Color::Yellow << \"Allowed to fail so marking it as not failed\\n\";\n            } else if(st.failure_flags & TestCaseFailureReason::DidntFailExactlyNumTimes) {\n                s << Color::Red << \"Didn't fail exactly \" << tc->m_expected_failures\n                  << \" times so marking it as failed!\\n\";\n            } else if(st.failure_flags & TestCaseFailureReason::FailedExactlyNumTimes) {\n                s << Color::Yellow << \"Failed exactly \" << tc->m_expected_failures\n                  << \" times as expected so marking it as not failed!\\n\";\n            }\n            if(st.failure_flags & TestCaseFailureReason::TooManyFailedAsserts) {\n                s << Color::Red << \"Aborting - too many failed asserts!\\n\";\n            }\n            s << Color::None; // lgtm [cpp/useless-expression]\n        }\n\n        void test_case_exception(const TestCaseException& e) override {\n            if(tc->m_no_output)\n                return;\n\n            logTestStart();\n\n            file_line_to_stream(tc->m_file.c_str(), tc->m_line, \" \");\n            successOrFailColoredStringToStream(false, e.is_crash ? assertType::is_require :\n                                                                   assertType::is_check);\n            s << Color::Red << (e.is_crash ? \"test case CRASHED: \" : \"test case THREW exception: \")\n              << Color::Cyan << e.error_string << \"\\n\";\n\n            int num_stringified_contexts = get_num_stringified_contexts();\n            if(num_stringified_contexts) {\n                auto stringified_contexts = get_stringified_contexts();\n                s << Color::None << \"  logged: \";\n                for(int i = num_stringified_contexts; i > 0; --i) {\n                    s << (i == num_stringified_contexts ? \"\" : \"          \")\n                      << stringified_contexts[i - 1] << \"\\n\";\n                }\n            }\n            s << \"\\n\" << Color::None;\n        }\n\n        void subcase_start(const SubcaseSignature& subc) override {\n            std::lock_guard<std::mutex> lock(mutex);\n            subcasesStack.push_back(subc);\n            ++currentSubcaseLevel;\n            hasLoggedCurrentTestStart = false;\n        }\n\n        void subcase_end() override {\n            std::lock_guard<std::mutex> lock(mutex);\n            --currentSubcaseLevel;\n            hasLoggedCurrentTestStart = false;\n        }\n\n        void log_assert(const AssertData& rb) override {\n            if((!rb.m_failed && !opt.success) || tc->m_no_output)\n                return;\n\n            std::lock_guard<std::mutex> lock(mutex);\n\n            logTestStart();\n\n            file_line_to_stream(rb.m_file, rb.m_line, \" \");\n            successOrFailColoredStringToStream(!rb.m_failed, rb.m_at);\n\n            fulltext_log_assert_to_stream(s, rb);\n\n            log_contexts();\n        }\n\n        void log_message(const MessageData& mb) override {\n            if(tc->m_no_output)\n                return;\n\n            std::lock_guard<std::mutex> lock(mutex);\n\n            logTestStart();\n\n            file_line_to_stream(mb.m_file, mb.m_line, \" \");\n            s << getSuccessOrFailColor(false, mb.m_severity)\n              << getSuccessOrFailString(mb.m_severity & assertType::is_warn, mb.m_severity,\n                                        \"MESSAGE\") << \": \";\n            s << Color::None << mb.m_string << \"\\n\";\n            log_contexts();\n        }\n\n        void test_case_skipped(const TestCaseData&) override {}\n    };\n\n    DOCTEST_REGISTER_REPORTER(\"console\", 0, ConsoleReporter);\n\n#ifdef DOCTEST_PLATFORM_WINDOWS\n    struct DebugOutputWindowReporter : public ConsoleReporter\n    {\n        DOCTEST_THREAD_LOCAL static std::ostringstream oss;\n\n        DebugOutputWindowReporter(const ContextOptions& co)\n                : ConsoleReporter(co, oss) {}\n\n#define DOCTEST_DEBUG_OUTPUT_REPORTER_OVERRIDE(func, type, arg)                                    \\\n    void func(type arg) override {                                                                 \\\n        bool with_col = g_no_colors;                                                               \\\n        g_no_colors   = false;                                                                     \\\n        ConsoleReporter::func(arg);                                                                \\\n        DOCTEST_OUTPUT_DEBUG_STRING(oss.str().c_str());                                            \\\n        oss.str(\"\");                                                                               \\\n        g_no_colors = with_col;                                                                    \\\n    }\n\n        DOCTEST_DEBUG_OUTPUT_REPORTER_OVERRIDE(test_run_start, DOCTEST_EMPTY, DOCTEST_EMPTY)\n        DOCTEST_DEBUG_OUTPUT_REPORTER_OVERRIDE(test_run_end, const TestRunStats&, in)\n        DOCTEST_DEBUG_OUTPUT_REPORTER_OVERRIDE(test_case_start, const TestCaseData&, in)\n        DOCTEST_DEBUG_OUTPUT_REPORTER_OVERRIDE(test_case_reenter, const TestCaseData&, in)\n        DOCTEST_DEBUG_OUTPUT_REPORTER_OVERRIDE(test_case_end, const CurrentTestCaseStats&, in)\n        DOCTEST_DEBUG_OUTPUT_REPORTER_OVERRIDE(test_case_exception, const TestCaseException&, in)\n        DOCTEST_DEBUG_OUTPUT_REPORTER_OVERRIDE(subcase_start, const SubcaseSignature&, in)\n        DOCTEST_DEBUG_OUTPUT_REPORTER_OVERRIDE(subcase_end, DOCTEST_EMPTY, DOCTEST_EMPTY)\n        DOCTEST_DEBUG_OUTPUT_REPORTER_OVERRIDE(log_assert, const AssertData&, in)\n        DOCTEST_DEBUG_OUTPUT_REPORTER_OVERRIDE(log_message, const MessageData&, in)\n        DOCTEST_DEBUG_OUTPUT_REPORTER_OVERRIDE(test_case_skipped, const TestCaseData&, in)\n    };\n\n    DOCTEST_THREAD_LOCAL std::ostringstream DebugOutputWindowReporter::oss;\n#endif // DOCTEST_PLATFORM_WINDOWS\n\n    // the implementation of parseOption()\n    bool parseOptionImpl(int argc, const char* const* argv, const char* pattern, String* value) {\n        // going from the end to the beginning and stopping on the first occurrence from the end\n        for(int i = argc; i > 0; --i) {\n            auto index = i - 1;\n            auto temp = std::strstr(argv[index], pattern);\n            if(temp && (value || strlen(temp) == strlen(pattern))) { //!OCLINT prefer early exits and continue\n                // eliminate matches in which the chars before the option are not '-'\n                bool noBadCharsFound = true;\n                auto curr            = argv[index];\n                while(curr != temp) {\n                    if(*curr++ != '-') {\n                        noBadCharsFound = false;\n                        break;\n                    }\n                }\n                if(noBadCharsFound && argv[index][0] == '-') {\n                    if(value) {\n                        // parsing the value of an option\n                        temp += strlen(pattern);\n                        const unsigned len = strlen(temp);\n                        if(len) {\n                            *value = temp;\n                            return true;\n                        }\n                    } else {\n                        // just a flag - no value\n                        return true;\n                    }\n                }\n            }\n        }\n        return false;\n    }\n\n    // parses an option and returns the string after the '=' character\n    bool parseOption(int argc, const char* const* argv, const char* pattern, String* value = nullptr,\n                     const String& defaultVal = String()) {\n        if(value)\n            *value = defaultVal;\n#ifndef DOCTEST_CONFIG_NO_UNPREFIXED_OPTIONS\n        // offset (normally 3 for \"dt-\") to skip prefix\n        if(parseOptionImpl(argc, argv, pattern + strlen(DOCTEST_CONFIG_OPTIONS_PREFIX), value))\n            return true;\n#endif // DOCTEST_CONFIG_NO_UNPREFIXED_OPTIONS\n        return parseOptionImpl(argc, argv, pattern, value);\n    }\n\n    // locates a flag on the command line\n    bool parseFlag(int argc, const char* const* argv, const char* pattern) {\n        return parseOption(argc, argv, pattern);\n    }\n\n    // parses a comma separated list of words after a pattern in one of the arguments in argv\n    bool parseCommaSepArgs(int argc, const char* const* argv, const char* pattern,\n                           std::vector<String>& res) {\n        String filtersString;\n        if(parseOption(argc, argv, pattern, &filtersString)) {\n            // tokenize with \",\" as a separator\n            // cppcheck-suppress strtokCalled\n            DOCTEST_CLANG_SUPPRESS_WARNING_WITH_PUSH(\"-Wdeprecated-declarations\")\n            auto pch = std::strtok(filtersString.c_str(), \",\"); // modifies the string\n            while(pch != nullptr) {\n                if(strlen(pch))\n                    res.push_back(pch);\n                // uses the strtok() internal state to go to the next token\n                // cppcheck-suppress strtokCalled\n                pch = std::strtok(nullptr, \",\");\n            }\n            DOCTEST_CLANG_SUPPRESS_WARNING_POP\n            return true;\n        }\n        return false;\n    }\n\n    enum optionType\n    {\n        option_bool,\n        option_int\n    };\n\n    // parses an int/bool option from the command line\n    bool parseIntOption(int argc, const char* const* argv, const char* pattern, optionType type,\n                        int& res) {\n        String parsedValue;\n        if(!parseOption(argc, argv, pattern, &parsedValue))\n            return false;\n\n        if(type == 0) {\n            // boolean\n            const char positive[][5] = {\"1\", \"true\", \"on\", \"yes\"};  // 5 - strlen(\"true\") + 1\n            const char negative[][6] = {\"0\", \"false\", \"off\", \"no\"}; // 6 - strlen(\"false\") + 1\n\n            // if the value matches any of the positive/negative possibilities\n            for(unsigned i = 0; i < 4; i++) {\n                if(parsedValue.compare(positive[i], true) == 0) {\n                    res = 1; //!OCLINT parameter reassignment\n                    return true;\n                }\n                if(parsedValue.compare(negative[i], true) == 0) {\n                    res = 0; //!OCLINT parameter reassignment\n                    return true;\n                }\n            }\n        } else {\n            // integer\n            // TODO: change this to use std::stoi or something else! currently it uses undefined behavior - assumes '0' on failed parse...\n            int theInt = std::atoi(parsedValue.c_str()); // NOLINT\n            if(theInt != 0) {\n                res = theInt; //!OCLINT parameter reassignment\n                return true;\n            }\n        }\n        return false;\n    }\n} // namespace\n\nContext::Context(int argc, const char* const* argv)\n        : p(new detail::ContextState) {\n    parseArgs(argc, argv, true);\n    if(argc)\n        p->binary_name = argv[0];\n}\n\nContext::~Context() {\n    if(g_cs == p)\n        g_cs = nullptr;\n    delete p;\n}\n\nvoid Context::applyCommandLine(int argc, const char* const* argv) {\n    parseArgs(argc, argv);\n    if(argc)\n        p->binary_name = argv[0];\n}\n\n// parses args\nvoid Context::parseArgs(int argc, const char* const* argv, bool withDefaults) {\n    using namespace detail;\n\n    // clang-format off\n    parseCommaSepArgs(argc, argv, DOCTEST_CONFIG_OPTIONS_PREFIX \"source-file=\",        p->filters[0]);\n    parseCommaSepArgs(argc, argv, DOCTEST_CONFIG_OPTIONS_PREFIX \"sf=\",                 p->filters[0]);\n    parseCommaSepArgs(argc, argv, DOCTEST_CONFIG_OPTIONS_PREFIX \"source-file-exclude=\",p->filters[1]);\n    parseCommaSepArgs(argc, argv, DOCTEST_CONFIG_OPTIONS_PREFIX \"sfe=\",                p->filters[1]);\n    parseCommaSepArgs(argc, argv, DOCTEST_CONFIG_OPTIONS_PREFIX \"test-suite=\",         p->filters[2]);\n    parseCommaSepArgs(argc, argv, DOCTEST_CONFIG_OPTIONS_PREFIX \"ts=\",                 p->filters[2]);\n    parseCommaSepArgs(argc, argv, DOCTEST_CONFIG_OPTIONS_PREFIX \"test-suite-exclude=\", p->filters[3]);\n    parseCommaSepArgs(argc, argv, DOCTEST_CONFIG_OPTIONS_PREFIX \"tse=\",                p->filters[3]);\n    parseCommaSepArgs(argc, argv, DOCTEST_CONFIG_OPTIONS_PREFIX \"test-case=\",          p->filters[4]);\n    parseCommaSepArgs(argc, argv, DOCTEST_CONFIG_OPTIONS_PREFIX \"tc=\",                 p->filters[4]);\n    parseCommaSepArgs(argc, argv, DOCTEST_CONFIG_OPTIONS_PREFIX \"test-case-exclude=\",  p->filters[5]);\n    parseCommaSepArgs(argc, argv, DOCTEST_CONFIG_OPTIONS_PREFIX \"tce=\",                p->filters[5]);\n    parseCommaSepArgs(argc, argv, DOCTEST_CONFIG_OPTIONS_PREFIX \"subcase=\",            p->filters[6]);\n    parseCommaSepArgs(argc, argv, DOCTEST_CONFIG_OPTIONS_PREFIX \"sc=\",                 p->filters[6]);\n    parseCommaSepArgs(argc, argv, DOCTEST_CONFIG_OPTIONS_PREFIX \"subcase-exclude=\",    p->filters[7]);\n    parseCommaSepArgs(argc, argv, DOCTEST_CONFIG_OPTIONS_PREFIX \"sce=\",                p->filters[7]);\n    parseCommaSepArgs(argc, argv, DOCTEST_CONFIG_OPTIONS_PREFIX \"reporters=\",          p->filters[8]);\n    parseCommaSepArgs(argc, argv, DOCTEST_CONFIG_OPTIONS_PREFIX \"r=\",                  p->filters[8]);\n    // clang-format on\n\n    int    intRes = 0;\n    String strRes;\n\n#define DOCTEST_PARSE_AS_BOOL_OR_FLAG(name, sname, var, default)                                   \\\n    if(parseIntOption(argc, argv, DOCTEST_CONFIG_OPTIONS_PREFIX name \"=\", option_bool, intRes) ||  \\\n       parseIntOption(argc, argv, DOCTEST_CONFIG_OPTIONS_PREFIX sname \"=\", option_bool, intRes))   \\\n        p->var = !!intRes;                                                                         \\\n    else if(parseFlag(argc, argv, DOCTEST_CONFIG_OPTIONS_PREFIX name) ||                           \\\n            parseFlag(argc, argv, DOCTEST_CONFIG_OPTIONS_PREFIX sname))                            \\\n        p->var = true;                                                                             \\\n    else if(withDefaults)                                                                          \\\n    p->var = default\n\n#define DOCTEST_PARSE_INT_OPTION(name, sname, var, default)                                        \\\n    if(parseIntOption(argc, argv, DOCTEST_CONFIG_OPTIONS_PREFIX name \"=\", option_int, intRes) ||   \\\n       parseIntOption(argc, argv, DOCTEST_CONFIG_OPTIONS_PREFIX sname \"=\", option_int, intRes))    \\\n        p->var = intRes;                                                                           \\\n    else if(withDefaults)                                                                          \\\n    p->var = default\n\n#define DOCTEST_PARSE_STR_OPTION(name, sname, var, default)                                        \\\n    if(parseOption(argc, argv, DOCTEST_CONFIG_OPTIONS_PREFIX name \"=\", &strRes, default) ||        \\\n       parseOption(argc, argv, DOCTEST_CONFIG_OPTIONS_PREFIX sname \"=\", &strRes, default) ||       \\\n       withDefaults)                                                                               \\\n    p->var = strRes\n\n    // clang-format off\n    DOCTEST_PARSE_STR_OPTION(\"out\", \"o\", out, \"\");\n    DOCTEST_PARSE_STR_OPTION(\"order-by\", \"ob\", order_by, \"file\");\n    DOCTEST_PARSE_INT_OPTION(\"rand-seed\", \"rs\", rand_seed, 0);\n\n    DOCTEST_PARSE_INT_OPTION(\"first\", \"f\", first, 0);\n    DOCTEST_PARSE_INT_OPTION(\"last\", \"l\", last, UINT_MAX);\n\n    DOCTEST_PARSE_INT_OPTION(\"abort-after\", \"aa\", abort_after, 0);\n    DOCTEST_PARSE_INT_OPTION(\"subcase-filter-levels\", \"scfl\", subcase_filter_levels, INT_MAX);\n\n    DOCTEST_PARSE_AS_BOOL_OR_FLAG(\"success\", \"s\", success, false);\n    DOCTEST_PARSE_AS_BOOL_OR_FLAG(\"case-sensitive\", \"cs\", case_sensitive, false);\n    DOCTEST_PARSE_AS_BOOL_OR_FLAG(\"exit\", \"e\", exit, false);\n    DOCTEST_PARSE_AS_BOOL_OR_FLAG(\"duration\", \"d\", duration, false);\n    DOCTEST_PARSE_AS_BOOL_OR_FLAG(\"no-throw\", \"nt\", no_throw, false);\n    DOCTEST_PARSE_AS_BOOL_OR_FLAG(\"no-exitcode\", \"ne\", no_exitcode, false);\n    DOCTEST_PARSE_AS_BOOL_OR_FLAG(\"no-run\", \"nr\", no_run, false);\n    DOCTEST_PARSE_AS_BOOL_OR_FLAG(\"no-version\", \"nv\", no_version, false);\n    DOCTEST_PARSE_AS_BOOL_OR_FLAG(\"no-colors\", \"nc\", no_colors, false);\n    DOCTEST_PARSE_AS_BOOL_OR_FLAG(\"force-colors\", \"fc\", force_colors, false);\n    DOCTEST_PARSE_AS_BOOL_OR_FLAG(\"no-breaks\", \"nb\", no_breaks, false);\n    DOCTEST_PARSE_AS_BOOL_OR_FLAG(\"no-skip\", \"ns\", no_skip, false);\n    DOCTEST_PARSE_AS_BOOL_OR_FLAG(\"gnu-file-line\", \"gfl\", gnu_file_line, !bool(DOCTEST_MSVC));\n    DOCTEST_PARSE_AS_BOOL_OR_FLAG(\"no-path-filenames\", \"npf\", no_path_in_filenames, false);\n    DOCTEST_PARSE_AS_BOOL_OR_FLAG(\"no-line-numbers\", \"nln\", no_line_numbers, false);\n    DOCTEST_PARSE_AS_BOOL_OR_FLAG(\"no-debug-output\", \"ndo\", no_debug_output, false);\n    DOCTEST_PARSE_AS_BOOL_OR_FLAG(\"no-skipped-summary\", \"nss\", no_skipped_summary, false);\n    DOCTEST_PARSE_AS_BOOL_OR_FLAG(\"no-time-in-output\", \"ntio\", no_time_in_output, false);\n    // clang-format on\n\n    if(withDefaults) {\n        p->help             = false;\n        p->version          = false;\n        p->count            = false;\n        p->list_test_cases  = false;\n        p->list_test_suites = false;\n        p->list_reporters   = false;\n    }\n    if(parseFlag(argc, argv, DOCTEST_CONFIG_OPTIONS_PREFIX \"help\") ||\n       parseFlag(argc, argv, DOCTEST_CONFIG_OPTIONS_PREFIX \"h\") ||\n       parseFlag(argc, argv, DOCTEST_CONFIG_OPTIONS_PREFIX \"?\")) {\n        p->help = true;\n        p->exit = true;\n    }\n    if(parseFlag(argc, argv, DOCTEST_CONFIG_OPTIONS_PREFIX \"version\") ||\n       parseFlag(argc, argv, DOCTEST_CONFIG_OPTIONS_PREFIX \"v\")) {\n        p->version = true;\n        p->exit    = true;\n    }\n    if(parseFlag(argc, argv, DOCTEST_CONFIG_OPTIONS_PREFIX \"count\") ||\n       parseFlag(argc, argv, DOCTEST_CONFIG_OPTIONS_PREFIX \"c\")) {\n        p->count = true;\n        p->exit  = true;\n    }\n    if(parseFlag(argc, argv, DOCTEST_CONFIG_OPTIONS_PREFIX \"list-test-cases\") ||\n       parseFlag(argc, argv, DOCTEST_CONFIG_OPTIONS_PREFIX \"ltc\")) {\n        p->list_test_cases = true;\n        p->exit            = true;\n    }\n    if(parseFlag(argc, argv, DOCTEST_CONFIG_OPTIONS_PREFIX \"list-test-suites\") ||\n       parseFlag(argc, argv, DOCTEST_CONFIG_OPTIONS_PREFIX \"lts\")) {\n        p->list_test_suites = true;\n        p->exit             = true;\n    }\n    if(parseFlag(argc, argv, DOCTEST_CONFIG_OPTIONS_PREFIX \"list-reporters\") ||\n       parseFlag(argc, argv, DOCTEST_CONFIG_OPTIONS_PREFIX \"lr\")) {\n        p->list_reporters = true;\n        p->exit           = true;\n    }\n}\n\n// allows the user to add procedurally to the filters from the command line\nvoid Context::addFilter(const char* filter, const char* value) { setOption(filter, value); }\n\n// allows the user to clear all filters from the command line\nvoid Context::clearFilters() {\n    for(auto& curr : p->filters)\n        curr.clear();\n}\n\n// allows the user to override procedurally the int/bool options from the command line\nvoid Context::setOption(const char* option, int value) {\n    setOption(option, toString(value).c_str());\n    // NOLINTNEXTLINE(clang-analyzer-cplusplus.NewDeleteLeaks)\n}\n\n// allows the user to override procedurally the string options from the command line\nvoid Context::setOption(const char* option, const char* value) {\n    auto argv   = String(\"-\") + option + \"=\" + value;\n    auto lvalue = argv.c_str();\n    parseArgs(1, &lvalue);\n}\n\n// users should query this in their main() and exit the program if true\nbool Context::shouldExit() { return p->exit; }\n\nvoid Context::setAsDefaultForAssertsOutOfTestCases() { g_cs = p; }\n\nvoid Context::setAssertHandler(detail::assert_handler ah) { p->ah = ah; }\n\n// the main function that does all the filtering and test running\nint Context::run() {\n    using namespace detail;\n\n    // save the old context state in case such was setup - for using asserts out of a testing context\n    auto old_cs = g_cs;\n    // this is the current contest\n    g_cs               = p;\n    is_running_in_test = true;\n\n    g_no_colors = p->no_colors;\n    p->resetRunData();\n\n    // stdout by default\n    p->cout = &std::cout;\n    p->cerr = &std::cerr;\n\n    // or to a file if specified\n    std::fstream fstr;\n    if(p->out.size()) {\n        fstr.open(p->out.c_str(), std::fstream::out);\n        p->cout = &fstr;\n    }\n\n    auto cleanup_and_return = [&]() {\n        if(fstr.is_open())\n            fstr.close();\n\n        // restore context\n        g_cs               = old_cs;\n        is_running_in_test = false;\n\n        // we have to free the reporters which were allocated when the run started\n        for(auto& curr : p->reporters_currently_used)\n            delete curr;\n        p->reporters_currently_used.clear();\n\n        if(p->numTestCasesFailed && !p->no_exitcode)\n            return EXIT_FAILURE;\n        return EXIT_SUCCESS;\n    };\n\n    // setup default reporter if none is given through the command line\n    if(p->filters[8].empty())\n        p->filters[8].push_back(\"console\");\n\n    // check to see if any of the registered reporters has been selected\n    for(auto& curr : getReporters()) {\n        if(matchesAny(curr.first.second.c_str(), p->filters[8], false, p->case_sensitive))\n            p->reporters_currently_used.push_back(curr.second(*g_cs));\n    }\n\n    // TODO: check if there is nothing in reporters_currently_used\n\n    // prepend all listeners\n    for(auto& curr : getListeners())\n        p->reporters_currently_used.insert(p->reporters_currently_used.begin(), curr.second(*g_cs));\n\n#ifdef DOCTEST_PLATFORM_WINDOWS\n    if(isDebuggerActive() && p->no_debug_output == false)\n        p->reporters_currently_used.push_back(new DebugOutputWindowReporter(*g_cs));\n#endif // DOCTEST_PLATFORM_WINDOWS\n\n    // handle version, help and no_run\n    if(p->no_run || p->version || p->help || p->list_reporters) {\n        DOCTEST_ITERATE_THROUGH_REPORTERS(report_query, QueryData());\n\n        return cleanup_and_return();\n    }\n\n    std::vector<const TestCase*> testArray;\n    for(auto& curr : getRegisteredTests())\n        testArray.push_back(&curr);\n    p->numTestCases = testArray.size();\n\n    // sort the collected records\n    if(!testArray.empty()) {\n        if(p->order_by.compare(\"file\", true) == 0) {\n            std::sort(testArray.begin(), testArray.end(), fileOrderComparator);\n        } else if(p->order_by.compare(\"suite\", true) == 0) {\n            std::sort(testArray.begin(), testArray.end(), suiteOrderComparator);\n        } else if(p->order_by.compare(\"name\", true) == 0) {\n            std::sort(testArray.begin(), testArray.end(), nameOrderComparator);\n        } else if(p->order_by.compare(\"rand\", true) == 0) {\n            std::srand(p->rand_seed);\n\n            // random_shuffle implementation\n            const auto first = &testArray[0];\n            for(size_t i = testArray.size() - 1; i > 0; --i) {\n                int idxToSwap = std::rand() % (i + 1); // NOLINT\n\n                const auto temp = first[i];\n\n                first[i]         = first[idxToSwap];\n                first[idxToSwap] = temp;\n            }\n        } else if(p->order_by.compare(\"none\", true) == 0) {\n            // means no sorting - beneficial for death tests which call into the executable\n            // with a specific test case in mind - we don't want to slow down the startup times\n        }\n    }\n\n    std::set<String> testSuitesPassingFilt;\n\n    bool                             query_mode = p->count || p->list_test_cases || p->list_test_suites;\n    std::vector<const TestCaseData*> queryResults;\n\n    if(!query_mode)\n        DOCTEST_ITERATE_THROUGH_REPORTERS(test_run_start, DOCTEST_EMPTY);\n\n    // invoke the registered functions if they match the filter criteria (or just count them)\n    for(auto& curr : testArray) {\n        const auto& tc = *curr;\n\n        bool skip_me = false;\n        if(tc.m_skip && !p->no_skip)\n            skip_me = true;\n\n        if(!matchesAny(tc.m_file.c_str(), p->filters[0], true, p->case_sensitive))\n            skip_me = true;\n        if(matchesAny(tc.m_file.c_str(), p->filters[1], false, p->case_sensitive))\n            skip_me = true;\n        if(!matchesAny(tc.m_test_suite, p->filters[2], true, p->case_sensitive))\n            skip_me = true;\n        if(matchesAny(tc.m_test_suite, p->filters[3], false, p->case_sensitive))\n            skip_me = true;\n        if(!matchesAny(tc.m_name, p->filters[4], true, p->case_sensitive))\n            skip_me = true;\n        if(matchesAny(tc.m_name, p->filters[5], false, p->case_sensitive))\n            skip_me = true;\n\n        if(!skip_me)\n            p->numTestCasesPassingFilters++;\n\n        // skip the test if it is not in the execution range\n        if((p->last < p->numTestCasesPassingFilters && p->first <= p->last) ||\n           (p->first > p->numTestCasesPassingFilters))\n            skip_me = true;\n\n        if(skip_me) {\n            if(!query_mode)\n                DOCTEST_ITERATE_THROUGH_REPORTERS(test_case_skipped, tc);\n            continue;\n        }\n\n        // do not execute the test if we are to only count the number of filter passing tests\n        if(p->count)\n            continue;\n\n        // print the name of the test and don't execute it\n        if(p->list_test_cases) {\n            queryResults.push_back(&tc);\n            continue;\n        }\n\n        // print the name of the test suite if not done already and don't execute it\n        if(p->list_test_suites) {\n            if((testSuitesPassingFilt.count(tc.m_test_suite) == 0) && tc.m_test_suite[0] != '\\0') {\n                queryResults.push_back(&tc);\n                testSuitesPassingFilt.insert(tc.m_test_suite);\n                p->numTestSuitesPassingFilters++;\n            }\n            continue;\n        }\n\n        // execute the test if it passes all the filtering\n        {\n            p->currentTest = &tc;\n\n            p->failure_flags = TestCaseFailureReason::None;\n            p->seconds       = 0;\n\n            // reset atomic counters\n            p->numAssertsFailedCurrentTest_atomic = 0;\n            p->numAssertsCurrentTest_atomic       = 0;\n\n            p->subcasesPassed.clear();\n\n            DOCTEST_ITERATE_THROUGH_REPORTERS(test_case_start, tc);\n\n            p->timer.start();\n            \n            bool run_test = true;\n\n            do {\n                // reset some of the fields for subcases (except for the set of fully passed ones)\n                p->should_reenter          = false;\n                p->subcasesCurrentMaxLevel = 0;\n                p->subcasesStack.clear();\n\n                p->shouldLogCurrentException = true;\n\n                // reset stuff for logging with INFO()\n                p->stringifiedContexts.clear();\n\n#ifndef DOCTEST_CONFIG_NO_EXCEPTIONS\n                try {\n#endif // DOCTEST_CONFIG_NO_EXCEPTIONS\n                    FatalConditionHandler fatalConditionHandler; // Handle signals\n                    // execute the test\n                    tc.m_test();\n                    fatalConditionHandler.reset();\n#ifndef DOCTEST_CONFIG_NO_EXCEPTIONS\n                } catch(const TestFailureException&) {\n                    p->failure_flags |= TestCaseFailureReason::AssertFailure;\n                } catch(...) {\n                    DOCTEST_ITERATE_THROUGH_REPORTERS(test_case_exception,\n                                                      {translateActiveException(), false});\n                    p->failure_flags |= TestCaseFailureReason::Exception;\n                }\n#endif // DOCTEST_CONFIG_NO_EXCEPTIONS\n\n                // exit this loop if enough assertions have failed - even if there are more subcases\n                if(p->abort_after > 0 &&\n                   p->numAssertsFailed + p->numAssertsFailedCurrentTest_atomic >= p->abort_after) {\n                    run_test = false;\n                    p->failure_flags |= TestCaseFailureReason::TooManyFailedAsserts;\n                }\n                \n                if(p->should_reenter && run_test)\n                    DOCTEST_ITERATE_THROUGH_REPORTERS(test_case_reenter, tc);\n                if(!p->should_reenter)\n                    run_test = false;\n            } while(run_test);\n\n            p->finalizeTestCaseData();\n\n            DOCTEST_ITERATE_THROUGH_REPORTERS(test_case_end, *g_cs);\n\n            p->currentTest = nullptr;\n\n            // stop executing tests if enough assertions have failed\n            if(p->abort_after > 0 && p->numAssertsFailed >= p->abort_after)\n                break;\n        }\n    }\n\n    if(!query_mode) {\n        DOCTEST_ITERATE_THROUGH_REPORTERS(test_run_end, *g_cs);\n    } else {\n        QueryData qdata;\n        qdata.run_stats = g_cs;\n        qdata.data      = queryResults.data();\n        qdata.num_data  = unsigned(queryResults.size());\n        DOCTEST_ITERATE_THROUGH_REPORTERS(report_query, qdata);\n    }\n\n    // see these issues on the reasoning for this:\n    // - https://github.com/onqtam/doctest/issues/143#issuecomment-414418903\n    // - https://github.com/onqtam/doctest/issues/126\n    auto DOCTEST_FIX_FOR_MACOS_LIBCPP_IOSFWD_STRING_LINK_ERRORS = []() DOCTEST_NOINLINE\n        { std::cout << std::string(); };\n    DOCTEST_FIX_FOR_MACOS_LIBCPP_IOSFWD_STRING_LINK_ERRORS();\n\n    return cleanup_and_return();\n}\n\nIReporter::~IReporter() = default;\n\nint IReporter::get_num_active_contexts() { return detail::g_infoContexts.size(); }\nconst IContextScope* const* IReporter::get_active_contexts() {\n    return get_num_active_contexts() ? &detail::g_infoContexts[0] : nullptr;\n}\n\nint IReporter::get_num_stringified_contexts() { return detail::g_cs->stringifiedContexts.size(); }\nconst String* IReporter::get_stringified_contexts() {\n    return get_num_stringified_contexts() ? &detail::g_cs->stringifiedContexts[0] : nullptr;\n}\n\nnamespace detail {\n    void registerReporterImpl(const char* name, int priority, reporterCreatorFunc c, bool isReporter) {\n        if(isReporter)\n            getReporters().insert(reporterMap::value_type(reporterMap::key_type(priority, name), c));\n        else\n            getListeners().insert(reporterMap::value_type(reporterMap::key_type(priority, name), c));\n    }\n} // namespace detail\n\n} // namespace doctest\n\n#endif // DOCTEST_CONFIG_DISABLE\n\n#ifdef DOCTEST_CONFIG_IMPLEMENT_WITH_MAIN\nDOCTEST_MSVC_SUPPRESS_WARNING_WITH_PUSH(4007) // 'function' : must be 'attribute' - see issue #182\nint main(int argc, char** argv) { return doctest::Context(argc, argv).run(); }\nDOCTEST_MSVC_SUPPRESS_WARNING_POP\n#endif // DOCTEST_CONFIG_IMPLEMENT_WITH_MAIN\n\nDOCTEST_CLANG_SUPPRESS_WARNING_POP\nDOCTEST_MSVC_SUPPRESS_WARNING_POP\nDOCTEST_GCC_SUPPRESS_WARNING_POP\n\n#endif // DOCTEST_LIBRARY_IMPLEMENTATION\n#endif // DOCTEST_CONFIG_IMPLEMENT\n"}}, "reports": [{"events": [{"location": {"col": 29, "file": 3, "line": 1053}, "message": "expanded from macro 'DOCTEST_DO_BINARY_EXPRESSION_COMPARISON'"}, {"location": {"col": 9, "file": 3, "line": 1198}, "message": "'operator!=<Digest>' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/ccache/src/third_party/doctest.h", "reportHash": "9a69fffafb9b5c67c3f17d7273ff999e", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}]};
      window.onload = function() {
        if (!browserCompatible) {
          setNonCompatibleBrowserMessage();
        } else {
          BugViewer.init(data.files, data.reports);
          BugViewer.create();
          BugViewer.initByUrl();
        }
      };
    </script>
  </head>
  <body>
  <div class="container">
    <div id="content">
      <div id="side-bar">
        <div class="header">
          <a href="index.html" class="button">&#8249; Return to List</a>
        </div>
        <div id="report-nav">
          <div class="header">Reports</div>
        </div>
      </div>
      <div id="editor-wrapper">
        <div class="header">
          <div id="file">
            <span class="label">File:</span>
            <span id="file-path"></span>
          </div>
          <div id="checker">
            <span class="label">Checker name:</span>
            <span id="checker-name"></span>
          </div>
          <div id="review-status-wrapper">
            <span class="label">Review status:</span>
            <span id="review-status"></span>
          </div>
        </div>
        <div id="editor"></div>
      </div>
    </div>
  </div>
  </body>
</html>
