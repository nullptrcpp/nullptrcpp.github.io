<!DOCTYPE html>
<html>
  <head>
    <title>Plist HTML Viewer</title>

    <meta charset="UTF-8">

    <style type="text/css">
      .CodeMirror{font-family:monospace;height:300px;color:#000;direction:ltr}.CodeMirror-lines{padding:4px 0}.CodeMirror pre{padding:0 4px}.CodeMirror-gutter-filler,.CodeMirror-scrollbar-filler{background-color:#fff}.CodeMirror-gutters{border-right:1px solid #ddd;background-color:#f7f7f7;white-space:nowrap}.CodeMirror-linenumber{padding:0 3px 0 5px;min-width:20px;text-align:right;color:#999;white-space:nowrap}.CodeMirror-guttermarker{color:#000}.CodeMirror-guttermarker-subtle{color:#999}.CodeMirror-cursor{border-left:1px solid #000;border-right:none;width:0}.CodeMirror div.CodeMirror-secondarycursor{border-left:1px solid silver}.cm-fat-cursor .CodeMirror-cursor{width:auto;border:0!important;background:#7e7}.cm-fat-cursor div.CodeMirror-cursors{z-index:1}.cm-animate-fat-cursor{width:auto;border:0;-webkit-animation:blink 1.06s steps(1) infinite;-moz-animation:blink 1.06s steps(1) infinite;animation:blink 1.06s steps(1) infinite;background-color:#7e7}@-moz-keyframes blink{50%{background-color:transparent}}@-webkit-keyframes blink{50%{background-color:transparent}}@keyframes blink{50%{background-color:transparent}}.cm-tab{display:inline-block;text-decoration:inherit}.CodeMirror-rulers{position:absolute;left:0;right:0;top:-50px;bottom:-20px;overflow:hidden}.CodeMirror-ruler{border-left:1px solid #ccc;top:0;bottom:0;position:absolute}.cm-s-default .cm-header{color:#00f}.cm-s-default .cm-quote{color:#090}.cm-negative{color:#d44}.cm-positive{color:#292}.cm-header,.cm-strong{font-weight:700}.cm-em{font-style:italic}.cm-link{text-decoration:underline}.cm-strikethrough{text-decoration:line-through}.cm-s-default .cm-keyword{color:#708}.cm-s-default .cm-atom{color:#219}.cm-s-default .cm-number{color:#164}.cm-s-default .cm-def{color:#00f}.cm-s-default .cm-variable-2{color:#05a}.cm-s-default .cm-type,.cm-s-default .cm-variable-3{color:#085}.cm-s-default .cm-comment{color:#a50}.cm-s-default .cm-string{color:#a11}.cm-s-default .cm-string-2{color:#f50}.cm-s-default .cm-meta{color:#555}.cm-s-default .cm-qualifier{color:#555}.cm-s-default .cm-builtin{color:#30a}.cm-s-default .cm-bracket{color:#997}.cm-s-default .cm-tag{color:#170}.cm-s-default .cm-attribute{color:#00c}.cm-s-default .cm-hr{color:#999}.cm-s-default .cm-link{color:#00c}.cm-s-default .cm-error{color:red}.cm-invalidchar{color:red}.CodeMirror-composing{border-bottom:2px solid}div.CodeMirror span.CodeMirror-matchingbracket{color:#0f0}div.CodeMirror span.CodeMirror-nonmatchingbracket{color:#f22}.CodeMirror-matchingtag{background:rgba(255,150,0,.3)}.CodeMirror-activeline-background{background:#e8f2ff}.CodeMirror{position:relative;overflow:hidden;background:#fff}.CodeMirror-scroll{overflow:scroll!important;margin-bottom:-30px;margin-right:-30px;padding-bottom:30px;height:100%;outline:0;position:relative}.CodeMirror-sizer{position:relative;border-right:30px solid transparent}.CodeMirror-gutter-filler,.CodeMirror-hscrollbar,.CodeMirror-scrollbar-filler,.CodeMirror-vscrollbar{position:absolute;z-index:6;display:none}.CodeMirror-vscrollbar{right:0;top:0;overflow-x:hidden;overflow-y:scroll}.CodeMirror-hscrollbar{bottom:0;left:0;overflow-y:hidden;overflow-x:scroll}.CodeMirror-scrollbar-filler{right:0;bottom:0}.CodeMirror-gutter-filler{left:0;bottom:0}.CodeMirror-gutters{position:absolute;left:0;top:0;min-height:100%;z-index:3}.CodeMirror-gutter{white-space:normal;height:100%;display:inline-block;vertical-align:top;margin-bottom:-30px}.CodeMirror-gutter-wrapper{position:absolute;z-index:4;background:0 0!important;border:none!important}.CodeMirror-gutter-background{position:absolute;top:0;bottom:0;z-index:4}.CodeMirror-gutter-elt{position:absolute;cursor:default;z-index:4}.CodeMirror-gutter-wrapper ::selection{background-color:transparent}.CodeMirror-gutter-wrapper ::-moz-selection{background-color:transparent}.CodeMirror-lines{cursor:text;min-height:1px}.CodeMirror pre{-moz-border-radius:0;-webkit-border-radius:0;border-radius:0;border-width:0;background:0 0;font-family:inherit;font-size:inherit;margin:0;white-space:pre;word-wrap:normal;line-height:inherit;color:inherit;z-index:2;position:relative;overflow:visible;-webkit-tap-highlight-color:transparent;-webkit-font-variant-ligatures:contextual;font-variant-ligatures:contextual}.CodeMirror-wrap pre{word-wrap:break-word;white-space:pre-wrap;word-break:normal}.CodeMirror-linebackground{position:absolute;left:0;right:0;top:0;bottom:0;z-index:0}.CodeMirror-linewidget{position:relative;z-index:2;overflow:auto}.CodeMirror-rtl pre{direction:rtl}.CodeMirror-code{outline:0}.CodeMirror-gutter,.CodeMirror-gutters,.CodeMirror-linenumber,.CodeMirror-scroll,.CodeMirror-sizer{-moz-box-sizing:content-box;box-sizing:content-box}.CodeMirror-measure{position:absolute;width:100%;height:0;overflow:hidden;visibility:hidden}.CodeMirror-cursor{position:absolute;pointer-events:none}.CodeMirror-measure pre{position:static}div.CodeMirror-cursors{visibility:hidden;position:relative;z-index:3}div.CodeMirror-dragcursors{visibility:visible}.CodeMirror-focused div.CodeMirror-cursors{visibility:visible}.CodeMirror-selected{background:#d9d9d9}.CodeMirror-focused .CodeMirror-selected{background:#d7d4f0}.CodeMirror-crosshair{cursor:crosshair}.CodeMirror-line::selection,.CodeMirror-line>span::selection,.CodeMirror-line>span>span::selection{background:#d7d4f0}.CodeMirror-line::-moz-selection,.CodeMirror-line>span::-moz-selection,.CodeMirror-line>span>span::-moz-selection{background:#d7d4f0}.cm-searching{background-color:#ffa;background-color:rgba(255,255,0,.4)}.cm-force-border{padding-right:.1px}@media print{.CodeMirror div.CodeMirror-cursors{visibility:hidden}}.cm-tab-wrap-hack:after{content:''}span.CodeMirror-selectedtext{background:0 0}
/*# sourceMappingURL=codemirror.min.css.map */

      .severity-low {
  background-color: #669603;
}

.severity-low:after {
  content : 'L';
}

.severity-unspecified {
  background-color: #666666;
}

.severity-unspecified:after {
  content : 'U';
}

.severity-style {
  background-color: #9932cc;
}

.severity-style:after {
  content : 'S';
}

.severity-medium {
  background-color: #a9d323;
  color: black;
}

.severity-medium:after {
  content : 'M';
}

.severity-high {
  background-color: #ffa800;
}

.severity-high:after {
  content : 'H';
}

.severity-critical {
  background-color: #e92625;
}

.severity-critical:after {
  content : 'C';
}

i[class*="severity-"] {
  line-height: normal;
  text-transform: capitalize;
  font-size: 0.8em;
  font-weight: bold;
  color: white;
  display: inline-block;
  width: 16px;
  height: 16px;
  text-align: center;
  font-family: sans-serif;
}

      html, body {
  width: 100%;
  height: 100%;
  padding: 0px;
  margin: 0px;
}

div.container {
  padding: 10px;
}

#content {
  height: 100%;
  display: block;
  overflow: hidden;
}

#content > div {
  margin: 10px;
  overflow: hidden;
  border: 1px solid #ddd;
  border-radius: 3px;
  overflow: hidden;
  height: 97%;
}

.button {
  background-color: #f1f1f1;
  text-decoration: none;
  display: inline-block;
  padding: 8px 16px;
  color: black;
  cursor: pointer;
}

.button:hover {
  background-color: #ddd;
  color: black;
}

.review-status {
  color: white;
  text-align: center;
}

.review-status-confirmed {
  background-color: #e92625;
}

.review-status-false-positive {
  background-color: grey;
}

.review-status-intentional {
  background-color: #669603;
}

      div.container {
  width: 100%;
  height: 100%;
  padding: 0px;
}

#editor-wrapper {
  margin: 10px;
}

#side-bar {
  float: left;
  width: 260px;
  margin: 0px;
}

#report-nav ul {
  list-style-type: none;
  padding: 0;
  margin: 0;
  overflow-y: auto;
  height: 100%;
}

#report-nav ul > li {
  padding: .4em;
  background-color: #fff;
  border-bottom: 1px solid rgba(0,0,0,.125);
  text-align: left;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

#report-nav ul > li.active {
  background-color: #427ea9;
  color: white;
}

#report-nav ul > li:hover {
  background-color: #427ea9;
  color: white;
  cursor: pointer;
}

#report-nav ul a {
  text-decoration: none;
}

#report-nav i[class*="severity-"] {
  margin-right: 5px;
}

.header {
  border-bottom: 1px solid lightgrey;
  font-family: monospace;
  padding: 10px;
  background-color: #fafbfc;
  border-bottom: 1px solid #e1e4e8;
  border-top-left-radius: 2px;
  border-top-right-radius: 2px;
}

#report-nav .header {
  font-weight: bold;
}

#editor-wrapper .header > div {
  padding-top: 2px;
}

#file-path,
#checker-name {
  color: #195ea2;
}

#review-status {
  padding: 0px 5px;
}

#file-path {
  font-family: monospace;
}

.check-msg {
  display: inline-block;
  padding: 3px 6px;
  margin: 1px;
  -webkit-border-radius: 5px;
  -moz-border-radius: 5px;
  border-radius: 5px;
}

.check-msg.info {
  color: #00546f;
  background-color: #bfdfe9;
  border: 1px solid #87a8b3;
}

.check-msg.error {
  background-color: #f2dede;
  color: #a94442;
  border: 1px solid #ebcccc;
}

.check-msg.macro {
  background-color: #d7dac2;
  color: #4f5c6d;
  border: 1px solid #d7dac2;
}

.check-msg.note {
  background-color: #d7d7d7;
  color: #4f5c6d;
  border: 1px solid #bfbfbf;
}

.check-msg.current {
  border: 2px dashed #3692ff;
}

.check-msg .tag {
  padding: 1px 5px;
  text-align: center;
  border-radius: 2px;
  margin-right: 5px;
  text-decoration: inherit;
}

.check-msg .tag.macro {
  background-color: #83876a;
  color: white;
  text-transform: capitalize;
}

.check-msg .tag.note {
  background-color: #9299a1;
  color: white;
  text-transform: capitalize;
}

.checker-enum {
  color: white;
  padding: 1px 5px;
  text-align: center;
  border-radius: 25px;
  margin-right: 5px;
  text-decoration: inherit;
}

.checker-enum.info {
  background-color: #427ea9;
}

.checker-enum.error {
  background-color: #a94442;
}

.arrow {
  border: solid black;
  border-width: 0 3px 3px 0;
  display: inline-block;
  padding: 3px;
  cursor: pointer;
  margin: 0px 5px;
}

.arrow:hover {
  border: solid #437ea8;
  border-width: 0 3px 3px 0;
}

.left-arrow {
  transform: rotate(135deg);
  -webkit-transform: rotate(135deg);
}

.right-arrow {
  transform: rotate(-45deg);
  -webkit-transform: rotate(-45deg);
}

    </style>

    <script type="text/javascript">
      function setNonCompatibleBrowserMessage() {
  document.body.innerHTML =
    '<h2 style="margin-left: 20px;">Your browser is not compatible with CodeChecker Viewer!</h2> \
     <p style="margin-left: 20px;">The version required for the following browsers are:</p> \
     <ul style="margin-left: 20px;"> \
     <li>Internet Explorer: version 9 or newer</li> \
     <li>Firefox: version 22.0 or newer</li> \
     </ul>';
}

// http://stackoverflow.com/questions/5916900/how-can-you-detect-the-version-of-a-browser
var browserVersion = (function(){
  var ua = navigator.userAgent, tem,
    M = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];

  if (/trident/i.test(M[1])) {
    tem = /\brv[ :]+(\d+)/g.exec(ua) || [];
    return 'IE ' + (tem[1] || '');
  }

  if (M[1] === 'Chrome') {
    tem = ua.match(/\b(OPR|Edge)\/(\d+)/);
    if (tem != null) return tem.slice(1).join(' ').replace('OPR', 'Opera');
  }

  M = M[2] ? [M[1], M[2]] : [navigator.appName, navigator.appVersion, '-?'];
  if ((tem = ua.match(/version\/(\d+)/i)) != null) M.splice(1, 1, tem[1]);
    return M.join(' ');
})();

var pos = browserVersion.indexOf(' ');
var browser = browserVersion.substr(0, pos);
var version = parseInt(browserVersion.substr(pos + 1));

var browserCompatible
  = browser === 'Firefox'
  ? version >= 22
  : browser === 'IE'
  ? version >= 9
  : true;


      /* MIT License

Copyright (C) 2017 by Marijn Haverbeke <marijnh@gmail.com> and others

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
 */
      !function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):e.CodeMirror=t()}(this,function(){"use strict";function e(e){return new RegExp("(^|\\s)"+e+"(?:$|\\s)\\s*")}function t(e){for(var t=e.childNodes.length;t>0;--t)e.removeChild(e.firstChild);return e}function r(e,r){return t(e).appendChild(r)}function n(e,t,r,n){var i=document.createElement(e);if(r&&(i.className=r),n&&(i.style.cssText=n),"string"==typeof t)i.appendChild(document.createTextNode(t));else if(t)for(var o=0;o<t.length;++o)i.appendChild(t[o]);return i}function i(e,t,r,i){var o=n(e,t,r,i);return o.setAttribute("role","presentation"),o}function o(e,t){if(3==t.nodeType&&(t=t.parentNode),e.contains)return e.contains(t);do{if(11==t.nodeType&&(t=t.host),t==e)return!0}while(t=t.parentNode)}function l(){var e;try{e=document.activeElement}catch(t){e=document.body||null}for(;e&&e.shadowRoot&&e.shadowRoot.activeElement;)e=e.shadowRoot.activeElement;return e}function s(t,r){var n=t.className;e(r).test(n)||(t.className+=(n?" ":"")+r)}function a(t,r){for(var n=t.split(" "),i=0;i<n.length;i++)n[i]&&!e(n[i]).test(r)&&(r+=" "+n[i]);return r}function u(e){var t=Array.prototype.slice.call(arguments,1);return function(){return e.apply(null,t)}}function c(e,t,r){t||(t={});for(var n in e)!e.hasOwnProperty(n)||!1===r&&t.hasOwnProperty(n)||(t[n]=e[n]);return t}function f(e,t,r,n,i){null==t&&-1==(t=e.search(/[^\s\u00a0]/))&&(t=e.length);for(var o=n||0,l=i||0;;){var s=e.indexOf("\t",o);if(s<0||s>=t)return l+(t-o);l+=s-o,l+=r-l%r,o=s+1}}function h(e,t){for(var r=0;r<e.length;++r)if(e[r]==t)return r;return-1}function d(e,t,r){for(var n=0,i=0;;){var o=e.indexOf("\t",n);-1==o&&(o=e.length);var l=o-n;if(o==e.length||i+l>=t)return n+Math.min(l,t-i);if(i+=o-n,i+=r-i%r,n=o+1,i>=t)return n}}function p(e){for(;Kl.length<=e;)Kl.push(g(Kl)+" ");return Kl[e]}function g(e){return e[e.length-1]}function v(e,t){for(var r=[],n=0;n<e.length;n++)r[n]=t(e[n],n);return r}function m(e,t,r){for(var n=0,i=r(t);n<e.length&&r(e[n])<=i;)n++;e.splice(n,0,t)}function y(){}function b(e,t){var r;return Object.create?r=Object.create(e):(y.prototype=e,r=new y),t&&c(t,r),r}function w(e){return/\w/.test(e)||e>""&&(e.toUpperCase()!=e.toLowerCase()||jl.test(e))}function x(e,t){return t?!!(t.source.indexOf("\\w")>-1&&w(e))||t.test(e):w(e)}function C(e){for(var t in e)if(e.hasOwnProperty(t)&&e[t])return!1;return!0}function S(e){return e.charCodeAt(0)>=768&&Xl.test(e)}function L(e,t,r){for(;(r<0?t>0:t<e.length)&&S(e.charAt(t));)t+=r;return t}function k(e,t,r){for(var n=t>r?-1:1;;){if(t==r)return t;var i=(t+r)/2,o=n<0?Math.ceil(i):Math.floor(i);if(o==t)return e(o)?t:r;e(o)?r=o:t=o+n}}function T(e,t,r){var o=this;this.input=r,o.scrollbarFiller=n("div",null,"CodeMirror-scrollbar-filler"),o.scrollbarFiller.setAttribute("cm-not-content","true"),o.gutterFiller=n("div",null,"CodeMirror-gutter-filler"),o.gutterFiller.setAttribute("cm-not-content","true"),o.lineDiv=i("div",null,"CodeMirror-code"),o.selectionDiv=n("div",null,null,"position: relative; z-index: 1"),o.cursorDiv=n("div",null,"CodeMirror-cursors"),o.measure=n("div",null,"CodeMirror-measure"),o.lineMeasure=n("div",null,"CodeMirror-measure"),o.lineSpace=i("div",[o.measure,o.lineMeasure,o.selectionDiv,o.cursorDiv,o.lineDiv],null,"position: relative; outline: none");var l=i("div",[o.lineSpace],"CodeMirror-lines");o.mover=n("div",[l],null,"position: relative"),o.sizer=n("div",[o.mover],"CodeMirror-sizer"),o.sizerWidth=null,o.heightForcer=n("div",null,null,"position: absolute; height: "+Rl+"px; width: 1px;"),o.gutters=n("div",null,"CodeMirror-gutters"),o.lineGutter=null,o.scroller=n("div",[o.sizer,o.heightForcer,o.gutters],"CodeMirror-scroll"),o.scroller.setAttribute("tabIndex","-1"),o.wrapper=n("div",[o.scrollbarFiller,o.gutterFiller,o.scroller],"CodeMirror"),gl&&vl<8&&(o.gutters.style.zIndex=-1,o.scroller.style.paddingRight=0),ml||fl&&Tl||(o.scroller.draggable=!0),e&&(e.appendChild?e.appendChild(o.wrapper):e(o.wrapper)),o.viewFrom=o.viewTo=t.first,o.reportedViewFrom=o.reportedViewTo=t.first,o.view=[],o.renderedView=null,o.externalMeasured=null,o.viewOffset=0,o.lastWrapHeight=o.lastWrapWidth=0,o.updateLineNumbers=null,o.nativeBarWidth=o.barHeight=o.barWidth=0,o.scrollbarsClipped=!1,o.lineNumWidth=o.lineNumInnerWidth=o.lineNumChars=null,o.alignWidgets=!1,o.cachedCharWidth=o.cachedTextHeight=o.cachedPaddingH=null,o.maxLine=null,o.maxLineLength=0,o.maxLineChanged=!1,o.wheelDX=o.wheelDY=o.wheelStartX=o.wheelStartY=null,o.shift=!1,o.selForContextMenu=null,o.activeTouch=null,r.init(o)}function M(e,t){if((t-=e.first)<0||t>=e.size)throw new Error("There is no line "+(t+e.first)+" in the document.");for(var r=e;!r.lines;)for(var n=0;;++n){var i=r.children[n],o=i.chunkSize();if(t<o){r=i;break}t-=o}return r.lines[t]}function N(e,t,r){var n=[],i=t.line;return e.iter(t.line,r.line+1,function(e){var o=e.text;i==r.line&&(o=o.slice(0,r.ch)),i==t.line&&(o=o.slice(t.ch)),n.push(o),++i}),n}function O(e,t,r){var n=[];return e.iter(t,r,function(e){n.push(e.text)}),n}function A(e,t){var r=t-e.height;if(r)for(var n=e;n;n=n.parent)n.height+=r}function W(e){if(null==e.parent)return null;for(var t=e.parent,r=h(t.lines,e),n=t.parent;n;t=n,n=n.parent)for(var i=0;n.children[i]!=t;++i)r+=n.children[i].chunkSize();return r+t.first}function D(e,t){var r=e.first;e:do{for(var n=0;n<e.children.length;++n){var i=e.children[n],o=i.height;if(t<o){e=i;continue e}t-=o,r+=i.chunkSize()}return r}while(!e.lines);for(var l=0;l<e.lines.length;++l){var s=e.lines[l].height;if(t<s)break;t-=s}return r+l}function H(e,t){return t>=e.first&&t<e.first+e.size}function F(e,t){return String(e.lineNumberFormatter(t+e.firstLineNumber))}function E(e,t,r){if(void 0===r&&(r=null),!(this instanceof E))return new E(e,t,r);this.line=e,this.ch=t,this.sticky=r}function P(e,t){return e.line-t.line||e.ch-t.ch}function I(e,t){return e.sticky==t.sticky&&0==P(e,t)}function z(e){return E(e.line,e.ch)}function R(e,t){return P(e,t)<0?t:e}function B(e,t){return P(e,t)<0?e:t}function G(e,t){return Math.max(e.first,Math.min(t,e.first+e.size-1))}function U(e,t){if(t.line<e.first)return E(e.first,0);var r=e.first+e.size-1;return t.line>r?E(r,M(e,r).text.length):V(t,M(e,t.line).text.length)}function V(e,t){var r=e.ch;return null==r||r>t?E(e.line,t):r<0?E(e.line,0):e}function K(e,t){for(var r=[],n=0;n<t.length;n++)r[n]=U(e,t[n]);return r}function j(){Yl=!0}function X(){_l=!0}function Y(e,t,r){this.marker=e,this.from=t,this.to=r}function _(e,t){if(e)for(var r=0;r<e.length;++r){var n=e[r];if(n.marker==t)return n}}function $(e,t){for(var r,n=0;n<e.length;++n)e[n]!=t&&(r||(r=[])).push(e[n]);return r}function q(e,t){e.markedSpans=e.markedSpans?e.markedSpans.concat([t]):[t],t.marker.attachLine(e)}function Z(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t)||o.from==t&&"bookmark"==l.type&&(!r||!o.marker.insertLeft)){var s=null==o.to||(l.inclusiveRight?o.to>=t:o.to>t);(n||(n=[])).push(new Y(l,o.from,s?null:o.to))}}return n}function Q(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.to||(l.inclusiveRight?o.to>=t:o.to>t)||o.from==t&&"bookmark"==l.type&&(!r||o.marker.insertLeft)){var s=null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t);(n||(n=[])).push(new Y(l,s?null:o.from-t,null==o.to?null:o.to-t))}}return n}function J(e,t){if(t.full)return null;var r=H(e,t.from.line)&&M(e,t.from.line).markedSpans,n=H(e,t.to.line)&&M(e,t.to.line).markedSpans;if(!r&&!n)return null;var i=t.from.ch,o=t.to.ch,l=0==P(t.from,t.to),s=Z(r,i,l),a=Q(n,o,l),u=1==t.text.length,c=g(t.text).length+(u?i:0);if(s)for(var f=0;f<s.length;++f){var h=s[f];if(null==h.to){var d=_(a,h.marker);d?u&&(h.to=null==d.to?null:d.to+c):h.to=i}}if(a)for(var p=0;p<a.length;++p){var v=a[p];null!=v.to&&(v.to+=c),null==v.from?_(s,v.marker)||(v.from=c,u&&(s||(s=[])).push(v)):(v.from+=c,u&&(s||(s=[])).push(v))}s&&(s=ee(s)),a&&a!=s&&(a=ee(a));var m=[s];if(!u){var y,b=t.text.length-2;if(b>0&&s)for(var w=0;w<s.length;++w)null==s[w].to&&(y||(y=[])).push(new Y(s[w].marker,null,null));for(var x=0;x<b;++x)m.push(y);m.push(a)}return m}function ee(e){for(var t=0;t<e.length;++t){var r=e[t];null!=r.from&&r.from==r.to&&!1!==r.marker.clearWhenEmpty&&e.splice(t--,1)}return e.length?e:null}function te(e,t,r){var n=null;if(e.iter(t.line,r.line+1,function(e){if(e.markedSpans)for(var t=0;t<e.markedSpans.length;++t){var r=e.markedSpans[t].marker;!r.readOnly||n&&-1!=h(n,r)||(n||(n=[])).push(r)}}),!n)return null;for(var i=[{from:t,to:r}],o=0;o<n.length;++o)for(var l=n[o],s=l.find(0),a=0;a<i.length;++a){var u=i[a];if(!(P(u.to,s.from)<0||P(u.from,s.to)>0)){var c=[a,1],f=P(u.from,s.from),d=P(u.to,s.to);(f<0||!l.inclusiveLeft&&!f)&&c.push({from:u.from,to:s.from}),(d>0||!l.inclusiveRight&&!d)&&c.push({from:s.to,to:u.to}),i.splice.apply(i,c),a+=c.length-3}}return i}function re(e){var t=e.markedSpans;if(t){for(var r=0;r<t.length;++r)t[r].marker.detachLine(e);e.markedSpans=null}}function ne(e,t){if(t){for(var r=0;r<t.length;++r)t[r].marker.attachLine(e);e.markedSpans=t}}function ie(e){return e.inclusiveLeft?-1:0}function oe(e){return e.inclusiveRight?1:0}function le(e,t){var r=e.lines.length-t.lines.length;if(0!=r)return r;var n=e.find(),i=t.find(),o=P(n.from,i.from)||ie(e)-ie(t);if(o)return-o;var l=P(n.to,i.to)||oe(e)-oe(t);return l||t.id-e.id}function se(e,t){var r,n=_l&&e.markedSpans;if(n)for(var i=void 0,o=0;o<n.length;++o)(i=n[o]).marker.collapsed&&null==(t?i.from:i.to)&&(!r||le(r,i.marker)<0)&&(r=i.marker);return r}function ae(e){return se(e,!0)}function ue(e){return se(e,!1)}function ce(e,t,r,n,i){var o=M(e,t),l=_l&&o.markedSpans;if(l)for(var s=0;s<l.length;++s){var a=l[s];if(a.marker.collapsed){var u=a.marker.find(0),c=P(u.from,r)||ie(a.marker)-ie(i),f=P(u.to,n)||oe(a.marker)-oe(i);if(!(c>=0&&f<=0||c<=0&&f>=0)&&(c<=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.to,r)>=0:P(u.to,r)>0)||c>=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.from,n)<=0:P(u.from,n)<0)))return!0}}}function fe(e){for(var t;t=ae(e);)e=t.find(-1,!0).line;return e}function he(e){for(var t;t=ue(e);)e=t.find(1,!0).line;return e}function de(e){for(var t,r;t=ue(e);)e=t.find(1,!0).line,(r||(r=[])).push(e);return r}function pe(e,t){var r=M(e,t),n=fe(r);return r==n?t:W(n)}function ge(e,t){if(t>e.lastLine())return t;var r,n=M(e,t);if(!ve(e,n))return t;for(;r=ue(n);)n=r.find(1,!0).line;return W(n)+1}function ve(e,t){var r=_l&&t.markedSpans;if(r)for(var n=void 0,i=0;i<r.length;++i)if((n=r[i]).marker.collapsed){if(null==n.from)return!0;if(!n.marker.widgetNode&&0==n.from&&n.marker.inclusiveLeft&&me(e,t,n))return!0}}function me(e,t,r){if(null==r.to){var n=r.marker.find(1,!0);return me(e,n.line,_(n.line.markedSpans,r.marker))}if(r.marker.inclusiveRight&&r.to==t.text.length)return!0;for(var i=void 0,o=0;o<t.markedSpans.length;++o)if((i=t.markedSpans[o]).marker.collapsed&&!i.marker.widgetNode&&i.from==r.to&&(null==i.to||i.to!=r.from)&&(i.marker.inclusiveLeft||r.marker.inclusiveRight)&&me(e,t,i))return!0}function ye(e){for(var t=0,r=(e=fe(e)).parent,n=0;n<r.lines.length;++n){var i=r.lines[n];if(i==e)break;t+=i.height}for(var o=r.parent;o;r=o,o=r.parent)for(var l=0;l<o.children.length;++l){var s=o.children[l];if(s==r)break;t+=s.height}return t}function be(e){if(0==e.height)return 0;for(var t,r=e.text.length,n=e;t=ae(n);){var i=t.find(0,!0);n=i.from.line,r+=i.from.ch-i.to.ch}for(n=e;t=ue(n);){var o=t.find(0,!0);r-=n.text.length-o.from.ch,r+=(n=o.to.line).text.length-o.to.ch}return r}function we(e){var t=e.display,r=e.doc;t.maxLine=M(r,r.first),t.maxLineLength=be(t.maxLine),t.maxLineChanged=!0,r.iter(function(e){var r=be(e);r>t.maxLineLength&&(t.maxLineLength=r,t.maxLine=e)})}function xe(e,t,r,n){if(!e)return n(t,r,"ltr",0);for(var i=!1,o=0;o<e.length;++o){var l=e[o];(l.from<r&&l.to>t||t==r&&l.to==t)&&(n(Math.max(l.from,t),Math.min(l.to,r),1==l.level?"rtl":"ltr",o),i=!0)}i||n(t,r,"ltr")}function Ce(e,t,r){var n;$l=null;for(var i=0;i<e.length;++i){var o=e[i];if(o.from<t&&o.to>t)return i;o.to==t&&(o.from!=o.to&&"before"==r?n=i:$l=i),o.from==t&&(o.from!=o.to&&"before"!=r?n=i:$l=i)}return null!=n?n:$l}function Se(e,t){var r=e.order;return null==r&&(r=e.order=ql(e.text,t)),r}function Le(e,t){return e._handlers&&e._handlers[t]||Zl}function ke(e,t,r){if(e.removeEventListener)e.removeEventListener(t,r,!1);else if(e.detachEvent)e.detachEvent("on"+t,r);else{var n=e._handlers,i=n&&n[t];if(i){var o=h(i,r);o>-1&&(n[t]=i.slice(0,o).concat(i.slice(o+1)))}}}function Te(e,t){var r=Le(e,t);if(r.length)for(var n=Array.prototype.slice.call(arguments,2),i=0;i<r.length;++i)r[i].apply(null,n)}function Me(e,t,r){return"string"==typeof t&&(t={type:t,preventDefault:function(){this.defaultPrevented=!0}}),Te(e,r||t.type,e,t),He(t)||t.codemirrorIgnore}function Ne(e){var t=e._handlers&&e._handlers.cursorActivity;if(t)for(var r=e.curOp.cursorActivityHandlers||(e.curOp.cursorActivityHandlers=[]),n=0;n<t.length;++n)-1==h(r,t[n])&&r.push(t[n])}function Oe(e,t){return Le(e,t).length>0}function Ae(e){e.prototype.on=function(e,t){Ql(this,e,t)},e.prototype.off=function(e,t){ke(this,e,t)}}function We(e){e.preventDefault?e.preventDefault():e.returnValue=!1}function De(e){e.stopPropagation?e.stopPropagation():e.cancelBubble=!0}function He(e){return null!=e.defaultPrevented?e.defaultPrevented:0==e.returnValue}function Fe(e){We(e),De(e)}function Ee(e){return e.target||e.srcElement}function Pe(e){var t=e.which;return null==t&&(1&e.button?t=1:2&e.button?t=3:4&e.button&&(t=2)),Ml&&e.ctrlKey&&1==t&&(t=3),t}function Ie(e){if(null==Il){var t=n("span","​");r(e,n("span",[t,document.createTextNode("x")])),0!=e.firstChild.offsetHeight&&(Il=t.offsetWidth<=1&&t.offsetHeight>2&&!(gl&&vl<8))}var i=Il?n("span","​"):n("span"," ",null,"display: inline-block; width: 1px; margin-right: -1px");return i.setAttribute("cm-text",""),i}function ze(e){if(null!=zl)return zl;var n=r(e,document.createTextNode("AخA")),i=Wl(n,0,1).getBoundingClientRect(),o=Wl(n,1,2).getBoundingClientRect();return t(e),!(!i||i.left==i.right)&&(zl=o.right-i.right<3)}function Re(e){if(null!=ns)return ns;var t=r(e,n("span","x")),i=t.getBoundingClientRect(),o=Wl(t,0,1).getBoundingClientRect();return ns=Math.abs(i.left-o.left)>1}function Be(e,t){arguments.length>2&&(t.dependencies=Array.prototype.slice.call(arguments,2)),is[e]=t}function Ge(e){if("string"==typeof e&&os.hasOwnProperty(e))e=os[e];else if(e&&"string"==typeof e.name&&os.hasOwnProperty(e.name)){var t=os[e.name];"string"==typeof t&&(t={name:t}),(e=b(t,e)).name=t.name}else{if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+xml$/.test(e))return Ge("application/xml");if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+json$/.test(e))return Ge("application/json")}return"string"==typeof e?{name:e}:e||{name:"null"}}function Ue(e,t){t=Ge(t);var r=is[t.name];if(!r)return Ue(e,"text/plain");var n=r(e,t);if(ls.hasOwnProperty(t.name)){var i=ls[t.name];for(var o in i)i.hasOwnProperty(o)&&(n.hasOwnProperty(o)&&(n["_"+o]=n[o]),n[o]=i[o])}if(n.name=t.name,t.helperType&&(n.helperType=t.helperType),t.modeProps)for(var l in t.modeProps)n[l]=t.modeProps[l];return n}function Ve(e,t){c(t,ls.hasOwnProperty(e)?ls[e]:ls[e]={})}function Ke(e,t){if(!0===t)return t;if(e.copyState)return e.copyState(t);var r={};for(var n in t){var i=t[n];i instanceof Array&&(i=i.concat([])),r[n]=i}return r}function je(e,t){for(var r;e.innerMode&&(r=e.innerMode(t))&&r.mode!=e;)t=r.state,e=r.mode;return r||{mode:e,state:t}}function Xe(e,t,r){return!e.startState||e.startState(t,r)}function Ye(e,t,r,n){var i=[e.state.modeGen],o={};tt(e,t.text,e.doc.mode,r,function(e,t){return i.push(e,t)},o,n);for(var l=r.state,s=0;s<e.state.overlays.length;++s)!function(n){var l=e.state.overlays[n],s=1,a=0;r.state=!0,tt(e,t.text,l.mode,r,function(e,t){for(var r=s;a<e;){var n=i[s];n>e&&i.splice(s,1,e,i[s+1],n),s+=2,a=Math.min(e,n)}if(t)if(l.opaque)i.splice(r,s-r,e,"overlay "+t),s=r+2;else for(;r<s;r+=2){var o=i[r+1];i[r+1]=(o?o+" ":"")+"overlay "+t}},o)}(s);return r.state=l,{styles:i,classes:o.bgClass||o.textClass?o:null}}function _e(e,t,r){if(!t.styles||t.styles[0]!=e.state.modeGen){var n=$e(e,W(t)),i=t.text.length>e.options.maxHighlightLength&&Ke(e.doc.mode,n.state),o=Ye(e,t,n);i&&(n.state=i),t.stateAfter=n.save(!i),t.styles=o.styles,o.classes?t.styleClasses=o.classes:t.styleClasses&&(t.styleClasses=null),r===e.doc.highlightFrontier&&(e.doc.modeFrontier=Math.max(e.doc.modeFrontier,++e.doc.highlightFrontier))}return t.styles}function $e(e,t,r){var n=e.doc,i=e.display;if(!n.mode.startState)return new us(n,!0,t);var o=rt(e,t,r),l=o>n.first&&M(n,o-1).stateAfter,s=l?us.fromSaved(n,l,o):new us(n,Xe(n.mode),o);return n.iter(o,t,function(r){qe(e,r.text,s);var n=s.line;r.stateAfter=n==t-1||n%5==0||n>=i.viewFrom&&n<i.viewTo?s.save():null,s.nextLine()}),r&&(n.modeFrontier=s.line),s}function qe(e,t,r,n){var i=e.doc.mode,o=new ss(t,e.options.tabSize,r);for(o.start=o.pos=n||0,""==t&&Ze(i,r.state);!o.eol();)Qe(i,o,r.state),o.start=o.pos}function Ze(e,t){if(e.blankLine)return e.blankLine(t);if(e.innerMode){var r=je(e,t);return r.mode.blankLine?r.mode.blankLine(r.state):void 0}}function Qe(e,t,r,n){for(var i=0;i<10;i++){n&&(n[0]=je(e,r).mode);var o=e.token(t,r);if(t.pos>t.start)return o}throw new Error("Mode "+e.name+" failed to advance stream.")}function Je(e,t,r,n){var i,o,l=e.doc,s=l.mode,a=M(l,(t=U(l,t)).line),u=$e(e,t.line,r),c=new ss(a.text,e.options.tabSize,u);for(n&&(o=[]);(n||c.pos<t.ch)&&!c.eol();)c.start=c.pos,i=Qe(s,c,u.state),n&&o.push(new cs(c,i,Ke(l.mode,u.state)));return n?o:new cs(c,i,u.state)}function et(e,t){if(e)for(;;){var r=e.match(/(?:^|\s+)line-(background-)?(\S+)/);if(!r)break;e=e.slice(0,r.index)+e.slice(r.index+r[0].length);var n=r[1]?"bgClass":"textClass";null==t[n]?t[n]=r[2]:new RegExp("(?:^|s)"+r[2]+"(?:$|s)").test(t[n])||(t[n]+=" "+r[2])}return e}function tt(e,t,r,n,i,o,l){var s=r.flattenSpans;null==s&&(s=e.options.flattenSpans);var a,u=0,c=null,f=new ss(t,e.options.tabSize,n),h=e.options.addModeClass&&[null];for(""==t&&et(Ze(r,n.state),o);!f.eol();){if(f.pos>e.options.maxHighlightLength?(s=!1,l&&qe(e,t,n,f.pos),f.pos=t.length,a=null):a=et(Qe(r,f,n.state,h),o),h){var d=h[0].name;d&&(a="m-"+(a?d+" "+a:d))}if(!s||c!=a){for(;u<f.start;)i(u=Math.min(f.start,u+5e3),c);c=a}f.start=f.pos}for(;u<f.pos;){var p=Math.min(f.pos,u+5e3);i(p,c),u=p}}function rt(e,t,r){for(var n,i,o=e.doc,l=r?-1:t-(e.doc.mode.innerMode?1e3:100),s=t;s>l;--s){if(s<=o.first)return o.first;var a=M(o,s-1),u=a.stateAfter;if(u&&(!r||s+(u instanceof as?u.lookAhead:0)<=o.modeFrontier))return s;var c=f(a.text,null,e.options.tabSize);(null==i||n>c)&&(i=s-1,n=c)}return i}function nt(e,t){if(e.modeFrontier=Math.min(e.modeFrontier,t),!(e.highlightFrontier<t-10)){for(var r=e.first,n=t-1;n>r;n--){var i=M(e,n).stateAfter;if(i&&(!(i instanceof as)||n+i.lookAhead<t)){r=n+1;break}}e.highlightFrontier=Math.min(e.highlightFrontier,r)}}function it(e,t,r,n){e.text=t,e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null),null!=e.order&&(e.order=null),re(e),ne(e,r);var i=n?n(e):1;i!=e.height&&A(e,i)}function ot(e){e.parent=null,re(e)}function lt(e,t){if(!e||/^\s*$/.test(e))return null;var r=t.addModeClass?ps:ds;return r[e]||(r[e]=e.replace(/\S+/g,"cm-$&"))}function st(e,t){var r=i("span",null,null,ml?"padding-right: .1px":null),n={pre:i("pre",[r],"CodeMirror-line"),content:r,col:0,pos:0,cm:e,trailingSpace:!1,splitSpaces:(gl||ml)&&e.getOption("lineWrapping")};t.measure={};for(var o=0;o<=(t.rest?t.rest.length:0);o++){var l=o?t.rest[o-1]:t.line,s=void 0;n.pos=0,n.addToken=ut,ze(e.display.measure)&&(s=Se(l,e.doc.direction))&&(n.addToken=ft(n.addToken,s)),n.map=[],dt(l,n,_e(e,l,t!=e.display.externalMeasured&&W(l))),l.styleClasses&&(l.styleClasses.bgClass&&(n.bgClass=a(l.styleClasses.bgClass,n.bgClass||"")),l.styleClasses.textClass&&(n.textClass=a(l.styleClasses.textClass,n.textClass||""))),0==n.map.length&&n.map.push(0,0,n.content.appendChild(Ie(e.display.measure))),0==o?(t.measure.map=n.map,t.measure.cache={}):((t.measure.maps||(t.measure.maps=[])).push(n.map),(t.measure.caches||(t.measure.caches=[])).push({}))}if(ml){var u=n.content.lastChild;(/\bcm-tab\b/.test(u.className)||u.querySelector&&u.querySelector(".cm-tab"))&&(n.content.className="cm-tab-wrap-hack")}return Te(e,"renderLine",e,t.line,n.pre),n.pre.className&&(n.textClass=a(n.pre.className,n.textClass||"")),n}function at(e){var t=n("span","•","cm-invalidchar");return t.title="\\u"+e.charCodeAt(0).toString(16),t.setAttribute("aria-label",t.title),t}function ut(e,t,r,i,o,l,s){if(t){var a,u=e.splitSpaces?ct(t,e.trailingSpace):t,c=e.cm.state.specialChars,f=!1;if(c.test(t)){a=document.createDocumentFragment();for(var h=0;;){c.lastIndex=h;var d=c.exec(t),g=d?d.index-h:t.length-h;if(g){var v=document.createTextNode(u.slice(h,h+g));gl&&vl<9?a.appendChild(n("span",[v])):a.appendChild(v),e.map.push(e.pos,e.pos+g,v),e.col+=g,e.pos+=g}if(!d)break;h+=g+1;var m=void 0;if("\t"==d[0]){var y=e.cm.options.tabSize,b=y-e.col%y;(m=a.appendChild(n("span",p(b),"cm-tab"))).setAttribute("role","presentation"),m.setAttribute("cm-text","\t"),e.col+=b}else"\r"==d[0]||"\n"==d[0]?((m=a.appendChild(n("span","\r"==d[0]?"␍":"␤","cm-invalidchar"))).setAttribute("cm-text",d[0]),e.col+=1):((m=e.cm.options.specialCharPlaceholder(d[0])).setAttribute("cm-text",d[0]),gl&&vl<9?a.appendChild(n("span",[m])):a.appendChild(m),e.col+=1);e.map.push(e.pos,e.pos+1,m),e.pos++}}else e.col+=t.length,a=document.createTextNode(u),e.map.push(e.pos,e.pos+t.length,a),gl&&vl<9&&(f=!0),e.pos+=t.length;if(e.trailingSpace=32==u.charCodeAt(t.length-1),r||i||o||f||s){var w=r||"";i&&(w+=i),o&&(w+=o);var x=n("span",[a],w,s);return l&&(x.title=l),e.content.appendChild(x)}e.content.appendChild(a)}}function ct(e,t){if(e.length>1&&!/  /.test(e))return e;for(var r=t,n="",i=0;i<e.length;i++){var o=e.charAt(i);" "!=o||!r||i!=e.length-1&&32!=e.charCodeAt(i+1)||(o=" "),n+=o,r=" "==o}return n}function ft(e,t){return function(r,n,i,o,l,s,a){i=i?i+" cm-force-border":"cm-force-border";for(var u=r.pos,c=u+n.length;;){for(var f=void 0,h=0;h<t.length&&!((f=t[h]).to>u&&f.from<=u);h++);if(f.to>=c)return e(r,n,i,o,l,s,a);e(r,n.slice(0,f.to-u),i,o,null,s,a),o=null,n=n.slice(f.to-u),u=f.to}}}function ht(e,t,r,n){var i=!n&&r.widgetNode;i&&e.map.push(e.pos,e.pos+t,i),!n&&e.cm.display.input.needsContentAttribute&&(i||(i=e.content.appendChild(document.createElement("span"))),i.setAttribute("cm-marker",r.id)),i&&(e.cm.display.input.setUneditable(i),e.content.appendChild(i)),e.pos+=t,e.trailingSpace=!1}function dt(e,t,r){var n=e.markedSpans,i=e.text,o=0;if(n)for(var l,s,a,u,c,f,h,d=i.length,p=0,g=1,v="",m=0;;){if(m==p){a=u=c=f=s="",h=null,m=1/0;for(var y=[],b=void 0,w=0;w<n.length;++w){var x=n[w],C=x.marker;"bookmark"==C.type&&x.from==p&&C.widgetNode?y.push(C):x.from<=p&&(null==x.to||x.to>p||C.collapsed&&x.to==p&&x.from==p)?(null!=x.to&&x.to!=p&&m>x.to&&(m=x.to,u=""),C.className&&(a+=" "+C.className),C.css&&(s=(s?s+";":"")+C.css),C.startStyle&&x.from==p&&(c+=" "+C.startStyle),C.endStyle&&x.to==m&&(b||(b=[])).push(C.endStyle,x.to),C.title&&!f&&(f=C.title),C.collapsed&&(!h||le(h.marker,C)<0)&&(h=x)):x.from>p&&m>x.from&&(m=x.from)}if(b)for(var S=0;S<b.length;S+=2)b[S+1]==m&&(u+=" "+b[S]);if(!h||h.from==p)for(var L=0;L<y.length;++L)ht(t,0,y[L]);if(h&&(h.from||0)==p){if(ht(t,(null==h.to?d+1:h.to)-p,h.marker,null==h.from),null==h.to)return;h.to==p&&(h=!1)}}if(p>=d)break;for(var k=Math.min(d,m);;){if(v){var T=p+v.length;if(!h){var M=T>k?v.slice(0,k-p):v;t.addToken(t,M,l?l+a:a,c,p+M.length==m?u:"",f,s)}if(T>=k){v=v.slice(k-p),p=k;break}p=T,c=""}v=i.slice(o,o=r[g++]),l=lt(r[g++],t.cm.options)}}else for(var N=1;N<r.length;N+=2)t.addToken(t,i.slice(o,o=r[N]),lt(r[N+1],t.cm.options))}function pt(e,t,r){this.line=t,this.rest=de(t),this.size=this.rest?W(g(this.rest))-r+1:1,this.node=this.text=null,this.hidden=ve(e,t)}function gt(e,t,r){for(var n,i=[],o=t;o<r;o=n){var l=new pt(e.doc,M(e.doc,o),o);n=o+l.size,i.push(l)}return i}function vt(e){gs?gs.ops.push(e):e.ownsGroup=gs={ops:[e],delayedCallbacks:[]}}function mt(e){var t=e.delayedCallbacks,r=0;do{for(;r<t.length;r++)t[r].call(null);for(var n=0;n<e.ops.length;n++){var i=e.ops[n];if(i.cursorActivityHandlers)for(;i.cursorActivityCalled<i.cursorActivityHandlers.length;)i.cursorActivityHandlers[i.cursorActivityCalled++].call(null,i.cm)}}while(r<t.length)}function yt(e,t){var r=e.ownsGroup;if(r)try{mt(r)}finally{gs=null,t(r)}}function bt(e,t){var r=Le(e,t);if(r.length){var n,i=Array.prototype.slice.call(arguments,2);gs?n=gs.delayedCallbacks:vs?n=vs:(n=vs=[],setTimeout(wt,0));for(var o=0;o<r.length;++o)!function(e){n.push(function(){return r[e].apply(null,i)})}(o)}}function wt(){var e=vs;vs=null;for(var t=0;t<e.length;++t)e[t]()}function xt(e,t,r,n){for(var i=0;i<t.changes.length;i++){var o=t.changes[i];"text"==o?kt(e,t):"gutter"==o?Mt(e,t,r,n):"class"==o?Tt(e,t):"widget"==o&&Nt(e,t,n)}t.changes=null}function Ct(e){return e.node==e.text&&(e.node=n("div",null,null,"position: relative"),e.text.parentNode&&e.text.parentNode.replaceChild(e.node,e.text),e.node.appendChild(e.text),gl&&vl<8&&(e.node.style.zIndex=2)),e.node}function St(e,t){var r=t.bgClass?t.bgClass+" "+(t.line.bgClass||""):t.line.bgClass;if(r&&(r+=" CodeMirror-linebackground"),t.background)r?t.background.className=r:(t.background.parentNode.removeChild(t.background),t.background=null);else if(r){var i=Ct(t);t.background=i.insertBefore(n("div",null,r),i.firstChild),e.display.input.setUneditable(t.background)}}function Lt(e,t){var r=e.display.externalMeasured;return r&&r.line==t.line?(e.display.externalMeasured=null,t.measure=r.measure,r.built):st(e,t)}function kt(e,t){var r=t.text.className,n=Lt(e,t);t.text==t.node&&(t.node=n.pre),t.text.parentNode.replaceChild(n.pre,t.text),t.text=n.pre,n.bgClass!=t.bgClass||n.textClass!=t.textClass?(t.bgClass=n.bgClass,t.textClass=n.textClass,Tt(e,t)):r&&(t.text.className=r)}function Tt(e,t){St(e,t),t.line.wrapClass?Ct(t).className=t.line.wrapClass:t.node!=t.text&&(t.node.className="");var r=t.textClass?t.textClass+" "+(t.line.textClass||""):t.line.textClass;t.text.className=r||""}function Mt(e,t,r,i){if(t.gutter&&(t.node.removeChild(t.gutter),t.gutter=null),t.gutterBackground&&(t.node.removeChild(t.gutterBackground),t.gutterBackground=null),t.line.gutterClass){var o=Ct(t);t.gutterBackground=n("div",null,"CodeMirror-gutter-background "+t.line.gutterClass,"left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px; width: "+i.gutterTotalWidth+"px"),e.display.input.setUneditable(t.gutterBackground),o.insertBefore(t.gutterBackground,t.text)}var l=t.line.gutterMarkers;if(e.options.lineNumbers||l){var s=Ct(t),a=t.gutter=n("div",null,"CodeMirror-gutter-wrapper","left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px");if(e.display.input.setUneditable(a),s.insertBefore(a,t.text),t.line.gutterClass&&(a.className+=" "+t.line.gutterClass),!e.options.lineNumbers||l&&l["CodeMirror-linenumbers"]||(t.lineNumber=a.appendChild(n("div",F(e.options,r),"CodeMirror-linenumber CodeMirror-gutter-elt","left: "+i.gutterLeft["CodeMirror-linenumbers"]+"px; width: "+e.display.lineNumInnerWidth+"px"))),l)for(var u=0;u<e.options.gutters.length;++u){var c=e.options.gutters[u],f=l.hasOwnProperty(c)&&l[c];f&&a.appendChild(n("div",[f],"CodeMirror-gutter-elt","left: "+i.gutterLeft[c]+"px; width: "+i.gutterWidth[c]+"px"))}}}function Nt(e,t,r){t.alignable&&(t.alignable=null);for(var n=t.node.firstChild,i=void 0;n;n=i)i=n.nextSibling,"CodeMirror-linewidget"==n.className&&t.node.removeChild(n);At(e,t,r)}function Ot(e,t,r,n){var i=Lt(e,t);return t.text=t.node=i.pre,i.bgClass&&(t.bgClass=i.bgClass),i.textClass&&(t.textClass=i.textClass),Tt(e,t),Mt(e,t,r,n),At(e,t,n),t.node}function At(e,t,r){if(Wt(e,t.line,t,r,!0),t.rest)for(var n=0;n<t.rest.length;n++)Wt(e,t.rest[n],t,r,!1)}function Wt(e,t,r,i,o){if(t.widgets)for(var l=Ct(r),s=0,a=t.widgets;s<a.length;++s){var u=a[s],c=n("div",[u.node],"CodeMirror-linewidget");u.handleMouseEvents||c.setAttribute("cm-ignore-events","true"),Dt(u,c,r,i),e.display.input.setUneditable(c),o&&u.above?l.insertBefore(c,r.gutter||r.text):l.appendChild(c),bt(u,"redraw")}}function Dt(e,t,r,n){if(e.noHScroll){(r.alignable||(r.alignable=[])).push(t);var i=n.wrapperWidth;t.style.left=n.fixedPos+"px",e.coverGutter||(i-=n.gutterTotalWidth,t.style.paddingLeft=n.gutterTotalWidth+"px"),t.style.width=i+"px"}e.coverGutter&&(t.style.zIndex=5,t.style.position="relative",e.noHScroll||(t.style.marginLeft=-n.gutterTotalWidth+"px"))}function Ht(e){if(null!=e.height)return e.height;var t=e.doc.cm;if(!t)return 0;if(!o(document.body,e.node)){var i="position: relative;";e.coverGutter&&(i+="margin-left: -"+t.display.gutters.offsetWidth+"px;"),e.noHScroll&&(i+="width: "+t.display.wrapper.clientWidth+"px;"),r(t.display.measure,n("div",[e.node],null,i))}return e.height=e.node.parentNode.offsetHeight}function Ft(e,t){for(var r=Ee(t);r!=e.wrapper;r=r.parentNode)if(!r||1==r.nodeType&&"true"==r.getAttribute("cm-ignore-events")||r.parentNode==e.sizer&&r!=e.mover)return!0}function Et(e){return e.lineSpace.offsetTop}function Pt(e){return e.mover.offsetHeight-e.lineSpace.offsetHeight}function It(e){if(e.cachedPaddingH)return e.cachedPaddingH;var t=r(e.measure,n("pre","x")),i=window.getComputedStyle?window.getComputedStyle(t):t.currentStyle,o={left:parseInt(i.paddingLeft),right:parseInt(i.paddingRight)};return isNaN(o.left)||isNaN(o.right)||(e.cachedPaddingH=o),o}function zt(e){return Rl-e.display.nativeBarWidth}function Rt(e){return e.display.scroller.clientWidth-zt(e)-e.display.barWidth}function Bt(e){return e.display.scroller.clientHeight-zt(e)-e.display.barHeight}function Gt(e,t,r){var n=e.options.lineWrapping,i=n&&Rt(e);if(!t.measure.heights||n&&t.measure.width!=i){var o=t.measure.heights=[];if(n){t.measure.width=i;for(var l=t.text.firstChild.getClientRects(),s=0;s<l.length-1;s++){var a=l[s],u=l[s+1];Math.abs(a.bottom-u.bottom)>2&&o.push((a.bottom+u.top)/2-r.top)}}o.push(r.bottom-r.top)}}function Ut(e,t,r){if(e.line==t)return{map:e.measure.map,cache:e.measure.cache};for(var n=0;n<e.rest.length;n++)if(e.rest[n]==t)return{map:e.measure.maps[n],cache:e.measure.caches[n]};for(var i=0;i<e.rest.length;i++)if(W(e.rest[i])>r)return{map:e.measure.maps[i],cache:e.measure.caches[i],before:!0}}function Vt(e,t){var n=W(t=fe(t)),i=e.display.externalMeasured=new pt(e.doc,t,n);i.lineN=n;var o=i.built=st(e,i);return i.text=o.pre,r(e.display.lineMeasure,o.pre),i}function Kt(e,t,r,n){return Yt(e,Xt(e,t),r,n)}function jt(e,t){if(t>=e.display.viewFrom&&t<e.display.viewTo)return e.display.view[Lr(e,t)];var r=e.display.externalMeasured;return r&&t>=r.lineN&&t<r.lineN+r.size?r:void 0}function Xt(e,t){var r=W(t),n=jt(e,r);n&&!n.text?n=null:n&&n.changes&&(xt(e,n,r,br(e)),e.curOp.forceUpdate=!0),n||(n=Vt(e,t));var i=Ut(n,t,r);return{line:t,view:n,rect:null,map:i.map,cache:i.cache,before:i.before,hasHeights:!1}}function Yt(e,t,r,n,i){t.before&&(r=-1);var o,l=r+(n||"");return t.cache.hasOwnProperty(l)?o=t.cache[l]:(t.rect||(t.rect=t.view.text.getBoundingClientRect()),t.hasHeights||(Gt(e,t.view,t.rect),t.hasHeights=!0),(o=qt(e,t,r,n)).bogus||(t.cache[l]=o)),{left:o.left,right:o.right,top:i?o.rtop:o.top,bottom:i?o.rbottom:o.bottom}}function _t(e,t,r){for(var n,i,o,l,s,a,u=0;u<e.length;u+=3)if(s=e[u],a=e[u+1],t<s?(i=0,o=1,l="left"):t<a?o=(i=t-s)+1:(u==e.length-3||t==a&&e[u+3]>t)&&(i=(o=a-s)-1,t>=a&&(l="right")),null!=i){if(n=e[u+2],s==a&&r==(n.insertLeft?"left":"right")&&(l=r),"left"==r&&0==i)for(;u&&e[u-2]==e[u-3]&&e[u-1].insertLeft;)n=e[2+(u-=3)],l="left";if("right"==r&&i==a-s)for(;u<e.length-3&&e[u+3]==e[u+4]&&!e[u+5].insertLeft;)n=e[(u+=3)+2],l="right";break}return{node:n,start:i,end:o,collapse:l,coverStart:s,coverEnd:a}}function $t(e,t){var r=ms;if("left"==t)for(var n=0;n<e.length&&(r=e[n]).left==r.right;n++);else for(var i=e.length-1;i>=0&&(r=e[i]).left==r.right;i--);return r}function qt(e,t,r,n){var i,o=_t(t.map,r,n),l=o.node,s=o.start,a=o.end,u=o.collapse;if(3==l.nodeType){for(var c=0;c<4;c++){for(;s&&S(t.line.text.charAt(o.coverStart+s));)--s;for(;o.coverStart+a<o.coverEnd&&S(t.line.text.charAt(o.coverStart+a));)++a;if((i=gl&&vl<9&&0==s&&a==o.coverEnd-o.coverStart?l.parentNode.getBoundingClientRect():$t(Wl(l,s,a).getClientRects(),n)).left||i.right||0==s)break;a=s,s-=1,u="right"}gl&&vl<11&&(i=Zt(e.display.measure,i))}else{s>0&&(u=n="right");var f;i=e.options.lineWrapping&&(f=l.getClientRects()).length>1?f["right"==n?f.length-1:0]:l.getBoundingClientRect()}if(gl&&vl<9&&!s&&(!i||!i.left&&!i.right)){var h=l.parentNode.getClientRects()[0];i=h?{left:h.left,right:h.left+yr(e.display),top:h.top,bottom:h.bottom}:ms}for(var d=i.top-t.rect.top,p=i.bottom-t.rect.top,g=(d+p)/2,v=t.view.measure.heights,m=0;m<v.length-1&&!(g<v[m]);m++);var y=m?v[m-1]:0,b=v[m],w={left:("right"==u?i.right:i.left)-t.rect.left,right:("left"==u?i.left:i.right)-t.rect.left,top:y,bottom:b};return i.left||i.right||(w.bogus=!0),e.options.singleCursorHeightPerLine||(w.rtop=d,w.rbottom=p),w}function Zt(e,t){if(!window.screen||null==screen.logicalXDPI||screen.logicalXDPI==screen.deviceXDPI||!Re(e))return t;var r=screen.logicalXDPI/screen.deviceXDPI,n=screen.logicalYDPI/screen.deviceYDPI;return{left:t.left*r,right:t.right*r,top:t.top*n,bottom:t.bottom*n}}function Qt(e){if(e.measure&&(e.measure.cache={},e.measure.heights=null,e.rest))for(var t=0;t<e.rest.length;t++)e.measure.caches[t]={}}function Jt(e){e.display.externalMeasure=null,t(e.display.lineMeasure);for(var r=0;r<e.display.view.length;r++)Qt(e.display.view[r])}function er(e){Jt(e),e.display.cachedCharWidth=e.display.cachedTextHeight=e.display.cachedPaddingH=null,e.options.lineWrapping||(e.display.maxLineChanged=!0),e.display.lineNumChars=null}function tr(){return bl&&kl?-(document.body.getBoundingClientRect().left-parseInt(getComputedStyle(document.body).marginLeft)):window.pageXOffset||(document.documentElement||document.body).scrollLeft}function rr(){return bl&&kl?-(document.body.getBoundingClientRect().top-parseInt(getComputedStyle(document.body).marginTop)):window.pageYOffset||(document.documentElement||document.body).scrollTop}function nr(e){var t=0;if(e.widgets)for(var r=0;r<e.widgets.length;++r)e.widgets[r].above&&(t+=Ht(e.widgets[r]));return t}function ir(e,t,r,n,i){if(!i){var o=nr(t);r.top+=o,r.bottom+=o}if("line"==n)return r;n||(n="local");var l=ye(t);if("local"==n?l+=Et(e.display):l-=e.display.viewOffset,"page"==n||"window"==n){var s=e.display.lineSpace.getBoundingClientRect();l+=s.top+("window"==n?0:rr());var a=s.left+("window"==n?0:tr());r.left+=a,r.right+=a}return r.top+=l,r.bottom+=l,r}function or(e,t,r){if("div"==r)return t;var n=t.left,i=t.top;if("page"==r)n-=tr(),i-=rr();else if("local"==r||!r){var o=e.display.sizer.getBoundingClientRect();n+=o.left,i+=o.top}var l=e.display.lineSpace.getBoundingClientRect();return{left:n-l.left,top:i-l.top}}function lr(e,t,r,n,i){return n||(n=M(e.doc,t.line)),ir(e,n,Kt(e,n,t.ch,i),r)}function sr(e,t,r,n,i,o){function l(t,l){var s=Yt(e,i,t,l?"right":"left",o);return l?s.left=s.right:s.right=s.left,ir(e,n,s,r)}function s(e,t,r){var n=1==a[t].level;return l(r?e-1:e,n!=r)}n=n||M(e.doc,t.line),i||(i=Xt(e,n));var a=Se(n,e.doc.direction),u=t.ch,c=t.sticky;if(u>=n.text.length?(u=n.text.length,c="before"):u<=0&&(u=0,c="after"),!a)return l("before"==c?u-1:u,"before"==c);var f=Ce(a,u,c),h=$l,d=s(u,f,"before"==c);return null!=h&&(d.other=s(u,h,"before"!=c)),d}function ar(e,t){var r=0;t=U(e.doc,t),e.options.lineWrapping||(r=yr(e.display)*t.ch);var n=M(e.doc,t.line),i=ye(n)+Et(e.display);return{left:r,right:r,top:i,bottom:i+n.height}}function ur(e,t,r,n,i){var o=E(e,t,r);return o.xRel=i,n&&(o.outside=!0),o}function cr(e,t,r){var n=e.doc;if((r+=e.display.viewOffset)<0)return ur(n.first,0,null,!0,-1);var i=D(n,r),o=n.first+n.size-1;if(i>o)return ur(n.first+n.size-1,M(n,o).text.length,null,!0,1);t<0&&(t=0);for(var l=M(n,i);;){var s=pr(e,l,i,t,r),a=ue(l),u=a&&a.find(0,!0);if(!a||!(s.ch>u.from.ch||s.ch==u.from.ch&&s.xRel>0))return s;i=W(l=u.to.line)}}function fr(e,t,r,n){n-=nr(t);var i=t.text.length,o=k(function(t){return Yt(e,r,t-1).bottom<=n},i,0);return i=k(function(t){return Yt(e,r,t).top>n},o,i),{begin:o,end:i}}function hr(e,t,r,n){return r||(r=Xt(e,t)),fr(e,t,r,ir(e,t,Yt(e,r,n),"line").top)}function dr(e,t,r,n){return!(e.bottom<=r)&&(e.top>r||(n?e.left:e.right)>t)}function pr(e,t,r,n,i){i-=ye(t);var o=Xt(e,t),l=nr(t),s=0,a=t.text.length,u=!0,c=Se(t,e.doc.direction);if(c){var f=(e.options.lineWrapping?vr:gr)(e,t,r,o,c,n,i);s=(u=1!=f.level)?f.from:f.to-1,a=u?f.to:f.from-1}var h,d,p=null,g=null,v=k(function(t){var r=Yt(e,o,t);return r.top+=l,r.bottom+=l,!!dr(r,n,i,!1)&&(r.top<=i&&r.left<=n&&(p=t,g=r),!0)},s,a),m=!1;if(g){var y=n-g.left<g.right-n,b=y==u;v=p+(b?0:1),d=b?"after":"before",h=y?g.left:g.right}else{u||v!=a&&v!=s||v++,d=0==v?"after":v==t.text.length?"before":Yt(e,o,v-(u?1:0)).bottom+l<=i==u?"after":"before";var w=sr(e,E(r,v,d),"line",t,o);h=w.left,m=i<w.top||i>=w.bottom}return v=L(t.text,v,1),ur(r,v,d,m,n-h)}function gr(e,t,r,n,i,o,l){var s=k(function(s){var a=i[s],u=1!=a.level;return dr(sr(e,E(r,u?a.to:a.from,u?"before":"after"),"line",t,n),o,l,!0)},0,i.length-1),a=i[s];if(s>0){var u=1!=a.level,c=sr(e,E(r,u?a.from:a.to,u?"after":"before"),"line",t,n);dr(c,o,l,!0)&&c.top>l&&(a=i[s-1])}return a}function vr(e,t,r,n,i,o,l){for(var s=fr(e,t,n,l),a=s.begin,u=s.end,c=null,f=null,h=0;h<i.length;h++){var d=i[h];if(!(d.from>=u||d.to<=a)){var p=Yt(e,n,1!=d.level?Math.min(u,d.to)-1:Math.max(a,d.from)).right,g=p<o?o-p+1e9:p-o;(!c||f>g)&&(c=d,f=g)}}return c||(c=i[i.length-1]),c.from<a&&(c={from:a,to:c.to,level:c.level}),c.to>u&&(c={from:c.from,to:u,level:c.level}),c}function mr(e){if(null!=e.cachedTextHeight)return e.cachedTextHeight;if(null==hs){hs=n("pre");for(var i=0;i<49;++i)hs.appendChild(document.createTextNode("x")),hs.appendChild(n("br"));hs.appendChild(document.createTextNode("x"))}r(e.measure,hs);var o=hs.offsetHeight/50;return o>3&&(e.cachedTextHeight=o),t(e.measure),o||1}function yr(e){if(null!=e.cachedCharWidth)return e.cachedCharWidth;var t=n("span","xxxxxxxxxx"),i=n("pre",[t]);r(e.measure,i);var o=t.getBoundingClientRect(),l=(o.right-o.left)/10;return l>2&&(e.cachedCharWidth=l),l||10}function br(e){for(var t=e.display,r={},n={},i=t.gutters.clientLeft,o=t.gutters.firstChild,l=0;o;o=o.nextSibling,++l)r[e.options.gutters[l]]=o.offsetLeft+o.clientLeft+i,n[e.options.gutters[l]]=o.clientWidth;return{fixedPos:wr(t),gutterTotalWidth:t.gutters.offsetWidth,gutterLeft:r,gutterWidth:n,wrapperWidth:t.wrapper.clientWidth}}function wr(e){return e.scroller.getBoundingClientRect().left-e.sizer.getBoundingClientRect().left}function xr(e){var t=mr(e.display),r=e.options.lineWrapping,n=r&&Math.max(5,e.display.scroller.clientWidth/yr(e.display)-3);return function(i){if(ve(e.doc,i))return 0;var o=0;if(i.widgets)for(var l=0;l<i.widgets.length;l++)i.widgets[l].height&&(o+=i.widgets[l].height);return r?o+(Math.ceil(i.text.length/n)||1)*t:o+t}}function Cr(e){var t=e.doc,r=xr(e);t.iter(function(e){var t=r(e);t!=e.height&&A(e,t)})}function Sr(e,t,r,n){var i=e.display;if(!r&&"true"==Ee(t).getAttribute("cm-not-content"))return null;var o,l,s=i.lineSpace.getBoundingClientRect();try{o=t.clientX-s.left,l=t.clientY-s.top}catch(t){return null}var a,u=cr(e,o,l);if(n&&1==u.xRel&&(a=M(e.doc,u.line).text).length==u.ch){var c=f(a,a.length,e.options.tabSize)-a.length;u=E(u.line,Math.max(0,Math.round((o-It(e.display).left)/yr(e.display))-c))}return u}function Lr(e,t){if(t>=e.display.viewTo)return null;if((t-=e.display.viewFrom)<0)return null;for(var r=e.display.view,n=0;n<r.length;n++)if((t-=r[n].size)<0)return n}function kr(e){e.display.input.showSelection(e.display.input.prepareSelection())}function Tr(e,t){void 0===t&&(t=!0);for(var r=e.doc,n={},i=n.cursors=document.createDocumentFragment(),o=n.selection=document.createDocumentFragment(),l=0;l<r.sel.ranges.length;l++)if(t||l!=r.sel.primIndex){var s=r.sel.ranges[l];if(!(s.from().line>=e.display.viewTo||s.to().line<e.display.viewFrom)){var a=s.empty();(a||e.options.showCursorWhenSelecting)&&Mr(e,s.head,i),a||Or(e,s,o)}}return n}function Mr(e,t,r){var i=sr(e,t,"div",null,null,!e.options.singleCursorHeightPerLine),o=r.appendChild(n("div"," ","CodeMirror-cursor"));if(o.style.left=i.left+"px",o.style.top=i.top+"px",o.style.height=Math.max(0,i.bottom-i.top)*e.options.cursorHeight+"px",i.other){var l=r.appendChild(n("div"," ","CodeMirror-cursor CodeMirror-secondarycursor"));l.style.display="",l.style.left=i.other.left+"px",l.style.top=i.other.top+"px",l.style.height=.85*(i.other.bottom-i.other.top)+"px"}}function Nr(e,t){return e.top-t.top||e.left-t.left}function Or(e,t,r){function i(e,t,r,i){t<0&&(t=0),t=Math.round(t),i=Math.round(i),a.appendChild(n("div",null,"CodeMirror-selected","position: absolute; left: "+e+"px;\n                             top: "+t+"px; width: "+(null==r?f-e:r)+"px;\n                             height: "+(i-t)+"px"))}function o(t,r,n){function o(r,n){return lr(e,E(t,r),"div",u,n)}var l,a,u=M(s,t),h=u.text.length,d=Se(u,s.direction);return xe(d,r||0,null==n?h:n,function(t,s,p,g){var v=o(t,"ltr"==p?"left":"right"),m=o(s-1,"ltr"==p?"right":"left");if("ltr"==p){var y=null==r&&0==t?c:v.left,b=null==n&&s==h?f:m.right;m.top-v.top<=3?i(y,m.top,b-y,m.bottom):(i(y,v.top,null,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top),i(c,m.top,m.right,m.bottom))}else if(t<s){var w=null==r&&0==t?f:v.right,x=null==n&&s==h?c:m.left;if(m.top-v.top<=3)i(x,m.top,w-x,m.bottom);else{var C=c;if(g){var S=hr(e,u,null,t).end;C=o(S-(/\s/.test(u.text.charAt(S-1))?2:1),"left").left}i(C,v.top,w-C,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top);var L=null;d.length,L=o(hr(e,u,null,s).begin,"right").right-x,i(x,m.top,L,m.bottom)}}(!l||Nr(v,l)<0)&&(l=v),Nr(m,l)<0&&(l=m),(!a||Nr(v,a)<0)&&(a=v),Nr(m,a)<0&&(a=m)}),{start:l,end:a}}var l=e.display,s=e.doc,a=document.createDocumentFragment(),u=It(e.display),c=u.left,f=Math.max(l.sizerWidth,Rt(e)-l.sizer.offsetLeft)-u.right,h=t.from(),d=t.to();if(h.line==d.line)o(h.line,h.ch,d.ch);else{var p=M(s,h.line),g=M(s,d.line),v=fe(p)==fe(g),m=o(h.line,h.ch,v?p.text.length+1:null).end,y=o(d.line,v?0:null,d.ch).start;v&&(m.top<y.top-2?(i(m.right,m.top,null,m.bottom),i(c,y.top,y.left,y.bottom)):i(m.right,m.top,y.left-m.right,m.bottom)),m.bottom<y.top&&i(c,m.bottom,null,y.top)}r.appendChild(a)}function Ar(e){if(e.state.focused){var t=e.display;clearInterval(t.blinker);var r=!0;t.cursorDiv.style.visibility="",e.options.cursorBlinkRate>0?t.blinker=setInterval(function(){return t.cursorDiv.style.visibility=(r=!r)?"":"hidden"},e.options.cursorBlinkRate):e.options.cursorBlinkRate<0&&(t.cursorDiv.style.visibility="hidden")}}function Wr(e){e.state.focused||(e.display.input.focus(),Hr(e))}function Dr(e){e.state.delayingBlurEvent=!0,setTimeout(function(){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1,Fr(e))},100)}function Hr(e,t){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1),"nocursor"!=e.options.readOnly&&(e.state.focused||(Te(e,"focus",e,t),e.state.focused=!0,s(e.display.wrapper,"CodeMirror-focused"),e.curOp||e.display.selForContextMenu==e.doc.sel||(e.display.input.reset(),ml&&setTimeout(function(){return e.display.input.reset(!0)},20)),e.display.input.receivedFocus()),Ar(e))}function Fr(e,t){e.state.delayingBlurEvent||(e.state.focused&&(Te(e,"blur",e,t),e.state.focused=!1,Fl(e.display.wrapper,"CodeMirror-focused")),clearInterval(e.display.blinker),setTimeout(function(){e.state.focused||(e.display.shift=!1)},150))}function Er(e){for(var t=e.display,r=t.lineDiv.offsetTop,n=0;n<t.view.length;n++){var i=t.view[n],o=void 0;if(!i.hidden){if(gl&&vl<8){var l=i.node.offsetTop+i.node.offsetHeight;o=l-r,r=l}else{var s=i.node.getBoundingClientRect();o=s.bottom-s.top}var a=i.line.height-o;if(o<2&&(o=mr(t)),(a>.005||a<-.005)&&(A(i.line,o),Pr(i.line),i.rest))for(var u=0;u<i.rest.length;u++)Pr(i.rest[u])}}}function Pr(e){if(e.widgets)for(var t=0;t<e.widgets.length;++t)e.widgets[t].height=e.widgets[t].node.parentNode.offsetHeight}function Ir(e,t,r){var n=r&&null!=r.top?Math.max(0,r.top):e.scroller.scrollTop;n=Math.floor(n-Et(e));var i=r&&null!=r.bottom?r.bottom:n+e.wrapper.clientHeight,o=D(t,n),l=D(t,i);if(r&&r.ensure){var s=r.ensure.from.line,a=r.ensure.to.line;s<o?(o=s,l=D(t,ye(M(t,s))+e.wrapper.clientHeight)):Math.min(a,t.lastLine())>=l&&(o=D(t,ye(M(t,a))-e.wrapper.clientHeight),l=a)}return{from:o,to:Math.max(l,o+1)}}function zr(e){var t=e.display,r=t.view;if(t.alignWidgets||t.gutters.firstChild&&e.options.fixedGutter){for(var n=wr(t)-t.scroller.scrollLeft+e.doc.scrollLeft,i=t.gutters.offsetWidth,o=n+"px",l=0;l<r.length;l++)if(!r[l].hidden){e.options.fixedGutter&&(r[l].gutter&&(r[l].gutter.style.left=o),r[l].gutterBackground&&(r[l].gutterBackground.style.left=o));var s=r[l].alignable;if(s)for(var a=0;a<s.length;a++)s[a].style.left=o}e.options.fixedGutter&&(t.gutters.style.left=n+i+"px")}}function Rr(e){if(!e.options.lineNumbers)return!1;var t=e.doc,r=F(e.options,t.first+t.size-1),i=e.display;if(r.length!=i.lineNumChars){var o=i.measure.appendChild(n("div",[n("div",r)],"CodeMirror-linenumber CodeMirror-gutter-elt")),l=o.firstChild.offsetWidth,s=o.offsetWidth-l;return i.lineGutter.style.width="",i.lineNumInnerWidth=Math.max(l,i.lineGutter.offsetWidth-s)+1,i.lineNumWidth=i.lineNumInnerWidth+s,i.lineNumChars=i.lineNumInnerWidth?r.length:-1,i.lineGutter.style.width=i.lineNumWidth+"px",Wn(e),!0}return!1}function Br(e,t){if(!Me(e,"scrollCursorIntoView")){var r=e.display,i=r.sizer.getBoundingClientRect(),o=null;if(t.top+i.top<0?o=!0:t.bottom+i.top>(window.innerHeight||document.documentElement.clientHeight)&&(o=!1),null!=o&&!Sl){var l=n("div","​",null,"position: absolute;\n                         top: "+(t.top-r.viewOffset-Et(e.display))+"px;\n                         height: "+(t.bottom-t.top+zt(e)+r.barHeight)+"px;\n                         left: "+t.left+"px; width: "+Math.max(2,t.right-t.left)+"px;");e.display.lineSpace.appendChild(l),l.scrollIntoView(o),e.display.lineSpace.removeChild(l)}}}function Gr(e,t,r,n){null==n&&(n=0);var i;e.options.lineWrapping||t!=r||(r="before"==(t=t.ch?E(t.line,"before"==t.sticky?t.ch-1:t.ch,"after"):t).sticky?E(t.line,t.ch+1,"before"):t);for(var o=0;o<5;o++){var l=!1,s=sr(e,t),a=r&&r!=t?sr(e,r):s,u=Vr(e,i={left:Math.min(s.left,a.left),top:Math.min(s.top,a.top)-n,right:Math.max(s.left,a.left),bottom:Math.max(s.bottom,a.bottom)+n}),c=e.doc.scrollTop,f=e.doc.scrollLeft;if(null!=u.scrollTop&&(qr(e,u.scrollTop),Math.abs(e.doc.scrollTop-c)>1&&(l=!0)),null!=u.scrollLeft&&(Qr(e,u.scrollLeft),Math.abs(e.doc.scrollLeft-f)>1&&(l=!0)),!l)break}return i}function Ur(e,t){var r=Vr(e,t);null!=r.scrollTop&&qr(e,r.scrollTop),null!=r.scrollLeft&&Qr(e,r.scrollLeft)}function Vr(e,t){var r=e.display,n=mr(e.display);t.top<0&&(t.top=0);var i=e.curOp&&null!=e.curOp.scrollTop?e.curOp.scrollTop:r.scroller.scrollTop,o=Bt(e),l={};t.bottom-t.top>o&&(t.bottom=t.top+o);var s=e.doc.height+Pt(r),a=t.top<n,u=t.bottom>s-n;if(t.top<i)l.scrollTop=a?0:t.top;else if(t.bottom>i+o){var c=Math.min(t.top,(u?s:t.bottom)-o);c!=i&&(l.scrollTop=c)}var f=e.curOp&&null!=e.curOp.scrollLeft?e.curOp.scrollLeft:r.scroller.scrollLeft,h=Rt(e)-(e.options.fixedGutter?r.gutters.offsetWidth:0),d=t.right-t.left>h;return d&&(t.right=t.left+h),t.left<10?l.scrollLeft=0:t.left<f?l.scrollLeft=Math.max(0,t.left-(d?0:10)):t.right>h+f-3&&(l.scrollLeft=t.right+(d?0:10)-h),l}function Kr(e,t){null!=t&&(_r(e),e.curOp.scrollTop=(null==e.curOp.scrollTop?e.doc.scrollTop:e.curOp.scrollTop)+t)}function jr(e){_r(e);var t=e.getCursor();e.curOp.scrollToPos={from:t,to:t,margin:e.options.cursorScrollMargin}}function Xr(e,t,r){null==t&&null==r||_r(e),null!=t&&(e.curOp.scrollLeft=t),null!=r&&(e.curOp.scrollTop=r)}function Yr(e,t){_r(e),e.curOp.scrollToPos=t}function _r(e){var t=e.curOp.scrollToPos;t&&(e.curOp.scrollToPos=null,$r(e,ar(e,t.from),ar(e,t.to),t.margin))}function $r(e,t,r,n){var i=Vr(e,{left:Math.min(t.left,r.left),top:Math.min(t.top,r.top)-n,right:Math.max(t.right,r.right),bottom:Math.max(t.bottom,r.bottom)+n});Xr(e,i.scrollLeft,i.scrollTop)}function qr(e,t){Math.abs(e.doc.scrollTop-t)<2||(fl||On(e,{top:t}),Zr(e,t,!0),fl&&On(e),Cn(e,100))}function Zr(e,t,r){t=Math.min(e.display.scroller.scrollHeight-e.display.scroller.clientHeight,t),(e.display.scroller.scrollTop!=t||r)&&(e.doc.scrollTop=t,e.display.scrollbars.setScrollTop(t),e.display.scroller.scrollTop!=t&&(e.display.scroller.scrollTop=t))}function Qr(e,t,r,n){t=Math.min(t,e.display.scroller.scrollWidth-e.display.scroller.clientWidth),(r?t==e.doc.scrollLeft:Math.abs(e.doc.scrollLeft-t)<2)&&!n||(e.doc.scrollLeft=t,zr(e),e.display.scroller.scrollLeft!=t&&(e.display.scroller.scrollLeft=t),e.display.scrollbars.setScrollLeft(t))}function Jr(e){var t=e.display,r=t.gutters.offsetWidth,n=Math.round(e.doc.height+Pt(e.display));return{clientHeight:t.scroller.clientHeight,viewHeight:t.wrapper.clientHeight,scrollWidth:t.scroller.scrollWidth,clientWidth:t.scroller.clientWidth,viewWidth:t.wrapper.clientWidth,barLeft:e.options.fixedGutter?r:0,docHeight:n,scrollHeight:n+zt(e)+t.barHeight,nativeBarWidth:t.nativeBarWidth,gutterWidth:r}}function en(e,t){t||(t=Jr(e));var r=e.display.barWidth,n=e.display.barHeight;tn(e,t);for(var i=0;i<4&&r!=e.display.barWidth||n!=e.display.barHeight;i++)r!=e.display.barWidth&&e.options.lineWrapping&&Er(e),tn(e,Jr(e)),r=e.display.barWidth,n=e.display.barHeight}function tn(e,t){var r=e.display,n=r.scrollbars.update(t);r.sizer.style.paddingRight=(r.barWidth=n.right)+"px",r.sizer.style.paddingBottom=(r.barHeight=n.bottom)+"px",r.heightForcer.style.borderBottom=n.bottom+"px solid transparent",n.right&&n.bottom?(r.scrollbarFiller.style.display="block",r.scrollbarFiller.style.height=n.bottom+"px",r.scrollbarFiller.style.width=n.right+"px"):r.scrollbarFiller.style.display="",n.bottom&&e.options.coverGutterNextToScrollbar&&e.options.fixedGutter?(r.gutterFiller.style.display="block",r.gutterFiller.style.height=n.bottom+"px",r.gutterFiller.style.width=t.gutterWidth+"px"):r.gutterFiller.style.display=""}function rn(e){e.display.scrollbars&&(e.display.scrollbars.clear(),e.display.scrollbars.addClass&&Fl(e.display.wrapper,e.display.scrollbars.addClass)),e.display.scrollbars=new ws[e.options.scrollbarStyle](function(t){e.display.wrapper.insertBefore(t,e.display.scrollbarFiller),Ql(t,"mousedown",function(){e.state.focused&&setTimeout(function(){return e.display.input.focus()},0)}),t.setAttribute("cm-not-content","true")},function(t,r){"horizontal"==r?Qr(e,t):qr(e,t)},e),e.display.scrollbars.addClass&&s(e.display.wrapper,e.display.scrollbars.addClass)}function nn(e){e.curOp={cm:e,viewChanged:!1,startHeight:e.doc.height,forceUpdate:!1,updateInput:null,typing:!1,changeObjs:null,cursorActivityHandlers:null,cursorActivityCalled:0,selectionChanged:!1,updateMaxLine:!1,scrollLeft:null,scrollTop:null,scrollToPos:null,focus:!1,id:++xs},vt(e.curOp)}function on(e){yt(e.curOp,function(e){for(var t=0;t<e.ops.length;t++)e.ops[t].cm.curOp=null;ln(e)})}function ln(e){for(var t=e.ops,r=0;r<t.length;r++)sn(t[r]);for(var n=0;n<t.length;n++)an(t[n]);for(var i=0;i<t.length;i++)un(t[i]);for(var o=0;o<t.length;o++)cn(t[o]);for(var l=0;l<t.length;l++)fn(t[l])}function sn(e){var t=e.cm,r=t.display;Ln(t),e.updateMaxLine&&we(t),e.mustUpdate=e.viewChanged||e.forceUpdate||null!=e.scrollTop||e.scrollToPos&&(e.scrollToPos.from.line<r.viewFrom||e.scrollToPos.to.line>=r.viewTo)||r.maxLineChanged&&t.options.lineWrapping,e.update=e.mustUpdate&&new Cs(t,e.mustUpdate&&{top:e.scrollTop,ensure:e.scrollToPos},e.forceUpdate)}function an(e){e.updatedDisplay=e.mustUpdate&&Mn(e.cm,e.update)}function un(e){var t=e.cm,r=t.display;e.updatedDisplay&&Er(t),e.barMeasure=Jr(t),r.maxLineChanged&&!t.options.lineWrapping&&(e.adjustWidthTo=Kt(t,r.maxLine,r.maxLine.text.length).left+3,t.display.sizerWidth=e.adjustWidthTo,e.barMeasure.scrollWidth=Math.max(r.scroller.clientWidth,r.sizer.offsetLeft+e.adjustWidthTo+zt(t)+t.display.barWidth),e.maxScrollLeft=Math.max(0,r.sizer.offsetLeft+e.adjustWidthTo-Rt(t))),(e.updatedDisplay||e.selectionChanged)&&(e.preparedSelection=r.input.prepareSelection())}function cn(e){var t=e.cm;null!=e.adjustWidthTo&&(t.display.sizer.style.minWidth=e.adjustWidthTo+"px",e.maxScrollLeft<t.doc.scrollLeft&&Qr(t,Math.min(t.display.scroller.scrollLeft,e.maxScrollLeft),!0),t.display.maxLineChanged=!1);var r=e.focus&&e.focus==l();e.preparedSelection&&t.display.input.showSelection(e.preparedSelection,r),(e.updatedDisplay||e.startHeight!=t.doc.height)&&en(t,e.barMeasure),e.updatedDisplay&&Dn(t,e.barMeasure),e.selectionChanged&&Ar(t),t.state.focused&&e.updateInput&&t.display.input.reset(e.typing),r&&Wr(e.cm)}function fn(e){var t=e.cm,r=t.display,n=t.doc;e.updatedDisplay&&Nn(t,e.update),null==r.wheelStartX||null==e.scrollTop&&null==e.scrollLeft&&!e.scrollToPos||(r.wheelStartX=r.wheelStartY=null),null!=e.scrollTop&&Zr(t,e.scrollTop,e.forceScroll),null!=e.scrollLeft&&Qr(t,e.scrollLeft,!0,!0),e.scrollToPos&&Br(t,Gr(t,U(n,e.scrollToPos.from),U(n,e.scrollToPos.to),e.scrollToPos.margin));var i=e.maybeHiddenMarkers,o=e.maybeUnhiddenMarkers;if(i)for(var l=0;l<i.length;++l)i[l].lines.length||Te(i[l],"hide");if(o)for(var s=0;s<o.length;++s)o[s].lines.length&&Te(o[s],"unhide");r.wrapper.offsetHeight&&(n.scrollTop=t.display.scroller.scrollTop),e.changeObjs&&Te(t,"changes",t,e.changeObjs),e.update&&e.update.finish()}function hn(e,t){if(e.curOp)return t();nn(e);try{return t()}finally{on(e)}}function dn(e,t){return function(){if(e.curOp)return t.apply(e,arguments);nn(e);try{return t.apply(e,arguments)}finally{on(e)}}}function pn(e){return function(){if(this.curOp)return e.apply(this,arguments);nn(this);try{return e.apply(this,arguments)}finally{on(this)}}}function gn(e){return function(){var t=this.cm;if(!t||t.curOp)return e.apply(this,arguments);nn(t);try{return e.apply(this,arguments)}finally{on(t)}}}function vn(e,t,r,n){null==t&&(t=e.doc.first),null==r&&(r=e.doc.first+e.doc.size),n||(n=0);var i=e.display;if(n&&r<i.viewTo&&(null==i.updateLineNumbers||i.updateLineNumbers>t)&&(i.updateLineNumbers=t),e.curOp.viewChanged=!0,t>=i.viewTo)_l&&pe(e.doc,t)<i.viewTo&&yn(e);else if(r<=i.viewFrom)_l&&ge(e.doc,r+n)>i.viewFrom?yn(e):(i.viewFrom+=n,i.viewTo+=n);else if(t<=i.viewFrom&&r>=i.viewTo)yn(e);else if(t<=i.viewFrom){var o=bn(e,r,r+n,1);o?(i.view=i.view.slice(o.index),i.viewFrom=o.lineN,i.viewTo+=n):yn(e)}else if(r>=i.viewTo){var l=bn(e,t,t,-1);l?(i.view=i.view.slice(0,l.index),i.viewTo=l.lineN):yn(e)}else{var s=bn(e,t,t,-1),a=bn(e,r,r+n,1);s&&a?(i.view=i.view.slice(0,s.index).concat(gt(e,s.lineN,a.lineN)).concat(i.view.slice(a.index)),i.viewTo+=n):yn(e)}var u=i.externalMeasured;u&&(r<u.lineN?u.lineN+=n:t<u.lineN+u.size&&(i.externalMeasured=null))}function mn(e,t,r){e.curOp.viewChanged=!0;var n=e.display,i=e.display.externalMeasured;if(i&&t>=i.lineN&&t<i.lineN+i.size&&(n.externalMeasured=null),!(t<n.viewFrom||t>=n.viewTo)){var o=n.view[Lr(e,t)];if(null!=o.node){var l=o.changes||(o.changes=[]);-1==h(l,r)&&l.push(r)}}}function yn(e){e.display.viewFrom=e.display.viewTo=e.doc.first,e.display.view=[],e.display.viewOffset=0}function bn(e,t,r,n){var i,o=Lr(e,t),l=e.display.view;if(!_l||r==e.doc.first+e.doc.size)return{index:o,lineN:r};for(var s=e.display.viewFrom,a=0;a<o;a++)s+=l[a].size;if(s!=t){if(n>0){if(o==l.length-1)return null;i=s+l[o].size-t,o++}else i=s-t;t+=i,r+=i}for(;pe(e.doc,r)!=r;){if(o==(n<0?0:l.length-1))return null;r+=n*l[o-(n<0?1:0)].size,o+=n}return{index:o,lineN:r}}function wn(e,t,r){var n=e.display;0==n.view.length||t>=n.viewTo||r<=n.viewFrom?(n.view=gt(e,t,r),n.viewFrom=t):(n.viewFrom>t?n.view=gt(e,t,n.viewFrom).concat(n.view):n.viewFrom<t&&(n.view=n.view.slice(Lr(e,t))),n.viewFrom=t,n.viewTo<r?n.view=n.view.concat(gt(e,n.viewTo,r)):n.viewTo>r&&(n.view=n.view.slice(0,Lr(e,r)))),n.viewTo=r}function xn(e){for(var t=e.display.view,r=0,n=0;n<t.length;n++){var i=t[n];i.hidden||i.node&&!i.changes||++r}return r}function Cn(e,t){e.doc.highlightFrontier<e.display.viewTo&&e.state.highlight.set(t,u(Sn,e))}function Sn(e){var t=e.doc;if(!(t.highlightFrontier>=e.display.viewTo)){var r=+new Date+e.options.workTime,n=$e(e,t.highlightFrontier),i=[];t.iter(n.line,Math.min(t.first+t.size,e.display.viewTo+500),function(o){if(n.line>=e.display.viewFrom){var l=o.styles,s=o.text.length>e.options.maxHighlightLength?Ke(t.mode,n.state):null,a=Ye(e,o,n,!0);s&&(n.state=s),o.styles=a.styles;var u=o.styleClasses,c=a.classes;c?o.styleClasses=c:u&&(o.styleClasses=null);for(var f=!l||l.length!=o.styles.length||u!=c&&(!u||!c||u.bgClass!=c.bgClass||u.textClass!=c.textClass),h=0;!f&&h<l.length;++h)f=l[h]!=o.styles[h];f&&i.push(n.line),o.stateAfter=n.save(),n.nextLine()}else o.text.length<=e.options.maxHighlightLength&&qe(e,o.text,n),o.stateAfter=n.line%5==0?n.save():null,n.nextLine();if(+new Date>r)return Cn(e,e.options.workDelay),!0}),t.highlightFrontier=n.line,t.modeFrontier=Math.max(t.modeFrontier,n.line),i.length&&hn(e,function(){for(var t=0;t<i.length;t++)mn(e,i[t],"text")})}}function Ln(e){var t=e.display;!t.scrollbarsClipped&&t.scroller.offsetWidth&&(t.nativeBarWidth=t.scroller.offsetWidth-t.scroller.clientWidth,t.heightForcer.style.height=zt(e)+"px",t.sizer.style.marginBottom=-t.nativeBarWidth+"px",t.sizer.style.borderRightWidth=zt(e)+"px",t.scrollbarsClipped=!0)}function kn(e){if(e.hasFocus())return null;var t=l();if(!t||!o(e.display.lineDiv,t))return null;var r={activeElt:t};if(window.getSelection){var n=window.getSelection();n.anchorNode&&n.extend&&o(e.display.lineDiv,n.anchorNode)&&(r.anchorNode=n.anchorNode,r.anchorOffset=n.anchorOffset,r.focusNode=n.focusNode,r.focusOffset=n.focusOffset)}return r}function Tn(e){if(e&&e.activeElt&&e.activeElt!=l()&&(e.activeElt.focus(),e.anchorNode&&o(document.body,e.anchorNode)&&o(document.body,e.focusNode))){var t=window.getSelection(),r=document.createRange();r.setEnd(e.anchorNode,e.anchorOffset),r.collapse(!1),t.removeAllRanges(),t.addRange(r),t.extend(e.focusNode,e.focusOffset)}}function Mn(e,r){var n=e.display,i=e.doc;if(r.editorIsHidden)return yn(e),!1;if(!r.force&&r.visible.from>=n.viewFrom&&r.visible.to<=n.viewTo&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo)&&n.renderedView==n.view&&0==xn(e))return!1;Rr(e)&&(yn(e),r.dims=br(e));var o=i.first+i.size,l=Math.max(r.visible.from-e.options.viewportMargin,i.first),s=Math.min(o,r.visible.to+e.options.viewportMargin);n.viewFrom<l&&l-n.viewFrom<20&&(l=Math.max(i.first,n.viewFrom)),n.viewTo>s&&n.viewTo-s<20&&(s=Math.min(o,n.viewTo)),_l&&(l=pe(e.doc,l),s=ge(e.doc,s));var a=l!=n.viewFrom||s!=n.viewTo||n.lastWrapHeight!=r.wrapperHeight||n.lastWrapWidth!=r.wrapperWidth;wn(e,l,s),n.viewOffset=ye(M(e.doc,n.viewFrom)),e.display.mover.style.top=n.viewOffset+"px";var u=xn(e);if(!a&&0==u&&!r.force&&n.renderedView==n.view&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo))return!1;var c=kn(e);return u>4&&(n.lineDiv.style.display="none"),An(e,n.updateLineNumbers,r.dims),u>4&&(n.lineDiv.style.display=""),n.renderedView=n.view,Tn(c),t(n.cursorDiv),t(n.selectionDiv),n.gutters.style.height=n.sizer.style.minHeight=0,a&&(n.lastWrapHeight=r.wrapperHeight,n.lastWrapWidth=r.wrapperWidth,Cn(e,400)),n.updateLineNumbers=null,!0}function Nn(e,t){for(var r=t.viewport,n=!0;(n&&e.options.lineWrapping&&t.oldDisplayWidth!=Rt(e)||(r&&null!=r.top&&(r={top:Math.min(e.doc.height+Pt(e.display)-Bt(e),r.top)}),t.visible=Ir(e.display,e.doc,r),!(t.visible.from>=e.display.viewFrom&&t.visible.to<=e.display.viewTo)))&&Mn(e,t);n=!1){Er(e);var i=Jr(e);kr(e),en(e,i),Dn(e,i),t.force=!1}t.signal(e,"update",e),e.display.viewFrom==e.display.reportedViewFrom&&e.display.viewTo==e.display.reportedViewTo||(t.signal(e,"viewportChange",e,e.display.viewFrom,e.display.viewTo),e.display.reportedViewFrom=e.display.viewFrom,e.display.reportedViewTo=e.display.viewTo)}function On(e,t){var r=new Cs(e,t);if(Mn(e,r)){Er(e),Nn(e,r);var n=Jr(e);kr(e),en(e,n),Dn(e,n),r.finish()}}function An(e,r,n){function i(t){var r=t.nextSibling;return ml&&Ml&&e.display.currentWheelTarget==t?t.style.display="none":t.parentNode.removeChild(t),r}for(var o=e.display,l=e.options.lineNumbers,s=o.lineDiv,a=s.firstChild,u=o.view,c=o.viewFrom,f=0;f<u.length;f++){var d=u[f];if(d.hidden);else if(d.node&&d.node.parentNode==s){for(;a!=d.node;)a=i(a);var p=l&&null!=r&&r<=c&&d.lineNumber;d.changes&&(h(d.changes,"gutter")>-1&&(p=!1),xt(e,d,c,n)),p&&(t(d.lineNumber),d.lineNumber.appendChild(document.createTextNode(F(e.options,c)))),a=d.node.nextSibling}else{var g=Ot(e,d,c,n);s.insertBefore(g,a)}c+=d.size}for(;a;)a=i(a)}function Wn(e){var t=e.display.gutters.offsetWidth;e.display.sizer.style.marginLeft=t+"px"}function Dn(e,t){e.display.sizer.style.minHeight=t.docHeight+"px",e.display.heightForcer.style.top=t.docHeight+"px",e.display.gutters.style.height=t.docHeight+e.display.barHeight+zt(e)+"px"}function Hn(e){var r=e.display.gutters,i=e.options.gutters;t(r);for(var o=0;o<i.length;++o){var l=i[o],s=r.appendChild(n("div",null,"CodeMirror-gutter "+l));"CodeMirror-linenumbers"==l&&(e.display.lineGutter=s,s.style.width=(e.display.lineNumWidth||1)+"px")}r.style.display=o?"":"none",Wn(e)}function Fn(e){var t=h(e.gutters,"CodeMirror-linenumbers");-1==t&&e.lineNumbers?e.gutters=e.gutters.concat(["CodeMirror-linenumbers"]):t>-1&&!e.lineNumbers&&(e.gutters=e.gutters.slice(0),e.gutters.splice(t,1))}function En(e){var t=e.wheelDeltaX,r=e.wheelDeltaY;return null==t&&e.detail&&e.axis==e.HORIZONTAL_AXIS&&(t=e.detail),null==r&&e.detail&&e.axis==e.VERTICAL_AXIS?r=e.detail:null==r&&(r=e.wheelDelta),{x:t,y:r}}function Pn(e){var t=En(e);return t.x*=Ls,t.y*=Ls,t}function In(e,t){var r=En(t),n=r.x,i=r.y,o=e.display,l=o.scroller,s=l.scrollWidth>l.clientWidth,a=l.scrollHeight>l.clientHeight;if(n&&s||i&&a){if(i&&Ml&&ml)e:for(var u=t.target,c=o.view;u!=l;u=u.parentNode)for(var f=0;f<c.length;f++)if(c[f].node==u){e.display.currentWheelTarget=u;break e}if(n&&!fl&&!wl&&null!=Ls)return i&&a&&qr(e,Math.max(0,l.scrollTop+i*Ls)),Qr(e,Math.max(0,l.scrollLeft+n*Ls)),(!i||i&&a)&&We(t),void(o.wheelStartX=null);if(i&&null!=Ls){var h=i*Ls,d=e.doc.scrollTop,p=d+o.wrapper.clientHeight;h<0?d=Math.max(0,d+h-50):p=Math.min(e.doc.height,p+h+50),On(e,{top:d,bottom:p})}Ss<20&&(null==o.wheelStartX?(o.wheelStartX=l.scrollLeft,o.wheelStartY=l.scrollTop,o.wheelDX=n,o.wheelDY=i,setTimeout(function(){if(null!=o.wheelStartX){var e=l.scrollLeft-o.wheelStartX,t=l.scrollTop-o.wheelStartY,r=t&&o.wheelDY&&t/o.wheelDY||e&&o.wheelDX&&e/o.wheelDX;o.wheelStartX=o.wheelStartY=null,r&&(Ls=(Ls*Ss+r)/(Ss+1),++Ss)}},200)):(o.wheelDX+=n,o.wheelDY+=i))}}function zn(e,t){var r=e[t];e.sort(function(e,t){return P(e.from(),t.from())}),t=h(e,r);for(var n=1;n<e.length;n++){var i=e[n],o=e[n-1];if(P(o.to(),i.from())>=0){var l=B(o.from(),i.from()),s=R(o.to(),i.to()),a=o.empty()?i.from()==i.head:o.from()==o.head;n<=t&&--t,e.splice(--n,2,new Ts(a?s:l,a?l:s))}}return new ks(e,t)}function Rn(e,t){return new ks([new Ts(e,t||e)],0)}function Bn(e){return e.text?E(e.from.line+e.text.length-1,g(e.text).length+(1==e.text.length?e.from.ch:0)):e.to}function Gn(e,t){if(P(e,t.from)<0)return e;if(P(e,t.to)<=0)return Bn(t);var r=e.line+t.text.length-(t.to.line-t.from.line)-1,n=e.ch;return e.line==t.to.line&&(n+=Bn(t).ch-t.to.ch),E(r,n)}function Un(e,t){for(var r=[],n=0;n<e.sel.ranges.length;n++){var i=e.sel.ranges[n];r.push(new Ts(Gn(i.anchor,t),Gn(i.head,t)))}return zn(r,e.sel.primIndex)}function Vn(e,t,r){return e.line==t.line?E(r.line,e.ch-t.ch+r.ch):E(r.line+(e.line-t.line),e.ch)}function Kn(e,t,r){for(var n=[],i=E(e.first,0),o=i,l=0;l<t.length;l++){var s=t[l],a=Vn(s.from,i,o),u=Vn(Bn(s),i,o);if(i=s.to,o=u,"around"==r){var c=e.sel.ranges[l],f=P(c.head,c.anchor)<0;n[l]=new Ts(f?u:a,f?a:u)}else n[l]=new Ts(a,a)}return new ks(n,e.sel.primIndex)}function jn(e){e.doc.mode=Ue(e.options,e.doc.modeOption),Xn(e)}function Xn(e){e.doc.iter(function(e){e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null)}),e.doc.modeFrontier=e.doc.highlightFrontier=e.doc.first,Cn(e,100),e.state.modeGen++,e.curOp&&vn(e)}function Yn(e,t){return 0==t.from.ch&&0==t.to.ch&&""==g(t.text)&&(!e.cm||e.cm.options.wholeLineUpdateBefore)}function _n(e,t,r,n){function i(e){return r?r[e]:null}function o(e,r,i){it(e,r,i,n),bt(e,"change",e,t)}function l(e,t){for(var r=[],o=e;o<t;++o)r.push(new fs(u[o],i(o),n));return r}var s=t.from,a=t.to,u=t.text,c=M(e,s.line),f=M(e,a.line),h=g(u),d=i(u.length-1),p=a.line-s.line;if(t.full)e.insert(0,l(0,u.length)),e.remove(u.length,e.size-u.length);else if(Yn(e,t)){var v=l(0,u.length-1);o(f,f.text,d),p&&e.remove(s.line,p),v.length&&e.insert(s.line,v)}else if(c==f)if(1==u.length)o(c,c.text.slice(0,s.ch)+h+c.text.slice(a.ch),d);else{var m=l(1,u.length-1);m.push(new fs(h+c.text.slice(a.ch),d,n)),o(c,c.text.slice(0,s.ch)+u[0],i(0)),e.insert(s.line+1,m)}else if(1==u.length)o(c,c.text.slice(0,s.ch)+u[0]+f.text.slice(a.ch),i(0)),e.remove(s.line+1,p);else{o(c,c.text.slice(0,s.ch)+u[0],i(0)),o(f,h+f.text.slice(a.ch),d);var y=l(1,u.length-1);p>1&&e.remove(s.line+1,p-1),e.insert(s.line+1,y)}bt(e,"change",e,t)}function $n(e,t,r){function n(e,i,o){if(e.linked)for(var l=0;l<e.linked.length;++l){var s=e.linked[l];if(s.doc!=i){var a=o&&s.sharedHist;r&&!a||(t(s.doc,a),n(s.doc,e,a))}}}n(e,null,!0)}function qn(e,t){if(t.cm)throw new Error("This document is already in use.");e.doc=t,t.cm=e,Cr(e),jn(e),Zn(e),e.options.lineWrapping||we(e),e.options.mode=t.modeOption,vn(e)}function Zn(e){("rtl"==e.doc.direction?s:Fl)(e.display.lineDiv,"CodeMirror-rtl")}function Qn(e){hn(e,function(){Zn(e),vn(e)})}function Jn(e){this.done=[],this.undone=[],this.undoDepth=1/0,this.lastModTime=this.lastSelTime=0,this.lastOp=this.lastSelOp=null,this.lastOrigin=this.lastSelOrigin=null,this.generation=this.maxGeneration=e||1}function ei(e,t){var r={from:z(t.from),to:Bn(t),text:N(e,t.from,t.to)};return si(e,r,t.from.line,t.to.line+1),$n(e,function(e){return si(e,r,t.from.line,t.to.line+1)},!0),r}function ti(e){for(;e.length&&g(e).ranges;)e.pop()}function ri(e,t){return t?(ti(e.done),g(e.done)):e.done.length&&!g(e.done).ranges?g(e.done):e.done.length>1&&!e.done[e.done.length-2].ranges?(e.done.pop(),g(e.done)):void 0}function ni(e,t,r,n){var i=e.history;i.undone.length=0;var o,l,s=+new Date;if((i.lastOp==n||i.lastOrigin==t.origin&&t.origin&&("+"==t.origin.charAt(0)&&e.cm&&i.lastModTime>s-e.cm.options.historyEventDelay||"*"==t.origin.charAt(0)))&&(o=ri(i,i.lastOp==n)))l=g(o.changes),0==P(t.from,t.to)&&0==P(t.from,l.to)?l.to=Bn(t):o.changes.push(ei(e,t));else{var a=g(i.done);for(a&&a.ranges||li(e.sel,i.done),o={changes:[ei(e,t)],generation:i.generation},i.done.push(o);i.done.length>i.undoDepth;)i.done.shift(),i.done[0].ranges||i.done.shift()}i.done.push(r),i.generation=++i.maxGeneration,i.lastModTime=i.lastSelTime=s,i.lastOp=i.lastSelOp=n,i.lastOrigin=i.lastSelOrigin=t.origin,l||Te(e,"historyAdded")}function ii(e,t,r,n){var i=t.charAt(0);return"*"==i||"+"==i&&r.ranges.length==n.ranges.length&&r.somethingSelected()==n.somethingSelected()&&new Date-e.history.lastSelTime<=(e.cm?e.cm.options.historyEventDelay:500)}function oi(e,t,r,n){var i=e.history,o=n&&n.origin;r==i.lastSelOp||o&&i.lastSelOrigin==o&&(i.lastModTime==i.lastSelTime&&i.lastOrigin==o||ii(e,o,g(i.done),t))?i.done[i.done.length-1]=t:li(t,i.done),i.lastSelTime=+new Date,i.lastSelOrigin=o,i.lastSelOp=r,n&&!1!==n.clearRedo&&ti(i.undone)}function li(e,t){var r=g(t);r&&r.ranges&&r.equals(e)||t.push(e)}function si(e,t,r,n){var i=t["spans_"+e.id],o=0;e.iter(Math.max(e.first,r),Math.min(e.first+e.size,n),function(r){r.markedSpans&&((i||(i=t["spans_"+e.id]={}))[o]=r.markedSpans),++o})}function ai(e){if(!e)return null;for(var t,r=0;r<e.length;++r)e[r].marker.explicitlyCleared?t||(t=e.slice(0,r)):t&&t.push(e[r]);return t?t.length?t:null:e}function ui(e,t){var r=t["spans_"+e.id];if(!r)return null;for(var n=[],i=0;i<t.text.length;++i)n.push(ai(r[i]));return n}function ci(e,t){var r=ui(e,t),n=J(e,t);if(!r)return n;if(!n)return r;for(var i=0;i<r.length;++i){var o=r[i],l=n[i];if(o&&l)e:for(var s=0;s<l.length;++s){for(var a=l[s],u=0;u<o.length;++u)if(o[u].marker==a.marker)continue e;o.push(a)}else l&&(r[i]=l)}return r}function fi(e,t,r){for(var n=[],i=0;i<e.length;++i){var o=e[i];if(o.ranges)n.push(r?ks.prototype.deepCopy.call(o):o);else{var l=o.changes,s=[];n.push({changes:s});for(var a=0;a<l.length;++a){var u=l[a],c=void 0;if(s.push({from:u.from,to:u.to,text:u.text}),t)for(var f in u)(c=f.match(/^spans_(\d+)$/))&&h(t,Number(c[1]))>-1&&(g(s)[f]=u[f],delete u[f])}}}return n}function hi(e,t,r,n){if(n){var i=e.anchor;if(r){var o=P(t,i)<0;o!=P(r,i)<0?(i=t,t=r):o!=P(t,r)<0&&(t=r)}return new Ts(i,t)}return new Ts(r||t,t)}function di(e,t,r,n,i){null==i&&(i=e.cm&&(e.cm.display.shift||e.extend)),bi(e,new ks([hi(e.sel.primary(),t,r,i)],0),n)}function pi(e,t,r){for(var n=[],i=e.cm&&(e.cm.display.shift||e.extend),o=0;o<e.sel.ranges.length;o++)n[o]=hi(e.sel.ranges[o],t[o],null,i);bi(e,zn(n,e.sel.primIndex),r)}function gi(e,t,r,n){var i=e.sel.ranges.slice(0);i[t]=r,bi(e,zn(i,e.sel.primIndex),n)}function vi(e,t,r,n){bi(e,Rn(t,r),n)}function mi(e,t,r){var n={ranges:t.ranges,update:function(t){var r=this;this.ranges=[];for(var n=0;n<t.length;n++)r.ranges[n]=new Ts(U(e,t[n].anchor),U(e,t[n].head))},origin:r&&r.origin};return Te(e,"beforeSelectionChange",e,n),e.cm&&Te(e.cm,"beforeSelectionChange",e.cm,n),n.ranges!=t.ranges?zn(n.ranges,n.ranges.length-1):t}function yi(e,t,r){var n=e.history.done,i=g(n);i&&i.ranges?(n[n.length-1]=t,wi(e,t,r)):bi(e,t,r)}function bi(e,t,r){wi(e,t,r),oi(e,e.sel,e.cm?e.cm.curOp.id:NaN,r)}function wi(e,t,r){(Oe(e,"beforeSelectionChange")||e.cm&&Oe(e.cm,"beforeSelectionChange"))&&(t=mi(e,t,r)),xi(e,Si(e,t,r&&r.bias||(P(t.primary().head,e.sel.primary().head)<0?-1:1),!0)),r&&!1===r.scroll||!e.cm||jr(e.cm)}function xi(e,t){t.equals(e.sel)||(e.sel=t,e.cm&&(e.cm.curOp.updateInput=e.cm.curOp.selectionChanged=!0,Ne(e.cm)),bt(e,"cursorActivity",e))}function Ci(e){xi(e,Si(e,e.sel,null,!1))}function Si(e,t,r,n){for(var i,o=0;o<t.ranges.length;o++){var l=t.ranges[o],s=t.ranges.length==e.sel.ranges.length&&e.sel.ranges[o],a=ki(e,l.anchor,s&&s.anchor,r,n),u=ki(e,l.head,s&&s.head,r,n);(i||a!=l.anchor||u!=l.head)&&(i||(i=t.ranges.slice(0,o)),i[o]=new Ts(a,u))}return i?zn(i,t.primIndex):t}function Li(e,t,r,n,i){var o=M(e,t.line);if(o.markedSpans)for(var l=0;l<o.markedSpans.length;++l){var s=o.markedSpans[l],a=s.marker;if((null==s.from||(a.inclusiveLeft?s.from<=t.ch:s.from<t.ch))&&(null==s.to||(a.inclusiveRight?s.to>=t.ch:s.to>t.ch))){if(i&&(Te(a,"beforeCursorEnter"),a.explicitlyCleared)){if(o.markedSpans){--l;continue}break}if(!a.atomic)continue;if(r){var u=a.find(n<0?1:-1),c=void 0;if((n<0?a.inclusiveRight:a.inclusiveLeft)&&(u=Ti(e,u,-n,u&&u.line==t.line?o:null)),u&&u.line==t.line&&(c=P(u,r))&&(n<0?c<0:c>0))return Li(e,u,t,n,i)}var f=a.find(n<0?-1:1);return(n<0?a.inclusiveLeft:a.inclusiveRight)&&(f=Ti(e,f,n,f.line==t.line?o:null)),f?Li(e,f,t,n,i):null}}return t}function ki(e,t,r,n,i){var o=n||1,l=Li(e,t,r,o,i)||!i&&Li(e,t,r,o,!0)||Li(e,t,r,-o,i)||!i&&Li(e,t,r,-o,!0);return l||(e.cantEdit=!0,E(e.first,0))}function Ti(e,t,r,n){return r<0&&0==t.ch?t.line>e.first?U(e,E(t.line-1)):null:r>0&&t.ch==(n||M(e,t.line)).text.length?t.line<e.first+e.size-1?E(t.line+1,0):null:new E(t.line,t.ch+r)}function Mi(e){e.setSelection(E(e.firstLine(),0),E(e.lastLine()),Gl)}function Ni(e,t,r){var n={canceled:!1,from:t.from,to:t.to,text:t.text,origin:t.origin,cancel:function(){return n.canceled=!0}};return r&&(n.update=function(t,r,i,o){t&&(n.from=U(e,t)),r&&(n.to=U(e,r)),i&&(n.text=i),void 0!==o&&(n.origin=o)}),Te(e,"beforeChange",e,n),e.cm&&Te(e.cm,"beforeChange",e.cm,n),n.canceled?null:{from:n.from,to:n.to,text:n.text,origin:n.origin}}function Oi(e,t,r){if(e.cm){if(!e.cm.curOp)return dn(e.cm,Oi)(e,t,r);if(e.cm.state.suppressEdits)return}if(!(Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"))||(t=Ni(e,t,!0))){var n=Yl&&!r&&te(e,t.from,t.to);if(n)for(var i=n.length-1;i>=0;--i)Ai(e,{from:n[i].from,to:n[i].to,text:i?[""]:t.text,origin:t.origin});else Ai(e,t)}}function Ai(e,t){if(1!=t.text.length||""!=t.text[0]||0!=P(t.from,t.to)){var r=Un(e,t);ni(e,t,r,e.cm?e.cm.curOp.id:NaN),Hi(e,t,r,J(e,t));var n=[];$n(e,function(e,r){r||-1!=h(n,e.history)||(zi(e.history,t),n.push(e.history)),Hi(e,t,null,J(e,t))})}}function Wi(e,t,r){if(!e.cm||!e.cm.state.suppressEdits||r){for(var n,i=e.history,o=e.sel,l="undo"==t?i.done:i.undone,s="undo"==t?i.undone:i.done,a=0;a<l.length&&(n=l[a],r?!n.ranges||n.equals(e.sel):n.ranges);a++);if(a!=l.length){for(i.lastOrigin=i.lastSelOrigin=null;(n=l.pop()).ranges;){if(li(n,s),r&&!n.equals(e.sel))return void bi(e,n,{clearRedo:!1});o=n}var u=[];li(o,s),s.push({changes:u,generation:i.generation}),i.generation=n.generation||++i.maxGeneration;for(var c=Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"),f=n.changes.length-1;f>=0;--f){var d=function(r){var i=n.changes[r];if(i.origin=t,c&&!Ni(e,i,!1))return l.length=0,{};u.push(ei(e,i));var o=r?Un(e,i):g(l);Hi(e,i,o,ci(e,i)),!r&&e.cm&&e.cm.scrollIntoView({from:i.from,to:Bn(i)});var s=[];$n(e,function(e,t){t||-1!=h(s,e.history)||(zi(e.history,i),s.push(e.history)),Hi(e,i,null,ci(e,i))})}(f);if(d)return d.v}}}}function Di(e,t){if(0!=t&&(e.first+=t,e.sel=new ks(v(e.sel.ranges,function(e){return new Ts(E(e.anchor.line+t,e.anchor.ch),E(e.head.line+t,e.head.ch))}),e.sel.primIndex),e.cm)){vn(e.cm,e.first,e.first-t,t);for(var r=e.cm.display,n=r.viewFrom;n<r.viewTo;n++)mn(e.cm,n,"gutter")}}function Hi(e,t,r,n){if(e.cm&&!e.cm.curOp)return dn(e.cm,Hi)(e,t,r,n);if(t.to.line<e.first)Di(e,t.text.length-1-(t.to.line-t.from.line));else if(!(t.from.line>e.lastLine())){if(t.from.line<e.first){var i=t.text.length-1-(e.first-t.from.line);Di(e,i),t={from:E(e.first,0),to:E(t.to.line+i,t.to.ch),text:[g(t.text)],origin:t.origin}}var o=e.lastLine();t.to.line>o&&(t={from:t.from,to:E(o,M(e,o).text.length),text:[t.text[0]],origin:t.origin}),t.removed=N(e,t.from,t.to),r||(r=Un(e,t)),e.cm?Fi(e.cm,t,n):_n(e,t,n),wi(e,r,Gl)}}function Fi(e,t,r){var n=e.doc,i=e.display,o=t.from,l=t.to,s=!1,a=o.line;e.options.lineWrapping||(a=W(fe(M(n,o.line))),n.iter(a,l.line+1,function(e){if(e==i.maxLine)return s=!0,!0})),n.sel.contains(t.from,t.to)>-1&&Ne(e),_n(n,t,r,xr(e)),e.options.lineWrapping||(n.iter(a,o.line+t.text.length,function(e){var t=be(e);t>i.maxLineLength&&(i.maxLine=e,i.maxLineLength=t,i.maxLineChanged=!0,s=!1)}),s&&(e.curOp.updateMaxLine=!0)),nt(n,o.line),Cn(e,400);var u=t.text.length-(l.line-o.line)-1;t.full?vn(e):o.line!=l.line||1!=t.text.length||Yn(e.doc,t)?vn(e,o.line,l.line+1,u):mn(e,o.line,"text");var c=Oe(e,"changes"),f=Oe(e,"change");if(f||c){var h={from:o,to:l,text:t.text,removed:t.removed,origin:t.origin};f&&bt(e,"change",e,h),c&&(e.curOp.changeObjs||(e.curOp.changeObjs=[])).push(h)}e.display.selForContextMenu=null}function Ei(e,t,r,n,i){if(n||(n=r),P(n,r)<0){var o;r=(o=[n,r])[0],n=o[1]}"string"==typeof t&&(t=e.splitLines(t)),Oi(e,{from:r,to:n,text:t,origin:i})}function Pi(e,t,r,n){r<e.line?e.line+=n:t<e.line&&(e.line=t,e.ch=0)}function Ii(e,t,r,n){for(var i=0;i<e.length;++i){var o=e[i],l=!0;if(o.ranges){o.copied||((o=e[i]=o.deepCopy()).copied=!0);for(var s=0;s<o.ranges.length;s++)Pi(o.ranges[s].anchor,t,r,n),Pi(o.ranges[s].head,t,r,n)}else{for(var a=0;a<o.changes.length;++a){var u=o.changes[a];if(r<u.from.line)u.from=E(u.from.line+n,u.from.ch),u.to=E(u.to.line+n,u.to.ch);else if(t<=u.to.line){l=!1;break}}l||(e.splice(0,i+1),i=0)}}}function zi(e,t){var r=t.from.line,n=t.to.line,i=t.text.length-(n-r)-1;Ii(e.done,r,n,i),Ii(e.undone,r,n,i)}function Ri(e,t,r,n){var i=t,o=t;return"number"==typeof t?o=M(e,G(e,t)):i=W(t),null==i?null:(n(o,i)&&e.cm&&mn(e.cm,i,r),o)}function Bi(e){var t=this;this.lines=e,this.parent=null;for(var r=0,n=0;n<e.length;++n)e[n].parent=t,r+=e[n].height;this.height=r}function Gi(e){var t=this;this.children=e;for(var r=0,n=0,i=0;i<e.length;++i){var o=e[i];r+=o.chunkSize(),n+=o.height,o.parent=t}this.size=r,this.height=n,this.parent=null}function Ui(e,t,r){ye(t)<(e.curOp&&e.curOp.scrollTop||e.doc.scrollTop)&&Kr(e,r)}function Vi(e,t,r,n){var i=new Ms(e,r,n),o=e.cm;return o&&i.noHScroll&&(o.display.alignWidgets=!0),Ri(e,t,"widget",function(t){var r=t.widgets||(t.widgets=[]);if(null==i.insertAt?r.push(i):r.splice(Math.min(r.length-1,Math.max(0,i.insertAt)),0,i),i.line=t,o&&!ve(e,t)){var n=ye(t)<e.scrollTop;A(t,t.height+Ht(i)),n&&Kr(o,i.height),o.curOp.forceUpdate=!0}return!0}),bt(o,"lineWidgetAdded",o,i,"number"==typeof t?t:W(t)),i}function Ki(e,t,r,n,o){if(n&&n.shared)return ji(e,t,r,n,o);if(e.cm&&!e.cm.curOp)return dn(e.cm,Ki)(e,t,r,n,o);var l=new Os(e,o),s=P(t,r);if(n&&c(n,l,!1),s>0||0==s&&!1!==l.clearWhenEmpty)return l;if(l.replacedWith&&(l.collapsed=!0,l.widgetNode=i("span",[l.replacedWith],"CodeMirror-widget"),n.handleMouseEvents||l.widgetNode.setAttribute("cm-ignore-events","true"),n.insertLeft&&(l.widgetNode.insertLeft=!0)),l.collapsed){if(ce(e,t.line,t,r,l)||t.line!=r.line&&ce(e,r.line,t,r,l))throw new Error("Inserting collapsed marker partially overlapping an existing one");X()}l.addToHistory&&ni(e,{from:t,to:r,origin:"markText"},e.sel,NaN);var a,u=t.line,f=e.cm;if(e.iter(u,r.line+1,function(e){f&&l.collapsed&&!f.options.lineWrapping&&fe(e)==f.display.maxLine&&(a=!0),l.collapsed&&u!=t.line&&A(e,0),q(e,new Y(l,u==t.line?t.ch:null,u==r.line?r.ch:null)),++u}),l.collapsed&&e.iter(t.line,r.line+1,function(t){ve(e,t)&&A(t,0)}),l.clearOnEnter&&Ql(l,"beforeCursorEnter",function(){return l.clear()}),l.readOnly&&(j(),(e.history.done.length||e.history.undone.length)&&e.clearHistory()),l.collapsed&&(l.id=++Ns,l.atomic=!0),f){if(a&&(f.curOp.updateMaxLine=!0),l.collapsed)vn(f,t.line,r.line+1);else if(l.className||l.title||l.startStyle||l.endStyle||l.css)for(var h=t.line;h<=r.line;h++)mn(f,h,"text");l.atomic&&Ci(f.doc),bt(f,"markerAdded",f,l)}return l}function ji(e,t,r,n,i){(n=c(n)).shared=!1;var o=[Ki(e,t,r,n,i)],l=o[0],s=n.widgetNode;return $n(e,function(e){s&&(n.widgetNode=s.cloneNode(!0)),o.push(Ki(e,U(e,t),U(e,r),n,i));for(var a=0;a<e.linked.length;++a)if(e.linked[a].isParent)return;l=g(o)}),new As(o,l)}function Xi(e){return e.findMarks(E(e.first,0),e.clipPos(E(e.lastLine())),function(e){return e.parent})}function Yi(e,t){for(var r=0;r<t.length;r++){var n=t[r],i=n.find(),o=e.clipPos(i.from),l=e.clipPos(i.to);if(P(o,l)){var s=Ki(e,o,l,n.primary,n.primary.type);n.markers.push(s),s.parent=n}}}function _i(e){for(var t=0;t<e.length;t++)!function(t){var r=e[t],n=[r.primary.doc];$n(r.primary.doc,function(e){return n.push(e)});for(var i=0;i<r.markers.length;i++){var o=r.markers[i];-1==h(n,o.doc)&&(o.parent=null,r.markers.splice(i--,1))}}(t)}function $i(e){var t=this;if(Qi(t),!Me(t,e)&&!Ft(t.display,e)){We(e),gl&&(Hs=+new Date);var r=Sr(t,e,!0),n=e.dataTransfer.files;if(r&&!t.isReadOnly())if(n&&n.length&&window.FileReader&&window.File)for(var i=n.length,o=Array(i),l=0,s=0;s<i;++s)!function(e,n){if(!t.options.allowDropFileTypes||-1!=h(t.options.allowDropFileTypes,e.type)){var s=new FileReader;s.onload=dn(t,function(){var e=s.result;if(/[\x00-\x08\x0e-\x1f]{2}/.test(e)&&(e=""),o[n]=e,++l==i){var a={from:r=U(t.doc,r),to:r,text:t.doc.splitLines(o.join(t.doc.lineSeparator())),origin:"paste"};Oi(t.doc,a),yi(t.doc,Rn(r,Bn(a)))}}),s.readAsText(e)}}(n[s],s);else{if(t.state.draggingText&&t.doc.sel.contains(r)>-1)return t.state.draggingText(e),void setTimeout(function(){return t.display.input.focus()},20);try{var a=e.dataTransfer.getData("Text");if(a){var u;if(t.state.draggingText&&!t.state.draggingText.copy&&(u=t.listSelections()),wi(t.doc,Rn(r,r)),u)for(var c=0;c<u.length;++c)Ei(t.doc,"",u[c].anchor,u[c].head,"drag");t.replaceSelection(a,"around","paste"),t.display.input.focus()}}catch(e){}}}}function qi(e,t){if(gl&&(!e.state.draggingText||+new Date-Hs<100))Fe(t);else if(!Me(e,t)&&!Ft(e.display,t)&&(t.dataTransfer.setData("Text",e.getSelection()),t.dataTransfer.effectAllowed="copyMove",t.dataTransfer.setDragImage&&!xl)){var r=n("img",null,null,"position: fixed; left: 0; top: 0;");r.src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",wl&&(r.width=r.height=1,e.display.wrapper.appendChild(r),r._top=r.offsetTop),t.dataTransfer.setDragImage(r,0,0),wl&&r.parentNode.removeChild(r)}}function Zi(e,t){var i=Sr(e,t);if(i){var o=document.createDocumentFragment();Mr(e,i,o),e.display.dragCursor||(e.display.dragCursor=n("div",null,"CodeMirror-cursors CodeMirror-dragcursors"),e.display.lineSpace.insertBefore(e.display.dragCursor,e.display.cursorDiv)),r(e.display.dragCursor,o)}}function Qi(e){e.display.dragCursor&&(e.display.lineSpace.removeChild(e.display.dragCursor),e.display.dragCursor=null)}function Ji(e){if(document.getElementsByClassName)for(var t=document.getElementsByClassName("CodeMirror"),r=0;r<t.length;r++){var n=t[r].CodeMirror;n&&e(n)}}function eo(){Fs||(to(),Fs=!0)}function to(){var e;Ql(window,"resize",function(){null==e&&(e=setTimeout(function(){e=null,Ji(ro)},100))}),Ql(window,"blur",function(){return Ji(Fr)})}function ro(e){var t=e.display;t.lastWrapHeight==t.wrapper.clientHeight&&t.lastWrapWidth==t.wrapper.clientWidth||(t.cachedCharWidth=t.cachedTextHeight=t.cachedPaddingH=null,t.scrollbarsClipped=!1,e.setSize())}function no(e){var t=e.split(/-(?!$)/);e=t[t.length-1];for(var r,n,i,o,l=0;l<t.length-1;l++){var s=t[l];if(/^(cmd|meta|m)$/i.test(s))o=!0;else if(/^a(lt)?$/i.test(s))r=!0;else if(/^(c|ctrl|control)$/i.test(s))n=!0;else{if(!/^s(hift)?$/i.test(s))throw new Error("Unrecognized modifier name: "+s);i=!0}}return r&&(e="Alt-"+e),n&&(e="Ctrl-"+e),o&&(e="Cmd-"+e),i&&(e="Shift-"+e),e}function io(e){var t={};for(var r in e)if(e.hasOwnProperty(r)){var n=e[r];if(/^(name|fallthrough|(de|at)tach)$/.test(r))continue;if("..."==n){delete e[r];continue}for(var i=v(r.split(" "),no),o=0;o<i.length;o++){var l=void 0,s=void 0;o==i.length-1?(s=i.join(" "),l=n):(s=i.slice(0,o+1).join(" "),l="...");var a=t[s];if(a){if(a!=l)throw new Error("Inconsistent bindings for "+s)}else t[s]=l}delete e[r]}for(var u in t)e[u]=t[u];return e}function oo(e,t,r,n){var i=(t=uo(t)).call?t.call(e,n):t[e];if(!1===i)return"nothing";if("..."===i)return"multi";if(null!=i&&r(i))return"handled";if(t.fallthrough){if("[object Array]"!=Object.prototype.toString.call(t.fallthrough))return oo(e,t.fallthrough,r,n);for(var o=0;o<t.fallthrough.length;o++){var l=oo(e,t.fallthrough[o],r,n);if(l)return l}}}function lo(e){var t="string"==typeof e?e:Es[e.keyCode];return"Ctrl"==t||"Alt"==t||"Shift"==t||"Mod"==t}function so(e,t,r){var n=e;return t.altKey&&"Alt"!=n&&(e="Alt-"+e),(Dl?t.metaKey:t.ctrlKey)&&"Ctrl"!=n&&(e="Ctrl-"+e),(Dl?t.ctrlKey:t.metaKey)&&"Cmd"!=n&&(e="Cmd-"+e),!r&&t.shiftKey&&"Shift"!=n&&(e="Shift-"+e),e}function ao(e,t){if(wl&&34==e.keyCode&&e.char)return!1;var r=Es[e.keyCode];return null!=r&&!e.altGraphKey&&so(r,e,t)}function uo(e){return"string"==typeof e?Rs[e]:e}function co(e,t){for(var r=e.doc.sel.ranges,n=[],i=0;i<r.length;i++){for(var o=t(r[i]);n.length&&P(o.from,g(n).to)<=0;){var l=n.pop();if(P(l.from,o.from)<0){o.from=l.from;break}}n.push(o)}hn(e,function(){for(var t=n.length-1;t>=0;t--)Ei(e.doc,"",n[t].from,n[t].to,"+delete");jr(e)})}function fo(e,t,r){var n=L(e.text,t+r,r);return n<0||n>e.text.length?null:n}function ho(e,t,r){var n=fo(e,t.ch,r);return null==n?null:new E(t.line,n,r<0?"after":"before")}function po(e,t,r,n,i){if(e){var o=Se(r,t.doc.direction);if(o){var l,s=i<0?g(o):o[0],a=i<0==(1==s.level)?"after":"before";if(s.level>0){var u=Xt(t,r);l=i<0?r.text.length-1:0;var c=Yt(t,u,l).top;l=k(function(e){return Yt(t,u,e).top==c},i<0==(1==s.level)?s.from:s.to-1,l),"before"==a&&(l=fo(r,l,1))}else l=i<0?s.to:s.from;return new E(n,l,a)}}return new E(n,i<0?r.text.length:0,i<0?"before":"after")}function go(e,t,r,n){var i=Se(t,e.doc.direction);if(!i)return ho(t,r,n);r.ch>=t.text.length?(r.ch=t.text.length,r.sticky="before"):r.ch<=0&&(r.ch=0,r.sticky="after");var o=Ce(i,r.ch,r.sticky),l=i[o];if("ltr"==e.doc.direction&&l.level%2==0&&(n>0?l.to>r.ch:l.from<r.ch))return ho(t,r,n);var s,a=function(e,r){return fo(t,e instanceof E?e.ch:e,r)},u=function(r){return e.options.lineWrapping?(s=s||Xt(e,t),hr(e,t,s,r)):{begin:0,end:t.text.length}},c=u("before"==r.sticky?a(r,-1):r.ch);if("rtl"==e.doc.direction||1==l.level){var f=1==l.level==n<0,h=a(r,f?1:-1);if(null!=h&&(f?h<=l.to&&h<=c.end:h>=l.from&&h>=c.begin)){var d=f?"before":"after";return new E(r.line,h,d)}}var p=function(e,t,n){for(var o=function(e,t){return t?new E(r.line,a(e,1),"before"):new E(r.line,e,"after")};e>=0&&e<i.length;e+=t){var l=i[e],s=t>0==(1!=l.level),u=s?n.begin:a(n.end,-1);if(l.from<=u&&u<l.to)return o(u,s);if(u=s?l.from:a(l.to,-1),n.begin<=u&&u<n.end)return o(u,s)}},g=p(o+n,n,c);if(g)return g;var v=n>0?c.end:a(c.begin,-1);return null==v||n>0&&v==t.text.length||!(g=p(n>0?0:i.length-1,n,u(v)))?null:g}function vo(e,t){var r=M(e.doc,t),n=fe(r);return n!=r&&(t=W(n)),po(!0,e,n,t,1)}function mo(e,t){var r=M(e.doc,t),n=he(r);return n!=r&&(t=W(n)),po(!0,e,r,t,-1)}function yo(e,t){var r=vo(e,t.line),n=M(e.doc,r.line),i=Se(n,e.doc.direction);if(!i||0==i[0].level){var o=Math.max(0,n.text.search(/\S/)),l=t.line==r.line&&t.ch<=o&&t.ch;return E(r.line,l?0:o,r.sticky)}return r}function bo(e,t,r){if("string"==typeof t&&!(t=Bs[t]))return!1;e.display.input.ensurePolled();var n=e.display.shift,i=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),r&&(e.display.shift=!1),i=t(e)!=Bl}finally{e.display.shift=n,e.state.suppressEdits=!1}return i}function wo(e,t,r){for(var n=0;n<e.state.keyMaps.length;n++){var i=oo(t,e.state.keyMaps[n],r,e);if(i)return i}return e.options.extraKeys&&oo(t,e.options.extraKeys,r,e)||oo(t,e.options.keyMap,r,e)}function xo(e,t,r,n){var i=e.state.keySeq;if(i){if(lo(t))return"handled";Gs.set(50,function(){e.state.keySeq==i&&(e.state.keySeq=null,e.display.input.reset())}),t=i+" "+t}var o=wo(e,t,n);return"multi"==o&&(e.state.keySeq=t),"handled"==o&&bt(e,"keyHandled",e,t,r),"handled"!=o&&"multi"!=o||(We(r),Ar(e)),i&&!o&&/\'$/.test(t)?(We(r),!0):!!o}function Co(e,t){var r=ao(t,!0);return!!r&&(t.shiftKey&&!e.state.keySeq?xo(e,"Shift-"+r,t,function(t){return bo(e,t,!0)})||xo(e,r,t,function(t){if("string"==typeof t?/^go[A-Z]/.test(t):t.motion)return bo(e,t)}):xo(e,r,t,function(t){return bo(e,t)}))}function So(e,t,r){return xo(e,"'"+r+"'",t,function(t){return bo(e,t,!0)})}function Lo(e){var t=this;if(t.curOp.focus=l(),!Me(t,e)){gl&&vl<11&&27==e.keyCode&&(e.returnValue=!1);var r=e.keyCode;t.display.shift=16==r||e.shiftKey;var n=Co(t,e);wl&&(Us=n?r:null,!n&&88==r&&!rs&&(Ml?e.metaKey:e.ctrlKey)&&t.replaceSelection("",null,"cut")),18!=r||/\bCodeMirror-crosshair\b/.test(t.display.lineDiv.className)||ko(t)}}function ko(e){function t(e){18!=e.keyCode&&e.altKey||(Fl(r,"CodeMirror-crosshair"),ke(document,"keyup",t),ke(document,"mouseover",t))}var r=e.display.lineDiv;s(r,"CodeMirror-crosshair"),Ql(document,"keyup",t),Ql(document,"mouseover",t)}function To(e){16==e.keyCode&&(this.doc.sel.shift=!1),Me(this,e)}function Mo(e){var t=this;if(!(Ft(t.display,e)||Me(t,e)||e.ctrlKey&&!e.altKey||Ml&&e.metaKey)){var r=e.keyCode,n=e.charCode;if(wl&&r==Us)return Us=null,void We(e);if(!wl||e.which&&!(e.which<10)||!Co(t,e)){var i=String.fromCharCode(null==n?r:n);"\b"!=i&&(So(t,e,i)||t.display.input.onKeyPress(e))}}}function No(e,t){var r=+new Date;return js&&js.compare(r,e,t)?(Ks=js=null,"triple"):Ks&&Ks.compare(r,e,t)?(js=new Vs(r,e,t),Ks=null,"double"):(Ks=new Vs(r,e,t),js=null,"single")}function Oo(e){var t=this,r=t.display;if(!(Me(t,e)||r.activeTouch&&r.input.supportsTouch()))if(r.input.ensurePolled(),r.shift=e.shiftKey,Ft(r,e))ml||(r.scroller.draggable=!1,setTimeout(function(){return r.scroller.draggable=!0},100));else if(!zo(t,e)){var n=Sr(t,e),i=Pe(e),o=n?No(n,i):"single";window.focus(),1==i&&t.state.selectingText&&t.state.selectingText(e),n&&Ao(t,i,n,o,e)||(1==i?n?Do(t,n,o,e):Ee(e)==r.scroller&&We(e):2==i?(n&&di(t.doc,n),setTimeout(function(){return r.input.focus()},20)):3==i&&(Hl?Ro(t,e):Dr(t)))}}function Ao(e,t,r,n,i){var o="Click";return"double"==n?o="Double"+o:"triple"==n&&(o="Triple"+o),o=(1==t?"Left":2==t?"Middle":"Right")+o,xo(e,so(o,i),i,function(t){if("string"==typeof t&&(t=Bs[t]),!t)return!1;var n=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),n=t(e,r)!=Bl}finally{e.state.suppressEdits=!1}return n})}function Wo(e,t,r){var n=e.getOption("configureMouse"),i=n?n(e,t,r):{};if(null==i.unit){var o=Nl?r.shiftKey&&r.metaKey:r.altKey;i.unit=o?"rectangle":"single"==t?"char":"double"==t?"word":"line"}return(null==i.extend||e.doc.extend)&&(i.extend=e.doc.extend||r.shiftKey),null==i.addNew&&(i.addNew=Ml?r.metaKey:r.ctrlKey),null==i.moveOnDrag&&(i.moveOnDrag=!(Ml?r.altKey:r.ctrlKey)),i}function Do(e,t,r,n){gl?setTimeout(u(Wr,e),0):e.curOp.focus=l();var i,o=Wo(e,r,n),s=e.doc.sel;e.options.dragDrop&&Jl&&!e.isReadOnly()&&"single"==r&&(i=s.contains(t))>-1&&(P((i=s.ranges[i]).from(),t)<0||t.xRel>0)&&(P(i.to(),t)>0||t.xRel<0)?Ho(e,n,t,o):Eo(e,n,t,o)}function Ho(e,t,r,n){var i=e.display,o=!1,l=dn(e,function(t){ml&&(i.scroller.draggable=!1),e.state.draggingText=!1,ke(document,"mouseup",l),ke(document,"mousemove",s),ke(i.scroller,"dragstart",a),ke(i.scroller,"drop",l),o||(We(t),n.addNew||di(e.doc,r,null,null,n.extend),ml||gl&&9==vl?setTimeout(function(){document.body.focus(),i.input.focus()},20):i.input.focus())}),s=function(e){o=o||Math.abs(t.clientX-e.clientX)+Math.abs(t.clientY-e.clientY)>=10},a=function(){return o=!0};ml&&(i.scroller.draggable=!0),e.state.draggingText=l,l.copy=!n.moveOnDrag,i.scroller.dragDrop&&i.scroller.dragDrop(),Ql(document,"mouseup",l),Ql(document,"mousemove",s),Ql(i.scroller,"dragstart",a),Ql(i.scroller,"drop",l),Dr(e),setTimeout(function(){return i.input.focus()},20)}function Fo(e,t,r){if("char"==r)return new Ts(t,t);if("word"==r)return e.findWordAt(t);if("line"==r)return new Ts(E(t.line,0),U(e.doc,E(t.line+1,0)));var n=r(e,t);return new Ts(n.from,n.to)}function Eo(e,t,r,n){function i(t){if(0!=P(m,t))if(m=t,"rectangle"==n.unit){for(var i=[],o=e.options.tabSize,l=f(M(u,r.line).text,r.ch,o),s=f(M(u,t.line).text,t.ch,o),a=Math.min(l,s),g=Math.max(l,s),v=Math.min(r.line,t.line),y=Math.min(e.lastLine(),Math.max(r.line,t.line));v<=y;v++){var b=M(u,v).text,w=d(b,a,o);a==g?i.push(new Ts(E(v,w),E(v,w))):b.length>w&&i.push(new Ts(E(v,w),E(v,d(b,g,o))))}i.length||i.push(new Ts(r,r)),bi(u,zn(p.ranges.slice(0,h).concat(i),h),{origin:"*mouse",scroll:!1}),e.scrollIntoView(t)}else{var x,C=c,S=Fo(e,t,n.unit),L=C.anchor;P(S.anchor,L)>0?(x=S.head,L=B(C.from(),S.anchor)):(x=S.anchor,L=R(C.to(),S.head));var k=p.ranges.slice(0);k[h]=Po(e,new Ts(U(u,L),x)),bi(u,zn(k,h),Ul)}}function o(t){var r=++b,s=Sr(e,t,!0,"rectangle"==n.unit);if(s)if(0!=P(s,m)){e.curOp.focus=l(),i(s);var c=Ir(a,u);(s.line>=c.to||s.line<c.from)&&setTimeout(dn(e,function(){b==r&&o(t)}),150)}else{var f=t.clientY<y.top?-20:t.clientY>y.bottom?20:0;f&&setTimeout(dn(e,function(){b==r&&(a.scroller.scrollTop+=f,o(t))}),50)}}function s(t){e.state.selectingText=!1,b=1/0,We(t),a.input.focus(),ke(document,"mousemove",w),ke(document,"mouseup",x),u.history.lastSelOrigin=null}var a=e.display,u=e.doc;We(t);var c,h,p=u.sel,g=p.ranges;if(n.addNew&&!n.extend?(h=u.sel.contains(r),c=h>-1?g[h]:new Ts(r,r)):(c=u.sel.primary(),h=u.sel.primIndex),"rectangle"==n.unit)n.addNew||(c=new Ts(r,r)),r=Sr(e,t,!0,!0),h=-1;else{var v=Fo(e,r,n.unit);c=n.extend?hi(c,v.anchor,v.head,n.extend):v}n.addNew?-1==h?(h=g.length,bi(u,zn(g.concat([c]),h),{scroll:!1,origin:"*mouse"})):g.length>1&&g[h].empty()&&"char"==n.unit&&!n.extend?(bi(u,zn(g.slice(0,h).concat(g.slice(h+1)),0),{scroll:!1,origin:"*mouse"}),p=u.sel):gi(u,h,c,Ul):(h=0,bi(u,new ks([c],0),Ul),p=u.sel);var m=r,y=a.wrapper.getBoundingClientRect(),b=0,w=dn(e,function(e){Pe(e)?o(e):s(e)}),x=dn(e,s);e.state.selectingText=x,Ql(document,"mousemove",w),Ql(document,"mouseup",x)}function Po(e,t){var r=t.anchor,n=t.head,i=M(e.doc,r.line);if(0==P(r,n)&&r.sticky==n.sticky)return t;var o=Se(i);if(!o)return t;var l=Ce(o,r.ch,r.sticky),s=o[l];if(s.from!=r.ch&&s.to!=r.ch)return t;var a=l+(s.from==r.ch==(1!=s.level)?0:1);if(0==a||a==o.length)return t;var u;if(n.line!=r.line)u=(n.line-r.line)*("ltr"==e.doc.direction?1:-1)>0;else{var c=Ce(o,n.ch,n.sticky),f=c-l||(n.ch-r.ch)*(1==s.level?-1:1);u=c==a-1||c==a?f<0:f>0}var h=o[a+(u?-1:0)],d=u==(1==h.level),p=d?h.from:h.to,g=d?"after":"before";return r.ch==p&&r.sticky==g?t:new Ts(new E(r.line,p,g),n)}function Io(e,t,r,n){var i,o;if(t.touches)i=t.touches[0].clientX,o=t.touches[0].clientY;else try{i=t.clientX,o=t.clientY}catch(t){return!1}if(i>=Math.floor(e.display.gutters.getBoundingClientRect().right))return!1;n&&We(t);var l=e.display,s=l.lineDiv.getBoundingClientRect();if(o>s.bottom||!Oe(e,r))return He(t);o-=s.top-l.viewOffset;for(var a=0;a<e.options.gutters.length;++a){var u=l.gutters.childNodes[a];if(u&&u.getBoundingClientRect().right>=i)return Te(e,r,e,D(e.doc,o),e.options.gutters[a],t),He(t)}}function zo(e,t){return Io(e,t,"gutterClick",!0)}function Ro(e,t){Ft(e.display,t)||Bo(e,t)||Me(e,t,"contextmenu")||e.display.input.onContextMenu(t)}function Bo(e,t){return!!Oe(e,"gutterContextMenu")&&Io(e,t,"gutterContextMenu",!1)}function Go(e){e.display.wrapper.className=e.display.wrapper.className.replace(/\s*cm-s-\S+/g,"")+e.options.theme.replace(/(^|\s)\s*/g," cm-s-"),er(e)}function Uo(e){Hn(e),vn(e),zr(e)}function Vo(e,t,r){if(!t!=!(r&&r!=Xs)){var n=e.display.dragFunctions,i=t?Ql:ke;i(e.display.scroller,"dragstart",n.start),i(e.display.scroller,"dragenter",n.enter),i(e.display.scroller,"dragover",n.over),i(e.display.scroller,"dragleave",n.leave),i(e.display.scroller,"drop",n.drop)}}function Ko(e){e.options.lineWrapping?(s(e.display.wrapper,"CodeMirror-wrap"),e.display.sizer.style.minWidth="",e.display.sizerWidth=null):(Fl(e.display.wrapper,"CodeMirror-wrap"),we(e)),Cr(e),vn(e),er(e),setTimeout(function(){return en(e)},100)}function jo(e,t){var r=this;if(!(this instanceof jo))return new jo(e,t);this.options=t=t?c(t):{},c(Ys,t,!1),Fn(t);var n=t.value;"string"==typeof n&&(n=new Ds(n,t.mode,null,t.lineSeparator,t.direction)),this.doc=n;var i=new jo.inputStyles[t.inputStyle](this),o=this.display=new T(e,n,i);o.wrapper.CodeMirror=this,Hn(this),Go(this),t.lineWrapping&&(this.display.wrapper.className+=" CodeMirror-wrap"),rn(this),this.state={keyMaps:[],overlays:[],modeGen:0,overwrite:!1,delayingBlurEvent:!1,focused:!1,suppressEdits:!1,pasteIncoming:!1,cutIncoming:!1,selectingText:!1,draggingText:!1,highlight:new Pl,keySeq:null,specialChars:null},t.autofocus&&!Tl&&o.input.focus(),gl&&vl<11&&setTimeout(function(){return r.display.input.reset(!0)},20),Xo(this),eo(),nn(this),this.curOp.forceUpdate=!0,qn(this,n),t.autofocus&&!Tl||this.hasFocus()?setTimeout(u(Hr,this),20):Fr(this);for(var l in _s)_s.hasOwnProperty(l)&&_s[l](r,t[l],Xs);Rr(this),t.finishInit&&t.finishInit(this);for(var s=0;s<$s.length;++s)$s[s](r);on(this),ml&&t.lineWrapping&&"optimizelegibility"==getComputedStyle(o.lineDiv).textRendering&&(o.lineDiv.style.textRendering="auto")}function Xo(e){function t(){i.activeTouch&&(o=setTimeout(function(){return i.activeTouch=null},1e3),(l=i.activeTouch).end=+new Date)}function r(e){if(1!=e.touches.length)return!1;var t=e.touches[0];return t.radiusX<=1&&t.radiusY<=1}function n(e,t){if(null==t.left)return!0;var r=t.left-e.left,n=t.top-e.top;return r*r+n*n>400}var i=e.display;Ql(i.scroller,"mousedown",dn(e,Oo)),gl&&vl<11?Ql(i.scroller,"dblclick",dn(e,function(t){if(!Me(e,t)){var r=Sr(e,t);if(r&&!zo(e,t)&&!Ft(e.display,t)){We(t);var n=e.findWordAt(r);di(e.doc,n.anchor,n.head)}}})):Ql(i.scroller,"dblclick",function(t){return Me(e,t)||We(t)}),Hl||Ql(i.scroller,"contextmenu",function(t){return Ro(e,t)});var o,l={end:0};Ql(i.scroller,"touchstart",function(t){if(!Me(e,t)&&!r(t)&&!zo(e,t)){i.input.ensurePolled(),clearTimeout(o);var n=+new Date;i.activeTouch={start:n,moved:!1,prev:n-l.end<=300?l:null},1==t.touches.length&&(i.activeTouch.left=t.touches[0].pageX,i.activeTouch.top=t.touches[0].pageY)}}),Ql(i.scroller,"touchmove",function(){i.activeTouch&&(i.activeTouch.moved=!0)}),Ql(i.scroller,"touchend",function(r){var o=i.activeTouch;if(o&&!Ft(i,r)&&null!=o.left&&!o.moved&&new Date-o.start<300){var l,s=e.coordsChar(i.activeTouch,"page");l=!o.prev||n(o,o.prev)?new Ts(s,s):!o.prev.prev||n(o,o.prev.prev)?e.findWordAt(s):new Ts(E(s.line,0),U(e.doc,E(s.line+1,0))),e.setSelection(l.anchor,l.head),e.focus(),We(r)}t()}),Ql(i.scroller,"touchcancel",t),Ql(i.scroller,"scroll",function(){i.scroller.clientHeight&&(qr(e,i.scroller.scrollTop),Qr(e,i.scroller.scrollLeft,!0),Te(e,"scroll",e))}),Ql(i.scroller,"mousewheel",function(t){return In(e,t)}),Ql(i.scroller,"DOMMouseScroll",function(t){return In(e,t)}),Ql(i.wrapper,"scroll",function(){return i.wrapper.scrollTop=i.wrapper.scrollLeft=0}),i.dragFunctions={enter:function(t){Me(e,t)||Fe(t)},over:function(t){Me(e,t)||(Zi(e,t),Fe(t))},start:function(t){return qi(e,t)},drop:dn(e,$i),leave:function(t){Me(e,t)||Qi(e)}};var s=i.input.getField();Ql(s,"keyup",function(t){return To.call(e,t)}),Ql(s,"keydown",dn(e,Lo)),Ql(s,"keypress",dn(e,Mo)),Ql(s,"focus",function(t){return Hr(e,t)}),Ql(s,"blur",function(t){return Fr(e,t)})}function Yo(e,t,r,n){var i,o=e.doc;null==r&&(r="add"),"smart"==r&&(o.mode.indent?i=$e(e,t).state:r="prev");var l=e.options.tabSize,s=M(o,t),a=f(s.text,null,l);s.stateAfter&&(s.stateAfter=null);var u,c=s.text.match(/^\s*/)[0];if(n||/\S/.test(s.text)){if("smart"==r&&((u=o.mode.indent(i,s.text.slice(c.length),s.text))==Bl||u>150)){if(!n)return;r="prev"}}else u=0,r="not";"prev"==r?u=t>o.first?f(M(o,t-1).text,null,l):0:"add"==r?u=a+e.options.indentUnit:"subtract"==r?u=a-e.options.indentUnit:"number"==typeof r&&(u=a+r),u=Math.max(0,u);var h="",d=0;if(e.options.indentWithTabs)for(var g=Math.floor(u/l);g;--g)d+=l,h+="\t";if(d<u&&(h+=p(u-d)),h!=c)return Ei(o,h,E(t,0),E(t,c.length),"+input"),s.stateAfter=null,!0;for(var v=0;v<o.sel.ranges.length;v++){var m=o.sel.ranges[v];if(m.head.line==t&&m.head.ch<c.length){var y=E(t,c.length);gi(o,v,new Ts(y,y));break}}}function _o(e){qs=e}function $o(e,t,r,n,i){var o=e.doc;e.display.shift=!1,n||(n=o.sel);var l=e.state.pasteIncoming||"paste"==i,s=es(t),a=null;if(l&&n.ranges.length>1)if(qs&&qs.text.join("\n")==t){if(n.ranges.length%qs.text.length==0){a=[];for(var u=0;u<qs.text.length;u++)a.push(o.splitLines(qs.text[u]))}}else s.length==n.ranges.length&&e.options.pasteLinesPerSelection&&(a=v(s,function(e){return[e]}));for(var c,f=n.ranges.length-1;f>=0;f--){var h=n.ranges[f],d=h.from(),p=h.to();h.empty()&&(r&&r>0?d=E(d.line,d.ch-r):e.state.overwrite&&!l?p=E(p.line,Math.min(M(o,p.line).text.length,p.ch+g(s).length)):qs&&qs.lineWise&&qs.text.join("\n")==t&&(d=p=E(d.line,0))),c=e.curOp.updateInput;var m={from:d,to:p,text:a?a[f%a.length]:s,origin:i||(l?"paste":e.state.cutIncoming?"cut":"+input")};Oi(e.doc,m),bt(e,"inputRead",e,m)}t&&!l&&Zo(e,t),jr(e),e.curOp.updateInput=c,e.curOp.typing=!0,e.state.pasteIncoming=e.state.cutIncoming=!1}function qo(e,t){var r=e.clipboardData&&e.clipboardData.getData("Text");if(r)return e.preventDefault(),t.isReadOnly()||t.options.disableInput||hn(t,function(){return $o(t,r,0,null,"paste")}),!0}function Zo(e,t){if(e.options.electricChars&&e.options.smartIndent)for(var r=e.doc.sel,n=r.ranges.length-1;n>=0;n--){var i=r.ranges[n];if(!(i.head.ch>100||n&&r.ranges[n-1].head.line==i.head.line)){var o=e.getModeAt(i.head),l=!1;if(o.electricChars){for(var s=0;s<o.electricChars.length;s++)if(t.indexOf(o.electricChars.charAt(s))>-1){l=Yo(e,i.head.line,"smart");break}}else o.electricInput&&o.electricInput.test(M(e.doc,i.head.line).text.slice(0,i.head.ch))&&(l=Yo(e,i.head.line,"smart"));l&&bt(e,"electricInput",e,i.head.line)}}}function Qo(e){for(var t=[],r=[],n=0;n<e.doc.sel.ranges.length;n++){var i=e.doc.sel.ranges[n].head.line,o={anchor:E(i,0),head:E(i+1,0)};r.push(o),t.push(e.getRange(o.anchor,o.head))}return{text:t,ranges:r}}function Jo(e,t){e.setAttribute("autocorrect","off"),e.setAttribute("autocapitalize","off"),e.setAttribute("spellcheck",!!t)}function el(){var e=n("textarea",null,null,"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none"),t=n("div",[e],null,"overflow: hidden; position: relative; width: 3px; height: 0px;");return ml?e.style.width="1000px":e.setAttribute("wrap","off"),Ll&&(e.style.border="1px solid black"),Jo(e),t}function tl(e,t,r,n,i){function o(){var n=t.line+r;return!(n<e.first||n>=e.first+e.size)&&(t=new E(n,t.ch,t.sticky),u=M(e,n))}function l(n){var l;if(null==(l=i?go(e.cm,u,t,r):ho(u,t,r))){if(n||!o())return!1;t=po(i,e.cm,u,t.line,r)}else t=l;return!0}var s=t,a=r,u=M(e,t.line);if("char"==n)l();else if("column"==n)l(!0);else if("word"==n||"group"==n)for(var c=null,f="group"==n,h=e.cm&&e.cm.getHelper(t,"wordChars"),d=!0;!(r<0)||l(!d);d=!1){var p=u.text.charAt(t.ch)||"\n",g=x(p,h)?"w":f&&"\n"==p?"n":!f||/\s/.test(p)?null:"p";if(!f||d||g||(g="s"),c&&c!=g){r<0&&(r=1,l(),t.sticky="after");break}if(g&&(c=g),r>0&&!l(!d))break}var v=ki(e,t,s,a,!0);return I(s,v)&&(v.hitSide=!0),v}function rl(e,t,r,n){var i,o=e.doc,l=t.left;if("page"==n){var s=Math.min(e.display.wrapper.clientHeight,window.innerHeight||document.documentElement.clientHeight),a=Math.max(s-.5*mr(e.display),3);i=(r>0?t.bottom:t.top)+r*a}else"line"==n&&(i=r>0?t.bottom+3:t.top-3);for(var u;(u=cr(e,l,i)).outside;){if(r<0?i<=0:i>=o.height){u.hitSide=!0;break}i+=5*r}return u}function nl(e,t){var r=jt(e,t.line);if(!r||r.hidden)return null;var n=M(e.doc,t.line),i=Ut(r,n,t.line),o=Se(n,e.doc.direction),l="left";o&&(l=Ce(o,t.ch)%2?"right":"left");var s=_t(i.map,t.ch,l);return s.offset="right"==s.collapse?s.end:s.start,s}function il(e){for(var t=e;t;t=t.parentNode)if(/CodeMirror-gutter-wrapper/.test(t.className))return!0;return!1}function ol(e,t){return t&&(e.bad=!0),e}function ll(e,t,r,n,i){function o(e){return function(t){return t.id==e}}function l(){c&&(u+=f,c=!1)}function s(e){e&&(l(),u+=e)}function a(t){if(1==t.nodeType){var r=t.getAttribute("cm-text");if(null!=r)return void s(r||t.textContent.replace(/\u200b/g,""));var u,h=t.getAttribute("cm-marker");if(h){var d=e.findMarks(E(n,0),E(i+1,0),o(+h));return void(d.length&&(u=d[0].find(0))&&s(N(e.doc,u.from,u.to).join(f)))}if("false"==t.getAttribute("contenteditable"))return;var p=/^(pre|div|p)$/i.test(t.nodeName);p&&l();for(var g=0;g<t.childNodes.length;g++)a(t.childNodes[g]);p&&(c=!0)}else 3==t.nodeType&&s(t.nodeValue)}for(var u="",c=!1,f=e.doc.lineSeparator();a(t),t!=r;)t=t.nextSibling;return u}function sl(e,t,r){var n;if(t==e.display.lineDiv){if(!(n=e.display.lineDiv.childNodes[r]))return ol(e.clipPos(E(e.display.viewTo-1)),!0);t=null,r=0}else for(n=t;;n=n.parentNode){if(!n||n==e.display.lineDiv)return null;if(n.parentNode&&n.parentNode==e.display.lineDiv)break}for(var i=0;i<e.display.view.length;i++){var o=e.display.view[i];if(o.node==n)return al(o,t,r)}}function al(e,t,r){function n(t,r,n){for(var i=-1;i<(f?f.length:0);i++)for(var o=i<0?c.map:f[i],l=0;l<o.length;l+=3){var s=o[l+2];if(s==t||s==r){var a=W(i<0?e.line:e.rest[i]),u=o[l]+n;return(n<0||s!=t)&&(u=o[l+(n?1:0)]),E(a,u)}}}var i=e.text.firstChild,l=!1;if(!t||!o(i,t))return ol(E(W(e.line),0),!0);if(t==i&&(l=!0,t=i.childNodes[r],r=0,!t)){var s=e.rest?g(e.rest):e.line;return ol(E(W(s),s.text.length),l)}var a=3==t.nodeType?t:null,u=t;for(a||1!=t.childNodes.length||3!=t.firstChild.nodeType||(a=t.firstChild,r&&(r=a.nodeValue.length));u.parentNode!=i;)u=u.parentNode;var c=e.measure,f=c.maps,h=n(a,u,r);if(h)return ol(h,l);for(var d=u.nextSibling,p=a?a.nodeValue.length-r:0;d;d=d.nextSibling){if(h=n(d,d.firstChild,0))return ol(E(h.line,h.ch-p),l);p+=d.textContent.length}for(var v=u.previousSibling,m=r;v;v=v.previousSibling){if(h=n(v,v.firstChild,-1))return ol(E(h.line,h.ch+m),l);m+=v.textContent.length}}var ul=navigator.userAgent,cl=navigator.platform,fl=/gecko\/\d/i.test(ul),hl=/MSIE \d/.test(ul),dl=/Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(ul),pl=/Edge\/(\d+)/.exec(ul),gl=hl||dl||pl,vl=gl&&(hl?document.documentMode||6:+(pl||dl)[1]),ml=!pl&&/WebKit\//.test(ul),yl=ml&&/Qt\/\d+\.\d+/.test(ul),bl=!pl&&/Chrome\//.test(ul),wl=/Opera\//.test(ul),xl=/Apple Computer/.test(navigator.vendor),Cl=/Mac OS X 1\d\D([8-9]|\d\d)\D/.test(ul),Sl=/PhantomJS/.test(ul),Ll=!pl&&/AppleWebKit/.test(ul)&&/Mobile\/\w+/.test(ul),kl=/Android/.test(ul),Tl=Ll||kl||/webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(ul),Ml=Ll||/Mac/.test(cl),Nl=/\bCrOS\b/.test(ul),Ol=/win/i.test(cl),Al=wl&&ul.match(/Version\/(\d*\.\d*)/);Al&&(Al=Number(Al[1])),Al&&Al>=15&&(wl=!1,ml=!0);var Wl,Dl=Ml&&(yl||wl&&(null==Al||Al<12.11)),Hl=fl||gl&&vl>=9,Fl=function(t,r){var n=t.className,i=e(r).exec(n);if(i){var o=n.slice(i.index+i[0].length);t.className=n.slice(0,i.index)+(o?i[1]+o:"")}};Wl=document.createRange?function(e,t,r,n){var i=document.createRange();return i.setEnd(n||e,r),i.setStart(e,t),i}:function(e,t,r){var n=document.body.createTextRange();try{n.moveToElementText(e.parentNode)}catch(e){return n}return n.collapse(!0),n.moveEnd("character",r),n.moveStart("character",t),n};var El=function(e){e.select()};Ll?El=function(e){e.selectionStart=0,e.selectionEnd=e.value.length}:gl&&(El=function(e){try{e.select()}catch(e){}});var Pl=function(){this.id=null};Pl.prototype.set=function(e,t){clearTimeout(this.id),this.id=setTimeout(t,e)};var Il,zl,Rl=30,Bl={toString:function(){return"CodeMirror.Pass"}},Gl={scroll:!1},Ul={origin:"*mouse"},Vl={origin:"+move"},Kl=[""],jl=/[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/,Xl=/[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/,Yl=!1,_l=!1,$l=null,ql=function(){function e(e){return e<=247?r.charAt(e):1424<=e&&e<=1524?"R":1536<=e&&e<=1785?n.charAt(e-1536):1774<=e&&e<=2220?"r":8192<=e&&e<=8203?"w":8204==e?"b":"L"}function t(e,t,r){this.level=e,this.from=t,this.to=r}var r="bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN",n="nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111",i=/[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/,o=/[stwN]/,l=/[LRr]/,s=/[Lb1n]/,a=/[1n]/;return function(r,n){var u="ltr"==n?"L":"R";if(0==r.length||"ltr"==n&&!i.test(r))return!1;for(var c=r.length,f=[],h=0;h<c;++h)f.push(e(r.charCodeAt(h)));for(var d=0,p=u;d<c;++d){var v=f[d];"m"==v?f[d]=p:p=v}for(var m=0,y=u;m<c;++m){var b=f[m];"1"==b&&"r"==y?f[m]="n":l.test(b)&&(y=b,"r"==b&&(f[m]="R"))}for(var w=1,x=f[0];w<c-1;++w){var C=f[w];"+"==C&&"1"==x&&"1"==f[w+1]?f[w]="1":","!=C||x!=f[w+1]||"1"!=x&&"n"!=x||(f[w]=x),x=C}for(var S=0;S<c;++S){var L=f[S];if(","==L)f[S]="N";else if("%"==L){var k=void 0;for(k=S+1;k<c&&"%"==f[k];++k);for(var T=S&&"!"==f[S-1]||k<c&&"1"==f[k]?"1":"N",M=S;M<k;++M)f[M]=T;S=k-1}}for(var N=0,O=u;N<c;++N){var A=f[N];"L"==O&&"1"==A?f[N]="L":l.test(A)&&(O=A)}for(var W=0;W<c;++W)if(o.test(f[W])){var D=void 0;for(D=W+1;D<c&&o.test(f[D]);++D);for(var H="L"==(W?f[W-1]:u),F=H==("L"==(D<c?f[D]:u))?H?"L":"R":u,E=W;E<D;++E)f[E]=F;W=D-1}for(var P,I=[],z=0;z<c;)if(s.test(f[z])){var R=z;for(++z;z<c&&s.test(f[z]);++z);I.push(new t(0,R,z))}else{var B=z,G=I.length;for(++z;z<c&&"L"!=f[z];++z);for(var U=B;U<z;)if(a.test(f[U])){B<U&&I.splice(G,0,new t(1,B,U));var V=U;for(++U;U<z&&a.test(f[U]);++U);I.splice(G,0,new t(2,V,U)),B=U}else++U;B<z&&I.splice(G,0,new t(1,B,z))}return 1==I[0].level&&(P=r.match(/^\s+/))&&(I[0].from=P[0].length,I.unshift(new t(0,0,P[0].length))),1==g(I).level&&(P=r.match(/\s+$/))&&(g(I).to-=P[0].length,I.push(new t(0,c-P[0].length,c))),"rtl"==n?I.reverse():I}}(),Zl=[],Ql=function(e,t,r){if(e.addEventListener)e.addEventListener(t,r,!1);else if(e.attachEvent)e.attachEvent("on"+t,r);else{var n=e._handlers||(e._handlers={});n[t]=(n[t]||Zl).concat(r)}},Jl=function(){if(gl&&vl<9)return!1;var e=n("div");return"draggable"in e||"dragDrop"in e}(),es=3!="\n\nb".split(/\n/).length?function(e){for(var t=0,r=[],n=e.length;t<=n;){var i=e.indexOf("\n",t);-1==i&&(i=e.length);var o=e.slice(t,"\r"==e.charAt(i-1)?i-1:i),l=o.indexOf("\r");-1!=l?(r.push(o.slice(0,l)),t+=l+1):(r.push(o),t=i+1)}return r}:function(e){return e.split(/\r\n?|\n/)},ts=window.getSelection?function(e){try{return e.selectionStart!=e.selectionEnd}catch(e){return!1}}:function(e){var t;try{t=e.ownerDocument.selection.createRange()}catch(e){}return!(!t||t.parentElement()!=e)&&0!=t.compareEndPoints("StartToEnd",t)},rs=function(){var e=n("div");return"oncopy"in e||(e.setAttribute("oncopy","return;"),"function"==typeof e.oncopy)}(),ns=null,is={},os={},ls={},ss=function(e,t,r){this.pos=this.start=0,this.string=e,this.tabSize=t||8,this.lastColumnPos=this.lastColumnValue=0,this.lineStart=0,this.lineOracle=r};ss.prototype.eol=function(){return this.pos>=this.string.length},ss.prototype.sol=function(){return this.pos==this.lineStart},ss.prototype.peek=function(){return this.string.charAt(this.pos)||void 0},ss.prototype.next=function(){if(this.pos<this.string.length)return this.string.charAt(this.pos++)},ss.prototype.eat=function(e){var t=this.string.charAt(this.pos);if("string"==typeof e?t==e:t&&(e.test?e.test(t):e(t)))return++this.pos,t},ss.prototype.eatWhile=function(e){for(var t=this.pos;this.eat(e););return this.pos>t},ss.prototype.eatSpace=function(){for(var e=this,t=this.pos;/[\s\u00a0]/.test(this.string.charAt(this.pos));)++e.pos;return this.pos>t},ss.prototype.skipToEnd=function(){this.pos=this.string.length},ss.prototype.skipTo=function(e){var t=this.string.indexOf(e,this.pos);if(t>-1)return this.pos=t,!0},ss.prototype.backUp=function(e){this.pos-=e},ss.prototype.column=function(){return this.lastColumnPos<this.start&&(this.lastColumnValue=f(this.string,this.start,this.tabSize,this.lastColumnPos,this.lastColumnValue),this.lastColumnPos=this.start),this.lastColumnValue-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.indentation=function(){return f(this.string,null,this.tabSize)-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.match=function(e,t,r){if("string"!=typeof e){var n=this.string.slice(this.pos).match(e);return n&&n.index>0?null:(n&&!1!==t&&(this.pos+=n[0].length),n)}var i=function(e){return r?e.toLowerCase():e};if(i(this.string.substr(this.pos,e.length))==i(e))return!1!==t&&(this.pos+=e.length),!0},ss.prototype.current=function(){return this.string.slice(this.start,this.pos)},ss.prototype.hideFirstChars=function(e,t){this.lineStart+=e;try{return t()}finally{this.lineStart-=e}},ss.prototype.lookAhead=function(e){var t=this.lineOracle;return t&&t.lookAhead(e)};var as=function(e,t){this.state=e,this.lookAhead=t},us=function(e,t,r,n){this.state=t,this.doc=e,this.line=r,this.maxLookAhead=n||0};us.prototype.lookAhead=function(e){var t=this.doc.getLine(this.line+e);return null!=t&&e>this.maxLookAhead&&(this.maxLookAhead=e),t},us.prototype.nextLine=function(){this.line++,this.maxLookAhead>0&&this.maxLookAhead--},us.fromSaved=function(e,t,r){return t instanceof as?new us(e,Ke(e.mode,t.state),r,t.lookAhead):new us(e,Ke(e.mode,t),r)},us.prototype.save=function(e){var t=!1!==e?Ke(this.doc.mode,this.state):this.state;return this.maxLookAhead>0?new as(t,this.maxLookAhead):t};var cs=function(e,t,r){this.start=e.start,this.end=e.pos,this.string=e.current(),this.type=t||null,this.state=r},fs=function(e,t,r){this.text=e,ne(this,t),this.height=r?r(this):1};fs.prototype.lineNo=function(){return W(this)},Ae(fs);var hs,ds={},ps={},gs=null,vs=null,ms={left:0,right:0,top:0,bottom:0},ys=function(e,t,r){this.cm=r;var i=this.vert=n("div",[n("div",null,null,"min-width: 1px")],"CodeMirror-vscrollbar"),o=this.horiz=n("div",[n("div",null,null,"height: 100%; min-height: 1px")],"CodeMirror-hscrollbar");e(i),e(o),Ql(i,"scroll",function(){i.clientHeight&&t(i.scrollTop,"vertical")}),Ql(o,"scroll",function(){o.clientWidth&&t(o.scrollLeft,"horizontal")}),this.checkedZeroWidth=!1,gl&&vl<8&&(this.horiz.style.minHeight=this.vert.style.minWidth="18px")};ys.prototype.update=function(e){var t=e.scrollWidth>e.clientWidth+1,r=e.scrollHeight>e.clientHeight+1,n=e.nativeBarWidth;if(r){this.vert.style.display="block",this.vert.style.bottom=t?n+"px":"0";var i=e.viewHeight-(t?n:0);this.vert.firstChild.style.height=Math.max(0,e.scrollHeight-e.clientHeight+i)+"px"}else this.vert.style.display="",this.vert.firstChild.style.height="0";if(t){this.horiz.style.display="block",this.horiz.style.right=r?n+"px":"0",this.horiz.style.left=e.barLeft+"px";var o=e.viewWidth-e.barLeft-(r?n:0);this.horiz.firstChild.style.width=Math.max(0,e.scrollWidth-e.clientWidth+o)+"px"}else this.horiz.style.display="",this.horiz.firstChild.style.width="0";return!this.checkedZeroWidth&&e.clientHeight>0&&(0==n&&this.zeroWidthHack(),this.checkedZeroWidth=!0),{right:r?n:0,bottom:t?n:0}},ys.prototype.setScrollLeft=function(e){this.horiz.scrollLeft!=e&&(this.horiz.scrollLeft=e),this.disableHoriz&&this.enableZeroWidthBar(this.horiz,this.disableHoriz,"horiz")},ys.prototype.setScrollTop=function(e){this.vert.scrollTop!=e&&(this.vert.scrollTop=e),this.disableVert&&this.enableZeroWidthBar(this.vert,this.disableVert,"vert")},ys.prototype.zeroWidthHack=function(){var e=Ml&&!Cl?"12px":"18px";this.horiz.style.height=this.vert.style.width=e,this.horiz.style.pointerEvents=this.vert.style.pointerEvents="none",this.disableHoriz=new Pl,this.disableVert=new Pl},ys.prototype.enableZeroWidthBar=function(e,t,r){function n(){var i=e.getBoundingClientRect();("vert"==r?document.elementFromPoint(i.right-1,(i.top+i.bottom)/2):document.elementFromPoint((i.right+i.left)/2,i.bottom-1))!=e?e.style.pointerEvents="none":t.set(1e3,n)}e.style.pointerEvents="auto",t.set(1e3,n)},ys.prototype.clear=function(){var e=this.horiz.parentNode;e.removeChild(this.horiz),e.removeChild(this.vert)};var bs=function(){};bs.prototype.update=function(){return{bottom:0,right:0}},bs.prototype.setScrollLeft=function(){},bs.prototype.setScrollTop=function(){},bs.prototype.clear=function(){};var ws={native:ys,null:bs},xs=0,Cs=function(e,t,r){var n=e.display;this.viewport=t,this.visible=Ir(n,e.doc,t),this.editorIsHidden=!n.wrapper.offsetWidth,this.wrapperHeight=n.wrapper.clientHeight,this.wrapperWidth=n.wrapper.clientWidth,this.oldDisplayWidth=Rt(e),this.force=r,this.dims=br(e),this.events=[]};Cs.prototype.signal=function(e,t){Oe(e,t)&&this.events.push(arguments)},Cs.prototype.finish=function(){for(var e=this,t=0;t<this.events.length;t++)Te.apply(null,e.events[t])};var Ss=0,Ls=null;gl?Ls=-.53:fl?Ls=15:bl?Ls=-.7:xl&&(Ls=-1/3);var ks=function(e,t){this.ranges=e,this.primIndex=t};ks.prototype.primary=function(){return this.ranges[this.primIndex]},ks.prototype.equals=function(e){var t=this;if(e==this)return!0;if(e.primIndex!=this.primIndex||e.ranges.length!=this.ranges.length)return!1;for(var r=0;r<this.ranges.length;r++){var n=t.ranges[r],i=e.ranges[r];if(!I(n.anchor,i.anchor)||!I(n.head,i.head))return!1}return!0},ks.prototype.deepCopy=function(){for(var e=this,t=[],r=0;r<this.ranges.length;r++)t[r]=new Ts(z(e.ranges[r].anchor),z(e.ranges[r].head));return new ks(t,this.primIndex)},ks.prototype.somethingSelected=function(){for(var e=this,t=0;t<this.ranges.length;t++)if(!e.ranges[t].empty())return!0;return!1},ks.prototype.contains=function(e,t){var r=this;t||(t=e);for(var n=0;n<this.ranges.length;n++){var i=r.ranges[n];if(P(t,i.from())>=0&&P(e,i.to())<=0)return n}return-1};var Ts=function(e,t){this.anchor=e,this.head=t};Ts.prototype.from=function(){return B(this.anchor,this.head)},Ts.prototype.to=function(){return R(this.anchor,this.head)},Ts.prototype.empty=function(){return this.head.line==this.anchor.line&&this.head.ch==this.anchor.ch},Bi.prototype={chunkSize:function(){return this.lines.length},removeInner:function(e,t){for(var r=this,n=e,i=e+t;n<i;++n){var o=r.lines[n];r.height-=o.height,ot(o),bt(o,"delete")}this.lines.splice(e,t)},collapse:function(e){e.push.apply(e,this.lines)},insertInner:function(e,t,r){var n=this;this.height+=r,this.lines=this.lines.slice(0,e).concat(t).concat(this.lines.slice(e));for(var i=0;i<t.length;++i)t[i].parent=n},iterN:function(e,t,r){for(var n=this,i=e+t;e<i;++e)if(r(n.lines[e]))return!0}},Gi.prototype={chunkSize:function(){return this.size},removeInner:function(e,t){var r=this;this.size-=t;for(var n=0;n<this.children.length;++n){var i=r.children[n],o=i.chunkSize();if(e<o){var l=Math.min(t,o-e),s=i.height;if(i.removeInner(e,l),r.height-=s-i.height,o==l&&(r.children.splice(n--,1),i.parent=null),0==(t-=l))break;e=0}else e-=o}if(this.size-t<25&&(this.children.length>1||!(this.children[0]instanceof Bi))){var a=[];this.collapse(a),this.children=[new Bi(a)],this.children[0].parent=this}},collapse:function(e){for(var t=this,r=0;r<this.children.length;++r)t.children[r].collapse(e)},insertInner:function(e,t,r){var n=this;this.size+=t.length,this.height+=r;for(var i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<=l){if(o.insertInner(e,t,r),o.lines&&o.lines.length>50){for(var s=o.lines.length%25+25,a=s;a<o.lines.length;){var u=new Bi(o.lines.slice(a,a+=25));o.height-=u.height,n.children.splice(++i,0,u),u.parent=n}o.lines=o.lines.slice(0,s),n.maybeSpill()}break}e-=l}},maybeSpill:function(){if(!(this.children.length<=10)){var e=this;do{var t=new Gi(e.children.splice(e.children.length-5,5));if(e.parent){e.size-=t.size,e.height-=t.height;var r=h(e.parent.children,e);e.parent.children.splice(r+1,0,t)}else{var n=new Gi(e.children);n.parent=e,e.children=[n,t],e=n}t.parent=e.parent}while(e.children.length>10);e.parent.maybeSpill()}},iterN:function(e,t,r){for(var n=this,i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<l){var s=Math.min(t,l-e);if(o.iterN(e,s,r))return!0;if(0==(t-=s))break;e=0}else e-=l}}};var Ms=function(e,t,r){var n=this;if(r)for(var i in r)r.hasOwnProperty(i)&&(n[i]=r[i]);this.doc=e,this.node=t};Ms.prototype.clear=function(){var e=this,t=this.doc.cm,r=this.line.widgets,n=this.line,i=W(n);if(null!=i&&r){for(var o=0;o<r.length;++o)r[o]==e&&r.splice(o--,1);r.length||(n.widgets=null);var l=Ht(this);A(n,Math.max(0,n.height-l)),t&&(hn(t,function(){Ui(t,n,-l),mn(t,i,"widget")}),bt(t,"lineWidgetCleared",t,this,i))}},Ms.prototype.changed=function(){var e=this,t=this.height,r=this.doc.cm,n=this.line;this.height=null;var i=Ht(this)-t;i&&(A(n,n.height+i),r&&hn(r,function(){r.curOp.forceUpdate=!0,Ui(r,n,i),bt(r,"lineWidgetChanged",r,e,W(n))}))},Ae(Ms);var Ns=0,Os=function(e,t){this.lines=[],this.type=t,this.doc=e,this.id=++Ns};Os.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){var t=this.doc.cm,r=t&&!t.curOp;if(r&&nn(t),Oe(this,"clear")){var n=this.find();n&&bt(this,"clear",n.from,n.to)}for(var i=null,o=null,l=0;l<this.lines.length;++l){var s=e.lines[l],a=_(s.markedSpans,e);t&&!e.collapsed?mn(t,W(s),"text"):t&&(null!=a.to&&(o=W(s)),null!=a.from&&(i=W(s))),s.markedSpans=$(s.markedSpans,a),null==a.from&&e.collapsed&&!ve(e.doc,s)&&t&&A(s,mr(t.display))}if(t&&this.collapsed&&!t.options.lineWrapping)for(var u=0;u<this.lines.length;++u){var c=fe(e.lines[u]),f=be(c);f>t.display.maxLineLength&&(t.display.maxLine=c,t.display.maxLineLength=f,t.display.maxLineChanged=!0)}null!=i&&t&&this.collapsed&&vn(t,i,o+1),this.lines.length=0,this.explicitlyCleared=!0,this.atomic&&this.doc.cantEdit&&(this.doc.cantEdit=!1,t&&Ci(t.doc)),t&&bt(t,"markerCleared",t,this,i,o),r&&on(t),this.parent&&this.parent.clear()}},Os.prototype.find=function(e,t){var r=this;null==e&&"bookmark"==this.type&&(e=1);for(var n,i,o=0;o<this.lines.length;++o){var l=r.lines[o],s=_(l.markedSpans,r);if(null!=s.from&&(n=E(t?l:W(l),s.from),-1==e))return n;if(null!=s.to&&(i=E(t?l:W(l),s.to),1==e))return i}return n&&{from:n,to:i}},Os.prototype.changed=function(){var e=this,t=this.find(-1,!0),r=this,n=this.doc.cm;t&&n&&hn(n,function(){var i=t.line,o=W(t.line),l=jt(n,o);if(l&&(Qt(l),n.curOp.selectionChanged=n.curOp.forceUpdate=!0),n.curOp.updateMaxLine=!0,!ve(r.doc,i)&&null!=r.height){var s=r.height;r.height=null;var a=Ht(r)-s;a&&A(i,i.height+a)}bt(n,"markerChanged",n,e)})},Os.prototype.attachLine=function(e){if(!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;t.maybeHiddenMarkers&&-1!=h(t.maybeHiddenMarkers,this)||(t.maybeUnhiddenMarkers||(t.maybeUnhiddenMarkers=[])).push(this)}this.lines.push(e)},Os.prototype.detachLine=function(e){if(this.lines.splice(h(this.lines,e),1),!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;(t.maybeHiddenMarkers||(t.maybeHiddenMarkers=[])).push(this)}},Ae(Os);var As=function(e,t){var r=this;this.markers=e,this.primary=t;for(var n=0;n<e.length;++n)e[n].parent=r};As.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){this.explicitlyCleared=!0;for(var t=0;t<this.markers.length;++t)e.markers[t].clear();bt(this,"clear")}},As.prototype.find=function(e,t){return this.primary.find(e,t)},Ae(As);var Ws=0,Ds=function(e,t,r,n,i){if(!(this instanceof Ds))return new Ds(e,t,r,n,i);null==r&&(r=0),Gi.call(this,[new Bi([new fs("",null)])]),this.first=r,this.scrollTop=this.scrollLeft=0,this.cantEdit=!1,this.cleanGeneration=1,this.modeFrontier=this.highlightFrontier=r;var o=E(r,0);this.sel=Rn(o),this.history=new Jn(null),this.id=++Ws,this.modeOption=t,this.lineSep=n,this.direction="rtl"==i?"rtl":"ltr",this.extend=!1,"string"==typeof e&&(e=this.splitLines(e)),_n(this,{from:o,to:o,text:e}),bi(this,Rn(o),Gl)};Ds.prototype=b(Gi.prototype,{constructor:Ds,iter:function(e,t,r){r?this.iterN(e-this.first,t-e,r):this.iterN(this.first,this.first+this.size,e)},insert:function(e,t){for(var r=0,n=0;n<t.length;++n)r+=t[n].height;this.insertInner(e-this.first,t,r)},remove:function(e,t){this.removeInner(e-this.first,t)},getValue:function(e){var t=O(this,this.first,this.first+this.size);return!1===e?t:t.join(e||this.lineSeparator())},setValue:gn(function(e){var t=E(this.first,0),r=this.first+this.size-1;Oi(this,{from:t,to:E(r,M(this,r).text.length),text:this.splitLines(e),origin:"setValue",full:!0},!0),this.cm&&Xr(this.cm,0,0),bi(this,Rn(t),Gl)}),replaceRange:function(e,t,r,n){Ei(this,e,t=U(this,t),r=r?U(this,r):t,n)},getRange:function(e,t,r){var n=N(this,U(this,e),U(this,t));return!1===r?n:n.join(r||this.lineSeparator())},getLine:function(e){var t=this.getLineHandle(e);return t&&t.text},getLineHandle:function(e){if(H(this,e))return M(this,e)},getLineNumber:function(e){return W(e)},getLineHandleVisualStart:function(e){return"number"==typeof e&&(e=M(this,e)),fe(e)},lineCount:function(){return this.size},firstLine:function(){return this.first},lastLine:function(){return this.first+this.size-1},clipPos:function(e){return U(this,e)},getCursor:function(e){var t=this.sel.primary();return null==e||"head"==e?t.head:"anchor"==e?t.anchor:"end"==e||"to"==e||!1===e?t.to():t.from()},listSelections:function(){return this.sel.ranges},somethingSelected:function(){return this.sel.somethingSelected()},setCursor:gn(function(e,t,r){vi(this,U(this,"number"==typeof e?E(e,t||0):e),null,r)}),setSelection:gn(function(e,t,r){vi(this,U(this,e),U(this,t||e),r)}),extendSelection:gn(function(e,t,r){di(this,U(this,e),t&&U(this,t),r)}),extendSelections:gn(function(e,t){pi(this,K(this,e),t)}),extendSelectionsBy:gn(function(e,t){pi(this,K(this,v(this.sel.ranges,e)),t)}),setSelections:gn(function(e,t,r){var n=this;if(e.length){for(var i=[],o=0;o<e.length;o++)i[o]=new Ts(U(n,e[o].anchor),U(n,e[o].head));null==t&&(t=Math.min(e.length-1,this.sel.primIndex)),bi(this,zn(i,t),r)}}),addSelection:gn(function(e,t,r){var n=this.sel.ranges.slice(0);n.push(new Ts(U(this,e),U(this,t||e))),bi(this,zn(n,n.length-1),r)}),getSelection:function(e){for(var t,r=this,n=this.sel.ranges,i=0;i<n.length;i++){var o=N(r,n[i].from(),n[i].to());t=t?t.concat(o):o}return!1===e?t:t.join(e||this.lineSeparator())},getSelections:function(e){for(var t=this,r=[],n=this.sel.ranges,i=0;i<n.length;i++){var o=N(t,n[i].from(),n[i].to());!1!==e&&(o=o.join(e||t.lineSeparator())),r[i]=o}return r},replaceSelection:function(e,t,r){for(var n=[],i=0;i<this.sel.ranges.length;i++)n[i]=e;this.replaceSelections(n,t,r||"+input")},replaceSelections:gn(function(e,t,r){for(var n=this,i=[],o=this.sel,l=0;l<o.ranges.length;l++){var s=o.ranges[l];i[l]={from:s.from(),to:s.to(),text:n.splitLines(e[l]),origin:r}}for(var a=t&&"end"!=t&&Kn(this,i,t),u=i.length-1;u>=0;u--)Oi(n,i[u]);a?yi(this,a):this.cm&&jr(this.cm)}),undo:gn(function(){Wi(this,"undo")}),redo:gn(function(){Wi(this,"redo")}),undoSelection:gn(function(){Wi(this,"undo",!0)}),redoSelection:gn(function(){Wi(this,"redo",!0)}),setExtending:function(e){this.extend=e},getExtending:function(){return this.extend},historySize:function(){for(var e=this.history,t=0,r=0,n=0;n<e.done.length;n++)e.done[n].ranges||++t;for(var i=0;i<e.undone.length;i++)e.undone[i].ranges||++r;return{undo:t,redo:r}},clearHistory:function(){this.history=new Jn(this.history.maxGeneration)},markClean:function(){this.cleanGeneration=this.changeGeneration(!0)},changeGeneration:function(e){return e&&(this.history.lastOp=this.history.lastSelOp=this.history.lastOrigin=null),this.history.generation},isClean:function(e){return this.history.generation==(e||this.cleanGeneration)},getHistory:function(){return{done:fi(this.history.done),undone:fi(this.history.undone)}},setHistory:function(e){var t=this.history=new Jn(this.history.maxGeneration);t.done=fi(e.done.slice(0),null,!0),t.undone=fi(e.undone.slice(0),null,!0)},setGutterMarker:gn(function(e,t,r){return Ri(this,e,"gutter",function(e){var n=e.gutterMarkers||(e.gutterMarkers={});return n[t]=r,!r&&C(n)&&(e.gutterMarkers=null),!0})}),clearGutter:gn(function(e){var t=this;this.iter(function(r){r.gutterMarkers&&r.gutterMarkers[e]&&Ri(t,r,"gutter",function(){return r.gutterMarkers[e]=null,C(r.gutterMarkers)&&(r.gutterMarkers=null),!0})})}),lineInfo:function(e){var t;if("number"==typeof e){if(!H(this,e))return null;if(t=e,!(e=M(this,e)))return null}else if(null==(t=W(e)))return null;return{line:t,handle:e,text:e.text,gutterMarkers:e.gutterMarkers,textClass:e.textClass,bgClass:e.bgClass,wrapClass:e.wrapClass,widgets:e.widgets}},addLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass";if(t[i]){if(e(n).test(t[i]))return!1;t[i]+=" "+n}else t[i]=n;return!0})}),removeLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass",o=t[i];if(!o)return!1;if(null==n)t[i]=null;else{var l=o.match(e(n));if(!l)return!1;var s=l.index+l[0].length;t[i]=o.slice(0,l.index)+(l.index&&s!=o.length?" ":"")+o.slice(s)||null}return!0})}),addLineWidget:gn(function(e,t,r){return Vi(this,e,t,r)}),removeLineWidget:function(e){e.clear()},markText:function(e,t,r){return Ki(this,U(this,e),U(this,t),r,r&&r.type||"range")},setBookmark:function(e,t){var r={replacedWith:t&&(null==t.nodeType?t.widget:t),insertLeft:t&&t.insertLeft,clearWhenEmpty:!1,shared:t&&t.shared,handleMouseEvents:t&&t.handleMouseEvents};return e=U(this,e),Ki(this,e,e,r,"bookmark")},findMarksAt:function(e){var t=[],r=M(this,(e=U(this,e)).line).markedSpans;if(r)for(var n=0;n<r.length;++n){var i=r[n];(null==i.from||i.from<=e.ch)&&(null==i.to||i.to>=e.ch)&&t.push(i.marker.parent||i.marker)}return t},findMarks:function(e,t,r){e=U(this,e),t=U(this,t);var n=[],i=e.line;return this.iter(e.line,t.line+1,function(o){var l=o.markedSpans;if(l)for(var s=0;s<l.length;s++){var a=l[s];null!=a.to&&i==e.line&&e.ch>=a.to||null==a.from&&i!=e.line||null!=a.from&&i==t.line&&a.from>=t.ch||r&&!r(a.marker)||n.push(a.marker.parent||a.marker)}++i}),n},getAllMarks:function(){var e=[];return this.iter(function(t){var r=t.markedSpans;if(r)for(var n=0;n<r.length;++n)null!=r[n].from&&e.push(r[n].marker)}),e},posFromIndex:function(e){var t,r=this.first,n=this.lineSeparator().length;return this.iter(function(i){var o=i.text.length+n;if(o>e)return t=e,!0;e-=o,++r}),U(this,E(r,t))},indexFromPos:function(e){var t=(e=U(this,e)).ch;if(e.line<this.first||e.ch<0)return 0;var r=this.lineSeparator().length;return this.iter(this.first,e.line,function(e){t+=e.text.length+r}),t},copy:function(e){var t=new Ds(O(this,this.first,this.first+this.size),this.modeOption,this.first,this.lineSep,this.direction);return t.scrollTop=this.scrollTop,t.scrollLeft=this.scrollLeft,t.sel=this.sel,t.extend=!1,e&&(t.history.undoDepth=this.history.undoDepth,t.setHistory(this.getHistory())),t},linkedDoc:function(e){e||(e={});var t=this.first,r=this.first+this.size;null!=e.from&&e.from>t&&(t=e.from),null!=e.to&&e.to<r&&(r=e.to);var n=new Ds(O(this,t,r),e.mode||this.modeOption,t,this.lineSep,this.direction);return e.sharedHist&&(n.history=this.history),(this.linked||(this.linked=[])).push({doc:n,sharedHist:e.sharedHist}),n.linked=[{doc:this,isParent:!0,sharedHist:e.sharedHist}],Yi(n,Xi(this)),n},unlinkDoc:function(e){var t=this;if(e instanceof jo&&(e=e.doc),this.linked)for(var r=0;r<this.linked.length;++r)if(t.linked[r].doc==e){t.linked.splice(r,1),e.unlinkDoc(t),_i(Xi(t));break}if(e.history==this.history){var n=[e.id];$n(e,function(e){return n.push(e.id)},!0),e.history=new Jn(null),e.history.done=fi(this.history.done,n),e.history.undone=fi(this.history.undone,n)}},iterLinkedDocs:function(e){$n(this,e)},getMode:function(){return this.mode},getEditor:function(){return this.cm},splitLines:function(e){return this.lineSep?e.split(this.lineSep):es(e)},lineSeparator:function(){return this.lineSep||"\n"},setDirection:gn(function(e){"rtl"!=e&&(e="ltr"),e!=this.direction&&(this.direction=e,this.iter(function(e){return e.order=null}),this.cm&&Qn(this.cm))})}),Ds.prototype.eachLine=Ds.prototype.iter;for(var Hs=0,Fs=!1,Es={3:"Enter",8:"Backspace",9:"Tab",13:"Enter",16:"Shift",17:"Ctrl",18:"Alt",19:"Pause",20:"CapsLock",27:"Esc",32:"Space",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"Left",38:"Up",39:"Right",40:"Down",44:"PrintScrn",45:"Insert",46:"Delete",59:";",61:"=",91:"Mod",92:"Mod",93:"Mod",106:"*",107:"=",109:"-",110:".",111:"/",127:"Delete",173:"-",186:";",187:"=",188:",",189:"-",190:".",191:"/",192:"`",219:"[",220:"\\",221:"]",222:"'",63232:"Up",63233:"Down",63234:"Left",63235:"Right",63272:"Delete",63273:"Home",63275:"End",63276:"PageUp",63277:"PageDown",63302:"Insert"},Ps=0;Ps<10;Ps++)Es[Ps+48]=Es[Ps+96]=String(Ps);for(var Is=65;Is<=90;Is++)Es[Is]=String.fromCharCode(Is);for(var zs=1;zs<=12;zs++)Es[zs+111]=Es[zs+63235]="F"+zs;var Rs={};Rs.basic={Left:"goCharLeft",Right:"goCharRight",Up:"goLineUp",Down:"goLineDown",End:"goLineEnd",Home:"goLineStartSmart",PageUp:"goPageUp",PageDown:"goPageDown",Delete:"delCharAfter",Backspace:"delCharBefore","Shift-Backspace":"delCharBefore",Tab:"defaultTab","Shift-Tab":"indentAuto",Enter:"newlineAndIndent",Insert:"toggleOverwrite",Esc:"singleSelection"},Rs.pcDefault={"Ctrl-A":"selectAll","Ctrl-D":"deleteLine","Ctrl-Z":"undo","Shift-Ctrl-Z":"redo","Ctrl-Y":"redo","Ctrl-Home":"goDocStart","Ctrl-End":"goDocEnd","Ctrl-Up":"goLineUp","Ctrl-Down":"goLineDown","Ctrl-Left":"goGroupLeft","Ctrl-Right":"goGroupRight","Alt-Left":"goLineStart","Alt-Right":"goLineEnd","Ctrl-Backspace":"delGroupBefore","Ctrl-Delete":"delGroupAfter","Ctrl-S":"save","Ctrl-F":"find","Ctrl-G":"findNext","Shift-Ctrl-G":"findPrev","Shift-Ctrl-F":"replace","Shift-Ctrl-R":"replaceAll","Ctrl-[":"indentLess","Ctrl-]":"indentMore","Ctrl-U":"undoSelection","Shift-Ctrl-U":"redoSelection","Alt-U":"redoSelection",fallthrough:"basic"},Rs.emacsy={"Ctrl-F":"goCharRight","Ctrl-B":"goCharLeft","Ctrl-P":"goLineUp","Ctrl-N":"goLineDown","Alt-F":"goWordRight","Alt-B":"goWordLeft","Ctrl-A":"goLineStart","Ctrl-E":"goLineEnd","Ctrl-V":"goPageDown","Shift-Ctrl-V":"goPageUp","Ctrl-D":"delCharAfter","Ctrl-H":"delCharBefore","Alt-D":"delWordAfter","Alt-Backspace":"delWordBefore","Ctrl-K":"killLine","Ctrl-T":"transposeChars","Ctrl-O":"openLine"},Rs.macDefault={"Cmd-A":"selectAll","Cmd-D":"deleteLine","Cmd-Z":"undo","Shift-Cmd-Z":"redo","Cmd-Y":"redo","Cmd-Home":"goDocStart","Cmd-Up":"goDocStart","Cmd-End":"goDocEnd","Cmd-Down":"goDocEnd","Alt-Left":"goGroupLeft","Alt-Right":"goGroupRight","Cmd-Left":"goLineLeft","Cmd-Right":"goLineRight","Alt-Backspace":"delGroupBefore","Ctrl-Alt-Backspace":"delGroupAfter","Alt-Delete":"delGroupAfter","Cmd-S":"save","Cmd-F":"find","Cmd-G":"findNext","Shift-Cmd-G":"findPrev","Cmd-Alt-F":"replace","Shift-Cmd-Alt-F":"replaceAll","Cmd-[":"indentLess","Cmd-]":"indentMore","Cmd-Backspace":"delWrappedLineLeft","Cmd-Delete":"delWrappedLineRight","Cmd-U":"undoSelection","Shift-Cmd-U":"redoSelection","Ctrl-Up":"goDocStart","Ctrl-Down":"goDocEnd",fallthrough:["basic","emacsy"]},Rs.default=Ml?Rs.macDefault:Rs.pcDefault;var Bs={selectAll:Mi,singleSelection:function(e){return e.setSelection(e.getCursor("anchor"),e.getCursor("head"),Gl)},killLine:function(e){return co(e,function(t){if(t.empty()){var r=M(e.doc,t.head.line).text.length;return t.head.ch==r&&t.head.line<e.lastLine()?{from:t.head,to:E(t.head.line+1,0)}:{from:t.head,to:E(t.head.line,r)}}return{from:t.from(),to:t.to()}})},deleteLine:function(e){return co(e,function(t){return{from:E(t.from().line,0),to:U(e.doc,E(t.to().line+1,0))}})},delLineLeft:function(e){return co(e,function(e){return{from:E(e.from().line,0),to:e.from()}})},delWrappedLineLeft:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5;return{from:e.coordsChar({left:0,top:r},"div"),to:t.from()}})},delWrappedLineRight:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5,n=e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div");return{from:t.from(),to:n}})},undo:function(e){return e.undo()},redo:function(e){return e.redo()},undoSelection:function(e){return e.undoSelection()},redoSelection:function(e){return e.redoSelection()},goDocStart:function(e){return e.extendSelection(E(e.firstLine(),0))},goDocEnd:function(e){return e.extendSelection(E(e.lastLine()))},goLineStart:function(e){return e.extendSelectionsBy(function(t){return vo(e,t.head.line)},{origin:"+move",bias:1})},goLineStartSmart:function(e){return e.extendSelectionsBy(function(t){return yo(e,t.head)},{origin:"+move",bias:1})},goLineEnd:function(e){return e.extendSelectionsBy(function(t){return mo(e,t.head.line)},{origin:"+move",bias:-1})},goLineRight:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div")},Vl)},goLineLeft:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:0,top:r},"div")},Vl)},goLineLeftSmart:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5,n=e.coordsChar({left:0,top:r},"div");return n.ch<e.getLine(n.line).search(/\S/)?yo(e,t.head):n},Vl)},goLineUp:function(e){return e.moveV(-1,"line")},goLineDown:function(e){return e.moveV(1,"line")},goPageUp:function(e){return e.moveV(-1,"page")},goPageDown:function(e){return e.moveV(1,"page")},goCharLeft:function(e){return e.moveH(-1,"char")},goCharRight:function(e){return e.moveH(1,"char")},goColumnLeft:function(e){return e.moveH(-1,"column")},goColumnRight:function(e){return e.moveH(1,"column")},goWordLeft:function(e){return e.moveH(-1,"word")},goGroupRight:function(e){return e.moveH(1,"group")},goGroupLeft:function(e){return e.moveH(-1,"group")},goWordRight:function(e){return e.moveH(1,"word")},delCharBefore:function(e){return e.deleteH(-1,"char")},delCharAfter:function(e){return e.deleteH(1,"char")},delWordBefore:function(e){return e.deleteH(-1,"word")},delWordAfter:function(e){return e.deleteH(1,"word")},delGroupBefore:function(e){return e.deleteH(-1,"group")},delGroupAfter:function(e){return e.deleteH(1,"group")},indentAuto:function(e){return e.indentSelection("smart")},indentMore:function(e){return e.indentSelection("add")},indentLess:function(e){return e.indentSelection("subtract")},insertTab:function(e){return e.replaceSelection("\t")},insertSoftTab:function(e){for(var t=[],r=e.listSelections(),n=e.options.tabSize,i=0;i<r.length;i++){var o=r[i].from(),l=f(e.getLine(o.line),o.ch,n);t.push(p(n-l%n))}e.replaceSelections(t)},defaultTab:function(e){e.somethingSelected()?e.indentSelection("add"):e.execCommand("insertTab")},transposeChars:function(e){return hn(e,function(){for(var t=e.listSelections(),r=[],n=0;n<t.length;n++)if(t[n].empty()){var i=t[n].head,o=M(e.doc,i.line).text;if(o)if(i.ch==o.length&&(i=new E(i.line,i.ch-1)),i.ch>0)i=new E(i.line,i.ch+1),e.replaceRange(o.charAt(i.ch-1)+o.charAt(i.ch-2),E(i.line,i.ch-2),i,"+transpose");else if(i.line>e.doc.first){var l=M(e.doc,i.line-1).text;l&&(i=new E(i.line,1),e.replaceRange(o.charAt(0)+e.doc.lineSeparator()+l.charAt(l.length-1),E(i.line-1,l.length-1),i,"+transpose"))}r.push(new Ts(i,i))}e.setSelections(r)})},newlineAndIndent:function(e){return hn(e,function(){for(var t=e.listSelections(),r=t.length-1;r>=0;r--)e.replaceRange(e.doc.lineSeparator(),t[r].anchor,t[r].head,"+input");t=e.listSelections();for(var n=0;n<t.length;n++)e.indentLine(t[n].from().line,null,!0);jr(e)})},openLine:function(e){return e.replaceSelection("\n","start")},toggleOverwrite:function(e){return e.toggleOverwrite()}},Gs=new Pl,Us=null,Vs=function(e,t,r){this.time=e,this.pos=t,this.button=r};Vs.prototype.compare=function(e,t,r){return this.time+400>e&&0==P(t,this.pos)&&r==this.button};var Ks,js,Xs={toString:function(){return"CodeMirror.Init"}},Ys={},_s={};jo.defaults=Ys,jo.optionHandlers=_s;var $s=[];jo.defineInitHook=function(e){return $s.push(e)};var qs=null,Zs=function(e){this.cm=e,this.lastAnchorNode=this.lastAnchorOffset=this.lastFocusNode=this.lastFocusOffset=null,this.polling=new Pl,this.composing=null,this.gracePeriod=!1,this.readDOMTimeout=null};Zs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()}),"cut"==e.type&&i.replaceSelection("",null,"cut");else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type&&i.operation(function(){i.setSelections(t.ranges,0,Gl),i.replaceSelection("",null,"cut")})}if(e.clipboardData){e.clipboardData.clearData();var r=qs.text.join("\n");if(e.clipboardData.setData("Text",r),e.clipboardData.getData("Text")==r)return void e.preventDefault()}var l=el(),s=l.firstChild;i.display.lineSpace.insertBefore(l,i.display.lineSpace.firstChild),s.value=qs.text.join("\n");var a=document.activeElement;El(s),setTimeout(function(){i.display.lineSpace.removeChild(l),a.focus(),a==o&&n.showPrimarySelection()},50)}}var r=this,n=this,i=n.cm,o=n.div=e.lineDiv;Jo(o,i.options.spellcheck),Ql(o,"paste",function(e){Me(i,e)||qo(e,i)||vl<=11&&setTimeout(dn(i,function(){return r.updateFromDOM()}),20)}),Ql(o,"compositionstart",function(e){r.composing={data:e.data,done:!1}}),Ql(o,"compositionupdate",function(e){r.composing||(r.composing={data:e.data,done:!1})}),Ql(o,"compositionend",function(e){r.composing&&(e.data!=r.composing.data&&r.readFromDOMSoon(),r.composing.done=!0)}),Ql(o,"touchstart",function(){return n.forceCompositionEnd()}),Ql(o,"input",function(){r.composing||r.readFromDOMSoon()}),Ql(o,"copy",t),Ql(o,"cut",t)},Zs.prototype.prepareSelection=function(){var e=Tr(this.cm,!1);return e.focus=this.cm.state.focused,e},Zs.prototype.showSelection=function(e,t){e&&this.cm.display.view.length&&((e.focus||t)&&this.showPrimarySelection(),this.showMultipleSelections(e))},Zs.prototype.showPrimarySelection=function(){var e=window.getSelection(),t=this.cm,r=t.doc.sel.primary(),n=r.from(),i=r.to();if(t.display.viewTo==t.display.viewFrom||n.line>=t.display.viewTo||i.line<t.display.viewFrom)e.removeAllRanges();else{var o=sl(t,e.anchorNode,e.anchorOffset),l=sl(t,e.focusNode,e.focusOffset);if(!o||o.bad||!l||l.bad||0!=P(B(o,l),n)||0!=P(R(o,l),i)){var s=t.display.view,a=n.line>=t.display.viewFrom&&nl(t,n)||{node:s[0].measure.map[2],offset:0},u=i.line<t.display.viewTo&&nl(t,i);if(!u){var c=s[s.length-1].measure,f=c.maps?c.maps[c.maps.length-1]:c.map;u={node:f[f.length-1],offset:f[f.length-2]-f[f.length-3]}}if(a&&u){var h,d=e.rangeCount&&e.getRangeAt(0);try{h=Wl(a.node,a.offset,u.offset,u.node)}catch(e){}h&&(!fl&&t.state.focused?(e.collapse(a.node,a.offset),h.collapsed||(e.removeAllRanges(),e.addRange(h))):(e.removeAllRanges(),e.addRange(h)),d&&null==e.anchorNode?e.addRange(d):fl&&this.startGracePeriod()),this.rememberSelection()}else e.removeAllRanges()}}},Zs.prototype.startGracePeriod=function(){var e=this;clearTimeout(this.gracePeriod),this.gracePeriod=setTimeout(function(){e.gracePeriod=!1,e.selectionChanged()&&e.cm.operation(function(){return e.cm.curOp.selectionChanged=!0})},20)},Zs.prototype.showMultipleSelections=function(e){r(this.cm.display.cursorDiv,e.cursors),r(this.cm.display.selectionDiv,e.selection)},Zs.prototype.rememberSelection=function(){var e=window.getSelection();this.lastAnchorNode=e.anchorNode,this.lastAnchorOffset=e.anchorOffset,this.lastFocusNode=e.focusNode,this.lastFocusOffset=e.focusOffset},Zs.prototype.selectionInEditor=function(){var e=window.getSelection();if(!e.rangeCount)return!1;var t=e.getRangeAt(0).commonAncestorContainer;return o(this.div,t)},Zs.prototype.focus=function(){"nocursor"!=this.cm.options.readOnly&&(this.selectionInEditor()||this.showSelection(this.prepareSelection(),!0),this.div.focus())},Zs.prototype.blur=function(){this.div.blur()},Zs.prototype.getField=function(){return this.div},Zs.prototype.supportsTouch=function(){return!0},Zs.prototype.receivedFocus=function(){function e(){t.cm.state.focused&&(t.pollSelection(),t.polling.set(t.cm.options.pollInterval,e))}var t=this;this.selectionInEditor()?this.pollSelection():hn(this.cm,function(){return t.cm.curOp.selectionChanged=!0}),this.polling.set(this.cm.options.pollInterval,e)},Zs.prototype.selectionChanged=function(){var e=window.getSelection();return e.anchorNode!=this.lastAnchorNode||e.anchorOffset!=this.lastAnchorOffset||e.focusNode!=this.lastFocusNode||e.focusOffset!=this.lastFocusOffset},Zs.prototype.pollSelection=function(){if(null==this.readDOMTimeout&&!this.gracePeriod&&this.selectionChanged()){var e=window.getSelection(),t=this.cm;if(kl&&bl&&this.cm.options.gutters.length&&il(e.anchorNode))return this.cm.triggerOnKeyDown({type:"keydown",keyCode:8,preventDefault:Math.abs}),this.blur(),void this.focus();if(!this.composing){this.rememberSelection();var r=sl(t,e.anchorNode,e.anchorOffset),n=sl(t,e.focusNode,e.focusOffset);r&&n&&hn(t,function(){bi(t.doc,Rn(r,n),Gl),(r.bad||n.bad)&&(t.curOp.selectionChanged=!0)})}}},Zs.prototype.pollContent=function(){null!=this.readDOMTimeout&&(clearTimeout(this.readDOMTimeout),this.readDOMTimeout=null);var e=this.cm,t=e.display,r=e.doc.sel.primary(),n=r.from(),i=r.to();if(0==n.ch&&n.line>e.firstLine()&&(n=E(n.line-1,M(e.doc,n.line-1).length)),i.ch==M(e.doc,i.line).text.length&&i.line<e.lastLine()&&(i=E(i.line+1,0)),n.line<t.viewFrom||i.line>t.viewTo-1)return!1;var o,l,s;n.line==t.viewFrom||0==(o=Lr(e,n.line))?(l=W(t.view[0].line),s=t.view[0].node):(l=W(t.view[o].line),s=t.view[o-1].node.nextSibling);var a,u,c=Lr(e,i.line);if(c==t.view.length-1?(a=t.viewTo-1,u=t.lineDiv.lastChild):(a=W(t.view[c+1].line)-1,u=t.view[c+1].node.previousSibling),!s)return!1;for(var f=e.doc.splitLines(ll(e,s,u,l,a)),h=N(e.doc,E(l,0),E(a,M(e.doc,a).text.length));f.length>1&&h.length>1;)if(g(f)==g(h))f.pop(),h.pop(),a--;else{if(f[0]!=h[0])break;f.shift(),h.shift(),l++}for(var d=0,p=0,v=f[0],m=h[0],y=Math.min(v.length,m.length);d<y&&v.charCodeAt(d)==m.charCodeAt(d);)++d;for(var b=g(f),w=g(h),x=Math.min(b.length-(1==f.length?d:0),w.length-(1==h.length?d:0));p<x&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)++p;if(1==f.length&&1==h.length&&l==n.line)for(;d&&d>n.ch&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)d--,p++;f[f.length-1]=b.slice(0,b.length-p).replace(/^\u200b+/,""),f[0]=f[0].slice(d).replace(/\u200b+$/,"");var C=E(l,d),S=E(a,h.length?g(h).length-p:0);return f.length>1||f[0]||P(C,S)?(Ei(e.doc,f,C,S,"+input"),!0):void 0},Zs.prototype.ensurePolled=function(){this.forceCompositionEnd()},Zs.prototype.reset=function(){this.forceCompositionEnd()},Zs.prototype.forceCompositionEnd=function(){this.composing&&(clearTimeout(this.readDOMTimeout),this.composing=null,this.updateFromDOM(),this.div.blur(),this.div.focus())},Zs.prototype.readFromDOMSoon=function(){var e=this;null==this.readDOMTimeout&&(this.readDOMTimeout=setTimeout(function(){if(e.readDOMTimeout=null,e.composing){if(!e.composing.done)return;e.composing=null}e.updateFromDOM()},80))},Zs.prototype.updateFromDOM=function(){var e=this;!this.cm.isReadOnly()&&this.pollContent()||hn(this.cm,function(){return vn(e.cm)})},Zs.prototype.setUneditable=function(e){e.contentEditable="false"},Zs.prototype.onKeyPress=function(e){0!=e.charCode&&(e.preventDefault(),this.cm.isReadOnly()||dn(this.cm,$o)(this.cm,String.fromCharCode(null==e.charCode?e.keyCode:e.charCode),0))},Zs.prototype.readOnlyChanged=function(e){this.div.contentEditable=String("nocursor"!=e)},Zs.prototype.onContextMenu=function(){},Zs.prototype.resetPosition=function(){},Zs.prototype.needsContentAttribute=!0;var Qs=function(e){this.cm=e,this.prevInput="",this.pollingFast=!1,this.polling=new Pl,this.hasSelection=!1,this.composing=null};Qs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()});else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type?i.setSelections(t.ranges,null,Gl):(n.prevInput="",l.value=t.text.join("\n"),El(l))}"cut"==e.type&&(i.state.cutIncoming=!0)}}var r=this,n=this,i=this.cm,o=this.wrapper=el(),l=this.textarea=o.firstChild;e.wrapper.insertBefore(o,e.wrapper.firstChild),Ll&&(l.style.width="0px"),Ql(l,"input",function(){gl&&vl>=9&&r.hasSelection&&(r.hasSelection=null),n.poll()}),Ql(l,"paste",function(e){Me(i,e)||qo(e,i)||(i.state.pasteIncoming=!0,n.fastPoll())}),Ql(l,"cut",t),Ql(l,"copy",t),Ql(e.scroller,"paste",function(t){Ft(e,t)||Me(i,t)||(i.state.pasteIncoming=!0,n.focus())}),Ql(e.lineSpace,"selectstart",function(t){Ft(e,t)||We(t)}),Ql(l,"compositionstart",function(){var e=i.getCursor("from");n.composing&&n.composing.range.clear(),n.composing={start:e,range:i.markText(e,i.getCursor("to"),{className:"CodeMirror-composing"})}}),Ql(l,"compositionend",function(){n.composing&&(n.poll(),n.composing.range.clear(),n.composing=null)})},Qs.prototype.prepareSelection=function(){var e=this.cm,t=e.display,r=e.doc,n=Tr(e);if(e.options.moveInputWithCursor){var i=sr(e,r.sel.primary().head,"div"),o=t.wrapper.getBoundingClientRect(),l=t.lineDiv.getBoundingClientRect();n.teTop=Math.max(0,Math.min(t.wrapper.clientHeight-10,i.top+l.top-o.top)),n.teLeft=Math.max(0,Math.min(t.wrapper.clientWidth-10,i.left+l.left-o.left))}return n},Qs.prototype.showSelection=function(e){var t=this.cm.display;r(t.cursorDiv,e.cursors),r(t.selectionDiv,e.selection),null!=e.teTop&&(this.wrapper.style.top=e.teTop+"px",this.wrapper.style.left=e.teLeft+"px")},Qs.prototype.reset=function(e){if(!this.contextMenuPending&&!this.composing){var t=this.cm;if(t.somethingSelected()){this.prevInput="";var r=t.getSelection();this.textarea.value=r,t.state.focused&&El(this.textarea),gl&&vl>=9&&(this.hasSelection=r)}else e||(this.prevInput=this.textarea.value="",gl&&vl>=9&&(this.hasSelection=null))}},Qs.prototype.getField=function(){return this.textarea},Qs.prototype.supportsTouch=function(){return!1},Qs.prototype.focus=function(){if("nocursor"!=this.cm.options.readOnly&&(!Tl||l()!=this.textarea))try{this.textarea.focus()}catch(e){}},Qs.prototype.blur=function(){this.textarea.blur()},Qs.prototype.resetPosition=function(){this.wrapper.style.top=this.wrapper.style.left=0},Qs.prototype.receivedFocus=function(){this.slowPoll()},Qs.prototype.slowPoll=function(){var e=this;this.pollingFast||this.polling.set(this.cm.options.pollInterval,function(){e.poll(),e.cm.state.focused&&e.slowPoll()})},Qs.prototype.fastPoll=function(){function e(){r.poll()||t?(r.pollingFast=!1,r.slowPoll()):(t=!0,r.polling.set(60,e))}var t=!1,r=this;r.pollingFast=!0,r.polling.set(20,e)},Qs.prototype.poll=function(){var e=this,t=this.cm,r=this.textarea,n=this.prevInput;if(this.contextMenuPending||!t.state.focused||ts(r)&&!n&&!this.composing||t.isReadOnly()||t.options.disableInput||t.state.keySeq)return!1;var i=r.value;if(i==n&&!t.somethingSelected())return!1;if(gl&&vl>=9&&this.hasSelection===i||Ml&&/[\uf700-\uf7ff]/.test(i))return t.display.input.reset(),!1;if(t.doc.sel==t.display.selForContextMenu){var o=i.charCodeAt(0);if(8203!=o||n||(n="​"),8666==o)return this.reset(),this.cm.execCommand("undo")}for(var l=0,s=Math.min(n.length,i.length);l<s&&n.charCodeAt(l)==i.charCodeAt(l);)++l;return hn(t,function(){$o(t,i.slice(l),n.length-l,null,e.composing?"*compose":null),i.length>1e3||i.indexOf("\n")>-1?r.value=e.prevInput="":e.prevInput=i,e.composing&&(e.composing.range.clear(),e.composing.range=t.markText(e.composing.start,t.getCursor("to"),{className:"CodeMirror-composing"}))}),!0},Qs.prototype.ensurePolled=function(){this.pollingFast&&this.poll()&&(this.pollingFast=!1)},Qs.prototype.onKeyPress=function(){gl&&vl>=9&&(this.hasSelection=null),this.fastPoll()},Qs.prototype.onContextMenu=function(e){function t(){if(null!=l.selectionStart){var e=i.somethingSelected(),t="​"+(e?l.value:"");l.value="⇚",l.value=t,n.prevInput=e?"":"​",l.selectionStart=1,l.selectionEnd=t.length,o.selForContextMenu=i.doc.sel}}function r(){if(n.contextMenuPending=!1,n.wrapper.style.cssText=c,l.style.cssText=u,gl&&vl<9&&o.scrollbars.setScrollTop(o.scroller.scrollTop=a),null!=l.selectionStart){(!gl||gl&&vl<9)&&t();var e=0,r=function(){o.selForContextMenu==i.doc.sel&&0==l.selectionStart&&l.selectionEnd>0&&"​"==n.prevInput?dn(i,Mi)(i):e++<10?o.detectingSelectAll=setTimeout(r,500):(o.selForContextMenu=null,o.input.reset())};o.detectingSelectAll=setTimeout(r,200)}}var n=this,i=n.cm,o=i.display,l=n.textarea,s=Sr(i,e),a=o.scroller.scrollTop;if(s&&!wl){i.options.resetSelectionOnContextMenu&&-1==i.doc.sel.contains(s)&&dn(i,bi)(i.doc,Rn(s),Gl);var u=l.style.cssText,c=n.wrapper.style.cssText;n.wrapper.style.cssText="position: absolute";var f=n.wrapper.getBoundingClientRect();l.style.cssText="position: absolute; width: 30px; height: 30px;\n      top: "+(e.clientY-f.top-5)+"px; left: "+(e.clientX-f.left-5)+"px;\n      z-index: 1000; background: "+(gl?"rgba(255, 255, 255, .05)":"transparent")+";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";var h;if(ml&&(h=window.scrollY),o.input.focus(),ml&&window.scrollTo(null,h),o.input.reset(),i.somethingSelected()||(l.value=n.prevInput=" "),n.contextMenuPending=!0,o.selForContextMenu=i.doc.sel,clearTimeout(o.detectingSelectAll),gl&&vl>=9&&t(),Hl){Fe(e);var d=function(){ke(window,"mouseup",d),setTimeout(r,20)};Ql(window,"mouseup",d)}else setTimeout(r,50)}},Qs.prototype.readOnlyChanged=function(e){e||this.reset(),this.textarea.disabled="nocursor"==e},Qs.prototype.setUneditable=function(){},Qs.prototype.needsContentAttribute=!1,function(e){function t(t,n,i,o){e.defaults[t]=n,i&&(r[t]=o?function(e,t,r){r!=Xs&&i(e,t,r)}:i)}var r=e.optionHandlers;e.defineOption=t,e.Init=Xs,t("value","",function(e,t){return e.setValue(t)},!0),t("mode",null,function(e,t){e.doc.modeOption=t,jn(e)},!0),t("indentUnit",2,jn,!0),t("indentWithTabs",!1),t("smartIndent",!0),t("tabSize",4,function(e){Xn(e),er(e),vn(e)},!0),t("lineSeparator",null,function(e,t){if(e.doc.lineSep=t,t){var r=[],n=e.doc.first;e.doc.iter(function(e){for(var i=0;;){var o=e.text.indexOf(t,i);if(-1==o)break;i=o+t.length,r.push(E(n,o))}n++});for(var i=r.length-1;i>=0;i--)Ei(e.doc,t,r[i],E(r[i].line,r[i].ch+t.length))}}),t("specialChars",/[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff]/g,function(e,t,r){e.state.specialChars=new RegExp(t.source+(t.test("\t")?"":"|\t"),"g"),r!=Xs&&e.refresh()}),t("specialCharPlaceholder",at,function(e){return e.refresh()},!0),t("electricChars",!0),t("inputStyle",Tl?"contenteditable":"textarea",function(){throw new Error("inputStyle can not (yet) be changed in a running editor")},!0),t("spellcheck",!1,function(e,t){return e.getInputField().spellcheck=t},!0),t("rtlMoveVisually",!Ol),t("wholeLineUpdateBefore",!0),t("theme","default",function(e){Go(e),Uo(e)},!0),t("keyMap","default",function(e,t,r){var n=uo(t),i=r!=Xs&&uo(r);i&&i.detach&&i.detach(e,n),n.attach&&n.attach(e,i||null)}),t("extraKeys",null),t("configureMouse",null),t("lineWrapping",!1,Ko,!0),t("gutters",[],function(e){Fn(e.options),Uo(e)},!0),t("fixedGutter",!0,function(e,t){e.display.gutters.style.left=t?wr(e.display)+"px":"0",e.refresh()},!0),t("coverGutterNextToScrollbar",!1,function(e){return en(e)},!0),t("scrollbarStyle","native",function(e){rn(e),en(e),e.display.scrollbars.setScrollTop(e.doc.scrollTop),e.display.scrollbars.setScrollLeft(e.doc.scrollLeft)},!0),t("lineNumbers",!1,function(e){Fn(e.options),Uo(e)},!0),t("firstLineNumber",1,Uo,!0),t("lineNumberFormatter",function(e){return e},Uo,!0),t("showCursorWhenSelecting",!1,kr,!0),t("resetSelectionOnContextMenu",!0),t("lineWiseCopyCut",!0),t("pasteLinesPerSelection",!0),t("readOnly",!1,function(e,t){"nocursor"==t&&(Fr(e),e.display.input.blur()),e.display.input.readOnlyChanged(t)}),t("disableInput",!1,function(e,t){t||e.display.input.reset()},!0),t("dragDrop",!0,Vo),t("allowDropFileTypes",null),t("cursorBlinkRate",530),t("cursorScrollMargin",0),t("cursorHeight",1,kr,!0),t("singleCursorHeightPerLine",!0,kr,!0),t("workTime",100),t("workDelay",100),t("flattenSpans",!0,Xn,!0),t("addModeClass",!1,Xn,!0),t("pollInterval",100),t("undoDepth",200,function(e,t){return e.doc.history.undoDepth=t}),t("historyEventDelay",1250),t("viewportMargin",10,function(e){return e.refresh()},!0),t("maxHighlightLength",1e4,Xn,!0),t("moveInputWithCursor",!0,function(e,t){t||e.display.input.resetPosition()}),t("tabindex",null,function(e,t){return e.display.input.getField().tabIndex=t||""}),t("autofocus",null),t("direction","ltr",function(e,t){return e.doc.setDirection(t)},!0)}(jo),function(e){var t=e.optionHandlers,r=e.helpers={};e.prototype={constructor:e,focus:function(){window.focus(),this.display.input.focus()},setOption:function(e,r){var n=this.options,i=n[e];n[e]==r&&"mode"!=e||(n[e]=r,t.hasOwnProperty(e)&&dn(this,t[e])(this,r,i),Te(this,"optionChange",this,e))},getOption:function(e){return this.options[e]},getDoc:function(){return this.doc},addKeyMap:function(e,t){this.state.keyMaps[t?"push":"unshift"](uo(e))},removeKeyMap:function(e){for(var t=this.state.keyMaps,r=0;r<t.length;++r)if(t[r]==e||t[r].name==e)return t.splice(r,1),!0},addOverlay:pn(function(t,r){var n=t.token?t:e.getMode(this.options,t);if(n.startState)throw new Error("Overlays may not be stateful.");m(this.state.overlays,{mode:n,modeSpec:t,opaque:r&&r.opaque,priority:r&&r.priority||0},function(e){return e.priority}),this.state.modeGen++,vn(this)}),removeOverlay:pn(function(e){for(var t=this,r=this.state.overlays,n=0;n<r.length;++n){var i=r[n].modeSpec;if(i==e||"string"==typeof e&&i.name==e)return r.splice(n,1),t.state.modeGen++,void vn(t)}}),indentLine:pn(function(e,t,r){"string"!=typeof t&&"number"!=typeof t&&(t=null==t?this.options.smartIndent?"smart":"prev":t?"add":"subtract"),H(this.doc,e)&&Yo(this,e,t,r)}),indentSelection:pn(function(e){for(var t=this,r=this.doc.sel.ranges,n=-1,i=0;i<r.length;i++){var o=r[i];if(o.empty())o.head.line>n&&(Yo(t,o.head.line,e,!0),n=o.head.line,i==t.doc.sel.primIndex&&jr(t));else{var l=o.from(),s=o.to(),a=Math.max(n,l.line);n=Math.min(t.lastLine(),s.line-(s.ch?0:1))+1;for(var u=a;u<n;++u)Yo(t,u,e);var c=t.doc.sel.ranges;0==l.ch&&r.length==c.length&&c[i].from().ch>0&&gi(t.doc,i,new Ts(l,c[i].to()),Gl)}}}),getTokenAt:function(e,t){return Je(this,e,t)},getLineTokens:function(e,t){return Je(this,E(e),t,!0)},getTokenTypeAt:function(e){e=U(this.doc,e);var t,r=_e(this,M(this.doc,e.line)),n=0,i=(r.length-1)/2,o=e.ch;if(0==o)t=r[2];else for(;;){var l=n+i>>1;if((l?r[2*l-1]:0)>=o)i=l;else{if(!(r[2*l+1]<o)){t=r[2*l+2];break}n=l+1}}var s=t?t.indexOf("overlay "):-1;return s<0?t:0==s?null:t.slice(0,s-1)},getModeAt:function(t){var r=this.doc.mode;return r.innerMode?e.innerMode(r,this.getTokenAt(t).state).mode:r},getHelper:function(e,t){return this.getHelpers(e,t)[0]},getHelpers:function(e,t){var n=this,i=[];if(!r.hasOwnProperty(t))return i;var o=r[t],l=this.getModeAt(e);if("string"==typeof l[t])o[l[t]]&&i.push(o[l[t]]);else if(l[t])for(var s=0;s<l[t].length;s++){var a=o[l[t][s]];a&&i.push(a)}else l.helperType&&o[l.helperType]?i.push(o[l.helperType]):o[l.name]&&i.push(o[l.name]);for(var u=0;u<o._global.length;u++){var c=o._global[u];c.pred(l,n)&&-1==h(i,c.val)&&i.push(c.val)}return i},getStateAfter:function(e,t){var r=this.doc;return e=G(r,null==e?r.first+r.size-1:e),$e(this,e+1,t).state},cursorCoords:function(e,t){var r,n=this.doc.sel.primary();return r=null==e?n.head:"object"==typeof e?U(this.doc,e):e?n.from():n.to(),sr(this,r,t||"page")},charCoords:function(e,t){return lr(this,U(this.doc,e),t||"page")},coordsChar:function(e,t){return e=or(this,e,t||"page"),cr(this,e.left,e.top)},lineAtHeight:function(e,t){return e=or(this,{top:e,left:0},t||"page").top,D(this.doc,e+this.display.viewOffset)},heightAtLine:function(e,t,r){var n,i=!1;if("number"==typeof e){var o=this.doc.first+this.doc.size-1;e<this.doc.first?e=this.doc.first:e>o&&(e=o,i=!0),n=M(this.doc,e)}else n=e;return ir(this,n,{top:0,left:0},t||"page",r||i).top+(i?this.doc.height-ye(n):0)},defaultTextHeight:function(){return mr(this.display)},defaultCharWidth:function(){return yr(this.display)},getViewport:function(){return{from:this.display.viewFrom,to:this.display.viewTo}},addWidget:function(e,t,r,n,i){var o=this.display,l=(e=sr(this,U(this.doc,e))).bottom,s=e.left;if(t.style.position="absolute",t.setAttribute("cm-ignore-events","true"),this.display.input.setUneditable(t),o.sizer.appendChild(t),"over"==n)l=e.top;else if("above"==n||"near"==n){var a=Math.max(o.wrapper.clientHeight,this.doc.height),u=Math.max(o.sizer.clientWidth,o.lineSpace.clientWidth);("above"==n||e.bottom+t.offsetHeight>a)&&e.top>t.offsetHeight?l=e.top-t.offsetHeight:e.bottom+t.offsetHeight<=a&&(l=e.bottom),s+t.offsetWidth>u&&(s=u-t.offsetWidth)}t.style.top=l+"px",t.style.left=t.style.right="","right"==i?(s=o.sizer.clientWidth-t.offsetWidth,t.style.right="0px"):("left"==i?s=0:"middle"==i&&(s=(o.sizer.clientWidth-t.offsetWidth)/2),t.style.left=s+"px"),r&&Ur(this,{left:s,top:l,right:s+t.offsetWidth,bottom:l+t.offsetHeight})},triggerOnKeyDown:pn(Lo),triggerOnKeyPress:pn(Mo),triggerOnKeyUp:To,triggerOnMouseDown:pn(Oo),execCommand:function(e){if(Bs.hasOwnProperty(e))return Bs[e].call(null,this)},triggerElectric:pn(function(e){Zo(this,e)}),findPosH:function(e,t,r,n){var i=this,o=1;t<0&&(o=-1,t=-t);for(var l=U(this.doc,e),s=0;s<t&&!(l=tl(i.doc,l,o,r,n)).hitSide;++s);return l},moveH:pn(function(e,t){var r=this;this.extendSelectionsBy(function(n){return r.display.shift||r.doc.extend||n.empty()?tl(r.doc,n.head,e,t,r.options.rtlMoveVisually):e<0?n.from():n.to()},Vl)}),deleteH:pn(function(e,t){var r=this.doc.sel,n=this.doc;r.somethingSelected()?n.replaceSelection("",null,"+delete"):co(this,function(r){var i=tl(n,r.head,e,t,!1);return e<0?{from:i,to:r.head}:{from:r.head,to:i}})}),findPosV:function(e,t,r,n){var i=this,o=1,l=n;t<0&&(o=-1,t=-t);for(var s=U(this.doc,e),a=0;a<t;++a){var u=sr(i,s,"div");if(null==l?l=u.left:u.left=l,(s=rl(i,u,o,r)).hitSide)break}return s},moveV:pn(function(e,t){var r=this,n=this.doc,i=[],o=!this.display.shift&&!n.extend&&n.sel.somethingSelected();if(n.extendSelectionsBy(function(l){if(o)return e<0?l.from():l.to();var s=sr(r,l.head,"div");null!=l.goalColumn&&(s.left=l.goalColumn),i.push(s.left);var a=rl(r,s,e,t);return"page"==t&&l==n.sel.primary()&&Kr(r,lr(r,a,"div").top-s.top),a},Vl),i.length)for(var l=0;l<n.sel.ranges.length;l++)n.sel.ranges[l].goalColumn=i[l]}),findWordAt:function(e){var t=M(this.doc,e.line).text,r=e.ch,n=e.ch;if(t){var i=this.getHelper(e,"wordChars");"before"!=e.sticky&&n!=t.length||!r?++n:--r;for(var o=t.charAt(r),l=x(o,i)?function(e){return x(e,i)}:/\s/.test(o)?function(e){return/\s/.test(e)}:function(e){return!/\s/.test(e)&&!x(e)};r>0&&l(t.charAt(r-1));)--r;for(;n<t.length&&l(t.charAt(n));)++n}return new Ts(E(e.line,r),E(e.line,n))},toggleOverwrite:function(e){null!=e&&e==this.state.overwrite||((this.state.overwrite=!this.state.overwrite)?s(this.display.cursorDiv,"CodeMirror-overwrite"):Fl(this.display.cursorDiv,"CodeMirror-overwrite"),Te(this,"overwriteToggle",this,this.state.overwrite))},hasFocus:function(){return this.display.input.getField()==l()},isReadOnly:function(){return!(!this.options.readOnly&&!this.doc.cantEdit)},scrollTo:pn(function(e,t){Xr(this,e,t)}),getScrollInfo:function(){var e=this.display.scroller;return{left:e.scrollLeft,top:e.scrollTop,height:e.scrollHeight-zt(this)-this.display.barHeight,width:e.scrollWidth-zt(this)-this.display.barWidth,clientHeight:Bt(this),clientWidth:Rt(this)}},scrollIntoView:pn(function(e,t){null==e?(e={from:this.doc.sel.primary().head,to:null},null==t&&(t=this.options.cursorScrollMargin)):"number"==typeof e?e={from:E(e,0),to:null}:null==e.from&&(e={from:e,to:null}),e.to||(e.to=e.from),e.margin=t||0,null!=e.from.line?Yr(this,e):$r(this,e.from,e.to,e.margin)}),setSize:pn(function(e,t){var r=this,n=function(e){return"number"==typeof e||/^\d+$/.test(String(e))?e+"px":e};null!=e&&(this.display.wrapper.style.width=n(e)),null!=t&&(this.display.wrapper.style.height=n(t)),this.options.lineWrapping&&Jt(this);var i=this.display.viewFrom;this.doc.iter(i,this.display.viewTo,function(e){if(e.widgets)for(var t=0;t<e.widgets.length;t++)if(e.widgets[t].noHScroll){mn(r,i,"widget");break}++i}),this.curOp.forceUpdate=!0,Te(this,"refresh",this)}),operation:function(e){return hn(this,e)},startOperation:function(){return nn(this)},endOperation:function(){return on(this)},refresh:pn(function(){var e=this.display.cachedTextHeight;vn(this),this.curOp.forceUpdate=!0,er(this),Xr(this,this.doc.scrollLeft,this.doc.scrollTop),Wn(this),(null==e||Math.abs(e-mr(this.display))>.5)&&Cr(this),Te(this,"refresh",this)}),swapDoc:pn(function(e){var t=this.doc;return t.cm=null,qn(this,e),er(this),this.display.input.reset(),Xr(this,e.scrollLeft,e.scrollTop),this.curOp.forceScroll=!0,bt(this,"swapDoc",this,t),t}),getInputField:function(){return this.display.input.getField()},getWrapperElement:function(){return this.display.wrapper},getScrollerElement:function(){return this.display.scroller},getGutterElement:function(){return this.display.gutters}},Ae(e),e.registerHelper=function(t,n,i){r.hasOwnProperty(t)||(r[t]=e[t]={_global:[]}),r[t][n]=i},e.registerGlobalHelper=function(t,n,i,o){e.registerHelper(t,n,o),r[t]._global.push({pred:i,val:o})}}(jo);var Js="iter insert remove copy getEditor constructor".split(" ");for(var ea in Ds.prototype)Ds.prototype.hasOwnProperty(ea)&&h(Js,ea)<0&&(jo.prototype[ea]=function(e){return function(){return e.apply(this.doc,arguments)}}(Ds.prototype[ea]));return Ae(Ds),jo.inputStyles={textarea:Qs,contenteditable:Zs},jo.defineMode=function(e){jo.defaults.mode||"null"==e||(jo.defaults.mode=e),Be.apply(this,arguments)},jo.defineMIME=function(e,t){os[e]=t},jo.defineMode("null",function(){return{token:function(e){return e.skipToEnd()}}}),jo.defineMIME("text/plain","null"),jo.defineExtension=function(e,t){jo.prototype[e]=t},jo.defineDocExtension=function(e,t){Ds.prototype[e]=t},jo.fromTextArea=function(e,t){function r(){e.value=a.getValue()}if(t=t?c(t):{},t.value=e.value,!t.tabindex&&e.tabIndex&&(t.tabindex=e.tabIndex),!t.placeholder&&e.placeholder&&(t.placeholder=e.placeholder),null==t.autofocus){var n=l();t.autofocus=n==e||null!=e.getAttribute("autofocus")&&n==document.body}var i;if(e.form&&(Ql(e.form,"submit",r),!t.leaveSubmitMethodAlone)){var o=e.form;i=o.submit;try{var s=o.submit=function(){r(),o.submit=i,o.submit(),o.submit=s}}catch(e){}}t.finishInit=function(t){t.save=r,t.getTextArea=function(){return e},t.toTextArea=function(){t.toTextArea=isNaN,r(),e.parentNode.removeChild(t.getWrapperElement()),e.style.display="",e.form&&(ke(e.form,"submit",r),"function"==typeof e.form.submit&&(e.form.submit=i))}},e.style.display="none";var a=jo(function(t){return e.parentNode.insertBefore(t,e.nextSibling)},t);return a},function(e){e.off=ke,e.on=Ql,e.wheelEventPixels=Pn,e.Doc=Ds,e.splitLines=es,e.countColumn=f,e.findColumn=d,e.isWordChar=w,e.Pass=Bl,e.signal=Te,e.Line=fs,e.changeEnd=Bn,e.scrollbarModel=ws,e.Pos=E,e.cmpPos=P,e.modes=is,e.mimeModes=os,e.resolveMode=Ge,e.getMode=Ue,e.modeExtensions=ls,e.extendMode=Ve,e.copyState=Ke,e.startState=Xe,e.innerMode=je,e.commands=Bs,e.keyMap=Rs,e.keyName=ao,e.isModifierKey=lo,e.lookupKey=oo,e.normalizeKeyMap=io,e.StringStream=ss,e.SharedTextMarker=As,e.TextMarker=Os,e.LineWidget=Ms,e.e_preventDefault=We,e.e_stopPropagation=De,e.e_stop=Fe,e.addClass=s,e.contains=o,e.rmClass=Fl,e.keyNames=Es}(jo),jo.version="5.30.0",jo});
      !function(e){"object"==typeof exports&&"object"==typeof module?e(require("../../lib/codemirror")):"function"==typeof define&&define.amd?define(["../../lib/codemirror"],e):e(CodeMirror)}(function(e){"use strict";function t(e,t,n,r,o,a){this.indented=e,this.column=t,this.type=n,this.info=r,this.align=o,this.prev=a}function n(e,n,r,o){var a=e.indented;return e.context&&"statement"==e.context.type&&"statement"!=r&&(a=e.context.indented),e.context=new t(a,n,r,o,null,e.context)}function r(e){var t=e.context.type;return")"!=t&&"]"!=t&&"}"!=t||(e.indented=e.context.indented),e.context=e.context.prev}function o(e,t,n){return"variable"==t.prevToken||"type"==t.prevToken||(!!/\S(?:[^- ]>|[*\]])\s*$|\*$/.test(e.string.slice(0,n))||(!(!t.typeAtEndOfLine||e.column()!=e.indentation())||void 0))}function a(e){for(;;){if(!e||"top"==e.type)return!0;if("}"==e.type&&"namespace"!=e.prev.info)return!1;e=e.prev}}function i(e){for(var t={},n=e.split(" "),r=0;r<n.length;++r)t[n[r]]=!0;return t}function l(e,t){return"function"==typeof e?e(t):e.propertyIsEnumerable(t)}function s(e,t){if(!t.startOfLine)return!1;for(var n,r=null;n=e.peek();){if("\\"==n&&e.match(/^.$/)){r=s;break}if("/"==n&&e.match(/^\/[\/\*]/,!1))break;e.next()}return t.tokenize=r,"meta"}function c(e,t){return"type"==t.prevToken&&"type"}function u(e){return e.eatWhile(/[\w\.']/),"number"}function d(e,t){if(e.backUp(1),e.match(/(R|u8R|uR|UR|LR)/)){var n=e.match(/"([^\s\\()]{0,16})\(/);return!!n&&(t.cpp11RawStringDelim=n[1],t.tokenize=m,m(e,t))}return e.match(/(u8|u|U|L)/)?!!e.match(/["']/,!1)&&"string":(e.next(),!1)}function f(e){var t=/(\w+)::~?(\w+)$/.exec(e);return t&&t[1]==t[2]}function p(e,t){for(var n;null!=(n=e.next());)if('"'==n&&!e.eat('"')){t.tokenize=null;break}return"string"}function m(e,t){var n=t.cpp11RawStringDelim.replace(/[^\w\s]/g,"\\$&");return e.match(new RegExp(".*?\\)"+n+'"'))?t.tokenize=null:e.skipToEnd(),"string"}function h(t,n){function r(e){if(e)for(var t in e)e.hasOwnProperty(t)&&o.push(t)}"string"==typeof t&&(t=[t]);var o=[];r(n.keywords),r(n.types),r(n.builtin),r(n.atoms),o.length&&(n.helperType=t[0],e.registerHelper("hintWords",t[0],o));for(var a=0;a<t.length;++a)e.defineMIME(t[a],n)}function g(e,t){for(var n=!1;!e.eol();){if(!n&&e.match('"""')){t.tokenize=null;break}n="\\"==e.next()&&!n}return"string"}function y(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!e&&!o&&t.match('"')){a=!0;break}if(e&&t.match('"""')){a=!0;break}r=t.next(),!o&&"$"==r&&t.match("{")&&t.skipTo("}"),o=!o&&"\\"==r&&!e}return!a&&e||(n.tokenize=null),"string"}}function x(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!o&&t.match('"')&&("single"==e||t.match('""'))){a=!0;break}if(!o&&t.match("``")){w=x(e),a=!0;break}r=t.next(),o="single"==e&&!o&&"\\"==r}return a&&(n.tokenize=null),"string"}}e.defineMode("clike",function(i,s){function c(e,t){var n=e.next();if(S[n]){var r=S[n](e,t);if(!1!==r)return r}if('"'==n||"'"==n)return t.tokenize=u(n),t.tokenize(e,t);if(D.test(n))return p=n,null;if(L.test(n)){if(e.backUp(1),e.match(I))return"number";e.next()}if("/"==n){if(e.eat("*"))return t.tokenize=d,d(e,t);if(e.eat("/"))return e.skipToEnd(),"comment"}if(F.test(n)){for(;!e.match(/^\/[\/*]/,!1)&&e.eat(F););return"operator"}if(e.eatWhile(z),P)for(;e.match(P);)e.eatWhile(z);var o=e.current();return l(x,o)?(l(w,o)&&(p="newstatement"),l(v,o)&&(m=!0),"keyword"):l(b,o)?"type":l(k,o)?(l(w,o)&&(p="newstatement"),"builtin"):l(_,o)?"atom":"variable"}function u(e){return function(t,n){for(var r,o=!1,a=!1;null!=(r=t.next());){if(r==e&&!o){a=!0;break}o=!o&&"\\"==r}return(a||!o&&!C)&&(n.tokenize=null),"string"}}function d(e,t){for(var n,r=!1;n=e.next();){if("/"==n&&r){t.tokenize=null;break}r="*"==n}return"comment"}function f(e,t){s.typeFirstDefinitions&&e.eol()&&a(t.context)&&(t.typeAtEndOfLine=o(e,t,e.pos))}var p,m,h=i.indentUnit,g=s.statementIndentUnit||h,y=s.dontAlignCalls,x=s.keywords||{},b=s.types||{},k=s.builtin||{},w=s.blockKeywords||{},v=s.defKeywords||{},_=s.atoms||{},S=s.hooks||{},C=s.multiLineStrings,T=!1!==s.indentStatements,M=!1!==s.indentSwitch,P=s.namespaceSeparator,D=s.isPunctuationChar||/[\[\]{}\(\),;\:\.]/,L=s.numberStart||/[\d\.]/,I=s.number||/^(?:0x[a-f\d]+|0b[01]+|(?:\d+\.?\d*|\.\d+)(?:e[-+]?\d+)?)(u|ll?|l|f)?/i,F=s.isOperatorChar||/[+\-*&%=<>!?|\/]/,z=s.isIdentifierChar||/[\w\$_\xa1-\uffff]/;return{startState:function(e){return{tokenize:null,context:new t((e||0)-h,0,"top",null,!1),indented:0,startOfLine:!0,prevToken:null}},token:function(e,t){var i=t.context;if(e.sol()&&(null==i.align&&(i.align=!1),t.indented=e.indentation(),t.startOfLine=!0),e.eatSpace())return f(e,t),null;p=m=null;var l=(t.tokenize||c)(e,t);if("comment"==l||"meta"==l)return l;if(null==i.align&&(i.align=!0),";"==p||":"==p||","==p&&e.match(/^\s*(?:\/\/.*)?$/,!1))for(;"statement"==t.context.type;)r(t);else if("{"==p)n(t,e.column(),"}");else if("["==p)n(t,e.column(),"]");else if("("==p)n(t,e.column(),")");else if("}"==p){for(;"statement"==i.type;)i=r(t);for("}"==i.type&&(i=r(t));"statement"==i.type;)i=r(t)}else p==i.type?r(t):T&&(("}"==i.type||"top"==i.type)&&";"!=p||"statement"==i.type&&"newstatement"==p)&&n(t,e.column(),"statement",e.current());if("variable"==l&&("def"==t.prevToken||s.typeFirstDefinitions&&o(e,t,e.start)&&a(t.context)&&e.match(/^\s*\(/,!1))&&(l="def"),S.token){var u=S.token(e,t,l);void 0!==u&&(l=u)}return"def"==l&&!1===s.styleDefs&&(l="variable"),t.startOfLine=!1,t.prevToken=m?"def":l||p,f(e,t),l},indent:function(t,n){if(t.tokenize!=c&&null!=t.tokenize||t.typeAtEndOfLine)return e.Pass;var r=t.context,o=n&&n.charAt(0);if("statement"==r.type&&"}"==o&&(r=r.prev),s.dontIndentStatements)for(;"statement"==r.type&&s.dontIndentStatements.test(r.info);)r=r.prev;if(S.indent){var a=S.indent(t,r,n);if("number"==typeof a)return a}var i=o==r.type,l=r.prev&&"switch"==r.prev.info;if(s.allmanIndentation&&/[{(]/.test(o)){for(;"top"!=r.type&&"}"!=r.type;)r=r.prev;return r.indented}return"statement"==r.type?r.indented+("{"==o?0:g):!r.align||y&&")"==r.type?")"!=r.type||i?r.indented+(i?0:h)+(i||!l||/^(?:case|default)\b/.test(n)?0:h):r.indented+g:r.column+(i?0:1)},electricInput:M?/^\s*(?:case .*?:|default:|\{\}?|\})$/:/^\s*[{}]$/,blockCommentStart:"/*",blockCommentEnd:"*/",lineComment:"//",fold:"brace"}});var b="auto if break case register continue return default do sizeof static else struct switch extern typedef union for goto while enum const volatile",k="int long char short double float unsigned signed void size_t ptrdiff_t";h(["text/x-csrc","text/x-c","text/x-chdr"],{name:"clike",keywords:i(b),types:i(k+" bool _Complex _Bool float_t double_t intptr_t intmax_t int8_t int16_t int32_t int64_t uintptr_t uintmax_t uint8_t uint16_t uint32_t uint64_t"),blockKeywords:i("case do else for if switch while struct"),defKeywords:i("struct"),typeFirstDefinitions:!0,atoms:i("null true false"),hooks:{"#":s,"*":c},modeProps:{fold:["brace","include"]}}),h(["text/x-c++src","text/x-c++hdr"],{name:"clike",keywords:i(b+" asm dynamic_cast namespace reinterpret_cast try explicit new static_cast typeid catch operator template typename class friend private this using const_cast inline public throw virtual delete mutable protected alignas alignof constexpr decltype nullptr noexcept thread_local final static_assert override"),types:i(k+" bool wchar_t"),blockKeywords:i("catch class do else finally for if struct switch try while"),defKeywords:i("class namespace struct enum union"),typeFirstDefinitions:!0,atoms:i("true false null"),dontIndentStatements:/^template$/,isIdentifierChar:/[\w\$_~\xa1-\uffff]/,hooks:{"#":s,"*":c,u:d,U:d,L:d,R:d,0:u,1:u,2:u,3:u,4:u,5:u,6:u,7:u,8:u,9:u,token:function(e,t,n){if("variable"==n&&"("==e.peek()&&(";"==t.prevToken||null==t.prevToken||"}"==t.prevToken)&&f(e.current()))return"def"}},namespaceSeparator:"::",modeProps:{fold:["brace","include"]}}),h("text/x-java",{name:"clike",keywords:i("abstract assert break case catch class const continue default do else enum extends final finally float for goto if implements import instanceof interface native new package private protected public return static strictfp super switch synchronized this throw throws transient try volatile while @interface"),types:i("byte short int long float double boolean char void Boolean Byte Character Double Float Integer Long Number Object Short String StringBuffer StringBuilder Void"),blockKeywords:i("catch class do else finally for if switch try while"),defKeywords:i("class interface package enum @interface"),typeFirstDefinitions:!0,atoms:i("true false null"),number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,hooks:{"@":function(e){return!e.match("interface",!1)&&(e.eatWhile(/[\w\$_]/),"meta")}},modeProps:{fold:["brace","import"]}}),h("text/x-csharp",{name:"clike",keywords:i("abstract as async await base break case catch checked class const continue default delegate do else enum event explicit extern finally fixed for foreach goto if implicit in interface internal is lock namespace new operator out override params private protected public readonly ref return sealed sizeof stackalloc static struct switch this throw try typeof unchecked unsafe using virtual void volatile while add alias ascending descending dynamic from get global group into join let orderby partial remove select set value var yield"),types:i("Action Boolean Byte Char DateTime DateTimeOffset Decimal Double Func Guid Int16 Int32 Int64 Object SByte Single String Task TimeSpan UInt16 UInt32 UInt64 bool byte char decimal double short int long object sbyte float string ushort uint ulong"),blockKeywords:i("catch class do else finally for foreach if struct switch try while"),defKeywords:i("class interface namespace struct var"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"@":function(e,t){return e.eat('"')?(t.tokenize=p,p(e,t)):(e.eatWhile(/[\w\$_]/),"meta")}}}),h("text/x-scala",{name:"clike",keywords:i("abstract case catch class def do else extends final finally for forSome if implicit import lazy match new null object override package private protected return sealed super this throw trait try type val var while with yield _ assert assume require print println printf readLine readBoolean readByte readShort readChar readInt readLong readFloat readDouble"),types:i("AnyVal App Application Array BufferedIterator BigDecimal BigInt Char Console Either Enumeration Equiv Error Exception Fractional Function IndexedSeq Int Integral Iterable Iterator List Map Numeric Nil NotNull Option Ordered Ordering PartialFunction PartialOrdering Product Proxy Range Responder Seq Serializable Set Specializable Stream StringBuilder StringContext Symbol Throwable Traversable TraversableOnce Tuple Unit Vector Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),multiLineStrings:!0,blockKeywords:i("catch class enum do else finally for forSome if match switch try while"),defKeywords:i("class enum def object package trait type val var"),atoms:i("true false null"),indentStatements:!1,indentSwitch:!1,isOperatorChar:/[+\-*&%=<>!?|\/#:@]/,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return!!e.match('""')&&(t.tokenize=g,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},"=":function(e,n){var r=n.context;return!("}"!=r.type||!r.align||!e.eat(">"))&&(n.context=new t(r.indented,r.column,r.type,r.info,null,r.prev),"operator")}},modeProps:{closeBrackets:{triples:'"'}}}),h("text/x-kotlin",{name:"clike",keywords:i("package as typealias class interface this super val var fun for is in This throw return break continue object if else while do try when !in !is as? file import where by get set abstract enum open inner override private public internal protected catch finally out final vararg reified dynamic companion constructor init sealed field property receiver param sparam lateinit data inline noinline tailrec external annotation crossinline const operator infix suspend"),types:i("Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),intendSwitch:!1,indentStatements:!1,multiLineStrings:!0,number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,blockKeywords:i("catch class do else finally for if where try while enum"),defKeywords:i("class val var object package interface fun"),atoms:i("true false null this"),hooks:{'"':function(e,t){return t.tokenize=y(e.match('""')),t.tokenize(e,t)}},modeProps:{closeBrackets:{triples:'"'}}}),h(["x-shader/x-vertex","x-shader/x-fragment"],{name:"clike",keywords:i("sampler1D sampler2D sampler3D samplerCube sampler1DShadow sampler2DShadow const attribute uniform varying break continue discard return for while do if else struct in out inout"),types:i("float int bool void vec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4 mat2 mat3 mat4"),blockKeywords:i("for while do if else struct"),builtin:i("radians degrees sin cos tan asin acos atan pow exp log exp2 sqrt inversesqrt abs sign floor ceil fract mod min max clamp mix step smoothstep length distance dot cross normalize ftransform faceforward reflect refract matrixCompMult lessThan lessThanEqual greaterThan greaterThanEqual equal notEqual any all not texture1D texture1DProj texture1DLod texture1DProjLod texture2D texture2DProj texture2DLod texture2DProjLod texture3D texture3DProj texture3DLod texture3DProjLod textureCube textureCubeLod shadow1D shadow2D shadow1DProj shadow2DProj shadow1DLod shadow2DLod shadow1DProjLod shadow2DProjLod dFdx dFdy fwidth noise1 noise2 noise3 noise4"),atoms:i("true false gl_FragColor gl_SecondaryColor gl_Normal gl_Vertex gl_MultiTexCoord0 gl_MultiTexCoord1 gl_MultiTexCoord2 gl_MultiTexCoord3 gl_MultiTexCoord4 gl_MultiTexCoord5 gl_MultiTexCoord6 gl_MultiTexCoord7 gl_FogCoord gl_PointCoord gl_Position gl_PointSize gl_ClipVertex gl_FrontColor gl_BackColor gl_FrontSecondaryColor gl_BackSecondaryColor gl_TexCoord gl_FogFragCoord gl_FragCoord gl_FrontFacing gl_FragData gl_FragDepth gl_ModelViewMatrix gl_ProjectionMatrix gl_ModelViewProjectionMatrix gl_TextureMatrix gl_NormalMatrix gl_ModelViewMatrixInverse gl_ProjectionMatrixInverse gl_ModelViewProjectionMatrixInverse gl_TexureMatrixTranspose gl_ModelViewMatrixInverseTranspose gl_ProjectionMatrixInverseTranspose gl_ModelViewProjectionMatrixInverseTranspose gl_TextureMatrixInverseTranspose gl_NormalScale gl_DepthRange gl_ClipPlane gl_Point gl_FrontMaterial gl_BackMaterial gl_LightSource gl_LightModel gl_FrontLightModelProduct gl_BackLightModelProduct gl_TextureColor gl_EyePlaneS gl_EyePlaneT gl_EyePlaneR gl_EyePlaneQ gl_FogParameters gl_MaxLights gl_MaxClipPlanes gl_MaxTextureUnits gl_MaxTextureCoords gl_MaxVertexAttribs gl_MaxVertexUniformComponents gl_MaxVaryingFloats gl_MaxVertexTextureImageUnits gl_MaxTextureImageUnits gl_MaxFragmentUniformComponents gl_MaxCombineTextureImageUnits gl_MaxDrawBuffers"),indentSwitch:!1,hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-nesc",{name:"clike",keywords:i(b+"as atomic async call command component components configuration event generic implementation includes interface module new norace nx_struct nx_union post provides signal task uses abstract extends"),types:i(k),blockKeywords:i("case do else for if switch while struct"),atoms:i("null true false"),hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-objectivec",{name:"clike",keywords:i(b+"inline restrict _Bool _Complex _Imaginary BOOL Class bycopy byref id IMP in inout nil oneway out Protocol SEL self super atomic nonatomic retain copy readwrite readonly"),types:i(k),atoms:i("YES NO NULL NILL ON OFF true false"),hooks:{"@":function(e){return e.eatWhile(/[\w\$]/),"keyword"},"#":s,indent:function(e,t,n){if("statement"==t.type&&/^@\w/.test(n))return t.indented}},modeProps:{fold:"brace"}}),h("text/x-squirrel",{name:"clike",keywords:i("base break clone continue const default delete enum extends function in class foreach local resume return this throw typeof yield constructor instanceof static"),types:i(k),blockKeywords:i("case catch class else for foreach if switch try while"),defKeywords:i("function local class"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"#":s},modeProps:{fold:["brace","include"]}});var w=null;h("text/x-ceylon",{name:"clike",keywords:i("abstracts alias assembly assert assign break case catch class continue dynamic else exists extends finally for function given if import in interface is let module new nonempty object of out outer package return satisfies super switch then this throw try value void while"),types:function(e){var t=e.charAt(0);return t===t.toUpperCase()&&t!==t.toLowerCase()},blockKeywords:i("case catch class dynamic else finally for function if interface module new object switch try while"),defKeywords:i("class dynamic function interface module object package value"),builtin:i("abstract actual aliased annotation by default deprecated doc final formal late license native optional sealed see serializable shared suppressWarnings tagged throws variable"),isPunctuationChar:/[\[\]{}\(\),;\:\.`]/,isOperatorChar:/[+\-*&%=<>!?|^~:\/]/,numberStart:/[\d#$]/,number:/^(?:#[\da-fA-F_]+|\$[01_]+|[\d_]+[kMGTPmunpf]?|[\d_]+\.[\d_]+(?:[eE][-+]?\d+|[kMGTPmunpf]|)|)/i,multiLineStrings:!0,typeFirstDefinitions:!0,atoms:i("true false null larger smaller equal empty finished"),indentSwitch:!1,styleDefs:!1,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return t.tokenize=x(e.match('""')?"triple":"single"),t.tokenize(e,t)},"`":function(e,t){return!(!w||!e.match("`"))&&(t.tokenize=w,w=null,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},token:function(e,t,n){if(("variable"==n||"type"==n)&&"."==t.prevToken)return"variable-2"}},modeProps:{fold:["brace","import"],closeBrackets:{triples:'"'}}})});
      // -------------------------------------------------------------------------
//  Part of the CodeChecker project, under the Apache License v2.0 with
//  LLVM Exceptions. See LICENSE for license information.
//  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
// -------------------------------------------------------------------------

var BugViewer = {
  _files : [],
  _reports : [],
  _lineWidgets : [],
  _navigationMenuItems : [],
  _sourceFileData : null,
  _currentReport : null,
  _lastBugEvent  : null,

  init : function (files, reports) {
    this._files = files;
    this._reports = reports;

    this.initEscapeChars();
  },

  initEscapeChars : function () {
    this.escapeChars = {
      ' ' : 'nbsp',
      '<' : 'lt',
      '>' : 'gt',
      '"' : 'quot',
      '&' : 'amp'
    };

    var regexString = '[';
    for (var key in this.escapeChars) {
      regexString += key;
    }
    regexString += ']';

    this.escapeRegExp = new RegExp( regexString, 'g');
  },

  escapeHTML : function (str) {
    var that = this;

    return str.replace(this.escapeRegExp, function (m) {
      return '&' + that.escapeChars[m] + ';';
    });
  },

  initByUrl : function () {
    if (!this._reports) return;

    var state = {};
    window.location.hash.substr(1).split('&').forEach(function (s) {
      var parts = s.split('=');
      state[parts[0]] = parts[1];
    });

    for (var key in this._reports) {
      var report = this._reports[key];
      if (report.reportHash === state['reportHash']) {
        this.navigate(report);
        return;
      }
    }

    this.navigate(this._reports[0]);
  },

  create : function () {
    this._content = document.getElementById('editor-wrapper');
    this._filepath = document.getElementById('file-path');
    this._checkerName = document.getElementById('checker-name');
    this._reviewStatusWrapper =
      document.getElementById('review-status-wrapper');
    this._reviewStatus = document.getElementById('review-status');
    this._editor = document.getElementById('editor');

    this._codeMirror = CodeMirror(this._editor, {
      mode: 'text/x-c++src',
      matchBrackets : true,
      lineNumbers : true,
      readOnly : true,
      foldGutter : true,
      extraKeys : {},
      viewportMargin : 100
    });

    this._createNavigationMenu();
  },

  navigate : function (report, item) {
    if (!item) {
      var items = this._navigationMenuItems.filter(function (navItem) {
        return navItem.report.reportHash === report.reportHash;
      });

      if (!items.length) return;

      item = items[0].widget;
    }

    this._selectedReport.classList.remove('active');
    this._selectedReport = item;
    this._selectedReport.classList.add('active');
    this.setReport(report);
  },

  _createNavigationMenu : function () {
    var that = this;

    var nav = document.getElementById('report-nav');
    var list = document.createElement('ul');
    this._reports.forEach(function (report) {
      var events = report['events'];
      var lastBugEvent = events[events.length - 1];
      var item = document.createElement('li');

      var severity = document.createElement('i');
      severity.className = 'severity-' + report.severity.toLowerCase();

      item.appendChild(severity);
      item.appendChild(document.createTextNode(lastBugEvent.message));

      item.addEventListener('click', function () {
        that.navigate(report, item);
      })
      list.appendChild(item);
      that._navigationMenuItems.push({ report : report, widget : item });
    });

    if (!this._selectedReport && list.childNodes.length) {
      this._selectedReport = list.childNodes[0];
      this._selectedReport.classList.add('active');
    }

    nav.appendChild(list);
  },

  setReport : function (report) {
    this._currentReport = report;
    var events = report['events'];
    var lastBugEvent = events[events.length - 1];
    this.setCurrentBugEvent(lastBugEvent, events.length - 1);
    this.setCheckerName(report.checkerName);
    this.setReviewStatus(report.reviewStatus);

    window.location.hash = '#reportHash=' + report.reportHash;
  },

  setCurrentBugEvent : function (event, idx) {
    this._currentBugEvent = event;
    this.setSourceFileData(this._files[event.location.file]);
    this.drawBugPath();

    this.jumpTo(event.location.line, 0);
    this.highlightBugEvent(event, idx);
  },

  highlightBugEvent : function (event, idx) {
    this._lineWidgets.forEach(function (widget) {
      var lineIdx = widget.node.getAttribute('idx');
      if (parseInt(lineIdx) === idx) {
        widget.node.classList.add('current');
      }
    });
  },

  setCheckerName : function (checkerName) {
    this._checkerName.innerHTML = checkerName;
  },

  setReviewStatus : function (status) {
    if (status) {
      var className =
        'review-status-' + status.toLowerCase().split(' ').join('-');
      this._reviewStatus.className = "review-status " + className;

      this._reviewStatus.innerHTML = status;
      this._reviewStatusWrapper.style.display = 'block';
    } else {
      this._reviewStatusWrapper.style.display = 'none';
    }
  },

  setSourceFileData : function (file) {
    if (this._sourceFileData && file.id === this._sourceFileData.id) {
      return;
    }

    this._sourceFileData = file;
    this._filepath.innerHTML = file.path;
    this._codeMirror.doc.setValue(file.content);
    this._refresh();
  },

  _refresh : function () {
    var that = this;
    setTimeout(function () {
      var fullHeight = parseInt(that._content.clientHeight);
      var headerHeight = that._filepath.clientHeight;

      that._codeMirror.setSize('auto', fullHeight - headerHeight);
      that._codeMirror.refresh();
    }, 200);
  },

  clearBubbles : function () {
    this._lineWidgets.forEach(function (widget) { widget.clear(); });
    this._lineWidgets = [];
  },

  getMessage : function (event, kind) {
    if (kind === 'macro') {
      var name = 'macro expansion' + (event.name ? ': ' + event.name : '');

      return '<span class="tag macro">' + name + '</span>'
        + this.escapeHTML(event.expansion).replace(/(?:\r\n|\r|\n)/g, '<br>');
    } else if (kind === 'note') {
      return '<span class="tag note">note</span>'
        +  this.escapeHTML(event.message).replace(/(?:\r\n|\r|\n)/g, '<br>');
    }
  },

  addExtraPathEvents : function (events, kind) {
    var that = this;

    if (!events) {
      return;
    }

    events.forEach(function (event) {
      if (event.location.file !== that._currentBugEvent.location.file) {
        return;
      }

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + kind);

      var msg = document.createElement('span');
      msg.innerHTML = that.getMessage(event, kind);
      element.appendChild(msg);

      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  drawBugPath : function () {
    var that = this;

    this.clearBubbles();

    this.addExtraPathEvents(this._currentReport.macros, 'macro');
    this.addExtraPathEvents(this._currentReport.notes, 'note');

    // Processing bug path events.
    var currentEvents = this._currentReport.events;
    currentEvents.forEach(function (event, step) {
      if (event.location.file !== that._currentBugEvent.location.file)
        return;

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';
      var type = step === currentEvents.length - 1 ? 'error' : 'info';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + type);
      element.setAttribute('idx', step);

      var enumeration = document.createElement('span');
      enumeration.setAttribute('class', 'checker-enum ' + type);
      enumeration.innerHTML = step + 1;

      if (currentEvents.length > 1)
        element.appendChild(enumeration);

      var prevBugEvent = step - 1;
      if (step > 0) {
        var prevBug = document.createElement('span');
        prevBug.setAttribute('class', 'arrow left-arrow');
        prevBug.addEventListener('click', function () {
          var event = currentEvents[prevBugEvent];
          that.setCurrentBugEvent(event, prevBugEvent);
        });
        element.appendChild(prevBug);
      }

      var msg = document.createElement('span');
      msg.innerHTML = that.escapeHTML(event.message)
        .replace(/(?:\r\n|\r|\n)/g, '<br>');

      element.appendChild(msg);

      var nextBugEvent = step + 1;
      if (nextBugEvent < currentEvents.length) {
        var nextBug = document.createElement('span');
        nextBug.setAttribute('class', 'arrow right-arrow');
        nextBug.addEventListener('click', function () {
          var event = currentEvents[nextBugEvent];
          that.setCurrentBugEvent(event, nextBugEvent);
        });
        element.appendChild(nextBug);
      }


      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  jumpTo : function (line, column) {
    var that = this;

    setTimeout(function () {
      var selPosPixel
        = that._codeMirror.charCoords({ line : line, ch : column }, 'local');
      var editorSize = {
        width  : that._editor.clientWidth,
        height : that._editor.clientHeight
      };

      that._codeMirror.scrollIntoView({
        top    : selPosPixel.top - 100,
        bottom : selPosPixel.top + editorSize.height - 150,
        left   : selPosPixel.left < editorSize.width - 100
               ? 0
               : selPosPixel.left - 50,
        right  : selPosPixel.left < editorSize.width - 100
               ? 10
               : selPosPixel.left + editorSize.width - 100
      });
    }, 0);
  }
}


      var data = {"files": {"30": {"id": 30, "path": "/home/vsts/work/1/llvm-project/lldb/source/Plugins/ObjectFile/Mach-O/ObjectFileMachO.cpp", "content": "//===-- ObjectFileMachO.cpp -----------------------------------------------===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#include \"llvm/ADT/StringRef.h\"\n\n#include \"Plugins/Process/Utility/RegisterContextDarwin_arm.h\"\n#include \"Plugins/Process/Utility/RegisterContextDarwin_arm64.h\"\n#include \"Plugins/Process/Utility/RegisterContextDarwin_i386.h\"\n#include \"Plugins/Process/Utility/RegisterContextDarwin_x86_64.h\"\n#include \"lldb/Core/Debugger.h\"\n#include \"lldb/Core/FileSpecList.h\"\n#include \"lldb/Core/Module.h\"\n#include \"lldb/Core/ModuleSpec.h\"\n#include \"lldb/Core/PluginManager.h\"\n#include \"lldb/Core/Section.h\"\n#include \"lldb/Core/StreamFile.h\"\n#include \"lldb/Host/Host.h\"\n#include \"lldb/Symbol/DWARFCallFrameInfo.h\"\n#include \"lldb/Symbol/ObjectFile.h\"\n#include \"lldb/Target/DynamicLoader.h\"\n#include \"lldb/Target/MemoryRegionInfo.h\"\n#include \"lldb/Target/Platform.h\"\n#include \"lldb/Target/Process.h\"\n#include \"lldb/Target/SectionLoadList.h\"\n#include \"lldb/Target/Target.h\"\n#include \"lldb/Target/Thread.h\"\n#include \"lldb/Target/ThreadList.h\"\n#include \"lldb/Utility/ArchSpec.h\"\n#include \"lldb/Utility/DataBuffer.h\"\n#include \"lldb/Utility/FileSpec.h\"\n#include \"lldb/Utility/Log.h\"\n#include \"lldb/Utility/RangeMap.h\"\n#include \"lldb/Utility/RegisterValue.h\"\n#include \"lldb/Utility/Status.h\"\n#include \"lldb/Utility/StreamString.h\"\n#include \"lldb/Utility/Timer.h\"\n#include \"lldb/Utility/UUID.h\"\n\n#include \"lldb/Host/SafeMachO.h\"\n\n#include \"llvm/Support/MemoryBuffer.h\"\n\n#include \"ObjectFileMachO.h\"\n\n#if defined(__APPLE__)\n#include <TargetConditionals.h>\n// GetLLDBSharedCacheUUID() needs to call dlsym()\n#include <dlfcn.h>\n#endif\n\n#ifndef __APPLE__\n#include \"Utility/UuidCompatibility.h\"\n#else\n#include <uuid/uuid.h>\n#endif\n\n#include <memory>\n\n#define THUMB_ADDRESS_BIT_MASK 0xfffffffffffffffeull\nusing namespace lldb;\nusing namespace lldb_private;\nusing namespace llvm::MachO;\n\nLLDB_PLUGIN_DEFINE(ObjectFileMachO)\n\n// Some structure definitions needed for parsing the dyld shared cache files\n// found on iOS devices.\n\nstruct lldb_copy_dyld_cache_header_v1 {\n  char magic[16];         // e.g. \"dyld_v0    i386\", \"dyld_v1   armv7\", etc.\n  uint32_t mappingOffset; // file offset to first dyld_cache_mapping_info\n  uint32_t mappingCount;  // number of dyld_cache_mapping_info entries\n  uint32_t imagesOffset;\n  uint32_t imagesCount;\n  uint64_t dyldBaseAddress;\n  uint64_t codeSignatureOffset;\n  uint64_t codeSignatureSize;\n  uint64_t slideInfoOffset;\n  uint64_t slideInfoSize;\n  uint64_t localSymbolsOffset;\n  uint64_t localSymbolsSize;\n  uint8_t uuid[16]; // v1 and above, also recorded in dyld_all_image_infos v13\n                    // and later\n};\n\nstruct lldb_copy_dyld_cache_mapping_info {\n  uint64_t address;\n  uint64_t size;\n  uint64_t fileOffset;\n  uint32_t maxProt;\n  uint32_t initProt;\n};\n\nstruct lldb_copy_dyld_cache_local_symbols_info {\n  uint32_t nlistOffset;\n  uint32_t nlistCount;\n  uint32_t stringsOffset;\n  uint32_t stringsSize;\n  uint32_t entriesOffset;\n  uint32_t entriesCount;\n};\nstruct lldb_copy_dyld_cache_local_symbols_entry {\n  uint32_t dylibOffset;\n  uint32_t nlistStartIndex;\n  uint32_t nlistCount;\n};\n\nstatic void PrintRegisterValue(RegisterContext *reg_ctx, const char *name,\n                               const char *alt_name, size_t reg_byte_size,\n                               Stream &data) {\n  const RegisterInfo *reg_info = reg_ctx->GetRegisterInfoByName(name);\n  if (reg_info == nullptr)\n    reg_info = reg_ctx->GetRegisterInfoByName(alt_name);\n  if (reg_info) {\n    lldb_private::RegisterValue reg_value;\n    if (reg_ctx->ReadRegister(reg_info, reg_value)) {\n      if (reg_info->byte_size >= reg_byte_size)\n        data.Write(reg_value.GetBytes(), reg_byte_size);\n      else {\n        data.Write(reg_value.GetBytes(), reg_info->byte_size);\n        for (size_t i = 0, n = reg_byte_size - reg_info->byte_size; i < n; ++i)\n          data.PutChar(0);\n      }\n      return;\n    }\n  }\n  // Just write zeros if all else fails\n  for (size_t i = 0; i < reg_byte_size; ++i)\n    data.PutChar(0);\n}\n\nclass RegisterContextDarwin_x86_64_Mach : public RegisterContextDarwin_x86_64 {\npublic:\n  RegisterContextDarwin_x86_64_Mach(lldb_private::Thread &thread,\n                                    const DataExtractor &data)\n      : RegisterContextDarwin_x86_64(thread, 0) {\n    SetRegisterDataFrom_LC_THREAD(data);\n  }\n\n  void InvalidateAllRegisters() override {\n    // Do nothing... registers are always valid...\n  }\n\n  void SetRegisterDataFrom_LC_THREAD(const DataExtractor &data) {\n    lldb::offset_t offset = 0;\n    SetError(GPRRegSet, Read, -1);\n    SetError(FPURegSet, Read, -1);\n    SetError(EXCRegSet, Read, -1);\n    bool done = false;\n\n    while (!done) {\n      int flavor = data.GetU32(&offset);\n      if (flavor == 0)\n        done = true;\n      else {\n        uint32_t i;\n        uint32_t count = data.GetU32(&offset);\n        switch (flavor) {\n        case GPRRegSet:\n          for (i = 0; i < count; ++i)\n            (&gpr.rax)[i] = data.GetU64(&offset);\n          SetError(GPRRegSet, Read, 0);\n          done = true;\n\n          break;\n        case FPURegSet:\n          // TODO: fill in FPU regs....\n          // SetError (FPURegSet, Read, -1);\n          done = true;\n\n          break;\n        case EXCRegSet:\n          exc.trapno = data.GetU32(&offset);\n          exc.err = data.GetU32(&offset);\n          exc.faultvaddr = data.GetU64(&offset);\n          SetError(EXCRegSet, Read, 0);\n          done = true;\n          break;\n        case 7:\n        case 8:\n        case 9:\n          // fancy flavors that encapsulate of the above flavors...\n          break;\n\n        default:\n          done = true;\n          break;\n        }\n      }\n    }\n  }\n\n  static bool Create_LC_THREAD(Thread *thread, Stream &data) {\n    RegisterContextSP reg_ctx_sp(thread->GetRegisterContext());\n    if (reg_ctx_sp) {\n      RegisterContext *reg_ctx = reg_ctx_sp.get();\n\n      data.PutHex32(GPRRegSet); // Flavor\n      data.PutHex32(GPRWordCount);\n      PrintRegisterValue(reg_ctx, \"rax\", nullptr, 8, data);\n      PrintRegisterValue(reg_ctx, \"rbx\", nullptr, 8, data);\n      PrintRegisterValue(reg_ctx, \"rcx\", nullptr, 8, data);\n      PrintRegisterValue(reg_ctx, \"rdx\", nullptr, 8, data);\n      PrintRegisterValue(reg_ctx, \"rdi\", nullptr, 8, data);\n      PrintRegisterValue(reg_ctx, \"rsi\", nullptr, 8, data);\n      PrintRegisterValue(reg_ctx, \"rbp\", nullptr, 8, data);\n      PrintRegisterValue(reg_ctx, \"rsp\", nullptr, 8, data);\n      PrintRegisterValue(reg_ctx, \"r8\", nullptr, 8, data);\n      PrintRegisterValue(reg_ctx, \"r9\", nullptr, 8, data);\n      PrintRegisterValue(reg_ctx, \"r10\", nullptr, 8, data);\n      PrintRegisterValue(reg_ctx, \"r11\", nullptr, 8, data);\n      PrintRegisterValue(reg_ctx, \"r12\", nullptr, 8, data);\n      PrintRegisterValue(reg_ctx, \"r13\", nullptr, 8, data);\n      PrintRegisterValue(reg_ctx, \"r14\", nullptr, 8, data);\n      PrintRegisterValue(reg_ctx, \"r15\", nullptr, 8, data);\n      PrintRegisterValue(reg_ctx, \"rip\", nullptr, 8, data);\n      PrintRegisterValue(reg_ctx, \"rflags\", nullptr, 8, data);\n      PrintRegisterValue(reg_ctx, \"cs\", nullptr, 8, data);\n      PrintRegisterValue(reg_ctx, \"fs\", nullptr, 8, data);\n      PrintRegisterValue(reg_ctx, \"gs\", nullptr, 8, data);\n\n      //            // Write out the FPU registers\n      //            const size_t fpu_byte_size = sizeof(FPU);\n      //            size_t bytes_written = 0;\n      //            data.PutHex32 (FPURegSet);\n      //            data.PutHex32 (fpu_byte_size/sizeof(uint64_t));\n      //            bytes_written += data.PutHex32(0); // uint32_t pad[0]\n      //            bytes_written += data.PutHex32(0); // uint32_t pad[1]\n      //            bytes_written += WriteRegister (reg_ctx, \"fcw\", \"fctrl\", 2,\n      //            data);   // uint16_t    fcw;    // \"fctrl\"\n      //            bytes_written += WriteRegister (reg_ctx, \"fsw\" , \"fstat\", 2,\n      //            data);  // uint16_t    fsw;    // \"fstat\"\n      //            bytes_written += WriteRegister (reg_ctx, \"ftw\" , \"ftag\", 1,\n      //            data);   // uint8_t     ftw;    // \"ftag\"\n      //            bytes_written += data.PutHex8  (0); // uint8_t pad1;\n      //            bytes_written += WriteRegister (reg_ctx, \"fop\" , NULL, 2,\n      //            data);     // uint16_t    fop;    // \"fop\"\n      //            bytes_written += WriteRegister (reg_ctx, \"fioff\", \"ip\", 4,\n      //            data);    // uint32_t    ip;     // \"fioff\"\n      //            bytes_written += WriteRegister (reg_ctx, \"fiseg\", NULL, 2,\n      //            data);    // uint16_t    cs;     // \"fiseg\"\n      //            bytes_written += data.PutHex16 (0); // uint16_t    pad2;\n      //            bytes_written += WriteRegister (reg_ctx, \"dp\", \"fooff\" , 4,\n      //            data);   // uint32_t    dp;     // \"fooff\"\n      //            bytes_written += WriteRegister (reg_ctx, \"foseg\", NULL, 2,\n      //            data);    // uint16_t    ds;     // \"foseg\"\n      //            bytes_written += data.PutHex16 (0); // uint16_t    pad3;\n      //            bytes_written += WriteRegister (reg_ctx, \"mxcsr\", NULL, 4,\n      //            data);    // uint32_t    mxcsr;\n      //            bytes_written += WriteRegister (reg_ctx, \"mxcsrmask\", NULL,\n      //            4, data);// uint32_t    mxcsrmask;\n      //            bytes_written += WriteRegister (reg_ctx, \"stmm0\", NULL,\n      //            sizeof(MMSReg), data);\n      //            bytes_written += WriteRegister (reg_ctx, \"stmm1\", NULL,\n      //            sizeof(MMSReg), data);\n      //            bytes_written += WriteRegister (reg_ctx, \"stmm2\", NULL,\n      //            sizeof(MMSReg), data);\n      //            bytes_written += WriteRegister (reg_ctx, \"stmm3\", NULL,\n      //            sizeof(MMSReg), data);\n      //            bytes_written += WriteRegister (reg_ctx, \"stmm4\", NULL,\n      //            sizeof(MMSReg), data);\n      //            bytes_written += WriteRegister (reg_ctx, \"stmm5\", NULL,\n      //            sizeof(MMSReg), data);\n      //            bytes_written += WriteRegister (reg_ctx, \"stmm6\", NULL,\n      //            sizeof(MMSReg), data);\n      //            bytes_written += WriteRegister (reg_ctx, \"stmm7\", NULL,\n      //            sizeof(MMSReg), data);\n      //            bytes_written += WriteRegister (reg_ctx, \"xmm0\" , NULL,\n      //            sizeof(XMMReg), data);\n      //            bytes_written += WriteRegister (reg_ctx, \"xmm1\" , NULL,\n      //            sizeof(XMMReg), data);\n      //            bytes_written += WriteRegister (reg_ctx, \"xmm2\" , NULL,\n      //            sizeof(XMMReg), data);\n      //            bytes_written += WriteRegister (reg_ctx, \"xmm3\" , NULL,\n      //            sizeof(XMMReg), data);\n      //            bytes_written += WriteRegister (reg_ctx, \"xmm4\" , NULL,\n      //            sizeof(XMMReg), data);\n      //            bytes_written += WriteRegister (reg_ctx, \"xmm5\" , NULL,\n      //            sizeof(XMMReg), data);\n      //            bytes_written += WriteRegister (reg_ctx, \"xmm6\" , NULL,\n      //            sizeof(XMMReg), data);\n      //            bytes_written += WriteRegister (reg_ctx, \"xmm7\" , NULL,\n      //            sizeof(XMMReg), data);\n      //            bytes_written += WriteRegister (reg_ctx, \"xmm8\" , NULL,\n      //            sizeof(XMMReg), data);\n      //            bytes_written += WriteRegister (reg_ctx, \"xmm9\" , NULL,\n      //            sizeof(XMMReg), data);\n      //            bytes_written += WriteRegister (reg_ctx, \"xmm10\", NULL,\n      //            sizeof(XMMReg), data);\n      //            bytes_written += WriteRegister (reg_ctx, \"xmm11\", NULL,\n      //            sizeof(XMMReg), data);\n      //            bytes_written += WriteRegister (reg_ctx, \"xmm12\", NULL,\n      //            sizeof(XMMReg), data);\n      //            bytes_written += WriteRegister (reg_ctx, \"xmm13\", NULL,\n      //            sizeof(XMMReg), data);\n      //            bytes_written += WriteRegister (reg_ctx, \"xmm14\", NULL,\n      //            sizeof(XMMReg), data);\n      //            bytes_written += WriteRegister (reg_ctx, \"xmm15\", NULL,\n      //            sizeof(XMMReg), data);\n      //\n      //            // Fill rest with zeros\n      //            for (size_t i=0, n = fpu_byte_size - bytes_written; i<n; ++\n      //            i)\n      //                data.PutChar(0);\n\n      // Write out the EXC registers\n      data.PutHex32(EXCRegSet);\n      data.PutHex32(EXCWordCount);\n      PrintRegisterValue(reg_ctx, \"trapno\", nullptr, 4, data);\n      PrintRegisterValue(reg_ctx, \"err\", nullptr, 4, data);\n      PrintRegisterValue(reg_ctx, \"faultvaddr\", nullptr, 8, data);\n      return true;\n    }\n    return false;\n  }\n\nprotected:\n  int DoReadGPR(lldb::tid_t tid, int flavor, GPR &gpr) override { return 0; }\n\n  int DoReadFPU(lldb::tid_t tid, int flavor, FPU &fpu) override { return 0; }\n\n  int DoReadEXC(lldb::tid_t tid, int flavor, EXC &exc) override { return 0; }\n\n  int DoWriteGPR(lldb::tid_t tid, int flavor, const GPR &gpr) override {\n    return 0;\n  }\n\n  int DoWriteFPU(lldb::tid_t tid, int flavor, const FPU &fpu) override {\n    return 0;\n  }\n\n  int DoWriteEXC(lldb::tid_t tid, int flavor, const EXC &exc) override {\n    return 0;\n  }\n};\n\nclass RegisterContextDarwin_i386_Mach : public RegisterContextDarwin_i386 {\npublic:\n  RegisterContextDarwin_i386_Mach(lldb_private::Thread &thread,\n                                  const DataExtractor &data)\n      : RegisterContextDarwin_i386(thread, 0) {\n    SetRegisterDataFrom_LC_THREAD(data);\n  }\n\n  void InvalidateAllRegisters() override {\n    // Do nothing... registers are always valid...\n  }\n\n  void SetRegisterDataFrom_LC_THREAD(const DataExtractor &data) {\n    lldb::offset_t offset = 0;\n    SetError(GPRRegSet, Read, -1);\n    SetError(FPURegSet, Read, -1);\n    SetError(EXCRegSet, Read, -1);\n    bool done = false;\n\n    while (!done) {\n      int flavor = data.GetU32(&offset);\n      if (flavor == 0)\n        done = true;\n      else {\n        uint32_t i;\n        uint32_t count = data.GetU32(&offset);\n        switch (flavor) {\n        case GPRRegSet:\n          for (i = 0; i < count; ++i)\n            (&gpr.eax)[i] = data.GetU32(&offset);\n          SetError(GPRRegSet, Read, 0);\n          done = true;\n\n          break;\n        case FPURegSet:\n          // TODO: fill in FPU regs....\n          // SetError (FPURegSet, Read, -1);\n          done = true;\n\n          break;\n        case EXCRegSet:\n          exc.trapno = data.GetU32(&offset);\n          exc.err = data.GetU32(&offset);\n          exc.faultvaddr = data.GetU32(&offset);\n          SetError(EXCRegSet, Read, 0);\n          done = true;\n          break;\n        case 7:\n        case 8:\n        case 9:\n          // fancy flavors that encapsulate of the above flavors...\n          break;\n\n        default:\n          done = true;\n          break;\n        }\n      }\n    }\n  }\n\n  static bool Create_LC_THREAD(Thread *thread, Stream &data) {\n    RegisterContextSP reg_ctx_sp(thread->GetRegisterContext());\n    if (reg_ctx_sp) {\n      RegisterContext *reg_ctx = reg_ctx_sp.get();\n\n      data.PutHex32(GPRRegSet); // Flavor\n      data.PutHex32(GPRWordCount);\n      PrintRegisterValue(reg_ctx, \"eax\", nullptr, 4, data);\n      PrintRegisterValue(reg_ctx, \"ebx\", nullptr, 4, data);\n      PrintRegisterValue(reg_ctx, \"ecx\", nullptr, 4, data);\n      PrintRegisterValue(reg_ctx, \"edx\", nullptr, 4, data);\n      PrintRegisterValue(reg_ctx, \"edi\", nullptr, 4, data);\n      PrintRegisterValue(reg_ctx, \"esi\", nullptr, 4, data);\n      PrintRegisterValue(reg_ctx, \"ebp\", nullptr, 4, data);\n      PrintRegisterValue(reg_ctx, \"esp\", nullptr, 4, data);\n      PrintRegisterValue(reg_ctx, \"ss\", nullptr, 4, data);\n      PrintRegisterValue(reg_ctx, \"eflags\", nullptr, 4, data);\n      PrintRegisterValue(reg_ctx, \"eip\", nullptr, 4, data);\n      PrintRegisterValue(reg_ctx, \"cs\", nullptr, 4, data);\n      PrintRegisterValue(reg_ctx, \"ds\", nullptr, 4, data);\n      PrintRegisterValue(reg_ctx, \"es\", nullptr, 4, data);\n      PrintRegisterValue(reg_ctx, \"fs\", nullptr, 4, data);\n      PrintRegisterValue(reg_ctx, \"gs\", nullptr, 4, data);\n\n      // Write out the EXC registers\n      data.PutHex32(EXCRegSet);\n      data.PutHex32(EXCWordCount);\n      PrintRegisterValue(reg_ctx, \"trapno\", nullptr, 4, data);\n      PrintRegisterValue(reg_ctx, \"err\", nullptr, 4, data);\n      PrintRegisterValue(reg_ctx, \"faultvaddr\", nullptr, 4, data);\n      return true;\n    }\n    return false;\n  }\n\nprotected:\n  int DoReadGPR(lldb::tid_t tid, int flavor, GPR &gpr) override { return 0; }\n\n  int DoReadFPU(lldb::tid_t tid, int flavor, FPU &fpu) override { return 0; }\n\n  int DoReadEXC(lldb::tid_t tid, int flavor, EXC &exc) override { return 0; }\n\n  int DoWriteGPR(lldb::tid_t tid, int flavor, const GPR &gpr) override {\n    return 0;\n  }\n\n  int DoWriteFPU(lldb::tid_t tid, int flavor, const FPU &fpu) override {\n    return 0;\n  }\n\n  int DoWriteEXC(lldb::tid_t tid, int flavor, const EXC &exc) override {\n    return 0;\n  }\n};\n\nclass RegisterContextDarwin_arm_Mach : public RegisterContextDarwin_arm {\npublic:\n  RegisterContextDarwin_arm_Mach(lldb_private::Thread &thread,\n                                 const DataExtractor &data)\n      : RegisterContextDarwin_arm(thread, 0) {\n    SetRegisterDataFrom_LC_THREAD(data);\n  }\n\n  void InvalidateAllRegisters() override {\n    // Do nothing... registers are always valid...\n  }\n\n  void SetRegisterDataFrom_LC_THREAD(const DataExtractor &data) {\n    lldb::offset_t offset = 0;\n    SetError(GPRRegSet, Read, -1);\n    SetError(FPURegSet, Read, -1);\n    SetError(EXCRegSet, Read, -1);\n    bool done = false;\n\n    while (!done) {\n      int flavor = data.GetU32(&offset);\n      uint32_t count = data.GetU32(&offset);\n      lldb::offset_t next_thread_state = offset + (count * 4);\n      switch (flavor) {\n      case GPRAltRegSet:\n      case GPRRegSet:\n        // On ARM, the CPSR register is also included in the count but it is\n        // not included in gpr.r so loop until (count-1).\n        for (uint32_t i = 0; i < (count - 1); ++i) {\n          gpr.r[i] = data.GetU32(&offset);\n        }\n        // Save cpsr explicitly.\n        gpr.cpsr = data.GetU32(&offset);\n\n        SetError(GPRRegSet, Read, 0);\n        offset = next_thread_state;\n        break;\n\n      case FPURegSet: {\n        uint8_t *fpu_reg_buf = (uint8_t *)&fpu.floats.s[0];\n        const int fpu_reg_buf_size = sizeof(fpu.floats);\n        if (data.ExtractBytes(offset, fpu_reg_buf_size, eByteOrderLittle,\n                              fpu_reg_buf) == fpu_reg_buf_size) {\n          offset += fpu_reg_buf_size;\n          fpu.fpscr = data.GetU32(&offset);\n          SetError(FPURegSet, Read, 0);\n        } else {\n          done = true;\n        }\n      }\n        offset = next_thread_state;\n        break;\n\n      case EXCRegSet:\n        if (count == 3) {\n          exc.exception = data.GetU32(&offset);\n          exc.fsr = data.GetU32(&offset);\n          exc.far = data.GetU32(&offset);\n          SetError(EXCRegSet, Read, 0);\n        }\n        done = true;\n        offset = next_thread_state;\n        break;\n\n      // Unknown register set flavor, stop trying to parse.\n      default:\n        done = true;\n      }\n    }\n  }\n\n  static bool Create_LC_THREAD(Thread *thread, Stream &data) {\n    RegisterContextSP reg_ctx_sp(thread->GetRegisterContext());\n    if (reg_ctx_sp) {\n      RegisterContext *reg_ctx = reg_ctx_sp.get();\n\n      data.PutHex32(GPRRegSet); // Flavor\n      data.PutHex32(GPRWordCount);\n      PrintRegisterValue(reg_ctx, \"r0\", nullptr, 4, data);\n      PrintRegisterValue(reg_ctx, \"r1\", nullptr, 4, data);\n      PrintRegisterValue(reg_ctx, \"r2\", nullptr, 4, data);\n      PrintRegisterValue(reg_ctx, \"r3\", nullptr, 4, data);\n      PrintRegisterValue(reg_ctx, \"r4\", nullptr, 4, data);\n      PrintRegisterValue(reg_ctx, \"r5\", nullptr, 4, data);\n      PrintRegisterValue(reg_ctx, \"r6\", nullptr, 4, data);\n      PrintRegisterValue(reg_ctx, \"r7\", nullptr, 4, data);\n      PrintRegisterValue(reg_ctx, \"r8\", nullptr, 4, data);\n      PrintRegisterValue(reg_ctx, \"r9\", nullptr, 4, data);\n      PrintRegisterValue(reg_ctx, \"r10\", nullptr, 4, data);\n      PrintRegisterValue(reg_ctx, \"r11\", nullptr, 4, data);\n      PrintRegisterValue(reg_ctx, \"r12\", nullptr, 4, data);\n      PrintRegisterValue(reg_ctx, \"sp\", nullptr, 4, data);\n      PrintRegisterValue(reg_ctx, \"lr\", nullptr, 4, data);\n      PrintRegisterValue(reg_ctx, \"pc\", nullptr, 4, data);\n      PrintRegisterValue(reg_ctx, \"cpsr\", nullptr, 4, data);\n\n      // Write out the EXC registers\n      //            data.PutHex32 (EXCRegSet);\n      //            data.PutHex32 (EXCWordCount);\n      //            WriteRegister (reg_ctx, \"exception\", NULL, 4, data);\n      //            WriteRegister (reg_ctx, \"fsr\", NULL, 4, data);\n      //            WriteRegister (reg_ctx, \"far\", NULL, 4, data);\n      return true;\n    }\n    return false;\n  }\n\nprotected:\n  int DoReadGPR(lldb::tid_t tid, int flavor, GPR &gpr) override { return -1; }\n\n  int DoReadFPU(lldb::tid_t tid, int flavor, FPU &fpu) override { return -1; }\n\n  int DoReadEXC(lldb::tid_t tid, int flavor, EXC &exc) override { return -1; }\n\n  int DoReadDBG(lldb::tid_t tid, int flavor, DBG &dbg) override { return -1; }\n\n  int DoWriteGPR(lldb::tid_t tid, int flavor, const GPR &gpr) override {\n    return 0;\n  }\n\n  int DoWriteFPU(lldb::tid_t tid, int flavor, const FPU &fpu) override {\n    return 0;\n  }\n\n  int DoWriteEXC(lldb::tid_t tid, int flavor, const EXC &exc) override {\n    return 0;\n  }\n\n  int DoWriteDBG(lldb::tid_t tid, int flavor, const DBG &dbg) override {\n    return -1;\n  }\n};\n\nclass RegisterContextDarwin_arm64_Mach : public RegisterContextDarwin_arm64 {\npublic:\n  RegisterContextDarwin_arm64_Mach(lldb_private::Thread &thread,\n                                   const DataExtractor &data)\n      : RegisterContextDarwin_arm64(thread, 0) {\n    SetRegisterDataFrom_LC_THREAD(data);\n  }\n\n  void InvalidateAllRegisters() override {\n    // Do nothing... registers are always valid...\n  }\n\n  void SetRegisterDataFrom_LC_THREAD(const DataExtractor &data) {\n    lldb::offset_t offset = 0;\n    SetError(GPRRegSet, Read, -1);\n    SetError(FPURegSet, Read, -1);\n    SetError(EXCRegSet, Read, -1);\n    bool done = false;\n    while (!done) {\n      int flavor = data.GetU32(&offset);\n      uint32_t count = data.GetU32(&offset);\n      lldb::offset_t next_thread_state = offset + (count * 4);\n      switch (flavor) {\n      case GPRRegSet:\n        // x0-x29 + fp + lr + sp + pc (== 33 64-bit registers) plus cpsr (1\n        // 32-bit register)\n        if (count >= (33 * 2) + 1) {\n          for (uint32_t i = 0; i < 29; ++i)\n            gpr.x[i] = data.GetU64(&offset);\n          gpr.fp = data.GetU64(&offset);\n          gpr.lr = data.GetU64(&offset);\n          gpr.sp = data.GetU64(&offset);\n          gpr.pc = data.GetU64(&offset);\n          gpr.cpsr = data.GetU32(&offset);\n          SetError(GPRRegSet, Read, 0);\n        }\n        offset = next_thread_state;\n        break;\n      case FPURegSet: {\n        uint8_t *fpu_reg_buf = (uint8_t *)&fpu.v[0];\n        const int fpu_reg_buf_size = sizeof(fpu);\n        if (fpu_reg_buf_size == count * sizeof(uint32_t) &&\n            data.ExtractBytes(offset, fpu_reg_buf_size, eByteOrderLittle,\n                              fpu_reg_buf) == fpu_reg_buf_size) {\n          SetError(FPURegSet, Read, 0);\n        } else {\n          done = true;\n        }\n      }\n        offset = next_thread_state;\n        break;\n      case EXCRegSet:\n        if (count == 4) {\n          exc.far = data.GetU64(&offset);\n          exc.esr = data.GetU32(&offset);\n          exc.exception = data.GetU32(&offset);\n          SetError(EXCRegSet, Read, 0);\n        }\n        offset = next_thread_state;\n        break;\n      default:\n        done = true;\n        break;\n      }\n    }\n  }\n\n  static bool Create_LC_THREAD(Thread *thread, Stream &data) {\n    RegisterContextSP reg_ctx_sp(thread->GetRegisterContext());\n    if (reg_ctx_sp) {\n      RegisterContext *reg_ctx = reg_ctx_sp.get();\n\n      data.PutHex32(GPRRegSet); // Flavor\n      data.PutHex32(GPRWordCount);\n      PrintRegisterValue(reg_ctx, \"x0\", nullptr, 8, data);\n      PrintRegisterValue(reg_ctx, \"x1\", nullptr, 8, data);\n      PrintRegisterValue(reg_ctx, \"x2\", nullptr, 8, data);\n      PrintRegisterValue(reg_ctx, \"x3\", nullptr, 8, data);\n      PrintRegisterValue(reg_ctx, \"x4\", nullptr, 8, data);\n      PrintRegisterValue(reg_ctx, \"x5\", nullptr, 8, data);\n      PrintRegisterValue(reg_ctx, \"x6\", nullptr, 8, data);\n      PrintRegisterValue(reg_ctx, \"x7\", nullptr, 8, data);\n      PrintRegisterValue(reg_ctx, \"x8\", nullptr, 8, data);\n      PrintRegisterValue(reg_ctx, \"x9\", nullptr, 8, data);\n      PrintRegisterValue(reg_ctx, \"x10\", nullptr, 8, data);\n      PrintRegisterValue(reg_ctx, \"x11\", nullptr, 8, data);\n      PrintRegisterValue(reg_ctx, \"x12\", nullptr, 8, data);\n      PrintRegisterValue(reg_ctx, \"x13\", nullptr, 8, data);\n      PrintRegisterValue(reg_ctx, \"x14\", nullptr, 8, data);\n      PrintRegisterValue(reg_ctx, \"x15\", nullptr, 8, data);\n      PrintRegisterValue(reg_ctx, \"x16\", nullptr, 8, data);\n      PrintRegisterValue(reg_ctx, \"x17\", nullptr, 8, data);\n      PrintRegisterValue(reg_ctx, \"x18\", nullptr, 8, data);\n      PrintRegisterValue(reg_ctx, \"x19\", nullptr, 8, data);\n      PrintRegisterValue(reg_ctx, \"x20\", nullptr, 8, data);\n      PrintRegisterValue(reg_ctx, \"x21\", nullptr, 8, data);\n      PrintRegisterValue(reg_ctx, \"x22\", nullptr, 8, data);\n      PrintRegisterValue(reg_ctx, \"x23\", nullptr, 8, data);\n      PrintRegisterValue(reg_ctx, \"x24\", nullptr, 8, data);\n      PrintRegisterValue(reg_ctx, \"x25\", nullptr, 8, data);\n      PrintRegisterValue(reg_ctx, \"x26\", nullptr, 8, data);\n      PrintRegisterValue(reg_ctx, \"x27\", nullptr, 8, data);\n      PrintRegisterValue(reg_ctx, \"x28\", nullptr, 8, data);\n      PrintRegisterValue(reg_ctx, \"fp\", nullptr, 8, data);\n      PrintRegisterValue(reg_ctx, \"lr\", nullptr, 8, data);\n      PrintRegisterValue(reg_ctx, \"sp\", nullptr, 8, data);\n      PrintRegisterValue(reg_ctx, \"pc\", nullptr, 8, data);\n      PrintRegisterValue(reg_ctx, \"cpsr\", nullptr, 4, data);\n\n      // Write out the EXC registers\n      //            data.PutHex32 (EXCRegSet);\n      //            data.PutHex32 (EXCWordCount);\n      //            WriteRegister (reg_ctx, \"far\", NULL, 8, data);\n      //            WriteRegister (reg_ctx, \"esr\", NULL, 4, data);\n      //            WriteRegister (reg_ctx, \"exception\", NULL, 4, data);\n      return true;\n    }\n    return false;\n  }\n\nprotected:\n  int DoReadGPR(lldb::tid_t tid, int flavor, GPR &gpr) override { return -1; }\n\n  int DoReadFPU(lldb::tid_t tid, int flavor, FPU &fpu) override { return -1; }\n\n  int DoReadEXC(lldb::tid_t tid, int flavor, EXC &exc) override { return -1; }\n\n  int DoReadDBG(lldb::tid_t tid, int flavor, DBG &dbg) override { return -1; }\n\n  int DoWriteGPR(lldb::tid_t tid, int flavor, const GPR &gpr) override {\n    return 0;\n  }\n\n  int DoWriteFPU(lldb::tid_t tid, int flavor, const FPU &fpu) override {\n    return 0;\n  }\n\n  int DoWriteEXC(lldb::tid_t tid, int flavor, const EXC &exc) override {\n    return 0;\n  }\n\n  int DoWriteDBG(lldb::tid_t tid, int flavor, const DBG &dbg) override {\n    return -1;\n  }\n};\n\nstatic uint32_t MachHeaderSizeFromMagic(uint32_t magic) {\n  switch (magic) {\n  case MH_MAGIC:\n  case MH_CIGAM:\n    return sizeof(struct mach_header);\n\n  case MH_MAGIC_64:\n  case MH_CIGAM_64:\n    return sizeof(struct mach_header_64);\n    break;\n\n  default:\n    break;\n  }\n  return 0;\n}\n\n#define MACHO_NLIST_ARM_SYMBOL_IS_THUMB 0x0008\n\nchar ObjectFileMachO::ID;\n\nvoid ObjectFileMachO::Initialize() {\n  PluginManager::RegisterPlugin(\n      GetPluginNameStatic(), GetPluginDescriptionStatic(), CreateInstance,\n      CreateMemoryInstance, GetModuleSpecifications, SaveCore);\n}\n\nvoid ObjectFileMachO::Terminate() {\n  PluginManager::UnregisterPlugin(CreateInstance);\n}\n\nlldb_private::ConstString ObjectFileMachO::GetPluginNameStatic() {\n  static ConstString g_name(\"mach-o\");\n  return g_name;\n}\n\nconst char *ObjectFileMachO::GetPluginDescriptionStatic() {\n  return \"Mach-o object file reader (32 and 64 bit)\";\n}\n\nObjectFile *ObjectFileMachO::CreateInstance(const lldb::ModuleSP &module_sp,\n                                            DataBufferSP &data_sp,\n                                            lldb::offset_t data_offset,\n                                            const FileSpec *file,\n                                            lldb::offset_t file_offset,\n                                            lldb::offset_t length) {\n  if (!data_sp) {\n    data_sp = MapFileData(*file, length, file_offset);\n    if (!data_sp)\n      return nullptr;\n    data_offset = 0;\n  }\n\n  if (!ObjectFileMachO::MagicBytesMatch(data_sp, data_offset, length))\n    return nullptr;\n\n  // Update the data to contain the entire file if it doesn't already\n  if (data_sp->GetByteSize() < length) {\n    data_sp = MapFileData(*file, length, file_offset);\n    if (!data_sp)\n      return nullptr;\n    data_offset = 0;\n  }\n  auto objfile_up = std::make_unique<ObjectFileMachO>(\n      module_sp, data_sp, data_offset, file, file_offset, length);\n  if (!objfile_up || !objfile_up->ParseHeader())\n    return nullptr;\n\n  return objfile_up.release();\n}\n\nObjectFile *ObjectFileMachO::CreateMemoryInstance(\n    const lldb::ModuleSP &module_sp, DataBufferSP &data_sp,\n    const ProcessSP &process_sp, lldb::addr_t header_addr) {\n  if (ObjectFileMachO::MagicBytesMatch(data_sp, 0, data_sp->GetByteSize())) {\n    std::unique_ptr<ObjectFile> objfile_up(\n        new ObjectFileMachO(module_sp, data_sp, process_sp, header_addr));\n    if (objfile_up.get() && objfile_up->ParseHeader())\n      return objfile_up.release();\n  }\n  return nullptr;\n}\n\nsize_t ObjectFileMachO::GetModuleSpecifications(\n    const lldb_private::FileSpec &file, lldb::DataBufferSP &data_sp,\n    lldb::offset_t data_offset, lldb::offset_t file_offset,\n    lldb::offset_t length, lldb_private::ModuleSpecList &specs) {\n  const size_t initial_count = specs.GetSize();\n\n  if (ObjectFileMachO::MagicBytesMatch(data_sp, 0, data_sp->GetByteSize())) {\n    DataExtractor data;\n    data.SetData(data_sp);\n    llvm::MachO::mach_header header;\n    if (ParseHeader(data, &data_offset, header)) {\n      size_t header_and_load_cmds =\n          header.sizeofcmds + MachHeaderSizeFromMagic(header.magic);\n      if (header_and_load_cmds >= data_sp->GetByteSize()) {\n        data_sp = MapFileData(file, header_and_load_cmds, file_offset);\n        data.SetData(data_sp);\n        data_offset = MachHeaderSizeFromMagic(header.magic);\n      }\n      if (data_sp) {\n        ModuleSpec base_spec;\n        base_spec.GetFileSpec() = file;\n        base_spec.SetObjectOffset(file_offset);\n        base_spec.SetObjectSize(length);\n        GetAllArchSpecs(header, data, data_offset, base_spec, specs);\n      }\n    }\n  }\n  return specs.GetSize() - initial_count;\n}\n\nConstString ObjectFileMachO::GetSegmentNameTEXT() {\n  static ConstString g_segment_name_TEXT(\"__TEXT\");\n  return g_segment_name_TEXT;\n}\n\nConstString ObjectFileMachO::GetSegmentNameDATA() {\n  static ConstString g_segment_name_DATA(\"__DATA\");\n  return g_segment_name_DATA;\n}\n\nConstString ObjectFileMachO::GetSegmentNameDATA_DIRTY() {\n  static ConstString g_segment_name(\"__DATA_DIRTY\");\n  return g_segment_name;\n}\n\nConstString ObjectFileMachO::GetSegmentNameDATA_CONST() {\n  static ConstString g_segment_name(\"__DATA_CONST\");\n  return g_segment_name;\n}\n\nConstString ObjectFileMachO::GetSegmentNameOBJC() {\n  static ConstString g_segment_name_OBJC(\"__OBJC\");\n  return g_segment_name_OBJC;\n}\n\nConstString ObjectFileMachO::GetSegmentNameLINKEDIT() {\n  static ConstString g_section_name_LINKEDIT(\"__LINKEDIT\");\n  return g_section_name_LINKEDIT;\n}\n\nConstString ObjectFileMachO::GetSegmentNameDWARF() {\n  static ConstString g_section_name(\"__DWARF\");\n  return g_section_name;\n}\n\nConstString ObjectFileMachO::GetSectionNameEHFrame() {\n  static ConstString g_section_name_eh_frame(\"__eh_frame\");\n  return g_section_name_eh_frame;\n}\n\nbool ObjectFileMachO::MagicBytesMatch(DataBufferSP &data_sp,\n                                      lldb::addr_t data_offset,\n                                      lldb::addr_t data_length) {\n  DataExtractor data;\n  data.SetData(data_sp, data_offset, data_length);\n  lldb::offset_t offset = 0;\n  uint32_t magic = data.GetU32(&offset);\n  return MachHeaderSizeFromMagic(magic) != 0;\n}\n\nObjectFileMachO::ObjectFileMachO(const lldb::ModuleSP &module_sp,\n                                 DataBufferSP &data_sp,\n                                 lldb::offset_t data_offset,\n                                 const FileSpec *file,\n                                 lldb::offset_t file_offset,\n                                 lldb::offset_t length)\n    : ObjectFile(module_sp, file, file_offset, length, data_sp, data_offset),\n      m_mach_segments(), m_mach_sections(), m_entry_point_address(),\n      m_thread_context_offsets(), m_thread_context_offsets_valid(false),\n      m_reexported_dylibs(), m_allow_assembly_emulation_unwind_plans(true) {\n  ::memset(&m_header, 0, sizeof(m_header));\n  ::memset(&m_dysymtab, 0, sizeof(m_dysymtab));\n}\n\nObjectFileMachO::ObjectFileMachO(const lldb::ModuleSP &module_sp,\n                                 lldb::DataBufferSP &header_data_sp,\n                                 const lldb::ProcessSP &process_sp,\n                                 lldb::addr_t header_addr)\n    : ObjectFile(module_sp, process_sp, header_addr, header_data_sp),\n      m_mach_segments(), m_mach_sections(), m_entry_point_address(),\n      m_thread_context_offsets(), m_thread_context_offsets_valid(false),\n      m_reexported_dylibs(), m_allow_assembly_emulation_unwind_plans(true) {\n  ::memset(&m_header, 0, sizeof(m_header));\n  ::memset(&m_dysymtab, 0, sizeof(m_dysymtab));\n}\n\nbool ObjectFileMachO::ParseHeader(DataExtractor &data,\n                                  lldb::offset_t *data_offset_ptr,\n                                  llvm::MachO::mach_header &header) {\n  data.SetByteOrder(endian::InlHostByteOrder());\n  // Leave magic in the original byte order\n  header.magic = data.GetU32(data_offset_ptr);\n  bool can_parse = false;\n  bool is_64_bit = false;\n  switch (header.magic) {\n  case MH_MAGIC:\n    data.SetByteOrder(endian::InlHostByteOrder());\n    data.SetAddressByteSize(4);\n    can_parse = true;\n    break;\n\n  case MH_MAGIC_64:\n    data.SetByteOrder(endian::InlHostByteOrder());\n    data.SetAddressByteSize(8);\n    can_parse = true;\n    is_64_bit = true;\n    break;\n\n  case MH_CIGAM:\n    data.SetByteOrder(endian::InlHostByteOrder() == eByteOrderBig\n                          ? eByteOrderLittle\n                          : eByteOrderBig);\n    data.SetAddressByteSize(4);\n    can_parse = true;\n    break;\n\n  case MH_CIGAM_64:\n    data.SetByteOrder(endian::InlHostByteOrder() == eByteOrderBig\n                          ? eByteOrderLittle\n                          : eByteOrderBig);\n    data.SetAddressByteSize(8);\n    is_64_bit = true;\n    can_parse = true;\n    break;\n\n  default:\n    break;\n  }\n\n  if (can_parse) {\n    data.GetU32(data_offset_ptr, &header.cputype, 6);\n    if (is_64_bit)\n      *data_offset_ptr += 4;\n    return true;\n  } else {\n    memset(&header, 0, sizeof(header));\n  }\n  return false;\n}\n\nbool ObjectFileMachO::ParseHeader() {\n  ModuleSP module_sp(GetModule());\n  if (!module_sp)\n    return false;\n\n  std::lock_guard<std::recursive_mutex> guard(module_sp->GetMutex());\n  bool can_parse = false;\n  lldb::offset_t offset = 0;\n  m_data.SetByteOrder(endian::InlHostByteOrder());\n  // Leave magic in the original byte order\n  m_header.magic = m_data.GetU32(&offset);\n  switch (m_header.magic) {\n  case MH_MAGIC:\n    m_data.SetByteOrder(endian::InlHostByteOrder());\n    m_data.SetAddressByteSize(4);\n    can_parse = true;\n    break;\n\n  case MH_MAGIC_64:\n    m_data.SetByteOrder(endian::InlHostByteOrder());\n    m_data.SetAddressByteSize(8);\n    can_parse = true;\n    break;\n\n  case MH_CIGAM:\n    m_data.SetByteOrder(endian::InlHostByteOrder() == eByteOrderBig\n                            ? eByteOrderLittle\n                            : eByteOrderBig);\n    m_data.SetAddressByteSize(4);\n    can_parse = true;\n    break;\n\n  case MH_CIGAM_64:\n    m_data.SetByteOrder(endian::InlHostByteOrder() == eByteOrderBig\n                            ? eByteOrderLittle\n                            : eByteOrderBig);\n    m_data.SetAddressByteSize(8);\n    can_parse = true;\n    break;\n\n  default:\n    break;\n  }\n\n  if (can_parse) {\n    m_data.GetU32(&offset, &m_header.cputype, 6);\n\n    ModuleSpecList all_specs;\n    ModuleSpec base_spec;\n    GetAllArchSpecs(m_header, m_data, MachHeaderSizeFromMagic(m_header.magic),\n                    base_spec, all_specs);\n\n    for (unsigned i = 0, e = all_specs.GetSize(); i != e; ++i) {\n      ArchSpec mach_arch =\n          all_specs.GetModuleSpecRefAtIndex(i).GetArchitecture();\n\n      // Check if the module has a required architecture\n      const ArchSpec &module_arch = module_sp->GetArchitecture();\n      if (module_arch.IsValid() && !module_arch.IsCompatibleMatch(mach_arch))\n        continue;\n\n      if (SetModulesArchitecture(mach_arch)) {\n        const size_t header_and_lc_size =\n            m_header.sizeofcmds + MachHeaderSizeFromMagic(m_header.magic);\n        if (m_data.GetByteSize() < header_and_lc_size) {\n          DataBufferSP data_sp;\n          ProcessSP process_sp(m_process_wp.lock());\n          if (process_sp) {\n            data_sp = ReadMemory(process_sp, m_memory_addr, header_and_lc_size);\n          } else {\n            // Read in all only the load command data from the file on disk\n            data_sp = MapFileData(m_file, header_and_lc_size, m_file_offset);\n            if (data_sp->GetByteSize() != header_and_lc_size)\n              continue;\n          }\n          if (data_sp)\n            m_data.SetData(data_sp);\n        }\n      }\n      return true;\n    }\n    // None found.\n    return false;\n  } else {\n    memset(&m_header, 0, sizeof(struct mach_header));\n  }\n  return false;\n}\n\nByteOrder ObjectFileMachO::GetByteOrder() const {\n  return m_data.GetByteOrder();\n}\n\nbool ObjectFileMachO::IsExecutable() const {\n  return m_header.filetype == MH_EXECUTE;\n}\n\nbool ObjectFileMachO::IsDynamicLoader() const {\n  return m_header.filetype == MH_DYLINKER;\n}\n\nuint32_t ObjectFileMachO::GetAddressByteSize() const {\n  return m_data.GetAddressByteSize();\n}\n\nAddressClass ObjectFileMachO::GetAddressClass(lldb::addr_t file_addr) {\n  Symtab *symtab = GetSymtab();\n  if (!symtab)\n    return AddressClass::eUnknown;\n\n  Symbol *symbol = symtab->FindSymbolContainingFileAddress(file_addr);\n  if (symbol) {\n    if (symbol->ValueIsAddress()) {\n      SectionSP section_sp(symbol->GetAddressRef().GetSection());\n      if (section_sp) {\n        const lldb::SectionType section_type = section_sp->GetType();\n        switch (section_type) {\n        case eSectionTypeInvalid:\n          return AddressClass::eUnknown;\n\n        case eSectionTypeCode:\n          if (m_header.cputype == llvm::MachO::CPU_TYPE_ARM) {\n            // For ARM we have a bit in the n_desc field of the symbol that\n            // tells us ARM/Thumb which is bit 0x0008.\n            if (symbol->GetFlags() & MACHO_NLIST_ARM_SYMBOL_IS_THUMB)\n              return AddressClass::eCodeAlternateISA;\n          }\n          return AddressClass::eCode;\n\n        case eSectionTypeContainer:\n          return AddressClass::eUnknown;\n\n        case eSectionTypeData:\n        case eSectionTypeDataCString:\n        case eSectionTypeDataCStringPointers:\n        case eSectionTypeDataSymbolAddress:\n        case eSectionTypeData4:\n        case eSectionTypeData8:\n        case eSectionTypeData16:\n        case eSectionTypeDataPointers:\n        case eSectionTypeZeroFill:\n        case eSectionTypeDataObjCMessageRefs:\n        case eSectionTypeDataObjCCFStrings:\n        case eSectionTypeGoSymtab:\n          return AddressClass::eData;\n\n        case eSectionTypeDebug:\n        case eSectionTypeDWARFDebugAbbrev:\n        case eSectionTypeDWARFDebugAbbrevDwo:\n        case eSectionTypeDWARFDebugAddr:\n        case eSectionTypeDWARFDebugAranges:\n        case eSectionTypeDWARFDebugCuIndex:\n        case eSectionTypeDWARFDebugFrame:\n        case eSectionTypeDWARFDebugInfo:\n        case eSectionTypeDWARFDebugInfoDwo:\n        case eSectionTypeDWARFDebugLine:\n        case eSectionTypeDWARFDebugLineStr:\n        case eSectionTypeDWARFDebugLoc:\n        case eSectionTypeDWARFDebugLocDwo:\n        case eSectionTypeDWARFDebugLocLists:\n        case eSectionTypeDWARFDebugLocListsDwo:\n        case eSectionTypeDWARFDebugMacInfo:\n        case eSectionTypeDWARFDebugMacro:\n        case eSectionTypeDWARFDebugNames:\n        case eSectionTypeDWARFDebugPubNames:\n        case eSectionTypeDWARFDebugPubTypes:\n        case eSectionTypeDWARFDebugRanges:\n        case eSectionTypeDWARFDebugRngLists:\n        case eSectionTypeDWARFDebugRngListsDwo:\n        case eSectionTypeDWARFDebugStr:\n        case eSectionTypeDWARFDebugStrDwo:\n        case eSectionTypeDWARFDebugStrOffsets:\n        case eSectionTypeDWARFDebugStrOffsetsDwo:\n        case eSectionTypeDWARFDebugTuIndex:\n        case eSectionTypeDWARFDebugTypes:\n        case eSectionTypeDWARFDebugTypesDwo:\n        case eSectionTypeDWARFAppleNames:\n        case eSectionTypeDWARFAppleTypes:\n        case eSectionTypeDWARFAppleNamespaces:\n        case eSectionTypeDWARFAppleObjC:\n        case eSectionTypeDWARFGNUDebugAltLink:\n          return AddressClass::eDebug;\n\n        case eSectionTypeEHFrame:\n        case eSectionTypeARMexidx:\n        case eSectionTypeARMextab:\n        case eSectionTypeCompactUnwind:\n          return AddressClass::eRuntime;\n\n        case eSectionTypeAbsoluteAddress:\n        case eSectionTypeELFSymbolTable:\n        case eSectionTypeELFDynamicSymbols:\n        case eSectionTypeELFRelocationEntries:\n        case eSectionTypeELFDynamicLinkInfo:\n        case eSectionTypeOther:\n          return AddressClass::eUnknown;\n        }\n      }\n    }\n\n    const SymbolType symbol_type = symbol->GetType();\n    switch (symbol_type) {\n    case eSymbolTypeAny:\n      return AddressClass::eUnknown;\n    case eSymbolTypeAbsolute:\n      return AddressClass::eUnknown;\n\n    case eSymbolTypeCode:\n    case eSymbolTypeTrampoline:\n    case eSymbolTypeResolver:\n      if (m_header.cputype == llvm::MachO::CPU_TYPE_ARM) {\n        // For ARM we have a bit in the n_desc field of the symbol that tells\n        // us ARM/Thumb which is bit 0x0008.\n        if (symbol->GetFlags() & MACHO_NLIST_ARM_SYMBOL_IS_THUMB)\n          return AddressClass::eCodeAlternateISA;\n      }\n      return AddressClass::eCode;\n\n    case eSymbolTypeData:\n      return AddressClass::eData;\n    case eSymbolTypeRuntime:\n      return AddressClass::eRuntime;\n    case eSymbolTypeException:\n      return AddressClass::eRuntime;\n    case eSymbolTypeSourceFile:\n      return AddressClass::eDebug;\n    case eSymbolTypeHeaderFile:\n      return AddressClass::eDebug;\n    case eSymbolTypeObjectFile:\n      return AddressClass::eDebug;\n    case eSymbolTypeCommonBlock:\n      return AddressClass::eDebug;\n    case eSymbolTypeBlock:\n      return AddressClass::eDebug;\n    case eSymbolTypeLocal:\n      return AddressClass::eData;\n    case eSymbolTypeParam:\n      return AddressClass::eData;\n    case eSymbolTypeVariable:\n      return AddressClass::eData;\n    case eSymbolTypeVariableType:\n      return AddressClass::eDebug;\n    case eSymbolTypeLineEntry:\n      return AddressClass::eDebug;\n    case eSymbolTypeLineHeader:\n      return AddressClass::eDebug;\n    case eSymbolTypeScopeBegin:\n      return AddressClass::eDebug;\n    case eSymbolTypeScopeEnd:\n      return AddressClass::eDebug;\n    case eSymbolTypeAdditional:\n      return AddressClass::eUnknown;\n    case eSymbolTypeCompiler:\n      return AddressClass::eDebug;\n    case eSymbolTypeInstrumentation:\n      return AddressClass::eDebug;\n    case eSymbolTypeUndefined:\n      return AddressClass::eUnknown;\n    case eSymbolTypeObjCClass:\n      return AddressClass::eRuntime;\n    case eSymbolTypeObjCMetaClass:\n      return AddressClass::eRuntime;\n    case eSymbolTypeObjCIVar:\n      return AddressClass::eRuntime;\n    case eSymbolTypeReExported:\n      return AddressClass::eRuntime;\n    }\n  }\n  return AddressClass::eUnknown;\n}\n\nSymtab *ObjectFileMachO::GetSymtab() {\n  ModuleSP module_sp(GetModule());\n  if (module_sp) {\n    std::lock_guard<std::recursive_mutex> guard(module_sp->GetMutex());\n    if (m_symtab_up == nullptr) {\n      m_symtab_up = std::make_unique<Symtab>(this);\n      std::lock_guard<std::recursive_mutex> symtab_guard(\n          m_symtab_up->GetMutex());\n      ParseSymtab();\n      m_symtab_up->Finalize();\n    }\n  }\n  return m_symtab_up.get();\n}\n\nbool ObjectFileMachO::IsStripped() {\n  if (m_dysymtab.cmd == 0) {\n    ModuleSP module_sp(GetModule());\n    if (module_sp) {\n      lldb::offset_t offset = MachHeaderSizeFromMagic(m_header.magic);\n      for (uint32_t i = 0; i < m_header.ncmds; ++i) {\n        const lldb::offset_t load_cmd_offset = offset;\n\n        load_command lc;\n        if (m_data.GetU32(&offset, &lc.cmd, 2) == nullptr)\n          break;\n        if (lc.cmd == LC_DYSYMTAB) {\n          m_dysymtab.cmd = lc.cmd;\n          m_dysymtab.cmdsize = lc.cmdsize;\n          if (m_data.GetU32(&offset, &m_dysymtab.ilocalsym,\n                            (sizeof(m_dysymtab) / sizeof(uint32_t)) - 2) ==\n              nullptr) {\n            // Clear m_dysymtab if we were unable to read all items from the\n            // load command\n            ::memset(&m_dysymtab, 0, sizeof(m_dysymtab));\n          }\n        }\n        offset = load_cmd_offset + lc.cmdsize;\n      }\n    }\n  }\n  if (m_dysymtab.cmd)\n    return m_dysymtab.nlocalsym <= 1;\n  return false;\n}\n\nObjectFileMachO::EncryptedFileRanges ObjectFileMachO::GetEncryptedFileRanges() {\n  EncryptedFileRanges result;\n  lldb::offset_t offset = MachHeaderSizeFromMagic(m_header.magic);\n\n  encryption_info_command encryption_cmd;\n  for (uint32_t i = 0; i < m_header.ncmds; ++i) {\n    const lldb::offset_t load_cmd_offset = offset;\n    if (m_data.GetU32(&offset, &encryption_cmd, 2) == nullptr)\n      break;\n\n    // LC_ENCRYPTION_INFO and LC_ENCRYPTION_INFO_64 have the same sizes for the\n    // 3 fields we care about, so treat them the same.\n    if (encryption_cmd.cmd == LC_ENCRYPTION_INFO ||\n        encryption_cmd.cmd == LC_ENCRYPTION_INFO_64) {\n      if (m_data.GetU32(&offset, &encryption_cmd.cryptoff, 3)) {\n        if (encryption_cmd.cryptid != 0) {\n          EncryptedFileRanges::Entry entry;\n          entry.SetRangeBase(encryption_cmd.cryptoff);\n          entry.SetByteSize(encryption_cmd.cryptsize);\n          result.Append(entry);\n        }\n      }\n    }\n    offset = load_cmd_offset + encryption_cmd.cmdsize;\n  }\n\n  return result;\n}\n\nvoid ObjectFileMachO::SanitizeSegmentCommand(segment_command_64 &seg_cmd,\n                                             uint32_t cmd_idx) {\n  if (m_length == 0 || seg_cmd.filesize == 0)\n    return;\n\n  if ((m_header.flags & MH_DYLIB_IN_CACHE) && !IsInMemory()) {\n    // In shared cache images, the load commands are relative to the\n    // shared cache file, and not the the specific image we are\n    // examining. Let's fix this up so that it looks like a normal\n    // image.\n    if (strncmp(seg_cmd.segname, \"__TEXT\", sizeof(seg_cmd.segname)) == 0)\n      m_text_address = seg_cmd.vmaddr;\n    if (strncmp(seg_cmd.segname, \"__LINKEDIT\", sizeof(seg_cmd.segname)) == 0)\n      m_linkedit_original_offset = seg_cmd.fileoff;\n\n    seg_cmd.fileoff = seg_cmd.vmaddr - m_text_address;\n  }\n\n  if (seg_cmd.fileoff > m_length) {\n    // We have a load command that says it extends past the end of the file.\n    // This is likely a corrupt file.  We don't have any way to return an error\n    // condition here (this method was likely invoked from something like\n    // ObjectFile::GetSectionList()), so we just null out the section contents,\n    // and dump a message to stdout.  The most common case here is core file\n    // debugging with a truncated file.\n    const char *lc_segment_name =\n        seg_cmd.cmd == LC_SEGMENT_64 ? \"LC_SEGMENT_64\" : \"LC_SEGMENT\";\n    GetModule()->ReportWarning(\n        \"load command %u %s has a fileoff (0x%\" PRIx64\n        \") that extends beyond the end of the file (0x%\" PRIx64\n        \"), ignoring this section\",\n        cmd_idx, lc_segment_name, seg_cmd.fileoff, m_length);\n\n    seg_cmd.fileoff = 0;\n    seg_cmd.filesize = 0;\n  }\n\n  if (seg_cmd.fileoff + seg_cmd.filesize > m_length) {\n    // We have a load command that says it extends past the end of the file.\n    // This is likely a corrupt file.  We don't have any way to return an error\n    // condition here (this method was likely invoked from something like\n    // ObjectFile::GetSectionList()), so we just null out the section contents,\n    // and dump a message to stdout.  The most common case here is core file\n    // debugging with a truncated file.\n    const char *lc_segment_name =\n        seg_cmd.cmd == LC_SEGMENT_64 ? \"LC_SEGMENT_64\" : \"LC_SEGMENT\";\n    GetModule()->ReportWarning(\n        \"load command %u %s has a fileoff + filesize (0x%\" PRIx64\n        \") that extends beyond the end of the file (0x%\" PRIx64\n        \"), the segment will be truncated to match\",\n        cmd_idx, lc_segment_name, seg_cmd.fileoff + seg_cmd.filesize, m_length);\n\n    // Truncate the length\n    seg_cmd.filesize = m_length - seg_cmd.fileoff;\n  }\n}\n\nstatic uint32_t GetSegmentPermissions(const segment_command_64 &seg_cmd) {\n  uint32_t result = 0;\n  if (seg_cmd.initprot & VM_PROT_READ)\n    result |= ePermissionsReadable;\n  if (seg_cmd.initprot & VM_PROT_WRITE)\n    result |= ePermissionsWritable;\n  if (seg_cmd.initprot & VM_PROT_EXECUTE)\n    result |= ePermissionsExecutable;\n  return result;\n}\n\nstatic lldb::SectionType GetSectionType(uint32_t flags,\n                                        ConstString section_name) {\n\n  if (flags & (S_ATTR_PURE_INSTRUCTIONS | S_ATTR_SOME_INSTRUCTIONS))\n    return eSectionTypeCode;\n\n  uint32_t mach_sect_type = flags & SECTION_TYPE;\n  static ConstString g_sect_name_objc_data(\"__objc_data\");\n  static ConstString g_sect_name_objc_msgrefs(\"__objc_msgrefs\");\n  static ConstString g_sect_name_objc_selrefs(\"__objc_selrefs\");\n  static ConstString g_sect_name_objc_classrefs(\"__objc_classrefs\");\n  static ConstString g_sect_name_objc_superrefs(\"__objc_superrefs\");\n  static ConstString g_sect_name_objc_const(\"__objc_const\");\n  static ConstString g_sect_name_objc_classlist(\"__objc_classlist\");\n  static ConstString g_sect_name_cfstring(\"__cfstring\");\n\n  static ConstString g_sect_name_dwarf_debug_abbrev(\"__debug_abbrev\");\n  static ConstString g_sect_name_dwarf_debug_aranges(\"__debug_aranges\");\n  static ConstString g_sect_name_dwarf_debug_frame(\"__debug_frame\");\n  static ConstString g_sect_name_dwarf_debug_info(\"__debug_info\");\n  static ConstString g_sect_name_dwarf_debug_line(\"__debug_line\");\n  static ConstString g_sect_name_dwarf_debug_loc(\"__debug_loc\");\n  static ConstString g_sect_name_dwarf_debug_loclists(\"__debug_loclists\");\n  static ConstString g_sect_name_dwarf_debug_macinfo(\"__debug_macinfo\");\n  static ConstString g_sect_name_dwarf_debug_names(\"__debug_names\");\n  static ConstString g_sect_name_dwarf_debug_pubnames(\"__debug_pubnames\");\n  static ConstString g_sect_name_dwarf_debug_pubtypes(\"__debug_pubtypes\");\n  static ConstString g_sect_name_dwarf_debug_ranges(\"__debug_ranges\");\n  static ConstString g_sect_name_dwarf_debug_str(\"__debug_str\");\n  static ConstString g_sect_name_dwarf_debug_types(\"__debug_types\");\n  static ConstString g_sect_name_dwarf_apple_names(\"__apple_names\");\n  static ConstString g_sect_name_dwarf_apple_types(\"__apple_types\");\n  static ConstString g_sect_name_dwarf_apple_namespaces(\"__apple_namespac\");\n  static ConstString g_sect_name_dwarf_apple_objc(\"__apple_objc\");\n  static ConstString g_sect_name_eh_frame(\"__eh_frame\");\n  static ConstString g_sect_name_compact_unwind(\"__unwind_info\");\n  static ConstString g_sect_name_text(\"__text\");\n  static ConstString g_sect_name_data(\"__data\");\n  static ConstString g_sect_name_go_symtab(\"__gosymtab\");\n\n  if (section_name == g_sect_name_dwarf_debug_abbrev)\n    return eSectionTypeDWARFDebugAbbrev;\n  if (section_name == g_sect_name_dwarf_debug_aranges)\n    return eSectionTypeDWARFDebugAranges;\n  if (section_name == g_sect_name_dwarf_debug_frame)\n    return eSectionTypeDWARFDebugFrame;\n  if (section_name == g_sect_name_dwarf_debug_info)\n    return eSectionTypeDWARFDebugInfo;\n  if (section_name == g_sect_name_dwarf_debug_line)\n    return eSectionTypeDWARFDebugLine;\n  if (section_name == g_sect_name_dwarf_debug_loc)\n    return eSectionTypeDWARFDebugLoc;\n  if (section_name == g_sect_name_dwarf_debug_loclists)\n    return eSectionTypeDWARFDebugLocLists;\n  if (section_name == g_sect_name_dwarf_debug_macinfo)\n    return eSectionTypeDWARFDebugMacInfo;\n  if (section_name == g_sect_name_dwarf_debug_names)\n    return eSectionTypeDWARFDebugNames;\n  if (section_name == g_sect_name_dwarf_debug_pubnames)\n    return eSectionTypeDWARFDebugPubNames;\n  if (section_name == g_sect_name_dwarf_debug_pubtypes)\n    return eSectionTypeDWARFDebugPubTypes;\n  if (section_name == g_sect_name_dwarf_debug_ranges)\n    return eSectionTypeDWARFDebugRanges;\n  if (section_name == g_sect_name_dwarf_debug_str)\n    return eSectionTypeDWARFDebugStr;\n  if (section_name == g_sect_name_dwarf_debug_types)\n    return eSectionTypeDWARFDebugTypes;\n  if (section_name == g_sect_name_dwarf_apple_names)\n    return eSectionTypeDWARFAppleNames;\n  if (section_name == g_sect_name_dwarf_apple_types)\n    return eSectionTypeDWARFAppleTypes;\n  if (section_name == g_sect_name_dwarf_apple_namespaces)\n    return eSectionTypeDWARFAppleNamespaces;\n  if (section_name == g_sect_name_dwarf_apple_objc)\n    return eSectionTypeDWARFAppleObjC;\n  if (section_name == g_sect_name_objc_selrefs)\n    return eSectionTypeDataCStringPointers;\n  if (section_name == g_sect_name_objc_msgrefs)\n    return eSectionTypeDataObjCMessageRefs;\n  if (section_name == g_sect_name_eh_frame)\n    return eSectionTypeEHFrame;\n  if (section_name == g_sect_name_compact_unwind)\n    return eSectionTypeCompactUnwind;\n  if (section_name == g_sect_name_cfstring)\n    return eSectionTypeDataObjCCFStrings;\n  if (section_name == g_sect_name_go_symtab)\n    return eSectionTypeGoSymtab;\n  if (section_name == g_sect_name_objc_data ||\n      section_name == g_sect_name_objc_classrefs ||\n      section_name == g_sect_name_objc_superrefs ||\n      section_name == g_sect_name_objc_const ||\n      section_name == g_sect_name_objc_classlist) {\n    return eSectionTypeDataPointers;\n  }\n\n  switch (mach_sect_type) {\n  // TODO: categorize sections by other flags for regular sections\n  case S_REGULAR:\n    if (section_name == g_sect_name_text)\n      return eSectionTypeCode;\n    if (section_name == g_sect_name_data)\n      return eSectionTypeData;\n    return eSectionTypeOther;\n  case S_ZEROFILL:\n    return eSectionTypeZeroFill;\n  case S_CSTRING_LITERALS: // section with only literal C strings\n    return eSectionTypeDataCString;\n  case S_4BYTE_LITERALS: // section with only 4 byte literals\n    return eSectionTypeData4;\n  case S_8BYTE_LITERALS: // section with only 8 byte literals\n    return eSectionTypeData8;\n  case S_LITERAL_POINTERS: // section with only pointers to literals\n    return eSectionTypeDataPointers;\n  case S_NON_LAZY_SYMBOL_POINTERS: // section with only non-lazy symbol pointers\n    return eSectionTypeDataPointers;\n  case S_LAZY_SYMBOL_POINTERS: // section with only lazy symbol pointers\n    return eSectionTypeDataPointers;\n  case S_SYMBOL_STUBS: // section with only symbol stubs, byte size of stub in\n                       // the reserved2 field\n    return eSectionTypeCode;\n  case S_MOD_INIT_FUNC_POINTERS: // section with only function pointers for\n                                 // initialization\n    return eSectionTypeDataPointers;\n  case S_MOD_TERM_FUNC_POINTERS: // section with only function pointers for\n                                 // termination\n    return eSectionTypeDataPointers;\n  case S_COALESCED:\n    return eSectionTypeOther;\n  case S_GB_ZEROFILL:\n    return eSectionTypeZeroFill;\n  case S_INTERPOSING: // section with only pairs of function pointers for\n                      // interposing\n    return eSectionTypeCode;\n  case S_16BYTE_LITERALS: // section with only 16 byte literals\n    return eSectionTypeData16;\n  case S_DTRACE_DOF:\n    return eSectionTypeDebug;\n  case S_LAZY_DYLIB_SYMBOL_POINTERS:\n    return eSectionTypeDataPointers;\n  default:\n    return eSectionTypeOther;\n  }\n}\n\nstruct ObjectFileMachO::SegmentParsingContext {\n  const EncryptedFileRanges EncryptedRanges;\n  lldb_private::SectionList &UnifiedList;\n  uint32_t NextSegmentIdx = 0;\n  uint32_t NextSectionIdx = 0;\n  bool FileAddressesChanged = false;\n\n  SegmentParsingContext(EncryptedFileRanges EncryptedRanges,\n                        lldb_private::SectionList &UnifiedList)\n      : EncryptedRanges(std::move(EncryptedRanges)), UnifiedList(UnifiedList) {}\n};\n\nvoid ObjectFileMachO::ProcessSegmentCommand(const load_command &load_cmd_,\n                                            lldb::offset_t offset,\n                                            uint32_t cmd_idx,\n                                            SegmentParsingContext &context) {\n  segment_command_64 load_cmd;\n  memcpy(&load_cmd, &load_cmd_, sizeof(load_cmd_));\n\n  if (!m_data.GetU8(&offset, (uint8_t *)load_cmd.segname, 16))\n    return;\n\n  ModuleSP module_sp = GetModule();\n  const bool is_core = GetType() == eTypeCoreFile;\n  const bool is_dsym = (m_header.filetype == MH_DSYM);\n  bool add_section = true;\n  bool add_to_unified = true;\n  ConstString const_segname(\n      load_cmd.segname, strnlen(load_cmd.segname, sizeof(load_cmd.segname)));\n\n  SectionSP unified_section_sp(\n      context.UnifiedList.FindSectionByName(const_segname));\n  if (is_dsym && unified_section_sp) {\n    if (const_segname == GetSegmentNameLINKEDIT()) {\n      // We need to keep the __LINKEDIT segment private to this object file\n      // only\n      add_to_unified = false;\n    } else {\n      // This is the dSYM file and this section has already been created by the\n      // object file, no need to create it.\n      add_section = false;\n    }\n  }\n  load_cmd.vmaddr = m_data.GetAddress(&offset);\n  load_cmd.vmsize = m_data.GetAddress(&offset);\n  load_cmd.fileoff = m_data.GetAddress(&offset);\n  load_cmd.filesize = m_data.GetAddress(&offset);\n  if (!m_data.GetU32(&offset, &load_cmd.maxprot, 4))\n    return;\n\n  SanitizeSegmentCommand(load_cmd, cmd_idx);\n\n  const uint32_t segment_permissions = GetSegmentPermissions(load_cmd);\n  const bool segment_is_encrypted =\n      (load_cmd.flags & SG_PROTECTED_VERSION_1) != 0;\n\n  // Keep a list of mach segments around in case we need to get at data that\n  // isn't stored in the abstracted Sections.\n  m_mach_segments.push_back(load_cmd);\n\n  // Use a segment ID of the segment index shifted left by 8 so they never\n  // conflict with any of the sections.\n  SectionSP segment_sp;\n  if (add_section && (const_segname || is_core)) {\n    segment_sp = std::make_shared<Section>(\n        module_sp, // Module to which this section belongs\n        this,      // Object file to which this sections belongs\n        ++context.NextSegmentIdx\n            << 8, // Section ID is the 1 based segment index\n        // shifted right by 8 bits as not to collide with any of the 256\n        // section IDs that are possible\n        const_segname,         // Name of this section\n        eSectionTypeContainer, // This section is a container of other\n        // sections.\n        load_cmd.vmaddr, // File VM address == addresses as they are\n        // found in the object file\n        load_cmd.vmsize,  // VM size in bytes of this section\n        load_cmd.fileoff, // Offset to the data for this section in\n        // the file\n        load_cmd.filesize, // Size in bytes of this section as found\n        // in the file\n        0,               // Segments have no alignment information\n        load_cmd.flags); // Flags for this section\n\n    segment_sp->SetIsEncrypted(segment_is_encrypted);\n    m_sections_up->AddSection(segment_sp);\n    segment_sp->SetPermissions(segment_permissions);\n    if (add_to_unified)\n      context.UnifiedList.AddSection(segment_sp);\n  } else if (unified_section_sp) {\n    if (is_dsym && unified_section_sp->GetFileAddress() != load_cmd.vmaddr) {\n      // Check to see if the module was read from memory?\n      if (module_sp->GetObjectFile()->IsInMemory()) {\n        // We have a module that is in memory and needs to have its file\n        // address adjusted. We need to do this because when we load a file\n        // from memory, its addresses will be slid already, yet the addresses\n        // in the new symbol file will still be unslid.  Since everything is\n        // stored as section offset, this shouldn't cause any problems.\n\n        // Make sure we've parsed the symbol table from the ObjectFile before\n        // we go around changing its Sections.\n        module_sp->GetObjectFile()->GetSymtab();\n        // eh_frame would present the same problems but we parse that on a per-\n        // function basis as-needed so it's more difficult to remove its use of\n        // the Sections.  Realistically, the environments where this code path\n        // will be taken will not have eh_frame sections.\n\n        unified_section_sp->SetFileAddress(load_cmd.vmaddr);\n\n        // Notify the module that the section addresses have been changed once\n        // we're done so any file-address caches can be updated.\n        context.FileAddressesChanged = true;\n      }\n    }\n    m_sections_up->AddSection(unified_section_sp);\n  }\n\n  struct section_64 sect64;\n  ::memset(&sect64, 0, sizeof(sect64));\n  // Push a section into our mach sections for the section at index zero\n  // (NO_SECT) if we don't have any mach sections yet...\n  if (m_mach_sections.empty())\n    m_mach_sections.push_back(sect64);\n  uint32_t segment_sect_idx;\n  const lldb::user_id_t first_segment_sectID = context.NextSectionIdx + 1;\n\n  const uint32_t num_u32s = load_cmd.cmd == LC_SEGMENT ? 7 : 8;\n  for (segment_sect_idx = 0; segment_sect_idx < load_cmd.nsects;\n       ++segment_sect_idx) {\n    if (m_data.GetU8(&offset, (uint8_t *)sect64.sectname,\n                     sizeof(sect64.sectname)) == nullptr)\n      break;\n    if (m_data.GetU8(&offset, (uint8_t *)sect64.segname,\n                     sizeof(sect64.segname)) == nullptr)\n      break;\n    sect64.addr = m_data.GetAddress(&offset);\n    sect64.size = m_data.GetAddress(&offset);\n\n    if (m_data.GetU32(&offset, &sect64.offset, num_u32s) == nullptr)\n      break;\n\n    if ((m_header.flags & MH_DYLIB_IN_CACHE) && !IsInMemory()) {\n      sect64.offset = sect64.addr - m_text_address;\n    }\n\n    // Keep a list of mach sections around in case we need to get at data that\n    // isn't stored in the abstracted Sections.\n    m_mach_sections.push_back(sect64);\n\n    if (add_section) {\n      ConstString section_name(\n          sect64.sectname, strnlen(sect64.sectname, sizeof(sect64.sectname)));\n      if (!const_segname) {\n        // We have a segment with no name so we need to conjure up segments\n        // that correspond to the section's segname if there isn't already such\n        // a section. If there is such a section, we resize the section so that\n        // it spans all sections.  We also mark these sections as fake so\n        // address matches don't hit if they land in the gaps between the child\n        // sections.\n        const_segname.SetTrimmedCStringWithLength(sect64.segname,\n                                                  sizeof(sect64.segname));\n        segment_sp = context.UnifiedList.FindSectionByName(const_segname);\n        if (segment_sp.get()) {\n          Section *segment = segment_sp.get();\n          // Grow the section size as needed.\n          const lldb::addr_t sect64_min_addr = sect64.addr;\n          const lldb::addr_t sect64_max_addr = sect64_min_addr + sect64.size;\n          const lldb::addr_t curr_seg_byte_size = segment->GetByteSize();\n          const lldb::addr_t curr_seg_min_addr = segment->GetFileAddress();\n          const lldb::addr_t curr_seg_max_addr =\n              curr_seg_min_addr + curr_seg_byte_size;\n          if (sect64_min_addr >= curr_seg_min_addr) {\n            const lldb::addr_t new_seg_byte_size =\n                sect64_max_addr - curr_seg_min_addr;\n            // Only grow the section size if needed\n            if (new_seg_byte_size > curr_seg_byte_size)\n              segment->SetByteSize(new_seg_byte_size);\n          } else {\n            // We need to change the base address of the segment and adjust the\n            // child section offsets for all existing children.\n            const lldb::addr_t slide_amount =\n                sect64_min_addr - curr_seg_min_addr;\n            segment->Slide(slide_amount, false);\n            segment->GetChildren().Slide(-slide_amount, false);\n            segment->SetByteSize(curr_seg_max_addr - sect64_min_addr);\n          }\n\n          // Grow the section size as needed.\n          if (sect64.offset) {\n            const lldb::addr_t segment_min_file_offset =\n                segment->GetFileOffset();\n            const lldb::addr_t segment_max_file_offset =\n                segment_min_file_offset + segment->GetFileSize();\n\n            const lldb::addr_t section_min_file_offset = sect64.offset;\n            const lldb::addr_t section_max_file_offset =\n                section_min_file_offset + sect64.size;\n            const lldb::addr_t new_file_offset =\n                std::min(section_min_file_offset, segment_min_file_offset);\n            const lldb::addr_t new_file_size =\n                std::max(section_max_file_offset, segment_max_file_offset) -\n                new_file_offset;\n            segment->SetFileOffset(new_file_offset);\n            segment->SetFileSize(new_file_size);\n          }\n        } else {\n          // Create a fake section for the section's named segment\n          segment_sp = std::make_shared<Section>(\n              segment_sp, // Parent section\n              module_sp,  // Module to which this section belongs\n              this,       // Object file to which this section belongs\n              ++context.NextSegmentIdx\n                  << 8, // Section ID is the 1 based segment index\n              // shifted right by 8 bits as not to\n              // collide with any of the 256 section IDs\n              // that are possible\n              const_segname,         // Name of this section\n              eSectionTypeContainer, // This section is a container of\n              // other sections.\n              sect64.addr, // File VM address == addresses as they are\n              // found in the object file\n              sect64.size,   // VM size in bytes of this section\n              sect64.offset, // Offset to the data for this section in\n              // the file\n              sect64.offset ? sect64.size : 0, // Size in bytes of\n              // this section as\n              // found in the file\n              sect64.align,\n              load_cmd.flags); // Flags for this section\n          segment_sp->SetIsFake(true);\n          segment_sp->SetPermissions(segment_permissions);\n          m_sections_up->AddSection(segment_sp);\n          if (add_to_unified)\n            context.UnifiedList.AddSection(segment_sp);\n          segment_sp->SetIsEncrypted(segment_is_encrypted);\n        }\n      }\n      assert(segment_sp.get());\n\n      lldb::SectionType sect_type = GetSectionType(sect64.flags, section_name);\n\n      SectionSP section_sp(new Section(\n          segment_sp, module_sp, this, ++context.NextSectionIdx, section_name,\n          sect_type, sect64.addr - segment_sp->GetFileAddress(), sect64.size,\n          sect64.offset, sect64.offset == 0 ? 0 : sect64.size, sect64.align,\n          sect64.flags));\n      // Set the section to be encrypted to match the segment\n\n      bool section_is_encrypted = false;\n      if (!segment_is_encrypted && load_cmd.filesize != 0)\n        section_is_encrypted = context.EncryptedRanges.FindEntryThatContains(\n                                   sect64.offset) != nullptr;\n\n      section_sp->SetIsEncrypted(segment_is_encrypted || section_is_encrypted);\n      section_sp->SetPermissions(segment_permissions);\n      segment_sp->GetChildren().AddSection(section_sp);\n\n      if (segment_sp->IsFake()) {\n        segment_sp.reset();\n        const_segname.Clear();\n      }\n    }\n  }\n  if (segment_sp && is_dsym) {\n    if (first_segment_sectID <= context.NextSectionIdx) {\n      lldb::user_id_t sect_uid;\n      for (sect_uid = first_segment_sectID; sect_uid <= context.NextSectionIdx;\n           ++sect_uid) {\n        SectionSP curr_section_sp(\n            segment_sp->GetChildren().FindSectionByID(sect_uid));\n        SectionSP next_section_sp;\n        if (sect_uid + 1 <= context.NextSectionIdx)\n          next_section_sp =\n              segment_sp->GetChildren().FindSectionByID(sect_uid + 1);\n\n        if (curr_section_sp.get()) {\n          if (curr_section_sp->GetByteSize() == 0) {\n            if (next_section_sp.get() != nullptr)\n              curr_section_sp->SetByteSize(next_section_sp->GetFileAddress() -\n                                           curr_section_sp->GetFileAddress());\n            else\n              curr_section_sp->SetByteSize(load_cmd.vmsize);\n          }\n        }\n      }\n    }\n  }\n}\n\nvoid ObjectFileMachO::ProcessDysymtabCommand(const load_command &load_cmd,\n                                             lldb::offset_t offset) {\n  m_dysymtab.cmd = load_cmd.cmd;\n  m_dysymtab.cmdsize = load_cmd.cmdsize;\n  m_data.GetU32(&offset, &m_dysymtab.ilocalsym,\n                (sizeof(m_dysymtab) / sizeof(uint32_t)) - 2);\n}\n\nvoid ObjectFileMachO::CreateSections(SectionList &unified_section_list) {\n  if (m_sections_up)\n    return;\n\n  m_sections_up = std::make_unique<SectionList>();\n\n  lldb::offset_t offset = MachHeaderSizeFromMagic(m_header.magic);\n  // bool dump_sections = false;\n  ModuleSP module_sp(GetModule());\n\n  offset = MachHeaderSizeFromMagic(m_header.magic);\n\n  SegmentParsingContext context(GetEncryptedFileRanges(), unified_section_list);\n  struct load_command load_cmd;\n  for (uint32_t i = 0; i < m_header.ncmds; ++i) {\n    const lldb::offset_t load_cmd_offset = offset;\n    if (m_data.GetU32(&offset, &load_cmd, 2) == nullptr)\n      break;\n\n    if (load_cmd.cmd == LC_SEGMENT || load_cmd.cmd == LC_SEGMENT_64)\n      ProcessSegmentCommand(load_cmd, offset, i, context);\n    else if (load_cmd.cmd == LC_DYSYMTAB)\n      ProcessDysymtabCommand(load_cmd, offset);\n\n    offset = load_cmd_offset + load_cmd.cmdsize;\n  }\n\n  if (context.FileAddressesChanged && module_sp)\n    module_sp->SectionFileAddressesChanged();\n}\n\nclass MachSymtabSectionInfo {\npublic:\n  MachSymtabSectionInfo(SectionList *section_list)\n      : m_section_list(section_list), m_section_infos() {\n    // Get the number of sections down to a depth of 1 to include all segments\n    // and their sections, but no other sections that may be added for debug\n    // map or\n    m_section_infos.resize(section_list->GetNumSections(1));\n  }\n\n  SectionSP GetSection(uint8_t n_sect, addr_t file_addr) {\n    if (n_sect == 0)\n      return SectionSP();\n    if (n_sect < m_section_infos.size()) {\n      if (!m_section_infos[n_sect].section_sp) {\n        SectionSP section_sp(m_section_list->FindSectionByID(n_sect));\n        m_section_infos[n_sect].section_sp = section_sp;\n        if (section_sp) {\n          m_section_infos[n_sect].vm_range.SetBaseAddress(\n              section_sp->GetFileAddress());\n          m_section_infos[n_sect].vm_range.SetByteSize(\n              section_sp->GetByteSize());\n        } else {\n          std::string filename = \"<unknown>\";\n          SectionSP first_section_sp(m_section_list->GetSectionAtIndex(0));\n          if (first_section_sp)\n            filename = first_section_sp->GetObjectFile()->GetFileSpec().GetPath();\n\n          Host::SystemLog(Host::eSystemLogError,\n                          \"error: unable to find section %d for a symbol in %s, corrupt file?\\n\",\n                          n_sect, \n                          filename.c_str());\n        }\n      }\n      if (m_section_infos[n_sect].vm_range.Contains(file_addr)) {\n        // Symbol is in section.\n        return m_section_infos[n_sect].section_sp;\n      } else if (m_section_infos[n_sect].vm_range.GetByteSize() == 0 &&\n                 m_section_infos[n_sect].vm_range.GetBaseAddress() ==\n                     file_addr) {\n        // Symbol is in section with zero size, but has the same start address\n        // as the section. This can happen with linker symbols (symbols that\n        // start with the letter 'l' or 'L'.\n        return m_section_infos[n_sect].section_sp;\n      }\n    }\n    return m_section_list->FindSectionContainingFileAddress(file_addr);\n  }\n\nprotected:\n  struct SectionInfo {\n    SectionInfo() : vm_range(), section_sp() {}\n\n    VMRange vm_range;\n    SectionSP section_sp;\n  };\n  SectionList *m_section_list;\n  std::vector<SectionInfo> m_section_infos;\n};\n\n#define TRIE_SYMBOL_IS_THUMB (1ULL << 63)\nstruct TrieEntry {\n  void Dump() const {\n    printf(\"0x%16.16llx 0x%16.16llx 0x%16.16llx \\\"%s\\\"\",\n           static_cast<unsigned long long>(address),\n           static_cast<unsigned long long>(flags),\n           static_cast<unsigned long long>(other), name.GetCString());\n    if (import_name)\n      printf(\" -> \\\"%s\\\"\\n\", import_name.GetCString());\n    else\n      printf(\"\\n\");\n  }\n  ConstString name;\n  uint64_t address = LLDB_INVALID_ADDRESS;\n  uint64_t flags =\n      0; // EXPORT_SYMBOL_FLAGS_REEXPORT, EXPORT_SYMBOL_FLAGS_STUB_AND_RESOLVER,\n         // TRIE_SYMBOL_IS_THUMB\n  uint64_t other = 0;\n  ConstString import_name;\n};\n\nstruct TrieEntryWithOffset {\n  lldb::offset_t nodeOffset;\n  TrieEntry entry;\n\n  TrieEntryWithOffset(lldb::offset_t offset) : nodeOffset(offset), entry() {}\n\n  void Dump(uint32_t idx) const {\n    printf(\"[%3u] 0x%16.16llx: \", idx,\n           static_cast<unsigned long long>(nodeOffset));\n    entry.Dump();\n  }\n\n  bool operator<(const TrieEntryWithOffset &other) const {\n    return (nodeOffset < other.nodeOffset);\n  }\n};\n\nstatic bool ParseTrieEntries(DataExtractor &data, lldb::offset_t offset,\n                             const bool is_arm, addr_t text_seg_base_addr,\n                             std::vector<llvm::StringRef> &nameSlices,\n                             std::set<lldb::addr_t> &resolver_addresses,\n                             std::vector<TrieEntryWithOffset> &reexports,\n                             std::vector<TrieEntryWithOffset> &ext_symbols) {\n  if (!data.ValidOffset(offset))\n    return true;\n\n  // Terminal node -- end of a branch, possibly add this to\n  // the symbol table or resolver table.\n  const uint64_t terminalSize = data.GetULEB128(&offset);\n  lldb::offset_t children_offset = offset + terminalSize;\n  if (terminalSize != 0) {\n    TrieEntryWithOffset e(offset);\n    e.entry.flags = data.GetULEB128(&offset);\n    const char *import_name = nullptr;\n    if (e.entry.flags & EXPORT_SYMBOL_FLAGS_REEXPORT) {\n      e.entry.address = 0;\n      e.entry.other = data.GetULEB128(&offset); // dylib ordinal\n      import_name = data.GetCStr(&offset);\n    } else {\n      e.entry.address = data.GetULEB128(&offset);\n      if (text_seg_base_addr != LLDB_INVALID_ADDRESS)\n        e.entry.address += text_seg_base_addr;\n      if (e.entry.flags & EXPORT_SYMBOL_FLAGS_STUB_AND_RESOLVER) {\n        e.entry.other = data.GetULEB128(&offset);\n        uint64_t resolver_addr = e.entry.other;\n        if (text_seg_base_addr != LLDB_INVALID_ADDRESS)\n          resolver_addr += text_seg_base_addr;\n        if (is_arm)\n          resolver_addr &= THUMB_ADDRESS_BIT_MASK;\n        resolver_addresses.insert(resolver_addr);\n      } else\n        e.entry.other = 0;\n    }\n    bool add_this_entry = false;\n    if (Flags(e.entry.flags).Test(EXPORT_SYMBOL_FLAGS_REEXPORT) &&\n        import_name && import_name[0]) {\n      // add symbols that are reexport symbols with a valid import name.\n      add_this_entry = true;\n    } else if (e.entry.flags == 0 &&\n               (import_name == nullptr || import_name[0] == '\\0')) {\n      // add externally visible symbols, in case the nlist record has\n      // been stripped/omitted.\n      add_this_entry = true;\n    }\n    if (add_this_entry) {\n      std::string name;\n      if (!nameSlices.empty()) {\n        for (auto name_slice : nameSlices)\n          name.append(name_slice.data(), name_slice.size());\n      }\n      if (name.size() > 1) {\n        // Skip the leading '_'\n        e.entry.name.SetCStringWithLength(name.c_str() + 1, name.size() - 1);\n      }\n      if (import_name) {\n        // Skip the leading '_'\n        e.entry.import_name.SetCString(import_name + 1);\n      }\n      if (Flags(e.entry.flags).Test(EXPORT_SYMBOL_FLAGS_REEXPORT)) {\n        reexports.push_back(e);\n      } else {\n        if (is_arm && (e.entry.address & 1)) {\n          e.entry.flags |= TRIE_SYMBOL_IS_THUMB;\n          e.entry.address &= THUMB_ADDRESS_BIT_MASK;\n        }\n        ext_symbols.push_back(e);\n      }\n    }\n  }\n\n  const uint8_t childrenCount = data.GetU8(&children_offset);\n  for (uint8_t i = 0; i < childrenCount; ++i) {\n    const char *cstr = data.GetCStr(&children_offset);\n    if (cstr)\n      nameSlices.push_back(llvm::StringRef(cstr));\n    else\n      return false; // Corrupt data\n    lldb::offset_t childNodeOffset = data.GetULEB128(&children_offset);\n    if (childNodeOffset) {\n      if (!ParseTrieEntries(data, childNodeOffset, is_arm, text_seg_base_addr,\n                            nameSlices, resolver_addresses, reexports,\n                            ext_symbols)) {\n        return false;\n      }\n    }\n    nameSlices.pop_back();\n  }\n  return true;\n}\n\nstatic SymbolType GetSymbolType(const char *&symbol_name,\n                                bool &demangled_is_synthesized,\n                                const SectionSP &text_section_sp,\n                                const SectionSP &data_section_sp,\n                                const SectionSP &data_dirty_section_sp,\n                                const SectionSP &data_const_section_sp,\n                                const SectionSP &symbol_section) {\n  SymbolType type = eSymbolTypeInvalid;\n\n  const char *symbol_sect_name = symbol_section->GetName().AsCString();\n  if (symbol_section->IsDescendant(text_section_sp.get())) {\n    if (symbol_section->IsClear(S_ATTR_PURE_INSTRUCTIONS |\n                                S_ATTR_SELF_MODIFYING_CODE |\n                                S_ATTR_SOME_INSTRUCTIONS))\n      type = eSymbolTypeData;\n    else\n      type = eSymbolTypeCode;\n  } else if (symbol_section->IsDescendant(data_section_sp.get()) ||\n             symbol_section->IsDescendant(data_dirty_section_sp.get()) ||\n             symbol_section->IsDescendant(data_const_section_sp.get())) {\n    if (symbol_sect_name &&\n        ::strstr(symbol_sect_name, \"__objc\") == symbol_sect_name) {\n      type = eSymbolTypeRuntime;\n\n      if (symbol_name) {\n        llvm::StringRef symbol_name_ref(symbol_name);\n        if (symbol_name_ref.startswith(\"OBJC_\")) {\n          static const llvm::StringRef g_objc_v2_prefix_class(\"OBJC_CLASS_$_\");\n          static const llvm::StringRef g_objc_v2_prefix_metaclass(\n              \"OBJC_METACLASS_$_\");\n          static const llvm::StringRef g_objc_v2_prefix_ivar(\"OBJC_IVAR_$_\");\n          if (symbol_name_ref.startswith(g_objc_v2_prefix_class)) {\n            symbol_name = symbol_name + g_objc_v2_prefix_class.size();\n            type = eSymbolTypeObjCClass;\n            demangled_is_synthesized = true;\n          } else if (symbol_name_ref.startswith(g_objc_v2_prefix_metaclass)) {\n            symbol_name = symbol_name + g_objc_v2_prefix_metaclass.size();\n            type = eSymbolTypeObjCMetaClass;\n            demangled_is_synthesized = true;\n          } else if (symbol_name_ref.startswith(g_objc_v2_prefix_ivar)) {\n            symbol_name = symbol_name + g_objc_v2_prefix_ivar.size();\n            type = eSymbolTypeObjCIVar;\n            demangled_is_synthesized = true;\n          }\n        }\n      }\n    } else if (symbol_sect_name &&\n               ::strstr(symbol_sect_name, \"__gcc_except_tab\") ==\n                   symbol_sect_name) {\n      type = eSymbolTypeException;\n    } else {\n      type = eSymbolTypeData;\n    }\n  } else if (symbol_sect_name &&\n             ::strstr(symbol_sect_name, \"__IMPORT\") == symbol_sect_name) {\n    type = eSymbolTypeTrampoline;\n  }\n  return type;\n}\n\n// Read the UUID out of a dyld_shared_cache file on-disk.\nUUID ObjectFileMachO::GetSharedCacheUUID(FileSpec dyld_shared_cache,\n                                         const ByteOrder byte_order,\n                                         const uint32_t addr_byte_size) {\n  UUID dsc_uuid;\n  DataBufferSP DscData = MapFileData(\n      dyld_shared_cache, sizeof(struct lldb_copy_dyld_cache_header_v1), 0);\n  if (!DscData)\n    return dsc_uuid;\n  DataExtractor dsc_header_data(DscData, byte_order, addr_byte_size);\n\n  char version_str[7];\n  lldb::offset_t offset = 0;\n  memcpy(version_str, dsc_header_data.GetData(&offset, 6), 6);\n  version_str[6] = '\\0';\n  if (strcmp(version_str, \"dyld_v\") == 0) {\n    offset = offsetof(struct lldb_copy_dyld_cache_header_v1, uuid);\n    dsc_uuid = UUID::fromOptionalData(\n        dsc_header_data.GetData(&offset, sizeof(uuid_t)), sizeof(uuid_t));\n  }\n  Log *log(lldb_private::GetLogIfAllCategoriesSet(LIBLLDB_LOG_SYMBOLS));\n  if (log && dsc_uuid.IsValid()) {\n    LLDB_LOGF(log, \"Shared cache %s has UUID %s\",\n              dyld_shared_cache.GetPath().c_str(),\n              dsc_uuid.GetAsString().c_str());\n  }\n  return dsc_uuid;\n}\n\nstatic llvm::Optional<struct nlist_64>\nParseNList(DataExtractor &nlist_data, lldb::offset_t &nlist_data_offset,\n           size_t nlist_byte_size) {\n  struct nlist_64 nlist;\n  if (!nlist_data.ValidOffsetForDataOfSize(nlist_data_offset, nlist_byte_size))\n    return {};\n  nlist.n_strx = nlist_data.GetU32_unchecked(&nlist_data_offset);\n  nlist.n_type = nlist_data.GetU8_unchecked(&nlist_data_offset);\n  nlist.n_sect = nlist_data.GetU8_unchecked(&nlist_data_offset);\n  nlist.n_desc = nlist_data.GetU16_unchecked(&nlist_data_offset);\n  nlist.n_value = nlist_data.GetAddress_unchecked(&nlist_data_offset);\n  return nlist;\n}\n\nenum { DebugSymbols = true, NonDebugSymbols = false };\n\nsize_t ObjectFileMachO::ParseSymtab() {\n  LLDB_SCOPED_TIMERF(\"ObjectFileMachO::ParseSymtab () module = %s\",\n                     m_file.GetFilename().AsCString(\"\"));\n  ModuleSP module_sp(GetModule());\n  if (!module_sp)\n    return 0;\n\n  struct symtab_command symtab_load_command = {0, 0, 0, 0, 0, 0};\n  struct linkedit_data_command function_starts_load_command = {0, 0, 0, 0};\n  struct dyld_info_command dyld_info = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};\n  // The data element of type bool indicates that this entry is thumb\n  // code.\n  typedef AddressDataArray<lldb::addr_t, bool, 100> FunctionStarts;\n\n  // Record the address of every function/data that we add to the symtab.\n  // We add symbols to the table in the order of most information (nlist\n  // records) to least (function starts), and avoid duplicating symbols\n  // via this set.\n  std::set<addr_t> symbols_added;\n  FunctionStarts function_starts;\n  lldb::offset_t offset = MachHeaderSizeFromMagic(m_header.magic);\n  uint32_t i;\n  FileSpecList dylib_files;\n  Log *log(lldb_private::GetLogIfAllCategoriesSet(LIBLLDB_LOG_SYMBOLS));\n  llvm::StringRef g_objc_v2_prefix_class(\"_OBJC_CLASS_$_\");\n  llvm::StringRef g_objc_v2_prefix_metaclass(\"_OBJC_METACLASS_$_\");\n  llvm::StringRef g_objc_v2_prefix_ivar(\"_OBJC_IVAR_$_\");\n\n  for (i = 0; i < m_header.ncmds; ++i) {\n    const lldb::offset_t cmd_offset = offset;\n    // Read in the load command and load command size\n    struct load_command lc;\n    if (m_data.GetU32(&offset, &lc, 2) == nullptr)\n      break;\n    // Watch for the symbol table load command\n    switch (lc.cmd) {\n    case LC_SYMTAB:\n      symtab_load_command.cmd = lc.cmd;\n      symtab_load_command.cmdsize = lc.cmdsize;\n      // Read in the rest of the symtab load command\n      if (m_data.GetU32(&offset, &symtab_load_command.symoff, 4) ==\n          nullptr) // fill in symoff, nsyms, stroff, strsize fields\n        return 0;\n      break;\n\n    case LC_DYLD_INFO:\n    case LC_DYLD_INFO_ONLY:\n      if (m_data.GetU32(&offset, &dyld_info.rebase_off, 10)) {\n        dyld_info.cmd = lc.cmd;\n        dyld_info.cmdsize = lc.cmdsize;\n      } else {\n        memset(&dyld_info, 0, sizeof(dyld_info));\n      }\n      break;\n\n    case LC_LOAD_DYLIB:\n    case LC_LOAD_WEAK_DYLIB:\n    case LC_REEXPORT_DYLIB:\n    case LC_LOADFVMLIB:\n    case LC_LOAD_UPWARD_DYLIB: {\n      uint32_t name_offset = cmd_offset + m_data.GetU32(&offset);\n      const char *path = m_data.PeekCStr(name_offset);\n      if (path) {\n        FileSpec file_spec(path);\n        // Strip the path if there is @rpath, @executable, etc so we just use\n        // the basename\n        if (path[0] == '@')\n          file_spec.GetDirectory().Clear();\n\n        if (lc.cmd == LC_REEXPORT_DYLIB) {\n          m_reexported_dylibs.AppendIfUnique(file_spec);\n        }\n\n        dylib_files.Append(file_spec);\n      }\n    } break;\n\n    case LC_FUNCTION_STARTS:\n      function_starts_load_command.cmd = lc.cmd;\n      function_starts_load_command.cmdsize = lc.cmdsize;\n      if (m_data.GetU32(&offset, &function_starts_load_command.dataoff, 2) ==\n          nullptr) // fill in symoff, nsyms, stroff, strsize fields\n        memset(&function_starts_load_command, 0,\n               sizeof(function_starts_load_command));\n      break;\n\n    default:\n      break;\n    }\n    offset = cmd_offset + lc.cmdsize;\n  }\n\n  if (!symtab_load_command.cmd)\n    return 0;\n\n  Symtab *symtab = m_symtab_up.get();\n  SectionList *section_list = GetSectionList();\n  if (section_list == nullptr)\n    return 0;\n\n  const uint32_t addr_byte_size = m_data.GetAddressByteSize();\n  const ByteOrder byte_order = m_data.GetByteOrder();\n  bool bit_width_32 = addr_byte_size == 4;\n  const size_t nlist_byte_size =\n      bit_width_32 ? sizeof(struct nlist) : sizeof(struct nlist_64);\n\n  DataExtractor nlist_data(nullptr, 0, byte_order, addr_byte_size);\n  DataExtractor strtab_data(nullptr, 0, byte_order, addr_byte_size);\n  DataExtractor function_starts_data(nullptr, 0, byte_order, addr_byte_size);\n  DataExtractor indirect_symbol_index_data(nullptr, 0, byte_order,\n                                           addr_byte_size);\n  DataExtractor dyld_trie_data(nullptr, 0, byte_order, addr_byte_size);\n\n  const addr_t nlist_data_byte_size =\n      symtab_load_command.nsyms * nlist_byte_size;\n  const addr_t strtab_data_byte_size = symtab_load_command.strsize;\n  addr_t strtab_addr = LLDB_INVALID_ADDRESS;\n\n  ProcessSP process_sp(m_process_wp.lock());\n  Process *process = process_sp.get();\n\n  uint32_t memory_module_load_level = eMemoryModuleLoadLevelComplete;\n  bool is_shared_cache_image = m_header.flags & MH_DYLIB_IN_CACHE;\n  bool is_local_shared_cache_image = is_shared_cache_image && !IsInMemory();\n  SectionSP linkedit_section_sp(\n      section_list->FindSectionByName(GetSegmentNameLINKEDIT()));\n\n  if (process && m_header.filetype != llvm::MachO::MH_OBJECT &&\n      !is_local_shared_cache_image) {\n    Target &target = process->GetTarget();\n\n    memory_module_load_level = target.GetMemoryModuleLoadLevel();\n\n    // Reading mach file from memory in a process or core file...\n\n    if (linkedit_section_sp) {\n      addr_t linkedit_load_addr =\n          linkedit_section_sp->GetLoadBaseAddress(&target);\n      if (linkedit_load_addr == LLDB_INVALID_ADDRESS) {\n        // We might be trying to access the symbol table before the\n        // __LINKEDIT's load address has been set in the target. We can't\n        // fail to read the symbol table, so calculate the right address\n        // manually\n        linkedit_load_addr = CalculateSectionLoadAddressForMemoryImage(\n            m_memory_addr, GetMachHeaderSection(), linkedit_section_sp.get());\n      }\n\n      const addr_t linkedit_file_offset = linkedit_section_sp->GetFileOffset();\n      const addr_t symoff_addr = linkedit_load_addr +\n                                 symtab_load_command.symoff -\n                                 linkedit_file_offset;\n      strtab_addr = linkedit_load_addr + symtab_load_command.stroff -\n                    linkedit_file_offset;\n\n        // Always load dyld - the dynamic linker - from memory if we didn't\n        // find a binary anywhere else. lldb will not register\n        // dylib/framework/bundle loads/unloads if we don't have the dyld\n        // symbols, we force dyld to load from memory despite the user's\n        // target.memory-module-load-level setting.\n        if (memory_module_load_level == eMemoryModuleLoadLevelComplete ||\n            m_header.filetype == llvm::MachO::MH_DYLINKER) {\n          DataBufferSP nlist_data_sp(\n              ReadMemory(process_sp, symoff_addr, nlist_data_byte_size));\n          if (nlist_data_sp)\n            nlist_data.SetData(nlist_data_sp, 0, nlist_data_sp->GetByteSize());\n          if (m_dysymtab.nindirectsyms != 0) {\n            const addr_t indirect_syms_addr = linkedit_load_addr +\n                                              m_dysymtab.indirectsymoff -\n                                              linkedit_file_offset;\n            DataBufferSP indirect_syms_data_sp(ReadMemory(\n                process_sp, indirect_syms_addr, m_dysymtab.nindirectsyms * 4));\n            if (indirect_syms_data_sp)\n              indirect_symbol_index_data.SetData(\n                  indirect_syms_data_sp, 0,\n                  indirect_syms_data_sp->GetByteSize());\n            // If this binary is outside the shared cache,\n            // cache the string table.\n            // Binaries in the shared cache all share a giant string table,\n            // and we can't share the string tables across multiple\n            // ObjectFileMachO's, so we'd end up re-reading this mega-strtab\n            // for every binary in the shared cache - it would be a big perf\n            // problem. For binaries outside the shared cache, it's faster to\n            // read the entire strtab at once instead of piece-by-piece as we\n            // process the nlist records.\n            if (!is_shared_cache_image) {\n              DataBufferSP strtab_data_sp(\n                  ReadMemory(process_sp, strtab_addr, strtab_data_byte_size));\n              if (strtab_data_sp) {\n                strtab_data.SetData(strtab_data_sp, 0,\n                                    strtab_data_sp->GetByteSize());\n              }\n            }\n          }\n        if (memory_module_load_level >= eMemoryModuleLoadLevelPartial) {\n          if (function_starts_load_command.cmd) {\n            const addr_t func_start_addr =\n                linkedit_load_addr + function_starts_load_command.dataoff -\n                linkedit_file_offset;\n            DataBufferSP func_start_data_sp(\n                ReadMemory(process_sp, func_start_addr,\n                           function_starts_load_command.datasize));\n            if (func_start_data_sp)\n              function_starts_data.SetData(func_start_data_sp, 0,\n                                           func_start_data_sp->GetByteSize());\n          }\n        }\n      }\n    }\n  } else {\n    if (is_local_shared_cache_image) {\n      // The load commands in shared cache images are relative to the\n      // beginning of the shared cache, not the library image. The\n      // data we get handed when creating the ObjectFileMachO starts\n      // at the beginning of a specific library and spans to the end\n      // of the cache to be able to reach the shared LINKEDIT\n      // segments. We need to convert the load command offsets to be\n      // relative to the beginning of our specific image.\n      lldb::addr_t linkedit_offset = linkedit_section_sp->GetFileOffset();\n      lldb::offset_t linkedit_slide =\n          linkedit_offset - m_linkedit_original_offset;\n      symtab_load_command.symoff += linkedit_slide;\n      symtab_load_command.stroff += linkedit_slide;\n      dyld_info.export_off += linkedit_slide;\n      m_dysymtab.indirectsymoff += linkedit_slide;\n      function_starts_load_command.dataoff += linkedit_slide;\n    }\n\n    nlist_data.SetData(m_data, symtab_load_command.symoff,\n                       nlist_data_byte_size);\n    strtab_data.SetData(m_data, symtab_load_command.stroff,\n                        strtab_data_byte_size);\n\n    if (dyld_info.export_size > 0) {\n      dyld_trie_data.SetData(m_data, dyld_info.export_off,\n                             dyld_info.export_size);\n    }\n\n    if (m_dysymtab.nindirectsyms != 0) {\n      indirect_symbol_index_data.SetData(m_data, m_dysymtab.indirectsymoff,\n                                         m_dysymtab.nindirectsyms * 4);\n    }\n    if (function_starts_load_command.cmd) {\n      function_starts_data.SetData(m_data, function_starts_load_command.dataoff,\n                                   function_starts_load_command.datasize);\n    }\n  }\n\n  const bool have_strtab_data = strtab_data.GetByteSize() > 0;\n\n  ConstString g_segment_name_TEXT = GetSegmentNameTEXT();\n  ConstString g_segment_name_DATA = GetSegmentNameDATA();\n  ConstString g_segment_name_DATA_DIRTY = GetSegmentNameDATA_DIRTY();\n  ConstString g_segment_name_DATA_CONST = GetSegmentNameDATA_CONST();\n  ConstString g_segment_name_OBJC = GetSegmentNameOBJC();\n  ConstString g_section_name_eh_frame = GetSectionNameEHFrame();\n  SectionSP text_section_sp(\n      section_list->FindSectionByName(g_segment_name_TEXT));\n  SectionSP data_section_sp(\n      section_list->FindSectionByName(g_segment_name_DATA));\n  SectionSP data_dirty_section_sp(\n      section_list->FindSectionByName(g_segment_name_DATA_DIRTY));\n  SectionSP data_const_section_sp(\n      section_list->FindSectionByName(g_segment_name_DATA_CONST));\n  SectionSP objc_section_sp(\n      section_list->FindSectionByName(g_segment_name_OBJC));\n  SectionSP eh_frame_section_sp;\n  if (text_section_sp.get())\n    eh_frame_section_sp = text_section_sp->GetChildren().FindSectionByName(\n        g_section_name_eh_frame);\n  else\n    eh_frame_section_sp =\n        section_list->FindSectionByName(g_section_name_eh_frame);\n\n  const bool is_arm = (m_header.cputype == llvm::MachO::CPU_TYPE_ARM);\n  const bool always_thumb = GetArchitecture().IsAlwaysThumbInstructions();\n\n  // lldb works best if it knows the start address of all functions in a\n  // module. Linker symbols or debug info are normally the best source of\n  // information for start addr / size but they may be stripped in a released\n  // binary. Two additional sources of information exist in Mach-O binaries:\n  //    LC_FUNCTION_STARTS - a list of ULEB128 encoded offsets of each\n  //    function's start address in the\n  //                         binary, relative to the text section.\n  //    eh_frame           - the eh_frame FDEs have the start addr & size of\n  //    each function\n  //  LC_FUNCTION_STARTS is the fastest source to read in, and is present on\n  //  all modern binaries.\n  //  Binaries built to run on older releases may need to use eh_frame\n  //  information.\n\n  if (text_section_sp && function_starts_data.GetByteSize()) {\n    FunctionStarts::Entry function_start_entry;\n    function_start_entry.data = false;\n    lldb::offset_t function_start_offset = 0;\n    function_start_entry.addr = text_section_sp->GetFileAddress();\n    uint64_t delta;\n    while ((delta = function_starts_data.GetULEB128(&function_start_offset)) >\n           0) {\n      // Now append the current entry\n      function_start_entry.addr += delta;\n      if (is_arm) {\n        if (function_start_entry.addr & 1) {\n          function_start_entry.addr &= THUMB_ADDRESS_BIT_MASK;\n          function_start_entry.data = true;\n        } else if (always_thumb) {\n          function_start_entry.data = true;\n        }\n      }\n      function_starts.Append(function_start_entry);\n    }\n  } else {\n    // If m_type is eTypeDebugInfo, then this is a dSYM - it will have the\n    // load command claiming an eh_frame but it doesn't actually have the\n    // eh_frame content.  And if we have a dSYM, we don't need to do any of\n    // this fill-in-the-missing-symbols works anyway - the debug info should\n    // give us all the functions in the module.\n    if (text_section_sp.get() && eh_frame_section_sp.get() &&\n        m_type != eTypeDebugInfo) {\n      DWARFCallFrameInfo eh_frame(*this, eh_frame_section_sp,\n                                  DWARFCallFrameInfo::EH);\n      DWARFCallFrameInfo::FunctionAddressAndSizeVector functions;\n      eh_frame.GetFunctionAddressAndSizeVector(functions);\n      addr_t text_base_addr = text_section_sp->GetFileAddress();\n      size_t count = functions.GetSize();\n      for (size_t i = 0; i < count; ++i) {\n        const DWARFCallFrameInfo::FunctionAddressAndSizeVector::Entry *func =\n            functions.GetEntryAtIndex(i);\n        if (func) {\n          FunctionStarts::Entry function_start_entry;\n          function_start_entry.addr = func->base - text_base_addr;\n          if (is_arm) {\n            if (function_start_entry.addr & 1) {\n              function_start_entry.addr &= THUMB_ADDRESS_BIT_MASK;\n              function_start_entry.data = true;\n            } else if (always_thumb) {\n              function_start_entry.data = true;\n            }\n          }\n          function_starts.Append(function_start_entry);\n        }\n      }\n    }\n  }\n\n  const size_t function_starts_count = function_starts.GetSize();\n\n  // For user process binaries (executables, dylibs, frameworks, bundles), if\n  // we don't have LC_FUNCTION_STARTS/eh_frame section in this binary, we're\n  // going to assume the binary has been stripped.  Don't allow assembly\n  // language instruction emulation because we don't know proper function\n  // start boundaries.\n  //\n  // For all other types of binaries (kernels, stand-alone bare board\n  // binaries, kexts), they may not have LC_FUNCTION_STARTS / eh_frame\n  // sections - we should not make any assumptions about them based on that.\n  if (function_starts_count == 0 && CalculateStrata() == eStrataUser) {\n    m_allow_assembly_emulation_unwind_plans = false;\n    Log *unwind_or_symbol_log(lldb_private::GetLogIfAnyCategoriesSet(\n        LIBLLDB_LOG_SYMBOLS | LIBLLDB_LOG_UNWIND));\n\n    if (unwind_or_symbol_log)\n      module_sp->LogMessage(\n          unwind_or_symbol_log,\n          \"no LC_FUNCTION_STARTS, will not allow assembly profiled unwinds\");\n  }\n\n  const user_id_t TEXT_eh_frame_sectID = eh_frame_section_sp.get()\n                                             ? eh_frame_section_sp->GetID()\n                                             : static_cast<user_id_t>(NO_SECT);\n\n  lldb::offset_t nlist_data_offset = 0;\n\n  uint32_t N_SO_index = UINT32_MAX;\n\n  MachSymtabSectionInfo section_info(section_list);\n  std::vector<uint32_t> N_FUN_indexes;\n  std::vector<uint32_t> N_NSYM_indexes;\n  std::vector<uint32_t> N_INCL_indexes;\n  std::vector<uint32_t> N_BRAC_indexes;\n  std::vector<uint32_t> N_COMM_indexes;\n  typedef std::multimap<uint64_t, uint32_t> ValueToSymbolIndexMap;\n  typedef llvm::DenseMap<uint32_t, uint32_t> NListIndexToSymbolIndexMap;\n  typedef llvm::DenseMap<const char *, uint32_t> ConstNameToSymbolIndexMap;\n  ValueToSymbolIndexMap N_FUN_addr_to_sym_idx;\n  ValueToSymbolIndexMap N_STSYM_addr_to_sym_idx;\n  ConstNameToSymbolIndexMap N_GSYM_name_to_sym_idx;\n  // Any symbols that get merged into another will get an entry in this map\n  // so we know\n  NListIndexToSymbolIndexMap m_nlist_idx_to_sym_idx;\n  uint32_t nlist_idx = 0;\n  Symbol *symbol_ptr = nullptr;\n\n  uint32_t sym_idx = 0;\n  Symbol *sym = nullptr;\n  size_t num_syms = 0;\n  std::string memory_symbol_name;\n  uint32_t unmapped_local_symbols_found = 0;\n\n  std::vector<TrieEntryWithOffset> reexport_trie_entries;\n  std::vector<TrieEntryWithOffset> external_sym_trie_entries;\n  std::set<lldb::addr_t> resolver_addresses;\n\n  if (dyld_trie_data.GetByteSize() > 0) {\n    ConstString text_segment_name(\"__TEXT\");\n    SectionSP text_segment_sp =\n        GetSectionList()->FindSectionByName(text_segment_name);\n    lldb::addr_t text_segment_file_addr = LLDB_INVALID_ADDRESS;\n    if (text_segment_sp)\n      text_segment_file_addr = text_segment_sp->GetFileAddress();\n    std::vector<llvm::StringRef> nameSlices;\n    ParseTrieEntries(dyld_trie_data, 0, is_arm, text_segment_file_addr,\n                     nameSlices, resolver_addresses, reexport_trie_entries,\n                     external_sym_trie_entries);\n  }\n\n  typedef std::set<ConstString> IndirectSymbols;\n  IndirectSymbols indirect_symbol_names;\n\n#if TARGET_OS_IPHONE\n\n  // Some recent builds of the dyld_shared_cache (hereafter: DSC) have been\n  // optimized by moving LOCAL symbols out of the memory mapped portion of\n  // the DSC. The symbol information has all been retained, but it isn't\n  // available in the normal nlist data. However, there *are* duplicate\n  // entries of *some*\n  // LOCAL symbols in the normal nlist data. To handle this situation\n  // correctly, we must first attempt\n  // to parse any DSC unmapped symbol information. If we find any, we set a\n  // flag that tells the normal nlist parser to ignore all LOCAL symbols.\n\n  if (m_header.flags & MH_DYLIB_IN_CACHE) {\n    // Before we can start mapping the DSC, we need to make certain the\n    // target process is actually using the cache we can find.\n\n    // Next we need to determine the correct path for the dyld shared cache.\n\n    ArchSpec header_arch = GetArchitecture();\n    char dsc_path[PATH_MAX];\n    char dsc_path_development[PATH_MAX];\n\n    snprintf(\n        dsc_path, sizeof(dsc_path), \"%s%s%s\",\n        \"/System/Library/Caches/com.apple.dyld/\", /* IPHONE_DYLD_SHARED_CACHE_DIR\n                                                   */\n        \"dyld_shared_cache_\", /* DYLD_SHARED_CACHE_BASE_NAME */\n        header_arch.GetArchitectureName());\n\n    snprintf(\n        dsc_path_development, sizeof(dsc_path), \"%s%s%s%s\",\n        \"/System/Library/Caches/com.apple.dyld/\", /* IPHONE_DYLD_SHARED_CACHE_DIR\n                                                   */\n        \"dyld_shared_cache_\", /* DYLD_SHARED_CACHE_BASE_NAME */\n        header_arch.GetArchitectureName(), \".development\");\n\n    FileSpec dsc_nondevelopment_filespec(dsc_path);\n    FileSpec dsc_development_filespec(dsc_path_development);\n    FileSpec dsc_filespec;\n\n    UUID dsc_uuid;\n    UUID process_shared_cache_uuid;\n    addr_t process_shared_cache_base_addr;\n\n    if (process) {\n      GetProcessSharedCacheUUID(process, process_shared_cache_base_addr,\n                                process_shared_cache_uuid);\n    }\n\n    // First see if we can find an exact match for the inferior process\n    // shared cache UUID in the development or non-development shared caches\n    // on disk.\n    if (process_shared_cache_uuid.IsValid()) {\n      if (FileSystem::Instance().Exists(dsc_development_filespec)) {\n        UUID dsc_development_uuid = GetSharedCacheUUID(\n            dsc_development_filespec, byte_order, addr_byte_size);\n        if (dsc_development_uuid.IsValid() &&\n            dsc_development_uuid == process_shared_cache_uuid) {\n          dsc_filespec = dsc_development_filespec;\n          dsc_uuid = dsc_development_uuid;\n        }\n      }\n      if (!dsc_uuid.IsValid() &&\n          FileSystem::Instance().Exists(dsc_nondevelopment_filespec)) {\n        UUID dsc_nondevelopment_uuid = GetSharedCacheUUID(\n            dsc_nondevelopment_filespec, byte_order, addr_byte_size);\n        if (dsc_nondevelopment_uuid.IsValid() &&\n            dsc_nondevelopment_uuid == process_shared_cache_uuid) {\n          dsc_filespec = dsc_nondevelopment_filespec;\n          dsc_uuid = dsc_nondevelopment_uuid;\n        }\n      }\n    }\n\n    // Failing a UUID match, prefer the development dyld_shared cache if both\n    // are present.\n    if (!FileSystem::Instance().Exists(dsc_filespec)) {\n      if (FileSystem::Instance().Exists(dsc_development_filespec)) {\n        dsc_filespec = dsc_development_filespec;\n      } else {\n        dsc_filespec = dsc_nondevelopment_filespec;\n      }\n    }\n\n    /* The dyld_cache_header has a pointer to the\n       dyld_cache_local_symbols_info structure (localSymbolsOffset).\n       The dyld_cache_local_symbols_info structure gives us three things:\n         1. The start and count of the nlist records in the dyld_shared_cache\n       file\n         2. The start and size of the strings for these nlist records\n         3. The start and count of dyld_cache_local_symbols_entry entries\n\n       There is one dyld_cache_local_symbols_entry per dylib/framework in the\n       dyld shared cache.\n       The \"dylibOffset\" field is the Mach-O header of this dylib/framework in\n       the dyld shared cache.\n       The dyld_cache_local_symbols_entry also lists the start of this\n       dylib/framework's nlist records\n       and the count of how many nlist records there are for this\n       dylib/framework.\n    */\n\n    // Process the dyld shared cache header to find the unmapped symbols\n\n    DataBufferSP dsc_data_sp = MapFileData(\n        dsc_filespec, sizeof(struct lldb_copy_dyld_cache_header_v1), 0);\n    if (!dsc_uuid.IsValid()) {\n      dsc_uuid = GetSharedCacheUUID(dsc_filespec, byte_order, addr_byte_size);\n    }\n    if (dsc_data_sp) {\n      DataExtractor dsc_header_data(dsc_data_sp, byte_order, addr_byte_size);\n\n      bool uuid_match = true;\n      if (dsc_uuid.IsValid() && process) {\n        if (process_shared_cache_uuid.IsValid() &&\n            dsc_uuid != process_shared_cache_uuid) {\n          // The on-disk dyld_shared_cache file is not the same as the one in\n          // this process' memory, don't use it.\n          uuid_match = false;\n          ModuleSP module_sp(GetModule());\n          if (module_sp)\n            module_sp->ReportWarning(\"process shared cache does not match \"\n                                     \"on-disk dyld_shared_cache file, some \"\n                                     \"symbol names will be missing.\");\n        }\n      }\n\n      offset = offsetof(struct lldb_copy_dyld_cache_header_v1, mappingOffset);\n\n      uint32_t mappingOffset = dsc_header_data.GetU32(&offset);\n\n      // If the mappingOffset points to a location inside the header, we've\n      // opened an old dyld shared cache, and should not proceed further.\n      if (uuid_match &&\n          mappingOffset >= sizeof(struct lldb_copy_dyld_cache_header_v1)) {\n\n        DataBufferSP dsc_mapping_info_data_sp = MapFileData(\n            dsc_filespec, sizeof(struct lldb_copy_dyld_cache_mapping_info),\n            mappingOffset);\n\n        DataExtractor dsc_mapping_info_data(dsc_mapping_info_data_sp,\n                                            byte_order, addr_byte_size);\n        offset = 0;\n\n        // The File addresses (from the in-memory Mach-O load commands) for\n        // the shared libraries in the shared library cache need to be\n        // adjusted by an offset to match up with the dylibOffset identifying\n        // field in the dyld_cache_local_symbol_entry's.  This offset is\n        // recorded in mapping_offset_value.\n        const uint64_t mapping_offset_value =\n            dsc_mapping_info_data.GetU64(&offset);\n\n        offset =\n            offsetof(struct lldb_copy_dyld_cache_header_v1, localSymbolsOffset);\n        uint64_t localSymbolsOffset = dsc_header_data.GetU64(&offset);\n        uint64_t localSymbolsSize = dsc_header_data.GetU64(&offset);\n\n        if (localSymbolsOffset && localSymbolsSize) {\n          // Map the local symbols\n          DataBufferSP dsc_local_symbols_data_sp =\n              MapFileData(dsc_filespec, localSymbolsSize, localSymbolsOffset);\n\n          if (dsc_local_symbols_data_sp) {\n            DataExtractor dsc_local_symbols_data(dsc_local_symbols_data_sp,\n                                                 byte_order, addr_byte_size);\n\n            offset = 0;\n\n            typedef llvm::DenseMap<ConstString, uint16_t> UndefinedNameToDescMap;\n            typedef llvm::DenseMap<uint32_t, ConstString> SymbolIndexToName;\n            UndefinedNameToDescMap undefined_name_to_desc;\n            SymbolIndexToName reexport_shlib_needs_fixup;\n\n            // Read the local_symbols_infos struct in one shot\n            struct lldb_copy_dyld_cache_local_symbols_info local_symbols_info;\n            dsc_local_symbols_data.GetU32(&offset,\n                                          &local_symbols_info.nlistOffset, 6);\n\n            SectionSP text_section_sp(\n                section_list->FindSectionByName(GetSegmentNameTEXT()));\n\n            uint32_t header_file_offset =\n                (text_section_sp->GetFileAddress() - mapping_offset_value);\n\n            offset = local_symbols_info.entriesOffset;\n            for (uint32_t entry_index = 0;\n                 entry_index < local_symbols_info.entriesCount; entry_index++) {\n              struct lldb_copy_dyld_cache_local_symbols_entry\n                  local_symbols_entry;\n              local_symbols_entry.dylibOffset =\n                  dsc_local_symbols_data.GetU32(&offset);\n              local_symbols_entry.nlistStartIndex =\n                  dsc_local_symbols_data.GetU32(&offset);\n              local_symbols_entry.nlistCount =\n                  dsc_local_symbols_data.GetU32(&offset);\n\n              if (header_file_offset == local_symbols_entry.dylibOffset) {\n                unmapped_local_symbols_found = local_symbols_entry.nlistCount;\n\n                // The normal nlist code cannot correctly size the Symbols\n                // array, we need to allocate it here.\n                sym = symtab->Resize(\n                    symtab_load_command.nsyms + m_dysymtab.nindirectsyms +\n                    unmapped_local_symbols_found - m_dysymtab.nlocalsym);\n                num_syms = symtab->GetNumSymbols();\n\n                nlist_data_offset =\n                    local_symbols_info.nlistOffset +\n                    (nlist_byte_size * local_symbols_entry.nlistStartIndex);\n                uint32_t string_table_offset = local_symbols_info.stringsOffset;\n\n                for (uint32_t nlist_index = 0;\n                     nlist_index < local_symbols_entry.nlistCount;\n                     nlist_index++) {\n                  /////////////////////////////\n                  {\n                    llvm::Optional<struct nlist_64> nlist_maybe =\n                        ParseNList(dsc_local_symbols_data, nlist_data_offset,\n                                   nlist_byte_size);\n                    if (!nlist_maybe)\n                      break;\n                    struct nlist_64 nlist = *nlist_maybe;\n\n                    SymbolType type = eSymbolTypeInvalid;\n                    const char *symbol_name = dsc_local_symbols_data.PeekCStr(\n                        string_table_offset + nlist.n_strx);\n\n                    if (symbol_name == NULL) {\n                      // No symbol should be NULL, even the symbols with no\n                      // string values should have an offset zero which\n                      // points to an empty C-string\n                      Host::SystemLog(\n                          Host::eSystemLogError,\n                          \"error: DSC unmapped local symbol[%u] has invalid \"\n                          \"string table offset 0x%x in %s, ignoring symbol\\n\",\n                          entry_index, nlist.n_strx,\n                          module_sp->GetFileSpec().GetPath().c_str());\n                      continue;\n                    }\n                    if (symbol_name[0] == '\\0')\n                      symbol_name = NULL;\n\n                    const char *symbol_name_non_abi_mangled = NULL;\n\n                    SectionSP symbol_section;\n                    uint32_t symbol_byte_size = 0;\n                    bool add_nlist = true;\n                    bool is_debug = ((nlist.n_type & N_STAB) != 0);\n                    bool demangled_is_synthesized = false;\n                    bool is_gsym = false;\n                    bool set_value = true;\n\n                    assert(sym_idx < num_syms);\n\n                    sym[sym_idx].SetDebug(is_debug);\n\n                    if (is_debug) {\n                      switch (nlist.n_type) {\n                      case N_GSYM:\n                        // global symbol: name,,NO_SECT,type,0\n                        // Sometimes the N_GSYM value contains the address.\n\n                        // FIXME: In the .o files, we have a GSYM and a debug\n                        // symbol for all the ObjC data.  They\n                        // have the same address, but we want to ensure that\n                        // we always find only the real symbol, 'cause we\n                        // don't currently correctly attribute the\n                        // GSYM one to the ObjCClass/Ivar/MetaClass\n                        // symbol type.  This is a temporary hack to make\n                        // sure the ObjectiveC symbols get treated correctly.\n                        // To do this right, we should coalesce all the GSYM\n                        // & global symbols that have the same address.\n\n                        is_gsym = true;\n                        sym[sym_idx].SetExternal(true);\n\n                        if (symbol_name && symbol_name[0] == '_' &&\n                            symbol_name[1] == 'O') {\n                          llvm::StringRef symbol_name_ref(symbol_name);\n                          if (symbol_name_ref.startswith(\n                                  g_objc_v2_prefix_class)) {\n                            symbol_name_non_abi_mangled = symbol_name + 1;\n                            symbol_name =\n                                symbol_name + g_objc_v2_prefix_class.size();\n                            type = eSymbolTypeObjCClass;\n                            demangled_is_synthesized = true;\n\n                          } else if (symbol_name_ref.startswith(\n                                         g_objc_v2_prefix_metaclass)) {\n                            symbol_name_non_abi_mangled = symbol_name + 1;\n                            symbol_name =\n                                symbol_name + g_objc_v2_prefix_metaclass.size();\n                            type = eSymbolTypeObjCMetaClass;\n                            demangled_is_synthesized = true;\n                          } else if (symbol_name_ref.startswith(\n                                         g_objc_v2_prefix_ivar)) {\n                            symbol_name_non_abi_mangled = symbol_name + 1;\n                            symbol_name =\n                                symbol_name + g_objc_v2_prefix_ivar.size();\n                            type = eSymbolTypeObjCIVar;\n                            demangled_is_synthesized = true;\n                          }\n                        } else {\n                          if (nlist.n_value != 0)\n                            symbol_section = section_info.GetSection(\n                                nlist.n_sect, nlist.n_value);\n                          type = eSymbolTypeData;\n                        }\n                        break;\n\n                      case N_FNAME:\n                        // procedure name (f77 kludge): name,,NO_SECT,0,0\n                        type = eSymbolTypeCompiler;\n                        break;\n\n                      case N_FUN:\n                        // procedure: name,,n_sect,linenumber,address\n                        if (symbol_name) {\n                          type = eSymbolTypeCode;\n                          symbol_section = section_info.GetSection(\n                              nlist.n_sect, nlist.n_value);\n\n                          N_FUN_addr_to_sym_idx.insert(\n                              std::make_pair(nlist.n_value, sym_idx));\n                          // We use the current number of symbols in the\n                          // symbol table in lieu of using nlist_idx in case\n                          // we ever start trimming entries out\n                          N_FUN_indexes.push_back(sym_idx);\n                        } else {\n                          type = eSymbolTypeCompiler;\n\n                          if (!N_FUN_indexes.empty()) {\n                            // Copy the size of the function into the\n                            // original\n                            // STAB entry so we don't have\n                            // to hunt for it later\n                            symtab->SymbolAtIndex(N_FUN_indexes.back())\n                                ->SetByteSize(nlist.n_value);\n                            N_FUN_indexes.pop_back();\n                            // We don't really need the end function STAB as\n                            // it contains the size which we already placed\n                            // with the original symbol, so don't add it if\n                            // we want a minimal symbol table\n                            add_nlist = false;\n                          }\n                        }\n                        break;\n\n                      case N_STSYM:\n                        // static symbol: name,,n_sect,type,address\n                        N_STSYM_addr_to_sym_idx.insert(\n                            std::make_pair(nlist.n_value, sym_idx));\n                        symbol_section = section_info.GetSection(nlist.n_sect,\n                                                                 nlist.n_value);\n                        if (symbol_name && symbol_name[0]) {\n                          type = ObjectFile::GetSymbolTypeFromName(\n                              symbol_name + 1, eSymbolTypeData);\n                        }\n                        break;\n\n                      case N_LCSYM:\n                        // .lcomm symbol: name,,n_sect,type,address\n                        symbol_section = section_info.GetSection(nlist.n_sect,\n                                                                 nlist.n_value);\n                        type = eSymbolTypeCommonBlock;\n                        break;\n\n                      case N_BNSYM:\n                        // We use the current number of symbols in the symbol\n                        // table in lieu of using nlist_idx in case we ever\n                        // start trimming entries out Skip these if we want\n                        // minimal symbol tables\n                        add_nlist = false;\n                        break;\n\n                      case N_ENSYM:\n                        // Set the size of the N_BNSYM to the terminating\n                        // index of this N_ENSYM so that we can always skip\n                        // the entire symbol if we need to navigate more\n                        // quickly at the source level when parsing STABS\n                        // Skip these if we want minimal symbol tables\n                        add_nlist = false;\n                        break;\n\n                      case N_OPT:\n                        // emitted with gcc2_compiled and in gcc source\n                        type = eSymbolTypeCompiler;\n                        break;\n\n                      case N_RSYM:\n                        // register sym: name,,NO_SECT,type,register\n                        type = eSymbolTypeVariable;\n                        break;\n\n                      case N_SLINE:\n                        // src line: 0,,n_sect,linenumber,address\n                        symbol_section = section_info.GetSection(nlist.n_sect,\n                                                                 nlist.n_value);\n                        type = eSymbolTypeLineEntry;\n                        break;\n\n                      case N_SSYM:\n                        // structure elt: name,,NO_SECT,type,struct_offset\n                        type = eSymbolTypeVariableType;\n                        break;\n\n                      case N_SO:\n                        // source file name\n                        type = eSymbolTypeSourceFile;\n                        if (symbol_name == NULL) {\n                          add_nlist = false;\n                          if (N_SO_index != UINT32_MAX) {\n                            // Set the size of the N_SO to the terminating\n                            // index of this N_SO so that we can always skip\n                            // the entire N_SO if we need to navigate more\n                            // quickly at the source level when parsing STABS\n                            symbol_ptr = symtab->SymbolAtIndex(N_SO_index);\n                            symbol_ptr->SetByteSize(sym_idx);\n                            symbol_ptr->SetSizeIsSibling(true);\n                          }\n                          N_NSYM_indexes.clear();\n                          N_INCL_indexes.clear();\n                          N_BRAC_indexes.clear();\n                          N_COMM_indexes.clear();\n                          N_FUN_indexes.clear();\n                          N_SO_index = UINT32_MAX;\n                        } else {\n                          // We use the current number of symbols in the\n                          // symbol table in lieu of using nlist_idx in case\n                          // we ever start trimming entries out\n                          const bool N_SO_has_full_path = symbol_name[0] == '/';\n                          if (N_SO_has_full_path) {\n                            if ((N_SO_index == sym_idx - 1) &&\n                                ((sym_idx - 1) < num_syms)) {\n                              // We have two consecutive N_SO entries where\n                              // the first contains a directory and the\n                              // second contains a full path.\n                              sym[sym_idx - 1].GetMangled().SetValue(\n                                  ConstString(symbol_name), false);\n                              m_nlist_idx_to_sym_idx[nlist_idx] = sym_idx - 1;\n                              add_nlist = false;\n                            } else {\n                              // This is the first entry in a N_SO that\n                              // contains a directory or\n                              // a full path to the source file\n                              N_SO_index = sym_idx;\n                            }\n                          } else if ((N_SO_index == sym_idx - 1) &&\n                                     ((sym_idx - 1) < num_syms)) {\n                            // This is usually the second N_SO entry that\n                            // contains just the filename, so here we combine\n                            // it with the first one if we are minimizing the\n                            // symbol table\n                            const char *so_path = sym[sym_idx - 1]\n                                                      .GetMangled()\n                                                      .GetDemangledName()\n                                                      .AsCString();\n                            if (so_path && so_path[0]) {\n                              std::string full_so_path(so_path);\n                              const size_t double_slash_pos =\n                                  full_so_path.find(\"//\");\n                              if (double_slash_pos != std::string::npos) {\n                                // The linker has been generating bad N_SO\n                                // entries with doubled up paths\n                                // in the format \"%s%s\" where the first\n                                // string in the DW_AT_comp_dir, and the\n                                // second is the directory for the source\n                                // file so you end up with a path that looks\n                                // like \"/tmp/src//tmp/src/\"\n                                FileSpec so_dir(so_path);\n                                if (!FileSystem::Instance().Exists(so_dir)) {\n                                  so_dir.SetFile(\n                                      &full_so_path[double_slash_pos + 1],\n                                      FileSpec::Style::native);\n                                  if (FileSystem::Instance().Exists(so_dir)) {\n                                    // Trim off the incorrect path\n                                    full_so_path.erase(0, double_slash_pos + 1);\n                                  }\n                                }\n                              }\n                              if (*full_so_path.rbegin() != '/')\n                                full_so_path += '/';\n                              full_so_path += symbol_name;\n                              sym[sym_idx - 1].GetMangled().SetValue(\n                                  ConstString(full_so_path.c_str()), false);\n                              add_nlist = false;\n                              m_nlist_idx_to_sym_idx[nlist_idx] = sym_idx - 1;\n                            }\n                          } else {\n                            // This could be a relative path to a N_SO\n                            N_SO_index = sym_idx;\n                          }\n                        }\n                        break;\n\n                      case N_OSO:\n                        // object file name: name,,0,0,st_mtime\n                        type = eSymbolTypeObjectFile;\n                        break;\n\n                      case N_LSYM:\n                        // local sym: name,,NO_SECT,type,offset\n                        type = eSymbolTypeLocal;\n                        break;\n\n                      // INCL scopes\n                      case N_BINCL:\n                        // include file beginning: name,,NO_SECT,0,sum We use\n                        // the current number of symbols in the symbol table\n                        // in lieu of using nlist_idx in case we ever start\n                        // trimming entries out\n                        N_INCL_indexes.push_back(sym_idx);\n                        type = eSymbolTypeScopeBegin;\n                        break;\n\n                      case N_EINCL:\n                        // include file end: name,,NO_SECT,0,0\n                        // Set the size of the N_BINCL to the terminating\n                        // index of this N_EINCL so that we can always skip\n                        // the entire symbol if we need to navigate more\n                        // quickly at the source level when parsing STABS\n                        if (!N_INCL_indexes.empty()) {\n                          symbol_ptr =\n                              symtab->SymbolAtIndex(N_INCL_indexes.back());\n                          symbol_ptr->SetByteSize(sym_idx + 1);\n                          symbol_ptr->SetSizeIsSibling(true);\n                          N_INCL_indexes.pop_back();\n                        }\n                        type = eSymbolTypeScopeEnd;\n                        break;\n\n                      case N_SOL:\n                        // #included file name: name,,n_sect,0,address\n                        type = eSymbolTypeHeaderFile;\n\n                        // We currently don't use the header files on darwin\n                        add_nlist = false;\n                        break;\n\n                      case N_PARAMS:\n                        // compiler parameters: name,,NO_SECT,0,0\n                        type = eSymbolTypeCompiler;\n                        break;\n\n                      case N_VERSION:\n                        // compiler version: name,,NO_SECT,0,0\n                        type = eSymbolTypeCompiler;\n                        break;\n\n                      case N_OLEVEL:\n                        // compiler -O level: name,,NO_SECT,0,0\n                        type = eSymbolTypeCompiler;\n                        break;\n\n                      case N_PSYM:\n                        // parameter: name,,NO_SECT,type,offset\n                        type = eSymbolTypeVariable;\n                        break;\n\n                      case N_ENTRY:\n                        // alternate entry: name,,n_sect,linenumber,address\n                        symbol_section = section_info.GetSection(nlist.n_sect,\n                                                                 nlist.n_value);\n                        type = eSymbolTypeLineEntry;\n                        break;\n\n                      // Left and Right Braces\n                      case N_LBRAC:\n                        // left bracket: 0,,NO_SECT,nesting level,address We\n                        // use the current number of symbols in the symbol\n                        // table in lieu of using nlist_idx in case we ever\n                        // start trimming entries out\n                        symbol_section = section_info.GetSection(nlist.n_sect,\n                                                                 nlist.n_value);\n                        N_BRAC_indexes.push_back(sym_idx);\n                        type = eSymbolTypeScopeBegin;\n                        break;\n\n                      case N_RBRAC:\n                        // right bracket: 0,,NO_SECT,nesting level,address\n                        // Set the size of the N_LBRAC to the terminating\n                        // index of this N_RBRAC so that we can always skip\n                        // the entire symbol if we need to navigate more\n                        // quickly at the source level when parsing STABS\n                        symbol_section = section_info.GetSection(nlist.n_sect,\n                                                                 nlist.n_value);\n                        if (!N_BRAC_indexes.empty()) {\n                          symbol_ptr =\n                              symtab->SymbolAtIndex(N_BRAC_indexes.back());\n                          symbol_ptr->SetByteSize(sym_idx + 1);\n                          symbol_ptr->SetSizeIsSibling(true);\n                          N_BRAC_indexes.pop_back();\n                        }\n                        type = eSymbolTypeScopeEnd;\n                        break;\n\n                      case N_EXCL:\n                        // deleted include file: name,,NO_SECT,0,sum\n                        type = eSymbolTypeHeaderFile;\n                        break;\n\n                      // COMM scopes\n                      case N_BCOMM:\n                        // begin common: name,,NO_SECT,0,0\n                        // We use the current number of symbols in the symbol\n                        // table in lieu of using nlist_idx in case we ever\n                        // start trimming entries out\n                        type = eSymbolTypeScopeBegin;\n                        N_COMM_indexes.push_back(sym_idx);\n                        break;\n\n                      case N_ECOML:\n                        // end common (local name): 0,,n_sect,0,address\n                        symbol_section = section_info.GetSection(nlist.n_sect,\n                                                                 nlist.n_value);\n                        // Fall through\n\n                      case N_ECOMM:\n                        // end common: name,,n_sect,0,0\n                        // Set the size of the N_BCOMM to the terminating\n                        // index of this N_ECOMM/N_ECOML so that we can\n                        // always skip the entire symbol if we need to\n                        // navigate more quickly at the source level when\n                        // parsing STABS\n                        if (!N_COMM_indexes.empty()) {\n                          symbol_ptr =\n                              symtab->SymbolAtIndex(N_COMM_indexes.back());\n                          symbol_ptr->SetByteSize(sym_idx + 1);\n                          symbol_ptr->SetSizeIsSibling(true);\n                          N_COMM_indexes.pop_back();\n                        }\n                        type = eSymbolTypeScopeEnd;\n                        break;\n\n                      case N_LENG:\n                        // second stab entry with length information\n                        type = eSymbolTypeAdditional;\n                        break;\n\n                      default:\n                        break;\n                      }\n                    } else {\n                      // uint8_t n_pext    = N_PEXT & nlist.n_type;\n                      uint8_t n_type = N_TYPE & nlist.n_type;\n                      sym[sym_idx].SetExternal((N_EXT & nlist.n_type) != 0);\n\n                      switch (n_type) {\n                      case N_INDR: {\n                        const char *reexport_name_cstr =\n                            strtab_data.PeekCStr(nlist.n_value);\n                        if (reexport_name_cstr && reexport_name_cstr[0]) {\n                          type = eSymbolTypeReExported;\n                          ConstString reexport_name(\n                              reexport_name_cstr +\n                              ((reexport_name_cstr[0] == '_') ? 1 : 0));\n                          sym[sym_idx].SetReExportedSymbolName(reexport_name);\n                          set_value = false;\n                          reexport_shlib_needs_fixup[sym_idx] = reexport_name;\n                          indirect_symbol_names.insert(ConstString(\n                              symbol_name + ((symbol_name[0] == '_') ? 1 : 0)));\n                        } else\n                          type = eSymbolTypeUndefined;\n                      } break;\n\n                      case N_UNDF:\n                        if (symbol_name && symbol_name[0]) {\n                          ConstString undefined_name(\n                              symbol_name + ((symbol_name[0] == '_') ? 1 : 0));\n                          undefined_name_to_desc[undefined_name] = nlist.n_desc;\n                        }\n                      // Fall through\n                      case N_PBUD:\n                        type = eSymbolTypeUndefined;\n                        break;\n\n                      case N_ABS:\n                        type = eSymbolTypeAbsolute;\n                        break;\n\n                      case N_SECT: {\n                        symbol_section = section_info.GetSection(nlist.n_sect,\n                                                                 nlist.n_value);\n\n                        if (symbol_section == NULL) {\n                          // TODO: warn about this?\n                          add_nlist = false;\n                          break;\n                        }\n\n                        if (TEXT_eh_frame_sectID == nlist.n_sect) {\n                          type = eSymbolTypeException;\n                        } else {\n                          uint32_t section_type =\n                              symbol_section->Get() & SECTION_TYPE;\n\n                          switch (section_type) {\n                          case S_CSTRING_LITERALS:\n                            type = eSymbolTypeData;\n                            break; // section with only literal C strings\n                          case S_4BYTE_LITERALS:\n                            type = eSymbolTypeData;\n                            break; // section with only 4 byte literals\n                          case S_8BYTE_LITERALS:\n                            type = eSymbolTypeData;\n                            break; // section with only 8 byte literals\n                          case S_LITERAL_POINTERS:\n                            type = eSymbolTypeTrampoline;\n                            break; // section with only pointers to literals\n                          case S_NON_LAZY_SYMBOL_POINTERS:\n                            type = eSymbolTypeTrampoline;\n                            break; // section with only non-lazy symbol\n                                   // pointers\n                          case S_LAZY_SYMBOL_POINTERS:\n                            type = eSymbolTypeTrampoline;\n                            break; // section with only lazy symbol pointers\n                          case S_SYMBOL_STUBS:\n                            type = eSymbolTypeTrampoline;\n                            break; // section with only symbol stubs, byte\n                                   // size of stub in the reserved2 field\n                          case S_MOD_INIT_FUNC_POINTERS:\n                            type = eSymbolTypeCode;\n                            break; // section with only function pointers for\n                                   // initialization\n                          case S_MOD_TERM_FUNC_POINTERS:\n                            type = eSymbolTypeCode;\n                            break; // section with only function pointers for\n                                   // termination\n                          case S_INTERPOSING:\n                            type = eSymbolTypeTrampoline;\n                            break; // section with only pairs of function\n                                   // pointers for interposing\n                          case S_16BYTE_LITERALS:\n                            type = eSymbolTypeData;\n                            break; // section with only 16 byte literals\n                          case S_DTRACE_DOF:\n                            type = eSymbolTypeInstrumentation;\n                            break;\n                          case S_LAZY_DYLIB_SYMBOL_POINTERS:\n                            type = eSymbolTypeTrampoline;\n                            break;\n                          default:\n                            switch (symbol_section->GetType()) {\n                            case lldb::eSectionTypeCode:\n                              type = eSymbolTypeCode;\n                              break;\n                            case eSectionTypeData:\n                            case eSectionTypeDataCString: // Inlined C string\n                                                          // data\n                            case eSectionTypeDataCStringPointers: // Pointers\n                                                                  // to C\n                                                                  // string\n                                                                  // data\n                            case eSectionTypeDataSymbolAddress:   // Address of\n                                                                  // a symbol in\n                                                                  // the symbol\n                                                                  // table\n                            case eSectionTypeData4:\n                            case eSectionTypeData8:\n                            case eSectionTypeData16:\n                              type = eSymbolTypeData;\n                              break;\n                            default:\n                              break;\n                            }\n                            break;\n                          }\n\n                          if (type == eSymbolTypeInvalid) {\n                            const char *symbol_sect_name =\n                                symbol_section->GetName().AsCString();\n                            if (symbol_section->IsDescendant(\n                                    text_section_sp.get())) {\n                              if (symbol_section->IsClear(\n                                      S_ATTR_PURE_INSTRUCTIONS |\n                                      S_ATTR_SELF_MODIFYING_CODE |\n                                      S_ATTR_SOME_INSTRUCTIONS))\n                                type = eSymbolTypeData;\n                              else\n                                type = eSymbolTypeCode;\n                            } else if (symbol_section->IsDescendant(\n                                           data_section_sp.get()) ||\n                                       symbol_section->IsDescendant(\n                                           data_dirty_section_sp.get()) ||\n                                       symbol_section->IsDescendant(\n                                           data_const_section_sp.get())) {\n                              if (symbol_sect_name &&\n                                  ::strstr(symbol_sect_name, \"__objc\") ==\n                                      symbol_sect_name) {\n                                type = eSymbolTypeRuntime;\n\n                                if (symbol_name) {\n                                  llvm::StringRef symbol_name_ref(symbol_name);\n                                  if (symbol_name_ref.startswith(\"_OBJC_\")) {\n                                    llvm::StringRef\n                                        g_objc_v2_prefix_class(\n                                            \"_OBJC_CLASS_$_\");\n                                    llvm::StringRef\n                                        g_objc_v2_prefix_metaclass(\n                                            \"_OBJC_METACLASS_$_\");\n                                    llvm::StringRef\n                                        g_objc_v2_prefix_ivar(\"_OBJC_IVAR_$_\");\n                                    if (symbol_name_ref.startswith(\n                                            g_objc_v2_prefix_class)) {\n                                      symbol_name_non_abi_mangled =\n                                          symbol_name + 1;\n                                      symbol_name =\n                                          symbol_name +\n                                          g_objc_v2_prefix_class.size();\n                                      type = eSymbolTypeObjCClass;\n                                      demangled_is_synthesized = true;\n                                    } else if (\n                                        symbol_name_ref.startswith(\n                                            g_objc_v2_prefix_metaclass)) {\n                                      symbol_name_non_abi_mangled =\n                                          symbol_name + 1;\n                                      symbol_name =\n                                          symbol_name +\n                                          g_objc_v2_prefix_metaclass.size();\n                                      type = eSymbolTypeObjCMetaClass;\n                                      demangled_is_synthesized = true;\n                                    } else if (symbol_name_ref.startswith(\n                                                   g_objc_v2_prefix_ivar)) {\n                                      symbol_name_non_abi_mangled =\n                                          symbol_name + 1;\n                                      symbol_name =\n                                          symbol_name +\n                                          g_objc_v2_prefix_ivar.size();\n                                      type = eSymbolTypeObjCIVar;\n                                      demangled_is_synthesized = true;\n                                    }\n                                  }\n                                }\n                              } else if (symbol_sect_name &&\n                                         ::strstr(symbol_sect_name,\n                                                  \"__gcc_except_tab\") ==\n                                             symbol_sect_name) {\n                                type = eSymbolTypeException;\n                              } else {\n                                type = eSymbolTypeData;\n                              }\n                            } else if (symbol_sect_name &&\n                                       ::strstr(symbol_sect_name, \"__IMPORT\") ==\n                                           symbol_sect_name) {\n                              type = eSymbolTypeTrampoline;\n                            } else if (symbol_section->IsDescendant(\n                                           objc_section_sp.get())) {\n                              type = eSymbolTypeRuntime;\n                              if (symbol_name && symbol_name[0] == '.') {\n                                llvm::StringRef symbol_name_ref(symbol_name);\n                                llvm::StringRef\n                                    g_objc_v1_prefix_class(\".objc_class_name_\");\n                                if (symbol_name_ref.startswith(\n                                        g_objc_v1_prefix_class)) {\n                                  symbol_name_non_abi_mangled = symbol_name;\n                                  symbol_name = symbol_name +\n                                                g_objc_v1_prefix_class.size();\n                                  type = eSymbolTypeObjCClass;\n                                  demangled_is_synthesized = true;\n                                }\n                              }\n                            }\n                          }\n                        }\n                      } break;\n                      }\n                    }\n\n                    if (add_nlist) {\n                      uint64_t symbol_value = nlist.n_value;\n                      if (symbol_name_non_abi_mangled) {\n                        sym[sym_idx].GetMangled().SetMangledName(\n                            ConstString(symbol_name_non_abi_mangled));\n                        sym[sym_idx].GetMangled().SetDemangledName(\n                            ConstString(symbol_name));\n                      } else {\n                        bool symbol_name_is_mangled = false;\n\n                        if (symbol_name && symbol_name[0] == '_') {\n                          symbol_name_is_mangled = symbol_name[1] == '_';\n                          symbol_name++; // Skip the leading underscore\n                        }\n\n                        if (symbol_name) {\n                          ConstString const_symbol_name(symbol_name);\n                          sym[sym_idx].GetMangled().SetValue(\n                              const_symbol_name, symbol_name_is_mangled);\n                          if (is_gsym && is_debug) {\n                            const char *gsym_name =\n                                sym[sym_idx]\n                                    .GetMangled()\n                                    .GetName(Mangled::ePreferMangled)\n                                    .GetCString();\n                            if (gsym_name)\n                              N_GSYM_name_to_sym_idx[gsym_name] = sym_idx;\n                          }\n                        }\n                      }\n                      if (symbol_section) {\n                        const addr_t section_file_addr =\n                            symbol_section->GetFileAddress();\n                        if (symbol_byte_size == 0 &&\n                            function_starts_count > 0) {\n                          addr_t symbol_lookup_file_addr = nlist.n_value;\n                          // Do an exact address match for non-ARM addresses,\n                          // else get the closest since the symbol might be a\n                          // thumb symbol which has an address with bit zero\n                          // set\n                          FunctionStarts::Entry *func_start_entry =\n                              function_starts.FindEntry(symbol_lookup_file_addr,\n                                                        !is_arm);\n                          if (is_arm && func_start_entry) {\n                            // Verify that the function start address is the\n                            // symbol address (ARM) or the symbol address + 1\n                            // (thumb)\n                            if (func_start_entry->addr !=\n                                    symbol_lookup_file_addr &&\n                                func_start_entry->addr !=\n                                    (symbol_lookup_file_addr + 1)) {\n                              // Not the right entry, NULL it out...\n                              func_start_entry = NULL;\n                            }\n                          }\n                          if (func_start_entry) {\n                            func_start_entry->data = true;\n\n                            addr_t symbol_file_addr = func_start_entry->addr;\n                            uint32_t symbol_flags = 0;\n                            if (is_arm) {\n                              if (symbol_file_addr & 1)\n                                symbol_flags = MACHO_NLIST_ARM_SYMBOL_IS_THUMB;\n                              symbol_file_addr &= THUMB_ADDRESS_BIT_MASK;\n                            }\n\n                            const FunctionStarts::Entry *next_func_start_entry =\n                                function_starts.FindNextEntry(func_start_entry);\n                            const addr_t section_end_file_addr =\n                                section_file_addr +\n                                symbol_section->GetByteSize();\n                            if (next_func_start_entry) {\n                              addr_t next_symbol_file_addr =\n                                  next_func_start_entry->addr;\n                              // Be sure the clear the Thumb address bit when\n                              // we calculate the size from the current and\n                              // next address\n                              if (is_arm)\n                                next_symbol_file_addr &= THUMB_ADDRESS_BIT_MASK;\n                              symbol_byte_size = std::min<lldb::addr_t>(\n                                  next_symbol_file_addr - symbol_file_addr,\n                                  section_end_file_addr - symbol_file_addr);\n                            } else {\n                              symbol_byte_size =\n                                  section_end_file_addr - symbol_file_addr;\n                            }\n                          }\n                        }\n                        symbol_value -= section_file_addr;\n                      }\n\n                      if (is_debug == false) {\n                        if (type == eSymbolTypeCode) {\n                          // See if we can find a N_FUN entry for any code\n                          // symbols. If we do find a match, and the name\n                          // matches, then we can merge the two into just the\n                          // function symbol to avoid duplicate entries in\n                          // the symbol table\n                          auto range =\n                              N_FUN_addr_to_sym_idx.equal_range(nlist.n_value);\n                          if (range.first != range.second) {\n                            bool found_it = false;\n                            for (auto pos = range.first; pos != range.second;\n                                 ++pos) {\n                              if (sym[sym_idx].GetMangled().GetName(\n                                      Mangled::ePreferMangled) ==\n                                  sym[pos->second].GetMangled().GetName(\n                                      Mangled::ePreferMangled)) {\n                                m_nlist_idx_to_sym_idx[nlist_idx] = pos->second;\n                                // We just need the flags from the linker\n                                // symbol, so put these flags\n                                // into the N_FUN flags to avoid duplicate\n                                // symbols in the symbol table\n                                sym[pos->second].SetExternal(\n                                    sym[sym_idx].IsExternal());\n                                sym[pos->second].SetFlags(nlist.n_type << 16 |\n                                                          nlist.n_desc);\n                                if (resolver_addresses.find(nlist.n_value) !=\n                                    resolver_addresses.end())\n                                  sym[pos->second].SetType(eSymbolTypeResolver);\n                                sym[sym_idx].Clear();\n                                found_it = true;\n                                break;\n                              }\n                            }\n                            if (found_it)\n                              continue;\n                          } else {\n                            if (resolver_addresses.find(nlist.n_value) !=\n                                resolver_addresses.end())\n                              type = eSymbolTypeResolver;\n                          }\n                        } else if (type == eSymbolTypeData ||\n                                   type == eSymbolTypeObjCClass ||\n                                   type == eSymbolTypeObjCMetaClass ||\n                                   type == eSymbolTypeObjCIVar) {\n                          // See if we can find a N_STSYM entry for any data\n                          // symbols. If we do find a match, and the name\n                          // matches, then we can merge the two into just the\n                          // Static symbol to avoid duplicate entries in the\n                          // symbol table\n                          auto range = N_STSYM_addr_to_sym_idx.equal_range(\n                              nlist.n_value);\n                          if (range.first != range.second) {\n                            bool found_it = false;\n                            for (auto pos = range.first; pos != range.second;\n                                 ++pos) {\n                              if (sym[sym_idx].GetMangled().GetName(\n                                      Mangled::ePreferMangled) ==\n                                  sym[pos->second].GetMangled().GetName(\n                                      Mangled::ePreferMangled)) {\n                                m_nlist_idx_to_sym_idx[nlist_idx] = pos->second;\n                                // We just need the flags from the linker\n                                // symbol, so put these flags\n                                // into the N_STSYM flags to avoid duplicate\n                                // symbols in the symbol table\n                                sym[pos->second].SetExternal(\n                                    sym[sym_idx].IsExternal());\n                                sym[pos->second].SetFlags(nlist.n_type << 16 |\n                                                          nlist.n_desc);\n                                sym[sym_idx].Clear();\n                                found_it = true;\n                                break;\n                              }\n                            }\n                            if (found_it)\n                              continue;\n                          } else {\n                            const char *gsym_name =\n                                sym[sym_idx]\n                                    .GetMangled()\n                                    .GetName(Mangled::ePreferMangled)\n                                    .GetCString();\n                            if (gsym_name) {\n                              // Combine N_GSYM stab entries with the non\n                              // stab symbol\n                              ConstNameToSymbolIndexMap::const_iterator pos =\n                                  N_GSYM_name_to_sym_idx.find(gsym_name);\n                              if (pos != N_GSYM_name_to_sym_idx.end()) {\n                                const uint32_t GSYM_sym_idx = pos->second;\n                                m_nlist_idx_to_sym_idx[nlist_idx] =\n                                    GSYM_sym_idx;\n                                // Copy the address, because often the N_GSYM\n                                // address has an invalid address of zero\n                                // when the global is a common symbol\n                                sym[GSYM_sym_idx].GetAddressRef().SetSection(\n                                    symbol_section);\n                                sym[GSYM_sym_idx].GetAddressRef().SetOffset(\n                                    symbol_value);\n                                symbols_added.insert(sym[GSYM_sym_idx]\n                                                         .GetAddress()\n                                                         .GetFileAddress());\n                                // We just need the flags from the linker\n                                // symbol, so put these flags\n                                // into the N_GSYM flags to avoid duplicate\n                                // symbols in the symbol table\n                                sym[GSYM_sym_idx].SetFlags(nlist.n_type << 16 |\n                                                           nlist.n_desc);\n                                sym[sym_idx].Clear();\n                                continue;\n                              }\n                            }\n                          }\n                        }\n                      }\n\n                      sym[sym_idx].SetID(nlist_idx);\n                      sym[sym_idx].SetType(type);\n                      if (set_value) {\n                        sym[sym_idx].GetAddressRef().SetSection(symbol_section);\n                        sym[sym_idx].GetAddressRef().SetOffset(symbol_value);\n                        symbols_added.insert(\n                            sym[sym_idx].GetAddress().GetFileAddress());\n                      }\n                      sym[sym_idx].SetFlags(nlist.n_type << 16 | nlist.n_desc);\n\n                      if (symbol_byte_size > 0)\n                        sym[sym_idx].SetByteSize(symbol_byte_size);\n\n                      if (demangled_is_synthesized)\n                        sym[sym_idx].SetDemangledNameIsSynthesized(true);\n                      ++sym_idx;\n                    } else {\n                      sym[sym_idx].Clear();\n                    }\n                  }\n                  /////////////////////////////\n                }\n                break; // No more entries to consider\n              }\n            }\n\n            for (const auto &pos : reexport_shlib_needs_fixup) {\n              const auto undef_pos = undefined_name_to_desc.find(pos.second);\n              if (undef_pos != undefined_name_to_desc.end()) {\n                const uint8_t dylib_ordinal =\n                    llvm::MachO::GET_LIBRARY_ORDINAL(undef_pos->second);\n                if (dylib_ordinal > 0 && dylib_ordinal < dylib_files.GetSize())\n                  sym[pos.first].SetReExportedSymbolSharedLibrary(\n                      dylib_files.GetFileSpecAtIndex(dylib_ordinal - 1));\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n\n  // Must reset this in case it was mutated above!\n  nlist_data_offset = 0;\n#endif\n\n  if (nlist_data.GetByteSize() > 0) {\n\n    // If the sym array was not created while parsing the DSC unmapped\n    // symbols, create it now.\n    if (sym == nullptr) {\n      sym =\n          symtab->Resize(symtab_load_command.nsyms + m_dysymtab.nindirectsyms);\n      num_syms = symtab->GetNumSymbols();\n    }\n\n    if (unmapped_local_symbols_found) {\n      assert(m_dysymtab.ilocalsym == 0);\n      nlist_data_offset += (m_dysymtab.nlocalsym * nlist_byte_size);\n      nlist_idx = m_dysymtab.nlocalsym;\n    } else {\n      nlist_idx = 0;\n    }\n\n    typedef llvm::DenseMap<ConstString, uint16_t> UndefinedNameToDescMap;\n    typedef llvm::DenseMap<uint32_t, ConstString> SymbolIndexToName;\n    UndefinedNameToDescMap undefined_name_to_desc;\n    SymbolIndexToName reexport_shlib_needs_fixup;\n\n    // Symtab parsing is a huge mess. Everything is entangled and the code\n    // requires access to a ridiculous amount of variables. LLDB depends\n    // heavily on the proper merging of symbols and to get that right we need\n    // to make sure we have parsed all the debug symbols first. Therefore we\n    // invoke the lambda twice, once to parse only the debug symbols and then\n    // once more to parse the remaining symbols.\n    auto ParseSymbolLambda = [&](struct nlist_64 &nlist, uint32_t nlist_idx,\n                                 bool debug_only) {\n      const bool is_debug = ((nlist.n_type & N_STAB) != 0);\n      if (is_debug != debug_only)\n        return true;\n\n      const char *symbol_name_non_abi_mangled = nullptr;\n      const char *symbol_name = nullptr;\n\n      if (have_strtab_data) {\n        symbol_name = strtab_data.PeekCStr(nlist.n_strx);\n\n        if (symbol_name == nullptr) {\n          // No symbol should be NULL, even the symbols with no string values\n          // should have an offset zero which points to an empty C-string\n          Host::SystemLog(Host::eSystemLogError,\n                          \"error: symbol[%u] has invalid string table offset \"\n                          \"0x%x in %s, ignoring symbol\\n\",\n                          nlist_idx, nlist.n_strx,\n                          module_sp->GetFileSpec().GetPath().c_str());\n          return true;\n        }\n        if (symbol_name[0] == '\\0')\n          symbol_name = nullptr;\n      } else {\n        const addr_t str_addr = strtab_addr + nlist.n_strx;\n        Status str_error;\n        if (process->ReadCStringFromMemory(str_addr, memory_symbol_name,\n                                           str_error))\n          symbol_name = memory_symbol_name.c_str();\n      }\n\n      SymbolType type = eSymbolTypeInvalid;\n      SectionSP symbol_section;\n      lldb::addr_t symbol_byte_size = 0;\n      bool add_nlist = true;\n      bool is_gsym = false;\n      bool demangled_is_synthesized = false;\n      bool set_value = true;\n\n      assert(sym_idx < num_syms);\n      sym[sym_idx].SetDebug(is_debug);\n\n      if (is_debug) {\n        switch (nlist.n_type) {\n        case N_GSYM:\n          // global symbol: name,,NO_SECT,type,0\n          // Sometimes the N_GSYM value contains the address.\n\n          // FIXME: In the .o files, we have a GSYM and a debug symbol for all\n          // the ObjC data.  They\n          // have the same address, but we want to ensure that we always find\n          // only the real symbol, 'cause we don't currently correctly\n          // attribute the GSYM one to the ObjCClass/Ivar/MetaClass symbol\n          // type.  This is a temporary hack to make sure the ObjectiveC\n          // symbols get treated correctly.  To do this right, we should\n          // coalesce all the GSYM & global symbols that have the same\n          // address.\n          is_gsym = true;\n          sym[sym_idx].SetExternal(true);\n\n          if (symbol_name && symbol_name[0] == '_' && symbol_name[1] == 'O') {\n            llvm::StringRef symbol_name_ref(symbol_name);\n            if (symbol_name_ref.startswith(g_objc_v2_prefix_class)) {\n              symbol_name_non_abi_mangled = symbol_name + 1;\n              symbol_name = symbol_name + g_objc_v2_prefix_class.size();\n              type = eSymbolTypeObjCClass;\n              demangled_is_synthesized = true;\n\n            } else if (symbol_name_ref.startswith(g_objc_v2_prefix_metaclass)) {\n              symbol_name_non_abi_mangled = symbol_name + 1;\n              symbol_name = symbol_name + g_objc_v2_prefix_metaclass.size();\n              type = eSymbolTypeObjCMetaClass;\n              demangled_is_synthesized = true;\n            } else if (symbol_name_ref.startswith(g_objc_v2_prefix_ivar)) {\n              symbol_name_non_abi_mangled = symbol_name + 1;\n              symbol_name = symbol_name + g_objc_v2_prefix_ivar.size();\n              type = eSymbolTypeObjCIVar;\n              demangled_is_synthesized = true;\n            }\n          } else {\n            if (nlist.n_value != 0)\n              symbol_section =\n                  section_info.GetSection(nlist.n_sect, nlist.n_value);\n            type = eSymbolTypeData;\n          }\n          break;\n\n        case N_FNAME:\n          // procedure name (f77 kludge): name,,NO_SECT,0,0\n          type = eSymbolTypeCompiler;\n          break;\n\n        case N_FUN:\n          // procedure: name,,n_sect,linenumber,address\n          if (symbol_name) {\n            type = eSymbolTypeCode;\n            symbol_section =\n                section_info.GetSection(nlist.n_sect, nlist.n_value);\n\n            N_FUN_addr_to_sym_idx.insert(\n                std::make_pair(nlist.n_value, sym_idx));\n            // We use the current number of symbols in the symbol table in\n            // lieu of using nlist_idx in case we ever start trimming entries\n            // out\n            N_FUN_indexes.push_back(sym_idx);\n          } else {\n            type = eSymbolTypeCompiler;\n\n            if (!N_FUN_indexes.empty()) {\n              // Copy the size of the function into the original STAB entry\n              // so we don't have to hunt for it later\n              symtab->SymbolAtIndex(N_FUN_indexes.back())\n                  ->SetByteSize(nlist.n_value);\n              N_FUN_indexes.pop_back();\n              // We don't really need the end function STAB as it contains\n              // the size which we already placed with the original symbol,\n              // so don't add it if we want a minimal symbol table\n              add_nlist = false;\n            }\n          }\n          break;\n\n        case N_STSYM:\n          // static symbol: name,,n_sect,type,address\n          N_STSYM_addr_to_sym_idx.insert(\n              std::make_pair(nlist.n_value, sym_idx));\n          symbol_section = section_info.GetSection(nlist.n_sect, nlist.n_value);\n          if (symbol_name && symbol_name[0]) {\n            type = ObjectFile::GetSymbolTypeFromName(symbol_name + 1,\n                                                     eSymbolTypeData);\n          }\n          break;\n\n        case N_LCSYM:\n          // .lcomm symbol: name,,n_sect,type,address\n          symbol_section = section_info.GetSection(nlist.n_sect, nlist.n_value);\n          type = eSymbolTypeCommonBlock;\n          break;\n\n        case N_BNSYM:\n          // We use the current number of symbols in the symbol table in lieu\n          // of using nlist_idx in case we ever start trimming entries out\n          // Skip these if we want minimal symbol tables\n          add_nlist = false;\n          break;\n\n        case N_ENSYM:\n          // Set the size of the N_BNSYM to the terminating index of this\n          // N_ENSYM so that we can always skip the entire symbol if we need\n          // to navigate more quickly at the source level when parsing STABS\n          // Skip these if we want minimal symbol tables\n          add_nlist = false;\n          break;\n\n        case N_OPT:\n          // emitted with gcc2_compiled and in gcc source\n          type = eSymbolTypeCompiler;\n          break;\n\n        case N_RSYM:\n          // register sym: name,,NO_SECT,type,register\n          type = eSymbolTypeVariable;\n          break;\n\n        case N_SLINE:\n          // src line: 0,,n_sect,linenumber,address\n          symbol_section = section_info.GetSection(nlist.n_sect, nlist.n_value);\n          type = eSymbolTypeLineEntry;\n          break;\n\n        case N_SSYM:\n          // structure elt: name,,NO_SECT,type,struct_offset\n          type = eSymbolTypeVariableType;\n          break;\n\n        case N_SO:\n          // source file name\n          type = eSymbolTypeSourceFile;\n          if (symbol_name == nullptr) {\n            add_nlist = false;\n            if (N_SO_index != UINT32_MAX) {\n              // Set the size of the N_SO to the terminating index of this\n              // N_SO so that we can always skip the entire N_SO if we need\n              // to navigate more quickly at the source level when parsing\n              // STABS\n              symbol_ptr = symtab->SymbolAtIndex(N_SO_index);\n              symbol_ptr->SetByteSize(sym_idx);\n              symbol_ptr->SetSizeIsSibling(true);\n            }\n            N_NSYM_indexes.clear();\n            N_INCL_indexes.clear();\n            N_BRAC_indexes.clear();\n            N_COMM_indexes.clear();\n            N_FUN_indexes.clear();\n            N_SO_index = UINT32_MAX;\n          } else {\n            // We use the current number of symbols in the symbol table in\n            // lieu of using nlist_idx in case we ever start trimming entries\n            // out\n            const bool N_SO_has_full_path = symbol_name[0] == '/';\n            if (N_SO_has_full_path) {\n              if ((N_SO_index == sym_idx - 1) && ((sym_idx - 1) < num_syms)) {\n                // We have two consecutive N_SO entries where the first\n                // contains a directory and the second contains a full path.\n                sym[sym_idx - 1].GetMangled().SetValue(ConstString(symbol_name),\n                                                       false);\n                m_nlist_idx_to_sym_idx[nlist_idx] = sym_idx - 1;\n                add_nlist = false;\n              } else {\n                // This is the first entry in a N_SO that contains a\n                // directory or a full path to the source file\n                N_SO_index = sym_idx;\n              }\n            } else if ((N_SO_index == sym_idx - 1) &&\n                       ((sym_idx - 1) < num_syms)) {\n              // This is usually the second N_SO entry that contains just the\n              // filename, so here we combine it with the first one if we are\n              // minimizing the symbol table\n              const char *so_path =\n                  sym[sym_idx - 1].GetMangled().GetDemangledName().AsCString();\n              if (so_path && so_path[0]) {\n                std::string full_so_path(so_path);\n                const size_t double_slash_pos = full_so_path.find(\"//\");\n                if (double_slash_pos != std::string::npos) {\n                  // The linker has been generating bad N_SO entries with\n                  // doubled up paths in the format \"%s%s\" where the first\n                  // string in the DW_AT_comp_dir, and the second is the\n                  // directory for the source file so you end up with a path\n                  // that looks like \"/tmp/src//tmp/src/\"\n                  FileSpec so_dir(so_path);\n                  if (!FileSystem::Instance().Exists(so_dir)) {\n                    so_dir.SetFile(&full_so_path[double_slash_pos + 1],\n                                   FileSpec::Style::native);\n                    if (FileSystem::Instance().Exists(so_dir)) {\n                      // Trim off the incorrect path\n                      full_so_path.erase(0, double_slash_pos + 1);\n                    }\n                  }\n                }\n                if (*full_so_path.rbegin() != '/')\n                  full_so_path += '/';\n                full_so_path += symbol_name;\n                sym[sym_idx - 1].GetMangled().SetValue(\n                    ConstString(full_so_path.c_str()), false);\n                add_nlist = false;\n                m_nlist_idx_to_sym_idx[nlist_idx] = sym_idx - 1;\n              }\n            } else {\n              // This could be a relative path to a N_SO\n              N_SO_index = sym_idx;\n            }\n          }\n          break;\n\n        case N_OSO:\n          // object file name: name,,0,0,st_mtime\n          type = eSymbolTypeObjectFile;\n          break;\n\n        case N_LSYM:\n          // local sym: name,,NO_SECT,type,offset\n          type = eSymbolTypeLocal;\n          break;\n\n        // INCL scopes\n        case N_BINCL:\n          // include file beginning: name,,NO_SECT,0,sum We use the current\n          // number of symbols in the symbol table in lieu of using nlist_idx\n          // in case we ever start trimming entries out\n          N_INCL_indexes.push_back(sym_idx);\n          type = eSymbolTypeScopeBegin;\n          break;\n\n        case N_EINCL:\n          // include file end: name,,NO_SECT,0,0\n          // Set the size of the N_BINCL to the terminating index of this\n          // N_EINCL so that we can always skip the entire symbol if we need\n          // to navigate more quickly at the source level when parsing STABS\n          if (!N_INCL_indexes.empty()) {\n            symbol_ptr = symtab->SymbolAtIndex(N_INCL_indexes.back());\n            symbol_ptr->SetByteSize(sym_idx + 1);\n            symbol_ptr->SetSizeIsSibling(true);\n            N_INCL_indexes.pop_back();\n          }\n          type = eSymbolTypeScopeEnd;\n          break;\n\n        case N_SOL:\n          // #included file name: name,,n_sect,0,address\n          type = eSymbolTypeHeaderFile;\n\n          // We currently don't use the header files on darwin\n          add_nlist = false;\n          break;\n\n        case N_PARAMS:\n          // compiler parameters: name,,NO_SECT,0,0\n          type = eSymbolTypeCompiler;\n          break;\n\n        case N_VERSION:\n          // compiler version: name,,NO_SECT,0,0\n          type = eSymbolTypeCompiler;\n          break;\n\n        case N_OLEVEL:\n          // compiler -O level: name,,NO_SECT,0,0\n          type = eSymbolTypeCompiler;\n          break;\n\n        case N_PSYM:\n          // parameter: name,,NO_SECT,type,offset\n          type = eSymbolTypeVariable;\n          break;\n\n        case N_ENTRY:\n          // alternate entry: name,,n_sect,linenumber,address\n          symbol_section = section_info.GetSection(nlist.n_sect, nlist.n_value);\n          type = eSymbolTypeLineEntry;\n          break;\n\n        // Left and Right Braces\n        case N_LBRAC:\n          // left bracket: 0,,NO_SECT,nesting level,address We use the\n          // current number of symbols in the symbol table in lieu of using\n          // nlist_idx in case we ever start trimming entries out\n          symbol_section = section_info.GetSection(nlist.n_sect, nlist.n_value);\n          N_BRAC_indexes.push_back(sym_idx);\n          type = eSymbolTypeScopeBegin;\n          break;\n\n        case N_RBRAC:\n          // right bracket: 0,,NO_SECT,nesting level,address Set the size of\n          // the N_LBRAC to the terminating index of this N_RBRAC so that we\n          // can always skip the entire symbol if we need to navigate more\n          // quickly at the source level when parsing STABS\n          symbol_section = section_info.GetSection(nlist.n_sect, nlist.n_value);\n          if (!N_BRAC_indexes.empty()) {\n            symbol_ptr = symtab->SymbolAtIndex(N_BRAC_indexes.back());\n            symbol_ptr->SetByteSize(sym_idx + 1);\n            symbol_ptr->SetSizeIsSibling(true);\n            N_BRAC_indexes.pop_back();\n          }\n          type = eSymbolTypeScopeEnd;\n          break;\n\n        case N_EXCL:\n          // deleted include file: name,,NO_SECT,0,sum\n          type = eSymbolTypeHeaderFile;\n          break;\n\n        // COMM scopes\n        case N_BCOMM:\n          // begin common: name,,NO_SECT,0,0\n          // We use the current number of symbols in the symbol table in lieu\n          // of using nlist_idx in case we ever start trimming entries out\n          type = eSymbolTypeScopeBegin;\n          N_COMM_indexes.push_back(sym_idx);\n          break;\n\n        case N_ECOML:\n          // end common (local name): 0,,n_sect,0,address\n          symbol_section = section_info.GetSection(nlist.n_sect, nlist.n_value);\n          LLVM_FALLTHROUGH;\n\n        case N_ECOMM:\n          // end common: name,,n_sect,0,0\n          // Set the size of the N_BCOMM to the terminating index of this\n          // N_ECOMM/N_ECOML so that we can always skip the entire symbol if\n          // we need to navigate more quickly at the source level when\n          // parsing STABS\n          if (!N_COMM_indexes.empty()) {\n            symbol_ptr = symtab->SymbolAtIndex(N_COMM_indexes.back());\n            symbol_ptr->SetByteSize(sym_idx + 1);\n            symbol_ptr->SetSizeIsSibling(true);\n            N_COMM_indexes.pop_back();\n          }\n          type = eSymbolTypeScopeEnd;\n          break;\n\n        case N_LENG:\n          // second stab entry with length information\n          type = eSymbolTypeAdditional;\n          break;\n\n        default:\n          break;\n        }\n      } else {\n        uint8_t n_type = N_TYPE & nlist.n_type;\n        sym[sym_idx].SetExternal((N_EXT & nlist.n_type) != 0);\n\n        switch (n_type) {\n        case N_INDR: {\n          const char *reexport_name_cstr = strtab_data.PeekCStr(nlist.n_value);\n          if (reexport_name_cstr && reexport_name_cstr[0]) {\n            type = eSymbolTypeReExported;\n            ConstString reexport_name(reexport_name_cstr +\n                                      ((reexport_name_cstr[0] == '_') ? 1 : 0));\n            sym[sym_idx].SetReExportedSymbolName(reexport_name);\n            set_value = false;\n            reexport_shlib_needs_fixup[sym_idx] = reexport_name;\n            indirect_symbol_names.insert(\n                ConstString(symbol_name + ((symbol_name[0] == '_') ? 1 : 0)));\n          } else\n            type = eSymbolTypeUndefined;\n        } break;\n\n        case N_UNDF:\n          if (symbol_name && symbol_name[0]) {\n            ConstString undefined_name(symbol_name +\n                                       ((symbol_name[0] == '_') ? 1 : 0));\n            undefined_name_to_desc[undefined_name] = nlist.n_desc;\n          }\n          LLVM_FALLTHROUGH;\n\n        case N_PBUD:\n          type = eSymbolTypeUndefined;\n          break;\n\n        case N_ABS:\n          type = eSymbolTypeAbsolute;\n          break;\n\n        case N_SECT: {\n          symbol_section = section_info.GetSection(nlist.n_sect, nlist.n_value);\n\n          if (!symbol_section) {\n            // TODO: warn about this?\n            add_nlist = false;\n            break;\n          }\n\n          if (TEXT_eh_frame_sectID == nlist.n_sect) {\n            type = eSymbolTypeException;\n          } else {\n            uint32_t section_type = symbol_section->Get() & SECTION_TYPE;\n\n            switch (section_type) {\n            case S_CSTRING_LITERALS:\n              type = eSymbolTypeData;\n              break; // section with only literal C strings\n            case S_4BYTE_LITERALS:\n              type = eSymbolTypeData;\n              break; // section with only 4 byte literals\n            case S_8BYTE_LITERALS:\n              type = eSymbolTypeData;\n              break; // section with only 8 byte literals\n            case S_LITERAL_POINTERS:\n              type = eSymbolTypeTrampoline;\n              break; // section with only pointers to literals\n            case S_NON_LAZY_SYMBOL_POINTERS:\n              type = eSymbolTypeTrampoline;\n              break; // section with only non-lazy symbol pointers\n            case S_LAZY_SYMBOL_POINTERS:\n              type = eSymbolTypeTrampoline;\n              break; // section with only lazy symbol pointers\n            case S_SYMBOL_STUBS:\n              type = eSymbolTypeTrampoline;\n              break; // section with only symbol stubs, byte size of stub in\n                     // the reserved2 field\n            case S_MOD_INIT_FUNC_POINTERS:\n              type = eSymbolTypeCode;\n              break; // section with only function pointers for initialization\n            case S_MOD_TERM_FUNC_POINTERS:\n              type = eSymbolTypeCode;\n              break; // section with only function pointers for termination\n            case S_INTERPOSING:\n              type = eSymbolTypeTrampoline;\n              break; // section with only pairs of function pointers for\n                     // interposing\n            case S_16BYTE_LITERALS:\n              type = eSymbolTypeData;\n              break; // section with only 16 byte literals\n            case S_DTRACE_DOF:\n              type = eSymbolTypeInstrumentation;\n              break;\n            case S_LAZY_DYLIB_SYMBOL_POINTERS:\n              type = eSymbolTypeTrampoline;\n              break;\n            default:\n              switch (symbol_section->GetType()) {\n              case lldb::eSectionTypeCode:\n                type = eSymbolTypeCode;\n                break;\n              case eSectionTypeData:\n              case eSectionTypeDataCString:         // Inlined C string data\n              case eSectionTypeDataCStringPointers: // Pointers to C string\n                                                    // data\n              case eSectionTypeDataSymbolAddress:   // Address of a symbol in\n                                                    // the symbol table\n              case eSectionTypeData4:\n              case eSectionTypeData8:\n              case eSectionTypeData16:\n                type = eSymbolTypeData;\n                break;\n              default:\n                break;\n              }\n              break;\n            }\n\n            if (type == eSymbolTypeInvalid) {\n              const char *symbol_sect_name =\n                  symbol_section->GetName().AsCString();\n              if (symbol_section->IsDescendant(text_section_sp.get())) {\n                if (symbol_section->IsClear(S_ATTR_PURE_INSTRUCTIONS |\n                                            S_ATTR_SELF_MODIFYING_CODE |\n                                            S_ATTR_SOME_INSTRUCTIONS))\n                  type = eSymbolTypeData;\n                else\n                  type = eSymbolTypeCode;\n              } else if (symbol_section->IsDescendant(data_section_sp.get()) ||\n                         symbol_section->IsDescendant(\n                             data_dirty_section_sp.get()) ||\n                         symbol_section->IsDescendant(\n                             data_const_section_sp.get())) {\n                if (symbol_sect_name &&\n                    ::strstr(symbol_sect_name, \"__objc\") == symbol_sect_name) {\n                  type = eSymbolTypeRuntime;\n\n                  if (symbol_name) {\n                    llvm::StringRef symbol_name_ref(symbol_name);\n                    if (symbol_name_ref.startswith(\"_OBJC_\")) {\n                      llvm::StringRef g_objc_v2_prefix_class(\n                          \"_OBJC_CLASS_$_\");\n                      llvm::StringRef g_objc_v2_prefix_metaclass(\n                          \"_OBJC_METACLASS_$_\");\n                      llvm::StringRef g_objc_v2_prefix_ivar(\n                          \"_OBJC_IVAR_$_\");\n                      if (symbol_name_ref.startswith(g_objc_v2_prefix_class)) {\n                        symbol_name_non_abi_mangled = symbol_name + 1;\n                        symbol_name =\n                            symbol_name + g_objc_v2_prefix_class.size();\n                        type = eSymbolTypeObjCClass;\n                        demangled_is_synthesized = true;\n                      } else if (symbol_name_ref.startswith(\n                                     g_objc_v2_prefix_metaclass)) {\n                        symbol_name_non_abi_mangled = symbol_name + 1;\n                        symbol_name =\n                            symbol_name + g_objc_v2_prefix_metaclass.size();\n                        type = eSymbolTypeObjCMetaClass;\n                        demangled_is_synthesized = true;\n                      } else if (symbol_name_ref.startswith(\n                                     g_objc_v2_prefix_ivar)) {\n                        symbol_name_non_abi_mangled = symbol_name + 1;\n                        symbol_name =\n                            symbol_name + g_objc_v2_prefix_ivar.size();\n                        type = eSymbolTypeObjCIVar;\n                        demangled_is_synthesized = true;\n                      }\n                    }\n                  }\n                } else if (symbol_sect_name &&\n                           ::strstr(symbol_sect_name, \"__gcc_except_tab\") ==\n                               symbol_sect_name) {\n                  type = eSymbolTypeException;\n                } else {\n                  type = eSymbolTypeData;\n                }\n              } else if (symbol_sect_name &&\n                         ::strstr(symbol_sect_name, \"__IMPORT\") ==\n                             symbol_sect_name) {\n                type = eSymbolTypeTrampoline;\n              } else if (symbol_section->IsDescendant(objc_section_sp.get())) {\n                type = eSymbolTypeRuntime;\n                if (symbol_name && symbol_name[0] == '.') {\n                  llvm::StringRef symbol_name_ref(symbol_name);\n                  llvm::StringRef g_objc_v1_prefix_class(\n                      \".objc_class_name_\");\n                  if (symbol_name_ref.startswith(g_objc_v1_prefix_class)) {\n                    symbol_name_non_abi_mangled = symbol_name;\n                    symbol_name = symbol_name + g_objc_v1_prefix_class.size();\n                    type = eSymbolTypeObjCClass;\n                    demangled_is_synthesized = true;\n                  }\n                }\n              }\n            }\n          }\n        } break;\n        }\n      }\n\n      if (!add_nlist) {\n        sym[sym_idx].Clear();\n        return true;\n      }\n\n      uint64_t symbol_value = nlist.n_value;\n\n      if (symbol_name_non_abi_mangled) {\n        sym[sym_idx].GetMangled().SetMangledName(\n            ConstString(symbol_name_non_abi_mangled));\n        sym[sym_idx].GetMangled().SetDemangledName(ConstString(symbol_name));\n      } else {\n        bool symbol_name_is_mangled = false;\n\n        if (symbol_name && symbol_name[0] == '_') {\n          symbol_name_is_mangled = symbol_name[1] == '_';\n          symbol_name++; // Skip the leading underscore\n        }\n\n        if (symbol_name) {\n          ConstString const_symbol_name(symbol_name);\n          sym[sym_idx].GetMangled().SetValue(const_symbol_name,\n                                             symbol_name_is_mangled);\n        }\n      }\n\n      if (is_gsym) {\n        const char *gsym_name = sym[sym_idx]\n                                    .GetMangled()\n                                    .GetName(Mangled::ePreferMangled)\n                                    .GetCString();\n        if (gsym_name)\n          N_GSYM_name_to_sym_idx[gsym_name] = sym_idx;\n      }\n\n      if (symbol_section) {\n        const addr_t section_file_addr = symbol_section->GetFileAddress();\n        if (symbol_byte_size == 0 && function_starts_count > 0) {\n          addr_t symbol_lookup_file_addr = nlist.n_value;\n          // Do an exact address match for non-ARM addresses, else get the\n          // closest since the symbol might be a thumb symbol which has an\n          // address with bit zero set.\n          FunctionStarts::Entry *func_start_entry =\n              function_starts.FindEntry(symbol_lookup_file_addr, !is_arm);\n          if (is_arm && func_start_entry) {\n            // Verify that the function start address is the symbol address\n            // (ARM) or the symbol address + 1 (thumb).\n            if (func_start_entry->addr != symbol_lookup_file_addr &&\n                func_start_entry->addr != (symbol_lookup_file_addr + 1)) {\n              // Not the right entry, NULL it out...\n              func_start_entry = nullptr;\n            }\n          }\n          if (func_start_entry) {\n            func_start_entry->data = true;\n\n            addr_t symbol_file_addr = func_start_entry->addr;\n            if (is_arm)\n              symbol_file_addr &= THUMB_ADDRESS_BIT_MASK;\n\n            const FunctionStarts::Entry *next_func_start_entry =\n                function_starts.FindNextEntry(func_start_entry);\n            const addr_t section_end_file_addr =\n                section_file_addr + symbol_section->GetByteSize();\n            if (next_func_start_entry) {\n              addr_t next_symbol_file_addr = next_func_start_entry->addr;\n              // Be sure the clear the Thumb address bit when we calculate the\n              // size from the current and next address\n              if (is_arm)\n                next_symbol_file_addr &= THUMB_ADDRESS_BIT_MASK;\n              symbol_byte_size = std::min<lldb::addr_t>(\n                  next_symbol_file_addr - symbol_file_addr,\n                  section_end_file_addr - symbol_file_addr);\n            } else {\n              symbol_byte_size = section_end_file_addr - symbol_file_addr;\n            }\n          }\n        }\n        symbol_value -= section_file_addr;\n      }\n\n      if (!is_debug) {\n        if (type == eSymbolTypeCode) {\n          // See if we can find a N_FUN entry for any code symbols. If we do\n          // find a match, and the name matches, then we can merge the two into\n          // just the function symbol to avoid duplicate entries in the symbol\n          // table.\n          std::pair<ValueToSymbolIndexMap::const_iterator,\n                    ValueToSymbolIndexMap::const_iterator>\n              range;\n          range = N_FUN_addr_to_sym_idx.equal_range(nlist.n_value);\n          if (range.first != range.second) {\n            for (ValueToSymbolIndexMap::const_iterator pos = range.first;\n                 pos != range.second; ++pos) {\n              if (sym[sym_idx].GetMangled().GetName(Mangled::ePreferMangled) ==\n                  sym[pos->second].GetMangled().GetName(\n                      Mangled::ePreferMangled)) {\n                m_nlist_idx_to_sym_idx[nlist_idx] = pos->second;\n                // We just need the flags from the linker symbol, so put these\n                // flags into the N_FUN flags to avoid duplicate symbols in the\n                // symbol table.\n                sym[pos->second].SetExternal(sym[sym_idx].IsExternal());\n                sym[pos->second].SetFlags(nlist.n_type << 16 | nlist.n_desc);\n                if (resolver_addresses.find(nlist.n_value) !=\n                    resolver_addresses.end())\n                  sym[pos->second].SetType(eSymbolTypeResolver);\n                sym[sym_idx].Clear();\n                return true;\n              }\n            }\n          } else {\n            if (resolver_addresses.find(nlist.n_value) !=\n                resolver_addresses.end())\n              type = eSymbolTypeResolver;\n          }\n        } else if (type == eSymbolTypeData || type == eSymbolTypeObjCClass ||\n                   type == eSymbolTypeObjCMetaClass ||\n                   type == eSymbolTypeObjCIVar) {\n          // See if we can find a N_STSYM entry for any data symbols. If we do\n          // find a match, and the name matches, then we can merge the two into\n          // just the Static symbol to avoid duplicate entries in the symbol\n          // table.\n          std::pair<ValueToSymbolIndexMap::const_iterator,\n                    ValueToSymbolIndexMap::const_iterator>\n              range;\n          range = N_STSYM_addr_to_sym_idx.equal_range(nlist.n_value);\n          if (range.first != range.second) {\n            for (ValueToSymbolIndexMap::const_iterator pos = range.first;\n                 pos != range.second; ++pos) {\n              if (sym[sym_idx].GetMangled().GetName(Mangled::ePreferMangled) ==\n                  sym[pos->second].GetMangled().GetName(\n                      Mangled::ePreferMangled)) {\n                m_nlist_idx_to_sym_idx[nlist_idx] = pos->second;\n                // We just need the flags from the linker symbol, so put these\n                // flags into the N_STSYM flags to avoid duplicate symbols in\n                // the symbol table.\n                sym[pos->second].SetExternal(sym[sym_idx].IsExternal());\n                sym[pos->second].SetFlags(nlist.n_type << 16 | nlist.n_desc);\n                sym[sym_idx].Clear();\n                return true;\n              }\n            }\n          } else {\n            // Combine N_GSYM stab entries with the non stab symbol.\n            const char *gsym_name = sym[sym_idx]\n                                        .GetMangled()\n                                        .GetName(Mangled::ePreferMangled)\n                                        .GetCString();\n            if (gsym_name) {\n              ConstNameToSymbolIndexMap::const_iterator pos =\n                  N_GSYM_name_to_sym_idx.find(gsym_name);\n              if (pos != N_GSYM_name_to_sym_idx.end()) {\n                const uint32_t GSYM_sym_idx = pos->second;\n                m_nlist_idx_to_sym_idx[nlist_idx] = GSYM_sym_idx;\n                // Copy the address, because often the N_GSYM address has an\n                // invalid address of zero when the global is a common symbol.\n                sym[GSYM_sym_idx].GetAddressRef().SetSection(symbol_section);\n                sym[GSYM_sym_idx].GetAddressRef().SetOffset(symbol_value);\n                symbols_added.insert(\n                    sym[GSYM_sym_idx].GetAddress().GetFileAddress());\n                // We just need the flags from the linker symbol, so put these\n                // flags into the N_GSYM flags to avoid duplicate symbols in\n                // the symbol table.\n                sym[GSYM_sym_idx].SetFlags(nlist.n_type << 16 | nlist.n_desc);\n                sym[sym_idx].Clear();\n                return true;\n              }\n            }\n          }\n        }\n      }\n\n      sym[sym_idx].SetID(nlist_idx);\n      sym[sym_idx].SetType(type);\n      if (set_value) {\n        sym[sym_idx].GetAddressRef().SetSection(symbol_section);\n        sym[sym_idx].GetAddressRef().SetOffset(symbol_value);\n        symbols_added.insert(sym[sym_idx].GetAddress().GetFileAddress());\n      }\n      sym[sym_idx].SetFlags(nlist.n_type << 16 | nlist.n_desc);\n      if (nlist.n_desc & N_WEAK_REF)\n        sym[sym_idx].SetIsWeak(true);\n\n      if (symbol_byte_size > 0)\n        sym[sym_idx].SetByteSize(symbol_byte_size);\n\n      if (demangled_is_synthesized)\n        sym[sym_idx].SetDemangledNameIsSynthesized(true);\n\n      ++sym_idx;\n      return true;\n    };\n\n    // First parse all the nlists but don't process them yet. See the next\n    // comment for an explanation why.\n    std::vector<struct nlist_64> nlists;\n    nlists.reserve(symtab_load_command.nsyms);\n    for (; nlist_idx < symtab_load_command.nsyms; ++nlist_idx) {\n      if (auto nlist =\n              ParseNList(nlist_data, nlist_data_offset, nlist_byte_size))\n        nlists.push_back(*nlist);\n      else\n        break;\n    }\n\n    // Now parse all the debug symbols. This is needed to merge non-debug\n    // symbols in the next step. Non-debug symbols are always coalesced into\n    // the debug symbol. Doing this in one step would mean that some symbols\n    // won't be merged.\n    nlist_idx = 0;\n    for (auto &nlist : nlists) {\n      if (!ParseSymbolLambda(nlist, nlist_idx++, DebugSymbols))\n        break;\n    }\n\n    // Finally parse all the non debug symbols.\n    nlist_idx = 0;\n    for (auto &nlist : nlists) {\n      if (!ParseSymbolLambda(nlist, nlist_idx++, NonDebugSymbols))\n        break;\n    }\n\n    for (const auto &pos : reexport_shlib_needs_fixup) {\n      const auto undef_pos = undefined_name_to_desc.find(pos.second);\n      if (undef_pos != undefined_name_to_desc.end()) {\n        const uint8_t dylib_ordinal =\n            llvm::MachO::GET_LIBRARY_ORDINAL(undef_pos->second);\n        if (dylib_ordinal > 0 && dylib_ordinal < dylib_files.GetSize())\n          sym[pos.first].SetReExportedSymbolSharedLibrary(\n              dylib_files.GetFileSpecAtIndex(dylib_ordinal - 1));\n      }\n    }\n  }\n\n  // Count how many trie symbols we'll add to the symbol table\n  int trie_symbol_table_augment_count = 0;\n  for (auto &e : external_sym_trie_entries) {\n    if (symbols_added.find(e.entry.address) == symbols_added.end())\n      trie_symbol_table_augment_count++;\n  }\n\n  if (num_syms < sym_idx + trie_symbol_table_augment_count) {\n    num_syms = sym_idx + trie_symbol_table_augment_count;\n    sym = symtab->Resize(num_syms);\n  }\n  uint32_t synthetic_sym_id = symtab_load_command.nsyms;\n\n  // Add symbols from the trie to the symbol table.\n  for (auto &e : external_sym_trie_entries) {\n    if (symbols_added.find(e.entry.address) != symbols_added.end())\n      continue;\n\n    // Find the section that this trie address is in, use that to annotate\n    // symbol type as we add the trie address and name to the symbol table.\n    Address symbol_addr;\n    if (module_sp->ResolveFileAddress(e.entry.address, symbol_addr)) {\n      SectionSP symbol_section(symbol_addr.GetSection());\n      const char *symbol_name = e.entry.name.GetCString();\n      bool demangled_is_synthesized = false;\n      SymbolType type =\n          GetSymbolType(symbol_name, demangled_is_synthesized, text_section_sp,\n                        data_section_sp, data_dirty_section_sp,\n                        data_const_section_sp, symbol_section);\n\n      sym[sym_idx].SetType(type);\n      if (symbol_section) {\n        sym[sym_idx].SetID(synthetic_sym_id++);\n        sym[sym_idx].GetMangled().SetMangledName(ConstString(symbol_name));\n        if (demangled_is_synthesized)\n          sym[sym_idx].SetDemangledNameIsSynthesized(true);\n        sym[sym_idx].SetIsSynthetic(true);\n        sym[sym_idx].SetExternal(true);\n        sym[sym_idx].GetAddressRef() = symbol_addr;\n        symbols_added.insert(symbol_addr.GetFileAddress());\n        if (e.entry.flags & TRIE_SYMBOL_IS_THUMB)\n          sym[sym_idx].SetFlags(MACHO_NLIST_ARM_SYMBOL_IS_THUMB);\n        ++sym_idx;\n      }\n    }\n  }\n\n  if (function_starts_count > 0) {\n    uint32_t num_synthetic_function_symbols = 0;\n    for (i = 0; i < function_starts_count; ++i) {\n      if (symbols_added.find(function_starts.GetEntryRef(i).addr) ==\n          symbols_added.end())\n        ++num_synthetic_function_symbols;\n    }\n\n    if (num_synthetic_function_symbols > 0) {\n      if (num_syms < sym_idx + num_synthetic_function_symbols) {\n        num_syms = sym_idx + num_synthetic_function_symbols;\n        sym = symtab->Resize(num_syms);\n      }\n      for (i = 0; i < function_starts_count; ++i) {\n        const FunctionStarts::Entry *func_start_entry =\n            function_starts.GetEntryAtIndex(i);\n        if (symbols_added.find(func_start_entry->addr) == symbols_added.end()) {\n          addr_t symbol_file_addr = func_start_entry->addr;\n          uint32_t symbol_flags = 0;\n          if (func_start_entry->data)\n            symbol_flags = MACHO_NLIST_ARM_SYMBOL_IS_THUMB;\n          Address symbol_addr;\n          if (module_sp->ResolveFileAddress(symbol_file_addr, symbol_addr)) {\n            SectionSP symbol_section(symbol_addr.GetSection());\n            uint32_t symbol_byte_size = 0;\n            if (symbol_section) {\n              const addr_t section_file_addr = symbol_section->GetFileAddress();\n              const FunctionStarts::Entry *next_func_start_entry =\n                  function_starts.FindNextEntry(func_start_entry);\n              const addr_t section_end_file_addr =\n                  section_file_addr + symbol_section->GetByteSize();\n              if (next_func_start_entry) {\n                addr_t next_symbol_file_addr = next_func_start_entry->addr;\n                if (is_arm)\n                  next_symbol_file_addr &= THUMB_ADDRESS_BIT_MASK;\n                symbol_byte_size = std::min<lldb::addr_t>(\n                    next_symbol_file_addr - symbol_file_addr,\n                    section_end_file_addr - symbol_file_addr);\n              } else {\n                symbol_byte_size = section_end_file_addr - symbol_file_addr;\n              }\n              sym[sym_idx].SetID(synthetic_sym_id++);\n              sym[sym_idx].GetMangled().SetDemangledName(\n                  GetNextSyntheticSymbolName());\n              sym[sym_idx].SetType(eSymbolTypeCode);\n              sym[sym_idx].SetIsSynthetic(true);\n              sym[sym_idx].GetAddressRef() = symbol_addr;\n              symbols_added.insert(symbol_addr.GetFileAddress());\n              if (symbol_flags)\n                sym[sym_idx].SetFlags(symbol_flags);\n              if (symbol_byte_size)\n                sym[sym_idx].SetByteSize(symbol_byte_size);\n              ++sym_idx;\n            }\n          }\n        }\n      }\n    }\n  }\n\n  // Trim our symbols down to just what we ended up with after removing any\n  // symbols.\n  if (sym_idx < num_syms) {\n    num_syms = sym_idx;\n    sym = symtab->Resize(num_syms);\n  }\n\n  // Now synthesize indirect symbols\n  if (m_dysymtab.nindirectsyms != 0) {\n    if (indirect_symbol_index_data.GetByteSize()) {\n      NListIndexToSymbolIndexMap::const_iterator end_index_pos =\n          m_nlist_idx_to_sym_idx.end();\n\n      for (uint32_t sect_idx = 1; sect_idx < m_mach_sections.size();\n           ++sect_idx) {\n        if ((m_mach_sections[sect_idx].flags & SECTION_TYPE) ==\n            S_SYMBOL_STUBS) {\n          uint32_t symbol_stub_byte_size = m_mach_sections[sect_idx].reserved2;\n          if (symbol_stub_byte_size == 0)\n            continue;\n\n          const uint32_t num_symbol_stubs =\n              m_mach_sections[sect_idx].size / symbol_stub_byte_size;\n\n          if (num_symbol_stubs == 0)\n            continue;\n\n          const uint32_t symbol_stub_index_offset =\n              m_mach_sections[sect_idx].reserved1;\n          for (uint32_t stub_idx = 0; stub_idx < num_symbol_stubs; ++stub_idx) {\n            const uint32_t symbol_stub_index =\n                symbol_stub_index_offset + stub_idx;\n            const lldb::addr_t symbol_stub_addr =\n                m_mach_sections[sect_idx].addr +\n                (stub_idx * symbol_stub_byte_size);\n            lldb::offset_t symbol_stub_offset = symbol_stub_index * 4;\n            if (indirect_symbol_index_data.ValidOffsetForDataOfSize(\n                    symbol_stub_offset, 4)) {\n              const uint32_t stub_sym_id =\n                  indirect_symbol_index_data.GetU32(&symbol_stub_offset);\n              if (stub_sym_id & (INDIRECT_SYMBOL_ABS | INDIRECT_SYMBOL_LOCAL))\n                continue;\n\n              NListIndexToSymbolIndexMap::const_iterator index_pos =\n                  m_nlist_idx_to_sym_idx.find(stub_sym_id);\n              Symbol *stub_symbol = nullptr;\n              if (index_pos != end_index_pos) {\n                // We have a remapping from the original nlist index to a\n                // current symbol index, so just look this up by index\n                stub_symbol = symtab->SymbolAtIndex(index_pos->second);\n              } else {\n                // We need to lookup a symbol using the original nlist symbol\n                // index since this index is coming from the S_SYMBOL_STUBS\n                stub_symbol = symtab->FindSymbolByID(stub_sym_id);\n              }\n\n              if (stub_symbol) {\n                Address so_addr(symbol_stub_addr, section_list);\n\n                if (stub_symbol->GetType() == eSymbolTypeUndefined) {\n                  // Change the external symbol into a trampoline that makes\n                  // sense These symbols were N_UNDF N_EXT, and are useless\n                  // to us, so we can re-use them so we don't have to make up\n                  // a synthetic symbol for no good reason.\n                  if (resolver_addresses.find(symbol_stub_addr) ==\n                      resolver_addresses.end())\n                    stub_symbol->SetType(eSymbolTypeTrampoline);\n                  else\n                    stub_symbol->SetType(eSymbolTypeResolver);\n                  stub_symbol->SetExternal(false);\n                  stub_symbol->GetAddressRef() = so_addr;\n                  stub_symbol->SetByteSize(symbol_stub_byte_size);\n                } else {\n                  // Make a synthetic symbol to describe the trampoline stub\n                  Mangled stub_symbol_mangled_name(stub_symbol->GetMangled());\n                  if (sym_idx >= num_syms) {\n                    sym = symtab->Resize(++num_syms);\n                    stub_symbol = nullptr; // this pointer no longer valid\n                  }\n                  sym[sym_idx].SetID(synthetic_sym_id++);\n                  sym[sym_idx].GetMangled() = stub_symbol_mangled_name;\n                  if (resolver_addresses.find(symbol_stub_addr) ==\n                      resolver_addresses.end())\n                    sym[sym_idx].SetType(eSymbolTypeTrampoline);\n                  else\n                    sym[sym_idx].SetType(eSymbolTypeResolver);\n                  sym[sym_idx].SetIsSynthetic(true);\n                  sym[sym_idx].GetAddressRef() = so_addr;\n                  symbols_added.insert(so_addr.GetFileAddress());\n                  sym[sym_idx].SetByteSize(symbol_stub_byte_size);\n                  ++sym_idx;\n                }\n              } else {\n                if (log)\n                  log->Warning(\"symbol stub referencing symbol table symbol \"\n                               \"%u that isn't in our minimal symbol table, \"\n                               \"fix this!!!\",\n                               stub_sym_id);\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n\n  if (!reexport_trie_entries.empty()) {\n    for (const auto &e : reexport_trie_entries) {\n      if (e.entry.import_name) {\n        // Only add indirect symbols from the Trie entries if we didn't have\n        // a N_INDR nlist entry for this already\n        if (indirect_symbol_names.find(e.entry.name) ==\n            indirect_symbol_names.end()) {\n          // Make a synthetic symbol to describe re-exported symbol.\n          if (sym_idx >= num_syms)\n            sym = symtab->Resize(++num_syms);\n          sym[sym_idx].SetID(synthetic_sym_id++);\n          sym[sym_idx].GetMangled() = Mangled(e.entry.name);\n          sym[sym_idx].SetType(eSymbolTypeReExported);\n          sym[sym_idx].SetIsSynthetic(true);\n          sym[sym_idx].SetReExportedSymbolName(e.entry.import_name);\n          if (e.entry.other > 0 && e.entry.other <= dylib_files.GetSize()) {\n            sym[sym_idx].SetReExportedSymbolSharedLibrary(\n                dylib_files.GetFileSpecAtIndex(e.entry.other - 1));\n          }\n          ++sym_idx;\n        }\n      }\n    }\n  }\n\n  //        StreamFile s(stdout, false);\n  //        s.Printf (\"Symbol table before CalculateSymbolSizes():\\n\");\n  //        symtab->Dump(&s, NULL, eSortOrderNone);\n  // Set symbol byte sizes correctly since mach-o nlist entries don't have\n  // sizes\n  symtab->CalculateSymbolSizes();\n\n  //        s.Printf (\"Symbol table after CalculateSymbolSizes():\\n\");\n  //        symtab->Dump(&s, NULL, eSortOrderNone);\n\n  return symtab->GetNumSymbols();\n}\n\nvoid ObjectFileMachO::Dump(Stream *s) {\n  ModuleSP module_sp(GetModule());\n  if (module_sp) {\n    std::lock_guard<std::recursive_mutex> guard(module_sp->GetMutex());\n    s->Printf(\"%p: \", static_cast<void *>(this));\n    s->Indent();\n    if (m_header.magic == MH_MAGIC_64 || m_header.magic == MH_CIGAM_64)\n      s->PutCString(\"ObjectFileMachO64\");\n    else\n      s->PutCString(\"ObjectFileMachO32\");\n\n    *s << \", file = '\" << m_file;\n    ModuleSpecList all_specs;\n    ModuleSpec base_spec;\n    GetAllArchSpecs(m_header, m_data, MachHeaderSizeFromMagic(m_header.magic),\n                    base_spec, all_specs);\n    for (unsigned i = 0, e = all_specs.GetSize(); i != e; ++i) {\n      *s << \"', triple\";\n      if (e)\n        s->Printf(\"[%d]\", i);\n      *s << \" = \";\n      *s << all_specs.GetModuleSpecRefAtIndex(i)\n                .GetArchitecture()\n                .GetTriple()\n                .getTriple();\n    }\n    *s << \"\\n\";\n    SectionList *sections = GetSectionList();\n    if (sections)\n      sections->Dump(s->AsRawOstream(), s->GetIndentLevel(), nullptr, true,\n                     UINT32_MAX);\n\n    if (m_symtab_up)\n      m_symtab_up->Dump(s, nullptr, eSortOrderNone);\n  }\n}\n\nUUID ObjectFileMachO::GetUUID(const llvm::MachO::mach_header &header,\n                              const lldb_private::DataExtractor &data,\n                              lldb::offset_t lc_offset) {\n  uint32_t i;\n  struct uuid_command load_cmd;\n\n  lldb::offset_t offset = lc_offset;\n  for (i = 0; i < header.ncmds; ++i) {\n    const lldb::offset_t cmd_offset = offset;\n    if (data.GetU32(&offset, &load_cmd, 2) == nullptr)\n      break;\n\n    if (load_cmd.cmd == LC_UUID) {\n      const uint8_t *uuid_bytes = data.PeekData(offset, 16);\n\n      if (uuid_bytes) {\n        // OpenCL on Mac OS X uses the same UUID for each of its object files.\n        // We pretend these object files have no UUID to prevent crashing.\n\n        const uint8_t opencl_uuid[] = {0x8c, 0x8e, 0xb3, 0x9b, 0x3b, 0xa8,\n                                       0x4b, 0x16, 0xb6, 0xa4, 0x27, 0x63,\n                                       0xbb, 0x14, 0xf0, 0x0d};\n\n        if (!memcmp(uuid_bytes, opencl_uuid, 16))\n          return UUID();\n\n        return UUID::fromOptionalData(uuid_bytes, 16);\n      }\n      return UUID();\n    }\n    offset = cmd_offset + load_cmd.cmdsize;\n  }\n  return UUID();\n}\n\nstatic llvm::StringRef GetOSName(uint32_t cmd) {\n  switch (cmd) {\n  case llvm::MachO::LC_VERSION_MIN_IPHONEOS:\n    return llvm::Triple::getOSTypeName(llvm::Triple::IOS);\n  case llvm::MachO::LC_VERSION_MIN_MACOSX:\n    return llvm::Triple::getOSTypeName(llvm::Triple::MacOSX);\n  case llvm::MachO::LC_VERSION_MIN_TVOS:\n    return llvm::Triple::getOSTypeName(llvm::Triple::TvOS);\n  case llvm::MachO::LC_VERSION_MIN_WATCHOS:\n    return llvm::Triple::getOSTypeName(llvm::Triple::WatchOS);\n  default:\n    llvm_unreachable(\"unexpected LC_VERSION load command\");\n  }\n}\n\nnamespace {\nstruct OSEnv {\n  llvm::StringRef os_type;\n  llvm::StringRef environment;\n  OSEnv(uint32_t cmd) {\n    switch (cmd) {\n    case llvm::MachO::PLATFORM_MACOS:\n      os_type = llvm::Triple::getOSTypeName(llvm::Triple::MacOSX);\n      return;\n    case llvm::MachO::PLATFORM_IOS:\n      os_type = llvm::Triple::getOSTypeName(llvm::Triple::IOS);\n      return;\n    case llvm::MachO::PLATFORM_TVOS:\n      os_type = llvm::Triple::getOSTypeName(llvm::Triple::TvOS);\n      return;\n    case llvm::MachO::PLATFORM_WATCHOS:\n      os_type = llvm::Triple::getOSTypeName(llvm::Triple::WatchOS);\n      return;\n      // NEED_BRIDGEOS_TRIPLE      case llvm::MachO::PLATFORM_BRIDGEOS:\n      // NEED_BRIDGEOS_TRIPLE        os_type =\n      // llvm::Triple::getOSTypeName(llvm::Triple::BridgeOS);\n      // NEED_BRIDGEOS_TRIPLE        return;\n    case llvm::MachO::PLATFORM_MACCATALYST:\n      os_type = llvm::Triple::getOSTypeName(llvm::Triple::IOS);\n      environment = llvm::Triple::getEnvironmentTypeName(llvm::Triple::MacABI);\n      return;\n    case llvm::MachO::PLATFORM_IOSSIMULATOR:\n      os_type = llvm::Triple::getOSTypeName(llvm::Triple::IOS);\n      environment =\n          llvm::Triple::getEnvironmentTypeName(llvm::Triple::Simulator);\n      return;\n    case llvm::MachO::PLATFORM_TVOSSIMULATOR:\n      os_type = llvm::Triple::getOSTypeName(llvm::Triple::TvOS);\n      environment =\n          llvm::Triple::getEnvironmentTypeName(llvm::Triple::Simulator);\n      return;\n    case llvm::MachO::PLATFORM_WATCHOSSIMULATOR:\n      os_type = llvm::Triple::getOSTypeName(llvm::Triple::WatchOS);\n      environment =\n          llvm::Triple::getEnvironmentTypeName(llvm::Triple::Simulator);\n      return;\n    default: {\n      Log *log(lldb_private::GetLogIfAnyCategoriesSet(LIBLLDB_LOG_SYMBOLS |\n                                                      LIBLLDB_LOG_PROCESS));\n      LLDB_LOGF(log, \"unsupported platform in LC_BUILD_VERSION\");\n    }\n    }\n  }\n};\n\nstruct MinOS {\n  uint32_t major_version, minor_version, patch_version;\n  MinOS(uint32_t version)\n      : major_version(version >> 16), minor_version((version >> 8) & 0xffu),\n        patch_version(version & 0xffu) {}\n};\n} // namespace\n\nvoid ObjectFileMachO::GetAllArchSpecs(const llvm::MachO::mach_header &header,\n                                      const lldb_private::DataExtractor &data,\n                                      lldb::offset_t lc_offset,\n                                      ModuleSpec &base_spec,\n                                      lldb_private::ModuleSpecList &all_specs) {\n  auto &base_arch = base_spec.GetArchitecture();\n  base_arch.SetArchitecture(eArchTypeMachO, header.cputype, header.cpusubtype);\n  if (!base_arch.IsValid())\n    return;\n\n  bool found_any = false;\n  auto add_triple = [&](const llvm::Triple &triple) {\n    auto spec = base_spec;\n    spec.GetArchitecture().GetTriple() = triple;\n    if (spec.GetArchitecture().IsValid()) {\n      spec.GetUUID() = ObjectFileMachO::GetUUID(header, data, lc_offset);\n      all_specs.Append(spec);\n      found_any = true;\n    }\n  };\n\n  // Set OS to an unspecified unknown or a \"*\" so it can match any OS\n  llvm::Triple base_triple = base_arch.GetTriple();\n  base_triple.setOS(llvm::Triple::UnknownOS);\n  base_triple.setOSName(llvm::StringRef());\n\n  if (header.filetype == MH_PRELOAD) {\n    if (header.cputype == CPU_TYPE_ARM) {\n      // If this is a 32-bit arm binary, and it's a standalone binary, force\n      // the Vendor to Apple so we don't accidentally pick up the generic\n      // armv7 ABI at runtime.  Apple's armv7 ABI always uses r7 for the\n      // frame pointer register; most other armv7 ABIs use a combination of\n      // r7 and r11.\n      base_triple.setVendor(llvm::Triple::Apple);\n    } else {\n      // Set vendor to an unspecified unknown or a \"*\" so it can match any\n      // vendor This is required for correct behavior of EFI debugging on\n      // x86_64\n      base_triple.setVendor(llvm::Triple::UnknownVendor);\n      base_triple.setVendorName(llvm::StringRef());\n    }\n    return add_triple(base_triple);\n  }\n\n  struct load_command load_cmd;\n\n  // See if there is an LC_VERSION_MIN_* load command that can give\n  // us the OS type.\n  lldb::offset_t offset = lc_offset;\n  for (uint32_t i = 0; i < header.ncmds; ++i) {\n    const lldb::offset_t cmd_offset = offset;\n    if (data.GetU32(&offset, &load_cmd, 2) == NULL)\n      break;\n\n    struct version_min_command version_min;\n    switch (load_cmd.cmd) {\n    case llvm::MachO::LC_VERSION_MIN_MACOSX:\n    case llvm::MachO::LC_VERSION_MIN_IPHONEOS:\n    case llvm::MachO::LC_VERSION_MIN_TVOS:\n    case llvm::MachO::LC_VERSION_MIN_WATCHOS: {\n      if (load_cmd.cmdsize != sizeof(version_min))\n        break;\n      if (data.ExtractBytes(cmd_offset, sizeof(version_min),\n                            data.GetByteOrder(), &version_min) == 0)\n        break;\n      MinOS min_os(version_min.version);\n      llvm::SmallString<32> os_name;\n      llvm::raw_svector_ostream os(os_name);\n      os << GetOSName(load_cmd.cmd) << min_os.major_version << '.'\n         << min_os.minor_version << '.' << min_os.patch_version;\n\n      auto triple = base_triple;\n      triple.setOSName(os.str());\n\n      // Disambiguate legacy simulator platforms.\n      if (load_cmd.cmd != llvm::MachO::LC_VERSION_MIN_MACOSX &&\n          (base_triple.getArch() == llvm::Triple::x86_64 ||\n           base_triple.getArch() == llvm::Triple::x86)) {\n        // The combination of legacy LC_VERSION_MIN load command and\n        // x86 architecture always indicates a simulator environment.\n        // The combination of LC_VERSION_MIN and arm architecture only\n        // appears for native binaries. Back-deploying simulator\n        // binaries on Apple Silicon Macs use the modern unambigous\n        // LC_BUILD_VERSION load commands; no special handling required.\n        triple.setEnvironment(llvm::Triple::Simulator);\n      }\n      add_triple(triple);\n      break;\n    }\n    default:\n      break;\n    }\n\n    offset = cmd_offset + load_cmd.cmdsize;\n  }\n\n  // See if there are LC_BUILD_VERSION load commands that can give\n  // us the OS type.\n  offset = lc_offset;\n  for (uint32_t i = 0; i < header.ncmds; ++i) {\n    const lldb::offset_t cmd_offset = offset;\n    if (data.GetU32(&offset, &load_cmd, 2) == NULL)\n      break;\n\n    do {\n      if (load_cmd.cmd == llvm::MachO::LC_BUILD_VERSION) {\n        struct build_version_command build_version;\n        if (load_cmd.cmdsize < sizeof(build_version)) {\n          // Malformed load command.\n          break;\n        }\n        if (data.ExtractBytes(cmd_offset, sizeof(build_version),\n                              data.GetByteOrder(), &build_version) == 0)\n          break;\n        MinOS min_os(build_version.minos);\n        OSEnv os_env(build_version.platform);\n        llvm::SmallString<16> os_name;\n        llvm::raw_svector_ostream os(os_name);\n        os << os_env.os_type << min_os.major_version << '.'\n           << min_os.minor_version << '.' << min_os.patch_version;\n        auto triple = base_triple;\n        triple.setOSName(os.str());\n        os_name.clear();\n        if (!os_env.environment.empty())\n          triple.setEnvironmentName(os_env.environment);\n        add_triple(triple);\n      }\n    } while (0);\n    offset = cmd_offset + load_cmd.cmdsize;\n  }\n\n  if (!found_any) {\n    if (header.filetype == MH_KEXT_BUNDLE) {\n      base_triple.setVendor(llvm::Triple::Apple);\n      add_triple(base_triple);\n    } else {\n      // We didn't find a LC_VERSION_MIN load command and this isn't a KEXT\n      // so lets not say our Vendor is Apple, leave it as an unspecified\n      // unknown.\n      base_triple.setVendor(llvm::Triple::UnknownVendor);\n      base_triple.setVendorName(llvm::StringRef());\n      add_triple(base_triple);\n    }\n  }\n}\n\nArchSpec ObjectFileMachO::GetArchitecture(\n    ModuleSP module_sp, const llvm::MachO::mach_header &header,\n    const lldb_private::DataExtractor &data, lldb::offset_t lc_offset) {\n  ModuleSpecList all_specs;\n  ModuleSpec base_spec;\n  GetAllArchSpecs(header, data, MachHeaderSizeFromMagic(header.magic),\n                  base_spec, all_specs);\n\n  // If the object file offers multiple alternative load commands,\n  // pick the one that matches the module.\n  if (module_sp) {\n    const ArchSpec &module_arch = module_sp->GetArchitecture();\n    for (unsigned i = 0, e = all_specs.GetSize(); i != e; ++i) {\n      ArchSpec mach_arch =\n          all_specs.GetModuleSpecRefAtIndex(i).GetArchitecture();\n      if (module_arch.IsCompatibleMatch(mach_arch))\n        return mach_arch;\n    }\n  }\n\n  // Return the first arch we found.\n  if (all_specs.GetSize() == 0)\n    return {};\n  return all_specs.GetModuleSpecRefAtIndex(0).GetArchitecture();\n}\n\nUUID ObjectFileMachO::GetUUID() {\n  ModuleSP module_sp(GetModule());\n  if (module_sp) {\n    std::lock_guard<std::recursive_mutex> guard(module_sp->GetMutex());\n    lldb::offset_t offset = MachHeaderSizeFromMagic(m_header.magic);\n    return GetUUID(m_header, m_data, offset);\n  }\n  return UUID();\n}\n\nuint32_t ObjectFileMachO::GetDependentModules(FileSpecList &files) {\n  uint32_t count = 0;\n  ModuleSP module_sp(GetModule());\n  if (module_sp) {\n    std::lock_guard<std::recursive_mutex> guard(module_sp->GetMutex());\n    struct load_command load_cmd;\n    lldb::offset_t offset = MachHeaderSizeFromMagic(m_header.magic);\n    std::vector<std::string> rpath_paths;\n    std::vector<std::string> rpath_relative_paths;\n    std::vector<std::string> at_exec_relative_paths;\n    uint32_t i;\n    for (i = 0; i < m_header.ncmds; ++i) {\n      const uint32_t cmd_offset = offset;\n      if (m_data.GetU32(&offset, &load_cmd, 2) == nullptr)\n        break;\n\n      switch (load_cmd.cmd) {\n      case LC_RPATH:\n      case LC_LOAD_DYLIB:\n      case LC_LOAD_WEAK_DYLIB:\n      case LC_REEXPORT_DYLIB:\n      case LC_LOAD_DYLINKER:\n      case LC_LOADFVMLIB:\n      case LC_LOAD_UPWARD_DYLIB: {\n        uint32_t name_offset = cmd_offset + m_data.GetU32(&offset);\n        const char *path = m_data.PeekCStr(name_offset);\n        if (path) {\n          if (load_cmd.cmd == LC_RPATH)\n            rpath_paths.push_back(path);\n          else {\n            if (path[0] == '@') {\n              if (strncmp(path, \"@rpath\", strlen(\"@rpath\")) == 0)\n                rpath_relative_paths.push_back(path + strlen(\"@rpath\"));\n              else if (strncmp(path, \"@executable_path\",\n                               strlen(\"@executable_path\")) == 0)\n                at_exec_relative_paths.push_back(path +\n                                                 strlen(\"@executable_path\"));\n            } else {\n              FileSpec file_spec(path);\n              if (files.AppendIfUnique(file_spec))\n                count++;\n            }\n          }\n        }\n      } break;\n\n      default:\n        break;\n      }\n      offset = cmd_offset + load_cmd.cmdsize;\n    }\n\n    FileSpec this_file_spec(m_file);\n    FileSystem::Instance().Resolve(this_file_spec);\n\n    if (!rpath_paths.empty()) {\n      // Fixup all LC_RPATH values to be absolute paths\n      std::string loader_path(\"@loader_path\");\n      std::string executable_path(\"@executable_path\");\n      for (auto &rpath : rpath_paths) {\n        if (llvm::StringRef(rpath).startswith(loader_path)) {\n          rpath.erase(0, loader_path.size());\n          rpath.insert(0, this_file_spec.GetDirectory().GetCString());\n        } else if (llvm::StringRef(rpath).startswith(executable_path)) {\n          rpath.erase(0, executable_path.size());\n          rpath.insert(0, this_file_spec.GetDirectory().GetCString());\n        }\n      }\n\n      for (const auto &rpath_relative_path : rpath_relative_paths) {\n        for (const auto &rpath : rpath_paths) {\n          std::string path = rpath;\n          path += rpath_relative_path;\n          // It is OK to resolve this path because we must find a file on disk\n          // for us to accept it anyway if it is rpath relative.\n          FileSpec file_spec(path);\n          FileSystem::Instance().Resolve(file_spec);\n          if (FileSystem::Instance().Exists(file_spec) &&\n              files.AppendIfUnique(file_spec)) {\n            count++;\n            break;\n          }\n        }\n      }\n    }\n\n    // We may have @executable_paths but no RPATHS.  Figure those out here.\n    // Only do this if this object file is the executable.  We have no way to\n    // get back to the actual executable otherwise, so we won't get the right\n    // path.\n    if (!at_exec_relative_paths.empty() && CalculateType() == eTypeExecutable) {\n      FileSpec exec_dir = this_file_spec.CopyByRemovingLastPathComponent();\n      for (const auto &at_exec_relative_path : at_exec_relative_paths) {\n        FileSpec file_spec =\n            exec_dir.CopyByAppendingPathComponent(at_exec_relative_path);\n        if (FileSystem::Instance().Exists(file_spec) &&\n            files.AppendIfUnique(file_spec))\n          count++;\n      }\n    }\n  }\n  return count;\n}\n\nlldb_private::Address ObjectFileMachO::GetEntryPointAddress() {\n  // If the object file is not an executable it can't hold the entry point.\n  // m_entry_point_address is initialized to an invalid address, so we can just\n  // return that. If m_entry_point_address is valid it means we've found it\n  // already, so return the cached value.\n\n  if ((!IsExecutable() && !IsDynamicLoader()) ||\n      m_entry_point_address.IsValid()) {\n    return m_entry_point_address;\n  }\n\n  // Otherwise, look for the UnixThread or Thread command.  The data for the\n  // Thread command is given in /usr/include/mach-o.h, but it is basically:\n  //\n  //  uint32_t flavor  - this is the flavor argument you would pass to\n  //  thread_get_state\n  //  uint32_t count   - this is the count of longs in the thread state data\n  //  struct XXX_thread_state state - this is the structure from\n  //  <machine/thread_status.h> corresponding to the flavor.\n  //  <repeat this trio>\n  //\n  // So we just keep reading the various register flavors till we find the GPR\n  // one, then read the PC out of there.\n  // FIXME: We will need to have a \"RegisterContext data provider\" class at some\n  // point that can get all the registers\n  // out of data in this form & attach them to a given thread.  That should\n  // underlie the MacOS X User process plugin, and we'll also need it for the\n  // MacOS X Core File process plugin.  When we have that we can also use it\n  // here.\n  //\n  // For now we hard-code the offsets and flavors we need:\n  //\n  //\n\n  ModuleSP module_sp(GetModule());\n  if (module_sp) {\n    std::lock_guard<std::recursive_mutex> guard(module_sp->GetMutex());\n    struct load_command load_cmd;\n    lldb::offset_t offset = MachHeaderSizeFromMagic(m_header.magic);\n    uint32_t i;\n    lldb::addr_t start_address = LLDB_INVALID_ADDRESS;\n    bool done = false;\n\n    for (i = 0; i < m_header.ncmds; ++i) {\n      const lldb::offset_t cmd_offset = offset;\n      if (m_data.GetU32(&offset, &load_cmd, 2) == nullptr)\n        break;\n\n      switch (load_cmd.cmd) {\n      case LC_UNIXTHREAD:\n      case LC_THREAD: {\n        while (offset < cmd_offset + load_cmd.cmdsize) {\n          uint32_t flavor = m_data.GetU32(&offset);\n          uint32_t count = m_data.GetU32(&offset);\n          if (count == 0) {\n            // We've gotten off somehow, log and exit;\n            return m_entry_point_address;\n          }\n\n          switch (m_header.cputype) {\n          case llvm::MachO::CPU_TYPE_ARM:\n            if (flavor == 1 ||\n                flavor == 9) // ARM_THREAD_STATE/ARM_THREAD_STATE32\n                             // from mach/arm/thread_status.h\n            {\n              offset += 60; // This is the offset of pc in the GPR thread state\n                            // data structure.\n              start_address = m_data.GetU32(&offset);\n              done = true;\n            }\n            break;\n          case llvm::MachO::CPU_TYPE_ARM64:\n          case llvm::MachO::CPU_TYPE_ARM64_32:\n            if (flavor == 6) // ARM_THREAD_STATE64 from mach/arm/thread_status.h\n            {\n              offset += 256; // This is the offset of pc in the GPR thread state\n                             // data structure.\n              start_address = m_data.GetU64(&offset);\n              done = true;\n            }\n            break;\n          case llvm::MachO::CPU_TYPE_I386:\n            if (flavor ==\n                1) // x86_THREAD_STATE32 from mach/i386/thread_status.h\n            {\n              offset += 40; // This is the offset of eip in the GPR thread state\n                            // data structure.\n              start_address = m_data.GetU32(&offset);\n              done = true;\n            }\n            break;\n          case llvm::MachO::CPU_TYPE_X86_64:\n            if (flavor ==\n                4) // x86_THREAD_STATE64 from mach/i386/thread_status.h\n            {\n              offset += 16 * 8; // This is the offset of rip in the GPR thread\n                                // state data structure.\n              start_address = m_data.GetU64(&offset);\n              done = true;\n            }\n            break;\n          default:\n            return m_entry_point_address;\n          }\n          // Haven't found the GPR flavor yet, skip over the data for this\n          // flavor:\n          if (done)\n            break;\n          offset += count * 4;\n        }\n      } break;\n      case LC_MAIN: {\n        ConstString text_segment_name(\"__TEXT\");\n        uint64_t entryoffset = m_data.GetU64(&offset);\n        SectionSP text_segment_sp =\n            GetSectionList()->FindSectionByName(text_segment_name);\n        if (text_segment_sp) {\n          done = true;\n          start_address = text_segment_sp->GetFileAddress() + entryoffset;\n        }\n      } break;\n\n      default:\n        break;\n      }\n      if (done)\n        break;\n\n      // Go to the next load command:\n      offset = cmd_offset + load_cmd.cmdsize;\n    }\n\n    if (start_address == LLDB_INVALID_ADDRESS && IsDynamicLoader()) {\n      if (GetSymtab()) {\n        Symbol *dyld_start_sym = GetSymtab()->FindFirstSymbolWithNameAndType(\n            ConstString(\"_dyld_start\"), SymbolType::eSymbolTypeCode,\n            Symtab::eDebugAny, Symtab::eVisibilityAny);\n        if (dyld_start_sym && dyld_start_sym->GetAddress().IsValid()) {\n          start_address = dyld_start_sym->GetAddress().GetFileAddress();\n        }\n      }\n    }\n\n    if (start_address != LLDB_INVALID_ADDRESS) {\n      // We got the start address from the load commands, so now resolve that\n      // address in the sections of this ObjectFile:\n      if (!m_entry_point_address.ResolveAddressUsingFileSections(\n              start_address, GetSectionList())) {\n        m_entry_point_address.Clear();\n      }\n    } else {\n      // We couldn't read the UnixThread load command - maybe it wasn't there.\n      // As a fallback look for the \"start\" symbol in the main executable.\n\n      ModuleSP module_sp(GetModule());\n\n      if (module_sp) {\n        SymbolContextList contexts;\n        SymbolContext context;\n        module_sp->FindSymbolsWithNameAndType(ConstString(\"start\"),\n                                              eSymbolTypeCode, contexts);\n        if (contexts.GetSize()) {\n          if (contexts.GetContextAtIndex(0, context))\n            m_entry_point_address = context.symbol->GetAddress();\n        }\n      }\n    }\n  }\n\n  return m_entry_point_address;\n}\n\nlldb_private::Address ObjectFileMachO::GetBaseAddress() {\n  lldb_private::Address header_addr;\n  SectionList *section_list = GetSectionList();\n  if (section_list) {\n    SectionSP text_segment_sp(\n        section_list->FindSectionByName(GetSegmentNameTEXT()));\n    if (text_segment_sp) {\n      header_addr.SetSection(text_segment_sp);\n      header_addr.SetOffset(0);\n    }\n  }\n  return header_addr;\n}\n\nuint32_t ObjectFileMachO::GetNumThreadContexts() {\n  ModuleSP module_sp(GetModule());\n  if (module_sp) {\n    std::lock_guard<std::recursive_mutex> guard(module_sp->GetMutex());\n    if (!m_thread_context_offsets_valid) {\n      m_thread_context_offsets_valid = true;\n      lldb::offset_t offset = MachHeaderSizeFromMagic(m_header.magic);\n      FileRangeArray::Entry file_range;\n      thread_command thread_cmd;\n      for (uint32_t i = 0; i < m_header.ncmds; ++i) {\n        const uint32_t cmd_offset = offset;\n        if (m_data.GetU32(&offset, &thread_cmd, 2) == nullptr)\n          break;\n\n        if (thread_cmd.cmd == LC_THREAD) {\n          file_range.SetRangeBase(offset);\n          file_range.SetByteSize(thread_cmd.cmdsize - 8);\n          m_thread_context_offsets.Append(file_range);\n        }\n        offset = cmd_offset + thread_cmd.cmdsize;\n      }\n    }\n  }\n  return m_thread_context_offsets.GetSize();\n}\n\nstd::string ObjectFileMachO::GetIdentifierString() {\n  std::string result;\n  ModuleSP module_sp(GetModule());\n  if (module_sp) {\n    std::lock_guard<std::recursive_mutex> guard(module_sp->GetMutex());\n\n    // First, look over the load commands for an LC_NOTE load command with\n    // data_owner string \"kern ver str\" & use that if found.\n    lldb::offset_t offset = MachHeaderSizeFromMagic(m_header.magic);\n    for (uint32_t i = 0; i < m_header.ncmds; ++i) {\n      const uint32_t cmd_offset = offset;\n      load_command lc;\n      if (m_data.GetU32(&offset, &lc.cmd, 2) == nullptr)\n        break;\n      if (lc.cmd == LC_NOTE) {\n        char data_owner[17];\n        m_data.CopyData(offset, 16, data_owner);\n        data_owner[16] = '\\0';\n        offset += 16;\n        uint64_t fileoff = m_data.GetU64_unchecked(&offset);\n        uint64_t size = m_data.GetU64_unchecked(&offset);\n\n        // \"kern ver str\" has a uint32_t version and then a nul terminated\n        // c-string.\n        if (strcmp(\"kern ver str\", data_owner) == 0) {\n          offset = fileoff;\n          uint32_t version;\n          if (m_data.GetU32(&offset, &version, 1) != nullptr) {\n            if (version == 1) {\n              uint32_t strsize = size - sizeof(uint32_t);\n              char *buf = (char *)malloc(strsize);\n              if (buf) {\n                m_data.CopyData(offset, strsize, buf);\n                buf[strsize - 1] = '\\0';\n                result = buf;\n                if (buf)\n                  free(buf);\n                return result;\n              }\n            }\n          }\n        }\n      }\n      offset = cmd_offset + lc.cmdsize;\n    }\n\n    // Second, make a pass over the load commands looking for an obsolete\n    // LC_IDENT load command.\n    offset = MachHeaderSizeFromMagic(m_header.magic);\n    for (uint32_t i = 0; i < m_header.ncmds; ++i) {\n      const uint32_t cmd_offset = offset;\n      struct ident_command ident_command;\n      if (m_data.GetU32(&offset, &ident_command, 2) == nullptr)\n        break;\n      if (ident_command.cmd == LC_IDENT && ident_command.cmdsize != 0) {\n        char *buf = (char *)malloc(ident_command.cmdsize);\n        if (buf != nullptr && m_data.CopyData(offset, ident_command.cmdsize,\n                                              buf) == ident_command.cmdsize) {\n          buf[ident_command.cmdsize - 1] = '\\0';\n          result = buf;\n        }\n        if (buf)\n          free(buf);\n      }\n      offset = cmd_offset + ident_command.cmdsize;\n    }\n  }\n  return result;\n}\n\nbool ObjectFileMachO::GetCorefileMainBinaryInfo(addr_t &address, UUID &uuid,\n                                                ObjectFile::BinaryType &type) {\n  address = LLDB_INVALID_ADDRESS;\n  uuid.Clear();\n  ModuleSP module_sp(GetModule());\n  if (module_sp) {\n    std::lock_guard<std::recursive_mutex> guard(module_sp->GetMutex());\n    lldb::offset_t offset = MachHeaderSizeFromMagic(m_header.magic);\n    for (uint32_t i = 0; i < m_header.ncmds; ++i) {\n      const uint32_t cmd_offset = offset;\n      load_command lc;\n      if (m_data.GetU32(&offset, &lc.cmd, 2) == nullptr)\n        break;\n      if (lc.cmd == LC_NOTE) {\n        char data_owner[17];\n        memset(data_owner, 0, sizeof(data_owner));\n        m_data.CopyData(offset, 16, data_owner);\n        offset += 16;\n        uint64_t fileoff = m_data.GetU64_unchecked(&offset);\n        uint64_t size = m_data.GetU64_unchecked(&offset);\n\n        // \"main bin spec\" (main binary specification) data payload is\n        // formatted:\n        //    uint32_t version       [currently 1]\n        //    uint32_t type          [0 == unspecified, 1 == kernel,\n        //                            2 == user process, 3 == firmware ]\n        //    uint64_t address       [ UINT64_MAX if address not specified ]\n        //    uuid_t   uuid          [ all zero's if uuid not specified ]\n        //    uint32_t log2_pagesize [ process page size in log base\n        //                             2, e.g. 4k pages are 12.\n        //                             0 for unspecified ]\n        //    uint32_t unused        [ for alignment ]\n\n        if (strcmp(\"main bin spec\", data_owner) == 0 && size >= 32) {\n          offset = fileoff;\n          uint32_t version;\n          if (m_data.GetU32(&offset, &version, 1) != nullptr && version == 1) {\n            uint32_t binspec_type = 0;\n            uuid_t raw_uuid;\n            memset(raw_uuid, 0, sizeof(uuid_t));\n\n            if (m_data.GetU32(&offset, &binspec_type, 1) &&\n                m_data.GetU64(&offset, &address, 1) &&\n                m_data.CopyData(offset, sizeof(uuid_t), raw_uuid) != 0) {\n              uuid = UUID::fromOptionalData(raw_uuid, sizeof(uuid_t));\n              // convert the \"main bin spec\" type into our\n              // ObjectFile::BinaryType enum\n              switch (binspec_type) {\n              case 0:\n                type = eBinaryTypeUnknown;\n                break;\n              case 1:\n                type = eBinaryTypeKernel;\n                break;\n              case 2:\n                type = eBinaryTypeUser;\n                break;\n              case 3:\n                type = eBinaryTypeStandalone;\n                break;\n              }\n              return true;\n            }\n          }\n        }\n      }\n      offset = cmd_offset + lc.cmdsize;\n    }\n  }\n  return false;\n}\n\nlldb::RegisterContextSP\nObjectFileMachO::GetThreadContextAtIndex(uint32_t idx,\n                                         lldb_private::Thread &thread) {\n  lldb::RegisterContextSP reg_ctx_sp;\n\n  ModuleSP module_sp(GetModule());\n  if (module_sp) {\n    std::lock_guard<std::recursive_mutex> guard(module_sp->GetMutex());\n    if (!m_thread_context_offsets_valid)\n      GetNumThreadContexts();\n\n    const FileRangeArray::Entry *thread_context_file_range =\n        m_thread_context_offsets.GetEntryAtIndex(idx);\n    if (thread_context_file_range) {\n\n      DataExtractor data(m_data, thread_context_file_range->GetRangeBase(),\n                         thread_context_file_range->GetByteSize());\n\n      switch (m_header.cputype) {\n      case llvm::MachO::CPU_TYPE_ARM64:\n      case llvm::MachO::CPU_TYPE_ARM64_32:\n        reg_ctx_sp =\n            std::make_shared<RegisterContextDarwin_arm64_Mach>(thread, data);\n        break;\n\n      case llvm::MachO::CPU_TYPE_ARM:\n        reg_ctx_sp =\n            std::make_shared<RegisterContextDarwin_arm_Mach>(thread, data);\n        break;\n\n      case llvm::MachO::CPU_TYPE_I386:\n        reg_ctx_sp =\n            std::make_shared<RegisterContextDarwin_i386_Mach>(thread, data);\n        break;\n\n      case llvm::MachO::CPU_TYPE_X86_64:\n        reg_ctx_sp =\n            std::make_shared<RegisterContextDarwin_x86_64_Mach>(thread, data);\n        break;\n      }\n    }\n  }\n  return reg_ctx_sp;\n}\n\nObjectFile::Type ObjectFileMachO::CalculateType() {\n  switch (m_header.filetype) {\n  case MH_OBJECT: // 0x1u\n    if (GetAddressByteSize() == 4) {\n      // 32 bit kexts are just object files, but they do have a valid\n      // UUID load command.\n      if (GetUUID()) {\n        // this checking for the UUID load command is not enough we could\n        // eventually look for the symbol named \"OSKextGetCurrentIdentifier\" as\n        // this is required of kexts\n        if (m_strata == eStrataInvalid)\n          m_strata = eStrataKernel;\n        return eTypeSharedLibrary;\n      }\n    }\n    return eTypeObjectFile;\n\n  case MH_EXECUTE:\n    return eTypeExecutable; // 0x2u\n  case MH_FVMLIB:\n    return eTypeSharedLibrary; // 0x3u\n  case MH_CORE:\n    return eTypeCoreFile; // 0x4u\n  case MH_PRELOAD:\n    return eTypeSharedLibrary; // 0x5u\n  case MH_DYLIB:\n    return eTypeSharedLibrary; // 0x6u\n  case MH_DYLINKER:\n    return eTypeDynamicLinker; // 0x7u\n  case MH_BUNDLE:\n    return eTypeSharedLibrary; // 0x8u\n  case MH_DYLIB_STUB:\n    return eTypeStubLibrary; // 0x9u\n  case MH_DSYM:\n    return eTypeDebugInfo; // 0xAu\n  case MH_KEXT_BUNDLE:\n    return eTypeSharedLibrary; // 0xBu\n  default:\n    break;\n  }\n  return eTypeUnknown;\n}\n\nObjectFile::Strata ObjectFileMachO::CalculateStrata() {\n  switch (m_header.filetype) {\n  case MH_OBJECT: // 0x1u\n  {\n    // 32 bit kexts are just object files, but they do have a valid\n    // UUID load command.\n    if (GetUUID()) {\n      // this checking for the UUID load command is not enough we could\n      // eventually look for the symbol named \"OSKextGetCurrentIdentifier\" as\n      // this is required of kexts\n      if (m_type == eTypeInvalid)\n        m_type = eTypeSharedLibrary;\n\n      return eStrataKernel;\n    }\n  }\n    return eStrataUnknown;\n\n  case MH_EXECUTE: // 0x2u\n    // Check for the MH_DYLDLINK bit in the flags\n    if (m_header.flags & MH_DYLDLINK) {\n      return eStrataUser;\n    } else {\n      SectionList *section_list = GetSectionList();\n      if (section_list) {\n        static ConstString g_kld_section_name(\"__KLD\");\n        if (section_list->FindSectionByName(g_kld_section_name))\n          return eStrataKernel;\n      }\n    }\n    return eStrataRawImage;\n\n  case MH_FVMLIB:\n    return eStrataUser; // 0x3u\n  case MH_CORE:\n    return eStrataUnknown; // 0x4u\n  case MH_PRELOAD:\n    return eStrataRawImage; // 0x5u\n  case MH_DYLIB:\n    return eStrataUser; // 0x6u\n  case MH_DYLINKER:\n    return eStrataUser; // 0x7u\n  case MH_BUNDLE:\n    return eStrataUser; // 0x8u\n  case MH_DYLIB_STUB:\n    return eStrataUser; // 0x9u\n  case MH_DSYM:\n    return eStrataUnknown; // 0xAu\n  case MH_KEXT_BUNDLE:\n    return eStrataKernel; // 0xBu\n  default:\n    break;\n  }\n  return eStrataUnknown;\n}\n\nllvm::VersionTuple ObjectFileMachO::GetVersion() {\n  ModuleSP module_sp(GetModule());\n  if (module_sp) {\n    std::lock_guard<std::recursive_mutex> guard(module_sp->GetMutex());\n    struct dylib_command load_cmd;\n    lldb::offset_t offset = MachHeaderSizeFromMagic(m_header.magic);\n    uint32_t version_cmd = 0;\n    uint64_t version = 0;\n    uint32_t i;\n    for (i = 0; i < m_header.ncmds; ++i) {\n      const lldb::offset_t cmd_offset = offset;\n      if (m_data.GetU32(&offset, &load_cmd, 2) == nullptr)\n        break;\n\n      if (load_cmd.cmd == LC_ID_DYLIB) {\n        if (version_cmd == 0) {\n          version_cmd = load_cmd.cmd;\n          if (m_data.GetU32(&offset, &load_cmd.dylib, 4) == nullptr)\n            break;\n          version = load_cmd.dylib.current_version;\n        }\n        break; // Break for now unless there is another more complete version\n               // number load command in the future.\n      }\n      offset = cmd_offset + load_cmd.cmdsize;\n    }\n\n    if (version_cmd == LC_ID_DYLIB) {\n      unsigned major = (version & 0xFFFF0000ull) >> 16;\n      unsigned minor = (version & 0x0000FF00ull) >> 8;\n      unsigned subminor = (version & 0x000000FFull);\n      return llvm::VersionTuple(major, minor, subminor);\n    }\n  }\n  return llvm::VersionTuple();\n}\n\nArchSpec ObjectFileMachO::GetArchitecture() {\n  ModuleSP module_sp(GetModule());\n  ArchSpec arch;\n  if (module_sp) {\n    std::lock_guard<std::recursive_mutex> guard(module_sp->GetMutex());\n\n    return GetArchitecture(module_sp, m_header, m_data,\n                           MachHeaderSizeFromMagic(m_header.magic));\n  }\n  return arch;\n}\n\nvoid ObjectFileMachO::GetProcessSharedCacheUUID(Process *process,\n                                                addr_t &base_addr, UUID &uuid) {\n  uuid.Clear();\n  base_addr = LLDB_INVALID_ADDRESS;\n  if (process && process->GetDynamicLoader()) {\n    DynamicLoader *dl = process->GetDynamicLoader();\n    LazyBool using_shared_cache;\n    LazyBool private_shared_cache;\n    dl->GetSharedCacheInformation(base_addr, uuid, using_shared_cache,\n                                  private_shared_cache);\n  }\n  Log *log(lldb_private::GetLogIfAnyCategoriesSet(LIBLLDB_LOG_SYMBOLS |\n                                                  LIBLLDB_LOG_PROCESS));\n  LLDB_LOGF(\n      log,\n      \"inferior process shared cache has a UUID of %s, base address 0x%\" PRIx64,\n      uuid.GetAsString().c_str(), base_addr);\n}\n\n// From dyld SPI header dyld_process_info.h\ntypedef void *dyld_process_info;\nstruct lldb_copy__dyld_process_cache_info {\n  uuid_t cacheUUID;          // UUID of cache used by process\n  uint64_t cacheBaseAddress; // load address of dyld shared cache\n  bool noCache;              // process is running without a dyld cache\n  bool privateCache; // process is using a private copy of its dyld cache\n};\n\n// #including mach/mach.h pulls in machine.h & CPU_TYPE_ARM etc conflicts with\n// llvm enum definitions llvm::MachO::CPU_TYPE_ARM turning them into compile\n// errors. So we need to use the actual underlying types of task_t and\n// kern_return_t below.\nextern \"C\" unsigned int /*task_t*/ mach_task_self();\n\nvoid ObjectFileMachO::GetLLDBSharedCacheUUID(addr_t &base_addr, UUID &uuid) {\n  uuid.Clear();\n  base_addr = LLDB_INVALID_ADDRESS;\n\n#if defined(__APPLE__)\n  uint8_t *(*dyld_get_all_image_infos)(void);\n  dyld_get_all_image_infos =\n      (uint8_t * (*)()) dlsym(RTLD_DEFAULT, \"_dyld_get_all_image_infos\");\n  if (dyld_get_all_image_infos) {\n    uint8_t *dyld_all_image_infos_address = dyld_get_all_image_infos();\n    if (dyld_all_image_infos_address) {\n      uint32_t *version = (uint32_t *)\n          dyld_all_image_infos_address; // version <mach-o/dyld_images.h>\n      if (*version >= 13) {\n        uuid_t *sharedCacheUUID_address = 0;\n        int wordsize = sizeof(uint8_t *);\n        if (wordsize == 8) {\n          sharedCacheUUID_address =\n              (uuid_t *)((uint8_t *)dyld_all_image_infos_address +\n                         160); // sharedCacheUUID <mach-o/dyld_images.h>\n          if (*version >= 15)\n            base_addr =\n                *(uint64_t\n                      *)((uint8_t *)dyld_all_image_infos_address +\n                         176); // sharedCacheBaseAddress <mach-o/dyld_images.h>\n        } else {\n          sharedCacheUUID_address =\n              (uuid_t *)((uint8_t *)dyld_all_image_infos_address +\n                         84); // sharedCacheUUID <mach-o/dyld_images.h>\n          if (*version >= 15) {\n            base_addr = 0;\n            base_addr =\n                *(uint32_t\n                      *)((uint8_t *)dyld_all_image_infos_address +\n                         100); // sharedCacheBaseAddress <mach-o/dyld_images.h>\n          }\n        }\n        uuid = UUID::fromOptionalData(sharedCacheUUID_address, sizeof(uuid_t));\n      }\n    }\n  } else {\n    // Exists in macOS 10.12 and later, iOS 10.0 and later - dyld SPI\n    dyld_process_info (*dyld_process_info_create)(\n        unsigned int /* task_t */ task, uint64_t timestamp,\n        unsigned int /*kern_return_t*/ *kernelError);\n    void (*dyld_process_info_get_cache)(void *info, void *cacheInfo);\n    void (*dyld_process_info_release)(dyld_process_info info);\n\n    dyld_process_info_create = (void *(*)(unsigned int /* task_t */, uint64_t,\n                                          unsigned int /*kern_return_t*/ *))\n        dlsym(RTLD_DEFAULT, \"_dyld_process_info_create\");\n    dyld_process_info_get_cache = (void (*)(void *, void *))dlsym(\n        RTLD_DEFAULT, \"_dyld_process_info_get_cache\");\n    dyld_process_info_release =\n        (void (*)(void *))dlsym(RTLD_DEFAULT, \"_dyld_process_info_release\");\n\n    if (dyld_process_info_create && dyld_process_info_get_cache) {\n      unsigned int /*kern_return_t */ kern_ret;\n      dyld_process_info process_info =\n          dyld_process_info_create(::mach_task_self(), 0, &kern_ret);\n      if (process_info) {\n        struct lldb_copy__dyld_process_cache_info sc_info;\n        memset(&sc_info, 0, sizeof(struct lldb_copy__dyld_process_cache_info));\n        dyld_process_info_get_cache(process_info, &sc_info);\n        if (sc_info.cacheBaseAddress != 0) {\n          base_addr = sc_info.cacheBaseAddress;\n          uuid = UUID::fromOptionalData(sc_info.cacheUUID, sizeof(uuid_t));\n        }\n        dyld_process_info_release(process_info);\n      }\n    }\n  }\n  Log *log(lldb_private::GetLogIfAnyCategoriesSet(LIBLLDB_LOG_SYMBOLS |\n                                                  LIBLLDB_LOG_PROCESS));\n  if (log && uuid.IsValid())\n    LLDB_LOGF(log,\n              \"lldb's in-memory shared cache has a UUID of %s base address of \"\n              \"0x%\" PRIx64,\n              uuid.GetAsString().c_str(), base_addr);\n#endif\n}\n\nllvm::VersionTuple ObjectFileMachO::GetMinimumOSVersion() {\n  if (!m_min_os_version) {\n    lldb::offset_t offset = MachHeaderSizeFromMagic(m_header.magic);\n    for (uint32_t i = 0; i < m_header.ncmds; ++i) {\n      const lldb::offset_t load_cmd_offset = offset;\n\n      version_min_command lc;\n      if (m_data.GetU32(&offset, &lc.cmd, 2) == nullptr)\n        break;\n      if (lc.cmd == llvm::MachO::LC_VERSION_MIN_MACOSX ||\n          lc.cmd == llvm::MachO::LC_VERSION_MIN_IPHONEOS ||\n          lc.cmd == llvm::MachO::LC_VERSION_MIN_TVOS ||\n          lc.cmd == llvm::MachO::LC_VERSION_MIN_WATCHOS) {\n        if (m_data.GetU32(&offset, &lc.version,\n                          (sizeof(lc) / sizeof(uint32_t)) - 2)) {\n          const uint32_t xxxx = lc.version >> 16;\n          const uint32_t yy = (lc.version >> 8) & 0xffu;\n          const uint32_t zz = lc.version & 0xffu;\n          if (xxxx) {\n            m_min_os_version = llvm::VersionTuple(xxxx, yy, zz);\n            break;\n          }\n        }\n      } else if (lc.cmd == llvm::MachO::LC_BUILD_VERSION) {\n        // struct build_version_command {\n        //     uint32_t    cmd;            /* LC_BUILD_VERSION */\n        //     uint32_t    cmdsize;        /* sizeof(struct\n        //     build_version_command) plus */\n        //                                 /* ntools * sizeof(struct\n        //                                 build_tool_version) */\n        //     uint32_t    platform;       /* platform */\n        //     uint32_t    minos;          /* X.Y.Z is encoded in nibbles\n        //     xxxx.yy.zz */ uint32_t    sdk;            /* X.Y.Z is encoded in\n        //     nibbles xxxx.yy.zz */ uint32_t    ntools;         /* number of\n        //     tool entries following this */\n        // };\n\n        offset += 4; // skip platform\n        uint32_t minos = m_data.GetU32(&offset);\n\n        const uint32_t xxxx = minos >> 16;\n        const uint32_t yy = (minos >> 8) & 0xffu;\n        const uint32_t zz = minos & 0xffu;\n        if (xxxx) {\n          m_min_os_version = llvm::VersionTuple(xxxx, yy, zz);\n          break;\n        }\n      }\n\n      offset = load_cmd_offset + lc.cmdsize;\n    }\n\n    if (!m_min_os_version) {\n      // Set version to an empty value so we don't keep trying to\n      m_min_os_version = llvm::VersionTuple();\n    }\n  }\n\n  return *m_min_os_version;\n}\n\nllvm::VersionTuple ObjectFileMachO::GetSDKVersion() {\n  if (!m_sdk_versions.hasValue()) {\n    lldb::offset_t offset = MachHeaderSizeFromMagic(m_header.magic);\n    for (uint32_t i = 0; i < m_header.ncmds; ++i) {\n      const lldb::offset_t load_cmd_offset = offset;\n\n      version_min_command lc;\n      if (m_data.GetU32(&offset, &lc.cmd, 2) == nullptr)\n        break;\n      if (lc.cmd == llvm::MachO::LC_VERSION_MIN_MACOSX ||\n          lc.cmd == llvm::MachO::LC_VERSION_MIN_IPHONEOS ||\n          lc.cmd == llvm::MachO::LC_VERSION_MIN_TVOS ||\n          lc.cmd == llvm::MachO::LC_VERSION_MIN_WATCHOS) {\n        if (m_data.GetU32(&offset, &lc.version,\n                          (sizeof(lc) / sizeof(uint32_t)) - 2)) {\n          const uint32_t xxxx = lc.sdk >> 16;\n          const uint32_t yy = (lc.sdk >> 8) & 0xffu;\n          const uint32_t zz = lc.sdk & 0xffu;\n          if (xxxx) {\n            m_sdk_versions = llvm::VersionTuple(xxxx, yy, zz);\n            break;\n          } else {\n            GetModule()->ReportWarning(\"minimum OS version load command with \"\n                                       \"invalid (0) version found.\");\n          }\n        }\n      }\n      offset = load_cmd_offset + lc.cmdsize;\n    }\n\n    if (!m_sdk_versions.hasValue()) {\n      offset = MachHeaderSizeFromMagic(m_header.magic);\n      for (uint32_t i = 0; i < m_header.ncmds; ++i) {\n        const lldb::offset_t load_cmd_offset = offset;\n\n        version_min_command lc;\n        if (m_data.GetU32(&offset, &lc.cmd, 2) == nullptr)\n          break;\n        if (lc.cmd == llvm::MachO::LC_BUILD_VERSION) {\n          // struct build_version_command {\n          //     uint32_t    cmd;            /* LC_BUILD_VERSION */\n          //     uint32_t    cmdsize;        /* sizeof(struct\n          //     build_version_command) plus */\n          //                                 /* ntools * sizeof(struct\n          //                                 build_tool_version) */\n          //     uint32_t    platform;       /* platform */\n          //     uint32_t    minos;          /* X.Y.Z is encoded in nibbles\n          //     xxxx.yy.zz */ uint32_t    sdk;            /* X.Y.Z is encoded\n          //     in nibbles xxxx.yy.zz */ uint32_t    ntools;         /* number\n          //     of tool entries following this */\n          // };\n\n          offset += 4; // skip platform\n          uint32_t minos = m_data.GetU32(&offset);\n\n          const uint32_t xxxx = minos >> 16;\n          const uint32_t yy = (minos >> 8) & 0xffu;\n          const uint32_t zz = minos & 0xffu;\n          if (xxxx) {\n            m_sdk_versions = llvm::VersionTuple(xxxx, yy, zz);\n            break;\n          }\n        }\n        offset = load_cmd_offset + lc.cmdsize;\n      }\n    }\n\n    if (!m_sdk_versions.hasValue())\n      m_sdk_versions = llvm::VersionTuple();\n  }\n\n  return m_sdk_versions.getValue();\n}\n\nbool ObjectFileMachO::GetIsDynamicLinkEditor() {\n  return m_header.filetype == llvm::MachO::MH_DYLINKER;\n}\n\nbool ObjectFileMachO::AllowAssemblyEmulationUnwindPlans() {\n  return m_allow_assembly_emulation_unwind_plans;\n}\n\n// PluginInterface protocol\nlldb_private::ConstString ObjectFileMachO::GetPluginName() {\n  return GetPluginNameStatic();\n}\n\nuint32_t ObjectFileMachO::GetPluginVersion() { return 1; }\n\nSection *ObjectFileMachO::GetMachHeaderSection() {\n  // Find the first address of the mach header which is the first non-zero file\n  // sized section whose file offset is zero. This is the base file address of\n  // the mach-o file which can be subtracted from the vmaddr of the other\n  // segments found in memory and added to the load address\n  ModuleSP module_sp = GetModule();\n  if (!module_sp)\n    return nullptr;\n  SectionList *section_list = GetSectionList();\n  if (!section_list)\n    return nullptr;\n  const size_t num_sections = section_list->GetSize();\n  for (size_t sect_idx = 0; sect_idx < num_sections; ++sect_idx) {\n    Section *section = section_list->GetSectionAtIndex(sect_idx).get();\n    if (section->GetFileOffset() == 0 && SectionIsLoadable(section))\n      return section;\n  }\n  return nullptr;\n}\n\nbool ObjectFileMachO::SectionIsLoadable(const Section *section) {\n  if (!section)\n    return false;\n  const bool is_dsym = (m_header.filetype == MH_DSYM);\n  if (section->GetFileSize() == 0 && !is_dsym)\n    return false;\n  if (section->IsThreadSpecific())\n    return false;\n  if (GetModule().get() != section->GetModule().get())\n    return false;\n  // Be careful with __LINKEDIT and __DWARF segments\n  if (section->GetName() == GetSegmentNameLINKEDIT() ||\n      section->GetName() == GetSegmentNameDWARF()) {\n    // Only map __LINKEDIT and __DWARF if we have an in memory image and\n    // this isn't a kernel binary like a kext or mach_kernel.\n    const bool is_memory_image = (bool)m_process_wp.lock();\n    const Strata strata = GetStrata();\n    if (is_memory_image == false || strata == eStrataKernel)\n      return false;\n  }\n  return true;\n}\n\nlldb::addr_t ObjectFileMachO::CalculateSectionLoadAddressForMemoryImage(\n    lldb::addr_t header_load_address, const Section *header_section,\n    const Section *section) {\n  ModuleSP module_sp = GetModule();\n  if (module_sp && header_section && section &&\n      header_load_address != LLDB_INVALID_ADDRESS) {\n    lldb::addr_t file_addr = header_section->GetFileAddress();\n    if (file_addr != LLDB_INVALID_ADDRESS && SectionIsLoadable(section))\n      return section->GetFileAddress() - file_addr + header_load_address;\n  }\n  return LLDB_INVALID_ADDRESS;\n}\n\nbool ObjectFileMachO::SetLoadAddress(Target &target, lldb::addr_t value,\n                                     bool value_is_offset) {\n  ModuleSP module_sp = GetModule();\n  if (!module_sp)\n    return false;\n\n  SectionList *section_list = GetSectionList();\n  if (!section_list)\n    return false;\n\n  size_t num_loaded_sections = 0;\n  const size_t num_sections = section_list->GetSize();\n\n  if (value_is_offset) {\n    // \"value\" is an offset to apply to each top level segment\n    for (size_t sect_idx = 0; sect_idx < num_sections; ++sect_idx) {\n      // Iterate through the object file sections to find all of the\n      // sections that size on disk (to avoid __PAGEZERO) and load them\n      SectionSP section_sp(section_list->GetSectionAtIndex(sect_idx));\n      if (SectionIsLoadable(section_sp.get()))\n        if (target.GetSectionLoadList().SetSectionLoadAddress(\n                section_sp, section_sp->GetFileAddress() + value))\n          ++num_loaded_sections;\n    }\n  } else {\n    // \"value\" is the new base address of the mach_header, adjust each\n    // section accordingly\n\n    Section *mach_header_section = GetMachHeaderSection();\n    if (mach_header_section) {\n      for (size_t sect_idx = 0; sect_idx < num_sections; ++sect_idx) {\n        SectionSP section_sp(section_list->GetSectionAtIndex(sect_idx));\n\n        lldb::addr_t section_load_addr =\n            CalculateSectionLoadAddressForMemoryImage(\n                value, mach_header_section, section_sp.get());\n        if (section_load_addr != LLDB_INVALID_ADDRESS) {\n          if (target.GetSectionLoadList().SetSectionLoadAddress(\n                  section_sp, section_load_addr))\n            ++num_loaded_sections;\n        }\n      }\n    }\n  }\n  return num_loaded_sections > 0;\n}\n\nbool ObjectFileMachO::SaveCore(const lldb::ProcessSP &process_sp,\n                               const FileSpec &outfile, Status &error) {\n  if (!process_sp)\n    return false;\n\n  Target &target = process_sp->GetTarget();\n  const ArchSpec target_arch = target.GetArchitecture();\n  const llvm::Triple &target_triple = target_arch.GetTriple();\n  if (target_triple.getVendor() == llvm::Triple::Apple &&\n      (target_triple.getOS() == llvm::Triple::MacOSX ||\n       target_triple.getOS() == llvm::Triple::IOS ||\n       target_triple.getOS() == llvm::Triple::WatchOS ||\n       target_triple.getOS() == llvm::Triple::TvOS)) {\n    // NEED_BRIDGEOS_TRIPLE target_triple.getOS() == llvm::Triple::BridgeOS))\n    // {\n    bool make_core = false;\n    switch (target_arch.GetMachine()) {\n    case llvm::Triple::aarch64:\n    case llvm::Triple::aarch64_32:\n    case llvm::Triple::arm:\n    case llvm::Triple::thumb:\n    case llvm::Triple::x86:\n    case llvm::Triple::x86_64:\n      make_core = true;\n      break;\n    default:\n      error.SetErrorStringWithFormat(\"unsupported core architecture: %s\",\n                                     target_triple.str().c_str());\n      break;\n    }\n\n    if (make_core) {\n      std::vector<segment_command_64> segment_load_commands;\n      //                uint32_t range_info_idx = 0;\n      MemoryRegionInfo range_info;\n      Status range_error = process_sp->GetMemoryRegionInfo(0, range_info);\n      const uint32_t addr_byte_size = target_arch.GetAddressByteSize();\n      const ByteOrder byte_order = target_arch.GetByteOrder();\n      if (range_error.Success()) {\n        while (range_info.GetRange().GetRangeBase() != LLDB_INVALID_ADDRESS) {\n          const addr_t addr = range_info.GetRange().GetRangeBase();\n          const addr_t size = range_info.GetRange().GetByteSize();\n\n          if (size == 0)\n            break;\n\n          // Calculate correct protections\n          uint32_t prot = 0;\n          if (range_info.GetReadable() == MemoryRegionInfo::eYes)\n            prot |= VM_PROT_READ;\n          if (range_info.GetWritable() == MemoryRegionInfo::eYes)\n            prot |= VM_PROT_WRITE;\n          if (range_info.GetExecutable() == MemoryRegionInfo::eYes)\n            prot |= VM_PROT_EXECUTE;\n\n          if (prot != 0) {\n            uint32_t cmd_type = LC_SEGMENT_64;\n            uint32_t segment_size = sizeof(segment_command_64);\n            if (addr_byte_size == 4) {\n              cmd_type = LC_SEGMENT;\n              segment_size = sizeof(segment_command);\n            }\n            segment_command_64 segment = {\n                cmd_type,     // uint32_t cmd;\n                segment_size, // uint32_t cmdsize;\n                {0},          // char segname[16];\n                addr, // uint64_t vmaddr;    // uint32_t for 32-bit Mach-O\n                size, // uint64_t vmsize;    // uint32_t for 32-bit Mach-O\n                0,    // uint64_t fileoff;   // uint32_t for 32-bit Mach-O\n                size, // uint64_t filesize;  // uint32_t for 32-bit Mach-O\n                prot, // uint32_t maxprot;\n                prot, // uint32_t initprot;\n                0,    // uint32_t nsects;\n                0};   // uint32_t flags;\n            segment_load_commands.push_back(segment);\n          } else {\n            // No protections and a size of 1 used to be returned from old\n            // debugservers when we asked about a region that was past the\n            // last memory region and it indicates the end...\n            if (size == 1)\n              break;\n          }\n\n          range_error = process_sp->GetMemoryRegionInfo(\n              range_info.GetRange().GetRangeEnd(), range_info);\n          if (range_error.Fail())\n            break;\n        }\n\n        StreamString buffer(Stream::eBinary, addr_byte_size, byte_order);\n\n        mach_header_64 mach_header;\n        if (addr_byte_size == 8) {\n          mach_header.magic = MH_MAGIC_64;\n        } else {\n          mach_header.magic = MH_MAGIC;\n        }\n        mach_header.cputype = target_arch.GetMachOCPUType();\n        mach_header.cpusubtype = target_arch.GetMachOCPUSubType();\n        mach_header.filetype = MH_CORE;\n        mach_header.ncmds = segment_load_commands.size();\n        mach_header.flags = 0;\n        mach_header.reserved = 0;\n        ThreadList &thread_list = process_sp->GetThreadList();\n        const uint32_t num_threads = thread_list.GetSize();\n\n        // Make an array of LC_THREAD data items. Each one contains the\n        // contents of the LC_THREAD load command. The data doesn't contain\n        // the load command + load command size, we will add the load command\n        // and load command size as we emit the data.\n        std::vector<StreamString> LC_THREAD_datas(num_threads);\n        for (auto &LC_THREAD_data : LC_THREAD_datas) {\n          LC_THREAD_data.GetFlags().Set(Stream::eBinary);\n          LC_THREAD_data.SetAddressByteSize(addr_byte_size);\n          LC_THREAD_data.SetByteOrder(byte_order);\n        }\n        for (uint32_t thread_idx = 0; thread_idx < num_threads; ++thread_idx) {\n          ThreadSP thread_sp(thread_list.GetThreadAtIndex(thread_idx));\n          if (thread_sp) {\n            switch (mach_header.cputype) {\n            case llvm::MachO::CPU_TYPE_ARM64:\n            case llvm::MachO::CPU_TYPE_ARM64_32:\n              RegisterContextDarwin_arm64_Mach::Create_LC_THREAD(\n                  thread_sp.get(), LC_THREAD_datas[thread_idx]);\n              break;\n\n            case llvm::MachO::CPU_TYPE_ARM:\n              RegisterContextDarwin_arm_Mach::Create_LC_THREAD(\n                  thread_sp.get(), LC_THREAD_datas[thread_idx]);\n              break;\n\n            case llvm::MachO::CPU_TYPE_I386:\n              RegisterContextDarwin_i386_Mach::Create_LC_THREAD(\n                  thread_sp.get(), LC_THREAD_datas[thread_idx]);\n              break;\n\n            case llvm::MachO::CPU_TYPE_X86_64:\n              RegisterContextDarwin_x86_64_Mach::Create_LC_THREAD(\n                  thread_sp.get(), LC_THREAD_datas[thread_idx]);\n              break;\n            }\n          }\n        }\n\n        // The size of the load command is the size of the segments...\n        if (addr_byte_size == 8) {\n          mach_header.sizeofcmds =\n              segment_load_commands.size() * sizeof(struct segment_command_64);\n        } else {\n          mach_header.sizeofcmds =\n              segment_load_commands.size() * sizeof(struct segment_command);\n        }\n\n        // and the size of all LC_THREAD load command\n        for (const auto &LC_THREAD_data : LC_THREAD_datas) {\n          ++mach_header.ncmds;\n          mach_header.sizeofcmds += 8 + LC_THREAD_data.GetSize();\n        }\n\n        // Write the mach header\n        buffer.PutHex32(mach_header.magic);\n        buffer.PutHex32(mach_header.cputype);\n        buffer.PutHex32(mach_header.cpusubtype);\n        buffer.PutHex32(mach_header.filetype);\n        buffer.PutHex32(mach_header.ncmds);\n        buffer.PutHex32(mach_header.sizeofcmds);\n        buffer.PutHex32(mach_header.flags);\n        if (addr_byte_size == 8) {\n          buffer.PutHex32(mach_header.reserved);\n        }\n\n        // Skip the mach header and all load commands and align to the next\n        // 0x1000 byte boundary\n        addr_t file_offset = buffer.GetSize() + mach_header.sizeofcmds;\n        if (file_offset & 0x00000fff) {\n          file_offset += 0x00001000ull;\n          file_offset &= (~0x00001000ull + 1);\n        }\n\n        for (auto &segment : segment_load_commands) {\n          segment.fileoff = file_offset;\n          file_offset += segment.filesize;\n        }\n\n        // Write out all of the LC_THREAD load commands\n        for (const auto &LC_THREAD_data : LC_THREAD_datas) {\n          const size_t LC_THREAD_data_size = LC_THREAD_data.GetSize();\n          buffer.PutHex32(LC_THREAD);\n          buffer.PutHex32(8 + LC_THREAD_data_size); // cmd + cmdsize + data\n          buffer.Write(LC_THREAD_data.GetString().data(), LC_THREAD_data_size);\n        }\n\n        // Write out all of the segment load commands\n        for (const auto &segment : segment_load_commands) {\n          printf(\"0x%8.8x 0x%8.8x [0x%16.16\" PRIx64 \" - 0x%16.16\" PRIx64\n                 \") [0x%16.16\" PRIx64 \" 0x%16.16\" PRIx64\n                 \") 0x%8.8x 0x%8.8x 0x%8.8x 0x%8.8x]\\n\",\n                 segment.cmd, segment.cmdsize, segment.vmaddr,\n                 segment.vmaddr + segment.vmsize, segment.fileoff,\n                 segment.filesize, segment.maxprot, segment.initprot,\n                 segment.nsects, segment.flags);\n\n          buffer.PutHex32(segment.cmd);\n          buffer.PutHex32(segment.cmdsize);\n          buffer.PutRawBytes(segment.segname, sizeof(segment.segname));\n          if (addr_byte_size == 8) {\n            buffer.PutHex64(segment.vmaddr);\n            buffer.PutHex64(segment.vmsize);\n            buffer.PutHex64(segment.fileoff);\n            buffer.PutHex64(segment.filesize);\n          } else {\n            buffer.PutHex32(static_cast<uint32_t>(segment.vmaddr));\n            buffer.PutHex32(static_cast<uint32_t>(segment.vmsize));\n            buffer.PutHex32(static_cast<uint32_t>(segment.fileoff));\n            buffer.PutHex32(static_cast<uint32_t>(segment.filesize));\n          }\n          buffer.PutHex32(segment.maxprot);\n          buffer.PutHex32(segment.initprot);\n          buffer.PutHex32(segment.nsects);\n          buffer.PutHex32(segment.flags);\n        }\n\n        std::string core_file_path(outfile.GetPath());\n        auto core_file = FileSystem::Instance().Open(\n            outfile, File::eOpenOptionWrite | File::eOpenOptionTruncate |\n                         File::eOpenOptionCanCreate);\n        if (!core_file) {\n          error = core_file.takeError();\n        } else {\n          // Read 1 page at a time\n          uint8_t bytes[0x1000];\n          // Write the mach header and load commands out to the core file\n          size_t bytes_written = buffer.GetString().size();\n          error =\n              core_file.get()->Write(buffer.GetString().data(), bytes_written);\n          if (error.Success()) {\n            // Now write the file data for all memory segments in the process\n            for (const auto &segment : segment_load_commands) {\n              if (core_file.get()->SeekFromStart(segment.fileoff) == -1) {\n                error.SetErrorStringWithFormat(\n                    \"unable to seek to offset 0x%\" PRIx64 \" in '%s'\",\n                    segment.fileoff, core_file_path.c_str());\n                break;\n              }\n\n              printf(\"Saving %\" PRId64\n                     \" bytes of data for memory region at 0x%\" PRIx64 \"\\n\",\n                     segment.vmsize, segment.vmaddr);\n              addr_t bytes_left = segment.vmsize;\n              addr_t addr = segment.vmaddr;\n              Status memory_read_error;\n              while (bytes_left > 0 && error.Success()) {\n                const size_t bytes_to_read =\n                    bytes_left > sizeof(bytes) ? sizeof(bytes) : bytes_left;\n\n                // In a savecore setting, we don't really care about caching,\n                // as the data is dumped and very likely never read again,\n                // so we call ReadMemoryFromInferior to bypass it.\n                const size_t bytes_read = process_sp->ReadMemoryFromInferior(\n                    addr, bytes, bytes_to_read, memory_read_error);\n\n                if (bytes_read == bytes_to_read) {\n                  size_t bytes_written = bytes_read;\n                  error = core_file.get()->Write(bytes, bytes_written);\n                  bytes_left -= bytes_read;\n                  addr += bytes_read;\n                } else {\n                  // Some pages within regions are not readable, those should\n                  // be zero filled\n                  memset(bytes, 0, bytes_to_read);\n                  size_t bytes_written = bytes_to_read;\n                  error = core_file.get()->Write(bytes, bytes_written);\n                  bytes_left -= bytes_to_read;\n                  addr += bytes_to_read;\n                }\n              }\n            }\n          }\n        }\n      } else {\n        error.SetErrorString(\n            \"process doesn't support getting memory region info\");\n      }\n    }\n    return true; // This is the right plug to handle saving core files for\n                 // this process\n  }\n  return false;\n}\n"}}, "reports": [{"events": [{"location": {"col": 8, "file": 30, "line": 1960}, "message": "'operator<' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lldb/source/Plugins/ObjectFile/Mach-O/ObjectFileMachO.cpp", "reportHash": "64a5dfe88d6a5cd0abea97ce6b3af6b9", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}]};
      window.onload = function() {
        if (!browserCompatible) {
          setNonCompatibleBrowserMessage();
        } else {
          BugViewer.init(data.files, data.reports);
          BugViewer.create();
          BugViewer.initByUrl();
        }
      };
    </script>
  </head>
  <body>
  <div class="container">
    <div id="content">
      <div id="side-bar">
        <div class="header">
          <a href="index.html" class="button">&#8249; Return to List</a>
        </div>
        <div id="report-nav">
          <div class="header">Reports</div>
        </div>
      </div>
      <div id="editor-wrapper">
        <div class="header">
          <div id="file">
            <span class="label">File:</span>
            <span id="file-path"></span>
          </div>
          <div id="checker">
            <span class="label">Checker name:</span>
            <span id="checker-name"></span>
          </div>
          <div id="review-status-wrapper">
            <span class="label">Review status:</span>
            <span id="review-status"></span>
          </div>
        </div>
        <div id="editor"></div>
      </div>
    </div>
  </div>
  </body>
</html>
