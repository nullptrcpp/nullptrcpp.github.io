<!DOCTYPE html>
<html>
  <head>
    <title>Plist HTML Viewer</title>

    <meta charset="UTF-8">

    <style type="text/css">
      .CodeMirror{font-family:monospace;height:300px;color:#000;direction:ltr}.CodeMirror-lines{padding:4px 0}.CodeMirror pre{padding:0 4px}.CodeMirror-gutter-filler,.CodeMirror-scrollbar-filler{background-color:#fff}.CodeMirror-gutters{border-right:1px solid #ddd;background-color:#f7f7f7;white-space:nowrap}.CodeMirror-linenumber{padding:0 3px 0 5px;min-width:20px;text-align:right;color:#999;white-space:nowrap}.CodeMirror-guttermarker{color:#000}.CodeMirror-guttermarker-subtle{color:#999}.CodeMirror-cursor{border-left:1px solid #000;border-right:none;width:0}.CodeMirror div.CodeMirror-secondarycursor{border-left:1px solid silver}.cm-fat-cursor .CodeMirror-cursor{width:auto;border:0!important;background:#7e7}.cm-fat-cursor div.CodeMirror-cursors{z-index:1}.cm-animate-fat-cursor{width:auto;border:0;-webkit-animation:blink 1.06s steps(1) infinite;-moz-animation:blink 1.06s steps(1) infinite;animation:blink 1.06s steps(1) infinite;background-color:#7e7}@-moz-keyframes blink{50%{background-color:transparent}}@-webkit-keyframes blink{50%{background-color:transparent}}@keyframes blink{50%{background-color:transparent}}.cm-tab{display:inline-block;text-decoration:inherit}.CodeMirror-rulers{position:absolute;left:0;right:0;top:-50px;bottom:-20px;overflow:hidden}.CodeMirror-ruler{border-left:1px solid #ccc;top:0;bottom:0;position:absolute}.cm-s-default .cm-header{color:#00f}.cm-s-default .cm-quote{color:#090}.cm-negative{color:#d44}.cm-positive{color:#292}.cm-header,.cm-strong{font-weight:700}.cm-em{font-style:italic}.cm-link{text-decoration:underline}.cm-strikethrough{text-decoration:line-through}.cm-s-default .cm-keyword{color:#708}.cm-s-default .cm-atom{color:#219}.cm-s-default .cm-number{color:#164}.cm-s-default .cm-def{color:#00f}.cm-s-default .cm-variable-2{color:#05a}.cm-s-default .cm-type,.cm-s-default .cm-variable-3{color:#085}.cm-s-default .cm-comment{color:#a50}.cm-s-default .cm-string{color:#a11}.cm-s-default .cm-string-2{color:#f50}.cm-s-default .cm-meta{color:#555}.cm-s-default .cm-qualifier{color:#555}.cm-s-default .cm-builtin{color:#30a}.cm-s-default .cm-bracket{color:#997}.cm-s-default .cm-tag{color:#170}.cm-s-default .cm-attribute{color:#00c}.cm-s-default .cm-hr{color:#999}.cm-s-default .cm-link{color:#00c}.cm-s-default .cm-error{color:red}.cm-invalidchar{color:red}.CodeMirror-composing{border-bottom:2px solid}div.CodeMirror span.CodeMirror-matchingbracket{color:#0f0}div.CodeMirror span.CodeMirror-nonmatchingbracket{color:#f22}.CodeMirror-matchingtag{background:rgba(255,150,0,.3)}.CodeMirror-activeline-background{background:#e8f2ff}.CodeMirror{position:relative;overflow:hidden;background:#fff}.CodeMirror-scroll{overflow:scroll!important;margin-bottom:-30px;margin-right:-30px;padding-bottom:30px;height:100%;outline:0;position:relative}.CodeMirror-sizer{position:relative;border-right:30px solid transparent}.CodeMirror-gutter-filler,.CodeMirror-hscrollbar,.CodeMirror-scrollbar-filler,.CodeMirror-vscrollbar{position:absolute;z-index:6;display:none}.CodeMirror-vscrollbar{right:0;top:0;overflow-x:hidden;overflow-y:scroll}.CodeMirror-hscrollbar{bottom:0;left:0;overflow-y:hidden;overflow-x:scroll}.CodeMirror-scrollbar-filler{right:0;bottom:0}.CodeMirror-gutter-filler{left:0;bottom:0}.CodeMirror-gutters{position:absolute;left:0;top:0;min-height:100%;z-index:3}.CodeMirror-gutter{white-space:normal;height:100%;display:inline-block;vertical-align:top;margin-bottom:-30px}.CodeMirror-gutter-wrapper{position:absolute;z-index:4;background:0 0!important;border:none!important}.CodeMirror-gutter-background{position:absolute;top:0;bottom:0;z-index:4}.CodeMirror-gutter-elt{position:absolute;cursor:default;z-index:4}.CodeMirror-gutter-wrapper ::selection{background-color:transparent}.CodeMirror-gutter-wrapper ::-moz-selection{background-color:transparent}.CodeMirror-lines{cursor:text;min-height:1px}.CodeMirror pre{-moz-border-radius:0;-webkit-border-radius:0;border-radius:0;border-width:0;background:0 0;font-family:inherit;font-size:inherit;margin:0;white-space:pre;word-wrap:normal;line-height:inherit;color:inherit;z-index:2;position:relative;overflow:visible;-webkit-tap-highlight-color:transparent;-webkit-font-variant-ligatures:contextual;font-variant-ligatures:contextual}.CodeMirror-wrap pre{word-wrap:break-word;white-space:pre-wrap;word-break:normal}.CodeMirror-linebackground{position:absolute;left:0;right:0;top:0;bottom:0;z-index:0}.CodeMirror-linewidget{position:relative;z-index:2;overflow:auto}.CodeMirror-rtl pre{direction:rtl}.CodeMirror-code{outline:0}.CodeMirror-gutter,.CodeMirror-gutters,.CodeMirror-linenumber,.CodeMirror-scroll,.CodeMirror-sizer{-moz-box-sizing:content-box;box-sizing:content-box}.CodeMirror-measure{position:absolute;width:100%;height:0;overflow:hidden;visibility:hidden}.CodeMirror-cursor{position:absolute;pointer-events:none}.CodeMirror-measure pre{position:static}div.CodeMirror-cursors{visibility:hidden;position:relative;z-index:3}div.CodeMirror-dragcursors{visibility:visible}.CodeMirror-focused div.CodeMirror-cursors{visibility:visible}.CodeMirror-selected{background:#d9d9d9}.CodeMirror-focused .CodeMirror-selected{background:#d7d4f0}.CodeMirror-crosshair{cursor:crosshair}.CodeMirror-line::selection,.CodeMirror-line>span::selection,.CodeMirror-line>span>span::selection{background:#d7d4f0}.CodeMirror-line::-moz-selection,.CodeMirror-line>span::-moz-selection,.CodeMirror-line>span>span::-moz-selection{background:#d7d4f0}.cm-searching{background-color:#ffa;background-color:rgba(255,255,0,.4)}.cm-force-border{padding-right:.1px}@media print{.CodeMirror div.CodeMirror-cursors{visibility:hidden}}.cm-tab-wrap-hack:after{content:''}span.CodeMirror-selectedtext{background:0 0}
/*# sourceMappingURL=codemirror.min.css.map */

      .severity-low {
  background-color: #669603;
}

.severity-low:after {
  content : 'L';
}

.severity-unspecified {
  background-color: #666666;
}

.severity-unspecified:after {
  content : 'U';
}

.severity-style {
  background-color: #9932cc;
}

.severity-style:after {
  content : 'S';
}

.severity-medium {
  background-color: #a9d323;
  color: black;
}

.severity-medium:after {
  content : 'M';
}

.severity-high {
  background-color: #ffa800;
}

.severity-high:after {
  content : 'H';
}

.severity-critical {
  background-color: #e92625;
}

.severity-critical:after {
  content : 'C';
}

i[class*="severity-"] {
  line-height: normal;
  text-transform: capitalize;
  font-size: 0.8em;
  font-weight: bold;
  color: white;
  display: inline-block;
  width: 16px;
  height: 16px;
  text-align: center;
  font-family: sans-serif;
}

      html, body {
  width: 100%;
  height: 100%;
  padding: 0px;
  margin: 0px;
}

div.container {
  padding: 10px;
}

#content {
  height: 100%;
  display: block;
  overflow: hidden;
}

#content > div {
  margin: 10px;
  overflow: hidden;
  border: 1px solid #ddd;
  border-radius: 3px;
  overflow: hidden;
  height: 97%;
}

.button {
  background-color: #f1f1f1;
  text-decoration: none;
  display: inline-block;
  padding: 8px 16px;
  color: black;
  cursor: pointer;
}

.button:hover {
  background-color: #ddd;
  color: black;
}

.review-status {
  color: white;
  text-align: center;
}

.review-status-confirmed {
  background-color: #e92625;
}

.review-status-false-positive {
  background-color: grey;
}

.review-status-intentional {
  background-color: #669603;
}

      div.container {
  width: 100%;
  height: 100%;
  padding: 0px;
}

#editor-wrapper {
  margin: 10px;
}

#side-bar {
  float: left;
  width: 260px;
  margin: 0px;
}

#report-nav ul {
  list-style-type: none;
  padding: 0;
  margin: 0;
  overflow-y: auto;
  height: 100%;
}

#report-nav ul > li {
  padding: .4em;
  background-color: #fff;
  border-bottom: 1px solid rgba(0,0,0,.125);
  text-align: left;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

#report-nav ul > li.active {
  background-color: #427ea9;
  color: white;
}

#report-nav ul > li:hover {
  background-color: #427ea9;
  color: white;
  cursor: pointer;
}

#report-nav ul a {
  text-decoration: none;
}

#report-nav i[class*="severity-"] {
  margin-right: 5px;
}

.header {
  border-bottom: 1px solid lightgrey;
  font-family: monospace;
  padding: 10px;
  background-color: #fafbfc;
  border-bottom: 1px solid #e1e4e8;
  border-top-left-radius: 2px;
  border-top-right-radius: 2px;
}

#report-nav .header {
  font-weight: bold;
}

#editor-wrapper .header > div {
  padding-top: 2px;
}

#file-path,
#checker-name {
  color: #195ea2;
}

#review-status {
  padding: 0px 5px;
}

#file-path {
  font-family: monospace;
}

.check-msg {
  display: inline-block;
  padding: 3px 6px;
  margin: 1px;
  -webkit-border-radius: 5px;
  -moz-border-radius: 5px;
  border-radius: 5px;
}

.check-msg.info {
  color: #00546f;
  background-color: #bfdfe9;
  border: 1px solid #87a8b3;
}

.check-msg.error {
  background-color: #f2dede;
  color: #a94442;
  border: 1px solid #ebcccc;
}

.check-msg.macro {
  background-color: #d7dac2;
  color: #4f5c6d;
  border: 1px solid #d7dac2;
}

.check-msg.note {
  background-color: #d7d7d7;
  color: #4f5c6d;
  border: 1px solid #bfbfbf;
}

.check-msg.current {
  border: 2px dashed #3692ff;
}

.check-msg .tag {
  padding: 1px 5px;
  text-align: center;
  border-radius: 2px;
  margin-right: 5px;
  text-decoration: inherit;
}

.check-msg .tag.macro {
  background-color: #83876a;
  color: white;
  text-transform: capitalize;
}

.check-msg .tag.note {
  background-color: #9299a1;
  color: white;
  text-transform: capitalize;
}

.checker-enum {
  color: white;
  padding: 1px 5px;
  text-align: center;
  border-radius: 25px;
  margin-right: 5px;
  text-decoration: inherit;
}

.checker-enum.info {
  background-color: #427ea9;
}

.checker-enum.error {
  background-color: #a94442;
}

.arrow {
  border: solid black;
  border-width: 0 3px 3px 0;
  display: inline-block;
  padding: 3px;
  cursor: pointer;
  margin: 0px 5px;
}

.arrow:hover {
  border: solid #437ea8;
  border-width: 0 3px 3px 0;
}

.left-arrow {
  transform: rotate(135deg);
  -webkit-transform: rotate(135deg);
}

.right-arrow {
  transform: rotate(-45deg);
  -webkit-transform: rotate(-45deg);
}

    </style>

    <script type="text/javascript">
      function setNonCompatibleBrowserMessage() {
  document.body.innerHTML =
    '<h2 style="margin-left: 20px;">Your browser is not compatible with CodeChecker Viewer!</h2> \
     <p style="margin-left: 20px;">The version required for the following browsers are:</p> \
     <ul style="margin-left: 20px;"> \
     <li>Internet Explorer: version 9 or newer</li> \
     <li>Firefox: version 22.0 or newer</li> \
     </ul>';
}

// http://stackoverflow.com/questions/5916900/how-can-you-detect-the-version-of-a-browser
var browserVersion = (function(){
  var ua = navigator.userAgent, tem,
    M = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];

  if (/trident/i.test(M[1])) {
    tem = /\brv[ :]+(\d+)/g.exec(ua) || [];
    return 'IE ' + (tem[1] || '');
  }

  if (M[1] === 'Chrome') {
    tem = ua.match(/\b(OPR|Edge)\/(\d+)/);
    if (tem != null) return tem.slice(1).join(' ').replace('OPR', 'Opera');
  }

  M = M[2] ? [M[1], M[2]] : [navigator.appName, navigator.appVersion, '-?'];
  if ((tem = ua.match(/version\/(\d+)/i)) != null) M.splice(1, 1, tem[1]);
    return M.join(' ');
})();

var pos = browserVersion.indexOf(' ');
var browser = browserVersion.substr(0, pos);
var version = parseInt(browserVersion.substr(pos + 1));

var browserCompatible
  = browser === 'Firefox'
  ? version >= 22
  : browser === 'IE'
  ? version >= 9
  : true;


      /* MIT License

Copyright (C) 2017 by Marijn Haverbeke <marijnh@gmail.com> and others

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
 */
      !function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):e.CodeMirror=t()}(this,function(){"use strict";function e(e){return new RegExp("(^|\\s)"+e+"(?:$|\\s)\\s*")}function t(e){for(var t=e.childNodes.length;t>0;--t)e.removeChild(e.firstChild);return e}function r(e,r){return t(e).appendChild(r)}function n(e,t,r,n){var i=document.createElement(e);if(r&&(i.className=r),n&&(i.style.cssText=n),"string"==typeof t)i.appendChild(document.createTextNode(t));else if(t)for(var o=0;o<t.length;++o)i.appendChild(t[o]);return i}function i(e,t,r,i){var o=n(e,t,r,i);return o.setAttribute("role","presentation"),o}function o(e,t){if(3==t.nodeType&&(t=t.parentNode),e.contains)return e.contains(t);do{if(11==t.nodeType&&(t=t.host),t==e)return!0}while(t=t.parentNode)}function l(){var e;try{e=document.activeElement}catch(t){e=document.body||null}for(;e&&e.shadowRoot&&e.shadowRoot.activeElement;)e=e.shadowRoot.activeElement;return e}function s(t,r){var n=t.className;e(r).test(n)||(t.className+=(n?" ":"")+r)}function a(t,r){for(var n=t.split(" "),i=0;i<n.length;i++)n[i]&&!e(n[i]).test(r)&&(r+=" "+n[i]);return r}function u(e){var t=Array.prototype.slice.call(arguments,1);return function(){return e.apply(null,t)}}function c(e,t,r){t||(t={});for(var n in e)!e.hasOwnProperty(n)||!1===r&&t.hasOwnProperty(n)||(t[n]=e[n]);return t}function f(e,t,r,n,i){null==t&&-1==(t=e.search(/[^\s\u00a0]/))&&(t=e.length);for(var o=n||0,l=i||0;;){var s=e.indexOf("\t",o);if(s<0||s>=t)return l+(t-o);l+=s-o,l+=r-l%r,o=s+1}}function h(e,t){for(var r=0;r<e.length;++r)if(e[r]==t)return r;return-1}function d(e,t,r){for(var n=0,i=0;;){var o=e.indexOf("\t",n);-1==o&&(o=e.length);var l=o-n;if(o==e.length||i+l>=t)return n+Math.min(l,t-i);if(i+=o-n,i+=r-i%r,n=o+1,i>=t)return n}}function p(e){for(;Kl.length<=e;)Kl.push(g(Kl)+" ");return Kl[e]}function g(e){return e[e.length-1]}function v(e,t){for(var r=[],n=0;n<e.length;n++)r[n]=t(e[n],n);return r}function m(e,t,r){for(var n=0,i=r(t);n<e.length&&r(e[n])<=i;)n++;e.splice(n,0,t)}function y(){}function b(e,t){var r;return Object.create?r=Object.create(e):(y.prototype=e,r=new y),t&&c(t,r),r}function w(e){return/\w/.test(e)||e>""&&(e.toUpperCase()!=e.toLowerCase()||jl.test(e))}function x(e,t){return t?!!(t.source.indexOf("\\w")>-1&&w(e))||t.test(e):w(e)}function C(e){for(var t in e)if(e.hasOwnProperty(t)&&e[t])return!1;return!0}function S(e){return e.charCodeAt(0)>=768&&Xl.test(e)}function L(e,t,r){for(;(r<0?t>0:t<e.length)&&S(e.charAt(t));)t+=r;return t}function k(e,t,r){for(var n=t>r?-1:1;;){if(t==r)return t;var i=(t+r)/2,o=n<0?Math.ceil(i):Math.floor(i);if(o==t)return e(o)?t:r;e(o)?r=o:t=o+n}}function T(e,t,r){var o=this;this.input=r,o.scrollbarFiller=n("div",null,"CodeMirror-scrollbar-filler"),o.scrollbarFiller.setAttribute("cm-not-content","true"),o.gutterFiller=n("div",null,"CodeMirror-gutter-filler"),o.gutterFiller.setAttribute("cm-not-content","true"),o.lineDiv=i("div",null,"CodeMirror-code"),o.selectionDiv=n("div",null,null,"position: relative; z-index: 1"),o.cursorDiv=n("div",null,"CodeMirror-cursors"),o.measure=n("div",null,"CodeMirror-measure"),o.lineMeasure=n("div",null,"CodeMirror-measure"),o.lineSpace=i("div",[o.measure,o.lineMeasure,o.selectionDiv,o.cursorDiv,o.lineDiv],null,"position: relative; outline: none");var l=i("div",[o.lineSpace],"CodeMirror-lines");o.mover=n("div",[l],null,"position: relative"),o.sizer=n("div",[o.mover],"CodeMirror-sizer"),o.sizerWidth=null,o.heightForcer=n("div",null,null,"position: absolute; height: "+Rl+"px; width: 1px;"),o.gutters=n("div",null,"CodeMirror-gutters"),o.lineGutter=null,o.scroller=n("div",[o.sizer,o.heightForcer,o.gutters],"CodeMirror-scroll"),o.scroller.setAttribute("tabIndex","-1"),o.wrapper=n("div",[o.scrollbarFiller,o.gutterFiller,o.scroller],"CodeMirror"),gl&&vl<8&&(o.gutters.style.zIndex=-1,o.scroller.style.paddingRight=0),ml||fl&&Tl||(o.scroller.draggable=!0),e&&(e.appendChild?e.appendChild(o.wrapper):e(o.wrapper)),o.viewFrom=o.viewTo=t.first,o.reportedViewFrom=o.reportedViewTo=t.first,o.view=[],o.renderedView=null,o.externalMeasured=null,o.viewOffset=0,o.lastWrapHeight=o.lastWrapWidth=0,o.updateLineNumbers=null,o.nativeBarWidth=o.barHeight=o.barWidth=0,o.scrollbarsClipped=!1,o.lineNumWidth=o.lineNumInnerWidth=o.lineNumChars=null,o.alignWidgets=!1,o.cachedCharWidth=o.cachedTextHeight=o.cachedPaddingH=null,o.maxLine=null,o.maxLineLength=0,o.maxLineChanged=!1,o.wheelDX=o.wheelDY=o.wheelStartX=o.wheelStartY=null,o.shift=!1,o.selForContextMenu=null,o.activeTouch=null,r.init(o)}function M(e,t){if((t-=e.first)<0||t>=e.size)throw new Error("There is no line "+(t+e.first)+" in the document.");for(var r=e;!r.lines;)for(var n=0;;++n){var i=r.children[n],o=i.chunkSize();if(t<o){r=i;break}t-=o}return r.lines[t]}function N(e,t,r){var n=[],i=t.line;return e.iter(t.line,r.line+1,function(e){var o=e.text;i==r.line&&(o=o.slice(0,r.ch)),i==t.line&&(o=o.slice(t.ch)),n.push(o),++i}),n}function O(e,t,r){var n=[];return e.iter(t,r,function(e){n.push(e.text)}),n}function A(e,t){var r=t-e.height;if(r)for(var n=e;n;n=n.parent)n.height+=r}function W(e){if(null==e.parent)return null;for(var t=e.parent,r=h(t.lines,e),n=t.parent;n;t=n,n=n.parent)for(var i=0;n.children[i]!=t;++i)r+=n.children[i].chunkSize();return r+t.first}function D(e,t){var r=e.first;e:do{for(var n=0;n<e.children.length;++n){var i=e.children[n],o=i.height;if(t<o){e=i;continue e}t-=o,r+=i.chunkSize()}return r}while(!e.lines);for(var l=0;l<e.lines.length;++l){var s=e.lines[l].height;if(t<s)break;t-=s}return r+l}function H(e,t){return t>=e.first&&t<e.first+e.size}function F(e,t){return String(e.lineNumberFormatter(t+e.firstLineNumber))}function E(e,t,r){if(void 0===r&&(r=null),!(this instanceof E))return new E(e,t,r);this.line=e,this.ch=t,this.sticky=r}function P(e,t){return e.line-t.line||e.ch-t.ch}function I(e,t){return e.sticky==t.sticky&&0==P(e,t)}function z(e){return E(e.line,e.ch)}function R(e,t){return P(e,t)<0?t:e}function B(e,t){return P(e,t)<0?e:t}function G(e,t){return Math.max(e.first,Math.min(t,e.first+e.size-1))}function U(e,t){if(t.line<e.first)return E(e.first,0);var r=e.first+e.size-1;return t.line>r?E(r,M(e,r).text.length):V(t,M(e,t.line).text.length)}function V(e,t){var r=e.ch;return null==r||r>t?E(e.line,t):r<0?E(e.line,0):e}function K(e,t){for(var r=[],n=0;n<t.length;n++)r[n]=U(e,t[n]);return r}function j(){Yl=!0}function X(){_l=!0}function Y(e,t,r){this.marker=e,this.from=t,this.to=r}function _(e,t){if(e)for(var r=0;r<e.length;++r){var n=e[r];if(n.marker==t)return n}}function $(e,t){for(var r,n=0;n<e.length;++n)e[n]!=t&&(r||(r=[])).push(e[n]);return r}function q(e,t){e.markedSpans=e.markedSpans?e.markedSpans.concat([t]):[t],t.marker.attachLine(e)}function Z(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t)||o.from==t&&"bookmark"==l.type&&(!r||!o.marker.insertLeft)){var s=null==o.to||(l.inclusiveRight?o.to>=t:o.to>t);(n||(n=[])).push(new Y(l,o.from,s?null:o.to))}}return n}function Q(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.to||(l.inclusiveRight?o.to>=t:o.to>t)||o.from==t&&"bookmark"==l.type&&(!r||o.marker.insertLeft)){var s=null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t);(n||(n=[])).push(new Y(l,s?null:o.from-t,null==o.to?null:o.to-t))}}return n}function J(e,t){if(t.full)return null;var r=H(e,t.from.line)&&M(e,t.from.line).markedSpans,n=H(e,t.to.line)&&M(e,t.to.line).markedSpans;if(!r&&!n)return null;var i=t.from.ch,o=t.to.ch,l=0==P(t.from,t.to),s=Z(r,i,l),a=Q(n,o,l),u=1==t.text.length,c=g(t.text).length+(u?i:0);if(s)for(var f=0;f<s.length;++f){var h=s[f];if(null==h.to){var d=_(a,h.marker);d?u&&(h.to=null==d.to?null:d.to+c):h.to=i}}if(a)for(var p=0;p<a.length;++p){var v=a[p];null!=v.to&&(v.to+=c),null==v.from?_(s,v.marker)||(v.from=c,u&&(s||(s=[])).push(v)):(v.from+=c,u&&(s||(s=[])).push(v))}s&&(s=ee(s)),a&&a!=s&&(a=ee(a));var m=[s];if(!u){var y,b=t.text.length-2;if(b>0&&s)for(var w=0;w<s.length;++w)null==s[w].to&&(y||(y=[])).push(new Y(s[w].marker,null,null));for(var x=0;x<b;++x)m.push(y);m.push(a)}return m}function ee(e){for(var t=0;t<e.length;++t){var r=e[t];null!=r.from&&r.from==r.to&&!1!==r.marker.clearWhenEmpty&&e.splice(t--,1)}return e.length?e:null}function te(e,t,r){var n=null;if(e.iter(t.line,r.line+1,function(e){if(e.markedSpans)for(var t=0;t<e.markedSpans.length;++t){var r=e.markedSpans[t].marker;!r.readOnly||n&&-1!=h(n,r)||(n||(n=[])).push(r)}}),!n)return null;for(var i=[{from:t,to:r}],o=0;o<n.length;++o)for(var l=n[o],s=l.find(0),a=0;a<i.length;++a){var u=i[a];if(!(P(u.to,s.from)<0||P(u.from,s.to)>0)){var c=[a,1],f=P(u.from,s.from),d=P(u.to,s.to);(f<0||!l.inclusiveLeft&&!f)&&c.push({from:u.from,to:s.from}),(d>0||!l.inclusiveRight&&!d)&&c.push({from:s.to,to:u.to}),i.splice.apply(i,c),a+=c.length-3}}return i}function re(e){var t=e.markedSpans;if(t){for(var r=0;r<t.length;++r)t[r].marker.detachLine(e);e.markedSpans=null}}function ne(e,t){if(t){for(var r=0;r<t.length;++r)t[r].marker.attachLine(e);e.markedSpans=t}}function ie(e){return e.inclusiveLeft?-1:0}function oe(e){return e.inclusiveRight?1:0}function le(e,t){var r=e.lines.length-t.lines.length;if(0!=r)return r;var n=e.find(),i=t.find(),o=P(n.from,i.from)||ie(e)-ie(t);if(o)return-o;var l=P(n.to,i.to)||oe(e)-oe(t);return l||t.id-e.id}function se(e,t){var r,n=_l&&e.markedSpans;if(n)for(var i=void 0,o=0;o<n.length;++o)(i=n[o]).marker.collapsed&&null==(t?i.from:i.to)&&(!r||le(r,i.marker)<0)&&(r=i.marker);return r}function ae(e){return se(e,!0)}function ue(e){return se(e,!1)}function ce(e,t,r,n,i){var o=M(e,t),l=_l&&o.markedSpans;if(l)for(var s=0;s<l.length;++s){var a=l[s];if(a.marker.collapsed){var u=a.marker.find(0),c=P(u.from,r)||ie(a.marker)-ie(i),f=P(u.to,n)||oe(a.marker)-oe(i);if(!(c>=0&&f<=0||c<=0&&f>=0)&&(c<=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.to,r)>=0:P(u.to,r)>0)||c>=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.from,n)<=0:P(u.from,n)<0)))return!0}}}function fe(e){for(var t;t=ae(e);)e=t.find(-1,!0).line;return e}function he(e){for(var t;t=ue(e);)e=t.find(1,!0).line;return e}function de(e){for(var t,r;t=ue(e);)e=t.find(1,!0).line,(r||(r=[])).push(e);return r}function pe(e,t){var r=M(e,t),n=fe(r);return r==n?t:W(n)}function ge(e,t){if(t>e.lastLine())return t;var r,n=M(e,t);if(!ve(e,n))return t;for(;r=ue(n);)n=r.find(1,!0).line;return W(n)+1}function ve(e,t){var r=_l&&t.markedSpans;if(r)for(var n=void 0,i=0;i<r.length;++i)if((n=r[i]).marker.collapsed){if(null==n.from)return!0;if(!n.marker.widgetNode&&0==n.from&&n.marker.inclusiveLeft&&me(e,t,n))return!0}}function me(e,t,r){if(null==r.to){var n=r.marker.find(1,!0);return me(e,n.line,_(n.line.markedSpans,r.marker))}if(r.marker.inclusiveRight&&r.to==t.text.length)return!0;for(var i=void 0,o=0;o<t.markedSpans.length;++o)if((i=t.markedSpans[o]).marker.collapsed&&!i.marker.widgetNode&&i.from==r.to&&(null==i.to||i.to!=r.from)&&(i.marker.inclusiveLeft||r.marker.inclusiveRight)&&me(e,t,i))return!0}function ye(e){for(var t=0,r=(e=fe(e)).parent,n=0;n<r.lines.length;++n){var i=r.lines[n];if(i==e)break;t+=i.height}for(var o=r.parent;o;r=o,o=r.parent)for(var l=0;l<o.children.length;++l){var s=o.children[l];if(s==r)break;t+=s.height}return t}function be(e){if(0==e.height)return 0;for(var t,r=e.text.length,n=e;t=ae(n);){var i=t.find(0,!0);n=i.from.line,r+=i.from.ch-i.to.ch}for(n=e;t=ue(n);){var o=t.find(0,!0);r-=n.text.length-o.from.ch,r+=(n=o.to.line).text.length-o.to.ch}return r}function we(e){var t=e.display,r=e.doc;t.maxLine=M(r,r.first),t.maxLineLength=be(t.maxLine),t.maxLineChanged=!0,r.iter(function(e){var r=be(e);r>t.maxLineLength&&(t.maxLineLength=r,t.maxLine=e)})}function xe(e,t,r,n){if(!e)return n(t,r,"ltr",0);for(var i=!1,o=0;o<e.length;++o){var l=e[o];(l.from<r&&l.to>t||t==r&&l.to==t)&&(n(Math.max(l.from,t),Math.min(l.to,r),1==l.level?"rtl":"ltr",o),i=!0)}i||n(t,r,"ltr")}function Ce(e,t,r){var n;$l=null;for(var i=0;i<e.length;++i){var o=e[i];if(o.from<t&&o.to>t)return i;o.to==t&&(o.from!=o.to&&"before"==r?n=i:$l=i),o.from==t&&(o.from!=o.to&&"before"!=r?n=i:$l=i)}return null!=n?n:$l}function Se(e,t){var r=e.order;return null==r&&(r=e.order=ql(e.text,t)),r}function Le(e,t){return e._handlers&&e._handlers[t]||Zl}function ke(e,t,r){if(e.removeEventListener)e.removeEventListener(t,r,!1);else if(e.detachEvent)e.detachEvent("on"+t,r);else{var n=e._handlers,i=n&&n[t];if(i){var o=h(i,r);o>-1&&(n[t]=i.slice(0,o).concat(i.slice(o+1)))}}}function Te(e,t){var r=Le(e,t);if(r.length)for(var n=Array.prototype.slice.call(arguments,2),i=0;i<r.length;++i)r[i].apply(null,n)}function Me(e,t,r){return"string"==typeof t&&(t={type:t,preventDefault:function(){this.defaultPrevented=!0}}),Te(e,r||t.type,e,t),He(t)||t.codemirrorIgnore}function Ne(e){var t=e._handlers&&e._handlers.cursorActivity;if(t)for(var r=e.curOp.cursorActivityHandlers||(e.curOp.cursorActivityHandlers=[]),n=0;n<t.length;++n)-1==h(r,t[n])&&r.push(t[n])}function Oe(e,t){return Le(e,t).length>0}function Ae(e){e.prototype.on=function(e,t){Ql(this,e,t)},e.prototype.off=function(e,t){ke(this,e,t)}}function We(e){e.preventDefault?e.preventDefault():e.returnValue=!1}function De(e){e.stopPropagation?e.stopPropagation():e.cancelBubble=!0}function He(e){return null!=e.defaultPrevented?e.defaultPrevented:0==e.returnValue}function Fe(e){We(e),De(e)}function Ee(e){return e.target||e.srcElement}function Pe(e){var t=e.which;return null==t&&(1&e.button?t=1:2&e.button?t=3:4&e.button&&(t=2)),Ml&&e.ctrlKey&&1==t&&(t=3),t}function Ie(e){if(null==Il){var t=n("span","​");r(e,n("span",[t,document.createTextNode("x")])),0!=e.firstChild.offsetHeight&&(Il=t.offsetWidth<=1&&t.offsetHeight>2&&!(gl&&vl<8))}var i=Il?n("span","​"):n("span"," ",null,"display: inline-block; width: 1px; margin-right: -1px");return i.setAttribute("cm-text",""),i}function ze(e){if(null!=zl)return zl;var n=r(e,document.createTextNode("AخA")),i=Wl(n,0,1).getBoundingClientRect(),o=Wl(n,1,2).getBoundingClientRect();return t(e),!(!i||i.left==i.right)&&(zl=o.right-i.right<3)}function Re(e){if(null!=ns)return ns;var t=r(e,n("span","x")),i=t.getBoundingClientRect(),o=Wl(t,0,1).getBoundingClientRect();return ns=Math.abs(i.left-o.left)>1}function Be(e,t){arguments.length>2&&(t.dependencies=Array.prototype.slice.call(arguments,2)),is[e]=t}function Ge(e){if("string"==typeof e&&os.hasOwnProperty(e))e=os[e];else if(e&&"string"==typeof e.name&&os.hasOwnProperty(e.name)){var t=os[e.name];"string"==typeof t&&(t={name:t}),(e=b(t,e)).name=t.name}else{if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+xml$/.test(e))return Ge("application/xml");if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+json$/.test(e))return Ge("application/json")}return"string"==typeof e?{name:e}:e||{name:"null"}}function Ue(e,t){t=Ge(t);var r=is[t.name];if(!r)return Ue(e,"text/plain");var n=r(e,t);if(ls.hasOwnProperty(t.name)){var i=ls[t.name];for(var o in i)i.hasOwnProperty(o)&&(n.hasOwnProperty(o)&&(n["_"+o]=n[o]),n[o]=i[o])}if(n.name=t.name,t.helperType&&(n.helperType=t.helperType),t.modeProps)for(var l in t.modeProps)n[l]=t.modeProps[l];return n}function Ve(e,t){c(t,ls.hasOwnProperty(e)?ls[e]:ls[e]={})}function Ke(e,t){if(!0===t)return t;if(e.copyState)return e.copyState(t);var r={};for(var n in t){var i=t[n];i instanceof Array&&(i=i.concat([])),r[n]=i}return r}function je(e,t){for(var r;e.innerMode&&(r=e.innerMode(t))&&r.mode!=e;)t=r.state,e=r.mode;return r||{mode:e,state:t}}function Xe(e,t,r){return!e.startState||e.startState(t,r)}function Ye(e,t,r,n){var i=[e.state.modeGen],o={};tt(e,t.text,e.doc.mode,r,function(e,t){return i.push(e,t)},o,n);for(var l=r.state,s=0;s<e.state.overlays.length;++s)!function(n){var l=e.state.overlays[n],s=1,a=0;r.state=!0,tt(e,t.text,l.mode,r,function(e,t){for(var r=s;a<e;){var n=i[s];n>e&&i.splice(s,1,e,i[s+1],n),s+=2,a=Math.min(e,n)}if(t)if(l.opaque)i.splice(r,s-r,e,"overlay "+t),s=r+2;else for(;r<s;r+=2){var o=i[r+1];i[r+1]=(o?o+" ":"")+"overlay "+t}},o)}(s);return r.state=l,{styles:i,classes:o.bgClass||o.textClass?o:null}}function _e(e,t,r){if(!t.styles||t.styles[0]!=e.state.modeGen){var n=$e(e,W(t)),i=t.text.length>e.options.maxHighlightLength&&Ke(e.doc.mode,n.state),o=Ye(e,t,n);i&&(n.state=i),t.stateAfter=n.save(!i),t.styles=o.styles,o.classes?t.styleClasses=o.classes:t.styleClasses&&(t.styleClasses=null),r===e.doc.highlightFrontier&&(e.doc.modeFrontier=Math.max(e.doc.modeFrontier,++e.doc.highlightFrontier))}return t.styles}function $e(e,t,r){var n=e.doc,i=e.display;if(!n.mode.startState)return new us(n,!0,t);var o=rt(e,t,r),l=o>n.first&&M(n,o-1).stateAfter,s=l?us.fromSaved(n,l,o):new us(n,Xe(n.mode),o);return n.iter(o,t,function(r){qe(e,r.text,s);var n=s.line;r.stateAfter=n==t-1||n%5==0||n>=i.viewFrom&&n<i.viewTo?s.save():null,s.nextLine()}),r&&(n.modeFrontier=s.line),s}function qe(e,t,r,n){var i=e.doc.mode,o=new ss(t,e.options.tabSize,r);for(o.start=o.pos=n||0,""==t&&Ze(i,r.state);!o.eol();)Qe(i,o,r.state),o.start=o.pos}function Ze(e,t){if(e.blankLine)return e.blankLine(t);if(e.innerMode){var r=je(e,t);return r.mode.blankLine?r.mode.blankLine(r.state):void 0}}function Qe(e,t,r,n){for(var i=0;i<10;i++){n&&(n[0]=je(e,r).mode);var o=e.token(t,r);if(t.pos>t.start)return o}throw new Error("Mode "+e.name+" failed to advance stream.")}function Je(e,t,r,n){var i,o,l=e.doc,s=l.mode,a=M(l,(t=U(l,t)).line),u=$e(e,t.line,r),c=new ss(a.text,e.options.tabSize,u);for(n&&(o=[]);(n||c.pos<t.ch)&&!c.eol();)c.start=c.pos,i=Qe(s,c,u.state),n&&o.push(new cs(c,i,Ke(l.mode,u.state)));return n?o:new cs(c,i,u.state)}function et(e,t){if(e)for(;;){var r=e.match(/(?:^|\s+)line-(background-)?(\S+)/);if(!r)break;e=e.slice(0,r.index)+e.slice(r.index+r[0].length);var n=r[1]?"bgClass":"textClass";null==t[n]?t[n]=r[2]:new RegExp("(?:^|s)"+r[2]+"(?:$|s)").test(t[n])||(t[n]+=" "+r[2])}return e}function tt(e,t,r,n,i,o,l){var s=r.flattenSpans;null==s&&(s=e.options.flattenSpans);var a,u=0,c=null,f=new ss(t,e.options.tabSize,n),h=e.options.addModeClass&&[null];for(""==t&&et(Ze(r,n.state),o);!f.eol();){if(f.pos>e.options.maxHighlightLength?(s=!1,l&&qe(e,t,n,f.pos),f.pos=t.length,a=null):a=et(Qe(r,f,n.state,h),o),h){var d=h[0].name;d&&(a="m-"+(a?d+" "+a:d))}if(!s||c!=a){for(;u<f.start;)i(u=Math.min(f.start,u+5e3),c);c=a}f.start=f.pos}for(;u<f.pos;){var p=Math.min(f.pos,u+5e3);i(p,c),u=p}}function rt(e,t,r){for(var n,i,o=e.doc,l=r?-1:t-(e.doc.mode.innerMode?1e3:100),s=t;s>l;--s){if(s<=o.first)return o.first;var a=M(o,s-1),u=a.stateAfter;if(u&&(!r||s+(u instanceof as?u.lookAhead:0)<=o.modeFrontier))return s;var c=f(a.text,null,e.options.tabSize);(null==i||n>c)&&(i=s-1,n=c)}return i}function nt(e,t){if(e.modeFrontier=Math.min(e.modeFrontier,t),!(e.highlightFrontier<t-10)){for(var r=e.first,n=t-1;n>r;n--){var i=M(e,n).stateAfter;if(i&&(!(i instanceof as)||n+i.lookAhead<t)){r=n+1;break}}e.highlightFrontier=Math.min(e.highlightFrontier,r)}}function it(e,t,r,n){e.text=t,e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null),null!=e.order&&(e.order=null),re(e),ne(e,r);var i=n?n(e):1;i!=e.height&&A(e,i)}function ot(e){e.parent=null,re(e)}function lt(e,t){if(!e||/^\s*$/.test(e))return null;var r=t.addModeClass?ps:ds;return r[e]||(r[e]=e.replace(/\S+/g,"cm-$&"))}function st(e,t){var r=i("span",null,null,ml?"padding-right: .1px":null),n={pre:i("pre",[r],"CodeMirror-line"),content:r,col:0,pos:0,cm:e,trailingSpace:!1,splitSpaces:(gl||ml)&&e.getOption("lineWrapping")};t.measure={};for(var o=0;o<=(t.rest?t.rest.length:0);o++){var l=o?t.rest[o-1]:t.line,s=void 0;n.pos=0,n.addToken=ut,ze(e.display.measure)&&(s=Se(l,e.doc.direction))&&(n.addToken=ft(n.addToken,s)),n.map=[],dt(l,n,_e(e,l,t!=e.display.externalMeasured&&W(l))),l.styleClasses&&(l.styleClasses.bgClass&&(n.bgClass=a(l.styleClasses.bgClass,n.bgClass||"")),l.styleClasses.textClass&&(n.textClass=a(l.styleClasses.textClass,n.textClass||""))),0==n.map.length&&n.map.push(0,0,n.content.appendChild(Ie(e.display.measure))),0==o?(t.measure.map=n.map,t.measure.cache={}):((t.measure.maps||(t.measure.maps=[])).push(n.map),(t.measure.caches||(t.measure.caches=[])).push({}))}if(ml){var u=n.content.lastChild;(/\bcm-tab\b/.test(u.className)||u.querySelector&&u.querySelector(".cm-tab"))&&(n.content.className="cm-tab-wrap-hack")}return Te(e,"renderLine",e,t.line,n.pre),n.pre.className&&(n.textClass=a(n.pre.className,n.textClass||"")),n}function at(e){var t=n("span","•","cm-invalidchar");return t.title="\\u"+e.charCodeAt(0).toString(16),t.setAttribute("aria-label",t.title),t}function ut(e,t,r,i,o,l,s){if(t){var a,u=e.splitSpaces?ct(t,e.trailingSpace):t,c=e.cm.state.specialChars,f=!1;if(c.test(t)){a=document.createDocumentFragment();for(var h=0;;){c.lastIndex=h;var d=c.exec(t),g=d?d.index-h:t.length-h;if(g){var v=document.createTextNode(u.slice(h,h+g));gl&&vl<9?a.appendChild(n("span",[v])):a.appendChild(v),e.map.push(e.pos,e.pos+g,v),e.col+=g,e.pos+=g}if(!d)break;h+=g+1;var m=void 0;if("\t"==d[0]){var y=e.cm.options.tabSize,b=y-e.col%y;(m=a.appendChild(n("span",p(b),"cm-tab"))).setAttribute("role","presentation"),m.setAttribute("cm-text","\t"),e.col+=b}else"\r"==d[0]||"\n"==d[0]?((m=a.appendChild(n("span","\r"==d[0]?"␍":"␤","cm-invalidchar"))).setAttribute("cm-text",d[0]),e.col+=1):((m=e.cm.options.specialCharPlaceholder(d[0])).setAttribute("cm-text",d[0]),gl&&vl<9?a.appendChild(n("span",[m])):a.appendChild(m),e.col+=1);e.map.push(e.pos,e.pos+1,m),e.pos++}}else e.col+=t.length,a=document.createTextNode(u),e.map.push(e.pos,e.pos+t.length,a),gl&&vl<9&&(f=!0),e.pos+=t.length;if(e.trailingSpace=32==u.charCodeAt(t.length-1),r||i||o||f||s){var w=r||"";i&&(w+=i),o&&(w+=o);var x=n("span",[a],w,s);return l&&(x.title=l),e.content.appendChild(x)}e.content.appendChild(a)}}function ct(e,t){if(e.length>1&&!/  /.test(e))return e;for(var r=t,n="",i=0;i<e.length;i++){var o=e.charAt(i);" "!=o||!r||i!=e.length-1&&32!=e.charCodeAt(i+1)||(o=" "),n+=o,r=" "==o}return n}function ft(e,t){return function(r,n,i,o,l,s,a){i=i?i+" cm-force-border":"cm-force-border";for(var u=r.pos,c=u+n.length;;){for(var f=void 0,h=0;h<t.length&&!((f=t[h]).to>u&&f.from<=u);h++);if(f.to>=c)return e(r,n,i,o,l,s,a);e(r,n.slice(0,f.to-u),i,o,null,s,a),o=null,n=n.slice(f.to-u),u=f.to}}}function ht(e,t,r,n){var i=!n&&r.widgetNode;i&&e.map.push(e.pos,e.pos+t,i),!n&&e.cm.display.input.needsContentAttribute&&(i||(i=e.content.appendChild(document.createElement("span"))),i.setAttribute("cm-marker",r.id)),i&&(e.cm.display.input.setUneditable(i),e.content.appendChild(i)),e.pos+=t,e.trailingSpace=!1}function dt(e,t,r){var n=e.markedSpans,i=e.text,o=0;if(n)for(var l,s,a,u,c,f,h,d=i.length,p=0,g=1,v="",m=0;;){if(m==p){a=u=c=f=s="",h=null,m=1/0;for(var y=[],b=void 0,w=0;w<n.length;++w){var x=n[w],C=x.marker;"bookmark"==C.type&&x.from==p&&C.widgetNode?y.push(C):x.from<=p&&(null==x.to||x.to>p||C.collapsed&&x.to==p&&x.from==p)?(null!=x.to&&x.to!=p&&m>x.to&&(m=x.to,u=""),C.className&&(a+=" "+C.className),C.css&&(s=(s?s+";":"")+C.css),C.startStyle&&x.from==p&&(c+=" "+C.startStyle),C.endStyle&&x.to==m&&(b||(b=[])).push(C.endStyle,x.to),C.title&&!f&&(f=C.title),C.collapsed&&(!h||le(h.marker,C)<0)&&(h=x)):x.from>p&&m>x.from&&(m=x.from)}if(b)for(var S=0;S<b.length;S+=2)b[S+1]==m&&(u+=" "+b[S]);if(!h||h.from==p)for(var L=0;L<y.length;++L)ht(t,0,y[L]);if(h&&(h.from||0)==p){if(ht(t,(null==h.to?d+1:h.to)-p,h.marker,null==h.from),null==h.to)return;h.to==p&&(h=!1)}}if(p>=d)break;for(var k=Math.min(d,m);;){if(v){var T=p+v.length;if(!h){var M=T>k?v.slice(0,k-p):v;t.addToken(t,M,l?l+a:a,c,p+M.length==m?u:"",f,s)}if(T>=k){v=v.slice(k-p),p=k;break}p=T,c=""}v=i.slice(o,o=r[g++]),l=lt(r[g++],t.cm.options)}}else for(var N=1;N<r.length;N+=2)t.addToken(t,i.slice(o,o=r[N]),lt(r[N+1],t.cm.options))}function pt(e,t,r){this.line=t,this.rest=de(t),this.size=this.rest?W(g(this.rest))-r+1:1,this.node=this.text=null,this.hidden=ve(e,t)}function gt(e,t,r){for(var n,i=[],o=t;o<r;o=n){var l=new pt(e.doc,M(e.doc,o),o);n=o+l.size,i.push(l)}return i}function vt(e){gs?gs.ops.push(e):e.ownsGroup=gs={ops:[e],delayedCallbacks:[]}}function mt(e){var t=e.delayedCallbacks,r=0;do{for(;r<t.length;r++)t[r].call(null);for(var n=0;n<e.ops.length;n++){var i=e.ops[n];if(i.cursorActivityHandlers)for(;i.cursorActivityCalled<i.cursorActivityHandlers.length;)i.cursorActivityHandlers[i.cursorActivityCalled++].call(null,i.cm)}}while(r<t.length)}function yt(e,t){var r=e.ownsGroup;if(r)try{mt(r)}finally{gs=null,t(r)}}function bt(e,t){var r=Le(e,t);if(r.length){var n,i=Array.prototype.slice.call(arguments,2);gs?n=gs.delayedCallbacks:vs?n=vs:(n=vs=[],setTimeout(wt,0));for(var o=0;o<r.length;++o)!function(e){n.push(function(){return r[e].apply(null,i)})}(o)}}function wt(){var e=vs;vs=null;for(var t=0;t<e.length;++t)e[t]()}function xt(e,t,r,n){for(var i=0;i<t.changes.length;i++){var o=t.changes[i];"text"==o?kt(e,t):"gutter"==o?Mt(e,t,r,n):"class"==o?Tt(e,t):"widget"==o&&Nt(e,t,n)}t.changes=null}function Ct(e){return e.node==e.text&&(e.node=n("div",null,null,"position: relative"),e.text.parentNode&&e.text.parentNode.replaceChild(e.node,e.text),e.node.appendChild(e.text),gl&&vl<8&&(e.node.style.zIndex=2)),e.node}function St(e,t){var r=t.bgClass?t.bgClass+" "+(t.line.bgClass||""):t.line.bgClass;if(r&&(r+=" CodeMirror-linebackground"),t.background)r?t.background.className=r:(t.background.parentNode.removeChild(t.background),t.background=null);else if(r){var i=Ct(t);t.background=i.insertBefore(n("div",null,r),i.firstChild),e.display.input.setUneditable(t.background)}}function Lt(e,t){var r=e.display.externalMeasured;return r&&r.line==t.line?(e.display.externalMeasured=null,t.measure=r.measure,r.built):st(e,t)}function kt(e,t){var r=t.text.className,n=Lt(e,t);t.text==t.node&&(t.node=n.pre),t.text.parentNode.replaceChild(n.pre,t.text),t.text=n.pre,n.bgClass!=t.bgClass||n.textClass!=t.textClass?(t.bgClass=n.bgClass,t.textClass=n.textClass,Tt(e,t)):r&&(t.text.className=r)}function Tt(e,t){St(e,t),t.line.wrapClass?Ct(t).className=t.line.wrapClass:t.node!=t.text&&(t.node.className="");var r=t.textClass?t.textClass+" "+(t.line.textClass||""):t.line.textClass;t.text.className=r||""}function Mt(e,t,r,i){if(t.gutter&&(t.node.removeChild(t.gutter),t.gutter=null),t.gutterBackground&&(t.node.removeChild(t.gutterBackground),t.gutterBackground=null),t.line.gutterClass){var o=Ct(t);t.gutterBackground=n("div",null,"CodeMirror-gutter-background "+t.line.gutterClass,"left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px; width: "+i.gutterTotalWidth+"px"),e.display.input.setUneditable(t.gutterBackground),o.insertBefore(t.gutterBackground,t.text)}var l=t.line.gutterMarkers;if(e.options.lineNumbers||l){var s=Ct(t),a=t.gutter=n("div",null,"CodeMirror-gutter-wrapper","left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px");if(e.display.input.setUneditable(a),s.insertBefore(a,t.text),t.line.gutterClass&&(a.className+=" "+t.line.gutterClass),!e.options.lineNumbers||l&&l["CodeMirror-linenumbers"]||(t.lineNumber=a.appendChild(n("div",F(e.options,r),"CodeMirror-linenumber CodeMirror-gutter-elt","left: "+i.gutterLeft["CodeMirror-linenumbers"]+"px; width: "+e.display.lineNumInnerWidth+"px"))),l)for(var u=0;u<e.options.gutters.length;++u){var c=e.options.gutters[u],f=l.hasOwnProperty(c)&&l[c];f&&a.appendChild(n("div",[f],"CodeMirror-gutter-elt","left: "+i.gutterLeft[c]+"px; width: "+i.gutterWidth[c]+"px"))}}}function Nt(e,t,r){t.alignable&&(t.alignable=null);for(var n=t.node.firstChild,i=void 0;n;n=i)i=n.nextSibling,"CodeMirror-linewidget"==n.className&&t.node.removeChild(n);At(e,t,r)}function Ot(e,t,r,n){var i=Lt(e,t);return t.text=t.node=i.pre,i.bgClass&&(t.bgClass=i.bgClass),i.textClass&&(t.textClass=i.textClass),Tt(e,t),Mt(e,t,r,n),At(e,t,n),t.node}function At(e,t,r){if(Wt(e,t.line,t,r,!0),t.rest)for(var n=0;n<t.rest.length;n++)Wt(e,t.rest[n],t,r,!1)}function Wt(e,t,r,i,o){if(t.widgets)for(var l=Ct(r),s=0,a=t.widgets;s<a.length;++s){var u=a[s],c=n("div",[u.node],"CodeMirror-linewidget");u.handleMouseEvents||c.setAttribute("cm-ignore-events","true"),Dt(u,c,r,i),e.display.input.setUneditable(c),o&&u.above?l.insertBefore(c,r.gutter||r.text):l.appendChild(c),bt(u,"redraw")}}function Dt(e,t,r,n){if(e.noHScroll){(r.alignable||(r.alignable=[])).push(t);var i=n.wrapperWidth;t.style.left=n.fixedPos+"px",e.coverGutter||(i-=n.gutterTotalWidth,t.style.paddingLeft=n.gutterTotalWidth+"px"),t.style.width=i+"px"}e.coverGutter&&(t.style.zIndex=5,t.style.position="relative",e.noHScroll||(t.style.marginLeft=-n.gutterTotalWidth+"px"))}function Ht(e){if(null!=e.height)return e.height;var t=e.doc.cm;if(!t)return 0;if(!o(document.body,e.node)){var i="position: relative;";e.coverGutter&&(i+="margin-left: -"+t.display.gutters.offsetWidth+"px;"),e.noHScroll&&(i+="width: "+t.display.wrapper.clientWidth+"px;"),r(t.display.measure,n("div",[e.node],null,i))}return e.height=e.node.parentNode.offsetHeight}function Ft(e,t){for(var r=Ee(t);r!=e.wrapper;r=r.parentNode)if(!r||1==r.nodeType&&"true"==r.getAttribute("cm-ignore-events")||r.parentNode==e.sizer&&r!=e.mover)return!0}function Et(e){return e.lineSpace.offsetTop}function Pt(e){return e.mover.offsetHeight-e.lineSpace.offsetHeight}function It(e){if(e.cachedPaddingH)return e.cachedPaddingH;var t=r(e.measure,n("pre","x")),i=window.getComputedStyle?window.getComputedStyle(t):t.currentStyle,o={left:parseInt(i.paddingLeft),right:parseInt(i.paddingRight)};return isNaN(o.left)||isNaN(o.right)||(e.cachedPaddingH=o),o}function zt(e){return Rl-e.display.nativeBarWidth}function Rt(e){return e.display.scroller.clientWidth-zt(e)-e.display.barWidth}function Bt(e){return e.display.scroller.clientHeight-zt(e)-e.display.barHeight}function Gt(e,t,r){var n=e.options.lineWrapping,i=n&&Rt(e);if(!t.measure.heights||n&&t.measure.width!=i){var o=t.measure.heights=[];if(n){t.measure.width=i;for(var l=t.text.firstChild.getClientRects(),s=0;s<l.length-1;s++){var a=l[s],u=l[s+1];Math.abs(a.bottom-u.bottom)>2&&o.push((a.bottom+u.top)/2-r.top)}}o.push(r.bottom-r.top)}}function Ut(e,t,r){if(e.line==t)return{map:e.measure.map,cache:e.measure.cache};for(var n=0;n<e.rest.length;n++)if(e.rest[n]==t)return{map:e.measure.maps[n],cache:e.measure.caches[n]};for(var i=0;i<e.rest.length;i++)if(W(e.rest[i])>r)return{map:e.measure.maps[i],cache:e.measure.caches[i],before:!0}}function Vt(e,t){var n=W(t=fe(t)),i=e.display.externalMeasured=new pt(e.doc,t,n);i.lineN=n;var o=i.built=st(e,i);return i.text=o.pre,r(e.display.lineMeasure,o.pre),i}function Kt(e,t,r,n){return Yt(e,Xt(e,t),r,n)}function jt(e,t){if(t>=e.display.viewFrom&&t<e.display.viewTo)return e.display.view[Lr(e,t)];var r=e.display.externalMeasured;return r&&t>=r.lineN&&t<r.lineN+r.size?r:void 0}function Xt(e,t){var r=W(t),n=jt(e,r);n&&!n.text?n=null:n&&n.changes&&(xt(e,n,r,br(e)),e.curOp.forceUpdate=!0),n||(n=Vt(e,t));var i=Ut(n,t,r);return{line:t,view:n,rect:null,map:i.map,cache:i.cache,before:i.before,hasHeights:!1}}function Yt(e,t,r,n,i){t.before&&(r=-1);var o,l=r+(n||"");return t.cache.hasOwnProperty(l)?o=t.cache[l]:(t.rect||(t.rect=t.view.text.getBoundingClientRect()),t.hasHeights||(Gt(e,t.view,t.rect),t.hasHeights=!0),(o=qt(e,t,r,n)).bogus||(t.cache[l]=o)),{left:o.left,right:o.right,top:i?o.rtop:o.top,bottom:i?o.rbottom:o.bottom}}function _t(e,t,r){for(var n,i,o,l,s,a,u=0;u<e.length;u+=3)if(s=e[u],a=e[u+1],t<s?(i=0,o=1,l="left"):t<a?o=(i=t-s)+1:(u==e.length-3||t==a&&e[u+3]>t)&&(i=(o=a-s)-1,t>=a&&(l="right")),null!=i){if(n=e[u+2],s==a&&r==(n.insertLeft?"left":"right")&&(l=r),"left"==r&&0==i)for(;u&&e[u-2]==e[u-3]&&e[u-1].insertLeft;)n=e[2+(u-=3)],l="left";if("right"==r&&i==a-s)for(;u<e.length-3&&e[u+3]==e[u+4]&&!e[u+5].insertLeft;)n=e[(u+=3)+2],l="right";break}return{node:n,start:i,end:o,collapse:l,coverStart:s,coverEnd:a}}function $t(e,t){var r=ms;if("left"==t)for(var n=0;n<e.length&&(r=e[n]).left==r.right;n++);else for(var i=e.length-1;i>=0&&(r=e[i]).left==r.right;i--);return r}function qt(e,t,r,n){var i,o=_t(t.map,r,n),l=o.node,s=o.start,a=o.end,u=o.collapse;if(3==l.nodeType){for(var c=0;c<4;c++){for(;s&&S(t.line.text.charAt(o.coverStart+s));)--s;for(;o.coverStart+a<o.coverEnd&&S(t.line.text.charAt(o.coverStart+a));)++a;if((i=gl&&vl<9&&0==s&&a==o.coverEnd-o.coverStart?l.parentNode.getBoundingClientRect():$t(Wl(l,s,a).getClientRects(),n)).left||i.right||0==s)break;a=s,s-=1,u="right"}gl&&vl<11&&(i=Zt(e.display.measure,i))}else{s>0&&(u=n="right");var f;i=e.options.lineWrapping&&(f=l.getClientRects()).length>1?f["right"==n?f.length-1:0]:l.getBoundingClientRect()}if(gl&&vl<9&&!s&&(!i||!i.left&&!i.right)){var h=l.parentNode.getClientRects()[0];i=h?{left:h.left,right:h.left+yr(e.display),top:h.top,bottom:h.bottom}:ms}for(var d=i.top-t.rect.top,p=i.bottom-t.rect.top,g=(d+p)/2,v=t.view.measure.heights,m=0;m<v.length-1&&!(g<v[m]);m++);var y=m?v[m-1]:0,b=v[m],w={left:("right"==u?i.right:i.left)-t.rect.left,right:("left"==u?i.left:i.right)-t.rect.left,top:y,bottom:b};return i.left||i.right||(w.bogus=!0),e.options.singleCursorHeightPerLine||(w.rtop=d,w.rbottom=p),w}function Zt(e,t){if(!window.screen||null==screen.logicalXDPI||screen.logicalXDPI==screen.deviceXDPI||!Re(e))return t;var r=screen.logicalXDPI/screen.deviceXDPI,n=screen.logicalYDPI/screen.deviceYDPI;return{left:t.left*r,right:t.right*r,top:t.top*n,bottom:t.bottom*n}}function Qt(e){if(e.measure&&(e.measure.cache={},e.measure.heights=null,e.rest))for(var t=0;t<e.rest.length;t++)e.measure.caches[t]={}}function Jt(e){e.display.externalMeasure=null,t(e.display.lineMeasure);for(var r=0;r<e.display.view.length;r++)Qt(e.display.view[r])}function er(e){Jt(e),e.display.cachedCharWidth=e.display.cachedTextHeight=e.display.cachedPaddingH=null,e.options.lineWrapping||(e.display.maxLineChanged=!0),e.display.lineNumChars=null}function tr(){return bl&&kl?-(document.body.getBoundingClientRect().left-parseInt(getComputedStyle(document.body).marginLeft)):window.pageXOffset||(document.documentElement||document.body).scrollLeft}function rr(){return bl&&kl?-(document.body.getBoundingClientRect().top-parseInt(getComputedStyle(document.body).marginTop)):window.pageYOffset||(document.documentElement||document.body).scrollTop}function nr(e){var t=0;if(e.widgets)for(var r=0;r<e.widgets.length;++r)e.widgets[r].above&&(t+=Ht(e.widgets[r]));return t}function ir(e,t,r,n,i){if(!i){var o=nr(t);r.top+=o,r.bottom+=o}if("line"==n)return r;n||(n="local");var l=ye(t);if("local"==n?l+=Et(e.display):l-=e.display.viewOffset,"page"==n||"window"==n){var s=e.display.lineSpace.getBoundingClientRect();l+=s.top+("window"==n?0:rr());var a=s.left+("window"==n?0:tr());r.left+=a,r.right+=a}return r.top+=l,r.bottom+=l,r}function or(e,t,r){if("div"==r)return t;var n=t.left,i=t.top;if("page"==r)n-=tr(),i-=rr();else if("local"==r||!r){var o=e.display.sizer.getBoundingClientRect();n+=o.left,i+=o.top}var l=e.display.lineSpace.getBoundingClientRect();return{left:n-l.left,top:i-l.top}}function lr(e,t,r,n,i){return n||(n=M(e.doc,t.line)),ir(e,n,Kt(e,n,t.ch,i),r)}function sr(e,t,r,n,i,o){function l(t,l){var s=Yt(e,i,t,l?"right":"left",o);return l?s.left=s.right:s.right=s.left,ir(e,n,s,r)}function s(e,t,r){var n=1==a[t].level;return l(r?e-1:e,n!=r)}n=n||M(e.doc,t.line),i||(i=Xt(e,n));var a=Se(n,e.doc.direction),u=t.ch,c=t.sticky;if(u>=n.text.length?(u=n.text.length,c="before"):u<=0&&(u=0,c="after"),!a)return l("before"==c?u-1:u,"before"==c);var f=Ce(a,u,c),h=$l,d=s(u,f,"before"==c);return null!=h&&(d.other=s(u,h,"before"!=c)),d}function ar(e,t){var r=0;t=U(e.doc,t),e.options.lineWrapping||(r=yr(e.display)*t.ch);var n=M(e.doc,t.line),i=ye(n)+Et(e.display);return{left:r,right:r,top:i,bottom:i+n.height}}function ur(e,t,r,n,i){var o=E(e,t,r);return o.xRel=i,n&&(o.outside=!0),o}function cr(e,t,r){var n=e.doc;if((r+=e.display.viewOffset)<0)return ur(n.first,0,null,!0,-1);var i=D(n,r),o=n.first+n.size-1;if(i>o)return ur(n.first+n.size-1,M(n,o).text.length,null,!0,1);t<0&&(t=0);for(var l=M(n,i);;){var s=pr(e,l,i,t,r),a=ue(l),u=a&&a.find(0,!0);if(!a||!(s.ch>u.from.ch||s.ch==u.from.ch&&s.xRel>0))return s;i=W(l=u.to.line)}}function fr(e,t,r,n){n-=nr(t);var i=t.text.length,o=k(function(t){return Yt(e,r,t-1).bottom<=n},i,0);return i=k(function(t){return Yt(e,r,t).top>n},o,i),{begin:o,end:i}}function hr(e,t,r,n){return r||(r=Xt(e,t)),fr(e,t,r,ir(e,t,Yt(e,r,n),"line").top)}function dr(e,t,r,n){return!(e.bottom<=r)&&(e.top>r||(n?e.left:e.right)>t)}function pr(e,t,r,n,i){i-=ye(t);var o=Xt(e,t),l=nr(t),s=0,a=t.text.length,u=!0,c=Se(t,e.doc.direction);if(c){var f=(e.options.lineWrapping?vr:gr)(e,t,r,o,c,n,i);s=(u=1!=f.level)?f.from:f.to-1,a=u?f.to:f.from-1}var h,d,p=null,g=null,v=k(function(t){var r=Yt(e,o,t);return r.top+=l,r.bottom+=l,!!dr(r,n,i,!1)&&(r.top<=i&&r.left<=n&&(p=t,g=r),!0)},s,a),m=!1;if(g){var y=n-g.left<g.right-n,b=y==u;v=p+(b?0:1),d=b?"after":"before",h=y?g.left:g.right}else{u||v!=a&&v!=s||v++,d=0==v?"after":v==t.text.length?"before":Yt(e,o,v-(u?1:0)).bottom+l<=i==u?"after":"before";var w=sr(e,E(r,v,d),"line",t,o);h=w.left,m=i<w.top||i>=w.bottom}return v=L(t.text,v,1),ur(r,v,d,m,n-h)}function gr(e,t,r,n,i,o,l){var s=k(function(s){var a=i[s],u=1!=a.level;return dr(sr(e,E(r,u?a.to:a.from,u?"before":"after"),"line",t,n),o,l,!0)},0,i.length-1),a=i[s];if(s>0){var u=1!=a.level,c=sr(e,E(r,u?a.from:a.to,u?"after":"before"),"line",t,n);dr(c,o,l,!0)&&c.top>l&&(a=i[s-1])}return a}function vr(e,t,r,n,i,o,l){for(var s=fr(e,t,n,l),a=s.begin,u=s.end,c=null,f=null,h=0;h<i.length;h++){var d=i[h];if(!(d.from>=u||d.to<=a)){var p=Yt(e,n,1!=d.level?Math.min(u,d.to)-1:Math.max(a,d.from)).right,g=p<o?o-p+1e9:p-o;(!c||f>g)&&(c=d,f=g)}}return c||(c=i[i.length-1]),c.from<a&&(c={from:a,to:c.to,level:c.level}),c.to>u&&(c={from:c.from,to:u,level:c.level}),c}function mr(e){if(null!=e.cachedTextHeight)return e.cachedTextHeight;if(null==hs){hs=n("pre");for(var i=0;i<49;++i)hs.appendChild(document.createTextNode("x")),hs.appendChild(n("br"));hs.appendChild(document.createTextNode("x"))}r(e.measure,hs);var o=hs.offsetHeight/50;return o>3&&(e.cachedTextHeight=o),t(e.measure),o||1}function yr(e){if(null!=e.cachedCharWidth)return e.cachedCharWidth;var t=n("span","xxxxxxxxxx"),i=n("pre",[t]);r(e.measure,i);var o=t.getBoundingClientRect(),l=(o.right-o.left)/10;return l>2&&(e.cachedCharWidth=l),l||10}function br(e){for(var t=e.display,r={},n={},i=t.gutters.clientLeft,o=t.gutters.firstChild,l=0;o;o=o.nextSibling,++l)r[e.options.gutters[l]]=o.offsetLeft+o.clientLeft+i,n[e.options.gutters[l]]=o.clientWidth;return{fixedPos:wr(t),gutterTotalWidth:t.gutters.offsetWidth,gutterLeft:r,gutterWidth:n,wrapperWidth:t.wrapper.clientWidth}}function wr(e){return e.scroller.getBoundingClientRect().left-e.sizer.getBoundingClientRect().left}function xr(e){var t=mr(e.display),r=e.options.lineWrapping,n=r&&Math.max(5,e.display.scroller.clientWidth/yr(e.display)-3);return function(i){if(ve(e.doc,i))return 0;var o=0;if(i.widgets)for(var l=0;l<i.widgets.length;l++)i.widgets[l].height&&(o+=i.widgets[l].height);return r?o+(Math.ceil(i.text.length/n)||1)*t:o+t}}function Cr(e){var t=e.doc,r=xr(e);t.iter(function(e){var t=r(e);t!=e.height&&A(e,t)})}function Sr(e,t,r,n){var i=e.display;if(!r&&"true"==Ee(t).getAttribute("cm-not-content"))return null;var o,l,s=i.lineSpace.getBoundingClientRect();try{o=t.clientX-s.left,l=t.clientY-s.top}catch(t){return null}var a,u=cr(e,o,l);if(n&&1==u.xRel&&(a=M(e.doc,u.line).text).length==u.ch){var c=f(a,a.length,e.options.tabSize)-a.length;u=E(u.line,Math.max(0,Math.round((o-It(e.display).left)/yr(e.display))-c))}return u}function Lr(e,t){if(t>=e.display.viewTo)return null;if((t-=e.display.viewFrom)<0)return null;for(var r=e.display.view,n=0;n<r.length;n++)if((t-=r[n].size)<0)return n}function kr(e){e.display.input.showSelection(e.display.input.prepareSelection())}function Tr(e,t){void 0===t&&(t=!0);for(var r=e.doc,n={},i=n.cursors=document.createDocumentFragment(),o=n.selection=document.createDocumentFragment(),l=0;l<r.sel.ranges.length;l++)if(t||l!=r.sel.primIndex){var s=r.sel.ranges[l];if(!(s.from().line>=e.display.viewTo||s.to().line<e.display.viewFrom)){var a=s.empty();(a||e.options.showCursorWhenSelecting)&&Mr(e,s.head,i),a||Or(e,s,o)}}return n}function Mr(e,t,r){var i=sr(e,t,"div",null,null,!e.options.singleCursorHeightPerLine),o=r.appendChild(n("div"," ","CodeMirror-cursor"));if(o.style.left=i.left+"px",o.style.top=i.top+"px",o.style.height=Math.max(0,i.bottom-i.top)*e.options.cursorHeight+"px",i.other){var l=r.appendChild(n("div"," ","CodeMirror-cursor CodeMirror-secondarycursor"));l.style.display="",l.style.left=i.other.left+"px",l.style.top=i.other.top+"px",l.style.height=.85*(i.other.bottom-i.other.top)+"px"}}function Nr(e,t){return e.top-t.top||e.left-t.left}function Or(e,t,r){function i(e,t,r,i){t<0&&(t=0),t=Math.round(t),i=Math.round(i),a.appendChild(n("div",null,"CodeMirror-selected","position: absolute; left: "+e+"px;\n                             top: "+t+"px; width: "+(null==r?f-e:r)+"px;\n                             height: "+(i-t)+"px"))}function o(t,r,n){function o(r,n){return lr(e,E(t,r),"div",u,n)}var l,a,u=M(s,t),h=u.text.length,d=Se(u,s.direction);return xe(d,r||0,null==n?h:n,function(t,s,p,g){var v=o(t,"ltr"==p?"left":"right"),m=o(s-1,"ltr"==p?"right":"left");if("ltr"==p){var y=null==r&&0==t?c:v.left,b=null==n&&s==h?f:m.right;m.top-v.top<=3?i(y,m.top,b-y,m.bottom):(i(y,v.top,null,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top),i(c,m.top,m.right,m.bottom))}else if(t<s){var w=null==r&&0==t?f:v.right,x=null==n&&s==h?c:m.left;if(m.top-v.top<=3)i(x,m.top,w-x,m.bottom);else{var C=c;if(g){var S=hr(e,u,null,t).end;C=o(S-(/\s/.test(u.text.charAt(S-1))?2:1),"left").left}i(C,v.top,w-C,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top);var L=null;d.length,L=o(hr(e,u,null,s).begin,"right").right-x,i(x,m.top,L,m.bottom)}}(!l||Nr(v,l)<0)&&(l=v),Nr(m,l)<0&&(l=m),(!a||Nr(v,a)<0)&&(a=v),Nr(m,a)<0&&(a=m)}),{start:l,end:a}}var l=e.display,s=e.doc,a=document.createDocumentFragment(),u=It(e.display),c=u.left,f=Math.max(l.sizerWidth,Rt(e)-l.sizer.offsetLeft)-u.right,h=t.from(),d=t.to();if(h.line==d.line)o(h.line,h.ch,d.ch);else{var p=M(s,h.line),g=M(s,d.line),v=fe(p)==fe(g),m=o(h.line,h.ch,v?p.text.length+1:null).end,y=o(d.line,v?0:null,d.ch).start;v&&(m.top<y.top-2?(i(m.right,m.top,null,m.bottom),i(c,y.top,y.left,y.bottom)):i(m.right,m.top,y.left-m.right,m.bottom)),m.bottom<y.top&&i(c,m.bottom,null,y.top)}r.appendChild(a)}function Ar(e){if(e.state.focused){var t=e.display;clearInterval(t.blinker);var r=!0;t.cursorDiv.style.visibility="",e.options.cursorBlinkRate>0?t.blinker=setInterval(function(){return t.cursorDiv.style.visibility=(r=!r)?"":"hidden"},e.options.cursorBlinkRate):e.options.cursorBlinkRate<0&&(t.cursorDiv.style.visibility="hidden")}}function Wr(e){e.state.focused||(e.display.input.focus(),Hr(e))}function Dr(e){e.state.delayingBlurEvent=!0,setTimeout(function(){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1,Fr(e))},100)}function Hr(e,t){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1),"nocursor"!=e.options.readOnly&&(e.state.focused||(Te(e,"focus",e,t),e.state.focused=!0,s(e.display.wrapper,"CodeMirror-focused"),e.curOp||e.display.selForContextMenu==e.doc.sel||(e.display.input.reset(),ml&&setTimeout(function(){return e.display.input.reset(!0)},20)),e.display.input.receivedFocus()),Ar(e))}function Fr(e,t){e.state.delayingBlurEvent||(e.state.focused&&(Te(e,"blur",e,t),e.state.focused=!1,Fl(e.display.wrapper,"CodeMirror-focused")),clearInterval(e.display.blinker),setTimeout(function(){e.state.focused||(e.display.shift=!1)},150))}function Er(e){for(var t=e.display,r=t.lineDiv.offsetTop,n=0;n<t.view.length;n++){var i=t.view[n],o=void 0;if(!i.hidden){if(gl&&vl<8){var l=i.node.offsetTop+i.node.offsetHeight;o=l-r,r=l}else{var s=i.node.getBoundingClientRect();o=s.bottom-s.top}var a=i.line.height-o;if(o<2&&(o=mr(t)),(a>.005||a<-.005)&&(A(i.line,o),Pr(i.line),i.rest))for(var u=0;u<i.rest.length;u++)Pr(i.rest[u])}}}function Pr(e){if(e.widgets)for(var t=0;t<e.widgets.length;++t)e.widgets[t].height=e.widgets[t].node.parentNode.offsetHeight}function Ir(e,t,r){var n=r&&null!=r.top?Math.max(0,r.top):e.scroller.scrollTop;n=Math.floor(n-Et(e));var i=r&&null!=r.bottom?r.bottom:n+e.wrapper.clientHeight,o=D(t,n),l=D(t,i);if(r&&r.ensure){var s=r.ensure.from.line,a=r.ensure.to.line;s<o?(o=s,l=D(t,ye(M(t,s))+e.wrapper.clientHeight)):Math.min(a,t.lastLine())>=l&&(o=D(t,ye(M(t,a))-e.wrapper.clientHeight),l=a)}return{from:o,to:Math.max(l,o+1)}}function zr(e){var t=e.display,r=t.view;if(t.alignWidgets||t.gutters.firstChild&&e.options.fixedGutter){for(var n=wr(t)-t.scroller.scrollLeft+e.doc.scrollLeft,i=t.gutters.offsetWidth,o=n+"px",l=0;l<r.length;l++)if(!r[l].hidden){e.options.fixedGutter&&(r[l].gutter&&(r[l].gutter.style.left=o),r[l].gutterBackground&&(r[l].gutterBackground.style.left=o));var s=r[l].alignable;if(s)for(var a=0;a<s.length;a++)s[a].style.left=o}e.options.fixedGutter&&(t.gutters.style.left=n+i+"px")}}function Rr(e){if(!e.options.lineNumbers)return!1;var t=e.doc,r=F(e.options,t.first+t.size-1),i=e.display;if(r.length!=i.lineNumChars){var o=i.measure.appendChild(n("div",[n("div",r)],"CodeMirror-linenumber CodeMirror-gutter-elt")),l=o.firstChild.offsetWidth,s=o.offsetWidth-l;return i.lineGutter.style.width="",i.lineNumInnerWidth=Math.max(l,i.lineGutter.offsetWidth-s)+1,i.lineNumWidth=i.lineNumInnerWidth+s,i.lineNumChars=i.lineNumInnerWidth?r.length:-1,i.lineGutter.style.width=i.lineNumWidth+"px",Wn(e),!0}return!1}function Br(e,t){if(!Me(e,"scrollCursorIntoView")){var r=e.display,i=r.sizer.getBoundingClientRect(),o=null;if(t.top+i.top<0?o=!0:t.bottom+i.top>(window.innerHeight||document.documentElement.clientHeight)&&(o=!1),null!=o&&!Sl){var l=n("div","​",null,"position: absolute;\n                         top: "+(t.top-r.viewOffset-Et(e.display))+"px;\n                         height: "+(t.bottom-t.top+zt(e)+r.barHeight)+"px;\n                         left: "+t.left+"px; width: "+Math.max(2,t.right-t.left)+"px;");e.display.lineSpace.appendChild(l),l.scrollIntoView(o),e.display.lineSpace.removeChild(l)}}}function Gr(e,t,r,n){null==n&&(n=0);var i;e.options.lineWrapping||t!=r||(r="before"==(t=t.ch?E(t.line,"before"==t.sticky?t.ch-1:t.ch,"after"):t).sticky?E(t.line,t.ch+1,"before"):t);for(var o=0;o<5;o++){var l=!1,s=sr(e,t),a=r&&r!=t?sr(e,r):s,u=Vr(e,i={left:Math.min(s.left,a.left),top:Math.min(s.top,a.top)-n,right:Math.max(s.left,a.left),bottom:Math.max(s.bottom,a.bottom)+n}),c=e.doc.scrollTop,f=e.doc.scrollLeft;if(null!=u.scrollTop&&(qr(e,u.scrollTop),Math.abs(e.doc.scrollTop-c)>1&&(l=!0)),null!=u.scrollLeft&&(Qr(e,u.scrollLeft),Math.abs(e.doc.scrollLeft-f)>1&&(l=!0)),!l)break}return i}function Ur(e,t){var r=Vr(e,t);null!=r.scrollTop&&qr(e,r.scrollTop),null!=r.scrollLeft&&Qr(e,r.scrollLeft)}function Vr(e,t){var r=e.display,n=mr(e.display);t.top<0&&(t.top=0);var i=e.curOp&&null!=e.curOp.scrollTop?e.curOp.scrollTop:r.scroller.scrollTop,o=Bt(e),l={};t.bottom-t.top>o&&(t.bottom=t.top+o);var s=e.doc.height+Pt(r),a=t.top<n,u=t.bottom>s-n;if(t.top<i)l.scrollTop=a?0:t.top;else if(t.bottom>i+o){var c=Math.min(t.top,(u?s:t.bottom)-o);c!=i&&(l.scrollTop=c)}var f=e.curOp&&null!=e.curOp.scrollLeft?e.curOp.scrollLeft:r.scroller.scrollLeft,h=Rt(e)-(e.options.fixedGutter?r.gutters.offsetWidth:0),d=t.right-t.left>h;return d&&(t.right=t.left+h),t.left<10?l.scrollLeft=0:t.left<f?l.scrollLeft=Math.max(0,t.left-(d?0:10)):t.right>h+f-3&&(l.scrollLeft=t.right+(d?0:10)-h),l}function Kr(e,t){null!=t&&(_r(e),e.curOp.scrollTop=(null==e.curOp.scrollTop?e.doc.scrollTop:e.curOp.scrollTop)+t)}function jr(e){_r(e);var t=e.getCursor();e.curOp.scrollToPos={from:t,to:t,margin:e.options.cursorScrollMargin}}function Xr(e,t,r){null==t&&null==r||_r(e),null!=t&&(e.curOp.scrollLeft=t),null!=r&&(e.curOp.scrollTop=r)}function Yr(e,t){_r(e),e.curOp.scrollToPos=t}function _r(e){var t=e.curOp.scrollToPos;t&&(e.curOp.scrollToPos=null,$r(e,ar(e,t.from),ar(e,t.to),t.margin))}function $r(e,t,r,n){var i=Vr(e,{left:Math.min(t.left,r.left),top:Math.min(t.top,r.top)-n,right:Math.max(t.right,r.right),bottom:Math.max(t.bottom,r.bottom)+n});Xr(e,i.scrollLeft,i.scrollTop)}function qr(e,t){Math.abs(e.doc.scrollTop-t)<2||(fl||On(e,{top:t}),Zr(e,t,!0),fl&&On(e),Cn(e,100))}function Zr(e,t,r){t=Math.min(e.display.scroller.scrollHeight-e.display.scroller.clientHeight,t),(e.display.scroller.scrollTop!=t||r)&&(e.doc.scrollTop=t,e.display.scrollbars.setScrollTop(t),e.display.scroller.scrollTop!=t&&(e.display.scroller.scrollTop=t))}function Qr(e,t,r,n){t=Math.min(t,e.display.scroller.scrollWidth-e.display.scroller.clientWidth),(r?t==e.doc.scrollLeft:Math.abs(e.doc.scrollLeft-t)<2)&&!n||(e.doc.scrollLeft=t,zr(e),e.display.scroller.scrollLeft!=t&&(e.display.scroller.scrollLeft=t),e.display.scrollbars.setScrollLeft(t))}function Jr(e){var t=e.display,r=t.gutters.offsetWidth,n=Math.round(e.doc.height+Pt(e.display));return{clientHeight:t.scroller.clientHeight,viewHeight:t.wrapper.clientHeight,scrollWidth:t.scroller.scrollWidth,clientWidth:t.scroller.clientWidth,viewWidth:t.wrapper.clientWidth,barLeft:e.options.fixedGutter?r:0,docHeight:n,scrollHeight:n+zt(e)+t.barHeight,nativeBarWidth:t.nativeBarWidth,gutterWidth:r}}function en(e,t){t||(t=Jr(e));var r=e.display.barWidth,n=e.display.barHeight;tn(e,t);for(var i=0;i<4&&r!=e.display.barWidth||n!=e.display.barHeight;i++)r!=e.display.barWidth&&e.options.lineWrapping&&Er(e),tn(e,Jr(e)),r=e.display.barWidth,n=e.display.barHeight}function tn(e,t){var r=e.display,n=r.scrollbars.update(t);r.sizer.style.paddingRight=(r.barWidth=n.right)+"px",r.sizer.style.paddingBottom=(r.barHeight=n.bottom)+"px",r.heightForcer.style.borderBottom=n.bottom+"px solid transparent",n.right&&n.bottom?(r.scrollbarFiller.style.display="block",r.scrollbarFiller.style.height=n.bottom+"px",r.scrollbarFiller.style.width=n.right+"px"):r.scrollbarFiller.style.display="",n.bottom&&e.options.coverGutterNextToScrollbar&&e.options.fixedGutter?(r.gutterFiller.style.display="block",r.gutterFiller.style.height=n.bottom+"px",r.gutterFiller.style.width=t.gutterWidth+"px"):r.gutterFiller.style.display=""}function rn(e){e.display.scrollbars&&(e.display.scrollbars.clear(),e.display.scrollbars.addClass&&Fl(e.display.wrapper,e.display.scrollbars.addClass)),e.display.scrollbars=new ws[e.options.scrollbarStyle](function(t){e.display.wrapper.insertBefore(t,e.display.scrollbarFiller),Ql(t,"mousedown",function(){e.state.focused&&setTimeout(function(){return e.display.input.focus()},0)}),t.setAttribute("cm-not-content","true")},function(t,r){"horizontal"==r?Qr(e,t):qr(e,t)},e),e.display.scrollbars.addClass&&s(e.display.wrapper,e.display.scrollbars.addClass)}function nn(e){e.curOp={cm:e,viewChanged:!1,startHeight:e.doc.height,forceUpdate:!1,updateInput:null,typing:!1,changeObjs:null,cursorActivityHandlers:null,cursorActivityCalled:0,selectionChanged:!1,updateMaxLine:!1,scrollLeft:null,scrollTop:null,scrollToPos:null,focus:!1,id:++xs},vt(e.curOp)}function on(e){yt(e.curOp,function(e){for(var t=0;t<e.ops.length;t++)e.ops[t].cm.curOp=null;ln(e)})}function ln(e){for(var t=e.ops,r=0;r<t.length;r++)sn(t[r]);for(var n=0;n<t.length;n++)an(t[n]);for(var i=0;i<t.length;i++)un(t[i]);for(var o=0;o<t.length;o++)cn(t[o]);for(var l=0;l<t.length;l++)fn(t[l])}function sn(e){var t=e.cm,r=t.display;Ln(t),e.updateMaxLine&&we(t),e.mustUpdate=e.viewChanged||e.forceUpdate||null!=e.scrollTop||e.scrollToPos&&(e.scrollToPos.from.line<r.viewFrom||e.scrollToPos.to.line>=r.viewTo)||r.maxLineChanged&&t.options.lineWrapping,e.update=e.mustUpdate&&new Cs(t,e.mustUpdate&&{top:e.scrollTop,ensure:e.scrollToPos},e.forceUpdate)}function an(e){e.updatedDisplay=e.mustUpdate&&Mn(e.cm,e.update)}function un(e){var t=e.cm,r=t.display;e.updatedDisplay&&Er(t),e.barMeasure=Jr(t),r.maxLineChanged&&!t.options.lineWrapping&&(e.adjustWidthTo=Kt(t,r.maxLine,r.maxLine.text.length).left+3,t.display.sizerWidth=e.adjustWidthTo,e.barMeasure.scrollWidth=Math.max(r.scroller.clientWidth,r.sizer.offsetLeft+e.adjustWidthTo+zt(t)+t.display.barWidth),e.maxScrollLeft=Math.max(0,r.sizer.offsetLeft+e.adjustWidthTo-Rt(t))),(e.updatedDisplay||e.selectionChanged)&&(e.preparedSelection=r.input.prepareSelection())}function cn(e){var t=e.cm;null!=e.adjustWidthTo&&(t.display.sizer.style.minWidth=e.adjustWidthTo+"px",e.maxScrollLeft<t.doc.scrollLeft&&Qr(t,Math.min(t.display.scroller.scrollLeft,e.maxScrollLeft),!0),t.display.maxLineChanged=!1);var r=e.focus&&e.focus==l();e.preparedSelection&&t.display.input.showSelection(e.preparedSelection,r),(e.updatedDisplay||e.startHeight!=t.doc.height)&&en(t,e.barMeasure),e.updatedDisplay&&Dn(t,e.barMeasure),e.selectionChanged&&Ar(t),t.state.focused&&e.updateInput&&t.display.input.reset(e.typing),r&&Wr(e.cm)}function fn(e){var t=e.cm,r=t.display,n=t.doc;e.updatedDisplay&&Nn(t,e.update),null==r.wheelStartX||null==e.scrollTop&&null==e.scrollLeft&&!e.scrollToPos||(r.wheelStartX=r.wheelStartY=null),null!=e.scrollTop&&Zr(t,e.scrollTop,e.forceScroll),null!=e.scrollLeft&&Qr(t,e.scrollLeft,!0,!0),e.scrollToPos&&Br(t,Gr(t,U(n,e.scrollToPos.from),U(n,e.scrollToPos.to),e.scrollToPos.margin));var i=e.maybeHiddenMarkers,o=e.maybeUnhiddenMarkers;if(i)for(var l=0;l<i.length;++l)i[l].lines.length||Te(i[l],"hide");if(o)for(var s=0;s<o.length;++s)o[s].lines.length&&Te(o[s],"unhide");r.wrapper.offsetHeight&&(n.scrollTop=t.display.scroller.scrollTop),e.changeObjs&&Te(t,"changes",t,e.changeObjs),e.update&&e.update.finish()}function hn(e,t){if(e.curOp)return t();nn(e);try{return t()}finally{on(e)}}function dn(e,t){return function(){if(e.curOp)return t.apply(e,arguments);nn(e);try{return t.apply(e,arguments)}finally{on(e)}}}function pn(e){return function(){if(this.curOp)return e.apply(this,arguments);nn(this);try{return e.apply(this,arguments)}finally{on(this)}}}function gn(e){return function(){var t=this.cm;if(!t||t.curOp)return e.apply(this,arguments);nn(t);try{return e.apply(this,arguments)}finally{on(t)}}}function vn(e,t,r,n){null==t&&(t=e.doc.first),null==r&&(r=e.doc.first+e.doc.size),n||(n=0);var i=e.display;if(n&&r<i.viewTo&&(null==i.updateLineNumbers||i.updateLineNumbers>t)&&(i.updateLineNumbers=t),e.curOp.viewChanged=!0,t>=i.viewTo)_l&&pe(e.doc,t)<i.viewTo&&yn(e);else if(r<=i.viewFrom)_l&&ge(e.doc,r+n)>i.viewFrom?yn(e):(i.viewFrom+=n,i.viewTo+=n);else if(t<=i.viewFrom&&r>=i.viewTo)yn(e);else if(t<=i.viewFrom){var o=bn(e,r,r+n,1);o?(i.view=i.view.slice(o.index),i.viewFrom=o.lineN,i.viewTo+=n):yn(e)}else if(r>=i.viewTo){var l=bn(e,t,t,-1);l?(i.view=i.view.slice(0,l.index),i.viewTo=l.lineN):yn(e)}else{var s=bn(e,t,t,-1),a=bn(e,r,r+n,1);s&&a?(i.view=i.view.slice(0,s.index).concat(gt(e,s.lineN,a.lineN)).concat(i.view.slice(a.index)),i.viewTo+=n):yn(e)}var u=i.externalMeasured;u&&(r<u.lineN?u.lineN+=n:t<u.lineN+u.size&&(i.externalMeasured=null))}function mn(e,t,r){e.curOp.viewChanged=!0;var n=e.display,i=e.display.externalMeasured;if(i&&t>=i.lineN&&t<i.lineN+i.size&&(n.externalMeasured=null),!(t<n.viewFrom||t>=n.viewTo)){var o=n.view[Lr(e,t)];if(null!=o.node){var l=o.changes||(o.changes=[]);-1==h(l,r)&&l.push(r)}}}function yn(e){e.display.viewFrom=e.display.viewTo=e.doc.first,e.display.view=[],e.display.viewOffset=0}function bn(e,t,r,n){var i,o=Lr(e,t),l=e.display.view;if(!_l||r==e.doc.first+e.doc.size)return{index:o,lineN:r};for(var s=e.display.viewFrom,a=0;a<o;a++)s+=l[a].size;if(s!=t){if(n>0){if(o==l.length-1)return null;i=s+l[o].size-t,o++}else i=s-t;t+=i,r+=i}for(;pe(e.doc,r)!=r;){if(o==(n<0?0:l.length-1))return null;r+=n*l[o-(n<0?1:0)].size,o+=n}return{index:o,lineN:r}}function wn(e,t,r){var n=e.display;0==n.view.length||t>=n.viewTo||r<=n.viewFrom?(n.view=gt(e,t,r),n.viewFrom=t):(n.viewFrom>t?n.view=gt(e,t,n.viewFrom).concat(n.view):n.viewFrom<t&&(n.view=n.view.slice(Lr(e,t))),n.viewFrom=t,n.viewTo<r?n.view=n.view.concat(gt(e,n.viewTo,r)):n.viewTo>r&&(n.view=n.view.slice(0,Lr(e,r)))),n.viewTo=r}function xn(e){for(var t=e.display.view,r=0,n=0;n<t.length;n++){var i=t[n];i.hidden||i.node&&!i.changes||++r}return r}function Cn(e,t){e.doc.highlightFrontier<e.display.viewTo&&e.state.highlight.set(t,u(Sn,e))}function Sn(e){var t=e.doc;if(!(t.highlightFrontier>=e.display.viewTo)){var r=+new Date+e.options.workTime,n=$e(e,t.highlightFrontier),i=[];t.iter(n.line,Math.min(t.first+t.size,e.display.viewTo+500),function(o){if(n.line>=e.display.viewFrom){var l=o.styles,s=o.text.length>e.options.maxHighlightLength?Ke(t.mode,n.state):null,a=Ye(e,o,n,!0);s&&(n.state=s),o.styles=a.styles;var u=o.styleClasses,c=a.classes;c?o.styleClasses=c:u&&(o.styleClasses=null);for(var f=!l||l.length!=o.styles.length||u!=c&&(!u||!c||u.bgClass!=c.bgClass||u.textClass!=c.textClass),h=0;!f&&h<l.length;++h)f=l[h]!=o.styles[h];f&&i.push(n.line),o.stateAfter=n.save(),n.nextLine()}else o.text.length<=e.options.maxHighlightLength&&qe(e,o.text,n),o.stateAfter=n.line%5==0?n.save():null,n.nextLine();if(+new Date>r)return Cn(e,e.options.workDelay),!0}),t.highlightFrontier=n.line,t.modeFrontier=Math.max(t.modeFrontier,n.line),i.length&&hn(e,function(){for(var t=0;t<i.length;t++)mn(e,i[t],"text")})}}function Ln(e){var t=e.display;!t.scrollbarsClipped&&t.scroller.offsetWidth&&(t.nativeBarWidth=t.scroller.offsetWidth-t.scroller.clientWidth,t.heightForcer.style.height=zt(e)+"px",t.sizer.style.marginBottom=-t.nativeBarWidth+"px",t.sizer.style.borderRightWidth=zt(e)+"px",t.scrollbarsClipped=!0)}function kn(e){if(e.hasFocus())return null;var t=l();if(!t||!o(e.display.lineDiv,t))return null;var r={activeElt:t};if(window.getSelection){var n=window.getSelection();n.anchorNode&&n.extend&&o(e.display.lineDiv,n.anchorNode)&&(r.anchorNode=n.anchorNode,r.anchorOffset=n.anchorOffset,r.focusNode=n.focusNode,r.focusOffset=n.focusOffset)}return r}function Tn(e){if(e&&e.activeElt&&e.activeElt!=l()&&(e.activeElt.focus(),e.anchorNode&&o(document.body,e.anchorNode)&&o(document.body,e.focusNode))){var t=window.getSelection(),r=document.createRange();r.setEnd(e.anchorNode,e.anchorOffset),r.collapse(!1),t.removeAllRanges(),t.addRange(r),t.extend(e.focusNode,e.focusOffset)}}function Mn(e,r){var n=e.display,i=e.doc;if(r.editorIsHidden)return yn(e),!1;if(!r.force&&r.visible.from>=n.viewFrom&&r.visible.to<=n.viewTo&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo)&&n.renderedView==n.view&&0==xn(e))return!1;Rr(e)&&(yn(e),r.dims=br(e));var o=i.first+i.size,l=Math.max(r.visible.from-e.options.viewportMargin,i.first),s=Math.min(o,r.visible.to+e.options.viewportMargin);n.viewFrom<l&&l-n.viewFrom<20&&(l=Math.max(i.first,n.viewFrom)),n.viewTo>s&&n.viewTo-s<20&&(s=Math.min(o,n.viewTo)),_l&&(l=pe(e.doc,l),s=ge(e.doc,s));var a=l!=n.viewFrom||s!=n.viewTo||n.lastWrapHeight!=r.wrapperHeight||n.lastWrapWidth!=r.wrapperWidth;wn(e,l,s),n.viewOffset=ye(M(e.doc,n.viewFrom)),e.display.mover.style.top=n.viewOffset+"px";var u=xn(e);if(!a&&0==u&&!r.force&&n.renderedView==n.view&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo))return!1;var c=kn(e);return u>4&&(n.lineDiv.style.display="none"),An(e,n.updateLineNumbers,r.dims),u>4&&(n.lineDiv.style.display=""),n.renderedView=n.view,Tn(c),t(n.cursorDiv),t(n.selectionDiv),n.gutters.style.height=n.sizer.style.minHeight=0,a&&(n.lastWrapHeight=r.wrapperHeight,n.lastWrapWidth=r.wrapperWidth,Cn(e,400)),n.updateLineNumbers=null,!0}function Nn(e,t){for(var r=t.viewport,n=!0;(n&&e.options.lineWrapping&&t.oldDisplayWidth!=Rt(e)||(r&&null!=r.top&&(r={top:Math.min(e.doc.height+Pt(e.display)-Bt(e),r.top)}),t.visible=Ir(e.display,e.doc,r),!(t.visible.from>=e.display.viewFrom&&t.visible.to<=e.display.viewTo)))&&Mn(e,t);n=!1){Er(e);var i=Jr(e);kr(e),en(e,i),Dn(e,i),t.force=!1}t.signal(e,"update",e),e.display.viewFrom==e.display.reportedViewFrom&&e.display.viewTo==e.display.reportedViewTo||(t.signal(e,"viewportChange",e,e.display.viewFrom,e.display.viewTo),e.display.reportedViewFrom=e.display.viewFrom,e.display.reportedViewTo=e.display.viewTo)}function On(e,t){var r=new Cs(e,t);if(Mn(e,r)){Er(e),Nn(e,r);var n=Jr(e);kr(e),en(e,n),Dn(e,n),r.finish()}}function An(e,r,n){function i(t){var r=t.nextSibling;return ml&&Ml&&e.display.currentWheelTarget==t?t.style.display="none":t.parentNode.removeChild(t),r}for(var o=e.display,l=e.options.lineNumbers,s=o.lineDiv,a=s.firstChild,u=o.view,c=o.viewFrom,f=0;f<u.length;f++){var d=u[f];if(d.hidden);else if(d.node&&d.node.parentNode==s){for(;a!=d.node;)a=i(a);var p=l&&null!=r&&r<=c&&d.lineNumber;d.changes&&(h(d.changes,"gutter")>-1&&(p=!1),xt(e,d,c,n)),p&&(t(d.lineNumber),d.lineNumber.appendChild(document.createTextNode(F(e.options,c)))),a=d.node.nextSibling}else{var g=Ot(e,d,c,n);s.insertBefore(g,a)}c+=d.size}for(;a;)a=i(a)}function Wn(e){var t=e.display.gutters.offsetWidth;e.display.sizer.style.marginLeft=t+"px"}function Dn(e,t){e.display.sizer.style.minHeight=t.docHeight+"px",e.display.heightForcer.style.top=t.docHeight+"px",e.display.gutters.style.height=t.docHeight+e.display.barHeight+zt(e)+"px"}function Hn(e){var r=e.display.gutters,i=e.options.gutters;t(r);for(var o=0;o<i.length;++o){var l=i[o],s=r.appendChild(n("div",null,"CodeMirror-gutter "+l));"CodeMirror-linenumbers"==l&&(e.display.lineGutter=s,s.style.width=(e.display.lineNumWidth||1)+"px")}r.style.display=o?"":"none",Wn(e)}function Fn(e){var t=h(e.gutters,"CodeMirror-linenumbers");-1==t&&e.lineNumbers?e.gutters=e.gutters.concat(["CodeMirror-linenumbers"]):t>-1&&!e.lineNumbers&&(e.gutters=e.gutters.slice(0),e.gutters.splice(t,1))}function En(e){var t=e.wheelDeltaX,r=e.wheelDeltaY;return null==t&&e.detail&&e.axis==e.HORIZONTAL_AXIS&&(t=e.detail),null==r&&e.detail&&e.axis==e.VERTICAL_AXIS?r=e.detail:null==r&&(r=e.wheelDelta),{x:t,y:r}}function Pn(e){var t=En(e);return t.x*=Ls,t.y*=Ls,t}function In(e,t){var r=En(t),n=r.x,i=r.y,o=e.display,l=o.scroller,s=l.scrollWidth>l.clientWidth,a=l.scrollHeight>l.clientHeight;if(n&&s||i&&a){if(i&&Ml&&ml)e:for(var u=t.target,c=o.view;u!=l;u=u.parentNode)for(var f=0;f<c.length;f++)if(c[f].node==u){e.display.currentWheelTarget=u;break e}if(n&&!fl&&!wl&&null!=Ls)return i&&a&&qr(e,Math.max(0,l.scrollTop+i*Ls)),Qr(e,Math.max(0,l.scrollLeft+n*Ls)),(!i||i&&a)&&We(t),void(o.wheelStartX=null);if(i&&null!=Ls){var h=i*Ls,d=e.doc.scrollTop,p=d+o.wrapper.clientHeight;h<0?d=Math.max(0,d+h-50):p=Math.min(e.doc.height,p+h+50),On(e,{top:d,bottom:p})}Ss<20&&(null==o.wheelStartX?(o.wheelStartX=l.scrollLeft,o.wheelStartY=l.scrollTop,o.wheelDX=n,o.wheelDY=i,setTimeout(function(){if(null!=o.wheelStartX){var e=l.scrollLeft-o.wheelStartX,t=l.scrollTop-o.wheelStartY,r=t&&o.wheelDY&&t/o.wheelDY||e&&o.wheelDX&&e/o.wheelDX;o.wheelStartX=o.wheelStartY=null,r&&(Ls=(Ls*Ss+r)/(Ss+1),++Ss)}},200)):(o.wheelDX+=n,o.wheelDY+=i))}}function zn(e,t){var r=e[t];e.sort(function(e,t){return P(e.from(),t.from())}),t=h(e,r);for(var n=1;n<e.length;n++){var i=e[n],o=e[n-1];if(P(o.to(),i.from())>=0){var l=B(o.from(),i.from()),s=R(o.to(),i.to()),a=o.empty()?i.from()==i.head:o.from()==o.head;n<=t&&--t,e.splice(--n,2,new Ts(a?s:l,a?l:s))}}return new ks(e,t)}function Rn(e,t){return new ks([new Ts(e,t||e)],0)}function Bn(e){return e.text?E(e.from.line+e.text.length-1,g(e.text).length+(1==e.text.length?e.from.ch:0)):e.to}function Gn(e,t){if(P(e,t.from)<0)return e;if(P(e,t.to)<=0)return Bn(t);var r=e.line+t.text.length-(t.to.line-t.from.line)-1,n=e.ch;return e.line==t.to.line&&(n+=Bn(t).ch-t.to.ch),E(r,n)}function Un(e,t){for(var r=[],n=0;n<e.sel.ranges.length;n++){var i=e.sel.ranges[n];r.push(new Ts(Gn(i.anchor,t),Gn(i.head,t)))}return zn(r,e.sel.primIndex)}function Vn(e,t,r){return e.line==t.line?E(r.line,e.ch-t.ch+r.ch):E(r.line+(e.line-t.line),e.ch)}function Kn(e,t,r){for(var n=[],i=E(e.first,0),o=i,l=0;l<t.length;l++){var s=t[l],a=Vn(s.from,i,o),u=Vn(Bn(s),i,o);if(i=s.to,o=u,"around"==r){var c=e.sel.ranges[l],f=P(c.head,c.anchor)<0;n[l]=new Ts(f?u:a,f?a:u)}else n[l]=new Ts(a,a)}return new ks(n,e.sel.primIndex)}function jn(e){e.doc.mode=Ue(e.options,e.doc.modeOption),Xn(e)}function Xn(e){e.doc.iter(function(e){e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null)}),e.doc.modeFrontier=e.doc.highlightFrontier=e.doc.first,Cn(e,100),e.state.modeGen++,e.curOp&&vn(e)}function Yn(e,t){return 0==t.from.ch&&0==t.to.ch&&""==g(t.text)&&(!e.cm||e.cm.options.wholeLineUpdateBefore)}function _n(e,t,r,n){function i(e){return r?r[e]:null}function o(e,r,i){it(e,r,i,n),bt(e,"change",e,t)}function l(e,t){for(var r=[],o=e;o<t;++o)r.push(new fs(u[o],i(o),n));return r}var s=t.from,a=t.to,u=t.text,c=M(e,s.line),f=M(e,a.line),h=g(u),d=i(u.length-1),p=a.line-s.line;if(t.full)e.insert(0,l(0,u.length)),e.remove(u.length,e.size-u.length);else if(Yn(e,t)){var v=l(0,u.length-1);o(f,f.text,d),p&&e.remove(s.line,p),v.length&&e.insert(s.line,v)}else if(c==f)if(1==u.length)o(c,c.text.slice(0,s.ch)+h+c.text.slice(a.ch),d);else{var m=l(1,u.length-1);m.push(new fs(h+c.text.slice(a.ch),d,n)),o(c,c.text.slice(0,s.ch)+u[0],i(0)),e.insert(s.line+1,m)}else if(1==u.length)o(c,c.text.slice(0,s.ch)+u[0]+f.text.slice(a.ch),i(0)),e.remove(s.line+1,p);else{o(c,c.text.slice(0,s.ch)+u[0],i(0)),o(f,h+f.text.slice(a.ch),d);var y=l(1,u.length-1);p>1&&e.remove(s.line+1,p-1),e.insert(s.line+1,y)}bt(e,"change",e,t)}function $n(e,t,r){function n(e,i,o){if(e.linked)for(var l=0;l<e.linked.length;++l){var s=e.linked[l];if(s.doc!=i){var a=o&&s.sharedHist;r&&!a||(t(s.doc,a),n(s.doc,e,a))}}}n(e,null,!0)}function qn(e,t){if(t.cm)throw new Error("This document is already in use.");e.doc=t,t.cm=e,Cr(e),jn(e),Zn(e),e.options.lineWrapping||we(e),e.options.mode=t.modeOption,vn(e)}function Zn(e){("rtl"==e.doc.direction?s:Fl)(e.display.lineDiv,"CodeMirror-rtl")}function Qn(e){hn(e,function(){Zn(e),vn(e)})}function Jn(e){this.done=[],this.undone=[],this.undoDepth=1/0,this.lastModTime=this.lastSelTime=0,this.lastOp=this.lastSelOp=null,this.lastOrigin=this.lastSelOrigin=null,this.generation=this.maxGeneration=e||1}function ei(e,t){var r={from:z(t.from),to:Bn(t),text:N(e,t.from,t.to)};return si(e,r,t.from.line,t.to.line+1),$n(e,function(e){return si(e,r,t.from.line,t.to.line+1)},!0),r}function ti(e){for(;e.length&&g(e).ranges;)e.pop()}function ri(e,t){return t?(ti(e.done),g(e.done)):e.done.length&&!g(e.done).ranges?g(e.done):e.done.length>1&&!e.done[e.done.length-2].ranges?(e.done.pop(),g(e.done)):void 0}function ni(e,t,r,n){var i=e.history;i.undone.length=0;var o,l,s=+new Date;if((i.lastOp==n||i.lastOrigin==t.origin&&t.origin&&("+"==t.origin.charAt(0)&&e.cm&&i.lastModTime>s-e.cm.options.historyEventDelay||"*"==t.origin.charAt(0)))&&(o=ri(i,i.lastOp==n)))l=g(o.changes),0==P(t.from,t.to)&&0==P(t.from,l.to)?l.to=Bn(t):o.changes.push(ei(e,t));else{var a=g(i.done);for(a&&a.ranges||li(e.sel,i.done),o={changes:[ei(e,t)],generation:i.generation},i.done.push(o);i.done.length>i.undoDepth;)i.done.shift(),i.done[0].ranges||i.done.shift()}i.done.push(r),i.generation=++i.maxGeneration,i.lastModTime=i.lastSelTime=s,i.lastOp=i.lastSelOp=n,i.lastOrigin=i.lastSelOrigin=t.origin,l||Te(e,"historyAdded")}function ii(e,t,r,n){var i=t.charAt(0);return"*"==i||"+"==i&&r.ranges.length==n.ranges.length&&r.somethingSelected()==n.somethingSelected()&&new Date-e.history.lastSelTime<=(e.cm?e.cm.options.historyEventDelay:500)}function oi(e,t,r,n){var i=e.history,o=n&&n.origin;r==i.lastSelOp||o&&i.lastSelOrigin==o&&(i.lastModTime==i.lastSelTime&&i.lastOrigin==o||ii(e,o,g(i.done),t))?i.done[i.done.length-1]=t:li(t,i.done),i.lastSelTime=+new Date,i.lastSelOrigin=o,i.lastSelOp=r,n&&!1!==n.clearRedo&&ti(i.undone)}function li(e,t){var r=g(t);r&&r.ranges&&r.equals(e)||t.push(e)}function si(e,t,r,n){var i=t["spans_"+e.id],o=0;e.iter(Math.max(e.first,r),Math.min(e.first+e.size,n),function(r){r.markedSpans&&((i||(i=t["spans_"+e.id]={}))[o]=r.markedSpans),++o})}function ai(e){if(!e)return null;for(var t,r=0;r<e.length;++r)e[r].marker.explicitlyCleared?t||(t=e.slice(0,r)):t&&t.push(e[r]);return t?t.length?t:null:e}function ui(e,t){var r=t["spans_"+e.id];if(!r)return null;for(var n=[],i=0;i<t.text.length;++i)n.push(ai(r[i]));return n}function ci(e,t){var r=ui(e,t),n=J(e,t);if(!r)return n;if(!n)return r;for(var i=0;i<r.length;++i){var o=r[i],l=n[i];if(o&&l)e:for(var s=0;s<l.length;++s){for(var a=l[s],u=0;u<o.length;++u)if(o[u].marker==a.marker)continue e;o.push(a)}else l&&(r[i]=l)}return r}function fi(e,t,r){for(var n=[],i=0;i<e.length;++i){var o=e[i];if(o.ranges)n.push(r?ks.prototype.deepCopy.call(o):o);else{var l=o.changes,s=[];n.push({changes:s});for(var a=0;a<l.length;++a){var u=l[a],c=void 0;if(s.push({from:u.from,to:u.to,text:u.text}),t)for(var f in u)(c=f.match(/^spans_(\d+)$/))&&h(t,Number(c[1]))>-1&&(g(s)[f]=u[f],delete u[f])}}}return n}function hi(e,t,r,n){if(n){var i=e.anchor;if(r){var o=P(t,i)<0;o!=P(r,i)<0?(i=t,t=r):o!=P(t,r)<0&&(t=r)}return new Ts(i,t)}return new Ts(r||t,t)}function di(e,t,r,n,i){null==i&&(i=e.cm&&(e.cm.display.shift||e.extend)),bi(e,new ks([hi(e.sel.primary(),t,r,i)],0),n)}function pi(e,t,r){for(var n=[],i=e.cm&&(e.cm.display.shift||e.extend),o=0;o<e.sel.ranges.length;o++)n[o]=hi(e.sel.ranges[o],t[o],null,i);bi(e,zn(n,e.sel.primIndex),r)}function gi(e,t,r,n){var i=e.sel.ranges.slice(0);i[t]=r,bi(e,zn(i,e.sel.primIndex),n)}function vi(e,t,r,n){bi(e,Rn(t,r),n)}function mi(e,t,r){var n={ranges:t.ranges,update:function(t){var r=this;this.ranges=[];for(var n=0;n<t.length;n++)r.ranges[n]=new Ts(U(e,t[n].anchor),U(e,t[n].head))},origin:r&&r.origin};return Te(e,"beforeSelectionChange",e,n),e.cm&&Te(e.cm,"beforeSelectionChange",e.cm,n),n.ranges!=t.ranges?zn(n.ranges,n.ranges.length-1):t}function yi(e,t,r){var n=e.history.done,i=g(n);i&&i.ranges?(n[n.length-1]=t,wi(e,t,r)):bi(e,t,r)}function bi(e,t,r){wi(e,t,r),oi(e,e.sel,e.cm?e.cm.curOp.id:NaN,r)}function wi(e,t,r){(Oe(e,"beforeSelectionChange")||e.cm&&Oe(e.cm,"beforeSelectionChange"))&&(t=mi(e,t,r)),xi(e,Si(e,t,r&&r.bias||(P(t.primary().head,e.sel.primary().head)<0?-1:1),!0)),r&&!1===r.scroll||!e.cm||jr(e.cm)}function xi(e,t){t.equals(e.sel)||(e.sel=t,e.cm&&(e.cm.curOp.updateInput=e.cm.curOp.selectionChanged=!0,Ne(e.cm)),bt(e,"cursorActivity",e))}function Ci(e){xi(e,Si(e,e.sel,null,!1))}function Si(e,t,r,n){for(var i,o=0;o<t.ranges.length;o++){var l=t.ranges[o],s=t.ranges.length==e.sel.ranges.length&&e.sel.ranges[o],a=ki(e,l.anchor,s&&s.anchor,r,n),u=ki(e,l.head,s&&s.head,r,n);(i||a!=l.anchor||u!=l.head)&&(i||(i=t.ranges.slice(0,o)),i[o]=new Ts(a,u))}return i?zn(i,t.primIndex):t}function Li(e,t,r,n,i){var o=M(e,t.line);if(o.markedSpans)for(var l=0;l<o.markedSpans.length;++l){var s=o.markedSpans[l],a=s.marker;if((null==s.from||(a.inclusiveLeft?s.from<=t.ch:s.from<t.ch))&&(null==s.to||(a.inclusiveRight?s.to>=t.ch:s.to>t.ch))){if(i&&(Te(a,"beforeCursorEnter"),a.explicitlyCleared)){if(o.markedSpans){--l;continue}break}if(!a.atomic)continue;if(r){var u=a.find(n<0?1:-1),c=void 0;if((n<0?a.inclusiveRight:a.inclusiveLeft)&&(u=Ti(e,u,-n,u&&u.line==t.line?o:null)),u&&u.line==t.line&&(c=P(u,r))&&(n<0?c<0:c>0))return Li(e,u,t,n,i)}var f=a.find(n<0?-1:1);return(n<0?a.inclusiveLeft:a.inclusiveRight)&&(f=Ti(e,f,n,f.line==t.line?o:null)),f?Li(e,f,t,n,i):null}}return t}function ki(e,t,r,n,i){var o=n||1,l=Li(e,t,r,o,i)||!i&&Li(e,t,r,o,!0)||Li(e,t,r,-o,i)||!i&&Li(e,t,r,-o,!0);return l||(e.cantEdit=!0,E(e.first,0))}function Ti(e,t,r,n){return r<0&&0==t.ch?t.line>e.first?U(e,E(t.line-1)):null:r>0&&t.ch==(n||M(e,t.line)).text.length?t.line<e.first+e.size-1?E(t.line+1,0):null:new E(t.line,t.ch+r)}function Mi(e){e.setSelection(E(e.firstLine(),0),E(e.lastLine()),Gl)}function Ni(e,t,r){var n={canceled:!1,from:t.from,to:t.to,text:t.text,origin:t.origin,cancel:function(){return n.canceled=!0}};return r&&(n.update=function(t,r,i,o){t&&(n.from=U(e,t)),r&&(n.to=U(e,r)),i&&(n.text=i),void 0!==o&&(n.origin=o)}),Te(e,"beforeChange",e,n),e.cm&&Te(e.cm,"beforeChange",e.cm,n),n.canceled?null:{from:n.from,to:n.to,text:n.text,origin:n.origin}}function Oi(e,t,r){if(e.cm){if(!e.cm.curOp)return dn(e.cm,Oi)(e,t,r);if(e.cm.state.suppressEdits)return}if(!(Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"))||(t=Ni(e,t,!0))){var n=Yl&&!r&&te(e,t.from,t.to);if(n)for(var i=n.length-1;i>=0;--i)Ai(e,{from:n[i].from,to:n[i].to,text:i?[""]:t.text,origin:t.origin});else Ai(e,t)}}function Ai(e,t){if(1!=t.text.length||""!=t.text[0]||0!=P(t.from,t.to)){var r=Un(e,t);ni(e,t,r,e.cm?e.cm.curOp.id:NaN),Hi(e,t,r,J(e,t));var n=[];$n(e,function(e,r){r||-1!=h(n,e.history)||(zi(e.history,t),n.push(e.history)),Hi(e,t,null,J(e,t))})}}function Wi(e,t,r){if(!e.cm||!e.cm.state.suppressEdits||r){for(var n,i=e.history,o=e.sel,l="undo"==t?i.done:i.undone,s="undo"==t?i.undone:i.done,a=0;a<l.length&&(n=l[a],r?!n.ranges||n.equals(e.sel):n.ranges);a++);if(a!=l.length){for(i.lastOrigin=i.lastSelOrigin=null;(n=l.pop()).ranges;){if(li(n,s),r&&!n.equals(e.sel))return void bi(e,n,{clearRedo:!1});o=n}var u=[];li(o,s),s.push({changes:u,generation:i.generation}),i.generation=n.generation||++i.maxGeneration;for(var c=Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"),f=n.changes.length-1;f>=0;--f){var d=function(r){var i=n.changes[r];if(i.origin=t,c&&!Ni(e,i,!1))return l.length=0,{};u.push(ei(e,i));var o=r?Un(e,i):g(l);Hi(e,i,o,ci(e,i)),!r&&e.cm&&e.cm.scrollIntoView({from:i.from,to:Bn(i)});var s=[];$n(e,function(e,t){t||-1!=h(s,e.history)||(zi(e.history,i),s.push(e.history)),Hi(e,i,null,ci(e,i))})}(f);if(d)return d.v}}}}function Di(e,t){if(0!=t&&(e.first+=t,e.sel=new ks(v(e.sel.ranges,function(e){return new Ts(E(e.anchor.line+t,e.anchor.ch),E(e.head.line+t,e.head.ch))}),e.sel.primIndex),e.cm)){vn(e.cm,e.first,e.first-t,t);for(var r=e.cm.display,n=r.viewFrom;n<r.viewTo;n++)mn(e.cm,n,"gutter")}}function Hi(e,t,r,n){if(e.cm&&!e.cm.curOp)return dn(e.cm,Hi)(e,t,r,n);if(t.to.line<e.first)Di(e,t.text.length-1-(t.to.line-t.from.line));else if(!(t.from.line>e.lastLine())){if(t.from.line<e.first){var i=t.text.length-1-(e.first-t.from.line);Di(e,i),t={from:E(e.first,0),to:E(t.to.line+i,t.to.ch),text:[g(t.text)],origin:t.origin}}var o=e.lastLine();t.to.line>o&&(t={from:t.from,to:E(o,M(e,o).text.length),text:[t.text[0]],origin:t.origin}),t.removed=N(e,t.from,t.to),r||(r=Un(e,t)),e.cm?Fi(e.cm,t,n):_n(e,t,n),wi(e,r,Gl)}}function Fi(e,t,r){var n=e.doc,i=e.display,o=t.from,l=t.to,s=!1,a=o.line;e.options.lineWrapping||(a=W(fe(M(n,o.line))),n.iter(a,l.line+1,function(e){if(e==i.maxLine)return s=!0,!0})),n.sel.contains(t.from,t.to)>-1&&Ne(e),_n(n,t,r,xr(e)),e.options.lineWrapping||(n.iter(a,o.line+t.text.length,function(e){var t=be(e);t>i.maxLineLength&&(i.maxLine=e,i.maxLineLength=t,i.maxLineChanged=!0,s=!1)}),s&&(e.curOp.updateMaxLine=!0)),nt(n,o.line),Cn(e,400);var u=t.text.length-(l.line-o.line)-1;t.full?vn(e):o.line!=l.line||1!=t.text.length||Yn(e.doc,t)?vn(e,o.line,l.line+1,u):mn(e,o.line,"text");var c=Oe(e,"changes"),f=Oe(e,"change");if(f||c){var h={from:o,to:l,text:t.text,removed:t.removed,origin:t.origin};f&&bt(e,"change",e,h),c&&(e.curOp.changeObjs||(e.curOp.changeObjs=[])).push(h)}e.display.selForContextMenu=null}function Ei(e,t,r,n,i){if(n||(n=r),P(n,r)<0){var o;r=(o=[n,r])[0],n=o[1]}"string"==typeof t&&(t=e.splitLines(t)),Oi(e,{from:r,to:n,text:t,origin:i})}function Pi(e,t,r,n){r<e.line?e.line+=n:t<e.line&&(e.line=t,e.ch=0)}function Ii(e,t,r,n){for(var i=0;i<e.length;++i){var o=e[i],l=!0;if(o.ranges){o.copied||((o=e[i]=o.deepCopy()).copied=!0);for(var s=0;s<o.ranges.length;s++)Pi(o.ranges[s].anchor,t,r,n),Pi(o.ranges[s].head,t,r,n)}else{for(var a=0;a<o.changes.length;++a){var u=o.changes[a];if(r<u.from.line)u.from=E(u.from.line+n,u.from.ch),u.to=E(u.to.line+n,u.to.ch);else if(t<=u.to.line){l=!1;break}}l||(e.splice(0,i+1),i=0)}}}function zi(e,t){var r=t.from.line,n=t.to.line,i=t.text.length-(n-r)-1;Ii(e.done,r,n,i),Ii(e.undone,r,n,i)}function Ri(e,t,r,n){var i=t,o=t;return"number"==typeof t?o=M(e,G(e,t)):i=W(t),null==i?null:(n(o,i)&&e.cm&&mn(e.cm,i,r),o)}function Bi(e){var t=this;this.lines=e,this.parent=null;for(var r=0,n=0;n<e.length;++n)e[n].parent=t,r+=e[n].height;this.height=r}function Gi(e){var t=this;this.children=e;for(var r=0,n=0,i=0;i<e.length;++i){var o=e[i];r+=o.chunkSize(),n+=o.height,o.parent=t}this.size=r,this.height=n,this.parent=null}function Ui(e,t,r){ye(t)<(e.curOp&&e.curOp.scrollTop||e.doc.scrollTop)&&Kr(e,r)}function Vi(e,t,r,n){var i=new Ms(e,r,n),o=e.cm;return o&&i.noHScroll&&(o.display.alignWidgets=!0),Ri(e,t,"widget",function(t){var r=t.widgets||(t.widgets=[]);if(null==i.insertAt?r.push(i):r.splice(Math.min(r.length-1,Math.max(0,i.insertAt)),0,i),i.line=t,o&&!ve(e,t)){var n=ye(t)<e.scrollTop;A(t,t.height+Ht(i)),n&&Kr(o,i.height),o.curOp.forceUpdate=!0}return!0}),bt(o,"lineWidgetAdded",o,i,"number"==typeof t?t:W(t)),i}function Ki(e,t,r,n,o){if(n&&n.shared)return ji(e,t,r,n,o);if(e.cm&&!e.cm.curOp)return dn(e.cm,Ki)(e,t,r,n,o);var l=new Os(e,o),s=P(t,r);if(n&&c(n,l,!1),s>0||0==s&&!1!==l.clearWhenEmpty)return l;if(l.replacedWith&&(l.collapsed=!0,l.widgetNode=i("span",[l.replacedWith],"CodeMirror-widget"),n.handleMouseEvents||l.widgetNode.setAttribute("cm-ignore-events","true"),n.insertLeft&&(l.widgetNode.insertLeft=!0)),l.collapsed){if(ce(e,t.line,t,r,l)||t.line!=r.line&&ce(e,r.line,t,r,l))throw new Error("Inserting collapsed marker partially overlapping an existing one");X()}l.addToHistory&&ni(e,{from:t,to:r,origin:"markText"},e.sel,NaN);var a,u=t.line,f=e.cm;if(e.iter(u,r.line+1,function(e){f&&l.collapsed&&!f.options.lineWrapping&&fe(e)==f.display.maxLine&&(a=!0),l.collapsed&&u!=t.line&&A(e,0),q(e,new Y(l,u==t.line?t.ch:null,u==r.line?r.ch:null)),++u}),l.collapsed&&e.iter(t.line,r.line+1,function(t){ve(e,t)&&A(t,0)}),l.clearOnEnter&&Ql(l,"beforeCursorEnter",function(){return l.clear()}),l.readOnly&&(j(),(e.history.done.length||e.history.undone.length)&&e.clearHistory()),l.collapsed&&(l.id=++Ns,l.atomic=!0),f){if(a&&(f.curOp.updateMaxLine=!0),l.collapsed)vn(f,t.line,r.line+1);else if(l.className||l.title||l.startStyle||l.endStyle||l.css)for(var h=t.line;h<=r.line;h++)mn(f,h,"text");l.atomic&&Ci(f.doc),bt(f,"markerAdded",f,l)}return l}function ji(e,t,r,n,i){(n=c(n)).shared=!1;var o=[Ki(e,t,r,n,i)],l=o[0],s=n.widgetNode;return $n(e,function(e){s&&(n.widgetNode=s.cloneNode(!0)),o.push(Ki(e,U(e,t),U(e,r),n,i));for(var a=0;a<e.linked.length;++a)if(e.linked[a].isParent)return;l=g(o)}),new As(o,l)}function Xi(e){return e.findMarks(E(e.first,0),e.clipPos(E(e.lastLine())),function(e){return e.parent})}function Yi(e,t){for(var r=0;r<t.length;r++){var n=t[r],i=n.find(),o=e.clipPos(i.from),l=e.clipPos(i.to);if(P(o,l)){var s=Ki(e,o,l,n.primary,n.primary.type);n.markers.push(s),s.parent=n}}}function _i(e){for(var t=0;t<e.length;t++)!function(t){var r=e[t],n=[r.primary.doc];$n(r.primary.doc,function(e){return n.push(e)});for(var i=0;i<r.markers.length;i++){var o=r.markers[i];-1==h(n,o.doc)&&(o.parent=null,r.markers.splice(i--,1))}}(t)}function $i(e){var t=this;if(Qi(t),!Me(t,e)&&!Ft(t.display,e)){We(e),gl&&(Hs=+new Date);var r=Sr(t,e,!0),n=e.dataTransfer.files;if(r&&!t.isReadOnly())if(n&&n.length&&window.FileReader&&window.File)for(var i=n.length,o=Array(i),l=0,s=0;s<i;++s)!function(e,n){if(!t.options.allowDropFileTypes||-1!=h(t.options.allowDropFileTypes,e.type)){var s=new FileReader;s.onload=dn(t,function(){var e=s.result;if(/[\x00-\x08\x0e-\x1f]{2}/.test(e)&&(e=""),o[n]=e,++l==i){var a={from:r=U(t.doc,r),to:r,text:t.doc.splitLines(o.join(t.doc.lineSeparator())),origin:"paste"};Oi(t.doc,a),yi(t.doc,Rn(r,Bn(a)))}}),s.readAsText(e)}}(n[s],s);else{if(t.state.draggingText&&t.doc.sel.contains(r)>-1)return t.state.draggingText(e),void setTimeout(function(){return t.display.input.focus()},20);try{var a=e.dataTransfer.getData("Text");if(a){var u;if(t.state.draggingText&&!t.state.draggingText.copy&&(u=t.listSelections()),wi(t.doc,Rn(r,r)),u)for(var c=0;c<u.length;++c)Ei(t.doc,"",u[c].anchor,u[c].head,"drag");t.replaceSelection(a,"around","paste"),t.display.input.focus()}}catch(e){}}}}function qi(e,t){if(gl&&(!e.state.draggingText||+new Date-Hs<100))Fe(t);else if(!Me(e,t)&&!Ft(e.display,t)&&(t.dataTransfer.setData("Text",e.getSelection()),t.dataTransfer.effectAllowed="copyMove",t.dataTransfer.setDragImage&&!xl)){var r=n("img",null,null,"position: fixed; left: 0; top: 0;");r.src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",wl&&(r.width=r.height=1,e.display.wrapper.appendChild(r),r._top=r.offsetTop),t.dataTransfer.setDragImage(r,0,0),wl&&r.parentNode.removeChild(r)}}function Zi(e,t){var i=Sr(e,t);if(i){var o=document.createDocumentFragment();Mr(e,i,o),e.display.dragCursor||(e.display.dragCursor=n("div",null,"CodeMirror-cursors CodeMirror-dragcursors"),e.display.lineSpace.insertBefore(e.display.dragCursor,e.display.cursorDiv)),r(e.display.dragCursor,o)}}function Qi(e){e.display.dragCursor&&(e.display.lineSpace.removeChild(e.display.dragCursor),e.display.dragCursor=null)}function Ji(e){if(document.getElementsByClassName)for(var t=document.getElementsByClassName("CodeMirror"),r=0;r<t.length;r++){var n=t[r].CodeMirror;n&&e(n)}}function eo(){Fs||(to(),Fs=!0)}function to(){var e;Ql(window,"resize",function(){null==e&&(e=setTimeout(function(){e=null,Ji(ro)},100))}),Ql(window,"blur",function(){return Ji(Fr)})}function ro(e){var t=e.display;t.lastWrapHeight==t.wrapper.clientHeight&&t.lastWrapWidth==t.wrapper.clientWidth||(t.cachedCharWidth=t.cachedTextHeight=t.cachedPaddingH=null,t.scrollbarsClipped=!1,e.setSize())}function no(e){var t=e.split(/-(?!$)/);e=t[t.length-1];for(var r,n,i,o,l=0;l<t.length-1;l++){var s=t[l];if(/^(cmd|meta|m)$/i.test(s))o=!0;else if(/^a(lt)?$/i.test(s))r=!0;else if(/^(c|ctrl|control)$/i.test(s))n=!0;else{if(!/^s(hift)?$/i.test(s))throw new Error("Unrecognized modifier name: "+s);i=!0}}return r&&(e="Alt-"+e),n&&(e="Ctrl-"+e),o&&(e="Cmd-"+e),i&&(e="Shift-"+e),e}function io(e){var t={};for(var r in e)if(e.hasOwnProperty(r)){var n=e[r];if(/^(name|fallthrough|(de|at)tach)$/.test(r))continue;if("..."==n){delete e[r];continue}for(var i=v(r.split(" "),no),o=0;o<i.length;o++){var l=void 0,s=void 0;o==i.length-1?(s=i.join(" "),l=n):(s=i.slice(0,o+1).join(" "),l="...");var a=t[s];if(a){if(a!=l)throw new Error("Inconsistent bindings for "+s)}else t[s]=l}delete e[r]}for(var u in t)e[u]=t[u];return e}function oo(e,t,r,n){var i=(t=uo(t)).call?t.call(e,n):t[e];if(!1===i)return"nothing";if("..."===i)return"multi";if(null!=i&&r(i))return"handled";if(t.fallthrough){if("[object Array]"!=Object.prototype.toString.call(t.fallthrough))return oo(e,t.fallthrough,r,n);for(var o=0;o<t.fallthrough.length;o++){var l=oo(e,t.fallthrough[o],r,n);if(l)return l}}}function lo(e){var t="string"==typeof e?e:Es[e.keyCode];return"Ctrl"==t||"Alt"==t||"Shift"==t||"Mod"==t}function so(e,t,r){var n=e;return t.altKey&&"Alt"!=n&&(e="Alt-"+e),(Dl?t.metaKey:t.ctrlKey)&&"Ctrl"!=n&&(e="Ctrl-"+e),(Dl?t.ctrlKey:t.metaKey)&&"Cmd"!=n&&(e="Cmd-"+e),!r&&t.shiftKey&&"Shift"!=n&&(e="Shift-"+e),e}function ao(e,t){if(wl&&34==e.keyCode&&e.char)return!1;var r=Es[e.keyCode];return null!=r&&!e.altGraphKey&&so(r,e,t)}function uo(e){return"string"==typeof e?Rs[e]:e}function co(e,t){for(var r=e.doc.sel.ranges,n=[],i=0;i<r.length;i++){for(var o=t(r[i]);n.length&&P(o.from,g(n).to)<=0;){var l=n.pop();if(P(l.from,o.from)<0){o.from=l.from;break}}n.push(o)}hn(e,function(){for(var t=n.length-1;t>=0;t--)Ei(e.doc,"",n[t].from,n[t].to,"+delete");jr(e)})}function fo(e,t,r){var n=L(e.text,t+r,r);return n<0||n>e.text.length?null:n}function ho(e,t,r){var n=fo(e,t.ch,r);return null==n?null:new E(t.line,n,r<0?"after":"before")}function po(e,t,r,n,i){if(e){var o=Se(r,t.doc.direction);if(o){var l,s=i<0?g(o):o[0],a=i<0==(1==s.level)?"after":"before";if(s.level>0){var u=Xt(t,r);l=i<0?r.text.length-1:0;var c=Yt(t,u,l).top;l=k(function(e){return Yt(t,u,e).top==c},i<0==(1==s.level)?s.from:s.to-1,l),"before"==a&&(l=fo(r,l,1))}else l=i<0?s.to:s.from;return new E(n,l,a)}}return new E(n,i<0?r.text.length:0,i<0?"before":"after")}function go(e,t,r,n){var i=Se(t,e.doc.direction);if(!i)return ho(t,r,n);r.ch>=t.text.length?(r.ch=t.text.length,r.sticky="before"):r.ch<=0&&(r.ch=0,r.sticky="after");var o=Ce(i,r.ch,r.sticky),l=i[o];if("ltr"==e.doc.direction&&l.level%2==0&&(n>0?l.to>r.ch:l.from<r.ch))return ho(t,r,n);var s,a=function(e,r){return fo(t,e instanceof E?e.ch:e,r)},u=function(r){return e.options.lineWrapping?(s=s||Xt(e,t),hr(e,t,s,r)):{begin:0,end:t.text.length}},c=u("before"==r.sticky?a(r,-1):r.ch);if("rtl"==e.doc.direction||1==l.level){var f=1==l.level==n<0,h=a(r,f?1:-1);if(null!=h&&(f?h<=l.to&&h<=c.end:h>=l.from&&h>=c.begin)){var d=f?"before":"after";return new E(r.line,h,d)}}var p=function(e,t,n){for(var o=function(e,t){return t?new E(r.line,a(e,1),"before"):new E(r.line,e,"after")};e>=0&&e<i.length;e+=t){var l=i[e],s=t>0==(1!=l.level),u=s?n.begin:a(n.end,-1);if(l.from<=u&&u<l.to)return o(u,s);if(u=s?l.from:a(l.to,-1),n.begin<=u&&u<n.end)return o(u,s)}},g=p(o+n,n,c);if(g)return g;var v=n>0?c.end:a(c.begin,-1);return null==v||n>0&&v==t.text.length||!(g=p(n>0?0:i.length-1,n,u(v)))?null:g}function vo(e,t){var r=M(e.doc,t),n=fe(r);return n!=r&&(t=W(n)),po(!0,e,n,t,1)}function mo(e,t){var r=M(e.doc,t),n=he(r);return n!=r&&(t=W(n)),po(!0,e,r,t,-1)}function yo(e,t){var r=vo(e,t.line),n=M(e.doc,r.line),i=Se(n,e.doc.direction);if(!i||0==i[0].level){var o=Math.max(0,n.text.search(/\S/)),l=t.line==r.line&&t.ch<=o&&t.ch;return E(r.line,l?0:o,r.sticky)}return r}function bo(e,t,r){if("string"==typeof t&&!(t=Bs[t]))return!1;e.display.input.ensurePolled();var n=e.display.shift,i=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),r&&(e.display.shift=!1),i=t(e)!=Bl}finally{e.display.shift=n,e.state.suppressEdits=!1}return i}function wo(e,t,r){for(var n=0;n<e.state.keyMaps.length;n++){var i=oo(t,e.state.keyMaps[n],r,e);if(i)return i}return e.options.extraKeys&&oo(t,e.options.extraKeys,r,e)||oo(t,e.options.keyMap,r,e)}function xo(e,t,r,n){var i=e.state.keySeq;if(i){if(lo(t))return"handled";Gs.set(50,function(){e.state.keySeq==i&&(e.state.keySeq=null,e.display.input.reset())}),t=i+" "+t}var o=wo(e,t,n);return"multi"==o&&(e.state.keySeq=t),"handled"==o&&bt(e,"keyHandled",e,t,r),"handled"!=o&&"multi"!=o||(We(r),Ar(e)),i&&!o&&/\'$/.test(t)?(We(r),!0):!!o}function Co(e,t){var r=ao(t,!0);return!!r&&(t.shiftKey&&!e.state.keySeq?xo(e,"Shift-"+r,t,function(t){return bo(e,t,!0)})||xo(e,r,t,function(t){if("string"==typeof t?/^go[A-Z]/.test(t):t.motion)return bo(e,t)}):xo(e,r,t,function(t){return bo(e,t)}))}function So(e,t,r){return xo(e,"'"+r+"'",t,function(t){return bo(e,t,!0)})}function Lo(e){var t=this;if(t.curOp.focus=l(),!Me(t,e)){gl&&vl<11&&27==e.keyCode&&(e.returnValue=!1);var r=e.keyCode;t.display.shift=16==r||e.shiftKey;var n=Co(t,e);wl&&(Us=n?r:null,!n&&88==r&&!rs&&(Ml?e.metaKey:e.ctrlKey)&&t.replaceSelection("",null,"cut")),18!=r||/\bCodeMirror-crosshair\b/.test(t.display.lineDiv.className)||ko(t)}}function ko(e){function t(e){18!=e.keyCode&&e.altKey||(Fl(r,"CodeMirror-crosshair"),ke(document,"keyup",t),ke(document,"mouseover",t))}var r=e.display.lineDiv;s(r,"CodeMirror-crosshair"),Ql(document,"keyup",t),Ql(document,"mouseover",t)}function To(e){16==e.keyCode&&(this.doc.sel.shift=!1),Me(this,e)}function Mo(e){var t=this;if(!(Ft(t.display,e)||Me(t,e)||e.ctrlKey&&!e.altKey||Ml&&e.metaKey)){var r=e.keyCode,n=e.charCode;if(wl&&r==Us)return Us=null,void We(e);if(!wl||e.which&&!(e.which<10)||!Co(t,e)){var i=String.fromCharCode(null==n?r:n);"\b"!=i&&(So(t,e,i)||t.display.input.onKeyPress(e))}}}function No(e,t){var r=+new Date;return js&&js.compare(r,e,t)?(Ks=js=null,"triple"):Ks&&Ks.compare(r,e,t)?(js=new Vs(r,e,t),Ks=null,"double"):(Ks=new Vs(r,e,t),js=null,"single")}function Oo(e){var t=this,r=t.display;if(!(Me(t,e)||r.activeTouch&&r.input.supportsTouch()))if(r.input.ensurePolled(),r.shift=e.shiftKey,Ft(r,e))ml||(r.scroller.draggable=!1,setTimeout(function(){return r.scroller.draggable=!0},100));else if(!zo(t,e)){var n=Sr(t,e),i=Pe(e),o=n?No(n,i):"single";window.focus(),1==i&&t.state.selectingText&&t.state.selectingText(e),n&&Ao(t,i,n,o,e)||(1==i?n?Do(t,n,o,e):Ee(e)==r.scroller&&We(e):2==i?(n&&di(t.doc,n),setTimeout(function(){return r.input.focus()},20)):3==i&&(Hl?Ro(t,e):Dr(t)))}}function Ao(e,t,r,n,i){var o="Click";return"double"==n?o="Double"+o:"triple"==n&&(o="Triple"+o),o=(1==t?"Left":2==t?"Middle":"Right")+o,xo(e,so(o,i),i,function(t){if("string"==typeof t&&(t=Bs[t]),!t)return!1;var n=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),n=t(e,r)!=Bl}finally{e.state.suppressEdits=!1}return n})}function Wo(e,t,r){var n=e.getOption("configureMouse"),i=n?n(e,t,r):{};if(null==i.unit){var o=Nl?r.shiftKey&&r.metaKey:r.altKey;i.unit=o?"rectangle":"single"==t?"char":"double"==t?"word":"line"}return(null==i.extend||e.doc.extend)&&(i.extend=e.doc.extend||r.shiftKey),null==i.addNew&&(i.addNew=Ml?r.metaKey:r.ctrlKey),null==i.moveOnDrag&&(i.moveOnDrag=!(Ml?r.altKey:r.ctrlKey)),i}function Do(e,t,r,n){gl?setTimeout(u(Wr,e),0):e.curOp.focus=l();var i,o=Wo(e,r,n),s=e.doc.sel;e.options.dragDrop&&Jl&&!e.isReadOnly()&&"single"==r&&(i=s.contains(t))>-1&&(P((i=s.ranges[i]).from(),t)<0||t.xRel>0)&&(P(i.to(),t)>0||t.xRel<0)?Ho(e,n,t,o):Eo(e,n,t,o)}function Ho(e,t,r,n){var i=e.display,o=!1,l=dn(e,function(t){ml&&(i.scroller.draggable=!1),e.state.draggingText=!1,ke(document,"mouseup",l),ke(document,"mousemove",s),ke(i.scroller,"dragstart",a),ke(i.scroller,"drop",l),o||(We(t),n.addNew||di(e.doc,r,null,null,n.extend),ml||gl&&9==vl?setTimeout(function(){document.body.focus(),i.input.focus()},20):i.input.focus())}),s=function(e){o=o||Math.abs(t.clientX-e.clientX)+Math.abs(t.clientY-e.clientY)>=10},a=function(){return o=!0};ml&&(i.scroller.draggable=!0),e.state.draggingText=l,l.copy=!n.moveOnDrag,i.scroller.dragDrop&&i.scroller.dragDrop(),Ql(document,"mouseup",l),Ql(document,"mousemove",s),Ql(i.scroller,"dragstart",a),Ql(i.scroller,"drop",l),Dr(e),setTimeout(function(){return i.input.focus()},20)}function Fo(e,t,r){if("char"==r)return new Ts(t,t);if("word"==r)return e.findWordAt(t);if("line"==r)return new Ts(E(t.line,0),U(e.doc,E(t.line+1,0)));var n=r(e,t);return new Ts(n.from,n.to)}function Eo(e,t,r,n){function i(t){if(0!=P(m,t))if(m=t,"rectangle"==n.unit){for(var i=[],o=e.options.tabSize,l=f(M(u,r.line).text,r.ch,o),s=f(M(u,t.line).text,t.ch,o),a=Math.min(l,s),g=Math.max(l,s),v=Math.min(r.line,t.line),y=Math.min(e.lastLine(),Math.max(r.line,t.line));v<=y;v++){var b=M(u,v).text,w=d(b,a,o);a==g?i.push(new Ts(E(v,w),E(v,w))):b.length>w&&i.push(new Ts(E(v,w),E(v,d(b,g,o))))}i.length||i.push(new Ts(r,r)),bi(u,zn(p.ranges.slice(0,h).concat(i),h),{origin:"*mouse",scroll:!1}),e.scrollIntoView(t)}else{var x,C=c,S=Fo(e,t,n.unit),L=C.anchor;P(S.anchor,L)>0?(x=S.head,L=B(C.from(),S.anchor)):(x=S.anchor,L=R(C.to(),S.head));var k=p.ranges.slice(0);k[h]=Po(e,new Ts(U(u,L),x)),bi(u,zn(k,h),Ul)}}function o(t){var r=++b,s=Sr(e,t,!0,"rectangle"==n.unit);if(s)if(0!=P(s,m)){e.curOp.focus=l(),i(s);var c=Ir(a,u);(s.line>=c.to||s.line<c.from)&&setTimeout(dn(e,function(){b==r&&o(t)}),150)}else{var f=t.clientY<y.top?-20:t.clientY>y.bottom?20:0;f&&setTimeout(dn(e,function(){b==r&&(a.scroller.scrollTop+=f,o(t))}),50)}}function s(t){e.state.selectingText=!1,b=1/0,We(t),a.input.focus(),ke(document,"mousemove",w),ke(document,"mouseup",x),u.history.lastSelOrigin=null}var a=e.display,u=e.doc;We(t);var c,h,p=u.sel,g=p.ranges;if(n.addNew&&!n.extend?(h=u.sel.contains(r),c=h>-1?g[h]:new Ts(r,r)):(c=u.sel.primary(),h=u.sel.primIndex),"rectangle"==n.unit)n.addNew||(c=new Ts(r,r)),r=Sr(e,t,!0,!0),h=-1;else{var v=Fo(e,r,n.unit);c=n.extend?hi(c,v.anchor,v.head,n.extend):v}n.addNew?-1==h?(h=g.length,bi(u,zn(g.concat([c]),h),{scroll:!1,origin:"*mouse"})):g.length>1&&g[h].empty()&&"char"==n.unit&&!n.extend?(bi(u,zn(g.slice(0,h).concat(g.slice(h+1)),0),{scroll:!1,origin:"*mouse"}),p=u.sel):gi(u,h,c,Ul):(h=0,bi(u,new ks([c],0),Ul),p=u.sel);var m=r,y=a.wrapper.getBoundingClientRect(),b=0,w=dn(e,function(e){Pe(e)?o(e):s(e)}),x=dn(e,s);e.state.selectingText=x,Ql(document,"mousemove",w),Ql(document,"mouseup",x)}function Po(e,t){var r=t.anchor,n=t.head,i=M(e.doc,r.line);if(0==P(r,n)&&r.sticky==n.sticky)return t;var o=Se(i);if(!o)return t;var l=Ce(o,r.ch,r.sticky),s=o[l];if(s.from!=r.ch&&s.to!=r.ch)return t;var a=l+(s.from==r.ch==(1!=s.level)?0:1);if(0==a||a==o.length)return t;var u;if(n.line!=r.line)u=(n.line-r.line)*("ltr"==e.doc.direction?1:-1)>0;else{var c=Ce(o,n.ch,n.sticky),f=c-l||(n.ch-r.ch)*(1==s.level?-1:1);u=c==a-1||c==a?f<0:f>0}var h=o[a+(u?-1:0)],d=u==(1==h.level),p=d?h.from:h.to,g=d?"after":"before";return r.ch==p&&r.sticky==g?t:new Ts(new E(r.line,p,g),n)}function Io(e,t,r,n){var i,o;if(t.touches)i=t.touches[0].clientX,o=t.touches[0].clientY;else try{i=t.clientX,o=t.clientY}catch(t){return!1}if(i>=Math.floor(e.display.gutters.getBoundingClientRect().right))return!1;n&&We(t);var l=e.display,s=l.lineDiv.getBoundingClientRect();if(o>s.bottom||!Oe(e,r))return He(t);o-=s.top-l.viewOffset;for(var a=0;a<e.options.gutters.length;++a){var u=l.gutters.childNodes[a];if(u&&u.getBoundingClientRect().right>=i)return Te(e,r,e,D(e.doc,o),e.options.gutters[a],t),He(t)}}function zo(e,t){return Io(e,t,"gutterClick",!0)}function Ro(e,t){Ft(e.display,t)||Bo(e,t)||Me(e,t,"contextmenu")||e.display.input.onContextMenu(t)}function Bo(e,t){return!!Oe(e,"gutterContextMenu")&&Io(e,t,"gutterContextMenu",!1)}function Go(e){e.display.wrapper.className=e.display.wrapper.className.replace(/\s*cm-s-\S+/g,"")+e.options.theme.replace(/(^|\s)\s*/g," cm-s-"),er(e)}function Uo(e){Hn(e),vn(e),zr(e)}function Vo(e,t,r){if(!t!=!(r&&r!=Xs)){var n=e.display.dragFunctions,i=t?Ql:ke;i(e.display.scroller,"dragstart",n.start),i(e.display.scroller,"dragenter",n.enter),i(e.display.scroller,"dragover",n.over),i(e.display.scroller,"dragleave",n.leave),i(e.display.scroller,"drop",n.drop)}}function Ko(e){e.options.lineWrapping?(s(e.display.wrapper,"CodeMirror-wrap"),e.display.sizer.style.minWidth="",e.display.sizerWidth=null):(Fl(e.display.wrapper,"CodeMirror-wrap"),we(e)),Cr(e),vn(e),er(e),setTimeout(function(){return en(e)},100)}function jo(e,t){var r=this;if(!(this instanceof jo))return new jo(e,t);this.options=t=t?c(t):{},c(Ys,t,!1),Fn(t);var n=t.value;"string"==typeof n&&(n=new Ds(n,t.mode,null,t.lineSeparator,t.direction)),this.doc=n;var i=new jo.inputStyles[t.inputStyle](this),o=this.display=new T(e,n,i);o.wrapper.CodeMirror=this,Hn(this),Go(this),t.lineWrapping&&(this.display.wrapper.className+=" CodeMirror-wrap"),rn(this),this.state={keyMaps:[],overlays:[],modeGen:0,overwrite:!1,delayingBlurEvent:!1,focused:!1,suppressEdits:!1,pasteIncoming:!1,cutIncoming:!1,selectingText:!1,draggingText:!1,highlight:new Pl,keySeq:null,specialChars:null},t.autofocus&&!Tl&&o.input.focus(),gl&&vl<11&&setTimeout(function(){return r.display.input.reset(!0)},20),Xo(this),eo(),nn(this),this.curOp.forceUpdate=!0,qn(this,n),t.autofocus&&!Tl||this.hasFocus()?setTimeout(u(Hr,this),20):Fr(this);for(var l in _s)_s.hasOwnProperty(l)&&_s[l](r,t[l],Xs);Rr(this),t.finishInit&&t.finishInit(this);for(var s=0;s<$s.length;++s)$s[s](r);on(this),ml&&t.lineWrapping&&"optimizelegibility"==getComputedStyle(o.lineDiv).textRendering&&(o.lineDiv.style.textRendering="auto")}function Xo(e){function t(){i.activeTouch&&(o=setTimeout(function(){return i.activeTouch=null},1e3),(l=i.activeTouch).end=+new Date)}function r(e){if(1!=e.touches.length)return!1;var t=e.touches[0];return t.radiusX<=1&&t.radiusY<=1}function n(e,t){if(null==t.left)return!0;var r=t.left-e.left,n=t.top-e.top;return r*r+n*n>400}var i=e.display;Ql(i.scroller,"mousedown",dn(e,Oo)),gl&&vl<11?Ql(i.scroller,"dblclick",dn(e,function(t){if(!Me(e,t)){var r=Sr(e,t);if(r&&!zo(e,t)&&!Ft(e.display,t)){We(t);var n=e.findWordAt(r);di(e.doc,n.anchor,n.head)}}})):Ql(i.scroller,"dblclick",function(t){return Me(e,t)||We(t)}),Hl||Ql(i.scroller,"contextmenu",function(t){return Ro(e,t)});var o,l={end:0};Ql(i.scroller,"touchstart",function(t){if(!Me(e,t)&&!r(t)&&!zo(e,t)){i.input.ensurePolled(),clearTimeout(o);var n=+new Date;i.activeTouch={start:n,moved:!1,prev:n-l.end<=300?l:null},1==t.touches.length&&(i.activeTouch.left=t.touches[0].pageX,i.activeTouch.top=t.touches[0].pageY)}}),Ql(i.scroller,"touchmove",function(){i.activeTouch&&(i.activeTouch.moved=!0)}),Ql(i.scroller,"touchend",function(r){var o=i.activeTouch;if(o&&!Ft(i,r)&&null!=o.left&&!o.moved&&new Date-o.start<300){var l,s=e.coordsChar(i.activeTouch,"page");l=!o.prev||n(o,o.prev)?new Ts(s,s):!o.prev.prev||n(o,o.prev.prev)?e.findWordAt(s):new Ts(E(s.line,0),U(e.doc,E(s.line+1,0))),e.setSelection(l.anchor,l.head),e.focus(),We(r)}t()}),Ql(i.scroller,"touchcancel",t),Ql(i.scroller,"scroll",function(){i.scroller.clientHeight&&(qr(e,i.scroller.scrollTop),Qr(e,i.scroller.scrollLeft,!0),Te(e,"scroll",e))}),Ql(i.scroller,"mousewheel",function(t){return In(e,t)}),Ql(i.scroller,"DOMMouseScroll",function(t){return In(e,t)}),Ql(i.wrapper,"scroll",function(){return i.wrapper.scrollTop=i.wrapper.scrollLeft=0}),i.dragFunctions={enter:function(t){Me(e,t)||Fe(t)},over:function(t){Me(e,t)||(Zi(e,t),Fe(t))},start:function(t){return qi(e,t)},drop:dn(e,$i),leave:function(t){Me(e,t)||Qi(e)}};var s=i.input.getField();Ql(s,"keyup",function(t){return To.call(e,t)}),Ql(s,"keydown",dn(e,Lo)),Ql(s,"keypress",dn(e,Mo)),Ql(s,"focus",function(t){return Hr(e,t)}),Ql(s,"blur",function(t){return Fr(e,t)})}function Yo(e,t,r,n){var i,o=e.doc;null==r&&(r="add"),"smart"==r&&(o.mode.indent?i=$e(e,t).state:r="prev");var l=e.options.tabSize,s=M(o,t),a=f(s.text,null,l);s.stateAfter&&(s.stateAfter=null);var u,c=s.text.match(/^\s*/)[0];if(n||/\S/.test(s.text)){if("smart"==r&&((u=o.mode.indent(i,s.text.slice(c.length),s.text))==Bl||u>150)){if(!n)return;r="prev"}}else u=0,r="not";"prev"==r?u=t>o.first?f(M(o,t-1).text,null,l):0:"add"==r?u=a+e.options.indentUnit:"subtract"==r?u=a-e.options.indentUnit:"number"==typeof r&&(u=a+r),u=Math.max(0,u);var h="",d=0;if(e.options.indentWithTabs)for(var g=Math.floor(u/l);g;--g)d+=l,h+="\t";if(d<u&&(h+=p(u-d)),h!=c)return Ei(o,h,E(t,0),E(t,c.length),"+input"),s.stateAfter=null,!0;for(var v=0;v<o.sel.ranges.length;v++){var m=o.sel.ranges[v];if(m.head.line==t&&m.head.ch<c.length){var y=E(t,c.length);gi(o,v,new Ts(y,y));break}}}function _o(e){qs=e}function $o(e,t,r,n,i){var o=e.doc;e.display.shift=!1,n||(n=o.sel);var l=e.state.pasteIncoming||"paste"==i,s=es(t),a=null;if(l&&n.ranges.length>1)if(qs&&qs.text.join("\n")==t){if(n.ranges.length%qs.text.length==0){a=[];for(var u=0;u<qs.text.length;u++)a.push(o.splitLines(qs.text[u]))}}else s.length==n.ranges.length&&e.options.pasteLinesPerSelection&&(a=v(s,function(e){return[e]}));for(var c,f=n.ranges.length-1;f>=0;f--){var h=n.ranges[f],d=h.from(),p=h.to();h.empty()&&(r&&r>0?d=E(d.line,d.ch-r):e.state.overwrite&&!l?p=E(p.line,Math.min(M(o,p.line).text.length,p.ch+g(s).length)):qs&&qs.lineWise&&qs.text.join("\n")==t&&(d=p=E(d.line,0))),c=e.curOp.updateInput;var m={from:d,to:p,text:a?a[f%a.length]:s,origin:i||(l?"paste":e.state.cutIncoming?"cut":"+input")};Oi(e.doc,m),bt(e,"inputRead",e,m)}t&&!l&&Zo(e,t),jr(e),e.curOp.updateInput=c,e.curOp.typing=!0,e.state.pasteIncoming=e.state.cutIncoming=!1}function qo(e,t){var r=e.clipboardData&&e.clipboardData.getData("Text");if(r)return e.preventDefault(),t.isReadOnly()||t.options.disableInput||hn(t,function(){return $o(t,r,0,null,"paste")}),!0}function Zo(e,t){if(e.options.electricChars&&e.options.smartIndent)for(var r=e.doc.sel,n=r.ranges.length-1;n>=0;n--){var i=r.ranges[n];if(!(i.head.ch>100||n&&r.ranges[n-1].head.line==i.head.line)){var o=e.getModeAt(i.head),l=!1;if(o.electricChars){for(var s=0;s<o.electricChars.length;s++)if(t.indexOf(o.electricChars.charAt(s))>-1){l=Yo(e,i.head.line,"smart");break}}else o.electricInput&&o.electricInput.test(M(e.doc,i.head.line).text.slice(0,i.head.ch))&&(l=Yo(e,i.head.line,"smart"));l&&bt(e,"electricInput",e,i.head.line)}}}function Qo(e){for(var t=[],r=[],n=0;n<e.doc.sel.ranges.length;n++){var i=e.doc.sel.ranges[n].head.line,o={anchor:E(i,0),head:E(i+1,0)};r.push(o),t.push(e.getRange(o.anchor,o.head))}return{text:t,ranges:r}}function Jo(e,t){e.setAttribute("autocorrect","off"),e.setAttribute("autocapitalize","off"),e.setAttribute("spellcheck",!!t)}function el(){var e=n("textarea",null,null,"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none"),t=n("div",[e],null,"overflow: hidden; position: relative; width: 3px; height: 0px;");return ml?e.style.width="1000px":e.setAttribute("wrap","off"),Ll&&(e.style.border="1px solid black"),Jo(e),t}function tl(e,t,r,n,i){function o(){var n=t.line+r;return!(n<e.first||n>=e.first+e.size)&&(t=new E(n,t.ch,t.sticky),u=M(e,n))}function l(n){var l;if(null==(l=i?go(e.cm,u,t,r):ho(u,t,r))){if(n||!o())return!1;t=po(i,e.cm,u,t.line,r)}else t=l;return!0}var s=t,a=r,u=M(e,t.line);if("char"==n)l();else if("column"==n)l(!0);else if("word"==n||"group"==n)for(var c=null,f="group"==n,h=e.cm&&e.cm.getHelper(t,"wordChars"),d=!0;!(r<0)||l(!d);d=!1){var p=u.text.charAt(t.ch)||"\n",g=x(p,h)?"w":f&&"\n"==p?"n":!f||/\s/.test(p)?null:"p";if(!f||d||g||(g="s"),c&&c!=g){r<0&&(r=1,l(),t.sticky="after");break}if(g&&(c=g),r>0&&!l(!d))break}var v=ki(e,t,s,a,!0);return I(s,v)&&(v.hitSide=!0),v}function rl(e,t,r,n){var i,o=e.doc,l=t.left;if("page"==n){var s=Math.min(e.display.wrapper.clientHeight,window.innerHeight||document.documentElement.clientHeight),a=Math.max(s-.5*mr(e.display),3);i=(r>0?t.bottom:t.top)+r*a}else"line"==n&&(i=r>0?t.bottom+3:t.top-3);for(var u;(u=cr(e,l,i)).outside;){if(r<0?i<=0:i>=o.height){u.hitSide=!0;break}i+=5*r}return u}function nl(e,t){var r=jt(e,t.line);if(!r||r.hidden)return null;var n=M(e.doc,t.line),i=Ut(r,n,t.line),o=Se(n,e.doc.direction),l="left";o&&(l=Ce(o,t.ch)%2?"right":"left");var s=_t(i.map,t.ch,l);return s.offset="right"==s.collapse?s.end:s.start,s}function il(e){for(var t=e;t;t=t.parentNode)if(/CodeMirror-gutter-wrapper/.test(t.className))return!0;return!1}function ol(e,t){return t&&(e.bad=!0),e}function ll(e,t,r,n,i){function o(e){return function(t){return t.id==e}}function l(){c&&(u+=f,c=!1)}function s(e){e&&(l(),u+=e)}function a(t){if(1==t.nodeType){var r=t.getAttribute("cm-text");if(null!=r)return void s(r||t.textContent.replace(/\u200b/g,""));var u,h=t.getAttribute("cm-marker");if(h){var d=e.findMarks(E(n,0),E(i+1,0),o(+h));return void(d.length&&(u=d[0].find(0))&&s(N(e.doc,u.from,u.to).join(f)))}if("false"==t.getAttribute("contenteditable"))return;var p=/^(pre|div|p)$/i.test(t.nodeName);p&&l();for(var g=0;g<t.childNodes.length;g++)a(t.childNodes[g]);p&&(c=!0)}else 3==t.nodeType&&s(t.nodeValue)}for(var u="",c=!1,f=e.doc.lineSeparator();a(t),t!=r;)t=t.nextSibling;return u}function sl(e,t,r){var n;if(t==e.display.lineDiv){if(!(n=e.display.lineDiv.childNodes[r]))return ol(e.clipPos(E(e.display.viewTo-1)),!0);t=null,r=0}else for(n=t;;n=n.parentNode){if(!n||n==e.display.lineDiv)return null;if(n.parentNode&&n.parentNode==e.display.lineDiv)break}for(var i=0;i<e.display.view.length;i++){var o=e.display.view[i];if(o.node==n)return al(o,t,r)}}function al(e,t,r){function n(t,r,n){for(var i=-1;i<(f?f.length:0);i++)for(var o=i<0?c.map:f[i],l=0;l<o.length;l+=3){var s=o[l+2];if(s==t||s==r){var a=W(i<0?e.line:e.rest[i]),u=o[l]+n;return(n<0||s!=t)&&(u=o[l+(n?1:0)]),E(a,u)}}}var i=e.text.firstChild,l=!1;if(!t||!o(i,t))return ol(E(W(e.line),0),!0);if(t==i&&(l=!0,t=i.childNodes[r],r=0,!t)){var s=e.rest?g(e.rest):e.line;return ol(E(W(s),s.text.length),l)}var a=3==t.nodeType?t:null,u=t;for(a||1!=t.childNodes.length||3!=t.firstChild.nodeType||(a=t.firstChild,r&&(r=a.nodeValue.length));u.parentNode!=i;)u=u.parentNode;var c=e.measure,f=c.maps,h=n(a,u,r);if(h)return ol(h,l);for(var d=u.nextSibling,p=a?a.nodeValue.length-r:0;d;d=d.nextSibling){if(h=n(d,d.firstChild,0))return ol(E(h.line,h.ch-p),l);p+=d.textContent.length}for(var v=u.previousSibling,m=r;v;v=v.previousSibling){if(h=n(v,v.firstChild,-1))return ol(E(h.line,h.ch+m),l);m+=v.textContent.length}}var ul=navigator.userAgent,cl=navigator.platform,fl=/gecko\/\d/i.test(ul),hl=/MSIE \d/.test(ul),dl=/Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(ul),pl=/Edge\/(\d+)/.exec(ul),gl=hl||dl||pl,vl=gl&&(hl?document.documentMode||6:+(pl||dl)[1]),ml=!pl&&/WebKit\//.test(ul),yl=ml&&/Qt\/\d+\.\d+/.test(ul),bl=!pl&&/Chrome\//.test(ul),wl=/Opera\//.test(ul),xl=/Apple Computer/.test(navigator.vendor),Cl=/Mac OS X 1\d\D([8-9]|\d\d)\D/.test(ul),Sl=/PhantomJS/.test(ul),Ll=!pl&&/AppleWebKit/.test(ul)&&/Mobile\/\w+/.test(ul),kl=/Android/.test(ul),Tl=Ll||kl||/webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(ul),Ml=Ll||/Mac/.test(cl),Nl=/\bCrOS\b/.test(ul),Ol=/win/i.test(cl),Al=wl&&ul.match(/Version\/(\d*\.\d*)/);Al&&(Al=Number(Al[1])),Al&&Al>=15&&(wl=!1,ml=!0);var Wl,Dl=Ml&&(yl||wl&&(null==Al||Al<12.11)),Hl=fl||gl&&vl>=9,Fl=function(t,r){var n=t.className,i=e(r).exec(n);if(i){var o=n.slice(i.index+i[0].length);t.className=n.slice(0,i.index)+(o?i[1]+o:"")}};Wl=document.createRange?function(e,t,r,n){var i=document.createRange();return i.setEnd(n||e,r),i.setStart(e,t),i}:function(e,t,r){var n=document.body.createTextRange();try{n.moveToElementText(e.parentNode)}catch(e){return n}return n.collapse(!0),n.moveEnd("character",r),n.moveStart("character",t),n};var El=function(e){e.select()};Ll?El=function(e){e.selectionStart=0,e.selectionEnd=e.value.length}:gl&&(El=function(e){try{e.select()}catch(e){}});var Pl=function(){this.id=null};Pl.prototype.set=function(e,t){clearTimeout(this.id),this.id=setTimeout(t,e)};var Il,zl,Rl=30,Bl={toString:function(){return"CodeMirror.Pass"}},Gl={scroll:!1},Ul={origin:"*mouse"},Vl={origin:"+move"},Kl=[""],jl=/[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/,Xl=/[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/,Yl=!1,_l=!1,$l=null,ql=function(){function e(e){return e<=247?r.charAt(e):1424<=e&&e<=1524?"R":1536<=e&&e<=1785?n.charAt(e-1536):1774<=e&&e<=2220?"r":8192<=e&&e<=8203?"w":8204==e?"b":"L"}function t(e,t,r){this.level=e,this.from=t,this.to=r}var r="bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN",n="nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111",i=/[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/,o=/[stwN]/,l=/[LRr]/,s=/[Lb1n]/,a=/[1n]/;return function(r,n){var u="ltr"==n?"L":"R";if(0==r.length||"ltr"==n&&!i.test(r))return!1;for(var c=r.length,f=[],h=0;h<c;++h)f.push(e(r.charCodeAt(h)));for(var d=0,p=u;d<c;++d){var v=f[d];"m"==v?f[d]=p:p=v}for(var m=0,y=u;m<c;++m){var b=f[m];"1"==b&&"r"==y?f[m]="n":l.test(b)&&(y=b,"r"==b&&(f[m]="R"))}for(var w=1,x=f[0];w<c-1;++w){var C=f[w];"+"==C&&"1"==x&&"1"==f[w+1]?f[w]="1":","!=C||x!=f[w+1]||"1"!=x&&"n"!=x||(f[w]=x),x=C}for(var S=0;S<c;++S){var L=f[S];if(","==L)f[S]="N";else if("%"==L){var k=void 0;for(k=S+1;k<c&&"%"==f[k];++k);for(var T=S&&"!"==f[S-1]||k<c&&"1"==f[k]?"1":"N",M=S;M<k;++M)f[M]=T;S=k-1}}for(var N=0,O=u;N<c;++N){var A=f[N];"L"==O&&"1"==A?f[N]="L":l.test(A)&&(O=A)}for(var W=0;W<c;++W)if(o.test(f[W])){var D=void 0;for(D=W+1;D<c&&o.test(f[D]);++D);for(var H="L"==(W?f[W-1]:u),F=H==("L"==(D<c?f[D]:u))?H?"L":"R":u,E=W;E<D;++E)f[E]=F;W=D-1}for(var P,I=[],z=0;z<c;)if(s.test(f[z])){var R=z;for(++z;z<c&&s.test(f[z]);++z);I.push(new t(0,R,z))}else{var B=z,G=I.length;for(++z;z<c&&"L"!=f[z];++z);for(var U=B;U<z;)if(a.test(f[U])){B<U&&I.splice(G,0,new t(1,B,U));var V=U;for(++U;U<z&&a.test(f[U]);++U);I.splice(G,0,new t(2,V,U)),B=U}else++U;B<z&&I.splice(G,0,new t(1,B,z))}return 1==I[0].level&&(P=r.match(/^\s+/))&&(I[0].from=P[0].length,I.unshift(new t(0,0,P[0].length))),1==g(I).level&&(P=r.match(/\s+$/))&&(g(I).to-=P[0].length,I.push(new t(0,c-P[0].length,c))),"rtl"==n?I.reverse():I}}(),Zl=[],Ql=function(e,t,r){if(e.addEventListener)e.addEventListener(t,r,!1);else if(e.attachEvent)e.attachEvent("on"+t,r);else{var n=e._handlers||(e._handlers={});n[t]=(n[t]||Zl).concat(r)}},Jl=function(){if(gl&&vl<9)return!1;var e=n("div");return"draggable"in e||"dragDrop"in e}(),es=3!="\n\nb".split(/\n/).length?function(e){for(var t=0,r=[],n=e.length;t<=n;){var i=e.indexOf("\n",t);-1==i&&(i=e.length);var o=e.slice(t,"\r"==e.charAt(i-1)?i-1:i),l=o.indexOf("\r");-1!=l?(r.push(o.slice(0,l)),t+=l+1):(r.push(o),t=i+1)}return r}:function(e){return e.split(/\r\n?|\n/)},ts=window.getSelection?function(e){try{return e.selectionStart!=e.selectionEnd}catch(e){return!1}}:function(e){var t;try{t=e.ownerDocument.selection.createRange()}catch(e){}return!(!t||t.parentElement()!=e)&&0!=t.compareEndPoints("StartToEnd",t)},rs=function(){var e=n("div");return"oncopy"in e||(e.setAttribute("oncopy","return;"),"function"==typeof e.oncopy)}(),ns=null,is={},os={},ls={},ss=function(e,t,r){this.pos=this.start=0,this.string=e,this.tabSize=t||8,this.lastColumnPos=this.lastColumnValue=0,this.lineStart=0,this.lineOracle=r};ss.prototype.eol=function(){return this.pos>=this.string.length},ss.prototype.sol=function(){return this.pos==this.lineStart},ss.prototype.peek=function(){return this.string.charAt(this.pos)||void 0},ss.prototype.next=function(){if(this.pos<this.string.length)return this.string.charAt(this.pos++)},ss.prototype.eat=function(e){var t=this.string.charAt(this.pos);if("string"==typeof e?t==e:t&&(e.test?e.test(t):e(t)))return++this.pos,t},ss.prototype.eatWhile=function(e){for(var t=this.pos;this.eat(e););return this.pos>t},ss.prototype.eatSpace=function(){for(var e=this,t=this.pos;/[\s\u00a0]/.test(this.string.charAt(this.pos));)++e.pos;return this.pos>t},ss.prototype.skipToEnd=function(){this.pos=this.string.length},ss.prototype.skipTo=function(e){var t=this.string.indexOf(e,this.pos);if(t>-1)return this.pos=t,!0},ss.prototype.backUp=function(e){this.pos-=e},ss.prototype.column=function(){return this.lastColumnPos<this.start&&(this.lastColumnValue=f(this.string,this.start,this.tabSize,this.lastColumnPos,this.lastColumnValue),this.lastColumnPos=this.start),this.lastColumnValue-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.indentation=function(){return f(this.string,null,this.tabSize)-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.match=function(e,t,r){if("string"!=typeof e){var n=this.string.slice(this.pos).match(e);return n&&n.index>0?null:(n&&!1!==t&&(this.pos+=n[0].length),n)}var i=function(e){return r?e.toLowerCase():e};if(i(this.string.substr(this.pos,e.length))==i(e))return!1!==t&&(this.pos+=e.length),!0},ss.prototype.current=function(){return this.string.slice(this.start,this.pos)},ss.prototype.hideFirstChars=function(e,t){this.lineStart+=e;try{return t()}finally{this.lineStart-=e}},ss.prototype.lookAhead=function(e){var t=this.lineOracle;return t&&t.lookAhead(e)};var as=function(e,t){this.state=e,this.lookAhead=t},us=function(e,t,r,n){this.state=t,this.doc=e,this.line=r,this.maxLookAhead=n||0};us.prototype.lookAhead=function(e){var t=this.doc.getLine(this.line+e);return null!=t&&e>this.maxLookAhead&&(this.maxLookAhead=e),t},us.prototype.nextLine=function(){this.line++,this.maxLookAhead>0&&this.maxLookAhead--},us.fromSaved=function(e,t,r){return t instanceof as?new us(e,Ke(e.mode,t.state),r,t.lookAhead):new us(e,Ke(e.mode,t),r)},us.prototype.save=function(e){var t=!1!==e?Ke(this.doc.mode,this.state):this.state;return this.maxLookAhead>0?new as(t,this.maxLookAhead):t};var cs=function(e,t,r){this.start=e.start,this.end=e.pos,this.string=e.current(),this.type=t||null,this.state=r},fs=function(e,t,r){this.text=e,ne(this,t),this.height=r?r(this):1};fs.prototype.lineNo=function(){return W(this)},Ae(fs);var hs,ds={},ps={},gs=null,vs=null,ms={left:0,right:0,top:0,bottom:0},ys=function(e,t,r){this.cm=r;var i=this.vert=n("div",[n("div",null,null,"min-width: 1px")],"CodeMirror-vscrollbar"),o=this.horiz=n("div",[n("div",null,null,"height: 100%; min-height: 1px")],"CodeMirror-hscrollbar");e(i),e(o),Ql(i,"scroll",function(){i.clientHeight&&t(i.scrollTop,"vertical")}),Ql(o,"scroll",function(){o.clientWidth&&t(o.scrollLeft,"horizontal")}),this.checkedZeroWidth=!1,gl&&vl<8&&(this.horiz.style.minHeight=this.vert.style.minWidth="18px")};ys.prototype.update=function(e){var t=e.scrollWidth>e.clientWidth+1,r=e.scrollHeight>e.clientHeight+1,n=e.nativeBarWidth;if(r){this.vert.style.display="block",this.vert.style.bottom=t?n+"px":"0";var i=e.viewHeight-(t?n:0);this.vert.firstChild.style.height=Math.max(0,e.scrollHeight-e.clientHeight+i)+"px"}else this.vert.style.display="",this.vert.firstChild.style.height="0";if(t){this.horiz.style.display="block",this.horiz.style.right=r?n+"px":"0",this.horiz.style.left=e.barLeft+"px";var o=e.viewWidth-e.barLeft-(r?n:0);this.horiz.firstChild.style.width=Math.max(0,e.scrollWidth-e.clientWidth+o)+"px"}else this.horiz.style.display="",this.horiz.firstChild.style.width="0";return!this.checkedZeroWidth&&e.clientHeight>0&&(0==n&&this.zeroWidthHack(),this.checkedZeroWidth=!0),{right:r?n:0,bottom:t?n:0}},ys.prototype.setScrollLeft=function(e){this.horiz.scrollLeft!=e&&(this.horiz.scrollLeft=e),this.disableHoriz&&this.enableZeroWidthBar(this.horiz,this.disableHoriz,"horiz")},ys.prototype.setScrollTop=function(e){this.vert.scrollTop!=e&&(this.vert.scrollTop=e),this.disableVert&&this.enableZeroWidthBar(this.vert,this.disableVert,"vert")},ys.prototype.zeroWidthHack=function(){var e=Ml&&!Cl?"12px":"18px";this.horiz.style.height=this.vert.style.width=e,this.horiz.style.pointerEvents=this.vert.style.pointerEvents="none",this.disableHoriz=new Pl,this.disableVert=new Pl},ys.prototype.enableZeroWidthBar=function(e,t,r){function n(){var i=e.getBoundingClientRect();("vert"==r?document.elementFromPoint(i.right-1,(i.top+i.bottom)/2):document.elementFromPoint((i.right+i.left)/2,i.bottom-1))!=e?e.style.pointerEvents="none":t.set(1e3,n)}e.style.pointerEvents="auto",t.set(1e3,n)},ys.prototype.clear=function(){var e=this.horiz.parentNode;e.removeChild(this.horiz),e.removeChild(this.vert)};var bs=function(){};bs.prototype.update=function(){return{bottom:0,right:0}},bs.prototype.setScrollLeft=function(){},bs.prototype.setScrollTop=function(){},bs.prototype.clear=function(){};var ws={native:ys,null:bs},xs=0,Cs=function(e,t,r){var n=e.display;this.viewport=t,this.visible=Ir(n,e.doc,t),this.editorIsHidden=!n.wrapper.offsetWidth,this.wrapperHeight=n.wrapper.clientHeight,this.wrapperWidth=n.wrapper.clientWidth,this.oldDisplayWidth=Rt(e),this.force=r,this.dims=br(e),this.events=[]};Cs.prototype.signal=function(e,t){Oe(e,t)&&this.events.push(arguments)},Cs.prototype.finish=function(){for(var e=this,t=0;t<this.events.length;t++)Te.apply(null,e.events[t])};var Ss=0,Ls=null;gl?Ls=-.53:fl?Ls=15:bl?Ls=-.7:xl&&(Ls=-1/3);var ks=function(e,t){this.ranges=e,this.primIndex=t};ks.prototype.primary=function(){return this.ranges[this.primIndex]},ks.prototype.equals=function(e){var t=this;if(e==this)return!0;if(e.primIndex!=this.primIndex||e.ranges.length!=this.ranges.length)return!1;for(var r=0;r<this.ranges.length;r++){var n=t.ranges[r],i=e.ranges[r];if(!I(n.anchor,i.anchor)||!I(n.head,i.head))return!1}return!0},ks.prototype.deepCopy=function(){for(var e=this,t=[],r=0;r<this.ranges.length;r++)t[r]=new Ts(z(e.ranges[r].anchor),z(e.ranges[r].head));return new ks(t,this.primIndex)},ks.prototype.somethingSelected=function(){for(var e=this,t=0;t<this.ranges.length;t++)if(!e.ranges[t].empty())return!0;return!1},ks.prototype.contains=function(e,t){var r=this;t||(t=e);for(var n=0;n<this.ranges.length;n++){var i=r.ranges[n];if(P(t,i.from())>=0&&P(e,i.to())<=0)return n}return-1};var Ts=function(e,t){this.anchor=e,this.head=t};Ts.prototype.from=function(){return B(this.anchor,this.head)},Ts.prototype.to=function(){return R(this.anchor,this.head)},Ts.prototype.empty=function(){return this.head.line==this.anchor.line&&this.head.ch==this.anchor.ch},Bi.prototype={chunkSize:function(){return this.lines.length},removeInner:function(e,t){for(var r=this,n=e,i=e+t;n<i;++n){var o=r.lines[n];r.height-=o.height,ot(o),bt(o,"delete")}this.lines.splice(e,t)},collapse:function(e){e.push.apply(e,this.lines)},insertInner:function(e,t,r){var n=this;this.height+=r,this.lines=this.lines.slice(0,e).concat(t).concat(this.lines.slice(e));for(var i=0;i<t.length;++i)t[i].parent=n},iterN:function(e,t,r){for(var n=this,i=e+t;e<i;++e)if(r(n.lines[e]))return!0}},Gi.prototype={chunkSize:function(){return this.size},removeInner:function(e,t){var r=this;this.size-=t;for(var n=0;n<this.children.length;++n){var i=r.children[n],o=i.chunkSize();if(e<o){var l=Math.min(t,o-e),s=i.height;if(i.removeInner(e,l),r.height-=s-i.height,o==l&&(r.children.splice(n--,1),i.parent=null),0==(t-=l))break;e=0}else e-=o}if(this.size-t<25&&(this.children.length>1||!(this.children[0]instanceof Bi))){var a=[];this.collapse(a),this.children=[new Bi(a)],this.children[0].parent=this}},collapse:function(e){for(var t=this,r=0;r<this.children.length;++r)t.children[r].collapse(e)},insertInner:function(e,t,r){var n=this;this.size+=t.length,this.height+=r;for(var i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<=l){if(o.insertInner(e,t,r),o.lines&&o.lines.length>50){for(var s=o.lines.length%25+25,a=s;a<o.lines.length;){var u=new Bi(o.lines.slice(a,a+=25));o.height-=u.height,n.children.splice(++i,0,u),u.parent=n}o.lines=o.lines.slice(0,s),n.maybeSpill()}break}e-=l}},maybeSpill:function(){if(!(this.children.length<=10)){var e=this;do{var t=new Gi(e.children.splice(e.children.length-5,5));if(e.parent){e.size-=t.size,e.height-=t.height;var r=h(e.parent.children,e);e.parent.children.splice(r+1,0,t)}else{var n=new Gi(e.children);n.parent=e,e.children=[n,t],e=n}t.parent=e.parent}while(e.children.length>10);e.parent.maybeSpill()}},iterN:function(e,t,r){for(var n=this,i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<l){var s=Math.min(t,l-e);if(o.iterN(e,s,r))return!0;if(0==(t-=s))break;e=0}else e-=l}}};var Ms=function(e,t,r){var n=this;if(r)for(var i in r)r.hasOwnProperty(i)&&(n[i]=r[i]);this.doc=e,this.node=t};Ms.prototype.clear=function(){var e=this,t=this.doc.cm,r=this.line.widgets,n=this.line,i=W(n);if(null!=i&&r){for(var o=0;o<r.length;++o)r[o]==e&&r.splice(o--,1);r.length||(n.widgets=null);var l=Ht(this);A(n,Math.max(0,n.height-l)),t&&(hn(t,function(){Ui(t,n,-l),mn(t,i,"widget")}),bt(t,"lineWidgetCleared",t,this,i))}},Ms.prototype.changed=function(){var e=this,t=this.height,r=this.doc.cm,n=this.line;this.height=null;var i=Ht(this)-t;i&&(A(n,n.height+i),r&&hn(r,function(){r.curOp.forceUpdate=!0,Ui(r,n,i),bt(r,"lineWidgetChanged",r,e,W(n))}))},Ae(Ms);var Ns=0,Os=function(e,t){this.lines=[],this.type=t,this.doc=e,this.id=++Ns};Os.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){var t=this.doc.cm,r=t&&!t.curOp;if(r&&nn(t),Oe(this,"clear")){var n=this.find();n&&bt(this,"clear",n.from,n.to)}for(var i=null,o=null,l=0;l<this.lines.length;++l){var s=e.lines[l],a=_(s.markedSpans,e);t&&!e.collapsed?mn(t,W(s),"text"):t&&(null!=a.to&&(o=W(s)),null!=a.from&&(i=W(s))),s.markedSpans=$(s.markedSpans,a),null==a.from&&e.collapsed&&!ve(e.doc,s)&&t&&A(s,mr(t.display))}if(t&&this.collapsed&&!t.options.lineWrapping)for(var u=0;u<this.lines.length;++u){var c=fe(e.lines[u]),f=be(c);f>t.display.maxLineLength&&(t.display.maxLine=c,t.display.maxLineLength=f,t.display.maxLineChanged=!0)}null!=i&&t&&this.collapsed&&vn(t,i,o+1),this.lines.length=0,this.explicitlyCleared=!0,this.atomic&&this.doc.cantEdit&&(this.doc.cantEdit=!1,t&&Ci(t.doc)),t&&bt(t,"markerCleared",t,this,i,o),r&&on(t),this.parent&&this.parent.clear()}},Os.prototype.find=function(e,t){var r=this;null==e&&"bookmark"==this.type&&(e=1);for(var n,i,o=0;o<this.lines.length;++o){var l=r.lines[o],s=_(l.markedSpans,r);if(null!=s.from&&(n=E(t?l:W(l),s.from),-1==e))return n;if(null!=s.to&&(i=E(t?l:W(l),s.to),1==e))return i}return n&&{from:n,to:i}},Os.prototype.changed=function(){var e=this,t=this.find(-1,!0),r=this,n=this.doc.cm;t&&n&&hn(n,function(){var i=t.line,o=W(t.line),l=jt(n,o);if(l&&(Qt(l),n.curOp.selectionChanged=n.curOp.forceUpdate=!0),n.curOp.updateMaxLine=!0,!ve(r.doc,i)&&null!=r.height){var s=r.height;r.height=null;var a=Ht(r)-s;a&&A(i,i.height+a)}bt(n,"markerChanged",n,e)})},Os.prototype.attachLine=function(e){if(!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;t.maybeHiddenMarkers&&-1!=h(t.maybeHiddenMarkers,this)||(t.maybeUnhiddenMarkers||(t.maybeUnhiddenMarkers=[])).push(this)}this.lines.push(e)},Os.prototype.detachLine=function(e){if(this.lines.splice(h(this.lines,e),1),!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;(t.maybeHiddenMarkers||(t.maybeHiddenMarkers=[])).push(this)}},Ae(Os);var As=function(e,t){var r=this;this.markers=e,this.primary=t;for(var n=0;n<e.length;++n)e[n].parent=r};As.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){this.explicitlyCleared=!0;for(var t=0;t<this.markers.length;++t)e.markers[t].clear();bt(this,"clear")}},As.prototype.find=function(e,t){return this.primary.find(e,t)},Ae(As);var Ws=0,Ds=function(e,t,r,n,i){if(!(this instanceof Ds))return new Ds(e,t,r,n,i);null==r&&(r=0),Gi.call(this,[new Bi([new fs("",null)])]),this.first=r,this.scrollTop=this.scrollLeft=0,this.cantEdit=!1,this.cleanGeneration=1,this.modeFrontier=this.highlightFrontier=r;var o=E(r,0);this.sel=Rn(o),this.history=new Jn(null),this.id=++Ws,this.modeOption=t,this.lineSep=n,this.direction="rtl"==i?"rtl":"ltr",this.extend=!1,"string"==typeof e&&(e=this.splitLines(e)),_n(this,{from:o,to:o,text:e}),bi(this,Rn(o),Gl)};Ds.prototype=b(Gi.prototype,{constructor:Ds,iter:function(e,t,r){r?this.iterN(e-this.first,t-e,r):this.iterN(this.first,this.first+this.size,e)},insert:function(e,t){for(var r=0,n=0;n<t.length;++n)r+=t[n].height;this.insertInner(e-this.first,t,r)},remove:function(e,t){this.removeInner(e-this.first,t)},getValue:function(e){var t=O(this,this.first,this.first+this.size);return!1===e?t:t.join(e||this.lineSeparator())},setValue:gn(function(e){var t=E(this.first,0),r=this.first+this.size-1;Oi(this,{from:t,to:E(r,M(this,r).text.length),text:this.splitLines(e),origin:"setValue",full:!0},!0),this.cm&&Xr(this.cm,0,0),bi(this,Rn(t),Gl)}),replaceRange:function(e,t,r,n){Ei(this,e,t=U(this,t),r=r?U(this,r):t,n)},getRange:function(e,t,r){var n=N(this,U(this,e),U(this,t));return!1===r?n:n.join(r||this.lineSeparator())},getLine:function(e){var t=this.getLineHandle(e);return t&&t.text},getLineHandle:function(e){if(H(this,e))return M(this,e)},getLineNumber:function(e){return W(e)},getLineHandleVisualStart:function(e){return"number"==typeof e&&(e=M(this,e)),fe(e)},lineCount:function(){return this.size},firstLine:function(){return this.first},lastLine:function(){return this.first+this.size-1},clipPos:function(e){return U(this,e)},getCursor:function(e){var t=this.sel.primary();return null==e||"head"==e?t.head:"anchor"==e?t.anchor:"end"==e||"to"==e||!1===e?t.to():t.from()},listSelections:function(){return this.sel.ranges},somethingSelected:function(){return this.sel.somethingSelected()},setCursor:gn(function(e,t,r){vi(this,U(this,"number"==typeof e?E(e,t||0):e),null,r)}),setSelection:gn(function(e,t,r){vi(this,U(this,e),U(this,t||e),r)}),extendSelection:gn(function(e,t,r){di(this,U(this,e),t&&U(this,t),r)}),extendSelections:gn(function(e,t){pi(this,K(this,e),t)}),extendSelectionsBy:gn(function(e,t){pi(this,K(this,v(this.sel.ranges,e)),t)}),setSelections:gn(function(e,t,r){var n=this;if(e.length){for(var i=[],o=0;o<e.length;o++)i[o]=new Ts(U(n,e[o].anchor),U(n,e[o].head));null==t&&(t=Math.min(e.length-1,this.sel.primIndex)),bi(this,zn(i,t),r)}}),addSelection:gn(function(e,t,r){var n=this.sel.ranges.slice(0);n.push(new Ts(U(this,e),U(this,t||e))),bi(this,zn(n,n.length-1),r)}),getSelection:function(e){for(var t,r=this,n=this.sel.ranges,i=0;i<n.length;i++){var o=N(r,n[i].from(),n[i].to());t=t?t.concat(o):o}return!1===e?t:t.join(e||this.lineSeparator())},getSelections:function(e){for(var t=this,r=[],n=this.sel.ranges,i=0;i<n.length;i++){var o=N(t,n[i].from(),n[i].to());!1!==e&&(o=o.join(e||t.lineSeparator())),r[i]=o}return r},replaceSelection:function(e,t,r){for(var n=[],i=0;i<this.sel.ranges.length;i++)n[i]=e;this.replaceSelections(n,t,r||"+input")},replaceSelections:gn(function(e,t,r){for(var n=this,i=[],o=this.sel,l=0;l<o.ranges.length;l++){var s=o.ranges[l];i[l]={from:s.from(),to:s.to(),text:n.splitLines(e[l]),origin:r}}for(var a=t&&"end"!=t&&Kn(this,i,t),u=i.length-1;u>=0;u--)Oi(n,i[u]);a?yi(this,a):this.cm&&jr(this.cm)}),undo:gn(function(){Wi(this,"undo")}),redo:gn(function(){Wi(this,"redo")}),undoSelection:gn(function(){Wi(this,"undo",!0)}),redoSelection:gn(function(){Wi(this,"redo",!0)}),setExtending:function(e){this.extend=e},getExtending:function(){return this.extend},historySize:function(){for(var e=this.history,t=0,r=0,n=0;n<e.done.length;n++)e.done[n].ranges||++t;for(var i=0;i<e.undone.length;i++)e.undone[i].ranges||++r;return{undo:t,redo:r}},clearHistory:function(){this.history=new Jn(this.history.maxGeneration)},markClean:function(){this.cleanGeneration=this.changeGeneration(!0)},changeGeneration:function(e){return e&&(this.history.lastOp=this.history.lastSelOp=this.history.lastOrigin=null),this.history.generation},isClean:function(e){return this.history.generation==(e||this.cleanGeneration)},getHistory:function(){return{done:fi(this.history.done),undone:fi(this.history.undone)}},setHistory:function(e){var t=this.history=new Jn(this.history.maxGeneration);t.done=fi(e.done.slice(0),null,!0),t.undone=fi(e.undone.slice(0),null,!0)},setGutterMarker:gn(function(e,t,r){return Ri(this,e,"gutter",function(e){var n=e.gutterMarkers||(e.gutterMarkers={});return n[t]=r,!r&&C(n)&&(e.gutterMarkers=null),!0})}),clearGutter:gn(function(e){var t=this;this.iter(function(r){r.gutterMarkers&&r.gutterMarkers[e]&&Ri(t,r,"gutter",function(){return r.gutterMarkers[e]=null,C(r.gutterMarkers)&&(r.gutterMarkers=null),!0})})}),lineInfo:function(e){var t;if("number"==typeof e){if(!H(this,e))return null;if(t=e,!(e=M(this,e)))return null}else if(null==(t=W(e)))return null;return{line:t,handle:e,text:e.text,gutterMarkers:e.gutterMarkers,textClass:e.textClass,bgClass:e.bgClass,wrapClass:e.wrapClass,widgets:e.widgets}},addLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass";if(t[i]){if(e(n).test(t[i]))return!1;t[i]+=" "+n}else t[i]=n;return!0})}),removeLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass",o=t[i];if(!o)return!1;if(null==n)t[i]=null;else{var l=o.match(e(n));if(!l)return!1;var s=l.index+l[0].length;t[i]=o.slice(0,l.index)+(l.index&&s!=o.length?" ":"")+o.slice(s)||null}return!0})}),addLineWidget:gn(function(e,t,r){return Vi(this,e,t,r)}),removeLineWidget:function(e){e.clear()},markText:function(e,t,r){return Ki(this,U(this,e),U(this,t),r,r&&r.type||"range")},setBookmark:function(e,t){var r={replacedWith:t&&(null==t.nodeType?t.widget:t),insertLeft:t&&t.insertLeft,clearWhenEmpty:!1,shared:t&&t.shared,handleMouseEvents:t&&t.handleMouseEvents};return e=U(this,e),Ki(this,e,e,r,"bookmark")},findMarksAt:function(e){var t=[],r=M(this,(e=U(this,e)).line).markedSpans;if(r)for(var n=0;n<r.length;++n){var i=r[n];(null==i.from||i.from<=e.ch)&&(null==i.to||i.to>=e.ch)&&t.push(i.marker.parent||i.marker)}return t},findMarks:function(e,t,r){e=U(this,e),t=U(this,t);var n=[],i=e.line;return this.iter(e.line,t.line+1,function(o){var l=o.markedSpans;if(l)for(var s=0;s<l.length;s++){var a=l[s];null!=a.to&&i==e.line&&e.ch>=a.to||null==a.from&&i!=e.line||null!=a.from&&i==t.line&&a.from>=t.ch||r&&!r(a.marker)||n.push(a.marker.parent||a.marker)}++i}),n},getAllMarks:function(){var e=[];return this.iter(function(t){var r=t.markedSpans;if(r)for(var n=0;n<r.length;++n)null!=r[n].from&&e.push(r[n].marker)}),e},posFromIndex:function(e){var t,r=this.first,n=this.lineSeparator().length;return this.iter(function(i){var o=i.text.length+n;if(o>e)return t=e,!0;e-=o,++r}),U(this,E(r,t))},indexFromPos:function(e){var t=(e=U(this,e)).ch;if(e.line<this.first||e.ch<0)return 0;var r=this.lineSeparator().length;return this.iter(this.first,e.line,function(e){t+=e.text.length+r}),t},copy:function(e){var t=new Ds(O(this,this.first,this.first+this.size),this.modeOption,this.first,this.lineSep,this.direction);return t.scrollTop=this.scrollTop,t.scrollLeft=this.scrollLeft,t.sel=this.sel,t.extend=!1,e&&(t.history.undoDepth=this.history.undoDepth,t.setHistory(this.getHistory())),t},linkedDoc:function(e){e||(e={});var t=this.first,r=this.first+this.size;null!=e.from&&e.from>t&&(t=e.from),null!=e.to&&e.to<r&&(r=e.to);var n=new Ds(O(this,t,r),e.mode||this.modeOption,t,this.lineSep,this.direction);return e.sharedHist&&(n.history=this.history),(this.linked||(this.linked=[])).push({doc:n,sharedHist:e.sharedHist}),n.linked=[{doc:this,isParent:!0,sharedHist:e.sharedHist}],Yi(n,Xi(this)),n},unlinkDoc:function(e){var t=this;if(e instanceof jo&&(e=e.doc),this.linked)for(var r=0;r<this.linked.length;++r)if(t.linked[r].doc==e){t.linked.splice(r,1),e.unlinkDoc(t),_i(Xi(t));break}if(e.history==this.history){var n=[e.id];$n(e,function(e){return n.push(e.id)},!0),e.history=new Jn(null),e.history.done=fi(this.history.done,n),e.history.undone=fi(this.history.undone,n)}},iterLinkedDocs:function(e){$n(this,e)},getMode:function(){return this.mode},getEditor:function(){return this.cm},splitLines:function(e){return this.lineSep?e.split(this.lineSep):es(e)},lineSeparator:function(){return this.lineSep||"\n"},setDirection:gn(function(e){"rtl"!=e&&(e="ltr"),e!=this.direction&&(this.direction=e,this.iter(function(e){return e.order=null}),this.cm&&Qn(this.cm))})}),Ds.prototype.eachLine=Ds.prototype.iter;for(var Hs=0,Fs=!1,Es={3:"Enter",8:"Backspace",9:"Tab",13:"Enter",16:"Shift",17:"Ctrl",18:"Alt",19:"Pause",20:"CapsLock",27:"Esc",32:"Space",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"Left",38:"Up",39:"Right",40:"Down",44:"PrintScrn",45:"Insert",46:"Delete",59:";",61:"=",91:"Mod",92:"Mod",93:"Mod",106:"*",107:"=",109:"-",110:".",111:"/",127:"Delete",173:"-",186:";",187:"=",188:",",189:"-",190:".",191:"/",192:"`",219:"[",220:"\\",221:"]",222:"'",63232:"Up",63233:"Down",63234:"Left",63235:"Right",63272:"Delete",63273:"Home",63275:"End",63276:"PageUp",63277:"PageDown",63302:"Insert"},Ps=0;Ps<10;Ps++)Es[Ps+48]=Es[Ps+96]=String(Ps);for(var Is=65;Is<=90;Is++)Es[Is]=String.fromCharCode(Is);for(var zs=1;zs<=12;zs++)Es[zs+111]=Es[zs+63235]="F"+zs;var Rs={};Rs.basic={Left:"goCharLeft",Right:"goCharRight",Up:"goLineUp",Down:"goLineDown",End:"goLineEnd",Home:"goLineStartSmart",PageUp:"goPageUp",PageDown:"goPageDown",Delete:"delCharAfter",Backspace:"delCharBefore","Shift-Backspace":"delCharBefore",Tab:"defaultTab","Shift-Tab":"indentAuto",Enter:"newlineAndIndent",Insert:"toggleOverwrite",Esc:"singleSelection"},Rs.pcDefault={"Ctrl-A":"selectAll","Ctrl-D":"deleteLine","Ctrl-Z":"undo","Shift-Ctrl-Z":"redo","Ctrl-Y":"redo","Ctrl-Home":"goDocStart","Ctrl-End":"goDocEnd","Ctrl-Up":"goLineUp","Ctrl-Down":"goLineDown","Ctrl-Left":"goGroupLeft","Ctrl-Right":"goGroupRight","Alt-Left":"goLineStart","Alt-Right":"goLineEnd","Ctrl-Backspace":"delGroupBefore","Ctrl-Delete":"delGroupAfter","Ctrl-S":"save","Ctrl-F":"find","Ctrl-G":"findNext","Shift-Ctrl-G":"findPrev","Shift-Ctrl-F":"replace","Shift-Ctrl-R":"replaceAll","Ctrl-[":"indentLess","Ctrl-]":"indentMore","Ctrl-U":"undoSelection","Shift-Ctrl-U":"redoSelection","Alt-U":"redoSelection",fallthrough:"basic"},Rs.emacsy={"Ctrl-F":"goCharRight","Ctrl-B":"goCharLeft","Ctrl-P":"goLineUp","Ctrl-N":"goLineDown","Alt-F":"goWordRight","Alt-B":"goWordLeft","Ctrl-A":"goLineStart","Ctrl-E":"goLineEnd","Ctrl-V":"goPageDown","Shift-Ctrl-V":"goPageUp","Ctrl-D":"delCharAfter","Ctrl-H":"delCharBefore","Alt-D":"delWordAfter","Alt-Backspace":"delWordBefore","Ctrl-K":"killLine","Ctrl-T":"transposeChars","Ctrl-O":"openLine"},Rs.macDefault={"Cmd-A":"selectAll","Cmd-D":"deleteLine","Cmd-Z":"undo","Shift-Cmd-Z":"redo","Cmd-Y":"redo","Cmd-Home":"goDocStart","Cmd-Up":"goDocStart","Cmd-End":"goDocEnd","Cmd-Down":"goDocEnd","Alt-Left":"goGroupLeft","Alt-Right":"goGroupRight","Cmd-Left":"goLineLeft","Cmd-Right":"goLineRight","Alt-Backspace":"delGroupBefore","Ctrl-Alt-Backspace":"delGroupAfter","Alt-Delete":"delGroupAfter","Cmd-S":"save","Cmd-F":"find","Cmd-G":"findNext","Shift-Cmd-G":"findPrev","Cmd-Alt-F":"replace","Shift-Cmd-Alt-F":"replaceAll","Cmd-[":"indentLess","Cmd-]":"indentMore","Cmd-Backspace":"delWrappedLineLeft","Cmd-Delete":"delWrappedLineRight","Cmd-U":"undoSelection","Shift-Cmd-U":"redoSelection","Ctrl-Up":"goDocStart","Ctrl-Down":"goDocEnd",fallthrough:["basic","emacsy"]},Rs.default=Ml?Rs.macDefault:Rs.pcDefault;var Bs={selectAll:Mi,singleSelection:function(e){return e.setSelection(e.getCursor("anchor"),e.getCursor("head"),Gl)},killLine:function(e){return co(e,function(t){if(t.empty()){var r=M(e.doc,t.head.line).text.length;return t.head.ch==r&&t.head.line<e.lastLine()?{from:t.head,to:E(t.head.line+1,0)}:{from:t.head,to:E(t.head.line,r)}}return{from:t.from(),to:t.to()}})},deleteLine:function(e){return co(e,function(t){return{from:E(t.from().line,0),to:U(e.doc,E(t.to().line+1,0))}})},delLineLeft:function(e){return co(e,function(e){return{from:E(e.from().line,0),to:e.from()}})},delWrappedLineLeft:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5;return{from:e.coordsChar({left:0,top:r},"div"),to:t.from()}})},delWrappedLineRight:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5,n=e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div");return{from:t.from(),to:n}})},undo:function(e){return e.undo()},redo:function(e){return e.redo()},undoSelection:function(e){return e.undoSelection()},redoSelection:function(e){return e.redoSelection()},goDocStart:function(e){return e.extendSelection(E(e.firstLine(),0))},goDocEnd:function(e){return e.extendSelection(E(e.lastLine()))},goLineStart:function(e){return e.extendSelectionsBy(function(t){return vo(e,t.head.line)},{origin:"+move",bias:1})},goLineStartSmart:function(e){return e.extendSelectionsBy(function(t){return yo(e,t.head)},{origin:"+move",bias:1})},goLineEnd:function(e){return e.extendSelectionsBy(function(t){return mo(e,t.head.line)},{origin:"+move",bias:-1})},goLineRight:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div")},Vl)},goLineLeft:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:0,top:r},"div")},Vl)},goLineLeftSmart:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5,n=e.coordsChar({left:0,top:r},"div");return n.ch<e.getLine(n.line).search(/\S/)?yo(e,t.head):n},Vl)},goLineUp:function(e){return e.moveV(-1,"line")},goLineDown:function(e){return e.moveV(1,"line")},goPageUp:function(e){return e.moveV(-1,"page")},goPageDown:function(e){return e.moveV(1,"page")},goCharLeft:function(e){return e.moveH(-1,"char")},goCharRight:function(e){return e.moveH(1,"char")},goColumnLeft:function(e){return e.moveH(-1,"column")},goColumnRight:function(e){return e.moveH(1,"column")},goWordLeft:function(e){return e.moveH(-1,"word")},goGroupRight:function(e){return e.moveH(1,"group")},goGroupLeft:function(e){return e.moveH(-1,"group")},goWordRight:function(e){return e.moveH(1,"word")},delCharBefore:function(e){return e.deleteH(-1,"char")},delCharAfter:function(e){return e.deleteH(1,"char")},delWordBefore:function(e){return e.deleteH(-1,"word")},delWordAfter:function(e){return e.deleteH(1,"word")},delGroupBefore:function(e){return e.deleteH(-1,"group")},delGroupAfter:function(e){return e.deleteH(1,"group")},indentAuto:function(e){return e.indentSelection("smart")},indentMore:function(e){return e.indentSelection("add")},indentLess:function(e){return e.indentSelection("subtract")},insertTab:function(e){return e.replaceSelection("\t")},insertSoftTab:function(e){for(var t=[],r=e.listSelections(),n=e.options.tabSize,i=0;i<r.length;i++){var o=r[i].from(),l=f(e.getLine(o.line),o.ch,n);t.push(p(n-l%n))}e.replaceSelections(t)},defaultTab:function(e){e.somethingSelected()?e.indentSelection("add"):e.execCommand("insertTab")},transposeChars:function(e){return hn(e,function(){for(var t=e.listSelections(),r=[],n=0;n<t.length;n++)if(t[n].empty()){var i=t[n].head,o=M(e.doc,i.line).text;if(o)if(i.ch==o.length&&(i=new E(i.line,i.ch-1)),i.ch>0)i=new E(i.line,i.ch+1),e.replaceRange(o.charAt(i.ch-1)+o.charAt(i.ch-2),E(i.line,i.ch-2),i,"+transpose");else if(i.line>e.doc.first){var l=M(e.doc,i.line-1).text;l&&(i=new E(i.line,1),e.replaceRange(o.charAt(0)+e.doc.lineSeparator()+l.charAt(l.length-1),E(i.line-1,l.length-1),i,"+transpose"))}r.push(new Ts(i,i))}e.setSelections(r)})},newlineAndIndent:function(e){return hn(e,function(){for(var t=e.listSelections(),r=t.length-1;r>=0;r--)e.replaceRange(e.doc.lineSeparator(),t[r].anchor,t[r].head,"+input");t=e.listSelections();for(var n=0;n<t.length;n++)e.indentLine(t[n].from().line,null,!0);jr(e)})},openLine:function(e){return e.replaceSelection("\n","start")},toggleOverwrite:function(e){return e.toggleOverwrite()}},Gs=new Pl,Us=null,Vs=function(e,t,r){this.time=e,this.pos=t,this.button=r};Vs.prototype.compare=function(e,t,r){return this.time+400>e&&0==P(t,this.pos)&&r==this.button};var Ks,js,Xs={toString:function(){return"CodeMirror.Init"}},Ys={},_s={};jo.defaults=Ys,jo.optionHandlers=_s;var $s=[];jo.defineInitHook=function(e){return $s.push(e)};var qs=null,Zs=function(e){this.cm=e,this.lastAnchorNode=this.lastAnchorOffset=this.lastFocusNode=this.lastFocusOffset=null,this.polling=new Pl,this.composing=null,this.gracePeriod=!1,this.readDOMTimeout=null};Zs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()}),"cut"==e.type&&i.replaceSelection("",null,"cut");else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type&&i.operation(function(){i.setSelections(t.ranges,0,Gl),i.replaceSelection("",null,"cut")})}if(e.clipboardData){e.clipboardData.clearData();var r=qs.text.join("\n");if(e.clipboardData.setData("Text",r),e.clipboardData.getData("Text")==r)return void e.preventDefault()}var l=el(),s=l.firstChild;i.display.lineSpace.insertBefore(l,i.display.lineSpace.firstChild),s.value=qs.text.join("\n");var a=document.activeElement;El(s),setTimeout(function(){i.display.lineSpace.removeChild(l),a.focus(),a==o&&n.showPrimarySelection()},50)}}var r=this,n=this,i=n.cm,o=n.div=e.lineDiv;Jo(o,i.options.spellcheck),Ql(o,"paste",function(e){Me(i,e)||qo(e,i)||vl<=11&&setTimeout(dn(i,function(){return r.updateFromDOM()}),20)}),Ql(o,"compositionstart",function(e){r.composing={data:e.data,done:!1}}),Ql(o,"compositionupdate",function(e){r.composing||(r.composing={data:e.data,done:!1})}),Ql(o,"compositionend",function(e){r.composing&&(e.data!=r.composing.data&&r.readFromDOMSoon(),r.composing.done=!0)}),Ql(o,"touchstart",function(){return n.forceCompositionEnd()}),Ql(o,"input",function(){r.composing||r.readFromDOMSoon()}),Ql(o,"copy",t),Ql(o,"cut",t)},Zs.prototype.prepareSelection=function(){var e=Tr(this.cm,!1);return e.focus=this.cm.state.focused,e},Zs.prototype.showSelection=function(e,t){e&&this.cm.display.view.length&&((e.focus||t)&&this.showPrimarySelection(),this.showMultipleSelections(e))},Zs.prototype.showPrimarySelection=function(){var e=window.getSelection(),t=this.cm,r=t.doc.sel.primary(),n=r.from(),i=r.to();if(t.display.viewTo==t.display.viewFrom||n.line>=t.display.viewTo||i.line<t.display.viewFrom)e.removeAllRanges();else{var o=sl(t,e.anchorNode,e.anchorOffset),l=sl(t,e.focusNode,e.focusOffset);if(!o||o.bad||!l||l.bad||0!=P(B(o,l),n)||0!=P(R(o,l),i)){var s=t.display.view,a=n.line>=t.display.viewFrom&&nl(t,n)||{node:s[0].measure.map[2],offset:0},u=i.line<t.display.viewTo&&nl(t,i);if(!u){var c=s[s.length-1].measure,f=c.maps?c.maps[c.maps.length-1]:c.map;u={node:f[f.length-1],offset:f[f.length-2]-f[f.length-3]}}if(a&&u){var h,d=e.rangeCount&&e.getRangeAt(0);try{h=Wl(a.node,a.offset,u.offset,u.node)}catch(e){}h&&(!fl&&t.state.focused?(e.collapse(a.node,a.offset),h.collapsed||(e.removeAllRanges(),e.addRange(h))):(e.removeAllRanges(),e.addRange(h)),d&&null==e.anchorNode?e.addRange(d):fl&&this.startGracePeriod()),this.rememberSelection()}else e.removeAllRanges()}}},Zs.prototype.startGracePeriod=function(){var e=this;clearTimeout(this.gracePeriod),this.gracePeriod=setTimeout(function(){e.gracePeriod=!1,e.selectionChanged()&&e.cm.operation(function(){return e.cm.curOp.selectionChanged=!0})},20)},Zs.prototype.showMultipleSelections=function(e){r(this.cm.display.cursorDiv,e.cursors),r(this.cm.display.selectionDiv,e.selection)},Zs.prototype.rememberSelection=function(){var e=window.getSelection();this.lastAnchorNode=e.anchorNode,this.lastAnchorOffset=e.anchorOffset,this.lastFocusNode=e.focusNode,this.lastFocusOffset=e.focusOffset},Zs.prototype.selectionInEditor=function(){var e=window.getSelection();if(!e.rangeCount)return!1;var t=e.getRangeAt(0).commonAncestorContainer;return o(this.div,t)},Zs.prototype.focus=function(){"nocursor"!=this.cm.options.readOnly&&(this.selectionInEditor()||this.showSelection(this.prepareSelection(),!0),this.div.focus())},Zs.prototype.blur=function(){this.div.blur()},Zs.prototype.getField=function(){return this.div},Zs.prototype.supportsTouch=function(){return!0},Zs.prototype.receivedFocus=function(){function e(){t.cm.state.focused&&(t.pollSelection(),t.polling.set(t.cm.options.pollInterval,e))}var t=this;this.selectionInEditor()?this.pollSelection():hn(this.cm,function(){return t.cm.curOp.selectionChanged=!0}),this.polling.set(this.cm.options.pollInterval,e)},Zs.prototype.selectionChanged=function(){var e=window.getSelection();return e.anchorNode!=this.lastAnchorNode||e.anchorOffset!=this.lastAnchorOffset||e.focusNode!=this.lastFocusNode||e.focusOffset!=this.lastFocusOffset},Zs.prototype.pollSelection=function(){if(null==this.readDOMTimeout&&!this.gracePeriod&&this.selectionChanged()){var e=window.getSelection(),t=this.cm;if(kl&&bl&&this.cm.options.gutters.length&&il(e.anchorNode))return this.cm.triggerOnKeyDown({type:"keydown",keyCode:8,preventDefault:Math.abs}),this.blur(),void this.focus();if(!this.composing){this.rememberSelection();var r=sl(t,e.anchorNode,e.anchorOffset),n=sl(t,e.focusNode,e.focusOffset);r&&n&&hn(t,function(){bi(t.doc,Rn(r,n),Gl),(r.bad||n.bad)&&(t.curOp.selectionChanged=!0)})}}},Zs.prototype.pollContent=function(){null!=this.readDOMTimeout&&(clearTimeout(this.readDOMTimeout),this.readDOMTimeout=null);var e=this.cm,t=e.display,r=e.doc.sel.primary(),n=r.from(),i=r.to();if(0==n.ch&&n.line>e.firstLine()&&(n=E(n.line-1,M(e.doc,n.line-1).length)),i.ch==M(e.doc,i.line).text.length&&i.line<e.lastLine()&&(i=E(i.line+1,0)),n.line<t.viewFrom||i.line>t.viewTo-1)return!1;var o,l,s;n.line==t.viewFrom||0==(o=Lr(e,n.line))?(l=W(t.view[0].line),s=t.view[0].node):(l=W(t.view[o].line),s=t.view[o-1].node.nextSibling);var a,u,c=Lr(e,i.line);if(c==t.view.length-1?(a=t.viewTo-1,u=t.lineDiv.lastChild):(a=W(t.view[c+1].line)-1,u=t.view[c+1].node.previousSibling),!s)return!1;for(var f=e.doc.splitLines(ll(e,s,u,l,a)),h=N(e.doc,E(l,0),E(a,M(e.doc,a).text.length));f.length>1&&h.length>1;)if(g(f)==g(h))f.pop(),h.pop(),a--;else{if(f[0]!=h[0])break;f.shift(),h.shift(),l++}for(var d=0,p=0,v=f[0],m=h[0],y=Math.min(v.length,m.length);d<y&&v.charCodeAt(d)==m.charCodeAt(d);)++d;for(var b=g(f),w=g(h),x=Math.min(b.length-(1==f.length?d:0),w.length-(1==h.length?d:0));p<x&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)++p;if(1==f.length&&1==h.length&&l==n.line)for(;d&&d>n.ch&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)d--,p++;f[f.length-1]=b.slice(0,b.length-p).replace(/^\u200b+/,""),f[0]=f[0].slice(d).replace(/\u200b+$/,"");var C=E(l,d),S=E(a,h.length?g(h).length-p:0);return f.length>1||f[0]||P(C,S)?(Ei(e.doc,f,C,S,"+input"),!0):void 0},Zs.prototype.ensurePolled=function(){this.forceCompositionEnd()},Zs.prototype.reset=function(){this.forceCompositionEnd()},Zs.prototype.forceCompositionEnd=function(){this.composing&&(clearTimeout(this.readDOMTimeout),this.composing=null,this.updateFromDOM(),this.div.blur(),this.div.focus())},Zs.prototype.readFromDOMSoon=function(){var e=this;null==this.readDOMTimeout&&(this.readDOMTimeout=setTimeout(function(){if(e.readDOMTimeout=null,e.composing){if(!e.composing.done)return;e.composing=null}e.updateFromDOM()},80))},Zs.prototype.updateFromDOM=function(){var e=this;!this.cm.isReadOnly()&&this.pollContent()||hn(this.cm,function(){return vn(e.cm)})},Zs.prototype.setUneditable=function(e){e.contentEditable="false"},Zs.prototype.onKeyPress=function(e){0!=e.charCode&&(e.preventDefault(),this.cm.isReadOnly()||dn(this.cm,$o)(this.cm,String.fromCharCode(null==e.charCode?e.keyCode:e.charCode),0))},Zs.prototype.readOnlyChanged=function(e){this.div.contentEditable=String("nocursor"!=e)},Zs.prototype.onContextMenu=function(){},Zs.prototype.resetPosition=function(){},Zs.prototype.needsContentAttribute=!0;var Qs=function(e){this.cm=e,this.prevInput="",this.pollingFast=!1,this.polling=new Pl,this.hasSelection=!1,this.composing=null};Qs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()});else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type?i.setSelections(t.ranges,null,Gl):(n.prevInput="",l.value=t.text.join("\n"),El(l))}"cut"==e.type&&(i.state.cutIncoming=!0)}}var r=this,n=this,i=this.cm,o=this.wrapper=el(),l=this.textarea=o.firstChild;e.wrapper.insertBefore(o,e.wrapper.firstChild),Ll&&(l.style.width="0px"),Ql(l,"input",function(){gl&&vl>=9&&r.hasSelection&&(r.hasSelection=null),n.poll()}),Ql(l,"paste",function(e){Me(i,e)||qo(e,i)||(i.state.pasteIncoming=!0,n.fastPoll())}),Ql(l,"cut",t),Ql(l,"copy",t),Ql(e.scroller,"paste",function(t){Ft(e,t)||Me(i,t)||(i.state.pasteIncoming=!0,n.focus())}),Ql(e.lineSpace,"selectstart",function(t){Ft(e,t)||We(t)}),Ql(l,"compositionstart",function(){var e=i.getCursor("from");n.composing&&n.composing.range.clear(),n.composing={start:e,range:i.markText(e,i.getCursor("to"),{className:"CodeMirror-composing"})}}),Ql(l,"compositionend",function(){n.composing&&(n.poll(),n.composing.range.clear(),n.composing=null)})},Qs.prototype.prepareSelection=function(){var e=this.cm,t=e.display,r=e.doc,n=Tr(e);if(e.options.moveInputWithCursor){var i=sr(e,r.sel.primary().head,"div"),o=t.wrapper.getBoundingClientRect(),l=t.lineDiv.getBoundingClientRect();n.teTop=Math.max(0,Math.min(t.wrapper.clientHeight-10,i.top+l.top-o.top)),n.teLeft=Math.max(0,Math.min(t.wrapper.clientWidth-10,i.left+l.left-o.left))}return n},Qs.prototype.showSelection=function(e){var t=this.cm.display;r(t.cursorDiv,e.cursors),r(t.selectionDiv,e.selection),null!=e.teTop&&(this.wrapper.style.top=e.teTop+"px",this.wrapper.style.left=e.teLeft+"px")},Qs.prototype.reset=function(e){if(!this.contextMenuPending&&!this.composing){var t=this.cm;if(t.somethingSelected()){this.prevInput="";var r=t.getSelection();this.textarea.value=r,t.state.focused&&El(this.textarea),gl&&vl>=9&&(this.hasSelection=r)}else e||(this.prevInput=this.textarea.value="",gl&&vl>=9&&(this.hasSelection=null))}},Qs.prototype.getField=function(){return this.textarea},Qs.prototype.supportsTouch=function(){return!1},Qs.prototype.focus=function(){if("nocursor"!=this.cm.options.readOnly&&(!Tl||l()!=this.textarea))try{this.textarea.focus()}catch(e){}},Qs.prototype.blur=function(){this.textarea.blur()},Qs.prototype.resetPosition=function(){this.wrapper.style.top=this.wrapper.style.left=0},Qs.prototype.receivedFocus=function(){this.slowPoll()},Qs.prototype.slowPoll=function(){var e=this;this.pollingFast||this.polling.set(this.cm.options.pollInterval,function(){e.poll(),e.cm.state.focused&&e.slowPoll()})},Qs.prototype.fastPoll=function(){function e(){r.poll()||t?(r.pollingFast=!1,r.slowPoll()):(t=!0,r.polling.set(60,e))}var t=!1,r=this;r.pollingFast=!0,r.polling.set(20,e)},Qs.prototype.poll=function(){var e=this,t=this.cm,r=this.textarea,n=this.prevInput;if(this.contextMenuPending||!t.state.focused||ts(r)&&!n&&!this.composing||t.isReadOnly()||t.options.disableInput||t.state.keySeq)return!1;var i=r.value;if(i==n&&!t.somethingSelected())return!1;if(gl&&vl>=9&&this.hasSelection===i||Ml&&/[\uf700-\uf7ff]/.test(i))return t.display.input.reset(),!1;if(t.doc.sel==t.display.selForContextMenu){var o=i.charCodeAt(0);if(8203!=o||n||(n="​"),8666==o)return this.reset(),this.cm.execCommand("undo")}for(var l=0,s=Math.min(n.length,i.length);l<s&&n.charCodeAt(l)==i.charCodeAt(l);)++l;return hn(t,function(){$o(t,i.slice(l),n.length-l,null,e.composing?"*compose":null),i.length>1e3||i.indexOf("\n")>-1?r.value=e.prevInput="":e.prevInput=i,e.composing&&(e.composing.range.clear(),e.composing.range=t.markText(e.composing.start,t.getCursor("to"),{className:"CodeMirror-composing"}))}),!0},Qs.prototype.ensurePolled=function(){this.pollingFast&&this.poll()&&(this.pollingFast=!1)},Qs.prototype.onKeyPress=function(){gl&&vl>=9&&(this.hasSelection=null),this.fastPoll()},Qs.prototype.onContextMenu=function(e){function t(){if(null!=l.selectionStart){var e=i.somethingSelected(),t="​"+(e?l.value:"");l.value="⇚",l.value=t,n.prevInput=e?"":"​",l.selectionStart=1,l.selectionEnd=t.length,o.selForContextMenu=i.doc.sel}}function r(){if(n.contextMenuPending=!1,n.wrapper.style.cssText=c,l.style.cssText=u,gl&&vl<9&&o.scrollbars.setScrollTop(o.scroller.scrollTop=a),null!=l.selectionStart){(!gl||gl&&vl<9)&&t();var e=0,r=function(){o.selForContextMenu==i.doc.sel&&0==l.selectionStart&&l.selectionEnd>0&&"​"==n.prevInput?dn(i,Mi)(i):e++<10?o.detectingSelectAll=setTimeout(r,500):(o.selForContextMenu=null,o.input.reset())};o.detectingSelectAll=setTimeout(r,200)}}var n=this,i=n.cm,o=i.display,l=n.textarea,s=Sr(i,e),a=o.scroller.scrollTop;if(s&&!wl){i.options.resetSelectionOnContextMenu&&-1==i.doc.sel.contains(s)&&dn(i,bi)(i.doc,Rn(s),Gl);var u=l.style.cssText,c=n.wrapper.style.cssText;n.wrapper.style.cssText="position: absolute";var f=n.wrapper.getBoundingClientRect();l.style.cssText="position: absolute; width: 30px; height: 30px;\n      top: "+(e.clientY-f.top-5)+"px; left: "+(e.clientX-f.left-5)+"px;\n      z-index: 1000; background: "+(gl?"rgba(255, 255, 255, .05)":"transparent")+";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";var h;if(ml&&(h=window.scrollY),o.input.focus(),ml&&window.scrollTo(null,h),o.input.reset(),i.somethingSelected()||(l.value=n.prevInput=" "),n.contextMenuPending=!0,o.selForContextMenu=i.doc.sel,clearTimeout(o.detectingSelectAll),gl&&vl>=9&&t(),Hl){Fe(e);var d=function(){ke(window,"mouseup",d),setTimeout(r,20)};Ql(window,"mouseup",d)}else setTimeout(r,50)}},Qs.prototype.readOnlyChanged=function(e){e||this.reset(),this.textarea.disabled="nocursor"==e},Qs.prototype.setUneditable=function(){},Qs.prototype.needsContentAttribute=!1,function(e){function t(t,n,i,o){e.defaults[t]=n,i&&(r[t]=o?function(e,t,r){r!=Xs&&i(e,t,r)}:i)}var r=e.optionHandlers;e.defineOption=t,e.Init=Xs,t("value","",function(e,t){return e.setValue(t)},!0),t("mode",null,function(e,t){e.doc.modeOption=t,jn(e)},!0),t("indentUnit",2,jn,!0),t("indentWithTabs",!1),t("smartIndent",!0),t("tabSize",4,function(e){Xn(e),er(e),vn(e)},!0),t("lineSeparator",null,function(e,t){if(e.doc.lineSep=t,t){var r=[],n=e.doc.first;e.doc.iter(function(e){for(var i=0;;){var o=e.text.indexOf(t,i);if(-1==o)break;i=o+t.length,r.push(E(n,o))}n++});for(var i=r.length-1;i>=0;i--)Ei(e.doc,t,r[i],E(r[i].line,r[i].ch+t.length))}}),t("specialChars",/[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff]/g,function(e,t,r){e.state.specialChars=new RegExp(t.source+(t.test("\t")?"":"|\t"),"g"),r!=Xs&&e.refresh()}),t("specialCharPlaceholder",at,function(e){return e.refresh()},!0),t("electricChars",!0),t("inputStyle",Tl?"contenteditable":"textarea",function(){throw new Error("inputStyle can not (yet) be changed in a running editor")},!0),t("spellcheck",!1,function(e,t){return e.getInputField().spellcheck=t},!0),t("rtlMoveVisually",!Ol),t("wholeLineUpdateBefore",!0),t("theme","default",function(e){Go(e),Uo(e)},!0),t("keyMap","default",function(e,t,r){var n=uo(t),i=r!=Xs&&uo(r);i&&i.detach&&i.detach(e,n),n.attach&&n.attach(e,i||null)}),t("extraKeys",null),t("configureMouse",null),t("lineWrapping",!1,Ko,!0),t("gutters",[],function(e){Fn(e.options),Uo(e)},!0),t("fixedGutter",!0,function(e,t){e.display.gutters.style.left=t?wr(e.display)+"px":"0",e.refresh()},!0),t("coverGutterNextToScrollbar",!1,function(e){return en(e)},!0),t("scrollbarStyle","native",function(e){rn(e),en(e),e.display.scrollbars.setScrollTop(e.doc.scrollTop),e.display.scrollbars.setScrollLeft(e.doc.scrollLeft)},!0),t("lineNumbers",!1,function(e){Fn(e.options),Uo(e)},!0),t("firstLineNumber",1,Uo,!0),t("lineNumberFormatter",function(e){return e},Uo,!0),t("showCursorWhenSelecting",!1,kr,!0),t("resetSelectionOnContextMenu",!0),t("lineWiseCopyCut",!0),t("pasteLinesPerSelection",!0),t("readOnly",!1,function(e,t){"nocursor"==t&&(Fr(e),e.display.input.blur()),e.display.input.readOnlyChanged(t)}),t("disableInput",!1,function(e,t){t||e.display.input.reset()},!0),t("dragDrop",!0,Vo),t("allowDropFileTypes",null),t("cursorBlinkRate",530),t("cursorScrollMargin",0),t("cursorHeight",1,kr,!0),t("singleCursorHeightPerLine",!0,kr,!0),t("workTime",100),t("workDelay",100),t("flattenSpans",!0,Xn,!0),t("addModeClass",!1,Xn,!0),t("pollInterval",100),t("undoDepth",200,function(e,t){return e.doc.history.undoDepth=t}),t("historyEventDelay",1250),t("viewportMargin",10,function(e){return e.refresh()},!0),t("maxHighlightLength",1e4,Xn,!0),t("moveInputWithCursor",!0,function(e,t){t||e.display.input.resetPosition()}),t("tabindex",null,function(e,t){return e.display.input.getField().tabIndex=t||""}),t("autofocus",null),t("direction","ltr",function(e,t){return e.doc.setDirection(t)},!0)}(jo),function(e){var t=e.optionHandlers,r=e.helpers={};e.prototype={constructor:e,focus:function(){window.focus(),this.display.input.focus()},setOption:function(e,r){var n=this.options,i=n[e];n[e]==r&&"mode"!=e||(n[e]=r,t.hasOwnProperty(e)&&dn(this,t[e])(this,r,i),Te(this,"optionChange",this,e))},getOption:function(e){return this.options[e]},getDoc:function(){return this.doc},addKeyMap:function(e,t){this.state.keyMaps[t?"push":"unshift"](uo(e))},removeKeyMap:function(e){for(var t=this.state.keyMaps,r=0;r<t.length;++r)if(t[r]==e||t[r].name==e)return t.splice(r,1),!0},addOverlay:pn(function(t,r){var n=t.token?t:e.getMode(this.options,t);if(n.startState)throw new Error("Overlays may not be stateful.");m(this.state.overlays,{mode:n,modeSpec:t,opaque:r&&r.opaque,priority:r&&r.priority||0},function(e){return e.priority}),this.state.modeGen++,vn(this)}),removeOverlay:pn(function(e){for(var t=this,r=this.state.overlays,n=0;n<r.length;++n){var i=r[n].modeSpec;if(i==e||"string"==typeof e&&i.name==e)return r.splice(n,1),t.state.modeGen++,void vn(t)}}),indentLine:pn(function(e,t,r){"string"!=typeof t&&"number"!=typeof t&&(t=null==t?this.options.smartIndent?"smart":"prev":t?"add":"subtract"),H(this.doc,e)&&Yo(this,e,t,r)}),indentSelection:pn(function(e){for(var t=this,r=this.doc.sel.ranges,n=-1,i=0;i<r.length;i++){var o=r[i];if(o.empty())o.head.line>n&&(Yo(t,o.head.line,e,!0),n=o.head.line,i==t.doc.sel.primIndex&&jr(t));else{var l=o.from(),s=o.to(),a=Math.max(n,l.line);n=Math.min(t.lastLine(),s.line-(s.ch?0:1))+1;for(var u=a;u<n;++u)Yo(t,u,e);var c=t.doc.sel.ranges;0==l.ch&&r.length==c.length&&c[i].from().ch>0&&gi(t.doc,i,new Ts(l,c[i].to()),Gl)}}}),getTokenAt:function(e,t){return Je(this,e,t)},getLineTokens:function(e,t){return Je(this,E(e),t,!0)},getTokenTypeAt:function(e){e=U(this.doc,e);var t,r=_e(this,M(this.doc,e.line)),n=0,i=(r.length-1)/2,o=e.ch;if(0==o)t=r[2];else for(;;){var l=n+i>>1;if((l?r[2*l-1]:0)>=o)i=l;else{if(!(r[2*l+1]<o)){t=r[2*l+2];break}n=l+1}}var s=t?t.indexOf("overlay "):-1;return s<0?t:0==s?null:t.slice(0,s-1)},getModeAt:function(t){var r=this.doc.mode;return r.innerMode?e.innerMode(r,this.getTokenAt(t).state).mode:r},getHelper:function(e,t){return this.getHelpers(e,t)[0]},getHelpers:function(e,t){var n=this,i=[];if(!r.hasOwnProperty(t))return i;var o=r[t],l=this.getModeAt(e);if("string"==typeof l[t])o[l[t]]&&i.push(o[l[t]]);else if(l[t])for(var s=0;s<l[t].length;s++){var a=o[l[t][s]];a&&i.push(a)}else l.helperType&&o[l.helperType]?i.push(o[l.helperType]):o[l.name]&&i.push(o[l.name]);for(var u=0;u<o._global.length;u++){var c=o._global[u];c.pred(l,n)&&-1==h(i,c.val)&&i.push(c.val)}return i},getStateAfter:function(e,t){var r=this.doc;return e=G(r,null==e?r.first+r.size-1:e),$e(this,e+1,t).state},cursorCoords:function(e,t){var r,n=this.doc.sel.primary();return r=null==e?n.head:"object"==typeof e?U(this.doc,e):e?n.from():n.to(),sr(this,r,t||"page")},charCoords:function(e,t){return lr(this,U(this.doc,e),t||"page")},coordsChar:function(e,t){return e=or(this,e,t||"page"),cr(this,e.left,e.top)},lineAtHeight:function(e,t){return e=or(this,{top:e,left:0},t||"page").top,D(this.doc,e+this.display.viewOffset)},heightAtLine:function(e,t,r){var n,i=!1;if("number"==typeof e){var o=this.doc.first+this.doc.size-1;e<this.doc.first?e=this.doc.first:e>o&&(e=o,i=!0),n=M(this.doc,e)}else n=e;return ir(this,n,{top:0,left:0},t||"page",r||i).top+(i?this.doc.height-ye(n):0)},defaultTextHeight:function(){return mr(this.display)},defaultCharWidth:function(){return yr(this.display)},getViewport:function(){return{from:this.display.viewFrom,to:this.display.viewTo}},addWidget:function(e,t,r,n,i){var o=this.display,l=(e=sr(this,U(this.doc,e))).bottom,s=e.left;if(t.style.position="absolute",t.setAttribute("cm-ignore-events","true"),this.display.input.setUneditable(t),o.sizer.appendChild(t),"over"==n)l=e.top;else if("above"==n||"near"==n){var a=Math.max(o.wrapper.clientHeight,this.doc.height),u=Math.max(o.sizer.clientWidth,o.lineSpace.clientWidth);("above"==n||e.bottom+t.offsetHeight>a)&&e.top>t.offsetHeight?l=e.top-t.offsetHeight:e.bottom+t.offsetHeight<=a&&(l=e.bottom),s+t.offsetWidth>u&&(s=u-t.offsetWidth)}t.style.top=l+"px",t.style.left=t.style.right="","right"==i?(s=o.sizer.clientWidth-t.offsetWidth,t.style.right="0px"):("left"==i?s=0:"middle"==i&&(s=(o.sizer.clientWidth-t.offsetWidth)/2),t.style.left=s+"px"),r&&Ur(this,{left:s,top:l,right:s+t.offsetWidth,bottom:l+t.offsetHeight})},triggerOnKeyDown:pn(Lo),triggerOnKeyPress:pn(Mo),triggerOnKeyUp:To,triggerOnMouseDown:pn(Oo),execCommand:function(e){if(Bs.hasOwnProperty(e))return Bs[e].call(null,this)},triggerElectric:pn(function(e){Zo(this,e)}),findPosH:function(e,t,r,n){var i=this,o=1;t<0&&(o=-1,t=-t);for(var l=U(this.doc,e),s=0;s<t&&!(l=tl(i.doc,l,o,r,n)).hitSide;++s);return l},moveH:pn(function(e,t){var r=this;this.extendSelectionsBy(function(n){return r.display.shift||r.doc.extend||n.empty()?tl(r.doc,n.head,e,t,r.options.rtlMoveVisually):e<0?n.from():n.to()},Vl)}),deleteH:pn(function(e,t){var r=this.doc.sel,n=this.doc;r.somethingSelected()?n.replaceSelection("",null,"+delete"):co(this,function(r){var i=tl(n,r.head,e,t,!1);return e<0?{from:i,to:r.head}:{from:r.head,to:i}})}),findPosV:function(e,t,r,n){var i=this,o=1,l=n;t<0&&(o=-1,t=-t);for(var s=U(this.doc,e),a=0;a<t;++a){var u=sr(i,s,"div");if(null==l?l=u.left:u.left=l,(s=rl(i,u,o,r)).hitSide)break}return s},moveV:pn(function(e,t){var r=this,n=this.doc,i=[],o=!this.display.shift&&!n.extend&&n.sel.somethingSelected();if(n.extendSelectionsBy(function(l){if(o)return e<0?l.from():l.to();var s=sr(r,l.head,"div");null!=l.goalColumn&&(s.left=l.goalColumn),i.push(s.left);var a=rl(r,s,e,t);return"page"==t&&l==n.sel.primary()&&Kr(r,lr(r,a,"div").top-s.top),a},Vl),i.length)for(var l=0;l<n.sel.ranges.length;l++)n.sel.ranges[l].goalColumn=i[l]}),findWordAt:function(e){var t=M(this.doc,e.line).text,r=e.ch,n=e.ch;if(t){var i=this.getHelper(e,"wordChars");"before"!=e.sticky&&n!=t.length||!r?++n:--r;for(var o=t.charAt(r),l=x(o,i)?function(e){return x(e,i)}:/\s/.test(o)?function(e){return/\s/.test(e)}:function(e){return!/\s/.test(e)&&!x(e)};r>0&&l(t.charAt(r-1));)--r;for(;n<t.length&&l(t.charAt(n));)++n}return new Ts(E(e.line,r),E(e.line,n))},toggleOverwrite:function(e){null!=e&&e==this.state.overwrite||((this.state.overwrite=!this.state.overwrite)?s(this.display.cursorDiv,"CodeMirror-overwrite"):Fl(this.display.cursorDiv,"CodeMirror-overwrite"),Te(this,"overwriteToggle",this,this.state.overwrite))},hasFocus:function(){return this.display.input.getField()==l()},isReadOnly:function(){return!(!this.options.readOnly&&!this.doc.cantEdit)},scrollTo:pn(function(e,t){Xr(this,e,t)}),getScrollInfo:function(){var e=this.display.scroller;return{left:e.scrollLeft,top:e.scrollTop,height:e.scrollHeight-zt(this)-this.display.barHeight,width:e.scrollWidth-zt(this)-this.display.barWidth,clientHeight:Bt(this),clientWidth:Rt(this)}},scrollIntoView:pn(function(e,t){null==e?(e={from:this.doc.sel.primary().head,to:null},null==t&&(t=this.options.cursorScrollMargin)):"number"==typeof e?e={from:E(e,0),to:null}:null==e.from&&(e={from:e,to:null}),e.to||(e.to=e.from),e.margin=t||0,null!=e.from.line?Yr(this,e):$r(this,e.from,e.to,e.margin)}),setSize:pn(function(e,t){var r=this,n=function(e){return"number"==typeof e||/^\d+$/.test(String(e))?e+"px":e};null!=e&&(this.display.wrapper.style.width=n(e)),null!=t&&(this.display.wrapper.style.height=n(t)),this.options.lineWrapping&&Jt(this);var i=this.display.viewFrom;this.doc.iter(i,this.display.viewTo,function(e){if(e.widgets)for(var t=0;t<e.widgets.length;t++)if(e.widgets[t].noHScroll){mn(r,i,"widget");break}++i}),this.curOp.forceUpdate=!0,Te(this,"refresh",this)}),operation:function(e){return hn(this,e)},startOperation:function(){return nn(this)},endOperation:function(){return on(this)},refresh:pn(function(){var e=this.display.cachedTextHeight;vn(this),this.curOp.forceUpdate=!0,er(this),Xr(this,this.doc.scrollLeft,this.doc.scrollTop),Wn(this),(null==e||Math.abs(e-mr(this.display))>.5)&&Cr(this),Te(this,"refresh",this)}),swapDoc:pn(function(e){var t=this.doc;return t.cm=null,qn(this,e),er(this),this.display.input.reset(),Xr(this,e.scrollLeft,e.scrollTop),this.curOp.forceScroll=!0,bt(this,"swapDoc",this,t),t}),getInputField:function(){return this.display.input.getField()},getWrapperElement:function(){return this.display.wrapper},getScrollerElement:function(){return this.display.scroller},getGutterElement:function(){return this.display.gutters}},Ae(e),e.registerHelper=function(t,n,i){r.hasOwnProperty(t)||(r[t]=e[t]={_global:[]}),r[t][n]=i},e.registerGlobalHelper=function(t,n,i,o){e.registerHelper(t,n,o),r[t]._global.push({pred:i,val:o})}}(jo);var Js="iter insert remove copy getEditor constructor".split(" ");for(var ea in Ds.prototype)Ds.prototype.hasOwnProperty(ea)&&h(Js,ea)<0&&(jo.prototype[ea]=function(e){return function(){return e.apply(this.doc,arguments)}}(Ds.prototype[ea]));return Ae(Ds),jo.inputStyles={textarea:Qs,contenteditable:Zs},jo.defineMode=function(e){jo.defaults.mode||"null"==e||(jo.defaults.mode=e),Be.apply(this,arguments)},jo.defineMIME=function(e,t){os[e]=t},jo.defineMode("null",function(){return{token:function(e){return e.skipToEnd()}}}),jo.defineMIME("text/plain","null"),jo.defineExtension=function(e,t){jo.prototype[e]=t},jo.defineDocExtension=function(e,t){Ds.prototype[e]=t},jo.fromTextArea=function(e,t){function r(){e.value=a.getValue()}if(t=t?c(t):{},t.value=e.value,!t.tabindex&&e.tabIndex&&(t.tabindex=e.tabIndex),!t.placeholder&&e.placeholder&&(t.placeholder=e.placeholder),null==t.autofocus){var n=l();t.autofocus=n==e||null!=e.getAttribute("autofocus")&&n==document.body}var i;if(e.form&&(Ql(e.form,"submit",r),!t.leaveSubmitMethodAlone)){var o=e.form;i=o.submit;try{var s=o.submit=function(){r(),o.submit=i,o.submit(),o.submit=s}}catch(e){}}t.finishInit=function(t){t.save=r,t.getTextArea=function(){return e},t.toTextArea=function(){t.toTextArea=isNaN,r(),e.parentNode.removeChild(t.getWrapperElement()),e.style.display="",e.form&&(ke(e.form,"submit",r),"function"==typeof e.form.submit&&(e.form.submit=i))}},e.style.display="none";var a=jo(function(t){return e.parentNode.insertBefore(t,e.nextSibling)},t);return a},function(e){e.off=ke,e.on=Ql,e.wheelEventPixels=Pn,e.Doc=Ds,e.splitLines=es,e.countColumn=f,e.findColumn=d,e.isWordChar=w,e.Pass=Bl,e.signal=Te,e.Line=fs,e.changeEnd=Bn,e.scrollbarModel=ws,e.Pos=E,e.cmpPos=P,e.modes=is,e.mimeModes=os,e.resolveMode=Ge,e.getMode=Ue,e.modeExtensions=ls,e.extendMode=Ve,e.copyState=Ke,e.startState=Xe,e.innerMode=je,e.commands=Bs,e.keyMap=Rs,e.keyName=ao,e.isModifierKey=lo,e.lookupKey=oo,e.normalizeKeyMap=io,e.StringStream=ss,e.SharedTextMarker=As,e.TextMarker=Os,e.LineWidget=Ms,e.e_preventDefault=We,e.e_stopPropagation=De,e.e_stop=Fe,e.addClass=s,e.contains=o,e.rmClass=Fl,e.keyNames=Es}(jo),jo.version="5.30.0",jo});
      !function(e){"object"==typeof exports&&"object"==typeof module?e(require("../../lib/codemirror")):"function"==typeof define&&define.amd?define(["../../lib/codemirror"],e):e(CodeMirror)}(function(e){"use strict";function t(e,t,n,r,o,a){this.indented=e,this.column=t,this.type=n,this.info=r,this.align=o,this.prev=a}function n(e,n,r,o){var a=e.indented;return e.context&&"statement"==e.context.type&&"statement"!=r&&(a=e.context.indented),e.context=new t(a,n,r,o,null,e.context)}function r(e){var t=e.context.type;return")"!=t&&"]"!=t&&"}"!=t||(e.indented=e.context.indented),e.context=e.context.prev}function o(e,t,n){return"variable"==t.prevToken||"type"==t.prevToken||(!!/\S(?:[^- ]>|[*\]])\s*$|\*$/.test(e.string.slice(0,n))||(!(!t.typeAtEndOfLine||e.column()!=e.indentation())||void 0))}function a(e){for(;;){if(!e||"top"==e.type)return!0;if("}"==e.type&&"namespace"!=e.prev.info)return!1;e=e.prev}}function i(e){for(var t={},n=e.split(" "),r=0;r<n.length;++r)t[n[r]]=!0;return t}function l(e,t){return"function"==typeof e?e(t):e.propertyIsEnumerable(t)}function s(e,t){if(!t.startOfLine)return!1;for(var n,r=null;n=e.peek();){if("\\"==n&&e.match(/^.$/)){r=s;break}if("/"==n&&e.match(/^\/[\/\*]/,!1))break;e.next()}return t.tokenize=r,"meta"}function c(e,t){return"type"==t.prevToken&&"type"}function u(e){return e.eatWhile(/[\w\.']/),"number"}function d(e,t){if(e.backUp(1),e.match(/(R|u8R|uR|UR|LR)/)){var n=e.match(/"([^\s\\()]{0,16})\(/);return!!n&&(t.cpp11RawStringDelim=n[1],t.tokenize=m,m(e,t))}return e.match(/(u8|u|U|L)/)?!!e.match(/["']/,!1)&&"string":(e.next(),!1)}function f(e){var t=/(\w+)::~?(\w+)$/.exec(e);return t&&t[1]==t[2]}function p(e,t){for(var n;null!=(n=e.next());)if('"'==n&&!e.eat('"')){t.tokenize=null;break}return"string"}function m(e,t){var n=t.cpp11RawStringDelim.replace(/[^\w\s]/g,"\\$&");return e.match(new RegExp(".*?\\)"+n+'"'))?t.tokenize=null:e.skipToEnd(),"string"}function h(t,n){function r(e){if(e)for(var t in e)e.hasOwnProperty(t)&&o.push(t)}"string"==typeof t&&(t=[t]);var o=[];r(n.keywords),r(n.types),r(n.builtin),r(n.atoms),o.length&&(n.helperType=t[0],e.registerHelper("hintWords",t[0],o));for(var a=0;a<t.length;++a)e.defineMIME(t[a],n)}function g(e,t){for(var n=!1;!e.eol();){if(!n&&e.match('"""')){t.tokenize=null;break}n="\\"==e.next()&&!n}return"string"}function y(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!e&&!o&&t.match('"')){a=!0;break}if(e&&t.match('"""')){a=!0;break}r=t.next(),!o&&"$"==r&&t.match("{")&&t.skipTo("}"),o=!o&&"\\"==r&&!e}return!a&&e||(n.tokenize=null),"string"}}function x(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!o&&t.match('"')&&("single"==e||t.match('""'))){a=!0;break}if(!o&&t.match("``")){w=x(e),a=!0;break}r=t.next(),o="single"==e&&!o&&"\\"==r}return a&&(n.tokenize=null),"string"}}e.defineMode("clike",function(i,s){function c(e,t){var n=e.next();if(S[n]){var r=S[n](e,t);if(!1!==r)return r}if('"'==n||"'"==n)return t.tokenize=u(n),t.tokenize(e,t);if(D.test(n))return p=n,null;if(L.test(n)){if(e.backUp(1),e.match(I))return"number";e.next()}if("/"==n){if(e.eat("*"))return t.tokenize=d,d(e,t);if(e.eat("/"))return e.skipToEnd(),"comment"}if(F.test(n)){for(;!e.match(/^\/[\/*]/,!1)&&e.eat(F););return"operator"}if(e.eatWhile(z),P)for(;e.match(P);)e.eatWhile(z);var o=e.current();return l(x,o)?(l(w,o)&&(p="newstatement"),l(v,o)&&(m=!0),"keyword"):l(b,o)?"type":l(k,o)?(l(w,o)&&(p="newstatement"),"builtin"):l(_,o)?"atom":"variable"}function u(e){return function(t,n){for(var r,o=!1,a=!1;null!=(r=t.next());){if(r==e&&!o){a=!0;break}o=!o&&"\\"==r}return(a||!o&&!C)&&(n.tokenize=null),"string"}}function d(e,t){for(var n,r=!1;n=e.next();){if("/"==n&&r){t.tokenize=null;break}r="*"==n}return"comment"}function f(e,t){s.typeFirstDefinitions&&e.eol()&&a(t.context)&&(t.typeAtEndOfLine=o(e,t,e.pos))}var p,m,h=i.indentUnit,g=s.statementIndentUnit||h,y=s.dontAlignCalls,x=s.keywords||{},b=s.types||{},k=s.builtin||{},w=s.blockKeywords||{},v=s.defKeywords||{},_=s.atoms||{},S=s.hooks||{},C=s.multiLineStrings,T=!1!==s.indentStatements,M=!1!==s.indentSwitch,P=s.namespaceSeparator,D=s.isPunctuationChar||/[\[\]{}\(\),;\:\.]/,L=s.numberStart||/[\d\.]/,I=s.number||/^(?:0x[a-f\d]+|0b[01]+|(?:\d+\.?\d*|\.\d+)(?:e[-+]?\d+)?)(u|ll?|l|f)?/i,F=s.isOperatorChar||/[+\-*&%=<>!?|\/]/,z=s.isIdentifierChar||/[\w\$_\xa1-\uffff]/;return{startState:function(e){return{tokenize:null,context:new t((e||0)-h,0,"top",null,!1),indented:0,startOfLine:!0,prevToken:null}},token:function(e,t){var i=t.context;if(e.sol()&&(null==i.align&&(i.align=!1),t.indented=e.indentation(),t.startOfLine=!0),e.eatSpace())return f(e,t),null;p=m=null;var l=(t.tokenize||c)(e,t);if("comment"==l||"meta"==l)return l;if(null==i.align&&(i.align=!0),";"==p||":"==p||","==p&&e.match(/^\s*(?:\/\/.*)?$/,!1))for(;"statement"==t.context.type;)r(t);else if("{"==p)n(t,e.column(),"}");else if("["==p)n(t,e.column(),"]");else if("("==p)n(t,e.column(),")");else if("}"==p){for(;"statement"==i.type;)i=r(t);for("}"==i.type&&(i=r(t));"statement"==i.type;)i=r(t)}else p==i.type?r(t):T&&(("}"==i.type||"top"==i.type)&&";"!=p||"statement"==i.type&&"newstatement"==p)&&n(t,e.column(),"statement",e.current());if("variable"==l&&("def"==t.prevToken||s.typeFirstDefinitions&&o(e,t,e.start)&&a(t.context)&&e.match(/^\s*\(/,!1))&&(l="def"),S.token){var u=S.token(e,t,l);void 0!==u&&(l=u)}return"def"==l&&!1===s.styleDefs&&(l="variable"),t.startOfLine=!1,t.prevToken=m?"def":l||p,f(e,t),l},indent:function(t,n){if(t.tokenize!=c&&null!=t.tokenize||t.typeAtEndOfLine)return e.Pass;var r=t.context,o=n&&n.charAt(0);if("statement"==r.type&&"}"==o&&(r=r.prev),s.dontIndentStatements)for(;"statement"==r.type&&s.dontIndentStatements.test(r.info);)r=r.prev;if(S.indent){var a=S.indent(t,r,n);if("number"==typeof a)return a}var i=o==r.type,l=r.prev&&"switch"==r.prev.info;if(s.allmanIndentation&&/[{(]/.test(o)){for(;"top"!=r.type&&"}"!=r.type;)r=r.prev;return r.indented}return"statement"==r.type?r.indented+("{"==o?0:g):!r.align||y&&")"==r.type?")"!=r.type||i?r.indented+(i?0:h)+(i||!l||/^(?:case|default)\b/.test(n)?0:h):r.indented+g:r.column+(i?0:1)},electricInput:M?/^\s*(?:case .*?:|default:|\{\}?|\})$/:/^\s*[{}]$/,blockCommentStart:"/*",blockCommentEnd:"*/",lineComment:"//",fold:"brace"}});var b="auto if break case register continue return default do sizeof static else struct switch extern typedef union for goto while enum const volatile",k="int long char short double float unsigned signed void size_t ptrdiff_t";h(["text/x-csrc","text/x-c","text/x-chdr"],{name:"clike",keywords:i(b),types:i(k+" bool _Complex _Bool float_t double_t intptr_t intmax_t int8_t int16_t int32_t int64_t uintptr_t uintmax_t uint8_t uint16_t uint32_t uint64_t"),blockKeywords:i("case do else for if switch while struct"),defKeywords:i("struct"),typeFirstDefinitions:!0,atoms:i("null true false"),hooks:{"#":s,"*":c},modeProps:{fold:["brace","include"]}}),h(["text/x-c++src","text/x-c++hdr"],{name:"clike",keywords:i(b+" asm dynamic_cast namespace reinterpret_cast try explicit new static_cast typeid catch operator template typename class friend private this using const_cast inline public throw virtual delete mutable protected alignas alignof constexpr decltype nullptr noexcept thread_local final static_assert override"),types:i(k+" bool wchar_t"),blockKeywords:i("catch class do else finally for if struct switch try while"),defKeywords:i("class namespace struct enum union"),typeFirstDefinitions:!0,atoms:i("true false null"),dontIndentStatements:/^template$/,isIdentifierChar:/[\w\$_~\xa1-\uffff]/,hooks:{"#":s,"*":c,u:d,U:d,L:d,R:d,0:u,1:u,2:u,3:u,4:u,5:u,6:u,7:u,8:u,9:u,token:function(e,t,n){if("variable"==n&&"("==e.peek()&&(";"==t.prevToken||null==t.prevToken||"}"==t.prevToken)&&f(e.current()))return"def"}},namespaceSeparator:"::",modeProps:{fold:["brace","include"]}}),h("text/x-java",{name:"clike",keywords:i("abstract assert break case catch class const continue default do else enum extends final finally float for goto if implements import instanceof interface native new package private protected public return static strictfp super switch synchronized this throw throws transient try volatile while @interface"),types:i("byte short int long float double boolean char void Boolean Byte Character Double Float Integer Long Number Object Short String StringBuffer StringBuilder Void"),blockKeywords:i("catch class do else finally for if switch try while"),defKeywords:i("class interface package enum @interface"),typeFirstDefinitions:!0,atoms:i("true false null"),number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,hooks:{"@":function(e){return!e.match("interface",!1)&&(e.eatWhile(/[\w\$_]/),"meta")}},modeProps:{fold:["brace","import"]}}),h("text/x-csharp",{name:"clike",keywords:i("abstract as async await base break case catch checked class const continue default delegate do else enum event explicit extern finally fixed for foreach goto if implicit in interface internal is lock namespace new operator out override params private protected public readonly ref return sealed sizeof stackalloc static struct switch this throw try typeof unchecked unsafe using virtual void volatile while add alias ascending descending dynamic from get global group into join let orderby partial remove select set value var yield"),types:i("Action Boolean Byte Char DateTime DateTimeOffset Decimal Double Func Guid Int16 Int32 Int64 Object SByte Single String Task TimeSpan UInt16 UInt32 UInt64 bool byte char decimal double short int long object sbyte float string ushort uint ulong"),blockKeywords:i("catch class do else finally for foreach if struct switch try while"),defKeywords:i("class interface namespace struct var"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"@":function(e,t){return e.eat('"')?(t.tokenize=p,p(e,t)):(e.eatWhile(/[\w\$_]/),"meta")}}}),h("text/x-scala",{name:"clike",keywords:i("abstract case catch class def do else extends final finally for forSome if implicit import lazy match new null object override package private protected return sealed super this throw trait try type val var while with yield _ assert assume require print println printf readLine readBoolean readByte readShort readChar readInt readLong readFloat readDouble"),types:i("AnyVal App Application Array BufferedIterator BigDecimal BigInt Char Console Either Enumeration Equiv Error Exception Fractional Function IndexedSeq Int Integral Iterable Iterator List Map Numeric Nil NotNull Option Ordered Ordering PartialFunction PartialOrdering Product Proxy Range Responder Seq Serializable Set Specializable Stream StringBuilder StringContext Symbol Throwable Traversable TraversableOnce Tuple Unit Vector Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),multiLineStrings:!0,blockKeywords:i("catch class enum do else finally for forSome if match switch try while"),defKeywords:i("class enum def object package trait type val var"),atoms:i("true false null"),indentStatements:!1,indentSwitch:!1,isOperatorChar:/[+\-*&%=<>!?|\/#:@]/,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return!!e.match('""')&&(t.tokenize=g,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},"=":function(e,n){var r=n.context;return!("}"!=r.type||!r.align||!e.eat(">"))&&(n.context=new t(r.indented,r.column,r.type,r.info,null,r.prev),"operator")}},modeProps:{closeBrackets:{triples:'"'}}}),h("text/x-kotlin",{name:"clike",keywords:i("package as typealias class interface this super val var fun for is in This throw return break continue object if else while do try when !in !is as? file import where by get set abstract enum open inner override private public internal protected catch finally out final vararg reified dynamic companion constructor init sealed field property receiver param sparam lateinit data inline noinline tailrec external annotation crossinline const operator infix suspend"),types:i("Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),intendSwitch:!1,indentStatements:!1,multiLineStrings:!0,number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,blockKeywords:i("catch class do else finally for if where try while enum"),defKeywords:i("class val var object package interface fun"),atoms:i("true false null this"),hooks:{'"':function(e,t){return t.tokenize=y(e.match('""')),t.tokenize(e,t)}},modeProps:{closeBrackets:{triples:'"'}}}),h(["x-shader/x-vertex","x-shader/x-fragment"],{name:"clike",keywords:i("sampler1D sampler2D sampler3D samplerCube sampler1DShadow sampler2DShadow const attribute uniform varying break continue discard return for while do if else struct in out inout"),types:i("float int bool void vec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4 mat2 mat3 mat4"),blockKeywords:i("for while do if else struct"),builtin:i("radians degrees sin cos tan asin acos atan pow exp log exp2 sqrt inversesqrt abs sign floor ceil fract mod min max clamp mix step smoothstep length distance dot cross normalize ftransform faceforward reflect refract matrixCompMult lessThan lessThanEqual greaterThan greaterThanEqual equal notEqual any all not texture1D texture1DProj texture1DLod texture1DProjLod texture2D texture2DProj texture2DLod texture2DProjLod texture3D texture3DProj texture3DLod texture3DProjLod textureCube textureCubeLod shadow1D shadow2D shadow1DProj shadow2DProj shadow1DLod shadow2DLod shadow1DProjLod shadow2DProjLod dFdx dFdy fwidth noise1 noise2 noise3 noise4"),atoms:i("true false gl_FragColor gl_SecondaryColor gl_Normal gl_Vertex gl_MultiTexCoord0 gl_MultiTexCoord1 gl_MultiTexCoord2 gl_MultiTexCoord3 gl_MultiTexCoord4 gl_MultiTexCoord5 gl_MultiTexCoord6 gl_MultiTexCoord7 gl_FogCoord gl_PointCoord gl_Position gl_PointSize gl_ClipVertex gl_FrontColor gl_BackColor gl_FrontSecondaryColor gl_BackSecondaryColor gl_TexCoord gl_FogFragCoord gl_FragCoord gl_FrontFacing gl_FragData gl_FragDepth gl_ModelViewMatrix gl_ProjectionMatrix gl_ModelViewProjectionMatrix gl_TextureMatrix gl_NormalMatrix gl_ModelViewMatrixInverse gl_ProjectionMatrixInverse gl_ModelViewProjectionMatrixInverse gl_TexureMatrixTranspose gl_ModelViewMatrixInverseTranspose gl_ProjectionMatrixInverseTranspose gl_ModelViewProjectionMatrixInverseTranspose gl_TextureMatrixInverseTranspose gl_NormalScale gl_DepthRange gl_ClipPlane gl_Point gl_FrontMaterial gl_BackMaterial gl_LightSource gl_LightModel gl_FrontLightModelProduct gl_BackLightModelProduct gl_TextureColor gl_EyePlaneS gl_EyePlaneT gl_EyePlaneR gl_EyePlaneQ gl_FogParameters gl_MaxLights gl_MaxClipPlanes gl_MaxTextureUnits gl_MaxTextureCoords gl_MaxVertexAttribs gl_MaxVertexUniformComponents gl_MaxVaryingFloats gl_MaxVertexTextureImageUnits gl_MaxTextureImageUnits gl_MaxFragmentUniformComponents gl_MaxCombineTextureImageUnits gl_MaxDrawBuffers"),indentSwitch:!1,hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-nesc",{name:"clike",keywords:i(b+"as atomic async call command component components configuration event generic implementation includes interface module new norace nx_struct nx_union post provides signal task uses abstract extends"),types:i(k),blockKeywords:i("case do else for if switch while struct"),atoms:i("null true false"),hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-objectivec",{name:"clike",keywords:i(b+"inline restrict _Bool _Complex _Imaginary BOOL Class bycopy byref id IMP in inout nil oneway out Protocol SEL self super atomic nonatomic retain copy readwrite readonly"),types:i(k),atoms:i("YES NO NULL NILL ON OFF true false"),hooks:{"@":function(e){return e.eatWhile(/[\w\$]/),"keyword"},"#":s,indent:function(e,t,n){if("statement"==t.type&&/^@\w/.test(n))return t.indented}},modeProps:{fold:"brace"}}),h("text/x-squirrel",{name:"clike",keywords:i("base break clone continue const default delete enum extends function in class foreach local resume return this throw typeof yield constructor instanceof static"),types:i(k),blockKeywords:i("case catch class else for foreach if switch try while"),defKeywords:i("function local class"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"#":s},modeProps:{fold:["brace","include"]}});var w=null;h("text/x-ceylon",{name:"clike",keywords:i("abstracts alias assembly assert assign break case catch class continue dynamic else exists extends finally for function given if import in interface is let module new nonempty object of out outer package return satisfies super switch then this throw try value void while"),types:function(e){var t=e.charAt(0);return t===t.toUpperCase()&&t!==t.toLowerCase()},blockKeywords:i("case catch class dynamic else finally for function if interface module new object switch try while"),defKeywords:i("class dynamic function interface module object package value"),builtin:i("abstract actual aliased annotation by default deprecated doc final formal late license native optional sealed see serializable shared suppressWarnings tagged throws variable"),isPunctuationChar:/[\[\]{}\(\),;\:\.`]/,isOperatorChar:/[+\-*&%=<>!?|^~:\/]/,numberStart:/[\d#$]/,number:/^(?:#[\da-fA-F_]+|\$[01_]+|[\d_]+[kMGTPmunpf]?|[\d_]+\.[\d_]+(?:[eE][-+]?\d+|[kMGTPmunpf]|)|)/i,multiLineStrings:!0,typeFirstDefinitions:!0,atoms:i("true false null larger smaller equal empty finished"),indentSwitch:!1,styleDefs:!1,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return t.tokenize=x(e.match('""')?"triple":"single"),t.tokenize(e,t)},"`":function(e,t){return!(!w||!e.match("`"))&&(t.tokenize=w,w=null,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},token:function(e,t,n){if(("variable"==n||"type"==n)&&"."==t.prevToken)return"variable-2"}},modeProps:{fold:["brace","import"],closeBrackets:{triples:'"'}}})});
      // -------------------------------------------------------------------------
//  Part of the CodeChecker project, under the Apache License v2.0 with
//  LLVM Exceptions. See LICENSE for license information.
//  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
// -------------------------------------------------------------------------

var BugViewer = {
  _files : [],
  _reports : [],
  _lineWidgets : [],
  _navigationMenuItems : [],
  _sourceFileData : null,
  _currentReport : null,
  _lastBugEvent  : null,

  init : function (files, reports) {
    this._files = files;
    this._reports = reports;

    this.initEscapeChars();
  },

  initEscapeChars : function () {
    this.escapeChars = {
      ' ' : 'nbsp',
      '<' : 'lt',
      '>' : 'gt',
      '"' : 'quot',
      '&' : 'amp'
    };

    var regexString = '[';
    for (var key in this.escapeChars) {
      regexString += key;
    }
    regexString += ']';

    this.escapeRegExp = new RegExp( regexString, 'g');
  },

  escapeHTML : function (str) {
    var that = this;

    return str.replace(this.escapeRegExp, function (m) {
      return '&' + that.escapeChars[m] + ';';
    });
  },

  initByUrl : function () {
    if (!this._reports) return;

    var state = {};
    window.location.hash.substr(1).split('&').forEach(function (s) {
      var parts = s.split('=');
      state[parts[0]] = parts[1];
    });

    for (var key in this._reports) {
      var report = this._reports[key];
      if (report.reportHash === state['reportHash']) {
        this.navigate(report);
        return;
      }
    }

    this.navigate(this._reports[0]);
  },

  create : function () {
    this._content = document.getElementById('editor-wrapper');
    this._filepath = document.getElementById('file-path');
    this._checkerName = document.getElementById('checker-name');
    this._reviewStatusWrapper =
      document.getElementById('review-status-wrapper');
    this._reviewStatus = document.getElementById('review-status');
    this._editor = document.getElementById('editor');

    this._codeMirror = CodeMirror(this._editor, {
      mode: 'text/x-c++src',
      matchBrackets : true,
      lineNumbers : true,
      readOnly : true,
      foldGutter : true,
      extraKeys : {},
      viewportMargin : 100
    });

    this._createNavigationMenu();
  },

  navigate : function (report, item) {
    if (!item) {
      var items = this._navigationMenuItems.filter(function (navItem) {
        return navItem.report.reportHash === report.reportHash;
      });

      if (!items.length) return;

      item = items[0].widget;
    }

    this._selectedReport.classList.remove('active');
    this._selectedReport = item;
    this._selectedReport.classList.add('active');
    this.setReport(report);
  },

  _createNavigationMenu : function () {
    var that = this;

    var nav = document.getElementById('report-nav');
    var list = document.createElement('ul');
    this._reports.forEach(function (report) {
      var events = report['events'];
      var lastBugEvent = events[events.length - 1];
      var item = document.createElement('li');

      var severity = document.createElement('i');
      severity.className = 'severity-' + report.severity.toLowerCase();

      item.appendChild(severity);
      item.appendChild(document.createTextNode(lastBugEvent.message));

      item.addEventListener('click', function () {
        that.navigate(report, item);
      })
      list.appendChild(item);
      that._navigationMenuItems.push({ report : report, widget : item });
    });

    if (!this._selectedReport && list.childNodes.length) {
      this._selectedReport = list.childNodes[0];
      this._selectedReport.classList.add('active');
    }

    nav.appendChild(list);
  },

  setReport : function (report) {
    this._currentReport = report;
    var events = report['events'];
    var lastBugEvent = events[events.length - 1];
    this.setCurrentBugEvent(lastBugEvent, events.length - 1);
    this.setCheckerName(report.checkerName);
    this.setReviewStatus(report.reviewStatus);

    window.location.hash = '#reportHash=' + report.reportHash;
  },

  setCurrentBugEvent : function (event, idx) {
    this._currentBugEvent = event;
    this.setSourceFileData(this._files[event.location.file]);
    this.drawBugPath();

    this.jumpTo(event.location.line, 0);
    this.highlightBugEvent(event, idx);
  },

  highlightBugEvent : function (event, idx) {
    this._lineWidgets.forEach(function (widget) {
      var lineIdx = widget.node.getAttribute('idx');
      if (parseInt(lineIdx) === idx) {
        widget.node.classList.add('current');
      }
    });
  },

  setCheckerName : function (checkerName) {
    this._checkerName.innerHTML = checkerName;
  },

  setReviewStatus : function (status) {
    if (status) {
      var className =
        'review-status-' + status.toLowerCase().split(' ').join('-');
      this._reviewStatus.className = "review-status " + className;

      this._reviewStatus.innerHTML = status;
      this._reviewStatusWrapper.style.display = 'block';
    } else {
      this._reviewStatusWrapper.style.display = 'none';
    }
  },

  setSourceFileData : function (file) {
    if (this._sourceFileData && file.id === this._sourceFileData.id) {
      return;
    }

    this._sourceFileData = file;
    this._filepath.innerHTML = file.path;
    this._codeMirror.doc.setValue(file.content);
    this._refresh();
  },

  _refresh : function () {
    var that = this;
    setTimeout(function () {
      var fullHeight = parseInt(that._content.clientHeight);
      var headerHeight = that._filepath.clientHeight;

      that._codeMirror.setSize('auto', fullHeight - headerHeight);
      that._codeMirror.refresh();
    }, 200);
  },

  clearBubbles : function () {
    this._lineWidgets.forEach(function (widget) { widget.clear(); });
    this._lineWidgets = [];
  },

  getMessage : function (event, kind) {
    if (kind === 'macro') {
      var name = 'macro expansion' + (event.name ? ': ' + event.name : '');

      return '<span class="tag macro">' + name + '</span>'
        + this.escapeHTML(event.expansion).replace(/(?:\r\n|\r|\n)/g, '<br>');
    } else if (kind === 'note') {
      return '<span class="tag note">note</span>'
        +  this.escapeHTML(event.message).replace(/(?:\r\n|\r|\n)/g, '<br>');
    }
  },

  addExtraPathEvents : function (events, kind) {
    var that = this;

    if (!events) {
      return;
    }

    events.forEach(function (event) {
      if (event.location.file !== that._currentBugEvent.location.file) {
        return;
      }

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + kind);

      var msg = document.createElement('span');
      msg.innerHTML = that.getMessage(event, kind);
      element.appendChild(msg);

      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  drawBugPath : function () {
    var that = this;

    this.clearBubbles();

    this.addExtraPathEvents(this._currentReport.macros, 'macro');
    this.addExtraPathEvents(this._currentReport.notes, 'note');

    // Processing bug path events.
    var currentEvents = this._currentReport.events;
    currentEvents.forEach(function (event, step) {
      if (event.location.file !== that._currentBugEvent.location.file)
        return;

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';
      var type = step === currentEvents.length - 1 ? 'error' : 'info';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + type);
      element.setAttribute('idx', step);

      var enumeration = document.createElement('span');
      enumeration.setAttribute('class', 'checker-enum ' + type);
      enumeration.innerHTML = step + 1;

      if (currentEvents.length > 1)
        element.appendChild(enumeration);

      var prevBugEvent = step - 1;
      if (step > 0) {
        var prevBug = document.createElement('span');
        prevBug.setAttribute('class', 'arrow left-arrow');
        prevBug.addEventListener('click', function () {
          var event = currentEvents[prevBugEvent];
          that.setCurrentBugEvent(event, prevBugEvent);
        });
        element.appendChild(prevBug);
      }

      var msg = document.createElement('span');
      msg.innerHTML = that.escapeHTML(event.message)
        .replace(/(?:\r\n|\r|\n)/g, '<br>');

      element.appendChild(msg);

      var nextBugEvent = step + 1;
      if (nextBugEvent < currentEvents.length) {
        var nextBug = document.createElement('span');
        nextBug.setAttribute('class', 'arrow right-arrow');
        nextBug.addEventListener('click', function () {
          var event = currentEvents[nextBugEvent];
          that.setCurrentBugEvent(event, nextBugEvent);
        });
        element.appendChild(nextBug);
      }


      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  jumpTo : function (line, column) {
    var that = this;

    setTimeout(function () {
      var selPosPixel
        = that._codeMirror.charCoords({ line : line, ch : column }, 'local');
      var editorSize = {
        width  : that._editor.clientWidth,
        height : that._editor.clientHeight
      };

      that._codeMirror.scrollIntoView({
        top    : selPosPixel.top - 100,
        bottom : selPosPixel.top + editorSize.height - 150,
        left   : selPosPixel.left < editorSize.width - 100
               ? 0
               : selPosPixel.left - 50,
        right  : selPosPixel.left < editorSize.width - 100
               ? 10
               : selPosPixel.left + editorSize.width - 100
      });
    }, 0);
  }
}


      var data = {"files": {"0": {"id": 0, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/APValue.h", "content": "//===--- APValue.h - Union class for APFloat/APSInt/Complex -----*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n//  This file defines the APValue class.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_AST_APVALUE_H\n#define LLVM_CLANG_AST_APVALUE_H\n\n#include \"clang/Basic/LLVM.h\"\n#include \"llvm/ADT/APFixedPoint.h\"\n#include \"llvm/ADT/APFloat.h\"\n#include \"llvm/ADT/APSInt.h\"\n#include \"llvm/ADT/FoldingSet.h\"\n#include \"llvm/ADT/PointerIntPair.h\"\n#include \"llvm/ADT/PointerUnion.h\"\n#include \"llvm/Support/AlignOf.h\"\n\nnamespace clang {\nnamespace serialization {\ntemplate <typename T> class BasicReaderBase;\n} // end namespace serialization\n\n  class AddrLabelExpr;\n  class ASTContext;\n  class CharUnits;\n  class CXXRecordDecl;\n  class Decl;\n  class DiagnosticBuilder;\n  class Expr;\n  class FieldDecl;\n  struct PrintingPolicy;\n  class Type;\n  class ValueDecl;\n  class QualType;\n\n/// Symbolic representation of typeid(T) for some type T.\nclass TypeInfoLValue {\n  const Type *T;\n\npublic:\n  TypeInfoLValue() : T() {}\n  explicit TypeInfoLValue(const Type *T);\n\n  const Type *getType() const { return T; }\n  explicit operator bool() const { return T; }\n\n  void *getOpaqueValue() { return const_cast<Type*>(T); }\n  static TypeInfoLValue getFromOpaqueValue(void *Value) {\n    TypeInfoLValue V;\n    V.T = reinterpret_cast<const Type*>(Value);\n    return V;\n  }\n\n  void print(llvm::raw_ostream &Out, const PrintingPolicy &Policy) const;\n};\n\n/// Symbolic representation of a dynamic allocation.\nclass DynamicAllocLValue {\n  unsigned Index;\n\npublic:\n  DynamicAllocLValue() : Index(0) {}\n  explicit DynamicAllocLValue(unsigned Index) : Index(Index + 1) {}\n  unsigned getIndex() { return Index - 1; }\n\n  explicit operator bool() const { return Index != 0; }\n\n  void *getOpaqueValue() {\n    return reinterpret_cast<void *>(static_cast<uintptr_t>(Index)\n                                    << NumLowBitsAvailable);\n  }\n  static DynamicAllocLValue getFromOpaqueValue(void *Value) {\n    DynamicAllocLValue V;\n    V.Index = reinterpret_cast<uintptr_t>(Value) >> NumLowBitsAvailable;\n    return V;\n  }\n\n  static unsigned getMaxIndex() {\n    return (std::numeric_limits<unsigned>::max() >> NumLowBitsAvailable) - 1;\n  }\n\n  static constexpr int NumLowBitsAvailable = 3;\n};\n}\n\nnamespace llvm {\ntemplate<> struct PointerLikeTypeTraits<clang::TypeInfoLValue> {\n  static void *getAsVoidPointer(clang::TypeInfoLValue V) {\n    return V.getOpaqueValue();\n  }\n  static clang::TypeInfoLValue getFromVoidPointer(void *P) {\n    return clang::TypeInfoLValue::getFromOpaqueValue(P);\n  }\n  // Validated by static_assert in APValue.cpp; hardcoded to avoid needing\n  // to include Type.h.\n  static constexpr int NumLowBitsAvailable = 3;\n};\n\ntemplate<> struct PointerLikeTypeTraits<clang::DynamicAllocLValue> {\n  static void *getAsVoidPointer(clang::DynamicAllocLValue V) {\n    return V.getOpaqueValue();\n  }\n  static clang::DynamicAllocLValue getFromVoidPointer(void *P) {\n    return clang::DynamicAllocLValue::getFromOpaqueValue(P);\n  }\n  static constexpr int NumLowBitsAvailable =\n      clang::DynamicAllocLValue::NumLowBitsAvailable;\n};\n}\n\nnamespace clang {\n/// APValue - This class implements a discriminated union of [uninitialized]\n/// [APSInt] [APFloat], [Complex APSInt] [Complex APFloat], [Expr + Offset],\n/// [Vector: N * APValue], [Array: N * APValue]\nclass APValue {\n  typedef llvm::APFixedPoint APFixedPoint;\n  typedef llvm::APSInt APSInt;\n  typedef llvm::APFloat APFloat;\npublic:\n  enum ValueKind {\n    /// There is no such object (it's outside its lifetime).\n    None,\n    /// This object has an indeterminate value (C++ [basic.indet]).\n    Indeterminate,\n    Int,\n    Float,\n    FixedPoint,\n    ComplexInt,\n    ComplexFloat,\n    LValue,\n    Vector,\n    Array,\n    Struct,\n    Union,\n    MemberPointer,\n    AddrLabelDiff\n  };\n\n  class LValueBase {\n    typedef llvm::PointerUnion<const ValueDecl *, const Expr *, TypeInfoLValue,\n                               DynamicAllocLValue>\n        PtrTy;\n\n  public:\n    LValueBase() : Local{} {}\n    LValueBase(const ValueDecl *P, unsigned I = 0, unsigned V = 0);\n    LValueBase(const Expr *P, unsigned I = 0, unsigned V = 0);\n    static LValueBase getDynamicAlloc(DynamicAllocLValue LV, QualType Type);\n    static LValueBase getTypeInfo(TypeInfoLValue LV, QualType TypeInfo);\n\n    void Profile(llvm::FoldingSetNodeID &ID) const;\n\n    template <class T>\n    bool is() const { return Ptr.is<T>(); }\n\n    template <class T>\n    T get() const { return Ptr.get<T>(); }\n\n    template <class T>\n    T dyn_cast() const { return Ptr.dyn_cast<T>(); }\n\n    void *getOpaqueValue() const;\n\n    bool isNull() const;\n\n    explicit operator bool() const;\n\n    unsigned getCallIndex() const;\n    unsigned getVersion() const;\n    QualType getTypeInfoType() const;\n    QualType getDynamicAllocType() const;\n\n    QualType getType() const;\n\n    friend bool operator==(const LValueBase &LHS, const LValueBase &RHS);\n    friend bool operator!=(const LValueBase &LHS, const LValueBase &RHS) {\n      return !(LHS == RHS);\n    }\n    friend llvm::hash_code hash_value(const LValueBase &Base);\n    friend struct llvm::DenseMapInfo<LValueBase>;\n\n  private:\n    PtrTy Ptr;\n    struct LocalState {\n      unsigned CallIndex, Version;\n    };\n    union {\n      LocalState Local;\n      /// The type std::type_info, if this is a TypeInfoLValue.\n      void *TypeInfoType;\n      /// The QualType, if this is a DynamicAllocLValue.\n      void *DynamicAllocType;\n    };\n  };\n\n  /// A FieldDecl or CXXRecordDecl, along with a flag indicating whether we\n  /// mean a virtual or non-virtual base class subobject.\n  typedef llvm::PointerIntPair<const Decl *, 1, bool> BaseOrMemberType;\n\n  /// A non-discriminated union of a base, field, or array index.\n  class LValuePathEntry {\n    static_assert(sizeof(uintptr_t) <= sizeof(uint64_t),\n                  \"pointer doesn't fit in 64 bits?\");\n    uint64_t Value;\n\n  public:\n    LValuePathEntry() : Value() {}\n    LValuePathEntry(BaseOrMemberType BaseOrMember);\n    static LValuePathEntry ArrayIndex(uint64_t Index) {\n      LValuePathEntry Result;\n      Result.Value = Index;\n      return Result;\n    }\n\n    BaseOrMemberType getAsBaseOrMember() const {\n      return BaseOrMemberType::getFromOpaqueValue(\n          reinterpret_cast<void *>(Value));\n    }\n    uint64_t getAsArrayIndex() const { return Value; }\n\n    void Profile(llvm::FoldingSetNodeID &ID) const;\n\n    friend bool operator==(LValuePathEntry A, LValuePathEntry B) {\n      return A.Value == B.Value;\n    }\n    friend bool operator!=(LValuePathEntry A, LValuePathEntry B) {\n      return A.Value != B.Value;\n    }\n    friend llvm::hash_code hash_value(LValuePathEntry A) {\n      return llvm::hash_value(A.Value);\n    }\n  };\n  class LValuePathSerializationHelper {\n    const void *ElemTy;\n\n  public:\n    ArrayRef<LValuePathEntry> Path;\n\n    LValuePathSerializationHelper(ArrayRef<LValuePathEntry>, QualType);\n    QualType getType();\n  };\n  struct NoLValuePath {};\n  struct UninitArray {};\n  struct UninitStruct {};\n\n  template <typename Impl> friend class clang::serialization::BasicReaderBase;\n  friend class ASTImporter;\n  friend class ASTNodeImporter;\n\nprivate:\n  ValueKind Kind;\n\n  struct ComplexAPSInt {\n    APSInt Real, Imag;\n    ComplexAPSInt() : Real(1), Imag(1) {}\n  };\n  struct ComplexAPFloat {\n    APFloat Real, Imag;\n    ComplexAPFloat() : Real(0.0), Imag(0.0) {}\n  };\n  struct LV;\n  struct Vec {\n    APValue *Elts;\n    unsigned NumElts;\n    Vec() : Elts(nullptr), NumElts(0) {}\n    ~Vec() { delete[] Elts; }\n  };\n  struct Arr {\n    APValue *Elts;\n    unsigned NumElts, ArrSize;\n    Arr(unsigned NumElts, unsigned ArrSize);\n    ~Arr();\n  };\n  struct StructData {\n    APValue *Elts;\n    unsigned NumBases;\n    unsigned NumFields;\n    StructData(unsigned NumBases, unsigned NumFields);\n    ~StructData();\n  };\n  struct UnionData {\n    const FieldDecl *Field;\n    APValue *Value;\n    UnionData();\n    ~UnionData();\n  };\n  struct AddrLabelDiffData {\n    const AddrLabelExpr* LHSExpr;\n    const AddrLabelExpr* RHSExpr;\n  };\n  struct MemberPointerData;\n\n  // We ensure elsewhere that Data is big enough for LV and MemberPointerData.\n  typedef llvm::AlignedCharArrayUnion<void *, APSInt, APFloat, ComplexAPSInt,\n                                      ComplexAPFloat, Vec, Arr, StructData,\n                                      UnionData, AddrLabelDiffData> DataType;\n  static const size_t DataSize = sizeof(DataType);\n\n  DataType Data;\n\npublic:\n  APValue() : Kind(None) {}\n  explicit APValue(APSInt I) : Kind(None) {\n    MakeInt(); setInt(std::move(I));\n  }\n  explicit APValue(APFloat F) : Kind(None) {\n    MakeFloat(); setFloat(std::move(F));\n  }\n  explicit APValue(APFixedPoint FX) : Kind(None) {\n    MakeFixedPoint(std::move(FX));\n  }\n  explicit APValue(const APValue *E, unsigned N) : Kind(None) {\n    MakeVector(); setVector(E, N);\n  }\n  APValue(APSInt R, APSInt I) : Kind(None) {\n    MakeComplexInt(); setComplexInt(std::move(R), std::move(I));\n  }\n  APValue(APFloat R, APFloat I) : Kind(None) {\n    MakeComplexFloat(); setComplexFloat(std::move(R), std::move(I));\n  }\n  APValue(const APValue &RHS);\n  APValue(APValue &&RHS);\n  APValue(LValueBase B, const CharUnits &O, NoLValuePath N,\n          bool IsNullPtr = false)\n      : Kind(None) {\n    MakeLValue(); setLValue(B, O, N, IsNullPtr);\n  }\n  APValue(LValueBase B, const CharUnits &O, ArrayRef<LValuePathEntry> Path,\n          bool OnePastTheEnd, bool IsNullPtr = false)\n      : Kind(None) {\n    MakeLValue(); setLValue(B, O, Path, OnePastTheEnd, IsNullPtr);\n  }\n  APValue(UninitArray, unsigned InitElts, unsigned Size) : Kind(None) {\n    MakeArray(InitElts, Size);\n  }\n  APValue(UninitStruct, unsigned B, unsigned M) : Kind(None) {\n    MakeStruct(B, M);\n  }\n  explicit APValue(const FieldDecl *D, const APValue &V = APValue())\n      : Kind(None) {\n    MakeUnion(); setUnion(D, V);\n  }\n  APValue(const ValueDecl *Member, bool IsDerivedMember,\n          ArrayRef<const CXXRecordDecl*> Path) : Kind(None) {\n    MakeMemberPointer(Member, IsDerivedMember, Path);\n  }\n  APValue(const AddrLabelExpr* LHSExpr, const AddrLabelExpr* RHSExpr)\n      : Kind(None) {\n    MakeAddrLabelDiff(); setAddrLabelDiff(LHSExpr, RHSExpr);\n  }\n  static APValue IndeterminateValue() {\n    APValue Result;\n    Result.Kind = Indeterminate;\n    return Result;\n  }\n\n  APValue &operator=(const APValue &RHS);\n  APValue &operator=(APValue &&RHS);\n\n  ~APValue() {\n    if (Kind != None && Kind != Indeterminate)\n      DestroyDataAndMakeUninit();\n  }\n\n  /// Returns whether the object performed allocations.\n  ///\n  /// If APValues are constructed via placement new, \\c needsCleanup()\n  /// indicates whether the destructor must be called in order to correctly\n  /// free all allocated memory.\n  bool needsCleanup() const;\n\n  /// Swaps the contents of this and the given APValue.\n  void swap(APValue &RHS);\n\n  /// profile this value. There is no guarantee that values of different\n  /// types will not produce the same profiled value, so the type should\n  /// typically also be profiled if it's not implied by the context.\n  void Profile(llvm::FoldingSetNodeID &ID) const;\n\n  ValueKind getKind() const { return Kind; }\n\n  bool isAbsent() const { return Kind == None; }\n  bool isIndeterminate() const { return Kind == Indeterminate; }\n  bool hasValue() const { return Kind != None && Kind != Indeterminate; }\n\n  bool isInt() const { return Kind == Int; }\n  bool isFloat() const { return Kind == Float; }\n  bool isFixedPoint() const { return Kind == FixedPoint; }\n  bool isComplexInt() const { return Kind == ComplexInt; }\n  bool isComplexFloat() const { return Kind == ComplexFloat; }\n  bool isLValue() const { return Kind == LValue; }\n  bool isVector() const { return Kind == Vector; }\n  bool isArray() const { return Kind == Array; }\n  bool isStruct() const { return Kind == Struct; }\n  bool isUnion() const { return Kind == Union; }\n  bool isMemberPointer() const { return Kind == MemberPointer; }\n  bool isAddrLabelDiff() const { return Kind == AddrLabelDiff; }\n\n  void dump() const;\n  void dump(raw_ostream &OS, const ASTContext &Context) const;\n\n  void printPretty(raw_ostream &OS, const ASTContext &Ctx, QualType Ty) const;\n  void printPretty(raw_ostream &OS, const PrintingPolicy &Policy, QualType Ty,\n                   const ASTContext *Ctx = nullptr) const;\n\n  std::string getAsString(const ASTContext &Ctx, QualType Ty) const;\n\n  APSInt &getInt() {\n    assert(isInt() && \"Invalid accessor\");\n    return *(APSInt *)(char *)&Data;\n  }\n  const APSInt &getInt() const {\n    return const_cast<APValue*>(this)->getInt();\n  }\n\n  /// Try to convert this value to an integral constant. This works if it's an\n  /// integer, null pointer, or offset from a null pointer. Returns true on\n  /// success.\n  bool toIntegralConstant(APSInt &Result, QualType SrcTy,\n                          const ASTContext &Ctx) const;\n\n  APFloat &getFloat() {\n    assert(isFloat() && \"Invalid accessor\");\n    return *(APFloat *)(char *)&Data;\n  }\n  const APFloat &getFloat() const {\n    return const_cast<APValue*>(this)->getFloat();\n  }\n\n  APFixedPoint &getFixedPoint() {\n    assert(isFixedPoint() && \"Invalid accessor\");\n    return *(APFixedPoint *)(char *)&Data;\n  }\n  const APFixedPoint &getFixedPoint() const {\n    return const_cast<APValue *>(this)->getFixedPoint();\n  }\n\n  APSInt &getComplexIntReal() {\n    assert(isComplexInt() && \"Invalid accessor\");\n    return ((ComplexAPSInt *)(char *)&Data)->Real;\n  }\n  const APSInt &getComplexIntReal() const {\n    return const_cast<APValue*>(this)->getComplexIntReal();\n  }\n\n  APSInt &getComplexIntImag() {\n    assert(isComplexInt() && \"Invalid accessor\");\n    return ((ComplexAPSInt *)(char *)&Data)->Imag;\n  }\n  const APSInt &getComplexIntImag() const {\n    return const_cast<APValue*>(this)->getComplexIntImag();\n  }\n\n  APFloat &getComplexFloatReal() {\n    assert(isComplexFloat() && \"Invalid accessor\");\n    return ((ComplexAPFloat *)(char *)&Data)->Real;\n  }\n  const APFloat &getComplexFloatReal() const {\n    return const_cast<APValue*>(this)->getComplexFloatReal();\n  }\n\n  APFloat &getComplexFloatImag() {\n    assert(isComplexFloat() && \"Invalid accessor\");\n    return ((ComplexAPFloat *)(char *)&Data)->Imag;\n  }\n  const APFloat &getComplexFloatImag() const {\n    return const_cast<APValue*>(this)->getComplexFloatImag();\n  }\n\n  const LValueBase getLValueBase() const;\n  CharUnits &getLValueOffset();\n  const CharUnits &getLValueOffset() const {\n    return const_cast<APValue*>(this)->getLValueOffset();\n  }\n  bool isLValueOnePastTheEnd() const;\n  bool hasLValuePath() const;\n  ArrayRef<LValuePathEntry> getLValuePath() const;\n  unsigned getLValueCallIndex() const;\n  unsigned getLValueVersion() const;\n  bool isNullPointer() const;\n\n  APValue &getVectorElt(unsigned I) {\n    assert(isVector() && \"Invalid accessor\");\n    assert(I < getVectorLength() && \"Index out of range\");\n    return ((Vec *)(char *)&Data)->Elts[I];\n  }\n  const APValue &getVectorElt(unsigned I) const {\n    return const_cast<APValue*>(this)->getVectorElt(I);\n  }\n  unsigned getVectorLength() const {\n    assert(isVector() && \"Invalid accessor\");\n    return ((const Vec *)(const void *)&Data)->NumElts;\n  }\n\n  APValue &getArrayInitializedElt(unsigned I) {\n    assert(isArray() && \"Invalid accessor\");\n    assert(I < getArrayInitializedElts() && \"Index out of range\");\n    return ((Arr *)(char *)&Data)->Elts[I];\n  }\n  const APValue &getArrayInitializedElt(unsigned I) const {\n    return const_cast<APValue*>(this)->getArrayInitializedElt(I);\n  }\n  bool hasArrayFiller() const {\n    return getArrayInitializedElts() != getArraySize();\n  }\n  APValue &getArrayFiller() {\n    assert(isArray() && \"Invalid accessor\");\n    assert(hasArrayFiller() && \"No array filler\");\n    return ((Arr *)(char *)&Data)->Elts[getArrayInitializedElts()];\n  }\n  const APValue &getArrayFiller() const {\n    return const_cast<APValue*>(this)->getArrayFiller();\n  }\n  unsigned getArrayInitializedElts() const {\n    assert(isArray() && \"Invalid accessor\");\n    return ((const Arr *)(const void *)&Data)->NumElts;\n  }\n  unsigned getArraySize() const {\n    assert(isArray() && \"Invalid accessor\");\n    return ((const Arr *)(const void *)&Data)->ArrSize;\n  }\n\n  unsigned getStructNumBases() const {\n    assert(isStruct() && \"Invalid accessor\");\n    return ((const StructData *)(const char *)&Data)->NumBases;\n  }\n  unsigned getStructNumFields() const {\n    assert(isStruct() && \"Invalid accessor\");\n    return ((const StructData *)(const char *)&Data)->NumFields;\n  }\n  APValue &getStructBase(unsigned i) {\n    assert(isStruct() && \"Invalid accessor\");\n    assert(i < getStructNumBases() && \"base class index OOB\");\n    return ((StructData *)(char *)&Data)->Elts[i];\n  }\n  APValue &getStructField(unsigned i) {\n    assert(isStruct() && \"Invalid accessor\");\n    assert(i < getStructNumFields() && \"field index OOB\");\n    return ((StructData *)(char *)&Data)->Elts[getStructNumBases() + i];\n  }\n  const APValue &getStructBase(unsigned i) const {\n    return const_cast<APValue*>(this)->getStructBase(i);\n  }\n  const APValue &getStructField(unsigned i) const {\n    return const_cast<APValue*>(this)->getStructField(i);\n  }\n\n  const FieldDecl *getUnionField() const {\n    assert(isUnion() && \"Invalid accessor\");\n    return ((const UnionData *)(const char *)&Data)->Field;\n  }\n  APValue &getUnionValue() {\n    assert(isUnion() && \"Invalid accessor\");\n    return *((UnionData *)(char *)&Data)->Value;\n  }\n  const APValue &getUnionValue() const {\n    return const_cast<APValue*>(this)->getUnionValue();\n  }\n\n  const ValueDecl *getMemberPointerDecl() const;\n  bool isMemberPointerToDerivedMember() const;\n  ArrayRef<const CXXRecordDecl*> getMemberPointerPath() const;\n\n  const AddrLabelExpr* getAddrLabelDiffLHS() const {\n    assert(isAddrLabelDiff() && \"Invalid accessor\");\n    return ((const AddrLabelDiffData *)(const char *)&Data)->LHSExpr;\n  }\n  const AddrLabelExpr* getAddrLabelDiffRHS() const {\n    assert(isAddrLabelDiff() && \"Invalid accessor\");\n    return ((const AddrLabelDiffData *)(const char *)&Data)->RHSExpr;\n  }\n\n  void setInt(APSInt I) {\n    assert(isInt() && \"Invalid accessor\");\n    *(APSInt *)(char *)&Data = std::move(I);\n  }\n  void setFloat(APFloat F) {\n    assert(isFloat() && \"Invalid accessor\");\n    *(APFloat *)(char *)&Data = std::move(F);\n  }\n  void setFixedPoint(APFixedPoint FX) {\n    assert(isFixedPoint() && \"Invalid accessor\");\n    *(APFixedPoint *)(char *)&Data = std::move(FX);\n  }\n  void setVector(const APValue *E, unsigned N) {\n    MutableArrayRef<APValue> InternalElts = setVectorUninit(N);\n    for (unsigned i = 0; i != N; ++i)\n      InternalElts[i] = E[i];\n  }\n  void setComplexInt(APSInt R, APSInt I) {\n    assert(R.getBitWidth() == I.getBitWidth() &&\n           \"Invalid complex int (type mismatch).\");\n    assert(isComplexInt() && \"Invalid accessor\");\n    ((ComplexAPSInt *)(char *)&Data)->Real = std::move(R);\n    ((ComplexAPSInt *)(char *)&Data)->Imag = std::move(I);\n  }\n  void setComplexFloat(APFloat R, APFloat I) {\n    assert(&R.getSemantics() == &I.getSemantics() &&\n           \"Invalid complex float (type mismatch).\");\n    assert(isComplexFloat() && \"Invalid accessor\");\n    ((ComplexAPFloat *)(char *)&Data)->Real = std::move(R);\n    ((ComplexAPFloat *)(char *)&Data)->Imag = std::move(I);\n  }\n  void setLValue(LValueBase B, const CharUnits &O, NoLValuePath,\n                 bool IsNullPtr);\n  void setLValue(LValueBase B, const CharUnits &O,\n                 ArrayRef<LValuePathEntry> Path, bool OnePastTheEnd,\n                 bool IsNullPtr);\n  void setUnion(const FieldDecl *Field, const APValue &Value);\n  void setAddrLabelDiff(const AddrLabelExpr* LHSExpr,\n                        const AddrLabelExpr* RHSExpr) {\n    ((AddrLabelDiffData *)(char *)&Data)->LHSExpr = LHSExpr;\n    ((AddrLabelDiffData *)(char *)&Data)->RHSExpr = RHSExpr;\n  }\n\nprivate:\n  void DestroyDataAndMakeUninit();\n  void MakeInt() {\n    assert(isAbsent() && \"Bad state change\");\n    new ((void *)&Data) APSInt(1);\n    Kind = Int;\n  }\n  void MakeFloat() {\n    assert(isAbsent() && \"Bad state change\");\n    new ((void *)(char *)&Data) APFloat(0.0);\n    Kind = Float;\n  }\n  void MakeFixedPoint(APFixedPoint &&FX) {\n    assert(isAbsent() && \"Bad state change\");\n    new ((void *)(char *)&Data) APFixedPoint(std::move(FX));\n    Kind = FixedPoint;\n  }\n  void MakeVector() {\n    assert(isAbsent() && \"Bad state change\");\n    new ((void *)(char *)&Data) Vec();\n    Kind = Vector;\n  }\n  void MakeComplexInt() {\n    assert(isAbsent() && \"Bad state change\");\n    new ((void *)(char *)&Data) ComplexAPSInt();\n    Kind = ComplexInt;\n  }\n  void MakeComplexFloat() {\n    assert(isAbsent() && \"Bad state change\");\n    new ((void *)(char *)&Data) ComplexAPFloat();\n    Kind = ComplexFloat;\n  }\n  void MakeLValue();\n  void MakeArray(unsigned InitElts, unsigned Size);\n  void MakeStruct(unsigned B, unsigned M) {\n    assert(isAbsent() && \"Bad state change\");\n    new ((void *)(char *)&Data) StructData(B, M);\n    Kind = Struct;\n  }\n  void MakeUnion() {\n    assert(isAbsent() && \"Bad state change\");\n    new ((void *)(char *)&Data) UnionData();\n    Kind = Union;\n  }\n  void MakeMemberPointer(const ValueDecl *Member, bool IsDerivedMember,\n                         ArrayRef<const CXXRecordDecl*> Path);\n  void MakeAddrLabelDiff() {\n    assert(isAbsent() && \"Bad state change\");\n    new ((void *)(char *)&Data) AddrLabelDiffData();\n    Kind = AddrLabelDiff;\n  }\n\nprivate:\n  /// The following functions are used as part of initialization, during\n  /// deserialization and importing. Reserve the space so that it can be\n  /// filled in by those steps.\n  MutableArrayRef<APValue> setVectorUninit(unsigned N) {\n    assert(isVector() && \"Invalid accessor\");\n    Vec *V = ((Vec *)(char *)&Data);\n    V->Elts = new APValue[N];\n    V->NumElts = N;\n    return {V->Elts, V->NumElts};\n  }\n  MutableArrayRef<LValuePathEntry>\n  setLValueUninit(LValueBase B, const CharUnits &O, unsigned Size,\n                  bool OnePastTheEnd, bool IsNullPtr);\n  MutableArrayRef<const CXXRecordDecl *>\n  setMemberPointerUninit(const ValueDecl *Member, bool IsDerivedMember,\n                         unsigned Size);\n};\n\n} // end namespace clang.\n\nnamespace llvm {\ntemplate<> struct DenseMapInfo<clang::APValue::LValueBase> {\n  static clang::APValue::LValueBase getEmptyKey();\n  static clang::APValue::LValueBase getTombstoneKey();\n  static unsigned getHashValue(const clang::APValue::LValueBase &Base);\n  static bool isEqual(const clang::APValue::LValueBase &LHS,\n                      const clang::APValue::LValueBase &RHS);\n};\n}\n\n#endif\n"}, "1": {"id": 1, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/ASTContext.h", "content": "//===- ASTContext.h - Context to hold long-lived AST nodes ------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n/// \\file\n/// Defines the clang::ASTContext interface.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_AST_ASTCONTEXT_H\n#define LLVM_CLANG_AST_ASTCONTEXT_H\n\n#include \"clang/AST/ASTContextAllocate.h\"\n#include \"clang/AST/ASTFwd.h\"\n#include \"clang/AST/CanonicalType.h\"\n#include \"clang/AST/CommentCommandTraits.h\"\n#include \"clang/AST/ComparisonCategories.h\"\n#include \"clang/AST/Decl.h\"\n#include \"clang/AST/DeclBase.h\"\n#include \"clang/AST/DeclarationName.h\"\n#include \"clang/AST/ExternalASTSource.h\"\n#include \"clang/AST/NestedNameSpecifier.h\"\n#include \"clang/AST/PrettyPrinter.h\"\n#include \"clang/AST/RawCommentList.h\"\n#include \"clang/AST/TemplateName.h\"\n#include \"clang/AST/Type.h\"\n#include \"clang/Basic/AddressSpaces.h\"\n#include \"clang/Basic/AttrKinds.h\"\n#include \"clang/Basic/IdentifierTable.h\"\n#include \"clang/Basic/LLVM.h\"\n#include \"clang/Basic/LangOptions.h\"\n#include \"clang/Basic/Linkage.h\"\n#include \"clang/Basic/NoSanitizeList.h\"\n#include \"clang/Basic/OperatorKinds.h\"\n#include \"clang/Basic/PartialDiagnostic.h\"\n#include \"clang/Basic/ProfileList.h\"\n#include \"clang/Basic/SourceLocation.h\"\n#include \"clang/Basic/Specifiers.h\"\n#include \"clang/Basic/XRayLists.h\"\n#include \"llvm/ADT/APSInt.h\"\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/ADT/DenseMap.h\"\n#include \"llvm/ADT/DenseSet.h\"\n#include \"llvm/ADT/FoldingSet.h\"\n#include \"llvm/ADT/IntrusiveRefCntPtr.h\"\n#include \"llvm/ADT/MapVector.h\"\n#include \"llvm/ADT/None.h\"\n#include \"llvm/ADT/Optional.h\"\n#include \"llvm/ADT/PointerIntPair.h\"\n#include \"llvm/ADT/PointerUnion.h\"\n#include \"llvm/ADT/SmallVector.h\"\n#include \"llvm/ADT/StringMap.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/ADT/TinyPtrVector.h\"\n#include \"llvm/ADT/Triple.h\"\n#include \"llvm/ADT/iterator_range.h\"\n#include \"llvm/Support/AlignOf.h\"\n#include \"llvm/Support/Allocator.h\"\n#include \"llvm/Support/Casting.h\"\n#include \"llvm/Support/Compiler.h\"\n#include \"llvm/Support/TypeSize.h\"\n#include <cassert>\n#include <cstddef>\n#include <cstdint>\n#include <iterator>\n#include <memory>\n#include <string>\n#include <type_traits>\n#include <utility>\n#include <vector>\n\nnamespace llvm {\n\nclass APFixedPoint;\nclass FixedPointSemantics;\nstruct fltSemantics;\ntemplate <typename T, unsigned N> class SmallPtrSet;\n\n} // namespace llvm\n\nnamespace clang {\n\nclass APValue;\nclass ASTMutationListener;\nclass ASTRecordLayout;\nclass AtomicExpr;\nclass BlockExpr;\nclass BuiltinTemplateDecl;\nclass CharUnits;\nclass ConceptDecl;\nclass CXXABI;\nclass CXXConstructorDecl;\nclass CXXMethodDecl;\nclass CXXRecordDecl;\nclass DiagnosticsEngine;\nclass ParentMapContext;\nclass DynTypedNode;\nclass DynTypedNodeList;\nclass Expr;\nclass GlobalDecl;\nclass MangleContext;\nclass MangleNumberingContext;\nclass MaterializeTemporaryExpr;\nclass MemberSpecializationInfo;\nclass Module;\nstruct MSGuidDeclParts;\nclass ObjCCategoryDecl;\nclass ObjCCategoryImplDecl;\nclass ObjCContainerDecl;\nclass ObjCImplDecl;\nclass ObjCImplementationDecl;\nclass ObjCInterfaceDecl;\nclass ObjCIvarDecl;\nclass ObjCMethodDecl;\nclass ObjCPropertyDecl;\nclass ObjCPropertyImplDecl;\nclass ObjCProtocolDecl;\nclass ObjCTypeParamDecl;\nclass OMPTraitInfo;\nstruct ParsedTargetAttr;\nclass Preprocessor;\nclass Stmt;\nclass StoredDeclsMap;\nclass TargetAttr;\nclass TargetInfo;\nclass TemplateDecl;\nclass TemplateParameterList;\nclass TemplateTemplateParmDecl;\nclass TemplateTypeParmDecl;\nclass UnresolvedSetIterator;\nclass UsingShadowDecl;\nclass VarTemplateDecl;\nclass VTableContextBase;\nstruct BlockVarCopyInit;\n\nnamespace Builtin {\n\nclass Context;\n\n} // namespace Builtin\n\nenum BuiltinTemplateKind : int;\nenum OpenCLTypeKind : uint8_t;\n\nnamespace comments {\n\nclass FullComment;\n\n} // namespace comments\n\nnamespace interp {\n\nclass Context;\n\n} // namespace interp\n\nnamespace serialization {\ntemplate <class> class AbstractTypeReader;\n} // namespace serialization\n\nstruct TypeInfo {\n  uint64_t Width = 0;\n  unsigned Align = 0;\n  bool AlignIsRequired : 1;\n\n  TypeInfo() : AlignIsRequired(false) {}\n  TypeInfo(uint64_t Width, unsigned Align, bool AlignIsRequired)\n      : Width(Width), Align(Align), AlignIsRequired(AlignIsRequired) {}\n};\n\nstruct TypeInfoChars {\n  CharUnits Width;\n  CharUnits Align;\n  bool AlignIsRequired : 1;\n\n  TypeInfoChars() : AlignIsRequired(false) {}\n  TypeInfoChars(CharUnits Width, CharUnits Align, bool AlignIsRequired)\n      : Width(Width), Align(Align), AlignIsRequired(AlignIsRequired) {}\n};\n\n/// Holds long-lived AST nodes (such as types and decls) that can be\n/// referred to throughout the semantic analysis of a file.\nclass ASTContext : public RefCountedBase<ASTContext> {\n  friend class NestedNameSpecifier;\n\n  mutable SmallVector<Type *, 0> Types;\n  mutable llvm::FoldingSet<ExtQuals> ExtQualNodes;\n  mutable llvm::FoldingSet<ComplexType> ComplexTypes;\n  mutable llvm::FoldingSet<PointerType> PointerTypes;\n  mutable llvm::FoldingSet<AdjustedType> AdjustedTypes;\n  mutable llvm::FoldingSet<BlockPointerType> BlockPointerTypes;\n  mutable llvm::FoldingSet<LValueReferenceType> LValueReferenceTypes;\n  mutable llvm::FoldingSet<RValueReferenceType> RValueReferenceTypes;\n  mutable llvm::FoldingSet<MemberPointerType> MemberPointerTypes;\n  mutable llvm::ContextualFoldingSet<ConstantArrayType, ASTContext &>\n      ConstantArrayTypes;\n  mutable llvm::FoldingSet<IncompleteArrayType> IncompleteArrayTypes;\n  mutable std::vector<VariableArrayType*> VariableArrayTypes;\n  mutable llvm::FoldingSet<DependentSizedArrayType> DependentSizedArrayTypes;\n  mutable llvm::FoldingSet<DependentSizedExtVectorType>\n    DependentSizedExtVectorTypes;\n  mutable llvm::FoldingSet<DependentAddressSpaceType>\n      DependentAddressSpaceTypes;\n  mutable llvm::FoldingSet<VectorType> VectorTypes;\n  mutable llvm::FoldingSet<DependentVectorType> DependentVectorTypes;\n  mutable llvm::FoldingSet<ConstantMatrixType> MatrixTypes;\n  mutable llvm::FoldingSet<DependentSizedMatrixType> DependentSizedMatrixTypes;\n  mutable llvm::FoldingSet<FunctionNoProtoType> FunctionNoProtoTypes;\n  mutable llvm::ContextualFoldingSet<FunctionProtoType, ASTContext&>\n    FunctionProtoTypes;\n  mutable llvm::FoldingSet<DependentTypeOfExprType> DependentTypeOfExprTypes;\n  mutable llvm::FoldingSet<DependentDecltypeType> DependentDecltypeTypes;\n  mutable llvm::FoldingSet<TemplateTypeParmType> TemplateTypeParmTypes;\n  mutable llvm::FoldingSet<ObjCTypeParamType> ObjCTypeParamTypes;\n  mutable llvm::FoldingSet<SubstTemplateTypeParmType>\n    SubstTemplateTypeParmTypes;\n  mutable llvm::FoldingSet<SubstTemplateTypeParmPackType>\n    SubstTemplateTypeParmPackTypes;\n  mutable llvm::ContextualFoldingSet<TemplateSpecializationType, ASTContext&>\n    TemplateSpecializationTypes;\n  mutable llvm::FoldingSet<ParenType> ParenTypes;\n  mutable llvm::FoldingSet<ElaboratedType> ElaboratedTypes;\n  mutable llvm::FoldingSet<DependentNameType> DependentNameTypes;\n  mutable llvm::ContextualFoldingSet<DependentTemplateSpecializationType,\n                                     ASTContext&>\n    DependentTemplateSpecializationTypes;\n  llvm::FoldingSet<PackExpansionType> PackExpansionTypes;\n  mutable llvm::FoldingSet<ObjCObjectTypeImpl> ObjCObjectTypes;\n  mutable llvm::FoldingSet<ObjCObjectPointerType> ObjCObjectPointerTypes;\n  mutable llvm::FoldingSet<DependentUnaryTransformType>\n    DependentUnaryTransformTypes;\n  mutable llvm::ContextualFoldingSet<AutoType, ASTContext&> AutoTypes;\n  mutable llvm::FoldingSet<DeducedTemplateSpecializationType>\n    DeducedTemplateSpecializationTypes;\n  mutable llvm::FoldingSet<AtomicType> AtomicTypes;\n  llvm::FoldingSet<AttributedType> AttributedTypes;\n  mutable llvm::FoldingSet<PipeType> PipeTypes;\n  mutable llvm::FoldingSet<ExtIntType> ExtIntTypes;\n  mutable llvm::FoldingSet<DependentExtIntType> DependentExtIntTypes;\n\n  mutable llvm::FoldingSet<QualifiedTemplateName> QualifiedTemplateNames;\n  mutable llvm::FoldingSet<DependentTemplateName> DependentTemplateNames;\n  mutable llvm::FoldingSet<SubstTemplateTemplateParmStorage>\n    SubstTemplateTemplateParms;\n  mutable llvm::ContextualFoldingSet<SubstTemplateTemplateParmPackStorage,\n                                     ASTContext&>\n    SubstTemplateTemplateParmPacks;\n\n  /// The set of nested name specifiers.\n  ///\n  /// This set is managed by the NestedNameSpecifier class.\n  mutable llvm::FoldingSet<NestedNameSpecifier> NestedNameSpecifiers;\n  mutable NestedNameSpecifier *GlobalNestedNameSpecifier = nullptr;\n\n  /// A cache mapping from RecordDecls to ASTRecordLayouts.\n  ///\n  /// This is lazily created.  This is intentionally not serialized.\n  mutable llvm::DenseMap<const RecordDecl*, const ASTRecordLayout*>\n    ASTRecordLayouts;\n  mutable llvm::DenseMap<const ObjCContainerDecl*, const ASTRecordLayout*>\n    ObjCLayouts;\n\n  /// A cache from types to size and alignment information.\n  using TypeInfoMap = llvm::DenseMap<const Type *, struct TypeInfo>;\n  mutable TypeInfoMap MemoizedTypeInfo;\n\n  /// A cache from types to unadjusted alignment information. Only ARM and\n  /// AArch64 targets need this information, keeping it separate prevents\n  /// imposing overhead on TypeInfo size.\n  using UnadjustedAlignMap = llvm::DenseMap<const Type *, unsigned>;\n  mutable UnadjustedAlignMap MemoizedUnadjustedAlign;\n\n  /// A cache mapping from CXXRecordDecls to key functions.\n  llvm::DenseMap<const CXXRecordDecl*, LazyDeclPtr> KeyFunctions;\n\n  /// Mapping from ObjCContainers to their ObjCImplementations.\n  llvm::DenseMap<ObjCContainerDecl*, ObjCImplDecl*> ObjCImpls;\n\n  /// Mapping from ObjCMethod to its duplicate declaration in the same\n  /// interface.\n  llvm::DenseMap<const ObjCMethodDecl*,const ObjCMethodDecl*> ObjCMethodRedecls;\n\n  /// Mapping from __block VarDecls to BlockVarCopyInit.\n  llvm::DenseMap<const VarDecl *, BlockVarCopyInit> BlockVarCopyInits;\n\n  /// Mapping from GUIDs to the corresponding MSGuidDecl.\n  mutable llvm::FoldingSet<MSGuidDecl> MSGuidDecls;\n\n  /// Mapping from APValues to the corresponding TemplateParamObjects.\n  mutable llvm::FoldingSet<TemplateParamObjectDecl> TemplateParamObjectDecls;\n\n  /// A cache mapping a string value to a StringLiteral object with the same\n  /// value.\n  ///\n  /// This is lazily created.  This is intentionally not serialized.\n  mutable llvm::StringMap<StringLiteral *> StringLiteralCache;\n\n  /// MD5 hash of CUID. It is calculated when first used and cached by this\n  /// data member.\n  mutable std::string CUIDHash;\n\n  /// Representation of a \"canonical\" template template parameter that\n  /// is used in canonical template names.\n  class CanonicalTemplateTemplateParm : public llvm::FoldingSetNode {\n    TemplateTemplateParmDecl *Parm;\n\n  public:\n    CanonicalTemplateTemplateParm(TemplateTemplateParmDecl *Parm)\n        : Parm(Parm) {}\n\n    TemplateTemplateParmDecl *getParam() const { return Parm; }\n\n    void Profile(llvm::FoldingSetNodeID &ID, const ASTContext &C) {\n      Profile(ID, C, Parm);\n    }\n\n    static void Profile(llvm::FoldingSetNodeID &ID,\n                        const ASTContext &C,\n                        TemplateTemplateParmDecl *Parm);\n  };\n  mutable llvm::ContextualFoldingSet<CanonicalTemplateTemplateParm,\n                                     const ASTContext&>\n    CanonTemplateTemplateParms;\n\n  TemplateTemplateParmDecl *\n    getCanonicalTemplateTemplateParmDecl(TemplateTemplateParmDecl *TTP) const;\n\n  /// The typedef for the __int128_t type.\n  mutable TypedefDecl *Int128Decl = nullptr;\n\n  /// The typedef for the __uint128_t type.\n  mutable TypedefDecl *UInt128Decl = nullptr;\n\n  /// The typedef for the target specific predefined\n  /// __builtin_va_list type.\n  mutable TypedefDecl *BuiltinVaListDecl = nullptr;\n\n  /// The typedef for the predefined \\c __builtin_ms_va_list type.\n  mutable TypedefDecl *BuiltinMSVaListDecl = nullptr;\n\n  /// The typedef for the predefined \\c id type.\n  mutable TypedefDecl *ObjCIdDecl = nullptr;\n\n  /// The typedef for the predefined \\c SEL type.\n  mutable TypedefDecl *ObjCSelDecl = nullptr;\n\n  /// The typedef for the predefined \\c Class type.\n  mutable TypedefDecl *ObjCClassDecl = nullptr;\n\n  /// The typedef for the predefined \\c Protocol class in Objective-C.\n  mutable ObjCInterfaceDecl *ObjCProtocolClassDecl = nullptr;\n\n  /// The typedef for the predefined 'BOOL' type.\n  mutable TypedefDecl *BOOLDecl = nullptr;\n\n  // Typedefs which may be provided defining the structure of Objective-C\n  // pseudo-builtins\n  QualType ObjCIdRedefinitionType;\n  QualType ObjCClassRedefinitionType;\n  QualType ObjCSelRedefinitionType;\n\n  /// The identifier 'bool'.\n  mutable IdentifierInfo *BoolName = nullptr;\n\n  /// The identifier 'NSObject'.\n  mutable IdentifierInfo *NSObjectName = nullptr;\n\n  /// The identifier 'NSCopying'.\n  IdentifierInfo *NSCopyingName = nullptr;\n\n  /// The identifier '__make_integer_seq'.\n  mutable IdentifierInfo *MakeIntegerSeqName = nullptr;\n\n  /// The identifier '__type_pack_element'.\n  mutable IdentifierInfo *TypePackElementName = nullptr;\n\n  QualType ObjCConstantStringType;\n  mutable RecordDecl *CFConstantStringTagDecl = nullptr;\n  mutable TypedefDecl *CFConstantStringTypeDecl = nullptr;\n\n  mutable QualType ObjCSuperType;\n\n  QualType ObjCNSStringType;\n\n  /// The typedef declaration for the Objective-C \"instancetype\" type.\n  TypedefDecl *ObjCInstanceTypeDecl = nullptr;\n\n  /// The type for the C FILE type.\n  TypeDecl *FILEDecl = nullptr;\n\n  /// The type for the C jmp_buf type.\n  TypeDecl *jmp_bufDecl = nullptr;\n\n  /// The type for the C sigjmp_buf type.\n  TypeDecl *sigjmp_bufDecl = nullptr;\n\n  /// The type for the C ucontext_t type.\n  TypeDecl *ucontext_tDecl = nullptr;\n\n  /// Type for the Block descriptor for Blocks CodeGen.\n  ///\n  /// Since this is only used for generation of debug info, it is not\n  /// serialized.\n  mutable RecordDecl *BlockDescriptorType = nullptr;\n\n  /// Type for the Block descriptor for Blocks CodeGen.\n  ///\n  /// Since this is only used for generation of debug info, it is not\n  /// serialized.\n  mutable RecordDecl *BlockDescriptorExtendedType = nullptr;\n\n  /// Declaration for the CUDA cudaConfigureCall function.\n  FunctionDecl *cudaConfigureCallDecl = nullptr;\n\n  /// Keeps track of all declaration attributes.\n  ///\n  /// Since so few decls have attrs, we keep them in a hash map instead of\n  /// wasting space in the Decl class.\n  llvm::DenseMap<const Decl*, AttrVec*> DeclAttrs;\n\n  /// A mapping from non-redeclarable declarations in modules that were\n  /// merged with other declarations to the canonical declaration that they were\n  /// merged into.\n  llvm::DenseMap<Decl*, Decl*> MergedDecls;\n\n  /// A mapping from a defining declaration to a list of modules (other\n  /// than the owning module of the declaration) that contain merged\n  /// definitions of that entity.\n  llvm::DenseMap<NamedDecl*, llvm::TinyPtrVector<Module*>> MergedDefModules;\n\n  /// Initializers for a module, in order. Each Decl will be either\n  /// something that has a semantic effect on startup (such as a variable with\n  /// a non-constant initializer), or an ImportDecl (which recursively triggers\n  /// initialization of another module).\n  struct PerModuleInitializers {\n    llvm::SmallVector<Decl*, 4> Initializers;\n    llvm::SmallVector<uint32_t, 4> LazyInitializers;\n\n    void resolve(ASTContext &Ctx);\n  };\n  llvm::DenseMap<Module*, PerModuleInitializers*> ModuleInitializers;\n\n  ASTContext &this_() { return *this; }\n\npublic:\n  /// A type synonym for the TemplateOrInstantiation mapping.\n  using TemplateOrSpecializationInfo =\n      llvm::PointerUnion<VarTemplateDecl *, MemberSpecializationInfo *>;\n\nprivate:\n  friend class ASTDeclReader;\n  friend class ASTReader;\n  friend class ASTWriter;\n  template <class> friend class serialization::AbstractTypeReader;\n  friend class CXXRecordDecl;\n\n  /// A mapping to contain the template or declaration that\n  /// a variable declaration describes or was instantiated from,\n  /// respectively.\n  ///\n  /// For non-templates, this value will be NULL. For variable\n  /// declarations that describe a variable template, this will be a\n  /// pointer to a VarTemplateDecl. For static data members\n  /// of class template specializations, this will be the\n  /// MemberSpecializationInfo referring to the member variable that was\n  /// instantiated or specialized. Thus, the mapping will keep track of\n  /// the static data member templates from which static data members of\n  /// class template specializations were instantiated.\n  ///\n  /// Given the following example:\n  ///\n  /// \\code\n  /// template<typename T>\n  /// struct X {\n  ///   static T value;\n  /// };\n  ///\n  /// template<typename T>\n  ///   T X<T>::value = T(17);\n  ///\n  /// int *x = &X<int>::value;\n  /// \\endcode\n  ///\n  /// This mapping will contain an entry that maps from the VarDecl for\n  /// X<int>::value to the corresponding VarDecl for X<T>::value (within the\n  /// class template X) and will be marked TSK_ImplicitInstantiation.\n  llvm::DenseMap<const VarDecl *, TemplateOrSpecializationInfo>\n  TemplateOrInstantiation;\n\n  /// Keeps track of the declaration from which a using declaration was\n  /// created during instantiation.\n  ///\n  /// The source and target declarations are always a UsingDecl, an\n  /// UnresolvedUsingValueDecl, or an UnresolvedUsingTypenameDecl.\n  ///\n  /// For example:\n  /// \\code\n  /// template<typename T>\n  /// struct A {\n  ///   void f();\n  /// };\n  ///\n  /// template<typename T>\n  /// struct B : A<T> {\n  ///   using A<T>::f;\n  /// };\n  ///\n  /// template struct B<int>;\n  /// \\endcode\n  ///\n  /// This mapping will contain an entry that maps from the UsingDecl in\n  /// B<int> to the UnresolvedUsingDecl in B<T>.\n  llvm::DenseMap<NamedDecl *, NamedDecl *> InstantiatedFromUsingDecl;\n\n  llvm::DenseMap<UsingShadowDecl*, UsingShadowDecl*>\n    InstantiatedFromUsingShadowDecl;\n\n  llvm::DenseMap<FieldDecl *, FieldDecl *> InstantiatedFromUnnamedFieldDecl;\n\n  /// Mapping that stores the methods overridden by a given C++\n  /// member function.\n  ///\n  /// Since most C++ member functions aren't virtual and therefore\n  /// don't override anything, we store the overridden functions in\n  /// this map on the side rather than within the CXXMethodDecl structure.\n  using CXXMethodVector = llvm::TinyPtrVector<const CXXMethodDecl *>;\n  llvm::DenseMap<const CXXMethodDecl *, CXXMethodVector> OverriddenMethods;\n\n  /// Mapping from each declaration context to its corresponding\n  /// mangling numbering context (used for constructs like lambdas which\n  /// need to be consistently numbered for the mangler).\n  llvm::DenseMap<const DeclContext *, std::unique_ptr<MangleNumberingContext>>\n      MangleNumberingContexts;\n  llvm::DenseMap<const Decl *, std::unique_ptr<MangleNumberingContext>>\n      ExtraMangleNumberingContexts;\n\n  /// Side-table of mangling numbers for declarations which rarely\n  /// need them (like static local vars).\n  llvm::MapVector<const NamedDecl *, unsigned> MangleNumbers;\n  llvm::MapVector<const VarDecl *, unsigned> StaticLocalNumbers;\n  /// Mapping the associated device lambda mangling number if present.\n  mutable llvm::DenseMap<const CXXRecordDecl *, unsigned>\n      DeviceLambdaManglingNumbers;\n\n  /// Mapping that stores parameterIndex values for ParmVarDecls when\n  /// that value exceeds the bitfield size of ParmVarDeclBits.ParameterIndex.\n  using ParameterIndexTable = llvm::DenseMap<const VarDecl *, unsigned>;\n  ParameterIndexTable ParamIndices;\n\n  ImportDecl *FirstLocalImport = nullptr;\n  ImportDecl *LastLocalImport = nullptr;\n\n  TranslationUnitDecl *TUDecl;\n  mutable ExternCContextDecl *ExternCContext = nullptr;\n  mutable BuiltinTemplateDecl *MakeIntegerSeqDecl = nullptr;\n  mutable BuiltinTemplateDecl *TypePackElementDecl = nullptr;\n\n  /// The associated SourceManager object.\n  SourceManager &SourceMgr;\n\n  /// The language options used to create the AST associated with\n  ///  this ASTContext object.\n  LangOptions &LangOpts;\n\n  /// NoSanitizeList object that is used by sanitizers to decide which\n  /// entities should not be instrumented.\n  std::unique_ptr<NoSanitizeList> NoSanitizeL;\n\n  /// Function filtering mechanism to determine whether a given function\n  /// should be imbued with the XRay \"always\" or \"never\" attributes.\n  std::unique_ptr<XRayFunctionFilter> XRayFilter;\n\n  /// ProfileList object that is used by the profile instrumentation\n  /// to decide which entities should be instrumented.\n  std::unique_ptr<ProfileList> ProfList;\n\n  /// The allocator used to create AST objects.\n  ///\n  /// AST objects are never destructed; rather, all memory associated with the\n  /// AST objects will be released when the ASTContext itself is destroyed.\n  mutable llvm::BumpPtrAllocator BumpAlloc;\n\n  /// Allocator for partial diagnostics.\n  PartialDiagnostic::DiagStorageAllocator DiagAllocator;\n\n  /// The current C++ ABI.\n  std::unique_ptr<CXXABI> ABI;\n  CXXABI *createCXXABI(const TargetInfo &T);\n\n  /// The logical -> physical address space map.\n  const LangASMap *AddrSpaceMap = nullptr;\n\n  /// Address space map mangling must be used with language specific\n  /// address spaces (e.g. OpenCL/CUDA)\n  bool AddrSpaceMapMangling;\n\n  const TargetInfo *Target = nullptr;\n  const TargetInfo *AuxTarget = nullptr;\n  clang::PrintingPolicy PrintingPolicy;\n  std::unique_ptr<interp::Context> InterpContext;\n  std::unique_ptr<ParentMapContext> ParentMapCtx;\n\n  /// Keeps track of the deallocated DeclListNodes for future reuse.\n  DeclListNode *ListNodeFreeList = nullptr;\n\npublic:\n  IdentifierTable &Idents;\n  SelectorTable &Selectors;\n  Builtin::Context &BuiltinInfo;\n  mutable DeclarationNameTable DeclarationNames;\n  IntrusiveRefCntPtr<ExternalASTSource> ExternalSource;\n  ASTMutationListener *Listener = nullptr;\n\n  /// Returns the clang bytecode interpreter context.\n  interp::Context &getInterpContext();\n\n  /// Returns the dynamic AST node parent map context.\n  ParentMapContext &getParentMapContext();\n\n  // A traversal scope limits the parts of the AST visible to certain analyses.\n  // RecursiveASTVisitor::TraverseAST will only visit reachable nodes, and\n  // getParents() will only observe reachable parent edges.\n  //\n  // The scope is defined by a set of \"top-level\" declarations.\n  // Initially, it is the entire TU: {getTranslationUnitDecl()}.\n  // Changing the scope clears the parent cache, which is expensive to rebuild.\n  std::vector<Decl *> getTraversalScope() const { return TraversalScope; }\n  void setTraversalScope(const std::vector<Decl *> &);\n\n  /// Forwards to get node parents from the ParentMapContext. New callers should\n  /// use ParentMapContext::getParents() directly.\n  template <typename NodeT> DynTypedNodeList getParents(const NodeT &Node);\n\n  const clang::PrintingPolicy &getPrintingPolicy() const {\n    return PrintingPolicy;\n  }\n\n  void setPrintingPolicy(const clang::PrintingPolicy &Policy) {\n    PrintingPolicy = Policy;\n  }\n\n  SourceManager& getSourceManager() { return SourceMgr; }\n  const SourceManager& getSourceManager() const { return SourceMgr; }\n\n  llvm::BumpPtrAllocator &getAllocator() const {\n    return BumpAlloc;\n  }\n\n  void *Allocate(size_t Size, unsigned Align = 8) const {\n    return BumpAlloc.Allocate(Size, Align);\n  }\n  template <typename T> T *Allocate(size_t Num = 1) const {\n    return static_cast<T *>(Allocate(Num * sizeof(T), alignof(T)));\n  }\n  void Deallocate(void *Ptr) const {}\n\n  /// Allocates a \\c DeclListNode or returns one from the \\c ListNodeFreeList\n  /// pool.\n  DeclListNode *AllocateDeclListNode(clang::NamedDecl *ND) {\n    if (DeclListNode *Alloc = ListNodeFreeList) {\n      ListNodeFreeList = Alloc->Rest.dyn_cast<DeclListNode*>();\n      Alloc->D = ND;\n      Alloc->Rest = nullptr;\n      return Alloc;\n    }\n    return new (*this) DeclListNode(ND);\n  }\n  /// Deallcates a \\c DeclListNode by returning it to the \\c ListNodeFreeList\n  /// pool.\n  void DeallocateDeclListNode(DeclListNode *N) {\n    N->Rest = ListNodeFreeList;\n    ListNodeFreeList = N;\n  }\n\n  /// Return the total amount of physical memory allocated for representing\n  /// AST nodes and type information.\n  size_t getASTAllocatedMemory() const {\n    return BumpAlloc.getTotalMemory();\n  }\n\n  /// Return the total memory used for various side tables.\n  size_t getSideTableAllocatedMemory() const;\n\n  PartialDiagnostic::DiagStorageAllocator &getDiagAllocator() {\n    return DiagAllocator;\n  }\n\n  const TargetInfo &getTargetInfo() const { return *Target; }\n  const TargetInfo *getAuxTargetInfo() const { return AuxTarget; }\n\n  /// getIntTypeForBitwidth -\n  /// sets integer QualTy according to specified details:\n  /// bitwidth, signed/unsigned.\n  /// Returns empty type if there is no appropriate target types.\n  QualType getIntTypeForBitwidth(unsigned DestWidth,\n                                 unsigned Signed) const;\n\n  /// getRealTypeForBitwidth -\n  /// sets floating point QualTy according to specified bitwidth.\n  /// Returns empty type if there is no appropriate target types.\n  QualType getRealTypeForBitwidth(unsigned DestWidth, bool ExplicitIEEE) const;\n\n  bool AtomicUsesUnsupportedLibcall(const AtomicExpr *E) const;\n\n  const LangOptions& getLangOpts() const { return LangOpts; }\n\n  // If this condition is false, typo correction must be performed eagerly\n  // rather than delayed in many places, as it makes use of dependent types.\n  // the condition is false for clang's C-only codepath, as it doesn't support\n  // dependent types yet.\n  bool isDependenceAllowed() const {\n    return LangOpts.CPlusPlus || LangOpts.RecoveryAST;\n  }\n\n  const NoSanitizeList &getNoSanitizeList() const { return *NoSanitizeL; }\n\n  const XRayFunctionFilter &getXRayFilter() const {\n    return *XRayFilter;\n  }\n\n  const ProfileList &getProfileList() const { return *ProfList; }\n\n  DiagnosticsEngine &getDiagnostics() const;\n\n  FullSourceLoc getFullLoc(SourceLocation Loc) const {\n    return FullSourceLoc(Loc,SourceMgr);\n  }\n\n  /// All comments in this translation unit.\n  RawCommentList Comments;\n\n  /// True if comments are already loaded from ExternalASTSource.\n  mutable bool CommentsLoaded = false;\n\n  /// Mapping from declaration to directly attached comment.\n  ///\n  /// Raw comments are owned by Comments list.  This mapping is populated\n  /// lazily.\n  mutable llvm::DenseMap<const Decl *, const RawComment *> DeclRawComments;\n\n  /// Mapping from canonical declaration to the first redeclaration in chain\n  /// that has a comment attached.\n  ///\n  /// Raw comments are owned by Comments list.  This mapping is populated\n  /// lazily.\n  mutable llvm::DenseMap<const Decl *, const Decl *> RedeclChainComments;\n\n  /// Keeps track of redeclaration chains that don't have any comment attached.\n  /// Mapping from canonical declaration to redeclaration chain that has no\n  /// comments attached to any redeclaration. Specifically it's mapping to\n  /// the last redeclaration we've checked.\n  ///\n  /// Shall not contain declarations that have comments attached to any\n  /// redeclaration in their chain.\n  mutable llvm::DenseMap<const Decl *, const Decl *> CommentlessRedeclChains;\n\n  /// Mapping from declarations to parsed comments attached to any\n  /// redeclaration.\n  mutable llvm::DenseMap<const Decl *, comments::FullComment *> ParsedComments;\n\n  /// Attaches \\p Comment to \\p OriginalD and to its redeclaration chain\n  /// and removes the redeclaration chain from the set of commentless chains.\n  ///\n  /// Don't do anything if a comment has already been attached to \\p OriginalD\n  /// or its redeclaration chain.\n  void cacheRawCommentForDecl(const Decl &OriginalD,\n                              const RawComment &Comment) const;\n\n  /// \\returns searches \\p CommentsInFile for doc comment for \\p D.\n  ///\n  /// \\p RepresentativeLocForDecl is used as a location for searching doc\n  /// comments. \\p CommentsInFile is a mapping offset -> comment of files in the\n  /// same file where \\p RepresentativeLocForDecl is.\n  RawComment *getRawCommentForDeclNoCacheImpl(\n      const Decl *D, const SourceLocation RepresentativeLocForDecl,\n      const std::map<unsigned, RawComment *> &CommentsInFile) const;\n\n  /// Return the documentation comment attached to a given declaration,\n  /// without looking into cache.\n  RawComment *getRawCommentForDeclNoCache(const Decl *D) const;\n\npublic:\n  void addComment(const RawComment &RC);\n\n  /// Return the documentation comment attached to a given declaration.\n  /// Returns nullptr if no comment is attached.\n  ///\n  /// \\param OriginalDecl if not nullptr, is set to declaration AST node that\n  /// had the comment, if the comment we found comes from a redeclaration.\n  const RawComment *\n  getRawCommentForAnyRedecl(const Decl *D,\n                            const Decl **OriginalDecl = nullptr) const;\n\n  /// Searches existing comments for doc comments that should be attached to \\p\n  /// Decls. If any doc comment is found, it is parsed.\n  ///\n  /// Requirement: All \\p Decls are in the same file.\n  ///\n  /// If the last comment in the file is already attached we assume\n  /// there are not comments left to be attached to \\p Decls.\n  void attachCommentsToJustParsedDecls(ArrayRef<Decl *> Decls,\n                                       const Preprocessor *PP);\n\n  /// Return parsed documentation comment attached to a given declaration.\n  /// Returns nullptr if no comment is attached.\n  ///\n  /// \\param PP the Preprocessor used with this TU.  Could be nullptr if\n  /// preprocessor is not available.\n  comments::FullComment *getCommentForDecl(const Decl *D,\n                                           const Preprocessor *PP) const;\n\n  /// Return parsed documentation comment attached to a given declaration.\n  /// Returns nullptr if no comment is attached. Does not look at any\n  /// redeclarations of the declaration.\n  comments::FullComment *getLocalCommentForDeclUncached(const Decl *D) const;\n\n  comments::FullComment *cloneFullComment(comments::FullComment *FC,\n                                         const Decl *D) const;\n\nprivate:\n  mutable comments::CommandTraits CommentCommandTraits;\n\n  /// Iterator that visits import declarations.\n  class import_iterator {\n    ImportDecl *Import = nullptr;\n\n  public:\n    using value_type = ImportDecl *;\n    using reference = ImportDecl *;\n    using pointer = ImportDecl *;\n    using difference_type = int;\n    using iterator_category = std::forward_iterator_tag;\n\n    import_iterator() = default;\n    explicit import_iterator(ImportDecl *Import) : Import(Import) {}\n\n    reference operator*() const { return Import; }\n    pointer operator->() const { return Import; }\n\n    import_iterator &operator++() {\n      Import = ASTContext::getNextLocalImport(Import);\n      return *this;\n    }\n\n    import_iterator operator++(int) {\n      import_iterator Other(*this);\n      ++(*this);\n      return Other;\n    }\n\n    friend bool operator==(import_iterator X, import_iterator Y) {\n      return X.Import == Y.Import;\n    }\n\n    friend bool operator!=(import_iterator X, import_iterator Y) {\n      return X.Import != Y.Import;\n    }\n  };\n\npublic:\n  comments::CommandTraits &getCommentCommandTraits() const {\n    return CommentCommandTraits;\n  }\n\n  /// Retrieve the attributes for the given declaration.\n  AttrVec& getDeclAttrs(const Decl *D);\n\n  /// Erase the attributes corresponding to the given declaration.\n  void eraseDeclAttrs(const Decl *D);\n\n  /// If this variable is an instantiated static data member of a\n  /// class template specialization, returns the templated static data member\n  /// from which it was instantiated.\n  // FIXME: Remove ?\n  MemberSpecializationInfo *getInstantiatedFromStaticDataMember(\n                                                           const VarDecl *Var);\n\n  TemplateOrSpecializationInfo\n  getTemplateOrSpecializationInfo(const VarDecl *Var);\n\n  /// Note that the static data member \\p Inst is an instantiation of\n  /// the static data member template \\p Tmpl of a class template.\n  void setInstantiatedFromStaticDataMember(VarDecl *Inst, VarDecl *Tmpl,\n                                           TemplateSpecializationKind TSK,\n                        SourceLocation PointOfInstantiation = SourceLocation());\n\n  void setTemplateOrSpecializationInfo(VarDecl *Inst,\n                                       TemplateOrSpecializationInfo TSI);\n\n  /// If the given using decl \\p Inst is an instantiation of a\n  /// (possibly unresolved) using decl from a template instantiation,\n  /// return it.\n  NamedDecl *getInstantiatedFromUsingDecl(NamedDecl *Inst);\n\n  /// Remember that the using decl \\p Inst is an instantiation\n  /// of the using decl \\p Pattern of a class template.\n  void setInstantiatedFromUsingDecl(NamedDecl *Inst, NamedDecl *Pattern);\n\n  void setInstantiatedFromUsingShadowDecl(UsingShadowDecl *Inst,\n                                          UsingShadowDecl *Pattern);\n  UsingShadowDecl *getInstantiatedFromUsingShadowDecl(UsingShadowDecl *Inst);\n\n  FieldDecl *getInstantiatedFromUnnamedFieldDecl(FieldDecl *Field);\n\n  void setInstantiatedFromUnnamedFieldDecl(FieldDecl *Inst, FieldDecl *Tmpl);\n\n  // Access to the set of methods overridden by the given C++ method.\n  using overridden_cxx_method_iterator = CXXMethodVector::const_iterator;\n  overridden_cxx_method_iterator\n  overridden_methods_begin(const CXXMethodDecl *Method) const;\n\n  overridden_cxx_method_iterator\n  overridden_methods_end(const CXXMethodDecl *Method) const;\n\n  unsigned overridden_methods_size(const CXXMethodDecl *Method) const;\n\n  using overridden_method_range =\n      llvm::iterator_range<overridden_cxx_method_iterator>;\n\n  overridden_method_range overridden_methods(const CXXMethodDecl *Method) const;\n\n  /// Note that the given C++ \\p Method overrides the given \\p\n  /// Overridden method.\n  void addOverriddenMethod(const CXXMethodDecl *Method,\n                           const CXXMethodDecl *Overridden);\n\n  /// Return C++ or ObjC overridden methods for the given \\p Method.\n  ///\n  /// An ObjC method is considered to override any method in the class's\n  /// base classes, its protocols, or its categories' protocols, that has\n  /// the same selector and is of the same kind (class or instance).\n  /// A method in an implementation is not considered as overriding the same\n  /// method in the interface or its categories.\n  void getOverriddenMethods(\n                        const NamedDecl *Method,\n                        SmallVectorImpl<const NamedDecl *> &Overridden) const;\n\n  /// Notify the AST context that a new import declaration has been\n  /// parsed or implicitly created within this translation unit.\n  void addedLocalImportDecl(ImportDecl *Import);\n\n  static ImportDecl *getNextLocalImport(ImportDecl *Import) {\n    return Import->getNextLocalImport();\n  }\n\n  using import_range = llvm::iterator_range<import_iterator>;\n\n  import_range local_imports() const {\n    return import_range(import_iterator(FirstLocalImport), import_iterator());\n  }\n\n  Decl *getPrimaryMergedDecl(Decl *D) {\n    Decl *Result = MergedDecls.lookup(D);\n    return Result ? Result : D;\n  }\n  void setPrimaryMergedDecl(Decl *D, Decl *Primary) {\n    MergedDecls[D] = Primary;\n  }\n\n  /// Note that the definition \\p ND has been merged into module \\p M,\n  /// and should be visible whenever \\p M is visible.\n  void mergeDefinitionIntoModule(NamedDecl *ND, Module *M,\n                                 bool NotifyListeners = true);\n\n  /// Clean up the merged definition list. Call this if you might have\n  /// added duplicates into the list.\n  void deduplicateMergedDefinitonsFor(NamedDecl *ND);\n\n  /// Get the additional modules in which the definition \\p Def has\n  /// been merged.\n  ArrayRef<Module*> getModulesWithMergedDefinition(const NamedDecl *Def);\n\n  /// Add a declaration to the list of declarations that are initialized\n  /// for a module. This will typically be a global variable (with internal\n  /// linkage) that runs module initializers, such as the iostream initializer,\n  /// or an ImportDecl nominating another module that has initializers.\n  void addModuleInitializer(Module *M, Decl *Init);\n\n  void addLazyModuleInitializers(Module *M, ArrayRef<uint32_t> IDs);\n\n  /// Get the initializations to perform when importing a module, if any.\n  ArrayRef<Decl*> getModuleInitializers(Module *M);\n\n  TranslationUnitDecl *getTranslationUnitDecl() const { return TUDecl; }\n\n  ExternCContextDecl *getExternCContextDecl() const;\n  BuiltinTemplateDecl *getMakeIntegerSeqDecl() const;\n  BuiltinTemplateDecl *getTypePackElementDecl() const;\n\n  // Builtin Types.\n  CanQualType VoidTy;\n  CanQualType BoolTy;\n  CanQualType CharTy;\n  CanQualType WCharTy;  // [C++ 3.9.1p5].\n  CanQualType WideCharTy; // Same as WCharTy in C++, integer type in C99.\n  CanQualType WIntTy;   // [C99 7.24.1], integer type unchanged by default promotions.\n  CanQualType Char8Ty;  // [C++20 proposal]\n  CanQualType Char16Ty; // [C++0x 3.9.1p5], integer type in C99.\n  CanQualType Char32Ty; // [C++0x 3.9.1p5], integer type in C99.\n  CanQualType SignedCharTy, ShortTy, IntTy, LongTy, LongLongTy, Int128Ty;\n  CanQualType UnsignedCharTy, UnsignedShortTy, UnsignedIntTy, UnsignedLongTy;\n  CanQualType UnsignedLongLongTy, UnsignedInt128Ty;\n  CanQualType FloatTy, DoubleTy, LongDoubleTy, Float128Ty;\n  CanQualType ShortAccumTy, AccumTy,\n      LongAccumTy;  // ISO/IEC JTC1 SC22 WG14 N1169 Extension\n  CanQualType UnsignedShortAccumTy, UnsignedAccumTy, UnsignedLongAccumTy;\n  CanQualType ShortFractTy, FractTy, LongFractTy;\n  CanQualType UnsignedShortFractTy, UnsignedFractTy, UnsignedLongFractTy;\n  CanQualType SatShortAccumTy, SatAccumTy, SatLongAccumTy;\n  CanQualType SatUnsignedShortAccumTy, SatUnsignedAccumTy,\n      SatUnsignedLongAccumTy;\n  CanQualType SatShortFractTy, SatFractTy, SatLongFractTy;\n  CanQualType SatUnsignedShortFractTy, SatUnsignedFractTy,\n      SatUnsignedLongFractTy;\n  CanQualType HalfTy; // [OpenCL 6.1.1.1], ARM NEON\n  CanQualType BFloat16Ty;\n  CanQualType Float16Ty; // C11 extension ISO/IEC TS 18661-3\n  CanQualType FloatComplexTy, DoubleComplexTy, LongDoubleComplexTy;\n  CanQualType Float128ComplexTy;\n  CanQualType VoidPtrTy, NullPtrTy;\n  CanQualType DependentTy, OverloadTy, BoundMemberTy, UnknownAnyTy;\n  CanQualType BuiltinFnTy;\n  CanQualType PseudoObjectTy, ARCUnbridgedCastTy;\n  CanQualType ObjCBuiltinIdTy, ObjCBuiltinClassTy, ObjCBuiltinSelTy;\n  CanQualType ObjCBuiltinBoolTy;\n#define IMAGE_TYPE(ImgType, Id, SingletonId, Access, Suffix) \\\n  CanQualType SingletonId;\n#include \"clang/Basic/OpenCLImageTypes.def\"\n  CanQualType OCLSamplerTy, OCLEventTy, OCLClkEventTy;\n  CanQualType OCLQueueTy, OCLReserveIDTy;\n  CanQualType IncompleteMatrixIdxTy;\n  CanQualType OMPArraySectionTy, OMPArrayShapingTy, OMPIteratorTy;\n#define EXT_OPAQUE_TYPE(ExtType, Id, Ext) \\\n  CanQualType Id##Ty;\n#include \"clang/Basic/OpenCLExtensionTypes.def\"\n#define SVE_TYPE(Name, Id, SingletonId) \\\n  CanQualType SingletonId;\n#include \"clang/Basic/AArch64SVEACLETypes.def\"\n#define PPC_VECTOR_TYPE(Name, Id, Size) \\\n  CanQualType Id##Ty;\n#include \"clang/Basic/PPCTypes.def\"\n#define RVV_TYPE(Name, Id, SingletonId) \\\n  CanQualType SingletonId;\n#include \"clang/Basic/RISCVVTypes.def\"\n\n  // Types for deductions in C++0x [stmt.ranged]'s desugaring. Built on demand.\n  mutable QualType AutoDeductTy;     // Deduction against 'auto'.\n  mutable QualType AutoRRefDeductTy; // Deduction against 'auto &&'.\n\n  // Decl used to help define __builtin_va_list for some targets.\n  // The decl is built when constructing 'BuiltinVaListDecl'.\n  mutable Decl *VaListTagDecl = nullptr;\n\n  // Implicitly-declared type 'struct _GUID'.\n  mutable TagDecl *MSGuidTagDecl = nullptr;\n\n  /// Keep track of CUDA/HIP static device variables referenced by host code.\n  llvm::DenseSet<const VarDecl *> CUDAStaticDeviceVarReferencedByHost;\n\n  ASTContext(LangOptions &LOpts, SourceManager &SM, IdentifierTable &idents,\n             SelectorTable &sels, Builtin::Context &builtins);\n  ASTContext(const ASTContext &) = delete;\n  ASTContext &operator=(const ASTContext &) = delete;\n  ~ASTContext();\n\n  /// Attach an external AST source to the AST context.\n  ///\n  /// The external AST source provides the ability to load parts of\n  /// the abstract syntax tree as needed from some external storage,\n  /// e.g., a precompiled header.\n  void setExternalSource(IntrusiveRefCntPtr<ExternalASTSource> Source);\n\n  /// Retrieve a pointer to the external AST source associated\n  /// with this AST context, if any.\n  ExternalASTSource *getExternalSource() const {\n    return ExternalSource.get();\n  }\n\n  /// Attach an AST mutation listener to the AST context.\n  ///\n  /// The AST mutation listener provides the ability to track modifications to\n  /// the abstract syntax tree entities committed after they were initially\n  /// created.\n  void setASTMutationListener(ASTMutationListener *Listener) {\n    this->Listener = Listener;\n  }\n\n  /// Retrieve a pointer to the AST mutation listener associated\n  /// with this AST context, if any.\n  ASTMutationListener *getASTMutationListener() const { return Listener; }\n\n  void PrintStats() const;\n  const SmallVectorImpl<Type *>& getTypes() const { return Types; }\n\n  BuiltinTemplateDecl *buildBuiltinTemplateDecl(BuiltinTemplateKind BTK,\n                                                const IdentifierInfo *II) const;\n\n  /// Create a new implicit TU-level CXXRecordDecl or RecordDecl\n  /// declaration.\n  RecordDecl *buildImplicitRecord(StringRef Name,\n                                  RecordDecl::TagKind TK = TTK_Struct) const;\n\n  /// Create a new implicit TU-level typedef declaration.\n  TypedefDecl *buildImplicitTypedef(QualType T, StringRef Name) const;\n\n  /// Retrieve the declaration for the 128-bit signed integer type.\n  TypedefDecl *getInt128Decl() const;\n\n  /// Retrieve the declaration for the 128-bit unsigned integer type.\n  TypedefDecl *getUInt128Decl() const;\n\n  //===--------------------------------------------------------------------===//\n  //                           Type Constructors\n  //===--------------------------------------------------------------------===//\n\nprivate:\n  /// Return a type with extended qualifiers.\n  QualType getExtQualType(const Type *Base, Qualifiers Quals) const;\n\n  QualType getTypeDeclTypeSlow(const TypeDecl *Decl) const;\n\n  QualType getPipeType(QualType T, bool ReadOnly) const;\n\npublic:\n  /// Return the uniqued reference to the type for an address space\n  /// qualified type with the specified type and address space.\n  ///\n  /// The resulting type has a union of the qualifiers from T and the address\n  /// space. If T already has an address space specifier, it is silently\n  /// replaced.\n  QualType getAddrSpaceQualType(QualType T, LangAS AddressSpace) const;\n\n  /// Remove any existing address space on the type and returns the type\n  /// with qualifiers intact (or that's the idea anyway)\n  ///\n  /// The return type should be T with all prior qualifiers minus the address\n  /// space.\n  QualType removeAddrSpaceQualType(QualType T) const;\n\n  /// Apply Objective-C protocol qualifiers to the given type.\n  /// \\param allowOnPointerType specifies if we can apply protocol\n  /// qualifiers on ObjCObjectPointerType. It can be set to true when\n  /// constructing the canonical type of a Objective-C type parameter.\n  QualType applyObjCProtocolQualifiers(QualType type,\n      ArrayRef<ObjCProtocolDecl *> protocols, bool &hasError,\n      bool allowOnPointerType = false) const;\n\n  /// Return the uniqued reference to the type for an Objective-C\n  /// gc-qualified type.\n  ///\n  /// The resulting type has a union of the qualifiers from T and the gc\n  /// attribute.\n  QualType getObjCGCQualType(QualType T, Qualifiers::GC gcAttr) const;\n\n  /// Remove the existing address space on the type if it is a pointer size\n  /// address space and return the type with qualifiers intact.\n  QualType removePtrSizeAddrSpace(QualType T) const;\n\n  /// Return the uniqued reference to the type for a \\c restrict\n  /// qualified type.\n  ///\n  /// The resulting type has a union of the qualifiers from \\p T and\n  /// \\c restrict.\n  QualType getRestrictType(QualType T) const {\n    return T.withFastQualifiers(Qualifiers::Restrict);\n  }\n\n  /// Return the uniqued reference to the type for a \\c volatile\n  /// qualified type.\n  ///\n  /// The resulting type has a union of the qualifiers from \\p T and\n  /// \\c volatile.\n  QualType getVolatileType(QualType T) const {\n    return T.withFastQualifiers(Qualifiers::Volatile);\n  }\n\n  /// Return the uniqued reference to the type for a \\c const\n  /// qualified type.\n  ///\n  /// The resulting type has a union of the qualifiers from \\p T and \\c const.\n  ///\n  /// It can be reasonably expected that this will always be equivalent to\n  /// calling T.withConst().\n  QualType getConstType(QualType T) const { return T.withConst(); }\n\n  /// Change the ExtInfo on a function type.\n  const FunctionType *adjustFunctionType(const FunctionType *Fn,\n                                         FunctionType::ExtInfo EInfo);\n\n  /// Adjust the given function result type.\n  CanQualType getCanonicalFunctionResultType(QualType ResultType) const;\n\n  /// Change the result type of a function type once it is deduced.\n  void adjustDeducedFunctionResultType(FunctionDecl *FD, QualType ResultType);\n\n  /// Get a function type and produce the equivalent function type with the\n  /// specified exception specification. Type sugar that can be present on a\n  /// declaration of a function with an exception specification is permitted\n  /// and preserved. Other type sugar (for instance, typedefs) is not.\n  QualType getFunctionTypeWithExceptionSpec(\n      QualType Orig, const FunctionProtoType::ExceptionSpecInfo &ESI);\n\n  /// Determine whether two function types are the same, ignoring\n  /// exception specifications in cases where they're part of the type.\n  bool hasSameFunctionTypeIgnoringExceptionSpec(QualType T, QualType U);\n\n  /// Change the exception specification on a function once it is\n  /// delay-parsed, instantiated, or computed.\n  void adjustExceptionSpec(FunctionDecl *FD,\n                           const FunctionProtoType::ExceptionSpecInfo &ESI,\n                           bool AsWritten = false);\n\n  /// Get a function type and produce the equivalent function type where\n  /// pointer size address spaces in the return type and parameter tyeps are\n  /// replaced with the default address space.\n  QualType getFunctionTypeWithoutPtrSizes(QualType T);\n\n  /// Determine whether two function types are the same, ignoring pointer sizes\n  /// in the return type and parameter types.\n  bool hasSameFunctionTypeIgnoringPtrSizes(QualType T, QualType U);\n\n  /// Return the uniqued reference to the type for a complex\n  /// number with the specified element type.\n  QualType getComplexType(QualType T) const;\n  CanQualType getComplexType(CanQualType T) const {\n    return CanQualType::CreateUnsafe(getComplexType((QualType) T));\n  }\n\n  /// Return the uniqued reference to the type for a pointer to\n  /// the specified type.\n  QualType getPointerType(QualType T) const;\n  CanQualType getPointerType(CanQualType T) const {\n    return CanQualType::CreateUnsafe(getPointerType((QualType) T));\n  }\n\n  /// Return the uniqued reference to a type adjusted from the original\n  /// type to a new type.\n  QualType getAdjustedType(QualType Orig, QualType New) const;\n  CanQualType getAdjustedType(CanQualType Orig, CanQualType New) const {\n    return CanQualType::CreateUnsafe(\n        getAdjustedType((QualType)Orig, (QualType)New));\n  }\n\n  /// Return the uniqued reference to the decayed version of the given\n  /// type.  Can only be called on array and function types which decay to\n  /// pointer types.\n  QualType getDecayedType(QualType T) const;\n  CanQualType getDecayedType(CanQualType T) const {\n    return CanQualType::CreateUnsafe(getDecayedType((QualType) T));\n  }\n\n  /// Return the uniqued reference to the atomic type for the specified\n  /// type.\n  QualType getAtomicType(QualType T) const;\n\n  /// Return the uniqued reference to the type for a block of the\n  /// specified type.\n  QualType getBlockPointerType(QualType T) const;\n\n  /// Gets the struct used to keep track of the descriptor for pointer to\n  /// blocks.\n  QualType getBlockDescriptorType() const;\n\n  /// Return a read_only pipe type for the specified type.\n  QualType getReadPipeType(QualType T) const;\n\n  /// Return a write_only pipe type for the specified type.\n  QualType getWritePipeType(QualType T) const;\n\n  /// Return an extended integer type with the specified signedness and bit\n  /// count.\n  QualType getExtIntType(bool Unsigned, unsigned NumBits) const;\n\n  /// Return a dependent extended integer type with the specified signedness and\n  /// bit count.\n  QualType getDependentExtIntType(bool Unsigned, Expr *BitsExpr) const;\n\n  /// Gets the struct used to keep track of the extended descriptor for\n  /// pointer to blocks.\n  QualType getBlockDescriptorExtendedType() const;\n\n  /// Map an AST Type to an OpenCLTypeKind enum value.\n  OpenCLTypeKind getOpenCLTypeKind(const Type *T) const;\n\n  /// Get address space for OpenCL type.\n  LangAS getOpenCLTypeAddrSpace(const Type *T) const;\n\n  void setcudaConfigureCallDecl(FunctionDecl *FD) {\n    cudaConfigureCallDecl = FD;\n  }\n\n  FunctionDecl *getcudaConfigureCallDecl() {\n    return cudaConfigureCallDecl;\n  }\n\n  /// Returns true iff we need copy/dispose helpers for the given type.\n  bool BlockRequiresCopying(QualType Ty, const VarDecl *D);\n\n  /// Returns true, if given type has a known lifetime. HasByrefExtendedLayout\n  /// is set to false in this case. If HasByrefExtendedLayout returns true,\n  /// byref variable has extended lifetime.\n  bool getByrefLifetime(QualType Ty,\n                        Qualifiers::ObjCLifetime &Lifetime,\n                        bool &HasByrefExtendedLayout) const;\n\n  /// Return the uniqued reference to the type for an lvalue reference\n  /// to the specified type.\n  QualType getLValueReferenceType(QualType T, bool SpelledAsLValue = true)\n    const;\n\n  /// Return the uniqued reference to the type for an rvalue reference\n  /// to the specified type.\n  QualType getRValueReferenceType(QualType T) const;\n\n  /// Return the uniqued reference to the type for a member pointer to\n  /// the specified type in the specified class.\n  ///\n  /// The class \\p Cls is a \\c Type because it could be a dependent name.\n  QualType getMemberPointerType(QualType T, const Type *Cls) const;\n\n  /// Return a non-unique reference to the type for a variable array of\n  /// the specified element type.\n  QualType getVariableArrayType(QualType EltTy, Expr *NumElts,\n                                ArrayType::ArraySizeModifier ASM,\n                                unsigned IndexTypeQuals,\n                                SourceRange Brackets) const;\n\n  /// Return a non-unique reference to the type for a dependently-sized\n  /// array of the specified element type.\n  ///\n  /// FIXME: We will need these to be uniqued, or at least comparable, at some\n  /// point.\n  QualType getDependentSizedArrayType(QualType EltTy, Expr *NumElts,\n                                      ArrayType::ArraySizeModifier ASM,\n                                      unsigned IndexTypeQuals,\n                                      SourceRange Brackets) const;\n\n  /// Return a unique reference to the type for an incomplete array of\n  /// the specified element type.\n  QualType getIncompleteArrayType(QualType EltTy,\n                                  ArrayType::ArraySizeModifier ASM,\n                                  unsigned IndexTypeQuals) const;\n\n  /// Return the unique reference to the type for a constant array of\n  /// the specified element type.\n  QualType getConstantArrayType(QualType EltTy, const llvm::APInt &ArySize,\n                                const Expr *SizeExpr,\n                                ArrayType::ArraySizeModifier ASM,\n                                unsigned IndexTypeQuals) const;\n\n  /// Return a type for a constant array for a string literal of the\n  /// specified element type and length.\n  QualType getStringLiteralArrayType(QualType EltTy, unsigned Length) const;\n\n  /// Returns a vla type where known sizes are replaced with [*].\n  QualType getVariableArrayDecayedType(QualType Ty) const;\n\n  // Convenience struct to return information about a builtin vector type.\n  struct BuiltinVectorTypeInfo {\n    QualType ElementType;\n    llvm::ElementCount EC;\n    unsigned NumVectors;\n    BuiltinVectorTypeInfo(QualType ElementType, llvm::ElementCount EC,\n                          unsigned NumVectors)\n        : ElementType(ElementType), EC(EC), NumVectors(NumVectors) {}\n  };\n\n  /// Returns the element type, element count and number of vectors\n  /// (in case of tuple) for a builtin vector type.\n  BuiltinVectorTypeInfo\n  getBuiltinVectorTypeInfo(const BuiltinType *VecTy) const;\n\n  /// Return the unique reference to a scalable vector type of the specified\n  /// element type and scalable number of elements.\n  ///\n  /// \\pre \\p EltTy must be a built-in type.\n  QualType getScalableVectorType(QualType EltTy, unsigned NumElts) const;\n\n  /// Return the unique reference to a vector type of the specified\n  /// element type and size.\n  ///\n  /// \\pre \\p VectorType must be a built-in type.\n  QualType getVectorType(QualType VectorType, unsigned NumElts,\n                         VectorType::VectorKind VecKind) const;\n  /// Return the unique reference to the type for a dependently sized vector of\n  /// the specified element type.\n  QualType getDependentVectorType(QualType VectorType, Expr *SizeExpr,\n                                  SourceLocation AttrLoc,\n                                  VectorType::VectorKind VecKind) const;\n\n  /// Return the unique reference to an extended vector type\n  /// of the specified element type and size.\n  ///\n  /// \\pre \\p VectorType must be a built-in type.\n  QualType getExtVectorType(QualType VectorType, unsigned NumElts) const;\n\n  /// \\pre Return a non-unique reference to the type for a dependently-sized\n  /// vector of the specified element type.\n  ///\n  /// FIXME: We will need these to be uniqued, or at least comparable, at some\n  /// point.\n  QualType getDependentSizedExtVectorType(QualType VectorType,\n                                          Expr *SizeExpr,\n                                          SourceLocation AttrLoc) const;\n\n  /// Return the unique reference to the matrix type of the specified element\n  /// type and size\n  ///\n  /// \\pre \\p ElementType must be a valid matrix element type (see\n  /// MatrixType::isValidElementType).\n  QualType getConstantMatrixType(QualType ElementType, unsigned NumRows,\n                                 unsigned NumColumns) const;\n\n  /// Return the unique reference to the matrix type of the specified element\n  /// type and size\n  QualType getDependentSizedMatrixType(QualType ElementType, Expr *RowExpr,\n                                       Expr *ColumnExpr,\n                                       SourceLocation AttrLoc) const;\n\n  QualType getDependentAddressSpaceType(QualType PointeeType,\n                                        Expr *AddrSpaceExpr,\n                                        SourceLocation AttrLoc) const;\n\n  /// Return a K&R style C function type like 'int()'.\n  QualType getFunctionNoProtoType(QualType ResultTy,\n                                  const FunctionType::ExtInfo &Info) const;\n\n  QualType getFunctionNoProtoType(QualType ResultTy) const {\n    return getFunctionNoProtoType(ResultTy, FunctionType::ExtInfo());\n  }\n\n  /// Return a normal function type with a typed argument list.\n  QualType getFunctionType(QualType ResultTy, ArrayRef<QualType> Args,\n                           const FunctionProtoType::ExtProtoInfo &EPI) const {\n    return getFunctionTypeInternal(ResultTy, Args, EPI, false);\n  }\n\n  QualType adjustStringLiteralBaseType(QualType StrLTy) const;\n\nprivate:\n  /// Return a normal function type with a typed argument list.\n  QualType getFunctionTypeInternal(QualType ResultTy, ArrayRef<QualType> Args,\n                                   const FunctionProtoType::ExtProtoInfo &EPI,\n                                   bool OnlyWantCanonical) const;\n\npublic:\n  /// Return the unique reference to the type for the specified type\n  /// declaration.\n  QualType getTypeDeclType(const TypeDecl *Decl,\n                           const TypeDecl *PrevDecl = nullptr) const {\n    assert(Decl && \"Passed null for Decl param\");\n    if (Decl->TypeForDecl) return QualType(Decl->TypeForDecl, 0);\n\n    if (PrevDecl) {\n      assert(PrevDecl->TypeForDecl && \"previous decl has no TypeForDecl\");\n      Decl->TypeForDecl = PrevDecl->TypeForDecl;\n      return QualType(PrevDecl->TypeForDecl, 0);\n    }\n\n    return getTypeDeclTypeSlow(Decl);\n  }\n\n  /// Return the unique reference to the type for the specified\n  /// typedef-name decl.\n  QualType getTypedefType(const TypedefNameDecl *Decl,\n                          QualType Underlying = QualType()) const;\n\n  QualType getRecordType(const RecordDecl *Decl) const;\n\n  QualType getEnumType(const EnumDecl *Decl) const;\n\n  QualType getInjectedClassNameType(CXXRecordDecl *Decl, QualType TST) const;\n\n  QualType getAttributedType(attr::Kind attrKind,\n                             QualType modifiedType,\n                             QualType equivalentType);\n\n  QualType getSubstTemplateTypeParmType(const TemplateTypeParmType *Replaced,\n                                        QualType Replacement) const;\n  QualType getSubstTemplateTypeParmPackType(\n                                          const TemplateTypeParmType *Replaced,\n                                            const TemplateArgument &ArgPack);\n\n  QualType\n  getTemplateTypeParmType(unsigned Depth, unsigned Index,\n                          bool ParameterPack,\n                          TemplateTypeParmDecl *ParmDecl = nullptr) const;\n\n  QualType getTemplateSpecializationType(TemplateName T,\n                                         ArrayRef<TemplateArgument> Args,\n                                         QualType Canon = QualType()) const;\n\n  QualType\n  getCanonicalTemplateSpecializationType(TemplateName T,\n                                         ArrayRef<TemplateArgument> Args) const;\n\n  QualType getTemplateSpecializationType(TemplateName T,\n                                         const TemplateArgumentListInfo &Args,\n                                         QualType Canon = QualType()) const;\n\n  TypeSourceInfo *\n  getTemplateSpecializationTypeInfo(TemplateName T, SourceLocation TLoc,\n                                    const TemplateArgumentListInfo &Args,\n                                    QualType Canon = QualType()) const;\n\n  QualType getParenType(QualType NamedType) const;\n\n  QualType getMacroQualifiedType(QualType UnderlyingTy,\n                                 const IdentifierInfo *MacroII) const;\n\n  QualType getElaboratedType(ElaboratedTypeKeyword Keyword,\n                             NestedNameSpecifier *NNS, QualType NamedType,\n                             TagDecl *OwnedTagDecl = nullptr) const;\n  QualType getDependentNameType(ElaboratedTypeKeyword Keyword,\n                                NestedNameSpecifier *NNS,\n                                const IdentifierInfo *Name,\n                                QualType Canon = QualType()) const;\n\n  QualType getDependentTemplateSpecializationType(ElaboratedTypeKeyword Keyword,\n                                                  NestedNameSpecifier *NNS,\n                                                  const IdentifierInfo *Name,\n                                    const TemplateArgumentListInfo &Args) const;\n  QualType getDependentTemplateSpecializationType(\n      ElaboratedTypeKeyword Keyword, NestedNameSpecifier *NNS,\n      const IdentifierInfo *Name, ArrayRef<TemplateArgument> Args) const;\n\n  TemplateArgument getInjectedTemplateArg(NamedDecl *ParamDecl);\n\n  /// Get a template argument list with one argument per template parameter\n  /// in a template parameter list, such as for the injected class name of\n  /// a class template.\n  void getInjectedTemplateArgs(const TemplateParameterList *Params,\n                               SmallVectorImpl<TemplateArgument> &Args);\n\n  /// Form a pack expansion type with the given pattern.\n  /// \\param NumExpansions The number of expansions for the pack, if known.\n  /// \\param ExpectPackInType If \\c false, we should not expect \\p Pattern to\n  ///        contain an unexpanded pack. This only makes sense if the pack\n  ///        expansion is used in a context where the arity is inferred from\n  ///        elsewhere, such as if the pattern contains a placeholder type or\n  ///        if this is the canonical type of another pack expansion type.\n  QualType getPackExpansionType(QualType Pattern,\n                                Optional<unsigned> NumExpansions,\n                                bool ExpectPackInType = true);\n\n  QualType getObjCInterfaceType(const ObjCInterfaceDecl *Decl,\n                                ObjCInterfaceDecl *PrevDecl = nullptr) const;\n\n  /// Legacy interface: cannot provide type arguments or __kindof.\n  QualType getObjCObjectType(QualType Base,\n                             ObjCProtocolDecl * const *Protocols,\n                             unsigned NumProtocols) const;\n\n  QualType getObjCObjectType(QualType Base,\n                             ArrayRef<QualType> typeArgs,\n                             ArrayRef<ObjCProtocolDecl *> protocols,\n                             bool isKindOf) const;\n\n  QualType getObjCTypeParamType(const ObjCTypeParamDecl *Decl,\n                                ArrayRef<ObjCProtocolDecl *> protocols) const;\n  void adjustObjCTypeParamBoundType(const ObjCTypeParamDecl *Orig,\n                                    ObjCTypeParamDecl *New) const;\n\n  bool ObjCObjectAdoptsQTypeProtocols(QualType QT, ObjCInterfaceDecl *Decl);\n\n  /// QIdProtocolsAdoptObjCObjectProtocols - Checks that protocols in\n  /// QT's qualified-id protocol list adopt all protocols in IDecl's list\n  /// of protocols.\n  bool QIdProtocolsAdoptObjCObjectProtocols(QualType QT,\n                                            ObjCInterfaceDecl *IDecl);\n\n  /// Return a ObjCObjectPointerType type for the given ObjCObjectType.\n  QualType getObjCObjectPointerType(QualType OIT) const;\n\n  /// GCC extension.\n  QualType getTypeOfExprType(Expr *e) const;\n  QualType getTypeOfType(QualType t) const;\n\n  /// C++11 decltype.\n  QualType getDecltypeType(Expr *e, QualType UnderlyingType) const;\n\n  /// Unary type transforms\n  QualType getUnaryTransformType(QualType BaseType, QualType UnderlyingType,\n                                 UnaryTransformType::UTTKind UKind) const;\n\n  /// C++11 deduced auto type.\n  QualType getAutoType(QualType DeducedType, AutoTypeKeyword Keyword,\n                       bool IsDependent, bool IsPack = false,\n                       ConceptDecl *TypeConstraintConcept = nullptr,\n                       ArrayRef<TemplateArgument> TypeConstraintArgs ={}) const;\n\n  /// C++11 deduction pattern for 'auto' type.\n  QualType getAutoDeductType() const;\n\n  /// C++11 deduction pattern for 'auto &&' type.\n  QualType getAutoRRefDeductType() const;\n\n  /// C++17 deduced class template specialization type.\n  QualType getDeducedTemplateSpecializationType(TemplateName Template,\n                                                QualType DeducedType,\n                                                bool IsDependent) const;\n\n  /// Return the unique reference to the type for the specified TagDecl\n  /// (struct/union/class/enum) decl.\n  QualType getTagDeclType(const TagDecl *Decl) const;\n\n  /// Return the unique type for \"size_t\" (C99 7.17), defined in\n  /// <stddef.h>.\n  ///\n  /// The sizeof operator requires this (C99 6.5.3.4p4).\n  CanQualType getSizeType() const;\n\n  /// Return the unique signed counterpart of\n  /// the integer type corresponding to size_t.\n  CanQualType getSignedSizeType() const;\n\n  /// Return the unique type for \"intmax_t\" (C99 7.18.1.5), defined in\n  /// <stdint.h>.\n  CanQualType getIntMaxType() const;\n\n  /// Return the unique type for \"uintmax_t\" (C99 7.18.1.5), defined in\n  /// <stdint.h>.\n  CanQualType getUIntMaxType() const;\n\n  /// Return the unique wchar_t type available in C++ (and available as\n  /// __wchar_t as a Microsoft extension).\n  QualType getWCharType() const { return WCharTy; }\n\n  /// Return the type of wide characters. In C++, this returns the\n  /// unique wchar_t type. In C99, this returns a type compatible with the type\n  /// defined in <stddef.h> as defined by the target.\n  QualType getWideCharType() const { return WideCharTy; }\n\n  /// Return the type of \"signed wchar_t\".\n  ///\n  /// Used when in C++, as a GCC extension.\n  QualType getSignedWCharType() const;\n\n  /// Return the type of \"unsigned wchar_t\".\n  ///\n  /// Used when in C++, as a GCC extension.\n  QualType getUnsignedWCharType() const;\n\n  /// In C99, this returns a type compatible with the type\n  /// defined in <stddef.h> as defined by the target.\n  QualType getWIntType() const { return WIntTy; }\n\n  /// Return a type compatible with \"intptr_t\" (C99 7.18.1.4),\n  /// as defined by the target.\n  QualType getIntPtrType() const;\n\n  /// Return a type compatible with \"uintptr_t\" (C99 7.18.1.4),\n  /// as defined by the target.\n  QualType getUIntPtrType() const;\n\n  /// Return the unique type for \"ptrdiff_t\" (C99 7.17) defined in\n  /// <stddef.h>. Pointer - pointer requires this (C99 6.5.6p9).\n  QualType getPointerDiffType() const;\n\n  /// Return the unique unsigned counterpart of \"ptrdiff_t\"\n  /// integer type. The standard (C11 7.21.6.1p7) refers to this type\n  /// in the definition of %tu format specifier.\n  QualType getUnsignedPointerDiffType() const;\n\n  /// Return the unique type for \"pid_t\" defined in\n  /// <sys/types.h>. We need this to compute the correct type for vfork().\n  QualType getProcessIDType() const;\n\n  /// Return the C structure type used to represent constant CFStrings.\n  QualType getCFConstantStringType() const;\n\n  /// Returns the C struct type for objc_super\n  QualType getObjCSuperType() const;\n  void setObjCSuperType(QualType ST) { ObjCSuperType = ST; }\n\n  /// Get the structure type used to representation CFStrings, or NULL\n  /// if it hasn't yet been built.\n  QualType getRawCFConstantStringType() const {\n    if (CFConstantStringTypeDecl)\n      return getTypedefType(CFConstantStringTypeDecl);\n    return QualType();\n  }\n  void setCFConstantStringType(QualType T);\n  TypedefDecl *getCFConstantStringDecl() const;\n  RecordDecl *getCFConstantStringTagDecl() const;\n\n  // This setter/getter represents the ObjC type for an NSConstantString.\n  void setObjCConstantStringInterface(ObjCInterfaceDecl *Decl);\n  QualType getObjCConstantStringInterface() const {\n    return ObjCConstantStringType;\n  }\n\n  QualType getObjCNSStringType() const {\n    return ObjCNSStringType;\n  }\n\n  void setObjCNSStringType(QualType T) {\n    ObjCNSStringType = T;\n  }\n\n  /// Retrieve the type that \\c id has been defined to, which may be\n  /// different from the built-in \\c id if \\c id has been typedef'd.\n  QualType getObjCIdRedefinitionType() const {\n    if (ObjCIdRedefinitionType.isNull())\n      return getObjCIdType();\n    return ObjCIdRedefinitionType;\n  }\n\n  /// Set the user-written type that redefines \\c id.\n  void setObjCIdRedefinitionType(QualType RedefType) {\n    ObjCIdRedefinitionType = RedefType;\n  }\n\n  /// Retrieve the type that \\c Class has been defined to, which may be\n  /// different from the built-in \\c Class if \\c Class has been typedef'd.\n  QualType getObjCClassRedefinitionType() const {\n    if (ObjCClassRedefinitionType.isNull())\n      return getObjCClassType();\n    return ObjCClassRedefinitionType;\n  }\n\n  /// Set the user-written type that redefines 'SEL'.\n  void setObjCClassRedefinitionType(QualType RedefType) {\n    ObjCClassRedefinitionType = RedefType;\n  }\n\n  /// Retrieve the type that 'SEL' has been defined to, which may be\n  /// different from the built-in 'SEL' if 'SEL' has been typedef'd.\n  QualType getObjCSelRedefinitionType() const {\n    if (ObjCSelRedefinitionType.isNull())\n      return getObjCSelType();\n    return ObjCSelRedefinitionType;\n  }\n\n  /// Set the user-written type that redefines 'SEL'.\n  void setObjCSelRedefinitionType(QualType RedefType) {\n    ObjCSelRedefinitionType = RedefType;\n  }\n\n  /// Retrieve the identifier 'NSObject'.\n  IdentifierInfo *getNSObjectName() const {\n    if (!NSObjectName) {\n      NSObjectName = &Idents.get(\"NSObject\");\n    }\n\n    return NSObjectName;\n  }\n\n  /// Retrieve the identifier 'NSCopying'.\n  IdentifierInfo *getNSCopyingName() {\n    if (!NSCopyingName) {\n      NSCopyingName = &Idents.get(\"NSCopying\");\n    }\n\n    return NSCopyingName;\n  }\n\n  CanQualType getNSUIntegerType() const;\n\n  CanQualType getNSIntegerType() const;\n\n  /// Retrieve the identifier 'bool'.\n  IdentifierInfo *getBoolName() const {\n    if (!BoolName)\n      BoolName = &Idents.get(\"bool\");\n    return BoolName;\n  }\n\n  IdentifierInfo *getMakeIntegerSeqName() const {\n    if (!MakeIntegerSeqName)\n      MakeIntegerSeqName = &Idents.get(\"__make_integer_seq\");\n    return MakeIntegerSeqName;\n  }\n\n  IdentifierInfo *getTypePackElementName() const {\n    if (!TypePackElementName)\n      TypePackElementName = &Idents.get(\"__type_pack_element\");\n    return TypePackElementName;\n  }\n\n  /// Retrieve the Objective-C \"instancetype\" type, if already known;\n  /// otherwise, returns a NULL type;\n  QualType getObjCInstanceType() {\n    return getTypeDeclType(getObjCInstanceTypeDecl());\n  }\n\n  /// Retrieve the typedef declaration corresponding to the Objective-C\n  /// \"instancetype\" type.\n  TypedefDecl *getObjCInstanceTypeDecl();\n\n  /// Set the type for the C FILE type.\n  void setFILEDecl(TypeDecl *FILEDecl) { this->FILEDecl = FILEDecl; }\n\n  /// Retrieve the C FILE type.\n  QualType getFILEType() const {\n    if (FILEDecl)\n      return getTypeDeclType(FILEDecl);\n    return QualType();\n  }\n\n  /// Set the type for the C jmp_buf type.\n  void setjmp_bufDecl(TypeDecl *jmp_bufDecl) {\n    this->jmp_bufDecl = jmp_bufDecl;\n  }\n\n  /// Retrieve the C jmp_buf type.\n  QualType getjmp_bufType() const {\n    if (jmp_bufDecl)\n      return getTypeDeclType(jmp_bufDecl);\n    return QualType();\n  }\n\n  /// Set the type for the C sigjmp_buf type.\n  void setsigjmp_bufDecl(TypeDecl *sigjmp_bufDecl) {\n    this->sigjmp_bufDecl = sigjmp_bufDecl;\n  }\n\n  /// Retrieve the C sigjmp_buf type.\n  QualType getsigjmp_bufType() const {\n    if (sigjmp_bufDecl)\n      return getTypeDeclType(sigjmp_bufDecl);\n    return QualType();\n  }\n\n  /// Set the type for the C ucontext_t type.\n  void setucontext_tDecl(TypeDecl *ucontext_tDecl) {\n    this->ucontext_tDecl = ucontext_tDecl;\n  }\n\n  /// Retrieve the C ucontext_t type.\n  QualType getucontext_tType() const {\n    if (ucontext_tDecl)\n      return getTypeDeclType(ucontext_tDecl);\n    return QualType();\n  }\n\n  /// The result type of logical operations, '<', '>', '!=', etc.\n  QualType getLogicalOperationType() const {\n    return getLangOpts().CPlusPlus ? BoolTy : IntTy;\n  }\n\n  /// Emit the Objective-CC type encoding for the given type \\p T into\n  /// \\p S.\n  ///\n  /// If \\p Field is specified then record field names are also encoded.\n  void getObjCEncodingForType(QualType T, std::string &S,\n                              const FieldDecl *Field=nullptr,\n                              QualType *NotEncodedT=nullptr) const;\n\n  /// Emit the Objective-C property type encoding for the given\n  /// type \\p T into \\p S.\n  void getObjCEncodingForPropertyType(QualType T, std::string &S) const;\n\n  void getLegacyIntegralTypeEncoding(QualType &t) const;\n\n  /// Put the string version of the type qualifiers \\p QT into \\p S.\n  void getObjCEncodingForTypeQualifier(Decl::ObjCDeclQualifier QT,\n                                       std::string &S) const;\n\n  /// Emit the encoded type for the function \\p Decl into \\p S.\n  ///\n  /// This is in the same format as Objective-C method encodings.\n  ///\n  /// \\returns true if an error occurred (e.g., because one of the parameter\n  /// types is incomplete), false otherwise.\n  std::string getObjCEncodingForFunctionDecl(const FunctionDecl *Decl) const;\n\n  /// Emit the encoded type for the method declaration \\p Decl into\n  /// \\p S.\n  std::string getObjCEncodingForMethodDecl(const ObjCMethodDecl *Decl,\n                                           bool Extended = false) const;\n\n  /// Return the encoded type for this block declaration.\n  std::string getObjCEncodingForBlock(const BlockExpr *blockExpr) const;\n\n  /// getObjCEncodingForPropertyDecl - Return the encoded type for\n  /// this method declaration. If non-NULL, Container must be either\n  /// an ObjCCategoryImplDecl or ObjCImplementationDecl; it should\n  /// only be NULL when getting encodings for protocol properties.\n  std::string getObjCEncodingForPropertyDecl(const ObjCPropertyDecl *PD,\n                                             const Decl *Container) const;\n\n  bool ProtocolCompatibleWithProtocol(ObjCProtocolDecl *lProto,\n                                      ObjCProtocolDecl *rProto) const;\n\n  ObjCPropertyImplDecl *getObjCPropertyImplDeclForPropertyDecl(\n                                                  const ObjCPropertyDecl *PD,\n                                                  const Decl *Container) const;\n\n  /// Return the size of type \\p T for Objective-C encoding purpose,\n  /// in characters.\n  CharUnits getObjCEncodingTypeSize(QualType T) const;\n\n  /// Retrieve the typedef corresponding to the predefined \\c id type\n  /// in Objective-C.\n  TypedefDecl *getObjCIdDecl() const;\n\n  /// Represents the Objective-CC \\c id type.\n  ///\n  /// This is set up lazily, by Sema.  \\c id is always a (typedef for a)\n  /// pointer type, a pointer to a struct.\n  QualType getObjCIdType() const {\n    return getTypeDeclType(getObjCIdDecl());\n  }\n\n  /// Retrieve the typedef corresponding to the predefined 'SEL' type\n  /// in Objective-C.\n  TypedefDecl *getObjCSelDecl() const;\n\n  /// Retrieve the type that corresponds to the predefined Objective-C\n  /// 'SEL' type.\n  QualType getObjCSelType() const {\n    return getTypeDeclType(getObjCSelDecl());\n  }\n\n  /// Retrieve the typedef declaration corresponding to the predefined\n  /// Objective-C 'Class' type.\n  TypedefDecl *getObjCClassDecl() const;\n\n  /// Represents the Objective-C \\c Class type.\n  ///\n  /// This is set up lazily, by Sema.  \\c Class is always a (typedef for a)\n  /// pointer type, a pointer to a struct.\n  QualType getObjCClassType() const {\n    return getTypeDeclType(getObjCClassDecl());\n  }\n\n  /// Retrieve the Objective-C class declaration corresponding to\n  /// the predefined \\c Protocol class.\n  ObjCInterfaceDecl *getObjCProtocolDecl() const;\n\n  /// Retrieve declaration of 'BOOL' typedef\n  TypedefDecl *getBOOLDecl() const {\n    return BOOLDecl;\n  }\n\n  /// Save declaration of 'BOOL' typedef\n  void setBOOLDecl(TypedefDecl *TD) {\n    BOOLDecl = TD;\n  }\n\n  /// type of 'BOOL' type.\n  QualType getBOOLType() const {\n    return getTypeDeclType(getBOOLDecl());\n  }\n\n  /// Retrieve the type of the Objective-C \\c Protocol class.\n  QualType getObjCProtoType() const {\n    return getObjCInterfaceType(getObjCProtocolDecl());\n  }\n\n  /// Retrieve the C type declaration corresponding to the predefined\n  /// \\c __builtin_va_list type.\n  TypedefDecl *getBuiltinVaListDecl() const;\n\n  /// Retrieve the type of the \\c __builtin_va_list type.\n  QualType getBuiltinVaListType() const {\n    return getTypeDeclType(getBuiltinVaListDecl());\n  }\n\n  /// Retrieve the C type declaration corresponding to the predefined\n  /// \\c __va_list_tag type used to help define the \\c __builtin_va_list type\n  /// for some targets.\n  Decl *getVaListTagDecl() const;\n\n  /// Retrieve the C type declaration corresponding to the predefined\n  /// \\c __builtin_ms_va_list type.\n  TypedefDecl *getBuiltinMSVaListDecl() const;\n\n  /// Retrieve the type of the \\c __builtin_ms_va_list type.\n  QualType getBuiltinMSVaListType() const {\n    return getTypeDeclType(getBuiltinMSVaListDecl());\n  }\n\n  /// Retrieve the implicitly-predeclared 'struct _GUID' declaration.\n  TagDecl *getMSGuidTagDecl() const { return MSGuidTagDecl; }\n\n  /// Retrieve the implicitly-predeclared 'struct _GUID' type.\n  QualType getMSGuidType() const {\n    assert(MSGuidTagDecl && \"asked for GUID type but MS extensions disabled\");\n    return getTagDeclType(MSGuidTagDecl);\n  }\n\n  /// Return whether a declaration to a builtin is allowed to be\n  /// overloaded/redeclared.\n  bool canBuiltinBeRedeclared(const FunctionDecl *) const;\n\n  /// Return a type with additional \\c const, \\c volatile, or\n  /// \\c restrict qualifiers.\n  QualType getCVRQualifiedType(QualType T, unsigned CVR) const {\n    return getQualifiedType(T, Qualifiers::fromCVRMask(CVR));\n  }\n\n  /// Un-split a SplitQualType.\n  QualType getQualifiedType(SplitQualType split) const {\n    return getQualifiedType(split.Ty, split.Quals);\n  }\n\n  /// Return a type with additional qualifiers.\n  QualType getQualifiedType(QualType T, Qualifiers Qs) const {\n    if (!Qs.hasNonFastQualifiers())\n      return T.withFastQualifiers(Qs.getFastQualifiers());\n    QualifierCollector Qc(Qs);\n    const Type *Ptr = Qc.strip(T);\n    return getExtQualType(Ptr, Qc);\n  }\n\n  /// Return a type with additional qualifiers.\n  QualType getQualifiedType(const Type *T, Qualifiers Qs) const {\n    if (!Qs.hasNonFastQualifiers())\n      return QualType(T, Qs.getFastQualifiers());\n    return getExtQualType(T, Qs);\n  }\n\n  /// Return a type with the given lifetime qualifier.\n  ///\n  /// \\pre Neither type.ObjCLifetime() nor \\p lifetime may be \\c OCL_None.\n  QualType getLifetimeQualifiedType(QualType type,\n                                    Qualifiers::ObjCLifetime lifetime) {\n    assert(type.getObjCLifetime() == Qualifiers::OCL_None);\n    assert(lifetime != Qualifiers::OCL_None);\n\n    Qualifiers qs;\n    qs.addObjCLifetime(lifetime);\n    return getQualifiedType(type, qs);\n  }\n\n  /// getUnqualifiedObjCPointerType - Returns version of\n  /// Objective-C pointer type with lifetime qualifier removed.\n  QualType getUnqualifiedObjCPointerType(QualType type) const {\n    if (!type.getTypePtr()->isObjCObjectPointerType() ||\n        !type.getQualifiers().hasObjCLifetime())\n      return type;\n    Qualifiers Qs = type.getQualifiers();\n    Qs.removeObjCLifetime();\n    return getQualifiedType(type.getUnqualifiedType(), Qs);\n  }\n\n  unsigned char getFixedPointScale(QualType Ty) const;\n  unsigned char getFixedPointIBits(QualType Ty) const;\n  llvm::FixedPointSemantics getFixedPointSemantics(QualType Ty) const;\n  llvm::APFixedPoint getFixedPointMax(QualType Ty) const;\n  llvm::APFixedPoint getFixedPointMin(QualType Ty) const;\n\n  DeclarationNameInfo getNameForTemplate(TemplateName Name,\n                                         SourceLocation NameLoc) const;\n\n  TemplateName getOverloadedTemplateName(UnresolvedSetIterator Begin,\n                                         UnresolvedSetIterator End) const;\n  TemplateName getAssumedTemplateName(DeclarationName Name) const;\n\n  TemplateName getQualifiedTemplateName(NestedNameSpecifier *NNS,\n                                        bool TemplateKeyword,\n                                        TemplateDecl *Template) const;\n\n  TemplateName getDependentTemplateName(NestedNameSpecifier *NNS,\n                                        const IdentifierInfo *Name) const;\n  TemplateName getDependentTemplateName(NestedNameSpecifier *NNS,\n                                        OverloadedOperatorKind Operator) const;\n  TemplateName getSubstTemplateTemplateParm(TemplateTemplateParmDecl *param,\n                                            TemplateName replacement) const;\n  TemplateName getSubstTemplateTemplateParmPack(TemplateTemplateParmDecl *Param,\n                                        const TemplateArgument &ArgPack) const;\n\n  enum GetBuiltinTypeError {\n    /// No error\n    GE_None,\n\n    /// Missing a type\n    GE_Missing_type,\n\n    /// Missing a type from <stdio.h>\n    GE_Missing_stdio,\n\n    /// Missing a type from <setjmp.h>\n    GE_Missing_setjmp,\n\n    /// Missing a type from <ucontext.h>\n    GE_Missing_ucontext\n  };\n\n  QualType DecodeTypeStr(const char *&Str, const ASTContext &Context,\n                         ASTContext::GetBuiltinTypeError &Error,\n                         bool &RequireICE, bool AllowTypeModifiers) const;\n\n  /// Return the type for the specified builtin.\n  ///\n  /// If \\p IntegerConstantArgs is non-null, it is filled in with a bitmask of\n  /// arguments to the builtin that are required to be integer constant\n  /// expressions.\n  QualType GetBuiltinType(unsigned ID, GetBuiltinTypeError &Error,\n                          unsigned *IntegerConstantArgs = nullptr) const;\n\n  /// Types and expressions required to build C++2a three-way comparisons\n  /// using operator<=>, including the values return by builtin <=> operators.\n  ComparisonCategories CompCategories;\n\nprivate:\n  CanQualType getFromTargetType(unsigned Type) const;\n  TypeInfo getTypeInfoImpl(const Type *T) const;\n\n  //===--------------------------------------------------------------------===//\n  //                         Type Predicates.\n  //===--------------------------------------------------------------------===//\n\npublic:\n  /// Return one of the GCNone, Weak or Strong Objective-C garbage\n  /// collection attributes.\n  Qualifiers::GC getObjCGCAttrKind(QualType Ty) const;\n\n  /// Return true if the given vector types are of the same unqualified\n  /// type or if they are equivalent to the same GCC vector type.\n  ///\n  /// \\note This ignores whether they are target-specific (AltiVec or Neon)\n  /// types.\n  bool areCompatibleVectorTypes(QualType FirstVec, QualType SecondVec);\n\n  /// Return true if the given types are an SVE builtin and a VectorType that\n  /// is a fixed-length representation of the SVE builtin for a specific\n  /// vector-length.\n  bool areCompatibleSveTypes(QualType FirstType, QualType SecondType);\n\n  /// Return true if the given vector types are lax-compatible SVE vector types,\n  /// false otherwise.\n  bool areLaxCompatibleSveTypes(QualType FirstType, QualType SecondType);\n\n  /// Return true if the type has been explicitly qualified with ObjC ownership.\n  /// A type may be implicitly qualified with ownership under ObjC ARC, and in\n  /// some cases the compiler treats these differently.\n  bool hasDirectOwnershipQualifier(QualType Ty) const;\n\n  /// Return true if this is an \\c NSObject object with its \\c NSObject\n  /// attribute set.\n  static bool isObjCNSObjectType(QualType Ty) {\n    return Ty->isObjCNSObjectType();\n  }\n\n  //===--------------------------------------------------------------------===//\n  //                         Type Sizing and Analysis\n  //===--------------------------------------------------------------------===//\n\n  /// Return the APFloat 'semantics' for the specified scalar floating\n  /// point type.\n  const llvm::fltSemantics &getFloatTypeSemantics(QualType T) const;\n\n  /// Get the size and alignment of the specified complete type in bits.\n  TypeInfo getTypeInfo(const Type *T) const;\n  TypeInfo getTypeInfo(QualType T) const { return getTypeInfo(T.getTypePtr()); }\n\n  /// Get default simd alignment of the specified complete type in bits.\n  unsigned getOpenMPDefaultSimdAlign(QualType T) const;\n\n  /// Return the size of the specified (complete) type \\p T, in bits.\n  uint64_t getTypeSize(QualType T) const { return getTypeInfo(T).Width; }\n  uint64_t getTypeSize(const Type *T) const { return getTypeInfo(T).Width; }\n\n  /// Return the size of the character type, in bits.\n  uint64_t getCharWidth() const {\n    return getTypeSize(CharTy);\n  }\n\n  /// Convert a size in bits to a size in characters.\n  CharUnits toCharUnitsFromBits(int64_t BitSize) const;\n\n  /// Convert a size in characters to a size in bits.\n  int64_t toBits(CharUnits CharSize) const;\n\n  /// Return the size of the specified (complete) type \\p T, in\n  /// characters.\n  CharUnits getTypeSizeInChars(QualType T) const;\n  CharUnits getTypeSizeInChars(const Type *T) const;\n\n  Optional<CharUnits> getTypeSizeInCharsIfKnown(QualType Ty) const {\n    if (Ty->isIncompleteType() || Ty->isDependentType())\n      return None;\n    return getTypeSizeInChars(Ty);\n  }\n\n  Optional<CharUnits> getTypeSizeInCharsIfKnown(const Type *Ty) const {\n    return getTypeSizeInCharsIfKnown(QualType(Ty, 0));\n  }\n\n  /// Return the ABI-specified alignment of a (complete) type \\p T, in\n  /// bits.\n  unsigned getTypeAlign(QualType T) const { return getTypeInfo(T).Align; }\n  unsigned getTypeAlign(const Type *T) const { return getTypeInfo(T).Align; }\n\n  /// Return the ABI-specified natural alignment of a (complete) type \\p T,\n  /// before alignment adjustments, in bits.\n  ///\n  /// This alignment is curently used only by ARM and AArch64 when passing\n  /// arguments of a composite type.\n  unsigned getTypeUnadjustedAlign(QualType T) const {\n    return getTypeUnadjustedAlign(T.getTypePtr());\n  }\n  unsigned getTypeUnadjustedAlign(const Type *T) const;\n\n  /// Return the alignment of a type, in bits, or 0 if\n  /// the type is incomplete and we cannot determine the alignment (for\n  /// example, from alignment attributes). The returned alignment is the\n  /// Preferred alignment if NeedsPreferredAlignment is true, otherwise is the\n  /// ABI alignment.\n  unsigned getTypeAlignIfKnown(QualType T,\n                               bool NeedsPreferredAlignment = false) const;\n\n  /// Return the ABI-specified alignment of a (complete) type \\p T, in\n  /// characters.\n  CharUnits getTypeAlignInChars(QualType T) const;\n  CharUnits getTypeAlignInChars(const Type *T) const;\n\n  /// Return the PreferredAlignment of a (complete) type \\p T, in\n  /// characters.\n  CharUnits getPreferredTypeAlignInChars(QualType T) const {\n    return toCharUnitsFromBits(getPreferredTypeAlign(T));\n  }\n\n  /// getTypeUnadjustedAlignInChars - Return the ABI-specified alignment of a type,\n  /// in characters, before alignment adjustments. This method does not work on\n  /// incomplete types.\n  CharUnits getTypeUnadjustedAlignInChars(QualType T) const;\n  CharUnits getTypeUnadjustedAlignInChars(const Type *T) const;\n\n  // getTypeInfoDataSizeInChars - Return the size of a type, in chars. If the\n  // type is a record, its data size is returned.\n  TypeInfoChars getTypeInfoDataSizeInChars(QualType T) const;\n\n  TypeInfoChars getTypeInfoInChars(const Type *T) const;\n  TypeInfoChars getTypeInfoInChars(QualType T) const;\n\n  /// Determine if the alignment the type has was required using an\n  /// alignment attribute.\n  bool isAlignmentRequired(const Type *T) const;\n  bool isAlignmentRequired(QualType T) const;\n\n  /// Return the \"preferred\" alignment of the specified type \\p T for\n  /// the current target, in bits.\n  ///\n  /// This can be different than the ABI alignment in cases where it is\n  /// beneficial for performance or backwards compatibility preserving to\n  /// overalign a data type. (Note: despite the name, the preferred alignment\n  /// is ABI-impacting, and not an optimization.)\n  unsigned getPreferredTypeAlign(QualType T) const {\n    return getPreferredTypeAlign(T.getTypePtr());\n  }\n  unsigned getPreferredTypeAlign(const Type *T) const;\n\n  /// Return the default alignment for __attribute__((aligned)) on\n  /// this target, to be used if no alignment value is specified.\n  unsigned getTargetDefaultAlignForAttributeAligned() const;\n\n  /// Return the alignment in bits that should be given to a\n  /// global variable with type \\p T.\n  unsigned getAlignOfGlobalVar(QualType T) const;\n\n  /// Return the alignment in characters that should be given to a\n  /// global variable with type \\p T.\n  CharUnits getAlignOfGlobalVarInChars(QualType T) const;\n\n  /// Return a conservative estimate of the alignment of the specified\n  /// decl \\p D.\n  ///\n  /// \\pre \\p D must not be a bitfield type, as bitfields do not have a valid\n  /// alignment.\n  ///\n  /// If \\p ForAlignof, references are treated like their underlying type\n  /// and  large arrays don't get any special treatment. If not \\p ForAlignof\n  /// it computes the value expected by CodeGen: references are treated like\n  /// pointers and large arrays get extra alignment.\n  CharUnits getDeclAlign(const Decl *D, bool ForAlignof = false) const;\n\n  /// Return the alignment (in bytes) of the thrown exception object. This is\n  /// only meaningful for targets that allocate C++ exceptions in a system\n  /// runtime, such as those using the Itanium C++ ABI.\n  CharUnits getExnObjectAlignment() const;\n\n  /// Get or compute information about the layout of the specified\n  /// record (struct/union/class) \\p D, which indicates its size and field\n  /// position information.\n  const ASTRecordLayout &getASTRecordLayout(const RecordDecl *D) const;\n\n  /// Get or compute information about the layout of the specified\n  /// Objective-C interface.\n  const ASTRecordLayout &getASTObjCInterfaceLayout(const ObjCInterfaceDecl *D)\n    const;\n\n  void DumpRecordLayout(const RecordDecl *RD, raw_ostream &OS,\n                        bool Simple = false) const;\n\n  /// Get or compute information about the layout of the specified\n  /// Objective-C implementation.\n  ///\n  /// This may differ from the interface if synthesized ivars are present.\n  const ASTRecordLayout &\n  getASTObjCImplementationLayout(const ObjCImplementationDecl *D) const;\n\n  /// Get our current best idea for the key function of the\n  /// given record decl, or nullptr if there isn't one.\n  ///\n  /// The key function is, according to the Itanium C++ ABI section 5.2.3:\n  ///   ...the first non-pure virtual function that is not inline at the\n  ///   point of class definition.\n  ///\n  /// Other ABIs use the same idea.  However, the ARM C++ ABI ignores\n  /// virtual functions that are defined 'inline', which means that\n  /// the result of this computation can change.\n  const CXXMethodDecl *getCurrentKeyFunction(const CXXRecordDecl *RD);\n\n  /// Observe that the given method cannot be a key function.\n  /// Checks the key-function cache for the method's class and clears it\n  /// if matches the given declaration.\n  ///\n  /// This is used in ABIs where out-of-line definitions marked\n  /// inline are not considered to be key functions.\n  ///\n  /// \\param method should be the declaration from the class definition\n  void setNonKeyFunction(const CXXMethodDecl *method);\n\n  /// Loading virtual member pointers using the virtual inheritance model\n  /// always results in an adjustment using the vbtable even if the index is\n  /// zero.\n  ///\n  /// This is usually OK because the first slot in the vbtable points\n  /// backwards to the top of the MDC.  However, the MDC might be reusing a\n  /// vbptr from an nv-base.  In this case, the first slot in the vbtable\n  /// points to the start of the nv-base which introduced the vbptr and *not*\n  /// the MDC.  Modify the NonVirtualBaseAdjustment to account for this.\n  CharUnits getOffsetOfBaseWithVBPtr(const CXXRecordDecl *RD) const;\n\n  /// Get the offset of a FieldDecl or IndirectFieldDecl, in bits.\n  uint64_t getFieldOffset(const ValueDecl *FD) const;\n\n  /// Get the offset of an ObjCIvarDecl in bits.\n  uint64_t lookupFieldBitOffset(const ObjCInterfaceDecl *OID,\n                                const ObjCImplementationDecl *ID,\n                                const ObjCIvarDecl *Ivar) const;\n\n  /// Find the 'this' offset for the member path in a pointer-to-member\n  /// APValue.\n  CharUnits getMemberPointerPathAdjustment(const APValue &MP) const;\n\n  bool isNearlyEmpty(const CXXRecordDecl *RD) const;\n\n  VTableContextBase *getVTableContext();\n\n  /// If \\p T is null pointer, assume the target in ASTContext.\n  MangleContext *createMangleContext(const TargetInfo *T = nullptr);\n\n  void DeepCollectObjCIvars(const ObjCInterfaceDecl *OI, bool leafClass,\n                            SmallVectorImpl<const ObjCIvarDecl*> &Ivars) const;\n\n  unsigned CountNonClassIvars(const ObjCInterfaceDecl *OI) const;\n  void CollectInheritedProtocols(const Decl *CDecl,\n                          llvm::SmallPtrSet<ObjCProtocolDecl*, 8> &Protocols);\n\n  /// Return true if the specified type has unique object representations\n  /// according to (C++17 [meta.unary.prop]p9)\n  bool hasUniqueObjectRepresentations(QualType Ty) const;\n\n  //===--------------------------------------------------------------------===//\n  //                            Type Operators\n  //===--------------------------------------------------------------------===//\n\n  /// Return the canonical (structural) type corresponding to the\n  /// specified potentially non-canonical type \\p T.\n  ///\n  /// The non-canonical version of a type may have many \"decorated\" versions of\n  /// types.  Decorators can include typedefs, 'typeof' operators, etc. The\n  /// returned type is guaranteed to be free of any of these, allowing two\n  /// canonical types to be compared for exact equality with a simple pointer\n  /// comparison.\n  CanQualType getCanonicalType(QualType T) const {\n    return CanQualType::CreateUnsafe(T.getCanonicalType());\n  }\n\n  const Type *getCanonicalType(const Type *T) const {\n    return T->getCanonicalTypeInternal().getTypePtr();\n  }\n\n  /// Return the canonical parameter type corresponding to the specific\n  /// potentially non-canonical one.\n  ///\n  /// Qualifiers are stripped off, functions are turned into function\n  /// pointers, and arrays decay one level into pointers.\n  CanQualType getCanonicalParamType(QualType T) const;\n\n  /// Determine whether the given types \\p T1 and \\p T2 are equivalent.\n  bool hasSameType(QualType T1, QualType T2) const {\n    return getCanonicalType(T1) == getCanonicalType(T2);\n  }\n  bool hasSameType(const Type *T1, const Type *T2) const {\n    return getCanonicalType(T1) == getCanonicalType(T2);\n  }\n\n  /// Return this type as a completely-unqualified array type,\n  /// capturing the qualifiers in \\p Quals.\n  ///\n  /// This will remove the minimal amount of sugaring from the types, similar\n  /// to the behavior of QualType::getUnqualifiedType().\n  ///\n  /// \\param T is the qualified type, which may be an ArrayType\n  ///\n  /// \\param Quals will receive the full set of qualifiers that were\n  /// applied to the array.\n  ///\n  /// \\returns if this is an array type, the completely unqualified array type\n  /// that corresponds to it. Otherwise, returns T.getUnqualifiedType().\n  QualType getUnqualifiedArrayType(QualType T, Qualifiers &Quals);\n\n  /// Determine whether the given types are equivalent after\n  /// cvr-qualifiers have been removed.\n  bool hasSameUnqualifiedType(QualType T1, QualType T2) const {\n    return getCanonicalType(T1).getTypePtr() ==\n           getCanonicalType(T2).getTypePtr();\n  }\n\n  bool hasSameNullabilityTypeQualifier(QualType SubT, QualType SuperT,\n                                       bool IsParam) const {\n    auto SubTnullability = SubT->getNullability(*this);\n    auto SuperTnullability = SuperT->getNullability(*this);\n    if (SubTnullability.hasValue() == SuperTnullability.hasValue()) {\n      // Neither has nullability; return true\n      if (!SubTnullability)\n        return true;\n      // Both have nullability qualifier.\n      if (*SubTnullability == *SuperTnullability ||\n          *SubTnullability == NullabilityKind::Unspecified ||\n          *SuperTnullability == NullabilityKind::Unspecified)\n        return true;\n\n      if (IsParam) {\n        // Ok for the superclass method parameter to be \"nonnull\" and the subclass\n        // method parameter to be \"nullable\"\n        return (*SuperTnullability == NullabilityKind::NonNull &&\n                *SubTnullability == NullabilityKind::Nullable);\n      }\n      // For the return type, it's okay for the superclass method to specify\n      // \"nullable\" and the subclass method specify \"nonnull\"\n      return (*SuperTnullability == NullabilityKind::Nullable &&\n              *SubTnullability == NullabilityKind::NonNull);\n    }\n    return true;\n  }\n\n  bool ObjCMethodsAreEqual(const ObjCMethodDecl *MethodDecl,\n                           const ObjCMethodDecl *MethodImp);\n\n  bool UnwrapSimilarTypes(QualType &T1, QualType &T2);\n  bool UnwrapSimilarArrayTypes(QualType &T1, QualType &T2);\n\n  /// Determine if two types are similar, according to the C++ rules. That is,\n  /// determine if they are the same other than qualifiers on the initial\n  /// sequence of pointer / pointer-to-member / array (and in Clang, object\n  /// pointer) types and their element types.\n  ///\n  /// Clang offers a number of qualifiers in addition to the C++ qualifiers;\n  /// those qualifiers are also ignored in the 'similarity' check.\n  bool hasSimilarType(QualType T1, QualType T2);\n\n  /// Determine if two types are similar, ignoring only CVR qualifiers.\n  bool hasCvrSimilarType(QualType T1, QualType T2);\n\n  /// Retrieves the \"canonical\" nested name specifier for a\n  /// given nested name specifier.\n  ///\n  /// The canonical nested name specifier is a nested name specifier\n  /// that uniquely identifies a type or namespace within the type\n  /// system. For example, given:\n  ///\n  /// \\code\n  /// namespace N {\n  ///   struct S {\n  ///     template<typename T> struct X { typename T* type; };\n  ///   };\n  /// }\n  ///\n  /// template<typename T> struct Y {\n  ///   typename N::S::X<T>::type member;\n  /// };\n  /// \\endcode\n  ///\n  /// Here, the nested-name-specifier for N::S::X<T>:: will be\n  /// S::X<template-param-0-0>, since 'S' and 'X' are uniquely defined\n  /// by declarations in the type system and the canonical type for\n  /// the template type parameter 'T' is template-param-0-0.\n  NestedNameSpecifier *\n  getCanonicalNestedNameSpecifier(NestedNameSpecifier *NNS) const;\n\n  /// Retrieves the default calling convention for the current target.\n  CallingConv getDefaultCallingConvention(bool IsVariadic,\n                                          bool IsCXXMethod,\n                                          bool IsBuiltin = false) const;\n\n  /// Retrieves the \"canonical\" template name that refers to a\n  /// given template.\n  ///\n  /// The canonical template name is the simplest expression that can\n  /// be used to refer to a given template. For most templates, this\n  /// expression is just the template declaration itself. For example,\n  /// the template std::vector can be referred to via a variety of\n  /// names---std::vector, \\::std::vector, vector (if vector is in\n  /// scope), etc.---but all of these names map down to the same\n  /// TemplateDecl, which is used to form the canonical template name.\n  ///\n  /// Dependent template names are more interesting. Here, the\n  /// template name could be something like T::template apply or\n  /// std::allocator<T>::template rebind, where the nested name\n  /// specifier itself is dependent. In this case, the canonical\n  /// template name uses the shortest form of the dependent\n  /// nested-name-specifier, which itself contains all canonical\n  /// types, values, and templates.\n  TemplateName getCanonicalTemplateName(TemplateName Name) const;\n\n  /// Determine whether the given template names refer to the same\n  /// template.\n  bool hasSameTemplateName(TemplateName X, TemplateName Y);\n\n  /// Retrieve the \"canonical\" template argument.\n  ///\n  /// The canonical template argument is the simplest template argument\n  /// (which may be a type, value, expression, or declaration) that\n  /// expresses the value of the argument.\n  TemplateArgument getCanonicalTemplateArgument(const TemplateArgument &Arg)\n    const;\n\n  /// Type Query functions.  If the type is an instance of the specified class,\n  /// return the Type pointer for the underlying maximally pretty type.  This\n  /// is a member of ASTContext because this may need to do some amount of\n  /// canonicalization, e.g. to move type qualifiers into the element type.\n  const ArrayType *getAsArrayType(QualType T) const;\n  const ConstantArrayType *getAsConstantArrayType(QualType T) const {\n    return dyn_cast_or_null<ConstantArrayType>(getAsArrayType(T));\n  }\n  const VariableArrayType *getAsVariableArrayType(QualType T) const {\n    return dyn_cast_or_null<VariableArrayType>(getAsArrayType(T));\n  }\n  const IncompleteArrayType *getAsIncompleteArrayType(QualType T) const {\n    return dyn_cast_or_null<IncompleteArrayType>(getAsArrayType(T));\n  }\n  const DependentSizedArrayType *getAsDependentSizedArrayType(QualType T)\n    const {\n    return dyn_cast_or_null<DependentSizedArrayType>(getAsArrayType(T));\n  }\n\n  /// Return the innermost element type of an array type.\n  ///\n  /// For example, will return \"int\" for int[m][n]\n  QualType getBaseElementType(const ArrayType *VAT) const;\n\n  /// Return the innermost element type of a type (which needn't\n  /// actually be an array type).\n  QualType getBaseElementType(QualType QT) const;\n\n  /// Return number of constant array elements.\n  uint64_t getConstantArrayElementCount(const ConstantArrayType *CA) const;\n\n  /// Perform adjustment on the parameter type of a function.\n  ///\n  /// This routine adjusts the given parameter type @p T to the actual\n  /// parameter type used by semantic analysis (C99 6.7.5.3p[7,8],\n  /// C++ [dcl.fct]p3). The adjusted parameter type is returned.\n  QualType getAdjustedParameterType(QualType T) const;\n\n  /// Retrieve the parameter type as adjusted for use in the signature\n  /// of a function, decaying array and function types and removing top-level\n  /// cv-qualifiers.\n  QualType getSignatureParameterType(QualType T) const;\n\n  QualType getExceptionObjectType(QualType T) const;\n\n  /// Return the properly qualified result of decaying the specified\n  /// array type to a pointer.\n  ///\n  /// This operation is non-trivial when handling typedefs etc.  The canonical\n  /// type of \\p T must be an array type, this returns a pointer to a properly\n  /// qualified element of the array.\n  ///\n  /// See C99 6.7.5.3p7 and C99 6.3.2.1p3.\n  QualType getArrayDecayedType(QualType T) const;\n\n  /// Return the type that \\p PromotableType will promote to: C99\n  /// 6.3.1.1p2, assuming that \\p PromotableType is a promotable integer type.\n  QualType getPromotedIntegerType(QualType PromotableType) const;\n\n  /// Recurses in pointer/array types until it finds an Objective-C\n  /// retainable type and returns its ownership.\n  Qualifiers::ObjCLifetime getInnerObjCOwnership(QualType T) const;\n\n  /// Whether this is a promotable bitfield reference according\n  /// to C99 6.3.1.1p2, bullet 2 (and GCC extensions).\n  ///\n  /// \\returns the type this bit-field will promote to, or NULL if no\n  /// promotion occurs.\n  QualType isPromotableBitField(Expr *E) const;\n\n  /// Return the highest ranked integer type, see C99 6.3.1.8p1.\n  ///\n  /// If \\p LHS > \\p RHS, returns 1.  If \\p LHS == \\p RHS, returns 0.  If\n  /// \\p LHS < \\p RHS, return -1.\n  int getIntegerTypeOrder(QualType LHS, QualType RHS) const;\n\n  /// Compare the rank of the two specified floating point types,\n  /// ignoring the domain of the type (i.e. 'double' == '_Complex double').\n  ///\n  /// If \\p LHS > \\p RHS, returns 1.  If \\p LHS == \\p RHS, returns 0.  If\n  /// \\p LHS < \\p RHS, return -1.\n  int getFloatingTypeOrder(QualType LHS, QualType RHS) const;\n\n  /// Compare the rank of two floating point types as above, but compare equal\n  /// if both types have the same floating-point semantics on the target (i.e.\n  /// long double and double on AArch64 will return 0).\n  int getFloatingTypeSemanticOrder(QualType LHS, QualType RHS) const;\n\n  /// Return a real floating point or a complex type (based on\n  /// \\p typeDomain/\\p typeSize).\n  ///\n  /// \\param typeDomain a real floating point or complex type.\n  /// \\param typeSize a real floating point or complex type.\n  QualType getFloatingTypeOfSizeWithinDomain(QualType typeSize,\n                                             QualType typeDomain) const;\n\n  unsigned getTargetAddressSpace(QualType T) const {\n    return getTargetAddressSpace(T.getQualifiers());\n  }\n\n  unsigned getTargetAddressSpace(Qualifiers Q) const {\n    return getTargetAddressSpace(Q.getAddressSpace());\n  }\n\n  unsigned getTargetAddressSpace(LangAS AS) const;\n\n  LangAS getLangASForBuiltinAddressSpace(unsigned AS) const;\n\n  /// Get target-dependent integer value for null pointer which is used for\n  /// constant folding.\n  uint64_t getTargetNullPointerValue(QualType QT) const;\n\n  bool addressSpaceMapManglingFor(LangAS AS) const {\n    return AddrSpaceMapMangling || isTargetAddressSpace(AS);\n  }\n\nprivate:\n  // Helper for integer ordering\n  unsigned getIntegerRank(const Type *T) const;\n\npublic:\n  //===--------------------------------------------------------------------===//\n  //                    Type Compatibility Predicates\n  //===--------------------------------------------------------------------===//\n\n  /// Compatibility predicates used to check assignment expressions.\n  bool typesAreCompatible(QualType T1, QualType T2,\n                          bool CompareUnqualified = false); // C99 6.2.7p1\n\n  bool propertyTypesAreCompatible(QualType, QualType);\n  bool typesAreBlockPointerCompatible(QualType, QualType);\n\n  bool isObjCIdType(QualType T) const {\n    return T == getObjCIdType();\n  }\n\n  bool isObjCClassType(QualType T) const {\n    return T == getObjCClassType();\n  }\n\n  bool isObjCSelType(QualType T) const {\n    return T == getObjCSelType();\n  }\n\n  bool ObjCQualifiedIdTypesAreCompatible(const ObjCObjectPointerType *LHS,\n                                         const ObjCObjectPointerType *RHS,\n                                         bool ForCompare);\n\n  bool ObjCQualifiedClassTypesAreCompatible(const ObjCObjectPointerType *LHS,\n                                            const ObjCObjectPointerType *RHS);\n\n  // Check the safety of assignment from LHS to RHS\n  bool canAssignObjCInterfaces(const ObjCObjectPointerType *LHSOPT,\n                               const ObjCObjectPointerType *RHSOPT);\n  bool canAssignObjCInterfaces(const ObjCObjectType *LHS,\n                               const ObjCObjectType *RHS);\n  bool canAssignObjCInterfacesInBlockPointer(\n                                          const ObjCObjectPointerType *LHSOPT,\n                                          const ObjCObjectPointerType *RHSOPT,\n                                          bool BlockReturnType);\n  bool areComparableObjCPointerTypes(QualType LHS, QualType RHS);\n  QualType areCommonBaseCompatible(const ObjCObjectPointerType *LHSOPT,\n                                   const ObjCObjectPointerType *RHSOPT);\n  bool canBindObjCObjectType(QualType To, QualType From);\n\n  // Functions for calculating composite types\n  QualType mergeTypes(QualType, QualType, bool OfBlockPointer=false,\n                      bool Unqualified = false, bool BlockReturnType = false);\n  QualType mergeFunctionTypes(QualType, QualType, bool OfBlockPointer=false,\n                              bool Unqualified = false, bool AllowCXX = false);\n  QualType mergeFunctionParameterTypes(QualType, QualType,\n                                       bool OfBlockPointer = false,\n                                       bool Unqualified = false);\n  QualType mergeTransparentUnionType(QualType, QualType,\n                                     bool OfBlockPointer=false,\n                                     bool Unqualified = false);\n\n  QualType mergeObjCGCQualifiers(QualType, QualType);\n\n  /// This function merges the ExtParameterInfo lists of two functions. It\n  /// returns true if the lists are compatible. The merged list is returned in\n  /// NewParamInfos.\n  ///\n  /// \\param FirstFnType The type of the first function.\n  ///\n  /// \\param SecondFnType The type of the second function.\n  ///\n  /// \\param CanUseFirst This flag is set to true if the first function's\n  /// ExtParameterInfo list can be used as the composite list of\n  /// ExtParameterInfo.\n  ///\n  /// \\param CanUseSecond This flag is set to true if the second function's\n  /// ExtParameterInfo list can be used as the composite list of\n  /// ExtParameterInfo.\n  ///\n  /// \\param NewParamInfos The composite list of ExtParameterInfo. The list is\n  /// empty if none of the flags are set.\n  ///\n  bool mergeExtParameterInfo(\n      const FunctionProtoType *FirstFnType,\n      const FunctionProtoType *SecondFnType,\n      bool &CanUseFirst, bool &CanUseSecond,\n      SmallVectorImpl<FunctionProtoType::ExtParameterInfo> &NewParamInfos);\n\n  void ResetObjCLayout(const ObjCContainerDecl *CD);\n\n  //===--------------------------------------------------------------------===//\n  //                    Integer Predicates\n  //===--------------------------------------------------------------------===//\n\n  // The width of an integer, as defined in C99 6.2.6.2. This is the number\n  // of bits in an integer type excluding any padding bits.\n  unsigned getIntWidth(QualType T) const;\n\n  // Per C99 6.2.5p6, for every signed integer type, there is a corresponding\n  // unsigned integer type.  This method takes a signed type, and returns the\n  // corresponding unsigned integer type.\n  // With the introduction of fixed point types in ISO N1169, this method also\n  // accepts fixed point types and returns the corresponding unsigned type for\n  // a given fixed point type.\n  QualType getCorrespondingUnsignedType(QualType T) const;\n\n  // Per ISO N1169, this method accepts fixed point types and returns the\n  // corresponding saturated type for a given fixed point type.\n  QualType getCorrespondingSaturatedType(QualType Ty) const;\n\n  // This method accepts fixed point types and returns the corresponding signed\n  // type. Unlike getCorrespondingUnsignedType(), this only accepts unsigned\n  // fixed point types because there are unsigned integer types like bool and\n  // char8_t that don't have signed equivalents.\n  QualType getCorrespondingSignedFixedPointType(QualType Ty) const;\n\n  //===--------------------------------------------------------------------===//\n  //                    Integer Values\n  //===--------------------------------------------------------------------===//\n\n  /// Make an APSInt of the appropriate width and signedness for the\n  /// given \\p Value and integer \\p Type.\n  llvm::APSInt MakeIntValue(uint64_t Value, QualType Type) const {\n    // If Type is a signed integer type larger than 64 bits, we need to be sure\n    // to sign extend Res appropriately.\n    llvm::APSInt Res(64, !Type->isSignedIntegerOrEnumerationType());\n    Res = Value;\n    unsigned Width = getIntWidth(Type);\n    if (Width != Res.getBitWidth())\n      return Res.extOrTrunc(Width);\n    return Res;\n  }\n\n  bool isSentinelNullExpr(const Expr *E);\n\n  /// Get the implementation of the ObjCInterfaceDecl \\p D, or nullptr if\n  /// none exists.\n  ObjCImplementationDecl *getObjCImplementation(ObjCInterfaceDecl *D);\n\n  /// Get the implementation of the ObjCCategoryDecl \\p D, or nullptr if\n  /// none exists.\n  ObjCCategoryImplDecl *getObjCImplementation(ObjCCategoryDecl *D);\n\n  /// Return true if there is at least one \\@implementation in the TU.\n  bool AnyObjCImplementation() {\n    return !ObjCImpls.empty();\n  }\n\n  /// Set the implementation of ObjCInterfaceDecl.\n  void setObjCImplementation(ObjCInterfaceDecl *IFaceD,\n                             ObjCImplementationDecl *ImplD);\n\n  /// Set the implementation of ObjCCategoryDecl.\n  void setObjCImplementation(ObjCCategoryDecl *CatD,\n                             ObjCCategoryImplDecl *ImplD);\n\n  /// Get the duplicate declaration of a ObjCMethod in the same\n  /// interface, or null if none exists.\n  const ObjCMethodDecl *\n  getObjCMethodRedeclaration(const ObjCMethodDecl *MD) const;\n\n  void setObjCMethodRedeclaration(const ObjCMethodDecl *MD,\n                                  const ObjCMethodDecl *Redecl);\n\n  /// Returns the Objective-C interface that \\p ND belongs to if it is\n  /// an Objective-C method/property/ivar etc. that is part of an interface,\n  /// otherwise returns null.\n  const ObjCInterfaceDecl *getObjContainingInterface(const NamedDecl *ND) const;\n\n  /// Set the copy initialization expression of a block var decl. \\p CanThrow\n  /// indicates whether the copy expression can throw or not.\n  void setBlockVarCopyInit(const VarDecl* VD, Expr *CopyExpr, bool CanThrow);\n\n  /// Get the copy initialization expression of the VarDecl \\p VD, or\n  /// nullptr if none exists.\n  BlockVarCopyInit getBlockVarCopyInit(const VarDecl* VD) const;\n\n  /// Allocate an uninitialized TypeSourceInfo.\n  ///\n  /// The caller should initialize the memory held by TypeSourceInfo using\n  /// the TypeLoc wrappers.\n  ///\n  /// \\param T the type that will be the basis for type source info. This type\n  /// should refer to how the declarator was written in source code, not to\n  /// what type semantic analysis resolved the declarator to.\n  ///\n  /// \\param Size the size of the type info to create, or 0 if the size\n  /// should be calculated based on the type.\n  TypeSourceInfo *CreateTypeSourceInfo(QualType T, unsigned Size = 0) const;\n\n  /// Allocate a TypeSourceInfo where all locations have been\n  /// initialized to a given location, which defaults to the empty\n  /// location.\n  TypeSourceInfo *\n  getTrivialTypeSourceInfo(QualType T,\n                           SourceLocation Loc = SourceLocation()) const;\n\n  /// Add a deallocation callback that will be invoked when the\n  /// ASTContext is destroyed.\n  ///\n  /// \\param Callback A callback function that will be invoked on destruction.\n  ///\n  /// \\param Data Pointer data that will be provided to the callback function\n  /// when it is called.\n  void AddDeallocation(void (*Callback)(void *), void *Data) const;\n\n  /// If T isn't trivially destructible, calls AddDeallocation to register it\n  /// for destruction.\n  template <typename T> void addDestruction(T *Ptr) const {\n    if (!std::is_trivially_destructible<T>::value) {\n      auto DestroyPtr = [](void *V) { static_cast<T *>(V)->~T(); };\n      AddDeallocation(DestroyPtr, Ptr);\n    }\n  }\n\n  GVALinkage GetGVALinkageForFunction(const FunctionDecl *FD) const;\n  GVALinkage GetGVALinkageForVariable(const VarDecl *VD);\n\n  /// Determines if the decl can be CodeGen'ed or deserialized from PCH\n  /// lazily, only when used; this is only relevant for function or file scoped\n  /// var definitions.\n  ///\n  /// \\returns true if the function/var must be CodeGen'ed/deserialized even if\n  /// it is not used.\n  bool DeclMustBeEmitted(const Decl *D);\n\n  /// Visits all versions of a multiversioned function with the passed\n  /// predicate.\n  void forEachMultiversionedFunctionVersion(\n      const FunctionDecl *FD,\n      llvm::function_ref<void(FunctionDecl *)> Pred) const;\n\n  const CXXConstructorDecl *\n  getCopyConstructorForExceptionObject(CXXRecordDecl *RD);\n\n  void addCopyConstructorForExceptionObject(CXXRecordDecl *RD,\n                                            CXXConstructorDecl *CD);\n\n  void addTypedefNameForUnnamedTagDecl(TagDecl *TD, TypedefNameDecl *TND);\n\n  TypedefNameDecl *getTypedefNameForUnnamedTagDecl(const TagDecl *TD);\n\n  void addDeclaratorForUnnamedTagDecl(TagDecl *TD, DeclaratorDecl *DD);\n\n  DeclaratorDecl *getDeclaratorForUnnamedTagDecl(const TagDecl *TD);\n\n  void setManglingNumber(const NamedDecl *ND, unsigned Number);\n  unsigned getManglingNumber(const NamedDecl *ND) const;\n\n  void setStaticLocalNumber(const VarDecl *VD, unsigned Number);\n  unsigned getStaticLocalNumber(const VarDecl *VD) const;\n\n  /// Retrieve the context for computing mangling numbers in the given\n  /// DeclContext.\n  MangleNumberingContext &getManglingNumberContext(const DeclContext *DC);\n  enum NeedExtraManglingDecl_t { NeedExtraManglingDecl };\n  MangleNumberingContext &getManglingNumberContext(NeedExtraManglingDecl_t,\n                                                   const Decl *D);\n\n  std::unique_ptr<MangleNumberingContext> createMangleNumberingContext() const;\n\n  /// Used by ParmVarDecl to store on the side the\n  /// index of the parameter when it exceeds the size of the normal bitfield.\n  void setParameterIndex(const ParmVarDecl *D, unsigned index);\n\n  /// Used by ParmVarDecl to retrieve on the side the\n  /// index of the parameter when it exceeds the size of the normal bitfield.\n  unsigned getParameterIndex(const ParmVarDecl *D) const;\n\n  /// Return a string representing the human readable name for the specified\n  /// function declaration or file name. Used by SourceLocExpr and\n  /// PredefinedExpr to cache evaluated results.\n  StringLiteral *getPredefinedStringLiteralFromCache(StringRef Key) const;\n\n  /// Return a declaration for the global GUID object representing the given\n  /// GUID value.\n  MSGuidDecl *getMSGuidDecl(MSGuidDeclParts Parts) const;\n\n  /// Return the template parameter object of the given type with the given\n  /// value.\n  TemplateParamObjectDecl *getTemplateParamObjectDecl(QualType T,\n                                                      const APValue &V) const;\n\n  /// Parses the target attributes passed in, and returns only the ones that are\n  /// valid feature names.\n  ParsedTargetAttr filterFunctionTargetAttrs(const TargetAttr *TD) const;\n\n  void getFunctionFeatureMap(llvm::StringMap<bool> &FeatureMap,\n                             const FunctionDecl *) const;\n  void getFunctionFeatureMap(llvm::StringMap<bool> &FeatureMap,\n                             GlobalDecl GD) const;\n\n  //===--------------------------------------------------------------------===//\n  //                    Statistics\n  //===--------------------------------------------------------------------===//\n\n  /// The number of implicitly-declared default constructors.\n  unsigned NumImplicitDefaultConstructors = 0;\n\n  /// The number of implicitly-declared default constructors for\n  /// which declarations were built.\n  unsigned NumImplicitDefaultConstructorsDeclared = 0;\n\n  /// The number of implicitly-declared copy constructors.\n  unsigned NumImplicitCopyConstructors = 0;\n\n  /// The number of implicitly-declared copy constructors for\n  /// which declarations were built.\n  unsigned NumImplicitCopyConstructorsDeclared = 0;\n\n  /// The number of implicitly-declared move constructors.\n  unsigned NumImplicitMoveConstructors = 0;\n\n  /// The number of implicitly-declared move constructors for\n  /// which declarations were built.\n  unsigned NumImplicitMoveConstructorsDeclared = 0;\n\n  /// The number of implicitly-declared copy assignment operators.\n  unsigned NumImplicitCopyAssignmentOperators = 0;\n\n  /// The number of implicitly-declared copy assignment operators for\n  /// which declarations were built.\n  unsigned NumImplicitCopyAssignmentOperatorsDeclared = 0;\n\n  /// The number of implicitly-declared move assignment operators.\n  unsigned NumImplicitMoveAssignmentOperators = 0;\n\n  /// The number of implicitly-declared move assignment operators for\n  /// which declarations were built.\n  unsigned NumImplicitMoveAssignmentOperatorsDeclared = 0;\n\n  /// The number of implicitly-declared destructors.\n  unsigned NumImplicitDestructors = 0;\n\n  /// The number of implicitly-declared destructors for which\n  /// declarations were built.\n  unsigned NumImplicitDestructorsDeclared = 0;\n\npublic:\n  /// Initialize built-in types.\n  ///\n  /// This routine may only be invoked once for a given ASTContext object.\n  /// It is normally invoked after ASTContext construction.\n  ///\n  /// \\param Target The target\n  void InitBuiltinTypes(const TargetInfo &Target,\n                        const TargetInfo *AuxTarget = nullptr);\n\nprivate:\n  void InitBuiltinType(CanQualType &R, BuiltinType::Kind K);\n\n  class ObjCEncOptions {\n    unsigned Bits;\n\n    ObjCEncOptions(unsigned Bits) : Bits(Bits) {}\n\n  public:\n    ObjCEncOptions() : Bits(0) {}\n    ObjCEncOptions(const ObjCEncOptions &RHS) : Bits(RHS.Bits) {}\n\n#define OPT_LIST(V)                                                            \\\n  V(ExpandPointedToStructures, 0)                                              \\\n  V(ExpandStructures, 1)                                                       \\\n  V(IsOutermostType, 2)                                                        \\\n  V(EncodingProperty, 3)                                                       \\\n  V(IsStructField, 4)                                                          \\\n  V(EncodeBlockParameters, 5)                                                  \\\n  V(EncodeClassNames, 6)                                                       \\\n\n#define V(N,I) ObjCEncOptions& set##N() { Bits |= 1 << I; return *this; }\nOPT_LIST(V)\n#undef V\n\n#define V(N,I) bool N() const { return Bits & 1 << I; }\nOPT_LIST(V)\n#undef V\n\n#undef OPT_LIST\n\n    LLVM_NODISCARD ObjCEncOptions keepingOnly(ObjCEncOptions Mask) const {\n      return Bits & Mask.Bits;\n    }\n\n    LLVM_NODISCARD ObjCEncOptions forComponentType() const {\n      ObjCEncOptions Mask = ObjCEncOptions()\n                                .setIsOutermostType()\n                                .setIsStructField();\n      return Bits & ~Mask.Bits;\n    }\n  };\n\n  // Return the Objective-C type encoding for a given type.\n  void getObjCEncodingForTypeImpl(QualType t, std::string &S,\n                                  ObjCEncOptions Options,\n                                  const FieldDecl *Field,\n                                  QualType *NotEncodedT = nullptr) const;\n\n  // Adds the encoding of the structure's members.\n  void getObjCEncodingForStructureImpl(RecordDecl *RD, std::string &S,\n                                       const FieldDecl *Field,\n                                       bool includeVBases = true,\n                                       QualType *NotEncodedT=nullptr) const;\n\npublic:\n  // Adds the encoding of a method parameter or return type.\n  void getObjCEncodingForMethodParameter(Decl::ObjCDeclQualifier QT,\n                                         QualType T, std::string& S,\n                                         bool Extended) const;\n\n  /// Returns true if this is an inline-initialized static data member\n  /// which is treated as a definition for MSVC compatibility.\n  bool isMSStaticDataMemberInlineDefinition(const VarDecl *VD) const;\n\n  enum class InlineVariableDefinitionKind {\n    /// Not an inline variable.\n    None,\n\n    /// Weak definition of inline variable.\n    Weak,\n\n    /// Weak for now, might become strong later in this TU.\n    WeakUnknown,\n\n    /// Strong definition.\n    Strong\n  };\n\n  /// Determine whether a definition of this inline variable should\n  /// be treated as a weak or strong definition. For compatibility with\n  /// C++14 and before, for a constexpr static data member, if there is an\n  /// out-of-line declaration of the member, we may promote it from weak to\n  /// strong.\n  InlineVariableDefinitionKind\n  getInlineVariableDefinitionKind(const VarDecl *VD) const;\n\nprivate:\n  friend class DeclarationNameTable;\n  friend class DeclContext;\n\n  const ASTRecordLayout &\n  getObjCLayout(const ObjCInterfaceDecl *D,\n                const ObjCImplementationDecl *Impl) const;\n\n  /// A set of deallocations that should be performed when the\n  /// ASTContext is destroyed.\n  // FIXME: We really should have a better mechanism in the ASTContext to\n  // manage running destructors for types which do variable sized allocation\n  // within the AST. In some places we thread the AST bump pointer allocator\n  // into the datastructures which avoids this mess during deallocation but is\n  // wasteful of memory, and here we require a lot of error prone book keeping\n  // in order to track and run destructors while we're tearing things down.\n  using DeallocationFunctionsAndArguments =\n      llvm::SmallVector<std::pair<void (*)(void *), void *>, 16>;\n  mutable DeallocationFunctionsAndArguments Deallocations;\n\n  // FIXME: This currently contains the set of StoredDeclMaps used\n  // by DeclContext objects.  This probably should not be in ASTContext,\n  // but we include it here so that ASTContext can quickly deallocate them.\n  llvm::PointerIntPair<StoredDeclsMap *, 1> LastSDM;\n\n  std::vector<Decl *> TraversalScope;\n\n  std::unique_ptr<VTableContextBase> VTContext;\n\n  void ReleaseDeclContextMaps();\n\npublic:\n  enum PragmaSectionFlag : unsigned {\n    PSF_None = 0,\n    PSF_Read = 0x1,\n    PSF_Write = 0x2,\n    PSF_Execute = 0x4,\n    PSF_Implicit = 0x8,\n    PSF_ZeroInit = 0x10,\n    PSF_Invalid = 0x80000000U,\n  };\n\n  struct SectionInfo {\n    NamedDecl *Decl;\n    SourceLocation PragmaSectionLocation;\n    int SectionFlags;\n\n    SectionInfo() = default;\n    SectionInfo(NamedDecl *Decl, SourceLocation PragmaSectionLocation,\n                int SectionFlags)\n        : Decl(Decl), PragmaSectionLocation(PragmaSectionLocation),\n          SectionFlags(SectionFlags) {}\n  };\n\n  llvm::StringMap<SectionInfo> SectionInfos;\n\n  /// Return a new OMPTraitInfo object owned by this context.\n  OMPTraitInfo &getNewOMPTraitInfo();\n\n  /// Whether a C++ static variable may be externalized.\n  bool mayExternalizeStaticVar(const Decl *D) const;\n\n  /// Whether a C++ static variable should be externalized.\n  bool shouldExternalizeStaticVar(const Decl *D) const;\n\n  StringRef getCUIDHash() const;\n\nprivate:\n  /// All OMPTraitInfo objects live in this collection, one per\n  /// `pragma omp [begin] declare variant` directive.\n  SmallVector<std::unique_ptr<OMPTraitInfo>, 4> OMPTraitInfoVector;\n};\n\n/// Insertion operator for diagnostics.\nconst StreamingDiagnostic &operator<<(const StreamingDiagnostic &DB,\n                                      const ASTContext::SectionInfo &Section);\n\n/// Utility function for constructing a nullary selector.\ninline Selector GetNullarySelector(StringRef name, ASTContext &Ctx) {\n  IdentifierInfo* II = &Ctx.Idents.get(name);\n  return Ctx.Selectors.getSelector(0, &II);\n}\n\n/// Utility function for constructing an unary selector.\ninline Selector GetUnarySelector(StringRef name, ASTContext &Ctx) {\n  IdentifierInfo* II = &Ctx.Idents.get(name);\n  return Ctx.Selectors.getSelector(1, &II);\n}\n\n} // namespace clang\n\n// operator new and delete aren't allowed inside namespaces.\n\n/// Placement new for using the ASTContext's allocator.\n///\n/// This placement form of operator new uses the ASTContext's allocator for\n/// obtaining memory.\n///\n/// IMPORTANT: These are also declared in clang/AST/ASTContextAllocate.h!\n/// Any changes here need to also be made there.\n///\n/// We intentionally avoid using a nothrow specification here so that the calls\n/// to this operator will not perform a null check on the result -- the\n/// underlying allocator never returns null pointers.\n///\n/// Usage looks like this (assuming there's an ASTContext 'Context' in scope):\n/// @code\n/// // Default alignment (8)\n/// IntegerLiteral *Ex = new (Context) IntegerLiteral(arguments);\n/// // Specific alignment\n/// IntegerLiteral *Ex2 = new (Context, 4) IntegerLiteral(arguments);\n/// @endcode\n/// Memory allocated through this placement new operator does not need to be\n/// explicitly freed, as ASTContext will free all of this memory when it gets\n/// destroyed. Please note that you cannot use delete on the pointer.\n///\n/// @param Bytes The number of bytes to allocate. Calculated by the compiler.\n/// @param C The ASTContext that provides the allocator.\n/// @param Alignment The alignment of the allocated memory (if the underlying\n///                  allocator supports it).\n/// @return The allocated memory. Could be nullptr.\ninline void *operator new(size_t Bytes, const clang::ASTContext &C,\n                          size_t Alignment /* = 8 */) {\n  return C.Allocate(Bytes, Alignment);\n}\n\n/// Placement delete companion to the new above.\n///\n/// This operator is just a companion to the new above. There is no way of\n/// invoking it directly; see the new operator for more details. This operator\n/// is called implicitly by the compiler if a placement new expression using\n/// the ASTContext throws in the object constructor.\ninline void operator delete(void *Ptr, const clang::ASTContext &C, size_t) {\n  C.Deallocate(Ptr);\n}\n\n/// This placement form of operator new[] uses the ASTContext's allocator for\n/// obtaining memory.\n///\n/// We intentionally avoid using a nothrow specification here so that the calls\n/// to this operator will not perform a null check on the result -- the\n/// underlying allocator never returns null pointers.\n///\n/// Usage looks like this (assuming there's an ASTContext 'Context' in scope):\n/// @code\n/// // Default alignment (8)\n/// char *data = new (Context) char[10];\n/// // Specific alignment\n/// char *data = new (Context, 4) char[10];\n/// @endcode\n/// Memory allocated through this placement new[] operator does not need to be\n/// explicitly freed, as ASTContext will free all of this memory when it gets\n/// destroyed. Please note that you cannot use delete on the pointer.\n///\n/// @param Bytes The number of bytes to allocate. Calculated by the compiler.\n/// @param C The ASTContext that provides the allocator.\n/// @param Alignment The alignment of the allocated memory (if the underlying\n///                  allocator supports it).\n/// @return The allocated memory. Could be nullptr.\ninline void *operator new[](size_t Bytes, const clang::ASTContext& C,\n                            size_t Alignment /* = 8 */) {\n  return C.Allocate(Bytes, Alignment);\n}\n\n/// Placement delete[] companion to the new[] above.\n///\n/// This operator is just a companion to the new[] above. There is no way of\n/// invoking it directly; see the new[] operator for more details. This operator\n/// is called implicitly by the compiler if a placement new[] expression using\n/// the ASTContext throws in the object constructor.\ninline void operator delete[](void *Ptr, const clang::ASTContext &C, size_t) {\n  C.Deallocate(Ptr);\n}\n\n/// Create the representation of a LazyGenerationalUpdatePtr.\ntemplate <typename Owner, typename T,\n          void (clang::ExternalASTSource::*Update)(Owner)>\ntypename clang::LazyGenerationalUpdatePtr<Owner, T, Update>::ValueType\n    clang::LazyGenerationalUpdatePtr<Owner, T, Update>::makeValue(\n        const clang::ASTContext &Ctx, T Value) {\n  // Note, this is implemented here so that ExternalASTSource.h doesn't need to\n  // include ASTContext.h. We explicitly instantiate it for all relevant types\n  // in ASTContext.cpp.\n  if (auto *Source = Ctx.getExternalSource())\n    return new (Ctx) LazyData(Source, Value);\n  return Value;\n}\n\n#endif // LLVM_CLANG_AST_ASTCONTEXT_H\n"}, "2": {"id": 2, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/AttrIterator.h", "content": "//===- AttrIterator.h - Classes for attribute iteration ---------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n//  This file defines the Attr vector and specific_attr_iterator interfaces.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_AST_ATTRITERATOR_H\n#define LLVM_CLANG_AST_ATTRITERATOR_H\n\n#include \"clang/Basic/LLVM.h\"\n#include \"llvm/ADT/SmallVector.h\"\n#include \"llvm/Support/Casting.h\"\n#include <cassert>\n#include <cstddef>\n#include <iterator>\n\nnamespace clang {\n\nclass ASTContext;\nclass Attr;\n\n/// AttrVec - A vector of Attr, which is how they are stored on the AST.\nusing AttrVec = SmallVector<Attr *, 4>;\n\n/// specific_attr_iterator - Iterates over a subrange of an AttrVec, only\n/// providing attributes that are of a specific type.\ntemplate <typename SpecificAttr, typename Container = AttrVec>\nclass specific_attr_iterator {\n  using Iterator = typename Container::const_iterator;\n\n  /// Current - The current, underlying iterator.\n  /// In order to ensure we don't dereference an invalid iterator unless\n  /// specifically requested, we don't necessarily advance this all the\n  /// way. Instead, we advance it when an operation is requested; if the\n  /// operation is acting on what should be a past-the-end iterator,\n  /// then we offer no guarantees, but this way we do not dereference a\n  /// past-the-end iterator when we move to a past-the-end position.\n  mutable Iterator Current;\n\n  void AdvanceToNext() const {\n    while (!isa<SpecificAttr>(*Current))\n      ++Current;\n  }\n\n  void AdvanceToNext(Iterator I) const {\n    while (Current != I && !isa<SpecificAttr>(*Current))\n      ++Current;\n  }\n\npublic:\n  using value_type = SpecificAttr *;\n  using reference = SpecificAttr *;\n  using pointer = SpecificAttr *;\n  using iterator_category = std::forward_iterator_tag;\n  using difference_type = std::ptrdiff_t;\n\n  specific_attr_iterator() = default;\n  explicit specific_attr_iterator(Iterator i) : Current(i) {}\n\n  reference operator*() const {\n    AdvanceToNext();\n    return cast<SpecificAttr>(*Current);\n  }\n  pointer operator->() const {\n    AdvanceToNext();\n    return cast<SpecificAttr>(*Current);\n  }\n\n  specific_attr_iterator& operator++() {\n    ++Current;\n    return *this;\n  }\n  specific_attr_iterator operator++(int) {\n    specific_attr_iterator Tmp(*this);\n    ++(*this);\n    return Tmp;\n  }\n\n  friend bool operator==(specific_attr_iterator Left,\n                         specific_attr_iterator Right) {\n    assert((Left.Current == nullptr) == (Right.Current == nullptr));\n    if (Left.Current < Right.Current)\n      Left.AdvanceToNext(Right.Current);\n    else\n      Right.AdvanceToNext(Left.Current);\n    return Left.Current == Right.Current;\n  }\n  friend bool operator!=(specific_attr_iterator Left,\n                         specific_attr_iterator Right) {\n    return !(Left == Right);\n  }\n};\n\ntemplate <typename SpecificAttr, typename Container>\ninline specific_attr_iterator<SpecificAttr, Container>\n          specific_attr_begin(const Container& container) {\n  return specific_attr_iterator<SpecificAttr, Container>(container.begin());\n}\ntemplate <typename SpecificAttr, typename Container>\ninline specific_attr_iterator<SpecificAttr, Container>\n          specific_attr_end(const Container& container) {\n  return specific_attr_iterator<SpecificAttr, Container>(container.end());\n}\n\ntemplate <typename SpecificAttr, typename Container>\ninline bool hasSpecificAttr(const Container& container) {\n  return specific_attr_begin<SpecificAttr>(container) !=\n          specific_attr_end<SpecificAttr>(container);\n}\ntemplate <typename SpecificAttr, typename Container>\ninline SpecificAttr *getSpecificAttr(const Container& container) {\n  specific_attr_iterator<SpecificAttr, Container> i =\n      specific_attr_begin<SpecificAttr>(container);\n  if (i != specific_attr_end<SpecificAttr>(container))\n    return *i;\n  else\n    return nullptr;\n}\n\n} // namespace clang\n\n#endif // LLVM_CLANG_AST_ATTRITERATOR_H\n"}, "3": {"id": 3, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/CanonicalType.h", "content": "//===- CanonicalType.h - C Language Family Type Representation --*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n//  This file defines the CanQual class template, which provides access to\n//  canonical types.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_AST_CANONICALTYPE_H\n#define LLVM_CLANG_AST_CANONICALTYPE_H\n\n#include \"clang/AST/Type.h\"\n#include \"clang/Basic/Diagnostic.h\"\n#include \"clang/Basic/SourceLocation.h\"\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/ADT/FoldingSet.h\"\n#include \"llvm/ADT/iterator.h\"\n#include \"llvm/Support/Casting.h\"\n#include \"llvm/Support/PointerLikeTypeTraits.h\"\n#include <cassert>\n#include <iterator>\n#include <type_traits>\n\nnamespace clang {\n\ntemplate<typename T> class CanProxy;\ntemplate<typename T> struct CanProxyAdaptor;\nclass CXXRecordDecl;\nclass EnumDecl;\nclass Expr;\nclass IdentifierInfo;\nclass ObjCInterfaceDecl;\nclass RecordDecl;\nclass TagDecl;\nclass TemplateTypeParmDecl;\n\n//----------------------------------------------------------------------------//\n// Canonical, qualified type template\n//----------------------------------------------------------------------------//\n\n/// Represents a canonical, potentially-qualified type.\n///\n/// The CanQual template is a lightweight smart pointer that provides access\n/// to the canonical representation of a type, where all typedefs and other\n/// syntactic sugar has been eliminated. A CanQualType may also have various\n/// qualifiers (const, volatile, restrict) attached to it.\n///\n/// The template type parameter @p T is one of the Type classes (PointerType,\n/// BuiltinType, etc.). The type stored within @c CanQual<T> will be of that\n/// type (or some subclass of that type). The typedef @c CanQualType is just\n/// a shorthand for @c CanQual<Type>.\n///\n/// An instance of @c CanQual<T> can be implicitly converted to a\n/// @c CanQual<U> when T is derived from U, which essentially provides an\n/// implicit upcast. For example, @c CanQual<LValueReferenceType> can be\n/// converted to @c CanQual<ReferenceType>. Note that any @c CanQual type can\n/// be implicitly converted to a QualType, but the reverse operation requires\n/// a call to ASTContext::getCanonicalType().\ntemplate<typename T = Type>\nclass CanQual {\n  /// The actual, canonical type.\n  QualType Stored;\n\npublic:\n  /// Constructs a NULL canonical type.\n  CanQual() = default;\n\n  /// Converting constructor that permits implicit upcasting of\n  /// canonical type pointers.\n  template <typename U>\n  CanQual(const CanQual<U> &Other,\n          std::enable_if_t<std::is_base_of<T, U>::value, int> = 0);\n\n  /// Retrieve the underlying type pointer, which refers to a\n  /// canonical type.\n  ///\n  /// The underlying pointer must not be nullptr.\n  const T *getTypePtr() const { return cast<T>(Stored.getTypePtr()); }\n\n  /// Retrieve the underlying type pointer, which refers to a\n  /// canonical type, or nullptr.\n  const T *getTypePtrOrNull() const {\n    return cast_or_null<T>(Stored.getTypePtrOrNull());\n  }\n\n  /// Implicit conversion to a qualified type.\n  operator QualType() const { return Stored; }\n\n  /// Implicit conversion to bool.\n  explicit operator bool() const { return !isNull(); }\n\n  bool isNull() const {\n    return Stored.isNull();\n  }\n\n  SplitQualType split() const { return Stored.split(); }\n\n  /// Retrieve a canonical type pointer with a different static type,\n  /// upcasting or downcasting as needed.\n  ///\n  /// The getAs() function is typically used to try to downcast to a\n  /// more specific (canonical) type in the type system. For example:\n  ///\n  /// @code\n  /// void f(CanQual<Type> T) {\n  ///   if (CanQual<PointerType> Ptr = T->getAs<PointerType>()) {\n  ///     // look at Ptr's pointee type\n  ///   }\n  /// }\n  /// @endcode\n  ///\n  /// \\returns A proxy pointer to the same type, but with the specified\n  /// static type (@p U). If the dynamic type is not the specified static type\n  /// or a derived class thereof, a NULL canonical type.\n  template<typename U> CanProxy<U> getAs() const;\n\n  template<typename U> CanProxy<U> castAs() const;\n\n  /// Overloaded arrow operator that produces a canonical type\n  /// proxy.\n  CanProxy<T> operator->() const;\n\n  /// Retrieve all qualifiers.\n  Qualifiers getQualifiers() const { return Stored.getLocalQualifiers(); }\n\n  /// Retrieve the const/volatile/restrict qualifiers.\n  unsigned getCVRQualifiers() const { return Stored.getLocalCVRQualifiers(); }\n\n  /// Determines whether this type has any qualifiers\n  bool hasQualifiers() const { return Stored.hasLocalQualifiers(); }\n\n  bool isConstQualified() const {\n    return Stored.isLocalConstQualified();\n  }\n\n  bool isVolatileQualified() const {\n    return Stored.isLocalVolatileQualified();\n  }\n\n  bool isRestrictQualified() const {\n    return Stored.isLocalRestrictQualified();\n  }\n\n  /// Determines if this canonical type is furthermore\n  /// canonical as a parameter.  The parameter-canonicalization\n  /// process decays arrays to pointers and drops top-level qualifiers.\n  bool isCanonicalAsParam() const {\n    return Stored.isCanonicalAsParam();\n  }\n\n  /// Retrieve the unqualified form of this type.\n  CanQual<T> getUnqualifiedType() const;\n\n  /// Retrieves a version of this type with const applied.\n  /// Note that this does not always yield a canonical type.\n  QualType withConst() const {\n    return Stored.withConst();\n  }\n\n  /// Determines whether this canonical type is more qualified than\n  /// the @p Other canonical type.\n  bool isMoreQualifiedThan(CanQual<T> Other) const {\n    return Stored.isMoreQualifiedThan(Other.Stored);\n  }\n\n  /// Determines whether this canonical type is at least as qualified as\n  /// the @p Other canonical type.\n  bool isAtLeastAsQualifiedAs(CanQual<T> Other) const {\n    return Stored.isAtLeastAsQualifiedAs(Other.Stored);\n  }\n\n  /// If the canonical type is a reference type, returns the type that\n  /// it refers to; otherwise, returns the type itself.\n  CanQual<Type> getNonReferenceType() const;\n\n  /// Retrieve the internal representation of this canonical type.\n  void *getAsOpaquePtr() const { return Stored.getAsOpaquePtr(); }\n\n  /// Construct a canonical type from its internal representation.\n  static CanQual<T> getFromOpaquePtr(void *Ptr);\n\n  /// Builds a canonical type from a QualType.\n  ///\n  /// This routine is inherently unsafe, because it requires the user to\n  /// ensure that the given type is a canonical type with the correct\n  // (dynamic) type.\n  static CanQual<T> CreateUnsafe(QualType Other);\n\n  void dump() const { Stored.dump(); }\n\n  void Profile(llvm::FoldingSetNodeID &ID) const {\n    ID.AddPointer(getAsOpaquePtr());\n  }\n};\n\ntemplate<typename T, typename U>\ninline bool operator==(CanQual<T> x, CanQual<U> y) {\n  return x.getAsOpaquePtr() == y.getAsOpaquePtr();\n}\n\ntemplate<typename T, typename U>\ninline bool operator!=(CanQual<T> x, CanQual<U> y) {\n  return x.getAsOpaquePtr() != y.getAsOpaquePtr();\n}\n\n/// Represents a canonical, potentially-qualified type.\nusing CanQualType = CanQual<Type>;\n\ninline CanQualType Type::getCanonicalTypeUnqualified() const {\n  return CanQualType::CreateUnsafe(getCanonicalTypeInternal());\n}\n\ninline const StreamingDiagnostic &operator<<(const StreamingDiagnostic &DB,\n                                             CanQualType T) {\n  DB << static_cast<QualType>(T);\n  return DB;\n}\n\n//----------------------------------------------------------------------------//\n// Internal proxy classes used by canonical types\n//----------------------------------------------------------------------------//\n\n#define LLVM_CLANG_CANPROXY_TYPE_ACCESSOR(Accessor)                    \\\nCanQualType Accessor() const {                                           \\\nreturn CanQualType::CreateUnsafe(this->getTypePtr()->Accessor());      \\\n}\n\n#define LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(Type, Accessor)             \\\nType Accessor() const { return this->getTypePtr()->Accessor(); }\n\n/// Base class of all canonical proxy types, which is responsible for\n/// storing the underlying canonical type and providing basic conversions.\ntemplate<typename T>\nclass CanProxyBase {\nprotected:\n  CanQual<T> Stored;\n\npublic:\n  /// Retrieve the pointer to the underlying Type\n  const T *getTypePtr() const { return Stored.getTypePtr(); }\n\n  /// Implicit conversion to the underlying pointer.\n  ///\n  /// Also provides the ability to use canonical type proxies in a Boolean\n  // context,e.g.,\n  /// @code\n  ///   if (CanQual<PointerType> Ptr = T->getAs<PointerType>()) { ... }\n  /// @endcode\n  operator const T*() const { return this->Stored.getTypePtrOrNull(); }\n\n  /// Try to convert the given canonical type to a specific structural\n  /// type.\n  template<typename U> CanProxy<U> getAs() const {\n    return this->Stored.template getAs<U>();\n  }\n\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(Type::TypeClass, getTypeClass)\n\n  // Type predicates\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(bool, isObjectType)\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(bool, isIncompleteType)\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(bool, isSizelessType)\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(bool, isSizelessBuiltinType)\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(bool, isIncompleteOrObjectType)\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(bool, isVariablyModifiedType)\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(bool, isIntegerType)\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(bool, isEnumeralType)\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(bool, isBooleanType)\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(bool, isCharType)\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(bool, isWideCharType)\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(bool, isIntegralType)\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(bool, isIntegralOrEnumerationType)\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(bool, isRealFloatingType)\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(bool, isComplexType)\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(bool, isAnyComplexType)\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(bool, isFloatingType)\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(bool, isRealType)\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(bool, isArithmeticType)\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(bool, isVoidType)\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(bool, isDerivedType)\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(bool, isScalarType)\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(bool, isAggregateType)\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(bool, isAnyPointerType)\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(bool, isVoidPointerType)\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(bool, isFunctionPointerType)\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(bool, isMemberFunctionPointerType)\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(bool, isClassType)\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(bool, isStructureType)\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(bool, isInterfaceType)\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(bool, isStructureOrClassType)\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(bool, isUnionType)\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(bool, isComplexIntegerType)\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(bool, isNullPtrType)\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(bool, isDependentType)\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(bool, isOverloadableType)\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(bool, isArrayType)\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(bool, hasPointerRepresentation)\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(bool, hasObjCPointerRepresentation)\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(bool, hasIntegerRepresentation)\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(bool, hasSignedIntegerRepresentation)\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(bool, hasUnsignedIntegerRepresentation)\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(bool, hasFloatingRepresentation)\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(bool, isPromotableIntegerType)\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(bool, isSignedIntegerType)\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(bool, isUnsignedIntegerType)\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(bool, isSignedIntegerOrEnumerationType)\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(bool, isUnsignedIntegerOrEnumerationType)\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(bool, isConstantSizeType)\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(bool, isSpecifierType)\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(CXXRecordDecl*, getAsCXXRecordDecl)\n\n  /// Retrieve the proxy-adaptor type.\n  ///\n  /// This arrow operator is used when CanProxyAdaptor has been specialized\n  /// for the given type T. In that case, we reference members of the\n  /// CanProxyAdaptor specialization. Otherwise, this operator will be hidden\n  /// by the arrow operator in the primary CanProxyAdaptor template.\n  const CanProxyAdaptor<T> *operator->() const {\n    return static_cast<const CanProxyAdaptor<T> *>(this);\n  }\n};\n\n/// Replaceable canonical proxy adaptor class that provides the link\n/// between a canonical type and the accessors of the type.\n///\n/// The CanProxyAdaptor is a replaceable class template that is instantiated\n/// as part of each canonical proxy type. The primary template merely provides\n/// redirection to the underlying type (T), e.g., @c PointerType. One can\n/// provide specializations of this class template for each underlying type\n/// that provide accessors returning canonical types (@c CanQualType) rather\n/// than the more typical @c QualType, to propagate the notion of \"canonical\"\n/// through the system.\ntemplate<typename T>\nstruct CanProxyAdaptor : CanProxyBase<T> {};\n\n/// Canonical proxy type returned when retrieving the members of a\n/// canonical type or as the result of the @c CanQual<T>::getAs member\n/// function.\n///\n/// The CanProxy type mainly exists as a proxy through which operator-> will\n/// look to either map down to a raw T* (e.g., PointerType*) or to a proxy\n/// type that provides canonical-type access to the fields of the type.\ntemplate<typename T>\nclass CanProxy : public CanProxyAdaptor<T> {\npublic:\n  /// Build a NULL proxy.\n  CanProxy() = default;\n\n  /// Build a proxy to the given canonical type.\n  CanProxy(CanQual<T> Stored) { this->Stored = Stored; }\n\n  /// Implicit conversion to the stored canonical type.\n  operator CanQual<T>() const { return this->Stored; }\n};\n\n} // namespace clang\n\nnamespace llvm {\n\n/// Implement simplify_type for CanQual<T>, so that we can dyn_cast from\n/// CanQual<T> to a specific Type class. We're prefer isa/dyn_cast/cast/etc.\n/// to return smart pointer (proxies?).\ntemplate<typename T>\nstruct simplify_type< ::clang::CanQual<T>> {\n  using SimpleType = const T *;\n\n  static SimpleType getSimplifiedValue(::clang::CanQual<T> Val) {\n    return Val.getTypePtr();\n  }\n};\n\n// Teach SmallPtrSet that CanQual<T> is \"basically a pointer\".\ntemplate<typename T>\nstruct PointerLikeTypeTraits<clang::CanQual<T>> {\n  static void *getAsVoidPointer(clang::CanQual<T> P) {\n    return P.getAsOpaquePtr();\n  }\n\n  static clang::CanQual<T> getFromVoidPointer(void *P) {\n    return clang::CanQual<T>::getFromOpaquePtr(P);\n  }\n\n  // qualifier information is encoded in the low bits.\n  static constexpr int NumLowBitsAvailable = 0;\n};\n\n} // namespace llvm\n\nnamespace clang {\n\n//----------------------------------------------------------------------------//\n// Canonical proxy adaptors for canonical type nodes.\n//----------------------------------------------------------------------------//\n\n/// Iterator adaptor that turns an iterator over canonical QualTypes\n/// into an iterator over CanQualTypes.\ntemplate <typename InputIterator>\nstruct CanTypeIterator\n    : llvm::iterator_adaptor_base<\n          CanTypeIterator<InputIterator>, InputIterator,\n          typename std::iterator_traits<InputIterator>::iterator_category,\n          CanQualType,\n          typename std::iterator_traits<InputIterator>::difference_type,\n          CanProxy<Type>, CanQualType> {\n  CanTypeIterator() = default;\n  explicit CanTypeIterator(InputIterator Iter)\n      : CanTypeIterator::iterator_adaptor_base(std::move(Iter)) {}\n\n  CanQualType operator*() const { return CanQualType::CreateUnsafe(*this->I); }\n  CanProxy<Type> operator->() const;\n};\n\ntemplate<>\nstruct CanProxyAdaptor<ComplexType> : public CanProxyBase<ComplexType> {\n  LLVM_CLANG_CANPROXY_TYPE_ACCESSOR(getElementType)\n};\n\ntemplate<>\nstruct CanProxyAdaptor<PointerType> : public CanProxyBase<PointerType> {\n  LLVM_CLANG_CANPROXY_TYPE_ACCESSOR(getPointeeType)\n};\n\ntemplate<>\nstruct CanProxyAdaptor<BlockPointerType>\n  : public CanProxyBase<BlockPointerType> {\n  LLVM_CLANG_CANPROXY_TYPE_ACCESSOR(getPointeeType)\n};\n\ntemplate<>\nstruct CanProxyAdaptor<ReferenceType> : public CanProxyBase<ReferenceType> {\n  LLVM_CLANG_CANPROXY_TYPE_ACCESSOR(getPointeeType)\n};\n\ntemplate<>\nstruct CanProxyAdaptor<LValueReferenceType>\n  : public CanProxyBase<LValueReferenceType> {\n  LLVM_CLANG_CANPROXY_TYPE_ACCESSOR(getPointeeType)\n};\n\ntemplate<>\nstruct CanProxyAdaptor<RValueReferenceType>\n  : public CanProxyBase<RValueReferenceType> {\n  LLVM_CLANG_CANPROXY_TYPE_ACCESSOR(getPointeeType)\n};\n\ntemplate<>\nstruct CanProxyAdaptor<MemberPointerType>\n  : public CanProxyBase<MemberPointerType> {\n  LLVM_CLANG_CANPROXY_TYPE_ACCESSOR(getPointeeType)\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(const Type *, getClass)\n};\n\n// CanProxyAdaptors for arrays are intentionally unimplemented because\n// they are not safe.\ntemplate<> struct CanProxyAdaptor<ArrayType>;\ntemplate<> struct CanProxyAdaptor<ConstantArrayType>;\ntemplate<> struct CanProxyAdaptor<IncompleteArrayType>;\ntemplate<> struct CanProxyAdaptor<VariableArrayType>;\ntemplate<> struct CanProxyAdaptor<DependentSizedArrayType>;\n\ntemplate<>\nstruct CanProxyAdaptor<DependentSizedExtVectorType>\n  : public CanProxyBase<DependentSizedExtVectorType> {\n  LLVM_CLANG_CANPROXY_TYPE_ACCESSOR(getElementType)\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(const Expr *, getSizeExpr)\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(SourceLocation, getAttributeLoc)\n};\n\ntemplate<>\nstruct CanProxyAdaptor<VectorType> : public CanProxyBase<VectorType> {\n  LLVM_CLANG_CANPROXY_TYPE_ACCESSOR(getElementType)\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(unsigned, getNumElements)\n};\n\ntemplate<>\nstruct CanProxyAdaptor<ExtVectorType> : public CanProxyBase<ExtVectorType> {\n  LLVM_CLANG_CANPROXY_TYPE_ACCESSOR(getElementType)\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(unsigned, getNumElements)\n};\n\ntemplate<>\nstruct CanProxyAdaptor<FunctionType> : public CanProxyBase<FunctionType> {\n  LLVM_CLANG_CANPROXY_TYPE_ACCESSOR(getReturnType)\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(FunctionType::ExtInfo, getExtInfo)\n};\n\ntemplate<>\nstruct CanProxyAdaptor<FunctionNoProtoType>\n  : public CanProxyBase<FunctionNoProtoType> {\n  LLVM_CLANG_CANPROXY_TYPE_ACCESSOR(getReturnType)\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(FunctionType::ExtInfo, getExtInfo)\n};\n\ntemplate<>\nstruct CanProxyAdaptor<FunctionProtoType>\n  : public CanProxyBase<FunctionProtoType> {\n  LLVM_CLANG_CANPROXY_TYPE_ACCESSOR(getReturnType)\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(FunctionType::ExtInfo, getExtInfo)\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(unsigned, getNumParams)\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(bool, hasExtParameterInfos)\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(\n            ArrayRef<FunctionProtoType::ExtParameterInfo>, getExtParameterInfos)\n\n  CanQualType getParamType(unsigned i) const {\n    return CanQualType::CreateUnsafe(this->getTypePtr()->getParamType(i));\n  }\n\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(bool, isVariadic)\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(Qualifiers, getMethodQuals)\n\n  using param_type_iterator =\n      CanTypeIterator<FunctionProtoType::param_type_iterator>;\n\n  param_type_iterator param_type_begin() const {\n    return param_type_iterator(this->getTypePtr()->param_type_begin());\n  }\n\n  param_type_iterator param_type_end() const {\n    return param_type_iterator(this->getTypePtr()->param_type_end());\n  }\n\n  // Note: canonical function types never have exception specifications\n};\n\ntemplate<>\nstruct CanProxyAdaptor<TypeOfType> : public CanProxyBase<TypeOfType> {\n  LLVM_CLANG_CANPROXY_TYPE_ACCESSOR(getUnderlyingType)\n};\n\ntemplate<>\nstruct CanProxyAdaptor<DecltypeType> : public CanProxyBase<DecltypeType> {\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(Expr *, getUnderlyingExpr)\n  LLVM_CLANG_CANPROXY_TYPE_ACCESSOR(getUnderlyingType)\n};\n\ntemplate <>\nstruct CanProxyAdaptor<UnaryTransformType>\n    : public CanProxyBase<UnaryTransformType> {\n  LLVM_CLANG_CANPROXY_TYPE_ACCESSOR(getBaseType)\n  LLVM_CLANG_CANPROXY_TYPE_ACCESSOR(getUnderlyingType)\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(UnaryTransformType::UTTKind, getUTTKind)\n};\n\ntemplate<>\nstruct CanProxyAdaptor<TagType> : public CanProxyBase<TagType> {\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(TagDecl *, getDecl)\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(bool, isBeingDefined)\n};\n\ntemplate<>\nstruct CanProxyAdaptor<RecordType> : public CanProxyBase<RecordType> {\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(RecordDecl *, getDecl)\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(bool, isBeingDefined)\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(bool, hasConstFields)\n};\n\ntemplate<>\nstruct CanProxyAdaptor<EnumType> : public CanProxyBase<EnumType> {\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(EnumDecl *, getDecl)\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(bool, isBeingDefined)\n};\n\ntemplate<>\nstruct CanProxyAdaptor<TemplateTypeParmType>\n  : public CanProxyBase<TemplateTypeParmType> {\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(unsigned, getDepth)\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(unsigned, getIndex)\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(bool, isParameterPack)\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(TemplateTypeParmDecl *, getDecl)\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(IdentifierInfo *, getIdentifier)\n};\n\ntemplate<>\nstruct CanProxyAdaptor<ObjCObjectType>\n  : public CanProxyBase<ObjCObjectType> {\n  LLVM_CLANG_CANPROXY_TYPE_ACCESSOR(getBaseType)\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(const ObjCInterfaceDecl *,\n                                      getInterface)\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(bool, isObjCUnqualifiedId)\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(bool, isObjCUnqualifiedClass)\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(bool, isObjCQualifiedId)\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(bool, isObjCQualifiedClass)\n\n  using qual_iterator = ObjCObjectPointerType::qual_iterator;\n\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(qual_iterator, qual_begin)\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(qual_iterator, qual_end)\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(bool, qual_empty)\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(unsigned, getNumProtocols)\n};\n\ntemplate<>\nstruct CanProxyAdaptor<ObjCObjectPointerType>\n  : public CanProxyBase<ObjCObjectPointerType> {\n  LLVM_CLANG_CANPROXY_TYPE_ACCESSOR(getPointeeType)\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(const ObjCInterfaceType *,\n                                      getInterfaceType)\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(bool, isObjCIdType)\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(bool, isObjCClassType)\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(bool, isObjCQualifiedIdType)\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(bool, isObjCQualifiedClassType)\n\n  using qual_iterator = ObjCObjectPointerType::qual_iterator;\n\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(qual_iterator, qual_begin)\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(qual_iterator, qual_end)\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(bool, qual_empty)\n  LLVM_CLANG_CANPROXY_SIMPLE_ACCESSOR(unsigned, getNumProtocols)\n};\n\n//----------------------------------------------------------------------------//\n// Method and function definitions\n//----------------------------------------------------------------------------//\ntemplate<typename T>\ninline CanQual<T> CanQual<T>::getUnqualifiedType() const {\n  return CanQual<T>::CreateUnsafe(Stored.getLocalUnqualifiedType());\n}\n\ntemplate<typename T>\ninline CanQual<Type> CanQual<T>::getNonReferenceType() const {\n  if (CanQual<ReferenceType> RefType = getAs<ReferenceType>())\n    return RefType->getPointeeType();\n  else\n    return *this;\n}\n\ntemplate<typename T>\nCanQual<T> CanQual<T>::getFromOpaquePtr(void *Ptr) {\n  CanQual<T> Result;\n  Result.Stored = QualType::getFromOpaquePtr(Ptr);\n  assert((!Result || Result.Stored.getAsOpaquePtr() == (void*)-1 ||\n          Result.Stored.isCanonical()) && \"Type is not canonical!\");\n  return Result;\n}\n\ntemplate<typename T>\nCanQual<T> CanQual<T>::CreateUnsafe(QualType Other) {\n  assert((Other.isNull() || Other.isCanonical()) && \"Type is not canonical!\");\n  assert((Other.isNull() || isa<T>(Other.getTypePtr())) &&\n         \"Dynamic type does not meet the static type's requires\");\n  CanQual<T> Result;\n  Result.Stored = Other;\n  return Result;\n}\n\ntemplate<typename T>\ntemplate<typename U>\nCanProxy<U> CanQual<T>::getAs() const {\n  static_assert(!TypeIsArrayType<T>::value,\n                \"ArrayType cannot be used with getAs!\");\n\n  if (Stored.isNull())\n    return CanProxy<U>();\n\n  if (isa<U>(Stored.getTypePtr()))\n    return CanQual<U>::CreateUnsafe(Stored);\n\n  return CanProxy<U>();\n}\n\ntemplate<typename T>\ntemplate<typename U>\nCanProxy<U> CanQual<T>::castAs() const {\n  static_assert(!TypeIsArrayType<U>::value,\n                \"ArrayType cannot be used with castAs!\");\n\n  assert(!Stored.isNull() && isa<U>(Stored.getTypePtr()));\n  return CanQual<U>::CreateUnsafe(Stored);\n}\n\ntemplate<typename T>\nCanProxy<T> CanQual<T>::operator->() const {\n  return CanProxy<T>(*this);\n}\n\ntemplate <typename InputIterator>\nCanProxy<Type> CanTypeIterator<InputIterator>::operator->() const {\n  return CanProxy<Type>(*this);\n}\n\n} // namespace clang\n\n#endif // LLVM_CLANG_AST_CANONICALTYPE_H\n"}, "4": {"id": 4, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/CharUnits.h", "content": "//===--- CharUnits.h - Character units for sizes and offsets ----*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n//  This file defines the CharUnits class\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_AST_CHARUNITS_H\n#define LLVM_CLANG_AST_CHARUNITS_H\n\n#include \"llvm/ADT/DenseMapInfo.h\"\n#include \"llvm/Support/Alignment.h\"\n#include \"llvm/Support/DataTypes.h\"\n#include \"llvm/Support/MathExtras.h\"\n\nnamespace clang {\n\n  /// CharUnits - This is an opaque type for sizes expressed in character units.\n  /// Instances of this type represent a quantity as a multiple of the size\n  /// of the standard C type, char, on the target architecture. As an opaque\n  /// type, CharUnits protects you from accidentally combining operations on\n  /// quantities in bit units and character units.\n  ///\n  /// In both C and C++, an object of type 'char', 'signed char', or 'unsigned\n  /// char' occupies exactly one byte, so 'character unit' and 'byte' refer to\n  /// the same quantity of storage. However, we use the term 'character unit'\n  /// rather than 'byte' to avoid an implication that a character unit is\n  /// exactly 8 bits.\n  ///\n  /// For portability, never assume that a target character is 8 bits wide. Use\n  /// CharUnit values wherever you calculate sizes, offsets, or alignments\n  /// in character units.\n  class CharUnits {\n    public:\n      typedef int64_t QuantityType;\n\n    private:\n      QuantityType Quantity = 0;\n\n      explicit CharUnits(QuantityType C) : Quantity(C) {}\n\n    public:\n\n      /// CharUnits - A default constructor.\n      CharUnits() = default;\n\n      /// Zero - Construct a CharUnits quantity of zero.\n      static CharUnits Zero() {\n        return CharUnits(0);\n      }\n\n      /// One - Construct a CharUnits quantity of one.\n      static CharUnits One() {\n        return CharUnits(1);\n      }\n\n      /// fromQuantity - Construct a CharUnits quantity from a raw integer type.\n      static CharUnits fromQuantity(QuantityType Quantity) {\n        return CharUnits(Quantity);\n      }\n\n      // Compound assignment.\n      CharUnits& operator+= (const CharUnits &Other) {\n        Quantity += Other.Quantity;\n        return *this;\n      }\n      CharUnits& operator++ () {\n        ++Quantity;\n        return *this;\n      }\n      CharUnits operator++ (int) {\n        return CharUnits(Quantity++);\n      }\n      CharUnits& operator-= (const CharUnits &Other) {\n        Quantity -= Other.Quantity;\n        return *this;\n      }\n      CharUnits& operator-- () {\n        --Quantity;\n        return *this;\n      }\n      CharUnits operator-- (int) {\n        return CharUnits(Quantity--);\n      }\n\n      // Comparison operators.\n      bool operator== (const CharUnits &Other) const {\n        return Quantity == Other.Quantity;\n      }\n      bool operator!= (const CharUnits &Other) const {\n        return Quantity != Other.Quantity;\n      }\n\n      // Relational operators.\n      bool operator<  (const CharUnits &Other) const {\n        return Quantity <  Other.Quantity;\n      }\n      bool operator<= (const CharUnits &Other) const {\n        return Quantity <= Other.Quantity;\n      }\n      bool operator>  (const CharUnits &Other) const {\n        return Quantity >  Other.Quantity;\n      }\n      bool operator>= (const CharUnits &Other) const {\n        return Quantity >= Other.Quantity;\n      }\n\n      // Other predicates.\n\n      /// isZero - Test whether the quantity equals zero.\n      bool isZero() const     { return Quantity == 0; }\n\n      /// isOne - Test whether the quantity equals one.\n      bool isOne() const      { return Quantity == 1; }\n\n      /// isPositive - Test whether the quantity is greater than zero.\n      bool isPositive() const { return Quantity  > 0; }\n\n      /// isNegative - Test whether the quantity is less than zero.\n      bool isNegative() const { return Quantity  < 0; }\n\n      /// isPowerOfTwo - Test whether the quantity is a power of two.\n      /// Zero is not a power of two.\n      bool isPowerOfTwo() const {\n        return (Quantity & -Quantity) == Quantity;\n      }\n\n      /// Test whether this is a multiple of the other value.\n      ///\n      /// Among other things, this promises that\n      /// self.alignTo(N) will just return self.\n      bool isMultipleOf(CharUnits N) const {\n        return (*this % N) == 0;\n      }\n\n      // Arithmetic operators.\n      CharUnits operator* (QuantityType N) const {\n        return CharUnits(Quantity * N);\n      }\n      CharUnits &operator*= (QuantityType N) {\n        Quantity *= N;\n        return *this;\n      }\n      CharUnits operator/ (QuantityType N) const {\n        return CharUnits(Quantity / N);\n      }\n      CharUnits &operator/= (QuantityType N) {\n        Quantity /= N;\n        return *this;\n      }\n      QuantityType operator/ (const CharUnits &Other) const {\n        return Quantity / Other.Quantity;\n      }\n      CharUnits operator% (QuantityType N) const {\n        return CharUnits(Quantity % N);\n      }\n      QuantityType operator% (const CharUnits &Other) const {\n        return Quantity % Other.Quantity;\n      }\n      CharUnits operator+ (const CharUnits &Other) const {\n        return CharUnits(Quantity + Other.Quantity);\n      }\n      CharUnits operator- (const CharUnits &Other) const {\n        return CharUnits(Quantity - Other.Quantity);\n      }\n      CharUnits operator- () const {\n        return CharUnits(-Quantity);\n      }\n\n\n      // Conversions.\n\n      /// getQuantity - Get the raw integer representation of this quantity.\n      QuantityType getQuantity() const { return Quantity; }\n\n      /// getAsAlign - Returns Quantity as a valid llvm::Align,\n      /// Beware llvm::Align assumes power of two 8-bit bytes.\n      llvm::Align getAsAlign() const { return llvm::Align(Quantity); }\n\n      /// alignTo - Returns the next integer (mod 2**64) that is\n      /// greater than or equal to this quantity and is a multiple of \\p Align.\n      /// Align must be non-zero.\n      CharUnits alignTo(const CharUnits &Align) const {\n        return CharUnits(llvm::alignTo(Quantity, Align.Quantity));\n      }\n\n      /// Given that this is a non-zero alignment value, what is the\n      /// alignment at the given offset?\n      CharUnits alignmentAtOffset(CharUnits offset) const {\n        assert(Quantity != 0 && \"offsetting from unknown alignment?\");\n        return CharUnits(llvm::MinAlign(Quantity, offset.Quantity));\n      }\n\n      /// Given that this is the alignment of the first element of an\n      /// array, return the minimum alignment of any element in the array.\n      CharUnits alignmentOfArrayElement(CharUnits elementSize) const {\n        // Since we don't track offsetted alignments, the alignment of\n        // the second element (or any odd element) will be minimally\n        // aligned.\n        return alignmentAtOffset(elementSize);\n      }\n\n\n  }; // class CharUnit\n} // namespace clang\n\ninline clang::CharUnits operator* (clang::CharUnits::QuantityType Scale,\n                                   const clang::CharUnits &CU) {\n  return CU * Scale;\n}\n\nnamespace llvm {\n\ntemplate<> struct DenseMapInfo<clang::CharUnits> {\n  static clang::CharUnits getEmptyKey() {\n    clang::CharUnits::QuantityType Quantity =\n      DenseMapInfo<clang::CharUnits::QuantityType>::getEmptyKey();\n\n    return clang::CharUnits::fromQuantity(Quantity);\n  }\n\n  static clang::CharUnits getTombstoneKey() {\n    clang::CharUnits::QuantityType Quantity =\n      DenseMapInfo<clang::CharUnits::QuantityType>::getTombstoneKey();\n\n    return clang::CharUnits::fromQuantity(Quantity);\n  }\n\n  static unsigned getHashValue(const clang::CharUnits &CU) {\n    clang::CharUnits::QuantityType Quantity = CU.getQuantity();\n    return DenseMapInfo<clang::CharUnits::QuantityType>::getHashValue(Quantity);\n  }\n\n  static bool isEqual(const clang::CharUnits &LHS,\n                      const clang::CharUnits &RHS) {\n    return LHS == RHS;\n  }\n};\n\n} // end namespace llvm\n\n#endif // LLVM_CLANG_AST_CHARUNITS_H\n"}, "5": {"id": 5, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/DeclBase.h", "content": "//===- DeclBase.h - Base Classes for representing declarations --*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n//  This file defines the Decl and DeclContext interfaces.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_AST_DECLBASE_H\n#define LLVM_CLANG_AST_DECLBASE_H\n\n#include \"clang/AST/ASTDumperUtils.h\"\n#include \"clang/AST/AttrIterator.h\"\n#include \"clang/AST/DeclarationName.h\"\n#include \"clang/Basic/IdentifierTable.h\"\n#include \"clang/Basic/LLVM.h\"\n#include \"clang/Basic/SourceLocation.h\"\n#include \"clang/Basic/Specifiers.h\"\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/ADT/PointerIntPair.h\"\n#include \"llvm/ADT/PointerUnion.h\"\n#include \"llvm/ADT/iterator.h\"\n#include \"llvm/ADT/iterator_range.h\"\n#include \"llvm/Support/Casting.h\"\n#include \"llvm/Support/Compiler.h\"\n#include \"llvm/Support/PrettyStackTrace.h\"\n#include \"llvm/Support/VersionTuple.h\"\n#include <algorithm>\n#include <cassert>\n#include <cstddef>\n#include <iterator>\n#include <string>\n#include <type_traits>\n#include <utility>\n\nnamespace clang {\n\nclass ASTContext;\nclass ASTMutationListener;\nclass Attr;\nclass BlockDecl;\nclass DeclContext;\nclass ExternalSourceSymbolAttr;\nclass FunctionDecl;\nclass FunctionType;\nclass IdentifierInfo;\nenum Linkage : unsigned char;\nclass LinkageSpecDecl;\nclass Module;\nclass NamedDecl;\nclass ObjCCategoryDecl;\nclass ObjCCategoryImplDecl;\nclass ObjCContainerDecl;\nclass ObjCImplDecl;\nclass ObjCImplementationDecl;\nclass ObjCInterfaceDecl;\nclass ObjCMethodDecl;\nclass ObjCProtocolDecl;\nstruct PrintingPolicy;\nclass RecordDecl;\nclass SourceManager;\nclass Stmt;\nclass StoredDeclsMap;\nclass TemplateDecl;\nclass TemplateParameterList;\nclass TranslationUnitDecl;\nclass UsingDirectiveDecl;\n\n/// Captures the result of checking the availability of a\n/// declaration.\nenum AvailabilityResult {\n  AR_Available = 0,\n  AR_NotYetIntroduced,\n  AR_Deprecated,\n  AR_Unavailable\n};\n\n/// Decl - This represents one declaration (or definition), e.g. a variable,\n/// typedef, function, struct, etc.\n///\n/// Note: There are objects tacked on before the *beginning* of Decl\n/// (and its subclasses) in its Decl::operator new(). Proper alignment\n/// of all subclasses (not requiring more than the alignment of Decl) is\n/// asserted in DeclBase.cpp.\nclass alignas(8) Decl {\npublic:\n  /// Lists the kind of concrete classes of Decl.\n  enum Kind {\n#define DECL(DERIVED, BASE) DERIVED,\n#define ABSTRACT_DECL(DECL)\n#define DECL_RANGE(BASE, START, END) \\\n        first##BASE = START, last##BASE = END,\n#define LAST_DECL_RANGE(BASE, START, END) \\\n        first##BASE = START, last##BASE = END\n#include \"clang/AST/DeclNodes.inc\"\n  };\n\n  /// A placeholder type used to construct an empty shell of a\n  /// decl-derived type that will be filled in later (e.g., by some\n  /// deserialization method).\n  struct EmptyShell {};\n\n  /// IdentifierNamespace - The different namespaces in which\n  /// declarations may appear.  According to C99 6.2.3, there are\n  /// four namespaces, labels, tags, members and ordinary\n  /// identifiers.  C++ describes lookup completely differently:\n  /// certain lookups merely \"ignore\" certain kinds of declarations,\n  /// usually based on whether the declaration is of a type, etc.\n  ///\n  /// These are meant as bitmasks, so that searches in\n  /// C++ can look into the \"tag\" namespace during ordinary lookup.\n  ///\n  /// Decl currently provides 15 bits of IDNS bits.\n  enum IdentifierNamespace {\n    /// Labels, declared with 'x:' and referenced with 'goto x'.\n    IDNS_Label               = 0x0001,\n\n    /// Tags, declared with 'struct foo;' and referenced with\n    /// 'struct foo'.  All tags are also types.  This is what\n    /// elaborated-type-specifiers look for in C.\n    /// This also contains names that conflict with tags in the\n    /// same scope but that are otherwise ordinary names (non-type\n    /// template parameters and indirect field declarations).\n    IDNS_Tag                 = 0x0002,\n\n    /// Types, declared with 'struct foo', typedefs, etc.\n    /// This is what elaborated-type-specifiers look for in C++,\n    /// but note that it's ill-formed to find a non-tag.\n    IDNS_Type                = 0x0004,\n\n    /// Members, declared with object declarations within tag\n    /// definitions.  In C, these can only be found by \"qualified\"\n    /// lookup in member expressions.  In C++, they're found by\n    /// normal lookup.\n    IDNS_Member              = 0x0008,\n\n    /// Namespaces, declared with 'namespace foo {}'.\n    /// Lookup for nested-name-specifiers find these.\n    IDNS_Namespace           = 0x0010,\n\n    /// Ordinary names.  In C, everything that's not a label, tag,\n    /// member, or function-local extern ends up here.\n    IDNS_Ordinary            = 0x0020,\n\n    /// Objective C \\@protocol.\n    IDNS_ObjCProtocol        = 0x0040,\n\n    /// This declaration is a friend function.  A friend function\n    /// declaration is always in this namespace but may also be in\n    /// IDNS_Ordinary if it was previously declared.\n    IDNS_OrdinaryFriend      = 0x0080,\n\n    /// This declaration is a friend class.  A friend class\n    /// declaration is always in this namespace but may also be in\n    /// IDNS_Tag|IDNS_Type if it was previously declared.\n    IDNS_TagFriend           = 0x0100,\n\n    /// This declaration is a using declaration.  A using declaration\n    /// *introduces* a number of other declarations into the current\n    /// scope, and those declarations use the IDNS of their targets,\n    /// but the actual using declarations go in this namespace.\n    IDNS_Using               = 0x0200,\n\n    /// This declaration is a C++ operator declared in a non-class\n    /// context.  All such operators are also in IDNS_Ordinary.\n    /// C++ lexical operator lookup looks for these.\n    IDNS_NonMemberOperator   = 0x0400,\n\n    /// This declaration is a function-local extern declaration of a\n    /// variable or function. This may also be IDNS_Ordinary if it\n    /// has been declared outside any function. These act mostly like\n    /// invisible friend declarations, but are also visible to unqualified\n    /// lookup within the scope of the declaring function.\n    IDNS_LocalExtern         = 0x0800,\n\n    /// This declaration is an OpenMP user defined reduction construction.\n    IDNS_OMPReduction        = 0x1000,\n\n    /// This declaration is an OpenMP user defined mapper.\n    IDNS_OMPMapper           = 0x2000,\n  };\n\n  /// ObjCDeclQualifier - 'Qualifiers' written next to the return and\n  /// parameter types in method declarations.  Other than remembering\n  /// them and mangling them into the method's signature string, these\n  /// are ignored by the compiler; they are consumed by certain\n  /// remote-messaging frameworks.\n  ///\n  /// in, inout, and out are mutually exclusive and apply only to\n  /// method parameters.  bycopy and byref are mutually exclusive and\n  /// apply only to method parameters (?).  oneway applies only to\n  /// results.  All of these expect their corresponding parameter to\n  /// have a particular type.  None of this is currently enforced by\n  /// clang.\n  ///\n  /// This should be kept in sync with ObjCDeclSpec::ObjCDeclQualifier.\n  enum ObjCDeclQualifier {\n    OBJC_TQ_None = 0x0,\n    OBJC_TQ_In = 0x1,\n    OBJC_TQ_Inout = 0x2,\n    OBJC_TQ_Out = 0x4,\n    OBJC_TQ_Bycopy = 0x8,\n    OBJC_TQ_Byref = 0x10,\n    OBJC_TQ_Oneway = 0x20,\n\n    /// The nullability qualifier is set when the nullability of the\n    /// result or parameter was expressed via a context-sensitive\n    /// keyword.\n    OBJC_TQ_CSNullability = 0x40\n  };\n\n  /// The kind of ownership a declaration has, for visibility purposes.\n  /// This enumeration is designed such that higher values represent higher\n  /// levels of name hiding.\n  enum class ModuleOwnershipKind : unsigned {\n    /// This declaration is not owned by a module.\n    Unowned,\n\n    /// This declaration has an owning module, but is globally visible\n    /// (typically because its owning module is visible and we know that\n    /// modules cannot later become hidden in this compilation).\n    /// After serialization and deserialization, this will be converted\n    /// to VisibleWhenImported.\n    Visible,\n\n    /// This declaration has an owning module, and is visible when that\n    /// module is imported.\n    VisibleWhenImported,\n\n    /// This declaration has an owning module, but is only visible to\n    /// lookups that occur within that module.\n    ModulePrivate\n  };\n\nprotected:\n  /// The next declaration within the same lexical\n  /// DeclContext. These pointers form the linked list that is\n  /// traversed via DeclContext's decls_begin()/decls_end().\n  ///\n  /// The extra two bits are used for the ModuleOwnershipKind.\n  llvm::PointerIntPair<Decl *, 2, ModuleOwnershipKind> NextInContextAndBits;\n\nprivate:\n  friend class DeclContext;\n\n  struct MultipleDC {\n    DeclContext *SemanticDC;\n    DeclContext *LexicalDC;\n  };\n\n  /// DeclCtx - Holds either a DeclContext* or a MultipleDC*.\n  /// For declarations that don't contain C++ scope specifiers, it contains\n  /// the DeclContext where the Decl was declared.\n  /// For declarations with C++ scope specifiers, it contains a MultipleDC*\n  /// with the context where it semantically belongs (SemanticDC) and the\n  /// context where it was lexically declared (LexicalDC).\n  /// e.g.:\n  ///\n  ///   namespace A {\n  ///      void f(); // SemanticDC == LexicalDC == 'namespace A'\n  ///   }\n  ///   void A::f(); // SemanticDC == namespace 'A'\n  ///                // LexicalDC == global namespace\n  llvm::PointerUnion<DeclContext*, MultipleDC*> DeclCtx;\n\n  bool isInSemaDC() const { return DeclCtx.is<DeclContext*>(); }\n  bool isOutOfSemaDC() const { return DeclCtx.is<MultipleDC*>(); }\n\n  MultipleDC *getMultipleDC() const {\n    return DeclCtx.get<MultipleDC*>();\n  }\n\n  DeclContext *getSemanticDC() const {\n    return DeclCtx.get<DeclContext*>();\n  }\n\n  /// Loc - The location of this decl.\n  SourceLocation Loc;\n\n  /// DeclKind - This indicates which class this is.\n  unsigned DeclKind : 7;\n\n  /// InvalidDecl - This indicates a semantic error occurred.\n  unsigned InvalidDecl :  1;\n\n  /// HasAttrs - This indicates whether the decl has attributes or not.\n  unsigned HasAttrs : 1;\n\n  /// Implicit - Whether this declaration was implicitly generated by\n  /// the implementation rather than explicitly written by the user.\n  unsigned Implicit : 1;\n\n  /// Whether this declaration was \"used\", meaning that a definition is\n  /// required.\n  unsigned Used : 1;\n\n  /// Whether this declaration was \"referenced\".\n  /// The difference with 'Used' is whether the reference appears in a\n  /// evaluated context or not, e.g. functions used in uninstantiated templates\n  /// are regarded as \"referenced\" but not \"used\".\n  unsigned Referenced : 1;\n\n  /// Whether this declaration is a top-level declaration (function,\n  /// global variable, etc.) that is lexically inside an objc container\n  /// definition.\n  unsigned TopLevelDeclInObjCContainer : 1;\n\n  /// Whether statistic collection is enabled.\n  static bool StatisticsEnabled;\n\nprotected:\n  friend class ASTDeclReader;\n  friend class ASTDeclWriter;\n  friend class ASTNodeImporter;\n  friend class ASTReader;\n  friend class CXXClassMemberWrapper;\n  friend class LinkageComputer;\n  template<typename decl_type> friend class Redeclarable;\n\n  /// Access - Used by C++ decls for the access specifier.\n  // NOTE: VC++ treats enums as signed, avoid using the AccessSpecifier enum\n  unsigned Access : 2;\n\n  /// Whether this declaration was loaded from an AST file.\n  unsigned FromASTFile : 1;\n\n  /// IdentifierNamespace - This specifies what IDNS_* namespace this lives in.\n  unsigned IdentifierNamespace : 14;\n\n  /// If 0, we have not computed the linkage of this declaration.\n  /// Otherwise, it is the linkage + 1.\n  mutable unsigned CacheValidAndLinkage : 3;\n\n  /// Allocate memory for a deserialized declaration.\n  ///\n  /// This routine must be used to allocate memory for any declaration that is\n  /// deserialized from a module file.\n  ///\n  /// \\param Size The size of the allocated object.\n  /// \\param Ctx The context in which we will allocate memory.\n  /// \\param ID The global ID of the deserialized declaration.\n  /// \\param Extra The amount of extra space to allocate after the object.\n  void *operator new(std::size_t Size, const ASTContext &Ctx, unsigned ID,\n                     std::size_t Extra = 0);\n\n  /// Allocate memory for a non-deserialized declaration.\n  void *operator new(std::size_t Size, const ASTContext &Ctx,\n                     DeclContext *Parent, std::size_t Extra = 0);\n\nprivate:\n  bool AccessDeclContextSanity() const;\n\n  /// Get the module ownership kind to use for a local lexical child of \\p DC,\n  /// which may be either a local or (rarely) an imported declaration.\n  static ModuleOwnershipKind getModuleOwnershipKindForChildOf(DeclContext *DC) {\n    if (DC) {\n      auto *D = cast<Decl>(DC);\n      auto MOK = D->getModuleOwnershipKind();\n      if (MOK != ModuleOwnershipKind::Unowned &&\n          (!D->isFromASTFile() || D->hasLocalOwningModuleStorage()))\n        return MOK;\n      // If D is not local and we have no local module storage, then we don't\n      // need to track module ownership at all.\n    }\n    return ModuleOwnershipKind::Unowned;\n  }\n\npublic:\n  Decl() = delete;\n  Decl(const Decl&) = delete;\n  Decl(Decl &&) = delete;\n  Decl &operator=(const Decl&) = delete;\n  Decl &operator=(Decl&&) = delete;\n\nprotected:\n  Decl(Kind DK, DeclContext *DC, SourceLocation L)\n      : NextInContextAndBits(nullptr, getModuleOwnershipKindForChildOf(DC)),\n        DeclCtx(DC), Loc(L), DeclKind(DK), InvalidDecl(false), HasAttrs(false),\n        Implicit(false), Used(false), Referenced(false),\n        TopLevelDeclInObjCContainer(false), Access(AS_none), FromASTFile(0),\n        IdentifierNamespace(getIdentifierNamespaceForKind(DK)),\n        CacheValidAndLinkage(0) {\n    if (StatisticsEnabled) add(DK);\n  }\n\n  Decl(Kind DK, EmptyShell Empty)\n      : DeclKind(DK), InvalidDecl(false), HasAttrs(false), Implicit(false),\n        Used(false), Referenced(false), TopLevelDeclInObjCContainer(false),\n        Access(AS_none), FromASTFile(0),\n        IdentifierNamespace(getIdentifierNamespaceForKind(DK)),\n        CacheValidAndLinkage(0) {\n    if (StatisticsEnabled) add(DK);\n  }\n\n  virtual ~Decl();\n\n  /// Update a potentially out-of-date declaration.\n  void updateOutOfDate(IdentifierInfo &II) const;\n\n  Linkage getCachedLinkage() const {\n    return Linkage(CacheValidAndLinkage - 1);\n  }\n\n  void setCachedLinkage(Linkage L) const {\n    CacheValidAndLinkage = L + 1;\n  }\n\n  bool hasCachedLinkage() const {\n    return CacheValidAndLinkage;\n  }\n\npublic:\n  /// Source range that this declaration covers.\n  virtual SourceRange getSourceRange() const LLVM_READONLY {\n    return SourceRange(getLocation(), getLocation());\n  }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY {\n    return getSourceRange().getBegin();\n  }\n\n  SourceLocation getEndLoc() const LLVM_READONLY {\n    return getSourceRange().getEnd();\n  }\n\n  SourceLocation getLocation() const { return Loc; }\n  void setLocation(SourceLocation L) { Loc = L; }\n\n  Kind getKind() const { return static_cast<Kind>(DeclKind); }\n  const char *getDeclKindName() const;\n\n  Decl *getNextDeclInContext() { return NextInContextAndBits.getPointer(); }\n  const Decl *getNextDeclInContext() const {return NextInContextAndBits.getPointer();}\n\n  DeclContext *getDeclContext() {\n    if (isInSemaDC())\n      return getSemanticDC();\n    return getMultipleDC()->SemanticDC;\n  }\n  const DeclContext *getDeclContext() const {\n    return const_cast<Decl*>(this)->getDeclContext();\n  }\n\n  /// Find the innermost non-closure ancestor of this declaration,\n  /// walking up through blocks, lambdas, etc.  If that ancestor is\n  /// not a code context (!isFunctionOrMethod()), returns null.\n  ///\n  /// A declaration may be its own non-closure context.\n  Decl *getNonClosureContext();\n  const Decl *getNonClosureContext() const {\n    return const_cast<Decl*>(this)->getNonClosureContext();\n  }\n\n  TranslationUnitDecl *getTranslationUnitDecl();\n  const TranslationUnitDecl *getTranslationUnitDecl() const {\n    return const_cast<Decl*>(this)->getTranslationUnitDecl();\n  }\n\n  bool isInAnonymousNamespace() const;\n\n  bool isInStdNamespace() const;\n\n  ASTContext &getASTContext() const LLVM_READONLY;\n\n  /// Helper to get the language options from the ASTContext.\n  /// Defined out of line to avoid depending on ASTContext.h.\n  const LangOptions &getLangOpts() const LLVM_READONLY;\n\n  void setAccess(AccessSpecifier AS) {\n    Access = AS;\n    assert(AccessDeclContextSanity());\n  }\n\n  AccessSpecifier getAccess() const {\n    assert(AccessDeclContextSanity());\n    return AccessSpecifier(Access);\n  }\n\n  /// Retrieve the access specifier for this declaration, even though\n  /// it may not yet have been properly set.\n  AccessSpecifier getAccessUnsafe() const {\n    return AccessSpecifier(Access);\n  }\n\n  bool hasAttrs() const { return HasAttrs; }\n\n  void setAttrs(const AttrVec& Attrs) {\n    return setAttrsImpl(Attrs, getASTContext());\n  }\n\n  AttrVec &getAttrs() {\n    return const_cast<AttrVec&>(const_cast<const Decl*>(this)->getAttrs());\n  }\n\n  const AttrVec &getAttrs() const;\n  void dropAttrs();\n  void addAttr(Attr *A);\n\n  using attr_iterator = AttrVec::const_iterator;\n  using attr_range = llvm::iterator_range<attr_iterator>;\n\n  attr_range attrs() const {\n    return attr_range(attr_begin(), attr_end());\n  }\n\n  attr_iterator attr_begin() const {\n    return hasAttrs() ? getAttrs().begin() : nullptr;\n  }\n  attr_iterator attr_end() const {\n    return hasAttrs() ? getAttrs().end() : nullptr;\n  }\n\n  template <typename T>\n  void dropAttr() {\n    if (!HasAttrs) return;\n\n    AttrVec &Vec = getAttrs();\n    llvm::erase_if(Vec, [](Attr *A) { return isa<T>(A); });\n\n    if (Vec.empty())\n      HasAttrs = false;\n  }\n\n  template <typename T>\n  llvm::iterator_range<specific_attr_iterator<T>> specific_attrs() const {\n    return llvm::make_range(specific_attr_begin<T>(), specific_attr_end<T>());\n  }\n\n  template <typename T>\n  specific_attr_iterator<T> specific_attr_begin() const {\n    return specific_attr_iterator<T>(attr_begin());\n  }\n\n  template <typename T>\n  specific_attr_iterator<T> specific_attr_end() const {\n    return specific_attr_iterator<T>(attr_end());\n  }\n\n  template<typename T> T *getAttr() const {\n    return hasAttrs() ? getSpecificAttr<T>(getAttrs()) : nullptr;\n  }\n\n  template<typename T> bool hasAttr() const {\n    return hasAttrs() && hasSpecificAttr<T>(getAttrs());\n  }\n\n  /// getMaxAlignment - return the maximum alignment specified by attributes\n  /// on this decl, 0 if there are none.\n  unsigned getMaxAlignment() const;\n\n  /// setInvalidDecl - Indicates the Decl had a semantic error. This\n  /// allows for graceful error recovery.\n  void setInvalidDecl(bool Invalid = true);\n  bool isInvalidDecl() const { return (bool) InvalidDecl; }\n\n  /// isImplicit - Indicates whether the declaration was implicitly\n  /// generated by the implementation. If false, this declaration\n  /// was written explicitly in the source code.\n  bool isImplicit() const { return Implicit; }\n  void setImplicit(bool I = true) { Implicit = I; }\n\n  /// Whether *any* (re-)declaration of the entity was used, meaning that\n  /// a definition is required.\n  ///\n  /// \\param CheckUsedAttr When true, also consider the \"used\" attribute\n  /// (in addition to the \"used\" bit set by \\c setUsed()) when determining\n  /// whether the function is used.\n  bool isUsed(bool CheckUsedAttr = true) const;\n\n  /// Set whether the declaration is used, in the sense of odr-use.\n  ///\n  /// This should only be used immediately after creating a declaration.\n  /// It intentionally doesn't notify any listeners.\n  void setIsUsed() { getCanonicalDecl()->Used = true; }\n\n  /// Mark the declaration used, in the sense of odr-use.\n  ///\n  /// This notifies any mutation listeners in addition to setting a bit\n  /// indicating the declaration is used.\n  void markUsed(ASTContext &C);\n\n  /// Whether any declaration of this entity was referenced.\n  bool isReferenced() const;\n\n  /// Whether this declaration was referenced. This should not be relied\n  /// upon for anything other than debugging.\n  bool isThisDeclarationReferenced() const { return Referenced; }\n\n  void setReferenced(bool R = true) { Referenced = R; }\n\n  /// Whether this declaration is a top-level declaration (function,\n  /// global variable, etc.) that is lexically inside an objc container\n  /// definition.\n  bool isTopLevelDeclInObjCContainer() const {\n    return TopLevelDeclInObjCContainer;\n  }\n\n  void setTopLevelDeclInObjCContainer(bool V = true) {\n    TopLevelDeclInObjCContainer = V;\n  }\n\n  /// Looks on this and related declarations for an applicable\n  /// external source symbol attribute.\n  ExternalSourceSymbolAttr *getExternalSourceSymbolAttr() const;\n\n  /// Whether this declaration was marked as being private to the\n  /// module in which it was defined.\n  bool isModulePrivate() const {\n    return getModuleOwnershipKind() == ModuleOwnershipKind::ModulePrivate;\n  }\n\n  /// Return true if this declaration has an attribute which acts as\n  /// definition of the entity, such as 'alias' or 'ifunc'.\n  bool hasDefiningAttr() const;\n\n  /// Return this declaration's defining attribute if it has one.\n  const Attr *getDefiningAttr() const;\n\nprotected:\n  /// Specify that this declaration was marked as being private\n  /// to the module in which it was defined.\n  void setModulePrivate() {\n    // The module-private specifier has no effect on unowned declarations.\n    // FIXME: We should track this in some way for source fidelity.\n    if (getModuleOwnershipKind() == ModuleOwnershipKind::Unowned)\n      return;\n    setModuleOwnershipKind(ModuleOwnershipKind::ModulePrivate);\n  }\n\npublic:\n  /// Set the FromASTFile flag. This indicates that this declaration\n  /// was deserialized and not parsed from source code and enables\n  /// features such as module ownership information.\n  void setFromASTFile() {\n    FromASTFile = true;\n  }\n\n  /// Set the owning module ID.  This may only be called for\n  /// deserialized Decls.\n  void setOwningModuleID(unsigned ID) {\n    assert(isFromASTFile() && \"Only works on a deserialized declaration\");\n    *((unsigned*)this - 2) = ID;\n  }\n\npublic:\n  /// Determine the availability of the given declaration.\n  ///\n  /// This routine will determine the most restrictive availability of\n  /// the given declaration (e.g., preferring 'unavailable' to\n  /// 'deprecated').\n  ///\n  /// \\param Message If non-NULL and the result is not \\c\n  /// AR_Available, will be set to a (possibly empty) message\n  /// describing why the declaration has not been introduced, is\n  /// deprecated, or is unavailable.\n  ///\n  /// \\param EnclosingVersion The version to compare with. If empty, assume the\n  /// deployment target version.\n  ///\n  /// \\param RealizedPlatform If non-NULL and the availability result is found\n  /// in an available attribute it will set to the platform which is written in\n  /// the available attribute.\n  AvailabilityResult\n  getAvailability(std::string *Message = nullptr,\n                  VersionTuple EnclosingVersion = VersionTuple(),\n                  StringRef *RealizedPlatform = nullptr) const;\n\n  /// Retrieve the version of the target platform in which this\n  /// declaration was introduced.\n  ///\n  /// \\returns An empty version tuple if this declaration has no 'introduced'\n  /// availability attributes, or the version tuple that's specified in the\n  /// attribute otherwise.\n  VersionTuple getVersionIntroduced() const;\n\n  /// Determine whether this declaration is marked 'deprecated'.\n  ///\n  /// \\param Message If non-NULL and the declaration is deprecated,\n  /// this will be set to the message describing why the declaration\n  /// was deprecated (which may be empty).\n  bool isDeprecated(std::string *Message = nullptr) const {\n    return getAvailability(Message) == AR_Deprecated;\n  }\n\n  /// Determine whether this declaration is marked 'unavailable'.\n  ///\n  /// \\param Message If non-NULL and the declaration is unavailable,\n  /// this will be set to the message describing why the declaration\n  /// was made unavailable (which may be empty).\n  bool isUnavailable(std::string *Message = nullptr) const {\n    return getAvailability(Message) == AR_Unavailable;\n  }\n\n  /// Determine whether this is a weak-imported symbol.\n  ///\n  /// Weak-imported symbols are typically marked with the\n  /// 'weak_import' attribute, but may also be marked with an\n  /// 'availability' attribute where we're targing a platform prior to\n  /// the introduction of this feature.\n  bool isWeakImported() const;\n\n  /// Determines whether this symbol can be weak-imported,\n  /// e.g., whether it would be well-formed to add the weak_import\n  /// attribute.\n  ///\n  /// \\param IsDefinition Set to \\c true to indicate that this\n  /// declaration cannot be weak-imported because it has a definition.\n  bool canBeWeakImported(bool &IsDefinition) const;\n\n  /// Determine whether this declaration came from an AST file (such as\n  /// a precompiled header or module) rather than having been parsed.\n  bool isFromASTFile() const { return FromASTFile; }\n\n  /// Retrieve the global declaration ID associated with this\n  /// declaration, which specifies where this Decl was loaded from.\n  unsigned getGlobalID() const {\n    if (isFromASTFile())\n      return *((const unsigned*)this - 1);\n    return 0;\n  }\n\n  /// Retrieve the global ID of the module that owns this particular\n  /// declaration.\n  unsigned getOwningModuleID() const {\n    if (isFromASTFile())\n      return *((const unsigned*)this - 2);\n    return 0;\n  }\n\nprivate:\n  Module *getOwningModuleSlow() const;\n\nprotected:\n  bool hasLocalOwningModuleStorage() const;\n\npublic:\n  /// Get the imported owning module, if this decl is from an imported\n  /// (non-local) module.\n  Module *getImportedOwningModule() const {\n    if (!isFromASTFile() || !hasOwningModule())\n      return nullptr;\n\n    return getOwningModuleSlow();\n  }\n\n  /// Get the local owning module, if known. Returns nullptr if owner is\n  /// not yet known or declaration is not from a module.\n  Module *getLocalOwningModule() const {\n    if (isFromASTFile() || !hasOwningModule())\n      return nullptr;\n\n    assert(hasLocalOwningModuleStorage() &&\n           \"owned local decl but no local module storage\");\n    return reinterpret_cast<Module *const *>(this)[-1];\n  }\n  void setLocalOwningModule(Module *M) {\n    assert(!isFromASTFile() && hasOwningModule() &&\n           hasLocalOwningModuleStorage() &&\n           \"should not have a cached owning module\");\n    reinterpret_cast<Module **>(this)[-1] = M;\n  }\n\n  /// Is this declaration owned by some module?\n  bool hasOwningModule() const {\n    return getModuleOwnershipKind() != ModuleOwnershipKind::Unowned;\n  }\n\n  /// Get the module that owns this declaration (for visibility purposes).\n  Module *getOwningModule() const {\n    return isFromASTFile() ? getImportedOwningModule() : getLocalOwningModule();\n  }\n\n  /// Get the module that owns this declaration for linkage purposes.\n  /// There only ever is such a module under the C++ Modules TS.\n  ///\n  /// \\param IgnoreLinkage Ignore the linkage of the entity; assume that\n  /// all declarations in a global module fragment are unowned.\n  Module *getOwningModuleForLinkage(bool IgnoreLinkage = false) const;\n\n  /// Determine whether this declaration is definitely visible to name lookup,\n  /// independent of whether the owning module is visible.\n  /// Note: The declaration may be visible even if this returns \\c false if the\n  /// owning module is visible within the query context. This is a low-level\n  /// helper function; most code should be calling Sema::isVisible() instead.\n  bool isUnconditionallyVisible() const {\n    return (int)getModuleOwnershipKind() <= (int)ModuleOwnershipKind::Visible;\n  }\n\n  /// Set that this declaration is globally visible, even if it came from a\n  /// module that is not visible.\n  void setVisibleDespiteOwningModule() {\n    if (!isUnconditionallyVisible())\n      setModuleOwnershipKind(ModuleOwnershipKind::Visible);\n  }\n\n  /// Get the kind of module ownership for this declaration.\n  ModuleOwnershipKind getModuleOwnershipKind() const {\n    return NextInContextAndBits.getInt();\n  }\n\n  /// Set whether this declaration is hidden from name lookup.\n  void setModuleOwnershipKind(ModuleOwnershipKind MOK) {\n    assert(!(getModuleOwnershipKind() == ModuleOwnershipKind::Unowned &&\n             MOK != ModuleOwnershipKind::Unowned && !isFromASTFile() &&\n             !hasLocalOwningModuleStorage()) &&\n           \"no storage available for owning module for this declaration\");\n    NextInContextAndBits.setInt(MOK);\n  }\n\n  unsigned getIdentifierNamespace() const {\n    return IdentifierNamespace;\n  }\n\n  bool isInIdentifierNamespace(unsigned NS) const {\n    return getIdentifierNamespace() & NS;\n  }\n\n  static unsigned getIdentifierNamespaceForKind(Kind DK);\n\n  bool hasTagIdentifierNamespace() const {\n    return isTagIdentifierNamespace(getIdentifierNamespace());\n  }\n\n  static bool isTagIdentifierNamespace(unsigned NS) {\n    // TagDecls have Tag and Type set and may also have TagFriend.\n    return (NS & ~IDNS_TagFriend) == (IDNS_Tag | IDNS_Type);\n  }\n\n  /// getLexicalDeclContext - The declaration context where this Decl was\n  /// lexically declared (LexicalDC). May be different from\n  /// getDeclContext() (SemanticDC).\n  /// e.g.:\n  ///\n  ///   namespace A {\n  ///      void f(); // SemanticDC == LexicalDC == 'namespace A'\n  ///   }\n  ///   void A::f(); // SemanticDC == namespace 'A'\n  ///                // LexicalDC == global namespace\n  DeclContext *getLexicalDeclContext() {\n    if (isInSemaDC())\n      return getSemanticDC();\n    return getMultipleDC()->LexicalDC;\n  }\n  const DeclContext *getLexicalDeclContext() const {\n    return const_cast<Decl*>(this)->getLexicalDeclContext();\n  }\n\n  /// Determine whether this declaration is declared out of line (outside its\n  /// semantic context).\n  virtual bool isOutOfLine() const;\n\n  /// setDeclContext - Set both the semantic and lexical DeclContext\n  /// to DC.\n  void setDeclContext(DeclContext *DC);\n\n  void setLexicalDeclContext(DeclContext *DC);\n\n  /// Determine whether this declaration is a templated entity (whether it is\n  // within the scope of a template parameter).\n  bool isTemplated() const;\n\n  /// Determine the number of levels of template parameter surrounding this\n  /// declaration.\n  unsigned getTemplateDepth() const;\n\n  /// isDefinedOutsideFunctionOrMethod - This predicate returns true if this\n  /// scoped decl is defined outside the current function or method.  This is\n  /// roughly global variables and functions, but also handles enums (which\n  /// could be defined inside or outside a function etc).\n  bool isDefinedOutsideFunctionOrMethod() const {\n    return getParentFunctionOrMethod() == nullptr;\n  }\n\n  /// Determine whether a substitution into this declaration would occur as\n  /// part of a substitution into a dependent local scope. Such a substitution\n  /// transitively substitutes into all constructs nested within this\n  /// declaration.\n  ///\n  /// This recognizes non-defining declarations as well as members of local\n  /// classes and lambdas:\n  /// \\code\n  ///     template<typename T> void foo() { void bar(); }\n  ///     template<typename T> void foo2() { class ABC { void bar(); }; }\n  ///     template<typename T> inline int x = [](){ return 0; }();\n  /// \\endcode\n  bool isInLocalScopeForInstantiation() const;\n\n  /// If this decl is defined inside a function/method/block it returns\n  /// the corresponding DeclContext, otherwise it returns null.\n  const DeclContext *getParentFunctionOrMethod() const;\n  DeclContext *getParentFunctionOrMethod() {\n    return const_cast<DeclContext*>(\n                    const_cast<const Decl*>(this)->getParentFunctionOrMethod());\n  }\n\n  /// Retrieves the \"canonical\" declaration of the given declaration.\n  virtual Decl *getCanonicalDecl() { return this; }\n  const Decl *getCanonicalDecl() const {\n    return const_cast<Decl*>(this)->getCanonicalDecl();\n  }\n\n  /// Whether this particular Decl is a canonical one.\n  bool isCanonicalDecl() const { return getCanonicalDecl() == this; }\n\nprotected:\n  /// Returns the next redeclaration or itself if this is the only decl.\n  ///\n  /// Decl subclasses that can be redeclared should override this method so that\n  /// Decl::redecl_iterator can iterate over them.\n  virtual Decl *getNextRedeclarationImpl() { return this; }\n\n  /// Implementation of getPreviousDecl(), to be overridden by any\n  /// subclass that has a redeclaration chain.\n  virtual Decl *getPreviousDeclImpl() { return nullptr; }\n\n  /// Implementation of getMostRecentDecl(), to be overridden by any\n  /// subclass that has a redeclaration chain.\n  virtual Decl *getMostRecentDeclImpl() { return this; }\n\npublic:\n  /// Iterates through all the redeclarations of the same decl.\n  class redecl_iterator {\n    /// Current - The current declaration.\n    Decl *Current = nullptr;\n    Decl *Starter;\n\n  public:\n    using value_type = Decl *;\n    using reference = const value_type &;\n    using pointer = const value_type *;\n    using iterator_category = std::forward_iterator_tag;\n    using difference_type = std::ptrdiff_t;\n\n    redecl_iterator() = default;\n    explicit redecl_iterator(Decl *C) : Current(C), Starter(C) {}\n\n    reference operator*() const { return Current; }\n    value_type operator->() const { return Current; }\n\n    redecl_iterator& operator++() {\n      assert(Current && \"Advancing while iterator has reached end\");\n      // Get either previous decl or latest decl.\n      Decl *Next = Current->getNextRedeclarationImpl();\n      assert(Next && \"Should return next redeclaration or itself, never null!\");\n      Current = (Next != Starter) ? Next : nullptr;\n      return *this;\n    }\n\n    redecl_iterator operator++(int) {\n      redecl_iterator tmp(*this);\n      ++(*this);\n      return tmp;\n    }\n\n    friend bool operator==(redecl_iterator x, redecl_iterator y) {\n      return x.Current == y.Current;\n    }\n\n    friend bool operator!=(redecl_iterator x, redecl_iterator y) {\n      return x.Current != y.Current;\n    }\n  };\n\n  using redecl_range = llvm::iterator_range<redecl_iterator>;\n\n  /// Returns an iterator range for all the redeclarations of the same\n  /// decl. It will iterate at least once (when this decl is the only one).\n  redecl_range redecls() const {\n    return redecl_range(redecls_begin(), redecls_end());\n  }\n\n  redecl_iterator redecls_begin() const {\n    return redecl_iterator(const_cast<Decl *>(this));\n  }\n\n  redecl_iterator redecls_end() const { return redecl_iterator(); }\n\n  /// Retrieve the previous declaration that declares the same entity\n  /// as this declaration, or NULL if there is no previous declaration.\n  Decl *getPreviousDecl() { return getPreviousDeclImpl(); }\n\n  /// Retrieve the previous declaration that declares the same entity\n  /// as this declaration, or NULL if there is no previous declaration.\n  const Decl *getPreviousDecl() const {\n    return const_cast<Decl *>(this)->getPreviousDeclImpl();\n  }\n\n  /// True if this is the first declaration in its redeclaration chain.\n  bool isFirstDecl() const {\n    return getPreviousDecl() == nullptr;\n  }\n\n  /// Retrieve the most recent declaration that declares the same entity\n  /// as this declaration (which may be this declaration).\n  Decl *getMostRecentDecl() { return getMostRecentDeclImpl(); }\n\n  /// Retrieve the most recent declaration that declares the same entity\n  /// as this declaration (which may be this declaration).\n  const Decl *getMostRecentDecl() const {\n    return const_cast<Decl *>(this)->getMostRecentDeclImpl();\n  }\n\n  /// getBody - If this Decl represents a declaration for a body of code,\n  ///  such as a function or method definition, this method returns the\n  ///  top-level Stmt* of that body.  Otherwise this method returns null.\n  virtual Stmt* getBody() const { return nullptr; }\n\n  /// Returns true if this \\c Decl represents a declaration for a body of\n  /// code, such as a function or method definition.\n  /// Note that \\c hasBody can also return true if any redeclaration of this\n  /// \\c Decl represents a declaration for a body of code.\n  virtual bool hasBody() const { return getBody() != nullptr; }\n\n  /// getBodyRBrace - Gets the right brace of the body, if a body exists.\n  /// This works whether the body is a CompoundStmt or a CXXTryStmt.\n  SourceLocation getBodyRBrace() const;\n\n  // global temp stats (until we have a per-module visitor)\n  static void add(Kind k);\n  static void EnableStatistics();\n  static void PrintStats();\n\n  /// isTemplateParameter - Determines whether this declaration is a\n  /// template parameter.\n  bool isTemplateParameter() const;\n\n  /// isTemplateParameter - Determines whether this declaration is a\n  /// template parameter pack.\n  bool isTemplateParameterPack() const;\n\n  /// Whether this declaration is a parameter pack.\n  bool isParameterPack() const;\n\n  /// returns true if this declaration is a template\n  bool isTemplateDecl() const;\n\n  /// Whether this declaration is a function or function template.\n  bool isFunctionOrFunctionTemplate() const {\n    return (DeclKind >= Decl::firstFunction &&\n            DeclKind <= Decl::lastFunction) ||\n           DeclKind == FunctionTemplate;\n  }\n\n  /// If this is a declaration that describes some template, this\n  /// method returns that template declaration.\n  ///\n  /// Note that this returns nullptr for partial specializations, because they\n  /// are not modeled as TemplateDecls. Use getDescribedTemplateParams to handle\n  /// those cases.\n  TemplateDecl *getDescribedTemplate() const;\n\n  /// If this is a declaration that describes some template or partial\n  /// specialization, this returns the corresponding template parameter list.\n  const TemplateParameterList *getDescribedTemplateParams() const;\n\n  /// Returns the function itself, or the templated function if this is a\n  /// function template.\n  FunctionDecl *getAsFunction() LLVM_READONLY;\n\n  const FunctionDecl *getAsFunction() const {\n    return const_cast<Decl *>(this)->getAsFunction();\n  }\n\n  /// Changes the namespace of this declaration to reflect that it's\n  /// a function-local extern declaration.\n  ///\n  /// These declarations appear in the lexical context of the extern\n  /// declaration, but in the semantic context of the enclosing namespace\n  /// scope.\n  void setLocalExternDecl() {\n    Decl *Prev = getPreviousDecl();\n    IdentifierNamespace &= ~IDNS_Ordinary;\n\n    // It's OK for the declaration to still have the \"invisible friend\" flag or\n    // the \"conflicts with tag declarations in this scope\" flag for the outer\n    // scope.\n    assert((IdentifierNamespace & ~(IDNS_OrdinaryFriend | IDNS_Tag)) == 0 &&\n           \"namespace is not ordinary\");\n\n    IdentifierNamespace |= IDNS_LocalExtern;\n    if (Prev && Prev->getIdentifierNamespace() & IDNS_Ordinary)\n      IdentifierNamespace |= IDNS_Ordinary;\n  }\n\n  /// Determine whether this is a block-scope declaration with linkage.\n  /// This will either be a local variable declaration declared 'extern', or a\n  /// local function declaration.\n  bool isLocalExternDecl() {\n    return IdentifierNamespace & IDNS_LocalExtern;\n  }\n\n  /// Changes the namespace of this declaration to reflect that it's\n  /// the object of a friend declaration.\n  ///\n  /// These declarations appear in the lexical context of the friending\n  /// class, but in the semantic context of the actual entity.  This property\n  /// applies only to a specific decl object;  other redeclarations of the\n  /// same entity may not (and probably don't) share this property.\n  void setObjectOfFriendDecl(bool PerformFriendInjection = false) {\n    unsigned OldNS = IdentifierNamespace;\n    assert((OldNS & (IDNS_Tag | IDNS_Ordinary |\n                     IDNS_TagFriend | IDNS_OrdinaryFriend |\n                     IDNS_LocalExtern | IDNS_NonMemberOperator)) &&\n           \"namespace includes neither ordinary nor tag\");\n    assert(!(OldNS & ~(IDNS_Tag | IDNS_Ordinary | IDNS_Type |\n                       IDNS_TagFriend | IDNS_OrdinaryFriend |\n                       IDNS_LocalExtern | IDNS_NonMemberOperator)) &&\n           \"namespace includes other than ordinary or tag\");\n\n    Decl *Prev = getPreviousDecl();\n    IdentifierNamespace &= ~(IDNS_Ordinary | IDNS_Tag | IDNS_Type);\n\n    if (OldNS & (IDNS_Tag | IDNS_TagFriend)) {\n      IdentifierNamespace |= IDNS_TagFriend;\n      if (PerformFriendInjection ||\n          (Prev && Prev->getIdentifierNamespace() & IDNS_Tag))\n        IdentifierNamespace |= IDNS_Tag | IDNS_Type;\n    }\n\n    if (OldNS & (IDNS_Ordinary | IDNS_OrdinaryFriend |\n                 IDNS_LocalExtern | IDNS_NonMemberOperator)) {\n      IdentifierNamespace |= IDNS_OrdinaryFriend;\n      if (PerformFriendInjection ||\n          (Prev && Prev->getIdentifierNamespace() & IDNS_Ordinary))\n        IdentifierNamespace |= IDNS_Ordinary;\n    }\n  }\n\n  enum FriendObjectKind {\n    FOK_None,      ///< Not a friend object.\n    FOK_Declared,  ///< A friend of a previously-declared entity.\n    FOK_Undeclared ///< A friend of a previously-undeclared entity.\n  };\n\n  /// Determines whether this declaration is the object of a\n  /// friend declaration and, if so, what kind.\n  ///\n  /// There is currently no direct way to find the associated FriendDecl.\n  FriendObjectKind getFriendObjectKind() const {\n    unsigned mask =\n        (IdentifierNamespace & (IDNS_TagFriend | IDNS_OrdinaryFriend));\n    if (!mask) return FOK_None;\n    return (IdentifierNamespace & (IDNS_Tag | IDNS_Ordinary) ? FOK_Declared\n                                                             : FOK_Undeclared);\n  }\n\n  /// Specifies that this declaration is a C++ overloaded non-member.\n  void setNonMemberOperator() {\n    assert(getKind() == Function || getKind() == FunctionTemplate);\n    assert((IdentifierNamespace & IDNS_Ordinary) &&\n           \"visible non-member operators should be in ordinary namespace\");\n    IdentifierNamespace |= IDNS_NonMemberOperator;\n  }\n\n  static bool classofKind(Kind K) { return true; }\n  static DeclContext *castToDeclContext(const Decl *);\n  static Decl *castFromDeclContext(const DeclContext *);\n\n  void print(raw_ostream &Out, unsigned Indentation = 0,\n             bool PrintInstantiation = false) const;\n  void print(raw_ostream &Out, const PrintingPolicy &Policy,\n             unsigned Indentation = 0, bool PrintInstantiation = false) const;\n  static void printGroup(Decl** Begin, unsigned NumDecls,\n                         raw_ostream &Out, const PrintingPolicy &Policy,\n                         unsigned Indentation = 0);\n\n  // Debuggers don't usually respect default arguments.\n  void dump() const;\n\n  // Same as dump(), but forces color printing.\n  void dumpColor() const;\n\n  void dump(raw_ostream &Out, bool Deserialize = false,\n            ASTDumpOutputFormat OutputFormat = ADOF_Default) const;\n\n  /// \\return Unique reproducible object identifier\n  int64_t getID() const;\n\n  /// Looks through the Decl's underlying type to extract a FunctionType\n  /// when possible. Will return null if the type underlying the Decl does not\n  /// have a FunctionType.\n  const FunctionType *getFunctionType(bool BlocksToo = true) const;\n\nprivate:\n  void setAttrsImpl(const AttrVec& Attrs, ASTContext &Ctx);\n  void setDeclContextsImpl(DeclContext *SemaDC, DeclContext *LexicalDC,\n                           ASTContext &Ctx);\n\nprotected:\n  ASTMutationListener *getASTMutationListener() const;\n};\n\n/// Determine whether two declarations declare the same entity.\ninline bool declaresSameEntity(const Decl *D1, const Decl *D2) {\n  if (!D1 || !D2)\n    return false;\n\n  if (D1 == D2)\n    return true;\n\n  return D1->getCanonicalDecl() == D2->getCanonicalDecl();\n}\n\n/// PrettyStackTraceDecl - If a crash occurs, indicate that it happened when\n/// doing something to a specific decl.\nclass PrettyStackTraceDecl : public llvm::PrettyStackTraceEntry {\n  const Decl *TheDecl;\n  SourceLocation Loc;\n  SourceManager &SM;\n  const char *Message;\n\npublic:\n  PrettyStackTraceDecl(const Decl *theDecl, SourceLocation L,\n                       SourceManager &sm, const char *Msg)\n      : TheDecl(theDecl), Loc(L), SM(sm), Message(Msg) {}\n\n  void print(raw_ostream &OS) const override;\n};\n} // namespace clang\n\n// Required to determine the layout of the PointerUnion<NamedDecl*> before\n// seeing the NamedDecl definition being first used in DeclListNode::operator*.\nnamespace llvm {\n  template <> struct PointerLikeTypeTraits<::clang::NamedDecl *> {\n    static inline void *getAsVoidPointer(::clang::NamedDecl *P) { return P; }\n    static inline ::clang::NamedDecl *getFromVoidPointer(void *P) {\n      return static_cast<::clang::NamedDecl *>(P);\n    }\n    static constexpr int NumLowBitsAvailable = 3;\n  };\n}\n\nnamespace clang {\n/// A list storing NamedDecls in the lookup tables.\nclass DeclListNode {\n  friend class ASTContext; // allocate, deallocate nodes.\n  friend class StoredDeclsList;\npublic:\n  using Decls = llvm::PointerUnion<NamedDecl*, DeclListNode*>;\n  class iterator {\n    friend class DeclContextLookupResult;\n    friend class StoredDeclsList;\n\n    Decls Ptr;\n    iterator(Decls Node) : Ptr(Node) { }\n  public:\n    using difference_type = ptrdiff_t;\n    using value_type = NamedDecl*;\n    using pointer = void;\n    using reference = value_type;\n    using iterator_category = std::forward_iterator_tag;\n\n    iterator() = default;\n\n    reference operator*() const {\n      assert(Ptr && \"dereferencing end() iterator\");\n      if (DeclListNode *CurNode = Ptr.dyn_cast<DeclListNode*>())\n        return CurNode->D;\n      return Ptr.get<NamedDecl*>();\n    }\n    void operator->() const { } // Unsupported.\n    bool operator==(const iterator &X) const { return Ptr == X.Ptr; }\n    bool operator!=(const iterator &X) const { return Ptr != X.Ptr; }\n    inline iterator &operator++() { // ++It\n      assert(!Ptr.isNull() && \"Advancing empty iterator\");\n\n      if (DeclListNode *CurNode = Ptr.dyn_cast<DeclListNode*>())\n        Ptr = CurNode->Rest;\n      else\n        Ptr = nullptr;\n      return *this;\n    }\n    iterator operator++(int) { // It++\n      iterator temp = *this;\n      ++(*this);\n      return temp;\n    }\n    // Enables the pattern for (iterator I =..., E = I.end(); I != E; ++I)\n    iterator end() { return iterator(); }\n  };\nprivate:\n  NamedDecl *D = nullptr;\n  Decls Rest = nullptr;\n  DeclListNode(NamedDecl *ND) : D(ND) {}\n};\n\n/// The results of name lookup within a DeclContext.\nclass DeclContextLookupResult {\n  using Decls = DeclListNode::Decls;\n\n  /// When in collection form, this is what the Data pointer points to.\n  Decls Result;\n\npublic:\n  DeclContextLookupResult() = default;\n  DeclContextLookupResult(Decls Result) : Result(Result) {}\n\n  using iterator = DeclListNode::iterator;\n  using const_iterator = iterator;\n  using reference = iterator::reference;\n\n  iterator begin() { return iterator(Result); }\n  iterator end() { return iterator(); }\n  const_iterator begin() const {\n    return const_cast<DeclContextLookupResult*>(this)->begin();\n  }\n  const_iterator end() const { return iterator(); }\n\n  bool empty() const { return Result.isNull();  }\n  bool isSingleResult() const { return Result.dyn_cast<NamedDecl*>(); }\n  reference front() const { return *begin(); }\n\n  // Find the first declaration of the given type in the list. Note that this\n  // is not in general the earliest-declared declaration, and should only be\n  // used when it's not possible for there to be more than one match or where\n  // it doesn't matter which one is found.\n  template<class T> T *find_first() const {\n    for (auto *D : *this)\n      if (T *Decl = dyn_cast<T>(D))\n        return Decl;\n\n    return nullptr;\n  }\n};\n\n/// DeclContext - This is used only as base class of specific decl types that\n/// can act as declaration contexts. These decls are (only the top classes\n/// that directly derive from DeclContext are mentioned, not their subclasses):\n///\n///   TranslationUnitDecl\n///   ExternCContext\n///   NamespaceDecl\n///   TagDecl\n///   OMPDeclareReductionDecl\n///   OMPDeclareMapperDecl\n///   FunctionDecl\n///   ObjCMethodDecl\n///   ObjCContainerDecl\n///   LinkageSpecDecl\n///   ExportDecl\n///   BlockDecl\n///   CapturedDecl\nclass DeclContext {\n  /// For makeDeclVisibleInContextImpl\n  friend class ASTDeclReader;\n  /// For reconcileExternalVisibleStorage, CreateStoredDeclsMap,\n  /// hasNeedToReconcileExternalVisibleStorage\n  friend class ExternalASTSource;\n  /// For CreateStoredDeclsMap\n  friend class DependentDiagnostic;\n  /// For hasNeedToReconcileExternalVisibleStorage,\n  /// hasLazyLocalLexicalLookups, hasLazyExternalLexicalLookups\n  friend class ASTWriter;\n\n  // We use uint64_t in the bit-fields below since some bit-fields\n  // cross the unsigned boundary and this breaks the packing.\n\n  /// Stores the bits used by DeclContext.\n  /// If modified NumDeclContextBit, the ctor of DeclContext and the accessor\n  /// methods in DeclContext should be updated appropriately.\n  class DeclContextBitfields {\n    friend class DeclContext;\n    /// DeclKind - This indicates which class this is.\n    uint64_t DeclKind : 7;\n\n    /// Whether this declaration context also has some external\n    /// storage that contains additional declarations that are lexically\n    /// part of this context.\n    mutable uint64_t ExternalLexicalStorage : 1;\n\n    /// Whether this declaration context also has some external\n    /// storage that contains additional declarations that are visible\n    /// in this context.\n    mutable uint64_t ExternalVisibleStorage : 1;\n\n    /// Whether this declaration context has had externally visible\n    /// storage added since the last lookup. In this case, \\c LookupPtr's\n    /// invariant may not hold and needs to be fixed before we perform\n    /// another lookup.\n    mutable uint64_t NeedToReconcileExternalVisibleStorage : 1;\n\n    /// If \\c true, this context may have local lexical declarations\n    /// that are missing from the lookup table.\n    mutable uint64_t HasLazyLocalLexicalLookups : 1;\n\n    /// If \\c true, the external source may have lexical declarations\n    /// that are missing from the lookup table.\n    mutable uint64_t HasLazyExternalLexicalLookups : 1;\n\n    /// If \\c true, lookups should only return identifier from\n    /// DeclContext scope (for example TranslationUnit). Used in\n    /// LookupQualifiedName()\n    mutable uint64_t UseQualifiedLookup : 1;\n  };\n\n  /// Number of bits in DeclContextBitfields.\n  enum { NumDeclContextBits = 13 };\n\n  /// Stores the bits used by TagDecl.\n  /// If modified NumTagDeclBits and the accessor\n  /// methods in TagDecl should be updated appropriately.\n  class TagDeclBitfields {\n    friend class TagDecl;\n    /// For the bits in DeclContextBitfields\n    uint64_t : NumDeclContextBits;\n\n    /// The TagKind enum.\n    uint64_t TagDeclKind : 3;\n\n    /// True if this is a definition (\"struct foo {};\"), false if it is a\n    /// declaration (\"struct foo;\").  It is not considered a definition\n    /// until the definition has been fully processed.\n    uint64_t IsCompleteDefinition : 1;\n\n    /// True if this is currently being defined.\n    uint64_t IsBeingDefined : 1;\n\n    /// True if this tag declaration is \"embedded\" (i.e., defined or declared\n    /// for the very first time) in the syntax of a declarator.\n    uint64_t IsEmbeddedInDeclarator : 1;\n\n    /// True if this tag is free standing, e.g. \"struct foo;\".\n    uint64_t IsFreeStanding : 1;\n\n    /// Indicates whether it is possible for declarations of this kind\n    /// to have an out-of-date definition.\n    ///\n    /// This option is only enabled when modules are enabled.\n    uint64_t MayHaveOutOfDateDef : 1;\n\n    /// Has the full definition of this type been required by a use somewhere in\n    /// the TU.\n    uint64_t IsCompleteDefinitionRequired : 1;\n  };\n\n  /// Number of non-inherited bits in TagDeclBitfields.\n  enum { NumTagDeclBits = 9 };\n\n  /// Stores the bits used by EnumDecl.\n  /// If modified NumEnumDeclBit and the accessor\n  /// methods in EnumDecl should be updated appropriately.\n  class EnumDeclBitfields {\n    friend class EnumDecl;\n    /// For the bits in DeclContextBitfields.\n    uint64_t : NumDeclContextBits;\n    /// For the bits in TagDeclBitfields.\n    uint64_t : NumTagDeclBits;\n\n    /// Width in bits required to store all the non-negative\n    /// enumerators of this enum.\n    uint64_t NumPositiveBits : 8;\n\n    /// Width in bits required to store all the negative\n    /// enumerators of this enum.\n    uint64_t NumNegativeBits : 8;\n\n    /// True if this tag declaration is a scoped enumeration. Only\n    /// possible in C++11 mode.\n    uint64_t IsScoped : 1;\n\n    /// If this tag declaration is a scoped enum,\n    /// then this is true if the scoped enum was declared using the class\n    /// tag, false if it was declared with the struct tag. No meaning is\n    /// associated if this tag declaration is not a scoped enum.\n    uint64_t IsScopedUsingClassTag : 1;\n\n    /// True if this is an enumeration with fixed underlying type. Only\n    /// possible in C++11, Microsoft extensions, or Objective C mode.\n    uint64_t IsFixed : 1;\n\n    /// True if a valid hash is stored in ODRHash.\n    uint64_t HasODRHash : 1;\n  };\n\n  /// Number of non-inherited bits in EnumDeclBitfields.\n  enum { NumEnumDeclBits = 20 };\n\n  /// Stores the bits used by RecordDecl.\n  /// If modified NumRecordDeclBits and the accessor\n  /// methods in RecordDecl should be updated appropriately.\n  class RecordDeclBitfields {\n    friend class RecordDecl;\n    /// For the bits in DeclContextBitfields.\n    uint64_t : NumDeclContextBits;\n    /// For the bits in TagDeclBitfields.\n    uint64_t : NumTagDeclBits;\n\n    /// This is true if this struct ends with a flexible\n    /// array member (e.g. int X[]) or if this union contains a struct that does.\n    /// If so, this cannot be contained in arrays or other structs as a member.\n    uint64_t HasFlexibleArrayMember : 1;\n\n    /// Whether this is the type of an anonymous struct or union.\n    uint64_t AnonymousStructOrUnion : 1;\n\n    /// This is true if this struct has at least one member\n    /// containing an Objective-C object pointer type.\n    uint64_t HasObjectMember : 1;\n\n    /// This is true if struct has at least one member of\n    /// 'volatile' type.\n    uint64_t HasVolatileMember : 1;\n\n    /// Whether the field declarations of this record have been loaded\n    /// from external storage. To avoid unnecessary deserialization of\n    /// methods/nested types we allow deserialization of just the fields\n    /// when needed.\n    mutable uint64_t LoadedFieldsFromExternalStorage : 1;\n\n    /// Basic properties of non-trivial C structs.\n    uint64_t NonTrivialToPrimitiveDefaultInitialize : 1;\n    uint64_t NonTrivialToPrimitiveCopy : 1;\n    uint64_t NonTrivialToPrimitiveDestroy : 1;\n\n    /// The following bits indicate whether this is or contains a C union that\n    /// is non-trivial to default-initialize, destruct, or copy. These bits\n    /// imply the associated basic non-triviality predicates declared above.\n    uint64_t HasNonTrivialToPrimitiveDefaultInitializeCUnion : 1;\n    uint64_t HasNonTrivialToPrimitiveDestructCUnion : 1;\n    uint64_t HasNonTrivialToPrimitiveCopyCUnion : 1;\n\n    /// Indicates whether this struct is destroyed in the callee.\n    uint64_t ParamDestroyedInCallee : 1;\n\n    /// Represents the way this type is passed to a function.\n    uint64_t ArgPassingRestrictions : 2;\n  };\n\n  /// Number of non-inherited bits in RecordDeclBitfields.\n  enum { NumRecordDeclBits = 14 };\n\n  /// Stores the bits used by OMPDeclareReductionDecl.\n  /// If modified NumOMPDeclareReductionDeclBits and the accessor\n  /// methods in OMPDeclareReductionDecl should be updated appropriately.\n  class OMPDeclareReductionDeclBitfields {\n    friend class OMPDeclareReductionDecl;\n    /// For the bits in DeclContextBitfields\n    uint64_t : NumDeclContextBits;\n\n    /// Kind of initializer,\n    /// function call or omp_priv<init_expr> initializtion.\n    uint64_t InitializerKind : 2;\n  };\n\n  /// Number of non-inherited bits in OMPDeclareReductionDeclBitfields.\n  enum { NumOMPDeclareReductionDeclBits = 2 };\n\n  /// Stores the bits used by FunctionDecl.\n  /// If modified NumFunctionDeclBits and the accessor\n  /// methods in FunctionDecl and CXXDeductionGuideDecl\n  /// (for IsCopyDeductionCandidate) should be updated appropriately.\n  class FunctionDeclBitfields {\n    friend class FunctionDecl;\n    /// For IsCopyDeductionCandidate\n    friend class CXXDeductionGuideDecl;\n    /// For the bits in DeclContextBitfields.\n    uint64_t : NumDeclContextBits;\n\n    uint64_t SClass : 3;\n    uint64_t IsInline : 1;\n    uint64_t IsInlineSpecified : 1;\n\n    uint64_t IsVirtualAsWritten : 1;\n    uint64_t IsPure : 1;\n    uint64_t HasInheritedPrototype : 1;\n    uint64_t HasWrittenPrototype : 1;\n    uint64_t IsDeleted : 1;\n    /// Used by CXXMethodDecl\n    uint64_t IsTrivial : 1;\n\n    /// This flag indicates whether this function is trivial for the purpose of\n    /// calls. This is meaningful only when this function is a copy/move\n    /// constructor or a destructor.\n    uint64_t IsTrivialForCall : 1;\n\n    uint64_t IsDefaulted : 1;\n    uint64_t IsExplicitlyDefaulted : 1;\n    uint64_t HasDefaultedFunctionInfo : 1;\n    uint64_t HasImplicitReturnZero : 1;\n    uint64_t IsLateTemplateParsed : 1;\n\n    /// Kind of contexpr specifier as defined by ConstexprSpecKind.\n    uint64_t ConstexprKind : 2;\n    uint64_t InstantiationIsPending : 1;\n\n    /// Indicates if the function uses __try.\n    uint64_t UsesSEHTry : 1;\n\n    /// Indicates if the function was a definition\n    /// but its body was skipped.\n    uint64_t HasSkippedBody : 1;\n\n    /// Indicates if the function declaration will\n    /// have a body, once we're done parsing it.\n    uint64_t WillHaveBody : 1;\n\n    /// Indicates that this function is a multiversioned\n    /// function using attribute 'target'.\n    uint64_t IsMultiVersion : 1;\n\n    /// [C++17] Only used by CXXDeductionGuideDecl. Indicates that\n    /// the Deduction Guide is the implicitly generated 'copy\n    /// deduction candidate' (is used during overload resolution).\n    uint64_t IsCopyDeductionCandidate : 1;\n\n    /// Store the ODRHash after first calculation.\n    uint64_t HasODRHash : 1;\n\n    /// Indicates if the function uses Floating Point Constrained Intrinsics\n    uint64_t UsesFPIntrin : 1;\n  };\n\n  /// Number of non-inherited bits in FunctionDeclBitfields.\n  enum { NumFunctionDeclBits = 27 };\n\n  /// Stores the bits used by CXXConstructorDecl. If modified\n  /// NumCXXConstructorDeclBits and the accessor\n  /// methods in CXXConstructorDecl should be updated appropriately.\n  class CXXConstructorDeclBitfields {\n    friend class CXXConstructorDecl;\n    /// For the bits in DeclContextBitfields.\n    uint64_t : NumDeclContextBits;\n    /// For the bits in FunctionDeclBitfields.\n    uint64_t : NumFunctionDeclBits;\n\n    /// 24 bits to fit in the remaining available space.\n    /// Note that this makes CXXConstructorDeclBitfields take\n    /// exactly 64 bits and thus the width of NumCtorInitializers\n    /// will need to be shrunk if some bit is added to NumDeclContextBitfields,\n    /// NumFunctionDeclBitfields or CXXConstructorDeclBitfields.\n    uint64_t NumCtorInitializers : 21;\n    uint64_t IsInheritingConstructor : 1;\n\n    /// Whether this constructor has a trail-allocated explicit specifier.\n    uint64_t HasTrailingExplicitSpecifier : 1;\n    /// If this constructor does't have a trail-allocated explicit specifier.\n    /// Whether this constructor is explicit specified.\n    uint64_t IsSimpleExplicit : 1;\n  };\n\n  /// Number of non-inherited bits in CXXConstructorDeclBitfields.\n  enum {\n    NumCXXConstructorDeclBits = 64 - NumDeclContextBits - NumFunctionDeclBits\n  };\n\n  /// Stores the bits used by ObjCMethodDecl.\n  /// If modified NumObjCMethodDeclBits and the accessor\n  /// methods in ObjCMethodDecl should be updated appropriately.\n  class ObjCMethodDeclBitfields {\n    friend class ObjCMethodDecl;\n\n    /// For the bits in DeclContextBitfields.\n    uint64_t : NumDeclContextBits;\n\n    /// The conventional meaning of this method; an ObjCMethodFamily.\n    /// This is not serialized; instead, it is computed on demand and\n    /// cached.\n    mutable uint64_t Family : ObjCMethodFamilyBitWidth;\n\n    /// instance (true) or class (false) method.\n    uint64_t IsInstance : 1;\n    uint64_t IsVariadic : 1;\n\n    /// True if this method is the getter or setter for an explicit property.\n    uint64_t IsPropertyAccessor : 1;\n\n    /// True if this method is a synthesized property accessor stub.\n    uint64_t IsSynthesizedAccessorStub : 1;\n\n    /// Method has a definition.\n    uint64_t IsDefined : 1;\n\n    /// Method redeclaration in the same interface.\n    uint64_t IsRedeclaration : 1;\n\n    /// Is redeclared in the same interface.\n    mutable uint64_t HasRedeclaration : 1;\n\n    /// \\@required/\\@optional\n    uint64_t DeclImplementation : 2;\n\n    /// in, inout, etc.\n    uint64_t objcDeclQualifier : 7;\n\n    /// Indicates whether this method has a related result type.\n    uint64_t RelatedResultType : 1;\n\n    /// Whether the locations of the selector identifiers are in a\n    /// \"standard\" position, a enum SelectorLocationsKind.\n    uint64_t SelLocsKind : 2;\n\n    /// Whether this method overrides any other in the class hierarchy.\n    ///\n    /// A method is said to override any method in the class's\n    /// base classes, its protocols, or its categories' protocols, that has\n    /// the same selector and is of the same kind (class or instance).\n    /// A method in an implementation is not considered as overriding the same\n    /// method in the interface or its categories.\n    uint64_t IsOverriding : 1;\n\n    /// Indicates if the method was a definition but its body was skipped.\n    uint64_t HasSkippedBody : 1;\n  };\n\n  /// Number of non-inherited bits in ObjCMethodDeclBitfields.\n  enum { NumObjCMethodDeclBits = 24 };\n\n  /// Stores the bits used by ObjCContainerDecl.\n  /// If modified NumObjCContainerDeclBits and the accessor\n  /// methods in ObjCContainerDecl should be updated appropriately.\n  class ObjCContainerDeclBitfields {\n    friend class ObjCContainerDecl;\n    /// For the bits in DeclContextBitfields\n    uint32_t : NumDeclContextBits;\n\n    // Not a bitfield but this saves space.\n    // Note that ObjCContainerDeclBitfields is full.\n    SourceLocation AtStart;\n  };\n\n  /// Number of non-inherited bits in ObjCContainerDeclBitfields.\n  /// Note that here we rely on the fact that SourceLocation is 32 bits\n  /// wide. We check this with the static_assert in the ctor of DeclContext.\n  enum { NumObjCContainerDeclBits = 64 - NumDeclContextBits };\n\n  /// Stores the bits used by LinkageSpecDecl.\n  /// If modified NumLinkageSpecDeclBits and the accessor\n  /// methods in LinkageSpecDecl should be updated appropriately.\n  class LinkageSpecDeclBitfields {\n    friend class LinkageSpecDecl;\n    /// For the bits in DeclContextBitfields.\n    uint64_t : NumDeclContextBits;\n\n    /// The language for this linkage specification with values\n    /// in the enum LinkageSpecDecl::LanguageIDs.\n    uint64_t Language : 3;\n\n    /// True if this linkage spec has braces.\n    /// This is needed so that hasBraces() returns the correct result while the\n    /// linkage spec body is being parsed.  Once RBraceLoc has been set this is\n    /// not used, so it doesn't need to be serialized.\n    uint64_t HasBraces : 1;\n  };\n\n  /// Number of non-inherited bits in LinkageSpecDeclBitfields.\n  enum { NumLinkageSpecDeclBits = 4 };\n\n  /// Stores the bits used by BlockDecl.\n  /// If modified NumBlockDeclBits and the accessor\n  /// methods in BlockDecl should be updated appropriately.\n  class BlockDeclBitfields {\n    friend class BlockDecl;\n    /// For the bits in DeclContextBitfields.\n    uint64_t : NumDeclContextBits;\n\n    uint64_t IsVariadic : 1;\n    uint64_t CapturesCXXThis : 1;\n    uint64_t BlockMissingReturnType : 1;\n    uint64_t IsConversionFromLambda : 1;\n\n    /// A bit that indicates this block is passed directly to a function as a\n    /// non-escaping parameter.\n    uint64_t DoesNotEscape : 1;\n\n    /// A bit that indicates whether it's possible to avoid coying this block to\n    /// the heap when it initializes or is assigned to a local variable with\n    /// automatic storage.\n    uint64_t CanAvoidCopyToHeap : 1;\n  };\n\n  /// Number of non-inherited bits in BlockDeclBitfields.\n  enum { NumBlockDeclBits = 5 };\n\n  /// Pointer to the data structure used to lookup declarations\n  /// within this context (or a DependentStoredDeclsMap if this is a\n  /// dependent context). We maintain the invariant that, if the map\n  /// contains an entry for a DeclarationName (and we haven't lazily\n  /// omitted anything), then it contains all relevant entries for that\n  /// name (modulo the hasExternalDecls() flag).\n  mutable StoredDeclsMap *LookupPtr = nullptr;\n\nprotected:\n  /// This anonymous union stores the bits belonging to DeclContext and classes\n  /// deriving from it. The goal is to use otherwise wasted\n  /// space in DeclContext to store data belonging to derived classes.\n  /// The space saved is especially significient when pointers are aligned\n  /// to 8 bytes. In this case due to alignment requirements we have a\n  /// little less than 8 bytes free in DeclContext which we can use.\n  /// We check that none of the classes in this union is larger than\n  /// 8 bytes with static_asserts in the ctor of DeclContext.\n  union {\n    DeclContextBitfields DeclContextBits;\n    TagDeclBitfields TagDeclBits;\n    EnumDeclBitfields EnumDeclBits;\n    RecordDeclBitfields RecordDeclBits;\n    OMPDeclareReductionDeclBitfields OMPDeclareReductionDeclBits;\n    FunctionDeclBitfields FunctionDeclBits;\n    CXXConstructorDeclBitfields CXXConstructorDeclBits;\n    ObjCMethodDeclBitfields ObjCMethodDeclBits;\n    ObjCContainerDeclBitfields ObjCContainerDeclBits;\n    LinkageSpecDeclBitfields LinkageSpecDeclBits;\n    BlockDeclBitfields BlockDeclBits;\n\n    static_assert(sizeof(DeclContextBitfields) <= 8,\n                  \"DeclContextBitfields is larger than 8 bytes!\");\n    static_assert(sizeof(TagDeclBitfields) <= 8,\n                  \"TagDeclBitfields is larger than 8 bytes!\");\n    static_assert(sizeof(EnumDeclBitfields) <= 8,\n                  \"EnumDeclBitfields is larger than 8 bytes!\");\n    static_assert(sizeof(RecordDeclBitfields) <= 8,\n                  \"RecordDeclBitfields is larger than 8 bytes!\");\n    static_assert(sizeof(OMPDeclareReductionDeclBitfields) <= 8,\n                  \"OMPDeclareReductionDeclBitfields is larger than 8 bytes!\");\n    static_assert(sizeof(FunctionDeclBitfields) <= 8,\n                  \"FunctionDeclBitfields is larger than 8 bytes!\");\n    static_assert(sizeof(CXXConstructorDeclBitfields) <= 8,\n                  \"CXXConstructorDeclBitfields is larger than 8 bytes!\");\n    static_assert(sizeof(ObjCMethodDeclBitfields) <= 8,\n                  \"ObjCMethodDeclBitfields is larger than 8 bytes!\");\n    static_assert(sizeof(ObjCContainerDeclBitfields) <= 8,\n                  \"ObjCContainerDeclBitfields is larger than 8 bytes!\");\n    static_assert(sizeof(LinkageSpecDeclBitfields) <= 8,\n                  \"LinkageSpecDeclBitfields is larger than 8 bytes!\");\n    static_assert(sizeof(BlockDeclBitfields) <= 8,\n                  \"BlockDeclBitfields is larger than 8 bytes!\");\n  };\n\n  /// FirstDecl - The first declaration stored within this declaration\n  /// context.\n  mutable Decl *FirstDecl = nullptr;\n\n  /// LastDecl - The last declaration stored within this declaration\n  /// context. FIXME: We could probably cache this value somewhere\n  /// outside of the DeclContext, to reduce the size of DeclContext by\n  /// another pointer.\n  mutable Decl *LastDecl = nullptr;\n\n  /// Build up a chain of declarations.\n  ///\n  /// \\returns the first/last pair of declarations.\n  static std::pair<Decl *, Decl *>\n  BuildDeclChain(ArrayRef<Decl*> Decls, bool FieldsAlreadyLoaded);\n\n  DeclContext(Decl::Kind K);\n\npublic:\n  ~DeclContext();\n\n  Decl::Kind getDeclKind() const {\n    return static_cast<Decl::Kind>(DeclContextBits.DeclKind);\n  }\n\n  const char *getDeclKindName() const;\n\n  /// getParent - Returns the containing DeclContext.\n  DeclContext *getParent() {\n    return cast<Decl>(this)->getDeclContext();\n  }\n  const DeclContext *getParent() const {\n    return const_cast<DeclContext*>(this)->getParent();\n  }\n\n  /// getLexicalParent - Returns the containing lexical DeclContext. May be\n  /// different from getParent, e.g.:\n  ///\n  ///   namespace A {\n  ///      struct S;\n  ///   }\n  ///   struct A::S {}; // getParent() == namespace 'A'\n  ///                   // getLexicalParent() == translation unit\n  ///\n  DeclContext *getLexicalParent() {\n    return cast<Decl>(this)->getLexicalDeclContext();\n  }\n  const DeclContext *getLexicalParent() const {\n    return const_cast<DeclContext*>(this)->getLexicalParent();\n  }\n\n  DeclContext *getLookupParent();\n\n  const DeclContext *getLookupParent() const {\n    return const_cast<DeclContext*>(this)->getLookupParent();\n  }\n\n  ASTContext &getParentASTContext() const {\n    return cast<Decl>(this)->getASTContext();\n  }\n\n  bool isClosure() const { return getDeclKind() == Decl::Block; }\n\n  /// Return this DeclContext if it is a BlockDecl. Otherwise, return the\n  /// innermost enclosing BlockDecl or null if there are no enclosing blocks.\n  const BlockDecl *getInnermostBlockDecl() const;\n\n  bool isObjCContainer() const {\n    switch (getDeclKind()) {\n    case Decl::ObjCCategory:\n    case Decl::ObjCCategoryImpl:\n    case Decl::ObjCImplementation:\n    case Decl::ObjCInterface:\n    case Decl::ObjCProtocol:\n      return true;\n    default:\n      return false;\n    }\n  }\n\n  bool isFunctionOrMethod() const {\n    switch (getDeclKind()) {\n    case Decl::Block:\n    case Decl::Captured:\n    case Decl::ObjCMethod:\n      return true;\n    default:\n      return getDeclKind() >= Decl::firstFunction &&\n             getDeclKind() <= Decl::lastFunction;\n    }\n  }\n\n  /// Test whether the context supports looking up names.\n  bool isLookupContext() const {\n    return !isFunctionOrMethod() && getDeclKind() != Decl::LinkageSpec &&\n           getDeclKind() != Decl::Export;\n  }\n\n  bool isFileContext() const {\n    return getDeclKind() == Decl::TranslationUnit ||\n           getDeclKind() == Decl::Namespace;\n  }\n\n  bool isTranslationUnit() const {\n    return getDeclKind() == Decl::TranslationUnit;\n  }\n\n  bool isRecord() const {\n    return getDeclKind() >= Decl::firstRecord &&\n           getDeclKind() <= Decl::lastRecord;\n  }\n\n  bool isNamespace() const { return getDeclKind() == Decl::Namespace; }\n\n  bool isStdNamespace() const;\n\n  bool isInlineNamespace() const;\n\n  /// Determines whether this context is dependent on a\n  /// template parameter.\n  bool isDependentContext() const;\n\n  /// isTransparentContext - Determines whether this context is a\n  /// \"transparent\" context, meaning that the members declared in this\n  /// context are semantically declared in the nearest enclosing\n  /// non-transparent (opaque) context but are lexically declared in\n  /// this context. For example, consider the enumerators of an\n  /// enumeration type:\n  /// @code\n  /// enum E {\n  ///   Val1\n  /// };\n  /// @endcode\n  /// Here, E is a transparent context, so its enumerator (Val1) will\n  /// appear (semantically) that it is in the same context of E.\n  /// Examples of transparent contexts include: enumerations (except for\n  /// C++0x scoped enums), and C++ linkage specifications.\n  bool isTransparentContext() const;\n\n  /// Determines whether this context or some of its ancestors is a\n  /// linkage specification context that specifies C linkage.\n  bool isExternCContext() const;\n\n  /// Retrieve the nearest enclosing C linkage specification context.\n  const LinkageSpecDecl *getExternCContext() const;\n\n  /// Determines whether this context or some of its ancestors is a\n  /// linkage specification context that specifies C++ linkage.\n  bool isExternCXXContext() const;\n\n  /// Determine whether this declaration context is equivalent\n  /// to the declaration context DC.\n  bool Equals(const DeclContext *DC) const {\n    return DC && this->getPrimaryContext() == DC->getPrimaryContext();\n  }\n\n  /// Determine whether this declaration context encloses the\n  /// declaration context DC.\n  bool Encloses(const DeclContext *DC) const;\n\n  /// Find the nearest non-closure ancestor of this context,\n  /// i.e. the innermost semantic parent of this context which is not\n  /// a closure.  A context may be its own non-closure ancestor.\n  Decl *getNonClosureAncestor();\n  const Decl *getNonClosureAncestor() const {\n    return const_cast<DeclContext*>(this)->getNonClosureAncestor();\n  }\n\n  /// getPrimaryContext - There may be many different\n  /// declarations of the same entity (including forward declarations\n  /// of classes, multiple definitions of namespaces, etc.), each with\n  /// a different set of declarations. This routine returns the\n  /// \"primary\" DeclContext structure, which will contain the\n  /// information needed to perform name lookup into this context.\n  DeclContext *getPrimaryContext();\n  const DeclContext *getPrimaryContext() const {\n    return const_cast<DeclContext*>(this)->getPrimaryContext();\n  }\n\n  /// getRedeclContext - Retrieve the context in which an entity conflicts with\n  /// other entities of the same name, or where it is a redeclaration if the\n  /// two entities are compatible. This skips through transparent contexts.\n  DeclContext *getRedeclContext();\n  const DeclContext *getRedeclContext() const {\n    return const_cast<DeclContext *>(this)->getRedeclContext();\n  }\n\n  /// Retrieve the nearest enclosing namespace context.\n  DeclContext *getEnclosingNamespaceContext();\n  const DeclContext *getEnclosingNamespaceContext() const {\n    return const_cast<DeclContext *>(this)->getEnclosingNamespaceContext();\n  }\n\n  /// Retrieve the outermost lexically enclosing record context.\n  RecordDecl *getOuterLexicalRecordContext();\n  const RecordDecl *getOuterLexicalRecordContext() const {\n    return const_cast<DeclContext *>(this)->getOuterLexicalRecordContext();\n  }\n\n  /// Test if this context is part of the enclosing namespace set of\n  /// the context NS, as defined in C++0x [namespace.def]p9. If either context\n  /// isn't a namespace, this is equivalent to Equals().\n  ///\n  /// The enclosing namespace set of a namespace is the namespace and, if it is\n  /// inline, its enclosing namespace, recursively.\n  bool InEnclosingNamespaceSetOf(const DeclContext *NS) const;\n\n  /// Collects all of the declaration contexts that are semantically\n  /// connected to this declaration context.\n  ///\n  /// For declaration contexts that have multiple semantically connected but\n  /// syntactically distinct contexts, such as C++ namespaces, this routine\n  /// retrieves the complete set of such declaration contexts in source order.\n  /// For example, given:\n  ///\n  /// \\code\n  /// namespace N {\n  ///   int x;\n  /// }\n  /// namespace N {\n  ///   int y;\n  /// }\n  /// \\endcode\n  ///\n  /// The \\c Contexts parameter will contain both definitions of N.\n  ///\n  /// \\param Contexts Will be cleared and set to the set of declaration\n  /// contexts that are semanticaly connected to this declaration context,\n  /// in source order, including this context (which may be the only result,\n  /// for non-namespace contexts).\n  void collectAllContexts(SmallVectorImpl<DeclContext *> &Contexts);\n\n  /// decl_iterator - Iterates through the declarations stored\n  /// within this context.\n  class decl_iterator {\n    /// Current - The current declaration.\n    Decl *Current = nullptr;\n\n  public:\n    using value_type = Decl *;\n    using reference = const value_type &;\n    using pointer = const value_type *;\n    using iterator_category = std::forward_iterator_tag;\n    using difference_type = std::ptrdiff_t;\n\n    decl_iterator() = default;\n    explicit decl_iterator(Decl *C) : Current(C) {}\n\n    reference operator*() const { return Current; }\n\n    // This doesn't meet the iterator requirements, but it's convenient\n    value_type operator->() const { return Current; }\n\n    decl_iterator& operator++() {\n      Current = Current->getNextDeclInContext();\n      return *this;\n    }\n\n    decl_iterator operator++(int) {\n      decl_iterator tmp(*this);\n      ++(*this);\n      return tmp;\n    }\n\n    friend bool operator==(decl_iterator x, decl_iterator y) {\n      return x.Current == y.Current;\n    }\n\n    friend bool operator!=(decl_iterator x, decl_iterator y) {\n      return x.Current != y.Current;\n    }\n  };\n\n  using decl_range = llvm::iterator_range<decl_iterator>;\n\n  /// decls_begin/decls_end - Iterate over the declarations stored in\n  /// this context.\n  decl_range decls() const { return decl_range(decls_begin(), decls_end()); }\n  decl_iterator decls_begin() const;\n  decl_iterator decls_end() const { return decl_iterator(); }\n  bool decls_empty() const;\n\n  /// noload_decls_begin/end - Iterate over the declarations stored in this\n  /// context that are currently loaded; don't attempt to retrieve anything\n  /// from an external source.\n  decl_range noload_decls() const {\n    return decl_range(noload_decls_begin(), noload_decls_end());\n  }\n  decl_iterator noload_decls_begin() const { return decl_iterator(FirstDecl); }\n  decl_iterator noload_decls_end() const { return decl_iterator(); }\n\n  /// specific_decl_iterator - Iterates over a subrange of\n  /// declarations stored in a DeclContext, providing only those that\n  /// are of type SpecificDecl (or a class derived from it). This\n  /// iterator is used, for example, to provide iteration over just\n  /// the fields within a RecordDecl (with SpecificDecl = FieldDecl).\n  template<typename SpecificDecl>\n  class specific_decl_iterator {\n    /// Current - The current, underlying declaration iterator, which\n    /// will either be NULL or will point to a declaration of\n    /// type SpecificDecl.\n    DeclContext::decl_iterator Current;\n\n    /// SkipToNextDecl - Advances the current position up to the next\n    /// declaration of type SpecificDecl that also meets the criteria\n    /// required by Acceptable.\n    void SkipToNextDecl() {\n      while (*Current && !isa<SpecificDecl>(*Current))\n        ++Current;\n    }\n\n  public:\n    using value_type = SpecificDecl *;\n    // TODO: Add reference and pointer types (with some appropriate proxy type)\n    // if we ever have a need for them.\n    using reference = void;\n    using pointer = void;\n    using difference_type =\n        std::iterator_traits<DeclContext::decl_iterator>::difference_type;\n    using iterator_category = std::forward_iterator_tag;\n\n    specific_decl_iterator() = default;\n\n    /// specific_decl_iterator - Construct a new iterator over a\n    /// subset of the declarations the range [C,\n    /// end-of-declarations). If A is non-NULL, it is a pointer to a\n    /// member function of SpecificDecl that should return true for\n    /// all of the SpecificDecl instances that will be in the subset\n    /// of iterators. For example, if you want Objective-C instance\n    /// methods, SpecificDecl will be ObjCMethodDecl and A will be\n    /// &ObjCMethodDecl::isInstanceMethod.\n    explicit specific_decl_iterator(DeclContext::decl_iterator C) : Current(C) {\n      SkipToNextDecl();\n    }\n\n    value_type operator*() const { return cast<SpecificDecl>(*Current); }\n\n    // This doesn't meet the iterator requirements, but it's convenient\n    value_type operator->() const { return **this; }\n\n    specific_decl_iterator& operator++() {\n      ++Current;\n      SkipToNextDecl();\n      return *this;\n    }\n\n    specific_decl_iterator operator++(int) {\n      specific_decl_iterator tmp(*this);\n      ++(*this);\n      return tmp;\n    }\n\n    friend bool operator==(const specific_decl_iterator& x,\n                           const specific_decl_iterator& y) {\n      return x.Current == y.Current;\n    }\n\n    friend bool operator!=(const specific_decl_iterator& x,\n                           const specific_decl_iterator& y) {\n      return x.Current != y.Current;\n    }\n  };\n\n  /// Iterates over a filtered subrange of declarations stored\n  /// in a DeclContext.\n  ///\n  /// This iterator visits only those declarations that are of type\n  /// SpecificDecl (or a class derived from it) and that meet some\n  /// additional run-time criteria. This iterator is used, for\n  /// example, to provide access to the instance methods within an\n  /// Objective-C interface (with SpecificDecl = ObjCMethodDecl and\n  /// Acceptable = ObjCMethodDecl::isInstanceMethod).\n  template<typename SpecificDecl, bool (SpecificDecl::*Acceptable)() const>\n  class filtered_decl_iterator {\n    /// Current - The current, underlying declaration iterator, which\n    /// will either be NULL or will point to a declaration of\n    /// type SpecificDecl.\n    DeclContext::decl_iterator Current;\n\n    /// SkipToNextDecl - Advances the current position up to the next\n    /// declaration of type SpecificDecl that also meets the criteria\n    /// required by Acceptable.\n    void SkipToNextDecl() {\n      while (*Current &&\n             (!isa<SpecificDecl>(*Current) ||\n              (Acceptable && !(cast<SpecificDecl>(*Current)->*Acceptable)())))\n        ++Current;\n    }\n\n  public:\n    using value_type = SpecificDecl *;\n    // TODO: Add reference and pointer types (with some appropriate proxy type)\n    // if we ever have a need for them.\n    using reference = void;\n    using pointer = void;\n    using difference_type =\n        std::iterator_traits<DeclContext::decl_iterator>::difference_type;\n    using iterator_category = std::forward_iterator_tag;\n\n    filtered_decl_iterator() = default;\n\n    /// filtered_decl_iterator - Construct a new iterator over a\n    /// subset of the declarations the range [C,\n    /// end-of-declarations). If A is non-NULL, it is a pointer to a\n    /// member function of SpecificDecl that should return true for\n    /// all of the SpecificDecl instances that will be in the subset\n    /// of iterators. For example, if you want Objective-C instance\n    /// methods, SpecificDecl will be ObjCMethodDecl and A will be\n    /// &ObjCMethodDecl::isInstanceMethod.\n    explicit filtered_decl_iterator(DeclContext::decl_iterator C) : Current(C) {\n      SkipToNextDecl();\n    }\n\n    value_type operator*() const { return cast<SpecificDecl>(*Current); }\n    value_type operator->() const { return cast<SpecificDecl>(*Current); }\n\n    filtered_decl_iterator& operator++() {\n      ++Current;\n      SkipToNextDecl();\n      return *this;\n    }\n\n    filtered_decl_iterator operator++(int) {\n      filtered_decl_iterator tmp(*this);\n      ++(*this);\n      return tmp;\n    }\n\n    friend bool operator==(const filtered_decl_iterator& x,\n                           const filtered_decl_iterator& y) {\n      return x.Current == y.Current;\n    }\n\n    friend bool operator!=(const filtered_decl_iterator& x,\n                           const filtered_decl_iterator& y) {\n      return x.Current != y.Current;\n    }\n  };\n\n  /// Add the declaration D into this context.\n  ///\n  /// This routine should be invoked when the declaration D has first\n  /// been declared, to place D into the context where it was\n  /// (lexically) defined. Every declaration must be added to one\n  /// (and only one!) context, where it can be visited via\n  /// [decls_begin(), decls_end()). Once a declaration has been added\n  /// to its lexical context, the corresponding DeclContext owns the\n  /// declaration.\n  ///\n  /// If D is also a NamedDecl, it will be made visible within its\n  /// semantic context via makeDeclVisibleInContext.\n  void addDecl(Decl *D);\n\n  /// Add the declaration D into this context, but suppress\n  /// searches for external declarations with the same name.\n  ///\n  /// Although analogous in function to addDecl, this removes an\n  /// important check.  This is only useful if the Decl is being\n  /// added in response to an external search; in all other cases,\n  /// addDecl() is the right function to use.\n  /// See the ASTImporter for use cases.\n  void addDeclInternal(Decl *D);\n\n  /// Add the declaration D to this context without modifying\n  /// any lookup tables.\n  ///\n  /// This is useful for some operations in dependent contexts where\n  /// the semantic context might not be dependent;  this basically\n  /// only happens with friends.\n  void addHiddenDecl(Decl *D);\n\n  /// Removes a declaration from this context.\n  void removeDecl(Decl *D);\n\n  /// Checks whether a declaration is in this context.\n  bool containsDecl(Decl *D) const;\n\n  /// Checks whether a declaration is in this context.\n  /// This also loads the Decls from the external source before the check.\n  bool containsDeclAndLoad(Decl *D) const;\n\n  using lookup_result = DeclContextLookupResult;\n  using lookup_iterator = lookup_result::iterator;\n\n  /// lookup - Find the declarations (if any) with the given Name in\n  /// this context. Returns a range of iterators that contains all of\n  /// the declarations with this name, with object, function, member,\n  /// and enumerator names preceding any tag name. Note that this\n  /// routine will not look into parent contexts.\n  lookup_result lookup(DeclarationName Name) const;\n\n  /// Find the declarations with the given name that are visible\n  /// within this context; don't attempt to retrieve anything from an\n  /// external source.\n  lookup_result noload_lookup(DeclarationName Name);\n\n  /// A simplistic name lookup mechanism that performs name lookup\n  /// into this declaration context without consulting the external source.\n  ///\n  /// This function should almost never be used, because it subverts the\n  /// usual relationship between a DeclContext and the external source.\n  /// See the ASTImporter for the (few, but important) use cases.\n  ///\n  /// FIXME: This is very inefficient; replace uses of it with uses of\n  /// noload_lookup.\n  void localUncachedLookup(DeclarationName Name,\n                           SmallVectorImpl<NamedDecl *> &Results);\n\n  /// Makes a declaration visible within this context.\n  ///\n  /// This routine makes the declaration D visible to name lookup\n  /// within this context and, if this is a transparent context,\n  /// within its parent contexts up to the first enclosing\n  /// non-transparent context. Making a declaration visible within a\n  /// context does not transfer ownership of a declaration, and a\n  /// declaration can be visible in many contexts that aren't its\n  /// lexical context.\n  ///\n  /// If D is a redeclaration of an existing declaration that is\n  /// visible from this context, as determined by\n  /// NamedDecl::declarationReplaces, the previous declaration will be\n  /// replaced with D.\n  void makeDeclVisibleInContext(NamedDecl *D);\n\n  /// all_lookups_iterator - An iterator that provides a view over the results\n  /// of looking up every possible name.\n  class all_lookups_iterator;\n\n  using lookups_range = llvm::iterator_range<all_lookups_iterator>;\n\n  lookups_range lookups() const;\n  // Like lookups(), but avoids loading external declarations.\n  // If PreserveInternalState, avoids building lookup data structures too.\n  lookups_range noload_lookups(bool PreserveInternalState) const;\n\n  /// Iterators over all possible lookups within this context.\n  all_lookups_iterator lookups_begin() const;\n  all_lookups_iterator lookups_end() const;\n\n  /// Iterators over all possible lookups within this context that are\n  /// currently loaded; don't attempt to retrieve anything from an external\n  /// source.\n  all_lookups_iterator noload_lookups_begin() const;\n  all_lookups_iterator noload_lookups_end() const;\n\n  struct udir_iterator;\n\n  using udir_iterator_base =\n      llvm::iterator_adaptor_base<udir_iterator, lookup_iterator,\n                                  std::random_access_iterator_tag,\n                                  UsingDirectiveDecl *>;\n\n  struct udir_iterator : udir_iterator_base {\n    udir_iterator(lookup_iterator I) : udir_iterator_base(I) {}\n\n    UsingDirectiveDecl *operator*() const;\n  };\n\n  using udir_range = llvm::iterator_range<udir_iterator>;\n\n  udir_range using_directives() const;\n\n  // These are all defined in DependentDiagnostic.h.\n  class ddiag_iterator;\n\n  using ddiag_range = llvm::iterator_range<DeclContext::ddiag_iterator>;\n\n  inline ddiag_range ddiags() const;\n\n  // Low-level accessors\n\n  /// Mark that there are external lexical declarations that we need\n  /// to include in our lookup table (and that are not available as external\n  /// visible lookups). These extra lookup results will be found by walking\n  /// the lexical declarations of this context. This should be used only if\n  /// setHasExternalLexicalStorage() has been called on any decl context for\n  /// which this is the primary context.\n  void setMustBuildLookupTable() {\n    assert(this == getPrimaryContext() &&\n           \"should only be called on primary context\");\n    DeclContextBits.HasLazyExternalLexicalLookups = true;\n  }\n\n  /// Retrieve the internal representation of the lookup structure.\n  /// This may omit some names if we are lazily building the structure.\n  StoredDeclsMap *getLookupPtr() const { return LookupPtr; }\n\n  /// Ensure the lookup structure is fully-built and return it.\n  StoredDeclsMap *buildLookup();\n\n  /// Whether this DeclContext has external storage containing\n  /// additional declarations that are lexically in this context.\n  bool hasExternalLexicalStorage() const {\n    return DeclContextBits.ExternalLexicalStorage;\n  }\n\n  /// State whether this DeclContext has external storage for\n  /// declarations lexically in this context.\n  void setHasExternalLexicalStorage(bool ES = true) const {\n    DeclContextBits.ExternalLexicalStorage = ES;\n  }\n\n  /// Whether this DeclContext has external storage containing\n  /// additional declarations that are visible in this context.\n  bool hasExternalVisibleStorage() const {\n    return DeclContextBits.ExternalVisibleStorage;\n  }\n\n  /// State whether this DeclContext has external storage for\n  /// declarations visible in this context.\n  void setHasExternalVisibleStorage(bool ES = true) const {\n    DeclContextBits.ExternalVisibleStorage = ES;\n    if (ES && LookupPtr)\n      DeclContextBits.NeedToReconcileExternalVisibleStorage = true;\n  }\n\n  /// Determine whether the given declaration is stored in the list of\n  /// declarations lexically within this context.\n  bool isDeclInLexicalTraversal(const Decl *D) const {\n    return D && (D->NextInContextAndBits.getPointer() || D == FirstDecl ||\n                 D == LastDecl);\n  }\n\n  bool setUseQualifiedLookup(bool use = true) const {\n    bool old_value = DeclContextBits.UseQualifiedLookup;\n    DeclContextBits.UseQualifiedLookup = use;\n    return old_value;\n  }\n\n  bool shouldUseQualifiedLookup() const {\n    return DeclContextBits.UseQualifiedLookup;\n  }\n\n  static bool classof(const Decl *D);\n  static bool classof(const DeclContext *D) { return true; }\n\n  void dumpDeclContext() const;\n  void dumpLookups() const;\n  void dumpLookups(llvm::raw_ostream &OS, bool DumpDecls = false,\n                   bool Deserialize = false) const;\n\nprivate:\n  /// Whether this declaration context has had externally visible\n  /// storage added since the last lookup. In this case, \\c LookupPtr's\n  /// invariant may not hold and needs to be fixed before we perform\n  /// another lookup.\n  bool hasNeedToReconcileExternalVisibleStorage() const {\n    return DeclContextBits.NeedToReconcileExternalVisibleStorage;\n  }\n\n  /// State that this declaration context has had externally visible\n  /// storage added since the last lookup. In this case, \\c LookupPtr's\n  /// invariant may not hold and needs to be fixed before we perform\n  /// another lookup.\n  void setNeedToReconcileExternalVisibleStorage(bool Need = true) const {\n    DeclContextBits.NeedToReconcileExternalVisibleStorage = Need;\n  }\n\n  /// If \\c true, this context may have local lexical declarations\n  /// that are missing from the lookup table.\n  bool hasLazyLocalLexicalLookups() const {\n    return DeclContextBits.HasLazyLocalLexicalLookups;\n  }\n\n  /// If \\c true, this context may have local lexical declarations\n  /// that are missing from the lookup table.\n  void setHasLazyLocalLexicalLookups(bool HasLLLL = true) const {\n    DeclContextBits.HasLazyLocalLexicalLookups = HasLLLL;\n  }\n\n  /// If \\c true, the external source may have lexical declarations\n  /// that are missing from the lookup table.\n  bool hasLazyExternalLexicalLookups() const {\n    return DeclContextBits.HasLazyExternalLexicalLookups;\n  }\n\n  /// If \\c true, the external source may have lexical declarations\n  /// that are missing from the lookup table.\n  void setHasLazyExternalLexicalLookups(bool HasLELL = true) const {\n    DeclContextBits.HasLazyExternalLexicalLookups = HasLELL;\n  }\n\n  void reconcileExternalVisibleStorage() const;\n  bool LoadLexicalDeclsFromExternalStorage() const;\n\n  /// Makes a declaration visible within this context, but\n  /// suppresses searches for external declarations with the same\n  /// name.\n  ///\n  /// Analogous to makeDeclVisibleInContext, but for the exclusive\n  /// use of addDeclInternal().\n  void makeDeclVisibleInContextInternal(NamedDecl *D);\n\n  StoredDeclsMap *CreateStoredDeclsMap(ASTContext &C) const;\n\n  void loadLazyLocalLexicalLookups();\n  void buildLookupImpl(DeclContext *DCtx, bool Internal);\n  void makeDeclVisibleInContextWithFlags(NamedDecl *D, bool Internal,\n                                         bool Rediscoverable);\n  void makeDeclVisibleInContextImpl(NamedDecl *D, bool Internal);\n};\n\ninline bool Decl::isTemplateParameter() const {\n  return getKind() == TemplateTypeParm || getKind() == NonTypeTemplateParm ||\n         getKind() == TemplateTemplateParm;\n}\n\n// Specialization selected when ToTy is not a known subclass of DeclContext.\ntemplate <class ToTy,\n          bool IsKnownSubtype = ::std::is_base_of<DeclContext, ToTy>::value>\nstruct cast_convert_decl_context {\n  static const ToTy *doit(const DeclContext *Val) {\n    return static_cast<const ToTy*>(Decl::castFromDeclContext(Val));\n  }\n\n  static ToTy *doit(DeclContext *Val) {\n    return static_cast<ToTy*>(Decl::castFromDeclContext(Val));\n  }\n};\n\n// Specialization selected when ToTy is a known subclass of DeclContext.\ntemplate <class ToTy>\nstruct cast_convert_decl_context<ToTy, true> {\n  static const ToTy *doit(const DeclContext *Val) {\n    return static_cast<const ToTy*>(Val);\n  }\n\n  static ToTy *doit(DeclContext *Val) {\n    return static_cast<ToTy*>(Val);\n  }\n};\n\n} // namespace clang\n\nnamespace llvm {\n\n/// isa<T>(DeclContext*)\ntemplate <typename To>\nstruct isa_impl<To, ::clang::DeclContext> {\n  static bool doit(const ::clang::DeclContext &Val) {\n    return To::classofKind(Val.getDeclKind());\n  }\n};\n\n/// cast<T>(DeclContext*)\ntemplate<class ToTy>\nstruct cast_convert_val<ToTy,\n                        const ::clang::DeclContext,const ::clang::DeclContext> {\n  static const ToTy &doit(const ::clang::DeclContext &Val) {\n    return *::clang::cast_convert_decl_context<ToTy>::doit(&Val);\n  }\n};\n\ntemplate<class ToTy>\nstruct cast_convert_val<ToTy, ::clang::DeclContext, ::clang::DeclContext> {\n  static ToTy &doit(::clang::DeclContext &Val) {\n    return *::clang::cast_convert_decl_context<ToTy>::doit(&Val);\n  }\n};\n\ntemplate<class ToTy>\nstruct cast_convert_val<ToTy,\n                     const ::clang::DeclContext*, const ::clang::DeclContext*> {\n  static const ToTy *doit(const ::clang::DeclContext *Val) {\n    return ::clang::cast_convert_decl_context<ToTy>::doit(Val);\n  }\n};\n\ntemplate<class ToTy>\nstruct cast_convert_val<ToTy, ::clang::DeclContext*, ::clang::DeclContext*> {\n  static ToTy *doit(::clang::DeclContext *Val) {\n    return ::clang::cast_convert_decl_context<ToTy>::doit(Val);\n  }\n};\n\n/// Implement cast_convert_val for Decl -> DeclContext conversions.\ntemplate<class FromTy>\nstruct cast_convert_val< ::clang::DeclContext, FromTy, FromTy> {\n  static ::clang::DeclContext &doit(const FromTy &Val) {\n    return *FromTy::castToDeclContext(&Val);\n  }\n};\n\ntemplate<class FromTy>\nstruct cast_convert_val< ::clang::DeclContext, FromTy*, FromTy*> {\n  static ::clang::DeclContext *doit(const FromTy *Val) {\n    return FromTy::castToDeclContext(Val);\n  }\n};\n\ntemplate<class FromTy>\nstruct cast_convert_val< const ::clang::DeclContext, FromTy, FromTy> {\n  static const ::clang::DeclContext &doit(const FromTy &Val) {\n    return *FromTy::castToDeclContext(&Val);\n  }\n};\n\ntemplate<class FromTy>\nstruct cast_convert_val< const ::clang::DeclContext, FromTy*, FromTy*> {\n  static const ::clang::DeclContext *doit(const FromTy *Val) {\n    return FromTy::castToDeclContext(Val);\n  }\n};\n\n} // namespace llvm\n\n#endif // LLVM_CLANG_AST_DECLBASE_H\n"}, "6": {"id": 6, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/DeclCXX.h", "content": "//===- DeclCXX.h - Classes for representing C++ declarations --*- C++ -*-=====//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n/// \\file\n/// Defines the C++ Decl subclasses, other than those for templates\n/// (found in DeclTemplate.h) and friends (in DeclFriend.h).\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_AST_DECLCXX_H\n#define LLVM_CLANG_AST_DECLCXX_H\n\n#include \"clang/AST/ASTUnresolvedSet.h\"\n#include \"clang/AST/Decl.h\"\n#include \"clang/AST/DeclBase.h\"\n#include \"clang/AST/DeclarationName.h\"\n#include \"clang/AST/Expr.h\"\n#include \"clang/AST/ExternalASTSource.h\"\n#include \"clang/AST/LambdaCapture.h\"\n#include \"clang/AST/NestedNameSpecifier.h\"\n#include \"clang/AST/Redeclarable.h\"\n#include \"clang/AST/Stmt.h\"\n#include \"clang/AST/Type.h\"\n#include \"clang/AST/TypeLoc.h\"\n#include \"clang/AST/UnresolvedSet.h\"\n#include \"clang/Basic/LLVM.h\"\n#include \"clang/Basic/Lambda.h\"\n#include \"clang/Basic/LangOptions.h\"\n#include \"clang/Basic/OperatorKinds.h\"\n#include \"clang/Basic/SourceLocation.h\"\n#include \"clang/Basic/Specifiers.h\"\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/ADT/DenseMap.h\"\n#include \"llvm/ADT/PointerIntPair.h\"\n#include \"llvm/ADT/PointerUnion.h\"\n#include \"llvm/ADT/STLExtras.h\"\n#include \"llvm/ADT/TinyPtrVector.h\"\n#include \"llvm/ADT/iterator_range.h\"\n#include \"llvm/Support/Casting.h\"\n#include \"llvm/Support/Compiler.h\"\n#include \"llvm/Support/PointerLikeTypeTraits.h\"\n#include \"llvm/Support/TrailingObjects.h\"\n#include <cassert>\n#include <cstddef>\n#include <iterator>\n#include <memory>\n#include <vector>\n\nnamespace clang {\n\nclass ASTContext;\nclass ClassTemplateDecl;\nclass ConstructorUsingShadowDecl;\nclass CXXBasePath;\nclass CXXBasePaths;\nclass CXXConstructorDecl;\nclass CXXDestructorDecl;\nclass CXXFinalOverriderMap;\nclass CXXIndirectPrimaryBaseSet;\nclass CXXMethodDecl;\nclass DecompositionDecl;\nclass DiagnosticBuilder;\nclass FriendDecl;\nclass FunctionTemplateDecl;\nclass IdentifierInfo;\nclass MemberSpecializationInfo;\nclass TemplateDecl;\nclass TemplateParameterList;\nclass UsingDecl;\n\n/// Represents an access specifier followed by colon ':'.\n///\n/// An objects of this class represents sugar for the syntactic occurrence\n/// of an access specifier followed by a colon in the list of member\n/// specifiers of a C++ class definition.\n///\n/// Note that they do not represent other uses of access specifiers,\n/// such as those occurring in a list of base specifiers.\n/// Also note that this class has nothing to do with so-called\n/// \"access declarations\" (C++98 11.3 [class.access.dcl]).\nclass AccessSpecDecl : public Decl {\n  /// The location of the ':'.\n  SourceLocation ColonLoc;\n\n  AccessSpecDecl(AccessSpecifier AS, DeclContext *DC,\n                 SourceLocation ASLoc, SourceLocation ColonLoc)\n    : Decl(AccessSpec, DC, ASLoc), ColonLoc(ColonLoc) {\n    setAccess(AS);\n  }\n\n  AccessSpecDecl(EmptyShell Empty) : Decl(AccessSpec, Empty) {}\n\n  virtual void anchor();\n\npublic:\n  /// The location of the access specifier.\n  SourceLocation getAccessSpecifierLoc() const { return getLocation(); }\n\n  /// Sets the location of the access specifier.\n  void setAccessSpecifierLoc(SourceLocation ASLoc) { setLocation(ASLoc); }\n\n  /// The location of the colon following the access specifier.\n  SourceLocation getColonLoc() const { return ColonLoc; }\n\n  /// Sets the location of the colon.\n  void setColonLoc(SourceLocation CLoc) { ColonLoc = CLoc; }\n\n  SourceRange getSourceRange() const override LLVM_READONLY {\n    return SourceRange(getAccessSpecifierLoc(), getColonLoc());\n  }\n\n  static AccessSpecDecl *Create(ASTContext &C, AccessSpecifier AS,\n                                DeclContext *DC, SourceLocation ASLoc,\n                                SourceLocation ColonLoc) {\n    return new (C, DC) AccessSpecDecl(AS, DC, ASLoc, ColonLoc);\n  }\n\n  static AccessSpecDecl *CreateDeserialized(ASTContext &C, unsigned ID);\n\n  // Implement isa/cast/dyncast/etc.\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) { return K == AccessSpec; }\n};\n\n/// Represents a base class of a C++ class.\n///\n/// Each CXXBaseSpecifier represents a single, direct base class (or\n/// struct) of a C++ class (or struct). It specifies the type of that\n/// base class, whether it is a virtual or non-virtual base, and what\n/// level of access (public, protected, private) is used for the\n/// derivation. For example:\n///\n/// \\code\n///   class A { };\n///   class B { };\n///   class C : public virtual A, protected B { };\n/// \\endcode\n///\n/// In this code, C will have two CXXBaseSpecifiers, one for \"public\n/// virtual A\" and the other for \"protected B\".\nclass CXXBaseSpecifier {\n  /// The source code range that covers the full base\n  /// specifier, including the \"virtual\" (if present) and access\n  /// specifier (if present).\n  SourceRange Range;\n\n  /// The source location of the ellipsis, if this is a pack\n  /// expansion.\n  SourceLocation EllipsisLoc;\n\n  /// Whether this is a virtual base class or not.\n  unsigned Virtual : 1;\n\n  /// Whether this is the base of a class (true) or of a struct (false).\n  ///\n  /// This determines the mapping from the access specifier as written in the\n  /// source code to the access specifier used for semantic analysis.\n  unsigned BaseOfClass : 1;\n\n  /// Access specifier as written in the source code (may be AS_none).\n  ///\n  /// The actual type of data stored here is an AccessSpecifier, but we use\n  /// \"unsigned\" here to work around a VC++ bug.\n  unsigned Access : 2;\n\n  /// Whether the class contains a using declaration\n  /// to inherit the named class's constructors.\n  unsigned InheritConstructors : 1;\n\n  /// The type of the base class.\n  ///\n  /// This will be a class or struct (or a typedef of such). The source code\n  /// range does not include the \\c virtual or the access specifier.\n  TypeSourceInfo *BaseTypeInfo;\n\npublic:\n  CXXBaseSpecifier() = default;\n  CXXBaseSpecifier(SourceRange R, bool V, bool BC, AccessSpecifier A,\n                   TypeSourceInfo *TInfo, SourceLocation EllipsisLoc)\n    : Range(R), EllipsisLoc(EllipsisLoc), Virtual(V), BaseOfClass(BC),\n      Access(A), InheritConstructors(false), BaseTypeInfo(TInfo) {}\n\n  /// Retrieves the source range that contains the entire base specifier.\n  SourceRange getSourceRange() const LLVM_READONLY { return Range; }\n  SourceLocation getBeginLoc() const LLVM_READONLY { return Range.getBegin(); }\n  SourceLocation getEndLoc() const LLVM_READONLY { return Range.getEnd(); }\n\n  /// Get the location at which the base class type was written.\n  SourceLocation getBaseTypeLoc() const LLVM_READONLY {\n    return BaseTypeInfo->getTypeLoc().getBeginLoc();\n  }\n\n  /// Determines whether the base class is a virtual base class (or not).\n  bool isVirtual() const { return Virtual; }\n\n  /// Determine whether this base class is a base of a class declared\n  /// with the 'class' keyword (vs. one declared with the 'struct' keyword).\n  bool isBaseOfClass() const { return BaseOfClass; }\n\n  /// Determine whether this base specifier is a pack expansion.\n  bool isPackExpansion() const { return EllipsisLoc.isValid(); }\n\n  /// Determine whether this base class's constructors get inherited.\n  bool getInheritConstructors() const { return InheritConstructors; }\n\n  /// Set that this base class's constructors should be inherited.\n  void setInheritConstructors(bool Inherit = true) {\n    InheritConstructors = Inherit;\n  }\n\n  /// For a pack expansion, determine the location of the ellipsis.\n  SourceLocation getEllipsisLoc() const {\n    return EllipsisLoc;\n  }\n\n  /// Returns the access specifier for this base specifier.\n  ///\n  /// This is the actual base specifier as used for semantic analysis, so\n  /// the result can never be AS_none. To retrieve the access specifier as\n  /// written in the source code, use getAccessSpecifierAsWritten().\n  AccessSpecifier getAccessSpecifier() const {\n    if ((AccessSpecifier)Access == AS_none)\n      return BaseOfClass? AS_private : AS_public;\n    else\n      return (AccessSpecifier)Access;\n  }\n\n  /// Retrieves the access specifier as written in the source code\n  /// (which may mean that no access specifier was explicitly written).\n  ///\n  /// Use getAccessSpecifier() to retrieve the access specifier for use in\n  /// semantic analysis.\n  AccessSpecifier getAccessSpecifierAsWritten() const {\n    return (AccessSpecifier)Access;\n  }\n\n  /// Retrieves the type of the base class.\n  ///\n  /// This type will always be an unqualified class type.\n  QualType getType() const {\n    return BaseTypeInfo->getType().getUnqualifiedType();\n  }\n\n  /// Retrieves the type and source location of the base class.\n  TypeSourceInfo *getTypeSourceInfo() const { return BaseTypeInfo; }\n};\n\n/// Represents a C++ struct/union/class.\nclass CXXRecordDecl : public RecordDecl {\n  friend class ASTDeclReader;\n  friend class ASTDeclWriter;\n  friend class ASTNodeImporter;\n  friend class ASTReader;\n  friend class ASTRecordWriter;\n  friend class ASTWriter;\n  friend class DeclContext;\n  friend class LambdaExpr;\n\n  friend void FunctionDecl::setPure(bool);\n  friend void TagDecl::startDefinition();\n\n  /// Values used in DefinitionData fields to represent special members.\n  enum SpecialMemberFlags {\n    SMF_DefaultConstructor = 0x1,\n    SMF_CopyConstructor = 0x2,\n    SMF_MoveConstructor = 0x4,\n    SMF_CopyAssignment = 0x8,\n    SMF_MoveAssignment = 0x10,\n    SMF_Destructor = 0x20,\n    SMF_All = 0x3f\n  };\n\n  struct DefinitionData {\n    #define FIELD(Name, Width, Merge) \\\n    unsigned Name : Width;\n    #include \"CXXRecordDeclDefinitionBits.def\"\n\n    /// Whether this class describes a C++ lambda.\n    unsigned IsLambda : 1;\n\n    /// Whether we are currently parsing base specifiers.\n    unsigned IsParsingBaseSpecifiers : 1;\n\n    /// True when visible conversion functions are already computed\n    /// and are available.\n    unsigned ComputedVisibleConversions : 1;\n\n    unsigned HasODRHash : 1;\n\n    /// A hash of parts of the class to help in ODR checking.\n    unsigned ODRHash = 0;\n\n    /// The number of base class specifiers in Bases.\n    unsigned NumBases = 0;\n\n    /// The number of virtual base class specifiers in VBases.\n    unsigned NumVBases = 0;\n\n    /// Base classes of this class.\n    ///\n    /// FIXME: This is wasted space for a union.\n    LazyCXXBaseSpecifiersPtr Bases;\n\n    /// direct and indirect virtual base classes of this class.\n    LazyCXXBaseSpecifiersPtr VBases;\n\n    /// The conversion functions of this C++ class (but not its\n    /// inherited conversion functions).\n    ///\n    /// Each of the entries in this overload set is a CXXConversionDecl.\n    LazyASTUnresolvedSet Conversions;\n\n    /// The conversion functions of this C++ class and all those\n    /// inherited conversion functions that are visible in this class.\n    ///\n    /// Each of the entries in this overload set is a CXXConversionDecl or a\n    /// FunctionTemplateDecl.\n    LazyASTUnresolvedSet VisibleConversions;\n\n    /// The declaration which defines this record.\n    CXXRecordDecl *Definition;\n\n    /// The first friend declaration in this class, or null if there\n    /// aren't any.\n    ///\n    /// This is actually currently stored in reverse order.\n    LazyDeclPtr FirstFriend;\n\n    DefinitionData(CXXRecordDecl *D);\n\n    /// Retrieve the set of direct base classes.\n    CXXBaseSpecifier *getBases() const {\n      if (!Bases.isOffset())\n        return Bases.get(nullptr);\n      return getBasesSlowCase();\n    }\n\n    /// Retrieve the set of virtual base classes.\n    CXXBaseSpecifier *getVBases() const {\n      if (!VBases.isOffset())\n        return VBases.get(nullptr);\n      return getVBasesSlowCase();\n    }\n\n    ArrayRef<CXXBaseSpecifier> bases() const {\n      return llvm::makeArrayRef(getBases(), NumBases);\n    }\n\n    ArrayRef<CXXBaseSpecifier> vbases() const {\n      return llvm::makeArrayRef(getVBases(), NumVBases);\n    }\n\n  private:\n    CXXBaseSpecifier *getBasesSlowCase() const;\n    CXXBaseSpecifier *getVBasesSlowCase() const;\n  };\n\n  struct DefinitionData *DefinitionData;\n\n  /// Describes a C++ closure type (generated by a lambda expression).\n  struct LambdaDefinitionData : public DefinitionData {\n    using Capture = LambdaCapture;\n\n    /// Whether this lambda is known to be dependent, even if its\n    /// context isn't dependent.\n    ///\n    /// A lambda with a non-dependent context can be dependent if it occurs\n    /// within the default argument of a function template, because the\n    /// lambda will have been created with the enclosing context as its\n    /// declaration context, rather than function. This is an unfortunate\n    /// artifact of having to parse the default arguments before.\n    unsigned Dependent : 1;\n\n    /// Whether this lambda is a generic lambda.\n    unsigned IsGenericLambda : 1;\n\n    /// The Default Capture.\n    unsigned CaptureDefault : 2;\n\n    /// The number of captures in this lambda is limited 2^NumCaptures.\n    unsigned NumCaptures : 15;\n\n    /// The number of explicit captures in this lambda.\n    unsigned NumExplicitCaptures : 13;\n\n    /// Has known `internal` linkage.\n    unsigned HasKnownInternalLinkage : 1;\n\n    /// The number used to indicate this lambda expression for name\n    /// mangling in the Itanium C++ ABI.\n    unsigned ManglingNumber : 31;\n\n    /// The declaration that provides context for this lambda, if the\n    /// actual DeclContext does not suffice. This is used for lambdas that\n    /// occur within default arguments of function parameters within the class\n    /// or within a data member initializer.\n    LazyDeclPtr ContextDecl;\n\n    /// The list of captures, both explicit and implicit, for this\n    /// lambda.\n    Capture *Captures = nullptr;\n\n    /// The type of the call method.\n    TypeSourceInfo *MethodTyInfo;\n\n    LambdaDefinitionData(CXXRecordDecl *D, TypeSourceInfo *Info, bool Dependent,\n                         bool IsGeneric, LambdaCaptureDefault CaptureDefault)\n        : DefinitionData(D), Dependent(Dependent), IsGenericLambda(IsGeneric),\n          CaptureDefault(CaptureDefault), NumCaptures(0),\n          NumExplicitCaptures(0), HasKnownInternalLinkage(0), ManglingNumber(0),\n          MethodTyInfo(Info) {\n      IsLambda = true;\n\n      // C++1z [expr.prim.lambda]p4:\n      //   This class type is not an aggregate type.\n      Aggregate = false;\n      PlainOldData = false;\n    }\n  };\n\n  struct DefinitionData *dataPtr() const {\n    // Complete the redecl chain (if necessary).\n    getMostRecentDecl();\n    return DefinitionData;\n  }\n\n  struct DefinitionData &data() const {\n    auto *DD = dataPtr();\n    assert(DD && \"queried property of class with no definition\");\n    return *DD;\n  }\n\n  struct LambdaDefinitionData &getLambdaData() const {\n    // No update required: a merged definition cannot change any lambda\n    // properties.\n    auto *DD = DefinitionData;\n    assert(DD && DD->IsLambda && \"queried lambda property of non-lambda class\");\n    return static_cast<LambdaDefinitionData&>(*DD);\n  }\n\n  /// The template or declaration that this declaration\n  /// describes or was instantiated from, respectively.\n  ///\n  /// For non-templates, this value will be null. For record\n  /// declarations that describe a class template, this will be a\n  /// pointer to a ClassTemplateDecl. For member\n  /// classes of class template specializations, this will be the\n  /// MemberSpecializationInfo referring to the member class that was\n  /// instantiated or specialized.\n  llvm::PointerUnion<ClassTemplateDecl *, MemberSpecializationInfo *>\n      TemplateOrInstantiation;\n\n  /// Called from setBases and addedMember to notify the class that a\n  /// direct or virtual base class or a member of class type has been added.\n  void addedClassSubobject(CXXRecordDecl *Base);\n\n  /// Notify the class that member has been added.\n  ///\n  /// This routine helps maintain information about the class based on which\n  /// members have been added. It will be invoked by DeclContext::addDecl()\n  /// whenever a member is added to this record.\n  void addedMember(Decl *D);\n\n  void markedVirtualFunctionPure();\n\n  /// Get the head of our list of friend declarations, possibly\n  /// deserializing the friends from an external AST source.\n  FriendDecl *getFirstFriend() const;\n\n  /// Determine whether this class has an empty base class subobject of type X\n  /// or of one of the types that might be at offset 0 within X (per the C++\n  /// \"standard layout\" rules).\n  bool hasSubobjectAtOffsetZeroOfEmptyBaseType(ASTContext &Ctx,\n                                               const CXXRecordDecl *X);\n\nprotected:\n  CXXRecordDecl(Kind K, TagKind TK, const ASTContext &C, DeclContext *DC,\n                SourceLocation StartLoc, SourceLocation IdLoc,\n                IdentifierInfo *Id, CXXRecordDecl *PrevDecl);\n\npublic:\n  /// Iterator that traverses the base classes of a class.\n  using base_class_iterator = CXXBaseSpecifier *;\n\n  /// Iterator that traverses the base classes of a class.\n  using base_class_const_iterator = const CXXBaseSpecifier *;\n\n  CXXRecordDecl *getCanonicalDecl() override {\n    return cast<CXXRecordDecl>(RecordDecl::getCanonicalDecl());\n  }\n\n  const CXXRecordDecl *getCanonicalDecl() const {\n    return const_cast<CXXRecordDecl*>(this)->getCanonicalDecl();\n  }\n\n  CXXRecordDecl *getPreviousDecl() {\n    return cast_or_null<CXXRecordDecl>(\n            static_cast<RecordDecl *>(this)->getPreviousDecl());\n  }\n\n  const CXXRecordDecl *getPreviousDecl() const {\n    return const_cast<CXXRecordDecl*>(this)->getPreviousDecl();\n  }\n\n  CXXRecordDecl *getMostRecentDecl() {\n    return cast<CXXRecordDecl>(\n            static_cast<RecordDecl *>(this)->getMostRecentDecl());\n  }\n\n  const CXXRecordDecl *getMostRecentDecl() const {\n    return const_cast<CXXRecordDecl*>(this)->getMostRecentDecl();\n  }\n\n  CXXRecordDecl *getMostRecentNonInjectedDecl() {\n    CXXRecordDecl *Recent =\n        static_cast<CXXRecordDecl *>(this)->getMostRecentDecl();\n    while (Recent->isInjectedClassName()) {\n      // FIXME: Does injected class name need to be in the redeclarations chain?\n      assert(Recent->getPreviousDecl());\n      Recent = Recent->getPreviousDecl();\n    }\n    return Recent;\n  }\n\n  const CXXRecordDecl *getMostRecentNonInjectedDecl() const {\n    return const_cast<CXXRecordDecl*>(this)->getMostRecentNonInjectedDecl();\n  }\n\n  CXXRecordDecl *getDefinition() const {\n    // We only need an update if we don't already know which\n    // declaration is the definition.\n    auto *DD = DefinitionData ? DefinitionData : dataPtr();\n    return DD ? DD->Definition : nullptr;\n  }\n\n  bool hasDefinition() const { return DefinitionData || dataPtr(); }\n\n  static CXXRecordDecl *Create(const ASTContext &C, TagKind TK, DeclContext *DC,\n                               SourceLocation StartLoc, SourceLocation IdLoc,\n                               IdentifierInfo *Id,\n                               CXXRecordDecl *PrevDecl = nullptr,\n                               bool DelayTypeCreation = false);\n  static CXXRecordDecl *CreateLambda(const ASTContext &C, DeclContext *DC,\n                                     TypeSourceInfo *Info, SourceLocation Loc,\n                                     bool DependentLambda, bool IsGeneric,\n                                     LambdaCaptureDefault CaptureDefault);\n  static CXXRecordDecl *CreateDeserialized(const ASTContext &C, unsigned ID);\n\n  bool isDynamicClass() const {\n    return data().Polymorphic || data().NumVBases != 0;\n  }\n\n  /// @returns true if class is dynamic or might be dynamic because the\n  /// definition is incomplete of dependent.\n  bool mayBeDynamicClass() const {\n    return !hasDefinition() || isDynamicClass() || hasAnyDependentBases();\n  }\n\n  /// @returns true if class is non dynamic or might be non dynamic because the\n  /// definition is incomplete of dependent.\n  bool mayBeNonDynamicClass() const {\n    return !hasDefinition() || !isDynamicClass() || hasAnyDependentBases();\n  }\n\n  void setIsParsingBaseSpecifiers() { data().IsParsingBaseSpecifiers = true; }\n\n  bool isParsingBaseSpecifiers() const {\n    return data().IsParsingBaseSpecifiers;\n  }\n\n  unsigned getODRHash() const;\n\n  /// Sets the base classes of this struct or class.\n  void setBases(CXXBaseSpecifier const * const *Bases, unsigned NumBases);\n\n  /// Retrieves the number of base classes of this class.\n  unsigned getNumBases() const { return data().NumBases; }\n\n  using base_class_range = llvm::iterator_range<base_class_iterator>;\n  using base_class_const_range =\n      llvm::iterator_range<base_class_const_iterator>;\n\n  base_class_range bases() {\n    return base_class_range(bases_begin(), bases_end());\n  }\n  base_class_const_range bases() const {\n    return base_class_const_range(bases_begin(), bases_end());\n  }\n\n  base_class_iterator bases_begin() { return data().getBases(); }\n  base_class_const_iterator bases_begin() const { return data().getBases(); }\n  base_class_iterator bases_end() { return bases_begin() + data().NumBases; }\n  base_class_const_iterator bases_end() const {\n    return bases_begin() + data().NumBases;\n  }\n\n  /// Retrieves the number of virtual base classes of this class.\n  unsigned getNumVBases() const { return data().NumVBases; }\n\n  base_class_range vbases() {\n    return base_class_range(vbases_begin(), vbases_end());\n  }\n  base_class_const_range vbases() const {\n    return base_class_const_range(vbases_begin(), vbases_end());\n  }\n\n  base_class_iterator vbases_begin() { return data().getVBases(); }\n  base_class_const_iterator vbases_begin() const { return data().getVBases(); }\n  base_class_iterator vbases_end() { return vbases_begin() + data().NumVBases; }\n  base_class_const_iterator vbases_end() const {\n    return vbases_begin() + data().NumVBases;\n  }\n\n  /// Determine whether this class has any dependent base classes which\n  /// are not the current instantiation.\n  bool hasAnyDependentBases() const;\n\n  /// Iterator access to method members.  The method iterator visits\n  /// all method members of the class, including non-instance methods,\n  /// special methods, etc.\n  using method_iterator = specific_decl_iterator<CXXMethodDecl>;\n  using method_range =\n      llvm::iterator_range<specific_decl_iterator<CXXMethodDecl>>;\n\n  method_range methods() const {\n    return method_range(method_begin(), method_end());\n  }\n\n  /// Method begin iterator.  Iterates in the order the methods\n  /// were declared.\n  method_iterator method_begin() const {\n    return method_iterator(decls_begin());\n  }\n\n  /// Method past-the-end iterator.\n  method_iterator method_end() const {\n    return method_iterator(decls_end());\n  }\n\n  /// Iterator access to constructor members.\n  using ctor_iterator = specific_decl_iterator<CXXConstructorDecl>;\n  using ctor_range =\n      llvm::iterator_range<specific_decl_iterator<CXXConstructorDecl>>;\n\n  ctor_range ctors() const { return ctor_range(ctor_begin(), ctor_end()); }\n\n  ctor_iterator ctor_begin() const {\n    return ctor_iterator(decls_begin());\n  }\n\n  ctor_iterator ctor_end() const {\n    return ctor_iterator(decls_end());\n  }\n\n  /// An iterator over friend declarations.  All of these are defined\n  /// in DeclFriend.h.\n  class friend_iterator;\n  using friend_range = llvm::iterator_range<friend_iterator>;\n\n  friend_range friends() const;\n  friend_iterator friend_begin() const;\n  friend_iterator friend_end() const;\n  void pushFriendDecl(FriendDecl *FD);\n\n  /// Determines whether this record has any friends.\n  bool hasFriends() const {\n    return data().FirstFriend.isValid();\n  }\n\n  /// \\c true if a defaulted copy constructor for this class would be\n  /// deleted.\n  bool defaultedCopyConstructorIsDeleted() const {\n    assert((!needsOverloadResolutionForCopyConstructor() ||\n            (data().DeclaredSpecialMembers & SMF_CopyConstructor)) &&\n           \"this property has not yet been computed by Sema\");\n    return data().DefaultedCopyConstructorIsDeleted;\n  }\n\n  /// \\c true if a defaulted move constructor for this class would be\n  /// deleted.\n  bool defaultedMoveConstructorIsDeleted() const {\n    assert((!needsOverloadResolutionForMoveConstructor() ||\n            (data().DeclaredSpecialMembers & SMF_MoveConstructor)) &&\n           \"this property has not yet been computed by Sema\");\n    return data().DefaultedMoveConstructorIsDeleted;\n  }\n\n  /// \\c true if a defaulted destructor for this class would be deleted.\n  bool defaultedDestructorIsDeleted() const {\n    assert((!needsOverloadResolutionForDestructor() ||\n            (data().DeclaredSpecialMembers & SMF_Destructor)) &&\n           \"this property has not yet been computed by Sema\");\n    return data().DefaultedDestructorIsDeleted;\n  }\n\n  /// \\c true if we know for sure that this class has a single,\n  /// accessible, unambiguous copy constructor that is not deleted.\n  bool hasSimpleCopyConstructor() const {\n    return !hasUserDeclaredCopyConstructor() &&\n           !data().DefaultedCopyConstructorIsDeleted;\n  }\n\n  /// \\c true if we know for sure that this class has a single,\n  /// accessible, unambiguous move constructor that is not deleted.\n  bool hasSimpleMoveConstructor() const {\n    return !hasUserDeclaredMoveConstructor() && hasMoveConstructor() &&\n           !data().DefaultedMoveConstructorIsDeleted;\n  }\n\n  /// \\c true if we know for sure that this class has a single,\n  /// accessible, unambiguous copy assignment operator that is not deleted.\n  bool hasSimpleCopyAssignment() const {\n    return !hasUserDeclaredCopyAssignment() &&\n           !data().DefaultedCopyAssignmentIsDeleted;\n  }\n\n  /// \\c true if we know for sure that this class has a single,\n  /// accessible, unambiguous move assignment operator that is not deleted.\n  bool hasSimpleMoveAssignment() const {\n    return !hasUserDeclaredMoveAssignment() && hasMoveAssignment() &&\n           !data().DefaultedMoveAssignmentIsDeleted;\n  }\n\n  /// \\c true if we know for sure that this class has an accessible\n  /// destructor that is not deleted.\n  bool hasSimpleDestructor() const {\n    return !hasUserDeclaredDestructor() &&\n           !data().DefaultedDestructorIsDeleted;\n  }\n\n  /// Determine whether this class has any default constructors.\n  bool hasDefaultConstructor() const {\n    return (data().DeclaredSpecialMembers & SMF_DefaultConstructor) ||\n           needsImplicitDefaultConstructor();\n  }\n\n  /// Determine if we need to declare a default constructor for\n  /// this class.\n  ///\n  /// This value is used for lazy creation of default constructors.\n  bool needsImplicitDefaultConstructor() const {\n    return (!data().UserDeclaredConstructor &&\n            !(data().DeclaredSpecialMembers & SMF_DefaultConstructor) &&\n            (!isLambda() || lambdaIsDefaultConstructibleAndAssignable())) ||\n           // FIXME: Proposed fix to core wording issue: if a class inherits\n           // a default constructor and doesn't explicitly declare one, one\n           // is declared implicitly.\n           (data().HasInheritedDefaultConstructor &&\n            !(data().DeclaredSpecialMembers & SMF_DefaultConstructor));\n  }\n\n  /// Determine whether this class has any user-declared constructors.\n  ///\n  /// When true, a default constructor will not be implicitly declared.\n  bool hasUserDeclaredConstructor() const {\n    return data().UserDeclaredConstructor;\n  }\n\n  /// Whether this class has a user-provided default constructor\n  /// per C++11.\n  bool hasUserProvidedDefaultConstructor() const {\n    return data().UserProvidedDefaultConstructor;\n  }\n\n  /// Determine whether this class has a user-declared copy constructor.\n  ///\n  /// When false, a copy constructor will be implicitly declared.\n  bool hasUserDeclaredCopyConstructor() const {\n    return data().UserDeclaredSpecialMembers & SMF_CopyConstructor;\n  }\n\n  /// Determine whether this class needs an implicit copy\n  /// constructor to be lazily declared.\n  bool needsImplicitCopyConstructor() const {\n    return !(data().DeclaredSpecialMembers & SMF_CopyConstructor);\n  }\n\n  /// Determine whether we need to eagerly declare a defaulted copy\n  /// constructor for this class.\n  bool needsOverloadResolutionForCopyConstructor() const {\n    // C++17 [class.copy.ctor]p6:\n    //   If the class definition declares a move constructor or move assignment\n    //   operator, the implicitly declared copy constructor is defined as\n    //   deleted.\n    // In MSVC mode, sometimes a declared move assignment does not delete an\n    // implicit copy constructor, so defer this choice to Sema.\n    if (data().UserDeclaredSpecialMembers &\n        (SMF_MoveConstructor | SMF_MoveAssignment))\n      return true;\n    return data().NeedOverloadResolutionForCopyConstructor;\n  }\n\n  /// Determine whether an implicit copy constructor for this type\n  /// would have a parameter with a const-qualified reference type.\n  bool implicitCopyConstructorHasConstParam() const {\n    return data().ImplicitCopyConstructorCanHaveConstParamForNonVBase &&\n           (isAbstract() ||\n            data().ImplicitCopyConstructorCanHaveConstParamForVBase);\n  }\n\n  /// Determine whether this class has a copy constructor with\n  /// a parameter type which is a reference to a const-qualified type.\n  bool hasCopyConstructorWithConstParam() const {\n    return data().HasDeclaredCopyConstructorWithConstParam ||\n           (needsImplicitCopyConstructor() &&\n            implicitCopyConstructorHasConstParam());\n  }\n\n  /// Whether this class has a user-declared move constructor or\n  /// assignment operator.\n  ///\n  /// When false, a move constructor and assignment operator may be\n  /// implicitly declared.\n  bool hasUserDeclaredMoveOperation() const {\n    return data().UserDeclaredSpecialMembers &\n             (SMF_MoveConstructor | SMF_MoveAssignment);\n  }\n\n  /// Determine whether this class has had a move constructor\n  /// declared by the user.\n  bool hasUserDeclaredMoveConstructor() const {\n    return data().UserDeclaredSpecialMembers & SMF_MoveConstructor;\n  }\n\n  /// Determine whether this class has a move constructor.\n  bool hasMoveConstructor() const {\n    return (data().DeclaredSpecialMembers & SMF_MoveConstructor) ||\n           needsImplicitMoveConstructor();\n  }\n\n  /// Set that we attempted to declare an implicit copy\n  /// constructor, but overload resolution failed so we deleted it.\n  void setImplicitCopyConstructorIsDeleted() {\n    assert((data().DefaultedCopyConstructorIsDeleted ||\n            needsOverloadResolutionForCopyConstructor()) &&\n           \"Copy constructor should not be deleted\");\n    data().DefaultedCopyConstructorIsDeleted = true;\n  }\n\n  /// Set that we attempted to declare an implicit move\n  /// constructor, but overload resolution failed so we deleted it.\n  void setImplicitMoveConstructorIsDeleted() {\n    assert((data().DefaultedMoveConstructorIsDeleted ||\n            needsOverloadResolutionForMoveConstructor()) &&\n           \"move constructor should not be deleted\");\n    data().DefaultedMoveConstructorIsDeleted = true;\n  }\n\n  /// Set that we attempted to declare an implicit destructor,\n  /// but overload resolution failed so we deleted it.\n  void setImplicitDestructorIsDeleted() {\n    assert((data().DefaultedDestructorIsDeleted ||\n            needsOverloadResolutionForDestructor()) &&\n           \"destructor should not be deleted\");\n    data().DefaultedDestructorIsDeleted = true;\n  }\n\n  /// Determine whether this class should get an implicit move\n  /// constructor or if any existing special member function inhibits this.\n  bool needsImplicitMoveConstructor() const {\n    return !(data().DeclaredSpecialMembers & SMF_MoveConstructor) &&\n           !hasUserDeclaredCopyConstructor() &&\n           !hasUserDeclaredCopyAssignment() &&\n           !hasUserDeclaredMoveAssignment() &&\n           !hasUserDeclaredDestructor();\n  }\n\n  /// Determine whether we need to eagerly declare a defaulted move\n  /// constructor for this class.\n  bool needsOverloadResolutionForMoveConstructor() const {\n    return data().NeedOverloadResolutionForMoveConstructor;\n  }\n\n  /// Determine whether this class has a user-declared copy assignment\n  /// operator.\n  ///\n  /// When false, a copy assignment operator will be implicitly declared.\n  bool hasUserDeclaredCopyAssignment() const {\n    return data().UserDeclaredSpecialMembers & SMF_CopyAssignment;\n  }\n\n  /// Set that we attempted to declare an implicit copy assignment\n  /// operator, but overload resolution failed so we deleted it.\n  void setImplicitCopyAssignmentIsDeleted() {\n    assert((data().DefaultedCopyAssignmentIsDeleted ||\n            needsOverloadResolutionForCopyAssignment()) &&\n           \"copy assignment should not be deleted\");\n    data().DefaultedCopyAssignmentIsDeleted = true;\n  }\n\n  /// Determine whether this class needs an implicit copy\n  /// assignment operator to be lazily declared.\n  bool needsImplicitCopyAssignment() const {\n    return !(data().DeclaredSpecialMembers & SMF_CopyAssignment);\n  }\n\n  /// Determine whether we need to eagerly declare a defaulted copy\n  /// assignment operator for this class.\n  bool needsOverloadResolutionForCopyAssignment() const {\n    // C++20 [class.copy.assign]p2:\n    //   If the class definition declares a move constructor or move assignment\n    //   operator, the implicitly declared copy assignment operator is defined\n    //   as deleted.\n    // In MSVC mode, sometimes a declared move constructor does not delete an\n    // implicit copy assignment, so defer this choice to Sema.\n    if (data().UserDeclaredSpecialMembers &\n        (SMF_MoveConstructor | SMF_MoveAssignment))\n      return true;\n    return data().NeedOverloadResolutionForCopyAssignment;\n  }\n\n  /// Determine whether an implicit copy assignment operator for this\n  /// type would have a parameter with a const-qualified reference type.\n  bool implicitCopyAssignmentHasConstParam() const {\n    return data().ImplicitCopyAssignmentHasConstParam;\n  }\n\n  /// Determine whether this class has a copy assignment operator with\n  /// a parameter type which is a reference to a const-qualified type or is not\n  /// a reference.\n  bool hasCopyAssignmentWithConstParam() const {\n    return data().HasDeclaredCopyAssignmentWithConstParam ||\n           (needsImplicitCopyAssignment() &&\n            implicitCopyAssignmentHasConstParam());\n  }\n\n  /// Determine whether this class has had a move assignment\n  /// declared by the user.\n  bool hasUserDeclaredMoveAssignment() const {\n    return data().UserDeclaredSpecialMembers & SMF_MoveAssignment;\n  }\n\n  /// Determine whether this class has a move assignment operator.\n  bool hasMoveAssignment() const {\n    return (data().DeclaredSpecialMembers & SMF_MoveAssignment) ||\n           needsImplicitMoveAssignment();\n  }\n\n  /// Set that we attempted to declare an implicit move assignment\n  /// operator, but overload resolution failed so we deleted it.\n  void setImplicitMoveAssignmentIsDeleted() {\n    assert((data().DefaultedMoveAssignmentIsDeleted ||\n            needsOverloadResolutionForMoveAssignment()) &&\n           \"move assignment should not be deleted\");\n    data().DefaultedMoveAssignmentIsDeleted = true;\n  }\n\n  /// Determine whether this class should get an implicit move\n  /// assignment operator or if any existing special member function inhibits\n  /// this.\n  bool needsImplicitMoveAssignment() const {\n    return !(data().DeclaredSpecialMembers & SMF_MoveAssignment) &&\n           !hasUserDeclaredCopyConstructor() &&\n           !hasUserDeclaredCopyAssignment() &&\n           !hasUserDeclaredMoveConstructor() &&\n           !hasUserDeclaredDestructor() &&\n           (!isLambda() || lambdaIsDefaultConstructibleAndAssignable());\n  }\n\n  /// Determine whether we need to eagerly declare a move assignment\n  /// operator for this class.\n  bool needsOverloadResolutionForMoveAssignment() const {\n    return data().NeedOverloadResolutionForMoveAssignment;\n  }\n\n  /// Determine whether this class has a user-declared destructor.\n  ///\n  /// When false, a destructor will be implicitly declared.\n  bool hasUserDeclaredDestructor() const {\n    return data().UserDeclaredSpecialMembers & SMF_Destructor;\n  }\n\n  /// Determine whether this class needs an implicit destructor to\n  /// be lazily declared.\n  bool needsImplicitDestructor() const {\n    return !(data().DeclaredSpecialMembers & SMF_Destructor);\n  }\n\n  /// Determine whether we need to eagerly declare a destructor for this\n  /// class.\n  bool needsOverloadResolutionForDestructor() const {\n    return data().NeedOverloadResolutionForDestructor;\n  }\n\n  /// Determine whether this class describes a lambda function object.\n  bool isLambda() const {\n    // An update record can't turn a non-lambda into a lambda.\n    auto *DD = DefinitionData;\n    return DD && DD->IsLambda;\n  }\n\n  /// Determine whether this class describes a generic\n  /// lambda function object (i.e. function call operator is\n  /// a template).\n  bool isGenericLambda() const;\n\n  /// Determine whether this lambda should have an implicit default constructor\n  /// and copy and move assignment operators.\n  bool lambdaIsDefaultConstructibleAndAssignable() const;\n\n  /// Retrieve the lambda call operator of the closure type\n  /// if this is a closure type.\n  CXXMethodDecl *getLambdaCallOperator() const;\n\n  /// Retrieve the dependent lambda call operator of the closure type\n  /// if this is a templated closure type.\n  FunctionTemplateDecl *getDependentLambdaCallOperator() const;\n\n  /// Retrieve the lambda static invoker, the address of which\n  /// is returned by the conversion operator, and the body of which\n  /// is forwarded to the lambda call operator. The version that does not\n  /// take a calling convention uses the 'default' calling convention for free\n  /// functions if the Lambda's calling convention was not modified via\n  /// attribute. Otherwise, it will return the calling convention specified for\n  /// the lambda.\n  CXXMethodDecl *getLambdaStaticInvoker() const;\n  CXXMethodDecl *getLambdaStaticInvoker(CallingConv CC) const;\n\n  /// Retrieve the generic lambda's template parameter list.\n  /// Returns null if the class does not represent a lambda or a generic\n  /// lambda.\n  TemplateParameterList *getGenericLambdaTemplateParameterList() const;\n\n  /// Retrieve the lambda template parameters that were specified explicitly.\n  ArrayRef<NamedDecl *> getLambdaExplicitTemplateParameters() const;\n\n  LambdaCaptureDefault getLambdaCaptureDefault() const {\n    assert(isLambda());\n    return static_cast<LambdaCaptureDefault>(getLambdaData().CaptureDefault);\n  }\n\n  /// Set the captures for this lambda closure type.\n  void setCaptures(ASTContext &Context, ArrayRef<LambdaCapture> Captures);\n\n  /// For a closure type, retrieve the mapping from captured\n  /// variables and \\c this to the non-static data members that store the\n  /// values or references of the captures.\n  ///\n  /// \\param Captures Will be populated with the mapping from captured\n  /// variables to the corresponding fields.\n  ///\n  /// \\param ThisCapture Will be set to the field declaration for the\n  /// \\c this capture.\n  ///\n  /// \\note No entries will be added for init-captures, as they do not capture\n  /// variables.\n  void getCaptureFields(llvm::DenseMap<const VarDecl *, FieldDecl *> &Captures,\n                        FieldDecl *&ThisCapture) const;\n\n  using capture_const_iterator = const LambdaCapture *;\n  using capture_const_range = llvm::iterator_range<capture_const_iterator>;\n\n  capture_const_range captures() const {\n    return capture_const_range(captures_begin(), captures_end());\n  }\n\n  capture_const_iterator captures_begin() const {\n    return isLambda() ? getLambdaData().Captures : nullptr;\n  }\n\n  capture_const_iterator captures_end() const {\n    return isLambda() ? captures_begin() + getLambdaData().NumCaptures\n                      : nullptr;\n  }\n\n  unsigned capture_size() const { return getLambdaData().NumCaptures; }\n\n  using conversion_iterator = UnresolvedSetIterator;\n\n  conversion_iterator conversion_begin() const {\n    return data().Conversions.get(getASTContext()).begin();\n  }\n\n  conversion_iterator conversion_end() const {\n    return data().Conversions.get(getASTContext()).end();\n  }\n\n  /// Removes a conversion function from this class.  The conversion\n  /// function must currently be a member of this class.  Furthermore,\n  /// this class must currently be in the process of being defined.\n  void removeConversion(const NamedDecl *Old);\n\n  /// Get all conversion functions visible in current class,\n  /// including conversion function templates.\n  llvm::iterator_range<conversion_iterator>\n  getVisibleConversionFunctions() const;\n\n  /// Determine whether this class is an aggregate (C++ [dcl.init.aggr]),\n  /// which is a class with no user-declared constructors, no private\n  /// or protected non-static data members, no base classes, and no virtual\n  /// functions (C++ [dcl.init.aggr]p1).\n  bool isAggregate() const { return data().Aggregate; }\n\n  /// Whether this class has any in-class initializers\n  /// for non-static data members (including those in anonymous unions or\n  /// structs).\n  bool hasInClassInitializer() const { return data().HasInClassInitializer; }\n\n  /// Whether this class or any of its subobjects has any members of\n  /// reference type which would make value-initialization ill-formed.\n  ///\n  /// Per C++03 [dcl.init]p5:\n  ///  - if T is a non-union class type without a user-declared constructor,\n  ///    then every non-static data member and base-class component of T is\n  ///    value-initialized [...] A program that calls for [...]\n  ///    value-initialization of an entity of reference type is ill-formed.\n  bool hasUninitializedReferenceMember() const {\n    return !isUnion() && !hasUserDeclaredConstructor() &&\n           data().HasUninitializedReferenceMember;\n  }\n\n  /// Whether this class is a POD-type (C++ [class]p4)\n  ///\n  /// For purposes of this function a class is POD if it is an aggregate\n  /// that has no non-static non-POD data members, no reference data\n  /// members, no user-defined copy assignment operator and no\n  /// user-defined destructor.\n  ///\n  /// Note that this is the C++ TR1 definition of POD.\n  bool isPOD() const { return data().PlainOldData; }\n\n  /// True if this class is C-like, without C++-specific features, e.g.\n  /// it contains only public fields, no bases, tag kind is not 'class', etc.\n  bool isCLike() const;\n\n  /// Determine whether this is an empty class in the sense of\n  /// (C++11 [meta.unary.prop]).\n  ///\n  /// The CXXRecordDecl is a class type, but not a union type,\n  /// with no non-static data members other than bit-fields of length 0,\n  /// no virtual member functions, no virtual base classes,\n  /// and no base class B for which is_empty<B>::value is false.\n  ///\n  /// \\note This does NOT include a check for union-ness.\n  bool isEmpty() const { return data().Empty; }\n\n  bool hasPrivateFields() const {\n    return data().HasPrivateFields;\n  }\n\n  bool hasProtectedFields() const {\n    return data().HasProtectedFields;\n  }\n\n  /// Determine whether this class has direct non-static data members.\n  bool hasDirectFields() const {\n    auto &D = data();\n    return D.HasPublicFields || D.HasProtectedFields || D.HasPrivateFields;\n  }\n\n  /// Whether this class is polymorphic (C++ [class.virtual]),\n  /// which means that the class contains or inherits a virtual function.\n  bool isPolymorphic() const { return data().Polymorphic; }\n\n  /// Determine whether this class has a pure virtual function.\n  ///\n  /// The class is is abstract per (C++ [class.abstract]p2) if it declares\n  /// a pure virtual function or inherits a pure virtual function that is\n  /// not overridden.\n  bool isAbstract() const { return data().Abstract; }\n\n  /// Determine whether this class is standard-layout per\n  /// C++ [class]p7.\n  bool isStandardLayout() const { return data().IsStandardLayout; }\n\n  /// Determine whether this class was standard-layout per\n  /// C++11 [class]p7, specifically using the C++11 rules without any DRs.\n  bool isCXX11StandardLayout() const { return data().IsCXX11StandardLayout; }\n\n  /// Determine whether this class, or any of its class subobjects,\n  /// contains a mutable field.\n  bool hasMutableFields() const { return data().HasMutableFields; }\n\n  /// Determine whether this class has any variant members.\n  bool hasVariantMembers() const { return data().HasVariantMembers; }\n\n  /// Determine whether this class has a trivial default constructor\n  /// (C++11 [class.ctor]p5).\n  bool hasTrivialDefaultConstructor() const {\n    return hasDefaultConstructor() &&\n           (data().HasTrivialSpecialMembers & SMF_DefaultConstructor);\n  }\n\n  /// Determine whether this class has a non-trivial default constructor\n  /// (C++11 [class.ctor]p5).\n  bool hasNonTrivialDefaultConstructor() const {\n    return (data().DeclaredNonTrivialSpecialMembers & SMF_DefaultConstructor) ||\n           (needsImplicitDefaultConstructor() &&\n            !(data().HasTrivialSpecialMembers & SMF_DefaultConstructor));\n  }\n\n  /// Determine whether this class has at least one constexpr constructor\n  /// other than the copy or move constructors.\n  bool hasConstexprNonCopyMoveConstructor() const {\n    return data().HasConstexprNonCopyMoveConstructor ||\n           (needsImplicitDefaultConstructor() &&\n            defaultedDefaultConstructorIsConstexpr());\n  }\n\n  /// Determine whether a defaulted default constructor for this class\n  /// would be constexpr.\n  bool defaultedDefaultConstructorIsConstexpr() const {\n    return data().DefaultedDefaultConstructorIsConstexpr &&\n           (!isUnion() || hasInClassInitializer() || !hasVariantMembers() ||\n            getLangOpts().CPlusPlus20);\n  }\n\n  /// Determine whether this class has a constexpr default constructor.\n  bool hasConstexprDefaultConstructor() const {\n    return data().HasConstexprDefaultConstructor ||\n           (needsImplicitDefaultConstructor() &&\n            defaultedDefaultConstructorIsConstexpr());\n  }\n\n  /// Determine whether this class has a trivial copy constructor\n  /// (C++ [class.copy]p6, C++11 [class.copy]p12)\n  bool hasTrivialCopyConstructor() const {\n    return data().HasTrivialSpecialMembers & SMF_CopyConstructor;\n  }\n\n  bool hasTrivialCopyConstructorForCall() const {\n    return data().HasTrivialSpecialMembersForCall & SMF_CopyConstructor;\n  }\n\n  /// Determine whether this class has a non-trivial copy constructor\n  /// (C++ [class.copy]p6, C++11 [class.copy]p12)\n  bool hasNonTrivialCopyConstructor() const {\n    return data().DeclaredNonTrivialSpecialMembers & SMF_CopyConstructor ||\n           !hasTrivialCopyConstructor();\n  }\n\n  bool hasNonTrivialCopyConstructorForCall() const {\n    return (data().DeclaredNonTrivialSpecialMembersForCall &\n            SMF_CopyConstructor) ||\n           !hasTrivialCopyConstructorForCall();\n  }\n\n  /// Determine whether this class has a trivial move constructor\n  /// (C++11 [class.copy]p12)\n  bool hasTrivialMoveConstructor() const {\n    return hasMoveConstructor() &&\n           (data().HasTrivialSpecialMembers & SMF_MoveConstructor);\n  }\n\n  bool hasTrivialMoveConstructorForCall() const {\n    return hasMoveConstructor() &&\n           (data().HasTrivialSpecialMembersForCall & SMF_MoveConstructor);\n  }\n\n  /// Determine whether this class has a non-trivial move constructor\n  /// (C++11 [class.copy]p12)\n  bool hasNonTrivialMoveConstructor() const {\n    return (data().DeclaredNonTrivialSpecialMembers & SMF_MoveConstructor) ||\n           (needsImplicitMoveConstructor() &&\n            !(data().HasTrivialSpecialMembers & SMF_MoveConstructor));\n  }\n\n  bool hasNonTrivialMoveConstructorForCall() const {\n    return (data().DeclaredNonTrivialSpecialMembersForCall &\n            SMF_MoveConstructor) ||\n           (needsImplicitMoveConstructor() &&\n            !(data().HasTrivialSpecialMembersForCall & SMF_MoveConstructor));\n  }\n\n  /// Determine whether this class has a trivial copy assignment operator\n  /// (C++ [class.copy]p11, C++11 [class.copy]p25)\n  bool hasTrivialCopyAssignment() const {\n    return data().HasTrivialSpecialMembers & SMF_CopyAssignment;\n  }\n\n  /// Determine whether this class has a non-trivial copy assignment\n  /// operator (C++ [class.copy]p11, C++11 [class.copy]p25)\n  bool hasNonTrivialCopyAssignment() const {\n    return data().DeclaredNonTrivialSpecialMembers & SMF_CopyAssignment ||\n           !hasTrivialCopyAssignment();\n  }\n\n  /// Determine whether this class has a trivial move assignment operator\n  /// (C++11 [class.copy]p25)\n  bool hasTrivialMoveAssignment() const {\n    return hasMoveAssignment() &&\n           (data().HasTrivialSpecialMembers & SMF_MoveAssignment);\n  }\n\n  /// Determine whether this class has a non-trivial move assignment\n  /// operator (C++11 [class.copy]p25)\n  bool hasNonTrivialMoveAssignment() const {\n    return (data().DeclaredNonTrivialSpecialMembers & SMF_MoveAssignment) ||\n           (needsImplicitMoveAssignment() &&\n            !(data().HasTrivialSpecialMembers & SMF_MoveAssignment));\n  }\n\n  /// Determine whether a defaulted default constructor for this class\n  /// would be constexpr.\n  bool defaultedDestructorIsConstexpr() const {\n    return data().DefaultedDestructorIsConstexpr &&\n           getLangOpts().CPlusPlus20;\n  }\n\n  /// Determine whether this class has a constexpr destructor.\n  bool hasConstexprDestructor() const;\n\n  /// Determine whether this class has a trivial destructor\n  /// (C++ [class.dtor]p3)\n  bool hasTrivialDestructor() const {\n    return data().HasTrivialSpecialMembers & SMF_Destructor;\n  }\n\n  bool hasTrivialDestructorForCall() const {\n    return data().HasTrivialSpecialMembersForCall & SMF_Destructor;\n  }\n\n  /// Determine whether this class has a non-trivial destructor\n  /// (C++ [class.dtor]p3)\n  bool hasNonTrivialDestructor() const {\n    return !(data().HasTrivialSpecialMembers & SMF_Destructor);\n  }\n\n  bool hasNonTrivialDestructorForCall() const {\n    return !(data().HasTrivialSpecialMembersForCall & SMF_Destructor);\n  }\n\n  void setHasTrivialSpecialMemberForCall() {\n    data().HasTrivialSpecialMembersForCall =\n        (SMF_CopyConstructor | SMF_MoveConstructor | SMF_Destructor);\n  }\n\n  /// Determine whether declaring a const variable with this type is ok\n  /// per core issue 253.\n  bool allowConstDefaultInit() const {\n    return !data().HasUninitializedFields ||\n           !(data().HasDefaultedDefaultConstructor ||\n             needsImplicitDefaultConstructor());\n  }\n\n  /// Determine whether this class has a destructor which has no\n  /// semantic effect.\n  ///\n  /// Any such destructor will be trivial, public, defaulted and not deleted,\n  /// and will call only irrelevant destructors.\n  bool hasIrrelevantDestructor() const {\n    return data().HasIrrelevantDestructor;\n  }\n\n  /// Determine whether this class has a non-literal or/ volatile type\n  /// non-static data member or base class.\n  bool hasNonLiteralTypeFieldsOrBases() const {\n    return data().HasNonLiteralTypeFieldsOrBases;\n  }\n\n  /// Determine whether this class has a using-declaration that names\n  /// a user-declared base class constructor.\n  bool hasInheritedConstructor() const {\n    return data().HasInheritedConstructor;\n  }\n\n  /// Determine whether this class has a using-declaration that names\n  /// a base class assignment operator.\n  bool hasInheritedAssignment() const {\n    return data().HasInheritedAssignment;\n  }\n\n  /// Determine whether this class is considered trivially copyable per\n  /// (C++11 [class]p6).\n  bool isTriviallyCopyable() const;\n\n  /// Determine whether this class is considered trivial.\n  ///\n  /// C++11 [class]p6:\n  ///    \"A trivial class is a class that has a trivial default constructor and\n  ///    is trivially copyable.\"\n  bool isTrivial() const {\n    return isTriviallyCopyable() && hasTrivialDefaultConstructor();\n  }\n\n  /// Determine whether this class is a literal type.\n  ///\n  /// C++11 [basic.types]p10:\n  ///   A class type that has all the following properties:\n  ///     - it has a trivial destructor\n  ///     - every constructor call and full-expression in the\n  ///       brace-or-equal-intializers for non-static data members (if any) is\n  ///       a constant expression.\n  ///     - it is an aggregate type or has at least one constexpr constructor\n  ///       or constructor template that is not a copy or move constructor, and\n  ///     - all of its non-static data members and base classes are of literal\n  ///       types\n  ///\n  /// We resolve DR1361 by ignoring the second bullet. We resolve DR1452 by\n  /// treating types with trivial default constructors as literal types.\n  ///\n  /// Only in C++17 and beyond, are lambdas literal types.\n  bool isLiteral() const {\n    const LangOptions &LangOpts = getLangOpts();\n    return (LangOpts.CPlusPlus20 ? hasConstexprDestructor()\n                                          : hasTrivialDestructor()) &&\n           (!isLambda() || LangOpts.CPlusPlus17) &&\n           !hasNonLiteralTypeFieldsOrBases() &&\n           (isAggregate() || isLambda() ||\n            hasConstexprNonCopyMoveConstructor() ||\n            hasTrivialDefaultConstructor());\n  }\n\n  /// Determine whether this is a structural type.\n  bool isStructural() const {\n    return isLiteral() && data().StructuralIfLiteral;\n  }\n\n  /// If this record is an instantiation of a member class,\n  /// retrieves the member class from which it was instantiated.\n  ///\n  /// This routine will return non-null for (non-templated) member\n  /// classes of class templates. For example, given:\n  ///\n  /// \\code\n  /// template<typename T>\n  /// struct X {\n  ///   struct A { };\n  /// };\n  /// \\endcode\n  ///\n  /// The declaration for X<int>::A is a (non-templated) CXXRecordDecl\n  /// whose parent is the class template specialization X<int>. For\n  /// this declaration, getInstantiatedFromMemberClass() will return\n  /// the CXXRecordDecl X<T>::A. When a complete definition of\n  /// X<int>::A is required, it will be instantiated from the\n  /// declaration returned by getInstantiatedFromMemberClass().\n  CXXRecordDecl *getInstantiatedFromMemberClass() const;\n\n  /// If this class is an instantiation of a member class of a\n  /// class template specialization, retrieves the member specialization\n  /// information.\n  MemberSpecializationInfo *getMemberSpecializationInfo() const;\n\n  /// Specify that this record is an instantiation of the\n  /// member class \\p RD.\n  void setInstantiationOfMemberClass(CXXRecordDecl *RD,\n                                     TemplateSpecializationKind TSK);\n\n  /// Retrieves the class template that is described by this\n  /// class declaration.\n  ///\n  /// Every class template is represented as a ClassTemplateDecl and a\n  /// CXXRecordDecl. The former contains template properties (such as\n  /// the template parameter lists) while the latter contains the\n  /// actual description of the template's\n  /// contents. ClassTemplateDecl::getTemplatedDecl() retrieves the\n  /// CXXRecordDecl that from a ClassTemplateDecl, while\n  /// getDescribedClassTemplate() retrieves the ClassTemplateDecl from\n  /// a CXXRecordDecl.\n  ClassTemplateDecl *getDescribedClassTemplate() const;\n\n  void setDescribedClassTemplate(ClassTemplateDecl *Template);\n\n  /// Determine whether this particular class is a specialization or\n  /// instantiation of a class template or member class of a class template,\n  /// and how it was instantiated or specialized.\n  TemplateSpecializationKind getTemplateSpecializationKind() const;\n\n  /// Set the kind of specialization or template instantiation this is.\n  void setTemplateSpecializationKind(TemplateSpecializationKind TSK);\n\n  /// Retrieve the record declaration from which this record could be\n  /// instantiated. Returns null if this class is not a template instantiation.\n  const CXXRecordDecl *getTemplateInstantiationPattern() const;\n\n  CXXRecordDecl *getTemplateInstantiationPattern() {\n    return const_cast<CXXRecordDecl *>(const_cast<const CXXRecordDecl *>(this)\n                                           ->getTemplateInstantiationPattern());\n  }\n\n  /// Returns the destructor decl for this class.\n  CXXDestructorDecl *getDestructor() const;\n\n  /// Returns true if the class destructor, or any implicitly invoked\n  /// destructors are marked noreturn.\n  bool isAnyDestructorNoReturn() const;\n\n  /// If the class is a local class [class.local], returns\n  /// the enclosing function declaration.\n  const FunctionDecl *isLocalClass() const {\n    if (const auto *RD = dyn_cast<CXXRecordDecl>(getDeclContext()))\n      return RD->isLocalClass();\n\n    return dyn_cast<FunctionDecl>(getDeclContext());\n  }\n\n  FunctionDecl *isLocalClass() {\n    return const_cast<FunctionDecl*>(\n        const_cast<const CXXRecordDecl*>(this)->isLocalClass());\n  }\n\n  /// Determine whether this dependent class is a current instantiation,\n  /// when viewed from within the given context.\n  bool isCurrentInstantiation(const DeclContext *CurContext) const;\n\n  /// Determine whether this class is derived from the class \\p Base.\n  ///\n  /// This routine only determines whether this class is derived from \\p Base,\n  /// but does not account for factors that may make a Derived -> Base class\n  /// ill-formed, such as private/protected inheritance or multiple, ambiguous\n  /// base class subobjects.\n  ///\n  /// \\param Base the base class we are searching for.\n  ///\n  /// \\returns true if this class is derived from Base, false otherwise.\n  bool isDerivedFrom(const CXXRecordDecl *Base) const;\n\n  /// Determine whether this class is derived from the type \\p Base.\n  ///\n  /// This routine only determines whether this class is derived from \\p Base,\n  /// but does not account for factors that may make a Derived -> Base class\n  /// ill-formed, such as private/protected inheritance or multiple, ambiguous\n  /// base class subobjects.\n  ///\n  /// \\param Base the base class we are searching for.\n  ///\n  /// \\param Paths will contain the paths taken from the current class to the\n  /// given \\p Base class.\n  ///\n  /// \\returns true if this class is derived from \\p Base, false otherwise.\n  ///\n  /// \\todo add a separate parameter to configure IsDerivedFrom, rather than\n  /// tangling input and output in \\p Paths\n  bool isDerivedFrom(const CXXRecordDecl *Base, CXXBasePaths &Paths) const;\n\n  /// Determine whether this class is virtually derived from\n  /// the class \\p Base.\n  ///\n  /// This routine only determines whether this class is virtually\n  /// derived from \\p Base, but does not account for factors that may\n  /// make a Derived -> Base class ill-formed, such as\n  /// private/protected inheritance or multiple, ambiguous base class\n  /// subobjects.\n  ///\n  /// \\param Base the base class we are searching for.\n  ///\n  /// \\returns true if this class is virtually derived from Base,\n  /// false otherwise.\n  bool isVirtuallyDerivedFrom(const CXXRecordDecl *Base) const;\n\n  /// Determine whether this class is provably not derived from\n  /// the type \\p Base.\n  bool isProvablyNotDerivedFrom(const CXXRecordDecl *Base) const;\n\n  /// Function type used by forallBases() as a callback.\n  ///\n  /// \\param BaseDefinition the definition of the base class\n  ///\n  /// \\returns true if this base matched the search criteria\n  using ForallBasesCallback =\n      llvm::function_ref<bool(const CXXRecordDecl *BaseDefinition)>;\n\n  /// Determines if the given callback holds for all the direct\n  /// or indirect base classes of this type.\n  ///\n  /// The class itself does not count as a base class.  This routine\n  /// returns false if the class has non-computable base classes.\n  ///\n  /// \\param BaseMatches Callback invoked for each (direct or indirect) base\n  /// class of this type until a call returns false.\n  bool forallBases(ForallBasesCallback BaseMatches) const;\n\n  /// Function type used by lookupInBases() to determine whether a\n  /// specific base class subobject matches the lookup criteria.\n  ///\n  /// \\param Specifier the base-class specifier that describes the inheritance\n  /// from the base class we are trying to match.\n  ///\n  /// \\param Path the current path, from the most-derived class down to the\n  /// base named by the \\p Specifier.\n  ///\n  /// \\returns true if this base matched the search criteria, false otherwise.\n  using BaseMatchesCallback =\n      llvm::function_ref<bool(const CXXBaseSpecifier *Specifier,\n                              CXXBasePath &Path)>;\n\n  /// Look for entities within the base classes of this C++ class,\n  /// transitively searching all base class subobjects.\n  ///\n  /// This routine uses the callback function \\p BaseMatches to find base\n  /// classes meeting some search criteria, walking all base class subobjects\n  /// and populating the given \\p Paths structure with the paths through the\n  /// inheritance hierarchy that resulted in a match. On a successful search,\n  /// the \\p Paths structure can be queried to retrieve the matching paths and\n  /// to determine if there were any ambiguities.\n  ///\n  /// \\param BaseMatches callback function used to determine whether a given\n  /// base matches the user-defined search criteria.\n  ///\n  /// \\param Paths used to record the paths from this class to its base class\n  /// subobjects that match the search criteria.\n  ///\n  /// \\param LookupInDependent can be set to true to extend the search to\n  /// dependent base classes.\n  ///\n  /// \\returns true if there exists any path from this class to a base class\n  /// subobject that matches the search criteria.\n  bool lookupInBases(BaseMatchesCallback BaseMatches, CXXBasePaths &Paths,\n                     bool LookupInDependent = false) const;\n\n  /// Base-class lookup callback that determines whether the given\n  /// base class specifier refers to a specific class declaration.\n  ///\n  /// This callback can be used with \\c lookupInBases() to determine whether\n  /// a given derived class has is a base class subobject of a particular type.\n  /// The base record pointer should refer to the canonical CXXRecordDecl of the\n  /// base class that we are searching for.\n  static bool FindBaseClass(const CXXBaseSpecifier *Specifier,\n                            CXXBasePath &Path, const CXXRecordDecl *BaseRecord);\n\n  /// Base-class lookup callback that determines whether the\n  /// given base class specifier refers to a specific class\n  /// declaration and describes virtual derivation.\n  ///\n  /// This callback can be used with \\c lookupInBases() to determine\n  /// whether a given derived class has is a virtual base class\n  /// subobject of a particular type.  The base record pointer should\n  /// refer to the canonical CXXRecordDecl of the base class that we\n  /// are searching for.\n  static bool FindVirtualBaseClass(const CXXBaseSpecifier *Specifier,\n                                   CXXBasePath &Path,\n                                   const CXXRecordDecl *BaseRecord);\n\n  /// Retrieve the final overriders for each virtual member\n  /// function in the class hierarchy where this class is the\n  /// most-derived class in the class hierarchy.\n  void getFinalOverriders(CXXFinalOverriderMap &FinaOverriders) const;\n\n  /// Get the indirect primary bases for this class.\n  void getIndirectPrimaryBases(CXXIndirectPrimaryBaseSet& Bases) const;\n\n  /// Determine whether this class has a member with the given name, possibly\n  /// in a non-dependent base class.\n  ///\n  /// No check for ambiguity is performed, so this should never be used when\n  /// implementing language semantics, but it may be appropriate for warnings,\n  /// static analysis, or similar.\n  bool hasMemberName(DeclarationName N) const;\n\n  /// Performs an imprecise lookup of a dependent name in this class.\n  ///\n  /// This function does not follow strict semantic rules and should be used\n  /// only when lookup rules can be relaxed, e.g. indexing.\n  std::vector<const NamedDecl *>\n  lookupDependentName(DeclarationName Name,\n                      llvm::function_ref<bool(const NamedDecl *ND)> Filter);\n\n  /// Renders and displays an inheritance diagram\n  /// for this C++ class and all of its base classes (transitively) using\n  /// GraphViz.\n  void viewInheritance(ASTContext& Context) const;\n\n  /// Calculates the access of a decl that is reached\n  /// along a path.\n  static AccessSpecifier MergeAccess(AccessSpecifier PathAccess,\n                                     AccessSpecifier DeclAccess) {\n    assert(DeclAccess != AS_none);\n    if (DeclAccess == AS_private) return AS_none;\n    return (PathAccess > DeclAccess ? PathAccess : DeclAccess);\n  }\n\n  /// Indicates that the declaration of a defaulted or deleted special\n  /// member function is now complete.\n  void finishedDefaultedOrDeletedMember(CXXMethodDecl *MD);\n\n  void setTrivialForCallFlags(CXXMethodDecl *MD);\n\n  /// Indicates that the definition of this class is now complete.\n  void completeDefinition() override;\n\n  /// Indicates that the definition of this class is now complete,\n  /// and provides a final overrider map to help determine\n  ///\n  /// \\param FinalOverriders The final overrider map for this class, which can\n  /// be provided as an optimization for abstract-class checking. If NULL,\n  /// final overriders will be computed if they are needed to complete the\n  /// definition.\n  void completeDefinition(CXXFinalOverriderMap *FinalOverriders);\n\n  /// Determine whether this class may end up being abstract, even though\n  /// it is not yet known to be abstract.\n  ///\n  /// \\returns true if this class is not known to be abstract but has any\n  /// base classes that are abstract. In this case, \\c completeDefinition()\n  /// will need to compute final overriders to determine whether the class is\n  /// actually abstract.\n  bool mayBeAbstract() const;\n\n  /// Determine whether it's impossible for a class to be derived from this\n  /// class. This is best-effort, and may conservatively return false.\n  bool isEffectivelyFinal() const;\n\n  /// If this is the closure type of a lambda expression, retrieve the\n  /// number to be used for name mangling in the Itanium C++ ABI.\n  ///\n  /// Zero indicates that this closure type has internal linkage, so the\n  /// mangling number does not matter, while a non-zero value indicates which\n  /// lambda expression this is in this particular context.\n  unsigned getLambdaManglingNumber() const {\n    assert(isLambda() && \"Not a lambda closure type!\");\n    return getLambdaData().ManglingNumber;\n  }\n\n  /// The lambda is known to has internal linkage no matter whether it has name\n  /// mangling number.\n  bool hasKnownLambdaInternalLinkage() const {\n    assert(isLambda() && \"Not a lambda closure type!\");\n    return getLambdaData().HasKnownInternalLinkage;\n  }\n\n  /// Retrieve the declaration that provides additional context for a\n  /// lambda, when the normal declaration context is not specific enough.\n  ///\n  /// Certain contexts (default arguments of in-class function parameters and\n  /// the initializers of data members) have separate name mangling rules for\n  /// lambdas within the Itanium C++ ABI. For these cases, this routine provides\n  /// the declaration in which the lambda occurs, e.g., the function parameter\n  /// or the non-static data member. Otherwise, it returns NULL to imply that\n  /// the declaration context suffices.\n  Decl *getLambdaContextDecl() const;\n\n  /// Set the mangling number and context declaration for a lambda\n  /// class.\n  void setLambdaMangling(unsigned ManglingNumber, Decl *ContextDecl,\n                         bool HasKnownInternalLinkage = false) {\n    assert(isLambda() && \"Not a lambda closure type!\");\n    getLambdaData().ManglingNumber = ManglingNumber;\n    getLambdaData().ContextDecl = ContextDecl;\n    getLambdaData().HasKnownInternalLinkage = HasKnownInternalLinkage;\n  }\n\n  /// Set the device side mangling number.\n  void setDeviceLambdaManglingNumber(unsigned Num) const;\n\n  /// Retrieve the device side mangling number.\n  unsigned getDeviceLambdaManglingNumber() const;\n\n  /// Returns the inheritance model used for this record.\n  MSInheritanceModel getMSInheritanceModel() const;\n\n  /// Calculate what the inheritance model would be for this class.\n  MSInheritanceModel calculateInheritanceModel() const;\n\n  /// In the Microsoft C++ ABI, use zero for the field offset of a null data\n  /// member pointer if we can guarantee that zero is not a valid field offset,\n  /// or if the member pointer has multiple fields.  Polymorphic classes have a\n  /// vfptr at offset zero, so we can use zero for null.  If there are multiple\n  /// fields, we can use zero even if it is a valid field offset because\n  /// null-ness testing will check the other fields.\n  bool nullFieldOffsetIsZero() const;\n\n  /// Controls when vtordisps will be emitted if this record is used as a\n  /// virtual base.\n  MSVtorDispMode getMSVtorDispMode() const;\n\n  /// Determine whether this lambda expression was known to be dependent\n  /// at the time it was created, even if its context does not appear to be\n  /// dependent.\n  ///\n  /// This flag is a workaround for an issue with parsing, where default\n  /// arguments are parsed before their enclosing function declarations have\n  /// been created. This means that any lambda expressions within those\n  /// default arguments will have as their DeclContext the context enclosing\n  /// the function declaration, which may be non-dependent even when the\n  /// function declaration itself is dependent. This flag indicates when we\n  /// know that the lambda is dependent despite that.\n  bool isDependentLambda() const {\n    return isLambda() && getLambdaData().Dependent;\n  }\n\n  TypeSourceInfo *getLambdaTypeInfo() const {\n    return getLambdaData().MethodTyInfo;\n  }\n\n  // Determine whether this type is an Interface Like type for\n  // __interface inheritance purposes.\n  bool isInterfaceLike() const;\n\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) {\n    return K >= firstCXXRecord && K <= lastCXXRecord;\n  }\n};\n\n/// Store information needed for an explicit specifier.\n/// Used by CXXDeductionGuideDecl, CXXConstructorDecl and CXXConversionDecl.\nclass ExplicitSpecifier {\n  llvm::PointerIntPair<Expr *, 2, ExplicitSpecKind> ExplicitSpec{\n      nullptr, ExplicitSpecKind::ResolvedFalse};\n\npublic:\n  ExplicitSpecifier() = default;\n  ExplicitSpecifier(Expr *Expression, ExplicitSpecKind Kind)\n      : ExplicitSpec(Expression, Kind) {}\n  ExplicitSpecKind getKind() const { return ExplicitSpec.getInt(); }\n  const Expr *getExpr() const { return ExplicitSpec.getPointer(); }\n  Expr *getExpr() { return ExplicitSpec.getPointer(); }\n\n  /// Determine if the declaration had an explicit specifier of any kind.\n  bool isSpecified() const {\n    return ExplicitSpec.getInt() != ExplicitSpecKind::ResolvedFalse ||\n           ExplicitSpec.getPointer();\n  }\n\n  /// Check for equivalence of explicit specifiers.\n  /// \\return true if the explicit specifier are equivalent, false otherwise.\n  bool isEquivalent(const ExplicitSpecifier Other) const;\n  /// Determine whether this specifier is known to correspond to an explicit\n  /// declaration. Returns false if the specifier is absent or has an\n  /// expression that is value-dependent or evaluates to false.\n  bool isExplicit() const {\n    return ExplicitSpec.getInt() == ExplicitSpecKind::ResolvedTrue;\n  }\n  /// Determine if the explicit specifier is invalid.\n  /// This state occurs after a substitution failures.\n  bool isInvalid() const {\n    return ExplicitSpec.getInt() == ExplicitSpecKind::Unresolved &&\n           !ExplicitSpec.getPointer();\n  }\n  void setKind(ExplicitSpecKind Kind) { ExplicitSpec.setInt(Kind); }\n  void setExpr(Expr *E) { ExplicitSpec.setPointer(E); }\n  // Retrieve the explicit specifier in the given declaration, if any.\n  static ExplicitSpecifier getFromDecl(FunctionDecl *Function);\n  static const ExplicitSpecifier getFromDecl(const FunctionDecl *Function) {\n    return getFromDecl(const_cast<FunctionDecl *>(Function));\n  }\n  static ExplicitSpecifier Invalid() {\n    return ExplicitSpecifier(nullptr, ExplicitSpecKind::Unresolved);\n  }\n};\n\n/// Represents a C++ deduction guide declaration.\n///\n/// \\code\n/// template<typename T> struct A { A(); A(T); };\n/// A() -> A<int>;\n/// \\endcode\n///\n/// In this example, there will be an explicit deduction guide from the\n/// second line, and implicit deduction guide templates synthesized from\n/// the constructors of \\c A.\nclass CXXDeductionGuideDecl : public FunctionDecl {\n  void anchor() override;\n\nprivate:\n  CXXDeductionGuideDecl(ASTContext &C, DeclContext *DC, SourceLocation StartLoc,\n                        ExplicitSpecifier ES,\n                        const DeclarationNameInfo &NameInfo, QualType T,\n                        TypeSourceInfo *TInfo, SourceLocation EndLocation)\n      : FunctionDecl(CXXDeductionGuide, C, DC, StartLoc, NameInfo, T, TInfo,\n                     SC_None, false, ConstexprSpecKind::Unspecified),\n        ExplicitSpec(ES) {\n    if (EndLocation.isValid())\n      setRangeEnd(EndLocation);\n    setIsCopyDeductionCandidate(false);\n  }\n\n  ExplicitSpecifier ExplicitSpec;\n  void setExplicitSpecifier(ExplicitSpecifier ES) { ExplicitSpec = ES; }\n\npublic:\n  friend class ASTDeclReader;\n  friend class ASTDeclWriter;\n\n  static CXXDeductionGuideDecl *\n  Create(ASTContext &C, DeclContext *DC, SourceLocation StartLoc,\n         ExplicitSpecifier ES, const DeclarationNameInfo &NameInfo, QualType T,\n         TypeSourceInfo *TInfo, SourceLocation EndLocation);\n\n  static CXXDeductionGuideDecl *CreateDeserialized(ASTContext &C, unsigned ID);\n\n  ExplicitSpecifier getExplicitSpecifier() { return ExplicitSpec; }\n  const ExplicitSpecifier getExplicitSpecifier() const { return ExplicitSpec; }\n\n  /// Return true if the declartion is already resolved to be explicit.\n  bool isExplicit() const { return ExplicitSpec.isExplicit(); }\n\n  /// Get the template for which this guide performs deduction.\n  TemplateDecl *getDeducedTemplate() const {\n    return getDeclName().getCXXDeductionGuideTemplate();\n  }\n\n  void setIsCopyDeductionCandidate(bool isCDC = true) {\n    FunctionDeclBits.IsCopyDeductionCandidate = isCDC;\n  }\n\n  bool isCopyDeductionCandidate() const {\n    return FunctionDeclBits.IsCopyDeductionCandidate;\n  }\n\n  // Implement isa/cast/dyncast/etc.\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) { return K == CXXDeductionGuide; }\n};\n\n/// \\brief Represents the body of a requires-expression.\n///\n/// This decl exists merely to serve as the DeclContext for the local\n/// parameters of the requires expression as well as other declarations inside\n/// it.\n///\n/// \\code\n/// template<typename T> requires requires (T t) { {t++} -> regular; }\n/// \\endcode\n///\n/// In this example, a RequiresExpr object will be generated for the expression,\n/// and a RequiresExprBodyDecl will be created to hold the parameter t and the\n/// template argument list imposed by the compound requirement.\nclass RequiresExprBodyDecl : public Decl, public DeclContext {\n  RequiresExprBodyDecl(ASTContext &C, DeclContext *DC, SourceLocation StartLoc)\n      : Decl(RequiresExprBody, DC, StartLoc), DeclContext(RequiresExprBody) {}\n\npublic:\n  friend class ASTDeclReader;\n  friend class ASTDeclWriter;\n\n  static RequiresExprBodyDecl *Create(ASTContext &C, DeclContext *DC,\n                                      SourceLocation StartLoc);\n\n  static RequiresExprBodyDecl *CreateDeserialized(ASTContext &C, unsigned ID);\n\n  // Implement isa/cast/dyncast/etc.\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) { return K == RequiresExprBody; }\n};\n\n/// Represents a static or instance method of a struct/union/class.\n///\n/// In the terminology of the C++ Standard, these are the (static and\n/// non-static) member functions, whether virtual or not.\nclass CXXMethodDecl : public FunctionDecl {\n  void anchor() override;\n\nprotected:\n  CXXMethodDecl(Kind DK, ASTContext &C, CXXRecordDecl *RD,\n                SourceLocation StartLoc, const DeclarationNameInfo &NameInfo,\n                QualType T, TypeSourceInfo *TInfo, StorageClass SC,\n                bool isInline, ConstexprSpecKind ConstexprKind,\n                SourceLocation EndLocation,\n                Expr *TrailingRequiresClause = nullptr)\n      : FunctionDecl(DK, C, RD, StartLoc, NameInfo, T, TInfo, SC, isInline,\n                     ConstexprKind, TrailingRequiresClause) {\n    if (EndLocation.isValid())\n      setRangeEnd(EndLocation);\n  }\n\npublic:\n  static CXXMethodDecl *Create(ASTContext &C, CXXRecordDecl *RD,\n                               SourceLocation StartLoc,\n                               const DeclarationNameInfo &NameInfo, QualType T,\n                               TypeSourceInfo *TInfo, StorageClass SC,\n                               bool isInline, ConstexprSpecKind ConstexprKind,\n                               SourceLocation EndLocation,\n                               Expr *TrailingRequiresClause = nullptr);\n\n  static CXXMethodDecl *CreateDeserialized(ASTContext &C, unsigned ID);\n\n  bool isStatic() const;\n  bool isInstance() const { return !isStatic(); }\n\n  /// Returns true if the given operator is implicitly static in a record\n  /// context.\n  static bool isStaticOverloadedOperator(OverloadedOperatorKind OOK) {\n    // [class.free]p1:\n    // Any allocation function for a class T is a static member\n    // (even if not explicitly declared static).\n    // [class.free]p6 Any deallocation function for a class X is a static member\n    // (even if not explicitly declared static).\n    return OOK == OO_New || OOK == OO_Array_New || OOK == OO_Delete ||\n           OOK == OO_Array_Delete;\n  }\n\n  bool isConst() const { return getType()->castAs<FunctionType>()->isConst(); }\n  bool isVolatile() const { return getType()->castAs<FunctionType>()->isVolatile(); }\n\n  bool isVirtual() const {\n    CXXMethodDecl *CD = const_cast<CXXMethodDecl*>(this)->getCanonicalDecl();\n\n    // Member function is virtual if it is marked explicitly so, or if it is\n    // declared in __interface -- then it is automatically pure virtual.\n    if (CD->isVirtualAsWritten() || CD->isPure())\n      return true;\n\n    return CD->size_overridden_methods() != 0;\n  }\n\n  /// If it's possible to devirtualize a call to this method, return the called\n  /// function. Otherwise, return null.\n\n  /// \\param Base The object on which this virtual function is called.\n  /// \\param IsAppleKext True if we are compiling for Apple kext.\n  CXXMethodDecl *getDevirtualizedMethod(const Expr *Base, bool IsAppleKext);\n\n  const CXXMethodDecl *getDevirtualizedMethod(const Expr *Base,\n                                              bool IsAppleKext) const {\n    return const_cast<CXXMethodDecl *>(this)->getDevirtualizedMethod(\n        Base, IsAppleKext);\n  }\n\n  /// Determine whether this is a usual deallocation function (C++\n  /// [basic.stc.dynamic.deallocation]p2), which is an overloaded delete or\n  /// delete[] operator with a particular signature. Populates \\p PreventedBy\n  /// with the declarations of the functions of the same kind if they were the\n  /// reason for this function returning false. This is used by\n  /// Sema::isUsualDeallocationFunction to reconsider the answer based on the\n  /// context.\n  bool isUsualDeallocationFunction(\n      SmallVectorImpl<const FunctionDecl *> &PreventedBy) const;\n\n  /// Determine whether this is a copy-assignment operator, regardless\n  /// of whether it was declared implicitly or explicitly.\n  bool isCopyAssignmentOperator() const;\n\n  /// Determine whether this is a move assignment operator.\n  bool isMoveAssignmentOperator() const;\n\n  CXXMethodDecl *getCanonicalDecl() override {\n    return cast<CXXMethodDecl>(FunctionDecl::getCanonicalDecl());\n  }\n  const CXXMethodDecl *getCanonicalDecl() const {\n    return const_cast<CXXMethodDecl*>(this)->getCanonicalDecl();\n  }\n\n  CXXMethodDecl *getMostRecentDecl() {\n    return cast<CXXMethodDecl>(\n            static_cast<FunctionDecl *>(this)->getMostRecentDecl());\n  }\n  const CXXMethodDecl *getMostRecentDecl() const {\n    return const_cast<CXXMethodDecl*>(this)->getMostRecentDecl();\n  }\n\n  void addOverriddenMethod(const CXXMethodDecl *MD);\n\n  using method_iterator = const CXXMethodDecl *const *;\n\n  method_iterator begin_overridden_methods() const;\n  method_iterator end_overridden_methods() const;\n  unsigned size_overridden_methods() const;\n\n  using overridden_method_range = llvm::iterator_range<\n      llvm::TinyPtrVector<const CXXMethodDecl *>::const_iterator>;\n\n  overridden_method_range overridden_methods() const;\n\n  /// Return the parent of this method declaration, which\n  /// is the class in which this method is defined.\n  const CXXRecordDecl *getParent() const {\n    return cast<CXXRecordDecl>(FunctionDecl::getParent());\n  }\n\n  /// Return the parent of this method declaration, which\n  /// is the class in which this method is defined.\n  CXXRecordDecl *getParent() {\n    return const_cast<CXXRecordDecl *>(\n             cast<CXXRecordDecl>(FunctionDecl::getParent()));\n  }\n\n  /// Return the type of the \\c this pointer.\n  ///\n  /// Should only be called for instance (i.e., non-static) methods. Note\n  /// that for the call operator of a lambda closure type, this returns the\n  /// desugared 'this' type (a pointer to the closure type), not the captured\n  /// 'this' type.\n  QualType getThisType() const;\n\n  /// Return the type of the object pointed by \\c this.\n  ///\n  /// See getThisType() for usage restriction.\n  QualType getThisObjectType() const;\n\n  static QualType getThisType(const FunctionProtoType *FPT,\n                              const CXXRecordDecl *Decl);\n\n  static QualType getThisObjectType(const FunctionProtoType *FPT,\n                                    const CXXRecordDecl *Decl);\n\n  Qualifiers getMethodQualifiers() const {\n    return getType()->castAs<FunctionProtoType>()->getMethodQuals();\n  }\n\n  /// Retrieve the ref-qualifier associated with this method.\n  ///\n  /// In the following example, \\c f() has an lvalue ref-qualifier, \\c g()\n  /// has an rvalue ref-qualifier, and \\c h() has no ref-qualifier.\n  /// @code\n  /// struct X {\n  ///   void f() &;\n  ///   void g() &&;\n  ///   void h();\n  /// };\n  /// @endcode\n  RefQualifierKind getRefQualifier() const {\n    return getType()->castAs<FunctionProtoType>()->getRefQualifier();\n  }\n\n  bool hasInlineBody() const;\n\n  /// Determine whether this is a lambda closure type's static member\n  /// function that is used for the result of the lambda's conversion to\n  /// function pointer (for a lambda with no captures).\n  ///\n  /// The function itself, if used, will have a placeholder body that will be\n  /// supplied by IR generation to either forward to the function call operator\n  /// or clone the function call operator.\n  bool isLambdaStaticInvoker() const;\n\n  /// Find the method in \\p RD that corresponds to this one.\n  ///\n  /// Find if \\p RD or one of the classes it inherits from override this method.\n  /// If so, return it. \\p RD is assumed to be a subclass of the class defining\n  /// this method (or be the class itself), unless \\p MayBeBase is set to true.\n  CXXMethodDecl *\n  getCorrespondingMethodInClass(const CXXRecordDecl *RD,\n                                bool MayBeBase = false);\n\n  const CXXMethodDecl *\n  getCorrespondingMethodInClass(const CXXRecordDecl *RD,\n                                bool MayBeBase = false) const {\n    return const_cast<CXXMethodDecl *>(this)\n              ->getCorrespondingMethodInClass(RD, MayBeBase);\n  }\n\n  /// Find if \\p RD declares a function that overrides this function, and if so,\n  /// return it. Does not search base classes.\n  CXXMethodDecl *getCorrespondingMethodDeclaredInClass(const CXXRecordDecl *RD,\n                                                       bool MayBeBase = false);\n  const CXXMethodDecl *\n  getCorrespondingMethodDeclaredInClass(const CXXRecordDecl *RD,\n                                        bool MayBeBase = false) const {\n    return const_cast<CXXMethodDecl *>(this)\n        ->getCorrespondingMethodDeclaredInClass(RD, MayBeBase);\n  }\n\n  // Implement isa/cast/dyncast/etc.\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) {\n    return K >= firstCXXMethod && K <= lastCXXMethod;\n  }\n};\n\n/// Represents a C++ base or member initializer.\n///\n/// This is part of a constructor initializer that\n/// initializes one non-static member variable or one base class. For\n/// example, in the following, both 'A(a)' and 'f(3.14159)' are member\n/// initializers:\n///\n/// \\code\n/// class A { };\n/// class B : public A {\n///   float f;\n/// public:\n///   B(A& a) : A(a), f(3.14159) { }\n/// };\n/// \\endcode\nclass CXXCtorInitializer final {\n  /// Either the base class name/delegating constructor type (stored as\n  /// a TypeSourceInfo*), an normal field (FieldDecl), or an anonymous field\n  /// (IndirectFieldDecl*) being initialized.\n  llvm::PointerUnion<TypeSourceInfo *, FieldDecl *, IndirectFieldDecl *>\n      Initializee;\n\n  /// The argument used to initialize the base or member, which may\n  /// end up constructing an object (when multiple arguments are involved).\n  Stmt *Init;\n\n  /// The source location for the field name or, for a base initializer\n  /// pack expansion, the location of the ellipsis.\n  ///\n  /// In the case of a delegating\n  /// constructor, it will still include the type's source location as the\n  /// Initializee points to the CXXConstructorDecl (to allow loop detection).\n  SourceLocation MemberOrEllipsisLocation;\n\n  /// Location of the left paren of the ctor-initializer.\n  SourceLocation LParenLoc;\n\n  /// Location of the right paren of the ctor-initializer.\n  SourceLocation RParenLoc;\n\n  /// If the initializee is a type, whether that type makes this\n  /// a delegating initialization.\n  unsigned IsDelegating : 1;\n\n  /// If the initializer is a base initializer, this keeps track\n  /// of whether the base is virtual or not.\n  unsigned IsVirtual : 1;\n\n  /// Whether or not the initializer is explicitly written\n  /// in the sources.\n  unsigned IsWritten : 1;\n\n  /// If IsWritten is true, then this number keeps track of the textual order\n  /// of this initializer in the original sources, counting from 0.\n  unsigned SourceOrder : 13;\n\npublic:\n  /// Creates a new base-class initializer.\n  explicit\n  CXXCtorInitializer(ASTContext &Context, TypeSourceInfo *TInfo, bool IsVirtual,\n                     SourceLocation L, Expr *Init, SourceLocation R,\n                     SourceLocation EllipsisLoc);\n\n  /// Creates a new member initializer.\n  explicit\n  CXXCtorInitializer(ASTContext &Context, FieldDecl *Member,\n                     SourceLocation MemberLoc, SourceLocation L, Expr *Init,\n                     SourceLocation R);\n\n  /// Creates a new anonymous field initializer.\n  explicit\n  CXXCtorInitializer(ASTContext &Context, IndirectFieldDecl *Member,\n                     SourceLocation MemberLoc, SourceLocation L, Expr *Init,\n                     SourceLocation R);\n\n  /// Creates a new delegating initializer.\n  explicit\n  CXXCtorInitializer(ASTContext &Context, TypeSourceInfo *TInfo,\n                     SourceLocation L, Expr *Init, SourceLocation R);\n\n  /// \\return Unique reproducible object identifier.\n  int64_t getID(const ASTContext &Context) const;\n\n  /// Determine whether this initializer is initializing a base class.\n  bool isBaseInitializer() const {\n    return Initializee.is<TypeSourceInfo*>() && !IsDelegating;\n  }\n\n  /// Determine whether this initializer is initializing a non-static\n  /// data member.\n  bool isMemberInitializer() const { return Initializee.is<FieldDecl*>(); }\n\n  bool isAnyMemberInitializer() const {\n    return isMemberInitializer() || isIndirectMemberInitializer();\n  }\n\n  bool isIndirectMemberInitializer() const {\n    return Initializee.is<IndirectFieldDecl*>();\n  }\n\n  /// Determine whether this initializer is an implicit initializer\n  /// generated for a field with an initializer defined on the member\n  /// declaration.\n  ///\n  /// In-class member initializers (also known as \"non-static data member\n  /// initializations\", NSDMIs) were introduced in C++11.\n  bool isInClassMemberInitializer() const {\n    return Init->getStmtClass() == Stmt::CXXDefaultInitExprClass;\n  }\n\n  /// Determine whether this initializer is creating a delegating\n  /// constructor.\n  bool isDelegatingInitializer() const {\n    return Initializee.is<TypeSourceInfo*>() && IsDelegating;\n  }\n\n  /// Determine whether this initializer is a pack expansion.\n  bool isPackExpansion() const {\n    return isBaseInitializer() && MemberOrEllipsisLocation.isValid();\n  }\n\n  // For a pack expansion, returns the location of the ellipsis.\n  SourceLocation getEllipsisLoc() const {\n    assert(isPackExpansion() && \"Initializer is not a pack expansion\");\n    return MemberOrEllipsisLocation;\n  }\n\n  /// If this is a base class initializer, returns the type of the\n  /// base class with location information. Otherwise, returns an NULL\n  /// type location.\n  TypeLoc getBaseClassLoc() const;\n\n  /// If this is a base class initializer, returns the type of the base class.\n  /// Otherwise, returns null.\n  const Type *getBaseClass() const;\n\n  /// Returns whether the base is virtual or not.\n  bool isBaseVirtual() const {\n    assert(isBaseInitializer() && \"Must call this on base initializer!\");\n\n    return IsVirtual;\n  }\n\n  /// Returns the declarator information for a base class or delegating\n  /// initializer.\n  TypeSourceInfo *getTypeSourceInfo() const {\n    return Initializee.dyn_cast<TypeSourceInfo *>();\n  }\n\n  /// If this is a member initializer, returns the declaration of the\n  /// non-static data member being initialized. Otherwise, returns null.\n  FieldDecl *getMember() const {\n    if (isMemberInitializer())\n      return Initializee.get<FieldDecl*>();\n    return nullptr;\n  }\n\n  FieldDecl *getAnyMember() const {\n    if (isMemberInitializer())\n      return Initializee.get<FieldDecl*>();\n    if (isIndirectMemberInitializer())\n      return Initializee.get<IndirectFieldDecl*>()->getAnonField();\n    return nullptr;\n  }\n\n  IndirectFieldDecl *getIndirectMember() const {\n    if (isIndirectMemberInitializer())\n      return Initializee.get<IndirectFieldDecl*>();\n    return nullptr;\n  }\n\n  SourceLocation getMemberLocation() const {\n    return MemberOrEllipsisLocation;\n  }\n\n  /// Determine the source location of the initializer.\n  SourceLocation getSourceLocation() const;\n\n  /// Determine the source range covering the entire initializer.\n  SourceRange getSourceRange() const LLVM_READONLY;\n\n  /// Determine whether this initializer is explicitly written\n  /// in the source code.\n  bool isWritten() const { return IsWritten; }\n\n  /// Return the source position of the initializer, counting from 0.\n  /// If the initializer was implicit, -1 is returned.\n  int getSourceOrder() const {\n    return IsWritten ? static_cast<int>(SourceOrder) : -1;\n  }\n\n  /// Set the source order of this initializer.\n  ///\n  /// This can only be called once for each initializer; it cannot be called\n  /// on an initializer having a positive number of (implicit) array indices.\n  ///\n  /// This assumes that the initializer was written in the source code, and\n  /// ensures that isWritten() returns true.\n  void setSourceOrder(int Pos) {\n    assert(!IsWritten &&\n           \"setSourceOrder() used on implicit initializer\");\n    assert(SourceOrder == 0 &&\n           \"calling twice setSourceOrder() on the same initializer\");\n    assert(Pos >= 0 &&\n           \"setSourceOrder() used to make an initializer implicit\");\n    IsWritten = true;\n    SourceOrder = static_cast<unsigned>(Pos);\n  }\n\n  SourceLocation getLParenLoc() const { return LParenLoc; }\n  SourceLocation getRParenLoc() const { return RParenLoc; }\n\n  /// Get the initializer.\n  Expr *getInit() const { return static_cast<Expr *>(Init); }\n};\n\n/// Description of a constructor that was inherited from a base class.\nclass InheritedConstructor {\n  ConstructorUsingShadowDecl *Shadow = nullptr;\n  CXXConstructorDecl *BaseCtor = nullptr;\n\npublic:\n  InheritedConstructor() = default;\n  InheritedConstructor(ConstructorUsingShadowDecl *Shadow,\n                       CXXConstructorDecl *BaseCtor)\n      : Shadow(Shadow), BaseCtor(BaseCtor) {}\n\n  explicit operator bool() const { return Shadow; }\n\n  ConstructorUsingShadowDecl *getShadowDecl() const { return Shadow; }\n  CXXConstructorDecl *getConstructor() const { return BaseCtor; }\n};\n\n/// Represents a C++ constructor within a class.\n///\n/// For example:\n///\n/// \\code\n/// class X {\n/// public:\n///   explicit X(int); // represented by a CXXConstructorDecl.\n/// };\n/// \\endcode\nclass CXXConstructorDecl final\n    : public CXXMethodDecl,\n      private llvm::TrailingObjects<CXXConstructorDecl, InheritedConstructor,\n                                    ExplicitSpecifier> {\n  // This class stores some data in DeclContext::CXXConstructorDeclBits\n  // to save some space. Use the provided accessors to access it.\n\n  /// \\name Support for base and member initializers.\n  /// \\{\n  /// The arguments used to initialize the base or member.\n  LazyCXXCtorInitializersPtr CtorInitializers;\n\n  CXXConstructorDecl(ASTContext &C, CXXRecordDecl *RD, SourceLocation StartLoc,\n                     const DeclarationNameInfo &NameInfo, QualType T,\n                     TypeSourceInfo *TInfo, ExplicitSpecifier ES, bool isInline,\n                     bool isImplicitlyDeclared, ConstexprSpecKind ConstexprKind,\n                     InheritedConstructor Inherited,\n                     Expr *TrailingRequiresClause);\n\n  void anchor() override;\n\n  size_t numTrailingObjects(OverloadToken<InheritedConstructor>) const {\n    return CXXConstructorDeclBits.IsInheritingConstructor;\n  }\n  size_t numTrailingObjects(OverloadToken<ExplicitSpecifier>) const {\n    return CXXConstructorDeclBits.HasTrailingExplicitSpecifier;\n  }\n\n  ExplicitSpecifier getExplicitSpecifierInternal() const {\n    if (CXXConstructorDeclBits.HasTrailingExplicitSpecifier)\n      return *getTrailingObjects<ExplicitSpecifier>();\n    return ExplicitSpecifier(\n        nullptr, CXXConstructorDeclBits.IsSimpleExplicit\n                     ? ExplicitSpecKind::ResolvedTrue\n                     : ExplicitSpecKind::ResolvedFalse);\n  }\n\n  enum TraillingAllocKind {\n    TAKInheritsConstructor = 1,\n    TAKHasTailExplicit = 1 << 1,\n  };\n\n  uint64_t getTraillingAllocKind() const {\n    return numTrailingObjects(OverloadToken<InheritedConstructor>()) |\n           (numTrailingObjects(OverloadToken<ExplicitSpecifier>()) << 1);\n  }\n\npublic:\n  friend class ASTDeclReader;\n  friend class ASTDeclWriter;\n  friend TrailingObjects;\n\n  static CXXConstructorDecl *CreateDeserialized(ASTContext &C, unsigned ID,\n                                                uint64_t AllocKind);\n  static CXXConstructorDecl *\n  Create(ASTContext &C, CXXRecordDecl *RD, SourceLocation StartLoc,\n         const DeclarationNameInfo &NameInfo, QualType T, TypeSourceInfo *TInfo,\n         ExplicitSpecifier ES, bool isInline, bool isImplicitlyDeclared,\n         ConstexprSpecKind ConstexprKind,\n         InheritedConstructor Inherited = InheritedConstructor(),\n         Expr *TrailingRequiresClause = nullptr);\n\n  void setExplicitSpecifier(ExplicitSpecifier ES) {\n    assert((!ES.getExpr() ||\n            CXXConstructorDeclBits.HasTrailingExplicitSpecifier) &&\n           \"cannot set this explicit specifier. no trail-allocated space for \"\n           \"explicit\");\n    if (ES.getExpr())\n      *getCanonicalDecl()->getTrailingObjects<ExplicitSpecifier>() = ES;\n    else\n      CXXConstructorDeclBits.IsSimpleExplicit = ES.isExplicit();\n  }\n\n  ExplicitSpecifier getExplicitSpecifier() {\n    return getCanonicalDecl()->getExplicitSpecifierInternal();\n  }\n  const ExplicitSpecifier getExplicitSpecifier() const {\n    return getCanonicalDecl()->getExplicitSpecifierInternal();\n  }\n\n  /// Return true if the declartion is already resolved to be explicit.\n  bool isExplicit() const { return getExplicitSpecifier().isExplicit(); }\n\n  /// Iterates through the member/base initializer list.\n  using init_iterator = CXXCtorInitializer **;\n\n  /// Iterates through the member/base initializer list.\n  using init_const_iterator = CXXCtorInitializer *const *;\n\n  using init_range = llvm::iterator_range<init_iterator>;\n  using init_const_range = llvm::iterator_range<init_const_iterator>;\n\n  init_range inits() { return init_range(init_begin(), init_end()); }\n  init_const_range inits() const {\n    return init_const_range(init_begin(), init_end());\n  }\n\n  /// Retrieve an iterator to the first initializer.\n  init_iterator init_begin() {\n    const auto *ConstThis = this;\n    return const_cast<init_iterator>(ConstThis->init_begin());\n  }\n\n  /// Retrieve an iterator to the first initializer.\n  init_const_iterator init_begin() const;\n\n  /// Retrieve an iterator past the last initializer.\n  init_iterator       init_end()       {\n    return init_begin() + getNumCtorInitializers();\n  }\n\n  /// Retrieve an iterator past the last initializer.\n  init_const_iterator init_end() const {\n    return init_begin() + getNumCtorInitializers();\n  }\n\n  using init_reverse_iterator = std::reverse_iterator<init_iterator>;\n  using init_const_reverse_iterator =\n      std::reverse_iterator<init_const_iterator>;\n\n  init_reverse_iterator init_rbegin() {\n    return init_reverse_iterator(init_end());\n  }\n  init_const_reverse_iterator init_rbegin() const {\n    return init_const_reverse_iterator(init_end());\n  }\n\n  init_reverse_iterator init_rend() {\n    return init_reverse_iterator(init_begin());\n  }\n  init_const_reverse_iterator init_rend() const {\n    return init_const_reverse_iterator(init_begin());\n  }\n\n  /// Determine the number of arguments used to initialize the member\n  /// or base.\n  unsigned getNumCtorInitializers() const {\n      return CXXConstructorDeclBits.NumCtorInitializers;\n  }\n\n  void setNumCtorInitializers(unsigned numCtorInitializers) {\n    CXXConstructorDeclBits.NumCtorInitializers = numCtorInitializers;\n    // This assert added because NumCtorInitializers is stored\n    // in CXXConstructorDeclBits as a bitfield and its width has\n    // been shrunk from 32 bits to fit into CXXConstructorDeclBitfields.\n    assert(CXXConstructorDeclBits.NumCtorInitializers ==\n           numCtorInitializers && \"NumCtorInitializers overflow!\");\n  }\n\n  void setCtorInitializers(CXXCtorInitializer **Initializers) {\n    CtorInitializers = Initializers;\n  }\n\n  /// Determine whether this constructor is a delegating constructor.\n  bool isDelegatingConstructor() const {\n    return (getNumCtorInitializers() == 1) &&\n           init_begin()[0]->isDelegatingInitializer();\n  }\n\n  /// When this constructor delegates to another, retrieve the target.\n  CXXConstructorDecl *getTargetConstructor() const;\n\n  /// Whether this constructor is a default\n  /// constructor (C++ [class.ctor]p5), which can be used to\n  /// default-initialize a class of this type.\n  bool isDefaultConstructor() const;\n\n  /// Whether this constructor is a copy constructor (C++ [class.copy]p2,\n  /// which can be used to copy the class.\n  ///\n  /// \\p TypeQuals will be set to the qualifiers on the\n  /// argument type. For example, \\p TypeQuals would be set to \\c\n  /// Qualifiers::Const for the following copy constructor:\n  ///\n  /// \\code\n  /// class X {\n  /// public:\n  ///   X(const X&);\n  /// };\n  /// \\endcode\n  bool isCopyConstructor(unsigned &TypeQuals) const;\n\n  /// Whether this constructor is a copy\n  /// constructor (C++ [class.copy]p2, which can be used to copy the\n  /// class.\n  bool isCopyConstructor() const {\n    unsigned TypeQuals = 0;\n    return isCopyConstructor(TypeQuals);\n  }\n\n  /// Determine whether this constructor is a move constructor\n  /// (C++11 [class.copy]p3), which can be used to move values of the class.\n  ///\n  /// \\param TypeQuals If this constructor is a move constructor, will be set\n  /// to the type qualifiers on the referent of the first parameter's type.\n  bool isMoveConstructor(unsigned &TypeQuals) const;\n\n  /// Determine whether this constructor is a move constructor\n  /// (C++11 [class.copy]p3), which can be used to move values of the class.\n  bool isMoveConstructor() const {\n    unsigned TypeQuals = 0;\n    return isMoveConstructor(TypeQuals);\n  }\n\n  /// Determine whether this is a copy or move constructor.\n  ///\n  /// \\param TypeQuals Will be set to the type qualifiers on the reference\n  /// parameter, if in fact this is a copy or move constructor.\n  bool isCopyOrMoveConstructor(unsigned &TypeQuals) const;\n\n  /// Determine whether this a copy or move constructor.\n  bool isCopyOrMoveConstructor() const {\n    unsigned Quals;\n    return isCopyOrMoveConstructor(Quals);\n  }\n\n  /// Whether this constructor is a\n  /// converting constructor (C++ [class.conv.ctor]), which can be\n  /// used for user-defined conversions.\n  bool isConvertingConstructor(bool AllowExplicit) const;\n\n  /// Determine whether this is a member template specialization that\n  /// would copy the object to itself. Such constructors are never used to copy\n  /// an object.\n  bool isSpecializationCopyingObject() const;\n\n  /// Determine whether this is an implicit constructor synthesized to\n  /// model a call to a constructor inherited from a base class.\n  bool isInheritingConstructor() const {\n    return CXXConstructorDeclBits.IsInheritingConstructor;\n  }\n\n  /// State that this is an implicit constructor synthesized to\n  /// model a call to a constructor inherited from a base class.\n  void setInheritingConstructor(bool isIC = true) {\n    CXXConstructorDeclBits.IsInheritingConstructor = isIC;\n  }\n\n  /// Get the constructor that this inheriting constructor is based on.\n  InheritedConstructor getInheritedConstructor() const {\n    return isInheritingConstructor() ?\n      *getTrailingObjects<InheritedConstructor>() : InheritedConstructor();\n  }\n\n  CXXConstructorDecl *getCanonicalDecl() override {\n    return cast<CXXConstructorDecl>(FunctionDecl::getCanonicalDecl());\n  }\n  const CXXConstructorDecl *getCanonicalDecl() const {\n    return const_cast<CXXConstructorDecl*>(this)->getCanonicalDecl();\n  }\n\n  // Implement isa/cast/dyncast/etc.\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) { return K == CXXConstructor; }\n};\n\n/// Represents a C++ destructor within a class.\n///\n/// For example:\n///\n/// \\code\n/// class X {\n/// public:\n///   ~X(); // represented by a CXXDestructorDecl.\n/// };\n/// \\endcode\nclass CXXDestructorDecl : public CXXMethodDecl {\n  friend class ASTDeclReader;\n  friend class ASTDeclWriter;\n\n  // FIXME: Don't allocate storage for these except in the first declaration\n  // of a virtual destructor.\n  FunctionDecl *OperatorDelete = nullptr;\n  Expr *OperatorDeleteThisArg = nullptr;\n\n  CXXDestructorDecl(ASTContext &C, CXXRecordDecl *RD, SourceLocation StartLoc,\n                    const DeclarationNameInfo &NameInfo, QualType T,\n                    TypeSourceInfo *TInfo, bool isInline,\n                    bool isImplicitlyDeclared, ConstexprSpecKind ConstexprKind,\n                    Expr *TrailingRequiresClause = nullptr)\n      : CXXMethodDecl(CXXDestructor, C, RD, StartLoc, NameInfo, T, TInfo,\n                      SC_None, isInline, ConstexprKind, SourceLocation(),\n                      TrailingRequiresClause) {\n    setImplicit(isImplicitlyDeclared);\n  }\n\n  void anchor() override;\n\npublic:\n  static CXXDestructorDecl *Create(ASTContext &C, CXXRecordDecl *RD,\n                                   SourceLocation StartLoc,\n                                   const DeclarationNameInfo &NameInfo,\n                                   QualType T, TypeSourceInfo *TInfo,\n                                   bool isInline, bool isImplicitlyDeclared,\n                                   ConstexprSpecKind ConstexprKind,\n                                   Expr *TrailingRequiresClause = nullptr);\n  static CXXDestructorDecl *CreateDeserialized(ASTContext & C, unsigned ID);\n\n  void setOperatorDelete(FunctionDecl *OD, Expr *ThisArg);\n\n  const FunctionDecl *getOperatorDelete() const {\n    return getCanonicalDecl()->OperatorDelete;\n  }\n\n  Expr *getOperatorDeleteThisArg() const {\n    return getCanonicalDecl()->OperatorDeleteThisArg;\n  }\n\n  CXXDestructorDecl *getCanonicalDecl() override {\n    return cast<CXXDestructorDecl>(FunctionDecl::getCanonicalDecl());\n  }\n  const CXXDestructorDecl *getCanonicalDecl() const {\n    return const_cast<CXXDestructorDecl*>(this)->getCanonicalDecl();\n  }\n\n  // Implement isa/cast/dyncast/etc.\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) { return K == CXXDestructor; }\n};\n\n/// Represents a C++ conversion function within a class.\n///\n/// For example:\n///\n/// \\code\n/// class X {\n/// public:\n///   operator bool();\n/// };\n/// \\endcode\nclass CXXConversionDecl : public CXXMethodDecl {\n  CXXConversionDecl(ASTContext &C, CXXRecordDecl *RD, SourceLocation StartLoc,\n                    const DeclarationNameInfo &NameInfo, QualType T,\n                    TypeSourceInfo *TInfo, bool isInline, ExplicitSpecifier ES,\n                    ConstexprSpecKind ConstexprKind, SourceLocation EndLocation,\n                    Expr *TrailingRequiresClause = nullptr)\n      : CXXMethodDecl(CXXConversion, C, RD, StartLoc, NameInfo, T, TInfo,\n                      SC_None, isInline, ConstexprKind, EndLocation,\n                      TrailingRequiresClause),\n        ExplicitSpec(ES) {}\n  void anchor() override;\n\n  ExplicitSpecifier ExplicitSpec;\n\npublic:\n  friend class ASTDeclReader;\n  friend class ASTDeclWriter;\n\n  static CXXConversionDecl *\n  Create(ASTContext &C, CXXRecordDecl *RD, SourceLocation StartLoc,\n         const DeclarationNameInfo &NameInfo, QualType T, TypeSourceInfo *TInfo,\n         bool isInline, ExplicitSpecifier ES, ConstexprSpecKind ConstexprKind,\n         SourceLocation EndLocation, Expr *TrailingRequiresClause = nullptr);\n  static CXXConversionDecl *CreateDeserialized(ASTContext &C, unsigned ID);\n\n  ExplicitSpecifier getExplicitSpecifier() {\n    return getCanonicalDecl()->ExplicitSpec;\n  }\n\n  const ExplicitSpecifier getExplicitSpecifier() const {\n    return getCanonicalDecl()->ExplicitSpec;\n  }\n\n  /// Return true if the declartion is already resolved to be explicit.\n  bool isExplicit() const { return getExplicitSpecifier().isExplicit(); }\n  void setExplicitSpecifier(ExplicitSpecifier ES) { ExplicitSpec = ES; }\n\n  /// Returns the type that this conversion function is converting to.\n  QualType getConversionType() const {\n    return getType()->castAs<FunctionType>()->getReturnType();\n  }\n\n  /// Determine whether this conversion function is a conversion from\n  /// a lambda closure type to a block pointer.\n  bool isLambdaToBlockPointerConversion() const;\n\n  CXXConversionDecl *getCanonicalDecl() override {\n    return cast<CXXConversionDecl>(FunctionDecl::getCanonicalDecl());\n  }\n  const CXXConversionDecl *getCanonicalDecl() const {\n    return const_cast<CXXConversionDecl*>(this)->getCanonicalDecl();\n  }\n\n  // Implement isa/cast/dyncast/etc.\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) { return K == CXXConversion; }\n};\n\n/// Represents a linkage specification.\n///\n/// For example:\n/// \\code\n///   extern \"C\" void foo();\n/// \\endcode\nclass LinkageSpecDecl : public Decl, public DeclContext {\n  virtual void anchor();\n  // This class stores some data in DeclContext::LinkageSpecDeclBits to save\n  // some space. Use the provided accessors to access it.\npublic:\n  /// Represents the language in a linkage specification.\n  ///\n  /// The values are part of the serialization ABI for\n  /// ASTs and cannot be changed without altering that ABI.\n  enum LanguageIDs { lang_c = 1, lang_cxx = 2 };\n\nprivate:\n  /// The source location for the extern keyword.\n  SourceLocation ExternLoc;\n\n  /// The source location for the right brace (if valid).\n  SourceLocation RBraceLoc;\n\n  LinkageSpecDecl(DeclContext *DC, SourceLocation ExternLoc,\n                  SourceLocation LangLoc, LanguageIDs lang, bool HasBraces);\n\npublic:\n  static LinkageSpecDecl *Create(ASTContext &C, DeclContext *DC,\n                                 SourceLocation ExternLoc,\n                                 SourceLocation LangLoc, LanguageIDs Lang,\n                                 bool HasBraces);\n  static LinkageSpecDecl *CreateDeserialized(ASTContext &C, unsigned ID);\n\n  /// Return the language specified by this linkage specification.\n  LanguageIDs getLanguage() const {\n    return static_cast<LanguageIDs>(LinkageSpecDeclBits.Language);\n  }\n\n  /// Set the language specified by this linkage specification.\n  void setLanguage(LanguageIDs L) { LinkageSpecDeclBits.Language = L; }\n\n  /// Determines whether this linkage specification had braces in\n  /// its syntactic form.\n  bool hasBraces() const {\n    assert(!RBraceLoc.isValid() || LinkageSpecDeclBits.HasBraces);\n    return LinkageSpecDeclBits.HasBraces;\n  }\n\n  SourceLocation getExternLoc() const { return ExternLoc; }\n  SourceLocation getRBraceLoc() const { return RBraceLoc; }\n  void setExternLoc(SourceLocation L) { ExternLoc = L; }\n  void setRBraceLoc(SourceLocation L) {\n    RBraceLoc = L;\n    LinkageSpecDeclBits.HasBraces = RBraceLoc.isValid();\n  }\n\n  SourceLocation getEndLoc() const LLVM_READONLY {\n    if (hasBraces())\n      return getRBraceLoc();\n    // No braces: get the end location of the (only) declaration in context\n    // (if present).\n    return decls_empty() ? getLocation() : decls_begin()->getEndLoc();\n  }\n\n  SourceRange getSourceRange() const override LLVM_READONLY {\n    return SourceRange(ExternLoc, getEndLoc());\n  }\n\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) { return K == LinkageSpec; }\n\n  static DeclContext *castToDeclContext(const LinkageSpecDecl *D) {\n    return static_cast<DeclContext *>(const_cast<LinkageSpecDecl*>(D));\n  }\n\n  static LinkageSpecDecl *castFromDeclContext(const DeclContext *DC) {\n    return static_cast<LinkageSpecDecl *>(const_cast<DeclContext*>(DC));\n  }\n};\n\n/// Represents C++ using-directive.\n///\n/// For example:\n/// \\code\n///    using namespace std;\n/// \\endcode\n///\n/// \\note UsingDirectiveDecl should be Decl not NamedDecl, but we provide\n/// artificial names for all using-directives in order to store\n/// them in DeclContext effectively.\nclass UsingDirectiveDecl : public NamedDecl {\n  /// The location of the \\c using keyword.\n  SourceLocation UsingLoc;\n\n  /// The location of the \\c namespace keyword.\n  SourceLocation NamespaceLoc;\n\n  /// The nested-name-specifier that precedes the namespace.\n  NestedNameSpecifierLoc QualifierLoc;\n\n  /// The namespace nominated by this using-directive.\n  NamedDecl *NominatedNamespace;\n\n  /// Enclosing context containing both using-directive and nominated\n  /// namespace.\n  DeclContext *CommonAncestor;\n\n  UsingDirectiveDecl(DeclContext *DC, SourceLocation UsingLoc,\n                     SourceLocation NamespcLoc,\n                     NestedNameSpecifierLoc QualifierLoc,\n                     SourceLocation IdentLoc,\n                     NamedDecl *Nominated,\n                     DeclContext *CommonAncestor)\n      : NamedDecl(UsingDirective, DC, IdentLoc, getName()), UsingLoc(UsingLoc),\n        NamespaceLoc(NamespcLoc), QualifierLoc(QualifierLoc),\n        NominatedNamespace(Nominated), CommonAncestor(CommonAncestor) {}\n\n  /// Returns special DeclarationName used by using-directives.\n  ///\n  /// This is only used by DeclContext for storing UsingDirectiveDecls in\n  /// its lookup structure.\n  static DeclarationName getName() {\n    return DeclarationName::getUsingDirectiveName();\n  }\n\n  void anchor() override;\n\npublic:\n  friend class ASTDeclReader;\n\n  // Friend for getUsingDirectiveName.\n  friend class DeclContext;\n\n  /// Retrieve the nested-name-specifier that qualifies the\n  /// name of the namespace, with source-location information.\n  NestedNameSpecifierLoc getQualifierLoc() const { return QualifierLoc; }\n\n  /// Retrieve the nested-name-specifier that qualifies the\n  /// name of the namespace.\n  NestedNameSpecifier *getQualifier() const {\n    return QualifierLoc.getNestedNameSpecifier();\n  }\n\n  NamedDecl *getNominatedNamespaceAsWritten() { return NominatedNamespace; }\n  const NamedDecl *getNominatedNamespaceAsWritten() const {\n    return NominatedNamespace;\n  }\n\n  /// Returns the namespace nominated by this using-directive.\n  NamespaceDecl *getNominatedNamespace();\n\n  const NamespaceDecl *getNominatedNamespace() const {\n    return const_cast<UsingDirectiveDecl*>(this)->getNominatedNamespace();\n  }\n\n  /// Returns the common ancestor context of this using-directive and\n  /// its nominated namespace.\n  DeclContext *getCommonAncestor() { return CommonAncestor; }\n  const DeclContext *getCommonAncestor() const { return CommonAncestor; }\n\n  /// Return the location of the \\c using keyword.\n  SourceLocation getUsingLoc() const { return UsingLoc; }\n\n  // FIXME: Could omit 'Key' in name.\n  /// Returns the location of the \\c namespace keyword.\n  SourceLocation getNamespaceKeyLocation() const { return NamespaceLoc; }\n\n  /// Returns the location of this using declaration's identifier.\n  SourceLocation getIdentLocation() const { return getLocation(); }\n\n  static UsingDirectiveDecl *Create(ASTContext &C, DeclContext *DC,\n                                    SourceLocation UsingLoc,\n                                    SourceLocation NamespaceLoc,\n                                    NestedNameSpecifierLoc QualifierLoc,\n                                    SourceLocation IdentLoc,\n                                    NamedDecl *Nominated,\n                                    DeclContext *CommonAncestor);\n  static UsingDirectiveDecl *CreateDeserialized(ASTContext &C, unsigned ID);\n\n  SourceRange getSourceRange() const override LLVM_READONLY {\n    return SourceRange(UsingLoc, getLocation());\n  }\n\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) { return K == UsingDirective; }\n};\n\n/// Represents a C++ namespace alias.\n///\n/// For example:\n///\n/// \\code\n/// namespace Foo = Bar;\n/// \\endcode\nclass NamespaceAliasDecl : public NamedDecl,\n                           public Redeclarable<NamespaceAliasDecl> {\n  friend class ASTDeclReader;\n\n  /// The location of the \\c namespace keyword.\n  SourceLocation NamespaceLoc;\n\n  /// The location of the namespace's identifier.\n  ///\n  /// This is accessed by TargetNameLoc.\n  SourceLocation IdentLoc;\n\n  /// The nested-name-specifier that precedes the namespace.\n  NestedNameSpecifierLoc QualifierLoc;\n\n  /// The Decl that this alias points to, either a NamespaceDecl or\n  /// a NamespaceAliasDecl.\n  NamedDecl *Namespace;\n\n  NamespaceAliasDecl(ASTContext &C, DeclContext *DC,\n                     SourceLocation NamespaceLoc, SourceLocation AliasLoc,\n                     IdentifierInfo *Alias, NestedNameSpecifierLoc QualifierLoc,\n                     SourceLocation IdentLoc, NamedDecl *Namespace)\n      : NamedDecl(NamespaceAlias, DC, AliasLoc, Alias), redeclarable_base(C),\n        NamespaceLoc(NamespaceLoc), IdentLoc(IdentLoc),\n        QualifierLoc(QualifierLoc), Namespace(Namespace) {}\n\n  void anchor() override;\n\n  using redeclarable_base = Redeclarable<NamespaceAliasDecl>;\n\n  NamespaceAliasDecl *getNextRedeclarationImpl() override;\n  NamespaceAliasDecl *getPreviousDeclImpl() override;\n  NamespaceAliasDecl *getMostRecentDeclImpl() override;\n\npublic:\n  static NamespaceAliasDecl *Create(ASTContext &C, DeclContext *DC,\n                                    SourceLocation NamespaceLoc,\n                                    SourceLocation AliasLoc,\n                                    IdentifierInfo *Alias,\n                                    NestedNameSpecifierLoc QualifierLoc,\n                                    SourceLocation IdentLoc,\n                                    NamedDecl *Namespace);\n\n  static NamespaceAliasDecl *CreateDeserialized(ASTContext &C, unsigned ID);\n\n  using redecl_range = redeclarable_base::redecl_range;\n  using redecl_iterator = redeclarable_base::redecl_iterator;\n\n  using redeclarable_base::redecls_begin;\n  using redeclarable_base::redecls_end;\n  using redeclarable_base::redecls;\n  using redeclarable_base::getPreviousDecl;\n  using redeclarable_base::getMostRecentDecl;\n\n  NamespaceAliasDecl *getCanonicalDecl() override {\n    return getFirstDecl();\n  }\n  const NamespaceAliasDecl *getCanonicalDecl() const {\n    return getFirstDecl();\n  }\n\n  /// Retrieve the nested-name-specifier that qualifies the\n  /// name of the namespace, with source-location information.\n  NestedNameSpecifierLoc getQualifierLoc() const { return QualifierLoc; }\n\n  /// Retrieve the nested-name-specifier that qualifies the\n  /// name of the namespace.\n  NestedNameSpecifier *getQualifier() const {\n    return QualifierLoc.getNestedNameSpecifier();\n  }\n\n  /// Retrieve the namespace declaration aliased by this directive.\n  NamespaceDecl *getNamespace() {\n    if (auto *AD = dyn_cast<NamespaceAliasDecl>(Namespace))\n      return AD->getNamespace();\n\n    return cast<NamespaceDecl>(Namespace);\n  }\n\n  const NamespaceDecl *getNamespace() const {\n    return const_cast<NamespaceAliasDecl *>(this)->getNamespace();\n  }\n\n  /// Returns the location of the alias name, i.e. 'foo' in\n  /// \"namespace foo = ns::bar;\".\n  SourceLocation getAliasLoc() const { return getLocation(); }\n\n  /// Returns the location of the \\c namespace keyword.\n  SourceLocation getNamespaceLoc() const { return NamespaceLoc; }\n\n  /// Returns the location of the identifier in the named namespace.\n  SourceLocation getTargetNameLoc() const { return IdentLoc; }\n\n  /// Retrieve the namespace that this alias refers to, which\n  /// may either be a NamespaceDecl or a NamespaceAliasDecl.\n  NamedDecl *getAliasedNamespace() const { return Namespace; }\n\n  SourceRange getSourceRange() const override LLVM_READONLY {\n    return SourceRange(NamespaceLoc, IdentLoc);\n  }\n\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) { return K == NamespaceAlias; }\n};\n\n/// Implicit declaration of a temporary that was materialized by\n/// a MaterializeTemporaryExpr and lifetime-extended by a declaration\nclass LifetimeExtendedTemporaryDecl final\n    : public Decl,\n      public Mergeable<LifetimeExtendedTemporaryDecl> {\n  friend class MaterializeTemporaryExpr;\n  friend class ASTDeclReader;\n\n  Stmt *ExprWithTemporary = nullptr;\n\n  /// The declaration which lifetime-extended this reference, if any.\n  /// Either a VarDecl, or (for a ctor-initializer) a FieldDecl.\n  ValueDecl *ExtendingDecl = nullptr;\n  unsigned ManglingNumber;\n\n  mutable APValue *Value = nullptr;\n\n  virtual void anchor();\n\n  LifetimeExtendedTemporaryDecl(Expr *Temp, ValueDecl *EDecl, unsigned Mangling)\n      : Decl(Decl::LifetimeExtendedTemporary, EDecl->getDeclContext(),\n             EDecl->getLocation()),\n        ExprWithTemporary(Temp), ExtendingDecl(EDecl),\n        ManglingNumber(Mangling) {}\n\n  LifetimeExtendedTemporaryDecl(EmptyShell)\n      : Decl(Decl::LifetimeExtendedTemporary, EmptyShell{}) {}\n\npublic:\n  static LifetimeExtendedTemporaryDecl *Create(Expr *Temp, ValueDecl *EDec,\n                                               unsigned Mangling) {\n    return new (EDec->getASTContext(), EDec->getDeclContext())\n        LifetimeExtendedTemporaryDecl(Temp, EDec, Mangling);\n  }\n  static LifetimeExtendedTemporaryDecl *CreateDeserialized(ASTContext &C,\n                                                           unsigned ID) {\n    return new (C, ID) LifetimeExtendedTemporaryDecl(EmptyShell{});\n  }\n\n  ValueDecl *getExtendingDecl() { return ExtendingDecl; }\n  const ValueDecl *getExtendingDecl() const { return ExtendingDecl; }\n\n  /// Retrieve the storage duration for the materialized temporary.\n  StorageDuration getStorageDuration() const;\n\n  /// Retrieve the expression to which the temporary materialization conversion\n  /// was applied. This isn't necessarily the initializer of the temporary due\n  /// to the C++98 delayed materialization rules, but\n  /// skipRValueSubobjectAdjustments can be used to find said initializer within\n  /// the subexpression.\n  Expr *getTemporaryExpr() { return cast<Expr>(ExprWithTemporary); }\n  const Expr *getTemporaryExpr() const { return cast<Expr>(ExprWithTemporary); }\n\n  unsigned getManglingNumber() const { return ManglingNumber; }\n\n  /// Get the storage for the constant value of a materialized temporary\n  /// of static storage duration.\n  APValue *getOrCreateValue(bool MayCreate) const;\n\n  APValue *getValue() const { return Value; }\n\n  // Iterators\n  Stmt::child_range childrenExpr() {\n    return Stmt::child_range(&ExprWithTemporary, &ExprWithTemporary + 1);\n  }\n\n  Stmt::const_child_range childrenExpr() const {\n    return Stmt::const_child_range(&ExprWithTemporary, &ExprWithTemporary + 1);\n  }\n\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) {\n    return K == Decl::LifetimeExtendedTemporary;\n  }\n};\n\n/// Represents a shadow declaration introduced into a scope by a\n/// (resolved) using declaration.\n///\n/// For example,\n/// \\code\n/// namespace A {\n///   void foo();\n/// }\n/// namespace B {\n///   using A::foo; // <- a UsingDecl\n///                 // Also creates a UsingShadowDecl for A::foo() in B\n/// }\n/// \\endcode\nclass UsingShadowDecl : public NamedDecl, public Redeclarable<UsingShadowDecl> {\n  friend class UsingDecl;\n\n  /// The referenced declaration.\n  NamedDecl *Underlying = nullptr;\n\n  /// The using declaration which introduced this decl or the next using\n  /// shadow declaration contained in the aforementioned using declaration.\n  NamedDecl *UsingOrNextShadow = nullptr;\n\n  void anchor() override;\n\n  using redeclarable_base = Redeclarable<UsingShadowDecl>;\n\n  UsingShadowDecl *getNextRedeclarationImpl() override {\n    return getNextRedeclaration();\n  }\n\n  UsingShadowDecl *getPreviousDeclImpl() override {\n    return getPreviousDecl();\n  }\n\n  UsingShadowDecl *getMostRecentDeclImpl() override {\n    return getMostRecentDecl();\n  }\n\nprotected:\n  UsingShadowDecl(Kind K, ASTContext &C, DeclContext *DC, SourceLocation Loc,\n                  UsingDecl *Using, NamedDecl *Target);\n  UsingShadowDecl(Kind K, ASTContext &C, EmptyShell);\n\npublic:\n  friend class ASTDeclReader;\n  friend class ASTDeclWriter;\n\n  static UsingShadowDecl *Create(ASTContext &C, DeclContext *DC,\n                                 SourceLocation Loc, UsingDecl *Using,\n                                 NamedDecl *Target) {\n    return new (C, DC) UsingShadowDecl(UsingShadow, C, DC, Loc, Using, Target);\n  }\n\n  static UsingShadowDecl *CreateDeserialized(ASTContext &C, unsigned ID);\n\n  using redecl_range = redeclarable_base::redecl_range;\n  using redecl_iterator = redeclarable_base::redecl_iterator;\n\n  using redeclarable_base::redecls_begin;\n  using redeclarable_base::redecls_end;\n  using redeclarable_base::redecls;\n  using redeclarable_base::getPreviousDecl;\n  using redeclarable_base::getMostRecentDecl;\n  using redeclarable_base::isFirstDecl;\n\n  UsingShadowDecl *getCanonicalDecl() override {\n    return getFirstDecl();\n  }\n  const UsingShadowDecl *getCanonicalDecl() const {\n    return getFirstDecl();\n  }\n\n  /// Gets the underlying declaration which has been brought into the\n  /// local scope.\n  NamedDecl *getTargetDecl() const { return Underlying; }\n\n  /// Sets the underlying declaration which has been brought into the\n  /// local scope.\n  void setTargetDecl(NamedDecl *ND) {\n    assert(ND && \"Target decl is null!\");\n    Underlying = ND;\n    // A UsingShadowDecl is never a friend or local extern declaration, even\n    // if it is a shadow declaration for one.\n    IdentifierNamespace =\n        ND->getIdentifierNamespace() &\n        ~(IDNS_OrdinaryFriend | IDNS_TagFriend | IDNS_LocalExtern);\n  }\n\n  /// Gets the using declaration to which this declaration is tied.\n  UsingDecl *getUsingDecl() const;\n\n  /// The next using shadow declaration contained in the shadow decl\n  /// chain of the using declaration which introduced this decl.\n  UsingShadowDecl *getNextUsingShadowDecl() const {\n    return dyn_cast_or_null<UsingShadowDecl>(UsingOrNextShadow);\n  }\n\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) {\n    return K == Decl::UsingShadow || K == Decl::ConstructorUsingShadow;\n  }\n};\n\n/// Represents a shadow constructor declaration introduced into a\n/// class by a C++11 using-declaration that names a constructor.\n///\n/// For example:\n/// \\code\n/// struct Base { Base(int); };\n/// struct Derived {\n///    using Base::Base; // creates a UsingDecl and a ConstructorUsingShadowDecl\n/// };\n/// \\endcode\nclass ConstructorUsingShadowDecl final : public UsingShadowDecl {\n  /// If this constructor using declaration inherted the constructor\n  /// from an indirect base class, this is the ConstructorUsingShadowDecl\n  /// in the named direct base class from which the declaration was inherited.\n  ConstructorUsingShadowDecl *NominatedBaseClassShadowDecl = nullptr;\n\n  /// If this constructor using declaration inherted the constructor\n  /// from an indirect base class, this is the ConstructorUsingShadowDecl\n  /// that will be used to construct the unique direct or virtual base class\n  /// that receives the constructor arguments.\n  ConstructorUsingShadowDecl *ConstructedBaseClassShadowDecl = nullptr;\n\n  /// \\c true if the constructor ultimately named by this using shadow\n  /// declaration is within a virtual base class subobject of the class that\n  /// contains this declaration.\n  unsigned IsVirtual : 1;\n\n  ConstructorUsingShadowDecl(ASTContext &C, DeclContext *DC, SourceLocation Loc,\n                             UsingDecl *Using, NamedDecl *Target,\n                             bool TargetInVirtualBase)\n      : UsingShadowDecl(ConstructorUsingShadow, C, DC, Loc, Using,\n                        Target->getUnderlyingDecl()),\n        NominatedBaseClassShadowDecl(\n            dyn_cast<ConstructorUsingShadowDecl>(Target)),\n        ConstructedBaseClassShadowDecl(NominatedBaseClassShadowDecl),\n        IsVirtual(TargetInVirtualBase) {\n    // If we found a constructor that chains to a constructor for a virtual\n    // base, we should directly call that virtual base constructor instead.\n    // FIXME: This logic belongs in Sema.\n    if (NominatedBaseClassShadowDecl &&\n        NominatedBaseClassShadowDecl->constructsVirtualBase()) {\n      ConstructedBaseClassShadowDecl =\n          NominatedBaseClassShadowDecl->ConstructedBaseClassShadowDecl;\n      IsVirtual = true;\n    }\n  }\n\n  ConstructorUsingShadowDecl(ASTContext &C, EmptyShell Empty)\n      : UsingShadowDecl(ConstructorUsingShadow, C, Empty), IsVirtual(false) {}\n\n  void anchor() override;\n\npublic:\n  friend class ASTDeclReader;\n  friend class ASTDeclWriter;\n\n  static ConstructorUsingShadowDecl *Create(ASTContext &C, DeclContext *DC,\n                                            SourceLocation Loc,\n                                            UsingDecl *Using, NamedDecl *Target,\n                                            bool IsVirtual);\n  static ConstructorUsingShadowDecl *CreateDeserialized(ASTContext &C,\n                                                        unsigned ID);\n\n  /// Returns the parent of this using shadow declaration, which\n  /// is the class in which this is declared.\n  //@{\n  const CXXRecordDecl *getParent() const {\n    return cast<CXXRecordDecl>(getDeclContext());\n  }\n  CXXRecordDecl *getParent() {\n    return cast<CXXRecordDecl>(getDeclContext());\n  }\n  //@}\n\n  /// Get the inheriting constructor declaration for the direct base\n  /// class from which this using shadow declaration was inherited, if there is\n  /// one. This can be different for each redeclaration of the same shadow decl.\n  ConstructorUsingShadowDecl *getNominatedBaseClassShadowDecl() const {\n    return NominatedBaseClassShadowDecl;\n  }\n\n  /// Get the inheriting constructor declaration for the base class\n  /// for which we don't have an explicit initializer, if there is one.\n  ConstructorUsingShadowDecl *getConstructedBaseClassShadowDecl() const {\n    return ConstructedBaseClassShadowDecl;\n  }\n\n  /// Get the base class that was named in the using declaration. This\n  /// can be different for each redeclaration of this same shadow decl.\n  CXXRecordDecl *getNominatedBaseClass() const;\n\n  /// Get the base class whose constructor or constructor shadow\n  /// declaration is passed the constructor arguments.\n  CXXRecordDecl *getConstructedBaseClass() const {\n    return cast<CXXRecordDecl>((ConstructedBaseClassShadowDecl\n                                    ? ConstructedBaseClassShadowDecl\n                                    : getTargetDecl())\n                                   ->getDeclContext());\n  }\n\n  /// Returns \\c true if the constructed base class is a virtual base\n  /// class subobject of this declaration's class.\n  bool constructsVirtualBase() const {\n    return IsVirtual;\n  }\n\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) { return K == ConstructorUsingShadow; }\n};\n\n/// Represents a C++ using-declaration.\n///\n/// For example:\n/// \\code\n///    using someNameSpace::someIdentifier;\n/// \\endcode\nclass UsingDecl : public NamedDecl, public Mergeable<UsingDecl> {\n  /// The source location of the 'using' keyword itself.\n  SourceLocation UsingLocation;\n\n  /// The nested-name-specifier that precedes the name.\n  NestedNameSpecifierLoc QualifierLoc;\n\n  /// Provides source/type location info for the declaration name\n  /// embedded in the ValueDecl base class.\n  DeclarationNameLoc DNLoc;\n\n  /// The first shadow declaration of the shadow decl chain associated\n  /// with this using declaration.\n  ///\n  /// The bool member of the pair store whether this decl has the \\c typename\n  /// keyword.\n  llvm::PointerIntPair<UsingShadowDecl *, 1, bool> FirstUsingShadow;\n\n  UsingDecl(DeclContext *DC, SourceLocation UL,\n            NestedNameSpecifierLoc QualifierLoc,\n            const DeclarationNameInfo &NameInfo, bool HasTypenameKeyword)\n    : NamedDecl(Using, DC, NameInfo.getLoc(), NameInfo.getName()),\n      UsingLocation(UL), QualifierLoc(QualifierLoc),\n      DNLoc(NameInfo.getInfo()), FirstUsingShadow(nullptr, HasTypenameKeyword) {\n  }\n\n  void anchor() override;\n\npublic:\n  friend class ASTDeclReader;\n  friend class ASTDeclWriter;\n\n  /// Return the source location of the 'using' keyword.\n  SourceLocation getUsingLoc() const { return UsingLocation; }\n\n  /// Set the source location of the 'using' keyword.\n  void setUsingLoc(SourceLocation L) { UsingLocation = L; }\n\n  /// Retrieve the nested-name-specifier that qualifies the name,\n  /// with source-location information.\n  NestedNameSpecifierLoc getQualifierLoc() const { return QualifierLoc; }\n\n  /// Retrieve the nested-name-specifier that qualifies the name.\n  NestedNameSpecifier *getQualifier() const {\n    return QualifierLoc.getNestedNameSpecifier();\n  }\n\n  DeclarationNameInfo getNameInfo() const {\n    return DeclarationNameInfo(getDeclName(), getLocation(), DNLoc);\n  }\n\n  /// Return true if it is a C++03 access declaration (no 'using').\n  bool isAccessDeclaration() const { return UsingLocation.isInvalid(); }\n\n  /// Return true if the using declaration has 'typename'.\n  bool hasTypename() const { return FirstUsingShadow.getInt(); }\n\n  /// Sets whether the using declaration has 'typename'.\n  void setTypename(bool TN) { FirstUsingShadow.setInt(TN); }\n\n  /// Iterates through the using shadow declarations associated with\n  /// this using declaration.\n  class shadow_iterator {\n    /// The current using shadow declaration.\n    UsingShadowDecl *Current = nullptr;\n\n  public:\n    using value_type = UsingShadowDecl *;\n    using reference = UsingShadowDecl *;\n    using pointer = UsingShadowDecl *;\n    using iterator_category = std::forward_iterator_tag;\n    using difference_type = std::ptrdiff_t;\n\n    shadow_iterator() = default;\n    explicit shadow_iterator(UsingShadowDecl *C) : Current(C) {}\n\n    reference operator*() const { return Current; }\n    pointer operator->() const { return Current; }\n\n    shadow_iterator& operator++() {\n      Current = Current->getNextUsingShadowDecl();\n      return *this;\n    }\n\n    shadow_iterator operator++(int) {\n      shadow_iterator tmp(*this);\n      ++(*this);\n      return tmp;\n    }\n\n    friend bool operator==(shadow_iterator x, shadow_iterator y) {\n      return x.Current == y.Current;\n    }\n    friend bool operator!=(shadow_iterator x, shadow_iterator y) {\n      return x.Current != y.Current;\n    }\n  };\n\n  using shadow_range = llvm::iterator_range<shadow_iterator>;\n\n  shadow_range shadows() const {\n    return shadow_range(shadow_begin(), shadow_end());\n  }\n\n  shadow_iterator shadow_begin() const {\n    return shadow_iterator(FirstUsingShadow.getPointer());\n  }\n\n  shadow_iterator shadow_end() const { return shadow_iterator(); }\n\n  /// Return the number of shadowed declarations associated with this\n  /// using declaration.\n  unsigned shadow_size() const {\n    return std::distance(shadow_begin(), shadow_end());\n  }\n\n  void addShadowDecl(UsingShadowDecl *S);\n  void removeShadowDecl(UsingShadowDecl *S);\n\n  static UsingDecl *Create(ASTContext &C, DeclContext *DC,\n                           SourceLocation UsingL,\n                           NestedNameSpecifierLoc QualifierLoc,\n                           const DeclarationNameInfo &NameInfo,\n                           bool HasTypenameKeyword);\n\n  static UsingDecl *CreateDeserialized(ASTContext &C, unsigned ID);\n\n  SourceRange getSourceRange() const override LLVM_READONLY;\n\n  /// Retrieves the canonical declaration of this declaration.\n  UsingDecl *getCanonicalDecl() override { return getFirstDecl(); }\n  const UsingDecl *getCanonicalDecl() const { return getFirstDecl(); }\n\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) { return K == Using; }\n};\n\n/// Represents a pack of using declarations that a single\n/// using-declarator pack-expanded into.\n///\n/// \\code\n/// template<typename ...T> struct X : T... {\n///   using T::operator()...;\n///   using T::operator T...;\n/// };\n/// \\endcode\n///\n/// In the second case above, the UsingPackDecl will have the name\n/// 'operator T' (which contains an unexpanded pack), but the individual\n/// UsingDecls and UsingShadowDecls will have more reasonable names.\nclass UsingPackDecl final\n    : public NamedDecl, public Mergeable<UsingPackDecl>,\n      private llvm::TrailingObjects<UsingPackDecl, NamedDecl *> {\n  /// The UnresolvedUsingValueDecl or UnresolvedUsingTypenameDecl from\n  /// which this waas instantiated.\n  NamedDecl *InstantiatedFrom;\n\n  /// The number of using-declarations created by this pack expansion.\n  unsigned NumExpansions;\n\n  UsingPackDecl(DeclContext *DC, NamedDecl *InstantiatedFrom,\n                ArrayRef<NamedDecl *> UsingDecls)\n      : NamedDecl(UsingPack, DC,\n                  InstantiatedFrom ? InstantiatedFrom->getLocation()\n                                   : SourceLocation(),\n                  InstantiatedFrom ? InstantiatedFrom->getDeclName()\n                                   : DeclarationName()),\n        InstantiatedFrom(InstantiatedFrom), NumExpansions(UsingDecls.size()) {\n    std::uninitialized_copy(UsingDecls.begin(), UsingDecls.end(),\n                            getTrailingObjects<NamedDecl *>());\n  }\n\n  void anchor() override;\n\npublic:\n  friend class ASTDeclReader;\n  friend class ASTDeclWriter;\n  friend TrailingObjects;\n\n  /// Get the using declaration from which this was instantiated. This will\n  /// always be an UnresolvedUsingValueDecl or an UnresolvedUsingTypenameDecl\n  /// that is a pack expansion.\n  NamedDecl *getInstantiatedFromUsingDecl() const { return InstantiatedFrom; }\n\n  /// Get the set of using declarations that this pack expanded into. Note that\n  /// some of these may still be unresolved.\n  ArrayRef<NamedDecl *> expansions() const {\n    return llvm::makeArrayRef(getTrailingObjects<NamedDecl *>(), NumExpansions);\n  }\n\n  static UsingPackDecl *Create(ASTContext &C, DeclContext *DC,\n                               NamedDecl *InstantiatedFrom,\n                               ArrayRef<NamedDecl *> UsingDecls);\n\n  static UsingPackDecl *CreateDeserialized(ASTContext &C, unsigned ID,\n                                           unsigned NumExpansions);\n\n  SourceRange getSourceRange() const override LLVM_READONLY {\n    return InstantiatedFrom->getSourceRange();\n  }\n\n  UsingPackDecl *getCanonicalDecl() override { return getFirstDecl(); }\n  const UsingPackDecl *getCanonicalDecl() const { return getFirstDecl(); }\n\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) { return K == UsingPack; }\n};\n\n/// Represents a dependent using declaration which was not marked with\n/// \\c typename.\n///\n/// Unlike non-dependent using declarations, these *only* bring through\n/// non-types; otherwise they would break two-phase lookup.\n///\n/// \\code\n/// template \\<class T> class A : public Base<T> {\n///   using Base<T>::foo;\n/// };\n/// \\endcode\nclass UnresolvedUsingValueDecl : public ValueDecl,\n                                 public Mergeable<UnresolvedUsingValueDecl> {\n  /// The source location of the 'using' keyword\n  SourceLocation UsingLocation;\n\n  /// If this is a pack expansion, the location of the '...'.\n  SourceLocation EllipsisLoc;\n\n  /// The nested-name-specifier that precedes the name.\n  NestedNameSpecifierLoc QualifierLoc;\n\n  /// Provides source/type location info for the declaration name\n  /// embedded in the ValueDecl base class.\n  DeclarationNameLoc DNLoc;\n\n  UnresolvedUsingValueDecl(DeclContext *DC, QualType Ty,\n                           SourceLocation UsingLoc,\n                           NestedNameSpecifierLoc QualifierLoc,\n                           const DeclarationNameInfo &NameInfo,\n                           SourceLocation EllipsisLoc)\n      : ValueDecl(UnresolvedUsingValue, DC,\n                  NameInfo.getLoc(), NameInfo.getName(), Ty),\n        UsingLocation(UsingLoc), EllipsisLoc(EllipsisLoc),\n        QualifierLoc(QualifierLoc), DNLoc(NameInfo.getInfo()) {}\n\n  void anchor() override;\n\npublic:\n  friend class ASTDeclReader;\n  friend class ASTDeclWriter;\n\n  /// Returns the source location of the 'using' keyword.\n  SourceLocation getUsingLoc() const { return UsingLocation; }\n\n  /// Set the source location of the 'using' keyword.\n  void setUsingLoc(SourceLocation L) { UsingLocation = L; }\n\n  /// Return true if it is a C++03 access declaration (no 'using').\n  bool isAccessDeclaration() const { return UsingLocation.isInvalid(); }\n\n  /// Retrieve the nested-name-specifier that qualifies the name,\n  /// with source-location information.\n  NestedNameSpecifierLoc getQualifierLoc() const { return QualifierLoc; }\n\n  /// Retrieve the nested-name-specifier that qualifies the name.\n  NestedNameSpecifier *getQualifier() const {\n    return QualifierLoc.getNestedNameSpecifier();\n  }\n\n  DeclarationNameInfo getNameInfo() const {\n    return DeclarationNameInfo(getDeclName(), getLocation(), DNLoc);\n  }\n\n  /// Determine whether this is a pack expansion.\n  bool isPackExpansion() const {\n    return EllipsisLoc.isValid();\n  }\n\n  /// Get the location of the ellipsis if this is a pack expansion.\n  SourceLocation getEllipsisLoc() const {\n    return EllipsisLoc;\n  }\n\n  static UnresolvedUsingValueDecl *\n    Create(ASTContext &C, DeclContext *DC, SourceLocation UsingLoc,\n           NestedNameSpecifierLoc QualifierLoc,\n           const DeclarationNameInfo &NameInfo, SourceLocation EllipsisLoc);\n\n  static UnresolvedUsingValueDecl *\n  CreateDeserialized(ASTContext &C, unsigned ID);\n\n  SourceRange getSourceRange() const override LLVM_READONLY;\n\n  /// Retrieves the canonical declaration of this declaration.\n  UnresolvedUsingValueDecl *getCanonicalDecl() override {\n    return getFirstDecl();\n  }\n  const UnresolvedUsingValueDecl *getCanonicalDecl() const {\n    return getFirstDecl();\n  }\n\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) { return K == UnresolvedUsingValue; }\n};\n\n/// Represents a dependent using declaration which was marked with\n/// \\c typename.\n///\n/// \\code\n/// template \\<class T> class A : public Base<T> {\n///   using typename Base<T>::foo;\n/// };\n/// \\endcode\n///\n/// The type associated with an unresolved using typename decl is\n/// currently always a typename type.\nclass UnresolvedUsingTypenameDecl\n    : public TypeDecl,\n      public Mergeable<UnresolvedUsingTypenameDecl> {\n  friend class ASTDeclReader;\n\n  /// The source location of the 'typename' keyword\n  SourceLocation TypenameLocation;\n\n  /// If this is a pack expansion, the location of the '...'.\n  SourceLocation EllipsisLoc;\n\n  /// The nested-name-specifier that precedes the name.\n  NestedNameSpecifierLoc QualifierLoc;\n\n  UnresolvedUsingTypenameDecl(DeclContext *DC, SourceLocation UsingLoc,\n                              SourceLocation TypenameLoc,\n                              NestedNameSpecifierLoc QualifierLoc,\n                              SourceLocation TargetNameLoc,\n                              IdentifierInfo *TargetName,\n                              SourceLocation EllipsisLoc)\n    : TypeDecl(UnresolvedUsingTypename, DC, TargetNameLoc, TargetName,\n               UsingLoc),\n      TypenameLocation(TypenameLoc), EllipsisLoc(EllipsisLoc),\n      QualifierLoc(QualifierLoc) {}\n\n  void anchor() override;\n\npublic:\n  /// Returns the source location of the 'using' keyword.\n  SourceLocation getUsingLoc() const { return getBeginLoc(); }\n\n  /// Returns the source location of the 'typename' keyword.\n  SourceLocation getTypenameLoc() const { return TypenameLocation; }\n\n  /// Retrieve the nested-name-specifier that qualifies the name,\n  /// with source-location information.\n  NestedNameSpecifierLoc getQualifierLoc() const { return QualifierLoc; }\n\n  /// Retrieve the nested-name-specifier that qualifies the name.\n  NestedNameSpecifier *getQualifier() const {\n    return QualifierLoc.getNestedNameSpecifier();\n  }\n\n  DeclarationNameInfo getNameInfo() const {\n    return DeclarationNameInfo(getDeclName(), getLocation());\n  }\n\n  /// Determine whether this is a pack expansion.\n  bool isPackExpansion() const {\n    return EllipsisLoc.isValid();\n  }\n\n  /// Get the location of the ellipsis if this is a pack expansion.\n  SourceLocation getEllipsisLoc() const {\n    return EllipsisLoc;\n  }\n\n  static UnresolvedUsingTypenameDecl *\n    Create(ASTContext &C, DeclContext *DC, SourceLocation UsingLoc,\n           SourceLocation TypenameLoc, NestedNameSpecifierLoc QualifierLoc,\n           SourceLocation TargetNameLoc, DeclarationName TargetName,\n           SourceLocation EllipsisLoc);\n\n  static UnresolvedUsingTypenameDecl *\n  CreateDeserialized(ASTContext &C, unsigned ID);\n\n  /// Retrieves the canonical declaration of this declaration.\n  UnresolvedUsingTypenameDecl *getCanonicalDecl() override {\n    return getFirstDecl();\n  }\n  const UnresolvedUsingTypenameDecl *getCanonicalDecl() const {\n    return getFirstDecl();\n  }\n\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) { return K == UnresolvedUsingTypename; }\n};\n\n/// Represents a C++11 static_assert declaration.\nclass StaticAssertDecl : public Decl {\n  llvm::PointerIntPair<Expr *, 1, bool> AssertExprAndFailed;\n  StringLiteral *Message;\n  SourceLocation RParenLoc;\n\n  StaticAssertDecl(DeclContext *DC, SourceLocation StaticAssertLoc,\n                   Expr *AssertExpr, StringLiteral *Message,\n                   SourceLocation RParenLoc, bool Failed)\n      : Decl(StaticAssert, DC, StaticAssertLoc),\n        AssertExprAndFailed(AssertExpr, Failed), Message(Message),\n        RParenLoc(RParenLoc) {}\n\n  virtual void anchor();\n\npublic:\n  friend class ASTDeclReader;\n\n  static StaticAssertDecl *Create(ASTContext &C, DeclContext *DC,\n                                  SourceLocation StaticAssertLoc,\n                                  Expr *AssertExpr, StringLiteral *Message,\n                                  SourceLocation RParenLoc, bool Failed);\n  static StaticAssertDecl *CreateDeserialized(ASTContext &C, unsigned ID);\n\n  Expr *getAssertExpr() { return AssertExprAndFailed.getPointer(); }\n  const Expr *getAssertExpr() const { return AssertExprAndFailed.getPointer(); }\n\n  StringLiteral *getMessage() { return Message; }\n  const StringLiteral *getMessage() const { return Message; }\n\n  bool isFailed() const { return AssertExprAndFailed.getInt(); }\n\n  SourceLocation getRParenLoc() const { return RParenLoc; }\n\n  SourceRange getSourceRange() const override LLVM_READONLY {\n    return SourceRange(getLocation(), getRParenLoc());\n  }\n\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) { return K == StaticAssert; }\n};\n\n/// A binding in a decomposition declaration. For instance, given:\n///\n///   int n[3];\n///   auto &[a, b, c] = n;\n///\n/// a, b, and c are BindingDecls, whose bindings are the expressions\n/// x[0], x[1], and x[2] respectively, where x is the implicit\n/// DecompositionDecl of type 'int (&)[3]'.\nclass BindingDecl : public ValueDecl {\n  /// The declaration that this binding binds to part of.\n  LazyDeclPtr Decomp;\n  /// The binding represented by this declaration. References to this\n  /// declaration are effectively equivalent to this expression (except\n  /// that it is only evaluated once at the point of declaration of the\n  /// binding).\n  Expr *Binding = nullptr;\n\n  BindingDecl(DeclContext *DC, SourceLocation IdLoc, IdentifierInfo *Id)\n      : ValueDecl(Decl::Binding, DC, IdLoc, Id, QualType()) {}\n\n  void anchor() override;\n\npublic:\n  friend class ASTDeclReader;\n\n  static BindingDecl *Create(ASTContext &C, DeclContext *DC,\n                             SourceLocation IdLoc, IdentifierInfo *Id);\n  static BindingDecl *CreateDeserialized(ASTContext &C, unsigned ID);\n\n  /// Get the expression to which this declaration is bound. This may be null\n  /// in two different cases: while parsing the initializer for the\n  /// decomposition declaration, and when the initializer is type-dependent.\n  Expr *getBinding() const { return Binding; }\n\n  /// Get the decomposition declaration that this binding represents a\n  /// decomposition of.\n  ValueDecl *getDecomposedDecl() const;\n\n  /// Get the variable (if any) that holds the value of evaluating the binding.\n  /// Only present for user-defined bindings for tuple-like types.\n  VarDecl *getHoldingVar() const;\n\n  /// Set the binding for this BindingDecl, along with its declared type (which\n  /// should be a possibly-cv-qualified form of the type of the binding, or a\n  /// reference to such a type).\n  void setBinding(QualType DeclaredType, Expr *Binding) {\n    setType(DeclaredType);\n    this->Binding = Binding;\n  }\n\n  /// Set the decomposed variable for this BindingDecl.\n  void setDecomposedDecl(ValueDecl *Decomposed) { Decomp = Decomposed; }\n\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) { return K == Decl::Binding; }\n};\n\n/// A decomposition declaration. For instance, given:\n///\n///   int n[3];\n///   auto &[a, b, c] = n;\n///\n/// the second line declares a DecompositionDecl of type 'int (&)[3]', and\n/// three BindingDecls (named a, b, and c). An instance of this class is always\n/// unnamed, but behaves in almost all other respects like a VarDecl.\nclass DecompositionDecl final\n    : public VarDecl,\n      private llvm::TrailingObjects<DecompositionDecl, BindingDecl *> {\n  /// The number of BindingDecl*s following this object.\n  unsigned NumBindings;\n\n  DecompositionDecl(ASTContext &C, DeclContext *DC, SourceLocation StartLoc,\n                    SourceLocation LSquareLoc, QualType T,\n                    TypeSourceInfo *TInfo, StorageClass SC,\n                    ArrayRef<BindingDecl *> Bindings)\n      : VarDecl(Decomposition, C, DC, StartLoc, LSquareLoc, nullptr, T, TInfo,\n                SC),\n        NumBindings(Bindings.size()) {\n    std::uninitialized_copy(Bindings.begin(), Bindings.end(),\n                            getTrailingObjects<BindingDecl *>());\n    for (auto *B : Bindings)\n      B->setDecomposedDecl(this);\n  }\n\n  void anchor() override;\n\npublic:\n  friend class ASTDeclReader;\n  friend TrailingObjects;\n\n  static DecompositionDecl *Create(ASTContext &C, DeclContext *DC,\n                                   SourceLocation StartLoc,\n                                   SourceLocation LSquareLoc,\n                                   QualType T, TypeSourceInfo *TInfo,\n                                   StorageClass S,\n                                   ArrayRef<BindingDecl *> Bindings);\n  static DecompositionDecl *CreateDeserialized(ASTContext &C, unsigned ID,\n                                               unsigned NumBindings);\n\n  ArrayRef<BindingDecl *> bindings() const {\n    return llvm::makeArrayRef(getTrailingObjects<BindingDecl *>(), NumBindings);\n  }\n\n  void printName(raw_ostream &os) const override;\n\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) { return K == Decomposition; }\n};\n\n/// An instance of this class represents the declaration of a property\n/// member.  This is a Microsoft extension to C++, first introduced in\n/// Visual Studio .NET 2003 as a parallel to similar features in C#\n/// and Managed C++.\n///\n/// A property must always be a non-static class member.\n///\n/// A property member superficially resembles a non-static data\n/// member, except preceded by a property attribute:\n///   __declspec(property(get=GetX, put=PutX)) int x;\n/// Either (but not both) of the 'get' and 'put' names may be omitted.\n///\n/// A reference to a property is always an lvalue.  If the lvalue\n/// undergoes lvalue-to-rvalue conversion, then a getter name is\n/// required, and that member is called with no arguments.\n/// If the lvalue is assigned into, then a setter name is required,\n/// and that member is called with one argument, the value assigned.\n/// Both operations are potentially overloaded.  Compound assignments\n/// are permitted, as are the increment and decrement operators.\n///\n/// The getter and putter methods are permitted to be overloaded,\n/// although their return and parameter types are subject to certain\n/// restrictions according to the type of the property.\n///\n/// A property declared using an incomplete array type may\n/// additionally be subscripted, adding extra parameters to the getter\n/// and putter methods.\nclass MSPropertyDecl : public DeclaratorDecl {\n  IdentifierInfo *GetterId, *SetterId;\n\n  MSPropertyDecl(DeclContext *DC, SourceLocation L, DeclarationName N,\n                 QualType T, TypeSourceInfo *TInfo, SourceLocation StartL,\n                 IdentifierInfo *Getter, IdentifierInfo *Setter)\n      : DeclaratorDecl(MSProperty, DC, L, N, T, TInfo, StartL),\n        GetterId(Getter), SetterId(Setter) {}\n\n  void anchor() override;\npublic:\n  friend class ASTDeclReader;\n\n  static MSPropertyDecl *Create(ASTContext &C, DeclContext *DC,\n                                SourceLocation L, DeclarationName N, QualType T,\n                                TypeSourceInfo *TInfo, SourceLocation StartL,\n                                IdentifierInfo *Getter, IdentifierInfo *Setter);\n  static MSPropertyDecl *CreateDeserialized(ASTContext &C, unsigned ID);\n\n  static bool classof(const Decl *D) { return D->getKind() == MSProperty; }\n\n  bool hasGetter() const { return GetterId != nullptr; }\n  IdentifierInfo* getGetterId() const { return GetterId; }\n  bool hasSetter() const { return SetterId != nullptr; }\n  IdentifierInfo* getSetterId() const { return SetterId; }\n};\n\n/// Parts of a decomposed MSGuidDecl. Factored out to avoid unnecessary\n/// dependencies on DeclCXX.h.\nstruct MSGuidDeclParts {\n  /// {01234567-...\n  uint32_t Part1;\n  /// ...-89ab-...\n  uint16_t Part2;\n  /// ...-cdef-...\n  uint16_t Part3;\n  /// ...-0123-456789abcdef}\n  uint8_t Part4And5[8];\n\n  uint64_t getPart4And5AsUint64() const {\n    uint64_t Val;\n    memcpy(&Val, &Part4And5, sizeof(Part4And5));\n    return Val;\n  }\n};\n\n/// A global _GUID constant. These are implicitly created by UuidAttrs.\n///\n///   struct _declspec(uuid(\"01234567-89ab-cdef-0123-456789abcdef\")) X{};\n///\n/// X is a CXXRecordDecl that contains a UuidAttr that references the (unique)\n/// MSGuidDecl for the specified UUID.\nclass MSGuidDecl : public ValueDecl,\n                   public Mergeable<MSGuidDecl>,\n                   public llvm::FoldingSetNode {\npublic:\n  using Parts = MSGuidDeclParts;\n\nprivate:\n  /// The decomposed form of the UUID.\n  Parts PartVal;\n\n  /// The resolved value of the UUID as an APValue. Computed on demand and\n  /// cached.\n  mutable APValue APVal;\n\n  void anchor() override;\n\n  MSGuidDecl(DeclContext *DC, QualType T, Parts P);\n\n  static MSGuidDecl *Create(const ASTContext &C, QualType T, Parts P);\n  static MSGuidDecl *CreateDeserialized(ASTContext &C, unsigned ID);\n\n  // Only ASTContext::getMSGuidDecl and deserialization create these.\n  friend class ASTContext;\n  friend class ASTReader;\n  friend class ASTDeclReader;\n\npublic:\n  /// Print this UUID in a human-readable format.\n  void printName(llvm::raw_ostream &OS) const override;\n\n  /// Get the decomposed parts of this declaration.\n  Parts getParts() const { return PartVal; }\n\n  /// Get the value of this MSGuidDecl as an APValue. This may fail and return\n  /// an absent APValue if the type of the declaration is not of the expected\n  /// shape.\n  APValue &getAsAPValue() const;\n\n  static void Profile(llvm::FoldingSetNodeID &ID, Parts P) {\n    ID.AddInteger(P.Part1);\n    ID.AddInteger(P.Part2);\n    ID.AddInteger(P.Part3);\n    ID.AddInteger(P.getPart4And5AsUint64());\n  }\n  void Profile(llvm::FoldingSetNodeID &ID) { Profile(ID, PartVal); }\n\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) { return K == Decl::MSGuid; }\n};\n\n/// Insertion operator for diagnostics.  This allows sending an AccessSpecifier\n/// into a diagnostic with <<.\nconst StreamingDiagnostic &operator<<(const StreamingDiagnostic &DB,\n                                      AccessSpecifier AS);\n\n} // namespace clang\n\n#endif // LLVM_CLANG_AST_DECLCXX_H\n"}, "7": {"id": 7, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/DeclObjC.h", "content": "//===- DeclObjC.h - Classes for representing declarations -------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n//  This file defines the DeclObjC interface and subclasses.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_AST_DECLOBJC_H\n#define LLVM_CLANG_AST_DECLOBJC_H\n\n#include \"clang/AST/Decl.h\"\n#include \"clang/AST/DeclBase.h\"\n#include \"clang/AST/DeclObjCCommon.h\"\n#include \"clang/AST/ExternalASTSource.h\"\n#include \"clang/AST/Redeclarable.h\"\n#include \"clang/AST/SelectorLocationsKind.h\"\n#include \"clang/AST/Type.h\"\n#include \"clang/Basic/IdentifierTable.h\"\n#include \"clang/Basic/LLVM.h\"\n#include \"clang/Basic/SourceLocation.h\"\n#include \"clang/Basic/Specifiers.h\"\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/ADT/DenseMap.h\"\n#include \"llvm/ADT/DenseSet.h\"\n#include \"llvm/ADT/None.h\"\n#include \"llvm/ADT/PointerIntPair.h\"\n#include \"llvm/ADT/STLExtras.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/ADT/iterator_range.h\"\n#include \"llvm/Support/Compiler.h\"\n#include \"llvm/Support/TrailingObjects.h\"\n#include <cassert>\n#include <cstddef>\n#include <cstdint>\n#include <iterator>\n#include <string>\n#include <utility>\n\nnamespace clang {\n\nclass ASTContext;\nclass CompoundStmt;\nclass CXXCtorInitializer;\nclass Expr;\nclass ObjCCategoryDecl;\nclass ObjCCategoryImplDecl;\nclass ObjCImplementationDecl;\nclass ObjCInterfaceDecl;\nclass ObjCIvarDecl;\nclass ObjCPropertyDecl;\nclass ObjCPropertyImplDecl;\nclass ObjCProtocolDecl;\nclass Stmt;\n\nclass ObjCListBase {\nprotected:\n  /// List is an array of pointers to objects that are not owned by this object.\n  void **List = nullptr;\n  unsigned NumElts = 0;\n\npublic:\n  ObjCListBase() = default;\n  ObjCListBase(const ObjCListBase &) = delete;\n  ObjCListBase &operator=(const ObjCListBase &) = delete;\n\n  unsigned size() const { return NumElts; }\n  bool empty() const { return NumElts == 0; }\n\nprotected:\n  void set(void *const* InList, unsigned Elts, ASTContext &Ctx);\n};\n\n/// ObjCList - This is a simple template class used to hold various lists of\n/// decls etc, which is heavily used by the ObjC front-end.  This only use case\n/// this supports is setting the list all at once and then reading elements out\n/// of it.\ntemplate <typename T>\nclass ObjCList : public ObjCListBase {\npublic:\n  void set(T* const* InList, unsigned Elts, ASTContext &Ctx) {\n    ObjCListBase::set(reinterpret_cast<void*const*>(InList), Elts, Ctx);\n  }\n\n  using iterator = T* const *;\n\n  iterator begin() const { return (iterator)List; }\n  iterator end() const { return (iterator)List+NumElts; }\n\n  T* operator[](unsigned Idx) const {\n    assert(Idx < NumElts && \"Invalid access\");\n    return (T*)List[Idx];\n  }\n};\n\n/// A list of Objective-C protocols, along with the source\n/// locations at which they were referenced.\nclass ObjCProtocolList : public ObjCList<ObjCProtocolDecl> {\n  SourceLocation *Locations = nullptr;\n\n  using ObjCList<ObjCProtocolDecl>::set;\n\npublic:\n  ObjCProtocolList() = default;\n\n  using loc_iterator = const SourceLocation *;\n\n  loc_iterator loc_begin() const { return Locations; }\n  loc_iterator loc_end() const { return Locations + size(); }\n\n  void set(ObjCProtocolDecl* const* InList, unsigned Elts,\n           const SourceLocation *Locs, ASTContext &Ctx);\n};\n\n/// ObjCMethodDecl - Represents an instance or class method declaration.\n/// ObjC methods can be declared within 4 contexts: class interfaces,\n/// categories, protocols, and class implementations. While C++ member\n/// functions leverage C syntax, Objective-C method syntax is modeled after\n/// Smalltalk (using colons to specify argument types/expressions).\n/// Here are some brief examples:\n///\n/// Setter/getter instance methods:\n/// - (void)setMenu:(NSMenu *)menu;\n/// - (NSMenu *)menu;\n///\n/// Instance method that takes 2 NSView arguments:\n/// - (void)replaceSubview:(NSView *)oldView with:(NSView *)newView;\n///\n/// Getter class method:\n/// + (NSMenu *)defaultMenu;\n///\n/// A selector represents a unique name for a method. The selector names for\n/// the above methods are setMenu:, menu, replaceSubview:with:, and defaultMenu.\n///\nclass ObjCMethodDecl : public NamedDecl, public DeclContext {\n  // This class stores some data in DeclContext::ObjCMethodDeclBits\n  // to save some space. Use the provided accessors to access it.\n\npublic:\n  enum ImplementationControl { None, Required, Optional };\n\nprivate:\n  /// Return type of this method.\n  QualType MethodDeclType;\n\n  /// Type source information for the return type.\n  TypeSourceInfo *ReturnTInfo;\n\n  /// Array of ParmVarDecls for the formal parameters of this method\n  /// and optionally followed by selector locations.\n  void *ParamsAndSelLocs = nullptr;\n  unsigned NumParams = 0;\n\n  /// List of attributes for this method declaration.\n  SourceLocation DeclEndLoc; // the location of the ';' or '{'.\n\n  /// The following are only used for method definitions, null otherwise.\n  LazyDeclStmtPtr Body;\n\n  /// SelfDecl - Decl for the implicit self parameter. This is lazily\n  /// constructed by createImplicitParams.\n  ImplicitParamDecl *SelfDecl = nullptr;\n\n  /// CmdDecl - Decl for the implicit _cmd parameter. This is lazily\n  /// constructed by createImplicitParams.\n  ImplicitParamDecl *CmdDecl = nullptr;\n\n  ObjCMethodDecl(SourceLocation beginLoc, SourceLocation endLoc,\n                 Selector SelInfo, QualType T, TypeSourceInfo *ReturnTInfo,\n                 DeclContext *contextDecl, bool isInstance = true,\n                 bool isVariadic = false, bool isPropertyAccessor = false,\n                 bool isSynthesizedAccessorStub = false, \n                 bool isImplicitlyDeclared = false, bool isDefined = false,\n                 ImplementationControl impControl = None,\n                 bool HasRelatedResultType = false);\n\n  SelectorLocationsKind getSelLocsKind() const {\n    return static_cast<SelectorLocationsKind>(ObjCMethodDeclBits.SelLocsKind);\n  }\n\n  void setSelLocsKind(SelectorLocationsKind Kind) {\n    ObjCMethodDeclBits.SelLocsKind = Kind;\n  }\n\n  bool hasStandardSelLocs() const {\n    return getSelLocsKind() != SelLoc_NonStandard;\n  }\n\n  /// Get a pointer to the stored selector identifiers locations array.\n  /// No locations will be stored if HasStandardSelLocs is true.\n  SourceLocation *getStoredSelLocs() {\n    return reinterpret_cast<SourceLocation *>(getParams() + NumParams);\n  }\n  const SourceLocation *getStoredSelLocs() const {\n    return reinterpret_cast<const SourceLocation *>(getParams() + NumParams);\n  }\n\n  /// Get a pointer to the stored selector identifiers locations array.\n  /// No locations will be stored if HasStandardSelLocs is true.\n  ParmVarDecl **getParams() {\n    return reinterpret_cast<ParmVarDecl **>(ParamsAndSelLocs);\n  }\n  const ParmVarDecl *const *getParams() const {\n    return reinterpret_cast<const ParmVarDecl *const *>(ParamsAndSelLocs);\n  }\n\n  /// Get the number of stored selector identifiers locations.\n  /// No locations will be stored if HasStandardSelLocs is true.\n  unsigned getNumStoredSelLocs() const {\n    if (hasStandardSelLocs())\n      return 0;\n    return getNumSelectorLocs();\n  }\n\n  void setParamsAndSelLocs(ASTContext &C,\n                           ArrayRef<ParmVarDecl*> Params,\n                           ArrayRef<SourceLocation> SelLocs);\n\n  /// A definition will return its interface declaration.\n  /// An interface declaration will return its definition.\n  /// Otherwise it will return itself.\n  ObjCMethodDecl *getNextRedeclarationImpl() override;\n\npublic:\n  friend class ASTDeclReader;\n  friend class ASTDeclWriter;\n\n  static ObjCMethodDecl *\n  Create(ASTContext &C, SourceLocation beginLoc, SourceLocation endLoc,\n         Selector SelInfo, QualType T, TypeSourceInfo *ReturnTInfo,\n         DeclContext *contextDecl, bool isInstance = true,\n         bool isVariadic = false, bool isPropertyAccessor = false,\n         bool isSynthesizedAccessorStub = false,\n         bool isImplicitlyDeclared = false, bool isDefined = false,\n         ImplementationControl impControl = None,\n         bool HasRelatedResultType = false);\n\n  static ObjCMethodDecl *CreateDeserialized(ASTContext &C, unsigned ID);\n\n  ObjCMethodDecl *getCanonicalDecl() override;\n  const ObjCMethodDecl *getCanonicalDecl() const {\n    return const_cast<ObjCMethodDecl*>(this)->getCanonicalDecl();\n  }\n\n  ObjCDeclQualifier getObjCDeclQualifier() const {\n    return static_cast<ObjCDeclQualifier>(ObjCMethodDeclBits.objcDeclQualifier);\n  }\n\n  void setObjCDeclQualifier(ObjCDeclQualifier QV) {\n    ObjCMethodDeclBits.objcDeclQualifier = QV;\n  }\n\n  /// Determine whether this method has a result type that is related\n  /// to the message receiver's type.\n  bool hasRelatedResultType() const {\n    return ObjCMethodDeclBits.RelatedResultType;\n  }\n\n  /// Note whether this method has a related result type.\n  void setRelatedResultType(bool RRT = true) {\n    ObjCMethodDeclBits.RelatedResultType = RRT;\n  }\n\n  /// True if this is a method redeclaration in the same interface.\n  bool isRedeclaration() const { return ObjCMethodDeclBits.IsRedeclaration; }\n  void setIsRedeclaration(bool RD) { ObjCMethodDeclBits.IsRedeclaration = RD; }\n  void setAsRedeclaration(const ObjCMethodDecl *PrevMethod);\n\n  /// True if redeclared in the same interface.\n  bool hasRedeclaration() const { return ObjCMethodDeclBits.HasRedeclaration; }\n  void setHasRedeclaration(bool HRD) const {\n    ObjCMethodDeclBits.HasRedeclaration = HRD;\n  }\n\n  /// Returns the location where the declarator ends. It will be\n  /// the location of ';' for a method declaration and the location of '{'\n  /// for a method definition.\n  SourceLocation getDeclaratorEndLoc() const { return DeclEndLoc; }\n\n  // Location information, modeled after the Stmt API.\n  SourceLocation getBeginLoc() const LLVM_READONLY { return getLocation(); }\n  SourceLocation getEndLoc() const LLVM_READONLY;\n  SourceRange getSourceRange() const override LLVM_READONLY {\n    return SourceRange(getLocation(), getEndLoc());\n  }\n\n  SourceLocation getSelectorStartLoc() const {\n    if (isImplicit())\n      return getBeginLoc();\n    return getSelectorLoc(0);\n  }\n\n  SourceLocation getSelectorLoc(unsigned Index) const {\n    assert(Index < getNumSelectorLocs() && \"Index out of range!\");\n    if (hasStandardSelLocs())\n      return getStandardSelectorLoc(Index, getSelector(),\n                                   getSelLocsKind() == SelLoc_StandardWithSpace,\n                                    parameters(),\n                                   DeclEndLoc);\n    return getStoredSelLocs()[Index];\n  }\n\n  void getSelectorLocs(SmallVectorImpl<SourceLocation> &SelLocs) const;\n\n  unsigned getNumSelectorLocs() const {\n    if (isImplicit())\n      return 0;\n    Selector Sel = getSelector();\n    if (Sel.isUnarySelector())\n      return 1;\n    return Sel.getNumArgs();\n  }\n\n  ObjCInterfaceDecl *getClassInterface();\n  const ObjCInterfaceDecl *getClassInterface() const {\n    return const_cast<ObjCMethodDecl*>(this)->getClassInterface();\n  }\n\n  /// If this method is declared or implemented in a category, return\n  /// that category.\n  ObjCCategoryDecl *getCategory();\n  const ObjCCategoryDecl *getCategory() const {\n    return const_cast<ObjCMethodDecl*>(this)->getCategory();\n  }\n\n  Selector getSelector() const { return getDeclName().getObjCSelector(); }\n\n  QualType getReturnType() const { return MethodDeclType; }\n  void setReturnType(QualType T) { MethodDeclType = T; }\n  SourceRange getReturnTypeSourceRange() const;\n\n  /// Determine the type of an expression that sends a message to this\n  /// function. This replaces the type parameters with the types they would\n  /// get if the receiver was parameterless (e.g. it may replace the type\n  /// parameter with 'id').\n  QualType getSendResultType() const;\n\n  /// Determine the type of an expression that sends a message to this\n  /// function with the given receiver type.\n  QualType getSendResultType(QualType receiverType) const;\n\n  TypeSourceInfo *getReturnTypeSourceInfo() const { return ReturnTInfo; }\n  void setReturnTypeSourceInfo(TypeSourceInfo *TInfo) { ReturnTInfo = TInfo; }\n\n  // Iterator access to formal parameters.\n  unsigned param_size() const { return NumParams; }\n\n  using param_const_iterator = const ParmVarDecl *const *;\n  using param_iterator = ParmVarDecl *const *;\n  using param_range = llvm::iterator_range<param_iterator>;\n  using param_const_range = llvm::iterator_range<param_const_iterator>;\n\n  param_const_iterator param_begin() const {\n    return param_const_iterator(getParams());\n  }\n\n  param_const_iterator param_end() const {\n    return param_const_iterator(getParams() + NumParams);\n  }\n\n  param_iterator param_begin() { return param_iterator(getParams()); }\n  param_iterator param_end() { return param_iterator(getParams() + NumParams); }\n\n  // This method returns and of the parameters which are part of the selector\n  // name mangling requirements.\n  param_const_iterator sel_param_end() const {\n    return param_begin() + getSelector().getNumArgs();\n  }\n\n  // ArrayRef access to formal parameters.  This should eventually\n  // replace the iterator interface above.\n  ArrayRef<ParmVarDecl*> parameters() const {\n    return llvm::makeArrayRef(const_cast<ParmVarDecl**>(getParams()),\n                              NumParams);\n  }\n\n  ParmVarDecl *getParamDecl(unsigned Idx) {\n    assert(Idx < NumParams && \"Index out of bounds!\");\n    return getParams()[Idx];\n  }\n  const ParmVarDecl *getParamDecl(unsigned Idx) const {\n    return const_cast<ObjCMethodDecl *>(this)->getParamDecl(Idx);\n  }\n\n  /// Sets the method's parameters and selector source locations.\n  /// If the method is implicit (not coming from source) \\p SelLocs is\n  /// ignored.\n  void setMethodParams(ASTContext &C,\n                       ArrayRef<ParmVarDecl*> Params,\n                       ArrayRef<SourceLocation> SelLocs = llvm::None);\n\n  // Iterator access to parameter types.\n  struct GetTypeFn {\n    QualType operator()(const ParmVarDecl *PD) const { return PD->getType(); }\n  };\n\n  using param_type_iterator =\n      llvm::mapped_iterator<param_const_iterator, GetTypeFn>;\n\n  param_type_iterator param_type_begin() const {\n    return llvm::map_iterator(param_begin(), GetTypeFn());\n  }\n\n  param_type_iterator param_type_end() const {\n    return llvm::map_iterator(param_end(), GetTypeFn());\n  }\n\n  /// createImplicitParams - Used to lazily create the self and cmd\n  /// implicit parameters. This must be called prior to using getSelfDecl()\n  /// or getCmdDecl(). The call is ignored if the implicit parameters\n  /// have already been created.\n  void createImplicitParams(ASTContext &Context, const ObjCInterfaceDecl *ID);\n\n  /// \\return the type for \\c self and set \\arg selfIsPseudoStrong and\n  /// \\arg selfIsConsumed accordingly.\n  QualType getSelfType(ASTContext &Context, const ObjCInterfaceDecl *OID,\n                       bool &selfIsPseudoStrong, bool &selfIsConsumed) const;\n\n  ImplicitParamDecl * getSelfDecl() const { return SelfDecl; }\n  void setSelfDecl(ImplicitParamDecl *SD) { SelfDecl = SD; }\n  ImplicitParamDecl * getCmdDecl() const { return CmdDecl; }\n  void setCmdDecl(ImplicitParamDecl *CD) { CmdDecl = CD; }\n\n  /// Determines the family of this method.\n  ObjCMethodFamily getMethodFamily() const;\n\n  bool isInstanceMethod() const { return ObjCMethodDeclBits.IsInstance; }\n  void setInstanceMethod(bool isInst) {\n    ObjCMethodDeclBits.IsInstance = isInst;\n  }\n\n  bool isVariadic() const { return ObjCMethodDeclBits.IsVariadic; }\n  void setVariadic(bool isVar) { ObjCMethodDeclBits.IsVariadic = isVar; }\n\n  bool isClassMethod() const { return !isInstanceMethod(); }\n\n  bool isPropertyAccessor() const {\n    return ObjCMethodDeclBits.IsPropertyAccessor;\n  }\n\n  void setPropertyAccessor(bool isAccessor) {\n    ObjCMethodDeclBits.IsPropertyAccessor = isAccessor;\n  }\n\n  bool isSynthesizedAccessorStub() const {\n    return ObjCMethodDeclBits.IsSynthesizedAccessorStub;\n  }\n\n  void setSynthesizedAccessorStub(bool isSynthesizedAccessorStub) {\n    ObjCMethodDeclBits.IsSynthesizedAccessorStub = isSynthesizedAccessorStub;\n  }\n\n  bool isDefined() const { return ObjCMethodDeclBits.IsDefined; }\n  void setDefined(bool isDefined) { ObjCMethodDeclBits.IsDefined = isDefined; }\n\n  /// Whether this method overrides any other in the class hierarchy.\n  ///\n  /// A method is said to override any method in the class's\n  /// base classes, its protocols, or its categories' protocols, that has\n  /// the same selector and is of the same kind (class or instance).\n  /// A method in an implementation is not considered as overriding the same\n  /// method in the interface or its categories.\n  bool isOverriding() const { return ObjCMethodDeclBits.IsOverriding; }\n  void setOverriding(bool IsOver) { ObjCMethodDeclBits.IsOverriding = IsOver; }\n\n  /// Return overridden methods for the given \\p Method.\n  ///\n  /// An ObjC method is considered to override any method in the class's\n  /// base classes (and base's categories), its protocols, or its categories'\n  /// protocols, that has\n  /// the same selector and is of the same kind (class or instance).\n  /// A method in an implementation is not considered as overriding the same\n  /// method in the interface or its categories.\n  void getOverriddenMethods(\n                     SmallVectorImpl<const ObjCMethodDecl *> &Overridden) const;\n\n  /// True if the method was a definition but its body was skipped.\n  bool hasSkippedBody() const { return ObjCMethodDeclBits.HasSkippedBody; }\n  void setHasSkippedBody(bool Skipped = true) {\n    ObjCMethodDeclBits.HasSkippedBody = Skipped;\n  }\n\n  /// True if the method is tagged as objc_direct\n  bool isDirectMethod() const;\n\n  /// Returns the property associated with this method's selector.\n  ///\n  /// Note that even if this particular method is not marked as a property\n  /// accessor, it is still possible for it to match a property declared in a\n  /// superclass. Pass \\c false if you only want to check the current class.\n  const ObjCPropertyDecl *findPropertyDecl(bool CheckOverrides = true) const;\n\n  // Related to protocols declared in  \\@protocol\n  void setDeclImplementation(ImplementationControl ic) {\n    ObjCMethodDeclBits.DeclImplementation = ic;\n  }\n\n  ImplementationControl getImplementationControl() const {\n    return ImplementationControl(ObjCMethodDeclBits.DeclImplementation);\n  }\n\n  bool isOptional() const {\n    return getImplementationControl() == Optional;\n  }\n\n  /// Returns true if this specific method declaration is marked with the\n  /// designated initializer attribute.\n  bool isThisDeclarationADesignatedInitializer() const;\n\n  /// Returns true if the method selector resolves to a designated initializer\n  /// in the class's interface.\n  ///\n  /// \\param InitMethod if non-null and the function returns true, it receives\n  /// the method declaration that was marked with the designated initializer\n  /// attribute.\n  bool isDesignatedInitializerForTheInterface(\n      const ObjCMethodDecl **InitMethod = nullptr) const;\n\n  /// Determine whether this method has a body.\n  bool hasBody() const override { return Body.isValid(); }\n\n  /// Retrieve the body of this method, if it has one.\n  Stmt *getBody() const override;\n\n  void setLazyBody(uint64_t Offset) { Body = Offset; }\n\n  CompoundStmt *getCompoundBody() { return (CompoundStmt*)getBody(); }\n  void setBody(Stmt *B) { Body = B; }\n\n  /// Returns whether this specific method is a definition.\n  bool isThisDeclarationADefinition() const { return hasBody(); }\n\n  /// Is this method defined in the NSObject base class?\n  bool definedInNSObject(const ASTContext &) const;\n\n  // Implement isa/cast/dyncast/etc.\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) { return K == ObjCMethod; }\n\n  static DeclContext *castToDeclContext(const ObjCMethodDecl *D) {\n    return static_cast<DeclContext *>(const_cast<ObjCMethodDecl*>(D));\n  }\n\n  static ObjCMethodDecl *castFromDeclContext(const DeclContext *DC) {\n    return static_cast<ObjCMethodDecl *>(const_cast<DeclContext*>(DC));\n  }\n};\n\n/// Describes the variance of a given generic parameter.\nenum class ObjCTypeParamVariance : uint8_t {\n  /// The parameter is invariant: must match exactly.\n  Invariant,\n\n  /// The parameter is covariant, e.g., X<T> is a subtype of X<U> when\n  /// the type parameter is covariant and T is a subtype of U.\n  Covariant,\n\n  /// The parameter is contravariant, e.g., X<T> is a subtype of X<U>\n  /// when the type parameter is covariant and U is a subtype of T.\n  Contravariant,\n};\n\n/// Represents the declaration of an Objective-C type parameter.\n///\n/// \\code\n/// @interface NSDictionary<Key : id<NSCopying>, Value>\n/// @end\n/// \\endcode\n///\n/// In the example above, both \\c Key and \\c Value are represented by\n/// \\c ObjCTypeParamDecl. \\c Key has an explicit bound of \\c id<NSCopying>,\n/// while \\c Value gets an implicit bound of \\c id.\n///\n/// Objective-C type parameters are typedef-names in the grammar,\nclass ObjCTypeParamDecl : public TypedefNameDecl {\n  /// Index of this type parameter in the type parameter list.\n  unsigned Index : 14;\n\n  /// The variance of the type parameter.\n  unsigned Variance : 2;\n\n  /// The location of the variance, if any.\n  SourceLocation VarianceLoc;\n\n  /// The location of the ':', which will be valid when the bound was\n  /// explicitly specified.\n  SourceLocation ColonLoc;\n\n  ObjCTypeParamDecl(ASTContext &ctx, DeclContext *dc,\n                    ObjCTypeParamVariance variance, SourceLocation varianceLoc,\n                    unsigned index,\n                    SourceLocation nameLoc, IdentifierInfo *name,\n                    SourceLocation colonLoc, TypeSourceInfo *boundInfo)\n      : TypedefNameDecl(ObjCTypeParam, ctx, dc, nameLoc, nameLoc, name,\n                        boundInfo),\n        Index(index), Variance(static_cast<unsigned>(variance)),\n        VarianceLoc(varianceLoc), ColonLoc(colonLoc) {}\n\n  void anchor() override;\n\npublic:\n  friend class ASTDeclReader;\n  friend class ASTDeclWriter;\n\n  static ObjCTypeParamDecl *Create(ASTContext &ctx, DeclContext *dc,\n                                   ObjCTypeParamVariance variance,\n                                   SourceLocation varianceLoc,\n                                   unsigned index,\n                                   SourceLocation nameLoc,\n                                   IdentifierInfo *name,\n                                   SourceLocation colonLoc,\n                                   TypeSourceInfo *boundInfo);\n  static ObjCTypeParamDecl *CreateDeserialized(ASTContext &ctx, unsigned ID);\n\n  SourceRange getSourceRange() const override LLVM_READONLY;\n\n  /// Determine the variance of this type parameter.\n  ObjCTypeParamVariance getVariance() const {\n    return static_cast<ObjCTypeParamVariance>(Variance);\n  }\n\n  /// Set the variance of this type parameter.\n  void setVariance(ObjCTypeParamVariance variance) {\n    Variance = static_cast<unsigned>(variance);\n  }\n\n  /// Retrieve the location of the variance keyword.\n  SourceLocation getVarianceLoc() const { return VarianceLoc; }\n\n  /// Retrieve the index into its type parameter list.\n  unsigned getIndex() const { return Index; }\n\n  /// Whether this type parameter has an explicitly-written type bound, e.g.,\n  /// \"T : NSView\".\n  bool hasExplicitBound() const { return ColonLoc.isValid(); }\n\n  /// Retrieve the location of the ':' separating the type parameter name\n  /// from the explicitly-specified bound.\n  SourceLocation getColonLoc() const { return ColonLoc; }\n\n  // Implement isa/cast/dyncast/etc.\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) { return K == ObjCTypeParam; }\n};\n\n/// Stores a list of Objective-C type parameters for a parameterized class\n/// or a category/extension thereof.\n///\n/// \\code\n/// @interface NSArray<T> // stores the <T>\n/// @end\n/// \\endcode\nclass ObjCTypeParamList final\n    : private llvm::TrailingObjects<ObjCTypeParamList, ObjCTypeParamDecl *> {\n  /// Location of the left and right angle brackets.\n  SourceRange Brackets;\n  /// The number of parameters in the list, which are tail-allocated.\n  unsigned NumParams;\n\n  ObjCTypeParamList(SourceLocation lAngleLoc,\n                    ArrayRef<ObjCTypeParamDecl *> typeParams,\n                    SourceLocation rAngleLoc);\n\npublic:\n  friend TrailingObjects;\n\n  /// Create a new Objective-C type parameter list.\n  static ObjCTypeParamList *create(ASTContext &ctx,\n                                   SourceLocation lAngleLoc,\n                                   ArrayRef<ObjCTypeParamDecl *> typeParams,\n                                   SourceLocation rAngleLoc);\n\n  /// Iterate through the type parameters in the list.\n  using iterator = ObjCTypeParamDecl **;\n\n  iterator begin() { return getTrailingObjects<ObjCTypeParamDecl *>(); }\n\n  iterator end() { return begin() + size(); }\n\n  /// Determine the number of type parameters in this list.\n  unsigned size() const { return NumParams; }\n\n  // Iterate through the type parameters in the list.\n  using const_iterator = ObjCTypeParamDecl * const *;\n\n  const_iterator begin() const {\n    return getTrailingObjects<ObjCTypeParamDecl *>();\n  }\n\n  const_iterator end() const {\n    return begin() + size();\n  }\n\n  ObjCTypeParamDecl *front() const {\n    assert(size() > 0 && \"empty Objective-C type parameter list\");\n    return *begin();\n  }\n\n  ObjCTypeParamDecl *back() const {\n    assert(size() > 0 && \"empty Objective-C type parameter list\");\n    return *(end() - 1);\n  }\n\n  SourceLocation getLAngleLoc() const { return Brackets.getBegin(); }\n  SourceLocation getRAngleLoc() const { return Brackets.getEnd(); }\n  SourceRange getSourceRange() const { return Brackets; }\n\n  /// Gather the default set of type arguments to be substituted for\n  /// these type parameters when dealing with an unspecialized type.\n  void gatherDefaultTypeArgs(SmallVectorImpl<QualType> &typeArgs) const;\n};\n\nenum class ObjCPropertyQueryKind : uint8_t {\n  OBJC_PR_query_unknown = 0x00,\n  OBJC_PR_query_instance,\n  OBJC_PR_query_class\n};\n\n/// Represents one property declaration in an Objective-C interface.\n///\n/// For example:\n/// \\code{.mm}\n/// \\@property (assign, readwrite) int MyProperty;\n/// \\endcode\nclass ObjCPropertyDecl : public NamedDecl {\n  void anchor() override;\n\npublic:\n  enum SetterKind { Assign, Retain, Copy, Weak };\n  enum PropertyControl { None, Required, Optional };\n\nprivate:\n  // location of \\@property\n  SourceLocation AtLoc;\n\n  // location of '(' starting attribute list or null.\n  SourceLocation LParenLoc;\n\n  QualType DeclType;\n  TypeSourceInfo *DeclTypeSourceInfo;\n  unsigned PropertyAttributes : NumObjCPropertyAttrsBits;\n  unsigned PropertyAttributesAsWritten : NumObjCPropertyAttrsBits;\n\n  // \\@required/\\@optional\n  unsigned PropertyImplementation : 2;\n\n  // getter name of NULL if no getter\n  Selector GetterName;\n\n  // setter name of NULL if no setter\n  Selector SetterName;\n\n  // location of the getter attribute's value\n  SourceLocation GetterNameLoc;\n\n  // location of the setter attribute's value\n  SourceLocation SetterNameLoc;\n\n  // Declaration of getter instance method\n  ObjCMethodDecl *GetterMethodDecl = nullptr;\n\n  // Declaration of setter instance method\n  ObjCMethodDecl *SetterMethodDecl = nullptr;\n\n  // Synthesize ivar for this property\n  ObjCIvarDecl *PropertyIvarDecl = nullptr;\n\n  ObjCPropertyDecl(DeclContext *DC, SourceLocation L, IdentifierInfo *Id,\n                   SourceLocation AtLocation, SourceLocation LParenLocation,\n                   QualType T, TypeSourceInfo *TSI, PropertyControl propControl)\n      : NamedDecl(ObjCProperty, DC, L, Id), AtLoc(AtLocation),\n        LParenLoc(LParenLocation), DeclType(T), DeclTypeSourceInfo(TSI),\n        PropertyAttributes(ObjCPropertyAttribute::kind_noattr),\n        PropertyAttributesAsWritten(ObjCPropertyAttribute::kind_noattr),\n        PropertyImplementation(propControl), GetterName(Selector()),\n        SetterName(Selector()) {}\n\npublic:\n  static ObjCPropertyDecl *Create(ASTContext &C, DeclContext *DC,\n                                  SourceLocation L,\n                                  IdentifierInfo *Id, SourceLocation AtLocation,\n                                  SourceLocation LParenLocation,\n                                  QualType T,\n                                  TypeSourceInfo *TSI,\n                                  PropertyControl propControl = None);\n\n  static ObjCPropertyDecl *CreateDeserialized(ASTContext &C, unsigned ID);\n\n  SourceLocation getAtLoc() const { return AtLoc; }\n  void setAtLoc(SourceLocation L) { AtLoc = L; }\n\n  SourceLocation getLParenLoc() const { return LParenLoc; }\n  void setLParenLoc(SourceLocation L) { LParenLoc = L; }\n\n  TypeSourceInfo *getTypeSourceInfo() const { return DeclTypeSourceInfo; }\n\n  QualType getType() const { return DeclType; }\n\n  void setType(QualType T, TypeSourceInfo *TSI) {\n    DeclType = T;\n    DeclTypeSourceInfo = TSI;\n  }\n\n  /// Retrieve the type when this property is used with a specific base object\n  /// type.\n  QualType getUsageType(QualType objectType) const;\n\n  ObjCPropertyAttribute::Kind getPropertyAttributes() const {\n    return ObjCPropertyAttribute::Kind(PropertyAttributes);\n  }\n\n  void setPropertyAttributes(ObjCPropertyAttribute::Kind PRVal) {\n    PropertyAttributes |= PRVal;\n  }\n\n  void overwritePropertyAttributes(unsigned PRVal) {\n    PropertyAttributes = PRVal;\n  }\n\n  ObjCPropertyAttribute::Kind getPropertyAttributesAsWritten() const {\n    return ObjCPropertyAttribute::Kind(PropertyAttributesAsWritten);\n  }\n\n  void setPropertyAttributesAsWritten(ObjCPropertyAttribute::Kind PRVal) {\n    PropertyAttributesAsWritten = PRVal;\n  }\n\n  // Helper methods for accessing attributes.\n\n  /// isReadOnly - Return true iff the property has a setter.\n  bool isReadOnly() const {\n    return (PropertyAttributes & ObjCPropertyAttribute::kind_readonly);\n  }\n\n  /// isAtomic - Return true if the property is atomic.\n  bool isAtomic() const {\n    return (PropertyAttributes & ObjCPropertyAttribute::kind_atomic);\n  }\n\n  /// isRetaining - Return true if the property retains its value.\n  bool isRetaining() const {\n    return (PropertyAttributes & (ObjCPropertyAttribute::kind_retain |\n                                  ObjCPropertyAttribute::kind_strong |\n                                  ObjCPropertyAttribute::kind_copy));\n  }\n\n  bool isInstanceProperty() const { return !isClassProperty(); }\n  bool isClassProperty() const {\n    return PropertyAttributes & ObjCPropertyAttribute::kind_class;\n  }\n  bool isDirectProperty() const {\n    return PropertyAttributes & ObjCPropertyAttribute::kind_direct;\n  }\n\n  ObjCPropertyQueryKind getQueryKind() const {\n    return isClassProperty() ? ObjCPropertyQueryKind::OBJC_PR_query_class :\n                               ObjCPropertyQueryKind::OBJC_PR_query_instance;\n  }\n\n  static ObjCPropertyQueryKind getQueryKind(bool isClassProperty) {\n    return isClassProperty ? ObjCPropertyQueryKind::OBJC_PR_query_class :\n                             ObjCPropertyQueryKind::OBJC_PR_query_instance;\n  }\n\n  /// getSetterKind - Return the method used for doing assignment in\n  /// the property setter. This is only valid if the property has been\n  /// defined to have a setter.\n  SetterKind getSetterKind() const {\n    if (PropertyAttributes & ObjCPropertyAttribute::kind_strong)\n      return getType()->isBlockPointerType() ? Copy : Retain;\n    if (PropertyAttributes & ObjCPropertyAttribute::kind_retain)\n      return Retain;\n    if (PropertyAttributes & ObjCPropertyAttribute::kind_copy)\n      return Copy;\n    if (PropertyAttributes & ObjCPropertyAttribute::kind_weak)\n      return Weak;\n    return Assign;\n  }\n\n  Selector getGetterName() const { return GetterName; }\n  SourceLocation getGetterNameLoc() const { return GetterNameLoc; }\n\n  void setGetterName(Selector Sel, SourceLocation Loc = SourceLocation()) {\n    GetterName = Sel;\n    GetterNameLoc = Loc;\n  }\n\n  Selector getSetterName() const { return SetterName; }\n  SourceLocation getSetterNameLoc() const { return SetterNameLoc; }\n\n  void setSetterName(Selector Sel, SourceLocation Loc = SourceLocation()) {\n    SetterName = Sel;\n    SetterNameLoc = Loc;\n  }\n\n  ObjCMethodDecl *getGetterMethodDecl() const { return GetterMethodDecl; }\n  void setGetterMethodDecl(ObjCMethodDecl *gDecl) { GetterMethodDecl = gDecl; }\n\n  ObjCMethodDecl *getSetterMethodDecl() const { return SetterMethodDecl; }\n  void setSetterMethodDecl(ObjCMethodDecl *gDecl) { SetterMethodDecl = gDecl; }\n\n  // Related to \\@optional/\\@required declared in \\@protocol\n  void setPropertyImplementation(PropertyControl pc) {\n    PropertyImplementation = pc;\n  }\n\n  PropertyControl getPropertyImplementation() const {\n    return PropertyControl(PropertyImplementation);\n  }\n\n  bool isOptional() const {\n    return getPropertyImplementation() == PropertyControl::Optional;\n  }\n\n  void setPropertyIvarDecl(ObjCIvarDecl *Ivar) {\n    PropertyIvarDecl = Ivar;\n  }\n\n  ObjCIvarDecl *getPropertyIvarDecl() const {\n    return PropertyIvarDecl;\n  }\n\n  SourceRange getSourceRange() const override LLVM_READONLY {\n    return SourceRange(AtLoc, getLocation());\n  }\n\n  /// Get the default name of the synthesized ivar.\n  IdentifierInfo *getDefaultSynthIvarName(ASTContext &Ctx) const;\n\n  /// Lookup a property by name in the specified DeclContext.\n  static ObjCPropertyDecl *findPropertyDecl(const DeclContext *DC,\n                                            const IdentifierInfo *propertyID,\n                                            ObjCPropertyQueryKind queryKind);\n\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) { return K == ObjCProperty; }\n};\n\n/// ObjCContainerDecl - Represents a container for method declarations.\n/// Current sub-classes are ObjCInterfaceDecl, ObjCCategoryDecl,\n/// ObjCProtocolDecl, and ObjCImplDecl.\n///\nclass ObjCContainerDecl : public NamedDecl, public DeclContext {\n  // This class stores some data in DeclContext::ObjCContainerDeclBits\n  // to save some space. Use the provided accessors to access it.\n\n  // These two locations in the range mark the end of the method container.\n  // The first points to the '@' token, and the second to the 'end' token.\n  SourceRange AtEnd;\n\n  void anchor() override;\n\npublic:\n  ObjCContainerDecl(Kind DK, DeclContext *DC, IdentifierInfo *Id,\n                    SourceLocation nameLoc, SourceLocation atStartLoc);\n\n  // Iterator access to instance/class properties.\n  using prop_iterator = specific_decl_iterator<ObjCPropertyDecl>;\n  using prop_range =\n      llvm::iterator_range<specific_decl_iterator<ObjCPropertyDecl>>;\n\n  prop_range properties() const { return prop_range(prop_begin(), prop_end()); }\n\n  prop_iterator prop_begin() const {\n    return prop_iterator(decls_begin());\n  }\n\n  prop_iterator prop_end() const {\n    return prop_iterator(decls_end());\n  }\n\n  using instprop_iterator =\n      filtered_decl_iterator<ObjCPropertyDecl,\n                             &ObjCPropertyDecl::isInstanceProperty>;\n  using instprop_range = llvm::iterator_range<instprop_iterator>;\n\n  instprop_range instance_properties() const {\n    return instprop_range(instprop_begin(), instprop_end());\n  }\n\n  instprop_iterator instprop_begin() const {\n    return instprop_iterator(decls_begin());\n  }\n\n  instprop_iterator instprop_end() const {\n    return instprop_iterator(decls_end());\n  }\n\n  using classprop_iterator =\n      filtered_decl_iterator<ObjCPropertyDecl,\n                             &ObjCPropertyDecl::isClassProperty>;\n  using classprop_range = llvm::iterator_range<classprop_iterator>;\n\n  classprop_range class_properties() const {\n    return classprop_range(classprop_begin(), classprop_end());\n  }\n\n  classprop_iterator classprop_begin() const {\n    return classprop_iterator(decls_begin());\n  }\n\n  classprop_iterator classprop_end() const {\n    return classprop_iterator(decls_end());\n  }\n\n  // Iterator access to instance/class methods.\n  using method_iterator = specific_decl_iterator<ObjCMethodDecl>;\n  using method_range =\n      llvm::iterator_range<specific_decl_iterator<ObjCMethodDecl>>;\n\n  method_range methods() const {\n    return method_range(meth_begin(), meth_end());\n  }\n\n  method_iterator meth_begin() const {\n    return method_iterator(decls_begin());\n  }\n\n  method_iterator meth_end() const {\n    return method_iterator(decls_end());\n  }\n\n  using instmeth_iterator =\n      filtered_decl_iterator<ObjCMethodDecl,\n                             &ObjCMethodDecl::isInstanceMethod>;\n  using instmeth_range = llvm::iterator_range<instmeth_iterator>;\n\n  instmeth_range instance_methods() const {\n    return instmeth_range(instmeth_begin(), instmeth_end());\n  }\n\n  instmeth_iterator instmeth_begin() const {\n    return instmeth_iterator(decls_begin());\n  }\n\n  instmeth_iterator instmeth_end() const {\n    return instmeth_iterator(decls_end());\n  }\n\n  using classmeth_iterator =\n      filtered_decl_iterator<ObjCMethodDecl,\n                             &ObjCMethodDecl::isClassMethod>;\n  using classmeth_range = llvm::iterator_range<classmeth_iterator>;\n\n  classmeth_range class_methods() const {\n    return classmeth_range(classmeth_begin(), classmeth_end());\n  }\n\n  classmeth_iterator classmeth_begin() const {\n    return classmeth_iterator(decls_begin());\n  }\n\n  classmeth_iterator classmeth_end() const {\n    return classmeth_iterator(decls_end());\n  }\n\n  // Get the local instance/class method declared in this interface.\n  ObjCMethodDecl *getMethod(Selector Sel, bool isInstance,\n                            bool AllowHidden = false) const;\n\n  ObjCMethodDecl *getInstanceMethod(Selector Sel,\n                                    bool AllowHidden = false) const {\n    return getMethod(Sel, true/*isInstance*/, AllowHidden);\n  }\n\n  ObjCMethodDecl *getClassMethod(Selector Sel, bool AllowHidden = false) const {\n    return getMethod(Sel, false/*isInstance*/, AllowHidden);\n  }\n\n  bool HasUserDeclaredSetterMethod(const ObjCPropertyDecl *P) const;\n  ObjCIvarDecl *getIvarDecl(IdentifierInfo *Id) const;\n\n  ObjCPropertyDecl *\n  FindPropertyDeclaration(const IdentifierInfo *PropertyId,\n                          ObjCPropertyQueryKind QueryKind) const;\n\n  using PropertyMap =\n      llvm::DenseMap<std::pair<IdentifierInfo *, unsigned/*isClassProperty*/>,\n                     ObjCPropertyDecl *>;\n  using ProtocolPropertySet = llvm::SmallDenseSet<const ObjCProtocolDecl *, 8>;\n  using PropertyDeclOrder = llvm::SmallVector<ObjCPropertyDecl *, 8>;\n\n  /// This routine collects list of properties to be implemented in the class.\n  /// This includes, class's and its conforming protocols' properties.\n  /// Note, the superclass's properties are not included in the list.\n  virtual void collectPropertiesToImplement(PropertyMap &PM,\n                                            PropertyDeclOrder &PO) const {}\n\n  SourceLocation getAtStartLoc() const { return ObjCContainerDeclBits.AtStart; }\n\n  void setAtStartLoc(SourceLocation Loc) {\n    ObjCContainerDeclBits.AtStart = Loc;\n  }\n\n  // Marks the end of the container.\n  SourceRange getAtEndRange() const { return AtEnd; }\n\n  void setAtEndRange(SourceRange atEnd) { AtEnd = atEnd; }\n\n  SourceRange getSourceRange() const override LLVM_READONLY {\n    return SourceRange(getAtStartLoc(), getAtEndRange().getEnd());\n  }\n\n  // Implement isa/cast/dyncast/etc.\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n\n  static bool classofKind(Kind K) {\n    return K >= firstObjCContainer &&\n           K <= lastObjCContainer;\n  }\n\n  static DeclContext *castToDeclContext(const ObjCContainerDecl *D) {\n    return static_cast<DeclContext *>(const_cast<ObjCContainerDecl*>(D));\n  }\n\n  static ObjCContainerDecl *castFromDeclContext(const DeclContext *DC) {\n    return static_cast<ObjCContainerDecl *>(const_cast<DeclContext*>(DC));\n  }\n};\n\n/// Represents an ObjC class declaration.\n///\n/// For example:\n///\n/// \\code\n///   // MostPrimitive declares no super class (not particularly useful).\n///   \\@interface MostPrimitive\n///     // no instance variables or methods.\n///   \\@end\n///\n///   // NSResponder inherits from NSObject & implements NSCoding (a protocol).\n///   \\@interface NSResponder : NSObject \\<NSCoding>\n///   { // instance variables are represented by ObjCIvarDecl.\n///     id nextResponder; // nextResponder instance variable.\n///   }\n///   - (NSResponder *)nextResponder; // return a pointer to NSResponder.\n///   - (void)mouseMoved:(NSEvent *)theEvent; // return void, takes a pointer\n///   \\@end                                    // to an NSEvent.\n/// \\endcode\n///\n///   Unlike C/C++, forward class declarations are accomplished with \\@class.\n///   Unlike C/C++, \\@class allows for a list of classes to be forward declared.\n///   Unlike C++, ObjC is a single-rooted class model. In Cocoa, classes\n///   typically inherit from NSObject (an exception is NSProxy).\n///\nclass ObjCInterfaceDecl : public ObjCContainerDecl\n                        , public Redeclarable<ObjCInterfaceDecl> {\n  friend class ASTContext;\n\n  /// TypeForDecl - This indicates the Type object that represents this\n  /// TypeDecl.  It is a cache maintained by ASTContext::getObjCInterfaceType\n  mutable const Type *TypeForDecl = nullptr;\n\n  struct DefinitionData {\n    /// The definition of this class, for quick access from any\n    /// declaration.\n    ObjCInterfaceDecl *Definition = nullptr;\n\n    /// When non-null, this is always an ObjCObjectType.\n    TypeSourceInfo *SuperClassTInfo = nullptr;\n\n    /// Protocols referenced in the \\@interface  declaration\n    ObjCProtocolList ReferencedProtocols;\n\n    /// Protocols reference in both the \\@interface and class extensions.\n    ObjCList<ObjCProtocolDecl> AllReferencedProtocols;\n\n    /// List of categories and class extensions defined for this class.\n    ///\n    /// Categories are stored as a linked list in the AST, since the categories\n    /// and class extensions come long after the initial interface declaration,\n    /// and we avoid dynamically-resized arrays in the AST wherever possible.\n    ObjCCategoryDecl *CategoryList = nullptr;\n\n    /// IvarList - List of all ivars defined by this class; including class\n    /// extensions and implementation. This list is built lazily.\n    ObjCIvarDecl *IvarList = nullptr;\n\n    /// Indicates that the contents of this Objective-C class will be\n    /// completed by the external AST source when required.\n    mutable unsigned ExternallyCompleted : 1;\n\n    /// Indicates that the ivar cache does not yet include ivars\n    /// declared in the implementation.\n    mutable unsigned IvarListMissingImplementation : 1;\n\n    /// Indicates that this interface decl contains at least one initializer\n    /// marked with the 'objc_designated_initializer' attribute.\n    unsigned HasDesignatedInitializers : 1;\n\n    enum InheritedDesignatedInitializersState {\n      /// We didn't calculate whether the designated initializers should be\n      /// inherited or not.\n      IDI_Unknown = 0,\n\n      /// Designated initializers are inherited for the super class.\n      IDI_Inherited = 1,\n\n      /// The class does not inherit designated initializers.\n      IDI_NotInherited = 2\n    };\n\n    /// One of the \\c InheritedDesignatedInitializersState enumeratos.\n    mutable unsigned InheritedDesignatedInitializers : 2;\n\n    /// The location of the last location in this declaration, before\n    /// the properties/methods. For example, this will be the '>', '}', or\n    /// identifier,\n    SourceLocation EndLoc;\n\n    DefinitionData()\n        : ExternallyCompleted(false), IvarListMissingImplementation(true),\n          HasDesignatedInitializers(false),\n          InheritedDesignatedInitializers(IDI_Unknown) {}\n  };\n\n  /// The type parameters associated with this class, if any.\n  ObjCTypeParamList *TypeParamList = nullptr;\n\n  /// Contains a pointer to the data associated with this class,\n  /// which will be NULL if this class has not yet been defined.\n  ///\n  /// The bit indicates when we don't need to check for out-of-date\n  /// declarations. It will be set unless modules are enabled.\n  llvm::PointerIntPair<DefinitionData *, 1, bool> Data;\n\n  ObjCInterfaceDecl(const ASTContext &C, DeclContext *DC, SourceLocation AtLoc,\n                    IdentifierInfo *Id, ObjCTypeParamList *typeParamList,\n                    SourceLocation CLoc, ObjCInterfaceDecl *PrevDecl,\n                    bool IsInternal);\n\n  void anchor() override;\n\n  void LoadExternalDefinition() const;\n\n  DefinitionData &data() const {\n    assert(Data.getPointer() && \"Declaration has no definition!\");\n    return *Data.getPointer();\n  }\n\n  /// Allocate the definition data for this class.\n  void allocateDefinitionData();\n\n  using redeclarable_base = Redeclarable<ObjCInterfaceDecl>;\n\n  ObjCInterfaceDecl *getNextRedeclarationImpl() override {\n    return getNextRedeclaration();\n  }\n\n  ObjCInterfaceDecl *getPreviousDeclImpl() override {\n    return getPreviousDecl();\n  }\n\n  ObjCInterfaceDecl *getMostRecentDeclImpl() override {\n    return getMostRecentDecl();\n  }\n\npublic:\n  static ObjCInterfaceDecl *Create(const ASTContext &C, DeclContext *DC,\n                                   SourceLocation atLoc,\n                                   IdentifierInfo *Id,\n                                   ObjCTypeParamList *typeParamList,\n                                   ObjCInterfaceDecl *PrevDecl,\n                                   SourceLocation ClassLoc = SourceLocation(),\n                                   bool isInternal = false);\n\n  static ObjCInterfaceDecl *CreateDeserialized(const ASTContext &C, unsigned ID);\n\n  /// Retrieve the type parameters of this class.\n  ///\n  /// This function looks for a type parameter list for the given\n  /// class; if the class has been declared (with \\c \\@class) but not\n  /// defined (with \\c \\@interface), it will search for a declaration that\n  /// has type parameters, skipping any declarations that do not.\n  ObjCTypeParamList *getTypeParamList() const;\n\n  /// Set the type parameters of this class.\n  ///\n  /// This function is used by the AST importer, which must import the type\n  /// parameters after creating their DeclContext to avoid loops.\n  void setTypeParamList(ObjCTypeParamList *TPL);\n\n  /// Retrieve the type parameters written on this particular declaration of\n  /// the class.\n  ObjCTypeParamList *getTypeParamListAsWritten() const {\n    return TypeParamList;\n  }\n\n  SourceRange getSourceRange() const override LLVM_READONLY {\n    if (isThisDeclarationADefinition())\n      return ObjCContainerDecl::getSourceRange();\n\n    return SourceRange(getAtStartLoc(), getLocation());\n  }\n\n  /// Indicate that this Objective-C class is complete, but that\n  /// the external AST source will be responsible for filling in its contents\n  /// when a complete class is required.\n  void setExternallyCompleted();\n\n  /// Indicate that this interface decl contains at least one initializer\n  /// marked with the 'objc_designated_initializer' attribute.\n  void setHasDesignatedInitializers();\n\n  /// Returns true if this interface decl contains at least one initializer\n  /// marked with the 'objc_designated_initializer' attribute.\n  bool hasDesignatedInitializers() const;\n\n  /// Returns true if this interface decl declares a designated initializer\n  /// or it inherites one from its super class.\n  bool declaresOrInheritsDesignatedInitializers() const {\n    return hasDesignatedInitializers() || inheritsDesignatedInitializers();\n  }\n\n  const ObjCProtocolList &getReferencedProtocols() const {\n    assert(hasDefinition() && \"Caller did not check for forward reference!\");\n    if (data().ExternallyCompleted)\n      LoadExternalDefinition();\n\n    return data().ReferencedProtocols;\n  }\n\n  ObjCImplementationDecl *getImplementation() const;\n  void setImplementation(ObjCImplementationDecl *ImplD);\n\n  ObjCCategoryDecl *FindCategoryDeclaration(IdentifierInfo *CategoryId) const;\n\n  // Get the local instance/class method declared in a category.\n  ObjCMethodDecl *getCategoryInstanceMethod(Selector Sel) const;\n  ObjCMethodDecl *getCategoryClassMethod(Selector Sel) const;\n\n  ObjCMethodDecl *getCategoryMethod(Selector Sel, bool isInstance) const {\n    return isInstance ? getCategoryInstanceMethod(Sel)\n                      : getCategoryClassMethod(Sel);\n  }\n\n  using protocol_iterator = ObjCProtocolList::iterator;\n  using protocol_range = llvm::iterator_range<protocol_iterator>;\n\n  protocol_range protocols() const {\n    return protocol_range(protocol_begin(), protocol_end());\n  }\n\n  protocol_iterator protocol_begin() const {\n    // FIXME: Should make sure no callers ever do this.\n    if (!hasDefinition())\n      return protocol_iterator();\n\n    if (data().ExternallyCompleted)\n      LoadExternalDefinition();\n\n    return data().ReferencedProtocols.begin();\n  }\n\n  protocol_iterator protocol_end() const {\n    // FIXME: Should make sure no callers ever do this.\n    if (!hasDefinition())\n      return protocol_iterator();\n\n    if (data().ExternallyCompleted)\n      LoadExternalDefinition();\n\n    return data().ReferencedProtocols.end();\n  }\n\n  using protocol_loc_iterator = ObjCProtocolList::loc_iterator;\n  using protocol_loc_range = llvm::iterator_range<protocol_loc_iterator>;\n\n  protocol_loc_range protocol_locs() const {\n    return protocol_loc_range(protocol_loc_begin(), protocol_loc_end());\n  }\n\n  protocol_loc_iterator protocol_loc_begin() const {\n    // FIXME: Should make sure no callers ever do this.\n    if (!hasDefinition())\n      return protocol_loc_iterator();\n\n    if (data().ExternallyCompleted)\n      LoadExternalDefinition();\n\n    return data().ReferencedProtocols.loc_begin();\n  }\n\n  protocol_loc_iterator protocol_loc_end() const {\n    // FIXME: Should make sure no callers ever do this.\n    if (!hasDefinition())\n      return protocol_loc_iterator();\n\n    if (data().ExternallyCompleted)\n      LoadExternalDefinition();\n\n    return data().ReferencedProtocols.loc_end();\n  }\n\n  using all_protocol_iterator = ObjCList<ObjCProtocolDecl>::iterator;\n  using all_protocol_range = llvm::iterator_range<all_protocol_iterator>;\n\n  all_protocol_range all_referenced_protocols() const {\n    return all_protocol_range(all_referenced_protocol_begin(),\n                              all_referenced_protocol_end());\n  }\n\n  all_protocol_iterator all_referenced_protocol_begin() const {\n    // FIXME: Should make sure no callers ever do this.\n    if (!hasDefinition())\n      return all_protocol_iterator();\n\n    if (data().ExternallyCompleted)\n      LoadExternalDefinition();\n\n    return data().AllReferencedProtocols.empty()\n             ? protocol_begin()\n             : data().AllReferencedProtocols.begin();\n  }\n\n  all_protocol_iterator all_referenced_protocol_end() const {\n    // FIXME: Should make sure no callers ever do this.\n    if (!hasDefinition())\n      return all_protocol_iterator();\n\n    if (data().ExternallyCompleted)\n      LoadExternalDefinition();\n\n    return data().AllReferencedProtocols.empty()\n             ? protocol_end()\n             : data().AllReferencedProtocols.end();\n  }\n\n  using ivar_iterator = specific_decl_iterator<ObjCIvarDecl>;\n  using ivar_range = llvm::iterator_range<specific_decl_iterator<ObjCIvarDecl>>;\n\n  ivar_range ivars() const { return ivar_range(ivar_begin(), ivar_end()); }\n\n  ivar_iterator ivar_begin() const {\n    if (const ObjCInterfaceDecl *Def = getDefinition())\n      return ivar_iterator(Def->decls_begin());\n\n    // FIXME: Should make sure no callers ever do this.\n    return ivar_iterator();\n  }\n\n  ivar_iterator ivar_end() const {\n    if (const ObjCInterfaceDecl *Def = getDefinition())\n      return ivar_iterator(Def->decls_end());\n\n    // FIXME: Should make sure no callers ever do this.\n    return ivar_iterator();\n  }\n\n  unsigned ivar_size() const {\n    return std::distance(ivar_begin(), ivar_end());\n  }\n\n  bool ivar_empty() const { return ivar_begin() == ivar_end(); }\n\n  ObjCIvarDecl *all_declared_ivar_begin();\n  const ObjCIvarDecl *all_declared_ivar_begin() const {\n    // Even though this modifies IvarList, it's conceptually const:\n    // the ivar chain is essentially a cached property of ObjCInterfaceDecl.\n    return const_cast<ObjCInterfaceDecl *>(this)->all_declared_ivar_begin();\n  }\n  void setIvarList(ObjCIvarDecl *ivar) { data().IvarList = ivar; }\n\n  /// setProtocolList - Set the list of protocols that this interface\n  /// implements.\n  void setProtocolList(ObjCProtocolDecl *const* List, unsigned Num,\n                       const SourceLocation *Locs, ASTContext &C) {\n    data().ReferencedProtocols.set(List, Num, Locs, C);\n  }\n\n  /// mergeClassExtensionProtocolList - Merge class extension's protocol list\n  /// into the protocol list for this class.\n  void mergeClassExtensionProtocolList(ObjCProtocolDecl *const* List,\n                                       unsigned Num,\n                                       ASTContext &C);\n\n  /// Produce a name to be used for class's metadata. It comes either via\n  /// objc_runtime_name attribute or class name.\n  StringRef getObjCRuntimeNameAsString() const;\n\n  /// Returns the designated initializers for the interface.\n  ///\n  /// If this declaration does not have methods marked as designated\n  /// initializers then the interface inherits the designated initializers of\n  /// its super class.\n  void getDesignatedInitializers(\n                  llvm::SmallVectorImpl<const ObjCMethodDecl *> &Methods) const;\n\n  /// Returns true if the given selector is a designated initializer for the\n  /// interface.\n  ///\n  /// If this declaration does not have methods marked as designated\n  /// initializers then the interface inherits the designated initializers of\n  /// its super class.\n  ///\n  /// \\param InitMethod if non-null and the function returns true, it receives\n  /// the method that was marked as a designated initializer.\n  bool\n  isDesignatedInitializer(Selector Sel,\n                          const ObjCMethodDecl **InitMethod = nullptr) const;\n\n  /// Determine whether this particular declaration of this class is\n  /// actually also a definition.\n  bool isThisDeclarationADefinition() const {\n    return getDefinition() == this;\n  }\n\n  /// Determine whether this class has been defined.\n  bool hasDefinition() const {\n    // If the name of this class is out-of-date, bring it up-to-date, which\n    // might bring in a definition.\n    // Note: a null value indicates that we don't have a definition and that\n    // modules are enabled.\n    if (!Data.getOpaqueValue())\n      getMostRecentDecl();\n\n    return Data.getPointer();\n  }\n\n  /// Retrieve the definition of this class, or NULL if this class\n  /// has been forward-declared (with \\@class) but not yet defined (with\n  /// \\@interface).\n  ObjCInterfaceDecl *getDefinition() {\n    return hasDefinition()? Data.getPointer()->Definition : nullptr;\n  }\n\n  /// Retrieve the definition of this class, or NULL if this class\n  /// has been forward-declared (with \\@class) but not yet defined (with\n  /// \\@interface).\n  const ObjCInterfaceDecl *getDefinition() const {\n    return hasDefinition()? Data.getPointer()->Definition : nullptr;\n  }\n\n  /// Starts the definition of this Objective-C class, taking it from\n  /// a forward declaration (\\@class) to a definition (\\@interface).\n  void startDefinition();\n\n  /// Retrieve the superclass type.\n  const ObjCObjectType *getSuperClassType() const {\n    if (TypeSourceInfo *TInfo = getSuperClassTInfo())\n      return TInfo->getType()->castAs<ObjCObjectType>();\n\n    return nullptr;\n  }\n\n  // Retrieve the type source information for the superclass.\n  TypeSourceInfo *getSuperClassTInfo() const {\n    // FIXME: Should make sure no callers ever do this.\n    if (!hasDefinition())\n      return nullptr;\n\n    if (data().ExternallyCompleted)\n      LoadExternalDefinition();\n\n    return data().SuperClassTInfo;\n  }\n\n  // Retrieve the declaration for the superclass of this class, which\n  // does not include any type arguments that apply to the superclass.\n  ObjCInterfaceDecl *getSuperClass() const;\n\n  void setSuperClass(TypeSourceInfo *superClass) {\n    data().SuperClassTInfo = superClass;\n  }\n\n  /// Iterator that walks over the list of categories, filtering out\n  /// those that do not meet specific criteria.\n  ///\n  /// This class template is used for the various permutations of category\n  /// and extension iterators.\n  template<bool (*Filter)(ObjCCategoryDecl *)>\n  class filtered_category_iterator {\n    ObjCCategoryDecl *Current = nullptr;\n\n    void findAcceptableCategory();\n\n  public:\n    using value_type = ObjCCategoryDecl *;\n    using reference = value_type;\n    using pointer = value_type;\n    using difference_type = std::ptrdiff_t;\n    using iterator_category = std::input_iterator_tag;\n\n    filtered_category_iterator() = default;\n    explicit filtered_category_iterator(ObjCCategoryDecl *Current)\n        : Current(Current) {\n      findAcceptableCategory();\n    }\n\n    reference operator*() const { return Current; }\n    pointer operator->() const { return Current; }\n\n    filtered_category_iterator &operator++();\n\n    filtered_category_iterator operator++(int) {\n      filtered_category_iterator Tmp = *this;\n      ++(*this);\n      return Tmp;\n    }\n\n    friend bool operator==(filtered_category_iterator X,\n                           filtered_category_iterator Y) {\n      return X.Current == Y.Current;\n    }\n\n    friend bool operator!=(filtered_category_iterator X,\n                           filtered_category_iterator Y) {\n      return X.Current != Y.Current;\n    }\n  };\n\nprivate:\n  /// Test whether the given category is visible.\n  ///\n  /// Used in the \\c visible_categories_iterator.\n  static bool isVisibleCategory(ObjCCategoryDecl *Cat);\n\npublic:\n  /// Iterator that walks over the list of categories and extensions\n  /// that are visible, i.e., not hidden in a non-imported submodule.\n  using visible_categories_iterator =\n      filtered_category_iterator<isVisibleCategory>;\n\n  using visible_categories_range =\n      llvm::iterator_range<visible_categories_iterator>;\n\n  visible_categories_range visible_categories() const {\n    return visible_categories_range(visible_categories_begin(),\n                                    visible_categories_end());\n  }\n\n  /// Retrieve an iterator to the beginning of the visible-categories\n  /// list.\n  visible_categories_iterator visible_categories_begin() const {\n    return visible_categories_iterator(getCategoryListRaw());\n  }\n\n  /// Retrieve an iterator to the end of the visible-categories list.\n  visible_categories_iterator visible_categories_end() const {\n    return visible_categories_iterator();\n  }\n\n  /// Determine whether the visible-categories list is empty.\n  bool visible_categories_empty() const {\n    return visible_categories_begin() == visible_categories_end();\n  }\n\nprivate:\n  /// Test whether the given category... is a category.\n  ///\n  /// Used in the \\c known_categories_iterator.\n  static bool isKnownCategory(ObjCCategoryDecl *) { return true; }\n\npublic:\n  /// Iterator that walks over all of the known categories and\n  /// extensions, including those that are hidden.\n  using known_categories_iterator = filtered_category_iterator<isKnownCategory>;\n  using known_categories_range =\n     llvm::iterator_range<known_categories_iterator>;\n\n  known_categories_range known_categories() const {\n    return known_categories_range(known_categories_begin(),\n                                  known_categories_end());\n  }\n\n  /// Retrieve an iterator to the beginning of the known-categories\n  /// list.\n  known_categories_iterator known_categories_begin() const {\n    return known_categories_iterator(getCategoryListRaw());\n  }\n\n  /// Retrieve an iterator to the end of the known-categories list.\n  known_categories_iterator known_categories_end() const {\n    return known_categories_iterator();\n  }\n\n  /// Determine whether the known-categories list is empty.\n  bool known_categories_empty() const {\n    return known_categories_begin() == known_categories_end();\n  }\n\nprivate:\n  /// Test whether the given category is a visible extension.\n  ///\n  /// Used in the \\c visible_extensions_iterator.\n  static bool isVisibleExtension(ObjCCategoryDecl *Cat);\n\npublic:\n  /// Iterator that walks over all of the visible extensions, skipping\n  /// any that are known but hidden.\n  using visible_extensions_iterator =\n      filtered_category_iterator<isVisibleExtension>;\n\n  using visible_extensions_range =\n      llvm::iterator_range<visible_extensions_iterator>;\n\n  visible_extensions_range visible_extensions() const {\n    return visible_extensions_range(visible_extensions_begin(),\n                                    visible_extensions_end());\n  }\n\n  /// Retrieve an iterator to the beginning of the visible-extensions\n  /// list.\n  visible_extensions_iterator visible_extensions_begin() const {\n    return visible_extensions_iterator(getCategoryListRaw());\n  }\n\n  /// Retrieve an iterator to the end of the visible-extensions list.\n  visible_extensions_iterator visible_extensions_end() const {\n    return visible_extensions_iterator();\n  }\n\n  /// Determine whether the visible-extensions list is empty.\n  bool visible_extensions_empty() const {\n    return visible_extensions_begin() == visible_extensions_end();\n  }\n\nprivate:\n  /// Test whether the given category is an extension.\n  ///\n  /// Used in the \\c known_extensions_iterator.\n  static bool isKnownExtension(ObjCCategoryDecl *Cat);\n\npublic:\n  friend class ASTDeclReader;\n  friend class ASTDeclWriter;\n  friend class ASTReader;\n\n  /// Iterator that walks over all of the known extensions.\n  using known_extensions_iterator =\n      filtered_category_iterator<isKnownExtension>;\n  using known_extensions_range =\n      llvm::iterator_range<known_extensions_iterator>;\n\n  known_extensions_range known_extensions() const {\n    return known_extensions_range(known_extensions_begin(),\n                                  known_extensions_end());\n  }\n\n  /// Retrieve an iterator to the beginning of the known-extensions\n  /// list.\n  known_extensions_iterator known_extensions_begin() const {\n    return known_extensions_iterator(getCategoryListRaw());\n  }\n\n  /// Retrieve an iterator to the end of the known-extensions list.\n  known_extensions_iterator known_extensions_end() const {\n    return known_extensions_iterator();\n  }\n\n  /// Determine whether the known-extensions list is empty.\n  bool known_extensions_empty() const {\n    return known_extensions_begin() == known_extensions_end();\n  }\n\n  /// Retrieve the raw pointer to the start of the category/extension\n  /// list.\n  ObjCCategoryDecl* getCategoryListRaw() const {\n    // FIXME: Should make sure no callers ever do this.\n    if (!hasDefinition())\n      return nullptr;\n\n    if (data().ExternallyCompleted)\n      LoadExternalDefinition();\n\n    return data().CategoryList;\n  }\n\n  /// Set the raw pointer to the start of the category/extension\n  /// list.\n  void setCategoryListRaw(ObjCCategoryDecl *category) {\n    data().CategoryList = category;\n  }\n\n  ObjCPropertyDecl\n    *FindPropertyVisibleInPrimaryClass(IdentifierInfo *PropertyId,\n                                       ObjCPropertyQueryKind QueryKind) const;\n\n  void collectPropertiesToImplement(PropertyMap &PM,\n                                    PropertyDeclOrder &PO) const override;\n\n  /// isSuperClassOf - Return true if this class is the specified class or is a\n  /// super class of the specified interface class.\n  bool isSuperClassOf(const ObjCInterfaceDecl *I) const {\n    // If RHS is derived from LHS it is OK; else it is not OK.\n    while (I != nullptr) {\n      if (declaresSameEntity(this, I))\n        return true;\n\n      I = I->getSuperClass();\n    }\n    return false;\n  }\n\n  /// isArcWeakrefUnavailable - Checks for a class or one of its super classes\n  /// to be incompatible with __weak references. Returns true if it is.\n  bool isArcWeakrefUnavailable() const;\n\n  /// isObjCRequiresPropertyDefs - Checks that a class or one of its super\n  /// classes must not be auto-synthesized. Returns class decl. if it must not\n  /// be; 0, otherwise.\n  const ObjCInterfaceDecl *isObjCRequiresPropertyDefs() const;\n\n  ObjCIvarDecl *lookupInstanceVariable(IdentifierInfo *IVarName,\n                                       ObjCInterfaceDecl *&ClassDeclared);\n  ObjCIvarDecl *lookupInstanceVariable(IdentifierInfo *IVarName) {\n    ObjCInterfaceDecl *ClassDeclared;\n    return lookupInstanceVariable(IVarName, ClassDeclared);\n  }\n\n  ObjCProtocolDecl *lookupNestedProtocol(IdentifierInfo *Name);\n\n  // Lookup a method. First, we search locally. If a method isn't\n  // found, we search referenced protocols and class categories.\n  ObjCMethodDecl *lookupMethod(Selector Sel, bool isInstance,\n                               bool shallowCategoryLookup = false,\n                               bool followSuper = true,\n                               const ObjCCategoryDecl *C = nullptr) const;\n\n  /// Lookup an instance method for a given selector.\n  ObjCMethodDecl *lookupInstanceMethod(Selector Sel) const {\n    return lookupMethod(Sel, true/*isInstance*/);\n  }\n\n  /// Lookup a class method for a given selector.\n  ObjCMethodDecl *lookupClassMethod(Selector Sel) const {\n    return lookupMethod(Sel, false/*isInstance*/);\n  }\n\n  ObjCInterfaceDecl *lookupInheritedClass(const IdentifierInfo *ICName);\n\n  /// Lookup a method in the classes implementation hierarchy.\n  ObjCMethodDecl *lookupPrivateMethod(const Selector &Sel,\n                                      bool Instance=true) const;\n\n  ObjCMethodDecl *lookupPrivateClassMethod(const Selector &Sel) {\n    return lookupPrivateMethod(Sel, false);\n  }\n\n  /// Lookup a setter or getter in the class hierarchy,\n  /// including in all categories except for category passed\n  /// as argument.\n  ObjCMethodDecl *lookupPropertyAccessor(const Selector Sel,\n                                         const ObjCCategoryDecl *Cat,\n                                         bool IsClassProperty) const {\n    return lookupMethod(Sel, !IsClassProperty/*isInstance*/,\n                        false/*shallowCategoryLookup*/,\n                        true /* followsSuper */,\n                        Cat);\n  }\n\n  SourceLocation getEndOfDefinitionLoc() const {\n    if (!hasDefinition())\n      return getLocation();\n\n    return data().EndLoc;\n  }\n\n  void setEndOfDefinitionLoc(SourceLocation LE) { data().EndLoc = LE; }\n\n  /// Retrieve the starting location of the superclass.\n  SourceLocation getSuperClassLoc() const;\n\n  /// isImplicitInterfaceDecl - check that this is an implicitly declared\n  /// ObjCInterfaceDecl node. This is for legacy objective-c \\@implementation\n  /// declaration without an \\@interface declaration.\n  bool isImplicitInterfaceDecl() const {\n    return hasDefinition() ? data().Definition->isImplicit() : isImplicit();\n  }\n\n  /// ClassImplementsProtocol - Checks that 'lProto' protocol\n  /// has been implemented in IDecl class, its super class or categories (if\n  /// lookupCategory is true).\n  bool ClassImplementsProtocol(ObjCProtocolDecl *lProto,\n                               bool lookupCategory,\n                               bool RHSIsQualifiedID = false);\n\n  using redecl_range = redeclarable_base::redecl_range;\n  using redecl_iterator = redeclarable_base::redecl_iterator;\n\n  using redeclarable_base::redecls_begin;\n  using redeclarable_base::redecls_end;\n  using redeclarable_base::redecls;\n  using redeclarable_base::getPreviousDecl;\n  using redeclarable_base::getMostRecentDecl;\n  using redeclarable_base::isFirstDecl;\n\n  /// Retrieves the canonical declaration of this Objective-C class.\n  ObjCInterfaceDecl *getCanonicalDecl() override { return getFirstDecl(); }\n  const ObjCInterfaceDecl *getCanonicalDecl() const { return getFirstDecl(); }\n\n  // Low-level accessor\n  const Type *getTypeForDecl() const { return TypeForDecl; }\n  void setTypeForDecl(const Type *TD) const { TypeForDecl = TD; }\n\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) { return K == ObjCInterface; }\n\nprivate:\n  const ObjCInterfaceDecl *findInterfaceWithDesignatedInitializers() const;\n  bool inheritsDesignatedInitializers() const;\n};\n\n/// ObjCIvarDecl - Represents an ObjC instance variable. In general, ObjC\n/// instance variables are identical to C. The only exception is Objective-C\n/// supports C++ style access control. For example:\n///\n///   \\@interface IvarExample : NSObject\n///   {\n///     id defaultToProtected;\n///   \\@public:\n///     id canBePublic; // same as C++.\n///   \\@protected:\n///     id canBeProtected; // same as C++.\n///   \\@package:\n///     id canBePackage; // framework visibility (not available in C++).\n///   }\n///\nclass ObjCIvarDecl : public FieldDecl {\n  void anchor() override;\n\npublic:\n  enum AccessControl {\n    None, Private, Protected, Public, Package\n  };\n\nprivate:\n  ObjCIvarDecl(ObjCContainerDecl *DC, SourceLocation StartLoc,\n               SourceLocation IdLoc, IdentifierInfo *Id,\n               QualType T, TypeSourceInfo *TInfo, AccessControl ac, Expr *BW,\n               bool synthesized)\n      : FieldDecl(ObjCIvar, DC, StartLoc, IdLoc, Id, T, TInfo, BW,\n                  /*Mutable=*/false, /*HasInit=*/ICIS_NoInit),\n        DeclAccess(ac), Synthesized(synthesized) {}\n\npublic:\n  static ObjCIvarDecl *Create(ASTContext &C, ObjCContainerDecl *DC,\n                              SourceLocation StartLoc, SourceLocation IdLoc,\n                              IdentifierInfo *Id, QualType T,\n                              TypeSourceInfo *TInfo,\n                              AccessControl ac, Expr *BW = nullptr,\n                              bool synthesized=false);\n\n  static ObjCIvarDecl *CreateDeserialized(ASTContext &C, unsigned ID);\n\n  /// Return the class interface that this ivar is logically contained\n  /// in; this is either the interface where the ivar was declared, or the\n  /// interface the ivar is conceptually a part of in the case of synthesized\n  /// ivars.\n  const ObjCInterfaceDecl *getContainingInterface() const;\n\n  ObjCIvarDecl *getNextIvar() { return NextIvar; }\n  const ObjCIvarDecl *getNextIvar() const { return NextIvar; }\n  void setNextIvar(ObjCIvarDecl *ivar) { NextIvar = ivar; }\n\n  void setAccessControl(AccessControl ac) { DeclAccess = ac; }\n\n  AccessControl getAccessControl() const { return AccessControl(DeclAccess); }\n\n  AccessControl getCanonicalAccessControl() const {\n    return DeclAccess == None ? Protected : AccessControl(DeclAccess);\n  }\n\n  void setSynthesize(bool synth) { Synthesized = synth; }\n  bool getSynthesize() const { return Synthesized; }\n\n  /// Retrieve the type of this instance variable when viewed as a member of a\n  /// specific object type.\n  QualType getUsageType(QualType objectType) const;\n\n  // Implement isa/cast/dyncast/etc.\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) { return K == ObjCIvar; }\n\nprivate:\n  /// NextIvar - Next Ivar in the list of ivars declared in class; class's\n  /// extensions and class's implementation\n  ObjCIvarDecl *NextIvar = nullptr;\n\n  // NOTE: VC++ treats enums as signed, avoid using the AccessControl enum\n  unsigned DeclAccess : 3;\n  unsigned Synthesized : 1;\n};\n\n/// Represents a field declaration created by an \\@defs(...).\nclass ObjCAtDefsFieldDecl : public FieldDecl {\n  ObjCAtDefsFieldDecl(DeclContext *DC, SourceLocation StartLoc,\n                      SourceLocation IdLoc, IdentifierInfo *Id,\n                      QualType T, Expr *BW)\n      : FieldDecl(ObjCAtDefsField, DC, StartLoc, IdLoc, Id, T,\n                  /*TInfo=*/nullptr, // FIXME: Do ObjCAtDefs have declarators ?\n                  BW, /*Mutable=*/false, /*HasInit=*/ICIS_NoInit) {}\n\n  void anchor() override;\n\npublic:\n  static ObjCAtDefsFieldDecl *Create(ASTContext &C, DeclContext *DC,\n                                     SourceLocation StartLoc,\n                                     SourceLocation IdLoc, IdentifierInfo *Id,\n                                     QualType T, Expr *BW);\n\n  static ObjCAtDefsFieldDecl *CreateDeserialized(ASTContext &C, unsigned ID);\n\n  // Implement isa/cast/dyncast/etc.\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) { return K == ObjCAtDefsField; }\n};\n\n/// Represents an Objective-C protocol declaration.\n///\n/// Objective-C protocols declare a pure abstract type (i.e., no instance\n/// variables are permitted).  Protocols originally drew inspiration from\n/// C++ pure virtual functions (a C++ feature with nice semantics and lousy\n/// syntax:-). Here is an example:\n///\n/// \\code\n/// \\@protocol NSDraggingInfo <refproto1, refproto2>\n/// - (NSWindow *)draggingDestinationWindow;\n/// - (NSImage *)draggedImage;\n/// \\@end\n/// \\endcode\n///\n/// This says that NSDraggingInfo requires two methods and requires everything\n/// that the two \"referenced protocols\" 'refproto1' and 'refproto2' require as\n/// well.\n///\n/// \\code\n/// \\@interface ImplementsNSDraggingInfo : NSObject \\<NSDraggingInfo>\n/// \\@end\n/// \\endcode\n///\n/// ObjC protocols inspired Java interfaces. Unlike Java, ObjC classes and\n/// protocols are in distinct namespaces. For example, Cocoa defines both\n/// an NSObject protocol and class (which isn't allowed in Java). As a result,\n/// protocols are referenced using angle brackets as follows:\n///\n/// id \\<NSDraggingInfo> anyObjectThatImplementsNSDraggingInfo;\nclass ObjCProtocolDecl : public ObjCContainerDecl,\n                         public Redeclarable<ObjCProtocolDecl> {\n  struct DefinitionData {\n    // The declaration that defines this protocol.\n    ObjCProtocolDecl *Definition;\n\n    /// Referenced protocols\n    ObjCProtocolList ReferencedProtocols;\n  };\n\n  /// Contains a pointer to the data associated with this class,\n  /// which will be NULL if this class has not yet been defined.\n  ///\n  /// The bit indicates when we don't need to check for out-of-date\n  /// declarations. It will be set unless modules are enabled.\n  llvm::PointerIntPair<DefinitionData *, 1, bool> Data;\n\n  ObjCProtocolDecl(ASTContext &C, DeclContext *DC, IdentifierInfo *Id,\n                   SourceLocation nameLoc, SourceLocation atStartLoc,\n                   ObjCProtocolDecl *PrevDecl);\n\n  void anchor() override;\n\n  DefinitionData &data() const {\n    assert(Data.getPointer() && \"Objective-C protocol has no definition!\");\n    return *Data.getPointer();\n  }\n\n  void allocateDefinitionData();\n\n  using redeclarable_base = Redeclarable<ObjCProtocolDecl>;\n\n  ObjCProtocolDecl *getNextRedeclarationImpl() override {\n    return getNextRedeclaration();\n  }\n\n  ObjCProtocolDecl *getPreviousDeclImpl() override {\n    return getPreviousDecl();\n  }\n\n  ObjCProtocolDecl *getMostRecentDeclImpl() override {\n    return getMostRecentDecl();\n  }\n\npublic:\n  friend class ASTDeclReader;\n  friend class ASTDeclWriter;\n  friend class ASTReader;\n\n  static ObjCProtocolDecl *Create(ASTContext &C, DeclContext *DC,\n                                  IdentifierInfo *Id,\n                                  SourceLocation nameLoc,\n                                  SourceLocation atStartLoc,\n                                  ObjCProtocolDecl *PrevDecl);\n\n  static ObjCProtocolDecl *CreateDeserialized(ASTContext &C, unsigned ID);\n\n  const ObjCProtocolList &getReferencedProtocols() const {\n    assert(hasDefinition() && \"No definition available!\");\n    return data().ReferencedProtocols;\n  }\n\n  using protocol_iterator = ObjCProtocolList::iterator;\n  using protocol_range = llvm::iterator_range<protocol_iterator>;\n\n  protocol_range protocols() const {\n    return protocol_range(protocol_begin(), protocol_end());\n  }\n\n  protocol_iterator protocol_begin() const {\n    if (!hasDefinition())\n      return protocol_iterator();\n\n    return data().ReferencedProtocols.begin();\n  }\n\n  protocol_iterator protocol_end() const {\n    if (!hasDefinition())\n      return protocol_iterator();\n\n    return data().ReferencedProtocols.end();\n  }\n\n  using protocol_loc_iterator = ObjCProtocolList::loc_iterator;\n  using protocol_loc_range = llvm::iterator_range<protocol_loc_iterator>;\n\n  protocol_loc_range protocol_locs() const {\n    return protocol_loc_range(protocol_loc_begin(), protocol_loc_end());\n  }\n\n  protocol_loc_iterator protocol_loc_begin() const {\n    if (!hasDefinition())\n      return protocol_loc_iterator();\n\n    return data().ReferencedProtocols.loc_begin();\n  }\n\n  protocol_loc_iterator protocol_loc_end() const {\n    if (!hasDefinition())\n      return protocol_loc_iterator();\n\n    return data().ReferencedProtocols.loc_end();\n  }\n\n  unsigned protocol_size() const {\n    if (!hasDefinition())\n      return 0;\n\n    return data().ReferencedProtocols.size();\n  }\n\n  /// setProtocolList - Set the list of protocols that this interface\n  /// implements.\n  void setProtocolList(ObjCProtocolDecl *const*List, unsigned Num,\n                       const SourceLocation *Locs, ASTContext &C) {\n    assert(hasDefinition() && \"Protocol is not defined\");\n    data().ReferencedProtocols.set(List, Num, Locs, C);\n  }\n\n  /// This is true iff the protocol is tagged with the\n  /// `objc_non_runtime_protocol` attribute.\n  bool isNonRuntimeProtocol() const;\n\n  /// Get the set of all protocols implied by this protocols inheritance\n  /// hierarchy.\n  void getImpliedProtocols(llvm::DenseSet<const ObjCProtocolDecl *> &IPs) const;\n\n  ObjCProtocolDecl *lookupProtocolNamed(IdentifierInfo *PName);\n\n  // Lookup a method. First, we search locally. If a method isn't\n  // found, we search referenced protocols and class categories.\n  ObjCMethodDecl *lookupMethod(Selector Sel, bool isInstance) const;\n\n  ObjCMethodDecl *lookupInstanceMethod(Selector Sel) const {\n    return lookupMethod(Sel, true/*isInstance*/);\n  }\n\n  ObjCMethodDecl *lookupClassMethod(Selector Sel) const {\n    return lookupMethod(Sel, false/*isInstance*/);\n  }\n\n  /// Determine whether this protocol has a definition.\n  bool hasDefinition() const {\n    // If the name of this protocol is out-of-date, bring it up-to-date, which\n    // might bring in a definition.\n    // Note: a null value indicates that we don't have a definition and that\n    // modules are enabled.\n    if (!Data.getOpaqueValue())\n      getMostRecentDecl();\n\n    return Data.getPointer();\n  }\n\n  /// Retrieve the definition of this protocol, if any.\n  ObjCProtocolDecl *getDefinition() {\n    return hasDefinition()? Data.getPointer()->Definition : nullptr;\n  }\n\n  /// Retrieve the definition of this protocol, if any.\n  const ObjCProtocolDecl *getDefinition() const {\n    return hasDefinition()? Data.getPointer()->Definition : nullptr;\n  }\n\n  /// Determine whether this particular declaration is also the\n  /// definition.\n  bool isThisDeclarationADefinition() const {\n    return getDefinition() == this;\n  }\n\n  /// Starts the definition of this Objective-C protocol.\n  void startDefinition();\n\n  /// Produce a name to be used for protocol's metadata. It comes either via\n  /// objc_runtime_name attribute or protocol name.\n  StringRef getObjCRuntimeNameAsString() const;\n\n  SourceRange getSourceRange() const override LLVM_READONLY {\n    if (isThisDeclarationADefinition())\n      return ObjCContainerDecl::getSourceRange();\n\n    return SourceRange(getAtStartLoc(), getLocation());\n  }\n\n  using redecl_range = redeclarable_base::redecl_range;\n  using redecl_iterator = redeclarable_base::redecl_iterator;\n\n  using redeclarable_base::redecls_begin;\n  using redeclarable_base::redecls_end;\n  using redeclarable_base::redecls;\n  using redeclarable_base::getPreviousDecl;\n  using redeclarable_base::getMostRecentDecl;\n  using redeclarable_base::isFirstDecl;\n\n  /// Retrieves the canonical declaration of this Objective-C protocol.\n  ObjCProtocolDecl *getCanonicalDecl() override { return getFirstDecl(); }\n  const ObjCProtocolDecl *getCanonicalDecl() const { return getFirstDecl(); }\n\n  void collectPropertiesToImplement(PropertyMap &PM,\n                                    PropertyDeclOrder &PO) const override;\n\n  void collectInheritedProtocolProperties(const ObjCPropertyDecl *Property,\n                                          ProtocolPropertySet &PS,\n                                          PropertyDeclOrder &PO) const;\n\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) { return K == ObjCProtocol; }\n};\n\n/// ObjCCategoryDecl - Represents a category declaration. A category allows\n/// you to add methods to an existing class (without subclassing or modifying\n/// the original class interface or implementation:-). Categories don't allow\n/// you to add instance data. The following example adds \"myMethod\" to all\n/// NSView's within a process:\n///\n/// \\@interface NSView (MyViewMethods)\n/// - myMethod;\n/// \\@end\n///\n/// Categories also allow you to split the implementation of a class across\n/// several files (a feature more naturally supported in C++).\n///\n/// Categories were originally inspired by dynamic languages such as Common\n/// Lisp and Smalltalk.  More traditional class-based languages (C++, Java)\n/// don't support this level of dynamism, which is both powerful and dangerous.\nclass ObjCCategoryDecl : public ObjCContainerDecl {\n  /// Interface belonging to this category\n  ObjCInterfaceDecl *ClassInterface;\n\n  /// The type parameters associated with this category, if any.\n  ObjCTypeParamList *TypeParamList = nullptr;\n\n  /// referenced protocols in this category.\n  ObjCProtocolList ReferencedProtocols;\n\n  /// Next category belonging to this class.\n  /// FIXME: this should not be a singly-linked list.  Move storage elsewhere.\n  ObjCCategoryDecl *NextClassCategory = nullptr;\n\n  /// The location of the category name in this declaration.\n  SourceLocation CategoryNameLoc;\n\n  /// class extension may have private ivars.\n  SourceLocation IvarLBraceLoc;\n  SourceLocation IvarRBraceLoc;\n\n  ObjCCategoryDecl(DeclContext *DC, SourceLocation AtLoc,\n                   SourceLocation ClassNameLoc, SourceLocation CategoryNameLoc,\n                   IdentifierInfo *Id, ObjCInterfaceDecl *IDecl,\n                   ObjCTypeParamList *typeParamList,\n                   SourceLocation IvarLBraceLoc = SourceLocation(),\n                   SourceLocation IvarRBraceLoc = SourceLocation());\n\n  void anchor() override;\n\npublic:\n  friend class ASTDeclReader;\n  friend class ASTDeclWriter;\n\n  static ObjCCategoryDecl *Create(ASTContext &C, DeclContext *DC,\n                                  SourceLocation AtLoc,\n                                  SourceLocation ClassNameLoc,\n                                  SourceLocation CategoryNameLoc,\n                                  IdentifierInfo *Id,\n                                  ObjCInterfaceDecl *IDecl,\n                                  ObjCTypeParamList *typeParamList,\n                                  SourceLocation IvarLBraceLoc=SourceLocation(),\n                                  SourceLocation IvarRBraceLoc=SourceLocation());\n  static ObjCCategoryDecl *CreateDeserialized(ASTContext &C, unsigned ID);\n\n  ObjCInterfaceDecl *getClassInterface() { return ClassInterface; }\n  const ObjCInterfaceDecl *getClassInterface() const { return ClassInterface; }\n\n  /// Retrieve the type parameter list associated with this category or\n  /// extension.\n  ObjCTypeParamList *getTypeParamList() const { return TypeParamList; }\n\n  /// Set the type parameters of this category.\n  ///\n  /// This function is used by the AST importer, which must import the type\n  /// parameters after creating their DeclContext to avoid loops.\n  void setTypeParamList(ObjCTypeParamList *TPL);\n\n\n  ObjCCategoryImplDecl *getImplementation() const;\n  void setImplementation(ObjCCategoryImplDecl *ImplD);\n\n  /// setProtocolList - Set the list of protocols that this interface\n  /// implements.\n  void setProtocolList(ObjCProtocolDecl *const*List, unsigned Num,\n                       const SourceLocation *Locs, ASTContext &C) {\n    ReferencedProtocols.set(List, Num, Locs, C);\n  }\n\n  const ObjCProtocolList &getReferencedProtocols() const {\n    return ReferencedProtocols;\n  }\n\n  using protocol_iterator = ObjCProtocolList::iterator;\n  using protocol_range = llvm::iterator_range<protocol_iterator>;\n\n  protocol_range protocols() const {\n    return protocol_range(protocol_begin(), protocol_end());\n  }\n\n  protocol_iterator protocol_begin() const {\n    return ReferencedProtocols.begin();\n  }\n\n  protocol_iterator protocol_end() const { return ReferencedProtocols.end(); }\n  unsigned protocol_size() const { return ReferencedProtocols.size(); }\n\n  using protocol_loc_iterator = ObjCProtocolList::loc_iterator;\n  using protocol_loc_range = llvm::iterator_range<protocol_loc_iterator>;\n\n  protocol_loc_range protocol_locs() const {\n    return protocol_loc_range(protocol_loc_begin(), protocol_loc_end());\n  }\n\n  protocol_loc_iterator protocol_loc_begin() const {\n    return ReferencedProtocols.loc_begin();\n  }\n\n  protocol_loc_iterator protocol_loc_end() const {\n    return ReferencedProtocols.loc_end();\n  }\n\n  ObjCCategoryDecl *getNextClassCategory() const { return NextClassCategory; }\n\n  /// Retrieve the pointer to the next stored category (or extension),\n  /// which may be hidden.\n  ObjCCategoryDecl *getNextClassCategoryRaw() const {\n    return NextClassCategory;\n  }\n\n  bool IsClassExtension() const { return getIdentifier() == nullptr; }\n\n  using ivar_iterator = specific_decl_iterator<ObjCIvarDecl>;\n  using ivar_range = llvm::iterator_range<specific_decl_iterator<ObjCIvarDecl>>;\n\n  ivar_range ivars() const { return ivar_range(ivar_begin(), ivar_end()); }\n\n  ivar_iterator ivar_begin() const {\n    return ivar_iterator(decls_begin());\n  }\n\n  ivar_iterator ivar_end() const {\n    return ivar_iterator(decls_end());\n  }\n\n  unsigned ivar_size() const {\n    return std::distance(ivar_begin(), ivar_end());\n  }\n\n  bool ivar_empty() const {\n    return ivar_begin() == ivar_end();\n  }\n\n  SourceLocation getCategoryNameLoc() const { return CategoryNameLoc; }\n  void setCategoryNameLoc(SourceLocation Loc) { CategoryNameLoc = Loc; }\n\n  void setIvarLBraceLoc(SourceLocation Loc) { IvarLBraceLoc = Loc; }\n  SourceLocation getIvarLBraceLoc() const { return IvarLBraceLoc; }\n  void setIvarRBraceLoc(SourceLocation Loc) { IvarRBraceLoc = Loc; }\n  SourceLocation getIvarRBraceLoc() const { return IvarRBraceLoc; }\n\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) { return K == ObjCCategory; }\n};\n\nclass ObjCImplDecl : public ObjCContainerDecl {\n  /// Class interface for this class/category implementation\n  ObjCInterfaceDecl *ClassInterface;\n\n  void anchor() override;\n\nprotected:\n  ObjCImplDecl(Kind DK, DeclContext *DC,\n               ObjCInterfaceDecl *classInterface,\n               IdentifierInfo *Id,\n               SourceLocation nameLoc, SourceLocation atStartLoc)\n      : ObjCContainerDecl(DK, DC, Id, nameLoc, atStartLoc),\n        ClassInterface(classInterface) {}\n\npublic:\n  const ObjCInterfaceDecl *getClassInterface() const { return ClassInterface; }\n  ObjCInterfaceDecl *getClassInterface() { return ClassInterface; }\n  void setClassInterface(ObjCInterfaceDecl *IFace);\n\n  void addInstanceMethod(ObjCMethodDecl *method) {\n    // FIXME: Context should be set correctly before we get here.\n    method->setLexicalDeclContext(this);\n    addDecl(method);\n  }\n\n  void addClassMethod(ObjCMethodDecl *method) {\n    // FIXME: Context should be set correctly before we get here.\n    method->setLexicalDeclContext(this);\n    addDecl(method);\n  }\n\n  void addPropertyImplementation(ObjCPropertyImplDecl *property);\n\n  ObjCPropertyImplDecl *FindPropertyImplDecl(IdentifierInfo *propertyId,\n                            ObjCPropertyQueryKind queryKind) const;\n  ObjCPropertyImplDecl *FindPropertyImplIvarDecl(IdentifierInfo *ivarId) const;\n\n  // Iterator access to properties.\n  using propimpl_iterator = specific_decl_iterator<ObjCPropertyImplDecl>;\n  using propimpl_range =\n      llvm::iterator_range<specific_decl_iterator<ObjCPropertyImplDecl>>;\n\n  propimpl_range property_impls() const {\n    return propimpl_range(propimpl_begin(), propimpl_end());\n  }\n\n  propimpl_iterator propimpl_begin() const {\n    return propimpl_iterator(decls_begin());\n  }\n\n  propimpl_iterator propimpl_end() const {\n    return propimpl_iterator(decls_end());\n  }\n\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n\n  static bool classofKind(Kind K) {\n    return K >= firstObjCImpl && K <= lastObjCImpl;\n  }\n};\n\n/// ObjCCategoryImplDecl - An object of this class encapsulates a category\n/// \\@implementation declaration. If a category class has declaration of a\n/// property, its implementation must be specified in the category's\n/// \\@implementation declaration. Example:\n/// \\@interface I \\@end\n/// \\@interface I(CATEGORY)\n///    \\@property int p1, d1;\n/// \\@end\n/// \\@implementation I(CATEGORY)\n///  \\@dynamic p1,d1;\n/// \\@end\n///\n/// ObjCCategoryImplDecl\nclass ObjCCategoryImplDecl : public ObjCImplDecl {\n  // Category name location\n  SourceLocation CategoryNameLoc;\n\n  ObjCCategoryImplDecl(DeclContext *DC, IdentifierInfo *Id,\n                       ObjCInterfaceDecl *classInterface,\n                       SourceLocation nameLoc, SourceLocation atStartLoc,\n                       SourceLocation CategoryNameLoc)\n      : ObjCImplDecl(ObjCCategoryImpl, DC, classInterface, Id,\n                     nameLoc, atStartLoc),\n        CategoryNameLoc(CategoryNameLoc) {}\n\n  void anchor() override;\n\npublic:\n  friend class ASTDeclReader;\n  friend class ASTDeclWriter;\n\n  static ObjCCategoryImplDecl *Create(ASTContext &C, DeclContext *DC,\n                                      IdentifierInfo *Id,\n                                      ObjCInterfaceDecl *classInterface,\n                                      SourceLocation nameLoc,\n                                      SourceLocation atStartLoc,\n                                      SourceLocation CategoryNameLoc);\n  static ObjCCategoryImplDecl *CreateDeserialized(ASTContext &C, unsigned ID);\n\n  ObjCCategoryDecl *getCategoryDecl() const;\n\n  SourceLocation getCategoryNameLoc() const { return CategoryNameLoc; }\n\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) { return K == ObjCCategoryImpl;}\n};\n\nraw_ostream &operator<<(raw_ostream &OS, const ObjCCategoryImplDecl &CID);\n\n/// ObjCImplementationDecl - Represents a class definition - this is where\n/// method definitions are specified. For example:\n///\n/// @code\n/// \\@implementation MyClass\n/// - (void)myMethod { /* do something */ }\n/// \\@end\n/// @endcode\n///\n/// In a non-fragile runtime, instance variables can appear in the class\n/// interface, class extensions (nameless categories), and in the implementation\n/// itself, as well as being synthesized as backing storage for properties.\n///\n/// In a fragile runtime, instance variables are specified in the class\n/// interface, \\em not in the implementation. Nevertheless (for legacy reasons),\n/// we allow instance variables to be specified in the implementation. When\n/// specified, they need to be \\em identical to the interface.\nclass ObjCImplementationDecl : public ObjCImplDecl {\n  /// Implementation Class's super class.\n  ObjCInterfaceDecl *SuperClass;\n  SourceLocation SuperLoc;\n\n  /// \\@implementation may have private ivars.\n  SourceLocation IvarLBraceLoc;\n  SourceLocation IvarRBraceLoc;\n\n  /// Support for ivar initialization.\n  /// The arguments used to initialize the ivars\n  LazyCXXCtorInitializersPtr IvarInitializers;\n  unsigned NumIvarInitializers = 0;\n\n  /// Do the ivars of this class require initialization other than\n  /// zero-initialization?\n  bool HasNonZeroConstructors : 1;\n\n  /// Do the ivars of this class require non-trivial destruction?\n  bool HasDestructors : 1;\n\n  ObjCImplementationDecl(DeclContext *DC,\n                         ObjCInterfaceDecl *classInterface,\n                         ObjCInterfaceDecl *superDecl,\n                         SourceLocation nameLoc, SourceLocation atStartLoc,\n                         SourceLocation superLoc = SourceLocation(),\n                         SourceLocation IvarLBraceLoc=SourceLocation(),\n                         SourceLocation IvarRBraceLoc=SourceLocation())\n      : ObjCImplDecl(ObjCImplementation, DC, classInterface,\n                     classInterface ? classInterface->getIdentifier()\n                                    : nullptr,\n                     nameLoc, atStartLoc),\n         SuperClass(superDecl), SuperLoc(superLoc),\n         IvarLBraceLoc(IvarLBraceLoc), IvarRBraceLoc(IvarRBraceLoc),\n         HasNonZeroConstructors(false), HasDestructors(false) {}\n\n  void anchor() override;\n\npublic:\n  friend class ASTDeclReader;\n  friend class ASTDeclWriter;\n\n  static ObjCImplementationDecl *Create(ASTContext &C, DeclContext *DC,\n                                        ObjCInterfaceDecl *classInterface,\n                                        ObjCInterfaceDecl *superDecl,\n                                        SourceLocation nameLoc,\n                                        SourceLocation atStartLoc,\n                                     SourceLocation superLoc = SourceLocation(),\n                                        SourceLocation IvarLBraceLoc=SourceLocation(),\n                                        SourceLocation IvarRBraceLoc=SourceLocation());\n\n  static ObjCImplementationDecl *CreateDeserialized(ASTContext &C, unsigned ID);\n\n  /// init_iterator - Iterates through the ivar initializer list.\n  using init_iterator = CXXCtorInitializer **;\n\n  /// init_const_iterator - Iterates through the ivar initializer list.\n  using init_const_iterator = CXXCtorInitializer * const *;\n\n  using init_range = llvm::iterator_range<init_iterator>;\n  using init_const_range = llvm::iterator_range<init_const_iterator>;\n\n  init_range inits() { return init_range(init_begin(), init_end()); }\n\n  init_const_range inits() const {\n    return init_const_range(init_begin(), init_end());\n  }\n\n  /// init_begin() - Retrieve an iterator to the first initializer.\n  init_iterator init_begin() {\n    const auto *ConstThis = this;\n    return const_cast<init_iterator>(ConstThis->init_begin());\n  }\n\n  /// begin() - Retrieve an iterator to the first initializer.\n  init_const_iterator init_begin() const;\n\n  /// init_end() - Retrieve an iterator past the last initializer.\n  init_iterator       init_end()       {\n    return init_begin() + NumIvarInitializers;\n  }\n\n  /// end() - Retrieve an iterator past the last initializer.\n  init_const_iterator init_end() const {\n    return init_begin() + NumIvarInitializers;\n  }\n\n  /// getNumArgs - Number of ivars which must be initialized.\n  unsigned getNumIvarInitializers() const {\n    return NumIvarInitializers;\n  }\n\n  void setNumIvarInitializers(unsigned numNumIvarInitializers) {\n    NumIvarInitializers = numNumIvarInitializers;\n  }\n\n  void setIvarInitializers(ASTContext &C,\n                           CXXCtorInitializer ** initializers,\n                           unsigned numInitializers);\n\n  /// Do any of the ivars of this class (not counting its base classes)\n  /// require construction other than zero-initialization?\n  bool hasNonZeroConstructors() const { return HasNonZeroConstructors; }\n  void setHasNonZeroConstructors(bool val) { HasNonZeroConstructors = val; }\n\n  /// Do any of the ivars of this class (not counting its base classes)\n  /// require non-trivial destruction?\n  bool hasDestructors() const { return HasDestructors; }\n  void setHasDestructors(bool val) { HasDestructors = val; }\n\n  /// getIdentifier - Get the identifier that names the class\n  /// interface associated with this implementation.\n  IdentifierInfo *getIdentifier() const {\n    return getClassInterface()->getIdentifier();\n  }\n\n  /// getName - Get the name of identifier for the class interface associated\n  /// with this implementation as a StringRef.\n  //\n  // FIXME: This is a bad API, we are hiding NamedDecl::getName with a different\n  // meaning.\n  StringRef getName() const {\n    assert(getIdentifier() && \"Name is not a simple identifier\");\n    return getIdentifier()->getName();\n  }\n\n  /// Get the name of the class associated with this interface.\n  //\n  // FIXME: Move to StringRef API.\n  std::string getNameAsString() const { return std::string(getName()); }\n\n  /// Produce a name to be used for class's metadata. It comes either via\n  /// class's objc_runtime_name attribute or class name.\n  StringRef getObjCRuntimeNameAsString() const;\n\n  const ObjCInterfaceDecl *getSuperClass() const { return SuperClass; }\n  ObjCInterfaceDecl *getSuperClass() { return SuperClass; }\n  SourceLocation getSuperClassLoc() const { return SuperLoc; }\n\n  void setSuperClass(ObjCInterfaceDecl * superCls) { SuperClass = superCls; }\n\n  void setIvarLBraceLoc(SourceLocation Loc) { IvarLBraceLoc = Loc; }\n  SourceLocation getIvarLBraceLoc() const { return IvarLBraceLoc; }\n  void setIvarRBraceLoc(SourceLocation Loc) { IvarRBraceLoc = Loc; }\n  SourceLocation getIvarRBraceLoc() const { return IvarRBraceLoc; }\n\n  using ivar_iterator = specific_decl_iterator<ObjCIvarDecl>;\n  using ivar_range = llvm::iterator_range<specific_decl_iterator<ObjCIvarDecl>>;\n\n  ivar_range ivars() const { return ivar_range(ivar_begin(), ivar_end()); }\n\n  ivar_iterator ivar_begin() const {\n    return ivar_iterator(decls_begin());\n  }\n\n  ivar_iterator ivar_end() const {\n    return ivar_iterator(decls_end());\n  }\n\n  unsigned ivar_size() const {\n    return std::distance(ivar_begin(), ivar_end());\n  }\n\n  bool ivar_empty() const {\n    return ivar_begin() == ivar_end();\n  }\n\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) { return K == ObjCImplementation; }\n};\n\nraw_ostream &operator<<(raw_ostream &OS, const ObjCImplementationDecl &ID);\n\n/// ObjCCompatibleAliasDecl - Represents alias of a class. This alias is\n/// declared as \\@compatibility_alias alias class.\nclass ObjCCompatibleAliasDecl : public NamedDecl {\n  /// Class that this is an alias of.\n  ObjCInterfaceDecl *AliasedClass;\n\n  ObjCCompatibleAliasDecl(DeclContext *DC, SourceLocation L, IdentifierInfo *Id,\n                          ObjCInterfaceDecl* aliasedClass)\n      : NamedDecl(ObjCCompatibleAlias, DC, L, Id), AliasedClass(aliasedClass) {}\n\n  void anchor() override;\n\npublic:\n  static ObjCCompatibleAliasDecl *Create(ASTContext &C, DeclContext *DC,\n                                         SourceLocation L, IdentifierInfo *Id,\n                                         ObjCInterfaceDecl* aliasedClass);\n\n  static ObjCCompatibleAliasDecl *CreateDeserialized(ASTContext &C,\n                                                     unsigned ID);\n\n  const ObjCInterfaceDecl *getClassInterface() const { return AliasedClass; }\n  ObjCInterfaceDecl *getClassInterface() { return AliasedClass; }\n  void setClassInterface(ObjCInterfaceDecl *D) { AliasedClass = D; }\n\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Kind K) { return K == ObjCCompatibleAlias; }\n};\n\n/// ObjCPropertyImplDecl - Represents implementation declaration of a property\n/// in a class or category implementation block. For example:\n/// \\@synthesize prop1 = ivar1;\n///\nclass ObjCPropertyImplDecl : public Decl {\npublic:\n  enum Kind {\n    Synthesize,\n    Dynamic\n  };\n\nprivate:\n  SourceLocation AtLoc;   // location of \\@synthesize or \\@dynamic\n\n  /// For \\@synthesize, the location of the ivar, if it was written in\n  /// the source code.\n  ///\n  /// \\code\n  /// \\@synthesize int a = b\n  /// \\endcode\n  SourceLocation IvarLoc;\n\n  /// Property declaration being implemented\n  ObjCPropertyDecl *PropertyDecl;\n\n  /// Null for \\@dynamic. Required for \\@synthesize.\n  ObjCIvarDecl *PropertyIvarDecl;\n\n  /// The getter's definition, which has an empty body if synthesized.\n  ObjCMethodDecl *GetterMethodDecl = nullptr;\n  /// The getter's definition, which has an empty body if synthesized.\n  ObjCMethodDecl *SetterMethodDecl = nullptr;\n\n  /// Null for \\@dynamic. Non-null if property must be copy-constructed in\n  /// getter.\n  Expr *GetterCXXConstructor = nullptr;\n\n  /// Null for \\@dynamic. Non-null if property has assignment operator to call\n  /// in Setter synthesis.\n  Expr *SetterCXXAssignment = nullptr;\n\n  ObjCPropertyImplDecl(DeclContext *DC, SourceLocation atLoc, SourceLocation L,\n                       ObjCPropertyDecl *property,\n                       Kind PK,\n                       ObjCIvarDecl *ivarDecl,\n                       SourceLocation ivarLoc)\n      : Decl(ObjCPropertyImpl, DC, L), AtLoc(atLoc),\n        IvarLoc(ivarLoc), PropertyDecl(property), PropertyIvarDecl(ivarDecl) {\n    assert(PK == Dynamic || PropertyIvarDecl);\n  }\n\npublic:\n  friend class ASTDeclReader;\n\n  static ObjCPropertyImplDecl *Create(ASTContext &C, DeclContext *DC,\n                                      SourceLocation atLoc, SourceLocation L,\n                                      ObjCPropertyDecl *property,\n                                      Kind PK,\n                                      ObjCIvarDecl *ivarDecl,\n                                      SourceLocation ivarLoc);\n\n  static ObjCPropertyImplDecl *CreateDeserialized(ASTContext &C, unsigned ID);\n\n  SourceRange getSourceRange() const override LLVM_READONLY;\n\n  SourceLocation getBeginLoc() const LLVM_READONLY { return AtLoc; }\n  void setAtLoc(SourceLocation Loc) { AtLoc = Loc; }\n\n  ObjCPropertyDecl *getPropertyDecl() const {\n    return PropertyDecl;\n  }\n  void setPropertyDecl(ObjCPropertyDecl *Prop) { PropertyDecl = Prop; }\n\n  Kind getPropertyImplementation() const {\n    return PropertyIvarDecl ? Synthesize : Dynamic;\n  }\n\n  ObjCIvarDecl *getPropertyIvarDecl() const {\n    return PropertyIvarDecl;\n  }\n  SourceLocation getPropertyIvarDeclLoc() const { return IvarLoc; }\n\n  void setPropertyIvarDecl(ObjCIvarDecl *Ivar,\n                           SourceLocation IvarLoc) {\n    PropertyIvarDecl = Ivar;\n    this->IvarLoc = IvarLoc;\n  }\n\n  /// For \\@synthesize, returns true if an ivar name was explicitly\n  /// specified.\n  ///\n  /// \\code\n  /// \\@synthesize int a = b; // true\n  /// \\@synthesize int a; // false\n  /// \\endcode\n  bool isIvarNameSpecified() const {\n    return IvarLoc.isValid() && IvarLoc != getLocation();\n  }\n\n  ObjCMethodDecl *getGetterMethodDecl() const { return GetterMethodDecl; }\n  void setGetterMethodDecl(ObjCMethodDecl *MD) { GetterMethodDecl = MD; }\n\n  ObjCMethodDecl *getSetterMethodDecl() const { return SetterMethodDecl; }\n  void setSetterMethodDecl(ObjCMethodDecl *MD) { SetterMethodDecl = MD; }\n\n  Expr *getGetterCXXConstructor() const {\n    return GetterCXXConstructor;\n  }\n\n  void setGetterCXXConstructor(Expr *getterCXXConstructor) {\n    GetterCXXConstructor = getterCXXConstructor;\n  }\n\n  Expr *getSetterCXXAssignment() const {\n    return SetterCXXAssignment;\n  }\n\n  void setSetterCXXAssignment(Expr *setterCXXAssignment) {\n    SetterCXXAssignment = setterCXXAssignment;\n  }\n\n  static bool classof(const Decl *D) { return classofKind(D->getKind()); }\n  static bool classofKind(Decl::Kind K) { return K == ObjCPropertyImpl; }\n};\n\ntemplate<bool (*Filter)(ObjCCategoryDecl *)>\nvoid\nObjCInterfaceDecl::filtered_category_iterator<Filter>::\nfindAcceptableCategory() {\n  while (Current && !Filter(Current))\n    Current = Current->getNextClassCategoryRaw();\n}\n\ntemplate<bool (*Filter)(ObjCCategoryDecl *)>\ninline ObjCInterfaceDecl::filtered_category_iterator<Filter> &\nObjCInterfaceDecl::filtered_category_iterator<Filter>::operator++() {\n  Current = Current->getNextClassCategoryRaw();\n  findAcceptableCategory();\n  return *this;\n}\n\ninline bool ObjCInterfaceDecl::isVisibleCategory(ObjCCategoryDecl *Cat) {\n  return Cat->isUnconditionallyVisible();\n}\n\ninline bool ObjCInterfaceDecl::isVisibleExtension(ObjCCategoryDecl *Cat) {\n  return Cat->IsClassExtension() && Cat->isUnconditionallyVisible();\n}\n\ninline bool ObjCInterfaceDecl::isKnownExtension(ObjCCategoryDecl *Cat) {\n  return Cat->IsClassExtension();\n}\n\n} // namespace clang\n\n#endif // LLVM_CLANG_AST_DECLOBJC_H\n"}, "8": {"id": 8, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/DeclarationName.h", "content": "//===- DeclarationName.h - Representation of declaration names --*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file declares the DeclarationName and DeclarationNameTable classes.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_AST_DECLARATIONNAME_H\n#define LLVM_CLANG_AST_DECLARATIONNAME_H\n\n#include \"clang/AST/Type.h\"\n#include \"clang/Basic/Diagnostic.h\"\n#include \"clang/Basic/IdentifierTable.h\"\n#include \"clang/Basic/OperatorKinds.h\"\n#include \"clang/Basic/PartialDiagnostic.h\"\n#include \"clang/Basic/SourceLocation.h\"\n#include \"llvm/ADT/DenseMapInfo.h\"\n#include \"llvm/ADT/FoldingSet.h\"\n#include \"llvm/Support/Compiler.h\"\n#include \"llvm/Support/type_traits.h\"\n#include <cassert>\n#include <cstdint>\n#include <cstring>\n#include <string>\n\nnamespace clang {\n\nclass ASTContext;\ntemplate <typename> class CanQual;\nclass DeclarationName;\nclass DeclarationNameTable;\nclass MultiKeywordSelector;\nstruct PrintingPolicy;\nclass TemplateDecl;\nclass TypeSourceInfo;\nclass UsingDirectiveDecl;\n\nusing CanQualType = CanQual<Type>;\n\nnamespace detail {\n\n/// CXXSpecialNameExtra records the type associated with one of the \"special\"\n/// kinds of declaration names in C++, e.g., constructors, destructors, and\n/// conversion functions. Note that CXXSpecialName is used for C++ constructor,\n/// destructor and conversion functions, but the actual kind is not stored in\n/// CXXSpecialName. Instead we use three different FoldingSet<CXXSpecialName>\n/// in DeclarationNameTable.\nclass alignas(IdentifierInfoAlignment) CXXSpecialNameExtra\n    : public llvm::FoldingSetNode {\n  friend class clang::DeclarationName;\n  friend class clang::DeclarationNameTable;\n\n  /// The type associated with this declaration name.\n  QualType Type;\n\n  /// Extra information associated with this declaration name that\n  /// can be used by the front end. All bits are really needed\n  /// so it is not possible to stash something in the low order bits.\n  void *FETokenInfo;\n\n  CXXSpecialNameExtra(QualType QT) : Type(QT), FETokenInfo(nullptr) {}\n\npublic:\n  void Profile(llvm::FoldingSetNodeID &ID) {\n    ID.AddPointer(Type.getAsOpaquePtr());\n  }\n};\n\n/// Contains extra information for the name of a C++ deduction guide.\nclass alignas(IdentifierInfoAlignment) CXXDeductionGuideNameExtra\n    : public detail::DeclarationNameExtra,\n      public llvm::FoldingSetNode {\n  friend class clang::DeclarationName;\n  friend class clang::DeclarationNameTable;\n\n  /// The template named by the deduction guide.\n  TemplateDecl *Template;\n\n  /// Extra information associated with this operator name that\n  /// can be used by the front end. All bits are really needed\n  /// so it is not possible to stash something in the low order bits.\n  void *FETokenInfo;\n\n  CXXDeductionGuideNameExtra(TemplateDecl *TD)\n      : DeclarationNameExtra(CXXDeductionGuideName), Template(TD),\n        FETokenInfo(nullptr) {}\n\npublic:\n  void Profile(llvm::FoldingSetNodeID &ID) { ID.AddPointer(Template); }\n};\n\n/// Contains extra information for the name of an overloaded operator\n/// in C++, such as \"operator+. This do not includes literal or conversion\n/// operators. For literal operators see CXXLiteralOperatorIdName and for\n/// conversion operators see CXXSpecialNameExtra.\nclass alignas(IdentifierInfoAlignment) CXXOperatorIdName {\n  friend class clang::DeclarationName;\n  friend class clang::DeclarationNameTable;\n\n  /// The kind of this operator.\n  OverloadedOperatorKind Kind = OO_None;\n\n  /// Extra information associated with this operator name that\n  /// can be used by the front end. All bits are really needed\n  /// so it is not possible to stash something in the low order bits.\n  void *FETokenInfo = nullptr;\n};\n\n/// Contains the actual identifier that makes up the\n/// name of a C++ literal operator.\nclass alignas(IdentifierInfoAlignment) CXXLiteralOperatorIdName\n    : public detail::DeclarationNameExtra,\n      public llvm::FoldingSetNode {\n  friend class clang::DeclarationName;\n  friend class clang::DeclarationNameTable;\n\n  IdentifierInfo *ID;\n\n  /// Extra information associated with this operator name that\n  /// can be used by the front end. All bits are really needed\n  /// so it is not possible to stash something in the low order bits.\n  void *FETokenInfo;\n\n  CXXLiteralOperatorIdName(IdentifierInfo *II)\n      : DeclarationNameExtra(CXXLiteralOperatorName), ID(II),\n        FETokenInfo(nullptr) {}\n\npublic:\n  void Profile(llvm::FoldingSetNodeID &FSID) { FSID.AddPointer(ID); }\n};\n\n} // namespace detail\n\n/// The name of a declaration. In the common case, this just stores\n/// an IdentifierInfo pointer to a normal name. However, it also provides\n/// encodings for Objective-C selectors (optimizing zero- and one-argument\n/// selectors, which make up 78% percent of all selectors in Cocoa.h),\n/// special C++ names for constructors, destructors, and conversion functions,\n/// and C++ overloaded operators.\nclass DeclarationName {\n  friend class DeclarationNameTable;\n  friend class NamedDecl;\n\n  /// StoredNameKind represent the kind of name that is actually stored in the\n  /// upper bits of the Ptr field. This is only used internally.\n  ///\n  /// NameKind, StoredNameKind, and DeclarationNameExtra::ExtraKind\n  /// must satisfy the following properties. These properties enable\n  /// efficient conversion between the various kinds.\n  ///\n  /// * The first seven enumerators of StoredNameKind must have the same\n  ///   numerical value as the first seven enumerators of NameKind.\n  ///   This enable efficient conversion between the two enumerations\n  ///   in the usual case.\n  ///\n  /// * The enumerations values of DeclarationNameExtra::ExtraKind must start\n  ///   at zero, and correspond to the numerical value of the first non-inline\n  ///   enumeration values of NameKind minus an offset. This makes conversion\n  ///   between DeclarationNameExtra::ExtraKind and NameKind possible with\n  ///   a single addition/substraction.\n  ///\n  /// * The enumeration values of Selector::IdentifierInfoFlag must correspond\n  ///   to the relevant enumeration values of StoredNameKind.\n  ///   More specifically:\n  ///    * ZeroArg == StoredObjCZeroArgSelector,\n  ///    * OneArg == StoredObjCOneArgSelector,\n  ///    * MultiArg == StoredDeclarationNameExtra\n  ///\n  /// * PtrMask must mask the low 3 bits of Ptr.\n  enum StoredNameKind {\n    StoredIdentifier = 0,\n    StoredObjCZeroArgSelector = Selector::ZeroArg,\n    StoredObjCOneArgSelector = Selector::OneArg,\n    StoredCXXConstructorName = 3,\n    StoredCXXDestructorName = 4,\n    StoredCXXConversionFunctionName = 5,\n    StoredCXXOperatorName = 6,\n    StoredDeclarationNameExtra = Selector::MultiArg,\n    PtrMask = 7,\n    UncommonNameKindOffset = 8\n  };\n\n  static_assert(alignof(IdentifierInfo) >= 8 &&\n                    alignof(detail::DeclarationNameExtra) >= 8 &&\n                    alignof(detail::CXXSpecialNameExtra) >= 8 &&\n                    alignof(detail::CXXOperatorIdName) >= 8 &&\n                    alignof(detail::CXXDeductionGuideNameExtra) >= 8 &&\n                    alignof(detail::CXXLiteralOperatorIdName) >= 8,\n                \"The various classes that DeclarationName::Ptr can point to\"\n                \" must be at least aligned to 8 bytes!\");\n\npublic:\n  /// The kind of the name stored in this DeclarationName.\n  /// The first 7 enumeration values are stored inline and correspond\n  /// to frequently used kinds. The rest is stored in DeclarationNameExtra\n  /// and correspond to infrequently used kinds.\n  enum NameKind {\n    Identifier = StoredIdentifier,\n    ObjCZeroArgSelector = StoredObjCZeroArgSelector,\n    ObjCOneArgSelector = StoredObjCOneArgSelector,\n    CXXConstructorName = StoredCXXConstructorName,\n    CXXDestructorName = StoredCXXDestructorName,\n    CXXConversionFunctionName = StoredCXXConversionFunctionName,\n    CXXOperatorName = StoredCXXOperatorName,\n    CXXDeductionGuideName = UncommonNameKindOffset +\n                            detail::DeclarationNameExtra::CXXDeductionGuideName,\n    CXXLiteralOperatorName =\n        UncommonNameKindOffset +\n        detail::DeclarationNameExtra::CXXLiteralOperatorName,\n    CXXUsingDirective = UncommonNameKindOffset +\n                        detail::DeclarationNameExtra::CXXUsingDirective,\n    ObjCMultiArgSelector = UncommonNameKindOffset +\n                           detail::DeclarationNameExtra::ObjCMultiArgSelector\n  };\n\nprivate:\n  /// The lowest three bits of Ptr are used to express what kind of name\n  /// we're actually storing, using the values of StoredNameKind. Depending\n  /// on the kind of name this is, the upper bits of Ptr may have one\n  /// of several different meanings:\n  ///\n  ///   StoredIdentifier - The name is a normal identifier, and Ptr is\n  ///   a normal IdentifierInfo pointer.\n  ///\n  ///   StoredObjCZeroArgSelector - The name is an Objective-C\n  ///   selector with zero arguments, and Ptr is an IdentifierInfo\n  ///   pointer pointing to the selector name.\n  ///\n  ///   StoredObjCOneArgSelector - The name is an Objective-C selector\n  ///   with one argument, and Ptr is an IdentifierInfo pointer\n  ///   pointing to the selector name.\n  ///\n  ///   StoredCXXConstructorName - The name of a C++ constructor,\n  ///   Ptr points to a CXXSpecialNameExtra.\n  ///\n  ///   StoredCXXDestructorName - The name of a C++ destructor,\n  ///   Ptr points to a CXXSpecialNameExtra.\n  ///\n  ///   StoredCXXConversionFunctionName - The name of a C++ conversion function,\n  ///   Ptr points to a CXXSpecialNameExtra.\n  ///\n  ///   StoredCXXOperatorName - The name of an overloaded C++ operator,\n  ///   Ptr points to a CXXOperatorIdName.\n  ///\n  ///   StoredDeclarationNameExtra - Ptr is actually a pointer to a\n  ///   DeclarationNameExtra structure, whose first value will tell us\n  ///   whether this is an Objective-C selector, C++ deduction guide,\n  ///   C++ literal operator, or C++ using directive.\n  uintptr_t Ptr = 0;\n\n  StoredNameKind getStoredNameKind() const {\n    return static_cast<StoredNameKind>(Ptr & PtrMask);\n  }\n\n  void *getPtr() const { return reinterpret_cast<void *>(Ptr & ~PtrMask); }\n\n  void setPtrAndKind(const void *P, StoredNameKind Kind) {\n    uintptr_t PAsInteger = reinterpret_cast<uintptr_t>(P);\n    assert((Kind & ~PtrMask) == 0 &&\n           \"Invalid StoredNameKind in setPtrAndKind!\");\n    assert((PAsInteger & PtrMask) == 0 &&\n           \"Improperly aligned pointer in setPtrAndKind!\");\n    Ptr = PAsInteger | Kind;\n  }\n\n  /// Construct a declaration name from a DeclarationNameExtra.\n  DeclarationName(detail::DeclarationNameExtra *Name) {\n    setPtrAndKind(Name, StoredDeclarationNameExtra);\n  }\n\n  /// Construct a declaration name from a CXXSpecialNameExtra.\n  DeclarationName(detail::CXXSpecialNameExtra *Name,\n                  StoredNameKind StoredKind) {\n    assert((StoredKind == StoredCXXConstructorName ||\n           StoredKind == StoredCXXDestructorName ||\n           StoredKind == StoredCXXConversionFunctionName) &&\n               \"Invalid StoredNameKind when constructing a DeclarationName\"\n               \" from a CXXSpecialNameExtra!\");\n    setPtrAndKind(Name, StoredKind);\n  }\n\n  /// Construct a DeclarationName from a CXXOperatorIdName.\n  DeclarationName(detail::CXXOperatorIdName *Name) {\n    setPtrAndKind(Name, StoredCXXOperatorName);\n  }\n\n  /// Assert that the stored pointer points to an IdentifierInfo and return it.\n  IdentifierInfo *castAsIdentifierInfo() const {\n    assert((getStoredNameKind() == StoredIdentifier) &&\n           \"DeclarationName does not store an IdentifierInfo!\");\n    return static_cast<IdentifierInfo *>(getPtr());\n  }\n\n  /// Assert that the stored pointer points to a DeclarationNameExtra\n  /// and return it.\n  detail::DeclarationNameExtra *castAsExtra() const {\n    assert((getStoredNameKind() == StoredDeclarationNameExtra) &&\n           \"DeclarationName does not store an Extra structure!\");\n    return static_cast<detail::DeclarationNameExtra *>(getPtr());\n  }\n\n  /// Assert that the stored pointer points to a CXXSpecialNameExtra\n  /// and return it.\n  detail::CXXSpecialNameExtra *castAsCXXSpecialNameExtra() const {\n    assert((getStoredNameKind() == StoredCXXConstructorName ||\n           getStoredNameKind() == StoredCXXDestructorName ||\n           getStoredNameKind() == StoredCXXConversionFunctionName) &&\n               \"DeclarationName does not store a CXXSpecialNameExtra!\");\n    return static_cast<detail::CXXSpecialNameExtra *>(getPtr());\n  }\n\n  /// Assert that the stored pointer points to a CXXOperatorIdName\n  /// and return it.\n  detail::CXXOperatorIdName *castAsCXXOperatorIdName() const {\n    assert((getStoredNameKind() == StoredCXXOperatorName) &&\n           \"DeclarationName does not store a CXXOperatorIdName!\");\n    return static_cast<detail::CXXOperatorIdName *>(getPtr());\n  }\n\n  /// Assert that the stored pointer points to a CXXDeductionGuideNameExtra\n  /// and return it.\n  detail::CXXDeductionGuideNameExtra *castAsCXXDeductionGuideNameExtra() const {\n    assert(getNameKind() == CXXDeductionGuideName &&\n           \"DeclarationName does not store a CXXDeductionGuideNameExtra!\");\n    return static_cast<detail::CXXDeductionGuideNameExtra *>(getPtr());\n  }\n\n  /// Assert that the stored pointer points to a CXXLiteralOperatorIdName\n  /// and return it.\n  detail::CXXLiteralOperatorIdName *castAsCXXLiteralOperatorIdName() const {\n    assert(getNameKind() == CXXLiteralOperatorName &&\n           \"DeclarationName does not store a CXXLiteralOperatorIdName!\");\n    return static_cast<detail::CXXLiteralOperatorIdName *>(getPtr());\n  }\n\n  /// Get and set the FETokenInfo in the less common cases where the\n  /// declaration name do not point to an identifier.\n  void *getFETokenInfoSlow() const;\n  void setFETokenInfoSlow(void *T);\n\npublic:\n  /// Construct an empty declaration name.\n  DeclarationName() { setPtrAndKind(nullptr, StoredIdentifier); }\n\n  /// Construct a declaration name from an IdentifierInfo *.\n  DeclarationName(const IdentifierInfo *II) {\n    setPtrAndKind(II, StoredIdentifier);\n  }\n\n  /// Construct a declaration name from an Objective-C selector.\n  DeclarationName(Selector Sel) : Ptr(Sel.InfoPtr) {}\n\n  /// Returns the name for all C++ using-directives.\n  static DeclarationName getUsingDirectiveName() {\n    // Single instance of DeclarationNameExtra for using-directive\n    static detail::DeclarationNameExtra UDirExtra(\n        detail::DeclarationNameExtra::CXXUsingDirective);\n    return DeclarationName(&UDirExtra);\n  }\n\n  /// Evaluates true when this declaration name is non-empty.\n  explicit operator bool() const {\n    return getPtr() || (getStoredNameKind() != StoredIdentifier);\n  }\n\n  /// Evaluates true when this declaration name is empty.\n  bool isEmpty() const { return !*this; }\n\n  /// Predicate functions for querying what type of name this is.\n  bool isIdentifier() const { return getStoredNameKind() == StoredIdentifier; }\n  bool isObjCZeroArgSelector() const {\n    return getStoredNameKind() == StoredObjCZeroArgSelector;\n  }\n  bool isObjCOneArgSelector() const {\n    return getStoredNameKind() == StoredObjCOneArgSelector;\n  }\n\n  /// Determine what kind of name this is.\n  NameKind getNameKind() const {\n    // We rely on the fact that the first 7 NameKind and StoredNameKind\n    // have the same numerical value. This makes the usual case efficient.\n    StoredNameKind StoredKind = getStoredNameKind();\n    if (StoredKind != StoredDeclarationNameExtra)\n      return static_cast<NameKind>(StoredKind);\n    // We have to consult DeclarationNameExtra. We rely on the fact that the\n    // enumeration values of ExtraKind correspond to the enumeration values of\n    // NameKind minus an offset of UncommonNameKindOffset.\n    unsigned ExtraKind = castAsExtra()->getKind();\n    return static_cast<NameKind>(UncommonNameKindOffset + ExtraKind);\n  }\n\n  /// Determines whether the name itself is dependent, e.g., because it\n  /// involves a C++ type that is itself dependent.\n  ///\n  /// Note that this does not capture all of the notions of \"dependent name\",\n  /// because an identifier can be a dependent name if it is used as the\n  /// callee in a call expression with dependent arguments.\n  bool isDependentName() const;\n\n  /// Retrieve the human-readable string for this name.\n  std::string getAsString() const;\n\n  /// Retrieve the IdentifierInfo * stored in this declaration name,\n  /// or null if this declaration name isn't a simple identifier.\n  IdentifierInfo *getAsIdentifierInfo() const {\n    if (isIdentifier())\n      return castAsIdentifierInfo();\n    return nullptr;\n  }\n\n  /// Get the representation of this declaration name as an opaque integer.\n  uintptr_t getAsOpaqueInteger() const { return Ptr; }\n\n  /// Get the representation of this declaration name as an opaque pointer.\n  void *getAsOpaquePtr() const { return reinterpret_cast<void *>(Ptr); }\n\n  /// Get a declaration name from an opaque pointer returned by getAsOpaquePtr.\n  static DeclarationName getFromOpaquePtr(void *P) {\n    DeclarationName N;\n    N.Ptr = reinterpret_cast<uintptr_t>(P);\n    return N;\n  }\n\n  /// Get a declaration name from an opaque integer\n  /// returned by getAsOpaqueInteger.\n  static DeclarationName getFromOpaqueInteger(uintptr_t P) {\n    DeclarationName N;\n    N.Ptr = P;\n    return N;\n  }\n\n  /// If this name is one of the C++ names (of a constructor, destructor,\n  /// or conversion function), return the type associated with that name.\n  QualType getCXXNameType() const {\n    if (getStoredNameKind() == StoredCXXConstructorName ||\n        getStoredNameKind() == StoredCXXDestructorName ||\n        getStoredNameKind() == StoredCXXConversionFunctionName) {\n      assert(getPtr() && \"getCXXNameType on a null DeclarationName!\");\n      return castAsCXXSpecialNameExtra()->Type;\n    }\n    return QualType();\n  }\n\n  /// If this name is the name of a C++ deduction guide, return the\n  /// template associated with that name.\n  TemplateDecl *getCXXDeductionGuideTemplate() const {\n    if (getNameKind() == CXXDeductionGuideName) {\n      assert(getPtr() &&\n             \"getCXXDeductionGuideTemplate on a null DeclarationName!\");\n      return castAsCXXDeductionGuideNameExtra()->Template;\n    }\n    return nullptr;\n  }\n\n  /// If this name is the name of an overloadable operator in C++\n  /// (e.g., @c operator+), retrieve the kind of overloaded operator.\n  OverloadedOperatorKind getCXXOverloadedOperator() const {\n    if (getStoredNameKind() == StoredCXXOperatorName) {\n      assert(getPtr() && \"getCXXOverloadedOperator on a null DeclarationName!\");\n      return castAsCXXOperatorIdName()->Kind;\n    }\n    return OO_None;\n  }\n\n  /// If this name is the name of a literal operator,\n  /// retrieve the identifier associated with it.\n  IdentifierInfo *getCXXLiteralIdentifier() const {\n    if (getNameKind() == CXXLiteralOperatorName) {\n      assert(getPtr() && \"getCXXLiteralIdentifier on a null DeclarationName!\");\n      return castAsCXXLiteralOperatorIdName()->ID;\n    }\n    return nullptr;\n  }\n\n  /// Get the Objective-C selector stored in this declaration name.\n  Selector getObjCSelector() const {\n    assert((getNameKind() == ObjCZeroArgSelector ||\n            getNameKind() == ObjCOneArgSelector ||\n            getNameKind() == ObjCMultiArgSelector || !getPtr()) &&\n           \"Not a selector!\");\n    return Selector(Ptr);\n  }\n\n  /// Get and set FETokenInfo. The language front-end is allowed to associate\n  /// arbitrary metadata with some kinds of declaration names, including normal\n  /// identifiers and C++ constructors, destructors, and conversion functions.\n  void *getFETokenInfo() const {\n    assert(getPtr() && \"getFETokenInfo on an empty DeclarationName!\");\n    if (getStoredNameKind() == StoredIdentifier)\n      return castAsIdentifierInfo()->getFETokenInfo();\n    return getFETokenInfoSlow();\n  }\n\n  void setFETokenInfo(void *T) {\n    assert(getPtr() && \"setFETokenInfo on an empty DeclarationName!\");\n    if (getStoredNameKind() == StoredIdentifier)\n      castAsIdentifierInfo()->setFETokenInfo(T);\n    else\n      setFETokenInfoSlow(T);\n  }\n\n  /// Determine whether the specified names are identical.\n  friend bool operator==(DeclarationName LHS, DeclarationName RHS) {\n    return LHS.Ptr == RHS.Ptr;\n  }\n\n  /// Determine whether the specified names are different.\n  friend bool operator!=(DeclarationName LHS, DeclarationName RHS) {\n    return LHS.Ptr != RHS.Ptr;\n  }\n\n  static DeclarationName getEmptyMarker() {\n    DeclarationName Name;\n    Name.Ptr = uintptr_t(-1);\n    return Name;\n  }\n\n  static DeclarationName getTombstoneMarker() {\n    DeclarationName Name;\n    Name.Ptr = uintptr_t(-2);\n    return Name;\n  }\n\n  static int compare(DeclarationName LHS, DeclarationName RHS);\n\n  void print(raw_ostream &OS, const PrintingPolicy &Policy) const;\n\n  void dump() const;\n};\n\nraw_ostream &operator<<(raw_ostream &OS, DeclarationName N);\n\n/// Ordering on two declaration names. If both names are identifiers,\n/// this provides a lexicographical ordering.\ninline bool operator<(DeclarationName LHS, DeclarationName RHS) {\n  return DeclarationName::compare(LHS, RHS) < 0;\n}\n\n/// Ordering on two declaration names. If both names are identifiers,\n/// this provides a lexicographical ordering.\ninline bool operator>(DeclarationName LHS, DeclarationName RHS) {\n  return DeclarationName::compare(LHS, RHS) > 0;\n}\n\n/// Ordering on two declaration names. If both names are identifiers,\n/// this provides a lexicographical ordering.\ninline bool operator<=(DeclarationName LHS, DeclarationName RHS) {\n  return DeclarationName::compare(LHS, RHS) <= 0;\n}\n\n/// Ordering on two declaration names. If both names are identifiers,\n/// this provides a lexicographical ordering.\ninline bool operator>=(DeclarationName LHS, DeclarationName RHS) {\n  return DeclarationName::compare(LHS, RHS) >= 0;\n}\n\n/// DeclarationNameTable is used to store and retrieve DeclarationName\n/// instances for the various kinds of declaration names, e.g., normal\n/// identifiers, C++ constructor names, etc. This class contains\n/// uniqued versions of each of the C++ special names, which can be\n/// retrieved using its member functions (e.g., getCXXConstructorName).\nclass DeclarationNameTable {\n  /// Used to allocate elements in the FoldingSets below.\n  const ASTContext &Ctx;\n\n  /// Manage the uniqued CXXSpecialNameExtra representing C++ constructors.\n  /// getCXXConstructorName and getCXXSpecialName can be used to obtain\n  /// a DeclarationName from the corresponding type of the constructor.\n  llvm::FoldingSet<detail::CXXSpecialNameExtra> CXXConstructorNames;\n\n  /// Manage the uniqued CXXSpecialNameExtra representing C++ destructors.\n  /// getCXXDestructorName and getCXXSpecialName can be used to obtain\n  /// a DeclarationName from the corresponding type of the destructor.\n  llvm::FoldingSet<detail::CXXSpecialNameExtra> CXXDestructorNames;\n\n  /// Manage the uniqued CXXSpecialNameExtra representing C++ conversion\n  /// functions. getCXXConversionFunctionName and getCXXSpecialName can be\n  /// used to obtain a DeclarationName from the corresponding type of the\n  /// conversion function.\n  llvm::FoldingSet<detail::CXXSpecialNameExtra> CXXConversionFunctionNames;\n\n  /// Manage the uniqued CXXOperatorIdName, which contain extra information\n  /// for the name of overloaded C++ operators. getCXXOperatorName\n  /// can be used to obtain a DeclarationName from the operator kind.\n  detail::CXXOperatorIdName CXXOperatorNames[NUM_OVERLOADED_OPERATORS];\n\n  /// Manage the uniqued CXXLiteralOperatorIdName, which contain extra\n  /// information for the name of C++ literal operators.\n  /// getCXXLiteralOperatorName can be used to obtain a DeclarationName\n  /// from the corresponding IdentifierInfo.\n  llvm::FoldingSet<detail::CXXLiteralOperatorIdName> CXXLiteralOperatorNames;\n\n  /// Manage the uniqued CXXDeductionGuideNameExtra, which contain\n  /// extra information for the name of a C++ deduction guide.\n  /// getCXXDeductionGuideName can be used to obtain a DeclarationName\n  /// from the corresponding template declaration.\n  llvm::FoldingSet<detail::CXXDeductionGuideNameExtra> CXXDeductionGuideNames;\n\npublic:\n  DeclarationNameTable(const ASTContext &C);\n  DeclarationNameTable(const DeclarationNameTable &) = delete;\n  DeclarationNameTable &operator=(const DeclarationNameTable &) = delete;\n  DeclarationNameTable(DeclarationNameTable &&) = delete;\n  DeclarationNameTable &operator=(DeclarationNameTable &&) = delete;\n  ~DeclarationNameTable() = default;\n\n  /// Create a declaration name that is a simple identifier.\n  DeclarationName getIdentifier(const IdentifierInfo *ID) {\n    return DeclarationName(ID);\n  }\n\n  /// Returns the name of a C++ constructor for the given Type.\n  DeclarationName getCXXConstructorName(CanQualType Ty);\n\n  /// Returns the name of a C++ destructor for the given Type.\n  DeclarationName getCXXDestructorName(CanQualType Ty);\n\n  /// Returns the name of a C++ deduction guide for the given template.\n  DeclarationName getCXXDeductionGuideName(TemplateDecl *TD);\n\n  /// Returns the name of a C++ conversion function for the given Type.\n  DeclarationName getCXXConversionFunctionName(CanQualType Ty);\n\n  /// Returns a declaration name for special kind of C++ name,\n  /// e.g., for a constructor, destructor, or conversion function.\n  /// Kind must be one of:\n  ///   * DeclarationName::CXXConstructorName,\n  ///   * DeclarationName::CXXDestructorName or\n  ///   * DeclarationName::CXXConversionFunctionName\n  DeclarationName getCXXSpecialName(DeclarationName::NameKind Kind,\n                                    CanQualType Ty);\n\n  /// Get the name of the overloadable C++ operator corresponding to Op.\n  DeclarationName getCXXOperatorName(OverloadedOperatorKind Op) {\n    return DeclarationName(&CXXOperatorNames[Op]);\n  }\n\n  /// Get the name of the literal operator function with II as the identifier.\n  DeclarationName getCXXLiteralOperatorName(IdentifierInfo *II);\n};\n\n/// DeclarationNameLoc - Additional source/type location info\n/// for a declaration name. Needs a DeclarationName in order\n/// to be interpreted correctly.\nclass DeclarationNameLoc {\n  // The source location for identifier stored elsewhere.\n  // struct {} Identifier;\n\n  // Type info for constructors, destructors and conversion functions.\n  // Locations (if any) for the tilde (destructor) or operator keyword\n  // (conversion) are stored elsewhere.\n  struct NT {\n    TypeSourceInfo *TInfo;\n  };\n\n  // The location (if any) of the operator keyword is stored elsewhere.\n  struct CXXOpName {\n    unsigned BeginOpNameLoc;\n    unsigned EndOpNameLoc;\n  };\n\n  // The location (if any) of the operator keyword is stored elsewhere.\n  struct CXXLitOpName {\n    unsigned OpNameLoc;\n  };\n\n  // struct {} CXXUsingDirective;\n  // struct {} ObjCZeroArgSelector;\n  // struct {} ObjCOneArgSelector;\n  // struct {} ObjCMultiArgSelector;\n  union {\n    struct NT NamedType;\n    struct CXXOpName CXXOperatorName;\n    struct CXXLitOpName CXXLiteralOperatorName;\n  };\n\n  void setNamedTypeLoc(TypeSourceInfo *TInfo) { NamedType.TInfo = TInfo; }\n\n  void setCXXOperatorNameRange(SourceRange Range) {\n    CXXOperatorName.BeginOpNameLoc = Range.getBegin().getRawEncoding();\n    CXXOperatorName.EndOpNameLoc = Range.getEnd().getRawEncoding();\n  }\n\n  void setCXXLiteralOperatorNameLoc(SourceLocation Loc) {\n    CXXLiteralOperatorName.OpNameLoc = Loc.getRawEncoding();\n  }\n\npublic:\n  DeclarationNameLoc(DeclarationName Name);\n  // FIXME: this should go away once all DNLocs are properly initialized.\n  DeclarationNameLoc() { memset((void*) this, 0, sizeof(*this)); }\n\n  /// Returns the source type info. Assumes that the object stores location\n  /// information of a constructor, destructor or conversion operator.\n  TypeSourceInfo *getNamedTypeInfo() const { return NamedType.TInfo; }\n\n  /// Return the beginning location of the getCXXOperatorNameRange() range.\n  SourceLocation getCXXOperatorNameBeginLoc() const {\n    return SourceLocation::getFromRawEncoding(CXXOperatorName.BeginOpNameLoc);\n  }\n\n  /// Return the end location of the getCXXOperatorNameRange() range.\n  SourceLocation getCXXOperatorNameEndLoc() const {\n    return SourceLocation::getFromRawEncoding(CXXOperatorName.EndOpNameLoc);\n  }\n\n  /// Return the range of the operator name (without the operator keyword).\n  /// Assumes that the object stores location information of a (non-literal)\n  /// operator.\n  SourceRange getCXXOperatorNameRange() const {\n    return SourceRange(getCXXOperatorNameBeginLoc(),\n                       getCXXOperatorNameEndLoc());\n  }\n\n  /// Return the location of the literal operator name (without the operator\n  /// keyword). Assumes that the object stores location information of a literal\n  /// operator.\n  SourceLocation getCXXLiteralOperatorNameLoc() const {\n    return SourceLocation::getFromRawEncoding(CXXLiteralOperatorName.OpNameLoc);\n  }\n\n  /// Construct location information for a constructor, destructor or conversion\n  /// operator.\n  static DeclarationNameLoc makeNamedTypeLoc(TypeSourceInfo *TInfo) {\n    DeclarationNameLoc DNL;\n    DNL.setNamedTypeLoc(TInfo);\n    return DNL;\n  }\n\n  /// Construct location information for a non-literal C++ operator.\n  static DeclarationNameLoc makeCXXOperatorNameLoc(SourceLocation BeginLoc,\n                                                   SourceLocation EndLoc) {\n    return makeCXXOperatorNameLoc(SourceRange(BeginLoc, EndLoc));\n  }\n\n  /// Construct location information for a non-literal C++ operator.\n  static DeclarationNameLoc makeCXXOperatorNameLoc(SourceRange Range) {\n    DeclarationNameLoc DNL;\n    DNL.setCXXOperatorNameRange(Range);\n    return DNL;\n  }\n\n  /// Construct location information for a literal C++ operator.\n  static DeclarationNameLoc makeCXXLiteralOperatorNameLoc(SourceLocation Loc) {\n    DeclarationNameLoc DNL;\n    DNL.setCXXLiteralOperatorNameLoc(Loc);\n    return DNL;\n  }\n};\n\n/// DeclarationNameInfo - A collector data type for bundling together\n/// a DeclarationName and the correspnding source/type location info.\nstruct DeclarationNameInfo {\nprivate:\n  /// Name - The declaration name, also encoding name kind.\n  DeclarationName Name;\n\n  /// Loc - The main source location for the declaration name.\n  SourceLocation NameLoc;\n\n  /// Info - Further source/type location info for special kinds of names.\n  DeclarationNameLoc LocInfo;\n\npublic:\n  // FIXME: remove it.\n  DeclarationNameInfo() = default;\n\n  DeclarationNameInfo(DeclarationName Name, SourceLocation NameLoc)\n      : Name(Name), NameLoc(NameLoc), LocInfo(Name) {}\n\n  DeclarationNameInfo(DeclarationName Name, SourceLocation NameLoc,\n                      DeclarationNameLoc LocInfo)\n      : Name(Name), NameLoc(NameLoc), LocInfo(LocInfo) {}\n\n  /// getName - Returns the embedded declaration name.\n  DeclarationName getName() const { return Name; }\n\n  /// setName - Sets the embedded declaration name.\n  void setName(DeclarationName N) { Name = N; }\n\n  /// getLoc - Returns the main location of the declaration name.\n  SourceLocation getLoc() const { return NameLoc; }\n\n  /// setLoc - Sets the main location of the declaration name.\n  void setLoc(SourceLocation L) { NameLoc = L; }\n\n  const DeclarationNameLoc &getInfo() const { return LocInfo; }\n  void setInfo(const DeclarationNameLoc &Info) { LocInfo = Info; }\n\n  /// getNamedTypeInfo - Returns the source type info associated to\n  /// the name. Assumes it is a constructor, destructor or conversion.\n  TypeSourceInfo *getNamedTypeInfo() const {\n    if (Name.getNameKind() != DeclarationName::CXXConstructorName &&\n        Name.getNameKind() != DeclarationName::CXXDestructorName &&\n        Name.getNameKind() != DeclarationName::CXXConversionFunctionName)\n      return nullptr;\n    return LocInfo.getNamedTypeInfo();\n  }\n\n  /// setNamedTypeInfo - Sets the source type info associated to\n  /// the name. Assumes it is a constructor, destructor or conversion.\n  void setNamedTypeInfo(TypeSourceInfo *TInfo) {\n    assert(Name.getNameKind() == DeclarationName::CXXConstructorName ||\n           Name.getNameKind() == DeclarationName::CXXDestructorName ||\n           Name.getNameKind() == DeclarationName::CXXConversionFunctionName);\n    LocInfo = DeclarationNameLoc::makeNamedTypeLoc(TInfo);\n  }\n\n  /// getCXXOperatorNameRange - Gets the range of the operator name\n  /// (without the operator keyword). Assumes it is a (non-literal) operator.\n  SourceRange getCXXOperatorNameRange() const {\n    if (Name.getNameKind() != DeclarationName::CXXOperatorName)\n      return SourceRange();\n    return LocInfo.getCXXOperatorNameRange();\n  }\n\n  /// setCXXOperatorNameRange - Sets the range of the operator name\n  /// (without the operator keyword). Assumes it is a C++ operator.\n  void setCXXOperatorNameRange(SourceRange R) {\n    assert(Name.getNameKind() == DeclarationName::CXXOperatorName);\n    LocInfo = DeclarationNameLoc::makeCXXOperatorNameLoc(R);\n  }\n\n  /// getCXXLiteralOperatorNameLoc - Returns the location of the literal\n  /// operator name (not the operator keyword).\n  /// Assumes it is a literal operator.\n  SourceLocation getCXXLiteralOperatorNameLoc() const {\n    if (Name.getNameKind() != DeclarationName::CXXLiteralOperatorName)\n      return SourceLocation();\n    return LocInfo.getCXXLiteralOperatorNameLoc();\n  }\n\n  /// setCXXLiteralOperatorNameLoc - Sets the location of the literal\n  /// operator name (not the operator keyword).\n  /// Assumes it is a literal operator.\n  void setCXXLiteralOperatorNameLoc(SourceLocation Loc) {\n    assert(Name.getNameKind() == DeclarationName::CXXLiteralOperatorName);\n    LocInfo = DeclarationNameLoc::makeCXXLiteralOperatorNameLoc(Loc);\n  }\n\n  /// Determine whether this name involves a template parameter.\n  bool isInstantiationDependent() const;\n\n  /// Determine whether this name contains an unexpanded\n  /// parameter pack.\n  bool containsUnexpandedParameterPack() const;\n\n  /// getAsString - Retrieve the human-readable string for this name.\n  std::string getAsString() const;\n\n  /// printName - Print the human-readable name to a stream.\n  void printName(raw_ostream &OS, PrintingPolicy Policy) const;\n\n  /// getBeginLoc - Retrieve the location of the first token.\n  SourceLocation getBeginLoc() const { return NameLoc; }\n\n  /// getSourceRange - The range of the declaration name.\n  SourceRange getSourceRange() const LLVM_READONLY {\n    return SourceRange(getBeginLoc(), getEndLoc());\n  }\n\n  SourceLocation getEndLoc() const LLVM_READONLY {\n    SourceLocation EndLoc = getEndLocPrivate();\n    return EndLoc.isValid() ? EndLoc : getBeginLoc();\n  }\n\nprivate:\n  SourceLocation getEndLocPrivate() const;\n};\n\n/// Insertion operator for partial diagnostics.  This allows binding\n/// DeclarationName's into a partial diagnostic with <<.\ninline const StreamingDiagnostic &operator<<(const StreamingDiagnostic &PD,\n                                             DeclarationName N) {\n  PD.AddTaggedVal(N.getAsOpaqueInteger(),\n                  DiagnosticsEngine::ak_declarationname);\n  return PD;\n}\n\nraw_ostream &operator<<(raw_ostream &OS, DeclarationNameInfo DNInfo);\n\n} // namespace clang\n\nnamespace llvm {\n\n/// Define DenseMapInfo so that DeclarationNames can be used as keys\n/// in DenseMap and DenseSets.\ntemplate<>\nstruct DenseMapInfo<clang::DeclarationName> {\n  static inline clang::DeclarationName getEmptyKey() {\n    return clang::DeclarationName::getEmptyMarker();\n  }\n\n  static inline clang::DeclarationName getTombstoneKey() {\n    return clang::DeclarationName::getTombstoneMarker();\n  }\n\n  static unsigned getHashValue(clang::DeclarationName Name) {\n    return DenseMapInfo<void*>::getHashValue(Name.getAsOpaquePtr());\n  }\n\n  static inline bool\n  isEqual(clang::DeclarationName LHS, clang::DeclarationName RHS) {\n    return LHS == RHS;\n  }\n};\n\ntemplate <> struct PointerLikeTypeTraits<clang::DeclarationName> {\n  static inline void *getAsVoidPointer(clang::DeclarationName P) {\n    return P.getAsOpaquePtr();\n  }\n  static inline clang::DeclarationName getFromVoidPointer(void *P) {\n    return clang::DeclarationName::getFromOpaquePtr(P);\n  }\n  static constexpr int NumLowBitsAvailable = 0;\n};\n\n} // namespace llvm\n\n// The definition of AssumedTemplateStorage is factored out of TemplateName to\n// resolve a cyclic dependency between it and DeclarationName (via Type).\nnamespace clang {\n\n/// A structure for storing the information associated with a name that has\n/// been assumed to be a template name (despite finding no TemplateDecls).\nclass AssumedTemplateStorage : public UncommonTemplateNameStorage {\n  friend class ASTContext;\n\n  AssumedTemplateStorage(DeclarationName Name)\n      : UncommonTemplateNameStorage(Assumed, 0), Name(Name) {}\n  DeclarationName Name;\n\npublic:\n  /// Get the name of the template.\n  DeclarationName getDeclName() const { return Name; }\n};\n\n} // namespace clang\n\n#endif // LLVM_CLANG_AST_DECLARATIONNAME_H\n"}, "9": {"id": 9, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/Expr.h", "content": "//===--- Expr.h - Classes for representing expressions ----------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n//  This file defines the Expr interface and subclasses.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_AST_EXPR_H\n#define LLVM_CLANG_AST_EXPR_H\n\n#include \"clang/AST/APValue.h\"\n#include \"clang/AST/ASTVector.h\"\n#include \"clang/AST/ComputeDependence.h\"\n#include \"clang/AST/Decl.h\"\n#include \"clang/AST/DeclAccessPair.h\"\n#include \"clang/AST/DependenceFlags.h\"\n#include \"clang/AST/OperationKinds.h\"\n#include \"clang/AST/Stmt.h\"\n#include \"clang/AST/TemplateBase.h\"\n#include \"clang/AST/Type.h\"\n#include \"clang/Basic/CharInfo.h\"\n#include \"clang/Basic/LangOptions.h\"\n#include \"clang/Basic/SyncScope.h\"\n#include \"clang/Basic/TypeTraits.h\"\n#include \"llvm/ADT/APFloat.h\"\n#include \"llvm/ADT/APSInt.h\"\n#include \"llvm/ADT/SmallVector.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/ADT/iterator.h\"\n#include \"llvm/ADT/iterator_range.h\"\n#include \"llvm/Support/AtomicOrdering.h\"\n#include \"llvm/Support/Compiler.h\"\n#include \"llvm/Support/TrailingObjects.h\"\n\nnamespace clang {\n  class APValue;\n  class ASTContext;\n  class BlockDecl;\n  class CXXBaseSpecifier;\n  class CXXMemberCallExpr;\n  class CXXOperatorCallExpr;\n  class CastExpr;\n  class Decl;\n  class IdentifierInfo;\n  class MaterializeTemporaryExpr;\n  class NamedDecl;\n  class ObjCPropertyRefExpr;\n  class OpaqueValueExpr;\n  class ParmVarDecl;\n  class StringLiteral;\n  class TargetInfo;\n  class ValueDecl;\n\n/// A simple array of base specifiers.\ntypedef SmallVector<CXXBaseSpecifier*, 4> CXXCastPath;\n\n/// An adjustment to be made to the temporary created when emitting a\n/// reference binding, which accesses a particular subobject of that temporary.\nstruct SubobjectAdjustment {\n  enum {\n    DerivedToBaseAdjustment,\n    FieldAdjustment,\n    MemberPointerAdjustment\n  } Kind;\n\n  struct DTB {\n    const CastExpr *BasePath;\n    const CXXRecordDecl *DerivedClass;\n  };\n\n  struct P {\n    const MemberPointerType *MPT;\n    Expr *RHS;\n  };\n\n  union {\n    struct DTB DerivedToBase;\n    FieldDecl *Field;\n    struct P Ptr;\n  };\n\n  SubobjectAdjustment(const CastExpr *BasePath,\n                      const CXXRecordDecl *DerivedClass)\n    : Kind(DerivedToBaseAdjustment) {\n    DerivedToBase.BasePath = BasePath;\n    DerivedToBase.DerivedClass = DerivedClass;\n  }\n\n  SubobjectAdjustment(FieldDecl *Field)\n    : Kind(FieldAdjustment) {\n    this->Field = Field;\n  }\n\n  SubobjectAdjustment(const MemberPointerType *MPT, Expr *RHS)\n    : Kind(MemberPointerAdjustment) {\n    this->Ptr.MPT = MPT;\n    this->Ptr.RHS = RHS;\n  }\n};\n\n/// This represents one expression.  Note that Expr's are subclasses of Stmt.\n/// This allows an expression to be transparently used any place a Stmt is\n/// required.\nclass Expr : public ValueStmt {\n  QualType TR;\n\npublic:\n  Expr() = delete;\n  Expr(const Expr&) = delete;\n  Expr(Expr &&) = delete;\n  Expr &operator=(const Expr&) = delete;\n  Expr &operator=(Expr&&) = delete;\n\nprotected:\n  Expr(StmtClass SC, QualType T, ExprValueKind VK, ExprObjectKind OK)\n      : ValueStmt(SC) {\n    ExprBits.Dependent = 0;\n    ExprBits.ValueKind = VK;\n    ExprBits.ObjectKind = OK;\n    assert(ExprBits.ObjectKind == OK && \"truncated kind\");\n    setType(T);\n  }\n\n  /// Construct an empty expression.\n  explicit Expr(StmtClass SC, EmptyShell) : ValueStmt(SC) { }\n\n  /// Each concrete expr subclass is expected to compute its dependence and call\n  /// this in the constructor.\n  void setDependence(ExprDependence Deps) {\n    ExprBits.Dependent = static_cast<unsigned>(Deps);\n  }\n  friend class ASTImporter; // Sets dependence dircetly.\n  friend class ASTStmtReader; // Sets dependence dircetly.\n\npublic:\n  QualType getType() const { return TR; }\n  void setType(QualType t) {\n    // In C++, the type of an expression is always adjusted so that it\n    // will not have reference type (C++ [expr]p6). Use\n    // QualType::getNonReferenceType() to retrieve the non-reference\n    // type. Additionally, inspect Expr::isLvalue to determine whether\n    // an expression that is adjusted in this manner should be\n    // considered an lvalue.\n    assert((t.isNull() || !t->isReferenceType()) &&\n           \"Expressions can't have reference type\");\n\n    TR = t;\n  }\n\n  ExprDependence getDependence() const {\n    return static_cast<ExprDependence>(ExprBits.Dependent);\n  }\n\n  /// Determines whether the value of this expression depends on\n  ///   - a template parameter (C++ [temp.dep.constexpr])\n  ///   - or an error, whose resolution is unknown\n  ///\n  /// For example, the array bound of \"Chars\" in the following example is\n  /// value-dependent.\n  /// @code\n  /// template<int Size, char (&Chars)[Size]> struct meta_string;\n  /// @endcode\n  bool isValueDependent() const {\n    return static_cast<bool>(getDependence() & ExprDependence::Value);\n  }\n\n  /// Determines whether the type of this expression depends on\n  ///   - a template paramter (C++ [temp.dep.expr], which means that its type\n  ///     could change from one template instantiation to the next)\n  ///   - or an error\n  ///\n  /// For example, the expressions \"x\" and \"x + y\" are type-dependent in\n  /// the following code, but \"y\" is not type-dependent:\n  /// @code\n  /// template<typename T>\n  /// void add(T x, int y) {\n  ///   x + y;\n  /// }\n  /// @endcode\n  bool isTypeDependent() const {\n    return static_cast<bool>(getDependence() & ExprDependence::Type);\n  }\n\n  /// Whether this expression is instantiation-dependent, meaning that\n  /// it depends in some way on\n  ///    - a template parameter (even if neither its type nor (constant) value\n  ///      can change due to the template instantiation)\n  ///    - or an error\n  ///\n  /// In the following example, the expression \\c sizeof(sizeof(T() + T())) is\n  /// instantiation-dependent (since it involves a template parameter \\c T), but\n  /// is neither type- nor value-dependent, since the type of the inner\n  /// \\c sizeof is known (\\c std::size_t) and therefore the size of the outer\n  /// \\c sizeof is known.\n  ///\n  /// \\code\n  /// template<typename T>\n  /// void f(T x, T y) {\n  ///   sizeof(sizeof(T() + T());\n  /// }\n  /// \\endcode\n  ///\n  /// \\code\n  /// void func(int) {\n  ///   func(); // the expression is instantiation-dependent, because it depends\n  ///           // on an error.\n  /// }\n  /// \\endcode\n  bool isInstantiationDependent() const {\n    return static_cast<bool>(getDependence() & ExprDependence::Instantiation);\n  }\n\n  /// Whether this expression contains an unexpanded parameter\n  /// pack (for C++11 variadic templates).\n  ///\n  /// Given the following function template:\n  ///\n  /// \\code\n  /// template<typename F, typename ...Types>\n  /// void forward(const F &f, Types &&...args) {\n  ///   f(static_cast<Types&&>(args)...);\n  /// }\n  /// \\endcode\n  ///\n  /// The expressions \\c args and \\c static_cast<Types&&>(args) both\n  /// contain parameter packs.\n  bool containsUnexpandedParameterPack() const {\n    return static_cast<bool>(getDependence() & ExprDependence::UnexpandedPack);\n  }\n\n  /// Whether this expression contains subexpressions which had errors, e.g. a\n  /// TypoExpr.\n  bool containsErrors() const {\n    return static_cast<bool>(getDependence() & ExprDependence::Error);\n  }\n\n  /// getExprLoc - Return the preferred location for the arrow when diagnosing\n  /// a problem with a generic expression.\n  SourceLocation getExprLoc() const LLVM_READONLY;\n\n  /// Determine whether an lvalue-to-rvalue conversion should implicitly be\n  /// applied to this expression if it appears as a discarded-value expression\n  /// in C++11 onwards. This applies to certain forms of volatile glvalues.\n  bool isReadIfDiscardedInCPlusPlus11() const;\n\n  /// isUnusedResultAWarning - Return true if this immediate expression should\n  /// be warned about if the result is unused.  If so, fill in expr, location,\n  /// and ranges with expr to warn on and source locations/ranges appropriate\n  /// for a warning.\n  bool isUnusedResultAWarning(const Expr *&WarnExpr, SourceLocation &Loc,\n                              SourceRange &R1, SourceRange &R2,\n                              ASTContext &Ctx) const;\n\n  /// isLValue - True if this expression is an \"l-value\" according to\n  /// the rules of the current language.  C and C++ give somewhat\n  /// different rules for this concept, but in general, the result of\n  /// an l-value expression identifies a specific object whereas the\n  /// result of an r-value expression is a value detached from any\n  /// specific storage.\n  ///\n  /// C++11 divides the concept of \"r-value\" into pure r-values\n  /// (\"pr-values\") and so-called expiring values (\"x-values\"), which\n  /// identify specific objects that can be safely cannibalized for\n  /// their resources.  This is an unfortunate abuse of terminology on\n  /// the part of the C++ committee.  In Clang, when we say \"r-value\",\n  /// we generally mean a pr-value.\n  bool isLValue() const { return getValueKind() == VK_LValue; }\n  bool isRValue() const { return getValueKind() == VK_RValue; }\n  bool isXValue() const { return getValueKind() == VK_XValue; }\n  bool isGLValue() const { return getValueKind() != VK_RValue; }\n\n  enum LValueClassification {\n    LV_Valid,\n    LV_NotObjectType,\n    LV_IncompleteVoidType,\n    LV_DuplicateVectorComponents,\n    LV_InvalidExpression,\n    LV_InvalidMessageExpression,\n    LV_MemberFunction,\n    LV_SubObjCPropertySetting,\n    LV_ClassTemporary,\n    LV_ArrayTemporary\n  };\n  /// Reasons why an expression might not be an l-value.\n  LValueClassification ClassifyLValue(ASTContext &Ctx) const;\n\n  enum isModifiableLvalueResult {\n    MLV_Valid,\n    MLV_NotObjectType,\n    MLV_IncompleteVoidType,\n    MLV_DuplicateVectorComponents,\n    MLV_InvalidExpression,\n    MLV_LValueCast,           // Specialized form of MLV_InvalidExpression.\n    MLV_IncompleteType,\n    MLV_ConstQualified,\n    MLV_ConstQualifiedField,\n    MLV_ConstAddrSpace,\n    MLV_ArrayType,\n    MLV_NoSetterProperty,\n    MLV_MemberFunction,\n    MLV_SubObjCPropertySetting,\n    MLV_InvalidMessageExpression,\n    MLV_ClassTemporary,\n    MLV_ArrayTemporary\n  };\n  /// isModifiableLvalue - C99 6.3.2.1: an lvalue that does not have array type,\n  /// does not have an incomplete type, does not have a const-qualified type,\n  /// and if it is a structure or union, does not have any member (including,\n  /// recursively, any member or element of all contained aggregates or unions)\n  /// with a const-qualified type.\n  ///\n  /// \\param Loc [in,out] - A source location which *may* be filled\n  /// in with the location of the expression making this a\n  /// non-modifiable lvalue, if specified.\n  isModifiableLvalueResult\n  isModifiableLvalue(ASTContext &Ctx, SourceLocation *Loc = nullptr) const;\n\n  /// The return type of classify(). Represents the C++11 expression\n  ///        taxonomy.\n  class Classification {\n  public:\n    /// The various classification results. Most of these mean prvalue.\n    enum Kinds {\n      CL_LValue,\n      CL_XValue,\n      CL_Function, // Functions cannot be lvalues in C.\n      CL_Void, // Void cannot be an lvalue in C.\n      CL_AddressableVoid, // Void expression whose address can be taken in C.\n      CL_DuplicateVectorComponents, // A vector shuffle with dupes.\n      CL_MemberFunction, // An expression referring to a member function\n      CL_SubObjCPropertySetting,\n      CL_ClassTemporary, // A temporary of class type, or subobject thereof.\n      CL_ArrayTemporary, // A temporary of array type.\n      CL_ObjCMessageRValue, // ObjC message is an rvalue\n      CL_PRValue // A prvalue for any other reason, of any other type\n    };\n    /// The results of modification testing.\n    enum ModifiableType {\n      CM_Untested, // testModifiable was false.\n      CM_Modifiable,\n      CM_RValue, // Not modifiable because it's an rvalue\n      CM_Function, // Not modifiable because it's a function; C++ only\n      CM_LValueCast, // Same as CM_RValue, but indicates GCC cast-as-lvalue ext\n      CM_NoSetterProperty,// Implicit assignment to ObjC property without setter\n      CM_ConstQualified,\n      CM_ConstQualifiedField,\n      CM_ConstAddrSpace,\n      CM_ArrayType,\n      CM_IncompleteType\n    };\n\n  private:\n    friend class Expr;\n\n    unsigned short Kind;\n    unsigned short Modifiable;\n\n    explicit Classification(Kinds k, ModifiableType m)\n      : Kind(k), Modifiable(m)\n    {}\n\n  public:\n    Classification() {}\n\n    Kinds getKind() const { return static_cast<Kinds>(Kind); }\n    ModifiableType getModifiable() const {\n      assert(Modifiable != CM_Untested && \"Did not test for modifiability.\");\n      return static_cast<ModifiableType>(Modifiable);\n    }\n    bool isLValue() const { return Kind == CL_LValue; }\n    bool isXValue() const { return Kind == CL_XValue; }\n    bool isGLValue() const { return Kind <= CL_XValue; }\n    bool isPRValue() const { return Kind >= CL_Function; }\n    bool isRValue() const { return Kind >= CL_XValue; }\n    bool isModifiable() const { return getModifiable() == CM_Modifiable; }\n\n    /// Create a simple, modifiably lvalue\n    static Classification makeSimpleLValue() {\n      return Classification(CL_LValue, CM_Modifiable);\n    }\n\n  };\n  /// Classify - Classify this expression according to the C++11\n  ///        expression taxonomy.\n  ///\n  /// C++11 defines ([basic.lval]) a new taxonomy of expressions to replace the\n  /// old lvalue vs rvalue. This function determines the type of expression this\n  /// is. There are three expression types:\n  /// - lvalues are classical lvalues as in C++03.\n  /// - prvalues are equivalent to rvalues in C++03.\n  /// - xvalues are expressions yielding unnamed rvalue references, e.g. a\n  ///   function returning an rvalue reference.\n  /// lvalues and xvalues are collectively referred to as glvalues, while\n  /// prvalues and xvalues together form rvalues.\n  Classification Classify(ASTContext &Ctx) const {\n    return ClassifyImpl(Ctx, nullptr);\n  }\n\n  /// ClassifyModifiable - Classify this expression according to the\n  ///        C++11 expression taxonomy, and see if it is valid on the left side\n  ///        of an assignment.\n  ///\n  /// This function extends classify in that it also tests whether the\n  /// expression is modifiable (C99 6.3.2.1p1).\n  /// \\param Loc A source location that might be filled with a relevant location\n  ///            if the expression is not modifiable.\n  Classification ClassifyModifiable(ASTContext &Ctx, SourceLocation &Loc) const{\n    return ClassifyImpl(Ctx, &Loc);\n  }\n\n  /// Returns the set of floating point options that apply to this expression.\n  /// Only meaningful for operations on floating point values.\n  FPOptions getFPFeaturesInEffect(const LangOptions &LO) const;\n\n  /// getValueKindForType - Given a formal return or parameter type,\n  /// give its value kind.\n  static ExprValueKind getValueKindForType(QualType T) {\n    if (const ReferenceType *RT = T->getAs<ReferenceType>())\n      return (isa<LValueReferenceType>(RT)\n                ? VK_LValue\n                : (RT->getPointeeType()->isFunctionType()\n                     ? VK_LValue : VK_XValue));\n    return VK_RValue;\n  }\n\n  /// getValueKind - The value kind that this expression produces.\n  ExprValueKind getValueKind() const {\n    return static_cast<ExprValueKind>(ExprBits.ValueKind);\n  }\n\n  /// getObjectKind - The object kind that this expression produces.\n  /// Object kinds are meaningful only for expressions that yield an\n  /// l-value or x-value.\n  ExprObjectKind getObjectKind() const {\n    return static_cast<ExprObjectKind>(ExprBits.ObjectKind);\n  }\n\n  bool isOrdinaryOrBitFieldObject() const {\n    ExprObjectKind OK = getObjectKind();\n    return (OK == OK_Ordinary || OK == OK_BitField);\n  }\n\n  /// setValueKind - Set the value kind produced by this expression.\n  void setValueKind(ExprValueKind Cat) { ExprBits.ValueKind = Cat; }\n\n  /// setObjectKind - Set the object kind produced by this expression.\n  void setObjectKind(ExprObjectKind Cat) { ExprBits.ObjectKind = Cat; }\n\nprivate:\n  Classification ClassifyImpl(ASTContext &Ctx, SourceLocation *Loc) const;\n\npublic:\n\n  /// Returns true if this expression is a gl-value that\n  /// potentially refers to a bit-field.\n  ///\n  /// In C++, whether a gl-value refers to a bitfield is essentially\n  /// an aspect of the value-kind type system.\n  bool refersToBitField() const { return getObjectKind() == OK_BitField; }\n\n  /// If this expression refers to a bit-field, retrieve the\n  /// declaration of that bit-field.\n  ///\n  /// Note that this returns a non-null pointer in subtly different\n  /// places than refersToBitField returns true.  In particular, this can\n  /// return a non-null pointer even for r-values loaded from\n  /// bit-fields, but it will return null for a conditional bit-field.\n  FieldDecl *getSourceBitField();\n\n  const FieldDecl *getSourceBitField() const {\n    return const_cast<Expr*>(this)->getSourceBitField();\n  }\n\n  Decl *getReferencedDeclOfCallee();\n  const Decl *getReferencedDeclOfCallee() const {\n    return const_cast<Expr*>(this)->getReferencedDeclOfCallee();\n  }\n\n  /// If this expression is an l-value for an Objective C\n  /// property, find the underlying property reference expression.\n  const ObjCPropertyRefExpr *getObjCProperty() const;\n\n  /// Check if this expression is the ObjC 'self' implicit parameter.\n  bool isObjCSelfExpr() const;\n\n  /// Returns whether this expression refers to a vector element.\n  bool refersToVectorElement() const;\n\n  /// Returns whether this expression refers to a matrix element.\n  bool refersToMatrixElement() const {\n    return getObjectKind() == OK_MatrixComponent;\n  }\n\n  /// Returns whether this expression refers to a global register\n  /// variable.\n  bool refersToGlobalRegisterVar() const;\n\n  /// Returns whether this expression has a placeholder type.\n  bool hasPlaceholderType() const {\n    return getType()->isPlaceholderType();\n  }\n\n  /// Returns whether this expression has a specific placeholder type.\n  bool hasPlaceholderType(BuiltinType::Kind K) const {\n    assert(BuiltinType::isPlaceholderTypeKind(K));\n    if (const BuiltinType *BT = dyn_cast<BuiltinType>(getType()))\n      return BT->getKind() == K;\n    return false;\n  }\n\n  /// isKnownToHaveBooleanValue - Return true if this is an integer expression\n  /// that is known to return 0 or 1.  This happens for _Bool/bool expressions\n  /// but also int expressions which are produced by things like comparisons in\n  /// C.\n  ///\n  /// \\param Semantic If true, only return true for expressions that are known\n  /// to be semantically boolean, which might not be true even for expressions\n  /// that are known to evaluate to 0/1. For instance, reading an unsigned\n  /// bit-field with width '1' will evaluate to 0/1, but doesn't necessarily\n  /// semantically correspond to a bool.\n  bool isKnownToHaveBooleanValue(bool Semantic = true) const;\n\n  /// isIntegerConstantExpr - Return the value if this expression is a valid\n  /// integer constant expression.  If not a valid i-c-e, return None and fill\n  /// in Loc (if specified) with the location of the invalid expression.\n  ///\n  /// Note: This does not perform the implicit conversions required by C++11\n  /// [expr.const]p5.\n  Optional<llvm::APSInt> getIntegerConstantExpr(const ASTContext &Ctx,\n                                                SourceLocation *Loc = nullptr,\n                                                bool isEvaluated = true) const;\n  bool isIntegerConstantExpr(const ASTContext &Ctx,\n                             SourceLocation *Loc = nullptr) const;\n\n  /// isCXX98IntegralConstantExpr - Return true if this expression is an\n  /// integral constant expression in C++98. Can only be used in C++.\n  bool isCXX98IntegralConstantExpr(const ASTContext &Ctx) const;\n\n  /// isCXX11ConstantExpr - Return true if this expression is a constant\n  /// expression in C++11. Can only be used in C++.\n  ///\n  /// Note: This does not perform the implicit conversions required by C++11\n  /// [expr.const]p5.\n  bool isCXX11ConstantExpr(const ASTContext &Ctx, APValue *Result = nullptr,\n                           SourceLocation *Loc = nullptr) const;\n\n  /// isPotentialConstantExpr - Return true if this function's definition\n  /// might be usable in a constant expression in C++11, if it were marked\n  /// constexpr. Return false if the function can never produce a constant\n  /// expression, along with diagnostics describing why not.\n  static bool isPotentialConstantExpr(const FunctionDecl *FD,\n                                      SmallVectorImpl<\n                                        PartialDiagnosticAt> &Diags);\n\n  /// isPotentialConstantExprUnevaluted - Return true if this expression might\n  /// be usable in a constant expression in C++11 in an unevaluated context, if\n  /// it were in function FD marked constexpr. Return false if the function can\n  /// never produce a constant expression, along with diagnostics describing\n  /// why not.\n  static bool isPotentialConstantExprUnevaluated(Expr *E,\n                                                 const FunctionDecl *FD,\n                                                 SmallVectorImpl<\n                                                   PartialDiagnosticAt> &Diags);\n\n  /// isConstantInitializer - Returns true if this expression can be emitted to\n  /// IR as a constant, and thus can be used as a constant initializer in C.\n  /// If this expression is not constant and Culprit is non-null,\n  /// it is used to store the address of first non constant expr.\n  bool isConstantInitializer(ASTContext &Ctx, bool ForRef,\n                             const Expr **Culprit = nullptr) const;\n\n  /// EvalStatus is a struct with detailed info about an evaluation in progress.\n  struct EvalStatus {\n    /// Whether the evaluated expression has side effects.\n    /// For example, (f() && 0) can be folded, but it still has side effects.\n    bool HasSideEffects;\n\n    /// Whether the evaluation hit undefined behavior.\n    /// For example, 1.0 / 0.0 can be folded to Inf, but has undefined behavior.\n    /// Likewise, INT_MAX + 1 can be folded to INT_MIN, but has UB.\n    bool HasUndefinedBehavior;\n\n    /// Diag - If this is non-null, it will be filled in with a stack of notes\n    /// indicating why evaluation failed (or why it failed to produce a constant\n    /// expression).\n    /// If the expression is unfoldable, the notes will indicate why it's not\n    /// foldable. If the expression is foldable, but not a constant expression,\n    /// the notes will describes why it isn't a constant expression. If the\n    /// expression *is* a constant expression, no notes will be produced.\n    SmallVectorImpl<PartialDiagnosticAt> *Diag;\n\n    EvalStatus()\n        : HasSideEffects(false), HasUndefinedBehavior(false), Diag(nullptr) {}\n\n    // hasSideEffects - Return true if the evaluated expression has\n    // side effects.\n    bool hasSideEffects() const {\n      return HasSideEffects;\n    }\n  };\n\n  /// EvalResult is a struct with detailed info about an evaluated expression.\n  struct EvalResult : EvalStatus {\n    /// Val - This is the value the expression can be folded to.\n    APValue Val;\n\n    // isGlobalLValue - Return true if the evaluated lvalue expression\n    // is global.\n    bool isGlobalLValue() const;\n  };\n\n  /// EvaluateAsRValue - Return true if this is a constant which we can fold to\n  /// an rvalue using any crazy technique (that has nothing to do with language\n  /// standards) that we want to, even if the expression has side-effects. If\n  /// this function returns true, it returns the folded constant in Result. If\n  /// the expression is a glvalue, an lvalue-to-rvalue conversion will be\n  /// applied.\n  bool EvaluateAsRValue(EvalResult &Result, const ASTContext &Ctx,\n                        bool InConstantContext = false) const;\n\n  /// EvaluateAsBooleanCondition - Return true if this is a constant\n  /// which we can fold and convert to a boolean condition using\n  /// any crazy technique that we want to, even if the expression has\n  /// side-effects.\n  bool EvaluateAsBooleanCondition(bool &Result, const ASTContext &Ctx,\n                                  bool InConstantContext = false) const;\n\n  enum SideEffectsKind {\n    SE_NoSideEffects,          ///< Strictly evaluate the expression.\n    SE_AllowUndefinedBehavior, ///< Allow UB that we can give a value, but not\n                               ///< arbitrary unmodeled side effects.\n    SE_AllowSideEffects        ///< Allow any unmodeled side effect.\n  };\n\n  /// EvaluateAsInt - Return true if this is a constant which we can fold and\n  /// convert to an integer, using any crazy technique that we want to.\n  bool EvaluateAsInt(EvalResult &Result, const ASTContext &Ctx,\n                     SideEffectsKind AllowSideEffects = SE_NoSideEffects,\n                     bool InConstantContext = false) const;\n\n  /// EvaluateAsFloat - Return true if this is a constant which we can fold and\n  /// convert to a floating point value, using any crazy technique that we\n  /// want to.\n  bool EvaluateAsFloat(llvm::APFloat &Result, const ASTContext &Ctx,\n                       SideEffectsKind AllowSideEffects = SE_NoSideEffects,\n                       bool InConstantContext = false) const;\n\n  /// EvaluateAsFloat - Return true if this is a constant which we can fold and\n  /// convert to a fixed point value.\n  bool EvaluateAsFixedPoint(EvalResult &Result, const ASTContext &Ctx,\n                            SideEffectsKind AllowSideEffects = SE_NoSideEffects,\n                            bool InConstantContext = false) const;\n\n  /// isEvaluatable - Call EvaluateAsRValue to see if this expression can be\n  /// constant folded without side-effects, but discard the result.\n  bool isEvaluatable(const ASTContext &Ctx,\n                     SideEffectsKind AllowSideEffects = SE_NoSideEffects) const;\n\n  /// HasSideEffects - This routine returns true for all those expressions\n  /// which have any effect other than producing a value. Example is a function\n  /// call, volatile variable read, or throwing an exception. If\n  /// IncludePossibleEffects is false, this call treats certain expressions with\n  /// potential side effects (such as function call-like expressions,\n  /// instantiation-dependent expressions, or invocations from a macro) as not\n  /// having side effects.\n  bool HasSideEffects(const ASTContext &Ctx,\n                      bool IncludePossibleEffects = true) const;\n\n  /// Determine whether this expression involves a call to any function\n  /// that is not trivial.\n  bool hasNonTrivialCall(const ASTContext &Ctx) const;\n\n  /// EvaluateKnownConstInt - Call EvaluateAsRValue and return the folded\n  /// integer. This must be called on an expression that constant folds to an\n  /// integer.\n  llvm::APSInt EvaluateKnownConstInt(\n      const ASTContext &Ctx,\n      SmallVectorImpl<PartialDiagnosticAt> *Diag = nullptr) const;\n\n  llvm::APSInt EvaluateKnownConstIntCheckOverflow(\n      const ASTContext &Ctx,\n      SmallVectorImpl<PartialDiagnosticAt> *Diag = nullptr) const;\n\n  void EvaluateForOverflow(const ASTContext &Ctx) const;\n\n  /// EvaluateAsLValue - Evaluate an expression to see if we can fold it to an\n  /// lvalue with link time known address, with no side-effects.\n  bool EvaluateAsLValue(EvalResult &Result, const ASTContext &Ctx,\n                        bool InConstantContext = false) const;\n\n  /// EvaluateAsInitializer - Evaluate an expression as if it were the\n  /// initializer of the given declaration. Returns true if the initializer\n  /// can be folded to a constant, and produces any relevant notes. In C++11,\n  /// notes will be produced if the expression is not a constant expression.\n  bool EvaluateAsInitializer(APValue &Result, const ASTContext &Ctx,\n                             const VarDecl *VD,\n                             SmallVectorImpl<PartialDiagnosticAt> &Notes,\n                             bool IsConstantInitializer) const;\n\n  /// EvaluateWithSubstitution - Evaluate an expression as if from the context\n  /// of a call to the given function with the given arguments, inside an\n  /// unevaluated context. Returns true if the expression could be folded to a\n  /// constant.\n  bool EvaluateWithSubstitution(APValue &Value, ASTContext &Ctx,\n                                const FunctionDecl *Callee,\n                                ArrayRef<const Expr*> Args,\n                                const Expr *This = nullptr) const;\n\n  enum class ConstantExprKind {\n    /// An integer constant expression (an array bound, enumerator, case value,\n    /// bit-field width, or similar) or similar.\n    Normal,\n    /// A non-class template argument. Such a value is only used for mangling,\n    /// not for code generation, so can refer to dllimported functions.\n    NonClassTemplateArgument,\n    /// A class template argument. Such a value is used for code generation.\n    ClassTemplateArgument,\n    /// An immediate invocation. The destruction of the end result of this\n    /// evaluation is not part of the evaluation, but all other temporaries\n    /// are destroyed.\n    ImmediateInvocation,\n  };\n\n  /// Evaluate an expression that is required to be a constant expression. Does\n  /// not check the syntactic constraints for C and C++98 constant expressions.\n  bool EvaluateAsConstantExpr(\n      EvalResult &Result, const ASTContext &Ctx,\n      ConstantExprKind Kind = ConstantExprKind::Normal) const;\n\n  /// If the current Expr is a pointer, this will try to statically\n  /// determine the number of bytes available where the pointer is pointing.\n  /// Returns true if all of the above holds and we were able to figure out the\n  /// size, false otherwise.\n  ///\n  /// \\param Type - How to evaluate the size of the Expr, as defined by the\n  /// \"type\" parameter of __builtin_object_size\n  bool tryEvaluateObjectSize(uint64_t &Result, ASTContext &Ctx,\n                             unsigned Type) const;\n\n  /// Enumeration used to describe the kind of Null pointer constant\n  /// returned from \\c isNullPointerConstant().\n  enum NullPointerConstantKind {\n    /// Expression is not a Null pointer constant.\n    NPCK_NotNull = 0,\n\n    /// Expression is a Null pointer constant built from a zero integer\n    /// expression that is not a simple, possibly parenthesized, zero literal.\n    /// C++ Core Issue 903 will classify these expressions as \"not pointers\"\n    /// once it is adopted.\n    /// http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_active.html#903\n    NPCK_ZeroExpression,\n\n    /// Expression is a Null pointer constant built from a literal zero.\n    NPCK_ZeroLiteral,\n\n    /// Expression is a C++11 nullptr.\n    NPCK_CXX11_nullptr,\n\n    /// Expression is a GNU-style __null constant.\n    NPCK_GNUNull\n  };\n\n  /// Enumeration used to describe how \\c isNullPointerConstant()\n  /// should cope with value-dependent expressions.\n  enum NullPointerConstantValueDependence {\n    /// Specifies that the expression should never be value-dependent.\n    NPC_NeverValueDependent = 0,\n\n    /// Specifies that a value-dependent expression of integral or\n    /// dependent type should be considered a null pointer constant.\n    NPC_ValueDependentIsNull,\n\n    /// Specifies that a value-dependent expression should be considered\n    /// to never be a null pointer constant.\n    NPC_ValueDependentIsNotNull\n  };\n\n  /// isNullPointerConstant - C99 6.3.2.3p3 - Test if this reduces down to\n  /// a Null pointer constant. The return value can further distinguish the\n  /// kind of NULL pointer constant that was detected.\n  NullPointerConstantKind isNullPointerConstant(\n      ASTContext &Ctx,\n      NullPointerConstantValueDependence NPC) const;\n\n  /// isOBJCGCCandidate - Return true if this expression may be used in a read/\n  /// write barrier.\n  bool isOBJCGCCandidate(ASTContext &Ctx) const;\n\n  /// Returns true if this expression is a bound member function.\n  bool isBoundMemberFunction(ASTContext &Ctx) const;\n\n  /// Given an expression of bound-member type, find the type\n  /// of the member.  Returns null if this is an *overloaded* bound\n  /// member expression.\n  static QualType findBoundMemberType(const Expr *expr);\n\n  /// Skip past any invisble AST nodes which might surround this\n  /// statement, such as ExprWithCleanups or ImplicitCastExpr nodes,\n  /// but also injected CXXMemberExpr and CXXConstructExpr which represent\n  /// implicit conversions.\n  Expr *IgnoreUnlessSpelledInSource();\n  const Expr *IgnoreUnlessSpelledInSource() const {\n    return const_cast<Expr *>(this)->IgnoreUnlessSpelledInSource();\n  }\n\n  /// Skip past any implicit casts which might surround this expression until\n  /// reaching a fixed point. Skips:\n  /// * ImplicitCastExpr\n  /// * FullExpr\n  Expr *IgnoreImpCasts() LLVM_READONLY;\n  const Expr *IgnoreImpCasts() const {\n    return const_cast<Expr *>(this)->IgnoreImpCasts();\n  }\n\n  /// Skip past any casts which might surround this expression until reaching\n  /// a fixed point. Skips:\n  /// * CastExpr\n  /// * FullExpr\n  /// * MaterializeTemporaryExpr\n  /// * SubstNonTypeTemplateParmExpr\n  Expr *IgnoreCasts() LLVM_READONLY;\n  const Expr *IgnoreCasts() const {\n    return const_cast<Expr *>(this)->IgnoreCasts();\n  }\n\n  /// Skip past any implicit AST nodes which might surround this expression\n  /// until reaching a fixed point. Skips:\n  /// * What IgnoreImpCasts() skips\n  /// * MaterializeTemporaryExpr\n  /// * CXXBindTemporaryExpr\n  Expr *IgnoreImplicit() LLVM_READONLY;\n  const Expr *IgnoreImplicit() const {\n    return const_cast<Expr *>(this)->IgnoreImplicit();\n  }\n\n  /// Skip past any implicit AST nodes which might surround this expression\n  /// until reaching a fixed point. Same as IgnoreImplicit, except that it\n  /// also skips over implicit calls to constructors and conversion functions.\n  ///\n  /// FIXME: Should IgnoreImplicit do this?\n  Expr *IgnoreImplicitAsWritten() LLVM_READONLY;\n  const Expr *IgnoreImplicitAsWritten() const {\n    return const_cast<Expr *>(this)->IgnoreImplicitAsWritten();\n  }\n\n  /// Skip past any parentheses which might surround this expression until\n  /// reaching a fixed point. Skips:\n  /// * ParenExpr\n  /// * UnaryOperator if `UO_Extension`\n  /// * GenericSelectionExpr if `!isResultDependent()`\n  /// * ChooseExpr if `!isConditionDependent()`\n  /// * ConstantExpr\n  Expr *IgnoreParens() LLVM_READONLY;\n  const Expr *IgnoreParens() const {\n    return const_cast<Expr *>(this)->IgnoreParens();\n  }\n\n  /// Skip past any parentheses and implicit casts which might surround this\n  /// expression until reaching a fixed point.\n  /// FIXME: IgnoreParenImpCasts really ought to be equivalent to\n  /// IgnoreParens() + IgnoreImpCasts() until reaching a fixed point. However\n  /// this is currently not the case. Instead IgnoreParenImpCasts() skips:\n  /// * What IgnoreParens() skips\n  /// * What IgnoreImpCasts() skips\n  /// * MaterializeTemporaryExpr\n  /// * SubstNonTypeTemplateParmExpr\n  Expr *IgnoreParenImpCasts() LLVM_READONLY;\n  const Expr *IgnoreParenImpCasts() const {\n    return const_cast<Expr *>(this)->IgnoreParenImpCasts();\n  }\n\n  /// Skip past any parentheses and casts which might surround this expression\n  /// until reaching a fixed point. Skips:\n  /// * What IgnoreParens() skips\n  /// * What IgnoreCasts() skips\n  Expr *IgnoreParenCasts() LLVM_READONLY;\n  const Expr *IgnoreParenCasts() const {\n    return const_cast<Expr *>(this)->IgnoreParenCasts();\n  }\n\n  /// Skip conversion operators. If this Expr is a call to a conversion\n  /// operator, return the argument.\n  Expr *IgnoreConversionOperatorSingleStep() LLVM_READONLY;\n  const Expr *IgnoreConversionOperatorSingleStep() const {\n    return const_cast<Expr *>(this)->IgnoreConversionOperatorSingleStep();\n  }\n\n  /// Skip past any parentheses and lvalue casts which might surround this\n  /// expression until reaching a fixed point. Skips:\n  /// * What IgnoreParens() skips\n  /// * What IgnoreCasts() skips, except that only lvalue-to-rvalue\n  ///   casts are skipped\n  /// FIXME: This is intended purely as a temporary workaround for code\n  /// that hasn't yet been rewritten to do the right thing about those\n  /// casts, and may disappear along with the last internal use.\n  Expr *IgnoreParenLValueCasts() LLVM_READONLY;\n  const Expr *IgnoreParenLValueCasts() const {\n    return const_cast<Expr *>(this)->IgnoreParenLValueCasts();\n  }\n\n  /// Skip past any parenthese and casts which do not change the value\n  /// (including ptr->int casts of the same size) until reaching a fixed point.\n  /// Skips:\n  /// * What IgnoreParens() skips\n  /// * CastExpr which do not change the value\n  /// * SubstNonTypeTemplateParmExpr\n  Expr *IgnoreParenNoopCasts(const ASTContext &Ctx) LLVM_READONLY;\n  const Expr *IgnoreParenNoopCasts(const ASTContext &Ctx) const {\n    return const_cast<Expr *>(this)->IgnoreParenNoopCasts(Ctx);\n  }\n\n  /// Skip past any parentheses and derived-to-base casts until reaching a\n  /// fixed point. Skips:\n  /// * What IgnoreParens() skips\n  /// * CastExpr which represent a derived-to-base cast (CK_DerivedToBase,\n  ///   CK_UncheckedDerivedToBase and CK_NoOp)\n  Expr *IgnoreParenBaseCasts() LLVM_READONLY;\n  const Expr *IgnoreParenBaseCasts() const {\n    return const_cast<Expr *>(this)->IgnoreParenBaseCasts();\n  }\n\n  /// Determine whether this expression is a default function argument.\n  ///\n  /// Default arguments are implicitly generated in the abstract syntax tree\n  /// by semantic analysis for function calls, object constructions, etc. in\n  /// C++. Default arguments are represented by \\c CXXDefaultArgExpr nodes;\n  /// this routine also looks through any implicit casts to determine whether\n  /// the expression is a default argument.\n  bool isDefaultArgument() const;\n\n  /// Determine whether the result of this expression is a\n  /// temporary object of the given class type.\n  bool isTemporaryObject(ASTContext &Ctx, const CXXRecordDecl *TempTy) const;\n\n  /// Whether this expression is an implicit reference to 'this' in C++.\n  bool isImplicitCXXThis() const;\n\n  static bool hasAnyTypeDependentArguments(ArrayRef<Expr *> Exprs);\n\n  /// For an expression of class type or pointer to class type,\n  /// return the most derived class decl the expression is known to refer to.\n  ///\n  /// If this expression is a cast, this method looks through it to find the\n  /// most derived decl that can be inferred from the expression.\n  /// This is valid because derived-to-base conversions have undefined\n  /// behavior if the object isn't dynamically of the derived type.\n  const CXXRecordDecl *getBestDynamicClassType() const;\n\n  /// Get the inner expression that determines the best dynamic class.\n  /// If this is a prvalue, we guarantee that it is of the most-derived type\n  /// for the object itself.\n  const Expr *getBestDynamicClassTypeExpr() const;\n\n  /// Walk outwards from an expression we want to bind a reference to and\n  /// find the expression whose lifetime needs to be extended. Record\n  /// the LHSs of comma expressions and adjustments needed along the path.\n  const Expr *skipRValueSubobjectAdjustments(\n      SmallVectorImpl<const Expr *> &CommaLHS,\n      SmallVectorImpl<SubobjectAdjustment> &Adjustments) const;\n  const Expr *skipRValueSubobjectAdjustments() const {\n    SmallVector<const Expr *, 8> CommaLHSs;\n    SmallVector<SubobjectAdjustment, 8> Adjustments;\n    return skipRValueSubobjectAdjustments(CommaLHSs, Adjustments);\n  }\n\n  /// Checks that the two Expr's will refer to the same value as a comparison\n  /// operand.  The caller must ensure that the values referenced by the Expr's\n  /// are not modified between E1 and E2 or the result my be invalid.\n  static bool isSameComparisonOperand(const Expr* E1, const Expr* E2);\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() >= firstExprConstant &&\n           T->getStmtClass() <= lastExprConstant;\n  }\n};\n// PointerLikeTypeTraits is specialized so it can be used with a forward-decl of\n// Expr. Verify that we got it right.\nstatic_assert(llvm::PointerLikeTypeTraits<Expr *>::NumLowBitsAvailable <=\n                  llvm::detail::ConstantLog2<alignof(Expr)>::value,\n              \"PointerLikeTypeTraits<Expr*> assumes too much alignment.\");\n\nusing ConstantExprKind = Expr::ConstantExprKind;\n\n//===----------------------------------------------------------------------===//\n// Wrapper Expressions.\n//===----------------------------------------------------------------------===//\n\n/// FullExpr - Represents a \"full-expression\" node.\nclass FullExpr : public Expr {\nprotected:\n Stmt *SubExpr;\n\n FullExpr(StmtClass SC, Expr *subexpr)\n     : Expr(SC, subexpr->getType(), subexpr->getValueKind(),\n            subexpr->getObjectKind()),\n       SubExpr(subexpr) {\n   setDependence(computeDependence(this));\n }\n  FullExpr(StmtClass SC, EmptyShell Empty)\n    : Expr(SC, Empty) {}\npublic:\n  const Expr *getSubExpr() const { return cast<Expr>(SubExpr); }\n  Expr *getSubExpr() { return cast<Expr>(SubExpr); }\n\n  /// As with any mutator of the AST, be very careful when modifying an\n  /// existing AST to preserve its invariants.\n  void setSubExpr(Expr *E) { SubExpr = E; }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() >= firstFullExprConstant &&\n           T->getStmtClass() <= lastFullExprConstant;\n  }\n};\n\n/// ConstantExpr - An expression that occurs in a constant context and\n/// optionally the result of evaluating the expression.\nclass ConstantExpr final\n    : public FullExpr,\n      private llvm::TrailingObjects<ConstantExpr, APValue, uint64_t> {\n  static_assert(std::is_same<uint64_t, llvm::APInt::WordType>::value,\n                \"ConstantExpr assumes that llvm::APInt::WordType is uint64_t \"\n                \"for tail-allocated storage\");\n  friend TrailingObjects;\n  friend class ASTStmtReader;\n  friend class ASTStmtWriter;\n\npublic:\n  /// Describes the kind of result that can be tail-allocated.\n  enum ResultStorageKind { RSK_None, RSK_Int64, RSK_APValue };\n\nprivate:\n  size_t numTrailingObjects(OverloadToken<APValue>) const {\n    return ConstantExprBits.ResultKind == ConstantExpr::RSK_APValue;\n  }\n  size_t numTrailingObjects(OverloadToken<uint64_t>) const {\n    return ConstantExprBits.ResultKind == ConstantExpr::RSK_Int64;\n  }\n\n  uint64_t &Int64Result() {\n    assert(ConstantExprBits.ResultKind == ConstantExpr::RSK_Int64 &&\n           \"invalid accessor\");\n    return *getTrailingObjects<uint64_t>();\n  }\n  const uint64_t &Int64Result() const {\n    return const_cast<ConstantExpr *>(this)->Int64Result();\n  }\n  APValue &APValueResult() {\n    assert(ConstantExprBits.ResultKind == ConstantExpr::RSK_APValue &&\n           \"invalid accessor\");\n    return *getTrailingObjects<APValue>();\n  }\n  APValue &APValueResult() const {\n    return const_cast<ConstantExpr *>(this)->APValueResult();\n  }\n\n  ConstantExpr(Expr *SubExpr, ResultStorageKind StorageKind,\n               bool IsImmediateInvocation);\n  ConstantExpr(EmptyShell Empty, ResultStorageKind StorageKind);\n\npublic:\n  static ConstantExpr *Create(const ASTContext &Context, Expr *E,\n                              const APValue &Result);\n  static ConstantExpr *Create(const ASTContext &Context, Expr *E,\n                              ResultStorageKind Storage = RSK_None,\n                              bool IsImmediateInvocation = false);\n  static ConstantExpr *CreateEmpty(const ASTContext &Context,\n                                   ResultStorageKind StorageKind);\n\n  static ResultStorageKind getStorageKind(const APValue &Value);\n  static ResultStorageKind getStorageKind(const Type *T,\n                                          const ASTContext &Context);\n\n  SourceLocation getBeginLoc() const LLVM_READONLY {\n    return SubExpr->getBeginLoc();\n  }\n  SourceLocation getEndLoc() const LLVM_READONLY {\n    return SubExpr->getEndLoc();\n  }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == ConstantExprClass;\n  }\n\n  void SetResult(APValue Value, const ASTContext &Context) {\n    MoveIntoResult(Value, Context);\n  }\n  void MoveIntoResult(APValue &Value, const ASTContext &Context);\n\n  APValue::ValueKind getResultAPValueKind() const {\n    return static_cast<APValue::ValueKind>(ConstantExprBits.APValueKind);\n  }\n  ResultStorageKind getResultStorageKind() const {\n    return static_cast<ResultStorageKind>(ConstantExprBits.ResultKind);\n  }\n  bool isImmediateInvocation() const {\n    return ConstantExprBits.IsImmediateInvocation;\n  }\n  bool hasAPValueResult() const {\n    return ConstantExprBits.APValueKind != APValue::None;\n  }\n  APValue getAPValueResult() const;\n  APValue &getResultAsAPValue() const { return APValueResult(); }\n  llvm::APSInt getResultAsAPSInt() const;\n  // Iterators\n  child_range children() { return child_range(&SubExpr, &SubExpr+1); }\n  const_child_range children() const {\n    return const_child_range(&SubExpr, &SubExpr + 1);\n  }\n};\n\n//===----------------------------------------------------------------------===//\n// Primary Expressions.\n//===----------------------------------------------------------------------===//\n\n/// OpaqueValueExpr - An expression referring to an opaque object of a\n/// fixed type and value class.  These don't correspond to concrete\n/// syntax; instead they're used to express operations (usually copy\n/// operations) on values whose source is generally obvious from\n/// context.\nclass OpaqueValueExpr : public Expr {\n  friend class ASTStmtReader;\n  Expr *SourceExpr;\n\npublic:\n  OpaqueValueExpr(SourceLocation Loc, QualType T, ExprValueKind VK,\n                  ExprObjectKind OK = OK_Ordinary, Expr *SourceExpr = nullptr)\n      : Expr(OpaqueValueExprClass, T, VK, OK), SourceExpr(SourceExpr) {\n    setIsUnique(false);\n    OpaqueValueExprBits.Loc = Loc;\n    setDependence(computeDependence(this));\n  }\n\n  /// Given an expression which invokes a copy constructor --- i.e.  a\n  /// CXXConstructExpr, possibly wrapped in an ExprWithCleanups ---\n  /// find the OpaqueValueExpr that's the source of the construction.\n  static const OpaqueValueExpr *findInCopyConstruct(const Expr *expr);\n\n  explicit OpaqueValueExpr(EmptyShell Empty)\n    : Expr(OpaqueValueExprClass, Empty) {}\n\n  /// Retrieve the location of this expression.\n  SourceLocation getLocation() const { return OpaqueValueExprBits.Loc; }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY {\n    return SourceExpr ? SourceExpr->getBeginLoc() : getLocation();\n  }\n  SourceLocation getEndLoc() const LLVM_READONLY {\n    return SourceExpr ? SourceExpr->getEndLoc() : getLocation();\n  }\n  SourceLocation getExprLoc() const LLVM_READONLY {\n    return SourceExpr ? SourceExpr->getExprLoc() : getLocation();\n  }\n\n  child_range children() {\n    return child_range(child_iterator(), child_iterator());\n  }\n\n  const_child_range children() const {\n    return const_child_range(const_child_iterator(), const_child_iterator());\n  }\n\n  /// The source expression of an opaque value expression is the\n  /// expression which originally generated the value.  This is\n  /// provided as a convenience for analyses that don't wish to\n  /// precisely model the execution behavior of the program.\n  ///\n  /// The source expression is typically set when building the\n  /// expression which binds the opaque value expression in the first\n  /// place.\n  Expr *getSourceExpr() const { return SourceExpr; }\n\n  void setIsUnique(bool V) {\n    assert((!V || SourceExpr) &&\n           \"unique OVEs are expected to have source expressions\");\n    OpaqueValueExprBits.IsUnique = V;\n  }\n\n  bool isUnique() const { return OpaqueValueExprBits.IsUnique; }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == OpaqueValueExprClass;\n  }\n};\n\n/// A reference to a declared variable, function, enum, etc.\n/// [C99 6.5.1p2]\n///\n/// This encodes all the information about how a declaration is referenced\n/// within an expression.\n///\n/// There are several optional constructs attached to DeclRefExprs only when\n/// they apply in order to conserve memory. These are laid out past the end of\n/// the object, and flags in the DeclRefExprBitfield track whether they exist:\n///\n///   DeclRefExprBits.HasQualifier:\n///       Specifies when this declaration reference expression has a C++\n///       nested-name-specifier.\n///   DeclRefExprBits.HasFoundDecl:\n///       Specifies when this declaration reference expression has a record of\n///       a NamedDecl (different from the referenced ValueDecl) which was found\n///       during name lookup and/or overload resolution.\n///   DeclRefExprBits.HasTemplateKWAndArgsInfo:\n///       Specifies when this declaration reference expression has an explicit\n///       C++ template keyword and/or template argument list.\n///   DeclRefExprBits.RefersToEnclosingVariableOrCapture\n///       Specifies when this declaration reference expression (validly)\n///       refers to an enclosed local or a captured variable.\nclass DeclRefExpr final\n    : public Expr,\n      private llvm::TrailingObjects<DeclRefExpr, NestedNameSpecifierLoc,\n                                    NamedDecl *, ASTTemplateKWAndArgsInfo,\n                                    TemplateArgumentLoc> {\n  friend class ASTStmtReader;\n  friend class ASTStmtWriter;\n  friend TrailingObjects;\n\n  /// The declaration that we are referencing.\n  ValueDecl *D;\n\n  /// Provides source/type location info for the declaration name\n  /// embedded in D.\n  DeclarationNameLoc DNLoc;\n\n  size_t numTrailingObjects(OverloadToken<NestedNameSpecifierLoc>) const {\n    return hasQualifier();\n  }\n\n  size_t numTrailingObjects(OverloadToken<NamedDecl *>) const {\n    return hasFoundDecl();\n  }\n\n  size_t numTrailingObjects(OverloadToken<ASTTemplateKWAndArgsInfo>) const {\n    return hasTemplateKWAndArgsInfo();\n  }\n\n  /// Test whether there is a distinct FoundDecl attached to the end of\n  /// this DRE.\n  bool hasFoundDecl() const { return DeclRefExprBits.HasFoundDecl; }\n\n  DeclRefExpr(const ASTContext &Ctx, NestedNameSpecifierLoc QualifierLoc,\n              SourceLocation TemplateKWLoc, ValueDecl *D,\n              bool RefersToEnlosingVariableOrCapture,\n              const DeclarationNameInfo &NameInfo, NamedDecl *FoundD,\n              const TemplateArgumentListInfo *TemplateArgs, QualType T,\n              ExprValueKind VK, NonOdrUseReason NOUR);\n\n  /// Construct an empty declaration reference expression.\n  explicit DeclRefExpr(EmptyShell Empty) : Expr(DeclRefExprClass, Empty) {}\n\npublic:\n  DeclRefExpr(const ASTContext &Ctx, ValueDecl *D,\n              bool RefersToEnclosingVariableOrCapture, QualType T,\n              ExprValueKind VK, SourceLocation L,\n              const DeclarationNameLoc &LocInfo = DeclarationNameLoc(),\n              NonOdrUseReason NOUR = NOUR_None);\n\n  static DeclRefExpr *\n  Create(const ASTContext &Context, NestedNameSpecifierLoc QualifierLoc,\n         SourceLocation TemplateKWLoc, ValueDecl *D,\n         bool RefersToEnclosingVariableOrCapture, SourceLocation NameLoc,\n         QualType T, ExprValueKind VK, NamedDecl *FoundD = nullptr,\n         const TemplateArgumentListInfo *TemplateArgs = nullptr,\n         NonOdrUseReason NOUR = NOUR_None);\n\n  static DeclRefExpr *\n  Create(const ASTContext &Context, NestedNameSpecifierLoc QualifierLoc,\n         SourceLocation TemplateKWLoc, ValueDecl *D,\n         bool RefersToEnclosingVariableOrCapture,\n         const DeclarationNameInfo &NameInfo, QualType T, ExprValueKind VK,\n         NamedDecl *FoundD = nullptr,\n         const TemplateArgumentListInfo *TemplateArgs = nullptr,\n         NonOdrUseReason NOUR = NOUR_None);\n\n  /// Construct an empty declaration reference expression.\n  static DeclRefExpr *CreateEmpty(const ASTContext &Context, bool HasQualifier,\n                                  bool HasFoundDecl,\n                                  bool HasTemplateKWAndArgsInfo,\n                                  unsigned NumTemplateArgs);\n\n  ValueDecl *getDecl() { return D; }\n  const ValueDecl *getDecl() const { return D; }\n  void setDecl(ValueDecl *NewD);\n\n  DeclarationNameInfo getNameInfo() const {\n    return DeclarationNameInfo(getDecl()->getDeclName(), getLocation(), DNLoc);\n  }\n\n  SourceLocation getLocation() const { return DeclRefExprBits.Loc; }\n  void setLocation(SourceLocation L) { DeclRefExprBits.Loc = L; }\n  SourceLocation getBeginLoc() const LLVM_READONLY;\n  SourceLocation getEndLoc() const LLVM_READONLY;\n\n  /// Determine whether this declaration reference was preceded by a\n  /// C++ nested-name-specifier, e.g., \\c N::foo.\n  bool hasQualifier() const { return DeclRefExprBits.HasQualifier; }\n\n  /// If the name was qualified, retrieves the nested-name-specifier\n  /// that precedes the name, with source-location information.\n  NestedNameSpecifierLoc getQualifierLoc() const {\n    if (!hasQualifier())\n      return NestedNameSpecifierLoc();\n    return *getTrailingObjects<NestedNameSpecifierLoc>();\n  }\n\n  /// If the name was qualified, retrieves the nested-name-specifier\n  /// that precedes the name. Otherwise, returns NULL.\n  NestedNameSpecifier *getQualifier() const {\n    return getQualifierLoc().getNestedNameSpecifier();\n  }\n\n  /// Get the NamedDecl through which this reference occurred.\n  ///\n  /// This Decl may be different from the ValueDecl actually referred to in the\n  /// presence of using declarations, etc. It always returns non-NULL, and may\n  /// simple return the ValueDecl when appropriate.\n\n  NamedDecl *getFoundDecl() {\n    return hasFoundDecl() ? *getTrailingObjects<NamedDecl *>() : D;\n  }\n\n  /// Get the NamedDecl through which this reference occurred.\n  /// See non-const variant.\n  const NamedDecl *getFoundDecl() const {\n    return hasFoundDecl() ? *getTrailingObjects<NamedDecl *>() : D;\n  }\n\n  bool hasTemplateKWAndArgsInfo() const {\n    return DeclRefExprBits.HasTemplateKWAndArgsInfo;\n  }\n\n  /// Retrieve the location of the template keyword preceding\n  /// this name, if any.\n  SourceLocation getTemplateKeywordLoc() const {\n    if (!hasTemplateKWAndArgsInfo())\n      return SourceLocation();\n    return getTrailingObjects<ASTTemplateKWAndArgsInfo>()->TemplateKWLoc;\n  }\n\n  /// Retrieve the location of the left angle bracket starting the\n  /// explicit template argument list following the name, if any.\n  SourceLocation getLAngleLoc() const {\n    if (!hasTemplateKWAndArgsInfo())\n      return SourceLocation();\n    return getTrailingObjects<ASTTemplateKWAndArgsInfo>()->LAngleLoc;\n  }\n\n  /// Retrieve the location of the right angle bracket ending the\n  /// explicit template argument list following the name, if any.\n  SourceLocation getRAngleLoc() const {\n    if (!hasTemplateKWAndArgsInfo())\n      return SourceLocation();\n    return getTrailingObjects<ASTTemplateKWAndArgsInfo>()->RAngleLoc;\n  }\n\n  /// Determines whether the name in this declaration reference\n  /// was preceded by the template keyword.\n  bool hasTemplateKeyword() const { return getTemplateKeywordLoc().isValid(); }\n\n  /// Determines whether this declaration reference was followed by an\n  /// explicit template argument list.\n  bool hasExplicitTemplateArgs() const { return getLAngleLoc().isValid(); }\n\n  /// Copies the template arguments (if present) into the given\n  /// structure.\n  void copyTemplateArgumentsInto(TemplateArgumentListInfo &List) const {\n    if (hasExplicitTemplateArgs())\n      getTrailingObjects<ASTTemplateKWAndArgsInfo>()->copyInto(\n          getTrailingObjects<TemplateArgumentLoc>(), List);\n  }\n\n  /// Retrieve the template arguments provided as part of this\n  /// template-id.\n  const TemplateArgumentLoc *getTemplateArgs() const {\n    if (!hasExplicitTemplateArgs())\n      return nullptr;\n    return getTrailingObjects<TemplateArgumentLoc>();\n  }\n\n  /// Retrieve the number of template arguments provided as part of this\n  /// template-id.\n  unsigned getNumTemplateArgs() const {\n    if (!hasExplicitTemplateArgs())\n      return 0;\n    return getTrailingObjects<ASTTemplateKWAndArgsInfo>()->NumTemplateArgs;\n  }\n\n  ArrayRef<TemplateArgumentLoc> template_arguments() const {\n    return {getTemplateArgs(), getNumTemplateArgs()};\n  }\n\n  /// Returns true if this expression refers to a function that\n  /// was resolved from an overloaded set having size greater than 1.\n  bool hadMultipleCandidates() const {\n    return DeclRefExprBits.HadMultipleCandidates;\n  }\n  /// Sets the flag telling whether this expression refers to\n  /// a function that was resolved from an overloaded set having size\n  /// greater than 1.\n  void setHadMultipleCandidates(bool V = true) {\n    DeclRefExprBits.HadMultipleCandidates = V;\n  }\n\n  /// Is this expression a non-odr-use reference, and if so, why?\n  NonOdrUseReason isNonOdrUse() const {\n    return static_cast<NonOdrUseReason>(DeclRefExprBits.NonOdrUseReason);\n  }\n\n  /// Does this DeclRefExpr refer to an enclosing local or a captured\n  /// variable?\n  bool refersToEnclosingVariableOrCapture() const {\n    return DeclRefExprBits.RefersToEnclosingVariableOrCapture;\n  }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == DeclRefExprClass;\n  }\n\n  // Iterators\n  child_range children() {\n    return child_range(child_iterator(), child_iterator());\n  }\n\n  const_child_range children() const {\n    return const_child_range(const_child_iterator(), const_child_iterator());\n  }\n};\n\n/// Used by IntegerLiteral/FloatingLiteral to store the numeric without\n/// leaking memory.\n///\n/// For large floats/integers, APFloat/APInt will allocate memory from the heap\n/// to represent these numbers.  Unfortunately, when we use a BumpPtrAllocator\n/// to allocate IntegerLiteral/FloatingLiteral nodes the memory associated with\n/// the APFloat/APInt values will never get freed. APNumericStorage uses\n/// ASTContext's allocator for memory allocation.\nclass APNumericStorage {\n  union {\n    uint64_t VAL;    ///< Used to store the <= 64 bits integer value.\n    uint64_t *pVal;  ///< Used to store the >64 bits integer value.\n  };\n  unsigned BitWidth;\n\n  bool hasAllocation() const { return llvm::APInt::getNumWords(BitWidth) > 1; }\n\n  APNumericStorage(const APNumericStorage &) = delete;\n  void operator=(const APNumericStorage &) = delete;\n\nprotected:\n  APNumericStorage() : VAL(0), BitWidth(0) { }\n\n  llvm::APInt getIntValue() const {\n    unsigned NumWords = llvm::APInt::getNumWords(BitWidth);\n    if (NumWords > 1)\n      return llvm::APInt(BitWidth, NumWords, pVal);\n    else\n      return llvm::APInt(BitWidth, VAL);\n  }\n  void setIntValue(const ASTContext &C, const llvm::APInt &Val);\n};\n\nclass APIntStorage : private APNumericStorage {\npublic:\n  llvm::APInt getValue() const { return getIntValue(); }\n  void setValue(const ASTContext &C, const llvm::APInt &Val) {\n    setIntValue(C, Val);\n  }\n};\n\nclass APFloatStorage : private APNumericStorage {\npublic:\n  llvm::APFloat getValue(const llvm::fltSemantics &Semantics) const {\n    return llvm::APFloat(Semantics, getIntValue());\n  }\n  void setValue(const ASTContext &C, const llvm::APFloat &Val) {\n    setIntValue(C, Val.bitcastToAPInt());\n  }\n};\n\nclass IntegerLiteral : public Expr, public APIntStorage {\n  SourceLocation Loc;\n\n  /// Construct an empty integer literal.\n  explicit IntegerLiteral(EmptyShell Empty)\n    : Expr(IntegerLiteralClass, Empty) { }\n\npublic:\n  // type should be IntTy, LongTy, LongLongTy, UnsignedIntTy, UnsignedLongTy,\n  // or UnsignedLongLongTy\n  IntegerLiteral(const ASTContext &C, const llvm::APInt &V, QualType type,\n                 SourceLocation l);\n\n  /// Returns a new integer literal with value 'V' and type 'type'.\n  /// \\param type - either IntTy, LongTy, LongLongTy, UnsignedIntTy,\n  /// UnsignedLongTy, or UnsignedLongLongTy which should match the size of V\n  /// \\param V - the value that the returned integer literal contains.\n  static IntegerLiteral *Create(const ASTContext &C, const llvm::APInt &V,\n                                QualType type, SourceLocation l);\n  /// Returns a new empty integer literal.\n  static IntegerLiteral *Create(const ASTContext &C, EmptyShell Empty);\n\n  SourceLocation getBeginLoc() const LLVM_READONLY { return Loc; }\n  SourceLocation getEndLoc() const LLVM_READONLY { return Loc; }\n\n  /// Retrieve the location of the literal.\n  SourceLocation getLocation() const { return Loc; }\n\n  void setLocation(SourceLocation Location) { Loc = Location; }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == IntegerLiteralClass;\n  }\n\n  // Iterators\n  child_range children() {\n    return child_range(child_iterator(), child_iterator());\n  }\n  const_child_range children() const {\n    return const_child_range(const_child_iterator(), const_child_iterator());\n  }\n};\n\nclass FixedPointLiteral : public Expr, public APIntStorage {\n  SourceLocation Loc;\n  unsigned Scale;\n\n  /// \\brief Construct an empty fixed-point literal.\n  explicit FixedPointLiteral(EmptyShell Empty)\n      : Expr(FixedPointLiteralClass, Empty) {}\n\n public:\n  FixedPointLiteral(const ASTContext &C, const llvm::APInt &V, QualType type,\n                    SourceLocation l, unsigned Scale);\n\n  // Store the int as is without any bit shifting.\n  static FixedPointLiteral *CreateFromRawInt(const ASTContext &C,\n                                             const llvm::APInt &V,\n                                             QualType type, SourceLocation l,\n                                             unsigned Scale);\n\n  /// Returns an empty fixed-point literal.\n  static FixedPointLiteral *Create(const ASTContext &C, EmptyShell Empty);\n\n  SourceLocation getBeginLoc() const LLVM_READONLY { return Loc; }\n  SourceLocation getEndLoc() const LLVM_READONLY { return Loc; }\n\n  /// \\brief Retrieve the location of the literal.\n  SourceLocation getLocation() const { return Loc; }\n\n  void setLocation(SourceLocation Location) { Loc = Location; }\n\n  unsigned getScale() const { return Scale; }\n  void setScale(unsigned S) { Scale = S; }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == FixedPointLiteralClass;\n  }\n\n  std::string getValueAsString(unsigned Radix) const;\n\n  // Iterators\n  child_range children() {\n    return child_range(child_iterator(), child_iterator());\n  }\n  const_child_range children() const {\n    return const_child_range(const_child_iterator(), const_child_iterator());\n  }\n};\n\nclass CharacterLiteral : public Expr {\npublic:\n  enum CharacterKind {\n    Ascii,\n    Wide,\n    UTF8,\n    UTF16,\n    UTF32\n  };\n\nprivate:\n  unsigned Value;\n  SourceLocation Loc;\npublic:\n  // type should be IntTy\n  CharacterLiteral(unsigned value, CharacterKind kind, QualType type,\n                   SourceLocation l)\n      : Expr(CharacterLiteralClass, type, VK_RValue, OK_Ordinary), Value(value),\n        Loc(l) {\n    CharacterLiteralBits.Kind = kind;\n    setDependence(ExprDependence::None);\n  }\n\n  /// Construct an empty character literal.\n  CharacterLiteral(EmptyShell Empty) : Expr(CharacterLiteralClass, Empty) { }\n\n  SourceLocation getLocation() const { return Loc; }\n  CharacterKind getKind() const {\n    return static_cast<CharacterKind>(CharacterLiteralBits.Kind);\n  }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY { return Loc; }\n  SourceLocation getEndLoc() const LLVM_READONLY { return Loc; }\n\n  unsigned getValue() const { return Value; }\n\n  void setLocation(SourceLocation Location) { Loc = Location; }\n  void setKind(CharacterKind kind) { CharacterLiteralBits.Kind = kind; }\n  void setValue(unsigned Val) { Value = Val; }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == CharacterLiteralClass;\n  }\n\n  // Iterators\n  child_range children() {\n    return child_range(child_iterator(), child_iterator());\n  }\n  const_child_range children() const {\n    return const_child_range(const_child_iterator(), const_child_iterator());\n  }\n};\n\nclass FloatingLiteral : public Expr, private APFloatStorage {\n  SourceLocation Loc;\n\n  FloatingLiteral(const ASTContext &C, const llvm::APFloat &V, bool isexact,\n                  QualType Type, SourceLocation L);\n\n  /// Construct an empty floating-point literal.\n  explicit FloatingLiteral(const ASTContext &C, EmptyShell Empty);\n\npublic:\n  static FloatingLiteral *Create(const ASTContext &C, const llvm::APFloat &V,\n                                 bool isexact, QualType Type, SourceLocation L);\n  static FloatingLiteral *Create(const ASTContext &C, EmptyShell Empty);\n\n  llvm::APFloat getValue() const {\n    return APFloatStorage::getValue(getSemantics());\n  }\n  void setValue(const ASTContext &C, const llvm::APFloat &Val) {\n    assert(&getSemantics() == &Val.getSemantics() && \"Inconsistent semantics\");\n    APFloatStorage::setValue(C, Val);\n  }\n\n  /// Get a raw enumeration value representing the floating-point semantics of\n  /// this literal (32-bit IEEE, x87, ...), suitable for serialisation.\n  llvm::APFloatBase::Semantics getRawSemantics() const {\n    return static_cast<llvm::APFloatBase::Semantics>(\n        FloatingLiteralBits.Semantics);\n  }\n\n  /// Set the raw enumeration value representing the floating-point semantics of\n  /// this literal (32-bit IEEE, x87, ...), suitable for serialisation.\n  void setRawSemantics(llvm::APFloatBase::Semantics Sem) {\n    FloatingLiteralBits.Semantics = Sem;\n  }\n\n  /// Return the APFloat semantics this literal uses.\n  const llvm::fltSemantics &getSemantics() const {\n    return llvm::APFloatBase::EnumToSemantics(\n        static_cast<llvm::APFloatBase::Semantics>(\n            FloatingLiteralBits.Semantics));\n  }\n\n  /// Set the APFloat semantics this literal uses.\n  void setSemantics(const llvm::fltSemantics &Sem) {\n    FloatingLiteralBits.Semantics = llvm::APFloatBase::SemanticsToEnum(Sem);\n  }\n\n  bool isExact() const { return FloatingLiteralBits.IsExact; }\n  void setExact(bool E) { FloatingLiteralBits.IsExact = E; }\n\n  /// getValueAsApproximateDouble - This returns the value as an inaccurate\n  /// double.  Note that this may cause loss of precision, but is useful for\n  /// debugging dumps, etc.\n  double getValueAsApproximateDouble() const;\n\n  SourceLocation getLocation() const { return Loc; }\n  void setLocation(SourceLocation L) { Loc = L; }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY { return Loc; }\n  SourceLocation getEndLoc() const LLVM_READONLY { return Loc; }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == FloatingLiteralClass;\n  }\n\n  // Iterators\n  child_range children() {\n    return child_range(child_iterator(), child_iterator());\n  }\n  const_child_range children() const {\n    return const_child_range(const_child_iterator(), const_child_iterator());\n  }\n};\n\n/// ImaginaryLiteral - We support imaginary integer and floating point literals,\n/// like \"1.0i\".  We represent these as a wrapper around FloatingLiteral and\n/// IntegerLiteral classes.  Instances of this class always have a Complex type\n/// whose element type matches the subexpression.\n///\nclass ImaginaryLiteral : public Expr {\n  Stmt *Val;\npublic:\n  ImaginaryLiteral(Expr *val, QualType Ty)\n      : Expr(ImaginaryLiteralClass, Ty, VK_RValue, OK_Ordinary), Val(val) {\n    setDependence(ExprDependence::None);\n  }\n\n  /// Build an empty imaginary literal.\n  explicit ImaginaryLiteral(EmptyShell Empty)\n    : Expr(ImaginaryLiteralClass, Empty) { }\n\n  const Expr *getSubExpr() const { return cast<Expr>(Val); }\n  Expr *getSubExpr() { return cast<Expr>(Val); }\n  void setSubExpr(Expr *E) { Val = E; }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY {\n    return Val->getBeginLoc();\n  }\n  SourceLocation getEndLoc() const LLVM_READONLY { return Val->getEndLoc(); }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == ImaginaryLiteralClass;\n  }\n\n  // Iterators\n  child_range children() { return child_range(&Val, &Val+1); }\n  const_child_range children() const {\n    return const_child_range(&Val, &Val + 1);\n  }\n};\n\n/// StringLiteral - This represents a string literal expression, e.g. \"foo\"\n/// or L\"bar\" (wide strings). The actual string data can be obtained with\n/// getBytes() and is NOT null-terminated. The length of the string data is\n/// determined by calling getByteLength().\n///\n/// The C type for a string is always a ConstantArrayType. In C++, the char\n/// type is const qualified, in C it is not.\n///\n/// Note that strings in C can be formed by concatenation of multiple string\n/// literal pptokens in translation phase #6. This keeps track of the locations\n/// of each of these pieces.\n///\n/// Strings in C can also be truncated and extended by assigning into arrays,\n/// e.g. with constructs like:\n///   char X[2] = \"foobar\";\n/// In this case, getByteLength() will return 6, but the string literal will\n/// have type \"char[2]\".\nclass StringLiteral final\n    : public Expr,\n      private llvm::TrailingObjects<StringLiteral, unsigned, SourceLocation,\n                                    char> {\n  friend class ASTStmtReader;\n  friend TrailingObjects;\n\n  /// StringLiteral is followed by several trailing objects. They are in order:\n  ///\n  /// * A single unsigned storing the length in characters of this string. The\n  ///   length in bytes is this length times the width of a single character.\n  ///   Always present and stored as a trailing objects because storing it in\n  ///   StringLiteral would increase the size of StringLiteral by sizeof(void *)\n  ///   due to alignment requirements. If you add some data to StringLiteral,\n  ///   consider moving it inside StringLiteral.\n  ///\n  /// * An array of getNumConcatenated() SourceLocation, one for each of the\n  ///   token this string is made of.\n  ///\n  /// * An array of getByteLength() char used to store the string data.\n\npublic:\n  enum StringKind { Ascii, Wide, UTF8, UTF16, UTF32 };\n\nprivate:\n  unsigned numTrailingObjects(OverloadToken<unsigned>) const { return 1; }\n  unsigned numTrailingObjects(OverloadToken<SourceLocation>) const {\n    return getNumConcatenated();\n  }\n\n  unsigned numTrailingObjects(OverloadToken<char>) const {\n    return getByteLength();\n  }\n\n  char *getStrDataAsChar() { return getTrailingObjects<char>(); }\n  const char *getStrDataAsChar() const { return getTrailingObjects<char>(); }\n\n  const uint16_t *getStrDataAsUInt16() const {\n    return reinterpret_cast<const uint16_t *>(getTrailingObjects<char>());\n  }\n\n  const uint32_t *getStrDataAsUInt32() const {\n    return reinterpret_cast<const uint32_t *>(getTrailingObjects<char>());\n  }\n\n  /// Build a string literal.\n  StringLiteral(const ASTContext &Ctx, StringRef Str, StringKind Kind,\n                bool Pascal, QualType Ty, const SourceLocation *Loc,\n                unsigned NumConcatenated);\n\n  /// Build an empty string literal.\n  StringLiteral(EmptyShell Empty, unsigned NumConcatenated, unsigned Length,\n                unsigned CharByteWidth);\n\n  /// Map a target and string kind to the appropriate character width.\n  static unsigned mapCharByteWidth(TargetInfo const &Target, StringKind SK);\n\n  /// Set one of the string literal token.\n  void setStrTokenLoc(unsigned TokNum, SourceLocation L) {\n    assert(TokNum < getNumConcatenated() && \"Invalid tok number\");\n    getTrailingObjects<SourceLocation>()[TokNum] = L;\n  }\n\npublic:\n  /// This is the \"fully general\" constructor that allows representation of\n  /// strings formed from multiple concatenated tokens.\n  static StringLiteral *Create(const ASTContext &Ctx, StringRef Str,\n                               StringKind Kind, bool Pascal, QualType Ty,\n                               const SourceLocation *Loc,\n                               unsigned NumConcatenated);\n\n  /// Simple constructor for string literals made from one token.\n  static StringLiteral *Create(const ASTContext &Ctx, StringRef Str,\n                               StringKind Kind, bool Pascal, QualType Ty,\n                               SourceLocation Loc) {\n    return Create(Ctx, Str, Kind, Pascal, Ty, &Loc, 1);\n  }\n\n  /// Construct an empty string literal.\n  static StringLiteral *CreateEmpty(const ASTContext &Ctx,\n                                    unsigned NumConcatenated, unsigned Length,\n                                    unsigned CharByteWidth);\n\n  StringRef getString() const {\n    assert(getCharByteWidth() == 1 &&\n           \"This function is used in places that assume strings use char\");\n    return StringRef(getStrDataAsChar(), getByteLength());\n  }\n\n  /// Allow access to clients that need the byte representation, such as\n  /// ASTWriterStmt::VisitStringLiteral().\n  StringRef getBytes() const {\n    // FIXME: StringRef may not be the right type to use as a result for this.\n    return StringRef(getStrDataAsChar(), getByteLength());\n  }\n\n  void outputString(raw_ostream &OS) const;\n\n  uint32_t getCodeUnit(size_t i) const {\n    assert(i < getLength() && \"out of bounds access\");\n    switch (getCharByteWidth()) {\n    case 1:\n      return static_cast<unsigned char>(getStrDataAsChar()[i]);\n    case 2:\n      return getStrDataAsUInt16()[i];\n    case 4:\n      return getStrDataAsUInt32()[i];\n    }\n    llvm_unreachable(\"Unsupported character width!\");\n  }\n\n  unsigned getByteLength() const { return getCharByteWidth() * getLength(); }\n  unsigned getLength() const { return *getTrailingObjects<unsigned>(); }\n  unsigned getCharByteWidth() const { return StringLiteralBits.CharByteWidth; }\n\n  StringKind getKind() const {\n    return static_cast<StringKind>(StringLiteralBits.Kind);\n  }\n\n  bool isAscii() const { return getKind() == Ascii; }\n  bool isWide() const { return getKind() == Wide; }\n  bool isUTF8() const { return getKind() == UTF8; }\n  bool isUTF16() const { return getKind() == UTF16; }\n  bool isUTF32() const { return getKind() == UTF32; }\n  bool isPascal() const { return StringLiteralBits.IsPascal; }\n\n  bool containsNonAscii() const {\n    for (auto c : getString())\n      if (!isASCII(c))\n        return true;\n    return false;\n  }\n\n  bool containsNonAsciiOrNull() const {\n    for (auto c : getString())\n      if (!isASCII(c) || !c)\n        return true;\n    return false;\n  }\n\n  /// getNumConcatenated - Get the number of string literal tokens that were\n  /// concatenated in translation phase #6 to form this string literal.\n  unsigned getNumConcatenated() const {\n    return StringLiteralBits.NumConcatenated;\n  }\n\n  /// Get one of the string literal token.\n  SourceLocation getStrTokenLoc(unsigned TokNum) const {\n    assert(TokNum < getNumConcatenated() && \"Invalid tok number\");\n    return getTrailingObjects<SourceLocation>()[TokNum];\n  }\n\n  /// getLocationOfByte - Return a source location that points to the specified\n  /// byte of this string literal.\n  ///\n  /// Strings are amazingly complex.  They can be formed from multiple tokens\n  /// and can have escape sequences in them in addition to the usual trigraph\n  /// and escaped newline business.  This routine handles this complexity.\n  ///\n  SourceLocation\n  getLocationOfByte(unsigned ByteNo, const SourceManager &SM,\n                    const LangOptions &Features, const TargetInfo &Target,\n                    unsigned *StartToken = nullptr,\n                    unsigned *StartTokenByteOffset = nullptr) const;\n\n  typedef const SourceLocation *tokloc_iterator;\n\n  tokloc_iterator tokloc_begin() const {\n    return getTrailingObjects<SourceLocation>();\n  }\n\n  tokloc_iterator tokloc_end() const {\n    return getTrailingObjects<SourceLocation>() + getNumConcatenated();\n  }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY { return *tokloc_begin(); }\n  SourceLocation getEndLoc() const LLVM_READONLY { return *(tokloc_end() - 1); }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == StringLiteralClass;\n  }\n\n  // Iterators\n  child_range children() {\n    return child_range(child_iterator(), child_iterator());\n  }\n  const_child_range children() const {\n    return const_child_range(const_child_iterator(), const_child_iterator());\n  }\n};\n\n/// [C99 6.4.2.2] - A predefined identifier such as __func__.\nclass PredefinedExpr final\n    : public Expr,\n      private llvm::TrailingObjects<PredefinedExpr, Stmt *> {\n  friend class ASTStmtReader;\n  friend TrailingObjects;\n\n  // PredefinedExpr is optionally followed by a single trailing\n  // \"Stmt *\" for the predefined identifier. It is present if and only if\n  // hasFunctionName() is true and is always a \"StringLiteral *\".\n\npublic:\n  enum IdentKind {\n    Func,\n    Function,\n    LFunction, // Same as Function, but as wide string.\n    FuncDName,\n    FuncSig,\n    LFuncSig, // Same as FuncSig, but as as wide string\n    PrettyFunction,\n    /// The same as PrettyFunction, except that the\n    /// 'virtual' keyword is omitted for virtual member functions.\n    PrettyFunctionNoVirtual\n  };\n\nprivate:\n  PredefinedExpr(SourceLocation L, QualType FNTy, IdentKind IK,\n                 StringLiteral *SL);\n\n  explicit PredefinedExpr(EmptyShell Empty, bool HasFunctionName);\n\n  /// True if this PredefinedExpr has storage for a function name.\n  bool hasFunctionName() const { return PredefinedExprBits.HasFunctionName; }\n\n  void setFunctionName(StringLiteral *SL) {\n    assert(hasFunctionName() &&\n           \"This PredefinedExpr has no storage for a function name!\");\n    *getTrailingObjects<Stmt *>() = SL;\n  }\n\npublic:\n  /// Create a PredefinedExpr.\n  static PredefinedExpr *Create(const ASTContext &Ctx, SourceLocation L,\n                                QualType FNTy, IdentKind IK, StringLiteral *SL);\n\n  /// Create an empty PredefinedExpr.\n  static PredefinedExpr *CreateEmpty(const ASTContext &Ctx,\n                                     bool HasFunctionName);\n\n  IdentKind getIdentKind() const {\n    return static_cast<IdentKind>(PredefinedExprBits.Kind);\n  }\n\n  SourceLocation getLocation() const { return PredefinedExprBits.Loc; }\n  void setLocation(SourceLocation L) { PredefinedExprBits.Loc = L; }\n\n  StringLiteral *getFunctionName() {\n    return hasFunctionName()\n               ? static_cast<StringLiteral *>(*getTrailingObjects<Stmt *>())\n               : nullptr;\n  }\n\n  const StringLiteral *getFunctionName() const {\n    return hasFunctionName()\n               ? static_cast<StringLiteral *>(*getTrailingObjects<Stmt *>())\n               : nullptr;\n  }\n\n  static StringRef getIdentKindName(IdentKind IK);\n  StringRef getIdentKindName() const {\n    return getIdentKindName(getIdentKind());\n  }\n\n  static std::string ComputeName(IdentKind IK, const Decl *CurrentDecl);\n\n  SourceLocation getBeginLoc() const { return getLocation(); }\n  SourceLocation getEndLoc() const { return getLocation(); }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == PredefinedExprClass;\n  }\n\n  // Iterators\n  child_range children() {\n    return child_range(getTrailingObjects<Stmt *>(),\n                       getTrailingObjects<Stmt *>() + hasFunctionName());\n  }\n\n  const_child_range children() const {\n    return const_child_range(getTrailingObjects<Stmt *>(),\n                             getTrailingObjects<Stmt *>() + hasFunctionName());\n  }\n};\n\n/// ParenExpr - This represents a parethesized expression, e.g. \"(1)\".  This\n/// AST node is only formed if full location information is requested.\nclass ParenExpr : public Expr {\n  SourceLocation L, R;\n  Stmt *Val;\npublic:\n  ParenExpr(SourceLocation l, SourceLocation r, Expr *val)\n      : Expr(ParenExprClass, val->getType(), val->getValueKind(),\n             val->getObjectKind()),\n        L(l), R(r), Val(val) {\n    setDependence(computeDependence(this));\n  }\n\n  /// Construct an empty parenthesized expression.\n  explicit ParenExpr(EmptyShell Empty)\n    : Expr(ParenExprClass, Empty) { }\n\n  const Expr *getSubExpr() const { return cast<Expr>(Val); }\n  Expr *getSubExpr() { return cast<Expr>(Val); }\n  void setSubExpr(Expr *E) { Val = E; }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY { return L; }\n  SourceLocation getEndLoc() const LLVM_READONLY { return R; }\n\n  /// Get the location of the left parentheses '('.\n  SourceLocation getLParen() const { return L; }\n  void setLParen(SourceLocation Loc) { L = Loc; }\n\n  /// Get the location of the right parentheses ')'.\n  SourceLocation getRParen() const { return R; }\n  void setRParen(SourceLocation Loc) { R = Loc; }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == ParenExprClass;\n  }\n\n  // Iterators\n  child_range children() { return child_range(&Val, &Val+1); }\n  const_child_range children() const {\n    return const_child_range(&Val, &Val + 1);\n  }\n};\n\n/// UnaryOperator - This represents the unary-expression's (except sizeof and\n/// alignof), the postinc/postdec operators from postfix-expression, and various\n/// extensions.\n///\n/// Notes on various nodes:\n///\n/// Real/Imag - These return the real/imag part of a complex operand.  If\n///   applied to a non-complex value, the former returns its operand and the\n///   later returns zero in the type of the operand.\n///\nclass UnaryOperator final\n    : public Expr,\n      private llvm::TrailingObjects<UnaryOperator, FPOptionsOverride> {\n  Stmt *Val;\n\n  size_t numTrailingObjects(OverloadToken<FPOptionsOverride>) const {\n    return UnaryOperatorBits.HasFPFeatures ? 1 : 0;\n  }\n\n  FPOptionsOverride &getTrailingFPFeatures() {\n    assert(UnaryOperatorBits.HasFPFeatures);\n    return *getTrailingObjects<FPOptionsOverride>();\n  }\n\n  const FPOptionsOverride &getTrailingFPFeatures() const {\n    assert(UnaryOperatorBits.HasFPFeatures);\n    return *getTrailingObjects<FPOptionsOverride>();\n  }\n\npublic:\n  typedef UnaryOperatorKind Opcode;\n\nprotected:\n  UnaryOperator(const ASTContext &Ctx, Expr *input, Opcode opc, QualType type,\n                ExprValueKind VK, ExprObjectKind OK, SourceLocation l,\n                bool CanOverflow, FPOptionsOverride FPFeatures);\n\n  /// Build an empty unary operator.\n  explicit UnaryOperator(bool HasFPFeatures, EmptyShell Empty)\n      : Expr(UnaryOperatorClass, Empty) {\n    UnaryOperatorBits.Opc = UO_AddrOf;\n    UnaryOperatorBits.HasFPFeatures = HasFPFeatures;\n  }\n\npublic:\n  static UnaryOperator *CreateEmpty(const ASTContext &C, bool hasFPFeatures);\n\n  static UnaryOperator *Create(const ASTContext &C, Expr *input, Opcode opc,\n                               QualType type, ExprValueKind VK,\n                               ExprObjectKind OK, SourceLocation l,\n                               bool CanOverflow, FPOptionsOverride FPFeatures);\n\n  Opcode getOpcode() const {\n    return static_cast<Opcode>(UnaryOperatorBits.Opc);\n  }\n  void setOpcode(Opcode Opc) { UnaryOperatorBits.Opc = Opc; }\n\n  Expr *getSubExpr() const { return cast<Expr>(Val); }\n  void setSubExpr(Expr *E) { Val = E; }\n\n  /// getOperatorLoc - Return the location of the operator.\n  SourceLocation getOperatorLoc() const { return UnaryOperatorBits.Loc; }\n  void setOperatorLoc(SourceLocation L) { UnaryOperatorBits.Loc = L; }\n\n  /// Returns true if the unary operator can cause an overflow. For instance,\n  ///   signed int i = INT_MAX; i++;\n  ///   signed char c = CHAR_MAX; c++;\n  /// Due to integer promotions, c++ is promoted to an int before the postfix\n  /// increment, and the result is an int that cannot overflow. However, i++\n  /// can overflow.\n  bool canOverflow() const { return UnaryOperatorBits.CanOverflow; }\n  void setCanOverflow(bool C) { UnaryOperatorBits.CanOverflow = C; }\n\n  // Get the FP contractability status of this operator. Only meaningful for\n  // operations on floating point types.\n  bool isFPContractableWithinStatement(const LangOptions &LO) const {\n    return getFPFeaturesInEffect(LO).allowFPContractWithinStatement();\n  }\n\n  // Get the FENV_ACCESS status of this operator. Only meaningful for\n  // operations on floating point types.\n  bool isFEnvAccessOn(const LangOptions &LO) const {\n    return getFPFeaturesInEffect(LO).getAllowFEnvAccess();\n  }\n\n  /// isPostfix - Return true if this is a postfix operation, like x++.\n  static bool isPostfix(Opcode Op) {\n    return Op == UO_PostInc || Op == UO_PostDec;\n  }\n\n  /// isPrefix - Return true if this is a prefix operation, like --x.\n  static bool isPrefix(Opcode Op) {\n    return Op == UO_PreInc || Op == UO_PreDec;\n  }\n\n  bool isPrefix() const { return isPrefix(getOpcode()); }\n  bool isPostfix() const { return isPostfix(getOpcode()); }\n\n  static bool isIncrementOp(Opcode Op) {\n    return Op == UO_PreInc || Op == UO_PostInc;\n  }\n  bool isIncrementOp() const {\n    return isIncrementOp(getOpcode());\n  }\n\n  static bool isDecrementOp(Opcode Op) {\n    return Op == UO_PreDec || Op == UO_PostDec;\n  }\n  bool isDecrementOp() const {\n    return isDecrementOp(getOpcode());\n  }\n\n  static bool isIncrementDecrementOp(Opcode Op) { return Op <= UO_PreDec; }\n  bool isIncrementDecrementOp() const {\n    return isIncrementDecrementOp(getOpcode());\n  }\n\n  static bool isArithmeticOp(Opcode Op) {\n    return Op >= UO_Plus && Op <= UO_LNot;\n  }\n  bool isArithmeticOp() const { return isArithmeticOp(getOpcode()); }\n\n  /// getOpcodeStr - Turn an Opcode enum value into the punctuation char it\n  /// corresponds to, e.g. \"sizeof\" or \"[pre]++\"\n  static StringRef getOpcodeStr(Opcode Op);\n\n  /// Retrieve the unary opcode that corresponds to the given\n  /// overloaded operator.\n  static Opcode getOverloadedOpcode(OverloadedOperatorKind OO, bool Postfix);\n\n  /// Retrieve the overloaded operator kind that corresponds to\n  /// the given unary opcode.\n  static OverloadedOperatorKind getOverloadedOperator(Opcode Opc);\n\n  SourceLocation getBeginLoc() const LLVM_READONLY {\n    return isPostfix() ? Val->getBeginLoc() : getOperatorLoc();\n  }\n  SourceLocation getEndLoc() const LLVM_READONLY {\n    return isPostfix() ? getOperatorLoc() : Val->getEndLoc();\n  }\n  SourceLocation getExprLoc() const { return getOperatorLoc(); }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == UnaryOperatorClass;\n  }\n\n  // Iterators\n  child_range children() { return child_range(&Val, &Val+1); }\n  const_child_range children() const {\n    return const_child_range(&Val, &Val + 1);\n  }\n\n  /// Is FPFeatures in Trailing Storage?\n  bool hasStoredFPFeatures() const { return UnaryOperatorBits.HasFPFeatures; }\n\n  /// Get FPFeatures from trailing storage.\n  FPOptionsOverride getStoredFPFeatures() const {\n    return getTrailingFPFeatures();\n  }\n\nprotected:\n  /// Set FPFeatures in trailing storage, used only by Serialization\n  void setStoredFPFeatures(FPOptionsOverride F) { getTrailingFPFeatures() = F; }\n\npublic:\n  // Get the FP features status of this operator. Only meaningful for\n  // operations on floating point types.\n  FPOptions getFPFeaturesInEffect(const LangOptions &LO) const {\n    if (UnaryOperatorBits.HasFPFeatures)\n      return getStoredFPFeatures().applyOverrides(LO);\n    return FPOptions::defaultWithoutTrailingStorage(LO);\n  }\n  FPOptionsOverride getFPOptionsOverride() const {\n    if (UnaryOperatorBits.HasFPFeatures)\n      return getStoredFPFeatures();\n    return FPOptionsOverride();\n  }\n\n  friend TrailingObjects;\n  friend class ASTReader;\n  friend class ASTStmtReader;\n  friend class ASTStmtWriter;\n};\n\n/// Helper class for OffsetOfExpr.\n\n// __builtin_offsetof(type, identifier(.identifier|[expr])*)\nclass OffsetOfNode {\npublic:\n  /// The kind of offsetof node we have.\n  enum Kind {\n    /// An index into an array.\n    Array = 0x00,\n    /// A field.\n    Field = 0x01,\n    /// A field in a dependent type, known only by its name.\n    Identifier = 0x02,\n    /// An implicit indirection through a C++ base class, when the\n    /// field found is in a base class.\n    Base = 0x03\n  };\n\nprivate:\n  enum { MaskBits = 2, Mask = 0x03 };\n\n  /// The source range that covers this part of the designator.\n  SourceRange Range;\n\n  /// The data describing the designator, which comes in three\n  /// different forms, depending on the lower two bits.\n  ///   - An unsigned index into the array of Expr*'s stored after this node\n  ///     in memory, for [constant-expression] designators.\n  ///   - A FieldDecl*, for references to a known field.\n  ///   - An IdentifierInfo*, for references to a field with a given name\n  ///     when the class type is dependent.\n  ///   - A CXXBaseSpecifier*, for references that look at a field in a\n  ///     base class.\n  uintptr_t Data;\n\npublic:\n  /// Create an offsetof node that refers to an array element.\n  OffsetOfNode(SourceLocation LBracketLoc, unsigned Index,\n               SourceLocation RBracketLoc)\n      : Range(LBracketLoc, RBracketLoc), Data((Index << 2) | Array) {}\n\n  /// Create an offsetof node that refers to a field.\n  OffsetOfNode(SourceLocation DotLoc, FieldDecl *Field, SourceLocation NameLoc)\n      : Range(DotLoc.isValid() ? DotLoc : NameLoc, NameLoc),\n        Data(reinterpret_cast<uintptr_t>(Field) | OffsetOfNode::Field) {}\n\n  /// Create an offsetof node that refers to an identifier.\n  OffsetOfNode(SourceLocation DotLoc, IdentifierInfo *Name,\n               SourceLocation NameLoc)\n      : Range(DotLoc.isValid() ? DotLoc : NameLoc, NameLoc),\n        Data(reinterpret_cast<uintptr_t>(Name) | Identifier) {}\n\n  /// Create an offsetof node that refers into a C++ base class.\n  explicit OffsetOfNode(const CXXBaseSpecifier *Base)\n      : Range(), Data(reinterpret_cast<uintptr_t>(Base) | OffsetOfNode::Base) {}\n\n  /// Determine what kind of offsetof node this is.\n  Kind getKind() const { return static_cast<Kind>(Data & Mask); }\n\n  /// For an array element node, returns the index into the array\n  /// of expressions.\n  unsigned getArrayExprIndex() const {\n    assert(getKind() == Array);\n    return Data >> 2;\n  }\n\n  /// For a field offsetof node, returns the field.\n  FieldDecl *getField() const {\n    assert(getKind() == Field);\n    return reinterpret_cast<FieldDecl *>(Data & ~(uintptr_t)Mask);\n  }\n\n  /// For a field or identifier offsetof node, returns the name of\n  /// the field.\n  IdentifierInfo *getFieldName() const;\n\n  /// For a base class node, returns the base specifier.\n  CXXBaseSpecifier *getBase() const {\n    assert(getKind() == Base);\n    return reinterpret_cast<CXXBaseSpecifier *>(Data & ~(uintptr_t)Mask);\n  }\n\n  /// Retrieve the source range that covers this offsetof node.\n  ///\n  /// For an array element node, the source range contains the locations of\n  /// the square brackets. For a field or identifier node, the source range\n  /// contains the location of the period (if there is one) and the\n  /// identifier.\n  SourceRange getSourceRange() const LLVM_READONLY { return Range; }\n  SourceLocation getBeginLoc() const LLVM_READONLY { return Range.getBegin(); }\n  SourceLocation getEndLoc() const LLVM_READONLY { return Range.getEnd(); }\n};\n\n/// OffsetOfExpr - [C99 7.17] - This represents an expression of the form\n/// offsetof(record-type, member-designator). For example, given:\n/// @code\n/// struct S {\n///   float f;\n///   double d;\n/// };\n/// struct T {\n///   int i;\n///   struct S s[10];\n/// };\n/// @endcode\n/// we can represent and evaluate the expression @c offsetof(struct T, s[2].d).\n\nclass OffsetOfExpr final\n    : public Expr,\n      private llvm::TrailingObjects<OffsetOfExpr, OffsetOfNode, Expr *> {\n  SourceLocation OperatorLoc, RParenLoc;\n  // Base type;\n  TypeSourceInfo *TSInfo;\n  // Number of sub-components (i.e. instances of OffsetOfNode).\n  unsigned NumComps;\n  // Number of sub-expressions (i.e. array subscript expressions).\n  unsigned NumExprs;\n\n  size_t numTrailingObjects(OverloadToken<OffsetOfNode>) const {\n    return NumComps;\n  }\n\n  OffsetOfExpr(const ASTContext &C, QualType type,\n               SourceLocation OperatorLoc, TypeSourceInfo *tsi,\n               ArrayRef<OffsetOfNode> comps, ArrayRef<Expr*> exprs,\n               SourceLocation RParenLoc);\n\n  explicit OffsetOfExpr(unsigned numComps, unsigned numExprs)\n    : Expr(OffsetOfExprClass, EmptyShell()),\n      TSInfo(nullptr), NumComps(numComps), NumExprs(numExprs) {}\n\npublic:\n\n  static OffsetOfExpr *Create(const ASTContext &C, QualType type,\n                              SourceLocation OperatorLoc, TypeSourceInfo *tsi,\n                              ArrayRef<OffsetOfNode> comps,\n                              ArrayRef<Expr*> exprs, SourceLocation RParenLoc);\n\n  static OffsetOfExpr *CreateEmpty(const ASTContext &C,\n                                   unsigned NumComps, unsigned NumExprs);\n\n  /// getOperatorLoc - Return the location of the operator.\n  SourceLocation getOperatorLoc() const { return OperatorLoc; }\n  void setOperatorLoc(SourceLocation L) { OperatorLoc = L; }\n\n  /// Return the location of the right parentheses.\n  SourceLocation getRParenLoc() const { return RParenLoc; }\n  void setRParenLoc(SourceLocation R) { RParenLoc = R; }\n\n  TypeSourceInfo *getTypeSourceInfo() const {\n    return TSInfo;\n  }\n  void setTypeSourceInfo(TypeSourceInfo *tsi) {\n    TSInfo = tsi;\n  }\n\n  const OffsetOfNode &getComponent(unsigned Idx) const {\n    assert(Idx < NumComps && \"Subscript out of range\");\n    return getTrailingObjects<OffsetOfNode>()[Idx];\n  }\n\n  void setComponent(unsigned Idx, OffsetOfNode ON) {\n    assert(Idx < NumComps && \"Subscript out of range\");\n    getTrailingObjects<OffsetOfNode>()[Idx] = ON;\n  }\n\n  unsigned getNumComponents() const {\n    return NumComps;\n  }\n\n  Expr* getIndexExpr(unsigned Idx) {\n    assert(Idx < NumExprs && \"Subscript out of range\");\n    return getTrailingObjects<Expr *>()[Idx];\n  }\n\n  const Expr *getIndexExpr(unsigned Idx) const {\n    assert(Idx < NumExprs && \"Subscript out of range\");\n    return getTrailingObjects<Expr *>()[Idx];\n  }\n\n  void setIndexExpr(unsigned Idx, Expr* E) {\n    assert(Idx < NumComps && \"Subscript out of range\");\n    getTrailingObjects<Expr *>()[Idx] = E;\n  }\n\n  unsigned getNumExpressions() const {\n    return NumExprs;\n  }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY { return OperatorLoc; }\n  SourceLocation getEndLoc() const LLVM_READONLY { return RParenLoc; }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == OffsetOfExprClass;\n  }\n\n  // Iterators\n  child_range children() {\n    Stmt **begin = reinterpret_cast<Stmt **>(getTrailingObjects<Expr *>());\n    return child_range(begin, begin + NumExprs);\n  }\n  const_child_range children() const {\n    Stmt *const *begin =\n        reinterpret_cast<Stmt *const *>(getTrailingObjects<Expr *>());\n    return const_child_range(begin, begin + NumExprs);\n  }\n  friend TrailingObjects;\n};\n\n/// UnaryExprOrTypeTraitExpr - expression with either a type or (unevaluated)\n/// expression operand.  Used for sizeof/alignof (C99 6.5.3.4) and\n/// vec_step (OpenCL 1.1 6.11.12).\nclass UnaryExprOrTypeTraitExpr : public Expr {\n  union {\n    TypeSourceInfo *Ty;\n    Stmt *Ex;\n  } Argument;\n  SourceLocation OpLoc, RParenLoc;\n\npublic:\n  UnaryExprOrTypeTraitExpr(UnaryExprOrTypeTrait ExprKind, TypeSourceInfo *TInfo,\n                           QualType resultType, SourceLocation op,\n                           SourceLocation rp)\n      : Expr(UnaryExprOrTypeTraitExprClass, resultType, VK_RValue, OK_Ordinary),\n        OpLoc(op), RParenLoc(rp) {\n    assert(ExprKind <= UETT_Last && \"invalid enum value!\");\n    UnaryExprOrTypeTraitExprBits.Kind = ExprKind;\n    assert(static_cast<unsigned>(ExprKind) ==\n               UnaryExprOrTypeTraitExprBits.Kind &&\n           \"UnaryExprOrTypeTraitExprBits.Kind overflow!\");\n    UnaryExprOrTypeTraitExprBits.IsType = true;\n    Argument.Ty = TInfo;\n    setDependence(computeDependence(this));\n  }\n\n  UnaryExprOrTypeTraitExpr(UnaryExprOrTypeTrait ExprKind, Expr *E,\n                           QualType resultType, SourceLocation op,\n                           SourceLocation rp);\n\n  /// Construct an empty sizeof/alignof expression.\n  explicit UnaryExprOrTypeTraitExpr(EmptyShell Empty)\n    : Expr(UnaryExprOrTypeTraitExprClass, Empty) { }\n\n  UnaryExprOrTypeTrait getKind() const {\n    return static_cast<UnaryExprOrTypeTrait>(UnaryExprOrTypeTraitExprBits.Kind);\n  }\n  void setKind(UnaryExprOrTypeTrait K) {\n    assert(K <= UETT_Last && \"invalid enum value!\");\n    UnaryExprOrTypeTraitExprBits.Kind = K;\n    assert(static_cast<unsigned>(K) == UnaryExprOrTypeTraitExprBits.Kind &&\n           \"UnaryExprOrTypeTraitExprBits.Kind overflow!\");\n  }\n\n  bool isArgumentType() const { return UnaryExprOrTypeTraitExprBits.IsType; }\n  QualType getArgumentType() const {\n    return getArgumentTypeInfo()->getType();\n  }\n  TypeSourceInfo *getArgumentTypeInfo() const {\n    assert(isArgumentType() && \"calling getArgumentType() when arg is expr\");\n    return Argument.Ty;\n  }\n  Expr *getArgumentExpr() {\n    assert(!isArgumentType() && \"calling getArgumentExpr() when arg is type\");\n    return static_cast<Expr*>(Argument.Ex);\n  }\n  const Expr *getArgumentExpr() const {\n    return const_cast<UnaryExprOrTypeTraitExpr*>(this)->getArgumentExpr();\n  }\n\n  void setArgument(Expr *E) {\n    Argument.Ex = E;\n    UnaryExprOrTypeTraitExprBits.IsType = false;\n  }\n  void setArgument(TypeSourceInfo *TInfo) {\n    Argument.Ty = TInfo;\n    UnaryExprOrTypeTraitExprBits.IsType = true;\n  }\n\n  /// Gets the argument type, or the type of the argument expression, whichever\n  /// is appropriate.\n  QualType getTypeOfArgument() const {\n    return isArgumentType() ? getArgumentType() : getArgumentExpr()->getType();\n  }\n\n  SourceLocation getOperatorLoc() const { return OpLoc; }\n  void setOperatorLoc(SourceLocation L) { OpLoc = L; }\n\n  SourceLocation getRParenLoc() const { return RParenLoc; }\n  void setRParenLoc(SourceLocation L) { RParenLoc = L; }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY { return OpLoc; }\n  SourceLocation getEndLoc() const LLVM_READONLY { return RParenLoc; }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == UnaryExprOrTypeTraitExprClass;\n  }\n\n  // Iterators\n  child_range children();\n  const_child_range children() const;\n};\n\n//===----------------------------------------------------------------------===//\n// Postfix Operators.\n//===----------------------------------------------------------------------===//\n\n/// ArraySubscriptExpr - [C99 6.5.2.1] Array Subscripting.\nclass ArraySubscriptExpr : public Expr {\n  enum { LHS, RHS, END_EXPR };\n  Stmt *SubExprs[END_EXPR];\n\n  bool lhsIsBase() const { return getRHS()->getType()->isIntegerType(); }\n\npublic:\n  ArraySubscriptExpr(Expr *lhs, Expr *rhs, QualType t, ExprValueKind VK,\n                     ExprObjectKind OK, SourceLocation rbracketloc)\n      : Expr(ArraySubscriptExprClass, t, VK, OK) {\n    SubExprs[LHS] = lhs;\n    SubExprs[RHS] = rhs;\n    ArrayOrMatrixSubscriptExprBits.RBracketLoc = rbracketloc;\n    setDependence(computeDependence(this));\n  }\n\n  /// Create an empty array subscript expression.\n  explicit ArraySubscriptExpr(EmptyShell Shell)\n    : Expr(ArraySubscriptExprClass, Shell) { }\n\n  /// An array access can be written A[4] or 4[A] (both are equivalent).\n  /// - getBase() and getIdx() always present the normalized view: A[4].\n  ///    In this case getBase() returns \"A\" and getIdx() returns \"4\".\n  /// - getLHS() and getRHS() present the syntactic view. e.g. for\n  ///    4[A] getLHS() returns \"4\".\n  /// Note: Because vector element access is also written A[4] we must\n  /// predicate the format conversion in getBase and getIdx only on the\n  /// the type of the RHS, as it is possible for the LHS to be a vector of\n  /// integer type\n  Expr *getLHS() { return cast<Expr>(SubExprs[LHS]); }\n  const Expr *getLHS() const { return cast<Expr>(SubExprs[LHS]); }\n  void setLHS(Expr *E) { SubExprs[LHS] = E; }\n\n  Expr *getRHS() { return cast<Expr>(SubExprs[RHS]); }\n  const Expr *getRHS() const { return cast<Expr>(SubExprs[RHS]); }\n  void setRHS(Expr *E) { SubExprs[RHS] = E; }\n\n  Expr *getBase() { return lhsIsBase() ? getLHS() : getRHS(); }\n  const Expr *getBase() const { return lhsIsBase() ? getLHS() : getRHS(); }\n\n  Expr *getIdx() { return lhsIsBase() ? getRHS() : getLHS(); }\n  const Expr *getIdx() const { return lhsIsBase() ? getRHS() : getLHS(); }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY {\n    return getLHS()->getBeginLoc();\n  }\n  SourceLocation getEndLoc() const { return getRBracketLoc(); }\n\n  SourceLocation getRBracketLoc() const {\n    return ArrayOrMatrixSubscriptExprBits.RBracketLoc;\n  }\n  void setRBracketLoc(SourceLocation L) {\n    ArrayOrMatrixSubscriptExprBits.RBracketLoc = L;\n  }\n\n  SourceLocation getExprLoc() const LLVM_READONLY {\n    return getBase()->getExprLoc();\n  }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == ArraySubscriptExprClass;\n  }\n\n  // Iterators\n  child_range children() {\n    return child_range(&SubExprs[0], &SubExprs[0]+END_EXPR);\n  }\n  const_child_range children() const {\n    return const_child_range(&SubExprs[0], &SubExprs[0] + END_EXPR);\n  }\n};\n\n/// MatrixSubscriptExpr - Matrix subscript expression for the MatrixType\n/// extension.\n/// MatrixSubscriptExpr can be either incomplete (only Base and RowIdx are set\n/// so far, the type is IncompleteMatrixIdx) or complete (Base, RowIdx and\n/// ColumnIdx refer to valid expressions). Incomplete matrix expressions only\n/// exist during the initial construction of the AST.\nclass MatrixSubscriptExpr : public Expr {\n  enum { BASE, ROW_IDX, COLUMN_IDX, END_EXPR };\n  Stmt *SubExprs[END_EXPR];\n\npublic:\n  MatrixSubscriptExpr(Expr *Base, Expr *RowIdx, Expr *ColumnIdx, QualType T,\n                      SourceLocation RBracketLoc)\n      : Expr(MatrixSubscriptExprClass, T, Base->getValueKind(),\n             OK_MatrixComponent) {\n    SubExprs[BASE] = Base;\n    SubExprs[ROW_IDX] = RowIdx;\n    SubExprs[COLUMN_IDX] = ColumnIdx;\n    ArrayOrMatrixSubscriptExprBits.RBracketLoc = RBracketLoc;\n    setDependence(computeDependence(this));\n  }\n\n  /// Create an empty matrix subscript expression.\n  explicit MatrixSubscriptExpr(EmptyShell Shell)\n      : Expr(MatrixSubscriptExprClass, Shell) {}\n\n  bool isIncomplete() const {\n    bool IsIncomplete = hasPlaceholderType(BuiltinType::IncompleteMatrixIdx);\n    assert((SubExprs[COLUMN_IDX] || IsIncomplete) &&\n           \"expressions without column index must be marked as incomplete\");\n    return IsIncomplete;\n  }\n  Expr *getBase() { return cast<Expr>(SubExprs[BASE]); }\n  const Expr *getBase() const { return cast<Expr>(SubExprs[BASE]); }\n  void setBase(Expr *E) { SubExprs[BASE] = E; }\n\n  Expr *getRowIdx() { return cast<Expr>(SubExprs[ROW_IDX]); }\n  const Expr *getRowIdx() const { return cast<Expr>(SubExprs[ROW_IDX]); }\n  void setRowIdx(Expr *E) { SubExprs[ROW_IDX] = E; }\n\n  Expr *getColumnIdx() { return cast_or_null<Expr>(SubExprs[COLUMN_IDX]); }\n  const Expr *getColumnIdx() const {\n    assert(!isIncomplete() &&\n           \"cannot get the column index of an incomplete expression\");\n    return cast<Expr>(SubExprs[COLUMN_IDX]);\n  }\n  void setColumnIdx(Expr *E) { SubExprs[COLUMN_IDX] = E; }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY {\n    return getBase()->getBeginLoc();\n  }\n\n  SourceLocation getEndLoc() const { return getRBracketLoc(); }\n\n  SourceLocation getExprLoc() const LLVM_READONLY {\n    return getBase()->getExprLoc();\n  }\n\n  SourceLocation getRBracketLoc() const {\n    return ArrayOrMatrixSubscriptExprBits.RBracketLoc;\n  }\n  void setRBracketLoc(SourceLocation L) {\n    ArrayOrMatrixSubscriptExprBits.RBracketLoc = L;\n  }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == MatrixSubscriptExprClass;\n  }\n\n  // Iterators\n  child_range children() {\n    return child_range(&SubExprs[0], &SubExprs[0] + END_EXPR);\n  }\n  const_child_range children() const {\n    return const_child_range(&SubExprs[0], &SubExprs[0] + END_EXPR);\n  }\n};\n\n/// CallExpr - Represents a function call (C99 6.5.2.2, C++ [expr.call]).\n/// CallExpr itself represents a normal function call, e.g., \"f(x, 2)\",\n/// while its subclasses may represent alternative syntax that (semantically)\n/// results in a function call. For example, CXXOperatorCallExpr is\n/// a subclass for overloaded operator calls that use operator syntax, e.g.,\n/// \"str1 + str2\" to resolve to a function call.\nclass CallExpr : public Expr {\n  enum { FN = 0, PREARGS_START = 1 };\n\n  /// The number of arguments in the call expression.\n  unsigned NumArgs;\n\n  /// The location of the right parenthese. This has a different meaning for\n  /// the derived classes of CallExpr.\n  SourceLocation RParenLoc;\n\n  // CallExpr store some data in trailing objects. However since CallExpr\n  // is used a base of other expression classes we cannot use\n  // llvm::TrailingObjects. Instead we manually perform the pointer arithmetic\n  // and casts.\n  //\n  // The trailing objects are in order:\n  //\n  // * A single \"Stmt *\" for the callee expression.\n  //\n  // * An array of getNumPreArgs() \"Stmt *\" for the pre-argument expressions.\n  //\n  // * An array of getNumArgs() \"Stmt *\" for the argument expressions.\n  //\n  // * An optional of type FPOptionsOverride.\n  //\n  // Note that we store the offset in bytes from the this pointer to the start\n  // of the trailing objects. It would be perfectly possible to compute it\n  // based on the dynamic kind of the CallExpr. However 1.) we have plenty of\n  // space in the bit-fields of Stmt. 2.) It was benchmarked to be faster to\n  // compute this once and then load the offset from the bit-fields of Stmt,\n  // instead of re-computing the offset each time the trailing objects are\n  // accessed.\n\n  /// Return a pointer to the start of the trailing array of \"Stmt *\".\n  Stmt **getTrailingStmts() {\n    return reinterpret_cast<Stmt **>(reinterpret_cast<char *>(this) +\n                                     CallExprBits.OffsetToTrailingObjects);\n  }\n  Stmt *const *getTrailingStmts() const {\n    return const_cast<CallExpr *>(this)->getTrailingStmts();\n  }\n\n  /// Map a statement class to the appropriate offset in bytes from the\n  /// this pointer to the trailing objects.\n  static unsigned offsetToTrailingObjects(StmtClass SC);\n\n  unsigned getSizeOfTrailingStmts() const {\n    return (1 + getNumPreArgs() + getNumArgs()) * sizeof(Stmt *);\n  }\n\n  size_t getOffsetOfTrailingFPFeatures() const {\n    assert(hasStoredFPFeatures());\n    return CallExprBits.OffsetToTrailingObjects + getSizeOfTrailingStmts();\n  }\n\npublic:\n  enum class ADLCallKind : bool { NotADL, UsesADL };\n  static constexpr ADLCallKind NotADL = ADLCallKind::NotADL;\n  static constexpr ADLCallKind UsesADL = ADLCallKind::UsesADL;\n\nprotected:\n  /// Build a call expression, assuming that appropriate storage has been\n  /// allocated for the trailing objects.\n  CallExpr(StmtClass SC, Expr *Fn, ArrayRef<Expr *> PreArgs,\n           ArrayRef<Expr *> Args, QualType Ty, ExprValueKind VK,\n           SourceLocation RParenLoc, FPOptionsOverride FPFeatures,\n           unsigned MinNumArgs, ADLCallKind UsesADL);\n\n  /// Build an empty call expression, for deserialization.\n  CallExpr(StmtClass SC, unsigned NumPreArgs, unsigned NumArgs,\n           bool hasFPFeatures, EmptyShell Empty);\n\n  /// Return the size in bytes needed for the trailing objects.\n  /// Used by the derived classes to allocate the right amount of storage.\n  static unsigned sizeOfTrailingObjects(unsigned NumPreArgs, unsigned NumArgs,\n                                        bool HasFPFeatures) {\n    return (1 + NumPreArgs + NumArgs) * sizeof(Stmt *) +\n           HasFPFeatures * sizeof(FPOptionsOverride);\n  }\n\n  Stmt *getPreArg(unsigned I) {\n    assert(I < getNumPreArgs() && \"Prearg access out of range!\");\n    return getTrailingStmts()[PREARGS_START + I];\n  }\n  const Stmt *getPreArg(unsigned I) const {\n    assert(I < getNumPreArgs() && \"Prearg access out of range!\");\n    return getTrailingStmts()[PREARGS_START + I];\n  }\n  void setPreArg(unsigned I, Stmt *PreArg) {\n    assert(I < getNumPreArgs() && \"Prearg access out of range!\");\n    getTrailingStmts()[PREARGS_START + I] = PreArg;\n  }\n\n  unsigned getNumPreArgs() const { return CallExprBits.NumPreArgs; }\n\n  /// Return a pointer to the trailing FPOptions\n  FPOptionsOverride *getTrailingFPFeatures() {\n    assert(hasStoredFPFeatures());\n    return reinterpret_cast<FPOptionsOverride *>(\n        reinterpret_cast<char *>(this) + CallExprBits.OffsetToTrailingObjects +\n        getSizeOfTrailingStmts());\n  }\n  const FPOptionsOverride *getTrailingFPFeatures() const {\n    assert(hasStoredFPFeatures());\n    return reinterpret_cast<const FPOptionsOverride *>(\n        reinterpret_cast<const char *>(this) +\n        CallExprBits.OffsetToTrailingObjects + getSizeOfTrailingStmts());\n  }\n\npublic:\n  /// Create a call expression.\n  /// \\param Fn     The callee expression,\n  /// \\param Args   The argument array,\n  /// \\param Ty     The type of the call expression (which is *not* the return\n  ///               type in general),\n  /// \\param VK     The value kind of the call expression (lvalue, rvalue, ...),\n  /// \\param RParenLoc  The location of the right parenthesis in the call\n  ///                   expression.\n  /// \\param FPFeatures Floating-point features associated with the call,\n  /// \\param MinNumArgs Specifies the minimum number of arguments. The actual\n  ///                   number of arguments will be the greater of Args.size()\n  ///                   and MinNumArgs. This is used in a few places to allocate\n  ///                   enough storage for the default arguments.\n  /// \\param UsesADL    Specifies whether the callee was found through\n  ///                   argument-dependent lookup.\n  ///\n  /// Note that you can use CreateTemporary if you need a temporary call\n  /// expression on the stack.\n  static CallExpr *Create(const ASTContext &Ctx, Expr *Fn,\n                          ArrayRef<Expr *> Args, QualType Ty, ExprValueKind VK,\n                          SourceLocation RParenLoc,\n                          FPOptionsOverride FPFeatures, unsigned MinNumArgs = 0,\n                          ADLCallKind UsesADL = NotADL);\n\n  /// Create a temporary call expression with no arguments in the memory\n  /// pointed to by Mem. Mem must points to at least sizeof(CallExpr)\n  /// + sizeof(Stmt *) bytes of storage, aligned to alignof(CallExpr):\n  ///\n  /// \\code{.cpp}\n  ///   alignas(CallExpr) char Buffer[sizeof(CallExpr) + sizeof(Stmt *)];\n  ///   CallExpr *TheCall = CallExpr::CreateTemporary(Buffer, etc);\n  /// \\endcode\n  static CallExpr *CreateTemporary(void *Mem, Expr *Fn, QualType Ty,\n                                   ExprValueKind VK, SourceLocation RParenLoc,\n                                   ADLCallKind UsesADL = NotADL);\n\n  /// Create an empty call expression, for deserialization.\n  static CallExpr *CreateEmpty(const ASTContext &Ctx, unsigned NumArgs,\n                               bool HasFPFeatures, EmptyShell Empty);\n\n  Expr *getCallee() { return cast<Expr>(getTrailingStmts()[FN]); }\n  const Expr *getCallee() const { return cast<Expr>(getTrailingStmts()[FN]); }\n  void setCallee(Expr *F) { getTrailingStmts()[FN] = F; }\n\n  ADLCallKind getADLCallKind() const {\n    return static_cast<ADLCallKind>(CallExprBits.UsesADL);\n  }\n  void setADLCallKind(ADLCallKind V = UsesADL) {\n    CallExprBits.UsesADL = static_cast<bool>(V);\n  }\n  bool usesADL() const { return getADLCallKind() == UsesADL; }\n\n  bool hasStoredFPFeatures() const { return CallExprBits.HasFPFeatures; }\n\n  Decl *getCalleeDecl() { return getCallee()->getReferencedDeclOfCallee(); }\n  const Decl *getCalleeDecl() const {\n    return getCallee()->getReferencedDeclOfCallee();\n  }\n\n  /// If the callee is a FunctionDecl, return it. Otherwise return null.\n  FunctionDecl *getDirectCallee() {\n    return dyn_cast_or_null<FunctionDecl>(getCalleeDecl());\n  }\n  const FunctionDecl *getDirectCallee() const {\n    return dyn_cast_or_null<FunctionDecl>(getCalleeDecl());\n  }\n\n  /// getNumArgs - Return the number of actual arguments to this call.\n  unsigned getNumArgs() const { return NumArgs; }\n\n  /// Retrieve the call arguments.\n  Expr **getArgs() {\n    return reinterpret_cast<Expr **>(getTrailingStmts() + PREARGS_START +\n                                     getNumPreArgs());\n  }\n  const Expr *const *getArgs() const {\n    return reinterpret_cast<const Expr *const *>(\n        getTrailingStmts() + PREARGS_START + getNumPreArgs());\n  }\n\n  /// getArg - Return the specified argument.\n  Expr *getArg(unsigned Arg) {\n    assert(Arg < getNumArgs() && \"Arg access out of range!\");\n    return getArgs()[Arg];\n  }\n  const Expr *getArg(unsigned Arg) const {\n    assert(Arg < getNumArgs() && \"Arg access out of range!\");\n    return getArgs()[Arg];\n  }\n\n  /// setArg - Set the specified argument.\n  void setArg(unsigned Arg, Expr *ArgExpr) {\n    assert(Arg < getNumArgs() && \"Arg access out of range!\");\n    getArgs()[Arg] = ArgExpr;\n  }\n\n  /// Reduce the number of arguments in this call expression. This is used for\n  /// example during error recovery to drop extra arguments. There is no way\n  /// to perform the opposite because: 1.) We don't track how much storage\n  /// we have for the argument array 2.) This would potentially require growing\n  /// the argument array, something we cannot support since the arguments are\n  /// stored in a trailing array.\n  void shrinkNumArgs(unsigned NewNumArgs) {\n    assert((NewNumArgs <= getNumArgs()) &&\n           \"shrinkNumArgs cannot increase the number of arguments!\");\n    NumArgs = NewNumArgs;\n  }\n\n  /// Bluntly set a new number of arguments without doing any checks whatsoever.\n  /// Only used during construction of a CallExpr in a few places in Sema.\n  /// FIXME: Find a way to remove it.\n  void setNumArgsUnsafe(unsigned NewNumArgs) { NumArgs = NewNumArgs; }\n\n  typedef ExprIterator arg_iterator;\n  typedef ConstExprIterator const_arg_iterator;\n  typedef llvm::iterator_range<arg_iterator> arg_range;\n  typedef llvm::iterator_range<const_arg_iterator> const_arg_range;\n\n  arg_range arguments() { return arg_range(arg_begin(), arg_end()); }\n  const_arg_range arguments() const {\n    return const_arg_range(arg_begin(), arg_end());\n  }\n\n  arg_iterator arg_begin() {\n    return getTrailingStmts() + PREARGS_START + getNumPreArgs();\n  }\n  arg_iterator arg_end() { return arg_begin() + getNumArgs(); }\n\n  const_arg_iterator arg_begin() const {\n    return getTrailingStmts() + PREARGS_START + getNumPreArgs();\n  }\n  const_arg_iterator arg_end() const { return arg_begin() + getNumArgs(); }\n\n  /// This method provides fast access to all the subexpressions of\n  /// a CallExpr without going through the slower virtual child_iterator\n  /// interface.  This provides efficient reverse iteration of the\n  /// subexpressions.  This is currently used for CFG construction.\n  ArrayRef<Stmt *> getRawSubExprs() {\n    return llvm::makeArrayRef(getTrailingStmts(),\n                              PREARGS_START + getNumPreArgs() + getNumArgs());\n  }\n\n  /// getNumCommas - Return the number of commas that must have been present in\n  /// this function call.\n  unsigned getNumCommas() const { return getNumArgs() ? getNumArgs() - 1 : 0; }\n\n  /// Get FPOptionsOverride from trailing storage.\n  FPOptionsOverride getStoredFPFeatures() const {\n    assert(hasStoredFPFeatures());\n    return *getTrailingFPFeatures();\n  }\n  /// Set FPOptionsOverride in trailing storage. Used only by Serialization.\n  void setStoredFPFeatures(FPOptionsOverride F) {\n    assert(hasStoredFPFeatures());\n    *getTrailingFPFeatures() = F;\n  }\n\n  // Get the FP features status of this operator. Only meaningful for\n  // operations on floating point types.\n  FPOptions getFPFeaturesInEffect(const LangOptions &LO) const {\n    if (hasStoredFPFeatures())\n      return getStoredFPFeatures().applyOverrides(LO);\n    return FPOptions::defaultWithoutTrailingStorage(LO);\n  }\n\n  FPOptionsOverride getFPFeatures() const {\n    if (hasStoredFPFeatures())\n      return getStoredFPFeatures();\n    return FPOptionsOverride();\n  }\n\n  /// getBuiltinCallee - If this is a call to a builtin, return the builtin ID\n  /// of the callee. If not, return 0.\n  unsigned getBuiltinCallee() const;\n\n  /// Returns \\c true if this is a call to a builtin which does not\n  /// evaluate side-effects within its arguments.\n  bool isUnevaluatedBuiltinCall(const ASTContext &Ctx) const;\n\n  /// getCallReturnType - Get the return type of the call expr. This is not\n  /// always the type of the expr itself, if the return type is a reference\n  /// type.\n  QualType getCallReturnType(const ASTContext &Ctx) const;\n\n  /// Returns the WarnUnusedResultAttr that is either declared on the called\n  /// function, or its return type declaration.\n  const Attr *getUnusedResultAttr(const ASTContext &Ctx) const;\n\n  /// Returns true if this call expression should warn on unused results.\n  bool hasUnusedResultAttr(const ASTContext &Ctx) const {\n    return getUnusedResultAttr(Ctx) != nullptr;\n  }\n\n  SourceLocation getRParenLoc() const { return RParenLoc; }\n  void setRParenLoc(SourceLocation L) { RParenLoc = L; }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY;\n  SourceLocation getEndLoc() const LLVM_READONLY;\n\n  /// Return true if this is a call to __assume() or __builtin_assume() with\n  /// a non-value-dependent constant parameter evaluating as false.\n  bool isBuiltinAssumeFalse(const ASTContext &Ctx) const;\n\n  /// Used by Sema to implement MSVC-compatible delayed name lookup.\n  /// (Usually Exprs themselves should set dependence).\n  void markDependentForPostponedNameLookup() {\n    setDependence(getDependence() | ExprDependence::TypeValueInstantiation);\n  }\n\n  bool isCallToStdMove() const {\n    const FunctionDecl *FD = getDirectCallee();\n    return getNumArgs() == 1 && FD && FD->isInStdNamespace() &&\n           FD->getIdentifier() && FD->getIdentifier()->isStr(\"move\");\n  }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() >= firstCallExprConstant &&\n           T->getStmtClass() <= lastCallExprConstant;\n  }\n\n  // Iterators\n  child_range children() {\n    return child_range(getTrailingStmts(), getTrailingStmts() + PREARGS_START +\n                                               getNumPreArgs() + getNumArgs());\n  }\n\n  const_child_range children() const {\n    return const_child_range(getTrailingStmts(),\n                             getTrailingStmts() + PREARGS_START +\n                                 getNumPreArgs() + getNumArgs());\n  }\n};\n\n/// Extra data stored in some MemberExpr objects.\nstruct MemberExprNameQualifier {\n  /// The nested-name-specifier that qualifies the name, including\n  /// source-location information.\n  NestedNameSpecifierLoc QualifierLoc;\n\n  /// The DeclAccessPair through which the MemberDecl was found due to\n  /// name qualifiers.\n  DeclAccessPair FoundDecl;\n};\n\n/// MemberExpr - [C99 6.5.2.3] Structure and Union Members.  X->F and X.F.\n///\nclass MemberExpr final\n    : public Expr,\n      private llvm::TrailingObjects<MemberExpr, MemberExprNameQualifier,\n                                    ASTTemplateKWAndArgsInfo,\n                                    TemplateArgumentLoc> {\n  friend class ASTReader;\n  friend class ASTStmtReader;\n  friend class ASTStmtWriter;\n  friend TrailingObjects;\n\n  /// Base - the expression for the base pointer or structure references.  In\n  /// X.F, this is \"X\".\n  Stmt *Base;\n\n  /// MemberDecl - This is the decl being referenced by the field/member name.\n  /// In X.F, this is the decl referenced by F.\n  ValueDecl *MemberDecl;\n\n  /// MemberDNLoc - Provides source/type location info for the\n  /// declaration name embedded in MemberDecl.\n  DeclarationNameLoc MemberDNLoc;\n\n  /// MemberLoc - This is the location of the member name.\n  SourceLocation MemberLoc;\n\n  size_t numTrailingObjects(OverloadToken<MemberExprNameQualifier>) const {\n    return hasQualifierOrFoundDecl();\n  }\n\n  size_t numTrailingObjects(OverloadToken<ASTTemplateKWAndArgsInfo>) const {\n    return hasTemplateKWAndArgsInfo();\n  }\n\n  bool hasQualifierOrFoundDecl() const {\n    return MemberExprBits.HasQualifierOrFoundDecl;\n  }\n\n  bool hasTemplateKWAndArgsInfo() const {\n    return MemberExprBits.HasTemplateKWAndArgsInfo;\n  }\n\n  MemberExpr(Expr *Base, bool IsArrow, SourceLocation OperatorLoc,\n             ValueDecl *MemberDecl, const DeclarationNameInfo &NameInfo,\n             QualType T, ExprValueKind VK, ExprObjectKind OK,\n             NonOdrUseReason NOUR);\n  MemberExpr(EmptyShell Empty)\n      : Expr(MemberExprClass, Empty), Base(), MemberDecl() {}\n\npublic:\n  static MemberExpr *Create(const ASTContext &C, Expr *Base, bool IsArrow,\n                            SourceLocation OperatorLoc,\n                            NestedNameSpecifierLoc QualifierLoc,\n                            SourceLocation TemplateKWLoc, ValueDecl *MemberDecl,\n                            DeclAccessPair FoundDecl,\n                            DeclarationNameInfo MemberNameInfo,\n                            const TemplateArgumentListInfo *TemplateArgs,\n                            QualType T, ExprValueKind VK, ExprObjectKind OK,\n                            NonOdrUseReason NOUR);\n\n  /// Create an implicit MemberExpr, with no location, qualifier, template\n  /// arguments, and so on. Suitable only for non-static member access.\n  static MemberExpr *CreateImplicit(const ASTContext &C, Expr *Base,\n                                    bool IsArrow, ValueDecl *MemberDecl,\n                                    QualType T, ExprValueKind VK,\n                                    ExprObjectKind OK) {\n    return Create(C, Base, IsArrow, SourceLocation(), NestedNameSpecifierLoc(),\n                  SourceLocation(), MemberDecl,\n                  DeclAccessPair::make(MemberDecl, MemberDecl->getAccess()),\n                  DeclarationNameInfo(), nullptr, T, VK, OK, NOUR_None);\n  }\n\n  static MemberExpr *CreateEmpty(const ASTContext &Context, bool HasQualifier,\n                                 bool HasFoundDecl,\n                                 bool HasTemplateKWAndArgsInfo,\n                                 unsigned NumTemplateArgs);\n\n  void setBase(Expr *E) { Base = E; }\n  Expr *getBase() const { return cast<Expr>(Base); }\n\n  /// Retrieve the member declaration to which this expression refers.\n  ///\n  /// The returned declaration will be a FieldDecl or (in C++) a VarDecl (for\n  /// static data members), a CXXMethodDecl, or an EnumConstantDecl.\n  ValueDecl *getMemberDecl() const { return MemberDecl; }\n  void setMemberDecl(ValueDecl *D);\n\n  /// Retrieves the declaration found by lookup.\n  DeclAccessPair getFoundDecl() const {\n    if (!hasQualifierOrFoundDecl())\n      return DeclAccessPair::make(getMemberDecl(),\n                                  getMemberDecl()->getAccess());\n    return getTrailingObjects<MemberExprNameQualifier>()->FoundDecl;\n  }\n\n  /// Determines whether this member expression actually had\n  /// a C++ nested-name-specifier prior to the name of the member, e.g.,\n  /// x->Base::foo.\n  bool hasQualifier() const { return getQualifier() != nullptr; }\n\n  /// If the member name was qualified, retrieves the\n  /// nested-name-specifier that precedes the member name, with source-location\n  /// information.\n  NestedNameSpecifierLoc getQualifierLoc() const {\n    if (!hasQualifierOrFoundDecl())\n      return NestedNameSpecifierLoc();\n    return getTrailingObjects<MemberExprNameQualifier>()->QualifierLoc;\n  }\n\n  /// If the member name was qualified, retrieves the\n  /// nested-name-specifier that precedes the member name. Otherwise, returns\n  /// NULL.\n  NestedNameSpecifier *getQualifier() const {\n    return getQualifierLoc().getNestedNameSpecifier();\n  }\n\n  /// Retrieve the location of the template keyword preceding\n  /// the member name, if any.\n  SourceLocation getTemplateKeywordLoc() const {\n    if (!hasTemplateKWAndArgsInfo())\n      return SourceLocation();\n    return getTrailingObjects<ASTTemplateKWAndArgsInfo>()->TemplateKWLoc;\n  }\n\n  /// Retrieve the location of the left angle bracket starting the\n  /// explicit template argument list following the member name, if any.\n  SourceLocation getLAngleLoc() const {\n    if (!hasTemplateKWAndArgsInfo())\n      return SourceLocation();\n    return getTrailingObjects<ASTTemplateKWAndArgsInfo>()->LAngleLoc;\n  }\n\n  /// Retrieve the location of the right angle bracket ending the\n  /// explicit template argument list following the member name, if any.\n  SourceLocation getRAngleLoc() const {\n    if (!hasTemplateKWAndArgsInfo())\n      return SourceLocation();\n    return getTrailingObjects<ASTTemplateKWAndArgsInfo>()->RAngleLoc;\n  }\n\n  /// Determines whether the member name was preceded by the template keyword.\n  bool hasTemplateKeyword() const { return getTemplateKeywordLoc().isValid(); }\n\n  /// Determines whether the member name was followed by an\n  /// explicit template argument list.\n  bool hasExplicitTemplateArgs() const { return getLAngleLoc().isValid(); }\n\n  /// Copies the template arguments (if present) into the given\n  /// structure.\n  void copyTemplateArgumentsInto(TemplateArgumentListInfo &List) const {\n    if (hasExplicitTemplateArgs())\n      getTrailingObjects<ASTTemplateKWAndArgsInfo>()->copyInto(\n          getTrailingObjects<TemplateArgumentLoc>(), List);\n  }\n\n  /// Retrieve the template arguments provided as part of this\n  /// template-id.\n  const TemplateArgumentLoc *getTemplateArgs() const {\n    if (!hasExplicitTemplateArgs())\n      return nullptr;\n\n    return getTrailingObjects<TemplateArgumentLoc>();\n  }\n\n  /// Retrieve the number of template arguments provided as part of this\n  /// template-id.\n  unsigned getNumTemplateArgs() const {\n    if (!hasExplicitTemplateArgs())\n      return 0;\n\n    return getTrailingObjects<ASTTemplateKWAndArgsInfo>()->NumTemplateArgs;\n  }\n\n  ArrayRef<TemplateArgumentLoc> template_arguments() const {\n    return {getTemplateArgs(), getNumTemplateArgs()};\n  }\n\n  /// Retrieve the member declaration name info.\n  DeclarationNameInfo getMemberNameInfo() const {\n    return DeclarationNameInfo(MemberDecl->getDeclName(),\n                               MemberLoc, MemberDNLoc);\n  }\n\n  SourceLocation getOperatorLoc() const { return MemberExprBits.OperatorLoc; }\n\n  bool isArrow() const { return MemberExprBits.IsArrow; }\n  void setArrow(bool A) { MemberExprBits.IsArrow = A; }\n\n  /// getMemberLoc - Return the location of the \"member\", in X->F, it is the\n  /// location of 'F'.\n  SourceLocation getMemberLoc() const { return MemberLoc; }\n  void setMemberLoc(SourceLocation L) { MemberLoc = L; }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY;\n  SourceLocation getEndLoc() const LLVM_READONLY;\n\n  SourceLocation getExprLoc() const LLVM_READONLY { return MemberLoc; }\n\n  /// Determine whether the base of this explicit is implicit.\n  bool isImplicitAccess() const {\n    return getBase() && getBase()->isImplicitCXXThis();\n  }\n\n  /// Returns true if this member expression refers to a method that\n  /// was resolved from an overloaded set having size greater than 1.\n  bool hadMultipleCandidates() const {\n    return MemberExprBits.HadMultipleCandidates;\n  }\n  /// Sets the flag telling whether this expression refers to\n  /// a method that was resolved from an overloaded set having size\n  /// greater than 1.\n  void setHadMultipleCandidates(bool V = true) {\n    MemberExprBits.HadMultipleCandidates = V;\n  }\n\n  /// Returns true if virtual dispatch is performed.\n  /// If the member access is fully qualified, (i.e. X::f()), virtual\n  /// dispatching is not performed. In -fapple-kext mode qualified\n  /// calls to virtual method will still go through the vtable.\n  bool performsVirtualDispatch(const LangOptions &LO) const {\n    return LO.AppleKext || !hasQualifier();\n  }\n\n  /// Is this expression a non-odr-use reference, and if so, why?\n  /// This is only meaningful if the named member is a static member.\n  NonOdrUseReason isNonOdrUse() const {\n    return static_cast<NonOdrUseReason>(MemberExprBits.NonOdrUseReason);\n  }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == MemberExprClass;\n  }\n\n  // Iterators\n  child_range children() { return child_range(&Base, &Base+1); }\n  const_child_range children() const {\n    return const_child_range(&Base, &Base + 1);\n  }\n};\n\n/// CompoundLiteralExpr - [C99 6.5.2.5]\n///\nclass CompoundLiteralExpr : public Expr {\n  /// LParenLoc - If non-null, this is the location of the left paren in a\n  /// compound literal like \"(int){4}\".  This can be null if this is a\n  /// synthesized compound expression.\n  SourceLocation LParenLoc;\n\n  /// The type as written.  This can be an incomplete array type, in\n  /// which case the actual expression type will be different.\n  /// The int part of the pair stores whether this expr is file scope.\n  llvm::PointerIntPair<TypeSourceInfo *, 1, bool> TInfoAndScope;\n  Stmt *Init;\npublic:\n  CompoundLiteralExpr(SourceLocation lparenloc, TypeSourceInfo *tinfo,\n                      QualType T, ExprValueKind VK, Expr *init, bool fileScope)\n      : Expr(CompoundLiteralExprClass, T, VK, OK_Ordinary),\n        LParenLoc(lparenloc), TInfoAndScope(tinfo, fileScope), Init(init) {\n    setDependence(computeDependence(this));\n  }\n\n  /// Construct an empty compound literal.\n  explicit CompoundLiteralExpr(EmptyShell Empty)\n    : Expr(CompoundLiteralExprClass, Empty) { }\n\n  const Expr *getInitializer() const { return cast<Expr>(Init); }\n  Expr *getInitializer() { return cast<Expr>(Init); }\n  void setInitializer(Expr *E) { Init = E; }\n\n  bool isFileScope() const { return TInfoAndScope.getInt(); }\n  void setFileScope(bool FS) { TInfoAndScope.setInt(FS); }\n\n  SourceLocation getLParenLoc() const { return LParenLoc; }\n  void setLParenLoc(SourceLocation L) { LParenLoc = L; }\n\n  TypeSourceInfo *getTypeSourceInfo() const {\n    return TInfoAndScope.getPointer();\n  }\n  void setTypeSourceInfo(TypeSourceInfo *tinfo) {\n    TInfoAndScope.setPointer(tinfo);\n  }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY {\n    // FIXME: Init should never be null.\n    if (!Init)\n      return SourceLocation();\n    if (LParenLoc.isInvalid())\n      return Init->getBeginLoc();\n    return LParenLoc;\n  }\n  SourceLocation getEndLoc() const LLVM_READONLY {\n    // FIXME: Init should never be null.\n    if (!Init)\n      return SourceLocation();\n    return Init->getEndLoc();\n  }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == CompoundLiteralExprClass;\n  }\n\n  // Iterators\n  child_range children() { return child_range(&Init, &Init+1); }\n  const_child_range children() const {\n    return const_child_range(&Init, &Init + 1);\n  }\n};\n\n/// CastExpr - Base class for type casts, including both implicit\n/// casts (ImplicitCastExpr) and explicit casts that have some\n/// representation in the source code (ExplicitCastExpr's derived\n/// classes).\nclass CastExpr : public Expr {\n  Stmt *Op;\n\n  bool CastConsistency() const;\n\n  const CXXBaseSpecifier * const *path_buffer() const {\n    return const_cast<CastExpr*>(this)->path_buffer();\n  }\n  CXXBaseSpecifier **path_buffer();\n\n  friend class ASTStmtReader;\n\nprotected:\n  CastExpr(StmtClass SC, QualType ty, ExprValueKind VK, const CastKind kind,\n           Expr *op, unsigned BasePathSize, bool HasFPFeatures)\n      : Expr(SC, ty, VK, OK_Ordinary), Op(op) {\n    CastExprBits.Kind = kind;\n    CastExprBits.PartOfExplicitCast = false;\n    CastExprBits.BasePathSize = BasePathSize;\n    assert((CastExprBits.BasePathSize == BasePathSize) &&\n           \"BasePathSize overflow!\");\n    setDependence(computeDependence(this));\n    assert(CastConsistency());\n    CastExprBits.HasFPFeatures = HasFPFeatures;\n  }\n\n  /// Construct an empty cast.\n  CastExpr(StmtClass SC, EmptyShell Empty, unsigned BasePathSize,\n           bool HasFPFeatures)\n      : Expr(SC, Empty) {\n    CastExprBits.PartOfExplicitCast = false;\n    CastExprBits.BasePathSize = BasePathSize;\n    CastExprBits.HasFPFeatures = HasFPFeatures;\n    assert((CastExprBits.BasePathSize == BasePathSize) &&\n           \"BasePathSize overflow!\");\n  }\n\n  /// Return a pointer to the trailing FPOptions.\n  /// \\pre hasStoredFPFeatures() == true\n  FPOptionsOverride *getTrailingFPFeatures();\n  const FPOptionsOverride *getTrailingFPFeatures() const {\n    return const_cast<CastExpr *>(this)->getTrailingFPFeatures();\n  }\n\npublic:\n  CastKind getCastKind() const { return (CastKind) CastExprBits.Kind; }\n  void setCastKind(CastKind K) { CastExprBits.Kind = K; }\n\n  static const char *getCastKindName(CastKind CK);\n  const char *getCastKindName() const { return getCastKindName(getCastKind()); }\n\n  Expr *getSubExpr() { return cast<Expr>(Op); }\n  const Expr *getSubExpr() const { return cast<Expr>(Op); }\n  void setSubExpr(Expr *E) { Op = E; }\n\n  /// Retrieve the cast subexpression as it was written in the source\n  /// code, looking through any implicit casts or other intermediate nodes\n  /// introduced by semantic analysis.\n  Expr *getSubExprAsWritten();\n  const Expr *getSubExprAsWritten() const {\n    return const_cast<CastExpr *>(this)->getSubExprAsWritten();\n  }\n\n  /// If this cast applies a user-defined conversion, retrieve the conversion\n  /// function that it invokes.\n  NamedDecl *getConversionFunction() const;\n\n  typedef CXXBaseSpecifier **path_iterator;\n  typedef const CXXBaseSpecifier *const *path_const_iterator;\n  bool path_empty() const { return path_size() == 0; }\n  unsigned path_size() const { return CastExprBits.BasePathSize; }\n  path_iterator path_begin() { return path_buffer(); }\n  path_iterator path_end() { return path_buffer() + path_size(); }\n  path_const_iterator path_begin() const { return path_buffer(); }\n  path_const_iterator path_end() const { return path_buffer() + path_size(); }\n\n  llvm::iterator_range<path_iterator> path() {\n    return llvm::make_range(path_begin(), path_end());\n  }\n  llvm::iterator_range<path_const_iterator> path() const {\n    return llvm::make_range(path_begin(), path_end());\n  }\n\n  const FieldDecl *getTargetUnionField() const {\n    assert(getCastKind() == CK_ToUnion);\n    return getTargetFieldForToUnionCast(getType(), getSubExpr()->getType());\n  }\n\n  bool hasStoredFPFeatures() const { return CastExprBits.HasFPFeatures; }\n\n  /// Get FPOptionsOverride from trailing storage.\n  FPOptionsOverride getStoredFPFeatures() const {\n    assert(hasStoredFPFeatures());\n    return *getTrailingFPFeatures();\n  }\n\n  // Get the FP features status of this operation. Only meaningful for\n  // operations on floating point types.\n  FPOptions getFPFeaturesInEffect(const LangOptions &LO) const {\n    if (hasStoredFPFeatures())\n      return getStoredFPFeatures().applyOverrides(LO);\n    return FPOptions::defaultWithoutTrailingStorage(LO);\n  }\n\n  FPOptionsOverride getFPFeatures() const {\n    if (hasStoredFPFeatures())\n      return getStoredFPFeatures();\n    return FPOptionsOverride();\n  }\n\n  static const FieldDecl *getTargetFieldForToUnionCast(QualType unionType,\n                                                       QualType opType);\n  static const FieldDecl *getTargetFieldForToUnionCast(const RecordDecl *RD,\n                                                       QualType opType);\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() >= firstCastExprConstant &&\n           T->getStmtClass() <= lastCastExprConstant;\n  }\n\n  // Iterators\n  child_range children() { return child_range(&Op, &Op+1); }\n  const_child_range children() const { return const_child_range(&Op, &Op + 1); }\n};\n\n/// ImplicitCastExpr - Allows us to explicitly represent implicit type\n/// conversions, which have no direct representation in the original\n/// source code. For example: converting T[]->T*, void f()->void\n/// (*f)(), float->double, short->int, etc.\n///\n/// In C, implicit casts always produce rvalues. However, in C++, an\n/// implicit cast whose result is being bound to a reference will be\n/// an lvalue or xvalue. For example:\n///\n/// @code\n/// class Base { };\n/// class Derived : public Base { };\n/// Derived &&ref();\n/// void f(Derived d) {\n///   Base& b = d; // initializer is an ImplicitCastExpr\n///                // to an lvalue of type Base\n///   Base&& r = ref(); // initializer is an ImplicitCastExpr\n///                     // to an xvalue of type Base\n/// }\n/// @endcode\nclass ImplicitCastExpr final\n    : public CastExpr,\n      private llvm::TrailingObjects<ImplicitCastExpr, CXXBaseSpecifier *,\n                                    FPOptionsOverride> {\n\n  ImplicitCastExpr(QualType ty, CastKind kind, Expr *op,\n                   unsigned BasePathLength, FPOptionsOverride FPO,\n                   ExprValueKind VK)\n      : CastExpr(ImplicitCastExprClass, ty, VK, kind, op, BasePathLength,\n                 FPO.requiresTrailingStorage()) {\n    if (hasStoredFPFeatures())\n      *getTrailingFPFeatures() = FPO;\n  }\n\n  /// Construct an empty implicit cast.\n  explicit ImplicitCastExpr(EmptyShell Shell, unsigned PathSize,\n                            bool HasFPFeatures)\n      : CastExpr(ImplicitCastExprClass, Shell, PathSize, HasFPFeatures) {}\n\n  unsigned numTrailingObjects(OverloadToken<CXXBaseSpecifier *>) const {\n    return path_size();\n  }\n\npublic:\n  enum OnStack_t { OnStack };\n  ImplicitCastExpr(OnStack_t _, QualType ty, CastKind kind, Expr *op,\n                   ExprValueKind VK, FPOptionsOverride FPO)\n      : CastExpr(ImplicitCastExprClass, ty, VK, kind, op, 0,\n                 FPO.requiresTrailingStorage()) {\n    if (hasStoredFPFeatures())\n      *getTrailingFPFeatures() = FPO;\n  }\n\n  bool isPartOfExplicitCast() const { return CastExprBits.PartOfExplicitCast; }\n  void setIsPartOfExplicitCast(bool PartOfExplicitCast) {\n    CastExprBits.PartOfExplicitCast = PartOfExplicitCast;\n  }\n\n  static ImplicitCastExpr *Create(const ASTContext &Context, QualType T,\n                                  CastKind Kind, Expr *Operand,\n                                  const CXXCastPath *BasePath,\n                                  ExprValueKind Cat, FPOptionsOverride FPO);\n\n  static ImplicitCastExpr *CreateEmpty(const ASTContext &Context,\n                                       unsigned PathSize, bool HasFPFeatures);\n\n  SourceLocation getBeginLoc() const LLVM_READONLY {\n    return getSubExpr()->getBeginLoc();\n  }\n  SourceLocation getEndLoc() const LLVM_READONLY {\n    return getSubExpr()->getEndLoc();\n  }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == ImplicitCastExprClass;\n  }\n\n  friend TrailingObjects;\n  friend class CastExpr;\n};\n\n/// ExplicitCastExpr - An explicit cast written in the source\n/// code.\n///\n/// This class is effectively an abstract class, because it provides\n/// the basic representation of an explicitly-written cast without\n/// specifying which kind of cast (C cast, functional cast, static\n/// cast, etc.) was written; specific derived classes represent the\n/// particular style of cast and its location information.\n///\n/// Unlike implicit casts, explicit cast nodes have two different\n/// types: the type that was written into the source code, and the\n/// actual type of the expression as determined by semantic\n/// analysis. These types may differ slightly. For example, in C++ one\n/// can cast to a reference type, which indicates that the resulting\n/// expression will be an lvalue or xvalue. The reference type, however,\n/// will not be used as the type of the expression.\nclass ExplicitCastExpr : public CastExpr {\n  /// TInfo - Source type info for the (written) type\n  /// this expression is casting to.\n  TypeSourceInfo *TInfo;\n\nprotected:\n  ExplicitCastExpr(StmtClass SC, QualType exprTy, ExprValueKind VK,\n                   CastKind kind, Expr *op, unsigned PathSize,\n                   bool HasFPFeatures, TypeSourceInfo *writtenTy)\n      : CastExpr(SC, exprTy, VK, kind, op, PathSize, HasFPFeatures),\n        TInfo(writtenTy) {}\n\n  /// Construct an empty explicit cast.\n  ExplicitCastExpr(StmtClass SC, EmptyShell Shell, unsigned PathSize,\n                   bool HasFPFeatures)\n      : CastExpr(SC, Shell, PathSize, HasFPFeatures) {}\n\npublic:\n  /// getTypeInfoAsWritten - Returns the type source info for the type\n  /// that this expression is casting to.\n  TypeSourceInfo *getTypeInfoAsWritten() const { return TInfo; }\n  void setTypeInfoAsWritten(TypeSourceInfo *writtenTy) { TInfo = writtenTy; }\n\n  /// getTypeAsWritten - Returns the type that this expression is\n  /// casting to, as written in the source code.\n  QualType getTypeAsWritten() const { return TInfo->getType(); }\n\n  static bool classof(const Stmt *T) {\n     return T->getStmtClass() >= firstExplicitCastExprConstant &&\n            T->getStmtClass() <= lastExplicitCastExprConstant;\n  }\n};\n\n/// CStyleCastExpr - An explicit cast in C (C99 6.5.4) or a C-style\n/// cast in C++ (C++ [expr.cast]), which uses the syntax\n/// (Type)expr. For example: @c (int)f.\nclass CStyleCastExpr final\n    : public ExplicitCastExpr,\n      private llvm::TrailingObjects<CStyleCastExpr, CXXBaseSpecifier *,\n                                    FPOptionsOverride> {\n  SourceLocation LPLoc; // the location of the left paren\n  SourceLocation RPLoc; // the location of the right paren\n\n  CStyleCastExpr(QualType exprTy, ExprValueKind vk, CastKind kind, Expr *op,\n                 unsigned PathSize, FPOptionsOverride FPO,\n                 TypeSourceInfo *writtenTy, SourceLocation l, SourceLocation r)\n      : ExplicitCastExpr(CStyleCastExprClass, exprTy, vk, kind, op, PathSize,\n                         FPO.requiresTrailingStorage(), writtenTy),\n        LPLoc(l), RPLoc(r) {\n    if (hasStoredFPFeatures())\n      *getTrailingFPFeatures() = FPO;\n  }\n\n  /// Construct an empty C-style explicit cast.\n  explicit CStyleCastExpr(EmptyShell Shell, unsigned PathSize,\n                          bool HasFPFeatures)\n      : ExplicitCastExpr(CStyleCastExprClass, Shell, PathSize, HasFPFeatures) {}\n\n  unsigned numTrailingObjects(OverloadToken<CXXBaseSpecifier *>) const {\n    return path_size();\n  }\n\npublic:\n  static CStyleCastExpr *\n  Create(const ASTContext &Context, QualType T, ExprValueKind VK, CastKind K,\n         Expr *Op, const CXXCastPath *BasePath, FPOptionsOverride FPO,\n         TypeSourceInfo *WrittenTy, SourceLocation L, SourceLocation R);\n\n  static CStyleCastExpr *CreateEmpty(const ASTContext &Context,\n                                     unsigned PathSize, bool HasFPFeatures);\n\n  SourceLocation getLParenLoc() const { return LPLoc; }\n  void setLParenLoc(SourceLocation L) { LPLoc = L; }\n\n  SourceLocation getRParenLoc() const { return RPLoc; }\n  void setRParenLoc(SourceLocation L) { RPLoc = L; }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY { return LPLoc; }\n  SourceLocation getEndLoc() const LLVM_READONLY {\n    return getSubExpr()->getEndLoc();\n  }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == CStyleCastExprClass;\n  }\n\n  friend TrailingObjects;\n  friend class CastExpr;\n};\n\n/// A builtin binary operation expression such as \"x + y\" or \"x <= y\".\n///\n/// This expression node kind describes a builtin binary operation,\n/// such as \"x + y\" for integer values \"x\" and \"y\". The operands will\n/// already have been converted to appropriate types (e.g., by\n/// performing promotions or conversions).\n///\n/// In C++, where operators may be overloaded, a different kind of\n/// expression node (CXXOperatorCallExpr) is used to express the\n/// invocation of an overloaded operator with operator syntax. Within\n/// a C++ template, whether BinaryOperator or CXXOperatorCallExpr is\n/// used to store an expression \"x + y\" depends on the subexpressions\n/// for x and y. If neither x or y is type-dependent, and the \"+\"\n/// operator resolves to a built-in operation, BinaryOperator will be\n/// used to express the computation (x and y may still be\n/// value-dependent). If either x or y is type-dependent, or if the\n/// \"+\" resolves to an overloaded operator, CXXOperatorCallExpr will\n/// be used to express the computation.\nclass BinaryOperator : public Expr {\n  enum { LHS, RHS, END_EXPR };\n  Stmt *SubExprs[END_EXPR];\n\npublic:\n  typedef BinaryOperatorKind Opcode;\n\nprotected:\n  size_t offsetOfTrailingStorage() const;\n\n  /// Return a pointer to the trailing FPOptions\n  FPOptionsOverride *getTrailingFPFeatures() {\n    assert(BinaryOperatorBits.HasFPFeatures);\n    return reinterpret_cast<FPOptionsOverride *>(\n        reinterpret_cast<char *>(this) + offsetOfTrailingStorage());\n  }\n  const FPOptionsOverride *getTrailingFPFeatures() const {\n    assert(BinaryOperatorBits.HasFPFeatures);\n    return reinterpret_cast<const FPOptionsOverride *>(\n        reinterpret_cast<const char *>(this) + offsetOfTrailingStorage());\n  }\n\n  /// Build a binary operator, assuming that appropriate storage has been\n  /// allocated for the trailing objects when needed.\n  BinaryOperator(const ASTContext &Ctx, Expr *lhs, Expr *rhs, Opcode opc,\n                 QualType ResTy, ExprValueKind VK, ExprObjectKind OK,\n                 SourceLocation opLoc, FPOptionsOverride FPFeatures);\n\n  /// Construct an empty binary operator.\n  explicit BinaryOperator(EmptyShell Empty) : Expr(BinaryOperatorClass, Empty) {\n    BinaryOperatorBits.Opc = BO_Comma;\n  }\n\npublic:\n  static BinaryOperator *CreateEmpty(const ASTContext &C, bool hasFPFeatures);\n\n  static BinaryOperator *Create(const ASTContext &C, Expr *lhs, Expr *rhs,\n                                Opcode opc, QualType ResTy, ExprValueKind VK,\n                                ExprObjectKind OK, SourceLocation opLoc,\n                                FPOptionsOverride FPFeatures);\n  SourceLocation getExprLoc() const { return getOperatorLoc(); }\n  SourceLocation getOperatorLoc() const { return BinaryOperatorBits.OpLoc; }\n  void setOperatorLoc(SourceLocation L) { BinaryOperatorBits.OpLoc = L; }\n\n  Opcode getOpcode() const {\n    return static_cast<Opcode>(BinaryOperatorBits.Opc);\n  }\n  void setOpcode(Opcode Opc) { BinaryOperatorBits.Opc = Opc; }\n\n  Expr *getLHS() const { return cast<Expr>(SubExprs[LHS]); }\n  void setLHS(Expr *E) { SubExprs[LHS] = E; }\n  Expr *getRHS() const { return cast<Expr>(SubExprs[RHS]); }\n  void setRHS(Expr *E) { SubExprs[RHS] = E; }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY {\n    return getLHS()->getBeginLoc();\n  }\n  SourceLocation getEndLoc() const LLVM_READONLY {\n    return getRHS()->getEndLoc();\n  }\n\n  /// getOpcodeStr - Turn an Opcode enum value into the punctuation char it\n  /// corresponds to, e.g. \"<<=\".\n  static StringRef getOpcodeStr(Opcode Op);\n\n  StringRef getOpcodeStr() const { return getOpcodeStr(getOpcode()); }\n\n  /// Retrieve the binary opcode that corresponds to the given\n  /// overloaded operator.\n  static Opcode getOverloadedOpcode(OverloadedOperatorKind OO);\n\n  /// Retrieve the overloaded operator kind that corresponds to\n  /// the given binary opcode.\n  static OverloadedOperatorKind getOverloadedOperator(Opcode Opc);\n\n  /// predicates to categorize the respective opcodes.\n  static bool isPtrMemOp(Opcode Opc) {\n    return Opc == BO_PtrMemD || Opc == BO_PtrMemI;\n  }\n  bool isPtrMemOp() const { return isPtrMemOp(getOpcode()); }\n\n  static bool isMultiplicativeOp(Opcode Opc) {\n    return Opc >= BO_Mul && Opc <= BO_Rem;\n  }\n  bool isMultiplicativeOp() const { return isMultiplicativeOp(getOpcode()); }\n  static bool isAdditiveOp(Opcode Opc) { return Opc == BO_Add || Opc==BO_Sub; }\n  bool isAdditiveOp() const { return isAdditiveOp(getOpcode()); }\n  static bool isShiftOp(Opcode Opc) { return Opc == BO_Shl || Opc == BO_Shr; }\n  bool isShiftOp() const { return isShiftOp(getOpcode()); }\n\n  static bool isBitwiseOp(Opcode Opc) { return Opc >= BO_And && Opc <= BO_Or; }\n  bool isBitwiseOp() const { return isBitwiseOp(getOpcode()); }\n\n  static bool isRelationalOp(Opcode Opc) { return Opc >= BO_LT && Opc<=BO_GE; }\n  bool isRelationalOp() const { return isRelationalOp(getOpcode()); }\n\n  static bool isEqualityOp(Opcode Opc) { return Opc == BO_EQ || Opc == BO_NE; }\n  bool isEqualityOp() const { return isEqualityOp(getOpcode()); }\n\n  static bool isComparisonOp(Opcode Opc) { return Opc >= BO_Cmp && Opc<=BO_NE; }\n  bool isComparisonOp() const { return isComparisonOp(getOpcode()); }\n\n  static bool isCommaOp(Opcode Opc) { return Opc == BO_Comma; }\n  bool isCommaOp() const { return isCommaOp(getOpcode()); }\n\n  static Opcode negateComparisonOp(Opcode Opc) {\n    switch (Opc) {\n    default:\n      llvm_unreachable(\"Not a comparison operator.\");\n    case BO_LT: return BO_GE;\n    case BO_GT: return BO_LE;\n    case BO_LE: return BO_GT;\n    case BO_GE: return BO_LT;\n    case BO_EQ: return BO_NE;\n    case BO_NE: return BO_EQ;\n    }\n  }\n\n  static Opcode reverseComparisonOp(Opcode Opc) {\n    switch (Opc) {\n    default:\n      llvm_unreachable(\"Not a comparison operator.\");\n    case BO_LT: return BO_GT;\n    case BO_GT: return BO_LT;\n    case BO_LE: return BO_GE;\n    case BO_GE: return BO_LE;\n    case BO_EQ:\n    case BO_NE:\n      return Opc;\n    }\n  }\n\n  static bool isLogicalOp(Opcode Opc) { return Opc == BO_LAnd || Opc==BO_LOr; }\n  bool isLogicalOp() const { return isLogicalOp(getOpcode()); }\n\n  static bool isAssignmentOp(Opcode Opc) {\n    return Opc >= BO_Assign && Opc <= BO_OrAssign;\n  }\n  bool isAssignmentOp() const { return isAssignmentOp(getOpcode()); }\n\n  static bool isCompoundAssignmentOp(Opcode Opc) {\n    return Opc > BO_Assign && Opc <= BO_OrAssign;\n  }\n  bool isCompoundAssignmentOp() const {\n    return isCompoundAssignmentOp(getOpcode());\n  }\n  static Opcode getOpForCompoundAssignment(Opcode Opc) {\n    assert(isCompoundAssignmentOp(Opc));\n    if (Opc >= BO_AndAssign)\n      return Opcode(unsigned(Opc) - BO_AndAssign + BO_And);\n    else\n      return Opcode(unsigned(Opc) - BO_MulAssign + BO_Mul);\n  }\n\n  static bool isShiftAssignOp(Opcode Opc) {\n    return Opc == BO_ShlAssign || Opc == BO_ShrAssign;\n  }\n  bool isShiftAssignOp() const {\n    return isShiftAssignOp(getOpcode());\n  }\n\n  // Return true if a binary operator using the specified opcode and operands\n  // would match the 'p = (i8*)nullptr + n' idiom for casting a pointer-sized\n  // integer to a pointer.\n  static bool isNullPointerArithmeticExtension(ASTContext &Ctx, Opcode Opc,\n                                               Expr *LHS, Expr *RHS);\n\n  static bool classof(const Stmt *S) {\n    return S->getStmtClass() >= firstBinaryOperatorConstant &&\n           S->getStmtClass() <= lastBinaryOperatorConstant;\n  }\n\n  // Iterators\n  child_range children() {\n    return child_range(&SubExprs[0], &SubExprs[0]+END_EXPR);\n  }\n  const_child_range children() const {\n    return const_child_range(&SubExprs[0], &SubExprs[0] + END_EXPR);\n  }\n\n  /// Set and fetch the bit that shows whether FPFeatures needs to be\n  /// allocated in Trailing Storage\n  void setHasStoredFPFeatures(bool B) { BinaryOperatorBits.HasFPFeatures = B; }\n  bool hasStoredFPFeatures() const { return BinaryOperatorBits.HasFPFeatures; }\n\n  /// Get FPFeatures from trailing storage\n  FPOptionsOverride getStoredFPFeatures() const {\n    assert(hasStoredFPFeatures());\n    return *getTrailingFPFeatures();\n  }\n  /// Set FPFeatures in trailing storage, used only by Serialization\n  void setStoredFPFeatures(FPOptionsOverride F) {\n    assert(BinaryOperatorBits.HasFPFeatures);\n    *getTrailingFPFeatures() = F;\n  }\n\n  // Get the FP features status of this operator. Only meaningful for\n  // operations on floating point types.\n  FPOptions getFPFeaturesInEffect(const LangOptions &LO) const {\n    if (BinaryOperatorBits.HasFPFeatures)\n      return getStoredFPFeatures().applyOverrides(LO);\n    return FPOptions::defaultWithoutTrailingStorage(LO);\n  }\n\n  // This is used in ASTImporter\n  FPOptionsOverride getFPFeatures(const LangOptions &LO) const {\n    if (BinaryOperatorBits.HasFPFeatures)\n      return getStoredFPFeatures();\n    return FPOptionsOverride();\n  }\n\n  // Get the FP contractability status of this operator. Only meaningful for\n  // operations on floating point types.\n  bool isFPContractableWithinStatement(const LangOptions &LO) const {\n    return getFPFeaturesInEffect(LO).allowFPContractWithinStatement();\n  }\n\n  // Get the FENV_ACCESS status of this operator. Only meaningful for\n  // operations on floating point types.\n  bool isFEnvAccessOn(const LangOptions &LO) const {\n    return getFPFeaturesInEffect(LO).getAllowFEnvAccess();\n  }\n\nprotected:\n  BinaryOperator(const ASTContext &Ctx, Expr *lhs, Expr *rhs, Opcode opc,\n                 QualType ResTy, ExprValueKind VK, ExprObjectKind OK,\n                 SourceLocation opLoc, FPOptionsOverride FPFeatures,\n                 bool dead2);\n\n  /// Construct an empty BinaryOperator, SC is CompoundAssignOperator.\n  BinaryOperator(StmtClass SC, EmptyShell Empty) : Expr(SC, Empty) {\n    BinaryOperatorBits.Opc = BO_MulAssign;\n  }\n\n  /// Return the size in bytes needed for the trailing objects.\n  /// Used to allocate the right amount of storage.\n  static unsigned sizeOfTrailingObjects(bool HasFPFeatures) {\n    return HasFPFeatures * sizeof(FPOptionsOverride);\n  }\n};\n\n/// CompoundAssignOperator - For compound assignments (e.g. +=), we keep\n/// track of the type the operation is performed in.  Due to the semantics of\n/// these operators, the operands are promoted, the arithmetic performed, an\n/// implicit conversion back to the result type done, then the assignment takes\n/// place.  This captures the intermediate type which the computation is done\n/// in.\nclass CompoundAssignOperator : public BinaryOperator {\n  QualType ComputationLHSType;\n  QualType ComputationResultType;\n\n  /// Construct an empty CompoundAssignOperator.\n  explicit CompoundAssignOperator(const ASTContext &C, EmptyShell Empty,\n                                  bool hasFPFeatures)\n      : BinaryOperator(CompoundAssignOperatorClass, Empty) {}\n\nprotected:\n  CompoundAssignOperator(const ASTContext &C, Expr *lhs, Expr *rhs, Opcode opc,\n                         QualType ResType, ExprValueKind VK, ExprObjectKind OK,\n                         SourceLocation OpLoc, FPOptionsOverride FPFeatures,\n                         QualType CompLHSType, QualType CompResultType)\n      : BinaryOperator(C, lhs, rhs, opc, ResType, VK, OK, OpLoc, FPFeatures,\n                       true),\n        ComputationLHSType(CompLHSType), ComputationResultType(CompResultType) {\n    assert(isCompoundAssignmentOp() &&\n           \"Only should be used for compound assignments\");\n  }\n\npublic:\n  static CompoundAssignOperator *CreateEmpty(const ASTContext &C,\n                                             bool hasFPFeatures);\n\n  static CompoundAssignOperator *\n  Create(const ASTContext &C, Expr *lhs, Expr *rhs, Opcode opc, QualType ResTy,\n         ExprValueKind VK, ExprObjectKind OK, SourceLocation opLoc,\n         FPOptionsOverride FPFeatures, QualType CompLHSType = QualType(),\n         QualType CompResultType = QualType());\n\n  // The two computation types are the type the LHS is converted\n  // to for the computation and the type of the result; the two are\n  // distinct in a few cases (specifically, int+=ptr and ptr-=ptr).\n  QualType getComputationLHSType() const { return ComputationLHSType; }\n  void setComputationLHSType(QualType T) { ComputationLHSType = T; }\n\n  QualType getComputationResultType() const { return ComputationResultType; }\n  void setComputationResultType(QualType T) { ComputationResultType = T; }\n\n  static bool classof(const Stmt *S) {\n    return S->getStmtClass() == CompoundAssignOperatorClass;\n  }\n};\n\ninline size_t BinaryOperator::offsetOfTrailingStorage() const {\n  assert(BinaryOperatorBits.HasFPFeatures);\n  return isa<CompoundAssignOperator>(this) ? sizeof(CompoundAssignOperator)\n                                           : sizeof(BinaryOperator);\n}\n\n/// AbstractConditionalOperator - An abstract base class for\n/// ConditionalOperator and BinaryConditionalOperator.\nclass AbstractConditionalOperator : public Expr {\n  SourceLocation QuestionLoc, ColonLoc;\n  friend class ASTStmtReader;\n\nprotected:\n  AbstractConditionalOperator(StmtClass SC, QualType T, ExprValueKind VK,\n                              ExprObjectKind OK, SourceLocation qloc,\n                              SourceLocation cloc)\n      : Expr(SC, T, VK, OK), QuestionLoc(qloc), ColonLoc(cloc) {}\n\n  AbstractConditionalOperator(StmtClass SC, EmptyShell Empty)\n    : Expr(SC, Empty) { }\n\npublic:\n  // getCond - Return the expression representing the condition for\n  //   the ?: operator.\n  Expr *getCond() const;\n\n  // getTrueExpr - Return the subexpression representing the value of\n  //   the expression if the condition evaluates to true.\n  Expr *getTrueExpr() const;\n\n  // getFalseExpr - Return the subexpression representing the value of\n  //   the expression if the condition evaluates to false.  This is\n  //   the same as getRHS.\n  Expr *getFalseExpr() const;\n\n  SourceLocation getQuestionLoc() const { return QuestionLoc; }\n  SourceLocation getColonLoc() const { return ColonLoc; }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == ConditionalOperatorClass ||\n           T->getStmtClass() == BinaryConditionalOperatorClass;\n  }\n};\n\n/// ConditionalOperator - The ?: ternary operator.  The GNU \"missing\n/// middle\" extension is a BinaryConditionalOperator.\nclass ConditionalOperator : public AbstractConditionalOperator {\n  enum { COND, LHS, RHS, END_EXPR };\n  Stmt* SubExprs[END_EXPR]; // Left/Middle/Right hand sides.\n\n  friend class ASTStmtReader;\npublic:\n  ConditionalOperator(Expr *cond, SourceLocation QLoc, Expr *lhs,\n                      SourceLocation CLoc, Expr *rhs, QualType t,\n                      ExprValueKind VK, ExprObjectKind OK)\n      : AbstractConditionalOperator(ConditionalOperatorClass, t, VK, OK, QLoc,\n                                    CLoc) {\n    SubExprs[COND] = cond;\n    SubExprs[LHS] = lhs;\n    SubExprs[RHS] = rhs;\n    setDependence(computeDependence(this));\n  }\n\n  /// Build an empty conditional operator.\n  explicit ConditionalOperator(EmptyShell Empty)\n    : AbstractConditionalOperator(ConditionalOperatorClass, Empty) { }\n\n  // getCond - Return the expression representing the condition for\n  //   the ?: operator.\n  Expr *getCond() const { return cast<Expr>(SubExprs[COND]); }\n\n  // getTrueExpr - Return the subexpression representing the value of\n  //   the expression if the condition evaluates to true.\n  Expr *getTrueExpr() const { return cast<Expr>(SubExprs[LHS]); }\n\n  // getFalseExpr - Return the subexpression representing the value of\n  //   the expression if the condition evaluates to false.  This is\n  //   the same as getRHS.\n  Expr *getFalseExpr() const { return cast<Expr>(SubExprs[RHS]); }\n\n  Expr *getLHS() const { return cast<Expr>(SubExprs[LHS]); }\n  Expr *getRHS() const { return cast<Expr>(SubExprs[RHS]); }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY {\n    return getCond()->getBeginLoc();\n  }\n  SourceLocation getEndLoc() const LLVM_READONLY {\n    return getRHS()->getEndLoc();\n  }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == ConditionalOperatorClass;\n  }\n\n  // Iterators\n  child_range children() {\n    return child_range(&SubExprs[0], &SubExprs[0]+END_EXPR);\n  }\n  const_child_range children() const {\n    return const_child_range(&SubExprs[0], &SubExprs[0] + END_EXPR);\n  }\n};\n\n/// BinaryConditionalOperator - The GNU extension to the conditional\n/// operator which allows the middle operand to be omitted.\n///\n/// This is a different expression kind on the assumption that almost\n/// every client ends up needing to know that these are different.\nclass BinaryConditionalOperator : public AbstractConditionalOperator {\n  enum { COMMON, COND, LHS, RHS, NUM_SUBEXPRS };\n\n  /// - the common condition/left-hand-side expression, which will be\n  ///   evaluated as the opaque value\n  /// - the condition, expressed in terms of the opaque value\n  /// - the left-hand-side, expressed in terms of the opaque value\n  /// - the right-hand-side\n  Stmt *SubExprs[NUM_SUBEXPRS];\n  OpaqueValueExpr *OpaqueValue;\n\n  friend class ASTStmtReader;\npublic:\n  BinaryConditionalOperator(Expr *common, OpaqueValueExpr *opaqueValue,\n                            Expr *cond, Expr *lhs, Expr *rhs,\n                            SourceLocation qloc, SourceLocation cloc,\n                            QualType t, ExprValueKind VK, ExprObjectKind OK)\n      : AbstractConditionalOperator(BinaryConditionalOperatorClass, t, VK, OK,\n                                    qloc, cloc),\n        OpaqueValue(opaqueValue) {\n    SubExprs[COMMON] = common;\n    SubExprs[COND] = cond;\n    SubExprs[LHS] = lhs;\n    SubExprs[RHS] = rhs;\n    assert(OpaqueValue->getSourceExpr() == common && \"Wrong opaque value\");\n    setDependence(computeDependence(this));\n  }\n\n  /// Build an empty conditional operator.\n  explicit BinaryConditionalOperator(EmptyShell Empty)\n    : AbstractConditionalOperator(BinaryConditionalOperatorClass, Empty) { }\n\n  /// getCommon - Return the common expression, written to the\n  ///   left of the condition.  The opaque value will be bound to the\n  ///   result of this expression.\n  Expr *getCommon() const { return cast<Expr>(SubExprs[COMMON]); }\n\n  /// getOpaqueValue - Return the opaque value placeholder.\n  OpaqueValueExpr *getOpaqueValue() const { return OpaqueValue; }\n\n  /// getCond - Return the condition expression; this is defined\n  ///   in terms of the opaque value.\n  Expr *getCond() const { return cast<Expr>(SubExprs[COND]); }\n\n  /// getTrueExpr - Return the subexpression which will be\n  ///   evaluated if the condition evaluates to true;  this is defined\n  ///   in terms of the opaque value.\n  Expr *getTrueExpr() const {\n    return cast<Expr>(SubExprs[LHS]);\n  }\n\n  /// getFalseExpr - Return the subexpression which will be\n  ///   evaluated if the condnition evaluates to false; this is\n  ///   defined in terms of the opaque value.\n  Expr *getFalseExpr() const {\n    return cast<Expr>(SubExprs[RHS]);\n  }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY {\n    return getCommon()->getBeginLoc();\n  }\n  SourceLocation getEndLoc() const LLVM_READONLY {\n    return getFalseExpr()->getEndLoc();\n  }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == BinaryConditionalOperatorClass;\n  }\n\n  // Iterators\n  child_range children() {\n    return child_range(SubExprs, SubExprs + NUM_SUBEXPRS);\n  }\n  const_child_range children() const {\n    return const_child_range(SubExprs, SubExprs + NUM_SUBEXPRS);\n  }\n};\n\ninline Expr *AbstractConditionalOperator::getCond() const {\n  if (const ConditionalOperator *co = dyn_cast<ConditionalOperator>(this))\n    return co->getCond();\n  return cast<BinaryConditionalOperator>(this)->getCond();\n}\n\ninline Expr *AbstractConditionalOperator::getTrueExpr() const {\n  if (const ConditionalOperator *co = dyn_cast<ConditionalOperator>(this))\n    return co->getTrueExpr();\n  return cast<BinaryConditionalOperator>(this)->getTrueExpr();\n}\n\ninline Expr *AbstractConditionalOperator::getFalseExpr() const {\n  if (const ConditionalOperator *co = dyn_cast<ConditionalOperator>(this))\n    return co->getFalseExpr();\n  return cast<BinaryConditionalOperator>(this)->getFalseExpr();\n}\n\n/// AddrLabelExpr - The GNU address of label extension, representing &&label.\nclass AddrLabelExpr : public Expr {\n  SourceLocation AmpAmpLoc, LabelLoc;\n  LabelDecl *Label;\npublic:\n  AddrLabelExpr(SourceLocation AALoc, SourceLocation LLoc, LabelDecl *L,\n                QualType t)\n      : Expr(AddrLabelExprClass, t, VK_RValue, OK_Ordinary), AmpAmpLoc(AALoc),\n        LabelLoc(LLoc), Label(L) {\n    setDependence(ExprDependence::None);\n  }\n\n  /// Build an empty address of a label expression.\n  explicit AddrLabelExpr(EmptyShell Empty)\n    : Expr(AddrLabelExprClass, Empty) { }\n\n  SourceLocation getAmpAmpLoc() const { return AmpAmpLoc; }\n  void setAmpAmpLoc(SourceLocation L) { AmpAmpLoc = L; }\n  SourceLocation getLabelLoc() const { return LabelLoc; }\n  void setLabelLoc(SourceLocation L) { LabelLoc = L; }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY { return AmpAmpLoc; }\n  SourceLocation getEndLoc() const LLVM_READONLY { return LabelLoc; }\n\n  LabelDecl *getLabel() const { return Label; }\n  void setLabel(LabelDecl *L) { Label = L; }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == AddrLabelExprClass;\n  }\n\n  // Iterators\n  child_range children() {\n    return child_range(child_iterator(), child_iterator());\n  }\n  const_child_range children() const {\n    return const_child_range(const_child_iterator(), const_child_iterator());\n  }\n};\n\n/// StmtExpr - This is the GNU Statement Expression extension: ({int X=4; X;}).\n/// The StmtExpr contains a single CompoundStmt node, which it evaluates and\n/// takes the value of the last subexpression.\n///\n/// A StmtExpr is always an r-value; values \"returned\" out of a\n/// StmtExpr will be copied.\nclass StmtExpr : public Expr {\n  Stmt *SubStmt;\n  SourceLocation LParenLoc, RParenLoc;\npublic:\n  StmtExpr(CompoundStmt *SubStmt, QualType T, SourceLocation LParenLoc,\n           SourceLocation RParenLoc, unsigned TemplateDepth)\n      : Expr(StmtExprClass, T, VK_RValue, OK_Ordinary), SubStmt(SubStmt),\n        LParenLoc(LParenLoc), RParenLoc(RParenLoc) {\n    setDependence(computeDependence(this, TemplateDepth));\n    // FIXME: A templated statement expression should have an associated\n    // DeclContext so that nested declarations always have a dependent context.\n    StmtExprBits.TemplateDepth = TemplateDepth;\n  }\n\n  /// Build an empty statement expression.\n  explicit StmtExpr(EmptyShell Empty) : Expr(StmtExprClass, Empty) { }\n\n  CompoundStmt *getSubStmt() { return cast<CompoundStmt>(SubStmt); }\n  const CompoundStmt *getSubStmt() const { return cast<CompoundStmt>(SubStmt); }\n  void setSubStmt(CompoundStmt *S) { SubStmt = S; }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY { return LParenLoc; }\n  SourceLocation getEndLoc() const LLVM_READONLY { return RParenLoc; }\n\n  SourceLocation getLParenLoc() const { return LParenLoc; }\n  void setLParenLoc(SourceLocation L) { LParenLoc = L; }\n  SourceLocation getRParenLoc() const { return RParenLoc; }\n  void setRParenLoc(SourceLocation L) { RParenLoc = L; }\n\n  unsigned getTemplateDepth() const { return StmtExprBits.TemplateDepth; }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == StmtExprClass;\n  }\n\n  // Iterators\n  child_range children() { return child_range(&SubStmt, &SubStmt+1); }\n  const_child_range children() const {\n    return const_child_range(&SubStmt, &SubStmt + 1);\n  }\n};\n\n/// ShuffleVectorExpr - clang-specific builtin-in function\n/// __builtin_shufflevector.\n/// This AST node represents a operator that does a constant\n/// shuffle, similar to LLVM's shufflevector instruction. It takes\n/// two vectors and a variable number of constant indices,\n/// and returns the appropriately shuffled vector.\nclass ShuffleVectorExpr : public Expr {\n  SourceLocation BuiltinLoc, RParenLoc;\n\n  // SubExprs - the list of values passed to the __builtin_shufflevector\n  // function. The first two are vectors, and the rest are constant\n  // indices.  The number of values in this list is always\n  // 2+the number of indices in the vector type.\n  Stmt **SubExprs;\n  unsigned NumExprs;\n\npublic:\n  ShuffleVectorExpr(const ASTContext &C, ArrayRef<Expr*> args, QualType Type,\n                    SourceLocation BLoc, SourceLocation RP);\n\n  /// Build an empty vector-shuffle expression.\n  explicit ShuffleVectorExpr(EmptyShell Empty)\n    : Expr(ShuffleVectorExprClass, Empty), SubExprs(nullptr) { }\n\n  SourceLocation getBuiltinLoc() const { return BuiltinLoc; }\n  void setBuiltinLoc(SourceLocation L) { BuiltinLoc = L; }\n\n  SourceLocation getRParenLoc() const { return RParenLoc; }\n  void setRParenLoc(SourceLocation L) { RParenLoc = L; }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY { return BuiltinLoc; }\n  SourceLocation getEndLoc() const LLVM_READONLY { return RParenLoc; }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == ShuffleVectorExprClass;\n  }\n\n  /// getNumSubExprs - Return the size of the SubExprs array.  This includes the\n  /// constant expression, the actual arguments passed in, and the function\n  /// pointers.\n  unsigned getNumSubExprs() const { return NumExprs; }\n\n  /// Retrieve the array of expressions.\n  Expr **getSubExprs() { return reinterpret_cast<Expr **>(SubExprs); }\n\n  /// getExpr - Return the Expr at the specified index.\n  Expr *getExpr(unsigned Index) {\n    assert((Index < NumExprs) && \"Arg access out of range!\");\n    return cast<Expr>(SubExprs[Index]);\n  }\n  const Expr *getExpr(unsigned Index) const {\n    assert((Index < NumExprs) && \"Arg access out of range!\");\n    return cast<Expr>(SubExprs[Index]);\n  }\n\n  void setExprs(const ASTContext &C, ArrayRef<Expr *> Exprs);\n\n  llvm::APSInt getShuffleMaskIdx(const ASTContext &Ctx, unsigned N) const {\n    assert((N < NumExprs - 2) && \"Shuffle idx out of range!\");\n    return getExpr(N+2)->EvaluateKnownConstInt(Ctx);\n  }\n\n  // Iterators\n  child_range children() {\n    return child_range(&SubExprs[0], &SubExprs[0]+NumExprs);\n  }\n  const_child_range children() const {\n    return const_child_range(&SubExprs[0], &SubExprs[0] + NumExprs);\n  }\n};\n\n/// ConvertVectorExpr - Clang builtin function __builtin_convertvector\n/// This AST node provides support for converting a vector type to another\n/// vector type of the same arity.\nclass ConvertVectorExpr : public Expr {\nprivate:\n  Stmt *SrcExpr;\n  TypeSourceInfo *TInfo;\n  SourceLocation BuiltinLoc, RParenLoc;\n\n  friend class ASTReader;\n  friend class ASTStmtReader;\n  explicit ConvertVectorExpr(EmptyShell Empty) : Expr(ConvertVectorExprClass, Empty) {}\n\npublic:\n  ConvertVectorExpr(Expr *SrcExpr, TypeSourceInfo *TI, QualType DstType,\n                    ExprValueKind VK, ExprObjectKind OK,\n                    SourceLocation BuiltinLoc, SourceLocation RParenLoc)\n      : Expr(ConvertVectorExprClass, DstType, VK, OK), SrcExpr(SrcExpr),\n        TInfo(TI), BuiltinLoc(BuiltinLoc), RParenLoc(RParenLoc) {\n    setDependence(computeDependence(this));\n  }\n\n  /// getSrcExpr - Return the Expr to be converted.\n  Expr *getSrcExpr() const { return cast<Expr>(SrcExpr); }\n\n  /// getTypeSourceInfo - Return the destination type.\n  TypeSourceInfo *getTypeSourceInfo() const {\n    return TInfo;\n  }\n  void setTypeSourceInfo(TypeSourceInfo *ti) {\n    TInfo = ti;\n  }\n\n  /// getBuiltinLoc - Return the location of the __builtin_convertvector token.\n  SourceLocation getBuiltinLoc() const { return BuiltinLoc; }\n\n  /// getRParenLoc - Return the location of final right parenthesis.\n  SourceLocation getRParenLoc() const { return RParenLoc; }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY { return BuiltinLoc; }\n  SourceLocation getEndLoc() const LLVM_READONLY { return RParenLoc; }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == ConvertVectorExprClass;\n  }\n\n  // Iterators\n  child_range children() { return child_range(&SrcExpr, &SrcExpr+1); }\n  const_child_range children() const {\n    return const_child_range(&SrcExpr, &SrcExpr + 1);\n  }\n};\n\n/// ChooseExpr - GNU builtin-in function __builtin_choose_expr.\n/// This AST node is similar to the conditional operator (?:) in C, with\n/// the following exceptions:\n/// - the test expression must be a integer constant expression.\n/// - the expression returned acts like the chosen subexpression in every\n///   visible way: the type is the same as that of the chosen subexpression,\n///   and all predicates (whether it's an l-value, whether it's an integer\n///   constant expression, etc.) return the same result as for the chosen\n///   sub-expression.\nclass ChooseExpr : public Expr {\n  enum { COND, LHS, RHS, END_EXPR };\n  Stmt* SubExprs[END_EXPR]; // Left/Middle/Right hand sides.\n  SourceLocation BuiltinLoc, RParenLoc;\n  bool CondIsTrue;\npublic:\n  ChooseExpr(SourceLocation BLoc, Expr *cond, Expr *lhs, Expr *rhs, QualType t,\n             ExprValueKind VK, ExprObjectKind OK, SourceLocation RP,\n             bool condIsTrue)\n      : Expr(ChooseExprClass, t, VK, OK), BuiltinLoc(BLoc), RParenLoc(RP),\n        CondIsTrue(condIsTrue) {\n    SubExprs[COND] = cond;\n    SubExprs[LHS] = lhs;\n    SubExprs[RHS] = rhs;\n\n    setDependence(computeDependence(this));\n  }\n\n  /// Build an empty __builtin_choose_expr.\n  explicit ChooseExpr(EmptyShell Empty) : Expr(ChooseExprClass, Empty) { }\n\n  /// isConditionTrue - Return whether the condition is true (i.e. not\n  /// equal to zero).\n  bool isConditionTrue() const {\n    assert(!isConditionDependent() &&\n           \"Dependent condition isn't true or false\");\n    return CondIsTrue;\n  }\n  void setIsConditionTrue(bool isTrue) { CondIsTrue = isTrue; }\n\n  bool isConditionDependent() const {\n    return getCond()->isTypeDependent() || getCond()->isValueDependent();\n  }\n\n  /// getChosenSubExpr - Return the subexpression chosen according to the\n  /// condition.\n  Expr *getChosenSubExpr() const {\n    return isConditionTrue() ? getLHS() : getRHS();\n  }\n\n  Expr *getCond() const { return cast<Expr>(SubExprs[COND]); }\n  void setCond(Expr *E) { SubExprs[COND] = E; }\n  Expr *getLHS() const { return cast<Expr>(SubExprs[LHS]); }\n  void setLHS(Expr *E) { SubExprs[LHS] = E; }\n  Expr *getRHS() const { return cast<Expr>(SubExprs[RHS]); }\n  void setRHS(Expr *E) { SubExprs[RHS] = E; }\n\n  SourceLocation getBuiltinLoc() const { return BuiltinLoc; }\n  void setBuiltinLoc(SourceLocation L) { BuiltinLoc = L; }\n\n  SourceLocation getRParenLoc() const { return RParenLoc; }\n  void setRParenLoc(SourceLocation L) { RParenLoc = L; }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY { return BuiltinLoc; }\n  SourceLocation getEndLoc() const LLVM_READONLY { return RParenLoc; }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == ChooseExprClass;\n  }\n\n  // Iterators\n  child_range children() {\n    return child_range(&SubExprs[0], &SubExprs[0]+END_EXPR);\n  }\n  const_child_range children() const {\n    return const_child_range(&SubExprs[0], &SubExprs[0] + END_EXPR);\n  }\n};\n\n/// GNUNullExpr - Implements the GNU __null extension, which is a name\n/// for a null pointer constant that has integral type (e.g., int or\n/// long) and is the same size and alignment as a pointer. The __null\n/// extension is typically only used by system headers, which define\n/// NULL as __null in C++ rather than using 0 (which is an integer\n/// that may not match the size of a pointer).\nclass GNUNullExpr : public Expr {\n  /// TokenLoc - The location of the __null keyword.\n  SourceLocation TokenLoc;\n\npublic:\n  GNUNullExpr(QualType Ty, SourceLocation Loc)\n      : Expr(GNUNullExprClass, Ty, VK_RValue, OK_Ordinary), TokenLoc(Loc) {\n    setDependence(ExprDependence::None);\n  }\n\n  /// Build an empty GNU __null expression.\n  explicit GNUNullExpr(EmptyShell Empty) : Expr(GNUNullExprClass, Empty) { }\n\n  /// getTokenLocation - The location of the __null token.\n  SourceLocation getTokenLocation() const { return TokenLoc; }\n  void setTokenLocation(SourceLocation L) { TokenLoc = L; }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY { return TokenLoc; }\n  SourceLocation getEndLoc() const LLVM_READONLY { return TokenLoc; }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == GNUNullExprClass;\n  }\n\n  // Iterators\n  child_range children() {\n    return child_range(child_iterator(), child_iterator());\n  }\n  const_child_range children() const {\n    return const_child_range(const_child_iterator(), const_child_iterator());\n  }\n};\n\n/// Represents a call to the builtin function \\c __builtin_va_arg.\nclass VAArgExpr : public Expr {\n  Stmt *Val;\n  llvm::PointerIntPair<TypeSourceInfo *, 1, bool> TInfo;\n  SourceLocation BuiltinLoc, RParenLoc;\npublic:\n  VAArgExpr(SourceLocation BLoc, Expr *e, TypeSourceInfo *TInfo,\n            SourceLocation RPLoc, QualType t, bool IsMS)\n      : Expr(VAArgExprClass, t, VK_RValue, OK_Ordinary), Val(e),\n        TInfo(TInfo, IsMS), BuiltinLoc(BLoc), RParenLoc(RPLoc) {\n    setDependence(computeDependence(this));\n  }\n\n  /// Create an empty __builtin_va_arg expression.\n  explicit VAArgExpr(EmptyShell Empty)\n      : Expr(VAArgExprClass, Empty), Val(nullptr), TInfo(nullptr, false) {}\n\n  const Expr *getSubExpr() const { return cast<Expr>(Val); }\n  Expr *getSubExpr() { return cast<Expr>(Val); }\n  void setSubExpr(Expr *E) { Val = E; }\n\n  /// Returns whether this is really a Win64 ABI va_arg expression.\n  bool isMicrosoftABI() const { return TInfo.getInt(); }\n  void setIsMicrosoftABI(bool IsMS) { TInfo.setInt(IsMS); }\n\n  TypeSourceInfo *getWrittenTypeInfo() const { return TInfo.getPointer(); }\n  void setWrittenTypeInfo(TypeSourceInfo *TI) { TInfo.setPointer(TI); }\n\n  SourceLocation getBuiltinLoc() const { return BuiltinLoc; }\n  void setBuiltinLoc(SourceLocation L) { BuiltinLoc = L; }\n\n  SourceLocation getRParenLoc() const { return RParenLoc; }\n  void setRParenLoc(SourceLocation L) { RParenLoc = L; }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY { return BuiltinLoc; }\n  SourceLocation getEndLoc() const LLVM_READONLY { return RParenLoc; }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == VAArgExprClass;\n  }\n\n  // Iterators\n  child_range children() { return child_range(&Val, &Val+1); }\n  const_child_range children() const {\n    return const_child_range(&Val, &Val + 1);\n  }\n};\n\n/// Represents a function call to one of __builtin_LINE(), __builtin_COLUMN(),\n/// __builtin_FUNCTION(), or __builtin_FILE().\nclass SourceLocExpr final : public Expr {\n  SourceLocation BuiltinLoc, RParenLoc;\n  DeclContext *ParentContext;\n\npublic:\n  enum IdentKind { Function, File, Line, Column };\n\n  SourceLocExpr(const ASTContext &Ctx, IdentKind Type, SourceLocation BLoc,\n                SourceLocation RParenLoc, DeclContext *Context);\n\n  /// Build an empty call expression.\n  explicit SourceLocExpr(EmptyShell Empty) : Expr(SourceLocExprClass, Empty) {}\n\n  /// Return the result of evaluating this SourceLocExpr in the specified\n  /// (and possibly null) default argument or initialization context.\n  APValue EvaluateInContext(const ASTContext &Ctx,\n                            const Expr *DefaultExpr) const;\n\n  /// Return a string representing the name of the specific builtin function.\n  StringRef getBuiltinStr() const;\n\n  IdentKind getIdentKind() const {\n    return static_cast<IdentKind>(SourceLocExprBits.Kind);\n  }\n\n  bool isStringType() const {\n    switch (getIdentKind()) {\n    case File:\n    case Function:\n      return true;\n    case Line:\n    case Column:\n      return false;\n    }\n    llvm_unreachable(\"unknown source location expression kind\");\n  }\n  bool isIntType() const LLVM_READONLY { return !isStringType(); }\n\n  /// If the SourceLocExpr has been resolved return the subexpression\n  /// representing the resolved value. Otherwise return null.\n  const DeclContext *getParentContext() const { return ParentContext; }\n  DeclContext *getParentContext() { return ParentContext; }\n\n  SourceLocation getLocation() const { return BuiltinLoc; }\n  SourceLocation getBeginLoc() const { return BuiltinLoc; }\n  SourceLocation getEndLoc() const { return RParenLoc; }\n\n  child_range children() {\n    return child_range(child_iterator(), child_iterator());\n  }\n\n  const_child_range children() const {\n    return const_child_range(child_iterator(), child_iterator());\n  }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == SourceLocExprClass;\n  }\n\nprivate:\n  friend class ASTStmtReader;\n};\n\n/// Describes an C or C++ initializer list.\n///\n/// InitListExpr describes an initializer list, which can be used to\n/// initialize objects of different types, including\n/// struct/class/union types, arrays, and vectors. For example:\n///\n/// @code\n/// struct foo x = { 1, { 2, 3 } };\n/// @endcode\n///\n/// Prior to semantic analysis, an initializer list will represent the\n/// initializer list as written by the user, but will have the\n/// placeholder type \"void\". This initializer list is called the\n/// syntactic form of the initializer, and may contain C99 designated\n/// initializers (represented as DesignatedInitExprs), initializations\n/// of subobject members without explicit braces, and so on. Clients\n/// interested in the original syntax of the initializer list should\n/// use the syntactic form of the initializer list.\n///\n/// After semantic analysis, the initializer list will represent the\n/// semantic form of the initializer, where the initializations of all\n/// subobjects are made explicit with nested InitListExpr nodes and\n/// C99 designators have been eliminated by placing the designated\n/// initializations into the subobject they initialize. Additionally,\n/// any \"holes\" in the initialization, where no initializer has been\n/// specified for a particular subobject, will be replaced with\n/// implicitly-generated ImplicitValueInitExpr expressions that\n/// value-initialize the subobjects. Note, however, that the\n/// initializer lists may still have fewer initializers than there are\n/// elements to initialize within the object.\n///\n/// After semantic analysis has completed, given an initializer list,\n/// method isSemanticForm() returns true if and only if this is the\n/// semantic form of the initializer list (note: the same AST node\n/// may at the same time be the syntactic form).\n/// Given the semantic form of the initializer list, one can retrieve\n/// the syntactic form of that initializer list (when different)\n/// using method getSyntacticForm(); the method returns null if applied\n/// to a initializer list which is already in syntactic form.\n/// Similarly, given the syntactic form (i.e., an initializer list such\n/// that isSemanticForm() returns false), one can retrieve the semantic\n/// form using method getSemanticForm().\n/// Since many initializer lists have the same syntactic and semantic forms,\n/// getSyntacticForm() may return NULL, indicating that the current\n/// semantic initializer list also serves as its syntactic form.\nclass InitListExpr : public Expr {\n  // FIXME: Eliminate this vector in favor of ASTContext allocation\n  typedef ASTVector<Stmt *> InitExprsTy;\n  InitExprsTy InitExprs;\n  SourceLocation LBraceLoc, RBraceLoc;\n\n  /// The alternative form of the initializer list (if it exists).\n  /// The int part of the pair stores whether this initializer list is\n  /// in semantic form. If not null, the pointer points to:\n  ///   - the syntactic form, if this is in semantic form;\n  ///   - the semantic form, if this is in syntactic form.\n  llvm::PointerIntPair<InitListExpr *, 1, bool> AltForm;\n\n  /// Either:\n  ///  If this initializer list initializes an array with more elements than\n  ///  there are initializers in the list, specifies an expression to be used\n  ///  for value initialization of the rest of the elements.\n  /// Or\n  ///  If this initializer list initializes a union, specifies which\n  ///  field within the union will be initialized.\n  llvm::PointerUnion<Expr *, FieldDecl *> ArrayFillerOrUnionFieldInit;\n\npublic:\n  InitListExpr(const ASTContext &C, SourceLocation lbraceloc,\n               ArrayRef<Expr*> initExprs, SourceLocation rbraceloc);\n\n  /// Build an empty initializer list.\n  explicit InitListExpr(EmptyShell Empty)\n    : Expr(InitListExprClass, Empty), AltForm(nullptr, true) { }\n\n  unsigned getNumInits() const { return InitExprs.size(); }\n\n  /// Retrieve the set of initializers.\n  Expr **getInits() { return reinterpret_cast<Expr **>(InitExprs.data()); }\n\n  /// Retrieve the set of initializers.\n  Expr * const *getInits() const {\n    return reinterpret_cast<Expr * const *>(InitExprs.data());\n  }\n\n  ArrayRef<Expr *> inits() {\n    return llvm::makeArrayRef(getInits(), getNumInits());\n  }\n\n  ArrayRef<Expr *> inits() const {\n    return llvm::makeArrayRef(getInits(), getNumInits());\n  }\n\n  const Expr *getInit(unsigned Init) const {\n    assert(Init < getNumInits() && \"Initializer access out of range!\");\n    return cast_or_null<Expr>(InitExprs[Init]);\n  }\n\n  Expr *getInit(unsigned Init) {\n    assert(Init < getNumInits() && \"Initializer access out of range!\");\n    return cast_or_null<Expr>(InitExprs[Init]);\n  }\n\n  void setInit(unsigned Init, Expr *expr) {\n    assert(Init < getNumInits() && \"Initializer access out of range!\");\n    InitExprs[Init] = expr;\n\n    if (expr)\n      setDependence(getDependence() | expr->getDependence());\n  }\n\n  /// Mark the semantic form of the InitListExpr as error when the semantic\n  /// analysis fails.\n  void markError() {\n    assert(isSemanticForm());\n    setDependence(getDependence() | ExprDependence::ErrorDependent);\n  }\n\n  /// Reserve space for some number of initializers.\n  void reserveInits(const ASTContext &C, unsigned NumInits);\n\n  /// Specify the number of initializers\n  ///\n  /// If there are more than @p NumInits initializers, the remaining\n  /// initializers will be destroyed. If there are fewer than @p\n  /// NumInits initializers, NULL expressions will be added for the\n  /// unknown initializers.\n  void resizeInits(const ASTContext &Context, unsigned NumInits);\n\n  /// Updates the initializer at index @p Init with the new\n  /// expression @p expr, and returns the old expression at that\n  /// location.\n  ///\n  /// When @p Init is out of range for this initializer list, the\n  /// initializer list will be extended with NULL expressions to\n  /// accommodate the new entry.\n  Expr *updateInit(const ASTContext &C, unsigned Init, Expr *expr);\n\n  /// If this initializer list initializes an array with more elements\n  /// than there are initializers in the list, specifies an expression to be\n  /// used for value initialization of the rest of the elements.\n  Expr *getArrayFiller() {\n    return ArrayFillerOrUnionFieldInit.dyn_cast<Expr *>();\n  }\n  const Expr *getArrayFiller() const {\n    return const_cast<InitListExpr *>(this)->getArrayFiller();\n  }\n  void setArrayFiller(Expr *filler);\n\n  /// Return true if this is an array initializer and its array \"filler\"\n  /// has been set.\n  bool hasArrayFiller() const { return getArrayFiller(); }\n\n  /// If this initializes a union, specifies which field in the\n  /// union to initialize.\n  ///\n  /// Typically, this field is the first named field within the\n  /// union. However, a designated initializer can specify the\n  /// initialization of a different field within the union.\n  FieldDecl *getInitializedFieldInUnion() {\n    return ArrayFillerOrUnionFieldInit.dyn_cast<FieldDecl *>();\n  }\n  const FieldDecl *getInitializedFieldInUnion() const {\n    return const_cast<InitListExpr *>(this)->getInitializedFieldInUnion();\n  }\n  void setInitializedFieldInUnion(FieldDecl *FD) {\n    assert((FD == nullptr\n            || getInitializedFieldInUnion() == nullptr\n            || getInitializedFieldInUnion() == FD)\n           && \"Only one field of a union may be initialized at a time!\");\n    ArrayFillerOrUnionFieldInit = FD;\n  }\n\n  // Explicit InitListExpr's originate from source code (and have valid source\n  // locations). Implicit InitListExpr's are created by the semantic analyzer.\n  // FIXME: This is wrong; InitListExprs created by semantic analysis have\n  // valid source locations too!\n  bool isExplicit() const {\n    return LBraceLoc.isValid() && RBraceLoc.isValid();\n  }\n\n  // Is this an initializer for an array of characters, initialized by a string\n  // literal or an @encode?\n  bool isStringLiteralInit() const;\n\n  /// Is this a transparent initializer list (that is, an InitListExpr that is\n  /// purely syntactic, and whose semantics are that of the sole contained\n  /// initializer)?\n  bool isTransparent() const;\n\n  /// Is this the zero initializer {0} in a language which considers it\n  /// idiomatic?\n  bool isIdiomaticZeroInitializer(const LangOptions &LangOpts) const;\n\n  SourceLocation getLBraceLoc() const { return LBraceLoc; }\n  void setLBraceLoc(SourceLocation Loc) { LBraceLoc = Loc; }\n  SourceLocation getRBraceLoc() const { return RBraceLoc; }\n  void setRBraceLoc(SourceLocation Loc) { RBraceLoc = Loc; }\n\n  bool isSemanticForm() const { return AltForm.getInt(); }\n  InitListExpr *getSemanticForm() const {\n    return isSemanticForm() ? nullptr : AltForm.getPointer();\n  }\n  bool isSyntacticForm() const {\n    return !AltForm.getInt() || !AltForm.getPointer();\n  }\n  InitListExpr *getSyntacticForm() const {\n    return isSemanticForm() ? AltForm.getPointer() : nullptr;\n  }\n\n  void setSyntacticForm(InitListExpr *Init) {\n    AltForm.setPointer(Init);\n    AltForm.setInt(true);\n    Init->AltForm.setPointer(this);\n    Init->AltForm.setInt(false);\n  }\n\n  bool hadArrayRangeDesignator() const {\n    return InitListExprBits.HadArrayRangeDesignator != 0;\n  }\n  void sawArrayRangeDesignator(bool ARD = true) {\n    InitListExprBits.HadArrayRangeDesignator = ARD;\n  }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY;\n  SourceLocation getEndLoc() const LLVM_READONLY;\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == InitListExprClass;\n  }\n\n  // Iterators\n  child_range children() {\n    const_child_range CCR = const_cast<const InitListExpr *>(this)->children();\n    return child_range(cast_away_const(CCR.begin()),\n                       cast_away_const(CCR.end()));\n  }\n\n  const_child_range children() const {\n    // FIXME: This does not include the array filler expression.\n    if (InitExprs.empty())\n      return const_child_range(const_child_iterator(), const_child_iterator());\n    return const_child_range(&InitExprs[0], &InitExprs[0] + InitExprs.size());\n  }\n\n  typedef InitExprsTy::iterator iterator;\n  typedef InitExprsTy::const_iterator const_iterator;\n  typedef InitExprsTy::reverse_iterator reverse_iterator;\n  typedef InitExprsTy::const_reverse_iterator const_reverse_iterator;\n\n  iterator begin() { return InitExprs.begin(); }\n  const_iterator begin() const { return InitExprs.begin(); }\n  iterator end() { return InitExprs.end(); }\n  const_iterator end() const { return InitExprs.end(); }\n  reverse_iterator rbegin() { return InitExprs.rbegin(); }\n  const_reverse_iterator rbegin() const { return InitExprs.rbegin(); }\n  reverse_iterator rend() { return InitExprs.rend(); }\n  const_reverse_iterator rend() const { return InitExprs.rend(); }\n\n  friend class ASTStmtReader;\n  friend class ASTStmtWriter;\n};\n\n/// Represents a C99 designated initializer expression.\n///\n/// A designated initializer expression (C99 6.7.8) contains one or\n/// more designators (which can be field designators, array\n/// designators, or GNU array-range designators) followed by an\n/// expression that initializes the field or element(s) that the\n/// designators refer to. For example, given:\n///\n/// @code\n/// struct point {\n///   double x;\n///   double y;\n/// };\n/// struct point ptarray[10] = { [2].y = 1.0, [2].x = 2.0, [0].x = 1.0 };\n/// @endcode\n///\n/// The InitListExpr contains three DesignatedInitExprs, the first of\n/// which covers @c [2].y=1.0. This DesignatedInitExpr will have two\n/// designators, one array designator for @c [2] followed by one field\n/// designator for @c .y. The initialization expression will be 1.0.\nclass DesignatedInitExpr final\n    : public Expr,\n      private llvm::TrailingObjects<DesignatedInitExpr, Stmt *> {\npublic:\n  /// Forward declaration of the Designator class.\n  class Designator;\n\nprivate:\n  /// The location of the '=' or ':' prior to the actual initializer\n  /// expression.\n  SourceLocation EqualOrColonLoc;\n\n  /// Whether this designated initializer used the GNU deprecated\n  /// syntax rather than the C99 '=' syntax.\n  unsigned GNUSyntax : 1;\n\n  /// The number of designators in this initializer expression.\n  unsigned NumDesignators : 15;\n\n  /// The number of subexpressions of this initializer expression,\n  /// which contains both the initializer and any additional\n  /// expressions used by array and array-range designators.\n  unsigned NumSubExprs : 16;\n\n  /// The designators in this designated initialization\n  /// expression.\n  Designator *Designators;\n\n  DesignatedInitExpr(const ASTContext &C, QualType Ty,\n                     llvm::ArrayRef<Designator> Designators,\n                     SourceLocation EqualOrColonLoc, bool GNUSyntax,\n                     ArrayRef<Expr *> IndexExprs, Expr *Init);\n\n  explicit DesignatedInitExpr(unsigned NumSubExprs)\n    : Expr(DesignatedInitExprClass, EmptyShell()),\n      NumDesignators(0), NumSubExprs(NumSubExprs), Designators(nullptr) { }\n\npublic:\n  /// A field designator, e.g., \".x\".\n  struct FieldDesignator {\n    /// Refers to the field that is being initialized. The low bit\n    /// of this field determines whether this is actually a pointer\n    /// to an IdentifierInfo (if 1) or a FieldDecl (if 0). When\n    /// initially constructed, a field designator will store an\n    /// IdentifierInfo*. After semantic analysis has resolved that\n    /// name, the field designator will instead store a FieldDecl*.\n    uintptr_t NameOrField;\n\n    /// The location of the '.' in the designated initializer.\n    SourceLocation DotLoc;\n\n    /// The location of the field name in the designated initializer.\n    SourceLocation FieldLoc;\n  };\n\n  /// An array or GNU array-range designator, e.g., \"[9]\" or \"[10..15]\".\n  struct ArrayOrRangeDesignator {\n    /// Location of the first index expression within the designated\n    /// initializer expression's list of subexpressions.\n    unsigned Index;\n    /// The location of the '[' starting the array range designator.\n    SourceLocation LBracketLoc;\n    /// The location of the ellipsis separating the start and end\n    /// indices. Only valid for GNU array-range designators.\n    SourceLocation EllipsisLoc;\n    /// The location of the ']' terminating the array range designator.\n    SourceLocation RBracketLoc;\n  };\n\n  /// Represents a single C99 designator.\n  ///\n  /// @todo This class is infuriatingly similar to clang::Designator,\n  /// but minor differences (storing indices vs. storing pointers)\n  /// keep us from reusing it. Try harder, later, to rectify these\n  /// differences.\n  class Designator {\n    /// The kind of designator this describes.\n    enum {\n      FieldDesignator,\n      ArrayDesignator,\n      ArrayRangeDesignator\n    } Kind;\n\n    union {\n      /// A field designator, e.g., \".x\".\n      struct FieldDesignator Field;\n      /// An array or GNU array-range designator, e.g., \"[9]\" or \"[10..15]\".\n      struct ArrayOrRangeDesignator ArrayOrRange;\n    };\n    friend class DesignatedInitExpr;\n\n  public:\n    Designator() {}\n\n    /// Initializes a field designator.\n    Designator(const IdentifierInfo *FieldName, SourceLocation DotLoc,\n               SourceLocation FieldLoc)\n      : Kind(FieldDesignator) {\n      new (&Field) DesignatedInitExpr::FieldDesignator;\n      Field.NameOrField = reinterpret_cast<uintptr_t>(FieldName) | 0x01;\n      Field.DotLoc = DotLoc;\n      Field.FieldLoc = FieldLoc;\n    }\n\n    /// Initializes an array designator.\n    Designator(unsigned Index, SourceLocation LBracketLoc,\n               SourceLocation RBracketLoc)\n      : Kind(ArrayDesignator) {\n      new (&ArrayOrRange) DesignatedInitExpr::ArrayOrRangeDesignator;\n      ArrayOrRange.Index = Index;\n      ArrayOrRange.LBracketLoc = LBracketLoc;\n      ArrayOrRange.EllipsisLoc = SourceLocation();\n      ArrayOrRange.RBracketLoc = RBracketLoc;\n    }\n\n    /// Initializes a GNU array-range designator.\n    Designator(unsigned Index, SourceLocation LBracketLoc,\n               SourceLocation EllipsisLoc, SourceLocation RBracketLoc)\n      : Kind(ArrayRangeDesignator) {\n      new (&ArrayOrRange) DesignatedInitExpr::ArrayOrRangeDesignator;\n      ArrayOrRange.Index = Index;\n      ArrayOrRange.LBracketLoc = LBracketLoc;\n      ArrayOrRange.EllipsisLoc = EllipsisLoc;\n      ArrayOrRange.RBracketLoc = RBracketLoc;\n    }\n\n    bool isFieldDesignator() const { return Kind == FieldDesignator; }\n    bool isArrayDesignator() const { return Kind == ArrayDesignator; }\n    bool isArrayRangeDesignator() const { return Kind == ArrayRangeDesignator; }\n\n    IdentifierInfo *getFieldName() const;\n\n    FieldDecl *getField() const {\n      assert(Kind == FieldDesignator && \"Only valid on a field designator\");\n      if (Field.NameOrField & 0x01)\n        return nullptr;\n      else\n        return reinterpret_cast<FieldDecl *>(Field.NameOrField);\n    }\n\n    void setField(FieldDecl *FD) {\n      assert(Kind == FieldDesignator && \"Only valid on a field designator\");\n      Field.NameOrField = reinterpret_cast<uintptr_t>(FD);\n    }\n\n    SourceLocation getDotLoc() const {\n      assert(Kind == FieldDesignator && \"Only valid on a field designator\");\n      return Field.DotLoc;\n    }\n\n    SourceLocation getFieldLoc() const {\n      assert(Kind == FieldDesignator && \"Only valid on a field designator\");\n      return Field.FieldLoc;\n    }\n\n    SourceLocation getLBracketLoc() const {\n      assert((Kind == ArrayDesignator || Kind == ArrayRangeDesignator) &&\n             \"Only valid on an array or array-range designator\");\n      return ArrayOrRange.LBracketLoc;\n    }\n\n    SourceLocation getRBracketLoc() const {\n      assert((Kind == ArrayDesignator || Kind == ArrayRangeDesignator) &&\n             \"Only valid on an array or array-range designator\");\n      return ArrayOrRange.RBracketLoc;\n    }\n\n    SourceLocation getEllipsisLoc() const {\n      assert(Kind == ArrayRangeDesignator &&\n             \"Only valid on an array-range designator\");\n      return ArrayOrRange.EllipsisLoc;\n    }\n\n    unsigned getFirstExprIndex() const {\n      assert((Kind == ArrayDesignator || Kind == ArrayRangeDesignator) &&\n             \"Only valid on an array or array-range designator\");\n      return ArrayOrRange.Index;\n    }\n\n    SourceLocation getBeginLoc() const LLVM_READONLY {\n      if (Kind == FieldDesignator)\n        return getDotLoc().isInvalid()? getFieldLoc() : getDotLoc();\n      else\n        return getLBracketLoc();\n    }\n    SourceLocation getEndLoc() const LLVM_READONLY {\n      return Kind == FieldDesignator ? getFieldLoc() : getRBracketLoc();\n    }\n    SourceRange getSourceRange() const LLVM_READONLY {\n      return SourceRange(getBeginLoc(), getEndLoc());\n    }\n  };\n\n  static DesignatedInitExpr *Create(const ASTContext &C,\n                                    llvm::ArrayRef<Designator> Designators,\n                                    ArrayRef<Expr*> IndexExprs,\n                                    SourceLocation EqualOrColonLoc,\n                                    bool GNUSyntax, Expr *Init);\n\n  static DesignatedInitExpr *CreateEmpty(const ASTContext &C,\n                                         unsigned NumIndexExprs);\n\n  /// Returns the number of designators in this initializer.\n  unsigned size() const { return NumDesignators; }\n\n  // Iterator access to the designators.\n  llvm::MutableArrayRef<Designator> designators() {\n    return {Designators, NumDesignators};\n  }\n\n  llvm::ArrayRef<Designator> designators() const {\n    return {Designators, NumDesignators};\n  }\n\n  Designator *getDesignator(unsigned Idx) { return &designators()[Idx]; }\n  const Designator *getDesignator(unsigned Idx) const {\n    return &designators()[Idx];\n  }\n\n  void setDesignators(const ASTContext &C, const Designator *Desigs,\n                      unsigned NumDesigs);\n\n  Expr *getArrayIndex(const Designator &D) const;\n  Expr *getArrayRangeStart(const Designator &D) const;\n  Expr *getArrayRangeEnd(const Designator &D) const;\n\n  /// Retrieve the location of the '=' that precedes the\n  /// initializer value itself, if present.\n  SourceLocation getEqualOrColonLoc() const { return EqualOrColonLoc; }\n  void setEqualOrColonLoc(SourceLocation L) { EqualOrColonLoc = L; }\n\n  /// Whether this designated initializer should result in direct-initialization\n  /// of the designated subobject (eg, '{.foo{1, 2, 3}}').\n  bool isDirectInit() const { return EqualOrColonLoc.isInvalid(); }\n\n  /// Determines whether this designated initializer used the\n  /// deprecated GNU syntax for designated initializers.\n  bool usesGNUSyntax() const { return GNUSyntax; }\n  void setGNUSyntax(bool GNU) { GNUSyntax = GNU; }\n\n  /// Retrieve the initializer value.\n  Expr *getInit() const {\n    return cast<Expr>(*const_cast<DesignatedInitExpr*>(this)->child_begin());\n  }\n\n  void setInit(Expr *init) {\n    *child_begin() = init;\n  }\n\n  /// Retrieve the total number of subexpressions in this\n  /// designated initializer expression, including the actual\n  /// initialized value and any expressions that occur within array\n  /// and array-range designators.\n  unsigned getNumSubExprs() const { return NumSubExprs; }\n\n  Expr *getSubExpr(unsigned Idx) const {\n    assert(Idx < NumSubExprs && \"Subscript out of range\");\n    return cast<Expr>(getTrailingObjects<Stmt *>()[Idx]);\n  }\n\n  void setSubExpr(unsigned Idx, Expr *E) {\n    assert(Idx < NumSubExprs && \"Subscript out of range\");\n    getTrailingObjects<Stmt *>()[Idx] = E;\n  }\n\n  /// Replaces the designator at index @p Idx with the series\n  /// of designators in [First, Last).\n  void ExpandDesignator(const ASTContext &C, unsigned Idx,\n                        const Designator *First, const Designator *Last);\n\n  SourceRange getDesignatorsSourceRange() const;\n\n  SourceLocation getBeginLoc() const LLVM_READONLY;\n  SourceLocation getEndLoc() const LLVM_READONLY;\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == DesignatedInitExprClass;\n  }\n\n  // Iterators\n  child_range children() {\n    Stmt **begin = getTrailingObjects<Stmt *>();\n    return child_range(begin, begin + NumSubExprs);\n  }\n  const_child_range children() const {\n    Stmt * const *begin = getTrailingObjects<Stmt *>();\n    return const_child_range(begin, begin + NumSubExprs);\n  }\n\n  friend TrailingObjects;\n};\n\n/// Represents a place-holder for an object not to be initialized by\n/// anything.\n///\n/// This only makes sense when it appears as part of an updater of a\n/// DesignatedInitUpdateExpr (see below). The base expression of a DIUE\n/// initializes a big object, and the NoInitExpr's mark the spots within the\n/// big object not to be overwritten by the updater.\n///\n/// \\see DesignatedInitUpdateExpr\nclass NoInitExpr : public Expr {\npublic:\n  explicit NoInitExpr(QualType ty)\n      : Expr(NoInitExprClass, ty, VK_RValue, OK_Ordinary) {\n    setDependence(computeDependence(this));\n  }\n\n  explicit NoInitExpr(EmptyShell Empty)\n    : Expr(NoInitExprClass, Empty) { }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == NoInitExprClass;\n  }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY { return SourceLocation(); }\n  SourceLocation getEndLoc() const LLVM_READONLY { return SourceLocation(); }\n\n  // Iterators\n  child_range children() {\n    return child_range(child_iterator(), child_iterator());\n  }\n  const_child_range children() const {\n    return const_child_range(const_child_iterator(), const_child_iterator());\n  }\n};\n\n// In cases like:\n//   struct Q { int a, b, c; };\n//   Q *getQ();\n//   void foo() {\n//     struct A { Q q; } a = { *getQ(), .q.b = 3 };\n//   }\n//\n// We will have an InitListExpr for a, with type A, and then a\n// DesignatedInitUpdateExpr for \"a.q\" with type Q. The \"base\" for this DIUE\n// is the call expression *getQ(); the \"updater\" for the DIUE is \".q.b = 3\"\n//\nclass DesignatedInitUpdateExpr : public Expr {\n  // BaseAndUpdaterExprs[0] is the base expression;\n  // BaseAndUpdaterExprs[1] is an InitListExpr overwriting part of the base.\n  Stmt *BaseAndUpdaterExprs[2];\n\npublic:\n  DesignatedInitUpdateExpr(const ASTContext &C, SourceLocation lBraceLoc,\n                           Expr *baseExprs, SourceLocation rBraceLoc);\n\n  explicit DesignatedInitUpdateExpr(EmptyShell Empty)\n    : Expr(DesignatedInitUpdateExprClass, Empty) { }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY;\n  SourceLocation getEndLoc() const LLVM_READONLY;\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == DesignatedInitUpdateExprClass;\n  }\n\n  Expr *getBase() const { return cast<Expr>(BaseAndUpdaterExprs[0]); }\n  void setBase(Expr *Base) { BaseAndUpdaterExprs[0] = Base; }\n\n  InitListExpr *getUpdater() const {\n    return cast<InitListExpr>(BaseAndUpdaterExprs[1]);\n  }\n  void setUpdater(Expr *Updater) { BaseAndUpdaterExprs[1] = Updater; }\n\n  // Iterators\n  // children = the base and the updater\n  child_range children() {\n    return child_range(&BaseAndUpdaterExprs[0], &BaseAndUpdaterExprs[0] + 2);\n  }\n  const_child_range children() const {\n    return const_child_range(&BaseAndUpdaterExprs[0],\n                             &BaseAndUpdaterExprs[0] + 2);\n  }\n};\n\n/// Represents a loop initializing the elements of an array.\n///\n/// The need to initialize the elements of an array occurs in a number of\n/// contexts:\n///\n///  * in the implicit copy/move constructor for a class with an array member\n///  * when a lambda-expression captures an array by value\n///  * when a decomposition declaration decomposes an array\n///\n/// There are two subexpressions: a common expression (the source array)\n/// that is evaluated once up-front, and a per-element initializer that\n/// runs once for each array element.\n///\n/// Within the per-element initializer, the common expression may be referenced\n/// via an OpaqueValueExpr, and the current index may be obtained via an\n/// ArrayInitIndexExpr.\nclass ArrayInitLoopExpr : public Expr {\n  Stmt *SubExprs[2];\n\n  explicit ArrayInitLoopExpr(EmptyShell Empty)\n      : Expr(ArrayInitLoopExprClass, Empty), SubExprs{} {}\n\npublic:\n  explicit ArrayInitLoopExpr(QualType T, Expr *CommonInit, Expr *ElementInit)\n      : Expr(ArrayInitLoopExprClass, T, VK_RValue, OK_Ordinary),\n        SubExprs{CommonInit, ElementInit} {\n    setDependence(computeDependence(this));\n  }\n\n  /// Get the common subexpression shared by all initializations (the source\n  /// array).\n  OpaqueValueExpr *getCommonExpr() const {\n    return cast<OpaqueValueExpr>(SubExprs[0]);\n  }\n\n  /// Get the initializer to use for each array element.\n  Expr *getSubExpr() const { return cast<Expr>(SubExprs[1]); }\n\n  llvm::APInt getArraySize() const {\n    return cast<ConstantArrayType>(getType()->castAsArrayTypeUnsafe())\n        ->getSize();\n  }\n\n  static bool classof(const Stmt *S) {\n    return S->getStmtClass() == ArrayInitLoopExprClass;\n  }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY {\n    return getCommonExpr()->getBeginLoc();\n  }\n  SourceLocation getEndLoc() const LLVM_READONLY {\n    return getCommonExpr()->getEndLoc();\n  }\n\n  child_range children() {\n    return child_range(SubExprs, SubExprs + 2);\n  }\n  const_child_range children() const {\n    return const_child_range(SubExprs, SubExprs + 2);\n  }\n\n  friend class ASTReader;\n  friend class ASTStmtReader;\n  friend class ASTStmtWriter;\n};\n\n/// Represents the index of the current element of an array being\n/// initialized by an ArrayInitLoopExpr. This can only appear within the\n/// subexpression of an ArrayInitLoopExpr.\nclass ArrayInitIndexExpr : public Expr {\n  explicit ArrayInitIndexExpr(EmptyShell Empty)\n      : Expr(ArrayInitIndexExprClass, Empty) {}\n\npublic:\n  explicit ArrayInitIndexExpr(QualType T)\n      : Expr(ArrayInitIndexExprClass, T, VK_RValue, OK_Ordinary) {\n    setDependence(ExprDependence::None);\n  }\n\n  static bool classof(const Stmt *S) {\n    return S->getStmtClass() == ArrayInitIndexExprClass;\n  }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY { return SourceLocation(); }\n  SourceLocation getEndLoc() const LLVM_READONLY { return SourceLocation(); }\n\n  child_range children() {\n    return child_range(child_iterator(), child_iterator());\n  }\n  const_child_range children() const {\n    return const_child_range(const_child_iterator(), const_child_iterator());\n  }\n\n  friend class ASTReader;\n  friend class ASTStmtReader;\n};\n\n/// Represents an implicitly-generated value initialization of\n/// an object of a given type.\n///\n/// Implicit value initializations occur within semantic initializer\n/// list expressions (InitListExpr) as placeholders for subobject\n/// initializations not explicitly specified by the user.\n///\n/// \\see InitListExpr\nclass ImplicitValueInitExpr : public Expr {\npublic:\n  explicit ImplicitValueInitExpr(QualType ty)\n      : Expr(ImplicitValueInitExprClass, ty, VK_RValue, OK_Ordinary) {\n    setDependence(computeDependence(this));\n  }\n\n  /// Construct an empty implicit value initialization.\n  explicit ImplicitValueInitExpr(EmptyShell Empty)\n    : Expr(ImplicitValueInitExprClass, Empty) { }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == ImplicitValueInitExprClass;\n  }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY { return SourceLocation(); }\n  SourceLocation getEndLoc() const LLVM_READONLY { return SourceLocation(); }\n\n  // Iterators\n  child_range children() {\n    return child_range(child_iterator(), child_iterator());\n  }\n  const_child_range children() const {\n    return const_child_range(const_child_iterator(), const_child_iterator());\n  }\n};\n\nclass ParenListExpr final\n    : public Expr,\n      private llvm::TrailingObjects<ParenListExpr, Stmt *> {\n  friend class ASTStmtReader;\n  friend TrailingObjects;\n\n  /// The location of the left and right parentheses.\n  SourceLocation LParenLoc, RParenLoc;\n\n  /// Build a paren list.\n  ParenListExpr(SourceLocation LParenLoc, ArrayRef<Expr *> Exprs,\n                SourceLocation RParenLoc);\n\n  /// Build an empty paren list.\n  ParenListExpr(EmptyShell Empty, unsigned NumExprs);\n\npublic:\n  /// Create a paren list.\n  static ParenListExpr *Create(const ASTContext &Ctx, SourceLocation LParenLoc,\n                               ArrayRef<Expr *> Exprs,\n                               SourceLocation RParenLoc);\n\n  /// Create an empty paren list.\n  static ParenListExpr *CreateEmpty(const ASTContext &Ctx, unsigned NumExprs);\n\n  /// Return the number of expressions in this paren list.\n  unsigned getNumExprs() const { return ParenListExprBits.NumExprs; }\n\n  Expr *getExpr(unsigned Init) {\n    assert(Init < getNumExprs() && \"Initializer access out of range!\");\n    return getExprs()[Init];\n  }\n\n  const Expr *getExpr(unsigned Init) const {\n    return const_cast<ParenListExpr *>(this)->getExpr(Init);\n  }\n\n  Expr **getExprs() {\n    return reinterpret_cast<Expr **>(getTrailingObjects<Stmt *>());\n  }\n\n  ArrayRef<Expr *> exprs() {\n    return llvm::makeArrayRef(getExprs(), getNumExprs());\n  }\n\n  SourceLocation getLParenLoc() const { return LParenLoc; }\n  SourceLocation getRParenLoc() const { return RParenLoc; }\n  SourceLocation getBeginLoc() const { return getLParenLoc(); }\n  SourceLocation getEndLoc() const { return getRParenLoc(); }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == ParenListExprClass;\n  }\n\n  // Iterators\n  child_range children() {\n    return child_range(getTrailingObjects<Stmt *>(),\n                       getTrailingObjects<Stmt *>() + getNumExprs());\n  }\n  const_child_range children() const {\n    return const_child_range(getTrailingObjects<Stmt *>(),\n                             getTrailingObjects<Stmt *>() + getNumExprs());\n  }\n};\n\n/// Represents a C11 generic selection.\n///\n/// A generic selection (C11 6.5.1.1) contains an unevaluated controlling\n/// expression, followed by one or more generic associations.  Each generic\n/// association specifies a type name and an expression, or \"default\" and an\n/// expression (in which case it is known as a default generic association).\n/// The type and value of the generic selection are identical to those of its\n/// result expression, which is defined as the expression in the generic\n/// association with a type name that is compatible with the type of the\n/// controlling expression, or the expression in the default generic association\n/// if no types are compatible.  For example:\n///\n/// @code\n/// _Generic(X, double: 1, float: 2, default: 3)\n/// @endcode\n///\n/// The above expression evaluates to 1 if 1.0 is substituted for X, 2 if 1.0f\n/// or 3 if \"hello\".\n///\n/// As an extension, generic selections are allowed in C++, where the following\n/// additional semantics apply:\n///\n/// Any generic selection whose controlling expression is type-dependent or\n/// which names a dependent type in its association list is result-dependent,\n/// which means that the choice of result expression is dependent.\n/// Result-dependent generic associations are both type- and value-dependent.\nclass GenericSelectionExpr final\n    : public Expr,\n      private llvm::TrailingObjects<GenericSelectionExpr, Stmt *,\n                                    TypeSourceInfo *> {\n  friend class ASTStmtReader;\n  friend class ASTStmtWriter;\n  friend TrailingObjects;\n\n  /// The number of association expressions and the index of the result\n  /// expression in the case where the generic selection expression is not\n  /// result-dependent. The result index is equal to ResultDependentIndex\n  /// if and only if the generic selection expression is result-dependent.\n  unsigned NumAssocs, ResultIndex;\n  enum : unsigned {\n    ResultDependentIndex = std::numeric_limits<unsigned>::max(),\n    ControllingIndex = 0,\n    AssocExprStartIndex = 1\n  };\n\n  /// The location of the \"default\" and of the right parenthesis.\n  SourceLocation DefaultLoc, RParenLoc;\n\n  // GenericSelectionExpr is followed by several trailing objects.\n  // They are (in order):\n  //\n  // * A single Stmt * for the controlling expression.\n  // * An array of getNumAssocs() Stmt * for the association expressions.\n  // * An array of getNumAssocs() TypeSourceInfo *, one for each of the\n  //   association expressions.\n  unsigned numTrailingObjects(OverloadToken<Stmt *>) const {\n    // Add one to account for the controlling expression; the remainder\n    // are the associated expressions.\n    return 1 + getNumAssocs();\n  }\n\n  unsigned numTrailingObjects(OverloadToken<TypeSourceInfo *>) const {\n    return getNumAssocs();\n  }\n\n  template <bool Const> class AssociationIteratorTy;\n  /// Bundle together an association expression and its TypeSourceInfo.\n  /// The Const template parameter is for the const and non-const versions\n  /// of AssociationTy.\n  template <bool Const> class AssociationTy {\n    friend class GenericSelectionExpr;\n    template <bool OtherConst> friend class AssociationIteratorTy;\n    using ExprPtrTy = std::conditional_t<Const, const Expr *, Expr *>;\n    using TSIPtrTy =\n        std::conditional_t<Const, const TypeSourceInfo *, TypeSourceInfo *>;\n    ExprPtrTy E;\n    TSIPtrTy TSI;\n    bool Selected;\n    AssociationTy(ExprPtrTy E, TSIPtrTy TSI, bool Selected)\n        : E(E), TSI(TSI), Selected(Selected) {}\n\n  public:\n    ExprPtrTy getAssociationExpr() const { return E; }\n    TSIPtrTy getTypeSourceInfo() const { return TSI; }\n    QualType getType() const { return TSI ? TSI->getType() : QualType(); }\n    bool isSelected() const { return Selected; }\n    AssociationTy *operator->() { return this; }\n    const AssociationTy *operator->() const { return this; }\n  }; // class AssociationTy\n\n  /// Iterator over const and non-const Association objects. The Association\n  /// objects are created on the fly when the iterator is dereferenced.\n  /// This abstract over how exactly the association expressions and the\n  /// corresponding TypeSourceInfo * are stored.\n  template <bool Const>\n  class AssociationIteratorTy\n      : public llvm::iterator_facade_base<\n            AssociationIteratorTy<Const>, std::input_iterator_tag,\n            AssociationTy<Const>, std::ptrdiff_t, AssociationTy<Const>,\n            AssociationTy<Const>> {\n    friend class GenericSelectionExpr;\n    // FIXME: This iterator could conceptually be a random access iterator, and\n    // it would be nice if we could strengthen the iterator category someday.\n    // However this iterator does not satisfy two requirements of forward\n    // iterators:\n    // a) reference = T& or reference = const T&\n    // b) If It1 and It2 are both dereferenceable, then It1 == It2 if and only\n    //    if *It1 and *It2 are bound to the same objects.\n    // An alternative design approach was discussed during review;\n    // store an Association object inside the iterator, and return a reference\n    // to it when dereferenced. This idea was discarded beacuse of nasty\n    // lifetime issues:\n    //    AssociationIterator It = ...;\n    //    const Association &Assoc = *It++; // Oops, Assoc is dangling.\n    using BaseTy = typename AssociationIteratorTy::iterator_facade_base;\n    using StmtPtrPtrTy =\n        std::conditional_t<Const, const Stmt *const *, Stmt **>;\n    using TSIPtrPtrTy = std::conditional_t<Const, const TypeSourceInfo *const *,\n                                           TypeSourceInfo **>;\n    StmtPtrPtrTy E; // = nullptr; FIXME: Once support for gcc 4.8 is dropped.\n    TSIPtrPtrTy TSI; // Kept in sync with E.\n    unsigned Offset = 0, SelectedOffset = 0;\n    AssociationIteratorTy(StmtPtrPtrTy E, TSIPtrPtrTy TSI, unsigned Offset,\n                          unsigned SelectedOffset)\n        : E(E), TSI(TSI), Offset(Offset), SelectedOffset(SelectedOffset) {}\n\n  public:\n    AssociationIteratorTy() : E(nullptr), TSI(nullptr) {}\n    typename BaseTy::reference operator*() const {\n      return AssociationTy<Const>(cast<Expr>(*E), *TSI,\n                                  Offset == SelectedOffset);\n    }\n    typename BaseTy::pointer operator->() const { return **this; }\n    using BaseTy::operator++;\n    AssociationIteratorTy &operator++() {\n      ++E;\n      ++TSI;\n      ++Offset;\n      return *this;\n    }\n    bool operator==(AssociationIteratorTy Other) const { return E == Other.E; }\n  }; // class AssociationIterator\n\n  /// Build a non-result-dependent generic selection expression.\n  GenericSelectionExpr(const ASTContext &Context, SourceLocation GenericLoc,\n                       Expr *ControllingExpr,\n                       ArrayRef<TypeSourceInfo *> AssocTypes,\n                       ArrayRef<Expr *> AssocExprs, SourceLocation DefaultLoc,\n                       SourceLocation RParenLoc,\n                       bool ContainsUnexpandedParameterPack,\n                       unsigned ResultIndex);\n\n  /// Build a result-dependent generic selection expression.\n  GenericSelectionExpr(const ASTContext &Context, SourceLocation GenericLoc,\n                       Expr *ControllingExpr,\n                       ArrayRef<TypeSourceInfo *> AssocTypes,\n                       ArrayRef<Expr *> AssocExprs, SourceLocation DefaultLoc,\n                       SourceLocation RParenLoc,\n                       bool ContainsUnexpandedParameterPack);\n\n  /// Build an empty generic selection expression for deserialization.\n  explicit GenericSelectionExpr(EmptyShell Empty, unsigned NumAssocs);\n\npublic:\n  /// Create a non-result-dependent generic selection expression.\n  static GenericSelectionExpr *\n  Create(const ASTContext &Context, SourceLocation GenericLoc,\n         Expr *ControllingExpr, ArrayRef<TypeSourceInfo *> AssocTypes,\n         ArrayRef<Expr *> AssocExprs, SourceLocation DefaultLoc,\n         SourceLocation RParenLoc, bool ContainsUnexpandedParameterPack,\n         unsigned ResultIndex);\n\n  /// Create a result-dependent generic selection expression.\n  static GenericSelectionExpr *\n  Create(const ASTContext &Context, SourceLocation GenericLoc,\n         Expr *ControllingExpr, ArrayRef<TypeSourceInfo *> AssocTypes,\n         ArrayRef<Expr *> AssocExprs, SourceLocation DefaultLoc,\n         SourceLocation RParenLoc, bool ContainsUnexpandedParameterPack);\n\n  /// Create an empty generic selection expression for deserialization.\n  static GenericSelectionExpr *CreateEmpty(const ASTContext &Context,\n                                           unsigned NumAssocs);\n\n  using Association = AssociationTy<false>;\n  using ConstAssociation = AssociationTy<true>;\n  using AssociationIterator = AssociationIteratorTy<false>;\n  using ConstAssociationIterator = AssociationIteratorTy<true>;\n  using association_range = llvm::iterator_range<AssociationIterator>;\n  using const_association_range =\n      llvm::iterator_range<ConstAssociationIterator>;\n\n  /// The number of association expressions.\n  unsigned getNumAssocs() const { return NumAssocs; }\n\n  /// The zero-based index of the result expression's generic association in\n  /// the generic selection's association list.  Defined only if the\n  /// generic selection is not result-dependent.\n  unsigned getResultIndex() const {\n    assert(!isResultDependent() &&\n           \"Generic selection is result-dependent but getResultIndex called!\");\n    return ResultIndex;\n  }\n\n  /// Whether this generic selection is result-dependent.\n  bool isResultDependent() const { return ResultIndex == ResultDependentIndex; }\n\n  /// Return the controlling expression of this generic selection expression.\n  Expr *getControllingExpr() {\n    return cast<Expr>(getTrailingObjects<Stmt *>()[ControllingIndex]);\n  }\n  const Expr *getControllingExpr() const {\n    return cast<Expr>(getTrailingObjects<Stmt *>()[ControllingIndex]);\n  }\n\n  /// Return the result expression of this controlling expression. Defined if\n  /// and only if the generic selection expression is not result-dependent.\n  Expr *getResultExpr() {\n    return cast<Expr>(\n        getTrailingObjects<Stmt *>()[AssocExprStartIndex + getResultIndex()]);\n  }\n  const Expr *getResultExpr() const {\n    return cast<Expr>(\n        getTrailingObjects<Stmt *>()[AssocExprStartIndex + getResultIndex()]);\n  }\n\n  ArrayRef<Expr *> getAssocExprs() const {\n    return {reinterpret_cast<Expr *const *>(getTrailingObjects<Stmt *>() +\n                                            AssocExprStartIndex),\n            NumAssocs};\n  }\n  ArrayRef<TypeSourceInfo *> getAssocTypeSourceInfos() const {\n    return {getTrailingObjects<TypeSourceInfo *>(), NumAssocs};\n  }\n\n  /// Return the Ith association expression with its TypeSourceInfo,\n  /// bundled together in GenericSelectionExpr::(Const)Association.\n  Association getAssociation(unsigned I) {\n    assert(I < getNumAssocs() &&\n           \"Out-of-range index in GenericSelectionExpr::getAssociation!\");\n    return Association(\n        cast<Expr>(getTrailingObjects<Stmt *>()[AssocExprStartIndex + I]),\n        getTrailingObjects<TypeSourceInfo *>()[I],\n        !isResultDependent() && (getResultIndex() == I));\n  }\n  ConstAssociation getAssociation(unsigned I) const {\n    assert(I < getNumAssocs() &&\n           \"Out-of-range index in GenericSelectionExpr::getAssociation!\");\n    return ConstAssociation(\n        cast<Expr>(getTrailingObjects<Stmt *>()[AssocExprStartIndex + I]),\n        getTrailingObjects<TypeSourceInfo *>()[I],\n        !isResultDependent() && (getResultIndex() == I));\n  }\n\n  association_range associations() {\n    AssociationIterator Begin(getTrailingObjects<Stmt *>() +\n                                  AssocExprStartIndex,\n                              getTrailingObjects<TypeSourceInfo *>(),\n                              /*Offset=*/0, ResultIndex);\n    AssociationIterator End(Begin.E + NumAssocs, Begin.TSI + NumAssocs,\n                            /*Offset=*/NumAssocs, ResultIndex);\n    return llvm::make_range(Begin, End);\n  }\n\n  const_association_range associations() const {\n    ConstAssociationIterator Begin(getTrailingObjects<Stmt *>() +\n                                       AssocExprStartIndex,\n                                   getTrailingObjects<TypeSourceInfo *>(),\n                                   /*Offset=*/0, ResultIndex);\n    ConstAssociationIterator End(Begin.E + NumAssocs, Begin.TSI + NumAssocs,\n                                 /*Offset=*/NumAssocs, ResultIndex);\n    return llvm::make_range(Begin, End);\n  }\n\n  SourceLocation getGenericLoc() const {\n    return GenericSelectionExprBits.GenericLoc;\n  }\n  SourceLocation getDefaultLoc() const { return DefaultLoc; }\n  SourceLocation getRParenLoc() const { return RParenLoc; }\n  SourceLocation getBeginLoc() const { return getGenericLoc(); }\n  SourceLocation getEndLoc() const { return getRParenLoc(); }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == GenericSelectionExprClass;\n  }\n\n  child_range children() {\n    return child_range(getTrailingObjects<Stmt *>(),\n                       getTrailingObjects<Stmt *>() +\n                           numTrailingObjects(OverloadToken<Stmt *>()));\n  }\n  const_child_range children() const {\n    return const_child_range(getTrailingObjects<Stmt *>(),\n                             getTrailingObjects<Stmt *>() +\n                                 numTrailingObjects(OverloadToken<Stmt *>()));\n  }\n};\n\n//===----------------------------------------------------------------------===//\n// Clang Extensions\n//===----------------------------------------------------------------------===//\n\n/// ExtVectorElementExpr - This represents access to specific elements of a\n/// vector, and may occur on the left hand side or right hand side.  For example\n/// the following is legal:  \"V.xy = V.zw\" if V is a 4 element extended vector.\n///\n/// Note that the base may have either vector or pointer to vector type, just\n/// like a struct field reference.\n///\nclass ExtVectorElementExpr : public Expr {\n  Stmt *Base;\n  IdentifierInfo *Accessor;\n  SourceLocation AccessorLoc;\npublic:\n  ExtVectorElementExpr(QualType ty, ExprValueKind VK, Expr *base,\n                       IdentifierInfo &accessor, SourceLocation loc)\n      : Expr(ExtVectorElementExprClass, ty, VK,\n             (VK == VK_RValue ? OK_Ordinary : OK_VectorComponent)),\n        Base(base), Accessor(&accessor), AccessorLoc(loc) {\n    setDependence(computeDependence(this));\n  }\n\n  /// Build an empty vector element expression.\n  explicit ExtVectorElementExpr(EmptyShell Empty)\n    : Expr(ExtVectorElementExprClass, Empty) { }\n\n  const Expr *getBase() const { return cast<Expr>(Base); }\n  Expr *getBase() { return cast<Expr>(Base); }\n  void setBase(Expr *E) { Base = E; }\n\n  IdentifierInfo &getAccessor() const { return *Accessor; }\n  void setAccessor(IdentifierInfo *II) { Accessor = II; }\n\n  SourceLocation getAccessorLoc() const { return AccessorLoc; }\n  void setAccessorLoc(SourceLocation L) { AccessorLoc = L; }\n\n  /// getNumElements - Get the number of components being selected.\n  unsigned getNumElements() const;\n\n  /// containsDuplicateElements - Return true if any element access is\n  /// repeated.\n  bool containsDuplicateElements() const;\n\n  /// getEncodedElementAccess - Encode the elements accessed into an llvm\n  /// aggregate Constant of ConstantInt(s).\n  void getEncodedElementAccess(SmallVectorImpl<uint32_t> &Elts) const;\n\n  SourceLocation getBeginLoc() const LLVM_READONLY {\n    return getBase()->getBeginLoc();\n  }\n  SourceLocation getEndLoc() const LLVM_READONLY { return AccessorLoc; }\n\n  /// isArrow - Return true if the base expression is a pointer to vector,\n  /// return false if the base expression is a vector.\n  bool isArrow() const;\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == ExtVectorElementExprClass;\n  }\n\n  // Iterators\n  child_range children() { return child_range(&Base, &Base+1); }\n  const_child_range children() const {\n    return const_child_range(&Base, &Base + 1);\n  }\n};\n\n/// BlockExpr - Adaptor class for mixing a BlockDecl with expressions.\n/// ^{ statement-body }   or   ^(int arg1, float arg2){ statement-body }\nclass BlockExpr : public Expr {\nprotected:\n  BlockDecl *TheBlock;\npublic:\n  BlockExpr(BlockDecl *BD, QualType ty)\n      : Expr(BlockExprClass, ty, VK_RValue, OK_Ordinary), TheBlock(BD) {\n    setDependence(computeDependence(this));\n  }\n\n  /// Build an empty block expression.\n  explicit BlockExpr(EmptyShell Empty) : Expr(BlockExprClass, Empty) { }\n\n  const BlockDecl *getBlockDecl() const { return TheBlock; }\n  BlockDecl *getBlockDecl() { return TheBlock; }\n  void setBlockDecl(BlockDecl *BD) { TheBlock = BD; }\n\n  // Convenience functions for probing the underlying BlockDecl.\n  SourceLocation getCaretLocation() const;\n  const Stmt *getBody() const;\n  Stmt *getBody();\n\n  SourceLocation getBeginLoc() const LLVM_READONLY {\n    return getCaretLocation();\n  }\n  SourceLocation getEndLoc() const LLVM_READONLY {\n    return getBody()->getEndLoc();\n  }\n\n  /// getFunctionType - Return the underlying function type for this block.\n  const FunctionProtoType *getFunctionType() const;\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == BlockExprClass;\n  }\n\n  // Iterators\n  child_range children() {\n    return child_range(child_iterator(), child_iterator());\n  }\n  const_child_range children() const {\n    return const_child_range(const_child_iterator(), const_child_iterator());\n  }\n};\n\n/// Copy initialization expr of a __block variable and a boolean flag that\n/// indicates whether the expression can throw.\nstruct BlockVarCopyInit {\n  BlockVarCopyInit() = default;\n  BlockVarCopyInit(Expr *CopyExpr, bool CanThrow)\n      : ExprAndFlag(CopyExpr, CanThrow) {}\n  void setExprAndFlag(Expr *CopyExpr, bool CanThrow) {\n    ExprAndFlag.setPointerAndInt(CopyExpr, CanThrow);\n  }\n  Expr *getCopyExpr() const { return ExprAndFlag.getPointer(); }\n  bool canThrow() const { return ExprAndFlag.getInt(); }\n  llvm::PointerIntPair<Expr *, 1, bool> ExprAndFlag;\n};\n\n/// AsTypeExpr - Clang builtin function __builtin_astype [OpenCL 6.2.4.2]\n/// This AST node provides support for reinterpreting a type to another\n/// type of the same size.\nclass AsTypeExpr : public Expr {\nprivate:\n  Stmt *SrcExpr;\n  SourceLocation BuiltinLoc, RParenLoc;\n\n  friend class ASTReader;\n  friend class ASTStmtReader;\n  explicit AsTypeExpr(EmptyShell Empty) : Expr(AsTypeExprClass, Empty) {}\n\npublic:\n  AsTypeExpr(Expr *SrcExpr, QualType DstType, ExprValueKind VK,\n             ExprObjectKind OK, SourceLocation BuiltinLoc,\n             SourceLocation RParenLoc)\n      : Expr(AsTypeExprClass, DstType, VK, OK), SrcExpr(SrcExpr),\n        BuiltinLoc(BuiltinLoc), RParenLoc(RParenLoc) {\n    setDependence(computeDependence(this));\n  }\n\n  /// getSrcExpr - Return the Expr to be converted.\n  Expr *getSrcExpr() const { return cast<Expr>(SrcExpr); }\n\n  /// getBuiltinLoc - Return the location of the __builtin_astype token.\n  SourceLocation getBuiltinLoc() const { return BuiltinLoc; }\n\n  /// getRParenLoc - Return the location of final right parenthesis.\n  SourceLocation getRParenLoc() const { return RParenLoc; }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY { return BuiltinLoc; }\n  SourceLocation getEndLoc() const LLVM_READONLY { return RParenLoc; }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == AsTypeExprClass;\n  }\n\n  // Iterators\n  child_range children() { return child_range(&SrcExpr, &SrcExpr+1); }\n  const_child_range children() const {\n    return const_child_range(&SrcExpr, &SrcExpr + 1);\n  }\n};\n\n/// PseudoObjectExpr - An expression which accesses a pseudo-object\n/// l-value.  A pseudo-object is an abstract object, accesses to which\n/// are translated to calls.  The pseudo-object expression has a\n/// syntactic form, which shows how the expression was actually\n/// written in the source code, and a semantic form, which is a series\n/// of expressions to be executed in order which detail how the\n/// operation is actually evaluated.  Optionally, one of the semantic\n/// forms may also provide a result value for the expression.\n///\n/// If any of the semantic-form expressions is an OpaqueValueExpr,\n/// that OVE is required to have a source expression, and it is bound\n/// to the result of that source expression.  Such OVEs may appear\n/// only in subsequent semantic-form expressions and as\n/// sub-expressions of the syntactic form.\n///\n/// PseudoObjectExpr should be used only when an operation can be\n/// usefully described in terms of fairly simple rewrite rules on\n/// objects and functions that are meant to be used by end-developers.\n/// For example, under the Itanium ABI, dynamic casts are implemented\n/// as a call to a runtime function called __dynamic_cast; using this\n/// class to describe that would be inappropriate because that call is\n/// not really part of the user-visible semantics, and instead the\n/// cast is properly reflected in the AST and IR-generation has been\n/// taught to generate the call as necessary.  In contrast, an\n/// Objective-C property access is semantically defined to be\n/// equivalent to a particular message send, and this is very much\n/// part of the user model.  The name of this class encourages this\n/// modelling design.\nclass PseudoObjectExpr final\n    : public Expr,\n      private llvm::TrailingObjects<PseudoObjectExpr, Expr *> {\n  // PseudoObjectExprBits.NumSubExprs - The number of sub-expressions.\n  // Always at least two, because the first sub-expression is the\n  // syntactic form.\n\n  // PseudoObjectExprBits.ResultIndex - The index of the\n  // sub-expression holding the result.  0 means the result is void,\n  // which is unambiguous because it's the index of the syntactic\n  // form.  Note that this is therefore 1 higher than the value passed\n  // in to Create, which is an index within the semantic forms.\n  // Note also that ASTStmtWriter assumes this encoding.\n\n  Expr **getSubExprsBuffer() { return getTrailingObjects<Expr *>(); }\n  const Expr * const *getSubExprsBuffer() const {\n    return getTrailingObjects<Expr *>();\n  }\n\n  PseudoObjectExpr(QualType type, ExprValueKind VK,\n                   Expr *syntactic, ArrayRef<Expr*> semantic,\n                   unsigned resultIndex);\n\n  PseudoObjectExpr(EmptyShell shell, unsigned numSemanticExprs);\n\n  unsigned getNumSubExprs() const {\n    return PseudoObjectExprBits.NumSubExprs;\n  }\n\npublic:\n  /// NoResult - A value for the result index indicating that there is\n  /// no semantic result.\n  enum : unsigned { NoResult = ~0U };\n\n  static PseudoObjectExpr *Create(const ASTContext &Context, Expr *syntactic,\n                                  ArrayRef<Expr*> semantic,\n                                  unsigned resultIndex);\n\n  static PseudoObjectExpr *Create(const ASTContext &Context, EmptyShell shell,\n                                  unsigned numSemanticExprs);\n\n  /// Return the syntactic form of this expression, i.e. the\n  /// expression it actually looks like.  Likely to be expressed in\n  /// terms of OpaqueValueExprs bound in the semantic form.\n  Expr *getSyntacticForm() { return getSubExprsBuffer()[0]; }\n  const Expr *getSyntacticForm() const { return getSubExprsBuffer()[0]; }\n\n  /// Return the index of the result-bearing expression into the semantics\n  /// expressions, or PseudoObjectExpr::NoResult if there is none.\n  unsigned getResultExprIndex() const {\n    if (PseudoObjectExprBits.ResultIndex == 0) return NoResult;\n    return PseudoObjectExprBits.ResultIndex - 1;\n  }\n\n  /// Return the result-bearing expression, or null if there is none.\n  Expr *getResultExpr() {\n    if (PseudoObjectExprBits.ResultIndex == 0)\n      return nullptr;\n    return getSubExprsBuffer()[PseudoObjectExprBits.ResultIndex];\n  }\n  const Expr *getResultExpr() const {\n    return const_cast<PseudoObjectExpr*>(this)->getResultExpr();\n  }\n\n  unsigned getNumSemanticExprs() const { return getNumSubExprs() - 1; }\n\n  typedef Expr * const *semantics_iterator;\n  typedef const Expr * const *const_semantics_iterator;\n  semantics_iterator semantics_begin() {\n    return getSubExprsBuffer() + 1;\n  }\n  const_semantics_iterator semantics_begin() const {\n    return getSubExprsBuffer() + 1;\n  }\n  semantics_iterator semantics_end() {\n    return getSubExprsBuffer() + getNumSubExprs();\n  }\n  const_semantics_iterator semantics_end() const {\n    return getSubExprsBuffer() + getNumSubExprs();\n  }\n\n  llvm::iterator_range<semantics_iterator> semantics() {\n    return llvm::make_range(semantics_begin(), semantics_end());\n  }\n  llvm::iterator_range<const_semantics_iterator> semantics() const {\n    return llvm::make_range(semantics_begin(), semantics_end());\n  }\n\n  Expr *getSemanticExpr(unsigned index) {\n    assert(index + 1 < getNumSubExprs());\n    return getSubExprsBuffer()[index + 1];\n  }\n  const Expr *getSemanticExpr(unsigned index) const {\n    return const_cast<PseudoObjectExpr*>(this)->getSemanticExpr(index);\n  }\n\n  SourceLocation getExprLoc() const LLVM_READONLY {\n    return getSyntacticForm()->getExprLoc();\n  }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY {\n    return getSyntacticForm()->getBeginLoc();\n  }\n  SourceLocation getEndLoc() const LLVM_READONLY {\n    return getSyntacticForm()->getEndLoc();\n  }\n\n  child_range children() {\n    const_child_range CCR =\n        const_cast<const PseudoObjectExpr *>(this)->children();\n    return child_range(cast_away_const(CCR.begin()),\n                       cast_away_const(CCR.end()));\n  }\n  const_child_range children() const {\n    Stmt *const *cs = const_cast<Stmt *const *>(\n        reinterpret_cast<const Stmt *const *>(getSubExprsBuffer()));\n    return const_child_range(cs, cs + getNumSubExprs());\n  }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == PseudoObjectExprClass;\n  }\n\n  friend TrailingObjects;\n  friend class ASTStmtReader;\n};\n\n/// AtomicExpr - Variadic atomic builtins: __atomic_exchange, __atomic_fetch_*,\n/// __atomic_load, __atomic_store, and __atomic_compare_exchange_*, for the\n/// similarly-named C++11 instructions, and __c11 variants for <stdatomic.h>,\n/// and corresponding __opencl_atomic_* for OpenCL 2.0.\n/// All of these instructions take one primary pointer, at least one memory\n/// order. The instructions for which getScopeModel returns non-null value\n/// take one synch scope.\nclass AtomicExpr : public Expr {\npublic:\n  enum AtomicOp {\n#define BUILTIN(ID, TYPE, ATTRS)\n#define ATOMIC_BUILTIN(ID, TYPE, ATTRS) AO ## ID,\n#include \"clang/Basic/Builtins.def\"\n    // Avoid trailing comma\n    BI_First = 0\n  };\n\nprivate:\n  /// Location of sub-expressions.\n  /// The location of Scope sub-expression is NumSubExprs - 1, which is\n  /// not fixed, therefore is not defined in enum.\n  enum { PTR, ORDER, VAL1, ORDER_FAIL, VAL2, WEAK, END_EXPR };\n  Stmt *SubExprs[END_EXPR + 1];\n  unsigned NumSubExprs;\n  SourceLocation BuiltinLoc, RParenLoc;\n  AtomicOp Op;\n\n  friend class ASTStmtReader;\npublic:\n  AtomicExpr(SourceLocation BLoc, ArrayRef<Expr*> args, QualType t,\n             AtomicOp op, SourceLocation RP);\n\n  /// Determine the number of arguments the specified atomic builtin\n  /// should have.\n  static unsigned getNumSubExprs(AtomicOp Op);\n\n  /// Build an empty AtomicExpr.\n  explicit AtomicExpr(EmptyShell Empty) : Expr(AtomicExprClass, Empty) { }\n\n  Expr *getPtr() const {\n    return cast<Expr>(SubExprs[PTR]);\n  }\n  Expr *getOrder() const {\n    return cast<Expr>(SubExprs[ORDER]);\n  }\n  Expr *getScope() const {\n    assert(getScopeModel() && \"No scope\");\n    return cast<Expr>(SubExprs[NumSubExprs - 1]);\n  }\n  Expr *getVal1() const {\n    if (Op == AO__c11_atomic_init || Op == AO__opencl_atomic_init)\n      return cast<Expr>(SubExprs[ORDER]);\n    assert(NumSubExprs > VAL1);\n    return cast<Expr>(SubExprs[VAL1]);\n  }\n  Expr *getOrderFail() const {\n    assert(NumSubExprs > ORDER_FAIL);\n    return cast<Expr>(SubExprs[ORDER_FAIL]);\n  }\n  Expr *getVal2() const {\n    if (Op == AO__atomic_exchange)\n      return cast<Expr>(SubExprs[ORDER_FAIL]);\n    assert(NumSubExprs > VAL2);\n    return cast<Expr>(SubExprs[VAL2]);\n  }\n  Expr *getWeak() const {\n    assert(NumSubExprs > WEAK);\n    return cast<Expr>(SubExprs[WEAK]);\n  }\n  QualType getValueType() const;\n\n  AtomicOp getOp() const { return Op; }\n  unsigned getNumSubExprs() const { return NumSubExprs; }\n\n  Expr **getSubExprs() { return reinterpret_cast<Expr **>(SubExprs); }\n  const Expr * const *getSubExprs() const {\n    return reinterpret_cast<Expr * const *>(SubExprs);\n  }\n\n  bool isVolatile() const {\n    return getPtr()->getType()->getPointeeType().isVolatileQualified();\n  }\n\n  bool isCmpXChg() const {\n    return getOp() == AO__c11_atomic_compare_exchange_strong ||\n           getOp() == AO__c11_atomic_compare_exchange_weak ||\n           getOp() == AO__opencl_atomic_compare_exchange_strong ||\n           getOp() == AO__opencl_atomic_compare_exchange_weak ||\n           getOp() == AO__atomic_compare_exchange ||\n           getOp() == AO__atomic_compare_exchange_n;\n  }\n\n  bool isOpenCL() const {\n    return getOp() >= AO__opencl_atomic_init &&\n           getOp() <= AO__opencl_atomic_fetch_max;\n  }\n\n  SourceLocation getBuiltinLoc() const { return BuiltinLoc; }\n  SourceLocation getRParenLoc() const { return RParenLoc; }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY { return BuiltinLoc; }\n  SourceLocation getEndLoc() const LLVM_READONLY { return RParenLoc; }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == AtomicExprClass;\n  }\n\n  // Iterators\n  child_range children() {\n    return child_range(SubExprs, SubExprs+NumSubExprs);\n  }\n  const_child_range children() const {\n    return const_child_range(SubExprs, SubExprs + NumSubExprs);\n  }\n\n  /// Get atomic scope model for the atomic op code.\n  /// \\return empty atomic scope model if the atomic op code does not have\n  ///   scope operand.\n  static std::unique_ptr<AtomicScopeModel> getScopeModel(AtomicOp Op) {\n    auto Kind =\n        (Op >= AO__opencl_atomic_load && Op <= AO__opencl_atomic_fetch_max)\n            ? AtomicScopeModelKind::OpenCL\n            : AtomicScopeModelKind::None;\n    return AtomicScopeModel::create(Kind);\n  }\n\n  /// Get atomic scope model.\n  /// \\return empty atomic scope model if this atomic expression does not have\n  ///   scope operand.\n  std::unique_ptr<AtomicScopeModel> getScopeModel() const {\n    return getScopeModel(getOp());\n  }\n};\n\n/// TypoExpr - Internal placeholder for expressions where typo correction\n/// still needs to be performed and/or an error diagnostic emitted.\nclass TypoExpr : public Expr {\n  // The location for the typo name.\n  SourceLocation TypoLoc;\n\npublic:\n  TypoExpr(QualType T, SourceLocation TypoLoc)\n      : Expr(TypoExprClass, T, VK_LValue, OK_Ordinary), TypoLoc(TypoLoc) {\n    assert(T->isDependentType() && \"TypoExpr given a non-dependent type\");\n    setDependence(ExprDependence::TypeValueInstantiation |\n                  ExprDependence::Error);\n  }\n\n  child_range children() {\n    return child_range(child_iterator(), child_iterator());\n  }\n  const_child_range children() const {\n    return const_child_range(const_child_iterator(), const_child_iterator());\n  }\n\n  SourceLocation getBeginLoc() const LLVM_READONLY { return TypoLoc; }\n  SourceLocation getEndLoc() const LLVM_READONLY { return TypoLoc; }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == TypoExprClass;\n  }\n\n};\n\n/// Frontend produces RecoveryExprs on semantic errors that prevent creating\n/// other well-formed expressions. E.g. when type-checking of a binary operator\n/// fails, we cannot produce a BinaryOperator expression. Instead, we can choose\n/// to produce a recovery expression storing left and right operands.\n///\n/// RecoveryExpr does not have any semantic meaning in C++, it is only useful to\n/// preserve expressions in AST that would otherwise be dropped. It captures\n/// subexpressions of some expression that we could not construct and source\n/// range covered by the expression.\n///\n/// By default, RecoveryExpr uses dependence-bits to take advantage of existing\n/// machinery to deal with dependent code in C++, e.g. RecoveryExpr is preserved\n/// in `decltype(<broken-expr>)` as part of the `DependentDecltypeType`. In\n/// addition to that, clang does not report most errors on dependent\n/// expressions, so we get rid of bogus errors for free. However, note that\n/// unlike other dependent expressions, RecoveryExpr can be produced in\n/// non-template contexts.\n///\n/// We will preserve the type in RecoveryExpr when the type is known, e.g.\n/// preserving the return type for a broken non-overloaded function call, a\n/// overloaded call where all candidates have the same return type. In this\n/// case, the expression is not type-dependent (unless the known type is itself\n/// dependent)\n///\n/// One can also reliably suppress all bogus errors on expressions containing\n/// recovery expressions by examining results of Expr::containsErrors().\nclass RecoveryExpr final : public Expr,\n                           private llvm::TrailingObjects<RecoveryExpr, Expr *> {\npublic:\n  static RecoveryExpr *Create(ASTContext &Ctx, QualType T,\n                              SourceLocation BeginLoc, SourceLocation EndLoc,\n                              ArrayRef<Expr *> SubExprs);\n  static RecoveryExpr *CreateEmpty(ASTContext &Ctx, unsigned NumSubExprs);\n\n  ArrayRef<Expr *> subExpressions() {\n    auto *B = getTrailingObjects<Expr *>();\n    return llvm::makeArrayRef(B, B + NumExprs);\n  }\n\n  ArrayRef<const Expr *> subExpressions() const {\n    return const_cast<RecoveryExpr *>(this)->subExpressions();\n  }\n\n  child_range children() {\n    Stmt **B = reinterpret_cast<Stmt **>(getTrailingObjects<Expr *>());\n    return child_range(B, B + NumExprs);\n  }\n\n  SourceLocation getBeginLoc() const { return BeginLoc; }\n  SourceLocation getEndLoc() const { return EndLoc; }\n\n  static bool classof(const Stmt *T) {\n    return T->getStmtClass() == RecoveryExprClass;\n  }\n\nprivate:\n  RecoveryExpr(ASTContext &Ctx, QualType T, SourceLocation BeginLoc,\n               SourceLocation EndLoc, ArrayRef<Expr *> SubExprs);\n  RecoveryExpr(EmptyShell Empty, unsigned NumSubExprs)\n      : Expr(RecoveryExprClass, Empty), NumExprs(NumSubExprs) {}\n\n  size_t numTrailingObjects(OverloadToken<Stmt *>) const { return NumExprs; }\n\n  SourceLocation BeginLoc, EndLoc;\n  unsigned NumExprs;\n  friend TrailingObjects;\n  friend class ASTStmtReader;\n  friend class ASTStmtWriter;\n};\n\n} // end namespace clang\n\n#endif // LLVM_CLANG_AST_EXPR_H\n"}, "10": {"id": 10, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/NestedNameSpecifier.h", "content": "//===- NestedNameSpecifier.h - C++ nested name specifiers -------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n//  This file defines the NestedNameSpecifier class, which represents\n//  a C++ nested-name-specifier.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_AST_NESTEDNAMESPECIFIER_H\n#define LLVM_CLANG_AST_NESTEDNAMESPECIFIER_H\n\n#include \"clang/AST/DependenceFlags.h\"\n#include \"clang/Basic/Diagnostic.h\"\n#include \"clang/Basic/SourceLocation.h\"\n#include \"llvm/ADT/DenseMapInfo.h\"\n#include \"llvm/ADT/FoldingSet.h\"\n#include \"llvm/ADT/PointerIntPair.h\"\n#include \"llvm/Support/Compiler.h\"\n#include <cstdint>\n#include <cstdlib>\n#include <utility>\n\nnamespace clang {\n\nclass ASTContext;\nclass CXXRecordDecl;\nclass IdentifierInfo;\nclass LangOptions;\nclass NamespaceAliasDecl;\nclass NamespaceDecl;\nstruct PrintingPolicy;\nclass Type;\nclass TypeLoc;\n\n/// Represents a C++ nested name specifier, such as\n/// \"\\::std::vector<int>::\".\n///\n/// C++ nested name specifiers are the prefixes to qualified\n/// names. For example, \"foo::\" in \"foo::x\" is a nested name\n/// specifier. Nested name specifiers are made up of a sequence of\n/// specifiers, each of which can be a namespace, type, identifier\n/// (for dependent names), decltype specifier, or the global specifier ('::').\n/// The last two specifiers can only appear at the start of a\n/// nested-namespace-specifier.\nclass NestedNameSpecifier : public llvm::FoldingSetNode {\n  /// Enumeration describing\n  enum StoredSpecifierKind {\n    StoredIdentifier = 0,\n    StoredDecl = 1,\n    StoredTypeSpec = 2,\n    StoredTypeSpecWithTemplate = 3\n  };\n\n  /// The nested name specifier that precedes this nested name\n  /// specifier.\n  ///\n  /// The pointer is the nested-name-specifier that precedes this\n  /// one. The integer stores one of the first four values of type\n  /// SpecifierKind.\n  llvm::PointerIntPair<NestedNameSpecifier *, 2, StoredSpecifierKind> Prefix;\n\n  /// The last component in the nested name specifier, which\n  /// can be an identifier, a declaration, or a type.\n  ///\n  /// When the pointer is NULL, this specifier represents the global\n  /// specifier '::'. Otherwise, the pointer is one of\n  /// IdentifierInfo*, Namespace*, or Type*, depending on the kind of\n  /// specifier as encoded within the prefix.\n  void* Specifier = nullptr;\n\npublic:\n  /// The kind of specifier that completes this nested name\n  /// specifier.\n  enum SpecifierKind {\n    /// An identifier, stored as an IdentifierInfo*.\n    Identifier,\n\n    /// A namespace, stored as a NamespaceDecl*.\n    Namespace,\n\n    /// A namespace alias, stored as a NamespaceAliasDecl*.\n    NamespaceAlias,\n\n    /// A type, stored as a Type*.\n    TypeSpec,\n\n    /// A type that was preceded by the 'template' keyword,\n    /// stored as a Type*.\n    TypeSpecWithTemplate,\n\n    /// The global specifier '::'. There is no stored value.\n    Global,\n\n    /// Microsoft's '__super' specifier, stored as a CXXRecordDecl* of\n    /// the class it appeared in.\n    Super\n  };\n\nprivate:\n  /// Builds the global specifier.\n  NestedNameSpecifier() : Prefix(nullptr, StoredIdentifier) {}\n\n  /// Copy constructor used internally to clone nested name\n  /// specifiers.\n  NestedNameSpecifier(const NestedNameSpecifier &Other) = default;\n\n  /// Either find or insert the given nested name specifier\n  /// mockup in the given context.\n  static NestedNameSpecifier *FindOrInsert(const ASTContext &Context,\n                                           const NestedNameSpecifier &Mockup);\n\npublic:\n  NestedNameSpecifier &operator=(const NestedNameSpecifier &) = delete;\n\n  /// Builds a specifier combining a prefix and an identifier.\n  ///\n  /// The prefix must be dependent, since nested name specifiers\n  /// referencing an identifier are only permitted when the identifier\n  /// cannot be resolved.\n  static NestedNameSpecifier *Create(const ASTContext &Context,\n                                     NestedNameSpecifier *Prefix,\n                                     IdentifierInfo *II);\n\n  /// Builds a nested name specifier that names a namespace.\n  static NestedNameSpecifier *Create(const ASTContext &Context,\n                                     NestedNameSpecifier *Prefix,\n                                     const NamespaceDecl *NS);\n\n  /// Builds a nested name specifier that names a namespace alias.\n  static NestedNameSpecifier *Create(const ASTContext &Context,\n                                     NestedNameSpecifier *Prefix,\n                                     NamespaceAliasDecl *Alias);\n\n  /// Builds a nested name specifier that names a type.\n  static NestedNameSpecifier *Create(const ASTContext &Context,\n                                     NestedNameSpecifier *Prefix,\n                                     bool Template, const Type *T);\n\n  /// Builds a specifier that consists of just an identifier.\n  ///\n  /// The nested-name-specifier is assumed to be dependent, but has no\n  /// prefix because the prefix is implied by something outside of the\n  /// nested name specifier, e.g., in \"x->Base::f\", the \"x\" has a dependent\n  /// type.\n  static NestedNameSpecifier *Create(const ASTContext &Context,\n                                     IdentifierInfo *II);\n\n  /// Returns the nested name specifier representing the global\n  /// scope.\n  static NestedNameSpecifier *GlobalSpecifier(const ASTContext &Context);\n\n  /// Returns the nested name specifier representing the __super scope\n  /// for the given CXXRecordDecl.\n  static NestedNameSpecifier *SuperSpecifier(const ASTContext &Context,\n                                             CXXRecordDecl *RD);\n\n  /// Return the prefix of this nested name specifier.\n  ///\n  /// The prefix contains all of the parts of the nested name\n  /// specifier that preced this current specifier. For example, for a\n  /// nested name specifier that represents \"foo::bar::\", the current\n  /// specifier will contain \"bar::\" and the prefix will contain\n  /// \"foo::\".\n  NestedNameSpecifier *getPrefix() const { return Prefix.getPointer(); }\n\n  /// Determine what kind of nested name specifier is stored.\n  SpecifierKind getKind() const;\n\n  /// Retrieve the identifier stored in this nested name\n  /// specifier.\n  IdentifierInfo *getAsIdentifier() const {\n    if (Prefix.getInt() == StoredIdentifier)\n      return (IdentifierInfo *)Specifier;\n\n    return nullptr;\n  }\n\n  /// Retrieve the namespace stored in this nested name\n  /// specifier.\n  NamespaceDecl *getAsNamespace() const;\n\n  /// Retrieve the namespace alias stored in this nested name\n  /// specifier.\n  NamespaceAliasDecl *getAsNamespaceAlias() const;\n\n  /// Retrieve the record declaration stored in this nested name\n  /// specifier.\n  CXXRecordDecl *getAsRecordDecl() const;\n\n  /// Retrieve the type stored in this nested name specifier.\n  const Type *getAsType() const {\n    if (Prefix.getInt() == StoredTypeSpec ||\n        Prefix.getInt() == StoredTypeSpecWithTemplate)\n      return (const Type *)Specifier;\n\n    return nullptr;\n  }\n\n  NestedNameSpecifierDependence getDependence() const;\n\n  /// Whether this nested name specifier refers to a dependent\n  /// type or not.\n  bool isDependent() const;\n\n  /// Whether this nested name specifier involves a template\n  /// parameter.\n  bool isInstantiationDependent() const;\n\n  /// Whether this nested-name-specifier contains an unexpanded\n  /// parameter pack (for C++11 variadic templates).\n  bool containsUnexpandedParameterPack() const;\n\n  /// Whether this nested name specifier contains an error.\n  bool containsErrors() const;\n\n  /// Print this nested name specifier to the given output stream. If\n  /// `ResolveTemplateArguments` is true, we'll print actual types, e.g.\n  /// `ns::SomeTemplate<int, MyClass>` instead of\n  /// `ns::SomeTemplate<Container::value_type, T>`.\n  void print(raw_ostream &OS, const PrintingPolicy &Policy,\n             bool ResolveTemplateArguments = false) const;\n\n  void Profile(llvm::FoldingSetNodeID &ID) const {\n    ID.AddPointer(Prefix.getOpaqueValue());\n    ID.AddPointer(Specifier);\n  }\n\n  /// Dump the nested name specifier to standard output to aid\n  /// in debugging.\n  void dump(const LangOptions &LO) const;\n  void dump() const;\n  void dump(llvm::raw_ostream &OS) const;\n  void dump(llvm::raw_ostream &OS, const LangOptions &LO) const;\n};\n\n/// A C++ nested-name-specifier augmented with source location\n/// information.\nclass NestedNameSpecifierLoc {\n  NestedNameSpecifier *Qualifier = nullptr;\n  void *Data = nullptr;\n\n  /// Determines the data length for the last component in the\n  /// given nested-name-specifier.\n  static unsigned getLocalDataLength(NestedNameSpecifier *Qualifier);\n\n  /// Determines the data length for the entire\n  /// nested-name-specifier.\n  static unsigned getDataLength(NestedNameSpecifier *Qualifier);\n\npublic:\n  /// Construct an empty nested-name-specifier.\n  NestedNameSpecifierLoc() = default;\n\n  /// Construct a nested-name-specifier with source location information\n  /// from\n  NestedNameSpecifierLoc(NestedNameSpecifier *Qualifier, void *Data)\n      : Qualifier(Qualifier), Data(Data) {}\n\n  /// Evaluates true when this nested-name-specifier location is\n  /// non-empty.\n  explicit operator bool() const { return Qualifier; }\n\n  /// Evaluates true when this nested-name-specifier location is\n  /// empty.\n  bool hasQualifier() const { return Qualifier; }\n\n  /// Retrieve the nested-name-specifier to which this instance\n  /// refers.\n  NestedNameSpecifier *getNestedNameSpecifier() const {\n    return Qualifier;\n  }\n\n  /// Retrieve the opaque pointer that refers to source-location data.\n  void *getOpaqueData() const { return Data; }\n\n  /// Retrieve the source range covering the entirety of this\n  /// nested-name-specifier.\n  ///\n  /// For example, if this instance refers to a nested-name-specifier\n  /// \\c \\::std::vector<int>::, the returned source range would cover\n  /// from the initial '::' to the last '::'.\n  SourceRange getSourceRange() const LLVM_READONLY;\n\n  /// Retrieve the source range covering just the last part of\n  /// this nested-name-specifier, not including the prefix.\n  ///\n  /// For example, if this instance refers to a nested-name-specifier\n  /// \\c \\::std::vector<int>::, the returned source range would cover\n  /// from \"vector\" to the last '::'.\n  SourceRange getLocalSourceRange() const;\n\n  /// Retrieve the location of the beginning of this\n  /// nested-name-specifier.\n  SourceLocation getBeginLoc() const {\n    return getSourceRange().getBegin();\n  }\n\n  /// Retrieve the location of the end of this\n  /// nested-name-specifier.\n  SourceLocation getEndLoc() const {\n    return getSourceRange().getEnd();\n  }\n\n  /// Retrieve the location of the beginning of this\n  /// component of the nested-name-specifier.\n  SourceLocation getLocalBeginLoc() const {\n    return getLocalSourceRange().getBegin();\n  }\n\n  /// Retrieve the location of the end of this component of the\n  /// nested-name-specifier.\n  SourceLocation getLocalEndLoc() const {\n    return getLocalSourceRange().getEnd();\n  }\n\n  /// Return the prefix of this nested-name-specifier.\n  ///\n  /// For example, if this instance refers to a nested-name-specifier\n  /// \\c \\::std::vector<int>::, the prefix is \\c \\::std::. Note that the\n  /// returned prefix may be empty, if this is the first component of\n  /// the nested-name-specifier.\n  NestedNameSpecifierLoc getPrefix() const {\n    if (!Qualifier)\n      return *this;\n\n    return NestedNameSpecifierLoc(Qualifier->getPrefix(), Data);\n  }\n\n  /// For a nested-name-specifier that refers to a type,\n  /// retrieve the type with source-location information.\n  TypeLoc getTypeLoc() const;\n\n  /// Determines the data length for the entire\n  /// nested-name-specifier.\n  unsigned getDataLength() const { return getDataLength(Qualifier); }\n\n  friend bool operator==(NestedNameSpecifierLoc X,\n                         NestedNameSpecifierLoc Y) {\n    return X.Qualifier == Y.Qualifier && X.Data == Y.Data;\n  }\n\n  friend bool operator!=(NestedNameSpecifierLoc X,\n                         NestedNameSpecifierLoc Y) {\n    return !(X == Y);\n  }\n};\n\n/// Class that aids in the construction of nested-name-specifiers along\n/// with source-location information for all of the components of the\n/// nested-name-specifier.\nclass NestedNameSpecifierLocBuilder {\n  /// The current representation of the nested-name-specifier we're\n  /// building.\n  NestedNameSpecifier *Representation = nullptr;\n\n  /// Buffer used to store source-location information for the\n  /// nested-name-specifier.\n  ///\n  /// Note that we explicitly manage the buffer (rather than using a\n  /// SmallVector) because \\c Declarator expects it to be possible to memcpy()\n  /// a \\c CXXScopeSpec, and CXXScopeSpec uses a NestedNameSpecifierLocBuilder.\n  char *Buffer = nullptr;\n\n  /// The size of the buffer used to store source-location information\n  /// for the nested-name-specifier.\n  unsigned BufferSize = 0;\n\n  /// The capacity of the buffer used to store source-location\n  /// information for the nested-name-specifier.\n  unsigned BufferCapacity = 0;\n\npublic:\n  NestedNameSpecifierLocBuilder() = default;\n  NestedNameSpecifierLocBuilder(const NestedNameSpecifierLocBuilder &Other);\n\n  NestedNameSpecifierLocBuilder &\n  operator=(const NestedNameSpecifierLocBuilder &Other);\n\n  ~NestedNameSpecifierLocBuilder() {\n    if (BufferCapacity)\n      free(Buffer);\n  }\n\n  /// Retrieve the representation of the nested-name-specifier.\n  NestedNameSpecifier *getRepresentation() const { return Representation; }\n\n  /// Extend the current nested-name-specifier by another\n  /// nested-name-specifier component of the form 'type::'.\n  ///\n  /// \\param Context The AST context in which this nested-name-specifier\n  /// resides.\n  ///\n  /// \\param TemplateKWLoc The location of the 'template' keyword, if present.\n  ///\n  /// \\param TL The TypeLoc that describes the type preceding the '::'.\n  ///\n  /// \\param ColonColonLoc The location of the trailing '::'.\n  void Extend(ASTContext &Context, SourceLocation TemplateKWLoc, TypeLoc TL,\n              SourceLocation ColonColonLoc);\n\n  /// Extend the current nested-name-specifier by another\n  /// nested-name-specifier component of the form 'identifier::'.\n  ///\n  /// \\param Context The AST context in which this nested-name-specifier\n  /// resides.\n  ///\n  /// \\param Identifier The identifier.\n  ///\n  /// \\param IdentifierLoc The location of the identifier.\n  ///\n  /// \\param ColonColonLoc The location of the trailing '::'.\n  void Extend(ASTContext &Context, IdentifierInfo *Identifier,\n              SourceLocation IdentifierLoc, SourceLocation ColonColonLoc);\n\n  /// Extend the current nested-name-specifier by another\n  /// nested-name-specifier component of the form 'namespace::'.\n  ///\n  /// \\param Context The AST context in which this nested-name-specifier\n  /// resides.\n  ///\n  /// \\param Namespace The namespace.\n  ///\n  /// \\param NamespaceLoc The location of the namespace name.\n  ///\n  /// \\param ColonColonLoc The location of the trailing '::'.\n  void Extend(ASTContext &Context, NamespaceDecl *Namespace,\n              SourceLocation NamespaceLoc, SourceLocation ColonColonLoc);\n\n  /// Extend the current nested-name-specifier by another\n  /// nested-name-specifier component of the form 'namespace-alias::'.\n  ///\n  /// \\param Context The AST context in which this nested-name-specifier\n  /// resides.\n  ///\n  /// \\param Alias The namespace alias.\n  ///\n  /// \\param AliasLoc The location of the namespace alias\n  /// name.\n  ///\n  /// \\param ColonColonLoc The location of the trailing '::'.\n  void Extend(ASTContext &Context, NamespaceAliasDecl *Alias,\n              SourceLocation AliasLoc, SourceLocation ColonColonLoc);\n\n  /// Turn this (empty) nested-name-specifier into the global\n  /// nested-name-specifier '::'.\n  void MakeGlobal(ASTContext &Context, SourceLocation ColonColonLoc);\n\n  /// Turns this (empty) nested-name-specifier into '__super'\n  /// nested-name-specifier.\n  ///\n  /// \\param Context The AST context in which this nested-name-specifier\n  /// resides.\n  ///\n  /// \\param RD The declaration of the class in which nested-name-specifier\n  /// appeared.\n  ///\n  /// \\param SuperLoc The location of the '__super' keyword.\n  /// name.\n  ///\n  /// \\param ColonColonLoc The location of the trailing '::'.\n  void MakeSuper(ASTContext &Context, CXXRecordDecl *RD,\n                 SourceLocation SuperLoc, SourceLocation ColonColonLoc);\n\n  /// Make a new nested-name-specifier from incomplete source-location\n  /// information.\n  ///\n  /// This routine should be used very, very rarely, in cases where we\n  /// need to synthesize a nested-name-specifier. Most code should instead use\n  /// \\c Adopt() with a proper \\c NestedNameSpecifierLoc.\n  void MakeTrivial(ASTContext &Context, NestedNameSpecifier *Qualifier,\n                   SourceRange R);\n\n  /// Adopt an existing nested-name-specifier (with source-range\n  /// information).\n  void Adopt(NestedNameSpecifierLoc Other);\n\n  /// Retrieve the source range covered by this nested-name-specifier.\n  SourceRange getSourceRange() const LLVM_READONLY {\n    return NestedNameSpecifierLoc(Representation, Buffer).getSourceRange();\n  }\n\n  /// Retrieve a nested-name-specifier with location information,\n  /// copied into the given AST context.\n  ///\n  /// \\param Context The context into which this nested-name-specifier will be\n  /// copied.\n  NestedNameSpecifierLoc getWithLocInContext(ASTContext &Context) const;\n\n  /// Retrieve a nested-name-specifier with location\n  /// information based on the information in this builder.\n  ///\n  /// This loc will contain references to the builder's internal data and may\n  /// be invalidated by any change to the builder.\n  NestedNameSpecifierLoc getTemporary() const {\n    return NestedNameSpecifierLoc(Representation, Buffer);\n  }\n\n  /// Clear out this builder, and prepare it to build another\n  /// nested-name-specifier with source-location information.\n  void Clear() {\n    Representation = nullptr;\n    BufferSize = 0;\n  }\n\n  /// Retrieve the underlying buffer.\n  ///\n  /// \\returns A pair containing a pointer to the buffer of source-location\n  /// data and the size of the source-location data that resides in that\n  /// buffer.\n  std::pair<char *, unsigned> getBuffer() const {\n    return std::make_pair(Buffer, BufferSize);\n  }\n};\n\n/// Insertion operator for diagnostics.  This allows sending\n/// NestedNameSpecifiers into a diagnostic with <<.\ninline const StreamingDiagnostic &operator<<(const StreamingDiagnostic &DB,\n                                             NestedNameSpecifier *NNS) {\n  DB.AddTaggedVal(reinterpret_cast<intptr_t>(NNS),\n                  DiagnosticsEngine::ak_nestednamespec);\n  return DB;\n}\n\n} // namespace clang\n\nnamespace llvm {\n\ntemplate <> struct DenseMapInfo<clang::NestedNameSpecifierLoc> {\n  using FirstInfo = DenseMapInfo<clang::NestedNameSpecifier *>;\n  using SecondInfo = DenseMapInfo<void *>;\n\n  static clang::NestedNameSpecifierLoc getEmptyKey() {\n    return clang::NestedNameSpecifierLoc(FirstInfo::getEmptyKey(),\n                                         SecondInfo::getEmptyKey());\n  }\n\n  static clang::NestedNameSpecifierLoc getTombstoneKey() {\n    return clang::NestedNameSpecifierLoc(FirstInfo::getTombstoneKey(),\n                                         SecondInfo::getTombstoneKey());\n  }\n\n  static unsigned getHashValue(const clang::NestedNameSpecifierLoc &PairVal) {\n    return hash_combine(\n        FirstInfo::getHashValue(PairVal.getNestedNameSpecifier()),\n        SecondInfo::getHashValue(PairVal.getOpaqueData()));\n  }\n\n  static bool isEqual(const clang::NestedNameSpecifierLoc &LHS,\n                      const clang::NestedNameSpecifierLoc &RHS) {\n    return LHS == RHS;\n  }\n};\n} // namespace llvm\n\n#endif // LLVM_CLANG_AST_NESTEDNAMESPECIFIER_H\n"}, "11": {"id": 11, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/Redeclarable.h", "content": "//===- Redeclarable.h - Base for Decls that can be redeclared --*- C++ -*-====//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n//  This file defines the Redeclarable interface.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_AST_REDECLARABLE_H\n#define LLVM_CLANG_AST_REDECLARABLE_H\n\n#include \"clang/AST/ExternalASTSource.h\"\n#include \"llvm/ADT/DenseMapInfo.h\"\n#include \"llvm/ADT/PointerUnion.h\"\n#include \"llvm/ADT/iterator_range.h\"\n#include \"llvm/Support/Casting.h\"\n#include <cassert>\n#include <cstddef>\n#include <iterator>\n\nnamespace clang {\n\nclass ASTContext;\nclass Decl;\n\n// Some notes on redeclarables:\n//\n//  - Every redeclarable is on a circular linked list.\n//\n//  - Every decl has a pointer to the first element of the chain _and_ a\n//    DeclLink that may point to one of 3 possible states:\n//      - the \"previous\" (temporal) element in the chain\n//      - the \"latest\" (temporal) element in the chain\n//      - the \"uninitialized-latest\" value (when newly-constructed)\n//\n//  - The first element is also often called the canonical element. Every\n//    element has a pointer to it so that \"getCanonical\" can be fast.\n//\n//  - Most links in the chain point to previous, except the link out of\n//    the first; it points to latest.\n//\n//  - Elements are called \"first\", \"previous\", \"latest\" or\n//    \"most-recent\" when referring to temporal order: order of addition\n//    to the chain.\n//\n//  - It's easiest to just ignore the implementation of DeclLink when making\n//    sense of the redeclaration chain.\n//\n//  - There's also a \"definition\" link for several types of\n//    redeclarable, where only one definition should exist at any given\n//    time (and the defn pointer is stored in the decl's \"data\" which\n//    is copied to every element on the chain when it's changed).\n//\n//    Here is some ASCII art:\n//\n//      \"first\"                                     \"latest\"\n//      \"canonical\"                                 \"most recent\"\n//      +------------+         first                +--------------+\n//      |            | <--------------------------- |              |\n//      |            |                              |              |\n//      |            |                              |              |\n//      |            |       +--------------+       |              |\n//      |            | first |              |       |              |\n//      |            | <---- |              |       |              |\n//      |            |       |              |       |              |\n//      | @class A   |  link | @interface A |  link | @class A     |\n//      | seen first | <---- | seen second  | <---- | seen third   |\n//      |            |       |              |       |              |\n//      +------------+       +--------------+       +--------------+\n//      | data       | defn  | data         |  defn | data         |\n//      |            | ----> |              | <---- |              |\n//      +------------+       +--------------+       +--------------+\n//        |                     |     ^                  ^\n//        |                     |defn |                  |\n//        | link                +-----+                  |\n//        +-->-------------------------------------------+\n\n/// Provides common interface for the Decls that can be redeclared.\ntemplate<typename decl_type>\nclass Redeclarable {\nprotected:\n  class DeclLink {\n    /// A pointer to a known latest declaration, either statically known or\n    /// generationally updated as decls are added by an external source.\n    using KnownLatest =\n        LazyGenerationalUpdatePtr<const Decl *, Decl *,\n                                  &ExternalASTSource::CompleteRedeclChain>;\n\n    /// We store a pointer to the ASTContext in the UninitializedLatest\n    /// pointer, but to avoid circular type dependencies when we steal the low\n    /// bits of this pointer, we use a raw void* here.\n    using UninitializedLatest = const void *;\n\n    using Previous = Decl *;\n\n    /// A pointer to either an uninitialized latest declaration (where either\n    /// we've not yet set the previous decl or there isn't one), or to a known\n    /// previous declaration.\n    using NotKnownLatest = llvm::PointerUnion<Previous, UninitializedLatest>;\n\n    mutable llvm::PointerUnion<NotKnownLatest, KnownLatest> Link;\n\n  public:\n    enum PreviousTag { PreviousLink };\n    enum LatestTag { LatestLink };\n\n    DeclLink(LatestTag, const ASTContext &Ctx)\n        : Link(NotKnownLatest(reinterpret_cast<UninitializedLatest>(&Ctx))) {}\n    DeclLink(PreviousTag, decl_type *D) : Link(NotKnownLatest(Previous(D))) {}\n\n    bool isFirst() const {\n      return Link.is<KnownLatest>() ||\n             // FIXME: 'template' is required on the next line due to an\n             // apparent clang bug.\n             Link.get<NotKnownLatest>().template is<UninitializedLatest>();\n    }\n\n    decl_type *getPrevious(const decl_type *D) const {\n      if (Link.is<NotKnownLatest>()) {\n        NotKnownLatest NKL = Link.get<NotKnownLatest>();\n        if (NKL.is<Previous>())\n          return static_cast<decl_type*>(NKL.get<Previous>());\n\n        // Allocate the generational 'most recent' cache now, if needed.\n        Link = KnownLatest(*reinterpret_cast<const ASTContext *>(\n                               NKL.get<UninitializedLatest>()),\n                           const_cast<decl_type *>(D));\n      }\n\n      return static_cast<decl_type*>(Link.get<KnownLatest>().get(D));\n    }\n\n    void setPrevious(decl_type *D) {\n      assert(!isFirst() && \"decl became non-canonical unexpectedly\");\n      Link = Previous(D);\n    }\n\n    void setLatest(decl_type *D) {\n      assert(isFirst() && \"decl became canonical unexpectedly\");\n      if (Link.is<NotKnownLatest>()) {\n        NotKnownLatest NKL = Link.get<NotKnownLatest>();\n        Link = KnownLatest(*reinterpret_cast<const ASTContext *>(\n                               NKL.get<UninitializedLatest>()),\n                           D);\n      } else {\n        auto Latest = Link.get<KnownLatest>();\n        Latest.set(D);\n        Link = Latest;\n      }\n    }\n\n    void markIncomplete() { Link.get<KnownLatest>().markIncomplete(); }\n\n    Decl *getLatestNotUpdated() const {\n      assert(isFirst() && \"expected a canonical decl\");\n      if (Link.is<NotKnownLatest>())\n        return nullptr;\n      return Link.get<KnownLatest>().getNotUpdated();\n    }\n  };\n\n  static DeclLink PreviousDeclLink(decl_type *D) {\n    return DeclLink(DeclLink::PreviousLink, D);\n  }\n\n  static DeclLink LatestDeclLink(const ASTContext &Ctx) {\n    return DeclLink(DeclLink::LatestLink, Ctx);\n  }\n\n  /// Points to the next redeclaration in the chain.\n  ///\n  /// If isFirst() is false, this is a link to the previous declaration\n  /// of this same Decl. If isFirst() is true, this is the first\n  /// declaration and Link points to the latest declaration. For example:\n  ///\n  ///  #1 int f(int x, int y = 1); // <pointer to #3, true>\n  ///  #2 int f(int x = 0, int y); // <pointer to #1, false>\n  ///  #3 int f(int x, int y) { return x + y; } // <pointer to #2, false>\n  ///\n  /// If there is only one declaration, it is <pointer to self, true>\n  DeclLink RedeclLink;\n\n  decl_type *First;\n\n  decl_type *getNextRedeclaration() const {\n    return RedeclLink.getPrevious(static_cast<const decl_type *>(this));\n  }\n\npublic:\n  friend class ASTDeclReader;\n  friend class ASTDeclWriter;\n\n  Redeclarable(const ASTContext &Ctx)\n      : RedeclLink(LatestDeclLink(Ctx)),\n        First(static_cast<decl_type *>(this)) {}\n\n  /// Return the previous declaration of this declaration or NULL if this\n  /// is the first declaration.\n  decl_type *getPreviousDecl() {\n    if (!RedeclLink.isFirst())\n      return getNextRedeclaration();\n    return nullptr;\n  }\n  const decl_type *getPreviousDecl() const {\n    return const_cast<decl_type *>(\n                 static_cast<const decl_type*>(this))->getPreviousDecl();\n  }\n\n  /// Return the first declaration of this declaration or itself if this\n  /// is the only declaration.\n  decl_type *getFirstDecl() { return First; }\n\n  /// Return the first declaration of this declaration or itself if this\n  /// is the only declaration.\n  const decl_type *getFirstDecl() const { return First; }\n\n  /// True if this is the first declaration in its redeclaration chain.\n  bool isFirstDecl() const { return RedeclLink.isFirst(); }\n\n  /// Returns the most recent (re)declaration of this declaration.\n  decl_type *getMostRecentDecl() {\n    return getFirstDecl()->getNextRedeclaration();\n  }\n\n  /// Returns the most recent (re)declaration of this declaration.\n  const decl_type *getMostRecentDecl() const {\n    return getFirstDecl()->getNextRedeclaration();\n  }\n\n  /// Set the previous declaration. If PrevDecl is NULL, set this as the\n  /// first and only declaration.\n  void setPreviousDecl(decl_type *PrevDecl);\n\n  /// Iterates through all the redeclarations of the same decl.\n  class redecl_iterator {\n    /// Current - The current declaration.\n    decl_type *Current = nullptr;\n    decl_type *Starter;\n    bool PassedFirst = false;\n\n  public:\n    using value_type = decl_type *;\n    using reference = decl_type *;\n    using pointer = decl_type *;\n    using iterator_category = std::forward_iterator_tag;\n    using difference_type = std::ptrdiff_t;\n\n    redecl_iterator() = default;\n    explicit redecl_iterator(decl_type *C) : Current(C), Starter(C) {}\n\n    reference operator*() const { return Current; }\n    pointer operator->() const { return Current; }\n\n    redecl_iterator& operator++() {\n      assert(Current && \"Advancing while iterator has reached end\");\n      // Sanity check to avoid infinite loop on invalid redecl chain.\n      if (Current->isFirstDecl()) {\n        if (PassedFirst) {\n          assert(0 && \"Passed first decl twice, invalid redecl chain!\");\n          Current = nullptr;\n          return *this;\n        }\n        PassedFirst = true;\n      }\n\n      // Get either previous decl or latest decl.\n      decl_type *Next = Current->getNextRedeclaration();\n      Current = (Next != Starter) ? Next : nullptr;\n      return *this;\n    }\n\n    redecl_iterator operator++(int) {\n      redecl_iterator tmp(*this);\n      ++(*this);\n      return tmp;\n    }\n\n    friend bool operator==(redecl_iterator x, redecl_iterator y) {\n      return x.Current == y.Current;\n    }\n    friend bool operator!=(redecl_iterator x, redecl_iterator y) {\n      return x.Current != y.Current;\n    }\n  };\n\n  using redecl_range = llvm::iterator_range<redecl_iterator>;\n\n  /// Returns an iterator range for all the redeclarations of the same\n  /// decl. It will iterate at least once (when this decl is the only one).\n  redecl_range redecls() const {\n    return redecl_range(redecl_iterator(const_cast<decl_type *>(\n                            static_cast<const decl_type *>(this))),\n                        redecl_iterator());\n  }\n\n  redecl_iterator redecls_begin() const { return redecls().begin(); }\n  redecl_iterator redecls_end() const { return redecls().end(); }\n};\n\n/// Get the primary declaration for a declaration from an AST file. That\n/// will be the first-loaded declaration.\nDecl *getPrimaryMergedDecl(Decl *D);\n\n/// Provides common interface for the Decls that cannot be redeclared,\n/// but can be merged if the same declaration is brought in from multiple\n/// modules.\ntemplate<typename decl_type>\nclass Mergeable {\npublic:\n  Mergeable() = default;\n\n  /// Return the first declaration of this declaration or itself if this\n  /// is the only declaration.\n  decl_type *getFirstDecl() {\n    auto *D = static_cast<decl_type *>(this);\n    if (!D->isFromASTFile())\n      return D;\n    return cast<decl_type>(getPrimaryMergedDecl(const_cast<decl_type*>(D)));\n  }\n\n  /// Return the first declaration of this declaration or itself if this\n  /// is the only declaration.\n  const decl_type *getFirstDecl() const {\n    const auto *D = static_cast<const decl_type *>(this);\n    if (!D->isFromASTFile())\n      return D;\n    return cast<decl_type>(getPrimaryMergedDecl(const_cast<decl_type*>(D)));\n  }\n\n  /// Returns true if this is the first declaration.\n  bool isFirstDecl() const { return getFirstDecl() == this; }\n};\n\n/// A wrapper class around a pointer that always points to its canonical\n/// declaration.\n///\n/// CanonicalDeclPtr<decl_type> behaves just like decl_type*, except we call\n/// decl_type::getCanonicalDecl() on construction.\n///\n/// This is useful for hashtables that you want to be keyed on a declaration's\n/// canonical decl -- if you use CanonicalDeclPtr as the key, you don't need to\n/// remember to call getCanonicalDecl() everywhere.\ntemplate <typename decl_type> class CanonicalDeclPtr {\npublic:\n  CanonicalDeclPtr() = default;\n  CanonicalDeclPtr(decl_type *Ptr)\n      : Ptr(Ptr ? Ptr->getCanonicalDecl() : nullptr) {}\n  CanonicalDeclPtr(const CanonicalDeclPtr &) = default;\n  CanonicalDeclPtr &operator=(const CanonicalDeclPtr &) = default;\n\n  operator decl_type *() { return Ptr; }\n  operator const decl_type *() const { return Ptr; }\n\n  decl_type *operator->() { return Ptr; }\n  const decl_type *operator->() const { return Ptr; }\n\n  decl_type &operator*() { return *Ptr; }\n  const decl_type &operator*() const { return *Ptr; }\n\n  friend bool operator==(CanonicalDeclPtr LHS, CanonicalDeclPtr RHS) {\n    return LHS.Ptr == RHS.Ptr;\n  }\n  friend bool operator!=(CanonicalDeclPtr LHS, CanonicalDeclPtr RHS) {\n    return LHS.Ptr != RHS.Ptr;\n  }\n\nprivate:\n  friend struct llvm::DenseMapInfo<CanonicalDeclPtr<decl_type>>;\n  friend struct llvm::PointerLikeTypeTraits<CanonicalDeclPtr<decl_type>>;\n\n  decl_type *Ptr = nullptr;\n};\n\n} // namespace clang\n\nnamespace llvm {\n\ntemplate <typename decl_type>\nstruct DenseMapInfo<clang::CanonicalDeclPtr<decl_type>> {\n  using CanonicalDeclPtr = clang::CanonicalDeclPtr<decl_type>;\n  using BaseInfo = DenseMapInfo<decl_type *>;\n\n  static CanonicalDeclPtr getEmptyKey() {\n    // Construct our CanonicalDeclPtr this way because the regular constructor\n    // would dereference P.Ptr, which is not allowed.\n    CanonicalDeclPtr P;\n    P.Ptr = BaseInfo::getEmptyKey();\n    return P;\n  }\n\n  static CanonicalDeclPtr getTombstoneKey() {\n    CanonicalDeclPtr P;\n    P.Ptr = BaseInfo::getTombstoneKey();\n    return P;\n  }\n\n  static unsigned getHashValue(const CanonicalDeclPtr &P) {\n    return BaseInfo::getHashValue(P);\n  }\n\n  static bool isEqual(const CanonicalDeclPtr &LHS,\n                      const CanonicalDeclPtr &RHS) {\n    return BaseInfo::isEqual(LHS, RHS);\n  }\n};\n\ntemplate <typename decl_type>\nstruct PointerLikeTypeTraits<clang::CanonicalDeclPtr<decl_type>> {\n  static inline void *getAsVoidPointer(clang::CanonicalDeclPtr<decl_type> P) {\n    return P.Ptr;\n  }\n  static inline clang::CanonicalDeclPtr<decl_type> getFromVoidPointer(void *P) {\n    clang::CanonicalDeclPtr<decl_type> C;\n    C.Ptr = PointerLikeTypeTraits<decl_type *>::getFromVoidPtr(P);\n    return C;\n  }\n  static constexpr int NumLowBitsAvailable =\n      PointerLikeTypeTraits<decl_type *>::NumLowBitsAvailable;\n};\n\n} // namespace llvm\n\n#endif // LLVM_CLANG_AST_REDECLARABLE_H\n"}, "12": {"id": 12, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/StmtIterator.h", "content": "//===- StmtIterator.h - Iterators for Statements ----------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file defines the StmtIterator and ConstStmtIterator classes.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_AST_STMTITERATOR_H\n#define LLVM_CLANG_AST_STMTITERATOR_H\n\n#include <cassert>\n#include <cstddef>\n#include <cstdint>\n#include <iterator>\n\nnamespace clang {\n\nclass Decl;\nclass Stmt;\nclass VariableArrayType;\n\nclass StmtIteratorBase {\nprotected:\n  enum {\n    StmtMode = 0x0,\n    SizeOfTypeVAMode = 0x1,\n    DeclGroupMode = 0x2,\n    Flags = 0x3\n  };\n\n  union {\n    Stmt **stmt;\n    Decl **DGI;\n  };\n  uintptr_t RawVAPtr = 0;\n  Decl **DGE;\n\n  StmtIteratorBase(Stmt **s) : stmt(s) {}\n  StmtIteratorBase(const VariableArrayType *t);\n  StmtIteratorBase(Decl **dgi, Decl **dge);\n  StmtIteratorBase() : stmt(nullptr) {}\n\n  bool inDeclGroup() const {\n    return (RawVAPtr & Flags) == DeclGroupMode;\n  }\n\n  bool inSizeOfTypeVA() const {\n    return (RawVAPtr & Flags) == SizeOfTypeVAMode;\n  }\n\n  bool inStmt() const {\n    return (RawVAPtr & Flags) == StmtMode;\n  }\n\n  const VariableArrayType *getVAPtr() const {\n    return reinterpret_cast<const VariableArrayType*>(RawVAPtr & ~Flags);\n  }\n\n  void setVAPtr(const VariableArrayType *P) {\n    assert(inDeclGroup() || inSizeOfTypeVA());\n    RawVAPtr = reinterpret_cast<uintptr_t>(P) | (RawVAPtr & Flags);\n  }\n\n  void NextDecl(bool ImmediateAdvance = true);\n  bool HandleDecl(Decl* D);\n  void NextVA();\n\n  Stmt*& GetDeclExpr() const;\n};\n\ntemplate <typename DERIVED, typename REFERENCE>\nclass StmtIteratorImpl : public StmtIteratorBase,\n                         public std::iterator<std::forward_iterator_tag,\n                                              REFERENCE, ptrdiff_t,\n                                              REFERENCE, REFERENCE> {\nprotected:\n  StmtIteratorImpl(const StmtIteratorBase& RHS) : StmtIteratorBase(RHS) {}\n\npublic:\n  StmtIteratorImpl() = default;\n  StmtIteratorImpl(Stmt **s) : StmtIteratorBase(s) {}\n  StmtIteratorImpl(Decl **dgi, Decl **dge) : StmtIteratorBase(dgi, dge) {}\n  StmtIteratorImpl(const VariableArrayType *t) : StmtIteratorBase(t) {}\n\n  DERIVED& operator++() {\n    if (inStmt())\n      ++stmt;\n    else if (getVAPtr())\n      NextVA();\n    else\n      NextDecl();\n\n    return static_cast<DERIVED&>(*this);\n  }\n\n  DERIVED operator++(int) {\n    DERIVED tmp = static_cast<DERIVED&>(*this);\n    operator++();\n    return tmp;\n  }\n\n  friend bool operator==(const DERIVED &LHS, const DERIVED &RHS) {\n    return LHS.stmt == RHS.stmt && LHS.DGI == RHS.DGI &&\n           LHS.RawVAPtr == RHS.RawVAPtr;\n  }\n\n  friend bool operator!=(const DERIVED &LHS, const DERIVED &RHS) {\n    return !(LHS == RHS);\n  }\n\n  REFERENCE operator*() const {\n    return inStmt() ? *stmt : GetDeclExpr();\n  }\n\n  REFERENCE operator->() const { return operator*(); }\n};\n\nstruct ConstStmtIterator;\n\nstruct StmtIterator : public StmtIteratorImpl<StmtIterator, Stmt*&> {\n  explicit StmtIterator() = default;\n  StmtIterator(Stmt** S) : StmtIteratorImpl<StmtIterator, Stmt*&>(S) {}\n  StmtIterator(Decl** dgi, Decl** dge)\n      : StmtIteratorImpl<StmtIterator, Stmt*&>(dgi, dge) {}\n  StmtIterator(const VariableArrayType *t)\n      : StmtIteratorImpl<StmtIterator, Stmt*&>(t) {}\n\nprivate:\n  StmtIterator(const StmtIteratorBase &RHS)\n      : StmtIteratorImpl<StmtIterator, Stmt *&>(RHS) {}\n\n  inline friend StmtIterator\n  cast_away_const(const ConstStmtIterator &RHS);\n};\n\nstruct ConstStmtIterator : public StmtIteratorImpl<ConstStmtIterator,\n                                                   const Stmt*> {\n  explicit ConstStmtIterator() = default;\n  ConstStmtIterator(const StmtIterator& RHS)\n      : StmtIteratorImpl<ConstStmtIterator, const Stmt*>(RHS) {}\n\n  ConstStmtIterator(Stmt * const *S)\n      : StmtIteratorImpl<ConstStmtIterator, const Stmt *>(\n            const_cast<Stmt **>(S)) {}\n};\n\ninline StmtIterator cast_away_const(const ConstStmtIterator &RHS) {\n  return RHS;\n}\n\n} // namespace clang\n\n#endif // LLVM_CLANG_AST_STMTITERATOR_H\n"}, "13": {"id": 13, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/Type.h", "content": "//===- Type.h - C Language Family Type Representation -----------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n/// \\file\n/// C Language Family Type Representation\n///\n/// This file defines the clang::Type interface and subclasses, used to\n/// represent types for languages in the C family.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_AST_TYPE_H\n#define LLVM_CLANG_AST_TYPE_H\n\n#include \"clang/AST/DependenceFlags.h\"\n#include \"clang/AST/NestedNameSpecifier.h\"\n#include \"clang/AST/TemplateName.h\"\n#include \"clang/Basic/AddressSpaces.h\"\n#include \"clang/Basic/AttrKinds.h\"\n#include \"clang/Basic/Diagnostic.h\"\n#include \"clang/Basic/ExceptionSpecificationType.h\"\n#include \"clang/Basic/LLVM.h\"\n#include \"clang/Basic/Linkage.h\"\n#include \"clang/Basic/PartialDiagnostic.h\"\n#include \"clang/Basic/SourceLocation.h\"\n#include \"clang/Basic/Specifiers.h\"\n#include \"clang/Basic/Visibility.h\"\n#include \"llvm/ADT/APInt.h\"\n#include \"llvm/ADT/APSInt.h\"\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/ADT/FoldingSet.h\"\n#include \"llvm/ADT/None.h\"\n#include \"llvm/ADT/Optional.h\"\n#include \"llvm/ADT/PointerIntPair.h\"\n#include \"llvm/ADT/PointerUnion.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/ADT/Twine.h\"\n#include \"llvm/ADT/iterator_range.h\"\n#include \"llvm/Support/Casting.h\"\n#include \"llvm/Support/Compiler.h\"\n#include \"llvm/Support/ErrorHandling.h\"\n#include \"llvm/Support/PointerLikeTypeTraits.h\"\n#include \"llvm/Support/TrailingObjects.h\"\n#include \"llvm/Support/type_traits.h\"\n#include <cassert>\n#include <cstddef>\n#include <cstdint>\n#include <cstring>\n#include <string>\n#include <type_traits>\n#include <utility>\n\nnamespace clang {\n\nclass ExtQuals;\nclass QualType;\nclass ConceptDecl;\nclass TagDecl;\nclass TemplateParameterList;\nclass Type;\n\nenum {\n  TypeAlignmentInBits = 4,\n  TypeAlignment = 1 << TypeAlignmentInBits\n};\n\nnamespace serialization {\n  template <class T> class AbstractTypeReader;\n  template <class T> class AbstractTypeWriter;\n}\n\n} // namespace clang\n\nnamespace llvm {\n\n  template <typename T>\n  struct PointerLikeTypeTraits;\n  template<>\n  struct PointerLikeTypeTraits< ::clang::Type*> {\n    static inline void *getAsVoidPointer(::clang::Type *P) { return P; }\n\n    static inline ::clang::Type *getFromVoidPointer(void *P) {\n      return static_cast< ::clang::Type*>(P);\n    }\n\n    static constexpr int NumLowBitsAvailable = clang::TypeAlignmentInBits;\n  };\n\n  template<>\n  struct PointerLikeTypeTraits< ::clang::ExtQuals*> {\n    static inline void *getAsVoidPointer(::clang::ExtQuals *P) { return P; }\n\n    static inline ::clang::ExtQuals *getFromVoidPointer(void *P) {\n      return static_cast< ::clang::ExtQuals*>(P);\n    }\n\n    static constexpr int NumLowBitsAvailable = clang::TypeAlignmentInBits;\n  };\n\n} // namespace llvm\n\nnamespace clang {\n\nclass ASTContext;\ntemplate <typename> class CanQual;\nclass CXXRecordDecl;\nclass DeclContext;\nclass EnumDecl;\nclass Expr;\nclass ExtQualsTypeCommonBase;\nclass FunctionDecl;\nclass IdentifierInfo;\nclass NamedDecl;\nclass ObjCInterfaceDecl;\nclass ObjCProtocolDecl;\nclass ObjCTypeParamDecl;\nstruct PrintingPolicy;\nclass RecordDecl;\nclass Stmt;\nclass TagDecl;\nclass TemplateArgument;\nclass TemplateArgumentListInfo;\nclass TemplateArgumentLoc;\nclass TemplateTypeParmDecl;\nclass TypedefNameDecl;\nclass UnresolvedUsingTypenameDecl;\n\nusing CanQualType = CanQual<Type>;\n\n// Provide forward declarations for all of the *Type classes.\n#define TYPE(Class, Base) class Class##Type;\n#include \"clang/AST/TypeNodes.inc\"\n\n/// The collection of all-type qualifiers we support.\n/// Clang supports five independent qualifiers:\n/// * C99: const, volatile, and restrict\n/// * MS: __unaligned\n/// * Embedded C (TR18037): address spaces\n/// * Objective C: the GC attributes (none, weak, or strong)\nclass Qualifiers {\npublic:\n  enum TQ { // NOTE: These flags must be kept in sync with DeclSpec::TQ.\n    Const    = 0x1,\n    Restrict = 0x2,\n    Volatile = 0x4,\n    CVRMask = Const | Volatile | Restrict\n  };\n\n  enum GC {\n    GCNone = 0,\n    Weak,\n    Strong\n  };\n\n  enum ObjCLifetime {\n    /// There is no lifetime qualification on this type.\n    OCL_None,\n\n    /// This object can be modified without requiring retains or\n    /// releases.\n    OCL_ExplicitNone,\n\n    /// Assigning into this object requires the old value to be\n    /// released and the new value to be retained.  The timing of the\n    /// release of the old value is inexact: it may be moved to\n    /// immediately after the last known point where the value is\n    /// live.\n    OCL_Strong,\n\n    /// Reading or writing from this object requires a barrier call.\n    OCL_Weak,\n\n    /// Assigning into this object requires a lifetime extension.\n    OCL_Autoreleasing\n  };\n\n  enum {\n    /// The maximum supported address space number.\n    /// 23 bits should be enough for anyone.\n    MaxAddressSpace = 0x7fffffu,\n\n    /// The width of the \"fast\" qualifier mask.\n    FastWidth = 3,\n\n    /// The fast qualifier mask.\n    FastMask = (1 << FastWidth) - 1\n  };\n\n  /// Returns the common set of qualifiers while removing them from\n  /// the given sets.\n  static Qualifiers removeCommonQualifiers(Qualifiers &L, Qualifiers &R) {\n    // If both are only CVR-qualified, bit operations are sufficient.\n    if (!(L.Mask & ~CVRMask) && !(R.Mask & ~CVRMask)) {\n      Qualifiers Q;\n      Q.Mask = L.Mask & R.Mask;\n      L.Mask &= ~Q.Mask;\n      R.Mask &= ~Q.Mask;\n      return Q;\n    }\n\n    Qualifiers Q;\n    unsigned CommonCRV = L.getCVRQualifiers() & R.getCVRQualifiers();\n    Q.addCVRQualifiers(CommonCRV);\n    L.removeCVRQualifiers(CommonCRV);\n    R.removeCVRQualifiers(CommonCRV);\n\n    if (L.getObjCGCAttr() == R.getObjCGCAttr()) {\n      Q.setObjCGCAttr(L.getObjCGCAttr());\n      L.removeObjCGCAttr();\n      R.removeObjCGCAttr();\n    }\n\n    if (L.getObjCLifetime() == R.getObjCLifetime()) {\n      Q.setObjCLifetime(L.getObjCLifetime());\n      L.removeObjCLifetime();\n      R.removeObjCLifetime();\n    }\n\n    if (L.getAddressSpace() == R.getAddressSpace()) {\n      Q.setAddressSpace(L.getAddressSpace());\n      L.removeAddressSpace();\n      R.removeAddressSpace();\n    }\n    return Q;\n  }\n\n  static Qualifiers fromFastMask(unsigned Mask) {\n    Qualifiers Qs;\n    Qs.addFastQualifiers(Mask);\n    return Qs;\n  }\n\n  static Qualifiers fromCVRMask(unsigned CVR) {\n    Qualifiers Qs;\n    Qs.addCVRQualifiers(CVR);\n    return Qs;\n  }\n\n  static Qualifiers fromCVRUMask(unsigned CVRU) {\n    Qualifiers Qs;\n    Qs.addCVRUQualifiers(CVRU);\n    return Qs;\n  }\n\n  // Deserialize qualifiers from an opaque representation.\n  static Qualifiers fromOpaqueValue(unsigned opaque) {\n    Qualifiers Qs;\n    Qs.Mask = opaque;\n    return Qs;\n  }\n\n  // Serialize these qualifiers into an opaque representation.\n  unsigned getAsOpaqueValue() const {\n    return Mask;\n  }\n\n  bool hasConst() const { return Mask & Const; }\n  bool hasOnlyConst() const { return Mask == Const; }\n  void removeConst() { Mask &= ~Const; }\n  void addConst() { Mask |= Const; }\n\n  bool hasVolatile() const { return Mask & Volatile; }\n  bool hasOnlyVolatile() const { return Mask == Volatile; }\n  void removeVolatile() { Mask &= ~Volatile; }\n  void addVolatile() { Mask |= Volatile; }\n\n  bool hasRestrict() const { return Mask & Restrict; }\n  bool hasOnlyRestrict() const { return Mask == Restrict; }\n  void removeRestrict() { Mask &= ~Restrict; }\n  void addRestrict() { Mask |= Restrict; }\n\n  bool hasCVRQualifiers() const { return getCVRQualifiers(); }\n  unsigned getCVRQualifiers() const { return Mask & CVRMask; }\n  unsigned getCVRUQualifiers() const { return Mask & (CVRMask | UMask); }\n\n  void setCVRQualifiers(unsigned mask) {\n    assert(!(mask & ~CVRMask) && \"bitmask contains non-CVR bits\");\n    Mask = (Mask & ~CVRMask) | mask;\n  }\n  void removeCVRQualifiers(unsigned mask) {\n    assert(!(mask & ~CVRMask) && \"bitmask contains non-CVR bits\");\n    Mask &= ~mask;\n  }\n  void removeCVRQualifiers() {\n    removeCVRQualifiers(CVRMask);\n  }\n  void addCVRQualifiers(unsigned mask) {\n    assert(!(mask & ~CVRMask) && \"bitmask contains non-CVR bits\");\n    Mask |= mask;\n  }\n  void addCVRUQualifiers(unsigned mask) {\n    assert(!(mask & ~CVRMask & ~UMask) && \"bitmask contains non-CVRU bits\");\n    Mask |= mask;\n  }\n\n  bool hasUnaligned() const { return Mask & UMask; }\n  void setUnaligned(bool flag) {\n    Mask = (Mask & ~UMask) | (flag ? UMask : 0);\n  }\n  void removeUnaligned() { Mask &= ~UMask; }\n  void addUnaligned() { Mask |= UMask; }\n\n  bool hasObjCGCAttr() const { return Mask & GCAttrMask; }\n  GC getObjCGCAttr() const { return GC((Mask & GCAttrMask) >> GCAttrShift); }\n  void setObjCGCAttr(GC type) {\n    Mask = (Mask & ~GCAttrMask) | (type << GCAttrShift);\n  }\n  void removeObjCGCAttr() { setObjCGCAttr(GCNone); }\n  void addObjCGCAttr(GC type) {\n    assert(type);\n    setObjCGCAttr(type);\n  }\n  Qualifiers withoutObjCGCAttr() const {\n    Qualifiers qs = *this;\n    qs.removeObjCGCAttr();\n    return qs;\n  }\n  Qualifiers withoutObjCLifetime() const {\n    Qualifiers qs = *this;\n    qs.removeObjCLifetime();\n    return qs;\n  }\n  Qualifiers withoutAddressSpace() const {\n    Qualifiers qs = *this;\n    qs.removeAddressSpace();\n    return qs;\n  }\n\n  bool hasObjCLifetime() const { return Mask & LifetimeMask; }\n  ObjCLifetime getObjCLifetime() const {\n    return ObjCLifetime((Mask & LifetimeMask) >> LifetimeShift);\n  }\n  void setObjCLifetime(ObjCLifetime type) {\n    Mask = (Mask & ~LifetimeMask) | (type << LifetimeShift);\n  }\n  void removeObjCLifetime() { setObjCLifetime(OCL_None); }\n  void addObjCLifetime(ObjCLifetime type) {\n    assert(type);\n    assert(!hasObjCLifetime());\n    Mask |= (type << LifetimeShift);\n  }\n\n  /// True if the lifetime is neither None or ExplicitNone.\n  bool hasNonTrivialObjCLifetime() const {\n    ObjCLifetime lifetime = getObjCLifetime();\n    return (lifetime > OCL_ExplicitNone);\n  }\n\n  /// True if the lifetime is either strong or weak.\n  bool hasStrongOrWeakObjCLifetime() const {\n    ObjCLifetime lifetime = getObjCLifetime();\n    return (lifetime == OCL_Strong || lifetime == OCL_Weak);\n  }\n\n  bool hasAddressSpace() const { return Mask & AddressSpaceMask; }\n  LangAS getAddressSpace() const {\n    return static_cast<LangAS>(Mask >> AddressSpaceShift);\n  }\n  bool hasTargetSpecificAddressSpace() const {\n    return isTargetAddressSpace(getAddressSpace());\n  }\n  /// Get the address space attribute value to be printed by diagnostics.\n  unsigned getAddressSpaceAttributePrintValue() const {\n    auto Addr = getAddressSpace();\n    // This function is not supposed to be used with language specific\n    // address spaces. If that happens, the diagnostic message should consider\n    // printing the QualType instead of the address space value.\n    assert(Addr == LangAS::Default || hasTargetSpecificAddressSpace());\n    if (Addr != LangAS::Default)\n      return toTargetAddressSpace(Addr);\n    // TODO: The diagnostic messages where Addr may be 0 should be fixed\n    // since it cannot differentiate the situation where 0 denotes the default\n    // address space or user specified __attribute__((address_space(0))).\n    return 0;\n  }\n  void setAddressSpace(LangAS space) {\n    assert((unsigned)space <= MaxAddressSpace);\n    Mask = (Mask & ~AddressSpaceMask)\n         | (((uint32_t) space) << AddressSpaceShift);\n  }\n  void removeAddressSpace() { setAddressSpace(LangAS::Default); }\n  void addAddressSpace(LangAS space) {\n    assert(space != LangAS::Default);\n    setAddressSpace(space);\n  }\n\n  // Fast qualifiers are those that can be allocated directly\n  // on a QualType object.\n  bool hasFastQualifiers() const { return getFastQualifiers(); }\n  unsigned getFastQualifiers() const { return Mask & FastMask; }\n  void setFastQualifiers(unsigned mask) {\n    assert(!(mask & ~FastMask) && \"bitmask contains non-fast qualifier bits\");\n    Mask = (Mask & ~FastMask) | mask;\n  }\n  void removeFastQualifiers(unsigned mask) {\n    assert(!(mask & ~FastMask) && \"bitmask contains non-fast qualifier bits\");\n    Mask &= ~mask;\n  }\n  void removeFastQualifiers() {\n    removeFastQualifiers(FastMask);\n  }\n  void addFastQualifiers(unsigned mask) {\n    assert(!(mask & ~FastMask) && \"bitmask contains non-fast qualifier bits\");\n    Mask |= mask;\n  }\n\n  /// Return true if the set contains any qualifiers which require an ExtQuals\n  /// node to be allocated.\n  bool hasNonFastQualifiers() const { return Mask & ~FastMask; }\n  Qualifiers getNonFastQualifiers() const {\n    Qualifiers Quals = *this;\n    Quals.setFastQualifiers(0);\n    return Quals;\n  }\n\n  /// Return true if the set contains any qualifiers.\n  bool hasQualifiers() const { return Mask; }\n  bool empty() const { return !Mask; }\n\n  /// Add the qualifiers from the given set to this set.\n  void addQualifiers(Qualifiers Q) {\n    // If the other set doesn't have any non-boolean qualifiers, just\n    // bit-or it in.\n    if (!(Q.Mask & ~CVRMask))\n      Mask |= Q.Mask;\n    else {\n      Mask |= (Q.Mask & CVRMask);\n      if (Q.hasAddressSpace())\n        addAddressSpace(Q.getAddressSpace());\n      if (Q.hasObjCGCAttr())\n        addObjCGCAttr(Q.getObjCGCAttr());\n      if (Q.hasObjCLifetime())\n        addObjCLifetime(Q.getObjCLifetime());\n    }\n  }\n\n  /// Remove the qualifiers from the given set from this set.\n  void removeQualifiers(Qualifiers Q) {\n    // If the other set doesn't have any non-boolean qualifiers, just\n    // bit-and the inverse in.\n    if (!(Q.Mask & ~CVRMask))\n      Mask &= ~Q.Mask;\n    else {\n      Mask &= ~(Q.Mask & CVRMask);\n      if (getObjCGCAttr() == Q.getObjCGCAttr())\n        removeObjCGCAttr();\n      if (getObjCLifetime() == Q.getObjCLifetime())\n        removeObjCLifetime();\n      if (getAddressSpace() == Q.getAddressSpace())\n        removeAddressSpace();\n    }\n  }\n\n  /// Add the qualifiers from the given set to this set, given that\n  /// they don't conflict.\n  void addConsistentQualifiers(Qualifiers qs) {\n    assert(getAddressSpace() == qs.getAddressSpace() ||\n           !hasAddressSpace() || !qs.hasAddressSpace());\n    assert(getObjCGCAttr() == qs.getObjCGCAttr() ||\n           !hasObjCGCAttr() || !qs.hasObjCGCAttr());\n    assert(getObjCLifetime() == qs.getObjCLifetime() ||\n           !hasObjCLifetime() || !qs.hasObjCLifetime());\n    Mask |= qs.Mask;\n  }\n\n  /// Returns true if address space A is equal to or a superset of B.\n  /// OpenCL v2.0 defines conversion rules (OpenCLC v2.0 s6.5.5) and notion of\n  /// overlapping address spaces.\n  /// CL1.1 or CL1.2:\n  ///   every address space is a superset of itself.\n  /// CL2.0 adds:\n  ///   __generic is a superset of any address space except for __constant.\n  static bool isAddressSpaceSupersetOf(LangAS A, LangAS B) {\n    // Address spaces must match exactly.\n    return A == B ||\n           // Otherwise in OpenCLC v2.0 s6.5.5: every address space except\n           // for __constant can be used as __generic.\n           (A == LangAS::opencl_generic && B != LangAS::opencl_constant) ||\n           // We also define global_device and global_host address spaces,\n           // to distinguish global pointers allocated on host from pointers\n           // allocated on device, which are a subset of __global.\n           (A == LangAS::opencl_global && (B == LangAS::opencl_global_device ||\n                                           B == LangAS::opencl_global_host)) ||\n           // Consider pointer size address spaces to be equivalent to default.\n           ((isPtrSizeAddressSpace(A) || A == LangAS::Default) &&\n            (isPtrSizeAddressSpace(B) || B == LangAS::Default));\n  }\n\n  /// Returns true if the address space in these qualifiers is equal to or\n  /// a superset of the address space in the argument qualifiers.\n  bool isAddressSpaceSupersetOf(Qualifiers other) const {\n    return isAddressSpaceSupersetOf(getAddressSpace(), other.getAddressSpace());\n  }\n\n  /// Determines if these qualifiers compatibly include another set.\n  /// Generally this answers the question of whether an object with the other\n  /// qualifiers can be safely used as an object with these qualifiers.\n  bool compatiblyIncludes(Qualifiers other) const {\n    return isAddressSpaceSupersetOf(other) &&\n           // ObjC GC qualifiers can match, be added, or be removed, but can't\n           // be changed.\n           (getObjCGCAttr() == other.getObjCGCAttr() || !hasObjCGCAttr() ||\n            !other.hasObjCGCAttr()) &&\n           // ObjC lifetime qualifiers must match exactly.\n           getObjCLifetime() == other.getObjCLifetime() &&\n           // CVR qualifiers may subset.\n           (((Mask & CVRMask) | (other.Mask & CVRMask)) == (Mask & CVRMask)) &&\n           // U qualifier may superset.\n           (!other.hasUnaligned() || hasUnaligned());\n  }\n\n  /// Determines if these qualifiers compatibly include another set of\n  /// qualifiers from the narrow perspective of Objective-C ARC lifetime.\n  ///\n  /// One set of Objective-C lifetime qualifiers compatibly includes the other\n  /// if the lifetime qualifiers match, or if both are non-__weak and the\n  /// including set also contains the 'const' qualifier, or both are non-__weak\n  /// and one is None (which can only happen in non-ARC modes).\n  bool compatiblyIncludesObjCLifetime(Qualifiers other) const {\n    if (getObjCLifetime() == other.getObjCLifetime())\n      return true;\n\n    if (getObjCLifetime() == OCL_Weak || other.getObjCLifetime() == OCL_Weak)\n      return false;\n\n    if (getObjCLifetime() == OCL_None || other.getObjCLifetime() == OCL_None)\n      return true;\n\n    return hasConst();\n  }\n\n  /// Determine whether this set of qualifiers is a strict superset of\n  /// another set of qualifiers, not considering qualifier compatibility.\n  bool isStrictSupersetOf(Qualifiers Other) const;\n\n  bool operator==(Qualifiers Other) const { return Mask == Other.Mask; }\n  bool operator!=(Qualifiers Other) const { return Mask != Other.Mask; }\n\n  explicit operator bool() const { return hasQualifiers(); }\n\n  Qualifiers &operator+=(Qualifiers R) {\n    addQualifiers(R);\n    return *this;\n  }\n\n  // Union two qualifier sets.  If an enumerated qualifier appears\n  // in both sets, use the one from the right.\n  friend Qualifiers operator+(Qualifiers L, Qualifiers R) {\n    L += R;\n    return L;\n  }\n\n  Qualifiers &operator-=(Qualifiers R) {\n    removeQualifiers(R);\n    return *this;\n  }\n\n  /// Compute the difference between two qualifier sets.\n  friend Qualifiers operator-(Qualifiers L, Qualifiers R) {\n    L -= R;\n    return L;\n  }\n\n  std::string getAsString() const;\n  std::string getAsString(const PrintingPolicy &Policy) const;\n\n  static std::string getAddrSpaceAsString(LangAS AS);\n\n  bool isEmptyWhenPrinted(const PrintingPolicy &Policy) const;\n  void print(raw_ostream &OS, const PrintingPolicy &Policy,\n             bool appendSpaceIfNonEmpty = false) const;\n\n  void Profile(llvm::FoldingSetNodeID &ID) const {\n    ID.AddInteger(Mask);\n  }\n\nprivate:\n  // bits:     |0 1 2|3|4 .. 5|6  ..  8|9   ...   31|\n  //           |C R V|U|GCAttr|Lifetime|AddressSpace|\n  uint32_t Mask = 0;\n\n  static const uint32_t UMask = 0x8;\n  static const uint32_t UShift = 3;\n  static const uint32_t GCAttrMask = 0x30;\n  static const uint32_t GCAttrShift = 4;\n  static const uint32_t LifetimeMask = 0x1C0;\n  static const uint32_t LifetimeShift = 6;\n  static const uint32_t AddressSpaceMask =\n      ~(CVRMask | UMask | GCAttrMask | LifetimeMask);\n  static const uint32_t AddressSpaceShift = 9;\n};\n\n/// A std::pair-like structure for storing a qualified type split\n/// into its local qualifiers and its locally-unqualified type.\nstruct SplitQualType {\n  /// The locally-unqualified type.\n  const Type *Ty = nullptr;\n\n  /// The local qualifiers.\n  Qualifiers Quals;\n\n  SplitQualType() = default;\n  SplitQualType(const Type *ty, Qualifiers qs) : Ty(ty), Quals(qs) {}\n\n  SplitQualType getSingleStepDesugaredType() const; // end of this file\n\n  // Make std::tie work.\n  std::pair<const Type *,Qualifiers> asPair() const {\n    return std::pair<const Type *, Qualifiers>(Ty, Quals);\n  }\n\n  friend bool operator==(SplitQualType a, SplitQualType b) {\n    return a.Ty == b.Ty && a.Quals == b.Quals;\n  }\n  friend bool operator!=(SplitQualType a, SplitQualType b) {\n    return a.Ty != b.Ty || a.Quals != b.Quals;\n  }\n};\n\n/// The kind of type we are substituting Objective-C type arguments into.\n///\n/// The kind of substitution affects the replacement of type parameters when\n/// no concrete type information is provided, e.g., when dealing with an\n/// unspecialized type.\nenum class ObjCSubstitutionContext {\n  /// An ordinary type.\n  Ordinary,\n\n  /// The result type of a method or function.\n  Result,\n\n  /// The parameter type of a method or function.\n  Parameter,\n\n  /// The type of a property.\n  Property,\n\n  /// The superclass of a type.\n  Superclass,\n};\n\n/// A (possibly-)qualified type.\n///\n/// For efficiency, we don't store CV-qualified types as nodes on their\n/// own: instead each reference to a type stores the qualifiers.  This\n/// greatly reduces the number of nodes we need to allocate for types (for\n/// example we only need one for 'int', 'const int', 'volatile int',\n/// 'const volatile int', etc).\n///\n/// As an added efficiency bonus, instead of making this a pair, we\n/// just store the two bits we care about in the low bits of the\n/// pointer.  To handle the packing/unpacking, we make QualType be a\n/// simple wrapper class that acts like a smart pointer.  A third bit\n/// indicates whether there are extended qualifiers present, in which\n/// case the pointer points to a special structure.\nclass QualType {\n  friend class QualifierCollector;\n\n  // Thankfully, these are efficiently composable.\n  llvm::PointerIntPair<llvm::PointerUnion<const Type *, const ExtQuals *>,\n                       Qualifiers::FastWidth> Value;\n\n  const ExtQuals *getExtQualsUnsafe() const {\n    return Value.getPointer().get<const ExtQuals*>();\n  }\n\n  const Type *getTypePtrUnsafe() const {\n    return Value.getPointer().get<const Type*>();\n  }\n\n  const ExtQualsTypeCommonBase *getCommonPtr() const {\n    assert(!isNull() && \"Cannot retrieve a NULL type pointer\");\n    auto CommonPtrVal = reinterpret_cast<uintptr_t>(Value.getOpaqueValue());\n    CommonPtrVal &= ~(uintptr_t)((1 << TypeAlignmentInBits) - 1);\n    return reinterpret_cast<ExtQualsTypeCommonBase*>(CommonPtrVal);\n  }\n\npublic:\n  QualType() = default;\n  QualType(const Type *Ptr, unsigned Quals) : Value(Ptr, Quals) {}\n  QualType(const ExtQuals *Ptr, unsigned Quals) : Value(Ptr, Quals) {}\n\n  unsigned getLocalFastQualifiers() const { return Value.getInt(); }\n  void setLocalFastQualifiers(unsigned Quals) { Value.setInt(Quals); }\n\n  /// Retrieves a pointer to the underlying (unqualified) type.\n  ///\n  /// This function requires that the type not be NULL. If the type might be\n  /// NULL, use the (slightly less efficient) \\c getTypePtrOrNull().\n  const Type *getTypePtr() const;\n\n  const Type *getTypePtrOrNull() const;\n\n  /// Retrieves a pointer to the name of the base type.\n  const IdentifierInfo *getBaseTypeIdentifier() const;\n\n  /// Divides a QualType into its unqualified type and a set of local\n  /// qualifiers.\n  SplitQualType split() const;\n\n  void *getAsOpaquePtr() const { return Value.getOpaqueValue(); }\n\n  static QualType getFromOpaquePtr(const void *Ptr) {\n    QualType T;\n    T.Value.setFromOpaqueValue(const_cast<void*>(Ptr));\n    return T;\n  }\n\n  const Type &operator*() const {\n    return *getTypePtr();\n  }\n\n  const Type *operator->() const {\n    return getTypePtr();\n  }\n\n  bool isCanonical() const;\n  bool isCanonicalAsParam() const;\n\n  /// Return true if this QualType doesn't point to a type yet.\n  bool isNull() const {\n    return Value.getPointer().isNull();\n  }\n\n  /// Determine whether this particular QualType instance has the\n  /// \"const\" qualifier set, without looking through typedefs that may have\n  /// added \"const\" at a different level.\n  bool isLocalConstQualified() const {\n    return (getLocalFastQualifiers() & Qualifiers::Const);\n  }\n\n  /// Determine whether this type is const-qualified.\n  bool isConstQualified() const;\n\n  /// Determine whether this particular QualType instance has the\n  /// \"restrict\" qualifier set, without looking through typedefs that may have\n  /// added \"restrict\" at a different level.\n  bool isLocalRestrictQualified() const {\n    return (getLocalFastQualifiers() & Qualifiers::Restrict);\n  }\n\n  /// Determine whether this type is restrict-qualified.\n  bool isRestrictQualified() const;\n\n  /// Determine whether this particular QualType instance has the\n  /// \"volatile\" qualifier set, without looking through typedefs that may have\n  /// added \"volatile\" at a different level.\n  bool isLocalVolatileQualified() const {\n    return (getLocalFastQualifiers() & Qualifiers::Volatile);\n  }\n\n  /// Determine whether this type is volatile-qualified.\n  bool isVolatileQualified() const;\n\n  /// Determine whether this particular QualType instance has any\n  /// qualifiers, without looking through any typedefs that might add\n  /// qualifiers at a different level.\n  bool hasLocalQualifiers() const {\n    return getLocalFastQualifiers() || hasLocalNonFastQualifiers();\n  }\n\n  /// Determine whether this type has any qualifiers.\n  bool hasQualifiers() const;\n\n  /// Determine whether this particular QualType instance has any\n  /// \"non-fast\" qualifiers, e.g., those that are stored in an ExtQualType\n  /// instance.\n  bool hasLocalNonFastQualifiers() const {\n    return Value.getPointer().is<const ExtQuals*>();\n  }\n\n  /// Retrieve the set of qualifiers local to this particular QualType\n  /// instance, not including any qualifiers acquired through typedefs or\n  /// other sugar.\n  Qualifiers getLocalQualifiers() const;\n\n  /// Retrieve the set of qualifiers applied to this type.\n  Qualifiers getQualifiers() const;\n\n  /// Retrieve the set of CVR (const-volatile-restrict) qualifiers\n  /// local to this particular QualType instance, not including any qualifiers\n  /// acquired through typedefs or other sugar.\n  unsigned getLocalCVRQualifiers() const {\n    return getLocalFastQualifiers();\n  }\n\n  /// Retrieve the set of CVR (const-volatile-restrict) qualifiers\n  /// applied to this type.\n  unsigned getCVRQualifiers() const;\n\n  bool isConstant(const ASTContext& Ctx) const {\n    return QualType::isConstant(*this, Ctx);\n  }\n\n  /// Determine whether this is a Plain Old Data (POD) type (C++ 3.9p10).\n  bool isPODType(const ASTContext &Context) const;\n\n  /// Return true if this is a POD type according to the rules of the C++98\n  /// standard, regardless of the current compilation's language.\n  bool isCXX98PODType(const ASTContext &Context) const;\n\n  /// Return true if this is a POD type according to the more relaxed rules\n  /// of the C++11 standard, regardless of the current compilation's language.\n  /// (C++0x [basic.types]p9). Note that, unlike\n  /// CXXRecordDecl::isCXX11StandardLayout, this takes DRs into account.\n  bool isCXX11PODType(const ASTContext &Context) const;\n\n  /// Return true if this is a trivial type per (C++0x [basic.types]p9)\n  bool isTrivialType(const ASTContext &Context) const;\n\n  /// Return true if this is a trivially copyable type (C++0x [basic.types]p9)\n  bool isTriviallyCopyableType(const ASTContext &Context) const;\n\n\n  /// Returns true if it is a class and it might be dynamic.\n  bool mayBeDynamicClass() const;\n\n  /// Returns true if it is not a class or if the class might not be dynamic.\n  bool mayBeNotDynamicClass() const;\n\n  // Don't promise in the API that anything besides 'const' can be\n  // easily added.\n\n  /// Add the `const` type qualifier to this QualType.\n  void addConst() {\n    addFastQualifiers(Qualifiers::Const);\n  }\n  QualType withConst() const {\n    return withFastQualifiers(Qualifiers::Const);\n  }\n\n  /// Add the `volatile` type qualifier to this QualType.\n  void addVolatile() {\n    addFastQualifiers(Qualifiers::Volatile);\n  }\n  QualType withVolatile() const {\n    return withFastQualifiers(Qualifiers::Volatile);\n  }\n\n  /// Add the `restrict` qualifier to this QualType.\n  void addRestrict() {\n    addFastQualifiers(Qualifiers::Restrict);\n  }\n  QualType withRestrict() const {\n    return withFastQualifiers(Qualifiers::Restrict);\n  }\n\n  QualType withCVRQualifiers(unsigned CVR) const {\n    return withFastQualifiers(CVR);\n  }\n\n  void addFastQualifiers(unsigned TQs) {\n    assert(!(TQs & ~Qualifiers::FastMask)\n           && \"non-fast qualifier bits set in mask!\");\n    Value.setInt(Value.getInt() | TQs);\n  }\n\n  void removeLocalConst();\n  void removeLocalVolatile();\n  void removeLocalRestrict();\n  void removeLocalCVRQualifiers(unsigned Mask);\n\n  void removeLocalFastQualifiers() { Value.setInt(0); }\n  void removeLocalFastQualifiers(unsigned Mask) {\n    assert(!(Mask & ~Qualifiers::FastMask) && \"mask has non-fast qualifiers\");\n    Value.setInt(Value.getInt() & ~Mask);\n  }\n\n  // Creates a type with the given qualifiers in addition to any\n  // qualifiers already on this type.\n  QualType withFastQualifiers(unsigned TQs) const {\n    QualType T = *this;\n    T.addFastQualifiers(TQs);\n    return T;\n  }\n\n  // Creates a type with exactly the given fast qualifiers, removing\n  // any existing fast qualifiers.\n  QualType withExactLocalFastQualifiers(unsigned TQs) const {\n    return withoutLocalFastQualifiers().withFastQualifiers(TQs);\n  }\n\n  // Removes fast qualifiers, but leaves any extended qualifiers in place.\n  QualType withoutLocalFastQualifiers() const {\n    QualType T = *this;\n    T.removeLocalFastQualifiers();\n    return T;\n  }\n\n  QualType getCanonicalType() const;\n\n  /// Return this type with all of the instance-specific qualifiers\n  /// removed, but without removing any qualifiers that may have been applied\n  /// through typedefs.\n  QualType getLocalUnqualifiedType() const { return QualType(getTypePtr(), 0); }\n\n  /// Retrieve the unqualified variant of the given type,\n  /// removing as little sugar as possible.\n  ///\n  /// This routine looks through various kinds of sugar to find the\n  /// least-desugared type that is unqualified. For example, given:\n  ///\n  /// \\code\n  /// typedef int Integer;\n  /// typedef const Integer CInteger;\n  /// typedef CInteger DifferenceType;\n  /// \\endcode\n  ///\n  /// Executing \\c getUnqualifiedType() on the type \\c DifferenceType will\n  /// desugar until we hit the type \\c Integer, which has no qualifiers on it.\n  ///\n  /// The resulting type might still be qualified if it's sugar for an array\n  /// type.  To strip qualifiers even from within a sugared array type, use\n  /// ASTContext::getUnqualifiedArrayType.\n  inline QualType getUnqualifiedType() const;\n\n  /// Retrieve the unqualified variant of the given type, removing as little\n  /// sugar as possible.\n  ///\n  /// Like getUnqualifiedType(), but also returns the set of\n  /// qualifiers that were built up.\n  ///\n  /// The resulting type might still be qualified if it's sugar for an array\n  /// type.  To strip qualifiers even from within a sugared array type, use\n  /// ASTContext::getUnqualifiedArrayType.\n  inline SplitQualType getSplitUnqualifiedType() const;\n\n  /// Determine whether this type is more qualified than the other\n  /// given type, requiring exact equality for non-CVR qualifiers.\n  bool isMoreQualifiedThan(QualType Other) const;\n\n  /// Determine whether this type is at least as qualified as the other\n  /// given type, requiring exact equality for non-CVR qualifiers.\n  bool isAtLeastAsQualifiedAs(QualType Other) const;\n\n  QualType getNonReferenceType() const;\n\n  /// Determine the type of a (typically non-lvalue) expression with the\n  /// specified result type.\n  ///\n  /// This routine should be used for expressions for which the return type is\n  /// explicitly specified (e.g., in a cast or call) and isn't necessarily\n  /// an lvalue. It removes a top-level reference (since there are no\n  /// expressions of reference type) and deletes top-level cvr-qualifiers\n  /// from non-class types (in C++) or all types (in C).\n  QualType getNonLValueExprType(const ASTContext &Context) const;\n\n  /// Remove an outer pack expansion type (if any) from this type. Used as part\n  /// of converting the type of a declaration to the type of an expression that\n  /// references that expression. It's meaningless for an expression to have a\n  /// pack expansion type.\n  QualType getNonPackExpansionType() const;\n\n  /// Return the specified type with any \"sugar\" removed from\n  /// the type.  This takes off typedefs, typeof's etc.  If the outer level of\n  /// the type is already concrete, it returns it unmodified.  This is similar\n  /// to getting the canonical type, but it doesn't remove *all* typedefs.  For\n  /// example, it returns \"T*\" as \"T*\", (not as \"int*\"), because the pointer is\n  /// concrete.\n  ///\n  /// Qualifiers are left in place.\n  QualType getDesugaredType(const ASTContext &Context) const {\n    return getDesugaredType(*this, Context);\n  }\n\n  SplitQualType getSplitDesugaredType() const {\n    return getSplitDesugaredType(*this);\n  }\n\n  /// Return the specified type with one level of \"sugar\" removed from\n  /// the type.\n  ///\n  /// This routine takes off the first typedef, typeof, etc. If the outer level\n  /// of the type is already concrete, it returns it unmodified.\n  QualType getSingleStepDesugaredType(const ASTContext &Context) const {\n    return getSingleStepDesugaredTypeImpl(*this, Context);\n  }\n\n  /// Returns the specified type after dropping any\n  /// outer-level parentheses.\n  QualType IgnoreParens() const {\n    if (isa<ParenType>(*this))\n      return QualType::IgnoreParens(*this);\n    return *this;\n  }\n\n  /// Indicate whether the specified types and qualifiers are identical.\n  friend bool operator==(const QualType &LHS, const QualType &RHS) {\n    return LHS.Value == RHS.Value;\n  }\n  friend bool operator!=(const QualType &LHS, const QualType &RHS) {\n    return LHS.Value != RHS.Value;\n  }\n  friend bool operator<(const QualType &LHS, const QualType &RHS) {\n    return LHS.Value < RHS.Value;\n  }\n\n  static std::string getAsString(SplitQualType split,\n                                 const PrintingPolicy &Policy) {\n    return getAsString(split.Ty, split.Quals, Policy);\n  }\n  static std::string getAsString(const Type *ty, Qualifiers qs,\n                                 const PrintingPolicy &Policy);\n\n  std::string getAsString() const;\n  std::string getAsString(const PrintingPolicy &Policy) const;\n\n  void print(raw_ostream &OS, const PrintingPolicy &Policy,\n             const Twine &PlaceHolder = Twine(),\n             unsigned Indentation = 0) const;\n\n  static void print(SplitQualType split, raw_ostream &OS,\n                    const PrintingPolicy &policy, const Twine &PlaceHolder,\n                    unsigned Indentation = 0) {\n    return print(split.Ty, split.Quals, OS, policy, PlaceHolder, Indentation);\n  }\n\n  static void print(const Type *ty, Qualifiers qs,\n                    raw_ostream &OS, const PrintingPolicy &policy,\n                    const Twine &PlaceHolder,\n                    unsigned Indentation = 0);\n\n  void getAsStringInternal(std::string &Str,\n                           const PrintingPolicy &Policy) const;\n\n  static void getAsStringInternal(SplitQualType split, std::string &out,\n                                  const PrintingPolicy &policy) {\n    return getAsStringInternal(split.Ty, split.Quals, out, policy);\n  }\n\n  static void getAsStringInternal(const Type *ty, Qualifiers qs,\n                                  std::string &out,\n                                  const PrintingPolicy &policy);\n\n  class StreamedQualTypeHelper {\n    const QualType &T;\n    const PrintingPolicy &Policy;\n    const Twine &PlaceHolder;\n    unsigned Indentation;\n\n  public:\n    StreamedQualTypeHelper(const QualType &T, const PrintingPolicy &Policy,\n                           const Twine &PlaceHolder, unsigned Indentation)\n        : T(T), Policy(Policy), PlaceHolder(PlaceHolder),\n          Indentation(Indentation) {}\n\n    friend raw_ostream &operator<<(raw_ostream &OS,\n                                   const StreamedQualTypeHelper &SQT) {\n      SQT.T.print(OS, SQT.Policy, SQT.PlaceHolder, SQT.Indentation);\n      return OS;\n    }\n  };\n\n  StreamedQualTypeHelper stream(const PrintingPolicy &Policy,\n                                const Twine &PlaceHolder = Twine(),\n                                unsigned Indentation = 0) const {\n    return StreamedQualTypeHelper(*this, Policy, PlaceHolder, Indentation);\n  }\n\n  void dump(const char *s) const;\n  void dump() const;\n  void dump(llvm::raw_ostream &OS, const ASTContext &Context) const;\n\n  void Profile(llvm::FoldingSetNodeID &ID) const {\n    ID.AddPointer(getAsOpaquePtr());\n  }\n\n  /// Check if this type has any address space qualifier.\n  inline bool hasAddressSpace() const;\n\n  /// Return the address space of this type.\n  inline LangAS getAddressSpace() const;\n\n  /// Returns true if address space qualifiers overlap with T address space\n  /// qualifiers.\n  /// OpenCL C defines conversion rules for pointers to different address spaces\n  /// and notion of overlapping address spaces.\n  /// CL1.1 or CL1.2:\n  ///   address spaces overlap iff they are they same.\n  /// OpenCL C v2.0 s6.5.5 adds:\n  ///   __generic overlaps with any address space except for __constant.\n  bool isAddressSpaceOverlapping(QualType T) const {\n    Qualifiers Q = getQualifiers();\n    Qualifiers TQ = T.getQualifiers();\n    // Address spaces overlap if at least one of them is a superset of another\n    return Q.isAddressSpaceSupersetOf(TQ) || TQ.isAddressSpaceSupersetOf(Q);\n  }\n\n  /// Returns gc attribute of this type.\n  inline Qualifiers::GC getObjCGCAttr() const;\n\n  /// true when Type is objc's weak.\n  bool isObjCGCWeak() const {\n    return getObjCGCAttr() == Qualifiers::Weak;\n  }\n\n  /// true when Type is objc's strong.\n  bool isObjCGCStrong() const {\n    return getObjCGCAttr() == Qualifiers::Strong;\n  }\n\n  /// Returns lifetime attribute of this type.\n  Qualifiers::ObjCLifetime getObjCLifetime() const {\n    return getQualifiers().getObjCLifetime();\n  }\n\n  bool hasNonTrivialObjCLifetime() const {\n    return getQualifiers().hasNonTrivialObjCLifetime();\n  }\n\n  bool hasStrongOrWeakObjCLifetime() const {\n    return getQualifiers().hasStrongOrWeakObjCLifetime();\n  }\n\n  // true when Type is objc's weak and weak is enabled but ARC isn't.\n  bool isNonWeakInMRRWithObjCWeak(const ASTContext &Context) const;\n\n  enum PrimitiveDefaultInitializeKind {\n    /// The type does not fall into any of the following categories. Note that\n    /// this case is zero-valued so that values of this enum can be used as a\n    /// boolean condition for non-triviality.\n    PDIK_Trivial,\n\n    /// The type is an Objective-C retainable pointer type that is qualified\n    /// with the ARC __strong qualifier.\n    PDIK_ARCStrong,\n\n    /// The type is an Objective-C retainable pointer type that is qualified\n    /// with the ARC __weak qualifier.\n    PDIK_ARCWeak,\n\n    /// The type is a struct containing a field whose type is not PCK_Trivial.\n    PDIK_Struct\n  };\n\n  /// Functions to query basic properties of non-trivial C struct types.\n\n  /// Check if this is a non-trivial type that would cause a C struct\n  /// transitively containing this type to be non-trivial to default initialize\n  /// and return the kind.\n  PrimitiveDefaultInitializeKind\n  isNonTrivialToPrimitiveDefaultInitialize() const;\n\n  enum PrimitiveCopyKind {\n    /// The type does not fall into any of the following categories. Note that\n    /// this case is zero-valued so that values of this enum can be used as a\n    /// boolean condition for non-triviality.\n    PCK_Trivial,\n\n    /// The type would be trivial except that it is volatile-qualified. Types\n    /// that fall into one of the other non-trivial cases may additionally be\n    /// volatile-qualified.\n    PCK_VolatileTrivial,\n\n    /// The type is an Objective-C retainable pointer type that is qualified\n    /// with the ARC __strong qualifier.\n    PCK_ARCStrong,\n\n    /// The type is an Objective-C retainable pointer type that is qualified\n    /// with the ARC __weak qualifier.\n    PCK_ARCWeak,\n\n    /// The type is a struct containing a field whose type is neither\n    /// PCK_Trivial nor PCK_VolatileTrivial.\n    /// Note that a C++ struct type does not necessarily match this; C++ copying\n    /// semantics are too complex to express here, in part because they depend\n    /// on the exact constructor or assignment operator that is chosen by\n    /// overload resolution to do the copy.\n    PCK_Struct\n  };\n\n  /// Check if this is a non-trivial type that would cause a C struct\n  /// transitively containing this type to be non-trivial to copy and return the\n  /// kind.\n  PrimitiveCopyKind isNonTrivialToPrimitiveCopy() const;\n\n  /// Check if this is a non-trivial type that would cause a C struct\n  /// transitively containing this type to be non-trivial to destructively\n  /// move and return the kind. Destructive move in this context is a C++-style\n  /// move in which the source object is placed in a valid but unspecified state\n  /// after it is moved, as opposed to a truly destructive move in which the\n  /// source object is placed in an uninitialized state.\n  PrimitiveCopyKind isNonTrivialToPrimitiveDestructiveMove() const;\n\n  enum DestructionKind {\n    DK_none,\n    DK_cxx_destructor,\n    DK_objc_strong_lifetime,\n    DK_objc_weak_lifetime,\n    DK_nontrivial_c_struct\n  };\n\n  /// Returns a nonzero value if objects of this type require\n  /// non-trivial work to clean up after.  Non-zero because it's\n  /// conceivable that qualifiers (objc_gc(weak)?) could make\n  /// something require destruction.\n  DestructionKind isDestructedType() const {\n    return isDestructedTypeImpl(*this);\n  }\n\n  /// Check if this is or contains a C union that is non-trivial to\n  /// default-initialize, which is a union that has a member that is non-trivial\n  /// to default-initialize. If this returns true,\n  /// isNonTrivialToPrimitiveDefaultInitialize returns PDIK_Struct.\n  bool hasNonTrivialToPrimitiveDefaultInitializeCUnion() const;\n\n  /// Check if this is or contains a C union that is non-trivial to destruct,\n  /// which is a union that has a member that is non-trivial to destruct. If\n  /// this returns true, isDestructedType returns DK_nontrivial_c_struct.\n  bool hasNonTrivialToPrimitiveDestructCUnion() const;\n\n  /// Check if this is or contains a C union that is non-trivial to copy, which\n  /// is a union that has a member that is non-trivial to copy. If this returns\n  /// true, isNonTrivialToPrimitiveCopy returns PCK_Struct.\n  bool hasNonTrivialToPrimitiveCopyCUnion() const;\n\n  /// Determine whether expressions of the given type are forbidden\n  /// from being lvalues in C.\n  ///\n  /// The expression types that are forbidden to be lvalues are:\n  ///   - 'void', but not qualified void\n  ///   - function types\n  ///\n  /// The exact rule here is C99 6.3.2.1:\n  ///   An lvalue is an expression with an object type or an incomplete\n  ///   type other than void.\n  bool isCForbiddenLValueType() const;\n\n  /// Substitute type arguments for the Objective-C type parameters used in the\n  /// subject type.\n  ///\n  /// \\param ctx ASTContext in which the type exists.\n  ///\n  /// \\param typeArgs The type arguments that will be substituted for the\n  /// Objective-C type parameters in the subject type, which are generally\n  /// computed via \\c Type::getObjCSubstitutions. If empty, the type\n  /// parameters will be replaced with their bounds or id/Class, as appropriate\n  /// for the context.\n  ///\n  /// \\param context The context in which the subject type was written.\n  ///\n  /// \\returns the resulting type.\n  QualType substObjCTypeArgs(ASTContext &ctx,\n                             ArrayRef<QualType> typeArgs,\n                             ObjCSubstitutionContext context) const;\n\n  /// Substitute type arguments from an object type for the Objective-C type\n  /// parameters used in the subject type.\n  ///\n  /// This operation combines the computation of type arguments for\n  /// substitution (\\c Type::getObjCSubstitutions) with the actual process of\n  /// substitution (\\c QualType::substObjCTypeArgs) for the convenience of\n  /// callers that need to perform a single substitution in isolation.\n  ///\n  /// \\param objectType The type of the object whose member type we're\n  /// substituting into. For example, this might be the receiver of a message\n  /// or the base of a property access.\n  ///\n  /// \\param dc The declaration context from which the subject type was\n  /// retrieved, which indicates (for example) which type parameters should\n  /// be substituted.\n  ///\n  /// \\param context The context in which the subject type was written.\n  ///\n  /// \\returns the subject type after replacing all of the Objective-C type\n  /// parameters with their corresponding arguments.\n  QualType substObjCMemberType(QualType objectType,\n                               const DeclContext *dc,\n                               ObjCSubstitutionContext context) const;\n\n  /// Strip Objective-C \"__kindof\" types from the given type.\n  QualType stripObjCKindOfType(const ASTContext &ctx) const;\n\n  /// Remove all qualifiers including _Atomic.\n  QualType getAtomicUnqualifiedType() const;\n\nprivate:\n  // These methods are implemented in a separate translation unit;\n  // \"static\"-ize them to avoid creating temporary QualTypes in the\n  // caller.\n  static bool isConstant(QualType T, const ASTContext& Ctx);\n  static QualType getDesugaredType(QualType T, const ASTContext &Context);\n  static SplitQualType getSplitDesugaredType(QualType T);\n  static SplitQualType getSplitUnqualifiedTypeImpl(QualType type);\n  static QualType getSingleStepDesugaredTypeImpl(QualType type,\n                                                 const ASTContext &C);\n  static QualType IgnoreParens(QualType T);\n  static DestructionKind isDestructedTypeImpl(QualType type);\n\n  /// Check if \\param RD is or contains a non-trivial C union.\n  static bool hasNonTrivialToPrimitiveDefaultInitializeCUnion(const RecordDecl *RD);\n  static bool hasNonTrivialToPrimitiveDestructCUnion(const RecordDecl *RD);\n  static bool hasNonTrivialToPrimitiveCopyCUnion(const RecordDecl *RD);\n};\n\n} // namespace clang\n\nnamespace llvm {\n\n/// Implement simplify_type for QualType, so that we can dyn_cast from QualType\n/// to a specific Type class.\ntemplate<> struct simplify_type< ::clang::QualType> {\n  using SimpleType = const ::clang::Type *;\n\n  static SimpleType getSimplifiedValue(::clang::QualType Val) {\n    return Val.getTypePtr();\n  }\n};\n\n// Teach SmallPtrSet that QualType is \"basically a pointer\".\ntemplate<>\nstruct PointerLikeTypeTraits<clang::QualType> {\n  static inline void *getAsVoidPointer(clang::QualType P) {\n    return P.getAsOpaquePtr();\n  }\n\n  static inline clang::QualType getFromVoidPointer(void *P) {\n    return clang::QualType::getFromOpaquePtr(P);\n  }\n\n  // Various qualifiers go in low bits.\n  static constexpr int NumLowBitsAvailable = 0;\n};\n\n} // namespace llvm\n\nnamespace clang {\n\n/// Base class that is common to both the \\c ExtQuals and \\c Type\n/// classes, which allows \\c QualType to access the common fields between the\n/// two.\nclass ExtQualsTypeCommonBase {\n  friend class ExtQuals;\n  friend class QualType;\n  friend class Type;\n\n  /// The \"base\" type of an extended qualifiers type (\\c ExtQuals) or\n  /// a self-referential pointer (for \\c Type).\n  ///\n  /// This pointer allows an efficient mapping from a QualType to its\n  /// underlying type pointer.\n  const Type *const BaseType;\n\n  /// The canonical type of this type.  A QualType.\n  QualType CanonicalType;\n\n  ExtQualsTypeCommonBase(const Type *baseType, QualType canon)\n      : BaseType(baseType), CanonicalType(canon) {}\n};\n\n/// We can encode up to four bits in the low bits of a\n/// type pointer, but there are many more type qualifiers that we want\n/// to be able to apply to an arbitrary type.  Therefore we have this\n/// struct, intended to be heap-allocated and used by QualType to\n/// store qualifiers.\n///\n/// The current design tags the 'const', 'restrict', and 'volatile' qualifiers\n/// in three low bits on the QualType pointer; a fourth bit records whether\n/// the pointer is an ExtQuals node. The extended qualifiers (address spaces,\n/// Objective-C GC attributes) are much more rare.\nclass ExtQuals : public ExtQualsTypeCommonBase, public llvm::FoldingSetNode {\n  // NOTE: changing the fast qualifiers should be straightforward as\n  // long as you don't make 'const' non-fast.\n  // 1. Qualifiers:\n  //    a) Modify the bitmasks (Qualifiers::TQ and DeclSpec::TQ).\n  //       Fast qualifiers must occupy the low-order bits.\n  //    b) Update Qualifiers::FastWidth and FastMask.\n  // 2. QualType:\n  //    a) Update is{Volatile,Restrict}Qualified(), defined inline.\n  //    b) Update remove{Volatile,Restrict}, defined near the end of\n  //       this header.\n  // 3. ASTContext:\n  //    a) Update get{Volatile,Restrict}Type.\n\n  /// The immutable set of qualifiers applied by this node. Always contains\n  /// extended qualifiers.\n  Qualifiers Quals;\n\n  ExtQuals *this_() { return this; }\n\npublic:\n  ExtQuals(const Type *baseType, QualType canon, Qualifiers quals)\n      : ExtQualsTypeCommonBase(baseType,\n                               canon.isNull() ? QualType(this_(), 0) : canon),\n        Quals(quals) {\n    assert(Quals.hasNonFastQualifiers()\n           && \"ExtQuals created with no fast qualifiers\");\n    assert(!Quals.hasFastQualifiers()\n           && \"ExtQuals created with fast qualifiers\");\n  }\n\n  Qualifiers getQualifiers() const { return Quals; }\n\n  bool hasObjCGCAttr() const { return Quals.hasObjCGCAttr(); }\n  Qualifiers::GC getObjCGCAttr() const { return Quals.getObjCGCAttr(); }\n\n  bool hasObjCLifetime() const { return Quals.hasObjCLifetime(); }\n  Qualifiers::ObjCLifetime getObjCLifetime() const {\n    return Quals.getObjCLifetime();\n  }\n\n  bool hasAddressSpace() const { return Quals.hasAddressSpace(); }\n  LangAS getAddressSpace() const { return Quals.getAddressSpace(); }\n\n  const Type *getBaseType() const { return BaseType; }\n\npublic:\n  void Profile(llvm::FoldingSetNodeID &ID) const {\n    Profile(ID, getBaseType(), Quals);\n  }\n\n  static void Profile(llvm::FoldingSetNodeID &ID,\n                      const Type *BaseType,\n                      Qualifiers Quals) {\n    assert(!Quals.hasFastQualifiers() && \"fast qualifiers in ExtQuals hash!\");\n    ID.AddPointer(BaseType);\n    Quals.Profile(ID);\n  }\n};\n\n/// The kind of C++11 ref-qualifier associated with a function type.\n/// This determines whether a member function's \"this\" object can be an\n/// lvalue, rvalue, or neither.\nenum RefQualifierKind {\n  /// No ref-qualifier was provided.\n  RQ_None = 0,\n\n  /// An lvalue ref-qualifier was provided (\\c &).\n  RQ_LValue,\n\n  /// An rvalue ref-qualifier was provided (\\c &&).\n  RQ_RValue\n};\n\n/// Which keyword(s) were used to create an AutoType.\nenum class AutoTypeKeyword {\n  /// auto\n  Auto,\n\n  /// decltype(auto)\n  DecltypeAuto,\n\n  /// __auto_type (GNU extension)\n  GNUAutoType\n};\n\n/// The base class of the type hierarchy.\n///\n/// A central concept with types is that each type always has a canonical\n/// type.  A canonical type is the type with any typedef names stripped out\n/// of it or the types it references.  For example, consider:\n///\n///  typedef int  foo;\n///  typedef foo* bar;\n///    'int *'    'foo *'    'bar'\n///\n/// There will be a Type object created for 'int'.  Since int is canonical, its\n/// CanonicalType pointer points to itself.  There is also a Type for 'foo' (a\n/// TypedefType).  Its CanonicalType pointer points to the 'int' Type.  Next\n/// there is a PointerType that represents 'int*', which, like 'int', is\n/// canonical.  Finally, there is a PointerType type for 'foo*' whose canonical\n/// type is 'int*', and there is a TypedefType for 'bar', whose canonical type\n/// is also 'int*'.\n///\n/// Non-canonical types are useful for emitting diagnostics, without losing\n/// information about typedefs being used.  Canonical types are useful for type\n/// comparisons (they allow by-pointer equality tests) and useful for reasoning\n/// about whether something has a particular form (e.g. is a function type),\n/// because they implicitly, recursively, strip all typedefs out of a type.\n///\n/// Types, once created, are immutable.\n///\nclass alignas(8) Type : public ExtQualsTypeCommonBase {\npublic:\n  enum TypeClass {\n#define TYPE(Class, Base) Class,\n#define LAST_TYPE(Class) TypeLast = Class\n#define ABSTRACT_TYPE(Class, Base)\n#include \"clang/AST/TypeNodes.inc\"\n  };\n\nprivate:\n  /// Bitfields required by the Type class.\n  class TypeBitfields {\n    friend class Type;\n    template <class T> friend class TypePropertyCache;\n\n    /// TypeClass bitfield - Enum that specifies what subclass this belongs to.\n    unsigned TC : 8;\n\n    /// Store information on the type dependency.\n    unsigned Dependence : llvm::BitWidth<TypeDependence>;\n\n    /// True if the cache (i.e. the bitfields here starting with\n    /// 'Cache') is valid.\n    mutable unsigned CacheValid : 1;\n\n    /// Linkage of this type.\n    mutable unsigned CachedLinkage : 3;\n\n    /// Whether this type involves and local or unnamed types.\n    mutable unsigned CachedLocalOrUnnamed : 1;\n\n    /// Whether this type comes from an AST file.\n    mutable unsigned FromAST : 1;\n\n    bool isCacheValid() const {\n      return CacheValid;\n    }\n\n    Linkage getLinkage() const {\n      assert(isCacheValid() && \"getting linkage from invalid cache\");\n      return static_cast<Linkage>(CachedLinkage);\n    }\n\n    bool hasLocalOrUnnamedType() const {\n      assert(isCacheValid() && \"getting linkage from invalid cache\");\n      return CachedLocalOrUnnamed;\n    }\n  };\n  enum { NumTypeBits = 8 + llvm::BitWidth<TypeDependence> + 6 };\n\nprotected:\n  // These classes allow subclasses to somewhat cleanly pack bitfields\n  // into Type.\n\n  class ArrayTypeBitfields {\n    friend class ArrayType;\n\n    unsigned : NumTypeBits;\n\n    /// CVR qualifiers from declarations like\n    /// 'int X[static restrict 4]'. For function parameters only.\n    unsigned IndexTypeQuals : 3;\n\n    /// Storage class qualifiers from declarations like\n    /// 'int X[static restrict 4]'. For function parameters only.\n    /// Actually an ArrayType::ArraySizeModifier.\n    unsigned SizeModifier : 3;\n  };\n\n  class ConstantArrayTypeBitfields {\n    friend class ConstantArrayType;\n\n    unsigned : NumTypeBits + 3 + 3;\n\n    /// Whether we have a stored size expression.\n    unsigned HasStoredSizeExpr : 1;\n  };\n\n  class BuiltinTypeBitfields {\n    friend class BuiltinType;\n\n    unsigned : NumTypeBits;\n\n    /// The kind (BuiltinType::Kind) of builtin type this is.\n    unsigned Kind : 8;\n  };\n\n  /// FunctionTypeBitfields store various bits belonging to FunctionProtoType.\n  /// Only common bits are stored here. Additional uncommon bits are stored\n  /// in a trailing object after FunctionProtoType.\n  class FunctionTypeBitfields {\n    friend class FunctionProtoType;\n    friend class FunctionType;\n\n    unsigned : NumTypeBits;\n\n    /// Extra information which affects how the function is called, like\n    /// regparm and the calling convention.\n    unsigned ExtInfo : 13;\n\n    /// The ref-qualifier associated with a \\c FunctionProtoType.\n    ///\n    /// This is a value of type \\c RefQualifierKind.\n    unsigned RefQualifier : 2;\n\n    /// Used only by FunctionProtoType, put here to pack with the\n    /// other bitfields.\n    /// The qualifiers are part of FunctionProtoType because...\n    ///\n    /// C++ 8.3.5p4: The return type, the parameter type list and the\n    /// cv-qualifier-seq, [...], are part of the function type.\n    unsigned FastTypeQuals : Qualifiers::FastWidth;\n    /// Whether this function has extended Qualifiers.\n    unsigned HasExtQuals : 1;\n\n    /// The number of parameters this function has, not counting '...'.\n    /// According to [implimits] 8 bits should be enough here but this is\n    /// somewhat easy to exceed with metaprogramming and so we would like to\n    /// keep NumParams as wide as reasonably possible.\n    unsigned NumParams : 16;\n\n    /// The type of exception specification this function has.\n    unsigned ExceptionSpecType : 4;\n\n    /// Whether this function has extended parameter information.\n    unsigned HasExtParameterInfos : 1;\n\n    /// Whether the function is variadic.\n    unsigned Variadic : 1;\n\n    /// Whether this function has a trailing return type.\n    unsigned HasTrailingReturn : 1;\n  };\n\n  class ObjCObjectTypeBitfields {\n    friend class ObjCObjectType;\n\n    unsigned : NumTypeBits;\n\n    /// The number of type arguments stored directly on this object type.\n    unsigned NumTypeArgs : 7;\n\n    /// The number of protocols stored directly on this object type.\n    unsigned NumProtocols : 6;\n\n    /// Whether this is a \"kindof\" type.\n    unsigned IsKindOf : 1;\n  };\n\n  class ReferenceTypeBitfields {\n    friend class ReferenceType;\n\n    unsigned : NumTypeBits;\n\n    /// True if the type was originally spelled with an lvalue sigil.\n    /// This is never true of rvalue references but can also be false\n    /// on lvalue references because of C++0x [dcl.typedef]p9,\n    /// as follows:\n    ///\n    ///   typedef int &ref;    // lvalue, spelled lvalue\n    ///   typedef int &&rvref; // rvalue\n    ///   ref &a;              // lvalue, inner ref, spelled lvalue\n    ///   ref &&a;             // lvalue, inner ref\n    ///   rvref &a;            // lvalue, inner ref, spelled lvalue\n    ///   rvref &&a;           // rvalue, inner ref\n    unsigned SpelledAsLValue : 1;\n\n    /// True if the inner type is a reference type.  This only happens\n    /// in non-canonical forms.\n    unsigned InnerRef : 1;\n  };\n\n  class TypeWithKeywordBitfields {\n    friend class TypeWithKeyword;\n\n    unsigned : NumTypeBits;\n\n    /// An ElaboratedTypeKeyword.  8 bits for efficient access.\n    unsigned Keyword : 8;\n  };\n\n  enum { NumTypeWithKeywordBits = 8 };\n\n  class ElaboratedTypeBitfields {\n    friend class ElaboratedType;\n\n    unsigned : NumTypeBits;\n    unsigned : NumTypeWithKeywordBits;\n\n    /// Whether the ElaboratedType has a trailing OwnedTagDecl.\n    unsigned HasOwnedTagDecl : 1;\n  };\n\n  class VectorTypeBitfields {\n    friend class VectorType;\n    friend class DependentVectorType;\n\n    unsigned : NumTypeBits;\n\n    /// The kind of vector, either a generic vector type or some\n    /// target-specific vector type such as for AltiVec or Neon.\n    unsigned VecKind : 3;\n    /// The number of elements in the vector.\n    uint32_t NumElements;\n  };\n\n  class AttributedTypeBitfields {\n    friend class AttributedType;\n\n    unsigned : NumTypeBits;\n\n    /// An AttributedType::Kind\n    unsigned AttrKind : 32 - NumTypeBits;\n  };\n\n  class AutoTypeBitfields {\n    friend class AutoType;\n\n    unsigned : NumTypeBits;\n\n    /// Was this placeholder type spelled as 'auto', 'decltype(auto)',\n    /// or '__auto_type'?  AutoTypeKeyword value.\n    unsigned Keyword : 2;\n\n    /// The number of template arguments in the type-constraints, which is\n    /// expected to be able to hold at least 1024 according to [implimits].\n    /// However as this limit is somewhat easy to hit with template\n    /// metaprogramming we'd prefer to keep it as large as possible.\n    /// At the moment it has been left as a non-bitfield since this type\n    /// safely fits in 64 bits as an unsigned, so there is no reason to\n    /// introduce the performance impact of a bitfield.\n    unsigned NumArgs;\n  };\n\n  class SubstTemplateTypeParmPackTypeBitfields {\n    friend class SubstTemplateTypeParmPackType;\n\n    unsigned : NumTypeBits;\n\n    /// The number of template arguments in \\c Arguments, which is\n    /// expected to be able to hold at least 1024 according to [implimits].\n    /// However as this limit is somewhat easy to hit with template\n    /// metaprogramming we'd prefer to keep it as large as possible.\n    /// At the moment it has been left as a non-bitfield since this type\n    /// safely fits in 64 bits as an unsigned, so there is no reason to\n    /// introduce the performance impact of a bitfield.\n    unsigned NumArgs;\n  };\n\n  class TemplateSpecializationTypeBitfields {\n    friend class TemplateSpecializationType;\n\n    unsigned : NumTypeBits;\n\n    /// Whether this template specialization type is a substituted type alias.\n    unsigned TypeAlias : 1;\n\n    /// The number of template arguments named in this class template\n    /// specialization, which is expected to be able to hold at least 1024\n    /// according to [implimits]. However, as this limit is somewhat easy to\n    /// hit with template metaprogramming we'd prefer to keep it as large\n    /// as possible. At the moment it has been left as a non-bitfield since\n    /// this type safely fits in 64 bits as an unsigned, so there is no reason\n    /// to introduce the performance impact of a bitfield.\n    unsigned NumArgs;\n  };\n\n  class DependentTemplateSpecializationTypeBitfields {\n    friend class DependentTemplateSpecializationType;\n\n    unsigned : NumTypeBits;\n    unsigned : NumTypeWithKeywordBits;\n\n    /// The number of template arguments named in this class template\n    /// specialization, which is expected to be able to hold at least 1024\n    /// according to [implimits]. However, as this limit is somewhat easy to\n    /// hit with template metaprogramming we'd prefer to keep it as large\n    /// as possible. At the moment it has been left as a non-bitfield since\n    /// this type safely fits in 64 bits as an unsigned, so there is no reason\n    /// to introduce the performance impact of a bitfield.\n    unsigned NumArgs;\n  };\n\n  class PackExpansionTypeBitfields {\n    friend class PackExpansionType;\n\n    unsigned : NumTypeBits;\n\n    /// The number of expansions that this pack expansion will\n    /// generate when substituted (+1), which is expected to be able to\n    /// hold at least 1024 according to [implimits]. However, as this limit\n    /// is somewhat easy to hit with template metaprogramming we'd prefer to\n    /// keep it as large as possible. At the moment it has been left as a\n    /// non-bitfield since this type safely fits in 64 bits as an unsigned, so\n    /// there is no reason to introduce the performance impact of a bitfield.\n    ///\n    /// This field will only have a non-zero value when some of the parameter\n    /// packs that occur within the pattern have been substituted but others\n    /// have not.\n    unsigned NumExpansions;\n  };\n\n  union {\n    TypeBitfields TypeBits;\n    ArrayTypeBitfields ArrayTypeBits;\n    ConstantArrayTypeBitfields ConstantArrayTypeBits;\n    AttributedTypeBitfields AttributedTypeBits;\n    AutoTypeBitfields AutoTypeBits;\n    BuiltinTypeBitfields BuiltinTypeBits;\n    FunctionTypeBitfields FunctionTypeBits;\n    ObjCObjectTypeBitfields ObjCObjectTypeBits;\n    ReferenceTypeBitfields ReferenceTypeBits;\n    TypeWithKeywordBitfields TypeWithKeywordBits;\n    ElaboratedTypeBitfields ElaboratedTypeBits;\n    VectorTypeBitfields VectorTypeBits;\n    SubstTemplateTypeParmPackTypeBitfields SubstTemplateTypeParmPackTypeBits;\n    TemplateSpecializationTypeBitfields TemplateSpecializationTypeBits;\n    DependentTemplateSpecializationTypeBitfields\n      DependentTemplateSpecializationTypeBits;\n    PackExpansionTypeBitfields PackExpansionTypeBits;\n  };\n\nprivate:\n  template <class T> friend class TypePropertyCache;\n\n  /// Set whether this type comes from an AST file.\n  void setFromAST(bool V = true) const {\n    TypeBits.FromAST = V;\n  }\n\nprotected:\n  friend class ASTContext;\n\n  Type(TypeClass tc, QualType canon, TypeDependence Dependence)\n      : ExtQualsTypeCommonBase(this,\n                               canon.isNull() ? QualType(this_(), 0) : canon) {\n    static_assert(sizeof(*this) <= 8 + sizeof(ExtQualsTypeCommonBase),\n                  \"changing bitfields changed sizeof(Type)!\");\n    static_assert(alignof(decltype(*this)) % sizeof(void *) == 0,\n                  \"Insufficient alignment!\");\n    TypeBits.TC = tc;\n    TypeBits.Dependence = static_cast<unsigned>(Dependence);\n    TypeBits.CacheValid = false;\n    TypeBits.CachedLocalOrUnnamed = false;\n    TypeBits.CachedLinkage = NoLinkage;\n    TypeBits.FromAST = false;\n  }\n\n  // silence VC++ warning C4355: 'this' : used in base member initializer list\n  Type *this_() { return this; }\n\n  void setDependence(TypeDependence D) {\n    TypeBits.Dependence = static_cast<unsigned>(D);\n  }\n\n  void addDependence(TypeDependence D) { setDependence(getDependence() | D); }\n\npublic:\n  friend class ASTReader;\n  friend class ASTWriter;\n  template <class T> friend class serialization::AbstractTypeReader;\n  template <class T> friend class serialization::AbstractTypeWriter;\n\n  Type(const Type &) = delete;\n  Type(Type &&) = delete;\n  Type &operator=(const Type &) = delete;\n  Type &operator=(Type &&) = delete;\n\n  TypeClass getTypeClass() const { return static_cast<TypeClass>(TypeBits.TC); }\n\n  /// Whether this type comes from an AST file.\n  bool isFromAST() const { return TypeBits.FromAST; }\n\n  /// Whether this type is or contains an unexpanded parameter\n  /// pack, used to support C++0x variadic templates.\n  ///\n  /// A type that contains a parameter pack shall be expanded by the\n  /// ellipsis operator at some point. For example, the typedef in the\n  /// following example contains an unexpanded parameter pack 'T':\n  ///\n  /// \\code\n  /// template<typename ...T>\n  /// struct X {\n  ///   typedef T* pointer_types; // ill-formed; T is a parameter pack.\n  /// };\n  /// \\endcode\n  ///\n  /// Note that this routine does not specify which\n  bool containsUnexpandedParameterPack() const {\n    return getDependence() & TypeDependence::UnexpandedPack;\n  }\n\n  /// Determines if this type would be canonical if it had no further\n  /// qualification.\n  bool isCanonicalUnqualified() const {\n    return CanonicalType == QualType(this, 0);\n  }\n\n  /// Pull a single level of sugar off of this locally-unqualified type.\n  /// Users should generally prefer SplitQualType::getSingleStepDesugaredType()\n  /// or QualType::getSingleStepDesugaredType(const ASTContext&).\n  QualType getLocallyUnqualifiedSingleStepDesugaredType() const;\n\n  /// As an extension, we classify types as one of \"sized\" or \"sizeless\";\n  /// every type is one or the other.  Standard types are all sized;\n  /// sizeless types are purely an extension.\n  ///\n  /// Sizeless types contain data with no specified size, alignment,\n  /// or layout.\n  bool isSizelessType() const;\n  bool isSizelessBuiltinType() const;\n\n  /// Determines if this is a sizeless type supported by the\n  /// 'arm_sve_vector_bits' type attribute, which can be applied to a single\n  /// SVE vector or predicate, excluding tuple types such as svint32x4_t.\n  bool isVLSTBuiltinType() const;\n\n  /// Returns the representative type for the element of an SVE builtin type.\n  /// This is used to represent fixed-length SVE vectors created with the\n  /// 'arm_sve_vector_bits' type attribute as VectorType.\n  QualType getSveEltType(const ASTContext &Ctx) const;\n\n  /// Types are partitioned into 3 broad categories (C99 6.2.5p1):\n  /// object types, function types, and incomplete types.\n\n  /// Return true if this is an incomplete type.\n  /// A type that can describe objects, but which lacks information needed to\n  /// determine its size (e.g. void, or a fwd declared struct). Clients of this\n  /// routine will need to determine if the size is actually required.\n  ///\n  /// Def If non-null, and the type refers to some kind of declaration\n  /// that can be completed (such as a C struct, C++ class, or Objective-C\n  /// class), will be set to the declaration.\n  bool isIncompleteType(NamedDecl **Def = nullptr) const;\n\n  /// Return true if this is an incomplete or object\n  /// type, in other words, not a function type.\n  bool isIncompleteOrObjectType() const {\n    return !isFunctionType();\n  }\n\n  /// Determine whether this type is an object type.\n  bool isObjectType() const {\n    // C++ [basic.types]p8:\n    //   An object type is a (possibly cv-qualified) type that is not a\n    //   function type, not a reference type, and not a void type.\n    return !isReferenceType() && !isFunctionType() && !isVoidType();\n  }\n\n  /// Return true if this is a literal type\n  /// (C++11 [basic.types]p10)\n  bool isLiteralType(const ASTContext &Ctx) const;\n\n  /// Determine if this type is a structural type, per C++20 [temp.param]p7.\n  bool isStructuralType() const;\n\n  /// Test if this type is a standard-layout type.\n  /// (C++0x [basic.type]p9)\n  bool isStandardLayoutType() const;\n\n  /// Helper methods to distinguish type categories. All type predicates\n  /// operate on the canonical type, ignoring typedefs and qualifiers.\n\n  /// Returns true if the type is a builtin type.\n  bool isBuiltinType() const;\n\n  /// Test for a particular builtin type.\n  bool isSpecificBuiltinType(unsigned K) const;\n\n  /// Test for a type which does not represent an actual type-system type but\n  /// is instead used as a placeholder for various convenient purposes within\n  /// Clang.  All such types are BuiltinTypes.\n  bool isPlaceholderType() const;\n  const BuiltinType *getAsPlaceholderType() const;\n\n  /// Test for a specific placeholder type.\n  bool isSpecificPlaceholderType(unsigned K) const;\n\n  /// Test for a placeholder type other than Overload; see\n  /// BuiltinType::isNonOverloadPlaceholderType.\n  bool isNonOverloadPlaceholderType() const;\n\n  /// isIntegerType() does *not* include complex integers (a GCC extension).\n  /// isComplexIntegerType() can be used to test for complex integers.\n  bool isIntegerType() const;     // C99 6.2.5p17 (int, char, bool, enum)\n  bool isEnumeralType() const;\n\n  /// Determine whether this type is a scoped enumeration type.\n  bool isScopedEnumeralType() const;\n  bool isBooleanType() const;\n  bool isCharType() const;\n  bool isWideCharType() const;\n  bool isChar8Type() const;\n  bool isChar16Type() const;\n  bool isChar32Type() const;\n  bool isAnyCharacterType() const;\n  bool isIntegralType(const ASTContext &Ctx) const;\n\n  /// Determine whether this type is an integral or enumeration type.\n  bool isIntegralOrEnumerationType() const;\n\n  /// Determine whether this type is an integral or unscoped enumeration type.\n  bool isIntegralOrUnscopedEnumerationType() const;\n  bool isUnscopedEnumerationType() const;\n\n  /// Floating point categories.\n  bool isRealFloatingType() const; // C99 6.2.5p10 (float, double, long double)\n  /// isComplexType() does *not* include complex integers (a GCC extension).\n  /// isComplexIntegerType() can be used to test for complex integers.\n  bool isComplexType() const;      // C99 6.2.5p11 (complex)\n  bool isAnyComplexType() const;   // C99 6.2.5p11 (complex) + Complex Int.\n  bool isFloatingType() const;     // C99 6.2.5p11 (real floating + complex)\n  bool isHalfType() const;         // OpenCL 6.1.1.1, NEON (IEEE 754-2008 half)\n  bool isFloat16Type() const;      // C11 extension ISO/IEC TS 18661\n  bool isBFloat16Type() const;\n  bool isFloat128Type() const;\n  bool isRealType() const;         // C99 6.2.5p17 (real floating + integer)\n  bool isArithmeticType() const;   // C99 6.2.5p18 (integer + floating)\n  bool isVoidType() const;         // C99 6.2.5p19\n  bool isScalarType() const;       // C99 6.2.5p21 (arithmetic + pointers)\n  bool isAggregateType() const;\n  bool isFundamentalType() const;\n  bool isCompoundType() const;\n\n  // Type Predicates: Check to see if this type is structurally the specified\n  // type, ignoring typedefs and qualifiers.\n  bool isFunctionType() const;\n  bool isFunctionNoProtoType() const { return getAs<FunctionNoProtoType>(); }\n  bool isFunctionProtoType() const { return getAs<FunctionProtoType>(); }\n  bool isPointerType() const;\n  bool isAnyPointerType() const;   // Any C pointer or ObjC object pointer\n  bool isBlockPointerType() const;\n  bool isVoidPointerType() const;\n  bool isReferenceType() const;\n  bool isLValueReferenceType() const;\n  bool isRValueReferenceType() const;\n  bool isObjectPointerType() const;\n  bool isFunctionPointerType() const;\n  bool isFunctionReferenceType() const;\n  bool isMemberPointerType() const;\n  bool isMemberFunctionPointerType() const;\n  bool isMemberDataPointerType() const;\n  bool isArrayType() const;\n  bool isConstantArrayType() const;\n  bool isIncompleteArrayType() const;\n  bool isVariableArrayType() const;\n  bool isDependentSizedArrayType() const;\n  bool isRecordType() const;\n  bool isClassType() const;\n  bool isStructureType() const;\n  bool isObjCBoxableRecordType() const;\n  bool isInterfaceType() const;\n  bool isStructureOrClassType() const;\n  bool isUnionType() const;\n  bool isComplexIntegerType() const;            // GCC _Complex integer type.\n  bool isVectorType() const;                    // GCC vector type.\n  bool isExtVectorType() const;                 // Extended vector type.\n  bool isMatrixType() const;                    // Matrix type.\n  bool isConstantMatrixType() const;            // Constant matrix type.\n  bool isDependentAddressSpaceType() const;     // value-dependent address space qualifier\n  bool isObjCObjectPointerType() const;         // pointer to ObjC object\n  bool isObjCRetainableType() const;            // ObjC object or block pointer\n  bool isObjCLifetimeType() const;              // (array of)* retainable type\n  bool isObjCIndirectLifetimeType() const;      // (pointer to)* lifetime type\n  bool isObjCNSObjectType() const;              // __attribute__((NSObject))\n  bool isObjCIndependentClassType() const;      // __attribute__((objc_independent_class))\n  // FIXME: change this to 'raw' interface type, so we can used 'interface' type\n  // for the common case.\n  bool isObjCObjectType() const;                // NSString or typeof(*(id)0)\n  bool isObjCQualifiedInterfaceType() const;    // NSString<foo>\n  bool isObjCQualifiedIdType() const;           // id<foo>\n  bool isObjCQualifiedClassType() const;        // Class<foo>\n  bool isObjCObjectOrInterfaceType() const;\n  bool isObjCIdType() const;                    // id\n  bool isDecltypeType() const;\n  /// Was this type written with the special inert-in-ARC __unsafe_unretained\n  /// qualifier?\n  ///\n  /// This approximates the answer to the following question: if this\n  /// translation unit were compiled in ARC, would this type be qualified\n  /// with __unsafe_unretained?\n  bool isObjCInertUnsafeUnretainedType() const {\n    return hasAttr(attr::ObjCInertUnsafeUnretained);\n  }\n\n  /// Whether the type is Objective-C 'id' or a __kindof type of an\n  /// object type, e.g., __kindof NSView * or __kindof id\n  /// <NSCopying>.\n  ///\n  /// \\param bound Will be set to the bound on non-id subtype types,\n  /// which will be (possibly specialized) Objective-C class type, or\n  /// null for 'id.\n  bool isObjCIdOrObjectKindOfType(const ASTContext &ctx,\n                                  const ObjCObjectType *&bound) const;\n\n  bool isObjCClassType() const;                 // Class\n\n  /// Whether the type is Objective-C 'Class' or a __kindof type of an\n  /// Class type, e.g., __kindof Class <NSCopying>.\n  ///\n  /// Unlike \\c isObjCIdOrObjectKindOfType, there is no relevant bound\n  /// here because Objective-C's type system cannot express \"a class\n  /// object for a subclass of NSFoo\".\n  bool isObjCClassOrClassKindOfType() const;\n\n  bool isBlockCompatibleObjCPointerType(ASTContext &ctx) const;\n  bool isObjCSelType() const;                 // Class\n  bool isObjCBuiltinType() const;               // 'id' or 'Class'\n  bool isObjCARCBridgableType() const;\n  bool isCARCBridgableType() const;\n  bool isTemplateTypeParmType() const;          // C++ template type parameter\n  bool isNullPtrType() const;                   // C++11 std::nullptr_t\n  bool isNothrowT() const;                      // C++   std::nothrow_t\n  bool isAlignValT() const;                     // C++17 std::align_val_t\n  bool isStdByteType() const;                   // C++17 std::byte\n  bool isAtomicType() const;                    // C11 _Atomic()\n  bool isUndeducedAutoType() const;             // C++11 auto or\n                                                // C++14 decltype(auto)\n  bool isTypedefNameType() const;               // typedef or alias template\n\n#define IMAGE_TYPE(ImgType, Id, SingletonId, Access, Suffix) \\\n  bool is##Id##Type() const;\n#include \"clang/Basic/OpenCLImageTypes.def\"\n\n  bool isImageType() const;                     // Any OpenCL image type\n\n  bool isSamplerT() const;                      // OpenCL sampler_t\n  bool isEventT() const;                        // OpenCL event_t\n  bool isClkEventT() const;                     // OpenCL clk_event_t\n  bool isQueueT() const;                        // OpenCL queue_t\n  bool isReserveIDT() const;                    // OpenCL reserve_id_t\n\n#define EXT_OPAQUE_TYPE(ExtType, Id, Ext) \\\n  bool is##Id##Type() const;\n#include \"clang/Basic/OpenCLExtensionTypes.def\"\n  // Type defined in cl_intel_device_side_avc_motion_estimation OpenCL extension\n  bool isOCLIntelSubgroupAVCType() const;\n  bool isOCLExtOpaqueType() const;              // Any OpenCL extension type\n\n  bool isPipeType() const;                      // OpenCL pipe type\n  bool isExtIntType() const;                    // Extended Int Type\n  bool isOpenCLSpecificType() const;            // Any OpenCL specific type\n\n  /// Determines if this type, which must satisfy\n  /// isObjCLifetimeType(), is implicitly __unsafe_unretained rather\n  /// than implicitly __strong.\n  bool isObjCARCImplicitlyUnretainedType() const;\n\n  /// Check if the type is the CUDA device builtin surface type.\n  bool isCUDADeviceBuiltinSurfaceType() const;\n  /// Check if the type is the CUDA device builtin texture type.\n  bool isCUDADeviceBuiltinTextureType() const;\n\n  /// Return the implicit lifetime for this type, which must not be dependent.\n  Qualifiers::ObjCLifetime getObjCARCImplicitLifetime() const;\n\n  enum ScalarTypeKind {\n    STK_CPointer,\n    STK_BlockPointer,\n    STK_ObjCObjectPointer,\n    STK_MemberPointer,\n    STK_Bool,\n    STK_Integral,\n    STK_Floating,\n    STK_IntegralComplex,\n    STK_FloatingComplex,\n    STK_FixedPoint\n  };\n\n  /// Given that this is a scalar type, classify it.\n  ScalarTypeKind getScalarTypeKind() const;\n\n  TypeDependence getDependence() const {\n    return static_cast<TypeDependence>(TypeBits.Dependence);\n  }\n\n  /// Whether this type is an error type.\n  bool containsErrors() const {\n    return getDependence() & TypeDependence::Error;\n  }\n\n  /// Whether this type is a dependent type, meaning that its definition\n  /// somehow depends on a template parameter (C++ [temp.dep.type]).\n  bool isDependentType() const {\n    return getDependence() & TypeDependence::Dependent;\n  }\n\n  /// Determine whether this type is an instantiation-dependent type,\n  /// meaning that the type involves a template parameter (even if the\n  /// definition does not actually depend on the type substituted for that\n  /// template parameter).\n  bool isInstantiationDependentType() const {\n    return getDependence() & TypeDependence::Instantiation;\n  }\n\n  /// Determine whether this type is an undeduced type, meaning that\n  /// it somehow involves a C++11 'auto' type or similar which has not yet been\n  /// deduced.\n  bool isUndeducedType() const;\n\n  /// Whether this type is a variably-modified type (C99 6.7.5).\n  bool isVariablyModifiedType() const {\n    return getDependence() & TypeDependence::VariablyModified;\n  }\n\n  /// Whether this type involves a variable-length array type\n  /// with a definite size.\n  bool hasSizedVLAType() const;\n\n  /// Whether this type is or contains a local or unnamed type.\n  bool hasUnnamedOrLocalType() const;\n\n  bool isOverloadableType() const;\n\n  /// Determine wither this type is a C++ elaborated-type-specifier.\n  bool isElaboratedTypeSpecifier() const;\n\n  bool canDecayToPointerType() const;\n\n  /// Whether this type is represented natively as a pointer.  This includes\n  /// pointers, references, block pointers, and Objective-C interface,\n  /// qualified id, and qualified interface types, as well as nullptr_t.\n  bool hasPointerRepresentation() const;\n\n  /// Whether this type can represent an objective pointer type for the\n  /// purpose of GC'ability\n  bool hasObjCPointerRepresentation() const;\n\n  /// Determine whether this type has an integer representation\n  /// of some sort, e.g., it is an integer type or a vector.\n  bool hasIntegerRepresentation() const;\n\n  /// Determine whether this type has an signed integer representation\n  /// of some sort, e.g., it is an signed integer type or a vector.\n  bool hasSignedIntegerRepresentation() const;\n\n  /// Determine whether this type has an unsigned integer representation\n  /// of some sort, e.g., it is an unsigned integer type or a vector.\n  bool hasUnsignedIntegerRepresentation() const;\n\n  /// Determine whether this type has a floating-point representation\n  /// of some sort, e.g., it is a floating-point type or a vector thereof.\n  bool hasFloatingRepresentation() const;\n\n  // Type Checking Functions: Check to see if this type is structurally the\n  // specified type, ignoring typedefs and qualifiers, and return a pointer to\n  // the best type we can.\n  const RecordType *getAsStructureType() const;\n  /// NOTE: getAs*ArrayType are methods on ASTContext.\n  const RecordType *getAsUnionType() const;\n  const ComplexType *getAsComplexIntegerType() const; // GCC complex int type.\n  const ObjCObjectType *getAsObjCInterfaceType() const;\n\n  // The following is a convenience method that returns an ObjCObjectPointerType\n  // for object declared using an interface.\n  const ObjCObjectPointerType *getAsObjCInterfacePointerType() const;\n  const ObjCObjectPointerType *getAsObjCQualifiedIdType() const;\n  const ObjCObjectPointerType *getAsObjCQualifiedClassType() const;\n  const ObjCObjectType *getAsObjCQualifiedInterfaceType() const;\n\n  /// Retrieves the CXXRecordDecl that this type refers to, either\n  /// because the type is a RecordType or because it is the injected-class-name\n  /// type of a class template or class template partial specialization.\n  CXXRecordDecl *getAsCXXRecordDecl() const;\n\n  /// Retrieves the RecordDecl this type refers to.\n  RecordDecl *getAsRecordDecl() const;\n\n  /// Retrieves the TagDecl that this type refers to, either\n  /// because the type is a TagType or because it is the injected-class-name\n  /// type of a class template or class template partial specialization.\n  TagDecl *getAsTagDecl() const;\n\n  /// If this is a pointer or reference to a RecordType, return the\n  /// CXXRecordDecl that the type refers to.\n  ///\n  /// If this is not a pointer or reference, or the type being pointed to does\n  /// not refer to a CXXRecordDecl, returns NULL.\n  const CXXRecordDecl *getPointeeCXXRecordDecl() const;\n\n  /// Get the DeducedType whose type will be deduced for a variable with\n  /// an initializer of this type. This looks through declarators like pointer\n  /// types, but not through decltype or typedefs.\n  DeducedType *getContainedDeducedType() const;\n\n  /// Get the AutoType whose type will be deduced for a variable with\n  /// an initializer of this type. This looks through declarators like pointer\n  /// types, but not through decltype or typedefs.\n  AutoType *getContainedAutoType() const {\n    return dyn_cast_or_null<AutoType>(getContainedDeducedType());\n  }\n\n  /// Determine whether this type was written with a leading 'auto'\n  /// corresponding to a trailing return type (possibly for a nested\n  /// function type within a pointer to function type or similar).\n  bool hasAutoForTrailingReturnType() const;\n\n  /// Member-template getAs<specific type>'.  Look through sugar for\n  /// an instance of \\<specific type>.   This scheme will eventually\n  /// replace the specific getAsXXXX methods above.\n  ///\n  /// There are some specializations of this member template listed\n  /// immediately following this class.\n  template <typename T> const T *getAs() const;\n\n  /// Member-template getAsAdjusted<specific type>. Look through specific kinds\n  /// of sugar (parens, attributes, etc) for an instance of \\<specific type>.\n  /// This is used when you need to walk over sugar nodes that represent some\n  /// kind of type adjustment from a type that was written as a \\<specific type>\n  /// to another type that is still canonically a \\<specific type>.\n  template <typename T> const T *getAsAdjusted() const;\n\n  /// A variant of getAs<> for array types which silently discards\n  /// qualifiers from the outermost type.\n  const ArrayType *getAsArrayTypeUnsafe() const;\n\n  /// Member-template castAs<specific type>.  Look through sugar for\n  /// the underlying instance of \\<specific type>.\n  ///\n  /// This method has the same relationship to getAs<T> as cast<T> has\n  /// to dyn_cast<T>; which is to say, the underlying type *must*\n  /// have the intended type, and this method will never return null.\n  template <typename T> const T *castAs() const;\n\n  /// A variant of castAs<> for array type which silently discards\n  /// qualifiers from the outermost type.\n  const ArrayType *castAsArrayTypeUnsafe() const;\n\n  /// Determine whether this type had the specified attribute applied to it\n  /// (looking through top-level type sugar).\n  bool hasAttr(attr::Kind AK) const;\n\n  /// Get the base element type of this type, potentially discarding type\n  /// qualifiers.  This should never be used when type qualifiers\n  /// are meaningful.\n  const Type *getBaseElementTypeUnsafe() const;\n\n  /// If this is an array type, return the element type of the array,\n  /// potentially with type qualifiers missing.\n  /// This should never be used when type qualifiers are meaningful.\n  const Type *getArrayElementTypeNoTypeQual() const;\n\n  /// If this is a pointer type, return the pointee type.\n  /// If this is an array type, return the array element type.\n  /// This should never be used when type qualifiers are meaningful.\n  const Type *getPointeeOrArrayElementType() const;\n\n  /// If this is a pointer, ObjC object pointer, or block\n  /// pointer, this returns the respective pointee.\n  QualType getPointeeType() const;\n\n  /// Return the specified type with any \"sugar\" removed from the type,\n  /// removing any typedefs, typeofs, etc., as well as any qualifiers.\n  const Type *getUnqualifiedDesugaredType() const;\n\n  /// More type predicates useful for type checking/promotion\n  bool isPromotableIntegerType() const; // C99 6.3.1.1p2\n\n  /// Return true if this is an integer type that is\n  /// signed, according to C99 6.2.5p4 [char, signed char, short, int, long..],\n  /// or an enum decl which has a signed representation.\n  bool isSignedIntegerType() const;\n\n  /// Return true if this is an integer type that is\n  /// unsigned, according to C99 6.2.5p6 [which returns true for _Bool],\n  /// or an enum decl which has an unsigned representation.\n  bool isUnsignedIntegerType() const;\n\n  /// Determines whether this is an integer type that is signed or an\n  /// enumeration types whose underlying type is a signed integer type.\n  bool isSignedIntegerOrEnumerationType() const;\n\n  /// Determines whether this is an integer type that is unsigned or an\n  /// enumeration types whose underlying type is a unsigned integer type.\n  bool isUnsignedIntegerOrEnumerationType() const;\n\n  /// Return true if this is a fixed point type according to\n  /// ISO/IEC JTC1 SC22 WG14 N1169.\n  bool isFixedPointType() const;\n\n  /// Return true if this is a fixed point or integer type.\n  bool isFixedPointOrIntegerType() const;\n\n  /// Return true if this is a saturated fixed point type according to\n  /// ISO/IEC JTC1 SC22 WG14 N1169. This type can be signed or unsigned.\n  bool isSaturatedFixedPointType() const;\n\n  /// Return true if this is a saturated fixed point type according to\n  /// ISO/IEC JTC1 SC22 WG14 N1169. This type can be signed or unsigned.\n  bool isUnsaturatedFixedPointType() const;\n\n  /// Return true if this is a fixed point type that is signed according\n  /// to ISO/IEC JTC1 SC22 WG14 N1169. This type can also be saturated.\n  bool isSignedFixedPointType() const;\n\n  /// Return true if this is a fixed point type that is unsigned according\n  /// to ISO/IEC JTC1 SC22 WG14 N1169. This type can also be saturated.\n  bool isUnsignedFixedPointType() const;\n\n  /// Return true if this is not a variable sized type,\n  /// according to the rules of C99 6.7.5p3.  It is not legal to call this on\n  /// incomplete types.\n  bool isConstantSizeType() const;\n\n  /// Returns true if this type can be represented by some\n  /// set of type specifiers.\n  bool isSpecifierType() const;\n\n  /// Determine the linkage of this type.\n  Linkage getLinkage() const;\n\n  /// Determine the visibility of this type.\n  Visibility getVisibility() const {\n    return getLinkageAndVisibility().getVisibility();\n  }\n\n  /// Return true if the visibility was explicitly set is the code.\n  bool isVisibilityExplicit() const {\n    return getLinkageAndVisibility().isVisibilityExplicit();\n  }\n\n  /// Determine the linkage and visibility of this type.\n  LinkageInfo getLinkageAndVisibility() const;\n\n  /// True if the computed linkage is valid. Used for consistency\n  /// checking. Should always return true.\n  bool isLinkageValid() const;\n\n  /// Determine the nullability of the given type.\n  ///\n  /// Note that nullability is only captured as sugar within the type\n  /// system, not as part of the canonical type, so nullability will\n  /// be lost by canonicalization and desugaring.\n  Optional<NullabilityKind> getNullability(const ASTContext &context) const;\n\n  /// Determine whether the given type can have a nullability\n  /// specifier applied to it, i.e., if it is any kind of pointer type.\n  ///\n  /// \\param ResultIfUnknown The value to return if we don't yet know whether\n  ///        this type can have nullability because it is dependent.\n  bool canHaveNullability(bool ResultIfUnknown = true) const;\n\n  /// Retrieve the set of substitutions required when accessing a member\n  /// of the Objective-C receiver type that is declared in the given context.\n  ///\n  /// \\c *this is the type of the object we're operating on, e.g., the\n  /// receiver for a message send or the base of a property access, and is\n  /// expected to be of some object or object pointer type.\n  ///\n  /// \\param dc The declaration context for which we are building up a\n  /// substitution mapping, which should be an Objective-C class, extension,\n  /// category, or method within.\n  ///\n  /// \\returns an array of type arguments that can be substituted for\n  /// the type parameters of the given declaration context in any type described\n  /// within that context, or an empty optional to indicate that no\n  /// substitution is required.\n  Optional<ArrayRef<QualType>>\n  getObjCSubstitutions(const DeclContext *dc) const;\n\n  /// Determines if this is an ObjC interface type that may accept type\n  /// parameters.\n  bool acceptsObjCTypeParams() const;\n\n  const char *getTypeClassName() const;\n\n  QualType getCanonicalTypeInternal() const {\n    return CanonicalType;\n  }\n\n  CanQualType getCanonicalTypeUnqualified() const; // in CanonicalType.h\n  void dump() const;\n  void dump(llvm::raw_ostream &OS, const ASTContext &Context) const;\n};\n\n/// This will check for a TypedefType by removing any existing sugar\n/// until it reaches a TypedefType or a non-sugared type.\ntemplate <> const TypedefType *Type::getAs() const;\n\n/// This will check for a TemplateSpecializationType by removing any\n/// existing sugar until it reaches a TemplateSpecializationType or a\n/// non-sugared type.\ntemplate <> const TemplateSpecializationType *Type::getAs() const;\n\n/// This will check for an AttributedType by removing any existing sugar\n/// until it reaches an AttributedType or a non-sugared type.\ntemplate <> const AttributedType *Type::getAs() const;\n\n// We can do canonical leaf types faster, because we don't have to\n// worry about preserving child type decoration.\n#define TYPE(Class, Base)\n#define LEAF_TYPE(Class) \\\ntemplate <> inline const Class##Type *Type::getAs() const { \\\n  return dyn_cast<Class##Type>(CanonicalType); \\\n} \\\ntemplate <> inline const Class##Type *Type::castAs() const { \\\n  return cast<Class##Type>(CanonicalType); \\\n}\n#include \"clang/AST/TypeNodes.inc\"\n\n/// This class is used for builtin types like 'int'.  Builtin\n/// types are always canonical and have a literal name field.\nclass BuiltinType : public Type {\npublic:\n  enum Kind {\n// OpenCL image types\n#define IMAGE_TYPE(ImgType, Id, SingletonId, Access, Suffix) Id,\n#include \"clang/Basic/OpenCLImageTypes.def\"\n// OpenCL extension types\n#define EXT_OPAQUE_TYPE(ExtType, Id, Ext) Id,\n#include \"clang/Basic/OpenCLExtensionTypes.def\"\n// SVE Types\n#define SVE_TYPE(Name, Id, SingletonId) Id,\n#include \"clang/Basic/AArch64SVEACLETypes.def\"\n// PPC MMA Types\n#define PPC_VECTOR_TYPE(Name, Id, Size) Id,\n#include \"clang/Basic/PPCTypes.def\"\n// RVV Types\n#define RVV_TYPE(Name, Id, SingletonId) Id,\n#include \"clang/Basic/RISCVVTypes.def\"\n// All other builtin types\n#define BUILTIN_TYPE(Id, SingletonId) Id,\n#define LAST_BUILTIN_TYPE(Id) LastKind = Id\n#include \"clang/AST/BuiltinTypes.def\"\n  };\n\nprivate:\n  friend class ASTContext; // ASTContext creates these.\n\n  BuiltinType(Kind K)\n      : Type(Builtin, QualType(),\n             K == Dependent ? TypeDependence::DependentInstantiation\n                            : TypeDependence::None) {\n    BuiltinTypeBits.Kind = K;\n  }\n\npublic:\n  Kind getKind() const { return static_cast<Kind>(BuiltinTypeBits.Kind); }\n  StringRef getName(const PrintingPolicy &Policy) const;\n\n  const char *getNameAsCString(const PrintingPolicy &Policy) const {\n    // The StringRef is null-terminated.\n    StringRef str = getName(Policy);\n    assert(!str.empty() && str.data()[str.size()] == '\\0');\n    return str.data();\n  }\n\n  bool isSugared() const { return false; }\n  QualType desugar() const { return QualType(this, 0); }\n\n  bool isInteger() const {\n    return getKind() >= Bool && getKind() <= Int128;\n  }\n\n  bool isSignedInteger() const {\n    return getKind() >= Char_S && getKind() <= Int128;\n  }\n\n  bool isUnsignedInteger() const {\n    return getKind() >= Bool && getKind() <= UInt128;\n  }\n\n  bool isFloatingPoint() const {\n    return getKind() >= Half && getKind() <= Float128;\n  }\n\n  /// Determines whether the given kind corresponds to a placeholder type.\n  static bool isPlaceholderTypeKind(Kind K) {\n    return K >= Overload;\n  }\n\n  /// Determines whether this type is a placeholder type, i.e. a type\n  /// which cannot appear in arbitrary positions in a fully-formed\n  /// expression.\n  bool isPlaceholderType() const {\n    return isPlaceholderTypeKind(getKind());\n  }\n\n  /// Determines whether this type is a placeholder type other than\n  /// Overload.  Most placeholder types require only syntactic\n  /// information about their context in order to be resolved (e.g.\n  /// whether it is a call expression), which means they can (and\n  /// should) be resolved in an earlier \"phase\" of analysis.\n  /// Overload expressions sometimes pick up further information\n  /// from their context, like whether the context expects a\n  /// specific function-pointer type, and so frequently need\n  /// special treatment.\n  bool isNonOverloadPlaceholderType() const {\n    return getKind() > Overload;\n  }\n\n  static bool classof(const Type *T) { return T->getTypeClass() == Builtin; }\n};\n\n/// Complex values, per C99 6.2.5p11.  This supports the C99 complex\n/// types (_Complex float etc) as well as the GCC integer complex extensions.\nclass ComplexType : public Type, public llvm::FoldingSetNode {\n  friend class ASTContext; // ASTContext creates these.\n\n  QualType ElementType;\n\n  ComplexType(QualType Element, QualType CanonicalPtr)\n      : Type(Complex, CanonicalPtr, Element->getDependence()),\n        ElementType(Element) {}\n\npublic:\n  QualType getElementType() const { return ElementType; }\n\n  bool isSugared() const { return false; }\n  QualType desugar() const { return QualType(this, 0); }\n\n  void Profile(llvm::FoldingSetNodeID &ID) {\n    Profile(ID, getElementType());\n  }\n\n  static void Profile(llvm::FoldingSetNodeID &ID, QualType Element) {\n    ID.AddPointer(Element.getAsOpaquePtr());\n  }\n\n  static bool classof(const Type *T) { return T->getTypeClass() == Complex; }\n};\n\n/// Sugar for parentheses used when specifying types.\nclass ParenType : public Type, public llvm::FoldingSetNode {\n  friend class ASTContext; // ASTContext creates these.\n\n  QualType Inner;\n\n  ParenType(QualType InnerType, QualType CanonType)\n      : Type(Paren, CanonType, InnerType->getDependence()), Inner(InnerType) {}\n\npublic:\n  QualType getInnerType() const { return Inner; }\n\n  bool isSugared() const { return true; }\n  QualType desugar() const { return getInnerType(); }\n\n  void Profile(llvm::FoldingSetNodeID &ID) {\n    Profile(ID, getInnerType());\n  }\n\n  static void Profile(llvm::FoldingSetNodeID &ID, QualType Inner) {\n    Inner.Profile(ID);\n  }\n\n  static bool classof(const Type *T) { return T->getTypeClass() == Paren; }\n};\n\n/// PointerType - C99 6.7.5.1 - Pointer Declarators.\nclass PointerType : public Type, public llvm::FoldingSetNode {\n  friend class ASTContext; // ASTContext creates these.\n\n  QualType PointeeType;\n\n  PointerType(QualType Pointee, QualType CanonicalPtr)\n      : Type(Pointer, CanonicalPtr, Pointee->getDependence()),\n        PointeeType(Pointee) {}\n\npublic:\n  QualType getPointeeType() const { return PointeeType; }\n\n  bool isSugared() const { return false; }\n  QualType desugar() const { return QualType(this, 0); }\n\n  void Profile(llvm::FoldingSetNodeID &ID) {\n    Profile(ID, getPointeeType());\n  }\n\n  static void Profile(llvm::FoldingSetNodeID &ID, QualType Pointee) {\n    ID.AddPointer(Pointee.getAsOpaquePtr());\n  }\n\n  static bool classof(const Type *T) { return T->getTypeClass() == Pointer; }\n};\n\n/// Represents a type which was implicitly adjusted by the semantic\n/// engine for arbitrary reasons.  For example, array and function types can\n/// decay, and function types can have their calling conventions adjusted.\nclass AdjustedType : public Type, public llvm::FoldingSetNode {\n  QualType OriginalTy;\n  QualType AdjustedTy;\n\nprotected:\n  friend class ASTContext; // ASTContext creates these.\n\n  AdjustedType(TypeClass TC, QualType OriginalTy, QualType AdjustedTy,\n               QualType CanonicalPtr)\n      : Type(TC, CanonicalPtr, OriginalTy->getDependence()),\n        OriginalTy(OriginalTy), AdjustedTy(AdjustedTy) {}\n\npublic:\n  QualType getOriginalType() const { return OriginalTy; }\n  QualType getAdjustedType() const { return AdjustedTy; }\n\n  bool isSugared() const { return true; }\n  QualType desugar() const { return AdjustedTy; }\n\n  void Profile(llvm::FoldingSetNodeID &ID) {\n    Profile(ID, OriginalTy, AdjustedTy);\n  }\n\n  static void Profile(llvm::FoldingSetNodeID &ID, QualType Orig, QualType New) {\n    ID.AddPointer(Orig.getAsOpaquePtr());\n    ID.AddPointer(New.getAsOpaquePtr());\n  }\n\n  static bool classof(const Type *T) {\n    return T->getTypeClass() == Adjusted || T->getTypeClass() == Decayed;\n  }\n};\n\n/// Represents a pointer type decayed from an array or function type.\nclass DecayedType : public AdjustedType {\n  friend class ASTContext; // ASTContext creates these.\n\n  inline\n  DecayedType(QualType OriginalType, QualType Decayed, QualType Canonical);\n\npublic:\n  QualType getDecayedType() const { return getAdjustedType(); }\n\n  inline QualType getPointeeType() const;\n\n  static bool classof(const Type *T) { return T->getTypeClass() == Decayed; }\n};\n\n/// Pointer to a block type.\n/// This type is to represent types syntactically represented as\n/// \"void (^)(int)\", etc. Pointee is required to always be a function type.\nclass BlockPointerType : public Type, public llvm::FoldingSetNode {\n  friend class ASTContext; // ASTContext creates these.\n\n  // Block is some kind of pointer type\n  QualType PointeeType;\n\n  BlockPointerType(QualType Pointee, QualType CanonicalCls)\n      : Type(BlockPointer, CanonicalCls, Pointee->getDependence()),\n        PointeeType(Pointee) {}\n\npublic:\n  // Get the pointee type. Pointee is required to always be a function type.\n  QualType getPointeeType() const { return PointeeType; }\n\n  bool isSugared() const { return false; }\n  QualType desugar() const { return QualType(this, 0); }\n\n  void Profile(llvm::FoldingSetNodeID &ID) {\n      Profile(ID, getPointeeType());\n  }\n\n  static void Profile(llvm::FoldingSetNodeID &ID, QualType Pointee) {\n      ID.AddPointer(Pointee.getAsOpaquePtr());\n  }\n\n  static bool classof(const Type *T) {\n    return T->getTypeClass() == BlockPointer;\n  }\n};\n\n/// Base for LValueReferenceType and RValueReferenceType\nclass ReferenceType : public Type, public llvm::FoldingSetNode {\n  QualType PointeeType;\n\nprotected:\n  ReferenceType(TypeClass tc, QualType Referencee, QualType CanonicalRef,\n                bool SpelledAsLValue)\n      : Type(tc, CanonicalRef, Referencee->getDependence()),\n        PointeeType(Referencee) {\n    ReferenceTypeBits.SpelledAsLValue = SpelledAsLValue;\n    ReferenceTypeBits.InnerRef = Referencee->isReferenceType();\n  }\n\npublic:\n  bool isSpelledAsLValue() const { return ReferenceTypeBits.SpelledAsLValue; }\n  bool isInnerRef() const { return ReferenceTypeBits.InnerRef; }\n\n  QualType getPointeeTypeAsWritten() const { return PointeeType; }\n\n  QualType getPointeeType() const {\n    // FIXME: this might strip inner qualifiers; okay?\n    const ReferenceType *T = this;\n    while (T->isInnerRef())\n      T = T->PointeeType->castAs<ReferenceType>();\n    return T->PointeeType;\n  }\n\n  void Profile(llvm::FoldingSetNodeID &ID) {\n    Profile(ID, PointeeType, isSpelledAsLValue());\n  }\n\n  static void Profile(llvm::FoldingSetNodeID &ID,\n                      QualType Referencee,\n                      bool SpelledAsLValue) {\n    ID.AddPointer(Referencee.getAsOpaquePtr());\n    ID.AddBoolean(SpelledAsLValue);\n  }\n\n  static bool classof(const Type *T) {\n    return T->getTypeClass() == LValueReference ||\n           T->getTypeClass() == RValueReference;\n  }\n};\n\n/// An lvalue reference type, per C++11 [dcl.ref].\nclass LValueReferenceType : public ReferenceType {\n  friend class ASTContext; // ASTContext creates these\n\n  LValueReferenceType(QualType Referencee, QualType CanonicalRef,\n                      bool SpelledAsLValue)\n      : ReferenceType(LValueReference, Referencee, CanonicalRef,\n                      SpelledAsLValue) {}\n\npublic:\n  bool isSugared() const { return false; }\n  QualType desugar() const { return QualType(this, 0); }\n\n  static bool classof(const Type *T) {\n    return T->getTypeClass() == LValueReference;\n  }\n};\n\n/// An rvalue reference type, per C++11 [dcl.ref].\nclass RValueReferenceType : public ReferenceType {\n  friend class ASTContext; // ASTContext creates these\n\n  RValueReferenceType(QualType Referencee, QualType CanonicalRef)\n       : ReferenceType(RValueReference, Referencee, CanonicalRef, false) {}\n\npublic:\n  bool isSugared() const { return false; }\n  QualType desugar() const { return QualType(this, 0); }\n\n  static bool classof(const Type *T) {\n    return T->getTypeClass() == RValueReference;\n  }\n};\n\n/// A pointer to member type per C++ 8.3.3 - Pointers to members.\n///\n/// This includes both pointers to data members and pointer to member functions.\nclass MemberPointerType : public Type, public llvm::FoldingSetNode {\n  friend class ASTContext; // ASTContext creates these.\n\n  QualType PointeeType;\n\n  /// The class of which the pointee is a member. Must ultimately be a\n  /// RecordType, but could be a typedef or a template parameter too.\n  const Type *Class;\n\n  MemberPointerType(QualType Pointee, const Type *Cls, QualType CanonicalPtr)\n      : Type(MemberPointer, CanonicalPtr,\n             (Cls->getDependence() & ~TypeDependence::VariablyModified) |\n                 Pointee->getDependence()),\n        PointeeType(Pointee), Class(Cls) {}\n\npublic:\n  QualType getPointeeType() const { return PointeeType; }\n\n  /// Returns true if the member type (i.e. the pointee type) is a\n  /// function type rather than a data-member type.\n  bool isMemberFunctionPointer() const {\n    return PointeeType->isFunctionProtoType();\n  }\n\n  /// Returns true if the member type (i.e. the pointee type) is a\n  /// data type rather than a function type.\n  bool isMemberDataPointer() const {\n    return !PointeeType->isFunctionProtoType();\n  }\n\n  const Type *getClass() const { return Class; }\n  CXXRecordDecl *getMostRecentCXXRecordDecl() const;\n\n  bool isSugared() const { return false; }\n  QualType desugar() const { return QualType(this, 0); }\n\n  void Profile(llvm::FoldingSetNodeID &ID) {\n    Profile(ID, getPointeeType(), getClass());\n  }\n\n  static void Profile(llvm::FoldingSetNodeID &ID, QualType Pointee,\n                      const Type *Class) {\n    ID.AddPointer(Pointee.getAsOpaquePtr());\n    ID.AddPointer(Class);\n  }\n\n  static bool classof(const Type *T) {\n    return T->getTypeClass() == MemberPointer;\n  }\n};\n\n/// Represents an array type, per C99 6.7.5.2 - Array Declarators.\nclass ArrayType : public Type, public llvm::FoldingSetNode {\npublic:\n  /// Capture whether this is a normal array (e.g. int X[4])\n  /// an array with a static size (e.g. int X[static 4]), or an array\n  /// with a star size (e.g. int X[*]).\n  /// 'static' is only allowed on function parameters.\n  enum ArraySizeModifier {\n    Normal, Static, Star\n  };\n\nprivate:\n  /// The element type of the array.\n  QualType ElementType;\n\nprotected:\n  friend class ASTContext; // ASTContext creates these.\n\n  ArrayType(TypeClass tc, QualType et, QualType can, ArraySizeModifier sm,\n            unsigned tq, const Expr *sz = nullptr);\n\npublic:\n  QualType getElementType() const { return ElementType; }\n\n  ArraySizeModifier getSizeModifier() const {\n    return ArraySizeModifier(ArrayTypeBits.SizeModifier);\n  }\n\n  Qualifiers getIndexTypeQualifiers() const {\n    return Qualifiers::fromCVRMask(getIndexTypeCVRQualifiers());\n  }\n\n  unsigned getIndexTypeCVRQualifiers() const {\n    return ArrayTypeBits.IndexTypeQuals;\n  }\n\n  static bool classof(const Type *T) {\n    return T->getTypeClass() == ConstantArray ||\n           T->getTypeClass() == VariableArray ||\n           T->getTypeClass() == IncompleteArray ||\n           T->getTypeClass() == DependentSizedArray;\n  }\n};\n\n/// Represents the canonical version of C arrays with a specified constant size.\n/// For example, the canonical type for 'int A[4 + 4*100]' is a\n/// ConstantArrayType where the element type is 'int' and the size is 404.\nclass ConstantArrayType final\n    : public ArrayType,\n      private llvm::TrailingObjects<ConstantArrayType, const Expr *> {\n  friend class ASTContext; // ASTContext creates these.\n  friend TrailingObjects;\n\n  llvm::APInt Size; // Allows us to unique the type.\n\n  ConstantArrayType(QualType et, QualType can, const llvm::APInt &size,\n                    const Expr *sz, ArraySizeModifier sm, unsigned tq)\n      : ArrayType(ConstantArray, et, can, sm, tq, sz), Size(size) {\n    ConstantArrayTypeBits.HasStoredSizeExpr = sz != nullptr;\n    if (ConstantArrayTypeBits.HasStoredSizeExpr) {\n      assert(!can.isNull() && \"canonical constant array should not have size\");\n      *getTrailingObjects<const Expr*>() = sz;\n    }\n  }\n\n  unsigned numTrailingObjects(OverloadToken<const Expr*>) const {\n    return ConstantArrayTypeBits.HasStoredSizeExpr;\n  }\n\npublic:\n  const llvm::APInt &getSize() const { return Size; }\n  const Expr *getSizeExpr() const {\n    return ConstantArrayTypeBits.HasStoredSizeExpr\n               ? *getTrailingObjects<const Expr *>()\n               : nullptr;\n  }\n  bool isSugared() const { return false; }\n  QualType desugar() const { return QualType(this, 0); }\n\n  /// Determine the number of bits required to address a member of\n  // an array with the given element type and number of elements.\n  static unsigned getNumAddressingBits(const ASTContext &Context,\n                                       QualType ElementType,\n                                       const llvm::APInt &NumElements);\n\n  /// Determine the maximum number of active bits that an array's size\n  /// can require, which limits the maximum size of the array.\n  static unsigned getMaxSizeBits(const ASTContext &Context);\n\n  void Profile(llvm::FoldingSetNodeID &ID, const ASTContext &Ctx) {\n    Profile(ID, Ctx, getElementType(), getSize(), getSizeExpr(),\n            getSizeModifier(), getIndexTypeCVRQualifiers());\n  }\n\n  static void Profile(llvm::FoldingSetNodeID &ID, const ASTContext &Ctx,\n                      QualType ET, const llvm::APInt &ArraySize,\n                      const Expr *SizeExpr, ArraySizeModifier SizeMod,\n                      unsigned TypeQuals);\n\n  static bool classof(const Type *T) {\n    return T->getTypeClass() == ConstantArray;\n  }\n};\n\n/// Represents a C array with an unspecified size.  For example 'int A[]' has\n/// an IncompleteArrayType where the element type is 'int' and the size is\n/// unspecified.\nclass IncompleteArrayType : public ArrayType {\n  friend class ASTContext; // ASTContext creates these.\n\n  IncompleteArrayType(QualType et, QualType can,\n                      ArraySizeModifier sm, unsigned tq)\n      : ArrayType(IncompleteArray, et, can, sm, tq) {}\n\npublic:\n  friend class StmtIteratorBase;\n\n  bool isSugared() const { return false; }\n  QualType desugar() const { return QualType(this, 0); }\n\n  static bool classof(const Type *T) {\n    return T->getTypeClass() == IncompleteArray;\n  }\n\n  void Profile(llvm::FoldingSetNodeID &ID) {\n    Profile(ID, getElementType(), getSizeModifier(),\n            getIndexTypeCVRQualifiers());\n  }\n\n  static void Profile(llvm::FoldingSetNodeID &ID, QualType ET,\n                      ArraySizeModifier SizeMod, unsigned TypeQuals) {\n    ID.AddPointer(ET.getAsOpaquePtr());\n    ID.AddInteger(SizeMod);\n    ID.AddInteger(TypeQuals);\n  }\n};\n\n/// Represents a C array with a specified size that is not an\n/// integer-constant-expression.  For example, 'int s[x+foo()]'.\n/// Since the size expression is an arbitrary expression, we store it as such.\n///\n/// Note: VariableArrayType's aren't uniqued (since the expressions aren't) and\n/// should not be: two lexically equivalent variable array types could mean\n/// different things, for example, these variables do not have the same type\n/// dynamically:\n///\n/// void foo(int x) {\n///   int Y[x];\n///   ++x;\n///   int Z[x];\n/// }\nclass VariableArrayType : public ArrayType {\n  friend class ASTContext; // ASTContext creates these.\n\n  /// An assignment-expression. VLA's are only permitted within\n  /// a function block.\n  Stmt *SizeExpr;\n\n  /// The range spanned by the left and right array brackets.\n  SourceRange Brackets;\n\n  VariableArrayType(QualType et, QualType can, Expr *e,\n                    ArraySizeModifier sm, unsigned tq,\n                    SourceRange brackets)\n      : ArrayType(VariableArray, et, can, sm, tq, e),\n        SizeExpr((Stmt*) e), Brackets(brackets) {}\n\npublic:\n  friend class StmtIteratorBase;\n\n  Expr *getSizeExpr() const {\n    // We use C-style casts instead of cast<> here because we do not wish\n    // to have a dependency of Type.h on Stmt.h/Expr.h.\n    return (Expr*) SizeExpr;\n  }\n\n  SourceRange getBracketsRange() const { return Brackets; }\n  SourceLocation getLBracketLoc() const { return Brackets.getBegin(); }\n  SourceLocation getRBracketLoc() const { return Brackets.getEnd(); }\n\n  bool isSugared() const { return false; }\n  QualType desugar() const { return QualType(this, 0); }\n\n  static bool classof(const Type *T) {\n    return T->getTypeClass() == VariableArray;\n  }\n\n  void Profile(llvm::FoldingSetNodeID &ID) {\n    llvm_unreachable(\"Cannot unique VariableArrayTypes.\");\n  }\n};\n\n/// Represents an array type in C++ whose size is a value-dependent expression.\n///\n/// For example:\n/// \\code\n/// template<typename T, int Size>\n/// class array {\n///   T data[Size];\n/// };\n/// \\endcode\n///\n/// For these types, we won't actually know what the array bound is\n/// until template instantiation occurs, at which point this will\n/// become either a ConstantArrayType or a VariableArrayType.\nclass DependentSizedArrayType : public ArrayType {\n  friend class ASTContext; // ASTContext creates these.\n\n  const ASTContext &Context;\n\n  /// An assignment expression that will instantiate to the\n  /// size of the array.\n  ///\n  /// The expression itself might be null, in which case the array\n  /// type will have its size deduced from an initializer.\n  Stmt *SizeExpr;\n\n  /// The range spanned by the left and right array brackets.\n  SourceRange Brackets;\n\n  DependentSizedArrayType(const ASTContext &Context, QualType et, QualType can,\n                          Expr *e, ArraySizeModifier sm, unsigned tq,\n                          SourceRange brackets);\n\npublic:\n  friend class StmtIteratorBase;\n\n  Expr *getSizeExpr() const {\n    // We use C-style casts instead of cast<> here because we do not wish\n    // to have a dependency of Type.h on Stmt.h/Expr.h.\n    return (Expr*) SizeExpr;\n  }\n\n  SourceRange getBracketsRange() const { return Brackets; }\n  SourceLocation getLBracketLoc() const { return Brackets.getBegin(); }\n  SourceLocation getRBracketLoc() const { return Brackets.getEnd(); }\n\n  bool isSugared() const { return false; }\n  QualType desugar() const { return QualType(this, 0); }\n\n  static bool classof(const Type *T) {\n    return T->getTypeClass() == DependentSizedArray;\n  }\n\n  void Profile(llvm::FoldingSetNodeID &ID) {\n    Profile(ID, Context, getElementType(),\n            getSizeModifier(), getIndexTypeCVRQualifiers(), getSizeExpr());\n  }\n\n  static void Profile(llvm::FoldingSetNodeID &ID, const ASTContext &Context,\n                      QualType ET, ArraySizeModifier SizeMod,\n                      unsigned TypeQuals, Expr *E);\n};\n\n/// Represents an extended address space qualifier where the input address space\n/// value is dependent. Non-dependent address spaces are not represented with a\n/// special Type subclass; they are stored on an ExtQuals node as part of a QualType.\n///\n/// For example:\n/// \\code\n/// template<typename T, int AddrSpace>\n/// class AddressSpace {\n///   typedef T __attribute__((address_space(AddrSpace))) type;\n/// }\n/// \\endcode\nclass DependentAddressSpaceType : public Type, public llvm::FoldingSetNode {\n  friend class ASTContext;\n\n  const ASTContext &Context;\n  Expr *AddrSpaceExpr;\n  QualType PointeeType;\n  SourceLocation loc;\n\n  DependentAddressSpaceType(const ASTContext &Context, QualType PointeeType,\n                            QualType can, Expr *AddrSpaceExpr,\n                            SourceLocation loc);\n\npublic:\n  Expr *getAddrSpaceExpr() const { return AddrSpaceExpr; }\n  QualType getPointeeType() const { return PointeeType; }\n  SourceLocation getAttributeLoc() const { return loc; }\n\n  bool isSugared() const { return false; }\n  QualType desugar() const { return QualType(this, 0); }\n\n  static bool classof(const Type *T) {\n    return T->getTypeClass() == DependentAddressSpace;\n  }\n\n  void Profile(llvm::FoldingSetNodeID &ID) {\n    Profile(ID, Context, getPointeeType(), getAddrSpaceExpr());\n  }\n\n  static void Profile(llvm::FoldingSetNodeID &ID, const ASTContext &Context,\n                      QualType PointeeType, Expr *AddrSpaceExpr);\n};\n\n/// Represents an extended vector type where either the type or size is\n/// dependent.\n///\n/// For example:\n/// \\code\n/// template<typename T, int Size>\n/// class vector {\n///   typedef T __attribute__((ext_vector_type(Size))) type;\n/// }\n/// \\endcode\nclass DependentSizedExtVectorType : public Type, public llvm::FoldingSetNode {\n  friend class ASTContext;\n\n  const ASTContext &Context;\n  Expr *SizeExpr;\n\n  /// The element type of the array.\n  QualType ElementType;\n\n  SourceLocation loc;\n\n  DependentSizedExtVectorType(const ASTContext &Context, QualType ElementType,\n                              QualType can, Expr *SizeExpr, SourceLocation loc);\n\npublic:\n  Expr *getSizeExpr() const { return SizeExpr; }\n  QualType getElementType() const { return ElementType; }\n  SourceLocation getAttributeLoc() const { return loc; }\n\n  bool isSugared() const { return false; }\n  QualType desugar() const { return QualType(this, 0); }\n\n  static bool classof(const Type *T) {\n    return T->getTypeClass() == DependentSizedExtVector;\n  }\n\n  void Profile(llvm::FoldingSetNodeID &ID) {\n    Profile(ID, Context, getElementType(), getSizeExpr());\n  }\n\n  static void Profile(llvm::FoldingSetNodeID &ID, const ASTContext &Context,\n                      QualType ElementType, Expr *SizeExpr);\n};\n\n\n/// Represents a GCC generic vector type. This type is created using\n/// __attribute__((vector_size(n)), where \"n\" specifies the vector size in\n/// bytes; or from an Altivec __vector or vector declaration.\n/// Since the constructor takes the number of vector elements, the\n/// client is responsible for converting the size into the number of elements.\nclass VectorType : public Type, public llvm::FoldingSetNode {\npublic:\n  enum VectorKind {\n    /// not a target-specific vector type\n    GenericVector,\n\n    /// is AltiVec vector\n    AltiVecVector,\n\n    /// is AltiVec 'vector Pixel'\n    AltiVecPixel,\n\n    /// is AltiVec 'vector bool ...'\n    AltiVecBool,\n\n    /// is ARM Neon vector\n    NeonVector,\n\n    /// is ARM Neon polynomial vector\n    NeonPolyVector,\n\n    /// is AArch64 SVE fixed-length data vector\n    SveFixedLengthDataVector,\n\n    /// is AArch64 SVE fixed-length predicate vector\n    SveFixedLengthPredicateVector\n  };\n\nprotected:\n  friend class ASTContext; // ASTContext creates these.\n\n  /// The element type of the vector.\n  QualType ElementType;\n\n  VectorType(QualType vecType, unsigned nElements, QualType canonType,\n             VectorKind vecKind);\n\n  VectorType(TypeClass tc, QualType vecType, unsigned nElements,\n             QualType canonType, VectorKind vecKind);\n\npublic:\n  QualType getElementType() const { return ElementType; }\n  unsigned getNumElements() const { return VectorTypeBits.NumElements; }\n\n  bool isSugared() const { return false; }\n  QualType desugar() const { return QualType(this, 0); }\n\n  VectorKind getVectorKind() const {\n    return VectorKind(VectorTypeBits.VecKind);\n  }\n\n  void Profile(llvm::FoldingSetNodeID &ID) {\n    Profile(ID, getElementType(), getNumElements(),\n            getTypeClass(), getVectorKind());\n  }\n\n  static void Profile(llvm::FoldingSetNodeID &ID, QualType ElementType,\n                      unsigned NumElements, TypeClass TypeClass,\n                      VectorKind VecKind) {\n    ID.AddPointer(ElementType.getAsOpaquePtr());\n    ID.AddInteger(NumElements);\n    ID.AddInteger(TypeClass);\n    ID.AddInteger(VecKind);\n  }\n\n  static bool classof(const Type *T) {\n    return T->getTypeClass() == Vector || T->getTypeClass() == ExtVector;\n  }\n};\n\n/// Represents a vector type where either the type or size is dependent.\n////\n/// For example:\n/// \\code\n/// template<typename T, int Size>\n/// class vector {\n///   typedef T __attribute__((vector_size(Size))) type;\n/// }\n/// \\endcode\nclass DependentVectorType : public Type, public llvm::FoldingSetNode {\n  friend class ASTContext;\n\n  const ASTContext &Context;\n  QualType ElementType;\n  Expr *SizeExpr;\n  SourceLocation Loc;\n\n  DependentVectorType(const ASTContext &Context, QualType ElementType,\n                           QualType CanonType, Expr *SizeExpr,\n                           SourceLocation Loc, VectorType::VectorKind vecKind);\n\npublic:\n  Expr *getSizeExpr() const { return SizeExpr; }\n  QualType getElementType() const { return ElementType; }\n  SourceLocation getAttributeLoc() const { return Loc; }\n  VectorType::VectorKind getVectorKind() const {\n    return VectorType::VectorKind(VectorTypeBits.VecKind);\n  }\n\n  bool isSugared() const { return false; }\n  QualType desugar() const { return QualType(this, 0); }\n\n  static bool classof(const Type *T) {\n    return T->getTypeClass() == DependentVector;\n  }\n\n  void Profile(llvm::FoldingSetNodeID &ID) {\n    Profile(ID, Context, getElementType(), getSizeExpr(), getVectorKind());\n  }\n\n  static void Profile(llvm::FoldingSetNodeID &ID, const ASTContext &Context,\n                      QualType ElementType, const Expr *SizeExpr,\n                      VectorType::VectorKind VecKind);\n};\n\n/// ExtVectorType - Extended vector type. This type is created using\n/// __attribute__((ext_vector_type(n)), where \"n\" is the number of elements.\n/// Unlike vector_size, ext_vector_type is only allowed on typedef's. This\n/// class enables syntactic extensions, like Vector Components for accessing\n/// points (as .xyzw), colors (as .rgba), and textures (modeled after OpenGL\n/// Shading Language).\nclass ExtVectorType : public VectorType {\n  friend class ASTContext; // ASTContext creates these.\n\n  ExtVectorType(QualType vecType, unsigned nElements, QualType canonType)\n      : VectorType(ExtVector, vecType, nElements, canonType, GenericVector) {}\n\npublic:\n  static int getPointAccessorIdx(char c) {\n    switch (c) {\n    default: return -1;\n    case 'x': case 'r': return 0;\n    case 'y': case 'g': return 1;\n    case 'z': case 'b': return 2;\n    case 'w': case 'a': return 3;\n    }\n  }\n\n  static int getNumericAccessorIdx(char c) {\n    switch (c) {\n      default: return -1;\n      case '0': return 0;\n      case '1': return 1;\n      case '2': return 2;\n      case '3': return 3;\n      case '4': return 4;\n      case '5': return 5;\n      case '6': return 6;\n      case '7': return 7;\n      case '8': return 8;\n      case '9': return 9;\n      case 'A':\n      case 'a': return 10;\n      case 'B':\n      case 'b': return 11;\n      case 'C':\n      case 'c': return 12;\n      case 'D':\n      case 'd': return 13;\n      case 'E':\n      case 'e': return 14;\n      case 'F':\n      case 'f': return 15;\n    }\n  }\n\n  static int getAccessorIdx(char c, bool isNumericAccessor) {\n    if (isNumericAccessor)\n      return getNumericAccessorIdx(c);\n    else\n      return getPointAccessorIdx(c);\n  }\n\n  bool isAccessorWithinNumElements(char c, bool isNumericAccessor) const {\n    if (int idx = getAccessorIdx(c, isNumericAccessor)+1)\n      return unsigned(idx-1) < getNumElements();\n    return false;\n  }\n\n  bool isSugared() const { return false; }\n  QualType desugar() const { return QualType(this, 0); }\n\n  static bool classof(const Type *T) {\n    return T->getTypeClass() == ExtVector;\n  }\n};\n\n/// Represents a matrix type, as defined in the Matrix Types clang extensions.\n/// __attribute__((matrix_type(rows, columns))), where \"rows\" specifies\n/// number of rows and \"columns\" specifies the number of columns.\nclass MatrixType : public Type, public llvm::FoldingSetNode {\nprotected:\n  friend class ASTContext;\n\n  /// The element type of the matrix.\n  QualType ElementType;\n\n  MatrixType(QualType ElementTy, QualType CanonElementTy);\n\n  MatrixType(TypeClass TypeClass, QualType ElementTy, QualType CanonElementTy,\n             const Expr *RowExpr = nullptr, const Expr *ColumnExpr = nullptr);\n\npublic:\n  /// Returns type of the elements being stored in the matrix\n  QualType getElementType() const { return ElementType; }\n\n  /// Valid elements types are the following:\n  /// * an integer type (as in C2x 6.2.5p19), but excluding enumerated types\n  ///   and _Bool\n  /// * the standard floating types float or double\n  /// * a half-precision floating point type, if one is supported on the target\n  static bool isValidElementType(QualType T) {\n    return T->isDependentType() ||\n           (T->isRealType() && !T->isBooleanType() && !T->isEnumeralType());\n  }\n\n  bool isSugared() const { return false; }\n  QualType desugar() const { return QualType(this, 0); }\n\n  static bool classof(const Type *T) {\n    return T->getTypeClass() == ConstantMatrix ||\n           T->getTypeClass() == DependentSizedMatrix;\n  }\n};\n\n/// Represents a concrete matrix type with constant number of rows and columns\nclass ConstantMatrixType final : public MatrixType {\nprotected:\n  friend class ASTContext;\n\n  /// The element type of the matrix.\n  // FIXME: Appears to be unused? There is also MatrixType::ElementType...\n  QualType ElementType;\n\n  /// Number of rows and columns.\n  unsigned NumRows;\n  unsigned NumColumns;\n\n  static constexpr unsigned MaxElementsPerDimension = (1 << 20) - 1;\n\n  ConstantMatrixType(QualType MatrixElementType, unsigned NRows,\n                     unsigned NColumns, QualType CanonElementType);\n\n  ConstantMatrixType(TypeClass typeClass, QualType MatrixType, unsigned NRows,\n                     unsigned NColumns, QualType CanonElementType);\n\npublic:\n  /// Returns the number of rows in the matrix.\n  unsigned getNumRows() const { return NumRows; }\n\n  /// Returns the number of columns in the matrix.\n  unsigned getNumColumns() const { return NumColumns; }\n\n  /// Returns the number of elements required to embed the matrix into a vector.\n  unsigned getNumElementsFlattened() const {\n    return getNumRows() * getNumColumns();\n  }\n\n  /// Returns true if \\p NumElements is a valid matrix dimension.\n  static constexpr bool isDimensionValid(size_t NumElements) {\n    return NumElements > 0 && NumElements <= MaxElementsPerDimension;\n  }\n\n  /// Returns the maximum number of elements per dimension.\n  static constexpr unsigned getMaxElementsPerDimension() {\n    return MaxElementsPerDimension;\n  }\n\n  void Profile(llvm::FoldingSetNodeID &ID) {\n    Profile(ID, getElementType(), getNumRows(), getNumColumns(),\n            getTypeClass());\n  }\n\n  static void Profile(llvm::FoldingSetNodeID &ID, QualType ElementType,\n                      unsigned NumRows, unsigned NumColumns,\n                      TypeClass TypeClass) {\n    ID.AddPointer(ElementType.getAsOpaquePtr());\n    ID.AddInteger(NumRows);\n    ID.AddInteger(NumColumns);\n    ID.AddInteger(TypeClass);\n  }\n\n  static bool classof(const Type *T) {\n    return T->getTypeClass() == ConstantMatrix;\n  }\n};\n\n/// Represents a matrix type where the type and the number of rows and columns\n/// is dependent on a template.\nclass DependentSizedMatrixType final : public MatrixType {\n  friend class ASTContext;\n\n  const ASTContext &Context;\n  Expr *RowExpr;\n  Expr *ColumnExpr;\n\n  SourceLocation loc;\n\n  DependentSizedMatrixType(const ASTContext &Context, QualType ElementType,\n                           QualType CanonicalType, Expr *RowExpr,\n                           Expr *ColumnExpr, SourceLocation loc);\n\npublic:\n  QualType getElementType() const { return ElementType; }\n  Expr *getRowExpr() const { return RowExpr; }\n  Expr *getColumnExpr() const { return ColumnExpr; }\n  SourceLocation getAttributeLoc() const { return loc; }\n\n  bool isSugared() const { return false; }\n  QualType desugar() const { return QualType(this, 0); }\n\n  static bool classof(const Type *T) {\n    return T->getTypeClass() == DependentSizedMatrix;\n  }\n\n  void Profile(llvm::FoldingSetNodeID &ID) {\n    Profile(ID, Context, getElementType(), getRowExpr(), getColumnExpr());\n  }\n\n  static void Profile(llvm::FoldingSetNodeID &ID, const ASTContext &Context,\n                      QualType ElementType, Expr *RowExpr, Expr *ColumnExpr);\n};\n\n/// FunctionType - C99 6.7.5.3 - Function Declarators.  This is the common base\n/// class of FunctionNoProtoType and FunctionProtoType.\nclass FunctionType : public Type {\n  // The type returned by the function.\n  QualType ResultType;\n\npublic:\n  /// Interesting information about a specific parameter that can't simply\n  /// be reflected in parameter's type. This is only used by FunctionProtoType\n  /// but is in FunctionType to make this class available during the\n  /// specification of the bases of FunctionProtoType.\n  ///\n  /// It makes sense to model language features this way when there's some\n  /// sort of parameter-specific override (such as an attribute) that\n  /// affects how the function is called.  For example, the ARC ns_consumed\n  /// attribute changes whether a parameter is passed at +0 (the default)\n  /// or +1 (ns_consumed).  This must be reflected in the function type,\n  /// but isn't really a change to the parameter type.\n  ///\n  /// One serious disadvantage of modelling language features this way is\n  /// that they generally do not work with language features that attempt\n  /// to destructure types.  For example, template argument deduction will\n  /// not be able to match a parameter declared as\n  ///   T (*)(U)\n  /// against an argument of type\n  ///   void (*)(__attribute__((ns_consumed)) id)\n  /// because the substitution of T=void, U=id into the former will\n  /// not produce the latter.\n  class ExtParameterInfo {\n    enum {\n      ABIMask = 0x0F,\n      IsConsumed = 0x10,\n      HasPassObjSize = 0x20,\n      IsNoEscape = 0x40,\n    };\n    unsigned char Data = 0;\n\n  public:\n    ExtParameterInfo() = default;\n\n    /// Return the ABI treatment of this parameter.\n    ParameterABI getABI() const { return ParameterABI(Data & ABIMask); }\n    ExtParameterInfo withABI(ParameterABI kind) const {\n      ExtParameterInfo copy = *this;\n      copy.Data = (copy.Data & ~ABIMask) | unsigned(kind);\n      return copy;\n    }\n\n    /// Is this parameter considered \"consumed\" by Objective-C ARC?\n    /// Consumed parameters must have retainable object type.\n    bool isConsumed() const { return (Data & IsConsumed); }\n    ExtParameterInfo withIsConsumed(bool consumed) const {\n      ExtParameterInfo copy = *this;\n      if (consumed)\n        copy.Data |= IsConsumed;\n      else\n        copy.Data &= ~IsConsumed;\n      return copy;\n    }\n\n    bool hasPassObjectSize() const { return Data & HasPassObjSize; }\n    ExtParameterInfo withHasPassObjectSize() const {\n      ExtParameterInfo Copy = *this;\n      Copy.Data |= HasPassObjSize;\n      return Copy;\n    }\n\n    bool isNoEscape() const { return Data & IsNoEscape; }\n    ExtParameterInfo withIsNoEscape(bool NoEscape) const {\n      ExtParameterInfo Copy = *this;\n      if (NoEscape)\n        Copy.Data |= IsNoEscape;\n      else\n        Copy.Data &= ~IsNoEscape;\n      return Copy;\n    }\n\n    unsigned char getOpaqueValue() const { return Data; }\n    static ExtParameterInfo getFromOpaqueValue(unsigned char data) {\n      ExtParameterInfo result;\n      result.Data = data;\n      return result;\n    }\n\n    friend bool operator==(ExtParameterInfo lhs, ExtParameterInfo rhs) {\n      return lhs.Data == rhs.Data;\n    }\n\n    friend bool operator!=(ExtParameterInfo lhs, ExtParameterInfo rhs) {\n      return lhs.Data != rhs.Data;\n    }\n  };\n\n  /// A class which abstracts out some details necessary for\n  /// making a call.\n  ///\n  /// It is not actually used directly for storing this information in\n  /// a FunctionType, although FunctionType does currently use the\n  /// same bit-pattern.\n  ///\n  // If you add a field (say Foo), other than the obvious places (both,\n  // constructors, compile failures), what you need to update is\n  // * Operator==\n  // * getFoo\n  // * withFoo\n  // * functionType. Add Foo, getFoo.\n  // * ASTContext::getFooType\n  // * ASTContext::mergeFunctionTypes\n  // * FunctionNoProtoType::Profile\n  // * FunctionProtoType::Profile\n  // * TypePrinter::PrintFunctionProto\n  // * AST read and write\n  // * Codegen\n  class ExtInfo {\n    friend class FunctionType;\n\n    // Feel free to rearrange or add bits, but if you go over 16, you'll need to\n    // adjust the Bits field below, and if you add bits, you'll need to adjust\n    // Type::FunctionTypeBitfields::ExtInfo as well.\n\n    // |  CC  |noreturn|produces|nocallersavedregs|regparm|nocfcheck|cmsenscall|\n    // |0 .. 4|   5    |    6   |       7         |8 .. 10|    11   |    12    |\n    //\n    // regparm is either 0 (no regparm attribute) or the regparm value+1.\n    enum { CallConvMask = 0x1F };\n    enum { NoReturnMask = 0x20 };\n    enum { ProducesResultMask = 0x40 };\n    enum { NoCallerSavedRegsMask = 0x80 };\n    enum {\n      RegParmMask =  0x700,\n      RegParmOffset = 8\n    };\n    enum { NoCfCheckMask = 0x800 };\n    enum { CmseNSCallMask = 0x1000 };\n    uint16_t Bits = CC_C;\n\n    ExtInfo(unsigned Bits) : Bits(static_cast<uint16_t>(Bits)) {}\n\n  public:\n    // Constructor with no defaults. Use this when you know that you\n    // have all the elements (when reading an AST file for example).\n    ExtInfo(bool noReturn, bool hasRegParm, unsigned regParm, CallingConv cc,\n            bool producesResult, bool noCallerSavedRegs, bool NoCfCheck,\n            bool cmseNSCall) {\n      assert((!hasRegParm || regParm < 7) && \"Invalid regparm value\");\n      Bits = ((unsigned)cc) | (noReturn ? NoReturnMask : 0) |\n             (producesResult ? ProducesResultMask : 0) |\n             (noCallerSavedRegs ? NoCallerSavedRegsMask : 0) |\n             (hasRegParm ? ((regParm + 1) << RegParmOffset) : 0) |\n             (NoCfCheck ? NoCfCheckMask : 0) |\n             (cmseNSCall ? CmseNSCallMask : 0);\n    }\n\n    // Constructor with all defaults. Use when for example creating a\n    // function known to use defaults.\n    ExtInfo() = default;\n\n    // Constructor with just the calling convention, which is an important part\n    // of the canonical type.\n    ExtInfo(CallingConv CC) : Bits(CC) {}\n\n    bool getNoReturn() const { return Bits & NoReturnMask; }\n    bool getProducesResult() const { return Bits & ProducesResultMask; }\n    bool getCmseNSCall() const { return Bits & CmseNSCallMask; }\n    bool getNoCallerSavedRegs() const { return Bits & NoCallerSavedRegsMask; }\n    bool getNoCfCheck() const { return Bits & NoCfCheckMask; }\n    bool getHasRegParm() const { return ((Bits & RegParmMask) >> RegParmOffset) != 0; }\n\n    unsigned getRegParm() const {\n      unsigned RegParm = (Bits & RegParmMask) >> RegParmOffset;\n      if (RegParm > 0)\n        --RegParm;\n      return RegParm;\n    }\n\n    CallingConv getCC() const { return CallingConv(Bits & CallConvMask); }\n\n    bool operator==(ExtInfo Other) const {\n      return Bits == Other.Bits;\n    }\n    bool operator!=(ExtInfo Other) const {\n      return Bits != Other.Bits;\n    }\n\n    // Note that we don't have setters. That is by design, use\n    // the following with methods instead of mutating these objects.\n\n    ExtInfo withNoReturn(bool noReturn) const {\n      if (noReturn)\n        return ExtInfo(Bits | NoReturnMask);\n      else\n        return ExtInfo(Bits & ~NoReturnMask);\n    }\n\n    ExtInfo withProducesResult(bool producesResult) const {\n      if (producesResult)\n        return ExtInfo(Bits | ProducesResultMask);\n      else\n        return ExtInfo(Bits & ~ProducesResultMask);\n    }\n\n    ExtInfo withCmseNSCall(bool cmseNSCall) const {\n      if (cmseNSCall)\n        return ExtInfo(Bits | CmseNSCallMask);\n      else\n        return ExtInfo(Bits & ~CmseNSCallMask);\n    }\n\n    ExtInfo withNoCallerSavedRegs(bool noCallerSavedRegs) const {\n      if (noCallerSavedRegs)\n        return ExtInfo(Bits | NoCallerSavedRegsMask);\n      else\n        return ExtInfo(Bits & ~NoCallerSavedRegsMask);\n    }\n\n    ExtInfo withNoCfCheck(bool noCfCheck) const {\n      if (noCfCheck)\n        return ExtInfo(Bits | NoCfCheckMask);\n      else\n        return ExtInfo(Bits & ~NoCfCheckMask);\n    }\n\n    ExtInfo withRegParm(unsigned RegParm) const {\n      assert(RegParm < 7 && \"Invalid regparm value\");\n      return ExtInfo((Bits & ~RegParmMask) |\n                     ((RegParm + 1) << RegParmOffset));\n    }\n\n    ExtInfo withCallingConv(CallingConv cc) const {\n      return ExtInfo((Bits & ~CallConvMask) | (unsigned) cc);\n    }\n\n    void Profile(llvm::FoldingSetNodeID &ID) const {\n      ID.AddInteger(Bits);\n    }\n  };\n\n  /// A simple holder for a QualType representing a type in an\n  /// exception specification. Unfortunately needed by FunctionProtoType\n  /// because TrailingObjects cannot handle repeated types.\n  struct ExceptionType { QualType Type; };\n\n  /// A simple holder for various uncommon bits which do not fit in\n  /// FunctionTypeBitfields. Aligned to alignof(void *) to maintain the\n  /// alignment of subsequent objects in TrailingObjects. You must update\n  /// hasExtraBitfields in FunctionProtoType after adding extra data here.\n  struct alignas(void *) FunctionTypeExtraBitfields {\n    /// The number of types in the exception specification.\n    /// A whole unsigned is not needed here and according to\n    /// [implimits] 8 bits would be enough here.\n    unsigned NumExceptionType;\n  };\n\nprotected:\n  FunctionType(TypeClass tc, QualType res, QualType Canonical,\n               TypeDependence Dependence, ExtInfo Info)\n      : Type(tc, Canonical, Dependence), ResultType(res) {\n    FunctionTypeBits.ExtInfo = Info.Bits;\n  }\n\n  Qualifiers getFastTypeQuals() const {\n    return Qualifiers::fromFastMask(FunctionTypeBits.FastTypeQuals);\n  }\n\npublic:\n  QualType getReturnType() const { return ResultType; }\n\n  bool getHasRegParm() const { return getExtInfo().getHasRegParm(); }\n  unsigned getRegParmType() const { return getExtInfo().getRegParm(); }\n\n  /// Determine whether this function type includes the GNU noreturn\n  /// attribute. The C++11 [[noreturn]] attribute does not affect the function\n  /// type.\n  bool getNoReturnAttr() const { return getExtInfo().getNoReturn(); }\n\n  bool getCmseNSCallAttr() const { return getExtInfo().getCmseNSCall(); }\n  CallingConv getCallConv() const { return getExtInfo().getCC(); }\n  ExtInfo getExtInfo() const { return ExtInfo(FunctionTypeBits.ExtInfo); }\n\n  static_assert((~Qualifiers::FastMask & Qualifiers::CVRMask) == 0,\n                \"Const, volatile and restrict are assumed to be a subset of \"\n                \"the fast qualifiers.\");\n\n  bool isConst() const { return getFastTypeQuals().hasConst(); }\n  bool isVolatile() const { return getFastTypeQuals().hasVolatile(); }\n  bool isRestrict() const { return getFastTypeQuals().hasRestrict(); }\n\n  /// Determine the type of an expression that calls a function of\n  /// this type.\n  QualType getCallResultType(const ASTContext &Context) const {\n    return getReturnType().getNonLValueExprType(Context);\n  }\n\n  static StringRef getNameForCallConv(CallingConv CC);\n\n  static bool classof(const Type *T) {\n    return T->getTypeClass() == FunctionNoProto ||\n           T->getTypeClass() == FunctionProto;\n  }\n};\n\n/// Represents a K&R-style 'int foo()' function, which has\n/// no information available about its arguments.\nclass FunctionNoProtoType : public FunctionType, public llvm::FoldingSetNode {\n  friend class ASTContext; // ASTContext creates these.\n\n  FunctionNoProtoType(QualType Result, QualType Canonical, ExtInfo Info)\n      : FunctionType(FunctionNoProto, Result, Canonical,\n                     Result->getDependence() &\n                         ~(TypeDependence::DependentInstantiation |\n                           TypeDependence::UnexpandedPack),\n                     Info) {}\n\npublic:\n  // No additional state past what FunctionType provides.\n\n  bool isSugared() const { return false; }\n  QualType desugar() const { return QualType(this, 0); }\n\n  void Profile(llvm::FoldingSetNodeID &ID) {\n    Profile(ID, getReturnType(), getExtInfo());\n  }\n\n  static void Profile(llvm::FoldingSetNodeID &ID, QualType ResultType,\n                      ExtInfo Info) {\n    Info.Profile(ID);\n    ID.AddPointer(ResultType.getAsOpaquePtr());\n  }\n\n  static bool classof(const Type *T) {\n    return T->getTypeClass() == FunctionNoProto;\n  }\n};\n\n/// Represents a prototype with parameter type info, e.g.\n/// 'int foo(int)' or 'int foo(void)'.  'void' is represented as having no\n/// parameters, not as having a single void parameter. Such a type can have\n/// an exception specification, but this specification is not part of the\n/// canonical type. FunctionProtoType has several trailing objects, some of\n/// which optional. For more information about the trailing objects see\n/// the first comment inside FunctionProtoType.\nclass FunctionProtoType final\n    : public FunctionType,\n      public llvm::FoldingSetNode,\n      private llvm::TrailingObjects<\n          FunctionProtoType, QualType, SourceLocation,\n          FunctionType::FunctionTypeExtraBitfields, FunctionType::ExceptionType,\n          Expr *, FunctionDecl *, FunctionType::ExtParameterInfo, Qualifiers> {\n  friend class ASTContext; // ASTContext creates these.\n  friend TrailingObjects;\n\n  // FunctionProtoType is followed by several trailing objects, some of\n  // which optional. They are in order:\n  //\n  // * An array of getNumParams() QualType holding the parameter types.\n  //   Always present. Note that for the vast majority of FunctionProtoType,\n  //   these will be the only trailing objects.\n  //\n  // * Optionally if the function is variadic, the SourceLocation of the\n  //   ellipsis.\n  //\n  // * Optionally if some extra data is stored in FunctionTypeExtraBitfields\n  //   (see FunctionTypeExtraBitfields and FunctionTypeBitfields):\n  //   a single FunctionTypeExtraBitfields. Present if and only if\n  //   hasExtraBitfields() is true.\n  //\n  // * Optionally exactly one of:\n  //   * an array of getNumExceptions() ExceptionType,\n  //   * a single Expr *,\n  //   * a pair of FunctionDecl *,\n  //   * a single FunctionDecl *\n  //   used to store information about the various types of exception\n  //   specification. See getExceptionSpecSize for the details.\n  //\n  // * Optionally an array of getNumParams() ExtParameterInfo holding\n  //   an ExtParameterInfo for each of the parameters. Present if and\n  //   only if hasExtParameterInfos() is true.\n  //\n  // * Optionally a Qualifiers object to represent extra qualifiers that can't\n  //   be represented by FunctionTypeBitfields.FastTypeQuals. Present if and only\n  //   if hasExtQualifiers() is true.\n  //\n  // The optional FunctionTypeExtraBitfields has to be before the data\n  // related to the exception specification since it contains the number\n  // of exception types.\n  //\n  // We put the ExtParameterInfos last.  If all were equal, it would make\n  // more sense to put these before the exception specification, because\n  // it's much easier to skip past them compared to the elaborate switch\n  // required to skip the exception specification.  However, all is not\n  // equal; ExtParameterInfos are used to model very uncommon features,\n  // and it's better not to burden the more common paths.\n\npublic:\n  /// Holds information about the various types of exception specification.\n  /// ExceptionSpecInfo is not stored as such in FunctionProtoType but is\n  /// used to group together the various bits of information about the\n  /// exception specification.\n  struct ExceptionSpecInfo {\n    /// The kind of exception specification this is.\n    ExceptionSpecificationType Type = EST_None;\n\n    /// Explicitly-specified list of exception types.\n    ArrayRef<QualType> Exceptions;\n\n    /// Noexcept expression, if this is a computed noexcept specification.\n    Expr *NoexceptExpr = nullptr;\n\n    /// The function whose exception specification this is, for\n    /// EST_Unevaluated and EST_Uninstantiated.\n    FunctionDecl *SourceDecl = nullptr;\n\n    /// The function template whose exception specification this is instantiated\n    /// from, for EST_Uninstantiated.\n    FunctionDecl *SourceTemplate = nullptr;\n\n    ExceptionSpecInfo() = default;\n\n    ExceptionSpecInfo(ExceptionSpecificationType EST) : Type(EST) {}\n  };\n\n  /// Extra information about a function prototype. ExtProtoInfo is not\n  /// stored as such in FunctionProtoType but is used to group together\n  /// the various bits of extra information about a function prototype.\n  struct ExtProtoInfo {\n    FunctionType::ExtInfo ExtInfo;\n    bool Variadic : 1;\n    bool HasTrailingReturn : 1;\n    Qualifiers TypeQuals;\n    RefQualifierKind RefQualifier = RQ_None;\n    ExceptionSpecInfo ExceptionSpec;\n    const ExtParameterInfo *ExtParameterInfos = nullptr;\n    SourceLocation EllipsisLoc;\n\n    ExtProtoInfo() : Variadic(false), HasTrailingReturn(false) {}\n\n    ExtProtoInfo(CallingConv CC)\n        : ExtInfo(CC), Variadic(false), HasTrailingReturn(false) {}\n\n    ExtProtoInfo withExceptionSpec(const ExceptionSpecInfo &ESI) {\n      ExtProtoInfo Result(*this);\n      Result.ExceptionSpec = ESI;\n      return Result;\n    }\n  };\n\nprivate:\n  unsigned numTrailingObjects(OverloadToken<QualType>) const {\n    return getNumParams();\n  }\n\n  unsigned numTrailingObjects(OverloadToken<SourceLocation>) const {\n    return isVariadic();\n  }\n\n  unsigned numTrailingObjects(OverloadToken<FunctionTypeExtraBitfields>) const {\n    return hasExtraBitfields();\n  }\n\n  unsigned numTrailingObjects(OverloadToken<ExceptionType>) const {\n    return getExceptionSpecSize().NumExceptionType;\n  }\n\n  unsigned numTrailingObjects(OverloadToken<Expr *>) const {\n    return getExceptionSpecSize().NumExprPtr;\n  }\n\n  unsigned numTrailingObjects(OverloadToken<FunctionDecl *>) const {\n    return getExceptionSpecSize().NumFunctionDeclPtr;\n  }\n\n  unsigned numTrailingObjects(OverloadToken<ExtParameterInfo>) const {\n    return hasExtParameterInfos() ? getNumParams() : 0;\n  }\n\n  /// Determine whether there are any argument types that\n  /// contain an unexpanded parameter pack.\n  static bool containsAnyUnexpandedParameterPack(const QualType *ArgArray,\n                                                 unsigned numArgs) {\n    for (unsigned Idx = 0; Idx < numArgs; ++Idx)\n      if (ArgArray[Idx]->containsUnexpandedParameterPack())\n        return true;\n\n    return false;\n  }\n\n  FunctionProtoType(QualType result, ArrayRef<QualType> params,\n                    QualType canonical, const ExtProtoInfo &epi);\n\n  /// This struct is returned by getExceptionSpecSize and is used to\n  /// translate an ExceptionSpecificationType to the number and kind\n  /// of trailing objects related to the exception specification.\n  struct ExceptionSpecSizeHolder {\n    unsigned NumExceptionType;\n    unsigned NumExprPtr;\n    unsigned NumFunctionDeclPtr;\n  };\n\n  /// Return the number and kind of trailing objects\n  /// related to the exception specification.\n  static ExceptionSpecSizeHolder\n  getExceptionSpecSize(ExceptionSpecificationType EST, unsigned NumExceptions) {\n    switch (EST) {\n    case EST_None:\n    case EST_DynamicNone:\n    case EST_MSAny:\n    case EST_BasicNoexcept:\n    case EST_Unparsed:\n    case EST_NoThrow:\n      return {0, 0, 0};\n\n    case EST_Dynamic:\n      return {NumExceptions, 0, 0};\n\n    case EST_DependentNoexcept:\n    case EST_NoexceptFalse:\n    case EST_NoexceptTrue:\n      return {0, 1, 0};\n\n    case EST_Uninstantiated:\n      return {0, 0, 2};\n\n    case EST_Unevaluated:\n      return {0, 0, 1};\n    }\n    llvm_unreachable(\"bad exception specification kind\");\n  }\n\n  /// Return the number and kind of trailing objects\n  /// related to the exception specification.\n  ExceptionSpecSizeHolder getExceptionSpecSize() const {\n    return getExceptionSpecSize(getExceptionSpecType(), getNumExceptions());\n  }\n\n  /// Whether the trailing FunctionTypeExtraBitfields is present.\n  static bool hasExtraBitfields(ExceptionSpecificationType EST) {\n    // If the exception spec type is EST_Dynamic then we have > 0 exception\n    // types and the exact number is stored in FunctionTypeExtraBitfields.\n    return EST == EST_Dynamic;\n  }\n\n  /// Whether the trailing FunctionTypeExtraBitfields is present.\n  bool hasExtraBitfields() const {\n    return hasExtraBitfields(getExceptionSpecType());\n  }\n\n  bool hasExtQualifiers() const {\n    return FunctionTypeBits.HasExtQuals;\n  }\n\npublic:\n  unsigned getNumParams() const { return FunctionTypeBits.NumParams; }\n\n  QualType getParamType(unsigned i) const {\n    assert(i < getNumParams() && \"invalid parameter index\");\n    return param_type_begin()[i];\n  }\n\n  ArrayRef<QualType> getParamTypes() const {\n    return llvm::makeArrayRef(param_type_begin(), param_type_end());\n  }\n\n  ExtProtoInfo getExtProtoInfo() const {\n    ExtProtoInfo EPI;\n    EPI.ExtInfo = getExtInfo();\n    EPI.Variadic = isVariadic();\n    EPI.EllipsisLoc = getEllipsisLoc();\n    EPI.HasTrailingReturn = hasTrailingReturn();\n    EPI.ExceptionSpec = getExceptionSpecInfo();\n    EPI.TypeQuals = getMethodQuals();\n    EPI.RefQualifier = getRefQualifier();\n    EPI.ExtParameterInfos = getExtParameterInfosOrNull();\n    return EPI;\n  }\n\n  /// Get the kind of exception specification on this function.\n  ExceptionSpecificationType getExceptionSpecType() const {\n    return static_cast<ExceptionSpecificationType>(\n        FunctionTypeBits.ExceptionSpecType);\n  }\n\n  /// Return whether this function has any kind of exception spec.\n  bool hasExceptionSpec() const { return getExceptionSpecType() != EST_None; }\n\n  /// Return whether this function has a dynamic (throw) exception spec.\n  bool hasDynamicExceptionSpec() const {\n    return isDynamicExceptionSpec(getExceptionSpecType());\n  }\n\n  /// Return whether this function has a noexcept exception spec.\n  bool hasNoexceptExceptionSpec() const {\n    return isNoexceptExceptionSpec(getExceptionSpecType());\n  }\n\n  /// Return whether this function has a dependent exception spec.\n  bool hasDependentExceptionSpec() const;\n\n  /// Return whether this function has an instantiation-dependent exception\n  /// spec.\n  bool hasInstantiationDependentExceptionSpec() const;\n\n  /// Return all the available information about this type's exception spec.\n  ExceptionSpecInfo getExceptionSpecInfo() const {\n    ExceptionSpecInfo Result;\n    Result.Type = getExceptionSpecType();\n    if (Result.Type == EST_Dynamic) {\n      Result.Exceptions = exceptions();\n    } else if (isComputedNoexcept(Result.Type)) {\n      Result.NoexceptExpr = getNoexceptExpr();\n    } else if (Result.Type == EST_Uninstantiated) {\n      Result.SourceDecl = getExceptionSpecDecl();\n      Result.SourceTemplate = getExceptionSpecTemplate();\n    } else if (Result.Type == EST_Unevaluated) {\n      Result.SourceDecl = getExceptionSpecDecl();\n    }\n    return Result;\n  }\n\n  /// Return the number of types in the exception specification.\n  unsigned getNumExceptions() const {\n    return getExceptionSpecType() == EST_Dynamic\n               ? getTrailingObjects<FunctionTypeExtraBitfields>()\n                     ->NumExceptionType\n               : 0;\n  }\n\n  /// Return the ith exception type, where 0 <= i < getNumExceptions().\n  QualType getExceptionType(unsigned i) const {\n    assert(i < getNumExceptions() && \"Invalid exception number!\");\n    return exception_begin()[i];\n  }\n\n  /// Return the expression inside noexcept(expression), or a null pointer\n  /// if there is none (because the exception spec is not of this form).\n  Expr *getNoexceptExpr() const {\n    if (!isComputedNoexcept(getExceptionSpecType()))\n      return nullptr;\n    return *getTrailingObjects<Expr *>();\n  }\n\n  /// If this function type has an exception specification which hasn't\n  /// been determined yet (either because it has not been evaluated or because\n  /// it has not been instantiated), this is the function whose exception\n  /// specification is represented by this type.\n  FunctionDecl *getExceptionSpecDecl() const {\n    if (getExceptionSpecType() != EST_Uninstantiated &&\n        getExceptionSpecType() != EST_Unevaluated)\n      return nullptr;\n    return getTrailingObjects<FunctionDecl *>()[0];\n  }\n\n  /// If this function type has an uninstantiated exception\n  /// specification, this is the function whose exception specification\n  /// should be instantiated to find the exception specification for\n  /// this type.\n  FunctionDecl *getExceptionSpecTemplate() const {\n    if (getExceptionSpecType() != EST_Uninstantiated)\n      return nullptr;\n    return getTrailingObjects<FunctionDecl *>()[1];\n  }\n\n  /// Determine whether this function type has a non-throwing exception\n  /// specification.\n  CanThrowResult canThrow() const;\n\n  /// Determine whether this function type has a non-throwing exception\n  /// specification. If this depends on template arguments, returns\n  /// \\c ResultIfDependent.\n  bool isNothrow(bool ResultIfDependent = false) const {\n    return ResultIfDependent ? canThrow() != CT_Can : canThrow() == CT_Cannot;\n  }\n\n  /// Whether this function prototype is variadic.\n  bool isVariadic() const { return FunctionTypeBits.Variadic; }\n\n  SourceLocation getEllipsisLoc() const {\n    return isVariadic() ? *getTrailingObjects<SourceLocation>()\n                        : SourceLocation();\n  }\n\n  /// Determines whether this function prototype contains a\n  /// parameter pack at the end.\n  ///\n  /// A function template whose last parameter is a parameter pack can be\n  /// called with an arbitrary number of arguments, much like a variadic\n  /// function.\n  bool isTemplateVariadic() const;\n\n  /// Whether this function prototype has a trailing return type.\n  bool hasTrailingReturn() const { return FunctionTypeBits.HasTrailingReturn; }\n\n  Qualifiers getMethodQuals() const {\n    if (hasExtQualifiers())\n      return *getTrailingObjects<Qualifiers>();\n    else\n      return getFastTypeQuals();\n  }\n\n  /// Retrieve the ref-qualifier associated with this function type.\n  RefQualifierKind getRefQualifier() const {\n    return static_cast<RefQualifierKind>(FunctionTypeBits.RefQualifier);\n  }\n\n  using param_type_iterator = const QualType *;\n  using param_type_range = llvm::iterator_range<param_type_iterator>;\n\n  param_type_range param_types() const {\n    return param_type_range(param_type_begin(), param_type_end());\n  }\n\n  param_type_iterator param_type_begin() const {\n    return getTrailingObjects<QualType>();\n  }\n\n  param_type_iterator param_type_end() const {\n    return param_type_begin() + getNumParams();\n  }\n\n  using exception_iterator = const QualType *;\n\n  ArrayRef<QualType> exceptions() const {\n    return llvm::makeArrayRef(exception_begin(), exception_end());\n  }\n\n  exception_iterator exception_begin() const {\n    return reinterpret_cast<exception_iterator>(\n        getTrailingObjects<ExceptionType>());\n  }\n\n  exception_iterator exception_end() const {\n    return exception_begin() + getNumExceptions();\n  }\n\n  /// Is there any interesting extra information for any of the parameters\n  /// of this function type?\n  bool hasExtParameterInfos() const {\n    return FunctionTypeBits.HasExtParameterInfos;\n  }\n\n  ArrayRef<ExtParameterInfo> getExtParameterInfos() const {\n    assert(hasExtParameterInfos());\n    return ArrayRef<ExtParameterInfo>(getTrailingObjects<ExtParameterInfo>(),\n                                      getNumParams());\n  }\n\n  /// Return a pointer to the beginning of the array of extra parameter\n  /// information, if present, or else null if none of the parameters\n  /// carry it.  This is equivalent to getExtProtoInfo().ExtParameterInfos.\n  const ExtParameterInfo *getExtParameterInfosOrNull() const {\n    if (!hasExtParameterInfos())\n      return nullptr;\n    return getTrailingObjects<ExtParameterInfo>();\n  }\n\n  ExtParameterInfo getExtParameterInfo(unsigned I) const {\n    assert(I < getNumParams() && \"parameter index out of range\");\n    if (hasExtParameterInfos())\n      return getTrailingObjects<ExtParameterInfo>()[I];\n    return ExtParameterInfo();\n  }\n\n  ParameterABI getParameterABI(unsigned I) const {\n    assert(I < getNumParams() && \"parameter index out of range\");\n    if (hasExtParameterInfos())\n      return getTrailingObjects<ExtParameterInfo>()[I].getABI();\n    return ParameterABI::Ordinary;\n  }\n\n  bool isParamConsumed(unsigned I) const {\n    assert(I < getNumParams() && \"parameter index out of range\");\n    if (hasExtParameterInfos())\n      return getTrailingObjects<ExtParameterInfo>()[I].isConsumed();\n    return false;\n  }\n\n  bool isSugared() const { return false; }\n  QualType desugar() const { return QualType(this, 0); }\n\n  void printExceptionSpecification(raw_ostream &OS,\n                                   const PrintingPolicy &Policy) const;\n\n  static bool classof(const Type *T) {\n    return T->getTypeClass() == FunctionProto;\n  }\n\n  void Profile(llvm::FoldingSetNodeID &ID, const ASTContext &Ctx);\n  static void Profile(llvm::FoldingSetNodeID &ID, QualType Result,\n                      param_type_iterator ArgTys, unsigned NumArgs,\n                      const ExtProtoInfo &EPI, const ASTContext &Context,\n                      bool Canonical);\n};\n\n/// Represents the dependent type named by a dependently-scoped\n/// typename using declaration, e.g.\n///   using typename Base<T>::foo;\n///\n/// Template instantiation turns these into the underlying type.\nclass UnresolvedUsingType : public Type {\n  friend class ASTContext; // ASTContext creates these.\n\n  UnresolvedUsingTypenameDecl *Decl;\n\n  UnresolvedUsingType(const UnresolvedUsingTypenameDecl *D)\n      : Type(UnresolvedUsing, QualType(),\n             TypeDependence::DependentInstantiation),\n        Decl(const_cast<UnresolvedUsingTypenameDecl *>(D)) {}\n\npublic:\n  UnresolvedUsingTypenameDecl *getDecl() const { return Decl; }\n\n  bool isSugared() const { return false; }\n  QualType desugar() const { return QualType(this, 0); }\n\n  static bool classof(const Type *T) {\n    return T->getTypeClass() == UnresolvedUsing;\n  }\n\n  void Profile(llvm::FoldingSetNodeID &ID) {\n    return Profile(ID, Decl);\n  }\n\n  static void Profile(llvm::FoldingSetNodeID &ID,\n                      UnresolvedUsingTypenameDecl *D) {\n    ID.AddPointer(D);\n  }\n};\n\nclass TypedefType : public Type {\n  TypedefNameDecl *Decl;\n\nprivate:\n  friend class ASTContext; // ASTContext creates these.\n\n  TypedefType(TypeClass tc, const TypedefNameDecl *D, QualType underlying,\n              QualType can);\n\npublic:\n  TypedefNameDecl *getDecl() const { return Decl; }\n\n  bool isSugared() const { return true; }\n  QualType desugar() const;\n\n  static bool classof(const Type *T) { return T->getTypeClass() == Typedef; }\n};\n\n/// Sugar type that represents a type that was qualified by a qualifier written\n/// as a macro invocation.\nclass MacroQualifiedType : public Type {\n  friend class ASTContext; // ASTContext creates these.\n\n  QualType UnderlyingTy;\n  const IdentifierInfo *MacroII;\n\n  MacroQualifiedType(QualType UnderlyingTy, QualType CanonTy,\n                     const IdentifierInfo *MacroII)\n      : Type(MacroQualified, CanonTy, UnderlyingTy->getDependence()),\n        UnderlyingTy(UnderlyingTy), MacroII(MacroII) {\n    assert(isa<AttributedType>(UnderlyingTy) &&\n           \"Expected a macro qualified type to only wrap attributed types.\");\n  }\n\npublic:\n  const IdentifierInfo *getMacroIdentifier() const { return MacroII; }\n  QualType getUnderlyingType() const { return UnderlyingTy; }\n\n  /// Return this attributed type's modified type with no qualifiers attached to\n  /// it.\n  QualType getModifiedType() const;\n\n  bool isSugared() const { return true; }\n  QualType desugar() const;\n\n  static bool classof(const Type *T) {\n    return T->getTypeClass() == MacroQualified;\n  }\n};\n\n/// Represents a `typeof` (or __typeof__) expression (a GCC extension).\nclass TypeOfExprType : public Type {\n  Expr *TOExpr;\n\nprotected:\n  friend class ASTContext; // ASTContext creates these.\n\n  TypeOfExprType(Expr *E, QualType can = QualType());\n\npublic:\n  Expr *getUnderlyingExpr() const { return TOExpr; }\n\n  /// Remove a single level of sugar.\n  QualType desugar() const;\n\n  /// Returns whether this type directly provides sugar.\n  bool isSugared() const;\n\n  static bool classof(const Type *T) { return T->getTypeClass() == TypeOfExpr; }\n};\n\n/// Internal representation of canonical, dependent\n/// `typeof(expr)` types.\n///\n/// This class is used internally by the ASTContext to manage\n/// canonical, dependent types, only. Clients will only see instances\n/// of this class via TypeOfExprType nodes.\nclass DependentTypeOfExprType\n  : public TypeOfExprType, public llvm::FoldingSetNode {\n  const ASTContext &Context;\n\npublic:\n  DependentTypeOfExprType(const ASTContext &Context, Expr *E)\n      : TypeOfExprType(E), Context(Context) {}\n\n  void Profile(llvm::FoldingSetNodeID &ID) {\n    Profile(ID, Context, getUnderlyingExpr());\n  }\n\n  static void Profile(llvm::FoldingSetNodeID &ID, const ASTContext &Context,\n                      Expr *E);\n};\n\n/// Represents `typeof(type)`, a GCC extension.\nclass TypeOfType : public Type {\n  friend class ASTContext; // ASTContext creates these.\n\n  QualType TOType;\n\n  TypeOfType(QualType T, QualType can)\n      : Type(TypeOf, can, T->getDependence()), TOType(T) {\n    assert(!isa<TypedefType>(can) && \"Invalid canonical type\");\n  }\n\npublic:\n  QualType getUnderlyingType() const { return TOType; }\n\n  /// Remove a single level of sugar.\n  QualType desugar() const { return getUnderlyingType(); }\n\n  /// Returns whether this type directly provides sugar.\n  bool isSugared() const { return true; }\n\n  static bool classof(const Type *T) { return T->getTypeClass() == TypeOf; }\n};\n\n/// Represents the type `decltype(expr)` (C++11).\nclass DecltypeType : public Type {\n  Expr *E;\n  QualType UnderlyingType;\n\nprotected:\n  friend class ASTContext; // ASTContext creates these.\n\n  DecltypeType(Expr *E, QualType underlyingType, QualType can = QualType());\n\npublic:\n  Expr *getUnderlyingExpr() const { return E; }\n  QualType getUnderlyingType() const { return UnderlyingType; }\n\n  /// Remove a single level of sugar.\n  QualType desugar() const;\n\n  /// Returns whether this type directly provides sugar.\n  bool isSugared() const;\n\n  static bool classof(const Type *T) { return T->getTypeClass() == Decltype; }\n};\n\n/// Internal representation of canonical, dependent\n/// decltype(expr) types.\n///\n/// This class is used internally by the ASTContext to manage\n/// canonical, dependent types, only. Clients will only see instances\n/// of this class via DecltypeType nodes.\nclass DependentDecltypeType : public DecltypeType, public llvm::FoldingSetNode {\n  const ASTContext &Context;\n\npublic:\n  DependentDecltypeType(const ASTContext &Context, Expr *E);\n\n  void Profile(llvm::FoldingSetNodeID &ID) {\n    Profile(ID, Context, getUnderlyingExpr());\n  }\n\n  static void Profile(llvm::FoldingSetNodeID &ID, const ASTContext &Context,\n                      Expr *E);\n};\n\n/// A unary type transform, which is a type constructed from another.\nclass UnaryTransformType : public Type {\npublic:\n  enum UTTKind {\n    EnumUnderlyingType\n  };\n\nprivate:\n  /// The untransformed type.\n  QualType BaseType;\n\n  /// The transformed type if not dependent, otherwise the same as BaseType.\n  QualType UnderlyingType;\n\n  UTTKind UKind;\n\nprotected:\n  friend class ASTContext;\n\n  UnaryTransformType(QualType BaseTy, QualType UnderlyingTy, UTTKind UKind,\n                     QualType CanonicalTy);\n\npublic:\n  bool isSugared() const { return !isDependentType(); }\n  QualType desugar() const { return UnderlyingType; }\n\n  QualType getUnderlyingType() const { return UnderlyingType; }\n  QualType getBaseType() const { return BaseType; }\n\n  UTTKind getUTTKind() const { return UKind; }\n\n  static bool classof(const Type *T) {\n    return T->getTypeClass() == UnaryTransform;\n  }\n};\n\n/// Internal representation of canonical, dependent\n/// __underlying_type(type) types.\n///\n/// This class is used internally by the ASTContext to manage\n/// canonical, dependent types, only. Clients will only see instances\n/// of this class via UnaryTransformType nodes.\nclass DependentUnaryTransformType : public UnaryTransformType,\n                                    public llvm::FoldingSetNode {\npublic:\n  DependentUnaryTransformType(const ASTContext &C, QualType BaseType,\n                              UTTKind UKind);\n\n  void Profile(llvm::FoldingSetNodeID &ID) {\n    Profile(ID, getBaseType(), getUTTKind());\n  }\n\n  static void Profile(llvm::FoldingSetNodeID &ID, QualType BaseType,\n                      UTTKind UKind) {\n    ID.AddPointer(BaseType.getAsOpaquePtr());\n    ID.AddInteger((unsigned)UKind);\n  }\n};\n\nclass TagType : public Type {\n  friend class ASTReader;\n  template <class T> friend class serialization::AbstractTypeReader;\n\n  /// Stores the TagDecl associated with this type. The decl may point to any\n  /// TagDecl that declares the entity.\n  TagDecl *decl;\n\nprotected:\n  TagType(TypeClass TC, const TagDecl *D, QualType can);\n\npublic:\n  TagDecl *getDecl() const;\n\n  /// Determines whether this type is in the process of being defined.\n  bool isBeingDefined() const;\n\n  static bool classof(const Type *T) {\n    return T->getTypeClass() == Enum || T->getTypeClass() == Record;\n  }\n};\n\n/// A helper class that allows the use of isa/cast/dyncast\n/// to detect TagType objects of structs/unions/classes.\nclass RecordType : public TagType {\nprotected:\n  friend class ASTContext; // ASTContext creates these.\n\n  explicit RecordType(const RecordDecl *D)\n      : TagType(Record, reinterpret_cast<const TagDecl*>(D), QualType()) {}\n  explicit RecordType(TypeClass TC, RecordDecl *D)\n      : TagType(TC, reinterpret_cast<const TagDecl*>(D), QualType()) {}\n\npublic:\n  RecordDecl *getDecl() const {\n    return reinterpret_cast<RecordDecl*>(TagType::getDecl());\n  }\n\n  /// Recursively check all fields in the record for const-ness. If any field\n  /// is declared const, return true. Otherwise, return false.\n  bool hasConstFields() const;\n\n  bool isSugared() const { return false; }\n  QualType desugar() const { return QualType(this, 0); }\n\n  static bool classof(const Type *T) { return T->getTypeClass() == Record; }\n};\n\n/// A helper class that allows the use of isa/cast/dyncast\n/// to detect TagType objects of enums.\nclass EnumType : public TagType {\n  friend class ASTContext; // ASTContext creates these.\n\n  explicit EnumType(const EnumDecl *D)\n      : TagType(Enum, reinterpret_cast<const TagDecl*>(D), QualType()) {}\n\npublic:\n  EnumDecl *getDecl() const {\n    return reinterpret_cast<EnumDecl*>(TagType::getDecl());\n  }\n\n  bool isSugared() const { return false; }\n  QualType desugar() const { return QualType(this, 0); }\n\n  static bool classof(const Type *T) { return T->getTypeClass() == Enum; }\n};\n\n/// An attributed type is a type to which a type attribute has been applied.\n///\n/// The \"modified type\" is the fully-sugared type to which the attributed\n/// type was applied; generally it is not canonically equivalent to the\n/// attributed type. The \"equivalent type\" is the minimally-desugared type\n/// which the type is canonically equivalent to.\n///\n/// For example, in the following attributed type:\n///     int32_t __attribute__((vector_size(16)))\n///   - the modified type is the TypedefType for int32_t\n///   - the equivalent type is VectorType(16, int32_t)\n///   - the canonical type is VectorType(16, int)\nclass AttributedType : public Type, public llvm::FoldingSetNode {\npublic:\n  using Kind = attr::Kind;\n\nprivate:\n  friend class ASTContext; // ASTContext creates these\n\n  QualType ModifiedType;\n  QualType EquivalentType;\n\n  AttributedType(QualType canon, attr::Kind attrKind, QualType modified,\n                 QualType equivalent)\n      : Type(Attributed, canon, equivalent->getDependence()),\n        ModifiedType(modified), EquivalentType(equivalent) {\n    AttributedTypeBits.AttrKind = attrKind;\n  }\n\npublic:\n  Kind getAttrKind() const {\n    return static_cast<Kind>(AttributedTypeBits.AttrKind);\n  }\n\n  QualType getModifiedType() const { return ModifiedType; }\n  QualType getEquivalentType() const { return EquivalentType; }\n\n  bool isSugared() const { return true; }\n  QualType desugar() const { return getEquivalentType(); }\n\n  /// Does this attribute behave like a type qualifier?\n  ///\n  /// A type qualifier adjusts a type to provide specialized rules for\n  /// a specific object, like the standard const and volatile qualifiers.\n  /// This includes attributes controlling things like nullability,\n  /// address spaces, and ARC ownership.  The value of the object is still\n  /// largely described by the modified type.\n  ///\n  /// In contrast, many type attributes \"rewrite\" their modified type to\n  /// produce a fundamentally different type, not necessarily related in any\n  /// formalizable way to the original type.  For example, calling convention\n  /// and vector attributes are not simple type qualifiers.\n  ///\n  /// Type qualifiers are often, but not always, reflected in the canonical\n  /// type.\n  bool isQualifier() const;\n\n  bool isMSTypeSpec() const;\n\n  bool isCallingConv() const;\n\n  llvm::Optional<NullabilityKind> getImmediateNullability() const;\n\n  /// Retrieve the attribute kind corresponding to the given\n  /// nullability kind.\n  static Kind getNullabilityAttrKind(NullabilityKind kind) {\n    switch (kind) {\n    case NullabilityKind::NonNull:\n      return attr::TypeNonNull;\n\n    case NullabilityKind::Nullable:\n      return attr::TypeNullable;\n\n    case NullabilityKind::NullableResult:\n      return attr::TypeNullableResult;\n\n    case NullabilityKind::Unspecified:\n      return attr::TypeNullUnspecified;\n    }\n    llvm_unreachable(\"Unknown nullability kind.\");\n  }\n\n  /// Strip off the top-level nullability annotation on the given\n  /// type, if it's there.\n  ///\n  /// \\param T The type to strip. If the type is exactly an\n  /// AttributedType specifying nullability (without looking through\n  /// type sugar), the nullability is returned and this type changed\n  /// to the underlying modified type.\n  ///\n  /// \\returns the top-level nullability, if present.\n  static Optional<NullabilityKind> stripOuterNullability(QualType &T);\n\n  void Profile(llvm::FoldingSetNodeID &ID) {\n    Profile(ID, getAttrKind(), ModifiedType, EquivalentType);\n  }\n\n  static void Profile(llvm::FoldingSetNodeID &ID, Kind attrKind,\n                      QualType modified, QualType equivalent) {\n    ID.AddInteger(attrKind);\n    ID.AddPointer(modified.getAsOpaquePtr());\n    ID.AddPointer(equivalent.getAsOpaquePtr());\n  }\n\n  static bool classof(const Type *T) {\n    return T->getTypeClass() == Attributed;\n  }\n};\n\nclass TemplateTypeParmType : public Type, public llvm::FoldingSetNode {\n  friend class ASTContext; // ASTContext creates these\n\n  // Helper data collector for canonical types.\n  struct CanonicalTTPTInfo {\n    unsigned Depth : 15;\n    unsigned ParameterPack : 1;\n    unsigned Index : 16;\n  };\n\n  union {\n    // Info for the canonical type.\n    CanonicalTTPTInfo CanTTPTInfo;\n\n    // Info for the non-canonical type.\n    TemplateTypeParmDecl *TTPDecl;\n  };\n\n  /// Build a non-canonical type.\n  TemplateTypeParmType(TemplateTypeParmDecl *TTPDecl, QualType Canon)\n      : Type(TemplateTypeParm, Canon,\n             TypeDependence::DependentInstantiation |\n                 (Canon->getDependence() & TypeDependence::UnexpandedPack)),\n        TTPDecl(TTPDecl) {}\n\n  /// Build the canonical type.\n  TemplateTypeParmType(unsigned D, unsigned I, bool PP)\n      : Type(TemplateTypeParm, QualType(this, 0),\n             TypeDependence::DependentInstantiation |\n                 (PP ? TypeDependence::UnexpandedPack : TypeDependence::None)) {\n    CanTTPTInfo.Depth = D;\n    CanTTPTInfo.Index = I;\n    CanTTPTInfo.ParameterPack = PP;\n  }\n\n  const CanonicalTTPTInfo& getCanTTPTInfo() const {\n    QualType Can = getCanonicalTypeInternal();\n    return Can->castAs<TemplateTypeParmType>()->CanTTPTInfo;\n  }\n\npublic:\n  unsigned getDepth() const { return getCanTTPTInfo().Depth; }\n  unsigned getIndex() const { return getCanTTPTInfo().Index; }\n  bool isParameterPack() const { return getCanTTPTInfo().ParameterPack; }\n\n  TemplateTypeParmDecl *getDecl() const {\n    return isCanonicalUnqualified() ? nullptr : TTPDecl;\n  }\n\n  IdentifierInfo *getIdentifier() const;\n\n  bool isSugared() const { return false; }\n  QualType desugar() const { return QualType(this, 0); }\n\n  void Profile(llvm::FoldingSetNodeID &ID) {\n    Profile(ID, getDepth(), getIndex(), isParameterPack(), getDecl());\n  }\n\n  static void Profile(llvm::FoldingSetNodeID &ID, unsigned Depth,\n                      unsigned Index, bool ParameterPack,\n                      TemplateTypeParmDecl *TTPDecl) {\n    ID.AddInteger(Depth);\n    ID.AddInteger(Index);\n    ID.AddBoolean(ParameterPack);\n    ID.AddPointer(TTPDecl);\n  }\n\n  static bool classof(const Type *T) {\n    return T->getTypeClass() == TemplateTypeParm;\n  }\n};\n\n/// Represents the result of substituting a type for a template\n/// type parameter.\n///\n/// Within an instantiated template, all template type parameters have\n/// been replaced with these.  They are used solely to record that a\n/// type was originally written as a template type parameter;\n/// therefore they are never canonical.\nclass SubstTemplateTypeParmType : public Type, public llvm::FoldingSetNode {\n  friend class ASTContext;\n\n  // The original type parameter.\n  const TemplateTypeParmType *Replaced;\n\n  SubstTemplateTypeParmType(const TemplateTypeParmType *Param, QualType Canon)\n      : Type(SubstTemplateTypeParm, Canon, Canon->getDependence()),\n        Replaced(Param) {}\n\npublic:\n  /// Gets the template parameter that was substituted for.\n  const TemplateTypeParmType *getReplacedParameter() const {\n    return Replaced;\n  }\n\n  /// Gets the type that was substituted for the template\n  /// parameter.\n  QualType getReplacementType() const {\n    return getCanonicalTypeInternal();\n  }\n\n  bool isSugared() const { return true; }\n  QualType desugar() const { return getReplacementType(); }\n\n  void Profile(llvm::FoldingSetNodeID &ID) {\n    Profile(ID, getReplacedParameter(), getReplacementType());\n  }\n\n  static void Profile(llvm::FoldingSetNodeID &ID,\n                      const TemplateTypeParmType *Replaced,\n                      QualType Replacement) {\n    ID.AddPointer(Replaced);\n    ID.AddPointer(Replacement.getAsOpaquePtr());\n  }\n\n  static bool classof(const Type *T) {\n    return T->getTypeClass() == SubstTemplateTypeParm;\n  }\n};\n\n/// Represents the result of substituting a set of types for a template\n/// type parameter pack.\n///\n/// When a pack expansion in the source code contains multiple parameter packs\n/// and those parameter packs correspond to different levels of template\n/// parameter lists, this type node is used to represent a template type\n/// parameter pack from an outer level, which has already had its argument pack\n/// substituted but that still lives within a pack expansion that itself\n/// could not be instantiated. When actually performing a substitution into\n/// that pack expansion (e.g., when all template parameters have corresponding\n/// arguments), this type will be replaced with the \\c SubstTemplateTypeParmType\n/// at the current pack substitution index.\nclass SubstTemplateTypeParmPackType : public Type, public llvm::FoldingSetNode {\n  friend class ASTContext;\n\n  /// The original type parameter.\n  const TemplateTypeParmType *Replaced;\n\n  /// A pointer to the set of template arguments that this\n  /// parameter pack is instantiated with.\n  const TemplateArgument *Arguments;\n\n  SubstTemplateTypeParmPackType(const TemplateTypeParmType *Param,\n                                QualType Canon,\n                                const TemplateArgument &ArgPack);\n\npublic:\n  IdentifierInfo *getIdentifier() const { return Replaced->getIdentifier(); }\n\n  /// Gets the template parameter that was substituted for.\n  const TemplateTypeParmType *getReplacedParameter() const {\n    return Replaced;\n  }\n\n  unsigned getNumArgs() const {\n    return SubstTemplateTypeParmPackTypeBits.NumArgs;\n  }\n\n  bool isSugared() const { return false; }\n  QualType desugar() const { return QualType(this, 0); }\n\n  TemplateArgument getArgumentPack() const;\n\n  void Profile(llvm::FoldingSetNodeID &ID);\n  static void Profile(llvm::FoldingSetNodeID &ID,\n                      const TemplateTypeParmType *Replaced,\n                      const TemplateArgument &ArgPack);\n\n  static bool classof(const Type *T) {\n    return T->getTypeClass() == SubstTemplateTypeParmPack;\n  }\n};\n\n/// Common base class for placeholders for types that get replaced by\n/// placeholder type deduction: C++11 auto, C++14 decltype(auto), C++17 deduced\n/// class template types, and constrained type names.\n///\n/// These types are usually a placeholder for a deduced type. However, before\n/// the initializer is attached, or (usually) if the initializer is\n/// type-dependent, there is no deduced type and the type is canonical. In\n/// the latter case, it is also a dependent type.\nclass DeducedType : public Type {\nprotected:\n  DeducedType(TypeClass TC, QualType DeducedAsType,\n              TypeDependence ExtraDependence)\n      : Type(TC,\n             // FIXME: Retain the sugared deduced type?\n             DeducedAsType.isNull() ? QualType(this, 0)\n                                    : DeducedAsType.getCanonicalType(),\n             ExtraDependence | (DeducedAsType.isNull()\n                                    ? TypeDependence::None\n                                    : DeducedAsType->getDependence() &\n                                          ~TypeDependence::VariablyModified)) {}\n\npublic:\n  bool isSugared() const { return !isCanonicalUnqualified(); }\n  QualType desugar() const { return getCanonicalTypeInternal(); }\n\n  /// Get the type deduced for this placeholder type, or null if it's\n  /// either not been deduced or was deduced to a dependent type.\n  QualType getDeducedType() const {\n    return !isCanonicalUnqualified() ? getCanonicalTypeInternal() : QualType();\n  }\n  bool isDeduced() const {\n    return !isCanonicalUnqualified() || isDependentType();\n  }\n\n  static bool classof(const Type *T) {\n    return T->getTypeClass() == Auto ||\n           T->getTypeClass() == DeducedTemplateSpecialization;\n  }\n};\n\n/// Represents a C++11 auto or C++14 decltype(auto) type, possibly constrained\n/// by a type-constraint.\nclass alignas(8) AutoType : public DeducedType, public llvm::FoldingSetNode {\n  friend class ASTContext; // ASTContext creates these\n\n  ConceptDecl *TypeConstraintConcept;\n\n  AutoType(QualType DeducedAsType, AutoTypeKeyword Keyword,\n           TypeDependence ExtraDependence, ConceptDecl *CD,\n           ArrayRef<TemplateArgument> TypeConstraintArgs);\n\n  const TemplateArgument *getArgBuffer() const {\n    return reinterpret_cast<const TemplateArgument*>(this+1);\n  }\n\n  TemplateArgument *getArgBuffer() {\n    return reinterpret_cast<TemplateArgument*>(this+1);\n  }\n\npublic:\n  /// Retrieve the template arguments.\n  const TemplateArgument *getArgs() const {\n    return getArgBuffer();\n  }\n\n  /// Retrieve the number of template arguments.\n  unsigned getNumArgs() const {\n    return AutoTypeBits.NumArgs;\n  }\n\n  const TemplateArgument &getArg(unsigned Idx) const; // in TemplateBase.h\n\n  ArrayRef<TemplateArgument> getTypeConstraintArguments() const {\n    return {getArgs(), getNumArgs()};\n  }\n\n  ConceptDecl *getTypeConstraintConcept() const {\n    return TypeConstraintConcept;\n  }\n\n  bool isConstrained() const {\n    return TypeConstraintConcept != nullptr;\n  }\n\n  bool isDecltypeAuto() const {\n    return getKeyword() == AutoTypeKeyword::DecltypeAuto;\n  }\n\n  AutoTypeKeyword getKeyword() const {\n    return (AutoTypeKeyword)AutoTypeBits.Keyword;\n  }\n\n  void Profile(llvm::FoldingSetNodeID &ID, const ASTContext &Context) {\n    Profile(ID, Context, getDeducedType(), getKeyword(), isDependentType(),\n            getTypeConstraintConcept(), getTypeConstraintArguments());\n  }\n\n  static void Profile(llvm::FoldingSetNodeID &ID, const ASTContext &Context,\n                      QualType Deduced, AutoTypeKeyword Keyword,\n                      bool IsDependent, ConceptDecl *CD,\n                      ArrayRef<TemplateArgument> Arguments);\n\n  static bool classof(const Type *T) {\n    return T->getTypeClass() == Auto;\n  }\n};\n\n/// Represents a C++17 deduced template specialization type.\nclass DeducedTemplateSpecializationType : public DeducedType,\n                                          public llvm::FoldingSetNode {\n  friend class ASTContext; // ASTContext creates these\n\n  /// The name of the template whose arguments will be deduced.\n  TemplateName Template;\n\n  DeducedTemplateSpecializationType(TemplateName Template,\n                                    QualType DeducedAsType,\n                                    bool IsDeducedAsDependent)\n      : DeducedType(DeducedTemplateSpecialization, DeducedAsType,\n                    toTypeDependence(Template.getDependence()) |\n                        (IsDeducedAsDependent\n                             ? TypeDependence::DependentInstantiation\n                             : TypeDependence::None)),\n        Template(Template) {}\n\npublic:\n  /// Retrieve the name of the template that we are deducing.\n  TemplateName getTemplateName() const { return Template;}\n\n  void Profile(llvm::FoldingSetNodeID &ID) {\n    Profile(ID, getTemplateName(), getDeducedType(), isDependentType());\n  }\n\n  static void Profile(llvm::FoldingSetNodeID &ID, TemplateName Template,\n                      QualType Deduced, bool IsDependent) {\n    Template.Profile(ID);\n    ID.AddPointer(Deduced.getAsOpaquePtr());\n    ID.AddBoolean(IsDependent);\n  }\n\n  static bool classof(const Type *T) {\n    return T->getTypeClass() == DeducedTemplateSpecialization;\n  }\n};\n\n/// Represents a type template specialization; the template\n/// must be a class template, a type alias template, or a template\n/// template parameter.  A template which cannot be resolved to one of\n/// these, e.g. because it is written with a dependent scope\n/// specifier, is instead represented as a\n/// @c DependentTemplateSpecializationType.\n///\n/// A non-dependent template specialization type is always \"sugar\",\n/// typically for a \\c RecordType.  For example, a class template\n/// specialization type of \\c vector<int> will refer to a tag type for\n/// the instantiation \\c std::vector<int, std::allocator<int>>\n///\n/// Template specializations are dependent if either the template or\n/// any of the template arguments are dependent, in which case the\n/// type may also be canonical.\n///\n/// Instances of this type are allocated with a trailing array of\n/// TemplateArguments, followed by a QualType representing the\n/// non-canonical aliased type when the template is a type alias\n/// template.\nclass alignas(8) TemplateSpecializationType\n    : public Type,\n      public llvm::FoldingSetNode {\n  friend class ASTContext; // ASTContext creates these\n\n  /// The name of the template being specialized.  This is\n  /// either a TemplateName::Template (in which case it is a\n  /// ClassTemplateDecl*, a TemplateTemplateParmDecl*, or a\n  /// TypeAliasTemplateDecl*), a\n  /// TemplateName::SubstTemplateTemplateParmPack, or a\n  /// TemplateName::SubstTemplateTemplateParm (in which case the\n  /// replacement must, recursively, be one of these).\n  TemplateName Template;\n\n  TemplateSpecializationType(TemplateName T,\n                             ArrayRef<TemplateArgument> Args,\n                             QualType Canon,\n                             QualType Aliased);\n\npublic:\n  /// Determine whether any of the given template arguments are dependent.\n  ///\n  /// The converted arguments should be supplied when known; whether an\n  /// argument is dependent can depend on the conversions performed on it\n  /// (for example, a 'const int' passed as a template argument might be\n  /// dependent if the parameter is a reference but non-dependent if the\n  /// parameter is an int).\n  ///\n  /// Note that the \\p Args parameter is unused: this is intentional, to remind\n  /// the caller that they need to pass in the converted arguments, not the\n  /// specified arguments.\n  static bool\n  anyDependentTemplateArguments(ArrayRef<TemplateArgumentLoc> Args,\n                                ArrayRef<TemplateArgument> Converted);\n  static bool\n  anyDependentTemplateArguments(const TemplateArgumentListInfo &,\n                                ArrayRef<TemplateArgument> Converted);\n  static bool anyInstantiationDependentTemplateArguments(\n      ArrayRef<TemplateArgumentLoc> Args);\n\n  /// True if this template specialization type matches a current\n  /// instantiation in the context in which it is found.\n  bool isCurrentInstantiation() const {\n    return isa<InjectedClassNameType>(getCanonicalTypeInternal());\n  }\n\n  /// Determine if this template specialization type is for a type alias\n  /// template that has been substituted.\n  ///\n  /// Nearly every template specialization type whose template is an alias\n  /// template will be substituted. However, this is not the case when\n  /// the specialization contains a pack expansion but the template alias\n  /// does not have a corresponding parameter pack, e.g.,\n  ///\n  /// \\code\n  /// template<typename T, typename U, typename V> struct S;\n  /// template<typename T, typename U> using A = S<T, int, U>;\n  /// template<typename... Ts> struct X {\n  ///   typedef A<Ts...> type; // not a type alias\n  /// };\n  /// \\endcode\n  bool isTypeAlias() const { return TemplateSpecializationTypeBits.TypeAlias; }\n\n  /// Get the aliased type, if this is a specialization of a type alias\n  /// template.\n  QualType getAliasedType() const {\n    assert(isTypeAlias() && \"not a type alias template specialization\");\n    return *reinterpret_cast<const QualType*>(end());\n  }\n\n  using iterator = const TemplateArgument *;\n\n  iterator begin() const { return getArgs(); }\n  iterator end() const; // defined inline in TemplateBase.h\n\n  /// Retrieve the name of the template that we are specializing.\n  TemplateName getTemplateName() const { return Template; }\n\n  /// Retrieve the template arguments.\n  const TemplateArgument *getArgs() const {\n    return reinterpret_cast<const TemplateArgument *>(this + 1);\n  }\n\n  /// Retrieve the number of template arguments.\n  unsigned getNumArgs() const {\n    return TemplateSpecializationTypeBits.NumArgs;\n  }\n\n  /// Retrieve a specific template argument as a type.\n  /// \\pre \\c isArgType(Arg)\n  const TemplateArgument &getArg(unsigned Idx) const; // in TemplateBase.h\n\n  ArrayRef<TemplateArgument> template_arguments() const {\n    return {getArgs(), getNumArgs()};\n  }\n\n  bool isSugared() const {\n    return !isDependentType() || isCurrentInstantiation() || isTypeAlias();\n  }\n\n  QualType desugar() const {\n    return isTypeAlias() ? getAliasedType() : getCanonicalTypeInternal();\n  }\n\n  void Profile(llvm::FoldingSetNodeID &ID, const ASTContext &Ctx) {\n    Profile(ID, Template, template_arguments(), Ctx);\n    if (isTypeAlias())\n      getAliasedType().Profile(ID);\n  }\n\n  static void Profile(llvm::FoldingSetNodeID &ID, TemplateName T,\n                      ArrayRef<TemplateArgument> Args,\n                      const ASTContext &Context);\n\n  static bool classof(const Type *T) {\n    return T->getTypeClass() == TemplateSpecialization;\n  }\n};\n\n/// Print a template argument list, including the '<' and '>'\n/// enclosing the template arguments.\nvoid printTemplateArgumentList(raw_ostream &OS,\n                               ArrayRef<TemplateArgument> Args,\n                               const PrintingPolicy &Policy,\n                               const TemplateParameterList *TPL = nullptr);\n\nvoid printTemplateArgumentList(raw_ostream &OS,\n                               ArrayRef<TemplateArgumentLoc> Args,\n                               const PrintingPolicy &Policy,\n                               const TemplateParameterList *TPL = nullptr);\n\nvoid printTemplateArgumentList(raw_ostream &OS,\n                               const TemplateArgumentListInfo &Args,\n                               const PrintingPolicy &Policy,\n                               const TemplateParameterList *TPL = nullptr);\n\n/// The injected class name of a C++ class template or class\n/// template partial specialization.  Used to record that a type was\n/// spelled with a bare identifier rather than as a template-id; the\n/// equivalent for non-templated classes is just RecordType.\n///\n/// Injected class name types are always dependent.  Template\n/// instantiation turns these into RecordTypes.\n///\n/// Injected class name types are always canonical.  This works\n/// because it is impossible to compare an injected class name type\n/// with the corresponding non-injected template type, for the same\n/// reason that it is impossible to directly compare template\n/// parameters from different dependent contexts: injected class name\n/// types can only occur within the scope of a particular templated\n/// declaration, and within that scope every template specialization\n/// will canonicalize to the injected class name (when appropriate\n/// according to the rules of the language).\nclass InjectedClassNameType : public Type {\n  friend class ASTContext; // ASTContext creates these.\n  friend class ASTNodeImporter;\n  friend class ASTReader; // FIXME: ASTContext::getInjectedClassNameType is not\n                          // currently suitable for AST reading, too much\n                          // interdependencies.\n  template <class T> friend class serialization::AbstractTypeReader;\n\n  CXXRecordDecl *Decl;\n\n  /// The template specialization which this type represents.\n  /// For example, in\n  ///   template <class T> class A { ... };\n  /// this is A<T>, whereas in\n  ///   template <class X, class Y> class A<B<X,Y> > { ... };\n  /// this is A<B<X,Y> >.\n  ///\n  /// It is always unqualified, always a template specialization type,\n  /// and always dependent.\n  QualType InjectedType;\n\n  InjectedClassNameType(CXXRecordDecl *D, QualType TST)\n      : Type(InjectedClassName, QualType(),\n             TypeDependence::DependentInstantiation),\n        Decl(D), InjectedType(TST) {\n    assert(isa<TemplateSpecializationType>(TST));\n    assert(!TST.hasQualifiers());\n    assert(TST->isDependentType());\n  }\n\npublic:\n  QualType getInjectedSpecializationType() const { return InjectedType; }\n\n  const TemplateSpecializationType *getInjectedTST() const {\n    return cast<TemplateSpecializationType>(InjectedType.getTypePtr());\n  }\n\n  TemplateName getTemplateName() const {\n    return getInjectedTST()->getTemplateName();\n  }\n\n  CXXRecordDecl *getDecl() const;\n\n  bool isSugared() const { return false; }\n  QualType desugar() const { return QualType(this, 0); }\n\n  static bool classof(const Type *T) {\n    return T->getTypeClass() == InjectedClassName;\n  }\n};\n\n/// The kind of a tag type.\nenum TagTypeKind {\n  /// The \"struct\" keyword.\n  TTK_Struct,\n\n  /// The \"__interface\" keyword.\n  TTK_Interface,\n\n  /// The \"union\" keyword.\n  TTK_Union,\n\n  /// The \"class\" keyword.\n  TTK_Class,\n\n  /// The \"enum\" keyword.\n  TTK_Enum\n};\n\n/// The elaboration keyword that precedes a qualified type name or\n/// introduces an elaborated-type-specifier.\nenum ElaboratedTypeKeyword {\n  /// The \"struct\" keyword introduces the elaborated-type-specifier.\n  ETK_Struct,\n\n  /// The \"__interface\" keyword introduces the elaborated-type-specifier.\n  ETK_Interface,\n\n  /// The \"union\" keyword introduces the elaborated-type-specifier.\n  ETK_Union,\n\n  /// The \"class\" keyword introduces the elaborated-type-specifier.\n  ETK_Class,\n\n  /// The \"enum\" keyword introduces the elaborated-type-specifier.\n  ETK_Enum,\n\n  /// The \"typename\" keyword precedes the qualified type name, e.g.,\n  /// \\c typename T::type.\n  ETK_Typename,\n\n  /// No keyword precedes the qualified type name.\n  ETK_None\n};\n\n/// A helper class for Type nodes having an ElaboratedTypeKeyword.\n/// The keyword in stored in the free bits of the base class.\n/// Also provides a few static helpers for converting and printing\n/// elaborated type keyword and tag type kind enumerations.\nclass TypeWithKeyword : public Type {\nprotected:\n  TypeWithKeyword(ElaboratedTypeKeyword Keyword, TypeClass tc,\n                  QualType Canonical, TypeDependence Dependence)\n      : Type(tc, Canonical, Dependence) {\n    TypeWithKeywordBits.Keyword = Keyword;\n  }\n\npublic:\n  ElaboratedTypeKeyword getKeyword() const {\n    return static_cast<ElaboratedTypeKeyword>(TypeWithKeywordBits.Keyword);\n  }\n\n  /// Converts a type specifier (DeclSpec::TST) into an elaborated type keyword.\n  static ElaboratedTypeKeyword getKeywordForTypeSpec(unsigned TypeSpec);\n\n  /// Converts a type specifier (DeclSpec::TST) into a tag type kind.\n  /// It is an error to provide a type specifier which *isn't* a tag kind here.\n  static TagTypeKind getTagTypeKindForTypeSpec(unsigned TypeSpec);\n\n  /// Converts a TagTypeKind into an elaborated type keyword.\n  static ElaboratedTypeKeyword getKeywordForTagTypeKind(TagTypeKind Tag);\n\n  /// Converts an elaborated type keyword into a TagTypeKind.\n  /// It is an error to provide an elaborated type keyword\n  /// which *isn't* a tag kind here.\n  static TagTypeKind getTagTypeKindForKeyword(ElaboratedTypeKeyword Keyword);\n\n  static bool KeywordIsTagTypeKind(ElaboratedTypeKeyword Keyword);\n\n  static StringRef getKeywordName(ElaboratedTypeKeyword Keyword);\n\n  static StringRef getTagTypeKindName(TagTypeKind Kind) {\n    return getKeywordName(getKeywordForTagTypeKind(Kind));\n  }\n\n  class CannotCastToThisType {};\n  static CannotCastToThisType classof(const Type *);\n};\n\n/// Represents a type that was referred to using an elaborated type\n/// keyword, e.g., struct S, or via a qualified name, e.g., N::M::type,\n/// or both.\n///\n/// This type is used to keep track of a type name as written in the\n/// source code, including tag keywords and any nested-name-specifiers.\n/// The type itself is always \"sugar\", used to express what was written\n/// in the source code but containing no additional semantic information.\nclass ElaboratedType final\n    : public TypeWithKeyword,\n      public llvm::FoldingSetNode,\n      private llvm::TrailingObjects<ElaboratedType, TagDecl *> {\n  friend class ASTContext; // ASTContext creates these\n  friend TrailingObjects;\n\n  /// The nested name specifier containing the qualifier.\n  NestedNameSpecifier *NNS;\n\n  /// The type that this qualified name refers to.\n  QualType NamedType;\n\n  /// The (re)declaration of this tag type owned by this occurrence is stored\n  /// as a trailing object if there is one. Use getOwnedTagDecl to obtain\n  /// it, or obtain a null pointer if there is none.\n\n  ElaboratedType(ElaboratedTypeKeyword Keyword, NestedNameSpecifier *NNS,\n                 QualType NamedType, QualType CanonType, TagDecl *OwnedTagDecl)\n      : TypeWithKeyword(Keyword, Elaborated, CanonType,\n                        // Any semantic dependence on the qualifier will have\n                        // been incorporated into NamedType. We still need to\n                        // track syntactic (instantiation / error / pack)\n                        // dependence on the qualifier.\n                        NamedType->getDependence() |\n                            (NNS ? toSyntacticDependence(\n                                       toTypeDependence(NNS->getDependence()))\n                                 : TypeDependence::None)),\n        NNS(NNS), NamedType(NamedType) {\n    ElaboratedTypeBits.HasOwnedTagDecl = false;\n    if (OwnedTagDecl) {\n      ElaboratedTypeBits.HasOwnedTagDecl = true;\n      *getTrailingObjects<TagDecl *>() = OwnedTagDecl;\n    }\n    assert(!(Keyword == ETK_None && NNS == nullptr) &&\n           \"ElaboratedType cannot have elaborated type keyword \"\n           \"and name qualifier both null.\");\n  }\n\npublic:\n  /// Retrieve the qualification on this type.\n  NestedNameSpecifier *getQualifier() const { return NNS; }\n\n  /// Retrieve the type named by the qualified-id.\n  QualType getNamedType() const { return NamedType; }\n\n  /// Remove a single level of sugar.\n  QualType desugar() const { return getNamedType(); }\n\n  /// Returns whether this type directly provides sugar.\n  bool isSugared() const { return true; }\n\n  /// Return the (re)declaration of this type owned by this occurrence of this\n  /// type, or nullptr if there is none.\n  TagDecl *getOwnedTagDecl() const {\n    return ElaboratedTypeBits.HasOwnedTagDecl ? *getTrailingObjects<TagDecl *>()\n                                              : nullptr;\n  }\n\n  void Profile(llvm::FoldingSetNodeID &ID) {\n    Profile(ID, getKeyword(), NNS, NamedType, getOwnedTagDecl());\n  }\n\n  static void Profile(llvm::FoldingSetNodeID &ID, ElaboratedTypeKeyword Keyword,\n                      NestedNameSpecifier *NNS, QualType NamedType,\n                      TagDecl *OwnedTagDecl) {\n    ID.AddInteger(Keyword);\n    ID.AddPointer(NNS);\n    NamedType.Profile(ID);\n    ID.AddPointer(OwnedTagDecl);\n  }\n\n  static bool classof(const Type *T) { return T->getTypeClass() == Elaborated; }\n};\n\n/// Represents a qualified type name for which the type name is\n/// dependent.\n///\n/// DependentNameType represents a class of dependent types that involve a\n/// possibly dependent nested-name-specifier (e.g., \"T::\") followed by a\n/// name of a type. The DependentNameType may start with a \"typename\" (for a\n/// typename-specifier), \"class\", \"struct\", \"union\", or \"enum\" (for a\n/// dependent elaborated-type-specifier), or nothing (in contexts where we\n/// know that we must be referring to a type, e.g., in a base class specifier).\n/// Typically the nested-name-specifier is dependent, but in MSVC compatibility\n/// mode, this type is used with non-dependent names to delay name lookup until\n/// instantiation.\nclass DependentNameType : public TypeWithKeyword, public llvm::FoldingSetNode {\n  friend class ASTContext; // ASTContext creates these\n\n  /// The nested name specifier containing the qualifier.\n  NestedNameSpecifier *NNS;\n\n  /// The type that this typename specifier refers to.\n  const IdentifierInfo *Name;\n\n  DependentNameType(ElaboratedTypeKeyword Keyword, NestedNameSpecifier *NNS,\n                    const IdentifierInfo *Name, QualType CanonType)\n      : TypeWithKeyword(Keyword, DependentName, CanonType,\n                        TypeDependence::DependentInstantiation |\n                            toTypeDependence(NNS->getDependence())),\n        NNS(NNS), Name(Name) {}\n\npublic:\n  /// Retrieve the qualification on this type.\n  NestedNameSpecifier *getQualifier() const { return NNS; }\n\n  /// Retrieve the type named by the typename specifier as an identifier.\n  ///\n  /// This routine will return a non-NULL identifier pointer when the\n  /// form of the original typename was terminated by an identifier,\n  /// e.g., \"typename T::type\".\n  const IdentifierInfo *getIdentifier() const {\n    return Name;\n  }\n\n  bool isSugared() const { return false; }\n  QualType desugar() const { return QualType(this, 0); }\n\n  void Profile(llvm::FoldingSetNodeID &ID) {\n    Profile(ID, getKeyword(), NNS, Name);\n  }\n\n  static void Profile(llvm::FoldingSetNodeID &ID, ElaboratedTypeKeyword Keyword,\n                      NestedNameSpecifier *NNS, const IdentifierInfo *Name) {\n    ID.AddInteger(Keyword);\n    ID.AddPointer(NNS);\n    ID.AddPointer(Name);\n  }\n\n  static bool classof(const Type *T) {\n    return T->getTypeClass() == DependentName;\n  }\n};\n\n/// Represents a template specialization type whose template cannot be\n/// resolved, e.g.\n///   A<T>::template B<T>\nclass alignas(8) DependentTemplateSpecializationType\n    : public TypeWithKeyword,\n      public llvm::FoldingSetNode {\n  friend class ASTContext; // ASTContext creates these\n\n  /// The nested name specifier containing the qualifier.\n  NestedNameSpecifier *NNS;\n\n  /// The identifier of the template.\n  const IdentifierInfo *Name;\n\n  DependentTemplateSpecializationType(ElaboratedTypeKeyword Keyword,\n                                      NestedNameSpecifier *NNS,\n                                      const IdentifierInfo *Name,\n                                      ArrayRef<TemplateArgument> Args,\n                                      QualType Canon);\n\n  const TemplateArgument *getArgBuffer() const {\n    return reinterpret_cast<const TemplateArgument*>(this+1);\n  }\n\n  TemplateArgument *getArgBuffer() {\n    return reinterpret_cast<TemplateArgument*>(this+1);\n  }\n\npublic:\n  NestedNameSpecifier *getQualifier() const { return NNS; }\n  const IdentifierInfo *getIdentifier() const { return Name; }\n\n  /// Retrieve the template arguments.\n  const TemplateArgument *getArgs() const {\n    return getArgBuffer();\n  }\n\n  /// Retrieve the number of template arguments.\n  unsigned getNumArgs() const {\n    return DependentTemplateSpecializationTypeBits.NumArgs;\n  }\n\n  const TemplateArgument &getArg(unsigned Idx) const; // in TemplateBase.h\n\n  ArrayRef<TemplateArgument> template_arguments() const {\n    return {getArgs(), getNumArgs()};\n  }\n\n  using iterator = const TemplateArgument *;\n\n  iterator begin() const { return getArgs(); }\n  iterator end() const; // inline in TemplateBase.h\n\n  bool isSugared() const { return false; }\n  QualType desugar() const { return QualType(this, 0); }\n\n  void Profile(llvm::FoldingSetNodeID &ID, const ASTContext &Context) {\n    Profile(ID, Context, getKeyword(), NNS, Name, {getArgs(), getNumArgs()});\n  }\n\n  static void Profile(llvm::FoldingSetNodeID &ID,\n                      const ASTContext &Context,\n                      ElaboratedTypeKeyword Keyword,\n                      NestedNameSpecifier *Qualifier,\n                      const IdentifierInfo *Name,\n                      ArrayRef<TemplateArgument> Args);\n\n  static bool classof(const Type *T) {\n    return T->getTypeClass() == DependentTemplateSpecialization;\n  }\n};\n\n/// Represents a pack expansion of types.\n///\n/// Pack expansions are part of C++11 variadic templates. A pack\n/// expansion contains a pattern, which itself contains one or more\n/// \"unexpanded\" parameter packs. When instantiated, a pack expansion\n/// produces a series of types, each instantiated from the pattern of\n/// the expansion, where the Ith instantiation of the pattern uses the\n/// Ith arguments bound to each of the unexpanded parameter packs. The\n/// pack expansion is considered to \"expand\" these unexpanded\n/// parameter packs.\n///\n/// \\code\n/// template<typename ...Types> struct tuple;\n///\n/// template<typename ...Types>\n/// struct tuple_of_references {\n///   typedef tuple<Types&...> type;\n/// };\n/// \\endcode\n///\n/// Here, the pack expansion \\c Types&... is represented via a\n/// PackExpansionType whose pattern is Types&.\nclass PackExpansionType : public Type, public llvm::FoldingSetNode {\n  friend class ASTContext; // ASTContext creates these\n\n  /// The pattern of the pack expansion.\n  QualType Pattern;\n\n  PackExpansionType(QualType Pattern, QualType Canon,\n                    Optional<unsigned> NumExpansions)\n      : Type(PackExpansion, Canon,\n             (Pattern->getDependence() | TypeDependence::Dependent |\n              TypeDependence::Instantiation) &\n                 ~TypeDependence::UnexpandedPack),\n        Pattern(Pattern) {\n    PackExpansionTypeBits.NumExpansions =\n        NumExpansions ? *NumExpansions + 1 : 0;\n  }\n\npublic:\n  /// Retrieve the pattern of this pack expansion, which is the\n  /// type that will be repeatedly instantiated when instantiating the\n  /// pack expansion itself.\n  QualType getPattern() const { return Pattern; }\n\n  /// Retrieve the number of expansions that this pack expansion will\n  /// generate, if known.\n  Optional<unsigned> getNumExpansions() const {\n    if (PackExpansionTypeBits.NumExpansions)\n      return PackExpansionTypeBits.NumExpansions - 1;\n    return None;\n  }\n\n  bool isSugared() const { return false; }\n  QualType desugar() const { return QualType(this, 0); }\n\n  void Profile(llvm::FoldingSetNodeID &ID) {\n    Profile(ID, getPattern(), getNumExpansions());\n  }\n\n  static void Profile(llvm::FoldingSetNodeID &ID, QualType Pattern,\n                      Optional<unsigned> NumExpansions) {\n    ID.AddPointer(Pattern.getAsOpaquePtr());\n    ID.AddBoolean(NumExpansions.hasValue());\n    if (NumExpansions)\n      ID.AddInteger(*NumExpansions);\n  }\n\n  static bool classof(const Type *T) {\n    return T->getTypeClass() == PackExpansion;\n  }\n};\n\n/// This class wraps the list of protocol qualifiers. For types that can\n/// take ObjC protocol qualifers, they can subclass this class.\ntemplate <class T>\nclass ObjCProtocolQualifiers {\nprotected:\n  ObjCProtocolQualifiers() = default;\n\n  ObjCProtocolDecl * const *getProtocolStorage() const {\n    return const_cast<ObjCProtocolQualifiers*>(this)->getProtocolStorage();\n  }\n\n  ObjCProtocolDecl **getProtocolStorage() {\n    return static_cast<T*>(this)->getProtocolStorageImpl();\n  }\n\n  void setNumProtocols(unsigned N) {\n    static_cast<T*>(this)->setNumProtocolsImpl(N);\n  }\n\n  void initialize(ArrayRef<ObjCProtocolDecl *> protocols) {\n    setNumProtocols(protocols.size());\n    assert(getNumProtocols() == protocols.size() &&\n           \"bitfield overflow in protocol count\");\n    if (!protocols.empty())\n      memcpy(getProtocolStorage(), protocols.data(),\n             protocols.size() * sizeof(ObjCProtocolDecl*));\n  }\n\npublic:\n  using qual_iterator = ObjCProtocolDecl * const *;\n  using qual_range = llvm::iterator_range<qual_iterator>;\n\n  qual_range quals() const { return qual_range(qual_begin(), qual_end()); }\n  qual_iterator qual_begin() const { return getProtocolStorage(); }\n  qual_iterator qual_end() const { return qual_begin() + getNumProtocols(); }\n\n  bool qual_empty() const { return getNumProtocols() == 0; }\n\n  /// Return the number of qualifying protocols in this type, or 0 if\n  /// there are none.\n  unsigned getNumProtocols() const {\n    return static_cast<const T*>(this)->getNumProtocolsImpl();\n  }\n\n  /// Fetch a protocol by index.\n  ObjCProtocolDecl *getProtocol(unsigned I) const {\n    assert(I < getNumProtocols() && \"Out-of-range protocol access\");\n    return qual_begin()[I];\n  }\n\n  /// Retrieve all of the protocol qualifiers.\n  ArrayRef<ObjCProtocolDecl *> getProtocols() const {\n    return ArrayRef<ObjCProtocolDecl *>(qual_begin(), getNumProtocols());\n  }\n};\n\n/// Represents a type parameter type in Objective C. It can take\n/// a list of protocols.\nclass ObjCTypeParamType : public Type,\n                          public ObjCProtocolQualifiers<ObjCTypeParamType>,\n                          public llvm::FoldingSetNode {\n  friend class ASTContext;\n  friend class ObjCProtocolQualifiers<ObjCTypeParamType>;\n\n  /// The number of protocols stored on this type.\n  unsigned NumProtocols : 6;\n\n  ObjCTypeParamDecl *OTPDecl;\n\n  /// The protocols are stored after the ObjCTypeParamType node. In the\n  /// canonical type, the list of protocols are sorted alphabetically\n  /// and uniqued.\n  ObjCProtocolDecl **getProtocolStorageImpl();\n\n  /// Return the number of qualifying protocols in this interface type,\n  /// or 0 if there are none.\n  unsigned getNumProtocolsImpl() const {\n    return NumProtocols;\n  }\n\n  void setNumProtocolsImpl(unsigned N) {\n    NumProtocols = N;\n  }\n\n  ObjCTypeParamType(const ObjCTypeParamDecl *D,\n                    QualType can,\n                    ArrayRef<ObjCProtocolDecl *> protocols);\n\npublic:\n  bool isSugared() const { return true; }\n  QualType desugar() const { return getCanonicalTypeInternal(); }\n\n  static bool classof(const Type *T) {\n    return T->getTypeClass() == ObjCTypeParam;\n  }\n\n  void Profile(llvm::FoldingSetNodeID &ID);\n  static void Profile(llvm::FoldingSetNodeID &ID,\n                      const ObjCTypeParamDecl *OTPDecl,\n                      QualType CanonicalType,\n                      ArrayRef<ObjCProtocolDecl *> protocols);\n\n  ObjCTypeParamDecl *getDecl() const { return OTPDecl; }\n};\n\n/// Represents a class type in Objective C.\n///\n/// Every Objective C type is a combination of a base type, a set of\n/// type arguments (optional, for parameterized classes) and a list of\n/// protocols.\n///\n/// Given the following declarations:\n/// \\code\n///   \\@class C<T>;\n///   \\@protocol P;\n/// \\endcode\n///\n/// 'C' is an ObjCInterfaceType C.  It is sugar for an ObjCObjectType\n/// with base C and no protocols.\n///\n/// 'C<P>' is an unspecialized ObjCObjectType with base C and protocol list [P].\n/// 'C<C*>' is a specialized ObjCObjectType with type arguments 'C*' and no\n/// protocol list.\n/// 'C<C*><P>' is a specialized ObjCObjectType with base C, type arguments 'C*',\n/// and protocol list [P].\n///\n/// 'id' is a TypedefType which is sugar for an ObjCObjectPointerType whose\n/// pointee is an ObjCObjectType with base BuiltinType::ObjCIdType\n/// and no protocols.\n///\n/// 'id<P>' is an ObjCObjectPointerType whose pointee is an ObjCObjectType\n/// with base BuiltinType::ObjCIdType and protocol list [P].  Eventually\n/// this should get its own sugar class to better represent the source.\nclass ObjCObjectType : public Type,\n                       public ObjCProtocolQualifiers<ObjCObjectType> {\n  friend class ObjCProtocolQualifiers<ObjCObjectType>;\n\n  // ObjCObjectType.NumTypeArgs - the number of type arguments stored\n  // after the ObjCObjectPointerType node.\n  // ObjCObjectType.NumProtocols - the number of protocols stored\n  // after the type arguments of ObjCObjectPointerType node.\n  //\n  // These protocols are those written directly on the type.  If\n  // protocol qualifiers ever become additive, the iterators will need\n  // to get kindof complicated.\n  //\n  // In the canonical object type, these are sorted alphabetically\n  // and uniqued.\n\n  /// Either a BuiltinType or an InterfaceType or sugar for either.\n  QualType BaseType;\n\n  /// Cached superclass type.\n  mutable llvm::PointerIntPair<const ObjCObjectType *, 1, bool>\n    CachedSuperClassType;\n\n  QualType *getTypeArgStorage();\n  const QualType *getTypeArgStorage() const {\n    return const_cast<ObjCObjectType *>(this)->getTypeArgStorage();\n  }\n\n  ObjCProtocolDecl **getProtocolStorageImpl();\n  /// Return the number of qualifying protocols in this interface type,\n  /// or 0 if there are none.\n  unsigned getNumProtocolsImpl() const {\n    return ObjCObjectTypeBits.NumProtocols;\n  }\n  void setNumProtocolsImpl(unsigned N) {\n    ObjCObjectTypeBits.NumProtocols = N;\n  }\n\nprotected:\n  enum Nonce_ObjCInterface { Nonce_ObjCInterface };\n\n  ObjCObjectType(QualType Canonical, QualType Base,\n                 ArrayRef<QualType> typeArgs,\n                 ArrayRef<ObjCProtocolDecl *> protocols,\n                 bool isKindOf);\n\n  ObjCObjectType(enum Nonce_ObjCInterface)\n      : Type(ObjCInterface, QualType(), TypeDependence::None),\n        BaseType(QualType(this_(), 0)) {\n    ObjCObjectTypeBits.NumProtocols = 0;\n    ObjCObjectTypeBits.NumTypeArgs = 0;\n    ObjCObjectTypeBits.IsKindOf = 0;\n  }\n\n  void computeSuperClassTypeSlow() const;\n\npublic:\n  /// Gets the base type of this object type.  This is always (possibly\n  /// sugar for) one of:\n  ///  - the 'id' builtin type (as opposed to the 'id' type visible to the\n  ///    user, which is a typedef for an ObjCObjectPointerType)\n  ///  - the 'Class' builtin type (same caveat)\n  ///  - an ObjCObjectType (currently always an ObjCInterfaceType)\n  QualType getBaseType() const { return BaseType; }\n\n  bool isObjCId() const {\n    return getBaseType()->isSpecificBuiltinType(BuiltinType::ObjCId);\n  }\n\n  bool isObjCClass() const {\n    return getBaseType()->isSpecificBuiltinType(BuiltinType::ObjCClass);\n  }\n\n  bool isObjCUnqualifiedId() const { return qual_empty() && isObjCId(); }\n  bool isObjCUnqualifiedClass() const { return qual_empty() && isObjCClass(); }\n  bool isObjCUnqualifiedIdOrClass() const {\n    if (!qual_empty()) return false;\n    if (const BuiltinType *T = getBaseType()->getAs<BuiltinType>())\n      return T->getKind() == BuiltinType::ObjCId ||\n             T->getKind() == BuiltinType::ObjCClass;\n    return false;\n  }\n  bool isObjCQualifiedId() const { return !qual_empty() && isObjCId(); }\n  bool isObjCQualifiedClass() const { return !qual_empty() && isObjCClass(); }\n\n  /// Gets the interface declaration for this object type, if the base type\n  /// really is an interface.\n  ObjCInterfaceDecl *getInterface() const;\n\n  /// Determine whether this object type is \"specialized\", meaning\n  /// that it has type arguments.\n  bool isSpecialized() const;\n\n  /// Determine whether this object type was written with type arguments.\n  bool isSpecializedAsWritten() const {\n    return ObjCObjectTypeBits.NumTypeArgs > 0;\n  }\n\n  /// Determine whether this object type is \"unspecialized\", meaning\n  /// that it has no type arguments.\n  bool isUnspecialized() const { return !isSpecialized(); }\n\n  /// Determine whether this object type is \"unspecialized\" as\n  /// written, meaning that it has no type arguments.\n  bool isUnspecializedAsWritten() const { return !isSpecializedAsWritten(); }\n\n  /// Retrieve the type arguments of this object type (semantically).\n  ArrayRef<QualType> getTypeArgs() const;\n\n  /// Retrieve the type arguments of this object type as they were\n  /// written.\n  ArrayRef<QualType> getTypeArgsAsWritten() const {\n    return llvm::makeArrayRef(getTypeArgStorage(),\n                              ObjCObjectTypeBits.NumTypeArgs);\n  }\n\n  /// Whether this is a \"__kindof\" type as written.\n  bool isKindOfTypeAsWritten() const { return ObjCObjectTypeBits.IsKindOf; }\n\n  /// Whether this ia a \"__kindof\" type (semantically).\n  bool isKindOfType() const;\n\n  /// Retrieve the type of the superclass of this object type.\n  ///\n  /// This operation substitutes any type arguments into the\n  /// superclass of the current class type, potentially producing a\n  /// specialization of the superclass type. Produces a null type if\n  /// there is no superclass.\n  QualType getSuperClassType() const {\n    if (!CachedSuperClassType.getInt())\n      computeSuperClassTypeSlow();\n\n    assert(CachedSuperClassType.getInt() && \"Superclass not set?\");\n    return QualType(CachedSuperClassType.getPointer(), 0);\n  }\n\n  /// Strip off the Objective-C \"kindof\" type and (with it) any\n  /// protocol qualifiers.\n  QualType stripObjCKindOfTypeAndQuals(const ASTContext &ctx) const;\n\n  bool isSugared() const { return false; }\n  QualType desugar() const { return QualType(this, 0); }\n\n  static bool classof(const Type *T) {\n    return T->getTypeClass() == ObjCObject ||\n           T->getTypeClass() == ObjCInterface;\n  }\n};\n\n/// A class providing a concrete implementation\n/// of ObjCObjectType, so as to not increase the footprint of\n/// ObjCInterfaceType.  Code outside of ASTContext and the core type\n/// system should not reference this type.\nclass ObjCObjectTypeImpl : public ObjCObjectType, public llvm::FoldingSetNode {\n  friend class ASTContext;\n\n  // If anyone adds fields here, ObjCObjectType::getProtocolStorage()\n  // will need to be modified.\n\n  ObjCObjectTypeImpl(QualType Canonical, QualType Base,\n                     ArrayRef<QualType> typeArgs,\n                     ArrayRef<ObjCProtocolDecl *> protocols,\n                     bool isKindOf)\n      : ObjCObjectType(Canonical, Base, typeArgs, protocols, isKindOf) {}\n\npublic:\n  void Profile(llvm::FoldingSetNodeID &ID);\n  static void Profile(llvm::FoldingSetNodeID &ID,\n                      QualType Base,\n                      ArrayRef<QualType> typeArgs,\n                      ArrayRef<ObjCProtocolDecl *> protocols,\n                      bool isKindOf);\n};\n\ninline QualType *ObjCObjectType::getTypeArgStorage() {\n  return reinterpret_cast<QualType *>(static_cast<ObjCObjectTypeImpl*>(this)+1);\n}\n\ninline ObjCProtocolDecl **ObjCObjectType::getProtocolStorageImpl() {\n    return reinterpret_cast<ObjCProtocolDecl**>(\n             getTypeArgStorage() + ObjCObjectTypeBits.NumTypeArgs);\n}\n\ninline ObjCProtocolDecl **ObjCTypeParamType::getProtocolStorageImpl() {\n    return reinterpret_cast<ObjCProtocolDecl**>(\n             static_cast<ObjCTypeParamType*>(this)+1);\n}\n\n/// Interfaces are the core concept in Objective-C for object oriented design.\n/// They basically correspond to C++ classes.  There are two kinds of interface\n/// types: normal interfaces like `NSString`, and qualified interfaces, which\n/// are qualified with a protocol list like `NSString<NSCopyable, NSAmazing>`.\n///\n/// ObjCInterfaceType guarantees the following properties when considered\n/// as a subtype of its superclass, ObjCObjectType:\n///   - There are no protocol qualifiers.  To reinforce this, code which\n///     tries to invoke the protocol methods via an ObjCInterfaceType will\n///     fail to compile.\n///   - It is its own base type.  That is, if T is an ObjCInterfaceType*,\n///     T->getBaseType() == QualType(T, 0).\nclass ObjCInterfaceType : public ObjCObjectType {\n  friend class ASTContext; // ASTContext creates these.\n  friend class ASTReader;\n  friend class ObjCInterfaceDecl;\n  template <class T> friend class serialization::AbstractTypeReader;\n\n  mutable ObjCInterfaceDecl *Decl;\n\n  ObjCInterfaceType(const ObjCInterfaceDecl *D)\n      : ObjCObjectType(Nonce_ObjCInterface),\n        Decl(const_cast<ObjCInterfaceDecl*>(D)) {}\n\npublic:\n  /// Get the declaration of this interface.\n  ObjCInterfaceDecl *getDecl() const { return Decl; }\n\n  bool isSugared() const { return false; }\n  QualType desugar() const { return QualType(this, 0); }\n\n  static bool classof(const Type *T) {\n    return T->getTypeClass() == ObjCInterface;\n  }\n\n  // Nonsense to \"hide\" certain members of ObjCObjectType within this\n  // class.  People asking for protocols on an ObjCInterfaceType are\n  // not going to get what they want: ObjCInterfaceTypes are\n  // guaranteed to have no protocols.\n  enum {\n    qual_iterator,\n    qual_begin,\n    qual_end,\n    getNumProtocols,\n    getProtocol\n  };\n};\n\ninline ObjCInterfaceDecl *ObjCObjectType::getInterface() const {\n  QualType baseType = getBaseType();\n  while (const auto *ObjT = baseType->getAs<ObjCObjectType>()) {\n    if (const auto *T = dyn_cast<ObjCInterfaceType>(ObjT))\n      return T->getDecl();\n\n    baseType = ObjT->getBaseType();\n  }\n\n  return nullptr;\n}\n\n/// Represents a pointer to an Objective C object.\n///\n/// These are constructed from pointer declarators when the pointee type is\n/// an ObjCObjectType (or sugar for one).  In addition, the 'id' and 'Class'\n/// types are typedefs for these, and the protocol-qualified types 'id<P>'\n/// and 'Class<P>' are translated into these.\n///\n/// Pointers to pointers to Objective C objects are still PointerTypes;\n/// only the first level of pointer gets it own type implementation.\nclass ObjCObjectPointerType : public Type, public llvm::FoldingSetNode {\n  friend class ASTContext; // ASTContext creates these.\n\n  QualType PointeeType;\n\n  ObjCObjectPointerType(QualType Canonical, QualType Pointee)\n      : Type(ObjCObjectPointer, Canonical, Pointee->getDependence()),\n        PointeeType(Pointee) {}\n\npublic:\n  /// Gets the type pointed to by this ObjC pointer.\n  /// The result will always be an ObjCObjectType or sugar thereof.\n  QualType getPointeeType() const { return PointeeType; }\n\n  /// Gets the type pointed to by this ObjC pointer.  Always returns non-null.\n  ///\n  /// This method is equivalent to getPointeeType() except that\n  /// it discards any typedefs (or other sugar) between this\n  /// type and the \"outermost\" object type.  So for:\n  /// \\code\n  ///   \\@class A; \\@protocol P; \\@protocol Q;\n  ///   typedef A<P> AP;\n  ///   typedef A A1;\n  ///   typedef A1<P> A1P;\n  ///   typedef A1P<Q> A1PQ;\n  /// \\endcode\n  /// For 'A*', getObjectType() will return 'A'.\n  /// For 'A<P>*', getObjectType() will return 'A<P>'.\n  /// For 'AP*', getObjectType() will return 'A<P>'.\n  /// For 'A1*', getObjectType() will return 'A'.\n  /// For 'A1<P>*', getObjectType() will return 'A1<P>'.\n  /// For 'A1P*', getObjectType() will return 'A1<P>'.\n  /// For 'A1PQ*', getObjectType() will return 'A1<Q>', because\n  ///   adding protocols to a protocol-qualified base discards the\n  ///   old qualifiers (for now).  But if it didn't, getObjectType()\n  ///   would return 'A1P<Q>' (and we'd have to make iterating over\n  ///   qualifiers more complicated).\n  const ObjCObjectType *getObjectType() const {\n    return PointeeType->castAs<ObjCObjectType>();\n  }\n\n  /// If this pointer points to an Objective C\n  /// \\@interface type, gets the type for that interface.  Any protocol\n  /// qualifiers on the interface are ignored.\n  ///\n  /// \\return null if the base type for this pointer is 'id' or 'Class'\n  const ObjCInterfaceType *getInterfaceType() const;\n\n  /// If this pointer points to an Objective \\@interface\n  /// type, gets the declaration for that interface.\n  ///\n  /// \\return null if the base type for this pointer is 'id' or 'Class'\n  ObjCInterfaceDecl *getInterfaceDecl() const {\n    return getObjectType()->getInterface();\n  }\n\n  /// True if this is equivalent to the 'id' type, i.e. if\n  /// its object type is the primitive 'id' type with no protocols.\n  bool isObjCIdType() const {\n    return getObjectType()->isObjCUnqualifiedId();\n  }\n\n  /// True if this is equivalent to the 'Class' type,\n  /// i.e. if its object tive is the primitive 'Class' type with no protocols.\n  bool isObjCClassType() const {\n    return getObjectType()->isObjCUnqualifiedClass();\n  }\n\n  /// True if this is equivalent to the 'id' or 'Class' type,\n  bool isObjCIdOrClassType() const {\n    return getObjectType()->isObjCUnqualifiedIdOrClass();\n  }\n\n  /// True if this is equivalent to 'id<P>' for some non-empty set of\n  /// protocols.\n  bool isObjCQualifiedIdType() const {\n    return getObjectType()->isObjCQualifiedId();\n  }\n\n  /// True if this is equivalent to 'Class<P>' for some non-empty set of\n  /// protocols.\n  bool isObjCQualifiedClassType() const {\n    return getObjectType()->isObjCQualifiedClass();\n  }\n\n  /// Whether this is a \"__kindof\" type.\n  bool isKindOfType() const { return getObjectType()->isKindOfType(); }\n\n  /// Whether this type is specialized, meaning that it has type arguments.\n  bool isSpecialized() const { return getObjectType()->isSpecialized(); }\n\n  /// Whether this type is specialized, meaning that it has type arguments.\n  bool isSpecializedAsWritten() const {\n    return getObjectType()->isSpecializedAsWritten();\n  }\n\n  /// Whether this type is unspecialized, meaning that is has no type arguments.\n  bool isUnspecialized() const { return getObjectType()->isUnspecialized(); }\n\n  /// Determine whether this object type is \"unspecialized\" as\n  /// written, meaning that it has no type arguments.\n  bool isUnspecializedAsWritten() const { return !isSpecializedAsWritten(); }\n\n  /// Retrieve the type arguments for this type.\n  ArrayRef<QualType> getTypeArgs() const {\n    return getObjectType()->getTypeArgs();\n  }\n\n  /// Retrieve the type arguments for this type.\n  ArrayRef<QualType> getTypeArgsAsWritten() const {\n    return getObjectType()->getTypeArgsAsWritten();\n  }\n\n  /// An iterator over the qualifiers on the object type.  Provided\n  /// for convenience.  This will always iterate over the full set of\n  /// protocols on a type, not just those provided directly.\n  using qual_iterator = ObjCObjectType::qual_iterator;\n  using qual_range = llvm::iterator_range<qual_iterator>;\n\n  qual_range quals() const { return qual_range(qual_begin(), qual_end()); }\n\n  qual_iterator qual_begin() const {\n    return getObjectType()->qual_begin();\n  }\n\n  qual_iterator qual_end() const {\n    return getObjectType()->qual_end();\n  }\n\n  bool qual_empty() const { return getObjectType()->qual_empty(); }\n\n  /// Return the number of qualifying protocols on the object type.\n  unsigned getNumProtocols() const {\n    return getObjectType()->getNumProtocols();\n  }\n\n  /// Retrieve a qualifying protocol by index on the object type.\n  ObjCProtocolDecl *getProtocol(unsigned I) const {\n    return getObjectType()->getProtocol(I);\n  }\n\n  bool isSugared() const { return false; }\n  QualType desugar() const { return QualType(this, 0); }\n\n  /// Retrieve the type of the superclass of this object pointer type.\n  ///\n  /// This operation substitutes any type arguments into the\n  /// superclass of the current class type, potentially producing a\n  /// pointer to a specialization of the superclass type. Produces a\n  /// null type if there is no superclass.\n  QualType getSuperClassType() const;\n\n  /// Strip off the Objective-C \"kindof\" type and (with it) any\n  /// protocol qualifiers.\n  const ObjCObjectPointerType *stripObjCKindOfTypeAndQuals(\n                                 const ASTContext &ctx) const;\n\n  void Profile(llvm::FoldingSetNodeID &ID) {\n    Profile(ID, getPointeeType());\n  }\n\n  static void Profile(llvm::FoldingSetNodeID &ID, QualType T) {\n    ID.AddPointer(T.getAsOpaquePtr());\n  }\n\n  static bool classof(const Type *T) {\n    return T->getTypeClass() == ObjCObjectPointer;\n  }\n};\n\nclass AtomicType : public Type, public llvm::FoldingSetNode {\n  friend class ASTContext; // ASTContext creates these.\n\n  QualType ValueType;\n\n  AtomicType(QualType ValTy, QualType Canonical)\n      : Type(Atomic, Canonical, ValTy->getDependence()), ValueType(ValTy) {}\n\npublic:\n  /// Gets the type contained by this atomic type, i.e.\n  /// the type returned by performing an atomic load of this atomic type.\n  QualType getValueType() const { return ValueType; }\n\n  bool isSugared() const { return false; }\n  QualType desugar() const { return QualType(this, 0); }\n\n  void Profile(llvm::FoldingSetNodeID &ID) {\n    Profile(ID, getValueType());\n  }\n\n  static void Profile(llvm::FoldingSetNodeID &ID, QualType T) {\n    ID.AddPointer(T.getAsOpaquePtr());\n  }\n\n  static bool classof(const Type *T) {\n    return T->getTypeClass() == Atomic;\n  }\n};\n\n/// PipeType - OpenCL20.\nclass PipeType : public Type, public llvm::FoldingSetNode {\n  friend class ASTContext; // ASTContext creates these.\n\n  QualType ElementType;\n  bool isRead;\n\n  PipeType(QualType elemType, QualType CanonicalPtr, bool isRead)\n      : Type(Pipe, CanonicalPtr, elemType->getDependence()),\n        ElementType(elemType), isRead(isRead) {}\n\npublic:\n  QualType getElementType() const { return ElementType; }\n\n  bool isSugared() const { return false; }\n\n  QualType desugar() const { return QualType(this, 0); }\n\n  void Profile(llvm::FoldingSetNodeID &ID) {\n    Profile(ID, getElementType(), isReadOnly());\n  }\n\n  static void Profile(llvm::FoldingSetNodeID &ID, QualType T, bool isRead) {\n    ID.AddPointer(T.getAsOpaquePtr());\n    ID.AddBoolean(isRead);\n  }\n\n  static bool classof(const Type *T) {\n    return T->getTypeClass() == Pipe;\n  }\n\n  bool isReadOnly() const { return isRead; }\n};\n\n/// A fixed int type of a specified bitwidth.\nclass ExtIntType final : public Type, public llvm::FoldingSetNode {\n  friend class ASTContext;\n  unsigned IsUnsigned : 1;\n  unsigned NumBits : 24;\n\nprotected:\n  ExtIntType(bool isUnsigned, unsigned NumBits);\n\npublic:\n  bool isUnsigned() const { return IsUnsigned; }\n  bool isSigned() const { return !IsUnsigned; }\n  unsigned getNumBits() const { return NumBits; }\n\n  bool isSugared() const { return false; }\n  QualType desugar() const { return QualType(this, 0); }\n\n  void Profile(llvm::FoldingSetNodeID &ID) {\n    Profile(ID, isUnsigned(), getNumBits());\n  }\n\n  static void Profile(llvm::FoldingSetNodeID &ID, bool IsUnsigned,\n                      unsigned NumBits) {\n    ID.AddBoolean(IsUnsigned);\n    ID.AddInteger(NumBits);\n  }\n\n  static bool classof(const Type *T) { return T->getTypeClass() == ExtInt; }\n};\n\nclass DependentExtIntType final : public Type, public llvm::FoldingSetNode {\n  friend class ASTContext;\n  const ASTContext &Context;\n  llvm::PointerIntPair<Expr*, 1, bool> ExprAndUnsigned;\n\nprotected:\n  DependentExtIntType(const ASTContext &Context, bool IsUnsigned,\n                      Expr *NumBits);\n\npublic:\n  bool isUnsigned() const;\n  bool isSigned() const { return !isUnsigned(); }\n  Expr *getNumBitsExpr() const;\n\n  bool isSugared() const { return false; }\n  QualType desugar() const { return QualType(this, 0); }\n\n  void Profile(llvm::FoldingSetNodeID &ID) {\n    Profile(ID, Context, isUnsigned(), getNumBitsExpr());\n  }\n  static void Profile(llvm::FoldingSetNodeID &ID, const ASTContext &Context,\n                      bool IsUnsigned, Expr *NumBitsExpr);\n\n  static bool classof(const Type *T) {\n    return T->getTypeClass() == DependentExtInt;\n  }\n};\n\n/// A qualifier set is used to build a set of qualifiers.\nclass QualifierCollector : public Qualifiers {\npublic:\n  QualifierCollector(Qualifiers Qs = Qualifiers()) : Qualifiers(Qs) {}\n\n  /// Collect any qualifiers on the given type and return an\n  /// unqualified type.  The qualifiers are assumed to be consistent\n  /// with those already in the type.\n  const Type *strip(QualType type) {\n    addFastQualifiers(type.getLocalFastQualifiers());\n    if (!type.hasLocalNonFastQualifiers())\n      return type.getTypePtrUnsafe();\n\n    const ExtQuals *extQuals = type.getExtQualsUnsafe();\n    addConsistentQualifiers(extQuals->getQualifiers());\n    return extQuals->getBaseType();\n  }\n\n  /// Apply the collected qualifiers to the given type.\n  QualType apply(const ASTContext &Context, QualType QT) const;\n\n  /// Apply the collected qualifiers to the given type.\n  QualType apply(const ASTContext &Context, const Type* T) const;\n};\n\n/// A container of type source information.\n///\n/// A client can read the relevant info using TypeLoc wrappers, e.g:\n/// @code\n/// TypeLoc TL = TypeSourceInfo->getTypeLoc();\n/// TL.getBeginLoc().print(OS, SrcMgr);\n/// @endcode\nclass alignas(8) TypeSourceInfo {\n  // Contains a memory block after the class, used for type source information,\n  // allocated by ASTContext.\n  friend class ASTContext;\n\n  QualType Ty;\n\n  TypeSourceInfo(QualType ty) : Ty(ty) {}\n\npublic:\n  /// Return the type wrapped by this type source info.\n  QualType getType() const { return Ty; }\n\n  /// Return the TypeLoc wrapper for the type source info.\n  TypeLoc getTypeLoc() const; // implemented in TypeLoc.h\n\n  /// Override the type stored in this TypeSourceInfo. Use with caution!\n  void overrideType(QualType T) { Ty = T; }\n};\n\n// Inline function definitions.\n\ninline SplitQualType SplitQualType::getSingleStepDesugaredType() const {\n  SplitQualType desugar =\n    Ty->getLocallyUnqualifiedSingleStepDesugaredType().split();\n  desugar.Quals.addConsistentQualifiers(Quals);\n  return desugar;\n}\n\ninline const Type *QualType::getTypePtr() const {\n  return getCommonPtr()->BaseType;\n}\n\ninline const Type *QualType::getTypePtrOrNull() const {\n  return (isNull() ? nullptr : getCommonPtr()->BaseType);\n}\n\ninline SplitQualType QualType::split() const {\n  if (!hasLocalNonFastQualifiers())\n    return SplitQualType(getTypePtrUnsafe(),\n                         Qualifiers::fromFastMask(getLocalFastQualifiers()));\n\n  const ExtQuals *eq = getExtQualsUnsafe();\n  Qualifiers qs = eq->getQualifiers();\n  qs.addFastQualifiers(getLocalFastQualifiers());\n  return SplitQualType(eq->getBaseType(), qs);\n}\n\ninline Qualifiers QualType::getLocalQualifiers() const {\n  Qualifiers Quals;\n  if (hasLocalNonFastQualifiers())\n    Quals = getExtQualsUnsafe()->getQualifiers();\n  Quals.addFastQualifiers(getLocalFastQualifiers());\n  return Quals;\n}\n\ninline Qualifiers QualType::getQualifiers() const {\n  Qualifiers quals = getCommonPtr()->CanonicalType.getLocalQualifiers();\n  quals.addFastQualifiers(getLocalFastQualifiers());\n  return quals;\n}\n\ninline unsigned QualType::getCVRQualifiers() const {\n  unsigned cvr = getCommonPtr()->CanonicalType.getLocalCVRQualifiers();\n  cvr |= getLocalCVRQualifiers();\n  return cvr;\n}\n\ninline QualType QualType::getCanonicalType() const {\n  QualType canon = getCommonPtr()->CanonicalType;\n  return canon.withFastQualifiers(getLocalFastQualifiers());\n}\n\ninline bool QualType::isCanonical() const {\n  return getTypePtr()->isCanonicalUnqualified();\n}\n\ninline bool QualType::isCanonicalAsParam() const {\n  if (!isCanonical()) return false;\n  if (hasLocalQualifiers()) return false;\n\n  const Type *T = getTypePtr();\n  if (T->isVariablyModifiedType() && T->hasSizedVLAType())\n    return false;\n\n  return !isa<FunctionType>(T) && !isa<ArrayType>(T);\n}\n\ninline bool QualType::isConstQualified() const {\n  return isLocalConstQualified() ||\n         getCommonPtr()->CanonicalType.isLocalConstQualified();\n}\n\ninline bool QualType::isRestrictQualified() const {\n  return isLocalRestrictQualified() ||\n         getCommonPtr()->CanonicalType.isLocalRestrictQualified();\n}\n\n\ninline bool QualType::isVolatileQualified() const {\n  return isLocalVolatileQualified() ||\n         getCommonPtr()->CanonicalType.isLocalVolatileQualified();\n}\n\ninline bool QualType::hasQualifiers() const {\n  return hasLocalQualifiers() ||\n         getCommonPtr()->CanonicalType.hasLocalQualifiers();\n}\n\ninline QualType QualType::getUnqualifiedType() const {\n  if (!getTypePtr()->getCanonicalTypeInternal().hasLocalQualifiers())\n    return QualType(getTypePtr(), 0);\n\n  return QualType(getSplitUnqualifiedTypeImpl(*this).Ty, 0);\n}\n\ninline SplitQualType QualType::getSplitUnqualifiedType() const {\n  if (!getTypePtr()->getCanonicalTypeInternal().hasLocalQualifiers())\n    return split();\n\n  return getSplitUnqualifiedTypeImpl(*this);\n}\n\ninline void QualType::removeLocalConst() {\n  removeLocalFastQualifiers(Qualifiers::Const);\n}\n\ninline void QualType::removeLocalRestrict() {\n  removeLocalFastQualifiers(Qualifiers::Restrict);\n}\n\ninline void QualType::removeLocalVolatile() {\n  removeLocalFastQualifiers(Qualifiers::Volatile);\n}\n\ninline void QualType::removeLocalCVRQualifiers(unsigned Mask) {\n  assert(!(Mask & ~Qualifiers::CVRMask) && \"mask has non-CVR bits\");\n  static_assert((int)Qualifiers::CVRMask == (int)Qualifiers::FastMask,\n                \"Fast bits differ from CVR bits!\");\n\n  // Fast path: we don't need to touch the slow qualifiers.\n  removeLocalFastQualifiers(Mask);\n}\n\n/// Check if this type has any address space qualifier.\ninline bool QualType::hasAddressSpace() const {\n  return getQualifiers().hasAddressSpace();\n}\n\n/// Return the address space of this type.\ninline LangAS QualType::getAddressSpace() const {\n  return getQualifiers().getAddressSpace();\n}\n\n/// Return the gc attribute of this type.\ninline Qualifiers::GC QualType::getObjCGCAttr() const {\n  return getQualifiers().getObjCGCAttr();\n}\n\ninline bool QualType::hasNonTrivialToPrimitiveDefaultInitializeCUnion() const {\n  if (auto *RD = getTypePtr()->getBaseElementTypeUnsafe()->getAsRecordDecl())\n    return hasNonTrivialToPrimitiveDefaultInitializeCUnion(RD);\n  return false;\n}\n\ninline bool QualType::hasNonTrivialToPrimitiveDestructCUnion() const {\n  if (auto *RD = getTypePtr()->getBaseElementTypeUnsafe()->getAsRecordDecl())\n    return hasNonTrivialToPrimitiveDestructCUnion(RD);\n  return false;\n}\n\ninline bool QualType::hasNonTrivialToPrimitiveCopyCUnion() const {\n  if (auto *RD = getTypePtr()->getBaseElementTypeUnsafe()->getAsRecordDecl())\n    return hasNonTrivialToPrimitiveCopyCUnion(RD);\n  return false;\n}\n\ninline FunctionType::ExtInfo getFunctionExtInfo(const Type &t) {\n  if (const auto *PT = t.getAs<PointerType>()) {\n    if (const auto *FT = PT->getPointeeType()->getAs<FunctionType>())\n      return FT->getExtInfo();\n  } else if (const auto *FT = t.getAs<FunctionType>())\n    return FT->getExtInfo();\n\n  return FunctionType::ExtInfo();\n}\n\ninline FunctionType::ExtInfo getFunctionExtInfo(QualType t) {\n  return getFunctionExtInfo(*t);\n}\n\n/// Determine whether this type is more\n/// qualified than the Other type. For example, \"const volatile int\"\n/// is more qualified than \"const int\", \"volatile int\", and\n/// \"int\". However, it is not more qualified than \"const volatile\n/// int\".\ninline bool QualType::isMoreQualifiedThan(QualType other) const {\n  Qualifiers MyQuals = getQualifiers();\n  Qualifiers OtherQuals = other.getQualifiers();\n  return (MyQuals != OtherQuals && MyQuals.compatiblyIncludes(OtherQuals));\n}\n\n/// Determine whether this type is at last\n/// as qualified as the Other type. For example, \"const volatile\n/// int\" is at least as qualified as \"const int\", \"volatile int\",\n/// \"int\", and \"const volatile int\".\ninline bool QualType::isAtLeastAsQualifiedAs(QualType other) const {\n  Qualifiers OtherQuals = other.getQualifiers();\n\n  // Ignore __unaligned qualifier if this type is a void.\n  if (getUnqualifiedType()->isVoidType())\n    OtherQuals.removeUnaligned();\n\n  return getQualifiers().compatiblyIncludes(OtherQuals);\n}\n\n/// If Type is a reference type (e.g., const\n/// int&), returns the type that the reference refers to (\"const\n/// int\"). Otherwise, returns the type itself. This routine is used\n/// throughout Sema to implement C++ 5p6:\n///\n///   If an expression initially has the type \"reference to T\" (8.3.2,\n///   8.5.3), the type is adjusted to \"T\" prior to any further\n///   analysis, the expression designates the object or function\n///   denoted by the reference, and the expression is an lvalue.\ninline QualType QualType::getNonReferenceType() const {\n  if (const auto *RefType = (*this)->getAs<ReferenceType>())\n    return RefType->getPointeeType();\n  else\n    return *this;\n}\n\ninline bool QualType::isCForbiddenLValueType() const {\n  return ((getTypePtr()->isVoidType() && !hasQualifiers()) ||\n          getTypePtr()->isFunctionType());\n}\n\n/// Tests whether the type is categorized as a fundamental type.\n///\n/// \\returns True for types specified in C++0x [basic.fundamental].\ninline bool Type::isFundamentalType() const {\n  return isVoidType() ||\n         isNullPtrType() ||\n         // FIXME: It's really annoying that we don't have an\n         // 'isArithmeticType()' which agrees with the standard definition.\n         (isArithmeticType() && !isEnumeralType());\n}\n\n/// Tests whether the type is categorized as a compound type.\n///\n/// \\returns True for types specified in C++0x [basic.compound].\ninline bool Type::isCompoundType() const {\n  // C++0x [basic.compound]p1:\n  //   Compound types can be constructed in the following ways:\n  //    -- arrays of objects of a given type [...];\n  return isArrayType() ||\n  //    -- functions, which have parameters of given types [...];\n         isFunctionType() ||\n  //    -- pointers to void or objects or functions [...];\n         isPointerType() ||\n  //    -- references to objects or functions of a given type. [...]\n         isReferenceType() ||\n  //    -- classes containing a sequence of objects of various types, [...];\n         isRecordType() ||\n  //    -- unions, which are classes capable of containing objects of different\n  //               types at different times;\n         isUnionType() ||\n  //    -- enumerations, which comprise a set of named constant values. [...];\n         isEnumeralType() ||\n  //    -- pointers to non-static class members, [...].\n         isMemberPointerType();\n}\n\ninline bool Type::isFunctionType() const {\n  return isa<FunctionType>(CanonicalType);\n}\n\ninline bool Type::isPointerType() const {\n  return isa<PointerType>(CanonicalType);\n}\n\ninline bool Type::isAnyPointerType() const {\n  return isPointerType() || isObjCObjectPointerType();\n}\n\ninline bool Type::isBlockPointerType() const {\n  return isa<BlockPointerType>(CanonicalType);\n}\n\ninline bool Type::isReferenceType() const {\n  return isa<ReferenceType>(CanonicalType);\n}\n\ninline bool Type::isLValueReferenceType() const {\n  return isa<LValueReferenceType>(CanonicalType);\n}\n\ninline bool Type::isRValueReferenceType() const {\n  return isa<RValueReferenceType>(CanonicalType);\n}\n\ninline bool Type::isObjectPointerType() const {\n  // Note: an \"object pointer type\" is not the same thing as a pointer to an\n  // object type; rather, it is a pointer to an object type or a pointer to cv\n  // void.\n  if (const auto *T = getAs<PointerType>())\n    return !T->getPointeeType()->isFunctionType();\n  else\n    return false;\n}\n\ninline bool Type::isFunctionPointerType() const {\n  if (const auto *T = getAs<PointerType>())\n    return T->getPointeeType()->isFunctionType();\n  else\n    return false;\n}\n\ninline bool Type::isFunctionReferenceType() const {\n  if (const auto *T = getAs<ReferenceType>())\n    return T->getPointeeType()->isFunctionType();\n  else\n    return false;\n}\n\ninline bool Type::isMemberPointerType() const {\n  return isa<MemberPointerType>(CanonicalType);\n}\n\ninline bool Type::isMemberFunctionPointerType() const {\n  if (const auto *T = getAs<MemberPointerType>())\n    return T->isMemberFunctionPointer();\n  else\n    return false;\n}\n\ninline bool Type::isMemberDataPointerType() const {\n  if (const auto *T = getAs<MemberPointerType>())\n    return T->isMemberDataPointer();\n  else\n    return false;\n}\n\ninline bool Type::isArrayType() const {\n  return isa<ArrayType>(CanonicalType);\n}\n\ninline bool Type::isConstantArrayType() const {\n  return isa<ConstantArrayType>(CanonicalType);\n}\n\ninline bool Type::isIncompleteArrayType() const {\n  return isa<IncompleteArrayType>(CanonicalType);\n}\n\ninline bool Type::isVariableArrayType() const {\n  return isa<VariableArrayType>(CanonicalType);\n}\n\ninline bool Type::isDependentSizedArrayType() const {\n  return isa<DependentSizedArrayType>(CanonicalType);\n}\n\ninline bool Type::isBuiltinType() const {\n  return isa<BuiltinType>(CanonicalType);\n}\n\ninline bool Type::isRecordType() const {\n  return isa<RecordType>(CanonicalType);\n}\n\ninline bool Type::isEnumeralType() const {\n  return isa<EnumType>(CanonicalType);\n}\n\ninline bool Type::isAnyComplexType() const {\n  return isa<ComplexType>(CanonicalType);\n}\n\ninline bool Type::isVectorType() const {\n  return isa<VectorType>(CanonicalType);\n}\n\ninline bool Type::isExtVectorType() const {\n  return isa<ExtVectorType>(CanonicalType);\n}\n\ninline bool Type::isMatrixType() const {\n  return isa<MatrixType>(CanonicalType);\n}\n\ninline bool Type::isConstantMatrixType() const {\n  return isa<ConstantMatrixType>(CanonicalType);\n}\n\ninline bool Type::isDependentAddressSpaceType() const {\n  return isa<DependentAddressSpaceType>(CanonicalType);\n}\n\ninline bool Type::isObjCObjectPointerType() const {\n  return isa<ObjCObjectPointerType>(CanonicalType);\n}\n\ninline bool Type::isObjCObjectType() const {\n  return isa<ObjCObjectType>(CanonicalType);\n}\n\ninline bool Type::isObjCObjectOrInterfaceType() const {\n  return isa<ObjCInterfaceType>(CanonicalType) ||\n    isa<ObjCObjectType>(CanonicalType);\n}\n\ninline bool Type::isAtomicType() const {\n  return isa<AtomicType>(CanonicalType);\n}\n\ninline bool Type::isUndeducedAutoType() const {\n  return isa<AutoType>(CanonicalType);\n}\n\ninline bool Type::isObjCQualifiedIdType() const {\n  if (const auto *OPT = getAs<ObjCObjectPointerType>())\n    return OPT->isObjCQualifiedIdType();\n  return false;\n}\n\ninline bool Type::isObjCQualifiedClassType() const {\n  if (const auto *OPT = getAs<ObjCObjectPointerType>())\n    return OPT->isObjCQualifiedClassType();\n  return false;\n}\n\ninline bool Type::isObjCIdType() const {\n  if (const auto *OPT = getAs<ObjCObjectPointerType>())\n    return OPT->isObjCIdType();\n  return false;\n}\n\ninline bool Type::isObjCClassType() const {\n  if (const auto *OPT = getAs<ObjCObjectPointerType>())\n    return OPT->isObjCClassType();\n  return false;\n}\n\ninline bool Type::isObjCSelType() const {\n  if (const auto *OPT = getAs<PointerType>())\n    return OPT->getPointeeType()->isSpecificBuiltinType(BuiltinType::ObjCSel);\n  return false;\n}\n\ninline bool Type::isObjCBuiltinType() const {\n  return isObjCIdType() || isObjCClassType() || isObjCSelType();\n}\n\ninline bool Type::isDecltypeType() const {\n  return isa<DecltypeType>(this);\n}\n\n#define IMAGE_TYPE(ImgType, Id, SingletonId, Access, Suffix) \\\n  inline bool Type::is##Id##Type() const { \\\n    return isSpecificBuiltinType(BuiltinType::Id); \\\n  }\n#include \"clang/Basic/OpenCLImageTypes.def\"\n\ninline bool Type::isSamplerT() const {\n  return isSpecificBuiltinType(BuiltinType::OCLSampler);\n}\n\ninline bool Type::isEventT() const {\n  return isSpecificBuiltinType(BuiltinType::OCLEvent);\n}\n\ninline bool Type::isClkEventT() const {\n  return isSpecificBuiltinType(BuiltinType::OCLClkEvent);\n}\n\ninline bool Type::isQueueT() const {\n  return isSpecificBuiltinType(BuiltinType::OCLQueue);\n}\n\ninline bool Type::isReserveIDT() const {\n  return isSpecificBuiltinType(BuiltinType::OCLReserveID);\n}\n\ninline bool Type::isImageType() const {\n#define IMAGE_TYPE(ImgType, Id, SingletonId, Access, Suffix) is##Id##Type() ||\n  return\n#include \"clang/Basic/OpenCLImageTypes.def\"\n      false; // end boolean or operation\n}\n\ninline bool Type::isPipeType() const {\n  return isa<PipeType>(CanonicalType);\n}\n\ninline bool Type::isExtIntType() const {\n  return isa<ExtIntType>(CanonicalType);\n}\n\n#define EXT_OPAQUE_TYPE(ExtType, Id, Ext) \\\n  inline bool Type::is##Id##Type() const { \\\n    return isSpecificBuiltinType(BuiltinType::Id); \\\n  }\n#include \"clang/Basic/OpenCLExtensionTypes.def\"\n\ninline bool Type::isOCLIntelSubgroupAVCType() const {\n#define INTEL_SUBGROUP_AVC_TYPE(ExtType, Id) \\\n  isOCLIntelSubgroupAVC##Id##Type() ||\n  return\n#include \"clang/Basic/OpenCLExtensionTypes.def\"\n    false; // end of boolean or operation\n}\n\ninline bool Type::isOCLExtOpaqueType() const {\n#define EXT_OPAQUE_TYPE(ExtType, Id, Ext) is##Id##Type() ||\n  return\n#include \"clang/Basic/OpenCLExtensionTypes.def\"\n    false; // end of boolean or operation\n}\n\ninline bool Type::isOpenCLSpecificType() const {\n  return isSamplerT() || isEventT() || isImageType() || isClkEventT() ||\n         isQueueT() || isReserveIDT() || isPipeType() || isOCLExtOpaqueType();\n}\n\ninline bool Type::isTemplateTypeParmType() const {\n  return isa<TemplateTypeParmType>(CanonicalType);\n}\n\ninline bool Type::isSpecificBuiltinType(unsigned K) const {\n  if (const BuiltinType *BT = getAs<BuiltinType>()) {\n    return BT->getKind() == static_cast<BuiltinType::Kind>(K);\n  }\n  return false;\n}\n\ninline bool Type::isPlaceholderType() const {\n  if (const auto *BT = dyn_cast<BuiltinType>(this))\n    return BT->isPlaceholderType();\n  return false;\n}\n\ninline const BuiltinType *Type::getAsPlaceholderType() const {\n  if (const auto *BT = dyn_cast<BuiltinType>(this))\n    if (BT->isPlaceholderType())\n      return BT;\n  return nullptr;\n}\n\ninline bool Type::isSpecificPlaceholderType(unsigned K) const {\n  assert(BuiltinType::isPlaceholderTypeKind((BuiltinType::Kind) K));\n  return isSpecificBuiltinType(K);\n}\n\ninline bool Type::isNonOverloadPlaceholderType() const {\n  if (const auto *BT = dyn_cast<BuiltinType>(this))\n    return BT->isNonOverloadPlaceholderType();\n  return false;\n}\n\ninline bool Type::isVoidType() const {\n  return isSpecificBuiltinType(BuiltinType::Void);\n}\n\ninline bool Type::isHalfType() const {\n  // FIXME: Should we allow complex __fp16? Probably not.\n  return isSpecificBuiltinType(BuiltinType::Half);\n}\n\ninline bool Type::isFloat16Type() const {\n  return isSpecificBuiltinType(BuiltinType::Float16);\n}\n\ninline bool Type::isBFloat16Type() const {\n  return isSpecificBuiltinType(BuiltinType::BFloat16);\n}\n\ninline bool Type::isFloat128Type() const {\n  return isSpecificBuiltinType(BuiltinType::Float128);\n}\n\ninline bool Type::isNullPtrType() const {\n  return isSpecificBuiltinType(BuiltinType::NullPtr);\n}\n\nbool IsEnumDeclComplete(EnumDecl *);\nbool IsEnumDeclScoped(EnumDecl *);\n\ninline bool Type::isIntegerType() const {\n  if (const auto *BT = dyn_cast<BuiltinType>(CanonicalType))\n    return BT->getKind() >= BuiltinType::Bool &&\n           BT->getKind() <= BuiltinType::Int128;\n  if (const EnumType *ET = dyn_cast<EnumType>(CanonicalType)) {\n    // Incomplete enum types are not treated as integer types.\n    // FIXME: In C++, enum types are never integer types.\n    return IsEnumDeclComplete(ET->getDecl()) &&\n      !IsEnumDeclScoped(ET->getDecl());\n  }\n  return isExtIntType();\n}\n\ninline bool Type::isFixedPointType() const {\n  if (const auto *BT = dyn_cast<BuiltinType>(CanonicalType)) {\n    return BT->getKind() >= BuiltinType::ShortAccum &&\n           BT->getKind() <= BuiltinType::SatULongFract;\n  }\n  return false;\n}\n\ninline bool Type::isFixedPointOrIntegerType() const {\n  return isFixedPointType() || isIntegerType();\n}\n\ninline bool Type::isSaturatedFixedPointType() const {\n  if (const auto *BT = dyn_cast<BuiltinType>(CanonicalType)) {\n    return BT->getKind() >= BuiltinType::SatShortAccum &&\n           BT->getKind() <= BuiltinType::SatULongFract;\n  }\n  return false;\n}\n\ninline bool Type::isUnsaturatedFixedPointType() const {\n  return isFixedPointType() && !isSaturatedFixedPointType();\n}\n\ninline bool Type::isSignedFixedPointType() const {\n  if (const auto *BT = dyn_cast<BuiltinType>(CanonicalType)) {\n    return ((BT->getKind() >= BuiltinType::ShortAccum &&\n             BT->getKind() <= BuiltinType::LongAccum) ||\n            (BT->getKind() >= BuiltinType::ShortFract &&\n             BT->getKind() <= BuiltinType::LongFract) ||\n            (BT->getKind() >= BuiltinType::SatShortAccum &&\n             BT->getKind() <= BuiltinType::SatLongAccum) ||\n            (BT->getKind() >= BuiltinType::SatShortFract &&\n             BT->getKind() <= BuiltinType::SatLongFract));\n  }\n  return false;\n}\n\ninline bool Type::isUnsignedFixedPointType() const {\n  return isFixedPointType() && !isSignedFixedPointType();\n}\n\ninline bool Type::isScalarType() const {\n  if (const auto *BT = dyn_cast<BuiltinType>(CanonicalType))\n    return BT->getKind() > BuiltinType::Void &&\n           BT->getKind() <= BuiltinType::NullPtr;\n  if (const EnumType *ET = dyn_cast<EnumType>(CanonicalType))\n    // Enums are scalar types, but only if they are defined.  Incomplete enums\n    // are not treated as scalar types.\n    return IsEnumDeclComplete(ET->getDecl());\n  return isa<PointerType>(CanonicalType) ||\n         isa<BlockPointerType>(CanonicalType) ||\n         isa<MemberPointerType>(CanonicalType) ||\n         isa<ComplexType>(CanonicalType) ||\n         isa<ObjCObjectPointerType>(CanonicalType) ||\n         isExtIntType();\n}\n\ninline bool Type::isIntegralOrEnumerationType() const {\n  if (const auto *BT = dyn_cast<BuiltinType>(CanonicalType))\n    return BT->getKind() >= BuiltinType::Bool &&\n           BT->getKind() <= BuiltinType::Int128;\n\n  // Check for a complete enum type; incomplete enum types are not properly an\n  // enumeration type in the sense required here.\n  if (const auto *ET = dyn_cast<EnumType>(CanonicalType))\n    return IsEnumDeclComplete(ET->getDecl());\n\n  return isExtIntType();\n}\n\ninline bool Type::isBooleanType() const {\n  if (const auto *BT = dyn_cast<BuiltinType>(CanonicalType))\n    return BT->getKind() == BuiltinType::Bool;\n  return false;\n}\n\ninline bool Type::isUndeducedType() const {\n  auto *DT = getContainedDeducedType();\n  return DT && !DT->isDeduced();\n}\n\n/// Determines whether this is a type for which one can define\n/// an overloaded operator.\ninline bool Type::isOverloadableType() const {\n  return isDependentType() || isRecordType() || isEnumeralType();\n}\n\n/// Determines whether this type is written as a typedef-name.\ninline bool Type::isTypedefNameType() const {\n  if (getAs<TypedefType>())\n    return true;\n  if (auto *TST = getAs<TemplateSpecializationType>())\n    return TST->isTypeAlias();\n  return false;\n}\n\n/// Determines whether this type can decay to a pointer type.\ninline bool Type::canDecayToPointerType() const {\n  return isFunctionType() || isArrayType();\n}\n\ninline bool Type::hasPointerRepresentation() const {\n  return (isPointerType() || isReferenceType() || isBlockPointerType() ||\n          isObjCObjectPointerType() || isNullPtrType());\n}\n\ninline bool Type::hasObjCPointerRepresentation() const {\n  return isObjCObjectPointerType();\n}\n\ninline const Type *Type::getBaseElementTypeUnsafe() const {\n  const Type *type = this;\n  while (const ArrayType *arrayType = type->getAsArrayTypeUnsafe())\n    type = arrayType->getElementType().getTypePtr();\n  return type;\n}\n\ninline const Type *Type::getPointeeOrArrayElementType() const {\n  const Type *type = this;\n  if (type->isAnyPointerType())\n    return type->getPointeeType().getTypePtr();\n  else if (type->isArrayType())\n    return type->getBaseElementTypeUnsafe();\n  return type;\n}\n/// Insertion operator for partial diagnostics. This allows sending adress\n/// spaces into a diagnostic with <<.\ninline const StreamingDiagnostic &operator<<(const StreamingDiagnostic &PD,\n                                             LangAS AS) {\n  PD.AddTaggedVal(static_cast<std::underlying_type_t<LangAS>>(AS),\n                  DiagnosticsEngine::ArgumentKind::ak_addrspace);\n  return PD;\n}\n\n/// Insertion operator for partial diagnostics. This allows sending Qualifiers\n/// into a diagnostic with <<.\ninline const StreamingDiagnostic &operator<<(const StreamingDiagnostic &PD,\n                                             Qualifiers Q) {\n  PD.AddTaggedVal(Q.getAsOpaqueValue(),\n                  DiagnosticsEngine::ArgumentKind::ak_qual);\n  return PD;\n}\n\n/// Insertion operator for partial diagnostics.  This allows sending QualType's\n/// into a diagnostic with <<.\ninline const StreamingDiagnostic &operator<<(const StreamingDiagnostic &PD,\n                                             QualType T) {\n  PD.AddTaggedVal(reinterpret_cast<intptr_t>(T.getAsOpaquePtr()),\n                  DiagnosticsEngine::ak_qualtype);\n  return PD;\n}\n\n// Helper class template that is used by Type::getAs to ensure that one does\n// not try to look through a qualified type to get to an array type.\ntemplate <typename T>\nusing TypeIsArrayType =\n    std::integral_constant<bool, std::is_same<T, ArrayType>::value ||\n                                     std::is_base_of<ArrayType, T>::value>;\n\n// Member-template getAs<specific type>'.\ntemplate <typename T> const T *Type::getAs() const {\n  static_assert(!TypeIsArrayType<T>::value,\n                \"ArrayType cannot be used with getAs!\");\n\n  // If this is directly a T type, return it.\n  if (const auto *Ty = dyn_cast<T>(this))\n    return Ty;\n\n  // If the canonical form of this type isn't the right kind, reject it.\n  if (!isa<T>(CanonicalType))\n    return nullptr;\n\n  // If this is a typedef for the type, strip the typedef off without\n  // losing all typedef information.\n  return cast<T>(getUnqualifiedDesugaredType());\n}\n\ntemplate <typename T> const T *Type::getAsAdjusted() const {\n  static_assert(!TypeIsArrayType<T>::value, \"ArrayType cannot be used with getAsAdjusted!\");\n\n  // If this is directly a T type, return it.\n  if (const auto *Ty = dyn_cast<T>(this))\n    return Ty;\n\n  // If the canonical form of this type isn't the right kind, reject it.\n  if (!isa<T>(CanonicalType))\n    return nullptr;\n\n  // Strip off type adjustments that do not modify the underlying nature of the\n  // type.\n  const Type *Ty = this;\n  while (Ty) {\n    if (const auto *A = dyn_cast<AttributedType>(Ty))\n      Ty = A->getModifiedType().getTypePtr();\n    else if (const auto *E = dyn_cast<ElaboratedType>(Ty))\n      Ty = E->desugar().getTypePtr();\n    else if (const auto *P = dyn_cast<ParenType>(Ty))\n      Ty = P->desugar().getTypePtr();\n    else if (const auto *A = dyn_cast<AdjustedType>(Ty))\n      Ty = A->desugar().getTypePtr();\n    else if (const auto *M = dyn_cast<MacroQualifiedType>(Ty))\n      Ty = M->desugar().getTypePtr();\n    else\n      break;\n  }\n\n  // Just because the canonical type is correct does not mean we can use cast<>,\n  // since we may not have stripped off all the sugar down to the base type.\n  return dyn_cast<T>(Ty);\n}\n\ninline const ArrayType *Type::getAsArrayTypeUnsafe() const {\n  // If this is directly an array type, return it.\n  if (const auto *arr = dyn_cast<ArrayType>(this))\n    return arr;\n\n  // If the canonical form of this type isn't the right kind, reject it.\n  if (!isa<ArrayType>(CanonicalType))\n    return nullptr;\n\n  // If this is a typedef for the type, strip the typedef off without\n  // losing all typedef information.\n  return cast<ArrayType>(getUnqualifiedDesugaredType());\n}\n\ntemplate <typename T> const T *Type::castAs() const {\n  static_assert(!TypeIsArrayType<T>::value,\n                \"ArrayType cannot be used with castAs!\");\n\n  if (const auto *ty = dyn_cast<T>(this)) return ty;\n  assert(isa<T>(CanonicalType));\n  return cast<T>(getUnqualifiedDesugaredType());\n}\n\ninline const ArrayType *Type::castAsArrayTypeUnsafe() const {\n  assert(isa<ArrayType>(CanonicalType));\n  if (const auto *arr = dyn_cast<ArrayType>(this)) return arr;\n  return cast<ArrayType>(getUnqualifiedDesugaredType());\n}\n\nDecayedType::DecayedType(QualType OriginalType, QualType DecayedPtr,\n                         QualType CanonicalPtr)\n    : AdjustedType(Decayed, OriginalType, DecayedPtr, CanonicalPtr) {\n#ifndef NDEBUG\n  QualType Adjusted = getAdjustedType();\n  (void)AttributedType::stripOuterNullability(Adjusted);\n  assert(isa<PointerType>(Adjusted));\n#endif\n}\n\nQualType DecayedType::getPointeeType() const {\n  QualType Decayed = getDecayedType();\n  (void)AttributedType::stripOuterNullability(Decayed);\n  return cast<PointerType>(Decayed)->getPointeeType();\n}\n\n// Get the decimal string representation of a fixed point type, represented\n// as a scaled integer.\n// TODO: At some point, we should change the arguments to instead just accept an\n// APFixedPoint instead of APSInt and scale.\nvoid FixedPointValueToString(SmallVectorImpl<char> &Str, llvm::APSInt Val,\n                             unsigned Scale);\n\n} // namespace clang\n\n#endif // LLVM_CLANG_AST_TYPE_H\n"}, "14": {"id": 14, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/TypeLoc.h", "content": "//===- TypeLoc.h - Type Source Info Wrapper ---------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n/// \\file\n/// Defines the clang::TypeLoc interface and its subclasses.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_AST_TYPELOC_H\n#define LLVM_CLANG_AST_TYPELOC_H\n\n#include \"clang/AST/DeclarationName.h\"\n#include \"clang/AST/NestedNameSpecifier.h\"\n#include \"clang/AST/TemplateBase.h\"\n#include \"clang/AST/Type.h\"\n#include \"clang/Basic/LLVM.h\"\n#include \"clang/Basic/SourceLocation.h\"\n#include \"clang/Basic/Specifiers.h\"\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/Support/Casting.h\"\n#include \"llvm/Support/Compiler.h\"\n#include \"llvm/Support/MathExtras.h\"\n#include <algorithm>\n#include <cassert>\n#include <cstdint>\n#include <cstring>\n\nnamespace clang {\n\nclass Attr;\nclass ASTContext;\nclass CXXRecordDecl;\nclass ConceptDecl;\nclass Expr;\nclass ObjCInterfaceDecl;\nclass ObjCProtocolDecl;\nclass ObjCTypeParamDecl;\nclass ParmVarDecl;\nclass TemplateTypeParmDecl;\nclass UnqualTypeLoc;\nclass UnresolvedUsingTypenameDecl;\n\n// Predeclare all the type nodes.\n#define ABSTRACT_TYPELOC(Class, Base)\n#define TYPELOC(Class, Base) \\\n  class Class##TypeLoc;\n#include \"clang/AST/TypeLocNodes.def\"\n\n/// Base wrapper for a particular \"section\" of type source info.\n///\n/// A client should use the TypeLoc subclasses through castAs()/getAs()\n/// in order to get at the actual information.\nclass TypeLoc {\nprotected:\n  // The correctness of this relies on the property that, for Type *Ty,\n  //   QualType(Ty, 0).getAsOpaquePtr() == (void*) Ty\n  const void *Ty = nullptr;\n  void *Data = nullptr;\n\npublic:\n  TypeLoc() = default;\n  TypeLoc(QualType ty, void *opaqueData)\n      : Ty(ty.getAsOpaquePtr()), Data(opaqueData) {}\n  TypeLoc(const Type *ty, void *opaqueData)\n      : Ty(ty), Data(opaqueData) {}\n\n  /// Convert to the specified TypeLoc type, asserting that this TypeLoc\n  /// is of the desired type.\n  ///\n  /// \\pre T::isKind(*this)\n  template<typename T>\n  T castAs() const {\n    assert(T::isKind(*this));\n    T t;\n    TypeLoc& tl = t;\n    tl = *this;\n    return t;\n  }\n\n  /// Convert to the specified TypeLoc type, returning a null TypeLoc if\n  /// this TypeLoc is not of the desired type.\n  template<typename T>\n  T getAs() const {\n    if (!T::isKind(*this))\n      return {};\n    T t;\n    TypeLoc& tl = t;\n    tl = *this;\n    return t;\n  }\n\n  /// Convert to the specified TypeLoc type, returning a null TypeLoc if\n  /// this TypeLoc is not of the desired type. It will consider type\n  /// adjustments from a type that was written as a T to another type that is\n  /// still canonically a T (ignores parens, attributes, elaborated types, etc).\n  template <typename T>\n  T getAsAdjusted() const;\n\n  /// The kinds of TypeLocs.  Equivalent to the Type::TypeClass enum,\n  /// except it also defines a Qualified enum that corresponds to the\n  /// QualifiedLoc class.\n  enum TypeLocClass {\n#define ABSTRACT_TYPE(Class, Base)\n#define TYPE(Class, Base) \\\n    Class = Type::Class,\n#include \"clang/AST/TypeNodes.inc\"\n    Qualified\n  };\n\n  TypeLocClass getTypeLocClass() const {\n    if (getType().hasLocalQualifiers()) return Qualified;\n    return (TypeLocClass) getType()->getTypeClass();\n  }\n\n  bool isNull() const { return !Ty; }\n  explicit operator bool() const { return Ty; }\n\n  /// Returns the size of type source info data block for the given type.\n  static unsigned getFullDataSizeForType(QualType Ty);\n\n  /// Returns the alignment of type source info data block for\n  /// the given type.\n  static unsigned getLocalAlignmentForType(QualType Ty);\n\n  /// Get the type for which this source info wrapper provides\n  /// information.\n  QualType getType() const {\n    return QualType::getFromOpaquePtr(Ty);\n  }\n\n  const Type *getTypePtr() const {\n    return QualType::getFromOpaquePtr(Ty).getTypePtr();\n  }\n\n  /// Get the pointer where source information is stored.\n  void *getOpaqueData() const {\n    return Data;\n  }\n\n  /// Get the begin source location.\n  SourceLocation getBeginLoc() const;\n\n  /// Get the end source location.\n  SourceLocation getEndLoc() const;\n\n  /// Get the full source range.\n  SourceRange getSourceRange() const LLVM_READONLY {\n    return SourceRange(getBeginLoc(), getEndLoc());\n  }\n\n\n  /// Get the local source range.\n  SourceRange getLocalSourceRange() const {\n    return getLocalSourceRangeImpl(*this);\n  }\n\n  /// Returns the size of the type source info data block.\n  unsigned getFullDataSize() const {\n    return getFullDataSizeForType(getType());\n  }\n\n  /// Get the next TypeLoc pointed by this TypeLoc, e.g for \"int*\" the\n  /// TypeLoc is a PointerLoc and next TypeLoc is for \"int\".\n  TypeLoc getNextTypeLoc() const {\n    return getNextTypeLocImpl(*this);\n  }\n\n  /// Skips past any qualifiers, if this is qualified.\n  UnqualTypeLoc getUnqualifiedLoc() const; // implemented in this header\n\n  TypeLoc IgnoreParens() const;\n\n  /// Find a type with the location of an explicit type qualifier.\n  ///\n  /// The result, if non-null, will be one of:\n  ///   QualifiedTypeLoc\n  ///   AtomicTypeLoc\n  ///   AttributedTypeLoc, for those type attributes that behave as qualifiers\n  TypeLoc findExplicitQualifierLoc() const;\n\n  /// Get the typeloc of an AutoType whose type will be deduced for a variable\n  /// with an initializer of this type. This looks through declarators like\n  /// pointer types, but not through decltype or typedefs.\n  AutoTypeLoc getContainedAutoTypeLoc() const;\n\n  /// Initializes this to state that every location in this\n  /// type is the given location.\n  ///\n  /// This method exists to provide a simple transition for code that\n  /// relies on location-less types.\n  void initialize(ASTContext &Context, SourceLocation Loc) const {\n    initializeImpl(Context, *this, Loc);\n  }\n\n  /// Initializes this by copying its information from another\n  /// TypeLoc of the same type.\n  void initializeFullCopy(TypeLoc Other) {\n    assert(getType() == Other.getType());\n    copy(Other);\n  }\n\n  /// Initializes this by copying its information from another\n  /// TypeLoc of the same type.  The given size must be the full data\n  /// size.\n  void initializeFullCopy(TypeLoc Other, unsigned Size) {\n    assert(getType() == Other.getType());\n    assert(getFullDataSize() == Size);\n    copy(Other);\n  }\n\n  /// Copies the other type loc into this one.\n  void copy(TypeLoc other);\n\n  friend bool operator==(const TypeLoc &LHS, const TypeLoc &RHS) {\n    return LHS.Ty == RHS.Ty && LHS.Data == RHS.Data;\n  }\n\n  friend bool operator!=(const TypeLoc &LHS, const TypeLoc &RHS) {\n    return !(LHS == RHS);\n  }\n\n  /// Find the location of the nullability specifier (__nonnull,\n  /// __nullable, or __null_unspecifier), if there is one.\n  SourceLocation findNullabilityLoc() const;\n\nprivate:\n  static bool isKind(const TypeLoc&) {\n    return true;\n  }\n\n  static void initializeImpl(ASTContext &Context, TypeLoc TL,\n                             SourceLocation Loc);\n  static TypeLoc getNextTypeLocImpl(TypeLoc TL);\n  static TypeLoc IgnoreParensImpl(TypeLoc TL);\n  static SourceRange getLocalSourceRangeImpl(TypeLoc TL);\n};\n\n/// Return the TypeLoc for a type source info.\ninline TypeLoc TypeSourceInfo::getTypeLoc() const {\n  // TODO: is this alignment already sufficient?\n  return TypeLoc(Ty, const_cast<void*>(static_cast<const void*>(this + 1)));\n}\n\n/// Wrapper of type source information for a type with\n/// no direct qualifiers.\nclass UnqualTypeLoc : public TypeLoc {\npublic:\n  UnqualTypeLoc() = default;\n  UnqualTypeLoc(const Type *Ty, void *Data) : TypeLoc(Ty, Data) {}\n\n  const Type *getTypePtr() const {\n    return reinterpret_cast<const Type*>(Ty);\n  }\n\n  TypeLocClass getTypeLocClass() const {\n    return (TypeLocClass) getTypePtr()->getTypeClass();\n  }\n\nprivate:\n  friend class TypeLoc;\n\n  static bool isKind(const TypeLoc &TL) {\n    return !TL.getType().hasLocalQualifiers();\n  }\n};\n\n/// Wrapper of type source information for a type with\n/// non-trivial direct qualifiers.\n///\n/// Currently, we intentionally do not provide source location for\n/// type qualifiers.\nclass QualifiedTypeLoc : public TypeLoc {\npublic:\n  SourceRange getLocalSourceRange() const { return {}; }\n\n  UnqualTypeLoc getUnqualifiedLoc() const {\n    unsigned align =\n        TypeLoc::getLocalAlignmentForType(QualType(getTypePtr(), 0));\n    auto dataInt = reinterpret_cast<uintptr_t>(Data);\n    dataInt = llvm::alignTo(dataInt, align);\n    return UnqualTypeLoc(getTypePtr(), reinterpret_cast<void*>(dataInt));\n  }\n\n  /// Initializes the local data of this type source info block to\n  /// provide no information.\n  void initializeLocal(ASTContext &Context, SourceLocation Loc) {\n    // do nothing\n  }\n\n  void copyLocal(TypeLoc other) {\n    // do nothing\n  }\n\n  TypeLoc getNextTypeLoc() const {\n    return getUnqualifiedLoc();\n  }\n\n  /// Returns the size of the type source info data block that is\n  /// specific to this type.\n  unsigned getLocalDataSize() const {\n    // In fact, we don't currently preserve any location information\n    // for qualifiers.\n    return 0;\n  }\n\n  /// Returns the alignment of the type source info data block that is\n  /// specific to this type.\n  unsigned getLocalDataAlignment() const {\n    // We don't preserve any location information.\n    return 1;\n  }\n\nprivate:\n  friend class TypeLoc;\n\n  static bool isKind(const TypeLoc &TL) {\n    return TL.getType().hasLocalQualifiers();\n  }\n};\n\ninline UnqualTypeLoc TypeLoc::getUnqualifiedLoc() const {\n  if (QualifiedTypeLoc Loc = getAs<QualifiedTypeLoc>())\n    return Loc.getUnqualifiedLoc();\n  return castAs<UnqualTypeLoc>();\n}\n\n/// A metaprogramming base class for TypeLoc classes which correspond\n/// to a particular Type subclass.  It is accepted for a single\n/// TypeLoc class to correspond to multiple Type classes.\n///\n/// \\tparam Base a class from which to derive\n/// \\tparam Derived the class deriving from this one\n/// \\tparam TypeClass the concrete Type subclass associated with this\n///   location type\n/// \\tparam LocalData the structure type of local location data for\n///   this type\n///\n/// TypeLocs with non-constant amounts of local data should override\n/// getExtraLocalDataSize(); getExtraLocalData() will then point to\n/// this extra memory.\n///\n/// TypeLocs with an inner type should define\n///   QualType getInnerType() const\n/// and getInnerTypeLoc() will then point to this inner type's\n/// location data.\n///\n/// A word about hierarchies: this template is not designed to be\n/// derived from multiple times in a hierarchy.  It is also not\n/// designed to be used for classes where subtypes might provide\n/// different amounts of source information.  It should be subclassed\n/// only at the deepest portion of the hierarchy where all children\n/// have identical source information; if that's an abstract type,\n/// then further descendents should inherit from\n/// InheritingConcreteTypeLoc instead.\ntemplate <class Base, class Derived, class TypeClass, class LocalData>\nclass ConcreteTypeLoc : public Base {\n  friend class TypeLoc;\n\n  const Derived *asDerived() const {\n    return static_cast<const Derived*>(this);\n  }\n\n  static bool isKind(const TypeLoc &TL) {\n    return !TL.getType().hasLocalQualifiers() &&\n           Derived::classofType(TL.getTypePtr());\n  }\n\n  static bool classofType(const Type *Ty) {\n    return TypeClass::classof(Ty);\n  }\n\npublic:\n  unsigned getLocalDataAlignment() const {\n    return std::max(unsigned(alignof(LocalData)),\n                    asDerived()->getExtraLocalDataAlignment());\n  }\n\n  unsigned getLocalDataSize() const {\n    unsigned size = sizeof(LocalData);\n    unsigned extraAlign = asDerived()->getExtraLocalDataAlignment();\n    size = llvm::alignTo(size, extraAlign);\n    size += asDerived()->getExtraLocalDataSize();\n    return size;\n  }\n\n  void copyLocal(Derived other) {\n    // Some subclasses have no data to copy.\n    if (asDerived()->getLocalDataSize() == 0) return;\n\n    // Copy the fixed-sized local data.\n    memcpy(getLocalData(), other.getLocalData(), sizeof(LocalData));\n\n    // Copy the variable-sized local data. We need to do this\n    // separately because the padding in the source and the padding in\n    // the destination might be different.\n    memcpy(getExtraLocalData(), other.getExtraLocalData(),\n           asDerived()->getExtraLocalDataSize());\n  }\n\n  TypeLoc getNextTypeLoc() const {\n    return getNextTypeLoc(asDerived()->getInnerType());\n  }\n\n  const TypeClass *getTypePtr() const {\n    return cast<TypeClass>(Base::getTypePtr());\n  }\n\nprotected:\n  unsigned getExtraLocalDataSize() const {\n    return 0;\n  }\n\n  unsigned getExtraLocalDataAlignment() const {\n    return 1;\n  }\n\n  LocalData *getLocalData() const {\n    return static_cast<LocalData*>(Base::Data);\n  }\n\n  /// Gets a pointer past the Info structure; useful for classes with\n  /// local data that can't be captured in the Info (e.g. because it's\n  /// of variable size).\n  void *getExtraLocalData() const {\n    unsigned size = sizeof(LocalData);\n    unsigned extraAlign = asDerived()->getExtraLocalDataAlignment();\n    size = llvm::alignTo(size, extraAlign);\n    return reinterpret_cast<char*>(Base::Data) + size;\n  }\n\n  void *getNonLocalData() const {\n    auto data = reinterpret_cast<uintptr_t>(Base::Data);\n    data += asDerived()->getLocalDataSize();\n    data = llvm::alignTo(data, getNextTypeAlign());\n    return reinterpret_cast<void*>(data);\n  }\n\n  struct HasNoInnerType {};\n  HasNoInnerType getInnerType() const { return HasNoInnerType(); }\n\n  TypeLoc getInnerTypeLoc() const {\n    return TypeLoc(asDerived()->getInnerType(), getNonLocalData());\n  }\n\nprivate:\n  unsigned getInnerTypeSize() const {\n    return getInnerTypeSize(asDerived()->getInnerType());\n  }\n\n  unsigned getInnerTypeSize(HasNoInnerType _) const {\n    return 0;\n  }\n\n  unsigned getInnerTypeSize(QualType _) const {\n    return getInnerTypeLoc().getFullDataSize();\n  }\n\n  unsigned getNextTypeAlign() const {\n    return getNextTypeAlign(asDerived()->getInnerType());\n  }\n\n  unsigned getNextTypeAlign(HasNoInnerType _) const {\n    return 1;\n  }\n\n  unsigned getNextTypeAlign(QualType T) const {\n    return TypeLoc::getLocalAlignmentForType(T);\n  }\n\n  TypeLoc getNextTypeLoc(HasNoInnerType _) const { return {}; }\n\n  TypeLoc getNextTypeLoc(QualType T) const {\n    return TypeLoc(T, getNonLocalData());\n  }\n};\n\n/// A metaprogramming class designed for concrete subtypes of abstract\n/// types where all subtypes share equivalently-structured source\n/// information.  See the note on ConcreteTypeLoc.\ntemplate <class Base, class Derived, class TypeClass>\nclass InheritingConcreteTypeLoc : public Base {\n  friend class TypeLoc;\n\n  static bool classofType(const Type *Ty) {\n    return TypeClass::classof(Ty);\n  }\n\n  static bool isKind(const TypeLoc &TL) {\n    return !TL.getType().hasLocalQualifiers() &&\n           Derived::classofType(TL.getTypePtr());\n  }\n  static bool isKind(const UnqualTypeLoc &TL) {\n    return Derived::classofType(TL.getTypePtr());\n  }\n\npublic:\n  const TypeClass *getTypePtr() const {\n    return cast<TypeClass>(Base::getTypePtr());\n  }\n};\n\nstruct TypeSpecLocInfo {\n  SourceLocation NameLoc;\n};\n\n/// A reasonable base class for TypeLocs that correspond to\n/// types that are written as a type-specifier.\nclass TypeSpecTypeLoc : public ConcreteTypeLoc<UnqualTypeLoc,\n                                               TypeSpecTypeLoc,\n                                               Type,\n                                               TypeSpecLocInfo> {\npublic:\n  enum {\n    LocalDataSize = sizeof(TypeSpecLocInfo),\n    LocalDataAlignment = alignof(TypeSpecLocInfo)\n  };\n\n  SourceLocation getNameLoc() const {\n    return this->getLocalData()->NameLoc;\n  }\n\n  void setNameLoc(SourceLocation Loc) {\n    this->getLocalData()->NameLoc = Loc;\n  }\n\n  SourceRange getLocalSourceRange() const {\n    return SourceRange(getNameLoc(), getNameLoc());\n  }\n\n  void initializeLocal(ASTContext &Context, SourceLocation Loc) {\n    setNameLoc(Loc);\n  }\n\nprivate:\n  friend class TypeLoc;\n\n  static bool isKind(const TypeLoc &TL);\n};\n\nstruct BuiltinLocInfo {\n  SourceRange BuiltinRange;\n};\n\n/// Wrapper for source info for builtin types.\nclass BuiltinTypeLoc : public ConcreteTypeLoc<UnqualTypeLoc,\n                                              BuiltinTypeLoc,\n                                              BuiltinType,\n                                              BuiltinLocInfo> {\npublic:\n  SourceLocation getBuiltinLoc() const {\n    return getLocalData()->BuiltinRange.getBegin();\n  }\n\n  void setBuiltinLoc(SourceLocation Loc) {\n    getLocalData()->BuiltinRange = Loc;\n  }\n\n  void expandBuiltinRange(SourceRange Range) {\n    SourceRange &BuiltinRange = getLocalData()->BuiltinRange;\n    if (!BuiltinRange.getBegin().isValid()) {\n      BuiltinRange = Range;\n    } else {\n      BuiltinRange.setBegin(std::min(Range.getBegin(), BuiltinRange.getBegin()));\n      BuiltinRange.setEnd(std::max(Range.getEnd(), BuiltinRange.getEnd()));\n    }\n  }\n\n  SourceLocation getNameLoc() const { return getBuiltinLoc(); }\n\n  WrittenBuiltinSpecs& getWrittenBuiltinSpecs() {\n    return *(static_cast<WrittenBuiltinSpecs*>(getExtraLocalData()));\n  }\n  const WrittenBuiltinSpecs& getWrittenBuiltinSpecs() const {\n    return *(static_cast<WrittenBuiltinSpecs*>(getExtraLocalData()));\n  }\n\n  bool needsExtraLocalData() const {\n    BuiltinType::Kind bk = getTypePtr()->getKind();\n    return (bk >= BuiltinType::UShort && bk <= BuiltinType::UInt128)\n      || (bk >= BuiltinType::Short && bk <= BuiltinType::Float128)\n      || bk == BuiltinType::UChar\n      || bk == BuiltinType::SChar;\n  }\n\n  unsigned getExtraLocalDataSize() const {\n    return needsExtraLocalData() ? sizeof(WrittenBuiltinSpecs) : 0;\n  }\n\n  unsigned getExtraLocalDataAlignment() const {\n    return needsExtraLocalData() ? alignof(WrittenBuiltinSpecs) : 1;\n  }\n\n  SourceRange getLocalSourceRange() const {\n    return getLocalData()->BuiltinRange;\n  }\n\n  TypeSpecifierSign getWrittenSignSpec() const {\n    if (needsExtraLocalData())\n      return static_cast<TypeSpecifierSign>(getWrittenBuiltinSpecs().Sign);\n    else\n      return TypeSpecifierSign::Unspecified;\n  }\n\n  bool hasWrittenSignSpec() const {\n    return getWrittenSignSpec() != TypeSpecifierSign::Unspecified;\n  }\n\n  void setWrittenSignSpec(TypeSpecifierSign written) {\n    if (needsExtraLocalData())\n      getWrittenBuiltinSpecs().Sign = static_cast<unsigned>(written);\n  }\n\n  TypeSpecifierWidth getWrittenWidthSpec() const {\n    if (needsExtraLocalData())\n      return static_cast<TypeSpecifierWidth>(getWrittenBuiltinSpecs().Width);\n    else\n      return TypeSpecifierWidth::Unspecified;\n  }\n\n  bool hasWrittenWidthSpec() const {\n    return getWrittenWidthSpec() != TypeSpecifierWidth::Unspecified;\n  }\n\n  void setWrittenWidthSpec(TypeSpecifierWidth written) {\n    if (needsExtraLocalData())\n      getWrittenBuiltinSpecs().Width = static_cast<unsigned>(written);\n  }\n\n  TypeSpecifierType getWrittenTypeSpec() const;\n\n  bool hasWrittenTypeSpec() const {\n    return getWrittenTypeSpec() != TST_unspecified;\n  }\n\n  void setWrittenTypeSpec(TypeSpecifierType written) {\n    if (needsExtraLocalData())\n      getWrittenBuiltinSpecs().Type = written;\n  }\n\n  bool hasModeAttr() const {\n    if (needsExtraLocalData())\n      return getWrittenBuiltinSpecs().ModeAttr;\n    else\n      return false;\n  }\n\n  void setModeAttr(bool written) {\n    if (needsExtraLocalData())\n      getWrittenBuiltinSpecs().ModeAttr = written;\n  }\n\n  void initializeLocal(ASTContext &Context, SourceLocation Loc) {\n    setBuiltinLoc(Loc);\n    if (needsExtraLocalData()) {\n      WrittenBuiltinSpecs &wbs = getWrittenBuiltinSpecs();\n      wbs.Sign = static_cast<unsigned>(TypeSpecifierSign::Unspecified);\n      wbs.Width = static_cast<unsigned>(TypeSpecifierWidth::Unspecified);\n      wbs.Type = TST_unspecified;\n      wbs.ModeAttr = false;\n    }\n  }\n};\n\n/// Wrapper for source info for typedefs.\nclass TypedefTypeLoc : public InheritingConcreteTypeLoc<TypeSpecTypeLoc,\n                                                        TypedefTypeLoc,\n                                                        TypedefType> {\npublic:\n  TypedefNameDecl *getTypedefNameDecl() const {\n    return getTypePtr()->getDecl();\n  }\n};\n\n/// Wrapper for source info for injected class names of class\n/// templates.\nclass InjectedClassNameTypeLoc :\n    public InheritingConcreteTypeLoc<TypeSpecTypeLoc,\n                                     InjectedClassNameTypeLoc,\n                                     InjectedClassNameType> {\npublic:\n  CXXRecordDecl *getDecl() const {\n    return getTypePtr()->getDecl();\n  }\n};\n\n/// Wrapper for source info for unresolved typename using decls.\nclass UnresolvedUsingTypeLoc :\n    public InheritingConcreteTypeLoc<TypeSpecTypeLoc,\n                                     UnresolvedUsingTypeLoc,\n                                     UnresolvedUsingType> {\npublic:\n  UnresolvedUsingTypenameDecl *getDecl() const {\n    return getTypePtr()->getDecl();\n  }\n};\n\n/// Wrapper for source info for tag types.  Note that this only\n/// records source info for the name itself; a type written 'struct foo'\n/// should be represented as an ElaboratedTypeLoc.  We currently\n/// only do that when C++ is enabled because of the expense of\n/// creating an ElaboratedType node for so many type references in C.\nclass TagTypeLoc : public InheritingConcreteTypeLoc<TypeSpecTypeLoc,\n                                                    TagTypeLoc,\n                                                    TagType> {\npublic:\n  TagDecl *getDecl() const { return getTypePtr()->getDecl(); }\n\n  /// True if the tag was defined in this type specifier.\n  bool isDefinition() const;\n};\n\n/// Wrapper for source info for record types.\nclass RecordTypeLoc : public InheritingConcreteTypeLoc<TagTypeLoc,\n                                                       RecordTypeLoc,\n                                                       RecordType> {\npublic:\n  RecordDecl *getDecl() const { return getTypePtr()->getDecl(); }\n};\n\n/// Wrapper for source info for enum types.\nclass EnumTypeLoc : public InheritingConcreteTypeLoc<TagTypeLoc,\n                                                     EnumTypeLoc,\n                                                     EnumType> {\npublic:\n  EnumDecl *getDecl() const { return getTypePtr()->getDecl(); }\n};\n\n/// Wrapper for template type parameters.\nclass TemplateTypeParmTypeLoc :\n    public InheritingConcreteTypeLoc<TypeSpecTypeLoc,\n                                     TemplateTypeParmTypeLoc,\n                                     TemplateTypeParmType> {\npublic:\n  TemplateTypeParmDecl *getDecl() const { return getTypePtr()->getDecl(); }\n};\n\nstruct ObjCTypeParamTypeLocInfo {\n  SourceLocation NameLoc;\n};\n\n/// ProtocolLAngleLoc, ProtocolRAngleLoc, and the source locations for\n/// protocol qualifiers are stored after Info.\nclass ObjCTypeParamTypeLoc : public ConcreteTypeLoc<UnqualTypeLoc,\n                                     ObjCTypeParamTypeLoc,\n                                     ObjCTypeParamType,\n                                     ObjCTypeParamTypeLocInfo> {\n  // SourceLocations are stored after Info, one for each protocol qualifier.\n  SourceLocation *getProtocolLocArray() const {\n    return (SourceLocation*)this->getExtraLocalData() + 2;\n  }\n\npublic:\n  ObjCTypeParamDecl *getDecl() const { return getTypePtr()->getDecl(); }\n\n  SourceLocation getNameLoc() const {\n    return this->getLocalData()->NameLoc;\n  }\n\n  void setNameLoc(SourceLocation Loc) {\n    this->getLocalData()->NameLoc = Loc;\n  }\n\n  SourceLocation getProtocolLAngleLoc() const {\n    return getNumProtocols()  ?\n      *((SourceLocation*)this->getExtraLocalData()) :\n      SourceLocation();\n  }\n\n  void setProtocolLAngleLoc(SourceLocation Loc) {\n    *((SourceLocation*)this->getExtraLocalData()) = Loc;\n  }\n\n  SourceLocation getProtocolRAngleLoc() const {\n    return getNumProtocols()  ?\n      *((SourceLocation*)this->getExtraLocalData() + 1) :\n      SourceLocation();\n  }\n\n  void setProtocolRAngleLoc(SourceLocation Loc) {\n    *((SourceLocation*)this->getExtraLocalData() + 1) = Loc;\n  }\n\n  unsigned getNumProtocols() const {\n    return this->getTypePtr()->getNumProtocols();\n  }\n\n  SourceLocation getProtocolLoc(unsigned i) const {\n    assert(i < getNumProtocols() && \"Index is out of bounds!\");\n    return getProtocolLocArray()[i];\n  }\n\n  void setProtocolLoc(unsigned i, SourceLocation Loc) {\n    assert(i < getNumProtocols() && \"Index is out of bounds!\");\n    getProtocolLocArray()[i] = Loc;\n  }\n\n  ObjCProtocolDecl *getProtocol(unsigned i) const {\n    assert(i < getNumProtocols() && \"Index is out of bounds!\");\n    return *(this->getTypePtr()->qual_begin() + i);\n  }\n\n  ArrayRef<SourceLocation> getProtocolLocs() const {\n    return llvm::makeArrayRef(getProtocolLocArray(), getNumProtocols());\n  }\n\n  void initializeLocal(ASTContext &Context, SourceLocation Loc);\n\n  unsigned getExtraLocalDataSize() const {\n    if (!this->getNumProtocols()) return 0;\n    // When there are protocol qualifers, we have LAngleLoc and RAngleLoc\n    // as well.\n    return (this->getNumProtocols() + 2) * sizeof(SourceLocation) ;\n  }\n\n  unsigned getExtraLocalDataAlignment() const {\n    return alignof(SourceLocation);\n  }\n\n  SourceRange getLocalSourceRange() const {\n    SourceLocation start = getNameLoc();\n    SourceLocation end = getProtocolRAngleLoc();\n    if (end.isInvalid()) return SourceRange(start, start);\n    return SourceRange(start, end);\n  }\n};\n\n/// Wrapper for substituted template type parameters.\nclass SubstTemplateTypeParmTypeLoc :\n    public InheritingConcreteTypeLoc<TypeSpecTypeLoc,\n                                     SubstTemplateTypeParmTypeLoc,\n                                     SubstTemplateTypeParmType> {\n};\n\n  /// Wrapper for substituted template type parameters.\nclass SubstTemplateTypeParmPackTypeLoc :\n    public InheritingConcreteTypeLoc<TypeSpecTypeLoc,\n                                     SubstTemplateTypeParmPackTypeLoc,\n                                     SubstTemplateTypeParmPackType> {\n};\n\nstruct AttributedLocInfo {\n  const Attr *TypeAttr;\n};\n\n/// Type source information for an attributed type.\nclass AttributedTypeLoc : public ConcreteTypeLoc<UnqualTypeLoc,\n                                                 AttributedTypeLoc,\n                                                 AttributedType,\n                                                 AttributedLocInfo> {\npublic:\n  attr::Kind getAttrKind() const {\n    return getTypePtr()->getAttrKind();\n  }\n\n  bool isQualifier() const {\n    return getTypePtr()->isQualifier();\n  }\n\n  /// The modified type, which is generally canonically different from\n  /// the attribute type.\n  ///    int main(int, char**) __attribute__((noreturn))\n  ///    ~~~     ~~~~~~~~~~~~~\n  TypeLoc getModifiedLoc() const {\n    return getInnerTypeLoc();\n  }\n\n  /// The type attribute.\n  const Attr *getAttr() const {\n    return getLocalData()->TypeAttr;\n  }\n  void setAttr(const Attr *A) {\n    getLocalData()->TypeAttr = A;\n  }\n\n  template<typename T> const T *getAttrAs() {\n    return dyn_cast_or_null<T>(getAttr());\n  }\n\n  SourceRange getLocalSourceRange() const;\n\n  void initializeLocal(ASTContext &Context, SourceLocation loc) {\n    setAttr(nullptr);\n  }\n\n  QualType getInnerType() const {\n    return getTypePtr()->getModifiedType();\n  }\n};\n\nstruct ObjCObjectTypeLocInfo {\n  SourceLocation TypeArgsLAngleLoc;\n  SourceLocation TypeArgsRAngleLoc;\n  SourceLocation ProtocolLAngleLoc;\n  SourceLocation ProtocolRAngleLoc;\n  bool HasBaseTypeAsWritten;\n};\n\n// A helper class for defining ObjC TypeLocs that can qualified with\n// protocols.\n//\n// TypeClass basically has to be either ObjCInterfaceType or\n// ObjCObjectPointerType.\nclass ObjCObjectTypeLoc : public ConcreteTypeLoc<UnqualTypeLoc,\n                                                 ObjCObjectTypeLoc,\n                                                 ObjCObjectType,\n                                                 ObjCObjectTypeLocInfo> {\n  // TypeSourceInfo*'s are stored after Info, one for each type argument.\n  TypeSourceInfo **getTypeArgLocArray() const {\n    return (TypeSourceInfo**)this->getExtraLocalData();\n  }\n\n  // SourceLocations are stored after the type argument information, one for\n  // each Protocol.\n  SourceLocation *getProtocolLocArray() const {\n    return (SourceLocation*)(getTypeArgLocArray() + getNumTypeArgs());\n  }\n\npublic:\n  SourceLocation getTypeArgsLAngleLoc() const {\n    return this->getLocalData()->TypeArgsLAngleLoc;\n  }\n\n  void setTypeArgsLAngleLoc(SourceLocation Loc) {\n    this->getLocalData()->TypeArgsLAngleLoc = Loc;\n  }\n\n  SourceLocation getTypeArgsRAngleLoc() const {\n    return this->getLocalData()->TypeArgsRAngleLoc;\n  }\n\n  void setTypeArgsRAngleLoc(SourceLocation Loc) {\n    this->getLocalData()->TypeArgsRAngleLoc = Loc;\n  }\n\n  unsigned getNumTypeArgs() const {\n    return this->getTypePtr()->getTypeArgsAsWritten().size();\n  }\n\n  TypeSourceInfo *getTypeArgTInfo(unsigned i) const {\n    assert(i < getNumTypeArgs() && \"Index is out of bounds!\");\n    return getTypeArgLocArray()[i];\n  }\n\n  void setTypeArgTInfo(unsigned i, TypeSourceInfo *TInfo) {\n    assert(i < getNumTypeArgs() && \"Index is out of bounds!\");\n    getTypeArgLocArray()[i] = TInfo;\n  }\n\n  SourceLocation getProtocolLAngleLoc() const {\n    return this->getLocalData()->ProtocolLAngleLoc;\n  }\n\n  void setProtocolLAngleLoc(SourceLocation Loc) {\n    this->getLocalData()->ProtocolLAngleLoc = Loc;\n  }\n\n  SourceLocation getProtocolRAngleLoc() const {\n    return this->getLocalData()->ProtocolRAngleLoc;\n  }\n\n  void setProtocolRAngleLoc(SourceLocation Loc) {\n    this->getLocalData()->ProtocolRAngleLoc = Loc;\n  }\n\n  unsigned getNumProtocols() const {\n    return this->getTypePtr()->getNumProtocols();\n  }\n\n  SourceLocation getProtocolLoc(unsigned i) const {\n    assert(i < getNumProtocols() && \"Index is out of bounds!\");\n    return getProtocolLocArray()[i];\n  }\n\n  void setProtocolLoc(unsigned i, SourceLocation Loc) {\n    assert(i < getNumProtocols() && \"Index is out of bounds!\");\n    getProtocolLocArray()[i] = Loc;\n  }\n\n  ObjCProtocolDecl *getProtocol(unsigned i) const {\n    assert(i < getNumProtocols() && \"Index is out of bounds!\");\n    return *(this->getTypePtr()->qual_begin() + i);\n  }\n\n\n  ArrayRef<SourceLocation> getProtocolLocs() const {\n    return llvm::makeArrayRef(getProtocolLocArray(), getNumProtocols());\n  }\n\n  bool hasBaseTypeAsWritten() const {\n    return getLocalData()->HasBaseTypeAsWritten;\n  }\n\n  void setHasBaseTypeAsWritten(bool HasBaseType) {\n    getLocalData()->HasBaseTypeAsWritten = HasBaseType;\n  }\n\n  TypeLoc getBaseLoc() const {\n    return getInnerTypeLoc();\n  }\n\n  SourceRange getLocalSourceRange() const {\n    SourceLocation start = getTypeArgsLAngleLoc();\n    if (start.isInvalid())\n      start = getProtocolLAngleLoc();\n    SourceLocation end = getProtocolRAngleLoc();\n    if (end.isInvalid())\n      end = getTypeArgsRAngleLoc();\n    return SourceRange(start, end);\n  }\n\n  void initializeLocal(ASTContext &Context, SourceLocation Loc);\n\n  unsigned getExtraLocalDataSize() const {\n    return this->getNumTypeArgs() * sizeof(TypeSourceInfo *)\n         + this->getNumProtocols() * sizeof(SourceLocation);\n  }\n\n  unsigned getExtraLocalDataAlignment() const {\n    static_assert(alignof(ObjCObjectTypeLoc) >= alignof(TypeSourceInfo *),\n                  \"not enough alignment for tail-allocated data\");\n    return alignof(TypeSourceInfo *);\n  }\n\n  QualType getInnerType() const {\n    return getTypePtr()->getBaseType();\n  }\n};\n\nstruct ObjCInterfaceLocInfo {\n  SourceLocation NameLoc;\n  SourceLocation NameEndLoc;\n};\n\n/// Wrapper for source info for ObjC interfaces.\nclass ObjCInterfaceTypeLoc : public ConcreteTypeLoc<ObjCObjectTypeLoc,\n                                                    ObjCInterfaceTypeLoc,\n                                                    ObjCInterfaceType,\n                                                    ObjCInterfaceLocInfo> {\npublic:\n  ObjCInterfaceDecl *getIFaceDecl() const {\n    return getTypePtr()->getDecl();\n  }\n\n  SourceLocation getNameLoc() const {\n    return getLocalData()->NameLoc;\n  }\n\n  void setNameLoc(SourceLocation Loc) {\n    getLocalData()->NameLoc = Loc;\n  }\n\n  SourceRange getLocalSourceRange() const {\n    return SourceRange(getNameLoc(), getNameEndLoc());\n  }\n\n  SourceLocation getNameEndLoc() const {\n    return getLocalData()->NameEndLoc;\n  }\n\n  void setNameEndLoc(SourceLocation Loc) {\n    getLocalData()->NameEndLoc = Loc;\n  }\n\n  void initializeLocal(ASTContext &Context, SourceLocation Loc) {\n    setNameLoc(Loc);\n    setNameEndLoc(Loc);\n  }\n};\n\nstruct MacroQualifiedLocInfo {\n  SourceLocation ExpansionLoc;\n};\n\nclass MacroQualifiedTypeLoc\n    : public ConcreteTypeLoc<UnqualTypeLoc, MacroQualifiedTypeLoc,\n                             MacroQualifiedType, MacroQualifiedLocInfo> {\npublic:\n  void initializeLocal(ASTContext &Context, SourceLocation Loc) {\n    setExpansionLoc(Loc);\n  }\n\n  TypeLoc getInnerLoc() const { return getInnerTypeLoc(); }\n\n  const IdentifierInfo *getMacroIdentifier() const {\n    return getTypePtr()->getMacroIdentifier();\n  }\n\n  SourceLocation getExpansionLoc() const {\n    return this->getLocalData()->ExpansionLoc;\n  }\n\n  void setExpansionLoc(SourceLocation Loc) {\n    this->getLocalData()->ExpansionLoc = Loc;\n  }\n\n  QualType getInnerType() const { return getTypePtr()->getUnderlyingType(); }\n\n  SourceRange getLocalSourceRange() const {\n    return getInnerLoc().getLocalSourceRange();\n  }\n};\n\nstruct ParenLocInfo {\n  SourceLocation LParenLoc;\n  SourceLocation RParenLoc;\n};\n\nclass ParenTypeLoc\n  : public ConcreteTypeLoc<UnqualTypeLoc, ParenTypeLoc, ParenType,\n                           ParenLocInfo> {\npublic:\n  SourceLocation getLParenLoc() const {\n    return this->getLocalData()->LParenLoc;\n  }\n\n  SourceLocation getRParenLoc() const {\n    return this->getLocalData()->RParenLoc;\n  }\n\n  void setLParenLoc(SourceLocation Loc) {\n    this->getLocalData()->LParenLoc = Loc;\n  }\n\n  void setRParenLoc(SourceLocation Loc) {\n    this->getLocalData()->RParenLoc = Loc;\n  }\n\n  SourceRange getLocalSourceRange() const {\n    return SourceRange(getLParenLoc(), getRParenLoc());\n  }\n\n  void initializeLocal(ASTContext &Context, SourceLocation Loc) {\n    setLParenLoc(Loc);\n    setRParenLoc(Loc);\n  }\n\n  TypeLoc getInnerLoc() const {\n    return getInnerTypeLoc();\n  }\n\n  QualType getInnerType() const {\n    return this->getTypePtr()->getInnerType();\n  }\n};\n\ninline TypeLoc TypeLoc::IgnoreParens() const {\n  if (ParenTypeLoc::isKind(*this))\n    return IgnoreParensImpl(*this);\n  return *this;\n}\n\nstruct AdjustedLocInfo {}; // Nothing.\n\nclass AdjustedTypeLoc : public ConcreteTypeLoc<UnqualTypeLoc, AdjustedTypeLoc,\n                                               AdjustedType, AdjustedLocInfo> {\npublic:\n  TypeLoc getOriginalLoc() const {\n    return getInnerTypeLoc();\n  }\n\n  void initializeLocal(ASTContext &Context, SourceLocation Loc) {\n    // do nothing\n  }\n\n  QualType getInnerType() const {\n    // The inner type is the undecayed type, since that's what we have source\n    // location information for.\n    return getTypePtr()->getOriginalType();\n  }\n\n  SourceRange getLocalSourceRange() const { return {}; }\n\n  unsigned getLocalDataSize() const {\n    // sizeof(AdjustedLocInfo) is 1, but we don't need its address to be unique\n    // anyway.  TypeLocBuilder can't handle data sizes of 1.\n    return 0;  // No data.\n  }\n};\n\n/// Wrapper for source info for pointers decayed from arrays and\n/// functions.\nclass DecayedTypeLoc : public InheritingConcreteTypeLoc<\n                           AdjustedTypeLoc, DecayedTypeLoc, DecayedType> {\n};\n\nstruct PointerLikeLocInfo {\n  SourceLocation StarLoc;\n};\n\n/// A base class for\ntemplate <class Derived, class TypeClass, class LocalData = PointerLikeLocInfo>\nclass PointerLikeTypeLoc : public ConcreteTypeLoc<UnqualTypeLoc, Derived,\n                                                  TypeClass, LocalData> {\npublic:\n  SourceLocation getSigilLoc() const {\n    return this->getLocalData()->StarLoc;\n  }\n\n  void setSigilLoc(SourceLocation Loc) {\n    this->getLocalData()->StarLoc = Loc;\n  }\n\n  TypeLoc getPointeeLoc() const {\n    return this->getInnerTypeLoc();\n  }\n\n  SourceRange getLocalSourceRange() const {\n    return SourceRange(getSigilLoc(), getSigilLoc());\n  }\n\n  void initializeLocal(ASTContext &Context, SourceLocation Loc) {\n    setSigilLoc(Loc);\n  }\n\n  QualType getInnerType() const {\n    return this->getTypePtr()->getPointeeType();\n  }\n};\n\n/// Wrapper for source info for pointers.\nclass PointerTypeLoc : public PointerLikeTypeLoc<PointerTypeLoc,\n                                                 PointerType> {\npublic:\n  SourceLocation getStarLoc() const {\n    return getSigilLoc();\n  }\n\n  void setStarLoc(SourceLocation Loc) {\n    setSigilLoc(Loc);\n  }\n};\n\n/// Wrapper for source info for block pointers.\nclass BlockPointerTypeLoc : public PointerLikeTypeLoc<BlockPointerTypeLoc,\n                                                      BlockPointerType> {\npublic:\n  SourceLocation getCaretLoc() const {\n    return getSigilLoc();\n  }\n\n  void setCaretLoc(SourceLocation Loc) {\n    setSigilLoc(Loc);\n  }\n};\n\nstruct MemberPointerLocInfo : public PointerLikeLocInfo {\n  TypeSourceInfo *ClassTInfo;\n};\n\n/// Wrapper for source info for member pointers.\nclass MemberPointerTypeLoc : public PointerLikeTypeLoc<MemberPointerTypeLoc,\n                                                       MemberPointerType,\n                                                       MemberPointerLocInfo> {\npublic:\n  SourceLocation getStarLoc() const {\n    return getSigilLoc();\n  }\n\n  void setStarLoc(SourceLocation Loc) {\n    setSigilLoc(Loc);\n  }\n\n  const Type *getClass() const {\n    return getTypePtr()->getClass();\n  }\n\n  TypeSourceInfo *getClassTInfo() const {\n    return getLocalData()->ClassTInfo;\n  }\n\n  void setClassTInfo(TypeSourceInfo* TI) {\n    getLocalData()->ClassTInfo = TI;\n  }\n\n  void initializeLocal(ASTContext &Context, SourceLocation Loc) {\n    setSigilLoc(Loc);\n    setClassTInfo(nullptr);\n  }\n\n  SourceRange getLocalSourceRange() const {\n    if (TypeSourceInfo *TI = getClassTInfo())\n      return SourceRange(TI->getTypeLoc().getBeginLoc(), getStarLoc());\n    else\n      return SourceRange(getStarLoc());\n  }\n};\n\n/// Wraps an ObjCPointerType with source location information.\nclass ObjCObjectPointerTypeLoc :\n    public PointerLikeTypeLoc<ObjCObjectPointerTypeLoc,\n                              ObjCObjectPointerType> {\npublic:\n  SourceLocation getStarLoc() const {\n    return getSigilLoc();\n  }\n\n  void setStarLoc(SourceLocation Loc) {\n    setSigilLoc(Loc);\n  }\n};\n\nclass ReferenceTypeLoc : public PointerLikeTypeLoc<ReferenceTypeLoc,\n                                                   ReferenceType> {\npublic:\n  QualType getInnerType() const {\n    return getTypePtr()->getPointeeTypeAsWritten();\n  }\n};\n\nclass LValueReferenceTypeLoc :\n    public InheritingConcreteTypeLoc<ReferenceTypeLoc,\n                                     LValueReferenceTypeLoc,\n                                     LValueReferenceType> {\npublic:\n  SourceLocation getAmpLoc() const {\n    return getSigilLoc();\n  }\n\n  void setAmpLoc(SourceLocation Loc) {\n    setSigilLoc(Loc);\n  }\n};\n\nclass RValueReferenceTypeLoc :\n    public InheritingConcreteTypeLoc<ReferenceTypeLoc,\n                                     RValueReferenceTypeLoc,\n                                     RValueReferenceType> {\npublic:\n  SourceLocation getAmpAmpLoc() const {\n    return getSigilLoc();\n  }\n\n  void setAmpAmpLoc(SourceLocation Loc) {\n    setSigilLoc(Loc);\n  }\n};\n\nstruct FunctionLocInfo {\n  SourceLocation LocalRangeBegin;\n  SourceLocation LParenLoc;\n  SourceLocation RParenLoc;\n  SourceLocation LocalRangeEnd;\n};\n\n/// Wrapper for source info for functions.\nclass FunctionTypeLoc : public ConcreteTypeLoc<UnqualTypeLoc,\n                                               FunctionTypeLoc,\n                                               FunctionType,\n                                               FunctionLocInfo> {\n  bool hasExceptionSpec() const {\n    if (auto *FPT = dyn_cast<FunctionProtoType>(getTypePtr())) {\n      return FPT->hasExceptionSpec();\n    }\n    return false;\n  }\n\n  SourceRange *getExceptionSpecRangePtr() const {\n    assert(hasExceptionSpec() && \"No exception spec range\");\n    // After the Info comes the ParmVarDecl array, and after that comes the\n    // exception specification information.\n    return (SourceRange *)(getParmArray() + getNumParams());\n  }\n\npublic:\n  SourceLocation getLocalRangeBegin() const {\n    return getLocalData()->LocalRangeBegin;\n  }\n\n  void setLocalRangeBegin(SourceLocation L) {\n    getLocalData()->LocalRangeBegin = L;\n  }\n\n  SourceLocation getLocalRangeEnd() const {\n    return getLocalData()->LocalRangeEnd;\n  }\n\n  void setLocalRangeEnd(SourceLocation L) {\n    getLocalData()->LocalRangeEnd = L;\n  }\n\n  SourceLocation getLParenLoc() const {\n    return this->getLocalData()->LParenLoc;\n  }\n\n  void setLParenLoc(SourceLocation Loc) {\n    this->getLocalData()->LParenLoc = Loc;\n  }\n\n  SourceLocation getRParenLoc() const {\n    return this->getLocalData()->RParenLoc;\n  }\n\n  void setRParenLoc(SourceLocation Loc) {\n    this->getLocalData()->RParenLoc = Loc;\n  }\n\n  SourceRange getParensRange() const {\n    return SourceRange(getLParenLoc(), getRParenLoc());\n  }\n\n  SourceRange getExceptionSpecRange() const {\n    if (hasExceptionSpec())\n      return *getExceptionSpecRangePtr();\n    return {};\n  }\n\n  void setExceptionSpecRange(SourceRange R) {\n    if (hasExceptionSpec())\n      *getExceptionSpecRangePtr() = R;\n  }\n\n  ArrayRef<ParmVarDecl *> getParams() const {\n    return llvm::makeArrayRef(getParmArray(), getNumParams());\n  }\n\n  // ParmVarDecls* are stored after Info, one for each parameter.\n  ParmVarDecl **getParmArray() const {\n    return (ParmVarDecl**) getExtraLocalData();\n  }\n\n  unsigned getNumParams() const {\n    if (isa<FunctionNoProtoType>(getTypePtr()))\n      return 0;\n    return cast<FunctionProtoType>(getTypePtr())->getNumParams();\n  }\n\n  ParmVarDecl *getParam(unsigned i) const { return getParmArray()[i]; }\n  void setParam(unsigned i, ParmVarDecl *VD) { getParmArray()[i] = VD; }\n\n  TypeLoc getReturnLoc() const {\n    return getInnerTypeLoc();\n  }\n\n  SourceRange getLocalSourceRange() const {\n    return SourceRange(getLocalRangeBegin(), getLocalRangeEnd());\n  }\n\n  void initializeLocal(ASTContext &Context, SourceLocation Loc) {\n    setLocalRangeBegin(Loc);\n    setLParenLoc(Loc);\n    setRParenLoc(Loc);\n    setLocalRangeEnd(Loc);\n    for (unsigned i = 0, e = getNumParams(); i != e; ++i)\n      setParam(i, nullptr);\n    if (hasExceptionSpec())\n      setExceptionSpecRange(Loc);\n  }\n\n  /// Returns the size of the type source info data block that is\n  /// specific to this type.\n  unsigned getExtraLocalDataSize() const {\n    unsigned ExceptSpecSize = hasExceptionSpec() ? sizeof(SourceRange) : 0;\n    return (getNumParams() * sizeof(ParmVarDecl *)) + ExceptSpecSize;\n  }\n\n  unsigned getExtraLocalDataAlignment() const { return alignof(ParmVarDecl *); }\n\n  QualType getInnerType() const { return getTypePtr()->getReturnType(); }\n};\n\nclass FunctionProtoTypeLoc :\n    public InheritingConcreteTypeLoc<FunctionTypeLoc,\n                                     FunctionProtoTypeLoc,\n                                     FunctionProtoType> {\n};\n\nclass FunctionNoProtoTypeLoc :\n    public InheritingConcreteTypeLoc<FunctionTypeLoc,\n                                     FunctionNoProtoTypeLoc,\n                                     FunctionNoProtoType> {\n};\n\nstruct ArrayLocInfo {\n  SourceLocation LBracketLoc, RBracketLoc;\n  Expr *Size;\n};\n\n/// Wrapper for source info for arrays.\nclass ArrayTypeLoc : public ConcreteTypeLoc<UnqualTypeLoc,\n                                            ArrayTypeLoc,\n                                            ArrayType,\n                                            ArrayLocInfo> {\npublic:\n  SourceLocation getLBracketLoc() const {\n    return getLocalData()->LBracketLoc;\n  }\n\n  void setLBracketLoc(SourceLocation Loc) {\n    getLocalData()->LBracketLoc = Loc;\n  }\n\n  SourceLocation getRBracketLoc() const {\n    return getLocalData()->RBracketLoc;\n  }\n\n  void setRBracketLoc(SourceLocation Loc) {\n    getLocalData()->RBracketLoc = Loc;\n  }\n\n  SourceRange getBracketsRange() const {\n    return SourceRange(getLBracketLoc(), getRBracketLoc());\n  }\n\n  Expr *getSizeExpr() const {\n    return getLocalData()->Size;\n  }\n\n  void setSizeExpr(Expr *Size) {\n    getLocalData()->Size = Size;\n  }\n\n  TypeLoc getElementLoc() const {\n    return getInnerTypeLoc();\n  }\n\n  SourceRange getLocalSourceRange() const {\n    return SourceRange(getLBracketLoc(), getRBracketLoc());\n  }\n\n  void initializeLocal(ASTContext &Context, SourceLocation Loc) {\n    setLBracketLoc(Loc);\n    setRBracketLoc(Loc);\n    setSizeExpr(nullptr);\n  }\n\n  QualType getInnerType() const { return getTypePtr()->getElementType(); }\n};\n\nclass ConstantArrayTypeLoc :\n    public InheritingConcreteTypeLoc<ArrayTypeLoc,\n                                     ConstantArrayTypeLoc,\n                                     ConstantArrayType> {\n};\n\nclass IncompleteArrayTypeLoc :\n    public InheritingConcreteTypeLoc<ArrayTypeLoc,\n                                     IncompleteArrayTypeLoc,\n                                     IncompleteArrayType> {\n};\n\nclass DependentSizedArrayTypeLoc :\n    public InheritingConcreteTypeLoc<ArrayTypeLoc,\n                                     DependentSizedArrayTypeLoc,\n                                     DependentSizedArrayType> {\npublic:\n  void initializeLocal(ASTContext &Context, SourceLocation Loc) {\n    ArrayTypeLoc::initializeLocal(Context, Loc);\n    setSizeExpr(getTypePtr()->getSizeExpr());\n  }\n};\n\nclass VariableArrayTypeLoc :\n    public InheritingConcreteTypeLoc<ArrayTypeLoc,\n                                     VariableArrayTypeLoc,\n                                     VariableArrayType> {\n};\n\n// Location information for a TemplateName.  Rudimentary for now.\nstruct TemplateNameLocInfo {\n  SourceLocation NameLoc;\n};\n\nstruct TemplateSpecializationLocInfo : TemplateNameLocInfo {\n  SourceLocation TemplateKWLoc;\n  SourceLocation LAngleLoc;\n  SourceLocation RAngleLoc;\n};\n\nclass TemplateSpecializationTypeLoc :\n    public ConcreteTypeLoc<UnqualTypeLoc,\n                           TemplateSpecializationTypeLoc,\n                           TemplateSpecializationType,\n                           TemplateSpecializationLocInfo> {\npublic:\n  SourceLocation getTemplateKeywordLoc() const {\n    return getLocalData()->TemplateKWLoc;\n  }\n\n  void setTemplateKeywordLoc(SourceLocation Loc) {\n    getLocalData()->TemplateKWLoc = Loc;\n  }\n\n  SourceLocation getLAngleLoc() const {\n    return getLocalData()->LAngleLoc;\n  }\n\n  void setLAngleLoc(SourceLocation Loc) {\n    getLocalData()->LAngleLoc = Loc;\n  }\n\n  SourceLocation getRAngleLoc() const {\n    return getLocalData()->RAngleLoc;\n  }\n\n  void setRAngleLoc(SourceLocation Loc) {\n    getLocalData()->RAngleLoc = Loc;\n  }\n\n  unsigned getNumArgs() const {\n    return getTypePtr()->getNumArgs();\n  }\n\n  void setArgLocInfo(unsigned i, TemplateArgumentLocInfo AI) {\n    getArgInfos()[i] = AI;\n  }\n\n  TemplateArgumentLocInfo getArgLocInfo(unsigned i) const {\n    return getArgInfos()[i];\n  }\n\n  TemplateArgumentLoc getArgLoc(unsigned i) const {\n    return TemplateArgumentLoc(getTypePtr()->getArg(i), getArgLocInfo(i));\n  }\n\n  SourceLocation getTemplateNameLoc() const {\n    return getLocalData()->NameLoc;\n  }\n\n  void setTemplateNameLoc(SourceLocation Loc) {\n    getLocalData()->NameLoc = Loc;\n  }\n\n  /// - Copy the location information from the given info.\n  void copy(TemplateSpecializationTypeLoc Loc) {\n    unsigned size = getFullDataSize();\n    assert(size == Loc.getFullDataSize());\n\n    // We're potentially copying Expr references here.  We don't\n    // bother retaining them because TypeSourceInfos live forever, so\n    // as long as the Expr was retained when originally written into\n    // the TypeLoc, we're okay.\n    memcpy(Data, Loc.Data, size);\n  }\n\n  SourceRange getLocalSourceRange() const {\n    if (getTemplateKeywordLoc().isValid())\n      return SourceRange(getTemplateKeywordLoc(), getRAngleLoc());\n    else\n      return SourceRange(getTemplateNameLoc(), getRAngleLoc());\n  }\n\n  void initializeLocal(ASTContext &Context, SourceLocation Loc) {\n    setTemplateKeywordLoc(Loc);\n    setTemplateNameLoc(Loc);\n    setLAngleLoc(Loc);\n    setRAngleLoc(Loc);\n    initializeArgLocs(Context, getNumArgs(), getTypePtr()->getArgs(),\n                      getArgInfos(), Loc);\n  }\n\n  static void initializeArgLocs(ASTContext &Context, unsigned NumArgs,\n                                const TemplateArgument *Args,\n                                TemplateArgumentLocInfo *ArgInfos,\n                                SourceLocation Loc);\n\n  unsigned getExtraLocalDataSize() const {\n    return getNumArgs() * sizeof(TemplateArgumentLocInfo);\n  }\n\n  unsigned getExtraLocalDataAlignment() const {\n    return alignof(TemplateArgumentLocInfo);\n  }\n\nprivate:\n  TemplateArgumentLocInfo *getArgInfos() const {\n    return static_cast<TemplateArgumentLocInfo*>(getExtraLocalData());\n  }\n};\n\nstruct DependentAddressSpaceLocInfo {\n  Expr *ExprOperand;\n  SourceRange OperandParens;\n  SourceLocation AttrLoc;\n};\n\nclass DependentAddressSpaceTypeLoc\n    : public ConcreteTypeLoc<UnqualTypeLoc,\n                             DependentAddressSpaceTypeLoc,\n                             DependentAddressSpaceType,\n                             DependentAddressSpaceLocInfo> {\npublic:\n  /// The location of the attribute name, i.e.\n  ///    int * __attribute__((address_space(11)))\n  ///                         ^~~~~~~~~~~~~\n  SourceLocation getAttrNameLoc() const {\n    return getLocalData()->AttrLoc;\n  }\n  void setAttrNameLoc(SourceLocation loc) {\n    getLocalData()->AttrLoc = loc;\n  }\n\n  /// The attribute's expression operand, if it has one.\n  ///    int * __attribute__((address_space(11)))\n  ///                                       ^~\n  Expr *getAttrExprOperand() const {\n    return getLocalData()->ExprOperand;\n  }\n  void setAttrExprOperand(Expr *e) {\n    getLocalData()->ExprOperand = e;\n  }\n\n  /// The location of the parentheses around the operand, if there is\n  /// an operand.\n  ///    int * __attribute__((address_space(11)))\n  ///                                      ^  ^\n  SourceRange getAttrOperandParensRange() const {\n    return getLocalData()->OperandParens;\n  }\n  void setAttrOperandParensRange(SourceRange range) {\n    getLocalData()->OperandParens = range;\n  }\n\n  SourceRange getLocalSourceRange() const {\n    SourceRange range(getAttrNameLoc());\n    range.setEnd(getAttrOperandParensRange().getEnd());\n    return range;\n  }\n\n  ///  Returns the type before the address space attribute application\n  ///  area.\n  ///    int * __attribute__((address_space(11))) *\n  ///    ^   ^\n  QualType getInnerType() const {\n    return this->getTypePtr()->getPointeeType();\n  }\n\n  TypeLoc getPointeeTypeLoc() const {\n    return this->getInnerTypeLoc();\n  }\n\n  void initializeLocal(ASTContext &Context, SourceLocation loc) {\n    setAttrNameLoc(loc);\n    setAttrOperandParensRange(loc);\n    setAttrOperandParensRange(SourceRange(loc));\n    setAttrExprOperand(getTypePtr()->getAddrSpaceExpr());\n  }\n};\n\n//===----------------------------------------------------------------------===//\n//\n//  All of these need proper implementations.\n//\n//===----------------------------------------------------------------------===//\n\n// FIXME: size expression and attribute locations (or keyword if we\n// ever fully support altivec syntax).\nstruct VectorTypeLocInfo {\n  SourceLocation NameLoc;\n};\n\nclass VectorTypeLoc : public ConcreteTypeLoc<UnqualTypeLoc, VectorTypeLoc,\n                                             VectorType, VectorTypeLocInfo> {\npublic:\n  SourceLocation getNameLoc() const { return this->getLocalData()->NameLoc; }\n\n  void setNameLoc(SourceLocation Loc) { this->getLocalData()->NameLoc = Loc; }\n\n  SourceRange getLocalSourceRange() const {\n    return SourceRange(getNameLoc(), getNameLoc());\n  }\n\n  void initializeLocal(ASTContext &Context, SourceLocation Loc) {\n    setNameLoc(Loc);\n  }\n\n  TypeLoc getElementLoc() const { return getInnerTypeLoc(); }\n\n  QualType getInnerType() const { return this->getTypePtr()->getElementType(); }\n};\n\n// FIXME: size expression and attribute locations (or keyword if we\n// ever fully support altivec syntax).\nclass DependentVectorTypeLoc\n    : public ConcreteTypeLoc<UnqualTypeLoc, DependentVectorTypeLoc,\n                             DependentVectorType, VectorTypeLocInfo> {\npublic:\n  SourceLocation getNameLoc() const { return this->getLocalData()->NameLoc; }\n\n  void setNameLoc(SourceLocation Loc) { this->getLocalData()->NameLoc = Loc; }\n\n  SourceRange getLocalSourceRange() const {\n    return SourceRange(getNameLoc(), getNameLoc());\n  }\n\n  void initializeLocal(ASTContext &Context, SourceLocation Loc) {\n    setNameLoc(Loc);\n  }\n\n  TypeLoc getElementLoc() const { return getInnerTypeLoc(); }\n\n  QualType getInnerType() const { return this->getTypePtr()->getElementType(); }\n};\n\n// FIXME: size expression and attribute locations.\nclass ExtVectorTypeLoc\n    : public InheritingConcreteTypeLoc<VectorTypeLoc, ExtVectorTypeLoc,\n                                       ExtVectorType> {};\n\n// FIXME: attribute locations.\n// For some reason, this isn't a subtype of VectorType.\nclass DependentSizedExtVectorTypeLoc\n    : public ConcreteTypeLoc<UnqualTypeLoc, DependentSizedExtVectorTypeLoc,\n                             DependentSizedExtVectorType, VectorTypeLocInfo> {\npublic:\n  SourceLocation getNameLoc() const { return this->getLocalData()->NameLoc; }\n\n  void setNameLoc(SourceLocation Loc) { this->getLocalData()->NameLoc = Loc; }\n\n  SourceRange getLocalSourceRange() const {\n    return SourceRange(getNameLoc(), getNameLoc());\n  }\n\n  void initializeLocal(ASTContext &Context, SourceLocation Loc) {\n    setNameLoc(Loc);\n  }\n\n  TypeLoc getElementLoc() const { return getInnerTypeLoc(); }\n\n  QualType getInnerType() const { return this->getTypePtr()->getElementType(); }\n};\n\nstruct MatrixTypeLocInfo {\n  SourceLocation AttrLoc;\n  SourceRange OperandParens;\n  Expr *RowOperand;\n  Expr *ColumnOperand;\n};\n\nclass MatrixTypeLoc : public ConcreteTypeLoc<UnqualTypeLoc, MatrixTypeLoc,\n                                             MatrixType, MatrixTypeLocInfo> {\npublic:\n  /// The location of the attribute name, i.e.\n  ///    float __attribute__((matrix_type(4, 2)))\n  ///                         ^~~~~~~~~~~~~~~~~\n  SourceLocation getAttrNameLoc() const { return getLocalData()->AttrLoc; }\n  void setAttrNameLoc(SourceLocation loc) { getLocalData()->AttrLoc = loc; }\n\n  /// The attribute's row operand, if it has one.\n  ///    float __attribute__((matrix_type(4, 2)))\n  ///                                     ^\n  Expr *getAttrRowOperand() const { return getLocalData()->RowOperand; }\n  void setAttrRowOperand(Expr *e) { getLocalData()->RowOperand = e; }\n\n  /// The attribute's column operand, if it has one.\n  ///    float __attribute__((matrix_type(4, 2)))\n  ///                                        ^\n  Expr *getAttrColumnOperand() const { return getLocalData()->ColumnOperand; }\n  void setAttrColumnOperand(Expr *e) { getLocalData()->ColumnOperand = e; }\n\n  /// The location of the parentheses around the operand, if there is\n  /// an operand.\n  ///    float __attribute__((matrix_type(4, 2)))\n  ///                                    ^    ^\n  SourceRange getAttrOperandParensRange() const {\n    return getLocalData()->OperandParens;\n  }\n  void setAttrOperandParensRange(SourceRange range) {\n    getLocalData()->OperandParens = range;\n  }\n\n  SourceRange getLocalSourceRange() const {\n    SourceRange range(getAttrNameLoc());\n    range.setEnd(getAttrOperandParensRange().getEnd());\n    return range;\n  }\n\n  void initializeLocal(ASTContext &Context, SourceLocation loc) {\n    setAttrNameLoc(loc);\n    setAttrOperandParensRange(loc);\n    setAttrRowOperand(nullptr);\n    setAttrColumnOperand(nullptr);\n  }\n};\n\nclass ConstantMatrixTypeLoc\n    : public InheritingConcreteTypeLoc<MatrixTypeLoc, ConstantMatrixTypeLoc,\n                                       ConstantMatrixType> {};\n\nclass DependentSizedMatrixTypeLoc\n    : public InheritingConcreteTypeLoc<MatrixTypeLoc,\n                                       DependentSizedMatrixTypeLoc,\n                                       DependentSizedMatrixType> {};\n\n// FIXME: location of the '_Complex' keyword.\nclass ComplexTypeLoc : public InheritingConcreteTypeLoc<TypeSpecTypeLoc,\n                                                        ComplexTypeLoc,\n                                                        ComplexType> {\n};\n\nstruct TypeofLocInfo {\n  SourceLocation TypeofLoc;\n  SourceLocation LParenLoc;\n  SourceLocation RParenLoc;\n};\n\nstruct TypeOfExprTypeLocInfo : public TypeofLocInfo {\n};\n\nstruct TypeOfTypeLocInfo : public TypeofLocInfo {\n  TypeSourceInfo* UnderlyingTInfo;\n};\n\ntemplate <class Derived, class TypeClass, class LocalData = TypeofLocInfo>\nclass TypeofLikeTypeLoc\n  : public ConcreteTypeLoc<UnqualTypeLoc, Derived, TypeClass, LocalData> {\npublic:\n  SourceLocation getTypeofLoc() const {\n    return this->getLocalData()->TypeofLoc;\n  }\n\n  void setTypeofLoc(SourceLocation Loc) {\n    this->getLocalData()->TypeofLoc = Loc;\n  }\n\n  SourceLocation getLParenLoc() const {\n    return this->getLocalData()->LParenLoc;\n  }\n\n  void setLParenLoc(SourceLocation Loc) {\n    this->getLocalData()->LParenLoc = Loc;\n  }\n\n  SourceLocation getRParenLoc() const {\n    return this->getLocalData()->RParenLoc;\n  }\n\n  void setRParenLoc(SourceLocation Loc) {\n    this->getLocalData()->RParenLoc = Loc;\n  }\n\n  SourceRange getParensRange() const {\n    return SourceRange(getLParenLoc(), getRParenLoc());\n  }\n\n  void setParensRange(SourceRange range) {\n      setLParenLoc(range.getBegin());\n      setRParenLoc(range.getEnd());\n  }\n\n  SourceRange getLocalSourceRange() const {\n    return SourceRange(getTypeofLoc(), getRParenLoc());\n  }\n\n  void initializeLocal(ASTContext &Context, SourceLocation Loc) {\n    setTypeofLoc(Loc);\n    setLParenLoc(Loc);\n    setRParenLoc(Loc);\n  }\n};\n\nclass TypeOfExprTypeLoc : public TypeofLikeTypeLoc<TypeOfExprTypeLoc,\n                                                   TypeOfExprType,\n                                                   TypeOfExprTypeLocInfo> {\npublic:\n  Expr* getUnderlyingExpr() const {\n    return getTypePtr()->getUnderlyingExpr();\n  }\n\n  // Reimplemented to account for GNU/C++ extension\n  //     typeof unary-expression\n  // where there are no parentheses.\n  SourceRange getLocalSourceRange() const;\n};\n\nclass TypeOfTypeLoc\n  : public TypeofLikeTypeLoc<TypeOfTypeLoc, TypeOfType, TypeOfTypeLocInfo> {\npublic:\n  QualType getUnderlyingType() const {\n    return this->getTypePtr()->getUnderlyingType();\n  }\n\n  TypeSourceInfo* getUnderlyingTInfo() const {\n    return this->getLocalData()->UnderlyingTInfo;\n  }\n\n  void setUnderlyingTInfo(TypeSourceInfo* TI) const {\n    this->getLocalData()->UnderlyingTInfo = TI;\n  }\n\n  void initializeLocal(ASTContext &Context, SourceLocation Loc);\n};\n\n// FIXME: location of the 'decltype' and parens.\nclass DecltypeTypeLoc : public InheritingConcreteTypeLoc<TypeSpecTypeLoc,\n                                                         DecltypeTypeLoc,\n                                                         DecltypeType> {\npublic:\n  Expr *getUnderlyingExpr() const { return getTypePtr()->getUnderlyingExpr(); }\n};\n\nstruct UnaryTransformTypeLocInfo {\n  // FIXME: While there's only one unary transform right now, future ones may\n  // need different representations\n  SourceLocation KWLoc, LParenLoc, RParenLoc;\n  TypeSourceInfo *UnderlyingTInfo;\n};\n\nclass UnaryTransformTypeLoc : public ConcreteTypeLoc<UnqualTypeLoc,\n                                                    UnaryTransformTypeLoc,\n                                                    UnaryTransformType,\n                                                    UnaryTransformTypeLocInfo> {\npublic:\n  SourceLocation getKWLoc() const { return getLocalData()->KWLoc; }\n  void setKWLoc(SourceLocation Loc) { getLocalData()->KWLoc = Loc; }\n\n  SourceLocation getLParenLoc() const { return getLocalData()->LParenLoc; }\n  void setLParenLoc(SourceLocation Loc) { getLocalData()->LParenLoc = Loc; }\n\n  SourceLocation getRParenLoc() const { return getLocalData()->RParenLoc; }\n  void setRParenLoc(SourceLocation Loc) { getLocalData()->RParenLoc = Loc; }\n\n  TypeSourceInfo* getUnderlyingTInfo() const {\n    return getLocalData()->UnderlyingTInfo;\n  }\n\n  void setUnderlyingTInfo(TypeSourceInfo *TInfo) {\n    getLocalData()->UnderlyingTInfo = TInfo;\n  }\n\n  SourceRange getLocalSourceRange() const {\n    return SourceRange(getKWLoc(), getRParenLoc());\n  }\n\n  SourceRange getParensRange() const {\n    return SourceRange(getLParenLoc(), getRParenLoc());\n  }\n\n  void setParensRange(SourceRange Range) {\n    setLParenLoc(Range.getBegin());\n    setRParenLoc(Range.getEnd());\n  }\n\n  void initializeLocal(ASTContext &Context, SourceLocation Loc);\n};\n\nclass DeducedTypeLoc\n    : public InheritingConcreteTypeLoc<TypeSpecTypeLoc, DeducedTypeLoc,\n                                       DeducedType> {};\n\nstruct AutoTypeLocInfo : TypeSpecLocInfo {\n  NestedNameSpecifierLoc NestedNameSpec;\n  SourceLocation TemplateKWLoc;\n  SourceLocation ConceptNameLoc;\n  NamedDecl *FoundDecl;\n  SourceLocation LAngleLoc;\n  SourceLocation RAngleLoc;\n};\n\nclass AutoTypeLoc\n    : public ConcreteTypeLoc<DeducedTypeLoc,\n                             AutoTypeLoc,\n                             AutoType,\n                             AutoTypeLocInfo> {\npublic:\n  AutoTypeKeyword getAutoKeyword() const {\n    return getTypePtr()->getKeyword();\n  }\n\n  bool isConstrained() const {\n    return getTypePtr()->isConstrained();\n  }\n\n  const NestedNameSpecifierLoc &getNestedNameSpecifierLoc() const {\n    return getLocalData()->NestedNameSpec;\n  }\n\n  void setNestedNameSpecifierLoc(NestedNameSpecifierLoc NNS) {\n    getLocalData()->NestedNameSpec = NNS;\n  }\n\n  SourceLocation getTemplateKWLoc() const {\n    return getLocalData()->TemplateKWLoc;\n  }\n\n  void setTemplateKWLoc(SourceLocation Loc) {\n    getLocalData()->TemplateKWLoc = Loc;\n  }\n\n  SourceLocation getConceptNameLoc() const {\n    return getLocalData()->ConceptNameLoc;\n  }\n\n  void setConceptNameLoc(SourceLocation Loc) {\n    getLocalData()->ConceptNameLoc = Loc;\n  }\n\n  NamedDecl *getFoundDecl() const {\n    return getLocalData()->FoundDecl;\n  }\n\n  void setFoundDecl(NamedDecl *D) {\n    getLocalData()->FoundDecl = D;\n  }\n\n  ConceptDecl *getNamedConcept() const {\n    return getTypePtr()->getTypeConstraintConcept();\n  }\n\n  DeclarationNameInfo getConceptNameInfo() const;\n\n  bool hasExplicitTemplateArgs() const {\n    return getLocalData()->LAngleLoc.isValid();\n  }\n\n  SourceLocation getLAngleLoc() const {\n    return this->getLocalData()->LAngleLoc;\n  }\n\n  void setLAngleLoc(SourceLocation Loc) {\n    this->getLocalData()->LAngleLoc = Loc;\n  }\n\n  SourceLocation getRAngleLoc() const {\n    return this->getLocalData()->RAngleLoc;\n  }\n\n  void setRAngleLoc(SourceLocation Loc) {\n    this->getLocalData()->RAngleLoc = Loc;\n  }\n\n  unsigned getNumArgs() const {\n    return getTypePtr()->getNumArgs();\n  }\n\n  void setArgLocInfo(unsigned i, TemplateArgumentLocInfo AI) {\n    getArgInfos()[i] = AI;\n  }\n\n  TemplateArgumentLocInfo getArgLocInfo(unsigned i) const {\n    return getArgInfos()[i];\n  }\n\n  TemplateArgumentLoc getArgLoc(unsigned i) const {\n    return TemplateArgumentLoc(getTypePtr()->getTypeConstraintArguments()[i],\n                               getArgLocInfo(i));\n  }\n\n  SourceRange getLocalSourceRange() const {\n    return{\n        isConstrained()\n          ? (getNestedNameSpecifierLoc()\n               ? getNestedNameSpecifierLoc().getBeginLoc()\n               : (getTemplateKWLoc().isValid()\n                  ? getTemplateKWLoc()\n                  : getConceptNameLoc()))\n          : getNameLoc(),\n        getNameLoc()\n    };\n  }\n\n  void copy(AutoTypeLoc Loc) {\n    unsigned size = getFullDataSize();\n    assert(size == Loc.getFullDataSize());\n    memcpy(Data, Loc.Data, size);\n  }\n\n  void initializeLocal(ASTContext &Context, SourceLocation Loc);\n\n  unsigned getExtraLocalDataSize() const {\n    return getNumArgs() * sizeof(TemplateArgumentLocInfo);\n  }\n\n  unsigned getExtraLocalDataAlignment() const {\n    return alignof(TemplateArgumentLocInfo);\n  }\n\nprivate:\n  TemplateArgumentLocInfo *getArgInfos() const {\n    return static_cast<TemplateArgumentLocInfo*>(getExtraLocalData());\n  }\n};\n\nclass DeducedTemplateSpecializationTypeLoc\n    : public InheritingConcreteTypeLoc<DeducedTypeLoc,\n                                       DeducedTemplateSpecializationTypeLoc,\n                                       DeducedTemplateSpecializationType> {\npublic:\n  SourceLocation getTemplateNameLoc() const {\n    return getNameLoc();\n  }\n\n  void setTemplateNameLoc(SourceLocation Loc) {\n    setNameLoc(Loc);\n  }\n};\n\nstruct ElaboratedLocInfo {\n  SourceLocation ElaboratedKWLoc;\n\n  /// Data associated with the nested-name-specifier location.\n  void *QualifierData;\n};\n\nclass ElaboratedTypeLoc : public ConcreteTypeLoc<UnqualTypeLoc,\n                                                 ElaboratedTypeLoc,\n                                                 ElaboratedType,\n                                                 ElaboratedLocInfo> {\npublic:\n  SourceLocation getElaboratedKeywordLoc() const {\n    return this->getLocalData()->ElaboratedKWLoc;\n  }\n\n  void setElaboratedKeywordLoc(SourceLocation Loc) {\n    this->getLocalData()->ElaboratedKWLoc = Loc;\n  }\n\n  NestedNameSpecifierLoc getQualifierLoc() const {\n    return NestedNameSpecifierLoc(getTypePtr()->getQualifier(),\n                                  getLocalData()->QualifierData);\n  }\n\n  void setQualifierLoc(NestedNameSpecifierLoc QualifierLoc) {\n    assert(QualifierLoc.getNestedNameSpecifier()\n                                            == getTypePtr()->getQualifier() &&\n           \"Inconsistent nested-name-specifier pointer\");\n    getLocalData()->QualifierData = QualifierLoc.getOpaqueData();\n  }\n\n  SourceRange getLocalSourceRange() const {\n    if (getElaboratedKeywordLoc().isValid())\n      if (getQualifierLoc())\n        return SourceRange(getElaboratedKeywordLoc(),\n                           getQualifierLoc().getEndLoc());\n      else\n        return SourceRange(getElaboratedKeywordLoc());\n    else\n      return getQualifierLoc().getSourceRange();\n  }\n\n  void initializeLocal(ASTContext &Context, SourceLocation Loc);\n\n  TypeLoc getNamedTypeLoc() const {\n    return getInnerTypeLoc();\n  }\n\n  QualType getInnerType() const {\n    return getTypePtr()->getNamedType();\n  }\n\n  void copy(ElaboratedTypeLoc Loc) {\n    unsigned size = getFullDataSize();\n    assert(size == Loc.getFullDataSize());\n    memcpy(Data, Loc.Data, size);\n  }\n};\n\n// This is exactly the structure of an ElaboratedTypeLoc whose inner\n// type is some sort of TypeDeclTypeLoc.\nstruct DependentNameLocInfo : ElaboratedLocInfo {\n  SourceLocation NameLoc;\n};\n\nclass DependentNameTypeLoc : public ConcreteTypeLoc<UnqualTypeLoc,\n                                                    DependentNameTypeLoc,\n                                                    DependentNameType,\n                                                    DependentNameLocInfo> {\npublic:\n  SourceLocation getElaboratedKeywordLoc() const {\n    return this->getLocalData()->ElaboratedKWLoc;\n  }\n\n  void setElaboratedKeywordLoc(SourceLocation Loc) {\n    this->getLocalData()->ElaboratedKWLoc = Loc;\n  }\n\n  NestedNameSpecifierLoc getQualifierLoc() const {\n    return NestedNameSpecifierLoc(getTypePtr()->getQualifier(),\n                                  getLocalData()->QualifierData);\n  }\n\n  void setQualifierLoc(NestedNameSpecifierLoc QualifierLoc) {\n    assert(QualifierLoc.getNestedNameSpecifier()\n                                            == getTypePtr()->getQualifier() &&\n           \"Inconsistent nested-name-specifier pointer\");\n    getLocalData()->QualifierData = QualifierLoc.getOpaqueData();\n  }\n\n  SourceLocation getNameLoc() const {\n    return this->getLocalData()->NameLoc;\n  }\n\n  void setNameLoc(SourceLocation Loc) {\n    this->getLocalData()->NameLoc = Loc;\n  }\n\n  SourceRange getLocalSourceRange() const {\n    if (getElaboratedKeywordLoc().isValid())\n      return SourceRange(getElaboratedKeywordLoc(), getNameLoc());\n    else\n      return SourceRange(getQualifierLoc().getBeginLoc(), getNameLoc());\n  }\n\n  void copy(DependentNameTypeLoc Loc) {\n    unsigned size = getFullDataSize();\n    assert(size == Loc.getFullDataSize());\n    memcpy(Data, Loc.Data, size);\n  }\n\n  void initializeLocal(ASTContext &Context, SourceLocation Loc);\n};\n\nstruct DependentTemplateSpecializationLocInfo : DependentNameLocInfo {\n  SourceLocation TemplateKWLoc;\n  SourceLocation LAngleLoc;\n  SourceLocation RAngleLoc;\n  // followed by a TemplateArgumentLocInfo[]\n};\n\nclass DependentTemplateSpecializationTypeLoc :\n    public ConcreteTypeLoc<UnqualTypeLoc,\n                           DependentTemplateSpecializationTypeLoc,\n                           DependentTemplateSpecializationType,\n                           DependentTemplateSpecializationLocInfo> {\npublic:\n  SourceLocation getElaboratedKeywordLoc() const {\n    return this->getLocalData()->ElaboratedKWLoc;\n  }\n\n  void setElaboratedKeywordLoc(SourceLocation Loc) {\n    this->getLocalData()->ElaboratedKWLoc = Loc;\n  }\n\n  NestedNameSpecifierLoc getQualifierLoc() const {\n    if (!getLocalData()->QualifierData)\n      return NestedNameSpecifierLoc();\n\n    return NestedNameSpecifierLoc(getTypePtr()->getQualifier(),\n                                  getLocalData()->QualifierData);\n  }\n\n  void setQualifierLoc(NestedNameSpecifierLoc QualifierLoc) {\n    if (!QualifierLoc) {\n      // Even if we have a nested-name-specifier in the dependent\n      // template specialization type, we won't record the nested-name-specifier\n      // location information when this type-source location information is\n      // part of a nested-name-specifier.\n      getLocalData()->QualifierData = nullptr;\n      return;\n    }\n\n    assert(QualifierLoc.getNestedNameSpecifier()\n                                        == getTypePtr()->getQualifier() &&\n           \"Inconsistent nested-name-specifier pointer\");\n    getLocalData()->QualifierData = QualifierLoc.getOpaqueData();\n  }\n\n  SourceLocation getTemplateKeywordLoc() const {\n    return getLocalData()->TemplateKWLoc;\n  }\n\n  void setTemplateKeywordLoc(SourceLocation Loc) {\n    getLocalData()->TemplateKWLoc = Loc;\n  }\n\n  SourceLocation getTemplateNameLoc() const {\n    return this->getLocalData()->NameLoc;\n  }\n\n  void setTemplateNameLoc(SourceLocation Loc) {\n    this->getLocalData()->NameLoc = Loc;\n  }\n\n  SourceLocation getLAngleLoc() const {\n    return this->getLocalData()->LAngleLoc;\n  }\n\n  void setLAngleLoc(SourceLocation Loc) {\n    this->getLocalData()->LAngleLoc = Loc;\n  }\n\n  SourceLocation getRAngleLoc() const {\n    return this->getLocalData()->RAngleLoc;\n  }\n\n  void setRAngleLoc(SourceLocation Loc) {\n    this->getLocalData()->RAngleLoc = Loc;\n  }\n\n  unsigned getNumArgs() const {\n    return getTypePtr()->getNumArgs();\n  }\n\n  void setArgLocInfo(unsigned i, TemplateArgumentLocInfo AI) {\n    getArgInfos()[i] = AI;\n  }\n\n  TemplateArgumentLocInfo getArgLocInfo(unsigned i) const {\n    return getArgInfos()[i];\n  }\n\n  TemplateArgumentLoc getArgLoc(unsigned i) const {\n    return TemplateArgumentLoc(getTypePtr()->getArg(i), getArgLocInfo(i));\n  }\n\n  SourceRange getLocalSourceRange() const {\n    if (getElaboratedKeywordLoc().isValid())\n      return SourceRange(getElaboratedKeywordLoc(), getRAngleLoc());\n    else if (getQualifierLoc())\n      return SourceRange(getQualifierLoc().getBeginLoc(), getRAngleLoc());\n    else if (getTemplateKeywordLoc().isValid())\n      return SourceRange(getTemplateKeywordLoc(), getRAngleLoc());\n    else\n      return SourceRange(getTemplateNameLoc(), getRAngleLoc());\n  }\n\n  void copy(DependentTemplateSpecializationTypeLoc Loc) {\n    unsigned size = getFullDataSize();\n    assert(size == Loc.getFullDataSize());\n    memcpy(Data, Loc.Data, size);\n  }\n\n  void initializeLocal(ASTContext &Context, SourceLocation Loc);\n\n  unsigned getExtraLocalDataSize() const {\n    return getNumArgs() * sizeof(TemplateArgumentLocInfo);\n  }\n\n  unsigned getExtraLocalDataAlignment() const {\n    return alignof(TemplateArgumentLocInfo);\n  }\n\nprivate:\n  TemplateArgumentLocInfo *getArgInfos() const {\n    return static_cast<TemplateArgumentLocInfo*>(getExtraLocalData());\n  }\n};\n\nstruct PackExpansionTypeLocInfo {\n  SourceLocation EllipsisLoc;\n};\n\nclass PackExpansionTypeLoc\n  : public ConcreteTypeLoc<UnqualTypeLoc, PackExpansionTypeLoc,\n                           PackExpansionType, PackExpansionTypeLocInfo> {\npublic:\n  SourceLocation getEllipsisLoc() const {\n    return this->getLocalData()->EllipsisLoc;\n  }\n\n  void setEllipsisLoc(SourceLocation Loc) {\n    this->getLocalData()->EllipsisLoc = Loc;\n  }\n\n  SourceRange getLocalSourceRange() const {\n    return SourceRange(getEllipsisLoc(), getEllipsisLoc());\n  }\n\n  void initializeLocal(ASTContext &Context, SourceLocation Loc) {\n    setEllipsisLoc(Loc);\n  }\n\n  TypeLoc getPatternLoc() const {\n    return getInnerTypeLoc();\n  }\n\n  QualType getInnerType() const {\n    return this->getTypePtr()->getPattern();\n  }\n};\n\nstruct AtomicTypeLocInfo {\n  SourceLocation KWLoc, LParenLoc, RParenLoc;\n};\n\nclass AtomicTypeLoc : public ConcreteTypeLoc<UnqualTypeLoc, AtomicTypeLoc,\n                                             AtomicType, AtomicTypeLocInfo> {\npublic:\n  TypeLoc getValueLoc() const {\n    return this->getInnerTypeLoc();\n  }\n\n  SourceRange getLocalSourceRange() const {\n    return SourceRange(getKWLoc(), getRParenLoc());\n  }\n\n  SourceLocation getKWLoc() const {\n    return this->getLocalData()->KWLoc;\n  }\n\n  void setKWLoc(SourceLocation Loc) {\n    this->getLocalData()->KWLoc = Loc;\n  }\n\n  SourceLocation getLParenLoc() const {\n    return this->getLocalData()->LParenLoc;\n  }\n\n  void setLParenLoc(SourceLocation Loc) {\n    this->getLocalData()->LParenLoc = Loc;\n  }\n\n  SourceLocation getRParenLoc() const {\n    return this->getLocalData()->RParenLoc;\n  }\n\n  void setRParenLoc(SourceLocation Loc) {\n    this->getLocalData()->RParenLoc = Loc;\n  }\n\n  SourceRange getParensRange() const {\n    return SourceRange(getLParenLoc(), getRParenLoc());\n  }\n\n  void setParensRange(SourceRange Range) {\n    setLParenLoc(Range.getBegin());\n    setRParenLoc(Range.getEnd());\n  }\n\n  void initializeLocal(ASTContext &Context, SourceLocation Loc) {\n    setKWLoc(Loc);\n    setLParenLoc(Loc);\n    setRParenLoc(Loc);\n  }\n\n  QualType getInnerType() const {\n    return this->getTypePtr()->getValueType();\n  }\n};\n\nstruct PipeTypeLocInfo {\n  SourceLocation KWLoc;\n};\n\nclass PipeTypeLoc : public ConcreteTypeLoc<UnqualTypeLoc, PipeTypeLoc, PipeType,\n                                           PipeTypeLocInfo> {\npublic:\n  TypeLoc getValueLoc() const { return this->getInnerTypeLoc(); }\n\n  SourceRange getLocalSourceRange() const { return SourceRange(getKWLoc()); }\n\n  SourceLocation getKWLoc() const { return this->getLocalData()->KWLoc; }\n  void setKWLoc(SourceLocation Loc) { this->getLocalData()->KWLoc = Loc; }\n\n  void initializeLocal(ASTContext &Context, SourceLocation Loc) {\n    setKWLoc(Loc);\n  }\n\n  QualType getInnerType() const { return this->getTypePtr()->getElementType(); }\n};\n\ntemplate <typename T>\ninline T TypeLoc::getAsAdjusted() const {\n  TypeLoc Cur = *this;\n  while (!T::isKind(Cur)) {\n    if (auto PTL = Cur.getAs<ParenTypeLoc>())\n      Cur = PTL.getInnerLoc();\n    else if (auto ATL = Cur.getAs<AttributedTypeLoc>())\n      Cur = ATL.getModifiedLoc();\n    else if (auto ETL = Cur.getAs<ElaboratedTypeLoc>())\n      Cur = ETL.getNamedTypeLoc();\n    else if (auto ATL = Cur.getAs<AdjustedTypeLoc>())\n      Cur = ATL.getOriginalLoc();\n    else if (auto MQL = Cur.getAs<MacroQualifiedTypeLoc>())\n      Cur = MQL.getInnerLoc();\n    else\n      break;\n  }\n  return Cur.getAs<T>();\n}\nclass ExtIntTypeLoc final\n    : public InheritingConcreteTypeLoc<TypeSpecTypeLoc, ExtIntTypeLoc,\n                                        ExtIntType> {};\nclass DependentExtIntTypeLoc final\n    : public InheritingConcreteTypeLoc<TypeSpecTypeLoc, DependentExtIntTypeLoc,\n                                        DependentExtIntType> {};\n\n} // namespace clang\n\n#endif // LLVM_CLANG_AST_TYPELOC_H\n"}, "15": {"id": 15, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Analysis/CFG.h", "content": "//===- CFG.h - Classes for representing and building CFGs -------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n//  This file defines the CFG and CFGBuilder classes for representing and\n//  building Control-Flow Graphs (CFGs) from ASTs.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_ANALYSIS_CFG_H\n#define LLVM_CLANG_ANALYSIS_CFG_H\n\n#include \"clang/Analysis/Support/BumpVector.h\"\n#include \"clang/Analysis/ConstructionContext.h\"\n#include \"clang/AST/ExprCXX.h\"\n#include \"clang/AST/ExprObjC.h\"\n#include \"clang/Basic/LLVM.h\"\n#include \"llvm/ADT/DenseMap.h\"\n#include \"llvm/ADT/GraphTraits.h\"\n#include \"llvm/ADT/None.h\"\n#include \"llvm/ADT/Optional.h\"\n#include \"llvm/ADT/PointerIntPair.h\"\n#include \"llvm/ADT/iterator_range.h\"\n#include \"llvm/Support/Allocator.h\"\n#include \"llvm/Support/raw_ostream.h\"\n#include <bitset>\n#include <cassert>\n#include <cstddef>\n#include <iterator>\n#include <memory>\n#include <vector>\n\nnamespace clang {\n\nclass ASTContext;\nclass BinaryOperator;\nclass CFG;\nclass CXXBaseSpecifier;\nclass CXXBindTemporaryExpr;\nclass CXXCtorInitializer;\nclass CXXDeleteExpr;\nclass CXXDestructorDecl;\nclass CXXNewExpr;\nclass CXXRecordDecl;\nclass Decl;\nclass FieldDecl;\nclass LangOptions;\nclass VarDecl;\n\n/// Represents a top-level expression in a basic block.\nclass CFGElement {\npublic:\n  enum Kind {\n    // main kind\n    Initializer,\n    ScopeBegin,\n    ScopeEnd,\n    NewAllocator,\n    LifetimeEnds,\n    LoopExit,\n    // stmt kind\n    Statement,\n    Constructor,\n    CXXRecordTypedCall,\n    STMT_BEGIN = Statement,\n    STMT_END = CXXRecordTypedCall,\n    // dtor kind\n    AutomaticObjectDtor,\n    DeleteDtor,\n    BaseDtor,\n    MemberDtor,\n    TemporaryDtor,\n    DTOR_BEGIN = AutomaticObjectDtor,\n    DTOR_END = TemporaryDtor\n  };\n\nprotected:\n  // The int bits are used to mark the kind.\n  llvm::PointerIntPair<void *, 2> Data1;\n  llvm::PointerIntPair<void *, 2> Data2;\n\n  CFGElement(Kind kind, const void *Ptr1, const void *Ptr2 = nullptr)\n      : Data1(const_cast<void*>(Ptr1), ((unsigned) kind) & 0x3),\n        Data2(const_cast<void*>(Ptr2), (((unsigned) kind) >> 2) & 0x3) {\n    assert(getKind() == kind);\n  }\n\n  CFGElement() = default;\n\npublic:\n  /// Convert to the specified CFGElement type, asserting that this\n  /// CFGElement is of the desired type.\n  template<typename T>\n  T castAs() const {\n    assert(T::isKind(*this));\n    T t;\n    CFGElement& e = t;\n    e = *this;\n    return t;\n  }\n\n  /// Convert to the specified CFGElement type, returning None if this\n  /// CFGElement is not of the desired type.\n  template<typename T>\n  Optional<T> getAs() const {\n    if (!T::isKind(*this))\n      return None;\n    T t;\n    CFGElement& e = t;\n    e = *this;\n    return t;\n  }\n\n  Kind getKind() const {\n    unsigned x = Data2.getInt();\n    x <<= 2;\n    x |= Data1.getInt();\n    return (Kind) x;\n  }\n\n  void dumpToStream(llvm::raw_ostream &OS) const;\n\n  void dump() const {\n    dumpToStream(llvm::errs());\n  }\n};\n\nclass CFGStmt : public CFGElement {\npublic:\n  explicit CFGStmt(Stmt *S, Kind K = Statement) : CFGElement(K, S) {\n    assert(isKind(*this));\n  }\n\n  const Stmt *getStmt() const {\n    return static_cast<const Stmt *>(Data1.getPointer());\n  }\n\nprivate:\n  friend class CFGElement;\n\n  static bool isKind(const CFGElement &E) {\n    return E.getKind() >= STMT_BEGIN && E.getKind() <= STMT_END;\n  }\n\nprotected:\n  CFGStmt() = default;\n};\n\n/// Represents C++ constructor call. Maintains information necessary to figure\n/// out what memory is being initialized by the constructor expression. For now\n/// this is only used by the analyzer's CFG.\nclass CFGConstructor : public CFGStmt {\npublic:\n  explicit CFGConstructor(CXXConstructExpr *CE, const ConstructionContext *C)\n      : CFGStmt(CE, Constructor) {\n    assert(C);\n    Data2.setPointer(const_cast<ConstructionContext *>(C));\n  }\n\n  const ConstructionContext *getConstructionContext() const {\n    return static_cast<ConstructionContext *>(Data2.getPointer());\n  }\n\nprivate:\n  friend class CFGElement;\n\n  CFGConstructor() = default;\n\n  static bool isKind(const CFGElement &E) {\n    return E.getKind() == Constructor;\n  }\n};\n\n/// Represents a function call that returns a C++ object by value. This, like\n/// constructor, requires a construction context in order to understand the\n/// storage of the returned object . In C such tracking is not necessary because\n/// no additional effort is required for destroying the object or modeling copy\n/// elision. Like CFGConstructor, this element is for now only used by the\n/// analyzer's CFG.\nclass CFGCXXRecordTypedCall : public CFGStmt {\npublic:\n  /// Returns true when call expression \\p CE needs to be represented\n  /// by CFGCXXRecordTypedCall, as opposed to a regular CFGStmt.\n  static bool isCXXRecordTypedCall(Expr *E) {\n    assert(isa<CallExpr>(E) || isa<ObjCMessageExpr>(E));\n    // There is no such thing as reference-type expression. If the function\n    // returns a reference, it'll return the respective lvalue or xvalue\n    // instead, and we're only interested in objects.\n    return !E->isGLValue() &&\n           E->getType().getCanonicalType()->getAsCXXRecordDecl();\n  }\n\n  explicit CFGCXXRecordTypedCall(Expr *E, const ConstructionContext *C)\n      : CFGStmt(E, CXXRecordTypedCall) {\n    assert(isCXXRecordTypedCall(E));\n    assert(C && (isa<TemporaryObjectConstructionContext>(C) ||\n                 // These are possible in C++17 due to mandatory copy elision.\n                 isa<ReturnedValueConstructionContext>(C) ||\n                 isa<VariableConstructionContext>(C) ||\n                 isa<ConstructorInitializerConstructionContext>(C) ||\n                 isa<ArgumentConstructionContext>(C)));\n    Data2.setPointer(const_cast<ConstructionContext *>(C));\n  }\n\n  const ConstructionContext *getConstructionContext() const {\n    return static_cast<ConstructionContext *>(Data2.getPointer());\n  }\n\nprivate:\n  friend class CFGElement;\n\n  CFGCXXRecordTypedCall() = default;\n\n  static bool isKind(const CFGElement &E) {\n    return E.getKind() == CXXRecordTypedCall;\n  }\n};\n\n/// Represents C++ base or member initializer from constructor's initialization\n/// list.\nclass CFGInitializer : public CFGElement {\npublic:\n  explicit CFGInitializer(CXXCtorInitializer *initializer)\n      : CFGElement(Initializer, initializer) {}\n\n  CXXCtorInitializer* getInitializer() const {\n    return static_cast<CXXCtorInitializer*>(Data1.getPointer());\n  }\n\nprivate:\n  friend class CFGElement;\n\n  CFGInitializer() = default;\n\n  static bool isKind(const CFGElement &E) {\n    return E.getKind() == Initializer;\n  }\n};\n\n/// Represents C++ allocator call.\nclass CFGNewAllocator : public CFGElement {\npublic:\n  explicit CFGNewAllocator(const CXXNewExpr *S)\n    : CFGElement(NewAllocator, S) {}\n\n  // Get the new expression.\n  const CXXNewExpr *getAllocatorExpr() const {\n    return static_cast<CXXNewExpr *>(Data1.getPointer());\n  }\n\nprivate:\n  friend class CFGElement;\n\n  CFGNewAllocator() = default;\n\n  static bool isKind(const CFGElement &elem) {\n    return elem.getKind() == NewAllocator;\n  }\n};\n\n/// Represents the point where a loop ends.\n/// This element is is only produced when building the CFG for the static\n/// analyzer and hidden behind the 'cfg-loopexit' analyzer config flag.\n///\n/// Note: a loop exit element can be reached even when the loop body was never\n/// entered.\nclass CFGLoopExit : public CFGElement {\npublic:\n  explicit CFGLoopExit(const Stmt *stmt) : CFGElement(LoopExit, stmt) {}\n\n  const Stmt *getLoopStmt() const {\n    return static_cast<Stmt *>(Data1.getPointer());\n  }\n\nprivate:\n  friend class CFGElement;\n\n  CFGLoopExit() = default;\n\n  static bool isKind(const CFGElement &elem) {\n    return elem.getKind() == LoopExit;\n  }\n};\n\n/// Represents the point where the lifetime of an automatic object ends\nclass CFGLifetimeEnds : public CFGElement {\npublic:\n  explicit CFGLifetimeEnds(const VarDecl *var, const Stmt *stmt)\n      : CFGElement(LifetimeEnds, var, stmt) {}\n\n  const VarDecl *getVarDecl() const {\n    return static_cast<VarDecl *>(Data1.getPointer());\n  }\n\n  const Stmt *getTriggerStmt() const {\n    return static_cast<Stmt *>(Data2.getPointer());\n  }\n\nprivate:\n  friend class CFGElement;\n\n  CFGLifetimeEnds() = default;\n\n  static bool isKind(const CFGElement &elem) {\n    return elem.getKind() == LifetimeEnds;\n  }\n};\n\n/// Represents beginning of a scope implicitly generated\n/// by the compiler on encountering a CompoundStmt\nclass CFGScopeBegin : public CFGElement {\npublic:\n  CFGScopeBegin() {}\n  CFGScopeBegin(const VarDecl *VD, const Stmt *S)\n      : CFGElement(ScopeBegin, VD, S) {}\n\n  // Get statement that triggered a new scope.\n  const Stmt *getTriggerStmt() const {\n    return static_cast<Stmt*>(Data2.getPointer());\n  }\n\n  // Get VD that triggered a new scope.\n  const VarDecl *getVarDecl() const {\n    return static_cast<VarDecl *>(Data1.getPointer());\n  }\n\nprivate:\n  friend class CFGElement;\n  static bool isKind(const CFGElement &E) {\n    Kind kind = E.getKind();\n    return kind == ScopeBegin;\n  }\n};\n\n/// Represents end of a scope implicitly generated by\n/// the compiler after the last Stmt in a CompoundStmt's body\nclass CFGScopeEnd : public CFGElement {\npublic:\n  CFGScopeEnd() {}\n  CFGScopeEnd(const VarDecl *VD, const Stmt *S) : CFGElement(ScopeEnd, VD, S) {}\n\n  const VarDecl *getVarDecl() const {\n    return static_cast<VarDecl *>(Data1.getPointer());\n  }\n\n  const Stmt *getTriggerStmt() const {\n    return static_cast<Stmt *>(Data2.getPointer());\n  }\n\nprivate:\n  friend class CFGElement;\n  static bool isKind(const CFGElement &E) {\n    Kind kind = E.getKind();\n    return kind == ScopeEnd;\n  }\n};\n\n/// Represents C++ object destructor implicitly generated by compiler on various\n/// occasions.\nclass CFGImplicitDtor : public CFGElement {\nprotected:\n  CFGImplicitDtor() = default;\n\n  CFGImplicitDtor(Kind kind, const void *data1, const void *data2 = nullptr)\n    : CFGElement(kind, data1, data2) {\n    assert(kind >= DTOR_BEGIN && kind <= DTOR_END);\n  }\n\npublic:\n  const CXXDestructorDecl *getDestructorDecl(ASTContext &astContext) const;\n  bool isNoReturn(ASTContext &astContext) const;\n\nprivate:\n  friend class CFGElement;\n\n  static bool isKind(const CFGElement &E) {\n    Kind kind = E.getKind();\n    return kind >= DTOR_BEGIN && kind <= DTOR_END;\n  }\n};\n\n/// Represents C++ object destructor implicitly generated for automatic object\n/// or temporary bound to const reference at the point of leaving its local\n/// scope.\nclass CFGAutomaticObjDtor: public CFGImplicitDtor {\npublic:\n  CFGAutomaticObjDtor(const VarDecl *var, const Stmt *stmt)\n      : CFGImplicitDtor(AutomaticObjectDtor, var, stmt) {}\n\n  const VarDecl *getVarDecl() const {\n    return static_cast<VarDecl*>(Data1.getPointer());\n  }\n\n  // Get statement end of which triggered the destructor call.\n  const Stmt *getTriggerStmt() const {\n    return static_cast<Stmt*>(Data2.getPointer());\n  }\n\nprivate:\n  friend class CFGElement;\n\n  CFGAutomaticObjDtor() = default;\n\n  static bool isKind(const CFGElement &elem) {\n    return elem.getKind() == AutomaticObjectDtor;\n  }\n};\n\n/// Represents C++ object destructor generated from a call to delete.\nclass CFGDeleteDtor : public CFGImplicitDtor {\npublic:\n  CFGDeleteDtor(const CXXRecordDecl *RD, const CXXDeleteExpr *DE)\n      : CFGImplicitDtor(DeleteDtor, RD, DE) {}\n\n  const CXXRecordDecl *getCXXRecordDecl() const {\n    return static_cast<CXXRecordDecl*>(Data1.getPointer());\n  }\n\n  // Get Delete expression which triggered the destructor call.\n  const CXXDeleteExpr *getDeleteExpr() const {\n    return static_cast<CXXDeleteExpr *>(Data2.getPointer());\n  }\n\nprivate:\n  friend class CFGElement;\n\n  CFGDeleteDtor() = default;\n\n  static bool isKind(const CFGElement &elem) {\n    return elem.getKind() == DeleteDtor;\n  }\n};\n\n/// Represents C++ object destructor implicitly generated for base object in\n/// destructor.\nclass CFGBaseDtor : public CFGImplicitDtor {\npublic:\n  CFGBaseDtor(const CXXBaseSpecifier *base)\n      : CFGImplicitDtor(BaseDtor, base) {}\n\n  const CXXBaseSpecifier *getBaseSpecifier() const {\n    return static_cast<const CXXBaseSpecifier*>(Data1.getPointer());\n  }\n\nprivate:\n  friend class CFGElement;\n\n  CFGBaseDtor() = default;\n\n  static bool isKind(const CFGElement &E) {\n    return E.getKind() == BaseDtor;\n  }\n};\n\n/// Represents C++ object destructor implicitly generated for member object in\n/// destructor.\nclass CFGMemberDtor : public CFGImplicitDtor {\npublic:\n  CFGMemberDtor(const FieldDecl *field)\n      : CFGImplicitDtor(MemberDtor, field, nullptr) {}\n\n  const FieldDecl *getFieldDecl() const {\n    return static_cast<const FieldDecl*>(Data1.getPointer());\n  }\n\nprivate:\n  friend class CFGElement;\n\n  CFGMemberDtor() = default;\n\n  static bool isKind(const CFGElement &E) {\n    return E.getKind() == MemberDtor;\n  }\n};\n\n/// Represents C++ object destructor implicitly generated at the end of full\n/// expression for temporary object.\nclass CFGTemporaryDtor : public CFGImplicitDtor {\npublic:\n  CFGTemporaryDtor(CXXBindTemporaryExpr *expr)\n      : CFGImplicitDtor(TemporaryDtor, expr, nullptr) {}\n\n  const CXXBindTemporaryExpr *getBindTemporaryExpr() const {\n    return static_cast<const CXXBindTemporaryExpr *>(Data1.getPointer());\n  }\n\nprivate:\n  friend class CFGElement;\n\n  CFGTemporaryDtor() = default;\n\n  static bool isKind(const CFGElement &E) {\n    return E.getKind() == TemporaryDtor;\n  }\n};\n\n/// Represents CFGBlock terminator statement.\n///\nclass CFGTerminator {\npublic:\n  enum Kind {\n    /// A branch that corresponds to a statement in the code,\n    /// such as an if-statement.\n    StmtBranch,\n    /// A branch in control flow of destructors of temporaries. In this case\n    /// terminator statement is the same statement that branches control flow\n    /// in evaluation of matching full expression.\n    TemporaryDtorsBranch,\n    /// A shortcut around virtual base initializers. It gets taken when\n    /// virtual base classes have already been initialized by the constructor\n    /// of the most derived class while we're in the base class.\n    VirtualBaseBranch,\n\n    /// Number of different kinds, for sanity checks. We subtract 1 so that\n    /// to keep receiving compiler warnings when we don't cover all enum values\n    /// in a switch.\n    NumKindsMinusOne = VirtualBaseBranch\n  };\n\nprivate:\n  static constexpr int KindBits = 2;\n  static_assert((1 << KindBits) > NumKindsMinusOne,\n                \"Not enough room for kind!\");\n  llvm::PointerIntPair<Stmt *, KindBits> Data;\n\npublic:\n  CFGTerminator() { assert(!isValid()); }\n  CFGTerminator(Stmt *S, Kind K = StmtBranch) : Data(S, K) {}\n\n  bool isValid() const { return Data.getOpaqueValue() != nullptr; }\n  Stmt *getStmt() { return Data.getPointer(); }\n  const Stmt *getStmt() const { return Data.getPointer(); }\n  Kind getKind() const { return static_cast<Kind>(Data.getInt()); }\n\n  bool isStmtBranch() const {\n    return getKind() == StmtBranch;\n  }\n  bool isTemporaryDtorsBranch() const {\n    return getKind() == TemporaryDtorsBranch;\n  }\n  bool isVirtualBaseBranch() const {\n    return getKind() == VirtualBaseBranch;\n  }\n};\n\n/// Represents a single basic block in a source-level CFG.\n///  It consists of:\n///\n///  (1) A set of statements/expressions (which may contain subexpressions).\n///  (2) A \"terminator\" statement (not in the set of statements).\n///  (3) A list of successors and predecessors.\n///\n/// Terminator: The terminator represents the type of control-flow that occurs\n/// at the end of the basic block.  The terminator is a Stmt* referring to an\n/// AST node that has control-flow: if-statements, breaks, loops, etc.\n/// If the control-flow is conditional, the condition expression will appear\n/// within the set of statements in the block (usually the last statement).\n///\n/// Predecessors: the order in the set of predecessors is arbitrary.\n///\n/// Successors: the order in the set of successors is NOT arbitrary.  We\n///  currently have the following orderings based on the terminator:\n///\n///     Terminator     |   Successor Ordering\n///  ------------------|------------------------------------\n///       if           |  Then Block;  Else Block\n///     ? operator     |  LHS expression;  RHS expression\n///     logical and/or |  expression that consumes the op, RHS\n///     vbase inits    |  already handled by the most derived class; not yet\n///\n/// But note that any of that may be NULL in case of optimized-out edges.\nclass CFGBlock {\n  class ElementList {\n    using ImplTy = BumpVector<CFGElement>;\n\n    ImplTy Impl;\n\n  public:\n    ElementList(BumpVectorContext &C) : Impl(C, 4) {}\n\n    using iterator = std::reverse_iterator<ImplTy::iterator>;\n    using const_iterator = std::reverse_iterator<ImplTy::const_iterator>;\n    using reverse_iterator = ImplTy::iterator;\n    using const_reverse_iterator = ImplTy::const_iterator;\n    using const_reference = ImplTy::const_reference;\n\n    void push_back(CFGElement e, BumpVectorContext &C) { Impl.push_back(e, C); }\n\n    reverse_iterator insert(reverse_iterator I, size_t Cnt, CFGElement E,\n        BumpVectorContext &C) {\n      return Impl.insert(I, Cnt, E, C);\n    }\n\n    const_reference front() const { return Impl.back(); }\n    const_reference back() const { return Impl.front(); }\n\n    iterator begin() { return Impl.rbegin(); }\n    iterator end() { return Impl.rend(); }\n    const_iterator begin() const { return Impl.rbegin(); }\n    const_iterator end() const { return Impl.rend(); }\n    reverse_iterator rbegin() { return Impl.begin(); }\n    reverse_iterator rend() { return Impl.end(); }\n    const_reverse_iterator rbegin() const { return Impl.begin(); }\n    const_reverse_iterator rend() const { return Impl.end(); }\n\n    CFGElement operator[](size_t i) const  {\n      assert(i < Impl.size());\n      return Impl[Impl.size() - 1 - i];\n    }\n\n    size_t size() const { return Impl.size(); }\n    bool empty() const { return Impl.empty(); }\n  };\n\n  /// A convenience class for comparing CFGElements, since methods of CFGBlock\n  /// like operator[] return CFGElements by value. This is practically a wrapper\n  /// around a (CFGBlock, Index) pair.\n  template <bool IsConst> class ElementRefImpl {\n\n    template <bool IsOtherConst> friend class ElementRefImpl;\n\n    using CFGBlockPtr =\n        std::conditional_t<IsConst, const CFGBlock *, CFGBlock *>;\n\n    using CFGElementPtr =\n        std::conditional_t<IsConst, const CFGElement *, CFGElement *>;\n\n  protected:\n    CFGBlockPtr Parent;\n    size_t Index;\n\n  public:\n    ElementRefImpl(CFGBlockPtr Parent, size_t Index)\n        : Parent(Parent), Index(Index) {}\n\n    template <bool IsOtherConst>\n    ElementRefImpl(ElementRefImpl<IsOtherConst> Other)\n        : ElementRefImpl(Other.Parent, Other.Index) {}\n\n    size_t getIndexInBlock() const { return Index; }\n\n    CFGBlockPtr getParent() { return Parent; }\n    CFGBlockPtr getParent() const { return Parent; }\n\n    bool operator<(ElementRefImpl Other) const {\n      return std::make_pair(Parent, Index) <\n             std::make_pair(Other.Parent, Other.Index);\n    }\n\n    bool operator==(ElementRefImpl Other) const {\n      return Parent == Other.Parent && Index == Other.Index;\n    }\n\n    bool operator!=(ElementRefImpl Other) const { return !(*this == Other); }\n    CFGElement operator*() const { return (*Parent)[Index]; }\n    CFGElementPtr operator->() const { return &*(Parent->begin() + Index); }\n\n    void dumpToStream(llvm::raw_ostream &OS) const {\n      OS << getIndexInBlock() + 1 << \": \";\n      (*this)->dumpToStream(OS);\n    }\n\n    void dump() const {\n      dumpToStream(llvm::errs());\n    }\n  };\n\n  template <bool IsReverse, bool IsConst> class ElementRefIterator {\n\n    template <bool IsOtherReverse, bool IsOtherConst>\n    friend class ElementRefIterator;\n\n    using CFGBlockRef =\n        std::conditional_t<IsConst, const CFGBlock *, CFGBlock *>;\n\n    using UnderlayingIteratorTy = std::conditional_t<\n        IsConst,\n        std::conditional_t<IsReverse, ElementList::const_reverse_iterator,\n                           ElementList::const_iterator>,\n        std::conditional_t<IsReverse, ElementList::reverse_iterator,\n                           ElementList::iterator>>;\n\n    using IteratorTraits = typename std::iterator_traits<UnderlayingIteratorTy>;\n    using ElementRef = typename CFGBlock::ElementRefImpl<IsConst>;\n\n  public:\n    using difference_type = typename IteratorTraits::difference_type;\n    using value_type = ElementRef;\n    using pointer = ElementRef *;\n    using iterator_category = typename IteratorTraits::iterator_category;\n\n  private:\n    CFGBlockRef Parent;\n    UnderlayingIteratorTy Pos;\n\n  public:\n    ElementRefIterator(CFGBlockRef Parent, UnderlayingIteratorTy Pos)\n        : Parent(Parent), Pos(Pos) {}\n\n    template <bool IsOtherConst>\n    ElementRefIterator(ElementRefIterator<false, IsOtherConst> E)\n        : ElementRefIterator(E.Parent, E.Pos.base()) {}\n\n    template <bool IsOtherConst>\n    ElementRefIterator(ElementRefIterator<true, IsOtherConst> E)\n        : ElementRefIterator(E.Parent, llvm::make_reverse_iterator(E.Pos)) {}\n\n    bool operator<(ElementRefIterator Other) const {\n      assert(Parent == Other.Parent);\n      return Pos < Other.Pos;\n    }\n\n    bool operator==(ElementRefIterator Other) const {\n      return Parent == Other.Parent && Pos == Other.Pos;\n    }\n\n    bool operator!=(ElementRefIterator Other) const {\n      return !(*this == Other);\n    }\n\n  private:\n    template <bool IsOtherConst>\n    static size_t\n    getIndexInBlock(CFGBlock::ElementRefIterator<true, IsOtherConst> E) {\n      return E.Parent->size() - (E.Pos - E.Parent->rbegin()) - 1;\n    }\n\n    template <bool IsOtherConst>\n    static size_t\n    getIndexInBlock(CFGBlock::ElementRefIterator<false, IsOtherConst> E) {\n      return E.Pos - E.Parent->begin();\n    }\n\n  public:\n    value_type operator*() { return {Parent, getIndexInBlock(*this)}; }\n\n    difference_type operator-(ElementRefIterator Other) const {\n      return Pos - Other.Pos;\n    }\n\n    ElementRefIterator operator++() {\n      ++this->Pos;\n      return *this;\n    }\n    ElementRefIterator operator++(int) {\n      ElementRefIterator Ret = *this;\n      ++*this;\n      return Ret;\n    }\n    ElementRefIterator operator+(size_t count) {\n      this->Pos += count;\n      return *this;\n    }\n    ElementRefIterator operator-(size_t count) {\n      this->Pos -= count;\n      return *this;\n    }\n  };\n\npublic:\n  /// The set of statements in the basic block.\n  ElementList Elements;\n\n  /// An (optional) label that prefixes the executable statements in the block.\n  /// When this variable is non-NULL, it is either an instance of LabelStmt,\n  /// SwitchCase or CXXCatchStmt.\n  Stmt *Label = nullptr;\n\n  /// The terminator for a basic block that indicates the type of control-flow\n  /// that occurs between a block and its successors.\n  CFGTerminator Terminator;\n\n  /// Some blocks are used to represent the \"loop edge\" to the start of a loop\n  /// from within the loop body. This Stmt* will be refer to the loop statement\n  /// for such blocks (and be null otherwise).\n  const Stmt *LoopTarget = nullptr;\n\n  /// A numerical ID assigned to a CFGBlock during construction of the CFG.\n  unsigned BlockID;\n\npublic:\n  /// This class represents a potential adjacent block in the CFG.  It encodes\n  /// whether or not the block is actually reachable, or can be proved to be\n  /// trivially unreachable.  For some cases it allows one to encode scenarios\n  /// where a block was substituted because the original (now alternate) block\n  /// is unreachable.\n  class AdjacentBlock {\n    enum Kind {\n      AB_Normal,\n      AB_Unreachable,\n      AB_Alternate\n    };\n\n    CFGBlock *ReachableBlock;\n    llvm::PointerIntPair<CFGBlock *, 2> UnreachableBlock;\n\n  public:\n    /// Construct an AdjacentBlock with a possibly unreachable block.\n    AdjacentBlock(CFGBlock *B, bool IsReachable);\n\n    /// Construct an AdjacentBlock with a reachable block and an alternate\n    /// unreachable block.\n    AdjacentBlock(CFGBlock *B, CFGBlock *AlternateBlock);\n\n    /// Get the reachable block, if one exists.\n    CFGBlock *getReachableBlock() const {\n      return ReachableBlock;\n    }\n\n    /// Get the potentially unreachable block.\n    CFGBlock *getPossiblyUnreachableBlock() const {\n      return UnreachableBlock.getPointer();\n    }\n\n    /// Provide an implicit conversion to CFGBlock* so that\n    /// AdjacentBlock can be substituted for CFGBlock*.\n    operator CFGBlock*() const {\n      return getReachableBlock();\n    }\n\n    CFGBlock& operator *() const {\n      return *getReachableBlock();\n    }\n\n    CFGBlock* operator ->() const {\n      return getReachableBlock();\n    }\n\n    bool isReachable() const {\n      Kind K = (Kind) UnreachableBlock.getInt();\n      return K == AB_Normal || K == AB_Alternate;\n    }\n  };\n\nprivate:\n  /// Keep track of the predecessor / successor CFG blocks.\n  using AdjacentBlocks = BumpVector<AdjacentBlock>;\n  AdjacentBlocks Preds;\n  AdjacentBlocks Succs;\n\n  /// This bit is set when the basic block contains a function call\n  /// or implicit destructor that is attributed as 'noreturn'. In that case,\n  /// control cannot technically ever proceed past this block. All such blocks\n  /// will have a single immediate successor: the exit block. This allows them\n  /// to be easily reached from the exit block and using this bit quickly\n  /// recognized without scanning the contents of the block.\n  ///\n  /// Optimization Note: This bit could be profitably folded with Terminator's\n  /// storage if the memory usage of CFGBlock becomes an issue.\n  unsigned HasNoReturnElement : 1;\n\n  /// The parent CFG that owns this CFGBlock.\n  CFG *Parent;\n\npublic:\n  explicit CFGBlock(unsigned blockid, BumpVectorContext &C, CFG *parent)\n      : Elements(C), Terminator(nullptr), BlockID(blockid), Preds(C, 1),\n        Succs(C, 1), HasNoReturnElement(false), Parent(parent) {}\n\n  // Statement iterators\n  using iterator = ElementList::iterator;\n  using const_iterator = ElementList::const_iterator;\n  using reverse_iterator = ElementList::reverse_iterator;\n  using const_reverse_iterator = ElementList::const_reverse_iterator;\n\n  size_t getIndexInCFG() const;\n\n  CFGElement                 front()       const { return Elements.front();   }\n  CFGElement                 back()        const { return Elements.back();    }\n\n  iterator                   begin()             { return Elements.begin();   }\n  iterator                   end()               { return Elements.end();     }\n  const_iterator             begin()       const { return Elements.begin();   }\n  const_iterator             end()         const { return Elements.end();     }\n\n  reverse_iterator           rbegin()            { return Elements.rbegin();  }\n  reverse_iterator           rend()              { return Elements.rend();    }\n  const_reverse_iterator     rbegin()      const { return Elements.rbegin();  }\n  const_reverse_iterator     rend()        const { return Elements.rend();    }\n\n  using CFGElementRef = ElementRefImpl<false>;\n  using ConstCFGElementRef = ElementRefImpl<true>;\n\n  using ref_iterator = ElementRefIterator<false, false>;\n  using ref_iterator_range = llvm::iterator_range<ref_iterator>;\n  using const_ref_iterator = ElementRefIterator<false, true>;\n  using const_ref_iterator_range = llvm::iterator_range<const_ref_iterator>;\n\n  using reverse_ref_iterator = ElementRefIterator<true, false>;\n  using reverse_ref_iterator_range = llvm::iterator_range<reverse_ref_iterator>;\n\n  using const_reverse_ref_iterator = ElementRefIterator<true, true>;\n  using const_reverse_ref_iterator_range =\n      llvm::iterator_range<const_reverse_ref_iterator>;\n\n  ref_iterator ref_begin() { return {this, begin()}; }\n  ref_iterator ref_end() { return {this, end()}; }\n  const_ref_iterator ref_begin() const { return {this, begin()}; }\n  const_ref_iterator ref_end() const { return {this, end()}; }\n\n  reverse_ref_iterator rref_begin() { return {this, rbegin()}; }\n  reverse_ref_iterator rref_end() { return {this, rend()}; }\n  const_reverse_ref_iterator rref_begin() const { return {this, rbegin()}; }\n  const_reverse_ref_iterator rref_end() const { return {this, rend()}; }\n\n  ref_iterator_range refs() { return {ref_begin(), ref_end()}; }\n  const_ref_iterator_range refs() const { return {ref_begin(), ref_end()}; }\n  reverse_ref_iterator_range rrefs() { return {rref_begin(), rref_end()}; }\n  const_reverse_ref_iterator_range rrefs() const {\n    return {rref_begin(), rref_end()};\n  }\n\n  unsigned                   size()        const { return Elements.size();    }\n  bool                       empty()       const { return Elements.empty();   }\n\n  CFGElement operator[](size_t i) const  { return Elements[i]; }\n\n  // CFG iterators\n  using pred_iterator = AdjacentBlocks::iterator;\n  using const_pred_iterator = AdjacentBlocks::const_iterator;\n  using pred_reverse_iterator = AdjacentBlocks::reverse_iterator;\n  using const_pred_reverse_iterator = AdjacentBlocks::const_reverse_iterator;\n  using pred_range = llvm::iterator_range<pred_iterator>;\n  using pred_const_range = llvm::iterator_range<const_pred_iterator>;\n\n  using succ_iterator = AdjacentBlocks::iterator;\n  using const_succ_iterator = AdjacentBlocks::const_iterator;\n  using succ_reverse_iterator = AdjacentBlocks::reverse_iterator;\n  using const_succ_reverse_iterator = AdjacentBlocks::const_reverse_iterator;\n  using succ_range = llvm::iterator_range<succ_iterator>;\n  using succ_const_range = llvm::iterator_range<const_succ_iterator>;\n\n  pred_iterator                pred_begin()        { return Preds.begin();   }\n  pred_iterator                pred_end()          { return Preds.end();     }\n  const_pred_iterator          pred_begin()  const { return Preds.begin();   }\n  const_pred_iterator          pred_end()    const { return Preds.end();     }\n\n  pred_reverse_iterator        pred_rbegin()       { return Preds.rbegin();  }\n  pred_reverse_iterator        pred_rend()         { return Preds.rend();    }\n  const_pred_reverse_iterator  pred_rbegin() const { return Preds.rbegin();  }\n  const_pred_reverse_iterator  pred_rend()   const { return Preds.rend();    }\n\n  pred_range preds() {\n    return pred_range(pred_begin(), pred_end());\n  }\n\n  pred_const_range preds() const {\n    return pred_const_range(pred_begin(), pred_end());\n  }\n\n  succ_iterator                succ_begin()        { return Succs.begin();   }\n  succ_iterator                succ_end()          { return Succs.end();     }\n  const_succ_iterator          succ_begin()  const { return Succs.begin();   }\n  const_succ_iterator          succ_end()    const { return Succs.end();     }\n\n  succ_reverse_iterator        succ_rbegin()       { return Succs.rbegin();  }\n  succ_reverse_iterator        succ_rend()         { return Succs.rend();    }\n  const_succ_reverse_iterator  succ_rbegin() const { return Succs.rbegin();  }\n  const_succ_reverse_iterator  succ_rend()   const { return Succs.rend();    }\n\n  succ_range succs() {\n    return succ_range(succ_begin(), succ_end());\n  }\n\n  succ_const_range succs() const {\n    return succ_const_range(succ_begin(), succ_end());\n  }\n\n  unsigned                     succ_size()   const { return Succs.size();    }\n  bool                         succ_empty()  const { return Succs.empty();   }\n\n  unsigned                     pred_size()   const { return Preds.size();    }\n  bool                         pred_empty()  const { return Preds.empty();   }\n\n\n  class FilterOptions {\n  public:\n    unsigned IgnoreNullPredecessors : 1;\n    unsigned IgnoreDefaultsWithCoveredEnums : 1;\n\n    FilterOptions()\n        : IgnoreNullPredecessors(1), IgnoreDefaultsWithCoveredEnums(0) {}\n  };\n\n  static bool FilterEdge(const FilterOptions &F, const CFGBlock *Src,\n       const CFGBlock *Dst);\n\n  template <typename IMPL, bool IsPred>\n  class FilteredCFGBlockIterator {\n  private:\n    IMPL I, E;\n    const FilterOptions F;\n    const CFGBlock *From;\n\n  public:\n    explicit FilteredCFGBlockIterator(const IMPL &i, const IMPL &e,\n                                      const CFGBlock *from,\n                                      const FilterOptions &f)\n        : I(i), E(e), F(f), From(from) {\n      while (hasMore() && Filter(*I))\n        ++I;\n    }\n\n    bool hasMore() const { return I != E; }\n\n    FilteredCFGBlockIterator &operator++() {\n      do { ++I; } while (hasMore() && Filter(*I));\n      return *this;\n    }\n\n    const CFGBlock *operator*() const { return *I; }\n\n  private:\n    bool Filter(const CFGBlock *To) {\n      return IsPred ? FilterEdge(F, To, From) : FilterEdge(F, From, To);\n    }\n  };\n\n  using filtered_pred_iterator =\n      FilteredCFGBlockIterator<const_pred_iterator, true>;\n\n  using filtered_succ_iterator =\n      FilteredCFGBlockIterator<const_succ_iterator, false>;\n\n  filtered_pred_iterator filtered_pred_start_end(const FilterOptions &f) const {\n    return filtered_pred_iterator(pred_begin(), pred_end(), this, f);\n  }\n\n  filtered_succ_iterator filtered_succ_start_end(const FilterOptions &f) const {\n    return filtered_succ_iterator(succ_begin(), succ_end(), this, f);\n  }\n\n  // Manipulation of block contents\n\n  void setTerminator(CFGTerminator Term) { Terminator = Term; }\n  void setLabel(Stmt *Statement) { Label = Statement; }\n  void setLoopTarget(const Stmt *loopTarget) { LoopTarget = loopTarget; }\n  void setHasNoReturnElement() { HasNoReturnElement = true; }\n\n  /// Returns true if the block would eventually end with a sink (a noreturn\n  /// node).\n  bool isInevitablySinking() const;\n\n  CFGTerminator getTerminator() const { return Terminator; }\n\n  Stmt *getTerminatorStmt() { return Terminator.getStmt(); }\n  const Stmt *getTerminatorStmt() const { return Terminator.getStmt(); }\n\n  /// \\returns the last (\\c rbegin()) condition, e.g. observe the following code\n  /// snippet:\n  ///   if (A && B && C)\n  /// A block would be created for \\c A, \\c B, and \\c C. For the latter,\n  /// \\c getTerminatorStmt() would retrieve the entire condition, rather than\n  /// C itself, while this method would only return C.\n  const Expr *getLastCondition() const;\n\n  Stmt *getTerminatorCondition(bool StripParens = true);\n\n  const Stmt *getTerminatorCondition(bool StripParens = true) const {\n    return const_cast<CFGBlock*>(this)->getTerminatorCondition(StripParens);\n  }\n\n  const Stmt *getLoopTarget() const { return LoopTarget; }\n\n  Stmt *getLabel() { return Label; }\n  const Stmt *getLabel() const { return Label; }\n\n  bool hasNoReturnElement() const { return HasNoReturnElement; }\n\n  unsigned getBlockID() const { return BlockID; }\n\n  CFG *getParent() const { return Parent; }\n\n  void dump() const;\n\n  void dump(const CFG *cfg, const LangOptions &LO, bool ShowColors = false) const;\n  void print(raw_ostream &OS, const CFG* cfg, const LangOptions &LO,\n             bool ShowColors) const;\n\n  void printTerminator(raw_ostream &OS, const LangOptions &LO) const;\n  void printTerminatorJson(raw_ostream &Out, const LangOptions &LO,\n                           bool AddQuotes) const;\n\n  void printAsOperand(raw_ostream &OS, bool /*PrintType*/) {\n    OS << \"BB#\" << getBlockID();\n  }\n\n  /// Adds a (potentially unreachable) successor block to the current block.\n  void addSuccessor(AdjacentBlock Succ, BumpVectorContext &C);\n\n  void appendStmt(Stmt *statement, BumpVectorContext &C) {\n    Elements.push_back(CFGStmt(statement), C);\n  }\n\n  void appendConstructor(CXXConstructExpr *CE, const ConstructionContext *CC,\n                         BumpVectorContext &C) {\n    Elements.push_back(CFGConstructor(CE, CC), C);\n  }\n\n  void appendCXXRecordTypedCall(Expr *E,\n                                const ConstructionContext *CC,\n                                BumpVectorContext &C) {\n    Elements.push_back(CFGCXXRecordTypedCall(E, CC), C);\n  }\n\n  void appendInitializer(CXXCtorInitializer *initializer,\n                        BumpVectorContext &C) {\n    Elements.push_back(CFGInitializer(initializer), C);\n  }\n\n  void appendNewAllocator(CXXNewExpr *NE,\n                          BumpVectorContext &C) {\n    Elements.push_back(CFGNewAllocator(NE), C);\n  }\n\n  void appendScopeBegin(const VarDecl *VD, const Stmt *S,\n                        BumpVectorContext &C) {\n    Elements.push_back(CFGScopeBegin(VD, S), C);\n  }\n\n  void prependScopeBegin(const VarDecl *VD, const Stmt *S,\n                         BumpVectorContext &C) {\n    Elements.insert(Elements.rbegin(), 1, CFGScopeBegin(VD, S), C);\n  }\n\n  void appendScopeEnd(const VarDecl *VD, const Stmt *S, BumpVectorContext &C) {\n    Elements.push_back(CFGScopeEnd(VD, S), C);\n  }\n\n  void prependScopeEnd(const VarDecl *VD, const Stmt *S, BumpVectorContext &C) {\n    Elements.insert(Elements.rbegin(), 1, CFGScopeEnd(VD, S), C);\n  }\n\n  void appendBaseDtor(const CXXBaseSpecifier *BS, BumpVectorContext &C) {\n    Elements.push_back(CFGBaseDtor(BS), C);\n  }\n\n  void appendMemberDtor(FieldDecl *FD, BumpVectorContext &C) {\n    Elements.push_back(CFGMemberDtor(FD), C);\n  }\n\n  void appendTemporaryDtor(CXXBindTemporaryExpr *E, BumpVectorContext &C) {\n    Elements.push_back(CFGTemporaryDtor(E), C);\n  }\n\n  void appendAutomaticObjDtor(VarDecl *VD, Stmt *S, BumpVectorContext &C) {\n    Elements.push_back(CFGAutomaticObjDtor(VD, S), C);\n  }\n\n  void appendLifetimeEnds(VarDecl *VD, Stmt *S, BumpVectorContext &C) {\n    Elements.push_back(CFGLifetimeEnds(VD, S), C);\n  }\n\n  void appendLoopExit(const Stmt *LoopStmt, BumpVectorContext &C) {\n    Elements.push_back(CFGLoopExit(LoopStmt), C);\n  }\n\n  void appendDeleteDtor(CXXRecordDecl *RD, CXXDeleteExpr *DE, BumpVectorContext &C) {\n    Elements.push_back(CFGDeleteDtor(RD, DE), C);\n  }\n\n  // Destructors must be inserted in reversed order. So insertion is in two\n  // steps. First we prepare space for some number of elements, then we insert\n  // the elements beginning at the last position in prepared space.\n  iterator beginAutomaticObjDtorsInsert(iterator I, size_t Cnt,\n      BumpVectorContext &C) {\n    return iterator(Elements.insert(I.base(), Cnt,\n                                    CFGAutomaticObjDtor(nullptr, nullptr), C));\n  }\n  iterator insertAutomaticObjDtor(iterator I, VarDecl *VD, Stmt *S) {\n    *I = CFGAutomaticObjDtor(VD, S);\n    return ++I;\n  }\n\n  // Scope leaving must be performed in reversed order. So insertion is in two\n  // steps. First we prepare space for some number of elements, then we insert\n  // the elements beginning at the last position in prepared space.\n  iterator beginLifetimeEndsInsert(iterator I, size_t Cnt,\n                                   BumpVectorContext &C) {\n    return iterator(\n        Elements.insert(I.base(), Cnt, CFGLifetimeEnds(nullptr, nullptr), C));\n  }\n  iterator insertLifetimeEnds(iterator I, VarDecl *VD, Stmt *S) {\n    *I = CFGLifetimeEnds(VD, S);\n    return ++I;\n  }\n\n  // Scope leaving must be performed in reversed order. So insertion is in two\n  // steps. First we prepare space for some number of elements, then we insert\n  // the elements beginning at the last position in prepared space.\n  iterator beginScopeEndInsert(iterator I, size_t Cnt, BumpVectorContext &C) {\n    return iterator(\n        Elements.insert(I.base(), Cnt, CFGScopeEnd(nullptr, nullptr), C));\n  }\n  iterator insertScopeEnd(iterator I, VarDecl *VD, Stmt *S) {\n    *I = CFGScopeEnd(VD, S);\n    return ++I;\n  }\n};\n\n/// CFGCallback defines methods that should be called when a logical\n/// operator error is found when building the CFG.\nclass CFGCallback {\npublic:\n  CFGCallback() = default;\n  virtual ~CFGCallback() = default;\n\n  virtual void compareAlwaysTrue(const BinaryOperator *B, bool isAlwaysTrue) {}\n  virtual void compareBitwiseEquality(const BinaryOperator *B,\n                                      bool isAlwaysTrue) {}\n  virtual void compareBitwiseOr(const BinaryOperator *B) {}\n};\n\n/// Represents a source-level, intra-procedural CFG that represents the\n///  control-flow of a Stmt.  The Stmt can represent an entire function body,\n///  or a single expression.  A CFG will always contain one empty block that\n///  represents the Exit point of the CFG.  A CFG will also contain a designated\n///  Entry block.  The CFG solely represents control-flow; it consists of\n///  CFGBlocks which are simply containers of Stmt*'s in the AST the CFG\n///  was constructed from.\nclass CFG {\npublic:\n  //===--------------------------------------------------------------------===//\n  // CFG Construction & Manipulation.\n  //===--------------------------------------------------------------------===//\n\n  class BuildOptions {\n    std::bitset<Stmt::lastStmtConstant> alwaysAddMask;\n\n  public:\n    using ForcedBlkExprs = llvm::DenseMap<const Stmt *, const CFGBlock *>;\n\n    ForcedBlkExprs **forcedBlkExprs = nullptr;\n    CFGCallback *Observer = nullptr;\n    bool PruneTriviallyFalseEdges = true;\n    bool AddEHEdges = false;\n    bool AddInitializers = false;\n    bool AddImplicitDtors = false;\n    bool AddLifetime = false;\n    bool AddLoopExit = false;\n    bool AddTemporaryDtors = false;\n    bool AddScopes = false;\n    bool AddStaticInitBranches = false;\n    bool AddCXXNewAllocator = false;\n    bool AddCXXDefaultInitExprInCtors = false;\n    bool AddCXXDefaultInitExprInAggregates = false;\n    bool AddRichCXXConstructors = false;\n    bool MarkElidedCXXConstructors = false;\n    bool AddVirtualBaseBranches = false;\n    bool OmitImplicitValueInitializers = false;\n\n    BuildOptions() = default;\n\n    bool alwaysAdd(const Stmt *stmt) const {\n      return alwaysAddMask[stmt->getStmtClass()];\n    }\n\n    BuildOptions &setAlwaysAdd(Stmt::StmtClass stmtClass, bool val = true) {\n      alwaysAddMask[stmtClass] = val;\n      return *this;\n    }\n\n    BuildOptions &setAllAlwaysAdd() {\n      alwaysAddMask.set();\n      return *this;\n    }\n  };\n\n  /// Builds a CFG from an AST.\n  static std::unique_ptr<CFG> buildCFG(const Decl *D, Stmt *AST, ASTContext *C,\n                                       const BuildOptions &BO);\n\n  /// Create a new block in the CFG. The CFG owns the block; the caller should\n  /// not directly free it.\n  CFGBlock *createBlock();\n\n  /// Set the entry block of the CFG. This is typically used only during CFG\n  /// construction. Most CFG clients expect that the entry block has no\n  /// predecessors and contains no statements.\n  void setEntry(CFGBlock *B) { Entry = B; }\n\n  /// Set the block used for indirect goto jumps. This is typically used only\n  /// during CFG construction.\n  void setIndirectGotoBlock(CFGBlock *B) { IndirectGotoBlock = B; }\n\n  //===--------------------------------------------------------------------===//\n  // Block Iterators\n  //===--------------------------------------------------------------------===//\n\n  using CFGBlockListTy = BumpVector<CFGBlock *>;\n  using iterator = CFGBlockListTy::iterator;\n  using const_iterator = CFGBlockListTy::const_iterator;\n  using reverse_iterator = std::reverse_iterator<iterator>;\n  using const_reverse_iterator = std::reverse_iterator<const_iterator>;\n\n  CFGBlock &                front()                { return *Blocks.front(); }\n  CFGBlock &                back()                 { return *Blocks.back(); }\n\n  iterator                  begin()                { return Blocks.begin(); }\n  iterator                  end()                  { return Blocks.end(); }\n  const_iterator            begin()       const    { return Blocks.begin(); }\n  const_iterator            end()         const    { return Blocks.end(); }\n\n  iterator nodes_begin() { return iterator(Blocks.begin()); }\n  iterator nodes_end() { return iterator(Blocks.end()); }\n\n  llvm::iterator_range<iterator> nodes() { return {begin(), end()}; }\n  llvm::iterator_range<const_iterator> const_nodes() const {\n    return {begin(), end()};\n  }\n\n  const_iterator nodes_begin() const { return const_iterator(Blocks.begin()); }\n  const_iterator nodes_end() const { return const_iterator(Blocks.end()); }\n\n  reverse_iterator          rbegin()               { return Blocks.rbegin(); }\n  reverse_iterator          rend()                 { return Blocks.rend(); }\n  const_reverse_iterator    rbegin()      const    { return Blocks.rbegin(); }\n  const_reverse_iterator    rend()        const    { return Blocks.rend(); }\n\n  llvm::iterator_range<reverse_iterator> reverse_nodes() {\n    return {rbegin(), rend()};\n  }\n  llvm::iterator_range<const_reverse_iterator> const_reverse_nodes() const {\n    return {rbegin(), rend()};\n  }\n\n  CFGBlock &                getEntry()             { return *Entry; }\n  const CFGBlock &          getEntry()    const    { return *Entry; }\n  CFGBlock &                getExit()              { return *Exit; }\n  const CFGBlock &          getExit()     const    { return *Exit; }\n\n  CFGBlock *       getIndirectGotoBlock() { return IndirectGotoBlock; }\n  const CFGBlock * getIndirectGotoBlock() const { return IndirectGotoBlock; }\n\n  using try_block_iterator = std::vector<const CFGBlock *>::const_iterator;\n\n  try_block_iterator try_blocks_begin() const {\n    return TryDispatchBlocks.begin();\n  }\n\n  try_block_iterator try_blocks_end() const {\n    return TryDispatchBlocks.end();\n  }\n\n  void addTryDispatchBlock(const CFGBlock *block) {\n    TryDispatchBlocks.push_back(block);\n  }\n\n  /// Records a synthetic DeclStmt and the DeclStmt it was constructed from.\n  ///\n  /// The CFG uses synthetic DeclStmts when a single AST DeclStmt contains\n  /// multiple decls.\n  void addSyntheticDeclStmt(const DeclStmt *Synthetic,\n                            const DeclStmt *Source) {\n    assert(Synthetic->isSingleDecl() && \"Can handle single declarations only\");\n    assert(Synthetic != Source && \"Don't include original DeclStmts in map\");\n    assert(!SyntheticDeclStmts.count(Synthetic) && \"Already in map\");\n    SyntheticDeclStmts[Synthetic] = Source;\n  }\n\n  using synthetic_stmt_iterator =\n      llvm::DenseMap<const DeclStmt *, const DeclStmt *>::const_iterator;\n  using synthetic_stmt_range = llvm::iterator_range<synthetic_stmt_iterator>;\n\n  /// Iterates over synthetic DeclStmts in the CFG.\n  ///\n  /// Each element is a (synthetic statement, source statement) pair.\n  ///\n  /// \\sa addSyntheticDeclStmt\n  synthetic_stmt_iterator synthetic_stmt_begin() const {\n    return SyntheticDeclStmts.begin();\n  }\n\n  /// \\sa synthetic_stmt_begin\n  synthetic_stmt_iterator synthetic_stmt_end() const {\n    return SyntheticDeclStmts.end();\n  }\n\n  /// \\sa synthetic_stmt_begin\n  synthetic_stmt_range synthetic_stmts() const {\n    return synthetic_stmt_range(synthetic_stmt_begin(), synthetic_stmt_end());\n  }\n\n  //===--------------------------------------------------------------------===//\n  // Member templates useful for various batch operations over CFGs.\n  //===--------------------------------------------------------------------===//\n\n  template <typename CALLBACK>\n  void VisitBlockStmts(CALLBACK& O) const {\n    for (const_iterator I = begin(), E = end(); I != E; ++I)\n      for (CFGBlock::const_iterator BI = (*I)->begin(), BE = (*I)->end();\n           BI != BE; ++BI) {\n        if (Optional<CFGStmt> stmt = BI->getAs<CFGStmt>())\n          O(const_cast<Stmt*>(stmt->getStmt()));\n      }\n  }\n\n  //===--------------------------------------------------------------------===//\n  // CFG Introspection.\n  //===--------------------------------------------------------------------===//\n\n  /// Returns the total number of BlockIDs allocated (which start at 0).\n  unsigned getNumBlockIDs() const { return NumBlockIDs; }\n\n  /// Return the total number of CFGBlocks within the CFG This is simply a\n  /// renaming of the getNumBlockIDs(). This is necessary because the dominator\n  /// implementation needs such an interface.\n  unsigned size() const { return NumBlockIDs; }\n\n  /// Returns true if the CFG has no branches. Usually it boils down to the CFG\n  /// having exactly three blocks (entry, the actual code, exit), but sometimes\n  /// more blocks appear due to having control flow that can be fully\n  /// resolved in compile time.\n  bool isLinear() const;\n\n  //===--------------------------------------------------------------------===//\n  // CFG Debugging: Pretty-Printing and Visualization.\n  //===--------------------------------------------------------------------===//\n\n  void viewCFG(const LangOptions &LO) const;\n  void print(raw_ostream &OS, const LangOptions &LO, bool ShowColors) const;\n  void dump(const LangOptions &LO, bool ShowColors) const;\n\n  //===--------------------------------------------------------------------===//\n  // Internal: constructors and data.\n  //===--------------------------------------------------------------------===//\n\n  CFG() : Blocks(BlkBVC, 10) {}\n\n  llvm::BumpPtrAllocator& getAllocator() {\n    return BlkBVC.getAllocator();\n  }\n\n  BumpVectorContext &getBumpVectorContext() {\n    return BlkBVC;\n  }\n\nprivate:\n  CFGBlock *Entry = nullptr;\n  CFGBlock *Exit = nullptr;\n\n  // Special block to contain collective dispatch for indirect gotos\n  CFGBlock* IndirectGotoBlock = nullptr;\n\n  unsigned  NumBlockIDs = 0;\n\n  BumpVectorContext BlkBVC;\n\n  CFGBlockListTy Blocks;\n\n  /// C++ 'try' statements are modeled with an indirect dispatch block.\n  /// This is the collection of such blocks present in the CFG.\n  std::vector<const CFGBlock *> TryDispatchBlocks;\n\n  /// Collects DeclStmts synthesized for this CFG and maps each one back to its\n  /// source DeclStmt.\n  llvm::DenseMap<const DeclStmt *, const DeclStmt *> SyntheticDeclStmts;\n};\n\n} // namespace clang\n\n//===----------------------------------------------------------------------===//\n// GraphTraits specializations for CFG basic block graphs (source-level CFGs)\n//===----------------------------------------------------------------------===//\n\nnamespace llvm {\n\n/// Implement simplify_type for CFGTerminator, so that we can dyn_cast from\n/// CFGTerminator to a specific Stmt class.\ntemplate <> struct simplify_type< ::clang::CFGTerminator> {\n  using SimpleType = ::clang::Stmt *;\n\n  static SimpleType getSimplifiedValue(::clang::CFGTerminator Val) {\n    return Val.getStmt();\n  }\n};\n\n// Traits for: CFGBlock\n\ntemplate <> struct GraphTraits< ::clang::CFGBlock *> {\n  using NodeRef = ::clang::CFGBlock *;\n  using ChildIteratorType = ::clang::CFGBlock::succ_iterator;\n\n  static NodeRef getEntryNode(::clang::CFGBlock *BB) { return BB; }\n  static ChildIteratorType child_begin(NodeRef N) { return N->succ_begin(); }\n  static ChildIteratorType child_end(NodeRef N) { return N->succ_end(); }\n};\n\ntemplate <> struct GraphTraits<clang::CFGBlock>\n    : GraphTraits<clang::CFGBlock *> {};\n\ntemplate <> struct GraphTraits< const ::clang::CFGBlock *> {\n  using NodeRef = const ::clang::CFGBlock *;\n  using ChildIteratorType = ::clang::CFGBlock::const_succ_iterator;\n\n  static NodeRef getEntryNode(const clang::CFGBlock *BB) { return BB; }\n  static ChildIteratorType child_begin(NodeRef N) { return N->succ_begin(); }\n  static ChildIteratorType child_end(NodeRef N) { return N->succ_end(); }\n};\n\ntemplate <> struct GraphTraits<const clang::CFGBlock>\n    : GraphTraits<clang::CFGBlock *> {};\n\ntemplate <> struct GraphTraits<Inverse< ::clang::CFGBlock *>> {\n  using NodeRef = ::clang::CFGBlock *;\n  using ChildIteratorType = ::clang::CFGBlock::const_pred_iterator;\n\n  static NodeRef getEntryNode(Inverse<::clang::CFGBlock *> G) {\n    return G.Graph;\n  }\n\n  static ChildIteratorType child_begin(NodeRef N) { return N->pred_begin(); }\n  static ChildIteratorType child_end(NodeRef N) { return N->pred_end(); }\n};\n\ntemplate <> struct GraphTraits<Inverse<clang::CFGBlock>>\n    : GraphTraits<clang::CFGBlock *> {};\n\ntemplate <> struct GraphTraits<Inverse<const ::clang::CFGBlock *>> {\n  using NodeRef = const ::clang::CFGBlock *;\n  using ChildIteratorType = ::clang::CFGBlock::const_pred_iterator;\n\n  static NodeRef getEntryNode(Inverse<const ::clang::CFGBlock *> G) {\n    return G.Graph;\n  }\n\n  static ChildIteratorType child_begin(NodeRef N) { return N->pred_begin(); }\n  static ChildIteratorType child_end(NodeRef N) { return N->pred_end(); }\n};\n\ntemplate <> struct GraphTraits<const Inverse<clang::CFGBlock>>\n    : GraphTraits<clang::CFGBlock *> {};\n\n// Traits for: CFG\n\ntemplate <> struct GraphTraits< ::clang::CFG* >\n    : public GraphTraits< ::clang::CFGBlock *>  {\n  using nodes_iterator = ::clang::CFG::iterator;\n\n  static NodeRef getEntryNode(::clang::CFG *F) { return &F->getEntry(); }\n  static nodes_iterator nodes_begin(::clang::CFG* F) { return F->nodes_begin();}\n  static nodes_iterator   nodes_end(::clang::CFG* F) { return F->nodes_end(); }\n  static unsigned              size(::clang::CFG* F) { return F->size(); }\n};\n\ntemplate <> struct GraphTraits<const ::clang::CFG* >\n    : public GraphTraits<const ::clang::CFGBlock *>  {\n  using nodes_iterator = ::clang::CFG::const_iterator;\n\n  static NodeRef getEntryNode(const ::clang::CFG *F) { return &F->getEntry(); }\n\n  static nodes_iterator nodes_begin( const ::clang::CFG* F) {\n    return F->nodes_begin();\n  }\n\n  static nodes_iterator nodes_end( const ::clang::CFG* F) {\n    return F->nodes_end();\n  }\n\n  static unsigned size(const ::clang::CFG* F) {\n    return F->size();\n  }\n};\n\ntemplate <> struct GraphTraits<Inverse< ::clang::CFG *>>\n  : public GraphTraits<Inverse< ::clang::CFGBlock *>> {\n  using nodes_iterator = ::clang::CFG::iterator;\n\n  static NodeRef getEntryNode(::clang::CFG *F) { return &F->getExit(); }\n  static nodes_iterator nodes_begin( ::clang::CFG* F) {return F->nodes_begin();}\n  static nodes_iterator nodes_end( ::clang::CFG* F) { return F->nodes_end(); }\n};\n\ntemplate <> struct GraphTraits<Inverse<const ::clang::CFG *>>\n  : public GraphTraits<Inverse<const ::clang::CFGBlock *>> {\n  using nodes_iterator = ::clang::CFG::const_iterator;\n\n  static NodeRef getEntryNode(const ::clang::CFG *F) { return &F->getExit(); }\n\n  static nodes_iterator nodes_begin(const ::clang::CFG* F) {\n    return F->nodes_begin();\n  }\n\n  static nodes_iterator nodes_end(const ::clang::CFG* F) {\n    return F->nodes_end();\n  }\n};\n\n} // namespace llvm\n\n#endif // LLVM_CLANG_ANALYSIS_CFG_H\n"}, "16": {"id": 16, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Analysis/ConstructionContext.h", "content": "//===- ConstructionContext.h - CFG constructor information ------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file defines the ConstructionContext class and its sub-classes,\n// which represent various different ways of constructing C++ objects\n// with the additional information the users may want to know about\n// the constructor.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_ANALYSIS_CONSTRUCTIONCONTEXT_H\n#define LLVM_CLANG_ANALYSIS_CONSTRUCTIONCONTEXT_H\n\n#include \"clang/Analysis/Support/BumpVector.h\"\n#include \"clang/AST/ExprCXX.h\"\n#include \"clang/AST/ExprObjC.h\"\n\nnamespace clang {\n\n/// Represents a single point (AST node) in the program that requires attention\n/// during construction of an object. ConstructionContext would be represented\n/// as a list of such items.\nclass ConstructionContextItem {\npublic:\n  enum ItemKind {\n    VariableKind,\n    NewAllocatorKind,\n    ReturnKind,\n    MaterializationKind,\n    TemporaryDestructorKind,\n    ElidedDestructorKind,\n    ElidableConstructorKind,\n    ArgumentKind,\n    STATEMENT_WITH_INDEX_KIND_BEGIN=ArgumentKind,\n    STATEMENT_WITH_INDEX_KIND_END=ArgumentKind,\n    STATEMENT_KIND_BEGIN = VariableKind,\n    STATEMENT_KIND_END = ArgumentKind,\n    InitializerKind,\n    INITIALIZER_KIND_BEGIN=InitializerKind,\n    INITIALIZER_KIND_END=InitializerKind\n  };\n\n  LLVM_DUMP_METHOD static StringRef getKindAsString(ItemKind K) {\n    switch (K) {\n      case VariableKind:            return \"construct into local variable\";\n      case NewAllocatorKind:        return \"construct into new-allocator\";\n      case ReturnKind:              return \"construct into return address\";\n      case MaterializationKind:     return \"materialize temporary\";\n      case TemporaryDestructorKind: return \"destroy temporary\";\n      case ElidedDestructorKind:    return \"elide destructor\";\n      case ElidableConstructorKind: return \"elide constructor\";\n      case ArgumentKind:            return \"construct into argument\";\n      case InitializerKind:         return \"construct into member variable\";\n    };\n    llvm_unreachable(\"Unknown ItemKind\");\n  }\n\nprivate:\n  const void *const Data;\n  const ItemKind Kind;\n  const unsigned Index = 0;\n\n  bool hasStatement() const {\n    return Kind >= STATEMENT_KIND_BEGIN &&\n           Kind <= STATEMENT_KIND_END;\n  }\n\n  bool hasIndex() const {\n    return Kind >= STATEMENT_WITH_INDEX_KIND_BEGIN &&\n           Kind >= STATEMENT_WITH_INDEX_KIND_END;\n  }\n\n  bool hasInitializer() const {\n    return Kind >= INITIALIZER_KIND_BEGIN &&\n           Kind <= INITIALIZER_KIND_END;\n  }\n\npublic:\n  // ConstructionContextItem should be simple enough so that it was easy to\n  // re-construct it from the AST node it captures. For that reason we provide\n  // simple implicit conversions from all sorts of supported AST nodes.\n  ConstructionContextItem(const DeclStmt *DS)\n      : Data(DS), Kind(VariableKind) {}\n\n  ConstructionContextItem(const CXXNewExpr *NE)\n      : Data(NE), Kind(NewAllocatorKind) {}\n\n  ConstructionContextItem(const ReturnStmt *RS)\n      : Data(RS), Kind(ReturnKind) {}\n\n  ConstructionContextItem(const MaterializeTemporaryExpr *MTE)\n      : Data(MTE), Kind(MaterializationKind) {}\n\n  ConstructionContextItem(const CXXBindTemporaryExpr *BTE,\n                          bool IsElided = false)\n      : Data(BTE),\n        Kind(IsElided ? ElidedDestructorKind : TemporaryDestructorKind) {}\n\n  ConstructionContextItem(const CXXConstructExpr *CE)\n      : Data(CE), Kind(ElidableConstructorKind) {}\n\n  ConstructionContextItem(const CallExpr *CE, unsigned Index)\n      : Data(CE), Kind(ArgumentKind), Index(Index) {}\n\n  ConstructionContextItem(const CXXConstructExpr *CE, unsigned Index)\n      : Data(CE), Kind(ArgumentKind), Index(Index) {}\n\n  ConstructionContextItem(const CXXInheritedCtorInitExpr *CE, unsigned Index)\n      : Data(CE), Kind(ArgumentKind), Index(Index) {}\n\n  ConstructionContextItem(const ObjCMessageExpr *ME, unsigned Index)\n      : Data(ME), Kind(ArgumentKind), Index(Index) {}\n\n  // A polymorphic version of the previous calls with dynamic type check.\n  ConstructionContextItem(const Expr *E, unsigned Index)\n      : Data(E), Kind(ArgumentKind), Index(Index) {\n    assert(isa<CallExpr>(E) || isa<CXXConstructExpr>(E) ||\n           isa<CXXInheritedCtorInitExpr>(E) || isa<ObjCMessageExpr>(E));\n  }\n\n  ConstructionContextItem(const CXXCtorInitializer *Init)\n      : Data(Init), Kind(InitializerKind), Index(0) {}\n\n  ItemKind getKind() const { return Kind; }\n\n  LLVM_DUMP_METHOD StringRef getKindAsString() const {\n    return getKindAsString(getKind());\n  }\n\n  /// The construction site - the statement that triggered the construction\n  /// for one of its parts. For instance, stack variable declaration statement\n  /// triggers construction of itself or its elements if it's an array,\n  /// new-expression triggers construction of the newly allocated object(s).\n  const Stmt *getStmt() const {\n    assert(hasStatement());\n    return static_cast<const Stmt *>(Data);\n  }\n\n  const Stmt *getStmtOrNull() const {\n    return hasStatement() ? getStmt() : nullptr;\n  }\n\n  /// The construction site is not necessarily a statement. It may also be a\n  /// CXXCtorInitializer, which means that a member variable is being\n  /// constructed during initialization of the object that contains it.\n  const CXXCtorInitializer *getCXXCtorInitializer() const {\n    assert(hasInitializer());\n    return static_cast<const CXXCtorInitializer *>(Data);\n  }\n\n  /// If a single trigger statement triggers multiple constructors, they are\n  /// usually being enumerated. This covers function argument constructors\n  /// triggered by a call-expression and items in an initializer list triggered\n  /// by an init-list-expression.\n  unsigned getIndex() const {\n    // This is a fairly specific request. Let's make sure the user knows\n    // what he's doing.\n    assert(hasIndex());\n    return Index;\n  }\n\n  void Profile(llvm::FoldingSetNodeID &ID) const {\n    ID.AddPointer(Data);\n    ID.AddInteger(Kind);\n    ID.AddInteger(Index);\n  }\n\n  bool operator==(const ConstructionContextItem &Other) const {\n    // For most kinds the Index comparison is trivially true, but\n    // checking kind separately doesn't seem to be less expensive\n    // than checking Index. Same in operator<().\n    return std::make_tuple(Data, Kind, Index) ==\n           std::make_tuple(Other.Data, Other.Kind, Other.Index);\n  }\n\n  bool operator<(const ConstructionContextItem &Other) const {\n    return std::make_tuple(Data, Kind, Index) <\n           std::make_tuple(Other.Data, Other.Kind, Other.Index);\n  }\n};\n\n/// Construction context can be seen as a linked list of multiple layers.\n/// Sometimes a single trigger is not enough to describe the construction\n/// site. That's what causing us to have a chain of \"partial\" construction\n/// context layers. Some examples:\n/// - A constructor within in an aggregate initializer list within a variable\n///   would have a construction context of the initializer list with\n///   the parent construction context of a variable.\n/// - A constructor for a temporary that needs to be both destroyed\n///   and materialized into an elidable copy constructor would have a\n///   construction context of a CXXBindTemporaryExpr with the parent\n///   construction context of a MaterializeTemproraryExpr.\n/// Not all of these are currently supported.\n/// Layers are created gradually while traversing the AST, and layers that\n/// represent the outmost AST nodes are built first, while the node that\n/// immediately contains the constructor would be built last and capture the\n/// previous layers as its parents. Construction context captures the last layer\n/// (which has links to the previous layers) and classifies the seemingly\n/// arbitrary chain of layers into one of the possible ways of constructing\n/// an object in C++ for user-friendly experience.\nclass ConstructionContextLayer {\n  const ConstructionContextLayer *Parent = nullptr;\n  ConstructionContextItem Item;\n\n  ConstructionContextLayer(ConstructionContextItem Item,\n                           const ConstructionContextLayer *Parent)\n      : Parent(Parent), Item(Item) {}\n\npublic:\n  static const ConstructionContextLayer *\n  create(BumpVectorContext &C, const ConstructionContextItem &Item,\n         const ConstructionContextLayer *Parent = nullptr);\n\n  const ConstructionContextItem &getItem() const { return Item; }\n  const ConstructionContextLayer *getParent() const { return Parent; }\n  bool isLast() const { return !Parent; }\n\n  /// See if Other is a proper initial segment of this construction context\n  /// in terms of the parent chain - i.e. a few first parents coincide and\n  /// then the other context terminates but our context goes further - i.e.,\n  /// we are providing the same context that the other context provides,\n  /// and a bit more above that.\n  bool isStrictlyMoreSpecificThan(const ConstructionContextLayer *Other) const;\n};\n\n\n/// ConstructionContext's subclasses describe different ways of constructing\n/// an object in C++. The context re-captures the essential parent AST nodes\n/// of the CXXConstructExpr it is assigned to and presents these nodes\n/// through easy-to-understand accessor methods.\nclass ConstructionContext {\npublic:\n  enum Kind {\n    SimpleVariableKind,\n    CXX17ElidedCopyVariableKind,\n    VARIABLE_BEGIN = SimpleVariableKind,\n    VARIABLE_END = CXX17ElidedCopyVariableKind,\n    SimpleConstructorInitializerKind,\n    CXX17ElidedCopyConstructorInitializerKind,\n    INITIALIZER_BEGIN = SimpleConstructorInitializerKind,\n    INITIALIZER_END = CXX17ElidedCopyConstructorInitializerKind,\n    NewAllocatedObjectKind,\n    SimpleTemporaryObjectKind,\n    ElidedTemporaryObjectKind,\n    TEMPORARY_BEGIN = SimpleTemporaryObjectKind,\n    TEMPORARY_END = ElidedTemporaryObjectKind,\n    SimpleReturnedValueKind,\n    CXX17ElidedCopyReturnedValueKind,\n    RETURNED_VALUE_BEGIN = SimpleReturnedValueKind,\n    RETURNED_VALUE_END = CXX17ElidedCopyReturnedValueKind,\n    ArgumentKind\n  };\n\nprotected:\n  Kind K;\n\n  // Do not make public! These need to only be constructed\n  // via createFromLayers().\n  explicit ConstructionContext(Kind K) : K(K) {}\n\nprivate:\n  // A helper function for constructing an instance into a bump vector context.\n  template <typename T, typename... ArgTypes>\n  static T *create(BumpVectorContext &C, ArgTypes... Args) {\n    auto *CC = C.getAllocator().Allocate<T>();\n    return new (CC) T(Args...);\n  }\n\n  // A sub-routine of createFromLayers() that deals with temporary objects\n  // that need to be materialized. The BTE argument is for the situation when\n  // the object also needs to be bound for destruction.\n  static const ConstructionContext *createMaterializedTemporaryFromLayers(\n      BumpVectorContext &C, const MaterializeTemporaryExpr *MTE,\n      const CXXBindTemporaryExpr *BTE,\n      const ConstructionContextLayer *ParentLayer);\n\n  // A sub-routine of createFromLayers() that deals with temporary objects\n  // that need to be bound for destruction. Automatically finds out if the\n  // object also needs to be materialized and delegates to\n  // createMaterializedTemporaryFromLayers() if necessary.\n  static const ConstructionContext *\n  createBoundTemporaryFromLayers(\n      BumpVectorContext &C, const CXXBindTemporaryExpr *BTE,\n      const ConstructionContextLayer *ParentLayer);\n\npublic:\n  /// Consume the construction context layer, together with its parent layers,\n  /// and wrap it up into a complete construction context. May return null\n  /// if layers do not form any supported construction context.\n  static const ConstructionContext *\n  createFromLayers(BumpVectorContext &C,\n                   const ConstructionContextLayer *TopLayer);\n\n  Kind getKind() const { return K; }\n};\n\n/// An abstract base class for local variable constructors.\nclass VariableConstructionContext : public ConstructionContext {\n  const DeclStmt *DS;\n\nprotected:\n  VariableConstructionContext(ConstructionContext::Kind K, const DeclStmt *DS)\n      : ConstructionContext(K), DS(DS) {\n    assert(classof(this));\n    assert(DS);\n  }\n\npublic:\n  const DeclStmt *getDeclStmt() const { return DS; }\n\n  static bool classof(const ConstructionContext *CC) {\n    return CC->getKind() >= VARIABLE_BEGIN &&\n           CC->getKind() <= VARIABLE_END;\n  }\n};\n\n/// Represents construction into a simple local variable, eg. T var(123);.\n/// If a variable has an initializer, eg. T var = makeT();, then the final\n/// elidable copy-constructor from makeT() into var would also be a simple\n/// variable constructor handled by this class.\nclass SimpleVariableConstructionContext : public VariableConstructionContext {\n  friend class ConstructionContext; // Allows to create<>() itself.\n\n  explicit SimpleVariableConstructionContext(const DeclStmt *DS)\n      : VariableConstructionContext(ConstructionContext::SimpleVariableKind,\n                                    DS) {}\n\npublic:\n  static bool classof(const ConstructionContext *CC) {\n    return CC->getKind() == SimpleVariableKind;\n  }\n};\n\n/// Represents construction into a simple variable with an initializer syntax,\n/// with a single constructor, eg. T var = makeT();. Such construction context\n/// may only appear in C++17 because previously it was split into a temporary\n/// object constructor and an elidable simple variable copy-constructor and\n/// we were producing separate construction contexts for these constructors.\n/// In C++17 we have a single construction context that combines both.\n/// Note that if the object has trivial destructor, then this code is\n/// indistinguishable from a simple variable constructor on the AST level;\n/// in this case we provide a simple variable construction context.\nclass CXX17ElidedCopyVariableConstructionContext\n    : public VariableConstructionContext {\n  const CXXBindTemporaryExpr *BTE;\n\n  friend class ConstructionContext; // Allows to create<>() itself.\n\n  explicit CXX17ElidedCopyVariableConstructionContext(\n      const DeclStmt *DS, const CXXBindTemporaryExpr *BTE)\n      : VariableConstructionContext(CXX17ElidedCopyVariableKind, DS), BTE(BTE) {\n    assert(BTE);\n  }\n\npublic:\n  const CXXBindTemporaryExpr *getCXXBindTemporaryExpr() const { return BTE; }\n\n  static bool classof(const ConstructionContext *CC) {\n    return CC->getKind() == CXX17ElidedCopyVariableKind;\n  }\n};\n\n// An abstract base class for constructor-initializer-based constructors.\nclass ConstructorInitializerConstructionContext : public ConstructionContext {\n  const CXXCtorInitializer *I;\n\nprotected:\n  explicit ConstructorInitializerConstructionContext(\n      ConstructionContext::Kind K, const CXXCtorInitializer *I)\n      : ConstructionContext(K), I(I) {\n    assert(classof(this));\n    assert(I);\n  }\n\npublic:\n  const CXXCtorInitializer *getCXXCtorInitializer() const { return I; }\n\n  static bool classof(const ConstructionContext *CC) {\n    return CC->getKind() >= INITIALIZER_BEGIN &&\n           CC->getKind() <= INITIALIZER_END;\n  }\n};\n\n/// Represents construction into a field or a base class within a bigger object\n/// via a constructor initializer, eg. T(): field(123) { ... }.\nclass SimpleConstructorInitializerConstructionContext\n    : public ConstructorInitializerConstructionContext {\n  friend class ConstructionContext; // Allows to create<>() itself.\n\n  explicit SimpleConstructorInitializerConstructionContext(\n      const CXXCtorInitializer *I)\n      : ConstructorInitializerConstructionContext(\n            ConstructionContext::SimpleConstructorInitializerKind, I) {}\n\npublic:\n  static bool classof(const ConstructionContext *CC) {\n    return CC->getKind() == SimpleConstructorInitializerKind;\n  }\n};\n\n/// Represents construction into a field or a base class within a bigger object\n/// via a constructor initializer, with a single constructor, eg.\n/// T(): field(Field(123)) { ... }. Such construction context may only appear\n/// in C++17 because previously it was split into a temporary object constructor\n/// and an elidable simple constructor-initializer copy-constructor and we were\n/// producing separate construction contexts for these constructors. In C++17\n/// we have a single construction context that combines both. Note that if the\n/// object has trivial destructor, then this code is indistinguishable from\n/// a simple constructor-initializer constructor on the AST level; in this case\n/// we provide a simple constructor-initializer construction context.\nclass CXX17ElidedCopyConstructorInitializerConstructionContext\n    : public ConstructorInitializerConstructionContext {\n  const CXXBindTemporaryExpr *BTE;\n\n  friend class ConstructionContext; // Allows to create<>() itself.\n\n  explicit CXX17ElidedCopyConstructorInitializerConstructionContext(\n      const CXXCtorInitializer *I, const CXXBindTemporaryExpr *BTE)\n      : ConstructorInitializerConstructionContext(\n            CXX17ElidedCopyConstructorInitializerKind, I),\n        BTE(BTE) {\n    assert(BTE);\n  }\n\npublic:\n  const CXXBindTemporaryExpr *getCXXBindTemporaryExpr() const { return BTE; }\n\n  static bool classof(const ConstructionContext *CC) {\n    return CC->getKind() == CXX17ElidedCopyConstructorInitializerKind;\n  }\n};\n\n/// Represents immediate initialization of memory allocated by operator new,\n/// eg. new T(123);.\nclass NewAllocatedObjectConstructionContext : public ConstructionContext {\n  const CXXNewExpr *NE;\n\n  friend class ConstructionContext; // Allows to create<>() itself.\n\n  explicit NewAllocatedObjectConstructionContext(const CXXNewExpr *NE)\n      : ConstructionContext(ConstructionContext::NewAllocatedObjectKind),\n        NE(NE) {\n    assert(NE);\n  }\n\npublic:\n  const CXXNewExpr *getCXXNewExpr() const { return NE; }\n\n  static bool classof(const ConstructionContext *CC) {\n    return CC->getKind() == NewAllocatedObjectKind;\n  }\n};\n\n/// Represents a temporary object, eg. T(123), that does not immediately cross\n/// function boundaries \"by value\"; constructors that construct function\n/// value-type arguments or values that are immediately returned from the\n/// function that returns a value receive separate construction context kinds.\nclass TemporaryObjectConstructionContext : public ConstructionContext {\n  const CXXBindTemporaryExpr *BTE;\n  const MaterializeTemporaryExpr *MTE;\n\nprotected:\n  explicit TemporaryObjectConstructionContext(\n      ConstructionContext::Kind K, const CXXBindTemporaryExpr *BTE,\n      const MaterializeTemporaryExpr *MTE)\n      : ConstructionContext(K), BTE(BTE), MTE(MTE) {\n    // Both BTE and MTE can be null here, all combinations possible.\n    // Even though for now at least one should be non-null, we simply haven't\n    // implemented the other case yet (this would be a temporary in the middle\n    // of nowhere that doesn't have a non-trivial destructor).\n  }\n\npublic:\n  /// CXXBindTemporaryExpr here is non-null as long as the temporary has\n  /// a non-trivial destructor.\n  const CXXBindTemporaryExpr *getCXXBindTemporaryExpr() const {\n    return BTE;\n  }\n\n  /// MaterializeTemporaryExpr is non-null as long as the temporary is actually\n  /// used after construction, eg. by binding to a reference (lifetime\n  /// extension), accessing a field, calling a method, or passing it into\n  /// a function (an elidable copy or move constructor would be a common\n  /// example) by reference.\n  const MaterializeTemporaryExpr *getMaterializedTemporaryExpr() const {\n    return MTE;\n  }\n\n  static bool classof(const ConstructionContext *CC) {\n    return CC->getKind() >= TEMPORARY_BEGIN && CC->getKind() <= TEMPORARY_END;\n  }\n};\n\n/// Represents a temporary object that is not constructed for the purpose of\n/// being immediately copied/moved by an elidable copy/move-constructor.\n/// This includes temporary objects \"in the middle of nowhere\" like T(123) and\n/// lifetime-extended temporaries.\nclass SimpleTemporaryObjectConstructionContext\n    : public TemporaryObjectConstructionContext {\n  friend class ConstructionContext; // Allows to create<>() itself.\n\n  explicit SimpleTemporaryObjectConstructionContext(\n      const CXXBindTemporaryExpr *BTE, const MaterializeTemporaryExpr *MTE)\n      : TemporaryObjectConstructionContext(\n            ConstructionContext::SimpleTemporaryObjectKind, BTE, MTE) {}\n\npublic:\n  static bool classof(const ConstructionContext *CC) {\n    return CC->getKind() == SimpleTemporaryObjectKind;\n  }\n};\n\n/// Represents a temporary object that is constructed for the sole purpose\n/// of being immediately copied by an elidable copy/move constructor.\n/// For example, T t = T(123); includes a temporary T(123) that is immediately\n/// copied to variable t. In such cases the elidable copy can (but not\n/// necessarily should) be omitted (\"elided\") accodring to the rules of the\n/// language; the constructor would then construct variable t directly.\n/// This construction context contains information of the elidable constructor\n/// and its respective construction context.\nclass ElidedTemporaryObjectConstructionContext\n    : public TemporaryObjectConstructionContext {\n  const CXXConstructExpr *ElidedCE;\n  const ConstructionContext *ElidedCC;\n\n  friend class ConstructionContext; // Allows to create<>() itself.\n\n  explicit ElidedTemporaryObjectConstructionContext(\n      const CXXBindTemporaryExpr *BTE, const MaterializeTemporaryExpr *MTE,\n      const CXXConstructExpr *ElidedCE, const ConstructionContext *ElidedCC)\n      : TemporaryObjectConstructionContext(\n            ConstructionContext::ElidedTemporaryObjectKind, BTE, MTE),\n        ElidedCE(ElidedCE), ElidedCC(ElidedCC) {\n    // Elided constructor and its context should be either both specified\n    // or both unspecified. In the former case, the constructor must be\n    // elidable.\n    assert(ElidedCE && ElidedCE->isElidable() && ElidedCC);\n  }\n\npublic:\n  const CXXConstructExpr *getConstructorAfterElision() const {\n    return ElidedCE;\n  }\n\n  const ConstructionContext *getConstructionContextAfterElision() const {\n    return ElidedCC;\n  }\n\n  static bool classof(const ConstructionContext *CC) {\n    return CC->getKind() == ElidedTemporaryObjectKind;\n  }\n};\n\nclass ReturnedValueConstructionContext : public ConstructionContext {\n  const ReturnStmt *RS;\n\nprotected:\n  explicit ReturnedValueConstructionContext(ConstructionContext::Kind K,\n                                            const ReturnStmt *RS)\n      : ConstructionContext(K), RS(RS) {\n    assert(classof(this));\n    assert(RS);\n  }\n\npublic:\n  const ReturnStmt *getReturnStmt() const { return RS; }\n\n  static bool classof(const ConstructionContext *CC) {\n    return CC->getKind() >= RETURNED_VALUE_BEGIN &&\n           CC->getKind() <= RETURNED_VALUE_END;\n  }\n};\n\n/// Represents a temporary object that is being immediately returned from a\n/// function by value, eg. return t; or return T(123);. In this case there is\n/// always going to be a constructor at the return site. However, the usual\n/// temporary-related bureaucracy (CXXBindTemporaryExpr,\n/// MaterializeTemporaryExpr) is normally located in the caller function's AST.\nclass SimpleReturnedValueConstructionContext\n    : public ReturnedValueConstructionContext {\n  friend class ConstructionContext; // Allows to create<>() itself.\n\n  explicit SimpleReturnedValueConstructionContext(const ReturnStmt *RS)\n      : ReturnedValueConstructionContext(\n            ConstructionContext::SimpleReturnedValueKind, RS) {}\n\npublic:\n  static bool classof(const ConstructionContext *CC) {\n    return CC->getKind() == SimpleReturnedValueKind;\n  }\n};\n\n/// Represents a temporary object that is being immediately returned from a\n/// function by value, eg. return t; or return T(123); in C++17.\n/// In C++17 there is not going to be an elidable copy constructor at the\n/// return site.  However, the usual temporary-related bureaucracy (CXXBindTemporaryExpr,\n/// MaterializeTemporaryExpr) is normally located in the caller function's AST.\n/// Note that if the object has trivial destructor, then this code is\n/// indistinguishable from a simple returned value constructor on the AST level;\n/// in this case we provide a simple returned value construction context.\nclass CXX17ElidedCopyReturnedValueConstructionContext\n    : public ReturnedValueConstructionContext {\n  const CXXBindTemporaryExpr *BTE;\n\n  friend class ConstructionContext; // Allows to create<>() itself.\n\n  explicit CXX17ElidedCopyReturnedValueConstructionContext(\n      const ReturnStmt *RS, const CXXBindTemporaryExpr *BTE)\n      : ReturnedValueConstructionContext(\n            ConstructionContext::CXX17ElidedCopyReturnedValueKind, RS),\n        BTE(BTE) {\n    assert(BTE);\n  }\n\npublic:\n  const CXXBindTemporaryExpr *getCXXBindTemporaryExpr() const { return BTE; }\n\n  static bool classof(const ConstructionContext *CC) {\n    return CC->getKind() == CXX17ElidedCopyReturnedValueKind;\n  }\n};\n\nclass ArgumentConstructionContext : public ConstructionContext {\n  // The call of which the context is an argument.\n  const Expr *CE;\n\n  // Which argument we're constructing. Note that when numbering between\n  // arguments and parameters is inconsistent (eg., operator calls),\n  // this is the index of the argument, not of the parameter.\n  unsigned Index;\n\n  // Whether the object needs to be destroyed.\n  const CXXBindTemporaryExpr *BTE;\n\n  friend class ConstructionContext; // Allows to create<>() itself.\n\n  explicit ArgumentConstructionContext(const Expr *CE, unsigned Index,\n                                       const CXXBindTemporaryExpr *BTE)\n      : ConstructionContext(ArgumentKind), CE(CE),\n        Index(Index), BTE(BTE) {\n    assert(isa<CallExpr>(CE) || isa<CXXConstructExpr>(CE) ||\n           isa<ObjCMessageExpr>(CE));\n    // BTE is optional.\n  }\n\npublic:\n  const Expr *getCallLikeExpr() const { return CE; }\n  unsigned getIndex() const { return Index; }\n  const CXXBindTemporaryExpr *getCXXBindTemporaryExpr() const { return BTE; }\n\n  static bool classof(const ConstructionContext *CC) {\n    return CC->getKind() == ArgumentKind;\n  }\n};\n\n} // end namespace clang\n\n#endif // LLVM_CLANG_ANALYSIS_CONSTRUCTIONCONTEXT_H\n"}, "17": {"id": 17, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Analysis/ProgramPoint.h", "content": "//==- ProgramPoint.h - Program Points for Path-Sensitive Analysis --*- C++ -*-//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n//  This file defines the interface ProgramPoint, which identifies a\n//  distinct location in a function.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_ANALYSIS_PROGRAMPOINT_H\n#define LLVM_CLANG_ANALYSIS_PROGRAMPOINT_H\n\n#include \"clang/Analysis/AnalysisDeclContext.h\"\n#include \"clang/Analysis/CFG.h\"\n#include \"llvm/ADT/DenseMap.h\"\n#include \"llvm/ADT/FoldingSet.h\"\n#include \"llvm/ADT/Optional.h\"\n#include \"llvm/ADT/PointerIntPair.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/Support/Casting.h\"\n#include \"llvm/Support/DataTypes.h\"\n#include <cassert>\n#include <string>\n#include <utility>\n\nnamespace clang {\n\nclass AnalysisDeclContext;\nclass FunctionDecl;\nclass LocationContext;\n\n/// ProgramPoints can be \"tagged\" as representing points specific to a given\n/// analysis entity.  Tags are abstract annotations, with an associated\n/// description and potentially other information.\nclass ProgramPointTag {\npublic:\n  ProgramPointTag(void *tagKind = nullptr) : TagKind(tagKind) {}\n  virtual ~ProgramPointTag();\n  virtual StringRef getTagDescription() const = 0;\n\n  /// Used to implement 'isKind' in subclasses.\n  const void *getTagKind() const { return TagKind; }\n\nprivate:\n  const void *const TagKind;\n};\n\nclass SimpleProgramPointTag : public ProgramPointTag {\n  std::string Desc;\npublic:\n  SimpleProgramPointTag(StringRef MsgProvider, StringRef Msg);\n  StringRef getTagDescription() const override;\n};\n\nclass ProgramPoint {\npublic:\n  enum Kind { BlockEdgeKind,\n              BlockEntranceKind,\n              BlockExitKind,\n              PreStmtKind,\n              PreStmtPurgeDeadSymbolsKind,\n              PostStmtPurgeDeadSymbolsKind,\n              PostStmtKind,\n              PreLoadKind,\n              PostLoadKind,\n              PreStoreKind,\n              PostStoreKind,\n              PostConditionKind,\n              PostLValueKind,\n              PostAllocatorCallKind,\n              MinPostStmtKind = PostStmtKind,\n              MaxPostStmtKind = PostAllocatorCallKind,\n              PostInitializerKind,\n              CallEnterKind,\n              CallExitBeginKind,\n              CallExitEndKind,\n              FunctionExitKind,\n              PreImplicitCallKind,\n              PostImplicitCallKind,\n              MinImplicitCallKind = PreImplicitCallKind,\n              MaxImplicitCallKind = PostImplicitCallKind,\n              LoopExitKind,\n              EpsilonKind};\n\nprivate:\n  const void *Data1;\n  llvm::PointerIntPair<const void *, 2, unsigned> Data2;\n\n  // The LocationContext could be NULL to allow ProgramPoint to be used in\n  // context insensitive analysis.\n  llvm::PointerIntPair<const LocationContext *, 2, unsigned> L;\n\n  llvm::PointerIntPair<const ProgramPointTag *, 2, unsigned> Tag;\n\nprotected:\n  ProgramPoint() = default;\n  ProgramPoint(const void *P,\n               Kind k,\n               const LocationContext *l,\n               const ProgramPointTag *tag = nullptr)\n    : Data1(P),\n      Data2(nullptr, (((unsigned) k) >> 0) & 0x3),\n      L(l, (((unsigned) k) >> 2) & 0x3),\n      Tag(tag, (((unsigned) k) >> 4) & 0x3) {\n        assert(getKind() == k);\n        assert(getLocationContext() == l);\n        assert(getData1() == P);\n      }\n\n  ProgramPoint(const void *P1,\n               const void *P2,\n               Kind k,\n               const LocationContext *l,\n               const ProgramPointTag *tag = nullptr)\n    : Data1(P1),\n      Data2(P2, (((unsigned) k) >> 0) & 0x3),\n      L(l, (((unsigned) k) >> 2) & 0x3),\n      Tag(tag, (((unsigned) k) >> 4) & 0x3) {}\n\nprotected:\n  const void *getData1() const { return Data1; }\n  const void *getData2() const { return Data2.getPointer(); }\n  void setData2(const void *d) { Data2.setPointer(d); }\n\npublic:\n  /// Create a new ProgramPoint object that is the same as the original\n  /// except for using the specified tag value.\n  ProgramPoint withTag(const ProgramPointTag *tag) const {\n    return ProgramPoint(getData1(), getData2(), getKind(),\n                        getLocationContext(), tag);\n  }\n\n  /// Convert to the specified ProgramPoint type, asserting that this\n  /// ProgramPoint is of the desired type.\n  template<typename T>\n  T castAs() const {\n    assert(T::isKind(*this));\n    T t;\n    ProgramPoint& PP = t;\n    PP = *this;\n    return t;\n  }\n\n  /// Convert to the specified ProgramPoint type, returning None if this\n  /// ProgramPoint is not of the desired type.\n  template<typename T>\n  Optional<T> getAs() const {\n    if (!T::isKind(*this))\n      return None;\n    T t;\n    ProgramPoint& PP = t;\n    PP = *this;\n    return t;\n  }\n\n  Kind getKind() const {\n    unsigned x = Tag.getInt();\n    x <<= 2;\n    x |= L.getInt();\n    x <<= 2;\n    x |= Data2.getInt();\n    return (Kind) x;\n  }\n\n  /// Is this a program point corresponding to purge/removal of dead\n  /// symbols and bindings.\n  bool isPurgeKind() {\n    Kind K = getKind();\n    return (K == PostStmtPurgeDeadSymbolsKind ||\n            K == PreStmtPurgeDeadSymbolsKind);\n  }\n\n  const ProgramPointTag *getTag() const { return Tag.getPointer(); }\n\n  const LocationContext *getLocationContext() const {\n    return L.getPointer();\n  }\n\n  const StackFrameContext *getStackFrame() const {\n    return getLocationContext()->getStackFrame();\n  }\n\n  // For use with DenseMap.  This hash is probably slow.\n  unsigned getHashValue() const {\n    llvm::FoldingSetNodeID ID;\n    Profile(ID);\n    return ID.ComputeHash();\n  }\n\n  bool operator==(const ProgramPoint & RHS) const {\n    return Data1 == RHS.Data1 &&\n           Data2 == RHS.Data2 &&\n           L == RHS.L &&\n           Tag == RHS.Tag;\n  }\n\n  bool operator!=(const ProgramPoint &RHS) const {\n    return Data1 != RHS.Data1 ||\n           Data2 != RHS.Data2 ||\n           L != RHS.L ||\n           Tag != RHS.Tag;\n  }\n\n  void Profile(llvm::FoldingSetNodeID& ID) const {\n    ID.AddInteger((unsigned) getKind());\n    ID.AddPointer(getData1());\n    ID.AddPointer(getData2());\n    ID.AddPointer(getLocationContext());\n    ID.AddPointer(getTag());\n  }\n\n  void printJson(llvm::raw_ostream &Out, const char *NL = \"\\n\") const;\n\n  LLVM_DUMP_METHOD void dump() const;\n\n  static ProgramPoint getProgramPoint(const Stmt *S, ProgramPoint::Kind K,\n                                      const LocationContext *LC,\n                                      const ProgramPointTag *tag);\n};\n\nclass BlockEntrance : public ProgramPoint {\npublic:\n  BlockEntrance(const CFGBlock *B, const LocationContext *L,\n                const ProgramPointTag *tag = nullptr)\n    : ProgramPoint(B, BlockEntranceKind, L, tag) {\n    assert(B && \"BlockEntrance requires non-null block\");\n  }\n\n  const CFGBlock *getBlock() const {\n    return reinterpret_cast<const CFGBlock*>(getData1());\n  }\n\n  Optional<CFGElement> getFirstElement() const {\n    const CFGBlock *B = getBlock();\n    return B->empty() ? Optional<CFGElement>() : B->front();\n  }\n\nprivate:\n  friend class ProgramPoint;\n  BlockEntrance() = default;\n  static bool isKind(const ProgramPoint &Location) {\n    return Location.getKind() == BlockEntranceKind;\n  }\n};\n\nclass BlockExit : public ProgramPoint {\npublic:\n  BlockExit(const CFGBlock *B, const LocationContext *L)\n    : ProgramPoint(B, BlockExitKind, L) {}\n\n  const CFGBlock *getBlock() const {\n    return reinterpret_cast<const CFGBlock*>(getData1());\n  }\n\n  const Stmt *getTerminator() const {\n    return getBlock()->getTerminatorStmt();\n  }\n\nprivate:\n  friend class ProgramPoint;\n  BlockExit() = default;\n  static bool isKind(const ProgramPoint &Location) {\n    return Location.getKind() == BlockExitKind;\n  }\n};\n\nclass StmtPoint : public ProgramPoint {\npublic:\n  StmtPoint(const Stmt *S, const void *p2, Kind k, const LocationContext *L,\n            const ProgramPointTag *tag)\n    : ProgramPoint(S, p2, k, L, tag) {\n    assert(S);\n  }\n\n  const Stmt *getStmt() const { return (const Stmt*) getData1(); }\n\n  template <typename T>\n  const T* getStmtAs() const { return dyn_cast<T>(getStmt()); }\n\nprotected:\n  StmtPoint() = default;\nprivate:\n  friend class ProgramPoint;\n  static bool isKind(const ProgramPoint &Location) {\n    unsigned k = Location.getKind();\n    return k >= PreStmtKind && k <= MaxPostStmtKind;\n  }\n};\n\n\nclass PreStmt : public StmtPoint {\npublic:\n  PreStmt(const Stmt *S, const LocationContext *L, const ProgramPointTag *tag,\n          const Stmt *SubStmt = nullptr)\n    : StmtPoint(S, SubStmt, PreStmtKind, L, tag) {}\n\n  const Stmt *getSubStmt() const { return (const Stmt*) getData2(); }\n\nprivate:\n  friend class ProgramPoint;\n  PreStmt() = default;\n  static bool isKind(const ProgramPoint &Location) {\n    return Location.getKind() == PreStmtKind;\n  }\n};\n\nclass PostStmt : public StmtPoint {\nprotected:\n  PostStmt() = default;\n  PostStmt(const Stmt *S, const void *data, Kind k, const LocationContext *L,\n           const ProgramPointTag *tag = nullptr)\n    : StmtPoint(S, data, k, L, tag) {}\n\npublic:\n  explicit PostStmt(const Stmt *S, Kind k, const LocationContext *L,\n                    const ProgramPointTag *tag = nullptr)\n    : StmtPoint(S, nullptr, k, L, tag) {}\n\n  explicit PostStmt(const Stmt *S, const LocationContext *L,\n                    const ProgramPointTag *tag = nullptr)\n    : StmtPoint(S, nullptr, PostStmtKind, L, tag) {}\n\nprivate:\n  friend class ProgramPoint;\n  static bool isKind(const ProgramPoint &Location) {\n    unsigned k = Location.getKind();\n    return k >= MinPostStmtKind && k <= MaxPostStmtKind;\n  }\n};\n\nclass FunctionExitPoint : public ProgramPoint {\npublic:\n  explicit FunctionExitPoint(const ReturnStmt *S,\n                             const LocationContext *LC,\n                             const ProgramPointTag *tag = nullptr)\n      : ProgramPoint(S, FunctionExitKind, LC, tag) {}\n\n  const CFGBlock *getBlock() const {\n    return &getLocationContext()->getCFG()->getExit();\n  }\n\n  const ReturnStmt *getStmt() const {\n    return reinterpret_cast<const ReturnStmt *>(getData1());\n  }\n\nprivate:\n  friend class ProgramPoint;\n  FunctionExitPoint() = default;\n  static bool isKind(const ProgramPoint &Location) {\n    return Location.getKind() == FunctionExitKind;\n  }\n};\n\n// PostCondition represents the post program point of a branch condition.\nclass PostCondition : public PostStmt {\npublic:\n  PostCondition(const Stmt *S, const LocationContext *L,\n                const ProgramPointTag *tag = nullptr)\n    : PostStmt(S, PostConditionKind, L, tag) {}\n\nprivate:\n  friend class ProgramPoint;\n  PostCondition() = default;\n  static bool isKind(const ProgramPoint &Location) {\n    return Location.getKind() == PostConditionKind;\n  }\n};\n\nclass LocationCheck : public StmtPoint {\nprotected:\n  LocationCheck() = default;\n  LocationCheck(const Stmt *S, const LocationContext *L,\n                ProgramPoint::Kind K, const ProgramPointTag *tag)\n    : StmtPoint(S, nullptr, K, L, tag) {}\n\nprivate:\n  friend class ProgramPoint;\n  static bool isKind(const ProgramPoint &location) {\n    unsigned k = location.getKind();\n    return k == PreLoadKind || k == PreStoreKind;\n  }\n};\n\nclass PreLoad : public LocationCheck {\npublic:\n  PreLoad(const Stmt *S, const LocationContext *L,\n          const ProgramPointTag *tag = nullptr)\n    : LocationCheck(S, L, PreLoadKind, tag) {}\n\nprivate:\n  friend class ProgramPoint;\n  PreLoad() = default;\n  static bool isKind(const ProgramPoint &location) {\n    return location.getKind() == PreLoadKind;\n  }\n};\n\nclass PreStore : public LocationCheck {\npublic:\n  PreStore(const Stmt *S, const LocationContext *L,\n           const ProgramPointTag *tag = nullptr)\n  : LocationCheck(S, L, PreStoreKind, tag) {}\n\nprivate:\n  friend class ProgramPoint;\n  PreStore() = default;\n  static bool isKind(const ProgramPoint &location) {\n    return location.getKind() == PreStoreKind;\n  }\n};\n\nclass PostLoad : public PostStmt {\npublic:\n  PostLoad(const Stmt *S, const LocationContext *L,\n           const ProgramPointTag *tag = nullptr)\n    : PostStmt(S, PostLoadKind, L, tag) {}\n\nprivate:\n  friend class ProgramPoint;\n  PostLoad() = default;\n  static bool isKind(const ProgramPoint &Location) {\n    return Location.getKind() == PostLoadKind;\n  }\n};\n\n/// Represents a program point after a store evaluation.\nclass PostStore : public PostStmt {\npublic:\n  /// Construct the post store point.\n  /// \\param Loc can be used to store the information about the location\n  /// used in the form it was uttered in the code.\n  PostStore(const Stmt *S, const LocationContext *L, const void *Loc,\n            const ProgramPointTag *tag = nullptr)\n    : PostStmt(S, PostStoreKind, L, tag) {\n    assert(getData2() == nullptr);\n    setData2(Loc);\n  }\n\n  /// Returns the information about the location used in the store,\n  /// how it was uttered in the code.\n  const void *getLocationValue() const {\n    return getData2();\n  }\n\nprivate:\n  friend class ProgramPoint;\n  PostStore() = default;\n  static bool isKind(const ProgramPoint &Location) {\n    return Location.getKind() == PostStoreKind;\n  }\n};\n\nclass PostLValue : public PostStmt {\npublic:\n  PostLValue(const Stmt *S, const LocationContext *L,\n             const ProgramPointTag *tag = nullptr)\n    : PostStmt(S, PostLValueKind, L, tag) {}\n\nprivate:\n  friend class ProgramPoint;\n  PostLValue() = default;\n  static bool isKind(const ProgramPoint &Location) {\n    return Location.getKind() == PostLValueKind;\n  }\n};\n\n/// Represents a point after we ran remove dead bindings BEFORE\n/// processing the given statement.\nclass PreStmtPurgeDeadSymbols : public StmtPoint {\npublic:\n  PreStmtPurgeDeadSymbols(const Stmt *S, const LocationContext *L,\n                       const ProgramPointTag *tag = nullptr)\n    : StmtPoint(S, nullptr, PreStmtPurgeDeadSymbolsKind, L, tag) { }\n\nprivate:\n  friend class ProgramPoint;\n  PreStmtPurgeDeadSymbols() = default;\n  static bool isKind(const ProgramPoint &Location) {\n    return Location.getKind() == PreStmtPurgeDeadSymbolsKind;\n  }\n};\n\n/// Represents a point after we ran remove dead bindings AFTER\n/// processing the  given statement.\nclass PostStmtPurgeDeadSymbols : public StmtPoint {\npublic:\n  PostStmtPurgeDeadSymbols(const Stmt *S, const LocationContext *L,\n                       const ProgramPointTag *tag = nullptr)\n    : StmtPoint(S, nullptr, PostStmtPurgeDeadSymbolsKind, L, tag) { }\n\nprivate:\n  friend class ProgramPoint;\n  PostStmtPurgeDeadSymbols() = default;\n  static bool isKind(const ProgramPoint &Location) {\n    return Location.getKind() == PostStmtPurgeDeadSymbolsKind;\n  }\n};\n\nclass BlockEdge : public ProgramPoint {\npublic:\n  BlockEdge(const CFGBlock *B1, const CFGBlock *B2, const LocationContext *L)\n    : ProgramPoint(B1, B2, BlockEdgeKind, L) {\n    assert(B1 && \"BlockEdge: source block must be non-null\");\n    assert(B2 && \"BlockEdge: destination block must be non-null\");\n  }\n\n  const CFGBlock *getSrc() const {\n    return static_cast<const CFGBlock*>(getData1());\n  }\n\n  const CFGBlock *getDst() const {\n    return static_cast<const CFGBlock*>(getData2());\n  }\n\nprivate:\n  friend class ProgramPoint;\n  BlockEdge() = default;\n  static bool isKind(const ProgramPoint &Location) {\n    return Location.getKind() == BlockEdgeKind;\n  }\n};\n\nclass PostInitializer : public ProgramPoint {\npublic:\n  /// Construct a PostInitializer point that represents a location after\n  ///   CXXCtorInitializer expression evaluation.\n  ///\n  /// \\param I The initializer.\n  /// \\param Loc The location of the field being initialized.\n  PostInitializer(const CXXCtorInitializer *I,\n                  const void *Loc,\n                  const LocationContext *L)\n    : ProgramPoint(I, Loc, PostInitializerKind, L) {}\n\n  const CXXCtorInitializer *getInitializer() const {\n    return static_cast<const CXXCtorInitializer *>(getData1());\n  }\n\n  /// Returns the location of the field.\n  const void *getLocationValue() const {\n    return getData2();\n  }\n\nprivate:\n  friend class ProgramPoint;\n  PostInitializer() = default;\n  static bool isKind(const ProgramPoint &Location) {\n    return Location.getKind() == PostInitializerKind;\n  }\n};\n\n/// Represents an implicit call event.\n///\n/// The nearest statement is provided for diagnostic purposes.\nclass ImplicitCallPoint : public ProgramPoint {\npublic:\n  ImplicitCallPoint(const Decl *D, SourceLocation Loc, Kind K,\n                    const LocationContext *L, const ProgramPointTag *Tag)\n    : ProgramPoint(Loc.getPtrEncoding(), D, K, L, Tag) {}\n\n  const Decl *getDecl() const { return static_cast<const Decl *>(getData2()); }\n  SourceLocation getLocation() const {\n    return SourceLocation::getFromPtrEncoding(getData1());\n  }\n\nprotected:\n  ImplicitCallPoint() = default;\nprivate:\n  friend class ProgramPoint;\n  static bool isKind(const ProgramPoint &Location) {\n    return Location.getKind() >= MinImplicitCallKind &&\n           Location.getKind() <= MaxImplicitCallKind;\n  }\n};\n\n/// Represents a program point just before an implicit call event.\n///\n/// Explicit calls will appear as PreStmt program points.\nclass PreImplicitCall : public ImplicitCallPoint {\npublic:\n  PreImplicitCall(const Decl *D, SourceLocation Loc, const LocationContext *L,\n                  const ProgramPointTag *Tag = nullptr)\n    : ImplicitCallPoint(D, Loc, PreImplicitCallKind, L, Tag) {}\n\nprivate:\n  friend class ProgramPoint;\n  PreImplicitCall() = default;\n  static bool isKind(const ProgramPoint &Location) {\n    return Location.getKind() == PreImplicitCallKind;\n  }\n};\n\n/// Represents a program point just after an implicit call event.\n///\n/// Explicit calls will appear as PostStmt program points.\nclass PostImplicitCall : public ImplicitCallPoint {\npublic:\n  PostImplicitCall(const Decl *D, SourceLocation Loc, const LocationContext *L,\n                   const ProgramPointTag *Tag = nullptr)\n    : ImplicitCallPoint(D, Loc, PostImplicitCallKind, L, Tag) {}\n\nprivate:\n  friend class ProgramPoint;\n  PostImplicitCall() = default;\n  static bool isKind(const ProgramPoint &Location) {\n    return Location.getKind() == PostImplicitCallKind;\n  }\n};\n\nclass PostAllocatorCall : public StmtPoint {\npublic:\n  PostAllocatorCall(const Stmt *S, const LocationContext *L,\n                    const ProgramPointTag *Tag = nullptr)\n      : StmtPoint(S, nullptr, PostAllocatorCallKind, L, Tag) {}\n\nprivate:\n  friend class ProgramPoint;\n  PostAllocatorCall() = default;\n  static bool isKind(const ProgramPoint &Location) {\n    return Location.getKind() == PostAllocatorCallKind;\n  }\n};\n\n/// Represents a point when we begin processing an inlined call.\n/// CallEnter uses the caller's location context.\nclass CallEnter : public ProgramPoint {\npublic:\n  CallEnter(const Stmt *stmt, const StackFrameContext *calleeCtx,\n            const LocationContext *callerCtx)\n    : ProgramPoint(stmt, calleeCtx, CallEnterKind, callerCtx, nullptr) {}\n\n  const Stmt *getCallExpr() const {\n    return static_cast<const Stmt *>(getData1());\n  }\n\n  const StackFrameContext *getCalleeContext() const {\n    return static_cast<const StackFrameContext *>(getData2());\n  }\n\n  /// Returns the entry block in the CFG for the entered function.\n  const CFGBlock *getEntry() const {\n    const StackFrameContext *CalleeCtx = getCalleeContext();\n    const CFG *CalleeCFG = CalleeCtx->getCFG();\n    return &(CalleeCFG->getEntry());\n  }\n\nprivate:\n  friend class ProgramPoint;\n  CallEnter() = default;\n  static bool isKind(const ProgramPoint &Location) {\n    return Location.getKind() == CallEnterKind;\n  }\n};\n\n/// Represents a point when we start the call exit sequence (for inlined call).\n///\n/// The call exit is simulated with a sequence of nodes, which occur between\n/// CallExitBegin and CallExitEnd. The following operations occur between the\n/// two program points:\n/// - CallExitBegin\n/// - Bind the return value\n/// - Run Remove dead bindings (to clean up the dead symbols from the callee).\n/// - CallExitEnd\nclass CallExitBegin : public ProgramPoint {\npublic:\n  // CallExitBegin uses the callee's location context.\n  CallExitBegin(const StackFrameContext *L, const ReturnStmt *RS)\n    : ProgramPoint(RS, CallExitBeginKind, L, nullptr) { }\n\n  const ReturnStmt *getReturnStmt() const {\n    return static_cast<const ReturnStmt *>(getData1());\n  }\n\nprivate:\n  friend class ProgramPoint;\n  CallExitBegin() = default;\n  static bool isKind(const ProgramPoint &Location) {\n    return Location.getKind() == CallExitBeginKind;\n  }\n};\n\n/// Represents a point when we finish the call exit sequence (for inlined call).\n/// \\sa CallExitBegin\nclass CallExitEnd : public ProgramPoint {\npublic:\n  // CallExitEnd uses the caller's location context.\n  CallExitEnd(const StackFrameContext *CalleeCtx,\n              const LocationContext *CallerCtx)\n    : ProgramPoint(CalleeCtx, CallExitEndKind, CallerCtx, nullptr) {}\n\n  const StackFrameContext *getCalleeContext() const {\n    return static_cast<const StackFrameContext *>(getData1());\n  }\n\nprivate:\n  friend class ProgramPoint;\n  CallExitEnd() = default;\n  static bool isKind(const ProgramPoint &Location) {\n    return Location.getKind() == CallExitEndKind;\n  }\n};\n\n/// Represents a point when we exit a loop.\n/// When this ProgramPoint is encountered we can be sure that the symbolic\n/// execution of the corresponding LoopStmt is finished on the given path.\n/// Note: It is possible to encounter a LoopExit element when we haven't even\n/// encountered the loop itself. At the current state not all loop exits will\n/// result in a LoopExit program point.\nclass LoopExit : public ProgramPoint {\npublic:\n    LoopExit(const Stmt *LoopStmt, const LocationContext *LC)\n            : ProgramPoint(LoopStmt, nullptr, LoopExitKind, LC) {}\n\n    const Stmt *getLoopStmt() const {\n      return static_cast<const Stmt *>(getData1());\n    }\n\nprivate:\n    friend class ProgramPoint;\n    LoopExit() = default;\n    static bool isKind(const ProgramPoint &Location) {\n      return Location.getKind() == LoopExitKind;\n    }\n};\n\n/// This is a meta program point, which should be skipped by all the diagnostic\n/// reasoning etc.\nclass EpsilonPoint : public ProgramPoint {\npublic:\n  EpsilonPoint(const LocationContext *L, const void *Data1,\n               const void *Data2 = nullptr,\n               const ProgramPointTag *tag = nullptr)\n    : ProgramPoint(Data1, Data2, EpsilonKind, L, tag) {}\n\n  const void *getData() const { return getData1(); }\n\nprivate:\n  friend class ProgramPoint;\n  EpsilonPoint() = default;\n  static bool isKind(const ProgramPoint &Location) {\n    return Location.getKind() == EpsilonKind;\n  }\n};\n\n} // end namespace clang\n\n\nnamespace llvm { // Traits specialization for DenseMap\n\ntemplate <> struct DenseMapInfo<clang::ProgramPoint> {\n\nstatic inline clang::ProgramPoint getEmptyKey() {\n  uintptr_t x =\n   reinterpret_cast<uintptr_t>(DenseMapInfo<void*>::getEmptyKey()) & ~0x7;\n  return clang::BlockEntrance(reinterpret_cast<clang::CFGBlock*>(x), nullptr);\n}\n\nstatic inline clang::ProgramPoint getTombstoneKey() {\n  uintptr_t x =\n   reinterpret_cast<uintptr_t>(DenseMapInfo<void*>::getTombstoneKey()) & ~0x7;\n  return clang::BlockEntrance(reinterpret_cast<clang::CFGBlock*>(x), nullptr);\n}\n\nstatic unsigned getHashValue(const clang::ProgramPoint &Loc) {\n  return Loc.getHashValue();\n}\n\nstatic bool isEqual(const clang::ProgramPoint &L,\n                    const clang::ProgramPoint &R) {\n  return L == R;\n}\n\n};\n\n} // end namespace llvm\n\n#endif\n"}, "18": {"id": 18, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Basic/DiagnosticIDs.h", "content": "//===--- DiagnosticIDs.h - Diagnostic IDs Handling --------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n///\n/// \\file\n/// Defines the Diagnostic IDs-related interfaces.\n///\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_BASIC_DIAGNOSTICIDS_H\n#define LLVM_CLANG_BASIC_DIAGNOSTICIDS_H\n\n#include \"clang/Basic/LLVM.h\"\n#include \"llvm/ADT/IntrusiveRefCntPtr.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include <vector>\n\nnamespace clang {\n  class DiagnosticsEngine;\n  class SourceLocation;\n\n  // Import the diagnostic enums themselves.\n  namespace diag {\n    // Size of each of the diagnostic categories.\n    enum {\n      DIAG_SIZE_COMMON        =  300,\n      DIAG_SIZE_DRIVER        =  250,\n      DIAG_SIZE_FRONTEND      =  150,\n      DIAG_SIZE_SERIALIZATION =  120,\n      DIAG_SIZE_LEX           =  400,\n      DIAG_SIZE_PARSE         =  600,\n      DIAG_SIZE_AST           =  250,\n      DIAG_SIZE_COMMENT       =  100,\n      DIAG_SIZE_CROSSTU       =  100,\n      DIAG_SIZE_SEMA          = 4500,\n      DIAG_SIZE_ANALYSIS      =  100,\n      DIAG_SIZE_REFACTORING   = 1000,\n    };\n    // Start position for diagnostics.\n    enum {\n      DIAG_START_COMMON        =                          0,\n      DIAG_START_DRIVER        = DIAG_START_COMMON        + DIAG_SIZE_COMMON,\n      DIAG_START_FRONTEND      = DIAG_START_DRIVER        + DIAG_SIZE_DRIVER,\n      DIAG_START_SERIALIZATION = DIAG_START_FRONTEND      + DIAG_SIZE_FRONTEND,\n      DIAG_START_LEX           = DIAG_START_SERIALIZATION + DIAG_SIZE_SERIALIZATION,\n      DIAG_START_PARSE         = DIAG_START_LEX           + DIAG_SIZE_LEX,\n      DIAG_START_AST           = DIAG_START_PARSE         + DIAG_SIZE_PARSE,\n      DIAG_START_COMMENT       = DIAG_START_AST           + DIAG_SIZE_AST,\n      DIAG_START_CROSSTU       = DIAG_START_COMMENT       + DIAG_SIZE_COMMENT,\n      DIAG_START_SEMA          = DIAG_START_CROSSTU       + DIAG_SIZE_CROSSTU,\n      DIAG_START_ANALYSIS      = DIAG_START_SEMA          + DIAG_SIZE_SEMA,\n      DIAG_START_REFACTORING   = DIAG_START_ANALYSIS      + DIAG_SIZE_ANALYSIS,\n      DIAG_UPPER_LIMIT         = DIAG_START_REFACTORING   + DIAG_SIZE_REFACTORING\n    };\n\n    class CustomDiagInfo;\n\n    /// All of the diagnostics that can be emitted by the frontend.\n    typedef unsigned kind;\n\n    // Get typedefs for common diagnostics.\n    enum {\n#define DIAG(ENUM, FLAGS, DEFAULT_MAPPING, DESC, GROUP, SFINAE, CATEGORY,      \\\n             NOWERROR, SHOWINSYSHEADER, DEFFERABLE)                            \\\n  ENUM,\n#define COMMONSTART\n#include \"clang/Basic/DiagnosticCommonKinds.inc\"\n      NUM_BUILTIN_COMMON_DIAGNOSTICS\n#undef DIAG\n    };\n\n    /// Enum values that allow the client to map NOTEs, WARNINGs, and EXTENSIONs\n    /// to either Ignore (nothing), Remark (emit a remark), Warning\n    /// (emit a warning) or Error (emit as an error).  It allows clients to\n    /// map ERRORs to Error or Fatal (stop emitting diagnostics after this one).\n    enum class Severity {\n      // NOTE: 0 means \"uncomputed\".\n      Ignored = 1, ///< Do not present this diagnostic, ignore it.\n      Remark = 2,  ///< Present this diagnostic as a remark.\n      Warning = 3, ///< Present this diagnostic as a warning.\n      Error = 4,   ///< Present this diagnostic as an error.\n      Fatal = 5    ///< Present this diagnostic as a fatal error.\n    };\n\n    /// Flavors of diagnostics we can emit. Used to filter for a particular\n    /// kind of diagnostic (for instance, for -W/-R flags).\n    enum class Flavor {\n      WarningOrError, ///< A diagnostic that indicates a problem or potential\n                      ///< problem. Can be made fatal by -Werror.\n      Remark          ///< A diagnostic that indicates normal progress through\n                      ///< compilation.\n    };\n  }\n\nclass DiagnosticMapping {\n  unsigned Severity : 3;\n  unsigned IsUser : 1;\n  unsigned IsPragma : 1;\n  unsigned HasNoWarningAsError : 1;\n  unsigned HasNoErrorAsFatal : 1;\n  unsigned WasUpgradedFromWarning : 1;\n\npublic:\n  static DiagnosticMapping Make(diag::Severity Severity, bool IsUser,\n                                bool IsPragma) {\n    DiagnosticMapping Result;\n    Result.Severity = (unsigned)Severity;\n    Result.IsUser = IsUser;\n    Result.IsPragma = IsPragma;\n    Result.HasNoWarningAsError = 0;\n    Result.HasNoErrorAsFatal = 0;\n    Result.WasUpgradedFromWarning = 0;\n    return Result;\n  }\n\n  diag::Severity getSeverity() const { return (diag::Severity)Severity; }\n  void setSeverity(diag::Severity Value) { Severity = (unsigned)Value; }\n\n  bool isUser() const { return IsUser; }\n  bool isPragma() const { return IsPragma; }\n\n  bool isErrorOrFatal() const {\n    return getSeverity() == diag::Severity::Error ||\n           getSeverity() == diag::Severity::Fatal;\n  }\n\n  bool hasNoWarningAsError() const { return HasNoWarningAsError; }\n  void setNoWarningAsError(bool Value) { HasNoWarningAsError = Value; }\n\n  bool hasNoErrorAsFatal() const { return HasNoErrorAsFatal; }\n  void setNoErrorAsFatal(bool Value) { HasNoErrorAsFatal = Value; }\n\n  /// Whether this mapping attempted to map the diagnostic to a warning, but\n  /// was overruled because the diagnostic was already mapped to an error or\n  /// fatal error.\n  bool wasUpgradedFromWarning() const { return WasUpgradedFromWarning; }\n  void setUpgradedFromWarning(bool Value) { WasUpgradedFromWarning = Value; }\n\n  /// Serialize this mapping as a raw integer.\n  unsigned serialize() const {\n    return (IsUser << 7) | (IsPragma << 6) | (HasNoWarningAsError << 5) |\n           (HasNoErrorAsFatal << 4) | (WasUpgradedFromWarning << 3) | Severity;\n  }\n  /// Deserialize a mapping.\n  static DiagnosticMapping deserialize(unsigned Bits) {\n    DiagnosticMapping Result;\n    Result.IsUser = (Bits >> 7) & 1;\n    Result.IsPragma = (Bits >> 6) & 1;\n    Result.HasNoWarningAsError = (Bits >> 5) & 1;\n    Result.HasNoErrorAsFatal = (Bits >> 4) & 1;\n    Result.WasUpgradedFromWarning = (Bits >> 3) & 1;\n    Result.Severity = Bits & 0x7;\n    return Result;\n  }\n};\n\n/// Used for handling and querying diagnostic IDs.\n///\n/// Can be used and shared by multiple Diagnostics for multiple translation units.\nclass DiagnosticIDs : public RefCountedBase<DiagnosticIDs> {\npublic:\n  /// The level of the diagnostic, after it has been through mapping.\n  enum Level {\n    Ignored, Note, Remark, Warning, Error, Fatal\n  };\n\nprivate:\n  /// Information for uniquing and looking up custom diags.\n  std::unique_ptr<diag::CustomDiagInfo> CustomDiagInfo;\n\npublic:\n  DiagnosticIDs();\n  ~DiagnosticIDs();\n\n  /// Return an ID for a diagnostic with the specified format string and\n  /// level.\n  ///\n  /// If this is the first request for this diagnostic, it is registered and\n  /// created, otherwise the existing ID is returned.\n\n  // FIXME: Replace this function with a create-only facilty like\n  // createCustomDiagIDFromFormatString() to enforce safe usage. At the time of\n  // writing, nearly all callers of this function were invalid.\n  unsigned getCustomDiagID(Level L, StringRef FormatString);\n\n  //===--------------------------------------------------------------------===//\n  // Diagnostic classification and reporting interfaces.\n  //\n\n  /// Given a diagnostic ID, return a description of the issue.\n  StringRef getDescription(unsigned DiagID) const;\n\n  /// Return true if the unmapped diagnostic levelof the specified\n  /// diagnostic ID is a Warning or Extension.\n  ///\n  /// This only works on builtin diagnostics, not custom ones, and is not\n  /// legal to call on NOTEs.\n  static bool isBuiltinWarningOrExtension(unsigned DiagID);\n\n  /// Return true if the specified diagnostic is mapped to errors by\n  /// default.\n  static bool isDefaultMappingAsError(unsigned DiagID);\n\n  /// Determine whether the given built-in diagnostic ID is a Note.\n  static bool isBuiltinNote(unsigned DiagID);\n\n  /// Determine whether the given built-in diagnostic ID is for an\n  /// extension of some sort.\n  static bool isBuiltinExtensionDiag(unsigned DiagID) {\n    bool ignored;\n    return isBuiltinExtensionDiag(DiagID, ignored);\n  }\n\n  /// Determine whether the given built-in diagnostic ID is for an\n  /// extension of some sort, and whether it is enabled by default.\n  ///\n  /// This also returns EnabledByDefault, which is set to indicate whether the\n  /// diagnostic is ignored by default (in which case -pedantic enables it) or\n  /// treated as a warning/error by default.\n  ///\n  static bool isBuiltinExtensionDiag(unsigned DiagID, bool &EnabledByDefault);\n\n\n  /// Return the lowest-level warning option that enables the specified\n  /// diagnostic.\n  ///\n  /// If there is no -Wfoo flag that controls the diagnostic, this returns null.\n  static StringRef getWarningOptionForDiag(unsigned DiagID);\n\n  /// Return the category number that a specified \\p DiagID belongs to,\n  /// or 0 if no category.\n  static unsigned getCategoryNumberForDiag(unsigned DiagID);\n\n  /// Return the number of diagnostic categories.\n  static unsigned getNumberOfCategories();\n\n  /// Given a category ID, return the name of the category.\n  static StringRef getCategoryNameFromID(unsigned CategoryID);\n\n  /// Return true if a given diagnostic falls into an ARC diagnostic\n  /// category.\n  static bool isARCDiagnostic(unsigned DiagID);\n\n  /// Enumeration describing how the emission of a diagnostic should\n  /// be treated when it occurs during C++ template argument deduction.\n  enum SFINAEResponse {\n    /// The diagnostic should not be reported, but it should cause\n    /// template argument deduction to fail.\n    ///\n    /// The vast majority of errors that occur during template argument\n    /// deduction fall into this category.\n    SFINAE_SubstitutionFailure,\n\n    /// The diagnostic should be suppressed entirely.\n    ///\n    /// Warnings generally fall into this category.\n    SFINAE_Suppress,\n\n    /// The diagnostic should be reported.\n    ///\n    /// The diagnostic should be reported. Various fatal errors (e.g.,\n    /// template instantiation depth exceeded) fall into this category.\n    SFINAE_Report,\n\n    /// The diagnostic is an access-control diagnostic, which will be\n    /// substitution failures in some contexts and reported in others.\n    SFINAE_AccessControl\n  };\n\n  /// Determines whether the given built-in diagnostic ID is\n  /// for an error that is suppressed if it occurs during C++ template\n  /// argument deduction.\n  ///\n  /// When an error is suppressed due to SFINAE, the template argument\n  /// deduction fails but no diagnostic is emitted. Certain classes of\n  /// errors, such as those errors that involve C++ access control,\n  /// are not SFINAE errors.\n  static SFINAEResponse getDiagnosticSFINAEResponse(unsigned DiagID);\n\n  /// Whether the diagnostic message can be deferred.\n  ///\n  /// For single source offloading languages, a diagnostic message occurred\n  /// in a device host function may be deferred until the function is sure\n  /// to be emitted.\n  static bool isDeferrable(unsigned DiagID);\n\n  /// Get the string of all diagnostic flags.\n  ///\n  /// \\returns A list of all diagnostics flags as they would be written in a\n  /// command line invocation including their `no-` variants. For example:\n  /// `{\"-Wempty-body\", \"-Wno-empty-body\", ...}`\n  static std::vector<std::string> getDiagnosticFlags();\n\n  /// Get the set of all diagnostic IDs in the group with the given name.\n  ///\n  /// \\param[out] Diags - On return, the diagnostics in the group.\n  /// \\returns \\c true if the given group is unknown, \\c false otherwise.\n  bool getDiagnosticsInGroup(diag::Flavor Flavor, StringRef Group,\n                             SmallVectorImpl<diag::kind> &Diags) const;\n\n  /// Get the set of all diagnostic IDs.\n  static void getAllDiagnostics(diag::Flavor Flavor,\n                                std::vector<diag::kind> &Diags);\n\n  /// Get the diagnostic option with the closest edit distance to the\n  /// given group name.\n  static StringRef getNearestOption(diag::Flavor Flavor, StringRef Group);\n\nprivate:\n  /// Classify the specified diagnostic ID into a Level, consumable by\n  /// the DiagnosticClient.\n  ///\n  /// The classification is based on the way the client configured the\n  /// DiagnosticsEngine object.\n  ///\n  /// \\param Loc The source location for which we are interested in finding out\n  /// the diagnostic state. Can be null in order to query the latest state.\n  DiagnosticIDs::Level\n  getDiagnosticLevel(unsigned DiagID, SourceLocation Loc,\n                     const DiagnosticsEngine &Diag) const LLVM_READONLY;\n\n  diag::Severity\n  getDiagnosticSeverity(unsigned DiagID, SourceLocation Loc,\n                        const DiagnosticsEngine &Diag) const LLVM_READONLY;\n\n  /// Used to report a diagnostic that is finally fully formed.\n  ///\n  /// \\returns \\c true if the diagnostic was emitted, \\c false if it was\n  /// suppressed.\n  bool ProcessDiag(DiagnosticsEngine &Diag) const;\n\n  /// Used to emit a diagnostic that is finally fully formed,\n  /// ignoring suppression.\n  void EmitDiag(DiagnosticsEngine &Diag, Level DiagLevel) const;\n\n  /// Whether the diagnostic may leave the AST in a state where some\n  /// invariants can break.\n  bool isUnrecoverable(unsigned DiagID) const;\n\n  friend class DiagnosticsEngine;\n};\n\n}  // end namespace clang\n\n#endif\n"}, "19": {"id": 19, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Basic/IdentifierTable.h", "content": "//===- IdentifierTable.h - Hash table for identifier lookup -----*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n/// \\file\n/// Defines the clang::IdentifierInfo, clang::IdentifierTable, and\n/// clang::Selector interfaces.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_BASIC_IDENTIFIERTABLE_H\n#define LLVM_CLANG_BASIC_IDENTIFIERTABLE_H\n\n#include \"clang/Basic/LLVM.h\"\n#include \"clang/Basic/TokenKinds.h\"\n#include \"llvm/ADT/DenseMapInfo.h\"\n#include \"llvm/ADT/SmallString.h\"\n#include \"llvm/ADT/StringMap.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/Support/Allocator.h\"\n#include \"llvm/Support/PointerLikeTypeTraits.h\"\n#include \"llvm/Support/type_traits.h\"\n#include <cassert>\n#include <cstddef>\n#include <cstdint>\n#include <cstring>\n#include <string>\n#include <utility>\n\nnamespace clang {\n\nclass DeclarationName;\nclass DeclarationNameTable;\nclass IdentifierInfo;\nclass LangOptions;\nclass MultiKeywordSelector;\nclass SourceLocation;\n\n/// A simple pair of identifier info and location.\nusing IdentifierLocPair = std::pair<IdentifierInfo *, SourceLocation>;\n\n/// IdentifierInfo and other related classes are aligned to\n/// 8 bytes so that DeclarationName can use the lower 3 bits\n/// of a pointer to one of these classes.\nenum { IdentifierInfoAlignment = 8 };\n\nstatic constexpr int ObjCOrBuiltinIDBits = 15;\n\n/// One of these records is kept for each identifier that\n/// is lexed.  This contains information about whether the token was \\#define'd,\n/// is a language keyword, or if it is a front-end token of some sort (e.g. a\n/// variable or function name).  The preprocessor keeps this information in a\n/// set, and all tok::identifier tokens have a pointer to one of these.\n/// It is aligned to 8 bytes because DeclarationName needs the lower 3 bits.\nclass alignas(IdentifierInfoAlignment) IdentifierInfo {\n  friend class IdentifierTable;\n\n  // Front-end token ID or tok::identifier.\n  unsigned TokenID : 9;\n\n  // ObjC keyword ('protocol' in '@protocol') or builtin (__builtin_inf).\n  // First NUM_OBJC_KEYWORDS values are for Objective-C,\n  // the remaining values are for builtins.\n  unsigned ObjCOrBuiltinID : ObjCOrBuiltinIDBits;\n\n  // True if there is a #define for this.\n  unsigned HasMacro : 1;\n\n  // True if there was a #define for this.\n  unsigned HadMacro : 1;\n\n  // True if the identifier is a language extension.\n  unsigned IsExtension : 1;\n\n  // True if the identifier is a keyword in a newer or proposed Standard.\n  unsigned IsFutureCompatKeyword : 1;\n\n  // True if the identifier is poisoned.\n  unsigned IsPoisoned : 1;\n\n  // True if the identifier is a C++ operator keyword.\n  unsigned IsCPPOperatorKeyword : 1;\n\n  // Internal bit set by the member function RecomputeNeedsHandleIdentifier.\n  // See comment about RecomputeNeedsHandleIdentifier for more info.\n  unsigned NeedsHandleIdentifier : 1;\n\n  // True if the identifier was loaded (at least partially) from an AST file.\n  unsigned IsFromAST : 1;\n\n  // True if the identifier has changed from the definition\n  // loaded from an AST file.\n  unsigned ChangedAfterLoad : 1;\n\n  // True if the identifier's frontend information has changed from the\n  // definition loaded from an AST file.\n  unsigned FEChangedAfterLoad : 1;\n\n  // True if revertTokenIDToIdentifier was called.\n  unsigned RevertedTokenID : 1;\n\n  // True if there may be additional information about\n  // this identifier stored externally.\n  unsigned OutOfDate : 1;\n\n  // True if this is the 'import' contextual keyword.\n  unsigned IsModulesImport : 1;\n\n  // True if this is a mangled OpenMP variant name.\n  unsigned IsMangledOpenMPVariantName : 1;\n\n  // 28 bits left in a 64-bit word.\n\n  // Managed by the language front-end.\n  void *FETokenInfo = nullptr;\n\n  llvm::StringMapEntry<IdentifierInfo *> *Entry = nullptr;\n\n  IdentifierInfo()\n      : TokenID(tok::identifier), ObjCOrBuiltinID(0), HasMacro(false),\n        HadMacro(false), IsExtension(false), IsFutureCompatKeyword(false),\n        IsPoisoned(false), IsCPPOperatorKeyword(false),\n        NeedsHandleIdentifier(false), IsFromAST(false), ChangedAfterLoad(false),\n        FEChangedAfterLoad(false), RevertedTokenID(false), OutOfDate(false),\n        IsModulesImport(false), IsMangledOpenMPVariantName(false) {}\n\npublic:\n  IdentifierInfo(const IdentifierInfo &) = delete;\n  IdentifierInfo &operator=(const IdentifierInfo &) = delete;\n  IdentifierInfo(IdentifierInfo &&) = delete;\n  IdentifierInfo &operator=(IdentifierInfo &&) = delete;\n\n  /// Return true if this is the identifier for the specified string.\n  ///\n  /// This is intended to be used for string literals only: II->isStr(\"foo\").\n  template <std::size_t StrLen>\n  bool isStr(const char (&Str)[StrLen]) const {\n    return getLength() == StrLen-1 &&\n           memcmp(getNameStart(), Str, StrLen-1) == 0;\n  }\n\n  /// Return true if this is the identifier for the specified StringRef.\n  bool isStr(llvm::StringRef Str) const {\n    llvm::StringRef ThisStr(getNameStart(), getLength());\n    return ThisStr == Str;\n  }\n\n  /// Return the beginning of the actual null-terminated string for this\n  /// identifier.\n  const char *getNameStart() const { return Entry->getKeyData(); }\n\n  /// Efficiently return the length of this identifier info.\n  unsigned getLength() const { return Entry->getKeyLength(); }\n\n  /// Return the actual identifier string.\n  StringRef getName() const {\n    return StringRef(getNameStart(), getLength());\n  }\n\n  /// Return true if this identifier is \\#defined to some other value.\n  /// \\note The current definition may be in a module and not currently visible.\n  bool hasMacroDefinition() const {\n    return HasMacro;\n  }\n  void setHasMacroDefinition(bool Val) {\n    if (HasMacro == Val) return;\n\n    HasMacro = Val;\n    if (Val) {\n      NeedsHandleIdentifier = true;\n      HadMacro = true;\n    } else {\n      RecomputeNeedsHandleIdentifier();\n    }\n  }\n  /// Returns true if this identifier was \\#defined to some value at any\n  /// moment. In this case there should be an entry for the identifier in the\n  /// macro history table in Preprocessor.\n  bool hadMacroDefinition() const {\n    return HadMacro;\n  }\n\n  /// If this is a source-language token (e.g. 'for'), this API\n  /// can be used to cause the lexer to map identifiers to source-language\n  /// tokens.\n  tok::TokenKind getTokenID() const { return (tok::TokenKind)TokenID; }\n\n  /// True if revertTokenIDToIdentifier() was called.\n  bool hasRevertedTokenIDToIdentifier() const { return RevertedTokenID; }\n\n  /// Revert TokenID to tok::identifier; used for GNU libstdc++ 4.2\n  /// compatibility.\n  ///\n  /// TokenID is normally read-only but there are 2 instances where we revert it\n  /// to tok::identifier for libstdc++ 4.2. Keep track of when this happens\n  /// using this method so we can inform serialization about it.\n  void revertTokenIDToIdentifier() {\n    assert(TokenID != tok::identifier && \"Already at tok::identifier\");\n    TokenID = tok::identifier;\n    RevertedTokenID = true;\n  }\n  void revertIdentifierToTokenID(tok::TokenKind TK) {\n    assert(TokenID == tok::identifier && \"Should be at tok::identifier\");\n    TokenID = TK;\n    RevertedTokenID = false;\n  }\n\n  /// Return the preprocessor keyword ID for this identifier.\n  ///\n  /// For example, \"define\" will return tok::pp_define.\n  tok::PPKeywordKind getPPKeywordID() const;\n\n  /// Return the Objective-C keyword ID for the this identifier.\n  ///\n  /// For example, 'class' will return tok::objc_class if ObjC is enabled.\n  tok::ObjCKeywordKind getObjCKeywordID() const {\n    if (ObjCOrBuiltinID < tok::NUM_OBJC_KEYWORDS)\n      return tok::ObjCKeywordKind(ObjCOrBuiltinID);\n    else\n      return tok::objc_not_keyword;\n  }\n  void setObjCKeywordID(tok::ObjCKeywordKind ID) { ObjCOrBuiltinID = ID; }\n\n  /// Return a value indicating whether this is a builtin function.\n  ///\n  /// 0 is not-built-in. 1+ are specific builtin functions.\n  unsigned getBuiltinID() const {\n    if (ObjCOrBuiltinID >= tok::NUM_OBJC_KEYWORDS)\n      return ObjCOrBuiltinID - tok::NUM_OBJC_KEYWORDS;\n    else\n      return 0;\n  }\n  void setBuiltinID(unsigned ID) {\n    ObjCOrBuiltinID = ID + tok::NUM_OBJC_KEYWORDS;\n    assert(ObjCOrBuiltinID - unsigned(tok::NUM_OBJC_KEYWORDS) == ID\n           && \"ID too large for field!\");\n  }\n\n  unsigned getObjCOrBuiltinID() const { return ObjCOrBuiltinID; }\n  void setObjCOrBuiltinID(unsigned ID) { ObjCOrBuiltinID = ID; }\n\n  /// get/setExtension - Initialize information about whether or not this\n  /// language token is an extension.  This controls extension warnings, and is\n  /// only valid if a custom token ID is set.\n  bool isExtensionToken() const { return IsExtension; }\n  void setIsExtensionToken(bool Val) {\n    IsExtension = Val;\n    if (Val)\n      NeedsHandleIdentifier = true;\n    else\n      RecomputeNeedsHandleIdentifier();\n  }\n\n  /// is/setIsFutureCompatKeyword - Initialize information about whether or not\n  /// this language token is a keyword in a newer or proposed Standard. This\n  /// controls compatibility warnings, and is only true when not parsing the\n  /// corresponding Standard. Once a compatibility problem has been diagnosed\n  /// with this keyword, the flag will be cleared.\n  bool isFutureCompatKeyword() const { return IsFutureCompatKeyword; }\n  void setIsFutureCompatKeyword(bool Val) {\n    IsFutureCompatKeyword = Val;\n    if (Val)\n      NeedsHandleIdentifier = true;\n    else\n      RecomputeNeedsHandleIdentifier();\n  }\n\n  /// setIsPoisoned - Mark this identifier as poisoned.  After poisoning, the\n  /// Preprocessor will emit an error every time this token is used.\n  void setIsPoisoned(bool Value = true) {\n    IsPoisoned = Value;\n    if (Value)\n      NeedsHandleIdentifier = true;\n    else\n      RecomputeNeedsHandleIdentifier();\n  }\n\n  /// Return true if this token has been poisoned.\n  bool isPoisoned() const { return IsPoisoned; }\n\n  /// isCPlusPlusOperatorKeyword/setIsCPlusPlusOperatorKeyword controls whether\n  /// this identifier is a C++ alternate representation of an operator.\n  void setIsCPlusPlusOperatorKeyword(bool Val = true) {\n    IsCPPOperatorKeyword = Val;\n  }\n  bool isCPlusPlusOperatorKeyword() const { return IsCPPOperatorKeyword; }\n\n  /// Return true if this token is a keyword in the specified language.\n  bool isKeyword(const LangOptions &LangOpts) const;\n\n  /// Return true if this token is a C++ keyword in the specified\n  /// language.\n  bool isCPlusPlusKeyword(const LangOptions &LangOpts) const;\n\n  /// Get and set FETokenInfo. The language front-end is allowed to associate\n  /// arbitrary metadata with this token.\n  void *getFETokenInfo() const { return FETokenInfo; }\n  void setFETokenInfo(void *T) { FETokenInfo = T; }\n\n  /// Return true if the Preprocessor::HandleIdentifier must be called\n  /// on a token of this identifier.\n  ///\n  /// If this returns false, we know that HandleIdentifier will not affect\n  /// the token.\n  bool isHandleIdentifierCase() const { return NeedsHandleIdentifier; }\n\n  /// Return true if the identifier in its current state was loaded\n  /// from an AST file.\n  bool isFromAST() const { return IsFromAST; }\n\n  void setIsFromAST() { IsFromAST = true; }\n\n  /// Determine whether this identifier has changed since it was loaded\n  /// from an AST file.\n  bool hasChangedSinceDeserialization() const {\n    return ChangedAfterLoad;\n  }\n\n  /// Note that this identifier has changed since it was loaded from\n  /// an AST file.\n  void setChangedSinceDeserialization() {\n    ChangedAfterLoad = true;\n  }\n\n  /// Determine whether the frontend token information for this\n  /// identifier has changed since it was loaded from an AST file.\n  bool hasFETokenInfoChangedSinceDeserialization() const {\n    return FEChangedAfterLoad;\n  }\n\n  /// Note that the frontend token information for this identifier has\n  /// changed since it was loaded from an AST file.\n  void setFETokenInfoChangedSinceDeserialization() {\n    FEChangedAfterLoad = true;\n  }\n\n  /// Determine whether the information for this identifier is out of\n  /// date with respect to the external source.\n  bool isOutOfDate() const { return OutOfDate; }\n\n  /// Set whether the information for this identifier is out of\n  /// date with respect to the external source.\n  void setOutOfDate(bool OOD) {\n    OutOfDate = OOD;\n    if (OOD)\n      NeedsHandleIdentifier = true;\n    else\n      RecomputeNeedsHandleIdentifier();\n  }\n\n  /// Determine whether this is the contextual keyword \\c import.\n  bool isModulesImport() const { return IsModulesImport; }\n\n  /// Set whether this identifier is the contextual keyword \\c import.\n  void setModulesImport(bool I) {\n    IsModulesImport = I;\n    if (I)\n      NeedsHandleIdentifier = true;\n    else\n      RecomputeNeedsHandleIdentifier();\n  }\n\n  /// Determine whether this is the mangled name of an OpenMP variant.\n  bool isMangledOpenMPVariantName() const { return IsMangledOpenMPVariantName; }\n\n  /// Set whether this is the mangled name of an OpenMP variant.\n  void setMangledOpenMPVariantName(bool I) { IsMangledOpenMPVariantName = I; }\n\n  /// Return true if this identifier is an editor placeholder.\n  ///\n  /// Editor placeholders are produced by the code-completion engine and are\n  /// represented as characters between '<#' and '#>' in the source code. An\n  /// example of auto-completed call with a placeholder parameter is shown\n  /// below:\n  /// \\code\n  ///   function(<#int x#>);\n  /// \\endcode\n  bool isEditorPlaceholder() const {\n    return getName().startswith(\"<#\") && getName().endswith(\"#>\");\n  }\n\n  /// Determine whether \\p this is a name reserved for the implementation (C99\n  /// 7.1.3, C++ [lib.global.names]).\n  bool isReservedName(bool doubleUnderscoreOnly = false) const {\n    if (getLength() < 2)\n      return false;\n    const char *Name = getNameStart();\n    return Name[0] == '_' &&\n           (Name[1] == '_' ||\n            (Name[1] >= 'A' && Name[1] <= 'Z' && !doubleUnderscoreOnly));\n  }\n\n  /// Provide less than operator for lexicographical sorting.\n  bool operator<(const IdentifierInfo &RHS) const {\n    return getName() < RHS.getName();\n  }\n\nprivate:\n  /// The Preprocessor::HandleIdentifier does several special (but rare)\n  /// things to identifiers of various sorts.  For example, it changes the\n  /// \\c for keyword token from tok::identifier to tok::for.\n  ///\n  /// This method is very tied to the definition of HandleIdentifier.  Any\n  /// change to it should be reflected here.\n  void RecomputeNeedsHandleIdentifier() {\n    NeedsHandleIdentifier = isPoisoned() || hasMacroDefinition() ||\n                            isExtensionToken() || isFutureCompatKeyword() ||\n                            isOutOfDate() || isModulesImport();\n  }\n};\n\n/// An RAII object for [un]poisoning an identifier within a scope.\n///\n/// \\p II is allowed to be null, in which case objects of this type have\n/// no effect.\nclass PoisonIdentifierRAIIObject {\n  IdentifierInfo *const II;\n  const bool OldValue;\n\npublic:\n  PoisonIdentifierRAIIObject(IdentifierInfo *II, bool NewValue)\n    : II(II), OldValue(II ? II->isPoisoned() : false) {\n    if(II)\n      II->setIsPoisoned(NewValue);\n  }\n\n  ~PoisonIdentifierRAIIObject() {\n    if(II)\n      II->setIsPoisoned(OldValue);\n  }\n};\n\n/// An iterator that walks over all of the known identifiers\n/// in the lookup table.\n///\n/// Since this iterator uses an abstract interface via virtual\n/// functions, it uses an object-oriented interface rather than the\n/// more standard C++ STL iterator interface. In this OO-style\n/// iteration, the single function \\c Next() provides dereference,\n/// advance, and end-of-sequence checking in a single\n/// operation. Subclasses of this iterator type will provide the\n/// actual functionality.\nclass IdentifierIterator {\nprotected:\n  IdentifierIterator() = default;\n\npublic:\n  IdentifierIterator(const IdentifierIterator &) = delete;\n  IdentifierIterator &operator=(const IdentifierIterator &) = delete;\n\n  virtual ~IdentifierIterator();\n\n  /// Retrieve the next string in the identifier table and\n  /// advances the iterator for the following string.\n  ///\n  /// \\returns The next string in the identifier table. If there is\n  /// no such string, returns an empty \\c StringRef.\n  virtual StringRef Next() = 0;\n};\n\n/// Provides lookups to, and iteration over, IdentiferInfo objects.\nclass IdentifierInfoLookup {\npublic:\n  virtual ~IdentifierInfoLookup();\n\n  /// Return the IdentifierInfo for the specified named identifier.\n  ///\n  /// Unlike the version in IdentifierTable, this returns a pointer instead\n  /// of a reference.  If the pointer is null then the IdentifierInfo cannot\n  /// be found.\n  virtual IdentifierInfo* get(StringRef Name) = 0;\n\n  /// Retrieve an iterator into the set of all identifiers\n  /// known to this identifier lookup source.\n  ///\n  /// This routine provides access to all of the identifiers known to\n  /// the identifier lookup, allowing access to the contents of the\n  /// identifiers without introducing the overhead of constructing\n  /// IdentifierInfo objects for each.\n  ///\n  /// \\returns A new iterator into the set of known identifiers. The\n  /// caller is responsible for deleting this iterator.\n  virtual IdentifierIterator *getIdentifiers();\n};\n\n/// Implements an efficient mapping from strings to IdentifierInfo nodes.\n///\n/// This has no other purpose, but this is an extremely performance-critical\n/// piece of the code, as each occurrence of every identifier goes through\n/// here when lexed.\nclass IdentifierTable {\n  // Shark shows that using MallocAllocator is *much* slower than using this\n  // BumpPtrAllocator!\n  using HashTableTy = llvm::StringMap<IdentifierInfo *, llvm::BumpPtrAllocator>;\n  HashTableTy HashTable;\n\n  IdentifierInfoLookup* ExternalLookup;\n\npublic:\n  /// Create the identifier table.\n  explicit IdentifierTable(IdentifierInfoLookup *ExternalLookup = nullptr);\n\n  /// Create the identifier table, populating it with info about the\n  /// language keywords for the language specified by \\p LangOpts.\n  explicit IdentifierTable(const LangOptions &LangOpts,\n                           IdentifierInfoLookup *ExternalLookup = nullptr);\n\n  /// Set the external identifier lookup mechanism.\n  void setExternalIdentifierLookup(IdentifierInfoLookup *IILookup) {\n    ExternalLookup = IILookup;\n  }\n\n  /// Retrieve the external identifier lookup object, if any.\n  IdentifierInfoLookup *getExternalIdentifierLookup() const {\n    return ExternalLookup;\n  }\n\n  llvm::BumpPtrAllocator& getAllocator() {\n    return HashTable.getAllocator();\n  }\n\n  /// Return the identifier token info for the specified named\n  /// identifier.\n  IdentifierInfo &get(StringRef Name) {\n    auto &Entry = *HashTable.insert(std::make_pair(Name, nullptr)).first;\n\n    IdentifierInfo *&II = Entry.second;\n    if (II) return *II;\n\n    // No entry; if we have an external lookup, look there first.\n    if (ExternalLookup) {\n      II = ExternalLookup->get(Name);\n      if (II)\n        return *II;\n    }\n\n    // Lookups failed, make a new IdentifierInfo.\n    void *Mem = getAllocator().Allocate<IdentifierInfo>();\n    II = new (Mem) IdentifierInfo();\n\n    // Make sure getName() knows how to find the IdentifierInfo\n    // contents.\n    II->Entry = &Entry;\n\n    return *II;\n  }\n\n  IdentifierInfo &get(StringRef Name, tok::TokenKind TokenCode) {\n    IdentifierInfo &II = get(Name);\n    II.TokenID = TokenCode;\n    assert(II.TokenID == (unsigned) TokenCode && \"TokenCode too large\");\n    return II;\n  }\n\n  /// Gets an IdentifierInfo for the given name without consulting\n  ///        external sources.\n  ///\n  /// This is a version of get() meant for external sources that want to\n  /// introduce or modify an identifier. If they called get(), they would\n  /// likely end up in a recursion.\n  IdentifierInfo &getOwn(StringRef Name) {\n    auto &Entry = *HashTable.insert(std::make_pair(Name, nullptr)).first;\n\n    IdentifierInfo *&II = Entry.second;\n    if (II)\n      return *II;\n\n    // Lookups failed, make a new IdentifierInfo.\n    void *Mem = getAllocator().Allocate<IdentifierInfo>();\n    II = new (Mem) IdentifierInfo();\n\n    // Make sure getName() knows how to find the IdentifierInfo\n    // contents.\n    II->Entry = &Entry;\n\n    // If this is the 'import' contextual keyword, mark it as such.\n    if (Name.equals(\"import\"))\n      II->setModulesImport(true);\n\n    return *II;\n  }\n\n  using iterator = HashTableTy::const_iterator;\n  using const_iterator = HashTableTy::const_iterator;\n\n  iterator begin() const { return HashTable.begin(); }\n  iterator end() const   { return HashTable.end(); }\n  unsigned size() const  { return HashTable.size(); }\n\n  iterator find(StringRef Name) const { return HashTable.find(Name); }\n\n  /// Print some statistics to stderr that indicate how well the\n  /// hashing is doing.\n  void PrintStats() const;\n\n  /// Populate the identifier table with info about the language keywords\n  /// for the language specified by \\p LangOpts.\n  void AddKeywords(const LangOptions &LangOpts);\n};\n\n/// A family of Objective-C methods.\n///\n/// These families have no inherent meaning in the language, but are\n/// nonetheless central enough in the existing implementations to\n/// merit direct AST support.  While, in theory, arbitrary methods can\n/// be considered to form families, we focus here on the methods\n/// involving allocation and retain-count management, as these are the\n/// most \"core\" and the most likely to be useful to diverse clients\n/// without extra information.\n///\n/// Both selectors and actual method declarations may be classified\n/// into families.  Method families may impose additional restrictions\n/// beyond their selector name; for example, a method called '_init'\n/// that returns void is not considered to be in the 'init' family\n/// (but would be if it returned 'id').  It is also possible to\n/// explicitly change or remove a method's family.  Therefore the\n/// method's family should be considered the single source of truth.\nenum ObjCMethodFamily {\n  /// No particular method family.\n  OMF_None,\n\n  // Selectors in these families may have arbitrary arity, may be\n  // written with arbitrary leading underscores, and may have\n  // additional CamelCase \"words\" in their first selector chunk\n  // following the family name.\n  OMF_alloc,\n  OMF_copy,\n  OMF_init,\n  OMF_mutableCopy,\n  OMF_new,\n\n  // These families are singletons consisting only of the nullary\n  // selector with the given name.\n  OMF_autorelease,\n  OMF_dealloc,\n  OMF_finalize,\n  OMF_release,\n  OMF_retain,\n  OMF_retainCount,\n  OMF_self,\n  OMF_initialize,\n\n  // performSelector families\n  OMF_performSelector\n};\n\n/// Enough bits to store any enumerator in ObjCMethodFamily or\n/// InvalidObjCMethodFamily.\nenum { ObjCMethodFamilyBitWidth = 4 };\n\n/// An invalid value of ObjCMethodFamily.\nenum { InvalidObjCMethodFamily = (1 << ObjCMethodFamilyBitWidth) - 1 };\n\n/// A family of Objective-C methods.\n///\n/// These are family of methods whose result type is initially 'id', but\n/// but are candidate for the result type to be changed to 'instancetype'.\nenum ObjCInstanceTypeFamily {\n  OIT_None,\n  OIT_Array,\n  OIT_Dictionary,\n  OIT_Singleton,\n  OIT_Init,\n  OIT_ReturnsSelf\n};\n\nenum ObjCStringFormatFamily {\n  SFF_None,\n  SFF_NSString,\n  SFF_CFString\n};\n\n/// Smart pointer class that efficiently represents Objective-C method\n/// names.\n///\n/// This class will either point to an IdentifierInfo or a\n/// MultiKeywordSelector (which is private). This enables us to optimize\n/// selectors that take no arguments and selectors that take 1 argument, which\n/// accounts for 78% of all selectors in Cocoa.h.\nclass Selector {\n  friend class Diagnostic;\n  friend class SelectorTable; // only the SelectorTable can create these\n  friend class DeclarationName; // and the AST's DeclarationName.\n\n  enum IdentifierInfoFlag {\n    // Empty selector = 0. Note that these enumeration values must\n    // correspond to the enumeration values of DeclarationName::StoredNameKind\n    ZeroArg  = 0x01,\n    OneArg   = 0x02,\n    MultiArg = 0x07,\n    ArgFlags = 0x07\n  };\n\n  /// A pointer to the MultiKeywordSelector or IdentifierInfo. We use the low\n  /// three bits of InfoPtr to store an IdentifierInfoFlag. Note that in any\n  /// case IdentifierInfo and MultiKeywordSelector are already aligned to\n  /// 8 bytes even on 32 bits archs because of DeclarationName.\n  uintptr_t InfoPtr = 0;\n\n  Selector(IdentifierInfo *II, unsigned nArgs) {\n    InfoPtr = reinterpret_cast<uintptr_t>(II);\n    assert((InfoPtr & ArgFlags) == 0 &&\"Insufficiently aligned IdentifierInfo\");\n    assert(nArgs < 2 && \"nArgs not equal to 0/1\");\n    InfoPtr |= nArgs+1;\n  }\n\n  Selector(MultiKeywordSelector *SI) {\n    InfoPtr = reinterpret_cast<uintptr_t>(SI);\n    assert((InfoPtr & ArgFlags) == 0 &&\"Insufficiently aligned IdentifierInfo\");\n    InfoPtr |= MultiArg;\n  }\n\n  IdentifierInfo *getAsIdentifierInfo() const {\n    if (getIdentifierInfoFlag() < MultiArg)\n      return reinterpret_cast<IdentifierInfo *>(InfoPtr & ~ArgFlags);\n    return nullptr;\n  }\n\n  MultiKeywordSelector *getMultiKeywordSelector() const {\n    return reinterpret_cast<MultiKeywordSelector *>(InfoPtr & ~ArgFlags);\n  }\n\n  unsigned getIdentifierInfoFlag() const {\n    return InfoPtr & ArgFlags;\n  }\n\n  static ObjCMethodFamily getMethodFamilyImpl(Selector sel);\n\n  static ObjCStringFormatFamily getStringFormatFamilyImpl(Selector sel);\n\npublic:\n  /// The default ctor should only be used when creating data structures that\n  ///  will contain selectors.\n  Selector() = default;\n  explicit Selector(uintptr_t V) : InfoPtr(V) {}\n\n  /// operator==/!= - Indicate whether the specified selectors are identical.\n  bool operator==(Selector RHS) const {\n    return InfoPtr == RHS.InfoPtr;\n  }\n  bool operator!=(Selector RHS) const {\n    return InfoPtr != RHS.InfoPtr;\n  }\n\n  void *getAsOpaquePtr() const {\n    return reinterpret_cast<void*>(InfoPtr);\n  }\n\n  /// Determine whether this is the empty selector.\n  bool isNull() const { return InfoPtr == 0; }\n\n  // Predicates to identify the selector type.\n  bool isKeywordSelector() const {\n    return getIdentifierInfoFlag() != ZeroArg;\n  }\n\n  bool isUnarySelector() const {\n    return getIdentifierInfoFlag() == ZeroArg;\n  }\n\n  /// If this selector is the specific keyword selector described by Names.\n  bool isKeywordSelector(ArrayRef<StringRef> Names) const;\n\n  /// If this selector is the specific unary selector described by Name.\n  bool isUnarySelector(StringRef Name) const;\n\n  unsigned getNumArgs() const;\n\n  /// Retrieve the identifier at a given position in the selector.\n  ///\n  /// Note that the identifier pointer returned may be NULL. Clients that only\n  /// care about the text of the identifier string, and not the specific,\n  /// uniqued identifier pointer, should use \\c getNameForSlot(), which returns\n  /// an empty string when the identifier pointer would be NULL.\n  ///\n  /// \\param argIndex The index for which we want to retrieve the identifier.\n  /// This index shall be less than \\c getNumArgs() unless this is a keyword\n  /// selector, in which case 0 is the only permissible value.\n  ///\n  /// \\returns the uniqued identifier for this slot, or NULL if this slot has\n  /// no corresponding identifier.\n  IdentifierInfo *getIdentifierInfoForSlot(unsigned argIndex) const;\n\n  /// Retrieve the name at a given position in the selector.\n  ///\n  /// \\param argIndex The index for which we want to retrieve the name.\n  /// This index shall be less than \\c getNumArgs() unless this is a keyword\n  /// selector, in which case 0 is the only permissible value.\n  ///\n  /// \\returns the name for this slot, which may be the empty string if no\n  /// name was supplied.\n  StringRef getNameForSlot(unsigned argIndex) const;\n\n  /// Derive the full selector name (e.g. \"foo:bar:\") and return\n  /// it as an std::string.\n  std::string getAsString() const;\n\n  /// Prints the full selector name (e.g. \"foo:bar:\").\n  void print(llvm::raw_ostream &OS) const;\n\n  void dump() const;\n\n  /// Derive the conventional family of this method.\n  ObjCMethodFamily getMethodFamily() const {\n    return getMethodFamilyImpl(*this);\n  }\n\n  ObjCStringFormatFamily getStringFormatFamily() const {\n    return getStringFormatFamilyImpl(*this);\n  }\n\n  static Selector getEmptyMarker() {\n    return Selector(uintptr_t(-1));\n  }\n\n  static Selector getTombstoneMarker() {\n    return Selector(uintptr_t(-2));\n  }\n\n  static ObjCInstanceTypeFamily getInstTypeMethodFamily(Selector sel);\n};\n\n/// This table allows us to fully hide how we implement\n/// multi-keyword caching.\nclass SelectorTable {\n  // Actually a SelectorTableImpl\n  void *Impl;\n\npublic:\n  SelectorTable();\n  SelectorTable(const SelectorTable &) = delete;\n  SelectorTable &operator=(const SelectorTable &) = delete;\n  ~SelectorTable();\n\n  /// Can create any sort of selector.\n  ///\n  /// \\p NumArgs indicates whether this is a no argument selector \"foo\", a\n  /// single argument selector \"foo:\" or multi-argument \"foo:bar:\".\n  Selector getSelector(unsigned NumArgs, IdentifierInfo **IIV);\n\n  Selector getUnarySelector(IdentifierInfo *ID) {\n    return Selector(ID, 1);\n  }\n\n  Selector getNullarySelector(IdentifierInfo *ID) {\n    return Selector(ID, 0);\n  }\n\n  /// Return the total amount of memory allocated for managing selectors.\n  size_t getTotalMemory() const;\n\n  /// Return the default setter name for the given identifier.\n  ///\n  /// This is \"set\" + \\p Name where the initial character of \\p Name\n  /// has been capitalized.\n  static SmallString<64> constructSetterName(StringRef Name);\n\n  /// Return the default setter selector for the given identifier.\n  ///\n  /// This is \"set\" + \\p Name where the initial character of \\p Name\n  /// has been capitalized.\n  static Selector constructSetterSelector(IdentifierTable &Idents,\n                                          SelectorTable &SelTable,\n                                          const IdentifierInfo *Name);\n\n  /// Return the property name for the given setter selector.\n  static std::string getPropertyNameFromSetterSelector(Selector Sel);\n};\n\nnamespace detail {\n\n/// DeclarationNameExtra is used as a base of various uncommon special names.\n/// This class is needed since DeclarationName has not enough space to store\n/// the kind of every possible names. Therefore the kind of common names is\n/// stored directly in DeclarationName, and the kind of uncommon names is\n/// stored in DeclarationNameExtra. It is aligned to 8 bytes because\n/// DeclarationName needs the lower 3 bits to store the kind of common names.\n/// DeclarationNameExtra is tightly coupled to DeclarationName and any change\n/// here is very likely to require changes in DeclarationName(Table).\nclass alignas(IdentifierInfoAlignment) DeclarationNameExtra {\n  friend class clang::DeclarationName;\n  friend class clang::DeclarationNameTable;\n\nprotected:\n  /// The kind of \"extra\" information stored in the DeclarationName. See\n  /// @c ExtraKindOrNumArgs for an explanation of how these enumerator values\n  /// are used. Note that DeclarationName depends on the numerical values\n  /// of the enumerators in this enum. See DeclarationName::StoredNameKind\n  /// for more info.\n  enum ExtraKind {\n    CXXDeductionGuideName,\n    CXXLiteralOperatorName,\n    CXXUsingDirective,\n    ObjCMultiArgSelector\n  };\n\n  /// ExtraKindOrNumArgs has one of the following meaning:\n  ///  * The kind of an uncommon C++ special name. This DeclarationNameExtra\n  ///    is in this case in fact either a CXXDeductionGuideNameExtra or\n  ///    a CXXLiteralOperatorIdName.\n  ///\n  ///  * It may be also name common to C++ using-directives (CXXUsingDirective),\n  ///\n  ///  * Otherwise it is ObjCMultiArgSelector+NumArgs, where NumArgs is\n  ///    the number of arguments in the Objective-C selector, in which\n  ///    case the DeclarationNameExtra is also a MultiKeywordSelector.\n  unsigned ExtraKindOrNumArgs;\n\n  DeclarationNameExtra(ExtraKind Kind) : ExtraKindOrNumArgs(Kind) {}\n  DeclarationNameExtra(unsigned NumArgs)\n      : ExtraKindOrNumArgs(ObjCMultiArgSelector + NumArgs) {}\n\n  /// Return the corresponding ExtraKind.\n  ExtraKind getKind() const {\n    return static_cast<ExtraKind>(ExtraKindOrNumArgs >\n                                          (unsigned)ObjCMultiArgSelector\n                                      ? (unsigned)ObjCMultiArgSelector\n                                      : ExtraKindOrNumArgs);\n  }\n\n  /// Return the number of arguments in an ObjC selector. Only valid when this\n  /// is indeed an ObjCMultiArgSelector.\n  unsigned getNumArgs() const {\n    assert(ExtraKindOrNumArgs >= (unsigned)ObjCMultiArgSelector &&\n           \"getNumArgs called but this is not an ObjC selector!\");\n    return ExtraKindOrNumArgs - (unsigned)ObjCMultiArgSelector;\n  }\n};\n\n} // namespace detail\n\n}  // namespace clang\n\nnamespace llvm {\n\n/// Define DenseMapInfo so that Selectors can be used as keys in DenseMap and\n/// DenseSets.\ntemplate <>\nstruct DenseMapInfo<clang::Selector> {\n  static clang::Selector getEmptyKey() {\n    return clang::Selector::getEmptyMarker();\n  }\n\n  static clang::Selector getTombstoneKey() {\n    return clang::Selector::getTombstoneMarker();\n  }\n\n  static unsigned getHashValue(clang::Selector S);\n\n  static bool isEqual(clang::Selector LHS, clang::Selector RHS) {\n    return LHS == RHS;\n  }\n};\n\ntemplate<>\nstruct PointerLikeTypeTraits<clang::Selector> {\n  static const void *getAsVoidPointer(clang::Selector P) {\n    return P.getAsOpaquePtr();\n  }\n\n  static clang::Selector getFromVoidPointer(const void *P) {\n    return clang::Selector(reinterpret_cast<uintptr_t>(P));\n  }\n\n  static constexpr int NumLowBitsAvailable = 0;\n};\n\n// Provide PointerLikeTypeTraits for IdentifierInfo pointers, which\n// are not guaranteed to be 8-byte aligned.\ntemplate<>\nstruct PointerLikeTypeTraits<clang::IdentifierInfo*> {\n  static void *getAsVoidPointer(clang::IdentifierInfo* P) {\n    return P;\n  }\n\n  static clang::IdentifierInfo *getFromVoidPointer(void *P) {\n    return static_cast<clang::IdentifierInfo*>(P);\n  }\n\n  static constexpr int NumLowBitsAvailable = 1;\n};\n\ntemplate<>\nstruct PointerLikeTypeTraits<const clang::IdentifierInfo*> {\n  static const void *getAsVoidPointer(const clang::IdentifierInfo* P) {\n    return P;\n  }\n\n  static const clang::IdentifierInfo *getFromVoidPointer(const void *P) {\n    return static_cast<const clang::IdentifierInfo*>(P);\n  }\n\n  static constexpr int NumLowBitsAvailable = 1;\n};\n\n} // namespace llvm\n\n#endif // LLVM_CLANG_BASIC_IDENTIFIERTABLE_H\n"}, "20": {"id": 20, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Basic/LangOptions.h", "content": "//===- LangOptions.h - C Language Family Language Options -------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n/// \\file\n/// Defines the clang::LangOptions interface.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_BASIC_LANGOPTIONS_H\n#define LLVM_CLANG_BASIC_LANGOPTIONS_H\n\n#include \"clang/Basic/CommentOptions.h\"\n#include \"clang/Basic/LLVM.h\"\n#include \"clang/Basic/LangStandard.h\"\n#include \"clang/Basic/ObjCRuntime.h\"\n#include \"clang/Basic/Sanitizers.h\"\n#include \"clang/Basic/Visibility.h\"\n#include \"llvm/ADT/FloatingPointMode.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/ADT/Triple.h\"\n#include \"llvm/MC/MCTargetOptions.h\"\n#include <string>\n#include <vector>\n\nnamespace clang {\n\n/// Bitfields of LangOptions, split out from LangOptions in order to ensure that\n/// this large collection of bitfields is a trivial class type.\nclass LangOptionsBase {\n  friend class CompilerInvocation;\n\npublic:\n  // Define simple language options (with no accessors).\n#define LANGOPT(Name, Bits, Default, Description) unsigned Name : Bits;\n#define ENUM_LANGOPT(Name, Type, Bits, Default, Description)\n#include \"clang/Basic/LangOptions.def\"\n\nprotected:\n  // Define language options of enumeration type. These are private, and will\n  // have accessors (below).\n#define LANGOPT(Name, Bits, Default, Description)\n#define ENUM_LANGOPT(Name, Type, Bits, Default, Description) \\\n  unsigned Name : Bits;\n#include \"clang/Basic/LangOptions.def\"\n};\n\n/// In the Microsoft ABI, this controls the placement of virtual displacement\n/// members used to implement virtual inheritance.\nenum class MSVtorDispMode { Never, ForVBaseOverride, ForVFTable };\n\n/// Keeps track of the various options that can be\n/// enabled, which controls the dialect of C or C++ that is accepted.\nclass LangOptions : public LangOptionsBase {\npublic:\n  using Visibility = clang::Visibility;\n  using RoundingMode = llvm::RoundingMode;\n\n  enum GCMode { NonGC, GCOnly, HybridGC };\n  enum StackProtectorMode { SSPOff, SSPOn, SSPStrong, SSPReq };\n\n  // Automatic variables live on the stack, and when trivial they're usually\n  // uninitialized because it's undefined behavior to use them without\n  // initializing them.\n  enum class TrivialAutoVarInitKind { Uninitialized, Zero, Pattern };\n\n  enum SignedOverflowBehaviorTy {\n    // Default C standard behavior.\n    SOB_Undefined,\n\n    // -fwrapv\n    SOB_Defined,\n\n    // -ftrapv\n    SOB_Trapping\n  };\n\n  // FIXME: Unify with TUKind.\n  enum CompilingModuleKind {\n    /// Not compiling a module interface at all.\n    CMK_None,\n\n    /// Compiling a module from a module map.\n    CMK_ModuleMap,\n\n    /// Compiling a module from a list of header files.\n    CMK_HeaderModule,\n\n    /// Compiling a C++ modules TS module interface unit.\n    CMK_ModuleInterface,\n  };\n\n  enum PragmaMSPointersToMembersKind {\n    PPTMK_BestCase,\n    PPTMK_FullGeneralitySingleInheritance,\n    PPTMK_FullGeneralityMultipleInheritance,\n    PPTMK_FullGeneralityVirtualInheritance\n  };\n\n  using MSVtorDispMode = clang::MSVtorDispMode;\n\n  enum DefaultCallingConvention {\n    DCC_None,\n    DCC_CDecl,\n    DCC_FastCall,\n    DCC_StdCall,\n    DCC_VectorCall,\n    DCC_RegCall\n  };\n\n  enum AddrSpaceMapMangling { ASMM_Target, ASMM_On, ASMM_Off };\n\n  // Corresponds to _MSC_VER\n  enum MSVCMajorVersion {\n    MSVC2010 = 1600,\n    MSVC2012 = 1700,\n    MSVC2013 = 1800,\n    MSVC2015 = 1900,\n    MSVC2017 = 1910,\n    MSVC2017_5 = 1912,\n    MSVC2017_7 = 1914,\n    MSVC2019 = 1920,\n  };\n\n  enum SYCLMajorVersion {\n    SYCL_None,\n    SYCL_2017,\n  };\n\n  /// Clang versions with different platform ABI conformance.\n  enum class ClangABI {\n    /// Attempt to be ABI-compatible with code generated by Clang 3.8.x\n    /// (SVN r257626). This causes <1 x long long> to be passed in an\n    /// integer register instead of an SSE register on x64_64.\n    Ver3_8,\n\n    /// Attempt to be ABI-compatible with code generated by Clang 4.0.x\n    /// (SVN r291814). This causes move operations to be ignored when\n    /// determining whether a class type can be passed or returned directly.\n    Ver4,\n\n    /// Attempt to be ABI-compatible with code generated by Clang 6.0.x\n    /// (SVN r321711). This causes determination of whether a type is\n    /// standard-layout to ignore collisions between empty base classes\n    /// and between base classes and member subobjects, which affects\n    /// whether we reuse base class tail padding in some ABIs.\n    Ver6,\n\n    /// Attempt to be ABI-compatible with code generated by Clang 7.0.x\n    /// (SVN r338536). This causes alignof (C++) and _Alignof (C11) to be\n    /// compatible with __alignof (i.e., return the preferred alignment)\n    /// rather than returning the required alignment.\n    Ver7,\n\n    /// Attempt to be ABI-compatible with code generated by Clang 9.0.x\n    /// (SVN r351319). This causes vectors of __int128 to be passed in memory\n    /// instead of passing in multiple scalar registers on x86_64 on Linux and\n    /// NetBSD.\n    Ver9,\n\n    /// Attempt to be ABI-compatible with code generated by Clang 11.0.x\n    /// (git  2e10b7a39b93). This causes clang to pass unions with a 256-bit\n    /// vector member on the stack instead of using registers, to not properly\n    /// mangle substitutions for template names in some cases, and to mangle\n    /// declaration template arguments without a cast to the parameter type\n    /// even when that can lead to mangling collisions.\n    Ver11,\n\n    /// Conform to the underlying platform's C and C++ ABIs as closely\n    /// as we can.\n    Latest\n  };\n\n  enum class CoreFoundationABI {\n    /// No interoperability ABI has been specified\n    Unspecified,\n    /// CoreFoundation does not have any language interoperability\n    Standalone,\n    /// Interoperability with the ObjectiveC runtime\n    ObjectiveC,\n    /// Interoperability with the latest known version of the Swift runtime\n    Swift,\n    /// Interoperability with the Swift 5.0 runtime\n    Swift5_0,\n    /// Interoperability with the Swift 4.2 runtime\n    Swift4_2,\n    /// Interoperability with the Swift 4.1 runtime\n    Swift4_1,\n  };\n\n  enum FPModeKind {\n    // Disable the floating point pragma\n    FPM_Off,\n\n    // Enable the floating point pragma\n    FPM_On,\n\n    // Aggressively fuse FP ops (E.g. FMA) disregarding pragmas.\n    FPM_Fast,\n\n    // Aggressively fuse FP ops and honor pragmas.\n    FPM_FastHonorPragmas\n  };\n\n  /// Alias for RoundingMode::NearestTiesToEven.\n  static constexpr unsigned FPR_ToNearest =\n      static_cast<unsigned>(llvm::RoundingMode::NearestTiesToEven);\n\n  /// Possible floating point exception behavior.\n  enum FPExceptionModeKind {\n    /// Assume that floating-point exceptions are masked.\n    FPE_Ignore,\n    /// Transformations do not cause new exceptions but may hide some.\n    FPE_MayTrap,\n    /// Strictly preserve the floating-point exception semantics.\n    FPE_Strict\n  };\n\n  /// Possible exception handling behavior.\n  using ExceptionHandlingKind = llvm::ExceptionHandling;\n\n  enum class LaxVectorConversionKind {\n    /// Permit no implicit vector bitcasts.\n    None,\n    /// Permit vector bitcasts between integer vectors with different numbers\n    /// of elements but the same total bit-width.\n    Integer,\n    /// Permit vector bitcasts between all vectors with the same total\n    /// bit-width.\n    All,\n  };\n\n  enum class SignReturnAddressScopeKind {\n    /// No signing for any function.\n    None,\n    /// Sign the return address of functions that spill LR.\n    NonLeaf,\n    /// Sign the return address of all functions,\n    All\n  };\n\n  enum class SignReturnAddressKeyKind {\n    /// Return address signing uses APIA key.\n    AKey,\n    /// Return address signing uses APIB key.\n    BKey\n  };\n\n  enum class ThreadModelKind {\n    /// POSIX Threads.\n    POSIX,\n    /// Single Threaded Environment.\n    Single\n  };\n\npublic:\n  /// The used language standard.\n  LangStandard::Kind LangStd;\n\n  /// Set of enabled sanitizers.\n  SanitizerSet Sanitize;\n\n  /// Paths to files specifying which objects\n  /// (files, functions, variables) should not be instrumented.\n  std::vector<std::string> NoSanitizeFiles;\n\n  /// Paths to the XRay \"always instrument\" files specifying which\n  /// objects (files, functions, variables) should be imbued with the XRay\n  /// \"always instrument\" attribute.\n  /// WARNING: This is a deprecated field and will go away in the future.\n  std::vector<std::string> XRayAlwaysInstrumentFiles;\n\n  /// Paths to the XRay \"never instrument\" files specifying which\n  /// objects (files, functions, variables) should be imbued with the XRay\n  /// \"never instrument\" attribute.\n  /// WARNING: This is a deprecated field and will go away in the future.\n  std::vector<std::string> XRayNeverInstrumentFiles;\n\n  /// Paths to the XRay attribute list files, specifying which objects\n  /// (files, functions, variables) should be imbued with the appropriate XRay\n  /// attribute(s).\n  std::vector<std::string> XRayAttrListFiles;\n\n  /// Paths to special case list files specifying which entities\n  /// (files, functions) should or should not be instrumented.\n  std::vector<std::string> ProfileListFiles;\n\n  clang::ObjCRuntime ObjCRuntime;\n\n  CoreFoundationABI CFRuntime = CoreFoundationABI::Unspecified;\n\n  std::string ObjCConstantStringClass;\n\n  /// The name of the handler function to be called when -ftrapv is\n  /// specified.\n  ///\n  /// If none is specified, abort (GCC-compatible behaviour).\n  std::string OverflowHandler;\n\n  /// The module currently being compiled as specified by -fmodule-name.\n  std::string ModuleName;\n\n  /// The name of the current module, of which the main source file\n  /// is a part. If CompilingModule is set, we are compiling the interface\n  /// of this module, otherwise we are compiling an implementation file of\n  /// it. This starts as ModuleName in case -fmodule-name is provided and\n  /// changes during compilation to reflect the current module.\n  std::string CurrentModule;\n\n  /// The names of any features to enable in module 'requires' decls\n  /// in addition to the hard-coded list in Module.cpp and the target features.\n  ///\n  /// This list is sorted.\n  std::vector<std::string> ModuleFeatures;\n\n  /// Options for parsing comments.\n  CommentOptions CommentOpts;\n\n  /// A list of all -fno-builtin-* function names (e.g., memset).\n  std::vector<std::string> NoBuiltinFuncs;\n\n  /// Triples of the OpenMP targets that the host code codegen should\n  /// take into account in order to generate accurate offloading descriptors.\n  std::vector<llvm::Triple> OMPTargetTriples;\n\n  /// Name of the IR file that contains the result of the OpenMP target\n  /// host code generation.\n  std::string OMPHostIRFile;\n\n  /// The user provided compilation unit ID, if non-empty. This is used to\n  /// externalize static variables which is needed to support accessing static\n  /// device variables in host code for single source offloading languages\n  /// like CUDA/HIP.\n  std::string CUID;\n\n  /// Indicates whether the front-end is explicitly told that the\n  /// input is a header file (i.e. -x c-header).\n  bool IsHeaderFile = false;\n\n  LangOptions();\n\n  // Define accessors/mutators for language options of enumeration type.\n#define LANGOPT(Name, Bits, Default, Description)\n#define ENUM_LANGOPT(Name, Type, Bits, Default, Description) \\\n  Type get##Name() const { return static_cast<Type>(Name); } \\\n  void set##Name(Type Value) { Name = static_cast<unsigned>(Value); }\n#include \"clang/Basic/LangOptions.def\"\n\n  /// Are we compiling a module interface (.cppm or module map)?\n  bool isCompilingModule() const {\n    return getCompilingModule() != CMK_None;\n  }\n\n  /// Do we need to track the owning module for a local declaration?\n  bool trackLocalOwningModule() const {\n    return isCompilingModule() || ModulesLocalVisibility;\n  }\n\n  bool isSignedOverflowDefined() const {\n    return getSignedOverflowBehavior() == SOB_Defined;\n  }\n\n  bool isSubscriptPointerArithmetic() const {\n    return ObjCRuntime.isSubscriptPointerArithmetic() &&\n           !ObjCSubscriptingLegacyRuntime;\n  }\n\n  bool isCompatibleWithMSVC(MSVCMajorVersion MajorVersion) const {\n    return MSCompatibilityVersion >= MajorVersion * 100000U;\n  }\n\n  /// Reset all of the options that are not considered when building a\n  /// module.\n  void resetNonModularOptions();\n\n  /// Is this a libc/libm function that is no longer recognized as a\n  /// builtin because a -fno-builtin-* option has been specified?\n  bool isNoBuiltinFunc(StringRef Name) const;\n\n  /// True if any ObjC types may have non-trivial lifetime qualifiers.\n  bool allowsNonTrivialObjCLifetimeQualifiers() const {\n    return ObjCAutoRefCount || ObjCWeak;\n  }\n\n  bool assumeFunctionsAreConvergent() const {\n    return ConvergentFunctions;\n  }\n\n  /// Return the OpenCL C or C++ version as a VersionTuple.\n  VersionTuple getOpenCLVersionTuple() const;\n\n  /// Check if return address signing is enabled.\n  bool hasSignReturnAddress() const {\n    return getSignReturnAddressScope() != SignReturnAddressScopeKind::None;\n  }\n\n  /// Check if return address signing uses AKey.\n  bool isSignReturnAddressWithAKey() const {\n    return getSignReturnAddressKey() == SignReturnAddressKeyKind::AKey;\n  }\n\n  /// Check if leaf functions are also signed.\n  bool isSignReturnAddressScopeAll() const {\n    return getSignReturnAddressScope() == SignReturnAddressScopeKind::All;\n  }\n\n  bool hasSjLjExceptions() const {\n    return getExceptionHandling() == llvm::ExceptionHandling::SjLj;\n  }\n\n  bool hasSEHExceptions() const {\n    return getExceptionHandling() == llvm::ExceptionHandling::WinEH;\n  }\n\n  bool hasDWARFExceptions() const {\n    return getExceptionHandling() == llvm::ExceptionHandling::DwarfCFI;\n  }\n\n  bool hasWasmExceptions() const {\n    return getExceptionHandling() == llvm::ExceptionHandling::Wasm;\n  }\n};\n\n/// Floating point control options\nclass FPOptionsOverride;\nclass FPOptions {\npublic:\n  // We start by defining the layout.\n  using storage_type = uint16_t;\n\n  using RoundingMode = llvm::RoundingMode;\n\n  static constexpr unsigned StorageBitSize = 8 * sizeof(storage_type);\n\n  // Define a fake option named \"First\" so that we have a PREVIOUS even for the\n  // real first option.\n  static constexpr storage_type FirstShift = 0, FirstWidth = 0;\n#define OPTION(NAME, TYPE, WIDTH, PREVIOUS)                                    \\\n  static constexpr storage_type NAME##Shift =                                  \\\n      PREVIOUS##Shift + PREVIOUS##Width;                                       \\\n  static constexpr storage_type NAME##Width = WIDTH;                           \\\n  static constexpr storage_type NAME##Mask = ((1 << NAME##Width) - 1)          \\\n                                             << NAME##Shift;\n#include \"clang/Basic/FPOptions.def\"\n\n  static constexpr storage_type TotalWidth = 0\n#define OPTION(NAME, TYPE, WIDTH, PREVIOUS) +WIDTH\n#include \"clang/Basic/FPOptions.def\"\n      ;\n  static_assert(TotalWidth <= StorageBitSize, \"Too short type for FPOptions\");\n\nprivate:\n  storage_type Value;\n\npublic:\n  FPOptions() : Value(0) {\n    setFPContractMode(LangOptions::FPM_Off);\n    setRoundingMode(static_cast<RoundingMode>(LangOptions::FPR_ToNearest));\n    setFPExceptionMode(LangOptions::FPE_Ignore);\n  }\n  explicit FPOptions(const LangOptions &LO) {\n    Value = 0;\n    // The language fp contract option FPM_FastHonorPragmas has the same effect\n    // as FPM_Fast in frontend. For simplicity, use FPM_Fast uniformly in\n    // frontend.\n    auto LangOptContractMode = LO.getDefaultFPContractMode();\n    if (LangOptContractMode == LangOptions::FPM_FastHonorPragmas)\n      LangOptContractMode = LangOptions::FPM_Fast;\n    setFPContractMode(LangOptContractMode);\n    setRoundingMode(LO.getFPRoundingMode());\n    setFPExceptionMode(LO.getFPExceptionMode());\n    setAllowFPReassociate(LO.AllowFPReassoc);\n    setNoHonorNaNs(LO.NoHonorNaNs);\n    setNoHonorInfs(LO.NoHonorInfs);\n    setNoSignedZero(LO.NoSignedZero);\n    setAllowReciprocal(LO.AllowRecip);\n    setAllowApproxFunc(LO.ApproxFunc);\n    if (getFPContractMode() == LangOptions::FPM_On &&\n        getRoundingMode() == llvm::RoundingMode::Dynamic &&\n        getFPExceptionMode() == LangOptions::FPE_Strict)\n      // If the FP settings are set to the \"strict\" model, then\n      // FENV access is set to true. (ffp-model=strict)\n      setAllowFEnvAccess(true);\n    else\n      setAllowFEnvAccess(LangOptions::FPM_Off);\n  }\n\n  bool allowFPContractWithinStatement() const {\n    return getFPContractMode() == LangOptions::FPM_On;\n  }\n  void setAllowFPContractWithinStatement() {\n    setFPContractMode(LangOptions::FPM_On);\n  }\n\n  bool allowFPContractAcrossStatement() const {\n    return getFPContractMode() == LangOptions::FPM_Fast;\n  }\n  void setAllowFPContractAcrossStatement() {\n    setFPContractMode(LangOptions::FPM_Fast);\n  }\n\n  bool isFPConstrained() const {\n    return getRoundingMode() != llvm::RoundingMode::NearestTiesToEven ||\n           getFPExceptionMode() != LangOptions::FPE_Ignore ||\n           getAllowFEnvAccess();\n  }\n\n  bool operator==(FPOptions other) const { return Value == other.Value; }\n\n  /// Return the default value of FPOptions that's used when trailing\n  /// storage isn't required.\n  static FPOptions defaultWithoutTrailingStorage(const LangOptions &LO);\n\n  storage_type getAsOpaqueInt() const { return Value; }\n  static FPOptions getFromOpaqueInt(storage_type Value) {\n    FPOptions Opts;\n    Opts.Value = Value;\n    return Opts;\n  }\n\n  // We can define most of the accessors automatically:\n#define OPTION(NAME, TYPE, WIDTH, PREVIOUS)                                    \\\n  TYPE get##NAME() const {                                                     \\\n    return static_cast<TYPE>((Value & NAME##Mask) >> NAME##Shift);             \\\n  }                                                                            \\\n  void set##NAME(TYPE value) {                                                 \\\n    Value = (Value & ~NAME##Mask) | (storage_type(value) << NAME##Shift);      \\\n  }\n#include \"clang/Basic/FPOptions.def\"\n  LLVM_DUMP_METHOD void dump();\n};\n\n/// Represents difference between two FPOptions values.\n///\n/// The effect of language constructs changing the set of floating point options\n/// is usually a change of some FP properties while leaving others intact. This\n/// class describes such changes by keeping information about what FP options\n/// are overridden.\n///\n/// The integral set of FP options, described by the class FPOptions, may be\n/// represented as a default FP option set, defined by language standard and\n/// command line options, with the overrides introduced by pragmas.\n///\n/// The is implemented as a value of the new FPOptions plus a mask showing which\n/// fields are actually set in it.\nclass FPOptionsOverride {\n  FPOptions Options = FPOptions::getFromOpaqueInt(0);\n  FPOptions::storage_type OverrideMask = 0;\n\npublic:\n  using RoundingMode = llvm::RoundingMode;\n\n  /// The type suitable for storing values of FPOptionsOverride. Must be twice\n  /// as wide as bit size of FPOption.\n  using storage_type = uint32_t;\n  static_assert(sizeof(storage_type) >= 2 * sizeof(FPOptions::storage_type),\n                \"Too short type for FPOptionsOverride\");\n\n  /// Bit mask selecting bits of OverrideMask in serialized representation of\n  /// FPOptionsOverride.\n  static constexpr storage_type OverrideMaskBits =\n      (static_cast<storage_type>(1) << FPOptions::StorageBitSize) - 1;\n\n  FPOptionsOverride() {}\n  FPOptionsOverride(const LangOptions &LO)\n      : Options(LO), OverrideMask(OverrideMaskBits) {}\n  FPOptionsOverride(FPOptions FPO)\n      : Options(FPO), OverrideMask(OverrideMaskBits) {}\n\n  bool requiresTrailingStorage() const { return OverrideMask != 0; }\n\n  void setAllowFPContractWithinStatement() {\n    setFPContractModeOverride(LangOptions::FPM_On);\n  }\n\n  void setAllowFPContractAcrossStatement() {\n    setFPContractModeOverride(LangOptions::FPM_Fast);\n  }\n\n  void setDisallowFPContract() {\n    setFPContractModeOverride(LangOptions::FPM_Off);\n  }\n\n  void setFPPreciseEnabled(bool Value) {\n    setAllowFPReassociateOverride(!Value);\n    setNoHonorNaNsOverride(!Value);\n    setNoHonorInfsOverride(!Value);\n    setNoSignedZeroOverride(!Value);\n    setAllowReciprocalOverride(!Value);\n    setAllowApproxFuncOverride(!Value);\n    if (Value)\n      /* Precise mode implies fp_contract=on and disables ffast-math */\n      setAllowFPContractWithinStatement();\n    else\n      /* Precise mode disabled sets fp_contract=fast and enables ffast-math */\n      setAllowFPContractAcrossStatement();\n  }\n\n  storage_type getAsOpaqueInt() const {\n    return (static_cast<storage_type>(Options.getAsOpaqueInt())\n            << FPOptions::StorageBitSize) |\n           OverrideMask;\n  }\n  static FPOptionsOverride getFromOpaqueInt(storage_type I) {\n    FPOptionsOverride Opts;\n    Opts.OverrideMask = I & OverrideMaskBits;\n    Opts.Options = FPOptions::getFromOpaqueInt(I >> FPOptions::StorageBitSize);\n    return Opts;\n  }\n\n  FPOptions applyOverrides(FPOptions Base) {\n    FPOptions Result =\n        FPOptions::getFromOpaqueInt((Base.getAsOpaqueInt() & ~OverrideMask) |\n                                     (Options.getAsOpaqueInt() & OverrideMask));\n    return Result;\n  }\n\n  FPOptions applyOverrides(const LangOptions &LO) {\n    return applyOverrides(FPOptions(LO));\n  }\n\n  bool operator==(FPOptionsOverride other) const {\n    return Options == other.Options && OverrideMask == other.OverrideMask;\n  }\n  bool operator!=(FPOptionsOverride other) const { return !(*this == other); }\n\n#define OPTION(NAME, TYPE, WIDTH, PREVIOUS)                                    \\\n  bool has##NAME##Override() const {                                           \\\n    return OverrideMask & FPOptions::NAME##Mask;                               \\\n  }                                                                            \\\n  TYPE get##NAME##Override() const {                                           \\\n    assert(has##NAME##Override());                                             \\\n    return Options.get##NAME();                                                \\\n  }                                                                            \\\n  void clear##NAME##Override() {                                               \\\n    /* Clear the actual value so that we don't have spurious differences when  \\\n     * testing equality. */                                                    \\\n    Options.set##NAME(TYPE(0));                                                \\\n    OverrideMask &= ~FPOptions::NAME##Mask;                                    \\\n  }                                                                            \\\n  void set##NAME##Override(TYPE value) {                                       \\\n    Options.set##NAME(value);                                                  \\\n    OverrideMask |= FPOptions::NAME##Mask;                                     \\\n  }\n#include \"clang/Basic/FPOptions.def\"\n  LLVM_DUMP_METHOD void dump();\n};\n\n/// Describes the kind of translation unit being processed.\nenum TranslationUnitKind {\n  /// The translation unit is a complete translation unit.\n  TU_Complete,\n\n  /// The translation unit is a prefix to a translation unit, and is\n  /// not complete.\n  TU_Prefix,\n\n  /// The translation unit is a module.\n  TU_Module\n};\n\n} // namespace clang\n\n#endif // LLVM_CLANG_BASIC_LANGOPTIONS_H\n"}, "21": {"id": 21, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Basic/ObjCRuntime.h", "content": "//===- ObjCRuntime.h - Objective-C Runtime Configuration --------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n/// \\file\n/// Defines types useful for describing an Objective-C runtime.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_BASIC_OBJCRUNTIME_H\n#define LLVM_CLANG_BASIC_OBJCRUNTIME_H\n\n#include \"clang/Basic/LLVM.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/ADT/Triple.h\"\n#include \"llvm/Support/ErrorHandling.h\"\n#include \"llvm/Support/VersionTuple.h\"\n#include <string>\n\nnamespace clang {\n\n/// The basic abstraction for the target Objective-C runtime.\nclass ObjCRuntime {\npublic:\n  /// The basic Objective-C runtimes that we know about.\n  enum Kind {\n    /// 'macosx' is the Apple-provided NeXT-derived runtime on Mac OS\n    /// X platforms that use the non-fragile ABI; the version is a\n    /// release of that OS.\n    MacOSX,\n\n    /// 'macosx-fragile' is the Apple-provided NeXT-derived runtime on\n    /// Mac OS X platforms that use the fragile ABI; the version is a\n    /// release of that OS.\n    FragileMacOSX,\n\n    /// 'ios' is the Apple-provided NeXT-derived runtime on iOS or the iOS\n    /// simulator;  it is always non-fragile.  The version is a release\n    /// version of iOS.\n    iOS,\n\n    /// 'watchos' is a variant of iOS for Apple's watchOS. The version\n    /// is a release version of watchOS.\n    WatchOS,\n\n    /// 'gcc' is the Objective-C runtime shipped with GCC, implementing a\n    /// fragile Objective-C ABI\n    GCC,\n\n    /// 'gnustep' is the modern non-fragile GNUstep runtime.\n    GNUstep,\n\n    /// 'objfw' is the Objective-C runtime included in ObjFW\n    ObjFW\n  };\n\nprivate:\n  Kind TheKind = MacOSX;\n  VersionTuple Version;\n\npublic:\n  /// A bogus initialization of the runtime.\n  ObjCRuntime() = default;\n  ObjCRuntime(Kind kind, const VersionTuple &version)\n      : TheKind(kind), Version(version) {}\n\n  void set(Kind kind, VersionTuple version) {\n    TheKind = kind;\n    Version = version;\n  }\n\n  Kind getKind() const { return TheKind; }\n  const VersionTuple &getVersion() const { return Version; }\n\n  /// Does this runtime follow the set of implied behaviors for a\n  /// \"non-fragile\" ABI?\n  bool isNonFragile() const {\n    switch (getKind()) {\n    case FragileMacOSX: return false;\n    case GCC: return false;\n    case MacOSX: return true;\n    case GNUstep: return true;\n    case ObjFW: return true;\n    case iOS: return true;\n    case WatchOS: return true;\n    }\n    llvm_unreachable(\"bad kind\");\n  }\n\n  /// The inverse of isNonFragile():  does this runtime follow the set of\n  /// implied behaviors for a \"fragile\" ABI?\n  bool isFragile() const { return !isNonFragile(); }\n\n  /// The default dispatch mechanism to use for the specified architecture\n  bool isLegacyDispatchDefaultForArch(llvm::Triple::ArchType Arch) {\n    // The GNUstep runtime uses a newer dispatch method by default from\n    // version 1.6 onwards\n    if (getKind() == GNUstep && getVersion() >= VersionTuple(1, 6)) {\n      if (Arch == llvm::Triple::arm ||\n          Arch == llvm::Triple::x86 ||\n          Arch == llvm::Triple::x86_64)\n        return false;\n    }\n    else if ((getKind() ==  MacOSX) && isNonFragile() &&\n             (getVersion() >= VersionTuple(10, 0)) &&\n             (getVersion() < VersionTuple(10, 6)))\n        return Arch != llvm::Triple::x86_64;\n    // Except for deployment target of 10.5 or less,\n    // Mac runtimes use legacy dispatch everywhere now.\n    return true;\n  }\n\n  /// Is this runtime basically of the GNU family of runtimes?\n  bool isGNUFamily() const {\n    switch (getKind()) {\n    case FragileMacOSX:\n    case MacOSX:\n    case iOS:\n    case WatchOS:\n      return false;\n    case GCC:\n    case GNUstep:\n    case ObjFW:\n      return true;\n    }\n    llvm_unreachable(\"bad kind\");\n  }\n\n  /// Is this runtime basically of the NeXT family of runtimes?\n  bool isNeXTFamily() const {\n    // For now, this is just the inverse of isGNUFamily(), but that's\n    // not inherently true.\n    return !isGNUFamily();\n  }\n\n  /// Does this runtime allow ARC at all?\n  bool allowsARC() const {\n    switch (getKind()) {\n    case FragileMacOSX:\n      // No stub library for the fragile runtime.\n      return getVersion() >= VersionTuple(10, 7);\n    case MacOSX: return true;\n    case iOS: return true;\n    case WatchOS: return true;\n    case GCC: return false;\n    case GNUstep: return true;\n    case ObjFW: return true;\n    }\n    llvm_unreachable(\"bad kind\");\n  }\n\n  /// Does this runtime natively provide the ARC entrypoints?\n  ///\n  /// ARC cannot be directly supported on a platform that does not provide\n  /// these entrypoints, although it may be supportable via a stub\n  /// library.\n  bool hasNativeARC() const {\n    switch (getKind()) {\n    case FragileMacOSX: return getVersion() >= VersionTuple(10, 7);\n    case MacOSX: return getVersion() >= VersionTuple(10, 7);\n    case iOS: return getVersion() >= VersionTuple(5);\n    case WatchOS: return true;\n\n    case GCC: return false;\n    case GNUstep: return getVersion() >= VersionTuple(1, 6);\n    case ObjFW: return true;\n    }\n    llvm_unreachable(\"bad kind\");\n  }\n\n  /// Does this runtime provide ARC entrypoints that are likely to be faster\n  /// than an ordinary message send of the appropriate selector?\n  ///\n  /// The ARC entrypoints are guaranteed to be equivalent to just sending the\n  /// corresponding message.  If the entrypoint is implemented naively as just a\n  /// message send, using it is a trade-off: it sacrifices a few cycles of\n  /// overhead to save a small amount of code.  However, it's possible for\n  /// runtimes to detect and special-case classes that use \"standard\"\n  /// retain/release behavior; if that's dynamically a large proportion of all\n  /// retained objects, using the entrypoint will also be faster than using a\n  /// message send.\n  ///\n  /// When this method returns true, Clang will turn non-super message sends of\n  /// certain selectors into calls to the correspond entrypoint:\n  ///   retain => objc_retain\n  ///   release => objc_release\n  ///   autorelease => objc_autorelease\n  bool shouldUseARCFunctionsForRetainRelease() const {\n    switch (getKind()) {\n    case FragileMacOSX:\n      return false;\n    case MacOSX:\n      return getVersion() >= VersionTuple(10, 10);\n    case iOS:\n      return getVersion() >= VersionTuple(8);\n    case WatchOS:\n      return true;\n    case GCC:\n      return false;\n    case GNUstep:\n      return false;\n    case ObjFW:\n      return false;\n    }\n    llvm_unreachable(\"bad kind\");\n  }\n\n  /// Does this runtime provide entrypoints that are likely to be faster\n  /// than an ordinary message send of the \"alloc\" selector?\n  ///\n  /// The \"alloc\" entrypoint is guaranteed to be equivalent to just sending the\n  /// corresponding message.  If the entrypoint is implemented naively as just a\n  /// message send, using it is a trade-off: it sacrifices a few cycles of\n  /// overhead to save a small amount of code.  However, it's possible for\n  /// runtimes to detect and special-case classes that use \"standard\"\n  /// alloc behavior; if that's dynamically a large proportion of all\n  /// objects, using the entrypoint will also be faster than using a message\n  /// send.\n  ///\n  /// When this method returns true, Clang will turn non-super message sends of\n  /// certain selectors into calls to the corresponding entrypoint:\n  ///   alloc => objc_alloc\n  ///   allocWithZone:nil => objc_allocWithZone\n  bool shouldUseRuntimeFunctionsForAlloc() const {\n    switch (getKind()) {\n    case FragileMacOSX:\n      return false;\n    case MacOSX:\n      return getVersion() >= VersionTuple(10, 10);\n    case iOS:\n      return getVersion() >= VersionTuple(8);\n    case WatchOS:\n      return true;\n\n    case GCC:\n      return false;\n    case GNUstep:\n      return false;\n    case ObjFW:\n      return false;\n    }\n    llvm_unreachable(\"bad kind\");\n  }\n\n  /// Does this runtime provide the objc_alloc_init entrypoint? This can apply\n  /// the same optimization as objc_alloc, but also sends an -init message,\n  /// reducing code size on the caller.\n  bool shouldUseRuntimeFunctionForCombinedAllocInit() const {\n    switch (getKind()) {\n    case MacOSX:\n      return getVersion() >= VersionTuple(10, 14, 4);\n    case iOS:\n      return getVersion() >= VersionTuple(12, 2);\n    case WatchOS:\n      return getVersion() >= VersionTuple(5, 2);\n    default:\n      return false;\n    }\n  }\n\n  /// Does this runtime supports optimized setter entrypoints?\n  bool hasOptimizedSetter() const {\n    switch (getKind()) {\n      case MacOSX:\n        return getVersion() >= VersionTuple(10, 8);\n      case iOS:\n        return (getVersion() >= VersionTuple(6));\n      case WatchOS:\n        return true;\n      case GNUstep:\n        return getVersion() >= VersionTuple(1, 7);\n      default:\n        return false;\n    }\n  }\n\n  /// Does this runtime allow the use of __weak?\n  bool allowsWeak() const {\n    return hasNativeWeak();\n  }\n\n  /// Does this runtime natively provide ARC-compliant 'weak'\n  /// entrypoints?\n  bool hasNativeWeak() const {\n    // Right now, this is always equivalent to whether the runtime\n    // natively supports ARC decision.\n    return hasNativeARC();\n  }\n\n  /// Does this runtime directly support the subscripting methods?\n  ///\n  /// This is really a property of the library, not the runtime.\n  bool hasSubscripting() const {\n    switch (getKind()) {\n    case FragileMacOSX: return false;\n    case MacOSX: return getVersion() >= VersionTuple(10, 11);\n    case iOS: return getVersion() >= VersionTuple(9);\n    case WatchOS: return true;\n\n    // This is really a lie, because some implementations and versions\n    // of the runtime do not support ARC.  Probably -fgnu-runtime\n    // should imply a \"maximal\" runtime or something?\n    case GCC: return true;\n    case GNUstep: return true;\n    case ObjFW: return true;\n    }\n    llvm_unreachable(\"bad kind\");\n  }\n\n  /// Does this runtime allow sizeof or alignof on object types?\n  bool allowsSizeofAlignof() const {\n    return isFragile();\n  }\n\n  /// Does this runtime allow pointer arithmetic on objects?\n  ///\n  /// This covers +, -, ++, --, and (if isSubscriptPointerArithmetic()\n  /// yields true) [].\n  bool allowsPointerArithmetic() const {\n    switch (getKind()) {\n    case FragileMacOSX:\n    case GCC:\n      return true;\n    case MacOSX:\n    case iOS:\n    case WatchOS:\n    case GNUstep:\n    case ObjFW:\n      return false;\n    }\n    llvm_unreachable(\"bad kind\");\n  }\n\n  /// Is subscripting pointer arithmetic?\n  bool isSubscriptPointerArithmetic() const {\n    return allowsPointerArithmetic();\n  }\n\n  /// Does this runtime provide an objc_terminate function?\n  ///\n  /// This is used in handlers for exceptions during the unwind process;\n  /// without it, abort() must be used in pure ObjC files.\n  bool hasTerminate() const {\n    switch (getKind()) {\n    case FragileMacOSX: return getVersion() >= VersionTuple(10, 8);\n    case MacOSX: return getVersion() >= VersionTuple(10, 8);\n    case iOS: return getVersion() >= VersionTuple(5);\n    case WatchOS: return true;\n    case GCC: return false;\n    case GNUstep: return false;\n    case ObjFW: return false;\n    }\n    llvm_unreachable(\"bad kind\");\n  }\n\n  /// Does this runtime support weakly importing classes?\n  bool hasWeakClassImport() const {\n    switch (getKind()) {\n    case MacOSX: return true;\n    case iOS: return true;\n    case WatchOS: return true;\n    case FragileMacOSX: return false;\n    case GCC: return true;\n    case GNUstep: return true;\n    case ObjFW: return true;\n    }\n    llvm_unreachable(\"bad kind\");\n  }\n\n  /// Does this runtime use zero-cost exceptions?\n  bool hasUnwindExceptions() const {\n    switch (getKind()) {\n    case MacOSX: return true;\n    case iOS: return true;\n    case WatchOS: return true;\n    case FragileMacOSX: return false;\n    case GCC: return true;\n    case GNUstep: return true;\n    case ObjFW: return true;\n    }\n    llvm_unreachable(\"bad kind\");\n  }\n\n  bool hasAtomicCopyHelper() const {\n    switch (getKind()) {\n    case FragileMacOSX:\n    case MacOSX:\n    case iOS:\n    case WatchOS:\n      return true;\n    case GNUstep:\n      return getVersion() >= VersionTuple(1, 7);\n    default: return false;\n    }\n  }\n\n  /// Is objc_unsafeClaimAutoreleasedReturnValue available?\n  bool hasARCUnsafeClaimAutoreleasedReturnValue() const {\n    switch (getKind()) {\n    case MacOSX:\n    case FragileMacOSX:\n      return getVersion() >= VersionTuple(10, 11);\n    case iOS:\n      return getVersion() >= VersionTuple(9);\n    case WatchOS:\n      return getVersion() >= VersionTuple(2);\n    case GNUstep:\n      return false;\n    default:\n      return false;\n    }\n  }\n\n  /// Are the empty collection symbols available?\n  bool hasEmptyCollections() const {\n    switch (getKind()) {\n    default:\n      return false;\n    case MacOSX:\n      return getVersion() >= VersionTuple(10, 11);\n    case iOS:\n      return getVersion() >= VersionTuple(9);\n    case WatchOS:\n      return getVersion() >= VersionTuple(2);\n    }\n  }\n\n  /// Returns true if this Objective-C runtime supports Objective-C class\n  /// stubs.\n  bool allowsClassStubs() const {\n    switch (getKind()) {\n    case FragileMacOSX:\n    case GCC:\n    case GNUstep:\n    case ObjFW:\n      return false;\n    case MacOSX:\n    case iOS:\n    case WatchOS:\n      return true;\n    }\n    llvm_unreachable(\"bad kind\");\n  }\n\n  /// Does this runtime supports direct dispatch\n  bool allowsDirectDispatch() const {\n    switch (getKind()) {\n    case FragileMacOSX: return false;\n    case MacOSX: return true;\n    case iOS: return true;\n    case WatchOS: return true;\n    case GCC: return false;\n    case GNUstep: return false;\n    case ObjFW: return false;\n    }\n    llvm_unreachable(\"bad kind\");\n  }\n\n  /// Try to parse an Objective-C runtime specification from the given\n  /// string.\n  ///\n  /// \\return true on error.\n  bool tryParse(StringRef input);\n\n  std::string getAsString() const;\n\n  friend bool operator==(const ObjCRuntime &left, const ObjCRuntime &right) {\n    return left.getKind() == right.getKind() &&\n           left.getVersion() == right.getVersion();\n  }\n\n  friend bool operator!=(const ObjCRuntime &left, const ObjCRuntime &right) {\n    return !(left == right);\n  }\n\n  friend llvm::hash_code hash_value(const ObjCRuntime &OCR) {\n    return llvm::hash_combine(OCR.getKind(), OCR.getVersion());\n  }\n};\n\nraw_ostream &operator<<(raw_ostream &out, const ObjCRuntime &value);\n\n} // namespace clang\n\n#endif // LLVM_CLANG_BASIC_OBJCRUNTIME_H\n"}, "22": {"id": 22, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Basic/Sanitizers.h", "content": "//===- Sanitizers.h - C Language Family Language Options --------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n/// \\file\n/// Defines the clang::SanitizerKind enum.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_BASIC_SANITIZERS_H\n#define LLVM_CLANG_BASIC_SANITIZERS_H\n\n#include \"clang/Basic/LLVM.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/Support/MathExtras.h\"\n#include \"llvm/Transforms/Instrumentation/AddressSanitizerOptions.h\"\n#include <cassert>\n#include <cstdint>\n\nnamespace llvm {\nclass hash_code;\n}\n\nnamespace clang {\n\nclass SanitizerMask {\n  // NOTE: this class assumes kNumElem == 2 in most of the constexpr functions,\n  // in order to work within the C++11 constexpr function constraints. If you\n  // change kNumElem, you'll need to update those member functions as well.\n\n  /// Number of array elements.\n  static constexpr unsigned kNumElem = 2;\n  /// Mask value initialized to 0.\n  uint64_t maskLoToHigh[kNumElem]{};\n  /// Number of bits in a mask.\n  static constexpr unsigned kNumBits = sizeof(decltype(maskLoToHigh)) * 8;\n  /// Number of bits in a mask element.\n  static constexpr unsigned kNumBitElem = sizeof(decltype(maskLoToHigh[0])) * 8;\n\n  constexpr SanitizerMask(uint64_t mask1, uint64_t mask2)\n      : maskLoToHigh{mask1, mask2} {}\n\npublic:\n  SanitizerMask() = default;\n\n  static constexpr bool checkBitPos(const unsigned Pos) {\n    return Pos < kNumBits;\n  }\n\n  /// Create a mask with a bit enabled at position Pos.\n  static constexpr SanitizerMask bitPosToMask(const unsigned Pos) {\n    uint64_t mask1 = (Pos < kNumBitElem) ? 1ULL << (Pos % kNumBitElem) : 0;\n    uint64_t mask2 = (Pos >= kNumBitElem && Pos < (kNumBitElem * 2))\n                         ? 1ULL << (Pos % kNumBitElem)\n                         : 0;\n    return SanitizerMask(mask1, mask2);\n  }\n\n  unsigned countPopulation() const {\n    unsigned total = 0;\n    for (const auto &Val : maskLoToHigh)\n      total += llvm::countPopulation(Val);\n    return total;\n  }\n\n  void flipAllBits() {\n    for (auto &Val : maskLoToHigh)\n      Val = ~Val;\n  }\n\n  bool isPowerOf2() const {\n    return countPopulation() == 1;\n  }\n\n  llvm::hash_code hash_value() const;\n\n  constexpr explicit operator bool() const {\n    return maskLoToHigh[0] || maskLoToHigh[1];\n  }\n\n  constexpr bool operator==(const SanitizerMask &V) const {\n    return maskLoToHigh[0] == V.maskLoToHigh[0] &&\n           maskLoToHigh[1] == V.maskLoToHigh[1];\n  }\n\n  SanitizerMask &operator&=(const SanitizerMask &RHS) {\n    for (unsigned k = 0; k < kNumElem; k++)\n      maskLoToHigh[k] &= RHS.maskLoToHigh[k];\n    return *this;\n  }\n\n  SanitizerMask &operator|=(const SanitizerMask &RHS) {\n    for (unsigned k = 0; k < kNumElem; k++)\n      maskLoToHigh[k] |= RHS.maskLoToHigh[k];\n    return *this;\n  }\n\n  constexpr bool operator!() const { return !bool(*this); }\n\n  constexpr bool operator!=(const SanitizerMask &RHS) const {\n    return !((*this) == RHS);\n  }\n\n  friend constexpr inline SanitizerMask operator~(SanitizerMask v) {\n    return SanitizerMask(~v.maskLoToHigh[0], ~v.maskLoToHigh[1]);\n  }\n\n  friend constexpr inline SanitizerMask operator&(SanitizerMask a,\n                                                  const SanitizerMask &b) {\n    return SanitizerMask(a.maskLoToHigh[0] & b.maskLoToHigh[0],\n                         a.maskLoToHigh[1] & b.maskLoToHigh[1]);\n  }\n\n  friend constexpr inline SanitizerMask operator|(SanitizerMask a,\n                                                  const SanitizerMask &b) {\n    return SanitizerMask(a.maskLoToHigh[0] | b.maskLoToHigh[0],\n                         a.maskLoToHigh[1] | b.maskLoToHigh[1]);\n  }\n};\n\n// Declaring in clang namespace so that it can be found by ADL.\nllvm::hash_code hash_value(const clang::SanitizerMask &Arg);\n\n// Define the set of sanitizer kinds, as well as the set of sanitizers each\n// sanitizer group expands into.\nstruct SanitizerKind {\n  // Assign ordinals to possible values of -fsanitize= flag, which we will use\n  // as bit positions.\n  enum SanitizerOrdinal : uint64_t {\n#define SANITIZER(NAME, ID) SO_##ID,\n#define SANITIZER_GROUP(NAME, ID, ALIAS) SO_##ID##Group,\n#include \"clang/Basic/Sanitizers.def\"\n    SO_Count\n  };\n\n#define SANITIZER(NAME, ID)                                                    \\\n  static constexpr SanitizerMask ID = SanitizerMask::bitPosToMask(SO_##ID);    \\\n  static_assert(SanitizerMask::checkBitPos(SO_##ID), \"Bit position too big.\");\n#define SANITIZER_GROUP(NAME, ID, ALIAS)                                       \\\n  static constexpr SanitizerMask ID = SanitizerMask(ALIAS);                    \\\n  static constexpr SanitizerMask ID##Group =                                   \\\n      SanitizerMask::bitPosToMask(SO_##ID##Group);                             \\\n  static_assert(SanitizerMask::checkBitPos(SO_##ID##Group),                    \\\n                \"Bit position too big.\");\n#include \"clang/Basic/Sanitizers.def\"\n}; // SanitizerKind\n\nstruct SanitizerSet {\n  /// Check if a certain (single) sanitizer is enabled.\n  bool has(SanitizerMask K) const {\n    assert(K.isPowerOf2() && \"Has to be a single sanitizer.\");\n    return static_cast<bool>(Mask & K);\n  }\n\n  /// Check if one or more sanitizers are enabled.\n  bool hasOneOf(SanitizerMask K) const { return static_cast<bool>(Mask & K); }\n\n  /// Enable or disable a certain (single) sanitizer.\n  void set(SanitizerMask K, bool Value) {\n    assert(K.isPowerOf2() && \"Has to be a single sanitizer.\");\n    Mask = Value ? (Mask | K) : (Mask & ~K);\n  }\n\n  /// Disable the sanitizers specified in \\p K.\n  void clear(SanitizerMask K = SanitizerKind::All) { Mask &= ~K; }\n\n  /// Returns true if no sanitizers are enabled.\n  bool empty() const { return !Mask; }\n\n  /// Bitmask of enabled sanitizers.\n  SanitizerMask Mask;\n};\n\n/// Parse a single value from a -fsanitize= or -fno-sanitize= value list.\n/// Returns a non-zero SanitizerMask, or \\c 0 if \\p Value is not known.\nSanitizerMask parseSanitizerValue(StringRef Value, bool AllowGroups);\n\n/// Serialize a SanitizerSet into values for -fsanitize= or -fno-sanitize=.\nvoid serializeSanitizerSet(SanitizerSet Set,\n                           SmallVectorImpl<StringRef> &Values);\n\n/// For each sanitizer group bit set in \\p Kinds, set the bits for sanitizers\n/// this group enables.\nSanitizerMask expandSanitizerGroups(SanitizerMask Kinds);\n\n/// Return the sanitizers which do not affect preprocessing.\ninline SanitizerMask getPPTransparentSanitizers() {\n  return SanitizerKind::CFI | SanitizerKind::Integer |\n         SanitizerKind::ImplicitConversion | SanitizerKind::Nullability |\n         SanitizerKind::Undefined | SanitizerKind::FloatDivideByZero;\n}\n\nStringRef AsanDtorKindToString(llvm::AsanDtorKind kind);\n\nllvm::AsanDtorKind AsanDtorKindFromString(StringRef kind);\n\n} // namespace clang\n\n#endif // LLVM_CLANG_BASIC_SANITIZERS_H\n"}, "23": {"id": 23, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Basic/SourceLocation.h", "content": "//===- SourceLocation.h - Compact identifier for Source Files ---*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n/// \\file\n/// Defines the clang::SourceLocation class and associated facilities.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_BASIC_SOURCELOCATION_H\n#define LLVM_CLANG_BASIC_SOURCELOCATION_H\n\n#include \"clang/Basic/LLVM.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/Support/PointerLikeTypeTraits.h\"\n#include <cassert>\n#include <cstdint>\n#include <string>\n#include <utility>\n\nnamespace llvm {\n\ntemplate <typename T> struct DenseMapInfo;\n\nclass FoldingSetNodeID;\ntemplate <typename T> struct FoldingSetTrait;\n\n} // namespace llvm\n\nnamespace clang {\n\nclass SourceManager;\n\n/// An opaque identifier used by SourceManager which refers to a\n/// source file (MemoryBuffer) along with its \\#include path and \\#line data.\n///\nclass FileID {\n  /// A mostly-opaque identifier, where 0 is \"invalid\", >0 is\n  /// this module, and <-1 is something loaded from another module.\n  int ID = 0;\n\npublic:\n  bool isValid() const { return ID != 0; }\n  bool isInvalid() const { return ID == 0; }\n\n  bool operator==(const FileID &RHS) const { return ID == RHS.ID; }\n  bool operator<(const FileID &RHS) const { return ID < RHS.ID; }\n  bool operator<=(const FileID &RHS) const { return ID <= RHS.ID; }\n  bool operator!=(const FileID &RHS) const { return !(*this == RHS); }\n  bool operator>(const FileID &RHS) const { return RHS < *this; }\n  bool operator>=(const FileID &RHS) const { return RHS <= *this; }\n\n  static FileID getSentinel() { return get(-1); }\n  unsigned getHashValue() const { return static_cast<unsigned>(ID); }\n\nprivate:\n  friend class ASTWriter;\n  friend class ASTReader;\n  friend class SourceManager;\n\n  static FileID get(int V) {\n    FileID F;\n    F.ID = V;\n    return F;\n  }\n\n  int getOpaqueValue() const { return ID; }\n};\n\n/// Encodes a location in the source. The SourceManager can decode this\n/// to get at the full include stack, line and column information.\n///\n/// Technically, a source location is simply an offset into the manager's view\n/// of the input source, which is all input buffers (including macro\n/// expansions) concatenated in an effectively arbitrary order. The manager\n/// actually maintains two blocks of input buffers. One, starting at offset\n/// 0 and growing upwards, contains all buffers from this module. The other,\n/// starting at the highest possible offset and growing downwards, contains\n/// buffers of loaded modules.\n///\n/// In addition, one bit of SourceLocation is used for quick access to the\n/// information whether the location is in a file or a macro expansion.\n///\n/// It is important that this type remains small. It is currently 32 bits wide.\nclass SourceLocation {\n  friend class ASTReader;\n  friend class ASTWriter;\n  friend class SourceManager;\n  friend struct llvm::FoldingSetTrait<SourceLocation>;\n\n  unsigned ID = 0;\n\n  enum : unsigned {\n    MacroIDBit = 1U << 31\n  };\n\npublic:\n  bool isFileID() const  { return (ID & MacroIDBit) == 0; }\n  bool isMacroID() const { return (ID & MacroIDBit) != 0; }\n\n  /// Return true if this is a valid SourceLocation object.\n  ///\n  /// Invalid SourceLocations are often used when events have no corresponding\n  /// location in the source (e.g. a diagnostic is required for a command line\n  /// option).\n  bool isValid() const { return ID != 0; }\n  bool isInvalid() const { return ID == 0; }\n\nprivate:\n  /// Return the offset into the manager's global input view.\n  unsigned getOffset() const {\n    return ID & ~MacroIDBit;\n  }\n\n  static SourceLocation getFileLoc(unsigned ID) {\n    assert((ID & MacroIDBit) == 0 && \"Ran out of source locations!\");\n    SourceLocation L;\n    L.ID = ID;\n    return L;\n  }\n\n  static SourceLocation getMacroLoc(unsigned ID) {\n    assert((ID & MacroIDBit) == 0 && \"Ran out of source locations!\");\n    SourceLocation L;\n    L.ID = MacroIDBit | ID;\n    return L;\n  }\n\npublic:\n  /// Return a source location with the specified offset from this\n  /// SourceLocation.\n  SourceLocation getLocWithOffset(int Offset) const {\n    assert(((getOffset()+Offset) & MacroIDBit) == 0 && \"offset overflow\");\n    SourceLocation L;\n    L.ID = ID+Offset;\n    return L;\n  }\n\n  /// When a SourceLocation itself cannot be used, this returns\n  /// an (opaque) 32-bit integer encoding for it.\n  ///\n  /// This should only be passed to SourceLocation::getFromRawEncoding, it\n  /// should not be inspected directly.\n  unsigned getRawEncoding() const { return ID; }\n\n  /// Turn a raw encoding of a SourceLocation object into\n  /// a real SourceLocation.\n  ///\n  /// \\see getRawEncoding.\n  static SourceLocation getFromRawEncoding(unsigned Encoding) {\n    SourceLocation X;\n    X.ID = Encoding;\n    return X;\n  }\n\n  /// When a SourceLocation itself cannot be used, this returns\n  /// an (opaque) pointer encoding for it.\n  ///\n  /// This should only be passed to SourceLocation::getFromPtrEncoding, it\n  /// should not be inspected directly.\n  void* getPtrEncoding() const {\n    // Double cast to avoid a warning \"cast to pointer from integer of different\n    // size\".\n    return (void*)(uintptr_t)getRawEncoding();\n  }\n\n  /// Turn a pointer encoding of a SourceLocation object back\n  /// into a real SourceLocation.\n  static SourceLocation getFromPtrEncoding(const void *Encoding) {\n    return getFromRawEncoding((unsigned)(uintptr_t)Encoding);\n  }\n\n  static bool isPairOfFileLocations(SourceLocation Start, SourceLocation End) {\n    return Start.isValid() && Start.isFileID() && End.isValid() &&\n           End.isFileID();\n  }\n\n  unsigned getHashValue() const;\n  void print(raw_ostream &OS, const SourceManager &SM) const;\n  std::string printToString(const SourceManager &SM) const;\n  void dump(const SourceManager &SM) const;\n};\n\ninline bool operator==(const SourceLocation &LHS, const SourceLocation &RHS) {\n  return LHS.getRawEncoding() == RHS.getRawEncoding();\n}\n\ninline bool operator!=(const SourceLocation &LHS, const SourceLocation &RHS) {\n  return !(LHS == RHS);\n}\n\n// Ordering is meaningful only if LHS and RHS have the same FileID!\n// Otherwise use SourceManager::isBeforeInTranslationUnit().\ninline bool operator<(const SourceLocation &LHS, const SourceLocation &RHS) {\n  return LHS.getRawEncoding() < RHS.getRawEncoding();\n}\ninline bool operator>(const SourceLocation &LHS, const SourceLocation &RHS) {\n  return LHS.getRawEncoding() > RHS.getRawEncoding();\n}\ninline bool operator<=(const SourceLocation &LHS, const SourceLocation &RHS) {\n  return LHS.getRawEncoding() <= RHS.getRawEncoding();\n}\ninline bool operator>=(const SourceLocation &LHS, const SourceLocation &RHS) {\n  return LHS.getRawEncoding() >= RHS.getRawEncoding();\n}\n\n/// A trivial tuple used to represent a source range.\nclass SourceRange {\n  SourceLocation B;\n  SourceLocation E;\n\npublic:\n  SourceRange() = default;\n  SourceRange(SourceLocation loc) : B(loc), E(loc) {}\n  SourceRange(SourceLocation begin, SourceLocation end) : B(begin), E(end) {}\n\n  SourceLocation getBegin() const { return B; }\n  SourceLocation getEnd() const { return E; }\n\n  void setBegin(SourceLocation b) { B = b; }\n  void setEnd(SourceLocation e) { E = e; }\n\n  bool isValid() const { return B.isValid() && E.isValid(); }\n  bool isInvalid() const { return !isValid(); }\n\n  bool operator==(const SourceRange &X) const {\n    return B == X.B && E == X.E;\n  }\n\n  bool operator!=(const SourceRange &X) const {\n    return B != X.B || E != X.E;\n  }\n\n  // Returns true iff other is wholly contained within this range.\n  bool fullyContains(const SourceRange &other) const {\n    return B <= other.B && E >= other.E;\n  }\n\n  void print(raw_ostream &OS, const SourceManager &SM) const;\n  std::string printToString(const SourceManager &SM) const;\n  void dump(const SourceManager &SM) const;\n};\n\n/// Represents a character-granular source range.\n///\n/// The underlying SourceRange can either specify the starting/ending character\n/// of the range, or it can specify the start of the range and the start of the\n/// last token of the range (a \"token range\").  In the token range case, the\n/// size of the last token must be measured to determine the actual end of the\n/// range.\nclass CharSourceRange {\n  SourceRange Range;\n  bool IsTokenRange = false;\n\npublic:\n  CharSourceRange() = default;\n  CharSourceRange(SourceRange R, bool ITR) : Range(R), IsTokenRange(ITR) {}\n\n  static CharSourceRange getTokenRange(SourceRange R) {\n    return CharSourceRange(R, true);\n  }\n\n  static CharSourceRange getCharRange(SourceRange R) {\n    return CharSourceRange(R, false);\n  }\n\n  static CharSourceRange getTokenRange(SourceLocation B, SourceLocation E) {\n    return getTokenRange(SourceRange(B, E));\n  }\n\n  static CharSourceRange getCharRange(SourceLocation B, SourceLocation E) {\n    return getCharRange(SourceRange(B, E));\n  }\n\n  /// Return true if the end of this range specifies the start of\n  /// the last token.  Return false if the end of this range specifies the last\n  /// character in the range.\n  bool isTokenRange() const { return IsTokenRange; }\n  bool isCharRange() const { return !IsTokenRange; }\n\n  SourceLocation getBegin() const { return Range.getBegin(); }\n  SourceLocation getEnd() const { return Range.getEnd(); }\n  SourceRange getAsRange() const { return Range; }\n\n  void setBegin(SourceLocation b) { Range.setBegin(b); }\n  void setEnd(SourceLocation e) { Range.setEnd(e); }\n  void setTokenRange(bool TR) { IsTokenRange = TR; }\n\n  bool isValid() const { return Range.isValid(); }\n  bool isInvalid() const { return !isValid(); }\n};\n\n/// Represents an unpacked \"presumed\" location which can be presented\n/// to the user.\n///\n/// A 'presumed' location can be modified by \\#line and GNU line marker\n/// directives and is always the expansion point of a normal location.\n///\n/// You can get a PresumedLoc from a SourceLocation with SourceManager.\nclass PresumedLoc {\n  const char *Filename = nullptr;\n  FileID ID;\n  unsigned Line, Col;\n  SourceLocation IncludeLoc;\n\npublic:\n  PresumedLoc() = default;\n  PresumedLoc(const char *FN, FileID FID, unsigned Ln, unsigned Co,\n              SourceLocation IL)\n      : Filename(FN), ID(FID), Line(Ln), Col(Co), IncludeLoc(IL) {}\n\n  /// Return true if this object is invalid or uninitialized.\n  ///\n  /// This occurs when created with invalid source locations or when walking\n  /// off the top of a \\#include stack.\n  bool isInvalid() const { return Filename == nullptr; }\n  bool isValid() const { return Filename != nullptr; }\n\n  /// Return the presumed filename of this location.\n  ///\n  /// This can be affected by \\#line etc.\n  const char *getFilename() const {\n    assert(isValid());\n    return Filename;\n  }\n\n  FileID getFileID() const {\n    assert(isValid());\n    return ID;\n  }\n\n  /// Return the presumed line number of this location.\n  ///\n  /// This can be affected by \\#line etc.\n  unsigned getLine() const {\n    assert(isValid());\n    return Line;\n  }\n\n  /// Return the presumed column number of this location.\n  ///\n  /// This cannot be affected by \\#line, but is packaged here for convenience.\n  unsigned getColumn() const {\n    assert(isValid());\n    return Col;\n  }\n\n  /// Return the presumed include location of this location.\n  ///\n  /// This can be affected by GNU linemarker directives.\n  SourceLocation getIncludeLoc() const {\n    assert(isValid());\n    return IncludeLoc;\n  }\n};\n\nclass FileEntry;\n\n/// A SourceLocation and its associated SourceManager.\n///\n/// This is useful for argument passing to functions that expect both objects.\nclass FullSourceLoc : public SourceLocation {\n  const SourceManager *SrcMgr = nullptr;\n\npublic:\n  /// Creates a FullSourceLoc where isValid() returns \\c false.\n  FullSourceLoc() = default;\n\n  explicit FullSourceLoc(SourceLocation Loc, const SourceManager &SM)\n      : SourceLocation(Loc), SrcMgr(&SM) {}\n\n  bool hasManager() const {\n      bool hasSrcMgr =  SrcMgr != nullptr;\n      assert(hasSrcMgr == isValid() && \"FullSourceLoc has location but no manager\");\n      return hasSrcMgr;\n  }\n\n  /// \\pre This FullSourceLoc has an associated SourceManager.\n  const SourceManager &getManager() const {\n    assert(SrcMgr && \"SourceManager is NULL.\");\n    return *SrcMgr;\n  }\n\n  FileID getFileID() const;\n\n  FullSourceLoc getExpansionLoc() const;\n  FullSourceLoc getSpellingLoc() const;\n  FullSourceLoc getFileLoc() const;\n  PresumedLoc getPresumedLoc(bool UseLineDirectives = true) const;\n  bool isMacroArgExpansion(FullSourceLoc *StartLoc = nullptr) const;\n  FullSourceLoc getImmediateMacroCallerLoc() const;\n  std::pair<FullSourceLoc, StringRef> getModuleImportLoc() const;\n  unsigned getFileOffset() const;\n\n  unsigned getExpansionLineNumber(bool *Invalid = nullptr) const;\n  unsigned getExpansionColumnNumber(bool *Invalid = nullptr) const;\n\n  unsigned getSpellingLineNumber(bool *Invalid = nullptr) const;\n  unsigned getSpellingColumnNumber(bool *Invalid = nullptr) const;\n\n  const char *getCharacterData(bool *Invalid = nullptr) const;\n\n  unsigned getLineNumber(bool *Invalid = nullptr) const;\n  unsigned getColumnNumber(bool *Invalid = nullptr) const;\n\n  const FileEntry *getFileEntry() const;\n\n  /// Return a StringRef to the source buffer data for the\n  /// specified FileID.\n  StringRef getBufferData(bool *Invalid = nullptr) const;\n\n  /// Decompose the specified location into a raw FileID + Offset pair.\n  ///\n  /// The first element is the FileID, the second is the offset from the\n  /// start of the buffer of the location.\n  std::pair<FileID, unsigned> getDecomposedLoc() const;\n\n  bool isInSystemHeader() const;\n\n  /// Determines the order of 2 source locations in the translation unit.\n  ///\n  /// \\returns true if this source location comes before 'Loc', false otherwise.\n  bool isBeforeInTranslationUnitThan(SourceLocation Loc) const;\n\n  /// Determines the order of 2 source locations in the translation unit.\n  ///\n  /// \\returns true if this source location comes before 'Loc', false otherwise.\n  bool isBeforeInTranslationUnitThan(FullSourceLoc Loc) const {\n    assert(Loc.isValid());\n    assert(SrcMgr == Loc.SrcMgr && \"Loc comes from another SourceManager!\");\n    return isBeforeInTranslationUnitThan((SourceLocation)Loc);\n  }\n\n  /// Comparison function class, useful for sorting FullSourceLocs.\n  struct BeforeThanCompare {\n    bool operator()(const FullSourceLoc& lhs, const FullSourceLoc& rhs) const {\n      return lhs.isBeforeInTranslationUnitThan(rhs);\n    }\n  };\n\n  /// Prints information about this FullSourceLoc to stderr.\n  ///\n  /// This is useful for debugging.\n  void dump() const;\n\n  friend bool\n  operator==(const FullSourceLoc &LHS, const FullSourceLoc &RHS) {\n    return LHS.getRawEncoding() == RHS.getRawEncoding() &&\n          LHS.SrcMgr == RHS.SrcMgr;\n  }\n\n  friend bool\n  operator!=(const FullSourceLoc &LHS, const FullSourceLoc &RHS) {\n    return !(LHS == RHS);\n  }\n};\n\n} // namespace clang\n\nnamespace llvm {\n\n  /// Define DenseMapInfo so that FileID's can be used as keys in DenseMap and\n  /// DenseSets.\n  template <>\n  struct DenseMapInfo<clang::FileID> {\n    static clang::FileID getEmptyKey() {\n      return {};\n    }\n\n    static clang::FileID getTombstoneKey() {\n      return clang::FileID::getSentinel();\n    }\n\n    static unsigned getHashValue(clang::FileID S) {\n      return S.getHashValue();\n    }\n\n    static bool isEqual(clang::FileID LHS, clang::FileID RHS) {\n      return LHS == RHS;\n    }\n  };\n\n  /// Define DenseMapInfo so that SourceLocation's can be used as keys in\n  /// DenseMap and DenseSet. This trait class is eqivalent to\n  /// DenseMapInfo<unsigned> which uses SourceLocation::ID is used as a key.\n  template <> struct DenseMapInfo<clang::SourceLocation> {\n    static clang::SourceLocation getEmptyKey() {\n      return clang::SourceLocation::getFromRawEncoding(~0U);\n    }\n\n    static clang::SourceLocation getTombstoneKey() {\n      return clang::SourceLocation::getFromRawEncoding(~0U - 1);\n    }\n\n    static unsigned getHashValue(clang::SourceLocation Loc) {\n      return Loc.getHashValue();\n    }\n\n    static bool isEqual(clang::SourceLocation LHS, clang::SourceLocation RHS) {\n      return LHS == RHS;\n    }\n  };\n\n  // Allow calling FoldingSetNodeID::Add with SourceLocation object as parameter\n  template <> struct FoldingSetTrait<clang::SourceLocation> {\n    static void Profile(const clang::SourceLocation &X, FoldingSetNodeID &ID);\n  };\n\n  // Teach SmallPtrSet how to handle SourceLocation.\n  template<>\n  struct PointerLikeTypeTraits<clang::SourceLocation> {\n    static constexpr int NumLowBitsAvailable = 0;\n\n    static void *getAsVoidPointer(clang::SourceLocation L) {\n      return L.getPtrEncoding();\n    }\n\n    static clang::SourceLocation getFromVoidPointer(void *P) {\n      return clang::SourceLocation::getFromRawEncoding((unsigned)(uintptr_t)P);\n    }\n  };\n\n} // namespace llvm\n\n#endif // LLVM_CLANG_BASIC_SOURCELOCATION_H\n"}, "24": {"id": 24, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/DynamicTypeInfo.h", "content": "//===- DynamicTypeInfo.h - Runtime type information -------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_STATICANALYZER_CORE_PATHSENSITIVE_DYNAMICTYPEINFO_H\n#define LLVM_CLANG_STATICANALYZER_CORE_PATHSENSITIVE_DYNAMICTYPEINFO_H\n\n#include \"clang/AST/Type.h\"\n\nnamespace clang {\nnamespace ento {\n\n/// Stores the currently inferred strictest bound on the runtime type\n/// of a region in a given state along the analysis path.\nclass DynamicTypeInfo {\npublic:\n  DynamicTypeInfo() : DynTy(QualType()) {}\n\n  DynamicTypeInfo(QualType Ty, bool CanBeSub = true)\n      : DynTy(Ty), CanBeASubClass(CanBeSub) {}\n\n  /// Returns false if the type information is precise (the type 'DynTy' is\n  /// the only type in the lattice), true otherwise.\n  bool canBeASubClass() const { return CanBeASubClass; }\n\n  /// Returns true if the dynamic type info is available.\n  bool isValid() const { return !DynTy.isNull(); }\n\n  /// Returns the currently inferred upper bound on the runtime type.\n  QualType getType() const { return DynTy; }\n\n  operator bool() const { return isValid(); }\n\n  bool operator==(const DynamicTypeInfo &RHS) const {\n    return DynTy == RHS.DynTy && CanBeASubClass == RHS.CanBeASubClass;\n  }\n\n  void Profile(llvm::FoldingSetNodeID &ID) const {\n    ID.Add(DynTy);\n    ID.AddBoolean(CanBeASubClass);\n  }\n\nprivate:\n  QualType DynTy;\n  bool CanBeASubClass;\n};\n\n} // namespace ento\n} // namespace clang\n\n#endif // LLVM_CLANG_STATICANALYZER_CORE_PATHSENSITIVE_DYNAMICTYPEINFO_H\n"}, "25": {"id": 25, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/Environment.h", "content": "//===- Environment.h - Map from Stmt* to Locations/Values -------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n//  This file defined the Environment and EnvironmentManager classes.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_STATICANALYZER_CORE_PATHSENSITIVE_ENVIRONMENT_H\n#define LLVM_CLANG_STATICANALYZER_CORE_PATHSENSITIVE_ENVIRONMENT_H\n\n#include \"clang/Analysis/AnalysisDeclContext.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/ProgramState_Fwd.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/SVals.h\"\n#include \"llvm/ADT/ImmutableMap.h\"\n#include <utility>\n\nnamespace clang {\n\nclass Stmt;\n\nnamespace ento {\n\nclass SValBuilder;\nclass SymbolReaper;\n\n/// An entry in the environment consists of a Stmt and an LocationContext.\n/// This allows the environment to manage context-sensitive bindings,\n/// which is essentially for modeling recursive function analysis, among\n/// other things.\nclass EnvironmentEntry : public std::pair<const Stmt *,\n                                          const StackFrameContext *> {\npublic:\n  EnvironmentEntry(const Stmt *s, const LocationContext *L);\n\n  const Stmt *getStmt() const { return first; }\n  const LocationContext *getLocationContext() const { return second; }\n\n  /// Profile an EnvironmentEntry for inclusion in a FoldingSet.\n  static void Profile(llvm::FoldingSetNodeID &ID,\n                      const EnvironmentEntry &E) {\n    ID.AddPointer(E.getStmt());\n    ID.AddPointer(E.getLocationContext());\n  }\n\n  void Profile(llvm::FoldingSetNodeID &ID) const {\n    Profile(ID, *this);\n  }\n};\n\n/// An immutable map from EnvironemntEntries to SVals.\nclass Environment {\nprivate:\n  friend class EnvironmentManager;\n\n  using BindingsTy = llvm::ImmutableMap<EnvironmentEntry, SVal>;\n\n  BindingsTy ExprBindings;\n\n  Environment(BindingsTy eb) : ExprBindings(eb) {}\n\n  SVal lookupExpr(const EnvironmentEntry &E) const;\n\npublic:\n  using iterator = BindingsTy::iterator;\n\n  iterator begin() const { return ExprBindings.begin(); }\n  iterator end() const { return ExprBindings.end(); }\n\n  /// Fetches the current binding of the expression in the\n  /// Environment.\n  SVal getSVal(const EnvironmentEntry &E, SValBuilder &svalBuilder) const;\n\n  /// Profile - Profile the contents of an Environment object for use\n  ///  in a FoldingSet.\n  static void Profile(llvm::FoldingSetNodeID& ID, const Environment* env) {\n    env->ExprBindings.Profile(ID);\n  }\n\n  /// Profile - Used to profile the contents of this object for inclusion\n  ///  in a FoldingSet.\n  void Profile(llvm::FoldingSetNodeID& ID) const {\n    Profile(ID, this);\n  }\n\n  bool operator==(const Environment& RHS) const {\n    return ExprBindings == RHS.ExprBindings;\n  }\n\n  void printJson(raw_ostream &Out, const ASTContext &Ctx,\n                 const LocationContext *LCtx = nullptr, const char *NL = \"\\n\",\n                 unsigned int Space = 0, bool IsDot = false) const;\n};\n\nclass EnvironmentManager {\nprivate:\n  using FactoryTy = Environment::BindingsTy::Factory;\n\n  FactoryTy F;\n\npublic:\n  EnvironmentManager(llvm::BumpPtrAllocator &Allocator) : F(Allocator) {}\n\n  Environment getInitialEnvironment() {\n    return Environment(F.getEmptyMap());\n  }\n\n  /// Bind a symbolic value to the given environment entry.\n  Environment bindExpr(Environment Env, const EnvironmentEntry &E, SVal V,\n                       bool Invalidate);\n\n  Environment removeDeadBindings(Environment Env,\n                                 SymbolReaper &SymReaper,\n                                 ProgramStateRef state);\n};\n\n} // namespace ento\n\n} // namespace clang\n\n#endif // LLVM_CLANG_STATICANALYZER_CORE_PATHSENSITIVE_ENVIRONMENT_H\n"}, "26": {"id": 26, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/SVals.h", "content": "//===- SVals.h - Abstract Values for Static Analysis ------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n//  This file defines SVal, Loc, and NonLoc, classes that represent\n//  abstract r-values for use with path-sensitive value tracking.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_STATICANALYZER_CORE_PATHSENSITIVE_SVALS_H\n#define LLVM_CLANG_STATICANALYZER_CORE_PATHSENSITIVE_SVALS_H\n\n#include \"clang/AST/Expr.h\"\n#include \"clang/AST/Type.h\"\n#include \"clang/Basic/LLVM.h\"\n#include \"clang/StaticAnalyzer/Core/PathSensitive/SymExpr.h\"\n#include \"llvm/ADT/FoldingSet.h\"\n#include \"llvm/ADT/ImmutableList.h\"\n#include \"llvm/ADT/None.h\"\n#include \"llvm/ADT/Optional.h\"\n#include \"llvm/ADT/PointerUnion.h\"\n#include \"llvm/Support/Casting.h\"\n#include <cassert>\n#include <cstdint>\n#include <utility>\n\n//==------------------------------------------------------------------------==//\n//  Base SVal types.\n//==------------------------------------------------------------------------==//\n\nnamespace clang {\n\nclass CXXBaseSpecifier;\nclass DeclaratorDecl;\nclass FunctionDecl;\nclass LabelDecl;\n\nnamespace ento {\n\nclass BasicValueFactory;\nclass CompoundValData;\nclass LazyCompoundValData;\nclass MemRegion;\nclass PointerToMemberData;\nclass SValBuilder;\nclass TypedValueRegion;\n\nnamespace nonloc {\n\n/// Sub-kinds for NonLoc values.\nenum Kind {\n#define NONLOC_SVAL(Id, Parent) Id ## Kind,\n#include \"clang/StaticAnalyzer/Core/PathSensitive/SVals.def\"\n};\n\n} // namespace nonloc\n\nnamespace loc {\n\n/// Sub-kinds for Loc values.\nenum Kind {\n#define LOC_SVAL(Id, Parent) Id ## Kind,\n#include \"clang/StaticAnalyzer/Core/PathSensitive/SVals.def\"\n};\n\n} // namespace loc\n\n/// SVal - This represents a symbolic expression, which can be either\n///  an L-value or an R-value.\n///\nclass SVal {\npublic:\n  enum BaseKind {\n    // The enumerators must be representable using 2 bits.\n#define BASIC_SVAL(Id, Parent) Id ## Kind,\n#define ABSTRACT_SVAL_WITH_KIND(Id, Parent) Id ## Kind,\n#include \"clang/StaticAnalyzer/Core/PathSensitive/SVals.def\"\n  };\n  enum { BaseBits = 2, BaseMask = 0b11 };\n\nprotected:\n  const void *Data = nullptr;\n\n  /// The lowest 2 bits are a BaseKind (0 -- 3).\n  ///  The higher bits are an unsigned \"kind\" value.\n  unsigned Kind = 0;\n\n  explicit SVal(const void *d, bool isLoc, unsigned ValKind)\n      : Data(d), Kind((isLoc ? LocKind : NonLocKind) | (ValKind << BaseBits)) {}\n\n  explicit SVal(BaseKind k, const void *D = nullptr) : Data(D), Kind(k) {}\n\npublic:\n  explicit SVal() = default;\n\n  /// Convert to the specified SVal type, asserting that this SVal is of\n  /// the desired type.\n  template<typename T>\n  T castAs() const {\n    assert(T::isKind(*this));\n    return *static_cast<const T *>(this);\n  }\n\n  /// Convert to the specified SVal type, returning None if this SVal is\n  /// not of the desired type.\n  template<typename T>\n  Optional<T> getAs() const {\n    if (!T::isKind(*this))\n      return None;\n    return *static_cast<const T *>(this);\n  }\n\n  unsigned getRawKind() const { return Kind; }\n  BaseKind getBaseKind() const { return (BaseKind) (Kind & BaseMask); }\n  unsigned getSubKind() const { return Kind >> BaseBits; }\n\n  // This method is required for using SVal in a FoldingSetNode.  It\n  // extracts a unique signature for this SVal object.\n  void Profile(llvm::FoldingSetNodeID &ID) const {\n    ID.AddInteger((unsigned) getRawKind());\n    ID.AddPointer(Data);\n  }\n\n  bool operator==(const SVal &R) const {\n    return getRawKind() == R.getRawKind() && Data == R.Data;\n  }\n\n  bool operator!=(const SVal &R) const {\n    return !(*this == R);\n  }\n\n  bool isUnknown() const {\n    return getRawKind() == UnknownValKind;\n  }\n\n  bool isUndef() const {\n    return getRawKind() == UndefinedValKind;\n  }\n\n  bool isUnknownOrUndef() const {\n    return getRawKind() <= UnknownValKind;\n  }\n\n  bool isValid() const {\n    return getRawKind() > UnknownValKind;\n  }\n\n  bool isConstant() const;\n\n  bool isConstant(int I) const;\n\n  bool isZeroConstant() const;\n\n  /// hasConjuredSymbol - If this SVal wraps a conjured symbol, return true;\n  bool hasConjuredSymbol() const;\n\n  /// getAsFunctionDecl - If this SVal is a MemRegionVal and wraps a\n  /// CodeTextRegion wrapping a FunctionDecl, return that FunctionDecl.\n  /// Otherwise return 0.\n  const FunctionDecl *getAsFunctionDecl() const;\n\n  /// If this SVal is a location and wraps a symbol, return that\n  ///  SymbolRef. Otherwise return 0.\n  ///\n  /// Casts are ignored during lookup.\n  /// \\param IncludeBaseRegions The boolean that controls whether the search\n  /// should continue to the base regions if the region is not symbolic.\n  SymbolRef getAsLocSymbol(bool IncludeBaseRegions = false) const;\n\n  /// Get the symbol in the SVal or its base region.\n  SymbolRef getLocSymbolInBase() const;\n\n  /// If this SVal wraps a symbol return that SymbolRef.\n  /// Otherwise, return 0.\n  ///\n  /// Casts are ignored during lookup.\n  /// \\param IncludeBaseRegions The boolean that controls whether the search\n  /// should continue to the base regions if the region is not symbolic.\n  SymbolRef getAsSymbol(bool IncludeBaseRegions = false) const;\n\n  const MemRegion *getAsRegion() const;\n\n  /// printJson - Pretty-prints in JSON format.\n  void printJson(raw_ostream &Out, bool AddQuotes) const;\n\n  void dumpToStream(raw_ostream &OS) const;\n  void dump() const;\n\n  SymExpr::symbol_iterator symbol_begin() const {\n    const SymExpr *SE = getAsSymbol(/*IncludeBaseRegions=*/true);\n    if (SE)\n      return SE->symbol_begin();\n    else\n      return SymExpr::symbol_iterator();\n  }\n\n  SymExpr::symbol_iterator symbol_end() const {\n    return SymExpr::symbol_end();\n  }\n};\n\ninline raw_ostream &operator<<(raw_ostream &os, clang::ento::SVal V) {\n  V.dumpToStream(os);\n  return os;\n}\n\nclass UndefinedVal : public SVal {\npublic:\n  UndefinedVal() : SVal(UndefinedValKind) {}\n\nprivate:\n  friend class SVal;\n\n  static bool isKind(const SVal& V) {\n    return V.getBaseKind() == UndefinedValKind;\n  }\n};\n\nclass DefinedOrUnknownSVal : public SVal {\npublic:\n  // We want calling these methods to be a compiler error since they are\n  // tautologically false.\n  bool isUndef() const = delete;\n  bool isValid() const = delete;\n\nprotected:\n  DefinedOrUnknownSVal() = default;\n  explicit DefinedOrUnknownSVal(const void *d, bool isLoc, unsigned ValKind)\n      : SVal(d, isLoc, ValKind) {}\n  explicit DefinedOrUnknownSVal(BaseKind k, void *D = nullptr) : SVal(k, D) {}\n\nprivate:\n  friend class SVal;\n\n  static bool isKind(const SVal& V) {\n    return !V.isUndef();\n  }\n};\n\nclass UnknownVal : public DefinedOrUnknownSVal {\npublic:\n  explicit UnknownVal() : DefinedOrUnknownSVal(UnknownValKind) {}\n\nprivate:\n  friend class SVal;\n\n  static bool isKind(const SVal &V) {\n    return V.getBaseKind() == UnknownValKind;\n  }\n};\n\nclass DefinedSVal : public DefinedOrUnknownSVal {\npublic:\n  // We want calling these methods to be a compiler error since they are\n  // tautologically true/false.\n  bool isUnknown() const = delete;\n  bool isUnknownOrUndef() const = delete;\n  bool isValid() const = delete;\n\nprotected:\n  DefinedSVal() = default;\n  explicit DefinedSVal(const void *d, bool isLoc, unsigned ValKind)\n      : DefinedOrUnknownSVal(d, isLoc, ValKind) {}\n\nprivate:\n  friend class SVal;\n\n  static bool isKind(const SVal& V) {\n    return !V.isUnknownOrUndef();\n  }\n};\n\n/// Represents an SVal that is guaranteed to not be UnknownVal.\nclass KnownSVal : public SVal {\n  friend class SVal;\n\n  KnownSVal() = default;\n\n  static bool isKind(const SVal &V) {\n    return !V.isUnknown();\n  }\n\npublic:\n  KnownSVal(const DefinedSVal &V) : SVal(V) {}\n  KnownSVal(const UndefinedVal &V) : SVal(V) {}\n};\n\nclass NonLoc : public DefinedSVal {\nprotected:\n  NonLoc() = default;\n  explicit NonLoc(unsigned SubKind, const void *d)\n      : DefinedSVal(d, false, SubKind) {}\n\npublic:\n  void dumpToStream(raw_ostream &Out) const;\n\n  static bool isCompoundType(QualType T) {\n    return T->isArrayType() || T->isRecordType() ||\n           T->isAnyComplexType() || T->isVectorType();\n  }\n\nprivate:\n  friend class SVal;\n\n  static bool isKind(const SVal& V) {\n    return V.getBaseKind() == NonLocKind;\n  }\n};\n\nclass Loc : public DefinedSVal {\nprotected:\n  Loc() = default;\n  explicit Loc(unsigned SubKind, const void *D)\n      : DefinedSVal(const_cast<void *>(D), true, SubKind) {}\n\npublic:\n  void dumpToStream(raw_ostream &Out) const;\n\n  static bool isLocType(QualType T) {\n    return T->isAnyPointerType() || T->isBlockPointerType() ||\n           T->isReferenceType() || T->isNullPtrType();\n  }\n\nprivate:\n  friend class SVal;\n\n  static bool isKind(const SVal& V) {\n    return V.getBaseKind() == LocKind;\n  }\n};\n\n//==------------------------------------------------------------------------==//\n//  Subclasses of NonLoc.\n//==------------------------------------------------------------------------==//\n\nnamespace nonloc {\n\n/// Represents symbolic expression that isn't a location.\nclass SymbolVal : public NonLoc {\npublic:\n  SymbolVal() = delete;\n  SymbolVal(SymbolRef sym) : NonLoc(SymbolValKind, sym) {\n    assert(sym);\n    assert(!Loc::isLocType(sym->getType()));\n  }\n\n  SymbolRef getSymbol() const {\n    return (const SymExpr *) Data;\n  }\n\n  bool isExpression() const {\n    return !isa<SymbolData>(getSymbol());\n  }\n\nprivate:\n  friend class SVal;\n\n  static bool isKind(const SVal& V) {\n    return V.getBaseKind() == NonLocKind &&\n           V.getSubKind() == SymbolValKind;\n  }\n\n  static bool isKind(const NonLoc& V) {\n    return V.getSubKind() == SymbolValKind;\n  }\n};\n\n/// Value representing integer constant.\nclass ConcreteInt : public NonLoc {\npublic:\n  explicit ConcreteInt(const llvm::APSInt& V) : NonLoc(ConcreteIntKind, &V) {}\n\n  const llvm::APSInt& getValue() const {\n    return *static_cast<const llvm::APSInt *>(Data);\n  }\n\n  // Transfer functions for binary/unary operations on ConcreteInts.\n  SVal evalBinOp(SValBuilder &svalBuilder, BinaryOperator::Opcode Op,\n                 const ConcreteInt& R) const;\n\n  ConcreteInt evalComplement(SValBuilder &svalBuilder) const;\n\n  ConcreteInt evalMinus(SValBuilder &svalBuilder) const;\n\nprivate:\n  friend class SVal;\n\n  ConcreteInt() = default;\n\n  static bool isKind(const SVal& V) {\n    return V.getBaseKind() == NonLocKind &&\n           V.getSubKind() == ConcreteIntKind;\n  }\n\n  static bool isKind(const NonLoc& V) {\n    return V.getSubKind() == ConcreteIntKind;\n  }\n};\n\nclass LocAsInteger : public NonLoc {\n  friend class ento::SValBuilder;\n\n  explicit LocAsInteger(const std::pair<SVal, uintptr_t> &data)\n      : NonLoc(LocAsIntegerKind, &data) {\n    // We do not need to represent loc::ConcreteInt as LocAsInteger,\n    // as it'd collapse into a nonloc::ConcreteInt instead.\n    assert(data.first.getBaseKind() == LocKind &&\n           (data.first.getSubKind() == loc::MemRegionValKind ||\n            data.first.getSubKind() == loc::GotoLabelKind));\n  }\n\npublic:\n  Loc getLoc() const {\n    const std::pair<SVal, uintptr_t> *D =\n      static_cast<const std::pair<SVal, uintptr_t> *>(Data);\n    return D->first.castAs<Loc>();\n  }\n\n  Loc getPersistentLoc() const {\n    const std::pair<SVal, uintptr_t> *D =\n      static_cast<const std::pair<SVal, uintptr_t> *>(Data);\n    const SVal& V = D->first;\n    return V.castAs<Loc>();\n  }\n\n  unsigned getNumBits() const {\n    const std::pair<SVal, uintptr_t> *D =\n      static_cast<const std::pair<SVal, uintptr_t> *>(Data);\n    return D->second;\n  }\n\nprivate:\n  friend class SVal;\n\n  LocAsInteger() = default;\n\n  static bool isKind(const SVal& V) {\n    return V.getBaseKind() == NonLocKind &&\n           V.getSubKind() == LocAsIntegerKind;\n  }\n\n  static bool isKind(const NonLoc& V) {\n    return V.getSubKind() == LocAsIntegerKind;\n  }\n};\n\nclass CompoundVal : public NonLoc {\n  friend class ento::SValBuilder;\n\n  explicit CompoundVal(const CompoundValData* D) : NonLoc(CompoundValKind, D) {}\n\npublic:\n  const CompoundValData* getValue() const {\n    return static_cast<const CompoundValData *>(Data);\n  }\n\n  using iterator = llvm::ImmutableList<SVal>::iterator;\n\n  iterator begin() const;\n  iterator end() const;\n\nprivate:\n  friend class SVal;\n\n  CompoundVal() = default;\n\n  static bool isKind(const SVal& V) {\n    return V.getBaseKind() == NonLocKind && V.getSubKind() == CompoundValKind;\n  }\n\n  static bool isKind(const NonLoc& V) {\n    return V.getSubKind() == CompoundValKind;\n  }\n};\n\nclass LazyCompoundVal : public NonLoc {\n  friend class ento::SValBuilder;\n\n  explicit LazyCompoundVal(const LazyCompoundValData *D)\n      : NonLoc(LazyCompoundValKind, D) {}\n\npublic:\n  const LazyCompoundValData *getCVData() const {\n    return static_cast<const LazyCompoundValData *>(Data);\n  }\n\n  const void *getStore() const;\n  const TypedValueRegion *getRegion() const;\n\nprivate:\n  friend class SVal;\n\n  LazyCompoundVal() = default;\n\n  static bool isKind(const SVal& V) {\n    return V.getBaseKind() == NonLocKind &&\n           V.getSubKind() == LazyCompoundValKind;\n  }\n\n  static bool isKind(const NonLoc& V) {\n    return V.getSubKind() == LazyCompoundValKind;\n  }\n};\n\n/// Value representing pointer-to-member.\n///\n/// This value is qualified as NonLoc because neither loading nor storing\n/// operations are applied to it. Instead, the analyzer uses the L-value coming\n/// from pointer-to-member applied to an object.\n/// This SVal is represented by a NamedDecl which can be a member function\n/// pointer or a member data pointer and an optional list of CXXBaseSpecifiers.\n/// This list is required to accumulate the pointer-to-member cast history to\n/// figure out the correct subobject field. In particular, implicit casts grow\n/// this list and explicit casts like static_cast shrink this list.\nclass PointerToMember : public NonLoc {\n  friend class ento::SValBuilder;\n\npublic:\n  using PTMDataType =\n      llvm::PointerUnion<const NamedDecl *, const PointerToMemberData *>;\n\n  const PTMDataType getPTMData() const {\n    return PTMDataType::getFromOpaqueValue(const_cast<void *>(Data));\n  }\n\n  bool isNullMemberPointer() const;\n\n  const NamedDecl *getDecl() const;\n\n  template<typename AdjustedDecl>\n  const AdjustedDecl *getDeclAs() const {\n    return dyn_cast_or_null<AdjustedDecl>(getDecl());\n  }\n\n  using iterator = llvm::ImmutableList<const CXXBaseSpecifier *>::iterator;\n\n  iterator begin() const;\n  iterator end() const;\n\nprivate:\n  friend class SVal;\n\n  PointerToMember() = default;\n  explicit PointerToMember(const PTMDataType D)\n      : NonLoc(PointerToMemberKind, D.getOpaqueValue()) {}\n\n  static bool isKind(const SVal& V) {\n    return V.getBaseKind() == NonLocKind &&\n           V.getSubKind() == PointerToMemberKind;\n  }\n\n  static bool isKind(const NonLoc& V) {\n    return V.getSubKind() == PointerToMemberKind;\n  }\n};\n\n} // namespace nonloc\n\n//==------------------------------------------------------------------------==//\n//  Subclasses of Loc.\n//==------------------------------------------------------------------------==//\n\nnamespace loc {\n\nclass GotoLabel : public Loc {\npublic:\n  explicit GotoLabel(const LabelDecl *Label) : Loc(GotoLabelKind, Label) {\n    assert(Label);\n  }\n\n  const LabelDecl *getLabel() const {\n    return static_cast<const LabelDecl *>(Data);\n  }\n\nprivate:\n  friend class SVal;\n\n  GotoLabel() = default;\n\n  static bool isKind(const SVal& V) {\n    return V.getBaseKind() == LocKind && V.getSubKind() == GotoLabelKind;\n  }\n\n  static bool isKind(const Loc& V) {\n    return V.getSubKind() == GotoLabelKind;\n  }\n};\n\nclass MemRegionVal : public Loc {\npublic:\n  explicit MemRegionVal(const MemRegion* r) : Loc(MemRegionValKind, r) {\n    assert(r);\n  }\n\n  /// Get the underlining region.\n  const MemRegion *getRegion() const {\n    return static_cast<const MemRegion *>(Data);\n  }\n\n  /// Get the underlining region and strip casts.\n  const MemRegion* stripCasts(bool StripBaseCasts = true) const;\n\n  template <typename REGION>\n  const REGION* getRegionAs() const {\n    return dyn_cast<REGION>(getRegion());\n  }\n\n  bool operator==(const MemRegionVal &R) const {\n    return getRegion() == R.getRegion();\n  }\n\n  bool operator!=(const MemRegionVal &R) const {\n    return getRegion() != R.getRegion();\n  }\n\nprivate:\n  friend class SVal;\n\n  MemRegionVal() = default;\n\n  static bool isKind(const SVal& V) {\n    return V.getBaseKind() == LocKind &&\n           V.getSubKind() == MemRegionValKind;\n  }\n\n  static bool isKind(const Loc& V) {\n    return V.getSubKind() == MemRegionValKind;\n  }\n};\n\nclass ConcreteInt : public Loc {\npublic:\n  explicit ConcreteInt(const llvm::APSInt& V) : Loc(ConcreteIntKind, &V) {}\n\n  const llvm::APSInt &getValue() const {\n    return *static_cast<const llvm::APSInt *>(Data);\n  }\n\n  // Transfer functions for binary/unary operations on ConcreteInts.\n  SVal evalBinOp(BasicValueFactory& BasicVals, BinaryOperator::Opcode Op,\n                 const ConcreteInt& R) const;\n\nprivate:\n  friend class SVal;\n\n  ConcreteInt() = default;\n\n  static bool isKind(const SVal& V) {\n    return V.getBaseKind() == LocKind &&\n           V.getSubKind() == ConcreteIntKind;\n  }\n\n  static bool isKind(const Loc& V) {\n    return V.getSubKind() == ConcreteIntKind;\n  }\n};\n\n} // namespace loc\n\n} // namespace ento\n\n} // namespace clang\n\n#endif // LLVM_CLANG_STATICANALYZER_CORE_PATHSENSITIVE_SVALS_H\n"}, "27": {"id": 27, "path": "/home/vsts/work/1/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/SymExpr.h", "content": "//===- SymExpr.h - Management of Symbolic Values ----------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n//  This file defines SymExpr and SymbolData.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_STATICANALYZER_CORE_PATHSENSITIVE_SYMEXPR_H\n#define LLVM_CLANG_STATICANALYZER_CORE_PATHSENSITIVE_SYMEXPR_H\n\n#include \"clang/AST/Type.h\"\n#include \"clang/Basic/LLVM.h\"\n#include \"llvm/ADT/FoldingSet.h\"\n#include \"llvm/ADT/SmallVector.h\"\n#include <cassert>\n\nnamespace clang {\nnamespace ento {\n\nclass MemRegion;\n\n/// Symbolic value. These values used to capture symbolic execution of\n/// the program.\nclass SymExpr : public llvm::FoldingSetNode {\n  virtual void anchor();\n\npublic:\n  enum Kind {\n#define SYMBOL(Id, Parent) Id##Kind,\n#define SYMBOL_RANGE(Id, First, Last) BEGIN_##Id = First, END_##Id = Last,\n#include \"clang/StaticAnalyzer/Core/PathSensitive/Symbols.def\"\n  };\n\nprivate:\n  Kind K;\n\nprotected:\n  SymExpr(Kind k) : K(k) {}\n\n  static bool isValidTypeForSymbol(QualType T) {\n    // FIXME: Depending on whether we choose to deprecate structural symbols,\n    // this may become much stricter.\n    return !T.isNull() && !T->isVoidType();\n  }\n\n  mutable unsigned Complexity = 0;\n\npublic:\n  virtual ~SymExpr() = default;\n\n  Kind getKind() const { return K; }\n\n  virtual void dump() const;\n\n  virtual void dumpToStream(raw_ostream &os) const {}\n\n  virtual QualType getType() const = 0;\n  virtual void Profile(llvm::FoldingSetNodeID &profile) = 0;\n\n  /// Iterator over symbols that the current symbol depends on.\n  ///\n  /// For SymbolData, it's the symbol itself; for expressions, it's the\n  /// expression symbol and all the operands in it. Note, SymbolDerived is\n  /// treated as SymbolData - the iterator will NOT visit the parent region.\n  class symbol_iterator {\n    SmallVector<const SymExpr *, 5> itr;\n\n    void expand();\n\n  public:\n    symbol_iterator() = default;\n    symbol_iterator(const SymExpr *SE);\n\n    symbol_iterator &operator++();\n    const SymExpr *operator*();\n\n    bool operator==(const symbol_iterator &X) const;\n    bool operator!=(const symbol_iterator &X) const;\n  };\n\n  symbol_iterator symbol_begin() const { return symbol_iterator(this); }\n  static symbol_iterator symbol_end() { return symbol_iterator(); }\n\n  virtual unsigned computeComplexity() const = 0;\n\n  /// Find the region from which this symbol originates.\n  ///\n  /// Whenever the symbol was constructed to denote an unknown value of\n  /// a certain memory region, return this region. This method\n  /// allows checkers to make decisions depending on the origin of the symbol.\n  /// Symbol classes for which the origin region is known include\n  /// SymbolRegionValue which denotes the value of the region before\n  /// the beginning of the analysis, and SymbolDerived which denotes the value\n  /// of a certain memory region after its super region (a memory space or\n  /// a larger record region) is default-bound with a certain symbol.\n  virtual const MemRegion *getOriginRegion() const { return nullptr; }\n};\n\ninline raw_ostream &operator<<(raw_ostream &os,\n                               const clang::ento::SymExpr *SE) {\n  SE->dumpToStream(os);\n  return os;\n}\n\nusing SymbolRef = const SymExpr *;\nusing SymbolRefSmallVectorTy = SmallVector<SymbolRef, 2>;\nusing SymbolID = unsigned;\n\n/// A symbol representing data which can be stored in a memory location\n/// (region).\nclass SymbolData : public SymExpr {\n  const SymbolID Sym;\n\n  void anchor() override;\n\nprotected:\n  SymbolData(Kind k, SymbolID sym) : SymExpr(k), Sym(sym) {\n    assert(classof(this));\n  }\n\npublic:\n  ~SymbolData() override = default;\n\n  /// Get a string representation of the kind of the region.\n  virtual StringRef getKindStr() const = 0;\n\n  SymbolID getSymbolID() const { return Sym; }\n\n  unsigned computeComplexity() const override {\n    return 1;\n  };\n\n  // Implement isa<T> support.\n  static inline bool classof(const SymExpr *SE) {\n    Kind k = SE->getKind();\n    return k >= BEGIN_SYMBOLS && k <= END_SYMBOLS;\n  }\n};\n\n} // namespace ento\n} // namespace clang\n\n#endif // LLVM_CLANG_STATICANALYZER_CORE_PATHSENSITIVE_SYMEXPR_H\n"}, "28": {"id": 28, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/APFixedPoint.h", "content": "//===- APFixedPoint.h - Fixed point constant handling -----------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n/// \\file\n/// Defines the fixed point number interface.\n/// This is a class for abstracting various operations performed on fixed point\n/// types.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_ADT_APFIXEDPOINT_H\n#define LLVM_ADT_APFIXEDPOINT_H\n\n#include \"llvm/ADT/APSInt.h\"\n#include \"llvm/ADT/SmallString.h\"\n#include \"llvm/Support/raw_ostream.h\"\n\nnamespace llvm {\n\nclass APFloat;\nstruct fltSemantics;\n\n/// The fixed point semantics work similarly to fltSemantics. The width\n/// specifies the whole bit width of the underlying scaled integer (with padding\n/// if any). The scale represents the number of fractional bits in this type.\n/// When HasUnsignedPadding is true and this type is unsigned, the first bit\n/// in the value this represents is treated as padding.\nclass FixedPointSemantics {\npublic:\n  FixedPointSemantics(unsigned Width, unsigned Scale, bool IsSigned,\n                      bool IsSaturated, bool HasUnsignedPadding)\n      : Width(Width), Scale(Scale), IsSigned(IsSigned),\n        IsSaturated(IsSaturated), HasUnsignedPadding(HasUnsignedPadding) {\n    assert(Width >= Scale && \"Not enough room for the scale\");\n    assert(!(IsSigned && HasUnsignedPadding) &&\n           \"Cannot have unsigned padding on a signed type.\");\n  }\n\n  unsigned getWidth() const { return Width; }\n  unsigned getScale() const { return Scale; }\n  bool isSigned() const { return IsSigned; }\n  bool isSaturated() const { return IsSaturated; }\n  bool hasUnsignedPadding() const { return HasUnsignedPadding; }\n\n  void setSaturated(bool Saturated) { IsSaturated = Saturated; }\n\n  /// Return the number of integral bits represented by these semantics. These\n  /// are separate from the fractional bits and do not include the sign or\n  /// padding bit.\n  unsigned getIntegralBits() const {\n    if (IsSigned || (!IsSigned && HasUnsignedPadding))\n      return Width - Scale - 1;\n    else\n      return Width - Scale;\n  }\n\n  /// Return the FixedPointSemantics that allows for calculating the full\n  /// precision semantic that can precisely represent the precision and ranges\n  /// of both input values. This does not compute the resulting semantics for a\n  /// given binary operation.\n  FixedPointSemantics\n  getCommonSemantics(const FixedPointSemantics &Other) const;\n\n  /// Returns true if this fixed-point semantic with its value bits interpreted\n  /// as an integer can fit in the given floating point semantic without\n  /// overflowing to infinity.\n  /// For example, a signed 8-bit fixed-point semantic has a maximum and\n  /// minimum integer representation of 127 and -128, respectively. If both of\n  /// these values can be represented (possibly inexactly) in the floating\n  /// point semantic without overflowing, this returns true.\n  bool fitsInFloatSemantics(const fltSemantics &FloatSema) const;\n\n  /// Return the FixedPointSemantics for an integer type.\n  static FixedPointSemantics GetIntegerSemantics(unsigned Width,\n                                                 bool IsSigned) {\n    return FixedPointSemantics(Width, /*Scale=*/0, IsSigned,\n                               /*IsSaturated=*/false,\n                               /*HasUnsignedPadding=*/false);\n  }\n\nprivate:\n  unsigned Width          : 16;\n  unsigned Scale          : 13;\n  unsigned IsSigned       : 1;\n  unsigned IsSaturated    : 1;\n  unsigned HasUnsignedPadding : 1;\n};\n\n/// The APFixedPoint class works similarly to APInt/APSInt in that it is a\n/// functional replacement for a scaled integer. It is meant to replicate the\n/// fixed point types proposed in ISO/IEC JTC1 SC22 WG14 N1169. The class carries\n/// info about the fixed point type's width, sign, scale, and saturation, and\n/// provides different operations that would normally be performed on fixed point\n/// types.\nclass APFixedPoint {\npublic:\n  APFixedPoint(const APInt &Val, const FixedPointSemantics &Sema)\n      : Val(Val, !Sema.isSigned()), Sema(Sema) {\n    assert(Val.getBitWidth() == Sema.getWidth() &&\n           \"The value should have a bit width that matches the Sema width\");\n  }\n\n  APFixedPoint(uint64_t Val, const FixedPointSemantics &Sema)\n      : APFixedPoint(APInt(Sema.getWidth(), Val, Sema.isSigned()), Sema) {}\n\n  // Zero initialization.\n  APFixedPoint(const FixedPointSemantics &Sema) : APFixedPoint(0, Sema) {}\n\n  APSInt getValue() const { return APSInt(Val, !Sema.isSigned()); }\n  inline unsigned getWidth() const { return Sema.getWidth(); }\n  inline unsigned getScale() const { return Sema.getScale(); }\n  inline bool isSaturated() const { return Sema.isSaturated(); }\n  inline bool isSigned() const { return Sema.isSigned(); }\n  inline bool hasPadding() const { return Sema.hasUnsignedPadding(); }\n  FixedPointSemantics getSemantics() const { return Sema; }\n\n  bool getBoolValue() const { return Val.getBoolValue(); }\n\n  // Convert this number to match the semantics provided. If the overflow\n  // parameter is provided, set this value to true or false to indicate if this\n  // operation results in an overflow.\n  APFixedPoint convert(const FixedPointSemantics &DstSema,\n                       bool *Overflow = nullptr) const;\n\n  // Perform binary operations on a fixed point type. The resulting fixed point\n  // value will be in the common, full precision semantics that can represent\n  // the precision and ranges of both input values. See convert() for an\n  // explanation of the Overflow parameter.\n  APFixedPoint add(const APFixedPoint &Other, bool *Overflow = nullptr) const;\n  APFixedPoint sub(const APFixedPoint &Other, bool *Overflow = nullptr) const;\n  APFixedPoint mul(const APFixedPoint &Other, bool *Overflow = nullptr) const;\n  APFixedPoint div(const APFixedPoint &Other, bool *Overflow = nullptr) const;\n\n  // Perform shift operations on a fixed point type. Unlike the other binary\n  // operations, the resulting fixed point value will be in the original\n  // semantic.\n  APFixedPoint shl(unsigned Amt, bool *Overflow = nullptr) const;\n  APFixedPoint shr(unsigned Amt, bool *Overflow = nullptr) const {\n    // Right shift cannot overflow.\n    if (Overflow)\n      *Overflow = false;\n    return APFixedPoint(Val >> Amt, Sema);\n  }\n\n  /// Perform a unary negation (-X) on this fixed point type, taking into\n  /// account saturation if applicable.\n  APFixedPoint negate(bool *Overflow = nullptr) const;\n\n  /// Return the integral part of this fixed point number, rounded towards\n  /// zero. (-2.5k -> -2)\n  APSInt getIntPart() const {\n    if (Val < 0 && Val != -Val) // Cover the case when we have the min val\n      return -(-Val >> getScale());\n    else\n      return Val >> getScale();\n  }\n\n  /// Return the integral part of this fixed point number, rounded towards\n  /// zero. The value is stored into an APSInt with the provided width and sign.\n  /// If the overflow parameter is provided, and the integral value is not able\n  /// to be fully stored in the provided width and sign, the overflow parameter\n  /// is set to true.\n  APSInt convertToInt(unsigned DstWidth, bool DstSign,\n                      bool *Overflow = nullptr) const;\n\n  /// Convert this fixed point number to a floating point value with the\n  /// provided semantics.\n  APFloat convertToFloat(const fltSemantics &FloatSema) const;\n\n  void toString(SmallVectorImpl<char> &Str) const;\n  std::string toString() const {\n    SmallString<40> S;\n    toString(S);\n    return std::string(S.str());\n  }\n\n  // If LHS > RHS, return 1. If LHS == RHS, return 0. If LHS < RHS, return -1.\n  int compare(const APFixedPoint &Other) const;\n  bool operator==(const APFixedPoint &Other) const {\n    return compare(Other) == 0;\n  }\n  bool operator!=(const APFixedPoint &Other) const {\n    return compare(Other) != 0;\n  }\n  bool operator>(const APFixedPoint &Other) const { return compare(Other) > 0; }\n  bool operator<(const APFixedPoint &Other) const { return compare(Other) < 0; }\n  bool operator>=(const APFixedPoint &Other) const {\n    return compare(Other) >= 0;\n  }\n  bool operator<=(const APFixedPoint &Other) const {\n    return compare(Other) <= 0;\n  }\n\n  static APFixedPoint getMax(const FixedPointSemantics &Sema);\n  static APFixedPoint getMin(const FixedPointSemantics &Sema);\n\n  /// Given a floating point semantic, return the next floating point semantic\n  /// with a larger exponent and larger or equal mantissa.\n  static const fltSemantics *promoteFloatSemantics(const fltSemantics *S);\n\n  /// Create an APFixedPoint with a value equal to that of the provided integer,\n  /// and in the same semantics as the provided target semantics. If the value\n  /// is not able to fit in the specified fixed point semantics, and the\n  /// overflow parameter is provided, it is set to true.\n  static APFixedPoint getFromIntValue(const APSInt &Value,\n                                      const FixedPointSemantics &DstFXSema,\n                                      bool *Overflow = nullptr);\n\n  /// Create an APFixedPoint with a value equal to that of the provided\n  /// floating point value, in the provided target semantics. If the value is\n  /// not able to fit in the specified fixed point semantics and the overflow\n  /// parameter is specified, it is set to true.\n  /// For NaN, the Overflow flag is always set. For +inf and -inf, if the\n  /// semantic is saturating, the value saturates. Otherwise, the Overflow flag\n  /// is set.\n  static APFixedPoint getFromFloatValue(const APFloat &Value,\n                                        const FixedPointSemantics &DstFXSema,\n                                        bool *Overflow = nullptr);\n\nprivate:\n  APSInt Val;\n  FixedPointSemantics Sema;\n};\n\ninline raw_ostream &operator<<(raw_ostream &OS, const APFixedPoint &FX) {\n  OS << FX.toString();\n  return OS;\n}\n\n} // namespace llvm\n\n#endif\n"}, "29": {"id": 29, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/APFloat.h", "content": "//===- llvm/ADT/APFloat.h - Arbitrary Precision Floating Point ---*- C++ -*-==//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n///\n/// \\file\n/// \\brief\n/// This file declares a class to represent arbitrary precision floating point\n/// values and provide a variety of arithmetic operations on them.\n///\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_ADT_APFLOAT_H\n#define LLVM_ADT_APFLOAT_H\n\n#include \"llvm/ADT/APInt.h\"\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/ADT/FloatingPointMode.h\"\n#include \"llvm/Support/ErrorHandling.h\"\n#include <memory>\n\n#define APFLOAT_DISPATCH_ON_SEMANTICS(METHOD_CALL)                             \\\n  do {                                                                         \\\n    if (usesLayout<IEEEFloat>(getSemantics()))                                 \\\n      return U.IEEE.METHOD_CALL;                                               \\\n    if (usesLayout<DoubleAPFloat>(getSemantics()))                             \\\n      return U.Double.METHOD_CALL;                                             \\\n    llvm_unreachable(\"Unexpected semantics\");                                  \\\n  } while (false)\n\nnamespace llvm {\n\nstruct fltSemantics;\nclass APSInt;\nclass StringRef;\nclass APFloat;\nclass raw_ostream;\n\ntemplate <typename T> class Expected;\ntemplate <typename T> class SmallVectorImpl;\n\n/// Enum that represents what fraction of the LSB truncated bits of an fp number\n/// represent.\n///\n/// This essentially combines the roles of guard and sticky bits.\nenum lostFraction { // Example of truncated bits:\n  lfExactlyZero,    // 000000\n  lfLessThanHalf,   // 0xxxxx  x's not all zero\n  lfExactlyHalf,    // 100000\n  lfMoreThanHalf    // 1xxxxx  x's not all zero\n};\n\n/// A self-contained host- and target-independent arbitrary-precision\n/// floating-point software implementation.\n///\n/// APFloat uses bignum integer arithmetic as provided by static functions in\n/// the APInt class.  The library will work with bignum integers whose parts are\n/// any unsigned type at least 16 bits wide, but 64 bits is recommended.\n///\n/// Written for clarity rather than speed, in particular with a view to use in\n/// the front-end of a cross compiler so that target arithmetic can be correctly\n/// performed on the host.  Performance should nonetheless be reasonable,\n/// particularly for its intended use.  It may be useful as a base\n/// implementation for a run-time library during development of a faster\n/// target-specific one.\n///\n/// All 5 rounding modes in the IEEE-754R draft are handled correctly for all\n/// implemented operations.  Currently implemented operations are add, subtract,\n/// multiply, divide, fused-multiply-add, conversion-to-float,\n/// conversion-to-integer and conversion-from-integer.  New rounding modes\n/// (e.g. away from zero) can be added with three or four lines of code.\n///\n/// Four formats are built-in: IEEE single precision, double precision,\n/// quadruple precision, and x87 80-bit extended double (when operating with\n/// full extended precision).  Adding a new format that obeys IEEE semantics\n/// only requires adding two lines of code: a declaration and definition of the\n/// format.\n///\n/// All operations return the status of that operation as an exception bit-mask,\n/// so multiple operations can be done consecutively with their results or-ed\n/// together.  The returned status can be useful for compiler diagnostics; e.g.,\n/// inexact, underflow and overflow can be easily diagnosed on constant folding,\n/// and compiler optimizers can determine what exceptions would be raised by\n/// folding operations and optimize, or perhaps not optimize, accordingly.\n///\n/// At present, underflow tininess is detected after rounding; it should be\n/// straight forward to add support for the before-rounding case too.\n///\n/// The library reads hexadecimal floating point numbers as per C99, and\n/// correctly rounds if necessary according to the specified rounding mode.\n/// Syntax is required to have been validated by the caller.  It also converts\n/// floating point numbers to hexadecimal text as per the C99 %a and %A\n/// conversions.  The output precision (or alternatively the natural minimal\n/// precision) can be specified; if the requested precision is less than the\n/// natural precision the output is correctly rounded for the specified rounding\n/// mode.\n///\n/// It also reads decimal floating point numbers and correctly rounds according\n/// to the specified rounding mode.\n///\n/// Conversion to decimal text is not currently implemented.\n///\n/// Non-zero finite numbers are represented internally as a sign bit, a 16-bit\n/// signed exponent, and the significand as an array of integer parts.  After\n/// normalization of a number of precision P the exponent is within the range of\n/// the format, and if the number is not denormal the P-th bit of the\n/// significand is set as an explicit integer bit.  For denormals the most\n/// significant bit is shifted right so that the exponent is maintained at the\n/// format's minimum, so that the smallest denormal has just the least\n/// significant bit of the significand set.  The sign of zeroes and infinities\n/// is significant; the exponent and significand of such numbers is not stored,\n/// but has a known implicit (deterministic) value: 0 for the significands, 0\n/// for zero exponent, all 1 bits for infinity exponent.  For NaNs the sign and\n/// significand are deterministic, although not really meaningful, and preserved\n/// in non-conversion operations.  The exponent is implicitly all 1 bits.\n///\n/// APFloat does not provide any exception handling beyond default exception\n/// handling. We represent Signaling NaNs via IEEE-754R 2008 6.2.1 should clause\n/// by encoding Signaling NaNs with the first bit of its trailing significand as\n/// 0.\n///\n/// TODO\n/// ====\n///\n/// Some features that may or may not be worth adding:\n///\n/// Binary to decimal conversion (hard).\n///\n/// Optional ability to detect underflow tininess before rounding.\n///\n/// New formats: x87 in single and double precision mode (IEEE apart from\n/// extended exponent range) (hard).\n///\n/// New operations: sqrt, IEEE remainder, C90 fmod, nexttoward.\n///\n\n// This is the common type definitions shared by APFloat and its internal\n// implementation classes. This struct should not define any non-static data\n// members.\nstruct APFloatBase {\n  typedef APInt::WordType integerPart;\n  static constexpr unsigned integerPartWidth = APInt::APINT_BITS_PER_WORD;\n\n  /// A signed type to represent a floating point numbers unbiased exponent.\n  typedef int32_t ExponentType;\n\n  /// \\name Floating Point Semantics.\n  /// @{\n  enum Semantics {\n    S_IEEEhalf,\n    S_BFloat,\n    S_IEEEsingle,\n    S_IEEEdouble,\n    S_x87DoubleExtended,\n    S_IEEEquad,\n    S_PPCDoubleDouble\n  };\n\n  static const llvm::fltSemantics &EnumToSemantics(Semantics S);\n  static Semantics SemanticsToEnum(const llvm::fltSemantics &Sem);\n\n  static const fltSemantics &IEEEhalf() LLVM_READNONE;\n  static const fltSemantics &BFloat() LLVM_READNONE;\n  static const fltSemantics &IEEEsingle() LLVM_READNONE;\n  static const fltSemantics &IEEEdouble() LLVM_READNONE;\n  static const fltSemantics &IEEEquad() LLVM_READNONE;\n  static const fltSemantics &PPCDoubleDouble() LLVM_READNONE;\n  static const fltSemantics &x87DoubleExtended() LLVM_READNONE;\n\n  /// A Pseudo fltsemantic used to construct APFloats that cannot conflict with\n  /// anything real.\n  static const fltSemantics &Bogus() LLVM_READNONE;\n\n  /// @}\n\n  /// IEEE-754R 5.11: Floating Point Comparison Relations.\n  enum cmpResult {\n    cmpLessThan,\n    cmpEqual,\n    cmpGreaterThan,\n    cmpUnordered\n  };\n\n  /// IEEE-754R 4.3: Rounding-direction attributes.\n  using roundingMode = llvm::RoundingMode;\n\n  static constexpr roundingMode rmNearestTiesToEven =\n                                                RoundingMode::NearestTiesToEven;\n  static constexpr roundingMode rmTowardPositive = RoundingMode::TowardPositive;\n  static constexpr roundingMode rmTowardNegative = RoundingMode::TowardNegative;\n  static constexpr roundingMode rmTowardZero     = RoundingMode::TowardZero;\n  static constexpr roundingMode rmNearestTiesToAway =\n                                                RoundingMode::NearestTiesToAway;\n\n  /// IEEE-754R 7: Default exception handling.\n  ///\n  /// opUnderflow or opOverflow are always returned or-ed with opInexact.\n  ///\n  /// APFloat models this behavior specified by IEEE-754:\n  ///   \"For operations producing results in floating-point format, the default\n  ///    result of an operation that signals the invalid operation exception\n  ///    shall be a quiet NaN.\"\n  enum opStatus {\n    opOK = 0x00,\n    opInvalidOp = 0x01,\n    opDivByZero = 0x02,\n    opOverflow = 0x04,\n    opUnderflow = 0x08,\n    opInexact = 0x10\n  };\n\n  /// Category of internally-represented number.\n  enum fltCategory {\n    fcInfinity,\n    fcNaN,\n    fcNormal,\n    fcZero\n  };\n\n  /// Convenience enum used to construct an uninitialized APFloat.\n  enum uninitializedTag {\n    uninitialized\n  };\n\n  /// Enumeration of \\c ilogb error results.\n  enum IlogbErrorKinds {\n    IEK_Zero = INT_MIN + 1,\n    IEK_NaN = INT_MIN,\n    IEK_Inf = INT_MAX\n  };\n\n  static unsigned int semanticsPrecision(const fltSemantics &);\n  static ExponentType semanticsMinExponent(const fltSemantics &);\n  static ExponentType semanticsMaxExponent(const fltSemantics &);\n  static unsigned int semanticsSizeInBits(const fltSemantics &);\n\n  /// Returns the size of the floating point number (in bits) in the given\n  /// semantics.\n  static unsigned getSizeInBits(const fltSemantics &Sem);\n};\n\nnamespace detail {\n\nclass IEEEFloat final : public APFloatBase {\npublic:\n  /// \\name Constructors\n  /// @{\n\n  IEEEFloat(const fltSemantics &); // Default construct to +0.0\n  IEEEFloat(const fltSemantics &, integerPart);\n  IEEEFloat(const fltSemantics &, uninitializedTag);\n  IEEEFloat(const fltSemantics &, const APInt &);\n  explicit IEEEFloat(double d);\n  explicit IEEEFloat(float f);\n  IEEEFloat(const IEEEFloat &);\n  IEEEFloat(IEEEFloat &&);\n  ~IEEEFloat();\n\n  /// @}\n\n  /// Returns whether this instance allocated memory.\n  bool needsCleanup() const { return partCount() > 1; }\n\n  /// \\name Convenience \"constructors\"\n  /// @{\n\n  /// @}\n\n  /// \\name Arithmetic\n  /// @{\n\n  opStatus add(const IEEEFloat &, roundingMode);\n  opStatus subtract(const IEEEFloat &, roundingMode);\n  opStatus multiply(const IEEEFloat &, roundingMode);\n  opStatus divide(const IEEEFloat &, roundingMode);\n  /// IEEE remainder.\n  opStatus remainder(const IEEEFloat &);\n  /// C fmod, or llvm frem.\n  opStatus mod(const IEEEFloat &);\n  opStatus fusedMultiplyAdd(const IEEEFloat &, const IEEEFloat &, roundingMode);\n  opStatus roundToIntegral(roundingMode);\n  /// IEEE-754R 5.3.1: nextUp/nextDown.\n  opStatus next(bool nextDown);\n\n  /// @}\n\n  /// \\name Sign operations.\n  /// @{\n\n  void changeSign();\n\n  /// @}\n\n  /// \\name Conversions\n  /// @{\n\n  opStatus convert(const fltSemantics &, roundingMode, bool *);\n  opStatus convertToInteger(MutableArrayRef<integerPart>, unsigned int, bool,\n                            roundingMode, bool *) const;\n  opStatus convertFromAPInt(const APInt &, bool, roundingMode);\n  opStatus convertFromSignExtendedInteger(const integerPart *, unsigned int,\n                                          bool, roundingMode);\n  opStatus convertFromZeroExtendedInteger(const integerPart *, unsigned int,\n                                          bool, roundingMode);\n  Expected<opStatus> convertFromString(StringRef, roundingMode);\n  APInt bitcastToAPInt() const;\n  double convertToDouble() const;\n  float convertToFloat() const;\n\n  /// @}\n\n  /// The definition of equality is not straightforward for floating point, so\n  /// we won't use operator==.  Use one of the following, or write whatever it\n  /// is you really mean.\n  bool operator==(const IEEEFloat &) const = delete;\n\n  /// IEEE comparison with another floating point number (NaNs compare\n  /// unordered, 0==-0).\n  cmpResult compare(const IEEEFloat &) const;\n\n  /// Bitwise comparison for equality (QNaNs compare equal, 0!=-0).\n  bool bitwiseIsEqual(const IEEEFloat &) const;\n\n  /// Write out a hexadecimal representation of the floating point value to DST,\n  /// which must be of sufficient size, in the C99 form [-]0xh.hhhhp[+-]d.\n  /// Return the number of characters written, excluding the terminating NUL.\n  unsigned int convertToHexString(char *dst, unsigned int hexDigits,\n                                  bool upperCase, roundingMode) const;\n\n  /// \\name IEEE-754R 5.7.2 General operations.\n  /// @{\n\n  /// IEEE-754R isSignMinus: Returns true if and only if the current value is\n  /// negative.\n  ///\n  /// This applies to zeros and NaNs as well.\n  bool isNegative() const { return sign; }\n\n  /// IEEE-754R isNormal: Returns true if and only if the current value is normal.\n  ///\n  /// This implies that the current value of the float is not zero, subnormal,\n  /// infinite, or NaN following the definition of normality from IEEE-754R.\n  bool isNormal() const { return !isDenormal() && isFiniteNonZero(); }\n\n  /// Returns true if and only if the current value is zero, subnormal, or\n  /// normal.\n  ///\n  /// This means that the value is not infinite or NaN.\n  bool isFinite() const { return !isNaN() && !isInfinity(); }\n\n  /// Returns true if and only if the float is plus or minus zero.\n  bool isZero() const { return category == fcZero; }\n\n  /// IEEE-754R isSubnormal(): Returns true if and only if the float is a\n  /// denormal.\n  bool isDenormal() const;\n\n  /// IEEE-754R isInfinite(): Returns true if and only if the float is infinity.\n  bool isInfinity() const { return category == fcInfinity; }\n\n  /// Returns true if and only if the float is a quiet or signaling NaN.\n  bool isNaN() const { return category == fcNaN; }\n\n  /// Returns true if and only if the float is a signaling NaN.\n  bool isSignaling() const;\n\n  /// @}\n\n  /// \\name Simple Queries\n  /// @{\n\n  fltCategory getCategory() const { return category; }\n  const fltSemantics &getSemantics() const { return *semantics; }\n  bool isNonZero() const { return category != fcZero; }\n  bool isFiniteNonZero() const { return isFinite() && !isZero(); }\n  bool isPosZero() const { return isZero() && !isNegative(); }\n  bool isNegZero() const { return isZero() && isNegative(); }\n\n  /// Returns true if and only if the number has the smallest possible non-zero\n  /// magnitude in the current semantics.\n  bool isSmallest() const;\n\n  /// Returns true if and only if the number has the largest possible finite\n  /// magnitude in the current semantics.\n  bool isLargest() const;\n\n  /// Returns true if and only if the number is an exact integer.\n  bool isInteger() const;\n\n  /// @}\n\n  IEEEFloat &operator=(const IEEEFloat &);\n  IEEEFloat &operator=(IEEEFloat &&);\n\n  /// Overload to compute a hash code for an APFloat value.\n  ///\n  /// Note that the use of hash codes for floating point values is in general\n  /// frought with peril. Equality is hard to define for these values. For\n  /// example, should negative and positive zero hash to different codes? Are\n  /// they equal or not? This hash value implementation specifically\n  /// emphasizes producing different codes for different inputs in order to\n  /// be used in canonicalization and memoization. As such, equality is\n  /// bitwiseIsEqual, and 0 != -0.\n  friend hash_code hash_value(const IEEEFloat &Arg);\n\n  /// Converts this value into a decimal string.\n  ///\n  /// \\param FormatPrecision The maximum number of digits of\n  ///   precision to output.  If there are fewer digits available,\n  ///   zero padding will not be used unless the value is\n  ///   integral and small enough to be expressed in\n  ///   FormatPrecision digits.  0 means to use the natural\n  ///   precision of the number.\n  /// \\param FormatMaxPadding The maximum number of zeros to\n  ///   consider inserting before falling back to scientific\n  ///   notation.  0 means to always use scientific notation.\n  ///\n  /// \\param TruncateZero Indicate whether to remove the trailing zero in\n  ///   fraction part or not. Also setting this parameter to false forcing\n  ///   producing of output more similar to default printf behavior.\n  ///   Specifically the lower e is used as exponent delimiter and exponent\n  ///   always contains no less than two digits.\n  ///\n  /// Number       Precision    MaxPadding      Result\n  /// ------       ---------    ----------      ------\n  /// 1.01E+4              5             2       10100\n  /// 1.01E+4              4             2       1.01E+4\n  /// 1.01E+4              5             1       1.01E+4\n  /// 1.01E-2              5             2       0.0101\n  /// 1.01E-2              4             2       0.0101\n  /// 1.01E-2              4             1       1.01E-2\n  void toString(SmallVectorImpl<char> &Str, unsigned FormatPrecision = 0,\n                unsigned FormatMaxPadding = 3, bool TruncateZero = true) const;\n\n  /// If this value has an exact multiplicative inverse, store it in inv and\n  /// return true.\n  bool getExactInverse(APFloat *inv) const;\n\n  /// Returns the exponent of the internal representation of the APFloat.\n  ///\n  /// Because the radix of APFloat is 2, this is equivalent to floor(log2(x)).\n  /// For special APFloat values, this returns special error codes:\n  ///\n  ///   NaN -> \\c IEK_NaN\n  ///   0   -> \\c IEK_Zero\n  ///   Inf -> \\c IEK_Inf\n  ///\n  friend int ilogb(const IEEEFloat &Arg);\n\n  /// Returns: X * 2^Exp for integral exponents.\n  friend IEEEFloat scalbn(IEEEFloat X, int Exp, roundingMode);\n\n  friend IEEEFloat frexp(const IEEEFloat &X, int &Exp, roundingMode);\n\n  /// \\name Special value setters.\n  /// @{\n\n  void makeLargest(bool Neg = false);\n  void makeSmallest(bool Neg = false);\n  void makeNaN(bool SNaN = false, bool Neg = false,\n               const APInt *fill = nullptr);\n  void makeInf(bool Neg = false);\n  void makeZero(bool Neg = false);\n  void makeQuiet();\n\n  /// Returns the smallest (by magnitude) normalized finite number in the given\n  /// semantics.\n  ///\n  /// \\param Negative - True iff the number should be negative\n  void makeSmallestNormalized(bool Negative = false);\n\n  /// @}\n\n  cmpResult compareAbsoluteValue(const IEEEFloat &) const;\n\nprivate:\n  /// \\name Simple Queries\n  /// @{\n\n  integerPart *significandParts();\n  const integerPart *significandParts() const;\n  unsigned int partCount() const;\n\n  /// @}\n\n  /// \\name Significand operations.\n  /// @{\n\n  integerPart addSignificand(const IEEEFloat &);\n  integerPart subtractSignificand(const IEEEFloat &, integerPart);\n  lostFraction addOrSubtractSignificand(const IEEEFloat &, bool subtract);\n  lostFraction multiplySignificand(const IEEEFloat &, IEEEFloat);\n  lostFraction multiplySignificand(const IEEEFloat&);\n  lostFraction divideSignificand(const IEEEFloat &);\n  void incrementSignificand();\n  void initialize(const fltSemantics *);\n  void shiftSignificandLeft(unsigned int);\n  lostFraction shiftSignificandRight(unsigned int);\n  unsigned int significandLSB() const;\n  unsigned int significandMSB() const;\n  void zeroSignificand();\n  /// Return true if the significand excluding the integral bit is all ones.\n  bool isSignificandAllOnes() const;\n  /// Return true if the significand excluding the integral bit is all zeros.\n  bool isSignificandAllZeros() const;\n\n  /// @}\n\n  /// \\name Arithmetic on special values.\n  /// @{\n\n  opStatus addOrSubtractSpecials(const IEEEFloat &, bool subtract);\n  opStatus divideSpecials(const IEEEFloat &);\n  opStatus multiplySpecials(const IEEEFloat &);\n  opStatus modSpecials(const IEEEFloat &);\n  opStatus remainderSpecials(const IEEEFloat&);\n\n  /// @}\n\n  /// \\name Miscellany\n  /// @{\n\n  bool convertFromStringSpecials(StringRef str);\n  opStatus normalize(roundingMode, lostFraction);\n  opStatus addOrSubtract(const IEEEFloat &, roundingMode, bool subtract);\n  opStatus handleOverflow(roundingMode);\n  bool roundAwayFromZero(roundingMode, lostFraction, unsigned int) const;\n  opStatus convertToSignExtendedInteger(MutableArrayRef<integerPart>,\n                                        unsigned int, bool, roundingMode,\n                                        bool *) const;\n  opStatus convertFromUnsignedParts(const integerPart *, unsigned int,\n                                    roundingMode);\n  Expected<opStatus> convertFromHexadecimalString(StringRef, roundingMode);\n  Expected<opStatus> convertFromDecimalString(StringRef, roundingMode);\n  char *convertNormalToHexString(char *, unsigned int, bool,\n                                 roundingMode) const;\n  opStatus roundSignificandWithExponent(const integerPart *, unsigned int, int,\n                                        roundingMode);\n  ExponentType exponentNaN() const;\n  ExponentType exponentInf() const;\n  ExponentType exponentZero() const;\n\n  /// @}\n\n  APInt convertHalfAPFloatToAPInt() const;\n  APInt convertBFloatAPFloatToAPInt() const;\n  APInt convertFloatAPFloatToAPInt() const;\n  APInt convertDoubleAPFloatToAPInt() const;\n  APInt convertQuadrupleAPFloatToAPInt() const;\n  APInt convertF80LongDoubleAPFloatToAPInt() const;\n  APInt convertPPCDoubleDoubleAPFloatToAPInt() const;\n  void initFromAPInt(const fltSemantics *Sem, const APInt &api);\n  void initFromHalfAPInt(const APInt &api);\n  void initFromBFloatAPInt(const APInt &api);\n  void initFromFloatAPInt(const APInt &api);\n  void initFromDoubleAPInt(const APInt &api);\n  void initFromQuadrupleAPInt(const APInt &api);\n  void initFromF80LongDoubleAPInt(const APInt &api);\n  void initFromPPCDoubleDoubleAPInt(const APInt &api);\n\n  void assign(const IEEEFloat &);\n  void copySignificand(const IEEEFloat &);\n  void freeSignificand();\n\n  /// Note: this must be the first data member.\n  /// The semantics that this value obeys.\n  const fltSemantics *semantics;\n\n  /// A binary fraction with an explicit integer bit.\n  ///\n  /// The significand must be at least one bit wider than the target precision.\n  union Significand {\n    integerPart part;\n    integerPart *parts;\n  } significand;\n\n  /// The signed unbiased exponent of the value.\n  ExponentType exponent;\n\n  /// What kind of floating point number this is.\n  ///\n  /// Only 2 bits are required, but VisualStudio incorrectly sign extends it.\n  /// Using the extra bit keeps it from failing under VisualStudio.\n  fltCategory category : 3;\n\n  /// Sign bit of the number.\n  unsigned int sign : 1;\n};\n\nhash_code hash_value(const IEEEFloat &Arg);\nint ilogb(const IEEEFloat &Arg);\nIEEEFloat scalbn(IEEEFloat X, int Exp, IEEEFloat::roundingMode);\nIEEEFloat frexp(const IEEEFloat &Val, int &Exp, IEEEFloat::roundingMode RM);\n\n// This mode implements more precise float in terms of two APFloats.\n// The interface and layout is designed for arbitrary underlying semantics,\n// though currently only PPCDoubleDouble semantics are supported, whose\n// corresponding underlying semantics are IEEEdouble.\nclass DoubleAPFloat final : public APFloatBase {\n  // Note: this must be the first data member.\n  const fltSemantics *Semantics;\n  std::unique_ptr<APFloat[]> Floats;\n\n  opStatus addImpl(const APFloat &a, const APFloat &aa, const APFloat &c,\n                   const APFloat &cc, roundingMode RM);\n\n  opStatus addWithSpecial(const DoubleAPFloat &LHS, const DoubleAPFloat &RHS,\n                          DoubleAPFloat &Out, roundingMode RM);\n\npublic:\n  DoubleAPFloat(const fltSemantics &S);\n  DoubleAPFloat(const fltSemantics &S, uninitializedTag);\n  DoubleAPFloat(const fltSemantics &S, integerPart);\n  DoubleAPFloat(const fltSemantics &S, const APInt &I);\n  DoubleAPFloat(const fltSemantics &S, APFloat &&First, APFloat &&Second);\n  DoubleAPFloat(const DoubleAPFloat &RHS);\n  DoubleAPFloat(DoubleAPFloat &&RHS);\n\n  DoubleAPFloat &operator=(const DoubleAPFloat &RHS);\n\n  DoubleAPFloat &operator=(DoubleAPFloat &&RHS) {\n    if (this != &RHS) {\n      this->~DoubleAPFloat();\n      new (this) DoubleAPFloat(std::move(RHS));\n    }\n    return *this;\n  }\n\n  bool needsCleanup() const { return Floats != nullptr; }\n\n  APFloat &getFirst() { return Floats[0]; }\n  const APFloat &getFirst() const { return Floats[0]; }\n  APFloat &getSecond() { return Floats[1]; }\n  const APFloat &getSecond() const { return Floats[1]; }\n\n  opStatus add(const DoubleAPFloat &RHS, roundingMode RM);\n  opStatus subtract(const DoubleAPFloat &RHS, roundingMode RM);\n  opStatus multiply(const DoubleAPFloat &RHS, roundingMode RM);\n  opStatus divide(const DoubleAPFloat &RHS, roundingMode RM);\n  opStatus remainder(const DoubleAPFloat &RHS);\n  opStatus mod(const DoubleAPFloat &RHS);\n  opStatus fusedMultiplyAdd(const DoubleAPFloat &Multiplicand,\n                            const DoubleAPFloat &Addend, roundingMode RM);\n  opStatus roundToIntegral(roundingMode RM);\n  void changeSign();\n  cmpResult compareAbsoluteValue(const DoubleAPFloat &RHS) const;\n\n  fltCategory getCategory() const;\n  bool isNegative() const;\n\n  void makeInf(bool Neg);\n  void makeZero(bool Neg);\n  void makeLargest(bool Neg);\n  void makeSmallest(bool Neg);\n  void makeSmallestNormalized(bool Neg);\n  void makeNaN(bool SNaN, bool Neg, const APInt *fill);\n\n  cmpResult compare(const DoubleAPFloat &RHS) const;\n  bool bitwiseIsEqual(const DoubleAPFloat &RHS) const;\n  APInt bitcastToAPInt() const;\n  Expected<opStatus> convertFromString(StringRef, roundingMode);\n  opStatus next(bool nextDown);\n\n  opStatus convertToInteger(MutableArrayRef<integerPart> Input,\n                            unsigned int Width, bool IsSigned, roundingMode RM,\n                            bool *IsExact) const;\n  opStatus convertFromAPInt(const APInt &Input, bool IsSigned, roundingMode RM);\n  opStatus convertFromSignExtendedInteger(const integerPart *Input,\n                                          unsigned int InputSize, bool IsSigned,\n                                          roundingMode RM);\n  opStatus convertFromZeroExtendedInteger(const integerPart *Input,\n                                          unsigned int InputSize, bool IsSigned,\n                                          roundingMode RM);\n  unsigned int convertToHexString(char *DST, unsigned int HexDigits,\n                                  bool UpperCase, roundingMode RM) const;\n\n  bool isDenormal() const;\n  bool isSmallest() const;\n  bool isLargest() const;\n  bool isInteger() const;\n\n  void toString(SmallVectorImpl<char> &Str, unsigned FormatPrecision,\n                unsigned FormatMaxPadding, bool TruncateZero = true) const;\n\n  bool getExactInverse(APFloat *inv) const;\n\n  friend DoubleAPFloat scalbn(const DoubleAPFloat &X, int Exp, roundingMode);\n  friend DoubleAPFloat frexp(const DoubleAPFloat &X, int &Exp, roundingMode);\n  friend hash_code hash_value(const DoubleAPFloat &Arg);\n};\n\nhash_code hash_value(const DoubleAPFloat &Arg);\n\n} // End detail namespace\n\n// This is a interface class that is currently forwarding functionalities from\n// detail::IEEEFloat.\nclass APFloat : public APFloatBase {\n  typedef detail::IEEEFloat IEEEFloat;\n  typedef detail::DoubleAPFloat DoubleAPFloat;\n\n  static_assert(std::is_standard_layout<IEEEFloat>::value, \"\");\n\n  union Storage {\n    const fltSemantics *semantics;\n    IEEEFloat IEEE;\n    DoubleAPFloat Double;\n\n    explicit Storage(IEEEFloat F, const fltSemantics &S);\n    explicit Storage(DoubleAPFloat F, const fltSemantics &S)\n        : Double(std::move(F)) {\n      assert(&S == &PPCDoubleDouble());\n    }\n\n    template <typename... ArgTypes>\n    Storage(const fltSemantics &Semantics, ArgTypes &&... Args) {\n      if (usesLayout<IEEEFloat>(Semantics)) {\n        new (&IEEE) IEEEFloat(Semantics, std::forward<ArgTypes>(Args)...);\n        return;\n      }\n      if (usesLayout<DoubleAPFloat>(Semantics)) {\n        new (&Double) DoubleAPFloat(Semantics, std::forward<ArgTypes>(Args)...);\n        return;\n      }\n      llvm_unreachable(\"Unexpected semantics\");\n    }\n\n    ~Storage() {\n      if (usesLayout<IEEEFloat>(*semantics)) {\n        IEEE.~IEEEFloat();\n        return;\n      }\n      if (usesLayout<DoubleAPFloat>(*semantics)) {\n        Double.~DoubleAPFloat();\n        return;\n      }\n      llvm_unreachable(\"Unexpected semantics\");\n    }\n\n    Storage(const Storage &RHS) {\n      if (usesLayout<IEEEFloat>(*RHS.semantics)) {\n        new (this) IEEEFloat(RHS.IEEE);\n        return;\n      }\n      if (usesLayout<DoubleAPFloat>(*RHS.semantics)) {\n        new (this) DoubleAPFloat(RHS.Double);\n        return;\n      }\n      llvm_unreachable(\"Unexpected semantics\");\n    }\n\n    Storage(Storage &&RHS) {\n      if (usesLayout<IEEEFloat>(*RHS.semantics)) {\n        new (this) IEEEFloat(std::move(RHS.IEEE));\n        return;\n      }\n      if (usesLayout<DoubleAPFloat>(*RHS.semantics)) {\n        new (this) DoubleAPFloat(std::move(RHS.Double));\n        return;\n      }\n      llvm_unreachable(\"Unexpected semantics\");\n    }\n\n    Storage &operator=(const Storage &RHS) {\n      if (usesLayout<IEEEFloat>(*semantics) &&\n          usesLayout<IEEEFloat>(*RHS.semantics)) {\n        IEEE = RHS.IEEE;\n      } else if (usesLayout<DoubleAPFloat>(*semantics) &&\n                 usesLayout<DoubleAPFloat>(*RHS.semantics)) {\n        Double = RHS.Double;\n      } else if (this != &RHS) {\n        this->~Storage();\n        new (this) Storage(RHS);\n      }\n      return *this;\n    }\n\n    Storage &operator=(Storage &&RHS) {\n      if (usesLayout<IEEEFloat>(*semantics) &&\n          usesLayout<IEEEFloat>(*RHS.semantics)) {\n        IEEE = std::move(RHS.IEEE);\n      } else if (usesLayout<DoubleAPFloat>(*semantics) &&\n                 usesLayout<DoubleAPFloat>(*RHS.semantics)) {\n        Double = std::move(RHS.Double);\n      } else if (this != &RHS) {\n        this->~Storage();\n        new (this) Storage(std::move(RHS));\n      }\n      return *this;\n    }\n  } U;\n\n  template <typename T> static bool usesLayout(const fltSemantics &Semantics) {\n    static_assert(std::is_same<T, IEEEFloat>::value ||\n                  std::is_same<T, DoubleAPFloat>::value, \"\");\n    if (std::is_same<T, DoubleAPFloat>::value) {\n      return &Semantics == &PPCDoubleDouble();\n    }\n    return &Semantics != &PPCDoubleDouble();\n  }\n\n  IEEEFloat &getIEEE() {\n    if (usesLayout<IEEEFloat>(*U.semantics))\n      return U.IEEE;\n    if (usesLayout<DoubleAPFloat>(*U.semantics))\n      return U.Double.getFirst().U.IEEE;\n    llvm_unreachable(\"Unexpected semantics\");\n  }\n\n  const IEEEFloat &getIEEE() const {\n    if (usesLayout<IEEEFloat>(*U.semantics))\n      return U.IEEE;\n    if (usesLayout<DoubleAPFloat>(*U.semantics))\n      return U.Double.getFirst().U.IEEE;\n    llvm_unreachable(\"Unexpected semantics\");\n  }\n\n  void makeZero(bool Neg) { APFLOAT_DISPATCH_ON_SEMANTICS(makeZero(Neg)); }\n\n  void makeInf(bool Neg) { APFLOAT_DISPATCH_ON_SEMANTICS(makeInf(Neg)); }\n\n  void makeNaN(bool SNaN, bool Neg, const APInt *fill) {\n    APFLOAT_DISPATCH_ON_SEMANTICS(makeNaN(SNaN, Neg, fill));\n  }\n\n  void makeLargest(bool Neg) {\n    APFLOAT_DISPATCH_ON_SEMANTICS(makeLargest(Neg));\n  }\n\n  void makeSmallest(bool Neg) {\n    APFLOAT_DISPATCH_ON_SEMANTICS(makeSmallest(Neg));\n  }\n\n  void makeSmallestNormalized(bool Neg) {\n    APFLOAT_DISPATCH_ON_SEMANTICS(makeSmallestNormalized(Neg));\n  }\n\n  // FIXME: This is due to clang 3.3 (or older version) always checks for the\n  // default constructor in an array aggregate initialization, even if no\n  // elements in the array is default initialized.\n  APFloat() : U(IEEEdouble()) {\n    llvm_unreachable(\"This is a workaround for old clang.\");\n  }\n\n  explicit APFloat(IEEEFloat F, const fltSemantics &S) : U(std::move(F), S) {}\n  explicit APFloat(DoubleAPFloat F, const fltSemantics &S)\n      : U(std::move(F), S) {}\n\n  cmpResult compareAbsoluteValue(const APFloat &RHS) const {\n    assert(&getSemantics() == &RHS.getSemantics() &&\n           \"Should only compare APFloats with the same semantics\");\n    if (usesLayout<IEEEFloat>(getSemantics()))\n      return U.IEEE.compareAbsoluteValue(RHS.U.IEEE);\n    if (usesLayout<DoubleAPFloat>(getSemantics()))\n      return U.Double.compareAbsoluteValue(RHS.U.Double);\n    llvm_unreachable(\"Unexpected semantics\");\n  }\n\npublic:\n  APFloat(const fltSemantics &Semantics) : U(Semantics) {}\n  APFloat(const fltSemantics &Semantics, StringRef S);\n  APFloat(const fltSemantics &Semantics, integerPart I) : U(Semantics, I) {}\n  template <typename T,\n            typename = std::enable_if_t<std::is_floating_point<T>::value>>\n  APFloat(const fltSemantics &Semantics, T V) = delete;\n  // TODO: Remove this constructor. This isn't faster than the first one.\n  APFloat(const fltSemantics &Semantics, uninitializedTag)\n      : U(Semantics, uninitialized) {}\n  APFloat(const fltSemantics &Semantics, const APInt &I) : U(Semantics, I) {}\n  explicit APFloat(double d) : U(IEEEFloat(d), IEEEdouble()) {}\n  explicit APFloat(float f) : U(IEEEFloat(f), IEEEsingle()) {}\n  APFloat(const APFloat &RHS) = default;\n  APFloat(APFloat &&RHS) = default;\n\n  ~APFloat() = default;\n\n  bool needsCleanup() const { APFLOAT_DISPATCH_ON_SEMANTICS(needsCleanup()); }\n\n  /// Factory for Positive and Negative Zero.\n  ///\n  /// \\param Negative True iff the number should be negative.\n  static APFloat getZero(const fltSemantics &Sem, bool Negative = false) {\n    APFloat Val(Sem, uninitialized);\n    Val.makeZero(Negative);\n    return Val;\n  }\n\n  /// Factory for Positive and Negative Infinity.\n  ///\n  /// \\param Negative True iff the number should be negative.\n  static APFloat getInf(const fltSemantics &Sem, bool Negative = false) {\n    APFloat Val(Sem, uninitialized);\n    Val.makeInf(Negative);\n    return Val;\n  }\n\n  /// Factory for NaN values.\n  ///\n  /// \\param Negative - True iff the NaN generated should be negative.\n  /// \\param payload - The unspecified fill bits for creating the NaN, 0 by\n  /// default.  The value is truncated as necessary.\n  static APFloat getNaN(const fltSemantics &Sem, bool Negative = false,\n                        uint64_t payload = 0) {\n    if (payload) {\n      APInt intPayload(64, payload);\n      return getQNaN(Sem, Negative, &intPayload);\n    } else {\n      return getQNaN(Sem, Negative, nullptr);\n    }\n  }\n\n  /// Factory for QNaN values.\n  static APFloat getQNaN(const fltSemantics &Sem, bool Negative = false,\n                         const APInt *payload = nullptr) {\n    APFloat Val(Sem, uninitialized);\n    Val.makeNaN(false, Negative, payload);\n    return Val;\n  }\n\n  /// Factory for SNaN values.\n  static APFloat getSNaN(const fltSemantics &Sem, bool Negative = false,\n                         const APInt *payload = nullptr) {\n    APFloat Val(Sem, uninitialized);\n    Val.makeNaN(true, Negative, payload);\n    return Val;\n  }\n\n  /// Returns the largest finite number in the given semantics.\n  ///\n  /// \\param Negative - True iff the number should be negative\n  static APFloat getLargest(const fltSemantics &Sem, bool Negative = false) {\n    APFloat Val(Sem, uninitialized);\n    Val.makeLargest(Negative);\n    return Val;\n  }\n\n  /// Returns the smallest (by magnitude) finite number in the given semantics.\n  /// Might be denormalized, which implies a relative loss of precision.\n  ///\n  /// \\param Negative - True iff the number should be negative\n  static APFloat getSmallest(const fltSemantics &Sem, bool Negative = false) {\n    APFloat Val(Sem, uninitialized);\n    Val.makeSmallest(Negative);\n    return Val;\n  }\n\n  /// Returns the smallest (by magnitude) normalized finite number in the given\n  /// semantics.\n  ///\n  /// \\param Negative - True iff the number should be negative\n  static APFloat getSmallestNormalized(const fltSemantics &Sem,\n                                       bool Negative = false) {\n    APFloat Val(Sem, uninitialized);\n    Val.makeSmallestNormalized(Negative);\n    return Val;\n  }\n\n  /// Returns a float which is bitcasted from an all one value int.\n  ///\n  /// \\param Semantics - type float semantics\n  /// \\param BitWidth - Select float type\n  static APFloat getAllOnesValue(const fltSemantics &Semantics,\n                                 unsigned BitWidth);\n\n  /// Used to insert APFloat objects, or objects that contain APFloat objects,\n  /// into FoldingSets.\n  void Profile(FoldingSetNodeID &NID) const;\n\n  opStatus add(const APFloat &RHS, roundingMode RM) {\n    assert(&getSemantics() == &RHS.getSemantics() &&\n           \"Should only call on two APFloats with the same semantics\");\n    if (usesLayout<IEEEFloat>(getSemantics()))\n      return U.IEEE.add(RHS.U.IEEE, RM);\n    if (usesLayout<DoubleAPFloat>(getSemantics()))\n      return U.Double.add(RHS.U.Double, RM);\n    llvm_unreachable(\"Unexpected semantics\");\n  }\n  opStatus subtract(const APFloat &RHS, roundingMode RM) {\n    assert(&getSemantics() == &RHS.getSemantics() &&\n           \"Should only call on two APFloats with the same semantics\");\n    if (usesLayout<IEEEFloat>(getSemantics()))\n      return U.IEEE.subtract(RHS.U.IEEE, RM);\n    if (usesLayout<DoubleAPFloat>(getSemantics()))\n      return U.Double.subtract(RHS.U.Double, RM);\n    llvm_unreachable(\"Unexpected semantics\");\n  }\n  opStatus multiply(const APFloat &RHS, roundingMode RM) {\n    assert(&getSemantics() == &RHS.getSemantics() &&\n           \"Should only call on two APFloats with the same semantics\");\n    if (usesLayout<IEEEFloat>(getSemantics()))\n      return U.IEEE.multiply(RHS.U.IEEE, RM);\n    if (usesLayout<DoubleAPFloat>(getSemantics()))\n      return U.Double.multiply(RHS.U.Double, RM);\n    llvm_unreachable(\"Unexpected semantics\");\n  }\n  opStatus divide(const APFloat &RHS, roundingMode RM) {\n    assert(&getSemantics() == &RHS.getSemantics() &&\n           \"Should only call on two APFloats with the same semantics\");\n    if (usesLayout<IEEEFloat>(getSemantics()))\n      return U.IEEE.divide(RHS.U.IEEE, RM);\n    if (usesLayout<DoubleAPFloat>(getSemantics()))\n      return U.Double.divide(RHS.U.Double, RM);\n    llvm_unreachable(\"Unexpected semantics\");\n  }\n  opStatus remainder(const APFloat &RHS) {\n    assert(&getSemantics() == &RHS.getSemantics() &&\n           \"Should only call on two APFloats with the same semantics\");\n    if (usesLayout<IEEEFloat>(getSemantics()))\n      return U.IEEE.remainder(RHS.U.IEEE);\n    if (usesLayout<DoubleAPFloat>(getSemantics()))\n      return U.Double.remainder(RHS.U.Double);\n    llvm_unreachable(\"Unexpected semantics\");\n  }\n  opStatus mod(const APFloat &RHS) {\n    assert(&getSemantics() == &RHS.getSemantics() &&\n           \"Should only call on two APFloats with the same semantics\");\n    if (usesLayout<IEEEFloat>(getSemantics()))\n      return U.IEEE.mod(RHS.U.IEEE);\n    if (usesLayout<DoubleAPFloat>(getSemantics()))\n      return U.Double.mod(RHS.U.Double);\n    llvm_unreachable(\"Unexpected semantics\");\n  }\n  opStatus fusedMultiplyAdd(const APFloat &Multiplicand, const APFloat &Addend,\n                            roundingMode RM) {\n    assert(&getSemantics() == &Multiplicand.getSemantics() &&\n           \"Should only call on APFloats with the same semantics\");\n    assert(&getSemantics() == &Addend.getSemantics() &&\n           \"Should only call on APFloats with the same semantics\");\n    if (usesLayout<IEEEFloat>(getSemantics()))\n      return U.IEEE.fusedMultiplyAdd(Multiplicand.U.IEEE, Addend.U.IEEE, RM);\n    if (usesLayout<DoubleAPFloat>(getSemantics()))\n      return U.Double.fusedMultiplyAdd(Multiplicand.U.Double, Addend.U.Double,\n                                       RM);\n    llvm_unreachable(\"Unexpected semantics\");\n  }\n  opStatus roundToIntegral(roundingMode RM) {\n    APFLOAT_DISPATCH_ON_SEMANTICS(roundToIntegral(RM));\n  }\n\n  // TODO: bool parameters are not readable and a source of bugs.\n  // Do something.\n  opStatus next(bool nextDown) {\n    APFLOAT_DISPATCH_ON_SEMANTICS(next(nextDown));\n  }\n\n  /// Negate an APFloat.\n  APFloat operator-() const {\n    APFloat Result(*this);\n    Result.changeSign();\n    return Result;\n  }\n\n  /// Add two APFloats, rounding ties to the nearest even.\n  /// No error checking.\n  APFloat operator+(const APFloat &RHS) const {\n    APFloat Result(*this);\n    (void)Result.add(RHS, rmNearestTiesToEven);\n    return Result;\n  }\n\n  /// Subtract two APFloats, rounding ties to the nearest even.\n  /// No error checking.\n  APFloat operator-(const APFloat &RHS) const {\n    APFloat Result(*this);\n    (void)Result.subtract(RHS, rmNearestTiesToEven);\n    return Result;\n  }\n\n  /// Multiply two APFloats, rounding ties to the nearest even.\n  /// No error checking.\n  APFloat operator*(const APFloat &RHS) const {\n    APFloat Result(*this);\n    (void)Result.multiply(RHS, rmNearestTiesToEven);\n    return Result;\n  }\n\n  /// Divide the first APFloat by the second, rounding ties to the nearest even.\n  /// No error checking.\n  APFloat operator/(const APFloat &RHS) const {\n    APFloat Result(*this);\n    (void)Result.divide(RHS, rmNearestTiesToEven);\n    return Result;\n  }\n\n  void changeSign() { APFLOAT_DISPATCH_ON_SEMANTICS(changeSign()); }\n  void clearSign() {\n    if (isNegative())\n      changeSign();\n  }\n  void copySign(const APFloat &RHS) {\n    if (isNegative() != RHS.isNegative())\n      changeSign();\n  }\n\n  /// A static helper to produce a copy of an APFloat value with its sign\n  /// copied from some other APFloat.\n  static APFloat copySign(APFloat Value, const APFloat &Sign) {\n    Value.copySign(Sign);\n    return Value;\n  }\n\n  opStatus convert(const fltSemantics &ToSemantics, roundingMode RM,\n                   bool *losesInfo);\n  opStatus convertToInteger(MutableArrayRef<integerPart> Input,\n                            unsigned int Width, bool IsSigned, roundingMode RM,\n                            bool *IsExact) const {\n    APFLOAT_DISPATCH_ON_SEMANTICS(\n        convertToInteger(Input, Width, IsSigned, RM, IsExact));\n  }\n  opStatus convertToInteger(APSInt &Result, roundingMode RM,\n                            bool *IsExact) const;\n  opStatus convertFromAPInt(const APInt &Input, bool IsSigned,\n                            roundingMode RM) {\n    APFLOAT_DISPATCH_ON_SEMANTICS(convertFromAPInt(Input, IsSigned, RM));\n  }\n  opStatus convertFromSignExtendedInteger(const integerPart *Input,\n                                          unsigned int InputSize, bool IsSigned,\n                                          roundingMode RM) {\n    APFLOAT_DISPATCH_ON_SEMANTICS(\n        convertFromSignExtendedInteger(Input, InputSize, IsSigned, RM));\n  }\n  opStatus convertFromZeroExtendedInteger(const integerPart *Input,\n                                          unsigned int InputSize, bool IsSigned,\n                                          roundingMode RM) {\n    APFLOAT_DISPATCH_ON_SEMANTICS(\n        convertFromZeroExtendedInteger(Input, InputSize, IsSigned, RM));\n  }\n  Expected<opStatus> convertFromString(StringRef, roundingMode);\n  APInt bitcastToAPInt() const {\n    APFLOAT_DISPATCH_ON_SEMANTICS(bitcastToAPInt());\n  }\n  double convertToDouble() const { return getIEEE().convertToDouble(); }\n  float convertToFloat() const { return getIEEE().convertToFloat(); }\n\n  bool operator==(const APFloat &RHS) const { return compare(RHS) == cmpEqual; }\n\n  bool operator!=(const APFloat &RHS) const { return compare(RHS) != cmpEqual; }\n\n  bool operator<(const APFloat &RHS) const {\n    return compare(RHS) == cmpLessThan;\n  }\n\n  bool operator>(const APFloat &RHS) const {\n    return compare(RHS) == cmpGreaterThan;\n  }\n\n  bool operator<=(const APFloat &RHS) const {\n    cmpResult Res = compare(RHS);\n    return Res == cmpLessThan || Res == cmpEqual;\n  }\n\n  bool operator>=(const APFloat &RHS) const {\n    cmpResult Res = compare(RHS);\n    return Res == cmpGreaterThan || Res == cmpEqual;\n  }\n\n  cmpResult compare(const APFloat &RHS) const {\n    assert(&getSemantics() == &RHS.getSemantics() &&\n           \"Should only compare APFloats with the same semantics\");\n    if (usesLayout<IEEEFloat>(getSemantics()))\n      return U.IEEE.compare(RHS.U.IEEE);\n    if (usesLayout<DoubleAPFloat>(getSemantics()))\n      return U.Double.compare(RHS.U.Double);\n    llvm_unreachable(\"Unexpected semantics\");\n  }\n\n  bool bitwiseIsEqual(const APFloat &RHS) const {\n    if (&getSemantics() != &RHS.getSemantics())\n      return false;\n    if (usesLayout<IEEEFloat>(getSemantics()))\n      return U.IEEE.bitwiseIsEqual(RHS.U.IEEE);\n    if (usesLayout<DoubleAPFloat>(getSemantics()))\n      return U.Double.bitwiseIsEqual(RHS.U.Double);\n    llvm_unreachable(\"Unexpected semantics\");\n  }\n\n  /// We don't rely on operator== working on double values, as\n  /// it returns true for things that are clearly not equal, like -0.0 and 0.0.\n  /// As such, this method can be used to do an exact bit-for-bit comparison of\n  /// two floating point values.\n  ///\n  /// We leave the version with the double argument here because it's just so\n  /// convenient to write \"2.0\" and the like.  Without this function we'd\n  /// have to duplicate its logic everywhere it's called.\n  bool isExactlyValue(double V) const {\n    bool ignored;\n    APFloat Tmp(V);\n    Tmp.convert(getSemantics(), APFloat::rmNearestTiesToEven, &ignored);\n    return bitwiseIsEqual(Tmp);\n  }\n\n  unsigned int convertToHexString(char *DST, unsigned int HexDigits,\n                                  bool UpperCase, roundingMode RM) const {\n    APFLOAT_DISPATCH_ON_SEMANTICS(\n        convertToHexString(DST, HexDigits, UpperCase, RM));\n  }\n\n  bool isZero() const { return getCategory() == fcZero; }\n  bool isInfinity() const { return getCategory() == fcInfinity; }\n  bool isNaN() const { return getCategory() == fcNaN; }\n\n  bool isNegative() const { return getIEEE().isNegative(); }\n  bool isDenormal() const { APFLOAT_DISPATCH_ON_SEMANTICS(isDenormal()); }\n  bool isSignaling() const { return getIEEE().isSignaling(); }\n\n  bool isNormal() const { return !isDenormal() && isFiniteNonZero(); }\n  bool isFinite() const { return !isNaN() && !isInfinity(); }\n\n  fltCategory getCategory() const { return getIEEE().getCategory(); }\n  const fltSemantics &getSemantics() const { return *U.semantics; }\n  bool isNonZero() const { return !isZero(); }\n  bool isFiniteNonZero() const { return isFinite() && !isZero(); }\n  bool isPosZero() const { return isZero() && !isNegative(); }\n  bool isNegZero() const { return isZero() && isNegative(); }\n  bool isSmallest() const { APFLOAT_DISPATCH_ON_SEMANTICS(isSmallest()); }\n  bool isLargest() const { APFLOAT_DISPATCH_ON_SEMANTICS(isLargest()); }\n  bool isInteger() const { APFLOAT_DISPATCH_ON_SEMANTICS(isInteger()); }\n  bool isIEEE() const { return usesLayout<IEEEFloat>(getSemantics()); }\n\n  APFloat &operator=(const APFloat &RHS) = default;\n  APFloat &operator=(APFloat &&RHS) = default;\n\n  void toString(SmallVectorImpl<char> &Str, unsigned FormatPrecision = 0,\n                unsigned FormatMaxPadding = 3, bool TruncateZero = true) const {\n    APFLOAT_DISPATCH_ON_SEMANTICS(\n        toString(Str, FormatPrecision, FormatMaxPadding, TruncateZero));\n  }\n\n  void print(raw_ostream &) const;\n  void dump() const;\n\n  bool getExactInverse(APFloat *inv) const {\n    APFLOAT_DISPATCH_ON_SEMANTICS(getExactInverse(inv));\n  }\n\n  friend hash_code hash_value(const APFloat &Arg);\n  friend int ilogb(const APFloat &Arg) { return ilogb(Arg.getIEEE()); }\n  friend APFloat scalbn(APFloat X, int Exp, roundingMode RM);\n  friend APFloat frexp(const APFloat &X, int &Exp, roundingMode RM);\n  friend IEEEFloat;\n  friend DoubleAPFloat;\n};\n\n/// See friend declarations above.\n///\n/// These additional declarations are required in order to compile LLVM with IBM\n/// xlC compiler.\nhash_code hash_value(const APFloat &Arg);\ninline APFloat scalbn(APFloat X, int Exp, APFloat::roundingMode RM) {\n  if (APFloat::usesLayout<detail::IEEEFloat>(X.getSemantics()))\n    return APFloat(scalbn(X.U.IEEE, Exp, RM), X.getSemantics());\n  if (APFloat::usesLayout<detail::DoubleAPFloat>(X.getSemantics()))\n    return APFloat(scalbn(X.U.Double, Exp, RM), X.getSemantics());\n  llvm_unreachable(\"Unexpected semantics\");\n}\n\n/// Equivalent of C standard library function.\n///\n/// While the C standard says Exp is an unspecified value for infinity and nan,\n/// this returns INT_MAX for infinities, and INT_MIN for NaNs.\ninline APFloat frexp(const APFloat &X, int &Exp, APFloat::roundingMode RM) {\n  if (APFloat::usesLayout<detail::IEEEFloat>(X.getSemantics()))\n    return APFloat(frexp(X.U.IEEE, Exp, RM), X.getSemantics());\n  if (APFloat::usesLayout<detail::DoubleAPFloat>(X.getSemantics()))\n    return APFloat(frexp(X.U.Double, Exp, RM), X.getSemantics());\n  llvm_unreachable(\"Unexpected semantics\");\n}\n/// Returns the absolute value of the argument.\ninline APFloat abs(APFloat X) {\n  X.clearSign();\n  return X;\n}\n\n/// Returns the negated value of the argument.\ninline APFloat neg(APFloat X) {\n  X.changeSign();\n  return X;\n}\n\n/// Implements IEEE minNum semantics. Returns the smaller of the 2 arguments if\n/// both are not NaN. If either argument is a NaN, returns the other argument.\nLLVM_READONLY\ninline APFloat minnum(const APFloat &A, const APFloat &B) {\n  if (A.isNaN())\n    return B;\n  if (B.isNaN())\n    return A;\n  return B < A ? B : A;\n}\n\n/// Implements IEEE maxNum semantics. Returns the larger of the 2 arguments if\n/// both are not NaN. If either argument is a NaN, returns the other argument.\nLLVM_READONLY\ninline APFloat maxnum(const APFloat &A, const APFloat &B) {\n  if (A.isNaN())\n    return B;\n  if (B.isNaN())\n    return A;\n  return A < B ? B : A;\n}\n\n/// Implements IEEE 754-2018 minimum semantics. Returns the smaller of 2\n/// arguments, propagating NaNs and treating -0 as less than +0.\nLLVM_READONLY\ninline APFloat minimum(const APFloat &A, const APFloat &B) {\n  if (A.isNaN())\n    return A;\n  if (B.isNaN())\n    return B;\n  if (A.isZero() && B.isZero() && (A.isNegative() != B.isNegative()))\n    return A.isNegative() ? A : B;\n  return B < A ? B : A;\n}\n\n/// Implements IEEE 754-2018 maximum semantics. Returns the larger of 2\n/// arguments, propagating NaNs and treating -0 as less than +0.\nLLVM_READONLY\ninline APFloat maximum(const APFloat &A, const APFloat &B) {\n  if (A.isNaN())\n    return A;\n  if (B.isNaN())\n    return B;\n  if (A.isZero() && B.isZero() && (A.isNegative() != B.isNegative()))\n    return A.isNegative() ? B : A;\n  return A < B ? B : A;\n}\n\n} // namespace llvm\n\n#undef APFLOAT_DISPATCH_ON_SEMANTICS\n#endif // LLVM_ADT_APFLOAT_H\n"}, "34": {"id": 34, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/DenseSet.h", "content": "//===- llvm/ADT/DenseSet.h - Dense probed hash table ------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file defines the DenseSet and SmallDenseSet classes.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_ADT_DENSESET_H\n#define LLVM_ADT_DENSESET_H\n\n#include \"llvm/ADT/DenseMap.h\"\n#include \"llvm/ADT/DenseMapInfo.h\"\n#include \"llvm/Support/MathExtras.h\"\n#include \"llvm/Support/type_traits.h\"\n#include <algorithm>\n#include <cstddef>\n#include <initializer_list>\n#include <iterator>\n#include <utility>\n\nnamespace llvm {\n\nnamespace detail {\n\nstruct DenseSetEmpty {};\n\n// Use the empty base class trick so we can create a DenseMap where the buckets\n// contain only a single item.\ntemplate <typename KeyT> class DenseSetPair : public DenseSetEmpty {\n  KeyT key;\n\npublic:\n  KeyT &getFirst() { return key; }\n  const KeyT &getFirst() const { return key; }\n  DenseSetEmpty &getSecond() { return *this; }\n  const DenseSetEmpty &getSecond() const { return *this; }\n};\n\n/// Base class for DenseSet and DenseSmallSet.\n///\n/// MapTy should be either\n///\n///   DenseMap<ValueT, detail::DenseSetEmpty, ValueInfoT,\n///            detail::DenseSetPair<ValueT>>\n///\n/// or the equivalent SmallDenseMap type.  ValueInfoT must implement the\n/// DenseMapInfo \"concept\".\ntemplate <typename ValueT, typename MapTy, typename ValueInfoT>\nclass DenseSetImpl {\n  static_assert(sizeof(typename MapTy::value_type) == sizeof(ValueT),\n                \"DenseMap buckets unexpectedly large!\");\n  MapTy TheMap;\n\n  template <typename T>\n  using const_arg_type_t = typename const_pointer_or_const_ref<T>::type;\n\npublic:\n  using key_type = ValueT;\n  using value_type = ValueT;\n  using size_type = unsigned;\n\n  explicit DenseSetImpl(unsigned InitialReserve = 0) : TheMap(InitialReserve) {}\n\n  template <typename InputIt>\n  DenseSetImpl(const InputIt &I, const InputIt &E)\n      : DenseSetImpl(PowerOf2Ceil(std::distance(I, E))) {\n    insert(I, E);\n  }\n\n  DenseSetImpl(std::initializer_list<ValueT> Elems)\n      : DenseSetImpl(PowerOf2Ceil(Elems.size())) {\n    insert(Elems.begin(), Elems.end());\n  }\n\n  bool empty() const { return TheMap.empty(); }\n  size_type size() const { return TheMap.size(); }\n  size_t getMemorySize() const { return TheMap.getMemorySize(); }\n\n  /// Grow the DenseSet so that it has at least Size buckets. Will not shrink\n  /// the Size of the set.\n  void resize(size_t Size) { TheMap.resize(Size); }\n\n  /// Grow the DenseSet so that it can contain at least \\p NumEntries items\n  /// before resizing again.\n  void reserve(size_t Size) { TheMap.reserve(Size); }\n\n  void clear() {\n    TheMap.clear();\n  }\n\n  /// Return 1 if the specified key is in the set, 0 otherwise.\n  size_type count(const_arg_type_t<ValueT> V) const {\n    return TheMap.count(V);\n  }\n\n  bool erase(const ValueT &V) {\n    return TheMap.erase(V);\n  }\n\n  void swap(DenseSetImpl &RHS) { TheMap.swap(RHS.TheMap); }\n\n  // Iterators.\n\n  class ConstIterator;\n\n  class Iterator {\n    typename MapTy::iterator I;\n    friend class DenseSetImpl;\n    friend class ConstIterator;\n\n  public:\n    using difference_type = typename MapTy::iterator::difference_type;\n    using value_type = ValueT;\n    using pointer = value_type *;\n    using reference = value_type &;\n    using iterator_category = std::forward_iterator_tag;\n\n    Iterator() = default;\n    Iterator(const typename MapTy::iterator &i) : I(i) {}\n\n    ValueT &operator*() { return I->getFirst(); }\n    const ValueT &operator*() const { return I->getFirst(); }\n    ValueT *operator->() { return &I->getFirst(); }\n    const ValueT *operator->() const { return &I->getFirst(); }\n\n    Iterator& operator++() { ++I; return *this; }\n    Iterator operator++(int) { auto T = *this; ++I; return T; }\n    friend bool operator==(const Iterator &X, const Iterator &Y) {\n      return X.I == Y.I;\n    }\n    friend bool operator!=(const Iterator &X, const Iterator &Y) {\n      return X.I != Y.I;\n    }\n  };\n\n  class ConstIterator {\n    typename MapTy::const_iterator I;\n    friend class DenseSetImpl;\n    friend class Iterator;\n\n  public:\n    using difference_type = typename MapTy::const_iterator::difference_type;\n    using value_type = ValueT;\n    using pointer = const value_type *;\n    using reference = const value_type &;\n    using iterator_category = std::forward_iterator_tag;\n\n    ConstIterator() = default;\n    ConstIterator(const Iterator &B) : I(B.I) {}\n    ConstIterator(const typename MapTy::const_iterator &i) : I(i) {}\n\n    const ValueT &operator*() const { return I->getFirst(); }\n    const ValueT *operator->() const { return &I->getFirst(); }\n\n    ConstIterator& operator++() { ++I; return *this; }\n    ConstIterator operator++(int) { auto T = *this; ++I; return T; }\n    friend bool operator==(const ConstIterator &X, const ConstIterator &Y) {\n      return X.I == Y.I;\n    }\n    friend bool operator!=(const ConstIterator &X, const ConstIterator &Y) {\n      return X.I != Y.I;\n    }\n  };\n\n  using iterator = Iterator;\n  using const_iterator = ConstIterator;\n\n  iterator begin() { return Iterator(TheMap.begin()); }\n  iterator end() { return Iterator(TheMap.end()); }\n\n  const_iterator begin() const { return ConstIterator(TheMap.begin()); }\n  const_iterator end() const { return ConstIterator(TheMap.end()); }\n\n  iterator find(const_arg_type_t<ValueT> V) { return Iterator(TheMap.find(V)); }\n  const_iterator find(const_arg_type_t<ValueT> V) const {\n    return ConstIterator(TheMap.find(V));\n  }\n\n  /// Check if the set contains the given element.\n  bool contains(const_arg_type_t<ValueT> V) const {\n    return TheMap.find(V) != TheMap.end();\n  }\n\n  /// Alternative version of find() which allows a different, and possibly less\n  /// expensive, key type.\n  /// The DenseMapInfo is responsible for supplying methods\n  /// getHashValue(LookupKeyT) and isEqual(LookupKeyT, KeyT) for each key type\n  /// used.\n  template <class LookupKeyT>\n  iterator find_as(const LookupKeyT &Val) {\n    return Iterator(TheMap.find_as(Val));\n  }\n  template <class LookupKeyT>\n  const_iterator find_as(const LookupKeyT &Val) const {\n    return ConstIterator(TheMap.find_as(Val));\n  }\n\n  void erase(Iterator I) { return TheMap.erase(I.I); }\n  void erase(ConstIterator CI) { return TheMap.erase(CI.I); }\n\n  std::pair<iterator, bool> insert(const ValueT &V) {\n    detail::DenseSetEmpty Empty;\n    return TheMap.try_emplace(V, Empty);\n  }\n\n  std::pair<iterator, bool> insert(ValueT &&V) {\n    detail::DenseSetEmpty Empty;\n    return TheMap.try_emplace(std::move(V), Empty);\n  }\n\n  /// Alternative version of insert that uses a different (and possibly less\n  /// expensive) key type.\n  template <typename LookupKeyT>\n  std::pair<iterator, bool> insert_as(const ValueT &V,\n                                      const LookupKeyT &LookupKey) {\n    return TheMap.insert_as({V, detail::DenseSetEmpty()}, LookupKey);\n  }\n  template <typename LookupKeyT>\n  std::pair<iterator, bool> insert_as(ValueT &&V, const LookupKeyT &LookupKey) {\n    return TheMap.insert_as({std::move(V), detail::DenseSetEmpty()}, LookupKey);\n  }\n\n  // Range insertion of values.\n  template<typename InputIt>\n  void insert(InputIt I, InputIt E) {\n    for (; I != E; ++I)\n      insert(*I);\n  }\n};\n\n/// Equality comparison for DenseSet.\n///\n/// Iterates over elements of LHS confirming that each element is also a member\n/// of RHS, and that RHS contains no additional values.\n/// Equivalent to N calls to RHS.count. Amortized complexity is linear, worst\n/// case is O(N^2) (if every hash collides).\ntemplate <typename ValueT, typename MapTy, typename ValueInfoT>\nbool operator==(const DenseSetImpl<ValueT, MapTy, ValueInfoT> &LHS,\n                const DenseSetImpl<ValueT, MapTy, ValueInfoT> &RHS) {\n  if (LHS.size() != RHS.size())\n    return false;\n\n  for (auto &E : LHS)\n    if (!RHS.count(E))\n      return false;\n\n  return true;\n}\n\n/// Inequality comparison for DenseSet.\n///\n/// Equivalent to !(LHS == RHS). See operator== for performance notes.\ntemplate <typename ValueT, typename MapTy, typename ValueInfoT>\nbool operator!=(const DenseSetImpl<ValueT, MapTy, ValueInfoT> &LHS,\n                const DenseSetImpl<ValueT, MapTy, ValueInfoT> &RHS) {\n  return !(LHS == RHS);\n}\n\n} // end namespace detail\n\n/// Implements a dense probed hash-table based set.\ntemplate <typename ValueT, typename ValueInfoT = DenseMapInfo<ValueT>>\nclass DenseSet : public detail::DenseSetImpl<\n                     ValueT, DenseMap<ValueT, detail::DenseSetEmpty, ValueInfoT,\n                                      detail::DenseSetPair<ValueT>>,\n                     ValueInfoT> {\n  using BaseT =\n      detail::DenseSetImpl<ValueT,\n                           DenseMap<ValueT, detail::DenseSetEmpty, ValueInfoT,\n                                    detail::DenseSetPair<ValueT>>,\n                           ValueInfoT>;\n\npublic:\n  using BaseT::BaseT;\n};\n\n/// Implements a dense probed hash-table based set with some number of buckets\n/// stored inline.\ntemplate <typename ValueT, unsigned InlineBuckets = 4,\n          typename ValueInfoT = DenseMapInfo<ValueT>>\nclass SmallDenseSet\n    : public detail::DenseSetImpl<\n          ValueT, SmallDenseMap<ValueT, detail::DenseSetEmpty, InlineBuckets,\n                                ValueInfoT, detail::DenseSetPair<ValueT>>,\n          ValueInfoT> {\n  using BaseT = detail::DenseSetImpl<\n      ValueT, SmallDenseMap<ValueT, detail::DenseSetEmpty, InlineBuckets,\n                            ValueInfoT, detail::DenseSetPair<ValueT>>,\n      ValueInfoT>;\n\npublic:\n  using BaseT::BaseT;\n};\n\n} // end namespace llvm\n\n#endif // LLVM_ADT_DENSESET_H\n"}, "35": {"id": 35, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/FloatingPointMode.h", "content": "//===- llvm/Support/FloatingPointMode.h -------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// Utilities for dealing with flags related to floating point mode controls.\n//\n//===----------------------------------------------------------------------===/\n\n#ifndef LLVM_ADT_FLOATINGPOINTMODE_H\n#define LLVM_ADT_FLOATINGPOINTMODE_H\n\n#include \"llvm/ADT/StringSwitch.h\"\n#include \"llvm/Support/raw_ostream.h\"\n\nnamespace llvm {\n\n/// Rounding mode.\n///\n/// Enumerates supported rounding modes, as well as some special values. The set\n/// of the modes must agree with IEEE-754, 4.3.1 and 4.3.2. The constants\n/// assigned to the IEEE rounding modes must agree with the values used by\n/// FLT_ROUNDS (C11, 5.2.4.2.2p8).\n///\n/// This value is packed into bitfield in some cases, including \\c FPOptions, so\n/// the rounding mode values and the special value \\c Dynamic must fit into the\n/// the bit field (now - 3 bits). The value \\c Invalid is used only in values\n/// returned by intrinsics to indicate errors, it should never be stored as\n/// rounding mode value, so it does not need to fit the bit fields.\n///\nenum class RoundingMode : int8_t {\n  // Rounding mode defined in IEEE-754.\n  TowardZero        = 0,    ///< roundTowardZero.\n  NearestTiesToEven = 1,    ///< roundTiesToEven.\n  TowardPositive    = 2,    ///< roundTowardPositive.\n  TowardNegative    = 3,    ///< roundTowardNegative.\n  NearestTiesToAway = 4,    ///< roundTiesToAway.\n\n  // Special values.\n  Dynamic = 7,    ///< Denotes mode unknown at compile time.\n  Invalid = -1    ///< Denotes invalid value.\n};\n\n/// Returns text representation of the given rounding mode.\ninline StringRef spell(RoundingMode RM) {\n  switch (RM) {\n  case RoundingMode::TowardZero: return \"towardzero\";\n  case RoundingMode::NearestTiesToEven: return \"tonearest\";\n  case RoundingMode::TowardPositive: return \"upward\";\n  case RoundingMode::TowardNegative: return \"downward\";\n  case RoundingMode::NearestTiesToAway: return \"tonearestaway\";\n  case RoundingMode::Dynamic: return \"dynamic\";\n  default: return \"invalid\";\n  }\n}\n\ninline raw_ostream &operator << (raw_ostream &OS, RoundingMode RM) {\n  OS << spell(RM);\n  return OS;\n}\n\n/// Represent subnormal handling kind for floating point instruction inputs and\n/// outputs.\nstruct DenormalMode {\n  /// Represent handled modes for denormal (aka subnormal) modes in the floating\n  /// point environment.\n  enum DenormalModeKind : int8_t {\n    Invalid = -1,\n\n    /// IEEE-754 denormal numbers preserved.\n    IEEE,\n\n    /// The sign of a flushed-to-zero number is preserved in the sign of 0\n    PreserveSign,\n\n    /// Denormals are flushed to positive zero.\n    PositiveZero\n  };\n\n  /// Denormal flushing mode for floating point instruction results in the\n  /// default floating point environment.\n  DenormalModeKind Output = DenormalModeKind::Invalid;\n\n  /// Denormal treatment kind for floating point instruction inputs in the\n  /// default floating-point environment. If this is not DenormalModeKind::IEEE,\n  /// floating-point instructions implicitly treat the input value as 0.\n  DenormalModeKind Input = DenormalModeKind::Invalid;\n\n  constexpr DenormalMode() = default;\n  constexpr DenormalMode(DenormalModeKind Out, DenormalModeKind In) :\n    Output(Out), Input(In) {}\n\n\n  static constexpr DenormalMode getInvalid() {\n    return DenormalMode(DenormalModeKind::Invalid, DenormalModeKind::Invalid);\n  }\n\n  static constexpr DenormalMode getIEEE() {\n    return DenormalMode(DenormalModeKind::IEEE, DenormalModeKind::IEEE);\n  }\n\n  static constexpr DenormalMode getPreserveSign() {\n    return DenormalMode(DenormalModeKind::PreserveSign,\n                        DenormalModeKind::PreserveSign);\n  }\n\n  static constexpr DenormalMode getPositiveZero() {\n    return DenormalMode(DenormalModeKind::PositiveZero,\n                        DenormalModeKind::PositiveZero);\n  }\n\n  bool operator==(DenormalMode Other) const {\n    return Output == Other.Output && Input == Other.Input;\n  }\n\n  bool operator!=(DenormalMode Other) const {\n    return !(*this == Other);\n  }\n\n  bool isSimple() const {\n    return Input == Output;\n  }\n\n  bool isValid() const {\n    return Output != DenormalModeKind::Invalid &&\n           Input != DenormalModeKind::Invalid;\n  }\n\n  inline void print(raw_ostream &OS) const;\n\n  inline std::string str() const {\n    std::string storage;\n    raw_string_ostream OS(storage);\n    print(OS);\n    return OS.str();\n  }\n};\n\ninline raw_ostream& operator<<(raw_ostream &OS, DenormalMode Mode) {\n  Mode.print(OS);\n  return OS;\n}\n\n/// Parse the expected names from the denormal-fp-math attribute.\ninline DenormalMode::DenormalModeKind\nparseDenormalFPAttributeComponent(StringRef Str) {\n  // Assume ieee on unspecified attribute.\n  return StringSwitch<DenormalMode::DenormalModeKind>(Str)\n    .Cases(\"\", \"ieee\", DenormalMode::IEEE)\n    .Case(\"preserve-sign\", DenormalMode::PreserveSign)\n    .Case(\"positive-zero\", DenormalMode::PositiveZero)\n    .Default(DenormalMode::Invalid);\n}\n\n/// Return the name used for the denormal handling mode used by the the\n/// expected names from the denormal-fp-math attribute.\ninline StringRef denormalModeKindName(DenormalMode::DenormalModeKind Mode) {\n  switch (Mode) {\n  case DenormalMode::IEEE:\n    return \"ieee\";\n  case DenormalMode::PreserveSign:\n    return \"preserve-sign\";\n  case DenormalMode::PositiveZero:\n    return \"positive-zero\";\n  default:\n    return \"\";\n  }\n}\n\n/// Returns the denormal mode to use for inputs and outputs.\ninline DenormalMode parseDenormalFPAttribute(StringRef Str) {\n  StringRef OutputStr, InputStr;\n  std::tie(OutputStr, InputStr) = Str.split(',');\n\n  DenormalMode Mode;\n  Mode.Output = parseDenormalFPAttributeComponent(OutputStr);\n\n  // Maintain compatability with old form of the attribute which only specified\n  // one component.\n  Mode.Input = InputStr.empty() ? Mode.Output  :\n               parseDenormalFPAttributeComponent(InputStr);\n\n  return Mode;\n}\n\nvoid DenormalMode::print(raw_ostream &OS) const {\n  OS << denormalModeKindName(Output) << ',' << denormalModeKindName(Input);\n}\n\n}\n\n#endif // LLVM_ADT_FLOATINGPOINTMODE_H\n"}, "36": {"id": 36, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/FoldingSet.h", "content": "//===- llvm/ADT/FoldingSet.h - Uniquing Hash Set ----------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file defines a hash set that can be used to remove duplication of nodes\n// in a graph.  This code was originally created by Chris Lattner for use with\n// SelectionDAGCSEMap, but was isolated to provide use across the llvm code set.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_ADT_FOLDINGSET_H\n#define LLVM_ADT_FOLDINGSET_H\n\n#include \"llvm/ADT/SmallVector.h\"\n#include \"llvm/ADT/iterator.h\"\n#include \"llvm/Support/Allocator.h\"\n#include <cassert>\n#include <cstddef>\n#include <cstdint>\n#include <utility>\n\nnamespace llvm {\n\n/// This folding set used for two purposes:\n///   1. Given information about a node we want to create, look up the unique\n///      instance of the node in the set.  If the node already exists, return\n///      it, otherwise return the bucket it should be inserted into.\n///   2. Given a node that has already been created, remove it from the set.\n///\n/// This class is implemented as a single-link chained hash table, where the\n/// \"buckets\" are actually the nodes themselves (the next pointer is in the\n/// node).  The last node points back to the bucket to simplify node removal.\n///\n/// Any node that is to be included in the folding set must be a subclass of\n/// FoldingSetNode.  The node class must also define a Profile method used to\n/// establish the unique bits of data for the node.  The Profile method is\n/// passed a FoldingSetNodeID object which is used to gather the bits.  Just\n/// call one of the Add* functions defined in the FoldingSetBase::NodeID class.\n/// NOTE: That the folding set does not own the nodes and it is the\n/// responsibility of the user to dispose of the nodes.\n///\n/// Eg.\n///    class MyNode : public FoldingSetNode {\n///    private:\n///      std::string Name;\n///      unsigned Value;\n///    public:\n///      MyNode(const char *N, unsigned V) : Name(N), Value(V) {}\n///       ...\n///      void Profile(FoldingSetNodeID &ID) const {\n///        ID.AddString(Name);\n///        ID.AddInteger(Value);\n///      }\n///      ...\n///    };\n///\n/// To define the folding set itself use the FoldingSet template;\n///\n/// Eg.\n///    FoldingSet<MyNode> MyFoldingSet;\n///\n/// Four public methods are available to manipulate the folding set;\n///\n/// 1) If you have an existing node that you want add to the set but unsure\n/// that the node might already exist then call;\n///\n///    MyNode *M = MyFoldingSet.GetOrInsertNode(N);\n///\n/// If The result is equal to the input then the node has been inserted.\n/// Otherwise, the result is the node existing in the folding set, and the\n/// input can be discarded (use the result instead.)\n///\n/// 2) If you are ready to construct a node but want to check if it already\n/// exists, then call FindNodeOrInsertPos with a FoldingSetNodeID of the bits to\n/// check;\n///\n///   FoldingSetNodeID ID;\n///   ID.AddString(Name);\n///   ID.AddInteger(Value);\n///   void *InsertPoint;\n///\n///    MyNode *M = MyFoldingSet.FindNodeOrInsertPos(ID, InsertPoint);\n///\n/// If found then M will be non-NULL, else InsertPoint will point to where it\n/// should be inserted using InsertNode.\n///\n/// 3) If you get a NULL result from FindNodeOrInsertPos then you can insert a\n/// new node with InsertNode;\n///\n///    MyFoldingSet.InsertNode(M, InsertPoint);\n///\n/// 4) Finally, if you want to remove a node from the folding set call;\n///\n///    bool WasRemoved = MyFoldingSet.RemoveNode(M);\n///\n/// The result indicates whether the node existed in the folding set.\n\nclass FoldingSetNodeID;\nclass StringRef;\n\n//===----------------------------------------------------------------------===//\n/// FoldingSetBase - Implements the folding set functionality.  The main\n/// structure is an array of buckets.  Each bucket is indexed by the hash of\n/// the nodes it contains.  The bucket itself points to the nodes contained\n/// in the bucket via a singly linked list.  The last node in the list points\n/// back to the bucket to facilitate node removal.\n///\nclass FoldingSetBase {\nprotected:\n  /// Buckets - Array of bucket chains.\n  void **Buckets;\n\n  /// NumBuckets - Length of the Buckets array.  Always a power of 2.\n  unsigned NumBuckets;\n\n  /// NumNodes - Number of nodes in the folding set. Growth occurs when NumNodes\n  /// is greater than twice the number of buckets.\n  unsigned NumNodes;\n\n  explicit FoldingSetBase(unsigned Log2InitSize = 6);\n  FoldingSetBase(FoldingSetBase &&Arg);\n  FoldingSetBase &operator=(FoldingSetBase &&RHS);\n  ~FoldingSetBase();\n\npublic:\n  //===--------------------------------------------------------------------===//\n  /// Node - This class is used to maintain the singly linked bucket list in\n  /// a folding set.\n  class Node {\n  private:\n    // NextInFoldingSetBucket - next link in the bucket list.\n    void *NextInFoldingSetBucket = nullptr;\n\n  public:\n    Node() = default;\n\n    // Accessors\n    void *getNextInBucket() const { return NextInFoldingSetBucket; }\n    void SetNextInBucket(void *N) { NextInFoldingSetBucket = N; }\n  };\n\n  /// clear - Remove all nodes from the folding set.\n  void clear();\n\n  /// size - Returns the number of nodes in the folding set.\n  unsigned size() const { return NumNodes; }\n\n  /// empty - Returns true if there are no nodes in the folding set.\n  bool empty() const { return NumNodes == 0; }\n\n  /// capacity - Returns the number of nodes permitted in the folding set\n  /// before a rebucket operation is performed.\n  unsigned capacity() {\n    // We allow a load factor of up to 2.0,\n    // so that means our capacity is NumBuckets * 2\n    return NumBuckets * 2;\n  }\n\nprotected:\n  /// Functions provided by the derived class to compute folding properties.\n  /// This is effectively a vtable for FoldingSetBase, except that we don't\n  /// actually store a pointer to it in the object.\n  struct FoldingSetInfo {\n    /// GetNodeProfile - Instantiations of the FoldingSet template implement\n    /// this function to gather data bits for the given node.\n    void (*GetNodeProfile)(const FoldingSetBase *Self, Node *N,\n                           FoldingSetNodeID &ID);\n\n    /// NodeEquals - Instantiations of the FoldingSet template implement\n    /// this function to compare the given node with the given ID.\n    bool (*NodeEquals)(const FoldingSetBase *Self, Node *N,\n                       const FoldingSetNodeID &ID, unsigned IDHash,\n                       FoldingSetNodeID &TempID);\n\n    /// ComputeNodeHash - Instantiations of the FoldingSet template implement\n    /// this function to compute a hash value for the given node.\n    unsigned (*ComputeNodeHash)(const FoldingSetBase *Self, Node *N,\n                                FoldingSetNodeID &TempID);\n  };\n\nprivate:\n  /// GrowHashTable - Double the size of the hash table and rehash everything.\n  void GrowHashTable(const FoldingSetInfo &Info);\n\n  /// GrowBucketCount - resize the hash table and rehash everything.\n  /// NewBucketCount must be a power of two, and must be greater than the old\n  /// bucket count.\n  void GrowBucketCount(unsigned NewBucketCount, const FoldingSetInfo &Info);\n\nprotected:\n  // The below methods are protected to encourage subclasses to provide a more\n  // type-safe API.\n\n  /// reserve - Increase the number of buckets such that adding the\n  /// EltCount-th node won't cause a rebucket operation. reserve is permitted\n  /// to allocate more space than requested by EltCount.\n  void reserve(unsigned EltCount, const FoldingSetInfo &Info);\n\n  /// RemoveNode - Remove a node from the folding set, returning true if one\n  /// was removed or false if the node was not in the folding set.\n  bool RemoveNode(Node *N);\n\n  /// GetOrInsertNode - If there is an existing simple Node exactly\n  /// equal to the specified node, return it.  Otherwise, insert 'N' and return\n  /// it instead.\n  Node *GetOrInsertNode(Node *N, const FoldingSetInfo &Info);\n\n  /// FindNodeOrInsertPos - Look up the node specified by ID.  If it exists,\n  /// return it.  If not, return the insertion token that will make insertion\n  /// faster.\n  Node *FindNodeOrInsertPos(const FoldingSetNodeID &ID, void *&InsertPos,\n                            const FoldingSetInfo &Info);\n\n  /// InsertNode - Insert the specified node into the folding set, knowing that\n  /// it is not already in the folding set.  InsertPos must be obtained from\n  /// FindNodeOrInsertPos.\n  void InsertNode(Node *N, void *InsertPos, const FoldingSetInfo &Info);\n};\n\n//===----------------------------------------------------------------------===//\n\n/// DefaultFoldingSetTrait - This class provides default implementations\n/// for FoldingSetTrait implementations.\ntemplate<typename T> struct DefaultFoldingSetTrait {\n  static void Profile(const T &X, FoldingSetNodeID &ID) {\n    X.Profile(ID);\n  }\n  static void Profile(T &X, FoldingSetNodeID &ID) {\n    X.Profile(ID);\n  }\n\n  // Equals - Test if the profile for X would match ID, using TempID\n  // to compute a temporary ID if necessary. The default implementation\n  // just calls Profile and does a regular comparison. Implementations\n  // can override this to provide more efficient implementations.\n  static inline bool Equals(T &X, const FoldingSetNodeID &ID, unsigned IDHash,\n                            FoldingSetNodeID &TempID);\n\n  // ComputeHash - Compute a hash value for X, using TempID to\n  // compute a temporary ID if necessary. The default implementation\n  // just calls Profile and does a regular hash computation.\n  // Implementations can override this to provide more efficient\n  // implementations.\n  static inline unsigned ComputeHash(T &X, FoldingSetNodeID &TempID);\n};\n\n/// FoldingSetTrait - This trait class is used to define behavior of how\n/// to \"profile\" (in the FoldingSet parlance) an object of a given type.\n/// The default behavior is to invoke a 'Profile' method on an object, but\n/// through template specialization the behavior can be tailored for specific\n/// types.  Combined with the FoldingSetNodeWrapper class, one can add objects\n/// to FoldingSets that were not originally designed to have that behavior.\ntemplate<typename T> struct FoldingSetTrait\n  : public DefaultFoldingSetTrait<T> {};\n\n/// DefaultContextualFoldingSetTrait - Like DefaultFoldingSetTrait, but\n/// for ContextualFoldingSets.\ntemplate<typename T, typename Ctx>\nstruct DefaultContextualFoldingSetTrait {\n  static void Profile(T &X, FoldingSetNodeID &ID, Ctx Context) {\n    X.Profile(ID, Context);\n  }\n\n  static inline bool Equals(T &X, const FoldingSetNodeID &ID, unsigned IDHash,\n                            FoldingSetNodeID &TempID, Ctx Context);\n  static inline unsigned ComputeHash(T &X, FoldingSetNodeID &TempID,\n                                     Ctx Context);\n};\n\n/// ContextualFoldingSetTrait - Like FoldingSetTrait, but for\n/// ContextualFoldingSets.\ntemplate<typename T, typename Ctx> struct ContextualFoldingSetTrait\n  : public DefaultContextualFoldingSetTrait<T, Ctx> {};\n\n//===--------------------------------------------------------------------===//\n/// FoldingSetNodeIDRef - This class describes a reference to an interned\n/// FoldingSetNodeID, which can be a useful to store node id data rather\n/// than using plain FoldingSetNodeIDs, since the 32-element SmallVector\n/// is often much larger than necessary, and the possibility of heap\n/// allocation means it requires a non-trivial destructor call.\nclass FoldingSetNodeIDRef {\n  const unsigned *Data = nullptr;\n  size_t Size = 0;\n\npublic:\n  FoldingSetNodeIDRef() = default;\n  FoldingSetNodeIDRef(const unsigned *D, size_t S) : Data(D), Size(S) {}\n\n  /// ComputeHash - Compute a strong hash value for this FoldingSetNodeIDRef,\n  /// used to lookup the node in the FoldingSetBase.\n  unsigned ComputeHash() const;\n\n  bool operator==(FoldingSetNodeIDRef) const;\n\n  bool operator!=(FoldingSetNodeIDRef RHS) const { return !(*this == RHS); }\n\n  /// Used to compare the \"ordering\" of two nodes as defined by the\n  /// profiled bits and their ordering defined by memcmp().\n  bool operator<(FoldingSetNodeIDRef) const;\n\n  const unsigned *getData() const { return Data; }\n  size_t getSize() const { return Size; }\n};\n\n//===--------------------------------------------------------------------===//\n/// FoldingSetNodeID - This class is used to gather all the unique data bits of\n/// a node.  When all the bits are gathered this class is used to produce a\n/// hash value for the node.\nclass FoldingSetNodeID {\n  /// Bits - Vector of all the data bits that make the node unique.\n  /// Use a SmallVector to avoid a heap allocation in the common case.\n  SmallVector<unsigned, 32> Bits;\n\npublic:\n  FoldingSetNodeID() = default;\n\n  FoldingSetNodeID(FoldingSetNodeIDRef Ref)\n    : Bits(Ref.getData(), Ref.getData() + Ref.getSize()) {}\n\n  /// Add* - Add various data types to Bit data.\n  void AddPointer(const void *Ptr);\n  void AddInteger(signed I);\n  void AddInteger(unsigned I);\n  void AddInteger(long I);\n  void AddInteger(unsigned long I);\n  void AddInteger(long long I);\n  void AddInteger(unsigned long long I);\n  void AddBoolean(bool B) { AddInteger(B ? 1U : 0U); }\n  void AddString(StringRef String);\n  void AddNodeID(const FoldingSetNodeID &ID);\n\n  template <typename T>\n  inline void Add(const T &x) { FoldingSetTrait<T>::Profile(x, *this); }\n\n  /// clear - Clear the accumulated profile, allowing this FoldingSetNodeID\n  /// object to be used to compute a new profile.\n  inline void clear() { Bits.clear(); }\n\n  /// ComputeHash - Compute a strong hash value for this FoldingSetNodeID, used\n  /// to lookup the node in the FoldingSetBase.\n  unsigned ComputeHash() const;\n\n  /// operator== - Used to compare two nodes to each other.\n  bool operator==(const FoldingSetNodeID &RHS) const;\n  bool operator==(const FoldingSetNodeIDRef RHS) const;\n\n  bool operator!=(const FoldingSetNodeID &RHS) const { return !(*this == RHS); }\n  bool operator!=(const FoldingSetNodeIDRef RHS) const { return !(*this ==RHS);}\n\n  /// Used to compare the \"ordering\" of two nodes as defined by the\n  /// profiled bits and their ordering defined by memcmp().\n  bool operator<(const FoldingSetNodeID &RHS) const;\n  bool operator<(const FoldingSetNodeIDRef RHS) const;\n\n  /// Intern - Copy this node's data to a memory region allocated from the\n  /// given allocator and return a FoldingSetNodeIDRef describing the\n  /// interned data.\n  FoldingSetNodeIDRef Intern(BumpPtrAllocator &Allocator) const;\n};\n\n// Convenience type to hide the implementation of the folding set.\nusing FoldingSetNode = FoldingSetBase::Node;\ntemplate<class T> class FoldingSetIterator;\ntemplate<class T> class FoldingSetBucketIterator;\n\n// Definitions of FoldingSetTrait and ContextualFoldingSetTrait functions, which\n// require the definition of FoldingSetNodeID.\ntemplate<typename T>\ninline bool\nDefaultFoldingSetTrait<T>::Equals(T &X, const FoldingSetNodeID &ID,\n                                  unsigned /*IDHash*/,\n                                  FoldingSetNodeID &TempID) {\n  FoldingSetTrait<T>::Profile(X, TempID);\n  return TempID == ID;\n}\ntemplate<typename T>\ninline unsigned\nDefaultFoldingSetTrait<T>::ComputeHash(T &X, FoldingSetNodeID &TempID) {\n  FoldingSetTrait<T>::Profile(X, TempID);\n  return TempID.ComputeHash();\n}\ntemplate<typename T, typename Ctx>\ninline bool\nDefaultContextualFoldingSetTrait<T, Ctx>::Equals(T &X,\n                                                 const FoldingSetNodeID &ID,\n                                                 unsigned /*IDHash*/,\n                                                 FoldingSetNodeID &TempID,\n                                                 Ctx Context) {\n  ContextualFoldingSetTrait<T, Ctx>::Profile(X, TempID, Context);\n  return TempID == ID;\n}\ntemplate<typename T, typename Ctx>\ninline unsigned\nDefaultContextualFoldingSetTrait<T, Ctx>::ComputeHash(T &X,\n                                                      FoldingSetNodeID &TempID,\n                                                      Ctx Context) {\n  ContextualFoldingSetTrait<T, Ctx>::Profile(X, TempID, Context);\n  return TempID.ComputeHash();\n}\n\n//===----------------------------------------------------------------------===//\n/// FoldingSetImpl - An implementation detail that lets us share code between\n/// FoldingSet and ContextualFoldingSet.\ntemplate <class Derived, class T> class FoldingSetImpl : public FoldingSetBase {\nprotected:\n  explicit FoldingSetImpl(unsigned Log2InitSize)\n      : FoldingSetBase(Log2InitSize) {}\n\n  FoldingSetImpl(FoldingSetImpl &&Arg) = default;\n  FoldingSetImpl &operator=(FoldingSetImpl &&RHS) = default;\n  ~FoldingSetImpl() = default;\n\npublic:\n  using iterator = FoldingSetIterator<T>;\n\n  iterator begin() { return iterator(Buckets); }\n  iterator end() { return iterator(Buckets+NumBuckets); }\n\n  using const_iterator = FoldingSetIterator<const T>;\n\n  const_iterator begin() const { return const_iterator(Buckets); }\n  const_iterator end() const { return const_iterator(Buckets+NumBuckets); }\n\n  using bucket_iterator = FoldingSetBucketIterator<T>;\n\n  bucket_iterator bucket_begin(unsigned hash) {\n    return bucket_iterator(Buckets + (hash & (NumBuckets-1)));\n  }\n\n  bucket_iterator bucket_end(unsigned hash) {\n    return bucket_iterator(Buckets + (hash & (NumBuckets-1)), true);\n  }\n\n  /// reserve - Increase the number of buckets such that adding the\n  /// EltCount-th node won't cause a rebucket operation. reserve is permitted\n  /// to allocate more space than requested by EltCount.\n  void reserve(unsigned EltCount) {\n    return FoldingSetBase::reserve(EltCount, Derived::getFoldingSetInfo());\n  }\n\n  /// RemoveNode - Remove a node from the folding set, returning true if one\n  /// was removed or false if the node was not in the folding set.\n  bool RemoveNode(T *N) {\n    return FoldingSetBase::RemoveNode(N);\n  }\n\n  /// GetOrInsertNode - If there is an existing simple Node exactly\n  /// equal to the specified node, return it.  Otherwise, insert 'N' and\n  /// return it instead.\n  T *GetOrInsertNode(T *N) {\n    return static_cast<T *>(\n        FoldingSetBase::GetOrInsertNode(N, Derived::getFoldingSetInfo()));\n  }\n\n  /// FindNodeOrInsertPos - Look up the node specified by ID.  If it exists,\n  /// return it.  If not, return the insertion token that will make insertion\n  /// faster.\n  T *FindNodeOrInsertPos(const FoldingSetNodeID &ID, void *&InsertPos) {\n    return static_cast<T *>(FoldingSetBase::FindNodeOrInsertPos(\n        ID, InsertPos, Derived::getFoldingSetInfo()));\n  }\n\n  /// InsertNode - Insert the specified node into the folding set, knowing that\n  /// it is not already in the folding set.  InsertPos must be obtained from\n  /// FindNodeOrInsertPos.\n  void InsertNode(T *N, void *InsertPos) {\n    FoldingSetBase::InsertNode(N, InsertPos, Derived::getFoldingSetInfo());\n  }\n\n  /// InsertNode - Insert the specified node into the folding set, knowing that\n  /// it is not already in the folding set.\n  void InsertNode(T *N) {\n    T *Inserted = GetOrInsertNode(N);\n    (void)Inserted;\n    assert(Inserted == N && \"Node already inserted!\");\n  }\n};\n\n//===----------------------------------------------------------------------===//\n/// FoldingSet - This template class is used to instantiate a specialized\n/// implementation of the folding set to the node class T.  T must be a\n/// subclass of FoldingSetNode and implement a Profile function.\n///\n/// Note that this set type is movable and move-assignable. However, its\n/// moved-from state is not a valid state for anything other than\n/// move-assigning and destroying. This is primarily to enable movable APIs\n/// that incorporate these objects.\ntemplate <class T>\nclass FoldingSet : public FoldingSetImpl<FoldingSet<T>, T> {\n  using Super = FoldingSetImpl<FoldingSet, T>;\n  using Node = typename Super::Node;\n\n  /// GetNodeProfile - Each instantiation of the FoldingSet needs to provide a\n  /// way to convert nodes into a unique specifier.\n  static void GetNodeProfile(const FoldingSetBase *, Node *N,\n                             FoldingSetNodeID &ID) {\n    T *TN = static_cast<T *>(N);\n    FoldingSetTrait<T>::Profile(*TN, ID);\n  }\n\n  /// NodeEquals - Instantiations may optionally provide a way to compare a\n  /// node with a specified ID.\n  static bool NodeEquals(const FoldingSetBase *, Node *N,\n                         const FoldingSetNodeID &ID, unsigned IDHash,\n                         FoldingSetNodeID &TempID) {\n    T *TN = static_cast<T *>(N);\n    return FoldingSetTrait<T>::Equals(*TN, ID, IDHash, TempID);\n  }\n\n  /// ComputeNodeHash - Instantiations may optionally provide a way to compute a\n  /// hash value directly from a node.\n  static unsigned ComputeNodeHash(const FoldingSetBase *, Node *N,\n                                  FoldingSetNodeID &TempID) {\n    T *TN = static_cast<T *>(N);\n    return FoldingSetTrait<T>::ComputeHash(*TN, TempID);\n  }\n\n  static const FoldingSetBase::FoldingSetInfo &getFoldingSetInfo() {\n    static constexpr FoldingSetBase::FoldingSetInfo Info = {\n        GetNodeProfile, NodeEquals, ComputeNodeHash};\n    return Info;\n  }\n  friend Super;\n\npublic:\n  explicit FoldingSet(unsigned Log2InitSize = 6) : Super(Log2InitSize) {}\n  FoldingSet(FoldingSet &&Arg) = default;\n  FoldingSet &operator=(FoldingSet &&RHS) = default;\n};\n\n//===----------------------------------------------------------------------===//\n/// ContextualFoldingSet - This template class is a further refinement\n/// of FoldingSet which provides a context argument when calling\n/// Profile on its nodes.  Currently, that argument is fixed at\n/// initialization time.\n///\n/// T must be a subclass of FoldingSetNode and implement a Profile\n/// function with signature\n///   void Profile(FoldingSetNodeID &, Ctx);\ntemplate <class T, class Ctx>\nclass ContextualFoldingSet\n    : public FoldingSetImpl<ContextualFoldingSet<T, Ctx>, T> {\n  // Unfortunately, this can't derive from FoldingSet<T> because the\n  // construction of the vtable for FoldingSet<T> requires\n  // FoldingSet<T>::GetNodeProfile to be instantiated, which in turn\n  // requires a single-argument T::Profile().\n\n  using Super = FoldingSetImpl<ContextualFoldingSet, T>;\n  using Node = typename Super::Node;\n\n  Ctx Context;\n\n  static const Ctx &getContext(const FoldingSetBase *Base) {\n    return static_cast<const ContextualFoldingSet*>(Base)->Context;\n  }\n\n  /// GetNodeProfile - Each instantiatation of the FoldingSet needs to provide a\n  /// way to convert nodes into a unique specifier.\n  static void GetNodeProfile(const FoldingSetBase *Base, Node *N,\n                             FoldingSetNodeID &ID) {\n    T *TN = static_cast<T *>(N);\n    ContextualFoldingSetTrait<T, Ctx>::Profile(*TN, ID, getContext(Base));\n  }\n\n  static bool NodeEquals(const FoldingSetBase *Base, Node *N,\n                         const FoldingSetNodeID &ID, unsigned IDHash,\n                         FoldingSetNodeID &TempID) {\n    T *TN = static_cast<T *>(N);\n    return ContextualFoldingSetTrait<T, Ctx>::Equals(*TN, ID, IDHash, TempID,\n                                                     getContext(Base));\n  }\n\n  static unsigned ComputeNodeHash(const FoldingSetBase *Base, Node *N,\n                                  FoldingSetNodeID &TempID) {\n    T *TN = static_cast<T *>(N);\n    return ContextualFoldingSetTrait<T, Ctx>::ComputeHash(*TN, TempID,\n                                                          getContext(Base));\n  }\n\n  static const FoldingSetBase::FoldingSetInfo &getFoldingSetInfo() {\n    static constexpr FoldingSetBase::FoldingSetInfo Info = {\n        GetNodeProfile, NodeEquals, ComputeNodeHash};\n    return Info;\n  }\n  friend Super;\n\npublic:\n  explicit ContextualFoldingSet(Ctx Context, unsigned Log2InitSize = 6)\n      : Super(Log2InitSize), Context(Context) {}\n\n  Ctx getContext() const { return Context; }\n};\n\n//===----------------------------------------------------------------------===//\n/// FoldingSetVector - This template class combines a FoldingSet and a vector\n/// to provide the interface of FoldingSet but with deterministic iteration\n/// order based on the insertion order. T must be a subclass of FoldingSetNode\n/// and implement a Profile function.\ntemplate <class T, class VectorT = SmallVector<T*, 8>>\nclass FoldingSetVector {\n  FoldingSet<T> Set;\n  VectorT Vector;\n\npublic:\n  explicit FoldingSetVector(unsigned Log2InitSize = 6) : Set(Log2InitSize) {}\n\n  using iterator = pointee_iterator<typename VectorT::iterator>;\n\n  iterator begin() { return Vector.begin(); }\n  iterator end()   { return Vector.end(); }\n\n  using const_iterator = pointee_iterator<typename VectorT::const_iterator>;\n\n  const_iterator begin() const { return Vector.begin(); }\n  const_iterator end()   const { return Vector.end(); }\n\n  /// clear - Remove all nodes from the folding set.\n  void clear() { Set.clear(); Vector.clear(); }\n\n  /// FindNodeOrInsertPos - Look up the node specified by ID.  If it exists,\n  /// return it.  If not, return the insertion token that will make insertion\n  /// faster.\n  T *FindNodeOrInsertPos(const FoldingSetNodeID &ID, void *&InsertPos) {\n    return Set.FindNodeOrInsertPos(ID, InsertPos);\n  }\n\n  /// GetOrInsertNode - If there is an existing simple Node exactly\n  /// equal to the specified node, return it.  Otherwise, insert 'N' and\n  /// return it instead.\n  T *GetOrInsertNode(T *N) {\n    T *Result = Set.GetOrInsertNode(N);\n    if (Result == N) Vector.push_back(N);\n    return Result;\n  }\n\n  /// InsertNode - Insert the specified node into the folding set, knowing that\n  /// it is not already in the folding set.  InsertPos must be obtained from\n  /// FindNodeOrInsertPos.\n  void InsertNode(T *N, void *InsertPos) {\n    Set.InsertNode(N, InsertPos);\n    Vector.push_back(N);\n  }\n\n  /// InsertNode - Insert the specified node into the folding set, knowing that\n  /// it is not already in the folding set.\n  void InsertNode(T *N) {\n    Set.InsertNode(N);\n    Vector.push_back(N);\n  }\n\n  /// size - Returns the number of nodes in the folding set.\n  unsigned size() const { return Set.size(); }\n\n  /// empty - Returns true if there are no nodes in the folding set.\n  bool empty() const { return Set.empty(); }\n};\n\n//===----------------------------------------------------------------------===//\n/// FoldingSetIteratorImpl - This is the common iterator support shared by all\n/// folding sets, which knows how to walk the folding set hash table.\nclass FoldingSetIteratorImpl {\nprotected:\n  FoldingSetNode *NodePtr;\n\n  FoldingSetIteratorImpl(void **Bucket);\n\n  void advance();\n\npublic:\n  bool operator==(const FoldingSetIteratorImpl &RHS) const {\n    return NodePtr == RHS.NodePtr;\n  }\n  bool operator!=(const FoldingSetIteratorImpl &RHS) const {\n    return NodePtr != RHS.NodePtr;\n  }\n};\n\ntemplate <class T> class FoldingSetIterator : public FoldingSetIteratorImpl {\npublic:\n  explicit FoldingSetIterator(void **Bucket) : FoldingSetIteratorImpl(Bucket) {}\n\n  T &operator*() const {\n    return *static_cast<T*>(NodePtr);\n  }\n\n  T *operator->() const {\n    return static_cast<T*>(NodePtr);\n  }\n\n  inline FoldingSetIterator &operator++() {          // Preincrement\n    advance();\n    return *this;\n  }\n  FoldingSetIterator operator++(int) {        // Postincrement\n    FoldingSetIterator tmp = *this; ++*this; return tmp;\n  }\n};\n\n//===----------------------------------------------------------------------===//\n/// FoldingSetBucketIteratorImpl - This is the common bucket iterator support\n/// shared by all folding sets, which knows how to walk a particular bucket\n/// of a folding set hash table.\nclass FoldingSetBucketIteratorImpl {\nprotected:\n  void *Ptr;\n\n  explicit FoldingSetBucketIteratorImpl(void **Bucket);\n\n  FoldingSetBucketIteratorImpl(void **Bucket, bool) : Ptr(Bucket) {}\n\n  void advance() {\n    void *Probe = static_cast<FoldingSetNode*>(Ptr)->getNextInBucket();\n    uintptr_t x = reinterpret_cast<uintptr_t>(Probe) & ~0x1;\n    Ptr = reinterpret_cast<void*>(x);\n  }\n\npublic:\n  bool operator==(const FoldingSetBucketIteratorImpl &RHS) const {\n    return Ptr == RHS.Ptr;\n  }\n  bool operator!=(const FoldingSetBucketIteratorImpl &RHS) const {\n    return Ptr != RHS.Ptr;\n  }\n};\n\ntemplate <class T>\nclass FoldingSetBucketIterator : public FoldingSetBucketIteratorImpl {\npublic:\n  explicit FoldingSetBucketIterator(void **Bucket) :\n    FoldingSetBucketIteratorImpl(Bucket) {}\n\n  FoldingSetBucketIterator(void **Bucket, bool) :\n    FoldingSetBucketIteratorImpl(Bucket, true) {}\n\n  T &operator*() const { return *static_cast<T*>(Ptr); }\n  T *operator->() const { return static_cast<T*>(Ptr); }\n\n  inline FoldingSetBucketIterator &operator++() { // Preincrement\n    advance();\n    return *this;\n  }\n  FoldingSetBucketIterator operator++(int) {      // Postincrement\n    FoldingSetBucketIterator tmp = *this; ++*this; return tmp;\n  }\n};\n\n//===----------------------------------------------------------------------===//\n/// FoldingSetNodeWrapper - This template class is used to \"wrap\" arbitrary\n/// types in an enclosing object so that they can be inserted into FoldingSets.\ntemplate <typename T>\nclass FoldingSetNodeWrapper : public FoldingSetNode {\n  T data;\n\npublic:\n  template <typename... Ts>\n  explicit FoldingSetNodeWrapper(Ts &&... Args)\n      : data(std::forward<Ts>(Args)...) {}\n\n  void Profile(FoldingSetNodeID &ID) { FoldingSetTrait<T>::Profile(data, ID); }\n\n  T &getValue() { return data; }\n  const T &getValue() const { return data; }\n\n  operator T&() { return data; }\n  operator const T&() const { return data; }\n};\n\n//===----------------------------------------------------------------------===//\n/// FastFoldingSetNode - This is a subclass of FoldingSetNode which stores\n/// a FoldingSetNodeID value rather than requiring the node to recompute it\n/// each time it is needed. This trades space for speed (which can be\n/// significant if the ID is long), and it also permits nodes to drop\n/// information that would otherwise only be required for recomputing an ID.\nclass FastFoldingSetNode : public FoldingSetNode {\n  FoldingSetNodeID FastID;\n\nprotected:\n  explicit FastFoldingSetNode(const FoldingSetNodeID &ID) : FastID(ID) {}\n\npublic:\n  void Profile(FoldingSetNodeID &ID) const { ID.AddNodeID(FastID); }\n};\n\n//===----------------------------------------------------------------------===//\n// Partial specializations of FoldingSetTrait.\n\ntemplate<typename T> struct FoldingSetTrait<T*> {\n  static inline void Profile(T *X, FoldingSetNodeID &ID) {\n    ID.AddPointer(X);\n  }\n};\ntemplate <typename T1, typename T2>\nstruct FoldingSetTrait<std::pair<T1, T2>> {\n  static inline void Profile(const std::pair<T1, T2> &P,\n                             FoldingSetNodeID &ID) {\n    ID.Add(P.first);\n    ID.Add(P.second);\n  }\n};\n\n} // end namespace llvm\n\n#endif // LLVM_ADT_FOLDINGSET_H\n"}, "38": {"id": 38, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/ImmutableList.h", "content": "//==--- ImmutableList.h - Immutable (functional) list interface --*- C++ -*-==//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file defines the ImmutableList class.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_ADT_IMMUTABLELIST_H\n#define LLVM_ADT_IMMUTABLELIST_H\n\n#include \"llvm/ADT/FoldingSet.h\"\n#include \"llvm/Support/Allocator.h\"\n#include <cassert>\n#include <cstdint>\n#include <new>\n\nnamespace llvm {\n\ntemplate <typename T> class ImmutableListFactory;\n\ntemplate <typename T>\nclass ImmutableListImpl : public FoldingSetNode {\n  friend class ImmutableListFactory<T>;\n\n  T Head;\n  const ImmutableListImpl* Tail;\n\n  template <typename ElemT>\n  ImmutableListImpl(ElemT &&head, const ImmutableListImpl *tail = nullptr)\n    : Head(std::forward<ElemT>(head)), Tail(tail) {}\n\npublic:\n  ImmutableListImpl(const ImmutableListImpl &) = delete;\n  ImmutableListImpl &operator=(const ImmutableListImpl &) = delete;\n\n  const T& getHead() const { return Head; }\n  const ImmutableListImpl* getTail() const { return Tail; }\n\n  static inline void Profile(FoldingSetNodeID& ID, const T& H,\n                             const ImmutableListImpl* L){\n    ID.AddPointer(L);\n    ID.Add(H);\n  }\n\n  void Profile(FoldingSetNodeID& ID) {\n    Profile(ID, Head, Tail);\n  }\n};\n\n/// ImmutableList - This class represents an immutable (functional) list.\n///  It is implemented as a smart pointer (wraps ImmutableListImpl), so it\n///  it is intended to always be copied by value as if it were a pointer.\n///  This interface matches ImmutableSet and ImmutableMap.  ImmutableList\n///  objects should almost never be created directly, and instead should\n///  be created by ImmutableListFactory objects that manage the lifetime\n///  of a group of lists.  When the factory object is reclaimed, all lists\n///  created by that factory are released as well.\ntemplate <typename T>\nclass ImmutableList {\npublic:\n  using value_type = T;\n  using Factory = ImmutableListFactory<T>;\n\n  static_assert(std::is_trivially_destructible<T>::value,\n                \"T must be trivially destructible!\");\n\nprivate:\n  const ImmutableListImpl<T>* X;\n\npublic:\n  // This constructor should normally only be called by ImmutableListFactory<T>.\n  // There may be cases, however, when one needs to extract the internal pointer\n  // and reconstruct a list object from that pointer.\n  ImmutableList(const ImmutableListImpl<T>* x = nullptr) : X(x) {}\n\n  const ImmutableListImpl<T>* getInternalPointer() const {\n    return X;\n  }\n\n  class iterator {\n    const ImmutableListImpl<T>* L = nullptr;\n\n  public:\n    iterator() = default;\n    iterator(ImmutableList l) : L(l.getInternalPointer()) {}\n\n    iterator& operator++() { L = L->getTail(); return *this; }\n    bool operator==(const iterator& I) const { return L == I.L; }\n    bool operator!=(const iterator& I) const { return L != I.L; }\n    const value_type& operator*() const { return L->getHead(); }\n    const typename std::remove_reference<value_type>::type* operator->() const {\n      return &L->getHead();\n    }\n\n    ImmutableList getList() const { return L; }\n  };\n\n  /// begin - Returns an iterator referring to the head of the list, or\n  ///  an iterator denoting the end of the list if the list is empty.\n  iterator begin() const { return iterator(X); }\n\n  /// end - Returns an iterator denoting the end of the list.  This iterator\n  ///  does not refer to a valid list element.\n  iterator end() const { return iterator(); }\n\n  /// isEmpty - Returns true if the list is empty.\n  bool isEmpty() const { return !X; }\n\n  bool contains(const T& V) const {\n    for (iterator I = begin(), E = end(); I != E; ++I) {\n      if (*I == V)\n        return true;\n    }\n    return false;\n  }\n\n  /// isEqual - Returns true if two lists are equal.  Because all lists created\n  ///  from the same ImmutableListFactory are uniqued, this has O(1) complexity\n  ///  because it the contents of the list do not need to be compared.  Note\n  ///  that you should only compare two lists created from the same\n  ///  ImmutableListFactory.\n  bool isEqual(const ImmutableList& L) const { return X == L.X; }\n\n  bool operator==(const ImmutableList& L) const { return isEqual(L); }\n\n  /// getHead - Returns the head of the list.\n  const T& getHead() const {\n    assert(!isEmpty() && \"Cannot get the head of an empty list.\");\n    return X->getHead();\n  }\n\n  /// getTail - Returns the tail of the list, which is another (possibly empty)\n  ///  ImmutableList.\n  ImmutableList getTail() const {\n    return X ? X->getTail() : nullptr;\n  }\n\n  void Profile(FoldingSetNodeID& ID) const {\n    ID.AddPointer(X);\n  }\n};\n\ntemplate <typename T>\nclass ImmutableListFactory {\n  using ListTy = ImmutableListImpl<T>;\n  using CacheTy = FoldingSet<ListTy>;\n\n  CacheTy Cache;\n  uintptr_t Allocator;\n\n  bool ownsAllocator() const {\n    return (Allocator & 0x1) == 0;\n  }\n\n  BumpPtrAllocator& getAllocator() const {\n    return *reinterpret_cast<BumpPtrAllocator*>(Allocator & ~0x1);\n  }\n\npublic:\n  ImmutableListFactory()\n    : Allocator(reinterpret_cast<uintptr_t>(new BumpPtrAllocator())) {}\n\n  ImmutableListFactory(BumpPtrAllocator& Alloc)\n  : Allocator(reinterpret_cast<uintptr_t>(&Alloc) | 0x1) {}\n\n  ~ImmutableListFactory() {\n    if (ownsAllocator()) delete &getAllocator();\n  }\n\n  template <typename ElemT>\n  LLVM_NODISCARD ImmutableList<T> concat(ElemT &&Head, ImmutableList<T> Tail) {\n    // Profile the new list to see if it already exists in our cache.\n    FoldingSetNodeID ID;\n    void* InsertPos;\n\n    const ListTy* TailImpl = Tail.getInternalPointer();\n    ListTy::Profile(ID, Head, TailImpl);\n    ListTy* L = Cache.FindNodeOrInsertPos(ID, InsertPos);\n\n    if (!L) {\n      // The list does not exist in our cache.  Create it.\n      BumpPtrAllocator& A = getAllocator();\n      L = (ListTy*) A.Allocate<ListTy>();\n      new (L) ListTy(std::forward<ElemT>(Head), TailImpl);\n\n      // Insert the new list into the cache.\n      Cache.InsertNode(L, InsertPos);\n    }\n\n    return L;\n  }\n\n  template <typename ElemT>\n  LLVM_NODISCARD ImmutableList<T> add(ElemT &&Data, ImmutableList<T> L) {\n    return concat(std::forward<ElemT>(Data), L);\n  }\n\n  template <typename ...CtorArgs>\n  LLVM_NODISCARD ImmutableList<T> emplace(ImmutableList<T> Tail,\n                                          CtorArgs &&...Args) {\n    return concat(T(std::forward<CtorArgs>(Args)...), Tail);\n  }\n\n  ImmutableList<T> getEmptyList() const {\n    return ImmutableList<T>(nullptr);\n  }\n\n  template <typename ElemT>\n  ImmutableList<T> create(ElemT &&Data) {\n    return concat(std::forward<ElemT>(Data), getEmptyList());\n  }\n};\n\n//===----------------------------------------------------------------------===//\n// Partially-specialized Traits.\n//===----------------------------------------------------------------------===//\n\ntemplate<typename T> struct DenseMapInfo;\ntemplate<typename T> struct DenseMapInfo<ImmutableList<T>> {\n  static inline ImmutableList<T> getEmptyKey() {\n    return reinterpret_cast<ImmutableListImpl<T>*>(-1);\n  }\n\n  static inline ImmutableList<T> getTombstoneKey() {\n    return reinterpret_cast<ImmutableListImpl<T>*>(-2);\n  }\n\n  static unsigned getHashValue(ImmutableList<T> X) {\n    uintptr_t PtrVal = reinterpret_cast<uintptr_t>(X.getInternalPointer());\n    return (unsigned((uintptr_t)PtrVal) >> 4) ^\n           (unsigned((uintptr_t)PtrVal) >> 9);\n  }\n\n  static bool isEqual(ImmutableList<T> X1, ImmutableList<T> X2) {\n    return X1 == X2;\n  }\n};\n\n} // end namespace llvm\n\n#endif // LLVM_ADT_IMMUTABLELIST_H\n"}, "39": {"id": 39, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/ImmutableMap.h", "content": "//===--- ImmutableMap.h - Immutable (functional) map interface --*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file defines the ImmutableMap class.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_ADT_IMMUTABLEMAP_H\n#define LLVM_ADT_IMMUTABLEMAP_H\n\n#include \"llvm/ADT/FoldingSet.h\"\n#include \"llvm/ADT/ImmutableSet.h\"\n#include \"llvm/Support/Allocator.h\"\n#include <utility>\n\nnamespace llvm {\n\n/// ImutKeyValueInfo -Traits class used by ImmutableMap.  While both the first\n/// and second elements in a pair are used to generate profile information,\n/// only the first element (the key) is used by isEqual and isLess.\ntemplate <typename T, typename S>\nstruct ImutKeyValueInfo {\n  using value_type = const std::pair<T,S>;\n  using value_type_ref = const value_type&;\n  using key_type = const T;\n  using key_type_ref = const T&;\n  using data_type = const S;\n  using data_type_ref = const S&;\n\n  static inline key_type_ref KeyOfValue(value_type_ref V) {\n    return V.first;\n  }\n\n  static inline data_type_ref DataOfValue(value_type_ref V) {\n    return V.second;\n  }\n\n  static inline bool isEqual(key_type_ref L, key_type_ref R) {\n    return ImutContainerInfo<T>::isEqual(L,R);\n  }\n  static inline bool isLess(key_type_ref L, key_type_ref R) {\n    return ImutContainerInfo<T>::isLess(L,R);\n  }\n\n  static inline bool isDataEqual(data_type_ref L, data_type_ref R) {\n    return ImutContainerInfo<S>::isEqual(L,R);\n  }\n\n  static inline void Profile(FoldingSetNodeID& ID, value_type_ref V) {\n    ImutContainerInfo<T>::Profile(ID, V.first);\n    ImutContainerInfo<S>::Profile(ID, V.second);\n  }\n};\n\ntemplate <typename KeyT, typename ValT,\n          typename ValInfo = ImutKeyValueInfo<KeyT,ValT>>\nclass ImmutableMap {\npublic:\n  using value_type = typename ValInfo::value_type;\n  using value_type_ref = typename ValInfo::value_type_ref;\n  using key_type = typename ValInfo::key_type;\n  using key_type_ref = typename ValInfo::key_type_ref;\n  using data_type = typename ValInfo::data_type;\n  using data_type_ref = typename ValInfo::data_type_ref;\n  using TreeTy = ImutAVLTree<ValInfo>;\n\nprotected:\n  IntrusiveRefCntPtr<TreeTy> Root;\n\npublic:\n  /// Constructs a map from a pointer to a tree root.  In general one\n  /// should use a Factory object to create maps instead of directly\n  /// invoking the constructor, but there are cases where make this\n  /// constructor public is useful.\n  explicit ImmutableMap(const TreeTy *R) : Root(const_cast<TreeTy *>(R)) {}\n\n  class Factory {\n    typename TreeTy::Factory F;\n    const bool Canonicalize;\n\n  public:\n    Factory(bool canonicalize = true) : Canonicalize(canonicalize) {}\n\n    Factory(BumpPtrAllocator &Alloc, bool canonicalize = true)\n        : F(Alloc), Canonicalize(canonicalize) {}\n\n    Factory(const Factory &) = delete;\n    Factory &operator=(const Factory &) = delete;\n\n    ImmutableMap getEmptyMap() { return ImmutableMap(F.getEmptyTree()); }\n\n    LLVM_NODISCARD ImmutableMap add(ImmutableMap Old, key_type_ref K,\n                                    data_type_ref D) {\n      TreeTy *T = F.add(Old.Root.get(), std::pair<key_type, data_type>(K, D));\n      return ImmutableMap(Canonicalize ? F.getCanonicalTree(T): T);\n    }\n\n    LLVM_NODISCARD ImmutableMap remove(ImmutableMap Old, key_type_ref K) {\n      TreeTy *T = F.remove(Old.Root.get(), K);\n      return ImmutableMap(Canonicalize ? F.getCanonicalTree(T): T);\n    }\n\n    typename TreeTy::Factory *getTreeFactory() const {\n      return const_cast<typename TreeTy::Factory *>(&F);\n    }\n  };\n\n  bool contains(key_type_ref K) const {\n    return Root ? Root->contains(K) : false;\n  }\n\n  bool operator==(const ImmutableMap &RHS) const {\n    return Root && RHS.Root ? Root->isEqual(*RHS.Root.get()) : Root == RHS.Root;\n  }\n\n  bool operator!=(const ImmutableMap &RHS) const {\n    return Root && RHS.Root ? Root->isNotEqual(*RHS.Root.get())\n                            : Root != RHS.Root;\n  }\n\n  TreeTy *getRoot() const {\n    if (Root) { Root->retain(); }\n    return Root.get();\n  }\n\n  TreeTy *getRootWithoutRetain() const { return Root.get(); }\n\n  void manualRetain() {\n    if (Root) Root->retain();\n  }\n\n  void manualRelease() {\n    if (Root) Root->release();\n  }\n\n  bool isEmpty() const { return !Root; }\n\n  //===--------------------------------------------------===//\n  // Foreach - A limited form of map iteration.\n  //===--------------------------------------------------===//\n\nprivate:\n  template <typename Callback>\n  struct CBWrapper {\n    Callback C;\n\n    void operator()(value_type_ref V) { C(V.first,V.second); }\n  };\n\n  template <typename Callback>\n  struct CBWrapperRef {\n    Callback &C;\n\n    CBWrapperRef(Callback& c) : C(c) {}\n\n    void operator()(value_type_ref V) { C(V.first,V.second); }\n  };\n\npublic:\n  template <typename Callback>\n  void foreach(Callback& C) {\n    if (Root) {\n      CBWrapperRef<Callback> CB(C);\n      Root->foreach(CB);\n    }\n  }\n\n  template <typename Callback>\n  void foreach() {\n    if (Root) {\n      CBWrapper<Callback> CB;\n      Root->foreach(CB);\n    }\n  }\n\n  //===--------------------------------------------------===//\n  // For testing.\n  //===--------------------------------------------------===//\n\n  void verify() const { if (Root) Root->verify(); }\n\n  //===--------------------------------------------------===//\n  // Iterators.\n  //===--------------------------------------------------===//\n\n  class iterator : public ImutAVLValueIterator<ImmutableMap> {\n    friend class ImmutableMap;\n\n    iterator() = default;\n    explicit iterator(TreeTy *Tree) : iterator::ImutAVLValueIterator(Tree) {}\n\n  public:\n    key_type_ref getKey() const { return (*this)->first; }\n    data_type_ref getData() const { return (*this)->second; }\n  };\n\n  iterator begin() const { return iterator(Root.get()); }\n  iterator end() const { return iterator(); }\n\n  data_type* lookup(key_type_ref K) const {\n    if (Root) {\n      TreeTy* T = Root->find(K);\n      if (T) return &T->getValue().second;\n    }\n\n    return nullptr;\n  }\n\n  /// getMaxElement - Returns the <key,value> pair in the ImmutableMap for\n  ///  which key is the highest in the ordering of keys in the map.  This\n  ///  method returns NULL if the map is empty.\n  value_type* getMaxElement() const {\n    return Root ? &(Root->getMaxElement()->getValue()) : nullptr;\n  }\n\n  //===--------------------------------------------------===//\n  // Utility methods.\n  //===--------------------------------------------------===//\n\n  unsigned getHeight() const { return Root ? Root->getHeight() : 0; }\n\n  static inline void Profile(FoldingSetNodeID& ID, const ImmutableMap& M) {\n    ID.AddPointer(M.Root.get());\n  }\n\n  inline void Profile(FoldingSetNodeID& ID) const {\n    return Profile(ID,*this);\n  }\n};\n\n// NOTE: This will possibly become the new implementation of ImmutableMap some day.\ntemplate <typename KeyT, typename ValT,\ntypename ValInfo = ImutKeyValueInfo<KeyT,ValT>>\nclass ImmutableMapRef {\npublic:\n  using value_type = typename ValInfo::value_type;\n  using value_type_ref = typename ValInfo::value_type_ref;\n  using key_type = typename ValInfo::key_type;\n  using key_type_ref = typename ValInfo::key_type_ref;\n  using data_type = typename ValInfo::data_type;\n  using data_type_ref = typename ValInfo::data_type_ref;\n  using TreeTy = ImutAVLTree<ValInfo>;\n  using FactoryTy = typename TreeTy::Factory;\n\nprotected:\n  IntrusiveRefCntPtr<TreeTy> Root;\n  FactoryTy *Factory;\n\npublic:\n  /// Constructs a map from a pointer to a tree root.  In general one\n  /// should use a Factory object to create maps instead of directly\n  /// invoking the constructor, but there are cases where make this\n  /// constructor public is useful.\n  ImmutableMapRef(const TreeTy *R, FactoryTy *F)\n      : Root(const_cast<TreeTy *>(R)), Factory(F) {}\n\n  ImmutableMapRef(const ImmutableMap<KeyT, ValT> &X,\n                  typename ImmutableMap<KeyT, ValT>::Factory &F)\n      : Root(X.getRootWithoutRetain()), Factory(F.getTreeFactory()) {}\n\n  static inline ImmutableMapRef getEmptyMap(FactoryTy *F) {\n    return ImmutableMapRef(0, F);\n  }\n\n  void manualRetain() {\n    if (Root) Root->retain();\n  }\n\n  void manualRelease() {\n    if (Root) Root->release();\n  }\n\n  ImmutableMapRef add(key_type_ref K, data_type_ref D) const {\n    TreeTy *NewT =\n        Factory->add(Root.get(), std::pair<key_type, data_type>(K, D));\n    return ImmutableMapRef(NewT, Factory);\n  }\n\n  ImmutableMapRef remove(key_type_ref K) const {\n    TreeTy *NewT = Factory->remove(Root.get(), K);\n    return ImmutableMapRef(NewT, Factory);\n  }\n\n  bool contains(key_type_ref K) const {\n    return Root ? Root->contains(K) : false;\n  }\n\n  ImmutableMap<KeyT, ValT> asImmutableMap() const {\n    return ImmutableMap<KeyT, ValT>(Factory->getCanonicalTree(Root.get()));\n  }\n\n  bool operator==(const ImmutableMapRef &RHS) const {\n    return Root && RHS.Root ? Root->isEqual(*RHS.Root.get()) : Root == RHS.Root;\n  }\n\n  bool operator!=(const ImmutableMapRef &RHS) const {\n    return Root && RHS.Root ? Root->isNotEqual(*RHS.Root.get())\n                            : Root != RHS.Root;\n  }\n\n  bool isEmpty() const { return !Root; }\n\n  //===--------------------------------------------------===//\n  // For testing.\n  //===--------------------------------------------------===//\n\n  void verify() const {\n    if (Root)\n      Root->verify();\n  }\n\n  //===--------------------------------------------------===//\n  // Iterators.\n  //===--------------------------------------------------===//\n\n  class iterator : public ImutAVLValueIterator<ImmutableMapRef> {\n    friend class ImmutableMapRef;\n\n    iterator() = default;\n    explicit iterator(TreeTy *Tree) : iterator::ImutAVLValueIterator(Tree) {}\n\n  public:\n    key_type_ref getKey() const { return (*this)->first; }\n    data_type_ref getData() const { return (*this)->second; }\n  };\n\n  iterator begin() const { return iterator(Root.get()); }\n  iterator end() const { return iterator(); }\n\n  data_type *lookup(key_type_ref K) const {\n    if (Root) {\n      TreeTy* T = Root->find(K);\n      if (T) return &T->getValue().second;\n    }\n\n    return nullptr;\n  }\n\n  /// getMaxElement - Returns the <key,value> pair in the ImmutableMap for\n  ///  which key is the highest in the ordering of keys in the map.  This\n  ///  method returns NULL if the map is empty.\n  value_type* getMaxElement() const {\n    return Root ? &(Root->getMaxElement()->getValue()) : 0;\n  }\n\n  //===--------------------------------------------------===//\n  // Utility methods.\n  //===--------------------------------------------------===//\n\n  unsigned getHeight() const { return Root ? Root->getHeight() : 0; }\n\n  static inline void Profile(FoldingSetNodeID &ID, const ImmutableMapRef &M) {\n    ID.AddPointer(M.Root.get());\n  }\n\n  inline void Profile(FoldingSetNodeID &ID) const { return Profile(ID, *this); }\n};\n\n} // end namespace llvm\n\n#endif // LLVM_ADT_IMMUTABLEMAP_H\n"}, "40": {"id": 40, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/ImmutableSet.h", "content": "//===--- ImmutableSet.h - Immutable (functional) set interface --*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file defines the ImutAVLTree and ImmutableSet classes.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_ADT_IMMUTABLESET_H\n#define LLVM_ADT_IMMUTABLESET_H\n\n#include \"llvm/ADT/DenseMap.h\"\n#include \"llvm/ADT/FoldingSet.h\"\n#include \"llvm/ADT/IntrusiveRefCntPtr.h\"\n#include \"llvm/ADT/SmallVector.h\"\n#include \"llvm/ADT/iterator.h\"\n#include \"llvm/Support/Allocator.h\"\n#include \"llvm/Support/ErrorHandling.h\"\n#include <cassert>\n#include <cstdint>\n#include <functional>\n#include <iterator>\n#include <new>\n#include <vector>\n\nnamespace llvm {\n\n//===----------------------------------------------------------------------===//\n// Immutable AVL-Tree Definition.\n//===----------------------------------------------------------------------===//\n\ntemplate <typename ImutInfo> class ImutAVLFactory;\ntemplate <typename ImutInfo> class ImutIntervalAVLFactory;\ntemplate <typename ImutInfo> class ImutAVLTreeInOrderIterator;\ntemplate <typename ImutInfo> class ImutAVLTreeGenericIterator;\n\ntemplate <typename ImutInfo >\nclass ImutAVLTree {\npublic:\n  using key_type_ref = typename ImutInfo::key_type_ref;\n  using value_type = typename ImutInfo::value_type;\n  using value_type_ref = typename ImutInfo::value_type_ref;\n  using Factory = ImutAVLFactory<ImutInfo>;\n  using iterator = ImutAVLTreeInOrderIterator<ImutInfo>;\n\n  friend class ImutAVLFactory<ImutInfo>;\n  friend class ImutIntervalAVLFactory<ImutInfo>;\n  friend class ImutAVLTreeGenericIterator<ImutInfo>;\n\n  //===----------------------------------------------------===//\n  // Public Interface.\n  //===----------------------------------------------------===//\n\n  /// Return a pointer to the left subtree.  This value\n  ///  is NULL if there is no left subtree.\n  ImutAVLTree *getLeft() const { return left; }\n\n  /// Return a pointer to the right subtree.  This value is\n  ///  NULL if there is no right subtree.\n  ImutAVLTree *getRight() const { return right; }\n\n  /// getHeight - Returns the height of the tree.  A tree with no subtrees\n  ///  has a height of 1.\n  unsigned getHeight() const { return height; }\n\n  /// getValue - Returns the data value associated with the tree node.\n  const value_type& getValue() const { return value; }\n\n  /// find - Finds the subtree associated with the specified key value.\n  ///  This method returns NULL if no matching subtree is found.\n  ImutAVLTree* find(key_type_ref K) {\n    ImutAVLTree *T = this;\n    while (T) {\n      key_type_ref CurrentKey = ImutInfo::KeyOfValue(T->getValue());\n      if (ImutInfo::isEqual(K,CurrentKey))\n        return T;\n      else if (ImutInfo::isLess(K,CurrentKey))\n        T = T->getLeft();\n      else\n        T = T->getRight();\n    }\n    return nullptr;\n  }\n\n  /// getMaxElement - Find the subtree associated with the highest ranged\n  ///  key value.\n  ImutAVLTree* getMaxElement() {\n    ImutAVLTree *T = this;\n    ImutAVLTree *Right = T->getRight();\n    while (Right) { T = Right; Right = T->getRight(); }\n    return T;\n  }\n\n  /// size - Returns the number of nodes in the tree, which includes\n  ///  both leaves and non-leaf nodes.\n  unsigned size() const {\n    unsigned n = 1;\n    if (const ImutAVLTree* L = getLeft())\n      n += L->size();\n    if (const ImutAVLTree* R = getRight())\n      n += R->size();\n    return n;\n  }\n\n  /// begin - Returns an iterator that iterates over the nodes of the tree\n  ///  in an inorder traversal.  The returned iterator thus refers to the\n  ///  the tree node with the minimum data element.\n  iterator begin() const { return iterator(this); }\n\n  /// end - Returns an iterator for the tree that denotes the end of an\n  ///  inorder traversal.\n  iterator end() const { return iterator(); }\n\n  bool isElementEqual(value_type_ref V) const {\n    // Compare the keys.\n    if (!ImutInfo::isEqual(ImutInfo::KeyOfValue(getValue()),\n                           ImutInfo::KeyOfValue(V)))\n      return false;\n\n    // Also compare the data values.\n    if (!ImutInfo::isDataEqual(ImutInfo::DataOfValue(getValue()),\n                               ImutInfo::DataOfValue(V)))\n      return false;\n\n    return true;\n  }\n\n  bool isElementEqual(const ImutAVLTree* RHS) const {\n    return isElementEqual(RHS->getValue());\n  }\n\n  /// isEqual - Compares two trees for structural equality and returns true\n  ///   if they are equal.  This worst case performance of this operation is\n  //    linear in the sizes of the trees.\n  bool isEqual(const ImutAVLTree& RHS) const {\n    if (&RHS == this)\n      return true;\n\n    iterator LItr = begin(), LEnd = end();\n    iterator RItr = RHS.begin(), REnd = RHS.end();\n\n    while (LItr != LEnd && RItr != REnd) {\n      if (&*LItr == &*RItr) {\n        LItr.skipSubTree();\n        RItr.skipSubTree();\n        continue;\n      }\n\n      if (!LItr->isElementEqual(&*RItr))\n        return false;\n\n      ++LItr;\n      ++RItr;\n    }\n\n    return LItr == LEnd && RItr == REnd;\n  }\n\n  /// isNotEqual - Compares two trees for structural inequality.  Performance\n  ///  is the same is isEqual.\n  bool isNotEqual(const ImutAVLTree& RHS) const { return !isEqual(RHS); }\n\n  /// contains - Returns true if this tree contains a subtree (node) that\n  ///  has an data element that matches the specified key.  Complexity\n  ///  is logarithmic in the size of the tree.\n  bool contains(key_type_ref K) { return (bool) find(K); }\n\n  /// foreach - A member template the accepts invokes operator() on a functor\n  ///  object (specified by Callback) for every node/subtree in the tree.\n  ///  Nodes are visited using an inorder traversal.\n  template <typename Callback>\n  void foreach(Callback& C) {\n    if (ImutAVLTree* L = getLeft())\n      L->foreach(C);\n\n    C(value);\n\n    if (ImutAVLTree* R = getRight())\n      R->foreach(C);\n  }\n\n  /// validateTree - A utility method that checks that the balancing and\n  ///  ordering invariants of the tree are satisfied.  It is a recursive\n  ///  method that returns the height of the tree, which is then consumed\n  ///  by the enclosing validateTree call.  External callers should ignore the\n  ///  return value.  An invalid tree will cause an assertion to fire in\n  ///  a debug build.\n  unsigned validateTree() const {\n    unsigned HL = getLeft() ? getLeft()->validateTree() : 0;\n    unsigned HR = getRight() ? getRight()->validateTree() : 0;\n    (void) HL;\n    (void) HR;\n\n    assert(getHeight() == ( HL > HR ? HL : HR ) + 1\n            && \"Height calculation wrong\");\n\n    assert((HL > HR ? HL-HR : HR-HL) <= 2\n           && \"Balancing invariant violated\");\n\n    assert((!getLeft() ||\n            ImutInfo::isLess(ImutInfo::KeyOfValue(getLeft()->getValue()),\n                             ImutInfo::KeyOfValue(getValue()))) &&\n           \"Value in left child is not less that current value\");\n\n    assert((!getRight() ||\n             ImutInfo::isLess(ImutInfo::KeyOfValue(getValue()),\n                              ImutInfo::KeyOfValue(getRight()->getValue()))) &&\n           \"Current value is not less that value of right child\");\n\n    return getHeight();\n  }\n\n  //===----------------------------------------------------===//\n  // Internal values.\n  //===----------------------------------------------------===//\n\nprivate:\n  Factory *factory;\n  ImutAVLTree *left;\n  ImutAVLTree *right;\n  ImutAVLTree *prev = nullptr;\n  ImutAVLTree *next = nullptr;\n\n  unsigned height : 28;\n  bool IsMutable : 1;\n  bool IsDigestCached : 1;\n  bool IsCanonicalized : 1;\n\n  value_type value;\n  uint32_t digest = 0;\n  uint32_t refCount = 0;\n\n  //===----------------------------------------------------===//\n  // Internal methods (node manipulation; used by Factory).\n  //===----------------------------------------------------===//\n\nprivate:\n  /// ImutAVLTree - Internal constructor that is only called by\n  ///   ImutAVLFactory.\n  ImutAVLTree(Factory *f, ImutAVLTree* l, ImutAVLTree* r, value_type_ref v,\n              unsigned height)\n    : factory(f), left(l), right(r), height(height), IsMutable(true),\n      IsDigestCached(false), IsCanonicalized(false), value(v)\n  {\n    if (left) left->retain();\n    if (right) right->retain();\n  }\n\n  /// isMutable - Returns true if the left and right subtree references\n  ///  (as well as height) can be changed.  If this method returns false,\n  ///  the tree is truly immutable.  Trees returned from an ImutAVLFactory\n  ///  object should always have this method return true.  Further, if this\n  ///  method returns false for an instance of ImutAVLTree, all subtrees\n  ///  will also have this method return false.  The converse is not true.\n  bool isMutable() const { return IsMutable; }\n\n  /// hasCachedDigest - Returns true if the digest for this tree is cached.\n  ///  This can only be true if the tree is immutable.\n  bool hasCachedDigest() const { return IsDigestCached; }\n\n  //===----------------------------------------------------===//\n  // Mutating operations.  A tree root can be manipulated as\n  // long as its reference has not \"escaped\" from internal\n  // methods of a factory object (see below).  When a tree\n  // pointer is externally viewable by client code, the\n  // internal \"mutable bit\" is cleared to mark the tree\n  // immutable.  Note that a tree that still has its mutable\n  // bit set may have children (subtrees) that are themselves\n  // immutable.\n  //===----------------------------------------------------===//\n\n  /// markImmutable - Clears the mutable flag for a tree.  After this happens,\n  ///   it is an error to call setLeft(), setRight(), and setHeight().\n  void markImmutable() {\n    assert(isMutable() && \"Mutable flag already removed.\");\n    IsMutable = false;\n  }\n\n  /// markedCachedDigest - Clears the NoCachedDigest flag for a tree.\n  void markedCachedDigest() {\n    assert(!hasCachedDigest() && \"NoCachedDigest flag already removed.\");\n    IsDigestCached = true;\n  }\n\n  /// setHeight - Changes the height of the tree.  Used internally by\n  ///  ImutAVLFactory.\n  void setHeight(unsigned h) {\n    assert(isMutable() && \"Only a mutable tree can have its height changed.\");\n    height = h;\n  }\n\n  static uint32_t computeDigest(ImutAVLTree *L, ImutAVLTree *R,\n                                value_type_ref V) {\n    uint32_t digest = 0;\n\n    if (L)\n      digest += L->computeDigest();\n\n    // Compute digest of stored data.\n    FoldingSetNodeID ID;\n    ImutInfo::Profile(ID,V);\n    digest += ID.ComputeHash();\n\n    if (R)\n      digest += R->computeDigest();\n\n    return digest;\n  }\n\n  uint32_t computeDigest() {\n    // Check the lowest bit to determine if digest has actually been\n    // pre-computed.\n    if (hasCachedDigest())\n      return digest;\n\n    uint32_t X = computeDigest(getLeft(), getRight(), getValue());\n    digest = X;\n    markedCachedDigest();\n    return X;\n  }\n\n  //===----------------------------------------------------===//\n  // Reference count operations.\n  //===----------------------------------------------------===//\n\npublic:\n  void retain() { ++refCount; }\n\n  void release() {\n    assert(refCount > 0);\n    if (--refCount == 0)\n      destroy();\n  }\n\n  void destroy() {\n    if (left)\n      left->release();\n    if (right)\n      right->release();\n    if (IsCanonicalized) {\n      if (next)\n        next->prev = prev;\n\n      if (prev)\n        prev->next = next;\n      else\n        factory->Cache[factory->maskCacheIndex(computeDigest())] = next;\n    }\n\n    // We need to clear the mutability bit in case we are\n    // destroying the node as part of a sweep in ImutAVLFactory::recoverNodes().\n    IsMutable = false;\n    factory->freeNodes.push_back(this);\n  }\n};\n\ntemplate <typename ImutInfo>\nstruct IntrusiveRefCntPtrInfo<ImutAVLTree<ImutInfo>> {\n  static void retain(ImutAVLTree<ImutInfo> *Tree) { Tree->retain(); }\n  static void release(ImutAVLTree<ImutInfo> *Tree) { Tree->release(); }\n};\n\n//===----------------------------------------------------------------------===//\n// Immutable AVL-Tree Factory class.\n//===----------------------------------------------------------------------===//\n\ntemplate <typename ImutInfo >\nclass ImutAVLFactory {\n  friend class ImutAVLTree<ImutInfo>;\n\n  using TreeTy = ImutAVLTree<ImutInfo>;\n  using value_type_ref = typename TreeTy::value_type_ref;\n  using key_type_ref = typename TreeTy::key_type_ref;\n  using CacheTy = DenseMap<unsigned, TreeTy*>;\n\n  CacheTy Cache;\n  uintptr_t Allocator;\n  std::vector<TreeTy*> createdNodes;\n  std::vector<TreeTy*> freeNodes;\n\n  bool ownsAllocator() const {\n    return (Allocator & 0x1) == 0;\n  }\n\n  BumpPtrAllocator& getAllocator() const {\n    return *reinterpret_cast<BumpPtrAllocator*>(Allocator & ~0x1);\n  }\n\n  //===--------------------------------------------------===//\n  // Public interface.\n  //===--------------------------------------------------===//\n\npublic:\n  ImutAVLFactory()\n    : Allocator(reinterpret_cast<uintptr_t>(new BumpPtrAllocator())) {}\n\n  ImutAVLFactory(BumpPtrAllocator& Alloc)\n    : Allocator(reinterpret_cast<uintptr_t>(&Alloc) | 0x1) {}\n\n  ~ImutAVLFactory() {\n    if (ownsAllocator()) delete &getAllocator();\n  }\n\n  TreeTy* add(TreeTy* T, value_type_ref V) {\n    T = add_internal(V,T);\n    markImmutable(T);\n    recoverNodes();\n    return T;\n  }\n\n  TreeTy* remove(TreeTy* T, key_type_ref V) {\n    T = remove_internal(V,T);\n    markImmutable(T);\n    recoverNodes();\n    return T;\n  }\n\n  TreeTy* getEmptyTree() const { return nullptr; }\n\nprotected:\n  //===--------------------------------------------------===//\n  // A bunch of quick helper functions used for reasoning\n  // about the properties of trees and their children.\n  // These have succinct names so that the balancing code\n  // is as terse (and readable) as possible.\n  //===--------------------------------------------------===//\n\n  bool            isEmpty(TreeTy* T) const { return !T; }\n  unsigned        getHeight(TreeTy* T) const { return T ? T->getHeight() : 0; }\n  TreeTy*         getLeft(TreeTy* T) const { return T->getLeft(); }\n  TreeTy*         getRight(TreeTy* T) const { return T->getRight(); }\n  value_type_ref  getValue(TreeTy* T) const { return T->value; }\n\n  // Make sure the index is not the Tombstone or Entry key of the DenseMap.\n  static unsigned maskCacheIndex(unsigned I) { return (I & ~0x02); }\n\n  unsigned incrementHeight(TreeTy* L, TreeTy* R) const {\n    unsigned hl = getHeight(L);\n    unsigned hr = getHeight(R);\n    return (hl > hr ? hl : hr) + 1;\n  }\n\n  static bool compareTreeWithSection(TreeTy* T,\n                                     typename TreeTy::iterator& TI,\n                                     typename TreeTy::iterator& TE) {\n    typename TreeTy::iterator I = T->begin(), E = T->end();\n    for ( ; I!=E ; ++I, ++TI) {\n      if (TI == TE || !I->isElementEqual(&*TI))\n        return false;\n    }\n    return true;\n  }\n\n  //===--------------------------------------------------===//\n  // \"createNode\" is used to generate new tree roots that link\n  // to other trees.  The function may also simply move links\n  // in an existing root if that root is still marked mutable.\n  // This is necessary because otherwise our balancing code\n  // would leak memory as it would create nodes that are\n  // then discarded later before the finished tree is\n  // returned to the caller.\n  //===--------------------------------------------------===//\n\n  TreeTy* createNode(TreeTy* L, value_type_ref V, TreeTy* R) {\n    BumpPtrAllocator& A = getAllocator();\n    TreeTy* T;\n    if (!freeNodes.empty()) {\n      T = freeNodes.back();\n      freeNodes.pop_back();\n      assert(T != L);\n      assert(T != R);\n    } else {\n      T = (TreeTy*) A.Allocate<TreeTy>();\n    }\n    new (T) TreeTy(this, L, R, V, incrementHeight(L,R));\n    createdNodes.push_back(T);\n    return T;\n  }\n\n  TreeTy* createNode(TreeTy* newLeft, TreeTy* oldTree, TreeTy* newRight) {\n    return createNode(newLeft, getValue(oldTree), newRight);\n  }\n\n  void recoverNodes() {\n    for (unsigned i = 0, n = createdNodes.size(); i < n; ++i) {\n      TreeTy *N = createdNodes[i];\n      if (N->isMutable() && N->refCount == 0)\n        N->destroy();\n    }\n    createdNodes.clear();\n  }\n\n  /// balanceTree - Used by add_internal and remove_internal to\n  ///  balance a newly created tree.\n  TreeTy* balanceTree(TreeTy* L, value_type_ref V, TreeTy* R) {\n    unsigned hl = getHeight(L);\n    unsigned hr = getHeight(R);\n\n    if (hl > hr + 2) {\n      assert(!isEmpty(L) && \"Left tree cannot be empty to have a height >= 2\");\n\n      TreeTy *LL = getLeft(L);\n      TreeTy *LR = getRight(L);\n\n      if (getHeight(LL) >= getHeight(LR))\n        return createNode(LL, L, createNode(LR,V,R));\n\n      assert(!isEmpty(LR) && \"LR cannot be empty because it has a height >= 1\");\n\n      TreeTy *LRL = getLeft(LR);\n      TreeTy *LRR = getRight(LR);\n\n      return createNode(createNode(LL,L,LRL), LR, createNode(LRR,V,R));\n    }\n\n    if (hr > hl + 2) {\n      assert(!isEmpty(R) && \"Right tree cannot be empty to have a height >= 2\");\n\n      TreeTy *RL = getLeft(R);\n      TreeTy *RR = getRight(R);\n\n      if (getHeight(RR) >= getHeight(RL))\n        return createNode(createNode(L,V,RL), R, RR);\n\n      assert(!isEmpty(RL) && \"RL cannot be empty because it has a height >= 1\");\n\n      TreeTy *RLL = getLeft(RL);\n      TreeTy *RLR = getRight(RL);\n\n      return createNode(createNode(L,V,RLL), RL, createNode(RLR,R,RR));\n    }\n\n    return createNode(L,V,R);\n  }\n\n  /// add_internal - Creates a new tree that includes the specified\n  ///  data and the data from the original tree.  If the original tree\n  ///  already contained the data item, the original tree is returned.\n  TreeTy* add_internal(value_type_ref V, TreeTy* T) {\n    if (isEmpty(T))\n      return createNode(T, V, T);\n    assert(!T->isMutable());\n\n    key_type_ref K = ImutInfo::KeyOfValue(V);\n    key_type_ref KCurrent = ImutInfo::KeyOfValue(getValue(T));\n\n    if (ImutInfo::isEqual(K,KCurrent))\n      return createNode(getLeft(T), V, getRight(T));\n    else if (ImutInfo::isLess(K,KCurrent))\n      return balanceTree(add_internal(V, getLeft(T)), getValue(T), getRight(T));\n    else\n      return balanceTree(getLeft(T), getValue(T), add_internal(V, getRight(T)));\n  }\n\n  /// remove_internal - Creates a new tree that includes all the data\n  ///  from the original tree except the specified data.  If the\n  ///  specified data did not exist in the original tree, the original\n  ///  tree is returned.\n  TreeTy* remove_internal(key_type_ref K, TreeTy* T) {\n    if (isEmpty(T))\n      return T;\n\n    assert(!T->isMutable());\n\n    key_type_ref KCurrent = ImutInfo::KeyOfValue(getValue(T));\n\n    if (ImutInfo::isEqual(K,KCurrent)) {\n      return combineTrees(getLeft(T), getRight(T));\n    } else if (ImutInfo::isLess(K,KCurrent)) {\n      return balanceTree(remove_internal(K, getLeft(T)),\n                                            getValue(T), getRight(T));\n    } else {\n      return balanceTree(getLeft(T), getValue(T),\n                         remove_internal(K, getRight(T)));\n    }\n  }\n\n  TreeTy* combineTrees(TreeTy* L, TreeTy* R) {\n    if (isEmpty(L))\n      return R;\n    if (isEmpty(R))\n      return L;\n    TreeTy* OldNode;\n    TreeTy* newRight = removeMinBinding(R,OldNode);\n    return balanceTree(L, getValue(OldNode), newRight);\n  }\n\n  TreeTy* removeMinBinding(TreeTy* T, TreeTy*& Noderemoved) {\n    assert(!isEmpty(T));\n    if (isEmpty(getLeft(T))) {\n      Noderemoved = T;\n      return getRight(T);\n    }\n    return balanceTree(removeMinBinding(getLeft(T), Noderemoved),\n                       getValue(T), getRight(T));\n  }\n\n  /// markImmutable - Clears the mutable bits of a root and all of its\n  ///  descendants.\n  void markImmutable(TreeTy* T) {\n    if (!T || !T->isMutable())\n      return;\n    T->markImmutable();\n    markImmutable(getLeft(T));\n    markImmutable(getRight(T));\n  }\n\npublic:\n  TreeTy *getCanonicalTree(TreeTy *TNew) {\n    if (!TNew)\n      return nullptr;\n\n    if (TNew->IsCanonicalized)\n      return TNew;\n\n    // Search the hashtable for another tree with the same digest, and\n    // if find a collision compare those trees by their contents.\n    unsigned digest = TNew->computeDigest();\n    TreeTy *&entry = Cache[maskCacheIndex(digest)];\n    do {\n      if (!entry)\n        break;\n      for (TreeTy *T = entry ; T != nullptr; T = T->next) {\n        // Compare the Contents('T') with Contents('TNew')\n        typename TreeTy::iterator TI = T->begin(), TE = T->end();\n        if (!compareTreeWithSection(TNew, TI, TE))\n          continue;\n        if (TI != TE)\n          continue; // T has more contents than TNew.\n        // Trees did match!  Return 'T'.\n        if (TNew->refCount == 0)\n          TNew->destroy();\n        return T;\n      }\n      entry->prev = TNew;\n      TNew->next = entry;\n    }\n    while (false);\n\n    entry = TNew;\n    TNew->IsCanonicalized = true;\n    return TNew;\n  }\n};\n\n//===----------------------------------------------------------------------===//\n// Immutable AVL-Tree Iterators.\n//===----------------------------------------------------------------------===//\n\ntemplate <typename ImutInfo>\nclass ImutAVLTreeGenericIterator\n    : public std::iterator<std::bidirectional_iterator_tag,\n                           ImutAVLTree<ImutInfo>> {\n  SmallVector<uintptr_t,20> stack;\n\npublic:\n  enum VisitFlag { VisitedNone=0x0, VisitedLeft=0x1, VisitedRight=0x3,\n                   Flags=0x3 };\n\n  using TreeTy = ImutAVLTree<ImutInfo>;\n\n  ImutAVLTreeGenericIterator() = default;\n  ImutAVLTreeGenericIterator(const TreeTy *Root) {\n    if (Root) stack.push_back(reinterpret_cast<uintptr_t>(Root));\n  }\n\n  TreeTy &operator*() const {\n    assert(!stack.empty());\n    return *reinterpret_cast<TreeTy *>(stack.back() & ~Flags);\n  }\n  TreeTy *operator->() const { return &*this; }\n\n  uintptr_t getVisitState() const {\n    assert(!stack.empty());\n    return stack.back() & Flags;\n  }\n\n  bool atEnd() const { return stack.empty(); }\n\n  bool atBeginning() const {\n    return stack.size() == 1 && getVisitState() == VisitedNone;\n  }\n\n  void skipToParent() {\n    assert(!stack.empty());\n    stack.pop_back();\n    if (stack.empty())\n      return;\n    switch (getVisitState()) {\n      case VisitedNone:\n        stack.back() |= VisitedLeft;\n        break;\n      case VisitedLeft:\n        stack.back() |= VisitedRight;\n        break;\n      default:\n        llvm_unreachable(\"Unreachable.\");\n    }\n  }\n\n  bool operator==(const ImutAVLTreeGenericIterator &x) const {\n    return stack == x.stack;\n  }\n\n  bool operator!=(const ImutAVLTreeGenericIterator &x) const {\n    return !(*this == x);\n  }\n\n  ImutAVLTreeGenericIterator &operator++() {\n    assert(!stack.empty());\n    TreeTy* Current = reinterpret_cast<TreeTy*>(stack.back() & ~Flags);\n    assert(Current);\n    switch (getVisitState()) {\n      case VisitedNone:\n        if (TreeTy* L = Current->getLeft())\n          stack.push_back(reinterpret_cast<uintptr_t>(L));\n        else\n          stack.back() |= VisitedLeft;\n        break;\n      case VisitedLeft:\n        if (TreeTy* R = Current->getRight())\n          stack.push_back(reinterpret_cast<uintptr_t>(R));\n        else\n          stack.back() |= VisitedRight;\n        break;\n      case VisitedRight:\n        skipToParent();\n        break;\n      default:\n        llvm_unreachable(\"Unreachable.\");\n    }\n    return *this;\n  }\n\n  ImutAVLTreeGenericIterator &operator--() {\n    assert(!stack.empty());\n    TreeTy* Current = reinterpret_cast<TreeTy*>(stack.back() & ~Flags);\n    assert(Current);\n    switch (getVisitState()) {\n      case VisitedNone:\n        stack.pop_back();\n        break;\n      case VisitedLeft:\n        stack.back() &= ~Flags; // Set state to \"VisitedNone.\"\n        if (TreeTy* L = Current->getLeft())\n          stack.push_back(reinterpret_cast<uintptr_t>(L) | VisitedRight);\n        break;\n      case VisitedRight:\n        stack.back() &= ~Flags;\n        stack.back() |= VisitedLeft;\n        if (TreeTy* R = Current->getRight())\n          stack.push_back(reinterpret_cast<uintptr_t>(R) | VisitedRight);\n        break;\n      default:\n        llvm_unreachable(\"Unreachable.\");\n    }\n    return *this;\n  }\n};\n\ntemplate <typename ImutInfo>\nclass ImutAVLTreeInOrderIterator\n    : public std::iterator<std::bidirectional_iterator_tag,\n                           ImutAVLTree<ImutInfo>> {\n  using InternalIteratorTy = ImutAVLTreeGenericIterator<ImutInfo>;\n\n  InternalIteratorTy InternalItr;\n\npublic:\n  using TreeTy = ImutAVLTree<ImutInfo>;\n\n  ImutAVLTreeInOrderIterator(const TreeTy* Root) : InternalItr(Root) {\n    if (Root)\n      ++*this; // Advance to first element.\n  }\n\n  ImutAVLTreeInOrderIterator() : InternalItr() {}\n\n  bool operator==(const ImutAVLTreeInOrderIterator &x) const {\n    return InternalItr == x.InternalItr;\n  }\n\n  bool operator!=(const ImutAVLTreeInOrderIterator &x) const {\n    return !(*this == x);\n  }\n\n  TreeTy &operator*() const { return *InternalItr; }\n  TreeTy *operator->() const { return &*InternalItr; }\n\n  ImutAVLTreeInOrderIterator &operator++() {\n    do ++InternalItr;\n    while (!InternalItr.atEnd() &&\n           InternalItr.getVisitState() != InternalIteratorTy::VisitedLeft);\n\n    return *this;\n  }\n\n  ImutAVLTreeInOrderIterator &operator--() {\n    do --InternalItr;\n    while (!InternalItr.atBeginning() &&\n           InternalItr.getVisitState() != InternalIteratorTy::VisitedLeft);\n\n    return *this;\n  }\n\n  void skipSubTree() {\n    InternalItr.skipToParent();\n\n    while (!InternalItr.atEnd() &&\n           InternalItr.getVisitState() != InternalIteratorTy::VisitedLeft)\n      ++InternalItr;\n  }\n};\n\n/// Generic iterator that wraps a T::TreeTy::iterator and exposes\n/// iterator::getValue() on dereference.\ntemplate <typename T>\nstruct ImutAVLValueIterator\n    : iterator_adaptor_base<\n          ImutAVLValueIterator<T>, typename T::TreeTy::iterator,\n          typename std::iterator_traits<\n              typename T::TreeTy::iterator>::iterator_category,\n          const typename T::value_type> {\n  ImutAVLValueIterator() = default;\n  explicit ImutAVLValueIterator(typename T::TreeTy *Tree)\n      : ImutAVLValueIterator::iterator_adaptor_base(Tree) {}\n\n  typename ImutAVLValueIterator::reference operator*() const {\n    return this->I->getValue();\n  }\n};\n\n//===----------------------------------------------------------------------===//\n// Trait classes for Profile information.\n//===----------------------------------------------------------------------===//\n\n/// Generic profile template.  The default behavior is to invoke the\n/// profile method of an object.  Specializations for primitive integers\n/// and generic handling of pointers is done below.\ntemplate <typename T>\nstruct ImutProfileInfo {\n  using value_type = const T;\n  using value_type_ref = const T&;\n\n  static void Profile(FoldingSetNodeID &ID, value_type_ref X) {\n    FoldingSetTrait<T>::Profile(X,ID);\n  }\n};\n\n/// Profile traits for integers.\ntemplate <typename T>\nstruct ImutProfileInteger {\n  using value_type = const T;\n  using value_type_ref = const T&;\n\n  static void Profile(FoldingSetNodeID &ID, value_type_ref X) {\n    ID.AddInteger(X);\n  }\n};\n\n#define PROFILE_INTEGER_INFO(X)\\\ntemplate<> struct ImutProfileInfo<X> : ImutProfileInteger<X> {};\n\nPROFILE_INTEGER_INFO(char)\nPROFILE_INTEGER_INFO(unsigned char)\nPROFILE_INTEGER_INFO(short)\nPROFILE_INTEGER_INFO(unsigned short)\nPROFILE_INTEGER_INFO(unsigned)\nPROFILE_INTEGER_INFO(signed)\nPROFILE_INTEGER_INFO(long)\nPROFILE_INTEGER_INFO(unsigned long)\nPROFILE_INTEGER_INFO(long long)\nPROFILE_INTEGER_INFO(unsigned long long)\n\n#undef PROFILE_INTEGER_INFO\n\n/// Profile traits for booleans.\ntemplate <>\nstruct ImutProfileInfo<bool> {\n  using value_type = const bool;\n  using value_type_ref = const bool&;\n\n  static void Profile(FoldingSetNodeID &ID, value_type_ref X) {\n    ID.AddBoolean(X);\n  }\n};\n\n/// Generic profile trait for pointer types.  We treat pointers as\n/// references to unique objects.\ntemplate <typename T>\nstruct ImutProfileInfo<T*> {\n  using value_type = const T*;\n  using value_type_ref = value_type;\n\n  static void Profile(FoldingSetNodeID &ID, value_type_ref X) {\n    ID.AddPointer(X);\n  }\n};\n\n//===----------------------------------------------------------------------===//\n// Trait classes that contain element comparison operators and type\n//  definitions used by ImutAVLTree, ImmutableSet, and ImmutableMap.  These\n//  inherit from the profile traits (ImutProfileInfo) to include operations\n//  for element profiling.\n//===----------------------------------------------------------------------===//\n\n/// ImutContainerInfo - Generic definition of comparison operations for\n///   elements of immutable containers that defaults to using\n///   std::equal_to<> and std::less<> to perform comparison of elements.\ntemplate <typename T>\nstruct ImutContainerInfo : public ImutProfileInfo<T> {\n  using value_type = typename ImutProfileInfo<T>::value_type;\n  using value_type_ref = typename ImutProfileInfo<T>::value_type_ref;\n  using key_type = value_type;\n  using key_type_ref = value_type_ref;\n  using data_type = bool;\n  using data_type_ref = bool;\n\n  static key_type_ref KeyOfValue(value_type_ref D) { return D; }\n  static data_type_ref DataOfValue(value_type_ref) { return true; }\n\n  static bool isEqual(key_type_ref LHS, key_type_ref RHS) {\n    return std::equal_to<key_type>()(LHS,RHS);\n  }\n\n  static bool isLess(key_type_ref LHS, key_type_ref RHS) {\n    return std::less<key_type>()(LHS,RHS);\n  }\n\n  static bool isDataEqual(data_type_ref, data_type_ref) { return true; }\n};\n\n/// ImutContainerInfo - Specialization for pointer values to treat pointers\n///  as references to unique objects.  Pointers are thus compared by\n///  their addresses.\ntemplate <typename T>\nstruct ImutContainerInfo<T*> : public ImutProfileInfo<T*> {\n  using value_type = typename ImutProfileInfo<T*>::value_type;\n  using value_type_ref = typename ImutProfileInfo<T*>::value_type_ref;\n  using key_type = value_type;\n  using key_type_ref = value_type_ref;\n  using data_type = bool;\n  using data_type_ref = bool;\n\n  static key_type_ref KeyOfValue(value_type_ref D) { return D; }\n  static data_type_ref DataOfValue(value_type_ref) { return true; }\n\n  static bool isEqual(key_type_ref LHS, key_type_ref RHS) { return LHS == RHS; }\n\n  static bool isLess(key_type_ref LHS, key_type_ref RHS) { return LHS < RHS; }\n\n  static bool isDataEqual(data_type_ref, data_type_ref) { return true; }\n};\n\n//===----------------------------------------------------------------------===//\n// Immutable Set\n//===----------------------------------------------------------------------===//\n\ntemplate <typename ValT, typename ValInfo = ImutContainerInfo<ValT>>\nclass ImmutableSet {\npublic:\n  using value_type = typename ValInfo::value_type;\n  using value_type_ref = typename ValInfo::value_type_ref;\n  using TreeTy = ImutAVLTree<ValInfo>;\n\nprivate:\n  IntrusiveRefCntPtr<TreeTy> Root;\n\npublic:\n  /// Constructs a set from a pointer to a tree root.  In general one\n  /// should use a Factory object to create sets instead of directly\n  /// invoking the constructor, but there are cases where make this\n  /// constructor public is useful.\n  explicit ImmutableSet(TreeTy *R) : Root(R) {}\n\n  class Factory {\n    typename TreeTy::Factory F;\n    const bool Canonicalize;\n\n  public:\n    Factory(bool canonicalize = true)\n      : Canonicalize(canonicalize) {}\n\n    Factory(BumpPtrAllocator& Alloc, bool canonicalize = true)\n      : F(Alloc), Canonicalize(canonicalize) {}\n\n    Factory(const Factory& RHS) = delete;\n    void operator=(const Factory& RHS) = delete;\n\n    /// getEmptySet - Returns an immutable set that contains no elements.\n    ImmutableSet getEmptySet() {\n      return ImmutableSet(F.getEmptyTree());\n    }\n\n    /// add - Creates a new immutable set that contains all of the values\n    ///  of the original set with the addition of the specified value.  If\n    ///  the original set already included the value, then the original set is\n    ///  returned and no memory is allocated.  The time and space complexity\n    ///  of this operation is logarithmic in the size of the original set.\n    ///  The memory allocated to represent the set is released when the\n    ///  factory object that created the set is destroyed.\n    LLVM_NODISCARD ImmutableSet add(ImmutableSet Old, value_type_ref V) {\n      TreeTy *NewT = F.add(Old.Root.get(), V);\n      return ImmutableSet(Canonicalize ? F.getCanonicalTree(NewT) : NewT);\n    }\n\n    /// remove - Creates a new immutable set that contains all of the values\n    ///  of the original set with the exception of the specified value.  If\n    ///  the original set did not contain the value, the original set is\n    ///  returned and no memory is allocated.  The time and space complexity\n    ///  of this operation is logarithmic in the size of the original set.\n    ///  The memory allocated to represent the set is released when the\n    ///  factory object that created the set is destroyed.\n    LLVM_NODISCARD ImmutableSet remove(ImmutableSet Old, value_type_ref V) {\n      TreeTy *NewT = F.remove(Old.Root.get(), V);\n      return ImmutableSet(Canonicalize ? F.getCanonicalTree(NewT) : NewT);\n    }\n\n    BumpPtrAllocator& getAllocator() { return F.getAllocator(); }\n\n    typename TreeTy::Factory *getTreeFactory() const {\n      return const_cast<typename TreeTy::Factory *>(&F);\n    }\n  };\n\n  friend class Factory;\n\n  /// Returns true if the set contains the specified value.\n  bool contains(value_type_ref V) const {\n    return Root ? Root->contains(V) : false;\n  }\n\n  bool operator==(const ImmutableSet &RHS) const {\n    return Root && RHS.Root ? Root->isEqual(*RHS.Root.get()) : Root == RHS.Root;\n  }\n\n  bool operator!=(const ImmutableSet &RHS) const {\n    return Root && RHS.Root ? Root->isNotEqual(*RHS.Root.get())\n                            : Root != RHS.Root;\n  }\n\n  TreeTy *getRoot() {\n    if (Root) { Root->retain(); }\n    return Root.get();\n  }\n\n  TreeTy *getRootWithoutRetain() const { return Root.get(); }\n\n  /// isEmpty - Return true if the set contains no elements.\n  bool isEmpty() const { return !Root; }\n\n  /// isSingleton - Return true if the set contains exactly one element.\n  ///   This method runs in constant time.\n  bool isSingleton() const { return getHeight() == 1; }\n\n  template <typename Callback>\n  void foreach(Callback& C) { if (Root) Root->foreach(C); }\n\n  template <typename Callback>\n  void foreach() { if (Root) { Callback C; Root->foreach(C); } }\n\n  //===--------------------------------------------------===//\n  // Iterators.\n  //===--------------------------------------------------===//\n\n  using iterator = ImutAVLValueIterator<ImmutableSet>;\n\n  iterator begin() const { return iterator(Root.get()); }\n  iterator end() const { return iterator(); }\n\n  //===--------------------------------------------------===//\n  // Utility methods.\n  //===--------------------------------------------------===//\n\n  unsigned getHeight() const { return Root ? Root->getHeight() : 0; }\n\n  static void Profile(FoldingSetNodeID &ID, const ImmutableSet &S) {\n    ID.AddPointer(S.Root.get());\n  }\n\n  void Profile(FoldingSetNodeID &ID) const { return Profile(ID, *this); }\n\n  //===--------------------------------------------------===//\n  // For testing.\n  //===--------------------------------------------------===//\n\n  void validateTree() const { if (Root) Root->validateTree(); }\n};\n\n// NOTE: This may some day replace the current ImmutableSet.\ntemplate <typename ValT, typename ValInfo = ImutContainerInfo<ValT>>\nclass ImmutableSetRef {\npublic:\n  using value_type = typename ValInfo::value_type;\n  using value_type_ref = typename ValInfo::value_type_ref;\n  using TreeTy = ImutAVLTree<ValInfo>;\n  using FactoryTy = typename TreeTy::Factory;\n\nprivate:\n  IntrusiveRefCntPtr<TreeTy> Root;\n  FactoryTy *Factory;\n\npublic:\n  /// Constructs a set from a pointer to a tree root.  In general one\n  /// should use a Factory object to create sets instead of directly\n  /// invoking the constructor, but there are cases where make this\n  /// constructor public is useful.\n  ImmutableSetRef(TreeTy *R, FactoryTy *F) : Root(R), Factory(F) {}\n\n  static ImmutableSetRef getEmptySet(FactoryTy *F) {\n    return ImmutableSetRef(0, F);\n  }\n\n  ImmutableSetRef add(value_type_ref V) {\n    return ImmutableSetRef(Factory->add(Root.get(), V), Factory);\n  }\n\n  ImmutableSetRef remove(value_type_ref V) {\n    return ImmutableSetRef(Factory->remove(Root.get(), V), Factory);\n  }\n\n  /// Returns true if the set contains the specified value.\n  bool contains(value_type_ref V) const {\n    return Root ? Root->contains(V) : false;\n  }\n\n  ImmutableSet<ValT> asImmutableSet(bool canonicalize = true) const {\n    return ImmutableSet<ValT>(\n        canonicalize ? Factory->getCanonicalTree(Root.get()) : Root.get());\n  }\n\n  TreeTy *getRootWithoutRetain() const { return Root.get(); }\n\n  bool operator==(const ImmutableSetRef &RHS) const {\n    return Root && RHS.Root ? Root->isEqual(*RHS.Root.get()) : Root == RHS.Root;\n  }\n\n  bool operator!=(const ImmutableSetRef &RHS) const {\n    return Root && RHS.Root ? Root->isNotEqual(*RHS.Root.get())\n                            : Root != RHS.Root;\n  }\n\n  /// isEmpty - Return true if the set contains no elements.\n  bool isEmpty() const { return !Root; }\n\n  /// isSingleton - Return true if the set contains exactly one element.\n  ///   This method runs in constant time.\n  bool isSingleton() const { return getHeight() == 1; }\n\n  //===--------------------------------------------------===//\n  // Iterators.\n  //===--------------------------------------------------===//\n\n  using iterator = ImutAVLValueIterator<ImmutableSetRef>;\n\n  iterator begin() const { return iterator(Root.get()); }\n  iterator end() const { return iterator(); }\n\n  //===--------------------------------------------------===//\n  // Utility methods.\n  //===--------------------------------------------------===//\n\n  unsigned getHeight() const { return Root ? Root->getHeight() : 0; }\n\n  static void Profile(FoldingSetNodeID &ID, const ImmutableSetRef &S) {\n    ID.AddPointer(S.Root.get());\n  }\n\n  void Profile(FoldingSetNodeID &ID) const { return Profile(ID, *this); }\n\n  //===--------------------------------------------------===//\n  // For testing.\n  //===--------------------------------------------------===//\n\n  void validateTree() const { if (Root) Root->validateTree(); }\n};\n\n} // end namespace llvm\n\n#endif // LLVM_ADT_IMMUTABLESET_H\n"}, "44": {"id": 44, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/PointerUnion.h", "content": "//===- llvm/ADT/PointerUnion.h - Discriminated Union of 2 Ptrs --*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file defines the PointerUnion class, which is a discriminated union of\n// pointer types.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_ADT_POINTERUNION_H\n#define LLVM_ADT_POINTERUNION_H\n\n#include \"llvm/ADT/DenseMapInfo.h\"\n#include \"llvm/ADT/PointerIntPair.h\"\n#include \"llvm/Support/PointerLikeTypeTraits.h\"\n#include <cassert>\n#include <cstddef>\n#include <cstdint>\n\nnamespace llvm {\n\ntemplate <typename T> struct PointerUnionTypeSelectorReturn {\n  using Return = T;\n};\n\n/// Get a type based on whether two types are the same or not.\n///\n/// For:\n///\n/// \\code\n///   using Ret = typename PointerUnionTypeSelector<T1, T2, EQ, NE>::Return;\n/// \\endcode\n///\n/// Ret will be EQ type if T1 is same as T2 or NE type otherwise.\ntemplate <typename T1, typename T2, typename RET_EQ, typename RET_NE>\nstruct PointerUnionTypeSelector {\n  using Return = typename PointerUnionTypeSelectorReturn<RET_NE>::Return;\n};\n\ntemplate <typename T, typename RET_EQ, typename RET_NE>\nstruct PointerUnionTypeSelector<T, T, RET_EQ, RET_NE> {\n  using Return = typename PointerUnionTypeSelectorReturn<RET_EQ>::Return;\n};\n\ntemplate <typename T1, typename T2, typename RET_EQ, typename RET_NE>\nstruct PointerUnionTypeSelectorReturn<\n    PointerUnionTypeSelector<T1, T2, RET_EQ, RET_NE>> {\n  using Return =\n      typename PointerUnionTypeSelector<T1, T2, RET_EQ, RET_NE>::Return;\n};\n\nnamespace pointer_union_detail {\n  /// Determine the number of bits required to store integers with values < n.\n  /// This is ceil(log2(n)).\n  constexpr int bitsRequired(unsigned n) {\n    return n > 1 ? 1 + bitsRequired((n + 1) / 2) : 0;\n  }\n\n  template <typename... Ts> constexpr int lowBitsAvailable() {\n    return std::min<int>({PointerLikeTypeTraits<Ts>::NumLowBitsAvailable...});\n  }\n\n  /// Find the index of a type in a list of types. TypeIndex<T, Us...>::Index\n  /// is the index of T in Us, or sizeof...(Us) if T does not appear in the\n  /// list.\n  template <typename T, typename ...Us> struct TypeIndex;\n  template <typename T, typename ...Us> struct TypeIndex<T, T, Us...> {\n    static constexpr int Index = 0;\n  };\n  template <typename T, typename U, typename... Us>\n  struct TypeIndex<T, U, Us...> {\n    static constexpr int Index = 1 + TypeIndex<T, Us...>::Index;\n  };\n  template <typename T> struct TypeIndex<T> {\n    static constexpr int Index = 0;\n  };\n\n  /// Find the first type in a list of types.\n  template <typename T, typename...> struct GetFirstType {\n    using type = T;\n  };\n\n  /// Provide PointerLikeTypeTraits for void* that is used by PointerUnion\n  /// for the template arguments.\n  template <typename ...PTs> class PointerUnionUIntTraits {\n  public:\n    static inline void *getAsVoidPointer(void *P) { return P; }\n    static inline void *getFromVoidPointer(void *P) { return P; }\n    static constexpr int NumLowBitsAvailable = lowBitsAvailable<PTs...>();\n  };\n\n  template <typename Derived, typename ValTy, int I, typename ...Types>\n  class PointerUnionMembers;\n\n  template <typename Derived, typename ValTy, int I>\n  class PointerUnionMembers<Derived, ValTy, I> {\n  protected:\n    ValTy Val;\n    PointerUnionMembers() = default;\n    PointerUnionMembers(ValTy Val) : Val(Val) {}\n\n    friend struct PointerLikeTypeTraits<Derived>;\n  };\n\n  template <typename Derived, typename ValTy, int I, typename Type,\n            typename ...Types>\n  class PointerUnionMembers<Derived, ValTy, I, Type, Types...>\n      : public PointerUnionMembers<Derived, ValTy, I + 1, Types...> {\n    using Base = PointerUnionMembers<Derived, ValTy, I + 1, Types...>;\n  public:\n    using Base::Base;\n    PointerUnionMembers() = default;\n    PointerUnionMembers(Type V)\n        : Base(ValTy(const_cast<void *>(\n                         PointerLikeTypeTraits<Type>::getAsVoidPointer(V)),\n                     I)) {}\n\n    using Base::operator=;\n    Derived &operator=(Type V) {\n      this->Val = ValTy(\n          const_cast<void *>(PointerLikeTypeTraits<Type>::getAsVoidPointer(V)),\n          I);\n      return static_cast<Derived &>(*this);\n    };\n  };\n}\n\n/// A discriminated union of two or more pointer types, with the discriminator\n/// in the low bit of the pointer.\n///\n/// This implementation is extremely efficient in space due to leveraging the\n/// low bits of the pointer, while exposing a natural and type-safe API.\n///\n/// Common use patterns would be something like this:\n///    PointerUnion<int*, float*> P;\n///    P = (int*)0;\n///    printf(\"%d %d\", P.is<int*>(), P.is<float*>());  // prints \"1 0\"\n///    X = P.get<int*>();     // ok.\n///    Y = P.get<float*>();   // runtime assertion failure.\n///    Z = P.get<double*>();  // compile time failure.\n///    P = (float*)0;\n///    Y = P.get<float*>();   // ok.\n///    X = P.get<int*>();     // runtime assertion failure.\ntemplate <typename... PTs>\nclass PointerUnion\n    : public pointer_union_detail::PointerUnionMembers<\n          PointerUnion<PTs...>,\n          PointerIntPair<\n              void *, pointer_union_detail::bitsRequired(sizeof...(PTs)), int,\n              pointer_union_detail::PointerUnionUIntTraits<PTs...>>,\n          0, PTs...> {\n  // The first type is special because we want to directly cast a pointer to a\n  // default-initialized union to a pointer to the first type. But we don't\n  // want PointerUnion to be a 'template <typename First, typename ...Rest>'\n  // because it's much more convenient to have a name for the whole pack. So\n  // split off the first type here.\n  using First = typename pointer_union_detail::GetFirstType<PTs...>::type;\n  using Base = typename PointerUnion::PointerUnionMembers;\n\npublic:\n  PointerUnion() = default;\n\n  PointerUnion(std::nullptr_t) : PointerUnion() {}\n  using Base::Base;\n\n  /// Test if the pointer held in the union is null, regardless of\n  /// which type it is.\n  bool isNull() const { return !this->Val.getPointer(); }\n\n  explicit operator bool() const { return !isNull(); }\n\n  /// Test if the Union currently holds the type matching T.\n  template <typename T> bool is() const {\n    constexpr int Index = pointer_union_detail::TypeIndex<T, PTs...>::Index;\n    static_assert(Index < sizeof...(PTs),\n                  \"PointerUnion::is<T> given type not in the union\");\n    return this->Val.getInt() == Index;\n  }\n\n  /// Returns the value of the specified pointer type.\n  ///\n  /// If the specified pointer type is incorrect, assert.\n  template <typename T> T get() const {\n    assert(is<T>() && \"Invalid accessor called\");\n    return PointerLikeTypeTraits<T>::getFromVoidPointer(this->Val.getPointer());\n  }\n\n  /// Returns the current pointer if it is of the specified pointer type,\n  /// otherwise returns null.\n  template <typename T> T dyn_cast() const {\n    if (is<T>())\n      return get<T>();\n    return T();\n  }\n\n  /// If the union is set to the first pointer type get an address pointing to\n  /// it.\n  First const *getAddrOfPtr1() const {\n    return const_cast<PointerUnion *>(this)->getAddrOfPtr1();\n  }\n\n  /// If the union is set to the first pointer type get an address pointing to\n  /// it.\n  First *getAddrOfPtr1() {\n    assert(is<First>() && \"Val is not the first pointer\");\n    assert(\n        PointerLikeTypeTraits<First>::getAsVoidPointer(get<First>()) ==\n            this->Val.getPointer() &&\n        \"Can't get the address because PointerLikeTypeTraits changes the ptr\");\n    return const_cast<First *>(\n        reinterpret_cast<const First *>(this->Val.getAddrOfPointer()));\n  }\n\n  /// Assignment from nullptr which just clears the union.\n  const PointerUnion &operator=(std::nullptr_t) {\n    this->Val.initWithPointer(nullptr);\n    return *this;\n  }\n\n  /// Assignment from elements of the union.\n  using Base::operator=;\n\n  void *getOpaqueValue() const { return this->Val.getOpaqueValue(); }\n  static inline PointerUnion getFromOpaqueValue(void *VP) {\n    PointerUnion V;\n    V.Val = decltype(V.Val)::getFromOpaqueValue(VP);\n    return V;\n  }\n};\n\ntemplate <typename ...PTs>\nbool operator==(PointerUnion<PTs...> lhs, PointerUnion<PTs...> rhs) {\n  return lhs.getOpaqueValue() == rhs.getOpaqueValue();\n}\n\ntemplate <typename ...PTs>\nbool operator!=(PointerUnion<PTs...> lhs, PointerUnion<PTs...> rhs) {\n  return lhs.getOpaqueValue() != rhs.getOpaqueValue();\n}\n\ntemplate <typename ...PTs>\nbool operator<(PointerUnion<PTs...> lhs, PointerUnion<PTs...> rhs) {\n  return lhs.getOpaqueValue() < rhs.getOpaqueValue();\n}\n\n// Teach SmallPtrSet that PointerUnion is \"basically a pointer\", that has\n// # low bits available = min(PT1bits,PT2bits)-1.\ntemplate <typename ...PTs>\nstruct PointerLikeTypeTraits<PointerUnion<PTs...>> {\n  static inline void *getAsVoidPointer(const PointerUnion<PTs...> &P) {\n    return P.getOpaqueValue();\n  }\n\n  static inline PointerUnion<PTs...> getFromVoidPointer(void *P) {\n    return PointerUnion<PTs...>::getFromOpaqueValue(P);\n  }\n\n  // The number of bits available are the min of the pointer types minus the\n  // bits needed for the discriminator.\n  static constexpr int NumLowBitsAvailable = PointerLikeTypeTraits<decltype(\n      PointerUnion<PTs...>::Val)>::NumLowBitsAvailable;\n};\n\n// Teach DenseMap how to use PointerUnions as keys.\ntemplate <typename ...PTs> struct DenseMapInfo<PointerUnion<PTs...>> {\n  using Union = PointerUnion<PTs...>;\n  using FirstInfo =\n      DenseMapInfo<typename pointer_union_detail::GetFirstType<PTs...>::type>;\n\n  static inline Union getEmptyKey() { return Union(FirstInfo::getEmptyKey()); }\n\n  static inline Union getTombstoneKey() {\n    return Union(FirstInfo::getTombstoneKey());\n  }\n\n  static unsigned getHashValue(const Union &UnionVal) {\n    intptr_t key = (intptr_t)UnionVal.getOpaqueValue();\n    return DenseMapInfo<intptr_t>::getHashValue(key);\n  }\n\n  static bool isEqual(const Union &LHS, const Union &RHS) {\n    return LHS == RHS;\n  }\n};\n\n} // end namespace llvm\n\n#endif // LLVM_ADT_POINTERUNION_H\n"}, "52": {"id": 52, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/AtomicOrdering.h", "content": "//===-- llvm/Support/AtomicOrdering.h ---Atomic Ordering---------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n///\n/// \\file\n/// Atomic ordering constants.\n///\n/// These values are used by LLVM to represent atomic ordering for C++11's\n/// memory model and more, as detailed in docs/Atomics.rst.\n///\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_SUPPORT_ATOMICORDERING_H\n#define LLVM_SUPPORT_ATOMICORDERING_H\n\n#include <cstddef>\n\nnamespace llvm {\n\n/// Atomic ordering for C11 / C++11's memory models.\n///\n/// These values cannot change because they are shared with standard library\n/// implementations as well as with other compilers.\nenum class AtomicOrderingCABI {\n  relaxed = 0,\n  consume = 1,\n  acquire = 2,\n  release = 3,\n  acq_rel = 4,\n  seq_cst = 5,\n};\n\nbool operator<(AtomicOrderingCABI, AtomicOrderingCABI) = delete;\nbool operator>(AtomicOrderingCABI, AtomicOrderingCABI) = delete;\nbool operator<=(AtomicOrderingCABI, AtomicOrderingCABI) = delete;\nbool operator>=(AtomicOrderingCABI, AtomicOrderingCABI) = delete;\n\n// Validate an integral value which isn't known to fit within the enum's range\n// is a valid AtomicOrderingCABI.\ntemplate <typename Int> inline bool isValidAtomicOrderingCABI(Int I) {\n  return (Int)AtomicOrderingCABI::relaxed <= I &&\n         I <= (Int)AtomicOrderingCABI::seq_cst;\n}\n\n/// Atomic ordering for LLVM's memory model.\n///\n/// C++ defines ordering as a lattice. LLVM supplements this with NotAtomic and\n/// Unordered, which are both below the C++ orders.\n///\n/// not_atomic-->unordered-->relaxed-->release--------------->acq_rel-->seq_cst\n///                                   \\-->consume-->acquire--/\nenum class AtomicOrdering : unsigned {\n  NotAtomic = 0,\n  Unordered = 1,\n  Monotonic = 2, // Equivalent to C++'s relaxed.\n  // Consume = 3,  // Not specified yet.\n  Acquire = 4,\n  Release = 5,\n  AcquireRelease = 6,\n  SequentiallyConsistent = 7,\n  LAST = SequentiallyConsistent\n};\n\nbool operator<(AtomicOrdering, AtomicOrdering) = delete;\nbool operator>(AtomicOrdering, AtomicOrdering) = delete;\nbool operator<=(AtomicOrdering, AtomicOrdering) = delete;\nbool operator>=(AtomicOrdering, AtomicOrdering) = delete;\n\n// Validate an integral value which isn't known to fit within the enum's range\n// is a valid AtomicOrdering.\ntemplate <typename Int> inline bool isValidAtomicOrdering(Int I) {\n  return static_cast<Int>(AtomicOrdering::NotAtomic) <= I &&\n         I <= static_cast<Int>(AtomicOrdering::SequentiallyConsistent);\n}\n\n/// String used by LLVM IR to represent atomic ordering.\ninline const char *toIRString(AtomicOrdering ao) {\n  static const char *names[8] = {\"not_atomic\", \"unordered\", \"monotonic\",\n                                 \"consume\",    \"acquire\",   \"release\",\n                                 \"acq_rel\",    \"seq_cst\"};\n  return names[static_cast<size_t>(ao)];\n}\n\n/// Returns true if ao is stronger than other as defined by the AtomicOrdering\n/// lattice, which is based on C++'s definition.\ninline bool isStrongerThan(AtomicOrdering AO, AtomicOrdering Other) {\n  static const bool lookup[8][8] = {\n      //               NA     UN     RX     CO     AC     RE     AR     SC\n      /* NotAtomic */ {false, false, false, false, false, false, false, false},\n      /* Unordered */ { true, false, false, false, false, false, false, false},\n      /* relaxed   */ { true,  true, false, false, false, false, false, false},\n      /* consume   */ { true,  true,  true, false, false, false, false, false},\n      /* acquire   */ { true,  true,  true,  true, false, false, false, false},\n      /* release   */ { true,  true,  true, false, false, false, false, false},\n      /* acq_rel   */ { true,  true,  true,  true,  true,  true, false, false},\n      /* seq_cst   */ { true,  true,  true,  true,  true,  true,  true, false},\n  };\n  return lookup[static_cast<size_t>(AO)][static_cast<size_t>(Other)];\n}\n\ninline bool isAtLeastOrStrongerThan(AtomicOrdering AO, AtomicOrdering Other) {\n  static const bool lookup[8][8] = {\n      //               NA     UN     RX     CO     AC     RE     AR     SC\n      /* NotAtomic */ { true, false, false, false, false, false, false, false},\n      /* Unordered */ { true,  true, false, false, false, false, false, false},\n      /* relaxed   */ { true,  true,  true, false, false, false, false, false},\n      /* consume   */ { true,  true,  true,  true, false, false, false, false},\n      /* acquire   */ { true,  true,  true,  true,  true, false, false, false},\n      /* release   */ { true,  true,  true, false, false,  true, false, false},\n      /* acq_rel   */ { true,  true,  true,  true,  true,  true,  true, false},\n      /* seq_cst   */ { true,  true,  true,  true,  true,  true,  true,  true},\n  };\n  return lookup[static_cast<size_t>(AO)][static_cast<size_t>(Other)];\n}\n\ninline bool isStrongerThanUnordered(AtomicOrdering AO) {\n  return isStrongerThan(AO, AtomicOrdering::Unordered);\n}\n\ninline bool isStrongerThanMonotonic(AtomicOrdering AO) {\n  return isStrongerThan(AO, AtomicOrdering::Monotonic);\n}\n\ninline bool isAcquireOrStronger(AtomicOrdering AO) {\n  return isAtLeastOrStrongerThan(AO, AtomicOrdering::Acquire);\n}\n\ninline bool isReleaseOrStronger(AtomicOrdering AO) {\n  return isAtLeastOrStrongerThan(AO, AtomicOrdering::Release);\n}\n\ninline AtomicOrderingCABI toCABI(AtomicOrdering AO) {\n  static const AtomicOrderingCABI lookup[8] = {\n      /* NotAtomic */ AtomicOrderingCABI::relaxed,\n      /* Unordered */ AtomicOrderingCABI::relaxed,\n      /* relaxed   */ AtomicOrderingCABI::relaxed,\n      /* consume   */ AtomicOrderingCABI::consume,\n      /* acquire   */ AtomicOrderingCABI::acquire,\n      /* release   */ AtomicOrderingCABI::release,\n      /* acq_rel   */ AtomicOrderingCABI::acq_rel,\n      /* seq_cst   */ AtomicOrderingCABI::seq_cst,\n  };\n  return lookup[static_cast<size_t>(AO)];\n}\n\n} // end namespace llvm\n\n#endif // LLVM_SUPPORT_ATOMICORDERING_H\n"}, "53": {"id": 53, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/TypeSize.h", "content": "//===- TypeSize.h - Wrapper around type sizes -------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file provides a struct that can be used to query the size of IR types\n// which may be scalable vectors. It provides convenience operators so that\n// it can be used in much the same way as a single scalar value.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_SUPPORT_TYPESIZE_H\n#define LLVM_SUPPORT_TYPESIZE_H\n\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/Support/MathExtras.h\"\n#include \"llvm/Support/WithColor.h\"\n\n#include <algorithm>\n#include <array>\n#include <cassert>\n#include <cstdint>\n#include <type_traits>\n\nnamespace llvm {\n\ntemplate <typename LeafTy> struct LinearPolyBaseTypeTraits {};\n\n//===----------------------------------------------------------------------===//\n// LinearPolyBase - a base class for linear polynomials with multiple\n// dimensions. This can e.g. be used to describe offsets that are have both a\n// fixed and scalable component.\n//===----------------------------------------------------------------------===//\n\n/// LinearPolyBase describes a linear polynomial:\n///  c0 * scale0 + c1 * scale1 + ... + cK * scaleK\n/// where the scale is implicit, so only the coefficients are encoded.\ntemplate <typename LeafTy>\nclass LinearPolyBase {\npublic:\n  using ScalarTy = typename LinearPolyBaseTypeTraits<LeafTy>::ScalarTy;\n  static constexpr auto Dimensions = LinearPolyBaseTypeTraits<LeafTy>::Dimensions;\n  static_assert(Dimensions != std::numeric_limits<unsigned>::max(),\n                \"Dimensions out of range\");\n\nprivate:\n  std::array<ScalarTy, Dimensions> Coefficients;\n\nprotected:\n  LinearPolyBase(ArrayRef<ScalarTy> Values) {\n    std::copy(Values.begin(), Values.end(), Coefficients.begin());\n  }\n\npublic:\n  friend LeafTy &operator+=(LeafTy &LHS, const LeafTy &RHS) {\n    for (unsigned I=0; I<Dimensions; ++I)\n      LHS.Coefficients[I] += RHS.Coefficients[I];\n    return LHS;\n  }\n\n  friend LeafTy &operator-=(LeafTy &LHS, const LeafTy &RHS) {\n    for (unsigned I=0; I<Dimensions; ++I)\n      LHS.Coefficients[I] -= RHS.Coefficients[I];\n    return LHS;\n  }\n\n  friend LeafTy &operator*=(LeafTy &LHS, ScalarTy RHS) {\n    for (auto &C : LHS.Coefficients)\n      C *= RHS;\n    return LHS;\n  }\n\n  friend LeafTy operator+(const LeafTy &LHS, const LeafTy &RHS) {\n    LeafTy Copy = LHS;\n    return Copy += RHS;\n  }\n\n  friend LeafTy operator-(const LeafTy &LHS, const LeafTy &RHS) {\n    LeafTy Copy = LHS;\n    return Copy -= RHS;\n  }\n\n  friend LeafTy operator*(const LeafTy &LHS, ScalarTy RHS) {\n    LeafTy Copy = LHS;\n    return Copy *= RHS;\n  }\n\n  template <typename U = ScalarTy>\n  friend typename std::enable_if_t<std::is_signed<U>::value, LeafTy>\n  operator-(const LeafTy &LHS) {\n    LeafTy Copy = LHS;\n    return Copy *= -1;\n  }\n\n  bool operator==(const LinearPolyBase &RHS) const {\n    return std::equal(Coefficients.begin(), Coefficients.end(),\n                      RHS.Coefficients.begin());\n  }\n\n  bool operator!=(const LinearPolyBase &RHS) const {\n    return !(*this == RHS);\n  }\n\n  bool isZero() const {\n    return all_of(Coefficients, [](const ScalarTy &C) { return C == 0; });\n  }\n  bool isNonZero() const { return !isZero(); }\n  explicit operator bool() const { return isNonZero(); }\n\n  ScalarTy getValue(unsigned Dim) const { return Coefficients[Dim]; }\n};\n\n//===----------------------------------------------------------------------===//\n// StackOffset - Represent an offset with named fixed and scalable components.\n//===----------------------------------------------------------------------===//\n\nclass StackOffset;\ntemplate <> struct LinearPolyBaseTypeTraits<StackOffset> {\n  using ScalarTy = int64_t;\n  static constexpr unsigned Dimensions = 2;\n};\n\n/// StackOffset is a class to represent an offset with 2 dimensions,\n/// named fixed and scalable, respectively. This class allows a value for both\n/// dimensions to depict e.g. \"8 bytes and 16 scalable bytes\", which is needed\n/// to represent stack offsets.\nclass StackOffset : public LinearPolyBase<StackOffset> {\nprotected:\n  StackOffset(ScalarTy Fixed, ScalarTy Scalable)\n      : LinearPolyBase<StackOffset>({Fixed, Scalable}) {}\n\npublic:\n  StackOffset() : StackOffset({0, 0}) {}\n  StackOffset(const LinearPolyBase<StackOffset> &Other)\n      : LinearPolyBase<StackOffset>(Other) {}\n  static StackOffset getFixed(ScalarTy Fixed) { return {Fixed, 0}; }\n  static StackOffset getScalable(ScalarTy Scalable) { return {0, Scalable}; }\n  static StackOffset get(ScalarTy Fixed, ScalarTy Scalable) {\n    return {Fixed, Scalable};\n  }\n\n  ScalarTy getFixed() const { return this->getValue(0); }\n  ScalarTy getScalable() const { return this->getValue(1); }\n};\n\n//===----------------------------------------------------------------------===//\n// UnivariateLinearPolyBase - a base class for linear polynomials with multiple\n// dimensions, but where only one dimension can be set at any time.\n// This can e.g. be used to describe sizes that are either fixed or scalable.\n//===----------------------------------------------------------------------===//\n\n/// UnivariateLinearPolyBase is a base class for ElementCount and TypeSize.\n/// Like LinearPolyBase it tries to represent a linear polynomial\n/// where only one dimension can be set at any time, e.g.\n///   0 * scale0 + 0 * scale1 + ... + cJ * scaleJ + ... + 0 * scaleK\n/// The dimension that is set is the univariate dimension.\ntemplate <typename LeafTy>\nclass UnivariateLinearPolyBase {\npublic:\n  using ScalarTy = typename LinearPolyBaseTypeTraits<LeafTy>::ScalarTy;\n  static constexpr auto Dimensions = LinearPolyBaseTypeTraits<LeafTy>::Dimensions;\n  static_assert(Dimensions != std::numeric_limits<unsigned>::max(),\n                \"Dimensions out of range\");\n\nprotected:\n  ScalarTy Value;         // The value at the univeriate dimension.\n  unsigned UnivariateDim; // The univeriate dimension.\n\n  UnivariateLinearPolyBase(ScalarTy Val, unsigned UnivariateDim)\n      : Value(Val), UnivariateDim(UnivariateDim) {\n    assert(UnivariateDim < Dimensions && \"Dimension out of range\");\n  }\n\n  friend LeafTy &operator+=(LeafTy &LHS, const LeafTy &RHS) {\n    assert(LHS.UnivariateDim == RHS.UnivariateDim && \"Invalid dimensions\");\n    LHS.Value += RHS.Value;\n    return LHS;\n  }\n\n  friend LeafTy &operator-=(LeafTy &LHS, const LeafTy &RHS) {\n    assert(LHS.UnivariateDim == RHS.UnivariateDim && \"Invalid dimensions\");\n    LHS.Value -= RHS.Value;\n    return LHS;\n  }\n\n  friend LeafTy &operator*=(LeafTy &LHS, ScalarTy RHS) {\n    LHS.Value *= RHS;\n    return LHS;\n  }\n\n  friend LeafTy operator+(const LeafTy &LHS, const LeafTy &RHS) {\n    LeafTy Copy = LHS;\n    return Copy += RHS;\n  }\n\n  friend LeafTy operator-(const LeafTy &LHS, const LeafTy &RHS) {\n    LeafTy Copy = LHS;\n    return Copy -= RHS;\n  }\n\n  friend LeafTy operator*(const LeafTy &LHS, ScalarTy RHS) {\n    LeafTy Copy = LHS;\n    return Copy *= RHS;\n  }\n\n  template <typename U = ScalarTy>\n  friend typename std::enable_if<std::is_signed<U>::value, LeafTy>::type\n  operator-(const LeafTy &LHS) {\n    LeafTy Copy = LHS;\n    return Copy *= -1;\n  }\n\npublic:\n  bool operator==(const UnivariateLinearPolyBase &RHS) const {\n    return Value == RHS.Value && UnivariateDim == RHS.UnivariateDim;\n  }\n\n  bool operator!=(const UnivariateLinearPolyBase &RHS) const {\n    return !(*this == RHS);\n  }\n\n  bool isZero() const { return !Value; }\n  bool isNonZero() const { return !isZero(); }\n  explicit operator bool() const { return isNonZero(); }\n  ScalarTy getValue() const { return Value; }\n  ScalarTy getValue(unsigned Dim) const {\n    return Dim == UnivariateDim ? Value : 0;\n  }\n\n  /// Add \\p RHS to the value at the univariate dimension.\n  LeafTy getWithIncrement(ScalarTy RHS) const {\n    return static_cast<LeafTy>(\n        UnivariateLinearPolyBase(Value + RHS, UnivariateDim));\n  }\n\n  /// Subtract \\p RHS from the value at the univariate dimension.\n  LeafTy getWithDecrement(ScalarTy RHS) const {\n    return static_cast<LeafTy>(\n        UnivariateLinearPolyBase(Value - RHS, UnivariateDim));\n  }\n};\n\n\n//===----------------------------------------------------------------------===//\n// LinearPolySize - base class for fixed- or scalable sizes.\n//  ^  ^ \n//  |  |\n//  |  +----- ElementCount - Leaf class to represent an element count\n//  |                        (vscale x unsigned)\n//  |\n//  +-------- TypeSize - Leaf class to represent a type size\n//                       (vscale x uint64_t)\n//===----------------------------------------------------------------------===//\n\n/// LinearPolySize is a base class to represent sizes. It is either\n/// fixed-sized or it is scalable-sized, but it cannot be both.\ntemplate <typename LeafTy>\nclass LinearPolySize : public UnivariateLinearPolyBase<LeafTy> {\n  // Make the parent class a friend, so that it can access the protected\n  // conversion/copy-constructor for UnivariatePolyBase<LeafTy> ->\n  // LinearPolySize<LeafTy>.\n  friend class UnivariateLinearPolyBase<LeafTy>;\n\npublic:\n  using ScalarTy = typename UnivariateLinearPolyBase<LeafTy>::ScalarTy;\n  enum Dims : unsigned { FixedDim = 0, ScalableDim = 1 };\n\nprotected:\n  LinearPolySize(ScalarTy MinVal, Dims D)\n      : UnivariateLinearPolyBase<LeafTy>(MinVal, D) {}\n\n  LinearPolySize(const UnivariateLinearPolyBase<LeafTy> &V)\n      : UnivariateLinearPolyBase<LeafTy>(V) {}\n\npublic:\n\n  static LeafTy getFixed(ScalarTy MinVal) {\n    return static_cast<LeafTy>(LinearPolySize(MinVal, FixedDim));\n  }\n  static LeafTy getScalable(ScalarTy MinVal) {\n    return static_cast<LeafTy>(LinearPolySize(MinVal, ScalableDim));\n  }\n  static LeafTy get(ScalarTy MinVal, bool Scalable) {\n    return static_cast<LeafTy>(\n        LinearPolySize(MinVal, Scalable ? ScalableDim : FixedDim));\n  }\n  static LeafTy getNull() { return get(0, false); }\n\n  /// Returns the minimum value this size can represent.\n  ScalarTy getKnownMinValue() const { return this->getValue(); }\n  /// Returns whether the size is scaled by a runtime quantity (vscale).\n  bool isScalable() const { return this->UnivariateDim == ScalableDim; }\n  /// A return value of true indicates we know at compile time that the number\n  /// of elements (vscale * Min) is definitely even. However, returning false\n  /// does not guarantee that the total number of elements is odd.\n  bool isKnownEven() const { return (getKnownMinValue() & 0x1) == 0; }\n  /// This function tells the caller whether the element count is known at\n  /// compile time to be a multiple of the scalar value RHS.\n  bool isKnownMultipleOf(ScalarTy RHS) const {\n    return getKnownMinValue() % RHS == 0;\n  }\n\n  // Return the minimum value with the assumption that the count is exact.\n  // Use in places where a scalable count doesn't make sense (e.g. non-vector\n  // types, or vectors in backends which don't support scalable vectors).\n  ScalarTy getFixedValue() const {\n    assert(!isScalable() &&\n           \"Request for a fixed element count on a scalable object\");\n    return getKnownMinValue();\n  }\n\n  // For some cases, size ordering between scalable and fixed size types cannot\n  // be determined at compile time, so such comparisons aren't allowed.\n  //\n  // e.g. <vscale x 2 x i16> could be bigger than <4 x i32> with a runtime\n  // vscale >= 5, equal sized with a vscale of 4, and smaller with\n  // a vscale <= 3.\n  //\n  // All the functions below make use of the fact vscale is always >= 1, which\n  // means that <vscale x 4 x i32> is guaranteed to be >= <4 x i32>, etc.\n\n  static bool isKnownLT(const LinearPolySize &LHS, const LinearPolySize &RHS) {\n    if (!LHS.isScalable() || RHS.isScalable())\n      return LHS.getKnownMinValue() < RHS.getKnownMinValue();\n    return false;\n  }\n\n  static bool isKnownGT(const LinearPolySize &LHS, const LinearPolySize &RHS) {\n    if (LHS.isScalable() || !RHS.isScalable())\n      return LHS.getKnownMinValue() > RHS.getKnownMinValue();\n    return false;\n  }\n\n  static bool isKnownLE(const LinearPolySize &LHS, const LinearPolySize &RHS) {\n    if (!LHS.isScalable() || RHS.isScalable())\n      return LHS.getKnownMinValue() <= RHS.getKnownMinValue();\n    return false;\n  }\n\n  static bool isKnownGE(const LinearPolySize &LHS, const LinearPolySize &RHS) {\n    if (LHS.isScalable() || !RHS.isScalable())\n      return LHS.getKnownMinValue() >= RHS.getKnownMinValue();\n    return false;\n  }\n\n  /// We do not provide the '/' operator here because division for polynomial\n  /// types does not work in the same way as for normal integer types. We can\n  /// only divide the minimum value (or coefficient) by RHS, which is not the\n  /// same as\n  ///   (Min * Vscale) / RHS\n  /// The caller is recommended to use this function in combination with\n  /// isKnownMultipleOf(RHS), which lets the caller know if it's possible to\n  /// perform a lossless divide by RHS.\n  LeafTy divideCoefficientBy(ScalarTy RHS) const {\n    return static_cast<LeafTy>(\n        LinearPolySize::get(getKnownMinValue() / RHS, isScalable()));\n  }\n\n  LeafTy coefficientNextPowerOf2() const {\n    return static_cast<LeafTy>(LinearPolySize::get(\n        static_cast<ScalarTy>(llvm::NextPowerOf2(getKnownMinValue())),\n        isScalable()));\n  }\n\n  /// Printing function.\n  void print(raw_ostream &OS) const {\n    if (isScalable())\n      OS << \"vscale x \";\n    OS << getKnownMinValue();\n  }\n};\n\nclass ElementCount;\ntemplate <> struct LinearPolyBaseTypeTraits<ElementCount> {\n  using ScalarTy = unsigned;\n  static constexpr unsigned Dimensions = 2;\n};\n\nclass ElementCount : public LinearPolySize<ElementCount> {\npublic:\n  ElementCount() : LinearPolySize(LinearPolySize::getNull()) {}\n\n  ElementCount(const LinearPolySize<ElementCount> &V) : LinearPolySize(V) {}\n\n  /// Counting predicates.\n  ///\n  ///@{ Number of elements..\n  /// Exactly one element.\n  bool isScalar() const { return !isScalable() && getKnownMinValue() == 1; }\n  /// One or more elements.\n  bool isVector() const {\n    return (isScalable() && getKnownMinValue() != 0) || getKnownMinValue() > 1;\n  }\n  ///@}\n};\n\n// This class is used to represent the size of types. If the type is of fixed\nclass TypeSize;\ntemplate <> struct LinearPolyBaseTypeTraits<TypeSize> {\n  using ScalarTy = uint64_t;\n  static constexpr unsigned Dimensions = 2;\n};\n\n// TODO: Most functionality in this class will gradually be phased out\n// so it will resemble LinearPolySize as much as possible.\n//\n// TypeSize is used to represent the size of types. If the type is of fixed\n// size, it will represent the exact size. If the type is a scalable vector,\n// it will represent the known minimum size.\nclass TypeSize : public LinearPolySize<TypeSize> {\npublic:\n  TypeSize(const LinearPolySize<TypeSize> &V) : LinearPolySize(V) {}\n  TypeSize(ScalarTy MinVal, bool IsScalable)\n      : LinearPolySize(LinearPolySize::get(MinVal, IsScalable)) {}\n\n  static TypeSize Fixed(ScalarTy MinVal) { return TypeSize(MinVal, false); }\n  static TypeSize Scalable(ScalarTy MinVal) { return TypeSize(MinVal, true); }\n\n  ScalarTy getFixedSize() const { return getFixedValue(); }\n  ScalarTy getKnownMinSize() const { return getKnownMinValue(); }\n\n  // All code for this class below this point is needed because of the\n  // temporary implicit conversion to uint64_t. The operator overloads are\n  // needed because otherwise the conversion of the parent class\n  // UnivariateLinearPolyBase -> TypeSize is ambiguous.\n  // TODO: Remove the implicit conversion.\n\n  // Casts to a uint64_t if this is a fixed-width size.\n  //\n  // This interface is deprecated and will be removed in a future version\n  // of LLVM in favour of upgrading uses that rely on this implicit conversion\n  // to uint64_t. Calls to functions that return a TypeSize should use the\n  // proper interfaces to TypeSize.\n  // In practice this is mostly calls to MVT/EVT::getSizeInBits().\n  //\n  // To determine how to upgrade the code:\n  //\n  //   if (<algorithm works for both scalable and fixed-width vectors>)\n  //     use getKnownMinValue()\n  //   else if (<algorithm works only for fixed-width vectors>) {\n  //     if <algorithm can be adapted for both scalable and fixed-width vectors>\n  //       update the algorithm and use getKnownMinValue()\n  //     else\n  //       bail out early for scalable vectors and use getFixedValue()\n  //   }\n  operator ScalarTy() const {\n#ifdef STRICT_FIXED_SIZE_VECTORS\n    return getFixedValue();\n#else\n    if (isScalable())\n      WithColor::warning() << \"Compiler has made implicit assumption that \"\n                              \"TypeSize is not scalable. This may or may not \"\n                              \"lead to broken code.\\n\";\n    return getKnownMinValue();\n#endif\n  }\n\n  // Additional operators needed to avoid ambiguous parses\n  // because of the implicit conversion hack.\n  friend TypeSize operator*(const TypeSize &LHS, const int RHS) {\n    return LHS * (ScalarTy)RHS;\n  }\n  friend TypeSize operator*(const TypeSize &LHS, const unsigned RHS) {\n    return LHS * (ScalarTy)RHS;\n  }\n  friend TypeSize operator*(const TypeSize &LHS, const int64_t RHS) {\n    return LHS * (ScalarTy)RHS;\n  }\n  friend TypeSize operator*(const int LHS, const TypeSize &RHS) {\n    return RHS * LHS;\n  }\n  friend TypeSize operator*(const unsigned LHS, const TypeSize &RHS) {\n    return RHS * LHS;\n  }\n  friend TypeSize operator*(const int64_t LHS, const TypeSize &RHS) {\n    return RHS * LHS;\n  }\n  friend TypeSize operator*(const uint64_t LHS, const TypeSize &RHS) {\n    return RHS * LHS;\n  }\n};\n\n//===----------------------------------------------------------------------===//\n// Utilities\n//===----------------------------------------------------------------------===//\n\n/// Returns a TypeSize with a known minimum size that is the next integer\n/// (mod 2**64) that is greater than or equal to \\p Value and is a multiple\n/// of \\p Align. \\p Align must be non-zero.\n///\n/// Similar to the alignTo functions in MathExtras.h\ninline TypeSize alignTo(TypeSize Size, uint64_t Align) {\n  assert(Align != 0u && \"Align must be non-zero\");\n  return {(Size.getKnownMinValue() + Align - 1) / Align * Align,\n          Size.isScalable()};\n}\n\n/// Stream operator function for `LinearPolySize`.\ntemplate <typename LeafTy>\ninline raw_ostream &operator<<(raw_ostream &OS,\n                               const LinearPolySize<LeafTy> &PS) {\n  PS.print(OS);\n  return OS;\n}\n\ntemplate <typename T> struct DenseMapInfo;\ntemplate <> struct DenseMapInfo<ElementCount> {\n  static inline ElementCount getEmptyKey() {\n    return ElementCount::getScalable(~0U);\n  }\n  static inline ElementCount getTombstoneKey() {\n    return ElementCount::getFixed(~0U - 1);\n  }\n  static unsigned getHashValue(const ElementCount &EltCnt) {\n    unsigned HashVal = EltCnt.getKnownMinValue() * 37U;\n    if (EltCnt.isScalable())\n      return (HashVal - 1U);\n\n    return HashVal;\n  }\n\n  static bool isEqual(const ElementCount &LHS, const ElementCount &RHS) {\n    return LHS == RHS;\n  }\n};\n\n} // end namespace llvm\n\n#endif // LLVM_SUPPORT_TYPESIZE_H\n"}, "54": {"id": 54, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/VersionTuple.h", "content": "//===- VersionTuple.h - Version Number Handling -----------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n///\n/// \\file\n/// Defines the llvm::VersionTuple class, which represents a version in\n/// the form major[.minor[.subminor]].\n///\n//===----------------------------------------------------------------------===//\n#ifndef LLVM_SUPPORT_VERSIONTUPLE_H\n#define LLVM_SUPPORT_VERSIONTUPLE_H\n\n#include \"llvm/ADT/Hashing.h\"\n#include \"llvm/ADT/Optional.h\"\n#include <string>\n#include <tuple>\n\nnamespace llvm {\nclass raw_ostream;\nclass StringRef;\n\n/// Represents a version number in the form major[.minor[.subminor[.build]]].\nclass VersionTuple {\n  unsigned Major : 32;\n\n  unsigned Minor : 31;\n  unsigned HasMinor : 1;\n\n  unsigned Subminor : 31;\n  unsigned HasSubminor : 1;\n\n  unsigned Build : 31;\n  unsigned HasBuild : 1;\n\npublic:\n  VersionTuple()\n      : Major(0), Minor(0), HasMinor(false), Subminor(0), HasSubminor(false),\n        Build(0), HasBuild(false) {}\n\n  explicit VersionTuple(unsigned Major)\n      : Major(Major), Minor(0), HasMinor(false), Subminor(0),\n        HasSubminor(false), Build(0), HasBuild(false) {}\n\n  explicit VersionTuple(unsigned Major, unsigned Minor)\n      : Major(Major), Minor(Minor), HasMinor(true), Subminor(0),\n        HasSubminor(false), Build(0), HasBuild(false) {}\n\n  explicit VersionTuple(unsigned Major, unsigned Minor, unsigned Subminor)\n      : Major(Major), Minor(Minor), HasMinor(true), Subminor(Subminor),\n        HasSubminor(true), Build(0), HasBuild(false) {}\n\n  explicit VersionTuple(unsigned Major, unsigned Minor, unsigned Subminor,\n                        unsigned Build)\n      : Major(Major), Minor(Minor), HasMinor(true), Subminor(Subminor),\n        HasSubminor(true), Build(Build), HasBuild(true) {}\n\n  /// Determine whether this version information is empty\n  /// (e.g., all version components are zero).\n  bool empty() const {\n    return Major == 0 && Minor == 0 && Subminor == 0 && Build == 0;\n  }\n\n  /// Retrieve the major version number.\n  unsigned getMajor() const { return Major; }\n\n  /// Retrieve the minor version number, if provided.\n  Optional<unsigned> getMinor() const {\n    if (!HasMinor)\n      return None;\n    return Minor;\n  }\n\n  /// Retrieve the subminor version number, if provided.\n  Optional<unsigned> getSubminor() const {\n    if (!HasSubminor)\n      return None;\n    return Subminor;\n  }\n\n  /// Retrieve the build version number, if provided.\n  Optional<unsigned> getBuild() const {\n    if (!HasBuild)\n      return None;\n    return Build;\n  }\n\n  /// Return a version tuple that contains only the first 3 version components.\n  VersionTuple withoutBuild() const {\n    if (HasBuild)\n      return VersionTuple(Major, Minor, Subminor);\n    return *this;\n  }\n\n  /// Determine if two version numbers are equivalent. If not\n  /// provided, minor and subminor version numbers are considered to be zero.\n  friend bool operator==(const VersionTuple &X, const VersionTuple &Y) {\n    return X.Major == Y.Major && X.Minor == Y.Minor &&\n           X.Subminor == Y.Subminor && X.Build == Y.Build;\n  }\n\n  /// Determine if two version numbers are not equivalent.\n  ///\n  /// If not provided, minor and subminor version numbers are considered to be\n  /// zero.\n  friend bool operator!=(const VersionTuple &X, const VersionTuple &Y) {\n    return !(X == Y);\n  }\n\n  /// Determine whether one version number precedes another.\n  ///\n  /// If not provided, minor and subminor version numbers are considered to be\n  /// zero.\n  friend bool operator<(const VersionTuple &X, const VersionTuple &Y) {\n    return std::tie(X.Major, X.Minor, X.Subminor, X.Build) <\n           std::tie(Y.Major, Y.Minor, Y.Subminor, Y.Build);\n  }\n\n  /// Determine whether one version number follows another.\n  ///\n  /// If not provided, minor and subminor version numbers are considered to be\n  /// zero.\n  friend bool operator>(const VersionTuple &X, const VersionTuple &Y) {\n    return Y < X;\n  }\n\n  /// Determine whether one version number precedes or is\n  /// equivalent to another.\n  ///\n  /// If not provided, minor and subminor version numbers are considered to be\n  /// zero.\n  friend bool operator<=(const VersionTuple &X, const VersionTuple &Y) {\n    return !(Y < X);\n  }\n\n  /// Determine whether one version number follows or is\n  /// equivalent to another.\n  ///\n  /// If not provided, minor and subminor version numbers are considered to be\n  /// zero.\n  friend bool operator>=(const VersionTuple &X, const VersionTuple &Y) {\n    return !(X < Y);\n  }\n\n  friend llvm::hash_code hash_value(const VersionTuple &VT) {\n    return llvm::hash_combine(VT.Major, VT.Minor, VT.Subminor, VT.Build);\n  }\n\n  /// Retrieve a string representation of the version number.\n  std::string getAsString() const;\n\n  /// Try to parse the given string as a version number.\n  /// \\returns \\c true if the string does not match the regular expression\n  ///   [0-9]+(\\.[0-9]+){0,3}\n  bool tryParse(StringRef string);\n};\n\n/// Print a version number.\nraw_ostream &operator<<(raw_ostream &Out, const VersionTuple &V);\n\n} // end namespace llvm\n#endif // LLVM_SUPPORT_VERSIONTUPLE_H\n"}}, "reports": [{"events": [{"location": {"col": 17, "file": 0, "line": 182}, "message": "mark 'noexcept'"}, {"location": {"col": 17, "file": 0, "line": 182}, "message": "'operator==' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/APValue.h", "reportHash": "99024fce3ed4218f3a7d3bcd11cd5b45", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 17, "file": 0, "line": 183}, "message": "mark 'noexcept'"}, {"location": {"col": 17, "file": 0, "line": 183}, "message": "'operator!=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/APValue.h", "reportHash": "1ce9083f436a321d0f31dd5ab442fa26", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 17, "file": 0, "line": 230}, "message": "mark 'noexcept'"}, {"location": {"col": 17, "file": 0, "line": 230}, "message": "'operator==' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/APValue.h", "reportHash": "84aebb84f8d3fb766e6cde33856be062", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 17, "file": 0, "line": 233}, "message": "mark 'noexcept'"}, {"location": {"col": 17, "file": 0, "line": 233}, "message": "'operator!=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/APValue.h", "reportHash": "dae780eafd9b3d69f1148ce6d0d14351", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 17, "file": 1, "line": 855}, "message": "mark 'noexcept'"}, {"location": {"col": 17, "file": 1, "line": 855}, "message": "'operator==' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/ASTContext.h", "reportHash": "cebdd077c05029d1d34275dac157a13b", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 17, "file": 1, "line": 859}, "message": "mark 'noexcept'"}, {"location": {"col": 17, "file": 1, "line": 859}, "message": "'operator!=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/ASTContext.h", "reportHash": "6992fc4ded9dc6a4646badeaaae4f017", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 15, "file": 2, "line": 85}, "message": "mark 'noexcept'"}, {"location": {"col": 15, "file": 2, "line": 85}, "message": "'operator==' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/AttrIterator.h", "reportHash": "df7aa2100c208f972917088f9c1302b1", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 15, "file": 2, "line": 94}, "message": "mark 'noexcept'"}, {"location": {"col": 15, "file": 2, "line": 94}, "message": "'operator!=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/AttrIterator.h", "reportHash": "1bdcb793c290876f8ea578a1c363b974", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 13, "file": 3, "line": 202}, "message": "mark 'noexcept'"}, {"location": {"col": 13, "file": 3, "line": 202}, "message": "'operator==' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/CanonicalType.h", "reportHash": "2b655ca6c9307e2dedb32f04eaf5265d", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 13, "file": 3, "line": 202}, "message": "'operator==' should have 2 parameters of the same type"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/CanonicalType.h", "reportHash": "7d3137f8a42049e57d2e7658cc4a54a3", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 13, "file": 3, "line": 207}, "message": "mark 'noexcept'"}, {"location": {"col": 13, "file": 3, "line": 207}, "message": "'operator!=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/CanonicalType.h", "reportHash": "7710ffc691d10361160342117c8f5f56", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 13, "file": 3, "line": 207}, "message": "'operator!=' should have 2 parameters of the same type"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/CanonicalType.h", "reportHash": "d29277b5071528e2961ab84d92b4e269", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 12, "file": 4, "line": 92}, "message": "'operator==' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/CharUnits.h", "reportHash": "0cfb56bf0560c853122d2a200a96d808", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 12, "file": 4, "line": 95}, "message": "'operator!=' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/CharUnits.h", "reportHash": "d9d6cf302f80536a86f138fbae8e1d0f", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 12, "file": 4, "line": 100}, "message": "'operator<' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/CharUnits.h", "reportHash": "cce37517c12ef9de23346d4083111714", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 12, "file": 4, "line": 103}, "message": "'operator<=' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/CharUnits.h", "reportHash": "958454c1de985e0a32039f132e05f825", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 12, "file": 4, "line": 106}, "message": "'operator>' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/CharUnits.h", "reportHash": "a21dafc84be98e75d326f280b5148863", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 12, "file": 4, "line": 109}, "message": "'operator>=' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/CharUnits.h", "reportHash": "6fa301c14c602c63cac5cf0ba2ab2ad6", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 17, "file": 5, "line": 959}, "message": "mark 'noexcept'"}, {"location": {"col": 17, "file": 5, "line": 959}, "message": "'operator==' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/DeclBase.h", "reportHash": "4e2ee800b1b06ae982f1b8a493db54fc", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 17, "file": 5, "line": 963}, "message": "mark 'noexcept'"}, {"location": {"col": 17, "file": 5, "line": 963}, "message": "'operator!=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/DeclBase.h", "reportHash": "d0b0b388092974d8a542db7ec1b8bffc", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 5, "line": 1266}, "message": "'operator==' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/DeclBase.h", "reportHash": "68168d42059e4c975cadf9eb8999ef67", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 5, "line": 1267}, "message": "'operator!=' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/DeclBase.h", "reportHash": "733572bf6d591e4474729aa26eb0ab20", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 17, "file": 5, "line": 2096}, "message": "mark 'noexcept'"}, {"location": {"col": 17, "file": 5, "line": 2096}, "message": "'operator==' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/DeclBase.h", "reportHash": "c814cd6a2847279c4cce7ea4fb2de1dd", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 17, "file": 5, "line": 2100}, "message": "mark 'noexcept'"}, {"location": {"col": 17, "file": 5, "line": 2100}, "message": "'operator!=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/DeclBase.h", "reportHash": "6ced7391b4b6bad215e9650866b57e73", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 17, "file": 5, "line": 2184}, "message": "mark 'noexcept'"}, {"location": {"col": 17, "file": 5, "line": 2184}, "message": "'operator==' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/DeclBase.h", "reportHash": "d1265c788715c99213c412668a107dd5", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 17, "file": 5, "line": 2189}, "message": "mark 'noexcept'"}, {"location": {"col": 17, "file": 5, "line": 2189}, "message": "'operator!=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/DeclBase.h", "reportHash": "6646b9d447599590ca65687f6db443c6", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 17, "file": 5, "line": 2260}, "message": "mark 'noexcept'"}, {"location": {"col": 17, "file": 5, "line": 2260}, "message": "'operator==' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/DeclBase.h", "reportHash": "2b1ecdf954baf214f3fc1c9eb727b992", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 17, "file": 5, "line": 2265}, "message": "mark 'noexcept'"}, {"location": {"col": 17, "file": 5, "line": 2265}, "message": "'operator!=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/DeclBase.h", "reportHash": "83fd56266149731cb413d04f64383ba1", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 17, "file": 6, "line": 3465}, "message": "mark 'noexcept'"}, {"location": {"col": 17, "file": 6, "line": 3465}, "message": "'operator==' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/DeclCXX.h", "reportHash": "279a22cbec7dd8a6c344d3107ae522bc", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 17, "file": 6, "line": 3468}, "message": "mark 'noexcept'"}, {"location": {"col": 17, "file": 6, "line": 3468}, "message": "'operator!=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/DeclCXX.h", "reportHash": "100dde8d7309f69551e8ac3443542a9f", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 17, "file": 7, "line": 1605}, "message": "mark 'noexcept'"}, {"location": {"col": 17, "file": 7, "line": 1605}, "message": "'operator==' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/DeclObjC.h", "reportHash": "9c327fb72d86bf201500a4b957e0adb1", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 17, "file": 7, "line": 1610}, "message": "mark 'noexcept'"}, {"location": {"col": 17, "file": 7, "line": 1610}, "message": "'operator!=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/DeclObjC.h", "reportHash": "62d7c002f8e88348bb58e1e246bbb1ea", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 15, "file": 8, "line": 508}, "message": "mark 'noexcept'"}, {"location": {"col": 15, "file": 8, "line": 508}, "message": "'operator==' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/DeclarationName.h", "reportHash": "37de94db79b5628e26f1d5565983ac2e", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 15, "file": 8, "line": 513}, "message": "mark 'noexcept'"}, {"location": {"col": 15, "file": 8, "line": 513}, "message": "'operator!=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/DeclarationName.h", "reportHash": "ae59af82df1658b99ec2bd0a76b00291", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 13, "file": 8, "line": 540}, "message": "mark 'noexcept'"}, {"location": {"col": 13, "file": 8, "line": 540}, "message": "'operator<' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/DeclarationName.h", "reportHash": "d6fe2bf7f65b00f8090ae5747156d5e1", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 13, "file": 8, "line": 546}, "message": "mark 'noexcept'"}, {"location": {"col": 13, "file": 8, "line": 546}, "message": "'operator>' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/DeclarationName.h", "reportHash": "3b2e8e1b1f12fc2c5f0289748dfab661", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 13, "file": 8, "line": 552}, "message": "mark 'noexcept'"}, {"location": {"col": 13, "file": 8, "line": 552}, "message": "'operator<=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/DeclarationName.h", "reportHash": "aed87edb0328f99d897dba6f35fb44a5", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 13, "file": 8, "line": 558}, "message": "mark 'noexcept'"}, {"location": {"col": 13, "file": 8, "line": 558}, "message": "'operator>=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/DeclarationName.h", "reportHash": "59b256f0c35feb39c311b4ab5ae5bb12", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 9, "line": 5661}, "message": "'operator==' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/Expr.h", "reportHash": "c2e35e0caba75b0fe23f29a5ec44100c", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 15, "file": 10, "line": 342}, "message": "mark 'noexcept'"}, {"location": {"col": 15, "file": 10, "line": 342}, "message": "'operator==' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/NestedNameSpecifier.h", "reportHash": "a87db9c590e3ed36f0f87c0ab244b3fa", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 15, "file": 10, "line": 347}, "message": "mark 'noexcept'"}, {"location": {"col": 15, "file": 10, "line": 347}, "message": "'operator!=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/NestedNameSpecifier.h", "reportHash": "b2563d8b2a743e6d6ae3b4ca5b62ec36", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 17, "file": 11, "line": 282}, "message": "mark 'noexcept'"}, {"location": {"col": 17, "file": 11, "line": 282}, "message": "'operator==' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/Redeclarable.h", "reportHash": "9ddb5b639f2696d487bb9f02e58cb446", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 17, "file": 11, "line": 285}, "message": "mark 'noexcept'"}, {"location": {"col": 17, "file": 11, "line": 285}, "message": "'operator!=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/Redeclarable.h", "reportHash": "0dac5939600c899df56c58808ebb3636", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 15, "file": 11, "line": 364}, "message": "mark 'noexcept'"}, {"location": {"col": 15, "file": 11, "line": 364}, "message": "'operator==' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/Redeclarable.h", "reportHash": "8d7a566d368d671399de3d1ea32979da", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 15, "file": 11, "line": 367}, "message": "mark 'noexcept'"}, {"location": {"col": 15, "file": 11, "line": 367}, "message": "'operator!=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/Redeclarable.h", "reportHash": "a95622d6d5e86748fb7cbbfbe54ad006", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 15, "file": 12, "line": 107}, "message": "mark 'noexcept'"}, {"location": {"col": 15, "file": 12, "line": 107}, "message": "'operator==' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/StmtIterator.h", "reportHash": "95960fbebe9f6ad4b6fcdfbfa5c1e4f7", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 15, "file": 12, "line": 112}, "message": "mark 'noexcept'"}, {"location": {"col": 15, "file": 12, "line": 112}, "message": "'operator!=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/StmtIterator.h", "reportHash": "018354fb2a533b0dc6d70100a8df4067", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 13, "line": 541}, "message": "'operator==' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/Type.h", "reportHash": "ce4977988cad7f8737760e2fedaa7e72", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 13, "line": 542}, "message": "'operator!=' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/Type.h", "reportHash": "6d389f880113562d568f485abe246592", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 15, "file": 13, "line": 617}, "message": "mark 'noexcept'"}, {"location": {"col": 15, "file": 13, "line": 617}, "message": "'operator==' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/Type.h", "reportHash": "95b363fd6f801b1a8ba2f8b648c201ab", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 15, "file": 13, "line": 620}, "message": "mark 'noexcept'"}, {"location": {"col": 15, "file": 13, "line": 620}, "message": "'operator!=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/Type.h", "reportHash": "ba1024c59d10ad45bfd2a549c8131910", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 15, "file": 13, "line": 993}, "message": "mark 'noexcept'"}, {"location": {"col": 15, "file": 13, "line": 993}, "message": "'operator==' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/Type.h", "reportHash": "1a95e8349a9488817821097acf5dcc1c", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 15, "file": 13, "line": 996}, "message": "mark 'noexcept'"}, {"location": {"col": 15, "file": 13, "line": 996}, "message": "'operator!=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/Type.h", "reportHash": "567d105a85791b97a6dfcb8c2e015665", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 15, "file": 13, "line": 999}, "message": "mark 'noexcept'"}, {"location": {"col": 15, "file": 13, "line": 999}, "message": "'operator<' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/Type.h", "reportHash": "6d8346138c15819cb6e158cf7b7c051c", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 17, "file": 13, "line": 3623}, "message": "mark 'noexcept'"}, {"location": {"col": 17, "file": 13, "line": 3623}, "message": "'operator==' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/Type.h", "reportHash": "bf8b5d0140f58f7764ad4db58c730339", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 17, "file": 13, "line": 3627}, "message": "mark 'noexcept'"}, {"location": {"col": 17, "file": 13, "line": 3627}, "message": "'operator!=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/Type.h", "reportHash": "f509e6a02b9888aa2a494954e4e9e5c3", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 13, "line": 3716}, "message": "'operator==' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/Type.h", "reportHash": "d2c700c4bb7c55cb8a2096842eb8004a", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 13, "line": 3719}, "message": "'operator!=' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/Type.h", "reportHash": "c49237f0f9d5ccd3888ab37741525097", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 15, "file": 14, "line": 219}, "message": "mark 'noexcept'"}, {"location": {"col": 15, "file": 14, "line": 219}, "message": "'operator==' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/TypeLoc.h", "reportHash": "9ae5f97c963d39e91976e2ae44be38d1", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 15, "file": 14, "line": 223}, "message": "mark 'noexcept'"}, {"location": {"col": 15, "file": 14, "line": 223}, "message": "'operator!=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/AST/TypeLoc.h", "reportHash": "ac5e6eea8754e1f39185c61ab5d106a5", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 15, "line": 649}, "message": "'operator<' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Analysis/CFG.h", "reportHash": "c5e9860ea0bbfdb691d80df792dd5d19", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 15, "line": 654}, "message": "'operator==' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Analysis/CFG.h", "reportHash": "dcf92ea07a107f7c860fc351ba4a3f13", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 15, "line": 658}, "message": "'operator!=' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Analysis/CFG.h", "reportHash": "79bbbd2160bbdc62e0c2e95d0fcebbb0", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 15, "line": 712}, "message": "'operator<' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Analysis/CFG.h", "reportHash": "54769c7f005765f4b96c8887878df125", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 15, "line": 717}, "message": "'operator==' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Analysis/CFG.h", "reportHash": "533ff6144f2efaae15b99e738e4f4f57", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 15, "line": 721}, "message": "'operator!=' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Analysis/CFG.h", "reportHash": "f042d2dcdf076cba3b35819300accee9", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 16, "line": 173}, "message": "'operator==' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Analysis/ConstructionContext.h", "reportHash": "e4b38350c656e17dfa575be58ab8a468", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 16, "line": 181}, "message": "'operator<' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Analysis/ConstructionContext.h", "reportHash": "96b6962fba84a0dd84764dc287d2daca", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 17, "line": 194}, "message": "'operator==' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Analysis/ProgramPoint.h", "reportHash": "ef0cfecf2e9007339fbd7408688283b7", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 17, "line": 201}, "message": "'operator!=' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Analysis/ProgramPoint.h", "reportHash": "1656734e5b3c3f2deb54462feb261144", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 18, "line": 71}, "message": "'clang/Basic/DiagnosticCommonKinds.inc' file not found"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Basic/DiagnosticIDs.h", "reportHash": "0212dcde1e4a793396a6f1f45b22be74", "checkerName": "clang-diagnostic-error", "reviewStatus": null, "severity": "CRITICAL"}, {"events": [{"location": {"col": 8, "file": 19, "line": 398}, "message": "'operator<' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Basic/IdentifierTable.h", "reportHash": "c651e4b29cfb8a4272046cb85ddf22ff", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 19, "line": 742}, "message": "'operator==' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Basic/IdentifierTable.h", "reportHash": "09be03eeb951bf5da4573f410f780c90", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 19, "line": 745}, "message": "'operator!=' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Basic/IdentifierTable.h", "reportHash": "85ac9d242cb566232d1598bfeb990625", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 20, "line": 512}, "message": "'operator==' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Basic/LangOptions.h", "reportHash": "6933f751ebf0fb242f69faff8e42ba9c", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 20, "line": 626}, "message": "'operator==' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Basic/LangOptions.h", "reportHash": "f74d19c6bfe3850b4ebad4a84a6c0521", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 20, "line": 629}, "message": "'operator!=' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Basic/LangOptions.h", "reportHash": "f6cf24308c8306d0f36e63d15451476e", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 15, "file": 21, "line": 471}, "message": "mark 'noexcept'"}, {"location": {"col": 15, "file": 21, "line": 471}, "message": "'operator==' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Basic/ObjCRuntime.h", "reportHash": "e54bdc8cb6868d8f9c86c0d82b0d200b", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 15, "file": 21, "line": 476}, "message": "mark 'noexcept'"}, {"location": {"col": 15, "file": 21, "line": 476}, "message": "'operator!=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Basic/ObjCRuntime.h", "reportHash": "4fedc5e248632e45cc61663387a969f6", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 18, "file": 22, "line": 85}, "message": "'operator==' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Basic/Sanitizers.h", "reportHash": "7ef90e51108fd28fe8df11555d780fee", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 18, "file": 22, "line": 104}, "message": "'operator!=' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Basic/Sanitizers.h", "reportHash": "4726775d2ad4e0de948a9e33ac37a876", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 23, "line": 50}, "message": "'operator==' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Basic/SourceLocation.h", "reportHash": "60e9eebadde3993df2248d1d4619984d", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 23, "line": 51}, "message": "'operator<' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Basic/SourceLocation.h", "reportHash": "1ac2c33640dac3390d8987c1b57edb6f", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 23, "line": 52}, "message": "'operator<=' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Basic/SourceLocation.h", "reportHash": "7351398618947dce926e862003cbab0c", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 23, "line": 53}, "message": "'operator!=' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Basic/SourceLocation.h", "reportHash": "3b6ede5804055de3f6f95664ce141c82", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 23, "line": 54}, "message": "'operator>' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Basic/SourceLocation.h", "reportHash": "98a40f706c2f170e260b36ececbc808a", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 23, "line": 55}, "message": "'operator>=' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Basic/SourceLocation.h", "reportHash": "34735b8e77e0b95ec8efc934517ddf57", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 13, "file": 23, "line": 188}, "message": "mark 'noexcept'"}, {"location": {"col": 13, "file": 23, "line": 188}, "message": "'operator==' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Basic/SourceLocation.h", "reportHash": "490aa1a88dc177ad16771d5ecae0da2b", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 13, "file": 23, "line": 192}, "message": "mark 'noexcept'"}, {"location": {"col": 13, "file": 23, "line": 192}, "message": "'operator!=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Basic/SourceLocation.h", "reportHash": "d7e667ea96d49453ec3f4ec028d4a533", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 13, "file": 23, "line": 198}, "message": "mark 'noexcept'"}, {"location": {"col": 13, "file": 23, "line": 198}, "message": "'operator<' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Basic/SourceLocation.h", "reportHash": "c2e9f833fe8944cbcac9d5712f64efdc", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 13, "file": 23, "line": 201}, "message": "mark 'noexcept'"}, {"location": {"col": 13, "file": 23, "line": 201}, "message": "'operator>' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Basic/SourceLocation.h", "reportHash": "a99a5f97829c455e002b0cf2dd442b06", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 13, "file": 23, "line": 204}, "message": "mark 'noexcept'"}, {"location": {"col": 13, "file": 23, "line": 204}, "message": "'operator<=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Basic/SourceLocation.h", "reportHash": "0b8e0d5998e1f6ebb992b582fdf3f29e", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 13, "file": 23, "line": 207}, "message": "mark 'noexcept'"}, {"location": {"col": 13, "file": 23, "line": 207}, "message": "'operator>=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Basic/SourceLocation.h", "reportHash": "72aa9870161f0af1f85286224df9356c", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 23, "line": 230}, "message": "'operator==' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Basic/SourceLocation.h", "reportHash": "102838b0ca9f9b46b0c0e8c047185807", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 23, "line": 234}, "message": "'operator!=' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Basic/SourceLocation.h", "reportHash": "a69c9c661dd94a46a9cf12661ed82ff3", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 23, "line": 451}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 23, "line": 451}, "message": "'operator==' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Basic/SourceLocation.h", "reportHash": "698b9a3758bcd4bf13ec4711d4374c85", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 23, "line": 457}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 23, "line": 457}, "message": "'operator!=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/Basic/SourceLocation.h", "reportHash": "b337940efffcec49eb752c4a44029325", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 24, "line": 38}, "message": "'operator==' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/DynamicTypeInfo.h", "reportHash": "ae111822e2c0a93cc725310a92cd0cdc", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 25, "line": 90}, "message": "'operator==' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/Environment.h", "reportHash": "6b19dc8e30473c1b2fce4e51da21d00b", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 26, "line": 128}, "message": "'operator==' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/SVals.h", "reportHash": "2f4d294c694760f2cb840cfc7aaf3c3f", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 26, "line": 132}, "message": "'operator!=' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/SVals.h", "reportHash": "1330a880cddce50a9179ca035bb434de", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 26, "line": 612}, "message": "'operator==' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/SVals.h", "reportHash": "cd30a489412cc01a522d23a910ced6e4", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 26, "line": 616}, "message": "'operator!=' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/SVals.h", "reportHash": "ed620262784480a1fa9b6a3527669be2", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 27, "line": 82}, "message": "'operator==' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/SymExpr.h", "reportHash": "84c40e46e9bdda1bd1d2f18e32efc782", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 27, "line": 83}, "message": "'operator!=' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/include/clang/StaticAnalyzer/Core/PathSensitive/SymExpr.h", "reportHash": "93efdb1d4e19eeaa2c011778a6fd7f9a", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 28, "line": 184}, "message": "'operator==' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/APFixedPoint.h", "reportHash": "cd1dfce92fa4fc14851c02bf9b6c4f53", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 28, "line": 187}, "message": "'operator!=' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/APFixedPoint.h", "reportHash": "9536e221d7b54fe4c059a32db110a7a5", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 28, "line": 190}, "message": "'operator>' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/APFixedPoint.h", "reportHash": "ade30b9643824f8f5ddaffff223ad973", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 28, "line": 191}, "message": "'operator<' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/APFixedPoint.h", "reportHash": "82e5a2b098f4257f9acf6a75e5dc6192", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 28, "line": 192}, "message": "'operator>=' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/APFixedPoint.h", "reportHash": "5ee9626c2270a67d75bfca40ace499b6", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 28, "line": 195}, "message": "'operator<=' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/APFixedPoint.h", "reportHash": "3b5cc463d12d3dabc4ac04e734303f1d", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 29, "line": 318}, "message": "'operator==' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/APFloat.h", "reportHash": "14c7830fa57a0eb5273340118087cbec", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 29, "line": 1138}, "message": "'operator==' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/APFloat.h", "reportHash": "fa04f663cadf7c1dbb8557facb9aa573", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 29, "line": 1140}, "message": "'operator!=' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/APFloat.h", "reportHash": "54bb8401ef70a338f1b72fd220984bcc", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 29, "line": 1142}, "message": "'operator<' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/APFloat.h", "reportHash": "cba339b5811a70d89f870c27da7be40e", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 29, "line": 1146}, "message": "'operator>' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/APFloat.h", "reportHash": "ed5a96a8181c8fd3df66f5270c590a56", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 29, "line": 1150}, "message": "'operator<=' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/APFloat.h", "reportHash": "1188bf2ebb3a2701862eca1fb2b71208", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 29, "line": 1155}, "message": "'operator>=' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/APFloat.h", "reportHash": "931a92413e032b9985218487c918b4a4", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 17, "file": 34, "line": 133}, "message": "mark 'noexcept'"}, {"location": {"col": 17, "file": 34, "line": 133}, "message": "'operator==' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/DenseSet.h", "reportHash": "d2e4bbd2ee5d63188247f141384711cf", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 17, "file": 34, "line": 136}, "message": "mark 'noexcept'"}, {"location": {"col": 17, "file": 34, "line": 136}, "message": "'operator!=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/DenseSet.h", "reportHash": "0ef2212bd973217a362c80d9b210aee3", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 17, "file": 34, "line": 162}, "message": "mark 'noexcept'"}, {"location": {"col": 17, "file": 34, "line": 162}, "message": "'operator==' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/DenseSet.h", "reportHash": "5ccae725e3655d494bed590304f22f01", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 17, "file": 34, "line": 165}, "message": "mark 'noexcept'"}, {"location": {"col": 17, "file": 34, "line": 165}, "message": "'operator!=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/DenseSet.h", "reportHash": "acb9e1441cf6977b308baf2f0375ceea", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 6, "file": 34, "line": 243}, "message": "mark 'noexcept'"}, {"location": {"col": 6, "file": 34, "line": 243}, "message": "'operator==' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/DenseSet.h", "reportHash": "5891cb8de0180bdbfec0242ed7b5cc36", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 6, "file": 34, "line": 243}, "message": "'operator==' should have 2 parameters of the same type"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/DenseSet.h", "reportHash": "14dff92b52591b87a4bda8d28c2f2e92", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 6, "file": 34, "line": 259}, "message": "mark 'noexcept'"}, {"location": {"col": 6, "file": 34, "line": 259}, "message": "'operator!=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/DenseSet.h", "reportHash": "357273aee292715f063fa78ae8e17aed", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 6, "file": 34, "line": 259}, "message": "'operator!=' should have 2 parameters of the same type"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/DenseSet.h", "reportHash": "474a3ceec6111daec9f00c022a58bfa7", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 35, "line": 115}, "message": "'operator==' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/FloatingPointMode.h", "reportHash": "f16e0d52ffc3ee21aa819d72b6373669", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 35, "line": 119}, "message": "'operator!=' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/FloatingPointMode.h", "reportHash": "0f3f99f493e6b1703dd2a6a281ee2228", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 36, "line": 297}, "message": "'operator==' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/FoldingSet.h", "reportHash": "600e9244440b59dcc0c5093ed09171a6", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 36, "line": 299}, "message": "'operator!=' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/FoldingSet.h", "reportHash": "e399a5f5c5efe137fe520a5d5f6bd3bc", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 36, "line": 303}, "message": "'operator<' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/FoldingSet.h", "reportHash": "ed0700e2f8f9b20ef32fef8d0c706607", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 36, "line": 348}, "message": "'operator==' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/FoldingSet.h", "reportHash": "00d5f53ce3f86a281267cb2de49f46fc", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 36, "line": 349}, "message": "'operator==' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/FoldingSet.h", "reportHash": "4518e9f4d230d787c77d7d42a3d8c353", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 36, "line": 351}, "message": "'operator!=' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/FoldingSet.h", "reportHash": "dd4ccc2d3c4b35bd577ae4f35baff5c1", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 36, "line": 352}, "message": "'operator!=' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/FoldingSet.h", "reportHash": "a67c462b44ba5d758f66cf2d8a6bb536", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 36, "line": 356}, "message": "'operator<' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/FoldingSet.h", "reportHash": "72d296ec4a98fabcb64ba6dea5a5c850", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 36, "line": 357}, "message": "'operator<' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/FoldingSet.h", "reportHash": "f5929235d10e0277d8b33e8d6c2fd380", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 36, "line": 674}, "message": "'operator==' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/FoldingSet.h", "reportHash": "a4fc12a60092632c9ac448d97e735da9", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 36, "line": 677}, "message": "'operator!=' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/FoldingSet.h", "reportHash": "91c4d100855c2b42b6412b98abe8ba93", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 36, "line": 722}, "message": "'operator==' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/FoldingSet.h", "reportHash": "ef46dd6c2c770ab823220c2b58229777", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 36, "line": 725}, "message": "'operator!=' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/FoldingSet.h", "reportHash": "54e1e0c662adff264ce71a876809a34e", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 38, "line": 93}, "message": "'operator==' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/ImmutableList.h", "reportHash": "eb7e166f03ec8f28932ecb9dc2b38f4b", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 38, "line": 94}, "message": "'operator!=' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/ImmutableList.h", "reportHash": "a15af521346d6cefc25f051bb734bb62", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 38, "line": 129}, "message": "'operator==' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/ImmutableList.h", "reportHash": "1f63421f62bd7f2f8dbfdcc5cb941d6d", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 39, "line": 117}, "message": "'operator==' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/ImmutableMap.h", "reportHash": "ab850dadcb0c858383df852f183221ac", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 39, "line": 121}, "message": "'operator!=' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/ImmutableMap.h", "reportHash": "b490c8d35957390a01deeb8d39506424", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 39, "line": 297}, "message": "'operator==' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/ImmutableMap.h", "reportHash": "681ffad103b25a2cbbfea0d47b00f3d0", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 39, "line": 301}, "message": "'operator!=' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/ImmutableMap.h", "reportHash": "e61b20968c79e9d7853bdbc331e8af4f", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 40, "line": 705}, "message": "'operator==' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/ImmutableSet.h", "reportHash": "9d72fd8a7530697b0c13f94a812c871f", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 40, "line": 709}, "message": "'operator!=' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/ImmutableSet.h", "reportHash": "5355769afbbd64c2b8b741a2941c4dca", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 40, "line": 783}, "message": "'operator==' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/ImmutableSet.h", "reportHash": "ef216d3b0611e92c2814161dab24ab13", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 40, "line": 787}, "message": "'operator!=' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/ImmutableSet.h", "reportHash": "c986802eba003b5a25fb7c11c646a16f", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 40, "line": 1037}, "message": "'operator==' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/ImmutableSet.h", "reportHash": "16040b6eb125746cd2aa3f4c037608d9", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 40, "line": 1041}, "message": "'operator!=' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/ImmutableSet.h", "reportHash": "821390b26993249205a4a0295c185d66", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 40, "line": 1138}, "message": "'operator==' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/ImmutableSet.h", "reportHash": "abcd6517b77111830414202bffeeada6", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 40, "line": 1142}, "message": "'operator!=' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/ImmutableSet.h", "reportHash": "39157d7dab482a8d941eaa2780e349a9", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 6, "file": 44, "line": 236}, "message": "mark 'noexcept'"}, {"location": {"col": 6, "file": 44, "line": 236}, "message": "'operator==' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/PointerUnion.h", "reportHash": "360e5154ad07749cec4fcd1bb430baf4", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 6, "file": 44, "line": 236}, "message": "'operator==' should have 2 parameters of the same type"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/PointerUnion.h", "reportHash": "20fc88c17be2ef1277b5b02250a3f4bf", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 6, "file": 44, "line": 241}, "message": "mark 'noexcept'"}, {"location": {"col": 6, "file": 44, "line": 241}, "message": "'operator!=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/PointerUnion.h", "reportHash": "82f2b24acb0e69568c1bbb73b5bb6f8b", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 6, "file": 44, "line": 241}, "message": "'operator!=' should have 2 parameters of the same type"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/PointerUnion.h", "reportHash": "4b3d1b1f334c796bb2d7e3039532860c", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 6, "file": 44, "line": 246}, "message": "mark 'noexcept'"}, {"location": {"col": 6, "file": 44, "line": 246}, "message": "'operator<' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/PointerUnion.h", "reportHash": "20f1546a8cfc01e2dcfc5544e444be36", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 6, "file": 44, "line": 246}, "message": "'operator<' should have 2 parameters of the same type"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/PointerUnion.h", "reportHash": "6363aef2ee7009d5329311496335ca0c", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 6, "file": 52, "line": 37}, "message": "mark 'noexcept'"}, {"location": {"col": 6, "file": 52, "line": 37}, "message": "'operator<' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/AtomicOrdering.h", "reportHash": "4eeb2955b417ed1e2011eee1fda86089", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 6, "file": 52, "line": 38}, "message": "mark 'noexcept'"}, {"location": {"col": 6, "file": 52, "line": 38}, "message": "'operator>' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/AtomicOrdering.h", "reportHash": "cd9409fad833ac92ff3f96a17110096b", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 6, "file": 52, "line": 39}, "message": "mark 'noexcept'"}, {"location": {"col": 6, "file": 52, "line": 39}, "message": "'operator<=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/AtomicOrdering.h", "reportHash": "51aff962a8c34e56d79a5e13302c4fca", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 6, "file": 52, "line": 40}, "message": "mark 'noexcept'"}, {"location": {"col": 6, "file": 52, "line": 40}, "message": "'operator>=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/AtomicOrdering.h", "reportHash": "0b6ed19b9cdf4d66f3b61ad9c19eeeeb", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 6, "file": 52, "line": 68}, "message": "mark 'noexcept'"}, {"location": {"col": 6, "file": 52, "line": 68}, "message": "'operator<' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/AtomicOrdering.h", "reportHash": "0cefd761a4d3f7645bf485b9a85b0c1f", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 6, "file": 52, "line": 69}, "message": "mark 'noexcept'"}, {"location": {"col": 6, "file": 52, "line": 69}, "message": "'operator>' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/AtomicOrdering.h", "reportHash": "ff2dc0a4db715a5898a69c034204d6fd", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 6, "file": 52, "line": 70}, "message": "mark 'noexcept'"}, {"location": {"col": 6, "file": 52, "line": 70}, "message": "'operator<=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/AtomicOrdering.h", "reportHash": "d0fb471b2d1f390f93da8ca7bf90906c", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 6, "file": 52, "line": 71}, "message": "mark 'noexcept'"}, {"location": {"col": 6, "file": 52, "line": 71}, "message": "'operator>=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/AtomicOrdering.h", "reportHash": "fcc3ce8be5cdc853c7f51dd7c54d503e", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 53, "line": 98}, "message": "'operator==' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/TypeSize.h", "reportHash": "cdc902d7a03f40003bc80de54c5417ef", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 53, "line": 103}, "message": "'operator!=' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/TypeSize.h", "reportHash": "53481e0a36c599f11c08132d6da9c950", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 53, "line": 217}, "message": "'operator==' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/TypeSize.h", "reportHash": "2e6f45b5556455583af42180e8aed096", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 53, "line": 221}, "message": "'operator!=' should not be member function"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/TypeSize.h", "reportHash": "6fb71a68e8132b0e4b61238b1141328f", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 15, "file": 54, "line": 100}, "message": "mark 'noexcept'"}, {"location": {"col": 15, "file": 54, "line": 100}, "message": "'operator==' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/VersionTuple.h", "reportHash": "a8e707670695ae8118027c56eb9863c3", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 15, "file": 54, "line": 109}, "message": "mark 'noexcept'"}, {"location": {"col": 15, "file": 54, "line": 109}, "message": "'operator!=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/VersionTuple.h", "reportHash": "cb0befc0a37de3b7b8be5da911f7a41a", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 15, "file": 54, "line": 117}, "message": "mark 'noexcept'"}, {"location": {"col": 15, "file": 54, "line": 117}, "message": "'operator<' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/VersionTuple.h", "reportHash": "375acfaf1ce104ca0d744ceec881a18e", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 15, "file": 54, "line": 126}, "message": "mark 'noexcept'"}, {"location": {"col": 15, "file": 54, "line": 126}, "message": "'operator>' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/VersionTuple.h", "reportHash": "059d6f9b599901829e7f44bdd86993e6", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 15, "file": 54, "line": 135}, "message": "mark 'noexcept'"}, {"location": {"col": 15, "file": 54, "line": 135}, "message": "'operator<=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/VersionTuple.h", "reportHash": "aaaf2e7868af27845ee5473c07f3c7b1", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 15, "file": 54, "line": 144}, "message": "mark 'noexcept'"}, {"location": {"col": 15, "file": 54, "line": 144}, "message": "'operator>=' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/VersionTuple.h", "reportHash": "ae6c2faa0ea7852d67f51bd834e2444c", "checkerName": "cppcoreguidelines-comparison-operator", "reviewStatus": null, "severity": "UNSPECIFIED"}]};
      window.onload = function() {
        if (!browserCompatible) {
          setNonCompatibleBrowserMessage();
        } else {
          BugViewer.init(data.files, data.reports);
          BugViewer.create();
          BugViewer.initByUrl();
        }
      };
    </script>
  </head>
  <body>
  <div class="container">
    <div id="content">
      <div id="side-bar">
        <div class="header">
          <a href="index.html" class="button">&#8249; Return to List</a>
        </div>
        <div id="report-nav">
          <div class="header">Reports</div>
        </div>
      </div>
      <div id="editor-wrapper">
        <div class="header">
          <div id="file">
            <span class="label">File:</span>
            <span id="file-path"></span>
          </div>
          <div id="checker">
            <span class="label">Checker name:</span>
            <span id="checker-name"></span>
          </div>
          <div id="review-status-wrapper">
            <span class="label">Review status:</span>
            <span id="review-status"></span>
          </div>
        </div>
        <div id="editor"></div>
      </div>
    </div>
  </div>
  </body>
</html>
