<!DOCTYPE html>
<html>
  <head>
    <title>Plist HTML Viewer</title>

    <meta charset="UTF-8">

    <style type="text/css">
      .CodeMirror{font-family:monospace;height:300px;color:#000;direction:ltr}.CodeMirror-lines{padding:4px 0}.CodeMirror pre{padding:0 4px}.CodeMirror-gutter-filler,.CodeMirror-scrollbar-filler{background-color:#fff}.CodeMirror-gutters{border-right:1px solid #ddd;background-color:#f7f7f7;white-space:nowrap}.CodeMirror-linenumber{padding:0 3px 0 5px;min-width:20px;text-align:right;color:#999;white-space:nowrap}.CodeMirror-guttermarker{color:#000}.CodeMirror-guttermarker-subtle{color:#999}.CodeMirror-cursor{border-left:1px solid #000;border-right:none;width:0}.CodeMirror div.CodeMirror-secondarycursor{border-left:1px solid silver}.cm-fat-cursor .CodeMirror-cursor{width:auto;border:0!important;background:#7e7}.cm-fat-cursor div.CodeMirror-cursors{z-index:1}.cm-animate-fat-cursor{width:auto;border:0;-webkit-animation:blink 1.06s steps(1) infinite;-moz-animation:blink 1.06s steps(1) infinite;animation:blink 1.06s steps(1) infinite;background-color:#7e7}@-moz-keyframes blink{50%{background-color:transparent}}@-webkit-keyframes blink{50%{background-color:transparent}}@keyframes blink{50%{background-color:transparent}}.cm-tab{display:inline-block;text-decoration:inherit}.CodeMirror-rulers{position:absolute;left:0;right:0;top:-50px;bottom:-20px;overflow:hidden}.CodeMirror-ruler{border-left:1px solid #ccc;top:0;bottom:0;position:absolute}.cm-s-default .cm-header{color:#00f}.cm-s-default .cm-quote{color:#090}.cm-negative{color:#d44}.cm-positive{color:#292}.cm-header,.cm-strong{font-weight:700}.cm-em{font-style:italic}.cm-link{text-decoration:underline}.cm-strikethrough{text-decoration:line-through}.cm-s-default .cm-keyword{color:#708}.cm-s-default .cm-atom{color:#219}.cm-s-default .cm-number{color:#164}.cm-s-default .cm-def{color:#00f}.cm-s-default .cm-variable-2{color:#05a}.cm-s-default .cm-type,.cm-s-default .cm-variable-3{color:#085}.cm-s-default .cm-comment{color:#a50}.cm-s-default .cm-string{color:#a11}.cm-s-default .cm-string-2{color:#f50}.cm-s-default .cm-meta{color:#555}.cm-s-default .cm-qualifier{color:#555}.cm-s-default .cm-builtin{color:#30a}.cm-s-default .cm-bracket{color:#997}.cm-s-default .cm-tag{color:#170}.cm-s-default .cm-attribute{color:#00c}.cm-s-default .cm-hr{color:#999}.cm-s-default .cm-link{color:#00c}.cm-s-default .cm-error{color:red}.cm-invalidchar{color:red}.CodeMirror-composing{border-bottom:2px solid}div.CodeMirror span.CodeMirror-matchingbracket{color:#0f0}div.CodeMirror span.CodeMirror-nonmatchingbracket{color:#f22}.CodeMirror-matchingtag{background:rgba(255,150,0,.3)}.CodeMirror-activeline-background{background:#e8f2ff}.CodeMirror{position:relative;overflow:hidden;background:#fff}.CodeMirror-scroll{overflow:scroll!important;margin-bottom:-30px;margin-right:-30px;padding-bottom:30px;height:100%;outline:0;position:relative}.CodeMirror-sizer{position:relative;border-right:30px solid transparent}.CodeMirror-gutter-filler,.CodeMirror-hscrollbar,.CodeMirror-scrollbar-filler,.CodeMirror-vscrollbar{position:absolute;z-index:6;display:none}.CodeMirror-vscrollbar{right:0;top:0;overflow-x:hidden;overflow-y:scroll}.CodeMirror-hscrollbar{bottom:0;left:0;overflow-y:hidden;overflow-x:scroll}.CodeMirror-scrollbar-filler{right:0;bottom:0}.CodeMirror-gutter-filler{left:0;bottom:0}.CodeMirror-gutters{position:absolute;left:0;top:0;min-height:100%;z-index:3}.CodeMirror-gutter{white-space:normal;height:100%;display:inline-block;vertical-align:top;margin-bottom:-30px}.CodeMirror-gutter-wrapper{position:absolute;z-index:4;background:0 0!important;border:none!important}.CodeMirror-gutter-background{position:absolute;top:0;bottom:0;z-index:4}.CodeMirror-gutter-elt{position:absolute;cursor:default;z-index:4}.CodeMirror-gutter-wrapper ::selection{background-color:transparent}.CodeMirror-gutter-wrapper ::-moz-selection{background-color:transparent}.CodeMirror-lines{cursor:text;min-height:1px}.CodeMirror pre{-moz-border-radius:0;-webkit-border-radius:0;border-radius:0;border-width:0;background:0 0;font-family:inherit;font-size:inherit;margin:0;white-space:pre;word-wrap:normal;line-height:inherit;color:inherit;z-index:2;position:relative;overflow:visible;-webkit-tap-highlight-color:transparent;-webkit-font-variant-ligatures:contextual;font-variant-ligatures:contextual}.CodeMirror-wrap pre{word-wrap:break-word;white-space:pre-wrap;word-break:normal}.CodeMirror-linebackground{position:absolute;left:0;right:0;top:0;bottom:0;z-index:0}.CodeMirror-linewidget{position:relative;z-index:2;overflow:auto}.CodeMirror-rtl pre{direction:rtl}.CodeMirror-code{outline:0}.CodeMirror-gutter,.CodeMirror-gutters,.CodeMirror-linenumber,.CodeMirror-scroll,.CodeMirror-sizer{-moz-box-sizing:content-box;box-sizing:content-box}.CodeMirror-measure{position:absolute;width:100%;height:0;overflow:hidden;visibility:hidden}.CodeMirror-cursor{position:absolute;pointer-events:none}.CodeMirror-measure pre{position:static}div.CodeMirror-cursors{visibility:hidden;position:relative;z-index:3}div.CodeMirror-dragcursors{visibility:visible}.CodeMirror-focused div.CodeMirror-cursors{visibility:visible}.CodeMirror-selected{background:#d9d9d9}.CodeMirror-focused .CodeMirror-selected{background:#d7d4f0}.CodeMirror-crosshair{cursor:crosshair}.CodeMirror-line::selection,.CodeMirror-line>span::selection,.CodeMirror-line>span>span::selection{background:#d7d4f0}.CodeMirror-line::-moz-selection,.CodeMirror-line>span::-moz-selection,.CodeMirror-line>span>span::-moz-selection{background:#d7d4f0}.cm-searching{background-color:#ffa;background-color:rgba(255,255,0,.4)}.cm-force-border{padding-right:.1px}@media print{.CodeMirror div.CodeMirror-cursors{visibility:hidden}}.cm-tab-wrap-hack:after{content:''}span.CodeMirror-selectedtext{background:0 0}
/*# sourceMappingURL=codemirror.min.css.map */

      .severity-low {
  background-color: #669603;
}

.severity-low:after {
  content : 'L';
}

.severity-unspecified {
  background-color: #666666;
}

.severity-unspecified:after {
  content : 'U';
}

.severity-style {
  background-color: #9932cc;
}

.severity-style:after {
  content : 'S';
}

.severity-medium {
  background-color: #a9d323;
  color: black;
}

.severity-medium:after {
  content : 'M';
}

.severity-high {
  background-color: #ffa800;
}

.severity-high:after {
  content : 'H';
}

.severity-critical {
  background-color: #e92625;
}

.severity-critical:after {
  content : 'C';
}

i[class*="severity-"] {
  line-height: normal;
  text-transform: capitalize;
  font-size: 0.8em;
  font-weight: bold;
  color: white;
  display: inline-block;
  width: 16px;
  height: 16px;
  text-align: center;
  font-family: sans-serif;
}

      html, body {
  width: 100%;
  height: 100%;
  padding: 0px;
  margin: 0px;
}

div.container {
  padding: 10px;
}

#content {
  height: 100%;
  display: block;
  overflow: hidden;
}

#content > div {
  margin: 10px;
  overflow: hidden;
  border: 1px solid #ddd;
  border-radius: 3px;
  overflow: hidden;
  height: 97%;
}

.button {
  background-color: #f1f1f1;
  text-decoration: none;
  display: inline-block;
  padding: 8px 16px;
  color: black;
  cursor: pointer;
}

.button:hover {
  background-color: #ddd;
  color: black;
}

.review-status {
  color: white;
  text-align: center;
}

.review-status-confirmed {
  background-color: #e92625;
}

.review-status-false-positive {
  background-color: grey;
}

.review-status-intentional {
  background-color: #669603;
}

      div.container {
  width: 100%;
  height: 100%;
  padding: 0px;
}

#editor-wrapper {
  margin: 10px;
}

#side-bar {
  float: left;
  width: 260px;
  margin: 0px;
}

#report-nav ul {
  list-style-type: none;
  padding: 0;
  margin: 0;
  overflow-y: auto;
  height: 100%;
}

#report-nav ul > li {
  padding: .4em;
  background-color: #fff;
  border-bottom: 1px solid rgba(0,0,0,.125);
  text-align: left;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

#report-nav ul > li.active {
  background-color: #427ea9;
  color: white;
}

#report-nav ul > li:hover {
  background-color: #427ea9;
  color: white;
  cursor: pointer;
}

#report-nav ul a {
  text-decoration: none;
}

#report-nav i[class*="severity-"] {
  margin-right: 5px;
}

.header {
  border-bottom: 1px solid lightgrey;
  font-family: monospace;
  padding: 10px;
  background-color: #fafbfc;
  border-bottom: 1px solid #e1e4e8;
  border-top-left-radius: 2px;
  border-top-right-radius: 2px;
}

#report-nav .header {
  font-weight: bold;
}

#editor-wrapper .header > div {
  padding-top: 2px;
}

#file-path,
#checker-name {
  color: #195ea2;
}

#review-status {
  padding: 0px 5px;
}

#file-path {
  font-family: monospace;
}

.check-msg {
  display: inline-block;
  padding: 3px 6px;
  margin: 1px;
  -webkit-border-radius: 5px;
  -moz-border-radius: 5px;
  border-radius: 5px;
}

.check-msg.info {
  color: #00546f;
  background-color: #bfdfe9;
  border: 1px solid #87a8b3;
}

.check-msg.error {
  background-color: #f2dede;
  color: #a94442;
  border: 1px solid #ebcccc;
}

.check-msg.macro {
  background-color: #d7dac2;
  color: #4f5c6d;
  border: 1px solid #d7dac2;
}

.check-msg.note {
  background-color: #d7d7d7;
  color: #4f5c6d;
  border: 1px solid #bfbfbf;
}

.check-msg.current {
  border: 2px dashed #3692ff;
}

.check-msg .tag {
  padding: 1px 5px;
  text-align: center;
  border-radius: 2px;
  margin-right: 5px;
  text-decoration: inherit;
}

.check-msg .tag.macro {
  background-color: #83876a;
  color: white;
  text-transform: capitalize;
}

.check-msg .tag.note {
  background-color: #9299a1;
  color: white;
  text-transform: capitalize;
}

.checker-enum {
  color: white;
  padding: 1px 5px;
  text-align: center;
  border-radius: 25px;
  margin-right: 5px;
  text-decoration: inherit;
}

.checker-enum.info {
  background-color: #427ea9;
}

.checker-enum.error {
  background-color: #a94442;
}

.arrow {
  border: solid black;
  border-width: 0 3px 3px 0;
  display: inline-block;
  padding: 3px;
  cursor: pointer;
  margin: 0px 5px;
}

.arrow:hover {
  border: solid #437ea8;
  border-width: 0 3px 3px 0;
}

.left-arrow {
  transform: rotate(135deg);
  -webkit-transform: rotate(135deg);
}

.right-arrow {
  transform: rotate(-45deg);
  -webkit-transform: rotate(-45deg);
}

    </style>

    <script type="text/javascript">
      function setNonCompatibleBrowserMessage() {
  document.body.innerHTML =
    '<h2 style="margin-left: 20px;">Your browser is not compatible with CodeChecker Viewer!</h2> \
     <p style="margin-left: 20px;">The version required for the following browsers are:</p> \
     <ul style="margin-left: 20px;"> \
     <li>Internet Explorer: version 9 or newer</li> \
     <li>Firefox: version 22.0 or newer</li> \
     </ul>';
}

// http://stackoverflow.com/questions/5916900/how-can-you-detect-the-version-of-a-browser
var browserVersion = (function(){
  var ua = navigator.userAgent, tem,
    M = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];

  if (/trident/i.test(M[1])) {
    tem = /\brv[ :]+(\d+)/g.exec(ua) || [];
    return 'IE ' + (tem[1] || '');
  }

  if (M[1] === 'Chrome') {
    tem = ua.match(/\b(OPR|Edge)\/(\d+)/);
    if (tem != null) return tem.slice(1).join(' ').replace('OPR', 'Opera');
  }

  M = M[2] ? [M[1], M[2]] : [navigator.appName, navigator.appVersion, '-?'];
  if ((tem = ua.match(/version\/(\d+)/i)) != null) M.splice(1, 1, tem[1]);
    return M.join(' ');
})();

var pos = browserVersion.indexOf(' ');
var browser = browserVersion.substr(0, pos);
var version = parseInt(browserVersion.substr(pos + 1));

var browserCompatible
  = browser === 'Firefox'
  ? version >= 22
  : browser === 'IE'
  ? version >= 9
  : true;


      /* MIT License

Copyright (C) 2017 by Marijn Haverbeke <marijnh@gmail.com> and others

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
 */
      !function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):e.CodeMirror=t()}(this,function(){"use strict";function e(e){return new RegExp("(^|\\s)"+e+"(?:$|\\s)\\s*")}function t(e){for(var t=e.childNodes.length;t>0;--t)e.removeChild(e.firstChild);return e}function r(e,r){return t(e).appendChild(r)}function n(e,t,r,n){var i=document.createElement(e);if(r&&(i.className=r),n&&(i.style.cssText=n),"string"==typeof t)i.appendChild(document.createTextNode(t));else if(t)for(var o=0;o<t.length;++o)i.appendChild(t[o]);return i}function i(e,t,r,i){var o=n(e,t,r,i);return o.setAttribute("role","presentation"),o}function o(e,t){if(3==t.nodeType&&(t=t.parentNode),e.contains)return e.contains(t);do{if(11==t.nodeType&&(t=t.host),t==e)return!0}while(t=t.parentNode)}function l(){var e;try{e=document.activeElement}catch(t){e=document.body||null}for(;e&&e.shadowRoot&&e.shadowRoot.activeElement;)e=e.shadowRoot.activeElement;return e}function s(t,r){var n=t.className;e(r).test(n)||(t.className+=(n?" ":"")+r)}function a(t,r){for(var n=t.split(" "),i=0;i<n.length;i++)n[i]&&!e(n[i]).test(r)&&(r+=" "+n[i]);return r}function u(e){var t=Array.prototype.slice.call(arguments,1);return function(){return e.apply(null,t)}}function c(e,t,r){t||(t={});for(var n in e)!e.hasOwnProperty(n)||!1===r&&t.hasOwnProperty(n)||(t[n]=e[n]);return t}function f(e,t,r,n,i){null==t&&-1==(t=e.search(/[^\s\u00a0]/))&&(t=e.length);for(var o=n||0,l=i||0;;){var s=e.indexOf("\t",o);if(s<0||s>=t)return l+(t-o);l+=s-o,l+=r-l%r,o=s+1}}function h(e,t){for(var r=0;r<e.length;++r)if(e[r]==t)return r;return-1}function d(e,t,r){for(var n=0,i=0;;){var o=e.indexOf("\t",n);-1==o&&(o=e.length);var l=o-n;if(o==e.length||i+l>=t)return n+Math.min(l,t-i);if(i+=o-n,i+=r-i%r,n=o+1,i>=t)return n}}function p(e){for(;Kl.length<=e;)Kl.push(g(Kl)+" ");return Kl[e]}function g(e){return e[e.length-1]}function v(e,t){for(var r=[],n=0;n<e.length;n++)r[n]=t(e[n],n);return r}function m(e,t,r){for(var n=0,i=r(t);n<e.length&&r(e[n])<=i;)n++;e.splice(n,0,t)}function y(){}function b(e,t){var r;return Object.create?r=Object.create(e):(y.prototype=e,r=new y),t&&c(t,r),r}function w(e){return/\w/.test(e)||e>""&&(e.toUpperCase()!=e.toLowerCase()||jl.test(e))}function x(e,t){return t?!!(t.source.indexOf("\\w")>-1&&w(e))||t.test(e):w(e)}function C(e){for(var t in e)if(e.hasOwnProperty(t)&&e[t])return!1;return!0}function S(e){return e.charCodeAt(0)>=768&&Xl.test(e)}function L(e,t,r){for(;(r<0?t>0:t<e.length)&&S(e.charAt(t));)t+=r;return t}function k(e,t,r){for(var n=t>r?-1:1;;){if(t==r)return t;var i=(t+r)/2,o=n<0?Math.ceil(i):Math.floor(i);if(o==t)return e(o)?t:r;e(o)?r=o:t=o+n}}function T(e,t,r){var o=this;this.input=r,o.scrollbarFiller=n("div",null,"CodeMirror-scrollbar-filler"),o.scrollbarFiller.setAttribute("cm-not-content","true"),o.gutterFiller=n("div",null,"CodeMirror-gutter-filler"),o.gutterFiller.setAttribute("cm-not-content","true"),o.lineDiv=i("div",null,"CodeMirror-code"),o.selectionDiv=n("div",null,null,"position: relative; z-index: 1"),o.cursorDiv=n("div",null,"CodeMirror-cursors"),o.measure=n("div",null,"CodeMirror-measure"),o.lineMeasure=n("div",null,"CodeMirror-measure"),o.lineSpace=i("div",[o.measure,o.lineMeasure,o.selectionDiv,o.cursorDiv,o.lineDiv],null,"position: relative; outline: none");var l=i("div",[o.lineSpace],"CodeMirror-lines");o.mover=n("div",[l],null,"position: relative"),o.sizer=n("div",[o.mover],"CodeMirror-sizer"),o.sizerWidth=null,o.heightForcer=n("div",null,null,"position: absolute; height: "+Rl+"px; width: 1px;"),o.gutters=n("div",null,"CodeMirror-gutters"),o.lineGutter=null,o.scroller=n("div",[o.sizer,o.heightForcer,o.gutters],"CodeMirror-scroll"),o.scroller.setAttribute("tabIndex","-1"),o.wrapper=n("div",[o.scrollbarFiller,o.gutterFiller,o.scroller],"CodeMirror"),gl&&vl<8&&(o.gutters.style.zIndex=-1,o.scroller.style.paddingRight=0),ml||fl&&Tl||(o.scroller.draggable=!0),e&&(e.appendChild?e.appendChild(o.wrapper):e(o.wrapper)),o.viewFrom=o.viewTo=t.first,o.reportedViewFrom=o.reportedViewTo=t.first,o.view=[],o.renderedView=null,o.externalMeasured=null,o.viewOffset=0,o.lastWrapHeight=o.lastWrapWidth=0,o.updateLineNumbers=null,o.nativeBarWidth=o.barHeight=o.barWidth=0,o.scrollbarsClipped=!1,o.lineNumWidth=o.lineNumInnerWidth=o.lineNumChars=null,o.alignWidgets=!1,o.cachedCharWidth=o.cachedTextHeight=o.cachedPaddingH=null,o.maxLine=null,o.maxLineLength=0,o.maxLineChanged=!1,o.wheelDX=o.wheelDY=o.wheelStartX=o.wheelStartY=null,o.shift=!1,o.selForContextMenu=null,o.activeTouch=null,r.init(o)}function M(e,t){if((t-=e.first)<0||t>=e.size)throw new Error("There is no line "+(t+e.first)+" in the document.");for(var r=e;!r.lines;)for(var n=0;;++n){var i=r.children[n],o=i.chunkSize();if(t<o){r=i;break}t-=o}return r.lines[t]}function N(e,t,r){var n=[],i=t.line;return e.iter(t.line,r.line+1,function(e){var o=e.text;i==r.line&&(o=o.slice(0,r.ch)),i==t.line&&(o=o.slice(t.ch)),n.push(o),++i}),n}function O(e,t,r){var n=[];return e.iter(t,r,function(e){n.push(e.text)}),n}function A(e,t){var r=t-e.height;if(r)for(var n=e;n;n=n.parent)n.height+=r}function W(e){if(null==e.parent)return null;for(var t=e.parent,r=h(t.lines,e),n=t.parent;n;t=n,n=n.parent)for(var i=0;n.children[i]!=t;++i)r+=n.children[i].chunkSize();return r+t.first}function D(e,t){var r=e.first;e:do{for(var n=0;n<e.children.length;++n){var i=e.children[n],o=i.height;if(t<o){e=i;continue e}t-=o,r+=i.chunkSize()}return r}while(!e.lines);for(var l=0;l<e.lines.length;++l){var s=e.lines[l].height;if(t<s)break;t-=s}return r+l}function H(e,t){return t>=e.first&&t<e.first+e.size}function F(e,t){return String(e.lineNumberFormatter(t+e.firstLineNumber))}function E(e,t,r){if(void 0===r&&(r=null),!(this instanceof E))return new E(e,t,r);this.line=e,this.ch=t,this.sticky=r}function P(e,t){return e.line-t.line||e.ch-t.ch}function I(e,t){return e.sticky==t.sticky&&0==P(e,t)}function z(e){return E(e.line,e.ch)}function R(e,t){return P(e,t)<0?t:e}function B(e,t){return P(e,t)<0?e:t}function G(e,t){return Math.max(e.first,Math.min(t,e.first+e.size-1))}function U(e,t){if(t.line<e.first)return E(e.first,0);var r=e.first+e.size-1;return t.line>r?E(r,M(e,r).text.length):V(t,M(e,t.line).text.length)}function V(e,t){var r=e.ch;return null==r||r>t?E(e.line,t):r<0?E(e.line,0):e}function K(e,t){for(var r=[],n=0;n<t.length;n++)r[n]=U(e,t[n]);return r}function j(){Yl=!0}function X(){_l=!0}function Y(e,t,r){this.marker=e,this.from=t,this.to=r}function _(e,t){if(e)for(var r=0;r<e.length;++r){var n=e[r];if(n.marker==t)return n}}function $(e,t){for(var r,n=0;n<e.length;++n)e[n]!=t&&(r||(r=[])).push(e[n]);return r}function q(e,t){e.markedSpans=e.markedSpans?e.markedSpans.concat([t]):[t],t.marker.attachLine(e)}function Z(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t)||o.from==t&&"bookmark"==l.type&&(!r||!o.marker.insertLeft)){var s=null==o.to||(l.inclusiveRight?o.to>=t:o.to>t);(n||(n=[])).push(new Y(l,o.from,s?null:o.to))}}return n}function Q(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.to||(l.inclusiveRight?o.to>=t:o.to>t)||o.from==t&&"bookmark"==l.type&&(!r||o.marker.insertLeft)){var s=null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t);(n||(n=[])).push(new Y(l,s?null:o.from-t,null==o.to?null:o.to-t))}}return n}function J(e,t){if(t.full)return null;var r=H(e,t.from.line)&&M(e,t.from.line).markedSpans,n=H(e,t.to.line)&&M(e,t.to.line).markedSpans;if(!r&&!n)return null;var i=t.from.ch,o=t.to.ch,l=0==P(t.from,t.to),s=Z(r,i,l),a=Q(n,o,l),u=1==t.text.length,c=g(t.text).length+(u?i:0);if(s)for(var f=0;f<s.length;++f){var h=s[f];if(null==h.to){var d=_(a,h.marker);d?u&&(h.to=null==d.to?null:d.to+c):h.to=i}}if(a)for(var p=0;p<a.length;++p){var v=a[p];null!=v.to&&(v.to+=c),null==v.from?_(s,v.marker)||(v.from=c,u&&(s||(s=[])).push(v)):(v.from+=c,u&&(s||(s=[])).push(v))}s&&(s=ee(s)),a&&a!=s&&(a=ee(a));var m=[s];if(!u){var y,b=t.text.length-2;if(b>0&&s)for(var w=0;w<s.length;++w)null==s[w].to&&(y||(y=[])).push(new Y(s[w].marker,null,null));for(var x=0;x<b;++x)m.push(y);m.push(a)}return m}function ee(e){for(var t=0;t<e.length;++t){var r=e[t];null!=r.from&&r.from==r.to&&!1!==r.marker.clearWhenEmpty&&e.splice(t--,1)}return e.length?e:null}function te(e,t,r){var n=null;if(e.iter(t.line,r.line+1,function(e){if(e.markedSpans)for(var t=0;t<e.markedSpans.length;++t){var r=e.markedSpans[t].marker;!r.readOnly||n&&-1!=h(n,r)||(n||(n=[])).push(r)}}),!n)return null;for(var i=[{from:t,to:r}],o=0;o<n.length;++o)for(var l=n[o],s=l.find(0),a=0;a<i.length;++a){var u=i[a];if(!(P(u.to,s.from)<0||P(u.from,s.to)>0)){var c=[a,1],f=P(u.from,s.from),d=P(u.to,s.to);(f<0||!l.inclusiveLeft&&!f)&&c.push({from:u.from,to:s.from}),(d>0||!l.inclusiveRight&&!d)&&c.push({from:s.to,to:u.to}),i.splice.apply(i,c),a+=c.length-3}}return i}function re(e){var t=e.markedSpans;if(t){for(var r=0;r<t.length;++r)t[r].marker.detachLine(e);e.markedSpans=null}}function ne(e,t){if(t){for(var r=0;r<t.length;++r)t[r].marker.attachLine(e);e.markedSpans=t}}function ie(e){return e.inclusiveLeft?-1:0}function oe(e){return e.inclusiveRight?1:0}function le(e,t){var r=e.lines.length-t.lines.length;if(0!=r)return r;var n=e.find(),i=t.find(),o=P(n.from,i.from)||ie(e)-ie(t);if(o)return-o;var l=P(n.to,i.to)||oe(e)-oe(t);return l||t.id-e.id}function se(e,t){var r,n=_l&&e.markedSpans;if(n)for(var i=void 0,o=0;o<n.length;++o)(i=n[o]).marker.collapsed&&null==(t?i.from:i.to)&&(!r||le(r,i.marker)<0)&&(r=i.marker);return r}function ae(e){return se(e,!0)}function ue(e){return se(e,!1)}function ce(e,t,r,n,i){var o=M(e,t),l=_l&&o.markedSpans;if(l)for(var s=0;s<l.length;++s){var a=l[s];if(a.marker.collapsed){var u=a.marker.find(0),c=P(u.from,r)||ie(a.marker)-ie(i),f=P(u.to,n)||oe(a.marker)-oe(i);if(!(c>=0&&f<=0||c<=0&&f>=0)&&(c<=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.to,r)>=0:P(u.to,r)>0)||c>=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.from,n)<=0:P(u.from,n)<0)))return!0}}}function fe(e){for(var t;t=ae(e);)e=t.find(-1,!0).line;return e}function he(e){for(var t;t=ue(e);)e=t.find(1,!0).line;return e}function de(e){for(var t,r;t=ue(e);)e=t.find(1,!0).line,(r||(r=[])).push(e);return r}function pe(e,t){var r=M(e,t),n=fe(r);return r==n?t:W(n)}function ge(e,t){if(t>e.lastLine())return t;var r,n=M(e,t);if(!ve(e,n))return t;for(;r=ue(n);)n=r.find(1,!0).line;return W(n)+1}function ve(e,t){var r=_l&&t.markedSpans;if(r)for(var n=void 0,i=0;i<r.length;++i)if((n=r[i]).marker.collapsed){if(null==n.from)return!0;if(!n.marker.widgetNode&&0==n.from&&n.marker.inclusiveLeft&&me(e,t,n))return!0}}function me(e,t,r){if(null==r.to){var n=r.marker.find(1,!0);return me(e,n.line,_(n.line.markedSpans,r.marker))}if(r.marker.inclusiveRight&&r.to==t.text.length)return!0;for(var i=void 0,o=0;o<t.markedSpans.length;++o)if((i=t.markedSpans[o]).marker.collapsed&&!i.marker.widgetNode&&i.from==r.to&&(null==i.to||i.to!=r.from)&&(i.marker.inclusiveLeft||r.marker.inclusiveRight)&&me(e,t,i))return!0}function ye(e){for(var t=0,r=(e=fe(e)).parent,n=0;n<r.lines.length;++n){var i=r.lines[n];if(i==e)break;t+=i.height}for(var o=r.parent;o;r=o,o=r.parent)for(var l=0;l<o.children.length;++l){var s=o.children[l];if(s==r)break;t+=s.height}return t}function be(e){if(0==e.height)return 0;for(var t,r=e.text.length,n=e;t=ae(n);){var i=t.find(0,!0);n=i.from.line,r+=i.from.ch-i.to.ch}for(n=e;t=ue(n);){var o=t.find(0,!0);r-=n.text.length-o.from.ch,r+=(n=o.to.line).text.length-o.to.ch}return r}function we(e){var t=e.display,r=e.doc;t.maxLine=M(r,r.first),t.maxLineLength=be(t.maxLine),t.maxLineChanged=!0,r.iter(function(e){var r=be(e);r>t.maxLineLength&&(t.maxLineLength=r,t.maxLine=e)})}function xe(e,t,r,n){if(!e)return n(t,r,"ltr",0);for(var i=!1,o=0;o<e.length;++o){var l=e[o];(l.from<r&&l.to>t||t==r&&l.to==t)&&(n(Math.max(l.from,t),Math.min(l.to,r),1==l.level?"rtl":"ltr",o),i=!0)}i||n(t,r,"ltr")}function Ce(e,t,r){var n;$l=null;for(var i=0;i<e.length;++i){var o=e[i];if(o.from<t&&o.to>t)return i;o.to==t&&(o.from!=o.to&&"before"==r?n=i:$l=i),o.from==t&&(o.from!=o.to&&"before"!=r?n=i:$l=i)}return null!=n?n:$l}function Se(e,t){var r=e.order;return null==r&&(r=e.order=ql(e.text,t)),r}function Le(e,t){return e._handlers&&e._handlers[t]||Zl}function ke(e,t,r){if(e.removeEventListener)e.removeEventListener(t,r,!1);else if(e.detachEvent)e.detachEvent("on"+t,r);else{var n=e._handlers,i=n&&n[t];if(i){var o=h(i,r);o>-1&&(n[t]=i.slice(0,o).concat(i.slice(o+1)))}}}function Te(e,t){var r=Le(e,t);if(r.length)for(var n=Array.prototype.slice.call(arguments,2),i=0;i<r.length;++i)r[i].apply(null,n)}function Me(e,t,r){return"string"==typeof t&&(t={type:t,preventDefault:function(){this.defaultPrevented=!0}}),Te(e,r||t.type,e,t),He(t)||t.codemirrorIgnore}function Ne(e){var t=e._handlers&&e._handlers.cursorActivity;if(t)for(var r=e.curOp.cursorActivityHandlers||(e.curOp.cursorActivityHandlers=[]),n=0;n<t.length;++n)-1==h(r,t[n])&&r.push(t[n])}function Oe(e,t){return Le(e,t).length>0}function Ae(e){e.prototype.on=function(e,t){Ql(this,e,t)},e.prototype.off=function(e,t){ke(this,e,t)}}function We(e){e.preventDefault?e.preventDefault():e.returnValue=!1}function De(e){e.stopPropagation?e.stopPropagation():e.cancelBubble=!0}function He(e){return null!=e.defaultPrevented?e.defaultPrevented:0==e.returnValue}function Fe(e){We(e),De(e)}function Ee(e){return e.target||e.srcElement}function Pe(e){var t=e.which;return null==t&&(1&e.button?t=1:2&e.button?t=3:4&e.button&&(t=2)),Ml&&e.ctrlKey&&1==t&&(t=3),t}function Ie(e){if(null==Il){var t=n("span","​");r(e,n("span",[t,document.createTextNode("x")])),0!=e.firstChild.offsetHeight&&(Il=t.offsetWidth<=1&&t.offsetHeight>2&&!(gl&&vl<8))}var i=Il?n("span","​"):n("span"," ",null,"display: inline-block; width: 1px; margin-right: -1px");return i.setAttribute("cm-text",""),i}function ze(e){if(null!=zl)return zl;var n=r(e,document.createTextNode("AخA")),i=Wl(n,0,1).getBoundingClientRect(),o=Wl(n,1,2).getBoundingClientRect();return t(e),!(!i||i.left==i.right)&&(zl=o.right-i.right<3)}function Re(e){if(null!=ns)return ns;var t=r(e,n("span","x")),i=t.getBoundingClientRect(),o=Wl(t,0,1).getBoundingClientRect();return ns=Math.abs(i.left-o.left)>1}function Be(e,t){arguments.length>2&&(t.dependencies=Array.prototype.slice.call(arguments,2)),is[e]=t}function Ge(e){if("string"==typeof e&&os.hasOwnProperty(e))e=os[e];else if(e&&"string"==typeof e.name&&os.hasOwnProperty(e.name)){var t=os[e.name];"string"==typeof t&&(t={name:t}),(e=b(t,e)).name=t.name}else{if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+xml$/.test(e))return Ge("application/xml");if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+json$/.test(e))return Ge("application/json")}return"string"==typeof e?{name:e}:e||{name:"null"}}function Ue(e,t){t=Ge(t);var r=is[t.name];if(!r)return Ue(e,"text/plain");var n=r(e,t);if(ls.hasOwnProperty(t.name)){var i=ls[t.name];for(var o in i)i.hasOwnProperty(o)&&(n.hasOwnProperty(o)&&(n["_"+o]=n[o]),n[o]=i[o])}if(n.name=t.name,t.helperType&&(n.helperType=t.helperType),t.modeProps)for(var l in t.modeProps)n[l]=t.modeProps[l];return n}function Ve(e,t){c(t,ls.hasOwnProperty(e)?ls[e]:ls[e]={})}function Ke(e,t){if(!0===t)return t;if(e.copyState)return e.copyState(t);var r={};for(var n in t){var i=t[n];i instanceof Array&&(i=i.concat([])),r[n]=i}return r}function je(e,t){for(var r;e.innerMode&&(r=e.innerMode(t))&&r.mode!=e;)t=r.state,e=r.mode;return r||{mode:e,state:t}}function Xe(e,t,r){return!e.startState||e.startState(t,r)}function Ye(e,t,r,n){var i=[e.state.modeGen],o={};tt(e,t.text,e.doc.mode,r,function(e,t){return i.push(e,t)},o,n);for(var l=r.state,s=0;s<e.state.overlays.length;++s)!function(n){var l=e.state.overlays[n],s=1,a=0;r.state=!0,tt(e,t.text,l.mode,r,function(e,t){for(var r=s;a<e;){var n=i[s];n>e&&i.splice(s,1,e,i[s+1],n),s+=2,a=Math.min(e,n)}if(t)if(l.opaque)i.splice(r,s-r,e,"overlay "+t),s=r+2;else for(;r<s;r+=2){var o=i[r+1];i[r+1]=(o?o+" ":"")+"overlay "+t}},o)}(s);return r.state=l,{styles:i,classes:o.bgClass||o.textClass?o:null}}function _e(e,t,r){if(!t.styles||t.styles[0]!=e.state.modeGen){var n=$e(e,W(t)),i=t.text.length>e.options.maxHighlightLength&&Ke(e.doc.mode,n.state),o=Ye(e,t,n);i&&(n.state=i),t.stateAfter=n.save(!i),t.styles=o.styles,o.classes?t.styleClasses=o.classes:t.styleClasses&&(t.styleClasses=null),r===e.doc.highlightFrontier&&(e.doc.modeFrontier=Math.max(e.doc.modeFrontier,++e.doc.highlightFrontier))}return t.styles}function $e(e,t,r){var n=e.doc,i=e.display;if(!n.mode.startState)return new us(n,!0,t);var o=rt(e,t,r),l=o>n.first&&M(n,o-1).stateAfter,s=l?us.fromSaved(n,l,o):new us(n,Xe(n.mode),o);return n.iter(o,t,function(r){qe(e,r.text,s);var n=s.line;r.stateAfter=n==t-1||n%5==0||n>=i.viewFrom&&n<i.viewTo?s.save():null,s.nextLine()}),r&&(n.modeFrontier=s.line),s}function qe(e,t,r,n){var i=e.doc.mode,o=new ss(t,e.options.tabSize,r);for(o.start=o.pos=n||0,""==t&&Ze(i,r.state);!o.eol();)Qe(i,o,r.state),o.start=o.pos}function Ze(e,t){if(e.blankLine)return e.blankLine(t);if(e.innerMode){var r=je(e,t);return r.mode.blankLine?r.mode.blankLine(r.state):void 0}}function Qe(e,t,r,n){for(var i=0;i<10;i++){n&&(n[0]=je(e,r).mode);var o=e.token(t,r);if(t.pos>t.start)return o}throw new Error("Mode "+e.name+" failed to advance stream.")}function Je(e,t,r,n){var i,o,l=e.doc,s=l.mode,a=M(l,(t=U(l,t)).line),u=$e(e,t.line,r),c=new ss(a.text,e.options.tabSize,u);for(n&&(o=[]);(n||c.pos<t.ch)&&!c.eol();)c.start=c.pos,i=Qe(s,c,u.state),n&&o.push(new cs(c,i,Ke(l.mode,u.state)));return n?o:new cs(c,i,u.state)}function et(e,t){if(e)for(;;){var r=e.match(/(?:^|\s+)line-(background-)?(\S+)/);if(!r)break;e=e.slice(0,r.index)+e.slice(r.index+r[0].length);var n=r[1]?"bgClass":"textClass";null==t[n]?t[n]=r[2]:new RegExp("(?:^|s)"+r[2]+"(?:$|s)").test(t[n])||(t[n]+=" "+r[2])}return e}function tt(e,t,r,n,i,o,l){var s=r.flattenSpans;null==s&&(s=e.options.flattenSpans);var a,u=0,c=null,f=new ss(t,e.options.tabSize,n),h=e.options.addModeClass&&[null];for(""==t&&et(Ze(r,n.state),o);!f.eol();){if(f.pos>e.options.maxHighlightLength?(s=!1,l&&qe(e,t,n,f.pos),f.pos=t.length,a=null):a=et(Qe(r,f,n.state,h),o),h){var d=h[0].name;d&&(a="m-"+(a?d+" "+a:d))}if(!s||c!=a){for(;u<f.start;)i(u=Math.min(f.start,u+5e3),c);c=a}f.start=f.pos}for(;u<f.pos;){var p=Math.min(f.pos,u+5e3);i(p,c),u=p}}function rt(e,t,r){for(var n,i,o=e.doc,l=r?-1:t-(e.doc.mode.innerMode?1e3:100),s=t;s>l;--s){if(s<=o.first)return o.first;var a=M(o,s-1),u=a.stateAfter;if(u&&(!r||s+(u instanceof as?u.lookAhead:0)<=o.modeFrontier))return s;var c=f(a.text,null,e.options.tabSize);(null==i||n>c)&&(i=s-1,n=c)}return i}function nt(e,t){if(e.modeFrontier=Math.min(e.modeFrontier,t),!(e.highlightFrontier<t-10)){for(var r=e.first,n=t-1;n>r;n--){var i=M(e,n).stateAfter;if(i&&(!(i instanceof as)||n+i.lookAhead<t)){r=n+1;break}}e.highlightFrontier=Math.min(e.highlightFrontier,r)}}function it(e,t,r,n){e.text=t,e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null),null!=e.order&&(e.order=null),re(e),ne(e,r);var i=n?n(e):1;i!=e.height&&A(e,i)}function ot(e){e.parent=null,re(e)}function lt(e,t){if(!e||/^\s*$/.test(e))return null;var r=t.addModeClass?ps:ds;return r[e]||(r[e]=e.replace(/\S+/g,"cm-$&"))}function st(e,t){var r=i("span",null,null,ml?"padding-right: .1px":null),n={pre:i("pre",[r],"CodeMirror-line"),content:r,col:0,pos:0,cm:e,trailingSpace:!1,splitSpaces:(gl||ml)&&e.getOption("lineWrapping")};t.measure={};for(var o=0;o<=(t.rest?t.rest.length:0);o++){var l=o?t.rest[o-1]:t.line,s=void 0;n.pos=0,n.addToken=ut,ze(e.display.measure)&&(s=Se(l,e.doc.direction))&&(n.addToken=ft(n.addToken,s)),n.map=[],dt(l,n,_e(e,l,t!=e.display.externalMeasured&&W(l))),l.styleClasses&&(l.styleClasses.bgClass&&(n.bgClass=a(l.styleClasses.bgClass,n.bgClass||"")),l.styleClasses.textClass&&(n.textClass=a(l.styleClasses.textClass,n.textClass||""))),0==n.map.length&&n.map.push(0,0,n.content.appendChild(Ie(e.display.measure))),0==o?(t.measure.map=n.map,t.measure.cache={}):((t.measure.maps||(t.measure.maps=[])).push(n.map),(t.measure.caches||(t.measure.caches=[])).push({}))}if(ml){var u=n.content.lastChild;(/\bcm-tab\b/.test(u.className)||u.querySelector&&u.querySelector(".cm-tab"))&&(n.content.className="cm-tab-wrap-hack")}return Te(e,"renderLine",e,t.line,n.pre),n.pre.className&&(n.textClass=a(n.pre.className,n.textClass||"")),n}function at(e){var t=n("span","•","cm-invalidchar");return t.title="\\u"+e.charCodeAt(0).toString(16),t.setAttribute("aria-label",t.title),t}function ut(e,t,r,i,o,l,s){if(t){var a,u=e.splitSpaces?ct(t,e.trailingSpace):t,c=e.cm.state.specialChars,f=!1;if(c.test(t)){a=document.createDocumentFragment();for(var h=0;;){c.lastIndex=h;var d=c.exec(t),g=d?d.index-h:t.length-h;if(g){var v=document.createTextNode(u.slice(h,h+g));gl&&vl<9?a.appendChild(n("span",[v])):a.appendChild(v),e.map.push(e.pos,e.pos+g,v),e.col+=g,e.pos+=g}if(!d)break;h+=g+1;var m=void 0;if("\t"==d[0]){var y=e.cm.options.tabSize,b=y-e.col%y;(m=a.appendChild(n("span",p(b),"cm-tab"))).setAttribute("role","presentation"),m.setAttribute("cm-text","\t"),e.col+=b}else"\r"==d[0]||"\n"==d[0]?((m=a.appendChild(n("span","\r"==d[0]?"␍":"␤","cm-invalidchar"))).setAttribute("cm-text",d[0]),e.col+=1):((m=e.cm.options.specialCharPlaceholder(d[0])).setAttribute("cm-text",d[0]),gl&&vl<9?a.appendChild(n("span",[m])):a.appendChild(m),e.col+=1);e.map.push(e.pos,e.pos+1,m),e.pos++}}else e.col+=t.length,a=document.createTextNode(u),e.map.push(e.pos,e.pos+t.length,a),gl&&vl<9&&(f=!0),e.pos+=t.length;if(e.trailingSpace=32==u.charCodeAt(t.length-1),r||i||o||f||s){var w=r||"";i&&(w+=i),o&&(w+=o);var x=n("span",[a],w,s);return l&&(x.title=l),e.content.appendChild(x)}e.content.appendChild(a)}}function ct(e,t){if(e.length>1&&!/  /.test(e))return e;for(var r=t,n="",i=0;i<e.length;i++){var o=e.charAt(i);" "!=o||!r||i!=e.length-1&&32!=e.charCodeAt(i+1)||(o=" "),n+=o,r=" "==o}return n}function ft(e,t){return function(r,n,i,o,l,s,a){i=i?i+" cm-force-border":"cm-force-border";for(var u=r.pos,c=u+n.length;;){for(var f=void 0,h=0;h<t.length&&!((f=t[h]).to>u&&f.from<=u);h++);if(f.to>=c)return e(r,n,i,o,l,s,a);e(r,n.slice(0,f.to-u),i,o,null,s,a),o=null,n=n.slice(f.to-u),u=f.to}}}function ht(e,t,r,n){var i=!n&&r.widgetNode;i&&e.map.push(e.pos,e.pos+t,i),!n&&e.cm.display.input.needsContentAttribute&&(i||(i=e.content.appendChild(document.createElement("span"))),i.setAttribute("cm-marker",r.id)),i&&(e.cm.display.input.setUneditable(i),e.content.appendChild(i)),e.pos+=t,e.trailingSpace=!1}function dt(e,t,r){var n=e.markedSpans,i=e.text,o=0;if(n)for(var l,s,a,u,c,f,h,d=i.length,p=0,g=1,v="",m=0;;){if(m==p){a=u=c=f=s="",h=null,m=1/0;for(var y=[],b=void 0,w=0;w<n.length;++w){var x=n[w],C=x.marker;"bookmark"==C.type&&x.from==p&&C.widgetNode?y.push(C):x.from<=p&&(null==x.to||x.to>p||C.collapsed&&x.to==p&&x.from==p)?(null!=x.to&&x.to!=p&&m>x.to&&(m=x.to,u=""),C.className&&(a+=" "+C.className),C.css&&(s=(s?s+";":"")+C.css),C.startStyle&&x.from==p&&(c+=" "+C.startStyle),C.endStyle&&x.to==m&&(b||(b=[])).push(C.endStyle,x.to),C.title&&!f&&(f=C.title),C.collapsed&&(!h||le(h.marker,C)<0)&&(h=x)):x.from>p&&m>x.from&&(m=x.from)}if(b)for(var S=0;S<b.length;S+=2)b[S+1]==m&&(u+=" "+b[S]);if(!h||h.from==p)for(var L=0;L<y.length;++L)ht(t,0,y[L]);if(h&&(h.from||0)==p){if(ht(t,(null==h.to?d+1:h.to)-p,h.marker,null==h.from),null==h.to)return;h.to==p&&(h=!1)}}if(p>=d)break;for(var k=Math.min(d,m);;){if(v){var T=p+v.length;if(!h){var M=T>k?v.slice(0,k-p):v;t.addToken(t,M,l?l+a:a,c,p+M.length==m?u:"",f,s)}if(T>=k){v=v.slice(k-p),p=k;break}p=T,c=""}v=i.slice(o,o=r[g++]),l=lt(r[g++],t.cm.options)}}else for(var N=1;N<r.length;N+=2)t.addToken(t,i.slice(o,o=r[N]),lt(r[N+1],t.cm.options))}function pt(e,t,r){this.line=t,this.rest=de(t),this.size=this.rest?W(g(this.rest))-r+1:1,this.node=this.text=null,this.hidden=ve(e,t)}function gt(e,t,r){for(var n,i=[],o=t;o<r;o=n){var l=new pt(e.doc,M(e.doc,o),o);n=o+l.size,i.push(l)}return i}function vt(e){gs?gs.ops.push(e):e.ownsGroup=gs={ops:[e],delayedCallbacks:[]}}function mt(e){var t=e.delayedCallbacks,r=0;do{for(;r<t.length;r++)t[r].call(null);for(var n=0;n<e.ops.length;n++){var i=e.ops[n];if(i.cursorActivityHandlers)for(;i.cursorActivityCalled<i.cursorActivityHandlers.length;)i.cursorActivityHandlers[i.cursorActivityCalled++].call(null,i.cm)}}while(r<t.length)}function yt(e,t){var r=e.ownsGroup;if(r)try{mt(r)}finally{gs=null,t(r)}}function bt(e,t){var r=Le(e,t);if(r.length){var n,i=Array.prototype.slice.call(arguments,2);gs?n=gs.delayedCallbacks:vs?n=vs:(n=vs=[],setTimeout(wt,0));for(var o=0;o<r.length;++o)!function(e){n.push(function(){return r[e].apply(null,i)})}(o)}}function wt(){var e=vs;vs=null;for(var t=0;t<e.length;++t)e[t]()}function xt(e,t,r,n){for(var i=0;i<t.changes.length;i++){var o=t.changes[i];"text"==o?kt(e,t):"gutter"==o?Mt(e,t,r,n):"class"==o?Tt(e,t):"widget"==o&&Nt(e,t,n)}t.changes=null}function Ct(e){return e.node==e.text&&(e.node=n("div",null,null,"position: relative"),e.text.parentNode&&e.text.parentNode.replaceChild(e.node,e.text),e.node.appendChild(e.text),gl&&vl<8&&(e.node.style.zIndex=2)),e.node}function St(e,t){var r=t.bgClass?t.bgClass+" "+(t.line.bgClass||""):t.line.bgClass;if(r&&(r+=" CodeMirror-linebackground"),t.background)r?t.background.className=r:(t.background.parentNode.removeChild(t.background),t.background=null);else if(r){var i=Ct(t);t.background=i.insertBefore(n("div",null,r),i.firstChild),e.display.input.setUneditable(t.background)}}function Lt(e,t){var r=e.display.externalMeasured;return r&&r.line==t.line?(e.display.externalMeasured=null,t.measure=r.measure,r.built):st(e,t)}function kt(e,t){var r=t.text.className,n=Lt(e,t);t.text==t.node&&(t.node=n.pre),t.text.parentNode.replaceChild(n.pre,t.text),t.text=n.pre,n.bgClass!=t.bgClass||n.textClass!=t.textClass?(t.bgClass=n.bgClass,t.textClass=n.textClass,Tt(e,t)):r&&(t.text.className=r)}function Tt(e,t){St(e,t),t.line.wrapClass?Ct(t).className=t.line.wrapClass:t.node!=t.text&&(t.node.className="");var r=t.textClass?t.textClass+" "+(t.line.textClass||""):t.line.textClass;t.text.className=r||""}function Mt(e,t,r,i){if(t.gutter&&(t.node.removeChild(t.gutter),t.gutter=null),t.gutterBackground&&(t.node.removeChild(t.gutterBackground),t.gutterBackground=null),t.line.gutterClass){var o=Ct(t);t.gutterBackground=n("div",null,"CodeMirror-gutter-background "+t.line.gutterClass,"left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px; width: "+i.gutterTotalWidth+"px"),e.display.input.setUneditable(t.gutterBackground),o.insertBefore(t.gutterBackground,t.text)}var l=t.line.gutterMarkers;if(e.options.lineNumbers||l){var s=Ct(t),a=t.gutter=n("div",null,"CodeMirror-gutter-wrapper","left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px");if(e.display.input.setUneditable(a),s.insertBefore(a,t.text),t.line.gutterClass&&(a.className+=" "+t.line.gutterClass),!e.options.lineNumbers||l&&l["CodeMirror-linenumbers"]||(t.lineNumber=a.appendChild(n("div",F(e.options,r),"CodeMirror-linenumber CodeMirror-gutter-elt","left: "+i.gutterLeft["CodeMirror-linenumbers"]+"px; width: "+e.display.lineNumInnerWidth+"px"))),l)for(var u=0;u<e.options.gutters.length;++u){var c=e.options.gutters[u],f=l.hasOwnProperty(c)&&l[c];f&&a.appendChild(n("div",[f],"CodeMirror-gutter-elt","left: "+i.gutterLeft[c]+"px; width: "+i.gutterWidth[c]+"px"))}}}function Nt(e,t,r){t.alignable&&(t.alignable=null);for(var n=t.node.firstChild,i=void 0;n;n=i)i=n.nextSibling,"CodeMirror-linewidget"==n.className&&t.node.removeChild(n);At(e,t,r)}function Ot(e,t,r,n){var i=Lt(e,t);return t.text=t.node=i.pre,i.bgClass&&(t.bgClass=i.bgClass),i.textClass&&(t.textClass=i.textClass),Tt(e,t),Mt(e,t,r,n),At(e,t,n),t.node}function At(e,t,r){if(Wt(e,t.line,t,r,!0),t.rest)for(var n=0;n<t.rest.length;n++)Wt(e,t.rest[n],t,r,!1)}function Wt(e,t,r,i,o){if(t.widgets)for(var l=Ct(r),s=0,a=t.widgets;s<a.length;++s){var u=a[s],c=n("div",[u.node],"CodeMirror-linewidget");u.handleMouseEvents||c.setAttribute("cm-ignore-events","true"),Dt(u,c,r,i),e.display.input.setUneditable(c),o&&u.above?l.insertBefore(c,r.gutter||r.text):l.appendChild(c),bt(u,"redraw")}}function Dt(e,t,r,n){if(e.noHScroll){(r.alignable||(r.alignable=[])).push(t);var i=n.wrapperWidth;t.style.left=n.fixedPos+"px",e.coverGutter||(i-=n.gutterTotalWidth,t.style.paddingLeft=n.gutterTotalWidth+"px"),t.style.width=i+"px"}e.coverGutter&&(t.style.zIndex=5,t.style.position="relative",e.noHScroll||(t.style.marginLeft=-n.gutterTotalWidth+"px"))}function Ht(e){if(null!=e.height)return e.height;var t=e.doc.cm;if(!t)return 0;if(!o(document.body,e.node)){var i="position: relative;";e.coverGutter&&(i+="margin-left: -"+t.display.gutters.offsetWidth+"px;"),e.noHScroll&&(i+="width: "+t.display.wrapper.clientWidth+"px;"),r(t.display.measure,n("div",[e.node],null,i))}return e.height=e.node.parentNode.offsetHeight}function Ft(e,t){for(var r=Ee(t);r!=e.wrapper;r=r.parentNode)if(!r||1==r.nodeType&&"true"==r.getAttribute("cm-ignore-events")||r.parentNode==e.sizer&&r!=e.mover)return!0}function Et(e){return e.lineSpace.offsetTop}function Pt(e){return e.mover.offsetHeight-e.lineSpace.offsetHeight}function It(e){if(e.cachedPaddingH)return e.cachedPaddingH;var t=r(e.measure,n("pre","x")),i=window.getComputedStyle?window.getComputedStyle(t):t.currentStyle,o={left:parseInt(i.paddingLeft),right:parseInt(i.paddingRight)};return isNaN(o.left)||isNaN(o.right)||(e.cachedPaddingH=o),o}function zt(e){return Rl-e.display.nativeBarWidth}function Rt(e){return e.display.scroller.clientWidth-zt(e)-e.display.barWidth}function Bt(e){return e.display.scroller.clientHeight-zt(e)-e.display.barHeight}function Gt(e,t,r){var n=e.options.lineWrapping,i=n&&Rt(e);if(!t.measure.heights||n&&t.measure.width!=i){var o=t.measure.heights=[];if(n){t.measure.width=i;for(var l=t.text.firstChild.getClientRects(),s=0;s<l.length-1;s++){var a=l[s],u=l[s+1];Math.abs(a.bottom-u.bottom)>2&&o.push((a.bottom+u.top)/2-r.top)}}o.push(r.bottom-r.top)}}function Ut(e,t,r){if(e.line==t)return{map:e.measure.map,cache:e.measure.cache};for(var n=0;n<e.rest.length;n++)if(e.rest[n]==t)return{map:e.measure.maps[n],cache:e.measure.caches[n]};for(var i=0;i<e.rest.length;i++)if(W(e.rest[i])>r)return{map:e.measure.maps[i],cache:e.measure.caches[i],before:!0}}function Vt(e,t){var n=W(t=fe(t)),i=e.display.externalMeasured=new pt(e.doc,t,n);i.lineN=n;var o=i.built=st(e,i);return i.text=o.pre,r(e.display.lineMeasure,o.pre),i}function Kt(e,t,r,n){return Yt(e,Xt(e,t),r,n)}function jt(e,t){if(t>=e.display.viewFrom&&t<e.display.viewTo)return e.display.view[Lr(e,t)];var r=e.display.externalMeasured;return r&&t>=r.lineN&&t<r.lineN+r.size?r:void 0}function Xt(e,t){var r=W(t),n=jt(e,r);n&&!n.text?n=null:n&&n.changes&&(xt(e,n,r,br(e)),e.curOp.forceUpdate=!0),n||(n=Vt(e,t));var i=Ut(n,t,r);return{line:t,view:n,rect:null,map:i.map,cache:i.cache,before:i.before,hasHeights:!1}}function Yt(e,t,r,n,i){t.before&&(r=-1);var o,l=r+(n||"");return t.cache.hasOwnProperty(l)?o=t.cache[l]:(t.rect||(t.rect=t.view.text.getBoundingClientRect()),t.hasHeights||(Gt(e,t.view,t.rect),t.hasHeights=!0),(o=qt(e,t,r,n)).bogus||(t.cache[l]=o)),{left:o.left,right:o.right,top:i?o.rtop:o.top,bottom:i?o.rbottom:o.bottom}}function _t(e,t,r){for(var n,i,o,l,s,a,u=0;u<e.length;u+=3)if(s=e[u],a=e[u+1],t<s?(i=0,o=1,l="left"):t<a?o=(i=t-s)+1:(u==e.length-3||t==a&&e[u+3]>t)&&(i=(o=a-s)-1,t>=a&&(l="right")),null!=i){if(n=e[u+2],s==a&&r==(n.insertLeft?"left":"right")&&(l=r),"left"==r&&0==i)for(;u&&e[u-2]==e[u-3]&&e[u-1].insertLeft;)n=e[2+(u-=3)],l="left";if("right"==r&&i==a-s)for(;u<e.length-3&&e[u+3]==e[u+4]&&!e[u+5].insertLeft;)n=e[(u+=3)+2],l="right";break}return{node:n,start:i,end:o,collapse:l,coverStart:s,coverEnd:a}}function $t(e,t){var r=ms;if("left"==t)for(var n=0;n<e.length&&(r=e[n]).left==r.right;n++);else for(var i=e.length-1;i>=0&&(r=e[i]).left==r.right;i--);return r}function qt(e,t,r,n){var i,o=_t(t.map,r,n),l=o.node,s=o.start,a=o.end,u=o.collapse;if(3==l.nodeType){for(var c=0;c<4;c++){for(;s&&S(t.line.text.charAt(o.coverStart+s));)--s;for(;o.coverStart+a<o.coverEnd&&S(t.line.text.charAt(o.coverStart+a));)++a;if((i=gl&&vl<9&&0==s&&a==o.coverEnd-o.coverStart?l.parentNode.getBoundingClientRect():$t(Wl(l,s,a).getClientRects(),n)).left||i.right||0==s)break;a=s,s-=1,u="right"}gl&&vl<11&&(i=Zt(e.display.measure,i))}else{s>0&&(u=n="right");var f;i=e.options.lineWrapping&&(f=l.getClientRects()).length>1?f["right"==n?f.length-1:0]:l.getBoundingClientRect()}if(gl&&vl<9&&!s&&(!i||!i.left&&!i.right)){var h=l.parentNode.getClientRects()[0];i=h?{left:h.left,right:h.left+yr(e.display),top:h.top,bottom:h.bottom}:ms}for(var d=i.top-t.rect.top,p=i.bottom-t.rect.top,g=(d+p)/2,v=t.view.measure.heights,m=0;m<v.length-1&&!(g<v[m]);m++);var y=m?v[m-1]:0,b=v[m],w={left:("right"==u?i.right:i.left)-t.rect.left,right:("left"==u?i.left:i.right)-t.rect.left,top:y,bottom:b};return i.left||i.right||(w.bogus=!0),e.options.singleCursorHeightPerLine||(w.rtop=d,w.rbottom=p),w}function Zt(e,t){if(!window.screen||null==screen.logicalXDPI||screen.logicalXDPI==screen.deviceXDPI||!Re(e))return t;var r=screen.logicalXDPI/screen.deviceXDPI,n=screen.logicalYDPI/screen.deviceYDPI;return{left:t.left*r,right:t.right*r,top:t.top*n,bottom:t.bottom*n}}function Qt(e){if(e.measure&&(e.measure.cache={},e.measure.heights=null,e.rest))for(var t=0;t<e.rest.length;t++)e.measure.caches[t]={}}function Jt(e){e.display.externalMeasure=null,t(e.display.lineMeasure);for(var r=0;r<e.display.view.length;r++)Qt(e.display.view[r])}function er(e){Jt(e),e.display.cachedCharWidth=e.display.cachedTextHeight=e.display.cachedPaddingH=null,e.options.lineWrapping||(e.display.maxLineChanged=!0),e.display.lineNumChars=null}function tr(){return bl&&kl?-(document.body.getBoundingClientRect().left-parseInt(getComputedStyle(document.body).marginLeft)):window.pageXOffset||(document.documentElement||document.body).scrollLeft}function rr(){return bl&&kl?-(document.body.getBoundingClientRect().top-parseInt(getComputedStyle(document.body).marginTop)):window.pageYOffset||(document.documentElement||document.body).scrollTop}function nr(e){var t=0;if(e.widgets)for(var r=0;r<e.widgets.length;++r)e.widgets[r].above&&(t+=Ht(e.widgets[r]));return t}function ir(e,t,r,n,i){if(!i){var o=nr(t);r.top+=o,r.bottom+=o}if("line"==n)return r;n||(n="local");var l=ye(t);if("local"==n?l+=Et(e.display):l-=e.display.viewOffset,"page"==n||"window"==n){var s=e.display.lineSpace.getBoundingClientRect();l+=s.top+("window"==n?0:rr());var a=s.left+("window"==n?0:tr());r.left+=a,r.right+=a}return r.top+=l,r.bottom+=l,r}function or(e,t,r){if("div"==r)return t;var n=t.left,i=t.top;if("page"==r)n-=tr(),i-=rr();else if("local"==r||!r){var o=e.display.sizer.getBoundingClientRect();n+=o.left,i+=o.top}var l=e.display.lineSpace.getBoundingClientRect();return{left:n-l.left,top:i-l.top}}function lr(e,t,r,n,i){return n||(n=M(e.doc,t.line)),ir(e,n,Kt(e,n,t.ch,i),r)}function sr(e,t,r,n,i,o){function l(t,l){var s=Yt(e,i,t,l?"right":"left",o);return l?s.left=s.right:s.right=s.left,ir(e,n,s,r)}function s(e,t,r){var n=1==a[t].level;return l(r?e-1:e,n!=r)}n=n||M(e.doc,t.line),i||(i=Xt(e,n));var a=Se(n,e.doc.direction),u=t.ch,c=t.sticky;if(u>=n.text.length?(u=n.text.length,c="before"):u<=0&&(u=0,c="after"),!a)return l("before"==c?u-1:u,"before"==c);var f=Ce(a,u,c),h=$l,d=s(u,f,"before"==c);return null!=h&&(d.other=s(u,h,"before"!=c)),d}function ar(e,t){var r=0;t=U(e.doc,t),e.options.lineWrapping||(r=yr(e.display)*t.ch);var n=M(e.doc,t.line),i=ye(n)+Et(e.display);return{left:r,right:r,top:i,bottom:i+n.height}}function ur(e,t,r,n,i){var o=E(e,t,r);return o.xRel=i,n&&(o.outside=!0),o}function cr(e,t,r){var n=e.doc;if((r+=e.display.viewOffset)<0)return ur(n.first,0,null,!0,-1);var i=D(n,r),o=n.first+n.size-1;if(i>o)return ur(n.first+n.size-1,M(n,o).text.length,null,!0,1);t<0&&(t=0);for(var l=M(n,i);;){var s=pr(e,l,i,t,r),a=ue(l),u=a&&a.find(0,!0);if(!a||!(s.ch>u.from.ch||s.ch==u.from.ch&&s.xRel>0))return s;i=W(l=u.to.line)}}function fr(e,t,r,n){n-=nr(t);var i=t.text.length,o=k(function(t){return Yt(e,r,t-1).bottom<=n},i,0);return i=k(function(t){return Yt(e,r,t).top>n},o,i),{begin:o,end:i}}function hr(e,t,r,n){return r||(r=Xt(e,t)),fr(e,t,r,ir(e,t,Yt(e,r,n),"line").top)}function dr(e,t,r,n){return!(e.bottom<=r)&&(e.top>r||(n?e.left:e.right)>t)}function pr(e,t,r,n,i){i-=ye(t);var o=Xt(e,t),l=nr(t),s=0,a=t.text.length,u=!0,c=Se(t,e.doc.direction);if(c){var f=(e.options.lineWrapping?vr:gr)(e,t,r,o,c,n,i);s=(u=1!=f.level)?f.from:f.to-1,a=u?f.to:f.from-1}var h,d,p=null,g=null,v=k(function(t){var r=Yt(e,o,t);return r.top+=l,r.bottom+=l,!!dr(r,n,i,!1)&&(r.top<=i&&r.left<=n&&(p=t,g=r),!0)},s,a),m=!1;if(g){var y=n-g.left<g.right-n,b=y==u;v=p+(b?0:1),d=b?"after":"before",h=y?g.left:g.right}else{u||v!=a&&v!=s||v++,d=0==v?"after":v==t.text.length?"before":Yt(e,o,v-(u?1:0)).bottom+l<=i==u?"after":"before";var w=sr(e,E(r,v,d),"line",t,o);h=w.left,m=i<w.top||i>=w.bottom}return v=L(t.text,v,1),ur(r,v,d,m,n-h)}function gr(e,t,r,n,i,o,l){var s=k(function(s){var a=i[s],u=1!=a.level;return dr(sr(e,E(r,u?a.to:a.from,u?"before":"after"),"line",t,n),o,l,!0)},0,i.length-1),a=i[s];if(s>0){var u=1!=a.level,c=sr(e,E(r,u?a.from:a.to,u?"after":"before"),"line",t,n);dr(c,o,l,!0)&&c.top>l&&(a=i[s-1])}return a}function vr(e,t,r,n,i,o,l){for(var s=fr(e,t,n,l),a=s.begin,u=s.end,c=null,f=null,h=0;h<i.length;h++){var d=i[h];if(!(d.from>=u||d.to<=a)){var p=Yt(e,n,1!=d.level?Math.min(u,d.to)-1:Math.max(a,d.from)).right,g=p<o?o-p+1e9:p-o;(!c||f>g)&&(c=d,f=g)}}return c||(c=i[i.length-1]),c.from<a&&(c={from:a,to:c.to,level:c.level}),c.to>u&&(c={from:c.from,to:u,level:c.level}),c}function mr(e){if(null!=e.cachedTextHeight)return e.cachedTextHeight;if(null==hs){hs=n("pre");for(var i=0;i<49;++i)hs.appendChild(document.createTextNode("x")),hs.appendChild(n("br"));hs.appendChild(document.createTextNode("x"))}r(e.measure,hs);var o=hs.offsetHeight/50;return o>3&&(e.cachedTextHeight=o),t(e.measure),o||1}function yr(e){if(null!=e.cachedCharWidth)return e.cachedCharWidth;var t=n("span","xxxxxxxxxx"),i=n("pre",[t]);r(e.measure,i);var o=t.getBoundingClientRect(),l=(o.right-o.left)/10;return l>2&&(e.cachedCharWidth=l),l||10}function br(e){for(var t=e.display,r={},n={},i=t.gutters.clientLeft,o=t.gutters.firstChild,l=0;o;o=o.nextSibling,++l)r[e.options.gutters[l]]=o.offsetLeft+o.clientLeft+i,n[e.options.gutters[l]]=o.clientWidth;return{fixedPos:wr(t),gutterTotalWidth:t.gutters.offsetWidth,gutterLeft:r,gutterWidth:n,wrapperWidth:t.wrapper.clientWidth}}function wr(e){return e.scroller.getBoundingClientRect().left-e.sizer.getBoundingClientRect().left}function xr(e){var t=mr(e.display),r=e.options.lineWrapping,n=r&&Math.max(5,e.display.scroller.clientWidth/yr(e.display)-3);return function(i){if(ve(e.doc,i))return 0;var o=0;if(i.widgets)for(var l=0;l<i.widgets.length;l++)i.widgets[l].height&&(o+=i.widgets[l].height);return r?o+(Math.ceil(i.text.length/n)||1)*t:o+t}}function Cr(e){var t=e.doc,r=xr(e);t.iter(function(e){var t=r(e);t!=e.height&&A(e,t)})}function Sr(e,t,r,n){var i=e.display;if(!r&&"true"==Ee(t).getAttribute("cm-not-content"))return null;var o,l,s=i.lineSpace.getBoundingClientRect();try{o=t.clientX-s.left,l=t.clientY-s.top}catch(t){return null}var a,u=cr(e,o,l);if(n&&1==u.xRel&&(a=M(e.doc,u.line).text).length==u.ch){var c=f(a,a.length,e.options.tabSize)-a.length;u=E(u.line,Math.max(0,Math.round((o-It(e.display).left)/yr(e.display))-c))}return u}function Lr(e,t){if(t>=e.display.viewTo)return null;if((t-=e.display.viewFrom)<0)return null;for(var r=e.display.view,n=0;n<r.length;n++)if((t-=r[n].size)<0)return n}function kr(e){e.display.input.showSelection(e.display.input.prepareSelection())}function Tr(e,t){void 0===t&&(t=!0);for(var r=e.doc,n={},i=n.cursors=document.createDocumentFragment(),o=n.selection=document.createDocumentFragment(),l=0;l<r.sel.ranges.length;l++)if(t||l!=r.sel.primIndex){var s=r.sel.ranges[l];if(!(s.from().line>=e.display.viewTo||s.to().line<e.display.viewFrom)){var a=s.empty();(a||e.options.showCursorWhenSelecting)&&Mr(e,s.head,i),a||Or(e,s,o)}}return n}function Mr(e,t,r){var i=sr(e,t,"div",null,null,!e.options.singleCursorHeightPerLine),o=r.appendChild(n("div"," ","CodeMirror-cursor"));if(o.style.left=i.left+"px",o.style.top=i.top+"px",o.style.height=Math.max(0,i.bottom-i.top)*e.options.cursorHeight+"px",i.other){var l=r.appendChild(n("div"," ","CodeMirror-cursor CodeMirror-secondarycursor"));l.style.display="",l.style.left=i.other.left+"px",l.style.top=i.other.top+"px",l.style.height=.85*(i.other.bottom-i.other.top)+"px"}}function Nr(e,t){return e.top-t.top||e.left-t.left}function Or(e,t,r){function i(e,t,r,i){t<0&&(t=0),t=Math.round(t),i=Math.round(i),a.appendChild(n("div",null,"CodeMirror-selected","position: absolute; left: "+e+"px;\n                             top: "+t+"px; width: "+(null==r?f-e:r)+"px;\n                             height: "+(i-t)+"px"))}function o(t,r,n){function o(r,n){return lr(e,E(t,r),"div",u,n)}var l,a,u=M(s,t),h=u.text.length,d=Se(u,s.direction);return xe(d,r||0,null==n?h:n,function(t,s,p,g){var v=o(t,"ltr"==p?"left":"right"),m=o(s-1,"ltr"==p?"right":"left");if("ltr"==p){var y=null==r&&0==t?c:v.left,b=null==n&&s==h?f:m.right;m.top-v.top<=3?i(y,m.top,b-y,m.bottom):(i(y,v.top,null,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top),i(c,m.top,m.right,m.bottom))}else if(t<s){var w=null==r&&0==t?f:v.right,x=null==n&&s==h?c:m.left;if(m.top-v.top<=3)i(x,m.top,w-x,m.bottom);else{var C=c;if(g){var S=hr(e,u,null,t).end;C=o(S-(/\s/.test(u.text.charAt(S-1))?2:1),"left").left}i(C,v.top,w-C,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top);var L=null;d.length,L=o(hr(e,u,null,s).begin,"right").right-x,i(x,m.top,L,m.bottom)}}(!l||Nr(v,l)<0)&&(l=v),Nr(m,l)<0&&(l=m),(!a||Nr(v,a)<0)&&(a=v),Nr(m,a)<0&&(a=m)}),{start:l,end:a}}var l=e.display,s=e.doc,a=document.createDocumentFragment(),u=It(e.display),c=u.left,f=Math.max(l.sizerWidth,Rt(e)-l.sizer.offsetLeft)-u.right,h=t.from(),d=t.to();if(h.line==d.line)o(h.line,h.ch,d.ch);else{var p=M(s,h.line),g=M(s,d.line),v=fe(p)==fe(g),m=o(h.line,h.ch,v?p.text.length+1:null).end,y=o(d.line,v?0:null,d.ch).start;v&&(m.top<y.top-2?(i(m.right,m.top,null,m.bottom),i(c,y.top,y.left,y.bottom)):i(m.right,m.top,y.left-m.right,m.bottom)),m.bottom<y.top&&i(c,m.bottom,null,y.top)}r.appendChild(a)}function Ar(e){if(e.state.focused){var t=e.display;clearInterval(t.blinker);var r=!0;t.cursorDiv.style.visibility="",e.options.cursorBlinkRate>0?t.blinker=setInterval(function(){return t.cursorDiv.style.visibility=(r=!r)?"":"hidden"},e.options.cursorBlinkRate):e.options.cursorBlinkRate<0&&(t.cursorDiv.style.visibility="hidden")}}function Wr(e){e.state.focused||(e.display.input.focus(),Hr(e))}function Dr(e){e.state.delayingBlurEvent=!0,setTimeout(function(){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1,Fr(e))},100)}function Hr(e,t){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1),"nocursor"!=e.options.readOnly&&(e.state.focused||(Te(e,"focus",e,t),e.state.focused=!0,s(e.display.wrapper,"CodeMirror-focused"),e.curOp||e.display.selForContextMenu==e.doc.sel||(e.display.input.reset(),ml&&setTimeout(function(){return e.display.input.reset(!0)},20)),e.display.input.receivedFocus()),Ar(e))}function Fr(e,t){e.state.delayingBlurEvent||(e.state.focused&&(Te(e,"blur",e,t),e.state.focused=!1,Fl(e.display.wrapper,"CodeMirror-focused")),clearInterval(e.display.blinker),setTimeout(function(){e.state.focused||(e.display.shift=!1)},150))}function Er(e){for(var t=e.display,r=t.lineDiv.offsetTop,n=0;n<t.view.length;n++){var i=t.view[n],o=void 0;if(!i.hidden){if(gl&&vl<8){var l=i.node.offsetTop+i.node.offsetHeight;o=l-r,r=l}else{var s=i.node.getBoundingClientRect();o=s.bottom-s.top}var a=i.line.height-o;if(o<2&&(o=mr(t)),(a>.005||a<-.005)&&(A(i.line,o),Pr(i.line),i.rest))for(var u=0;u<i.rest.length;u++)Pr(i.rest[u])}}}function Pr(e){if(e.widgets)for(var t=0;t<e.widgets.length;++t)e.widgets[t].height=e.widgets[t].node.parentNode.offsetHeight}function Ir(e,t,r){var n=r&&null!=r.top?Math.max(0,r.top):e.scroller.scrollTop;n=Math.floor(n-Et(e));var i=r&&null!=r.bottom?r.bottom:n+e.wrapper.clientHeight,o=D(t,n),l=D(t,i);if(r&&r.ensure){var s=r.ensure.from.line,a=r.ensure.to.line;s<o?(o=s,l=D(t,ye(M(t,s))+e.wrapper.clientHeight)):Math.min(a,t.lastLine())>=l&&(o=D(t,ye(M(t,a))-e.wrapper.clientHeight),l=a)}return{from:o,to:Math.max(l,o+1)}}function zr(e){var t=e.display,r=t.view;if(t.alignWidgets||t.gutters.firstChild&&e.options.fixedGutter){for(var n=wr(t)-t.scroller.scrollLeft+e.doc.scrollLeft,i=t.gutters.offsetWidth,o=n+"px",l=0;l<r.length;l++)if(!r[l].hidden){e.options.fixedGutter&&(r[l].gutter&&(r[l].gutter.style.left=o),r[l].gutterBackground&&(r[l].gutterBackground.style.left=o));var s=r[l].alignable;if(s)for(var a=0;a<s.length;a++)s[a].style.left=o}e.options.fixedGutter&&(t.gutters.style.left=n+i+"px")}}function Rr(e){if(!e.options.lineNumbers)return!1;var t=e.doc,r=F(e.options,t.first+t.size-1),i=e.display;if(r.length!=i.lineNumChars){var o=i.measure.appendChild(n("div",[n("div",r)],"CodeMirror-linenumber CodeMirror-gutter-elt")),l=o.firstChild.offsetWidth,s=o.offsetWidth-l;return i.lineGutter.style.width="",i.lineNumInnerWidth=Math.max(l,i.lineGutter.offsetWidth-s)+1,i.lineNumWidth=i.lineNumInnerWidth+s,i.lineNumChars=i.lineNumInnerWidth?r.length:-1,i.lineGutter.style.width=i.lineNumWidth+"px",Wn(e),!0}return!1}function Br(e,t){if(!Me(e,"scrollCursorIntoView")){var r=e.display,i=r.sizer.getBoundingClientRect(),o=null;if(t.top+i.top<0?o=!0:t.bottom+i.top>(window.innerHeight||document.documentElement.clientHeight)&&(o=!1),null!=o&&!Sl){var l=n("div","​",null,"position: absolute;\n                         top: "+(t.top-r.viewOffset-Et(e.display))+"px;\n                         height: "+(t.bottom-t.top+zt(e)+r.barHeight)+"px;\n                         left: "+t.left+"px; width: "+Math.max(2,t.right-t.left)+"px;");e.display.lineSpace.appendChild(l),l.scrollIntoView(o),e.display.lineSpace.removeChild(l)}}}function Gr(e,t,r,n){null==n&&(n=0);var i;e.options.lineWrapping||t!=r||(r="before"==(t=t.ch?E(t.line,"before"==t.sticky?t.ch-1:t.ch,"after"):t).sticky?E(t.line,t.ch+1,"before"):t);for(var o=0;o<5;o++){var l=!1,s=sr(e,t),a=r&&r!=t?sr(e,r):s,u=Vr(e,i={left:Math.min(s.left,a.left),top:Math.min(s.top,a.top)-n,right:Math.max(s.left,a.left),bottom:Math.max(s.bottom,a.bottom)+n}),c=e.doc.scrollTop,f=e.doc.scrollLeft;if(null!=u.scrollTop&&(qr(e,u.scrollTop),Math.abs(e.doc.scrollTop-c)>1&&(l=!0)),null!=u.scrollLeft&&(Qr(e,u.scrollLeft),Math.abs(e.doc.scrollLeft-f)>1&&(l=!0)),!l)break}return i}function Ur(e,t){var r=Vr(e,t);null!=r.scrollTop&&qr(e,r.scrollTop),null!=r.scrollLeft&&Qr(e,r.scrollLeft)}function Vr(e,t){var r=e.display,n=mr(e.display);t.top<0&&(t.top=0);var i=e.curOp&&null!=e.curOp.scrollTop?e.curOp.scrollTop:r.scroller.scrollTop,o=Bt(e),l={};t.bottom-t.top>o&&(t.bottom=t.top+o);var s=e.doc.height+Pt(r),a=t.top<n,u=t.bottom>s-n;if(t.top<i)l.scrollTop=a?0:t.top;else if(t.bottom>i+o){var c=Math.min(t.top,(u?s:t.bottom)-o);c!=i&&(l.scrollTop=c)}var f=e.curOp&&null!=e.curOp.scrollLeft?e.curOp.scrollLeft:r.scroller.scrollLeft,h=Rt(e)-(e.options.fixedGutter?r.gutters.offsetWidth:0),d=t.right-t.left>h;return d&&(t.right=t.left+h),t.left<10?l.scrollLeft=0:t.left<f?l.scrollLeft=Math.max(0,t.left-(d?0:10)):t.right>h+f-3&&(l.scrollLeft=t.right+(d?0:10)-h),l}function Kr(e,t){null!=t&&(_r(e),e.curOp.scrollTop=(null==e.curOp.scrollTop?e.doc.scrollTop:e.curOp.scrollTop)+t)}function jr(e){_r(e);var t=e.getCursor();e.curOp.scrollToPos={from:t,to:t,margin:e.options.cursorScrollMargin}}function Xr(e,t,r){null==t&&null==r||_r(e),null!=t&&(e.curOp.scrollLeft=t),null!=r&&(e.curOp.scrollTop=r)}function Yr(e,t){_r(e),e.curOp.scrollToPos=t}function _r(e){var t=e.curOp.scrollToPos;t&&(e.curOp.scrollToPos=null,$r(e,ar(e,t.from),ar(e,t.to),t.margin))}function $r(e,t,r,n){var i=Vr(e,{left:Math.min(t.left,r.left),top:Math.min(t.top,r.top)-n,right:Math.max(t.right,r.right),bottom:Math.max(t.bottom,r.bottom)+n});Xr(e,i.scrollLeft,i.scrollTop)}function qr(e,t){Math.abs(e.doc.scrollTop-t)<2||(fl||On(e,{top:t}),Zr(e,t,!0),fl&&On(e),Cn(e,100))}function Zr(e,t,r){t=Math.min(e.display.scroller.scrollHeight-e.display.scroller.clientHeight,t),(e.display.scroller.scrollTop!=t||r)&&(e.doc.scrollTop=t,e.display.scrollbars.setScrollTop(t),e.display.scroller.scrollTop!=t&&(e.display.scroller.scrollTop=t))}function Qr(e,t,r,n){t=Math.min(t,e.display.scroller.scrollWidth-e.display.scroller.clientWidth),(r?t==e.doc.scrollLeft:Math.abs(e.doc.scrollLeft-t)<2)&&!n||(e.doc.scrollLeft=t,zr(e),e.display.scroller.scrollLeft!=t&&(e.display.scroller.scrollLeft=t),e.display.scrollbars.setScrollLeft(t))}function Jr(e){var t=e.display,r=t.gutters.offsetWidth,n=Math.round(e.doc.height+Pt(e.display));return{clientHeight:t.scroller.clientHeight,viewHeight:t.wrapper.clientHeight,scrollWidth:t.scroller.scrollWidth,clientWidth:t.scroller.clientWidth,viewWidth:t.wrapper.clientWidth,barLeft:e.options.fixedGutter?r:0,docHeight:n,scrollHeight:n+zt(e)+t.barHeight,nativeBarWidth:t.nativeBarWidth,gutterWidth:r}}function en(e,t){t||(t=Jr(e));var r=e.display.barWidth,n=e.display.barHeight;tn(e,t);for(var i=0;i<4&&r!=e.display.barWidth||n!=e.display.barHeight;i++)r!=e.display.barWidth&&e.options.lineWrapping&&Er(e),tn(e,Jr(e)),r=e.display.barWidth,n=e.display.barHeight}function tn(e,t){var r=e.display,n=r.scrollbars.update(t);r.sizer.style.paddingRight=(r.barWidth=n.right)+"px",r.sizer.style.paddingBottom=(r.barHeight=n.bottom)+"px",r.heightForcer.style.borderBottom=n.bottom+"px solid transparent",n.right&&n.bottom?(r.scrollbarFiller.style.display="block",r.scrollbarFiller.style.height=n.bottom+"px",r.scrollbarFiller.style.width=n.right+"px"):r.scrollbarFiller.style.display="",n.bottom&&e.options.coverGutterNextToScrollbar&&e.options.fixedGutter?(r.gutterFiller.style.display="block",r.gutterFiller.style.height=n.bottom+"px",r.gutterFiller.style.width=t.gutterWidth+"px"):r.gutterFiller.style.display=""}function rn(e){e.display.scrollbars&&(e.display.scrollbars.clear(),e.display.scrollbars.addClass&&Fl(e.display.wrapper,e.display.scrollbars.addClass)),e.display.scrollbars=new ws[e.options.scrollbarStyle](function(t){e.display.wrapper.insertBefore(t,e.display.scrollbarFiller),Ql(t,"mousedown",function(){e.state.focused&&setTimeout(function(){return e.display.input.focus()},0)}),t.setAttribute("cm-not-content","true")},function(t,r){"horizontal"==r?Qr(e,t):qr(e,t)},e),e.display.scrollbars.addClass&&s(e.display.wrapper,e.display.scrollbars.addClass)}function nn(e){e.curOp={cm:e,viewChanged:!1,startHeight:e.doc.height,forceUpdate:!1,updateInput:null,typing:!1,changeObjs:null,cursorActivityHandlers:null,cursorActivityCalled:0,selectionChanged:!1,updateMaxLine:!1,scrollLeft:null,scrollTop:null,scrollToPos:null,focus:!1,id:++xs},vt(e.curOp)}function on(e){yt(e.curOp,function(e){for(var t=0;t<e.ops.length;t++)e.ops[t].cm.curOp=null;ln(e)})}function ln(e){for(var t=e.ops,r=0;r<t.length;r++)sn(t[r]);for(var n=0;n<t.length;n++)an(t[n]);for(var i=0;i<t.length;i++)un(t[i]);for(var o=0;o<t.length;o++)cn(t[o]);for(var l=0;l<t.length;l++)fn(t[l])}function sn(e){var t=e.cm,r=t.display;Ln(t),e.updateMaxLine&&we(t),e.mustUpdate=e.viewChanged||e.forceUpdate||null!=e.scrollTop||e.scrollToPos&&(e.scrollToPos.from.line<r.viewFrom||e.scrollToPos.to.line>=r.viewTo)||r.maxLineChanged&&t.options.lineWrapping,e.update=e.mustUpdate&&new Cs(t,e.mustUpdate&&{top:e.scrollTop,ensure:e.scrollToPos},e.forceUpdate)}function an(e){e.updatedDisplay=e.mustUpdate&&Mn(e.cm,e.update)}function un(e){var t=e.cm,r=t.display;e.updatedDisplay&&Er(t),e.barMeasure=Jr(t),r.maxLineChanged&&!t.options.lineWrapping&&(e.adjustWidthTo=Kt(t,r.maxLine,r.maxLine.text.length).left+3,t.display.sizerWidth=e.adjustWidthTo,e.barMeasure.scrollWidth=Math.max(r.scroller.clientWidth,r.sizer.offsetLeft+e.adjustWidthTo+zt(t)+t.display.barWidth),e.maxScrollLeft=Math.max(0,r.sizer.offsetLeft+e.adjustWidthTo-Rt(t))),(e.updatedDisplay||e.selectionChanged)&&(e.preparedSelection=r.input.prepareSelection())}function cn(e){var t=e.cm;null!=e.adjustWidthTo&&(t.display.sizer.style.minWidth=e.adjustWidthTo+"px",e.maxScrollLeft<t.doc.scrollLeft&&Qr(t,Math.min(t.display.scroller.scrollLeft,e.maxScrollLeft),!0),t.display.maxLineChanged=!1);var r=e.focus&&e.focus==l();e.preparedSelection&&t.display.input.showSelection(e.preparedSelection,r),(e.updatedDisplay||e.startHeight!=t.doc.height)&&en(t,e.barMeasure),e.updatedDisplay&&Dn(t,e.barMeasure),e.selectionChanged&&Ar(t),t.state.focused&&e.updateInput&&t.display.input.reset(e.typing),r&&Wr(e.cm)}function fn(e){var t=e.cm,r=t.display,n=t.doc;e.updatedDisplay&&Nn(t,e.update),null==r.wheelStartX||null==e.scrollTop&&null==e.scrollLeft&&!e.scrollToPos||(r.wheelStartX=r.wheelStartY=null),null!=e.scrollTop&&Zr(t,e.scrollTop,e.forceScroll),null!=e.scrollLeft&&Qr(t,e.scrollLeft,!0,!0),e.scrollToPos&&Br(t,Gr(t,U(n,e.scrollToPos.from),U(n,e.scrollToPos.to),e.scrollToPos.margin));var i=e.maybeHiddenMarkers,o=e.maybeUnhiddenMarkers;if(i)for(var l=0;l<i.length;++l)i[l].lines.length||Te(i[l],"hide");if(o)for(var s=0;s<o.length;++s)o[s].lines.length&&Te(o[s],"unhide");r.wrapper.offsetHeight&&(n.scrollTop=t.display.scroller.scrollTop),e.changeObjs&&Te(t,"changes",t,e.changeObjs),e.update&&e.update.finish()}function hn(e,t){if(e.curOp)return t();nn(e);try{return t()}finally{on(e)}}function dn(e,t){return function(){if(e.curOp)return t.apply(e,arguments);nn(e);try{return t.apply(e,arguments)}finally{on(e)}}}function pn(e){return function(){if(this.curOp)return e.apply(this,arguments);nn(this);try{return e.apply(this,arguments)}finally{on(this)}}}function gn(e){return function(){var t=this.cm;if(!t||t.curOp)return e.apply(this,arguments);nn(t);try{return e.apply(this,arguments)}finally{on(t)}}}function vn(e,t,r,n){null==t&&(t=e.doc.first),null==r&&(r=e.doc.first+e.doc.size),n||(n=0);var i=e.display;if(n&&r<i.viewTo&&(null==i.updateLineNumbers||i.updateLineNumbers>t)&&(i.updateLineNumbers=t),e.curOp.viewChanged=!0,t>=i.viewTo)_l&&pe(e.doc,t)<i.viewTo&&yn(e);else if(r<=i.viewFrom)_l&&ge(e.doc,r+n)>i.viewFrom?yn(e):(i.viewFrom+=n,i.viewTo+=n);else if(t<=i.viewFrom&&r>=i.viewTo)yn(e);else if(t<=i.viewFrom){var o=bn(e,r,r+n,1);o?(i.view=i.view.slice(o.index),i.viewFrom=o.lineN,i.viewTo+=n):yn(e)}else if(r>=i.viewTo){var l=bn(e,t,t,-1);l?(i.view=i.view.slice(0,l.index),i.viewTo=l.lineN):yn(e)}else{var s=bn(e,t,t,-1),a=bn(e,r,r+n,1);s&&a?(i.view=i.view.slice(0,s.index).concat(gt(e,s.lineN,a.lineN)).concat(i.view.slice(a.index)),i.viewTo+=n):yn(e)}var u=i.externalMeasured;u&&(r<u.lineN?u.lineN+=n:t<u.lineN+u.size&&(i.externalMeasured=null))}function mn(e,t,r){e.curOp.viewChanged=!0;var n=e.display,i=e.display.externalMeasured;if(i&&t>=i.lineN&&t<i.lineN+i.size&&(n.externalMeasured=null),!(t<n.viewFrom||t>=n.viewTo)){var o=n.view[Lr(e,t)];if(null!=o.node){var l=o.changes||(o.changes=[]);-1==h(l,r)&&l.push(r)}}}function yn(e){e.display.viewFrom=e.display.viewTo=e.doc.first,e.display.view=[],e.display.viewOffset=0}function bn(e,t,r,n){var i,o=Lr(e,t),l=e.display.view;if(!_l||r==e.doc.first+e.doc.size)return{index:o,lineN:r};for(var s=e.display.viewFrom,a=0;a<o;a++)s+=l[a].size;if(s!=t){if(n>0){if(o==l.length-1)return null;i=s+l[o].size-t,o++}else i=s-t;t+=i,r+=i}for(;pe(e.doc,r)!=r;){if(o==(n<0?0:l.length-1))return null;r+=n*l[o-(n<0?1:0)].size,o+=n}return{index:o,lineN:r}}function wn(e,t,r){var n=e.display;0==n.view.length||t>=n.viewTo||r<=n.viewFrom?(n.view=gt(e,t,r),n.viewFrom=t):(n.viewFrom>t?n.view=gt(e,t,n.viewFrom).concat(n.view):n.viewFrom<t&&(n.view=n.view.slice(Lr(e,t))),n.viewFrom=t,n.viewTo<r?n.view=n.view.concat(gt(e,n.viewTo,r)):n.viewTo>r&&(n.view=n.view.slice(0,Lr(e,r)))),n.viewTo=r}function xn(e){for(var t=e.display.view,r=0,n=0;n<t.length;n++){var i=t[n];i.hidden||i.node&&!i.changes||++r}return r}function Cn(e,t){e.doc.highlightFrontier<e.display.viewTo&&e.state.highlight.set(t,u(Sn,e))}function Sn(e){var t=e.doc;if(!(t.highlightFrontier>=e.display.viewTo)){var r=+new Date+e.options.workTime,n=$e(e,t.highlightFrontier),i=[];t.iter(n.line,Math.min(t.first+t.size,e.display.viewTo+500),function(o){if(n.line>=e.display.viewFrom){var l=o.styles,s=o.text.length>e.options.maxHighlightLength?Ke(t.mode,n.state):null,a=Ye(e,o,n,!0);s&&(n.state=s),o.styles=a.styles;var u=o.styleClasses,c=a.classes;c?o.styleClasses=c:u&&(o.styleClasses=null);for(var f=!l||l.length!=o.styles.length||u!=c&&(!u||!c||u.bgClass!=c.bgClass||u.textClass!=c.textClass),h=0;!f&&h<l.length;++h)f=l[h]!=o.styles[h];f&&i.push(n.line),o.stateAfter=n.save(),n.nextLine()}else o.text.length<=e.options.maxHighlightLength&&qe(e,o.text,n),o.stateAfter=n.line%5==0?n.save():null,n.nextLine();if(+new Date>r)return Cn(e,e.options.workDelay),!0}),t.highlightFrontier=n.line,t.modeFrontier=Math.max(t.modeFrontier,n.line),i.length&&hn(e,function(){for(var t=0;t<i.length;t++)mn(e,i[t],"text")})}}function Ln(e){var t=e.display;!t.scrollbarsClipped&&t.scroller.offsetWidth&&(t.nativeBarWidth=t.scroller.offsetWidth-t.scroller.clientWidth,t.heightForcer.style.height=zt(e)+"px",t.sizer.style.marginBottom=-t.nativeBarWidth+"px",t.sizer.style.borderRightWidth=zt(e)+"px",t.scrollbarsClipped=!0)}function kn(e){if(e.hasFocus())return null;var t=l();if(!t||!o(e.display.lineDiv,t))return null;var r={activeElt:t};if(window.getSelection){var n=window.getSelection();n.anchorNode&&n.extend&&o(e.display.lineDiv,n.anchorNode)&&(r.anchorNode=n.anchorNode,r.anchorOffset=n.anchorOffset,r.focusNode=n.focusNode,r.focusOffset=n.focusOffset)}return r}function Tn(e){if(e&&e.activeElt&&e.activeElt!=l()&&(e.activeElt.focus(),e.anchorNode&&o(document.body,e.anchorNode)&&o(document.body,e.focusNode))){var t=window.getSelection(),r=document.createRange();r.setEnd(e.anchorNode,e.anchorOffset),r.collapse(!1),t.removeAllRanges(),t.addRange(r),t.extend(e.focusNode,e.focusOffset)}}function Mn(e,r){var n=e.display,i=e.doc;if(r.editorIsHidden)return yn(e),!1;if(!r.force&&r.visible.from>=n.viewFrom&&r.visible.to<=n.viewTo&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo)&&n.renderedView==n.view&&0==xn(e))return!1;Rr(e)&&(yn(e),r.dims=br(e));var o=i.first+i.size,l=Math.max(r.visible.from-e.options.viewportMargin,i.first),s=Math.min(o,r.visible.to+e.options.viewportMargin);n.viewFrom<l&&l-n.viewFrom<20&&(l=Math.max(i.first,n.viewFrom)),n.viewTo>s&&n.viewTo-s<20&&(s=Math.min(o,n.viewTo)),_l&&(l=pe(e.doc,l),s=ge(e.doc,s));var a=l!=n.viewFrom||s!=n.viewTo||n.lastWrapHeight!=r.wrapperHeight||n.lastWrapWidth!=r.wrapperWidth;wn(e,l,s),n.viewOffset=ye(M(e.doc,n.viewFrom)),e.display.mover.style.top=n.viewOffset+"px";var u=xn(e);if(!a&&0==u&&!r.force&&n.renderedView==n.view&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo))return!1;var c=kn(e);return u>4&&(n.lineDiv.style.display="none"),An(e,n.updateLineNumbers,r.dims),u>4&&(n.lineDiv.style.display=""),n.renderedView=n.view,Tn(c),t(n.cursorDiv),t(n.selectionDiv),n.gutters.style.height=n.sizer.style.minHeight=0,a&&(n.lastWrapHeight=r.wrapperHeight,n.lastWrapWidth=r.wrapperWidth,Cn(e,400)),n.updateLineNumbers=null,!0}function Nn(e,t){for(var r=t.viewport,n=!0;(n&&e.options.lineWrapping&&t.oldDisplayWidth!=Rt(e)||(r&&null!=r.top&&(r={top:Math.min(e.doc.height+Pt(e.display)-Bt(e),r.top)}),t.visible=Ir(e.display,e.doc,r),!(t.visible.from>=e.display.viewFrom&&t.visible.to<=e.display.viewTo)))&&Mn(e,t);n=!1){Er(e);var i=Jr(e);kr(e),en(e,i),Dn(e,i),t.force=!1}t.signal(e,"update",e),e.display.viewFrom==e.display.reportedViewFrom&&e.display.viewTo==e.display.reportedViewTo||(t.signal(e,"viewportChange",e,e.display.viewFrom,e.display.viewTo),e.display.reportedViewFrom=e.display.viewFrom,e.display.reportedViewTo=e.display.viewTo)}function On(e,t){var r=new Cs(e,t);if(Mn(e,r)){Er(e),Nn(e,r);var n=Jr(e);kr(e),en(e,n),Dn(e,n),r.finish()}}function An(e,r,n){function i(t){var r=t.nextSibling;return ml&&Ml&&e.display.currentWheelTarget==t?t.style.display="none":t.parentNode.removeChild(t),r}for(var o=e.display,l=e.options.lineNumbers,s=o.lineDiv,a=s.firstChild,u=o.view,c=o.viewFrom,f=0;f<u.length;f++){var d=u[f];if(d.hidden);else if(d.node&&d.node.parentNode==s){for(;a!=d.node;)a=i(a);var p=l&&null!=r&&r<=c&&d.lineNumber;d.changes&&(h(d.changes,"gutter")>-1&&(p=!1),xt(e,d,c,n)),p&&(t(d.lineNumber),d.lineNumber.appendChild(document.createTextNode(F(e.options,c)))),a=d.node.nextSibling}else{var g=Ot(e,d,c,n);s.insertBefore(g,a)}c+=d.size}for(;a;)a=i(a)}function Wn(e){var t=e.display.gutters.offsetWidth;e.display.sizer.style.marginLeft=t+"px"}function Dn(e,t){e.display.sizer.style.minHeight=t.docHeight+"px",e.display.heightForcer.style.top=t.docHeight+"px",e.display.gutters.style.height=t.docHeight+e.display.barHeight+zt(e)+"px"}function Hn(e){var r=e.display.gutters,i=e.options.gutters;t(r);for(var o=0;o<i.length;++o){var l=i[o],s=r.appendChild(n("div",null,"CodeMirror-gutter "+l));"CodeMirror-linenumbers"==l&&(e.display.lineGutter=s,s.style.width=(e.display.lineNumWidth||1)+"px")}r.style.display=o?"":"none",Wn(e)}function Fn(e){var t=h(e.gutters,"CodeMirror-linenumbers");-1==t&&e.lineNumbers?e.gutters=e.gutters.concat(["CodeMirror-linenumbers"]):t>-1&&!e.lineNumbers&&(e.gutters=e.gutters.slice(0),e.gutters.splice(t,1))}function En(e){var t=e.wheelDeltaX,r=e.wheelDeltaY;return null==t&&e.detail&&e.axis==e.HORIZONTAL_AXIS&&(t=e.detail),null==r&&e.detail&&e.axis==e.VERTICAL_AXIS?r=e.detail:null==r&&(r=e.wheelDelta),{x:t,y:r}}function Pn(e){var t=En(e);return t.x*=Ls,t.y*=Ls,t}function In(e,t){var r=En(t),n=r.x,i=r.y,o=e.display,l=o.scroller,s=l.scrollWidth>l.clientWidth,a=l.scrollHeight>l.clientHeight;if(n&&s||i&&a){if(i&&Ml&&ml)e:for(var u=t.target,c=o.view;u!=l;u=u.parentNode)for(var f=0;f<c.length;f++)if(c[f].node==u){e.display.currentWheelTarget=u;break e}if(n&&!fl&&!wl&&null!=Ls)return i&&a&&qr(e,Math.max(0,l.scrollTop+i*Ls)),Qr(e,Math.max(0,l.scrollLeft+n*Ls)),(!i||i&&a)&&We(t),void(o.wheelStartX=null);if(i&&null!=Ls){var h=i*Ls,d=e.doc.scrollTop,p=d+o.wrapper.clientHeight;h<0?d=Math.max(0,d+h-50):p=Math.min(e.doc.height,p+h+50),On(e,{top:d,bottom:p})}Ss<20&&(null==o.wheelStartX?(o.wheelStartX=l.scrollLeft,o.wheelStartY=l.scrollTop,o.wheelDX=n,o.wheelDY=i,setTimeout(function(){if(null!=o.wheelStartX){var e=l.scrollLeft-o.wheelStartX,t=l.scrollTop-o.wheelStartY,r=t&&o.wheelDY&&t/o.wheelDY||e&&o.wheelDX&&e/o.wheelDX;o.wheelStartX=o.wheelStartY=null,r&&(Ls=(Ls*Ss+r)/(Ss+1),++Ss)}},200)):(o.wheelDX+=n,o.wheelDY+=i))}}function zn(e,t){var r=e[t];e.sort(function(e,t){return P(e.from(),t.from())}),t=h(e,r);for(var n=1;n<e.length;n++){var i=e[n],o=e[n-1];if(P(o.to(),i.from())>=0){var l=B(o.from(),i.from()),s=R(o.to(),i.to()),a=o.empty()?i.from()==i.head:o.from()==o.head;n<=t&&--t,e.splice(--n,2,new Ts(a?s:l,a?l:s))}}return new ks(e,t)}function Rn(e,t){return new ks([new Ts(e,t||e)],0)}function Bn(e){return e.text?E(e.from.line+e.text.length-1,g(e.text).length+(1==e.text.length?e.from.ch:0)):e.to}function Gn(e,t){if(P(e,t.from)<0)return e;if(P(e,t.to)<=0)return Bn(t);var r=e.line+t.text.length-(t.to.line-t.from.line)-1,n=e.ch;return e.line==t.to.line&&(n+=Bn(t).ch-t.to.ch),E(r,n)}function Un(e,t){for(var r=[],n=0;n<e.sel.ranges.length;n++){var i=e.sel.ranges[n];r.push(new Ts(Gn(i.anchor,t),Gn(i.head,t)))}return zn(r,e.sel.primIndex)}function Vn(e,t,r){return e.line==t.line?E(r.line,e.ch-t.ch+r.ch):E(r.line+(e.line-t.line),e.ch)}function Kn(e,t,r){for(var n=[],i=E(e.first,0),o=i,l=0;l<t.length;l++){var s=t[l],a=Vn(s.from,i,o),u=Vn(Bn(s),i,o);if(i=s.to,o=u,"around"==r){var c=e.sel.ranges[l],f=P(c.head,c.anchor)<0;n[l]=new Ts(f?u:a,f?a:u)}else n[l]=new Ts(a,a)}return new ks(n,e.sel.primIndex)}function jn(e){e.doc.mode=Ue(e.options,e.doc.modeOption),Xn(e)}function Xn(e){e.doc.iter(function(e){e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null)}),e.doc.modeFrontier=e.doc.highlightFrontier=e.doc.first,Cn(e,100),e.state.modeGen++,e.curOp&&vn(e)}function Yn(e,t){return 0==t.from.ch&&0==t.to.ch&&""==g(t.text)&&(!e.cm||e.cm.options.wholeLineUpdateBefore)}function _n(e,t,r,n){function i(e){return r?r[e]:null}function o(e,r,i){it(e,r,i,n),bt(e,"change",e,t)}function l(e,t){for(var r=[],o=e;o<t;++o)r.push(new fs(u[o],i(o),n));return r}var s=t.from,a=t.to,u=t.text,c=M(e,s.line),f=M(e,a.line),h=g(u),d=i(u.length-1),p=a.line-s.line;if(t.full)e.insert(0,l(0,u.length)),e.remove(u.length,e.size-u.length);else if(Yn(e,t)){var v=l(0,u.length-1);o(f,f.text,d),p&&e.remove(s.line,p),v.length&&e.insert(s.line,v)}else if(c==f)if(1==u.length)o(c,c.text.slice(0,s.ch)+h+c.text.slice(a.ch),d);else{var m=l(1,u.length-1);m.push(new fs(h+c.text.slice(a.ch),d,n)),o(c,c.text.slice(0,s.ch)+u[0],i(0)),e.insert(s.line+1,m)}else if(1==u.length)o(c,c.text.slice(0,s.ch)+u[0]+f.text.slice(a.ch),i(0)),e.remove(s.line+1,p);else{o(c,c.text.slice(0,s.ch)+u[0],i(0)),o(f,h+f.text.slice(a.ch),d);var y=l(1,u.length-1);p>1&&e.remove(s.line+1,p-1),e.insert(s.line+1,y)}bt(e,"change",e,t)}function $n(e,t,r){function n(e,i,o){if(e.linked)for(var l=0;l<e.linked.length;++l){var s=e.linked[l];if(s.doc!=i){var a=o&&s.sharedHist;r&&!a||(t(s.doc,a),n(s.doc,e,a))}}}n(e,null,!0)}function qn(e,t){if(t.cm)throw new Error("This document is already in use.");e.doc=t,t.cm=e,Cr(e),jn(e),Zn(e),e.options.lineWrapping||we(e),e.options.mode=t.modeOption,vn(e)}function Zn(e){("rtl"==e.doc.direction?s:Fl)(e.display.lineDiv,"CodeMirror-rtl")}function Qn(e){hn(e,function(){Zn(e),vn(e)})}function Jn(e){this.done=[],this.undone=[],this.undoDepth=1/0,this.lastModTime=this.lastSelTime=0,this.lastOp=this.lastSelOp=null,this.lastOrigin=this.lastSelOrigin=null,this.generation=this.maxGeneration=e||1}function ei(e,t){var r={from:z(t.from),to:Bn(t),text:N(e,t.from,t.to)};return si(e,r,t.from.line,t.to.line+1),$n(e,function(e){return si(e,r,t.from.line,t.to.line+1)},!0),r}function ti(e){for(;e.length&&g(e).ranges;)e.pop()}function ri(e,t){return t?(ti(e.done),g(e.done)):e.done.length&&!g(e.done).ranges?g(e.done):e.done.length>1&&!e.done[e.done.length-2].ranges?(e.done.pop(),g(e.done)):void 0}function ni(e,t,r,n){var i=e.history;i.undone.length=0;var o,l,s=+new Date;if((i.lastOp==n||i.lastOrigin==t.origin&&t.origin&&("+"==t.origin.charAt(0)&&e.cm&&i.lastModTime>s-e.cm.options.historyEventDelay||"*"==t.origin.charAt(0)))&&(o=ri(i,i.lastOp==n)))l=g(o.changes),0==P(t.from,t.to)&&0==P(t.from,l.to)?l.to=Bn(t):o.changes.push(ei(e,t));else{var a=g(i.done);for(a&&a.ranges||li(e.sel,i.done),o={changes:[ei(e,t)],generation:i.generation},i.done.push(o);i.done.length>i.undoDepth;)i.done.shift(),i.done[0].ranges||i.done.shift()}i.done.push(r),i.generation=++i.maxGeneration,i.lastModTime=i.lastSelTime=s,i.lastOp=i.lastSelOp=n,i.lastOrigin=i.lastSelOrigin=t.origin,l||Te(e,"historyAdded")}function ii(e,t,r,n){var i=t.charAt(0);return"*"==i||"+"==i&&r.ranges.length==n.ranges.length&&r.somethingSelected()==n.somethingSelected()&&new Date-e.history.lastSelTime<=(e.cm?e.cm.options.historyEventDelay:500)}function oi(e,t,r,n){var i=e.history,o=n&&n.origin;r==i.lastSelOp||o&&i.lastSelOrigin==o&&(i.lastModTime==i.lastSelTime&&i.lastOrigin==o||ii(e,o,g(i.done),t))?i.done[i.done.length-1]=t:li(t,i.done),i.lastSelTime=+new Date,i.lastSelOrigin=o,i.lastSelOp=r,n&&!1!==n.clearRedo&&ti(i.undone)}function li(e,t){var r=g(t);r&&r.ranges&&r.equals(e)||t.push(e)}function si(e,t,r,n){var i=t["spans_"+e.id],o=0;e.iter(Math.max(e.first,r),Math.min(e.first+e.size,n),function(r){r.markedSpans&&((i||(i=t["spans_"+e.id]={}))[o]=r.markedSpans),++o})}function ai(e){if(!e)return null;for(var t,r=0;r<e.length;++r)e[r].marker.explicitlyCleared?t||(t=e.slice(0,r)):t&&t.push(e[r]);return t?t.length?t:null:e}function ui(e,t){var r=t["spans_"+e.id];if(!r)return null;for(var n=[],i=0;i<t.text.length;++i)n.push(ai(r[i]));return n}function ci(e,t){var r=ui(e,t),n=J(e,t);if(!r)return n;if(!n)return r;for(var i=0;i<r.length;++i){var o=r[i],l=n[i];if(o&&l)e:for(var s=0;s<l.length;++s){for(var a=l[s],u=0;u<o.length;++u)if(o[u].marker==a.marker)continue e;o.push(a)}else l&&(r[i]=l)}return r}function fi(e,t,r){for(var n=[],i=0;i<e.length;++i){var o=e[i];if(o.ranges)n.push(r?ks.prototype.deepCopy.call(o):o);else{var l=o.changes,s=[];n.push({changes:s});for(var a=0;a<l.length;++a){var u=l[a],c=void 0;if(s.push({from:u.from,to:u.to,text:u.text}),t)for(var f in u)(c=f.match(/^spans_(\d+)$/))&&h(t,Number(c[1]))>-1&&(g(s)[f]=u[f],delete u[f])}}}return n}function hi(e,t,r,n){if(n){var i=e.anchor;if(r){var o=P(t,i)<0;o!=P(r,i)<0?(i=t,t=r):o!=P(t,r)<0&&(t=r)}return new Ts(i,t)}return new Ts(r||t,t)}function di(e,t,r,n,i){null==i&&(i=e.cm&&(e.cm.display.shift||e.extend)),bi(e,new ks([hi(e.sel.primary(),t,r,i)],0),n)}function pi(e,t,r){for(var n=[],i=e.cm&&(e.cm.display.shift||e.extend),o=0;o<e.sel.ranges.length;o++)n[o]=hi(e.sel.ranges[o],t[o],null,i);bi(e,zn(n,e.sel.primIndex),r)}function gi(e,t,r,n){var i=e.sel.ranges.slice(0);i[t]=r,bi(e,zn(i,e.sel.primIndex),n)}function vi(e,t,r,n){bi(e,Rn(t,r),n)}function mi(e,t,r){var n={ranges:t.ranges,update:function(t){var r=this;this.ranges=[];for(var n=0;n<t.length;n++)r.ranges[n]=new Ts(U(e,t[n].anchor),U(e,t[n].head))},origin:r&&r.origin};return Te(e,"beforeSelectionChange",e,n),e.cm&&Te(e.cm,"beforeSelectionChange",e.cm,n),n.ranges!=t.ranges?zn(n.ranges,n.ranges.length-1):t}function yi(e,t,r){var n=e.history.done,i=g(n);i&&i.ranges?(n[n.length-1]=t,wi(e,t,r)):bi(e,t,r)}function bi(e,t,r){wi(e,t,r),oi(e,e.sel,e.cm?e.cm.curOp.id:NaN,r)}function wi(e,t,r){(Oe(e,"beforeSelectionChange")||e.cm&&Oe(e.cm,"beforeSelectionChange"))&&(t=mi(e,t,r)),xi(e,Si(e,t,r&&r.bias||(P(t.primary().head,e.sel.primary().head)<0?-1:1),!0)),r&&!1===r.scroll||!e.cm||jr(e.cm)}function xi(e,t){t.equals(e.sel)||(e.sel=t,e.cm&&(e.cm.curOp.updateInput=e.cm.curOp.selectionChanged=!0,Ne(e.cm)),bt(e,"cursorActivity",e))}function Ci(e){xi(e,Si(e,e.sel,null,!1))}function Si(e,t,r,n){for(var i,o=0;o<t.ranges.length;o++){var l=t.ranges[o],s=t.ranges.length==e.sel.ranges.length&&e.sel.ranges[o],a=ki(e,l.anchor,s&&s.anchor,r,n),u=ki(e,l.head,s&&s.head,r,n);(i||a!=l.anchor||u!=l.head)&&(i||(i=t.ranges.slice(0,o)),i[o]=new Ts(a,u))}return i?zn(i,t.primIndex):t}function Li(e,t,r,n,i){var o=M(e,t.line);if(o.markedSpans)for(var l=0;l<o.markedSpans.length;++l){var s=o.markedSpans[l],a=s.marker;if((null==s.from||(a.inclusiveLeft?s.from<=t.ch:s.from<t.ch))&&(null==s.to||(a.inclusiveRight?s.to>=t.ch:s.to>t.ch))){if(i&&(Te(a,"beforeCursorEnter"),a.explicitlyCleared)){if(o.markedSpans){--l;continue}break}if(!a.atomic)continue;if(r){var u=a.find(n<0?1:-1),c=void 0;if((n<0?a.inclusiveRight:a.inclusiveLeft)&&(u=Ti(e,u,-n,u&&u.line==t.line?o:null)),u&&u.line==t.line&&(c=P(u,r))&&(n<0?c<0:c>0))return Li(e,u,t,n,i)}var f=a.find(n<0?-1:1);return(n<0?a.inclusiveLeft:a.inclusiveRight)&&(f=Ti(e,f,n,f.line==t.line?o:null)),f?Li(e,f,t,n,i):null}}return t}function ki(e,t,r,n,i){var o=n||1,l=Li(e,t,r,o,i)||!i&&Li(e,t,r,o,!0)||Li(e,t,r,-o,i)||!i&&Li(e,t,r,-o,!0);return l||(e.cantEdit=!0,E(e.first,0))}function Ti(e,t,r,n){return r<0&&0==t.ch?t.line>e.first?U(e,E(t.line-1)):null:r>0&&t.ch==(n||M(e,t.line)).text.length?t.line<e.first+e.size-1?E(t.line+1,0):null:new E(t.line,t.ch+r)}function Mi(e){e.setSelection(E(e.firstLine(),0),E(e.lastLine()),Gl)}function Ni(e,t,r){var n={canceled:!1,from:t.from,to:t.to,text:t.text,origin:t.origin,cancel:function(){return n.canceled=!0}};return r&&(n.update=function(t,r,i,o){t&&(n.from=U(e,t)),r&&(n.to=U(e,r)),i&&(n.text=i),void 0!==o&&(n.origin=o)}),Te(e,"beforeChange",e,n),e.cm&&Te(e.cm,"beforeChange",e.cm,n),n.canceled?null:{from:n.from,to:n.to,text:n.text,origin:n.origin}}function Oi(e,t,r){if(e.cm){if(!e.cm.curOp)return dn(e.cm,Oi)(e,t,r);if(e.cm.state.suppressEdits)return}if(!(Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"))||(t=Ni(e,t,!0))){var n=Yl&&!r&&te(e,t.from,t.to);if(n)for(var i=n.length-1;i>=0;--i)Ai(e,{from:n[i].from,to:n[i].to,text:i?[""]:t.text,origin:t.origin});else Ai(e,t)}}function Ai(e,t){if(1!=t.text.length||""!=t.text[0]||0!=P(t.from,t.to)){var r=Un(e,t);ni(e,t,r,e.cm?e.cm.curOp.id:NaN),Hi(e,t,r,J(e,t));var n=[];$n(e,function(e,r){r||-1!=h(n,e.history)||(zi(e.history,t),n.push(e.history)),Hi(e,t,null,J(e,t))})}}function Wi(e,t,r){if(!e.cm||!e.cm.state.suppressEdits||r){for(var n,i=e.history,o=e.sel,l="undo"==t?i.done:i.undone,s="undo"==t?i.undone:i.done,a=0;a<l.length&&(n=l[a],r?!n.ranges||n.equals(e.sel):n.ranges);a++);if(a!=l.length){for(i.lastOrigin=i.lastSelOrigin=null;(n=l.pop()).ranges;){if(li(n,s),r&&!n.equals(e.sel))return void bi(e,n,{clearRedo:!1});o=n}var u=[];li(o,s),s.push({changes:u,generation:i.generation}),i.generation=n.generation||++i.maxGeneration;for(var c=Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"),f=n.changes.length-1;f>=0;--f){var d=function(r){var i=n.changes[r];if(i.origin=t,c&&!Ni(e,i,!1))return l.length=0,{};u.push(ei(e,i));var o=r?Un(e,i):g(l);Hi(e,i,o,ci(e,i)),!r&&e.cm&&e.cm.scrollIntoView({from:i.from,to:Bn(i)});var s=[];$n(e,function(e,t){t||-1!=h(s,e.history)||(zi(e.history,i),s.push(e.history)),Hi(e,i,null,ci(e,i))})}(f);if(d)return d.v}}}}function Di(e,t){if(0!=t&&(e.first+=t,e.sel=new ks(v(e.sel.ranges,function(e){return new Ts(E(e.anchor.line+t,e.anchor.ch),E(e.head.line+t,e.head.ch))}),e.sel.primIndex),e.cm)){vn(e.cm,e.first,e.first-t,t);for(var r=e.cm.display,n=r.viewFrom;n<r.viewTo;n++)mn(e.cm,n,"gutter")}}function Hi(e,t,r,n){if(e.cm&&!e.cm.curOp)return dn(e.cm,Hi)(e,t,r,n);if(t.to.line<e.first)Di(e,t.text.length-1-(t.to.line-t.from.line));else if(!(t.from.line>e.lastLine())){if(t.from.line<e.first){var i=t.text.length-1-(e.first-t.from.line);Di(e,i),t={from:E(e.first,0),to:E(t.to.line+i,t.to.ch),text:[g(t.text)],origin:t.origin}}var o=e.lastLine();t.to.line>o&&(t={from:t.from,to:E(o,M(e,o).text.length),text:[t.text[0]],origin:t.origin}),t.removed=N(e,t.from,t.to),r||(r=Un(e,t)),e.cm?Fi(e.cm,t,n):_n(e,t,n),wi(e,r,Gl)}}function Fi(e,t,r){var n=e.doc,i=e.display,o=t.from,l=t.to,s=!1,a=o.line;e.options.lineWrapping||(a=W(fe(M(n,o.line))),n.iter(a,l.line+1,function(e){if(e==i.maxLine)return s=!0,!0})),n.sel.contains(t.from,t.to)>-1&&Ne(e),_n(n,t,r,xr(e)),e.options.lineWrapping||(n.iter(a,o.line+t.text.length,function(e){var t=be(e);t>i.maxLineLength&&(i.maxLine=e,i.maxLineLength=t,i.maxLineChanged=!0,s=!1)}),s&&(e.curOp.updateMaxLine=!0)),nt(n,o.line),Cn(e,400);var u=t.text.length-(l.line-o.line)-1;t.full?vn(e):o.line!=l.line||1!=t.text.length||Yn(e.doc,t)?vn(e,o.line,l.line+1,u):mn(e,o.line,"text");var c=Oe(e,"changes"),f=Oe(e,"change");if(f||c){var h={from:o,to:l,text:t.text,removed:t.removed,origin:t.origin};f&&bt(e,"change",e,h),c&&(e.curOp.changeObjs||(e.curOp.changeObjs=[])).push(h)}e.display.selForContextMenu=null}function Ei(e,t,r,n,i){if(n||(n=r),P(n,r)<0){var o;r=(o=[n,r])[0],n=o[1]}"string"==typeof t&&(t=e.splitLines(t)),Oi(e,{from:r,to:n,text:t,origin:i})}function Pi(e,t,r,n){r<e.line?e.line+=n:t<e.line&&(e.line=t,e.ch=0)}function Ii(e,t,r,n){for(var i=0;i<e.length;++i){var o=e[i],l=!0;if(o.ranges){o.copied||((o=e[i]=o.deepCopy()).copied=!0);for(var s=0;s<o.ranges.length;s++)Pi(o.ranges[s].anchor,t,r,n),Pi(o.ranges[s].head,t,r,n)}else{for(var a=0;a<o.changes.length;++a){var u=o.changes[a];if(r<u.from.line)u.from=E(u.from.line+n,u.from.ch),u.to=E(u.to.line+n,u.to.ch);else if(t<=u.to.line){l=!1;break}}l||(e.splice(0,i+1),i=0)}}}function zi(e,t){var r=t.from.line,n=t.to.line,i=t.text.length-(n-r)-1;Ii(e.done,r,n,i),Ii(e.undone,r,n,i)}function Ri(e,t,r,n){var i=t,o=t;return"number"==typeof t?o=M(e,G(e,t)):i=W(t),null==i?null:(n(o,i)&&e.cm&&mn(e.cm,i,r),o)}function Bi(e){var t=this;this.lines=e,this.parent=null;for(var r=0,n=0;n<e.length;++n)e[n].parent=t,r+=e[n].height;this.height=r}function Gi(e){var t=this;this.children=e;for(var r=0,n=0,i=0;i<e.length;++i){var o=e[i];r+=o.chunkSize(),n+=o.height,o.parent=t}this.size=r,this.height=n,this.parent=null}function Ui(e,t,r){ye(t)<(e.curOp&&e.curOp.scrollTop||e.doc.scrollTop)&&Kr(e,r)}function Vi(e,t,r,n){var i=new Ms(e,r,n),o=e.cm;return o&&i.noHScroll&&(o.display.alignWidgets=!0),Ri(e,t,"widget",function(t){var r=t.widgets||(t.widgets=[]);if(null==i.insertAt?r.push(i):r.splice(Math.min(r.length-1,Math.max(0,i.insertAt)),0,i),i.line=t,o&&!ve(e,t)){var n=ye(t)<e.scrollTop;A(t,t.height+Ht(i)),n&&Kr(o,i.height),o.curOp.forceUpdate=!0}return!0}),bt(o,"lineWidgetAdded",o,i,"number"==typeof t?t:W(t)),i}function Ki(e,t,r,n,o){if(n&&n.shared)return ji(e,t,r,n,o);if(e.cm&&!e.cm.curOp)return dn(e.cm,Ki)(e,t,r,n,o);var l=new Os(e,o),s=P(t,r);if(n&&c(n,l,!1),s>0||0==s&&!1!==l.clearWhenEmpty)return l;if(l.replacedWith&&(l.collapsed=!0,l.widgetNode=i("span",[l.replacedWith],"CodeMirror-widget"),n.handleMouseEvents||l.widgetNode.setAttribute("cm-ignore-events","true"),n.insertLeft&&(l.widgetNode.insertLeft=!0)),l.collapsed){if(ce(e,t.line,t,r,l)||t.line!=r.line&&ce(e,r.line,t,r,l))throw new Error("Inserting collapsed marker partially overlapping an existing one");X()}l.addToHistory&&ni(e,{from:t,to:r,origin:"markText"},e.sel,NaN);var a,u=t.line,f=e.cm;if(e.iter(u,r.line+1,function(e){f&&l.collapsed&&!f.options.lineWrapping&&fe(e)==f.display.maxLine&&(a=!0),l.collapsed&&u!=t.line&&A(e,0),q(e,new Y(l,u==t.line?t.ch:null,u==r.line?r.ch:null)),++u}),l.collapsed&&e.iter(t.line,r.line+1,function(t){ve(e,t)&&A(t,0)}),l.clearOnEnter&&Ql(l,"beforeCursorEnter",function(){return l.clear()}),l.readOnly&&(j(),(e.history.done.length||e.history.undone.length)&&e.clearHistory()),l.collapsed&&(l.id=++Ns,l.atomic=!0),f){if(a&&(f.curOp.updateMaxLine=!0),l.collapsed)vn(f,t.line,r.line+1);else if(l.className||l.title||l.startStyle||l.endStyle||l.css)for(var h=t.line;h<=r.line;h++)mn(f,h,"text");l.atomic&&Ci(f.doc),bt(f,"markerAdded",f,l)}return l}function ji(e,t,r,n,i){(n=c(n)).shared=!1;var o=[Ki(e,t,r,n,i)],l=o[0],s=n.widgetNode;return $n(e,function(e){s&&(n.widgetNode=s.cloneNode(!0)),o.push(Ki(e,U(e,t),U(e,r),n,i));for(var a=0;a<e.linked.length;++a)if(e.linked[a].isParent)return;l=g(o)}),new As(o,l)}function Xi(e){return e.findMarks(E(e.first,0),e.clipPos(E(e.lastLine())),function(e){return e.parent})}function Yi(e,t){for(var r=0;r<t.length;r++){var n=t[r],i=n.find(),o=e.clipPos(i.from),l=e.clipPos(i.to);if(P(o,l)){var s=Ki(e,o,l,n.primary,n.primary.type);n.markers.push(s),s.parent=n}}}function _i(e){for(var t=0;t<e.length;t++)!function(t){var r=e[t],n=[r.primary.doc];$n(r.primary.doc,function(e){return n.push(e)});for(var i=0;i<r.markers.length;i++){var o=r.markers[i];-1==h(n,o.doc)&&(o.parent=null,r.markers.splice(i--,1))}}(t)}function $i(e){var t=this;if(Qi(t),!Me(t,e)&&!Ft(t.display,e)){We(e),gl&&(Hs=+new Date);var r=Sr(t,e,!0),n=e.dataTransfer.files;if(r&&!t.isReadOnly())if(n&&n.length&&window.FileReader&&window.File)for(var i=n.length,o=Array(i),l=0,s=0;s<i;++s)!function(e,n){if(!t.options.allowDropFileTypes||-1!=h(t.options.allowDropFileTypes,e.type)){var s=new FileReader;s.onload=dn(t,function(){var e=s.result;if(/[\x00-\x08\x0e-\x1f]{2}/.test(e)&&(e=""),o[n]=e,++l==i){var a={from:r=U(t.doc,r),to:r,text:t.doc.splitLines(o.join(t.doc.lineSeparator())),origin:"paste"};Oi(t.doc,a),yi(t.doc,Rn(r,Bn(a)))}}),s.readAsText(e)}}(n[s],s);else{if(t.state.draggingText&&t.doc.sel.contains(r)>-1)return t.state.draggingText(e),void setTimeout(function(){return t.display.input.focus()},20);try{var a=e.dataTransfer.getData("Text");if(a){var u;if(t.state.draggingText&&!t.state.draggingText.copy&&(u=t.listSelections()),wi(t.doc,Rn(r,r)),u)for(var c=0;c<u.length;++c)Ei(t.doc,"",u[c].anchor,u[c].head,"drag");t.replaceSelection(a,"around","paste"),t.display.input.focus()}}catch(e){}}}}function qi(e,t){if(gl&&(!e.state.draggingText||+new Date-Hs<100))Fe(t);else if(!Me(e,t)&&!Ft(e.display,t)&&(t.dataTransfer.setData("Text",e.getSelection()),t.dataTransfer.effectAllowed="copyMove",t.dataTransfer.setDragImage&&!xl)){var r=n("img",null,null,"position: fixed; left: 0; top: 0;");r.src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",wl&&(r.width=r.height=1,e.display.wrapper.appendChild(r),r._top=r.offsetTop),t.dataTransfer.setDragImage(r,0,0),wl&&r.parentNode.removeChild(r)}}function Zi(e,t){var i=Sr(e,t);if(i){var o=document.createDocumentFragment();Mr(e,i,o),e.display.dragCursor||(e.display.dragCursor=n("div",null,"CodeMirror-cursors CodeMirror-dragcursors"),e.display.lineSpace.insertBefore(e.display.dragCursor,e.display.cursorDiv)),r(e.display.dragCursor,o)}}function Qi(e){e.display.dragCursor&&(e.display.lineSpace.removeChild(e.display.dragCursor),e.display.dragCursor=null)}function Ji(e){if(document.getElementsByClassName)for(var t=document.getElementsByClassName("CodeMirror"),r=0;r<t.length;r++){var n=t[r].CodeMirror;n&&e(n)}}function eo(){Fs||(to(),Fs=!0)}function to(){var e;Ql(window,"resize",function(){null==e&&(e=setTimeout(function(){e=null,Ji(ro)},100))}),Ql(window,"blur",function(){return Ji(Fr)})}function ro(e){var t=e.display;t.lastWrapHeight==t.wrapper.clientHeight&&t.lastWrapWidth==t.wrapper.clientWidth||(t.cachedCharWidth=t.cachedTextHeight=t.cachedPaddingH=null,t.scrollbarsClipped=!1,e.setSize())}function no(e){var t=e.split(/-(?!$)/);e=t[t.length-1];for(var r,n,i,o,l=0;l<t.length-1;l++){var s=t[l];if(/^(cmd|meta|m)$/i.test(s))o=!0;else if(/^a(lt)?$/i.test(s))r=!0;else if(/^(c|ctrl|control)$/i.test(s))n=!0;else{if(!/^s(hift)?$/i.test(s))throw new Error("Unrecognized modifier name: "+s);i=!0}}return r&&(e="Alt-"+e),n&&(e="Ctrl-"+e),o&&(e="Cmd-"+e),i&&(e="Shift-"+e),e}function io(e){var t={};for(var r in e)if(e.hasOwnProperty(r)){var n=e[r];if(/^(name|fallthrough|(de|at)tach)$/.test(r))continue;if("..."==n){delete e[r];continue}for(var i=v(r.split(" "),no),o=0;o<i.length;o++){var l=void 0,s=void 0;o==i.length-1?(s=i.join(" "),l=n):(s=i.slice(0,o+1).join(" "),l="...");var a=t[s];if(a){if(a!=l)throw new Error("Inconsistent bindings for "+s)}else t[s]=l}delete e[r]}for(var u in t)e[u]=t[u];return e}function oo(e,t,r,n){var i=(t=uo(t)).call?t.call(e,n):t[e];if(!1===i)return"nothing";if("..."===i)return"multi";if(null!=i&&r(i))return"handled";if(t.fallthrough){if("[object Array]"!=Object.prototype.toString.call(t.fallthrough))return oo(e,t.fallthrough,r,n);for(var o=0;o<t.fallthrough.length;o++){var l=oo(e,t.fallthrough[o],r,n);if(l)return l}}}function lo(e){var t="string"==typeof e?e:Es[e.keyCode];return"Ctrl"==t||"Alt"==t||"Shift"==t||"Mod"==t}function so(e,t,r){var n=e;return t.altKey&&"Alt"!=n&&(e="Alt-"+e),(Dl?t.metaKey:t.ctrlKey)&&"Ctrl"!=n&&(e="Ctrl-"+e),(Dl?t.ctrlKey:t.metaKey)&&"Cmd"!=n&&(e="Cmd-"+e),!r&&t.shiftKey&&"Shift"!=n&&(e="Shift-"+e),e}function ao(e,t){if(wl&&34==e.keyCode&&e.char)return!1;var r=Es[e.keyCode];return null!=r&&!e.altGraphKey&&so(r,e,t)}function uo(e){return"string"==typeof e?Rs[e]:e}function co(e,t){for(var r=e.doc.sel.ranges,n=[],i=0;i<r.length;i++){for(var o=t(r[i]);n.length&&P(o.from,g(n).to)<=0;){var l=n.pop();if(P(l.from,o.from)<0){o.from=l.from;break}}n.push(o)}hn(e,function(){for(var t=n.length-1;t>=0;t--)Ei(e.doc,"",n[t].from,n[t].to,"+delete");jr(e)})}function fo(e,t,r){var n=L(e.text,t+r,r);return n<0||n>e.text.length?null:n}function ho(e,t,r){var n=fo(e,t.ch,r);return null==n?null:new E(t.line,n,r<0?"after":"before")}function po(e,t,r,n,i){if(e){var o=Se(r,t.doc.direction);if(o){var l,s=i<0?g(o):o[0],a=i<0==(1==s.level)?"after":"before";if(s.level>0){var u=Xt(t,r);l=i<0?r.text.length-1:0;var c=Yt(t,u,l).top;l=k(function(e){return Yt(t,u,e).top==c},i<0==(1==s.level)?s.from:s.to-1,l),"before"==a&&(l=fo(r,l,1))}else l=i<0?s.to:s.from;return new E(n,l,a)}}return new E(n,i<0?r.text.length:0,i<0?"before":"after")}function go(e,t,r,n){var i=Se(t,e.doc.direction);if(!i)return ho(t,r,n);r.ch>=t.text.length?(r.ch=t.text.length,r.sticky="before"):r.ch<=0&&(r.ch=0,r.sticky="after");var o=Ce(i,r.ch,r.sticky),l=i[o];if("ltr"==e.doc.direction&&l.level%2==0&&(n>0?l.to>r.ch:l.from<r.ch))return ho(t,r,n);var s,a=function(e,r){return fo(t,e instanceof E?e.ch:e,r)},u=function(r){return e.options.lineWrapping?(s=s||Xt(e,t),hr(e,t,s,r)):{begin:0,end:t.text.length}},c=u("before"==r.sticky?a(r,-1):r.ch);if("rtl"==e.doc.direction||1==l.level){var f=1==l.level==n<0,h=a(r,f?1:-1);if(null!=h&&(f?h<=l.to&&h<=c.end:h>=l.from&&h>=c.begin)){var d=f?"before":"after";return new E(r.line,h,d)}}var p=function(e,t,n){for(var o=function(e,t){return t?new E(r.line,a(e,1),"before"):new E(r.line,e,"after")};e>=0&&e<i.length;e+=t){var l=i[e],s=t>0==(1!=l.level),u=s?n.begin:a(n.end,-1);if(l.from<=u&&u<l.to)return o(u,s);if(u=s?l.from:a(l.to,-1),n.begin<=u&&u<n.end)return o(u,s)}},g=p(o+n,n,c);if(g)return g;var v=n>0?c.end:a(c.begin,-1);return null==v||n>0&&v==t.text.length||!(g=p(n>0?0:i.length-1,n,u(v)))?null:g}function vo(e,t){var r=M(e.doc,t),n=fe(r);return n!=r&&(t=W(n)),po(!0,e,n,t,1)}function mo(e,t){var r=M(e.doc,t),n=he(r);return n!=r&&(t=W(n)),po(!0,e,r,t,-1)}function yo(e,t){var r=vo(e,t.line),n=M(e.doc,r.line),i=Se(n,e.doc.direction);if(!i||0==i[0].level){var o=Math.max(0,n.text.search(/\S/)),l=t.line==r.line&&t.ch<=o&&t.ch;return E(r.line,l?0:o,r.sticky)}return r}function bo(e,t,r){if("string"==typeof t&&!(t=Bs[t]))return!1;e.display.input.ensurePolled();var n=e.display.shift,i=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),r&&(e.display.shift=!1),i=t(e)!=Bl}finally{e.display.shift=n,e.state.suppressEdits=!1}return i}function wo(e,t,r){for(var n=0;n<e.state.keyMaps.length;n++){var i=oo(t,e.state.keyMaps[n],r,e);if(i)return i}return e.options.extraKeys&&oo(t,e.options.extraKeys,r,e)||oo(t,e.options.keyMap,r,e)}function xo(e,t,r,n){var i=e.state.keySeq;if(i){if(lo(t))return"handled";Gs.set(50,function(){e.state.keySeq==i&&(e.state.keySeq=null,e.display.input.reset())}),t=i+" "+t}var o=wo(e,t,n);return"multi"==o&&(e.state.keySeq=t),"handled"==o&&bt(e,"keyHandled",e,t,r),"handled"!=o&&"multi"!=o||(We(r),Ar(e)),i&&!o&&/\'$/.test(t)?(We(r),!0):!!o}function Co(e,t){var r=ao(t,!0);return!!r&&(t.shiftKey&&!e.state.keySeq?xo(e,"Shift-"+r,t,function(t){return bo(e,t,!0)})||xo(e,r,t,function(t){if("string"==typeof t?/^go[A-Z]/.test(t):t.motion)return bo(e,t)}):xo(e,r,t,function(t){return bo(e,t)}))}function So(e,t,r){return xo(e,"'"+r+"'",t,function(t){return bo(e,t,!0)})}function Lo(e){var t=this;if(t.curOp.focus=l(),!Me(t,e)){gl&&vl<11&&27==e.keyCode&&(e.returnValue=!1);var r=e.keyCode;t.display.shift=16==r||e.shiftKey;var n=Co(t,e);wl&&(Us=n?r:null,!n&&88==r&&!rs&&(Ml?e.metaKey:e.ctrlKey)&&t.replaceSelection("",null,"cut")),18!=r||/\bCodeMirror-crosshair\b/.test(t.display.lineDiv.className)||ko(t)}}function ko(e){function t(e){18!=e.keyCode&&e.altKey||(Fl(r,"CodeMirror-crosshair"),ke(document,"keyup",t),ke(document,"mouseover",t))}var r=e.display.lineDiv;s(r,"CodeMirror-crosshair"),Ql(document,"keyup",t),Ql(document,"mouseover",t)}function To(e){16==e.keyCode&&(this.doc.sel.shift=!1),Me(this,e)}function Mo(e){var t=this;if(!(Ft(t.display,e)||Me(t,e)||e.ctrlKey&&!e.altKey||Ml&&e.metaKey)){var r=e.keyCode,n=e.charCode;if(wl&&r==Us)return Us=null,void We(e);if(!wl||e.which&&!(e.which<10)||!Co(t,e)){var i=String.fromCharCode(null==n?r:n);"\b"!=i&&(So(t,e,i)||t.display.input.onKeyPress(e))}}}function No(e,t){var r=+new Date;return js&&js.compare(r,e,t)?(Ks=js=null,"triple"):Ks&&Ks.compare(r,e,t)?(js=new Vs(r,e,t),Ks=null,"double"):(Ks=new Vs(r,e,t),js=null,"single")}function Oo(e){var t=this,r=t.display;if(!(Me(t,e)||r.activeTouch&&r.input.supportsTouch()))if(r.input.ensurePolled(),r.shift=e.shiftKey,Ft(r,e))ml||(r.scroller.draggable=!1,setTimeout(function(){return r.scroller.draggable=!0},100));else if(!zo(t,e)){var n=Sr(t,e),i=Pe(e),o=n?No(n,i):"single";window.focus(),1==i&&t.state.selectingText&&t.state.selectingText(e),n&&Ao(t,i,n,o,e)||(1==i?n?Do(t,n,o,e):Ee(e)==r.scroller&&We(e):2==i?(n&&di(t.doc,n),setTimeout(function(){return r.input.focus()},20)):3==i&&(Hl?Ro(t,e):Dr(t)))}}function Ao(e,t,r,n,i){var o="Click";return"double"==n?o="Double"+o:"triple"==n&&(o="Triple"+o),o=(1==t?"Left":2==t?"Middle":"Right")+o,xo(e,so(o,i),i,function(t){if("string"==typeof t&&(t=Bs[t]),!t)return!1;var n=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),n=t(e,r)!=Bl}finally{e.state.suppressEdits=!1}return n})}function Wo(e,t,r){var n=e.getOption("configureMouse"),i=n?n(e,t,r):{};if(null==i.unit){var o=Nl?r.shiftKey&&r.metaKey:r.altKey;i.unit=o?"rectangle":"single"==t?"char":"double"==t?"word":"line"}return(null==i.extend||e.doc.extend)&&(i.extend=e.doc.extend||r.shiftKey),null==i.addNew&&(i.addNew=Ml?r.metaKey:r.ctrlKey),null==i.moveOnDrag&&(i.moveOnDrag=!(Ml?r.altKey:r.ctrlKey)),i}function Do(e,t,r,n){gl?setTimeout(u(Wr,e),0):e.curOp.focus=l();var i,o=Wo(e,r,n),s=e.doc.sel;e.options.dragDrop&&Jl&&!e.isReadOnly()&&"single"==r&&(i=s.contains(t))>-1&&(P((i=s.ranges[i]).from(),t)<0||t.xRel>0)&&(P(i.to(),t)>0||t.xRel<0)?Ho(e,n,t,o):Eo(e,n,t,o)}function Ho(e,t,r,n){var i=e.display,o=!1,l=dn(e,function(t){ml&&(i.scroller.draggable=!1),e.state.draggingText=!1,ke(document,"mouseup",l),ke(document,"mousemove",s),ke(i.scroller,"dragstart",a),ke(i.scroller,"drop",l),o||(We(t),n.addNew||di(e.doc,r,null,null,n.extend),ml||gl&&9==vl?setTimeout(function(){document.body.focus(),i.input.focus()},20):i.input.focus())}),s=function(e){o=o||Math.abs(t.clientX-e.clientX)+Math.abs(t.clientY-e.clientY)>=10},a=function(){return o=!0};ml&&(i.scroller.draggable=!0),e.state.draggingText=l,l.copy=!n.moveOnDrag,i.scroller.dragDrop&&i.scroller.dragDrop(),Ql(document,"mouseup",l),Ql(document,"mousemove",s),Ql(i.scroller,"dragstart",a),Ql(i.scroller,"drop",l),Dr(e),setTimeout(function(){return i.input.focus()},20)}function Fo(e,t,r){if("char"==r)return new Ts(t,t);if("word"==r)return e.findWordAt(t);if("line"==r)return new Ts(E(t.line,0),U(e.doc,E(t.line+1,0)));var n=r(e,t);return new Ts(n.from,n.to)}function Eo(e,t,r,n){function i(t){if(0!=P(m,t))if(m=t,"rectangle"==n.unit){for(var i=[],o=e.options.tabSize,l=f(M(u,r.line).text,r.ch,o),s=f(M(u,t.line).text,t.ch,o),a=Math.min(l,s),g=Math.max(l,s),v=Math.min(r.line,t.line),y=Math.min(e.lastLine(),Math.max(r.line,t.line));v<=y;v++){var b=M(u,v).text,w=d(b,a,o);a==g?i.push(new Ts(E(v,w),E(v,w))):b.length>w&&i.push(new Ts(E(v,w),E(v,d(b,g,o))))}i.length||i.push(new Ts(r,r)),bi(u,zn(p.ranges.slice(0,h).concat(i),h),{origin:"*mouse",scroll:!1}),e.scrollIntoView(t)}else{var x,C=c,S=Fo(e,t,n.unit),L=C.anchor;P(S.anchor,L)>0?(x=S.head,L=B(C.from(),S.anchor)):(x=S.anchor,L=R(C.to(),S.head));var k=p.ranges.slice(0);k[h]=Po(e,new Ts(U(u,L),x)),bi(u,zn(k,h),Ul)}}function o(t){var r=++b,s=Sr(e,t,!0,"rectangle"==n.unit);if(s)if(0!=P(s,m)){e.curOp.focus=l(),i(s);var c=Ir(a,u);(s.line>=c.to||s.line<c.from)&&setTimeout(dn(e,function(){b==r&&o(t)}),150)}else{var f=t.clientY<y.top?-20:t.clientY>y.bottom?20:0;f&&setTimeout(dn(e,function(){b==r&&(a.scroller.scrollTop+=f,o(t))}),50)}}function s(t){e.state.selectingText=!1,b=1/0,We(t),a.input.focus(),ke(document,"mousemove",w),ke(document,"mouseup",x),u.history.lastSelOrigin=null}var a=e.display,u=e.doc;We(t);var c,h,p=u.sel,g=p.ranges;if(n.addNew&&!n.extend?(h=u.sel.contains(r),c=h>-1?g[h]:new Ts(r,r)):(c=u.sel.primary(),h=u.sel.primIndex),"rectangle"==n.unit)n.addNew||(c=new Ts(r,r)),r=Sr(e,t,!0,!0),h=-1;else{var v=Fo(e,r,n.unit);c=n.extend?hi(c,v.anchor,v.head,n.extend):v}n.addNew?-1==h?(h=g.length,bi(u,zn(g.concat([c]),h),{scroll:!1,origin:"*mouse"})):g.length>1&&g[h].empty()&&"char"==n.unit&&!n.extend?(bi(u,zn(g.slice(0,h).concat(g.slice(h+1)),0),{scroll:!1,origin:"*mouse"}),p=u.sel):gi(u,h,c,Ul):(h=0,bi(u,new ks([c],0),Ul),p=u.sel);var m=r,y=a.wrapper.getBoundingClientRect(),b=0,w=dn(e,function(e){Pe(e)?o(e):s(e)}),x=dn(e,s);e.state.selectingText=x,Ql(document,"mousemove",w),Ql(document,"mouseup",x)}function Po(e,t){var r=t.anchor,n=t.head,i=M(e.doc,r.line);if(0==P(r,n)&&r.sticky==n.sticky)return t;var o=Se(i);if(!o)return t;var l=Ce(o,r.ch,r.sticky),s=o[l];if(s.from!=r.ch&&s.to!=r.ch)return t;var a=l+(s.from==r.ch==(1!=s.level)?0:1);if(0==a||a==o.length)return t;var u;if(n.line!=r.line)u=(n.line-r.line)*("ltr"==e.doc.direction?1:-1)>0;else{var c=Ce(o,n.ch,n.sticky),f=c-l||(n.ch-r.ch)*(1==s.level?-1:1);u=c==a-1||c==a?f<0:f>0}var h=o[a+(u?-1:0)],d=u==(1==h.level),p=d?h.from:h.to,g=d?"after":"before";return r.ch==p&&r.sticky==g?t:new Ts(new E(r.line,p,g),n)}function Io(e,t,r,n){var i,o;if(t.touches)i=t.touches[0].clientX,o=t.touches[0].clientY;else try{i=t.clientX,o=t.clientY}catch(t){return!1}if(i>=Math.floor(e.display.gutters.getBoundingClientRect().right))return!1;n&&We(t);var l=e.display,s=l.lineDiv.getBoundingClientRect();if(o>s.bottom||!Oe(e,r))return He(t);o-=s.top-l.viewOffset;for(var a=0;a<e.options.gutters.length;++a){var u=l.gutters.childNodes[a];if(u&&u.getBoundingClientRect().right>=i)return Te(e,r,e,D(e.doc,o),e.options.gutters[a],t),He(t)}}function zo(e,t){return Io(e,t,"gutterClick",!0)}function Ro(e,t){Ft(e.display,t)||Bo(e,t)||Me(e,t,"contextmenu")||e.display.input.onContextMenu(t)}function Bo(e,t){return!!Oe(e,"gutterContextMenu")&&Io(e,t,"gutterContextMenu",!1)}function Go(e){e.display.wrapper.className=e.display.wrapper.className.replace(/\s*cm-s-\S+/g,"")+e.options.theme.replace(/(^|\s)\s*/g," cm-s-"),er(e)}function Uo(e){Hn(e),vn(e),zr(e)}function Vo(e,t,r){if(!t!=!(r&&r!=Xs)){var n=e.display.dragFunctions,i=t?Ql:ke;i(e.display.scroller,"dragstart",n.start),i(e.display.scroller,"dragenter",n.enter),i(e.display.scroller,"dragover",n.over),i(e.display.scroller,"dragleave",n.leave),i(e.display.scroller,"drop",n.drop)}}function Ko(e){e.options.lineWrapping?(s(e.display.wrapper,"CodeMirror-wrap"),e.display.sizer.style.minWidth="",e.display.sizerWidth=null):(Fl(e.display.wrapper,"CodeMirror-wrap"),we(e)),Cr(e),vn(e),er(e),setTimeout(function(){return en(e)},100)}function jo(e,t){var r=this;if(!(this instanceof jo))return new jo(e,t);this.options=t=t?c(t):{},c(Ys,t,!1),Fn(t);var n=t.value;"string"==typeof n&&(n=new Ds(n,t.mode,null,t.lineSeparator,t.direction)),this.doc=n;var i=new jo.inputStyles[t.inputStyle](this),o=this.display=new T(e,n,i);o.wrapper.CodeMirror=this,Hn(this),Go(this),t.lineWrapping&&(this.display.wrapper.className+=" CodeMirror-wrap"),rn(this),this.state={keyMaps:[],overlays:[],modeGen:0,overwrite:!1,delayingBlurEvent:!1,focused:!1,suppressEdits:!1,pasteIncoming:!1,cutIncoming:!1,selectingText:!1,draggingText:!1,highlight:new Pl,keySeq:null,specialChars:null},t.autofocus&&!Tl&&o.input.focus(),gl&&vl<11&&setTimeout(function(){return r.display.input.reset(!0)},20),Xo(this),eo(),nn(this),this.curOp.forceUpdate=!0,qn(this,n),t.autofocus&&!Tl||this.hasFocus()?setTimeout(u(Hr,this),20):Fr(this);for(var l in _s)_s.hasOwnProperty(l)&&_s[l](r,t[l],Xs);Rr(this),t.finishInit&&t.finishInit(this);for(var s=0;s<$s.length;++s)$s[s](r);on(this),ml&&t.lineWrapping&&"optimizelegibility"==getComputedStyle(o.lineDiv).textRendering&&(o.lineDiv.style.textRendering="auto")}function Xo(e){function t(){i.activeTouch&&(o=setTimeout(function(){return i.activeTouch=null},1e3),(l=i.activeTouch).end=+new Date)}function r(e){if(1!=e.touches.length)return!1;var t=e.touches[0];return t.radiusX<=1&&t.radiusY<=1}function n(e,t){if(null==t.left)return!0;var r=t.left-e.left,n=t.top-e.top;return r*r+n*n>400}var i=e.display;Ql(i.scroller,"mousedown",dn(e,Oo)),gl&&vl<11?Ql(i.scroller,"dblclick",dn(e,function(t){if(!Me(e,t)){var r=Sr(e,t);if(r&&!zo(e,t)&&!Ft(e.display,t)){We(t);var n=e.findWordAt(r);di(e.doc,n.anchor,n.head)}}})):Ql(i.scroller,"dblclick",function(t){return Me(e,t)||We(t)}),Hl||Ql(i.scroller,"contextmenu",function(t){return Ro(e,t)});var o,l={end:0};Ql(i.scroller,"touchstart",function(t){if(!Me(e,t)&&!r(t)&&!zo(e,t)){i.input.ensurePolled(),clearTimeout(o);var n=+new Date;i.activeTouch={start:n,moved:!1,prev:n-l.end<=300?l:null},1==t.touches.length&&(i.activeTouch.left=t.touches[0].pageX,i.activeTouch.top=t.touches[0].pageY)}}),Ql(i.scroller,"touchmove",function(){i.activeTouch&&(i.activeTouch.moved=!0)}),Ql(i.scroller,"touchend",function(r){var o=i.activeTouch;if(o&&!Ft(i,r)&&null!=o.left&&!o.moved&&new Date-o.start<300){var l,s=e.coordsChar(i.activeTouch,"page");l=!o.prev||n(o,o.prev)?new Ts(s,s):!o.prev.prev||n(o,o.prev.prev)?e.findWordAt(s):new Ts(E(s.line,0),U(e.doc,E(s.line+1,0))),e.setSelection(l.anchor,l.head),e.focus(),We(r)}t()}),Ql(i.scroller,"touchcancel",t),Ql(i.scroller,"scroll",function(){i.scroller.clientHeight&&(qr(e,i.scroller.scrollTop),Qr(e,i.scroller.scrollLeft,!0),Te(e,"scroll",e))}),Ql(i.scroller,"mousewheel",function(t){return In(e,t)}),Ql(i.scroller,"DOMMouseScroll",function(t){return In(e,t)}),Ql(i.wrapper,"scroll",function(){return i.wrapper.scrollTop=i.wrapper.scrollLeft=0}),i.dragFunctions={enter:function(t){Me(e,t)||Fe(t)},over:function(t){Me(e,t)||(Zi(e,t),Fe(t))},start:function(t){return qi(e,t)},drop:dn(e,$i),leave:function(t){Me(e,t)||Qi(e)}};var s=i.input.getField();Ql(s,"keyup",function(t){return To.call(e,t)}),Ql(s,"keydown",dn(e,Lo)),Ql(s,"keypress",dn(e,Mo)),Ql(s,"focus",function(t){return Hr(e,t)}),Ql(s,"blur",function(t){return Fr(e,t)})}function Yo(e,t,r,n){var i,o=e.doc;null==r&&(r="add"),"smart"==r&&(o.mode.indent?i=$e(e,t).state:r="prev");var l=e.options.tabSize,s=M(o,t),a=f(s.text,null,l);s.stateAfter&&(s.stateAfter=null);var u,c=s.text.match(/^\s*/)[0];if(n||/\S/.test(s.text)){if("smart"==r&&((u=o.mode.indent(i,s.text.slice(c.length),s.text))==Bl||u>150)){if(!n)return;r="prev"}}else u=0,r="not";"prev"==r?u=t>o.first?f(M(o,t-1).text,null,l):0:"add"==r?u=a+e.options.indentUnit:"subtract"==r?u=a-e.options.indentUnit:"number"==typeof r&&(u=a+r),u=Math.max(0,u);var h="",d=0;if(e.options.indentWithTabs)for(var g=Math.floor(u/l);g;--g)d+=l,h+="\t";if(d<u&&(h+=p(u-d)),h!=c)return Ei(o,h,E(t,0),E(t,c.length),"+input"),s.stateAfter=null,!0;for(var v=0;v<o.sel.ranges.length;v++){var m=o.sel.ranges[v];if(m.head.line==t&&m.head.ch<c.length){var y=E(t,c.length);gi(o,v,new Ts(y,y));break}}}function _o(e){qs=e}function $o(e,t,r,n,i){var o=e.doc;e.display.shift=!1,n||(n=o.sel);var l=e.state.pasteIncoming||"paste"==i,s=es(t),a=null;if(l&&n.ranges.length>1)if(qs&&qs.text.join("\n")==t){if(n.ranges.length%qs.text.length==0){a=[];for(var u=0;u<qs.text.length;u++)a.push(o.splitLines(qs.text[u]))}}else s.length==n.ranges.length&&e.options.pasteLinesPerSelection&&(a=v(s,function(e){return[e]}));for(var c,f=n.ranges.length-1;f>=0;f--){var h=n.ranges[f],d=h.from(),p=h.to();h.empty()&&(r&&r>0?d=E(d.line,d.ch-r):e.state.overwrite&&!l?p=E(p.line,Math.min(M(o,p.line).text.length,p.ch+g(s).length)):qs&&qs.lineWise&&qs.text.join("\n")==t&&(d=p=E(d.line,0))),c=e.curOp.updateInput;var m={from:d,to:p,text:a?a[f%a.length]:s,origin:i||(l?"paste":e.state.cutIncoming?"cut":"+input")};Oi(e.doc,m),bt(e,"inputRead",e,m)}t&&!l&&Zo(e,t),jr(e),e.curOp.updateInput=c,e.curOp.typing=!0,e.state.pasteIncoming=e.state.cutIncoming=!1}function qo(e,t){var r=e.clipboardData&&e.clipboardData.getData("Text");if(r)return e.preventDefault(),t.isReadOnly()||t.options.disableInput||hn(t,function(){return $o(t,r,0,null,"paste")}),!0}function Zo(e,t){if(e.options.electricChars&&e.options.smartIndent)for(var r=e.doc.sel,n=r.ranges.length-1;n>=0;n--){var i=r.ranges[n];if(!(i.head.ch>100||n&&r.ranges[n-1].head.line==i.head.line)){var o=e.getModeAt(i.head),l=!1;if(o.electricChars){for(var s=0;s<o.electricChars.length;s++)if(t.indexOf(o.electricChars.charAt(s))>-1){l=Yo(e,i.head.line,"smart");break}}else o.electricInput&&o.electricInput.test(M(e.doc,i.head.line).text.slice(0,i.head.ch))&&(l=Yo(e,i.head.line,"smart"));l&&bt(e,"electricInput",e,i.head.line)}}}function Qo(e){for(var t=[],r=[],n=0;n<e.doc.sel.ranges.length;n++){var i=e.doc.sel.ranges[n].head.line,o={anchor:E(i,0),head:E(i+1,0)};r.push(o),t.push(e.getRange(o.anchor,o.head))}return{text:t,ranges:r}}function Jo(e,t){e.setAttribute("autocorrect","off"),e.setAttribute("autocapitalize","off"),e.setAttribute("spellcheck",!!t)}function el(){var e=n("textarea",null,null,"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none"),t=n("div",[e],null,"overflow: hidden; position: relative; width: 3px; height: 0px;");return ml?e.style.width="1000px":e.setAttribute("wrap","off"),Ll&&(e.style.border="1px solid black"),Jo(e),t}function tl(e,t,r,n,i){function o(){var n=t.line+r;return!(n<e.first||n>=e.first+e.size)&&(t=new E(n,t.ch,t.sticky),u=M(e,n))}function l(n){var l;if(null==(l=i?go(e.cm,u,t,r):ho(u,t,r))){if(n||!o())return!1;t=po(i,e.cm,u,t.line,r)}else t=l;return!0}var s=t,a=r,u=M(e,t.line);if("char"==n)l();else if("column"==n)l(!0);else if("word"==n||"group"==n)for(var c=null,f="group"==n,h=e.cm&&e.cm.getHelper(t,"wordChars"),d=!0;!(r<0)||l(!d);d=!1){var p=u.text.charAt(t.ch)||"\n",g=x(p,h)?"w":f&&"\n"==p?"n":!f||/\s/.test(p)?null:"p";if(!f||d||g||(g="s"),c&&c!=g){r<0&&(r=1,l(),t.sticky="after");break}if(g&&(c=g),r>0&&!l(!d))break}var v=ki(e,t,s,a,!0);return I(s,v)&&(v.hitSide=!0),v}function rl(e,t,r,n){var i,o=e.doc,l=t.left;if("page"==n){var s=Math.min(e.display.wrapper.clientHeight,window.innerHeight||document.documentElement.clientHeight),a=Math.max(s-.5*mr(e.display),3);i=(r>0?t.bottom:t.top)+r*a}else"line"==n&&(i=r>0?t.bottom+3:t.top-3);for(var u;(u=cr(e,l,i)).outside;){if(r<0?i<=0:i>=o.height){u.hitSide=!0;break}i+=5*r}return u}function nl(e,t){var r=jt(e,t.line);if(!r||r.hidden)return null;var n=M(e.doc,t.line),i=Ut(r,n,t.line),o=Se(n,e.doc.direction),l="left";o&&(l=Ce(o,t.ch)%2?"right":"left");var s=_t(i.map,t.ch,l);return s.offset="right"==s.collapse?s.end:s.start,s}function il(e){for(var t=e;t;t=t.parentNode)if(/CodeMirror-gutter-wrapper/.test(t.className))return!0;return!1}function ol(e,t){return t&&(e.bad=!0),e}function ll(e,t,r,n,i){function o(e){return function(t){return t.id==e}}function l(){c&&(u+=f,c=!1)}function s(e){e&&(l(),u+=e)}function a(t){if(1==t.nodeType){var r=t.getAttribute("cm-text");if(null!=r)return void s(r||t.textContent.replace(/\u200b/g,""));var u,h=t.getAttribute("cm-marker");if(h){var d=e.findMarks(E(n,0),E(i+1,0),o(+h));return void(d.length&&(u=d[0].find(0))&&s(N(e.doc,u.from,u.to).join(f)))}if("false"==t.getAttribute("contenteditable"))return;var p=/^(pre|div|p)$/i.test(t.nodeName);p&&l();for(var g=0;g<t.childNodes.length;g++)a(t.childNodes[g]);p&&(c=!0)}else 3==t.nodeType&&s(t.nodeValue)}for(var u="",c=!1,f=e.doc.lineSeparator();a(t),t!=r;)t=t.nextSibling;return u}function sl(e,t,r){var n;if(t==e.display.lineDiv){if(!(n=e.display.lineDiv.childNodes[r]))return ol(e.clipPos(E(e.display.viewTo-1)),!0);t=null,r=0}else for(n=t;;n=n.parentNode){if(!n||n==e.display.lineDiv)return null;if(n.parentNode&&n.parentNode==e.display.lineDiv)break}for(var i=0;i<e.display.view.length;i++){var o=e.display.view[i];if(o.node==n)return al(o,t,r)}}function al(e,t,r){function n(t,r,n){for(var i=-1;i<(f?f.length:0);i++)for(var o=i<0?c.map:f[i],l=0;l<o.length;l+=3){var s=o[l+2];if(s==t||s==r){var a=W(i<0?e.line:e.rest[i]),u=o[l]+n;return(n<0||s!=t)&&(u=o[l+(n?1:0)]),E(a,u)}}}var i=e.text.firstChild,l=!1;if(!t||!o(i,t))return ol(E(W(e.line),0),!0);if(t==i&&(l=!0,t=i.childNodes[r],r=0,!t)){var s=e.rest?g(e.rest):e.line;return ol(E(W(s),s.text.length),l)}var a=3==t.nodeType?t:null,u=t;for(a||1!=t.childNodes.length||3!=t.firstChild.nodeType||(a=t.firstChild,r&&(r=a.nodeValue.length));u.parentNode!=i;)u=u.parentNode;var c=e.measure,f=c.maps,h=n(a,u,r);if(h)return ol(h,l);for(var d=u.nextSibling,p=a?a.nodeValue.length-r:0;d;d=d.nextSibling){if(h=n(d,d.firstChild,0))return ol(E(h.line,h.ch-p),l);p+=d.textContent.length}for(var v=u.previousSibling,m=r;v;v=v.previousSibling){if(h=n(v,v.firstChild,-1))return ol(E(h.line,h.ch+m),l);m+=v.textContent.length}}var ul=navigator.userAgent,cl=navigator.platform,fl=/gecko\/\d/i.test(ul),hl=/MSIE \d/.test(ul),dl=/Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(ul),pl=/Edge\/(\d+)/.exec(ul),gl=hl||dl||pl,vl=gl&&(hl?document.documentMode||6:+(pl||dl)[1]),ml=!pl&&/WebKit\//.test(ul),yl=ml&&/Qt\/\d+\.\d+/.test(ul),bl=!pl&&/Chrome\//.test(ul),wl=/Opera\//.test(ul),xl=/Apple Computer/.test(navigator.vendor),Cl=/Mac OS X 1\d\D([8-9]|\d\d)\D/.test(ul),Sl=/PhantomJS/.test(ul),Ll=!pl&&/AppleWebKit/.test(ul)&&/Mobile\/\w+/.test(ul),kl=/Android/.test(ul),Tl=Ll||kl||/webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(ul),Ml=Ll||/Mac/.test(cl),Nl=/\bCrOS\b/.test(ul),Ol=/win/i.test(cl),Al=wl&&ul.match(/Version\/(\d*\.\d*)/);Al&&(Al=Number(Al[1])),Al&&Al>=15&&(wl=!1,ml=!0);var Wl,Dl=Ml&&(yl||wl&&(null==Al||Al<12.11)),Hl=fl||gl&&vl>=9,Fl=function(t,r){var n=t.className,i=e(r).exec(n);if(i){var o=n.slice(i.index+i[0].length);t.className=n.slice(0,i.index)+(o?i[1]+o:"")}};Wl=document.createRange?function(e,t,r,n){var i=document.createRange();return i.setEnd(n||e,r),i.setStart(e,t),i}:function(e,t,r){var n=document.body.createTextRange();try{n.moveToElementText(e.parentNode)}catch(e){return n}return n.collapse(!0),n.moveEnd("character",r),n.moveStart("character",t),n};var El=function(e){e.select()};Ll?El=function(e){e.selectionStart=0,e.selectionEnd=e.value.length}:gl&&(El=function(e){try{e.select()}catch(e){}});var Pl=function(){this.id=null};Pl.prototype.set=function(e,t){clearTimeout(this.id),this.id=setTimeout(t,e)};var Il,zl,Rl=30,Bl={toString:function(){return"CodeMirror.Pass"}},Gl={scroll:!1},Ul={origin:"*mouse"},Vl={origin:"+move"},Kl=[""],jl=/[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/,Xl=/[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/,Yl=!1,_l=!1,$l=null,ql=function(){function e(e){return e<=247?r.charAt(e):1424<=e&&e<=1524?"R":1536<=e&&e<=1785?n.charAt(e-1536):1774<=e&&e<=2220?"r":8192<=e&&e<=8203?"w":8204==e?"b":"L"}function t(e,t,r){this.level=e,this.from=t,this.to=r}var r="bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN",n="nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111",i=/[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/,o=/[stwN]/,l=/[LRr]/,s=/[Lb1n]/,a=/[1n]/;return function(r,n){var u="ltr"==n?"L":"R";if(0==r.length||"ltr"==n&&!i.test(r))return!1;for(var c=r.length,f=[],h=0;h<c;++h)f.push(e(r.charCodeAt(h)));for(var d=0,p=u;d<c;++d){var v=f[d];"m"==v?f[d]=p:p=v}for(var m=0,y=u;m<c;++m){var b=f[m];"1"==b&&"r"==y?f[m]="n":l.test(b)&&(y=b,"r"==b&&(f[m]="R"))}for(var w=1,x=f[0];w<c-1;++w){var C=f[w];"+"==C&&"1"==x&&"1"==f[w+1]?f[w]="1":","!=C||x!=f[w+1]||"1"!=x&&"n"!=x||(f[w]=x),x=C}for(var S=0;S<c;++S){var L=f[S];if(","==L)f[S]="N";else if("%"==L){var k=void 0;for(k=S+1;k<c&&"%"==f[k];++k);for(var T=S&&"!"==f[S-1]||k<c&&"1"==f[k]?"1":"N",M=S;M<k;++M)f[M]=T;S=k-1}}for(var N=0,O=u;N<c;++N){var A=f[N];"L"==O&&"1"==A?f[N]="L":l.test(A)&&(O=A)}for(var W=0;W<c;++W)if(o.test(f[W])){var D=void 0;for(D=W+1;D<c&&o.test(f[D]);++D);for(var H="L"==(W?f[W-1]:u),F=H==("L"==(D<c?f[D]:u))?H?"L":"R":u,E=W;E<D;++E)f[E]=F;W=D-1}for(var P,I=[],z=0;z<c;)if(s.test(f[z])){var R=z;for(++z;z<c&&s.test(f[z]);++z);I.push(new t(0,R,z))}else{var B=z,G=I.length;for(++z;z<c&&"L"!=f[z];++z);for(var U=B;U<z;)if(a.test(f[U])){B<U&&I.splice(G,0,new t(1,B,U));var V=U;for(++U;U<z&&a.test(f[U]);++U);I.splice(G,0,new t(2,V,U)),B=U}else++U;B<z&&I.splice(G,0,new t(1,B,z))}return 1==I[0].level&&(P=r.match(/^\s+/))&&(I[0].from=P[0].length,I.unshift(new t(0,0,P[0].length))),1==g(I).level&&(P=r.match(/\s+$/))&&(g(I).to-=P[0].length,I.push(new t(0,c-P[0].length,c))),"rtl"==n?I.reverse():I}}(),Zl=[],Ql=function(e,t,r){if(e.addEventListener)e.addEventListener(t,r,!1);else if(e.attachEvent)e.attachEvent("on"+t,r);else{var n=e._handlers||(e._handlers={});n[t]=(n[t]||Zl).concat(r)}},Jl=function(){if(gl&&vl<9)return!1;var e=n("div");return"draggable"in e||"dragDrop"in e}(),es=3!="\n\nb".split(/\n/).length?function(e){for(var t=0,r=[],n=e.length;t<=n;){var i=e.indexOf("\n",t);-1==i&&(i=e.length);var o=e.slice(t,"\r"==e.charAt(i-1)?i-1:i),l=o.indexOf("\r");-1!=l?(r.push(o.slice(0,l)),t+=l+1):(r.push(o),t=i+1)}return r}:function(e){return e.split(/\r\n?|\n/)},ts=window.getSelection?function(e){try{return e.selectionStart!=e.selectionEnd}catch(e){return!1}}:function(e){var t;try{t=e.ownerDocument.selection.createRange()}catch(e){}return!(!t||t.parentElement()!=e)&&0!=t.compareEndPoints("StartToEnd",t)},rs=function(){var e=n("div");return"oncopy"in e||(e.setAttribute("oncopy","return;"),"function"==typeof e.oncopy)}(),ns=null,is={},os={},ls={},ss=function(e,t,r){this.pos=this.start=0,this.string=e,this.tabSize=t||8,this.lastColumnPos=this.lastColumnValue=0,this.lineStart=0,this.lineOracle=r};ss.prototype.eol=function(){return this.pos>=this.string.length},ss.prototype.sol=function(){return this.pos==this.lineStart},ss.prototype.peek=function(){return this.string.charAt(this.pos)||void 0},ss.prototype.next=function(){if(this.pos<this.string.length)return this.string.charAt(this.pos++)},ss.prototype.eat=function(e){var t=this.string.charAt(this.pos);if("string"==typeof e?t==e:t&&(e.test?e.test(t):e(t)))return++this.pos,t},ss.prototype.eatWhile=function(e){for(var t=this.pos;this.eat(e););return this.pos>t},ss.prototype.eatSpace=function(){for(var e=this,t=this.pos;/[\s\u00a0]/.test(this.string.charAt(this.pos));)++e.pos;return this.pos>t},ss.prototype.skipToEnd=function(){this.pos=this.string.length},ss.prototype.skipTo=function(e){var t=this.string.indexOf(e,this.pos);if(t>-1)return this.pos=t,!0},ss.prototype.backUp=function(e){this.pos-=e},ss.prototype.column=function(){return this.lastColumnPos<this.start&&(this.lastColumnValue=f(this.string,this.start,this.tabSize,this.lastColumnPos,this.lastColumnValue),this.lastColumnPos=this.start),this.lastColumnValue-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.indentation=function(){return f(this.string,null,this.tabSize)-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.match=function(e,t,r){if("string"!=typeof e){var n=this.string.slice(this.pos).match(e);return n&&n.index>0?null:(n&&!1!==t&&(this.pos+=n[0].length),n)}var i=function(e){return r?e.toLowerCase():e};if(i(this.string.substr(this.pos,e.length))==i(e))return!1!==t&&(this.pos+=e.length),!0},ss.prototype.current=function(){return this.string.slice(this.start,this.pos)},ss.prototype.hideFirstChars=function(e,t){this.lineStart+=e;try{return t()}finally{this.lineStart-=e}},ss.prototype.lookAhead=function(e){var t=this.lineOracle;return t&&t.lookAhead(e)};var as=function(e,t){this.state=e,this.lookAhead=t},us=function(e,t,r,n){this.state=t,this.doc=e,this.line=r,this.maxLookAhead=n||0};us.prototype.lookAhead=function(e){var t=this.doc.getLine(this.line+e);return null!=t&&e>this.maxLookAhead&&(this.maxLookAhead=e),t},us.prototype.nextLine=function(){this.line++,this.maxLookAhead>0&&this.maxLookAhead--},us.fromSaved=function(e,t,r){return t instanceof as?new us(e,Ke(e.mode,t.state),r,t.lookAhead):new us(e,Ke(e.mode,t),r)},us.prototype.save=function(e){var t=!1!==e?Ke(this.doc.mode,this.state):this.state;return this.maxLookAhead>0?new as(t,this.maxLookAhead):t};var cs=function(e,t,r){this.start=e.start,this.end=e.pos,this.string=e.current(),this.type=t||null,this.state=r},fs=function(e,t,r){this.text=e,ne(this,t),this.height=r?r(this):1};fs.prototype.lineNo=function(){return W(this)},Ae(fs);var hs,ds={},ps={},gs=null,vs=null,ms={left:0,right:0,top:0,bottom:0},ys=function(e,t,r){this.cm=r;var i=this.vert=n("div",[n("div",null,null,"min-width: 1px")],"CodeMirror-vscrollbar"),o=this.horiz=n("div",[n("div",null,null,"height: 100%; min-height: 1px")],"CodeMirror-hscrollbar");e(i),e(o),Ql(i,"scroll",function(){i.clientHeight&&t(i.scrollTop,"vertical")}),Ql(o,"scroll",function(){o.clientWidth&&t(o.scrollLeft,"horizontal")}),this.checkedZeroWidth=!1,gl&&vl<8&&(this.horiz.style.minHeight=this.vert.style.minWidth="18px")};ys.prototype.update=function(e){var t=e.scrollWidth>e.clientWidth+1,r=e.scrollHeight>e.clientHeight+1,n=e.nativeBarWidth;if(r){this.vert.style.display="block",this.vert.style.bottom=t?n+"px":"0";var i=e.viewHeight-(t?n:0);this.vert.firstChild.style.height=Math.max(0,e.scrollHeight-e.clientHeight+i)+"px"}else this.vert.style.display="",this.vert.firstChild.style.height="0";if(t){this.horiz.style.display="block",this.horiz.style.right=r?n+"px":"0",this.horiz.style.left=e.barLeft+"px";var o=e.viewWidth-e.barLeft-(r?n:0);this.horiz.firstChild.style.width=Math.max(0,e.scrollWidth-e.clientWidth+o)+"px"}else this.horiz.style.display="",this.horiz.firstChild.style.width="0";return!this.checkedZeroWidth&&e.clientHeight>0&&(0==n&&this.zeroWidthHack(),this.checkedZeroWidth=!0),{right:r?n:0,bottom:t?n:0}},ys.prototype.setScrollLeft=function(e){this.horiz.scrollLeft!=e&&(this.horiz.scrollLeft=e),this.disableHoriz&&this.enableZeroWidthBar(this.horiz,this.disableHoriz,"horiz")},ys.prototype.setScrollTop=function(e){this.vert.scrollTop!=e&&(this.vert.scrollTop=e),this.disableVert&&this.enableZeroWidthBar(this.vert,this.disableVert,"vert")},ys.prototype.zeroWidthHack=function(){var e=Ml&&!Cl?"12px":"18px";this.horiz.style.height=this.vert.style.width=e,this.horiz.style.pointerEvents=this.vert.style.pointerEvents="none",this.disableHoriz=new Pl,this.disableVert=new Pl},ys.prototype.enableZeroWidthBar=function(e,t,r){function n(){var i=e.getBoundingClientRect();("vert"==r?document.elementFromPoint(i.right-1,(i.top+i.bottom)/2):document.elementFromPoint((i.right+i.left)/2,i.bottom-1))!=e?e.style.pointerEvents="none":t.set(1e3,n)}e.style.pointerEvents="auto",t.set(1e3,n)},ys.prototype.clear=function(){var e=this.horiz.parentNode;e.removeChild(this.horiz),e.removeChild(this.vert)};var bs=function(){};bs.prototype.update=function(){return{bottom:0,right:0}},bs.prototype.setScrollLeft=function(){},bs.prototype.setScrollTop=function(){},bs.prototype.clear=function(){};var ws={native:ys,null:bs},xs=0,Cs=function(e,t,r){var n=e.display;this.viewport=t,this.visible=Ir(n,e.doc,t),this.editorIsHidden=!n.wrapper.offsetWidth,this.wrapperHeight=n.wrapper.clientHeight,this.wrapperWidth=n.wrapper.clientWidth,this.oldDisplayWidth=Rt(e),this.force=r,this.dims=br(e),this.events=[]};Cs.prototype.signal=function(e,t){Oe(e,t)&&this.events.push(arguments)},Cs.prototype.finish=function(){for(var e=this,t=0;t<this.events.length;t++)Te.apply(null,e.events[t])};var Ss=0,Ls=null;gl?Ls=-.53:fl?Ls=15:bl?Ls=-.7:xl&&(Ls=-1/3);var ks=function(e,t){this.ranges=e,this.primIndex=t};ks.prototype.primary=function(){return this.ranges[this.primIndex]},ks.prototype.equals=function(e){var t=this;if(e==this)return!0;if(e.primIndex!=this.primIndex||e.ranges.length!=this.ranges.length)return!1;for(var r=0;r<this.ranges.length;r++){var n=t.ranges[r],i=e.ranges[r];if(!I(n.anchor,i.anchor)||!I(n.head,i.head))return!1}return!0},ks.prototype.deepCopy=function(){for(var e=this,t=[],r=0;r<this.ranges.length;r++)t[r]=new Ts(z(e.ranges[r].anchor),z(e.ranges[r].head));return new ks(t,this.primIndex)},ks.prototype.somethingSelected=function(){for(var e=this,t=0;t<this.ranges.length;t++)if(!e.ranges[t].empty())return!0;return!1},ks.prototype.contains=function(e,t){var r=this;t||(t=e);for(var n=0;n<this.ranges.length;n++){var i=r.ranges[n];if(P(t,i.from())>=0&&P(e,i.to())<=0)return n}return-1};var Ts=function(e,t){this.anchor=e,this.head=t};Ts.prototype.from=function(){return B(this.anchor,this.head)},Ts.prototype.to=function(){return R(this.anchor,this.head)},Ts.prototype.empty=function(){return this.head.line==this.anchor.line&&this.head.ch==this.anchor.ch},Bi.prototype={chunkSize:function(){return this.lines.length},removeInner:function(e,t){for(var r=this,n=e,i=e+t;n<i;++n){var o=r.lines[n];r.height-=o.height,ot(o),bt(o,"delete")}this.lines.splice(e,t)},collapse:function(e){e.push.apply(e,this.lines)},insertInner:function(e,t,r){var n=this;this.height+=r,this.lines=this.lines.slice(0,e).concat(t).concat(this.lines.slice(e));for(var i=0;i<t.length;++i)t[i].parent=n},iterN:function(e,t,r){for(var n=this,i=e+t;e<i;++e)if(r(n.lines[e]))return!0}},Gi.prototype={chunkSize:function(){return this.size},removeInner:function(e,t){var r=this;this.size-=t;for(var n=0;n<this.children.length;++n){var i=r.children[n],o=i.chunkSize();if(e<o){var l=Math.min(t,o-e),s=i.height;if(i.removeInner(e,l),r.height-=s-i.height,o==l&&(r.children.splice(n--,1),i.parent=null),0==(t-=l))break;e=0}else e-=o}if(this.size-t<25&&(this.children.length>1||!(this.children[0]instanceof Bi))){var a=[];this.collapse(a),this.children=[new Bi(a)],this.children[0].parent=this}},collapse:function(e){for(var t=this,r=0;r<this.children.length;++r)t.children[r].collapse(e)},insertInner:function(e,t,r){var n=this;this.size+=t.length,this.height+=r;for(var i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<=l){if(o.insertInner(e,t,r),o.lines&&o.lines.length>50){for(var s=o.lines.length%25+25,a=s;a<o.lines.length;){var u=new Bi(o.lines.slice(a,a+=25));o.height-=u.height,n.children.splice(++i,0,u),u.parent=n}o.lines=o.lines.slice(0,s),n.maybeSpill()}break}e-=l}},maybeSpill:function(){if(!(this.children.length<=10)){var e=this;do{var t=new Gi(e.children.splice(e.children.length-5,5));if(e.parent){e.size-=t.size,e.height-=t.height;var r=h(e.parent.children,e);e.parent.children.splice(r+1,0,t)}else{var n=new Gi(e.children);n.parent=e,e.children=[n,t],e=n}t.parent=e.parent}while(e.children.length>10);e.parent.maybeSpill()}},iterN:function(e,t,r){for(var n=this,i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<l){var s=Math.min(t,l-e);if(o.iterN(e,s,r))return!0;if(0==(t-=s))break;e=0}else e-=l}}};var Ms=function(e,t,r){var n=this;if(r)for(var i in r)r.hasOwnProperty(i)&&(n[i]=r[i]);this.doc=e,this.node=t};Ms.prototype.clear=function(){var e=this,t=this.doc.cm,r=this.line.widgets,n=this.line,i=W(n);if(null!=i&&r){for(var o=0;o<r.length;++o)r[o]==e&&r.splice(o--,1);r.length||(n.widgets=null);var l=Ht(this);A(n,Math.max(0,n.height-l)),t&&(hn(t,function(){Ui(t,n,-l),mn(t,i,"widget")}),bt(t,"lineWidgetCleared",t,this,i))}},Ms.prototype.changed=function(){var e=this,t=this.height,r=this.doc.cm,n=this.line;this.height=null;var i=Ht(this)-t;i&&(A(n,n.height+i),r&&hn(r,function(){r.curOp.forceUpdate=!0,Ui(r,n,i),bt(r,"lineWidgetChanged",r,e,W(n))}))},Ae(Ms);var Ns=0,Os=function(e,t){this.lines=[],this.type=t,this.doc=e,this.id=++Ns};Os.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){var t=this.doc.cm,r=t&&!t.curOp;if(r&&nn(t),Oe(this,"clear")){var n=this.find();n&&bt(this,"clear",n.from,n.to)}for(var i=null,o=null,l=0;l<this.lines.length;++l){var s=e.lines[l],a=_(s.markedSpans,e);t&&!e.collapsed?mn(t,W(s),"text"):t&&(null!=a.to&&(o=W(s)),null!=a.from&&(i=W(s))),s.markedSpans=$(s.markedSpans,a),null==a.from&&e.collapsed&&!ve(e.doc,s)&&t&&A(s,mr(t.display))}if(t&&this.collapsed&&!t.options.lineWrapping)for(var u=0;u<this.lines.length;++u){var c=fe(e.lines[u]),f=be(c);f>t.display.maxLineLength&&(t.display.maxLine=c,t.display.maxLineLength=f,t.display.maxLineChanged=!0)}null!=i&&t&&this.collapsed&&vn(t,i,o+1),this.lines.length=0,this.explicitlyCleared=!0,this.atomic&&this.doc.cantEdit&&(this.doc.cantEdit=!1,t&&Ci(t.doc)),t&&bt(t,"markerCleared",t,this,i,o),r&&on(t),this.parent&&this.parent.clear()}},Os.prototype.find=function(e,t){var r=this;null==e&&"bookmark"==this.type&&(e=1);for(var n,i,o=0;o<this.lines.length;++o){var l=r.lines[o],s=_(l.markedSpans,r);if(null!=s.from&&(n=E(t?l:W(l),s.from),-1==e))return n;if(null!=s.to&&(i=E(t?l:W(l),s.to),1==e))return i}return n&&{from:n,to:i}},Os.prototype.changed=function(){var e=this,t=this.find(-1,!0),r=this,n=this.doc.cm;t&&n&&hn(n,function(){var i=t.line,o=W(t.line),l=jt(n,o);if(l&&(Qt(l),n.curOp.selectionChanged=n.curOp.forceUpdate=!0),n.curOp.updateMaxLine=!0,!ve(r.doc,i)&&null!=r.height){var s=r.height;r.height=null;var a=Ht(r)-s;a&&A(i,i.height+a)}bt(n,"markerChanged",n,e)})},Os.prototype.attachLine=function(e){if(!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;t.maybeHiddenMarkers&&-1!=h(t.maybeHiddenMarkers,this)||(t.maybeUnhiddenMarkers||(t.maybeUnhiddenMarkers=[])).push(this)}this.lines.push(e)},Os.prototype.detachLine=function(e){if(this.lines.splice(h(this.lines,e),1),!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;(t.maybeHiddenMarkers||(t.maybeHiddenMarkers=[])).push(this)}},Ae(Os);var As=function(e,t){var r=this;this.markers=e,this.primary=t;for(var n=0;n<e.length;++n)e[n].parent=r};As.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){this.explicitlyCleared=!0;for(var t=0;t<this.markers.length;++t)e.markers[t].clear();bt(this,"clear")}},As.prototype.find=function(e,t){return this.primary.find(e,t)},Ae(As);var Ws=0,Ds=function(e,t,r,n,i){if(!(this instanceof Ds))return new Ds(e,t,r,n,i);null==r&&(r=0),Gi.call(this,[new Bi([new fs("",null)])]),this.first=r,this.scrollTop=this.scrollLeft=0,this.cantEdit=!1,this.cleanGeneration=1,this.modeFrontier=this.highlightFrontier=r;var o=E(r,0);this.sel=Rn(o),this.history=new Jn(null),this.id=++Ws,this.modeOption=t,this.lineSep=n,this.direction="rtl"==i?"rtl":"ltr",this.extend=!1,"string"==typeof e&&(e=this.splitLines(e)),_n(this,{from:o,to:o,text:e}),bi(this,Rn(o),Gl)};Ds.prototype=b(Gi.prototype,{constructor:Ds,iter:function(e,t,r){r?this.iterN(e-this.first,t-e,r):this.iterN(this.first,this.first+this.size,e)},insert:function(e,t){for(var r=0,n=0;n<t.length;++n)r+=t[n].height;this.insertInner(e-this.first,t,r)},remove:function(e,t){this.removeInner(e-this.first,t)},getValue:function(e){var t=O(this,this.first,this.first+this.size);return!1===e?t:t.join(e||this.lineSeparator())},setValue:gn(function(e){var t=E(this.first,0),r=this.first+this.size-1;Oi(this,{from:t,to:E(r,M(this,r).text.length),text:this.splitLines(e),origin:"setValue",full:!0},!0),this.cm&&Xr(this.cm,0,0),bi(this,Rn(t),Gl)}),replaceRange:function(e,t,r,n){Ei(this,e,t=U(this,t),r=r?U(this,r):t,n)},getRange:function(e,t,r){var n=N(this,U(this,e),U(this,t));return!1===r?n:n.join(r||this.lineSeparator())},getLine:function(e){var t=this.getLineHandle(e);return t&&t.text},getLineHandle:function(e){if(H(this,e))return M(this,e)},getLineNumber:function(e){return W(e)},getLineHandleVisualStart:function(e){return"number"==typeof e&&(e=M(this,e)),fe(e)},lineCount:function(){return this.size},firstLine:function(){return this.first},lastLine:function(){return this.first+this.size-1},clipPos:function(e){return U(this,e)},getCursor:function(e){var t=this.sel.primary();return null==e||"head"==e?t.head:"anchor"==e?t.anchor:"end"==e||"to"==e||!1===e?t.to():t.from()},listSelections:function(){return this.sel.ranges},somethingSelected:function(){return this.sel.somethingSelected()},setCursor:gn(function(e,t,r){vi(this,U(this,"number"==typeof e?E(e,t||0):e),null,r)}),setSelection:gn(function(e,t,r){vi(this,U(this,e),U(this,t||e),r)}),extendSelection:gn(function(e,t,r){di(this,U(this,e),t&&U(this,t),r)}),extendSelections:gn(function(e,t){pi(this,K(this,e),t)}),extendSelectionsBy:gn(function(e,t){pi(this,K(this,v(this.sel.ranges,e)),t)}),setSelections:gn(function(e,t,r){var n=this;if(e.length){for(var i=[],o=0;o<e.length;o++)i[o]=new Ts(U(n,e[o].anchor),U(n,e[o].head));null==t&&(t=Math.min(e.length-1,this.sel.primIndex)),bi(this,zn(i,t),r)}}),addSelection:gn(function(e,t,r){var n=this.sel.ranges.slice(0);n.push(new Ts(U(this,e),U(this,t||e))),bi(this,zn(n,n.length-1),r)}),getSelection:function(e){for(var t,r=this,n=this.sel.ranges,i=0;i<n.length;i++){var o=N(r,n[i].from(),n[i].to());t=t?t.concat(o):o}return!1===e?t:t.join(e||this.lineSeparator())},getSelections:function(e){for(var t=this,r=[],n=this.sel.ranges,i=0;i<n.length;i++){var o=N(t,n[i].from(),n[i].to());!1!==e&&(o=o.join(e||t.lineSeparator())),r[i]=o}return r},replaceSelection:function(e,t,r){for(var n=[],i=0;i<this.sel.ranges.length;i++)n[i]=e;this.replaceSelections(n,t,r||"+input")},replaceSelections:gn(function(e,t,r){for(var n=this,i=[],o=this.sel,l=0;l<o.ranges.length;l++){var s=o.ranges[l];i[l]={from:s.from(),to:s.to(),text:n.splitLines(e[l]),origin:r}}for(var a=t&&"end"!=t&&Kn(this,i,t),u=i.length-1;u>=0;u--)Oi(n,i[u]);a?yi(this,a):this.cm&&jr(this.cm)}),undo:gn(function(){Wi(this,"undo")}),redo:gn(function(){Wi(this,"redo")}),undoSelection:gn(function(){Wi(this,"undo",!0)}),redoSelection:gn(function(){Wi(this,"redo",!0)}),setExtending:function(e){this.extend=e},getExtending:function(){return this.extend},historySize:function(){for(var e=this.history,t=0,r=0,n=0;n<e.done.length;n++)e.done[n].ranges||++t;for(var i=0;i<e.undone.length;i++)e.undone[i].ranges||++r;return{undo:t,redo:r}},clearHistory:function(){this.history=new Jn(this.history.maxGeneration)},markClean:function(){this.cleanGeneration=this.changeGeneration(!0)},changeGeneration:function(e){return e&&(this.history.lastOp=this.history.lastSelOp=this.history.lastOrigin=null),this.history.generation},isClean:function(e){return this.history.generation==(e||this.cleanGeneration)},getHistory:function(){return{done:fi(this.history.done),undone:fi(this.history.undone)}},setHistory:function(e){var t=this.history=new Jn(this.history.maxGeneration);t.done=fi(e.done.slice(0),null,!0),t.undone=fi(e.undone.slice(0),null,!0)},setGutterMarker:gn(function(e,t,r){return Ri(this,e,"gutter",function(e){var n=e.gutterMarkers||(e.gutterMarkers={});return n[t]=r,!r&&C(n)&&(e.gutterMarkers=null),!0})}),clearGutter:gn(function(e){var t=this;this.iter(function(r){r.gutterMarkers&&r.gutterMarkers[e]&&Ri(t,r,"gutter",function(){return r.gutterMarkers[e]=null,C(r.gutterMarkers)&&(r.gutterMarkers=null),!0})})}),lineInfo:function(e){var t;if("number"==typeof e){if(!H(this,e))return null;if(t=e,!(e=M(this,e)))return null}else if(null==(t=W(e)))return null;return{line:t,handle:e,text:e.text,gutterMarkers:e.gutterMarkers,textClass:e.textClass,bgClass:e.bgClass,wrapClass:e.wrapClass,widgets:e.widgets}},addLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass";if(t[i]){if(e(n).test(t[i]))return!1;t[i]+=" "+n}else t[i]=n;return!0})}),removeLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass",o=t[i];if(!o)return!1;if(null==n)t[i]=null;else{var l=o.match(e(n));if(!l)return!1;var s=l.index+l[0].length;t[i]=o.slice(0,l.index)+(l.index&&s!=o.length?" ":"")+o.slice(s)||null}return!0})}),addLineWidget:gn(function(e,t,r){return Vi(this,e,t,r)}),removeLineWidget:function(e){e.clear()},markText:function(e,t,r){return Ki(this,U(this,e),U(this,t),r,r&&r.type||"range")},setBookmark:function(e,t){var r={replacedWith:t&&(null==t.nodeType?t.widget:t),insertLeft:t&&t.insertLeft,clearWhenEmpty:!1,shared:t&&t.shared,handleMouseEvents:t&&t.handleMouseEvents};return e=U(this,e),Ki(this,e,e,r,"bookmark")},findMarksAt:function(e){var t=[],r=M(this,(e=U(this,e)).line).markedSpans;if(r)for(var n=0;n<r.length;++n){var i=r[n];(null==i.from||i.from<=e.ch)&&(null==i.to||i.to>=e.ch)&&t.push(i.marker.parent||i.marker)}return t},findMarks:function(e,t,r){e=U(this,e),t=U(this,t);var n=[],i=e.line;return this.iter(e.line,t.line+1,function(o){var l=o.markedSpans;if(l)for(var s=0;s<l.length;s++){var a=l[s];null!=a.to&&i==e.line&&e.ch>=a.to||null==a.from&&i!=e.line||null!=a.from&&i==t.line&&a.from>=t.ch||r&&!r(a.marker)||n.push(a.marker.parent||a.marker)}++i}),n},getAllMarks:function(){var e=[];return this.iter(function(t){var r=t.markedSpans;if(r)for(var n=0;n<r.length;++n)null!=r[n].from&&e.push(r[n].marker)}),e},posFromIndex:function(e){var t,r=this.first,n=this.lineSeparator().length;return this.iter(function(i){var o=i.text.length+n;if(o>e)return t=e,!0;e-=o,++r}),U(this,E(r,t))},indexFromPos:function(e){var t=(e=U(this,e)).ch;if(e.line<this.first||e.ch<0)return 0;var r=this.lineSeparator().length;return this.iter(this.first,e.line,function(e){t+=e.text.length+r}),t},copy:function(e){var t=new Ds(O(this,this.first,this.first+this.size),this.modeOption,this.first,this.lineSep,this.direction);return t.scrollTop=this.scrollTop,t.scrollLeft=this.scrollLeft,t.sel=this.sel,t.extend=!1,e&&(t.history.undoDepth=this.history.undoDepth,t.setHistory(this.getHistory())),t},linkedDoc:function(e){e||(e={});var t=this.first,r=this.first+this.size;null!=e.from&&e.from>t&&(t=e.from),null!=e.to&&e.to<r&&(r=e.to);var n=new Ds(O(this,t,r),e.mode||this.modeOption,t,this.lineSep,this.direction);return e.sharedHist&&(n.history=this.history),(this.linked||(this.linked=[])).push({doc:n,sharedHist:e.sharedHist}),n.linked=[{doc:this,isParent:!0,sharedHist:e.sharedHist}],Yi(n,Xi(this)),n},unlinkDoc:function(e){var t=this;if(e instanceof jo&&(e=e.doc),this.linked)for(var r=0;r<this.linked.length;++r)if(t.linked[r].doc==e){t.linked.splice(r,1),e.unlinkDoc(t),_i(Xi(t));break}if(e.history==this.history){var n=[e.id];$n(e,function(e){return n.push(e.id)},!0),e.history=new Jn(null),e.history.done=fi(this.history.done,n),e.history.undone=fi(this.history.undone,n)}},iterLinkedDocs:function(e){$n(this,e)},getMode:function(){return this.mode},getEditor:function(){return this.cm},splitLines:function(e){return this.lineSep?e.split(this.lineSep):es(e)},lineSeparator:function(){return this.lineSep||"\n"},setDirection:gn(function(e){"rtl"!=e&&(e="ltr"),e!=this.direction&&(this.direction=e,this.iter(function(e){return e.order=null}),this.cm&&Qn(this.cm))})}),Ds.prototype.eachLine=Ds.prototype.iter;for(var Hs=0,Fs=!1,Es={3:"Enter",8:"Backspace",9:"Tab",13:"Enter",16:"Shift",17:"Ctrl",18:"Alt",19:"Pause",20:"CapsLock",27:"Esc",32:"Space",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"Left",38:"Up",39:"Right",40:"Down",44:"PrintScrn",45:"Insert",46:"Delete",59:";",61:"=",91:"Mod",92:"Mod",93:"Mod",106:"*",107:"=",109:"-",110:".",111:"/",127:"Delete",173:"-",186:";",187:"=",188:",",189:"-",190:".",191:"/",192:"`",219:"[",220:"\\",221:"]",222:"'",63232:"Up",63233:"Down",63234:"Left",63235:"Right",63272:"Delete",63273:"Home",63275:"End",63276:"PageUp",63277:"PageDown",63302:"Insert"},Ps=0;Ps<10;Ps++)Es[Ps+48]=Es[Ps+96]=String(Ps);for(var Is=65;Is<=90;Is++)Es[Is]=String.fromCharCode(Is);for(var zs=1;zs<=12;zs++)Es[zs+111]=Es[zs+63235]="F"+zs;var Rs={};Rs.basic={Left:"goCharLeft",Right:"goCharRight",Up:"goLineUp",Down:"goLineDown",End:"goLineEnd",Home:"goLineStartSmart",PageUp:"goPageUp",PageDown:"goPageDown",Delete:"delCharAfter",Backspace:"delCharBefore","Shift-Backspace":"delCharBefore",Tab:"defaultTab","Shift-Tab":"indentAuto",Enter:"newlineAndIndent",Insert:"toggleOverwrite",Esc:"singleSelection"},Rs.pcDefault={"Ctrl-A":"selectAll","Ctrl-D":"deleteLine","Ctrl-Z":"undo","Shift-Ctrl-Z":"redo","Ctrl-Y":"redo","Ctrl-Home":"goDocStart","Ctrl-End":"goDocEnd","Ctrl-Up":"goLineUp","Ctrl-Down":"goLineDown","Ctrl-Left":"goGroupLeft","Ctrl-Right":"goGroupRight","Alt-Left":"goLineStart","Alt-Right":"goLineEnd","Ctrl-Backspace":"delGroupBefore","Ctrl-Delete":"delGroupAfter","Ctrl-S":"save","Ctrl-F":"find","Ctrl-G":"findNext","Shift-Ctrl-G":"findPrev","Shift-Ctrl-F":"replace","Shift-Ctrl-R":"replaceAll","Ctrl-[":"indentLess","Ctrl-]":"indentMore","Ctrl-U":"undoSelection","Shift-Ctrl-U":"redoSelection","Alt-U":"redoSelection",fallthrough:"basic"},Rs.emacsy={"Ctrl-F":"goCharRight","Ctrl-B":"goCharLeft","Ctrl-P":"goLineUp","Ctrl-N":"goLineDown","Alt-F":"goWordRight","Alt-B":"goWordLeft","Ctrl-A":"goLineStart","Ctrl-E":"goLineEnd","Ctrl-V":"goPageDown","Shift-Ctrl-V":"goPageUp","Ctrl-D":"delCharAfter","Ctrl-H":"delCharBefore","Alt-D":"delWordAfter","Alt-Backspace":"delWordBefore","Ctrl-K":"killLine","Ctrl-T":"transposeChars","Ctrl-O":"openLine"},Rs.macDefault={"Cmd-A":"selectAll","Cmd-D":"deleteLine","Cmd-Z":"undo","Shift-Cmd-Z":"redo","Cmd-Y":"redo","Cmd-Home":"goDocStart","Cmd-Up":"goDocStart","Cmd-End":"goDocEnd","Cmd-Down":"goDocEnd","Alt-Left":"goGroupLeft","Alt-Right":"goGroupRight","Cmd-Left":"goLineLeft","Cmd-Right":"goLineRight","Alt-Backspace":"delGroupBefore","Ctrl-Alt-Backspace":"delGroupAfter","Alt-Delete":"delGroupAfter","Cmd-S":"save","Cmd-F":"find","Cmd-G":"findNext","Shift-Cmd-G":"findPrev","Cmd-Alt-F":"replace","Shift-Cmd-Alt-F":"replaceAll","Cmd-[":"indentLess","Cmd-]":"indentMore","Cmd-Backspace":"delWrappedLineLeft","Cmd-Delete":"delWrappedLineRight","Cmd-U":"undoSelection","Shift-Cmd-U":"redoSelection","Ctrl-Up":"goDocStart","Ctrl-Down":"goDocEnd",fallthrough:["basic","emacsy"]},Rs.default=Ml?Rs.macDefault:Rs.pcDefault;var Bs={selectAll:Mi,singleSelection:function(e){return e.setSelection(e.getCursor("anchor"),e.getCursor("head"),Gl)},killLine:function(e){return co(e,function(t){if(t.empty()){var r=M(e.doc,t.head.line).text.length;return t.head.ch==r&&t.head.line<e.lastLine()?{from:t.head,to:E(t.head.line+1,0)}:{from:t.head,to:E(t.head.line,r)}}return{from:t.from(),to:t.to()}})},deleteLine:function(e){return co(e,function(t){return{from:E(t.from().line,0),to:U(e.doc,E(t.to().line+1,0))}})},delLineLeft:function(e){return co(e,function(e){return{from:E(e.from().line,0),to:e.from()}})},delWrappedLineLeft:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5;return{from:e.coordsChar({left:0,top:r},"div"),to:t.from()}})},delWrappedLineRight:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5,n=e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div");return{from:t.from(),to:n}})},undo:function(e){return e.undo()},redo:function(e){return e.redo()},undoSelection:function(e){return e.undoSelection()},redoSelection:function(e){return e.redoSelection()},goDocStart:function(e){return e.extendSelection(E(e.firstLine(),0))},goDocEnd:function(e){return e.extendSelection(E(e.lastLine()))},goLineStart:function(e){return e.extendSelectionsBy(function(t){return vo(e,t.head.line)},{origin:"+move",bias:1})},goLineStartSmart:function(e){return e.extendSelectionsBy(function(t){return yo(e,t.head)},{origin:"+move",bias:1})},goLineEnd:function(e){return e.extendSelectionsBy(function(t){return mo(e,t.head.line)},{origin:"+move",bias:-1})},goLineRight:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div")},Vl)},goLineLeft:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:0,top:r},"div")},Vl)},goLineLeftSmart:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5,n=e.coordsChar({left:0,top:r},"div");return n.ch<e.getLine(n.line).search(/\S/)?yo(e,t.head):n},Vl)},goLineUp:function(e){return e.moveV(-1,"line")},goLineDown:function(e){return e.moveV(1,"line")},goPageUp:function(e){return e.moveV(-1,"page")},goPageDown:function(e){return e.moveV(1,"page")},goCharLeft:function(e){return e.moveH(-1,"char")},goCharRight:function(e){return e.moveH(1,"char")},goColumnLeft:function(e){return e.moveH(-1,"column")},goColumnRight:function(e){return e.moveH(1,"column")},goWordLeft:function(e){return e.moveH(-1,"word")},goGroupRight:function(e){return e.moveH(1,"group")},goGroupLeft:function(e){return e.moveH(-1,"group")},goWordRight:function(e){return e.moveH(1,"word")},delCharBefore:function(e){return e.deleteH(-1,"char")},delCharAfter:function(e){return e.deleteH(1,"char")},delWordBefore:function(e){return e.deleteH(-1,"word")},delWordAfter:function(e){return e.deleteH(1,"word")},delGroupBefore:function(e){return e.deleteH(-1,"group")},delGroupAfter:function(e){return e.deleteH(1,"group")},indentAuto:function(e){return e.indentSelection("smart")},indentMore:function(e){return e.indentSelection("add")},indentLess:function(e){return e.indentSelection("subtract")},insertTab:function(e){return e.replaceSelection("\t")},insertSoftTab:function(e){for(var t=[],r=e.listSelections(),n=e.options.tabSize,i=0;i<r.length;i++){var o=r[i].from(),l=f(e.getLine(o.line),o.ch,n);t.push(p(n-l%n))}e.replaceSelections(t)},defaultTab:function(e){e.somethingSelected()?e.indentSelection("add"):e.execCommand("insertTab")},transposeChars:function(e){return hn(e,function(){for(var t=e.listSelections(),r=[],n=0;n<t.length;n++)if(t[n].empty()){var i=t[n].head,o=M(e.doc,i.line).text;if(o)if(i.ch==o.length&&(i=new E(i.line,i.ch-1)),i.ch>0)i=new E(i.line,i.ch+1),e.replaceRange(o.charAt(i.ch-1)+o.charAt(i.ch-2),E(i.line,i.ch-2),i,"+transpose");else if(i.line>e.doc.first){var l=M(e.doc,i.line-1).text;l&&(i=new E(i.line,1),e.replaceRange(o.charAt(0)+e.doc.lineSeparator()+l.charAt(l.length-1),E(i.line-1,l.length-1),i,"+transpose"))}r.push(new Ts(i,i))}e.setSelections(r)})},newlineAndIndent:function(e){return hn(e,function(){for(var t=e.listSelections(),r=t.length-1;r>=0;r--)e.replaceRange(e.doc.lineSeparator(),t[r].anchor,t[r].head,"+input");t=e.listSelections();for(var n=0;n<t.length;n++)e.indentLine(t[n].from().line,null,!0);jr(e)})},openLine:function(e){return e.replaceSelection("\n","start")},toggleOverwrite:function(e){return e.toggleOverwrite()}},Gs=new Pl,Us=null,Vs=function(e,t,r){this.time=e,this.pos=t,this.button=r};Vs.prototype.compare=function(e,t,r){return this.time+400>e&&0==P(t,this.pos)&&r==this.button};var Ks,js,Xs={toString:function(){return"CodeMirror.Init"}},Ys={},_s={};jo.defaults=Ys,jo.optionHandlers=_s;var $s=[];jo.defineInitHook=function(e){return $s.push(e)};var qs=null,Zs=function(e){this.cm=e,this.lastAnchorNode=this.lastAnchorOffset=this.lastFocusNode=this.lastFocusOffset=null,this.polling=new Pl,this.composing=null,this.gracePeriod=!1,this.readDOMTimeout=null};Zs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()}),"cut"==e.type&&i.replaceSelection("",null,"cut");else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type&&i.operation(function(){i.setSelections(t.ranges,0,Gl),i.replaceSelection("",null,"cut")})}if(e.clipboardData){e.clipboardData.clearData();var r=qs.text.join("\n");if(e.clipboardData.setData("Text",r),e.clipboardData.getData("Text")==r)return void e.preventDefault()}var l=el(),s=l.firstChild;i.display.lineSpace.insertBefore(l,i.display.lineSpace.firstChild),s.value=qs.text.join("\n");var a=document.activeElement;El(s),setTimeout(function(){i.display.lineSpace.removeChild(l),a.focus(),a==o&&n.showPrimarySelection()},50)}}var r=this,n=this,i=n.cm,o=n.div=e.lineDiv;Jo(o,i.options.spellcheck),Ql(o,"paste",function(e){Me(i,e)||qo(e,i)||vl<=11&&setTimeout(dn(i,function(){return r.updateFromDOM()}),20)}),Ql(o,"compositionstart",function(e){r.composing={data:e.data,done:!1}}),Ql(o,"compositionupdate",function(e){r.composing||(r.composing={data:e.data,done:!1})}),Ql(o,"compositionend",function(e){r.composing&&(e.data!=r.composing.data&&r.readFromDOMSoon(),r.composing.done=!0)}),Ql(o,"touchstart",function(){return n.forceCompositionEnd()}),Ql(o,"input",function(){r.composing||r.readFromDOMSoon()}),Ql(o,"copy",t),Ql(o,"cut",t)},Zs.prototype.prepareSelection=function(){var e=Tr(this.cm,!1);return e.focus=this.cm.state.focused,e},Zs.prototype.showSelection=function(e,t){e&&this.cm.display.view.length&&((e.focus||t)&&this.showPrimarySelection(),this.showMultipleSelections(e))},Zs.prototype.showPrimarySelection=function(){var e=window.getSelection(),t=this.cm,r=t.doc.sel.primary(),n=r.from(),i=r.to();if(t.display.viewTo==t.display.viewFrom||n.line>=t.display.viewTo||i.line<t.display.viewFrom)e.removeAllRanges();else{var o=sl(t,e.anchorNode,e.anchorOffset),l=sl(t,e.focusNode,e.focusOffset);if(!o||o.bad||!l||l.bad||0!=P(B(o,l),n)||0!=P(R(o,l),i)){var s=t.display.view,a=n.line>=t.display.viewFrom&&nl(t,n)||{node:s[0].measure.map[2],offset:0},u=i.line<t.display.viewTo&&nl(t,i);if(!u){var c=s[s.length-1].measure,f=c.maps?c.maps[c.maps.length-1]:c.map;u={node:f[f.length-1],offset:f[f.length-2]-f[f.length-3]}}if(a&&u){var h,d=e.rangeCount&&e.getRangeAt(0);try{h=Wl(a.node,a.offset,u.offset,u.node)}catch(e){}h&&(!fl&&t.state.focused?(e.collapse(a.node,a.offset),h.collapsed||(e.removeAllRanges(),e.addRange(h))):(e.removeAllRanges(),e.addRange(h)),d&&null==e.anchorNode?e.addRange(d):fl&&this.startGracePeriod()),this.rememberSelection()}else e.removeAllRanges()}}},Zs.prototype.startGracePeriod=function(){var e=this;clearTimeout(this.gracePeriod),this.gracePeriod=setTimeout(function(){e.gracePeriod=!1,e.selectionChanged()&&e.cm.operation(function(){return e.cm.curOp.selectionChanged=!0})},20)},Zs.prototype.showMultipleSelections=function(e){r(this.cm.display.cursorDiv,e.cursors),r(this.cm.display.selectionDiv,e.selection)},Zs.prototype.rememberSelection=function(){var e=window.getSelection();this.lastAnchorNode=e.anchorNode,this.lastAnchorOffset=e.anchorOffset,this.lastFocusNode=e.focusNode,this.lastFocusOffset=e.focusOffset},Zs.prototype.selectionInEditor=function(){var e=window.getSelection();if(!e.rangeCount)return!1;var t=e.getRangeAt(0).commonAncestorContainer;return o(this.div,t)},Zs.prototype.focus=function(){"nocursor"!=this.cm.options.readOnly&&(this.selectionInEditor()||this.showSelection(this.prepareSelection(),!0),this.div.focus())},Zs.prototype.blur=function(){this.div.blur()},Zs.prototype.getField=function(){return this.div},Zs.prototype.supportsTouch=function(){return!0},Zs.prototype.receivedFocus=function(){function e(){t.cm.state.focused&&(t.pollSelection(),t.polling.set(t.cm.options.pollInterval,e))}var t=this;this.selectionInEditor()?this.pollSelection():hn(this.cm,function(){return t.cm.curOp.selectionChanged=!0}),this.polling.set(this.cm.options.pollInterval,e)},Zs.prototype.selectionChanged=function(){var e=window.getSelection();return e.anchorNode!=this.lastAnchorNode||e.anchorOffset!=this.lastAnchorOffset||e.focusNode!=this.lastFocusNode||e.focusOffset!=this.lastFocusOffset},Zs.prototype.pollSelection=function(){if(null==this.readDOMTimeout&&!this.gracePeriod&&this.selectionChanged()){var e=window.getSelection(),t=this.cm;if(kl&&bl&&this.cm.options.gutters.length&&il(e.anchorNode))return this.cm.triggerOnKeyDown({type:"keydown",keyCode:8,preventDefault:Math.abs}),this.blur(),void this.focus();if(!this.composing){this.rememberSelection();var r=sl(t,e.anchorNode,e.anchorOffset),n=sl(t,e.focusNode,e.focusOffset);r&&n&&hn(t,function(){bi(t.doc,Rn(r,n),Gl),(r.bad||n.bad)&&(t.curOp.selectionChanged=!0)})}}},Zs.prototype.pollContent=function(){null!=this.readDOMTimeout&&(clearTimeout(this.readDOMTimeout),this.readDOMTimeout=null);var e=this.cm,t=e.display,r=e.doc.sel.primary(),n=r.from(),i=r.to();if(0==n.ch&&n.line>e.firstLine()&&(n=E(n.line-1,M(e.doc,n.line-1).length)),i.ch==M(e.doc,i.line).text.length&&i.line<e.lastLine()&&(i=E(i.line+1,0)),n.line<t.viewFrom||i.line>t.viewTo-1)return!1;var o,l,s;n.line==t.viewFrom||0==(o=Lr(e,n.line))?(l=W(t.view[0].line),s=t.view[0].node):(l=W(t.view[o].line),s=t.view[o-1].node.nextSibling);var a,u,c=Lr(e,i.line);if(c==t.view.length-1?(a=t.viewTo-1,u=t.lineDiv.lastChild):(a=W(t.view[c+1].line)-1,u=t.view[c+1].node.previousSibling),!s)return!1;for(var f=e.doc.splitLines(ll(e,s,u,l,a)),h=N(e.doc,E(l,0),E(a,M(e.doc,a).text.length));f.length>1&&h.length>1;)if(g(f)==g(h))f.pop(),h.pop(),a--;else{if(f[0]!=h[0])break;f.shift(),h.shift(),l++}for(var d=0,p=0,v=f[0],m=h[0],y=Math.min(v.length,m.length);d<y&&v.charCodeAt(d)==m.charCodeAt(d);)++d;for(var b=g(f),w=g(h),x=Math.min(b.length-(1==f.length?d:0),w.length-(1==h.length?d:0));p<x&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)++p;if(1==f.length&&1==h.length&&l==n.line)for(;d&&d>n.ch&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)d--,p++;f[f.length-1]=b.slice(0,b.length-p).replace(/^\u200b+/,""),f[0]=f[0].slice(d).replace(/\u200b+$/,"");var C=E(l,d),S=E(a,h.length?g(h).length-p:0);return f.length>1||f[0]||P(C,S)?(Ei(e.doc,f,C,S,"+input"),!0):void 0},Zs.prototype.ensurePolled=function(){this.forceCompositionEnd()},Zs.prototype.reset=function(){this.forceCompositionEnd()},Zs.prototype.forceCompositionEnd=function(){this.composing&&(clearTimeout(this.readDOMTimeout),this.composing=null,this.updateFromDOM(),this.div.blur(),this.div.focus())},Zs.prototype.readFromDOMSoon=function(){var e=this;null==this.readDOMTimeout&&(this.readDOMTimeout=setTimeout(function(){if(e.readDOMTimeout=null,e.composing){if(!e.composing.done)return;e.composing=null}e.updateFromDOM()},80))},Zs.prototype.updateFromDOM=function(){var e=this;!this.cm.isReadOnly()&&this.pollContent()||hn(this.cm,function(){return vn(e.cm)})},Zs.prototype.setUneditable=function(e){e.contentEditable="false"},Zs.prototype.onKeyPress=function(e){0!=e.charCode&&(e.preventDefault(),this.cm.isReadOnly()||dn(this.cm,$o)(this.cm,String.fromCharCode(null==e.charCode?e.keyCode:e.charCode),0))},Zs.prototype.readOnlyChanged=function(e){this.div.contentEditable=String("nocursor"!=e)},Zs.prototype.onContextMenu=function(){},Zs.prototype.resetPosition=function(){},Zs.prototype.needsContentAttribute=!0;var Qs=function(e){this.cm=e,this.prevInput="",this.pollingFast=!1,this.polling=new Pl,this.hasSelection=!1,this.composing=null};Qs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()});else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type?i.setSelections(t.ranges,null,Gl):(n.prevInput="",l.value=t.text.join("\n"),El(l))}"cut"==e.type&&(i.state.cutIncoming=!0)}}var r=this,n=this,i=this.cm,o=this.wrapper=el(),l=this.textarea=o.firstChild;e.wrapper.insertBefore(o,e.wrapper.firstChild),Ll&&(l.style.width="0px"),Ql(l,"input",function(){gl&&vl>=9&&r.hasSelection&&(r.hasSelection=null),n.poll()}),Ql(l,"paste",function(e){Me(i,e)||qo(e,i)||(i.state.pasteIncoming=!0,n.fastPoll())}),Ql(l,"cut",t),Ql(l,"copy",t),Ql(e.scroller,"paste",function(t){Ft(e,t)||Me(i,t)||(i.state.pasteIncoming=!0,n.focus())}),Ql(e.lineSpace,"selectstart",function(t){Ft(e,t)||We(t)}),Ql(l,"compositionstart",function(){var e=i.getCursor("from");n.composing&&n.composing.range.clear(),n.composing={start:e,range:i.markText(e,i.getCursor("to"),{className:"CodeMirror-composing"})}}),Ql(l,"compositionend",function(){n.composing&&(n.poll(),n.composing.range.clear(),n.composing=null)})},Qs.prototype.prepareSelection=function(){var e=this.cm,t=e.display,r=e.doc,n=Tr(e);if(e.options.moveInputWithCursor){var i=sr(e,r.sel.primary().head,"div"),o=t.wrapper.getBoundingClientRect(),l=t.lineDiv.getBoundingClientRect();n.teTop=Math.max(0,Math.min(t.wrapper.clientHeight-10,i.top+l.top-o.top)),n.teLeft=Math.max(0,Math.min(t.wrapper.clientWidth-10,i.left+l.left-o.left))}return n},Qs.prototype.showSelection=function(e){var t=this.cm.display;r(t.cursorDiv,e.cursors),r(t.selectionDiv,e.selection),null!=e.teTop&&(this.wrapper.style.top=e.teTop+"px",this.wrapper.style.left=e.teLeft+"px")},Qs.prototype.reset=function(e){if(!this.contextMenuPending&&!this.composing){var t=this.cm;if(t.somethingSelected()){this.prevInput="";var r=t.getSelection();this.textarea.value=r,t.state.focused&&El(this.textarea),gl&&vl>=9&&(this.hasSelection=r)}else e||(this.prevInput=this.textarea.value="",gl&&vl>=9&&(this.hasSelection=null))}},Qs.prototype.getField=function(){return this.textarea},Qs.prototype.supportsTouch=function(){return!1},Qs.prototype.focus=function(){if("nocursor"!=this.cm.options.readOnly&&(!Tl||l()!=this.textarea))try{this.textarea.focus()}catch(e){}},Qs.prototype.blur=function(){this.textarea.blur()},Qs.prototype.resetPosition=function(){this.wrapper.style.top=this.wrapper.style.left=0},Qs.prototype.receivedFocus=function(){this.slowPoll()},Qs.prototype.slowPoll=function(){var e=this;this.pollingFast||this.polling.set(this.cm.options.pollInterval,function(){e.poll(),e.cm.state.focused&&e.slowPoll()})},Qs.prototype.fastPoll=function(){function e(){r.poll()||t?(r.pollingFast=!1,r.slowPoll()):(t=!0,r.polling.set(60,e))}var t=!1,r=this;r.pollingFast=!0,r.polling.set(20,e)},Qs.prototype.poll=function(){var e=this,t=this.cm,r=this.textarea,n=this.prevInput;if(this.contextMenuPending||!t.state.focused||ts(r)&&!n&&!this.composing||t.isReadOnly()||t.options.disableInput||t.state.keySeq)return!1;var i=r.value;if(i==n&&!t.somethingSelected())return!1;if(gl&&vl>=9&&this.hasSelection===i||Ml&&/[\uf700-\uf7ff]/.test(i))return t.display.input.reset(),!1;if(t.doc.sel==t.display.selForContextMenu){var o=i.charCodeAt(0);if(8203!=o||n||(n="​"),8666==o)return this.reset(),this.cm.execCommand("undo")}for(var l=0,s=Math.min(n.length,i.length);l<s&&n.charCodeAt(l)==i.charCodeAt(l);)++l;return hn(t,function(){$o(t,i.slice(l),n.length-l,null,e.composing?"*compose":null),i.length>1e3||i.indexOf("\n")>-1?r.value=e.prevInput="":e.prevInput=i,e.composing&&(e.composing.range.clear(),e.composing.range=t.markText(e.composing.start,t.getCursor("to"),{className:"CodeMirror-composing"}))}),!0},Qs.prototype.ensurePolled=function(){this.pollingFast&&this.poll()&&(this.pollingFast=!1)},Qs.prototype.onKeyPress=function(){gl&&vl>=9&&(this.hasSelection=null),this.fastPoll()},Qs.prototype.onContextMenu=function(e){function t(){if(null!=l.selectionStart){var e=i.somethingSelected(),t="​"+(e?l.value:"");l.value="⇚",l.value=t,n.prevInput=e?"":"​",l.selectionStart=1,l.selectionEnd=t.length,o.selForContextMenu=i.doc.sel}}function r(){if(n.contextMenuPending=!1,n.wrapper.style.cssText=c,l.style.cssText=u,gl&&vl<9&&o.scrollbars.setScrollTop(o.scroller.scrollTop=a),null!=l.selectionStart){(!gl||gl&&vl<9)&&t();var e=0,r=function(){o.selForContextMenu==i.doc.sel&&0==l.selectionStart&&l.selectionEnd>0&&"​"==n.prevInput?dn(i,Mi)(i):e++<10?o.detectingSelectAll=setTimeout(r,500):(o.selForContextMenu=null,o.input.reset())};o.detectingSelectAll=setTimeout(r,200)}}var n=this,i=n.cm,o=i.display,l=n.textarea,s=Sr(i,e),a=o.scroller.scrollTop;if(s&&!wl){i.options.resetSelectionOnContextMenu&&-1==i.doc.sel.contains(s)&&dn(i,bi)(i.doc,Rn(s),Gl);var u=l.style.cssText,c=n.wrapper.style.cssText;n.wrapper.style.cssText="position: absolute";var f=n.wrapper.getBoundingClientRect();l.style.cssText="position: absolute; width: 30px; height: 30px;\n      top: "+(e.clientY-f.top-5)+"px; left: "+(e.clientX-f.left-5)+"px;\n      z-index: 1000; background: "+(gl?"rgba(255, 255, 255, .05)":"transparent")+";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";var h;if(ml&&(h=window.scrollY),o.input.focus(),ml&&window.scrollTo(null,h),o.input.reset(),i.somethingSelected()||(l.value=n.prevInput=" "),n.contextMenuPending=!0,o.selForContextMenu=i.doc.sel,clearTimeout(o.detectingSelectAll),gl&&vl>=9&&t(),Hl){Fe(e);var d=function(){ke(window,"mouseup",d),setTimeout(r,20)};Ql(window,"mouseup",d)}else setTimeout(r,50)}},Qs.prototype.readOnlyChanged=function(e){e||this.reset(),this.textarea.disabled="nocursor"==e},Qs.prototype.setUneditable=function(){},Qs.prototype.needsContentAttribute=!1,function(e){function t(t,n,i,o){e.defaults[t]=n,i&&(r[t]=o?function(e,t,r){r!=Xs&&i(e,t,r)}:i)}var r=e.optionHandlers;e.defineOption=t,e.Init=Xs,t("value","",function(e,t){return e.setValue(t)},!0),t("mode",null,function(e,t){e.doc.modeOption=t,jn(e)},!0),t("indentUnit",2,jn,!0),t("indentWithTabs",!1),t("smartIndent",!0),t("tabSize",4,function(e){Xn(e),er(e),vn(e)},!0),t("lineSeparator",null,function(e,t){if(e.doc.lineSep=t,t){var r=[],n=e.doc.first;e.doc.iter(function(e){for(var i=0;;){var o=e.text.indexOf(t,i);if(-1==o)break;i=o+t.length,r.push(E(n,o))}n++});for(var i=r.length-1;i>=0;i--)Ei(e.doc,t,r[i],E(r[i].line,r[i].ch+t.length))}}),t("specialChars",/[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff]/g,function(e,t,r){e.state.specialChars=new RegExp(t.source+(t.test("\t")?"":"|\t"),"g"),r!=Xs&&e.refresh()}),t("specialCharPlaceholder",at,function(e){return e.refresh()},!0),t("electricChars",!0),t("inputStyle",Tl?"contenteditable":"textarea",function(){throw new Error("inputStyle can not (yet) be changed in a running editor")},!0),t("spellcheck",!1,function(e,t){return e.getInputField().spellcheck=t},!0),t("rtlMoveVisually",!Ol),t("wholeLineUpdateBefore",!0),t("theme","default",function(e){Go(e),Uo(e)},!0),t("keyMap","default",function(e,t,r){var n=uo(t),i=r!=Xs&&uo(r);i&&i.detach&&i.detach(e,n),n.attach&&n.attach(e,i||null)}),t("extraKeys",null),t("configureMouse",null),t("lineWrapping",!1,Ko,!0),t("gutters",[],function(e){Fn(e.options),Uo(e)},!0),t("fixedGutter",!0,function(e,t){e.display.gutters.style.left=t?wr(e.display)+"px":"0",e.refresh()},!0),t("coverGutterNextToScrollbar",!1,function(e){return en(e)},!0),t("scrollbarStyle","native",function(e){rn(e),en(e),e.display.scrollbars.setScrollTop(e.doc.scrollTop),e.display.scrollbars.setScrollLeft(e.doc.scrollLeft)},!0),t("lineNumbers",!1,function(e){Fn(e.options),Uo(e)},!0),t("firstLineNumber",1,Uo,!0),t("lineNumberFormatter",function(e){return e},Uo,!0),t("showCursorWhenSelecting",!1,kr,!0),t("resetSelectionOnContextMenu",!0),t("lineWiseCopyCut",!0),t("pasteLinesPerSelection",!0),t("readOnly",!1,function(e,t){"nocursor"==t&&(Fr(e),e.display.input.blur()),e.display.input.readOnlyChanged(t)}),t("disableInput",!1,function(e,t){t||e.display.input.reset()},!0),t("dragDrop",!0,Vo),t("allowDropFileTypes",null),t("cursorBlinkRate",530),t("cursorScrollMargin",0),t("cursorHeight",1,kr,!0),t("singleCursorHeightPerLine",!0,kr,!0),t("workTime",100),t("workDelay",100),t("flattenSpans",!0,Xn,!0),t("addModeClass",!1,Xn,!0),t("pollInterval",100),t("undoDepth",200,function(e,t){return e.doc.history.undoDepth=t}),t("historyEventDelay",1250),t("viewportMargin",10,function(e){return e.refresh()},!0),t("maxHighlightLength",1e4,Xn,!0),t("moveInputWithCursor",!0,function(e,t){t||e.display.input.resetPosition()}),t("tabindex",null,function(e,t){return e.display.input.getField().tabIndex=t||""}),t("autofocus",null),t("direction","ltr",function(e,t){return e.doc.setDirection(t)},!0)}(jo),function(e){var t=e.optionHandlers,r=e.helpers={};e.prototype={constructor:e,focus:function(){window.focus(),this.display.input.focus()},setOption:function(e,r){var n=this.options,i=n[e];n[e]==r&&"mode"!=e||(n[e]=r,t.hasOwnProperty(e)&&dn(this,t[e])(this,r,i),Te(this,"optionChange",this,e))},getOption:function(e){return this.options[e]},getDoc:function(){return this.doc},addKeyMap:function(e,t){this.state.keyMaps[t?"push":"unshift"](uo(e))},removeKeyMap:function(e){for(var t=this.state.keyMaps,r=0;r<t.length;++r)if(t[r]==e||t[r].name==e)return t.splice(r,1),!0},addOverlay:pn(function(t,r){var n=t.token?t:e.getMode(this.options,t);if(n.startState)throw new Error("Overlays may not be stateful.");m(this.state.overlays,{mode:n,modeSpec:t,opaque:r&&r.opaque,priority:r&&r.priority||0},function(e){return e.priority}),this.state.modeGen++,vn(this)}),removeOverlay:pn(function(e){for(var t=this,r=this.state.overlays,n=0;n<r.length;++n){var i=r[n].modeSpec;if(i==e||"string"==typeof e&&i.name==e)return r.splice(n,1),t.state.modeGen++,void vn(t)}}),indentLine:pn(function(e,t,r){"string"!=typeof t&&"number"!=typeof t&&(t=null==t?this.options.smartIndent?"smart":"prev":t?"add":"subtract"),H(this.doc,e)&&Yo(this,e,t,r)}),indentSelection:pn(function(e){for(var t=this,r=this.doc.sel.ranges,n=-1,i=0;i<r.length;i++){var o=r[i];if(o.empty())o.head.line>n&&(Yo(t,o.head.line,e,!0),n=o.head.line,i==t.doc.sel.primIndex&&jr(t));else{var l=o.from(),s=o.to(),a=Math.max(n,l.line);n=Math.min(t.lastLine(),s.line-(s.ch?0:1))+1;for(var u=a;u<n;++u)Yo(t,u,e);var c=t.doc.sel.ranges;0==l.ch&&r.length==c.length&&c[i].from().ch>0&&gi(t.doc,i,new Ts(l,c[i].to()),Gl)}}}),getTokenAt:function(e,t){return Je(this,e,t)},getLineTokens:function(e,t){return Je(this,E(e),t,!0)},getTokenTypeAt:function(e){e=U(this.doc,e);var t,r=_e(this,M(this.doc,e.line)),n=0,i=(r.length-1)/2,o=e.ch;if(0==o)t=r[2];else for(;;){var l=n+i>>1;if((l?r[2*l-1]:0)>=o)i=l;else{if(!(r[2*l+1]<o)){t=r[2*l+2];break}n=l+1}}var s=t?t.indexOf("overlay "):-1;return s<0?t:0==s?null:t.slice(0,s-1)},getModeAt:function(t){var r=this.doc.mode;return r.innerMode?e.innerMode(r,this.getTokenAt(t).state).mode:r},getHelper:function(e,t){return this.getHelpers(e,t)[0]},getHelpers:function(e,t){var n=this,i=[];if(!r.hasOwnProperty(t))return i;var o=r[t],l=this.getModeAt(e);if("string"==typeof l[t])o[l[t]]&&i.push(o[l[t]]);else if(l[t])for(var s=0;s<l[t].length;s++){var a=o[l[t][s]];a&&i.push(a)}else l.helperType&&o[l.helperType]?i.push(o[l.helperType]):o[l.name]&&i.push(o[l.name]);for(var u=0;u<o._global.length;u++){var c=o._global[u];c.pred(l,n)&&-1==h(i,c.val)&&i.push(c.val)}return i},getStateAfter:function(e,t){var r=this.doc;return e=G(r,null==e?r.first+r.size-1:e),$e(this,e+1,t).state},cursorCoords:function(e,t){var r,n=this.doc.sel.primary();return r=null==e?n.head:"object"==typeof e?U(this.doc,e):e?n.from():n.to(),sr(this,r,t||"page")},charCoords:function(e,t){return lr(this,U(this.doc,e),t||"page")},coordsChar:function(e,t){return e=or(this,e,t||"page"),cr(this,e.left,e.top)},lineAtHeight:function(e,t){return e=or(this,{top:e,left:0},t||"page").top,D(this.doc,e+this.display.viewOffset)},heightAtLine:function(e,t,r){var n,i=!1;if("number"==typeof e){var o=this.doc.first+this.doc.size-1;e<this.doc.first?e=this.doc.first:e>o&&(e=o,i=!0),n=M(this.doc,e)}else n=e;return ir(this,n,{top:0,left:0},t||"page",r||i).top+(i?this.doc.height-ye(n):0)},defaultTextHeight:function(){return mr(this.display)},defaultCharWidth:function(){return yr(this.display)},getViewport:function(){return{from:this.display.viewFrom,to:this.display.viewTo}},addWidget:function(e,t,r,n,i){var o=this.display,l=(e=sr(this,U(this.doc,e))).bottom,s=e.left;if(t.style.position="absolute",t.setAttribute("cm-ignore-events","true"),this.display.input.setUneditable(t),o.sizer.appendChild(t),"over"==n)l=e.top;else if("above"==n||"near"==n){var a=Math.max(o.wrapper.clientHeight,this.doc.height),u=Math.max(o.sizer.clientWidth,o.lineSpace.clientWidth);("above"==n||e.bottom+t.offsetHeight>a)&&e.top>t.offsetHeight?l=e.top-t.offsetHeight:e.bottom+t.offsetHeight<=a&&(l=e.bottom),s+t.offsetWidth>u&&(s=u-t.offsetWidth)}t.style.top=l+"px",t.style.left=t.style.right="","right"==i?(s=o.sizer.clientWidth-t.offsetWidth,t.style.right="0px"):("left"==i?s=0:"middle"==i&&(s=(o.sizer.clientWidth-t.offsetWidth)/2),t.style.left=s+"px"),r&&Ur(this,{left:s,top:l,right:s+t.offsetWidth,bottom:l+t.offsetHeight})},triggerOnKeyDown:pn(Lo),triggerOnKeyPress:pn(Mo),triggerOnKeyUp:To,triggerOnMouseDown:pn(Oo),execCommand:function(e){if(Bs.hasOwnProperty(e))return Bs[e].call(null,this)},triggerElectric:pn(function(e){Zo(this,e)}),findPosH:function(e,t,r,n){var i=this,o=1;t<0&&(o=-1,t=-t);for(var l=U(this.doc,e),s=0;s<t&&!(l=tl(i.doc,l,o,r,n)).hitSide;++s);return l},moveH:pn(function(e,t){var r=this;this.extendSelectionsBy(function(n){return r.display.shift||r.doc.extend||n.empty()?tl(r.doc,n.head,e,t,r.options.rtlMoveVisually):e<0?n.from():n.to()},Vl)}),deleteH:pn(function(e,t){var r=this.doc.sel,n=this.doc;r.somethingSelected()?n.replaceSelection("",null,"+delete"):co(this,function(r){var i=tl(n,r.head,e,t,!1);return e<0?{from:i,to:r.head}:{from:r.head,to:i}})}),findPosV:function(e,t,r,n){var i=this,o=1,l=n;t<0&&(o=-1,t=-t);for(var s=U(this.doc,e),a=0;a<t;++a){var u=sr(i,s,"div");if(null==l?l=u.left:u.left=l,(s=rl(i,u,o,r)).hitSide)break}return s},moveV:pn(function(e,t){var r=this,n=this.doc,i=[],o=!this.display.shift&&!n.extend&&n.sel.somethingSelected();if(n.extendSelectionsBy(function(l){if(o)return e<0?l.from():l.to();var s=sr(r,l.head,"div");null!=l.goalColumn&&(s.left=l.goalColumn),i.push(s.left);var a=rl(r,s,e,t);return"page"==t&&l==n.sel.primary()&&Kr(r,lr(r,a,"div").top-s.top),a},Vl),i.length)for(var l=0;l<n.sel.ranges.length;l++)n.sel.ranges[l].goalColumn=i[l]}),findWordAt:function(e){var t=M(this.doc,e.line).text,r=e.ch,n=e.ch;if(t){var i=this.getHelper(e,"wordChars");"before"!=e.sticky&&n!=t.length||!r?++n:--r;for(var o=t.charAt(r),l=x(o,i)?function(e){return x(e,i)}:/\s/.test(o)?function(e){return/\s/.test(e)}:function(e){return!/\s/.test(e)&&!x(e)};r>0&&l(t.charAt(r-1));)--r;for(;n<t.length&&l(t.charAt(n));)++n}return new Ts(E(e.line,r),E(e.line,n))},toggleOverwrite:function(e){null!=e&&e==this.state.overwrite||((this.state.overwrite=!this.state.overwrite)?s(this.display.cursorDiv,"CodeMirror-overwrite"):Fl(this.display.cursorDiv,"CodeMirror-overwrite"),Te(this,"overwriteToggle",this,this.state.overwrite))},hasFocus:function(){return this.display.input.getField()==l()},isReadOnly:function(){return!(!this.options.readOnly&&!this.doc.cantEdit)},scrollTo:pn(function(e,t){Xr(this,e,t)}),getScrollInfo:function(){var e=this.display.scroller;return{left:e.scrollLeft,top:e.scrollTop,height:e.scrollHeight-zt(this)-this.display.barHeight,width:e.scrollWidth-zt(this)-this.display.barWidth,clientHeight:Bt(this),clientWidth:Rt(this)}},scrollIntoView:pn(function(e,t){null==e?(e={from:this.doc.sel.primary().head,to:null},null==t&&(t=this.options.cursorScrollMargin)):"number"==typeof e?e={from:E(e,0),to:null}:null==e.from&&(e={from:e,to:null}),e.to||(e.to=e.from),e.margin=t||0,null!=e.from.line?Yr(this,e):$r(this,e.from,e.to,e.margin)}),setSize:pn(function(e,t){var r=this,n=function(e){return"number"==typeof e||/^\d+$/.test(String(e))?e+"px":e};null!=e&&(this.display.wrapper.style.width=n(e)),null!=t&&(this.display.wrapper.style.height=n(t)),this.options.lineWrapping&&Jt(this);var i=this.display.viewFrom;this.doc.iter(i,this.display.viewTo,function(e){if(e.widgets)for(var t=0;t<e.widgets.length;t++)if(e.widgets[t].noHScroll){mn(r,i,"widget");break}++i}),this.curOp.forceUpdate=!0,Te(this,"refresh",this)}),operation:function(e){return hn(this,e)},startOperation:function(){return nn(this)},endOperation:function(){return on(this)},refresh:pn(function(){var e=this.display.cachedTextHeight;vn(this),this.curOp.forceUpdate=!0,er(this),Xr(this,this.doc.scrollLeft,this.doc.scrollTop),Wn(this),(null==e||Math.abs(e-mr(this.display))>.5)&&Cr(this),Te(this,"refresh",this)}),swapDoc:pn(function(e){var t=this.doc;return t.cm=null,qn(this,e),er(this),this.display.input.reset(),Xr(this,e.scrollLeft,e.scrollTop),this.curOp.forceScroll=!0,bt(this,"swapDoc",this,t),t}),getInputField:function(){return this.display.input.getField()},getWrapperElement:function(){return this.display.wrapper},getScrollerElement:function(){return this.display.scroller},getGutterElement:function(){return this.display.gutters}},Ae(e),e.registerHelper=function(t,n,i){r.hasOwnProperty(t)||(r[t]=e[t]={_global:[]}),r[t][n]=i},e.registerGlobalHelper=function(t,n,i,o){e.registerHelper(t,n,o),r[t]._global.push({pred:i,val:o})}}(jo);var Js="iter insert remove copy getEditor constructor".split(" ");for(var ea in Ds.prototype)Ds.prototype.hasOwnProperty(ea)&&h(Js,ea)<0&&(jo.prototype[ea]=function(e){return function(){return e.apply(this.doc,arguments)}}(Ds.prototype[ea]));return Ae(Ds),jo.inputStyles={textarea:Qs,contenteditable:Zs},jo.defineMode=function(e){jo.defaults.mode||"null"==e||(jo.defaults.mode=e),Be.apply(this,arguments)},jo.defineMIME=function(e,t){os[e]=t},jo.defineMode("null",function(){return{token:function(e){return e.skipToEnd()}}}),jo.defineMIME("text/plain","null"),jo.defineExtension=function(e,t){jo.prototype[e]=t},jo.defineDocExtension=function(e,t){Ds.prototype[e]=t},jo.fromTextArea=function(e,t){function r(){e.value=a.getValue()}if(t=t?c(t):{},t.value=e.value,!t.tabindex&&e.tabIndex&&(t.tabindex=e.tabIndex),!t.placeholder&&e.placeholder&&(t.placeholder=e.placeholder),null==t.autofocus){var n=l();t.autofocus=n==e||null!=e.getAttribute("autofocus")&&n==document.body}var i;if(e.form&&(Ql(e.form,"submit",r),!t.leaveSubmitMethodAlone)){var o=e.form;i=o.submit;try{var s=o.submit=function(){r(),o.submit=i,o.submit(),o.submit=s}}catch(e){}}t.finishInit=function(t){t.save=r,t.getTextArea=function(){return e},t.toTextArea=function(){t.toTextArea=isNaN,r(),e.parentNode.removeChild(t.getWrapperElement()),e.style.display="",e.form&&(ke(e.form,"submit",r),"function"==typeof e.form.submit&&(e.form.submit=i))}},e.style.display="none";var a=jo(function(t){return e.parentNode.insertBefore(t,e.nextSibling)},t);return a},function(e){e.off=ke,e.on=Ql,e.wheelEventPixels=Pn,e.Doc=Ds,e.splitLines=es,e.countColumn=f,e.findColumn=d,e.isWordChar=w,e.Pass=Bl,e.signal=Te,e.Line=fs,e.changeEnd=Bn,e.scrollbarModel=ws,e.Pos=E,e.cmpPos=P,e.modes=is,e.mimeModes=os,e.resolveMode=Ge,e.getMode=Ue,e.modeExtensions=ls,e.extendMode=Ve,e.copyState=Ke,e.startState=Xe,e.innerMode=je,e.commands=Bs,e.keyMap=Rs,e.keyName=ao,e.isModifierKey=lo,e.lookupKey=oo,e.normalizeKeyMap=io,e.StringStream=ss,e.SharedTextMarker=As,e.TextMarker=Os,e.LineWidget=Ms,e.e_preventDefault=We,e.e_stopPropagation=De,e.e_stop=Fe,e.addClass=s,e.contains=o,e.rmClass=Fl,e.keyNames=Es}(jo),jo.version="5.30.0",jo});
      !function(e){"object"==typeof exports&&"object"==typeof module?e(require("../../lib/codemirror")):"function"==typeof define&&define.amd?define(["../../lib/codemirror"],e):e(CodeMirror)}(function(e){"use strict";function t(e,t,n,r,o,a){this.indented=e,this.column=t,this.type=n,this.info=r,this.align=o,this.prev=a}function n(e,n,r,o){var a=e.indented;return e.context&&"statement"==e.context.type&&"statement"!=r&&(a=e.context.indented),e.context=new t(a,n,r,o,null,e.context)}function r(e){var t=e.context.type;return")"!=t&&"]"!=t&&"}"!=t||(e.indented=e.context.indented),e.context=e.context.prev}function o(e,t,n){return"variable"==t.prevToken||"type"==t.prevToken||(!!/\S(?:[^- ]>|[*\]])\s*$|\*$/.test(e.string.slice(0,n))||(!(!t.typeAtEndOfLine||e.column()!=e.indentation())||void 0))}function a(e){for(;;){if(!e||"top"==e.type)return!0;if("}"==e.type&&"namespace"!=e.prev.info)return!1;e=e.prev}}function i(e){for(var t={},n=e.split(" "),r=0;r<n.length;++r)t[n[r]]=!0;return t}function l(e,t){return"function"==typeof e?e(t):e.propertyIsEnumerable(t)}function s(e,t){if(!t.startOfLine)return!1;for(var n,r=null;n=e.peek();){if("\\"==n&&e.match(/^.$/)){r=s;break}if("/"==n&&e.match(/^\/[\/\*]/,!1))break;e.next()}return t.tokenize=r,"meta"}function c(e,t){return"type"==t.prevToken&&"type"}function u(e){return e.eatWhile(/[\w\.']/),"number"}function d(e,t){if(e.backUp(1),e.match(/(R|u8R|uR|UR|LR)/)){var n=e.match(/"([^\s\\()]{0,16})\(/);return!!n&&(t.cpp11RawStringDelim=n[1],t.tokenize=m,m(e,t))}return e.match(/(u8|u|U|L)/)?!!e.match(/["']/,!1)&&"string":(e.next(),!1)}function f(e){var t=/(\w+)::~?(\w+)$/.exec(e);return t&&t[1]==t[2]}function p(e,t){for(var n;null!=(n=e.next());)if('"'==n&&!e.eat('"')){t.tokenize=null;break}return"string"}function m(e,t){var n=t.cpp11RawStringDelim.replace(/[^\w\s]/g,"\\$&");return e.match(new RegExp(".*?\\)"+n+'"'))?t.tokenize=null:e.skipToEnd(),"string"}function h(t,n){function r(e){if(e)for(var t in e)e.hasOwnProperty(t)&&o.push(t)}"string"==typeof t&&(t=[t]);var o=[];r(n.keywords),r(n.types),r(n.builtin),r(n.atoms),o.length&&(n.helperType=t[0],e.registerHelper("hintWords",t[0],o));for(var a=0;a<t.length;++a)e.defineMIME(t[a],n)}function g(e,t){for(var n=!1;!e.eol();){if(!n&&e.match('"""')){t.tokenize=null;break}n="\\"==e.next()&&!n}return"string"}function y(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!e&&!o&&t.match('"')){a=!0;break}if(e&&t.match('"""')){a=!0;break}r=t.next(),!o&&"$"==r&&t.match("{")&&t.skipTo("}"),o=!o&&"\\"==r&&!e}return!a&&e||(n.tokenize=null),"string"}}function x(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!o&&t.match('"')&&("single"==e||t.match('""'))){a=!0;break}if(!o&&t.match("``")){w=x(e),a=!0;break}r=t.next(),o="single"==e&&!o&&"\\"==r}return a&&(n.tokenize=null),"string"}}e.defineMode("clike",function(i,s){function c(e,t){var n=e.next();if(S[n]){var r=S[n](e,t);if(!1!==r)return r}if('"'==n||"'"==n)return t.tokenize=u(n),t.tokenize(e,t);if(D.test(n))return p=n,null;if(L.test(n)){if(e.backUp(1),e.match(I))return"number";e.next()}if("/"==n){if(e.eat("*"))return t.tokenize=d,d(e,t);if(e.eat("/"))return e.skipToEnd(),"comment"}if(F.test(n)){for(;!e.match(/^\/[\/*]/,!1)&&e.eat(F););return"operator"}if(e.eatWhile(z),P)for(;e.match(P);)e.eatWhile(z);var o=e.current();return l(x,o)?(l(w,o)&&(p="newstatement"),l(v,o)&&(m=!0),"keyword"):l(b,o)?"type":l(k,o)?(l(w,o)&&(p="newstatement"),"builtin"):l(_,o)?"atom":"variable"}function u(e){return function(t,n){for(var r,o=!1,a=!1;null!=(r=t.next());){if(r==e&&!o){a=!0;break}o=!o&&"\\"==r}return(a||!o&&!C)&&(n.tokenize=null),"string"}}function d(e,t){for(var n,r=!1;n=e.next();){if("/"==n&&r){t.tokenize=null;break}r="*"==n}return"comment"}function f(e,t){s.typeFirstDefinitions&&e.eol()&&a(t.context)&&(t.typeAtEndOfLine=o(e,t,e.pos))}var p,m,h=i.indentUnit,g=s.statementIndentUnit||h,y=s.dontAlignCalls,x=s.keywords||{},b=s.types||{},k=s.builtin||{},w=s.blockKeywords||{},v=s.defKeywords||{},_=s.atoms||{},S=s.hooks||{},C=s.multiLineStrings,T=!1!==s.indentStatements,M=!1!==s.indentSwitch,P=s.namespaceSeparator,D=s.isPunctuationChar||/[\[\]{}\(\),;\:\.]/,L=s.numberStart||/[\d\.]/,I=s.number||/^(?:0x[a-f\d]+|0b[01]+|(?:\d+\.?\d*|\.\d+)(?:e[-+]?\d+)?)(u|ll?|l|f)?/i,F=s.isOperatorChar||/[+\-*&%=<>!?|\/]/,z=s.isIdentifierChar||/[\w\$_\xa1-\uffff]/;return{startState:function(e){return{tokenize:null,context:new t((e||0)-h,0,"top",null,!1),indented:0,startOfLine:!0,prevToken:null}},token:function(e,t){var i=t.context;if(e.sol()&&(null==i.align&&(i.align=!1),t.indented=e.indentation(),t.startOfLine=!0),e.eatSpace())return f(e,t),null;p=m=null;var l=(t.tokenize||c)(e,t);if("comment"==l||"meta"==l)return l;if(null==i.align&&(i.align=!0),";"==p||":"==p||","==p&&e.match(/^\s*(?:\/\/.*)?$/,!1))for(;"statement"==t.context.type;)r(t);else if("{"==p)n(t,e.column(),"}");else if("["==p)n(t,e.column(),"]");else if("("==p)n(t,e.column(),")");else if("}"==p){for(;"statement"==i.type;)i=r(t);for("}"==i.type&&(i=r(t));"statement"==i.type;)i=r(t)}else p==i.type?r(t):T&&(("}"==i.type||"top"==i.type)&&";"!=p||"statement"==i.type&&"newstatement"==p)&&n(t,e.column(),"statement",e.current());if("variable"==l&&("def"==t.prevToken||s.typeFirstDefinitions&&o(e,t,e.start)&&a(t.context)&&e.match(/^\s*\(/,!1))&&(l="def"),S.token){var u=S.token(e,t,l);void 0!==u&&(l=u)}return"def"==l&&!1===s.styleDefs&&(l="variable"),t.startOfLine=!1,t.prevToken=m?"def":l||p,f(e,t),l},indent:function(t,n){if(t.tokenize!=c&&null!=t.tokenize||t.typeAtEndOfLine)return e.Pass;var r=t.context,o=n&&n.charAt(0);if("statement"==r.type&&"}"==o&&(r=r.prev),s.dontIndentStatements)for(;"statement"==r.type&&s.dontIndentStatements.test(r.info);)r=r.prev;if(S.indent){var a=S.indent(t,r,n);if("number"==typeof a)return a}var i=o==r.type,l=r.prev&&"switch"==r.prev.info;if(s.allmanIndentation&&/[{(]/.test(o)){for(;"top"!=r.type&&"}"!=r.type;)r=r.prev;return r.indented}return"statement"==r.type?r.indented+("{"==o?0:g):!r.align||y&&")"==r.type?")"!=r.type||i?r.indented+(i?0:h)+(i||!l||/^(?:case|default)\b/.test(n)?0:h):r.indented+g:r.column+(i?0:1)},electricInput:M?/^\s*(?:case .*?:|default:|\{\}?|\})$/:/^\s*[{}]$/,blockCommentStart:"/*",blockCommentEnd:"*/",lineComment:"//",fold:"brace"}});var b="auto if break case register continue return default do sizeof static else struct switch extern typedef union for goto while enum const volatile",k="int long char short double float unsigned signed void size_t ptrdiff_t";h(["text/x-csrc","text/x-c","text/x-chdr"],{name:"clike",keywords:i(b),types:i(k+" bool _Complex _Bool float_t double_t intptr_t intmax_t int8_t int16_t int32_t int64_t uintptr_t uintmax_t uint8_t uint16_t uint32_t uint64_t"),blockKeywords:i("case do else for if switch while struct"),defKeywords:i("struct"),typeFirstDefinitions:!0,atoms:i("null true false"),hooks:{"#":s,"*":c},modeProps:{fold:["brace","include"]}}),h(["text/x-c++src","text/x-c++hdr"],{name:"clike",keywords:i(b+" asm dynamic_cast namespace reinterpret_cast try explicit new static_cast typeid catch operator template typename class friend private this using const_cast inline public throw virtual delete mutable protected alignas alignof constexpr decltype nullptr noexcept thread_local final static_assert override"),types:i(k+" bool wchar_t"),blockKeywords:i("catch class do else finally for if struct switch try while"),defKeywords:i("class namespace struct enum union"),typeFirstDefinitions:!0,atoms:i("true false null"),dontIndentStatements:/^template$/,isIdentifierChar:/[\w\$_~\xa1-\uffff]/,hooks:{"#":s,"*":c,u:d,U:d,L:d,R:d,0:u,1:u,2:u,3:u,4:u,5:u,6:u,7:u,8:u,9:u,token:function(e,t,n){if("variable"==n&&"("==e.peek()&&(";"==t.prevToken||null==t.prevToken||"}"==t.prevToken)&&f(e.current()))return"def"}},namespaceSeparator:"::",modeProps:{fold:["brace","include"]}}),h("text/x-java",{name:"clike",keywords:i("abstract assert break case catch class const continue default do else enum extends final finally float for goto if implements import instanceof interface native new package private protected public return static strictfp super switch synchronized this throw throws transient try volatile while @interface"),types:i("byte short int long float double boolean char void Boolean Byte Character Double Float Integer Long Number Object Short String StringBuffer StringBuilder Void"),blockKeywords:i("catch class do else finally for if switch try while"),defKeywords:i("class interface package enum @interface"),typeFirstDefinitions:!0,atoms:i("true false null"),number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,hooks:{"@":function(e){return!e.match("interface",!1)&&(e.eatWhile(/[\w\$_]/),"meta")}},modeProps:{fold:["brace","import"]}}),h("text/x-csharp",{name:"clike",keywords:i("abstract as async await base break case catch checked class const continue default delegate do else enum event explicit extern finally fixed for foreach goto if implicit in interface internal is lock namespace new operator out override params private protected public readonly ref return sealed sizeof stackalloc static struct switch this throw try typeof unchecked unsafe using virtual void volatile while add alias ascending descending dynamic from get global group into join let orderby partial remove select set value var yield"),types:i("Action Boolean Byte Char DateTime DateTimeOffset Decimal Double Func Guid Int16 Int32 Int64 Object SByte Single String Task TimeSpan UInt16 UInt32 UInt64 bool byte char decimal double short int long object sbyte float string ushort uint ulong"),blockKeywords:i("catch class do else finally for foreach if struct switch try while"),defKeywords:i("class interface namespace struct var"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"@":function(e,t){return e.eat('"')?(t.tokenize=p,p(e,t)):(e.eatWhile(/[\w\$_]/),"meta")}}}),h("text/x-scala",{name:"clike",keywords:i("abstract case catch class def do else extends final finally for forSome if implicit import lazy match new null object override package private protected return sealed super this throw trait try type val var while with yield _ assert assume require print println printf readLine readBoolean readByte readShort readChar readInt readLong readFloat readDouble"),types:i("AnyVal App Application Array BufferedIterator BigDecimal BigInt Char Console Either Enumeration Equiv Error Exception Fractional Function IndexedSeq Int Integral Iterable Iterator List Map Numeric Nil NotNull Option Ordered Ordering PartialFunction PartialOrdering Product Proxy Range Responder Seq Serializable Set Specializable Stream StringBuilder StringContext Symbol Throwable Traversable TraversableOnce Tuple Unit Vector Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),multiLineStrings:!0,blockKeywords:i("catch class enum do else finally for forSome if match switch try while"),defKeywords:i("class enum def object package trait type val var"),atoms:i("true false null"),indentStatements:!1,indentSwitch:!1,isOperatorChar:/[+\-*&%=<>!?|\/#:@]/,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return!!e.match('""')&&(t.tokenize=g,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},"=":function(e,n){var r=n.context;return!("}"!=r.type||!r.align||!e.eat(">"))&&(n.context=new t(r.indented,r.column,r.type,r.info,null,r.prev),"operator")}},modeProps:{closeBrackets:{triples:'"'}}}),h("text/x-kotlin",{name:"clike",keywords:i("package as typealias class interface this super val var fun for is in This throw return break continue object if else while do try when !in !is as? file import where by get set abstract enum open inner override private public internal protected catch finally out final vararg reified dynamic companion constructor init sealed field property receiver param sparam lateinit data inline noinline tailrec external annotation crossinline const operator infix suspend"),types:i("Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),intendSwitch:!1,indentStatements:!1,multiLineStrings:!0,number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,blockKeywords:i("catch class do else finally for if where try while enum"),defKeywords:i("class val var object package interface fun"),atoms:i("true false null this"),hooks:{'"':function(e,t){return t.tokenize=y(e.match('""')),t.tokenize(e,t)}},modeProps:{closeBrackets:{triples:'"'}}}),h(["x-shader/x-vertex","x-shader/x-fragment"],{name:"clike",keywords:i("sampler1D sampler2D sampler3D samplerCube sampler1DShadow sampler2DShadow const attribute uniform varying break continue discard return for while do if else struct in out inout"),types:i("float int bool void vec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4 mat2 mat3 mat4"),blockKeywords:i("for while do if else struct"),builtin:i("radians degrees sin cos tan asin acos atan pow exp log exp2 sqrt inversesqrt abs sign floor ceil fract mod min max clamp mix step smoothstep length distance dot cross normalize ftransform faceforward reflect refract matrixCompMult lessThan lessThanEqual greaterThan greaterThanEqual equal notEqual any all not texture1D texture1DProj texture1DLod texture1DProjLod texture2D texture2DProj texture2DLod texture2DProjLod texture3D texture3DProj texture3DLod texture3DProjLod textureCube textureCubeLod shadow1D shadow2D shadow1DProj shadow2DProj shadow1DLod shadow2DLod shadow1DProjLod shadow2DProjLod dFdx dFdy fwidth noise1 noise2 noise3 noise4"),atoms:i("true false gl_FragColor gl_SecondaryColor gl_Normal gl_Vertex gl_MultiTexCoord0 gl_MultiTexCoord1 gl_MultiTexCoord2 gl_MultiTexCoord3 gl_MultiTexCoord4 gl_MultiTexCoord5 gl_MultiTexCoord6 gl_MultiTexCoord7 gl_FogCoord gl_PointCoord gl_Position gl_PointSize gl_ClipVertex gl_FrontColor gl_BackColor gl_FrontSecondaryColor gl_BackSecondaryColor gl_TexCoord gl_FogFragCoord gl_FragCoord gl_FrontFacing gl_FragData gl_FragDepth gl_ModelViewMatrix gl_ProjectionMatrix gl_ModelViewProjectionMatrix gl_TextureMatrix gl_NormalMatrix gl_ModelViewMatrixInverse gl_ProjectionMatrixInverse gl_ModelViewProjectionMatrixInverse gl_TexureMatrixTranspose gl_ModelViewMatrixInverseTranspose gl_ProjectionMatrixInverseTranspose gl_ModelViewProjectionMatrixInverseTranspose gl_TextureMatrixInverseTranspose gl_NormalScale gl_DepthRange gl_ClipPlane gl_Point gl_FrontMaterial gl_BackMaterial gl_LightSource gl_LightModel gl_FrontLightModelProduct gl_BackLightModelProduct gl_TextureColor gl_EyePlaneS gl_EyePlaneT gl_EyePlaneR gl_EyePlaneQ gl_FogParameters gl_MaxLights gl_MaxClipPlanes gl_MaxTextureUnits gl_MaxTextureCoords gl_MaxVertexAttribs gl_MaxVertexUniformComponents gl_MaxVaryingFloats gl_MaxVertexTextureImageUnits gl_MaxTextureImageUnits gl_MaxFragmentUniformComponents gl_MaxCombineTextureImageUnits gl_MaxDrawBuffers"),indentSwitch:!1,hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-nesc",{name:"clike",keywords:i(b+"as atomic async call command component components configuration event generic implementation includes interface module new norace nx_struct nx_union post provides signal task uses abstract extends"),types:i(k),blockKeywords:i("case do else for if switch while struct"),atoms:i("null true false"),hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-objectivec",{name:"clike",keywords:i(b+"inline restrict _Bool _Complex _Imaginary BOOL Class bycopy byref id IMP in inout nil oneway out Protocol SEL self super atomic nonatomic retain copy readwrite readonly"),types:i(k),atoms:i("YES NO NULL NILL ON OFF true false"),hooks:{"@":function(e){return e.eatWhile(/[\w\$]/),"keyword"},"#":s,indent:function(e,t,n){if("statement"==t.type&&/^@\w/.test(n))return t.indented}},modeProps:{fold:"brace"}}),h("text/x-squirrel",{name:"clike",keywords:i("base break clone continue const default delete enum extends function in class foreach local resume return this throw typeof yield constructor instanceof static"),types:i(k),blockKeywords:i("case catch class else for foreach if switch try while"),defKeywords:i("function local class"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"#":s},modeProps:{fold:["brace","include"]}});var w=null;h("text/x-ceylon",{name:"clike",keywords:i("abstracts alias assembly assert assign break case catch class continue dynamic else exists extends finally for function given if import in interface is let module new nonempty object of out outer package return satisfies super switch then this throw try value void while"),types:function(e){var t=e.charAt(0);return t===t.toUpperCase()&&t!==t.toLowerCase()},blockKeywords:i("case catch class dynamic else finally for function if interface module new object switch try while"),defKeywords:i("class dynamic function interface module object package value"),builtin:i("abstract actual aliased annotation by default deprecated doc final formal late license native optional sealed see serializable shared suppressWarnings tagged throws variable"),isPunctuationChar:/[\[\]{}\(\),;\:\.`]/,isOperatorChar:/[+\-*&%=<>!?|^~:\/]/,numberStart:/[\d#$]/,number:/^(?:#[\da-fA-F_]+|\$[01_]+|[\d_]+[kMGTPmunpf]?|[\d_]+\.[\d_]+(?:[eE][-+]?\d+|[kMGTPmunpf]|)|)/i,multiLineStrings:!0,typeFirstDefinitions:!0,atoms:i("true false null larger smaller equal empty finished"),indentSwitch:!1,styleDefs:!1,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return t.tokenize=x(e.match('""')?"triple":"single"),t.tokenize(e,t)},"`":function(e,t){return!(!w||!e.match("`"))&&(t.tokenize=w,w=null,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},token:function(e,t,n){if(("variable"==n||"type"==n)&&"."==t.prevToken)return"variable-2"}},modeProps:{fold:["brace","import"],closeBrackets:{triples:'"'}}})});
      // -------------------------------------------------------------------------
//  Part of the CodeChecker project, under the Apache License v2.0 with
//  LLVM Exceptions. See LICENSE for license information.
//  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
// -------------------------------------------------------------------------

var BugViewer = {
  _files : [],
  _reports : [],
  _lineWidgets : [],
  _navigationMenuItems : [],
  _sourceFileData : null,
  _currentReport : null,
  _lastBugEvent  : null,

  init : function (files, reports) {
    this._files = files;
    this._reports = reports;

    this.initEscapeChars();
  },

  initEscapeChars : function () {
    this.escapeChars = {
      ' ' : 'nbsp',
      '<' : 'lt',
      '>' : 'gt',
      '"' : 'quot',
      '&' : 'amp'
    };

    var regexString = '[';
    for (var key in this.escapeChars) {
      regexString += key;
    }
    regexString += ']';

    this.escapeRegExp = new RegExp( regexString, 'g');
  },

  escapeHTML : function (str) {
    var that = this;

    return str.replace(this.escapeRegExp, function (m) {
      return '&' + that.escapeChars[m] + ';';
    });
  },

  initByUrl : function () {
    if (!this._reports) return;

    var state = {};
    window.location.hash.substr(1).split('&').forEach(function (s) {
      var parts = s.split('=');
      state[parts[0]] = parts[1];
    });

    for (var key in this._reports) {
      var report = this._reports[key];
      if (report.reportHash === state['reportHash']) {
        this.navigate(report);
        return;
      }
    }

    this.navigate(this._reports[0]);
  },

  create : function () {
    this._content = document.getElementById('editor-wrapper');
    this._filepath = document.getElementById('file-path');
    this._checkerName = document.getElementById('checker-name');
    this._reviewStatusWrapper =
      document.getElementById('review-status-wrapper');
    this._reviewStatus = document.getElementById('review-status');
    this._editor = document.getElementById('editor');

    this._codeMirror = CodeMirror(this._editor, {
      mode: 'text/x-c++src',
      matchBrackets : true,
      lineNumbers : true,
      readOnly : true,
      foldGutter : true,
      extraKeys : {},
      viewportMargin : 100
    });

    this._createNavigationMenu();
  },

  navigate : function (report, item) {
    if (!item) {
      var items = this._navigationMenuItems.filter(function (navItem) {
        return navItem.report.reportHash === report.reportHash;
      });

      if (!items.length) return;

      item = items[0].widget;
    }

    this._selectedReport.classList.remove('active');
    this._selectedReport = item;
    this._selectedReport.classList.add('active');
    this.setReport(report);
  },

  _createNavigationMenu : function () {
    var that = this;

    var nav = document.getElementById('report-nav');
    var list = document.createElement('ul');
    this._reports.forEach(function (report) {
      var events = report['events'];
      var lastBugEvent = events[events.length - 1];
      var item = document.createElement('li');

      var severity = document.createElement('i');
      severity.className = 'severity-' + report.severity.toLowerCase();

      item.appendChild(severity);
      item.appendChild(document.createTextNode(lastBugEvent.message));

      item.addEventListener('click', function () {
        that.navigate(report, item);
      })
      list.appendChild(item);
      that._navigationMenuItems.push({ report : report, widget : item });
    });

    if (!this._selectedReport && list.childNodes.length) {
      this._selectedReport = list.childNodes[0];
      this._selectedReport.classList.add('active');
    }

    nav.appendChild(list);
  },

  setReport : function (report) {
    this._currentReport = report;
    var events = report['events'];
    var lastBugEvent = events[events.length - 1];
    this.setCurrentBugEvent(lastBugEvent, events.length - 1);
    this.setCheckerName(report.checkerName);
    this.setReviewStatus(report.reviewStatus);

    window.location.hash = '#reportHash=' + report.reportHash;
  },

  setCurrentBugEvent : function (event, idx) {
    this._currentBugEvent = event;
    this.setSourceFileData(this._files[event.location.file]);
    this.drawBugPath();

    this.jumpTo(event.location.line, 0);
    this.highlightBugEvent(event, idx);
  },

  highlightBugEvent : function (event, idx) {
    this._lineWidgets.forEach(function (widget) {
      var lineIdx = widget.node.getAttribute('idx');
      if (parseInt(lineIdx) === idx) {
        widget.node.classList.add('current');
      }
    });
  },

  setCheckerName : function (checkerName) {
    this._checkerName.innerHTML = checkerName;
  },

  setReviewStatus : function (status) {
    if (status) {
      var className =
        'review-status-' + status.toLowerCase().split(' ').join('-');
      this._reviewStatus.className = "review-status " + className;

      this._reviewStatus.innerHTML = status;
      this._reviewStatusWrapper.style.display = 'block';
    } else {
      this._reviewStatusWrapper.style.display = 'none';
    }
  },

  setSourceFileData : function (file) {
    if (this._sourceFileData && file.id === this._sourceFileData.id) {
      return;
    }

    this._sourceFileData = file;
    this._filepath.innerHTML = file.path;
    this._codeMirror.doc.setValue(file.content);
    this._refresh();
  },

  _refresh : function () {
    var that = this;
    setTimeout(function () {
      var fullHeight = parseInt(that._content.clientHeight);
      var headerHeight = that._filepath.clientHeight;

      that._codeMirror.setSize('auto', fullHeight - headerHeight);
      that._codeMirror.refresh();
    }, 200);
  },

  clearBubbles : function () {
    this._lineWidgets.forEach(function (widget) { widget.clear(); });
    this._lineWidgets = [];
  },

  getMessage : function (event, kind) {
    if (kind === 'macro') {
      var name = 'macro expansion' + (event.name ? ': ' + event.name : '');

      return '<span class="tag macro">' + name + '</span>'
        + this.escapeHTML(event.expansion).replace(/(?:\r\n|\r|\n)/g, '<br>');
    } else if (kind === 'note') {
      return '<span class="tag note">note</span>'
        +  this.escapeHTML(event.message).replace(/(?:\r\n|\r|\n)/g, '<br>');
    }
  },

  addExtraPathEvents : function (events, kind) {
    var that = this;

    if (!events) {
      return;
    }

    events.forEach(function (event) {
      if (event.location.file !== that._currentBugEvent.location.file) {
        return;
      }

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + kind);

      var msg = document.createElement('span');
      msg.innerHTML = that.getMessage(event, kind);
      element.appendChild(msg);

      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  drawBugPath : function () {
    var that = this;

    this.clearBubbles();

    this.addExtraPathEvents(this._currentReport.macros, 'macro');
    this.addExtraPathEvents(this._currentReport.notes, 'note');

    // Processing bug path events.
    var currentEvents = this._currentReport.events;
    currentEvents.forEach(function (event, step) {
      if (event.location.file !== that._currentBugEvent.location.file)
        return;

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';
      var type = step === currentEvents.length - 1 ? 'error' : 'info';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + type);
      element.setAttribute('idx', step);

      var enumeration = document.createElement('span');
      enumeration.setAttribute('class', 'checker-enum ' + type);
      enumeration.innerHTML = step + 1;

      if (currentEvents.length > 1)
        element.appendChild(enumeration);

      var prevBugEvent = step - 1;
      if (step > 0) {
        var prevBug = document.createElement('span');
        prevBug.setAttribute('class', 'arrow left-arrow');
        prevBug.addEventListener('click', function () {
          var event = currentEvents[prevBugEvent];
          that.setCurrentBugEvent(event, prevBugEvent);
        });
        element.appendChild(prevBug);
      }

      var msg = document.createElement('span');
      msg.innerHTML = that.escapeHTML(event.message)
        .replace(/(?:\r\n|\r|\n)/g, '<br>');

      element.appendChild(msg);

      var nextBugEvent = step + 1;
      if (nextBugEvent < currentEvents.length) {
        var nextBug = document.createElement('span');
        nextBug.setAttribute('class', 'arrow right-arrow');
        nextBug.addEventListener('click', function () {
          var event = currentEvents[nextBugEvent];
          that.setCurrentBugEvent(event, nextBugEvent);
        });
        element.appendChild(nextBug);
      }


      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  jumpTo : function (line, column) {
    var that = this;

    setTimeout(function () {
      var selPosPixel
        = that._codeMirror.charCoords({ line : line, ch : column }, 'local');
      var editorSize = {
        width  : that._editor.clientWidth,
        height : that._editor.clientHeight
      };

      that._codeMirror.scrollIntoView({
        top    : selPosPixel.top - 100,
        bottom : selPosPixel.top + editorSize.height - 150,
        left   : selPosPixel.left < editorSize.width - 100
               ? 0
               : selPosPixel.left - 50,
        right  : selPosPixel.left < editorSize.width - 100
               ? 10
               : selPosPixel.left + editorSize.width - 100
      });
    }, 0);
  }
}


      var data = {"files": {"2": {"id": 2, "path": "/home/vsts/work/1/build/tools/polly/lib/External/isl/include/isl/stdint.h", "content": "#include <stdint.h>\n"}, "6": {"id": 6, "path": "/home/vsts/work/1/llvm-project/polly/include/polly/CodeGen/LoopGenerators.h", "content": "//===- LoopGenerators.h - IR helper to create loops -------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file contains functions to create scalar and OpenMP parallel loops\n// as LLVM-IR.\n//\n//===----------------------------------------------------------------------===//\n#ifndef POLLY_LOOP_GENERATORS_H\n#define POLLY_LOOP_GENERATORS_H\n\n#include \"polly/CodeGen/IRBuilder.h\"\n#include \"polly/Support/ScopHelper.h\"\n#include \"llvm/ADT/SetVector.h\"\n\nnamespace polly {\nusing llvm::AllocaInst;\nusing llvm::BasicBlock;\nusing llvm::DataLayout;\nusing llvm::DominatorTree;\nusing llvm::Function;\nusing llvm::ICmpInst;\nusing llvm::LoopInfo;\nusing llvm::Module;\nusing llvm::SetVector;\nusing llvm::Type;\nusing llvm::Value;\n\n/// General scheduling types of parallel OpenMP for loops.\n/// Initialization values taken from OpenMP's enum in kmp.h: sched_type.\n/// Currently, only 'static' scheduling may change from chunked to non-chunked.\nenum class OMPGeneralSchedulingType {\n  StaticChunked = 33,\n  StaticNonChunked = 34,\n  Dynamic = 35,\n  Guided = 36,\n  Runtime = 37\n};\n\nextern int PollyNumThreads;\nextern OMPGeneralSchedulingType PollyScheduling;\nextern int PollyChunkSize;\n\n/// Create a scalar do/for-style loop.\n///\n/// @param LowerBound         The starting value of the induction variable.\n/// @param UpperBound         The upper bound of the induction variable.\n/// @param Stride             The value by which the induction variable\n///                           is incremented.\n///\n/// @param Builder            The builder used to create the loop.\n/// @param P                  A pointer to the pass that uses this function.\n///                           It is used to update analysis information.\n/// @param LI                 The loop info for the current function\n/// @param DT                 The dominator tree we need to update\n/// @param ExitBlock          The block the loop will exit to.\n/// @param Predicate          The predicate used to generate the upper loop\n///                           bound.\n/// @param Annotator          This function can (optionally) take\n///                           a ScopAnnotator which\n///                           annotates loops and alias information in the SCoP.\n/// @param Parallel           If this loop should be marked parallel in\n///                           the Annotator.\n/// @param UseGuard           Create a guard in front of the header to check if\n///                           the loop is executed at least once, otherwise just\n///                           assume it.\n/// @param LoopVectDisabled   If the Loop vectorizer should be disabled for this\n///                           loop.\n///\n/// @return Value*    The newly created induction variable for this loop.\nValue *createLoop(Value *LowerBound, Value *UpperBound, Value *Stride,\n                  PollyIRBuilder &Builder, LoopInfo &LI, DominatorTree &DT,\n                  BasicBlock *&ExitBlock, ICmpInst::Predicate Predicate,\n                  ScopAnnotator *Annotator = NULL, bool Parallel = false,\n                  bool UseGuard = true, bool LoopVectDisabled = false);\n\n/// The ParallelLoopGenerator allows to create parallelized loops\n///\n/// To parallelize a loop, we perform the following steps:\n///   o  Generate a subfunction which will hold the loop body.\n///   o  Create a struct to hold all outer values needed in the loop body.\n///   o  Create calls to a runtime library to achieve the actual parallelism.\n///      These calls will spawn and join threads, define how the work (here the\n///      iterations) are distributed between them and make sure each has access\n///      to the struct holding all needed values.\n///\n/// At the moment we support only one parallel runtime, OpenMP.\n///\n/// If we parallelize the outer loop of the following loop nest,\n///\n///   S0;\n///   for (int i = 0; i < N; i++)\n///     for (int j = 0; j < M; j++)\n///       S1(i, j);\n///   S2;\n///\n/// we will generate the following code (with different runtime function names):\n///\n///   S0;\n///   auto *values = storeValuesIntoStruct();\n///   // Execute subfunction with multiple threads\n///   spawn_threads(subfunction, values);\n///   join_threads();\n///   S2;\n///\n///  // This function is executed in parallel by different threads\n///   void subfunction(values) {\n///     while (auto *WorkItem = getWorkItem()) {\n///       int LB = WorkItem.begin();\n///       int UB = WorkItem.end();\n///       for (int i = LB; i < UB; i++)\n///         for (int j = 0; j < M; j++)\n///           S1(i, j);\n///     }\n///     cleanup_thread();\n///   }\nclass ParallelLoopGenerator {\npublic:\n  /// Create a parallel loop generator for the current function.\n  ParallelLoopGenerator(PollyIRBuilder &Builder, LoopInfo &LI,\n                        DominatorTree &DT, const DataLayout &DL)\n      : Builder(Builder), LI(LI), DT(DT),\n        LongType(\n            Type::getIntNTy(Builder.getContext(), DL.getPointerSizeInBits())),\n        M(Builder.GetInsertBlock()->getParent()->getParent()) {}\n\n  virtual ~ParallelLoopGenerator() {}\n\n  /// Create a parallel loop.\n  ///\n  /// This function is the main function to automatically generate a parallel\n  /// loop with all its components.\n  ///\n  /// @param LB        The lower bound for the loop we parallelize.\n  /// @param UB        The upper bound for the loop we parallelize.\n  /// @param Stride    The stride of the loop we parallelize.\n  /// @param Values    A set of LLVM-IR Values that should be available in\n  ///                  the new loop body.\n  /// @param VMap      A map to allow outside access to the new versions of\n  ///                  the values in @p Values.\n  /// @param LoopBody  A pointer to an iterator that is set to point to the\n  ///                  body of the created loop. It should be used to insert\n  ///                  instructions that form the actual loop body.\n  ///\n  /// @return The newly created induction variable for this loop.\n  Value *createParallelLoop(Value *LB, Value *UB, Value *Stride,\n                            SetVector<Value *> &Values, ValueMapT &VMap,\n                            BasicBlock::iterator *LoopBody);\n\nprotected:\n  /// The IR builder we use to create instructions.\n  PollyIRBuilder &Builder;\n\n  /// The loop info of the current function we need to update.\n  LoopInfo &LI;\n\n  /// The dominance tree of the current function we need to update.\n  DominatorTree &DT;\n\n  /// The type of a \"long\" on this hardware used for backend calls.\n  Type *LongType;\n\n  /// The current module\n  Module *M;\n\npublic:\n  /// Create a struct for all @p Values and store them in there.\n  ///\n  /// @param Values The values which should be stored in the struct.\n  ///\n  /// @return The created struct.\n  AllocaInst *storeValuesIntoStruct(SetVector<Value *> &Values);\n\n  /// Extract all values from the @p Struct and construct the mapping.\n  ///\n  /// @param Values The values which were stored in the struct.\n  /// @param Struct The struct holding all the values in @p Values.\n  /// @param VMap   A map to associate every element of @p Values with the\n  ///               new llvm value loaded from the @p Struct.\n  void extractValuesFromStruct(SetVector<Value *> Values, Type *Ty,\n                               Value *Struct, ValueMapT &VMap);\n\n  /// Create the definition of the parallel subfunction.\n  ///\n  /// @return A pointer to the subfunction.\n  Function *createSubFnDefinition();\n\n  /// Create the runtime library calls for spawn and join of the worker threads.\n  /// Additionally, places a call to the specified subfunction.\n  ///\n  /// @param SubFn      The subfunction which holds the loop body.\n  /// @param SubFnParam The parameter for the subfunction (basically the struct\n  ///                   filled with the outside values).\n  /// @param LB         The lower bound for the loop we parallelize.\n  /// @param UB         The upper bound for the loop we parallelize.\n  /// @param Stride     The stride of the loop we parallelize.\n  virtual void deployParallelExecution(Function *SubFn, Value *SubFnParam,\n                                       Value *LB, Value *UB, Value *Stride) = 0;\n\n  /// Prepare the definition of the parallel subfunction.\n  /// Creates the argument list and names them (as well as the subfunction).\n  ///\n  /// @param F A pointer to the (parallel) subfunction's parent function.\n  ///\n  /// @return The pointer to the (parallel) subfunction.\n  virtual Function *prepareSubFnDefinition(Function *F) const = 0;\n\n  /// Create the parallel subfunction.\n  ///\n  /// @param Stride The induction variable increment.\n  /// @param Struct A struct holding all values in @p Values.\n  /// @param Values A set of LLVM-IR Values that should be available in\n  ///               the new loop body.\n  /// @param VMap   A map to allow outside access to the new versions of\n  ///               the values in @p Values.\n  /// @param SubFn  The newly created subfunction is returned here.\n  ///\n  /// @return The newly created induction variable.\n  virtual std::tuple<Value *, Function *>\n  createSubFn(Value *Stride, AllocaInst *Struct, SetVector<Value *> UsedValues,\n              ValueMapT &VMap) = 0;\n};\n} // end namespace polly\n#endif\n"}, "7": {"id": 7, "path": "/home/vsts/work/1/llvm-project/polly/include/polly/CodeGen/LoopGeneratorsKMP.h", "content": "//===- LoopGeneratorsKMP.h - IR helper to create loops ----------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file contains functions to create scalar and OpenMP parallel loops\n// as LLVM-IR.\n//\n//===----------------------------------------------------------------------===//\n#ifndef POLLY_LOOP_GENERATORS_KMP_H\n#define POLLY_LOOP_GENERATORS_KMP_H\n\n#include \"polly/CodeGen/IRBuilder.h\"\n#include \"polly/CodeGen/LoopGenerators.h\"\n#include \"polly/Support/ScopHelper.h\"\n#include \"llvm/ADT/SetVector.h\"\n\nnamespace polly {\nusing llvm::GlobalValue;\nusing llvm::GlobalVariable;\n\n/// This ParallelLoopGenerator subclass handles the generation of parallelized\n/// code, utilizing the LLVM OpenMP library.\nclass ParallelLoopGeneratorKMP : public ParallelLoopGenerator {\npublic:\n  /// Create a parallel loop generator for the current function.\n  ParallelLoopGeneratorKMP(PollyIRBuilder &Builder, LoopInfo &LI,\n                           DominatorTree &DT, const DataLayout &DL)\n      : ParallelLoopGenerator(Builder, LI, DT, DL) {\n    SourceLocationInfo = createSourceLocation();\n  }\n\nprotected:\n  /// The source location struct of this loop.\n  /// ident_t = type { i32, i32, i32, i32, i8* }\n  GlobalValue *SourceLocationInfo;\n\n  /// Convert the combination of given chunk size and scheduling type (which\n  /// might have been set via the command line) into the corresponding\n  /// scheduling type. This may result (e.g.) in a 'change' from\n  /// \"static chunked\" scheduling to \"static non-chunked\" (regarding the\n  /// provided and returned scheduling types).\n  ///\n  /// @param ChunkSize    The chunk size, set via command line or its default.\n  /// @param Scheduling   The scheduling, set via command line or its default.\n  ///\n  /// @return The corresponding OMPGeneralSchedulingType.\n  OMPGeneralSchedulingType\n  getSchedType(int ChunkSize, OMPGeneralSchedulingType Scheduling) const;\n\n  /// Returns True if 'LongType' is 64bit wide, otherwise: False.\n  bool is64BitArch();\n\npublic:\n  // The functions below may be used if one does not want to generate a\n  // specific OpenMP parallel loop, but generate individual parts of it\n  // (e.g. the subfunction definition).\n\n  /// Create a runtime library call to spawn the worker threads.\n  ///\n  /// @param SubFn      The subfunction which holds the loop body.\n  /// @param SubFnParam The parameter for the subfunction (basically the struct\n  ///                   filled with the outside values).\n  /// @param LB         The lower bound for the loop we parallelize.\n  /// @param UB         The upper bound for the loop we parallelize.\n  /// @param Stride     The stride of the loop we parallelize.\n  void createCallSpawnThreads(Value *SubFn, Value *SubFnParam, Value *LB,\n                              Value *UB, Value *Stride);\n\n  void deployParallelExecution(Function *SubFn, Value *SubFnParam, Value *LB,\n                               Value *UB, Value *Stride) override;\n\n  virtual Function *prepareSubFnDefinition(Function *F) const override;\n\n  std::tuple<Value *, Function *> createSubFn(Value *Stride, AllocaInst *Struct,\n                                              SetVector<Value *> UsedValues,\n                                              ValueMapT &VMap) override;\n\n  /// Create a runtime library call to get the current global thread number.\n  ///\n  /// @return A Value ref which holds the current global thread number.\n  Value *createCallGlobalThreadNum();\n\n  /// Create a runtime library call to request a number of threads.\n  /// Which will be used in the next OpenMP section (by the next fork).\n  ///\n  /// @param GlobalThreadID   The global thread ID.\n  /// @param NumThreads       The number of threads to use.\n  void createCallPushNumThreads(Value *GlobalThreadID, Value *NumThreads);\n\n  /// Create a runtime library call to prepare the OpenMP runtime.\n  /// For dynamically scheduled loops, saving the loop arguments.\n  ///\n  /// @param GlobalThreadID   The global thread ID.\n  /// @param LB               The loop's lower bound.\n  /// @param UB               The loop's upper bound.\n  /// @param Inc              The loop increment.\n  /// @param ChunkSize        The chunk size of the parallel loop.\n  void createCallDispatchInit(Value *GlobalThreadID, Value *LB, Value *UB,\n                              Value *Inc, Value *ChunkSize);\n\n  /// Create a runtime library call to retrieve the next (dynamically)\n  /// allocated chunk of work for this thread.\n  ///\n  /// @param GlobalThreadID   The global thread ID.\n  /// @param IsLastPtr        Pointer to a flag, which is set to 1 if this is\n  ///                         the last chunk of work, or 0 otherwise.\n  /// @param LBPtr            Pointer to the lower bound for the next chunk.\n  /// @param UBPtr            Pointer to the upper bound for the next chunk.\n  /// @param StridePtr        Pointer to the stride for the next chunk.\n  ///\n  /// @return A Value which holds 1 if there is work to be done, 0 otherwise.\n  Value *createCallDispatchNext(Value *GlobalThreadID, Value *IsLastPtr,\n                                Value *LBPtr, Value *UBPtr, Value *StridePtr);\n\n  /// Create a runtime library call to prepare the OpenMP runtime.\n  /// For statically scheduled loops, saving the loop arguments.\n  ///\n  /// @param GlobalThreadID   The global thread ID.\n  /// @param IsLastPtr        Pointer to a flag, which is set to 1 if this is\n  ///                         the last chunk of work, or 0 otherwise.\n  /// @param LBPtr            Pointer to the lower bound for the next chunk.\n  /// @param UBPtr            Pointer to the upper bound for the next chunk.\n  /// @param StridePtr        Pointer to the stride for the next chunk.\n  /// @param ChunkSize        The chunk size of the parallel loop.\n  void createCallStaticInit(Value *GlobalThreadID, Value *IsLastPtr,\n                            Value *LBPtr, Value *UBPtr, Value *StridePtr,\n                            Value *ChunkSize);\n\n  /// Create a runtime library call to mark the end of\n  /// a statically scheduled loop.\n  ///\n  /// @param GlobalThreadID   The global thread ID.\n  void createCallStaticFini(Value *GlobalThreadID);\n\n  /// Create the current source location.\n  ///\n  /// TODO: Generates only(!) dummy values.\n  GlobalVariable *createSourceLocation();\n};\n} // end namespace polly\n#endif\n"}, "8": {"id": 8, "path": "/home/vsts/work/1/llvm-project/polly/include/polly/Support/ScopHelper.h", "content": "//===------ Support/ScopHelper.h -- Some Helper Functions for Scop. -------===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// Small functions that help with LLVM-IR.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef POLLY_SUPPORT_IRHELPER_H\n#define POLLY_SUPPORT_IRHELPER_H\n\n#include \"llvm/ADT/SetVector.h\"\n#include \"llvm/IR/Instructions.h\"\n#include \"llvm/IR/IntrinsicInst.h\"\n#include \"llvm/IR/ValueHandle.h\"\n#include \"isl/isl-noexceptions.h\"\n\nnamespace llvm {\nclass LoopInfo;\nclass Loop;\nclass ScalarEvolution;\nclass SCEV;\nclass Region;\nclass Pass;\nclass DominatorTree;\nclass RegionInfo;\nclass RegionNode;\n} // namespace llvm\n\nnamespace polly {\nclass Scop;\nclass ScopStmt;\n\n/// Enumeration of assumptions Polly can take.\nenum AssumptionKind {\n  ALIASING,\n  INBOUNDS,\n  WRAPPING,\n  UNSIGNED,\n  PROFITABLE,\n  ERRORBLOCK,\n  COMPLEXITY,\n  INFINITELOOP,\n  INVARIANTLOAD,\n  DELINEARIZATION,\n};\n\n/// Enum to distinguish between assumptions and restrictions.\nenum AssumptionSign { AS_ASSUMPTION, AS_RESTRICTION };\n\n/// Helper struct to remember assumptions.\nstruct Assumption {\n  /// The kind of the assumption (e.g., WRAPPING).\n  AssumptionKind Kind;\n\n  /// Flag to distinguish assumptions and restrictions.\n  AssumptionSign Sign;\n\n  /// The valid/invalid context if this is an assumption/restriction.\n  isl::set Set;\n\n  /// The location that caused this assumption.\n  llvm::DebugLoc Loc;\n\n  /// An optional block whose domain can simplify the assumption.\n  llvm::BasicBlock *BB;\n\n  // Whether the assumption must be checked at runtime.\n  bool RequiresRTC;\n};\n\nusing RecordedAssumptionsTy = llvm::SmallVector<Assumption, 8>;\n\n/// Record an assumption for later addition to the assumed context.\n///\n/// This function will add the assumption to the RecordedAssumptions. This\n/// collection will be added (@see addAssumption) to the assumed context once\n/// all paramaters are known and the context is fully built.\n///\n/// @param RecordedAssumption container which keeps all recorded assumptions.\n/// @param Kind The assumption kind describing the underlying cause.\n/// @param Set  The relations between parameters that are assumed to hold.\n/// @param Loc  The location in the source that caused this assumption.\n/// @param Sign Enum to indicate if the assumptions in @p Set are positive\n///             (needed/assumptions) or negative (invalid/restrictions).\n/// @param BB   The block in which this assumption was taken. If it is\n///             set, the domain of that block will be used to simplify the\n///             actual assumption in @p Set once it is added. This is useful\n///             if the assumption was created prior to the domain.\n/// @param RTC  Does the assumption require a runtime check?\nvoid recordAssumption(RecordedAssumptionsTy *RecordedAssumptions,\n                      AssumptionKind Kind, isl::set Set, llvm::DebugLoc Loc,\n                      AssumptionSign Sign, llvm::BasicBlock *BB = nullptr,\n                      bool RTC = true);\n\n/// Type to remap values.\nusing ValueMapT = llvm::DenseMap<llvm::AssertingVH<llvm::Value>,\n                                 llvm::AssertingVH<llvm::Value>>;\n\n/// Type for a set of invariant loads.\nusing InvariantLoadsSetTy = llvm::SetVector<llvm::AssertingVH<llvm::LoadInst>>;\n\n/// Set type for parameters.\nusing ParameterSetTy = llvm::SetVector<const llvm::SCEV *>;\n\n/// Set of loops (used to remember loops in non-affine subregions).\nusing BoxedLoopsSetTy = llvm::SetVector<const llvm::Loop *>;\n\n/// Utility proxy to wrap the common members of LoadInst and StoreInst.\n///\n/// This works like the LLVM utility class CallSite, ie. it forwards all calls\n/// to either a LoadInst, StoreInst, MemIntrinsic or MemTransferInst.\n/// It is similar to LLVM's utility classes IntrinsicInst, MemIntrinsic,\n/// MemTransferInst, etc. in that it offers a common interface, but does not act\n/// as a fake base class.\n/// It is similar to StringRef and ArrayRef in that it holds a pointer to the\n/// referenced object and should be passed by-value as it is small enough.\n///\n/// This proxy can either represent a LoadInst instance, a StoreInst instance,\n/// a MemIntrinsic instance (memset, memmove, memcpy), a CallInst instance or a\n/// nullptr (only creatable using the default constructor); never an Instruction\n/// that is neither of the above mentioned. When representing a nullptr, only\n/// the following methods are defined:\n/// isNull(), isInstruction(), isLoad(), isStore(), ..., isMemTransferInst(),\n/// operator bool(), operator!()\n///\n/// The functions isa, cast, cast_or_null, dyn_cast are modeled te resemble\n/// those from llvm/Support/Casting.h. Partial template function specialization\n/// is currently not supported in C++ such that those cannot be used directly.\n/// (llvm::isa could, but then llvm:cast etc. would not have the expected\n/// behavior)\nclass MemAccInst {\nprivate:\n  llvm::Instruction *I;\n\npublic:\n  MemAccInst() : I(nullptr) {}\n  MemAccInst(const MemAccInst &Inst) : I(Inst.I) {}\n  /* implicit */ MemAccInst(llvm::LoadInst &LI) : I(&LI) {}\n  /* implicit */ MemAccInst(llvm::LoadInst *LI) : I(LI) {}\n  /* implicit */ MemAccInst(llvm::StoreInst &SI) : I(&SI) {}\n  /* implicit */ MemAccInst(llvm::StoreInst *SI) : I(SI) {}\n  /* implicit */ MemAccInst(llvm::MemIntrinsic *MI) : I(MI) {}\n  /* implicit */ MemAccInst(llvm::CallInst *CI) : I(CI) {}\n  explicit MemAccInst(llvm::Instruction &I) : I(&I) { assert(isa(I)); }\n  explicit MemAccInst(llvm::Instruction *I) : I(I) { assert(isa(I)); }\n\n  static bool isa(const llvm::Value &V) {\n    return llvm::isa<llvm::LoadInst>(V) || llvm::isa<llvm::StoreInst>(V) ||\n           llvm::isa<llvm::CallInst>(V) || llvm::isa<llvm::MemIntrinsic>(V);\n  }\n  static bool isa(const llvm::Value *V) {\n    return llvm::isa<llvm::LoadInst>(V) || llvm::isa<llvm::StoreInst>(V) ||\n           llvm::isa<llvm::CallInst>(V) || llvm::isa<llvm::MemIntrinsic>(V);\n  }\n  static MemAccInst cast(llvm::Value &V) {\n    return MemAccInst(llvm::cast<llvm::Instruction>(V));\n  }\n  static MemAccInst cast(llvm::Value *V) {\n    return MemAccInst(llvm::cast<llvm::Instruction>(V));\n  }\n  static MemAccInst cast_or_null(llvm::Value &V) {\n    return MemAccInst(llvm::cast<llvm::Instruction>(V));\n  }\n  static MemAccInst cast_or_null(llvm::Value *V) {\n    if (!V)\n      return MemAccInst();\n    return MemAccInst(llvm::cast<llvm::Instruction>(V));\n  }\n  static MemAccInst dyn_cast(llvm::Value &V) {\n    if (isa(V))\n      return MemAccInst(llvm::cast<llvm::Instruction>(V));\n    return MemAccInst();\n  }\n  static MemAccInst dyn_cast(llvm::Value *V) {\n    assert(V);\n    if (isa(V))\n      return MemAccInst(llvm::cast<llvm::Instruction>(V));\n    return MemAccInst();\n  }\n\n  MemAccInst &operator=(const MemAccInst &Inst) {\n    I = Inst.I;\n    return *this;\n  }\n  MemAccInst &operator=(llvm::LoadInst &LI) {\n    I = &LI;\n    return *this;\n  }\n  MemAccInst &operator=(llvm::LoadInst *LI) {\n    I = LI;\n    return *this;\n  }\n  MemAccInst &operator=(llvm::StoreInst &SI) {\n    I = &SI;\n    return *this;\n  }\n  MemAccInst &operator=(llvm::StoreInst *SI) {\n    I = SI;\n    return *this;\n  }\n  MemAccInst &operator=(llvm::MemIntrinsic &MI) {\n    I = &MI;\n    return *this;\n  }\n  MemAccInst &operator=(llvm::MemIntrinsic *MI) {\n    I = MI;\n    return *this;\n  }\n  MemAccInst &operator=(llvm::CallInst &CI) {\n    I = &CI;\n    return *this;\n  }\n  MemAccInst &operator=(llvm::CallInst *CI) {\n    I = CI;\n    return *this;\n  }\n\n  llvm::Instruction *get() const {\n    assert(I && \"Unexpected nullptr!\");\n    return I;\n  }\n  operator llvm::Instruction *() const { return asInstruction(); }\n  llvm::Instruction *operator->() const { return get(); }\n\n  explicit operator bool() const { return isInstruction(); }\n  bool operator!() const { return isNull(); }\n\n  llvm::Value *getValueOperand() const {\n    if (isLoad())\n      return asLoad();\n    if (isStore())\n      return asStore()->getValueOperand();\n    if (isMemIntrinsic())\n      return nullptr;\n    if (isCallInst())\n      return nullptr;\n    llvm_unreachable(\"Operation not supported on nullptr\");\n  }\n  llvm::Value *getPointerOperand() const {\n    if (isLoad())\n      return asLoad()->getPointerOperand();\n    if (isStore())\n      return asStore()->getPointerOperand();\n    if (isMemIntrinsic())\n      return asMemIntrinsic()->getRawDest();\n    if (isCallInst())\n      return nullptr;\n    llvm_unreachable(\"Operation not supported on nullptr\");\n  }\n\n  unsigned getAlignment() const {\n    if (isLoad())\n      return asLoad()->getAlignment();\n    if (isStore())\n      return asStore()->getAlignment();\n    if (isMemTransferInst())\n      return std::min(asMemTransferInst()->getDestAlignment(),\n                      asMemTransferInst()->getSourceAlignment());\n    if (isMemIntrinsic())\n      return asMemIntrinsic()->getDestAlignment();\n    if (isCallInst())\n      return 0;\n    llvm_unreachable(\"Operation not supported on nullptr\");\n  }\n  bool isVolatile() const {\n    if (isLoad())\n      return asLoad()->isVolatile();\n    if (isStore())\n      return asStore()->isVolatile();\n    if (isMemIntrinsic())\n      return asMemIntrinsic()->isVolatile();\n    if (isCallInst())\n      return false;\n    llvm_unreachable(\"Operation not supported on nullptr\");\n  }\n  bool isSimple() const {\n    if (isLoad())\n      return asLoad()->isSimple();\n    if (isStore())\n      return asStore()->isSimple();\n    if (isMemIntrinsic())\n      return !asMemIntrinsic()->isVolatile();\n    if (isCallInst())\n      return true;\n    llvm_unreachable(\"Operation not supported on nullptr\");\n  }\n  llvm::AtomicOrdering getOrdering() const {\n    if (isLoad())\n      return asLoad()->getOrdering();\n    if (isStore())\n      return asStore()->getOrdering();\n    if (isMemIntrinsic())\n      return llvm::AtomicOrdering::NotAtomic;\n    if (isCallInst())\n      return llvm::AtomicOrdering::NotAtomic;\n    llvm_unreachable(\"Operation not supported on nullptr\");\n  }\n  bool isUnordered() const {\n    if (isLoad())\n      return asLoad()->isUnordered();\n    if (isStore())\n      return asStore()->isUnordered();\n    // Copied from the Load/Store implementation of isUnordered:\n    if (isMemIntrinsic())\n      return !asMemIntrinsic()->isVolatile();\n    if (isCallInst())\n      return true;\n    llvm_unreachable(\"Operation not supported on nullptr\");\n  }\n\n  bool isNull() const { return !I; }\n  bool isInstruction() const { return I; }\n\n  llvm::Instruction *asInstruction() const { return I; }\n\nprivate:\n  bool isLoad() const { return I && llvm::isa<llvm::LoadInst>(I); }\n  bool isStore() const { return I && llvm::isa<llvm::StoreInst>(I); }\n  bool isCallInst() const { return I && llvm::isa<llvm::CallInst>(I); }\n  bool isMemIntrinsic() const { return I && llvm::isa<llvm::MemIntrinsic>(I); }\n  bool isMemSetInst() const { return I && llvm::isa<llvm::MemSetInst>(I); }\n  bool isMemTransferInst() const {\n    return I && llvm::isa<llvm::MemTransferInst>(I);\n  }\n\n  llvm::LoadInst *asLoad() const { return llvm::cast<llvm::LoadInst>(I); }\n  llvm::StoreInst *asStore() const { return llvm::cast<llvm::StoreInst>(I); }\n  llvm::CallInst *asCallInst() const { return llvm::cast<llvm::CallInst>(I); }\n  llvm::MemIntrinsic *asMemIntrinsic() const {\n    return llvm::cast<llvm::MemIntrinsic>(I);\n  }\n  llvm::MemSetInst *asMemSetInst() const {\n    return llvm::cast<llvm::MemSetInst>(I);\n  }\n  llvm::MemTransferInst *asMemTransferInst() const {\n    return llvm::cast<llvm::MemTransferInst>(I);\n  }\n};\n} // namespace polly\n\nnamespace llvm {\n/// Specialize simplify_type for MemAccInst to enable dyn_cast and cast\n///        from a MemAccInst object.\ntemplate <> struct simplify_type<polly::MemAccInst> {\n  typedef Instruction *SimpleType;\n  static SimpleType getSimplifiedValue(polly::MemAccInst &I) {\n    return I.asInstruction();\n  }\n};\n} // namespace llvm\n\nnamespace polly {\n\n/// Simplify the region to have a single unconditional entry edge and a\n/// single exit edge.\n///\n/// Although this function allows DT and RI to be null, regions only work\n/// properly if the DominatorTree (for Region::contains) and RegionInfo are kept\n/// up-to-date.\n///\n/// @param R  The region to be simplified\n/// @param DT DominatorTree to be updated.\n/// @param LI LoopInfo to be updated.\n/// @param RI RegionInfo to be updated.\nvoid simplifyRegion(llvm::Region *R, llvm::DominatorTree *DT,\n                    llvm::LoopInfo *LI, llvm::RegionInfo *RI);\n\n/// Split the entry block of a function to store the newly inserted\n///        allocations outside of all Scops.\n///\n/// @param EntryBlock The entry block of the current function.\n/// @param P          The pass that currently running.\n///\nvoid splitEntryBlockForAlloca(llvm::BasicBlock *EntryBlock, llvm::Pass *P);\n\n/// Split the entry block of a function to store the newly inserted\n///        allocations outside of all Scops.\n///\n/// @param DT DominatorTree to be updated.\n/// @param LI LoopInfo to be updated.\n/// @param RI RegionInfo to be updated.\nvoid splitEntryBlockForAlloca(llvm::BasicBlock *EntryBlock,\n                              llvm::DominatorTree *DT, llvm::LoopInfo *LI,\n                              llvm::RegionInfo *RI);\n\n/// Wrapper for SCEVExpander extended to all Polly features.\n///\n/// This wrapper will internally call the SCEVExpander but also makes sure that\n/// all additional features not represented in SCEV (e.g., SDiv/SRem are not\n/// black boxes but can be part of the function) will be expanded correctly.\n///\n/// The parameters are the same as for the creation of a SCEVExpander as well\n/// as the call to SCEVExpander::expandCodeFor:\n///\n/// @param S     The current Scop.\n/// @param SE    The Scalar Evolution pass.\n/// @param DL    The module data layout.\n/// @param Name  The suffix added to the new instruction names.\n/// @param E     The expression for which code is actually generated.\n/// @param Ty    The type of the resulting code.\n/// @param IP    The insertion point for the new code.\n/// @param VMap  A remapping of values used in @p E.\n/// @param RTCBB The last block of the RTC. Used to insert loop-invariant\n///              instructions in rare cases.\nllvm::Value *expandCodeFor(Scop &S, llvm::ScalarEvolution &SE,\n                           const llvm::DataLayout &DL, const char *Name,\n                           const llvm::SCEV *E, llvm::Type *Ty,\n                           llvm::Instruction *IP, ValueMapT *VMap,\n                           llvm::BasicBlock *RTCBB);\n\n/// Check if the block is a error block.\n///\n/// A error block is currently any block that fulfills at least one of\n/// the following conditions:\n///\n///  - It is terminated by an unreachable instruction\n///  - It contains a call to a non-pure function that is not immediately\n///    dominated by a loop header and that does not dominate the region exit.\n///    This is a heuristic to pick only error blocks that are conditionally\n///    executed and can be assumed to be not executed at all without the domains\n///    being available.\n///\n/// @param BB The block to check.\n/// @param R  The analyzed region.\n/// @param LI The loop info analysis.\n/// @param DT The dominator tree of the function.\n///\n/// @return True if the block is a error block, false otherwise.\nbool isErrorBlock(llvm::BasicBlock &BB, const llvm::Region &R,\n                  llvm::LoopInfo &LI, const llvm::DominatorTree &DT);\n\n/// Return the condition for the terminator @p TI.\n///\n/// For unconditional branches the \"i1 true\" condition will be returned.\n///\n/// @param TI The terminator to get the condition from.\n///\n/// @return The condition of @p TI and nullptr if none could be extracted.\nllvm::Value *getConditionFromTerminator(llvm::Instruction *TI);\n\n/// Get the smallest loop that contains @p S but is not in @p S.\nllvm::Loop *getLoopSurroundingScop(Scop &S, llvm::LoopInfo &LI);\n\n/// Get the number of blocks in @p L.\n///\n/// The number of blocks in a loop are the number of basic blocks actually\n/// belonging to the loop, as well as all single basic blocks that the loop\n/// exits to and which terminate in an unreachable instruction. We do not\n/// allow such basic blocks in the exit of a scop, hence they belong to the\n/// scop and represent run-time conditions which we want to model and\n/// subsequently speculate away.\n///\n/// @see getRegionNodeLoop for additional details.\nunsigned getNumBlocksInLoop(llvm::Loop *L);\n\n/// Get the number of blocks in @p RN.\nunsigned getNumBlocksInRegionNode(llvm::RegionNode *RN);\n\n/// Return the smallest loop surrounding @p RN.\nllvm::Loop *getRegionNodeLoop(llvm::RegionNode *RN, llvm::LoopInfo &LI);\n\n/// Check if @p LInst can be hoisted in @p R.\n///\n/// @param LInst The load to check.\n/// @param R     The analyzed region.\n/// @param LI    The loop info.\n/// @param SE    The scalar evolution analysis.\n/// @param DT    The dominator tree of the function.\n/// @param KnownInvariantLoads The invariant load set.\n///\n/// @return True if @p LInst can be hoisted in @p R.\nbool isHoistableLoad(llvm::LoadInst *LInst, llvm::Region &R, llvm::LoopInfo &LI,\n                     llvm::ScalarEvolution &SE, const llvm::DominatorTree &DT,\n                     const InvariantLoadsSetTy &KnownInvariantLoads);\n\n/// Return true iff @p V is an intrinsic that we ignore during code\n///        generation.\nbool isIgnoredIntrinsic(const llvm::Value *V);\n\n/// Check whether a value an be synthesized by the code generator.\n///\n/// Some value will be recalculated only from information that is code generated\n/// from the polyhedral representation. For such instructions we do not need to\n/// ensure that their operands are available during code generation.\n///\n/// @param V The value to check.\n/// @param S The current SCoP.\n/// @param SE The scalar evolution database.\n/// @param Scope Location where the value would by synthesized.\n/// @return If the instruction I can be regenerated from its\n///         scalar evolution representation, return true,\n///         otherwise return false.\nbool canSynthesize(const llvm::Value *V, const Scop &S,\n                   llvm::ScalarEvolution *SE, llvm::Loop *Scope);\n\n/// Return the block in which a value is used.\n///\n/// For normal instructions, this is the instruction's parent block. For PHI\n/// nodes, this is the incoming block of that use, because this is where the\n/// operand must be defined (i.e. its definition dominates this block).\n/// Non-instructions do not use operands at a specific point such that in this\n/// case this function returns nullptr.\nllvm::BasicBlock *getUseBlock(const llvm::Use &U);\n\n// If the loop is nonaffine/boxed, return the first non-boxed surrounding loop\n// for Polly. If the loop is affine, return the loop itself.\n//\n// @param L             Pointer to the Loop object to analyze.\n// @param LI            Reference to the LoopInfo.\n// @param BoxedLoops    Set of Boxed Loops we get from the SCoP.\nllvm::Loop *getFirstNonBoxedLoopFor(llvm::Loop *L, llvm::LoopInfo &LI,\n                                    const BoxedLoopsSetTy &BoxedLoops);\n\n// If the Basic Block belongs to a loop that is nonaffine/boxed, return the\n// first non-boxed surrounding loop for Polly. If the loop is affine, return\n// the loop itself.\n//\n// @param BB            Pointer to the Basic Block to analyze.\n// @param LI            Reference to the LoopInfo.\n// @param BoxedLoops    Set of Boxed Loops we get from the SCoP.\nllvm::Loop *getFirstNonBoxedLoopFor(llvm::BasicBlock *BB, llvm::LoopInfo &LI,\n                                    const BoxedLoopsSetTy &BoxedLoops);\n\n/// Is the given instruction a call to a debug function?\n///\n/// A debug function can be used to insert output in Polly-optimized code which\n/// normally does not allow function calls with side-effects. For instance, a\n/// printf can be inserted to check whether a value still has the expected value\n/// after Polly generated code:\n///\n///     int sum = 0;\n///     for (int i = 0; i < 16; i+=1) {\n///       sum += i;\n///       printf(\"The value of sum at i=%d is %d\\n\", sum, i);\n///     }\nbool isDebugCall(llvm::Instruction *Inst);\n\n/// Does the statement contain a call to a debug function?\n///\n/// Such a statement must not be removed, even if has no side-effects.\nbool hasDebugCall(ScopStmt *Stmt);\n\n/// Find a property value in a LoopID.\n///\n/// Generally, a property MDNode has the format\n///\n///   !{ !\"Name\", value }\n///\n/// In which case the value is returned.\n///\n/// If the property is just\n///\n///   !{ !\"Name\" }\n///\n/// Then `nullptr` is set to mark the property is existing, but does not carry\n/// any value. If the property does not exist, `None` is returned.\nllvm::Optional<llvm::Metadata *> findMetadataOperand(llvm::MDNode *LoopMD,\n                                                     llvm::StringRef Name);\n\n/// Find a boolean property value in a LoopID. The value not being defined is\n/// interpreted as a false value.\nbool getBooleanLoopAttribute(llvm::MDNode *LoopID, llvm::StringRef Name);\n\n/// Find an integers property value in a LoopID.\nllvm::Optional<int> getOptionalIntLoopAttribute(llvm::MDNode *LoopID,\n                                                llvm::StringRef Name);\n\n/// Does the loop's LoopID contain a 'llvm.loop.disable_heuristics' property?\n///\n/// This is equivalent to llvm::hasDisableAllTransformsHint(Loop*), but\n/// including the LoopUtils.h header indirectly also declares llvm::MemoryAccess\n/// which clashes with polly::MemoryAccess. Declaring this alias here avoid\n/// having to include LoopUtils.h in other files.\nbool hasDisableAllTransformsHint(llvm::Loop *L);\nbool hasDisableAllTransformsHint(llvm::MDNode *LoopID);\n\n/// Represent the attributes of a loop.\nstruct BandAttr {\n  /// LoopID which stores the properties of the loop, such as transformations to\n  /// apply and the metadata of followup-loops.\n  ///\n  /// Cannot be used to identify a loop. Two different loops can have the same\n  /// metadata.\n  llvm::MDNode *Metadata = nullptr;\n\n  /// The LoopInfo reference for this loop.\n  ///\n  /// Only loops from the original IR are represented by LoopInfo. Loops that\n  /// were generated by Polly are not tracked by LoopInfo.\n  llvm::Loop *OriginalLoop = nullptr;\n};\n\n/// Get an isl::id representing a loop.\n///\n/// This takes the ownership of the BandAttr and will be free'd when the\n/// returned isl::Id is free'd.\nisl::id getIslLoopAttr(isl::ctx Ctx, BandAttr *Attr);\n\n/// Create an isl::id that identifies an original loop.\n///\n/// Return nullptr if the loop does not need a BandAttr (i.e. has no\n/// properties);\n///\n/// This creates a BandAttr which must be unique per loop and therefore this\n/// must not be called multiple times on the same loop as their id would be\n/// different.\nisl::id createIslLoopAttr(isl::ctx Ctx, llvm::Loop *L);\n\n/// Is @p Id representing a loop?\n///\n/// Such ids contain a polly::BandAttr as its user pointer.\nbool isLoopAttr(const isl::id &Id);\n\n/// Return the BandAttr of a loop's isl::id.\nBandAttr *getLoopAttr(const isl::id &Id);\n\n} // namespace polly\n#endif\n"}, "9": {"id": 9, "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/include/isl/hmap.h", "content": "#include <isl/ctx.h>\n#include <isl/maybe.h>\n#include <isl/printer.h>\n\n#if defined(__cplusplus)\nextern \"C\" {\n#endif\n\n#define ISL_xCAT(A,B) A ## B\n#define ISL_CAT(A,B) ISL_xCAT(A,B)\n#define ISL_xFN(TYPE,NAME) TYPE ## _ ## NAME\n#define ISL_FN(TYPE,NAME) ISL_xFN(TYPE,NAME)\n\nstruct ISL_HMAP;\ntypedef struct ISL_HMAP\tISL_HMAP;\n\n__isl_give ISL_HMAP *ISL_FN(ISL_HMAP,alloc)(isl_ctx *ctx, int min_size);\n__isl_give ISL_HMAP *ISL_FN(ISL_HMAP,copy)(__isl_keep ISL_HMAP *hmap);\n__isl_null ISL_HMAP *ISL_FN(ISL_HMAP,free)(__isl_take ISL_HMAP *hmap);\n\nisl_ctx *ISL_FN(ISL_HMAP,get_ctx)(__isl_keep ISL_HMAP *hmap);\n\n__isl_give ISL_MAYBE(ISL_VAL) ISL_FN(ISL_HMAP,try_get)(\n\t__isl_keep ISL_HMAP *hmap, __isl_keep ISL_KEY *key);\nisl_bool ISL_FN(ISL_HMAP,has)(__isl_keep ISL_HMAP *hmap,\n\t__isl_keep ISL_KEY *key);\n__isl_give ISL_VAL *ISL_FN(ISL_HMAP,get)(__isl_keep ISL_HMAP *hmap,\n\t__isl_take ISL_KEY *key);\n__isl_give ISL_HMAP *ISL_FN(ISL_HMAP,set)(__isl_take ISL_HMAP *hmap,\n\t__isl_take ISL_KEY *key, __isl_take ISL_VAL *val);\n__isl_give ISL_HMAP *ISL_FN(ISL_HMAP,drop)(__isl_take ISL_HMAP *hmap,\n\t__isl_take ISL_KEY *key);\n\nisl_stat ISL_FN(ISL_HMAP,foreach)(__isl_keep ISL_HMAP *hmap,\n\tisl_stat (*fn)(__isl_take ISL_KEY *key, __isl_take ISL_VAL *val,\n\t\tvoid *user),\n\tvoid *user);\n\n__isl_give isl_printer *ISL_FN(isl_printer_print,ISL_HMAP_SUFFIX)(\n\t__isl_take isl_printer *p, __isl_keep ISL_HMAP *hmap);\nvoid ISL_FN(ISL_HMAP,dump)(__isl_keep ISL_HMAP *hmap);\n\n#undef ISL_xCAT\n#undef ISL_CAT\n#undef ISL_KEY\n#undef ISL_VAL\n#undef ISL_xFN\n#undef ISL_FN\n#undef ISL_xHMAP\n#undef ISL_yHMAP\n#undef ISL_HMAP\n\n#if defined(__cplusplus)\n}\n#endif\n"}, "10": {"id": 10, "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/include/isl/isl-noexceptions.h", "content": "/// These are automatically generated checked C++ bindings for isl.\n///\n/// isl is a library for computing with integer sets and maps described by\n/// Presburger formulas. On top of this, isl provides various tools for\n/// polyhedral compilation, ranging from dependence analysis over scheduling\n/// to AST generation.\n\n#ifndef ISL_CPP_CHECKED\n#define ISL_CPP_CHECKED\n\n#include <isl/id.h>\n#include <isl/space.h>\n#include <isl/val.h>\n#include <isl/aff.h>\n#include <isl/set.h>\n#include <isl/id.h>\n#include <isl/map.h>\n#include <isl/vec.h>\n#include <isl/ilp.h>\n#include <isl/union_set.h>\n#include <isl/union_map.h>\n#include <isl/flow.h>\n#include <isl/schedule.h>\n#include <isl/schedule_node.h>\n#include <isl/ast_build.h>\n#include <isl/fixed_box.h>\n#include <isl/constraint.h>\n#include <isl/polynomial.h>\n#include <isl/mat.h>\n#include <isl/fixed_box.h>\n#include <stdio.h>\n#include <stdlib.h>\n\n#include <functional>\n#include <string>\n\nnamespace isl {\ninline namespace noexceptions {\n\n#define ISLPP_STRINGIZE_(X) #X\n#define ISLPP_STRINGIZE(X) ISLPP_STRINGIZE_(X)\n\n#define ISLPP_ASSERT(test, message)                          \\\n  do {                                                       \\\n    if (test)                                                \\\n      break;                                                 \\\n    fputs(\"Assertion \\\"\" #test \"\\\" failed at \" __FILE__      \\\n      \":\" ISLPP_STRINGIZE(__LINE__) \"\\n  \" message \"\\n\",     \\\n      stderr);                                               \\\n    abort();                                                 \\\n  } while (0)\n\nclass boolean {\nprivate:\n  mutable bool checked = false;\n  isl_bool val;\n\n  friend boolean manage(isl_bool val);\n  boolean(isl_bool val): val(val) {}\npublic:\n  boolean()\n      : val(isl_bool_error) {}\n  ~boolean() {\n    // ISLPP_ASSERT(checked, \"IMPLEMENTATION ERROR: Unchecked state\");\n  }\n\n  /* implicit */ boolean(bool val)\n      : val(val ? isl_bool_true : isl_bool_false) {}\n\n  bool is_error() const { checked = true; return val == isl_bool_error; }\n  bool is_false() const { checked = true; return val == isl_bool_false; }\n  bool is_true() const { checked = true; return val == isl_bool_true; }\n\n  operator bool() const {\n    // ISLPP_ASSERT(checked, \"IMPLEMENTATION ERROR: Unchecked error state\");\n    ISLPP_ASSERT(!is_error(), \"IMPLEMENTATION ERROR: Unhandled error state\");\n    return is_true();\n  }\n\n  boolean operator!() const {\n    if (is_error())\n      return *this;\n    return !is_true();\n  }\n};\n\ninline boolean manage(isl_bool val) {\n  return boolean(val);\n}\n\nclass ctx {\n  isl_ctx *ptr;\npublic:\n  /* implicit */ ctx(isl_ctx *ctx)\n      : ptr(ctx) {}\n  isl_ctx *release() {\n    auto tmp = ptr;\n    ptr = nullptr;\n    return tmp;\n  }\n  isl_ctx *get() {\n    return ptr;\n  }\n};\n\n/* Class encapsulating an isl_stat value.\n */\nclass stat {\nprivate:\n\tmutable bool checked = false;\n\tisl_stat val;\n\n\tfriend stat manage(isl_stat val);\npublic:\n\tconstexpr stat(isl_stat val) : val(val) {}\n\tstatic stat ok() {\n\t\treturn stat(isl_stat_ok);\n\t}\n\tstatic stat error() {\n\t\treturn stat(isl_stat_error);\n\t}\n\tstat() : val(isl_stat_error) {}\n\t~stat() {\n\t\t// ISLPP_ASSERT(checked, \"IMPLEMENTATION ERROR: Unchecked state\");\n\t}\n\n\tisl_stat release() {\n\t\tchecked = true;\n\t\treturn val;\n\t}\n\n\tbool is_error() const {\n\t\tchecked = true;\n\t\treturn val == isl_stat_error;\n\t}\n\tbool is_ok() const {\n\t\tchecked = true;\n\t\treturn val == isl_stat_ok;\n\t}\n};\n\n\ninline stat manage(isl_stat val)\n{\n\treturn stat(val);\n}\n\nenum class dim {\n  cst = isl_dim_cst,\n  param = isl_dim_param,\n  in = isl_dim_in,\n  out = isl_dim_out,\n  set = isl_dim_set,\n  div = isl_dim_div,\n  all = isl_dim_all\n};\n\n}\n} // namespace isl\n\nnamespace isl {\n\ninline namespace noexceptions {\n\n// forward declarations\nclass aff;\nclass aff_list;\nclass ast_build;\nclass ast_expr;\nclass ast_expr_list;\nclass ast_node;\nclass ast_node_list;\nclass basic_map;\nclass basic_map_list;\nclass basic_set;\nclass basic_set_list;\nclass constraint;\nclass constraint_list;\nclass fixed_box;\nclass id;\nclass id_list;\nclass id_to_ast_expr;\nclass local_space;\nclass map;\nclass map_list;\nclass mat;\nclass multi_aff;\nclass multi_id;\nclass multi_pw_aff;\nclass multi_union_pw_aff;\nclass multi_val;\nclass point;\nclass pw_aff;\nclass pw_aff_list;\nclass pw_multi_aff;\nclass pw_multi_aff_list;\nclass pw_qpolynomial;\nclass pw_qpolynomial_fold_list;\nclass pw_qpolynomial_list;\nclass qpolynomial;\nclass qpolynomial_list;\nclass schedule;\nclass schedule_constraints;\nclass schedule_node;\nclass set;\nclass set_list;\nclass space;\nclass term;\nclass union_access_info;\nclass union_flow;\nclass union_map;\nclass union_map_list;\nclass union_pw_aff;\nclass union_pw_aff_list;\nclass union_pw_multi_aff;\nclass union_pw_multi_aff_list;\nclass union_pw_qpolynomial;\nclass union_set;\nclass union_set_list;\nclass val;\nclass val_list;\nclass vec;\n\n// declarations for isl::aff\ninline aff manage(__isl_take isl_aff *ptr);\ninline aff manage_copy(__isl_keep isl_aff *ptr);\n\nclass aff {\n  friend inline aff manage(__isl_take isl_aff *ptr);\n  friend inline aff manage_copy(__isl_keep isl_aff *ptr);\n\n  isl_aff *ptr = nullptr;\n\n  inline explicit aff(__isl_take isl_aff *ptr);\n\npublic:\n  inline /* implicit */ aff();\n  inline /* implicit */ aff(const aff &obj);\n  inline /* implicit */ aff(std::nullptr_t);\n  inline explicit aff(ctx ctx, const std::string &str);\n  inline explicit aff(local_space ls, val val);\n  inline explicit aff(local_space ls);\n  inline aff &operator=(aff obj);\n  inline ~aff();\n  inline __isl_give isl_aff *copy() const &;\n  inline __isl_give isl_aff *copy() && = delete;\n  inline __isl_keep isl_aff *get() const;\n  inline __isl_give isl_aff *release();\n  inline bool is_null() const;\n  inline explicit operator bool() const;\n  inline ctx get_ctx() const;\n  inline std::string to_str() const;\n  inline void dump() const;\n\n  inline aff add(aff aff2) const;\n  inline aff add_coefficient_si(isl::dim type, int pos, int v) const;\n  inline aff add_coefficient_val(isl::dim type, int pos, val v) const;\n  inline aff add_constant(val v) const;\n  inline aff add_constant_num_si(int v) const;\n  inline aff add_constant_si(int v) const;\n  inline aff add_dims(isl::dim type, unsigned int n) const;\n  inline aff align_params(space model) const;\n  inline basic_set bind(id id) const;\n  inline aff ceil() const;\n  inline int coefficient_sgn(isl::dim type, int pos) const;\n  inline isl_size dim(isl::dim type) const;\n  inline aff div(aff aff2) const;\n  inline aff drop_dims(isl::dim type, unsigned int first, unsigned int n) const;\n  inline basic_set eq_basic_set(aff aff2) const;\n  inline set eq_set(aff aff2) const;\n  inline val eval(point pnt) const;\n  inline int find_dim_by_name(isl::dim type, const std::string &name) const;\n  inline aff floor() const;\n  inline aff from_range() const;\n  inline basic_set ge_basic_set(aff aff2) const;\n  inline set ge_set(aff aff2) const;\n  inline val get_coefficient_val(isl::dim type, int pos) const;\n  inline val get_constant_val() const;\n  inline val get_denominator_val() const;\n  inline std::string get_dim_name(isl::dim type, unsigned int pos) const;\n  inline aff get_div(int pos) const;\n  inline local_space get_domain_local_space() const;\n  inline space get_domain_space() const;\n  inline uint32_t get_hash() const;\n  inline local_space get_local_space() const;\n  inline space get_space() const;\n  inline aff gist(set context) const;\n  inline aff gist_params(set context) const;\n  inline basic_set gt_basic_set(aff aff2) const;\n  inline set gt_set(aff aff2) const;\n  inline aff insert_dims(isl::dim type, unsigned int first, unsigned int n) const;\n  inline boolean involves_dims(isl::dim type, unsigned int first, unsigned int n) const;\n  inline boolean involves_locals() const;\n  inline boolean is_cst() const;\n  inline boolean is_nan() const;\n  inline basic_set le_basic_set(aff aff2) const;\n  inline set le_set(aff aff2) const;\n  inline basic_set lt_basic_set(aff aff2) const;\n  inline set lt_set(aff aff2) const;\n  inline aff mod(val mod) const;\n  inline aff move_dims(isl::dim dst_type, unsigned int dst_pos, isl::dim src_type, unsigned int src_pos, unsigned int n) const;\n  inline aff mul(aff aff2) const;\n  static inline aff nan_on_domain(local_space ls);\n  static inline aff nan_on_domain_space(space space);\n  inline set ne_set(aff aff2) const;\n  inline aff neg() const;\n  inline basic_set neg_basic_set() const;\n  static inline aff param_on_domain_space_id(space space, id id);\n  inline boolean plain_is_equal(const aff &aff2) const;\n  inline boolean plain_is_zero() const;\n  inline aff project_domain_on_params() const;\n  inline aff pullback(multi_aff ma) const;\n  inline aff pullback_aff(aff aff2) const;\n  inline aff scale(val v) const;\n  inline aff scale_down(val v) const;\n  inline aff scale_down_ui(unsigned int f) const;\n  inline aff set_coefficient_si(isl::dim type, int pos, int v) const;\n  inline aff set_coefficient_val(isl::dim type, int pos, val v) const;\n  inline aff set_constant_si(int v) const;\n  inline aff set_constant_val(val v) const;\n  inline aff set_dim_id(isl::dim type, unsigned int pos, id id) const;\n  inline aff set_tuple_id(isl::dim type, id id) const;\n  inline aff sub(aff aff2) const;\n  inline aff unbind_params_insert_domain(multi_id domain) const;\n  static inline aff val_on_domain_space(space space, val val);\n  static inline aff var_on_domain(local_space ls, isl::dim type, unsigned int pos);\n  inline basic_set zero_basic_set() const;\n  static inline aff zero_on_domain(space space);\n};\n\n// declarations for isl::aff_list\ninline aff_list manage(__isl_take isl_aff_list *ptr);\ninline aff_list manage_copy(__isl_keep isl_aff_list *ptr);\n\nclass aff_list {\n  friend inline aff_list manage(__isl_take isl_aff_list *ptr);\n  friend inline aff_list manage_copy(__isl_keep isl_aff_list *ptr);\n\n  isl_aff_list *ptr = nullptr;\n\n  inline explicit aff_list(__isl_take isl_aff_list *ptr);\n\npublic:\n  inline /* implicit */ aff_list();\n  inline /* implicit */ aff_list(const aff_list &obj);\n  inline /* implicit */ aff_list(std::nullptr_t);\n  inline aff_list &operator=(aff_list obj);\n  inline ~aff_list();\n  inline __isl_give isl_aff_list *copy() const &;\n  inline __isl_give isl_aff_list *copy() && = delete;\n  inline __isl_keep isl_aff_list *get() const;\n  inline __isl_give isl_aff_list *release();\n  inline bool is_null() const;\n  inline explicit operator bool() const;\n  inline ctx get_ctx() const;\n  inline std::string to_str() const;\n  inline void dump() const;\n\n  inline aff_list add(aff el) const;\n  static inline aff_list alloc(ctx ctx, int n);\n  inline aff_list clear() const;\n  inline aff_list concat(aff_list list2) const;\n  inline aff_list drop(unsigned int first, unsigned int n) const;\n  inline stat foreach(const std::function<stat(aff)> &fn) const;\n  static inline aff_list from_aff(aff el);\n  inline aff get_aff(int index) const;\n  inline aff get_at(int index) const;\n  inline aff_list insert(unsigned int pos, aff el) const;\n  inline isl_size n_aff() const;\n  inline aff_list reverse() const;\n  inline aff_list set_aff(int index, aff el) const;\n  inline isl_size size() const;\n  inline aff_list swap(unsigned int pos1, unsigned int pos2) const;\n};\n\n// declarations for isl::ast_build\ninline ast_build manage(__isl_take isl_ast_build *ptr);\ninline ast_build manage_copy(__isl_keep isl_ast_build *ptr);\n\nclass ast_build {\n  friend inline ast_build manage(__isl_take isl_ast_build *ptr);\n  friend inline ast_build manage_copy(__isl_keep isl_ast_build *ptr);\n\n  isl_ast_build *ptr = nullptr;\n\n  inline explicit ast_build(__isl_take isl_ast_build *ptr);\n\npublic:\n  inline /* implicit */ ast_build();\n  inline /* implicit */ ast_build(const ast_build &obj);\n  inline /* implicit */ ast_build(std::nullptr_t);\n  inline explicit ast_build(ctx ctx);\n  inline ast_build &operator=(ast_build obj);\n  inline ~ast_build();\n  inline __isl_give isl_ast_build *copy() const &;\n  inline __isl_give isl_ast_build *copy() && = delete;\n  inline __isl_keep isl_ast_build *get() const;\n  inline __isl_give isl_ast_build *release();\n  inline bool is_null() const;\n  inline explicit operator bool() const;\n  inline ctx get_ctx() const;\n\n  inline ast_expr access_from(multi_pw_aff mpa) const;\n  inline ast_expr access_from(pw_multi_aff pma) const;\n  inline ast_node ast_from_schedule(union_map schedule) const;\n  inline ast_expr call_from(multi_pw_aff mpa) const;\n  inline ast_expr call_from(pw_multi_aff pma) const;\n  inline ast_expr expr_from(pw_aff pa) const;\n  inline ast_expr expr_from(set set) const;\n  static inline ast_build from_context(set set);\n  inline union_map get_schedule() const;\n  inline space get_schedule_space() const;\n  inline ast_node node_from(schedule schedule) const;\n  inline ast_node node_from_schedule_map(union_map schedule) const;\n  inline ast_build restrict(set set) const;\n};\n\n// declarations for isl::ast_expr\ninline ast_expr manage(__isl_take isl_ast_expr *ptr);\ninline ast_expr manage_copy(__isl_keep isl_ast_expr *ptr);\n\nclass ast_expr {\n  friend inline ast_expr manage(__isl_take isl_ast_expr *ptr);\n  friend inline ast_expr manage_copy(__isl_keep isl_ast_expr *ptr);\n\n  isl_ast_expr *ptr = nullptr;\n\n  inline explicit ast_expr(__isl_take isl_ast_expr *ptr);\n\npublic:\n  inline /* implicit */ ast_expr();\n  inline /* implicit */ ast_expr(const ast_expr &obj);\n  inline /* implicit */ ast_expr(std::nullptr_t);\n  inline ast_expr &operator=(ast_expr obj);\n  inline ~ast_expr();\n  inline __isl_give isl_ast_expr *copy() const &;\n  inline __isl_give isl_ast_expr *copy() && = delete;\n  inline __isl_keep isl_ast_expr *get() const;\n  inline __isl_give isl_ast_expr *release();\n  inline bool is_null() const;\n  inline explicit operator bool() const;\n  inline ctx get_ctx() const;\n  inline std::string to_str() const;\n  inline void dump() const;\n\n  inline ast_expr access(ast_expr_list indices) const;\n  inline ast_expr add(ast_expr expr2) const;\n  inline ast_expr address_of() const;\n  inline ast_expr call(ast_expr_list arguments) const;\n  inline ast_expr div(ast_expr expr2) const;\n  inline ast_expr eq(ast_expr expr2) const;\n  static inline ast_expr from_id(id id);\n  static inline ast_expr from_val(val v);\n  inline ast_expr ge(ast_expr expr2) const;\n  inline id get_id() const;\n  inline ast_expr get_op_arg(int pos) const;\n  inline isl_size get_op_n_arg() const;\n  inline val get_val() const;\n  inline ast_expr gt(ast_expr expr2) const;\n  inline id id_get_id() const;\n  inline val int_get_val() const;\n  inline boolean is_equal(const ast_expr &expr2) const;\n  inline ast_expr le(ast_expr expr2) const;\n  inline ast_expr lt(ast_expr expr2) const;\n  inline ast_expr mul(ast_expr expr2) const;\n  inline ast_expr neg() const;\n  inline ast_expr op_get_arg(int pos) const;\n  inline isl_size op_get_n_arg() const;\n  inline ast_expr pdiv_q(ast_expr expr2) const;\n  inline ast_expr pdiv_r(ast_expr expr2) const;\n  inline ast_expr set_op_arg(int pos, ast_expr arg) const;\n  inline ast_expr sub(ast_expr expr2) const;\n  inline ast_expr substitute_ids(id_to_ast_expr id2expr) const;\n  inline std::string to_C_str() const;\n};\n\n// declarations for isl::ast_expr_list\ninline ast_expr_list manage(__isl_take isl_ast_expr_list *ptr);\ninline ast_expr_list manage_copy(__isl_keep isl_ast_expr_list *ptr);\n\nclass ast_expr_list {\n  friend inline ast_expr_list manage(__isl_take isl_ast_expr_list *ptr);\n  friend inline ast_expr_list manage_copy(__isl_keep isl_ast_expr_list *ptr);\n\n  isl_ast_expr_list *ptr = nullptr;\n\n  inline explicit ast_expr_list(__isl_take isl_ast_expr_list *ptr);\n\npublic:\n  inline /* implicit */ ast_expr_list();\n  inline /* implicit */ ast_expr_list(const ast_expr_list &obj);\n  inline /* implicit */ ast_expr_list(std::nullptr_t);\n  inline ast_expr_list &operator=(ast_expr_list obj);\n  inline ~ast_expr_list();\n  inline __isl_give isl_ast_expr_list *copy() const &;\n  inline __isl_give isl_ast_expr_list *copy() && = delete;\n  inline __isl_keep isl_ast_expr_list *get() const;\n  inline __isl_give isl_ast_expr_list *release();\n  inline bool is_null() const;\n  inline explicit operator bool() const;\n  inline ctx get_ctx() const;\n  inline std::string to_str() const;\n  inline void dump() const;\n\n  inline ast_expr_list add(ast_expr el) const;\n  static inline ast_expr_list alloc(ctx ctx, int n);\n  inline ast_expr_list clear() const;\n  inline ast_expr_list concat(ast_expr_list list2) const;\n  inline ast_expr_list drop(unsigned int first, unsigned int n) const;\n  inline stat foreach(const std::function<stat(ast_expr)> &fn) const;\n  static inline ast_expr_list from_ast_expr(ast_expr el);\n  inline ast_expr get_ast_expr(int index) const;\n  inline ast_expr get_at(int index) const;\n  inline ast_expr_list insert(unsigned int pos, ast_expr el) const;\n  inline isl_size n_ast_expr() const;\n  inline ast_expr_list reverse() const;\n  inline ast_expr_list set_ast_expr(int index, ast_expr el) const;\n  inline isl_size size() const;\n  inline ast_expr_list swap(unsigned int pos1, unsigned int pos2) const;\n};\n\n// declarations for isl::ast_node\ninline ast_node manage(__isl_take isl_ast_node *ptr);\ninline ast_node manage_copy(__isl_keep isl_ast_node *ptr);\n\nclass ast_node {\n  friend inline ast_node manage(__isl_take isl_ast_node *ptr);\n  friend inline ast_node manage_copy(__isl_keep isl_ast_node *ptr);\n\n  isl_ast_node *ptr = nullptr;\n\n  inline explicit ast_node(__isl_take isl_ast_node *ptr);\n\npublic:\n  inline /* implicit */ ast_node();\n  inline /* implicit */ ast_node(const ast_node &obj);\n  inline /* implicit */ ast_node(std::nullptr_t);\n  inline ast_node &operator=(ast_node obj);\n  inline ~ast_node();\n  inline __isl_give isl_ast_node *copy() const &;\n  inline __isl_give isl_ast_node *copy() && = delete;\n  inline __isl_keep isl_ast_node *get() const;\n  inline __isl_give isl_ast_node *release();\n  inline bool is_null() const;\n  inline explicit operator bool() const;\n  inline ctx get_ctx() const;\n  inline std::string to_str() const;\n  inline void dump() const;\n\n  static inline ast_node alloc_user(ast_expr expr);\n  inline ast_node_list block_get_children() const;\n  inline ast_node for_get_body() const;\n  inline ast_expr for_get_cond() const;\n  inline ast_expr for_get_inc() const;\n  inline ast_expr for_get_init() const;\n  inline ast_expr for_get_iterator() const;\n  inline boolean for_is_degenerate() const;\n  inline id get_annotation() const;\n  inline ast_expr if_get_cond() const;\n  inline ast_node if_get_else() const;\n  inline ast_node if_get_else_node() const;\n  inline ast_node if_get_then() const;\n  inline ast_node if_get_then_node() const;\n  inline boolean if_has_else() const;\n  inline boolean if_has_else_node() const;\n  inline id mark_get_id() const;\n  inline ast_node mark_get_node() const;\n  inline ast_node set_annotation(id annotation) const;\n  inline std::string to_C_str() const;\n  inline ast_expr user_get_expr() const;\n};\n\n// declarations for isl::ast_node_list\ninline ast_node_list manage(__isl_take isl_ast_node_list *ptr);\ninline ast_node_list manage_copy(__isl_keep isl_ast_node_list *ptr);\n\nclass ast_node_list {\n  friend inline ast_node_list manage(__isl_take isl_ast_node_list *ptr);\n  friend inline ast_node_list manage_copy(__isl_keep isl_ast_node_list *ptr);\n\n  isl_ast_node_list *ptr = nullptr;\n\n  inline explicit ast_node_list(__isl_take isl_ast_node_list *ptr);\n\npublic:\n  inline /* implicit */ ast_node_list();\n  inline /* implicit */ ast_node_list(const ast_node_list &obj);\n  inline /* implicit */ ast_node_list(std::nullptr_t);\n  inline ast_node_list &operator=(ast_node_list obj);\n  inline ~ast_node_list();\n  inline __isl_give isl_ast_node_list *copy() const &;\n  inline __isl_give isl_ast_node_list *copy() && = delete;\n  inline __isl_keep isl_ast_node_list *get() const;\n  inline __isl_give isl_ast_node_list *release();\n  inline bool is_null() const;\n  inline explicit operator bool() const;\n  inline ctx get_ctx() const;\n  inline std::string to_str() const;\n  inline void dump() const;\n\n  inline ast_node_list add(ast_node el) const;\n  static inline ast_node_list alloc(ctx ctx, int n);\n  inline ast_node_list clear() const;\n  inline ast_node_list concat(ast_node_list list2) const;\n  inline ast_node_list drop(unsigned int first, unsigned int n) const;\n  inline stat foreach(const std::function<stat(ast_node)> &fn) const;\n  static inline ast_node_list from_ast_node(ast_node el);\n  inline ast_node get_ast_node(int index) const;\n  inline ast_node get_at(int index) const;\n  inline ast_node_list insert(unsigned int pos, ast_node el) const;\n  inline isl_size n_ast_node() const;\n  inline ast_node_list reverse() const;\n  inline ast_node_list set_ast_node(int index, ast_node el) const;\n  inline isl_size size() const;\n  inline ast_node_list swap(unsigned int pos1, unsigned int pos2) const;\n};\n\n// declarations for isl::basic_map\ninline basic_map manage(__isl_take isl_basic_map *ptr);\ninline basic_map manage_copy(__isl_keep isl_basic_map *ptr);\n\nclass basic_map {\n  friend inline basic_map manage(__isl_take isl_basic_map *ptr);\n  friend inline basic_map manage_copy(__isl_keep isl_basic_map *ptr);\n\n  isl_basic_map *ptr = nullptr;\n\n  inline explicit basic_map(__isl_take isl_basic_map *ptr);\n\npublic:\n  inline /* implicit */ basic_map();\n  inline /* implicit */ basic_map(const basic_map &obj);\n  inline /* implicit */ basic_map(std::nullptr_t);\n  inline explicit basic_map(ctx ctx, const std::string &str);\n  inline basic_map &operator=(basic_map obj);\n  inline ~basic_map();\n  inline __isl_give isl_basic_map *copy() const &;\n  inline __isl_give isl_basic_map *copy() && = delete;\n  inline __isl_keep isl_basic_map *get() const;\n  inline __isl_give isl_basic_map *release();\n  inline bool is_null() const;\n  inline explicit operator bool() const;\n  inline ctx get_ctx() const;\n  inline std::string to_str() const;\n  inline void dump() const;\n\n  inline basic_map add_constraint(constraint constraint) const;\n  inline basic_map add_dims(isl::dim type, unsigned int n) const;\n  inline basic_map affine_hull() const;\n  inline basic_map align_params(space model) const;\n  inline basic_map apply_domain(basic_map bmap2) const;\n  inline basic_map apply_range(basic_map bmap2) const;\n  inline boolean can_curry() const;\n  inline boolean can_uncurry() const;\n  inline boolean can_zip() const;\n  inline basic_map curry() const;\n  inline basic_set deltas() const;\n  inline basic_map deltas_map() const;\n  inline basic_map detect_equalities() const;\n  inline isl_size dim(isl::dim type) const;\n  inline basic_set domain() const;\n  inline basic_map domain_map() const;\n  inline basic_map domain_product(basic_map bmap2) const;\n  inline basic_map drop_constraints_involving_dims(isl::dim type, unsigned int first, unsigned int n) const;\n  inline basic_map drop_constraints_not_involving_dims(isl::dim type, unsigned int first, unsigned int n) const;\n  inline basic_map drop_unused_params() const;\n  inline basic_map eliminate(isl::dim type, unsigned int first, unsigned int n) const;\n  static inline basic_map empty(space space);\n  static inline basic_map equal(space space, unsigned int n_equal);\n  inline mat equalities_matrix(isl::dim c1, isl::dim c2, isl::dim c3, isl::dim c4, isl::dim c5) const;\n  inline basic_map equate(isl::dim type1, int pos1, isl::dim type2, int pos2) const;\n  inline int find_dim_by_name(isl::dim type, const std::string &name) const;\n  inline basic_map fix_si(isl::dim type, unsigned int pos, int value) const;\n  inline basic_map fix_val(isl::dim type, unsigned int pos, val v) const;\n  inline basic_map flat_product(basic_map bmap2) const;\n  inline basic_map flat_range_product(basic_map bmap2) const;\n  inline basic_map flatten() const;\n  inline basic_map flatten_domain() const;\n  inline basic_map flatten_range() const;\n  inline stat foreach_constraint(const std::function<stat(constraint)> &fn) const;\n  static inline basic_map from_aff(aff aff);\n  static inline basic_map from_aff_list(space domain_space, aff_list list);\n  static inline basic_map from_constraint(constraint constraint);\n  static inline basic_map from_domain(basic_set bset);\n  static inline basic_map from_domain_and_range(basic_set domain, basic_set range);\n  static inline basic_map from_multi_aff(multi_aff maff);\n  static inline basic_map from_qpolynomial(qpolynomial qp);\n  static inline basic_map from_range(basic_set bset);\n  inline constraint_list get_constraint_list() const;\n  inline std::string get_dim_name(isl::dim type, unsigned int pos) const;\n  inline aff get_div(int pos) const;\n  inline local_space get_local_space() const;\n  inline space get_space() const;\n  inline std::string get_tuple_name(isl::dim type) const;\n  inline basic_map gist(basic_map context) const;\n  inline basic_map gist_domain(basic_set context) const;\n  inline boolean has_dim_id(isl::dim type, unsigned int pos) const;\n  static inline basic_map identity(space space);\n  inline boolean image_is_bounded() const;\n  inline mat inequalities_matrix(isl::dim c1, isl::dim c2, isl::dim c3, isl::dim c4, isl::dim c5) const;\n  inline basic_map insert_dims(isl::dim type, unsigned int pos, unsigned int n) const;\n  inline basic_map intersect(basic_map bmap2) const;\n  inline basic_map intersect_domain(basic_set bset) const;\n  inline basic_map intersect_range(basic_set bset) const;\n  inline boolean involves_dims(isl::dim type, unsigned int first, unsigned int n) const;\n  inline boolean is_disjoint(const basic_map &bmap2) const;\n  inline boolean is_empty() const;\n  inline boolean is_equal(const basic_map &bmap2) const;\n  inline boolean is_rational() const;\n  inline boolean is_single_valued() const;\n  inline boolean is_strict_subset(const basic_map &bmap2) const;\n  inline boolean is_subset(const basic_map &bmap2) const;\n  inline boolean is_universe() const;\n  static inline basic_map less_at(space space, unsigned int pos);\n  inline map lexmax() const;\n  inline map lexmin() const;\n  inline pw_multi_aff lexmin_pw_multi_aff() const;\n  inline basic_map lower_bound_si(isl::dim type, unsigned int pos, int value) const;\n  static inline basic_map more_at(space space, unsigned int pos);\n  inline basic_map move_dims(isl::dim dst_type, unsigned int dst_pos, isl::dim src_type, unsigned int src_pos, unsigned int n) const;\n  inline isl_size n_constraint() const;\n  static inline basic_map nat_universe(space space);\n  inline basic_map neg() const;\n  inline basic_map order_ge(isl::dim type1, int pos1, isl::dim type2, int pos2) const;\n  inline basic_map order_gt(isl::dim type1, int pos1, isl::dim type2, int pos2) const;\n  inline val plain_get_val_if_fixed(isl::dim type, unsigned int pos) const;\n  inline boolean plain_is_empty() const;\n  inline boolean plain_is_universe() const;\n  inline basic_map preimage_domain_multi_aff(multi_aff ma) const;\n  inline basic_map preimage_range_multi_aff(multi_aff ma) const;\n  inline basic_map product(basic_map bmap2) const;\n  inline basic_map project_out(isl::dim type, unsigned int first, unsigned int n) const;\n  inline basic_set range() const;\n  inline basic_map range_map() const;\n  inline basic_map range_product(basic_map bmap2) const;\n  inline basic_map remove_dims(isl::dim type, unsigned int first, unsigned int n) const;\n  inline basic_map remove_divs() const;\n  inline basic_map remove_divs_involving_dims(isl::dim type, unsigned int first, unsigned int n) const;\n  inline basic_map remove_redundancies() const;\n  inline basic_map reverse() const;\n  inline basic_map sample() const;\n  inline basic_map set_tuple_id(isl::dim type, id id) const;\n  inline basic_map set_tuple_name(isl::dim type, const std::string &s) const;\n  inline basic_map sum(basic_map bmap2) const;\n  inline basic_map uncurry() const;\n  inline map unite(basic_map bmap2) const;\n  static inline basic_map universe(space space);\n  inline basic_map upper_bound_si(isl::dim type, unsigned int pos, int value) const;\n  inline basic_set wrap() const;\n  inline basic_map zip() const;\n};\n\n// declarations for isl::basic_map_list\ninline basic_map_list manage(__isl_take isl_basic_map_list *ptr);\ninline basic_map_list manage_copy(__isl_keep isl_basic_map_list *ptr);\n\nclass basic_map_list {\n  friend inline basic_map_list manage(__isl_take isl_basic_map_list *ptr);\n  friend inline basic_map_list manage_copy(__isl_keep isl_basic_map_list *ptr);\n\n  isl_basic_map_list *ptr = nullptr;\n\n  inline explicit basic_map_list(__isl_take isl_basic_map_list *ptr);\n\npublic:\n  inline /* implicit */ basic_map_list();\n  inline /* implicit */ basic_map_list(const basic_map_list &obj);\n  inline /* implicit */ basic_map_list(std::nullptr_t);\n  inline basic_map_list &operator=(basic_map_list obj);\n  inline ~basic_map_list();\n  inline __isl_give isl_basic_map_list *copy() const &;\n  inline __isl_give isl_basic_map_list *copy() && = delete;\n  inline __isl_keep isl_basic_map_list *get() const;\n  inline __isl_give isl_basic_map_list *release();\n  inline bool is_null() const;\n  inline explicit operator bool() const;\n  inline ctx get_ctx() const;\n  inline std::string to_str() const;\n  inline void dump() const;\n\n  inline basic_map_list add(basic_map el) const;\n  static inline basic_map_list alloc(ctx ctx, int n);\n  inline basic_map_list clear() const;\n  inline basic_map_list concat(basic_map_list list2) const;\n  inline basic_map_list drop(unsigned int first, unsigned int n) const;\n  inline stat foreach(const std::function<stat(basic_map)> &fn) const;\n  static inline basic_map_list from_basic_map(basic_map el);\n  inline basic_map get_at(int index) const;\n  inline basic_map get_basic_map(int index) const;\n  inline basic_map_list insert(unsigned int pos, basic_map el) const;\n  inline isl_size n_basic_map() const;\n  inline basic_map_list reverse() const;\n  inline basic_map_list set_basic_map(int index, basic_map el) const;\n  inline isl_size size() const;\n  inline basic_map_list swap(unsigned int pos1, unsigned int pos2) const;\n};\n\n// declarations for isl::basic_set\ninline basic_set manage(__isl_take isl_basic_set *ptr);\ninline basic_set manage_copy(__isl_keep isl_basic_set *ptr);\n\nclass basic_set {\n  friend inline basic_set manage(__isl_take isl_basic_set *ptr);\n  friend inline basic_set manage_copy(__isl_keep isl_basic_set *ptr);\n\n  isl_basic_set *ptr = nullptr;\n\n  inline explicit basic_set(__isl_take isl_basic_set *ptr);\n\npublic:\n  inline /* implicit */ basic_set();\n  inline /* implicit */ basic_set(const basic_set &obj);\n  inline /* implicit */ basic_set(std::nullptr_t);\n  inline /* implicit */ basic_set(point pnt);\n  inline explicit basic_set(ctx ctx, const std::string &str);\n  inline basic_set &operator=(basic_set obj);\n  inline ~basic_set();\n  inline __isl_give isl_basic_set *copy() const &;\n  inline __isl_give isl_basic_set *copy() && = delete;\n  inline __isl_keep isl_basic_set *get() const;\n  inline __isl_give isl_basic_set *release();\n  inline bool is_null() const;\n  inline explicit operator bool() const;\n  inline ctx get_ctx() const;\n  inline std::string to_str() const;\n  inline void dump() const;\n\n  inline basic_set affine_hull() const;\n  inline basic_set align_params(space model) const;\n  inline basic_set apply(basic_map bmap) const;\n  static inline basic_set box_from_points(point pnt1, point pnt2);\n  inline basic_set coefficients() const;\n  inline basic_set detect_equalities() const;\n  inline isl_size dim(isl::dim type) const;\n  inline val dim_max_val(int pos) const;\n  inline basic_set drop_constraints_involving_dims(isl::dim type, unsigned int first, unsigned int n) const;\n  inline basic_set drop_constraints_not_involving_dims(isl::dim type, unsigned int first, unsigned int n) const;\n  inline basic_set drop_unused_params() const;\n  inline basic_set eliminate(isl::dim type, unsigned int first, unsigned int n) const;\n  static inline basic_set empty(space space);\n  inline mat equalities_matrix(isl::dim c1, isl::dim c2, isl::dim c3, isl::dim c4) const;\n  inline basic_set fix_si(isl::dim type, unsigned int pos, int value) const;\n  inline basic_set fix_val(isl::dim type, unsigned int pos, val v) const;\n  inline basic_set flat_product(basic_set bset2) const;\n  inline basic_set flatten() const;\n  inline stat foreach_bound_pair(isl::dim type, unsigned int pos, const std::function<stat(constraint, constraint, basic_set)> &fn) const;\n  inline stat foreach_constraint(const std::function<stat(constraint)> &fn) const;\n  static inline basic_set from_constraint(constraint constraint);\n  static inline basic_set from_multi_aff(multi_aff ma);\n  inline basic_set from_params() const;\n  inline constraint_list get_constraint_list() const;\n  inline id get_dim_id(isl::dim type, unsigned int pos) const;\n  inline std::string get_dim_name(isl::dim type, unsigned int pos) const;\n  inline aff get_div(int pos) const;\n  inline local_space get_local_space() const;\n  inline space get_space() const;\n  inline std::string get_tuple_name() const;\n  inline basic_set gist(basic_set context) const;\n  inline mat inequalities_matrix(isl::dim c1, isl::dim c2, isl::dim c3, isl::dim c4) const;\n  inline basic_set insert_dims(isl::dim type, unsigned int pos, unsigned int n) const;\n  inline basic_set intersect(basic_set bset2) const;\n  inline basic_set intersect_params(basic_set bset2) const;\n  inline boolean involves_dims(isl::dim type, unsigned int first, unsigned int n) const;\n  inline boolean is_bounded() const;\n  inline boolean is_disjoint(const basic_set &bset2) const;\n  inline boolean is_empty() const;\n  inline boolean is_equal(const basic_set &bset2) const;\n  inline int is_rational() const;\n  inline boolean is_subset(const basic_set &bset2) const;\n  inline boolean is_universe() const;\n  inline boolean is_wrapping() const;\n  inline set lexmax() const;\n  inline set lexmin() const;\n  inline basic_set lower_bound_val(isl::dim type, unsigned int pos, val value) const;\n  inline val max_val(const aff &obj) const;\n  inline basic_set move_dims(isl::dim dst_type, unsigned int dst_pos, isl::dim src_type, unsigned int src_pos, unsigned int n) const;\n  inline isl_size n_constraint() const;\n  inline isl_size n_dim() const;\n  static inline basic_set nat_universe(space space);\n  inline basic_set neg() const;\n  inline basic_set params() const;\n  inline boolean plain_is_empty() const;\n  inline boolean plain_is_equal(const basic_set &bset2) const;\n  inline boolean plain_is_universe() const;\n  static inline basic_set positive_orthant(space space);\n  inline basic_set preimage_multi_aff(multi_aff ma) const;\n  inline basic_set project_out(isl::dim type, unsigned int first, unsigned int n) const;\n  inline mat reduced_basis() const;\n  inline basic_set remove_dims(isl::dim type, unsigned int first, unsigned int n) const;\n  inline basic_set remove_divs() const;\n  inline basic_set remove_divs_involving_dims(isl::dim type, unsigned int first, unsigned int n) const;\n  inline basic_set remove_redundancies() const;\n  inline basic_set remove_unknown_divs() const;\n  inline basic_set sample() const;\n  inline point sample_point() const;\n  inline basic_set set_tuple_id(id id) const;\n  inline basic_set set_tuple_name(const std::string &s) const;\n  inline basic_set solutions() const;\n  inline set unite(basic_set bset2) const;\n  static inline basic_set universe(space space);\n  inline basic_map unwrap() const;\n  inline basic_set upper_bound_val(isl::dim type, unsigned int pos, val value) const;\n};\n\n// declarations for isl::basic_set_list\ninline basic_set_list manage(__isl_take isl_basic_set_list *ptr);\ninline basic_set_list manage_copy(__isl_keep isl_basic_set_list *ptr);\n\nclass basic_set_list {\n  friend inline basic_set_list manage(__isl_take isl_basic_set_list *ptr);\n  friend inline basic_set_list manage_copy(__isl_keep isl_basic_set_list *ptr);\n\n  isl_basic_set_list *ptr = nullptr;\n\n  inline explicit basic_set_list(__isl_take isl_basic_set_list *ptr);\n\npublic:\n  inline /* implicit */ basic_set_list();\n  inline /* implicit */ basic_set_list(const basic_set_list &obj);\n  inline /* implicit */ basic_set_list(std::nullptr_t);\n  inline basic_set_list &operator=(basic_set_list obj);\n  inline ~basic_set_list();\n  inline __isl_give isl_basic_set_list *copy() const &;\n  inline __isl_give isl_basic_set_list *copy() && = delete;\n  inline __isl_keep isl_basic_set_list *get() const;\n  inline __isl_give isl_basic_set_list *release();\n  inline bool is_null() const;\n  inline explicit operator bool() const;\n  inline ctx get_ctx() const;\n  inline std::string to_str() const;\n  inline void dump() const;\n\n  inline basic_set_list add(basic_set el) const;\n  static inline basic_set_list alloc(ctx ctx, int n);\n  inline basic_set_list clear() const;\n  inline basic_set_list coefficients() const;\n  inline basic_set_list concat(basic_set_list list2) const;\n  inline basic_set_list drop(unsigned int first, unsigned int n) const;\n  inline stat foreach(const std::function<stat(basic_set)> &fn) const;\n  static inline basic_set_list from_basic_set(basic_set el);\n  inline basic_set get_at(int index) const;\n  inline basic_set get_basic_set(int index) const;\n  inline basic_set_list insert(unsigned int pos, basic_set el) const;\n  inline isl_size n_basic_set() const;\n  inline basic_set_list reverse() const;\n  inline basic_set_list set_basic_set(int index, basic_set el) const;\n  inline isl_size size() const;\n  inline basic_set_list swap(unsigned int pos1, unsigned int pos2) const;\n};\n\n// declarations for isl::constraint\ninline constraint manage(__isl_take isl_constraint *ptr);\ninline constraint manage_copy(__isl_keep isl_constraint *ptr);\n\nclass constraint {\n  friend inline constraint manage(__isl_take isl_constraint *ptr);\n  friend inline constraint manage_copy(__isl_keep isl_constraint *ptr);\n\n  isl_constraint *ptr = nullptr;\n\n  inline explicit constraint(__isl_take isl_constraint *ptr);\n\npublic:\n  inline /* implicit */ constraint();\n  inline /* implicit */ constraint(const constraint &obj);\n  inline /* implicit */ constraint(std::nullptr_t);\n  inline constraint &operator=(constraint obj);\n  inline ~constraint();\n  inline __isl_give isl_constraint *copy() const &;\n  inline __isl_give isl_constraint *copy() && = delete;\n  inline __isl_keep isl_constraint *get() const;\n  inline __isl_give isl_constraint *release();\n  inline bool is_null() const;\n  inline explicit operator bool() const;\n  inline ctx get_ctx() const;\n  inline void dump() const;\n\n  static inline constraint alloc_equality(local_space ls);\n  static inline constraint alloc_inequality(local_space ls);\n  inline int cmp_last_non_zero(const constraint &c2) const;\n  inline aff get_aff() const;\n  inline aff get_bound(isl::dim type, int pos) const;\n  inline val get_coefficient_val(isl::dim type, int pos) const;\n  inline val get_constant_val() const;\n  inline std::string get_dim_name(isl::dim type, unsigned int pos) const;\n  inline aff get_div(int pos) const;\n  inline local_space get_local_space() const;\n  inline space get_space() const;\n  inline boolean involves_dims(isl::dim type, unsigned int first, unsigned int n) const;\n  inline boolean is_div_constraint() const;\n  inline boolean is_lower_bound(isl::dim type, unsigned int pos) const;\n  inline boolean is_upper_bound(isl::dim type, unsigned int pos) const;\n  inline int plain_cmp(const constraint &c2) const;\n  inline constraint set_coefficient_si(isl::dim type, int pos, int v) const;\n  inline constraint set_coefficient_val(isl::dim type, int pos, val v) const;\n  inline constraint set_constant_si(int v) const;\n  inline constraint set_constant_val(val v) const;\n};\n\n// declarations for isl::constraint_list\ninline constraint_list manage(__isl_take isl_constraint_list *ptr);\ninline constraint_list manage_copy(__isl_keep isl_constraint_list *ptr);\n\nclass constraint_list {\n  friend inline constraint_list manage(__isl_take isl_constraint_list *ptr);\n  friend inline constraint_list manage_copy(__isl_keep isl_constraint_list *ptr);\n\n  isl_constraint_list *ptr = nullptr;\n\n  inline explicit constraint_list(__isl_take isl_constraint_list *ptr);\n\npublic:\n  inline /* implicit */ constraint_list();\n  inline /* implicit */ constraint_list(const constraint_list &obj);\n  inline /* implicit */ constraint_list(std::nullptr_t);\n  inline constraint_list &operator=(constraint_list obj);\n  inline ~constraint_list();\n  inline __isl_give isl_constraint_list *copy() const &;\n  inline __isl_give isl_constraint_list *copy() && = delete;\n  inline __isl_keep isl_constraint_list *get() const;\n  inline __isl_give isl_constraint_list *release();\n  inline bool is_null() const;\n  inline explicit operator bool() const;\n  inline ctx get_ctx() const;\n  inline std::string to_str() const;\n  inline void dump() const;\n\n  inline constraint_list add(constraint el) const;\n  static inline constraint_list alloc(ctx ctx, int n);\n  inline constraint_list clear() const;\n  inline constraint_list concat(constraint_list list2) const;\n  inline constraint_list drop(unsigned int first, unsigned int n) const;\n  inline stat foreach(const std::function<stat(constraint)> &fn) const;\n  static inline constraint_list from_constraint(constraint el);\n  inline constraint get_at(int index) const;\n  inline constraint get_constraint(int index) const;\n  inline constraint_list insert(unsigned int pos, constraint el) const;\n  inline isl_size n_constraint() const;\n  inline constraint_list reverse() const;\n  inline constraint_list set_constraint(int index, constraint el) const;\n  inline isl_size size() const;\n  inline constraint_list swap(unsigned int pos1, unsigned int pos2) const;\n};\n\n// declarations for isl::fixed_box\ninline fixed_box manage(__isl_take isl_fixed_box *ptr);\ninline fixed_box manage_copy(__isl_keep isl_fixed_box *ptr);\n\nclass fixed_box {\n  friend inline fixed_box manage(__isl_take isl_fixed_box *ptr);\n  friend inline fixed_box manage_copy(__isl_keep isl_fixed_box *ptr);\n\n  isl_fixed_box *ptr = nullptr;\n\n  inline explicit fixed_box(__isl_take isl_fixed_box *ptr);\n\npublic:\n  inline /* implicit */ fixed_box();\n  inline /* implicit */ fixed_box(const fixed_box &obj);\n  inline /* implicit */ fixed_box(std::nullptr_t);\n  inline fixed_box &operator=(fixed_box obj);\n  inline ~fixed_box();\n  inline __isl_give isl_fixed_box *copy() const &;\n  inline __isl_give isl_fixed_box *copy() && = delete;\n  inline __isl_keep isl_fixed_box *get() const;\n  inline __isl_give isl_fixed_box *release();\n  inline bool is_null() const;\n  inline explicit operator bool() const;\n  inline ctx get_ctx() const;\n  inline std::string to_str() const;\n  inline void dump() const;\n\n  inline multi_aff get_offset() const;\n  inline multi_val get_size() const;\n  inline space get_space() const;\n  inline boolean is_valid() const;\n};\n\n// declarations for isl::id\ninline id manage(__isl_take isl_id *ptr);\ninline id manage_copy(__isl_keep isl_id *ptr);\n\nclass id {\n  friend inline id manage(__isl_take isl_id *ptr);\n  friend inline id manage_copy(__isl_keep isl_id *ptr);\n\n  isl_id *ptr = nullptr;\n\n  inline explicit id(__isl_take isl_id *ptr);\n\npublic:\n  inline /* implicit */ id();\n  inline /* implicit */ id(const id &obj);\n  inline /* implicit */ id(std::nullptr_t);\n  inline explicit id(ctx ctx, const std::string &str);\n  inline id &operator=(id obj);\n  inline ~id();\n  inline __isl_give isl_id *copy() const &;\n  inline __isl_give isl_id *copy() && = delete;\n  inline __isl_keep isl_id *get() const;\n  inline __isl_give isl_id *release();\n  inline bool is_null() const;\n  inline explicit operator bool() const;\n  inline ctx get_ctx() const;\n  inline std::string to_str() const;\n  inline void dump() const;\n\n  static inline id alloc(ctx ctx, const std::string &name, void * user);\n  inline uint32_t get_hash() const;\n  inline std::string get_name() const;\n  inline void * get_user() const;\n};\n\n// declarations for isl::id_list\ninline id_list manage(__isl_take isl_id_list *ptr);\ninline id_list manage_copy(__isl_keep isl_id_list *ptr);\n\nclass id_list {\n  friend inline id_list manage(__isl_take isl_id_list *ptr);\n  friend inline id_list manage_copy(__isl_keep isl_id_list *ptr);\n\n  isl_id_list *ptr = nullptr;\n\n  inline explicit id_list(__isl_take isl_id_list *ptr);\n\npublic:\n  inline /* implicit */ id_list();\n  inline /* implicit */ id_list(const id_list &obj);\n  inline /* implicit */ id_list(std::nullptr_t);\n  inline id_list &operator=(id_list obj);\n  inline ~id_list();\n  inline __isl_give isl_id_list *copy() const &;\n  inline __isl_give isl_id_list *copy() && = delete;\n  inline __isl_keep isl_id_list *get() const;\n  inline __isl_give isl_id_list *release();\n  inline bool is_null() const;\n  inline explicit operator bool() const;\n  inline ctx get_ctx() const;\n  inline std::string to_str() const;\n  inline void dump() const;\n\n  inline id_list add(id el) const;\n  static inline id_list alloc(ctx ctx, int n);\n  inline id_list clear() const;\n  inline id_list concat(id_list list2) const;\n  inline id_list drop(unsigned int first, unsigned int n) const;\n  inline stat foreach(const std::function<stat(id)> &fn) const;\n  static inline id_list from_id(id el);\n  inline id get_at(int index) const;\n  inline id get_id(int index) const;\n  inline id_list insert(unsigned int pos, id el) const;\n  inline isl_size n_id() const;\n  inline id_list reverse() const;\n  inline id_list set_id(int index, id el) const;\n  inline isl_size size() const;\n  inline id_list swap(unsigned int pos1, unsigned int pos2) const;\n};\n\n// declarations for isl::id_to_ast_expr\ninline id_to_ast_expr manage(__isl_take isl_id_to_ast_expr *ptr);\ninline id_to_ast_expr manage_copy(__isl_keep isl_id_to_ast_expr *ptr);\n\nclass id_to_ast_expr {\n  friend inline id_to_ast_expr manage(__isl_take isl_id_to_ast_expr *ptr);\n  friend inline id_to_ast_expr manage_copy(__isl_keep isl_id_to_ast_expr *ptr);\n\n  isl_id_to_ast_expr *ptr = nullptr;\n\n  inline explicit id_to_ast_expr(__isl_take isl_id_to_ast_expr *ptr);\n\npublic:\n  inline /* implicit */ id_to_ast_expr();\n  inline /* implicit */ id_to_ast_expr(const id_to_ast_expr &obj);\n  inline /* implicit */ id_to_ast_expr(std::nullptr_t);\n  inline id_to_ast_expr &operator=(id_to_ast_expr obj);\n  inline ~id_to_ast_expr();\n  inline __isl_give isl_id_to_ast_expr *copy() const &;\n  inline __isl_give isl_id_to_ast_expr *copy() && = delete;\n  inline __isl_keep isl_id_to_ast_expr *get() const;\n  inline __isl_give isl_id_to_ast_expr *release();\n  inline bool is_null() const;\n  inline explicit operator bool() const;\n  inline ctx get_ctx() const;\n  inline void dump() const;\n\n  static inline id_to_ast_expr alloc(ctx ctx, int min_size);\n  inline id_to_ast_expr drop(id key) const;\n  inline stat foreach(const std::function<stat(id, ast_expr)> &fn) const;\n  inline ast_expr get(id key) const;\n  inline boolean has(const id &key) const;\n  inline id_to_ast_expr set(id key, ast_expr val) const;\n};\n\n// declarations for isl::local_space\ninline local_space manage(__isl_take isl_local_space *ptr);\ninline local_space manage_copy(__isl_keep isl_local_space *ptr);\n\nclass local_space {\n  friend inline local_space manage(__isl_take isl_local_space *ptr);\n  friend inline local_space manage_copy(__isl_keep isl_local_space *ptr);\n\n  isl_local_space *ptr = nullptr;\n\n  inline explicit local_space(__isl_take isl_local_space *ptr);\n\npublic:\n  inline /* implicit */ local_space();\n  inline /* implicit */ local_space(const local_space &obj);\n  inline /* implicit */ local_space(std::nullptr_t);\n  inline explicit local_space(space space);\n  inline local_space &operator=(local_space obj);\n  inline ~local_space();\n  inline __isl_give isl_local_space *copy() const &;\n  inline __isl_give isl_local_space *copy() && = delete;\n  inline __isl_keep isl_local_space *get() const;\n  inline __isl_give isl_local_space *release();\n  inline bool is_null() const;\n  inline explicit operator bool() const;\n  inline ctx get_ctx() const;\n  inline void dump() const;\n\n  inline local_space add_dims(isl::dim type, unsigned int n) const;\n  inline isl_size dim(isl::dim type) const;\n  inline local_space domain() const;\n  inline local_space drop_dims(isl::dim type, unsigned int first, unsigned int n) const;\n  inline int find_dim_by_name(isl::dim type, const std::string &name) const;\n  inline local_space flatten_domain() const;\n  inline local_space flatten_range() const;\n  inline local_space from_domain() const;\n  inline id get_dim_id(isl::dim type, unsigned int pos) const;\n  inline std::string get_dim_name(isl::dim type, unsigned int pos) const;\n  inline aff get_div(int pos) const;\n  inline space get_space() const;\n  inline boolean has_dim_id(isl::dim type, unsigned int pos) const;\n  inline boolean has_dim_name(isl::dim type, unsigned int pos) const;\n  inline local_space insert_dims(isl::dim type, unsigned int first, unsigned int n) const;\n  inline local_space intersect(local_space ls2) const;\n  inline boolean is_equal(const local_space &ls2) const;\n  inline boolean is_params() const;\n  inline boolean is_set() const;\n  inline local_space range() const;\n  inline local_space set_dim_id(isl::dim type, unsigned int pos, id id) const;\n  inline local_space set_from_params() const;\n  inline local_space set_tuple_id(isl::dim type, id id) const;\n  inline local_space wrap() const;\n};\n\n// declarations for isl::map\ninline map manage(__isl_take isl_map *ptr);\ninline map manage_copy(__isl_keep isl_map *ptr);\n\nclass map {\n  friend inline map manage(__isl_take isl_map *ptr);\n  friend inline map manage_copy(__isl_keep isl_map *ptr);\n\n  isl_map *ptr = nullptr;\n\n  inline explicit map(__isl_take isl_map *ptr);\n\npublic:\n  inline /* implicit */ map();\n  inline /* implicit */ map(const map &obj);\n  inline /* implicit */ map(std::nullptr_t);\n  inline /* implicit */ map(basic_map bmap);\n  inline explicit map(ctx ctx, const std::string &str);\n  inline map &operator=(map obj);\n  inline ~map();\n  inline __isl_give isl_map *copy() const &;\n  inline __isl_give isl_map *copy() && = delete;\n  inline __isl_keep isl_map *get() const;\n  inline __isl_give isl_map *release();\n  inline bool is_null() const;\n  inline explicit operator bool() const;\n  inline ctx get_ctx() const;\n  inline std::string to_str() const;\n  inline void dump() const;\n\n  inline map add_constraint(constraint constraint) const;\n  inline map add_dims(isl::dim type, unsigned int n) const;\n  inline basic_map affine_hull() const;\n  inline map align_params(space model) const;\n  inline map apply_domain(map map2) const;\n  inline map apply_range(map map2) const;\n  inline set bind_domain(multi_id tuple) const;\n  inline set bind_range(multi_id tuple) const;\n  inline boolean can_curry() const;\n  inline boolean can_range_curry() const;\n  inline boolean can_uncurry() const;\n  inline boolean can_zip() const;\n  inline map coalesce() const;\n  inline map complement() const;\n  inline basic_map convex_hull() const;\n  inline map curry() const;\n  inline set deltas() const;\n  inline map deltas_map() const;\n  inline map detect_equalities() const;\n  inline isl_size dim(isl::dim type) const;\n  inline pw_aff dim_max(int pos) const;\n  inline pw_aff dim_min(int pos) const;\n  inline set domain() const;\n  inline map domain_factor_domain() const;\n  inline map domain_factor_range() const;\n  inline boolean domain_is_wrapping() const;\n  inline map domain_map() const;\n  inline map domain_product(map map2) const;\n  inline map drop_constraints_involving_dims(isl::dim type, unsigned int first, unsigned int n) const;\n  inline map drop_constraints_not_involving_dims(isl::dim type, unsigned int first, unsigned int n) const;\n  inline map drop_unused_params() const;\n  inline map eliminate(isl::dim type, unsigned int first, unsigned int n) const;\n  static inline map empty(space space);\n  inline map eq_at(multi_pw_aff mpa) const;\n  inline map equate(isl::dim type1, int pos1, isl::dim type2, int pos2) const;\n  inline map factor_domain() const;\n  inline map factor_range() const;\n  inline int find_dim_by_id(isl::dim type, const id &id) const;\n  inline int find_dim_by_name(isl::dim type, const std::string &name) const;\n  inline map fix_si(isl::dim type, unsigned int pos, int value) const;\n  inline map fix_val(isl::dim type, unsigned int pos, val v) const;\n  inline map fixed_power_val(val exp) const;\n  inline map flat_domain_product(map map2) const;\n  inline map flat_product(map map2) const;\n  inline map flat_range_product(map map2) const;\n  inline map flatten() const;\n  inline map flatten_domain() const;\n  inline map flatten_range() const;\n  inline map floordiv_val(val d) const;\n  inline stat foreach_basic_map(const std::function<stat(basic_map)> &fn) const;\n  static inline map from_aff(aff aff);\n  static inline map from_domain(set set);\n  static inline map from_domain_and_range(set domain, set range);\n  static inline map from_multi_aff(multi_aff maff);\n  static inline map from_multi_pw_aff(multi_pw_aff mpa);\n  static inline map from_pw_aff(pw_aff pwaff);\n  static inline map from_pw_multi_aff(pw_multi_aff pma);\n  static inline map from_range(set set);\n  static inline map from_union_map(union_map umap);\n  inline basic_map_list get_basic_map_list() const;\n  inline id get_dim_id(isl::dim type, unsigned int pos) const;\n  inline std::string get_dim_name(isl::dim type, unsigned int pos) const;\n  inline uint32_t get_hash() const;\n  inline fixed_box get_range_simple_fixed_box_hull() const;\n  inline space get_space() const;\n  inline id get_tuple_id(isl::dim type) const;\n  inline std::string get_tuple_name(isl::dim type) const;\n  inline map gist(map context) const;\n  inline map gist_basic_map(basic_map context) const;\n  inline map gist_domain(set context) const;\n  inline map gist_params(set context) const;\n  inline map gist_range(set context) const;\n  inline boolean has_dim_id(isl::dim type, unsigned int pos) const;\n  inline boolean has_dim_name(isl::dim type, unsigned int pos) const;\n  inline boolean has_equal_space(const map &map2) const;\n  inline boolean has_tuple_id(isl::dim type) const;\n  inline boolean has_tuple_name(isl::dim type) const;\n  static inline map identity(space space);\n  inline map insert_dims(isl::dim type, unsigned int pos, unsigned int n) const;\n  inline map intersect(map map2) const;\n  inline map intersect_domain(set set) const;\n  inline map intersect_domain_factor_domain(map factor) const;\n  inline map intersect_domain_factor_range(map factor) const;\n  inline map intersect_params(set params) const;\n  inline map intersect_range(set set) const;\n  inline map intersect_range_factor_domain(map factor) const;\n  inline map intersect_range_factor_range(map factor) const;\n  inline boolean involves_dims(isl::dim type, unsigned int first, unsigned int n) const;\n  inline boolean is_bijective() const;\n  inline boolean is_disjoint(const map &map2) const;\n  inline boolean is_empty() const;\n  inline boolean is_equal(const map &map2) const;\n  inline boolean is_identity() const;\n  inline boolean is_injective() const;\n  inline boolean is_product() const;\n  inline boolean is_single_valued() const;\n  inline boolean is_strict_subset(const map &map2) const;\n  inline boolean is_subset(const map &map2) const;\n  inline int is_translation() const;\n  static inline map lex_ge(space set_space);\n  inline map lex_ge_at(multi_pw_aff mpa) const;\n  static inline map lex_ge_first(space space, unsigned int n);\n  inline map lex_ge_map(map map2) const;\n  static inline map lex_gt(space set_space);\n  inline map lex_gt_at(multi_pw_aff mpa) const;\n  static inline map lex_gt_first(space space, unsigned int n);\n  inline map lex_gt_map(map map2) const;\n  static inline map lex_le(space set_space);\n  inline map lex_le_at(multi_pw_aff mpa) const;\n  static inline map lex_le_first(space space, unsigned int n);\n  inline map lex_le_map(map map2) const;\n  static inline map lex_lt(space set_space);\n  inline map lex_lt_at(multi_pw_aff mpa) const;\n  static inline map lex_lt_first(space space, unsigned int n);\n  inline map lex_lt_map(map map2) const;\n  inline map lexmax() const;\n  inline pw_multi_aff lexmax_pw_multi_aff() const;\n  inline map lexmin() const;\n  inline pw_multi_aff lexmin_pw_multi_aff() const;\n  inline map lower_bound(multi_pw_aff lower) const;\n  inline map lower_bound_si(isl::dim type, unsigned int pos, int value) const;\n  inline map lower_bound_val(isl::dim type, unsigned int pos, val value) const;\n  inline multi_pw_aff max_multi_pw_aff() const;\n  inline multi_pw_aff min_multi_pw_aff() const;\n  inline map move_dims(isl::dim dst_type, unsigned int dst_pos, isl::dim src_type, unsigned int src_pos, unsigned int n) const;\n  inline isl_size n_basic_map() const;\n  static inline map nat_universe(space space);\n  inline map neg() const;\n  inline map oppose(isl::dim type1, int pos1, isl::dim type2, int pos2) const;\n  inline map order_ge(isl::dim type1, int pos1, isl::dim type2, int pos2) const;\n  inline map order_gt(isl::dim type1, int pos1, isl::dim type2, int pos2) const;\n  inline map order_le(isl::dim type1, int pos1, isl::dim type2, int pos2) const;\n  inline map order_lt(isl::dim type1, int pos1, isl::dim type2, int pos2) const;\n  inline set params() const;\n  inline val plain_get_val_if_fixed(isl::dim type, unsigned int pos) const;\n  inline boolean plain_is_empty() const;\n  inline boolean plain_is_equal(const map &map2) const;\n  inline boolean plain_is_injective() const;\n  inline boolean plain_is_single_valued() const;\n  inline boolean plain_is_universe() const;\n  inline basic_map plain_unshifted_simple_hull() const;\n  inline basic_map polyhedral_hull() const;\n  inline map preimage_domain(multi_aff ma) const;\n  inline map preimage_domain(multi_pw_aff mpa) const;\n  inline map preimage_domain(pw_multi_aff pma) const;\n  inline map preimage_range(multi_aff ma) const;\n  inline map preimage_range(pw_multi_aff pma) const;\n  inline map product(map map2) const;\n  inline map project_out(isl::dim type, unsigned int first, unsigned int n) const;\n  inline map project_out_all_params() const;\n  inline set range() const;\n  inline map range_curry() const;\n  inline map range_factor_domain() const;\n  inline map range_factor_range() const;\n  inline boolean range_is_wrapping() const;\n  inline map range_map() const;\n  inline map range_product(map map2) const;\n  inline map range_reverse() const;\n  inline map remove_dims(isl::dim type, unsigned int first, unsigned int n) const;\n  inline map remove_divs() const;\n  inline map remove_divs_involving_dims(isl::dim type, unsigned int first, unsigned int n) const;\n  inline map remove_redundancies() const;\n  inline map remove_unknown_divs() const;\n  inline map reset_tuple_id(isl::dim type) const;\n  inline map reset_user() const;\n  inline map reverse() const;\n  inline basic_map sample() const;\n  inline map set_dim_id(isl::dim type, unsigned int pos, id id) const;\n  inline map set_tuple_id(isl::dim type, id id) const;\n  inline map set_tuple_name(isl::dim type, const std::string &s) const;\n  inline basic_map simple_hull() const;\n  inline map subtract(map map2) const;\n  inline map subtract_domain(set dom) const;\n  inline map subtract_range(set dom) const;\n  inline map sum(map map2) const;\n  inline map uncurry() const;\n  inline map unite(map map2) const;\n  static inline map universe(space space);\n  inline basic_map unshifted_simple_hull() const;\n  inline basic_map unshifted_simple_hull_from_map_list(map_list list) const;\n  inline map upper_bound(multi_pw_aff upper) const;\n  inline map upper_bound_si(isl::dim type, unsigned int pos, int value) const;\n  inline map upper_bound_val(isl::dim type, unsigned int pos, val value) const;\n  inline set wrap() const;\n  inline map zip() const;\n};\n\n// declarations for isl::map_list\ninline map_list manage(__isl_take isl_map_list *ptr);\ninline map_list manage_copy(__isl_keep isl_map_list *ptr);\n\nclass map_list {\n  friend inline map_list manage(__isl_take isl_map_list *ptr);\n  friend inline map_list manage_copy(__isl_keep isl_map_list *ptr);\n\n  isl_map_list *ptr = nullptr;\n\n  inline explicit map_list(__isl_take isl_map_list *ptr);\n\npublic:\n  inline /* implicit */ map_list();\n  inline /* implicit */ map_list(const map_list &obj);\n  inline /* implicit */ map_list(std::nullptr_t);\n  inline map_list &operator=(map_list obj);\n  inline ~map_list();\n  inline __isl_give isl_map_list *copy() const &;\n  inline __isl_give isl_map_list *copy() && = delete;\n  inline __isl_keep isl_map_list *get() const;\n  inline __isl_give isl_map_list *release();\n  inline bool is_null() const;\n  inline explicit operator bool() const;\n  inline ctx get_ctx() const;\n  inline std::string to_str() const;\n  inline void dump() const;\n\n  inline map_list add(map el) const;\n  static inline map_list alloc(ctx ctx, int n);\n  inline map_list clear() const;\n  inline map_list concat(map_list list2) const;\n  inline map_list drop(unsigned int first, unsigned int n) const;\n  inline stat foreach(const std::function<stat(map)> &fn) const;\n  static inline map_list from_map(map el);\n  inline map get_at(int index) const;\n  inline map get_map(int index) const;\n  inline map_list insert(unsigned int pos, map el) const;\n  inline isl_size n_map() const;\n  inline map_list reverse() const;\n  inline map_list set_map(int index, map el) const;\n  inline isl_size size() const;\n  inline map_list swap(unsigned int pos1, unsigned int pos2) const;\n};\n\n// declarations for isl::mat\ninline mat manage(__isl_take isl_mat *ptr);\ninline mat manage_copy(__isl_keep isl_mat *ptr);\n\nclass mat {\n  friend inline mat manage(__isl_take isl_mat *ptr);\n  friend inline mat manage_copy(__isl_keep isl_mat *ptr);\n\n  isl_mat *ptr = nullptr;\n\n  inline explicit mat(__isl_take isl_mat *ptr);\n\npublic:\n  inline /* implicit */ mat();\n  inline /* implicit */ mat(const mat &obj);\n  inline /* implicit */ mat(std::nullptr_t);\n  inline mat &operator=(mat obj);\n  inline ~mat();\n  inline __isl_give isl_mat *copy() const &;\n  inline __isl_give isl_mat *copy() && = delete;\n  inline __isl_keep isl_mat *get() const;\n  inline __isl_give isl_mat *release();\n  inline bool is_null() const;\n  inline explicit operator bool() const;\n  inline ctx get_ctx() const;\n  inline void dump() const;\n\n  inline mat add_rows(unsigned int n) const;\n  inline mat add_zero_cols(unsigned int n) const;\n  inline mat add_zero_rows(unsigned int n) const;\n  inline mat aff_direct_sum(mat right) const;\n  static inline mat alloc(ctx ctx, unsigned int n_row, unsigned int n_col);\n  inline isl_size cols() const;\n  inline mat concat(mat bot) const;\n  inline mat diagonal(mat mat2) const;\n  inline mat drop_cols(unsigned int col, unsigned int n) const;\n  inline mat drop_rows(unsigned int row, unsigned int n) const;\n  static inline mat from_row_vec(vec vec);\n  inline val get_element_val(int row, int col) const;\n  inline boolean has_linearly_independent_rows(const mat &mat2) const;\n  inline int initial_non_zero_cols() const;\n  inline mat insert_cols(unsigned int col, unsigned int n) const;\n  inline mat insert_rows(unsigned int row, unsigned int n) const;\n  inline mat insert_zero_cols(unsigned int first, unsigned int n) const;\n  inline mat insert_zero_rows(unsigned int row, unsigned int n) const;\n  inline mat inverse_product(mat right) const;\n  inline boolean is_equal(const mat &mat2) const;\n  inline mat lin_to_aff() const;\n  inline mat move_cols(unsigned int dst_col, unsigned int src_col, unsigned int n) const;\n  inline mat normalize() const;\n  inline mat normalize_row(int row) const;\n  inline mat product(mat right) const;\n  inline isl_size rank() const;\n  inline mat right_inverse() const;\n  inline mat right_kernel() const;\n  inline mat row_basis() const;\n  inline mat row_basis_extension(mat mat2) const;\n  inline isl_size rows() const;\n  inline mat set_element_si(int row, int col, int v) const;\n  inline mat set_element_val(int row, int col, val v) const;\n  inline mat swap_cols(unsigned int i, unsigned int j) const;\n  inline mat swap_rows(unsigned int i, unsigned int j) const;\n  inline mat transpose() const;\n  inline mat unimodular_complete(int row) const;\n  inline mat vec_concat(vec bot) const;\n  inline vec vec_inverse_product(vec vec) const;\n  inline vec vec_product(vec vec) const;\n};\n\n// declarations for isl::multi_aff\ninline multi_aff manage(__isl_take isl_multi_aff *ptr);\ninline multi_aff manage_copy(__isl_keep isl_multi_aff *ptr);\n\nclass multi_aff {\n  friend inline multi_aff manage(__isl_take isl_multi_aff *ptr);\n  friend inline multi_aff manage_copy(__isl_keep isl_multi_aff *ptr);\n\n  isl_multi_aff *ptr = nullptr;\n\n  inline explicit multi_aff(__isl_take isl_multi_aff *ptr);\n\npublic:\n  inline /* implicit */ multi_aff();\n  inline /* implicit */ multi_aff(const multi_aff &obj);\n  inline /* implicit */ multi_aff(std::nullptr_t);\n  inline /* implicit */ multi_aff(aff aff);\n  inline explicit multi_aff(space space, aff_list list);\n  inline explicit multi_aff(ctx ctx, const std::string &str);\n  inline multi_aff &operator=(multi_aff obj);\n  inline ~multi_aff();\n  inline __isl_give isl_multi_aff *copy() const &;\n  inline __isl_give isl_multi_aff *copy() && = delete;\n  inline __isl_keep isl_multi_aff *get() const;\n  inline __isl_give isl_multi_aff *release();\n  inline bool is_null() const;\n  inline explicit operator bool() const;\n  inline ctx get_ctx() const;\n  inline std::string to_str() const;\n  inline void dump() const;\n\n  inline multi_aff add(multi_aff multi2) const;\n  inline multi_aff add_constant(multi_val mv) const;\n  inline multi_aff add_constant(val v) const;\n  inline multi_aff add_dims(isl::dim type, unsigned int n) const;\n  inline multi_aff align_params(space model) const;\n  inline basic_set bind(multi_id tuple) const;\n  inline multi_aff bind_domain(multi_id tuple) const;\n  inline multi_aff bind_domain_wrapped_domain(multi_id tuple) const;\n  inline isl_size dim(isl::dim type) const;\n  static inline multi_aff domain_map(space space);\n  inline multi_aff drop_dims(isl::dim type, unsigned int first, unsigned int n) const;\n  inline multi_aff factor_range() const;\n  inline int find_dim_by_id(isl::dim type, const id &id) const;\n  inline int find_dim_by_name(isl::dim type, const std::string &name) const;\n  inline multi_aff flat_range_product(multi_aff multi2) const;\n  inline multi_aff flatten_domain() const;\n  inline multi_aff flatten_range() const;\n  inline multi_aff floor() const;\n  inline multi_aff from_range() const;\n  inline aff get_aff(int pos) const;\n  inline aff get_at(int pos) const;\n  inline multi_val get_constant_multi_val() const;\n  inline id get_dim_id(isl::dim type, unsigned int pos) const;\n  inline space get_domain_space() const;\n  inline aff_list get_list() const;\n  inline space get_space() const;\n  inline id get_tuple_id(isl::dim type) const;\n  inline std::string get_tuple_name(isl::dim type) const;\n  inline multi_aff gist(set context) const;\n  inline multi_aff gist_params(set context) const;\n  inline boolean has_tuple_id(isl::dim type) const;\n  static inline multi_aff identity(space space);\n  inline multi_aff identity() const;\n  static inline multi_aff identity_on_domain(space space);\n  inline multi_aff insert_dims(isl::dim type, unsigned int first, unsigned int n) const;\n  inline multi_aff insert_domain(space domain) const;\n  inline boolean involves_dims(isl::dim type, unsigned int first, unsigned int n) const;\n  inline boolean involves_locals() const;\n  inline boolean involves_nan() const;\n  inline set lex_ge_set(multi_aff ma2) const;\n  inline set lex_gt_set(multi_aff ma2) const;\n  inline set lex_le_set(multi_aff ma2) const;\n  inline set lex_lt_set(multi_aff ma2) const;\n  inline multi_aff mod_multi_val(multi_val mv) const;\n  inline multi_aff move_dims(isl::dim dst_type, unsigned int dst_pos, isl::dim src_type, unsigned int src_pos, unsigned int n) const;\n  static inline multi_aff multi_val_on_space(space space, multi_val mv);\n  inline multi_aff neg() const;\n  inline int plain_cmp(const multi_aff &multi2) const;\n  inline boolean plain_is_equal(const multi_aff &multi2) const;\n  inline multi_aff product(multi_aff multi2) const;\n  inline multi_aff project_domain_on_params() const;\n  static inline multi_aff project_out_map(space space, isl::dim type, unsigned int first, unsigned int n);\n  inline multi_aff pullback(multi_aff ma2) const;\n  inline multi_aff range_factor_domain() const;\n  inline multi_aff range_factor_range() const;\n  inline boolean range_is_wrapping() const;\n  static inline multi_aff range_map(space space);\n  inline multi_aff range_product(multi_aff multi2) const;\n  inline multi_aff range_splice(unsigned int pos, multi_aff multi2) const;\n  inline multi_aff reset_tuple_id(isl::dim type) const;\n  inline multi_aff reset_user() const;\n  inline multi_aff scale(multi_val mv) const;\n  inline multi_aff scale(val v) const;\n  inline multi_aff scale_down(multi_val mv) const;\n  inline multi_aff scale_down(val v) const;\n  inline multi_aff set_aff(int pos, aff el) const;\n  inline multi_aff set_at(int pos, aff el) const;\n  inline multi_aff set_dim_id(isl::dim type, unsigned int pos, id id) const;\n  inline multi_aff set_tuple_id(isl::dim type, id id) const;\n  inline multi_aff set_tuple_name(isl::dim type, const std::string &s) const;\n  inline isl_size size() const;\n  inline multi_aff splice(unsigned int in_pos, unsigned int out_pos, multi_aff multi2) const;\n  inline multi_aff sub(multi_aff multi2) const;\n  inline multi_aff unbind_params_insert_domain(multi_id domain) const;\n  static inline multi_aff zero(space space);\n};\n\n// declarations for isl::multi_id\ninline multi_id manage(__isl_take isl_multi_id *ptr);\ninline multi_id manage_copy(__isl_keep isl_multi_id *ptr);\n\nclass multi_id {\n  friend inline multi_id manage(__isl_take isl_multi_id *ptr);\n  friend inline multi_id manage_copy(__isl_keep isl_multi_id *ptr);\n\n  isl_multi_id *ptr = nullptr;\n\n  inline explicit multi_id(__isl_take isl_multi_id *ptr);\n\npublic:\n  inline /* implicit */ multi_id();\n  inline /* implicit */ multi_id(const multi_id &obj);\n  inline /* implicit */ multi_id(std::nullptr_t);\n  inline explicit multi_id(space space, id_list list);\n  inline explicit multi_id(ctx ctx, const std::string &str);\n  inline multi_id &operator=(multi_id obj);\n  inline ~multi_id();\n  inline __isl_give isl_multi_id *copy() const &;\n  inline __isl_give isl_multi_id *copy() && = delete;\n  inline __isl_keep isl_multi_id *get() const;\n  inline __isl_give isl_multi_id *release();\n  inline bool is_null() const;\n  inline explicit operator bool() const;\n  inline ctx get_ctx() const;\n  inline std::string to_str() const;\n  inline void dump() const;\n\n  inline multi_id align_params(space model) const;\n  inline multi_id factor_range() const;\n  inline multi_id flat_range_product(multi_id multi2) const;\n  inline multi_id flatten_range() const;\n  inline multi_id from_range() const;\n  inline id get_at(int pos) const;\n  inline space get_domain_space() const;\n  inline id get_id(int pos) const;\n  inline id_list get_list() const;\n  inline space get_space() const;\n  inline boolean plain_is_equal(const multi_id &multi2) const;\n  inline multi_id range_factor_domain() const;\n  inline multi_id range_factor_range() const;\n  inline boolean range_is_wrapping() const;\n  inline multi_id range_product(multi_id multi2) const;\n  inline multi_id range_splice(unsigned int pos, multi_id multi2) const;\n  inline multi_id reset_user() const;\n  inline multi_id set_at(int pos, id el) const;\n  inline multi_id set_id(int pos, id el) const;\n  inline isl_size size() const;\n};\n\n// declarations for isl::multi_pw_aff\ninline multi_pw_aff manage(__isl_take isl_multi_pw_aff *ptr);\ninline multi_pw_aff manage_copy(__isl_keep isl_multi_pw_aff *ptr);\n\nclass multi_pw_aff {\n  friend inline multi_pw_aff manage(__isl_take isl_multi_pw_aff *ptr);\n  friend inline multi_pw_aff manage_copy(__isl_keep isl_multi_pw_aff *ptr);\n\n  isl_multi_pw_aff *ptr = nullptr;\n\n  inline explicit multi_pw_aff(__isl_take isl_multi_pw_aff *ptr);\n\npublic:\n  inline /* implicit */ multi_pw_aff();\n  inline /* implicit */ multi_pw_aff(const multi_pw_aff &obj);\n  inline /* implicit */ multi_pw_aff(std::nullptr_t);\n  inline /* implicit */ multi_pw_aff(aff aff);\n  inline /* implicit */ multi_pw_aff(multi_aff ma);\n  inline /* implicit */ multi_pw_aff(pw_aff pa);\n  inline explicit multi_pw_aff(space space, pw_aff_list list);\n  inline /* implicit */ multi_pw_aff(pw_multi_aff pma);\n  inline explicit multi_pw_aff(ctx ctx, const std::string &str);\n  inline multi_pw_aff &operator=(multi_pw_aff obj);\n  inline ~multi_pw_aff();\n  inline __isl_give isl_multi_pw_aff *copy() const &;\n  inline __isl_give isl_multi_pw_aff *copy() && = delete;\n  inline __isl_keep isl_multi_pw_aff *get() const;\n  inline __isl_give isl_multi_pw_aff *release();\n  inline bool is_null() const;\n  inline explicit operator bool() const;\n  inline ctx get_ctx() const;\n  inline std::string to_str() const;\n  inline void dump() const;\n\n  inline multi_pw_aff add(multi_pw_aff multi2) const;\n  inline multi_pw_aff add_constant(multi_val mv) const;\n  inline multi_pw_aff add_constant(val v) const;\n  inline multi_pw_aff add_dims(isl::dim type, unsigned int n) const;\n  inline multi_pw_aff align_params(space model) const;\n  inline set bind(multi_id tuple) const;\n  inline multi_pw_aff bind_domain(multi_id tuple) const;\n  inline multi_pw_aff bind_domain_wrapped_domain(multi_id tuple) const;\n  inline multi_pw_aff coalesce() const;\n  inline isl_size dim(isl::dim type) const;\n  inline set domain() const;\n  inline multi_pw_aff drop_dims(isl::dim type, unsigned int first, unsigned int n) const;\n  inline map eq_map(multi_pw_aff mpa2) const;\n  inline multi_pw_aff factor_range() const;\n  inline int find_dim_by_id(isl::dim type, const id &id) const;\n  inline int find_dim_by_name(isl::dim type, const std::string &name) const;\n  inline multi_pw_aff flat_range_product(multi_pw_aff multi2) const;\n  inline multi_pw_aff flatten_range() const;\n  inline multi_pw_aff from_range() const;\n  inline pw_aff get_at(int pos) const;\n  inline id get_dim_id(isl::dim type, unsigned int pos) const;\n  inline space get_domain_space() const;\n  inline uint32_t get_hash() const;\n  inline pw_aff_list get_list() const;\n  inline pw_aff get_pw_aff(int pos) const;\n  inline space get_space() const;\n  inline id get_tuple_id(isl::dim type) const;\n  inline std::string get_tuple_name(isl::dim type) const;\n  inline multi_pw_aff gist(set set) const;\n  inline multi_pw_aff gist_params(set set) const;\n  inline boolean has_tuple_id(isl::dim type) const;\n  static inline multi_pw_aff identity(space space);\n  inline multi_pw_aff identity() const;\n  static inline multi_pw_aff identity_on_domain(space space);\n  inline multi_pw_aff insert_dims(isl::dim type, unsigned int first, unsigned int n) const;\n  inline multi_pw_aff insert_domain(space domain) const;\n  inline multi_pw_aff intersect_domain(set domain) const;\n  inline multi_pw_aff intersect_params(set set) const;\n  inline boolean involves_dims(isl::dim type, unsigned int first, unsigned int n) const;\n  inline boolean involves_nan() const;\n  inline boolean involves_param(const id &id) const;\n  inline boolean involves_param(const id_list &list) const;\n  inline boolean is_cst() const;\n  inline boolean is_equal(const multi_pw_aff &mpa2) const;\n  inline map lex_ge_map(multi_pw_aff mpa2) const;\n  inline map lex_gt_map(multi_pw_aff mpa2) const;\n  inline map lex_le_map(multi_pw_aff mpa2) const;\n  inline map lex_lt_map(multi_pw_aff mpa2) const;\n  inline multi_pw_aff max(multi_pw_aff multi2) const;\n  inline multi_val max_multi_val() const;\n  inline multi_pw_aff min(multi_pw_aff multi2) const;\n  inline multi_val min_multi_val() const;\n  inline multi_pw_aff mod_multi_val(multi_val mv) const;\n  inline multi_pw_aff move_dims(isl::dim dst_type, unsigned int dst_pos, isl::dim src_type, unsigned int src_pos, unsigned int n) const;\n  inline multi_pw_aff neg() const;\n  inline boolean plain_is_equal(const multi_pw_aff &multi2) const;\n  inline multi_pw_aff product(multi_pw_aff multi2) const;\n  inline multi_pw_aff project_domain_on_params() const;\n  inline multi_pw_aff pullback(multi_aff ma) const;\n  inline multi_pw_aff pullback(multi_pw_aff mpa2) const;\n  inline multi_pw_aff pullback(pw_multi_aff pma) const;\n  inline multi_pw_aff range_factor_domain() const;\n  inline multi_pw_aff range_factor_range() const;\n  inline boolean range_is_wrapping() const;\n  inline multi_pw_aff range_product(multi_pw_aff multi2) const;\n  inline multi_pw_aff range_splice(unsigned int pos, multi_pw_aff multi2) const;\n  inline multi_pw_aff reset_tuple_id(isl::dim type) const;\n  inline multi_pw_aff reset_user() const;\n  inline multi_pw_aff scale(multi_val mv) const;\n  inline multi_pw_aff scale(val v) const;\n  inline multi_pw_aff scale_down(multi_val mv) const;\n  inline multi_pw_aff scale_down(val v) const;\n  inline multi_pw_aff set_at(int pos, pw_aff el) const;\n  inline multi_pw_aff set_dim_id(isl::dim type, unsigned int pos, id id) const;\n  inline multi_pw_aff set_pw_aff(int pos, pw_aff el) const;\n  inline multi_pw_aff set_tuple_id(isl::dim type, id id) const;\n  inline multi_pw_aff set_tuple_name(isl::dim type, const std::string &s) const;\n  inline isl_size size() const;\n  inline multi_pw_aff splice(unsigned int in_pos, unsigned int out_pos, multi_pw_aff multi2) const;\n  inline multi_pw_aff sub(multi_pw_aff multi2) const;\n  inline multi_pw_aff unbind_params_insert_domain(multi_id domain) const;\n  inline multi_pw_aff union_add(multi_pw_aff mpa2) const;\n  static inline multi_pw_aff zero(space space);\n};\n\n// declarations for isl::multi_union_pw_aff\ninline multi_union_pw_aff manage(__isl_take isl_multi_union_pw_aff *ptr);\ninline multi_union_pw_aff manage_copy(__isl_keep isl_multi_union_pw_aff *ptr);\n\nclass multi_union_pw_aff {\n  friend inline multi_union_pw_aff manage(__isl_take isl_multi_union_pw_aff *ptr);\n  friend inline multi_union_pw_aff manage_copy(__isl_keep isl_multi_union_pw_aff *ptr);\n\n  isl_multi_union_pw_aff *ptr = nullptr;\n\n  inline explicit multi_union_pw_aff(__isl_take isl_multi_union_pw_aff *ptr);\n\npublic:\n  inline /* implicit */ multi_union_pw_aff();\n  inline /* implicit */ multi_union_pw_aff(const multi_union_pw_aff &obj);\n  inline /* implicit */ multi_union_pw_aff(std::nullptr_t);\n  inline /* implicit */ multi_union_pw_aff(multi_pw_aff mpa);\n  inline /* implicit */ multi_union_pw_aff(union_pw_aff upa);\n  inline explicit multi_union_pw_aff(space space, union_pw_aff_list list);\n  inline explicit multi_union_pw_aff(union_pw_multi_aff upma);\n  inline explicit multi_union_pw_aff(ctx ctx, const std::string &str);\n  inline multi_union_pw_aff &operator=(multi_union_pw_aff obj);\n  inline ~multi_union_pw_aff();\n  inline __isl_give isl_multi_union_pw_aff *copy() const &;\n  inline __isl_give isl_multi_union_pw_aff *copy() && = delete;\n  inline __isl_keep isl_multi_union_pw_aff *get() const;\n  inline __isl_give isl_multi_union_pw_aff *release();\n  inline bool is_null() const;\n  inline explicit operator bool() const;\n  inline ctx get_ctx() const;\n  inline std::string to_str() const;\n  inline void dump() const;\n\n  inline multi_union_pw_aff add(multi_union_pw_aff multi2) const;\n  inline multi_union_pw_aff align_params(space model) const;\n  inline union_pw_aff apply_aff(aff aff) const;\n  inline union_pw_aff apply_pw_aff(pw_aff pa) const;\n  inline multi_union_pw_aff apply_pw_multi_aff(pw_multi_aff pma) const;\n  inline union_set bind(multi_id tuple) const;\n  inline multi_union_pw_aff coalesce() const;\n  inline isl_size dim(isl::dim type) const;\n  inline union_set domain() const;\n  inline multi_union_pw_aff drop_dims(isl::dim type, unsigned int first, unsigned int n) const;\n  inline multi_pw_aff extract_multi_pw_aff(space space) const;\n  inline multi_union_pw_aff factor_range() const;\n  inline int find_dim_by_id(isl::dim type, const id &id) const;\n  inline int find_dim_by_name(isl::dim type, const std::string &name) const;\n  inline multi_union_pw_aff flat_range_product(multi_union_pw_aff multi2) const;\n  inline multi_union_pw_aff flatten_range() const;\n  inline multi_union_pw_aff floor() const;\n  static inline multi_union_pw_aff from_multi_aff(multi_aff ma);\n  inline multi_union_pw_aff from_range() const;\n  static inline multi_union_pw_aff from_union_map(union_map umap);\n  inline union_pw_aff get_at(int pos) const;\n  inline id get_dim_id(isl::dim type, unsigned int pos) const;\n  inline space get_domain_space() const;\n  inline union_pw_aff_list get_list() const;\n  inline space get_space() const;\n  inline id get_tuple_id(isl::dim type) const;\n  inline std::string get_tuple_name(isl::dim type) const;\n  inline union_pw_aff get_union_pw_aff(int pos) const;\n  inline multi_union_pw_aff gist(union_set context) const;\n  inline multi_union_pw_aff gist_params(set context) const;\n  inline boolean has_tuple_id(isl::dim type) const;\n  inline multi_union_pw_aff intersect_domain(union_set uset) const;\n  inline multi_union_pw_aff intersect_params(set params) const;\n  inline multi_union_pw_aff intersect_range(set set) const;\n  inline boolean involves_nan() const;\n  inline multi_val max_multi_val() const;\n  inline multi_val min_multi_val() const;\n  inline multi_union_pw_aff mod_multi_val(multi_val mv) const;\n  static inline multi_union_pw_aff multi_aff_on_domain(union_set domain, multi_aff ma);\n  static inline multi_union_pw_aff multi_val_on_domain(union_set domain, multi_val mv);\n  inline multi_union_pw_aff neg() const;\n  inline boolean plain_is_equal(const multi_union_pw_aff &multi2) const;\n  inline multi_union_pw_aff pullback(union_pw_multi_aff upma) const;\n  static inline multi_union_pw_aff pw_multi_aff_on_domain(union_set domain, pw_multi_aff pma);\n  inline multi_union_pw_aff range_factor_domain() const;\n  inline multi_union_pw_aff range_factor_range() const;\n  inline boolean range_is_wrapping() const;\n  inline multi_union_pw_aff range_product(multi_union_pw_aff multi2) const;\n  inline multi_union_pw_aff range_splice(unsigned int pos, multi_union_pw_aff multi2) const;\n  inline multi_union_pw_aff reset_tuple_id(isl::dim type) const;\n  inline multi_union_pw_aff reset_user() const;\n  inline multi_union_pw_aff scale(multi_val mv) const;\n  inline multi_union_pw_aff scale(val v) const;\n  inline multi_union_pw_aff scale_down(multi_val mv) const;\n  inline multi_union_pw_aff scale_down(val v) const;\n  inline multi_union_pw_aff set_at(int pos, union_pw_aff el) const;\n  inline multi_union_pw_aff set_dim_id(isl::dim type, unsigned int pos, id id) const;\n  inline multi_union_pw_aff set_tuple_id(isl::dim type, id id) const;\n  inline multi_union_pw_aff set_tuple_name(isl::dim type, const std::string &s) const;\n  inline multi_union_pw_aff set_union_pw_aff(int pos, union_pw_aff el) const;\n  inline isl_size size() const;\n  inline multi_union_pw_aff sub(multi_union_pw_aff multi2) const;\n  inline multi_union_pw_aff union_add(multi_union_pw_aff mupa2) const;\n  static inline multi_union_pw_aff zero(space space);\n  inline union_set zero_union_set() const;\n};\n\n// declarations for isl::multi_val\ninline multi_val manage(__isl_take isl_multi_val *ptr);\ninline multi_val manage_copy(__isl_keep isl_multi_val *ptr);\n\nclass multi_val {\n  friend inline multi_val manage(__isl_take isl_multi_val *ptr);\n  friend inline multi_val manage_copy(__isl_keep isl_multi_val *ptr);\n\n  isl_multi_val *ptr = nullptr;\n\n  inline explicit multi_val(__isl_take isl_multi_val *ptr);\n\npublic:\n  inline /* implicit */ multi_val();\n  inline /* implicit */ multi_val(const multi_val &obj);\n  inline /* implicit */ multi_val(std::nullptr_t);\n  inline explicit multi_val(space space, val_list list);\n  inline explicit multi_val(ctx ctx, const std::string &str);\n  inline multi_val &operator=(multi_val obj);\n  inline ~multi_val();\n  inline __isl_give isl_multi_val *copy() const &;\n  inline __isl_give isl_multi_val *copy() && = delete;\n  inline __isl_keep isl_multi_val *get() const;\n  inline __isl_give isl_multi_val *release();\n  inline bool is_null() const;\n  inline explicit operator bool() const;\n  inline ctx get_ctx() const;\n  inline std::string to_str() const;\n  inline void dump() const;\n\n  inline multi_val add(multi_val multi2) const;\n  inline multi_val add(val v) const;\n  inline multi_val add_dims(isl::dim type, unsigned int n) const;\n  inline multi_val align_params(space model) const;\n  inline isl_size dim(isl::dim type) const;\n  inline multi_val drop_dims(isl::dim type, unsigned int first, unsigned int n) const;\n  inline multi_val factor_range() const;\n  inline int find_dim_by_id(isl::dim type, const id &id) const;\n  inline int find_dim_by_name(isl::dim type, const std::string &name) const;\n  inline multi_val flat_range_product(multi_val multi2) const;\n  inline multi_val flatten_range() const;\n  inline multi_val from_range() const;\n  inline val get_at(int pos) const;\n  inline id get_dim_id(isl::dim type, unsigned int pos) const;\n  inline space get_domain_space() const;\n  inline val_list get_list() const;\n  inline space get_space() const;\n  inline id get_tuple_id(isl::dim type) const;\n  inline std::string get_tuple_name(isl::dim type) const;\n  inline val get_val(int pos) const;\n  inline boolean has_tuple_id(isl::dim type) const;\n  inline multi_val insert_dims(isl::dim type, unsigned int first, unsigned int n) const;\n  inline boolean involves_dims(isl::dim type, unsigned int first, unsigned int n) const;\n  inline boolean involves_nan() const;\n  inline boolean is_zero() const;\n  inline multi_val max(multi_val multi2) const;\n  inline multi_val min(multi_val multi2) const;\n  inline multi_val mod_multi_val(multi_val mv) const;\n  inline multi_val mod_val(val v) const;\n  inline multi_val neg() const;\n  inline boolean plain_is_equal(const multi_val &multi2) const;\n  inline multi_val product(multi_val multi2) const;\n  inline multi_val project_domain_on_params() const;\n  inline multi_val range_factor_domain() const;\n  inline multi_val range_factor_range() const;\n  inline boolean range_is_wrapping() const;\n  inline multi_val range_product(multi_val multi2) const;\n  inline multi_val range_splice(unsigned int pos, multi_val multi2) const;\n  inline multi_val reset_tuple_id(isl::dim type) const;\n  inline multi_val reset_user() const;\n  inline multi_val scale(multi_val mv) const;\n  inline multi_val scale(val v) const;\n  inline multi_val scale_down(multi_val mv) const;\n  inline multi_val scale_down(val v) const;\n  inline multi_val set_at(int pos, val el) const;\n  inline multi_val set_dim_id(isl::dim type, unsigned int pos, id id) const;\n  inline multi_val set_tuple_id(isl::dim type, id id) const;\n  inline multi_val set_tuple_name(isl::dim type, const std::string &s) const;\n  inline multi_val set_val(int pos, val el) const;\n  inline isl_size size() const;\n  inline multi_val splice(unsigned int in_pos, unsigned int out_pos, multi_val multi2) const;\n  inline multi_val sub(multi_val multi2) const;\n  static inline multi_val zero(space space);\n};\n\n// declarations for isl::point\ninline point manage(__isl_take isl_point *ptr);\ninline point manage_copy(__isl_keep isl_point *ptr);\n\nclass point {\n  friend inline point manage(__isl_take isl_point *ptr);\n  friend inline point manage_copy(__isl_keep isl_point *ptr);\n\n  isl_point *ptr = nullptr;\n\n  inline explicit point(__isl_take isl_point *ptr);\n\npublic:\n  inline /* implicit */ point();\n  inline /* implicit */ point(const point &obj);\n  inline /* implicit */ point(std::nullptr_t);\n  inline explicit point(space dim);\n  inline point &operator=(point obj);\n  inline ~point();\n  inline __isl_give isl_point *copy() const &;\n  inline __isl_give isl_point *copy() && = delete;\n  inline __isl_keep isl_point *get() const;\n  inline __isl_give isl_point *release();\n  inline bool is_null() const;\n  inline explicit operator bool() const;\n  inline ctx get_ctx() const;\n  inline std::string to_str() const;\n  inline void dump() const;\n\n  inline point add_ui(isl::dim type, int pos, unsigned int val) const;\n  inline val get_coordinate_val(isl::dim type, int pos) const;\n  inline multi_val get_multi_val() const;\n  inline space get_space() const;\n  inline point set_coordinate_val(isl::dim type, int pos, val v) const;\n  inline point sub_ui(isl::dim type, int pos, unsigned int val) const;\n};\n\n// declarations for isl::pw_aff\ninline pw_aff manage(__isl_take isl_pw_aff *ptr);\ninline pw_aff manage_copy(__isl_keep isl_pw_aff *ptr);\n\nclass pw_aff {\n  friend inline pw_aff manage(__isl_take isl_pw_aff *ptr);\n  friend inline pw_aff manage_copy(__isl_keep isl_pw_aff *ptr);\n\n  isl_pw_aff *ptr = nullptr;\n\n  inline explicit pw_aff(__isl_take isl_pw_aff *ptr);\n\npublic:\n  inline /* implicit */ pw_aff();\n  inline /* implicit */ pw_aff(const pw_aff &obj);\n  inline /* implicit */ pw_aff(std::nullptr_t);\n  inline /* implicit */ pw_aff(aff aff);\n  inline explicit pw_aff(ctx ctx, const std::string &str);\n  inline explicit pw_aff(set domain, val v);\n  inline explicit pw_aff(local_space ls);\n  inline pw_aff &operator=(pw_aff obj);\n  inline ~pw_aff();\n  inline __isl_give isl_pw_aff *copy() const &;\n  inline __isl_give isl_pw_aff *copy() && = delete;\n  inline __isl_keep isl_pw_aff *get() const;\n  inline __isl_give isl_pw_aff *release();\n  inline bool is_null() const;\n  inline explicit operator bool() const;\n  inline ctx get_ctx() const;\n  inline std::string to_str() const;\n  inline void dump() const;\n\n  inline pw_aff add(pw_aff pwaff2) const;\n  inline pw_aff add_constant(val v) const;\n  inline pw_aff add_dims(isl::dim type, unsigned int n) const;\n  inline pw_aff align_params(space model) const;\n  static inline pw_aff alloc(set set, aff aff);\n  inline aff as_aff() const;\n  inline set bind(id id) const;\n  inline pw_aff bind_domain(multi_id tuple) const;\n  inline pw_aff bind_domain_wrapped_domain(multi_id tuple) const;\n  inline pw_aff ceil() const;\n  inline pw_aff coalesce() const;\n  inline pw_aff cond(pw_aff pwaff_true, pw_aff pwaff_false) const;\n  inline isl_size dim(isl::dim type) const;\n  inline pw_aff div(pw_aff pa2) const;\n  inline set domain() const;\n  inline pw_aff drop_dims(isl::dim type, unsigned int first, unsigned int n) const;\n  inline pw_aff drop_unused_params() const;\n  static inline pw_aff empty(space space);\n  inline map eq_map(pw_aff pa2) const;\n  inline set eq_set(pw_aff pwaff2) const;\n  inline val eval(point pnt) const;\n  inline int find_dim_by_name(isl::dim type, const std::string &name) const;\n  inline pw_aff floor() const;\n  inline stat foreach_piece(const std::function<stat(set, aff)> &fn) const;\n  inline pw_aff from_range() const;\n  inline map ge_map(pw_aff pa2) const;\n  inline set ge_set(pw_aff pwaff2) const;\n  inline id get_dim_id(isl::dim type, unsigned int pos) const;\n  inline std::string get_dim_name(isl::dim type, unsigned int pos) const;\n  inline space get_domain_space() const;\n  inline uint32_t get_hash() const;\n  inline space get_space() const;\n  inline id get_tuple_id(isl::dim type) const;\n  inline pw_aff gist(set context) const;\n  inline pw_aff gist_params(set context) const;\n  inline map gt_map(pw_aff pa2) const;\n  inline set gt_set(pw_aff pwaff2) const;\n  inline boolean has_dim_id(isl::dim type, unsigned int pos) const;\n  inline boolean has_tuple_id(isl::dim type) const;\n  inline pw_aff insert_dims(isl::dim type, unsigned int first, unsigned int n) const;\n  inline pw_aff insert_domain(space domain) const;\n  inline pw_aff intersect_domain(set set) const;\n  inline pw_aff intersect_domain_wrapped_domain(set set) const;\n  inline pw_aff intersect_domain_wrapped_range(set set) const;\n  inline pw_aff intersect_params(set set) const;\n  inline boolean involves_dims(isl::dim type, unsigned int first, unsigned int n) const;\n  inline boolean involves_nan() const;\n  inline boolean involves_param_id(const id &id) const;\n  inline boolean is_cst() const;\n  inline boolean is_empty() const;\n  inline boolean is_equal(const pw_aff &pa2) const;\n  inline boolean isa_aff() const;\n  inline map le_map(pw_aff pa2) const;\n  inline set le_set(pw_aff pwaff2) const;\n  inline map lt_map(pw_aff pa2) const;\n  inline set lt_set(pw_aff pwaff2) const;\n  inline pw_aff max(pw_aff pwaff2) const;\n  inline pw_aff min(pw_aff pwaff2) const;\n  inline pw_aff mod(val mod) const;\n  inline pw_aff move_dims(isl::dim dst_type, unsigned int dst_pos, isl::dim src_type, unsigned int src_pos, unsigned int n) const;\n  inline pw_aff mul(pw_aff pwaff2) const;\n  inline isl_size n_piece() const;\n  static inline pw_aff nan_on_domain(local_space ls);\n  static inline pw_aff nan_on_domain_space(space space);\n  inline set ne_set(pw_aff pwaff2) const;\n  inline pw_aff neg() const;\n  inline set non_zero_set() const;\n  inline set nonneg_set() const;\n  static inline pw_aff param_on_domain(set domain, id id);\n  inline set params() const;\n  inline int plain_cmp(const pw_aff &pa2) const;\n  inline boolean plain_is_equal(const pw_aff &pwaff2) const;\n  inline set pos_set() const;\n  inline pw_aff project_domain_on_params() const;\n  inline pw_aff pullback(multi_aff ma) const;\n  inline pw_aff pullback(multi_pw_aff mpa) const;\n  inline pw_aff pullback(pw_multi_aff pma) const;\n  inline pw_aff reset_tuple_id(isl::dim type) const;\n  inline pw_aff reset_user() const;\n  inline pw_aff scale(val v) const;\n  inline pw_aff scale_down(val f) const;\n  inline pw_aff set_dim_id(isl::dim type, unsigned int pos, id id) const;\n  inline pw_aff set_tuple_id(isl::dim type, id id) const;\n  inline pw_aff sub(pw_aff pwaff2) const;\n  inline pw_aff subtract_domain(set set) const;\n  inline pw_aff tdiv_q(pw_aff pa2) const;\n  inline pw_aff tdiv_r(pw_aff pa2) const;\n  inline pw_aff union_add(pw_aff pwaff2) const;\n  inline pw_aff union_max(pw_aff pwaff2) const;\n  inline pw_aff union_min(pw_aff pwaff2) const;\n  static inline pw_aff var_on_domain(local_space ls, isl::dim type, unsigned int pos);\n  inline set zero_set() const;\n};\n\n// declarations for isl::pw_aff_list\ninline pw_aff_list manage(__isl_take isl_pw_aff_list *ptr);\ninline pw_aff_list manage_copy(__isl_keep isl_pw_aff_list *ptr);\n\nclass pw_aff_list {\n  friend inline pw_aff_list manage(__isl_take isl_pw_aff_list *ptr);\n  friend inline pw_aff_list manage_copy(__isl_keep isl_pw_aff_list *ptr);\n\n  isl_pw_aff_list *ptr = nullptr;\n\n  inline explicit pw_aff_list(__isl_take isl_pw_aff_list *ptr);\n\npublic:\n  inline /* implicit */ pw_aff_list();\n  inline /* implicit */ pw_aff_list(const pw_aff_list &obj);\n  inline /* implicit */ pw_aff_list(std::nullptr_t);\n  inline pw_aff_list &operator=(pw_aff_list obj);\n  inline ~pw_aff_list();\n  inline __isl_give isl_pw_aff_list *copy() const &;\n  inline __isl_give isl_pw_aff_list *copy() && = delete;\n  inline __isl_keep isl_pw_aff_list *get() const;\n  inline __isl_give isl_pw_aff_list *release();\n  inline bool is_null() const;\n  inline explicit operator bool() const;\n  inline ctx get_ctx() const;\n  inline std::string to_str() const;\n  inline void dump() const;\n\n  inline pw_aff_list add(pw_aff el) const;\n  static inline pw_aff_list alloc(ctx ctx, int n);\n  inline pw_aff_list clear() const;\n  inline pw_aff_list concat(pw_aff_list list2) const;\n  inline pw_aff_list drop(unsigned int first, unsigned int n) const;\n  inline set eq_set(pw_aff_list list2) const;\n  inline stat foreach(const std::function<stat(pw_aff)> &fn) const;\n  static inline pw_aff_list from_pw_aff(pw_aff el);\n  inline set ge_set(pw_aff_list list2) const;\n  inline pw_aff get_at(int index) const;\n  inline pw_aff get_pw_aff(int index) const;\n  inline set gt_set(pw_aff_list list2) const;\n  inline pw_aff_list insert(unsigned int pos, pw_aff el) const;\n  inline set le_set(pw_aff_list list2) const;\n  inline set lt_set(pw_aff_list list2) const;\n  inline pw_aff max() const;\n  inline pw_aff min() const;\n  inline isl_size n_pw_aff() const;\n  inline set ne_set(pw_aff_list list2) const;\n  inline pw_aff_list reverse() const;\n  inline pw_aff_list set_pw_aff(int index, pw_aff el) const;\n  inline isl_size size() const;\n  inline pw_aff_list swap(unsigned int pos1, unsigned int pos2) const;\n};\n\n// declarations for isl::pw_multi_aff\ninline pw_multi_aff manage(__isl_take isl_pw_multi_aff *ptr);\ninline pw_multi_aff manage_copy(__isl_keep isl_pw_multi_aff *ptr);\n\nclass pw_multi_aff {\n  friend inline pw_multi_aff manage(__isl_take isl_pw_multi_aff *ptr);\n  friend inline pw_multi_aff manage_copy(__isl_keep isl_pw_multi_aff *ptr);\n\n  isl_pw_multi_aff *ptr = nullptr;\n\n  inline explicit pw_multi_aff(__isl_take isl_pw_multi_aff *ptr);\n\npublic:\n  inline /* implicit */ pw_multi_aff();\n  inline /* implicit */ pw_multi_aff(const pw_multi_aff &obj);\n  inline /* implicit */ pw_multi_aff(std::nullptr_t);\n  inline /* implicit */ pw_multi_aff(multi_aff ma);\n  inline /* implicit */ pw_multi_aff(pw_aff pa);\n  inline explicit pw_multi_aff(ctx ctx, const std::string &str);\n  inline pw_multi_aff &operator=(pw_multi_aff obj);\n  inline ~pw_multi_aff();\n  inline __isl_give isl_pw_multi_aff *copy() const &;\n  inline __isl_give isl_pw_multi_aff *copy() && = delete;\n  inline __isl_keep isl_pw_multi_aff *get() const;\n  inline __isl_give isl_pw_multi_aff *release();\n  inline bool is_null() const;\n  inline explicit operator bool() const;\n  inline ctx get_ctx() const;\n  inline std::string to_str() const;\n  inline void dump() const;\n\n  inline pw_multi_aff add(pw_multi_aff pma2) const;\n  inline pw_multi_aff add_constant(multi_val mv) const;\n  inline pw_multi_aff add_constant(val v) const;\n  inline pw_multi_aff align_params(space model) const;\n  static inline pw_multi_aff alloc(set set, multi_aff maff);\n  inline multi_aff as_multi_aff() const;\n  inline pw_multi_aff bind_domain(multi_id tuple) const;\n  inline pw_multi_aff bind_domain_wrapped_domain(multi_id tuple) const;\n  inline pw_multi_aff coalesce() const;\n  inline isl_size dim(isl::dim type) const;\n  inline set domain() const;\n  static inline pw_multi_aff domain_map(space space);\n  inline pw_multi_aff drop_dims(isl::dim type, unsigned int first, unsigned int n) const;\n  inline pw_multi_aff drop_unused_params() const;\n  static inline pw_multi_aff empty(space space);\n  inline int find_dim_by_name(isl::dim type, const std::string &name) const;\n  inline pw_multi_aff fix_si(isl::dim type, unsigned int pos, int value) const;\n  inline pw_multi_aff flat_range_product(pw_multi_aff pma2) const;\n  inline stat foreach_piece(const std::function<stat(set, multi_aff)> &fn) const;\n  static inline pw_multi_aff from_domain(set set);\n  static inline pw_multi_aff from_map(map map);\n  static inline pw_multi_aff from_multi_pw_aff(multi_pw_aff mpa);\n  static inline pw_multi_aff from_set(set set);\n  inline id get_dim_id(isl::dim type, unsigned int pos) const;\n  inline std::string get_dim_name(isl::dim type, unsigned int pos) const;\n  inline space get_domain_space() const;\n  inline pw_aff get_pw_aff(int pos) const;\n  inline space get_space() const;\n  inline id get_tuple_id(isl::dim type) const;\n  inline std::string get_tuple_name(isl::dim type) const;\n  inline pw_multi_aff gist(set set) const;\n  inline pw_multi_aff gist_params(set set) const;\n  inline boolean has_tuple_id(isl::dim type) const;\n  inline boolean has_tuple_name(isl::dim type) const;\n  static inline pw_multi_aff identity(space space);\n  static inline pw_multi_aff identity_on_domain(space space);\n  inline pw_multi_aff insert_domain(space domain) const;\n  inline pw_multi_aff intersect_domain(set set) const;\n  inline pw_multi_aff intersect_domain_wrapped_domain(set set) const;\n  inline pw_multi_aff intersect_domain_wrapped_range(set set) const;\n  inline pw_multi_aff intersect_params(set set) const;\n  inline boolean involves_dims(isl::dim type, unsigned int first, unsigned int n) const;\n  inline boolean involves_locals() const;\n  inline boolean involves_nan() const;\n  inline boolean involves_param_id(const id &id) const;\n  inline boolean is_equal(const pw_multi_aff &pma2) const;\n  inline boolean isa_multi_aff() const;\n  inline multi_val max_multi_val() const;\n  inline multi_val min_multi_val() const;\n  static inline pw_multi_aff multi_val_on_domain(set domain, multi_val mv);\n  inline isl_size n_piece() const;\n  inline pw_multi_aff neg() const;\n  inline boolean plain_is_equal(const pw_multi_aff &pma2) const;\n  inline pw_multi_aff preimage_domain_wrapped_domain(pw_multi_aff pma2) const;\n  inline pw_multi_aff product(pw_multi_aff pma2) const;\n  inline pw_multi_aff project_domain_on_params() const;\n  static inline pw_multi_aff project_out_map(space space, isl::dim type, unsigned int first, unsigned int n);\n  inline pw_multi_aff pullback(multi_aff ma) const;\n  inline pw_multi_aff pullback(pw_multi_aff pma2) const;\n  inline pw_multi_aff range_factor_domain() const;\n  inline pw_multi_aff range_factor_range() const;\n  static inline pw_multi_aff range_map(space space);\n  inline pw_multi_aff range_product(pw_multi_aff pma2) const;\n  inline pw_multi_aff reset_tuple_id(isl::dim type) const;\n  inline pw_multi_aff reset_user() const;\n  inline pw_multi_aff scale(val v) const;\n  inline pw_multi_aff scale_down(val v) const;\n  inline pw_multi_aff scale_multi_val(multi_val mv) const;\n  inline pw_multi_aff set_dim_id(isl::dim type, unsigned int pos, id id) const;\n  inline pw_multi_aff set_pw_aff(unsigned int pos, pw_aff pa) const;\n  inline pw_multi_aff set_tuple_id(isl::dim type, id id) const;\n  inline pw_multi_aff sub(pw_multi_aff pma2) const;\n  inline pw_multi_aff subtract_domain(set set) const;\n  inline pw_multi_aff union_add(pw_multi_aff pma2) const;\n  inline pw_multi_aff union_lexmax(pw_multi_aff pma2) const;\n  inline pw_multi_aff union_lexmin(pw_multi_aff pma2) const;\n  static inline pw_multi_aff zero(space space);\n};\n\n// declarations for isl::pw_multi_aff_list\ninline pw_multi_aff_list manage(__isl_take isl_pw_multi_aff_list *ptr);\ninline pw_multi_aff_list manage_copy(__isl_keep isl_pw_multi_aff_list *ptr);\n\nclass pw_multi_aff_list {\n  friend inline pw_multi_aff_list manage(__isl_take isl_pw_multi_aff_list *ptr);\n  friend inline pw_multi_aff_list manage_copy(__isl_keep isl_pw_multi_aff_list *ptr);\n\n  isl_pw_multi_aff_list *ptr = nullptr;\n\n  inline explicit pw_multi_aff_list(__isl_take isl_pw_multi_aff_list *ptr);\n\npublic:\n  inline /* implicit */ pw_multi_aff_list();\n  inline /* implicit */ pw_multi_aff_list(const pw_multi_aff_list &obj);\n  inline /* implicit */ pw_multi_aff_list(std::nullptr_t);\n  inline pw_multi_aff_list &operator=(pw_multi_aff_list obj);\n  inline ~pw_multi_aff_list();\n  inline __isl_give isl_pw_multi_aff_list *copy() const &;\n  inline __isl_give isl_pw_multi_aff_list *copy() && = delete;\n  inline __isl_keep isl_pw_multi_aff_list *get() const;\n  inline __isl_give isl_pw_multi_aff_list *release();\n  inline bool is_null() const;\n  inline explicit operator bool() const;\n  inline ctx get_ctx() const;\n  inline std::string to_str() const;\n  inline void dump() const;\n\n  inline pw_multi_aff_list add(pw_multi_aff el) const;\n  static inline pw_multi_aff_list alloc(ctx ctx, int n);\n  inline pw_multi_aff_list clear() const;\n  inline pw_multi_aff_list concat(pw_multi_aff_list list2) const;\n  inline pw_multi_aff_list drop(unsigned int first, unsigned int n) const;\n  inline stat foreach(const std::function<stat(pw_multi_aff)> &fn) const;\n  static inline pw_multi_aff_list from_pw_multi_aff(pw_multi_aff el);\n  inline pw_multi_aff get_at(int index) const;\n  inline pw_multi_aff get_pw_multi_aff(int index) const;\n  inline pw_multi_aff_list insert(unsigned int pos, pw_multi_aff el) const;\n  inline isl_size n_pw_multi_aff() const;\n  inline pw_multi_aff_list reverse() const;\n  inline pw_multi_aff_list set_pw_multi_aff(int index, pw_multi_aff el) const;\n  inline isl_size size() const;\n  inline pw_multi_aff_list swap(unsigned int pos1, unsigned int pos2) const;\n};\n\n// declarations for isl::pw_qpolynomial\ninline pw_qpolynomial manage(__isl_take isl_pw_qpolynomial *ptr);\ninline pw_qpolynomial manage_copy(__isl_keep isl_pw_qpolynomial *ptr);\n\nclass pw_qpolynomial {\n  friend inline pw_qpolynomial manage(__isl_take isl_pw_qpolynomial *ptr);\n  friend inline pw_qpolynomial manage_copy(__isl_keep isl_pw_qpolynomial *ptr);\n\n  isl_pw_qpolynomial *ptr = nullptr;\n\n  inline explicit pw_qpolynomial(__isl_take isl_pw_qpolynomial *ptr);\n\npublic:\n  inline /* implicit */ pw_qpolynomial();\n  inline /* implicit */ pw_qpolynomial(const pw_qpolynomial &obj);\n  inline /* implicit */ pw_qpolynomial(std::nullptr_t);\n  inline explicit pw_qpolynomial(ctx ctx, const std::string &str);\n  inline pw_qpolynomial &operator=(pw_qpolynomial obj);\n  inline ~pw_qpolynomial();\n  inline __isl_give isl_pw_qpolynomial *copy() const &;\n  inline __isl_give isl_pw_qpolynomial *copy() && = delete;\n  inline __isl_keep isl_pw_qpolynomial *get() const;\n  inline __isl_give isl_pw_qpolynomial *release();\n  inline bool is_null() const;\n  inline explicit operator bool() const;\n  inline ctx get_ctx() const;\n  inline std::string to_str() const;\n  inline void dump() const;\n\n  inline pw_qpolynomial add(pw_qpolynomial pwqp2) const;\n  inline pw_qpolynomial add_dims(isl::dim type, unsigned int n) const;\n  static inline pw_qpolynomial alloc(set set, qpolynomial qp);\n  inline qpolynomial as_qpolynomial() const;\n  inline pw_qpolynomial coalesce() const;\n  inline isl_size dim(isl::dim type) const;\n  inline set domain() const;\n  inline pw_qpolynomial drop_dims(isl::dim type, unsigned int first, unsigned int n) const;\n  inline pw_qpolynomial drop_unused_params() const;\n  inline val eval(point pnt) const;\n  inline int find_dim_by_name(isl::dim type, const std::string &name) const;\n  inline pw_qpolynomial fix_val(isl::dim type, unsigned int n, val v) const;\n  inline stat foreach_piece(const std::function<stat(set, qpolynomial)> &fn) const;\n  static inline pw_qpolynomial from_pw_aff(pw_aff pwaff);\n  static inline pw_qpolynomial from_qpolynomial(qpolynomial qp);\n  inline pw_qpolynomial from_range() const;\n  inline space get_domain_space() const;\n  inline space get_space() const;\n  inline pw_qpolynomial gist(set context) const;\n  inline pw_qpolynomial gist_params(set context) const;\n  inline boolean has_equal_space(const pw_qpolynomial &pwqp2) const;\n  inline pw_qpolynomial insert_dims(isl::dim type, unsigned int first, unsigned int n) const;\n  inline pw_qpolynomial intersect_domain(set set) const;\n  inline pw_qpolynomial intersect_domain_wrapped_domain(set set) const;\n  inline pw_qpolynomial intersect_domain_wrapped_range(set set) const;\n  inline pw_qpolynomial intersect_params(set set) const;\n  inline boolean involves_dims(isl::dim type, unsigned int first, unsigned int n) const;\n  inline boolean involves_nan() const;\n  inline boolean involves_param_id(const id &id) const;\n  inline boolean is_zero() const;\n  inline boolean isa_qpolynomial() const;\n  inline val max() const;\n  inline val min() const;\n  inline pw_qpolynomial move_dims(isl::dim dst_type, unsigned int dst_pos, isl::dim src_type, unsigned int src_pos, unsigned int n) const;\n  inline pw_qpolynomial mul(pw_qpolynomial pwqp2) const;\n  inline isl_size n_piece() const;\n  inline pw_qpolynomial neg() const;\n  inline boolean plain_is_equal(const pw_qpolynomial &pwqp2) const;\n  inline pw_qpolynomial pow(unsigned int exponent) const;\n  inline pw_qpolynomial project_domain_on_params() const;\n  inline pw_qpolynomial reset_domain_space(space space) const;\n  inline pw_qpolynomial reset_user() const;\n  inline pw_qpolynomial scale_down_val(val v) const;\n  inline pw_qpolynomial scale_val(val v) const;\n  inline pw_qpolynomial split_dims(isl::dim type, unsigned int first, unsigned int n) const;\n  inline pw_qpolynomial split_periods(int max_periods) const;\n  inline pw_qpolynomial sub(pw_qpolynomial pwqp2) const;\n  inline pw_qpolynomial subtract_domain(set set) const;\n  inline pw_qpolynomial to_polynomial(int sign) const;\n  static inline pw_qpolynomial zero(space space);\n};\n\n// declarations for isl::pw_qpolynomial_fold_list\ninline pw_qpolynomial_fold_list manage(__isl_take isl_pw_qpolynomial_fold_list *ptr);\ninline pw_qpolynomial_fold_list manage_copy(__isl_keep isl_pw_qpolynomial_fold_list *ptr);\n\nclass pw_qpolynomial_fold_list {\n  friend inline pw_qpolynomial_fold_list manage(__isl_take isl_pw_qpolynomial_fold_list *ptr);\n  friend inline pw_qpolynomial_fold_list manage_copy(__isl_keep isl_pw_qpolynomial_fold_list *ptr);\n\n  isl_pw_qpolynomial_fold_list *ptr = nullptr;\n\n  inline explicit pw_qpolynomial_fold_list(__isl_take isl_pw_qpolynomial_fold_list *ptr);\n\npublic:\n  inline /* implicit */ pw_qpolynomial_fold_list();\n  inline /* implicit */ pw_qpolynomial_fold_list(const pw_qpolynomial_fold_list &obj);\n  inline /* implicit */ pw_qpolynomial_fold_list(std::nullptr_t);\n  inline pw_qpolynomial_fold_list &operator=(pw_qpolynomial_fold_list obj);\n  inline ~pw_qpolynomial_fold_list();\n  inline __isl_give isl_pw_qpolynomial_fold_list *copy() const &;\n  inline __isl_give isl_pw_qpolynomial_fold_list *copy() && = delete;\n  inline __isl_keep isl_pw_qpolynomial_fold_list *get() const;\n  inline __isl_give isl_pw_qpolynomial_fold_list *release();\n  inline bool is_null() const;\n  inline explicit operator bool() const;\n  inline ctx get_ctx() const;\n  inline std::string to_str() const;\n  inline void dump() const;\n\n};\n\n// declarations for isl::pw_qpolynomial_list\ninline pw_qpolynomial_list manage(__isl_take isl_pw_qpolynomial_list *ptr);\ninline pw_qpolynomial_list manage_copy(__isl_keep isl_pw_qpolynomial_list *ptr);\n\nclass pw_qpolynomial_list {\n  friend inline pw_qpolynomial_list manage(__isl_take isl_pw_qpolynomial_list *ptr);\n  friend inline pw_qpolynomial_list manage_copy(__isl_keep isl_pw_qpolynomial_list *ptr);\n\n  isl_pw_qpolynomial_list *ptr = nullptr;\n\n  inline explicit pw_qpolynomial_list(__isl_take isl_pw_qpolynomial_list *ptr);\n\npublic:\n  inline /* implicit */ pw_qpolynomial_list();\n  inline /* implicit */ pw_qpolynomial_list(const pw_qpolynomial_list &obj);\n  inline /* implicit */ pw_qpolynomial_list(std::nullptr_t);\n  inline pw_qpolynomial_list &operator=(pw_qpolynomial_list obj);\n  inline ~pw_qpolynomial_list();\n  inline __isl_give isl_pw_qpolynomial_list *copy() const &;\n  inline __isl_give isl_pw_qpolynomial_list *copy() && = delete;\n  inline __isl_keep isl_pw_qpolynomial_list *get() const;\n  inline __isl_give isl_pw_qpolynomial_list *release();\n  inline bool is_null() const;\n  inline explicit operator bool() const;\n  inline ctx get_ctx() const;\n  inline std::string to_str() const;\n  inline void dump() const;\n\n  inline pw_qpolynomial_list add(pw_qpolynomial el) const;\n  static inline pw_qpolynomial_list alloc(ctx ctx, int n);\n  inline pw_qpolynomial_list clear() const;\n  inline pw_qpolynomial_list concat(pw_qpolynomial_list list2) const;\n  inline pw_qpolynomial_list drop(unsigned int first, unsigned int n) const;\n  inline stat foreach(const std::function<stat(pw_qpolynomial)> &fn) const;\n  static inline pw_qpolynomial_list from_pw_qpolynomial(pw_qpolynomial el);\n  inline pw_qpolynomial get_at(int index) const;\n  inline pw_qpolynomial get_pw_qpolynomial(int index) const;\n  inline pw_qpolynomial_list insert(unsigned int pos, pw_qpolynomial el) const;\n  inline isl_size n_pw_qpolynomial() const;\n  inline pw_qpolynomial_list reverse() const;\n  inline pw_qpolynomial_list set_pw_qpolynomial(int index, pw_qpolynomial el) const;\n  inline isl_size size() const;\n  inline pw_qpolynomial_list swap(unsigned int pos1, unsigned int pos2) const;\n};\n\n// declarations for isl::qpolynomial\ninline qpolynomial manage(__isl_take isl_qpolynomial *ptr);\ninline qpolynomial manage_copy(__isl_keep isl_qpolynomial *ptr);\n\nclass qpolynomial {\n  friend inline qpolynomial manage(__isl_take isl_qpolynomial *ptr);\n  friend inline qpolynomial manage_copy(__isl_keep isl_qpolynomial *ptr);\n\n  isl_qpolynomial *ptr = nullptr;\n\n  inline explicit qpolynomial(__isl_take isl_qpolynomial *ptr);\n\npublic:\n  inline /* implicit */ qpolynomial();\n  inline /* implicit */ qpolynomial(const qpolynomial &obj);\n  inline /* implicit */ qpolynomial(std::nullptr_t);\n  inline qpolynomial &operator=(qpolynomial obj);\n  inline ~qpolynomial();\n  inline __isl_give isl_qpolynomial *copy() const &;\n  inline __isl_give isl_qpolynomial *copy() && = delete;\n  inline __isl_keep isl_qpolynomial *get() const;\n  inline __isl_give isl_qpolynomial *release();\n  inline bool is_null() const;\n  inline explicit operator bool() const;\n  inline ctx get_ctx() const;\n  inline void dump() const;\n\n  inline qpolynomial add(qpolynomial qp2) const;\n  inline qpolynomial add_dims(isl::dim type, unsigned int n) const;\n  inline qpolynomial align_params(space model) const;\n  inline stat as_polynomial_on_domain(const basic_set &bset, const std::function<stat(basic_set, qpolynomial)> &fn) const;\n  inline isl_size dim(isl::dim type) const;\n  inline qpolynomial drop_dims(isl::dim type, unsigned int first, unsigned int n) const;\n  inline val eval(point pnt) const;\n  inline stat foreach_term(const std::function<stat(term)> &fn) const;\n  static inline qpolynomial from_aff(aff aff);\n  static inline qpolynomial from_constraint(constraint c, isl::dim type, unsigned int pos);\n  static inline qpolynomial from_term(term term);\n  inline val get_constant_val() const;\n  inline space get_domain_space() const;\n  inline space get_space() const;\n  inline qpolynomial gist(set context) const;\n  inline qpolynomial gist_params(set context) const;\n  inline qpolynomial homogenize() const;\n  static inline qpolynomial infty_on_domain(space domain);\n  inline qpolynomial insert_dims(isl::dim type, unsigned int first, unsigned int n) const;\n  inline boolean involves_dims(isl::dim type, unsigned int first, unsigned int n) const;\n  inline boolean is_infty() const;\n  inline boolean is_nan() const;\n  inline boolean is_neginfty() const;\n  inline boolean is_zero() const;\n  inline qpolynomial move_dims(isl::dim dst_type, unsigned int dst_pos, isl::dim src_type, unsigned int src_pos, unsigned int n) const;\n  inline qpolynomial mul(qpolynomial qp2) const;\n  static inline qpolynomial nan_on_domain(space domain);\n  inline qpolynomial neg() const;\n  static inline qpolynomial neginfty_on_domain(space domain);\n  static inline qpolynomial one_on_domain(space domain);\n  inline boolean plain_is_equal(const qpolynomial &qp2) const;\n  inline qpolynomial pow(unsigned int power) const;\n  inline qpolynomial project_domain_on_params() const;\n  inline qpolynomial scale_down_val(val v) const;\n  inline qpolynomial scale_val(val v) const;\n  inline int sgn() const;\n  inline qpolynomial sub(qpolynomial qp2) const;\n  static inline qpolynomial val_on_domain(space space, val val);\n  static inline qpolynomial var_on_domain(space domain, isl::dim type, unsigned int pos);\n  static inline qpolynomial zero_on_domain(space domain);\n};\n\n// declarations for isl::qpolynomial_list\ninline qpolynomial_list manage(__isl_take isl_qpolynomial_list *ptr);\ninline qpolynomial_list manage_copy(__isl_keep isl_qpolynomial_list *ptr);\n\nclass qpolynomial_list {\n  friend inline qpolynomial_list manage(__isl_take isl_qpolynomial_list *ptr);\n  friend inline qpolynomial_list manage_copy(__isl_keep isl_qpolynomial_list *ptr);\n\n  isl_qpolynomial_list *ptr = nullptr;\n\n  inline explicit qpolynomial_list(__isl_take isl_qpolynomial_list *ptr);\n\npublic:\n  inline /* implicit */ qpolynomial_list();\n  inline /* implicit */ qpolynomial_list(const qpolynomial_list &obj);\n  inline /* implicit */ qpolynomial_list(std::nullptr_t);\n  inline qpolynomial_list &operator=(qpolynomial_list obj);\n  inline ~qpolynomial_list();\n  inline __isl_give isl_qpolynomial_list *copy() const &;\n  inline __isl_give isl_qpolynomial_list *copy() && = delete;\n  inline __isl_keep isl_qpolynomial_list *get() const;\n  inline __isl_give isl_qpolynomial_list *release();\n  inline bool is_null() const;\n  inline explicit operator bool() const;\n  inline ctx get_ctx() const;\n  inline std::string to_str() const;\n  inline void dump() const;\n\n  inline qpolynomial_list add(qpolynomial el) const;\n  static inline qpolynomial_list alloc(ctx ctx, int n);\n  inline qpolynomial_list clear() const;\n  inline qpolynomial_list concat(qpolynomial_list list2) const;\n  inline qpolynomial_list drop(unsigned int first, unsigned int n) const;\n  inline stat foreach(const std::function<stat(qpolynomial)> &fn) const;\n  static inline qpolynomial_list from_qpolynomial(qpolynomial el);\n  inline qpolynomial get_at(int index) const;\n  inline qpolynomial get_qpolynomial(int index) const;\n  inline qpolynomial_list insert(unsigned int pos, qpolynomial el) const;\n  inline isl_size n_qpolynomial() const;\n  inline qpolynomial_list reverse() const;\n  inline qpolynomial_list set_qpolynomial(int index, qpolynomial el) const;\n  inline isl_size size() const;\n  inline qpolynomial_list swap(unsigned int pos1, unsigned int pos2) const;\n};\n\n// declarations for isl::schedule\ninline schedule manage(__isl_take isl_schedule *ptr);\ninline schedule manage_copy(__isl_keep isl_schedule *ptr);\n\nclass schedule {\n  friend inline schedule manage(__isl_take isl_schedule *ptr);\n  friend inline schedule manage_copy(__isl_keep isl_schedule *ptr);\n\n  isl_schedule *ptr = nullptr;\n\n  inline explicit schedule(__isl_take isl_schedule *ptr);\n\npublic:\n  inline /* implicit */ schedule();\n  inline /* implicit */ schedule(const schedule &obj);\n  inline /* implicit */ schedule(std::nullptr_t);\n  inline explicit schedule(ctx ctx, const std::string &str);\n  inline schedule &operator=(schedule obj);\n  inline ~schedule();\n  inline __isl_give isl_schedule *copy() const &;\n  inline __isl_give isl_schedule *copy() && = delete;\n  inline __isl_keep isl_schedule *get() const;\n  inline __isl_give isl_schedule *release();\n  inline bool is_null() const;\n  inline explicit operator bool() const;\n  inline ctx get_ctx() const;\n  inline std::string to_str() const;\n  inline void dump() const;\n\n  inline schedule align_params(space space) const;\n  static inline schedule empty(space space);\n  static inline schedule from_domain(union_set domain);\n  inline union_set get_domain() const;\n  inline union_map get_map() const;\n  inline schedule_node get_root() const;\n  inline schedule gist_domain_params(set context) const;\n  inline schedule insert_context(set context) const;\n  inline schedule insert_guard(set guard) const;\n  inline schedule insert_partial_schedule(multi_union_pw_aff partial) const;\n  inline schedule intersect_domain(union_set domain) const;\n  inline boolean plain_is_equal(const schedule &schedule2) const;\n  inline schedule pullback(union_pw_multi_aff upma) const;\n  inline schedule reset_user() const;\n  inline schedule sequence(schedule schedule2) const;\n};\n\n// declarations for isl::schedule_constraints\ninline schedule_constraints manage(__isl_take isl_schedule_constraints *ptr);\ninline schedule_constraints manage_copy(__isl_keep isl_schedule_constraints *ptr);\n\nclass schedule_constraints {\n  friend inline schedule_constraints manage(__isl_take isl_schedule_constraints *ptr);\n  friend inline schedule_constraints manage_copy(__isl_keep isl_schedule_constraints *ptr);\n\n  isl_schedule_constraints *ptr = nullptr;\n\n  inline explicit schedule_constraints(__isl_take isl_schedule_constraints *ptr);\n\npublic:\n  inline /* implicit */ schedule_constraints();\n  inline /* implicit */ schedule_constraints(const schedule_constraints &obj);\n  inline /* implicit */ schedule_constraints(std::nullptr_t);\n  inline explicit schedule_constraints(ctx ctx, const std::string &str);\n  inline schedule_constraints &operator=(schedule_constraints obj);\n  inline ~schedule_constraints();\n  inline __isl_give isl_schedule_constraints *copy() const &;\n  inline __isl_give isl_schedule_constraints *copy() && = delete;\n  inline __isl_keep isl_schedule_constraints *get() const;\n  inline __isl_give isl_schedule_constraints *release();\n  inline bool is_null() const;\n  inline explicit operator bool() const;\n  inline ctx get_ctx() const;\n  inline std::string to_str() const;\n  inline void dump() const;\n\n  inline schedule_constraints apply(union_map umap) const;\n  inline schedule compute_schedule() const;\n  inline union_map get_coincidence() const;\n  inline union_map get_conditional_validity() const;\n  inline union_map get_conditional_validity_condition() const;\n  inline set get_context() const;\n  inline union_set get_domain() const;\n  inline union_map get_proximity() const;\n  inline union_map get_validity() const;\n  static inline schedule_constraints on_domain(union_set domain);\n  inline schedule_constraints set_coincidence(union_map coincidence) const;\n  inline schedule_constraints set_conditional_validity(union_map condition, union_map validity) const;\n  inline schedule_constraints set_context(set context) const;\n  inline schedule_constraints set_proximity(union_map proximity) const;\n  inline schedule_constraints set_validity(union_map validity) const;\n};\n\n// declarations for isl::schedule_node\ninline schedule_node manage(__isl_take isl_schedule_node *ptr);\ninline schedule_node manage_copy(__isl_keep isl_schedule_node *ptr);\n\nclass schedule_node {\n  friend inline schedule_node manage(__isl_take isl_schedule_node *ptr);\n  friend inline schedule_node manage_copy(__isl_keep isl_schedule_node *ptr);\n\n  isl_schedule_node *ptr = nullptr;\n\n  inline explicit schedule_node(__isl_take isl_schedule_node *ptr);\n\npublic:\n  inline /* implicit */ schedule_node();\n  inline /* implicit */ schedule_node(const schedule_node &obj);\n  inline /* implicit */ schedule_node(std::nullptr_t);\n  inline schedule_node &operator=(schedule_node obj);\n  inline ~schedule_node();\n  inline __isl_give isl_schedule_node *copy() const &;\n  inline __isl_give isl_schedule_node *copy() && = delete;\n  inline __isl_keep isl_schedule_node *get() const;\n  inline __isl_give isl_schedule_node *release();\n  inline bool is_null() const;\n  inline explicit operator bool() const;\n  inline ctx get_ctx() const;\n  inline std::string to_str() const;\n  inline void dump() const;\n\n  inline schedule_node align_params(space space) const;\n  inline schedule_node ancestor(int generation) const;\n  inline boolean band_member_get_coincident(int pos) const;\n  inline schedule_node band_member_set_coincident(int pos, int coincident) const;\n  inline schedule_node band_set_ast_build_options(union_set options) const;\n  inline schedule_node child(int pos) const;\n  inline set context_get_context() const;\n  inline schedule_node cut() const;\n  inline union_set domain_get_domain() const;\n  inline union_pw_multi_aff expansion_get_contraction() const;\n  inline union_map expansion_get_expansion() const;\n  inline union_map extension_get_extension() const;\n  inline union_set filter_get_filter() const;\n  inline schedule_node first_child() const;\n  inline stat foreach_ancestor_top_down(const std::function<stat(schedule_node)> &fn) const;\n  static inline schedule_node from_domain(union_set domain);\n  static inline schedule_node from_extension(union_map extension);\n  inline isl_size get_ancestor_child_position(const schedule_node &ancestor) const;\n  inline schedule_node get_child(int pos) const;\n  inline isl_size get_child_position() const;\n  inline union_set get_domain() const;\n  inline multi_union_pw_aff get_prefix_schedule_multi_union_pw_aff() const;\n  inline union_map get_prefix_schedule_relation() const;\n  inline union_map get_prefix_schedule_union_map() const;\n  inline union_pw_multi_aff get_prefix_schedule_union_pw_multi_aff() const;\n  inline schedule get_schedule() const;\n  inline isl_size get_schedule_depth() const;\n  inline schedule_node get_shared_ancestor(const schedule_node &node2) const;\n  inline union_pw_multi_aff get_subtree_contraction() const;\n  inline union_map get_subtree_expansion() const;\n  inline union_map get_subtree_schedule_union_map() const;\n  inline isl_size get_tree_depth() const;\n  inline union_set get_universe_domain() const;\n  inline schedule_node graft_after(schedule_node graft) const;\n  inline schedule_node graft_before(schedule_node graft) const;\n  inline schedule_node group(id group_id) const;\n  inline set guard_get_guard() const;\n  inline boolean has_children() const;\n  inline boolean has_next_sibling() const;\n  inline boolean has_parent() const;\n  inline boolean has_previous_sibling() const;\n  inline schedule_node insert_context(set context) const;\n  inline schedule_node insert_filter(union_set filter) const;\n  inline schedule_node insert_guard(set context) const;\n  inline schedule_node insert_mark(id mark) const;\n  inline schedule_node insert_partial_schedule(multi_union_pw_aff schedule) const;\n  inline schedule_node insert_sequence(union_set_list filters) const;\n  inline schedule_node insert_set(union_set_list filters) const;\n  inline boolean is_equal(const schedule_node &node2) const;\n  inline boolean is_subtree_anchored() const;\n  inline id mark_get_id() const;\n  inline isl_size n_children() const;\n  inline schedule_node next_sibling() const;\n  inline schedule_node order_after(union_set filter) const;\n  inline schedule_node order_before(union_set filter) const;\n  inline schedule_node parent() const;\n  inline schedule_node previous_sibling() const;\n  inline schedule_node reset_user() const;\n  inline schedule_node root() const;\n  inline schedule_node sequence_splice_child(int pos) const;\n};\n\n// declarations for isl::set\ninline set manage(__isl_take isl_set *ptr);\ninline set manage_copy(__isl_keep isl_set *ptr);\n\nclass set {\n  friend inline set manage(__isl_take isl_set *ptr);\n  friend inline set manage_copy(__isl_keep isl_set *ptr);\n\n  isl_set *ptr = nullptr;\n\n  inline explicit set(__isl_take isl_set *ptr);\n\npublic:\n  inline /* implicit */ set();\n  inline /* implicit */ set(const set &obj);\n  inline /* implicit */ set(std::nullptr_t);\n  inline /* implicit */ set(basic_set bset);\n  inline /* implicit */ set(point pnt);\n  inline explicit set(union_set uset);\n  inline explicit set(ctx ctx, const std::string &str);\n  inline set &operator=(set obj);\n  inline ~set();\n  inline __isl_give isl_set *copy() const &;\n  inline __isl_give isl_set *copy() && = delete;\n  inline __isl_keep isl_set *get() const;\n  inline __isl_give isl_set *release();\n  inline bool is_null() const;\n  inline explicit operator bool() const;\n  inline ctx get_ctx() const;\n  inline std::string to_str() const;\n  inline void dump() const;\n\n  inline set add_constraint(constraint constraint) const;\n  inline set add_dims(isl::dim type, unsigned int n) const;\n  inline basic_set affine_hull() const;\n  inline set align_params(space model) const;\n  inline set apply(map map) const;\n  inline set bind(multi_id tuple) const;\n  inline basic_set bounded_simple_hull() const;\n  static inline set box_from_points(point pnt1, point pnt2);\n  inline set coalesce() const;\n  inline basic_set coefficients() const;\n  inline set complement() const;\n  inline basic_set convex_hull() const;\n  inline val count_val() const;\n  inline set detect_equalities() const;\n  inline isl_size dim(isl::dim type) const;\n  inline boolean dim_has_any_lower_bound(isl::dim type, unsigned int pos) const;\n  inline boolean dim_has_any_upper_bound(isl::dim type, unsigned int pos) const;\n  inline boolean dim_has_lower_bound(isl::dim type, unsigned int pos) const;\n  inline boolean dim_has_upper_bound(isl::dim type, unsigned int pos) const;\n  inline boolean dim_is_bounded(isl::dim type, unsigned int pos) const;\n  inline pw_aff dim_max(int pos) const;\n  inline val dim_max_val(int pos) const;\n  inline pw_aff dim_min(int pos) const;\n  inline val dim_min_val(int pos) const;\n  inline set drop_constraints_involving_dims(isl::dim type, unsigned int first, unsigned int n) const;\n  inline set drop_constraints_not_involving_dims(isl::dim type, unsigned int first, unsigned int n) const;\n  inline set drop_unused_params() const;\n  inline set eliminate(isl::dim type, unsigned int first, unsigned int n) const;\n  static inline set empty(space space);\n  inline set equate(isl::dim type1, int pos1, isl::dim type2, int pos2) const;\n  inline int find_dim_by_id(isl::dim type, const id &id) const;\n  inline int find_dim_by_name(isl::dim type, const std::string &name) const;\n  inline set fix_si(isl::dim type, unsigned int pos, int value) const;\n  inline set fix_val(isl::dim type, unsigned int pos, val v) const;\n  inline set flat_product(set set2) const;\n  inline set flatten() const;\n  inline map flatten_map() const;\n  inline int follows_at(const set &set2, int pos) const;\n  inline stat foreach_basic_set(const std::function<stat(basic_set)> &fn) const;\n  inline stat foreach_point(const std::function<stat(point)> &fn) const;\n  static inline set from_multi_aff(multi_aff ma);\n  static inline set from_multi_pw_aff(multi_pw_aff mpa);\n  inline set from_params() const;\n  static inline set from_pw_aff(pw_aff pwaff);\n  static inline set from_pw_multi_aff(pw_multi_aff pma);\n  inline basic_set_list get_basic_set_list() const;\n  inline id get_dim_id(isl::dim type, unsigned int pos) const;\n  inline std::string get_dim_name(isl::dim type, unsigned int pos) const;\n  inline multi_val get_plain_multi_val_if_fixed() const;\n  inline fixed_box get_simple_fixed_box_hull() const;\n  inline space get_space() const;\n  inline val get_stride(int pos) const;\n  inline id get_tuple_id() const;\n  inline std::string get_tuple_name() const;\n  inline set gist(set context) const;\n  inline set gist_basic_set(basic_set context) const;\n  inline set gist_params(set context) const;\n  inline boolean has_dim_id(isl::dim type, unsigned int pos) const;\n  inline boolean has_dim_name(isl::dim type, unsigned int pos) const;\n  inline boolean has_equal_space(const set &set2) const;\n  inline boolean has_tuple_id() const;\n  inline boolean has_tuple_name() const;\n  inline map identity() const;\n  inline pw_aff indicator_function() const;\n  inline set insert_dims(isl::dim type, unsigned int pos, unsigned int n) const;\n  inline map insert_domain(space domain) const;\n  inline set intersect(set set2) const;\n  inline set intersect_factor_domain(set domain) const;\n  inline set intersect_factor_range(set range) const;\n  inline set intersect_params(set params) const;\n  inline boolean involves_dims(isl::dim type, unsigned int first, unsigned int n) const;\n  inline boolean involves_locals() const;\n  inline boolean is_bounded() const;\n  inline boolean is_box() const;\n  inline boolean is_disjoint(const set &set2) const;\n  inline boolean is_empty() const;\n  inline boolean is_equal(const set &set2) const;\n  inline boolean is_params() const;\n  inline boolean is_singleton() const;\n  inline boolean is_strict_subset(const set &set2) const;\n  inline boolean is_subset(const set &set2) const;\n  inline boolean is_wrapping() const;\n  inline map lex_ge_set(set set2) const;\n  inline map lex_gt_set(set set2) const;\n  inline map lex_le_set(set set2) const;\n  inline map lex_lt_set(set set2) const;\n  inline set lexmax() const;\n  inline pw_multi_aff lexmax_pw_multi_aff() const;\n  inline set lexmin() const;\n  inline pw_multi_aff lexmin_pw_multi_aff() const;\n  inline set lower_bound(multi_pw_aff lower) const;\n  inline set lower_bound(multi_val lower) const;\n  inline set lower_bound_si(isl::dim type, unsigned int pos, int value) const;\n  inline set lower_bound_val(isl::dim type, unsigned int pos, val value) const;\n  inline multi_pw_aff max_multi_pw_aff() const;\n  inline val max_val(const aff &obj) const;\n  inline multi_pw_aff min_multi_pw_aff() const;\n  inline val min_val(const aff &obj) const;\n  inline set move_dims(isl::dim dst_type, unsigned int dst_pos, isl::dim src_type, unsigned int src_pos, unsigned int n) const;\n  inline isl_size n_basic_set() const;\n  inline isl_size n_dim() const;\n  static inline set nat_universe(space space);\n  inline set neg() const;\n  inline set params() const;\n  inline int plain_cmp(const set &set2) const;\n  inline val plain_get_val_if_fixed(isl::dim type, unsigned int pos) const;\n  inline boolean plain_is_disjoint(const set &set2) const;\n  inline boolean plain_is_empty() const;\n  inline boolean plain_is_equal(const set &set2) const;\n  inline boolean plain_is_universe() const;\n  inline basic_set plain_unshifted_simple_hull() const;\n  inline basic_set polyhedral_hull() const;\n  inline set preimage(multi_aff ma) const;\n  inline set preimage(multi_pw_aff mpa) const;\n  inline set preimage(pw_multi_aff pma) const;\n  inline set product(set set2) const;\n  inline map project_onto_map(isl::dim type, unsigned int first, unsigned int n) const;\n  inline set project_out(isl::dim type, unsigned int first, unsigned int n) const;\n  inline set project_out_all_params() const;\n  inline set project_out_param(id id) const;\n  inline set project_out_param(id_list list) const;\n  inline set remove_dims(isl::dim type, unsigned int first, unsigned int n) const;\n  inline set remove_divs() const;\n  inline set remove_divs_involving_dims(isl::dim type, unsigned int first, unsigned int n) const;\n  inline set remove_redundancies() const;\n  inline set remove_unknown_divs() const;\n  inline set reset_space(space space) const;\n  inline set reset_tuple_id() const;\n  inline set reset_user() const;\n  inline basic_set sample() const;\n  inline point sample_point() const;\n  inline set set_dim_id(isl::dim type, unsigned int pos, id id) const;\n  inline set set_tuple_id(id id) const;\n  inline set set_tuple_name(const std::string &s) const;\n  inline basic_set simple_hull() const;\n  inline int size() const;\n  inline basic_set solutions() const;\n  inline set split_dims(isl::dim type, unsigned int first, unsigned int n) const;\n  inline set subtract(set set2) const;\n  inline set sum(set set2) const;\n  inline map translation() const;\n  inline set unbind_params(multi_id tuple) const;\n  inline map unbind_params_insert_domain(multi_id domain) const;\n  inline set unite(set set2) const;\n  static inline set universe(space space);\n  inline basic_set unshifted_simple_hull() const;\n  inline basic_set unshifted_simple_hull_from_set_list(set_list list) const;\n  inline map unwrap() const;\n  inline set upper_bound(multi_pw_aff upper) const;\n  inline set upper_bound(multi_val upper) const;\n  inline set upper_bound_si(isl::dim type, unsigned int pos, int value) const;\n  inline set upper_bound_val(isl::dim type, unsigned int pos, val value) const;\n  inline map wrapped_domain_map() const;\n};\n\n// declarations for isl::set_list\ninline set_list manage(__isl_take isl_set_list *ptr);\ninline set_list manage_copy(__isl_keep isl_set_list *ptr);\n\nclass set_list {\n  friend inline set_list manage(__isl_take isl_set_list *ptr);\n  friend inline set_list manage_copy(__isl_keep isl_set_list *ptr);\n\n  isl_set_list *ptr = nullptr;\n\n  inline explicit set_list(__isl_take isl_set_list *ptr);\n\npublic:\n  inline /* implicit */ set_list();\n  inline /* implicit */ set_list(const set_list &obj);\n  inline /* implicit */ set_list(std::nullptr_t);\n  inline set_list &operator=(set_list obj);\n  inline ~set_list();\n  inline __isl_give isl_set_list *copy() const &;\n  inline __isl_give isl_set_list *copy() && = delete;\n  inline __isl_keep isl_set_list *get() const;\n  inline __isl_give isl_set_list *release();\n  inline bool is_null() const;\n  inline explicit operator bool() const;\n  inline ctx get_ctx() const;\n  inline std::string to_str() const;\n  inline void dump() const;\n\n  inline set_list add(set el) const;\n  static inline set_list alloc(ctx ctx, int n);\n  inline set_list clear() const;\n  inline set_list concat(set_list list2) const;\n  inline set_list drop(unsigned int first, unsigned int n) const;\n  inline stat foreach(const std::function<stat(set)> &fn) const;\n  static inline set_list from_set(set el);\n  inline set get_at(int index) const;\n  inline set get_set(int index) const;\n  inline set_list insert(unsigned int pos, set el) const;\n  inline isl_size n_set() const;\n  inline set_list reverse() const;\n  inline set_list set_set(int index, set el) const;\n  inline isl_size size() const;\n  inline set_list swap(unsigned int pos1, unsigned int pos2) const;\n  inline set unite() const;\n};\n\n// declarations for isl::space\ninline space manage(__isl_take isl_space *ptr);\ninline space manage_copy(__isl_keep isl_space *ptr);\n\nclass space {\n  friend inline space manage(__isl_take isl_space *ptr);\n  friend inline space manage_copy(__isl_keep isl_space *ptr);\n\n  isl_space *ptr = nullptr;\n\n  inline explicit space(__isl_take isl_space *ptr);\n\npublic:\n  inline /* implicit */ space();\n  inline /* implicit */ space(const space &obj);\n  inline /* implicit */ space(std::nullptr_t);\n  inline explicit space(ctx ctx, unsigned int nparam, unsigned int n_in, unsigned int n_out);\n  inline explicit space(ctx ctx, unsigned int nparam, unsigned int dim);\n  inline space &operator=(space obj);\n  inline ~space();\n  inline __isl_give isl_space *copy() const &;\n  inline __isl_give isl_space *copy() && = delete;\n  inline __isl_keep isl_space *get() const;\n  inline __isl_give isl_space *release();\n  inline bool is_null() const;\n  inline explicit operator bool() const;\n  inline ctx get_ctx() const;\n  inline std::string to_str() const;\n  inline void dump() const;\n\n  inline space add_dims(isl::dim type, unsigned int n) const;\n  inline space add_named_tuple(id tuple_id, unsigned int dim) const;\n  inline space add_param_id(id id) const;\n  inline space add_unnamed_tuple(unsigned int dim) const;\n  inline space align_params(space space2) const;\n  inline boolean can_curry() const;\n  inline boolean can_range_curry() const;\n  inline boolean can_uncurry() const;\n  inline boolean can_zip() const;\n  inline space curry() const;\n  inline isl_size dim(isl::dim type) const;\n  inline space domain() const;\n  inline space domain_factor_domain() const;\n  inline space domain_factor_range() const;\n  inline boolean domain_is_wrapping() const;\n  inline space domain_map() const;\n  inline space domain_product(space right) const;\n  inline space drop_all_params() const;\n  inline space drop_dims(isl::dim type, unsigned int first, unsigned int num) const;\n  inline space factor_domain() const;\n  inline space factor_range() const;\n  inline int find_dim_by_id(isl::dim type, const id &id) const;\n  inline int find_dim_by_name(isl::dim type, const std::string &name) const;\n  inline space flatten_domain() const;\n  inline space flatten_range() const;\n  inline space from_domain() const;\n  inline space from_range() const;\n  inline id get_dim_id(isl::dim type, unsigned int pos) const;\n  inline std::string get_dim_name(isl::dim type, unsigned int pos) const;\n  inline id get_tuple_id(isl::dim type) const;\n  inline std::string get_tuple_name(isl::dim type) const;\n  inline boolean has_dim_id(isl::dim type, unsigned int pos) const;\n  inline boolean has_dim_name(isl::dim type, unsigned int pos) const;\n  inline boolean has_equal_params(const space &space2) const;\n  inline boolean has_equal_tuples(const space &space2) const;\n  inline boolean has_tuple_id(isl::dim type) const;\n  inline boolean has_tuple_name(isl::dim type) const;\n  inline space insert_dims(isl::dim type, unsigned int pos, unsigned int n) const;\n  inline boolean is_domain(const space &space2) const;\n  inline boolean is_equal(const space &space2) const;\n  inline boolean is_map() const;\n  inline boolean is_params() const;\n  inline boolean is_product() const;\n  inline boolean is_range(const space &space2) const;\n  inline boolean is_set() const;\n  inline boolean is_wrapping() const;\n  inline space join(space right) const;\n  inline space map_from_domain_and_range(space range) const;\n  inline space map_from_set() const;\n  inline space move_dims(isl::dim dst_type, unsigned int dst_pos, isl::dim src_type, unsigned int src_pos, unsigned int n) const;\n  inline space params() const;\n  static inline space params_alloc(ctx ctx, unsigned int nparam);\n  inline space product(space right) const;\n  inline space range() const;\n  inline space range_curry() const;\n  inline space range_factor_domain() const;\n  inline space range_factor_range() const;\n  inline boolean range_is_wrapping() const;\n  inline space range_map() const;\n  inline space range_product(space right) const;\n  inline space range_reverse() const;\n  inline space reset_tuple_id(isl::dim type) const;\n  inline space reset_user() const;\n  inline space reverse() const;\n  inline space set_dim_id(isl::dim type, unsigned int pos, id id) const;\n  inline space set_from_params() const;\n  inline space set_tuple_id(isl::dim type, id id) const;\n  inline space set_tuple_name(isl::dim type, const std::string &s) const;\n  inline boolean tuple_is_equal(isl::dim type1, const space &space2, isl::dim type2) const;\n  inline space uncurry() const;\n  static inline space unit(ctx ctx);\n  inline space unwrap() const;\n  inline space wrap() const;\n  inline space zip() const;\n};\n\n// declarations for isl::term\ninline term manage(__isl_take isl_term *ptr);\ninline term manage_copy(__isl_keep isl_term *ptr);\n\nclass term {\n  friend inline term manage(__isl_take isl_term *ptr);\n  friend inline term manage_copy(__isl_keep isl_term *ptr);\n\n  isl_term *ptr = nullptr;\n\n  inline explicit term(__isl_take isl_term *ptr);\n\npublic:\n  inline /* implicit */ term();\n  inline /* implicit */ term(const term &obj);\n  inline /* implicit */ term(std::nullptr_t);\n  inline term &operator=(term obj);\n  inline ~term();\n  inline __isl_give isl_term *copy() const &;\n  inline __isl_give isl_term *copy() && = delete;\n  inline __isl_keep isl_term *get() const;\n  inline __isl_give isl_term *release();\n  inline bool is_null() const;\n  inline explicit operator bool() const;\n  inline ctx get_ctx() const;\n\n  inline isl_size dim(isl::dim type) const;\n  inline val get_coefficient_val() const;\n  inline aff get_div(unsigned int pos) const;\n  inline isl_size get_exp(isl::dim type, unsigned int pos) const;\n};\n\n// declarations for isl::union_access_info\ninline union_access_info manage(__isl_take isl_union_access_info *ptr);\ninline union_access_info manage_copy(__isl_keep isl_union_access_info *ptr);\n\nclass union_access_info {\n  friend inline union_access_info manage(__isl_take isl_union_access_info *ptr);\n  friend inline union_access_info manage_copy(__isl_keep isl_union_access_info *ptr);\n\n  isl_union_access_info *ptr = nullptr;\n\n  inline explicit union_access_info(__isl_take isl_union_access_info *ptr);\n\npublic:\n  inline /* implicit */ union_access_info();\n  inline /* implicit */ union_access_info(const union_access_info &obj);\n  inline /* implicit */ union_access_info(std::nullptr_t);\n  inline explicit union_access_info(union_map sink);\n  inline union_access_info &operator=(union_access_info obj);\n  inline ~union_access_info();\n  inline __isl_give isl_union_access_info *copy() const &;\n  inline __isl_give isl_union_access_info *copy() && = delete;\n  inline __isl_keep isl_union_access_info *get() const;\n  inline __isl_give isl_union_access_info *release();\n  inline bool is_null() const;\n  inline explicit operator bool() const;\n  inline ctx get_ctx() const;\n  inline std::string to_str() const;\n\n  inline union_flow compute_flow() const;\n  inline union_access_info set_kill(union_map kill) const;\n  inline union_access_info set_may_source(union_map may_source) const;\n  inline union_access_info set_must_source(union_map must_source) const;\n  inline union_access_info set_schedule(schedule schedule) const;\n  inline union_access_info set_schedule_map(union_map schedule_map) const;\n};\n\n// declarations for isl::union_flow\ninline union_flow manage(__isl_take isl_union_flow *ptr);\ninline union_flow manage_copy(__isl_keep isl_union_flow *ptr);\n\nclass union_flow {\n  friend inline union_flow manage(__isl_take isl_union_flow *ptr);\n  friend inline union_flow manage_copy(__isl_keep isl_union_flow *ptr);\n\n  isl_union_flow *ptr = nullptr;\n\n  inline explicit union_flow(__isl_take isl_union_flow *ptr);\n\npublic:\n  inline /* implicit */ union_flow();\n  inline /* implicit */ union_flow(const union_flow &obj);\n  inline /* implicit */ union_flow(std::nullptr_t);\n  inline union_flow &operator=(union_flow obj);\n  inline ~union_flow();\n  inline __isl_give isl_union_flow *copy() const &;\n  inline __isl_give isl_union_flow *copy() && = delete;\n  inline __isl_keep isl_union_flow *get() const;\n  inline __isl_give isl_union_flow *release();\n  inline bool is_null() const;\n  inline explicit operator bool() const;\n  inline ctx get_ctx() const;\n  inline std::string to_str() const;\n\n  inline union_map get_full_may_dependence() const;\n  inline union_map get_full_must_dependence() const;\n  inline union_map get_may_dependence() const;\n  inline union_map get_may_no_source() const;\n  inline union_map get_must_dependence() const;\n  inline union_map get_must_no_source() const;\n};\n\n// declarations for isl::union_map\ninline union_map manage(__isl_take isl_union_map *ptr);\ninline union_map manage_copy(__isl_keep isl_union_map *ptr);\n\nclass union_map {\n  friend inline union_map manage(__isl_take isl_union_map *ptr);\n  friend inline union_map manage_copy(__isl_keep isl_union_map *ptr);\n\n  isl_union_map *ptr = nullptr;\n\n  inline explicit union_map(__isl_take isl_union_map *ptr);\n\npublic:\n  inline /* implicit */ union_map();\n  inline /* implicit */ union_map(const union_map &obj);\n  inline /* implicit */ union_map(std::nullptr_t);\n  inline /* implicit */ union_map(basic_map bmap);\n  inline /* implicit */ union_map(map map);\n  inline explicit union_map(union_pw_multi_aff upma);\n  inline explicit union_map(ctx ctx, const std::string &str);\n  inline union_map &operator=(union_map obj);\n  inline ~union_map();\n  inline __isl_give isl_union_map *copy() const &;\n  inline __isl_give isl_union_map *copy() && = delete;\n  inline __isl_keep isl_union_map *get() const;\n  inline __isl_give isl_union_map *release();\n  inline bool is_null() const;\n  inline explicit operator bool() const;\n  inline ctx get_ctx() const;\n  inline std::string to_str() const;\n  inline void dump() const;\n\n  inline union_map add_map(map map) const;\n  inline union_map affine_hull() const;\n  inline union_map align_params(space model) const;\n  inline union_map apply_domain(union_map umap2) const;\n  inline union_map apply_range(union_map umap2) const;\n  inline union_set bind_range(multi_id tuple) const;\n  inline union_map coalesce() const;\n  inline boolean contains(const space &space) const;\n  inline union_map curry() const;\n  inline union_set deltas() const;\n  inline union_map deltas_map() const;\n  inline union_map detect_equalities() const;\n  inline isl_size dim(isl::dim type) const;\n  inline union_set domain() const;\n  inline union_map domain_factor_domain() const;\n  inline union_map domain_factor_range() const;\n  inline union_map domain_map() const;\n  inline union_pw_multi_aff domain_map_union_pw_multi_aff() const;\n  inline union_map domain_product(union_map umap2) const;\n  static inline union_map empty(space space);\n  static inline union_map empty(ctx ctx);\n  static inline union_map empty_space(space space);\n  inline union_map eq_at(multi_union_pw_aff mupa) const;\n  inline map extract_map(space space) const;\n  inline union_map factor_domain() const;\n  inline union_map factor_range() const;\n  inline int find_dim_by_name(isl::dim type, const std::string &name) const;\n  inline union_map fixed_power(val exp) const;\n  inline union_map flat_domain_product(union_map umap2) const;\n  inline union_map flat_range_product(union_map umap2) const;\n  inline stat foreach_map(const std::function<stat(map)> &fn) const;\n  static inline union_map from(multi_union_pw_aff mupa);\n  static inline union_map from_domain(union_set uset);\n  static inline union_map from_domain_and_range(union_set domain, union_set range);\n  static inline union_map from_range(union_set uset);\n  static inline union_map from_union_pw_aff(union_pw_aff upa);\n  inline id get_dim_id(isl::dim type, unsigned int pos) const;\n  inline uint32_t get_hash() const;\n  inline map_list get_map_list() const;\n  inline space get_space() const;\n  inline union_map gist(union_map context) const;\n  inline union_map gist_domain(union_set uset) const;\n  inline union_map gist_params(set set) const;\n  inline union_map gist_range(union_set uset) const;\n  inline union_map intersect(union_map umap2) const;\n  inline union_map intersect_domain(space space) const;\n  inline union_map intersect_domain(union_set uset) const;\n  inline union_map intersect_domain_factor_domain(union_map factor) const;\n  inline union_map intersect_domain_factor_range(union_map factor) const;\n  inline union_map intersect_params(set set) const;\n  inline union_map intersect_range(space space) const;\n  inline union_map intersect_range(union_set uset) const;\n  inline union_map intersect_range_factor_domain(union_map factor) const;\n  inline union_map intersect_range_factor_range(union_map factor) const;\n  inline boolean involves_dims(isl::dim type, unsigned int first, unsigned int n) const;\n  inline boolean is_bijective() const;\n  inline boolean is_disjoint(const union_map &umap2) const;\n  inline boolean is_empty() const;\n  inline boolean is_equal(const union_map &umap2) const;\n  inline boolean is_identity() const;\n  inline boolean is_injective() const;\n  inline boolean is_single_valued() const;\n  inline boolean is_strict_subset(const union_map &umap2) const;\n  inline boolean is_subset(const union_map &umap2) const;\n  inline boolean isa_map() const;\n  inline union_map lex_ge_at_multi_union_pw_aff(multi_union_pw_aff mupa) const;\n  inline union_map lex_ge_union_map(union_map umap2) const;\n  inline union_map lex_gt_at_multi_union_pw_aff(multi_union_pw_aff mupa) const;\n  inline union_map lex_gt_union_map(union_map umap2) const;\n  inline union_map lex_le_at_multi_union_pw_aff(multi_union_pw_aff mupa) const;\n  inline union_map lex_le_union_map(union_map umap2) const;\n  inline union_map lex_lt_at_multi_union_pw_aff(multi_union_pw_aff mupa) const;\n  inline union_map lex_lt_union_map(union_map umap2) const;\n  inline union_map lexmax() const;\n  inline union_map lexmin() const;\n  inline isl_size n_map() const;\n  inline set params() const;\n  inline boolean plain_is_empty() const;\n  inline boolean plain_is_injective() const;\n  inline union_map polyhedral_hull() const;\n  inline union_map preimage_domain(multi_aff ma) const;\n  inline union_map preimage_domain(multi_pw_aff mpa) const;\n  inline union_map preimage_domain(pw_multi_aff pma) const;\n  inline union_map preimage_domain(union_pw_multi_aff upma) const;\n  inline union_map preimage_range(multi_aff ma) const;\n  inline union_map preimage_range(pw_multi_aff pma) const;\n  inline union_map preimage_range(union_pw_multi_aff upma) const;\n  inline union_map product(union_map umap2) const;\n  inline union_map project_out(isl::dim type, unsigned int first, unsigned int n) const;\n  inline union_map project_out_all_params() const;\n  inline union_set range() const;\n  inline union_map range_curry() const;\n  inline union_map range_factor_domain() const;\n  inline union_map range_factor_range() const;\n  inline union_map range_map() const;\n  inline union_map range_product(union_map umap2) const;\n  inline union_map range_reverse() const;\n  inline union_map remove_divs() const;\n  inline union_map remove_redundancies() const;\n  inline union_map reset_user() const;\n  inline union_map reverse() const;\n  inline basic_map sample() const;\n  inline union_map simple_hull() const;\n  inline union_map subtract(union_map umap2) const;\n  inline union_map subtract_domain(union_set dom) const;\n  inline union_map subtract_range(union_set dom) const;\n  inline union_map uncurry() const;\n  inline union_map unite(union_map umap2) const;\n  inline union_map universe() const;\n  inline union_set wrap() const;\n  inline union_map zip() const;\n};\n\n// declarations for isl::union_map_list\ninline union_map_list manage(__isl_take isl_union_map_list *ptr);\ninline union_map_list manage_copy(__isl_keep isl_union_map_list *ptr);\n\nclass union_map_list {\n  friend inline union_map_list manage(__isl_take isl_union_map_list *ptr);\n  friend inline union_map_list manage_copy(__isl_keep isl_union_map_list *ptr);\n\n  isl_union_map_list *ptr = nullptr;\n\n  inline explicit union_map_list(__isl_take isl_union_map_list *ptr);\n\npublic:\n  inline /* implicit */ union_map_list();\n  inline /* implicit */ union_map_list(const union_map_list &obj);\n  inline /* implicit */ union_map_list(std::nullptr_t);\n  inline union_map_list &operator=(union_map_list obj);\n  inline ~union_map_list();\n  inline __isl_give isl_union_map_list *copy() const &;\n  inline __isl_give isl_union_map_list *copy() && = delete;\n  inline __isl_keep isl_union_map_list *get() const;\n  inline __isl_give isl_union_map_list *release();\n  inline bool is_null() const;\n  inline explicit operator bool() const;\n  inline ctx get_ctx() const;\n  inline std::string to_str() const;\n  inline void dump() const;\n\n  inline union_map_list add(union_map el) const;\n  static inline union_map_list alloc(ctx ctx, int n);\n  inline union_map_list clear() const;\n  inline union_map_list concat(union_map_list list2) const;\n  inline union_map_list drop(unsigned int first, unsigned int n) const;\n  inline stat foreach(const std::function<stat(union_map)> &fn) const;\n  static inline union_map_list from_union_map(union_map el);\n  inline union_map get_at(int index) const;\n  inline union_map get_union_map(int index) const;\n  inline union_map_list insert(unsigned int pos, union_map el) const;\n  inline isl_size n_union_map() const;\n  inline union_map_list reverse() const;\n  inline union_map_list set_union_map(int index, union_map el) const;\n  inline isl_size size() const;\n  inline union_map_list swap(unsigned int pos1, unsigned int pos2) const;\n};\n\n// declarations for isl::union_pw_aff\ninline union_pw_aff manage(__isl_take isl_union_pw_aff *ptr);\ninline union_pw_aff manage_copy(__isl_keep isl_union_pw_aff *ptr);\n\nclass union_pw_aff {\n  friend inline union_pw_aff manage(__isl_take isl_union_pw_aff *ptr);\n  friend inline union_pw_aff manage_copy(__isl_keep isl_union_pw_aff *ptr);\n\n  isl_union_pw_aff *ptr = nullptr;\n\n  inline explicit union_pw_aff(__isl_take isl_union_pw_aff *ptr);\n\npublic:\n  inline /* implicit */ union_pw_aff();\n  inline /* implicit */ union_pw_aff(const union_pw_aff &obj);\n  inline /* implicit */ union_pw_aff(std::nullptr_t);\n  inline /* implicit */ union_pw_aff(aff aff);\n  inline /* implicit */ union_pw_aff(pw_aff pa);\n  inline explicit union_pw_aff(ctx ctx, const std::string &str);\n  inline explicit union_pw_aff(union_set domain, val v);\n  inline union_pw_aff &operator=(union_pw_aff obj);\n  inline ~union_pw_aff();\n  inline __isl_give isl_union_pw_aff *copy() const &;\n  inline __isl_give isl_union_pw_aff *copy() && = delete;\n  inline __isl_keep isl_union_pw_aff *get() const;\n  inline __isl_give isl_union_pw_aff *release();\n  inline bool is_null() const;\n  inline explicit operator bool() const;\n  inline ctx get_ctx() const;\n  inline std::string to_str() const;\n  inline void dump() const;\n\n  inline union_pw_aff add(union_pw_aff upa2) const;\n  inline union_pw_aff add_pw_aff(pw_aff pa) const;\n  static inline union_pw_aff aff_on_domain(union_set domain, aff aff);\n  inline union_pw_aff align_params(space model) const;\n  inline union_set bind(id id) const;\n  inline union_pw_aff coalesce() const;\n  inline isl_size dim(isl::dim type) const;\n  inline union_set domain() const;\n  inline union_pw_aff drop_dims(isl::dim type, unsigned int first, unsigned int n) const;\n  static inline union_pw_aff empty(space space);\n  static inline union_pw_aff empty_ctx(ctx ctx);\n  static inline union_pw_aff empty_space(space space);\n  inline pw_aff extract_pw_aff(space space) const;\n  inline int find_dim_by_name(isl::dim type, const std::string &name) const;\n  inline union_pw_aff floor() const;\n  inline stat foreach_pw_aff(const std::function<stat(pw_aff)> &fn) const;\n  inline pw_aff_list get_pw_aff_list() const;\n  inline space get_space() const;\n  inline union_pw_aff gist(union_set context) const;\n  inline union_pw_aff gist_params(set context) const;\n  inline union_pw_aff intersect_domain(space space) const;\n  inline union_pw_aff intersect_domain(union_set uset) const;\n  inline union_pw_aff intersect_domain_wrapped_domain(union_set uset) const;\n  inline union_pw_aff intersect_domain_wrapped_range(union_set uset) const;\n  inline union_pw_aff intersect_params(set set) const;\n  inline boolean involves_nan() const;\n  inline val max_val() const;\n  inline val min_val() const;\n  inline union_pw_aff mod_val(val f) const;\n  inline isl_size n_pw_aff() const;\n  inline union_pw_aff neg() const;\n  static inline union_pw_aff param_on_domain_id(union_set domain, id id);\n  inline boolean plain_is_equal(const union_pw_aff &upa2) const;\n  inline union_pw_aff pullback(union_pw_multi_aff upma) const;\n  static inline union_pw_aff pw_aff_on_domain(union_set domain, pw_aff pa);\n  inline union_pw_aff reset_user() const;\n  inline union_pw_aff scale_down_val(val v) const;\n  inline union_pw_aff scale_val(val v) const;\n  inline union_pw_aff sub(union_pw_aff upa2) const;\n  inline union_pw_aff subtract_domain(space space) const;\n  inline union_pw_aff subtract_domain(union_set uset) const;\n  inline union_pw_aff union_add(union_pw_aff upa2) const;\n  inline union_set zero_union_set() const;\n};\n\n// declarations for isl::union_pw_aff_list\ninline union_pw_aff_list manage(__isl_take isl_union_pw_aff_list *ptr);\ninline union_pw_aff_list manage_copy(__isl_keep isl_union_pw_aff_list *ptr);\n\nclass union_pw_aff_list {\n  friend inline union_pw_aff_list manage(__isl_take isl_union_pw_aff_list *ptr);\n  friend inline union_pw_aff_list manage_copy(__isl_keep isl_union_pw_aff_list *ptr);\n\n  isl_union_pw_aff_list *ptr = nullptr;\n\n  inline explicit union_pw_aff_list(__isl_take isl_union_pw_aff_list *ptr);\n\npublic:\n  inline /* implicit */ union_pw_aff_list();\n  inline /* implicit */ union_pw_aff_list(const union_pw_aff_list &obj);\n  inline /* implicit */ union_pw_aff_list(std::nullptr_t);\n  inline union_pw_aff_list &operator=(union_pw_aff_list obj);\n  inline ~union_pw_aff_list();\n  inline __isl_give isl_union_pw_aff_list *copy() const &;\n  inline __isl_give isl_union_pw_aff_list *copy() && = delete;\n  inline __isl_keep isl_union_pw_aff_list *get() const;\n  inline __isl_give isl_union_pw_aff_list *release();\n  inline bool is_null() const;\n  inline explicit operator bool() const;\n  inline ctx get_ctx() const;\n  inline std::string to_str() const;\n  inline void dump() const;\n\n  inline union_pw_aff_list add(union_pw_aff el) const;\n  static inline union_pw_aff_list alloc(ctx ctx, int n);\n  inline union_pw_aff_list clear() const;\n  inline union_pw_aff_list concat(union_pw_aff_list list2) const;\n  inline union_pw_aff_list drop(unsigned int first, unsigned int n) const;\n  inline stat foreach(const std::function<stat(union_pw_aff)> &fn) const;\n  static inline union_pw_aff_list from_union_pw_aff(union_pw_aff el);\n  inline union_pw_aff get_at(int index) const;\n  inline union_pw_aff get_union_pw_aff(int index) const;\n  inline union_pw_aff_list insert(unsigned int pos, union_pw_aff el) const;\n  inline isl_size n_union_pw_aff() const;\n  inline union_pw_aff_list reverse() const;\n  inline union_pw_aff_list set_union_pw_aff(int index, union_pw_aff el) const;\n  inline isl_size size() const;\n  inline union_pw_aff_list swap(unsigned int pos1, unsigned int pos2) const;\n};\n\n// declarations for isl::union_pw_multi_aff\ninline union_pw_multi_aff manage(__isl_take isl_union_pw_multi_aff *ptr);\ninline union_pw_multi_aff manage_copy(__isl_keep isl_union_pw_multi_aff *ptr);\n\nclass union_pw_multi_aff {\n  friend inline union_pw_multi_aff manage(__isl_take isl_union_pw_multi_aff *ptr);\n  friend inline union_pw_multi_aff manage_copy(__isl_keep isl_union_pw_multi_aff *ptr);\n\n  isl_union_pw_multi_aff *ptr = nullptr;\n\n  inline explicit union_pw_multi_aff(__isl_take isl_union_pw_multi_aff *ptr);\n\npublic:\n  inline /* implicit */ union_pw_multi_aff();\n  inline /* implicit */ union_pw_multi_aff(const union_pw_multi_aff &obj);\n  inline /* implicit */ union_pw_multi_aff(std::nullptr_t);\n  inline /* implicit */ union_pw_multi_aff(aff aff);\n  inline explicit union_pw_multi_aff(union_set uset);\n  inline /* implicit */ union_pw_multi_aff(multi_aff ma);\n  inline explicit union_pw_multi_aff(multi_union_pw_aff mupa);\n  inline /* implicit */ union_pw_multi_aff(pw_multi_aff pma);\n  inline explicit union_pw_multi_aff(union_map umap);\n  inline /* implicit */ union_pw_multi_aff(union_pw_aff upa);\n  inline explicit union_pw_multi_aff(ctx ctx, const std::string &str);\n  inline union_pw_multi_aff &operator=(union_pw_multi_aff obj);\n  inline ~union_pw_multi_aff();\n  inline __isl_give isl_union_pw_multi_aff *copy() const &;\n  inline __isl_give isl_union_pw_multi_aff *copy() && = delete;\n  inline __isl_keep isl_union_pw_multi_aff *get() const;\n  inline __isl_give isl_union_pw_multi_aff *release();\n  inline bool is_null() const;\n  inline explicit operator bool() const;\n  inline ctx get_ctx() const;\n  inline std::string to_str() const;\n  inline void dump() const;\n\n  inline union_pw_multi_aff add(union_pw_multi_aff upma2) const;\n  inline union_pw_multi_aff add_pw_multi_aff(pw_multi_aff pma) const;\n  inline union_pw_multi_aff align_params(space model) const;\n  inline union_pw_multi_aff apply(union_pw_multi_aff upma2) const;\n  inline pw_multi_aff as_pw_multi_aff() const;\n  inline union_pw_multi_aff coalesce() const;\n  inline isl_size dim(isl::dim type) const;\n  inline union_set domain() const;\n  inline union_pw_multi_aff drop_dims(isl::dim type, unsigned int first, unsigned int n) const;\n  static inline union_pw_multi_aff empty(space space);\n  static inline union_pw_multi_aff empty(ctx ctx);\n  static inline union_pw_multi_aff empty_space(space space);\n  inline pw_multi_aff extract_pw_multi_aff(space space) const;\n  inline int find_dim_by_name(isl::dim type, const std::string &name) const;\n  inline union_pw_multi_aff flat_range_product(union_pw_multi_aff upma2) const;\n  inline stat foreach_pw_multi_aff(const std::function<stat(pw_multi_aff)> &fn) const;\n  static inline union_pw_multi_aff from_union_set(union_set uset);\n  inline pw_multi_aff_list get_pw_multi_aff_list() const;\n  inline space get_space() const;\n  inline union_pw_aff get_union_pw_aff(int pos) const;\n  inline union_pw_multi_aff gist(union_set context) const;\n  inline union_pw_multi_aff gist_params(set context) const;\n  inline union_pw_multi_aff intersect_domain(space space) const;\n  inline union_pw_multi_aff intersect_domain(union_set uset) const;\n  inline union_pw_multi_aff intersect_domain_wrapped_domain(union_set uset) const;\n  inline union_pw_multi_aff intersect_domain_wrapped_range(union_set uset) const;\n  inline union_pw_multi_aff intersect_params(set set) const;\n  inline boolean involves_locals() const;\n  inline boolean involves_nan() const;\n  inline boolean isa_pw_multi_aff() const;\n  static inline union_pw_multi_aff multi_val_on_domain(union_set domain, multi_val mv);\n  inline isl_size n_pw_multi_aff() const;\n  inline union_pw_multi_aff neg() const;\n  inline boolean plain_is_empty() const;\n  inline boolean plain_is_equal(const union_pw_multi_aff &upma2) const;\n  inline union_pw_multi_aff preimage_domain_wrapped_domain(union_pw_multi_aff upma2) const;\n  inline union_pw_multi_aff pullback(union_pw_multi_aff upma2) const;\n  inline union_pw_multi_aff range_factor_domain() const;\n  inline union_pw_multi_aff range_factor_range() const;\n  inline union_pw_multi_aff range_product(union_pw_multi_aff upma2) const;\n  inline union_pw_multi_aff reset_user() const;\n  inline union_pw_multi_aff scale_down_val(val val) const;\n  inline union_pw_multi_aff scale_multi_val(multi_val mv) const;\n  inline union_pw_multi_aff scale_val(val val) const;\n  inline union_pw_multi_aff sub(union_pw_multi_aff upma2) const;\n  inline union_pw_multi_aff subtract_domain(space space) const;\n  inline union_pw_multi_aff subtract_domain(union_set uset) const;\n  inline union_pw_multi_aff union_add(union_pw_multi_aff upma2) const;\n};\n\n// declarations for isl::union_pw_multi_aff_list\ninline union_pw_multi_aff_list manage(__isl_take isl_union_pw_multi_aff_list *ptr);\ninline union_pw_multi_aff_list manage_copy(__isl_keep isl_union_pw_multi_aff_list *ptr);\n\nclass union_pw_multi_aff_list {\n  friend inline union_pw_multi_aff_list manage(__isl_take isl_union_pw_multi_aff_list *ptr);\n  friend inline union_pw_multi_aff_list manage_copy(__isl_keep isl_union_pw_multi_aff_list *ptr);\n\n  isl_union_pw_multi_aff_list *ptr = nullptr;\n\n  inline explicit union_pw_multi_aff_list(__isl_take isl_union_pw_multi_aff_list *ptr);\n\npublic:\n  inline /* implicit */ union_pw_multi_aff_list();\n  inline /* implicit */ union_pw_multi_aff_list(const union_pw_multi_aff_list &obj);\n  inline /* implicit */ union_pw_multi_aff_list(std::nullptr_t);\n  inline union_pw_multi_aff_list &operator=(union_pw_multi_aff_list obj);\n  inline ~union_pw_multi_aff_list();\n  inline __isl_give isl_union_pw_multi_aff_list *copy() const &;\n  inline __isl_give isl_union_pw_multi_aff_list *copy() && = delete;\n  inline __isl_keep isl_union_pw_multi_aff_list *get() const;\n  inline __isl_give isl_union_pw_multi_aff_list *release();\n  inline bool is_null() const;\n  inline explicit operator bool() const;\n  inline ctx get_ctx() const;\n  inline std::string to_str() const;\n  inline void dump() const;\n\n  inline union_pw_multi_aff_list add(union_pw_multi_aff el) const;\n  static inline union_pw_multi_aff_list alloc(ctx ctx, int n);\n  inline union_pw_multi_aff_list clear() const;\n  inline union_pw_multi_aff_list concat(union_pw_multi_aff_list list2) const;\n  inline union_pw_multi_aff_list drop(unsigned int first, unsigned int n) const;\n  inline stat foreach(const std::function<stat(union_pw_multi_aff)> &fn) const;\n  static inline union_pw_multi_aff_list from_union_pw_multi_aff(union_pw_multi_aff el);\n  inline union_pw_multi_aff get_at(int index) const;\n  inline union_pw_multi_aff get_union_pw_multi_aff(int index) const;\n  inline union_pw_multi_aff_list insert(unsigned int pos, union_pw_multi_aff el) const;\n  inline isl_size n_union_pw_multi_aff() const;\n  inline union_pw_multi_aff_list reverse() const;\n  inline union_pw_multi_aff_list set_union_pw_multi_aff(int index, union_pw_multi_aff el) const;\n  inline isl_size size() const;\n  inline union_pw_multi_aff_list swap(unsigned int pos1, unsigned int pos2) const;\n};\n\n// declarations for isl::union_pw_qpolynomial\ninline union_pw_qpolynomial manage(__isl_take isl_union_pw_qpolynomial *ptr);\ninline union_pw_qpolynomial manage_copy(__isl_keep isl_union_pw_qpolynomial *ptr);\n\nclass union_pw_qpolynomial {\n  friend inline union_pw_qpolynomial manage(__isl_take isl_union_pw_qpolynomial *ptr);\n  friend inline union_pw_qpolynomial manage_copy(__isl_keep isl_union_pw_qpolynomial *ptr);\n\n  isl_union_pw_qpolynomial *ptr = nullptr;\n\n  inline explicit union_pw_qpolynomial(__isl_take isl_union_pw_qpolynomial *ptr);\n\npublic:\n  inline /* implicit */ union_pw_qpolynomial();\n  inline /* implicit */ union_pw_qpolynomial(const union_pw_qpolynomial &obj);\n  inline /* implicit */ union_pw_qpolynomial(std::nullptr_t);\n  inline explicit union_pw_qpolynomial(ctx ctx, const std::string &str);\n  inline union_pw_qpolynomial &operator=(union_pw_qpolynomial obj);\n  inline ~union_pw_qpolynomial();\n  inline __isl_give isl_union_pw_qpolynomial *copy() const &;\n  inline __isl_give isl_union_pw_qpolynomial *copy() && = delete;\n  inline __isl_keep isl_union_pw_qpolynomial *get() const;\n  inline __isl_give isl_union_pw_qpolynomial *release();\n  inline bool is_null() const;\n  inline explicit operator bool() const;\n  inline ctx get_ctx() const;\n  inline std::string to_str() const;\n\n  inline union_pw_qpolynomial add(union_pw_qpolynomial upwqp2) const;\n  inline union_pw_qpolynomial add_pw_qpolynomial(pw_qpolynomial pwqp) const;\n  inline union_pw_qpolynomial align_params(space model) const;\n  inline union_pw_qpolynomial coalesce() const;\n  inline isl_size dim(isl::dim type) const;\n  inline union_set domain() const;\n  inline union_pw_qpolynomial drop_dims(isl::dim type, unsigned int first, unsigned int n) const;\n  inline val eval(point pnt) const;\n  inline pw_qpolynomial extract_pw_qpolynomial(space space) const;\n  inline int find_dim_by_name(isl::dim type, const std::string &name) const;\n  inline stat foreach_pw_qpolynomial(const std::function<stat(pw_qpolynomial)> &fn) const;\n  static inline union_pw_qpolynomial from_pw_qpolynomial(pw_qpolynomial pwqp);\n  inline pw_qpolynomial_list get_pw_qpolynomial_list() const;\n  inline space get_space() const;\n  inline union_pw_qpolynomial gist(union_set context) const;\n  inline union_pw_qpolynomial gist_params(set context) const;\n  inline union_pw_qpolynomial intersect_domain(union_set uset) const;\n  inline union_pw_qpolynomial intersect_domain_space(space space) const;\n  inline union_pw_qpolynomial intersect_domain_union_set(union_set uset) const;\n  inline union_pw_qpolynomial intersect_domain_wrapped_domain(union_set uset) const;\n  inline union_pw_qpolynomial intersect_domain_wrapped_range(union_set uset) const;\n  inline union_pw_qpolynomial intersect_params(set set) const;\n  inline boolean involves_nan() const;\n  inline union_pw_qpolynomial mul(union_pw_qpolynomial upwqp2) const;\n  inline isl_size n_pw_qpolynomial() const;\n  inline union_pw_qpolynomial neg() const;\n  inline boolean plain_is_equal(const union_pw_qpolynomial &upwqp2) const;\n  inline union_pw_qpolynomial reset_user() const;\n  inline union_pw_qpolynomial scale_down_val(val v) const;\n  inline union_pw_qpolynomial scale_val(val v) const;\n  inline union_pw_qpolynomial sub(union_pw_qpolynomial upwqp2) const;\n  inline union_pw_qpolynomial subtract_domain(union_set uset) const;\n  inline union_pw_qpolynomial subtract_domain_space(space space) const;\n  inline union_pw_qpolynomial subtract_domain_union_set(union_set uset) const;\n  inline union_pw_qpolynomial to_polynomial(int sign) const;\n  static inline union_pw_qpolynomial zero(space space);\n  static inline union_pw_qpolynomial zero_ctx(ctx ctx);\n  static inline union_pw_qpolynomial zero_space(space space);\n};\n\n// declarations for isl::union_set\ninline union_set manage(__isl_take isl_union_set *ptr);\ninline union_set manage_copy(__isl_keep isl_union_set *ptr);\n\nclass union_set {\n  friend inline union_set manage(__isl_take isl_union_set *ptr);\n  friend inline union_set manage_copy(__isl_keep isl_union_set *ptr);\n\n  isl_union_set *ptr = nullptr;\n\n  inline explicit union_set(__isl_take isl_union_set *ptr);\n\npublic:\n  inline /* implicit */ union_set();\n  inline /* implicit */ union_set(const union_set &obj);\n  inline /* implicit */ union_set(std::nullptr_t);\n  inline /* implicit */ union_set(basic_set bset);\n  inline /* implicit */ union_set(point pnt);\n  inline /* implicit */ union_set(set set);\n  inline explicit union_set(ctx ctx, const std::string &str);\n  inline union_set &operator=(union_set obj);\n  inline ~union_set();\n  inline __isl_give isl_union_set *copy() const &;\n  inline __isl_give isl_union_set *copy() && = delete;\n  inline __isl_keep isl_union_set *get() const;\n  inline __isl_give isl_union_set *release();\n  inline bool is_null() const;\n  inline explicit operator bool() const;\n  inline ctx get_ctx() const;\n  inline std::string to_str() const;\n  inline void dump() const;\n\n  inline union_set add_set(set set) const;\n  inline union_set affine_hull() const;\n  inline union_set align_params(space model) const;\n  inline union_set apply(union_map umap) const;\n  inline union_set coalesce() const;\n  inline union_set coefficients() const;\n  inline schedule compute_schedule(union_map validity, union_map proximity) const;\n  inline boolean contains(const space &space) const;\n  inline union_set detect_equalities() const;\n  inline isl_size dim(isl::dim type) const;\n  static inline union_set empty(space space);\n  static inline union_set empty(ctx ctx);\n  static inline union_set empty_space(space space);\n  inline set extract_set(space space) const;\n  inline stat foreach_point(const std::function<stat(point)> &fn) const;\n  inline stat foreach_set(const std::function<stat(set)> &fn) const;\n  inline basic_set_list get_basic_set_list() const;\n  inline uint32_t get_hash() const;\n  inline set_list get_set_list() const;\n  inline space get_space() const;\n  inline union_set gist(union_set context) const;\n  inline union_set gist_params(set set) const;\n  inline union_map identity() const;\n  inline union_pw_multi_aff identity_union_pw_multi_aff() const;\n  inline union_set intersect(union_set uset2) const;\n  inline union_set intersect_params(set set) const;\n  inline boolean is_disjoint(const union_set &uset2) const;\n  inline boolean is_empty() const;\n  inline boolean is_equal(const union_set &uset2) const;\n  inline boolean is_params() const;\n  inline boolean is_strict_subset(const union_set &uset2) const;\n  inline boolean is_subset(const union_set &uset2) const;\n  inline boolean isa_set() const;\n  inline union_map lex_ge_union_set(union_set uset2) const;\n  inline union_map lex_gt_union_set(union_set uset2) const;\n  inline union_map lex_le_union_set(union_set uset2) const;\n  inline union_map lex_lt_union_set(union_set uset2) const;\n  inline union_set lexmax() const;\n  inline union_set lexmin() const;\n  inline multi_val min_multi_union_pw_aff(const multi_union_pw_aff &obj) const;\n  inline isl_size n_set() const;\n  inline set params() const;\n  inline union_set polyhedral_hull() const;\n  inline union_set preimage(multi_aff ma) const;\n  inline union_set preimage(pw_multi_aff pma) const;\n  inline union_set preimage(union_pw_multi_aff upma) const;\n  inline union_set product(union_set uset2) const;\n  inline union_set project_out(isl::dim type, unsigned int first, unsigned int n) const;\n  inline union_set project_out_all_params() const;\n  inline union_set remove_divs() const;\n  inline union_set remove_redundancies() const;\n  inline union_set reset_user() const;\n  inline basic_set sample() const;\n  inline point sample_point() const;\n  inline union_set simple_hull() const;\n  inline union_set solutions() const;\n  inline union_set subtract(union_set uset2) const;\n  inline union_set unite(union_set uset2) const;\n  inline union_set universe() const;\n  inline union_map unwrap() const;\n  inline union_map wrapped_domain_map() const;\n};\n\n// declarations for isl::union_set_list\ninline union_set_list manage(__isl_take isl_union_set_list *ptr);\ninline union_set_list manage_copy(__isl_keep isl_union_set_list *ptr);\n\nclass union_set_list {\n  friend inline union_set_list manage(__isl_take isl_union_set_list *ptr);\n  friend inline union_set_list manage_copy(__isl_keep isl_union_set_list *ptr);\n\n  isl_union_set_list *ptr = nullptr;\n\n  inline explicit union_set_list(__isl_take isl_union_set_list *ptr);\n\npublic:\n  inline /* implicit */ union_set_list();\n  inline /* implicit */ union_set_list(const union_set_list &obj);\n  inline /* implicit */ union_set_list(std::nullptr_t);\n  inline union_set_list &operator=(union_set_list obj);\n  inline ~union_set_list();\n  inline __isl_give isl_union_set_list *copy() const &;\n  inline __isl_give isl_union_set_list *copy() && = delete;\n  inline __isl_keep isl_union_set_list *get() const;\n  inline __isl_give isl_union_set_list *release();\n  inline bool is_null() const;\n  inline explicit operator bool() const;\n  inline ctx get_ctx() const;\n  inline std::string to_str() const;\n  inline void dump() const;\n\n  inline union_set_list add(union_set el) const;\n  static inline union_set_list alloc(ctx ctx, int n);\n  inline union_set_list clear() const;\n  inline union_set_list concat(union_set_list list2) const;\n  inline union_set_list drop(unsigned int first, unsigned int n) const;\n  inline stat foreach(const std::function<stat(union_set)> &fn) const;\n  static inline union_set_list from_union_set(union_set el);\n  inline union_set get_at(int index) const;\n  inline union_set get_union_set(int index) const;\n  inline union_set_list insert(unsigned int pos, union_set el) const;\n  inline isl_size n_union_set() const;\n  inline union_set_list reverse() const;\n  inline union_set_list set_union_set(int index, union_set el) const;\n  inline isl_size size() const;\n  inline union_set_list swap(unsigned int pos1, unsigned int pos2) const;\n  inline union_set unite() const;\n};\n\n// declarations for isl::val\ninline val manage(__isl_take isl_val *ptr);\ninline val manage_copy(__isl_keep isl_val *ptr);\n\nclass val {\n  friend inline val manage(__isl_take isl_val *ptr);\n  friend inline val manage_copy(__isl_keep isl_val *ptr);\n\n  isl_val *ptr = nullptr;\n\n  inline explicit val(__isl_take isl_val *ptr);\n\npublic:\n  inline /* implicit */ val();\n  inline /* implicit */ val(const val &obj);\n  inline /* implicit */ val(std::nullptr_t);\n  inline explicit val(ctx ctx, long i);\n  inline explicit val(ctx ctx, const std::string &str);\n  inline val &operator=(val obj);\n  inline ~val();\n  inline __isl_give isl_val *copy() const &;\n  inline __isl_give isl_val *copy() && = delete;\n  inline __isl_keep isl_val *get() const;\n  inline __isl_give isl_val *release();\n  inline bool is_null() const;\n  inline explicit operator bool() const;\n  inline ctx get_ctx() const;\n  inline std::string to_str() const;\n  inline void dump() const;\n\n  inline val abs() const;\n  inline boolean abs_eq(const val &v2) const;\n  inline val add(val v2) const;\n  inline val add_ui(unsigned long v2) const;\n  inline val ceil() const;\n  inline int cmp_si(long i) const;\n  inline val div(val v2) const;\n  inline val div_ui(unsigned long v2) const;\n  inline boolean eq(const val &v2) const;\n  inline boolean eq_si(long i) const;\n  inline val floor() const;\n  inline val gcd(val v2) const;\n  inline boolean ge(const val &v2) const;\n  inline uint32_t get_hash() const;\n  inline long get_num_si() const;\n  inline boolean gt(const val &v2) const;\n  inline boolean gt_si(long i) const;\n  static inline val infty(ctx ctx);\n  static inline val int_from_ui(ctx ctx, unsigned long u);\n  inline val inv() const;\n  inline boolean is_divisible_by(const val &v2) const;\n  inline boolean is_infty() const;\n  inline boolean is_int() const;\n  inline boolean is_nan() const;\n  inline boolean is_neg() const;\n  inline boolean is_neginfty() const;\n  inline boolean is_negone() const;\n  inline boolean is_nonneg() const;\n  inline boolean is_nonpos() const;\n  inline boolean is_one() const;\n  inline boolean is_pos() const;\n  inline boolean is_rat() const;\n  inline boolean is_zero() const;\n  inline boolean le(const val &v2) const;\n  inline boolean lt(const val &v2) const;\n  inline val max(val v2) const;\n  inline val min(val v2) const;\n  inline val mod(val v2) const;\n  inline val mul(val v2) const;\n  inline val mul_ui(unsigned long v2) const;\n  inline isl_size n_abs_num_chunks(size_t size) const;\n  static inline val nan(ctx ctx);\n  inline boolean ne(const val &v2) const;\n  inline val neg() const;\n  static inline val neginfty(ctx ctx);\n  static inline val negone(ctx ctx);\n  static inline val one(ctx ctx);\n  inline val pow2() const;\n  inline val set_si(long i) const;\n  inline int sgn() const;\n  inline val sub(val v2) const;\n  inline val sub_ui(unsigned long v2) const;\n  inline val trunc() const;\n  static inline val zero(ctx ctx);\n};\n\n// declarations for isl::val_list\ninline val_list manage(__isl_take isl_val_list *ptr);\ninline val_list manage_copy(__isl_keep isl_val_list *ptr);\n\nclass val_list {\n  friend inline val_list manage(__isl_take isl_val_list *ptr);\n  friend inline val_list manage_copy(__isl_keep isl_val_list *ptr);\n\n  isl_val_list *ptr = nullptr;\n\n  inline explicit val_list(__isl_take isl_val_list *ptr);\n\npublic:\n  inline /* implicit */ val_list();\n  inline /* implicit */ val_list(const val_list &obj);\n  inline /* implicit */ val_list(std::nullptr_t);\n  inline val_list &operator=(val_list obj);\n  inline ~val_list();\n  inline __isl_give isl_val_list *copy() const &;\n  inline __isl_give isl_val_list *copy() && = delete;\n  inline __isl_keep isl_val_list *get() const;\n  inline __isl_give isl_val_list *release();\n  inline bool is_null() const;\n  inline explicit operator bool() const;\n  inline ctx get_ctx() const;\n  inline std::string to_str() const;\n  inline void dump() const;\n\n  inline val_list add(val el) const;\n  static inline val_list alloc(ctx ctx, int n);\n  inline val_list clear() const;\n  inline val_list concat(val_list list2) const;\n  inline val_list drop(unsigned int first, unsigned int n) const;\n  inline stat foreach(const std::function<stat(val)> &fn) const;\n  static inline val_list from_val(val el);\n  inline val get_at(int index) const;\n  inline val get_val(int index) const;\n  inline val_list insert(unsigned int pos, val el) const;\n  inline isl_size n_val() const;\n  inline val_list reverse() const;\n  inline val_list set_val(int index, val el) const;\n  inline isl_size size() const;\n  inline val_list swap(unsigned int pos1, unsigned int pos2) const;\n};\n\n// declarations for isl::vec\ninline vec manage(__isl_take isl_vec *ptr);\ninline vec manage_copy(__isl_keep isl_vec *ptr);\n\nclass vec {\n  friend inline vec manage(__isl_take isl_vec *ptr);\n  friend inline vec manage_copy(__isl_keep isl_vec *ptr);\n\n  isl_vec *ptr = nullptr;\n\n  inline explicit vec(__isl_take isl_vec *ptr);\n\npublic:\n  inline /* implicit */ vec();\n  inline /* implicit */ vec(const vec &obj);\n  inline /* implicit */ vec(std::nullptr_t);\n  inline vec &operator=(vec obj);\n  inline ~vec();\n  inline __isl_give isl_vec *copy() const &;\n  inline __isl_give isl_vec *copy() && = delete;\n  inline __isl_keep isl_vec *get() const;\n  inline __isl_give isl_vec *release();\n  inline bool is_null() const;\n  inline explicit operator bool() const;\n  inline ctx get_ctx() const;\n  inline void dump() const;\n\n  inline vec add(vec vec2) const;\n  inline vec add_els(unsigned int n) const;\n  static inline vec alloc(ctx ctx, unsigned int size);\n  inline vec ceil() const;\n  inline vec clr() const;\n  inline int cmp_element(const vec &vec2, int pos) const;\n  inline vec concat(vec vec2) const;\n  inline vec drop_els(unsigned int pos, unsigned int n) const;\n  inline vec extend(unsigned int size) const;\n  inline val get_element_val(int pos) const;\n  inline vec insert_els(unsigned int pos, unsigned int n) const;\n  inline vec insert_zero_els(unsigned int pos, unsigned int n) const;\n  inline boolean is_equal(const vec &vec2) const;\n  inline vec mat_product(mat mat) const;\n  inline vec move_els(unsigned int dst_col, unsigned int src_col, unsigned int n) const;\n  inline vec neg() const;\n  inline vec set_element_si(int pos, int v) const;\n  inline vec set_element_val(int pos, val v) const;\n  inline vec set_si(int v) const;\n  inline vec set_val(val v) const;\n  inline isl_size size() const;\n  inline vec sort() const;\n  static inline vec zero(ctx ctx, unsigned int size);\n  inline vec zero_extend(unsigned int size) const;\n};\n\n// implementations for isl::aff\naff manage(__isl_take isl_aff *ptr) {\n  return aff(ptr);\n}\naff manage_copy(__isl_keep isl_aff *ptr) {\n  ptr = isl_aff_copy(ptr);\n  return aff(ptr);\n}\n\naff::aff()\n    : ptr(nullptr) {}\n\naff::aff(const aff &obj)\n    : ptr(nullptr)\n{\n  ptr = obj.copy();\n}\naff::aff(std::nullptr_t)\n    : ptr(nullptr) {}\n\n\naff::aff(__isl_take isl_aff *ptr)\n    : ptr(ptr) {}\n\naff::aff(ctx ctx, const std::string &str)\n{\n  auto res = isl_aff_read_from_str(ctx.release(), str.c_str());\n  ptr = res;\n}\naff::aff(local_space ls, val val)\n{\n  auto res = isl_aff_val_on_domain(ls.release(), val.release());\n  ptr = res;\n}\naff::aff(local_space ls)\n{\n  auto res = isl_aff_zero_on_domain(ls.release());\n  ptr = res;\n}\n\naff &aff::operator=(aff obj) {\n  std::swap(this->ptr, obj.ptr);\n  return *this;\n}\n\naff::~aff() {\n  if (ptr)\n    isl_aff_free(ptr);\n}\n\n__isl_give isl_aff *aff::copy() const & {\n  return isl_aff_copy(ptr);\n}\n\n__isl_keep isl_aff *aff::get() const {\n  return ptr;\n}\n\n__isl_give isl_aff *aff::release() {\n  isl_aff *tmp = ptr;\n  ptr = nullptr;\n  return tmp;\n}\n\nbool aff::is_null() const {\n  return ptr == nullptr;\n}\naff::operator bool() const {\n  return !is_null();\n}\n\n\nctx aff::get_ctx() const {\n  return ctx(isl_aff_get_ctx(ptr));\n}\nstd::string aff::to_str() const {\n  char *Tmp = isl_aff_to_str(get());\n  if (!Tmp)\n    return \"\";\n  std::string S(Tmp);\n  free(Tmp);\n  return S;\n}\n\n\nvoid aff::dump() const {\n  isl_aff_dump(get());\n}\n\n\naff aff::add(aff aff2) const\n{\n  auto res = isl_aff_add(copy(), aff2.release());\n  return manage(res);\n}\n\naff aff::add_coefficient_si(isl::dim type, int pos, int v) const\n{\n  auto res = isl_aff_add_coefficient_si(copy(), static_cast<enum isl_dim_type>(type), pos, v);\n  return manage(res);\n}\n\naff aff::add_coefficient_val(isl::dim type, int pos, val v) const\n{\n  auto res = isl_aff_add_coefficient_val(copy(), static_cast<enum isl_dim_type>(type), pos, v.release());\n  return manage(res);\n}\n\naff aff::add_constant(val v) const\n{\n  auto res = isl_aff_add_constant_val(copy(), v.release());\n  return manage(res);\n}\n\naff aff::add_constant_num_si(int v) const\n{\n  auto res = isl_aff_add_constant_num_si(copy(), v);\n  return manage(res);\n}\n\naff aff::add_constant_si(int v) const\n{\n  auto res = isl_aff_add_constant_si(copy(), v);\n  return manage(res);\n}\n\naff aff::add_dims(isl::dim type, unsigned int n) const\n{\n  auto res = isl_aff_add_dims(copy(), static_cast<enum isl_dim_type>(type), n);\n  return manage(res);\n}\n\naff aff::align_params(space model) const\n{\n  auto res = isl_aff_align_params(copy(), model.release());\n  return manage(res);\n}\n\nbasic_set aff::bind(id id) const\n{\n  auto res = isl_aff_bind_id(copy(), id.release());\n  return manage(res);\n}\n\naff aff::ceil() const\n{\n  auto res = isl_aff_ceil(copy());\n  return manage(res);\n}\n\nint aff::coefficient_sgn(isl::dim type, int pos) const\n{\n  auto res = isl_aff_coefficient_sgn(get(), static_cast<enum isl_dim_type>(type), pos);\n  return res;\n}\n\nisl_size aff::dim(isl::dim type) const\n{\n  auto res = isl_aff_dim(get(), static_cast<enum isl_dim_type>(type));\n  return res;\n}\n\naff aff::div(aff aff2) const\n{\n  auto res = isl_aff_div(copy(), aff2.release());\n  return manage(res);\n}\n\naff aff::drop_dims(isl::dim type, unsigned int first, unsigned int n) const\n{\n  auto res = isl_aff_drop_dims(copy(), static_cast<enum isl_dim_type>(type), first, n);\n  return manage(res);\n}\n\nbasic_set aff::eq_basic_set(aff aff2) const\n{\n  auto res = isl_aff_eq_basic_set(copy(), aff2.release());\n  return manage(res);\n}\n\nset aff::eq_set(aff aff2) const\n{\n  auto res = isl_aff_eq_set(copy(), aff2.release());\n  return manage(res);\n}\n\nval aff::eval(point pnt) const\n{\n  auto res = isl_aff_eval(copy(), pnt.release());\n  return manage(res);\n}\n\nint aff::find_dim_by_name(isl::dim type, const std::string &name) const\n{\n  auto res = isl_aff_find_dim_by_name(get(), static_cast<enum isl_dim_type>(type), name.c_str());\n  return res;\n}\n\naff aff::floor() const\n{\n  auto res = isl_aff_floor(copy());\n  return manage(res);\n}\n\naff aff::from_range() const\n{\n  auto res = isl_aff_from_range(copy());\n  return manage(res);\n}\n\nbasic_set aff::ge_basic_set(aff aff2) const\n{\n  auto res = isl_aff_ge_basic_set(copy(), aff2.release());\n  return manage(res);\n}\n\nset aff::ge_set(aff aff2) const\n{\n  auto res = isl_aff_ge_set(copy(), aff2.release());\n  return manage(res);\n}\n\nval aff::get_coefficient_val(isl::dim type, int pos) const\n{\n  auto res = isl_aff_get_coefficient_val(get(), static_cast<enum isl_dim_type>(type), pos);\n  return manage(res);\n}\n\nval aff::get_constant_val() const\n{\n  auto res = isl_aff_get_constant_val(get());\n  return manage(res);\n}\n\nval aff::get_denominator_val() const\n{\n  auto res = isl_aff_get_denominator_val(get());\n  return manage(res);\n}\n\nstd::string aff::get_dim_name(isl::dim type, unsigned int pos) const\n{\n  auto res = isl_aff_get_dim_name(get(), static_cast<enum isl_dim_type>(type), pos);\n  std::string tmp(res);\n  return tmp;\n}\n\naff aff::get_div(int pos) const\n{\n  auto res = isl_aff_get_div(get(), pos);\n  return manage(res);\n}\n\nlocal_space aff::get_domain_local_space() const\n{\n  auto res = isl_aff_get_domain_local_space(get());\n  return manage(res);\n}\n\nspace aff::get_domain_space() const\n{\n  auto res = isl_aff_get_domain_space(get());\n  return manage(res);\n}\n\nuint32_t aff::get_hash() const\n{\n  auto res = isl_aff_get_hash(get());\n  return res;\n}\n\nlocal_space aff::get_local_space() const\n{\n  auto res = isl_aff_get_local_space(get());\n  return manage(res);\n}\n\nspace aff::get_space() const\n{\n  auto res = isl_aff_get_space(get());\n  return manage(res);\n}\n\naff aff::gist(set context) const\n{\n  auto res = isl_aff_gist(copy(), context.release());\n  return manage(res);\n}\n\naff aff::gist_params(set context) const\n{\n  auto res = isl_aff_gist_params(copy(), context.release());\n  return manage(res);\n}\n\nbasic_set aff::gt_basic_set(aff aff2) const\n{\n  auto res = isl_aff_gt_basic_set(copy(), aff2.release());\n  return manage(res);\n}\n\nset aff::gt_set(aff aff2) const\n{\n  auto res = isl_aff_gt_set(copy(), aff2.release());\n  return manage(res);\n}\n\naff aff::insert_dims(isl::dim type, unsigned int first, unsigned int n) const\n{\n  auto res = isl_aff_insert_dims(copy(), static_cast<enum isl_dim_type>(type), first, n);\n  return manage(res);\n}\n\nboolean aff::involves_dims(isl::dim type, unsigned int first, unsigned int n) const\n{\n  auto res = isl_aff_involves_dims(get(), static_cast<enum isl_dim_type>(type), first, n);\n  return manage(res);\n}\n\nboolean aff::involves_locals() const\n{\n  auto res = isl_aff_involves_locals(get());\n  return manage(res);\n}\n\nboolean aff::is_cst() const\n{\n  auto res = isl_aff_is_cst(get());\n  return manage(res);\n}\n\nboolean aff::is_nan() const\n{\n  auto res = isl_aff_is_nan(get());\n  return manage(res);\n}\n\nbasic_set aff::le_basic_set(aff aff2) const\n{\n  auto res = isl_aff_le_basic_set(copy(), aff2.release());\n  return manage(res);\n}\n\nset aff::le_set(aff aff2) const\n{\n  auto res = isl_aff_le_set(copy(), aff2.release());\n  return manage(res);\n}\n\nbasic_set aff::lt_basic_set(aff aff2) const\n{\n  auto res = isl_aff_lt_basic_set(copy(), aff2.release());\n  return manage(res);\n}\n\nset aff::lt_set(aff aff2) const\n{\n  auto res = isl_aff_lt_set(copy(), aff2.release());\n  return manage(res);\n}\n\naff aff::mod(val mod) const\n{\n  auto res = isl_aff_mod_val(copy(), mod.release());\n  return manage(res);\n}\n\naff aff::move_dims(isl::dim dst_type, unsigned int dst_pos, isl::dim src_type, unsigned int src_pos, unsigned int n) const\n{\n  auto res = isl_aff_move_dims(copy(), static_cast<enum isl_dim_type>(dst_type), dst_pos, static_cast<enum isl_dim_type>(src_type), src_pos, n);\n  return manage(res);\n}\n\naff aff::mul(aff aff2) const\n{\n  auto res = isl_aff_mul(copy(), aff2.release());\n  return manage(res);\n}\n\naff aff::nan_on_domain(local_space ls)\n{\n  auto res = isl_aff_nan_on_domain(ls.release());\n  return manage(res);\n}\n\naff aff::nan_on_domain_space(space space)\n{\n  auto res = isl_aff_nan_on_domain_space(space.release());\n  return manage(res);\n}\n\nset aff::ne_set(aff aff2) const\n{\n  auto res = isl_aff_ne_set(copy(), aff2.release());\n  return manage(res);\n}\n\naff aff::neg() const\n{\n  auto res = isl_aff_neg(copy());\n  return manage(res);\n}\n\nbasic_set aff::neg_basic_set() const\n{\n  auto res = isl_aff_neg_basic_set(copy());\n  return manage(res);\n}\n\naff aff::param_on_domain_space_id(space space, id id)\n{\n  auto res = isl_aff_param_on_domain_space_id(space.release(), id.release());\n  return manage(res);\n}\n\nboolean aff::plain_is_equal(const aff &aff2) const\n{\n  auto res = isl_aff_plain_is_equal(get(), aff2.get());\n  return manage(res);\n}\n\nboolean aff::plain_is_zero() const\n{\n  auto res = isl_aff_plain_is_zero(get());\n  return manage(res);\n}\n\naff aff::project_domain_on_params() const\n{\n  auto res = isl_aff_project_domain_on_params(copy());\n  return manage(res);\n}\n\naff aff::pullback(multi_aff ma) const\n{\n  auto res = isl_aff_pullback_multi_aff(copy(), ma.release());\n  return manage(res);\n}\n\naff aff::pullback_aff(aff aff2) const\n{\n  auto res = isl_aff_pullback_aff(copy(), aff2.release());\n  return manage(res);\n}\n\naff aff::scale(val v) const\n{\n  auto res = isl_aff_scale_val(copy(), v.release());\n  return manage(res);\n}\n\naff aff::scale_down(val v) const\n{\n  auto res = isl_aff_scale_down_val(copy(), v.release());\n  return manage(res);\n}\n\naff aff::scale_down_ui(unsigned int f) const\n{\n  auto res = isl_aff_scale_down_ui(copy(), f);\n  return manage(res);\n}\n\naff aff::set_coefficient_si(isl::dim type, int pos, int v) const\n{\n  auto res = isl_aff_set_coefficient_si(copy(), static_cast<enum isl_dim_type>(type), pos, v);\n  return manage(res);\n}\n\naff aff::set_coefficient_val(isl::dim type, int pos, val v) const\n{\n  auto res = isl_aff_set_coefficient_val(copy(), static_cast<enum isl_dim_type>(type), pos, v.release());\n  return manage(res);\n}\n\naff aff::set_constant_si(int v) const\n{\n  auto res = isl_aff_set_constant_si(copy(), v);\n  return manage(res);\n}\n\naff aff::set_constant_val(val v) const\n{\n  auto res = isl_aff_set_constant_val(copy(), v.release());\n  return manage(res);\n}\n\naff aff::set_dim_id(isl::dim type, unsigned int pos, id id) const\n{\n  auto res = isl_aff_set_dim_id(copy(), static_cast<enum isl_dim_type>(type), pos, id.release());\n  return manage(res);\n}\n\naff aff::set_tuple_id(isl::dim type, id id) const\n{\n  auto res = isl_aff_set_tuple_id(copy(), static_cast<enum isl_dim_type>(type), id.release());\n  return manage(res);\n}\n\naff aff::sub(aff aff2) const\n{\n  auto res = isl_aff_sub(copy(), aff2.release());\n  return manage(res);\n}\n\naff aff::unbind_params_insert_domain(multi_id domain) const\n{\n  auto res = isl_aff_unbind_params_insert_domain(copy(), domain.release());\n  return manage(res);\n}\n\naff aff::val_on_domain_space(space space, val val)\n{\n  auto res = isl_aff_val_on_domain_space(space.release(), val.release());\n  return manage(res);\n}\n\naff aff::var_on_domain(local_space ls, isl::dim type, unsigned int pos)\n{\n  auto res = isl_aff_var_on_domain(ls.release(), static_cast<enum isl_dim_type>(type), pos);\n  return manage(res);\n}\n\nbasic_set aff::zero_basic_set() const\n{\n  auto res = isl_aff_zero_basic_set(copy());\n  return manage(res);\n}\n\naff aff::zero_on_domain(space space)\n{\n  auto res = isl_aff_zero_on_domain_space(space.release());\n  return manage(res);\n}\n\n// implementations for isl::aff_list\naff_list manage(__isl_take isl_aff_list *ptr) {\n  return aff_list(ptr);\n}\naff_list manage_copy(__isl_keep isl_aff_list *ptr) {\n  ptr = isl_aff_list_copy(ptr);\n  return aff_list(ptr);\n}\n\naff_list::aff_list()\n    : ptr(nullptr) {}\n\naff_list::aff_list(const aff_list &obj)\n    : ptr(nullptr)\n{\n  ptr = obj.copy();\n}\naff_list::aff_list(std::nullptr_t)\n    : ptr(nullptr) {}\n\n\naff_list::aff_list(__isl_take isl_aff_list *ptr)\n    : ptr(ptr) {}\n\n\naff_list &aff_list::operator=(aff_list obj) {\n  std::swap(this->ptr, obj.ptr);\n  return *this;\n}\n\naff_list::~aff_list() {\n  if (ptr)\n    isl_aff_list_free(ptr);\n}\n\n__isl_give isl_aff_list *aff_list::copy() const & {\n  return isl_aff_list_copy(ptr);\n}\n\n__isl_keep isl_aff_list *aff_list::get() const {\n  return ptr;\n}\n\n__isl_give isl_aff_list *aff_list::release() {\n  isl_aff_list *tmp = ptr;\n  ptr = nullptr;\n  return tmp;\n}\n\nbool aff_list::is_null() const {\n  return ptr == nullptr;\n}\naff_list::operator bool() const {\n  return !is_null();\n}\n\n\nctx aff_list::get_ctx() const {\n  return ctx(isl_aff_list_get_ctx(ptr));\n}\nstd::string aff_list::to_str() const {\n  char *Tmp = isl_aff_list_to_str(get());\n  if (!Tmp)\n    return \"\";\n  std::string S(Tmp);\n  free(Tmp);\n  return S;\n}\n\n\nvoid aff_list::dump() const {\n  isl_aff_list_dump(get());\n}\n\n\naff_list aff_list::add(aff el) const\n{\n  auto res = isl_aff_list_add(copy(), el.release());\n  return manage(res);\n}\n\naff_list aff_list::alloc(ctx ctx, int n)\n{\n  auto res = isl_aff_list_alloc(ctx.release(), n);\n  return manage(res);\n}\n\naff_list aff_list::clear() const\n{\n  auto res = isl_aff_list_clear(copy());\n  return manage(res);\n}\n\naff_list aff_list::concat(aff_list list2) const\n{\n  auto res = isl_aff_list_concat(copy(), list2.release());\n  return manage(res);\n}\n\naff_list aff_list::drop(unsigned int first, unsigned int n) const\n{\n  auto res = isl_aff_list_drop(copy(), first, n);\n  return manage(res);\n}\n\nstat aff_list::foreach(const std::function<stat(aff)> &fn) const\n{\n  struct fn_data {\n    const std::function<stat(aff)> *func;\n  } fn_data = { &fn };\n  auto fn_lambda = [](isl_aff *arg_0, void *arg_1) -> isl_stat {\n    auto *data = static_cast<struct fn_data *>(arg_1);\n    stat ret = (*data->func)(manage(arg_0));\n    return ret.release();\n  };\n  auto res = isl_aff_list_foreach(get(), fn_lambda, &fn_data);\n  return manage(res);\n}\n\naff_list aff_list::from_aff(aff el)\n{\n  auto res = isl_aff_list_from_aff(el.release());\n  return manage(res);\n}\n\naff aff_list::get_aff(int index) const\n{\n  auto res = isl_aff_list_get_aff(get(), index);\n  return manage(res);\n}\n\naff aff_list::get_at(int index) const\n{\n  auto res = isl_aff_list_get_at(get(), index);\n  return manage(res);\n}\n\naff_list aff_list::insert(unsigned int pos, aff el) const\n{\n  auto res = isl_aff_list_insert(copy(), pos, el.release());\n  return manage(res);\n}\n\nisl_size aff_list::n_aff() const\n{\n  auto res = isl_aff_list_n_aff(get());\n  return res;\n}\n\naff_list aff_list::reverse() const\n{\n  auto res = isl_aff_list_reverse(copy());\n  return manage(res);\n}\n\naff_list aff_list::set_aff(int index, aff el) const\n{\n  auto res = isl_aff_list_set_aff(copy(), index, el.release());\n  return manage(res);\n}\n\nisl_size aff_list::size() const\n{\n  auto res = isl_aff_list_size(get());\n  return res;\n}\n\naff_list aff_list::swap(unsigned int pos1, unsigned int pos2) const\n{\n  auto res = isl_aff_list_swap(copy(), pos1, pos2);\n  return manage(res);\n}\n\n// implementations for isl::ast_build\nast_build manage(__isl_take isl_ast_build *ptr) {\n  return ast_build(ptr);\n}\nast_build manage_copy(__isl_keep isl_ast_build *ptr) {\n  ptr = isl_ast_build_copy(ptr);\n  return ast_build(ptr);\n}\n\nast_build::ast_build()\n    : ptr(nullptr) {}\n\nast_build::ast_build(const ast_build &obj)\n    : ptr(nullptr)\n{\n  ptr = obj.copy();\n}\nast_build::ast_build(std::nullptr_t)\n    : ptr(nullptr) {}\n\n\nast_build::ast_build(__isl_take isl_ast_build *ptr)\n    : ptr(ptr) {}\n\nast_build::ast_build(ctx ctx)\n{\n  auto res = isl_ast_build_alloc(ctx.release());\n  ptr = res;\n}\n\nast_build &ast_build::operator=(ast_build obj) {\n  std::swap(this->ptr, obj.ptr);\n  return *this;\n}\n\nast_build::~ast_build() {\n  if (ptr)\n    isl_ast_build_free(ptr);\n}\n\n__isl_give isl_ast_build *ast_build::copy() const & {\n  return isl_ast_build_copy(ptr);\n}\n\n__isl_keep isl_ast_build *ast_build::get() const {\n  return ptr;\n}\n\n__isl_give isl_ast_build *ast_build::release() {\n  isl_ast_build *tmp = ptr;\n  ptr = nullptr;\n  return tmp;\n}\n\nbool ast_build::is_null() const {\n  return ptr == nullptr;\n}\nast_build::operator bool() const {\n  return !is_null();\n}\n\n\nctx ast_build::get_ctx() const {\n  return ctx(isl_ast_build_get_ctx(ptr));\n}\n\n\nast_expr ast_build::access_from(multi_pw_aff mpa) const\n{\n  auto res = isl_ast_build_access_from_multi_pw_aff(get(), mpa.release());\n  return manage(res);\n}\n\nast_expr ast_build::access_from(pw_multi_aff pma) const\n{\n  auto res = isl_ast_build_access_from_pw_multi_aff(get(), pma.release());\n  return manage(res);\n}\n\nast_node ast_build::ast_from_schedule(union_map schedule) const\n{\n  auto res = isl_ast_build_ast_from_schedule(get(), schedule.release());\n  return manage(res);\n}\n\nast_expr ast_build::call_from(multi_pw_aff mpa) const\n{\n  auto res = isl_ast_build_call_from_multi_pw_aff(get(), mpa.release());\n  return manage(res);\n}\n\nast_expr ast_build::call_from(pw_multi_aff pma) const\n{\n  auto res = isl_ast_build_call_from_pw_multi_aff(get(), pma.release());\n  return manage(res);\n}\n\nast_expr ast_build::expr_from(pw_aff pa) const\n{\n  auto res = isl_ast_build_expr_from_pw_aff(get(), pa.release());\n  return manage(res);\n}\n\nast_expr ast_build::expr_from(set set) const\n{\n  auto res = isl_ast_build_expr_from_set(get(), set.release());\n  return manage(res);\n}\n\nast_build ast_build::from_context(set set)\n{\n  auto res = isl_ast_build_from_context(set.release());\n  return manage(res);\n}\n\nunion_map ast_build::get_schedule() const\n{\n  auto res = isl_ast_build_get_schedule(get());\n  return manage(res);\n}\n\nspace ast_build::get_schedule_space() const\n{\n  auto res = isl_ast_build_get_schedule_space(get());\n  return manage(res);\n}\n\nast_node ast_build::node_from(schedule schedule) const\n{\n  auto res = isl_ast_build_node_from_schedule(get(), schedule.release());\n  return manage(res);\n}\n\nast_node ast_build::node_from_schedule_map(union_map schedule) const\n{\n  auto res = isl_ast_build_node_from_schedule_map(get(), schedule.release());\n  return manage(res);\n}\n\nast_build ast_build::restrict(set set) const\n{\n  auto res = isl_ast_build_restrict(copy(), set.release());\n  return manage(res);\n}\n\n// implementations for isl::ast_expr\nast_expr manage(__isl_take isl_ast_expr *ptr) {\n  return ast_expr(ptr);\n}\nast_expr manage_copy(__isl_keep isl_ast_expr *ptr) {\n  ptr = isl_ast_expr_copy(ptr);\n  return ast_expr(ptr);\n}\n\nast_expr::ast_expr()\n    : ptr(nullptr) {}\n\nast_expr::ast_expr(const ast_expr &obj)\n    : ptr(nullptr)\n{\n  ptr = obj.copy();\n}\nast_expr::ast_expr(std::nullptr_t)\n    : ptr(nullptr) {}\n\n\nast_expr::ast_expr(__isl_take isl_ast_expr *ptr)\n    : ptr(ptr) {}\n\n\nast_expr &ast_expr::operator=(ast_expr obj) {\n  std::swap(this->ptr, obj.ptr);\n  return *this;\n}\n\nast_expr::~ast_expr() {\n  if (ptr)\n    isl_ast_expr_free(ptr);\n}\n\n__isl_give isl_ast_expr *ast_expr::copy() const & {\n  return isl_ast_expr_copy(ptr);\n}\n\n__isl_keep isl_ast_expr *ast_expr::get() const {\n  return ptr;\n}\n\n__isl_give isl_ast_expr *ast_expr::release() {\n  isl_ast_expr *tmp = ptr;\n  ptr = nullptr;\n  return tmp;\n}\n\nbool ast_expr::is_null() const {\n  return ptr == nullptr;\n}\nast_expr::operator bool() const {\n  return !is_null();\n}\n\n\nctx ast_expr::get_ctx() const {\n  return ctx(isl_ast_expr_get_ctx(ptr));\n}\nstd::string ast_expr::to_str() const {\n  char *Tmp = isl_ast_expr_to_str(get());\n  if (!Tmp)\n    return \"\";\n  std::string S(Tmp);\n  free(Tmp);\n  return S;\n}\n\n\nvoid ast_expr::dump() const {\n  isl_ast_expr_dump(get());\n}\n\n\nast_expr ast_expr::access(ast_expr_list indices) const\n{\n  auto res = isl_ast_expr_access(copy(), indices.release());\n  return manage(res);\n}\n\nast_expr ast_expr::add(ast_expr expr2) const\n{\n  auto res = isl_ast_expr_add(copy(), expr2.release());\n  return manage(res);\n}\n\nast_expr ast_expr::address_of() const\n{\n  auto res = isl_ast_expr_address_of(copy());\n  return manage(res);\n}\n\nast_expr ast_expr::call(ast_expr_list arguments) const\n{\n  auto res = isl_ast_expr_call(copy(), arguments.release());\n  return manage(res);\n}\n\nast_expr ast_expr::div(ast_expr expr2) const\n{\n  auto res = isl_ast_expr_div(copy(), expr2.release());\n  return manage(res);\n}\n\nast_expr ast_expr::eq(ast_expr expr2) const\n{\n  auto res = isl_ast_expr_eq(copy(), expr2.release());\n  return manage(res);\n}\n\nast_expr ast_expr::from_id(id id)\n{\n  auto res = isl_ast_expr_from_id(id.release());\n  return manage(res);\n}\n\nast_expr ast_expr::from_val(val v)\n{\n  auto res = isl_ast_expr_from_val(v.release());\n  return manage(res);\n}\n\nast_expr ast_expr::ge(ast_expr expr2) const\n{\n  auto res = isl_ast_expr_ge(copy(), expr2.release());\n  return manage(res);\n}\n\nid ast_expr::get_id() const\n{\n  auto res = isl_ast_expr_get_id(get());\n  return manage(res);\n}\n\nast_expr ast_expr::get_op_arg(int pos) const\n{\n  auto res = isl_ast_expr_get_op_arg(get(), pos);\n  return manage(res);\n}\n\nisl_size ast_expr::get_op_n_arg() const\n{\n  auto res = isl_ast_expr_get_op_n_arg(get());\n  return res;\n}\n\nval ast_expr::get_val() const\n{\n  auto res = isl_ast_expr_get_val(get());\n  return manage(res);\n}\n\nast_expr ast_expr::gt(ast_expr expr2) const\n{\n  auto res = isl_ast_expr_gt(copy(), expr2.release());\n  return manage(res);\n}\n\nid ast_expr::id_get_id() const\n{\n  auto res = isl_ast_expr_id_get_id(get());\n  return manage(res);\n}\n\nval ast_expr::int_get_val() const\n{\n  auto res = isl_ast_expr_int_get_val(get());\n  return manage(res);\n}\n\nboolean ast_expr::is_equal(const ast_expr &expr2) const\n{\n  auto res = isl_ast_expr_is_equal(get(), expr2.get());\n  return manage(res);\n}\n\nast_expr ast_expr::le(ast_expr expr2) const\n{\n  auto res = isl_ast_expr_le(copy(), expr2.release());\n  return manage(res);\n}\n\nast_expr ast_expr::lt(ast_expr expr2) const\n{\n  auto res = isl_ast_expr_lt(copy(), expr2.release());\n  return manage(res);\n}\n\nast_expr ast_expr::mul(ast_expr expr2) const\n{\n  auto res = isl_ast_expr_mul(copy(), expr2.release());\n  return manage(res);\n}\n\nast_expr ast_expr::neg() const\n{\n  auto res = isl_ast_expr_neg(copy());\n  return manage(res);\n}\n\nast_expr ast_expr::op_get_arg(int pos) const\n{\n  auto res = isl_ast_expr_op_get_arg(get(), pos);\n  return manage(res);\n}\n\nisl_size ast_expr::op_get_n_arg() const\n{\n  auto res = isl_ast_expr_op_get_n_arg(get());\n  return res;\n}\n\nast_expr ast_expr::pdiv_q(ast_expr expr2) const\n{\n  auto res = isl_ast_expr_pdiv_q(copy(), expr2.release());\n  return manage(res);\n}\n\nast_expr ast_expr::pdiv_r(ast_expr expr2) const\n{\n  auto res = isl_ast_expr_pdiv_r(copy(), expr2.release());\n  return manage(res);\n}\n\nast_expr ast_expr::set_op_arg(int pos, ast_expr arg) const\n{\n  auto res = isl_ast_expr_set_op_arg(copy(), pos, arg.release());\n  return manage(res);\n}\n\nast_expr ast_expr::sub(ast_expr expr2) const\n{\n  auto res = isl_ast_expr_sub(copy(), expr2.release());\n  return manage(res);\n}\n\nast_expr ast_expr::substitute_ids(id_to_ast_expr id2expr) const\n{\n  auto res = isl_ast_expr_substitute_ids(copy(), id2expr.release());\n  return manage(res);\n}\n\nstd::string ast_expr::to_C_str() const\n{\n  auto res = isl_ast_expr_to_C_str(get());\n  std::string tmp(res);\n  free(res);\n  return tmp;\n}\n\n// implementations for isl::ast_expr_list\nast_expr_list manage(__isl_take isl_ast_expr_list *ptr) {\n  return ast_expr_list(ptr);\n}\nast_expr_list manage_copy(__isl_keep isl_ast_expr_list *ptr) {\n  ptr = isl_ast_expr_list_copy(ptr);\n  return ast_expr_list(ptr);\n}\n\nast_expr_list::ast_expr_list()\n    : ptr(nullptr) {}\n\nast_expr_list::ast_expr_list(const ast_expr_list &obj)\n    : ptr(nullptr)\n{\n  ptr = obj.copy();\n}\nast_expr_list::ast_expr_list(std::nullptr_t)\n    : ptr(nullptr) {}\n\n\nast_expr_list::ast_expr_list(__isl_take isl_ast_expr_list *ptr)\n    : ptr(ptr) {}\n\n\nast_expr_list &ast_expr_list::operator=(ast_expr_list obj) {\n  std::swap(this->ptr, obj.ptr);\n  return *this;\n}\n\nast_expr_list::~ast_expr_list() {\n  if (ptr)\n    isl_ast_expr_list_free(ptr);\n}\n\n__isl_give isl_ast_expr_list *ast_expr_list::copy() const & {\n  return isl_ast_expr_list_copy(ptr);\n}\n\n__isl_keep isl_ast_expr_list *ast_expr_list::get() const {\n  return ptr;\n}\n\n__isl_give isl_ast_expr_list *ast_expr_list::release() {\n  isl_ast_expr_list *tmp = ptr;\n  ptr = nullptr;\n  return tmp;\n}\n\nbool ast_expr_list::is_null() const {\n  return ptr == nullptr;\n}\nast_expr_list::operator bool() const {\n  return !is_null();\n}\n\n\nctx ast_expr_list::get_ctx() const {\n  return ctx(isl_ast_expr_list_get_ctx(ptr));\n}\nstd::string ast_expr_list::to_str() const {\n  char *Tmp = isl_ast_expr_list_to_str(get());\n  if (!Tmp)\n    return \"\";\n  std::string S(Tmp);\n  free(Tmp);\n  return S;\n}\n\n\nvoid ast_expr_list::dump() const {\n  isl_ast_expr_list_dump(get());\n}\n\n\nast_expr_list ast_expr_list::add(ast_expr el) const\n{\n  auto res = isl_ast_expr_list_add(copy(), el.release());\n  return manage(res);\n}\n\nast_expr_list ast_expr_list::alloc(ctx ctx, int n)\n{\n  auto res = isl_ast_expr_list_alloc(ctx.release(), n);\n  return manage(res);\n}\n\nast_expr_list ast_expr_list::clear() const\n{\n  auto res = isl_ast_expr_list_clear(copy());\n  return manage(res);\n}\n\nast_expr_list ast_expr_list::concat(ast_expr_list list2) const\n{\n  auto res = isl_ast_expr_list_concat(copy(), list2.release());\n  return manage(res);\n}\n\nast_expr_list ast_expr_list::drop(unsigned int first, unsigned int n) const\n{\n  auto res = isl_ast_expr_list_drop(copy(), first, n);\n  return manage(res);\n}\n\nstat ast_expr_list::foreach(const std::function<stat(ast_expr)> &fn) const\n{\n  struct fn_data {\n    const std::function<stat(ast_expr)> *func;\n  } fn_data = { &fn };\n  auto fn_lambda = [](isl_ast_expr *arg_0, void *arg_1) -> isl_stat {\n    auto *data = static_cast<struct fn_data *>(arg_1);\n    stat ret = (*data->func)(manage(arg_0));\n    return ret.release();\n  };\n  auto res = isl_ast_expr_list_foreach(get(), fn_lambda, &fn_data);\n  return manage(res);\n}\n\nast_expr_list ast_expr_list::from_ast_expr(ast_expr el)\n{\n  auto res = isl_ast_expr_list_from_ast_expr(el.release());\n  return manage(res);\n}\n\nast_expr ast_expr_list::get_ast_expr(int index) const\n{\n  auto res = isl_ast_expr_list_get_ast_expr(get(), index);\n  return manage(res);\n}\n\nast_expr ast_expr_list::get_at(int index) const\n{\n  auto res = isl_ast_expr_list_get_at(get(), index);\n  return manage(res);\n}\n\nast_expr_list ast_expr_list::insert(unsigned int pos, ast_expr el) const\n{\n  auto res = isl_ast_expr_list_insert(copy(), pos, el.release());\n  return manage(res);\n}\n\nisl_size ast_expr_list::n_ast_expr() const\n{\n  auto res = isl_ast_expr_list_n_ast_expr(get());\n  return res;\n}\n\nast_expr_list ast_expr_list::reverse() const\n{\n  auto res = isl_ast_expr_list_reverse(copy());\n  return manage(res);\n}\n\nast_expr_list ast_expr_list::set_ast_expr(int index, ast_expr el) const\n{\n  auto res = isl_ast_expr_list_set_ast_expr(copy(), index, el.release());\n  return manage(res);\n}\n\nisl_size ast_expr_list::size() const\n{\n  auto res = isl_ast_expr_list_size(get());\n  return res;\n}\n\nast_expr_list ast_expr_list::swap(unsigned int pos1, unsigned int pos2) const\n{\n  auto res = isl_ast_expr_list_swap(copy(), pos1, pos2);\n  return manage(res);\n}\n\n// implementations for isl::ast_node\nast_node manage(__isl_take isl_ast_node *ptr) {\n  return ast_node(ptr);\n}\nast_node manage_copy(__isl_keep isl_ast_node *ptr) {\n  ptr = isl_ast_node_copy(ptr);\n  return ast_node(ptr);\n}\n\nast_node::ast_node()\n    : ptr(nullptr) {}\n\nast_node::ast_node(const ast_node &obj)\n    : ptr(nullptr)\n{\n  ptr = obj.copy();\n}\nast_node::ast_node(std::nullptr_t)\n    : ptr(nullptr) {}\n\n\nast_node::ast_node(__isl_take isl_ast_node *ptr)\n    : ptr(ptr) {}\n\n\nast_node &ast_node::operator=(ast_node obj) {\n  std::swap(this->ptr, obj.ptr);\n  return *this;\n}\n\nast_node::~ast_node() {\n  if (ptr)\n    isl_ast_node_free(ptr);\n}\n\n__isl_give isl_ast_node *ast_node::copy() const & {\n  return isl_ast_node_copy(ptr);\n}\n\n__isl_keep isl_ast_node *ast_node::get() const {\n  return ptr;\n}\n\n__isl_give isl_ast_node *ast_node::release() {\n  isl_ast_node *tmp = ptr;\n  ptr = nullptr;\n  return tmp;\n}\n\nbool ast_node::is_null() const {\n  return ptr == nullptr;\n}\nast_node::operator bool() const {\n  return !is_null();\n}\n\n\nctx ast_node::get_ctx() const {\n  return ctx(isl_ast_node_get_ctx(ptr));\n}\nstd::string ast_node::to_str() const {\n  char *Tmp = isl_ast_node_to_str(get());\n  if (!Tmp)\n    return \"\";\n  std::string S(Tmp);\n  free(Tmp);\n  return S;\n}\n\n\nvoid ast_node::dump() const {\n  isl_ast_node_dump(get());\n}\n\n\nast_node ast_node::alloc_user(ast_expr expr)\n{\n  auto res = isl_ast_node_alloc_user(expr.release());\n  return manage(res);\n}\n\nast_node_list ast_node::block_get_children() const\n{\n  auto res = isl_ast_node_block_get_children(get());\n  return manage(res);\n}\n\nast_node ast_node::for_get_body() const\n{\n  auto res = isl_ast_node_for_get_body(get());\n  return manage(res);\n}\n\nast_expr ast_node::for_get_cond() const\n{\n  auto res = isl_ast_node_for_get_cond(get());\n  return manage(res);\n}\n\nast_expr ast_node::for_get_inc() const\n{\n  auto res = isl_ast_node_for_get_inc(get());\n  return manage(res);\n}\n\nast_expr ast_node::for_get_init() const\n{\n  auto res = isl_ast_node_for_get_init(get());\n  return manage(res);\n}\n\nast_expr ast_node::for_get_iterator() const\n{\n  auto res = isl_ast_node_for_get_iterator(get());\n  return manage(res);\n}\n\nboolean ast_node::for_is_degenerate() const\n{\n  auto res = isl_ast_node_for_is_degenerate(get());\n  return manage(res);\n}\n\nid ast_node::get_annotation() const\n{\n  auto res = isl_ast_node_get_annotation(get());\n  return manage(res);\n}\n\nast_expr ast_node::if_get_cond() const\n{\n  auto res = isl_ast_node_if_get_cond(get());\n  return manage(res);\n}\n\nast_node ast_node::if_get_else() const\n{\n  auto res = isl_ast_node_if_get_else(get());\n  return manage(res);\n}\n\nast_node ast_node::if_get_else_node() const\n{\n  auto res = isl_ast_node_if_get_else_node(get());\n  return manage(res);\n}\n\nast_node ast_node::if_get_then() const\n{\n  auto res = isl_ast_node_if_get_then(get());\n  return manage(res);\n}\n\nast_node ast_node::if_get_then_node() const\n{\n  auto res = isl_ast_node_if_get_then_node(get());\n  return manage(res);\n}\n\nboolean ast_node::if_has_else() const\n{\n  auto res = isl_ast_node_if_has_else(get());\n  return manage(res);\n}\n\nboolean ast_node::if_has_else_node() const\n{\n  auto res = isl_ast_node_if_has_else_node(get());\n  return manage(res);\n}\n\nid ast_node::mark_get_id() const\n{\n  auto res = isl_ast_node_mark_get_id(get());\n  return manage(res);\n}\n\nast_node ast_node::mark_get_node() const\n{\n  auto res = isl_ast_node_mark_get_node(get());\n  return manage(res);\n}\n\nast_node ast_node::set_annotation(id annotation) const\n{\n  auto res = isl_ast_node_set_annotation(copy(), annotation.release());\n  return manage(res);\n}\n\nstd::string ast_node::to_C_str() const\n{\n  auto res = isl_ast_node_to_C_str(get());\n  std::string tmp(res);\n  free(res);\n  return tmp;\n}\n\nast_expr ast_node::user_get_expr() const\n{\n  auto res = isl_ast_node_user_get_expr(get());\n  return manage(res);\n}\n\n// implementations for isl::ast_node_list\nast_node_list manage(__isl_take isl_ast_node_list *ptr) {\n  return ast_node_list(ptr);\n}\nast_node_list manage_copy(__isl_keep isl_ast_node_list *ptr) {\n  ptr = isl_ast_node_list_copy(ptr);\n  return ast_node_list(ptr);\n}\n\nast_node_list::ast_node_list()\n    : ptr(nullptr) {}\n\nast_node_list::ast_node_list(const ast_node_list &obj)\n    : ptr(nullptr)\n{\n  ptr = obj.copy();\n}\nast_node_list::ast_node_list(std::nullptr_t)\n    : ptr(nullptr) {}\n\n\nast_node_list::ast_node_list(__isl_take isl_ast_node_list *ptr)\n    : ptr(ptr) {}\n\n\nast_node_list &ast_node_list::operator=(ast_node_list obj) {\n  std::swap(this->ptr, obj.ptr);\n  return *this;\n}\n\nast_node_list::~ast_node_list() {\n  if (ptr)\n    isl_ast_node_list_free(ptr);\n}\n\n__isl_give isl_ast_node_list *ast_node_list::copy() const & {\n  return isl_ast_node_list_copy(ptr);\n}\n\n__isl_keep isl_ast_node_list *ast_node_list::get() const {\n  return ptr;\n}\n\n__isl_give isl_ast_node_list *ast_node_list::release() {\n  isl_ast_node_list *tmp = ptr;\n  ptr = nullptr;\n  return tmp;\n}\n\nbool ast_node_list::is_null() const {\n  return ptr == nullptr;\n}\nast_node_list::operator bool() const {\n  return !is_null();\n}\n\n\nctx ast_node_list::get_ctx() const {\n  return ctx(isl_ast_node_list_get_ctx(ptr));\n}\nstd::string ast_node_list::to_str() const {\n  char *Tmp = isl_ast_node_list_to_str(get());\n  if (!Tmp)\n    return \"\";\n  std::string S(Tmp);\n  free(Tmp);\n  return S;\n}\n\n\nvoid ast_node_list::dump() const {\n  isl_ast_node_list_dump(get());\n}\n\n\nast_node_list ast_node_list::add(ast_node el) const\n{\n  auto res = isl_ast_node_list_add(copy(), el.release());\n  return manage(res);\n}\n\nast_node_list ast_node_list::alloc(ctx ctx, int n)\n{\n  auto res = isl_ast_node_list_alloc(ctx.release(), n);\n  return manage(res);\n}\n\nast_node_list ast_node_list::clear() const\n{\n  auto res = isl_ast_node_list_clear(copy());\n  return manage(res);\n}\n\nast_node_list ast_node_list::concat(ast_node_list list2) const\n{\n  auto res = isl_ast_node_list_concat(copy(), list2.release());\n  return manage(res);\n}\n\nast_node_list ast_node_list::drop(unsigned int first, unsigned int n) const\n{\n  auto res = isl_ast_node_list_drop(copy(), first, n);\n  return manage(res);\n}\n\nstat ast_node_list::foreach(const std::function<stat(ast_node)> &fn) const\n{\n  struct fn_data {\n    const std::function<stat(ast_node)> *func;\n  } fn_data = { &fn };\n  auto fn_lambda = [](isl_ast_node *arg_0, void *arg_1) -> isl_stat {\n    auto *data = static_cast<struct fn_data *>(arg_1);\n    stat ret = (*data->func)(manage(arg_0));\n    return ret.release();\n  };\n  auto res = isl_ast_node_list_foreach(get(), fn_lambda, &fn_data);\n  return manage(res);\n}\n\nast_node_list ast_node_list::from_ast_node(ast_node el)\n{\n  auto res = isl_ast_node_list_from_ast_node(el.release());\n  return manage(res);\n}\n\nast_node ast_node_list::get_ast_node(int index) const\n{\n  auto res = isl_ast_node_list_get_ast_node(get(), index);\n  return manage(res);\n}\n\nast_node ast_node_list::get_at(int index) const\n{\n  auto res = isl_ast_node_list_get_at(get(), index);\n  return manage(res);\n}\n\nast_node_list ast_node_list::insert(unsigned int pos, ast_node el) const\n{\n  auto res = isl_ast_node_list_insert(copy(), pos, el.release());\n  return manage(res);\n}\n\nisl_size ast_node_list::n_ast_node() const\n{\n  auto res = isl_ast_node_list_n_ast_node(get());\n  return res;\n}\n\nast_node_list ast_node_list::reverse() const\n{\n  auto res = isl_ast_node_list_reverse(copy());\n  return manage(res);\n}\n\nast_node_list ast_node_list::set_ast_node(int index, ast_node el) const\n{\n  auto res = isl_ast_node_list_set_ast_node(copy(), index, el.release());\n  return manage(res);\n}\n\nisl_size ast_node_list::size() const\n{\n  auto res = isl_ast_node_list_size(get());\n  return res;\n}\n\nast_node_list ast_node_list::swap(unsigned int pos1, unsigned int pos2) const\n{\n  auto res = isl_ast_node_list_swap(copy(), pos1, pos2);\n  return manage(res);\n}\n\n// implementations for isl::basic_map\nbasic_map manage(__isl_take isl_basic_map *ptr) {\n  return basic_map(ptr);\n}\nbasic_map manage_copy(__isl_keep isl_basic_map *ptr) {\n  ptr = isl_basic_map_copy(ptr);\n  return basic_map(ptr);\n}\n\nbasic_map::basic_map()\n    : ptr(nullptr) {}\n\nbasic_map::basic_map(const basic_map &obj)\n    : ptr(nullptr)\n{\n  ptr = obj.copy();\n}\nbasic_map::basic_map(std::nullptr_t)\n    : ptr(nullptr) {}\n\n\nbasic_map::basic_map(__isl_take isl_basic_map *ptr)\n    : ptr(ptr) {}\n\nbasic_map::basic_map(ctx ctx, const std::string &str)\n{\n  auto res = isl_basic_map_read_from_str(ctx.release(), str.c_str());\n  ptr = res;\n}\n\nbasic_map &basic_map::operator=(basic_map obj) {\n  std::swap(this->ptr, obj.ptr);\n  return *this;\n}\n\nbasic_map::~basic_map() {\n  if (ptr)\n    isl_basic_map_free(ptr);\n}\n\n__isl_give isl_basic_map *basic_map::copy() const & {\n  return isl_basic_map_copy(ptr);\n}\n\n__isl_keep isl_basic_map *basic_map::get() const {\n  return ptr;\n}\n\n__isl_give isl_basic_map *basic_map::release() {\n  isl_basic_map *tmp = ptr;\n  ptr = nullptr;\n  return tmp;\n}\n\nbool basic_map::is_null() const {\n  return ptr == nullptr;\n}\nbasic_map::operator bool() const {\n  return !is_null();\n}\n\n\nctx basic_map::get_ctx() const {\n  return ctx(isl_basic_map_get_ctx(ptr));\n}\nstd::string basic_map::to_str() const {\n  char *Tmp = isl_basic_map_to_str(get());\n  if (!Tmp)\n    return \"\";\n  std::string S(Tmp);\n  free(Tmp);\n  return S;\n}\n\n\nvoid basic_map::dump() const {\n  isl_basic_map_dump(get());\n}\n\n\nbasic_map basic_map::add_constraint(constraint constraint) const\n{\n  auto res = isl_basic_map_add_constraint(copy(), constraint.release());\n  return manage(res);\n}\n\nbasic_map basic_map::add_dims(isl::dim type, unsigned int n) const\n{\n  auto res = isl_basic_map_add_dims(copy(), static_cast<enum isl_dim_type>(type), n);\n  return manage(res);\n}\n\nbasic_map basic_map::affine_hull() const\n{\n  auto res = isl_basic_map_affine_hull(copy());\n  return manage(res);\n}\n\nbasic_map basic_map::align_params(space model) const\n{\n  auto res = isl_basic_map_align_params(copy(), model.release());\n  return manage(res);\n}\n\nbasic_map basic_map::apply_domain(basic_map bmap2) const\n{\n  auto res = isl_basic_map_apply_domain(copy(), bmap2.release());\n  return manage(res);\n}\n\nbasic_map basic_map::apply_range(basic_map bmap2) const\n{\n  auto res = isl_basic_map_apply_range(copy(), bmap2.release());\n  return manage(res);\n}\n\nboolean basic_map::can_curry() const\n{\n  auto res = isl_basic_map_can_curry(get());\n  return manage(res);\n}\n\nboolean basic_map::can_uncurry() const\n{\n  auto res = isl_basic_map_can_uncurry(get());\n  return manage(res);\n}\n\nboolean basic_map::can_zip() const\n{\n  auto res = isl_basic_map_can_zip(get());\n  return manage(res);\n}\n\nbasic_map basic_map::curry() const\n{\n  auto res = isl_basic_map_curry(copy());\n  return manage(res);\n}\n\nbasic_set basic_map::deltas() const\n{\n  auto res = isl_basic_map_deltas(copy());\n  return manage(res);\n}\n\nbasic_map basic_map::deltas_map() const\n{\n  auto res = isl_basic_map_deltas_map(copy());\n  return manage(res);\n}\n\nbasic_map basic_map::detect_equalities() const\n{\n  auto res = isl_basic_map_detect_equalities(copy());\n  return manage(res);\n}\n\nisl_size basic_map::dim(isl::dim type) const\n{\n  auto res = isl_basic_map_dim(get(), static_cast<enum isl_dim_type>(type));\n  return res;\n}\n\nbasic_set basic_map::domain() const\n{\n  auto res = isl_basic_map_domain(copy());\n  return manage(res);\n}\n\nbasic_map basic_map::domain_map() const\n{\n  auto res = isl_basic_map_domain_map(copy());\n  return manage(res);\n}\n\nbasic_map basic_map::domain_product(basic_map bmap2) const\n{\n  auto res = isl_basic_map_domain_product(copy(), bmap2.release());\n  return manage(res);\n}\n\nbasic_map basic_map::drop_constraints_involving_dims(isl::dim type, unsigned int first, unsigned int n) const\n{\n  auto res = isl_basic_map_drop_constraints_involving_dims(copy(), static_cast<enum isl_dim_type>(type), first, n);\n  return manage(res);\n}\n\nbasic_map basic_map::drop_constraints_not_involving_dims(isl::dim type, unsigned int first, unsigned int n) const\n{\n  auto res = isl_basic_map_drop_constraints_not_involving_dims(copy(), static_cast<enum isl_dim_type>(type), first, n);\n  return manage(res);\n}\n\nbasic_map basic_map::drop_unused_params() const\n{\n  auto res = isl_basic_map_drop_unused_params(copy());\n  return manage(res);\n}\n\nbasic_map basic_map::eliminate(isl::dim type, unsigned int first, unsigned int n) const\n{\n  auto res = isl_basic_map_eliminate(copy(), static_cast<enum isl_dim_type>(type), first, n);\n  return manage(res);\n}\n\nbasic_map basic_map::empty(space space)\n{\n  auto res = isl_basic_map_empty(space.release());\n  return manage(res);\n}\n\nbasic_map basic_map::equal(space space, unsigned int n_equal)\n{\n  auto res = isl_basic_map_equal(space.release(), n_equal);\n  return manage(res);\n}\n\nmat basic_map::equalities_matrix(isl::dim c1, isl::dim c2, isl::dim c3, isl::dim c4, isl::dim c5) const\n{\n  auto res = isl_basic_map_equalities_matrix(get(), static_cast<enum isl_dim_type>(c1), static_cast<enum isl_dim_type>(c2), static_cast<enum isl_dim_type>(c3), static_cast<enum isl_dim_type>(c4), static_cast<enum isl_dim_type>(c5));\n  return manage(res);\n}\n\nbasic_map basic_map::equate(isl::dim type1, int pos1, isl::dim type2, int pos2) const\n{\n  auto res = isl_basic_map_equate(copy(), static_cast<enum isl_dim_type>(type1), pos1, static_cast<enum isl_dim_type>(type2), pos2);\n  return manage(res);\n}\n\nint basic_map::find_dim_by_name(isl::dim type, const std::string &name) const\n{\n  auto res = isl_basic_map_find_dim_by_name(get(), static_cast<enum isl_dim_type>(type), name.c_str());\n  return res;\n}\n\nbasic_map basic_map::fix_si(isl::dim type, unsigned int pos, int value) const\n{\n  auto res = isl_basic_map_fix_si(copy(), static_cast<enum isl_dim_type>(type), pos, value);\n  return manage(res);\n}\n\nbasic_map basic_map::fix_val(isl::dim type, unsigned int pos, val v) const\n{\n  auto res = isl_basic_map_fix_val(copy(), static_cast<enum isl_dim_type>(type), pos, v.release());\n  return manage(res);\n}\n\nbasic_map basic_map::flat_product(basic_map bmap2) const\n{\n  auto res = isl_basic_map_flat_product(copy(), bmap2.release());\n  return manage(res);\n}\n\nbasic_map basic_map::flat_range_product(basic_map bmap2) const\n{\n  auto res = isl_basic_map_flat_range_product(copy(), bmap2.release());\n  return manage(res);\n}\n\nbasic_map basic_map::flatten() const\n{\n  auto res = isl_basic_map_flatten(copy());\n  return manage(res);\n}\n\nbasic_map basic_map::flatten_domain() const\n{\n  auto res = isl_basic_map_flatten_domain(copy());\n  return manage(res);\n}\n\nbasic_map basic_map::flatten_range() const\n{\n  auto res = isl_basic_map_flatten_range(copy());\n  return manage(res);\n}\n\nstat basic_map::foreach_constraint(const std::function<stat(constraint)> &fn) const\n{\n  struct fn_data {\n    const std::function<stat(constraint)> *func;\n  } fn_data = { &fn };\n  auto fn_lambda = [](isl_constraint *arg_0, void *arg_1) -> isl_stat {\n    auto *data = static_cast<struct fn_data *>(arg_1);\n    stat ret = (*data->func)(manage(arg_0));\n    return ret.release();\n  };\n  auto res = isl_basic_map_foreach_constraint(get(), fn_lambda, &fn_data);\n  return manage(res);\n}\n\nbasic_map basic_map::from_aff(aff aff)\n{\n  auto res = isl_basic_map_from_aff(aff.release());\n  return manage(res);\n}\n\nbasic_map basic_map::from_aff_list(space domain_space, aff_list list)\n{\n  auto res = isl_basic_map_from_aff_list(domain_space.release(), list.release());\n  return manage(res);\n}\n\nbasic_map basic_map::from_constraint(constraint constraint)\n{\n  auto res = isl_basic_map_from_constraint(constraint.release());\n  return manage(res);\n}\n\nbasic_map basic_map::from_domain(basic_set bset)\n{\n  auto res = isl_basic_map_from_domain(bset.release());\n  return manage(res);\n}\n\nbasic_map basic_map::from_domain_and_range(basic_set domain, basic_set range)\n{\n  auto res = isl_basic_map_from_domain_and_range(domain.release(), range.release());\n  return manage(res);\n}\n\nbasic_map basic_map::from_multi_aff(multi_aff maff)\n{\n  auto res = isl_basic_map_from_multi_aff(maff.release());\n  return manage(res);\n}\n\nbasic_map basic_map::from_qpolynomial(qpolynomial qp)\n{\n  auto res = isl_basic_map_from_qpolynomial(qp.release());\n  return manage(res);\n}\n\nbasic_map basic_map::from_range(basic_set bset)\n{\n  auto res = isl_basic_map_from_range(bset.release());\n  return manage(res);\n}\n\nconstraint_list basic_map::get_constraint_list() const\n{\n  auto res = isl_basic_map_get_constraint_list(get());\n  return manage(res);\n}\n\nstd::string basic_map::get_dim_name(isl::dim type, unsigned int pos) const\n{\n  auto res = isl_basic_map_get_dim_name(get(), static_cast<enum isl_dim_type>(type), pos);\n  std::string tmp(res);\n  return tmp;\n}\n\naff basic_map::get_div(int pos) const\n{\n  auto res = isl_basic_map_get_div(get(), pos);\n  return manage(res);\n}\n\nlocal_space basic_map::get_local_space() const\n{\n  auto res = isl_basic_map_get_local_space(get());\n  return manage(res);\n}\n\nspace basic_map::get_space() const\n{\n  auto res = isl_basic_map_get_space(get());\n  return manage(res);\n}\n\nstd::string basic_map::get_tuple_name(isl::dim type) const\n{\n  auto res = isl_basic_map_get_tuple_name(get(), static_cast<enum isl_dim_type>(type));\n  std::string tmp(res);\n  return tmp;\n}\n\nbasic_map basic_map::gist(basic_map context) const\n{\n  auto res = isl_basic_map_gist(copy(), context.release());\n  return manage(res);\n}\n\nbasic_map basic_map::gist_domain(basic_set context) const\n{\n  auto res = isl_basic_map_gist_domain(copy(), context.release());\n  return manage(res);\n}\n\nboolean basic_map::has_dim_id(isl::dim type, unsigned int pos) const\n{\n  auto res = isl_basic_map_has_dim_id(get(), static_cast<enum isl_dim_type>(type), pos);\n  return manage(res);\n}\n\nbasic_map basic_map::identity(space space)\n{\n  auto res = isl_basic_map_identity(space.release());\n  return manage(res);\n}\n\nboolean basic_map::image_is_bounded() const\n{\n  auto res = isl_basic_map_image_is_bounded(get());\n  return manage(res);\n}\n\nmat basic_map::inequalities_matrix(isl::dim c1, isl::dim c2, isl::dim c3, isl::dim c4, isl::dim c5) const\n{\n  auto res = isl_basic_map_inequalities_matrix(get(), static_cast<enum isl_dim_type>(c1), static_cast<enum isl_dim_type>(c2), static_cast<enum isl_dim_type>(c3), static_cast<enum isl_dim_type>(c4), static_cast<enum isl_dim_type>(c5));\n  return manage(res);\n}\n\nbasic_map basic_map::insert_dims(isl::dim type, unsigned int pos, unsigned int n) const\n{\n  auto res = isl_basic_map_insert_dims(copy(), static_cast<enum isl_dim_type>(type), pos, n);\n  return manage(res);\n}\n\nbasic_map basic_map::intersect(basic_map bmap2) const\n{\n  auto res = isl_basic_map_intersect(copy(), bmap2.release());\n  return manage(res);\n}\n\nbasic_map basic_map::intersect_domain(basic_set bset) const\n{\n  auto res = isl_basic_map_intersect_domain(copy(), bset.release());\n  return manage(res);\n}\n\nbasic_map basic_map::intersect_range(basic_set bset) const\n{\n  auto res = isl_basic_map_intersect_range(copy(), bset.release());\n  return manage(res);\n}\n\nboolean basic_map::involves_dims(isl::dim type, unsigned int first, unsigned int n) const\n{\n  auto res = isl_basic_map_involves_dims(get(), static_cast<enum isl_dim_type>(type), first, n);\n  return manage(res);\n}\n\nboolean basic_map::is_disjoint(const basic_map &bmap2) const\n{\n  auto res = isl_basic_map_is_disjoint(get(), bmap2.get());\n  return manage(res);\n}\n\nboolean basic_map::is_empty() const\n{\n  auto res = isl_basic_map_is_empty(get());\n  return manage(res);\n}\n\nboolean basic_map::is_equal(const basic_map &bmap2) const\n{\n  auto res = isl_basic_map_is_equal(get(), bmap2.get());\n  return manage(res);\n}\n\nboolean basic_map::is_rational() const\n{\n  auto res = isl_basic_map_is_rational(get());\n  return manage(res);\n}\n\nboolean basic_map::is_single_valued() const\n{\n  auto res = isl_basic_map_is_single_valued(get());\n  return manage(res);\n}\n\nboolean basic_map::is_strict_subset(const basic_map &bmap2) const\n{\n  auto res = isl_basic_map_is_strict_subset(get(), bmap2.get());\n  return manage(res);\n}\n\nboolean basic_map::is_subset(const basic_map &bmap2) const\n{\n  auto res = isl_basic_map_is_subset(get(), bmap2.get());\n  return manage(res);\n}\n\nboolean basic_map::is_universe() const\n{\n  auto res = isl_basic_map_is_universe(get());\n  return manage(res);\n}\n\nbasic_map basic_map::less_at(space space, unsigned int pos)\n{\n  auto res = isl_basic_map_less_at(space.release(), pos);\n  return manage(res);\n}\n\nmap basic_map::lexmax() const\n{\n  auto res = isl_basic_map_lexmax(copy());\n  return manage(res);\n}\n\nmap basic_map::lexmin() const\n{\n  auto res = isl_basic_map_lexmin(copy());\n  return manage(res);\n}\n\npw_multi_aff basic_map::lexmin_pw_multi_aff() const\n{\n  auto res = isl_basic_map_lexmin_pw_multi_aff(copy());\n  return manage(res);\n}\n\nbasic_map basic_map::lower_bound_si(isl::dim type, unsigned int pos, int value) const\n{\n  auto res = isl_basic_map_lower_bound_si(copy(), static_cast<enum isl_dim_type>(type), pos, value);\n  return manage(res);\n}\n\nbasic_map basic_map::more_at(space space, unsigned int pos)\n{\n  auto res = isl_basic_map_more_at(space.release(), pos);\n  return manage(res);\n}\n\nbasic_map basic_map::move_dims(isl::dim dst_type, unsigned int dst_pos, isl::dim src_type, unsigned int src_pos, unsigned int n) const\n{\n  auto res = isl_basic_map_move_dims(copy(), static_cast<enum isl_dim_type>(dst_type), dst_pos, static_cast<enum isl_dim_type>(src_type), src_pos, n);\n  return manage(res);\n}\n\nisl_size basic_map::n_constraint() const\n{\n  auto res = isl_basic_map_n_constraint(get());\n  return res;\n}\n\nbasic_map basic_map::nat_universe(space space)\n{\n  auto res = isl_basic_map_nat_universe(space.release());\n  return manage(res);\n}\n\nbasic_map basic_map::neg() const\n{\n  auto res = isl_basic_map_neg(copy());\n  return manage(res);\n}\n\nbasic_map basic_map::order_ge(isl::dim type1, int pos1, isl::dim type2, int pos2) const\n{\n  auto res = isl_basic_map_order_ge(copy(), static_cast<enum isl_dim_type>(type1), pos1, static_cast<enum isl_dim_type>(type2), pos2);\n  return manage(res);\n}\n\nbasic_map basic_map::order_gt(isl::dim type1, int pos1, isl::dim type2, int pos2) const\n{\n  auto res = isl_basic_map_order_gt(copy(), static_cast<enum isl_dim_type>(type1), pos1, static_cast<enum isl_dim_type>(type2), pos2);\n  return manage(res);\n}\n\nval basic_map::plain_get_val_if_fixed(isl::dim type, unsigned int pos) const\n{\n  auto res = isl_basic_map_plain_get_val_if_fixed(get(), static_cast<enum isl_dim_type>(type), pos);\n  return manage(res);\n}\n\nboolean basic_map::plain_is_empty() const\n{\n  auto res = isl_basic_map_plain_is_empty(get());\n  return manage(res);\n}\n\nboolean basic_map::plain_is_universe() const\n{\n  auto res = isl_basic_map_plain_is_universe(get());\n  return manage(res);\n}\n\nbasic_map basic_map::preimage_domain_multi_aff(multi_aff ma) const\n{\n  auto res = isl_basic_map_preimage_domain_multi_aff(copy(), ma.release());\n  return manage(res);\n}\n\nbasic_map basic_map::preimage_range_multi_aff(multi_aff ma) const\n{\n  auto res = isl_basic_map_preimage_range_multi_aff(copy(), ma.release());\n  return manage(res);\n}\n\nbasic_map basic_map::product(basic_map bmap2) const\n{\n  auto res = isl_basic_map_product(copy(), bmap2.release());\n  return manage(res);\n}\n\nbasic_map basic_map::project_out(isl::dim type, unsigned int first, unsigned int n) const\n{\n  auto res = isl_basic_map_project_out(copy(), static_cast<enum isl_dim_type>(type), first, n);\n  return manage(res);\n}\n\nbasic_set basic_map::range() const\n{\n  auto res = isl_basic_map_range(copy());\n  return manage(res);\n}\n\nbasic_map basic_map::range_map() const\n{\n  auto res = isl_basic_map_range_map(copy());\n  return manage(res);\n}\n\nbasic_map basic_map::range_product(basic_map bmap2) const\n{\n  auto res = isl_basic_map_range_product(copy(), bmap2.release());\n  return manage(res);\n}\n\nbasic_map basic_map::remove_dims(isl::dim type, unsigned int first, unsigned int n) const\n{\n  auto res = isl_basic_map_remove_dims(copy(), static_cast<enum isl_dim_type>(type), first, n);\n  return manage(res);\n}\n\nbasic_map basic_map::remove_divs() const\n{\n  auto res = isl_basic_map_remove_divs(copy());\n  return manage(res);\n}\n\nbasic_map basic_map::remove_divs_involving_dims(isl::dim type, unsigned int first, unsigned int n) const\n{\n  auto res = isl_basic_map_remove_divs_involving_dims(copy(), static_cast<enum isl_dim_type>(type), first, n);\n  return manage(res);\n}\n\nbasic_map basic_map::remove_redundancies() const\n{\n  auto res = isl_basic_map_remove_redundancies(copy());\n  return manage(res);\n}\n\nbasic_map basic_map::reverse() const\n{\n  auto res = isl_basic_map_reverse(copy());\n  return manage(res);\n}\n\nbasic_map basic_map::sample() const\n{\n  auto res = isl_basic_map_sample(copy());\n  return manage(res);\n}\n\nbasic_map basic_map::set_tuple_id(isl::dim type, id id) const\n{\n  auto res = isl_basic_map_set_tuple_id(copy(), static_cast<enum isl_dim_type>(type), id.release());\n  return manage(res);\n}\n\nbasic_map basic_map::set_tuple_name(isl::dim type, const std::string &s) const\n{\n  auto res = isl_basic_map_set_tuple_name(copy(), static_cast<enum isl_dim_type>(type), s.c_str());\n  return manage(res);\n}\n\nbasic_map basic_map::sum(basic_map bmap2) const\n{\n  auto res = isl_basic_map_sum(copy(), bmap2.release());\n  return manage(res);\n}\n\nbasic_map basic_map::uncurry() const\n{\n  auto res = isl_basic_map_uncurry(copy());\n  return manage(res);\n}\n\nmap basic_map::unite(basic_map bmap2) const\n{\n  auto res = isl_basic_map_union(copy(), bmap2.release());\n  return manage(res);\n}\n\nbasic_map basic_map::universe(space space)\n{\n  auto res = isl_basic_map_universe(space.release());\n  return manage(res);\n}\n\nbasic_map basic_map::upper_bound_si(isl::dim type, unsigned int pos, int value) const\n{\n  auto res = isl_basic_map_upper_bound_si(copy(), static_cast<enum isl_dim_type>(type), pos, value);\n  return manage(res);\n}\n\nbasic_set basic_map::wrap() const\n{\n  auto res = isl_basic_map_wrap(copy());\n  return manage(res);\n}\n\nbasic_map basic_map::zip() const\n{\n  auto res = isl_basic_map_zip(copy());\n  return manage(res);\n}\n\n// implementations for isl::basic_map_list\nbasic_map_list manage(__isl_take isl_basic_map_list *ptr) {\n  return basic_map_list(ptr);\n}\nbasic_map_list manage_copy(__isl_keep isl_basic_map_list *ptr) {\n  ptr = isl_basic_map_list_copy(ptr);\n  return basic_map_list(ptr);\n}\n\nbasic_map_list::basic_map_list()\n    : ptr(nullptr) {}\n\nbasic_map_list::basic_map_list(const basic_map_list &obj)\n    : ptr(nullptr)\n{\n  ptr = obj.copy();\n}\nbasic_map_list::basic_map_list(std::nullptr_t)\n    : ptr(nullptr) {}\n\n\nbasic_map_list::basic_map_list(__isl_take isl_basic_map_list *ptr)\n    : ptr(ptr) {}\n\n\nbasic_map_list &basic_map_list::operator=(basic_map_list obj) {\n  std::swap(this->ptr, obj.ptr);\n  return *this;\n}\n\nbasic_map_list::~basic_map_list() {\n  if (ptr)\n    isl_basic_map_list_free(ptr);\n}\n\n__isl_give isl_basic_map_list *basic_map_list::copy() const & {\n  return isl_basic_map_list_copy(ptr);\n}\n\n__isl_keep isl_basic_map_list *basic_map_list::get() const {\n  return ptr;\n}\n\n__isl_give isl_basic_map_list *basic_map_list::release() {\n  isl_basic_map_list *tmp = ptr;\n  ptr = nullptr;\n  return tmp;\n}\n\nbool basic_map_list::is_null() const {\n  return ptr == nullptr;\n}\nbasic_map_list::operator bool() const {\n  return !is_null();\n}\n\n\nctx basic_map_list::get_ctx() const {\n  return ctx(isl_basic_map_list_get_ctx(ptr));\n}\nstd::string basic_map_list::to_str() const {\n  char *Tmp = isl_basic_map_list_to_str(get());\n  if (!Tmp)\n    return \"\";\n  std::string S(Tmp);\n  free(Tmp);\n  return S;\n}\n\n\nvoid basic_map_list::dump() const {\n  isl_basic_map_list_dump(get());\n}\n\n\nbasic_map_list basic_map_list::add(basic_map el) const\n{\n  auto res = isl_basic_map_list_add(copy(), el.release());\n  return manage(res);\n}\n\nbasic_map_list basic_map_list::alloc(ctx ctx, int n)\n{\n  auto res = isl_basic_map_list_alloc(ctx.release(), n);\n  return manage(res);\n}\n\nbasic_map_list basic_map_list::clear() const\n{\n  auto res = isl_basic_map_list_clear(copy());\n  return manage(res);\n}\n\nbasic_map_list basic_map_list::concat(basic_map_list list2) const\n{\n  auto res = isl_basic_map_list_concat(copy(), list2.release());\n  return manage(res);\n}\n\nbasic_map_list basic_map_list::drop(unsigned int first, unsigned int n) const\n{\n  auto res = isl_basic_map_list_drop(copy(), first, n);\n  return manage(res);\n}\n\nstat basic_map_list::foreach(const std::function<stat(basic_map)> &fn) const\n{\n  struct fn_data {\n    const std::function<stat(basic_map)> *func;\n  } fn_data = { &fn };\n  auto fn_lambda = [](isl_basic_map *arg_0, void *arg_1) -> isl_stat {\n    auto *data = static_cast<struct fn_data *>(arg_1);\n    stat ret = (*data->func)(manage(arg_0));\n    return ret.release();\n  };\n  auto res = isl_basic_map_list_foreach(get(), fn_lambda, &fn_data);\n  return manage(res);\n}\n\nbasic_map_list basic_map_list::from_basic_map(basic_map el)\n{\n  auto res = isl_basic_map_list_from_basic_map(el.release());\n  return manage(res);\n}\n\nbasic_map basic_map_list::get_at(int index) const\n{\n  auto res = isl_basic_map_list_get_at(get(), index);\n  return manage(res);\n}\n\nbasic_map basic_map_list::get_basic_map(int index) const\n{\n  auto res = isl_basic_map_list_get_basic_map(get(), index);\n  return manage(res);\n}\n\nbasic_map_list basic_map_list::insert(unsigned int pos, basic_map el) const\n{\n  auto res = isl_basic_map_list_insert(copy(), pos, el.release());\n  return manage(res);\n}\n\nisl_size basic_map_list::n_basic_map() const\n{\n  auto res = isl_basic_map_list_n_basic_map(get());\n  return res;\n}\n\nbasic_map_list basic_map_list::reverse() const\n{\n  auto res = isl_basic_map_list_reverse(copy());\n  return manage(res);\n}\n\nbasic_map_list basic_map_list::set_basic_map(int index, basic_map el) const\n{\n  auto res = isl_basic_map_list_set_basic_map(copy(), index, el.release());\n  return manage(res);\n}\n\nisl_size basic_map_list::size() const\n{\n  auto res = isl_basic_map_list_size(get());\n  return res;\n}\n\nbasic_map_list basic_map_list::swap(unsigned int pos1, unsigned int pos2) const\n{\n  auto res = isl_basic_map_list_swap(copy(), pos1, pos2);\n  return manage(res);\n}\n\n// implementations for isl::basic_set\nbasic_set manage(__isl_take isl_basic_set *ptr) {\n  return basic_set(ptr);\n}\nbasic_set manage_copy(__isl_keep isl_basic_set *ptr) {\n  ptr = isl_basic_set_copy(ptr);\n  return basic_set(ptr);\n}\n\nbasic_set::basic_set()\n    : ptr(nullptr) {}\n\nbasic_set::basic_set(const basic_set &obj)\n    : ptr(nullptr)\n{\n  ptr = obj.copy();\n}\nbasic_set::basic_set(std::nullptr_t)\n    : ptr(nullptr) {}\n\n\nbasic_set::basic_set(__isl_take isl_basic_set *ptr)\n    : ptr(ptr) {}\n\nbasic_set::basic_set(point pnt)\n{\n  auto res = isl_basic_set_from_point(pnt.release());\n  ptr = res;\n}\nbasic_set::basic_set(ctx ctx, const std::string &str)\n{\n  auto res = isl_basic_set_read_from_str(ctx.release(), str.c_str());\n  ptr = res;\n}\n\nbasic_set &basic_set::operator=(basic_set obj) {\n  std::swap(this->ptr, obj.ptr);\n  return *this;\n}\n\nbasic_set::~basic_set() {\n  if (ptr)\n    isl_basic_set_free(ptr);\n}\n\n__isl_give isl_basic_set *basic_set::copy() const & {\n  return isl_basic_set_copy(ptr);\n}\n\n__isl_keep isl_basic_set *basic_set::get() const {\n  return ptr;\n}\n\n__isl_give isl_basic_set *basic_set::release() {\n  isl_basic_set *tmp = ptr;\n  ptr = nullptr;\n  return tmp;\n}\n\nbool basic_set::is_null() const {\n  return ptr == nullptr;\n}\nbasic_set::operator bool() const {\n  return !is_null();\n}\n\n\nctx basic_set::get_ctx() const {\n  return ctx(isl_basic_set_get_ctx(ptr));\n}\nstd::string basic_set::to_str() const {\n  char *Tmp = isl_basic_set_to_str(get());\n  if (!Tmp)\n    return \"\";\n  std::string S(Tmp);\n  free(Tmp);\n  return S;\n}\n\n\nvoid basic_set::dump() const {\n  isl_basic_set_dump(get());\n}\n\n\nbasic_set basic_set::affine_hull() const\n{\n  auto res = isl_basic_set_affine_hull(copy());\n  return manage(res);\n}\n\nbasic_set basic_set::align_params(space model) const\n{\n  auto res = isl_basic_set_align_params(copy(), model.release());\n  return manage(res);\n}\n\nbasic_set basic_set::apply(basic_map bmap) const\n{\n  auto res = isl_basic_set_apply(copy(), bmap.release());\n  return manage(res);\n}\n\nbasic_set basic_set::box_from_points(point pnt1, point pnt2)\n{\n  auto res = isl_basic_set_box_from_points(pnt1.release(), pnt2.release());\n  return manage(res);\n}\n\nbasic_set basic_set::coefficients() const\n{\n  auto res = isl_basic_set_coefficients(copy());\n  return manage(res);\n}\n\nbasic_set basic_set::detect_equalities() const\n{\n  auto res = isl_basic_set_detect_equalities(copy());\n  return manage(res);\n}\n\nisl_size basic_set::dim(isl::dim type) const\n{\n  auto res = isl_basic_set_dim(get(), static_cast<enum isl_dim_type>(type));\n  return res;\n}\n\nval basic_set::dim_max_val(int pos) const\n{\n  auto res = isl_basic_set_dim_max_val(copy(), pos);\n  return manage(res);\n}\n\nbasic_set basic_set::drop_constraints_involving_dims(isl::dim type, unsigned int first, unsigned int n) const\n{\n  auto res = isl_basic_set_drop_constraints_involving_dims(copy(), static_cast<enum isl_dim_type>(type), first, n);\n  return manage(res);\n}\n\nbasic_set basic_set::drop_constraints_not_involving_dims(isl::dim type, unsigned int first, unsigned int n) const\n{\n  auto res = isl_basic_set_drop_constraints_not_involving_dims(copy(), static_cast<enum isl_dim_type>(type), first, n);\n  return manage(res);\n}\n\nbasic_set basic_set::drop_unused_params() const\n{\n  auto res = isl_basic_set_drop_unused_params(copy());\n  return manage(res);\n}\n\nbasic_set basic_set::eliminate(isl::dim type, unsigned int first, unsigned int n) const\n{\n  auto res = isl_basic_set_eliminate(copy(), static_cast<enum isl_dim_type>(type), first, n);\n  return manage(res);\n}\n\nbasic_set basic_set::empty(space space)\n{\n  auto res = isl_basic_set_empty(space.release());\n  return manage(res);\n}\n\nmat basic_set::equalities_matrix(isl::dim c1, isl::dim c2, isl::dim c3, isl::dim c4) const\n{\n  auto res = isl_basic_set_equalities_matrix(get(), static_cast<enum isl_dim_type>(c1), static_cast<enum isl_dim_type>(c2), static_cast<enum isl_dim_type>(c3), static_cast<enum isl_dim_type>(c4));\n  return manage(res);\n}\n\nbasic_set basic_set::fix_si(isl::dim type, unsigned int pos, int value) const\n{\n  auto res = isl_basic_set_fix_si(copy(), static_cast<enum isl_dim_type>(type), pos, value);\n  return manage(res);\n}\n\nbasic_set basic_set::fix_val(isl::dim type, unsigned int pos, val v) const\n{\n  auto res = isl_basic_set_fix_val(copy(), static_cast<enum isl_dim_type>(type), pos, v.release());\n  return manage(res);\n}\n\nbasic_set basic_set::flat_product(basic_set bset2) const\n{\n  auto res = isl_basic_set_flat_product(copy(), bset2.release());\n  return manage(res);\n}\n\nbasic_set basic_set::flatten() const\n{\n  auto res = isl_basic_set_flatten(copy());\n  return manage(res);\n}\n\nstat basic_set::foreach_bound_pair(isl::dim type, unsigned int pos, const std::function<stat(constraint, constraint, basic_set)> &fn) const\n{\n  struct fn_data {\n    const std::function<stat(constraint, constraint, basic_set)> *func;\n  } fn_data = { &fn };\n  auto fn_lambda = [](isl_constraint *arg_0, isl_constraint *arg_1, isl_basic_set *arg_2, void *arg_3) -> isl_stat {\n    auto *data = static_cast<struct fn_data *>(arg_3);\n    stat ret = (*data->func)(manage(arg_0), manage(arg_1), manage(arg_2));\n    return ret.release();\n  };\n  auto res = isl_basic_set_foreach_bound_pair(get(), static_cast<enum isl_dim_type>(type), pos, fn_lambda, &fn_data);\n  return manage(res);\n}\n\nstat basic_set::foreach_constraint(const std::function<stat(constraint)> &fn) const\n{\n  struct fn_data {\n    const std::function<stat(constraint)> *func;\n  } fn_data = { &fn };\n  auto fn_lambda = [](isl_constraint *arg_0, void *arg_1) -> isl_stat {\n    auto *data = static_cast<struct fn_data *>(arg_1);\n    stat ret = (*data->func)(manage(arg_0));\n    return ret.release();\n  };\n  auto res = isl_basic_set_foreach_constraint(get(), fn_lambda, &fn_data);\n  return manage(res);\n}\n\nbasic_set basic_set::from_constraint(constraint constraint)\n{\n  auto res = isl_basic_set_from_constraint(constraint.release());\n  return manage(res);\n}\n\nbasic_set basic_set::from_multi_aff(multi_aff ma)\n{\n  auto res = isl_basic_set_from_multi_aff(ma.release());\n  return manage(res);\n}\n\nbasic_set basic_set::from_params() const\n{\n  auto res = isl_basic_set_from_params(copy());\n  return manage(res);\n}\n\nconstraint_list basic_set::get_constraint_list() const\n{\n  auto res = isl_basic_set_get_constraint_list(get());\n  return manage(res);\n}\n\nid basic_set::get_dim_id(isl::dim type, unsigned int pos) const\n{\n  auto res = isl_basic_set_get_dim_id(get(), static_cast<enum isl_dim_type>(type), pos);\n  return manage(res);\n}\n\nstd::string basic_set::get_dim_name(isl::dim type, unsigned int pos) const\n{\n  auto res = isl_basic_set_get_dim_name(get(), static_cast<enum isl_dim_type>(type), pos);\n  std::string tmp(res);\n  return tmp;\n}\n\naff basic_set::get_div(int pos) const\n{\n  auto res = isl_basic_set_get_div(get(), pos);\n  return manage(res);\n}\n\nlocal_space basic_set::get_local_space() const\n{\n  auto res = isl_basic_set_get_local_space(get());\n  return manage(res);\n}\n\nspace basic_set::get_space() const\n{\n  auto res = isl_basic_set_get_space(get());\n  return manage(res);\n}\n\nstd::string basic_set::get_tuple_name() const\n{\n  auto res = isl_basic_set_get_tuple_name(get());\n  std::string tmp(res);\n  return tmp;\n}\n\nbasic_set basic_set::gist(basic_set context) const\n{\n  auto res = isl_basic_set_gist(copy(), context.release());\n  return manage(res);\n}\n\nmat basic_set::inequalities_matrix(isl::dim c1, isl::dim c2, isl::dim c3, isl::dim c4) const\n{\n  auto res = isl_basic_set_inequalities_matrix(get(), static_cast<enum isl_dim_type>(c1), static_cast<enum isl_dim_type>(c2), static_cast<enum isl_dim_type>(c3), static_cast<enum isl_dim_type>(c4));\n  return manage(res);\n}\n\nbasic_set basic_set::insert_dims(isl::dim type, unsigned int pos, unsigned int n) const\n{\n  auto res = isl_basic_set_insert_dims(copy(), static_cast<enum isl_dim_type>(type), pos, n);\n  return manage(res);\n}\n\nbasic_set basic_set::intersect(basic_set bset2) const\n{\n  auto res = isl_basic_set_intersect(copy(), bset2.release());\n  return manage(res);\n}\n\nbasic_set basic_set::intersect_params(basic_set bset2) const\n{\n  auto res = isl_basic_set_intersect_params(copy(), bset2.release());\n  return manage(res);\n}\n\nboolean basic_set::involves_dims(isl::dim type, unsigned int first, unsigned int n) const\n{\n  auto res = isl_basic_set_involves_dims(get(), static_cast<enum isl_dim_type>(type), first, n);\n  return manage(res);\n}\n\nboolean basic_set::is_bounded() const\n{\n  auto res = isl_basic_set_is_bounded(get());\n  return manage(res);\n}\n\nboolean basic_set::is_disjoint(const basic_set &bset2) const\n{\n  auto res = isl_basic_set_is_disjoint(get(), bset2.get());\n  return manage(res);\n}\n\nboolean basic_set::is_empty() const\n{\n  auto res = isl_basic_set_is_empty(get());\n  return manage(res);\n}\n\nboolean basic_set::is_equal(const basic_set &bset2) const\n{\n  auto res = isl_basic_set_is_equal(get(), bset2.get());\n  return manage(res);\n}\n\nint basic_set::is_rational() const\n{\n  auto res = isl_basic_set_is_rational(get());\n  return res;\n}\n\nboolean basic_set::is_subset(const basic_set &bset2) const\n{\n  auto res = isl_basic_set_is_subset(get(), bset2.get());\n  return manage(res);\n}\n\nboolean basic_set::is_universe() const\n{\n  auto res = isl_basic_set_is_universe(get());\n  return manage(res);\n}\n\nboolean basic_set::is_wrapping() const\n{\n  auto res = isl_basic_set_is_wrapping(get());\n  return manage(res);\n}\n\nset basic_set::lexmax() const\n{\n  auto res = isl_basic_set_lexmax(copy());\n  return manage(res);\n}\n\nset basic_set::lexmin() const\n{\n  auto res = isl_basic_set_lexmin(copy());\n  return manage(res);\n}\n\nbasic_set basic_set::lower_bound_val(isl::dim type, unsigned int pos, val value) const\n{\n  auto res = isl_basic_set_lower_bound_val(copy(), static_cast<enum isl_dim_type>(type), pos, value.release());\n  return manage(res);\n}\n\nval basic_set::max_val(const aff &obj) const\n{\n  auto res = isl_basic_set_max_val(get(), obj.get());\n  return manage(res);\n}\n\nbasic_set basic_set::move_dims(isl::dim dst_type, unsigned int dst_pos, isl::dim src_type, unsigned int src_pos, unsigned int n) const\n{\n  auto res = isl_basic_set_move_dims(copy(), static_cast<enum isl_dim_type>(dst_type), dst_pos, static_cast<enum isl_dim_type>(src_type), src_pos, n);\n  return manage(res);\n}\n\nisl_size basic_set::n_constraint() const\n{\n  auto res = isl_basic_set_n_constraint(get());\n  return res;\n}\n\nisl_size basic_set::n_dim() const\n{\n  auto res = isl_basic_set_n_dim(get());\n  return res;\n}\n\nbasic_set basic_set::nat_universe(space space)\n{\n  auto res = isl_basic_set_nat_universe(space.release());\n  return manage(res);\n}\n\nbasic_set basic_set::neg() const\n{\n  auto res = isl_basic_set_neg(copy());\n  return manage(res);\n}\n\nbasic_set basic_set::params() const\n{\n  auto res = isl_basic_set_params(copy());\n  return manage(res);\n}\n\nboolean basic_set::plain_is_empty() const\n{\n  auto res = isl_basic_set_plain_is_empty(get());\n  return manage(res);\n}\n\nboolean basic_set::plain_is_equal(const basic_set &bset2) const\n{\n  auto res = isl_basic_set_plain_is_equal(get(), bset2.get());\n  return manage(res);\n}\n\nboolean basic_set::plain_is_universe() const\n{\n  auto res = isl_basic_set_plain_is_universe(get());\n  return manage(res);\n}\n\nbasic_set basic_set::positive_orthant(space space)\n{\n  auto res = isl_basic_set_positive_orthant(space.release());\n  return manage(res);\n}\n\nbasic_set basic_set::preimage_multi_aff(multi_aff ma) const\n{\n  auto res = isl_basic_set_preimage_multi_aff(copy(), ma.release());\n  return manage(res);\n}\n\nbasic_set basic_set::project_out(isl::dim type, unsigned int first, unsigned int n) const\n{\n  auto res = isl_basic_set_project_out(copy(), static_cast<enum isl_dim_type>(type), first, n);\n  return manage(res);\n}\n\nmat basic_set::reduced_basis() const\n{\n  auto res = isl_basic_set_reduced_basis(get());\n  return manage(res);\n}\n\nbasic_set basic_set::remove_dims(isl::dim type, unsigned int first, unsigned int n) const\n{\n  auto res = isl_basic_set_remove_dims(copy(), static_cast<enum isl_dim_type>(type), first, n);\n  return manage(res);\n}\n\nbasic_set basic_set::remove_divs() const\n{\n  auto res = isl_basic_set_remove_divs(copy());\n  return manage(res);\n}\n\nbasic_set basic_set::remove_divs_involving_dims(isl::dim type, unsigned int first, unsigned int n) const\n{\n  auto res = isl_basic_set_remove_divs_involving_dims(copy(), static_cast<enum isl_dim_type>(type), first, n);\n  return manage(res);\n}\n\nbasic_set basic_set::remove_redundancies() const\n{\n  auto res = isl_basic_set_remove_redundancies(copy());\n  return manage(res);\n}\n\nbasic_set basic_set::remove_unknown_divs() const\n{\n  auto res = isl_basic_set_remove_unknown_divs(copy());\n  return manage(res);\n}\n\nbasic_set basic_set::sample() const\n{\n  auto res = isl_basic_set_sample(copy());\n  return manage(res);\n}\n\npoint basic_set::sample_point() const\n{\n  auto res = isl_basic_set_sample_point(copy());\n  return manage(res);\n}\n\nbasic_set basic_set::set_tuple_id(id id) const\n{\n  auto res = isl_basic_set_set_tuple_id(copy(), id.release());\n  return manage(res);\n}\n\nbasic_set basic_set::set_tuple_name(const std::string &s) const\n{\n  auto res = isl_basic_set_set_tuple_name(copy(), s.c_str());\n  return manage(res);\n}\n\nbasic_set basic_set::solutions() const\n{\n  auto res = isl_basic_set_solutions(copy());\n  return manage(res);\n}\n\nset basic_set::unite(basic_set bset2) const\n{\n  auto res = isl_basic_set_union(copy(), bset2.release());\n  return manage(res);\n}\n\nbasic_set basic_set::universe(space space)\n{\n  auto res = isl_basic_set_universe(space.release());\n  return manage(res);\n}\n\nbasic_map basic_set::unwrap() const\n{\n  auto res = isl_basic_set_unwrap(copy());\n  return manage(res);\n}\n\nbasic_set basic_set::upper_bound_val(isl::dim type, unsigned int pos, val value) const\n{\n  auto res = isl_basic_set_upper_bound_val(copy(), static_cast<enum isl_dim_type>(type), pos, value.release());\n  return manage(res);\n}\n\n// implementations for isl::basic_set_list\nbasic_set_list manage(__isl_take isl_basic_set_list *ptr) {\n  return basic_set_list(ptr);\n}\nbasic_set_list manage_copy(__isl_keep isl_basic_set_list *ptr) {\n  ptr = isl_basic_set_list_copy(ptr);\n  return basic_set_list(ptr);\n}\n\nbasic_set_list::basic_set_list()\n    : ptr(nullptr) {}\n\nbasic_set_list::basic_set_list(const basic_set_list &obj)\n    : ptr(nullptr)\n{\n  ptr = obj.copy();\n}\nbasic_set_list::basic_set_list(std::nullptr_t)\n    : ptr(nullptr) {}\n\n\nbasic_set_list::basic_set_list(__isl_take isl_basic_set_list *ptr)\n    : ptr(ptr) {}\n\n\nbasic_set_list &basic_set_list::operator=(basic_set_list obj) {\n  std::swap(this->ptr, obj.ptr);\n  return *this;\n}\n\nbasic_set_list::~basic_set_list() {\n  if (ptr)\n    isl_basic_set_list_free(ptr);\n}\n\n__isl_give isl_basic_set_list *basic_set_list::copy() const & {\n  return isl_basic_set_list_copy(ptr);\n}\n\n__isl_keep isl_basic_set_list *basic_set_list::get() const {\n  return ptr;\n}\n\n__isl_give isl_basic_set_list *basic_set_list::release() {\n  isl_basic_set_list *tmp = ptr;\n  ptr = nullptr;\n  return tmp;\n}\n\nbool basic_set_list::is_null() const {\n  return ptr == nullptr;\n}\nbasic_set_list::operator bool() const {\n  return !is_null();\n}\n\n\nctx basic_set_list::get_ctx() const {\n  return ctx(isl_basic_set_list_get_ctx(ptr));\n}\nstd::string basic_set_list::to_str() const {\n  char *Tmp = isl_basic_set_list_to_str(get());\n  if (!Tmp)\n    return \"\";\n  std::string S(Tmp);\n  free(Tmp);\n  return S;\n}\n\n\nvoid basic_set_list::dump() const {\n  isl_basic_set_list_dump(get());\n}\n\n\nbasic_set_list basic_set_list::add(basic_set el) const\n{\n  auto res = isl_basic_set_list_add(copy(), el.release());\n  return manage(res);\n}\n\nbasic_set_list basic_set_list::alloc(ctx ctx, int n)\n{\n  auto res = isl_basic_set_list_alloc(ctx.release(), n);\n  return manage(res);\n}\n\nbasic_set_list basic_set_list::clear() const\n{\n  auto res = isl_basic_set_list_clear(copy());\n  return manage(res);\n}\n\nbasic_set_list basic_set_list::coefficients() const\n{\n  auto res = isl_basic_set_list_coefficients(copy());\n  return manage(res);\n}\n\nbasic_set_list basic_set_list::concat(basic_set_list list2) const\n{\n  auto res = isl_basic_set_list_concat(copy(), list2.release());\n  return manage(res);\n}\n\nbasic_set_list basic_set_list::drop(unsigned int first, unsigned int n) const\n{\n  auto res = isl_basic_set_list_drop(copy(), first, n);\n  return manage(res);\n}\n\nstat basic_set_list::foreach(const std::function<stat(basic_set)> &fn) const\n{\n  struct fn_data {\n    const std::function<stat(basic_set)> *func;\n  } fn_data = { &fn };\n  auto fn_lambda = [](isl_basic_set *arg_0, void *arg_1) -> isl_stat {\n    auto *data = static_cast<struct fn_data *>(arg_1);\n    stat ret = (*data->func)(manage(arg_0));\n    return ret.release();\n  };\n  auto res = isl_basic_set_list_foreach(get(), fn_lambda, &fn_data);\n  return manage(res);\n}\n\nbasic_set_list basic_set_list::from_basic_set(basic_set el)\n{\n  auto res = isl_basic_set_list_from_basic_set(el.release());\n  return manage(res);\n}\n\nbasic_set basic_set_list::get_at(int index) const\n{\n  auto res = isl_basic_set_list_get_at(get(), index);\n  return manage(res);\n}\n\nbasic_set basic_set_list::get_basic_set(int index) const\n{\n  auto res = isl_basic_set_list_get_basic_set(get(), index);\n  return manage(res);\n}\n\nbasic_set_list basic_set_list::insert(unsigned int pos, basic_set el) const\n{\n  auto res = isl_basic_set_list_insert(copy(), pos, el.release());\n  return manage(res);\n}\n\nisl_size basic_set_list::n_basic_set() const\n{\n  auto res = isl_basic_set_list_n_basic_set(get());\n  return res;\n}\n\nbasic_set_list basic_set_list::reverse() const\n{\n  auto res = isl_basic_set_list_reverse(copy());\n  return manage(res);\n}\n\nbasic_set_list basic_set_list::set_basic_set(int index, basic_set el) const\n{\n  auto res = isl_basic_set_list_set_basic_set(copy(), index, el.release());\n  return manage(res);\n}\n\nisl_size basic_set_list::size() const\n{\n  auto res = isl_basic_set_list_size(get());\n  return res;\n}\n\nbasic_set_list basic_set_list::swap(unsigned int pos1, unsigned int pos2) const\n{\n  auto res = isl_basic_set_list_swap(copy(), pos1, pos2);\n  return manage(res);\n}\n\n// implementations for isl::constraint\nconstraint manage(__isl_take isl_constraint *ptr) {\n  return constraint(ptr);\n}\nconstraint manage_copy(__isl_keep isl_constraint *ptr) {\n  ptr = isl_constraint_copy(ptr);\n  return constraint(ptr);\n}\n\nconstraint::constraint()\n    : ptr(nullptr) {}\n\nconstraint::constraint(const constraint &obj)\n    : ptr(nullptr)\n{\n  ptr = obj.copy();\n}\nconstraint::constraint(std::nullptr_t)\n    : ptr(nullptr) {}\n\n\nconstraint::constraint(__isl_take isl_constraint *ptr)\n    : ptr(ptr) {}\n\n\nconstraint &constraint::operator=(constraint obj) {\n  std::swap(this->ptr, obj.ptr);\n  return *this;\n}\n\nconstraint::~constraint() {\n  if (ptr)\n    isl_constraint_free(ptr);\n}\n\n__isl_give isl_constraint *constraint::copy() const & {\n  return isl_constraint_copy(ptr);\n}\n\n__isl_keep isl_constraint *constraint::get() const {\n  return ptr;\n}\n\n__isl_give isl_constraint *constraint::release() {\n  isl_constraint *tmp = ptr;\n  ptr = nullptr;\n  return tmp;\n}\n\nbool constraint::is_null() const {\n  return ptr == nullptr;\n}\nconstraint::operator bool() const {\n  return !is_null();\n}\n\n\nctx constraint::get_ctx() const {\n  return ctx(isl_constraint_get_ctx(ptr));\n}\n\nvoid constraint::dump() const {\n  isl_constraint_dump(get());\n}\n\n\nconstraint constraint::alloc_equality(local_space ls)\n{\n  auto res = isl_constraint_alloc_equality(ls.release());\n  return manage(res);\n}\n\nconstraint constraint::alloc_inequality(local_space ls)\n{\n  auto res = isl_constraint_alloc_inequality(ls.release());\n  return manage(res);\n}\n\nint constraint::cmp_last_non_zero(const constraint &c2) const\n{\n  auto res = isl_constraint_cmp_last_non_zero(get(), c2.get());\n  return res;\n}\n\naff constraint::get_aff() const\n{\n  auto res = isl_constraint_get_aff(get());\n  return manage(res);\n}\n\naff constraint::get_bound(isl::dim type, int pos) const\n{\n  auto res = isl_constraint_get_bound(get(), static_cast<enum isl_dim_type>(type), pos);\n  return manage(res);\n}\n\nval constraint::get_coefficient_val(isl::dim type, int pos) const\n{\n  auto res = isl_constraint_get_coefficient_val(get(), static_cast<enum isl_dim_type>(type), pos);\n  return manage(res);\n}\n\nval constraint::get_constant_val() const\n{\n  auto res = isl_constraint_get_constant_val(get());\n  return manage(res);\n}\n\nstd::string constraint::get_dim_name(isl::dim type, unsigned int pos) const\n{\n  auto res = isl_constraint_get_dim_name(get(), static_cast<enum isl_dim_type>(type), pos);\n  std::string tmp(res);\n  return tmp;\n}\n\naff constraint::get_div(int pos) const\n{\n  auto res = isl_constraint_get_div(get(), pos);\n  return manage(res);\n}\n\nlocal_space constraint::get_local_space() const\n{\n  auto res = isl_constraint_get_local_space(get());\n  return manage(res);\n}\n\nspace constraint::get_space() const\n{\n  auto res = isl_constraint_get_space(get());\n  return manage(res);\n}\n\nboolean constraint::involves_dims(isl::dim type, unsigned int first, unsigned int n) const\n{\n  auto res = isl_constraint_involves_dims(get(), static_cast<enum isl_dim_type>(type), first, n);\n  return manage(res);\n}\n\nboolean constraint::is_div_constraint() const\n{\n  auto res = isl_constraint_is_div_constraint(get());\n  return manage(res);\n}\n\nboolean constraint::is_lower_bound(isl::dim type, unsigned int pos) const\n{\n  auto res = isl_constraint_is_lower_bound(get(), static_cast<enum isl_dim_type>(type), pos);\n  return manage(res);\n}\n\nboolean constraint::is_upper_bound(isl::dim type, unsigned int pos) const\n{\n  auto res = isl_constraint_is_upper_bound(get(), static_cast<enum isl_dim_type>(type), pos);\n  return manage(res);\n}\n\nint constraint::plain_cmp(const constraint &c2) const\n{\n  auto res = isl_constraint_plain_cmp(get(), c2.get());\n  return res;\n}\n\nconstraint constraint::set_coefficient_si(isl::dim type, int pos, int v) const\n{\n  auto res = isl_constraint_set_coefficient_si(copy(), static_cast<enum isl_dim_type>(type), pos, v);\n  return manage(res);\n}\n\nconstraint constraint::set_coefficient_val(isl::dim type, int pos, val v) const\n{\n  auto res = isl_constraint_set_coefficient_val(copy(), static_cast<enum isl_dim_type>(type), pos, v.release());\n  return manage(res);\n}\n\nconstraint constraint::set_constant_si(int v) const\n{\n  auto res = isl_constraint_set_constant_si(copy(), v);\n  return manage(res);\n}\n\nconstraint constraint::set_constant_val(val v) const\n{\n  auto res = isl_constraint_set_constant_val(copy(), v.release());\n  return manage(res);\n}\n\n// implementations for isl::constraint_list\nconstraint_list manage(__isl_take isl_constraint_list *ptr) {\n  return constraint_list(ptr);\n}\nconstraint_list manage_copy(__isl_keep isl_constraint_list *ptr) {\n  ptr = isl_constraint_list_copy(ptr);\n  return constraint_list(ptr);\n}\n\nconstraint_list::constraint_list()\n    : ptr(nullptr) {}\n\nconstraint_list::constraint_list(const constraint_list &obj)\n    : ptr(nullptr)\n{\n  ptr = obj.copy();\n}\nconstraint_list::constraint_list(std::nullptr_t)\n    : ptr(nullptr) {}\n\n\nconstraint_list::constraint_list(__isl_take isl_constraint_list *ptr)\n    : ptr(ptr) {}\n\n\nconstraint_list &constraint_list::operator=(constraint_list obj) {\n  std::swap(this->ptr, obj.ptr);\n  return *this;\n}\n\nconstraint_list::~constraint_list() {\n  if (ptr)\n    isl_constraint_list_free(ptr);\n}\n\n__isl_give isl_constraint_list *constraint_list::copy() const & {\n  return isl_constraint_list_copy(ptr);\n}\n\n__isl_keep isl_constraint_list *constraint_list::get() const {\n  return ptr;\n}\n\n__isl_give isl_constraint_list *constraint_list::release() {\n  isl_constraint_list *tmp = ptr;\n  ptr = nullptr;\n  return tmp;\n}\n\nbool constraint_list::is_null() const {\n  return ptr == nullptr;\n}\nconstraint_list::operator bool() const {\n  return !is_null();\n}\n\n\nctx constraint_list::get_ctx() const {\n  return ctx(isl_constraint_list_get_ctx(ptr));\n}\nstd::string constraint_list::to_str() const {\n  char *Tmp = isl_constraint_list_to_str(get());\n  if (!Tmp)\n    return \"\";\n  std::string S(Tmp);\n  free(Tmp);\n  return S;\n}\n\n\nvoid constraint_list::dump() const {\n  isl_constraint_list_dump(get());\n}\n\n\nconstraint_list constraint_list::add(constraint el) const\n{\n  auto res = isl_constraint_list_add(copy(), el.release());\n  return manage(res);\n}\n\nconstraint_list constraint_list::alloc(ctx ctx, int n)\n{\n  auto res = isl_constraint_list_alloc(ctx.release(), n);\n  return manage(res);\n}\n\nconstraint_list constraint_list::clear() const\n{\n  auto res = isl_constraint_list_clear(copy());\n  return manage(res);\n}\n\nconstraint_list constraint_list::concat(constraint_list list2) const\n{\n  auto res = isl_constraint_list_concat(copy(), list2.release());\n  return manage(res);\n}\n\nconstraint_list constraint_list::drop(unsigned int first, unsigned int n) const\n{\n  auto res = isl_constraint_list_drop(copy(), first, n);\n  return manage(res);\n}\n\nstat constraint_list::foreach(const std::function<stat(constraint)> &fn) const\n{\n  struct fn_data {\n    const std::function<stat(constraint)> *func;\n  } fn_data = { &fn };\n  auto fn_lambda = [](isl_constraint *arg_0, void *arg_1) -> isl_stat {\n    auto *data = static_cast<struct fn_data *>(arg_1);\n    stat ret = (*data->func)(manage(arg_0));\n    return ret.release();\n  };\n  auto res = isl_constraint_list_foreach(get(), fn_lambda, &fn_data);\n  return manage(res);\n}\n\nconstraint_list constraint_list::from_constraint(constraint el)\n{\n  auto res = isl_constraint_list_from_constraint(el.release());\n  return manage(res);\n}\n\nconstraint constraint_list::get_at(int index) const\n{\n  auto res = isl_constraint_list_get_at(get(), index);\n  return manage(res);\n}\n\nconstraint constraint_list::get_constraint(int index) const\n{\n  auto res = isl_constraint_list_get_constraint(get(), index);\n  return manage(res);\n}\n\nconstraint_list constraint_list::insert(unsigned int pos, constraint el) const\n{\n  auto res = isl_constraint_list_insert(copy(), pos, el.release());\n  return manage(res);\n}\n\nisl_size constraint_list::n_constraint() const\n{\n  auto res = isl_constraint_list_n_constraint(get());\n  return res;\n}\n\nconstraint_list constraint_list::reverse() const\n{\n  auto res = isl_constraint_list_reverse(copy());\n  return manage(res);\n}\n\nconstraint_list constraint_list::set_constraint(int index, constraint el) const\n{\n  auto res = isl_constraint_list_set_constraint(copy(), index, el.release());\n  return manage(res);\n}\n\nisl_size constraint_list::size() const\n{\n  auto res = isl_constraint_list_size(get());\n  return res;\n}\n\nconstraint_list constraint_list::swap(unsigned int pos1, unsigned int pos2) const\n{\n  auto res = isl_constraint_list_swap(copy(), pos1, pos2);\n  return manage(res);\n}\n\n// implementations for isl::fixed_box\nfixed_box manage(__isl_take isl_fixed_box *ptr) {\n  return fixed_box(ptr);\n}\nfixed_box manage_copy(__isl_keep isl_fixed_box *ptr) {\n  ptr = isl_fixed_box_copy(ptr);\n  return fixed_box(ptr);\n}\n\nfixed_box::fixed_box()\n    : ptr(nullptr) {}\n\nfixed_box::fixed_box(const fixed_box &obj)\n    : ptr(nullptr)\n{\n  ptr = obj.copy();\n}\nfixed_box::fixed_box(std::nullptr_t)\n    : ptr(nullptr) {}\n\n\nfixed_box::fixed_box(__isl_take isl_fixed_box *ptr)\n    : ptr(ptr) {}\n\n\nfixed_box &fixed_box::operator=(fixed_box obj) {\n  std::swap(this->ptr, obj.ptr);\n  return *this;\n}\n\nfixed_box::~fixed_box() {\n  if (ptr)\n    isl_fixed_box_free(ptr);\n}\n\n__isl_give isl_fixed_box *fixed_box::copy() const & {\n  return isl_fixed_box_copy(ptr);\n}\n\n__isl_keep isl_fixed_box *fixed_box::get() const {\n  return ptr;\n}\n\n__isl_give isl_fixed_box *fixed_box::release() {\n  isl_fixed_box *tmp = ptr;\n  ptr = nullptr;\n  return tmp;\n}\n\nbool fixed_box::is_null() const {\n  return ptr == nullptr;\n}\nfixed_box::operator bool() const {\n  return !is_null();\n}\n\n\nctx fixed_box::get_ctx() const {\n  return ctx(isl_fixed_box_get_ctx(ptr));\n}\nstd::string fixed_box::to_str() const {\n  char *Tmp = isl_fixed_box_to_str(get());\n  if (!Tmp)\n    return \"\";\n  std::string S(Tmp);\n  free(Tmp);\n  return S;\n}\n\n\nvoid fixed_box::dump() const {\n  isl_fixed_box_dump(get());\n}\n\n\nmulti_aff fixed_box::get_offset() const\n{\n  auto res = isl_fixed_box_get_offset(get());\n  return manage(res);\n}\n\nmulti_val fixed_box::get_size() const\n{\n  auto res = isl_fixed_box_get_size(get());\n  return manage(res);\n}\n\nspace fixed_box::get_space() const\n{\n  auto res = isl_fixed_box_get_space(get());\n  return manage(res);\n}\n\nboolean fixed_box::is_valid() const\n{\n  auto res = isl_fixed_box_is_valid(get());\n  return manage(res);\n}\n\n// implementations for isl::id\nid manage(__isl_take isl_id *ptr) {\n  return id(ptr);\n}\nid manage_copy(__isl_keep isl_id *ptr) {\n  ptr = isl_id_copy(ptr);\n  return id(ptr);\n}\n\nid::id()\n    : ptr(nullptr) {}\n\nid::id(const id &obj)\n    : ptr(nullptr)\n{\n  ptr = obj.copy();\n}\nid::id(std::nullptr_t)\n    : ptr(nullptr) {}\n\n\nid::id(__isl_take isl_id *ptr)\n    : ptr(ptr) {}\n\nid::id(ctx ctx, const std::string &str)\n{\n  auto res = isl_id_read_from_str(ctx.release(), str.c_str());\n  ptr = res;\n}\n\nid &id::operator=(id obj) {\n  std::swap(this->ptr, obj.ptr);\n  return *this;\n}\n\nid::~id() {\n  if (ptr)\n    isl_id_free(ptr);\n}\n\n__isl_give isl_id *id::copy() const & {\n  return isl_id_copy(ptr);\n}\n\n__isl_keep isl_id *id::get() const {\n  return ptr;\n}\n\n__isl_give isl_id *id::release() {\n  isl_id *tmp = ptr;\n  ptr = nullptr;\n  return tmp;\n}\n\nbool id::is_null() const {\n  return ptr == nullptr;\n}\nid::operator bool() const {\n  return !is_null();\n}\n\n\nctx id::get_ctx() const {\n  return ctx(isl_id_get_ctx(ptr));\n}\nstd::string id::to_str() const {\n  char *Tmp = isl_id_to_str(get());\n  if (!Tmp)\n    return \"\";\n  std::string S(Tmp);\n  free(Tmp);\n  return S;\n}\n\n\nvoid id::dump() const {\n  isl_id_dump(get());\n}\n\n\nid id::alloc(ctx ctx, const std::string &name, void * user)\n{\n  auto res = isl_id_alloc(ctx.release(), name.c_str(), user);\n  return manage(res);\n}\n\nuint32_t id::get_hash() const\n{\n  auto res = isl_id_get_hash(get());\n  return res;\n}\n\nstd::string id::get_name() const\n{\n  auto res = isl_id_get_name(get());\n  std::string tmp(res);\n  return tmp;\n}\n\nvoid * id::get_user() const\n{\n  auto res = isl_id_get_user(get());\n  return res;\n}\n\n// implementations for isl::id_list\nid_list manage(__isl_take isl_id_list *ptr) {\n  return id_list(ptr);\n}\nid_list manage_copy(__isl_keep isl_id_list *ptr) {\n  ptr = isl_id_list_copy(ptr);\n  return id_list(ptr);\n}\n\nid_list::id_list()\n    : ptr(nullptr) {}\n\nid_list::id_list(const id_list &obj)\n    : ptr(nullptr)\n{\n  ptr = obj.copy();\n}\nid_list::id_list(std::nullptr_t)\n    : ptr(nullptr) {}\n\n\nid_list::id_list(__isl_take isl_id_list *ptr)\n    : ptr(ptr) {}\n\n\nid_list &id_list::operator=(id_list obj) {\n  std::swap(this->ptr, obj.ptr);\n  return *this;\n}\n\nid_list::~id_list() {\n  if (ptr)\n    isl_id_list_free(ptr);\n}\n\n__isl_give isl_id_list *id_list::copy() const & {\n  return isl_id_list_copy(ptr);\n}\n\n__isl_keep isl_id_list *id_list::get() const {\n  return ptr;\n}\n\n__isl_give isl_id_list *id_list::release() {\n  isl_id_list *tmp = ptr;\n  ptr = nullptr;\n  return tmp;\n}\n\nbool id_list::is_null() const {\n  return ptr == nullptr;\n}\nid_list::operator bool() const {\n  return !is_null();\n}\n\n\nctx id_list::get_ctx() const {\n  return ctx(isl_id_list_get_ctx(ptr));\n}\nstd::string id_list::to_str() const {\n  char *Tmp = isl_id_list_to_str(get());\n  if (!Tmp)\n    return \"\";\n  std::string S(Tmp);\n  free(Tmp);\n  return S;\n}\n\n\nvoid id_list::dump() const {\n  isl_id_list_dump(get());\n}\n\n\nid_list id_list::add(id el) const\n{\n  auto res = isl_id_list_add(copy(), el.release());\n  return manage(res);\n}\n\nid_list id_list::alloc(ctx ctx, int n)\n{\n  auto res = isl_id_list_alloc(ctx.release(), n);\n  return manage(res);\n}\n\nid_list id_list::clear() const\n{\n  auto res = isl_id_list_clear(copy());\n  return manage(res);\n}\n\nid_list id_list::concat(id_list list2) const\n{\n  auto res = isl_id_list_concat(copy(), list2.release());\n  return manage(res);\n}\n\nid_list id_list::drop(unsigned int first, unsigned int n) const\n{\n  auto res = isl_id_list_drop(copy(), first, n);\n  return manage(res);\n}\n\nstat id_list::foreach(const std::function<stat(id)> &fn) const\n{\n  struct fn_data {\n    const std::function<stat(id)> *func;\n  } fn_data = { &fn };\n  auto fn_lambda = [](isl_id *arg_0, void *arg_1) -> isl_stat {\n    auto *data = static_cast<struct fn_data *>(arg_1);\n    stat ret = (*data->func)(manage(arg_0));\n    return ret.release();\n  };\n  auto res = isl_id_list_foreach(get(), fn_lambda, &fn_data);\n  return manage(res);\n}\n\nid_list id_list::from_id(id el)\n{\n  auto res = isl_id_list_from_id(el.release());\n  return manage(res);\n}\n\nid id_list::get_at(int index) const\n{\n  auto res = isl_id_list_get_at(get(), index);\n  return manage(res);\n}\n\nid id_list::get_id(int index) const\n{\n  auto res = isl_id_list_get_id(get(), index);\n  return manage(res);\n}\n\nid_list id_list::insert(unsigned int pos, id el) const\n{\n  auto res = isl_id_list_insert(copy(), pos, el.release());\n  return manage(res);\n}\n\nisl_size id_list::n_id() const\n{\n  auto res = isl_id_list_n_id(get());\n  return res;\n}\n\nid_list id_list::reverse() const\n{\n  auto res = isl_id_list_reverse(copy());\n  return manage(res);\n}\n\nid_list id_list::set_id(int index, id el) const\n{\n  auto res = isl_id_list_set_id(copy(), index, el.release());\n  return manage(res);\n}\n\nisl_size id_list::size() const\n{\n  auto res = isl_id_list_size(get());\n  return res;\n}\n\nid_list id_list::swap(unsigned int pos1, unsigned int pos2) const\n{\n  auto res = isl_id_list_swap(copy(), pos1, pos2);\n  return manage(res);\n}\n\n// implementations for isl::id_to_ast_expr\nid_to_ast_expr manage(__isl_take isl_id_to_ast_expr *ptr) {\n  return id_to_ast_expr(ptr);\n}\nid_to_ast_expr manage_copy(__isl_keep isl_id_to_ast_expr *ptr) {\n  ptr = isl_id_to_ast_expr_copy(ptr);\n  return id_to_ast_expr(ptr);\n}\n\nid_to_ast_expr::id_to_ast_expr()\n    : ptr(nullptr) {}\n\nid_to_ast_expr::id_to_ast_expr(const id_to_ast_expr &obj)\n    : ptr(nullptr)\n{\n  ptr = obj.copy();\n}\nid_to_ast_expr::id_to_ast_expr(std::nullptr_t)\n    : ptr(nullptr) {}\n\n\nid_to_ast_expr::id_to_ast_expr(__isl_take isl_id_to_ast_expr *ptr)\n    : ptr(ptr) {}\n\n\nid_to_ast_expr &id_to_ast_expr::operator=(id_to_ast_expr obj) {\n  std::swap(this->ptr, obj.ptr);\n  return *this;\n}\n\nid_to_ast_expr::~id_to_ast_expr() {\n  if (ptr)\n    isl_id_to_ast_expr_free(ptr);\n}\n\n__isl_give isl_id_to_ast_expr *id_to_ast_expr::copy() const & {\n  return isl_id_to_ast_expr_copy(ptr);\n}\n\n__isl_keep isl_id_to_ast_expr *id_to_ast_expr::get() const {\n  return ptr;\n}\n\n__isl_give isl_id_to_ast_expr *id_to_ast_expr::release() {\n  isl_id_to_ast_expr *tmp = ptr;\n  ptr = nullptr;\n  return tmp;\n}\n\nbool id_to_ast_expr::is_null() const {\n  return ptr == nullptr;\n}\nid_to_ast_expr::operator bool() const {\n  return !is_null();\n}\n\n\nctx id_to_ast_expr::get_ctx() const {\n  return ctx(isl_id_to_ast_expr_get_ctx(ptr));\n}\n\nvoid id_to_ast_expr::dump() const {\n  isl_id_to_ast_expr_dump(get());\n}\n\n\nid_to_ast_expr id_to_ast_expr::alloc(ctx ctx, int min_size)\n{\n  auto res = isl_id_to_ast_expr_alloc(ctx.release(), min_size);\n  return manage(res);\n}\n\nid_to_ast_expr id_to_ast_expr::drop(id key) const\n{\n  auto res = isl_id_to_ast_expr_drop(copy(), key.release());\n  return manage(res);\n}\n\nstat id_to_ast_expr::foreach(const std::function<stat(id, ast_expr)> &fn) const\n{\n  struct fn_data {\n    const std::function<stat(id, ast_expr)> *func;\n  } fn_data = { &fn };\n  auto fn_lambda = [](isl_id *arg_0, isl_ast_expr *arg_1, void *arg_2) -> isl_stat {\n    auto *data = static_cast<struct fn_data *>(arg_2);\n    stat ret = (*data->func)(manage(arg_0), manage(arg_1));\n    return ret.release();\n  };\n  auto res = isl_id_to_ast_expr_foreach(get(), fn_lambda, &fn_data);\n  return manage(res);\n}\n\nast_expr id_to_ast_expr::get(id key) const\n{\n  auto res = isl_id_to_ast_expr_get(get(), key.release());\n  return manage(res);\n}\n\nboolean id_to_ast_expr::has(const id &key) const\n{\n  auto res = isl_id_to_ast_expr_has(get(), key.get());\n  return manage(res);\n}\n\nid_to_ast_expr id_to_ast_expr::set(id key, ast_expr val) const\n{\n  auto res = isl_id_to_ast_expr_set(copy(), key.release(), val.release());\n  return manage(res);\n}\n\n// implementations for isl::local_space\nlocal_space manage(__isl_take isl_local_space *ptr) {\n  return local_space(ptr);\n}\nlocal_space manage_copy(__isl_keep isl_local_space *ptr) {\n  ptr = isl_local_space_copy(ptr);\n  return local_space(ptr);\n}\n\nlocal_space::local_space()\n    : ptr(nullptr) {}\n\nlocal_space::local_space(const local_space &obj)\n    : ptr(nullptr)\n{\n  ptr = obj.copy();\n}\nlocal_space::local_space(std::nullptr_t)\n    : ptr(nullptr) {}\n\n\nlocal_space::local_space(__isl_take isl_local_space *ptr)\n    : ptr(ptr) {}\n\nlocal_space::local_space(space space)\n{\n  auto res = isl_local_space_from_space(space.release());\n  ptr = res;\n}\n\nlocal_space &local_space::operator=(local_space obj) {\n  std::swap(this->ptr, obj.ptr);\n  return *this;\n}\n\nlocal_space::~local_space() {\n  if (ptr)\n    isl_local_space_free(ptr);\n}\n\n__isl_give isl_local_space *local_space::copy() const & {\n  return isl_local_space_copy(ptr);\n}\n\n__isl_keep isl_local_space *local_space::get() const {\n  return ptr;\n}\n\n__isl_give isl_local_space *local_space::release() {\n  isl_local_space *tmp = ptr;\n  ptr = nullptr;\n  return tmp;\n}\n\nbool local_space::is_null() const {\n  return ptr == nullptr;\n}\nlocal_space::operator bool() const {\n  return !is_null();\n}\n\n\nctx local_space::get_ctx() const {\n  return ctx(isl_local_space_get_ctx(ptr));\n}\n\nvoid local_space::dump() const {\n  isl_local_space_dump(get());\n}\n\n\nlocal_space local_space::add_dims(isl::dim type, unsigned int n) const\n{\n  auto res = isl_local_space_add_dims(copy(), static_cast<enum isl_dim_type>(type), n);\n  return manage(res);\n}\n\nisl_size local_space::dim(isl::dim type) const\n{\n  auto res = isl_local_space_dim(get(), static_cast<enum isl_dim_type>(type));\n  return res;\n}\n\nlocal_space local_space::domain() const\n{\n  auto res = isl_local_space_domain(copy());\n  return manage(res);\n}\n\nlocal_space local_space::drop_dims(isl::dim type, unsigned int first, unsigned int n) const\n{\n  auto res = isl_local_space_drop_dims(copy(), static_cast<enum isl_dim_type>(type), first, n);\n  return manage(res);\n}\n\nint local_space::find_dim_by_name(isl::dim type, const std::string &name) const\n{\n  auto res = isl_local_space_find_dim_by_name(get(), static_cast<enum isl_dim_type>(type), name.c_str());\n  return res;\n}\n\nlocal_space local_space::flatten_domain() const\n{\n  auto res = isl_local_space_flatten_domain(copy());\n  return manage(res);\n}\n\nlocal_space local_space::flatten_range() const\n{\n  auto res = isl_local_space_flatten_range(copy());\n  return manage(res);\n}\n\nlocal_space local_space::from_domain() const\n{\n  auto res = isl_local_space_from_domain(copy());\n  return manage(res);\n}\n\nid local_space::get_dim_id(isl::dim type, unsigned int pos) const\n{\n  auto res = isl_local_space_get_dim_id(get(), static_cast<enum isl_dim_type>(type), pos);\n  return manage(res);\n}\n\nstd::string local_space::get_dim_name(isl::dim type, unsigned int pos) const\n{\n  auto res = isl_local_space_get_dim_name(get(), static_cast<enum isl_dim_type>(type), pos);\n  std::string tmp(res);\n  return tmp;\n}\n\naff local_space::get_div(int pos) const\n{\n  auto res = isl_local_space_get_div(get(), pos);\n  return manage(res);\n}\n\nspace local_space::get_space() const\n{\n  auto res = isl_local_space_get_space(get());\n  return manage(res);\n}\n\nboolean local_space::has_dim_id(isl::dim type, unsigned int pos) const\n{\n  auto res = isl_local_space_has_dim_id(get(), static_cast<enum isl_dim_type>(type), pos);\n  return manage(res);\n}\n\nboolean local_space::has_dim_name(isl::dim type, unsigned int pos) const\n{\n  auto res = isl_local_space_has_dim_name(get(), static_cast<enum isl_dim_type>(type), pos);\n  return manage(res);\n}\n\nlocal_space local_space::insert_dims(isl::dim type, unsigned int first, unsigned int n) const\n{\n  auto res = isl_local_space_insert_dims(copy(), static_cast<enum isl_dim_type>(type), first, n);\n  return manage(res);\n}\n\nlocal_space local_space::intersect(local_space ls2) const\n{\n  auto res = isl_local_space_intersect(copy(), ls2.release());\n  return manage(res);\n}\n\nboolean local_space::is_equal(const local_space &ls2) const\n{\n  auto res = isl_local_space_is_equal(get(), ls2.get());\n  return manage(res);\n}\n\nboolean local_space::is_params() const\n{\n  auto res = isl_local_space_is_params(get());\n  return manage(res);\n}\n\nboolean local_space::is_set() const\n{\n  auto res = isl_local_space_is_set(get());\n  return manage(res);\n}\n\nlocal_space local_space::range() const\n{\n  auto res = isl_local_space_range(copy());\n  return manage(res);\n}\n\nlocal_space local_space::set_dim_id(isl::dim type, unsigned int pos, id id) const\n{\n  auto res = isl_local_space_set_dim_id(copy(), static_cast<enum isl_dim_type>(type), pos, id.release());\n  return manage(res);\n}\n\nlocal_space local_space::set_from_params() const\n{\n  auto res = isl_local_space_set_from_params(copy());\n  return manage(res);\n}\n\nlocal_space local_space::set_tuple_id(isl::dim type, id id) const\n{\n  auto res = isl_local_space_set_tuple_id(copy(), static_cast<enum isl_dim_type>(type), id.release());\n  return manage(res);\n}\n\nlocal_space local_space::wrap() const\n{\n  auto res = isl_local_space_wrap(copy());\n  return manage(res);\n}\n\n// implementations for isl::map\nmap manage(__isl_take isl_map *ptr) {\n  return map(ptr);\n}\nmap manage_copy(__isl_keep isl_map *ptr) {\n  ptr = isl_map_copy(ptr);\n  return map(ptr);\n}\n\nmap::map()\n    : ptr(nullptr) {}\n\nmap::map(const map &obj)\n    : ptr(nullptr)\n{\n  ptr = obj.copy();\n}\nmap::map(std::nullptr_t)\n    : ptr(nullptr) {}\n\n\nmap::map(__isl_take isl_map *ptr)\n    : ptr(ptr) {}\n\nmap::map(basic_map bmap)\n{\n  auto res = isl_map_from_basic_map(bmap.release());\n  ptr = res;\n}\nmap::map(ctx ctx, const std::string &str)\n{\n  auto res = isl_map_read_from_str(ctx.release(), str.c_str());\n  ptr = res;\n}\n\nmap &map::operator=(map obj) {\n  std::swap(this->ptr, obj.ptr);\n  return *this;\n}\n\nmap::~map() {\n  if (ptr)\n    isl_map_free(ptr);\n}\n\n__isl_give isl_map *map::copy() const & {\n  return isl_map_copy(ptr);\n}\n\n__isl_keep isl_map *map::get() const {\n  return ptr;\n}\n\n__isl_give isl_map *map::release() {\n  isl_map *tmp = ptr;\n  ptr = nullptr;\n  return tmp;\n}\n\nbool map::is_null() const {\n  return ptr == nullptr;\n}\nmap::operator bool() const {\n  return !is_null();\n}\n\n\nctx map::get_ctx() const {\n  return ctx(isl_map_get_ctx(ptr));\n}\nstd::string map::to_str() const {\n  char *Tmp = isl_map_to_str(get());\n  if (!Tmp)\n    return \"\";\n  std::string S(Tmp);\n  free(Tmp);\n  return S;\n}\n\n\nvoid map::dump() const {\n  isl_map_dump(get());\n}\n\n\nmap map::add_constraint(constraint constraint) const\n{\n  auto res = isl_map_add_constraint(copy(), constraint.release());\n  return manage(res);\n}\n\nmap map::add_dims(isl::dim type, unsigned int n) const\n{\n  auto res = isl_map_add_dims(copy(), static_cast<enum isl_dim_type>(type), n);\n  return manage(res);\n}\n\nbasic_map map::affine_hull() const\n{\n  auto res = isl_map_affine_hull(copy());\n  return manage(res);\n}\n\nmap map::align_params(space model) const\n{\n  auto res = isl_map_align_params(copy(), model.release());\n  return manage(res);\n}\n\nmap map::apply_domain(map map2) const\n{\n  auto res = isl_map_apply_domain(copy(), map2.release());\n  return manage(res);\n}\n\nmap map::apply_range(map map2) const\n{\n  auto res = isl_map_apply_range(copy(), map2.release());\n  return manage(res);\n}\n\nset map::bind_domain(multi_id tuple) const\n{\n  auto res = isl_map_bind_domain(copy(), tuple.release());\n  return manage(res);\n}\n\nset map::bind_range(multi_id tuple) const\n{\n  auto res = isl_map_bind_range(copy(), tuple.release());\n  return manage(res);\n}\n\nboolean map::can_curry() const\n{\n  auto res = isl_map_can_curry(get());\n  return manage(res);\n}\n\nboolean map::can_range_curry() const\n{\n  auto res = isl_map_can_range_curry(get());\n  return manage(res);\n}\n\nboolean map::can_uncurry() const\n{\n  auto res = isl_map_can_uncurry(get());\n  return manage(res);\n}\n\nboolean map::can_zip() const\n{\n  auto res = isl_map_can_zip(get());\n  return manage(res);\n}\n\nmap map::coalesce() const\n{\n  auto res = isl_map_coalesce(copy());\n  return manage(res);\n}\n\nmap map::complement() const\n{\n  auto res = isl_map_complement(copy());\n  return manage(res);\n}\n\nbasic_map map::convex_hull() const\n{\n  auto res = isl_map_convex_hull(copy());\n  return manage(res);\n}\n\nmap map::curry() const\n{\n  auto res = isl_map_curry(copy());\n  return manage(res);\n}\n\nset map::deltas() const\n{\n  auto res = isl_map_deltas(copy());\n  return manage(res);\n}\n\nmap map::deltas_map() const\n{\n  auto res = isl_map_deltas_map(copy());\n  return manage(res);\n}\n\nmap map::detect_equalities() const\n{\n  auto res = isl_map_detect_equalities(copy());\n  return manage(res);\n}\n\nisl_size map::dim(isl::dim type) const\n{\n  auto res = isl_map_dim(get(), static_cast<enum isl_dim_type>(type));\n  return res;\n}\n\npw_aff map::dim_max(int pos) const\n{\n  auto res = isl_map_dim_max(copy(), pos);\n  return manage(res);\n}\n\npw_aff map::dim_min(int pos) const\n{\n  auto res = isl_map_dim_min(copy(), pos);\n  return manage(res);\n}\n\nset map::domain() const\n{\n  auto res = isl_map_domain(copy());\n  return manage(res);\n}\n\nmap map::domain_factor_domain() const\n{\n  auto res = isl_map_domain_factor_domain(copy());\n  return manage(res);\n}\n\nmap map::domain_factor_range() const\n{\n  auto res = isl_map_domain_factor_range(copy());\n  return manage(res);\n}\n\nboolean map::domain_is_wrapping() const\n{\n  auto res = isl_map_domain_is_wrapping(get());\n  return manage(res);\n}\n\nmap map::domain_map() const\n{\n  auto res = isl_map_domain_map(copy());\n  return manage(res);\n}\n\nmap map::domain_product(map map2) const\n{\n  auto res = isl_map_domain_product(copy(), map2.release());\n  return manage(res);\n}\n\nmap map::drop_constraints_involving_dims(isl::dim type, unsigned int first, unsigned int n) const\n{\n  auto res = isl_map_drop_constraints_involving_dims(copy(), static_cast<enum isl_dim_type>(type), first, n);\n  return manage(res);\n}\n\nmap map::drop_constraints_not_involving_dims(isl::dim type, unsigned int first, unsigned int n) const\n{\n  auto res = isl_map_drop_constraints_not_involving_dims(copy(), static_cast<enum isl_dim_type>(type), first, n);\n  return manage(res);\n}\n\nmap map::drop_unused_params() const\n{\n  auto res = isl_map_drop_unused_params(copy());\n  return manage(res);\n}\n\nmap map::eliminate(isl::dim type, unsigned int first, unsigned int n) const\n{\n  auto res = isl_map_eliminate(copy(), static_cast<enum isl_dim_type>(type), first, n);\n  return manage(res);\n}\n\nmap map::empty(space space)\n{\n  auto res = isl_map_empty(space.release());\n  return manage(res);\n}\n\nmap map::eq_at(multi_pw_aff mpa) const\n{\n  auto res = isl_map_eq_at_multi_pw_aff(copy(), mpa.release());\n  return manage(res);\n}\n\nmap map::equate(isl::dim type1, int pos1, isl::dim type2, int pos2) const\n{\n  auto res = isl_map_equate(copy(), static_cast<enum isl_dim_type>(type1), pos1, static_cast<enum isl_dim_type>(type2), pos2);\n  return manage(res);\n}\n\nmap map::factor_domain() const\n{\n  auto res = isl_map_factor_domain(copy());\n  return manage(res);\n}\n\nmap map::factor_range() const\n{\n  auto res = isl_map_factor_range(copy());\n  return manage(res);\n}\n\nint map::find_dim_by_id(isl::dim type, const id &id) const\n{\n  auto res = isl_map_find_dim_by_id(get(), static_cast<enum isl_dim_type>(type), id.get());\n  return res;\n}\n\nint map::find_dim_by_name(isl::dim type, const std::string &name) const\n{\n  auto res = isl_map_find_dim_by_name(get(), static_cast<enum isl_dim_type>(type), name.c_str());\n  return res;\n}\n\nmap map::fix_si(isl::dim type, unsigned int pos, int value) const\n{\n  auto res = isl_map_fix_si(copy(), static_cast<enum isl_dim_type>(type), pos, value);\n  return manage(res);\n}\n\nmap map::fix_val(isl::dim type, unsigned int pos, val v) const\n{\n  auto res = isl_map_fix_val(copy(), static_cast<enum isl_dim_type>(type), pos, v.release());\n  return manage(res);\n}\n\nmap map::fixed_power_val(val exp) const\n{\n  auto res = isl_map_fixed_power_val(copy(), exp.release());\n  return manage(res);\n}\n\nmap map::flat_domain_product(map map2) const\n{\n  auto res = isl_map_flat_domain_product(copy(), map2.release());\n  return manage(res);\n}\n\nmap map::flat_product(map map2) const\n{\n  auto res = isl_map_flat_product(copy(), map2.release());\n  return manage(res);\n}\n\nmap map::flat_range_product(map map2) const\n{\n  auto res = isl_map_flat_range_product(copy(), map2.release());\n  return manage(res);\n}\n\nmap map::flatten() const\n{\n  auto res = isl_map_flatten(copy());\n  return manage(res);\n}\n\nmap map::flatten_domain() const\n{\n  auto res = isl_map_flatten_domain(copy());\n  return manage(res);\n}\n\nmap map::flatten_range() const\n{\n  auto res = isl_map_flatten_range(copy());\n  return manage(res);\n}\n\nmap map::floordiv_val(val d) const\n{\n  auto res = isl_map_floordiv_val(copy(), d.release());\n  return manage(res);\n}\n\nstat map::foreach_basic_map(const std::function<stat(basic_map)> &fn) const\n{\n  struct fn_data {\n    const std::function<stat(basic_map)> *func;\n  } fn_data = { &fn };\n  auto fn_lambda = [](isl_basic_map *arg_0, void *arg_1) -> isl_stat {\n    auto *data = static_cast<struct fn_data *>(arg_1);\n    stat ret = (*data->func)(manage(arg_0));\n    return ret.release();\n  };\n  auto res = isl_map_foreach_basic_map(get(), fn_lambda, &fn_data);\n  return manage(res);\n}\n\nmap map::from_aff(aff aff)\n{\n  auto res = isl_map_from_aff(aff.release());\n  return manage(res);\n}\n\nmap map::from_domain(set set)\n{\n  auto res = isl_map_from_domain(set.release());\n  return manage(res);\n}\n\nmap map::from_domain_and_range(set domain, set range)\n{\n  auto res = isl_map_from_domain_and_range(domain.release(), range.release());\n  return manage(res);\n}\n\nmap map::from_multi_aff(multi_aff maff)\n{\n  auto res = isl_map_from_multi_aff(maff.release());\n  return manage(res);\n}\n\nmap map::from_multi_pw_aff(multi_pw_aff mpa)\n{\n  auto res = isl_map_from_multi_pw_aff(mpa.release());\n  return manage(res);\n}\n\nmap map::from_pw_aff(pw_aff pwaff)\n{\n  auto res = isl_map_from_pw_aff(pwaff.release());\n  return manage(res);\n}\n\nmap map::from_pw_multi_aff(pw_multi_aff pma)\n{\n  auto res = isl_map_from_pw_multi_aff(pma.release());\n  return manage(res);\n}\n\nmap map::from_range(set set)\n{\n  auto res = isl_map_from_range(set.release());\n  return manage(res);\n}\n\nmap map::from_union_map(union_map umap)\n{\n  auto res = isl_map_from_union_map(umap.release());\n  return manage(res);\n}\n\nbasic_map_list map::get_basic_map_list() const\n{\n  auto res = isl_map_get_basic_map_list(get());\n  return manage(res);\n}\n\nid map::get_dim_id(isl::dim type, unsigned int pos) const\n{\n  auto res = isl_map_get_dim_id(get(), static_cast<enum isl_dim_type>(type), pos);\n  return manage(res);\n}\n\nstd::string map::get_dim_name(isl::dim type, unsigned int pos) const\n{\n  auto res = isl_map_get_dim_name(get(), static_cast<enum isl_dim_type>(type), pos);\n  std::string tmp(res);\n  return tmp;\n}\n\nuint32_t map::get_hash() const\n{\n  auto res = isl_map_get_hash(get());\n  return res;\n}\n\nfixed_box map::get_range_simple_fixed_box_hull() const\n{\n  auto res = isl_map_get_range_simple_fixed_box_hull(get());\n  return manage(res);\n}\n\nspace map::get_space() const\n{\n  auto res = isl_map_get_space(get());\n  return manage(res);\n}\n\nid map::get_tuple_id(isl::dim type) const\n{\n  auto res = isl_map_get_tuple_id(get(), static_cast<enum isl_dim_type>(type));\n  return manage(res);\n}\n\nstd::string map::get_tuple_name(isl::dim type) const\n{\n  auto res = isl_map_get_tuple_name(get(), static_cast<enum isl_dim_type>(type));\n  std::string tmp(res);\n  return tmp;\n}\n\nmap map::gist(map context) const\n{\n  auto res = isl_map_gist(copy(), context.release());\n  return manage(res);\n}\n\nmap map::gist_basic_map(basic_map context) const\n{\n  auto res = isl_map_gist_basic_map(copy(), context.release());\n  return manage(res);\n}\n\nmap map::gist_domain(set context) const\n{\n  auto res = isl_map_gist_domain(copy(), context.release());\n  return manage(res);\n}\n\nmap map::gist_params(set context) const\n{\n  auto res = isl_map_gist_params(copy(), context.release());\n  return manage(res);\n}\n\nmap map::gist_range(set context) const\n{\n  auto res = isl_map_gist_range(copy(), context.release());\n  return manage(res);\n}\n\nboolean map::has_dim_id(isl::dim type, unsigned int pos) const\n{\n  auto res = isl_map_has_dim_id(get(), static_cast<enum isl_dim_type>(type), pos);\n  return manage(res);\n}\n\nboolean map::has_dim_name(isl::dim type, unsigned int pos) const\n{\n  auto res = isl_map_has_dim_name(get(), static_cast<enum isl_dim_type>(type), pos);\n  return manage(res);\n}\n\nboolean map::has_equal_space(const map &map2) const\n{\n  auto res = isl_map_has_equal_space(get(), map2.get());\n  return manage(res);\n}\n\nboolean map::has_tuple_id(isl::dim type) const\n{\n  auto res = isl_map_has_tuple_id(get(), static_cast<enum isl_dim_type>(type));\n  return manage(res);\n}\n\nboolean map::has_tuple_name(isl::dim type) const\n{\n  auto res = isl_map_has_tuple_name(get(), static_cast<enum isl_dim_type>(type));\n  return manage(res);\n}\n\nmap map::identity(space space)\n{\n  auto res = isl_map_identity(space.release());\n  return manage(res);\n}\n\nmap map::insert_dims(isl::dim type, unsigned int pos, unsigned int n) const\n{\n  auto res = isl_map_insert_dims(copy(), static_cast<enum isl_dim_type>(type), pos, n);\n  return manage(res);\n}\n\nmap map::intersect(map map2) const\n{\n  auto res = isl_map_intersect(copy(), map2.release());\n  return manage(res);\n}\n\nmap map::intersect_domain(set set) const\n{\n  auto res = isl_map_intersect_domain(copy(), set.release());\n  return manage(res);\n}\n\nmap map::intersect_domain_factor_domain(map factor) const\n{\n  auto res = isl_map_intersect_domain_factor_domain(copy(), factor.release());\n  return manage(res);\n}\n\nmap map::intersect_domain_factor_range(map factor) const\n{\n  auto res = isl_map_intersect_domain_factor_range(copy(), factor.release());\n  return manage(res);\n}\n\nmap map::intersect_params(set params) const\n{\n  auto res = isl_map_intersect_params(copy(), params.release());\n  return manage(res);\n}\n\nmap map::intersect_range(set set) const\n{\n  auto res = isl_map_intersect_range(copy(), set.release());\n  return manage(res);\n}\n\nmap map::intersect_range_factor_domain(map factor) const\n{\n  auto res = isl_map_intersect_range_factor_domain(copy(), factor.release());\n  return manage(res);\n}\n\nmap map::intersect_range_factor_range(map factor) const\n{\n  auto res = isl_map_intersect_range_factor_range(copy(), factor.release());\n  return manage(res);\n}\n\nboolean map::involves_dims(isl::dim type, unsigned int first, unsigned int n) const\n{\n  auto res = isl_map_involves_dims(get(), static_cast<enum isl_dim_type>(type), first, n);\n  return manage(res);\n}\n\nboolean map::is_bijective() const\n{\n  auto res = isl_map_is_bijective(get());\n  return manage(res);\n}\n\nboolean map::is_disjoint(const map &map2) const\n{\n  auto res = isl_map_is_disjoint(get(), map2.get());\n  return manage(res);\n}\n\nboolean map::is_empty() const\n{\n  auto res = isl_map_is_empty(get());\n  return manage(res);\n}\n\nboolean map::is_equal(const map &map2) const\n{\n  auto res = isl_map_is_equal(get(), map2.get());\n  return manage(res);\n}\n\nboolean map::is_identity() const\n{\n  auto res = isl_map_is_identity(get());\n  return manage(res);\n}\n\nboolean map::is_injective() const\n{\n  auto res = isl_map_is_injective(get());\n  return manage(res);\n}\n\nboolean map::is_product() const\n{\n  auto res = isl_map_is_product(get());\n  return manage(res);\n}\n\nboolean map::is_single_valued() const\n{\n  auto res = isl_map_is_single_valued(get());\n  return manage(res);\n}\n\nboolean map::is_strict_subset(const map &map2) const\n{\n  auto res = isl_map_is_strict_subset(get(), map2.get());\n  return manage(res);\n}\n\nboolean map::is_subset(const map &map2) const\n{\n  auto res = isl_map_is_subset(get(), map2.get());\n  return manage(res);\n}\n\nint map::is_translation() const\n{\n  auto res = isl_map_is_translation(get());\n  return res;\n}\n\nmap map::lex_ge(space set_space)\n{\n  auto res = isl_map_lex_ge(set_space.release());\n  return manage(res);\n}\n\nmap map::lex_ge_at(multi_pw_aff mpa) const\n{\n  auto res = isl_map_lex_ge_at_multi_pw_aff(copy(), mpa.release());\n  return manage(res);\n}\n\nmap map::lex_ge_first(space space, unsigned int n)\n{\n  auto res = isl_map_lex_ge_first(space.release(), n);\n  return manage(res);\n}\n\nmap map::lex_ge_map(map map2) const\n{\n  auto res = isl_map_lex_ge_map(copy(), map2.release());\n  return manage(res);\n}\n\nmap map::lex_gt(space set_space)\n{\n  auto res = isl_map_lex_gt(set_space.release());\n  return manage(res);\n}\n\nmap map::lex_gt_at(multi_pw_aff mpa) const\n{\n  auto res = isl_map_lex_gt_at_multi_pw_aff(copy(), mpa.release());\n  return manage(res);\n}\n\nmap map::lex_gt_first(space space, unsigned int n)\n{\n  auto res = isl_map_lex_gt_first(space.release(), n);\n  return manage(res);\n}\n\nmap map::lex_gt_map(map map2) const\n{\n  auto res = isl_map_lex_gt_map(copy(), map2.release());\n  return manage(res);\n}\n\nmap map::lex_le(space set_space)\n{\n  auto res = isl_map_lex_le(set_space.release());\n  return manage(res);\n}\n\nmap map::lex_le_at(multi_pw_aff mpa) const\n{\n  auto res = isl_map_lex_le_at_multi_pw_aff(copy(), mpa.release());\n  return manage(res);\n}\n\nmap map::lex_le_first(space space, unsigned int n)\n{\n  auto res = isl_map_lex_le_first(space.release(), n);\n  return manage(res);\n}\n\nmap map::lex_le_map(map map2) const\n{\n  auto res = isl_map_lex_le_map(copy(), map2.release());\n  return manage(res);\n}\n\nmap map::lex_lt(space set_space)\n{\n  auto res = isl_map_lex_lt(set_space.release());\n  return manage(res);\n}\n\nmap map::lex_lt_at(multi_pw_aff mpa) const\n{\n  auto res = isl_map_lex_lt_at_multi_pw_aff(copy(), mpa.release());\n  return manage(res);\n}\n\nmap map::lex_lt_first(space space, unsigned int n)\n{\n  auto res = isl_map_lex_lt_first(space.release(), n);\n  return manage(res);\n}\n\nmap map::lex_lt_map(map map2) const\n{\n  auto res = isl_map_lex_lt_map(copy(), map2.release());\n  return manage(res);\n}\n\nmap map::lexmax() const\n{\n  auto res = isl_map_lexmax(copy());\n  return manage(res);\n}\n\npw_multi_aff map::lexmax_pw_multi_aff() const\n{\n  auto res = isl_map_lexmax_pw_multi_aff(copy());\n  return manage(res);\n}\n\nmap map::lexmin() const\n{\n  auto res = isl_map_lexmin(copy());\n  return manage(res);\n}\n\npw_multi_aff map::lexmin_pw_multi_aff() const\n{\n  auto res = isl_map_lexmin_pw_multi_aff(copy());\n  return manage(res);\n}\n\nmap map::lower_bound(multi_pw_aff lower) const\n{\n  auto res = isl_map_lower_bound_multi_pw_aff(copy(), lower.release());\n  return manage(res);\n}\n\nmap map::lower_bound_si(isl::dim type, unsigned int pos, int value) const\n{\n  auto res = isl_map_lower_bound_si(copy(), static_cast<enum isl_dim_type>(type), pos, value);\n  return manage(res);\n}\n\nmap map::lower_bound_val(isl::dim type, unsigned int pos, val value) const\n{\n  auto res = isl_map_lower_bound_val(copy(), static_cast<enum isl_dim_type>(type), pos, value.release());\n  return manage(res);\n}\n\nmulti_pw_aff map::max_multi_pw_aff() const\n{\n  auto res = isl_map_max_multi_pw_aff(copy());\n  return manage(res);\n}\n\nmulti_pw_aff map::min_multi_pw_aff() const\n{\n  auto res = isl_map_min_multi_pw_aff(copy());\n  return manage(res);\n}\n\nmap map::move_dims(isl::dim dst_type, unsigned int dst_pos, isl::dim src_type, unsigned int src_pos, unsigned int n) const\n{\n  auto res = isl_map_move_dims(copy(), static_cast<enum isl_dim_type>(dst_type), dst_pos, static_cast<enum isl_dim_type>(src_type), src_pos, n);\n  return manage(res);\n}\n\nisl_size map::n_basic_map() const\n{\n  auto res = isl_map_n_basic_map(get());\n  return res;\n}\n\nmap map::nat_universe(space space)\n{\n  auto res = isl_map_nat_universe(space.release());\n  return manage(res);\n}\n\nmap map::neg() const\n{\n  auto res = isl_map_neg(copy());\n  return manage(res);\n}\n\nmap map::oppose(isl::dim type1, int pos1, isl::dim type2, int pos2) const\n{\n  auto res = isl_map_oppose(copy(), static_cast<enum isl_dim_type>(type1), pos1, static_cast<enum isl_dim_type>(type2), pos2);\n  return manage(res);\n}\n\nmap map::order_ge(isl::dim type1, int pos1, isl::dim type2, int pos2) const\n{\n  auto res = isl_map_order_ge(copy(), static_cast<enum isl_dim_type>(type1), pos1, static_cast<enum isl_dim_type>(type2), pos2);\n  return manage(res);\n}\n\nmap map::order_gt(isl::dim type1, int pos1, isl::dim type2, int pos2) const\n{\n  auto res = isl_map_order_gt(copy(), static_cast<enum isl_dim_type>(type1), pos1, static_cast<enum isl_dim_type>(type2), pos2);\n  return manage(res);\n}\n\nmap map::order_le(isl::dim type1, int pos1, isl::dim type2, int pos2) const\n{\n  auto res = isl_map_order_le(copy(), static_cast<enum isl_dim_type>(type1), pos1, static_cast<enum isl_dim_type>(type2), pos2);\n  return manage(res);\n}\n\nmap map::order_lt(isl::dim type1, int pos1, isl::dim type2, int pos2) const\n{\n  auto res = isl_map_order_lt(copy(), static_cast<enum isl_dim_type>(type1), pos1, static_cast<enum isl_dim_type>(type2), pos2);\n  return manage(res);\n}\n\nset map::params() const\n{\n  auto res = isl_map_params(copy());\n  return manage(res);\n}\n\nval map::plain_get_val_if_fixed(isl::dim type, unsigned int pos) const\n{\n  auto res = isl_map_plain_get_val_if_fixed(get(), static_cast<enum isl_dim_type>(type), pos);\n  return manage(res);\n}\n\nboolean map::plain_is_empty() const\n{\n  auto res = isl_map_plain_is_empty(get());\n  return manage(res);\n}\n\nboolean map::plain_is_equal(const map &map2) const\n{\n  auto res = isl_map_plain_is_equal(get(), map2.get());\n  return manage(res);\n}\n\nboolean map::plain_is_injective() const\n{\n  auto res = isl_map_plain_is_injective(get());\n  return manage(res);\n}\n\nboolean map::plain_is_single_valued() const\n{\n  auto res = isl_map_plain_is_single_valued(get());\n  return manage(res);\n}\n\nboolean map::plain_is_universe() const\n{\n  auto res = isl_map_plain_is_universe(get());\n  return manage(res);\n}\n\nbasic_map map::plain_unshifted_simple_hull() const\n{\n  auto res = isl_map_plain_unshifted_simple_hull(copy());\n  return manage(res);\n}\n\nbasic_map map::polyhedral_hull() const\n{\n  auto res = isl_map_polyhedral_hull(copy());\n  return manage(res);\n}\n\nmap map::preimage_domain(multi_aff ma) const\n{\n  auto res = isl_map_preimage_domain_multi_aff(copy(), ma.release());\n  return manage(res);\n}\n\nmap map::preimage_domain(multi_pw_aff mpa) const\n{\n  auto res = isl_map_preimage_domain_multi_pw_aff(copy(), mpa.release());\n  return manage(res);\n}\n\nmap map::preimage_domain(pw_multi_aff pma) const\n{\n  auto res = isl_map_preimage_domain_pw_multi_aff(copy(), pma.release());\n  return manage(res);\n}\n\nmap map::preimage_range(multi_aff ma) const\n{\n  auto res = isl_map_preimage_range_multi_aff(copy(), ma.release());\n  return manage(res);\n}\n\nmap map::preimage_range(pw_multi_aff pma) const\n{\n  auto res = isl_map_preimage_range_pw_multi_aff(copy(), pma.release());\n  return manage(res);\n}\n\nmap map::product(map map2) const\n{\n  auto res = isl_map_product(copy(), map2.release());\n  return manage(res);\n}\n\nmap map::project_out(isl::dim type, unsigned int first, unsigned int n) const\n{\n  auto res = isl_map_project_out(copy(), static_cast<enum isl_dim_type>(type), first, n);\n  return manage(res);\n}\n\nmap map::project_out_all_params() const\n{\n  auto res = isl_map_project_out_all_params(copy());\n  return manage(res);\n}\n\nset map::range() const\n{\n  auto res = isl_map_range(copy());\n  return manage(res);\n}\n\nmap map::range_curry() const\n{\n  auto res = isl_map_range_curry(copy());\n  return manage(res);\n}\n\nmap map::range_factor_domain() const\n{\n  auto res = isl_map_range_factor_domain(copy());\n  return manage(res);\n}\n\nmap map::range_factor_range() const\n{\n  auto res = isl_map_range_factor_range(copy());\n  return manage(res);\n}\n\nboolean map::range_is_wrapping() const\n{\n  auto res = isl_map_range_is_wrapping(get());\n  return manage(res);\n}\n\nmap map::range_map() const\n{\n  auto res = isl_map_range_map(copy());\n  return manage(res);\n}\n\nmap map::range_product(map map2) const\n{\n  auto res = isl_map_range_product(copy(), map2.release());\n  return manage(res);\n}\n\nmap map::range_reverse() const\n{\n  auto res = isl_map_range_reverse(copy());\n  return manage(res);\n}\n\nmap map::remove_dims(isl::dim type, unsigned int first, unsigned int n) const\n{\n  auto res = isl_map_remove_dims(copy(), static_cast<enum isl_dim_type>(type), first, n);\n  return manage(res);\n}\n\nmap map::remove_divs() const\n{\n  auto res = isl_map_remove_divs(copy());\n  return manage(res);\n}\n\nmap map::remove_divs_involving_dims(isl::dim type, unsigned int first, unsigned int n) const\n{\n  auto res = isl_map_remove_divs_involving_dims(copy(), static_cast<enum isl_dim_type>(type), first, n);\n  return manage(res);\n}\n\nmap map::remove_redundancies() const\n{\n  auto res = isl_map_remove_redundancies(copy());\n  return manage(res);\n}\n\nmap map::remove_unknown_divs() const\n{\n  auto res = isl_map_remove_unknown_divs(copy());\n  return manage(res);\n}\n\nmap map::reset_tuple_id(isl::dim type) const\n{\n  auto res = isl_map_reset_tuple_id(copy(), static_cast<enum isl_dim_type>(type));\n  return manage(res);\n}\n\nmap map::reset_user() const\n{\n  auto res = isl_map_reset_user(copy());\n  return manage(res);\n}\n\nmap map::reverse() const\n{\n  auto res = isl_map_reverse(copy());\n  return manage(res);\n}\n\nbasic_map map::sample() const\n{\n  auto res = isl_map_sample(copy());\n  return manage(res);\n}\n\nmap map::set_dim_id(isl::dim type, unsigned int pos, id id) const\n{\n  auto res = isl_map_set_dim_id(copy(), static_cast<enum isl_dim_type>(type), pos, id.release());\n  return manage(res);\n}\n\nmap map::set_tuple_id(isl::dim type, id id) const\n{\n  auto res = isl_map_set_tuple_id(copy(), static_cast<enum isl_dim_type>(type), id.release());\n  return manage(res);\n}\n\nmap map::set_tuple_name(isl::dim type, const std::string &s) const\n{\n  auto res = isl_map_set_tuple_name(copy(), static_cast<enum isl_dim_type>(type), s.c_str());\n  return manage(res);\n}\n\nbasic_map map::simple_hull() const\n{\n  auto res = isl_map_simple_hull(copy());\n  return manage(res);\n}\n\nmap map::subtract(map map2) const\n{\n  auto res = isl_map_subtract(copy(), map2.release());\n  return manage(res);\n}\n\nmap map::subtract_domain(set dom) const\n{\n  auto res = isl_map_subtract_domain(copy(), dom.release());\n  return manage(res);\n}\n\nmap map::subtract_range(set dom) const\n{\n  auto res = isl_map_subtract_range(copy(), dom.release());\n  return manage(res);\n}\n\nmap map::sum(map map2) const\n{\n  auto res = isl_map_sum(copy(), map2.release());\n  return manage(res);\n}\n\nmap map::uncurry() const\n{\n  auto res = isl_map_uncurry(copy());\n  return manage(res);\n}\n\nmap map::unite(map map2) const\n{\n  auto res = isl_map_union(copy(), map2.release());\n  return manage(res);\n}\n\nmap map::universe(space space)\n{\n  auto res = isl_map_universe(space.release());\n  return manage(res);\n}\n\nbasic_map map::unshifted_simple_hull() const\n{\n  auto res = isl_map_unshifted_simple_hull(copy());\n  return manage(res);\n}\n\nbasic_map map::unshifted_simple_hull_from_map_list(map_list list) const\n{\n  auto res = isl_map_unshifted_simple_hull_from_map_list(copy(), list.release());\n  return manage(res);\n}\n\nmap map::upper_bound(multi_pw_aff upper) const\n{\n  auto res = isl_map_upper_bound_multi_pw_aff(copy(), upper.release());\n  return manage(res);\n}\n\nmap map::upper_bound_si(isl::dim type, unsigned int pos, int value) const\n{\n  auto res = isl_map_upper_bound_si(copy(), static_cast<enum isl_dim_type>(type), pos, value);\n  return manage(res);\n}\n\nmap map::upper_bound_val(isl::dim type, unsigned int pos, val value) const\n{\n  auto res = isl_map_upper_bound_val(copy(), static_cast<enum isl_dim_type>(type), pos, value.release());\n  return manage(res);\n}\n\nset map::wrap() const\n{\n  auto res = isl_map_wrap(copy());\n  return manage(res);\n}\n\nmap map::zip() const\n{\n  auto res = isl_map_zip(copy());\n  return manage(res);\n}\n\n// implementations for isl::map_list\nmap_list manage(__isl_take isl_map_list *ptr) {\n  return map_list(ptr);\n}\nmap_list manage_copy(__isl_keep isl_map_list *ptr) {\n  ptr = isl_map_list_copy(ptr);\n  return map_list(ptr);\n}\n\nmap_list::map_list()\n    : ptr(nullptr) {}\n\nmap_list::map_list(const map_list &obj)\n    : ptr(nullptr)\n{\n  ptr = obj.copy();\n}\nmap_list::map_list(std::nullptr_t)\n    : ptr(nullptr) {}\n\n\nmap_list::map_list(__isl_take isl_map_list *ptr)\n    : ptr(ptr) {}\n\n\nmap_list &map_list::operator=(map_list obj) {\n  std::swap(this->ptr, obj.ptr);\n  return *this;\n}\n\nmap_list::~map_list() {\n  if (ptr)\n    isl_map_list_free(ptr);\n}\n\n__isl_give isl_map_list *map_list::copy() const & {\n  return isl_map_list_copy(ptr);\n}\n\n__isl_keep isl_map_list *map_list::get() const {\n  return ptr;\n}\n\n__isl_give isl_map_list *map_list::release() {\n  isl_map_list *tmp = ptr;\n  ptr = nullptr;\n  return tmp;\n}\n\nbool map_list::is_null() const {\n  return ptr == nullptr;\n}\nmap_list::operator bool() const {\n  return !is_null();\n}\n\n\nctx map_list::get_ctx() const {\n  return ctx(isl_map_list_get_ctx(ptr));\n}\nstd::string map_list::to_str() const {\n  char *Tmp = isl_map_list_to_str(get());\n  if (!Tmp)\n    return \"\";\n  std::string S(Tmp);\n  free(Tmp);\n  return S;\n}\n\n\nvoid map_list::dump() const {\n  isl_map_list_dump(get());\n}\n\n\nmap_list map_list::add(map el) const\n{\n  auto res = isl_map_list_add(copy(), el.release());\n  return manage(res);\n}\n\nmap_list map_list::alloc(ctx ctx, int n)\n{\n  auto res = isl_map_list_alloc(ctx.release(), n);\n  return manage(res);\n}\n\nmap_list map_list::clear() const\n{\n  auto res = isl_map_list_clear(copy());\n  return manage(res);\n}\n\nmap_list map_list::concat(map_list list2) const\n{\n  auto res = isl_map_list_concat(copy(), list2.release());\n  return manage(res);\n}\n\nmap_list map_list::drop(unsigned int first, unsigned int n) const\n{\n  auto res = isl_map_list_drop(copy(), first, n);\n  return manage(res);\n}\n\nstat map_list::foreach(const std::function<stat(map)> &fn) const\n{\n  struct fn_data {\n    const std::function<stat(map)> *func;\n  } fn_data = { &fn };\n  auto fn_lambda = [](isl_map *arg_0, void *arg_1) -> isl_stat {\n    auto *data = static_cast<struct fn_data *>(arg_1);\n    stat ret = (*data->func)(manage(arg_0));\n    return ret.release();\n  };\n  auto res = isl_map_list_foreach(get(), fn_lambda, &fn_data);\n  return manage(res);\n}\n\nmap_list map_list::from_map(map el)\n{\n  auto res = isl_map_list_from_map(el.release());\n  return manage(res);\n}\n\nmap map_list::get_at(int index) const\n{\n  auto res = isl_map_list_get_at(get(), index);\n  return manage(res);\n}\n\nmap map_list::get_map(int index) const\n{\n  auto res = isl_map_list_get_map(get(), index);\n  return manage(res);\n}\n\nmap_list map_list::insert(unsigned int pos, map el) const\n{\n  auto res = isl_map_list_insert(copy(), pos, el.release());\n  return manage(res);\n}\n\nisl_size map_list::n_map() const\n{\n  auto res = isl_map_list_n_map(get());\n  return res;\n}\n\nmap_list map_list::reverse() const\n{\n  auto res = isl_map_list_reverse(copy());\n  return manage(res);\n}\n\nmap_list map_list::set_map(int index, map el) const\n{\n  auto res = isl_map_list_set_map(copy(), index, el.release());\n  return manage(res);\n}\n\nisl_size map_list::size() const\n{\n  auto res = isl_map_list_size(get());\n  return res;\n}\n\nmap_list map_list::swap(unsigned int pos1, unsigned int pos2) const\n{\n  auto res = isl_map_list_swap(copy(), pos1, pos2);\n  return manage(res);\n}\n\n// implementations for isl::mat\nmat manage(__isl_take isl_mat *ptr) {\n  return mat(ptr);\n}\nmat manage_copy(__isl_keep isl_mat *ptr) {\n  ptr = isl_mat_copy(ptr);\n  return mat(ptr);\n}\n\nmat::mat()\n    : ptr(nullptr) {}\n\nmat::mat(const mat &obj)\n    : ptr(nullptr)\n{\n  ptr = obj.copy();\n}\nmat::mat(std::nullptr_t)\n    : ptr(nullptr) {}\n\n\nmat::mat(__isl_take isl_mat *ptr)\n    : ptr(ptr) {}\n\n\nmat &mat::operator=(mat obj) {\n  std::swap(this->ptr, obj.ptr);\n  return *this;\n}\n\nmat::~mat() {\n  if (ptr)\n    isl_mat_free(ptr);\n}\n\n__isl_give isl_mat *mat::copy() const & {\n  return isl_mat_copy(ptr);\n}\n\n__isl_keep isl_mat *mat::get() const {\n  return ptr;\n}\n\n__isl_give isl_mat *mat::release() {\n  isl_mat *tmp = ptr;\n  ptr = nullptr;\n  return tmp;\n}\n\nbool mat::is_null() const {\n  return ptr == nullptr;\n}\nmat::operator bool() const {\n  return !is_null();\n}\n\n\nctx mat::get_ctx() const {\n  return ctx(isl_mat_get_ctx(ptr));\n}\n\nvoid mat::dump() const {\n  isl_mat_dump(get());\n}\n\n\nmat mat::add_rows(unsigned int n) const\n{\n  auto res = isl_mat_add_rows(copy(), n);\n  return manage(res);\n}\n\nmat mat::add_zero_cols(unsigned int n) const\n{\n  auto res = isl_mat_add_zero_cols(copy(), n);\n  return manage(res);\n}\n\nmat mat::add_zero_rows(unsigned int n) const\n{\n  auto res = isl_mat_add_zero_rows(copy(), n);\n  return manage(res);\n}\n\nmat mat::aff_direct_sum(mat right) const\n{\n  auto res = isl_mat_aff_direct_sum(copy(), right.release());\n  return manage(res);\n}\n\nmat mat::alloc(ctx ctx, unsigned int n_row, unsigned int n_col)\n{\n  auto res = isl_mat_alloc(ctx.release(), n_row, n_col);\n  return manage(res);\n}\n\nisl_size mat::cols() const\n{\n  auto res = isl_mat_cols(get());\n  return res;\n}\n\nmat mat::concat(mat bot) const\n{\n  auto res = isl_mat_concat(copy(), bot.release());\n  return manage(res);\n}\n\nmat mat::diagonal(mat mat2) const\n{\n  auto res = isl_mat_diagonal(copy(), mat2.release());\n  return manage(res);\n}\n\nmat mat::drop_cols(unsigned int col, unsigned int n) const\n{\n  auto res = isl_mat_drop_cols(copy(), col, n);\n  return manage(res);\n}\n\nmat mat::drop_rows(unsigned int row, unsigned int n) const\n{\n  auto res = isl_mat_drop_rows(copy(), row, n);\n  return manage(res);\n}\n\nmat mat::from_row_vec(vec vec)\n{\n  auto res = isl_mat_from_row_vec(vec.release());\n  return manage(res);\n}\n\nval mat::get_element_val(int row, int col) const\n{\n  auto res = isl_mat_get_element_val(get(), row, col);\n  return manage(res);\n}\n\nboolean mat::has_linearly_independent_rows(const mat &mat2) const\n{\n  auto res = isl_mat_has_linearly_independent_rows(get(), mat2.get());\n  return manage(res);\n}\n\nint mat::initial_non_zero_cols() const\n{\n  auto res = isl_mat_initial_non_zero_cols(get());\n  return res;\n}\n\nmat mat::insert_cols(unsigned int col, unsigned int n) const\n{\n  auto res = isl_mat_insert_cols(copy(), col, n);\n  return manage(res);\n}\n\nmat mat::insert_rows(unsigned int row, unsigned int n) const\n{\n  auto res = isl_mat_insert_rows(copy(), row, n);\n  return manage(res);\n}\n\nmat mat::insert_zero_cols(unsigned int first, unsigned int n) const\n{\n  auto res = isl_mat_insert_zero_cols(copy(), first, n);\n  return manage(res);\n}\n\nmat mat::insert_zero_rows(unsigned int row, unsigned int n) const\n{\n  auto res = isl_mat_insert_zero_rows(copy(), row, n);\n  return manage(res);\n}\n\nmat mat::inverse_product(mat right) const\n{\n  auto res = isl_mat_inverse_product(copy(), right.release());\n  return manage(res);\n}\n\nboolean mat::is_equal(const mat &mat2) const\n{\n  auto res = isl_mat_is_equal(get(), mat2.get());\n  return manage(res);\n}\n\nmat mat::lin_to_aff() const\n{\n  auto res = isl_mat_lin_to_aff(copy());\n  return manage(res);\n}\n\nmat mat::move_cols(unsigned int dst_col, unsigned int src_col, unsigned int n) const\n{\n  auto res = isl_mat_move_cols(copy(), dst_col, src_col, n);\n  return manage(res);\n}\n\nmat mat::normalize() const\n{\n  auto res = isl_mat_normalize(copy());\n  return manage(res);\n}\n\nmat mat::normalize_row(int row) const\n{\n  auto res = isl_mat_normalize_row(copy(), row);\n  return manage(res);\n}\n\nmat mat::product(mat right) const\n{\n  auto res = isl_mat_product(copy(), right.release());\n  return manage(res);\n}\n\nisl_size mat::rank() const\n{\n  auto res = isl_mat_rank(get());\n  return res;\n}\n\nmat mat::right_inverse() const\n{\n  auto res = isl_mat_right_inverse(copy());\n  return manage(res);\n}\n\nmat mat::right_kernel() const\n{\n  auto res = isl_mat_right_kernel(copy());\n  return manage(res);\n}\n\nmat mat::row_basis() const\n{\n  auto res = isl_mat_row_basis(copy());\n  return manage(res);\n}\n\nmat mat::row_basis_extension(mat mat2) const\n{\n  auto res = isl_mat_row_basis_extension(copy(), mat2.release());\n  return manage(res);\n}\n\nisl_size mat::rows() const\n{\n  auto res = isl_mat_rows(get());\n  return res;\n}\n\nmat mat::set_element_si(int row, int col, int v) const\n{\n  auto res = isl_mat_set_element_si(copy(), row, col, v);\n  return manage(res);\n}\n\nmat mat::set_element_val(int row, int col, val v) const\n{\n  auto res = isl_mat_set_element_val(copy(), row, col, v.release());\n  return manage(res);\n}\n\nmat mat::swap_cols(unsigned int i, unsigned int j) const\n{\n  auto res = isl_mat_swap_cols(copy(), i, j);\n  return manage(res);\n}\n\nmat mat::swap_rows(unsigned int i, unsigned int j) const\n{\n  auto res = isl_mat_swap_rows(copy(), i, j);\n  return manage(res);\n}\n\nmat mat::transpose() const\n{\n  auto res = isl_mat_transpose(copy());\n  return manage(res);\n}\n\nmat mat::unimodular_complete(int row) const\n{\n  auto res = isl_mat_unimodular_complete(copy(), row);\n  return manage(res);\n}\n\nmat mat::vec_concat(vec bot) const\n{\n  auto res = isl_mat_vec_concat(copy(), bot.release());\n  return manage(res);\n}\n\nvec mat::vec_inverse_product(vec vec) const\n{\n  auto res = isl_mat_vec_inverse_product(copy(), vec.release());\n  return manage(res);\n}\n\nvec mat::vec_product(vec vec) const\n{\n  auto res = isl_mat_vec_product(copy(), vec.release());\n  return manage(res);\n}\n\n// implementations for isl::multi_aff\nmulti_aff manage(__isl_take isl_multi_aff *ptr) {\n  return multi_aff(ptr);\n}\nmulti_aff manage_copy(__isl_keep isl_multi_aff *ptr) {\n  ptr = isl_multi_aff_copy(ptr);\n  return multi_aff(ptr);\n}\n\nmulti_aff::multi_aff()\n    : ptr(nullptr) {}\n\nmulti_aff::multi_aff(const multi_aff &obj)\n    : ptr(nullptr)\n{\n  ptr = obj.copy();\n}\nmulti_aff::multi_aff(std::nullptr_t)\n    : ptr(nullptr) {}\n\n\nmulti_aff::multi_aff(__isl_take isl_multi_aff *ptr)\n    : ptr(ptr) {}\n\nmulti_aff::multi_aff(aff aff)\n{\n  auto res = isl_multi_aff_from_aff(aff.release());\n  ptr = res;\n}\nmulti_aff::multi_aff(space space, aff_list list)\n{\n  auto res = isl_multi_aff_from_aff_list(space.release(), list.release());\n  ptr = res;\n}\nmulti_aff::multi_aff(ctx ctx, const std::string &str)\n{\n  auto res = isl_multi_aff_read_from_str(ctx.release(), str.c_str());\n  ptr = res;\n}\n\nmulti_aff &multi_aff::operator=(multi_aff obj) {\n  std::swap(this->ptr, obj.ptr);\n  return *this;\n}\n\nmulti_aff::~multi_aff() {\n  if (ptr)\n    isl_multi_aff_free(ptr);\n}\n\n__isl_give isl_multi_aff *multi_aff::copy() const & {\n  return isl_multi_aff_copy(ptr);\n}\n\n__isl_keep isl_multi_aff *multi_aff::get() const {\n  return ptr;\n}\n\n__isl_give isl_multi_aff *multi_aff::release() {\n  isl_multi_aff *tmp = ptr;\n  ptr = nullptr;\n  return tmp;\n}\n\nbool multi_aff::is_null() const {\n  return ptr == nullptr;\n}\nmulti_aff::operator bool() const {\n  return !is_null();\n}\n\n\nctx multi_aff::get_ctx() const {\n  return ctx(isl_multi_aff_get_ctx(ptr));\n}\nstd::string multi_aff::to_str() const {\n  char *Tmp = isl_multi_aff_to_str(get());\n  if (!Tmp)\n    return \"\";\n  std::string S(Tmp);\n  free(Tmp);\n  return S;\n}\n\n\nvoid multi_aff::dump() const {\n  isl_multi_aff_dump(get());\n}\n\n\nmulti_aff multi_aff::add(multi_aff multi2) const\n{\n  auto res = isl_multi_aff_add(copy(), multi2.release());\n  return manage(res);\n}\n\nmulti_aff multi_aff::add_constant(multi_val mv) const\n{\n  auto res = isl_multi_aff_add_constant_multi_val(copy(), mv.release());\n  return manage(res);\n}\n\nmulti_aff multi_aff::add_constant(val v) const\n{\n  auto res = isl_multi_aff_add_constant_val(copy(), v.release());\n  return manage(res);\n}\n\nmulti_aff multi_aff::add_dims(isl::dim type, unsigned int n) const\n{\n  auto res = isl_multi_aff_add_dims(copy(), static_cast<enum isl_dim_type>(type), n);\n  return manage(res);\n}\n\nmulti_aff multi_aff::align_params(space model) const\n{\n  auto res = isl_multi_aff_align_params(copy(), model.release());\n  return manage(res);\n}\n\nbasic_set multi_aff::bind(multi_id tuple) const\n{\n  auto res = isl_multi_aff_bind(copy(), tuple.release());\n  return manage(res);\n}\n\nmulti_aff multi_aff::bind_domain(multi_id tuple) const\n{\n  auto res = isl_multi_aff_bind_domain(copy(), tuple.release());\n  return manage(res);\n}\n\nmulti_aff multi_aff::bind_domain_wrapped_domain(multi_id tuple) const\n{\n  auto res = isl_multi_aff_bind_domain_wrapped_domain(copy(), tuple.release());\n  return manage(res);\n}\n\nisl_size multi_aff::dim(isl::dim type) const\n{\n  auto res = isl_multi_aff_dim(get(), static_cast<enum isl_dim_type>(type));\n  return res;\n}\n\nmulti_aff multi_aff::domain_map(space space)\n{\n  auto res = isl_multi_aff_domain_map(space.release());\n  return manage(res);\n}\n\nmulti_aff multi_aff::drop_dims(isl::dim type, unsigned int first, unsigned int n) const\n{\n  auto res = isl_multi_aff_drop_dims(copy(), static_cast<enum isl_dim_type>(type), first, n);\n  return manage(res);\n}\n\nmulti_aff multi_aff::factor_range() const\n{\n  auto res = isl_multi_aff_factor_range(copy());\n  return manage(res);\n}\n\nint multi_aff::find_dim_by_id(isl::dim type, const id &id) const\n{\n  auto res = isl_multi_aff_find_dim_by_id(get(), static_cast<enum isl_dim_type>(type), id.get());\n  return res;\n}\n\nint multi_aff::find_dim_by_name(isl::dim type, const std::string &name) const\n{\n  auto res = isl_multi_aff_find_dim_by_name(get(), static_cast<enum isl_dim_type>(type), name.c_str());\n  return res;\n}\n\nmulti_aff multi_aff::flat_range_product(multi_aff multi2) const\n{\n  auto res = isl_multi_aff_flat_range_product(copy(), multi2.release());\n  return manage(res);\n}\n\nmulti_aff multi_aff::flatten_domain() const\n{\n  auto res = isl_multi_aff_flatten_domain(copy());\n  return manage(res);\n}\n\nmulti_aff multi_aff::flatten_range() const\n{\n  auto res = isl_multi_aff_flatten_range(copy());\n  return manage(res);\n}\n\nmulti_aff multi_aff::floor() const\n{\n  auto res = isl_multi_aff_floor(copy());\n  return manage(res);\n}\n\nmulti_aff multi_aff::from_range() const\n{\n  auto res = isl_multi_aff_from_range(copy());\n  return manage(res);\n}\n\naff multi_aff::get_aff(int pos) const\n{\n  auto res = isl_multi_aff_get_aff(get(), pos);\n  return manage(res);\n}\n\naff multi_aff::get_at(int pos) const\n{\n  auto res = isl_multi_aff_get_at(get(), pos);\n  return manage(res);\n}\n\nmulti_val multi_aff::get_constant_multi_val() const\n{\n  auto res = isl_multi_aff_get_constant_multi_val(get());\n  return manage(res);\n}\n\nid multi_aff::get_dim_id(isl::dim type, unsigned int pos) const\n{\n  auto res = isl_multi_aff_get_dim_id(get(), static_cast<enum isl_dim_type>(type), pos);\n  return manage(res);\n}\n\nspace multi_aff::get_domain_space() const\n{\n  auto res = isl_multi_aff_get_domain_space(get());\n  return manage(res);\n}\n\naff_list multi_aff::get_list() const\n{\n  auto res = isl_multi_aff_get_list(get());\n  return manage(res);\n}\n\nspace multi_aff::get_space() const\n{\n  auto res = isl_multi_aff_get_space(get());\n  return manage(res);\n}\n\nid multi_aff::get_tuple_id(isl::dim type) const\n{\n  auto res = isl_multi_aff_get_tuple_id(get(), static_cast<enum isl_dim_type>(type));\n  return manage(res);\n}\n\nstd::string multi_aff::get_tuple_name(isl::dim type) const\n{\n  auto res = isl_multi_aff_get_tuple_name(get(), static_cast<enum isl_dim_type>(type));\n  std::string tmp(res);\n  return tmp;\n}\n\nmulti_aff multi_aff::gist(set context) const\n{\n  auto res = isl_multi_aff_gist(copy(), context.release());\n  return manage(res);\n}\n\nmulti_aff multi_aff::gist_params(set context) const\n{\n  auto res = isl_multi_aff_gist_params(copy(), context.release());\n  return manage(res);\n}\n\nboolean multi_aff::has_tuple_id(isl::dim type) const\n{\n  auto res = isl_multi_aff_has_tuple_id(get(), static_cast<enum isl_dim_type>(type));\n  return manage(res);\n}\n\nmulti_aff multi_aff::identity(space space)\n{\n  auto res = isl_multi_aff_identity(space.release());\n  return manage(res);\n}\n\nmulti_aff multi_aff::identity() const\n{\n  auto res = isl_multi_aff_identity_multi_aff(copy());\n  return manage(res);\n}\n\nmulti_aff multi_aff::identity_on_domain(space space)\n{\n  auto res = isl_multi_aff_identity_on_domain_space(space.release());\n  return manage(res);\n}\n\nmulti_aff multi_aff::insert_dims(isl::dim type, unsigned int first, unsigned int n) const\n{\n  auto res = isl_multi_aff_insert_dims(copy(), static_cast<enum isl_dim_type>(type), first, n);\n  return manage(res);\n}\n\nmulti_aff multi_aff::insert_domain(space domain) const\n{\n  auto res = isl_multi_aff_insert_domain(copy(), domain.release());\n  return manage(res);\n}\n\nboolean multi_aff::involves_dims(isl::dim type, unsigned int first, unsigned int n) const\n{\n  auto res = isl_multi_aff_involves_dims(get(), static_cast<enum isl_dim_type>(type), first, n);\n  return manage(res);\n}\n\nboolean multi_aff::involves_locals() const\n{\n  auto res = isl_multi_aff_involves_locals(get());\n  return manage(res);\n}\n\nboolean multi_aff::involves_nan() const\n{\n  auto res = isl_multi_aff_involves_nan(get());\n  return manage(res);\n}\n\nset multi_aff::lex_ge_set(multi_aff ma2) const\n{\n  auto res = isl_multi_aff_lex_ge_set(copy(), ma2.release());\n  return manage(res);\n}\n\nset multi_aff::lex_gt_set(multi_aff ma2) const\n{\n  auto res = isl_multi_aff_lex_gt_set(copy(), ma2.release());\n  return manage(res);\n}\n\nset multi_aff::lex_le_set(multi_aff ma2) const\n{\n  auto res = isl_multi_aff_lex_le_set(copy(), ma2.release());\n  return manage(res);\n}\n\nset multi_aff::lex_lt_set(multi_aff ma2) const\n{\n  auto res = isl_multi_aff_lex_lt_set(copy(), ma2.release());\n  return manage(res);\n}\n\nmulti_aff multi_aff::mod_multi_val(multi_val mv) const\n{\n  auto res = isl_multi_aff_mod_multi_val(copy(), mv.release());\n  return manage(res);\n}\n\nmulti_aff multi_aff::move_dims(isl::dim dst_type, unsigned int dst_pos, isl::dim src_type, unsigned int src_pos, unsigned int n) const\n{\n  auto res = isl_multi_aff_move_dims(copy(), static_cast<enum isl_dim_type>(dst_type), dst_pos, static_cast<enum isl_dim_type>(src_type), src_pos, n);\n  return manage(res);\n}\n\nmulti_aff multi_aff::multi_val_on_space(space space, multi_val mv)\n{\n  auto res = isl_multi_aff_multi_val_on_space(space.release(), mv.release());\n  return manage(res);\n}\n\nmulti_aff multi_aff::neg() const\n{\n  auto res = isl_multi_aff_neg(copy());\n  return manage(res);\n}\n\nint multi_aff::plain_cmp(const multi_aff &multi2) const\n{\n  auto res = isl_multi_aff_plain_cmp(get(), multi2.get());\n  return res;\n}\n\nboolean multi_aff::plain_is_equal(const multi_aff &multi2) const\n{\n  auto res = isl_multi_aff_plain_is_equal(get(), multi2.get());\n  return manage(res);\n}\n\nmulti_aff multi_aff::product(multi_aff multi2) const\n{\n  auto res = isl_multi_aff_product(copy(), multi2.release());\n  return manage(res);\n}\n\nmulti_aff multi_aff::project_domain_on_params() const\n{\n  auto res = isl_multi_aff_project_domain_on_params(copy());\n  return manage(res);\n}\n\nmulti_aff multi_aff::project_out_map(space space, isl::dim type, unsigned int first, unsigned int n)\n{\n  auto res = isl_multi_aff_project_out_map(space.release(), static_cast<enum isl_dim_type>(type), first, n);\n  return manage(res);\n}\n\nmulti_aff multi_aff::pullback(multi_aff ma2) const\n{\n  auto res = isl_multi_aff_pullback_multi_aff(copy(), ma2.release());\n  return manage(res);\n}\n\nmulti_aff multi_aff::range_factor_domain() const\n{\n  auto res = isl_multi_aff_range_factor_domain(copy());\n  return manage(res);\n}\n\nmulti_aff multi_aff::range_factor_range() const\n{\n  auto res = isl_multi_aff_range_factor_range(copy());\n  return manage(res);\n}\n\nboolean multi_aff::range_is_wrapping() const\n{\n  auto res = isl_multi_aff_range_is_wrapping(get());\n  return manage(res);\n}\n\nmulti_aff multi_aff::range_map(space space)\n{\n  auto res = isl_multi_aff_range_map(space.release());\n  return manage(res);\n}\n\nmulti_aff multi_aff::range_product(multi_aff multi2) const\n{\n  auto res = isl_multi_aff_range_product(copy(), multi2.release());\n  return manage(res);\n}\n\nmulti_aff multi_aff::range_splice(unsigned int pos, multi_aff multi2) const\n{\n  auto res = isl_multi_aff_range_splice(copy(), pos, multi2.release());\n  return manage(res);\n}\n\nmulti_aff multi_aff::reset_tuple_id(isl::dim type) const\n{\n  auto res = isl_multi_aff_reset_tuple_id(copy(), static_cast<enum isl_dim_type>(type));\n  return manage(res);\n}\n\nmulti_aff multi_aff::reset_user() const\n{\n  auto res = isl_multi_aff_reset_user(copy());\n  return manage(res);\n}\n\nmulti_aff multi_aff::scale(multi_val mv) const\n{\n  auto res = isl_multi_aff_scale_multi_val(copy(), mv.release());\n  return manage(res);\n}\n\nmulti_aff multi_aff::scale(val v) const\n{\n  auto res = isl_multi_aff_scale_val(copy(), v.release());\n  return manage(res);\n}\n\nmulti_aff multi_aff::scale_down(multi_val mv) const\n{\n  auto res = isl_multi_aff_scale_down_multi_val(copy(), mv.release());\n  return manage(res);\n}\n\nmulti_aff multi_aff::scale_down(val v) const\n{\n  auto res = isl_multi_aff_scale_down_val(copy(), v.release());\n  return manage(res);\n}\n\nmulti_aff multi_aff::set_aff(int pos, aff el) const\n{\n  auto res = isl_multi_aff_set_aff(copy(), pos, el.release());\n  return manage(res);\n}\n\nmulti_aff multi_aff::set_at(int pos, aff el) const\n{\n  auto res = isl_multi_aff_set_at(copy(), pos, el.release());\n  return manage(res);\n}\n\nmulti_aff multi_aff::set_dim_id(isl::dim type, unsigned int pos, id id) const\n{\n  auto res = isl_multi_aff_set_dim_id(copy(), static_cast<enum isl_dim_type>(type), pos, id.release());\n  return manage(res);\n}\n\nmulti_aff multi_aff::set_tuple_id(isl::dim type, id id) const\n{\n  auto res = isl_multi_aff_set_tuple_id(copy(), static_cast<enum isl_dim_type>(type), id.release());\n  return manage(res);\n}\n\nmulti_aff multi_aff::set_tuple_name(isl::dim type, const std::string &s) const\n{\n  auto res = isl_multi_aff_set_tuple_name(copy(), static_cast<enum isl_dim_type>(type), s.c_str());\n  return manage(res);\n}\n\nisl_size multi_aff::size() const\n{\n  auto res = isl_multi_aff_size(get());\n  return res;\n}\n\nmulti_aff multi_aff::splice(unsigned int in_pos, unsigned int out_pos, multi_aff multi2) const\n{\n  auto res = isl_multi_aff_splice(copy(), in_pos, out_pos, multi2.release());\n  return manage(res);\n}\n\nmulti_aff multi_aff::sub(multi_aff multi2) const\n{\n  auto res = isl_multi_aff_sub(copy(), multi2.release());\n  return manage(res);\n}\n\nmulti_aff multi_aff::unbind_params_insert_domain(multi_id domain) const\n{\n  auto res = isl_multi_aff_unbind_params_insert_domain(copy(), domain.release());\n  return manage(res);\n}\n\nmulti_aff multi_aff::zero(space space)\n{\n  auto res = isl_multi_aff_zero(space.release());\n  return manage(res);\n}\n\n// implementations for isl::multi_id\nmulti_id manage(__isl_take isl_multi_id *ptr) {\n  return multi_id(ptr);\n}\nmulti_id manage_copy(__isl_keep isl_multi_id *ptr) {\n  ptr = isl_multi_id_copy(ptr);\n  return multi_id(ptr);\n}\n\nmulti_id::multi_id()\n    : ptr(nullptr) {}\n\nmulti_id::multi_id(const multi_id &obj)\n    : ptr(nullptr)\n{\n  ptr = obj.copy();\n}\nmulti_id::multi_id(std::nullptr_t)\n    : ptr(nullptr) {}\n\n\nmulti_id::multi_id(__isl_take isl_multi_id *ptr)\n    : ptr(ptr) {}\n\nmulti_id::multi_id(space space, id_list list)\n{\n  auto res = isl_multi_id_from_id_list(space.release(), list.release());\n  ptr = res;\n}\nmulti_id::multi_id(ctx ctx, const std::string &str)\n{\n  auto res = isl_multi_id_read_from_str(ctx.release(), str.c_str());\n  ptr = res;\n}\n\nmulti_id &multi_id::operator=(multi_id obj) {\n  std::swap(this->ptr, obj.ptr);\n  return *this;\n}\n\nmulti_id::~multi_id() {\n  if (ptr)\n    isl_multi_id_free(ptr);\n}\n\n__isl_give isl_multi_id *multi_id::copy() const & {\n  return isl_multi_id_copy(ptr);\n}\n\n__isl_keep isl_multi_id *multi_id::get() const {\n  return ptr;\n}\n\n__isl_give isl_multi_id *multi_id::release() {\n  isl_multi_id *tmp = ptr;\n  ptr = nullptr;\n  return tmp;\n}\n\nbool multi_id::is_null() const {\n  return ptr == nullptr;\n}\nmulti_id::operator bool() const {\n  return !is_null();\n}\n\n\nctx multi_id::get_ctx() const {\n  return ctx(isl_multi_id_get_ctx(ptr));\n}\nstd::string multi_id::to_str() const {\n  char *Tmp = isl_multi_id_to_str(get());\n  if (!Tmp)\n    return \"\";\n  std::string S(Tmp);\n  free(Tmp);\n  return S;\n}\n\n\nvoid multi_id::dump() const {\n  isl_multi_id_dump(get());\n}\n\n\nmulti_id multi_id::align_params(space model) const\n{\n  auto res = isl_multi_id_align_params(copy(), model.release());\n  return manage(res);\n}\n\nmulti_id multi_id::factor_range() const\n{\n  auto res = isl_multi_id_factor_range(copy());\n  return manage(res);\n}\n\nmulti_id multi_id::flat_range_product(multi_id multi2) const\n{\n  auto res = isl_multi_id_flat_range_product(copy(), multi2.release());\n  return manage(res);\n}\n\nmulti_id multi_id::flatten_range() const\n{\n  auto res = isl_multi_id_flatten_range(copy());\n  return manage(res);\n}\n\nmulti_id multi_id::from_range() const\n{\n  auto res = isl_multi_id_from_range(copy());\n  return manage(res);\n}\n\nid multi_id::get_at(int pos) const\n{\n  auto res = isl_multi_id_get_at(get(), pos);\n  return manage(res);\n}\n\nspace multi_id::get_domain_space() const\n{\n  auto res = isl_multi_id_get_domain_space(get());\n  return manage(res);\n}\n\nid multi_id::get_id(int pos) const\n{\n  auto res = isl_multi_id_get_id(get(), pos);\n  return manage(res);\n}\n\nid_list multi_id::get_list() const\n{\n  auto res = isl_multi_id_get_list(get());\n  return manage(res);\n}\n\nspace multi_id::get_space() const\n{\n  auto res = isl_multi_id_get_space(get());\n  return manage(res);\n}\n\nboolean multi_id::plain_is_equal(const multi_id &multi2) const\n{\n  auto res = isl_multi_id_plain_is_equal(get(), multi2.get());\n  return manage(res);\n}\n\nmulti_id multi_id::range_factor_domain() const\n{\n  auto res = isl_multi_id_range_factor_domain(copy());\n  return manage(res);\n}\n\nmulti_id multi_id::range_factor_range() const\n{\n  auto res = isl_multi_id_range_factor_range(copy());\n  return manage(res);\n}\n\nboolean multi_id::range_is_wrapping() const\n{\n  auto res = isl_multi_id_range_is_wrapping(get());\n  return manage(res);\n}\n\nmulti_id multi_id::range_product(multi_id multi2) const\n{\n  auto res = isl_multi_id_range_product(copy(), multi2.release());\n  return manage(res);\n}\n\nmulti_id multi_id::range_splice(unsigned int pos, multi_id multi2) const\n{\n  auto res = isl_multi_id_range_splice(copy(), pos, multi2.release());\n  return manage(res);\n}\n\nmulti_id multi_id::reset_user() const\n{\n  auto res = isl_multi_id_reset_user(copy());\n  return manage(res);\n}\n\nmulti_id multi_id::set_at(int pos, id el) const\n{\n  auto res = isl_multi_id_set_at(copy(), pos, el.release());\n  return manage(res);\n}\n\nmulti_id multi_id::set_id(int pos, id el) const\n{\n  auto res = isl_multi_id_set_id(copy(), pos, el.release());\n  return manage(res);\n}\n\nisl_size multi_id::size() const\n{\n  auto res = isl_multi_id_size(get());\n  return res;\n}\n\n// implementations for isl::multi_pw_aff\nmulti_pw_aff manage(__isl_take isl_multi_pw_aff *ptr) {\n  return multi_pw_aff(ptr);\n}\nmulti_pw_aff manage_copy(__isl_keep isl_multi_pw_aff *ptr) {\n  ptr = isl_multi_pw_aff_copy(ptr);\n  return multi_pw_aff(ptr);\n}\n\nmulti_pw_aff::multi_pw_aff()\n    : ptr(nullptr) {}\n\nmulti_pw_aff::multi_pw_aff(const multi_pw_aff &obj)\n    : ptr(nullptr)\n{\n  ptr = obj.copy();\n}\nmulti_pw_aff::multi_pw_aff(std::nullptr_t)\n    : ptr(nullptr) {}\n\n\nmulti_pw_aff::multi_pw_aff(__isl_take isl_multi_pw_aff *ptr)\n    : ptr(ptr) {}\n\nmulti_pw_aff::multi_pw_aff(aff aff)\n{\n  auto res = isl_multi_pw_aff_from_aff(aff.release());\n  ptr = res;\n}\nmulti_pw_aff::multi_pw_aff(multi_aff ma)\n{\n  auto res = isl_multi_pw_aff_from_multi_aff(ma.release());\n  ptr = res;\n}\nmulti_pw_aff::multi_pw_aff(pw_aff pa)\n{\n  auto res = isl_multi_pw_aff_from_pw_aff(pa.release());\n  ptr = res;\n}\nmulti_pw_aff::multi_pw_aff(space space, pw_aff_list list)\n{\n  auto res = isl_multi_pw_aff_from_pw_aff_list(space.release(), list.release());\n  ptr = res;\n}\nmulti_pw_aff::multi_pw_aff(pw_multi_aff pma)\n{\n  auto res = isl_multi_pw_aff_from_pw_multi_aff(pma.release());\n  ptr = res;\n}\nmulti_pw_aff::multi_pw_aff(ctx ctx, const std::string &str)\n{\n  auto res = isl_multi_pw_aff_read_from_str(ctx.release(), str.c_str());\n  ptr = res;\n}\n\nmulti_pw_aff &multi_pw_aff::operator=(multi_pw_aff obj) {\n  std::swap(this->ptr, obj.ptr);\n  return *this;\n}\n\nmulti_pw_aff::~multi_pw_aff() {\n  if (ptr)\n    isl_multi_pw_aff_free(ptr);\n}\n\n__isl_give isl_multi_pw_aff *multi_pw_aff::copy() const & {\n  return isl_multi_pw_aff_copy(ptr);\n}\n\n__isl_keep isl_multi_pw_aff *multi_pw_aff::get() const {\n  return ptr;\n}\n\n__isl_give isl_multi_pw_aff *multi_pw_aff::release() {\n  isl_multi_pw_aff *tmp = ptr;\n  ptr = nullptr;\n  return tmp;\n}\n\nbool multi_pw_aff::is_null() const {\n  return ptr == nullptr;\n}\nmulti_pw_aff::operator bool() const {\n  return !is_null();\n}\n\n\nctx multi_pw_aff::get_ctx() const {\n  return ctx(isl_multi_pw_aff_get_ctx(ptr));\n}\nstd::string multi_pw_aff::to_str() const {\n  char *Tmp = isl_multi_pw_aff_to_str(get());\n  if (!Tmp)\n    return \"\";\n  std::string S(Tmp);\n  free(Tmp);\n  return S;\n}\n\n\nvoid multi_pw_aff::dump() const {\n  isl_multi_pw_aff_dump(get());\n}\n\n\nmulti_pw_aff multi_pw_aff::add(multi_pw_aff multi2) const\n{\n  auto res = isl_multi_pw_aff_add(copy(), multi2.release());\n  return manage(res);\n}\n\nmulti_pw_aff multi_pw_aff::add_constant(multi_val mv) const\n{\n  auto res = isl_multi_pw_aff_add_constant_multi_val(copy(), mv.release());\n  return manage(res);\n}\n\nmulti_pw_aff multi_pw_aff::add_constant(val v) const\n{\n  auto res = isl_multi_pw_aff_add_constant_val(copy(), v.release());\n  return manage(res);\n}\n\nmulti_pw_aff multi_pw_aff::add_dims(isl::dim type, unsigned int n) const\n{\n  auto res = isl_multi_pw_aff_add_dims(copy(), static_cast<enum isl_dim_type>(type), n);\n  return manage(res);\n}\n\nmulti_pw_aff multi_pw_aff::align_params(space model) const\n{\n  auto res = isl_multi_pw_aff_align_params(copy(), model.release());\n  return manage(res);\n}\n\nset multi_pw_aff::bind(multi_id tuple) const\n{\n  auto res = isl_multi_pw_aff_bind(copy(), tuple.release());\n  return manage(res);\n}\n\nmulti_pw_aff multi_pw_aff::bind_domain(multi_id tuple) const\n{\n  auto res = isl_multi_pw_aff_bind_domain(copy(), tuple.release());\n  return manage(res);\n}\n\nmulti_pw_aff multi_pw_aff::bind_domain_wrapped_domain(multi_id tuple) const\n{\n  auto res = isl_multi_pw_aff_bind_domain_wrapped_domain(copy(), tuple.release());\n  return manage(res);\n}\n\nmulti_pw_aff multi_pw_aff::coalesce() const\n{\n  auto res = isl_multi_pw_aff_coalesce(copy());\n  return manage(res);\n}\n\nisl_size multi_pw_aff::dim(isl::dim type) const\n{\n  auto res = isl_multi_pw_aff_dim(get(), static_cast<enum isl_dim_type>(type));\n  return res;\n}\n\nset multi_pw_aff::domain() const\n{\n  auto res = isl_multi_pw_aff_domain(copy());\n  return manage(res);\n}\n\nmulti_pw_aff multi_pw_aff::drop_dims(isl::dim type, unsigned int first, unsigned int n) const\n{\n  auto res = isl_multi_pw_aff_drop_dims(copy(), static_cast<enum isl_dim_type>(type), first, n);\n  return manage(res);\n}\n\nmap multi_pw_aff::eq_map(multi_pw_aff mpa2) const\n{\n  auto res = isl_multi_pw_aff_eq_map(copy(), mpa2.release());\n  return manage(res);\n}\n\nmulti_pw_aff multi_pw_aff::factor_range() const\n{\n  auto res = isl_multi_pw_aff_factor_range(copy());\n  return manage(res);\n}\n\nint multi_pw_aff::find_dim_by_id(isl::dim type, const id &id) const\n{\n  auto res = isl_multi_pw_aff_find_dim_by_id(get(), static_cast<enum isl_dim_type>(type), id.get());\n  return res;\n}\n\nint multi_pw_aff::find_dim_by_name(isl::dim type, const std::string &name) const\n{\n  auto res = isl_multi_pw_aff_find_dim_by_name(get(), static_cast<enum isl_dim_type>(type), name.c_str());\n  return res;\n}\n\nmulti_pw_aff multi_pw_aff::flat_range_product(multi_pw_aff multi2) const\n{\n  auto res = isl_multi_pw_aff_flat_range_product(copy(), multi2.release());\n  return manage(res);\n}\n\nmulti_pw_aff multi_pw_aff::flatten_range() const\n{\n  auto res = isl_multi_pw_aff_flatten_range(copy());\n  return manage(res);\n}\n\nmulti_pw_aff multi_pw_aff::from_range() const\n{\n  auto res = isl_multi_pw_aff_from_range(copy());\n  return manage(res);\n}\n\npw_aff multi_pw_aff::get_at(int pos) const\n{\n  auto res = isl_multi_pw_aff_get_at(get(), pos);\n  return manage(res);\n}\n\nid multi_pw_aff::get_dim_id(isl::dim type, unsigned int pos) const\n{\n  auto res = isl_multi_pw_aff_get_dim_id(get(), static_cast<enum isl_dim_type>(type), pos);\n  return manage(res);\n}\n\nspace multi_pw_aff::get_domain_space() const\n{\n  auto res = isl_multi_pw_aff_get_domain_space(get());\n  return manage(res);\n}\n\nuint32_t multi_pw_aff::get_hash() const\n{\n  auto res = isl_multi_pw_aff_get_hash(get());\n  return res;\n}\n\npw_aff_list multi_pw_aff::get_list() const\n{\n  auto res = isl_multi_pw_aff_get_list(get());\n  return manage(res);\n}\n\npw_aff multi_pw_aff::get_pw_aff(int pos) const\n{\n  auto res = isl_multi_pw_aff_get_pw_aff(get(), pos);\n  return manage(res);\n}\n\nspace multi_pw_aff::get_space() const\n{\n  auto res = isl_multi_pw_aff_get_space(get());\n  return manage(res);\n}\n\nid multi_pw_aff::get_tuple_id(isl::dim type) const\n{\n  auto res = isl_multi_pw_aff_get_tuple_id(get(), static_cast<enum isl_dim_type>(type));\n  return manage(res);\n}\n\nstd::string multi_pw_aff::get_tuple_name(isl::dim type) const\n{\n  auto res = isl_multi_pw_aff_get_tuple_name(get(), static_cast<enum isl_dim_type>(type));\n  std::string tmp(res);\n  return tmp;\n}\n\nmulti_pw_aff multi_pw_aff::gist(set set) const\n{\n  auto res = isl_multi_pw_aff_gist(copy(), set.release());\n  return manage(res);\n}\n\nmulti_pw_aff multi_pw_aff::gist_params(set set) const\n{\n  auto res = isl_multi_pw_aff_gist_params(copy(), set.release());\n  return manage(res);\n}\n\nboolean multi_pw_aff::has_tuple_id(isl::dim type) const\n{\n  auto res = isl_multi_pw_aff_has_tuple_id(get(), static_cast<enum isl_dim_type>(type));\n  return manage(res);\n}\n\nmulti_pw_aff multi_pw_aff::identity(space space)\n{\n  auto res = isl_multi_pw_aff_identity(space.release());\n  return manage(res);\n}\n\nmulti_pw_aff multi_pw_aff::identity() const\n{\n  auto res = isl_multi_pw_aff_identity_multi_pw_aff(copy());\n  return manage(res);\n}\n\nmulti_pw_aff multi_pw_aff::identity_on_domain(space space)\n{\n  auto res = isl_multi_pw_aff_identity_on_domain_space(space.release());\n  return manage(res);\n}\n\nmulti_pw_aff multi_pw_aff::insert_dims(isl::dim type, unsigned int first, unsigned int n) const\n{\n  auto res = isl_multi_pw_aff_insert_dims(copy(), static_cast<enum isl_dim_type>(type), first, n);\n  return manage(res);\n}\n\nmulti_pw_aff multi_pw_aff::insert_domain(space domain) const\n{\n  auto res = isl_multi_pw_aff_insert_domain(copy(), domain.release());\n  return manage(res);\n}\n\nmulti_pw_aff multi_pw_aff::intersect_domain(set domain) const\n{\n  auto res = isl_multi_pw_aff_intersect_domain(copy(), domain.release());\n  return manage(res);\n}\n\nmulti_pw_aff multi_pw_aff::intersect_params(set set) const\n{\n  auto res = isl_multi_pw_aff_intersect_params(copy(), set.release());\n  return manage(res);\n}\n\nboolean multi_pw_aff::involves_dims(isl::dim type, unsigned int first, unsigned int n) const\n{\n  auto res = isl_multi_pw_aff_involves_dims(get(), static_cast<enum isl_dim_type>(type), first, n);\n  return manage(res);\n}\n\nboolean multi_pw_aff::involves_nan() const\n{\n  auto res = isl_multi_pw_aff_involves_nan(get());\n  return manage(res);\n}\n\nboolean multi_pw_aff::involves_param(const id &id) const\n{\n  auto res = isl_multi_pw_aff_involves_param_id(get(), id.get());\n  return manage(res);\n}\n\nboolean multi_pw_aff::involves_param(const id_list &list) const\n{\n  auto res = isl_multi_pw_aff_involves_param_id_list(get(), list.get());\n  return manage(res);\n}\n\nboolean multi_pw_aff::is_cst() const\n{\n  auto res = isl_multi_pw_aff_is_cst(get());\n  return manage(res);\n}\n\nboolean multi_pw_aff::is_equal(const multi_pw_aff &mpa2) const\n{\n  auto res = isl_multi_pw_aff_is_equal(get(), mpa2.get());\n  return manage(res);\n}\n\nmap multi_pw_aff::lex_ge_map(multi_pw_aff mpa2) const\n{\n  auto res = isl_multi_pw_aff_lex_ge_map(copy(), mpa2.release());\n  return manage(res);\n}\n\nmap multi_pw_aff::lex_gt_map(multi_pw_aff mpa2) const\n{\n  auto res = isl_multi_pw_aff_lex_gt_map(copy(), mpa2.release());\n  return manage(res);\n}\n\nmap multi_pw_aff::lex_le_map(multi_pw_aff mpa2) const\n{\n  auto res = isl_multi_pw_aff_lex_le_map(copy(), mpa2.release());\n  return manage(res);\n}\n\nmap multi_pw_aff::lex_lt_map(multi_pw_aff mpa2) const\n{\n  auto res = isl_multi_pw_aff_lex_lt_map(copy(), mpa2.release());\n  return manage(res);\n}\n\nmulti_pw_aff multi_pw_aff::max(multi_pw_aff multi2) const\n{\n  auto res = isl_multi_pw_aff_max(copy(), multi2.release());\n  return manage(res);\n}\n\nmulti_val multi_pw_aff::max_multi_val() const\n{\n  auto res = isl_multi_pw_aff_max_multi_val(copy());\n  return manage(res);\n}\n\nmulti_pw_aff multi_pw_aff::min(multi_pw_aff multi2) const\n{\n  auto res = isl_multi_pw_aff_min(copy(), multi2.release());\n  return manage(res);\n}\n\nmulti_val multi_pw_aff::min_multi_val() const\n{\n  auto res = isl_multi_pw_aff_min_multi_val(copy());\n  return manage(res);\n}\n\nmulti_pw_aff multi_pw_aff::mod_multi_val(multi_val mv) const\n{\n  auto res = isl_multi_pw_aff_mod_multi_val(copy(), mv.release());\n  return manage(res);\n}\n\nmulti_pw_aff multi_pw_aff::move_dims(isl::dim dst_type, unsigned int dst_pos, isl::dim src_type, unsigned int src_pos, unsigned int n) const\n{\n  auto res = isl_multi_pw_aff_move_dims(copy(), static_cast<enum isl_dim_type>(dst_type), dst_pos, static_cast<enum isl_dim_type>(src_type), src_pos, n);\n  return manage(res);\n}\n\nmulti_pw_aff multi_pw_aff::neg() const\n{\n  auto res = isl_multi_pw_aff_neg(copy());\n  return manage(res);\n}\n\nboolean multi_pw_aff::plain_is_equal(const multi_pw_aff &multi2) const\n{\n  auto res = isl_multi_pw_aff_plain_is_equal(get(), multi2.get());\n  return manage(res);\n}\n\nmulti_pw_aff multi_pw_aff::product(multi_pw_aff multi2) const\n{\n  auto res = isl_multi_pw_aff_product(copy(), multi2.release());\n  return manage(res);\n}\n\nmulti_pw_aff multi_pw_aff::project_domain_on_params() const\n{\n  auto res = isl_multi_pw_aff_project_domain_on_params(copy());\n  return manage(res);\n}\n\nmulti_pw_aff multi_pw_aff::pullback(multi_aff ma) const\n{\n  auto res = isl_multi_pw_aff_pullback_multi_aff(copy(), ma.release());\n  return manage(res);\n}\n\nmulti_pw_aff multi_pw_aff::pullback(multi_pw_aff mpa2) const\n{\n  auto res = isl_multi_pw_aff_pullback_multi_pw_aff(copy(), mpa2.release());\n  return manage(res);\n}\n\nmulti_pw_aff multi_pw_aff::pullback(pw_multi_aff pma) const\n{\n  auto res = isl_multi_pw_aff_pullback_pw_multi_aff(copy(), pma.release());\n  return manage(res);\n}\n\nmulti_pw_aff multi_pw_aff::range_factor_domain() const\n{\n  auto res = isl_multi_pw_aff_range_factor_domain(copy());\n  return manage(res);\n}\n\nmulti_pw_aff multi_pw_aff::range_factor_range() const\n{\n  auto res = isl_multi_pw_aff_range_factor_range(copy());\n  return manage(res);\n}\n\nboolean multi_pw_aff::range_is_wrapping() const\n{\n  auto res = isl_multi_pw_aff_range_is_wrapping(get());\n  return manage(res);\n}\n\nmulti_pw_aff multi_pw_aff::range_product(multi_pw_aff multi2) const\n{\n  auto res = isl_multi_pw_aff_range_product(copy(), multi2.release());\n  return manage(res);\n}\n\nmulti_pw_aff multi_pw_aff::range_splice(unsigned int pos, multi_pw_aff multi2) const\n{\n  auto res = isl_multi_pw_aff_range_splice(copy(), pos, multi2.release());\n  return manage(res);\n}\n\nmulti_pw_aff multi_pw_aff::reset_tuple_id(isl::dim type) const\n{\n  auto res = isl_multi_pw_aff_reset_tuple_id(copy(), static_cast<enum isl_dim_type>(type));\n  return manage(res);\n}\n\nmulti_pw_aff multi_pw_aff::reset_user() const\n{\n  auto res = isl_multi_pw_aff_reset_user(copy());\n  return manage(res);\n}\n\nmulti_pw_aff multi_pw_aff::scale(multi_val mv) const\n{\n  auto res = isl_multi_pw_aff_scale_multi_val(copy(), mv.release());\n  return manage(res);\n}\n\nmulti_pw_aff multi_pw_aff::scale(val v) const\n{\n  auto res = isl_multi_pw_aff_scale_val(copy(), v.release());\n  return manage(res);\n}\n\nmulti_pw_aff multi_pw_aff::scale_down(multi_val mv) const\n{\n  auto res = isl_multi_pw_aff_scale_down_multi_val(copy(), mv.release());\n  return manage(res);\n}\n\nmulti_pw_aff multi_pw_aff::scale_down(val v) const\n{\n  auto res = isl_multi_pw_aff_scale_down_val(copy(), v.release());\n  return manage(res);\n}\n\nmulti_pw_aff multi_pw_aff::set_at(int pos, pw_aff el) const\n{\n  auto res = isl_multi_pw_aff_set_at(copy(), pos, el.release());\n  return manage(res);\n}\n\nmulti_pw_aff multi_pw_aff::set_dim_id(isl::dim type, unsigned int pos, id id) const\n{\n  auto res = isl_multi_pw_aff_set_dim_id(copy(), static_cast<enum isl_dim_type>(type), pos, id.release());\n  return manage(res);\n}\n\nmulti_pw_aff multi_pw_aff::set_pw_aff(int pos, pw_aff el) const\n{\n  auto res = isl_multi_pw_aff_set_pw_aff(copy(), pos, el.release());\n  return manage(res);\n}\n\nmulti_pw_aff multi_pw_aff::set_tuple_id(isl::dim type, id id) const\n{\n  auto res = isl_multi_pw_aff_set_tuple_id(copy(), static_cast<enum isl_dim_type>(type), id.release());\n  return manage(res);\n}\n\nmulti_pw_aff multi_pw_aff::set_tuple_name(isl::dim type, const std::string &s) const\n{\n  auto res = isl_multi_pw_aff_set_tuple_name(copy(), static_cast<enum isl_dim_type>(type), s.c_str());\n  return manage(res);\n}\n\nisl_size multi_pw_aff::size() const\n{\n  auto res = isl_multi_pw_aff_size(get());\n  return res;\n}\n\nmulti_pw_aff multi_pw_aff::splice(unsigned int in_pos, unsigned int out_pos, multi_pw_aff multi2) const\n{\n  auto res = isl_multi_pw_aff_splice(copy(), in_pos, out_pos, multi2.release());\n  return manage(res);\n}\n\nmulti_pw_aff multi_pw_aff::sub(multi_pw_aff multi2) const\n{\n  auto res = isl_multi_pw_aff_sub(copy(), multi2.release());\n  return manage(res);\n}\n\nmulti_pw_aff multi_pw_aff::unbind_params_insert_domain(multi_id domain) const\n{\n  auto res = isl_multi_pw_aff_unbind_params_insert_domain(copy(), domain.release());\n  return manage(res);\n}\n\nmulti_pw_aff multi_pw_aff::union_add(multi_pw_aff mpa2) const\n{\n  auto res = isl_multi_pw_aff_union_add(copy(), mpa2.release());\n  return manage(res);\n}\n\nmulti_pw_aff multi_pw_aff::zero(space space)\n{\n  auto res = isl_multi_pw_aff_zero(space.release());\n  return manage(res);\n}\n\n// implementations for isl::multi_union_pw_aff\nmulti_union_pw_aff manage(__isl_take isl_multi_union_pw_aff *ptr) {\n  return multi_union_pw_aff(ptr);\n}\nmulti_union_pw_aff manage_copy(__isl_keep isl_multi_union_pw_aff *ptr) {\n  ptr = isl_multi_union_pw_aff_copy(ptr);\n  return multi_union_pw_aff(ptr);\n}\n\nmulti_union_pw_aff::multi_union_pw_aff()\n    : ptr(nullptr) {}\n\nmulti_union_pw_aff::multi_union_pw_aff(const multi_union_pw_aff &obj)\n    : ptr(nullptr)\n{\n  ptr = obj.copy();\n}\nmulti_union_pw_aff::multi_union_pw_aff(std::nullptr_t)\n    : ptr(nullptr) {}\n\n\nmulti_union_pw_aff::multi_union_pw_aff(__isl_take isl_multi_union_pw_aff *ptr)\n    : ptr(ptr) {}\n\nmulti_union_pw_aff::multi_union_pw_aff(multi_pw_aff mpa)\n{\n  auto res = isl_multi_union_pw_aff_from_multi_pw_aff(mpa.release());\n  ptr = res;\n}\nmulti_union_pw_aff::multi_union_pw_aff(union_pw_aff upa)\n{\n  auto res = isl_multi_union_pw_aff_from_union_pw_aff(upa.release());\n  ptr = res;\n}\nmulti_union_pw_aff::multi_union_pw_aff(space space, union_pw_aff_list list)\n{\n  auto res = isl_multi_union_pw_aff_from_union_pw_aff_list(space.release(), list.release());\n  ptr = res;\n}\nmulti_union_pw_aff::multi_union_pw_aff(union_pw_multi_aff upma)\n{\n  auto res = isl_multi_union_pw_aff_from_union_pw_multi_aff(upma.release());\n  ptr = res;\n}\nmulti_union_pw_aff::multi_union_pw_aff(ctx ctx, const std::string &str)\n{\n  auto res = isl_multi_union_pw_aff_read_from_str(ctx.release(), str.c_str());\n  ptr = res;\n}\n\nmulti_union_pw_aff &multi_union_pw_aff::operator=(multi_union_pw_aff obj) {\n  std::swap(this->ptr, obj.ptr);\n  return *this;\n}\n\nmulti_union_pw_aff::~multi_union_pw_aff() {\n  if (ptr)\n    isl_multi_union_pw_aff_free(ptr);\n}\n\n__isl_give isl_multi_union_pw_aff *multi_union_pw_aff::copy() const & {\n  return isl_multi_union_pw_aff_copy(ptr);\n}\n\n__isl_keep isl_multi_union_pw_aff *multi_union_pw_aff::get() const {\n  return ptr;\n}\n\n__isl_give isl_multi_union_pw_aff *multi_union_pw_aff::release() {\n  isl_multi_union_pw_aff *tmp = ptr;\n  ptr = nullptr;\n  return tmp;\n}\n\nbool multi_union_pw_aff::is_null() const {\n  return ptr == nullptr;\n}\nmulti_union_pw_aff::operator bool() const {\n  return !is_null();\n}\n\n\nctx multi_union_pw_aff::get_ctx() const {\n  return ctx(isl_multi_union_pw_aff_get_ctx(ptr));\n}\nstd::string multi_union_pw_aff::to_str() const {\n  char *Tmp = isl_multi_union_pw_aff_to_str(get());\n  if (!Tmp)\n    return \"\";\n  std::string S(Tmp);\n  free(Tmp);\n  return S;\n}\n\n\nvoid multi_union_pw_aff::dump() const {\n  isl_multi_union_pw_aff_dump(get());\n}\n\n\nmulti_union_pw_aff multi_union_pw_aff::add(multi_union_pw_aff multi2) const\n{\n  auto res = isl_multi_union_pw_aff_add(copy(), multi2.release());\n  return manage(res);\n}\n\nmulti_union_pw_aff multi_union_pw_aff::align_params(space model) const\n{\n  auto res = isl_multi_union_pw_aff_align_params(copy(), model.release());\n  return manage(res);\n}\n\nunion_pw_aff multi_union_pw_aff::apply_aff(aff aff) const\n{\n  auto res = isl_multi_union_pw_aff_apply_aff(copy(), aff.release());\n  return manage(res);\n}\n\nunion_pw_aff multi_union_pw_aff::apply_pw_aff(pw_aff pa) const\n{\n  auto res = isl_multi_union_pw_aff_apply_pw_aff(copy(), pa.release());\n  return manage(res);\n}\n\nmulti_union_pw_aff multi_union_pw_aff::apply_pw_multi_aff(pw_multi_aff pma) const\n{\n  auto res = isl_multi_union_pw_aff_apply_pw_multi_aff(copy(), pma.release());\n  return manage(res);\n}\n\nunion_set multi_union_pw_aff::bind(multi_id tuple) const\n{\n  auto res = isl_multi_union_pw_aff_bind(copy(), tuple.release());\n  return manage(res);\n}\n\nmulti_union_pw_aff multi_union_pw_aff::coalesce() const\n{\n  auto res = isl_multi_union_pw_aff_coalesce(copy());\n  return manage(res);\n}\n\nisl_size multi_union_pw_aff::dim(isl::dim type) const\n{\n  auto res = isl_multi_union_pw_aff_dim(get(), static_cast<enum isl_dim_type>(type));\n  return res;\n}\n\nunion_set multi_union_pw_aff::domain() const\n{\n  auto res = isl_multi_union_pw_aff_domain(copy());\n  return manage(res);\n}\n\nmulti_union_pw_aff multi_union_pw_aff::drop_dims(isl::dim type, unsigned int first, unsigned int n) const\n{\n  auto res = isl_multi_union_pw_aff_drop_dims(copy(), static_cast<enum isl_dim_type>(type), first, n);\n  return manage(res);\n}\n\nmulti_pw_aff multi_union_pw_aff::extract_multi_pw_aff(space space) const\n{\n  auto res = isl_multi_union_pw_aff_extract_multi_pw_aff(get(), space.release());\n  return manage(res);\n}\n\nmulti_union_pw_aff multi_union_pw_aff::factor_range() const\n{\n  auto res = isl_multi_union_pw_aff_factor_range(copy());\n  return manage(res);\n}\n\nint multi_union_pw_aff::find_dim_by_id(isl::dim type, const id &id) const\n{\n  auto res = isl_multi_union_pw_aff_find_dim_by_id(get(), static_cast<enum isl_dim_type>(type), id.get());\n  return res;\n}\n\nint multi_union_pw_aff::find_dim_by_name(isl::dim type, const std::string &name) const\n{\n  auto res = isl_multi_union_pw_aff_find_dim_by_name(get(), static_cast<enum isl_dim_type>(type), name.c_str());\n  return res;\n}\n\nmulti_union_pw_aff multi_union_pw_aff::flat_range_product(multi_union_pw_aff multi2) const\n{\n  auto res = isl_multi_union_pw_aff_flat_range_product(copy(), multi2.release());\n  return manage(res);\n}\n\nmulti_union_pw_aff multi_union_pw_aff::flatten_range() const\n{\n  auto res = isl_multi_union_pw_aff_flatten_range(copy());\n  return manage(res);\n}\n\nmulti_union_pw_aff multi_union_pw_aff::floor() const\n{\n  auto res = isl_multi_union_pw_aff_floor(copy());\n  return manage(res);\n}\n\nmulti_union_pw_aff multi_union_pw_aff::from_multi_aff(multi_aff ma)\n{\n  auto res = isl_multi_union_pw_aff_from_multi_aff(ma.release());\n  return manage(res);\n}\n\nmulti_union_pw_aff multi_union_pw_aff::from_range() const\n{\n  auto res = isl_multi_union_pw_aff_from_range(copy());\n  return manage(res);\n}\n\nmulti_union_pw_aff multi_union_pw_aff::from_union_map(union_map umap)\n{\n  auto res = isl_multi_union_pw_aff_from_union_map(umap.release());\n  return manage(res);\n}\n\nunion_pw_aff multi_union_pw_aff::get_at(int pos) const\n{\n  auto res = isl_multi_union_pw_aff_get_at(get(), pos);\n  return manage(res);\n}\n\nid multi_union_pw_aff::get_dim_id(isl::dim type, unsigned int pos) const\n{\n  auto res = isl_multi_union_pw_aff_get_dim_id(get(), static_cast<enum isl_dim_type>(type), pos);\n  return manage(res);\n}\n\nspace multi_union_pw_aff::get_domain_space() const\n{\n  auto res = isl_multi_union_pw_aff_get_domain_space(get());\n  return manage(res);\n}\n\nunion_pw_aff_list multi_union_pw_aff::get_list() const\n{\n  auto res = isl_multi_union_pw_aff_get_list(get());\n  return manage(res);\n}\n\nspace multi_union_pw_aff::get_space() const\n{\n  auto res = isl_multi_union_pw_aff_get_space(get());\n  return manage(res);\n}\n\nid multi_union_pw_aff::get_tuple_id(isl::dim type) const\n{\n  auto res = isl_multi_union_pw_aff_get_tuple_id(get(), static_cast<enum isl_dim_type>(type));\n  return manage(res);\n}\n\nstd::string multi_union_pw_aff::get_tuple_name(isl::dim type) const\n{\n  auto res = isl_multi_union_pw_aff_get_tuple_name(get(), static_cast<enum isl_dim_type>(type));\n  std::string tmp(res);\n  return tmp;\n}\n\nunion_pw_aff multi_union_pw_aff::get_union_pw_aff(int pos) const\n{\n  auto res = isl_multi_union_pw_aff_get_union_pw_aff(get(), pos);\n  return manage(res);\n}\n\nmulti_union_pw_aff multi_union_pw_aff::gist(union_set context) const\n{\n  auto res = isl_multi_union_pw_aff_gist(copy(), context.release());\n  return manage(res);\n}\n\nmulti_union_pw_aff multi_union_pw_aff::gist_params(set context) const\n{\n  auto res = isl_multi_union_pw_aff_gist_params(copy(), context.release());\n  return manage(res);\n}\n\nboolean multi_union_pw_aff::has_tuple_id(isl::dim type) const\n{\n  auto res = isl_multi_union_pw_aff_has_tuple_id(get(), static_cast<enum isl_dim_type>(type));\n  return manage(res);\n}\n\nmulti_union_pw_aff multi_union_pw_aff::intersect_domain(union_set uset) const\n{\n  auto res = isl_multi_union_pw_aff_intersect_domain(copy(), uset.release());\n  return manage(res);\n}\n\nmulti_union_pw_aff multi_union_pw_aff::intersect_params(set params) const\n{\n  auto res = isl_multi_union_pw_aff_intersect_params(copy(), params.release());\n  return manage(res);\n}\n\nmulti_union_pw_aff multi_union_pw_aff::intersect_range(set set) const\n{\n  auto res = isl_multi_union_pw_aff_intersect_range(copy(), set.release());\n  return manage(res);\n}\n\nboolean multi_union_pw_aff::involves_nan() const\n{\n  auto res = isl_multi_union_pw_aff_involves_nan(get());\n  return manage(res);\n}\n\nmulti_val multi_union_pw_aff::max_multi_val() const\n{\n  auto res = isl_multi_union_pw_aff_max_multi_val(copy());\n  return manage(res);\n}\n\nmulti_val multi_union_pw_aff::min_multi_val() const\n{\n  auto res = isl_multi_union_pw_aff_min_multi_val(copy());\n  return manage(res);\n}\n\nmulti_union_pw_aff multi_union_pw_aff::mod_multi_val(multi_val mv) const\n{\n  auto res = isl_multi_union_pw_aff_mod_multi_val(copy(), mv.release());\n  return manage(res);\n}\n\nmulti_union_pw_aff multi_union_pw_aff::multi_aff_on_domain(union_set domain, multi_aff ma)\n{\n  auto res = isl_multi_union_pw_aff_multi_aff_on_domain(domain.release(), ma.release());\n  return manage(res);\n}\n\nmulti_union_pw_aff multi_union_pw_aff::multi_val_on_domain(union_set domain, multi_val mv)\n{\n  auto res = isl_multi_union_pw_aff_multi_val_on_domain(domain.release(), mv.release());\n  return manage(res);\n}\n\nmulti_union_pw_aff multi_union_pw_aff::neg() const\n{\n  auto res = isl_multi_union_pw_aff_neg(copy());\n  return manage(res);\n}\n\nboolean multi_union_pw_aff::plain_is_equal(const multi_union_pw_aff &multi2) const\n{\n  auto res = isl_multi_union_pw_aff_plain_is_equal(get(), multi2.get());\n  return manage(res);\n}\n\nmulti_union_pw_aff multi_union_pw_aff::pullback(union_pw_multi_aff upma) const\n{\n  auto res = isl_multi_union_pw_aff_pullback_union_pw_multi_aff(copy(), upma.release());\n  return manage(res);\n}\n\nmulti_union_pw_aff multi_union_pw_aff::pw_multi_aff_on_domain(union_set domain, pw_multi_aff pma)\n{\n  auto res = isl_multi_union_pw_aff_pw_multi_aff_on_domain(domain.release(), pma.release());\n  return manage(res);\n}\n\nmulti_union_pw_aff multi_union_pw_aff::range_factor_domain() const\n{\n  auto res = isl_multi_union_pw_aff_range_factor_domain(copy());\n  return manage(res);\n}\n\nmulti_union_pw_aff multi_union_pw_aff::range_factor_range() const\n{\n  auto res = isl_multi_union_pw_aff_range_factor_range(copy());\n  return manage(res);\n}\n\nboolean multi_union_pw_aff::range_is_wrapping() const\n{\n  auto res = isl_multi_union_pw_aff_range_is_wrapping(get());\n  return manage(res);\n}\n\nmulti_union_pw_aff multi_union_pw_aff::range_product(multi_union_pw_aff multi2) const\n{\n  auto res = isl_multi_union_pw_aff_range_product(copy(), multi2.release());\n  return manage(res);\n}\n\nmulti_union_pw_aff multi_union_pw_aff::range_splice(unsigned int pos, multi_union_pw_aff multi2) const\n{\n  auto res = isl_multi_union_pw_aff_range_splice(copy(), pos, multi2.release());\n  return manage(res);\n}\n\nmulti_union_pw_aff multi_union_pw_aff::reset_tuple_id(isl::dim type) const\n{\n  auto res = isl_multi_union_pw_aff_reset_tuple_id(copy(), static_cast<enum isl_dim_type>(type));\n  return manage(res);\n}\n\nmulti_union_pw_aff multi_union_pw_aff::reset_user() const\n{\n  auto res = isl_multi_union_pw_aff_reset_user(copy());\n  return manage(res);\n}\n\nmulti_union_pw_aff multi_union_pw_aff::scale(multi_val mv) const\n{\n  auto res = isl_multi_union_pw_aff_scale_multi_val(copy(), mv.release());\n  return manage(res);\n}\n\nmulti_union_pw_aff multi_union_pw_aff::scale(val v) const\n{\n  auto res = isl_multi_union_pw_aff_scale_val(copy(), v.release());\n  return manage(res);\n}\n\nmulti_union_pw_aff multi_union_pw_aff::scale_down(multi_val mv) const\n{\n  auto res = isl_multi_union_pw_aff_scale_down_multi_val(copy(), mv.release());\n  return manage(res);\n}\n\nmulti_union_pw_aff multi_union_pw_aff::scale_down(val v) const\n{\n  auto res = isl_multi_union_pw_aff_scale_down_val(copy(), v.release());\n  return manage(res);\n}\n\nmulti_union_pw_aff multi_union_pw_aff::set_at(int pos, union_pw_aff el) const\n{\n  auto res = isl_multi_union_pw_aff_set_at(copy(), pos, el.release());\n  return manage(res);\n}\n\nmulti_union_pw_aff multi_union_pw_aff::set_dim_id(isl::dim type, unsigned int pos, id id) const\n{\n  auto res = isl_multi_union_pw_aff_set_dim_id(copy(), static_cast<enum isl_dim_type>(type), pos, id.release());\n  return manage(res);\n}\n\nmulti_union_pw_aff multi_union_pw_aff::set_tuple_id(isl::dim type, id id) const\n{\n  auto res = isl_multi_union_pw_aff_set_tuple_id(copy(), static_cast<enum isl_dim_type>(type), id.release());\n  return manage(res);\n}\n\nmulti_union_pw_aff multi_union_pw_aff::set_tuple_name(isl::dim type, const std::string &s) const\n{\n  auto res = isl_multi_union_pw_aff_set_tuple_name(copy(), static_cast<enum isl_dim_type>(type), s.c_str());\n  return manage(res);\n}\n\nmulti_union_pw_aff multi_union_pw_aff::set_union_pw_aff(int pos, union_pw_aff el) const\n{\n  auto res = isl_multi_union_pw_aff_set_union_pw_aff(copy(), pos, el.release());\n  return manage(res);\n}\n\nisl_size multi_union_pw_aff::size() const\n{\n  auto res = isl_multi_union_pw_aff_size(get());\n  return res;\n}\n\nmulti_union_pw_aff multi_union_pw_aff::sub(multi_union_pw_aff multi2) const\n{\n  auto res = isl_multi_union_pw_aff_sub(copy(), multi2.release());\n  return manage(res);\n}\n\nmulti_union_pw_aff multi_union_pw_aff::union_add(multi_union_pw_aff mupa2) const\n{\n  auto res = isl_multi_union_pw_aff_union_add(copy(), mupa2.release());\n  return manage(res);\n}\n\nmulti_union_pw_aff multi_union_pw_aff::zero(space space)\n{\n  auto res = isl_multi_union_pw_aff_zero(space.release());\n  return manage(res);\n}\n\nunion_set multi_union_pw_aff::zero_union_set() const\n{\n  auto res = isl_multi_union_pw_aff_zero_union_set(copy());\n  return manage(res);\n}\n\n// implementations for isl::multi_val\nmulti_val manage(__isl_take isl_multi_val *ptr) {\n  return multi_val(ptr);\n}\nmulti_val manage_copy(__isl_keep isl_multi_val *ptr) {\n  ptr = isl_multi_val_copy(ptr);\n  return multi_val(ptr);\n}\n\nmulti_val::multi_val()\n    : ptr(nullptr) {}\n\nmulti_val::multi_val(const multi_val &obj)\n    : ptr(nullptr)\n{\n  ptr = obj.copy();\n}\nmulti_val::multi_val(std::nullptr_t)\n    : ptr(nullptr) {}\n\n\nmulti_val::multi_val(__isl_take isl_multi_val *ptr)\n    : ptr(ptr) {}\n\nmulti_val::multi_val(space space, val_list list)\n{\n  auto res = isl_multi_val_from_val_list(space.release(), list.release());\n  ptr = res;\n}\nmulti_val::multi_val(ctx ctx, const std::string &str)\n{\n  auto res = isl_multi_val_read_from_str(ctx.release(), str.c_str());\n  ptr = res;\n}\n\nmulti_val &multi_val::operator=(multi_val obj) {\n  std::swap(this->ptr, obj.ptr);\n  return *this;\n}\n\nmulti_val::~multi_val() {\n  if (ptr)\n    isl_multi_val_free(ptr);\n}\n\n__isl_give isl_multi_val *multi_val::copy() const & {\n  return isl_multi_val_copy(ptr);\n}\n\n__isl_keep isl_multi_val *multi_val::get() const {\n  return ptr;\n}\n\n__isl_give isl_multi_val *multi_val::release() {\n  isl_multi_val *tmp = ptr;\n  ptr = nullptr;\n  return tmp;\n}\n\nbool multi_val::is_null() const {\n  return ptr == nullptr;\n}\nmulti_val::operator bool() const {\n  return !is_null();\n}\n\n\nctx multi_val::get_ctx() const {\n  return ctx(isl_multi_val_get_ctx(ptr));\n}\nstd::string multi_val::to_str() const {\n  char *Tmp = isl_multi_val_to_str(get());\n  if (!Tmp)\n    return \"\";\n  std::string S(Tmp);\n  free(Tmp);\n  return S;\n}\n\n\nvoid multi_val::dump() const {\n  isl_multi_val_dump(get());\n}\n\n\nmulti_val multi_val::add(multi_val multi2) const\n{\n  auto res = isl_multi_val_add(copy(), multi2.release());\n  return manage(res);\n}\n\nmulti_val multi_val::add(val v) const\n{\n  auto res = isl_multi_val_add_val(copy(), v.release());\n  return manage(res);\n}\n\nmulti_val multi_val::add_dims(isl::dim type, unsigned int n) const\n{\n  auto res = isl_multi_val_add_dims(copy(), static_cast<enum isl_dim_type>(type), n);\n  return manage(res);\n}\n\nmulti_val multi_val::align_params(space model) const\n{\n  auto res = isl_multi_val_align_params(copy(), model.release());\n  return manage(res);\n}\n\nisl_size multi_val::dim(isl::dim type) const\n{\n  auto res = isl_multi_val_dim(get(), static_cast<enum isl_dim_type>(type));\n  return res;\n}\n\nmulti_val multi_val::drop_dims(isl::dim type, unsigned int first, unsigned int n) const\n{\n  auto res = isl_multi_val_drop_dims(copy(), static_cast<enum isl_dim_type>(type), first, n);\n  return manage(res);\n}\n\nmulti_val multi_val::factor_range() const\n{\n  auto res = isl_multi_val_factor_range(copy());\n  return manage(res);\n}\n\nint multi_val::find_dim_by_id(isl::dim type, const id &id) const\n{\n  auto res = isl_multi_val_find_dim_by_id(get(), static_cast<enum isl_dim_type>(type), id.get());\n  return res;\n}\n\nint multi_val::find_dim_by_name(isl::dim type, const std::string &name) const\n{\n  auto res = isl_multi_val_find_dim_by_name(get(), static_cast<enum isl_dim_type>(type), name.c_str());\n  return res;\n}\n\nmulti_val multi_val::flat_range_product(multi_val multi2) const\n{\n  auto res = isl_multi_val_flat_range_product(copy(), multi2.release());\n  return manage(res);\n}\n\nmulti_val multi_val::flatten_range() const\n{\n  auto res = isl_multi_val_flatten_range(copy());\n  return manage(res);\n}\n\nmulti_val multi_val::from_range() const\n{\n  auto res = isl_multi_val_from_range(copy());\n  return manage(res);\n}\n\nval multi_val::get_at(int pos) const\n{\n  auto res = isl_multi_val_get_at(get(), pos);\n  return manage(res);\n}\n\nid multi_val::get_dim_id(isl::dim type, unsigned int pos) const\n{\n  auto res = isl_multi_val_get_dim_id(get(), static_cast<enum isl_dim_type>(type), pos);\n  return manage(res);\n}\n\nspace multi_val::get_domain_space() const\n{\n  auto res = isl_multi_val_get_domain_space(get());\n  return manage(res);\n}\n\nval_list multi_val::get_list() const\n{\n  auto res = isl_multi_val_get_list(get());\n  return manage(res);\n}\n\nspace multi_val::get_space() const\n{\n  auto res = isl_multi_val_get_space(get());\n  return manage(res);\n}\n\nid multi_val::get_tuple_id(isl::dim type) const\n{\n  auto res = isl_multi_val_get_tuple_id(get(), static_cast<enum isl_dim_type>(type));\n  return manage(res);\n}\n\nstd::string multi_val::get_tuple_name(isl::dim type) const\n{\n  auto res = isl_multi_val_get_tuple_name(get(), static_cast<enum isl_dim_type>(type));\n  std::string tmp(res);\n  return tmp;\n}\n\nval multi_val::get_val(int pos) const\n{\n  auto res = isl_multi_val_get_val(get(), pos);\n  return manage(res);\n}\n\nboolean multi_val::has_tuple_id(isl::dim type) const\n{\n  auto res = isl_multi_val_has_tuple_id(get(), static_cast<enum isl_dim_type>(type));\n  return manage(res);\n}\n\nmulti_val multi_val::insert_dims(isl::dim type, unsigned int first, unsigned int n) const\n{\n  auto res = isl_multi_val_insert_dims(copy(), static_cast<enum isl_dim_type>(type), first, n);\n  return manage(res);\n}\n\nboolean multi_val::involves_dims(isl::dim type, unsigned int first, unsigned int n) const\n{\n  auto res = isl_multi_val_involves_dims(get(), static_cast<enum isl_dim_type>(type), first, n);\n  return manage(res);\n}\n\nboolean multi_val::involves_nan() const\n{\n  auto res = isl_multi_val_involves_nan(get());\n  return manage(res);\n}\n\nboolean multi_val::is_zero() const\n{\n  auto res = isl_multi_val_is_zero(get());\n  return manage(res);\n}\n\nmulti_val multi_val::max(multi_val multi2) const\n{\n  auto res = isl_multi_val_max(copy(), multi2.release());\n  return manage(res);\n}\n\nmulti_val multi_val::min(multi_val multi2) const\n{\n  auto res = isl_multi_val_min(copy(), multi2.release());\n  return manage(res);\n}\n\nmulti_val multi_val::mod_multi_val(multi_val mv) const\n{\n  auto res = isl_multi_val_mod_multi_val(copy(), mv.release());\n  return manage(res);\n}\n\nmulti_val multi_val::mod_val(val v) const\n{\n  auto res = isl_multi_val_mod_val(copy(), v.release());\n  return manage(res);\n}\n\nmulti_val multi_val::neg() const\n{\n  auto res = isl_multi_val_neg(copy());\n  return manage(res);\n}\n\nboolean multi_val::plain_is_equal(const multi_val &multi2) const\n{\n  auto res = isl_multi_val_plain_is_equal(get(), multi2.get());\n  return manage(res);\n}\n\nmulti_val multi_val::product(multi_val multi2) const\n{\n  auto res = isl_multi_val_product(copy(), multi2.release());\n  return manage(res);\n}\n\nmulti_val multi_val::project_domain_on_params() const\n{\n  auto res = isl_multi_val_project_domain_on_params(copy());\n  return manage(res);\n}\n\nmulti_val multi_val::range_factor_domain() const\n{\n  auto res = isl_multi_val_range_factor_domain(copy());\n  return manage(res);\n}\n\nmulti_val multi_val::range_factor_range() const\n{\n  auto res = isl_multi_val_range_factor_range(copy());\n  return manage(res);\n}\n\nboolean multi_val::range_is_wrapping() const\n{\n  auto res = isl_multi_val_range_is_wrapping(get());\n  return manage(res);\n}\n\nmulti_val multi_val::range_product(multi_val multi2) const\n{\n  auto res = isl_multi_val_range_product(copy(), multi2.release());\n  return manage(res);\n}\n\nmulti_val multi_val::range_splice(unsigned int pos, multi_val multi2) const\n{\n  auto res = isl_multi_val_range_splice(copy(), pos, multi2.release());\n  return manage(res);\n}\n\nmulti_val multi_val::reset_tuple_id(isl::dim type) const\n{\n  auto res = isl_multi_val_reset_tuple_id(copy(), static_cast<enum isl_dim_type>(type));\n  return manage(res);\n}\n\nmulti_val multi_val::reset_user() const\n{\n  auto res = isl_multi_val_reset_user(copy());\n  return manage(res);\n}\n\nmulti_val multi_val::scale(multi_val mv) const\n{\n  auto res = isl_multi_val_scale_multi_val(copy(), mv.release());\n  return manage(res);\n}\n\nmulti_val multi_val::scale(val v) const\n{\n  auto res = isl_multi_val_scale_val(copy(), v.release());\n  return manage(res);\n}\n\nmulti_val multi_val::scale_down(multi_val mv) const\n{\n  auto res = isl_multi_val_scale_down_multi_val(copy(), mv.release());\n  return manage(res);\n}\n\nmulti_val multi_val::scale_down(val v) const\n{\n  auto res = isl_multi_val_scale_down_val(copy(), v.release());\n  return manage(res);\n}\n\nmulti_val multi_val::set_at(int pos, val el) const\n{\n  auto res = isl_multi_val_set_at(copy(), pos, el.release());\n  return manage(res);\n}\n\nmulti_val multi_val::set_dim_id(isl::dim type, unsigned int pos, id id) const\n{\n  auto res = isl_multi_val_set_dim_id(copy(), static_cast<enum isl_dim_type>(type), pos, id.release());\n  return manage(res);\n}\n\nmulti_val multi_val::set_tuple_id(isl::dim type, id id) const\n{\n  auto res = isl_multi_val_set_tuple_id(copy(), static_cast<enum isl_dim_type>(type), id.release());\n  return manage(res);\n}\n\nmulti_val multi_val::set_tuple_name(isl::dim type, const std::string &s) const\n{\n  auto res = isl_multi_val_set_tuple_name(copy(), static_cast<enum isl_dim_type>(type), s.c_str());\n  return manage(res);\n}\n\nmulti_val multi_val::set_val(int pos, val el) const\n{\n  auto res = isl_multi_val_set_val(copy(), pos, el.release());\n  return manage(res);\n}\n\nisl_size multi_val::size() const\n{\n  auto res = isl_multi_val_size(get());\n  return res;\n}\n\nmulti_val multi_val::splice(unsigned int in_pos, unsigned int out_pos, multi_val multi2) const\n{\n  auto res = isl_multi_val_splice(copy(), in_pos, out_pos, multi2.release());\n  return manage(res);\n}\n\nmulti_val multi_val::sub(multi_val multi2) const\n{\n  auto res = isl_multi_val_sub(copy(), multi2.release());\n  return manage(res);\n}\n\nmulti_val multi_val::zero(space space)\n{\n  auto res = isl_multi_val_zero(space.release());\n  return manage(res);\n}\n\n// implementations for isl::point\npoint manage(__isl_take isl_point *ptr) {\n  return point(ptr);\n}\npoint manage_copy(__isl_keep isl_point *ptr) {\n  ptr = isl_point_copy(ptr);\n  return point(ptr);\n}\n\npoint::point()\n    : ptr(nullptr) {}\n\npoint::point(const point &obj)\n    : ptr(nullptr)\n{\n  ptr = obj.copy();\n}\npoint::point(std::nullptr_t)\n    : ptr(nullptr) {}\n\n\npoint::point(__isl_take isl_point *ptr)\n    : ptr(ptr) {}\n\npoint::point(space dim)\n{\n  auto res = isl_point_zero(dim.release());\n  ptr = res;\n}\n\npoint &point::operator=(point obj) {\n  std::swap(this->ptr, obj.ptr);\n  return *this;\n}\n\npoint::~point() {\n  if (ptr)\n    isl_point_free(ptr);\n}\n\n__isl_give isl_point *point::copy() const & {\n  return isl_point_copy(ptr);\n}\n\n__isl_keep isl_point *point::get() const {\n  return ptr;\n}\n\n__isl_give isl_point *point::release() {\n  isl_point *tmp = ptr;\n  ptr = nullptr;\n  return tmp;\n}\n\nbool point::is_null() const {\n  return ptr == nullptr;\n}\npoint::operator bool() const {\n  return !is_null();\n}\n\n\nctx point::get_ctx() const {\n  return ctx(isl_point_get_ctx(ptr));\n}\nstd::string point::to_str() const {\n  char *Tmp = isl_point_to_str(get());\n  if (!Tmp)\n    return \"\";\n  std::string S(Tmp);\n  free(Tmp);\n  return S;\n}\n\n\nvoid point::dump() const {\n  isl_point_dump(get());\n}\n\n\npoint point::add_ui(isl::dim type, int pos, unsigned int val) const\n{\n  auto res = isl_point_add_ui(copy(), static_cast<enum isl_dim_type>(type), pos, val);\n  return manage(res);\n}\n\nval point::get_coordinate_val(isl::dim type, int pos) const\n{\n  auto res = isl_point_get_coordinate_val(get(), static_cast<enum isl_dim_type>(type), pos);\n  return manage(res);\n}\n\nmulti_val point::get_multi_val() const\n{\n  auto res = isl_point_get_multi_val(get());\n  return manage(res);\n}\n\nspace point::get_space() const\n{\n  auto res = isl_point_get_space(get());\n  return manage(res);\n}\n\npoint point::set_coordinate_val(isl::dim type, int pos, val v) const\n{\n  auto res = isl_point_set_coordinate_val(copy(), static_cast<enum isl_dim_type>(type), pos, v.release());\n  return manage(res);\n}\n\npoint point::sub_ui(isl::dim type, int pos, unsigned int val) const\n{\n  auto res = isl_point_sub_ui(copy(), static_cast<enum isl_dim_type>(type), pos, val);\n  return manage(res);\n}\n\n// implementations for isl::pw_aff\npw_aff manage(__isl_take isl_pw_aff *ptr) {\n  return pw_aff(ptr);\n}\npw_aff manage_copy(__isl_keep isl_pw_aff *ptr) {\n  ptr = isl_pw_aff_copy(ptr);\n  return pw_aff(ptr);\n}\n\npw_aff::pw_aff()\n    : ptr(nullptr) {}\n\npw_aff::pw_aff(const pw_aff &obj)\n    : ptr(nullptr)\n{\n  ptr = obj.copy();\n}\npw_aff::pw_aff(std::nullptr_t)\n    : ptr(nullptr) {}\n\n\npw_aff::pw_aff(__isl_take isl_pw_aff *ptr)\n    : ptr(ptr) {}\n\npw_aff::pw_aff(aff aff)\n{\n  auto res = isl_pw_aff_from_aff(aff.release());\n  ptr = res;\n}\npw_aff::pw_aff(ctx ctx, const std::string &str)\n{\n  auto res = isl_pw_aff_read_from_str(ctx.release(), str.c_str());\n  ptr = res;\n}\npw_aff::pw_aff(set domain, val v)\n{\n  auto res = isl_pw_aff_val_on_domain(domain.release(), v.release());\n  ptr = res;\n}\npw_aff::pw_aff(local_space ls)\n{\n  auto res = isl_pw_aff_zero_on_domain(ls.release());\n  ptr = res;\n}\n\npw_aff &pw_aff::operator=(pw_aff obj) {\n  std::swap(this->ptr, obj.ptr);\n  return *this;\n}\n\npw_aff::~pw_aff() {\n  if (ptr)\n    isl_pw_aff_free(ptr);\n}\n\n__isl_give isl_pw_aff *pw_aff::copy() const & {\n  return isl_pw_aff_copy(ptr);\n}\n\n__isl_keep isl_pw_aff *pw_aff::get() const {\n  return ptr;\n}\n\n__isl_give isl_pw_aff *pw_aff::release() {\n  isl_pw_aff *tmp = ptr;\n  ptr = nullptr;\n  return tmp;\n}\n\nbool pw_aff::is_null() const {\n  return ptr == nullptr;\n}\npw_aff::operator bool() const {\n  return !is_null();\n}\n\n\nctx pw_aff::get_ctx() const {\n  return ctx(isl_pw_aff_get_ctx(ptr));\n}\nstd::string pw_aff::to_str() const {\n  char *Tmp = isl_pw_aff_to_str(get());\n  if (!Tmp)\n    return \"\";\n  std::string S(Tmp);\n  free(Tmp);\n  return S;\n}\n\n\nvoid pw_aff::dump() const {\n  isl_pw_aff_dump(get());\n}\n\n\npw_aff pw_aff::add(pw_aff pwaff2) const\n{\n  auto res = isl_pw_aff_add(copy(), pwaff2.release());\n  return manage(res);\n}\n\npw_aff pw_aff::add_constant(val v) const\n{\n  auto res = isl_pw_aff_add_constant_val(copy(), v.release());\n  return manage(res);\n}\n\npw_aff pw_aff::add_dims(isl::dim type, unsigned int n) const\n{\n  auto res = isl_pw_aff_add_dims(copy(), static_cast<enum isl_dim_type>(type), n);\n  return manage(res);\n}\n\npw_aff pw_aff::align_params(space model) const\n{\n  auto res = isl_pw_aff_align_params(copy(), model.release());\n  return manage(res);\n}\n\npw_aff pw_aff::alloc(set set, aff aff)\n{\n  auto res = isl_pw_aff_alloc(set.release(), aff.release());\n  return manage(res);\n}\n\naff pw_aff::as_aff() const\n{\n  auto res = isl_pw_aff_as_aff(copy());\n  return manage(res);\n}\n\nset pw_aff::bind(id id) const\n{\n  auto res = isl_pw_aff_bind_id(copy(), id.release());\n  return manage(res);\n}\n\npw_aff pw_aff::bind_domain(multi_id tuple) const\n{\n  auto res = isl_pw_aff_bind_domain(copy(), tuple.release());\n  return manage(res);\n}\n\npw_aff pw_aff::bind_domain_wrapped_domain(multi_id tuple) const\n{\n  auto res = isl_pw_aff_bind_domain_wrapped_domain(copy(), tuple.release());\n  return manage(res);\n}\n\npw_aff pw_aff::ceil() const\n{\n  auto res = isl_pw_aff_ceil(copy());\n  return manage(res);\n}\n\npw_aff pw_aff::coalesce() const\n{\n  auto res = isl_pw_aff_coalesce(copy());\n  return manage(res);\n}\n\npw_aff pw_aff::cond(pw_aff pwaff_true, pw_aff pwaff_false) const\n{\n  auto res = isl_pw_aff_cond(copy(), pwaff_true.release(), pwaff_false.release());\n  return manage(res);\n}\n\nisl_size pw_aff::dim(isl::dim type) const\n{\n  auto res = isl_pw_aff_dim(get(), static_cast<enum isl_dim_type>(type));\n  return res;\n}\n\npw_aff pw_aff::div(pw_aff pa2) const\n{\n  auto res = isl_pw_aff_div(copy(), pa2.release());\n  return manage(res);\n}\n\nset pw_aff::domain() const\n{\n  auto res = isl_pw_aff_domain(copy());\n  return manage(res);\n}\n\npw_aff pw_aff::drop_dims(isl::dim type, unsigned int first, unsigned int n) const\n{\n  auto res = isl_pw_aff_drop_dims(copy(), static_cast<enum isl_dim_type>(type), first, n);\n  return manage(res);\n}\n\npw_aff pw_aff::drop_unused_params() const\n{\n  auto res = isl_pw_aff_drop_unused_params(copy());\n  return manage(res);\n}\n\npw_aff pw_aff::empty(space space)\n{\n  auto res = isl_pw_aff_empty(space.release());\n  return manage(res);\n}\n\nmap pw_aff::eq_map(pw_aff pa2) const\n{\n  auto res = isl_pw_aff_eq_map(copy(), pa2.release());\n  return manage(res);\n}\n\nset pw_aff::eq_set(pw_aff pwaff2) const\n{\n  auto res = isl_pw_aff_eq_set(copy(), pwaff2.release());\n  return manage(res);\n}\n\nval pw_aff::eval(point pnt) const\n{\n  auto res = isl_pw_aff_eval(copy(), pnt.release());\n  return manage(res);\n}\n\nint pw_aff::find_dim_by_name(isl::dim type, const std::string &name) const\n{\n  auto res = isl_pw_aff_find_dim_by_name(get(), static_cast<enum isl_dim_type>(type), name.c_str());\n  return res;\n}\n\npw_aff pw_aff::floor() const\n{\n  auto res = isl_pw_aff_floor(copy());\n  return manage(res);\n}\n\nstat pw_aff::foreach_piece(const std::function<stat(set, aff)> &fn) const\n{\n  struct fn_data {\n    const std::function<stat(set, aff)> *func;\n  } fn_data = { &fn };\n  auto fn_lambda = [](isl_set *arg_0, isl_aff *arg_1, void *arg_2) -> isl_stat {\n    auto *data = static_cast<struct fn_data *>(arg_2);\n    stat ret = (*data->func)(manage(arg_0), manage(arg_1));\n    return ret.release();\n  };\n  auto res = isl_pw_aff_foreach_piece(get(), fn_lambda, &fn_data);\n  return manage(res);\n}\n\npw_aff pw_aff::from_range() const\n{\n  auto res = isl_pw_aff_from_range(copy());\n  return manage(res);\n}\n\nmap pw_aff::ge_map(pw_aff pa2) const\n{\n  auto res = isl_pw_aff_ge_map(copy(), pa2.release());\n  return manage(res);\n}\n\nset pw_aff::ge_set(pw_aff pwaff2) const\n{\n  auto res = isl_pw_aff_ge_set(copy(), pwaff2.release());\n  return manage(res);\n}\n\nid pw_aff::get_dim_id(isl::dim type, unsigned int pos) const\n{\n  auto res = isl_pw_aff_get_dim_id(get(), static_cast<enum isl_dim_type>(type), pos);\n  return manage(res);\n}\n\nstd::string pw_aff::get_dim_name(isl::dim type, unsigned int pos) const\n{\n  auto res = isl_pw_aff_get_dim_name(get(), static_cast<enum isl_dim_type>(type), pos);\n  std::string tmp(res);\n  return tmp;\n}\n\nspace pw_aff::get_domain_space() const\n{\n  auto res = isl_pw_aff_get_domain_space(get());\n  return manage(res);\n}\n\nuint32_t pw_aff::get_hash() const\n{\n  auto res = isl_pw_aff_get_hash(get());\n  return res;\n}\n\nspace pw_aff::get_space() const\n{\n  auto res = isl_pw_aff_get_space(get());\n  return manage(res);\n}\n\nid pw_aff::get_tuple_id(isl::dim type) const\n{\n  auto res = isl_pw_aff_get_tuple_id(get(), static_cast<enum isl_dim_type>(type));\n  return manage(res);\n}\n\npw_aff pw_aff::gist(set context) const\n{\n  auto res = isl_pw_aff_gist(copy(), context.release());\n  return manage(res);\n}\n\npw_aff pw_aff::gist_params(set context) const\n{\n  auto res = isl_pw_aff_gist_params(copy(), context.release());\n  return manage(res);\n}\n\nmap pw_aff::gt_map(pw_aff pa2) const\n{\n  auto res = isl_pw_aff_gt_map(copy(), pa2.release());\n  return manage(res);\n}\n\nset pw_aff::gt_set(pw_aff pwaff2) const\n{\n  auto res = isl_pw_aff_gt_set(copy(), pwaff2.release());\n  return manage(res);\n}\n\nboolean pw_aff::has_dim_id(isl::dim type, unsigned int pos) const\n{\n  auto res = isl_pw_aff_has_dim_id(get(), static_cast<enum isl_dim_type>(type), pos);\n  return manage(res);\n}\n\nboolean pw_aff::has_tuple_id(isl::dim type) const\n{\n  auto res = isl_pw_aff_has_tuple_id(get(), static_cast<enum isl_dim_type>(type));\n  return manage(res);\n}\n\npw_aff pw_aff::insert_dims(isl::dim type, unsigned int first, unsigned int n) const\n{\n  auto res = isl_pw_aff_insert_dims(copy(), static_cast<enum isl_dim_type>(type), first, n);\n  return manage(res);\n}\n\npw_aff pw_aff::insert_domain(space domain) const\n{\n  auto res = isl_pw_aff_insert_domain(copy(), domain.release());\n  return manage(res);\n}\n\npw_aff pw_aff::intersect_domain(set set) const\n{\n  auto res = isl_pw_aff_intersect_domain(copy(), set.release());\n  return manage(res);\n}\n\npw_aff pw_aff::intersect_domain_wrapped_domain(set set) const\n{\n  auto res = isl_pw_aff_intersect_domain_wrapped_domain(copy(), set.release());\n  return manage(res);\n}\n\npw_aff pw_aff::intersect_domain_wrapped_range(set set) const\n{\n  auto res = isl_pw_aff_intersect_domain_wrapped_range(copy(), set.release());\n  return manage(res);\n}\n\npw_aff pw_aff::intersect_params(set set) const\n{\n  auto res = isl_pw_aff_intersect_params(copy(), set.release());\n  return manage(res);\n}\n\nboolean pw_aff::involves_dims(isl::dim type, unsigned int first, unsigned int n) const\n{\n  auto res = isl_pw_aff_involves_dims(get(), static_cast<enum isl_dim_type>(type), first, n);\n  return manage(res);\n}\n\nboolean pw_aff::involves_nan() const\n{\n  auto res = isl_pw_aff_involves_nan(get());\n  return manage(res);\n}\n\nboolean pw_aff::involves_param_id(const id &id) const\n{\n  auto res = isl_pw_aff_involves_param_id(get(), id.get());\n  return manage(res);\n}\n\nboolean pw_aff::is_cst() const\n{\n  auto res = isl_pw_aff_is_cst(get());\n  return manage(res);\n}\n\nboolean pw_aff::is_empty() const\n{\n  auto res = isl_pw_aff_is_empty(get());\n  return manage(res);\n}\n\nboolean pw_aff::is_equal(const pw_aff &pa2) const\n{\n  auto res = isl_pw_aff_is_equal(get(), pa2.get());\n  return manage(res);\n}\n\nboolean pw_aff::isa_aff() const\n{\n  auto res = isl_pw_aff_isa_aff(get());\n  return manage(res);\n}\n\nmap pw_aff::le_map(pw_aff pa2) const\n{\n  auto res = isl_pw_aff_le_map(copy(), pa2.release());\n  return manage(res);\n}\n\nset pw_aff::le_set(pw_aff pwaff2) const\n{\n  auto res = isl_pw_aff_le_set(copy(), pwaff2.release());\n  return manage(res);\n}\n\nmap pw_aff::lt_map(pw_aff pa2) const\n{\n  auto res = isl_pw_aff_lt_map(copy(), pa2.release());\n  return manage(res);\n}\n\nset pw_aff::lt_set(pw_aff pwaff2) const\n{\n  auto res = isl_pw_aff_lt_set(copy(), pwaff2.release());\n  return manage(res);\n}\n\npw_aff pw_aff::max(pw_aff pwaff2) const\n{\n  auto res = isl_pw_aff_max(copy(), pwaff2.release());\n  return manage(res);\n}\n\npw_aff pw_aff::min(pw_aff pwaff2) const\n{\n  auto res = isl_pw_aff_min(copy(), pwaff2.release());\n  return manage(res);\n}\n\npw_aff pw_aff::mod(val mod) const\n{\n  auto res = isl_pw_aff_mod_val(copy(), mod.release());\n  return manage(res);\n}\n\npw_aff pw_aff::move_dims(isl::dim dst_type, unsigned int dst_pos, isl::dim src_type, unsigned int src_pos, unsigned int n) const\n{\n  auto res = isl_pw_aff_move_dims(copy(), static_cast<enum isl_dim_type>(dst_type), dst_pos, static_cast<enum isl_dim_type>(src_type), src_pos, n);\n  return manage(res);\n}\n\npw_aff pw_aff::mul(pw_aff pwaff2) const\n{\n  auto res = isl_pw_aff_mul(copy(), pwaff2.release());\n  return manage(res);\n}\n\nisl_size pw_aff::n_piece() const\n{\n  auto res = isl_pw_aff_n_piece(get());\n  return res;\n}\n\npw_aff pw_aff::nan_on_domain(local_space ls)\n{\n  auto res = isl_pw_aff_nan_on_domain(ls.release());\n  return manage(res);\n}\n\npw_aff pw_aff::nan_on_domain_space(space space)\n{\n  auto res = isl_pw_aff_nan_on_domain_space(space.release());\n  return manage(res);\n}\n\nset pw_aff::ne_set(pw_aff pwaff2) const\n{\n  auto res = isl_pw_aff_ne_set(copy(), pwaff2.release());\n  return manage(res);\n}\n\npw_aff pw_aff::neg() const\n{\n  auto res = isl_pw_aff_neg(copy());\n  return manage(res);\n}\n\nset pw_aff::non_zero_set() const\n{\n  auto res = isl_pw_aff_non_zero_set(copy());\n  return manage(res);\n}\n\nset pw_aff::nonneg_set() const\n{\n  auto res = isl_pw_aff_nonneg_set(copy());\n  return manage(res);\n}\n\npw_aff pw_aff::param_on_domain(set domain, id id)\n{\n  auto res = isl_pw_aff_param_on_domain_id(domain.release(), id.release());\n  return manage(res);\n}\n\nset pw_aff::params() const\n{\n  auto res = isl_pw_aff_params(copy());\n  return manage(res);\n}\n\nint pw_aff::plain_cmp(const pw_aff &pa2) const\n{\n  auto res = isl_pw_aff_plain_cmp(get(), pa2.get());\n  return res;\n}\n\nboolean pw_aff::plain_is_equal(const pw_aff &pwaff2) const\n{\n  auto res = isl_pw_aff_plain_is_equal(get(), pwaff2.get());\n  return manage(res);\n}\n\nset pw_aff::pos_set() const\n{\n  auto res = isl_pw_aff_pos_set(copy());\n  return manage(res);\n}\n\npw_aff pw_aff::project_domain_on_params() const\n{\n  auto res = isl_pw_aff_project_domain_on_params(copy());\n  return manage(res);\n}\n\npw_aff pw_aff::pullback(multi_aff ma) const\n{\n  auto res = isl_pw_aff_pullback_multi_aff(copy(), ma.release());\n  return manage(res);\n}\n\npw_aff pw_aff::pullback(multi_pw_aff mpa) const\n{\n  auto res = isl_pw_aff_pullback_multi_pw_aff(copy(), mpa.release());\n  return manage(res);\n}\n\npw_aff pw_aff::pullback(pw_multi_aff pma) const\n{\n  auto res = isl_pw_aff_pullback_pw_multi_aff(copy(), pma.release());\n  return manage(res);\n}\n\npw_aff pw_aff::reset_tuple_id(isl::dim type) const\n{\n  auto res = isl_pw_aff_reset_tuple_id(copy(), static_cast<enum isl_dim_type>(type));\n  return manage(res);\n}\n\npw_aff pw_aff::reset_user() const\n{\n  auto res = isl_pw_aff_reset_user(copy());\n  return manage(res);\n}\n\npw_aff pw_aff::scale(val v) const\n{\n  auto res = isl_pw_aff_scale_val(copy(), v.release());\n  return manage(res);\n}\n\npw_aff pw_aff::scale_down(val f) const\n{\n  auto res = isl_pw_aff_scale_down_val(copy(), f.release());\n  return manage(res);\n}\n\npw_aff pw_aff::set_dim_id(isl::dim type, unsigned int pos, id id) const\n{\n  auto res = isl_pw_aff_set_dim_id(copy(), static_cast<enum isl_dim_type>(type), pos, id.release());\n  return manage(res);\n}\n\npw_aff pw_aff::set_tuple_id(isl::dim type, id id) const\n{\n  auto res = isl_pw_aff_set_tuple_id(copy(), static_cast<enum isl_dim_type>(type), id.release());\n  return manage(res);\n}\n\npw_aff pw_aff::sub(pw_aff pwaff2) const\n{\n  auto res = isl_pw_aff_sub(copy(), pwaff2.release());\n  return manage(res);\n}\n\npw_aff pw_aff::subtract_domain(set set) const\n{\n  auto res = isl_pw_aff_subtract_domain(copy(), set.release());\n  return manage(res);\n}\n\npw_aff pw_aff::tdiv_q(pw_aff pa2) const\n{\n  auto res = isl_pw_aff_tdiv_q(copy(), pa2.release());\n  return manage(res);\n}\n\npw_aff pw_aff::tdiv_r(pw_aff pa2) const\n{\n  auto res = isl_pw_aff_tdiv_r(copy(), pa2.release());\n  return manage(res);\n}\n\npw_aff pw_aff::union_add(pw_aff pwaff2) const\n{\n  auto res = isl_pw_aff_union_add(copy(), pwaff2.release());\n  return manage(res);\n}\n\npw_aff pw_aff::union_max(pw_aff pwaff2) const\n{\n  auto res = isl_pw_aff_union_max(copy(), pwaff2.release());\n  return manage(res);\n}\n\npw_aff pw_aff::union_min(pw_aff pwaff2) const\n{\n  auto res = isl_pw_aff_union_min(copy(), pwaff2.release());\n  return manage(res);\n}\n\npw_aff pw_aff::var_on_domain(local_space ls, isl::dim type, unsigned int pos)\n{\n  auto res = isl_pw_aff_var_on_domain(ls.release(), static_cast<enum isl_dim_type>(type), pos);\n  return manage(res);\n}\n\nset pw_aff::zero_set() const\n{\n  auto res = isl_pw_aff_zero_set(copy());\n  return manage(res);\n}\n\n// implementations for isl::pw_aff_list\npw_aff_list manage(__isl_take isl_pw_aff_list *ptr) {\n  return pw_aff_list(ptr);\n}\npw_aff_list manage_copy(__isl_keep isl_pw_aff_list *ptr) {\n  ptr = isl_pw_aff_list_copy(ptr);\n  return pw_aff_list(ptr);\n}\n\npw_aff_list::pw_aff_list()\n    : ptr(nullptr) {}\n\npw_aff_list::pw_aff_list(const pw_aff_list &obj)\n    : ptr(nullptr)\n{\n  ptr = obj.copy();\n}\npw_aff_list::pw_aff_list(std::nullptr_t)\n    : ptr(nullptr) {}\n\n\npw_aff_list::pw_aff_list(__isl_take isl_pw_aff_list *ptr)\n    : ptr(ptr) {}\n\n\npw_aff_list &pw_aff_list::operator=(pw_aff_list obj) {\n  std::swap(this->ptr, obj.ptr);\n  return *this;\n}\n\npw_aff_list::~pw_aff_list() {\n  if (ptr)\n    isl_pw_aff_list_free(ptr);\n}\n\n__isl_give isl_pw_aff_list *pw_aff_list::copy() const & {\n  return isl_pw_aff_list_copy(ptr);\n}\n\n__isl_keep isl_pw_aff_list *pw_aff_list::get() const {\n  return ptr;\n}\n\n__isl_give isl_pw_aff_list *pw_aff_list::release() {\n  isl_pw_aff_list *tmp = ptr;\n  ptr = nullptr;\n  return tmp;\n}\n\nbool pw_aff_list::is_null() const {\n  return ptr == nullptr;\n}\npw_aff_list::operator bool() const {\n  return !is_null();\n}\n\n\nctx pw_aff_list::get_ctx() const {\n  return ctx(isl_pw_aff_list_get_ctx(ptr));\n}\nstd::string pw_aff_list::to_str() const {\n  char *Tmp = isl_pw_aff_list_to_str(get());\n  if (!Tmp)\n    return \"\";\n  std::string S(Tmp);\n  free(Tmp);\n  return S;\n}\n\n\nvoid pw_aff_list::dump() const {\n  isl_pw_aff_list_dump(get());\n}\n\n\npw_aff_list pw_aff_list::add(pw_aff el) const\n{\n  auto res = isl_pw_aff_list_add(copy(), el.release());\n  return manage(res);\n}\n\npw_aff_list pw_aff_list::alloc(ctx ctx, int n)\n{\n  auto res = isl_pw_aff_list_alloc(ctx.release(), n);\n  return manage(res);\n}\n\npw_aff_list pw_aff_list::clear() const\n{\n  auto res = isl_pw_aff_list_clear(copy());\n  return manage(res);\n}\n\npw_aff_list pw_aff_list::concat(pw_aff_list list2) const\n{\n  auto res = isl_pw_aff_list_concat(copy(), list2.release());\n  return manage(res);\n}\n\npw_aff_list pw_aff_list::drop(unsigned int first, unsigned int n) const\n{\n  auto res = isl_pw_aff_list_drop(copy(), first, n);\n  return manage(res);\n}\n\nset pw_aff_list::eq_set(pw_aff_list list2) const\n{\n  auto res = isl_pw_aff_list_eq_set(copy(), list2.release());\n  return manage(res);\n}\n\nstat pw_aff_list::foreach(const std::function<stat(pw_aff)> &fn) const\n{\n  struct fn_data {\n    const std::function<stat(pw_aff)> *func;\n  } fn_data = { &fn };\n  auto fn_lambda = [](isl_pw_aff *arg_0, void *arg_1) -> isl_stat {\n    auto *data = static_cast<struct fn_data *>(arg_1);\n    stat ret = (*data->func)(manage(arg_0));\n    return ret.release();\n  };\n  auto res = isl_pw_aff_list_foreach(get(), fn_lambda, &fn_data);\n  return manage(res);\n}\n\npw_aff_list pw_aff_list::from_pw_aff(pw_aff el)\n{\n  auto res = isl_pw_aff_list_from_pw_aff(el.release());\n  return manage(res);\n}\n\nset pw_aff_list::ge_set(pw_aff_list list2) const\n{\n  auto res = isl_pw_aff_list_ge_set(copy(), list2.release());\n  return manage(res);\n}\n\npw_aff pw_aff_list::get_at(int index) const\n{\n  auto res = isl_pw_aff_list_get_at(get(), index);\n  return manage(res);\n}\n\npw_aff pw_aff_list::get_pw_aff(int index) const\n{\n  auto res = isl_pw_aff_list_get_pw_aff(get(), index);\n  return manage(res);\n}\n\nset pw_aff_list::gt_set(pw_aff_list list2) const\n{\n  auto res = isl_pw_aff_list_gt_set(copy(), list2.release());\n  return manage(res);\n}\n\npw_aff_list pw_aff_list::insert(unsigned int pos, pw_aff el) const\n{\n  auto res = isl_pw_aff_list_insert(copy(), pos, el.release());\n  return manage(res);\n}\n\nset pw_aff_list::le_set(pw_aff_list list2) const\n{\n  auto res = isl_pw_aff_list_le_set(copy(), list2.release());\n  return manage(res);\n}\n\nset pw_aff_list::lt_set(pw_aff_list list2) const\n{\n  auto res = isl_pw_aff_list_lt_set(copy(), list2.release());\n  return manage(res);\n}\n\npw_aff pw_aff_list::max() const\n{\n  auto res = isl_pw_aff_list_max(copy());\n  return manage(res);\n}\n\npw_aff pw_aff_list::min() const\n{\n  auto res = isl_pw_aff_list_min(copy());\n  return manage(res);\n}\n\nisl_size pw_aff_list::n_pw_aff() const\n{\n  auto res = isl_pw_aff_list_n_pw_aff(get());\n  return res;\n}\n\nset pw_aff_list::ne_set(pw_aff_list list2) const\n{\n  auto res = isl_pw_aff_list_ne_set(copy(), list2.release());\n  return manage(res);\n}\n\npw_aff_list pw_aff_list::reverse() const\n{\n  auto res = isl_pw_aff_list_reverse(copy());\n  return manage(res);\n}\n\npw_aff_list pw_aff_list::set_pw_aff(int index, pw_aff el) const\n{\n  auto res = isl_pw_aff_list_set_pw_aff(copy(), index, el.release());\n  return manage(res);\n}\n\nisl_size pw_aff_list::size() const\n{\n  auto res = isl_pw_aff_list_size(get());\n  return res;\n}\n\npw_aff_list pw_aff_list::swap(unsigned int pos1, unsigned int pos2) const\n{\n  auto res = isl_pw_aff_list_swap(copy(), pos1, pos2);\n  return manage(res);\n}\n\n// implementations for isl::pw_multi_aff\npw_multi_aff manage(__isl_take isl_pw_multi_aff *ptr) {\n  return pw_multi_aff(ptr);\n}\npw_multi_aff manage_copy(__isl_keep isl_pw_multi_aff *ptr) {\n  ptr = isl_pw_multi_aff_copy(ptr);\n  return pw_multi_aff(ptr);\n}\n\npw_multi_aff::pw_multi_aff()\n    : ptr(nullptr) {}\n\npw_multi_aff::pw_multi_aff(const pw_multi_aff &obj)\n    : ptr(nullptr)\n{\n  ptr = obj.copy();\n}\npw_multi_aff::pw_multi_aff(std::nullptr_t)\n    : ptr(nullptr) {}\n\n\npw_multi_aff::pw_multi_aff(__isl_take isl_pw_multi_aff *ptr)\n    : ptr(ptr) {}\n\npw_multi_aff::pw_multi_aff(multi_aff ma)\n{\n  auto res = isl_pw_multi_aff_from_multi_aff(ma.release());\n  ptr = res;\n}\npw_multi_aff::pw_multi_aff(pw_aff pa)\n{\n  auto res = isl_pw_multi_aff_from_pw_aff(pa.release());\n  ptr = res;\n}\npw_multi_aff::pw_multi_aff(ctx ctx, const std::string &str)\n{\n  auto res = isl_pw_multi_aff_read_from_str(ctx.release(), str.c_str());\n  ptr = res;\n}\n\npw_multi_aff &pw_multi_aff::operator=(pw_multi_aff obj) {\n  std::swap(this->ptr, obj.ptr);\n  return *this;\n}\n\npw_multi_aff::~pw_multi_aff() {\n  if (ptr)\n    isl_pw_multi_aff_free(ptr);\n}\n\n__isl_give isl_pw_multi_aff *pw_multi_aff::copy() const & {\n  return isl_pw_multi_aff_copy(ptr);\n}\n\n__isl_keep isl_pw_multi_aff *pw_multi_aff::get() const {\n  return ptr;\n}\n\n__isl_give isl_pw_multi_aff *pw_multi_aff::release() {\n  isl_pw_multi_aff *tmp = ptr;\n  ptr = nullptr;\n  return tmp;\n}\n\nbool pw_multi_aff::is_null() const {\n  return ptr == nullptr;\n}\npw_multi_aff::operator bool() const {\n  return !is_null();\n}\n\n\nctx pw_multi_aff::get_ctx() const {\n  return ctx(isl_pw_multi_aff_get_ctx(ptr));\n}\nstd::string pw_multi_aff::to_str() const {\n  char *Tmp = isl_pw_multi_aff_to_str(get());\n  if (!Tmp)\n    return \"\";\n  std::string S(Tmp);\n  free(Tmp);\n  return S;\n}\n\n\nvoid pw_multi_aff::dump() const {\n  isl_pw_multi_aff_dump(get());\n}\n\n\npw_multi_aff pw_multi_aff::add(pw_multi_aff pma2) const\n{\n  auto res = isl_pw_multi_aff_add(copy(), pma2.release());\n  return manage(res);\n}\n\npw_multi_aff pw_multi_aff::add_constant(multi_val mv) const\n{\n  auto res = isl_pw_multi_aff_add_constant_multi_val(copy(), mv.release());\n  return manage(res);\n}\n\npw_multi_aff pw_multi_aff::add_constant(val v) const\n{\n  auto res = isl_pw_multi_aff_add_constant_val(copy(), v.release());\n  return manage(res);\n}\n\npw_multi_aff pw_multi_aff::align_params(space model) const\n{\n  auto res = isl_pw_multi_aff_align_params(copy(), model.release());\n  return manage(res);\n}\n\npw_multi_aff pw_multi_aff::alloc(set set, multi_aff maff)\n{\n  auto res = isl_pw_multi_aff_alloc(set.release(), maff.release());\n  return manage(res);\n}\n\nmulti_aff pw_multi_aff::as_multi_aff() const\n{\n  auto res = isl_pw_multi_aff_as_multi_aff(copy());\n  return manage(res);\n}\n\npw_multi_aff pw_multi_aff::bind_domain(multi_id tuple) const\n{\n  auto res = isl_pw_multi_aff_bind_domain(copy(), tuple.release());\n  return manage(res);\n}\n\npw_multi_aff pw_multi_aff::bind_domain_wrapped_domain(multi_id tuple) const\n{\n  auto res = isl_pw_multi_aff_bind_domain_wrapped_domain(copy(), tuple.release());\n  return manage(res);\n}\n\npw_multi_aff pw_multi_aff::coalesce() const\n{\n  auto res = isl_pw_multi_aff_coalesce(copy());\n  return manage(res);\n}\n\nisl_size pw_multi_aff::dim(isl::dim type) const\n{\n  auto res = isl_pw_multi_aff_dim(get(), static_cast<enum isl_dim_type>(type));\n  return res;\n}\n\nset pw_multi_aff::domain() const\n{\n  auto res = isl_pw_multi_aff_domain(copy());\n  return manage(res);\n}\n\npw_multi_aff pw_multi_aff::domain_map(space space)\n{\n  auto res = isl_pw_multi_aff_domain_map(space.release());\n  return manage(res);\n}\n\npw_multi_aff pw_multi_aff::drop_dims(isl::dim type, unsigned int first, unsigned int n) const\n{\n  auto res = isl_pw_multi_aff_drop_dims(copy(), static_cast<enum isl_dim_type>(type), first, n);\n  return manage(res);\n}\n\npw_multi_aff pw_multi_aff::drop_unused_params() const\n{\n  auto res = isl_pw_multi_aff_drop_unused_params(copy());\n  return manage(res);\n}\n\npw_multi_aff pw_multi_aff::empty(space space)\n{\n  auto res = isl_pw_multi_aff_empty(space.release());\n  return manage(res);\n}\n\nint pw_multi_aff::find_dim_by_name(isl::dim type, const std::string &name) const\n{\n  auto res = isl_pw_multi_aff_find_dim_by_name(get(), static_cast<enum isl_dim_type>(type), name.c_str());\n  return res;\n}\n\npw_multi_aff pw_multi_aff::fix_si(isl::dim type, unsigned int pos, int value) const\n{\n  auto res = isl_pw_multi_aff_fix_si(copy(), static_cast<enum isl_dim_type>(type), pos, value);\n  return manage(res);\n}\n\npw_multi_aff pw_multi_aff::flat_range_product(pw_multi_aff pma2) const\n{\n  auto res = isl_pw_multi_aff_flat_range_product(copy(), pma2.release());\n  return manage(res);\n}\n\nstat pw_multi_aff::foreach_piece(const std::function<stat(set, multi_aff)> &fn) const\n{\n  struct fn_data {\n    const std::function<stat(set, multi_aff)> *func;\n  } fn_data = { &fn };\n  auto fn_lambda = [](isl_set *arg_0, isl_multi_aff *arg_1, void *arg_2) -> isl_stat {\n    auto *data = static_cast<struct fn_data *>(arg_2);\n    stat ret = (*data->func)(manage(arg_0), manage(arg_1));\n    return ret.release();\n  };\n  auto res = isl_pw_multi_aff_foreach_piece(get(), fn_lambda, &fn_data);\n  return manage(res);\n}\n\npw_multi_aff pw_multi_aff::from_domain(set set)\n{\n  auto res = isl_pw_multi_aff_from_domain(set.release());\n  return manage(res);\n}\n\npw_multi_aff pw_multi_aff::from_map(map map)\n{\n  auto res = isl_pw_multi_aff_from_map(map.release());\n  return manage(res);\n}\n\npw_multi_aff pw_multi_aff::from_multi_pw_aff(multi_pw_aff mpa)\n{\n  auto res = isl_pw_multi_aff_from_multi_pw_aff(mpa.release());\n  return manage(res);\n}\n\npw_multi_aff pw_multi_aff::from_set(set set)\n{\n  auto res = isl_pw_multi_aff_from_set(set.release());\n  return manage(res);\n}\n\nid pw_multi_aff::get_dim_id(isl::dim type, unsigned int pos) const\n{\n  auto res = isl_pw_multi_aff_get_dim_id(get(), static_cast<enum isl_dim_type>(type), pos);\n  return manage(res);\n}\n\nstd::string pw_multi_aff::get_dim_name(isl::dim type, unsigned int pos) const\n{\n  auto res = isl_pw_multi_aff_get_dim_name(get(), static_cast<enum isl_dim_type>(type), pos);\n  std::string tmp(res);\n  return tmp;\n}\n\nspace pw_multi_aff::get_domain_space() const\n{\n  auto res = isl_pw_multi_aff_get_domain_space(get());\n  return manage(res);\n}\n\npw_aff pw_multi_aff::get_pw_aff(int pos) const\n{\n  auto res = isl_pw_multi_aff_get_pw_aff(get(), pos);\n  return manage(res);\n}\n\nspace pw_multi_aff::get_space() const\n{\n  auto res = isl_pw_multi_aff_get_space(get());\n  return manage(res);\n}\n\nid pw_multi_aff::get_tuple_id(isl::dim type) const\n{\n  auto res = isl_pw_multi_aff_get_tuple_id(get(), static_cast<enum isl_dim_type>(type));\n  return manage(res);\n}\n\nstd::string pw_multi_aff::get_tuple_name(isl::dim type) const\n{\n  auto res = isl_pw_multi_aff_get_tuple_name(get(), static_cast<enum isl_dim_type>(type));\n  std::string tmp(res);\n  return tmp;\n}\n\npw_multi_aff pw_multi_aff::gist(set set) const\n{\n  auto res = isl_pw_multi_aff_gist(copy(), set.release());\n  return manage(res);\n}\n\npw_multi_aff pw_multi_aff::gist_params(set set) const\n{\n  auto res = isl_pw_multi_aff_gist_params(copy(), set.release());\n  return manage(res);\n}\n\nboolean pw_multi_aff::has_tuple_id(isl::dim type) const\n{\n  auto res = isl_pw_multi_aff_has_tuple_id(get(), static_cast<enum isl_dim_type>(type));\n  return manage(res);\n}\n\nboolean pw_multi_aff::has_tuple_name(isl::dim type) const\n{\n  auto res = isl_pw_multi_aff_has_tuple_name(get(), static_cast<enum isl_dim_type>(type));\n  return manage(res);\n}\n\npw_multi_aff pw_multi_aff::identity(space space)\n{\n  auto res = isl_pw_multi_aff_identity(space.release());\n  return manage(res);\n}\n\npw_multi_aff pw_multi_aff::identity_on_domain(space space)\n{\n  auto res = isl_pw_multi_aff_identity_on_domain_space(space.release());\n  return manage(res);\n}\n\npw_multi_aff pw_multi_aff::insert_domain(space domain) const\n{\n  auto res = isl_pw_multi_aff_insert_domain(copy(), domain.release());\n  return manage(res);\n}\n\npw_multi_aff pw_multi_aff::intersect_domain(set set) const\n{\n  auto res = isl_pw_multi_aff_intersect_domain(copy(), set.release());\n  return manage(res);\n}\n\npw_multi_aff pw_multi_aff::intersect_domain_wrapped_domain(set set) const\n{\n  auto res = isl_pw_multi_aff_intersect_domain_wrapped_domain(copy(), set.release());\n  return manage(res);\n}\n\npw_multi_aff pw_multi_aff::intersect_domain_wrapped_range(set set) const\n{\n  auto res = isl_pw_multi_aff_intersect_domain_wrapped_range(copy(), set.release());\n  return manage(res);\n}\n\npw_multi_aff pw_multi_aff::intersect_params(set set) const\n{\n  auto res = isl_pw_multi_aff_intersect_params(copy(), set.release());\n  return manage(res);\n}\n\nboolean pw_multi_aff::involves_dims(isl::dim type, unsigned int first, unsigned int n) const\n{\n  auto res = isl_pw_multi_aff_involves_dims(get(), static_cast<enum isl_dim_type>(type), first, n);\n  return manage(res);\n}\n\nboolean pw_multi_aff::involves_locals() const\n{\n  auto res = isl_pw_multi_aff_involves_locals(get());\n  return manage(res);\n}\n\nboolean pw_multi_aff::involves_nan() const\n{\n  auto res = isl_pw_multi_aff_involves_nan(get());\n  return manage(res);\n}\n\nboolean pw_multi_aff::involves_param_id(const id &id) const\n{\n  auto res = isl_pw_multi_aff_involves_param_id(get(), id.get());\n  return manage(res);\n}\n\nboolean pw_multi_aff::is_equal(const pw_multi_aff &pma2) const\n{\n  auto res = isl_pw_multi_aff_is_equal(get(), pma2.get());\n  return manage(res);\n}\n\nboolean pw_multi_aff::isa_multi_aff() const\n{\n  auto res = isl_pw_multi_aff_isa_multi_aff(get());\n  return manage(res);\n}\n\nmulti_val pw_multi_aff::max_multi_val() const\n{\n  auto res = isl_pw_multi_aff_max_multi_val(copy());\n  return manage(res);\n}\n\nmulti_val pw_multi_aff::min_multi_val() const\n{\n  auto res = isl_pw_multi_aff_min_multi_val(copy());\n  return manage(res);\n}\n\npw_multi_aff pw_multi_aff::multi_val_on_domain(set domain, multi_val mv)\n{\n  auto res = isl_pw_multi_aff_multi_val_on_domain(domain.release(), mv.release());\n  return manage(res);\n}\n\nisl_size pw_multi_aff::n_piece() const\n{\n  auto res = isl_pw_multi_aff_n_piece(get());\n  return res;\n}\n\npw_multi_aff pw_multi_aff::neg() const\n{\n  auto res = isl_pw_multi_aff_neg(copy());\n  return manage(res);\n}\n\nboolean pw_multi_aff::plain_is_equal(const pw_multi_aff &pma2) const\n{\n  auto res = isl_pw_multi_aff_plain_is_equal(get(), pma2.get());\n  return manage(res);\n}\n\npw_multi_aff pw_multi_aff::preimage_domain_wrapped_domain(pw_multi_aff pma2) const\n{\n  auto res = isl_pw_multi_aff_preimage_domain_wrapped_domain_pw_multi_aff(copy(), pma2.release());\n  return manage(res);\n}\n\npw_multi_aff pw_multi_aff::product(pw_multi_aff pma2) const\n{\n  auto res = isl_pw_multi_aff_product(copy(), pma2.release());\n  return manage(res);\n}\n\npw_multi_aff pw_multi_aff::project_domain_on_params() const\n{\n  auto res = isl_pw_multi_aff_project_domain_on_params(copy());\n  return manage(res);\n}\n\npw_multi_aff pw_multi_aff::project_out_map(space space, isl::dim type, unsigned int first, unsigned int n)\n{\n  auto res = isl_pw_multi_aff_project_out_map(space.release(), static_cast<enum isl_dim_type>(type), first, n);\n  return manage(res);\n}\n\npw_multi_aff pw_multi_aff::pullback(multi_aff ma) const\n{\n  auto res = isl_pw_multi_aff_pullback_multi_aff(copy(), ma.release());\n  return manage(res);\n}\n\npw_multi_aff pw_multi_aff::pullback(pw_multi_aff pma2) const\n{\n  auto res = isl_pw_multi_aff_pullback_pw_multi_aff(copy(), pma2.release());\n  return manage(res);\n}\n\npw_multi_aff pw_multi_aff::range_factor_domain() const\n{\n  auto res = isl_pw_multi_aff_range_factor_domain(copy());\n  return manage(res);\n}\n\npw_multi_aff pw_multi_aff::range_factor_range() const\n{\n  auto res = isl_pw_multi_aff_range_factor_range(copy());\n  return manage(res);\n}\n\npw_multi_aff pw_multi_aff::range_map(space space)\n{\n  auto res = isl_pw_multi_aff_range_map(space.release());\n  return manage(res);\n}\n\npw_multi_aff pw_multi_aff::range_product(pw_multi_aff pma2) const\n{\n  auto res = isl_pw_multi_aff_range_product(copy(), pma2.release());\n  return manage(res);\n}\n\npw_multi_aff pw_multi_aff::reset_tuple_id(isl::dim type) const\n{\n  auto res = isl_pw_multi_aff_reset_tuple_id(copy(), static_cast<enum isl_dim_type>(type));\n  return manage(res);\n}\n\npw_multi_aff pw_multi_aff::reset_user() const\n{\n  auto res = isl_pw_multi_aff_reset_user(copy());\n  return manage(res);\n}\n\npw_multi_aff pw_multi_aff::scale(val v) const\n{\n  auto res = isl_pw_multi_aff_scale_val(copy(), v.release());\n  return manage(res);\n}\n\npw_multi_aff pw_multi_aff::scale_down(val v) const\n{\n  auto res = isl_pw_multi_aff_scale_down_val(copy(), v.release());\n  return manage(res);\n}\n\npw_multi_aff pw_multi_aff::scale_multi_val(multi_val mv) const\n{\n  auto res = isl_pw_multi_aff_scale_multi_val(copy(), mv.release());\n  return manage(res);\n}\n\npw_multi_aff pw_multi_aff::set_dim_id(isl::dim type, unsigned int pos, id id) const\n{\n  auto res = isl_pw_multi_aff_set_dim_id(copy(), static_cast<enum isl_dim_type>(type), pos, id.release());\n  return manage(res);\n}\n\npw_multi_aff pw_multi_aff::set_pw_aff(unsigned int pos, pw_aff pa) const\n{\n  auto res = isl_pw_multi_aff_set_pw_aff(copy(), pos, pa.release());\n  return manage(res);\n}\n\npw_multi_aff pw_multi_aff::set_tuple_id(isl::dim type, id id) const\n{\n  auto res = isl_pw_multi_aff_set_tuple_id(copy(), static_cast<enum isl_dim_type>(type), id.release());\n  return manage(res);\n}\n\npw_multi_aff pw_multi_aff::sub(pw_multi_aff pma2) const\n{\n  auto res = isl_pw_multi_aff_sub(copy(), pma2.release());\n  return manage(res);\n}\n\npw_multi_aff pw_multi_aff::subtract_domain(set set) const\n{\n  auto res = isl_pw_multi_aff_subtract_domain(copy(), set.release());\n  return manage(res);\n}\n\npw_multi_aff pw_multi_aff::union_add(pw_multi_aff pma2) const\n{\n  auto res = isl_pw_multi_aff_union_add(copy(), pma2.release());\n  return manage(res);\n}\n\npw_multi_aff pw_multi_aff::union_lexmax(pw_multi_aff pma2) const\n{\n  auto res = isl_pw_multi_aff_union_lexmax(copy(), pma2.release());\n  return manage(res);\n}\n\npw_multi_aff pw_multi_aff::union_lexmin(pw_multi_aff pma2) const\n{\n  auto res = isl_pw_multi_aff_union_lexmin(copy(), pma2.release());\n  return manage(res);\n}\n\npw_multi_aff pw_multi_aff::zero(space space)\n{\n  auto res = isl_pw_multi_aff_zero(space.release());\n  return manage(res);\n}\n\n// implementations for isl::pw_multi_aff_list\npw_multi_aff_list manage(__isl_take isl_pw_multi_aff_list *ptr) {\n  return pw_multi_aff_list(ptr);\n}\npw_multi_aff_list manage_copy(__isl_keep isl_pw_multi_aff_list *ptr) {\n  ptr = isl_pw_multi_aff_list_copy(ptr);\n  return pw_multi_aff_list(ptr);\n}\n\npw_multi_aff_list::pw_multi_aff_list()\n    : ptr(nullptr) {}\n\npw_multi_aff_list::pw_multi_aff_list(const pw_multi_aff_list &obj)\n    : ptr(nullptr)\n{\n  ptr = obj.copy();\n}\npw_multi_aff_list::pw_multi_aff_list(std::nullptr_t)\n    : ptr(nullptr) {}\n\n\npw_multi_aff_list::pw_multi_aff_list(__isl_take isl_pw_multi_aff_list *ptr)\n    : ptr(ptr) {}\n\n\npw_multi_aff_list &pw_multi_aff_list::operator=(pw_multi_aff_list obj) {\n  std::swap(this->ptr, obj.ptr);\n  return *this;\n}\n\npw_multi_aff_list::~pw_multi_aff_list() {\n  if (ptr)\n    isl_pw_multi_aff_list_free(ptr);\n}\n\n__isl_give isl_pw_multi_aff_list *pw_multi_aff_list::copy() const & {\n  return isl_pw_multi_aff_list_copy(ptr);\n}\n\n__isl_keep isl_pw_multi_aff_list *pw_multi_aff_list::get() const {\n  return ptr;\n}\n\n__isl_give isl_pw_multi_aff_list *pw_multi_aff_list::release() {\n  isl_pw_multi_aff_list *tmp = ptr;\n  ptr = nullptr;\n  return tmp;\n}\n\nbool pw_multi_aff_list::is_null() const {\n  return ptr == nullptr;\n}\npw_multi_aff_list::operator bool() const {\n  return !is_null();\n}\n\n\nctx pw_multi_aff_list::get_ctx() const {\n  return ctx(isl_pw_multi_aff_list_get_ctx(ptr));\n}\nstd::string pw_multi_aff_list::to_str() const {\n  char *Tmp = isl_pw_multi_aff_list_to_str(get());\n  if (!Tmp)\n    return \"\";\n  std::string S(Tmp);\n  free(Tmp);\n  return S;\n}\n\n\nvoid pw_multi_aff_list::dump() const {\n  isl_pw_multi_aff_list_dump(get());\n}\n\n\npw_multi_aff_list pw_multi_aff_list::add(pw_multi_aff el) const\n{\n  auto res = isl_pw_multi_aff_list_add(copy(), el.release());\n  return manage(res);\n}\n\npw_multi_aff_list pw_multi_aff_list::alloc(ctx ctx, int n)\n{\n  auto res = isl_pw_multi_aff_list_alloc(ctx.release(), n);\n  return manage(res);\n}\n\npw_multi_aff_list pw_multi_aff_list::clear() const\n{\n  auto res = isl_pw_multi_aff_list_clear(copy());\n  return manage(res);\n}\n\npw_multi_aff_list pw_multi_aff_list::concat(pw_multi_aff_list list2) const\n{\n  auto res = isl_pw_multi_aff_list_concat(copy(), list2.release());\n  return manage(res);\n}\n\npw_multi_aff_list pw_multi_aff_list::drop(unsigned int first, unsigned int n) const\n{\n  auto res = isl_pw_multi_aff_list_drop(copy(), first, n);\n  return manage(res);\n}\n\nstat pw_multi_aff_list::foreach(const std::function<stat(pw_multi_aff)> &fn) const\n{\n  struct fn_data {\n    const std::function<stat(pw_multi_aff)> *func;\n  } fn_data = { &fn };\n  auto fn_lambda = [](isl_pw_multi_aff *arg_0, void *arg_1) -> isl_stat {\n    auto *data = static_cast<struct fn_data *>(arg_1);\n    stat ret = (*data->func)(manage(arg_0));\n    return ret.release();\n  };\n  auto res = isl_pw_multi_aff_list_foreach(get(), fn_lambda, &fn_data);\n  return manage(res);\n}\n\npw_multi_aff_list pw_multi_aff_list::from_pw_multi_aff(pw_multi_aff el)\n{\n  auto res = isl_pw_multi_aff_list_from_pw_multi_aff(el.release());\n  return manage(res);\n}\n\npw_multi_aff pw_multi_aff_list::get_at(int index) const\n{\n  auto res = isl_pw_multi_aff_list_get_at(get(), index);\n  return manage(res);\n}\n\npw_multi_aff pw_multi_aff_list::get_pw_multi_aff(int index) const\n{\n  auto res = isl_pw_multi_aff_list_get_pw_multi_aff(get(), index);\n  return manage(res);\n}\n\npw_multi_aff_list pw_multi_aff_list::insert(unsigned int pos, pw_multi_aff el) const\n{\n  auto res = isl_pw_multi_aff_list_insert(copy(), pos, el.release());\n  return manage(res);\n}\n\nisl_size pw_multi_aff_list::n_pw_multi_aff() const\n{\n  auto res = isl_pw_multi_aff_list_n_pw_multi_aff(get());\n  return res;\n}\n\npw_multi_aff_list pw_multi_aff_list::reverse() const\n{\n  auto res = isl_pw_multi_aff_list_reverse(copy());\n  return manage(res);\n}\n\npw_multi_aff_list pw_multi_aff_list::set_pw_multi_aff(int index, pw_multi_aff el) const\n{\n  auto res = isl_pw_multi_aff_list_set_pw_multi_aff(copy(), index, el.release());\n  return manage(res);\n}\n\nisl_size pw_multi_aff_list::size() const\n{\n  auto res = isl_pw_multi_aff_list_size(get());\n  return res;\n}\n\npw_multi_aff_list pw_multi_aff_list::swap(unsigned int pos1, unsigned int pos2) const\n{\n  auto res = isl_pw_multi_aff_list_swap(copy(), pos1, pos2);\n  return manage(res);\n}\n\n// implementations for isl::pw_qpolynomial\npw_qpolynomial manage(__isl_take isl_pw_qpolynomial *ptr) {\n  return pw_qpolynomial(ptr);\n}\npw_qpolynomial manage_copy(__isl_keep isl_pw_qpolynomial *ptr) {\n  ptr = isl_pw_qpolynomial_copy(ptr);\n  return pw_qpolynomial(ptr);\n}\n\npw_qpolynomial::pw_qpolynomial()\n    : ptr(nullptr) {}\n\npw_qpolynomial::pw_qpolynomial(const pw_qpolynomial &obj)\n    : ptr(nullptr)\n{\n  ptr = obj.copy();\n}\npw_qpolynomial::pw_qpolynomial(std::nullptr_t)\n    : ptr(nullptr) {}\n\n\npw_qpolynomial::pw_qpolynomial(__isl_take isl_pw_qpolynomial *ptr)\n    : ptr(ptr) {}\n\npw_qpolynomial::pw_qpolynomial(ctx ctx, const std::string &str)\n{\n  auto res = isl_pw_qpolynomial_read_from_str(ctx.release(), str.c_str());\n  ptr = res;\n}\n\npw_qpolynomial &pw_qpolynomial::operator=(pw_qpolynomial obj) {\n  std::swap(this->ptr, obj.ptr);\n  return *this;\n}\n\npw_qpolynomial::~pw_qpolynomial() {\n  if (ptr)\n    isl_pw_qpolynomial_free(ptr);\n}\n\n__isl_give isl_pw_qpolynomial *pw_qpolynomial::copy() const & {\n  return isl_pw_qpolynomial_copy(ptr);\n}\n\n__isl_keep isl_pw_qpolynomial *pw_qpolynomial::get() const {\n  return ptr;\n}\n\n__isl_give isl_pw_qpolynomial *pw_qpolynomial::release() {\n  isl_pw_qpolynomial *tmp = ptr;\n  ptr = nullptr;\n  return tmp;\n}\n\nbool pw_qpolynomial::is_null() const {\n  return ptr == nullptr;\n}\npw_qpolynomial::operator bool() const {\n  return !is_null();\n}\n\n\nctx pw_qpolynomial::get_ctx() const {\n  return ctx(isl_pw_qpolynomial_get_ctx(ptr));\n}\nstd::string pw_qpolynomial::to_str() const {\n  char *Tmp = isl_pw_qpolynomial_to_str(get());\n  if (!Tmp)\n    return \"\";\n  std::string S(Tmp);\n  free(Tmp);\n  return S;\n}\n\n\nvoid pw_qpolynomial::dump() const {\n  isl_pw_qpolynomial_dump(get());\n}\n\n\npw_qpolynomial pw_qpolynomial::add(pw_qpolynomial pwqp2) const\n{\n  auto res = isl_pw_qpolynomial_add(copy(), pwqp2.release());\n  return manage(res);\n}\n\npw_qpolynomial pw_qpolynomial::add_dims(isl::dim type, unsigned int n) const\n{\n  auto res = isl_pw_qpolynomial_add_dims(copy(), static_cast<enum isl_dim_type>(type), n);\n  return manage(res);\n}\n\npw_qpolynomial pw_qpolynomial::alloc(set set, qpolynomial qp)\n{\n  auto res = isl_pw_qpolynomial_alloc(set.release(), qp.release());\n  return manage(res);\n}\n\nqpolynomial pw_qpolynomial::as_qpolynomial() const\n{\n  auto res = isl_pw_qpolynomial_as_qpolynomial(copy());\n  return manage(res);\n}\n\npw_qpolynomial pw_qpolynomial::coalesce() const\n{\n  auto res = isl_pw_qpolynomial_coalesce(copy());\n  return manage(res);\n}\n\nisl_size pw_qpolynomial::dim(isl::dim type) const\n{\n  auto res = isl_pw_qpolynomial_dim(get(), static_cast<enum isl_dim_type>(type));\n  return res;\n}\n\nset pw_qpolynomial::domain() const\n{\n  auto res = isl_pw_qpolynomial_domain(copy());\n  return manage(res);\n}\n\npw_qpolynomial pw_qpolynomial::drop_dims(isl::dim type, unsigned int first, unsigned int n) const\n{\n  auto res = isl_pw_qpolynomial_drop_dims(copy(), static_cast<enum isl_dim_type>(type), first, n);\n  return manage(res);\n}\n\npw_qpolynomial pw_qpolynomial::drop_unused_params() const\n{\n  auto res = isl_pw_qpolynomial_drop_unused_params(copy());\n  return manage(res);\n}\n\nval pw_qpolynomial::eval(point pnt) const\n{\n  auto res = isl_pw_qpolynomial_eval(copy(), pnt.release());\n  return manage(res);\n}\n\nint pw_qpolynomial::find_dim_by_name(isl::dim type, const std::string &name) const\n{\n  auto res = isl_pw_qpolynomial_find_dim_by_name(get(), static_cast<enum isl_dim_type>(type), name.c_str());\n  return res;\n}\n\npw_qpolynomial pw_qpolynomial::fix_val(isl::dim type, unsigned int n, val v) const\n{\n  auto res = isl_pw_qpolynomial_fix_val(copy(), static_cast<enum isl_dim_type>(type), n, v.release());\n  return manage(res);\n}\n\nstat pw_qpolynomial::foreach_piece(const std::function<stat(set, qpolynomial)> &fn) const\n{\n  struct fn_data {\n    const std::function<stat(set, qpolynomial)> *func;\n  } fn_data = { &fn };\n  auto fn_lambda = [](isl_set *arg_0, isl_qpolynomial *arg_1, void *arg_2) -> isl_stat {\n    auto *data = static_cast<struct fn_data *>(arg_2);\n    stat ret = (*data->func)(manage(arg_0), manage(arg_1));\n    return ret.release();\n  };\n  auto res = isl_pw_qpolynomial_foreach_piece(get(), fn_lambda, &fn_data);\n  return manage(res);\n}\n\npw_qpolynomial pw_qpolynomial::from_pw_aff(pw_aff pwaff)\n{\n  auto res = isl_pw_qpolynomial_from_pw_aff(pwaff.release());\n  return manage(res);\n}\n\npw_qpolynomial pw_qpolynomial::from_qpolynomial(qpolynomial qp)\n{\n  auto res = isl_pw_qpolynomial_from_qpolynomial(qp.release());\n  return manage(res);\n}\n\npw_qpolynomial pw_qpolynomial::from_range() const\n{\n  auto res = isl_pw_qpolynomial_from_range(copy());\n  return manage(res);\n}\n\nspace pw_qpolynomial::get_domain_space() const\n{\n  auto res = isl_pw_qpolynomial_get_domain_space(get());\n  return manage(res);\n}\n\nspace pw_qpolynomial::get_space() const\n{\n  auto res = isl_pw_qpolynomial_get_space(get());\n  return manage(res);\n}\n\npw_qpolynomial pw_qpolynomial::gist(set context) const\n{\n  auto res = isl_pw_qpolynomial_gist(copy(), context.release());\n  return manage(res);\n}\n\npw_qpolynomial pw_qpolynomial::gist_params(set context) const\n{\n  auto res = isl_pw_qpolynomial_gist_params(copy(), context.release());\n  return manage(res);\n}\n\nboolean pw_qpolynomial::has_equal_space(const pw_qpolynomial &pwqp2) const\n{\n  auto res = isl_pw_qpolynomial_has_equal_space(get(), pwqp2.get());\n  return manage(res);\n}\n\npw_qpolynomial pw_qpolynomial::insert_dims(isl::dim type, unsigned int first, unsigned int n) const\n{\n  auto res = isl_pw_qpolynomial_insert_dims(copy(), static_cast<enum isl_dim_type>(type), first, n);\n  return manage(res);\n}\n\npw_qpolynomial pw_qpolynomial::intersect_domain(set set) const\n{\n  auto res = isl_pw_qpolynomial_intersect_domain(copy(), set.release());\n  return manage(res);\n}\n\npw_qpolynomial pw_qpolynomial::intersect_domain_wrapped_domain(set set) const\n{\n  auto res = isl_pw_qpolynomial_intersect_domain_wrapped_domain(copy(), set.release());\n  return manage(res);\n}\n\npw_qpolynomial pw_qpolynomial::intersect_domain_wrapped_range(set set) const\n{\n  auto res = isl_pw_qpolynomial_intersect_domain_wrapped_range(copy(), set.release());\n  return manage(res);\n}\n\npw_qpolynomial pw_qpolynomial::intersect_params(set set) const\n{\n  auto res = isl_pw_qpolynomial_intersect_params(copy(), set.release());\n  return manage(res);\n}\n\nboolean pw_qpolynomial::involves_dims(isl::dim type, unsigned int first, unsigned int n) const\n{\n  auto res = isl_pw_qpolynomial_involves_dims(get(), static_cast<enum isl_dim_type>(type), first, n);\n  return manage(res);\n}\n\nboolean pw_qpolynomial::involves_nan() const\n{\n  auto res = isl_pw_qpolynomial_involves_nan(get());\n  return manage(res);\n}\n\nboolean pw_qpolynomial::involves_param_id(const id &id) const\n{\n  auto res = isl_pw_qpolynomial_involves_param_id(get(), id.get());\n  return manage(res);\n}\n\nboolean pw_qpolynomial::is_zero() const\n{\n  auto res = isl_pw_qpolynomial_is_zero(get());\n  return manage(res);\n}\n\nboolean pw_qpolynomial::isa_qpolynomial() const\n{\n  auto res = isl_pw_qpolynomial_isa_qpolynomial(get());\n  return manage(res);\n}\n\nval pw_qpolynomial::max() const\n{\n  auto res = isl_pw_qpolynomial_max(copy());\n  return manage(res);\n}\n\nval pw_qpolynomial::min() const\n{\n  auto res = isl_pw_qpolynomial_min(copy());\n  return manage(res);\n}\n\npw_qpolynomial pw_qpolynomial::move_dims(isl::dim dst_type, unsigned int dst_pos, isl::dim src_type, unsigned int src_pos, unsigned int n) const\n{\n  auto res = isl_pw_qpolynomial_move_dims(copy(), static_cast<enum isl_dim_type>(dst_type), dst_pos, static_cast<enum isl_dim_type>(src_type), src_pos, n);\n  return manage(res);\n}\n\npw_qpolynomial pw_qpolynomial::mul(pw_qpolynomial pwqp2) const\n{\n  auto res = isl_pw_qpolynomial_mul(copy(), pwqp2.release());\n  return manage(res);\n}\n\nisl_size pw_qpolynomial::n_piece() const\n{\n  auto res = isl_pw_qpolynomial_n_piece(get());\n  return res;\n}\n\npw_qpolynomial pw_qpolynomial::neg() const\n{\n  auto res = isl_pw_qpolynomial_neg(copy());\n  return manage(res);\n}\n\nboolean pw_qpolynomial::plain_is_equal(const pw_qpolynomial &pwqp2) const\n{\n  auto res = isl_pw_qpolynomial_plain_is_equal(get(), pwqp2.get());\n  return manage(res);\n}\n\npw_qpolynomial pw_qpolynomial::pow(unsigned int exponent) const\n{\n  auto res = isl_pw_qpolynomial_pow(copy(), exponent);\n  return manage(res);\n}\n\npw_qpolynomial pw_qpolynomial::project_domain_on_params() const\n{\n  auto res = isl_pw_qpolynomial_project_domain_on_params(copy());\n  return manage(res);\n}\n\npw_qpolynomial pw_qpolynomial::reset_domain_space(space space) const\n{\n  auto res = isl_pw_qpolynomial_reset_domain_space(copy(), space.release());\n  return manage(res);\n}\n\npw_qpolynomial pw_qpolynomial::reset_user() const\n{\n  auto res = isl_pw_qpolynomial_reset_user(copy());\n  return manage(res);\n}\n\npw_qpolynomial pw_qpolynomial::scale_down_val(val v) const\n{\n  auto res = isl_pw_qpolynomial_scale_down_val(copy(), v.release());\n  return manage(res);\n}\n\npw_qpolynomial pw_qpolynomial::scale_val(val v) const\n{\n  auto res = isl_pw_qpolynomial_scale_val(copy(), v.release());\n  return manage(res);\n}\n\npw_qpolynomial pw_qpolynomial::split_dims(isl::dim type, unsigned int first, unsigned int n) const\n{\n  auto res = isl_pw_qpolynomial_split_dims(copy(), static_cast<enum isl_dim_type>(type), first, n);\n  return manage(res);\n}\n\npw_qpolynomial pw_qpolynomial::split_periods(int max_periods) const\n{\n  auto res = isl_pw_qpolynomial_split_periods(copy(), max_periods);\n  return manage(res);\n}\n\npw_qpolynomial pw_qpolynomial::sub(pw_qpolynomial pwqp2) const\n{\n  auto res = isl_pw_qpolynomial_sub(copy(), pwqp2.release());\n  return manage(res);\n}\n\npw_qpolynomial pw_qpolynomial::subtract_domain(set set) const\n{\n  auto res = isl_pw_qpolynomial_subtract_domain(copy(), set.release());\n  return manage(res);\n}\n\npw_qpolynomial pw_qpolynomial::to_polynomial(int sign) const\n{\n  auto res = isl_pw_qpolynomial_to_polynomial(copy(), sign);\n  return manage(res);\n}\n\npw_qpolynomial pw_qpolynomial::zero(space space)\n{\n  auto res = isl_pw_qpolynomial_zero(space.release());\n  return manage(res);\n}\n\n// implementations for isl::pw_qpolynomial_fold_list\npw_qpolynomial_fold_list manage(__isl_take isl_pw_qpolynomial_fold_list *ptr) {\n  return pw_qpolynomial_fold_list(ptr);\n}\npw_qpolynomial_fold_list manage_copy(__isl_keep isl_pw_qpolynomial_fold_list *ptr) {\n  ptr = isl_pw_qpolynomial_fold_list_copy(ptr);\n  return pw_qpolynomial_fold_list(ptr);\n}\n\npw_qpolynomial_fold_list::pw_qpolynomial_fold_list()\n    : ptr(nullptr) {}\n\npw_qpolynomial_fold_list::pw_qpolynomial_fold_list(const pw_qpolynomial_fold_list &obj)\n    : ptr(nullptr)\n{\n  ptr = obj.copy();\n}\npw_qpolynomial_fold_list::pw_qpolynomial_fold_list(std::nullptr_t)\n    : ptr(nullptr) {}\n\n\npw_qpolynomial_fold_list::pw_qpolynomial_fold_list(__isl_take isl_pw_qpolynomial_fold_list *ptr)\n    : ptr(ptr) {}\n\n\npw_qpolynomial_fold_list &pw_qpolynomial_fold_list::operator=(pw_qpolynomial_fold_list obj) {\n  std::swap(this->ptr, obj.ptr);\n  return *this;\n}\n\npw_qpolynomial_fold_list::~pw_qpolynomial_fold_list() {\n  if (ptr)\n    isl_pw_qpolynomial_fold_list_free(ptr);\n}\n\n__isl_give isl_pw_qpolynomial_fold_list *pw_qpolynomial_fold_list::copy() const & {\n  return isl_pw_qpolynomial_fold_list_copy(ptr);\n}\n\n__isl_keep isl_pw_qpolynomial_fold_list *pw_qpolynomial_fold_list::get() const {\n  return ptr;\n}\n\n__isl_give isl_pw_qpolynomial_fold_list *pw_qpolynomial_fold_list::release() {\n  isl_pw_qpolynomial_fold_list *tmp = ptr;\n  ptr = nullptr;\n  return tmp;\n}\n\nbool pw_qpolynomial_fold_list::is_null() const {\n  return ptr == nullptr;\n}\npw_qpolynomial_fold_list::operator bool() const {\n  return !is_null();\n}\n\n\nctx pw_qpolynomial_fold_list::get_ctx() const {\n  return ctx(isl_pw_qpolynomial_fold_list_get_ctx(ptr));\n}\nstd::string pw_qpolynomial_fold_list::to_str() const {\n  char *Tmp = isl_pw_qpolynomial_fold_list_to_str(get());\n  if (!Tmp)\n    return \"\";\n  std::string S(Tmp);\n  free(Tmp);\n  return S;\n}\n\n\nvoid pw_qpolynomial_fold_list::dump() const {\n  isl_pw_qpolynomial_fold_list_dump(get());\n}\n\n\n\n// implementations for isl::pw_qpolynomial_list\npw_qpolynomial_list manage(__isl_take isl_pw_qpolynomial_list *ptr) {\n  return pw_qpolynomial_list(ptr);\n}\npw_qpolynomial_list manage_copy(__isl_keep isl_pw_qpolynomial_list *ptr) {\n  ptr = isl_pw_qpolynomial_list_copy(ptr);\n  return pw_qpolynomial_list(ptr);\n}\n\npw_qpolynomial_list::pw_qpolynomial_list()\n    : ptr(nullptr) {}\n\npw_qpolynomial_list::pw_qpolynomial_list(const pw_qpolynomial_list &obj)\n    : ptr(nullptr)\n{\n  ptr = obj.copy();\n}\npw_qpolynomial_list::pw_qpolynomial_list(std::nullptr_t)\n    : ptr(nullptr) {}\n\n\npw_qpolynomial_list::pw_qpolynomial_list(__isl_take isl_pw_qpolynomial_list *ptr)\n    : ptr(ptr) {}\n\n\npw_qpolynomial_list &pw_qpolynomial_list::operator=(pw_qpolynomial_list obj) {\n  std::swap(this->ptr, obj.ptr);\n  return *this;\n}\n\npw_qpolynomial_list::~pw_qpolynomial_list() {\n  if (ptr)\n    isl_pw_qpolynomial_list_free(ptr);\n}\n\n__isl_give isl_pw_qpolynomial_list *pw_qpolynomial_list::copy() const & {\n  return isl_pw_qpolynomial_list_copy(ptr);\n}\n\n__isl_keep isl_pw_qpolynomial_list *pw_qpolynomial_list::get() const {\n  return ptr;\n}\n\n__isl_give isl_pw_qpolynomial_list *pw_qpolynomial_list::release() {\n  isl_pw_qpolynomial_list *tmp = ptr;\n  ptr = nullptr;\n  return tmp;\n}\n\nbool pw_qpolynomial_list::is_null() const {\n  return ptr == nullptr;\n}\npw_qpolynomial_list::operator bool() const {\n  return !is_null();\n}\n\n\nctx pw_qpolynomial_list::get_ctx() const {\n  return ctx(isl_pw_qpolynomial_list_get_ctx(ptr));\n}\nstd::string pw_qpolynomial_list::to_str() const {\n  char *Tmp = isl_pw_qpolynomial_list_to_str(get());\n  if (!Tmp)\n    return \"\";\n  std::string S(Tmp);\n  free(Tmp);\n  return S;\n}\n\n\nvoid pw_qpolynomial_list::dump() const {\n  isl_pw_qpolynomial_list_dump(get());\n}\n\n\npw_qpolynomial_list pw_qpolynomial_list::add(pw_qpolynomial el) const\n{\n  auto res = isl_pw_qpolynomial_list_add(copy(), el.release());\n  return manage(res);\n}\n\npw_qpolynomial_list pw_qpolynomial_list::alloc(ctx ctx, int n)\n{\n  auto res = isl_pw_qpolynomial_list_alloc(ctx.release(), n);\n  return manage(res);\n}\n\npw_qpolynomial_list pw_qpolynomial_list::clear() const\n{\n  auto res = isl_pw_qpolynomial_list_clear(copy());\n  return manage(res);\n}\n\npw_qpolynomial_list pw_qpolynomial_list::concat(pw_qpolynomial_list list2) const\n{\n  auto res = isl_pw_qpolynomial_list_concat(copy(), list2.release());\n  return manage(res);\n}\n\npw_qpolynomial_list pw_qpolynomial_list::drop(unsigned int first, unsigned int n) const\n{\n  auto res = isl_pw_qpolynomial_list_drop(copy(), first, n);\n  return manage(res);\n}\n\nstat pw_qpolynomial_list::foreach(const std::function<stat(pw_qpolynomial)> &fn) const\n{\n  struct fn_data {\n    const std::function<stat(pw_qpolynomial)> *func;\n  } fn_data = { &fn };\n  auto fn_lambda = [](isl_pw_qpolynomial *arg_0, void *arg_1) -> isl_stat {\n    auto *data = static_cast<struct fn_data *>(arg_1);\n    stat ret = (*data->func)(manage(arg_0));\n    return ret.release();\n  };\n  auto res = isl_pw_qpolynomial_list_foreach(get(), fn_lambda, &fn_data);\n  return manage(res);\n}\n\npw_qpolynomial_list pw_qpolynomial_list::from_pw_qpolynomial(pw_qpolynomial el)\n{\n  auto res = isl_pw_qpolynomial_list_from_pw_qpolynomial(el.release());\n  return manage(res);\n}\n\npw_qpolynomial pw_qpolynomial_list::get_at(int index) const\n{\n  auto res = isl_pw_qpolynomial_list_get_at(get(), index);\n  return manage(res);\n}\n\npw_qpolynomial pw_qpolynomial_list::get_pw_qpolynomial(int index) const\n{\n  auto res = isl_pw_qpolynomial_list_get_pw_qpolynomial(get(), index);\n  return manage(res);\n}\n\npw_qpolynomial_list pw_qpolynomial_list::insert(unsigned int pos, pw_qpolynomial el) const\n{\n  auto res = isl_pw_qpolynomial_list_insert(copy(), pos, el.release());\n  return manage(res);\n}\n\nisl_size pw_qpolynomial_list::n_pw_qpolynomial() const\n{\n  auto res = isl_pw_qpolynomial_list_n_pw_qpolynomial(get());\n  return res;\n}\n\npw_qpolynomial_list pw_qpolynomial_list::reverse() const\n{\n  auto res = isl_pw_qpolynomial_list_reverse(copy());\n  return manage(res);\n}\n\npw_qpolynomial_list pw_qpolynomial_list::set_pw_qpolynomial(int index, pw_qpolynomial el) const\n{\n  auto res = isl_pw_qpolynomial_list_set_pw_qpolynomial(copy(), index, el.release());\n  return manage(res);\n}\n\nisl_size pw_qpolynomial_list::size() const\n{\n  auto res = isl_pw_qpolynomial_list_size(get());\n  return res;\n}\n\npw_qpolynomial_list pw_qpolynomial_list::swap(unsigned int pos1, unsigned int pos2) const\n{\n  auto res = isl_pw_qpolynomial_list_swap(copy(), pos1, pos2);\n  return manage(res);\n}\n\n// implementations for isl::qpolynomial\nqpolynomial manage(__isl_take isl_qpolynomial *ptr) {\n  return qpolynomial(ptr);\n}\nqpolynomial manage_copy(__isl_keep isl_qpolynomial *ptr) {\n  ptr = isl_qpolynomial_copy(ptr);\n  return qpolynomial(ptr);\n}\n\nqpolynomial::qpolynomial()\n    : ptr(nullptr) {}\n\nqpolynomial::qpolynomial(const qpolynomial &obj)\n    : ptr(nullptr)\n{\n  ptr = obj.copy();\n}\nqpolynomial::qpolynomial(std::nullptr_t)\n    : ptr(nullptr) {}\n\n\nqpolynomial::qpolynomial(__isl_take isl_qpolynomial *ptr)\n    : ptr(ptr) {}\n\n\nqpolynomial &qpolynomial::operator=(qpolynomial obj) {\n  std::swap(this->ptr, obj.ptr);\n  return *this;\n}\n\nqpolynomial::~qpolynomial() {\n  if (ptr)\n    isl_qpolynomial_free(ptr);\n}\n\n__isl_give isl_qpolynomial *qpolynomial::copy() const & {\n  return isl_qpolynomial_copy(ptr);\n}\n\n__isl_keep isl_qpolynomial *qpolynomial::get() const {\n  return ptr;\n}\n\n__isl_give isl_qpolynomial *qpolynomial::release() {\n  isl_qpolynomial *tmp = ptr;\n  ptr = nullptr;\n  return tmp;\n}\n\nbool qpolynomial::is_null() const {\n  return ptr == nullptr;\n}\nqpolynomial::operator bool() const {\n  return !is_null();\n}\n\n\nctx qpolynomial::get_ctx() const {\n  return ctx(isl_qpolynomial_get_ctx(ptr));\n}\n\nvoid qpolynomial::dump() const {\n  isl_qpolynomial_dump(get());\n}\n\n\nqpolynomial qpolynomial::add(qpolynomial qp2) const\n{\n  auto res = isl_qpolynomial_add(copy(), qp2.release());\n  return manage(res);\n}\n\nqpolynomial qpolynomial::add_dims(isl::dim type, unsigned int n) const\n{\n  auto res = isl_qpolynomial_add_dims(copy(), static_cast<enum isl_dim_type>(type), n);\n  return manage(res);\n}\n\nqpolynomial qpolynomial::align_params(space model) const\n{\n  auto res = isl_qpolynomial_align_params(copy(), model.release());\n  return manage(res);\n}\n\nstat qpolynomial::as_polynomial_on_domain(const basic_set &bset, const std::function<stat(basic_set, qpolynomial)> &fn) const\n{\n  struct fn_data {\n    const std::function<stat(basic_set, qpolynomial)> *func;\n  } fn_data = { &fn };\n  auto fn_lambda = [](isl_basic_set *arg_0, isl_qpolynomial *arg_1, void *arg_2) -> isl_stat {\n    auto *data = static_cast<struct fn_data *>(arg_2);\n    stat ret = (*data->func)(manage(arg_0), manage(arg_1));\n    return ret.release();\n  };\n  auto res = isl_qpolynomial_as_polynomial_on_domain(get(), bset.get(), fn_lambda, &fn_data);\n  return manage(res);\n}\n\nisl_size qpolynomial::dim(isl::dim type) const\n{\n  auto res = isl_qpolynomial_dim(get(), static_cast<enum isl_dim_type>(type));\n  return res;\n}\n\nqpolynomial qpolynomial::drop_dims(isl::dim type, unsigned int first, unsigned int n) const\n{\n  auto res = isl_qpolynomial_drop_dims(copy(), static_cast<enum isl_dim_type>(type), first, n);\n  return manage(res);\n}\n\nval qpolynomial::eval(point pnt) const\n{\n  auto res = isl_qpolynomial_eval(copy(), pnt.release());\n  return manage(res);\n}\n\nstat qpolynomial::foreach_term(const std::function<stat(term)> &fn) const\n{\n  struct fn_data {\n    const std::function<stat(term)> *func;\n  } fn_data = { &fn };\n  auto fn_lambda = [](isl_term *arg_0, void *arg_1) -> isl_stat {\n    auto *data = static_cast<struct fn_data *>(arg_1);\n    stat ret = (*data->func)(manage(arg_0));\n    return ret.release();\n  };\n  auto res = isl_qpolynomial_foreach_term(get(), fn_lambda, &fn_data);\n  return manage(res);\n}\n\nqpolynomial qpolynomial::from_aff(aff aff)\n{\n  auto res = isl_qpolynomial_from_aff(aff.release());\n  return manage(res);\n}\n\nqpolynomial qpolynomial::from_constraint(constraint c, isl::dim type, unsigned int pos)\n{\n  auto res = isl_qpolynomial_from_constraint(c.release(), static_cast<enum isl_dim_type>(type), pos);\n  return manage(res);\n}\n\nqpolynomial qpolynomial::from_term(term term)\n{\n  auto res = isl_qpolynomial_from_term(term.release());\n  return manage(res);\n}\n\nval qpolynomial::get_constant_val() const\n{\n  auto res = isl_qpolynomial_get_constant_val(get());\n  return manage(res);\n}\n\nspace qpolynomial::get_domain_space() const\n{\n  auto res = isl_qpolynomial_get_domain_space(get());\n  return manage(res);\n}\n\nspace qpolynomial::get_space() const\n{\n  auto res = isl_qpolynomial_get_space(get());\n  return manage(res);\n}\n\nqpolynomial qpolynomial::gist(set context) const\n{\n  auto res = isl_qpolynomial_gist(copy(), context.release());\n  return manage(res);\n}\n\nqpolynomial qpolynomial::gist_params(set context) const\n{\n  auto res = isl_qpolynomial_gist_params(copy(), context.release());\n  return manage(res);\n}\n\nqpolynomial qpolynomial::homogenize() const\n{\n  auto res = isl_qpolynomial_homogenize(copy());\n  return manage(res);\n}\n\nqpolynomial qpolynomial::infty_on_domain(space domain)\n{\n  auto res = isl_qpolynomial_infty_on_domain(domain.release());\n  return manage(res);\n}\n\nqpolynomial qpolynomial::insert_dims(isl::dim type, unsigned int first, unsigned int n) const\n{\n  auto res = isl_qpolynomial_insert_dims(copy(), static_cast<enum isl_dim_type>(type), first, n);\n  return manage(res);\n}\n\nboolean qpolynomial::involves_dims(isl::dim type, unsigned int first, unsigned int n) const\n{\n  auto res = isl_qpolynomial_involves_dims(get(), static_cast<enum isl_dim_type>(type), first, n);\n  return manage(res);\n}\n\nboolean qpolynomial::is_infty() const\n{\n  auto res = isl_qpolynomial_is_infty(get());\n  return manage(res);\n}\n\nboolean qpolynomial::is_nan() const\n{\n  auto res = isl_qpolynomial_is_nan(get());\n  return manage(res);\n}\n\nboolean qpolynomial::is_neginfty() const\n{\n  auto res = isl_qpolynomial_is_neginfty(get());\n  return manage(res);\n}\n\nboolean qpolynomial::is_zero() const\n{\n  auto res = isl_qpolynomial_is_zero(get());\n  return manage(res);\n}\n\nqpolynomial qpolynomial::move_dims(isl::dim dst_type, unsigned int dst_pos, isl::dim src_type, unsigned int src_pos, unsigned int n) const\n{\n  auto res = isl_qpolynomial_move_dims(copy(), static_cast<enum isl_dim_type>(dst_type), dst_pos, static_cast<enum isl_dim_type>(src_type), src_pos, n);\n  return manage(res);\n}\n\nqpolynomial qpolynomial::mul(qpolynomial qp2) const\n{\n  auto res = isl_qpolynomial_mul(copy(), qp2.release());\n  return manage(res);\n}\n\nqpolynomial qpolynomial::nan_on_domain(space domain)\n{\n  auto res = isl_qpolynomial_nan_on_domain(domain.release());\n  return manage(res);\n}\n\nqpolynomial qpolynomial::neg() const\n{\n  auto res = isl_qpolynomial_neg(copy());\n  return manage(res);\n}\n\nqpolynomial qpolynomial::neginfty_on_domain(space domain)\n{\n  auto res = isl_qpolynomial_neginfty_on_domain(domain.release());\n  return manage(res);\n}\n\nqpolynomial qpolynomial::one_on_domain(space domain)\n{\n  auto res = isl_qpolynomial_one_on_domain(domain.release());\n  return manage(res);\n}\n\nboolean qpolynomial::plain_is_equal(const qpolynomial &qp2) const\n{\n  auto res = isl_qpolynomial_plain_is_equal(get(), qp2.get());\n  return manage(res);\n}\n\nqpolynomial qpolynomial::pow(unsigned int power) const\n{\n  auto res = isl_qpolynomial_pow(copy(), power);\n  return manage(res);\n}\n\nqpolynomial qpolynomial::project_domain_on_params() const\n{\n  auto res = isl_qpolynomial_project_domain_on_params(copy());\n  return manage(res);\n}\n\nqpolynomial qpolynomial::scale_down_val(val v) const\n{\n  auto res = isl_qpolynomial_scale_down_val(copy(), v.release());\n  return manage(res);\n}\n\nqpolynomial qpolynomial::scale_val(val v) const\n{\n  auto res = isl_qpolynomial_scale_val(copy(), v.release());\n  return manage(res);\n}\n\nint qpolynomial::sgn() const\n{\n  auto res = isl_qpolynomial_sgn(get());\n  return res;\n}\n\nqpolynomial qpolynomial::sub(qpolynomial qp2) const\n{\n  auto res = isl_qpolynomial_sub(copy(), qp2.release());\n  return manage(res);\n}\n\nqpolynomial qpolynomial::val_on_domain(space space, val val)\n{\n  auto res = isl_qpolynomial_val_on_domain(space.release(), val.release());\n  return manage(res);\n}\n\nqpolynomial qpolynomial::var_on_domain(space domain, isl::dim type, unsigned int pos)\n{\n  auto res = isl_qpolynomial_var_on_domain(domain.release(), static_cast<enum isl_dim_type>(type), pos);\n  return manage(res);\n}\n\nqpolynomial qpolynomial::zero_on_domain(space domain)\n{\n  auto res = isl_qpolynomial_zero_on_domain(domain.release());\n  return manage(res);\n}\n\n// implementations for isl::qpolynomial_list\nqpolynomial_list manage(__isl_take isl_qpolynomial_list *ptr) {\n  return qpolynomial_list(ptr);\n}\nqpolynomial_list manage_copy(__isl_keep isl_qpolynomial_list *ptr) {\n  ptr = isl_qpolynomial_list_copy(ptr);\n  return qpolynomial_list(ptr);\n}\n\nqpolynomial_list::qpolynomial_list()\n    : ptr(nullptr) {}\n\nqpolynomial_list::qpolynomial_list(const qpolynomial_list &obj)\n    : ptr(nullptr)\n{\n  ptr = obj.copy();\n}\nqpolynomial_list::qpolynomial_list(std::nullptr_t)\n    : ptr(nullptr) {}\n\n\nqpolynomial_list::qpolynomial_list(__isl_take isl_qpolynomial_list *ptr)\n    : ptr(ptr) {}\n\n\nqpolynomial_list &qpolynomial_list::operator=(qpolynomial_list obj) {\n  std::swap(this->ptr, obj.ptr);\n  return *this;\n}\n\nqpolynomial_list::~qpolynomial_list() {\n  if (ptr)\n    isl_qpolynomial_list_free(ptr);\n}\n\n__isl_give isl_qpolynomial_list *qpolynomial_list::copy() const & {\n  return isl_qpolynomial_list_copy(ptr);\n}\n\n__isl_keep isl_qpolynomial_list *qpolynomial_list::get() const {\n  return ptr;\n}\n\n__isl_give isl_qpolynomial_list *qpolynomial_list::release() {\n  isl_qpolynomial_list *tmp = ptr;\n  ptr = nullptr;\n  return tmp;\n}\n\nbool qpolynomial_list::is_null() const {\n  return ptr == nullptr;\n}\nqpolynomial_list::operator bool() const {\n  return !is_null();\n}\n\n\nctx qpolynomial_list::get_ctx() const {\n  return ctx(isl_qpolynomial_list_get_ctx(ptr));\n}\nstd::string qpolynomial_list::to_str() const {\n  char *Tmp = isl_qpolynomial_list_to_str(get());\n  if (!Tmp)\n    return \"\";\n  std::string S(Tmp);\n  free(Tmp);\n  return S;\n}\n\n\nvoid qpolynomial_list::dump() const {\n  isl_qpolynomial_list_dump(get());\n}\n\n\nqpolynomial_list qpolynomial_list::add(qpolynomial el) const\n{\n  auto res = isl_qpolynomial_list_add(copy(), el.release());\n  return manage(res);\n}\n\nqpolynomial_list qpolynomial_list::alloc(ctx ctx, int n)\n{\n  auto res = isl_qpolynomial_list_alloc(ctx.release(), n);\n  return manage(res);\n}\n\nqpolynomial_list qpolynomial_list::clear() const\n{\n  auto res = isl_qpolynomial_list_clear(copy());\n  return manage(res);\n}\n\nqpolynomial_list qpolynomial_list::concat(qpolynomial_list list2) const\n{\n  auto res = isl_qpolynomial_list_concat(copy(), list2.release());\n  return manage(res);\n}\n\nqpolynomial_list qpolynomial_list::drop(unsigned int first, unsigned int n) const\n{\n  auto res = isl_qpolynomial_list_drop(copy(), first, n);\n  return manage(res);\n}\n\nstat qpolynomial_list::foreach(const std::function<stat(qpolynomial)> &fn) const\n{\n  struct fn_data {\n    const std::function<stat(qpolynomial)> *func;\n  } fn_data = { &fn };\n  auto fn_lambda = [](isl_qpolynomial *arg_0, void *arg_1) -> isl_stat {\n    auto *data = static_cast<struct fn_data *>(arg_1);\n    stat ret = (*data->func)(manage(arg_0));\n    return ret.release();\n  };\n  auto res = isl_qpolynomial_list_foreach(get(), fn_lambda, &fn_data);\n  return manage(res);\n}\n\nqpolynomial_list qpolynomial_list::from_qpolynomial(qpolynomial el)\n{\n  auto res = isl_qpolynomial_list_from_qpolynomial(el.release());\n  return manage(res);\n}\n\nqpolynomial qpolynomial_list::get_at(int index) const\n{\n  auto res = isl_qpolynomial_list_get_at(get(), index);\n  return manage(res);\n}\n\nqpolynomial qpolynomial_list::get_qpolynomial(int index) const\n{\n  auto res = isl_qpolynomial_list_get_qpolynomial(get(), index);\n  return manage(res);\n}\n\nqpolynomial_list qpolynomial_list::insert(unsigned int pos, qpolynomial el) const\n{\n  auto res = isl_qpolynomial_list_insert(copy(), pos, el.release());\n  return manage(res);\n}\n\nisl_size qpolynomial_list::n_qpolynomial() const\n{\n  auto res = isl_qpolynomial_list_n_qpolynomial(get());\n  return res;\n}\n\nqpolynomial_list qpolynomial_list::reverse() const\n{\n  auto res = isl_qpolynomial_list_reverse(copy());\n  return manage(res);\n}\n\nqpolynomial_list qpolynomial_list::set_qpolynomial(int index, qpolynomial el) const\n{\n  auto res = isl_qpolynomial_list_set_qpolynomial(copy(), index, el.release());\n  return manage(res);\n}\n\nisl_size qpolynomial_list::size() const\n{\n  auto res = isl_qpolynomial_list_size(get());\n  return res;\n}\n\nqpolynomial_list qpolynomial_list::swap(unsigned int pos1, unsigned int pos2) const\n{\n  auto res = isl_qpolynomial_list_swap(copy(), pos1, pos2);\n  return manage(res);\n}\n\n// implementations for isl::schedule\nschedule manage(__isl_take isl_schedule *ptr) {\n  return schedule(ptr);\n}\nschedule manage_copy(__isl_keep isl_schedule *ptr) {\n  ptr = isl_schedule_copy(ptr);\n  return schedule(ptr);\n}\n\nschedule::schedule()\n    : ptr(nullptr) {}\n\nschedule::schedule(const schedule &obj)\n    : ptr(nullptr)\n{\n  ptr = obj.copy();\n}\nschedule::schedule(std::nullptr_t)\n    : ptr(nullptr) {}\n\n\nschedule::schedule(__isl_take isl_schedule *ptr)\n    : ptr(ptr) {}\n\nschedule::schedule(ctx ctx, const std::string &str)\n{\n  auto res = isl_schedule_read_from_str(ctx.release(), str.c_str());\n  ptr = res;\n}\n\nschedule &schedule::operator=(schedule obj) {\n  std::swap(this->ptr, obj.ptr);\n  return *this;\n}\n\nschedule::~schedule() {\n  if (ptr)\n    isl_schedule_free(ptr);\n}\n\n__isl_give isl_schedule *schedule::copy() const & {\n  return isl_schedule_copy(ptr);\n}\n\n__isl_keep isl_schedule *schedule::get() const {\n  return ptr;\n}\n\n__isl_give isl_schedule *schedule::release() {\n  isl_schedule *tmp = ptr;\n  ptr = nullptr;\n  return tmp;\n}\n\nbool schedule::is_null() const {\n  return ptr == nullptr;\n}\nschedule::operator bool() const {\n  return !is_null();\n}\n\n\nctx schedule::get_ctx() const {\n  return ctx(isl_schedule_get_ctx(ptr));\n}\nstd::string schedule::to_str() const {\n  char *Tmp = isl_schedule_to_str(get());\n  if (!Tmp)\n    return \"\";\n  std::string S(Tmp);\n  free(Tmp);\n  return S;\n}\n\n\nvoid schedule::dump() const {\n  isl_schedule_dump(get());\n}\n\n\nschedule schedule::align_params(space space) const\n{\n  auto res = isl_schedule_align_params(copy(), space.release());\n  return manage(res);\n}\n\nschedule schedule::empty(space space)\n{\n  auto res = isl_schedule_empty(space.release());\n  return manage(res);\n}\n\nschedule schedule::from_domain(union_set domain)\n{\n  auto res = isl_schedule_from_domain(domain.release());\n  return manage(res);\n}\n\nunion_set schedule::get_domain() const\n{\n  auto res = isl_schedule_get_domain(get());\n  return manage(res);\n}\n\nunion_map schedule::get_map() const\n{\n  auto res = isl_schedule_get_map(get());\n  return manage(res);\n}\n\nschedule_node schedule::get_root() const\n{\n  auto res = isl_schedule_get_root(get());\n  return manage(res);\n}\n\nschedule schedule::gist_domain_params(set context) const\n{\n  auto res = isl_schedule_gist_domain_params(copy(), context.release());\n  return manage(res);\n}\n\nschedule schedule::insert_context(set context) const\n{\n  auto res = isl_schedule_insert_context(copy(), context.release());\n  return manage(res);\n}\n\nschedule schedule::insert_guard(set guard) const\n{\n  auto res = isl_schedule_insert_guard(copy(), guard.release());\n  return manage(res);\n}\n\nschedule schedule::insert_partial_schedule(multi_union_pw_aff partial) const\n{\n  auto res = isl_schedule_insert_partial_schedule(copy(), partial.release());\n  return manage(res);\n}\n\nschedule schedule::intersect_domain(union_set domain) const\n{\n  auto res = isl_schedule_intersect_domain(copy(), domain.release());\n  return manage(res);\n}\n\nboolean schedule::plain_is_equal(const schedule &schedule2) const\n{\n  auto res = isl_schedule_plain_is_equal(get(), schedule2.get());\n  return manage(res);\n}\n\nschedule schedule::pullback(union_pw_multi_aff upma) const\n{\n  auto res = isl_schedule_pullback_union_pw_multi_aff(copy(), upma.release());\n  return manage(res);\n}\n\nschedule schedule::reset_user() const\n{\n  auto res = isl_schedule_reset_user(copy());\n  return manage(res);\n}\n\nschedule schedule::sequence(schedule schedule2) const\n{\n  auto res = isl_schedule_sequence(copy(), schedule2.release());\n  return manage(res);\n}\n\n// implementations for isl::schedule_constraints\nschedule_constraints manage(__isl_take isl_schedule_constraints *ptr) {\n  return schedule_constraints(ptr);\n}\nschedule_constraints manage_copy(__isl_keep isl_schedule_constraints *ptr) {\n  ptr = isl_schedule_constraints_copy(ptr);\n  return schedule_constraints(ptr);\n}\n\nschedule_constraints::schedule_constraints()\n    : ptr(nullptr) {}\n\nschedule_constraints::schedule_constraints(const schedule_constraints &obj)\n    : ptr(nullptr)\n{\n  ptr = obj.copy();\n}\nschedule_constraints::schedule_constraints(std::nullptr_t)\n    : ptr(nullptr) {}\n\n\nschedule_constraints::schedule_constraints(__isl_take isl_schedule_constraints *ptr)\n    : ptr(ptr) {}\n\nschedule_constraints::schedule_constraints(ctx ctx, const std::string &str)\n{\n  auto res = isl_schedule_constraints_read_from_str(ctx.release(), str.c_str());\n  ptr = res;\n}\n\nschedule_constraints &schedule_constraints::operator=(schedule_constraints obj) {\n  std::swap(this->ptr, obj.ptr);\n  return *this;\n}\n\nschedule_constraints::~schedule_constraints() {\n  if (ptr)\n    isl_schedule_constraints_free(ptr);\n}\n\n__isl_give isl_schedule_constraints *schedule_constraints::copy() const & {\n  return isl_schedule_constraints_copy(ptr);\n}\n\n__isl_keep isl_schedule_constraints *schedule_constraints::get() const {\n  return ptr;\n}\n\n__isl_give isl_schedule_constraints *schedule_constraints::release() {\n  isl_schedule_constraints *tmp = ptr;\n  ptr = nullptr;\n  return tmp;\n}\n\nbool schedule_constraints::is_null() const {\n  return ptr == nullptr;\n}\nschedule_constraints::operator bool() const {\n  return !is_null();\n}\n\n\nctx schedule_constraints::get_ctx() const {\n  return ctx(isl_schedule_constraints_get_ctx(ptr));\n}\nstd::string schedule_constraints::to_str() const {\n  char *Tmp = isl_schedule_constraints_to_str(get());\n  if (!Tmp)\n    return \"\";\n  std::string S(Tmp);\n  free(Tmp);\n  return S;\n}\n\n\nvoid schedule_constraints::dump() const {\n  isl_schedule_constraints_dump(get());\n}\n\n\nschedule_constraints schedule_constraints::apply(union_map umap) const\n{\n  auto res = isl_schedule_constraints_apply(copy(), umap.release());\n  return manage(res);\n}\n\nschedule schedule_constraints::compute_schedule() const\n{\n  auto res = isl_schedule_constraints_compute_schedule(copy());\n  return manage(res);\n}\n\nunion_map schedule_constraints::get_coincidence() const\n{\n  auto res = isl_schedule_constraints_get_coincidence(get());\n  return manage(res);\n}\n\nunion_map schedule_constraints::get_conditional_validity() const\n{\n  auto res = isl_schedule_constraints_get_conditional_validity(get());\n  return manage(res);\n}\n\nunion_map schedule_constraints::get_conditional_validity_condition() const\n{\n  auto res = isl_schedule_constraints_get_conditional_validity_condition(get());\n  return manage(res);\n}\n\nset schedule_constraints::get_context() const\n{\n  auto res = isl_schedule_constraints_get_context(get());\n  return manage(res);\n}\n\nunion_set schedule_constraints::get_domain() const\n{\n  auto res = isl_schedule_constraints_get_domain(get());\n  return manage(res);\n}\n\nunion_map schedule_constraints::get_proximity() const\n{\n  auto res = isl_schedule_constraints_get_proximity(get());\n  return manage(res);\n}\n\nunion_map schedule_constraints::get_validity() const\n{\n  auto res = isl_schedule_constraints_get_validity(get());\n  return manage(res);\n}\n\nschedule_constraints schedule_constraints::on_domain(union_set domain)\n{\n  auto res = isl_schedule_constraints_on_domain(domain.release());\n  return manage(res);\n}\n\nschedule_constraints schedule_constraints::set_coincidence(union_map coincidence) const\n{\n  auto res = isl_schedule_constraints_set_coincidence(copy(), coincidence.release());\n  return manage(res);\n}\n\nschedule_constraints schedule_constraints::set_conditional_validity(union_map condition, union_map validity) const\n{\n  auto res = isl_schedule_constraints_set_conditional_validity(copy(), condition.release(), validity.release());\n  return manage(res);\n}\n\nschedule_constraints schedule_constraints::set_context(set context) const\n{\n  auto res = isl_schedule_constraints_set_context(copy(), context.release());\n  return manage(res);\n}\n\nschedule_constraints schedule_constraints::set_proximity(union_map proximity) const\n{\n  auto res = isl_schedule_constraints_set_proximity(copy(), proximity.release());\n  return manage(res);\n}\n\nschedule_constraints schedule_constraints::set_validity(union_map validity) const\n{\n  auto res = isl_schedule_constraints_set_validity(copy(), validity.release());\n  return manage(res);\n}\n\n// implementations for isl::schedule_node\nschedule_node manage(__isl_take isl_schedule_node *ptr) {\n  return schedule_node(ptr);\n}\nschedule_node manage_copy(__isl_keep isl_schedule_node *ptr) {\n  ptr = isl_schedule_node_copy(ptr);\n  return schedule_node(ptr);\n}\n\nschedule_node::schedule_node()\n    : ptr(nullptr) {}\n\nschedule_node::schedule_node(const schedule_node &obj)\n    : ptr(nullptr)\n{\n  ptr = obj.copy();\n}\nschedule_node::schedule_node(std::nullptr_t)\n    : ptr(nullptr) {}\n\n\nschedule_node::schedule_node(__isl_take isl_schedule_node *ptr)\n    : ptr(ptr) {}\n\n\nschedule_node &schedule_node::operator=(schedule_node obj) {\n  std::swap(this->ptr, obj.ptr);\n  return *this;\n}\n\nschedule_node::~schedule_node() {\n  if (ptr)\n    isl_schedule_node_free(ptr);\n}\n\n__isl_give isl_schedule_node *schedule_node::copy() const & {\n  return isl_schedule_node_copy(ptr);\n}\n\n__isl_keep isl_schedule_node *schedule_node::get() const {\n  return ptr;\n}\n\n__isl_give isl_schedule_node *schedule_node::release() {\n  isl_schedule_node *tmp = ptr;\n  ptr = nullptr;\n  return tmp;\n}\n\nbool schedule_node::is_null() const {\n  return ptr == nullptr;\n}\nschedule_node::operator bool() const {\n  return !is_null();\n}\n\n\nctx schedule_node::get_ctx() const {\n  return ctx(isl_schedule_node_get_ctx(ptr));\n}\nstd::string schedule_node::to_str() const {\n  char *Tmp = isl_schedule_node_to_str(get());\n  if (!Tmp)\n    return \"\";\n  std::string S(Tmp);\n  free(Tmp);\n  return S;\n}\n\n\nvoid schedule_node::dump() const {\n  isl_schedule_node_dump(get());\n}\n\n\nschedule_node schedule_node::align_params(space space) const\n{\n  auto res = isl_schedule_node_align_params(copy(), space.release());\n  return manage(res);\n}\n\nschedule_node schedule_node::ancestor(int generation) const\n{\n  auto res = isl_schedule_node_ancestor(copy(), generation);\n  return manage(res);\n}\n\nboolean schedule_node::band_member_get_coincident(int pos) const\n{\n  auto res = isl_schedule_node_band_member_get_coincident(get(), pos);\n  return manage(res);\n}\n\nschedule_node schedule_node::band_member_set_coincident(int pos, int coincident) const\n{\n  auto res = isl_schedule_node_band_member_set_coincident(copy(), pos, coincident);\n  return manage(res);\n}\n\nschedule_node schedule_node::band_set_ast_build_options(union_set options) const\n{\n  auto res = isl_schedule_node_band_set_ast_build_options(copy(), options.release());\n  return manage(res);\n}\n\nschedule_node schedule_node::child(int pos) const\n{\n  auto res = isl_schedule_node_child(copy(), pos);\n  return manage(res);\n}\n\nset schedule_node::context_get_context() const\n{\n  auto res = isl_schedule_node_context_get_context(get());\n  return manage(res);\n}\n\nschedule_node schedule_node::cut() const\n{\n  auto res = isl_schedule_node_cut(copy());\n  return manage(res);\n}\n\nunion_set schedule_node::domain_get_domain() const\n{\n  auto res = isl_schedule_node_domain_get_domain(get());\n  return manage(res);\n}\n\nunion_pw_multi_aff schedule_node::expansion_get_contraction() const\n{\n  auto res = isl_schedule_node_expansion_get_contraction(get());\n  return manage(res);\n}\n\nunion_map schedule_node::expansion_get_expansion() const\n{\n  auto res = isl_schedule_node_expansion_get_expansion(get());\n  return manage(res);\n}\n\nunion_map schedule_node::extension_get_extension() const\n{\n  auto res = isl_schedule_node_extension_get_extension(get());\n  return manage(res);\n}\n\nunion_set schedule_node::filter_get_filter() const\n{\n  auto res = isl_schedule_node_filter_get_filter(get());\n  return manage(res);\n}\n\nschedule_node schedule_node::first_child() const\n{\n  auto res = isl_schedule_node_first_child(copy());\n  return manage(res);\n}\n\nstat schedule_node::foreach_ancestor_top_down(const std::function<stat(schedule_node)> &fn) const\n{\n  struct fn_data {\n    const std::function<stat(schedule_node)> *func;\n  } fn_data = { &fn };\n  auto fn_lambda = [](isl_schedule_node *arg_0, void *arg_1) -> isl_stat {\n    auto *data = static_cast<struct fn_data *>(arg_1);\n    stat ret = (*data->func)(manage_copy(arg_0));\n    return ret.release();\n  };\n  auto res = isl_schedule_node_foreach_ancestor_top_down(get(), fn_lambda, &fn_data);\n  return manage(res);\n}\n\nschedule_node schedule_node::from_domain(union_set domain)\n{\n  auto res = isl_schedule_node_from_domain(domain.release());\n  return manage(res);\n}\n\nschedule_node schedule_node::from_extension(union_map extension)\n{\n  auto res = isl_schedule_node_from_extension(extension.release());\n  return manage(res);\n}\n\nisl_size schedule_node::get_ancestor_child_position(const schedule_node &ancestor) const\n{\n  auto res = isl_schedule_node_get_ancestor_child_position(get(), ancestor.get());\n  return res;\n}\n\nschedule_node schedule_node::get_child(int pos) const\n{\n  auto res = isl_schedule_node_get_child(get(), pos);\n  return manage(res);\n}\n\nisl_size schedule_node::get_child_position() const\n{\n  auto res = isl_schedule_node_get_child_position(get());\n  return res;\n}\n\nunion_set schedule_node::get_domain() const\n{\n  auto res = isl_schedule_node_get_domain(get());\n  return manage(res);\n}\n\nmulti_union_pw_aff schedule_node::get_prefix_schedule_multi_union_pw_aff() const\n{\n  auto res = isl_schedule_node_get_prefix_schedule_multi_union_pw_aff(get());\n  return manage(res);\n}\n\nunion_map schedule_node::get_prefix_schedule_relation() const\n{\n  auto res = isl_schedule_node_get_prefix_schedule_relation(get());\n  return manage(res);\n}\n\nunion_map schedule_node::get_prefix_schedule_union_map() const\n{\n  auto res = isl_schedule_node_get_prefix_schedule_union_map(get());\n  return manage(res);\n}\n\nunion_pw_multi_aff schedule_node::get_prefix_schedule_union_pw_multi_aff() const\n{\n  auto res = isl_schedule_node_get_prefix_schedule_union_pw_multi_aff(get());\n  return manage(res);\n}\n\nschedule schedule_node::get_schedule() const\n{\n  auto res = isl_schedule_node_get_schedule(get());\n  return manage(res);\n}\n\nisl_size schedule_node::get_schedule_depth() const\n{\n  auto res = isl_schedule_node_get_schedule_depth(get());\n  return res;\n}\n\nschedule_node schedule_node::get_shared_ancestor(const schedule_node &node2) const\n{\n  auto res = isl_schedule_node_get_shared_ancestor(get(), node2.get());\n  return manage(res);\n}\n\nunion_pw_multi_aff schedule_node::get_subtree_contraction() const\n{\n  auto res = isl_schedule_node_get_subtree_contraction(get());\n  return manage(res);\n}\n\nunion_map schedule_node::get_subtree_expansion() const\n{\n  auto res = isl_schedule_node_get_subtree_expansion(get());\n  return manage(res);\n}\n\nunion_map schedule_node::get_subtree_schedule_union_map() const\n{\n  auto res = isl_schedule_node_get_subtree_schedule_union_map(get());\n  return manage(res);\n}\n\nisl_size schedule_node::get_tree_depth() const\n{\n  auto res = isl_schedule_node_get_tree_depth(get());\n  return res;\n}\n\nunion_set schedule_node::get_universe_domain() const\n{\n  auto res = isl_schedule_node_get_universe_domain(get());\n  return manage(res);\n}\n\nschedule_node schedule_node::graft_after(schedule_node graft) const\n{\n  auto res = isl_schedule_node_graft_after(copy(), graft.release());\n  return manage(res);\n}\n\nschedule_node schedule_node::graft_before(schedule_node graft) const\n{\n  auto res = isl_schedule_node_graft_before(copy(), graft.release());\n  return manage(res);\n}\n\nschedule_node schedule_node::group(id group_id) const\n{\n  auto res = isl_schedule_node_group(copy(), group_id.release());\n  return manage(res);\n}\n\nset schedule_node::guard_get_guard() const\n{\n  auto res = isl_schedule_node_guard_get_guard(get());\n  return manage(res);\n}\n\nboolean schedule_node::has_children() const\n{\n  auto res = isl_schedule_node_has_children(get());\n  return manage(res);\n}\n\nboolean schedule_node::has_next_sibling() const\n{\n  auto res = isl_schedule_node_has_next_sibling(get());\n  return manage(res);\n}\n\nboolean schedule_node::has_parent() const\n{\n  auto res = isl_schedule_node_has_parent(get());\n  return manage(res);\n}\n\nboolean schedule_node::has_previous_sibling() const\n{\n  auto res = isl_schedule_node_has_previous_sibling(get());\n  return manage(res);\n}\n\nschedule_node schedule_node::insert_context(set context) const\n{\n  auto res = isl_schedule_node_insert_context(copy(), context.release());\n  return manage(res);\n}\n\nschedule_node schedule_node::insert_filter(union_set filter) const\n{\n  auto res = isl_schedule_node_insert_filter(copy(), filter.release());\n  return manage(res);\n}\n\nschedule_node schedule_node::insert_guard(set context) const\n{\n  auto res = isl_schedule_node_insert_guard(copy(), context.release());\n  return manage(res);\n}\n\nschedule_node schedule_node::insert_mark(id mark) const\n{\n  auto res = isl_schedule_node_insert_mark(copy(), mark.release());\n  return manage(res);\n}\n\nschedule_node schedule_node::insert_partial_schedule(multi_union_pw_aff schedule) const\n{\n  auto res = isl_schedule_node_insert_partial_schedule(copy(), schedule.release());\n  return manage(res);\n}\n\nschedule_node schedule_node::insert_sequence(union_set_list filters) const\n{\n  auto res = isl_schedule_node_insert_sequence(copy(), filters.release());\n  return manage(res);\n}\n\nschedule_node schedule_node::insert_set(union_set_list filters) const\n{\n  auto res = isl_schedule_node_insert_set(copy(), filters.release());\n  return manage(res);\n}\n\nboolean schedule_node::is_equal(const schedule_node &node2) const\n{\n  auto res = isl_schedule_node_is_equal(get(), node2.get());\n  return manage(res);\n}\n\nboolean schedule_node::is_subtree_anchored() const\n{\n  auto res = isl_schedule_node_is_subtree_anchored(get());\n  return manage(res);\n}\n\nid schedule_node::mark_get_id() const\n{\n  auto res = isl_schedule_node_mark_get_id(get());\n  return manage(res);\n}\n\nisl_size schedule_node::n_children() const\n{\n  auto res = isl_schedule_node_n_children(get());\n  return res;\n}\n\nschedule_node schedule_node::next_sibling() const\n{\n  auto res = isl_schedule_node_next_sibling(copy());\n  return manage(res);\n}\n\nschedule_node schedule_node::order_after(union_set filter) const\n{\n  auto res = isl_schedule_node_order_after(copy(), filter.release());\n  return manage(res);\n}\n\nschedule_node schedule_node::order_before(union_set filter) const\n{\n  auto res = isl_schedule_node_order_before(copy(), filter.release());\n  return manage(res);\n}\n\nschedule_node schedule_node::parent() const\n{\n  auto res = isl_schedule_node_parent(copy());\n  return manage(res);\n}\n\nschedule_node schedule_node::previous_sibling() const\n{\n  auto res = isl_schedule_node_previous_sibling(copy());\n  return manage(res);\n}\n\nschedule_node schedule_node::reset_user() const\n{\n  auto res = isl_schedule_node_reset_user(copy());\n  return manage(res);\n}\n\nschedule_node schedule_node::root() const\n{\n  auto res = isl_schedule_node_root(copy());\n  return manage(res);\n}\n\nschedule_node schedule_node::sequence_splice_child(int pos) const\n{\n  auto res = isl_schedule_node_sequence_splice_child(copy(), pos);\n  return manage(res);\n}\n\n// implementations for isl::set\nset manage(__isl_take isl_set *ptr) {\n  return set(ptr);\n}\nset manage_copy(__isl_keep isl_set *ptr) {\n  ptr = isl_set_copy(ptr);\n  return set(ptr);\n}\n\nset::set()\n    : ptr(nullptr) {}\n\nset::set(const set &obj)\n    : ptr(nullptr)\n{\n  ptr = obj.copy();\n}\nset::set(std::nullptr_t)\n    : ptr(nullptr) {}\n\n\nset::set(__isl_take isl_set *ptr)\n    : ptr(ptr) {}\n\nset::set(basic_set bset)\n{\n  auto res = isl_set_from_basic_set(bset.release());\n  ptr = res;\n}\nset::set(point pnt)\n{\n  auto res = isl_set_from_point(pnt.release());\n  ptr = res;\n}\nset::set(union_set uset)\n{\n  auto res = isl_set_from_union_set(uset.release());\n  ptr = res;\n}\nset::set(ctx ctx, const std::string &str)\n{\n  auto res = isl_set_read_from_str(ctx.release(), str.c_str());\n  ptr = res;\n}\n\nset &set::operator=(set obj) {\n  std::swap(this->ptr, obj.ptr);\n  return *this;\n}\n\nset::~set() {\n  if (ptr)\n    isl_set_free(ptr);\n}\n\n__isl_give isl_set *set::copy() const & {\n  return isl_set_copy(ptr);\n}\n\n__isl_keep isl_set *set::get() const {\n  return ptr;\n}\n\n__isl_give isl_set *set::release() {\n  isl_set *tmp = ptr;\n  ptr = nullptr;\n  return tmp;\n}\n\nbool set::is_null() const {\n  return ptr == nullptr;\n}\nset::operator bool() const {\n  return !is_null();\n}\n\n\nctx set::get_ctx() const {\n  return ctx(isl_set_get_ctx(ptr));\n}\nstd::string set::to_str() const {\n  char *Tmp = isl_set_to_str(get());\n  if (!Tmp)\n    return \"\";\n  std::string S(Tmp);\n  free(Tmp);\n  return S;\n}\n\n\nvoid set::dump() const {\n  isl_set_dump(get());\n}\n\n\nset set::add_constraint(constraint constraint) const\n{\n  auto res = isl_set_add_constraint(copy(), constraint.release());\n  return manage(res);\n}\n\nset set::add_dims(isl::dim type, unsigned int n) const\n{\n  auto res = isl_set_add_dims(copy(), static_cast<enum isl_dim_type>(type), n);\n  return manage(res);\n}\n\nbasic_set set::affine_hull() const\n{\n  auto res = isl_set_affine_hull(copy());\n  return manage(res);\n}\n\nset set::align_params(space model) const\n{\n  auto res = isl_set_align_params(copy(), model.release());\n  return manage(res);\n}\n\nset set::apply(map map) const\n{\n  auto res = isl_set_apply(copy(), map.release());\n  return manage(res);\n}\n\nset set::bind(multi_id tuple) const\n{\n  auto res = isl_set_bind(copy(), tuple.release());\n  return manage(res);\n}\n\nbasic_set set::bounded_simple_hull() const\n{\n  auto res = isl_set_bounded_simple_hull(copy());\n  return manage(res);\n}\n\nset set::box_from_points(point pnt1, point pnt2)\n{\n  auto res = isl_set_box_from_points(pnt1.release(), pnt2.release());\n  return manage(res);\n}\n\nset set::coalesce() const\n{\n  auto res = isl_set_coalesce(copy());\n  return manage(res);\n}\n\nbasic_set set::coefficients() const\n{\n  auto res = isl_set_coefficients(copy());\n  return manage(res);\n}\n\nset set::complement() const\n{\n  auto res = isl_set_complement(copy());\n  return manage(res);\n}\n\nbasic_set set::convex_hull() const\n{\n  auto res = isl_set_convex_hull(copy());\n  return manage(res);\n}\n\nval set::count_val() const\n{\n  auto res = isl_set_count_val(get());\n  return manage(res);\n}\n\nset set::detect_equalities() const\n{\n  auto res = isl_set_detect_equalities(copy());\n  return manage(res);\n}\n\nisl_size set::dim(isl::dim type) const\n{\n  auto res = isl_set_dim(get(), static_cast<enum isl_dim_type>(type));\n  return res;\n}\n\nboolean set::dim_has_any_lower_bound(isl::dim type, unsigned int pos) const\n{\n  auto res = isl_set_dim_has_any_lower_bound(get(), static_cast<enum isl_dim_type>(type), pos);\n  return manage(res);\n}\n\nboolean set::dim_has_any_upper_bound(isl::dim type, unsigned int pos) const\n{\n  auto res = isl_set_dim_has_any_upper_bound(get(), static_cast<enum isl_dim_type>(type), pos);\n  return manage(res);\n}\n\nboolean set::dim_has_lower_bound(isl::dim type, unsigned int pos) const\n{\n  auto res = isl_set_dim_has_lower_bound(get(), static_cast<enum isl_dim_type>(type), pos);\n  return manage(res);\n}\n\nboolean set::dim_has_upper_bound(isl::dim type, unsigned int pos) const\n{\n  auto res = isl_set_dim_has_upper_bound(get(), static_cast<enum isl_dim_type>(type), pos);\n  return manage(res);\n}\n\nboolean set::dim_is_bounded(isl::dim type, unsigned int pos) const\n{\n  auto res = isl_set_dim_is_bounded(get(), static_cast<enum isl_dim_type>(type), pos);\n  return manage(res);\n}\n\npw_aff set::dim_max(int pos) const\n{\n  auto res = isl_set_dim_max(copy(), pos);\n  return manage(res);\n}\n\nval set::dim_max_val(int pos) const\n{\n  auto res = isl_set_dim_max_val(copy(), pos);\n  return manage(res);\n}\n\npw_aff set::dim_min(int pos) const\n{\n  auto res = isl_set_dim_min(copy(), pos);\n  return manage(res);\n}\n\nval set::dim_min_val(int pos) const\n{\n  auto res = isl_set_dim_min_val(copy(), pos);\n  return manage(res);\n}\n\nset set::drop_constraints_involving_dims(isl::dim type, unsigned int first, unsigned int n) const\n{\n  auto res = isl_set_drop_constraints_involving_dims(copy(), static_cast<enum isl_dim_type>(type), first, n);\n  return manage(res);\n}\n\nset set::drop_constraints_not_involving_dims(isl::dim type, unsigned int first, unsigned int n) const\n{\n  auto res = isl_set_drop_constraints_not_involving_dims(copy(), static_cast<enum isl_dim_type>(type), first, n);\n  return manage(res);\n}\n\nset set::drop_unused_params() const\n{\n  auto res = isl_set_drop_unused_params(copy());\n  return manage(res);\n}\n\nset set::eliminate(isl::dim type, unsigned int first, unsigned int n) const\n{\n  auto res = isl_set_eliminate(copy(), static_cast<enum isl_dim_type>(type), first, n);\n  return manage(res);\n}\n\nset set::empty(space space)\n{\n  auto res = isl_set_empty(space.release());\n  return manage(res);\n}\n\nset set::equate(isl::dim type1, int pos1, isl::dim type2, int pos2) const\n{\n  auto res = isl_set_equate(copy(), static_cast<enum isl_dim_type>(type1), pos1, static_cast<enum isl_dim_type>(type2), pos2);\n  return manage(res);\n}\n\nint set::find_dim_by_id(isl::dim type, const id &id) const\n{\n  auto res = isl_set_find_dim_by_id(get(), static_cast<enum isl_dim_type>(type), id.get());\n  return res;\n}\n\nint set::find_dim_by_name(isl::dim type, const std::string &name) const\n{\n  auto res = isl_set_find_dim_by_name(get(), static_cast<enum isl_dim_type>(type), name.c_str());\n  return res;\n}\n\nset set::fix_si(isl::dim type, unsigned int pos, int value) const\n{\n  auto res = isl_set_fix_si(copy(), static_cast<enum isl_dim_type>(type), pos, value);\n  return manage(res);\n}\n\nset set::fix_val(isl::dim type, unsigned int pos, val v) const\n{\n  auto res = isl_set_fix_val(copy(), static_cast<enum isl_dim_type>(type), pos, v.release());\n  return manage(res);\n}\n\nset set::flat_product(set set2) const\n{\n  auto res = isl_set_flat_product(copy(), set2.release());\n  return manage(res);\n}\n\nset set::flatten() const\n{\n  auto res = isl_set_flatten(copy());\n  return manage(res);\n}\n\nmap set::flatten_map() const\n{\n  auto res = isl_set_flatten_map(copy());\n  return manage(res);\n}\n\nint set::follows_at(const set &set2, int pos) const\n{\n  auto res = isl_set_follows_at(get(), set2.get(), pos);\n  return res;\n}\n\nstat set::foreach_basic_set(const std::function<stat(basic_set)> &fn) const\n{\n  struct fn_data {\n    const std::function<stat(basic_set)> *func;\n  } fn_data = { &fn };\n  auto fn_lambda = [](isl_basic_set *arg_0, void *arg_1) -> isl_stat {\n    auto *data = static_cast<struct fn_data *>(arg_1);\n    stat ret = (*data->func)(manage(arg_0));\n    return ret.release();\n  };\n  auto res = isl_set_foreach_basic_set(get(), fn_lambda, &fn_data);\n  return manage(res);\n}\n\nstat set::foreach_point(const std::function<stat(point)> &fn) const\n{\n  struct fn_data {\n    const std::function<stat(point)> *func;\n  } fn_data = { &fn };\n  auto fn_lambda = [](isl_point *arg_0, void *arg_1) -> isl_stat {\n    auto *data = static_cast<struct fn_data *>(arg_1);\n    stat ret = (*data->func)(manage(arg_0));\n    return ret.release();\n  };\n  auto res = isl_set_foreach_point(get(), fn_lambda, &fn_data);\n  return manage(res);\n}\n\nset set::from_multi_aff(multi_aff ma)\n{\n  auto res = isl_set_from_multi_aff(ma.release());\n  return manage(res);\n}\n\nset set::from_multi_pw_aff(multi_pw_aff mpa)\n{\n  auto res = isl_set_from_multi_pw_aff(mpa.release());\n  return manage(res);\n}\n\nset set::from_params() const\n{\n  auto res = isl_set_from_params(copy());\n  return manage(res);\n}\n\nset set::from_pw_aff(pw_aff pwaff)\n{\n  auto res = isl_set_from_pw_aff(pwaff.release());\n  return manage(res);\n}\n\nset set::from_pw_multi_aff(pw_multi_aff pma)\n{\n  auto res = isl_set_from_pw_multi_aff(pma.release());\n  return manage(res);\n}\n\nbasic_set_list set::get_basic_set_list() const\n{\n  auto res = isl_set_get_basic_set_list(get());\n  return manage(res);\n}\n\nid set::get_dim_id(isl::dim type, unsigned int pos) const\n{\n  auto res = isl_set_get_dim_id(get(), static_cast<enum isl_dim_type>(type), pos);\n  return manage(res);\n}\n\nstd::string set::get_dim_name(isl::dim type, unsigned int pos) const\n{\n  auto res = isl_set_get_dim_name(get(), static_cast<enum isl_dim_type>(type), pos);\n  std::string tmp(res);\n  return tmp;\n}\n\nmulti_val set::get_plain_multi_val_if_fixed() const\n{\n  auto res = isl_set_get_plain_multi_val_if_fixed(get());\n  return manage(res);\n}\n\nfixed_box set::get_simple_fixed_box_hull() const\n{\n  auto res = isl_set_get_simple_fixed_box_hull(get());\n  return manage(res);\n}\n\nspace set::get_space() const\n{\n  auto res = isl_set_get_space(get());\n  return manage(res);\n}\n\nval set::get_stride(int pos) const\n{\n  auto res = isl_set_get_stride(get(), pos);\n  return manage(res);\n}\n\nid set::get_tuple_id() const\n{\n  auto res = isl_set_get_tuple_id(get());\n  return manage(res);\n}\n\nstd::string set::get_tuple_name() const\n{\n  auto res = isl_set_get_tuple_name(get());\n  std::string tmp(res);\n  return tmp;\n}\n\nset set::gist(set context) const\n{\n  auto res = isl_set_gist(copy(), context.release());\n  return manage(res);\n}\n\nset set::gist_basic_set(basic_set context) const\n{\n  auto res = isl_set_gist_basic_set(copy(), context.release());\n  return manage(res);\n}\n\nset set::gist_params(set context) const\n{\n  auto res = isl_set_gist_params(copy(), context.release());\n  return manage(res);\n}\n\nboolean set::has_dim_id(isl::dim type, unsigned int pos) const\n{\n  auto res = isl_set_has_dim_id(get(), static_cast<enum isl_dim_type>(type), pos);\n  return manage(res);\n}\n\nboolean set::has_dim_name(isl::dim type, unsigned int pos) const\n{\n  auto res = isl_set_has_dim_name(get(), static_cast<enum isl_dim_type>(type), pos);\n  return manage(res);\n}\n\nboolean set::has_equal_space(const set &set2) const\n{\n  auto res = isl_set_has_equal_space(get(), set2.get());\n  return manage(res);\n}\n\nboolean set::has_tuple_id() const\n{\n  auto res = isl_set_has_tuple_id(get());\n  return manage(res);\n}\n\nboolean set::has_tuple_name() const\n{\n  auto res = isl_set_has_tuple_name(get());\n  return manage(res);\n}\n\nmap set::identity() const\n{\n  auto res = isl_set_identity(copy());\n  return manage(res);\n}\n\npw_aff set::indicator_function() const\n{\n  auto res = isl_set_indicator_function(copy());\n  return manage(res);\n}\n\nset set::insert_dims(isl::dim type, unsigned int pos, unsigned int n) const\n{\n  auto res = isl_set_insert_dims(copy(), static_cast<enum isl_dim_type>(type), pos, n);\n  return manage(res);\n}\n\nmap set::insert_domain(space domain) const\n{\n  auto res = isl_set_insert_domain(copy(), domain.release());\n  return manage(res);\n}\n\nset set::intersect(set set2) const\n{\n  auto res = isl_set_intersect(copy(), set2.release());\n  return manage(res);\n}\n\nset set::intersect_factor_domain(set domain) const\n{\n  auto res = isl_set_intersect_factor_domain(copy(), domain.release());\n  return manage(res);\n}\n\nset set::intersect_factor_range(set range) const\n{\n  auto res = isl_set_intersect_factor_range(copy(), range.release());\n  return manage(res);\n}\n\nset set::intersect_params(set params) const\n{\n  auto res = isl_set_intersect_params(copy(), params.release());\n  return manage(res);\n}\n\nboolean set::involves_dims(isl::dim type, unsigned int first, unsigned int n) const\n{\n  auto res = isl_set_involves_dims(get(), static_cast<enum isl_dim_type>(type), first, n);\n  return manage(res);\n}\n\nboolean set::involves_locals() const\n{\n  auto res = isl_set_involves_locals(get());\n  return manage(res);\n}\n\nboolean set::is_bounded() const\n{\n  auto res = isl_set_is_bounded(get());\n  return manage(res);\n}\n\nboolean set::is_box() const\n{\n  auto res = isl_set_is_box(get());\n  return manage(res);\n}\n\nboolean set::is_disjoint(const set &set2) const\n{\n  auto res = isl_set_is_disjoint(get(), set2.get());\n  return manage(res);\n}\n\nboolean set::is_empty() const\n{\n  auto res = isl_set_is_empty(get());\n  return manage(res);\n}\n\nboolean set::is_equal(const set &set2) const\n{\n  auto res = isl_set_is_equal(get(), set2.get());\n  return manage(res);\n}\n\nboolean set::is_params() const\n{\n  auto res = isl_set_is_params(get());\n  return manage(res);\n}\n\nboolean set::is_singleton() const\n{\n  auto res = isl_set_is_singleton(get());\n  return manage(res);\n}\n\nboolean set::is_strict_subset(const set &set2) const\n{\n  auto res = isl_set_is_strict_subset(get(), set2.get());\n  return manage(res);\n}\n\nboolean set::is_subset(const set &set2) const\n{\n  auto res = isl_set_is_subset(get(), set2.get());\n  return manage(res);\n}\n\nboolean set::is_wrapping() const\n{\n  auto res = isl_set_is_wrapping(get());\n  return manage(res);\n}\n\nmap set::lex_ge_set(set set2) const\n{\n  auto res = isl_set_lex_ge_set(copy(), set2.release());\n  return manage(res);\n}\n\nmap set::lex_gt_set(set set2) const\n{\n  auto res = isl_set_lex_gt_set(copy(), set2.release());\n  return manage(res);\n}\n\nmap set::lex_le_set(set set2) const\n{\n  auto res = isl_set_lex_le_set(copy(), set2.release());\n  return manage(res);\n}\n\nmap set::lex_lt_set(set set2) const\n{\n  auto res = isl_set_lex_lt_set(copy(), set2.release());\n  return manage(res);\n}\n\nset set::lexmax() const\n{\n  auto res = isl_set_lexmax(copy());\n  return manage(res);\n}\n\npw_multi_aff set::lexmax_pw_multi_aff() const\n{\n  auto res = isl_set_lexmax_pw_multi_aff(copy());\n  return manage(res);\n}\n\nset set::lexmin() const\n{\n  auto res = isl_set_lexmin(copy());\n  return manage(res);\n}\n\npw_multi_aff set::lexmin_pw_multi_aff() const\n{\n  auto res = isl_set_lexmin_pw_multi_aff(copy());\n  return manage(res);\n}\n\nset set::lower_bound(multi_pw_aff lower) const\n{\n  auto res = isl_set_lower_bound_multi_pw_aff(copy(), lower.release());\n  return manage(res);\n}\n\nset set::lower_bound(multi_val lower) const\n{\n  auto res = isl_set_lower_bound_multi_val(copy(), lower.release());\n  return manage(res);\n}\n\nset set::lower_bound_si(isl::dim type, unsigned int pos, int value) const\n{\n  auto res = isl_set_lower_bound_si(copy(), static_cast<enum isl_dim_type>(type), pos, value);\n  return manage(res);\n}\n\nset set::lower_bound_val(isl::dim type, unsigned int pos, val value) const\n{\n  auto res = isl_set_lower_bound_val(copy(), static_cast<enum isl_dim_type>(type), pos, value.release());\n  return manage(res);\n}\n\nmulti_pw_aff set::max_multi_pw_aff() const\n{\n  auto res = isl_set_max_multi_pw_aff(copy());\n  return manage(res);\n}\n\nval set::max_val(const aff &obj) const\n{\n  auto res = isl_set_max_val(get(), obj.get());\n  return manage(res);\n}\n\nmulti_pw_aff set::min_multi_pw_aff() const\n{\n  auto res = isl_set_min_multi_pw_aff(copy());\n  return manage(res);\n}\n\nval set::min_val(const aff &obj) const\n{\n  auto res = isl_set_min_val(get(), obj.get());\n  return manage(res);\n}\n\nset set::move_dims(isl::dim dst_type, unsigned int dst_pos, isl::dim src_type, unsigned int src_pos, unsigned int n) const\n{\n  auto res = isl_set_move_dims(copy(), static_cast<enum isl_dim_type>(dst_type), dst_pos, static_cast<enum isl_dim_type>(src_type), src_pos, n);\n  return manage(res);\n}\n\nisl_size set::n_basic_set() const\n{\n  auto res = isl_set_n_basic_set(get());\n  return res;\n}\n\nisl_size set::n_dim() const\n{\n  auto res = isl_set_n_dim(get());\n  return res;\n}\n\nset set::nat_universe(space space)\n{\n  auto res = isl_set_nat_universe(space.release());\n  return manage(res);\n}\n\nset set::neg() const\n{\n  auto res = isl_set_neg(copy());\n  return manage(res);\n}\n\nset set::params() const\n{\n  auto res = isl_set_params(copy());\n  return manage(res);\n}\n\nint set::plain_cmp(const set &set2) const\n{\n  auto res = isl_set_plain_cmp(get(), set2.get());\n  return res;\n}\n\nval set::plain_get_val_if_fixed(isl::dim type, unsigned int pos) const\n{\n  auto res = isl_set_plain_get_val_if_fixed(get(), static_cast<enum isl_dim_type>(type), pos);\n  return manage(res);\n}\n\nboolean set::plain_is_disjoint(const set &set2) const\n{\n  auto res = isl_set_plain_is_disjoint(get(), set2.get());\n  return manage(res);\n}\n\nboolean set::plain_is_empty() const\n{\n  auto res = isl_set_plain_is_empty(get());\n  return manage(res);\n}\n\nboolean set::plain_is_equal(const set &set2) const\n{\n  auto res = isl_set_plain_is_equal(get(), set2.get());\n  return manage(res);\n}\n\nboolean set::plain_is_universe() const\n{\n  auto res = isl_set_plain_is_universe(get());\n  return manage(res);\n}\n\nbasic_set set::plain_unshifted_simple_hull() const\n{\n  auto res = isl_set_plain_unshifted_simple_hull(copy());\n  return manage(res);\n}\n\nbasic_set set::polyhedral_hull() const\n{\n  auto res = isl_set_polyhedral_hull(copy());\n  return manage(res);\n}\n\nset set::preimage(multi_aff ma) const\n{\n  auto res = isl_set_preimage_multi_aff(copy(), ma.release());\n  return manage(res);\n}\n\nset set::preimage(multi_pw_aff mpa) const\n{\n  auto res = isl_set_preimage_multi_pw_aff(copy(), mpa.release());\n  return manage(res);\n}\n\nset set::preimage(pw_multi_aff pma) const\n{\n  auto res = isl_set_preimage_pw_multi_aff(copy(), pma.release());\n  return manage(res);\n}\n\nset set::product(set set2) const\n{\n  auto res = isl_set_product(copy(), set2.release());\n  return manage(res);\n}\n\nmap set::project_onto_map(isl::dim type, unsigned int first, unsigned int n) const\n{\n  auto res = isl_set_project_onto_map(copy(), static_cast<enum isl_dim_type>(type), first, n);\n  return manage(res);\n}\n\nset set::project_out(isl::dim type, unsigned int first, unsigned int n) const\n{\n  auto res = isl_set_project_out(copy(), static_cast<enum isl_dim_type>(type), first, n);\n  return manage(res);\n}\n\nset set::project_out_all_params() const\n{\n  auto res = isl_set_project_out_all_params(copy());\n  return manage(res);\n}\n\nset set::project_out_param(id id) const\n{\n  auto res = isl_set_project_out_param_id(copy(), id.release());\n  return manage(res);\n}\n\nset set::project_out_param(id_list list) const\n{\n  auto res = isl_set_project_out_param_id_list(copy(), list.release());\n  return manage(res);\n}\n\nset set::remove_dims(isl::dim type, unsigned int first, unsigned int n) const\n{\n  auto res = isl_set_remove_dims(copy(), static_cast<enum isl_dim_type>(type), first, n);\n  return manage(res);\n}\n\nset set::remove_divs() const\n{\n  auto res = isl_set_remove_divs(copy());\n  return manage(res);\n}\n\nset set::remove_divs_involving_dims(isl::dim type, unsigned int first, unsigned int n) const\n{\n  auto res = isl_set_remove_divs_involving_dims(copy(), static_cast<enum isl_dim_type>(type), first, n);\n  return manage(res);\n}\n\nset set::remove_redundancies() const\n{\n  auto res = isl_set_remove_redundancies(copy());\n  return manage(res);\n}\n\nset set::remove_unknown_divs() const\n{\n  auto res = isl_set_remove_unknown_divs(copy());\n  return manage(res);\n}\n\nset set::reset_space(space space) const\n{\n  auto res = isl_set_reset_space(copy(), space.release());\n  return manage(res);\n}\n\nset set::reset_tuple_id() const\n{\n  auto res = isl_set_reset_tuple_id(copy());\n  return manage(res);\n}\n\nset set::reset_user() const\n{\n  auto res = isl_set_reset_user(copy());\n  return manage(res);\n}\n\nbasic_set set::sample() const\n{\n  auto res = isl_set_sample(copy());\n  return manage(res);\n}\n\npoint set::sample_point() const\n{\n  auto res = isl_set_sample_point(copy());\n  return manage(res);\n}\n\nset set::set_dim_id(isl::dim type, unsigned int pos, id id) const\n{\n  auto res = isl_set_set_dim_id(copy(), static_cast<enum isl_dim_type>(type), pos, id.release());\n  return manage(res);\n}\n\nset set::set_tuple_id(id id) const\n{\n  auto res = isl_set_set_tuple_id(copy(), id.release());\n  return manage(res);\n}\n\nset set::set_tuple_name(const std::string &s) const\n{\n  auto res = isl_set_set_tuple_name(copy(), s.c_str());\n  return manage(res);\n}\n\nbasic_set set::simple_hull() const\n{\n  auto res = isl_set_simple_hull(copy());\n  return manage(res);\n}\n\nint set::size() const\n{\n  auto res = isl_set_size(get());\n  return res;\n}\n\nbasic_set set::solutions() const\n{\n  auto res = isl_set_solutions(copy());\n  return manage(res);\n}\n\nset set::split_dims(isl::dim type, unsigned int first, unsigned int n) const\n{\n  auto res = isl_set_split_dims(copy(), static_cast<enum isl_dim_type>(type), first, n);\n  return manage(res);\n}\n\nset set::subtract(set set2) const\n{\n  auto res = isl_set_subtract(copy(), set2.release());\n  return manage(res);\n}\n\nset set::sum(set set2) const\n{\n  auto res = isl_set_sum(copy(), set2.release());\n  return manage(res);\n}\n\nmap set::translation() const\n{\n  auto res = isl_set_translation(copy());\n  return manage(res);\n}\n\nset set::unbind_params(multi_id tuple) const\n{\n  auto res = isl_set_unbind_params(copy(), tuple.release());\n  return manage(res);\n}\n\nmap set::unbind_params_insert_domain(multi_id domain) const\n{\n  auto res = isl_set_unbind_params_insert_domain(copy(), domain.release());\n  return manage(res);\n}\n\nset set::unite(set set2) const\n{\n  auto res = isl_set_union(copy(), set2.release());\n  return manage(res);\n}\n\nset set::universe(space space)\n{\n  auto res = isl_set_universe(space.release());\n  return manage(res);\n}\n\nbasic_set set::unshifted_simple_hull() const\n{\n  auto res = isl_set_unshifted_simple_hull(copy());\n  return manage(res);\n}\n\nbasic_set set::unshifted_simple_hull_from_set_list(set_list list) const\n{\n  auto res = isl_set_unshifted_simple_hull_from_set_list(copy(), list.release());\n  return manage(res);\n}\n\nmap set::unwrap() const\n{\n  auto res = isl_set_unwrap(copy());\n  return manage(res);\n}\n\nset set::upper_bound(multi_pw_aff upper) const\n{\n  auto res = isl_set_upper_bound_multi_pw_aff(copy(), upper.release());\n  return manage(res);\n}\n\nset set::upper_bound(multi_val upper) const\n{\n  auto res = isl_set_upper_bound_multi_val(copy(), upper.release());\n  return manage(res);\n}\n\nset set::upper_bound_si(isl::dim type, unsigned int pos, int value) const\n{\n  auto res = isl_set_upper_bound_si(copy(), static_cast<enum isl_dim_type>(type), pos, value);\n  return manage(res);\n}\n\nset set::upper_bound_val(isl::dim type, unsigned int pos, val value) const\n{\n  auto res = isl_set_upper_bound_val(copy(), static_cast<enum isl_dim_type>(type), pos, value.release());\n  return manage(res);\n}\n\nmap set::wrapped_domain_map() const\n{\n  auto res = isl_set_wrapped_domain_map(copy());\n  return manage(res);\n}\n\n// implementations for isl::set_list\nset_list manage(__isl_take isl_set_list *ptr) {\n  return set_list(ptr);\n}\nset_list manage_copy(__isl_keep isl_set_list *ptr) {\n  ptr = isl_set_list_copy(ptr);\n  return set_list(ptr);\n}\n\nset_list::set_list()\n    : ptr(nullptr) {}\n\nset_list::set_list(const set_list &obj)\n    : ptr(nullptr)\n{\n  ptr = obj.copy();\n}\nset_list::set_list(std::nullptr_t)\n    : ptr(nullptr) {}\n\n\nset_list::set_list(__isl_take isl_set_list *ptr)\n    : ptr(ptr) {}\n\n\nset_list &set_list::operator=(set_list obj) {\n  std::swap(this->ptr, obj.ptr);\n  return *this;\n}\n\nset_list::~set_list() {\n  if (ptr)\n    isl_set_list_free(ptr);\n}\n\n__isl_give isl_set_list *set_list::copy() const & {\n  return isl_set_list_copy(ptr);\n}\n\n__isl_keep isl_set_list *set_list::get() const {\n  return ptr;\n}\n\n__isl_give isl_set_list *set_list::release() {\n  isl_set_list *tmp = ptr;\n  ptr = nullptr;\n  return tmp;\n}\n\nbool set_list::is_null() const {\n  return ptr == nullptr;\n}\nset_list::operator bool() const {\n  return !is_null();\n}\n\n\nctx set_list::get_ctx() const {\n  return ctx(isl_set_list_get_ctx(ptr));\n}\nstd::string set_list::to_str() const {\n  char *Tmp = isl_set_list_to_str(get());\n  if (!Tmp)\n    return \"\";\n  std::string S(Tmp);\n  free(Tmp);\n  return S;\n}\n\n\nvoid set_list::dump() const {\n  isl_set_list_dump(get());\n}\n\n\nset_list set_list::add(set el) const\n{\n  auto res = isl_set_list_add(copy(), el.release());\n  return manage(res);\n}\n\nset_list set_list::alloc(ctx ctx, int n)\n{\n  auto res = isl_set_list_alloc(ctx.release(), n);\n  return manage(res);\n}\n\nset_list set_list::clear() const\n{\n  auto res = isl_set_list_clear(copy());\n  return manage(res);\n}\n\nset_list set_list::concat(set_list list2) const\n{\n  auto res = isl_set_list_concat(copy(), list2.release());\n  return manage(res);\n}\n\nset_list set_list::drop(unsigned int first, unsigned int n) const\n{\n  auto res = isl_set_list_drop(copy(), first, n);\n  return manage(res);\n}\n\nstat set_list::foreach(const std::function<stat(set)> &fn) const\n{\n  struct fn_data {\n    const std::function<stat(set)> *func;\n  } fn_data = { &fn };\n  auto fn_lambda = [](isl_set *arg_0, void *arg_1) -> isl_stat {\n    auto *data = static_cast<struct fn_data *>(arg_1);\n    stat ret = (*data->func)(manage(arg_0));\n    return ret.release();\n  };\n  auto res = isl_set_list_foreach(get(), fn_lambda, &fn_data);\n  return manage(res);\n}\n\nset_list set_list::from_set(set el)\n{\n  auto res = isl_set_list_from_set(el.release());\n  return manage(res);\n}\n\nset set_list::get_at(int index) const\n{\n  auto res = isl_set_list_get_at(get(), index);\n  return manage(res);\n}\n\nset set_list::get_set(int index) const\n{\n  auto res = isl_set_list_get_set(get(), index);\n  return manage(res);\n}\n\nset_list set_list::insert(unsigned int pos, set el) const\n{\n  auto res = isl_set_list_insert(copy(), pos, el.release());\n  return manage(res);\n}\n\nisl_size set_list::n_set() const\n{\n  auto res = isl_set_list_n_set(get());\n  return res;\n}\n\nset_list set_list::reverse() const\n{\n  auto res = isl_set_list_reverse(copy());\n  return manage(res);\n}\n\nset_list set_list::set_set(int index, set el) const\n{\n  auto res = isl_set_list_set_set(copy(), index, el.release());\n  return manage(res);\n}\n\nisl_size set_list::size() const\n{\n  auto res = isl_set_list_size(get());\n  return res;\n}\n\nset_list set_list::swap(unsigned int pos1, unsigned int pos2) const\n{\n  auto res = isl_set_list_swap(copy(), pos1, pos2);\n  return manage(res);\n}\n\nset set_list::unite() const\n{\n  auto res = isl_set_list_union(copy());\n  return manage(res);\n}\n\n// implementations for isl::space\nspace manage(__isl_take isl_space *ptr) {\n  return space(ptr);\n}\nspace manage_copy(__isl_keep isl_space *ptr) {\n  ptr = isl_space_copy(ptr);\n  return space(ptr);\n}\n\nspace::space()\n    : ptr(nullptr) {}\n\nspace::space(const space &obj)\n    : ptr(nullptr)\n{\n  ptr = obj.copy();\n}\nspace::space(std::nullptr_t)\n    : ptr(nullptr) {}\n\n\nspace::space(__isl_take isl_space *ptr)\n    : ptr(ptr) {}\n\nspace::space(ctx ctx, unsigned int nparam, unsigned int n_in, unsigned int n_out)\n{\n  auto res = isl_space_alloc(ctx.release(), nparam, n_in, n_out);\n  ptr = res;\n}\nspace::space(ctx ctx, unsigned int nparam, unsigned int dim)\n{\n  auto res = isl_space_set_alloc(ctx.release(), nparam, dim);\n  ptr = res;\n}\n\nspace &space::operator=(space obj) {\n  std::swap(this->ptr, obj.ptr);\n  return *this;\n}\n\nspace::~space() {\n  if (ptr)\n    isl_space_free(ptr);\n}\n\n__isl_give isl_space *space::copy() const & {\n  return isl_space_copy(ptr);\n}\n\n__isl_keep isl_space *space::get() const {\n  return ptr;\n}\n\n__isl_give isl_space *space::release() {\n  isl_space *tmp = ptr;\n  ptr = nullptr;\n  return tmp;\n}\n\nbool space::is_null() const {\n  return ptr == nullptr;\n}\nspace::operator bool() const {\n  return !is_null();\n}\n\n\nctx space::get_ctx() const {\n  return ctx(isl_space_get_ctx(ptr));\n}\nstd::string space::to_str() const {\n  char *Tmp = isl_space_to_str(get());\n  if (!Tmp)\n    return \"\";\n  std::string S(Tmp);\n  free(Tmp);\n  return S;\n}\n\n\nvoid space::dump() const {\n  isl_space_dump(get());\n}\n\n\nspace space::add_dims(isl::dim type, unsigned int n) const\n{\n  auto res = isl_space_add_dims(copy(), static_cast<enum isl_dim_type>(type), n);\n  return manage(res);\n}\n\nspace space::add_named_tuple(id tuple_id, unsigned int dim) const\n{\n  auto res = isl_space_add_named_tuple_id_ui(copy(), tuple_id.release(), dim);\n  return manage(res);\n}\n\nspace space::add_param_id(id id) const\n{\n  auto res = isl_space_add_param_id(copy(), id.release());\n  return manage(res);\n}\n\nspace space::add_unnamed_tuple(unsigned int dim) const\n{\n  auto res = isl_space_add_unnamed_tuple_ui(copy(), dim);\n  return manage(res);\n}\n\nspace space::align_params(space space2) const\n{\n  auto res = isl_space_align_params(copy(), space2.release());\n  return manage(res);\n}\n\nboolean space::can_curry() const\n{\n  auto res = isl_space_can_curry(get());\n  return manage(res);\n}\n\nboolean space::can_range_curry() const\n{\n  auto res = isl_space_can_range_curry(get());\n  return manage(res);\n}\n\nboolean space::can_uncurry() const\n{\n  auto res = isl_space_can_uncurry(get());\n  return manage(res);\n}\n\nboolean space::can_zip() const\n{\n  auto res = isl_space_can_zip(get());\n  return manage(res);\n}\n\nspace space::curry() const\n{\n  auto res = isl_space_curry(copy());\n  return manage(res);\n}\n\nisl_size space::dim(isl::dim type) const\n{\n  auto res = isl_space_dim(get(), static_cast<enum isl_dim_type>(type));\n  return res;\n}\n\nspace space::domain() const\n{\n  auto res = isl_space_domain(copy());\n  return manage(res);\n}\n\nspace space::domain_factor_domain() const\n{\n  auto res = isl_space_domain_factor_domain(copy());\n  return manage(res);\n}\n\nspace space::domain_factor_range() const\n{\n  auto res = isl_space_domain_factor_range(copy());\n  return manage(res);\n}\n\nboolean space::domain_is_wrapping() const\n{\n  auto res = isl_space_domain_is_wrapping(get());\n  return manage(res);\n}\n\nspace space::domain_map() const\n{\n  auto res = isl_space_domain_map(copy());\n  return manage(res);\n}\n\nspace space::domain_product(space right) const\n{\n  auto res = isl_space_domain_product(copy(), right.release());\n  return manage(res);\n}\n\nspace space::drop_all_params() const\n{\n  auto res = isl_space_drop_all_params(copy());\n  return manage(res);\n}\n\nspace space::drop_dims(isl::dim type, unsigned int first, unsigned int num) const\n{\n  auto res = isl_space_drop_dims(copy(), static_cast<enum isl_dim_type>(type), first, num);\n  return manage(res);\n}\n\nspace space::factor_domain() const\n{\n  auto res = isl_space_factor_domain(copy());\n  return manage(res);\n}\n\nspace space::factor_range() const\n{\n  auto res = isl_space_factor_range(copy());\n  return manage(res);\n}\n\nint space::find_dim_by_id(isl::dim type, const id &id) const\n{\n  auto res = isl_space_find_dim_by_id(get(), static_cast<enum isl_dim_type>(type), id.get());\n  return res;\n}\n\nint space::find_dim_by_name(isl::dim type, const std::string &name) const\n{\n  auto res = isl_space_find_dim_by_name(get(), static_cast<enum isl_dim_type>(type), name.c_str());\n  return res;\n}\n\nspace space::flatten_domain() const\n{\n  auto res = isl_space_flatten_domain(copy());\n  return manage(res);\n}\n\nspace space::flatten_range() const\n{\n  auto res = isl_space_flatten_range(copy());\n  return manage(res);\n}\n\nspace space::from_domain() const\n{\n  auto res = isl_space_from_domain(copy());\n  return manage(res);\n}\n\nspace space::from_range() const\n{\n  auto res = isl_space_from_range(copy());\n  return manage(res);\n}\n\nid space::get_dim_id(isl::dim type, unsigned int pos) const\n{\n  auto res = isl_space_get_dim_id(get(), static_cast<enum isl_dim_type>(type), pos);\n  return manage(res);\n}\n\nstd::string space::get_dim_name(isl::dim type, unsigned int pos) const\n{\n  auto res = isl_space_get_dim_name(get(), static_cast<enum isl_dim_type>(type), pos);\n  std::string tmp(res);\n  return tmp;\n}\n\nid space::get_tuple_id(isl::dim type) const\n{\n  auto res = isl_space_get_tuple_id(get(), static_cast<enum isl_dim_type>(type));\n  return manage(res);\n}\n\nstd::string space::get_tuple_name(isl::dim type) const\n{\n  auto res = isl_space_get_tuple_name(get(), static_cast<enum isl_dim_type>(type));\n  std::string tmp(res);\n  return tmp;\n}\n\nboolean space::has_dim_id(isl::dim type, unsigned int pos) const\n{\n  auto res = isl_space_has_dim_id(get(), static_cast<enum isl_dim_type>(type), pos);\n  return manage(res);\n}\n\nboolean space::has_dim_name(isl::dim type, unsigned int pos) const\n{\n  auto res = isl_space_has_dim_name(get(), static_cast<enum isl_dim_type>(type), pos);\n  return manage(res);\n}\n\nboolean space::has_equal_params(const space &space2) const\n{\n  auto res = isl_space_has_equal_params(get(), space2.get());\n  return manage(res);\n}\n\nboolean space::has_equal_tuples(const space &space2) const\n{\n  auto res = isl_space_has_equal_tuples(get(), space2.get());\n  return manage(res);\n}\n\nboolean space::has_tuple_id(isl::dim type) const\n{\n  auto res = isl_space_has_tuple_id(get(), static_cast<enum isl_dim_type>(type));\n  return manage(res);\n}\n\nboolean space::has_tuple_name(isl::dim type) const\n{\n  auto res = isl_space_has_tuple_name(get(), static_cast<enum isl_dim_type>(type));\n  return manage(res);\n}\n\nspace space::insert_dims(isl::dim type, unsigned int pos, unsigned int n) const\n{\n  auto res = isl_space_insert_dims(copy(), static_cast<enum isl_dim_type>(type), pos, n);\n  return manage(res);\n}\n\nboolean space::is_domain(const space &space2) const\n{\n  auto res = isl_space_is_domain(get(), space2.get());\n  return manage(res);\n}\n\nboolean space::is_equal(const space &space2) const\n{\n  auto res = isl_space_is_equal(get(), space2.get());\n  return manage(res);\n}\n\nboolean space::is_map() const\n{\n  auto res = isl_space_is_map(get());\n  return manage(res);\n}\n\nboolean space::is_params() const\n{\n  auto res = isl_space_is_params(get());\n  return manage(res);\n}\n\nboolean space::is_product() const\n{\n  auto res = isl_space_is_product(get());\n  return manage(res);\n}\n\nboolean space::is_range(const space &space2) const\n{\n  auto res = isl_space_is_range(get(), space2.get());\n  return manage(res);\n}\n\nboolean space::is_set() const\n{\n  auto res = isl_space_is_set(get());\n  return manage(res);\n}\n\nboolean space::is_wrapping() const\n{\n  auto res = isl_space_is_wrapping(get());\n  return manage(res);\n}\n\nspace space::join(space right) const\n{\n  auto res = isl_space_join(copy(), right.release());\n  return manage(res);\n}\n\nspace space::map_from_domain_and_range(space range) const\n{\n  auto res = isl_space_map_from_domain_and_range(copy(), range.release());\n  return manage(res);\n}\n\nspace space::map_from_set() const\n{\n  auto res = isl_space_map_from_set(copy());\n  return manage(res);\n}\n\nspace space::move_dims(isl::dim dst_type, unsigned int dst_pos, isl::dim src_type, unsigned int src_pos, unsigned int n) const\n{\n  auto res = isl_space_move_dims(copy(), static_cast<enum isl_dim_type>(dst_type), dst_pos, static_cast<enum isl_dim_type>(src_type), src_pos, n);\n  return manage(res);\n}\n\nspace space::params() const\n{\n  auto res = isl_space_params(copy());\n  return manage(res);\n}\n\nspace space::params_alloc(ctx ctx, unsigned int nparam)\n{\n  auto res = isl_space_params_alloc(ctx.release(), nparam);\n  return manage(res);\n}\n\nspace space::product(space right) const\n{\n  auto res = isl_space_product(copy(), right.release());\n  return manage(res);\n}\n\nspace space::range() const\n{\n  auto res = isl_space_range(copy());\n  return manage(res);\n}\n\nspace space::range_curry() const\n{\n  auto res = isl_space_range_curry(copy());\n  return manage(res);\n}\n\nspace space::range_factor_domain() const\n{\n  auto res = isl_space_range_factor_domain(copy());\n  return manage(res);\n}\n\nspace space::range_factor_range() const\n{\n  auto res = isl_space_range_factor_range(copy());\n  return manage(res);\n}\n\nboolean space::range_is_wrapping() const\n{\n  auto res = isl_space_range_is_wrapping(get());\n  return manage(res);\n}\n\nspace space::range_map() const\n{\n  auto res = isl_space_range_map(copy());\n  return manage(res);\n}\n\nspace space::range_product(space right) const\n{\n  auto res = isl_space_range_product(copy(), right.release());\n  return manage(res);\n}\n\nspace space::range_reverse() const\n{\n  auto res = isl_space_range_reverse(copy());\n  return manage(res);\n}\n\nspace space::reset_tuple_id(isl::dim type) const\n{\n  auto res = isl_space_reset_tuple_id(copy(), static_cast<enum isl_dim_type>(type));\n  return manage(res);\n}\n\nspace space::reset_user() const\n{\n  auto res = isl_space_reset_user(copy());\n  return manage(res);\n}\n\nspace space::reverse() const\n{\n  auto res = isl_space_reverse(copy());\n  return manage(res);\n}\n\nspace space::set_dim_id(isl::dim type, unsigned int pos, id id) const\n{\n  auto res = isl_space_set_dim_id(copy(), static_cast<enum isl_dim_type>(type), pos, id.release());\n  return manage(res);\n}\n\nspace space::set_from_params() const\n{\n  auto res = isl_space_set_from_params(copy());\n  return manage(res);\n}\n\nspace space::set_tuple_id(isl::dim type, id id) const\n{\n  auto res = isl_space_set_tuple_id(copy(), static_cast<enum isl_dim_type>(type), id.release());\n  return manage(res);\n}\n\nspace space::set_tuple_name(isl::dim type, const std::string &s) const\n{\n  auto res = isl_space_set_tuple_name(copy(), static_cast<enum isl_dim_type>(type), s.c_str());\n  return manage(res);\n}\n\nboolean space::tuple_is_equal(isl::dim type1, const space &space2, isl::dim type2) const\n{\n  auto res = isl_space_tuple_is_equal(get(), static_cast<enum isl_dim_type>(type1), space2.get(), static_cast<enum isl_dim_type>(type2));\n  return manage(res);\n}\n\nspace space::uncurry() const\n{\n  auto res = isl_space_uncurry(copy());\n  return manage(res);\n}\n\nspace space::unit(ctx ctx)\n{\n  auto res = isl_space_unit(ctx.release());\n  return manage(res);\n}\n\nspace space::unwrap() const\n{\n  auto res = isl_space_unwrap(copy());\n  return manage(res);\n}\n\nspace space::wrap() const\n{\n  auto res = isl_space_wrap(copy());\n  return manage(res);\n}\n\nspace space::zip() const\n{\n  auto res = isl_space_zip(copy());\n  return manage(res);\n}\n\n// implementations for isl::term\nterm manage(__isl_take isl_term *ptr) {\n  return term(ptr);\n}\nterm manage_copy(__isl_keep isl_term *ptr) {\n  ptr = isl_term_copy(ptr);\n  return term(ptr);\n}\n\nterm::term()\n    : ptr(nullptr) {}\n\nterm::term(const term &obj)\n    : ptr(nullptr)\n{\n  ptr = obj.copy();\n}\nterm::term(std::nullptr_t)\n    : ptr(nullptr) {}\n\n\nterm::term(__isl_take isl_term *ptr)\n    : ptr(ptr) {}\n\n\nterm &term::operator=(term obj) {\n  std::swap(this->ptr, obj.ptr);\n  return *this;\n}\n\nterm::~term() {\n  if (ptr)\n    isl_term_free(ptr);\n}\n\n__isl_give isl_term *term::copy() const & {\n  return isl_term_copy(ptr);\n}\n\n__isl_keep isl_term *term::get() const {\n  return ptr;\n}\n\n__isl_give isl_term *term::release() {\n  isl_term *tmp = ptr;\n  ptr = nullptr;\n  return tmp;\n}\n\nbool term::is_null() const {\n  return ptr == nullptr;\n}\nterm::operator bool() const {\n  return !is_null();\n}\n\n\nctx term::get_ctx() const {\n  return ctx(isl_term_get_ctx(ptr));\n}\n\n\nisl_size term::dim(isl::dim type) const\n{\n  auto res = isl_term_dim(get(), static_cast<enum isl_dim_type>(type));\n  return res;\n}\n\nval term::get_coefficient_val() const\n{\n  auto res = isl_term_get_coefficient_val(get());\n  return manage(res);\n}\n\naff term::get_div(unsigned int pos) const\n{\n  auto res = isl_term_get_div(get(), pos);\n  return manage(res);\n}\n\nisl_size term::get_exp(isl::dim type, unsigned int pos) const\n{\n  auto res = isl_term_get_exp(get(), static_cast<enum isl_dim_type>(type), pos);\n  return res;\n}\n\n// implementations for isl::union_access_info\nunion_access_info manage(__isl_take isl_union_access_info *ptr) {\n  return union_access_info(ptr);\n}\nunion_access_info manage_copy(__isl_keep isl_union_access_info *ptr) {\n  ptr = isl_union_access_info_copy(ptr);\n  return union_access_info(ptr);\n}\n\nunion_access_info::union_access_info()\n    : ptr(nullptr) {}\n\nunion_access_info::union_access_info(const union_access_info &obj)\n    : ptr(nullptr)\n{\n  ptr = obj.copy();\n}\nunion_access_info::union_access_info(std::nullptr_t)\n    : ptr(nullptr) {}\n\n\nunion_access_info::union_access_info(__isl_take isl_union_access_info *ptr)\n    : ptr(ptr) {}\n\nunion_access_info::union_access_info(union_map sink)\n{\n  auto res = isl_union_access_info_from_sink(sink.release());\n  ptr = res;\n}\n\nunion_access_info &union_access_info::operator=(union_access_info obj) {\n  std::swap(this->ptr, obj.ptr);\n  return *this;\n}\n\nunion_access_info::~union_access_info() {\n  if (ptr)\n    isl_union_access_info_free(ptr);\n}\n\n__isl_give isl_union_access_info *union_access_info::copy() const & {\n  return isl_union_access_info_copy(ptr);\n}\n\n__isl_keep isl_union_access_info *union_access_info::get() const {\n  return ptr;\n}\n\n__isl_give isl_union_access_info *union_access_info::release() {\n  isl_union_access_info *tmp = ptr;\n  ptr = nullptr;\n  return tmp;\n}\n\nbool union_access_info::is_null() const {\n  return ptr == nullptr;\n}\nunion_access_info::operator bool() const {\n  return !is_null();\n}\n\n\nctx union_access_info::get_ctx() const {\n  return ctx(isl_union_access_info_get_ctx(ptr));\n}\nstd::string union_access_info::to_str() const {\n  char *Tmp = isl_union_access_info_to_str(get());\n  if (!Tmp)\n    return \"\";\n  std::string S(Tmp);\n  free(Tmp);\n  return S;\n}\n\n\n\nunion_flow union_access_info::compute_flow() const\n{\n  auto res = isl_union_access_info_compute_flow(copy());\n  return manage(res);\n}\n\nunion_access_info union_access_info::set_kill(union_map kill) const\n{\n  auto res = isl_union_access_info_set_kill(copy(), kill.release());\n  return manage(res);\n}\n\nunion_access_info union_access_info::set_may_source(union_map may_source) const\n{\n  auto res = isl_union_access_info_set_may_source(copy(), may_source.release());\n  return manage(res);\n}\n\nunion_access_info union_access_info::set_must_source(union_map must_source) const\n{\n  auto res = isl_union_access_info_set_must_source(copy(), must_source.release());\n  return manage(res);\n}\n\nunion_access_info union_access_info::set_schedule(schedule schedule) const\n{\n  auto res = isl_union_access_info_set_schedule(copy(), schedule.release());\n  return manage(res);\n}\n\nunion_access_info union_access_info::set_schedule_map(union_map schedule_map) const\n{\n  auto res = isl_union_access_info_set_schedule_map(copy(), schedule_map.release());\n  return manage(res);\n}\n\n// implementations for isl::union_flow\nunion_flow manage(__isl_take isl_union_flow *ptr) {\n  return union_flow(ptr);\n}\nunion_flow manage_copy(__isl_keep isl_union_flow *ptr) {\n  ptr = isl_union_flow_copy(ptr);\n  return union_flow(ptr);\n}\n\nunion_flow::union_flow()\n    : ptr(nullptr) {}\n\nunion_flow::union_flow(const union_flow &obj)\n    : ptr(nullptr)\n{\n  ptr = obj.copy();\n}\nunion_flow::union_flow(std::nullptr_t)\n    : ptr(nullptr) {}\n\n\nunion_flow::union_flow(__isl_take isl_union_flow *ptr)\n    : ptr(ptr) {}\n\n\nunion_flow &union_flow::operator=(union_flow obj) {\n  std::swap(this->ptr, obj.ptr);\n  return *this;\n}\n\nunion_flow::~union_flow() {\n  if (ptr)\n    isl_union_flow_free(ptr);\n}\n\n__isl_give isl_union_flow *union_flow::copy() const & {\n  return isl_union_flow_copy(ptr);\n}\n\n__isl_keep isl_union_flow *union_flow::get() const {\n  return ptr;\n}\n\n__isl_give isl_union_flow *union_flow::release() {\n  isl_union_flow *tmp = ptr;\n  ptr = nullptr;\n  return tmp;\n}\n\nbool union_flow::is_null() const {\n  return ptr == nullptr;\n}\nunion_flow::operator bool() const {\n  return !is_null();\n}\n\n\nctx union_flow::get_ctx() const {\n  return ctx(isl_union_flow_get_ctx(ptr));\n}\nstd::string union_flow::to_str() const {\n  char *Tmp = isl_union_flow_to_str(get());\n  if (!Tmp)\n    return \"\";\n  std::string S(Tmp);\n  free(Tmp);\n  return S;\n}\n\n\n\nunion_map union_flow::get_full_may_dependence() const\n{\n  auto res = isl_union_flow_get_full_may_dependence(get());\n  return manage(res);\n}\n\nunion_map union_flow::get_full_must_dependence() const\n{\n  auto res = isl_union_flow_get_full_must_dependence(get());\n  return manage(res);\n}\n\nunion_map union_flow::get_may_dependence() const\n{\n  auto res = isl_union_flow_get_may_dependence(get());\n  return manage(res);\n}\n\nunion_map union_flow::get_may_no_source() const\n{\n  auto res = isl_union_flow_get_may_no_source(get());\n  return manage(res);\n}\n\nunion_map union_flow::get_must_dependence() const\n{\n  auto res = isl_union_flow_get_must_dependence(get());\n  return manage(res);\n}\n\nunion_map union_flow::get_must_no_source() const\n{\n  auto res = isl_union_flow_get_must_no_source(get());\n  return manage(res);\n}\n\n// implementations for isl::union_map\nunion_map manage(__isl_take isl_union_map *ptr) {\n  return union_map(ptr);\n}\nunion_map manage_copy(__isl_keep isl_union_map *ptr) {\n  ptr = isl_union_map_copy(ptr);\n  return union_map(ptr);\n}\n\nunion_map::union_map()\n    : ptr(nullptr) {}\n\nunion_map::union_map(const union_map &obj)\n    : ptr(nullptr)\n{\n  ptr = obj.copy();\n}\nunion_map::union_map(std::nullptr_t)\n    : ptr(nullptr) {}\n\n\nunion_map::union_map(__isl_take isl_union_map *ptr)\n    : ptr(ptr) {}\n\nunion_map::union_map(basic_map bmap)\n{\n  auto res = isl_union_map_from_basic_map(bmap.release());\n  ptr = res;\n}\nunion_map::union_map(map map)\n{\n  auto res = isl_union_map_from_map(map.release());\n  ptr = res;\n}\nunion_map::union_map(union_pw_multi_aff upma)\n{\n  auto res = isl_union_map_from_union_pw_multi_aff(upma.release());\n  ptr = res;\n}\nunion_map::union_map(ctx ctx, const std::string &str)\n{\n  auto res = isl_union_map_read_from_str(ctx.release(), str.c_str());\n  ptr = res;\n}\n\nunion_map &union_map::operator=(union_map obj) {\n  std::swap(this->ptr, obj.ptr);\n  return *this;\n}\n\nunion_map::~union_map() {\n  if (ptr)\n    isl_union_map_free(ptr);\n}\n\n__isl_give isl_union_map *union_map::copy() const & {\n  return isl_union_map_copy(ptr);\n}\n\n__isl_keep isl_union_map *union_map::get() const {\n  return ptr;\n}\n\n__isl_give isl_union_map *union_map::release() {\n  isl_union_map *tmp = ptr;\n  ptr = nullptr;\n  return tmp;\n}\n\nbool union_map::is_null() const {\n  return ptr == nullptr;\n}\nunion_map::operator bool() const {\n  return !is_null();\n}\n\n\nctx union_map::get_ctx() const {\n  return ctx(isl_union_map_get_ctx(ptr));\n}\nstd::string union_map::to_str() const {\n  char *Tmp = isl_union_map_to_str(get());\n  if (!Tmp)\n    return \"\";\n  std::string S(Tmp);\n  free(Tmp);\n  return S;\n}\n\n\nvoid union_map::dump() const {\n  isl_union_map_dump(get());\n}\n\n\nunion_map union_map::add_map(map map) const\n{\n  auto res = isl_union_map_add_map(copy(), map.release());\n  return manage(res);\n}\n\nunion_map union_map::affine_hull() const\n{\n  auto res = isl_union_map_affine_hull(copy());\n  return manage(res);\n}\n\nunion_map union_map::align_params(space model) const\n{\n  auto res = isl_union_map_align_params(copy(), model.release());\n  return manage(res);\n}\n\nunion_map union_map::apply_domain(union_map umap2) const\n{\n  auto res = isl_union_map_apply_domain(copy(), umap2.release());\n  return manage(res);\n}\n\nunion_map union_map::apply_range(union_map umap2) const\n{\n  auto res = isl_union_map_apply_range(copy(), umap2.release());\n  return manage(res);\n}\n\nunion_set union_map::bind_range(multi_id tuple) const\n{\n  auto res = isl_union_map_bind_range(copy(), tuple.release());\n  return manage(res);\n}\n\nunion_map union_map::coalesce() const\n{\n  auto res = isl_union_map_coalesce(copy());\n  return manage(res);\n}\n\nboolean union_map::contains(const space &space) const\n{\n  auto res = isl_union_map_contains(get(), space.get());\n  return manage(res);\n}\n\nunion_map union_map::curry() const\n{\n  auto res = isl_union_map_curry(copy());\n  return manage(res);\n}\n\nunion_set union_map::deltas() const\n{\n  auto res = isl_union_map_deltas(copy());\n  return manage(res);\n}\n\nunion_map union_map::deltas_map() const\n{\n  auto res = isl_union_map_deltas_map(copy());\n  return manage(res);\n}\n\nunion_map union_map::detect_equalities() const\n{\n  auto res = isl_union_map_detect_equalities(copy());\n  return manage(res);\n}\n\nisl_size union_map::dim(isl::dim type) const\n{\n  auto res = isl_union_map_dim(get(), static_cast<enum isl_dim_type>(type));\n  return res;\n}\n\nunion_set union_map::domain() const\n{\n  auto res = isl_union_map_domain(copy());\n  return manage(res);\n}\n\nunion_map union_map::domain_factor_domain() const\n{\n  auto res = isl_union_map_domain_factor_domain(copy());\n  return manage(res);\n}\n\nunion_map union_map::domain_factor_range() const\n{\n  auto res = isl_union_map_domain_factor_range(copy());\n  return manage(res);\n}\n\nunion_map union_map::domain_map() const\n{\n  auto res = isl_union_map_domain_map(copy());\n  return manage(res);\n}\n\nunion_pw_multi_aff union_map::domain_map_union_pw_multi_aff() const\n{\n  auto res = isl_union_map_domain_map_union_pw_multi_aff(copy());\n  return manage(res);\n}\n\nunion_map union_map::domain_product(union_map umap2) const\n{\n  auto res = isl_union_map_domain_product(copy(), umap2.release());\n  return manage(res);\n}\n\nunion_map union_map::empty(space space)\n{\n  auto res = isl_union_map_empty(space.release());\n  return manage(res);\n}\n\nunion_map union_map::empty(ctx ctx)\n{\n  auto res = isl_union_map_empty_ctx(ctx.release());\n  return manage(res);\n}\n\nunion_map union_map::empty_space(space space)\n{\n  auto res = isl_union_map_empty_space(space.release());\n  return manage(res);\n}\n\nunion_map union_map::eq_at(multi_union_pw_aff mupa) const\n{\n  auto res = isl_union_map_eq_at_multi_union_pw_aff(copy(), mupa.release());\n  return manage(res);\n}\n\nmap union_map::extract_map(space space) const\n{\n  auto res = isl_union_map_extract_map(get(), space.release());\n  return manage(res);\n}\n\nunion_map union_map::factor_domain() const\n{\n  auto res = isl_union_map_factor_domain(copy());\n  return manage(res);\n}\n\nunion_map union_map::factor_range() const\n{\n  auto res = isl_union_map_factor_range(copy());\n  return manage(res);\n}\n\nint union_map::find_dim_by_name(isl::dim type, const std::string &name) const\n{\n  auto res = isl_union_map_find_dim_by_name(get(), static_cast<enum isl_dim_type>(type), name.c_str());\n  return res;\n}\n\nunion_map union_map::fixed_power(val exp) const\n{\n  auto res = isl_union_map_fixed_power_val(copy(), exp.release());\n  return manage(res);\n}\n\nunion_map union_map::flat_domain_product(union_map umap2) const\n{\n  auto res = isl_union_map_flat_domain_product(copy(), umap2.release());\n  return manage(res);\n}\n\nunion_map union_map::flat_range_product(union_map umap2) const\n{\n  auto res = isl_union_map_flat_range_product(copy(), umap2.release());\n  return manage(res);\n}\n\nstat union_map::foreach_map(const std::function<stat(map)> &fn) const\n{\n  struct fn_data {\n    const std::function<stat(map)> *func;\n  } fn_data = { &fn };\n  auto fn_lambda = [](isl_map *arg_0, void *arg_1) -> isl_stat {\n    auto *data = static_cast<struct fn_data *>(arg_1);\n    stat ret = (*data->func)(manage(arg_0));\n    return ret.release();\n  };\n  auto res = isl_union_map_foreach_map(get(), fn_lambda, &fn_data);\n  return manage(res);\n}\n\nunion_map union_map::from(multi_union_pw_aff mupa)\n{\n  auto res = isl_union_map_from_multi_union_pw_aff(mupa.release());\n  return manage(res);\n}\n\nunion_map union_map::from_domain(union_set uset)\n{\n  auto res = isl_union_map_from_domain(uset.release());\n  return manage(res);\n}\n\nunion_map union_map::from_domain_and_range(union_set domain, union_set range)\n{\n  auto res = isl_union_map_from_domain_and_range(domain.release(), range.release());\n  return manage(res);\n}\n\nunion_map union_map::from_range(union_set uset)\n{\n  auto res = isl_union_map_from_range(uset.release());\n  return manage(res);\n}\n\nunion_map union_map::from_union_pw_aff(union_pw_aff upa)\n{\n  auto res = isl_union_map_from_union_pw_aff(upa.release());\n  return manage(res);\n}\n\nid union_map::get_dim_id(isl::dim type, unsigned int pos) const\n{\n  auto res = isl_union_map_get_dim_id(get(), static_cast<enum isl_dim_type>(type), pos);\n  return manage(res);\n}\n\nuint32_t union_map::get_hash() const\n{\n  auto res = isl_union_map_get_hash(get());\n  return res;\n}\n\nmap_list union_map::get_map_list() const\n{\n  auto res = isl_union_map_get_map_list(get());\n  return manage(res);\n}\n\nspace union_map::get_space() const\n{\n  auto res = isl_union_map_get_space(get());\n  return manage(res);\n}\n\nunion_map union_map::gist(union_map context) const\n{\n  auto res = isl_union_map_gist(copy(), context.release());\n  return manage(res);\n}\n\nunion_map union_map::gist_domain(union_set uset) const\n{\n  auto res = isl_union_map_gist_domain(copy(), uset.release());\n  return manage(res);\n}\n\nunion_map union_map::gist_params(set set) const\n{\n  auto res = isl_union_map_gist_params(copy(), set.release());\n  return manage(res);\n}\n\nunion_map union_map::gist_range(union_set uset) const\n{\n  auto res = isl_union_map_gist_range(copy(), uset.release());\n  return manage(res);\n}\n\nunion_map union_map::intersect(union_map umap2) const\n{\n  auto res = isl_union_map_intersect(copy(), umap2.release());\n  return manage(res);\n}\n\nunion_map union_map::intersect_domain(space space) const\n{\n  auto res = isl_union_map_intersect_domain_space(copy(), space.release());\n  return manage(res);\n}\n\nunion_map union_map::intersect_domain(union_set uset) const\n{\n  auto res = isl_union_map_intersect_domain_union_set(copy(), uset.release());\n  return manage(res);\n}\n\nunion_map union_map::intersect_domain_factor_domain(union_map factor) const\n{\n  auto res = isl_union_map_intersect_domain_factor_domain(copy(), factor.release());\n  return manage(res);\n}\n\nunion_map union_map::intersect_domain_factor_range(union_map factor) const\n{\n  auto res = isl_union_map_intersect_domain_factor_range(copy(), factor.release());\n  return manage(res);\n}\n\nunion_map union_map::intersect_params(set set) const\n{\n  auto res = isl_union_map_intersect_params(copy(), set.release());\n  return manage(res);\n}\n\nunion_map union_map::intersect_range(space space) const\n{\n  auto res = isl_union_map_intersect_range_space(copy(), space.release());\n  return manage(res);\n}\n\nunion_map union_map::intersect_range(union_set uset) const\n{\n  auto res = isl_union_map_intersect_range_union_set(copy(), uset.release());\n  return manage(res);\n}\n\nunion_map union_map::intersect_range_factor_domain(union_map factor) const\n{\n  auto res = isl_union_map_intersect_range_factor_domain(copy(), factor.release());\n  return manage(res);\n}\n\nunion_map union_map::intersect_range_factor_range(union_map factor) const\n{\n  auto res = isl_union_map_intersect_range_factor_range(copy(), factor.release());\n  return manage(res);\n}\n\nboolean union_map::involves_dims(isl::dim type, unsigned int first, unsigned int n) const\n{\n  auto res = isl_union_map_involves_dims(get(), static_cast<enum isl_dim_type>(type), first, n);\n  return manage(res);\n}\n\nboolean union_map::is_bijective() const\n{\n  auto res = isl_union_map_is_bijective(get());\n  return manage(res);\n}\n\nboolean union_map::is_disjoint(const union_map &umap2) const\n{\n  auto res = isl_union_map_is_disjoint(get(), umap2.get());\n  return manage(res);\n}\n\nboolean union_map::is_empty() const\n{\n  auto res = isl_union_map_is_empty(get());\n  return manage(res);\n}\n\nboolean union_map::is_equal(const union_map &umap2) const\n{\n  auto res = isl_union_map_is_equal(get(), umap2.get());\n  return manage(res);\n}\n\nboolean union_map::is_identity() const\n{\n  auto res = isl_union_map_is_identity(get());\n  return manage(res);\n}\n\nboolean union_map::is_injective() const\n{\n  auto res = isl_union_map_is_injective(get());\n  return manage(res);\n}\n\nboolean union_map::is_single_valued() const\n{\n  auto res = isl_union_map_is_single_valued(get());\n  return manage(res);\n}\n\nboolean union_map::is_strict_subset(const union_map &umap2) const\n{\n  auto res = isl_union_map_is_strict_subset(get(), umap2.get());\n  return manage(res);\n}\n\nboolean union_map::is_subset(const union_map &umap2) const\n{\n  auto res = isl_union_map_is_subset(get(), umap2.get());\n  return manage(res);\n}\n\nboolean union_map::isa_map() const\n{\n  auto res = isl_union_map_isa_map(get());\n  return manage(res);\n}\n\nunion_map union_map::lex_ge_at_multi_union_pw_aff(multi_union_pw_aff mupa) const\n{\n  auto res = isl_union_map_lex_ge_at_multi_union_pw_aff(copy(), mupa.release());\n  return manage(res);\n}\n\nunion_map union_map::lex_ge_union_map(union_map umap2) const\n{\n  auto res = isl_union_map_lex_ge_union_map(copy(), umap2.release());\n  return manage(res);\n}\n\nunion_map union_map::lex_gt_at_multi_union_pw_aff(multi_union_pw_aff mupa) const\n{\n  auto res = isl_union_map_lex_gt_at_multi_union_pw_aff(copy(), mupa.release());\n  return manage(res);\n}\n\nunion_map union_map::lex_gt_union_map(union_map umap2) const\n{\n  auto res = isl_union_map_lex_gt_union_map(copy(), umap2.release());\n  return manage(res);\n}\n\nunion_map union_map::lex_le_at_multi_union_pw_aff(multi_union_pw_aff mupa) const\n{\n  auto res = isl_union_map_lex_le_at_multi_union_pw_aff(copy(), mupa.release());\n  return manage(res);\n}\n\nunion_map union_map::lex_le_union_map(union_map umap2) const\n{\n  auto res = isl_union_map_lex_le_union_map(copy(), umap2.release());\n  return manage(res);\n}\n\nunion_map union_map::lex_lt_at_multi_union_pw_aff(multi_union_pw_aff mupa) const\n{\n  auto res = isl_union_map_lex_lt_at_multi_union_pw_aff(copy(), mupa.release());\n  return manage(res);\n}\n\nunion_map union_map::lex_lt_union_map(union_map umap2) const\n{\n  auto res = isl_union_map_lex_lt_union_map(copy(), umap2.release());\n  return manage(res);\n}\n\nunion_map union_map::lexmax() const\n{\n  auto res = isl_union_map_lexmax(copy());\n  return manage(res);\n}\n\nunion_map union_map::lexmin() const\n{\n  auto res = isl_union_map_lexmin(copy());\n  return manage(res);\n}\n\nisl_size union_map::n_map() const\n{\n  auto res = isl_union_map_n_map(get());\n  return res;\n}\n\nset union_map::params() const\n{\n  auto res = isl_union_map_params(copy());\n  return manage(res);\n}\n\nboolean union_map::plain_is_empty() const\n{\n  auto res = isl_union_map_plain_is_empty(get());\n  return manage(res);\n}\n\nboolean union_map::plain_is_injective() const\n{\n  auto res = isl_union_map_plain_is_injective(get());\n  return manage(res);\n}\n\nunion_map union_map::polyhedral_hull() const\n{\n  auto res = isl_union_map_polyhedral_hull(copy());\n  return manage(res);\n}\n\nunion_map union_map::preimage_domain(multi_aff ma) const\n{\n  auto res = isl_union_map_preimage_domain_multi_aff(copy(), ma.release());\n  return manage(res);\n}\n\nunion_map union_map::preimage_domain(multi_pw_aff mpa) const\n{\n  auto res = isl_union_map_preimage_domain_multi_pw_aff(copy(), mpa.release());\n  return manage(res);\n}\n\nunion_map union_map::preimage_domain(pw_multi_aff pma) const\n{\n  auto res = isl_union_map_preimage_domain_pw_multi_aff(copy(), pma.release());\n  return manage(res);\n}\n\nunion_map union_map::preimage_domain(union_pw_multi_aff upma) const\n{\n  auto res = isl_union_map_preimage_domain_union_pw_multi_aff(copy(), upma.release());\n  return manage(res);\n}\n\nunion_map union_map::preimage_range(multi_aff ma) const\n{\n  auto res = isl_union_map_preimage_range_multi_aff(copy(), ma.release());\n  return manage(res);\n}\n\nunion_map union_map::preimage_range(pw_multi_aff pma) const\n{\n  auto res = isl_union_map_preimage_range_pw_multi_aff(copy(), pma.release());\n  return manage(res);\n}\n\nunion_map union_map::preimage_range(union_pw_multi_aff upma) const\n{\n  auto res = isl_union_map_preimage_range_union_pw_multi_aff(copy(), upma.release());\n  return manage(res);\n}\n\nunion_map union_map::product(union_map umap2) const\n{\n  auto res = isl_union_map_product(copy(), umap2.release());\n  return manage(res);\n}\n\nunion_map union_map::project_out(isl::dim type, unsigned int first, unsigned int n) const\n{\n  auto res = isl_union_map_project_out(copy(), static_cast<enum isl_dim_type>(type), first, n);\n  return manage(res);\n}\n\nunion_map union_map::project_out_all_params() const\n{\n  auto res = isl_union_map_project_out_all_params(copy());\n  return manage(res);\n}\n\nunion_set union_map::range() const\n{\n  auto res = isl_union_map_range(copy());\n  return manage(res);\n}\n\nunion_map union_map::range_curry() const\n{\n  auto res = isl_union_map_range_curry(copy());\n  return manage(res);\n}\n\nunion_map union_map::range_factor_domain() const\n{\n  auto res = isl_union_map_range_factor_domain(copy());\n  return manage(res);\n}\n\nunion_map union_map::range_factor_range() const\n{\n  auto res = isl_union_map_range_factor_range(copy());\n  return manage(res);\n}\n\nunion_map union_map::range_map() const\n{\n  auto res = isl_union_map_range_map(copy());\n  return manage(res);\n}\n\nunion_map union_map::range_product(union_map umap2) const\n{\n  auto res = isl_union_map_range_product(copy(), umap2.release());\n  return manage(res);\n}\n\nunion_map union_map::range_reverse() const\n{\n  auto res = isl_union_map_range_reverse(copy());\n  return manage(res);\n}\n\nunion_map union_map::remove_divs() const\n{\n  auto res = isl_union_map_remove_divs(copy());\n  return manage(res);\n}\n\nunion_map union_map::remove_redundancies() const\n{\n  auto res = isl_union_map_remove_redundancies(copy());\n  return manage(res);\n}\n\nunion_map union_map::reset_user() const\n{\n  auto res = isl_union_map_reset_user(copy());\n  return manage(res);\n}\n\nunion_map union_map::reverse() const\n{\n  auto res = isl_union_map_reverse(copy());\n  return manage(res);\n}\n\nbasic_map union_map::sample() const\n{\n  auto res = isl_union_map_sample(copy());\n  return manage(res);\n}\n\nunion_map union_map::simple_hull() const\n{\n  auto res = isl_union_map_simple_hull(copy());\n  return manage(res);\n}\n\nunion_map union_map::subtract(union_map umap2) const\n{\n  auto res = isl_union_map_subtract(copy(), umap2.release());\n  return manage(res);\n}\n\nunion_map union_map::subtract_domain(union_set dom) const\n{\n  auto res = isl_union_map_subtract_domain(copy(), dom.release());\n  return manage(res);\n}\n\nunion_map union_map::subtract_range(union_set dom) const\n{\n  auto res = isl_union_map_subtract_range(copy(), dom.release());\n  return manage(res);\n}\n\nunion_map union_map::uncurry() const\n{\n  auto res = isl_union_map_uncurry(copy());\n  return manage(res);\n}\n\nunion_map union_map::unite(union_map umap2) const\n{\n  auto res = isl_union_map_union(copy(), umap2.release());\n  return manage(res);\n}\n\nunion_map union_map::universe() const\n{\n  auto res = isl_union_map_universe(copy());\n  return manage(res);\n}\n\nunion_set union_map::wrap() const\n{\n  auto res = isl_union_map_wrap(copy());\n  return manage(res);\n}\n\nunion_map union_map::zip() const\n{\n  auto res = isl_union_map_zip(copy());\n  return manage(res);\n}\n\n// implementations for isl::union_map_list\nunion_map_list manage(__isl_take isl_union_map_list *ptr) {\n  return union_map_list(ptr);\n}\nunion_map_list manage_copy(__isl_keep isl_union_map_list *ptr) {\n  ptr = isl_union_map_list_copy(ptr);\n  return union_map_list(ptr);\n}\n\nunion_map_list::union_map_list()\n    : ptr(nullptr) {}\n\nunion_map_list::union_map_list(const union_map_list &obj)\n    : ptr(nullptr)\n{\n  ptr = obj.copy();\n}\nunion_map_list::union_map_list(std::nullptr_t)\n    : ptr(nullptr) {}\n\n\nunion_map_list::union_map_list(__isl_take isl_union_map_list *ptr)\n    : ptr(ptr) {}\n\n\nunion_map_list &union_map_list::operator=(union_map_list obj) {\n  std::swap(this->ptr, obj.ptr);\n  return *this;\n}\n\nunion_map_list::~union_map_list() {\n  if (ptr)\n    isl_union_map_list_free(ptr);\n}\n\n__isl_give isl_union_map_list *union_map_list::copy() const & {\n  return isl_union_map_list_copy(ptr);\n}\n\n__isl_keep isl_union_map_list *union_map_list::get() const {\n  return ptr;\n}\n\n__isl_give isl_union_map_list *union_map_list::release() {\n  isl_union_map_list *tmp = ptr;\n  ptr = nullptr;\n  return tmp;\n}\n\nbool union_map_list::is_null() const {\n  return ptr == nullptr;\n}\nunion_map_list::operator bool() const {\n  return !is_null();\n}\n\n\nctx union_map_list::get_ctx() const {\n  return ctx(isl_union_map_list_get_ctx(ptr));\n}\nstd::string union_map_list::to_str() const {\n  char *Tmp = isl_union_map_list_to_str(get());\n  if (!Tmp)\n    return \"\";\n  std::string S(Tmp);\n  free(Tmp);\n  return S;\n}\n\n\nvoid union_map_list::dump() const {\n  isl_union_map_list_dump(get());\n}\n\n\nunion_map_list union_map_list::add(union_map el) const\n{\n  auto res = isl_union_map_list_add(copy(), el.release());\n  return manage(res);\n}\n\nunion_map_list union_map_list::alloc(ctx ctx, int n)\n{\n  auto res = isl_union_map_list_alloc(ctx.release(), n);\n  return manage(res);\n}\n\nunion_map_list union_map_list::clear() const\n{\n  auto res = isl_union_map_list_clear(copy());\n  return manage(res);\n}\n\nunion_map_list union_map_list::concat(union_map_list list2) const\n{\n  auto res = isl_union_map_list_concat(copy(), list2.release());\n  return manage(res);\n}\n\nunion_map_list union_map_list::drop(unsigned int first, unsigned int n) const\n{\n  auto res = isl_union_map_list_drop(copy(), first, n);\n  return manage(res);\n}\n\nstat union_map_list::foreach(const std::function<stat(union_map)> &fn) const\n{\n  struct fn_data {\n    const std::function<stat(union_map)> *func;\n  } fn_data = { &fn };\n  auto fn_lambda = [](isl_union_map *arg_0, void *arg_1) -> isl_stat {\n    auto *data = static_cast<struct fn_data *>(arg_1);\n    stat ret = (*data->func)(manage(arg_0));\n    return ret.release();\n  };\n  auto res = isl_union_map_list_foreach(get(), fn_lambda, &fn_data);\n  return manage(res);\n}\n\nunion_map_list union_map_list::from_union_map(union_map el)\n{\n  auto res = isl_union_map_list_from_union_map(el.release());\n  return manage(res);\n}\n\nunion_map union_map_list::get_at(int index) const\n{\n  auto res = isl_union_map_list_get_at(get(), index);\n  return manage(res);\n}\n\nunion_map union_map_list::get_union_map(int index) const\n{\n  auto res = isl_union_map_list_get_union_map(get(), index);\n  return manage(res);\n}\n\nunion_map_list union_map_list::insert(unsigned int pos, union_map el) const\n{\n  auto res = isl_union_map_list_insert(copy(), pos, el.release());\n  return manage(res);\n}\n\nisl_size union_map_list::n_union_map() const\n{\n  auto res = isl_union_map_list_n_union_map(get());\n  return res;\n}\n\nunion_map_list union_map_list::reverse() const\n{\n  auto res = isl_union_map_list_reverse(copy());\n  return manage(res);\n}\n\nunion_map_list union_map_list::set_union_map(int index, union_map el) const\n{\n  auto res = isl_union_map_list_set_union_map(copy(), index, el.release());\n  return manage(res);\n}\n\nisl_size union_map_list::size() const\n{\n  auto res = isl_union_map_list_size(get());\n  return res;\n}\n\nunion_map_list union_map_list::swap(unsigned int pos1, unsigned int pos2) const\n{\n  auto res = isl_union_map_list_swap(copy(), pos1, pos2);\n  return manage(res);\n}\n\n// implementations for isl::union_pw_aff\nunion_pw_aff manage(__isl_take isl_union_pw_aff *ptr) {\n  return union_pw_aff(ptr);\n}\nunion_pw_aff manage_copy(__isl_keep isl_union_pw_aff *ptr) {\n  ptr = isl_union_pw_aff_copy(ptr);\n  return union_pw_aff(ptr);\n}\n\nunion_pw_aff::union_pw_aff()\n    : ptr(nullptr) {}\n\nunion_pw_aff::union_pw_aff(const union_pw_aff &obj)\n    : ptr(nullptr)\n{\n  ptr = obj.copy();\n}\nunion_pw_aff::union_pw_aff(std::nullptr_t)\n    : ptr(nullptr) {}\n\n\nunion_pw_aff::union_pw_aff(__isl_take isl_union_pw_aff *ptr)\n    : ptr(ptr) {}\n\nunion_pw_aff::union_pw_aff(aff aff)\n{\n  auto res = isl_union_pw_aff_from_aff(aff.release());\n  ptr = res;\n}\nunion_pw_aff::union_pw_aff(pw_aff pa)\n{\n  auto res = isl_union_pw_aff_from_pw_aff(pa.release());\n  ptr = res;\n}\nunion_pw_aff::union_pw_aff(ctx ctx, const std::string &str)\n{\n  auto res = isl_union_pw_aff_read_from_str(ctx.release(), str.c_str());\n  ptr = res;\n}\nunion_pw_aff::union_pw_aff(union_set domain, val v)\n{\n  auto res = isl_union_pw_aff_val_on_domain(domain.release(), v.release());\n  ptr = res;\n}\n\nunion_pw_aff &union_pw_aff::operator=(union_pw_aff obj) {\n  std::swap(this->ptr, obj.ptr);\n  return *this;\n}\n\nunion_pw_aff::~union_pw_aff() {\n  if (ptr)\n    isl_union_pw_aff_free(ptr);\n}\n\n__isl_give isl_union_pw_aff *union_pw_aff::copy() const & {\n  return isl_union_pw_aff_copy(ptr);\n}\n\n__isl_keep isl_union_pw_aff *union_pw_aff::get() const {\n  return ptr;\n}\n\n__isl_give isl_union_pw_aff *union_pw_aff::release() {\n  isl_union_pw_aff *tmp = ptr;\n  ptr = nullptr;\n  return tmp;\n}\n\nbool union_pw_aff::is_null() const {\n  return ptr == nullptr;\n}\nunion_pw_aff::operator bool() const {\n  return !is_null();\n}\n\n\nctx union_pw_aff::get_ctx() const {\n  return ctx(isl_union_pw_aff_get_ctx(ptr));\n}\nstd::string union_pw_aff::to_str() const {\n  char *Tmp = isl_union_pw_aff_to_str(get());\n  if (!Tmp)\n    return \"\";\n  std::string S(Tmp);\n  free(Tmp);\n  return S;\n}\n\n\nvoid union_pw_aff::dump() const {\n  isl_union_pw_aff_dump(get());\n}\n\n\nunion_pw_aff union_pw_aff::add(union_pw_aff upa2) const\n{\n  auto res = isl_union_pw_aff_add(copy(), upa2.release());\n  return manage(res);\n}\n\nunion_pw_aff union_pw_aff::add_pw_aff(pw_aff pa) const\n{\n  auto res = isl_union_pw_aff_add_pw_aff(copy(), pa.release());\n  return manage(res);\n}\n\nunion_pw_aff union_pw_aff::aff_on_domain(union_set domain, aff aff)\n{\n  auto res = isl_union_pw_aff_aff_on_domain(domain.release(), aff.release());\n  return manage(res);\n}\n\nunion_pw_aff union_pw_aff::align_params(space model) const\n{\n  auto res = isl_union_pw_aff_align_params(copy(), model.release());\n  return manage(res);\n}\n\nunion_set union_pw_aff::bind(id id) const\n{\n  auto res = isl_union_pw_aff_bind_id(copy(), id.release());\n  return manage(res);\n}\n\nunion_pw_aff union_pw_aff::coalesce() const\n{\n  auto res = isl_union_pw_aff_coalesce(copy());\n  return manage(res);\n}\n\nisl_size union_pw_aff::dim(isl::dim type) const\n{\n  auto res = isl_union_pw_aff_dim(get(), static_cast<enum isl_dim_type>(type));\n  return res;\n}\n\nunion_set union_pw_aff::domain() const\n{\n  auto res = isl_union_pw_aff_domain(copy());\n  return manage(res);\n}\n\nunion_pw_aff union_pw_aff::drop_dims(isl::dim type, unsigned int first, unsigned int n) const\n{\n  auto res = isl_union_pw_aff_drop_dims(copy(), static_cast<enum isl_dim_type>(type), first, n);\n  return manage(res);\n}\n\nunion_pw_aff union_pw_aff::empty(space space)\n{\n  auto res = isl_union_pw_aff_empty(space.release());\n  return manage(res);\n}\n\nunion_pw_aff union_pw_aff::empty_ctx(ctx ctx)\n{\n  auto res = isl_union_pw_aff_empty_ctx(ctx.release());\n  return manage(res);\n}\n\nunion_pw_aff union_pw_aff::empty_space(space space)\n{\n  auto res = isl_union_pw_aff_empty_space(space.release());\n  return manage(res);\n}\n\npw_aff union_pw_aff::extract_pw_aff(space space) const\n{\n  auto res = isl_union_pw_aff_extract_pw_aff(get(), space.release());\n  return manage(res);\n}\n\nint union_pw_aff::find_dim_by_name(isl::dim type, const std::string &name) const\n{\n  auto res = isl_union_pw_aff_find_dim_by_name(get(), static_cast<enum isl_dim_type>(type), name.c_str());\n  return res;\n}\n\nunion_pw_aff union_pw_aff::floor() const\n{\n  auto res = isl_union_pw_aff_floor(copy());\n  return manage(res);\n}\n\nstat union_pw_aff::foreach_pw_aff(const std::function<stat(pw_aff)> &fn) const\n{\n  struct fn_data {\n    const std::function<stat(pw_aff)> *func;\n  } fn_data = { &fn };\n  auto fn_lambda = [](isl_pw_aff *arg_0, void *arg_1) -> isl_stat {\n    auto *data = static_cast<struct fn_data *>(arg_1);\n    stat ret = (*data->func)(manage(arg_0));\n    return ret.release();\n  };\n  auto res = isl_union_pw_aff_foreach_pw_aff(get(), fn_lambda, &fn_data);\n  return manage(res);\n}\n\npw_aff_list union_pw_aff::get_pw_aff_list() const\n{\n  auto res = isl_union_pw_aff_get_pw_aff_list(get());\n  return manage(res);\n}\n\nspace union_pw_aff::get_space() const\n{\n  auto res = isl_union_pw_aff_get_space(get());\n  return manage(res);\n}\n\nunion_pw_aff union_pw_aff::gist(union_set context) const\n{\n  auto res = isl_union_pw_aff_gist(copy(), context.release());\n  return manage(res);\n}\n\nunion_pw_aff union_pw_aff::gist_params(set context) const\n{\n  auto res = isl_union_pw_aff_gist_params(copy(), context.release());\n  return manage(res);\n}\n\nunion_pw_aff union_pw_aff::intersect_domain(space space) const\n{\n  auto res = isl_union_pw_aff_intersect_domain_space(copy(), space.release());\n  return manage(res);\n}\n\nunion_pw_aff union_pw_aff::intersect_domain(union_set uset) const\n{\n  auto res = isl_union_pw_aff_intersect_domain_union_set(copy(), uset.release());\n  return manage(res);\n}\n\nunion_pw_aff union_pw_aff::intersect_domain_wrapped_domain(union_set uset) const\n{\n  auto res = isl_union_pw_aff_intersect_domain_wrapped_domain(copy(), uset.release());\n  return manage(res);\n}\n\nunion_pw_aff union_pw_aff::intersect_domain_wrapped_range(union_set uset) const\n{\n  auto res = isl_union_pw_aff_intersect_domain_wrapped_range(copy(), uset.release());\n  return manage(res);\n}\n\nunion_pw_aff union_pw_aff::intersect_params(set set) const\n{\n  auto res = isl_union_pw_aff_intersect_params(copy(), set.release());\n  return manage(res);\n}\n\nboolean union_pw_aff::involves_nan() const\n{\n  auto res = isl_union_pw_aff_involves_nan(get());\n  return manage(res);\n}\n\nval union_pw_aff::max_val() const\n{\n  auto res = isl_union_pw_aff_max_val(copy());\n  return manage(res);\n}\n\nval union_pw_aff::min_val() const\n{\n  auto res = isl_union_pw_aff_min_val(copy());\n  return manage(res);\n}\n\nunion_pw_aff union_pw_aff::mod_val(val f) const\n{\n  auto res = isl_union_pw_aff_mod_val(copy(), f.release());\n  return manage(res);\n}\n\nisl_size union_pw_aff::n_pw_aff() const\n{\n  auto res = isl_union_pw_aff_n_pw_aff(get());\n  return res;\n}\n\nunion_pw_aff union_pw_aff::neg() const\n{\n  auto res = isl_union_pw_aff_neg(copy());\n  return manage(res);\n}\n\nunion_pw_aff union_pw_aff::param_on_domain_id(union_set domain, id id)\n{\n  auto res = isl_union_pw_aff_param_on_domain_id(domain.release(), id.release());\n  return manage(res);\n}\n\nboolean union_pw_aff::plain_is_equal(const union_pw_aff &upa2) const\n{\n  auto res = isl_union_pw_aff_plain_is_equal(get(), upa2.get());\n  return manage(res);\n}\n\nunion_pw_aff union_pw_aff::pullback(union_pw_multi_aff upma) const\n{\n  auto res = isl_union_pw_aff_pullback_union_pw_multi_aff(copy(), upma.release());\n  return manage(res);\n}\n\nunion_pw_aff union_pw_aff::pw_aff_on_domain(union_set domain, pw_aff pa)\n{\n  auto res = isl_union_pw_aff_pw_aff_on_domain(domain.release(), pa.release());\n  return manage(res);\n}\n\nunion_pw_aff union_pw_aff::reset_user() const\n{\n  auto res = isl_union_pw_aff_reset_user(copy());\n  return manage(res);\n}\n\nunion_pw_aff union_pw_aff::scale_down_val(val v) const\n{\n  auto res = isl_union_pw_aff_scale_down_val(copy(), v.release());\n  return manage(res);\n}\n\nunion_pw_aff union_pw_aff::scale_val(val v) const\n{\n  auto res = isl_union_pw_aff_scale_val(copy(), v.release());\n  return manage(res);\n}\n\nunion_pw_aff union_pw_aff::sub(union_pw_aff upa2) const\n{\n  auto res = isl_union_pw_aff_sub(copy(), upa2.release());\n  return manage(res);\n}\n\nunion_pw_aff union_pw_aff::subtract_domain(space space) const\n{\n  auto res = isl_union_pw_aff_subtract_domain_space(copy(), space.release());\n  return manage(res);\n}\n\nunion_pw_aff union_pw_aff::subtract_domain(union_set uset) const\n{\n  auto res = isl_union_pw_aff_subtract_domain_union_set(copy(), uset.release());\n  return manage(res);\n}\n\nunion_pw_aff union_pw_aff::union_add(union_pw_aff upa2) const\n{\n  auto res = isl_union_pw_aff_union_add(copy(), upa2.release());\n  return manage(res);\n}\n\nunion_set union_pw_aff::zero_union_set() const\n{\n  auto res = isl_union_pw_aff_zero_union_set(copy());\n  return manage(res);\n}\n\n// implementations for isl::union_pw_aff_list\nunion_pw_aff_list manage(__isl_take isl_union_pw_aff_list *ptr) {\n  return union_pw_aff_list(ptr);\n}\nunion_pw_aff_list manage_copy(__isl_keep isl_union_pw_aff_list *ptr) {\n  ptr = isl_union_pw_aff_list_copy(ptr);\n  return union_pw_aff_list(ptr);\n}\n\nunion_pw_aff_list::union_pw_aff_list()\n    : ptr(nullptr) {}\n\nunion_pw_aff_list::union_pw_aff_list(const union_pw_aff_list &obj)\n    : ptr(nullptr)\n{\n  ptr = obj.copy();\n}\nunion_pw_aff_list::union_pw_aff_list(std::nullptr_t)\n    : ptr(nullptr) {}\n\n\nunion_pw_aff_list::union_pw_aff_list(__isl_take isl_union_pw_aff_list *ptr)\n    : ptr(ptr) {}\n\n\nunion_pw_aff_list &union_pw_aff_list::operator=(union_pw_aff_list obj) {\n  std::swap(this->ptr, obj.ptr);\n  return *this;\n}\n\nunion_pw_aff_list::~union_pw_aff_list() {\n  if (ptr)\n    isl_union_pw_aff_list_free(ptr);\n}\n\n__isl_give isl_union_pw_aff_list *union_pw_aff_list::copy() const & {\n  return isl_union_pw_aff_list_copy(ptr);\n}\n\n__isl_keep isl_union_pw_aff_list *union_pw_aff_list::get() const {\n  return ptr;\n}\n\n__isl_give isl_union_pw_aff_list *union_pw_aff_list::release() {\n  isl_union_pw_aff_list *tmp = ptr;\n  ptr = nullptr;\n  return tmp;\n}\n\nbool union_pw_aff_list::is_null() const {\n  return ptr == nullptr;\n}\nunion_pw_aff_list::operator bool() const {\n  return !is_null();\n}\n\n\nctx union_pw_aff_list::get_ctx() const {\n  return ctx(isl_union_pw_aff_list_get_ctx(ptr));\n}\nstd::string union_pw_aff_list::to_str() const {\n  char *Tmp = isl_union_pw_aff_list_to_str(get());\n  if (!Tmp)\n    return \"\";\n  std::string S(Tmp);\n  free(Tmp);\n  return S;\n}\n\n\nvoid union_pw_aff_list::dump() const {\n  isl_union_pw_aff_list_dump(get());\n}\n\n\nunion_pw_aff_list union_pw_aff_list::add(union_pw_aff el) const\n{\n  auto res = isl_union_pw_aff_list_add(copy(), el.release());\n  return manage(res);\n}\n\nunion_pw_aff_list union_pw_aff_list::alloc(ctx ctx, int n)\n{\n  auto res = isl_union_pw_aff_list_alloc(ctx.release(), n);\n  return manage(res);\n}\n\nunion_pw_aff_list union_pw_aff_list::clear() const\n{\n  auto res = isl_union_pw_aff_list_clear(copy());\n  return manage(res);\n}\n\nunion_pw_aff_list union_pw_aff_list::concat(union_pw_aff_list list2) const\n{\n  auto res = isl_union_pw_aff_list_concat(copy(), list2.release());\n  return manage(res);\n}\n\nunion_pw_aff_list union_pw_aff_list::drop(unsigned int first, unsigned int n) const\n{\n  auto res = isl_union_pw_aff_list_drop(copy(), first, n);\n  return manage(res);\n}\n\nstat union_pw_aff_list::foreach(const std::function<stat(union_pw_aff)> &fn) const\n{\n  struct fn_data {\n    const std::function<stat(union_pw_aff)> *func;\n  } fn_data = { &fn };\n  auto fn_lambda = [](isl_union_pw_aff *arg_0, void *arg_1) -> isl_stat {\n    auto *data = static_cast<struct fn_data *>(arg_1);\n    stat ret = (*data->func)(manage(arg_0));\n    return ret.release();\n  };\n  auto res = isl_union_pw_aff_list_foreach(get(), fn_lambda, &fn_data);\n  return manage(res);\n}\n\nunion_pw_aff_list union_pw_aff_list::from_union_pw_aff(union_pw_aff el)\n{\n  auto res = isl_union_pw_aff_list_from_union_pw_aff(el.release());\n  return manage(res);\n}\n\nunion_pw_aff union_pw_aff_list::get_at(int index) const\n{\n  auto res = isl_union_pw_aff_list_get_at(get(), index);\n  return manage(res);\n}\n\nunion_pw_aff union_pw_aff_list::get_union_pw_aff(int index) const\n{\n  auto res = isl_union_pw_aff_list_get_union_pw_aff(get(), index);\n  return manage(res);\n}\n\nunion_pw_aff_list union_pw_aff_list::insert(unsigned int pos, union_pw_aff el) const\n{\n  auto res = isl_union_pw_aff_list_insert(copy(), pos, el.release());\n  return manage(res);\n}\n\nisl_size union_pw_aff_list::n_union_pw_aff() const\n{\n  auto res = isl_union_pw_aff_list_n_union_pw_aff(get());\n  return res;\n}\n\nunion_pw_aff_list union_pw_aff_list::reverse() const\n{\n  auto res = isl_union_pw_aff_list_reverse(copy());\n  return manage(res);\n}\n\nunion_pw_aff_list union_pw_aff_list::set_union_pw_aff(int index, union_pw_aff el) const\n{\n  auto res = isl_union_pw_aff_list_set_union_pw_aff(copy(), index, el.release());\n  return manage(res);\n}\n\nisl_size union_pw_aff_list::size() const\n{\n  auto res = isl_union_pw_aff_list_size(get());\n  return res;\n}\n\nunion_pw_aff_list union_pw_aff_list::swap(unsigned int pos1, unsigned int pos2) const\n{\n  auto res = isl_union_pw_aff_list_swap(copy(), pos1, pos2);\n  return manage(res);\n}\n\n// implementations for isl::union_pw_multi_aff\nunion_pw_multi_aff manage(__isl_take isl_union_pw_multi_aff *ptr) {\n  return union_pw_multi_aff(ptr);\n}\nunion_pw_multi_aff manage_copy(__isl_keep isl_union_pw_multi_aff *ptr) {\n  ptr = isl_union_pw_multi_aff_copy(ptr);\n  return union_pw_multi_aff(ptr);\n}\n\nunion_pw_multi_aff::union_pw_multi_aff()\n    : ptr(nullptr) {}\n\nunion_pw_multi_aff::union_pw_multi_aff(const union_pw_multi_aff &obj)\n    : ptr(nullptr)\n{\n  ptr = obj.copy();\n}\nunion_pw_multi_aff::union_pw_multi_aff(std::nullptr_t)\n    : ptr(nullptr) {}\n\n\nunion_pw_multi_aff::union_pw_multi_aff(__isl_take isl_union_pw_multi_aff *ptr)\n    : ptr(ptr) {}\n\nunion_pw_multi_aff::union_pw_multi_aff(aff aff)\n{\n  auto res = isl_union_pw_multi_aff_from_aff(aff.release());\n  ptr = res;\n}\nunion_pw_multi_aff::union_pw_multi_aff(union_set uset)\n{\n  auto res = isl_union_pw_multi_aff_from_domain(uset.release());\n  ptr = res;\n}\nunion_pw_multi_aff::union_pw_multi_aff(multi_aff ma)\n{\n  auto res = isl_union_pw_multi_aff_from_multi_aff(ma.release());\n  ptr = res;\n}\nunion_pw_multi_aff::union_pw_multi_aff(multi_union_pw_aff mupa)\n{\n  auto res = isl_union_pw_multi_aff_from_multi_union_pw_aff(mupa.release());\n  ptr = res;\n}\nunion_pw_multi_aff::union_pw_multi_aff(pw_multi_aff pma)\n{\n  auto res = isl_union_pw_multi_aff_from_pw_multi_aff(pma.release());\n  ptr = res;\n}\nunion_pw_multi_aff::union_pw_multi_aff(union_map umap)\n{\n  auto res = isl_union_pw_multi_aff_from_union_map(umap.release());\n  ptr = res;\n}\nunion_pw_multi_aff::union_pw_multi_aff(union_pw_aff upa)\n{\n  auto res = isl_union_pw_multi_aff_from_union_pw_aff(upa.release());\n  ptr = res;\n}\nunion_pw_multi_aff::union_pw_multi_aff(ctx ctx, const std::string &str)\n{\n  auto res = isl_union_pw_multi_aff_read_from_str(ctx.release(), str.c_str());\n  ptr = res;\n}\n\nunion_pw_multi_aff &union_pw_multi_aff::operator=(union_pw_multi_aff obj) {\n  std::swap(this->ptr, obj.ptr);\n  return *this;\n}\n\nunion_pw_multi_aff::~union_pw_multi_aff() {\n  if (ptr)\n    isl_union_pw_multi_aff_free(ptr);\n}\n\n__isl_give isl_union_pw_multi_aff *union_pw_multi_aff::copy() const & {\n  return isl_union_pw_multi_aff_copy(ptr);\n}\n\n__isl_keep isl_union_pw_multi_aff *union_pw_multi_aff::get() const {\n  return ptr;\n}\n\n__isl_give isl_union_pw_multi_aff *union_pw_multi_aff::release() {\n  isl_union_pw_multi_aff *tmp = ptr;\n  ptr = nullptr;\n  return tmp;\n}\n\nbool union_pw_multi_aff::is_null() const {\n  return ptr == nullptr;\n}\nunion_pw_multi_aff::operator bool() const {\n  return !is_null();\n}\n\n\nctx union_pw_multi_aff::get_ctx() const {\n  return ctx(isl_union_pw_multi_aff_get_ctx(ptr));\n}\nstd::string union_pw_multi_aff::to_str() const {\n  char *Tmp = isl_union_pw_multi_aff_to_str(get());\n  if (!Tmp)\n    return \"\";\n  std::string S(Tmp);\n  free(Tmp);\n  return S;\n}\n\n\nvoid union_pw_multi_aff::dump() const {\n  isl_union_pw_multi_aff_dump(get());\n}\n\n\nunion_pw_multi_aff union_pw_multi_aff::add(union_pw_multi_aff upma2) const\n{\n  auto res = isl_union_pw_multi_aff_add(copy(), upma2.release());\n  return manage(res);\n}\n\nunion_pw_multi_aff union_pw_multi_aff::add_pw_multi_aff(pw_multi_aff pma) const\n{\n  auto res = isl_union_pw_multi_aff_add_pw_multi_aff(copy(), pma.release());\n  return manage(res);\n}\n\nunion_pw_multi_aff union_pw_multi_aff::align_params(space model) const\n{\n  auto res = isl_union_pw_multi_aff_align_params(copy(), model.release());\n  return manage(res);\n}\n\nunion_pw_multi_aff union_pw_multi_aff::apply(union_pw_multi_aff upma2) const\n{\n  auto res = isl_union_pw_multi_aff_apply_union_pw_multi_aff(copy(), upma2.release());\n  return manage(res);\n}\n\npw_multi_aff union_pw_multi_aff::as_pw_multi_aff() const\n{\n  auto res = isl_union_pw_multi_aff_as_pw_multi_aff(copy());\n  return manage(res);\n}\n\nunion_pw_multi_aff union_pw_multi_aff::coalesce() const\n{\n  auto res = isl_union_pw_multi_aff_coalesce(copy());\n  return manage(res);\n}\n\nisl_size union_pw_multi_aff::dim(isl::dim type) const\n{\n  auto res = isl_union_pw_multi_aff_dim(get(), static_cast<enum isl_dim_type>(type));\n  return res;\n}\n\nunion_set union_pw_multi_aff::domain() const\n{\n  auto res = isl_union_pw_multi_aff_domain(copy());\n  return manage(res);\n}\n\nunion_pw_multi_aff union_pw_multi_aff::drop_dims(isl::dim type, unsigned int first, unsigned int n) const\n{\n  auto res = isl_union_pw_multi_aff_drop_dims(copy(), static_cast<enum isl_dim_type>(type), first, n);\n  return manage(res);\n}\n\nunion_pw_multi_aff union_pw_multi_aff::empty(space space)\n{\n  auto res = isl_union_pw_multi_aff_empty(space.release());\n  return manage(res);\n}\n\nunion_pw_multi_aff union_pw_multi_aff::empty(ctx ctx)\n{\n  auto res = isl_union_pw_multi_aff_empty_ctx(ctx.release());\n  return manage(res);\n}\n\nunion_pw_multi_aff union_pw_multi_aff::empty_space(space space)\n{\n  auto res = isl_union_pw_multi_aff_empty_space(space.release());\n  return manage(res);\n}\n\npw_multi_aff union_pw_multi_aff::extract_pw_multi_aff(space space) const\n{\n  auto res = isl_union_pw_multi_aff_extract_pw_multi_aff(get(), space.release());\n  return manage(res);\n}\n\nint union_pw_multi_aff::find_dim_by_name(isl::dim type, const std::string &name) const\n{\n  auto res = isl_union_pw_multi_aff_find_dim_by_name(get(), static_cast<enum isl_dim_type>(type), name.c_str());\n  return res;\n}\n\nunion_pw_multi_aff union_pw_multi_aff::flat_range_product(union_pw_multi_aff upma2) const\n{\n  auto res = isl_union_pw_multi_aff_flat_range_product(copy(), upma2.release());\n  return manage(res);\n}\n\nstat union_pw_multi_aff::foreach_pw_multi_aff(const std::function<stat(pw_multi_aff)> &fn) const\n{\n  struct fn_data {\n    const std::function<stat(pw_multi_aff)> *func;\n  } fn_data = { &fn };\n  auto fn_lambda = [](isl_pw_multi_aff *arg_0, void *arg_1) -> isl_stat {\n    auto *data = static_cast<struct fn_data *>(arg_1);\n    stat ret = (*data->func)(manage(arg_0));\n    return ret.release();\n  };\n  auto res = isl_union_pw_multi_aff_foreach_pw_multi_aff(get(), fn_lambda, &fn_data);\n  return manage(res);\n}\n\nunion_pw_multi_aff union_pw_multi_aff::from_union_set(union_set uset)\n{\n  auto res = isl_union_pw_multi_aff_from_union_set(uset.release());\n  return manage(res);\n}\n\npw_multi_aff_list union_pw_multi_aff::get_pw_multi_aff_list() const\n{\n  auto res = isl_union_pw_multi_aff_get_pw_multi_aff_list(get());\n  return manage(res);\n}\n\nspace union_pw_multi_aff::get_space() const\n{\n  auto res = isl_union_pw_multi_aff_get_space(get());\n  return manage(res);\n}\n\nunion_pw_aff union_pw_multi_aff::get_union_pw_aff(int pos) const\n{\n  auto res = isl_union_pw_multi_aff_get_union_pw_aff(get(), pos);\n  return manage(res);\n}\n\nunion_pw_multi_aff union_pw_multi_aff::gist(union_set context) const\n{\n  auto res = isl_union_pw_multi_aff_gist(copy(), context.release());\n  return manage(res);\n}\n\nunion_pw_multi_aff union_pw_multi_aff::gist_params(set context) const\n{\n  auto res = isl_union_pw_multi_aff_gist_params(copy(), context.release());\n  return manage(res);\n}\n\nunion_pw_multi_aff union_pw_multi_aff::intersect_domain(space space) const\n{\n  auto res = isl_union_pw_multi_aff_intersect_domain_space(copy(), space.release());\n  return manage(res);\n}\n\nunion_pw_multi_aff union_pw_multi_aff::intersect_domain(union_set uset) const\n{\n  auto res = isl_union_pw_multi_aff_intersect_domain_union_set(copy(), uset.release());\n  return manage(res);\n}\n\nunion_pw_multi_aff union_pw_multi_aff::intersect_domain_wrapped_domain(union_set uset) const\n{\n  auto res = isl_union_pw_multi_aff_intersect_domain_wrapped_domain(copy(), uset.release());\n  return manage(res);\n}\n\nunion_pw_multi_aff union_pw_multi_aff::intersect_domain_wrapped_range(union_set uset) const\n{\n  auto res = isl_union_pw_multi_aff_intersect_domain_wrapped_range(copy(), uset.release());\n  return manage(res);\n}\n\nunion_pw_multi_aff union_pw_multi_aff::intersect_params(set set) const\n{\n  auto res = isl_union_pw_multi_aff_intersect_params(copy(), set.release());\n  return manage(res);\n}\n\nboolean union_pw_multi_aff::involves_locals() const\n{\n  auto res = isl_union_pw_multi_aff_involves_locals(get());\n  return manage(res);\n}\n\nboolean union_pw_multi_aff::involves_nan() const\n{\n  auto res = isl_union_pw_multi_aff_involves_nan(get());\n  return manage(res);\n}\n\nboolean union_pw_multi_aff::isa_pw_multi_aff() const\n{\n  auto res = isl_union_pw_multi_aff_isa_pw_multi_aff(get());\n  return manage(res);\n}\n\nunion_pw_multi_aff union_pw_multi_aff::multi_val_on_domain(union_set domain, multi_val mv)\n{\n  auto res = isl_union_pw_multi_aff_multi_val_on_domain(domain.release(), mv.release());\n  return manage(res);\n}\n\nisl_size union_pw_multi_aff::n_pw_multi_aff() const\n{\n  auto res = isl_union_pw_multi_aff_n_pw_multi_aff(get());\n  return res;\n}\n\nunion_pw_multi_aff union_pw_multi_aff::neg() const\n{\n  auto res = isl_union_pw_multi_aff_neg(copy());\n  return manage(res);\n}\n\nboolean union_pw_multi_aff::plain_is_empty() const\n{\n  auto res = isl_union_pw_multi_aff_plain_is_empty(get());\n  return manage(res);\n}\n\nboolean union_pw_multi_aff::plain_is_equal(const union_pw_multi_aff &upma2) const\n{\n  auto res = isl_union_pw_multi_aff_plain_is_equal(get(), upma2.get());\n  return manage(res);\n}\n\nunion_pw_multi_aff union_pw_multi_aff::preimage_domain_wrapped_domain(union_pw_multi_aff upma2) const\n{\n  auto res = isl_union_pw_multi_aff_preimage_domain_wrapped_domain_union_pw_multi_aff(copy(), upma2.release());\n  return manage(res);\n}\n\nunion_pw_multi_aff union_pw_multi_aff::pullback(union_pw_multi_aff upma2) const\n{\n  auto res = isl_union_pw_multi_aff_pullback_union_pw_multi_aff(copy(), upma2.release());\n  return manage(res);\n}\n\nunion_pw_multi_aff union_pw_multi_aff::range_factor_domain() const\n{\n  auto res = isl_union_pw_multi_aff_range_factor_domain(copy());\n  return manage(res);\n}\n\nunion_pw_multi_aff union_pw_multi_aff::range_factor_range() const\n{\n  auto res = isl_union_pw_multi_aff_range_factor_range(copy());\n  return manage(res);\n}\n\nunion_pw_multi_aff union_pw_multi_aff::range_product(union_pw_multi_aff upma2) const\n{\n  auto res = isl_union_pw_multi_aff_range_product(copy(), upma2.release());\n  return manage(res);\n}\n\nunion_pw_multi_aff union_pw_multi_aff::reset_user() const\n{\n  auto res = isl_union_pw_multi_aff_reset_user(copy());\n  return manage(res);\n}\n\nunion_pw_multi_aff union_pw_multi_aff::scale_down_val(val val) const\n{\n  auto res = isl_union_pw_multi_aff_scale_down_val(copy(), val.release());\n  return manage(res);\n}\n\nunion_pw_multi_aff union_pw_multi_aff::scale_multi_val(multi_val mv) const\n{\n  auto res = isl_union_pw_multi_aff_scale_multi_val(copy(), mv.release());\n  return manage(res);\n}\n\nunion_pw_multi_aff union_pw_multi_aff::scale_val(val val) const\n{\n  auto res = isl_union_pw_multi_aff_scale_val(copy(), val.release());\n  return manage(res);\n}\n\nunion_pw_multi_aff union_pw_multi_aff::sub(union_pw_multi_aff upma2) const\n{\n  auto res = isl_union_pw_multi_aff_sub(copy(), upma2.release());\n  return manage(res);\n}\n\nunion_pw_multi_aff union_pw_multi_aff::subtract_domain(space space) const\n{\n  auto res = isl_union_pw_multi_aff_subtract_domain_space(copy(), space.release());\n  return manage(res);\n}\n\nunion_pw_multi_aff union_pw_multi_aff::subtract_domain(union_set uset) const\n{\n  auto res = isl_union_pw_multi_aff_subtract_domain_union_set(copy(), uset.release());\n  return manage(res);\n}\n\nunion_pw_multi_aff union_pw_multi_aff::union_add(union_pw_multi_aff upma2) const\n{\n  auto res = isl_union_pw_multi_aff_union_add(copy(), upma2.release());\n  return manage(res);\n}\n\n// implementations for isl::union_pw_multi_aff_list\nunion_pw_multi_aff_list manage(__isl_take isl_union_pw_multi_aff_list *ptr) {\n  return union_pw_multi_aff_list(ptr);\n}\nunion_pw_multi_aff_list manage_copy(__isl_keep isl_union_pw_multi_aff_list *ptr) {\n  ptr = isl_union_pw_multi_aff_list_copy(ptr);\n  return union_pw_multi_aff_list(ptr);\n}\n\nunion_pw_multi_aff_list::union_pw_multi_aff_list()\n    : ptr(nullptr) {}\n\nunion_pw_multi_aff_list::union_pw_multi_aff_list(const union_pw_multi_aff_list &obj)\n    : ptr(nullptr)\n{\n  ptr = obj.copy();\n}\nunion_pw_multi_aff_list::union_pw_multi_aff_list(std::nullptr_t)\n    : ptr(nullptr) {}\n\n\nunion_pw_multi_aff_list::union_pw_multi_aff_list(__isl_take isl_union_pw_multi_aff_list *ptr)\n    : ptr(ptr) {}\n\n\nunion_pw_multi_aff_list &union_pw_multi_aff_list::operator=(union_pw_multi_aff_list obj) {\n  std::swap(this->ptr, obj.ptr);\n  return *this;\n}\n\nunion_pw_multi_aff_list::~union_pw_multi_aff_list() {\n  if (ptr)\n    isl_union_pw_multi_aff_list_free(ptr);\n}\n\n__isl_give isl_union_pw_multi_aff_list *union_pw_multi_aff_list::copy() const & {\n  return isl_union_pw_multi_aff_list_copy(ptr);\n}\n\n__isl_keep isl_union_pw_multi_aff_list *union_pw_multi_aff_list::get() const {\n  return ptr;\n}\n\n__isl_give isl_union_pw_multi_aff_list *union_pw_multi_aff_list::release() {\n  isl_union_pw_multi_aff_list *tmp = ptr;\n  ptr = nullptr;\n  return tmp;\n}\n\nbool union_pw_multi_aff_list::is_null() const {\n  return ptr == nullptr;\n}\nunion_pw_multi_aff_list::operator bool() const {\n  return !is_null();\n}\n\n\nctx union_pw_multi_aff_list::get_ctx() const {\n  return ctx(isl_union_pw_multi_aff_list_get_ctx(ptr));\n}\nstd::string union_pw_multi_aff_list::to_str() const {\n  char *Tmp = isl_union_pw_multi_aff_list_to_str(get());\n  if (!Tmp)\n    return \"\";\n  std::string S(Tmp);\n  free(Tmp);\n  return S;\n}\n\n\nvoid union_pw_multi_aff_list::dump() const {\n  isl_union_pw_multi_aff_list_dump(get());\n}\n\n\nunion_pw_multi_aff_list union_pw_multi_aff_list::add(union_pw_multi_aff el) const\n{\n  auto res = isl_union_pw_multi_aff_list_add(copy(), el.release());\n  return manage(res);\n}\n\nunion_pw_multi_aff_list union_pw_multi_aff_list::alloc(ctx ctx, int n)\n{\n  auto res = isl_union_pw_multi_aff_list_alloc(ctx.release(), n);\n  return manage(res);\n}\n\nunion_pw_multi_aff_list union_pw_multi_aff_list::clear() const\n{\n  auto res = isl_union_pw_multi_aff_list_clear(copy());\n  return manage(res);\n}\n\nunion_pw_multi_aff_list union_pw_multi_aff_list::concat(union_pw_multi_aff_list list2) const\n{\n  auto res = isl_union_pw_multi_aff_list_concat(copy(), list2.release());\n  return manage(res);\n}\n\nunion_pw_multi_aff_list union_pw_multi_aff_list::drop(unsigned int first, unsigned int n) const\n{\n  auto res = isl_union_pw_multi_aff_list_drop(copy(), first, n);\n  return manage(res);\n}\n\nstat union_pw_multi_aff_list::foreach(const std::function<stat(union_pw_multi_aff)> &fn) const\n{\n  struct fn_data {\n    const std::function<stat(union_pw_multi_aff)> *func;\n  } fn_data = { &fn };\n  auto fn_lambda = [](isl_union_pw_multi_aff *arg_0, void *arg_1) -> isl_stat {\n    auto *data = static_cast<struct fn_data *>(arg_1);\n    stat ret = (*data->func)(manage(arg_0));\n    return ret.release();\n  };\n  auto res = isl_union_pw_multi_aff_list_foreach(get(), fn_lambda, &fn_data);\n  return manage(res);\n}\n\nunion_pw_multi_aff_list union_pw_multi_aff_list::from_union_pw_multi_aff(union_pw_multi_aff el)\n{\n  auto res = isl_union_pw_multi_aff_list_from_union_pw_multi_aff(el.release());\n  return manage(res);\n}\n\nunion_pw_multi_aff union_pw_multi_aff_list::get_at(int index) const\n{\n  auto res = isl_union_pw_multi_aff_list_get_at(get(), index);\n  return manage(res);\n}\n\nunion_pw_multi_aff union_pw_multi_aff_list::get_union_pw_multi_aff(int index) const\n{\n  auto res = isl_union_pw_multi_aff_list_get_union_pw_multi_aff(get(), index);\n  return manage(res);\n}\n\nunion_pw_multi_aff_list union_pw_multi_aff_list::insert(unsigned int pos, union_pw_multi_aff el) const\n{\n  auto res = isl_union_pw_multi_aff_list_insert(copy(), pos, el.release());\n  return manage(res);\n}\n\nisl_size union_pw_multi_aff_list::n_union_pw_multi_aff() const\n{\n  auto res = isl_union_pw_multi_aff_list_n_union_pw_multi_aff(get());\n  return res;\n}\n\nunion_pw_multi_aff_list union_pw_multi_aff_list::reverse() const\n{\n  auto res = isl_union_pw_multi_aff_list_reverse(copy());\n  return manage(res);\n}\n\nunion_pw_multi_aff_list union_pw_multi_aff_list::set_union_pw_multi_aff(int index, union_pw_multi_aff el) const\n{\n  auto res = isl_union_pw_multi_aff_list_set_union_pw_multi_aff(copy(), index, el.release());\n  return manage(res);\n}\n\nisl_size union_pw_multi_aff_list::size() const\n{\n  auto res = isl_union_pw_multi_aff_list_size(get());\n  return res;\n}\n\nunion_pw_multi_aff_list union_pw_multi_aff_list::swap(unsigned int pos1, unsigned int pos2) const\n{\n  auto res = isl_union_pw_multi_aff_list_swap(copy(), pos1, pos2);\n  return manage(res);\n}\n\n// implementations for isl::union_pw_qpolynomial\nunion_pw_qpolynomial manage(__isl_take isl_union_pw_qpolynomial *ptr) {\n  return union_pw_qpolynomial(ptr);\n}\nunion_pw_qpolynomial manage_copy(__isl_keep isl_union_pw_qpolynomial *ptr) {\n  ptr = isl_union_pw_qpolynomial_copy(ptr);\n  return union_pw_qpolynomial(ptr);\n}\n\nunion_pw_qpolynomial::union_pw_qpolynomial()\n    : ptr(nullptr) {}\n\nunion_pw_qpolynomial::union_pw_qpolynomial(const union_pw_qpolynomial &obj)\n    : ptr(nullptr)\n{\n  ptr = obj.copy();\n}\nunion_pw_qpolynomial::union_pw_qpolynomial(std::nullptr_t)\n    : ptr(nullptr) {}\n\n\nunion_pw_qpolynomial::union_pw_qpolynomial(__isl_take isl_union_pw_qpolynomial *ptr)\n    : ptr(ptr) {}\n\nunion_pw_qpolynomial::union_pw_qpolynomial(ctx ctx, const std::string &str)\n{\n  auto res = isl_union_pw_qpolynomial_read_from_str(ctx.release(), str.c_str());\n  ptr = res;\n}\n\nunion_pw_qpolynomial &union_pw_qpolynomial::operator=(union_pw_qpolynomial obj) {\n  std::swap(this->ptr, obj.ptr);\n  return *this;\n}\n\nunion_pw_qpolynomial::~union_pw_qpolynomial() {\n  if (ptr)\n    isl_union_pw_qpolynomial_free(ptr);\n}\n\n__isl_give isl_union_pw_qpolynomial *union_pw_qpolynomial::copy() const & {\n  return isl_union_pw_qpolynomial_copy(ptr);\n}\n\n__isl_keep isl_union_pw_qpolynomial *union_pw_qpolynomial::get() const {\n  return ptr;\n}\n\n__isl_give isl_union_pw_qpolynomial *union_pw_qpolynomial::release() {\n  isl_union_pw_qpolynomial *tmp = ptr;\n  ptr = nullptr;\n  return tmp;\n}\n\nbool union_pw_qpolynomial::is_null() const {\n  return ptr == nullptr;\n}\nunion_pw_qpolynomial::operator bool() const {\n  return !is_null();\n}\n\n\nctx union_pw_qpolynomial::get_ctx() const {\n  return ctx(isl_union_pw_qpolynomial_get_ctx(ptr));\n}\nstd::string union_pw_qpolynomial::to_str() const {\n  char *Tmp = isl_union_pw_qpolynomial_to_str(get());\n  if (!Tmp)\n    return \"\";\n  std::string S(Tmp);\n  free(Tmp);\n  return S;\n}\n\n\n\nunion_pw_qpolynomial union_pw_qpolynomial::add(union_pw_qpolynomial upwqp2) const\n{\n  auto res = isl_union_pw_qpolynomial_add(copy(), upwqp2.release());\n  return manage(res);\n}\n\nunion_pw_qpolynomial union_pw_qpolynomial::add_pw_qpolynomial(pw_qpolynomial pwqp) const\n{\n  auto res = isl_union_pw_qpolynomial_add_pw_qpolynomial(copy(), pwqp.release());\n  return manage(res);\n}\n\nunion_pw_qpolynomial union_pw_qpolynomial::align_params(space model) const\n{\n  auto res = isl_union_pw_qpolynomial_align_params(copy(), model.release());\n  return manage(res);\n}\n\nunion_pw_qpolynomial union_pw_qpolynomial::coalesce() const\n{\n  auto res = isl_union_pw_qpolynomial_coalesce(copy());\n  return manage(res);\n}\n\nisl_size union_pw_qpolynomial::dim(isl::dim type) const\n{\n  auto res = isl_union_pw_qpolynomial_dim(get(), static_cast<enum isl_dim_type>(type));\n  return res;\n}\n\nunion_set union_pw_qpolynomial::domain() const\n{\n  auto res = isl_union_pw_qpolynomial_domain(copy());\n  return manage(res);\n}\n\nunion_pw_qpolynomial union_pw_qpolynomial::drop_dims(isl::dim type, unsigned int first, unsigned int n) const\n{\n  auto res = isl_union_pw_qpolynomial_drop_dims(copy(), static_cast<enum isl_dim_type>(type), first, n);\n  return manage(res);\n}\n\nval union_pw_qpolynomial::eval(point pnt) const\n{\n  auto res = isl_union_pw_qpolynomial_eval(copy(), pnt.release());\n  return manage(res);\n}\n\npw_qpolynomial union_pw_qpolynomial::extract_pw_qpolynomial(space space) const\n{\n  auto res = isl_union_pw_qpolynomial_extract_pw_qpolynomial(get(), space.release());\n  return manage(res);\n}\n\nint union_pw_qpolynomial::find_dim_by_name(isl::dim type, const std::string &name) const\n{\n  auto res = isl_union_pw_qpolynomial_find_dim_by_name(get(), static_cast<enum isl_dim_type>(type), name.c_str());\n  return res;\n}\n\nstat union_pw_qpolynomial::foreach_pw_qpolynomial(const std::function<stat(pw_qpolynomial)> &fn) const\n{\n  struct fn_data {\n    const std::function<stat(pw_qpolynomial)> *func;\n  } fn_data = { &fn };\n  auto fn_lambda = [](isl_pw_qpolynomial *arg_0, void *arg_1) -> isl_stat {\n    auto *data = static_cast<struct fn_data *>(arg_1);\n    stat ret = (*data->func)(manage(arg_0));\n    return ret.release();\n  };\n  auto res = isl_union_pw_qpolynomial_foreach_pw_qpolynomial(get(), fn_lambda, &fn_data);\n  return manage(res);\n}\n\nunion_pw_qpolynomial union_pw_qpolynomial::from_pw_qpolynomial(pw_qpolynomial pwqp)\n{\n  auto res = isl_union_pw_qpolynomial_from_pw_qpolynomial(pwqp.release());\n  return manage(res);\n}\n\npw_qpolynomial_list union_pw_qpolynomial::get_pw_qpolynomial_list() const\n{\n  auto res = isl_union_pw_qpolynomial_get_pw_qpolynomial_list(get());\n  return manage(res);\n}\n\nspace union_pw_qpolynomial::get_space() const\n{\n  auto res = isl_union_pw_qpolynomial_get_space(get());\n  return manage(res);\n}\n\nunion_pw_qpolynomial union_pw_qpolynomial::gist(union_set context) const\n{\n  auto res = isl_union_pw_qpolynomial_gist(copy(), context.release());\n  return manage(res);\n}\n\nunion_pw_qpolynomial union_pw_qpolynomial::gist_params(set context) const\n{\n  auto res = isl_union_pw_qpolynomial_gist_params(copy(), context.release());\n  return manage(res);\n}\n\nunion_pw_qpolynomial union_pw_qpolynomial::intersect_domain(union_set uset) const\n{\n  auto res = isl_union_pw_qpolynomial_intersect_domain(copy(), uset.release());\n  return manage(res);\n}\n\nunion_pw_qpolynomial union_pw_qpolynomial::intersect_domain_space(space space) const\n{\n  auto res = isl_union_pw_qpolynomial_intersect_domain_space(copy(), space.release());\n  return manage(res);\n}\n\nunion_pw_qpolynomial union_pw_qpolynomial::intersect_domain_union_set(union_set uset) const\n{\n  auto res = isl_union_pw_qpolynomial_intersect_domain_union_set(copy(), uset.release());\n  return manage(res);\n}\n\nunion_pw_qpolynomial union_pw_qpolynomial::intersect_domain_wrapped_domain(union_set uset) const\n{\n  auto res = isl_union_pw_qpolynomial_intersect_domain_wrapped_domain(copy(), uset.release());\n  return manage(res);\n}\n\nunion_pw_qpolynomial union_pw_qpolynomial::intersect_domain_wrapped_range(union_set uset) const\n{\n  auto res = isl_union_pw_qpolynomial_intersect_domain_wrapped_range(copy(), uset.release());\n  return manage(res);\n}\n\nunion_pw_qpolynomial union_pw_qpolynomial::intersect_params(set set) const\n{\n  auto res = isl_union_pw_qpolynomial_intersect_params(copy(), set.release());\n  return manage(res);\n}\n\nboolean union_pw_qpolynomial::involves_nan() const\n{\n  auto res = isl_union_pw_qpolynomial_involves_nan(get());\n  return manage(res);\n}\n\nunion_pw_qpolynomial union_pw_qpolynomial::mul(union_pw_qpolynomial upwqp2) const\n{\n  auto res = isl_union_pw_qpolynomial_mul(copy(), upwqp2.release());\n  return manage(res);\n}\n\nisl_size union_pw_qpolynomial::n_pw_qpolynomial() const\n{\n  auto res = isl_union_pw_qpolynomial_n_pw_qpolynomial(get());\n  return res;\n}\n\nunion_pw_qpolynomial union_pw_qpolynomial::neg() const\n{\n  auto res = isl_union_pw_qpolynomial_neg(copy());\n  return manage(res);\n}\n\nboolean union_pw_qpolynomial::plain_is_equal(const union_pw_qpolynomial &upwqp2) const\n{\n  auto res = isl_union_pw_qpolynomial_plain_is_equal(get(), upwqp2.get());\n  return manage(res);\n}\n\nunion_pw_qpolynomial union_pw_qpolynomial::reset_user() const\n{\n  auto res = isl_union_pw_qpolynomial_reset_user(copy());\n  return manage(res);\n}\n\nunion_pw_qpolynomial union_pw_qpolynomial::scale_down_val(val v) const\n{\n  auto res = isl_union_pw_qpolynomial_scale_down_val(copy(), v.release());\n  return manage(res);\n}\n\nunion_pw_qpolynomial union_pw_qpolynomial::scale_val(val v) const\n{\n  auto res = isl_union_pw_qpolynomial_scale_val(copy(), v.release());\n  return manage(res);\n}\n\nunion_pw_qpolynomial union_pw_qpolynomial::sub(union_pw_qpolynomial upwqp2) const\n{\n  auto res = isl_union_pw_qpolynomial_sub(copy(), upwqp2.release());\n  return manage(res);\n}\n\nunion_pw_qpolynomial union_pw_qpolynomial::subtract_domain(union_set uset) const\n{\n  auto res = isl_union_pw_qpolynomial_subtract_domain(copy(), uset.release());\n  return manage(res);\n}\n\nunion_pw_qpolynomial union_pw_qpolynomial::subtract_domain_space(space space) const\n{\n  auto res = isl_union_pw_qpolynomial_subtract_domain_space(copy(), space.release());\n  return manage(res);\n}\n\nunion_pw_qpolynomial union_pw_qpolynomial::subtract_domain_union_set(union_set uset) const\n{\n  auto res = isl_union_pw_qpolynomial_subtract_domain_union_set(copy(), uset.release());\n  return manage(res);\n}\n\nunion_pw_qpolynomial union_pw_qpolynomial::to_polynomial(int sign) const\n{\n  auto res = isl_union_pw_qpolynomial_to_polynomial(copy(), sign);\n  return manage(res);\n}\n\nunion_pw_qpolynomial union_pw_qpolynomial::zero(space space)\n{\n  auto res = isl_union_pw_qpolynomial_zero(space.release());\n  return manage(res);\n}\n\nunion_pw_qpolynomial union_pw_qpolynomial::zero_ctx(ctx ctx)\n{\n  auto res = isl_union_pw_qpolynomial_zero_ctx(ctx.release());\n  return manage(res);\n}\n\nunion_pw_qpolynomial union_pw_qpolynomial::zero_space(space space)\n{\n  auto res = isl_union_pw_qpolynomial_zero_space(space.release());\n  return manage(res);\n}\n\n// implementations for isl::union_set\nunion_set manage(__isl_take isl_union_set *ptr) {\n  return union_set(ptr);\n}\nunion_set manage_copy(__isl_keep isl_union_set *ptr) {\n  ptr = isl_union_set_copy(ptr);\n  return union_set(ptr);\n}\n\nunion_set::union_set()\n    : ptr(nullptr) {}\n\nunion_set::union_set(const union_set &obj)\n    : ptr(nullptr)\n{\n  ptr = obj.copy();\n}\nunion_set::union_set(std::nullptr_t)\n    : ptr(nullptr) {}\n\n\nunion_set::union_set(__isl_take isl_union_set *ptr)\n    : ptr(ptr) {}\n\nunion_set::union_set(basic_set bset)\n{\n  auto res = isl_union_set_from_basic_set(bset.release());\n  ptr = res;\n}\nunion_set::union_set(point pnt)\n{\n  auto res = isl_union_set_from_point(pnt.release());\n  ptr = res;\n}\nunion_set::union_set(set set)\n{\n  auto res = isl_union_set_from_set(set.release());\n  ptr = res;\n}\nunion_set::union_set(ctx ctx, const std::string &str)\n{\n  auto res = isl_union_set_read_from_str(ctx.release(), str.c_str());\n  ptr = res;\n}\n\nunion_set &union_set::operator=(union_set obj) {\n  std::swap(this->ptr, obj.ptr);\n  return *this;\n}\n\nunion_set::~union_set() {\n  if (ptr)\n    isl_union_set_free(ptr);\n}\n\n__isl_give isl_union_set *union_set::copy() const & {\n  return isl_union_set_copy(ptr);\n}\n\n__isl_keep isl_union_set *union_set::get() const {\n  return ptr;\n}\n\n__isl_give isl_union_set *union_set::release() {\n  isl_union_set *tmp = ptr;\n  ptr = nullptr;\n  return tmp;\n}\n\nbool union_set::is_null() const {\n  return ptr == nullptr;\n}\nunion_set::operator bool() const {\n  return !is_null();\n}\n\n\nctx union_set::get_ctx() const {\n  return ctx(isl_union_set_get_ctx(ptr));\n}\nstd::string union_set::to_str() const {\n  char *Tmp = isl_union_set_to_str(get());\n  if (!Tmp)\n    return \"\";\n  std::string S(Tmp);\n  free(Tmp);\n  return S;\n}\n\n\nvoid union_set::dump() const {\n  isl_union_set_dump(get());\n}\n\n\nunion_set union_set::add_set(set set) const\n{\n  auto res = isl_union_set_add_set(copy(), set.release());\n  return manage(res);\n}\n\nunion_set union_set::affine_hull() const\n{\n  auto res = isl_union_set_affine_hull(copy());\n  return manage(res);\n}\n\nunion_set union_set::align_params(space model) const\n{\n  auto res = isl_union_set_align_params(copy(), model.release());\n  return manage(res);\n}\n\nunion_set union_set::apply(union_map umap) const\n{\n  auto res = isl_union_set_apply(copy(), umap.release());\n  return manage(res);\n}\n\nunion_set union_set::coalesce() const\n{\n  auto res = isl_union_set_coalesce(copy());\n  return manage(res);\n}\n\nunion_set union_set::coefficients() const\n{\n  auto res = isl_union_set_coefficients(copy());\n  return manage(res);\n}\n\nschedule union_set::compute_schedule(union_map validity, union_map proximity) const\n{\n  auto res = isl_union_set_compute_schedule(copy(), validity.release(), proximity.release());\n  return manage(res);\n}\n\nboolean union_set::contains(const space &space) const\n{\n  auto res = isl_union_set_contains(get(), space.get());\n  return manage(res);\n}\n\nunion_set union_set::detect_equalities() const\n{\n  auto res = isl_union_set_detect_equalities(copy());\n  return manage(res);\n}\n\nisl_size union_set::dim(isl::dim type) const\n{\n  auto res = isl_union_set_dim(get(), static_cast<enum isl_dim_type>(type));\n  return res;\n}\n\nunion_set union_set::empty(space space)\n{\n  auto res = isl_union_set_empty(space.release());\n  return manage(res);\n}\n\nunion_set union_set::empty(ctx ctx)\n{\n  auto res = isl_union_set_empty_ctx(ctx.release());\n  return manage(res);\n}\n\nunion_set union_set::empty_space(space space)\n{\n  auto res = isl_union_set_empty_space(space.release());\n  return manage(res);\n}\n\nset union_set::extract_set(space space) const\n{\n  auto res = isl_union_set_extract_set(get(), space.release());\n  return manage(res);\n}\n\nstat union_set::foreach_point(const std::function<stat(point)> &fn) const\n{\n  struct fn_data {\n    const std::function<stat(point)> *func;\n  } fn_data = { &fn };\n  auto fn_lambda = [](isl_point *arg_0, void *arg_1) -> isl_stat {\n    auto *data = static_cast<struct fn_data *>(arg_1);\n    stat ret = (*data->func)(manage(arg_0));\n    return ret.release();\n  };\n  auto res = isl_union_set_foreach_point(get(), fn_lambda, &fn_data);\n  return manage(res);\n}\n\nstat union_set::foreach_set(const std::function<stat(set)> &fn) const\n{\n  struct fn_data {\n    const std::function<stat(set)> *func;\n  } fn_data = { &fn };\n  auto fn_lambda = [](isl_set *arg_0, void *arg_1) -> isl_stat {\n    auto *data = static_cast<struct fn_data *>(arg_1);\n    stat ret = (*data->func)(manage(arg_0));\n    return ret.release();\n  };\n  auto res = isl_union_set_foreach_set(get(), fn_lambda, &fn_data);\n  return manage(res);\n}\n\nbasic_set_list union_set::get_basic_set_list() const\n{\n  auto res = isl_union_set_get_basic_set_list(get());\n  return manage(res);\n}\n\nuint32_t union_set::get_hash() const\n{\n  auto res = isl_union_set_get_hash(get());\n  return res;\n}\n\nset_list union_set::get_set_list() const\n{\n  auto res = isl_union_set_get_set_list(get());\n  return manage(res);\n}\n\nspace union_set::get_space() const\n{\n  auto res = isl_union_set_get_space(get());\n  return manage(res);\n}\n\nunion_set union_set::gist(union_set context) const\n{\n  auto res = isl_union_set_gist(copy(), context.release());\n  return manage(res);\n}\n\nunion_set union_set::gist_params(set set) const\n{\n  auto res = isl_union_set_gist_params(copy(), set.release());\n  return manage(res);\n}\n\nunion_map union_set::identity() const\n{\n  auto res = isl_union_set_identity(copy());\n  return manage(res);\n}\n\nunion_pw_multi_aff union_set::identity_union_pw_multi_aff() const\n{\n  auto res = isl_union_set_identity_union_pw_multi_aff(copy());\n  return manage(res);\n}\n\nunion_set union_set::intersect(union_set uset2) const\n{\n  auto res = isl_union_set_intersect(copy(), uset2.release());\n  return manage(res);\n}\n\nunion_set union_set::intersect_params(set set) const\n{\n  auto res = isl_union_set_intersect_params(copy(), set.release());\n  return manage(res);\n}\n\nboolean union_set::is_disjoint(const union_set &uset2) const\n{\n  auto res = isl_union_set_is_disjoint(get(), uset2.get());\n  return manage(res);\n}\n\nboolean union_set::is_empty() const\n{\n  auto res = isl_union_set_is_empty(get());\n  return manage(res);\n}\n\nboolean union_set::is_equal(const union_set &uset2) const\n{\n  auto res = isl_union_set_is_equal(get(), uset2.get());\n  return manage(res);\n}\n\nboolean union_set::is_params() const\n{\n  auto res = isl_union_set_is_params(get());\n  return manage(res);\n}\n\nboolean union_set::is_strict_subset(const union_set &uset2) const\n{\n  auto res = isl_union_set_is_strict_subset(get(), uset2.get());\n  return manage(res);\n}\n\nboolean union_set::is_subset(const union_set &uset2) const\n{\n  auto res = isl_union_set_is_subset(get(), uset2.get());\n  return manage(res);\n}\n\nboolean union_set::isa_set() const\n{\n  auto res = isl_union_set_isa_set(get());\n  return manage(res);\n}\n\nunion_map union_set::lex_ge_union_set(union_set uset2) const\n{\n  auto res = isl_union_set_lex_ge_union_set(copy(), uset2.release());\n  return manage(res);\n}\n\nunion_map union_set::lex_gt_union_set(union_set uset2) const\n{\n  auto res = isl_union_set_lex_gt_union_set(copy(), uset2.release());\n  return manage(res);\n}\n\nunion_map union_set::lex_le_union_set(union_set uset2) const\n{\n  auto res = isl_union_set_lex_le_union_set(copy(), uset2.release());\n  return manage(res);\n}\n\nunion_map union_set::lex_lt_union_set(union_set uset2) const\n{\n  auto res = isl_union_set_lex_lt_union_set(copy(), uset2.release());\n  return manage(res);\n}\n\nunion_set union_set::lexmax() const\n{\n  auto res = isl_union_set_lexmax(copy());\n  return manage(res);\n}\n\nunion_set union_set::lexmin() const\n{\n  auto res = isl_union_set_lexmin(copy());\n  return manage(res);\n}\n\nmulti_val union_set::min_multi_union_pw_aff(const multi_union_pw_aff &obj) const\n{\n  auto res = isl_union_set_min_multi_union_pw_aff(get(), obj.get());\n  return manage(res);\n}\n\nisl_size union_set::n_set() const\n{\n  auto res = isl_union_set_n_set(get());\n  return res;\n}\n\nset union_set::params() const\n{\n  auto res = isl_union_set_params(copy());\n  return manage(res);\n}\n\nunion_set union_set::polyhedral_hull() const\n{\n  auto res = isl_union_set_polyhedral_hull(copy());\n  return manage(res);\n}\n\nunion_set union_set::preimage(multi_aff ma) const\n{\n  auto res = isl_union_set_preimage_multi_aff(copy(), ma.release());\n  return manage(res);\n}\n\nunion_set union_set::preimage(pw_multi_aff pma) const\n{\n  auto res = isl_union_set_preimage_pw_multi_aff(copy(), pma.release());\n  return manage(res);\n}\n\nunion_set union_set::preimage(union_pw_multi_aff upma) const\n{\n  auto res = isl_union_set_preimage_union_pw_multi_aff(copy(), upma.release());\n  return manage(res);\n}\n\nunion_set union_set::product(union_set uset2) const\n{\n  auto res = isl_union_set_product(copy(), uset2.release());\n  return manage(res);\n}\n\nunion_set union_set::project_out(isl::dim type, unsigned int first, unsigned int n) const\n{\n  auto res = isl_union_set_project_out(copy(), static_cast<enum isl_dim_type>(type), first, n);\n  return manage(res);\n}\n\nunion_set union_set::project_out_all_params() const\n{\n  auto res = isl_union_set_project_out_all_params(copy());\n  return manage(res);\n}\n\nunion_set union_set::remove_divs() const\n{\n  auto res = isl_union_set_remove_divs(copy());\n  return manage(res);\n}\n\nunion_set union_set::remove_redundancies() const\n{\n  auto res = isl_union_set_remove_redundancies(copy());\n  return manage(res);\n}\n\nunion_set union_set::reset_user() const\n{\n  auto res = isl_union_set_reset_user(copy());\n  return manage(res);\n}\n\nbasic_set union_set::sample() const\n{\n  auto res = isl_union_set_sample(copy());\n  return manage(res);\n}\n\npoint union_set::sample_point() const\n{\n  auto res = isl_union_set_sample_point(copy());\n  return manage(res);\n}\n\nunion_set union_set::simple_hull() const\n{\n  auto res = isl_union_set_simple_hull(copy());\n  return manage(res);\n}\n\nunion_set union_set::solutions() const\n{\n  auto res = isl_union_set_solutions(copy());\n  return manage(res);\n}\n\nunion_set union_set::subtract(union_set uset2) const\n{\n  auto res = isl_union_set_subtract(copy(), uset2.release());\n  return manage(res);\n}\n\nunion_set union_set::unite(union_set uset2) const\n{\n  auto res = isl_union_set_union(copy(), uset2.release());\n  return manage(res);\n}\n\nunion_set union_set::universe() const\n{\n  auto res = isl_union_set_universe(copy());\n  return manage(res);\n}\n\nunion_map union_set::unwrap() const\n{\n  auto res = isl_union_set_unwrap(copy());\n  return manage(res);\n}\n\nunion_map union_set::wrapped_domain_map() const\n{\n  auto res = isl_union_set_wrapped_domain_map(copy());\n  return manage(res);\n}\n\n// implementations for isl::union_set_list\nunion_set_list manage(__isl_take isl_union_set_list *ptr) {\n  return union_set_list(ptr);\n}\nunion_set_list manage_copy(__isl_keep isl_union_set_list *ptr) {\n  ptr = isl_union_set_list_copy(ptr);\n  return union_set_list(ptr);\n}\n\nunion_set_list::union_set_list()\n    : ptr(nullptr) {}\n\nunion_set_list::union_set_list(const union_set_list &obj)\n    : ptr(nullptr)\n{\n  ptr = obj.copy();\n}\nunion_set_list::union_set_list(std::nullptr_t)\n    : ptr(nullptr) {}\n\n\nunion_set_list::union_set_list(__isl_take isl_union_set_list *ptr)\n    : ptr(ptr) {}\n\n\nunion_set_list &union_set_list::operator=(union_set_list obj) {\n  std::swap(this->ptr, obj.ptr);\n  return *this;\n}\n\nunion_set_list::~union_set_list() {\n  if (ptr)\n    isl_union_set_list_free(ptr);\n}\n\n__isl_give isl_union_set_list *union_set_list::copy() const & {\n  return isl_union_set_list_copy(ptr);\n}\n\n__isl_keep isl_union_set_list *union_set_list::get() const {\n  return ptr;\n}\n\n__isl_give isl_union_set_list *union_set_list::release() {\n  isl_union_set_list *tmp = ptr;\n  ptr = nullptr;\n  return tmp;\n}\n\nbool union_set_list::is_null() const {\n  return ptr == nullptr;\n}\nunion_set_list::operator bool() const {\n  return !is_null();\n}\n\n\nctx union_set_list::get_ctx() const {\n  return ctx(isl_union_set_list_get_ctx(ptr));\n}\nstd::string union_set_list::to_str() const {\n  char *Tmp = isl_union_set_list_to_str(get());\n  if (!Tmp)\n    return \"\";\n  std::string S(Tmp);\n  free(Tmp);\n  return S;\n}\n\n\nvoid union_set_list::dump() const {\n  isl_union_set_list_dump(get());\n}\n\n\nunion_set_list union_set_list::add(union_set el) const\n{\n  auto res = isl_union_set_list_add(copy(), el.release());\n  return manage(res);\n}\n\nunion_set_list union_set_list::alloc(ctx ctx, int n)\n{\n  auto res = isl_union_set_list_alloc(ctx.release(), n);\n  return manage(res);\n}\n\nunion_set_list union_set_list::clear() const\n{\n  auto res = isl_union_set_list_clear(copy());\n  return manage(res);\n}\n\nunion_set_list union_set_list::concat(union_set_list list2) const\n{\n  auto res = isl_union_set_list_concat(copy(), list2.release());\n  return manage(res);\n}\n\nunion_set_list union_set_list::drop(unsigned int first, unsigned int n) const\n{\n  auto res = isl_union_set_list_drop(copy(), first, n);\n  return manage(res);\n}\n\nstat union_set_list::foreach(const std::function<stat(union_set)> &fn) const\n{\n  struct fn_data {\n    const std::function<stat(union_set)> *func;\n  } fn_data = { &fn };\n  auto fn_lambda = [](isl_union_set *arg_0, void *arg_1) -> isl_stat {\n    auto *data = static_cast<struct fn_data *>(arg_1);\n    stat ret = (*data->func)(manage(arg_0));\n    return ret.release();\n  };\n  auto res = isl_union_set_list_foreach(get(), fn_lambda, &fn_data);\n  return manage(res);\n}\n\nunion_set_list union_set_list::from_union_set(union_set el)\n{\n  auto res = isl_union_set_list_from_union_set(el.release());\n  return manage(res);\n}\n\nunion_set union_set_list::get_at(int index) const\n{\n  auto res = isl_union_set_list_get_at(get(), index);\n  return manage(res);\n}\n\nunion_set union_set_list::get_union_set(int index) const\n{\n  auto res = isl_union_set_list_get_union_set(get(), index);\n  return manage(res);\n}\n\nunion_set_list union_set_list::insert(unsigned int pos, union_set el) const\n{\n  auto res = isl_union_set_list_insert(copy(), pos, el.release());\n  return manage(res);\n}\n\nisl_size union_set_list::n_union_set() const\n{\n  auto res = isl_union_set_list_n_union_set(get());\n  return res;\n}\n\nunion_set_list union_set_list::reverse() const\n{\n  auto res = isl_union_set_list_reverse(copy());\n  return manage(res);\n}\n\nunion_set_list union_set_list::set_union_set(int index, union_set el) const\n{\n  auto res = isl_union_set_list_set_union_set(copy(), index, el.release());\n  return manage(res);\n}\n\nisl_size union_set_list::size() const\n{\n  auto res = isl_union_set_list_size(get());\n  return res;\n}\n\nunion_set_list union_set_list::swap(unsigned int pos1, unsigned int pos2) const\n{\n  auto res = isl_union_set_list_swap(copy(), pos1, pos2);\n  return manage(res);\n}\n\nunion_set union_set_list::unite() const\n{\n  auto res = isl_union_set_list_union(copy());\n  return manage(res);\n}\n\n// implementations for isl::val\nval manage(__isl_take isl_val *ptr) {\n  return val(ptr);\n}\nval manage_copy(__isl_keep isl_val *ptr) {\n  ptr = isl_val_copy(ptr);\n  return val(ptr);\n}\n\nval::val()\n    : ptr(nullptr) {}\n\nval::val(const val &obj)\n    : ptr(nullptr)\n{\n  ptr = obj.copy();\n}\nval::val(std::nullptr_t)\n    : ptr(nullptr) {}\n\n\nval::val(__isl_take isl_val *ptr)\n    : ptr(ptr) {}\n\nval::val(ctx ctx, long i)\n{\n  auto res = isl_val_int_from_si(ctx.release(), i);\n  ptr = res;\n}\nval::val(ctx ctx, const std::string &str)\n{\n  auto res = isl_val_read_from_str(ctx.release(), str.c_str());\n  ptr = res;\n}\n\nval &val::operator=(val obj) {\n  std::swap(this->ptr, obj.ptr);\n  return *this;\n}\n\nval::~val() {\n  if (ptr)\n    isl_val_free(ptr);\n}\n\n__isl_give isl_val *val::copy() const & {\n  return isl_val_copy(ptr);\n}\n\n__isl_keep isl_val *val::get() const {\n  return ptr;\n}\n\n__isl_give isl_val *val::release() {\n  isl_val *tmp = ptr;\n  ptr = nullptr;\n  return tmp;\n}\n\nbool val::is_null() const {\n  return ptr == nullptr;\n}\nval::operator bool() const {\n  return !is_null();\n}\n\n\nctx val::get_ctx() const {\n  return ctx(isl_val_get_ctx(ptr));\n}\nstd::string val::to_str() const {\n  char *Tmp = isl_val_to_str(get());\n  if (!Tmp)\n    return \"\";\n  std::string S(Tmp);\n  free(Tmp);\n  return S;\n}\n\n\nvoid val::dump() const {\n  isl_val_dump(get());\n}\n\n\nval val::abs() const\n{\n  auto res = isl_val_abs(copy());\n  return manage(res);\n}\n\nboolean val::abs_eq(const val &v2) const\n{\n  auto res = isl_val_abs_eq(get(), v2.get());\n  return manage(res);\n}\n\nval val::add(val v2) const\n{\n  auto res = isl_val_add(copy(), v2.release());\n  return manage(res);\n}\n\nval val::add_ui(unsigned long v2) const\n{\n  auto res = isl_val_add_ui(copy(), v2);\n  return manage(res);\n}\n\nval val::ceil() const\n{\n  auto res = isl_val_ceil(copy());\n  return manage(res);\n}\n\nint val::cmp_si(long i) const\n{\n  auto res = isl_val_cmp_si(get(), i);\n  return res;\n}\n\nval val::div(val v2) const\n{\n  auto res = isl_val_div(copy(), v2.release());\n  return manage(res);\n}\n\nval val::div_ui(unsigned long v2) const\n{\n  auto res = isl_val_div_ui(copy(), v2);\n  return manage(res);\n}\n\nboolean val::eq(const val &v2) const\n{\n  auto res = isl_val_eq(get(), v2.get());\n  return manage(res);\n}\n\nboolean val::eq_si(long i) const\n{\n  auto res = isl_val_eq_si(get(), i);\n  return manage(res);\n}\n\nval val::floor() const\n{\n  auto res = isl_val_floor(copy());\n  return manage(res);\n}\n\nval val::gcd(val v2) const\n{\n  auto res = isl_val_gcd(copy(), v2.release());\n  return manage(res);\n}\n\nboolean val::ge(const val &v2) const\n{\n  auto res = isl_val_ge(get(), v2.get());\n  return manage(res);\n}\n\nuint32_t val::get_hash() const\n{\n  auto res = isl_val_get_hash(get());\n  return res;\n}\n\nlong val::get_num_si() const\n{\n  auto res = isl_val_get_num_si(get());\n  return res;\n}\n\nboolean val::gt(const val &v2) const\n{\n  auto res = isl_val_gt(get(), v2.get());\n  return manage(res);\n}\n\nboolean val::gt_si(long i) const\n{\n  auto res = isl_val_gt_si(get(), i);\n  return manage(res);\n}\n\nval val::infty(ctx ctx)\n{\n  auto res = isl_val_infty(ctx.release());\n  return manage(res);\n}\n\nval val::int_from_ui(ctx ctx, unsigned long u)\n{\n  auto res = isl_val_int_from_ui(ctx.release(), u);\n  return manage(res);\n}\n\nval val::inv() const\n{\n  auto res = isl_val_inv(copy());\n  return manage(res);\n}\n\nboolean val::is_divisible_by(const val &v2) const\n{\n  auto res = isl_val_is_divisible_by(get(), v2.get());\n  return manage(res);\n}\n\nboolean val::is_infty() const\n{\n  auto res = isl_val_is_infty(get());\n  return manage(res);\n}\n\nboolean val::is_int() const\n{\n  auto res = isl_val_is_int(get());\n  return manage(res);\n}\n\nboolean val::is_nan() const\n{\n  auto res = isl_val_is_nan(get());\n  return manage(res);\n}\n\nboolean val::is_neg() const\n{\n  auto res = isl_val_is_neg(get());\n  return manage(res);\n}\n\nboolean val::is_neginfty() const\n{\n  auto res = isl_val_is_neginfty(get());\n  return manage(res);\n}\n\nboolean val::is_negone() const\n{\n  auto res = isl_val_is_negone(get());\n  return manage(res);\n}\n\nboolean val::is_nonneg() const\n{\n  auto res = isl_val_is_nonneg(get());\n  return manage(res);\n}\n\nboolean val::is_nonpos() const\n{\n  auto res = isl_val_is_nonpos(get());\n  return manage(res);\n}\n\nboolean val::is_one() const\n{\n  auto res = isl_val_is_one(get());\n  return manage(res);\n}\n\nboolean val::is_pos() const\n{\n  auto res = isl_val_is_pos(get());\n  return manage(res);\n}\n\nboolean val::is_rat() const\n{\n  auto res = isl_val_is_rat(get());\n  return manage(res);\n}\n\nboolean val::is_zero() const\n{\n  auto res = isl_val_is_zero(get());\n  return manage(res);\n}\n\nboolean val::le(const val &v2) const\n{\n  auto res = isl_val_le(get(), v2.get());\n  return manage(res);\n}\n\nboolean val::lt(const val &v2) const\n{\n  auto res = isl_val_lt(get(), v2.get());\n  return manage(res);\n}\n\nval val::max(val v2) const\n{\n  auto res = isl_val_max(copy(), v2.release());\n  return manage(res);\n}\n\nval val::min(val v2) const\n{\n  auto res = isl_val_min(copy(), v2.release());\n  return manage(res);\n}\n\nval val::mod(val v2) const\n{\n  auto res = isl_val_mod(copy(), v2.release());\n  return manage(res);\n}\n\nval val::mul(val v2) const\n{\n  auto res = isl_val_mul(copy(), v2.release());\n  return manage(res);\n}\n\nval val::mul_ui(unsigned long v2) const\n{\n  auto res = isl_val_mul_ui(copy(), v2);\n  return manage(res);\n}\n\nisl_size val::n_abs_num_chunks(size_t size) const\n{\n  auto res = isl_val_n_abs_num_chunks(get(), size);\n  return res;\n}\n\nval val::nan(ctx ctx)\n{\n  auto res = isl_val_nan(ctx.release());\n  return manage(res);\n}\n\nboolean val::ne(const val &v2) const\n{\n  auto res = isl_val_ne(get(), v2.get());\n  return manage(res);\n}\n\nval val::neg() const\n{\n  auto res = isl_val_neg(copy());\n  return manage(res);\n}\n\nval val::neginfty(ctx ctx)\n{\n  auto res = isl_val_neginfty(ctx.release());\n  return manage(res);\n}\n\nval val::negone(ctx ctx)\n{\n  auto res = isl_val_negone(ctx.release());\n  return manage(res);\n}\n\nval val::one(ctx ctx)\n{\n  auto res = isl_val_one(ctx.release());\n  return manage(res);\n}\n\nval val::pow2() const\n{\n  auto res = isl_val_pow2(copy());\n  return manage(res);\n}\n\nval val::set_si(long i) const\n{\n  auto res = isl_val_set_si(copy(), i);\n  return manage(res);\n}\n\nint val::sgn() const\n{\n  auto res = isl_val_sgn(get());\n  return res;\n}\n\nval val::sub(val v2) const\n{\n  auto res = isl_val_sub(copy(), v2.release());\n  return manage(res);\n}\n\nval val::sub_ui(unsigned long v2) const\n{\n  auto res = isl_val_sub_ui(copy(), v2);\n  return manage(res);\n}\n\nval val::trunc() const\n{\n  auto res = isl_val_trunc(copy());\n  return manage(res);\n}\n\nval val::zero(ctx ctx)\n{\n  auto res = isl_val_zero(ctx.release());\n  return manage(res);\n}\n\n// implementations for isl::val_list\nval_list manage(__isl_take isl_val_list *ptr) {\n  return val_list(ptr);\n}\nval_list manage_copy(__isl_keep isl_val_list *ptr) {\n  ptr = isl_val_list_copy(ptr);\n  return val_list(ptr);\n}\n\nval_list::val_list()\n    : ptr(nullptr) {}\n\nval_list::val_list(const val_list &obj)\n    : ptr(nullptr)\n{\n  ptr = obj.copy();\n}\nval_list::val_list(std::nullptr_t)\n    : ptr(nullptr) {}\n\n\nval_list::val_list(__isl_take isl_val_list *ptr)\n    : ptr(ptr) {}\n\n\nval_list &val_list::operator=(val_list obj) {\n  std::swap(this->ptr, obj.ptr);\n  return *this;\n}\n\nval_list::~val_list() {\n  if (ptr)\n    isl_val_list_free(ptr);\n}\n\n__isl_give isl_val_list *val_list::copy() const & {\n  return isl_val_list_copy(ptr);\n}\n\n__isl_keep isl_val_list *val_list::get() const {\n  return ptr;\n}\n\n__isl_give isl_val_list *val_list::release() {\n  isl_val_list *tmp = ptr;\n  ptr = nullptr;\n  return tmp;\n}\n\nbool val_list::is_null() const {\n  return ptr == nullptr;\n}\nval_list::operator bool() const {\n  return !is_null();\n}\n\n\nctx val_list::get_ctx() const {\n  return ctx(isl_val_list_get_ctx(ptr));\n}\nstd::string val_list::to_str() const {\n  char *Tmp = isl_val_list_to_str(get());\n  if (!Tmp)\n    return \"\";\n  std::string S(Tmp);\n  free(Tmp);\n  return S;\n}\n\n\nvoid val_list::dump() const {\n  isl_val_list_dump(get());\n}\n\n\nval_list val_list::add(val el) const\n{\n  auto res = isl_val_list_add(copy(), el.release());\n  return manage(res);\n}\n\nval_list val_list::alloc(ctx ctx, int n)\n{\n  auto res = isl_val_list_alloc(ctx.release(), n);\n  return manage(res);\n}\n\nval_list val_list::clear() const\n{\n  auto res = isl_val_list_clear(copy());\n  return manage(res);\n}\n\nval_list val_list::concat(val_list list2) const\n{\n  auto res = isl_val_list_concat(copy(), list2.release());\n  return manage(res);\n}\n\nval_list val_list::drop(unsigned int first, unsigned int n) const\n{\n  auto res = isl_val_list_drop(copy(), first, n);\n  return manage(res);\n}\n\nstat val_list::foreach(const std::function<stat(val)> &fn) const\n{\n  struct fn_data {\n    const std::function<stat(val)> *func;\n  } fn_data = { &fn };\n  auto fn_lambda = [](isl_val *arg_0, void *arg_1) -> isl_stat {\n    auto *data = static_cast<struct fn_data *>(arg_1);\n    stat ret = (*data->func)(manage(arg_0));\n    return ret.release();\n  };\n  auto res = isl_val_list_foreach(get(), fn_lambda, &fn_data);\n  return manage(res);\n}\n\nval_list val_list::from_val(val el)\n{\n  auto res = isl_val_list_from_val(el.release());\n  return manage(res);\n}\n\nval val_list::get_at(int index) const\n{\n  auto res = isl_val_list_get_at(get(), index);\n  return manage(res);\n}\n\nval val_list::get_val(int index) const\n{\n  auto res = isl_val_list_get_val(get(), index);\n  return manage(res);\n}\n\nval_list val_list::insert(unsigned int pos, val el) const\n{\n  auto res = isl_val_list_insert(copy(), pos, el.release());\n  return manage(res);\n}\n\nisl_size val_list::n_val() const\n{\n  auto res = isl_val_list_n_val(get());\n  return res;\n}\n\nval_list val_list::reverse() const\n{\n  auto res = isl_val_list_reverse(copy());\n  return manage(res);\n}\n\nval_list val_list::set_val(int index, val el) const\n{\n  auto res = isl_val_list_set_val(copy(), index, el.release());\n  return manage(res);\n}\n\nisl_size val_list::size() const\n{\n  auto res = isl_val_list_size(get());\n  return res;\n}\n\nval_list val_list::swap(unsigned int pos1, unsigned int pos2) const\n{\n  auto res = isl_val_list_swap(copy(), pos1, pos2);\n  return manage(res);\n}\n\n// implementations for isl::vec\nvec manage(__isl_take isl_vec *ptr) {\n  return vec(ptr);\n}\nvec manage_copy(__isl_keep isl_vec *ptr) {\n  ptr = isl_vec_copy(ptr);\n  return vec(ptr);\n}\n\nvec::vec()\n    : ptr(nullptr) {}\n\nvec::vec(const vec &obj)\n    : ptr(nullptr)\n{\n  ptr = obj.copy();\n}\nvec::vec(std::nullptr_t)\n    : ptr(nullptr) {}\n\n\nvec::vec(__isl_take isl_vec *ptr)\n    : ptr(ptr) {}\n\n\nvec &vec::operator=(vec obj) {\n  std::swap(this->ptr, obj.ptr);\n  return *this;\n}\n\nvec::~vec() {\n  if (ptr)\n    isl_vec_free(ptr);\n}\n\n__isl_give isl_vec *vec::copy() const & {\n  return isl_vec_copy(ptr);\n}\n\n__isl_keep isl_vec *vec::get() const {\n  return ptr;\n}\n\n__isl_give isl_vec *vec::release() {\n  isl_vec *tmp = ptr;\n  ptr = nullptr;\n  return tmp;\n}\n\nbool vec::is_null() const {\n  return ptr == nullptr;\n}\nvec::operator bool() const {\n  return !is_null();\n}\n\n\nctx vec::get_ctx() const {\n  return ctx(isl_vec_get_ctx(ptr));\n}\n\nvoid vec::dump() const {\n  isl_vec_dump(get());\n}\n\n\nvec vec::add(vec vec2) const\n{\n  auto res = isl_vec_add(copy(), vec2.release());\n  return manage(res);\n}\n\nvec vec::add_els(unsigned int n) const\n{\n  auto res = isl_vec_add_els(copy(), n);\n  return manage(res);\n}\n\nvec vec::alloc(ctx ctx, unsigned int size)\n{\n  auto res = isl_vec_alloc(ctx.release(), size);\n  return manage(res);\n}\n\nvec vec::ceil() const\n{\n  auto res = isl_vec_ceil(copy());\n  return manage(res);\n}\n\nvec vec::clr() const\n{\n  auto res = isl_vec_clr(copy());\n  return manage(res);\n}\n\nint vec::cmp_element(const vec &vec2, int pos) const\n{\n  auto res = isl_vec_cmp_element(get(), vec2.get(), pos);\n  return res;\n}\n\nvec vec::concat(vec vec2) const\n{\n  auto res = isl_vec_concat(copy(), vec2.release());\n  return manage(res);\n}\n\nvec vec::drop_els(unsigned int pos, unsigned int n) const\n{\n  auto res = isl_vec_drop_els(copy(), pos, n);\n  return manage(res);\n}\n\nvec vec::extend(unsigned int size) const\n{\n  auto res = isl_vec_extend(copy(), size);\n  return manage(res);\n}\n\nval vec::get_element_val(int pos) const\n{\n  auto res = isl_vec_get_element_val(get(), pos);\n  return manage(res);\n}\n\nvec vec::insert_els(unsigned int pos, unsigned int n) const\n{\n  auto res = isl_vec_insert_els(copy(), pos, n);\n  return manage(res);\n}\n\nvec vec::insert_zero_els(unsigned int pos, unsigned int n) const\n{\n  auto res = isl_vec_insert_zero_els(copy(), pos, n);\n  return manage(res);\n}\n\nboolean vec::is_equal(const vec &vec2) const\n{\n  auto res = isl_vec_is_equal(get(), vec2.get());\n  return manage(res);\n}\n\nvec vec::mat_product(mat mat) const\n{\n  auto res = isl_vec_mat_product(copy(), mat.release());\n  return manage(res);\n}\n\nvec vec::move_els(unsigned int dst_col, unsigned int src_col, unsigned int n) const\n{\n  auto res = isl_vec_move_els(copy(), dst_col, src_col, n);\n  return manage(res);\n}\n\nvec vec::neg() const\n{\n  auto res = isl_vec_neg(copy());\n  return manage(res);\n}\n\nvec vec::set_element_si(int pos, int v) const\n{\n  auto res = isl_vec_set_element_si(copy(), pos, v);\n  return manage(res);\n}\n\nvec vec::set_element_val(int pos, val v) const\n{\n  auto res = isl_vec_set_element_val(copy(), pos, v.release());\n  return manage(res);\n}\n\nvec vec::set_si(int v) const\n{\n  auto res = isl_vec_set_si(copy(), v);\n  return manage(res);\n}\n\nvec vec::set_val(val v) const\n{\n  auto res = isl_vec_set_val(copy(), v.release());\n  return manage(res);\n}\n\nisl_size vec::size() const\n{\n  auto res = isl_vec_size(get());\n  return res;\n}\n\nvec vec::sort() const\n{\n  auto res = isl_vec_sort(copy());\n  return manage(res);\n}\n\nvec vec::zero(ctx ctx, unsigned int size)\n{\n  auto res = isl_vec_zero(ctx.release(), size);\n  return manage(res);\n}\n\nvec vec::zero_extend(unsigned int size) const\n{\n  auto res = isl_vec_zero_extend(copy(), size);\n  return manage(res);\n}\n} // namespace noexceptions \n} // namespace isl\n\n#endif /* ISL_CPP_CHECKED */\n"}, "11": {"id": 11, "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/include/isl/maybe_templ.h", "content": "#include <isl/ctx.h>\n#include <isl/maybe.h>\n\n/* A structure that possibly contains a pointer to an object of type ISL_TYPE.\n * The pointer in \"value\" is only valid if \"valid\" is isl_bool_true.\n * Otherwise, \"value\" is set to NULL.\n */\nstruct ISL_MAYBE(ISL_TYPE) {\n\tisl_bool\tvalid;\n\tISL_TYPE\t*value;\n};\ntypedef struct ISL_MAYBE(ISL_TYPE) ISL_MAYBE(ISL_TYPE);\n"}}, "reports": [{"events": [{"location": {"col": 1, "file": 2, "line": 1}, "message": "header is missing header guard"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/build/tools/polly/lib/External/isl/include/isl/stdint.h", "reportHash": "68ef19784306aec92b6e580ecf56a18a", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 6, "line": 13}, "message": "POLLY_CODEGEN_LOOPGENERATORS_H (fixit)"}, {"location": {"col": 9, "file": 6, "line": 13}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/include/polly/CodeGen/LoopGenerators.h", "reportHash": "69d9151b09b64a3d2f883a5b8df89816", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 7, "line": 13}, "message": "POLLY_CODEGEN_LOOPGENERATORSKMP_H (fixit)"}, {"location": {"col": 9, "file": 7, "line": 13}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/include/polly/CodeGen/LoopGeneratorsKMP.h", "reportHash": "c0d5bd3ad7e38fd66ff4da93fc989ac8", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 8, "line": 13}, "message": "POLLY_SUPPORT_SCOPHELPER_H (fixit)"}, {"location": {"col": 9, "file": 8, "line": 13}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/include/polly/Support/ScopHelper.h", "reportHash": "43cdbb42235a56873f1c49943cf90255", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 1, "file": 9, "line": 1}, "message": "header is missing header guard"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/include/isl/hmap.h", "reportHash": "7e854bb09a60058b4dbd92b940b00414", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 10, "line": 8}, "message": "ISL_ISL_NOEXCEPTIONS_H (fixit)"}, {"location": {"col": 9, "file": 10, "line": 8}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/include/isl/isl-noexceptions.h", "reportHash": "6f02767c20e37433214b09c70329c021", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 1, "file": 11, "line": 1}, "message": "header is missing header guard"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/include/isl/maybe_templ.h", "reportHash": "a731e6a99102fa664aff270c5414ef42", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}]};
      window.onload = function() {
        if (!browserCompatible) {
          setNonCompatibleBrowserMessage();
        } else {
          BugViewer.init(data.files, data.reports);
          BugViewer.create();
          BugViewer.initByUrl();
        }
      };
    </script>
  </head>
  <body>
  <div class="container">
    <div id="content">
      <div id="side-bar">
        <div class="header">
          <a href="index.html" class="button">&#8249; Return to List</a>
        </div>
        <div id="report-nav">
          <div class="header">Reports</div>
        </div>
      </div>
      <div id="editor-wrapper">
        <div class="header">
          <div id="file">
            <span class="label">File:</span>
            <span id="file-path"></span>
          </div>
          <div id="checker">
            <span class="label">Checker name:</span>
            <span id="checker-name"></span>
          </div>
          <div id="review-status-wrapper">
            <span class="label">Review status:</span>
            <span id="review-status"></span>
          </div>
        </div>
        <div id="editor"></div>
      </div>
    </div>
  </div>
  </body>
</html>
