<!DOCTYPE html>
<html>
  <head>
    <title>Plist HTML Viewer</title>

    <meta charset="UTF-8">

    <style type="text/css">
      .CodeMirror{font-family:monospace;height:300px;color:#000;direction:ltr}.CodeMirror-lines{padding:4px 0}.CodeMirror pre{padding:0 4px}.CodeMirror-gutter-filler,.CodeMirror-scrollbar-filler{background-color:#fff}.CodeMirror-gutters{border-right:1px solid #ddd;background-color:#f7f7f7;white-space:nowrap}.CodeMirror-linenumber{padding:0 3px 0 5px;min-width:20px;text-align:right;color:#999;white-space:nowrap}.CodeMirror-guttermarker{color:#000}.CodeMirror-guttermarker-subtle{color:#999}.CodeMirror-cursor{border-left:1px solid #000;border-right:none;width:0}.CodeMirror div.CodeMirror-secondarycursor{border-left:1px solid silver}.cm-fat-cursor .CodeMirror-cursor{width:auto;border:0!important;background:#7e7}.cm-fat-cursor div.CodeMirror-cursors{z-index:1}.cm-animate-fat-cursor{width:auto;border:0;-webkit-animation:blink 1.06s steps(1) infinite;-moz-animation:blink 1.06s steps(1) infinite;animation:blink 1.06s steps(1) infinite;background-color:#7e7}@-moz-keyframes blink{50%{background-color:transparent}}@-webkit-keyframes blink{50%{background-color:transparent}}@keyframes blink{50%{background-color:transparent}}.cm-tab{display:inline-block;text-decoration:inherit}.CodeMirror-rulers{position:absolute;left:0;right:0;top:-50px;bottom:-20px;overflow:hidden}.CodeMirror-ruler{border-left:1px solid #ccc;top:0;bottom:0;position:absolute}.cm-s-default .cm-header{color:#00f}.cm-s-default .cm-quote{color:#090}.cm-negative{color:#d44}.cm-positive{color:#292}.cm-header,.cm-strong{font-weight:700}.cm-em{font-style:italic}.cm-link{text-decoration:underline}.cm-strikethrough{text-decoration:line-through}.cm-s-default .cm-keyword{color:#708}.cm-s-default .cm-atom{color:#219}.cm-s-default .cm-number{color:#164}.cm-s-default .cm-def{color:#00f}.cm-s-default .cm-variable-2{color:#05a}.cm-s-default .cm-type,.cm-s-default .cm-variable-3{color:#085}.cm-s-default .cm-comment{color:#a50}.cm-s-default .cm-string{color:#a11}.cm-s-default .cm-string-2{color:#f50}.cm-s-default .cm-meta{color:#555}.cm-s-default .cm-qualifier{color:#555}.cm-s-default .cm-builtin{color:#30a}.cm-s-default .cm-bracket{color:#997}.cm-s-default .cm-tag{color:#170}.cm-s-default .cm-attribute{color:#00c}.cm-s-default .cm-hr{color:#999}.cm-s-default .cm-link{color:#00c}.cm-s-default .cm-error{color:red}.cm-invalidchar{color:red}.CodeMirror-composing{border-bottom:2px solid}div.CodeMirror span.CodeMirror-matchingbracket{color:#0f0}div.CodeMirror span.CodeMirror-nonmatchingbracket{color:#f22}.CodeMirror-matchingtag{background:rgba(255,150,0,.3)}.CodeMirror-activeline-background{background:#e8f2ff}.CodeMirror{position:relative;overflow:hidden;background:#fff}.CodeMirror-scroll{overflow:scroll!important;margin-bottom:-30px;margin-right:-30px;padding-bottom:30px;height:100%;outline:0;position:relative}.CodeMirror-sizer{position:relative;border-right:30px solid transparent}.CodeMirror-gutter-filler,.CodeMirror-hscrollbar,.CodeMirror-scrollbar-filler,.CodeMirror-vscrollbar{position:absolute;z-index:6;display:none}.CodeMirror-vscrollbar{right:0;top:0;overflow-x:hidden;overflow-y:scroll}.CodeMirror-hscrollbar{bottom:0;left:0;overflow-y:hidden;overflow-x:scroll}.CodeMirror-scrollbar-filler{right:0;bottom:0}.CodeMirror-gutter-filler{left:0;bottom:0}.CodeMirror-gutters{position:absolute;left:0;top:0;min-height:100%;z-index:3}.CodeMirror-gutter{white-space:normal;height:100%;display:inline-block;vertical-align:top;margin-bottom:-30px}.CodeMirror-gutter-wrapper{position:absolute;z-index:4;background:0 0!important;border:none!important}.CodeMirror-gutter-background{position:absolute;top:0;bottom:0;z-index:4}.CodeMirror-gutter-elt{position:absolute;cursor:default;z-index:4}.CodeMirror-gutter-wrapper ::selection{background-color:transparent}.CodeMirror-gutter-wrapper ::-moz-selection{background-color:transparent}.CodeMirror-lines{cursor:text;min-height:1px}.CodeMirror pre{-moz-border-radius:0;-webkit-border-radius:0;border-radius:0;border-width:0;background:0 0;font-family:inherit;font-size:inherit;margin:0;white-space:pre;word-wrap:normal;line-height:inherit;color:inherit;z-index:2;position:relative;overflow:visible;-webkit-tap-highlight-color:transparent;-webkit-font-variant-ligatures:contextual;font-variant-ligatures:contextual}.CodeMirror-wrap pre{word-wrap:break-word;white-space:pre-wrap;word-break:normal}.CodeMirror-linebackground{position:absolute;left:0;right:0;top:0;bottom:0;z-index:0}.CodeMirror-linewidget{position:relative;z-index:2;overflow:auto}.CodeMirror-rtl pre{direction:rtl}.CodeMirror-code{outline:0}.CodeMirror-gutter,.CodeMirror-gutters,.CodeMirror-linenumber,.CodeMirror-scroll,.CodeMirror-sizer{-moz-box-sizing:content-box;box-sizing:content-box}.CodeMirror-measure{position:absolute;width:100%;height:0;overflow:hidden;visibility:hidden}.CodeMirror-cursor{position:absolute;pointer-events:none}.CodeMirror-measure pre{position:static}div.CodeMirror-cursors{visibility:hidden;position:relative;z-index:3}div.CodeMirror-dragcursors{visibility:visible}.CodeMirror-focused div.CodeMirror-cursors{visibility:visible}.CodeMirror-selected{background:#d9d9d9}.CodeMirror-focused .CodeMirror-selected{background:#d7d4f0}.CodeMirror-crosshair{cursor:crosshair}.CodeMirror-line::selection,.CodeMirror-line>span::selection,.CodeMirror-line>span>span::selection{background:#d7d4f0}.CodeMirror-line::-moz-selection,.CodeMirror-line>span::-moz-selection,.CodeMirror-line>span>span::-moz-selection{background:#d7d4f0}.cm-searching{background-color:#ffa;background-color:rgba(255,255,0,.4)}.cm-force-border{padding-right:.1px}@media print{.CodeMirror div.CodeMirror-cursors{visibility:hidden}}.cm-tab-wrap-hack:after{content:''}span.CodeMirror-selectedtext{background:0 0}
/*# sourceMappingURL=codemirror.min.css.map */

      .severity-low {
  background-color: #669603;
}

.severity-low:after {
  content : 'L';
}

.severity-unspecified {
  background-color: #666666;
}

.severity-unspecified:after {
  content : 'U';
}

.severity-style {
  background-color: #9932cc;
}

.severity-style:after {
  content : 'S';
}

.severity-medium {
  background-color: #a9d323;
  color: black;
}

.severity-medium:after {
  content : 'M';
}

.severity-high {
  background-color: #ffa800;
}

.severity-high:after {
  content : 'H';
}

.severity-critical {
  background-color: #e92625;
}

.severity-critical:after {
  content : 'C';
}

i[class*="severity-"] {
  line-height: normal;
  text-transform: capitalize;
  font-size: 0.8em;
  font-weight: bold;
  color: white;
  display: inline-block;
  width: 16px;
  height: 16px;
  text-align: center;
  font-family: sans-serif;
}

      html, body {
  width: 100%;
  height: 100%;
  padding: 0px;
  margin: 0px;
}

div.container {
  padding: 10px;
}

#content {
  height: 100%;
  display: block;
  overflow: hidden;
}

#content > div {
  margin: 10px;
  overflow: hidden;
  border: 1px solid #ddd;
  border-radius: 3px;
  overflow: hidden;
  height: 97%;
}

.button {
  background-color: #f1f1f1;
  text-decoration: none;
  display: inline-block;
  padding: 8px 16px;
  color: black;
  cursor: pointer;
}

.button:hover {
  background-color: #ddd;
  color: black;
}

.review-status {
  color: white;
  text-align: center;
}

.review-status-confirmed {
  background-color: #e92625;
}

.review-status-false-positive {
  background-color: grey;
}

.review-status-intentional {
  background-color: #669603;
}

      div.container {
  width: 100%;
  height: 100%;
  padding: 0px;
}

#editor-wrapper {
  margin: 10px;
}

#side-bar {
  float: left;
  width: 260px;
  margin: 0px;
}

#report-nav ul {
  list-style-type: none;
  padding: 0;
  margin: 0;
  overflow-y: auto;
  height: 100%;
}

#report-nav ul > li {
  padding: .4em;
  background-color: #fff;
  border-bottom: 1px solid rgba(0,0,0,.125);
  text-align: left;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

#report-nav ul > li.active {
  background-color: #427ea9;
  color: white;
}

#report-nav ul > li:hover {
  background-color: #427ea9;
  color: white;
  cursor: pointer;
}

#report-nav ul a {
  text-decoration: none;
}

#report-nav i[class*="severity-"] {
  margin-right: 5px;
}

.header {
  border-bottom: 1px solid lightgrey;
  font-family: monospace;
  padding: 10px;
  background-color: #fafbfc;
  border-bottom: 1px solid #e1e4e8;
  border-top-left-radius: 2px;
  border-top-right-radius: 2px;
}

#report-nav .header {
  font-weight: bold;
}

#editor-wrapper .header > div {
  padding-top: 2px;
}

#file-path,
#checker-name {
  color: #195ea2;
}

#review-status {
  padding: 0px 5px;
}

#file-path {
  font-family: monospace;
}

.check-msg {
  display: inline-block;
  padding: 3px 6px;
  margin: 1px;
  -webkit-border-radius: 5px;
  -moz-border-radius: 5px;
  border-radius: 5px;
}

.check-msg.info {
  color: #00546f;
  background-color: #bfdfe9;
  border: 1px solid #87a8b3;
}

.check-msg.error {
  background-color: #f2dede;
  color: #a94442;
  border: 1px solid #ebcccc;
}

.check-msg.macro {
  background-color: #d7dac2;
  color: #4f5c6d;
  border: 1px solid #d7dac2;
}

.check-msg.note {
  background-color: #d7d7d7;
  color: #4f5c6d;
  border: 1px solid #bfbfbf;
}

.check-msg.current {
  border: 2px dashed #3692ff;
}

.check-msg .tag {
  padding: 1px 5px;
  text-align: center;
  border-radius: 2px;
  margin-right: 5px;
  text-decoration: inherit;
}

.check-msg .tag.macro {
  background-color: #83876a;
  color: white;
  text-transform: capitalize;
}

.check-msg .tag.note {
  background-color: #9299a1;
  color: white;
  text-transform: capitalize;
}

.checker-enum {
  color: white;
  padding: 1px 5px;
  text-align: center;
  border-radius: 25px;
  margin-right: 5px;
  text-decoration: inherit;
}

.checker-enum.info {
  background-color: #427ea9;
}

.checker-enum.error {
  background-color: #a94442;
}

.arrow {
  border: solid black;
  border-width: 0 3px 3px 0;
  display: inline-block;
  padding: 3px;
  cursor: pointer;
  margin: 0px 5px;
}

.arrow:hover {
  border: solid #437ea8;
  border-width: 0 3px 3px 0;
}

.left-arrow {
  transform: rotate(135deg);
  -webkit-transform: rotate(135deg);
}

.right-arrow {
  transform: rotate(-45deg);
  -webkit-transform: rotate(-45deg);
}

    </style>

    <script type="text/javascript">
      function setNonCompatibleBrowserMessage() {
  document.body.innerHTML =
    '<h2 style="margin-left: 20px;">Your browser is not compatible with CodeChecker Viewer!</h2> \
     <p style="margin-left: 20px;">The version required for the following browsers are:</p> \
     <ul style="margin-left: 20px;"> \
     <li>Internet Explorer: version 9 or newer</li> \
     <li>Firefox: version 22.0 or newer</li> \
     </ul>';
}

// http://stackoverflow.com/questions/5916900/how-can-you-detect-the-version-of-a-browser
var browserVersion = (function(){
  var ua = navigator.userAgent, tem,
    M = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];

  if (/trident/i.test(M[1])) {
    tem = /\brv[ :]+(\d+)/g.exec(ua) || [];
    return 'IE ' + (tem[1] || '');
  }

  if (M[1] === 'Chrome') {
    tem = ua.match(/\b(OPR|Edge)\/(\d+)/);
    if (tem != null) return tem.slice(1).join(' ').replace('OPR', 'Opera');
  }

  M = M[2] ? [M[1], M[2]] : [navigator.appName, navigator.appVersion, '-?'];
  if ((tem = ua.match(/version\/(\d+)/i)) != null) M.splice(1, 1, tem[1]);
    return M.join(' ');
})();

var pos = browserVersion.indexOf(' ');
var browser = browserVersion.substr(0, pos);
var version = parseInt(browserVersion.substr(pos + 1));

var browserCompatible
  = browser === 'Firefox'
  ? version >= 22
  : browser === 'IE'
  ? version >= 9
  : true;


      /* MIT License

Copyright (C) 2017 by Marijn Haverbeke <marijnh@gmail.com> and others

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
 */
      !function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):e.CodeMirror=t()}(this,function(){"use strict";function e(e){return new RegExp("(^|\\s)"+e+"(?:$|\\s)\\s*")}function t(e){for(var t=e.childNodes.length;t>0;--t)e.removeChild(e.firstChild);return e}function r(e,r){return t(e).appendChild(r)}function n(e,t,r,n){var i=document.createElement(e);if(r&&(i.className=r),n&&(i.style.cssText=n),"string"==typeof t)i.appendChild(document.createTextNode(t));else if(t)for(var o=0;o<t.length;++o)i.appendChild(t[o]);return i}function i(e,t,r,i){var o=n(e,t,r,i);return o.setAttribute("role","presentation"),o}function o(e,t){if(3==t.nodeType&&(t=t.parentNode),e.contains)return e.contains(t);do{if(11==t.nodeType&&(t=t.host),t==e)return!0}while(t=t.parentNode)}function l(){var e;try{e=document.activeElement}catch(t){e=document.body||null}for(;e&&e.shadowRoot&&e.shadowRoot.activeElement;)e=e.shadowRoot.activeElement;return e}function s(t,r){var n=t.className;e(r).test(n)||(t.className+=(n?" ":"")+r)}function a(t,r){for(var n=t.split(" "),i=0;i<n.length;i++)n[i]&&!e(n[i]).test(r)&&(r+=" "+n[i]);return r}function u(e){var t=Array.prototype.slice.call(arguments,1);return function(){return e.apply(null,t)}}function c(e,t,r){t||(t={});for(var n in e)!e.hasOwnProperty(n)||!1===r&&t.hasOwnProperty(n)||(t[n]=e[n]);return t}function f(e,t,r,n,i){null==t&&-1==(t=e.search(/[^\s\u00a0]/))&&(t=e.length);for(var o=n||0,l=i||0;;){var s=e.indexOf("\t",o);if(s<0||s>=t)return l+(t-o);l+=s-o,l+=r-l%r,o=s+1}}function h(e,t){for(var r=0;r<e.length;++r)if(e[r]==t)return r;return-1}function d(e,t,r){for(var n=0,i=0;;){var o=e.indexOf("\t",n);-1==o&&(o=e.length);var l=o-n;if(o==e.length||i+l>=t)return n+Math.min(l,t-i);if(i+=o-n,i+=r-i%r,n=o+1,i>=t)return n}}function p(e){for(;Kl.length<=e;)Kl.push(g(Kl)+" ");return Kl[e]}function g(e){return e[e.length-1]}function v(e,t){for(var r=[],n=0;n<e.length;n++)r[n]=t(e[n],n);return r}function m(e,t,r){for(var n=0,i=r(t);n<e.length&&r(e[n])<=i;)n++;e.splice(n,0,t)}function y(){}function b(e,t){var r;return Object.create?r=Object.create(e):(y.prototype=e,r=new y),t&&c(t,r),r}function w(e){return/\w/.test(e)||e>""&&(e.toUpperCase()!=e.toLowerCase()||jl.test(e))}function x(e,t){return t?!!(t.source.indexOf("\\w")>-1&&w(e))||t.test(e):w(e)}function C(e){for(var t in e)if(e.hasOwnProperty(t)&&e[t])return!1;return!0}function S(e){return e.charCodeAt(0)>=768&&Xl.test(e)}function L(e,t,r){for(;(r<0?t>0:t<e.length)&&S(e.charAt(t));)t+=r;return t}function k(e,t,r){for(var n=t>r?-1:1;;){if(t==r)return t;var i=(t+r)/2,o=n<0?Math.ceil(i):Math.floor(i);if(o==t)return e(o)?t:r;e(o)?r=o:t=o+n}}function T(e,t,r){var o=this;this.input=r,o.scrollbarFiller=n("div",null,"CodeMirror-scrollbar-filler"),o.scrollbarFiller.setAttribute("cm-not-content","true"),o.gutterFiller=n("div",null,"CodeMirror-gutter-filler"),o.gutterFiller.setAttribute("cm-not-content","true"),o.lineDiv=i("div",null,"CodeMirror-code"),o.selectionDiv=n("div",null,null,"position: relative; z-index: 1"),o.cursorDiv=n("div",null,"CodeMirror-cursors"),o.measure=n("div",null,"CodeMirror-measure"),o.lineMeasure=n("div",null,"CodeMirror-measure"),o.lineSpace=i("div",[o.measure,o.lineMeasure,o.selectionDiv,o.cursorDiv,o.lineDiv],null,"position: relative; outline: none");var l=i("div",[o.lineSpace],"CodeMirror-lines");o.mover=n("div",[l],null,"position: relative"),o.sizer=n("div",[o.mover],"CodeMirror-sizer"),o.sizerWidth=null,o.heightForcer=n("div",null,null,"position: absolute; height: "+Rl+"px; width: 1px;"),o.gutters=n("div",null,"CodeMirror-gutters"),o.lineGutter=null,o.scroller=n("div",[o.sizer,o.heightForcer,o.gutters],"CodeMirror-scroll"),o.scroller.setAttribute("tabIndex","-1"),o.wrapper=n("div",[o.scrollbarFiller,o.gutterFiller,o.scroller],"CodeMirror"),gl&&vl<8&&(o.gutters.style.zIndex=-1,o.scroller.style.paddingRight=0),ml||fl&&Tl||(o.scroller.draggable=!0),e&&(e.appendChild?e.appendChild(o.wrapper):e(o.wrapper)),o.viewFrom=o.viewTo=t.first,o.reportedViewFrom=o.reportedViewTo=t.first,o.view=[],o.renderedView=null,o.externalMeasured=null,o.viewOffset=0,o.lastWrapHeight=o.lastWrapWidth=0,o.updateLineNumbers=null,o.nativeBarWidth=o.barHeight=o.barWidth=0,o.scrollbarsClipped=!1,o.lineNumWidth=o.lineNumInnerWidth=o.lineNumChars=null,o.alignWidgets=!1,o.cachedCharWidth=o.cachedTextHeight=o.cachedPaddingH=null,o.maxLine=null,o.maxLineLength=0,o.maxLineChanged=!1,o.wheelDX=o.wheelDY=o.wheelStartX=o.wheelStartY=null,o.shift=!1,o.selForContextMenu=null,o.activeTouch=null,r.init(o)}function M(e,t){if((t-=e.first)<0||t>=e.size)throw new Error("There is no line "+(t+e.first)+" in the document.");for(var r=e;!r.lines;)for(var n=0;;++n){var i=r.children[n],o=i.chunkSize();if(t<o){r=i;break}t-=o}return r.lines[t]}function N(e,t,r){var n=[],i=t.line;return e.iter(t.line,r.line+1,function(e){var o=e.text;i==r.line&&(o=o.slice(0,r.ch)),i==t.line&&(o=o.slice(t.ch)),n.push(o),++i}),n}function O(e,t,r){var n=[];return e.iter(t,r,function(e){n.push(e.text)}),n}function A(e,t){var r=t-e.height;if(r)for(var n=e;n;n=n.parent)n.height+=r}function W(e){if(null==e.parent)return null;for(var t=e.parent,r=h(t.lines,e),n=t.parent;n;t=n,n=n.parent)for(var i=0;n.children[i]!=t;++i)r+=n.children[i].chunkSize();return r+t.first}function D(e,t){var r=e.first;e:do{for(var n=0;n<e.children.length;++n){var i=e.children[n],o=i.height;if(t<o){e=i;continue e}t-=o,r+=i.chunkSize()}return r}while(!e.lines);for(var l=0;l<e.lines.length;++l){var s=e.lines[l].height;if(t<s)break;t-=s}return r+l}function H(e,t){return t>=e.first&&t<e.first+e.size}function F(e,t){return String(e.lineNumberFormatter(t+e.firstLineNumber))}function E(e,t,r){if(void 0===r&&(r=null),!(this instanceof E))return new E(e,t,r);this.line=e,this.ch=t,this.sticky=r}function P(e,t){return e.line-t.line||e.ch-t.ch}function I(e,t){return e.sticky==t.sticky&&0==P(e,t)}function z(e){return E(e.line,e.ch)}function R(e,t){return P(e,t)<0?t:e}function B(e,t){return P(e,t)<0?e:t}function G(e,t){return Math.max(e.first,Math.min(t,e.first+e.size-1))}function U(e,t){if(t.line<e.first)return E(e.first,0);var r=e.first+e.size-1;return t.line>r?E(r,M(e,r).text.length):V(t,M(e,t.line).text.length)}function V(e,t){var r=e.ch;return null==r||r>t?E(e.line,t):r<0?E(e.line,0):e}function K(e,t){for(var r=[],n=0;n<t.length;n++)r[n]=U(e,t[n]);return r}function j(){Yl=!0}function X(){_l=!0}function Y(e,t,r){this.marker=e,this.from=t,this.to=r}function _(e,t){if(e)for(var r=0;r<e.length;++r){var n=e[r];if(n.marker==t)return n}}function $(e,t){for(var r,n=0;n<e.length;++n)e[n]!=t&&(r||(r=[])).push(e[n]);return r}function q(e,t){e.markedSpans=e.markedSpans?e.markedSpans.concat([t]):[t],t.marker.attachLine(e)}function Z(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t)||o.from==t&&"bookmark"==l.type&&(!r||!o.marker.insertLeft)){var s=null==o.to||(l.inclusiveRight?o.to>=t:o.to>t);(n||(n=[])).push(new Y(l,o.from,s?null:o.to))}}return n}function Q(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.to||(l.inclusiveRight?o.to>=t:o.to>t)||o.from==t&&"bookmark"==l.type&&(!r||o.marker.insertLeft)){var s=null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t);(n||(n=[])).push(new Y(l,s?null:o.from-t,null==o.to?null:o.to-t))}}return n}function J(e,t){if(t.full)return null;var r=H(e,t.from.line)&&M(e,t.from.line).markedSpans,n=H(e,t.to.line)&&M(e,t.to.line).markedSpans;if(!r&&!n)return null;var i=t.from.ch,o=t.to.ch,l=0==P(t.from,t.to),s=Z(r,i,l),a=Q(n,o,l),u=1==t.text.length,c=g(t.text).length+(u?i:0);if(s)for(var f=0;f<s.length;++f){var h=s[f];if(null==h.to){var d=_(a,h.marker);d?u&&(h.to=null==d.to?null:d.to+c):h.to=i}}if(a)for(var p=0;p<a.length;++p){var v=a[p];null!=v.to&&(v.to+=c),null==v.from?_(s,v.marker)||(v.from=c,u&&(s||(s=[])).push(v)):(v.from+=c,u&&(s||(s=[])).push(v))}s&&(s=ee(s)),a&&a!=s&&(a=ee(a));var m=[s];if(!u){var y,b=t.text.length-2;if(b>0&&s)for(var w=0;w<s.length;++w)null==s[w].to&&(y||(y=[])).push(new Y(s[w].marker,null,null));for(var x=0;x<b;++x)m.push(y);m.push(a)}return m}function ee(e){for(var t=0;t<e.length;++t){var r=e[t];null!=r.from&&r.from==r.to&&!1!==r.marker.clearWhenEmpty&&e.splice(t--,1)}return e.length?e:null}function te(e,t,r){var n=null;if(e.iter(t.line,r.line+1,function(e){if(e.markedSpans)for(var t=0;t<e.markedSpans.length;++t){var r=e.markedSpans[t].marker;!r.readOnly||n&&-1!=h(n,r)||(n||(n=[])).push(r)}}),!n)return null;for(var i=[{from:t,to:r}],o=0;o<n.length;++o)for(var l=n[o],s=l.find(0),a=0;a<i.length;++a){var u=i[a];if(!(P(u.to,s.from)<0||P(u.from,s.to)>0)){var c=[a,1],f=P(u.from,s.from),d=P(u.to,s.to);(f<0||!l.inclusiveLeft&&!f)&&c.push({from:u.from,to:s.from}),(d>0||!l.inclusiveRight&&!d)&&c.push({from:s.to,to:u.to}),i.splice.apply(i,c),a+=c.length-3}}return i}function re(e){var t=e.markedSpans;if(t){for(var r=0;r<t.length;++r)t[r].marker.detachLine(e);e.markedSpans=null}}function ne(e,t){if(t){for(var r=0;r<t.length;++r)t[r].marker.attachLine(e);e.markedSpans=t}}function ie(e){return e.inclusiveLeft?-1:0}function oe(e){return e.inclusiveRight?1:0}function le(e,t){var r=e.lines.length-t.lines.length;if(0!=r)return r;var n=e.find(),i=t.find(),o=P(n.from,i.from)||ie(e)-ie(t);if(o)return-o;var l=P(n.to,i.to)||oe(e)-oe(t);return l||t.id-e.id}function se(e,t){var r,n=_l&&e.markedSpans;if(n)for(var i=void 0,o=0;o<n.length;++o)(i=n[o]).marker.collapsed&&null==(t?i.from:i.to)&&(!r||le(r,i.marker)<0)&&(r=i.marker);return r}function ae(e){return se(e,!0)}function ue(e){return se(e,!1)}function ce(e,t,r,n,i){var o=M(e,t),l=_l&&o.markedSpans;if(l)for(var s=0;s<l.length;++s){var a=l[s];if(a.marker.collapsed){var u=a.marker.find(0),c=P(u.from,r)||ie(a.marker)-ie(i),f=P(u.to,n)||oe(a.marker)-oe(i);if(!(c>=0&&f<=0||c<=0&&f>=0)&&(c<=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.to,r)>=0:P(u.to,r)>0)||c>=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.from,n)<=0:P(u.from,n)<0)))return!0}}}function fe(e){for(var t;t=ae(e);)e=t.find(-1,!0).line;return e}function he(e){for(var t;t=ue(e);)e=t.find(1,!0).line;return e}function de(e){for(var t,r;t=ue(e);)e=t.find(1,!0).line,(r||(r=[])).push(e);return r}function pe(e,t){var r=M(e,t),n=fe(r);return r==n?t:W(n)}function ge(e,t){if(t>e.lastLine())return t;var r,n=M(e,t);if(!ve(e,n))return t;for(;r=ue(n);)n=r.find(1,!0).line;return W(n)+1}function ve(e,t){var r=_l&&t.markedSpans;if(r)for(var n=void 0,i=0;i<r.length;++i)if((n=r[i]).marker.collapsed){if(null==n.from)return!0;if(!n.marker.widgetNode&&0==n.from&&n.marker.inclusiveLeft&&me(e,t,n))return!0}}function me(e,t,r){if(null==r.to){var n=r.marker.find(1,!0);return me(e,n.line,_(n.line.markedSpans,r.marker))}if(r.marker.inclusiveRight&&r.to==t.text.length)return!0;for(var i=void 0,o=0;o<t.markedSpans.length;++o)if((i=t.markedSpans[o]).marker.collapsed&&!i.marker.widgetNode&&i.from==r.to&&(null==i.to||i.to!=r.from)&&(i.marker.inclusiveLeft||r.marker.inclusiveRight)&&me(e,t,i))return!0}function ye(e){for(var t=0,r=(e=fe(e)).parent,n=0;n<r.lines.length;++n){var i=r.lines[n];if(i==e)break;t+=i.height}for(var o=r.parent;o;r=o,o=r.parent)for(var l=0;l<o.children.length;++l){var s=o.children[l];if(s==r)break;t+=s.height}return t}function be(e){if(0==e.height)return 0;for(var t,r=e.text.length,n=e;t=ae(n);){var i=t.find(0,!0);n=i.from.line,r+=i.from.ch-i.to.ch}for(n=e;t=ue(n);){var o=t.find(0,!0);r-=n.text.length-o.from.ch,r+=(n=o.to.line).text.length-o.to.ch}return r}function we(e){var t=e.display,r=e.doc;t.maxLine=M(r,r.first),t.maxLineLength=be(t.maxLine),t.maxLineChanged=!0,r.iter(function(e){var r=be(e);r>t.maxLineLength&&(t.maxLineLength=r,t.maxLine=e)})}function xe(e,t,r,n){if(!e)return n(t,r,"ltr",0);for(var i=!1,o=0;o<e.length;++o){var l=e[o];(l.from<r&&l.to>t||t==r&&l.to==t)&&(n(Math.max(l.from,t),Math.min(l.to,r),1==l.level?"rtl":"ltr",o),i=!0)}i||n(t,r,"ltr")}function Ce(e,t,r){var n;$l=null;for(var i=0;i<e.length;++i){var o=e[i];if(o.from<t&&o.to>t)return i;o.to==t&&(o.from!=o.to&&"before"==r?n=i:$l=i),o.from==t&&(o.from!=o.to&&"before"!=r?n=i:$l=i)}return null!=n?n:$l}function Se(e,t){var r=e.order;return null==r&&(r=e.order=ql(e.text,t)),r}function Le(e,t){return e._handlers&&e._handlers[t]||Zl}function ke(e,t,r){if(e.removeEventListener)e.removeEventListener(t,r,!1);else if(e.detachEvent)e.detachEvent("on"+t,r);else{var n=e._handlers,i=n&&n[t];if(i){var o=h(i,r);o>-1&&(n[t]=i.slice(0,o).concat(i.slice(o+1)))}}}function Te(e,t){var r=Le(e,t);if(r.length)for(var n=Array.prototype.slice.call(arguments,2),i=0;i<r.length;++i)r[i].apply(null,n)}function Me(e,t,r){return"string"==typeof t&&(t={type:t,preventDefault:function(){this.defaultPrevented=!0}}),Te(e,r||t.type,e,t),He(t)||t.codemirrorIgnore}function Ne(e){var t=e._handlers&&e._handlers.cursorActivity;if(t)for(var r=e.curOp.cursorActivityHandlers||(e.curOp.cursorActivityHandlers=[]),n=0;n<t.length;++n)-1==h(r,t[n])&&r.push(t[n])}function Oe(e,t){return Le(e,t).length>0}function Ae(e){e.prototype.on=function(e,t){Ql(this,e,t)},e.prototype.off=function(e,t){ke(this,e,t)}}function We(e){e.preventDefault?e.preventDefault():e.returnValue=!1}function De(e){e.stopPropagation?e.stopPropagation():e.cancelBubble=!0}function He(e){return null!=e.defaultPrevented?e.defaultPrevented:0==e.returnValue}function Fe(e){We(e),De(e)}function Ee(e){return e.target||e.srcElement}function Pe(e){var t=e.which;return null==t&&(1&e.button?t=1:2&e.button?t=3:4&e.button&&(t=2)),Ml&&e.ctrlKey&&1==t&&(t=3),t}function Ie(e){if(null==Il){var t=n("span","​");r(e,n("span",[t,document.createTextNode("x")])),0!=e.firstChild.offsetHeight&&(Il=t.offsetWidth<=1&&t.offsetHeight>2&&!(gl&&vl<8))}var i=Il?n("span","​"):n("span"," ",null,"display: inline-block; width: 1px; margin-right: -1px");return i.setAttribute("cm-text",""),i}function ze(e){if(null!=zl)return zl;var n=r(e,document.createTextNode("AخA")),i=Wl(n,0,1).getBoundingClientRect(),o=Wl(n,1,2).getBoundingClientRect();return t(e),!(!i||i.left==i.right)&&(zl=o.right-i.right<3)}function Re(e){if(null!=ns)return ns;var t=r(e,n("span","x")),i=t.getBoundingClientRect(),o=Wl(t,0,1).getBoundingClientRect();return ns=Math.abs(i.left-o.left)>1}function Be(e,t){arguments.length>2&&(t.dependencies=Array.prototype.slice.call(arguments,2)),is[e]=t}function Ge(e){if("string"==typeof e&&os.hasOwnProperty(e))e=os[e];else if(e&&"string"==typeof e.name&&os.hasOwnProperty(e.name)){var t=os[e.name];"string"==typeof t&&(t={name:t}),(e=b(t,e)).name=t.name}else{if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+xml$/.test(e))return Ge("application/xml");if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+json$/.test(e))return Ge("application/json")}return"string"==typeof e?{name:e}:e||{name:"null"}}function Ue(e,t){t=Ge(t);var r=is[t.name];if(!r)return Ue(e,"text/plain");var n=r(e,t);if(ls.hasOwnProperty(t.name)){var i=ls[t.name];for(var o in i)i.hasOwnProperty(o)&&(n.hasOwnProperty(o)&&(n["_"+o]=n[o]),n[o]=i[o])}if(n.name=t.name,t.helperType&&(n.helperType=t.helperType),t.modeProps)for(var l in t.modeProps)n[l]=t.modeProps[l];return n}function Ve(e,t){c(t,ls.hasOwnProperty(e)?ls[e]:ls[e]={})}function Ke(e,t){if(!0===t)return t;if(e.copyState)return e.copyState(t);var r={};for(var n in t){var i=t[n];i instanceof Array&&(i=i.concat([])),r[n]=i}return r}function je(e,t){for(var r;e.innerMode&&(r=e.innerMode(t))&&r.mode!=e;)t=r.state,e=r.mode;return r||{mode:e,state:t}}function Xe(e,t,r){return!e.startState||e.startState(t,r)}function Ye(e,t,r,n){var i=[e.state.modeGen],o={};tt(e,t.text,e.doc.mode,r,function(e,t){return i.push(e,t)},o,n);for(var l=r.state,s=0;s<e.state.overlays.length;++s)!function(n){var l=e.state.overlays[n],s=1,a=0;r.state=!0,tt(e,t.text,l.mode,r,function(e,t){for(var r=s;a<e;){var n=i[s];n>e&&i.splice(s,1,e,i[s+1],n),s+=2,a=Math.min(e,n)}if(t)if(l.opaque)i.splice(r,s-r,e,"overlay "+t),s=r+2;else for(;r<s;r+=2){var o=i[r+1];i[r+1]=(o?o+" ":"")+"overlay "+t}},o)}(s);return r.state=l,{styles:i,classes:o.bgClass||o.textClass?o:null}}function _e(e,t,r){if(!t.styles||t.styles[0]!=e.state.modeGen){var n=$e(e,W(t)),i=t.text.length>e.options.maxHighlightLength&&Ke(e.doc.mode,n.state),o=Ye(e,t,n);i&&(n.state=i),t.stateAfter=n.save(!i),t.styles=o.styles,o.classes?t.styleClasses=o.classes:t.styleClasses&&(t.styleClasses=null),r===e.doc.highlightFrontier&&(e.doc.modeFrontier=Math.max(e.doc.modeFrontier,++e.doc.highlightFrontier))}return t.styles}function $e(e,t,r){var n=e.doc,i=e.display;if(!n.mode.startState)return new us(n,!0,t);var o=rt(e,t,r),l=o>n.first&&M(n,o-1).stateAfter,s=l?us.fromSaved(n,l,o):new us(n,Xe(n.mode),o);return n.iter(o,t,function(r){qe(e,r.text,s);var n=s.line;r.stateAfter=n==t-1||n%5==0||n>=i.viewFrom&&n<i.viewTo?s.save():null,s.nextLine()}),r&&(n.modeFrontier=s.line),s}function qe(e,t,r,n){var i=e.doc.mode,o=new ss(t,e.options.tabSize,r);for(o.start=o.pos=n||0,""==t&&Ze(i,r.state);!o.eol();)Qe(i,o,r.state),o.start=o.pos}function Ze(e,t){if(e.blankLine)return e.blankLine(t);if(e.innerMode){var r=je(e,t);return r.mode.blankLine?r.mode.blankLine(r.state):void 0}}function Qe(e,t,r,n){for(var i=0;i<10;i++){n&&(n[0]=je(e,r).mode);var o=e.token(t,r);if(t.pos>t.start)return o}throw new Error("Mode "+e.name+" failed to advance stream.")}function Je(e,t,r,n){var i,o,l=e.doc,s=l.mode,a=M(l,(t=U(l,t)).line),u=$e(e,t.line,r),c=new ss(a.text,e.options.tabSize,u);for(n&&(o=[]);(n||c.pos<t.ch)&&!c.eol();)c.start=c.pos,i=Qe(s,c,u.state),n&&o.push(new cs(c,i,Ke(l.mode,u.state)));return n?o:new cs(c,i,u.state)}function et(e,t){if(e)for(;;){var r=e.match(/(?:^|\s+)line-(background-)?(\S+)/);if(!r)break;e=e.slice(0,r.index)+e.slice(r.index+r[0].length);var n=r[1]?"bgClass":"textClass";null==t[n]?t[n]=r[2]:new RegExp("(?:^|s)"+r[2]+"(?:$|s)").test(t[n])||(t[n]+=" "+r[2])}return e}function tt(e,t,r,n,i,o,l){var s=r.flattenSpans;null==s&&(s=e.options.flattenSpans);var a,u=0,c=null,f=new ss(t,e.options.tabSize,n),h=e.options.addModeClass&&[null];for(""==t&&et(Ze(r,n.state),o);!f.eol();){if(f.pos>e.options.maxHighlightLength?(s=!1,l&&qe(e,t,n,f.pos),f.pos=t.length,a=null):a=et(Qe(r,f,n.state,h),o),h){var d=h[0].name;d&&(a="m-"+(a?d+" "+a:d))}if(!s||c!=a){for(;u<f.start;)i(u=Math.min(f.start,u+5e3),c);c=a}f.start=f.pos}for(;u<f.pos;){var p=Math.min(f.pos,u+5e3);i(p,c),u=p}}function rt(e,t,r){for(var n,i,o=e.doc,l=r?-1:t-(e.doc.mode.innerMode?1e3:100),s=t;s>l;--s){if(s<=o.first)return o.first;var a=M(o,s-1),u=a.stateAfter;if(u&&(!r||s+(u instanceof as?u.lookAhead:0)<=o.modeFrontier))return s;var c=f(a.text,null,e.options.tabSize);(null==i||n>c)&&(i=s-1,n=c)}return i}function nt(e,t){if(e.modeFrontier=Math.min(e.modeFrontier,t),!(e.highlightFrontier<t-10)){for(var r=e.first,n=t-1;n>r;n--){var i=M(e,n).stateAfter;if(i&&(!(i instanceof as)||n+i.lookAhead<t)){r=n+1;break}}e.highlightFrontier=Math.min(e.highlightFrontier,r)}}function it(e,t,r,n){e.text=t,e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null),null!=e.order&&(e.order=null),re(e),ne(e,r);var i=n?n(e):1;i!=e.height&&A(e,i)}function ot(e){e.parent=null,re(e)}function lt(e,t){if(!e||/^\s*$/.test(e))return null;var r=t.addModeClass?ps:ds;return r[e]||(r[e]=e.replace(/\S+/g,"cm-$&"))}function st(e,t){var r=i("span",null,null,ml?"padding-right: .1px":null),n={pre:i("pre",[r],"CodeMirror-line"),content:r,col:0,pos:0,cm:e,trailingSpace:!1,splitSpaces:(gl||ml)&&e.getOption("lineWrapping")};t.measure={};for(var o=0;o<=(t.rest?t.rest.length:0);o++){var l=o?t.rest[o-1]:t.line,s=void 0;n.pos=0,n.addToken=ut,ze(e.display.measure)&&(s=Se(l,e.doc.direction))&&(n.addToken=ft(n.addToken,s)),n.map=[],dt(l,n,_e(e,l,t!=e.display.externalMeasured&&W(l))),l.styleClasses&&(l.styleClasses.bgClass&&(n.bgClass=a(l.styleClasses.bgClass,n.bgClass||"")),l.styleClasses.textClass&&(n.textClass=a(l.styleClasses.textClass,n.textClass||""))),0==n.map.length&&n.map.push(0,0,n.content.appendChild(Ie(e.display.measure))),0==o?(t.measure.map=n.map,t.measure.cache={}):((t.measure.maps||(t.measure.maps=[])).push(n.map),(t.measure.caches||(t.measure.caches=[])).push({}))}if(ml){var u=n.content.lastChild;(/\bcm-tab\b/.test(u.className)||u.querySelector&&u.querySelector(".cm-tab"))&&(n.content.className="cm-tab-wrap-hack")}return Te(e,"renderLine",e,t.line,n.pre),n.pre.className&&(n.textClass=a(n.pre.className,n.textClass||"")),n}function at(e){var t=n("span","•","cm-invalidchar");return t.title="\\u"+e.charCodeAt(0).toString(16),t.setAttribute("aria-label",t.title),t}function ut(e,t,r,i,o,l,s){if(t){var a,u=e.splitSpaces?ct(t,e.trailingSpace):t,c=e.cm.state.specialChars,f=!1;if(c.test(t)){a=document.createDocumentFragment();for(var h=0;;){c.lastIndex=h;var d=c.exec(t),g=d?d.index-h:t.length-h;if(g){var v=document.createTextNode(u.slice(h,h+g));gl&&vl<9?a.appendChild(n("span",[v])):a.appendChild(v),e.map.push(e.pos,e.pos+g,v),e.col+=g,e.pos+=g}if(!d)break;h+=g+1;var m=void 0;if("\t"==d[0]){var y=e.cm.options.tabSize,b=y-e.col%y;(m=a.appendChild(n("span",p(b),"cm-tab"))).setAttribute("role","presentation"),m.setAttribute("cm-text","\t"),e.col+=b}else"\r"==d[0]||"\n"==d[0]?((m=a.appendChild(n("span","\r"==d[0]?"␍":"␤","cm-invalidchar"))).setAttribute("cm-text",d[0]),e.col+=1):((m=e.cm.options.specialCharPlaceholder(d[0])).setAttribute("cm-text",d[0]),gl&&vl<9?a.appendChild(n("span",[m])):a.appendChild(m),e.col+=1);e.map.push(e.pos,e.pos+1,m),e.pos++}}else e.col+=t.length,a=document.createTextNode(u),e.map.push(e.pos,e.pos+t.length,a),gl&&vl<9&&(f=!0),e.pos+=t.length;if(e.trailingSpace=32==u.charCodeAt(t.length-1),r||i||o||f||s){var w=r||"";i&&(w+=i),o&&(w+=o);var x=n("span",[a],w,s);return l&&(x.title=l),e.content.appendChild(x)}e.content.appendChild(a)}}function ct(e,t){if(e.length>1&&!/  /.test(e))return e;for(var r=t,n="",i=0;i<e.length;i++){var o=e.charAt(i);" "!=o||!r||i!=e.length-1&&32!=e.charCodeAt(i+1)||(o=" "),n+=o,r=" "==o}return n}function ft(e,t){return function(r,n,i,o,l,s,a){i=i?i+" cm-force-border":"cm-force-border";for(var u=r.pos,c=u+n.length;;){for(var f=void 0,h=0;h<t.length&&!((f=t[h]).to>u&&f.from<=u);h++);if(f.to>=c)return e(r,n,i,o,l,s,a);e(r,n.slice(0,f.to-u),i,o,null,s,a),o=null,n=n.slice(f.to-u),u=f.to}}}function ht(e,t,r,n){var i=!n&&r.widgetNode;i&&e.map.push(e.pos,e.pos+t,i),!n&&e.cm.display.input.needsContentAttribute&&(i||(i=e.content.appendChild(document.createElement("span"))),i.setAttribute("cm-marker",r.id)),i&&(e.cm.display.input.setUneditable(i),e.content.appendChild(i)),e.pos+=t,e.trailingSpace=!1}function dt(e,t,r){var n=e.markedSpans,i=e.text,o=0;if(n)for(var l,s,a,u,c,f,h,d=i.length,p=0,g=1,v="",m=0;;){if(m==p){a=u=c=f=s="",h=null,m=1/0;for(var y=[],b=void 0,w=0;w<n.length;++w){var x=n[w],C=x.marker;"bookmark"==C.type&&x.from==p&&C.widgetNode?y.push(C):x.from<=p&&(null==x.to||x.to>p||C.collapsed&&x.to==p&&x.from==p)?(null!=x.to&&x.to!=p&&m>x.to&&(m=x.to,u=""),C.className&&(a+=" "+C.className),C.css&&(s=(s?s+";":"")+C.css),C.startStyle&&x.from==p&&(c+=" "+C.startStyle),C.endStyle&&x.to==m&&(b||(b=[])).push(C.endStyle,x.to),C.title&&!f&&(f=C.title),C.collapsed&&(!h||le(h.marker,C)<0)&&(h=x)):x.from>p&&m>x.from&&(m=x.from)}if(b)for(var S=0;S<b.length;S+=2)b[S+1]==m&&(u+=" "+b[S]);if(!h||h.from==p)for(var L=0;L<y.length;++L)ht(t,0,y[L]);if(h&&(h.from||0)==p){if(ht(t,(null==h.to?d+1:h.to)-p,h.marker,null==h.from),null==h.to)return;h.to==p&&(h=!1)}}if(p>=d)break;for(var k=Math.min(d,m);;){if(v){var T=p+v.length;if(!h){var M=T>k?v.slice(0,k-p):v;t.addToken(t,M,l?l+a:a,c,p+M.length==m?u:"",f,s)}if(T>=k){v=v.slice(k-p),p=k;break}p=T,c=""}v=i.slice(o,o=r[g++]),l=lt(r[g++],t.cm.options)}}else for(var N=1;N<r.length;N+=2)t.addToken(t,i.slice(o,o=r[N]),lt(r[N+1],t.cm.options))}function pt(e,t,r){this.line=t,this.rest=de(t),this.size=this.rest?W(g(this.rest))-r+1:1,this.node=this.text=null,this.hidden=ve(e,t)}function gt(e,t,r){for(var n,i=[],o=t;o<r;o=n){var l=new pt(e.doc,M(e.doc,o),o);n=o+l.size,i.push(l)}return i}function vt(e){gs?gs.ops.push(e):e.ownsGroup=gs={ops:[e],delayedCallbacks:[]}}function mt(e){var t=e.delayedCallbacks,r=0;do{for(;r<t.length;r++)t[r].call(null);for(var n=0;n<e.ops.length;n++){var i=e.ops[n];if(i.cursorActivityHandlers)for(;i.cursorActivityCalled<i.cursorActivityHandlers.length;)i.cursorActivityHandlers[i.cursorActivityCalled++].call(null,i.cm)}}while(r<t.length)}function yt(e,t){var r=e.ownsGroup;if(r)try{mt(r)}finally{gs=null,t(r)}}function bt(e,t){var r=Le(e,t);if(r.length){var n,i=Array.prototype.slice.call(arguments,2);gs?n=gs.delayedCallbacks:vs?n=vs:(n=vs=[],setTimeout(wt,0));for(var o=0;o<r.length;++o)!function(e){n.push(function(){return r[e].apply(null,i)})}(o)}}function wt(){var e=vs;vs=null;for(var t=0;t<e.length;++t)e[t]()}function xt(e,t,r,n){for(var i=0;i<t.changes.length;i++){var o=t.changes[i];"text"==o?kt(e,t):"gutter"==o?Mt(e,t,r,n):"class"==o?Tt(e,t):"widget"==o&&Nt(e,t,n)}t.changes=null}function Ct(e){return e.node==e.text&&(e.node=n("div",null,null,"position: relative"),e.text.parentNode&&e.text.parentNode.replaceChild(e.node,e.text),e.node.appendChild(e.text),gl&&vl<8&&(e.node.style.zIndex=2)),e.node}function St(e,t){var r=t.bgClass?t.bgClass+" "+(t.line.bgClass||""):t.line.bgClass;if(r&&(r+=" CodeMirror-linebackground"),t.background)r?t.background.className=r:(t.background.parentNode.removeChild(t.background),t.background=null);else if(r){var i=Ct(t);t.background=i.insertBefore(n("div",null,r),i.firstChild),e.display.input.setUneditable(t.background)}}function Lt(e,t){var r=e.display.externalMeasured;return r&&r.line==t.line?(e.display.externalMeasured=null,t.measure=r.measure,r.built):st(e,t)}function kt(e,t){var r=t.text.className,n=Lt(e,t);t.text==t.node&&(t.node=n.pre),t.text.parentNode.replaceChild(n.pre,t.text),t.text=n.pre,n.bgClass!=t.bgClass||n.textClass!=t.textClass?(t.bgClass=n.bgClass,t.textClass=n.textClass,Tt(e,t)):r&&(t.text.className=r)}function Tt(e,t){St(e,t),t.line.wrapClass?Ct(t).className=t.line.wrapClass:t.node!=t.text&&(t.node.className="");var r=t.textClass?t.textClass+" "+(t.line.textClass||""):t.line.textClass;t.text.className=r||""}function Mt(e,t,r,i){if(t.gutter&&(t.node.removeChild(t.gutter),t.gutter=null),t.gutterBackground&&(t.node.removeChild(t.gutterBackground),t.gutterBackground=null),t.line.gutterClass){var o=Ct(t);t.gutterBackground=n("div",null,"CodeMirror-gutter-background "+t.line.gutterClass,"left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px; width: "+i.gutterTotalWidth+"px"),e.display.input.setUneditable(t.gutterBackground),o.insertBefore(t.gutterBackground,t.text)}var l=t.line.gutterMarkers;if(e.options.lineNumbers||l){var s=Ct(t),a=t.gutter=n("div",null,"CodeMirror-gutter-wrapper","left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px");if(e.display.input.setUneditable(a),s.insertBefore(a,t.text),t.line.gutterClass&&(a.className+=" "+t.line.gutterClass),!e.options.lineNumbers||l&&l["CodeMirror-linenumbers"]||(t.lineNumber=a.appendChild(n("div",F(e.options,r),"CodeMirror-linenumber CodeMirror-gutter-elt","left: "+i.gutterLeft["CodeMirror-linenumbers"]+"px; width: "+e.display.lineNumInnerWidth+"px"))),l)for(var u=0;u<e.options.gutters.length;++u){var c=e.options.gutters[u],f=l.hasOwnProperty(c)&&l[c];f&&a.appendChild(n("div",[f],"CodeMirror-gutter-elt","left: "+i.gutterLeft[c]+"px; width: "+i.gutterWidth[c]+"px"))}}}function Nt(e,t,r){t.alignable&&(t.alignable=null);for(var n=t.node.firstChild,i=void 0;n;n=i)i=n.nextSibling,"CodeMirror-linewidget"==n.className&&t.node.removeChild(n);At(e,t,r)}function Ot(e,t,r,n){var i=Lt(e,t);return t.text=t.node=i.pre,i.bgClass&&(t.bgClass=i.bgClass),i.textClass&&(t.textClass=i.textClass),Tt(e,t),Mt(e,t,r,n),At(e,t,n),t.node}function At(e,t,r){if(Wt(e,t.line,t,r,!0),t.rest)for(var n=0;n<t.rest.length;n++)Wt(e,t.rest[n],t,r,!1)}function Wt(e,t,r,i,o){if(t.widgets)for(var l=Ct(r),s=0,a=t.widgets;s<a.length;++s){var u=a[s],c=n("div",[u.node],"CodeMirror-linewidget");u.handleMouseEvents||c.setAttribute("cm-ignore-events","true"),Dt(u,c,r,i),e.display.input.setUneditable(c),o&&u.above?l.insertBefore(c,r.gutter||r.text):l.appendChild(c),bt(u,"redraw")}}function Dt(e,t,r,n){if(e.noHScroll){(r.alignable||(r.alignable=[])).push(t);var i=n.wrapperWidth;t.style.left=n.fixedPos+"px",e.coverGutter||(i-=n.gutterTotalWidth,t.style.paddingLeft=n.gutterTotalWidth+"px"),t.style.width=i+"px"}e.coverGutter&&(t.style.zIndex=5,t.style.position="relative",e.noHScroll||(t.style.marginLeft=-n.gutterTotalWidth+"px"))}function Ht(e){if(null!=e.height)return e.height;var t=e.doc.cm;if(!t)return 0;if(!o(document.body,e.node)){var i="position: relative;";e.coverGutter&&(i+="margin-left: -"+t.display.gutters.offsetWidth+"px;"),e.noHScroll&&(i+="width: "+t.display.wrapper.clientWidth+"px;"),r(t.display.measure,n("div",[e.node],null,i))}return e.height=e.node.parentNode.offsetHeight}function Ft(e,t){for(var r=Ee(t);r!=e.wrapper;r=r.parentNode)if(!r||1==r.nodeType&&"true"==r.getAttribute("cm-ignore-events")||r.parentNode==e.sizer&&r!=e.mover)return!0}function Et(e){return e.lineSpace.offsetTop}function Pt(e){return e.mover.offsetHeight-e.lineSpace.offsetHeight}function It(e){if(e.cachedPaddingH)return e.cachedPaddingH;var t=r(e.measure,n("pre","x")),i=window.getComputedStyle?window.getComputedStyle(t):t.currentStyle,o={left:parseInt(i.paddingLeft),right:parseInt(i.paddingRight)};return isNaN(o.left)||isNaN(o.right)||(e.cachedPaddingH=o),o}function zt(e){return Rl-e.display.nativeBarWidth}function Rt(e){return e.display.scroller.clientWidth-zt(e)-e.display.barWidth}function Bt(e){return e.display.scroller.clientHeight-zt(e)-e.display.barHeight}function Gt(e,t,r){var n=e.options.lineWrapping,i=n&&Rt(e);if(!t.measure.heights||n&&t.measure.width!=i){var o=t.measure.heights=[];if(n){t.measure.width=i;for(var l=t.text.firstChild.getClientRects(),s=0;s<l.length-1;s++){var a=l[s],u=l[s+1];Math.abs(a.bottom-u.bottom)>2&&o.push((a.bottom+u.top)/2-r.top)}}o.push(r.bottom-r.top)}}function Ut(e,t,r){if(e.line==t)return{map:e.measure.map,cache:e.measure.cache};for(var n=0;n<e.rest.length;n++)if(e.rest[n]==t)return{map:e.measure.maps[n],cache:e.measure.caches[n]};for(var i=0;i<e.rest.length;i++)if(W(e.rest[i])>r)return{map:e.measure.maps[i],cache:e.measure.caches[i],before:!0}}function Vt(e,t){var n=W(t=fe(t)),i=e.display.externalMeasured=new pt(e.doc,t,n);i.lineN=n;var o=i.built=st(e,i);return i.text=o.pre,r(e.display.lineMeasure,o.pre),i}function Kt(e,t,r,n){return Yt(e,Xt(e,t),r,n)}function jt(e,t){if(t>=e.display.viewFrom&&t<e.display.viewTo)return e.display.view[Lr(e,t)];var r=e.display.externalMeasured;return r&&t>=r.lineN&&t<r.lineN+r.size?r:void 0}function Xt(e,t){var r=W(t),n=jt(e,r);n&&!n.text?n=null:n&&n.changes&&(xt(e,n,r,br(e)),e.curOp.forceUpdate=!0),n||(n=Vt(e,t));var i=Ut(n,t,r);return{line:t,view:n,rect:null,map:i.map,cache:i.cache,before:i.before,hasHeights:!1}}function Yt(e,t,r,n,i){t.before&&(r=-1);var o,l=r+(n||"");return t.cache.hasOwnProperty(l)?o=t.cache[l]:(t.rect||(t.rect=t.view.text.getBoundingClientRect()),t.hasHeights||(Gt(e,t.view,t.rect),t.hasHeights=!0),(o=qt(e,t,r,n)).bogus||(t.cache[l]=o)),{left:o.left,right:o.right,top:i?o.rtop:o.top,bottom:i?o.rbottom:o.bottom}}function _t(e,t,r){for(var n,i,o,l,s,a,u=0;u<e.length;u+=3)if(s=e[u],a=e[u+1],t<s?(i=0,o=1,l="left"):t<a?o=(i=t-s)+1:(u==e.length-3||t==a&&e[u+3]>t)&&(i=(o=a-s)-1,t>=a&&(l="right")),null!=i){if(n=e[u+2],s==a&&r==(n.insertLeft?"left":"right")&&(l=r),"left"==r&&0==i)for(;u&&e[u-2]==e[u-3]&&e[u-1].insertLeft;)n=e[2+(u-=3)],l="left";if("right"==r&&i==a-s)for(;u<e.length-3&&e[u+3]==e[u+4]&&!e[u+5].insertLeft;)n=e[(u+=3)+2],l="right";break}return{node:n,start:i,end:o,collapse:l,coverStart:s,coverEnd:a}}function $t(e,t){var r=ms;if("left"==t)for(var n=0;n<e.length&&(r=e[n]).left==r.right;n++);else for(var i=e.length-1;i>=0&&(r=e[i]).left==r.right;i--);return r}function qt(e,t,r,n){var i,o=_t(t.map,r,n),l=o.node,s=o.start,a=o.end,u=o.collapse;if(3==l.nodeType){for(var c=0;c<4;c++){for(;s&&S(t.line.text.charAt(o.coverStart+s));)--s;for(;o.coverStart+a<o.coverEnd&&S(t.line.text.charAt(o.coverStart+a));)++a;if((i=gl&&vl<9&&0==s&&a==o.coverEnd-o.coverStart?l.parentNode.getBoundingClientRect():$t(Wl(l,s,a).getClientRects(),n)).left||i.right||0==s)break;a=s,s-=1,u="right"}gl&&vl<11&&(i=Zt(e.display.measure,i))}else{s>0&&(u=n="right");var f;i=e.options.lineWrapping&&(f=l.getClientRects()).length>1?f["right"==n?f.length-1:0]:l.getBoundingClientRect()}if(gl&&vl<9&&!s&&(!i||!i.left&&!i.right)){var h=l.parentNode.getClientRects()[0];i=h?{left:h.left,right:h.left+yr(e.display),top:h.top,bottom:h.bottom}:ms}for(var d=i.top-t.rect.top,p=i.bottom-t.rect.top,g=(d+p)/2,v=t.view.measure.heights,m=0;m<v.length-1&&!(g<v[m]);m++);var y=m?v[m-1]:0,b=v[m],w={left:("right"==u?i.right:i.left)-t.rect.left,right:("left"==u?i.left:i.right)-t.rect.left,top:y,bottom:b};return i.left||i.right||(w.bogus=!0),e.options.singleCursorHeightPerLine||(w.rtop=d,w.rbottom=p),w}function Zt(e,t){if(!window.screen||null==screen.logicalXDPI||screen.logicalXDPI==screen.deviceXDPI||!Re(e))return t;var r=screen.logicalXDPI/screen.deviceXDPI,n=screen.logicalYDPI/screen.deviceYDPI;return{left:t.left*r,right:t.right*r,top:t.top*n,bottom:t.bottom*n}}function Qt(e){if(e.measure&&(e.measure.cache={},e.measure.heights=null,e.rest))for(var t=0;t<e.rest.length;t++)e.measure.caches[t]={}}function Jt(e){e.display.externalMeasure=null,t(e.display.lineMeasure);for(var r=0;r<e.display.view.length;r++)Qt(e.display.view[r])}function er(e){Jt(e),e.display.cachedCharWidth=e.display.cachedTextHeight=e.display.cachedPaddingH=null,e.options.lineWrapping||(e.display.maxLineChanged=!0),e.display.lineNumChars=null}function tr(){return bl&&kl?-(document.body.getBoundingClientRect().left-parseInt(getComputedStyle(document.body).marginLeft)):window.pageXOffset||(document.documentElement||document.body).scrollLeft}function rr(){return bl&&kl?-(document.body.getBoundingClientRect().top-parseInt(getComputedStyle(document.body).marginTop)):window.pageYOffset||(document.documentElement||document.body).scrollTop}function nr(e){var t=0;if(e.widgets)for(var r=0;r<e.widgets.length;++r)e.widgets[r].above&&(t+=Ht(e.widgets[r]));return t}function ir(e,t,r,n,i){if(!i){var o=nr(t);r.top+=o,r.bottom+=o}if("line"==n)return r;n||(n="local");var l=ye(t);if("local"==n?l+=Et(e.display):l-=e.display.viewOffset,"page"==n||"window"==n){var s=e.display.lineSpace.getBoundingClientRect();l+=s.top+("window"==n?0:rr());var a=s.left+("window"==n?0:tr());r.left+=a,r.right+=a}return r.top+=l,r.bottom+=l,r}function or(e,t,r){if("div"==r)return t;var n=t.left,i=t.top;if("page"==r)n-=tr(),i-=rr();else if("local"==r||!r){var o=e.display.sizer.getBoundingClientRect();n+=o.left,i+=o.top}var l=e.display.lineSpace.getBoundingClientRect();return{left:n-l.left,top:i-l.top}}function lr(e,t,r,n,i){return n||(n=M(e.doc,t.line)),ir(e,n,Kt(e,n,t.ch,i),r)}function sr(e,t,r,n,i,o){function l(t,l){var s=Yt(e,i,t,l?"right":"left",o);return l?s.left=s.right:s.right=s.left,ir(e,n,s,r)}function s(e,t,r){var n=1==a[t].level;return l(r?e-1:e,n!=r)}n=n||M(e.doc,t.line),i||(i=Xt(e,n));var a=Se(n,e.doc.direction),u=t.ch,c=t.sticky;if(u>=n.text.length?(u=n.text.length,c="before"):u<=0&&(u=0,c="after"),!a)return l("before"==c?u-1:u,"before"==c);var f=Ce(a,u,c),h=$l,d=s(u,f,"before"==c);return null!=h&&(d.other=s(u,h,"before"!=c)),d}function ar(e,t){var r=0;t=U(e.doc,t),e.options.lineWrapping||(r=yr(e.display)*t.ch);var n=M(e.doc,t.line),i=ye(n)+Et(e.display);return{left:r,right:r,top:i,bottom:i+n.height}}function ur(e,t,r,n,i){var o=E(e,t,r);return o.xRel=i,n&&(o.outside=!0),o}function cr(e,t,r){var n=e.doc;if((r+=e.display.viewOffset)<0)return ur(n.first,0,null,!0,-1);var i=D(n,r),o=n.first+n.size-1;if(i>o)return ur(n.first+n.size-1,M(n,o).text.length,null,!0,1);t<0&&(t=0);for(var l=M(n,i);;){var s=pr(e,l,i,t,r),a=ue(l),u=a&&a.find(0,!0);if(!a||!(s.ch>u.from.ch||s.ch==u.from.ch&&s.xRel>0))return s;i=W(l=u.to.line)}}function fr(e,t,r,n){n-=nr(t);var i=t.text.length,o=k(function(t){return Yt(e,r,t-1).bottom<=n},i,0);return i=k(function(t){return Yt(e,r,t).top>n},o,i),{begin:o,end:i}}function hr(e,t,r,n){return r||(r=Xt(e,t)),fr(e,t,r,ir(e,t,Yt(e,r,n),"line").top)}function dr(e,t,r,n){return!(e.bottom<=r)&&(e.top>r||(n?e.left:e.right)>t)}function pr(e,t,r,n,i){i-=ye(t);var o=Xt(e,t),l=nr(t),s=0,a=t.text.length,u=!0,c=Se(t,e.doc.direction);if(c){var f=(e.options.lineWrapping?vr:gr)(e,t,r,o,c,n,i);s=(u=1!=f.level)?f.from:f.to-1,a=u?f.to:f.from-1}var h,d,p=null,g=null,v=k(function(t){var r=Yt(e,o,t);return r.top+=l,r.bottom+=l,!!dr(r,n,i,!1)&&(r.top<=i&&r.left<=n&&(p=t,g=r),!0)},s,a),m=!1;if(g){var y=n-g.left<g.right-n,b=y==u;v=p+(b?0:1),d=b?"after":"before",h=y?g.left:g.right}else{u||v!=a&&v!=s||v++,d=0==v?"after":v==t.text.length?"before":Yt(e,o,v-(u?1:0)).bottom+l<=i==u?"after":"before";var w=sr(e,E(r,v,d),"line",t,o);h=w.left,m=i<w.top||i>=w.bottom}return v=L(t.text,v,1),ur(r,v,d,m,n-h)}function gr(e,t,r,n,i,o,l){var s=k(function(s){var a=i[s],u=1!=a.level;return dr(sr(e,E(r,u?a.to:a.from,u?"before":"after"),"line",t,n),o,l,!0)},0,i.length-1),a=i[s];if(s>0){var u=1!=a.level,c=sr(e,E(r,u?a.from:a.to,u?"after":"before"),"line",t,n);dr(c,o,l,!0)&&c.top>l&&(a=i[s-1])}return a}function vr(e,t,r,n,i,o,l){for(var s=fr(e,t,n,l),a=s.begin,u=s.end,c=null,f=null,h=0;h<i.length;h++){var d=i[h];if(!(d.from>=u||d.to<=a)){var p=Yt(e,n,1!=d.level?Math.min(u,d.to)-1:Math.max(a,d.from)).right,g=p<o?o-p+1e9:p-o;(!c||f>g)&&(c=d,f=g)}}return c||(c=i[i.length-1]),c.from<a&&(c={from:a,to:c.to,level:c.level}),c.to>u&&(c={from:c.from,to:u,level:c.level}),c}function mr(e){if(null!=e.cachedTextHeight)return e.cachedTextHeight;if(null==hs){hs=n("pre");for(var i=0;i<49;++i)hs.appendChild(document.createTextNode("x")),hs.appendChild(n("br"));hs.appendChild(document.createTextNode("x"))}r(e.measure,hs);var o=hs.offsetHeight/50;return o>3&&(e.cachedTextHeight=o),t(e.measure),o||1}function yr(e){if(null!=e.cachedCharWidth)return e.cachedCharWidth;var t=n("span","xxxxxxxxxx"),i=n("pre",[t]);r(e.measure,i);var o=t.getBoundingClientRect(),l=(o.right-o.left)/10;return l>2&&(e.cachedCharWidth=l),l||10}function br(e){for(var t=e.display,r={},n={},i=t.gutters.clientLeft,o=t.gutters.firstChild,l=0;o;o=o.nextSibling,++l)r[e.options.gutters[l]]=o.offsetLeft+o.clientLeft+i,n[e.options.gutters[l]]=o.clientWidth;return{fixedPos:wr(t),gutterTotalWidth:t.gutters.offsetWidth,gutterLeft:r,gutterWidth:n,wrapperWidth:t.wrapper.clientWidth}}function wr(e){return e.scroller.getBoundingClientRect().left-e.sizer.getBoundingClientRect().left}function xr(e){var t=mr(e.display),r=e.options.lineWrapping,n=r&&Math.max(5,e.display.scroller.clientWidth/yr(e.display)-3);return function(i){if(ve(e.doc,i))return 0;var o=0;if(i.widgets)for(var l=0;l<i.widgets.length;l++)i.widgets[l].height&&(o+=i.widgets[l].height);return r?o+(Math.ceil(i.text.length/n)||1)*t:o+t}}function Cr(e){var t=e.doc,r=xr(e);t.iter(function(e){var t=r(e);t!=e.height&&A(e,t)})}function Sr(e,t,r,n){var i=e.display;if(!r&&"true"==Ee(t).getAttribute("cm-not-content"))return null;var o,l,s=i.lineSpace.getBoundingClientRect();try{o=t.clientX-s.left,l=t.clientY-s.top}catch(t){return null}var a,u=cr(e,o,l);if(n&&1==u.xRel&&(a=M(e.doc,u.line).text).length==u.ch){var c=f(a,a.length,e.options.tabSize)-a.length;u=E(u.line,Math.max(0,Math.round((o-It(e.display).left)/yr(e.display))-c))}return u}function Lr(e,t){if(t>=e.display.viewTo)return null;if((t-=e.display.viewFrom)<0)return null;for(var r=e.display.view,n=0;n<r.length;n++)if((t-=r[n].size)<0)return n}function kr(e){e.display.input.showSelection(e.display.input.prepareSelection())}function Tr(e,t){void 0===t&&(t=!0);for(var r=e.doc,n={},i=n.cursors=document.createDocumentFragment(),o=n.selection=document.createDocumentFragment(),l=0;l<r.sel.ranges.length;l++)if(t||l!=r.sel.primIndex){var s=r.sel.ranges[l];if(!(s.from().line>=e.display.viewTo||s.to().line<e.display.viewFrom)){var a=s.empty();(a||e.options.showCursorWhenSelecting)&&Mr(e,s.head,i),a||Or(e,s,o)}}return n}function Mr(e,t,r){var i=sr(e,t,"div",null,null,!e.options.singleCursorHeightPerLine),o=r.appendChild(n("div"," ","CodeMirror-cursor"));if(o.style.left=i.left+"px",o.style.top=i.top+"px",o.style.height=Math.max(0,i.bottom-i.top)*e.options.cursorHeight+"px",i.other){var l=r.appendChild(n("div"," ","CodeMirror-cursor CodeMirror-secondarycursor"));l.style.display="",l.style.left=i.other.left+"px",l.style.top=i.other.top+"px",l.style.height=.85*(i.other.bottom-i.other.top)+"px"}}function Nr(e,t){return e.top-t.top||e.left-t.left}function Or(e,t,r){function i(e,t,r,i){t<0&&(t=0),t=Math.round(t),i=Math.round(i),a.appendChild(n("div",null,"CodeMirror-selected","position: absolute; left: "+e+"px;\n                             top: "+t+"px; width: "+(null==r?f-e:r)+"px;\n                             height: "+(i-t)+"px"))}function o(t,r,n){function o(r,n){return lr(e,E(t,r),"div",u,n)}var l,a,u=M(s,t),h=u.text.length,d=Se(u,s.direction);return xe(d,r||0,null==n?h:n,function(t,s,p,g){var v=o(t,"ltr"==p?"left":"right"),m=o(s-1,"ltr"==p?"right":"left");if("ltr"==p){var y=null==r&&0==t?c:v.left,b=null==n&&s==h?f:m.right;m.top-v.top<=3?i(y,m.top,b-y,m.bottom):(i(y,v.top,null,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top),i(c,m.top,m.right,m.bottom))}else if(t<s){var w=null==r&&0==t?f:v.right,x=null==n&&s==h?c:m.left;if(m.top-v.top<=3)i(x,m.top,w-x,m.bottom);else{var C=c;if(g){var S=hr(e,u,null,t).end;C=o(S-(/\s/.test(u.text.charAt(S-1))?2:1),"left").left}i(C,v.top,w-C,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top);var L=null;d.length,L=o(hr(e,u,null,s).begin,"right").right-x,i(x,m.top,L,m.bottom)}}(!l||Nr(v,l)<0)&&(l=v),Nr(m,l)<0&&(l=m),(!a||Nr(v,a)<0)&&(a=v),Nr(m,a)<0&&(a=m)}),{start:l,end:a}}var l=e.display,s=e.doc,a=document.createDocumentFragment(),u=It(e.display),c=u.left,f=Math.max(l.sizerWidth,Rt(e)-l.sizer.offsetLeft)-u.right,h=t.from(),d=t.to();if(h.line==d.line)o(h.line,h.ch,d.ch);else{var p=M(s,h.line),g=M(s,d.line),v=fe(p)==fe(g),m=o(h.line,h.ch,v?p.text.length+1:null).end,y=o(d.line,v?0:null,d.ch).start;v&&(m.top<y.top-2?(i(m.right,m.top,null,m.bottom),i(c,y.top,y.left,y.bottom)):i(m.right,m.top,y.left-m.right,m.bottom)),m.bottom<y.top&&i(c,m.bottom,null,y.top)}r.appendChild(a)}function Ar(e){if(e.state.focused){var t=e.display;clearInterval(t.blinker);var r=!0;t.cursorDiv.style.visibility="",e.options.cursorBlinkRate>0?t.blinker=setInterval(function(){return t.cursorDiv.style.visibility=(r=!r)?"":"hidden"},e.options.cursorBlinkRate):e.options.cursorBlinkRate<0&&(t.cursorDiv.style.visibility="hidden")}}function Wr(e){e.state.focused||(e.display.input.focus(),Hr(e))}function Dr(e){e.state.delayingBlurEvent=!0,setTimeout(function(){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1,Fr(e))},100)}function Hr(e,t){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1),"nocursor"!=e.options.readOnly&&(e.state.focused||(Te(e,"focus",e,t),e.state.focused=!0,s(e.display.wrapper,"CodeMirror-focused"),e.curOp||e.display.selForContextMenu==e.doc.sel||(e.display.input.reset(),ml&&setTimeout(function(){return e.display.input.reset(!0)},20)),e.display.input.receivedFocus()),Ar(e))}function Fr(e,t){e.state.delayingBlurEvent||(e.state.focused&&(Te(e,"blur",e,t),e.state.focused=!1,Fl(e.display.wrapper,"CodeMirror-focused")),clearInterval(e.display.blinker),setTimeout(function(){e.state.focused||(e.display.shift=!1)},150))}function Er(e){for(var t=e.display,r=t.lineDiv.offsetTop,n=0;n<t.view.length;n++){var i=t.view[n],o=void 0;if(!i.hidden){if(gl&&vl<8){var l=i.node.offsetTop+i.node.offsetHeight;o=l-r,r=l}else{var s=i.node.getBoundingClientRect();o=s.bottom-s.top}var a=i.line.height-o;if(o<2&&(o=mr(t)),(a>.005||a<-.005)&&(A(i.line,o),Pr(i.line),i.rest))for(var u=0;u<i.rest.length;u++)Pr(i.rest[u])}}}function Pr(e){if(e.widgets)for(var t=0;t<e.widgets.length;++t)e.widgets[t].height=e.widgets[t].node.parentNode.offsetHeight}function Ir(e,t,r){var n=r&&null!=r.top?Math.max(0,r.top):e.scroller.scrollTop;n=Math.floor(n-Et(e));var i=r&&null!=r.bottom?r.bottom:n+e.wrapper.clientHeight,o=D(t,n),l=D(t,i);if(r&&r.ensure){var s=r.ensure.from.line,a=r.ensure.to.line;s<o?(o=s,l=D(t,ye(M(t,s))+e.wrapper.clientHeight)):Math.min(a,t.lastLine())>=l&&(o=D(t,ye(M(t,a))-e.wrapper.clientHeight),l=a)}return{from:o,to:Math.max(l,o+1)}}function zr(e){var t=e.display,r=t.view;if(t.alignWidgets||t.gutters.firstChild&&e.options.fixedGutter){for(var n=wr(t)-t.scroller.scrollLeft+e.doc.scrollLeft,i=t.gutters.offsetWidth,o=n+"px",l=0;l<r.length;l++)if(!r[l].hidden){e.options.fixedGutter&&(r[l].gutter&&(r[l].gutter.style.left=o),r[l].gutterBackground&&(r[l].gutterBackground.style.left=o));var s=r[l].alignable;if(s)for(var a=0;a<s.length;a++)s[a].style.left=o}e.options.fixedGutter&&(t.gutters.style.left=n+i+"px")}}function Rr(e){if(!e.options.lineNumbers)return!1;var t=e.doc,r=F(e.options,t.first+t.size-1),i=e.display;if(r.length!=i.lineNumChars){var o=i.measure.appendChild(n("div",[n("div",r)],"CodeMirror-linenumber CodeMirror-gutter-elt")),l=o.firstChild.offsetWidth,s=o.offsetWidth-l;return i.lineGutter.style.width="",i.lineNumInnerWidth=Math.max(l,i.lineGutter.offsetWidth-s)+1,i.lineNumWidth=i.lineNumInnerWidth+s,i.lineNumChars=i.lineNumInnerWidth?r.length:-1,i.lineGutter.style.width=i.lineNumWidth+"px",Wn(e),!0}return!1}function Br(e,t){if(!Me(e,"scrollCursorIntoView")){var r=e.display,i=r.sizer.getBoundingClientRect(),o=null;if(t.top+i.top<0?o=!0:t.bottom+i.top>(window.innerHeight||document.documentElement.clientHeight)&&(o=!1),null!=o&&!Sl){var l=n("div","​",null,"position: absolute;\n                         top: "+(t.top-r.viewOffset-Et(e.display))+"px;\n                         height: "+(t.bottom-t.top+zt(e)+r.barHeight)+"px;\n                         left: "+t.left+"px; width: "+Math.max(2,t.right-t.left)+"px;");e.display.lineSpace.appendChild(l),l.scrollIntoView(o),e.display.lineSpace.removeChild(l)}}}function Gr(e,t,r,n){null==n&&(n=0);var i;e.options.lineWrapping||t!=r||(r="before"==(t=t.ch?E(t.line,"before"==t.sticky?t.ch-1:t.ch,"after"):t).sticky?E(t.line,t.ch+1,"before"):t);for(var o=0;o<5;o++){var l=!1,s=sr(e,t),a=r&&r!=t?sr(e,r):s,u=Vr(e,i={left:Math.min(s.left,a.left),top:Math.min(s.top,a.top)-n,right:Math.max(s.left,a.left),bottom:Math.max(s.bottom,a.bottom)+n}),c=e.doc.scrollTop,f=e.doc.scrollLeft;if(null!=u.scrollTop&&(qr(e,u.scrollTop),Math.abs(e.doc.scrollTop-c)>1&&(l=!0)),null!=u.scrollLeft&&(Qr(e,u.scrollLeft),Math.abs(e.doc.scrollLeft-f)>1&&(l=!0)),!l)break}return i}function Ur(e,t){var r=Vr(e,t);null!=r.scrollTop&&qr(e,r.scrollTop),null!=r.scrollLeft&&Qr(e,r.scrollLeft)}function Vr(e,t){var r=e.display,n=mr(e.display);t.top<0&&(t.top=0);var i=e.curOp&&null!=e.curOp.scrollTop?e.curOp.scrollTop:r.scroller.scrollTop,o=Bt(e),l={};t.bottom-t.top>o&&(t.bottom=t.top+o);var s=e.doc.height+Pt(r),a=t.top<n,u=t.bottom>s-n;if(t.top<i)l.scrollTop=a?0:t.top;else if(t.bottom>i+o){var c=Math.min(t.top,(u?s:t.bottom)-o);c!=i&&(l.scrollTop=c)}var f=e.curOp&&null!=e.curOp.scrollLeft?e.curOp.scrollLeft:r.scroller.scrollLeft,h=Rt(e)-(e.options.fixedGutter?r.gutters.offsetWidth:0),d=t.right-t.left>h;return d&&(t.right=t.left+h),t.left<10?l.scrollLeft=0:t.left<f?l.scrollLeft=Math.max(0,t.left-(d?0:10)):t.right>h+f-3&&(l.scrollLeft=t.right+(d?0:10)-h),l}function Kr(e,t){null!=t&&(_r(e),e.curOp.scrollTop=(null==e.curOp.scrollTop?e.doc.scrollTop:e.curOp.scrollTop)+t)}function jr(e){_r(e);var t=e.getCursor();e.curOp.scrollToPos={from:t,to:t,margin:e.options.cursorScrollMargin}}function Xr(e,t,r){null==t&&null==r||_r(e),null!=t&&(e.curOp.scrollLeft=t),null!=r&&(e.curOp.scrollTop=r)}function Yr(e,t){_r(e),e.curOp.scrollToPos=t}function _r(e){var t=e.curOp.scrollToPos;t&&(e.curOp.scrollToPos=null,$r(e,ar(e,t.from),ar(e,t.to),t.margin))}function $r(e,t,r,n){var i=Vr(e,{left:Math.min(t.left,r.left),top:Math.min(t.top,r.top)-n,right:Math.max(t.right,r.right),bottom:Math.max(t.bottom,r.bottom)+n});Xr(e,i.scrollLeft,i.scrollTop)}function qr(e,t){Math.abs(e.doc.scrollTop-t)<2||(fl||On(e,{top:t}),Zr(e,t,!0),fl&&On(e),Cn(e,100))}function Zr(e,t,r){t=Math.min(e.display.scroller.scrollHeight-e.display.scroller.clientHeight,t),(e.display.scroller.scrollTop!=t||r)&&(e.doc.scrollTop=t,e.display.scrollbars.setScrollTop(t),e.display.scroller.scrollTop!=t&&(e.display.scroller.scrollTop=t))}function Qr(e,t,r,n){t=Math.min(t,e.display.scroller.scrollWidth-e.display.scroller.clientWidth),(r?t==e.doc.scrollLeft:Math.abs(e.doc.scrollLeft-t)<2)&&!n||(e.doc.scrollLeft=t,zr(e),e.display.scroller.scrollLeft!=t&&(e.display.scroller.scrollLeft=t),e.display.scrollbars.setScrollLeft(t))}function Jr(e){var t=e.display,r=t.gutters.offsetWidth,n=Math.round(e.doc.height+Pt(e.display));return{clientHeight:t.scroller.clientHeight,viewHeight:t.wrapper.clientHeight,scrollWidth:t.scroller.scrollWidth,clientWidth:t.scroller.clientWidth,viewWidth:t.wrapper.clientWidth,barLeft:e.options.fixedGutter?r:0,docHeight:n,scrollHeight:n+zt(e)+t.barHeight,nativeBarWidth:t.nativeBarWidth,gutterWidth:r}}function en(e,t){t||(t=Jr(e));var r=e.display.barWidth,n=e.display.barHeight;tn(e,t);for(var i=0;i<4&&r!=e.display.barWidth||n!=e.display.barHeight;i++)r!=e.display.barWidth&&e.options.lineWrapping&&Er(e),tn(e,Jr(e)),r=e.display.barWidth,n=e.display.barHeight}function tn(e,t){var r=e.display,n=r.scrollbars.update(t);r.sizer.style.paddingRight=(r.barWidth=n.right)+"px",r.sizer.style.paddingBottom=(r.barHeight=n.bottom)+"px",r.heightForcer.style.borderBottom=n.bottom+"px solid transparent",n.right&&n.bottom?(r.scrollbarFiller.style.display="block",r.scrollbarFiller.style.height=n.bottom+"px",r.scrollbarFiller.style.width=n.right+"px"):r.scrollbarFiller.style.display="",n.bottom&&e.options.coverGutterNextToScrollbar&&e.options.fixedGutter?(r.gutterFiller.style.display="block",r.gutterFiller.style.height=n.bottom+"px",r.gutterFiller.style.width=t.gutterWidth+"px"):r.gutterFiller.style.display=""}function rn(e){e.display.scrollbars&&(e.display.scrollbars.clear(),e.display.scrollbars.addClass&&Fl(e.display.wrapper,e.display.scrollbars.addClass)),e.display.scrollbars=new ws[e.options.scrollbarStyle](function(t){e.display.wrapper.insertBefore(t,e.display.scrollbarFiller),Ql(t,"mousedown",function(){e.state.focused&&setTimeout(function(){return e.display.input.focus()},0)}),t.setAttribute("cm-not-content","true")},function(t,r){"horizontal"==r?Qr(e,t):qr(e,t)},e),e.display.scrollbars.addClass&&s(e.display.wrapper,e.display.scrollbars.addClass)}function nn(e){e.curOp={cm:e,viewChanged:!1,startHeight:e.doc.height,forceUpdate:!1,updateInput:null,typing:!1,changeObjs:null,cursorActivityHandlers:null,cursorActivityCalled:0,selectionChanged:!1,updateMaxLine:!1,scrollLeft:null,scrollTop:null,scrollToPos:null,focus:!1,id:++xs},vt(e.curOp)}function on(e){yt(e.curOp,function(e){for(var t=0;t<e.ops.length;t++)e.ops[t].cm.curOp=null;ln(e)})}function ln(e){for(var t=e.ops,r=0;r<t.length;r++)sn(t[r]);for(var n=0;n<t.length;n++)an(t[n]);for(var i=0;i<t.length;i++)un(t[i]);for(var o=0;o<t.length;o++)cn(t[o]);for(var l=0;l<t.length;l++)fn(t[l])}function sn(e){var t=e.cm,r=t.display;Ln(t),e.updateMaxLine&&we(t),e.mustUpdate=e.viewChanged||e.forceUpdate||null!=e.scrollTop||e.scrollToPos&&(e.scrollToPos.from.line<r.viewFrom||e.scrollToPos.to.line>=r.viewTo)||r.maxLineChanged&&t.options.lineWrapping,e.update=e.mustUpdate&&new Cs(t,e.mustUpdate&&{top:e.scrollTop,ensure:e.scrollToPos},e.forceUpdate)}function an(e){e.updatedDisplay=e.mustUpdate&&Mn(e.cm,e.update)}function un(e){var t=e.cm,r=t.display;e.updatedDisplay&&Er(t),e.barMeasure=Jr(t),r.maxLineChanged&&!t.options.lineWrapping&&(e.adjustWidthTo=Kt(t,r.maxLine,r.maxLine.text.length).left+3,t.display.sizerWidth=e.adjustWidthTo,e.barMeasure.scrollWidth=Math.max(r.scroller.clientWidth,r.sizer.offsetLeft+e.adjustWidthTo+zt(t)+t.display.barWidth),e.maxScrollLeft=Math.max(0,r.sizer.offsetLeft+e.adjustWidthTo-Rt(t))),(e.updatedDisplay||e.selectionChanged)&&(e.preparedSelection=r.input.prepareSelection())}function cn(e){var t=e.cm;null!=e.adjustWidthTo&&(t.display.sizer.style.minWidth=e.adjustWidthTo+"px",e.maxScrollLeft<t.doc.scrollLeft&&Qr(t,Math.min(t.display.scroller.scrollLeft,e.maxScrollLeft),!0),t.display.maxLineChanged=!1);var r=e.focus&&e.focus==l();e.preparedSelection&&t.display.input.showSelection(e.preparedSelection,r),(e.updatedDisplay||e.startHeight!=t.doc.height)&&en(t,e.barMeasure),e.updatedDisplay&&Dn(t,e.barMeasure),e.selectionChanged&&Ar(t),t.state.focused&&e.updateInput&&t.display.input.reset(e.typing),r&&Wr(e.cm)}function fn(e){var t=e.cm,r=t.display,n=t.doc;e.updatedDisplay&&Nn(t,e.update),null==r.wheelStartX||null==e.scrollTop&&null==e.scrollLeft&&!e.scrollToPos||(r.wheelStartX=r.wheelStartY=null),null!=e.scrollTop&&Zr(t,e.scrollTop,e.forceScroll),null!=e.scrollLeft&&Qr(t,e.scrollLeft,!0,!0),e.scrollToPos&&Br(t,Gr(t,U(n,e.scrollToPos.from),U(n,e.scrollToPos.to),e.scrollToPos.margin));var i=e.maybeHiddenMarkers,o=e.maybeUnhiddenMarkers;if(i)for(var l=0;l<i.length;++l)i[l].lines.length||Te(i[l],"hide");if(o)for(var s=0;s<o.length;++s)o[s].lines.length&&Te(o[s],"unhide");r.wrapper.offsetHeight&&(n.scrollTop=t.display.scroller.scrollTop),e.changeObjs&&Te(t,"changes",t,e.changeObjs),e.update&&e.update.finish()}function hn(e,t){if(e.curOp)return t();nn(e);try{return t()}finally{on(e)}}function dn(e,t){return function(){if(e.curOp)return t.apply(e,arguments);nn(e);try{return t.apply(e,arguments)}finally{on(e)}}}function pn(e){return function(){if(this.curOp)return e.apply(this,arguments);nn(this);try{return e.apply(this,arguments)}finally{on(this)}}}function gn(e){return function(){var t=this.cm;if(!t||t.curOp)return e.apply(this,arguments);nn(t);try{return e.apply(this,arguments)}finally{on(t)}}}function vn(e,t,r,n){null==t&&(t=e.doc.first),null==r&&(r=e.doc.first+e.doc.size),n||(n=0);var i=e.display;if(n&&r<i.viewTo&&(null==i.updateLineNumbers||i.updateLineNumbers>t)&&(i.updateLineNumbers=t),e.curOp.viewChanged=!0,t>=i.viewTo)_l&&pe(e.doc,t)<i.viewTo&&yn(e);else if(r<=i.viewFrom)_l&&ge(e.doc,r+n)>i.viewFrom?yn(e):(i.viewFrom+=n,i.viewTo+=n);else if(t<=i.viewFrom&&r>=i.viewTo)yn(e);else if(t<=i.viewFrom){var o=bn(e,r,r+n,1);o?(i.view=i.view.slice(o.index),i.viewFrom=o.lineN,i.viewTo+=n):yn(e)}else if(r>=i.viewTo){var l=bn(e,t,t,-1);l?(i.view=i.view.slice(0,l.index),i.viewTo=l.lineN):yn(e)}else{var s=bn(e,t,t,-1),a=bn(e,r,r+n,1);s&&a?(i.view=i.view.slice(0,s.index).concat(gt(e,s.lineN,a.lineN)).concat(i.view.slice(a.index)),i.viewTo+=n):yn(e)}var u=i.externalMeasured;u&&(r<u.lineN?u.lineN+=n:t<u.lineN+u.size&&(i.externalMeasured=null))}function mn(e,t,r){e.curOp.viewChanged=!0;var n=e.display,i=e.display.externalMeasured;if(i&&t>=i.lineN&&t<i.lineN+i.size&&(n.externalMeasured=null),!(t<n.viewFrom||t>=n.viewTo)){var o=n.view[Lr(e,t)];if(null!=o.node){var l=o.changes||(o.changes=[]);-1==h(l,r)&&l.push(r)}}}function yn(e){e.display.viewFrom=e.display.viewTo=e.doc.first,e.display.view=[],e.display.viewOffset=0}function bn(e,t,r,n){var i,o=Lr(e,t),l=e.display.view;if(!_l||r==e.doc.first+e.doc.size)return{index:o,lineN:r};for(var s=e.display.viewFrom,a=0;a<o;a++)s+=l[a].size;if(s!=t){if(n>0){if(o==l.length-1)return null;i=s+l[o].size-t,o++}else i=s-t;t+=i,r+=i}for(;pe(e.doc,r)!=r;){if(o==(n<0?0:l.length-1))return null;r+=n*l[o-(n<0?1:0)].size,o+=n}return{index:o,lineN:r}}function wn(e,t,r){var n=e.display;0==n.view.length||t>=n.viewTo||r<=n.viewFrom?(n.view=gt(e,t,r),n.viewFrom=t):(n.viewFrom>t?n.view=gt(e,t,n.viewFrom).concat(n.view):n.viewFrom<t&&(n.view=n.view.slice(Lr(e,t))),n.viewFrom=t,n.viewTo<r?n.view=n.view.concat(gt(e,n.viewTo,r)):n.viewTo>r&&(n.view=n.view.slice(0,Lr(e,r)))),n.viewTo=r}function xn(e){for(var t=e.display.view,r=0,n=0;n<t.length;n++){var i=t[n];i.hidden||i.node&&!i.changes||++r}return r}function Cn(e,t){e.doc.highlightFrontier<e.display.viewTo&&e.state.highlight.set(t,u(Sn,e))}function Sn(e){var t=e.doc;if(!(t.highlightFrontier>=e.display.viewTo)){var r=+new Date+e.options.workTime,n=$e(e,t.highlightFrontier),i=[];t.iter(n.line,Math.min(t.first+t.size,e.display.viewTo+500),function(o){if(n.line>=e.display.viewFrom){var l=o.styles,s=o.text.length>e.options.maxHighlightLength?Ke(t.mode,n.state):null,a=Ye(e,o,n,!0);s&&(n.state=s),o.styles=a.styles;var u=o.styleClasses,c=a.classes;c?o.styleClasses=c:u&&(o.styleClasses=null);for(var f=!l||l.length!=o.styles.length||u!=c&&(!u||!c||u.bgClass!=c.bgClass||u.textClass!=c.textClass),h=0;!f&&h<l.length;++h)f=l[h]!=o.styles[h];f&&i.push(n.line),o.stateAfter=n.save(),n.nextLine()}else o.text.length<=e.options.maxHighlightLength&&qe(e,o.text,n),o.stateAfter=n.line%5==0?n.save():null,n.nextLine();if(+new Date>r)return Cn(e,e.options.workDelay),!0}),t.highlightFrontier=n.line,t.modeFrontier=Math.max(t.modeFrontier,n.line),i.length&&hn(e,function(){for(var t=0;t<i.length;t++)mn(e,i[t],"text")})}}function Ln(e){var t=e.display;!t.scrollbarsClipped&&t.scroller.offsetWidth&&(t.nativeBarWidth=t.scroller.offsetWidth-t.scroller.clientWidth,t.heightForcer.style.height=zt(e)+"px",t.sizer.style.marginBottom=-t.nativeBarWidth+"px",t.sizer.style.borderRightWidth=zt(e)+"px",t.scrollbarsClipped=!0)}function kn(e){if(e.hasFocus())return null;var t=l();if(!t||!o(e.display.lineDiv,t))return null;var r={activeElt:t};if(window.getSelection){var n=window.getSelection();n.anchorNode&&n.extend&&o(e.display.lineDiv,n.anchorNode)&&(r.anchorNode=n.anchorNode,r.anchorOffset=n.anchorOffset,r.focusNode=n.focusNode,r.focusOffset=n.focusOffset)}return r}function Tn(e){if(e&&e.activeElt&&e.activeElt!=l()&&(e.activeElt.focus(),e.anchorNode&&o(document.body,e.anchorNode)&&o(document.body,e.focusNode))){var t=window.getSelection(),r=document.createRange();r.setEnd(e.anchorNode,e.anchorOffset),r.collapse(!1),t.removeAllRanges(),t.addRange(r),t.extend(e.focusNode,e.focusOffset)}}function Mn(e,r){var n=e.display,i=e.doc;if(r.editorIsHidden)return yn(e),!1;if(!r.force&&r.visible.from>=n.viewFrom&&r.visible.to<=n.viewTo&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo)&&n.renderedView==n.view&&0==xn(e))return!1;Rr(e)&&(yn(e),r.dims=br(e));var o=i.first+i.size,l=Math.max(r.visible.from-e.options.viewportMargin,i.first),s=Math.min(o,r.visible.to+e.options.viewportMargin);n.viewFrom<l&&l-n.viewFrom<20&&(l=Math.max(i.first,n.viewFrom)),n.viewTo>s&&n.viewTo-s<20&&(s=Math.min(o,n.viewTo)),_l&&(l=pe(e.doc,l),s=ge(e.doc,s));var a=l!=n.viewFrom||s!=n.viewTo||n.lastWrapHeight!=r.wrapperHeight||n.lastWrapWidth!=r.wrapperWidth;wn(e,l,s),n.viewOffset=ye(M(e.doc,n.viewFrom)),e.display.mover.style.top=n.viewOffset+"px";var u=xn(e);if(!a&&0==u&&!r.force&&n.renderedView==n.view&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo))return!1;var c=kn(e);return u>4&&(n.lineDiv.style.display="none"),An(e,n.updateLineNumbers,r.dims),u>4&&(n.lineDiv.style.display=""),n.renderedView=n.view,Tn(c),t(n.cursorDiv),t(n.selectionDiv),n.gutters.style.height=n.sizer.style.minHeight=0,a&&(n.lastWrapHeight=r.wrapperHeight,n.lastWrapWidth=r.wrapperWidth,Cn(e,400)),n.updateLineNumbers=null,!0}function Nn(e,t){for(var r=t.viewport,n=!0;(n&&e.options.lineWrapping&&t.oldDisplayWidth!=Rt(e)||(r&&null!=r.top&&(r={top:Math.min(e.doc.height+Pt(e.display)-Bt(e),r.top)}),t.visible=Ir(e.display,e.doc,r),!(t.visible.from>=e.display.viewFrom&&t.visible.to<=e.display.viewTo)))&&Mn(e,t);n=!1){Er(e);var i=Jr(e);kr(e),en(e,i),Dn(e,i),t.force=!1}t.signal(e,"update",e),e.display.viewFrom==e.display.reportedViewFrom&&e.display.viewTo==e.display.reportedViewTo||(t.signal(e,"viewportChange",e,e.display.viewFrom,e.display.viewTo),e.display.reportedViewFrom=e.display.viewFrom,e.display.reportedViewTo=e.display.viewTo)}function On(e,t){var r=new Cs(e,t);if(Mn(e,r)){Er(e),Nn(e,r);var n=Jr(e);kr(e),en(e,n),Dn(e,n),r.finish()}}function An(e,r,n){function i(t){var r=t.nextSibling;return ml&&Ml&&e.display.currentWheelTarget==t?t.style.display="none":t.parentNode.removeChild(t),r}for(var o=e.display,l=e.options.lineNumbers,s=o.lineDiv,a=s.firstChild,u=o.view,c=o.viewFrom,f=0;f<u.length;f++){var d=u[f];if(d.hidden);else if(d.node&&d.node.parentNode==s){for(;a!=d.node;)a=i(a);var p=l&&null!=r&&r<=c&&d.lineNumber;d.changes&&(h(d.changes,"gutter")>-1&&(p=!1),xt(e,d,c,n)),p&&(t(d.lineNumber),d.lineNumber.appendChild(document.createTextNode(F(e.options,c)))),a=d.node.nextSibling}else{var g=Ot(e,d,c,n);s.insertBefore(g,a)}c+=d.size}for(;a;)a=i(a)}function Wn(e){var t=e.display.gutters.offsetWidth;e.display.sizer.style.marginLeft=t+"px"}function Dn(e,t){e.display.sizer.style.minHeight=t.docHeight+"px",e.display.heightForcer.style.top=t.docHeight+"px",e.display.gutters.style.height=t.docHeight+e.display.barHeight+zt(e)+"px"}function Hn(e){var r=e.display.gutters,i=e.options.gutters;t(r);for(var o=0;o<i.length;++o){var l=i[o],s=r.appendChild(n("div",null,"CodeMirror-gutter "+l));"CodeMirror-linenumbers"==l&&(e.display.lineGutter=s,s.style.width=(e.display.lineNumWidth||1)+"px")}r.style.display=o?"":"none",Wn(e)}function Fn(e){var t=h(e.gutters,"CodeMirror-linenumbers");-1==t&&e.lineNumbers?e.gutters=e.gutters.concat(["CodeMirror-linenumbers"]):t>-1&&!e.lineNumbers&&(e.gutters=e.gutters.slice(0),e.gutters.splice(t,1))}function En(e){var t=e.wheelDeltaX,r=e.wheelDeltaY;return null==t&&e.detail&&e.axis==e.HORIZONTAL_AXIS&&(t=e.detail),null==r&&e.detail&&e.axis==e.VERTICAL_AXIS?r=e.detail:null==r&&(r=e.wheelDelta),{x:t,y:r}}function Pn(e){var t=En(e);return t.x*=Ls,t.y*=Ls,t}function In(e,t){var r=En(t),n=r.x,i=r.y,o=e.display,l=o.scroller,s=l.scrollWidth>l.clientWidth,a=l.scrollHeight>l.clientHeight;if(n&&s||i&&a){if(i&&Ml&&ml)e:for(var u=t.target,c=o.view;u!=l;u=u.parentNode)for(var f=0;f<c.length;f++)if(c[f].node==u){e.display.currentWheelTarget=u;break e}if(n&&!fl&&!wl&&null!=Ls)return i&&a&&qr(e,Math.max(0,l.scrollTop+i*Ls)),Qr(e,Math.max(0,l.scrollLeft+n*Ls)),(!i||i&&a)&&We(t),void(o.wheelStartX=null);if(i&&null!=Ls){var h=i*Ls,d=e.doc.scrollTop,p=d+o.wrapper.clientHeight;h<0?d=Math.max(0,d+h-50):p=Math.min(e.doc.height,p+h+50),On(e,{top:d,bottom:p})}Ss<20&&(null==o.wheelStartX?(o.wheelStartX=l.scrollLeft,o.wheelStartY=l.scrollTop,o.wheelDX=n,o.wheelDY=i,setTimeout(function(){if(null!=o.wheelStartX){var e=l.scrollLeft-o.wheelStartX,t=l.scrollTop-o.wheelStartY,r=t&&o.wheelDY&&t/o.wheelDY||e&&o.wheelDX&&e/o.wheelDX;o.wheelStartX=o.wheelStartY=null,r&&(Ls=(Ls*Ss+r)/(Ss+1),++Ss)}},200)):(o.wheelDX+=n,o.wheelDY+=i))}}function zn(e,t){var r=e[t];e.sort(function(e,t){return P(e.from(),t.from())}),t=h(e,r);for(var n=1;n<e.length;n++){var i=e[n],o=e[n-1];if(P(o.to(),i.from())>=0){var l=B(o.from(),i.from()),s=R(o.to(),i.to()),a=o.empty()?i.from()==i.head:o.from()==o.head;n<=t&&--t,e.splice(--n,2,new Ts(a?s:l,a?l:s))}}return new ks(e,t)}function Rn(e,t){return new ks([new Ts(e,t||e)],0)}function Bn(e){return e.text?E(e.from.line+e.text.length-1,g(e.text).length+(1==e.text.length?e.from.ch:0)):e.to}function Gn(e,t){if(P(e,t.from)<0)return e;if(P(e,t.to)<=0)return Bn(t);var r=e.line+t.text.length-(t.to.line-t.from.line)-1,n=e.ch;return e.line==t.to.line&&(n+=Bn(t).ch-t.to.ch),E(r,n)}function Un(e,t){for(var r=[],n=0;n<e.sel.ranges.length;n++){var i=e.sel.ranges[n];r.push(new Ts(Gn(i.anchor,t),Gn(i.head,t)))}return zn(r,e.sel.primIndex)}function Vn(e,t,r){return e.line==t.line?E(r.line,e.ch-t.ch+r.ch):E(r.line+(e.line-t.line),e.ch)}function Kn(e,t,r){for(var n=[],i=E(e.first,0),o=i,l=0;l<t.length;l++){var s=t[l],a=Vn(s.from,i,o),u=Vn(Bn(s),i,o);if(i=s.to,o=u,"around"==r){var c=e.sel.ranges[l],f=P(c.head,c.anchor)<0;n[l]=new Ts(f?u:a,f?a:u)}else n[l]=new Ts(a,a)}return new ks(n,e.sel.primIndex)}function jn(e){e.doc.mode=Ue(e.options,e.doc.modeOption),Xn(e)}function Xn(e){e.doc.iter(function(e){e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null)}),e.doc.modeFrontier=e.doc.highlightFrontier=e.doc.first,Cn(e,100),e.state.modeGen++,e.curOp&&vn(e)}function Yn(e,t){return 0==t.from.ch&&0==t.to.ch&&""==g(t.text)&&(!e.cm||e.cm.options.wholeLineUpdateBefore)}function _n(e,t,r,n){function i(e){return r?r[e]:null}function o(e,r,i){it(e,r,i,n),bt(e,"change",e,t)}function l(e,t){for(var r=[],o=e;o<t;++o)r.push(new fs(u[o],i(o),n));return r}var s=t.from,a=t.to,u=t.text,c=M(e,s.line),f=M(e,a.line),h=g(u),d=i(u.length-1),p=a.line-s.line;if(t.full)e.insert(0,l(0,u.length)),e.remove(u.length,e.size-u.length);else if(Yn(e,t)){var v=l(0,u.length-1);o(f,f.text,d),p&&e.remove(s.line,p),v.length&&e.insert(s.line,v)}else if(c==f)if(1==u.length)o(c,c.text.slice(0,s.ch)+h+c.text.slice(a.ch),d);else{var m=l(1,u.length-1);m.push(new fs(h+c.text.slice(a.ch),d,n)),o(c,c.text.slice(0,s.ch)+u[0],i(0)),e.insert(s.line+1,m)}else if(1==u.length)o(c,c.text.slice(0,s.ch)+u[0]+f.text.slice(a.ch),i(0)),e.remove(s.line+1,p);else{o(c,c.text.slice(0,s.ch)+u[0],i(0)),o(f,h+f.text.slice(a.ch),d);var y=l(1,u.length-1);p>1&&e.remove(s.line+1,p-1),e.insert(s.line+1,y)}bt(e,"change",e,t)}function $n(e,t,r){function n(e,i,o){if(e.linked)for(var l=0;l<e.linked.length;++l){var s=e.linked[l];if(s.doc!=i){var a=o&&s.sharedHist;r&&!a||(t(s.doc,a),n(s.doc,e,a))}}}n(e,null,!0)}function qn(e,t){if(t.cm)throw new Error("This document is already in use.");e.doc=t,t.cm=e,Cr(e),jn(e),Zn(e),e.options.lineWrapping||we(e),e.options.mode=t.modeOption,vn(e)}function Zn(e){("rtl"==e.doc.direction?s:Fl)(e.display.lineDiv,"CodeMirror-rtl")}function Qn(e){hn(e,function(){Zn(e),vn(e)})}function Jn(e){this.done=[],this.undone=[],this.undoDepth=1/0,this.lastModTime=this.lastSelTime=0,this.lastOp=this.lastSelOp=null,this.lastOrigin=this.lastSelOrigin=null,this.generation=this.maxGeneration=e||1}function ei(e,t){var r={from:z(t.from),to:Bn(t),text:N(e,t.from,t.to)};return si(e,r,t.from.line,t.to.line+1),$n(e,function(e){return si(e,r,t.from.line,t.to.line+1)},!0),r}function ti(e){for(;e.length&&g(e).ranges;)e.pop()}function ri(e,t){return t?(ti(e.done),g(e.done)):e.done.length&&!g(e.done).ranges?g(e.done):e.done.length>1&&!e.done[e.done.length-2].ranges?(e.done.pop(),g(e.done)):void 0}function ni(e,t,r,n){var i=e.history;i.undone.length=0;var o,l,s=+new Date;if((i.lastOp==n||i.lastOrigin==t.origin&&t.origin&&("+"==t.origin.charAt(0)&&e.cm&&i.lastModTime>s-e.cm.options.historyEventDelay||"*"==t.origin.charAt(0)))&&(o=ri(i,i.lastOp==n)))l=g(o.changes),0==P(t.from,t.to)&&0==P(t.from,l.to)?l.to=Bn(t):o.changes.push(ei(e,t));else{var a=g(i.done);for(a&&a.ranges||li(e.sel,i.done),o={changes:[ei(e,t)],generation:i.generation},i.done.push(o);i.done.length>i.undoDepth;)i.done.shift(),i.done[0].ranges||i.done.shift()}i.done.push(r),i.generation=++i.maxGeneration,i.lastModTime=i.lastSelTime=s,i.lastOp=i.lastSelOp=n,i.lastOrigin=i.lastSelOrigin=t.origin,l||Te(e,"historyAdded")}function ii(e,t,r,n){var i=t.charAt(0);return"*"==i||"+"==i&&r.ranges.length==n.ranges.length&&r.somethingSelected()==n.somethingSelected()&&new Date-e.history.lastSelTime<=(e.cm?e.cm.options.historyEventDelay:500)}function oi(e,t,r,n){var i=e.history,o=n&&n.origin;r==i.lastSelOp||o&&i.lastSelOrigin==o&&(i.lastModTime==i.lastSelTime&&i.lastOrigin==o||ii(e,o,g(i.done),t))?i.done[i.done.length-1]=t:li(t,i.done),i.lastSelTime=+new Date,i.lastSelOrigin=o,i.lastSelOp=r,n&&!1!==n.clearRedo&&ti(i.undone)}function li(e,t){var r=g(t);r&&r.ranges&&r.equals(e)||t.push(e)}function si(e,t,r,n){var i=t["spans_"+e.id],o=0;e.iter(Math.max(e.first,r),Math.min(e.first+e.size,n),function(r){r.markedSpans&&((i||(i=t["spans_"+e.id]={}))[o]=r.markedSpans),++o})}function ai(e){if(!e)return null;for(var t,r=0;r<e.length;++r)e[r].marker.explicitlyCleared?t||(t=e.slice(0,r)):t&&t.push(e[r]);return t?t.length?t:null:e}function ui(e,t){var r=t["spans_"+e.id];if(!r)return null;for(var n=[],i=0;i<t.text.length;++i)n.push(ai(r[i]));return n}function ci(e,t){var r=ui(e,t),n=J(e,t);if(!r)return n;if(!n)return r;for(var i=0;i<r.length;++i){var o=r[i],l=n[i];if(o&&l)e:for(var s=0;s<l.length;++s){for(var a=l[s],u=0;u<o.length;++u)if(o[u].marker==a.marker)continue e;o.push(a)}else l&&(r[i]=l)}return r}function fi(e,t,r){for(var n=[],i=0;i<e.length;++i){var o=e[i];if(o.ranges)n.push(r?ks.prototype.deepCopy.call(o):o);else{var l=o.changes,s=[];n.push({changes:s});for(var a=0;a<l.length;++a){var u=l[a],c=void 0;if(s.push({from:u.from,to:u.to,text:u.text}),t)for(var f in u)(c=f.match(/^spans_(\d+)$/))&&h(t,Number(c[1]))>-1&&(g(s)[f]=u[f],delete u[f])}}}return n}function hi(e,t,r,n){if(n){var i=e.anchor;if(r){var o=P(t,i)<0;o!=P(r,i)<0?(i=t,t=r):o!=P(t,r)<0&&(t=r)}return new Ts(i,t)}return new Ts(r||t,t)}function di(e,t,r,n,i){null==i&&(i=e.cm&&(e.cm.display.shift||e.extend)),bi(e,new ks([hi(e.sel.primary(),t,r,i)],0),n)}function pi(e,t,r){for(var n=[],i=e.cm&&(e.cm.display.shift||e.extend),o=0;o<e.sel.ranges.length;o++)n[o]=hi(e.sel.ranges[o],t[o],null,i);bi(e,zn(n,e.sel.primIndex),r)}function gi(e,t,r,n){var i=e.sel.ranges.slice(0);i[t]=r,bi(e,zn(i,e.sel.primIndex),n)}function vi(e,t,r,n){bi(e,Rn(t,r),n)}function mi(e,t,r){var n={ranges:t.ranges,update:function(t){var r=this;this.ranges=[];for(var n=0;n<t.length;n++)r.ranges[n]=new Ts(U(e,t[n].anchor),U(e,t[n].head))},origin:r&&r.origin};return Te(e,"beforeSelectionChange",e,n),e.cm&&Te(e.cm,"beforeSelectionChange",e.cm,n),n.ranges!=t.ranges?zn(n.ranges,n.ranges.length-1):t}function yi(e,t,r){var n=e.history.done,i=g(n);i&&i.ranges?(n[n.length-1]=t,wi(e,t,r)):bi(e,t,r)}function bi(e,t,r){wi(e,t,r),oi(e,e.sel,e.cm?e.cm.curOp.id:NaN,r)}function wi(e,t,r){(Oe(e,"beforeSelectionChange")||e.cm&&Oe(e.cm,"beforeSelectionChange"))&&(t=mi(e,t,r)),xi(e,Si(e,t,r&&r.bias||(P(t.primary().head,e.sel.primary().head)<0?-1:1),!0)),r&&!1===r.scroll||!e.cm||jr(e.cm)}function xi(e,t){t.equals(e.sel)||(e.sel=t,e.cm&&(e.cm.curOp.updateInput=e.cm.curOp.selectionChanged=!0,Ne(e.cm)),bt(e,"cursorActivity",e))}function Ci(e){xi(e,Si(e,e.sel,null,!1))}function Si(e,t,r,n){for(var i,o=0;o<t.ranges.length;o++){var l=t.ranges[o],s=t.ranges.length==e.sel.ranges.length&&e.sel.ranges[o],a=ki(e,l.anchor,s&&s.anchor,r,n),u=ki(e,l.head,s&&s.head,r,n);(i||a!=l.anchor||u!=l.head)&&(i||(i=t.ranges.slice(0,o)),i[o]=new Ts(a,u))}return i?zn(i,t.primIndex):t}function Li(e,t,r,n,i){var o=M(e,t.line);if(o.markedSpans)for(var l=0;l<o.markedSpans.length;++l){var s=o.markedSpans[l],a=s.marker;if((null==s.from||(a.inclusiveLeft?s.from<=t.ch:s.from<t.ch))&&(null==s.to||(a.inclusiveRight?s.to>=t.ch:s.to>t.ch))){if(i&&(Te(a,"beforeCursorEnter"),a.explicitlyCleared)){if(o.markedSpans){--l;continue}break}if(!a.atomic)continue;if(r){var u=a.find(n<0?1:-1),c=void 0;if((n<0?a.inclusiveRight:a.inclusiveLeft)&&(u=Ti(e,u,-n,u&&u.line==t.line?o:null)),u&&u.line==t.line&&(c=P(u,r))&&(n<0?c<0:c>0))return Li(e,u,t,n,i)}var f=a.find(n<0?-1:1);return(n<0?a.inclusiveLeft:a.inclusiveRight)&&(f=Ti(e,f,n,f.line==t.line?o:null)),f?Li(e,f,t,n,i):null}}return t}function ki(e,t,r,n,i){var o=n||1,l=Li(e,t,r,o,i)||!i&&Li(e,t,r,o,!0)||Li(e,t,r,-o,i)||!i&&Li(e,t,r,-o,!0);return l||(e.cantEdit=!0,E(e.first,0))}function Ti(e,t,r,n){return r<0&&0==t.ch?t.line>e.first?U(e,E(t.line-1)):null:r>0&&t.ch==(n||M(e,t.line)).text.length?t.line<e.first+e.size-1?E(t.line+1,0):null:new E(t.line,t.ch+r)}function Mi(e){e.setSelection(E(e.firstLine(),0),E(e.lastLine()),Gl)}function Ni(e,t,r){var n={canceled:!1,from:t.from,to:t.to,text:t.text,origin:t.origin,cancel:function(){return n.canceled=!0}};return r&&(n.update=function(t,r,i,o){t&&(n.from=U(e,t)),r&&(n.to=U(e,r)),i&&(n.text=i),void 0!==o&&(n.origin=o)}),Te(e,"beforeChange",e,n),e.cm&&Te(e.cm,"beforeChange",e.cm,n),n.canceled?null:{from:n.from,to:n.to,text:n.text,origin:n.origin}}function Oi(e,t,r){if(e.cm){if(!e.cm.curOp)return dn(e.cm,Oi)(e,t,r);if(e.cm.state.suppressEdits)return}if(!(Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"))||(t=Ni(e,t,!0))){var n=Yl&&!r&&te(e,t.from,t.to);if(n)for(var i=n.length-1;i>=0;--i)Ai(e,{from:n[i].from,to:n[i].to,text:i?[""]:t.text,origin:t.origin});else Ai(e,t)}}function Ai(e,t){if(1!=t.text.length||""!=t.text[0]||0!=P(t.from,t.to)){var r=Un(e,t);ni(e,t,r,e.cm?e.cm.curOp.id:NaN),Hi(e,t,r,J(e,t));var n=[];$n(e,function(e,r){r||-1!=h(n,e.history)||(zi(e.history,t),n.push(e.history)),Hi(e,t,null,J(e,t))})}}function Wi(e,t,r){if(!e.cm||!e.cm.state.suppressEdits||r){for(var n,i=e.history,o=e.sel,l="undo"==t?i.done:i.undone,s="undo"==t?i.undone:i.done,a=0;a<l.length&&(n=l[a],r?!n.ranges||n.equals(e.sel):n.ranges);a++);if(a!=l.length){for(i.lastOrigin=i.lastSelOrigin=null;(n=l.pop()).ranges;){if(li(n,s),r&&!n.equals(e.sel))return void bi(e,n,{clearRedo:!1});o=n}var u=[];li(o,s),s.push({changes:u,generation:i.generation}),i.generation=n.generation||++i.maxGeneration;for(var c=Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"),f=n.changes.length-1;f>=0;--f){var d=function(r){var i=n.changes[r];if(i.origin=t,c&&!Ni(e,i,!1))return l.length=0,{};u.push(ei(e,i));var o=r?Un(e,i):g(l);Hi(e,i,o,ci(e,i)),!r&&e.cm&&e.cm.scrollIntoView({from:i.from,to:Bn(i)});var s=[];$n(e,function(e,t){t||-1!=h(s,e.history)||(zi(e.history,i),s.push(e.history)),Hi(e,i,null,ci(e,i))})}(f);if(d)return d.v}}}}function Di(e,t){if(0!=t&&(e.first+=t,e.sel=new ks(v(e.sel.ranges,function(e){return new Ts(E(e.anchor.line+t,e.anchor.ch),E(e.head.line+t,e.head.ch))}),e.sel.primIndex),e.cm)){vn(e.cm,e.first,e.first-t,t);for(var r=e.cm.display,n=r.viewFrom;n<r.viewTo;n++)mn(e.cm,n,"gutter")}}function Hi(e,t,r,n){if(e.cm&&!e.cm.curOp)return dn(e.cm,Hi)(e,t,r,n);if(t.to.line<e.first)Di(e,t.text.length-1-(t.to.line-t.from.line));else if(!(t.from.line>e.lastLine())){if(t.from.line<e.first){var i=t.text.length-1-(e.first-t.from.line);Di(e,i),t={from:E(e.first,0),to:E(t.to.line+i,t.to.ch),text:[g(t.text)],origin:t.origin}}var o=e.lastLine();t.to.line>o&&(t={from:t.from,to:E(o,M(e,o).text.length),text:[t.text[0]],origin:t.origin}),t.removed=N(e,t.from,t.to),r||(r=Un(e,t)),e.cm?Fi(e.cm,t,n):_n(e,t,n),wi(e,r,Gl)}}function Fi(e,t,r){var n=e.doc,i=e.display,o=t.from,l=t.to,s=!1,a=o.line;e.options.lineWrapping||(a=W(fe(M(n,o.line))),n.iter(a,l.line+1,function(e){if(e==i.maxLine)return s=!0,!0})),n.sel.contains(t.from,t.to)>-1&&Ne(e),_n(n,t,r,xr(e)),e.options.lineWrapping||(n.iter(a,o.line+t.text.length,function(e){var t=be(e);t>i.maxLineLength&&(i.maxLine=e,i.maxLineLength=t,i.maxLineChanged=!0,s=!1)}),s&&(e.curOp.updateMaxLine=!0)),nt(n,o.line),Cn(e,400);var u=t.text.length-(l.line-o.line)-1;t.full?vn(e):o.line!=l.line||1!=t.text.length||Yn(e.doc,t)?vn(e,o.line,l.line+1,u):mn(e,o.line,"text");var c=Oe(e,"changes"),f=Oe(e,"change");if(f||c){var h={from:o,to:l,text:t.text,removed:t.removed,origin:t.origin};f&&bt(e,"change",e,h),c&&(e.curOp.changeObjs||(e.curOp.changeObjs=[])).push(h)}e.display.selForContextMenu=null}function Ei(e,t,r,n,i){if(n||(n=r),P(n,r)<0){var o;r=(o=[n,r])[0],n=o[1]}"string"==typeof t&&(t=e.splitLines(t)),Oi(e,{from:r,to:n,text:t,origin:i})}function Pi(e,t,r,n){r<e.line?e.line+=n:t<e.line&&(e.line=t,e.ch=0)}function Ii(e,t,r,n){for(var i=0;i<e.length;++i){var o=e[i],l=!0;if(o.ranges){o.copied||((o=e[i]=o.deepCopy()).copied=!0);for(var s=0;s<o.ranges.length;s++)Pi(o.ranges[s].anchor,t,r,n),Pi(o.ranges[s].head,t,r,n)}else{for(var a=0;a<o.changes.length;++a){var u=o.changes[a];if(r<u.from.line)u.from=E(u.from.line+n,u.from.ch),u.to=E(u.to.line+n,u.to.ch);else if(t<=u.to.line){l=!1;break}}l||(e.splice(0,i+1),i=0)}}}function zi(e,t){var r=t.from.line,n=t.to.line,i=t.text.length-(n-r)-1;Ii(e.done,r,n,i),Ii(e.undone,r,n,i)}function Ri(e,t,r,n){var i=t,o=t;return"number"==typeof t?o=M(e,G(e,t)):i=W(t),null==i?null:(n(o,i)&&e.cm&&mn(e.cm,i,r),o)}function Bi(e){var t=this;this.lines=e,this.parent=null;for(var r=0,n=0;n<e.length;++n)e[n].parent=t,r+=e[n].height;this.height=r}function Gi(e){var t=this;this.children=e;for(var r=0,n=0,i=0;i<e.length;++i){var o=e[i];r+=o.chunkSize(),n+=o.height,o.parent=t}this.size=r,this.height=n,this.parent=null}function Ui(e,t,r){ye(t)<(e.curOp&&e.curOp.scrollTop||e.doc.scrollTop)&&Kr(e,r)}function Vi(e,t,r,n){var i=new Ms(e,r,n),o=e.cm;return o&&i.noHScroll&&(o.display.alignWidgets=!0),Ri(e,t,"widget",function(t){var r=t.widgets||(t.widgets=[]);if(null==i.insertAt?r.push(i):r.splice(Math.min(r.length-1,Math.max(0,i.insertAt)),0,i),i.line=t,o&&!ve(e,t)){var n=ye(t)<e.scrollTop;A(t,t.height+Ht(i)),n&&Kr(o,i.height),o.curOp.forceUpdate=!0}return!0}),bt(o,"lineWidgetAdded",o,i,"number"==typeof t?t:W(t)),i}function Ki(e,t,r,n,o){if(n&&n.shared)return ji(e,t,r,n,o);if(e.cm&&!e.cm.curOp)return dn(e.cm,Ki)(e,t,r,n,o);var l=new Os(e,o),s=P(t,r);if(n&&c(n,l,!1),s>0||0==s&&!1!==l.clearWhenEmpty)return l;if(l.replacedWith&&(l.collapsed=!0,l.widgetNode=i("span",[l.replacedWith],"CodeMirror-widget"),n.handleMouseEvents||l.widgetNode.setAttribute("cm-ignore-events","true"),n.insertLeft&&(l.widgetNode.insertLeft=!0)),l.collapsed){if(ce(e,t.line,t,r,l)||t.line!=r.line&&ce(e,r.line,t,r,l))throw new Error("Inserting collapsed marker partially overlapping an existing one");X()}l.addToHistory&&ni(e,{from:t,to:r,origin:"markText"},e.sel,NaN);var a,u=t.line,f=e.cm;if(e.iter(u,r.line+1,function(e){f&&l.collapsed&&!f.options.lineWrapping&&fe(e)==f.display.maxLine&&(a=!0),l.collapsed&&u!=t.line&&A(e,0),q(e,new Y(l,u==t.line?t.ch:null,u==r.line?r.ch:null)),++u}),l.collapsed&&e.iter(t.line,r.line+1,function(t){ve(e,t)&&A(t,0)}),l.clearOnEnter&&Ql(l,"beforeCursorEnter",function(){return l.clear()}),l.readOnly&&(j(),(e.history.done.length||e.history.undone.length)&&e.clearHistory()),l.collapsed&&(l.id=++Ns,l.atomic=!0),f){if(a&&(f.curOp.updateMaxLine=!0),l.collapsed)vn(f,t.line,r.line+1);else if(l.className||l.title||l.startStyle||l.endStyle||l.css)for(var h=t.line;h<=r.line;h++)mn(f,h,"text");l.atomic&&Ci(f.doc),bt(f,"markerAdded",f,l)}return l}function ji(e,t,r,n,i){(n=c(n)).shared=!1;var o=[Ki(e,t,r,n,i)],l=o[0],s=n.widgetNode;return $n(e,function(e){s&&(n.widgetNode=s.cloneNode(!0)),o.push(Ki(e,U(e,t),U(e,r),n,i));for(var a=0;a<e.linked.length;++a)if(e.linked[a].isParent)return;l=g(o)}),new As(o,l)}function Xi(e){return e.findMarks(E(e.first,0),e.clipPos(E(e.lastLine())),function(e){return e.parent})}function Yi(e,t){for(var r=0;r<t.length;r++){var n=t[r],i=n.find(),o=e.clipPos(i.from),l=e.clipPos(i.to);if(P(o,l)){var s=Ki(e,o,l,n.primary,n.primary.type);n.markers.push(s),s.parent=n}}}function _i(e){for(var t=0;t<e.length;t++)!function(t){var r=e[t],n=[r.primary.doc];$n(r.primary.doc,function(e){return n.push(e)});for(var i=0;i<r.markers.length;i++){var o=r.markers[i];-1==h(n,o.doc)&&(o.parent=null,r.markers.splice(i--,1))}}(t)}function $i(e){var t=this;if(Qi(t),!Me(t,e)&&!Ft(t.display,e)){We(e),gl&&(Hs=+new Date);var r=Sr(t,e,!0),n=e.dataTransfer.files;if(r&&!t.isReadOnly())if(n&&n.length&&window.FileReader&&window.File)for(var i=n.length,o=Array(i),l=0,s=0;s<i;++s)!function(e,n){if(!t.options.allowDropFileTypes||-1!=h(t.options.allowDropFileTypes,e.type)){var s=new FileReader;s.onload=dn(t,function(){var e=s.result;if(/[\x00-\x08\x0e-\x1f]{2}/.test(e)&&(e=""),o[n]=e,++l==i){var a={from:r=U(t.doc,r),to:r,text:t.doc.splitLines(o.join(t.doc.lineSeparator())),origin:"paste"};Oi(t.doc,a),yi(t.doc,Rn(r,Bn(a)))}}),s.readAsText(e)}}(n[s],s);else{if(t.state.draggingText&&t.doc.sel.contains(r)>-1)return t.state.draggingText(e),void setTimeout(function(){return t.display.input.focus()},20);try{var a=e.dataTransfer.getData("Text");if(a){var u;if(t.state.draggingText&&!t.state.draggingText.copy&&(u=t.listSelections()),wi(t.doc,Rn(r,r)),u)for(var c=0;c<u.length;++c)Ei(t.doc,"",u[c].anchor,u[c].head,"drag");t.replaceSelection(a,"around","paste"),t.display.input.focus()}}catch(e){}}}}function qi(e,t){if(gl&&(!e.state.draggingText||+new Date-Hs<100))Fe(t);else if(!Me(e,t)&&!Ft(e.display,t)&&(t.dataTransfer.setData("Text",e.getSelection()),t.dataTransfer.effectAllowed="copyMove",t.dataTransfer.setDragImage&&!xl)){var r=n("img",null,null,"position: fixed; left: 0; top: 0;");r.src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",wl&&(r.width=r.height=1,e.display.wrapper.appendChild(r),r._top=r.offsetTop),t.dataTransfer.setDragImage(r,0,0),wl&&r.parentNode.removeChild(r)}}function Zi(e,t){var i=Sr(e,t);if(i){var o=document.createDocumentFragment();Mr(e,i,o),e.display.dragCursor||(e.display.dragCursor=n("div",null,"CodeMirror-cursors CodeMirror-dragcursors"),e.display.lineSpace.insertBefore(e.display.dragCursor,e.display.cursorDiv)),r(e.display.dragCursor,o)}}function Qi(e){e.display.dragCursor&&(e.display.lineSpace.removeChild(e.display.dragCursor),e.display.dragCursor=null)}function Ji(e){if(document.getElementsByClassName)for(var t=document.getElementsByClassName("CodeMirror"),r=0;r<t.length;r++){var n=t[r].CodeMirror;n&&e(n)}}function eo(){Fs||(to(),Fs=!0)}function to(){var e;Ql(window,"resize",function(){null==e&&(e=setTimeout(function(){e=null,Ji(ro)},100))}),Ql(window,"blur",function(){return Ji(Fr)})}function ro(e){var t=e.display;t.lastWrapHeight==t.wrapper.clientHeight&&t.lastWrapWidth==t.wrapper.clientWidth||(t.cachedCharWidth=t.cachedTextHeight=t.cachedPaddingH=null,t.scrollbarsClipped=!1,e.setSize())}function no(e){var t=e.split(/-(?!$)/);e=t[t.length-1];for(var r,n,i,o,l=0;l<t.length-1;l++){var s=t[l];if(/^(cmd|meta|m)$/i.test(s))o=!0;else if(/^a(lt)?$/i.test(s))r=!0;else if(/^(c|ctrl|control)$/i.test(s))n=!0;else{if(!/^s(hift)?$/i.test(s))throw new Error("Unrecognized modifier name: "+s);i=!0}}return r&&(e="Alt-"+e),n&&(e="Ctrl-"+e),o&&(e="Cmd-"+e),i&&(e="Shift-"+e),e}function io(e){var t={};for(var r in e)if(e.hasOwnProperty(r)){var n=e[r];if(/^(name|fallthrough|(de|at)tach)$/.test(r))continue;if("..."==n){delete e[r];continue}for(var i=v(r.split(" "),no),o=0;o<i.length;o++){var l=void 0,s=void 0;o==i.length-1?(s=i.join(" "),l=n):(s=i.slice(0,o+1).join(" "),l="...");var a=t[s];if(a){if(a!=l)throw new Error("Inconsistent bindings for "+s)}else t[s]=l}delete e[r]}for(var u in t)e[u]=t[u];return e}function oo(e,t,r,n){var i=(t=uo(t)).call?t.call(e,n):t[e];if(!1===i)return"nothing";if("..."===i)return"multi";if(null!=i&&r(i))return"handled";if(t.fallthrough){if("[object Array]"!=Object.prototype.toString.call(t.fallthrough))return oo(e,t.fallthrough,r,n);for(var o=0;o<t.fallthrough.length;o++){var l=oo(e,t.fallthrough[o],r,n);if(l)return l}}}function lo(e){var t="string"==typeof e?e:Es[e.keyCode];return"Ctrl"==t||"Alt"==t||"Shift"==t||"Mod"==t}function so(e,t,r){var n=e;return t.altKey&&"Alt"!=n&&(e="Alt-"+e),(Dl?t.metaKey:t.ctrlKey)&&"Ctrl"!=n&&(e="Ctrl-"+e),(Dl?t.ctrlKey:t.metaKey)&&"Cmd"!=n&&(e="Cmd-"+e),!r&&t.shiftKey&&"Shift"!=n&&(e="Shift-"+e),e}function ao(e,t){if(wl&&34==e.keyCode&&e.char)return!1;var r=Es[e.keyCode];return null!=r&&!e.altGraphKey&&so(r,e,t)}function uo(e){return"string"==typeof e?Rs[e]:e}function co(e,t){for(var r=e.doc.sel.ranges,n=[],i=0;i<r.length;i++){for(var o=t(r[i]);n.length&&P(o.from,g(n).to)<=0;){var l=n.pop();if(P(l.from,o.from)<0){o.from=l.from;break}}n.push(o)}hn(e,function(){for(var t=n.length-1;t>=0;t--)Ei(e.doc,"",n[t].from,n[t].to,"+delete");jr(e)})}function fo(e,t,r){var n=L(e.text,t+r,r);return n<0||n>e.text.length?null:n}function ho(e,t,r){var n=fo(e,t.ch,r);return null==n?null:new E(t.line,n,r<0?"after":"before")}function po(e,t,r,n,i){if(e){var o=Se(r,t.doc.direction);if(o){var l,s=i<0?g(o):o[0],a=i<0==(1==s.level)?"after":"before";if(s.level>0){var u=Xt(t,r);l=i<0?r.text.length-1:0;var c=Yt(t,u,l).top;l=k(function(e){return Yt(t,u,e).top==c},i<0==(1==s.level)?s.from:s.to-1,l),"before"==a&&(l=fo(r,l,1))}else l=i<0?s.to:s.from;return new E(n,l,a)}}return new E(n,i<0?r.text.length:0,i<0?"before":"after")}function go(e,t,r,n){var i=Se(t,e.doc.direction);if(!i)return ho(t,r,n);r.ch>=t.text.length?(r.ch=t.text.length,r.sticky="before"):r.ch<=0&&(r.ch=0,r.sticky="after");var o=Ce(i,r.ch,r.sticky),l=i[o];if("ltr"==e.doc.direction&&l.level%2==0&&(n>0?l.to>r.ch:l.from<r.ch))return ho(t,r,n);var s,a=function(e,r){return fo(t,e instanceof E?e.ch:e,r)},u=function(r){return e.options.lineWrapping?(s=s||Xt(e,t),hr(e,t,s,r)):{begin:0,end:t.text.length}},c=u("before"==r.sticky?a(r,-1):r.ch);if("rtl"==e.doc.direction||1==l.level){var f=1==l.level==n<0,h=a(r,f?1:-1);if(null!=h&&(f?h<=l.to&&h<=c.end:h>=l.from&&h>=c.begin)){var d=f?"before":"after";return new E(r.line,h,d)}}var p=function(e,t,n){for(var o=function(e,t){return t?new E(r.line,a(e,1),"before"):new E(r.line,e,"after")};e>=0&&e<i.length;e+=t){var l=i[e],s=t>0==(1!=l.level),u=s?n.begin:a(n.end,-1);if(l.from<=u&&u<l.to)return o(u,s);if(u=s?l.from:a(l.to,-1),n.begin<=u&&u<n.end)return o(u,s)}},g=p(o+n,n,c);if(g)return g;var v=n>0?c.end:a(c.begin,-1);return null==v||n>0&&v==t.text.length||!(g=p(n>0?0:i.length-1,n,u(v)))?null:g}function vo(e,t){var r=M(e.doc,t),n=fe(r);return n!=r&&(t=W(n)),po(!0,e,n,t,1)}function mo(e,t){var r=M(e.doc,t),n=he(r);return n!=r&&(t=W(n)),po(!0,e,r,t,-1)}function yo(e,t){var r=vo(e,t.line),n=M(e.doc,r.line),i=Se(n,e.doc.direction);if(!i||0==i[0].level){var o=Math.max(0,n.text.search(/\S/)),l=t.line==r.line&&t.ch<=o&&t.ch;return E(r.line,l?0:o,r.sticky)}return r}function bo(e,t,r){if("string"==typeof t&&!(t=Bs[t]))return!1;e.display.input.ensurePolled();var n=e.display.shift,i=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),r&&(e.display.shift=!1),i=t(e)!=Bl}finally{e.display.shift=n,e.state.suppressEdits=!1}return i}function wo(e,t,r){for(var n=0;n<e.state.keyMaps.length;n++){var i=oo(t,e.state.keyMaps[n],r,e);if(i)return i}return e.options.extraKeys&&oo(t,e.options.extraKeys,r,e)||oo(t,e.options.keyMap,r,e)}function xo(e,t,r,n){var i=e.state.keySeq;if(i){if(lo(t))return"handled";Gs.set(50,function(){e.state.keySeq==i&&(e.state.keySeq=null,e.display.input.reset())}),t=i+" "+t}var o=wo(e,t,n);return"multi"==o&&(e.state.keySeq=t),"handled"==o&&bt(e,"keyHandled",e,t,r),"handled"!=o&&"multi"!=o||(We(r),Ar(e)),i&&!o&&/\'$/.test(t)?(We(r),!0):!!o}function Co(e,t){var r=ao(t,!0);return!!r&&(t.shiftKey&&!e.state.keySeq?xo(e,"Shift-"+r,t,function(t){return bo(e,t,!0)})||xo(e,r,t,function(t){if("string"==typeof t?/^go[A-Z]/.test(t):t.motion)return bo(e,t)}):xo(e,r,t,function(t){return bo(e,t)}))}function So(e,t,r){return xo(e,"'"+r+"'",t,function(t){return bo(e,t,!0)})}function Lo(e){var t=this;if(t.curOp.focus=l(),!Me(t,e)){gl&&vl<11&&27==e.keyCode&&(e.returnValue=!1);var r=e.keyCode;t.display.shift=16==r||e.shiftKey;var n=Co(t,e);wl&&(Us=n?r:null,!n&&88==r&&!rs&&(Ml?e.metaKey:e.ctrlKey)&&t.replaceSelection("",null,"cut")),18!=r||/\bCodeMirror-crosshair\b/.test(t.display.lineDiv.className)||ko(t)}}function ko(e){function t(e){18!=e.keyCode&&e.altKey||(Fl(r,"CodeMirror-crosshair"),ke(document,"keyup",t),ke(document,"mouseover",t))}var r=e.display.lineDiv;s(r,"CodeMirror-crosshair"),Ql(document,"keyup",t),Ql(document,"mouseover",t)}function To(e){16==e.keyCode&&(this.doc.sel.shift=!1),Me(this,e)}function Mo(e){var t=this;if(!(Ft(t.display,e)||Me(t,e)||e.ctrlKey&&!e.altKey||Ml&&e.metaKey)){var r=e.keyCode,n=e.charCode;if(wl&&r==Us)return Us=null,void We(e);if(!wl||e.which&&!(e.which<10)||!Co(t,e)){var i=String.fromCharCode(null==n?r:n);"\b"!=i&&(So(t,e,i)||t.display.input.onKeyPress(e))}}}function No(e,t){var r=+new Date;return js&&js.compare(r,e,t)?(Ks=js=null,"triple"):Ks&&Ks.compare(r,e,t)?(js=new Vs(r,e,t),Ks=null,"double"):(Ks=new Vs(r,e,t),js=null,"single")}function Oo(e){var t=this,r=t.display;if(!(Me(t,e)||r.activeTouch&&r.input.supportsTouch()))if(r.input.ensurePolled(),r.shift=e.shiftKey,Ft(r,e))ml||(r.scroller.draggable=!1,setTimeout(function(){return r.scroller.draggable=!0},100));else if(!zo(t,e)){var n=Sr(t,e),i=Pe(e),o=n?No(n,i):"single";window.focus(),1==i&&t.state.selectingText&&t.state.selectingText(e),n&&Ao(t,i,n,o,e)||(1==i?n?Do(t,n,o,e):Ee(e)==r.scroller&&We(e):2==i?(n&&di(t.doc,n),setTimeout(function(){return r.input.focus()},20)):3==i&&(Hl?Ro(t,e):Dr(t)))}}function Ao(e,t,r,n,i){var o="Click";return"double"==n?o="Double"+o:"triple"==n&&(o="Triple"+o),o=(1==t?"Left":2==t?"Middle":"Right")+o,xo(e,so(o,i),i,function(t){if("string"==typeof t&&(t=Bs[t]),!t)return!1;var n=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),n=t(e,r)!=Bl}finally{e.state.suppressEdits=!1}return n})}function Wo(e,t,r){var n=e.getOption("configureMouse"),i=n?n(e,t,r):{};if(null==i.unit){var o=Nl?r.shiftKey&&r.metaKey:r.altKey;i.unit=o?"rectangle":"single"==t?"char":"double"==t?"word":"line"}return(null==i.extend||e.doc.extend)&&(i.extend=e.doc.extend||r.shiftKey),null==i.addNew&&(i.addNew=Ml?r.metaKey:r.ctrlKey),null==i.moveOnDrag&&(i.moveOnDrag=!(Ml?r.altKey:r.ctrlKey)),i}function Do(e,t,r,n){gl?setTimeout(u(Wr,e),0):e.curOp.focus=l();var i,o=Wo(e,r,n),s=e.doc.sel;e.options.dragDrop&&Jl&&!e.isReadOnly()&&"single"==r&&(i=s.contains(t))>-1&&(P((i=s.ranges[i]).from(),t)<0||t.xRel>0)&&(P(i.to(),t)>0||t.xRel<0)?Ho(e,n,t,o):Eo(e,n,t,o)}function Ho(e,t,r,n){var i=e.display,o=!1,l=dn(e,function(t){ml&&(i.scroller.draggable=!1),e.state.draggingText=!1,ke(document,"mouseup",l),ke(document,"mousemove",s),ke(i.scroller,"dragstart",a),ke(i.scroller,"drop",l),o||(We(t),n.addNew||di(e.doc,r,null,null,n.extend),ml||gl&&9==vl?setTimeout(function(){document.body.focus(),i.input.focus()},20):i.input.focus())}),s=function(e){o=o||Math.abs(t.clientX-e.clientX)+Math.abs(t.clientY-e.clientY)>=10},a=function(){return o=!0};ml&&(i.scroller.draggable=!0),e.state.draggingText=l,l.copy=!n.moveOnDrag,i.scroller.dragDrop&&i.scroller.dragDrop(),Ql(document,"mouseup",l),Ql(document,"mousemove",s),Ql(i.scroller,"dragstart",a),Ql(i.scroller,"drop",l),Dr(e),setTimeout(function(){return i.input.focus()},20)}function Fo(e,t,r){if("char"==r)return new Ts(t,t);if("word"==r)return e.findWordAt(t);if("line"==r)return new Ts(E(t.line,0),U(e.doc,E(t.line+1,0)));var n=r(e,t);return new Ts(n.from,n.to)}function Eo(e,t,r,n){function i(t){if(0!=P(m,t))if(m=t,"rectangle"==n.unit){for(var i=[],o=e.options.tabSize,l=f(M(u,r.line).text,r.ch,o),s=f(M(u,t.line).text,t.ch,o),a=Math.min(l,s),g=Math.max(l,s),v=Math.min(r.line,t.line),y=Math.min(e.lastLine(),Math.max(r.line,t.line));v<=y;v++){var b=M(u,v).text,w=d(b,a,o);a==g?i.push(new Ts(E(v,w),E(v,w))):b.length>w&&i.push(new Ts(E(v,w),E(v,d(b,g,o))))}i.length||i.push(new Ts(r,r)),bi(u,zn(p.ranges.slice(0,h).concat(i),h),{origin:"*mouse",scroll:!1}),e.scrollIntoView(t)}else{var x,C=c,S=Fo(e,t,n.unit),L=C.anchor;P(S.anchor,L)>0?(x=S.head,L=B(C.from(),S.anchor)):(x=S.anchor,L=R(C.to(),S.head));var k=p.ranges.slice(0);k[h]=Po(e,new Ts(U(u,L),x)),bi(u,zn(k,h),Ul)}}function o(t){var r=++b,s=Sr(e,t,!0,"rectangle"==n.unit);if(s)if(0!=P(s,m)){e.curOp.focus=l(),i(s);var c=Ir(a,u);(s.line>=c.to||s.line<c.from)&&setTimeout(dn(e,function(){b==r&&o(t)}),150)}else{var f=t.clientY<y.top?-20:t.clientY>y.bottom?20:0;f&&setTimeout(dn(e,function(){b==r&&(a.scroller.scrollTop+=f,o(t))}),50)}}function s(t){e.state.selectingText=!1,b=1/0,We(t),a.input.focus(),ke(document,"mousemove",w),ke(document,"mouseup",x),u.history.lastSelOrigin=null}var a=e.display,u=e.doc;We(t);var c,h,p=u.sel,g=p.ranges;if(n.addNew&&!n.extend?(h=u.sel.contains(r),c=h>-1?g[h]:new Ts(r,r)):(c=u.sel.primary(),h=u.sel.primIndex),"rectangle"==n.unit)n.addNew||(c=new Ts(r,r)),r=Sr(e,t,!0,!0),h=-1;else{var v=Fo(e,r,n.unit);c=n.extend?hi(c,v.anchor,v.head,n.extend):v}n.addNew?-1==h?(h=g.length,bi(u,zn(g.concat([c]),h),{scroll:!1,origin:"*mouse"})):g.length>1&&g[h].empty()&&"char"==n.unit&&!n.extend?(bi(u,zn(g.slice(0,h).concat(g.slice(h+1)),0),{scroll:!1,origin:"*mouse"}),p=u.sel):gi(u,h,c,Ul):(h=0,bi(u,new ks([c],0),Ul),p=u.sel);var m=r,y=a.wrapper.getBoundingClientRect(),b=0,w=dn(e,function(e){Pe(e)?o(e):s(e)}),x=dn(e,s);e.state.selectingText=x,Ql(document,"mousemove",w),Ql(document,"mouseup",x)}function Po(e,t){var r=t.anchor,n=t.head,i=M(e.doc,r.line);if(0==P(r,n)&&r.sticky==n.sticky)return t;var o=Se(i);if(!o)return t;var l=Ce(o,r.ch,r.sticky),s=o[l];if(s.from!=r.ch&&s.to!=r.ch)return t;var a=l+(s.from==r.ch==(1!=s.level)?0:1);if(0==a||a==o.length)return t;var u;if(n.line!=r.line)u=(n.line-r.line)*("ltr"==e.doc.direction?1:-1)>0;else{var c=Ce(o,n.ch,n.sticky),f=c-l||(n.ch-r.ch)*(1==s.level?-1:1);u=c==a-1||c==a?f<0:f>0}var h=o[a+(u?-1:0)],d=u==(1==h.level),p=d?h.from:h.to,g=d?"after":"before";return r.ch==p&&r.sticky==g?t:new Ts(new E(r.line,p,g),n)}function Io(e,t,r,n){var i,o;if(t.touches)i=t.touches[0].clientX,o=t.touches[0].clientY;else try{i=t.clientX,o=t.clientY}catch(t){return!1}if(i>=Math.floor(e.display.gutters.getBoundingClientRect().right))return!1;n&&We(t);var l=e.display,s=l.lineDiv.getBoundingClientRect();if(o>s.bottom||!Oe(e,r))return He(t);o-=s.top-l.viewOffset;for(var a=0;a<e.options.gutters.length;++a){var u=l.gutters.childNodes[a];if(u&&u.getBoundingClientRect().right>=i)return Te(e,r,e,D(e.doc,o),e.options.gutters[a],t),He(t)}}function zo(e,t){return Io(e,t,"gutterClick",!0)}function Ro(e,t){Ft(e.display,t)||Bo(e,t)||Me(e,t,"contextmenu")||e.display.input.onContextMenu(t)}function Bo(e,t){return!!Oe(e,"gutterContextMenu")&&Io(e,t,"gutterContextMenu",!1)}function Go(e){e.display.wrapper.className=e.display.wrapper.className.replace(/\s*cm-s-\S+/g,"")+e.options.theme.replace(/(^|\s)\s*/g," cm-s-"),er(e)}function Uo(e){Hn(e),vn(e),zr(e)}function Vo(e,t,r){if(!t!=!(r&&r!=Xs)){var n=e.display.dragFunctions,i=t?Ql:ke;i(e.display.scroller,"dragstart",n.start),i(e.display.scroller,"dragenter",n.enter),i(e.display.scroller,"dragover",n.over),i(e.display.scroller,"dragleave",n.leave),i(e.display.scroller,"drop",n.drop)}}function Ko(e){e.options.lineWrapping?(s(e.display.wrapper,"CodeMirror-wrap"),e.display.sizer.style.minWidth="",e.display.sizerWidth=null):(Fl(e.display.wrapper,"CodeMirror-wrap"),we(e)),Cr(e),vn(e),er(e),setTimeout(function(){return en(e)},100)}function jo(e,t){var r=this;if(!(this instanceof jo))return new jo(e,t);this.options=t=t?c(t):{},c(Ys,t,!1),Fn(t);var n=t.value;"string"==typeof n&&(n=new Ds(n,t.mode,null,t.lineSeparator,t.direction)),this.doc=n;var i=new jo.inputStyles[t.inputStyle](this),o=this.display=new T(e,n,i);o.wrapper.CodeMirror=this,Hn(this),Go(this),t.lineWrapping&&(this.display.wrapper.className+=" CodeMirror-wrap"),rn(this),this.state={keyMaps:[],overlays:[],modeGen:0,overwrite:!1,delayingBlurEvent:!1,focused:!1,suppressEdits:!1,pasteIncoming:!1,cutIncoming:!1,selectingText:!1,draggingText:!1,highlight:new Pl,keySeq:null,specialChars:null},t.autofocus&&!Tl&&o.input.focus(),gl&&vl<11&&setTimeout(function(){return r.display.input.reset(!0)},20),Xo(this),eo(),nn(this),this.curOp.forceUpdate=!0,qn(this,n),t.autofocus&&!Tl||this.hasFocus()?setTimeout(u(Hr,this),20):Fr(this);for(var l in _s)_s.hasOwnProperty(l)&&_s[l](r,t[l],Xs);Rr(this),t.finishInit&&t.finishInit(this);for(var s=0;s<$s.length;++s)$s[s](r);on(this),ml&&t.lineWrapping&&"optimizelegibility"==getComputedStyle(o.lineDiv).textRendering&&(o.lineDiv.style.textRendering="auto")}function Xo(e){function t(){i.activeTouch&&(o=setTimeout(function(){return i.activeTouch=null},1e3),(l=i.activeTouch).end=+new Date)}function r(e){if(1!=e.touches.length)return!1;var t=e.touches[0];return t.radiusX<=1&&t.radiusY<=1}function n(e,t){if(null==t.left)return!0;var r=t.left-e.left,n=t.top-e.top;return r*r+n*n>400}var i=e.display;Ql(i.scroller,"mousedown",dn(e,Oo)),gl&&vl<11?Ql(i.scroller,"dblclick",dn(e,function(t){if(!Me(e,t)){var r=Sr(e,t);if(r&&!zo(e,t)&&!Ft(e.display,t)){We(t);var n=e.findWordAt(r);di(e.doc,n.anchor,n.head)}}})):Ql(i.scroller,"dblclick",function(t){return Me(e,t)||We(t)}),Hl||Ql(i.scroller,"contextmenu",function(t){return Ro(e,t)});var o,l={end:0};Ql(i.scroller,"touchstart",function(t){if(!Me(e,t)&&!r(t)&&!zo(e,t)){i.input.ensurePolled(),clearTimeout(o);var n=+new Date;i.activeTouch={start:n,moved:!1,prev:n-l.end<=300?l:null},1==t.touches.length&&(i.activeTouch.left=t.touches[0].pageX,i.activeTouch.top=t.touches[0].pageY)}}),Ql(i.scroller,"touchmove",function(){i.activeTouch&&(i.activeTouch.moved=!0)}),Ql(i.scroller,"touchend",function(r){var o=i.activeTouch;if(o&&!Ft(i,r)&&null!=o.left&&!o.moved&&new Date-o.start<300){var l,s=e.coordsChar(i.activeTouch,"page");l=!o.prev||n(o,o.prev)?new Ts(s,s):!o.prev.prev||n(o,o.prev.prev)?e.findWordAt(s):new Ts(E(s.line,0),U(e.doc,E(s.line+1,0))),e.setSelection(l.anchor,l.head),e.focus(),We(r)}t()}),Ql(i.scroller,"touchcancel",t),Ql(i.scroller,"scroll",function(){i.scroller.clientHeight&&(qr(e,i.scroller.scrollTop),Qr(e,i.scroller.scrollLeft,!0),Te(e,"scroll",e))}),Ql(i.scroller,"mousewheel",function(t){return In(e,t)}),Ql(i.scroller,"DOMMouseScroll",function(t){return In(e,t)}),Ql(i.wrapper,"scroll",function(){return i.wrapper.scrollTop=i.wrapper.scrollLeft=0}),i.dragFunctions={enter:function(t){Me(e,t)||Fe(t)},over:function(t){Me(e,t)||(Zi(e,t),Fe(t))},start:function(t){return qi(e,t)},drop:dn(e,$i),leave:function(t){Me(e,t)||Qi(e)}};var s=i.input.getField();Ql(s,"keyup",function(t){return To.call(e,t)}),Ql(s,"keydown",dn(e,Lo)),Ql(s,"keypress",dn(e,Mo)),Ql(s,"focus",function(t){return Hr(e,t)}),Ql(s,"blur",function(t){return Fr(e,t)})}function Yo(e,t,r,n){var i,o=e.doc;null==r&&(r="add"),"smart"==r&&(o.mode.indent?i=$e(e,t).state:r="prev");var l=e.options.tabSize,s=M(o,t),a=f(s.text,null,l);s.stateAfter&&(s.stateAfter=null);var u,c=s.text.match(/^\s*/)[0];if(n||/\S/.test(s.text)){if("smart"==r&&((u=o.mode.indent(i,s.text.slice(c.length),s.text))==Bl||u>150)){if(!n)return;r="prev"}}else u=0,r="not";"prev"==r?u=t>o.first?f(M(o,t-1).text,null,l):0:"add"==r?u=a+e.options.indentUnit:"subtract"==r?u=a-e.options.indentUnit:"number"==typeof r&&(u=a+r),u=Math.max(0,u);var h="",d=0;if(e.options.indentWithTabs)for(var g=Math.floor(u/l);g;--g)d+=l,h+="\t";if(d<u&&(h+=p(u-d)),h!=c)return Ei(o,h,E(t,0),E(t,c.length),"+input"),s.stateAfter=null,!0;for(var v=0;v<o.sel.ranges.length;v++){var m=o.sel.ranges[v];if(m.head.line==t&&m.head.ch<c.length){var y=E(t,c.length);gi(o,v,new Ts(y,y));break}}}function _o(e){qs=e}function $o(e,t,r,n,i){var o=e.doc;e.display.shift=!1,n||(n=o.sel);var l=e.state.pasteIncoming||"paste"==i,s=es(t),a=null;if(l&&n.ranges.length>1)if(qs&&qs.text.join("\n")==t){if(n.ranges.length%qs.text.length==0){a=[];for(var u=0;u<qs.text.length;u++)a.push(o.splitLines(qs.text[u]))}}else s.length==n.ranges.length&&e.options.pasteLinesPerSelection&&(a=v(s,function(e){return[e]}));for(var c,f=n.ranges.length-1;f>=0;f--){var h=n.ranges[f],d=h.from(),p=h.to();h.empty()&&(r&&r>0?d=E(d.line,d.ch-r):e.state.overwrite&&!l?p=E(p.line,Math.min(M(o,p.line).text.length,p.ch+g(s).length)):qs&&qs.lineWise&&qs.text.join("\n")==t&&(d=p=E(d.line,0))),c=e.curOp.updateInput;var m={from:d,to:p,text:a?a[f%a.length]:s,origin:i||(l?"paste":e.state.cutIncoming?"cut":"+input")};Oi(e.doc,m),bt(e,"inputRead",e,m)}t&&!l&&Zo(e,t),jr(e),e.curOp.updateInput=c,e.curOp.typing=!0,e.state.pasteIncoming=e.state.cutIncoming=!1}function qo(e,t){var r=e.clipboardData&&e.clipboardData.getData("Text");if(r)return e.preventDefault(),t.isReadOnly()||t.options.disableInput||hn(t,function(){return $o(t,r,0,null,"paste")}),!0}function Zo(e,t){if(e.options.electricChars&&e.options.smartIndent)for(var r=e.doc.sel,n=r.ranges.length-1;n>=0;n--){var i=r.ranges[n];if(!(i.head.ch>100||n&&r.ranges[n-1].head.line==i.head.line)){var o=e.getModeAt(i.head),l=!1;if(o.electricChars){for(var s=0;s<o.electricChars.length;s++)if(t.indexOf(o.electricChars.charAt(s))>-1){l=Yo(e,i.head.line,"smart");break}}else o.electricInput&&o.electricInput.test(M(e.doc,i.head.line).text.slice(0,i.head.ch))&&(l=Yo(e,i.head.line,"smart"));l&&bt(e,"electricInput",e,i.head.line)}}}function Qo(e){for(var t=[],r=[],n=0;n<e.doc.sel.ranges.length;n++){var i=e.doc.sel.ranges[n].head.line,o={anchor:E(i,0),head:E(i+1,0)};r.push(o),t.push(e.getRange(o.anchor,o.head))}return{text:t,ranges:r}}function Jo(e,t){e.setAttribute("autocorrect","off"),e.setAttribute("autocapitalize","off"),e.setAttribute("spellcheck",!!t)}function el(){var e=n("textarea",null,null,"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none"),t=n("div",[e],null,"overflow: hidden; position: relative; width: 3px; height: 0px;");return ml?e.style.width="1000px":e.setAttribute("wrap","off"),Ll&&(e.style.border="1px solid black"),Jo(e),t}function tl(e,t,r,n,i){function o(){var n=t.line+r;return!(n<e.first||n>=e.first+e.size)&&(t=new E(n,t.ch,t.sticky),u=M(e,n))}function l(n){var l;if(null==(l=i?go(e.cm,u,t,r):ho(u,t,r))){if(n||!o())return!1;t=po(i,e.cm,u,t.line,r)}else t=l;return!0}var s=t,a=r,u=M(e,t.line);if("char"==n)l();else if("column"==n)l(!0);else if("word"==n||"group"==n)for(var c=null,f="group"==n,h=e.cm&&e.cm.getHelper(t,"wordChars"),d=!0;!(r<0)||l(!d);d=!1){var p=u.text.charAt(t.ch)||"\n",g=x(p,h)?"w":f&&"\n"==p?"n":!f||/\s/.test(p)?null:"p";if(!f||d||g||(g="s"),c&&c!=g){r<0&&(r=1,l(),t.sticky="after");break}if(g&&(c=g),r>0&&!l(!d))break}var v=ki(e,t,s,a,!0);return I(s,v)&&(v.hitSide=!0),v}function rl(e,t,r,n){var i,o=e.doc,l=t.left;if("page"==n){var s=Math.min(e.display.wrapper.clientHeight,window.innerHeight||document.documentElement.clientHeight),a=Math.max(s-.5*mr(e.display),3);i=(r>0?t.bottom:t.top)+r*a}else"line"==n&&(i=r>0?t.bottom+3:t.top-3);for(var u;(u=cr(e,l,i)).outside;){if(r<0?i<=0:i>=o.height){u.hitSide=!0;break}i+=5*r}return u}function nl(e,t){var r=jt(e,t.line);if(!r||r.hidden)return null;var n=M(e.doc,t.line),i=Ut(r,n,t.line),o=Se(n,e.doc.direction),l="left";o&&(l=Ce(o,t.ch)%2?"right":"left");var s=_t(i.map,t.ch,l);return s.offset="right"==s.collapse?s.end:s.start,s}function il(e){for(var t=e;t;t=t.parentNode)if(/CodeMirror-gutter-wrapper/.test(t.className))return!0;return!1}function ol(e,t){return t&&(e.bad=!0),e}function ll(e,t,r,n,i){function o(e){return function(t){return t.id==e}}function l(){c&&(u+=f,c=!1)}function s(e){e&&(l(),u+=e)}function a(t){if(1==t.nodeType){var r=t.getAttribute("cm-text");if(null!=r)return void s(r||t.textContent.replace(/\u200b/g,""));var u,h=t.getAttribute("cm-marker");if(h){var d=e.findMarks(E(n,0),E(i+1,0),o(+h));return void(d.length&&(u=d[0].find(0))&&s(N(e.doc,u.from,u.to).join(f)))}if("false"==t.getAttribute("contenteditable"))return;var p=/^(pre|div|p)$/i.test(t.nodeName);p&&l();for(var g=0;g<t.childNodes.length;g++)a(t.childNodes[g]);p&&(c=!0)}else 3==t.nodeType&&s(t.nodeValue)}for(var u="",c=!1,f=e.doc.lineSeparator();a(t),t!=r;)t=t.nextSibling;return u}function sl(e,t,r){var n;if(t==e.display.lineDiv){if(!(n=e.display.lineDiv.childNodes[r]))return ol(e.clipPos(E(e.display.viewTo-1)),!0);t=null,r=0}else for(n=t;;n=n.parentNode){if(!n||n==e.display.lineDiv)return null;if(n.parentNode&&n.parentNode==e.display.lineDiv)break}for(var i=0;i<e.display.view.length;i++){var o=e.display.view[i];if(o.node==n)return al(o,t,r)}}function al(e,t,r){function n(t,r,n){for(var i=-1;i<(f?f.length:0);i++)for(var o=i<0?c.map:f[i],l=0;l<o.length;l+=3){var s=o[l+2];if(s==t||s==r){var a=W(i<0?e.line:e.rest[i]),u=o[l]+n;return(n<0||s!=t)&&(u=o[l+(n?1:0)]),E(a,u)}}}var i=e.text.firstChild,l=!1;if(!t||!o(i,t))return ol(E(W(e.line),0),!0);if(t==i&&(l=!0,t=i.childNodes[r],r=0,!t)){var s=e.rest?g(e.rest):e.line;return ol(E(W(s),s.text.length),l)}var a=3==t.nodeType?t:null,u=t;for(a||1!=t.childNodes.length||3!=t.firstChild.nodeType||(a=t.firstChild,r&&(r=a.nodeValue.length));u.parentNode!=i;)u=u.parentNode;var c=e.measure,f=c.maps,h=n(a,u,r);if(h)return ol(h,l);for(var d=u.nextSibling,p=a?a.nodeValue.length-r:0;d;d=d.nextSibling){if(h=n(d,d.firstChild,0))return ol(E(h.line,h.ch-p),l);p+=d.textContent.length}for(var v=u.previousSibling,m=r;v;v=v.previousSibling){if(h=n(v,v.firstChild,-1))return ol(E(h.line,h.ch+m),l);m+=v.textContent.length}}var ul=navigator.userAgent,cl=navigator.platform,fl=/gecko\/\d/i.test(ul),hl=/MSIE \d/.test(ul),dl=/Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(ul),pl=/Edge\/(\d+)/.exec(ul),gl=hl||dl||pl,vl=gl&&(hl?document.documentMode||6:+(pl||dl)[1]),ml=!pl&&/WebKit\//.test(ul),yl=ml&&/Qt\/\d+\.\d+/.test(ul),bl=!pl&&/Chrome\//.test(ul),wl=/Opera\//.test(ul),xl=/Apple Computer/.test(navigator.vendor),Cl=/Mac OS X 1\d\D([8-9]|\d\d)\D/.test(ul),Sl=/PhantomJS/.test(ul),Ll=!pl&&/AppleWebKit/.test(ul)&&/Mobile\/\w+/.test(ul),kl=/Android/.test(ul),Tl=Ll||kl||/webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(ul),Ml=Ll||/Mac/.test(cl),Nl=/\bCrOS\b/.test(ul),Ol=/win/i.test(cl),Al=wl&&ul.match(/Version\/(\d*\.\d*)/);Al&&(Al=Number(Al[1])),Al&&Al>=15&&(wl=!1,ml=!0);var Wl,Dl=Ml&&(yl||wl&&(null==Al||Al<12.11)),Hl=fl||gl&&vl>=9,Fl=function(t,r){var n=t.className,i=e(r).exec(n);if(i){var o=n.slice(i.index+i[0].length);t.className=n.slice(0,i.index)+(o?i[1]+o:"")}};Wl=document.createRange?function(e,t,r,n){var i=document.createRange();return i.setEnd(n||e,r),i.setStart(e,t),i}:function(e,t,r){var n=document.body.createTextRange();try{n.moveToElementText(e.parentNode)}catch(e){return n}return n.collapse(!0),n.moveEnd("character",r),n.moveStart("character",t),n};var El=function(e){e.select()};Ll?El=function(e){e.selectionStart=0,e.selectionEnd=e.value.length}:gl&&(El=function(e){try{e.select()}catch(e){}});var Pl=function(){this.id=null};Pl.prototype.set=function(e,t){clearTimeout(this.id),this.id=setTimeout(t,e)};var Il,zl,Rl=30,Bl={toString:function(){return"CodeMirror.Pass"}},Gl={scroll:!1},Ul={origin:"*mouse"},Vl={origin:"+move"},Kl=[""],jl=/[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/,Xl=/[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/,Yl=!1,_l=!1,$l=null,ql=function(){function e(e){return e<=247?r.charAt(e):1424<=e&&e<=1524?"R":1536<=e&&e<=1785?n.charAt(e-1536):1774<=e&&e<=2220?"r":8192<=e&&e<=8203?"w":8204==e?"b":"L"}function t(e,t,r){this.level=e,this.from=t,this.to=r}var r="bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN",n="nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111",i=/[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/,o=/[stwN]/,l=/[LRr]/,s=/[Lb1n]/,a=/[1n]/;return function(r,n){var u="ltr"==n?"L":"R";if(0==r.length||"ltr"==n&&!i.test(r))return!1;for(var c=r.length,f=[],h=0;h<c;++h)f.push(e(r.charCodeAt(h)));for(var d=0,p=u;d<c;++d){var v=f[d];"m"==v?f[d]=p:p=v}for(var m=0,y=u;m<c;++m){var b=f[m];"1"==b&&"r"==y?f[m]="n":l.test(b)&&(y=b,"r"==b&&(f[m]="R"))}for(var w=1,x=f[0];w<c-1;++w){var C=f[w];"+"==C&&"1"==x&&"1"==f[w+1]?f[w]="1":","!=C||x!=f[w+1]||"1"!=x&&"n"!=x||(f[w]=x),x=C}for(var S=0;S<c;++S){var L=f[S];if(","==L)f[S]="N";else if("%"==L){var k=void 0;for(k=S+1;k<c&&"%"==f[k];++k);for(var T=S&&"!"==f[S-1]||k<c&&"1"==f[k]?"1":"N",M=S;M<k;++M)f[M]=T;S=k-1}}for(var N=0,O=u;N<c;++N){var A=f[N];"L"==O&&"1"==A?f[N]="L":l.test(A)&&(O=A)}for(var W=0;W<c;++W)if(o.test(f[W])){var D=void 0;for(D=W+1;D<c&&o.test(f[D]);++D);for(var H="L"==(W?f[W-1]:u),F=H==("L"==(D<c?f[D]:u))?H?"L":"R":u,E=W;E<D;++E)f[E]=F;W=D-1}for(var P,I=[],z=0;z<c;)if(s.test(f[z])){var R=z;for(++z;z<c&&s.test(f[z]);++z);I.push(new t(0,R,z))}else{var B=z,G=I.length;for(++z;z<c&&"L"!=f[z];++z);for(var U=B;U<z;)if(a.test(f[U])){B<U&&I.splice(G,0,new t(1,B,U));var V=U;for(++U;U<z&&a.test(f[U]);++U);I.splice(G,0,new t(2,V,U)),B=U}else++U;B<z&&I.splice(G,0,new t(1,B,z))}return 1==I[0].level&&(P=r.match(/^\s+/))&&(I[0].from=P[0].length,I.unshift(new t(0,0,P[0].length))),1==g(I).level&&(P=r.match(/\s+$/))&&(g(I).to-=P[0].length,I.push(new t(0,c-P[0].length,c))),"rtl"==n?I.reverse():I}}(),Zl=[],Ql=function(e,t,r){if(e.addEventListener)e.addEventListener(t,r,!1);else if(e.attachEvent)e.attachEvent("on"+t,r);else{var n=e._handlers||(e._handlers={});n[t]=(n[t]||Zl).concat(r)}},Jl=function(){if(gl&&vl<9)return!1;var e=n("div");return"draggable"in e||"dragDrop"in e}(),es=3!="\n\nb".split(/\n/).length?function(e){for(var t=0,r=[],n=e.length;t<=n;){var i=e.indexOf("\n",t);-1==i&&(i=e.length);var o=e.slice(t,"\r"==e.charAt(i-1)?i-1:i),l=o.indexOf("\r");-1!=l?(r.push(o.slice(0,l)),t+=l+1):(r.push(o),t=i+1)}return r}:function(e){return e.split(/\r\n?|\n/)},ts=window.getSelection?function(e){try{return e.selectionStart!=e.selectionEnd}catch(e){return!1}}:function(e){var t;try{t=e.ownerDocument.selection.createRange()}catch(e){}return!(!t||t.parentElement()!=e)&&0!=t.compareEndPoints("StartToEnd",t)},rs=function(){var e=n("div");return"oncopy"in e||(e.setAttribute("oncopy","return;"),"function"==typeof e.oncopy)}(),ns=null,is={},os={},ls={},ss=function(e,t,r){this.pos=this.start=0,this.string=e,this.tabSize=t||8,this.lastColumnPos=this.lastColumnValue=0,this.lineStart=0,this.lineOracle=r};ss.prototype.eol=function(){return this.pos>=this.string.length},ss.prototype.sol=function(){return this.pos==this.lineStart},ss.prototype.peek=function(){return this.string.charAt(this.pos)||void 0},ss.prototype.next=function(){if(this.pos<this.string.length)return this.string.charAt(this.pos++)},ss.prototype.eat=function(e){var t=this.string.charAt(this.pos);if("string"==typeof e?t==e:t&&(e.test?e.test(t):e(t)))return++this.pos,t},ss.prototype.eatWhile=function(e){for(var t=this.pos;this.eat(e););return this.pos>t},ss.prototype.eatSpace=function(){for(var e=this,t=this.pos;/[\s\u00a0]/.test(this.string.charAt(this.pos));)++e.pos;return this.pos>t},ss.prototype.skipToEnd=function(){this.pos=this.string.length},ss.prototype.skipTo=function(e){var t=this.string.indexOf(e,this.pos);if(t>-1)return this.pos=t,!0},ss.prototype.backUp=function(e){this.pos-=e},ss.prototype.column=function(){return this.lastColumnPos<this.start&&(this.lastColumnValue=f(this.string,this.start,this.tabSize,this.lastColumnPos,this.lastColumnValue),this.lastColumnPos=this.start),this.lastColumnValue-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.indentation=function(){return f(this.string,null,this.tabSize)-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.match=function(e,t,r){if("string"!=typeof e){var n=this.string.slice(this.pos).match(e);return n&&n.index>0?null:(n&&!1!==t&&(this.pos+=n[0].length),n)}var i=function(e){return r?e.toLowerCase():e};if(i(this.string.substr(this.pos,e.length))==i(e))return!1!==t&&(this.pos+=e.length),!0},ss.prototype.current=function(){return this.string.slice(this.start,this.pos)},ss.prototype.hideFirstChars=function(e,t){this.lineStart+=e;try{return t()}finally{this.lineStart-=e}},ss.prototype.lookAhead=function(e){var t=this.lineOracle;return t&&t.lookAhead(e)};var as=function(e,t){this.state=e,this.lookAhead=t},us=function(e,t,r,n){this.state=t,this.doc=e,this.line=r,this.maxLookAhead=n||0};us.prototype.lookAhead=function(e){var t=this.doc.getLine(this.line+e);return null!=t&&e>this.maxLookAhead&&(this.maxLookAhead=e),t},us.prototype.nextLine=function(){this.line++,this.maxLookAhead>0&&this.maxLookAhead--},us.fromSaved=function(e,t,r){return t instanceof as?new us(e,Ke(e.mode,t.state),r,t.lookAhead):new us(e,Ke(e.mode,t),r)},us.prototype.save=function(e){var t=!1!==e?Ke(this.doc.mode,this.state):this.state;return this.maxLookAhead>0?new as(t,this.maxLookAhead):t};var cs=function(e,t,r){this.start=e.start,this.end=e.pos,this.string=e.current(),this.type=t||null,this.state=r},fs=function(e,t,r){this.text=e,ne(this,t),this.height=r?r(this):1};fs.prototype.lineNo=function(){return W(this)},Ae(fs);var hs,ds={},ps={},gs=null,vs=null,ms={left:0,right:0,top:0,bottom:0},ys=function(e,t,r){this.cm=r;var i=this.vert=n("div",[n("div",null,null,"min-width: 1px")],"CodeMirror-vscrollbar"),o=this.horiz=n("div",[n("div",null,null,"height: 100%; min-height: 1px")],"CodeMirror-hscrollbar");e(i),e(o),Ql(i,"scroll",function(){i.clientHeight&&t(i.scrollTop,"vertical")}),Ql(o,"scroll",function(){o.clientWidth&&t(o.scrollLeft,"horizontal")}),this.checkedZeroWidth=!1,gl&&vl<8&&(this.horiz.style.minHeight=this.vert.style.minWidth="18px")};ys.prototype.update=function(e){var t=e.scrollWidth>e.clientWidth+1,r=e.scrollHeight>e.clientHeight+1,n=e.nativeBarWidth;if(r){this.vert.style.display="block",this.vert.style.bottom=t?n+"px":"0";var i=e.viewHeight-(t?n:0);this.vert.firstChild.style.height=Math.max(0,e.scrollHeight-e.clientHeight+i)+"px"}else this.vert.style.display="",this.vert.firstChild.style.height="0";if(t){this.horiz.style.display="block",this.horiz.style.right=r?n+"px":"0",this.horiz.style.left=e.barLeft+"px";var o=e.viewWidth-e.barLeft-(r?n:0);this.horiz.firstChild.style.width=Math.max(0,e.scrollWidth-e.clientWidth+o)+"px"}else this.horiz.style.display="",this.horiz.firstChild.style.width="0";return!this.checkedZeroWidth&&e.clientHeight>0&&(0==n&&this.zeroWidthHack(),this.checkedZeroWidth=!0),{right:r?n:0,bottom:t?n:0}},ys.prototype.setScrollLeft=function(e){this.horiz.scrollLeft!=e&&(this.horiz.scrollLeft=e),this.disableHoriz&&this.enableZeroWidthBar(this.horiz,this.disableHoriz,"horiz")},ys.prototype.setScrollTop=function(e){this.vert.scrollTop!=e&&(this.vert.scrollTop=e),this.disableVert&&this.enableZeroWidthBar(this.vert,this.disableVert,"vert")},ys.prototype.zeroWidthHack=function(){var e=Ml&&!Cl?"12px":"18px";this.horiz.style.height=this.vert.style.width=e,this.horiz.style.pointerEvents=this.vert.style.pointerEvents="none",this.disableHoriz=new Pl,this.disableVert=new Pl},ys.prototype.enableZeroWidthBar=function(e,t,r){function n(){var i=e.getBoundingClientRect();("vert"==r?document.elementFromPoint(i.right-1,(i.top+i.bottom)/2):document.elementFromPoint((i.right+i.left)/2,i.bottom-1))!=e?e.style.pointerEvents="none":t.set(1e3,n)}e.style.pointerEvents="auto",t.set(1e3,n)},ys.prototype.clear=function(){var e=this.horiz.parentNode;e.removeChild(this.horiz),e.removeChild(this.vert)};var bs=function(){};bs.prototype.update=function(){return{bottom:0,right:0}},bs.prototype.setScrollLeft=function(){},bs.prototype.setScrollTop=function(){},bs.prototype.clear=function(){};var ws={native:ys,null:bs},xs=0,Cs=function(e,t,r){var n=e.display;this.viewport=t,this.visible=Ir(n,e.doc,t),this.editorIsHidden=!n.wrapper.offsetWidth,this.wrapperHeight=n.wrapper.clientHeight,this.wrapperWidth=n.wrapper.clientWidth,this.oldDisplayWidth=Rt(e),this.force=r,this.dims=br(e),this.events=[]};Cs.prototype.signal=function(e,t){Oe(e,t)&&this.events.push(arguments)},Cs.prototype.finish=function(){for(var e=this,t=0;t<this.events.length;t++)Te.apply(null,e.events[t])};var Ss=0,Ls=null;gl?Ls=-.53:fl?Ls=15:bl?Ls=-.7:xl&&(Ls=-1/3);var ks=function(e,t){this.ranges=e,this.primIndex=t};ks.prototype.primary=function(){return this.ranges[this.primIndex]},ks.prototype.equals=function(e){var t=this;if(e==this)return!0;if(e.primIndex!=this.primIndex||e.ranges.length!=this.ranges.length)return!1;for(var r=0;r<this.ranges.length;r++){var n=t.ranges[r],i=e.ranges[r];if(!I(n.anchor,i.anchor)||!I(n.head,i.head))return!1}return!0},ks.prototype.deepCopy=function(){for(var e=this,t=[],r=0;r<this.ranges.length;r++)t[r]=new Ts(z(e.ranges[r].anchor),z(e.ranges[r].head));return new ks(t,this.primIndex)},ks.prototype.somethingSelected=function(){for(var e=this,t=0;t<this.ranges.length;t++)if(!e.ranges[t].empty())return!0;return!1},ks.prototype.contains=function(e,t){var r=this;t||(t=e);for(var n=0;n<this.ranges.length;n++){var i=r.ranges[n];if(P(t,i.from())>=0&&P(e,i.to())<=0)return n}return-1};var Ts=function(e,t){this.anchor=e,this.head=t};Ts.prototype.from=function(){return B(this.anchor,this.head)},Ts.prototype.to=function(){return R(this.anchor,this.head)},Ts.prototype.empty=function(){return this.head.line==this.anchor.line&&this.head.ch==this.anchor.ch},Bi.prototype={chunkSize:function(){return this.lines.length},removeInner:function(e,t){for(var r=this,n=e,i=e+t;n<i;++n){var o=r.lines[n];r.height-=o.height,ot(o),bt(o,"delete")}this.lines.splice(e,t)},collapse:function(e){e.push.apply(e,this.lines)},insertInner:function(e,t,r){var n=this;this.height+=r,this.lines=this.lines.slice(0,e).concat(t).concat(this.lines.slice(e));for(var i=0;i<t.length;++i)t[i].parent=n},iterN:function(e,t,r){for(var n=this,i=e+t;e<i;++e)if(r(n.lines[e]))return!0}},Gi.prototype={chunkSize:function(){return this.size},removeInner:function(e,t){var r=this;this.size-=t;for(var n=0;n<this.children.length;++n){var i=r.children[n],o=i.chunkSize();if(e<o){var l=Math.min(t,o-e),s=i.height;if(i.removeInner(e,l),r.height-=s-i.height,o==l&&(r.children.splice(n--,1),i.parent=null),0==(t-=l))break;e=0}else e-=o}if(this.size-t<25&&(this.children.length>1||!(this.children[0]instanceof Bi))){var a=[];this.collapse(a),this.children=[new Bi(a)],this.children[0].parent=this}},collapse:function(e){for(var t=this,r=0;r<this.children.length;++r)t.children[r].collapse(e)},insertInner:function(e,t,r){var n=this;this.size+=t.length,this.height+=r;for(var i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<=l){if(o.insertInner(e,t,r),o.lines&&o.lines.length>50){for(var s=o.lines.length%25+25,a=s;a<o.lines.length;){var u=new Bi(o.lines.slice(a,a+=25));o.height-=u.height,n.children.splice(++i,0,u),u.parent=n}o.lines=o.lines.slice(0,s),n.maybeSpill()}break}e-=l}},maybeSpill:function(){if(!(this.children.length<=10)){var e=this;do{var t=new Gi(e.children.splice(e.children.length-5,5));if(e.parent){e.size-=t.size,e.height-=t.height;var r=h(e.parent.children,e);e.parent.children.splice(r+1,0,t)}else{var n=new Gi(e.children);n.parent=e,e.children=[n,t],e=n}t.parent=e.parent}while(e.children.length>10);e.parent.maybeSpill()}},iterN:function(e,t,r){for(var n=this,i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<l){var s=Math.min(t,l-e);if(o.iterN(e,s,r))return!0;if(0==(t-=s))break;e=0}else e-=l}}};var Ms=function(e,t,r){var n=this;if(r)for(var i in r)r.hasOwnProperty(i)&&(n[i]=r[i]);this.doc=e,this.node=t};Ms.prototype.clear=function(){var e=this,t=this.doc.cm,r=this.line.widgets,n=this.line,i=W(n);if(null!=i&&r){for(var o=0;o<r.length;++o)r[o]==e&&r.splice(o--,1);r.length||(n.widgets=null);var l=Ht(this);A(n,Math.max(0,n.height-l)),t&&(hn(t,function(){Ui(t,n,-l),mn(t,i,"widget")}),bt(t,"lineWidgetCleared",t,this,i))}},Ms.prototype.changed=function(){var e=this,t=this.height,r=this.doc.cm,n=this.line;this.height=null;var i=Ht(this)-t;i&&(A(n,n.height+i),r&&hn(r,function(){r.curOp.forceUpdate=!0,Ui(r,n,i),bt(r,"lineWidgetChanged",r,e,W(n))}))},Ae(Ms);var Ns=0,Os=function(e,t){this.lines=[],this.type=t,this.doc=e,this.id=++Ns};Os.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){var t=this.doc.cm,r=t&&!t.curOp;if(r&&nn(t),Oe(this,"clear")){var n=this.find();n&&bt(this,"clear",n.from,n.to)}for(var i=null,o=null,l=0;l<this.lines.length;++l){var s=e.lines[l],a=_(s.markedSpans,e);t&&!e.collapsed?mn(t,W(s),"text"):t&&(null!=a.to&&(o=W(s)),null!=a.from&&(i=W(s))),s.markedSpans=$(s.markedSpans,a),null==a.from&&e.collapsed&&!ve(e.doc,s)&&t&&A(s,mr(t.display))}if(t&&this.collapsed&&!t.options.lineWrapping)for(var u=0;u<this.lines.length;++u){var c=fe(e.lines[u]),f=be(c);f>t.display.maxLineLength&&(t.display.maxLine=c,t.display.maxLineLength=f,t.display.maxLineChanged=!0)}null!=i&&t&&this.collapsed&&vn(t,i,o+1),this.lines.length=0,this.explicitlyCleared=!0,this.atomic&&this.doc.cantEdit&&(this.doc.cantEdit=!1,t&&Ci(t.doc)),t&&bt(t,"markerCleared",t,this,i,o),r&&on(t),this.parent&&this.parent.clear()}},Os.prototype.find=function(e,t){var r=this;null==e&&"bookmark"==this.type&&(e=1);for(var n,i,o=0;o<this.lines.length;++o){var l=r.lines[o],s=_(l.markedSpans,r);if(null!=s.from&&(n=E(t?l:W(l),s.from),-1==e))return n;if(null!=s.to&&(i=E(t?l:W(l),s.to),1==e))return i}return n&&{from:n,to:i}},Os.prototype.changed=function(){var e=this,t=this.find(-1,!0),r=this,n=this.doc.cm;t&&n&&hn(n,function(){var i=t.line,o=W(t.line),l=jt(n,o);if(l&&(Qt(l),n.curOp.selectionChanged=n.curOp.forceUpdate=!0),n.curOp.updateMaxLine=!0,!ve(r.doc,i)&&null!=r.height){var s=r.height;r.height=null;var a=Ht(r)-s;a&&A(i,i.height+a)}bt(n,"markerChanged",n,e)})},Os.prototype.attachLine=function(e){if(!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;t.maybeHiddenMarkers&&-1!=h(t.maybeHiddenMarkers,this)||(t.maybeUnhiddenMarkers||(t.maybeUnhiddenMarkers=[])).push(this)}this.lines.push(e)},Os.prototype.detachLine=function(e){if(this.lines.splice(h(this.lines,e),1),!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;(t.maybeHiddenMarkers||(t.maybeHiddenMarkers=[])).push(this)}},Ae(Os);var As=function(e,t){var r=this;this.markers=e,this.primary=t;for(var n=0;n<e.length;++n)e[n].parent=r};As.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){this.explicitlyCleared=!0;for(var t=0;t<this.markers.length;++t)e.markers[t].clear();bt(this,"clear")}},As.prototype.find=function(e,t){return this.primary.find(e,t)},Ae(As);var Ws=0,Ds=function(e,t,r,n,i){if(!(this instanceof Ds))return new Ds(e,t,r,n,i);null==r&&(r=0),Gi.call(this,[new Bi([new fs("",null)])]),this.first=r,this.scrollTop=this.scrollLeft=0,this.cantEdit=!1,this.cleanGeneration=1,this.modeFrontier=this.highlightFrontier=r;var o=E(r,0);this.sel=Rn(o),this.history=new Jn(null),this.id=++Ws,this.modeOption=t,this.lineSep=n,this.direction="rtl"==i?"rtl":"ltr",this.extend=!1,"string"==typeof e&&(e=this.splitLines(e)),_n(this,{from:o,to:o,text:e}),bi(this,Rn(o),Gl)};Ds.prototype=b(Gi.prototype,{constructor:Ds,iter:function(e,t,r){r?this.iterN(e-this.first,t-e,r):this.iterN(this.first,this.first+this.size,e)},insert:function(e,t){for(var r=0,n=0;n<t.length;++n)r+=t[n].height;this.insertInner(e-this.first,t,r)},remove:function(e,t){this.removeInner(e-this.first,t)},getValue:function(e){var t=O(this,this.first,this.first+this.size);return!1===e?t:t.join(e||this.lineSeparator())},setValue:gn(function(e){var t=E(this.first,0),r=this.first+this.size-1;Oi(this,{from:t,to:E(r,M(this,r).text.length),text:this.splitLines(e),origin:"setValue",full:!0},!0),this.cm&&Xr(this.cm,0,0),bi(this,Rn(t),Gl)}),replaceRange:function(e,t,r,n){Ei(this,e,t=U(this,t),r=r?U(this,r):t,n)},getRange:function(e,t,r){var n=N(this,U(this,e),U(this,t));return!1===r?n:n.join(r||this.lineSeparator())},getLine:function(e){var t=this.getLineHandle(e);return t&&t.text},getLineHandle:function(e){if(H(this,e))return M(this,e)},getLineNumber:function(e){return W(e)},getLineHandleVisualStart:function(e){return"number"==typeof e&&(e=M(this,e)),fe(e)},lineCount:function(){return this.size},firstLine:function(){return this.first},lastLine:function(){return this.first+this.size-1},clipPos:function(e){return U(this,e)},getCursor:function(e){var t=this.sel.primary();return null==e||"head"==e?t.head:"anchor"==e?t.anchor:"end"==e||"to"==e||!1===e?t.to():t.from()},listSelections:function(){return this.sel.ranges},somethingSelected:function(){return this.sel.somethingSelected()},setCursor:gn(function(e,t,r){vi(this,U(this,"number"==typeof e?E(e,t||0):e),null,r)}),setSelection:gn(function(e,t,r){vi(this,U(this,e),U(this,t||e),r)}),extendSelection:gn(function(e,t,r){di(this,U(this,e),t&&U(this,t),r)}),extendSelections:gn(function(e,t){pi(this,K(this,e),t)}),extendSelectionsBy:gn(function(e,t){pi(this,K(this,v(this.sel.ranges,e)),t)}),setSelections:gn(function(e,t,r){var n=this;if(e.length){for(var i=[],o=0;o<e.length;o++)i[o]=new Ts(U(n,e[o].anchor),U(n,e[o].head));null==t&&(t=Math.min(e.length-1,this.sel.primIndex)),bi(this,zn(i,t),r)}}),addSelection:gn(function(e,t,r){var n=this.sel.ranges.slice(0);n.push(new Ts(U(this,e),U(this,t||e))),bi(this,zn(n,n.length-1),r)}),getSelection:function(e){for(var t,r=this,n=this.sel.ranges,i=0;i<n.length;i++){var o=N(r,n[i].from(),n[i].to());t=t?t.concat(o):o}return!1===e?t:t.join(e||this.lineSeparator())},getSelections:function(e){for(var t=this,r=[],n=this.sel.ranges,i=0;i<n.length;i++){var o=N(t,n[i].from(),n[i].to());!1!==e&&(o=o.join(e||t.lineSeparator())),r[i]=o}return r},replaceSelection:function(e,t,r){for(var n=[],i=0;i<this.sel.ranges.length;i++)n[i]=e;this.replaceSelections(n,t,r||"+input")},replaceSelections:gn(function(e,t,r){for(var n=this,i=[],o=this.sel,l=0;l<o.ranges.length;l++){var s=o.ranges[l];i[l]={from:s.from(),to:s.to(),text:n.splitLines(e[l]),origin:r}}for(var a=t&&"end"!=t&&Kn(this,i,t),u=i.length-1;u>=0;u--)Oi(n,i[u]);a?yi(this,a):this.cm&&jr(this.cm)}),undo:gn(function(){Wi(this,"undo")}),redo:gn(function(){Wi(this,"redo")}),undoSelection:gn(function(){Wi(this,"undo",!0)}),redoSelection:gn(function(){Wi(this,"redo",!0)}),setExtending:function(e){this.extend=e},getExtending:function(){return this.extend},historySize:function(){for(var e=this.history,t=0,r=0,n=0;n<e.done.length;n++)e.done[n].ranges||++t;for(var i=0;i<e.undone.length;i++)e.undone[i].ranges||++r;return{undo:t,redo:r}},clearHistory:function(){this.history=new Jn(this.history.maxGeneration)},markClean:function(){this.cleanGeneration=this.changeGeneration(!0)},changeGeneration:function(e){return e&&(this.history.lastOp=this.history.lastSelOp=this.history.lastOrigin=null),this.history.generation},isClean:function(e){return this.history.generation==(e||this.cleanGeneration)},getHistory:function(){return{done:fi(this.history.done),undone:fi(this.history.undone)}},setHistory:function(e){var t=this.history=new Jn(this.history.maxGeneration);t.done=fi(e.done.slice(0),null,!0),t.undone=fi(e.undone.slice(0),null,!0)},setGutterMarker:gn(function(e,t,r){return Ri(this,e,"gutter",function(e){var n=e.gutterMarkers||(e.gutterMarkers={});return n[t]=r,!r&&C(n)&&(e.gutterMarkers=null),!0})}),clearGutter:gn(function(e){var t=this;this.iter(function(r){r.gutterMarkers&&r.gutterMarkers[e]&&Ri(t,r,"gutter",function(){return r.gutterMarkers[e]=null,C(r.gutterMarkers)&&(r.gutterMarkers=null),!0})})}),lineInfo:function(e){var t;if("number"==typeof e){if(!H(this,e))return null;if(t=e,!(e=M(this,e)))return null}else if(null==(t=W(e)))return null;return{line:t,handle:e,text:e.text,gutterMarkers:e.gutterMarkers,textClass:e.textClass,bgClass:e.bgClass,wrapClass:e.wrapClass,widgets:e.widgets}},addLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass";if(t[i]){if(e(n).test(t[i]))return!1;t[i]+=" "+n}else t[i]=n;return!0})}),removeLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass",o=t[i];if(!o)return!1;if(null==n)t[i]=null;else{var l=o.match(e(n));if(!l)return!1;var s=l.index+l[0].length;t[i]=o.slice(0,l.index)+(l.index&&s!=o.length?" ":"")+o.slice(s)||null}return!0})}),addLineWidget:gn(function(e,t,r){return Vi(this,e,t,r)}),removeLineWidget:function(e){e.clear()},markText:function(e,t,r){return Ki(this,U(this,e),U(this,t),r,r&&r.type||"range")},setBookmark:function(e,t){var r={replacedWith:t&&(null==t.nodeType?t.widget:t),insertLeft:t&&t.insertLeft,clearWhenEmpty:!1,shared:t&&t.shared,handleMouseEvents:t&&t.handleMouseEvents};return e=U(this,e),Ki(this,e,e,r,"bookmark")},findMarksAt:function(e){var t=[],r=M(this,(e=U(this,e)).line).markedSpans;if(r)for(var n=0;n<r.length;++n){var i=r[n];(null==i.from||i.from<=e.ch)&&(null==i.to||i.to>=e.ch)&&t.push(i.marker.parent||i.marker)}return t},findMarks:function(e,t,r){e=U(this,e),t=U(this,t);var n=[],i=e.line;return this.iter(e.line,t.line+1,function(o){var l=o.markedSpans;if(l)for(var s=0;s<l.length;s++){var a=l[s];null!=a.to&&i==e.line&&e.ch>=a.to||null==a.from&&i!=e.line||null!=a.from&&i==t.line&&a.from>=t.ch||r&&!r(a.marker)||n.push(a.marker.parent||a.marker)}++i}),n},getAllMarks:function(){var e=[];return this.iter(function(t){var r=t.markedSpans;if(r)for(var n=0;n<r.length;++n)null!=r[n].from&&e.push(r[n].marker)}),e},posFromIndex:function(e){var t,r=this.first,n=this.lineSeparator().length;return this.iter(function(i){var o=i.text.length+n;if(o>e)return t=e,!0;e-=o,++r}),U(this,E(r,t))},indexFromPos:function(e){var t=(e=U(this,e)).ch;if(e.line<this.first||e.ch<0)return 0;var r=this.lineSeparator().length;return this.iter(this.first,e.line,function(e){t+=e.text.length+r}),t},copy:function(e){var t=new Ds(O(this,this.first,this.first+this.size),this.modeOption,this.first,this.lineSep,this.direction);return t.scrollTop=this.scrollTop,t.scrollLeft=this.scrollLeft,t.sel=this.sel,t.extend=!1,e&&(t.history.undoDepth=this.history.undoDepth,t.setHistory(this.getHistory())),t},linkedDoc:function(e){e||(e={});var t=this.first,r=this.first+this.size;null!=e.from&&e.from>t&&(t=e.from),null!=e.to&&e.to<r&&(r=e.to);var n=new Ds(O(this,t,r),e.mode||this.modeOption,t,this.lineSep,this.direction);return e.sharedHist&&(n.history=this.history),(this.linked||(this.linked=[])).push({doc:n,sharedHist:e.sharedHist}),n.linked=[{doc:this,isParent:!0,sharedHist:e.sharedHist}],Yi(n,Xi(this)),n},unlinkDoc:function(e){var t=this;if(e instanceof jo&&(e=e.doc),this.linked)for(var r=0;r<this.linked.length;++r)if(t.linked[r].doc==e){t.linked.splice(r,1),e.unlinkDoc(t),_i(Xi(t));break}if(e.history==this.history){var n=[e.id];$n(e,function(e){return n.push(e.id)},!0),e.history=new Jn(null),e.history.done=fi(this.history.done,n),e.history.undone=fi(this.history.undone,n)}},iterLinkedDocs:function(e){$n(this,e)},getMode:function(){return this.mode},getEditor:function(){return this.cm},splitLines:function(e){return this.lineSep?e.split(this.lineSep):es(e)},lineSeparator:function(){return this.lineSep||"\n"},setDirection:gn(function(e){"rtl"!=e&&(e="ltr"),e!=this.direction&&(this.direction=e,this.iter(function(e){return e.order=null}),this.cm&&Qn(this.cm))})}),Ds.prototype.eachLine=Ds.prototype.iter;for(var Hs=0,Fs=!1,Es={3:"Enter",8:"Backspace",9:"Tab",13:"Enter",16:"Shift",17:"Ctrl",18:"Alt",19:"Pause",20:"CapsLock",27:"Esc",32:"Space",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"Left",38:"Up",39:"Right",40:"Down",44:"PrintScrn",45:"Insert",46:"Delete",59:";",61:"=",91:"Mod",92:"Mod",93:"Mod",106:"*",107:"=",109:"-",110:".",111:"/",127:"Delete",173:"-",186:";",187:"=",188:",",189:"-",190:".",191:"/",192:"`",219:"[",220:"\\",221:"]",222:"'",63232:"Up",63233:"Down",63234:"Left",63235:"Right",63272:"Delete",63273:"Home",63275:"End",63276:"PageUp",63277:"PageDown",63302:"Insert"},Ps=0;Ps<10;Ps++)Es[Ps+48]=Es[Ps+96]=String(Ps);for(var Is=65;Is<=90;Is++)Es[Is]=String.fromCharCode(Is);for(var zs=1;zs<=12;zs++)Es[zs+111]=Es[zs+63235]="F"+zs;var Rs={};Rs.basic={Left:"goCharLeft",Right:"goCharRight",Up:"goLineUp",Down:"goLineDown",End:"goLineEnd",Home:"goLineStartSmart",PageUp:"goPageUp",PageDown:"goPageDown",Delete:"delCharAfter",Backspace:"delCharBefore","Shift-Backspace":"delCharBefore",Tab:"defaultTab","Shift-Tab":"indentAuto",Enter:"newlineAndIndent",Insert:"toggleOverwrite",Esc:"singleSelection"},Rs.pcDefault={"Ctrl-A":"selectAll","Ctrl-D":"deleteLine","Ctrl-Z":"undo","Shift-Ctrl-Z":"redo","Ctrl-Y":"redo","Ctrl-Home":"goDocStart","Ctrl-End":"goDocEnd","Ctrl-Up":"goLineUp","Ctrl-Down":"goLineDown","Ctrl-Left":"goGroupLeft","Ctrl-Right":"goGroupRight","Alt-Left":"goLineStart","Alt-Right":"goLineEnd","Ctrl-Backspace":"delGroupBefore","Ctrl-Delete":"delGroupAfter","Ctrl-S":"save","Ctrl-F":"find","Ctrl-G":"findNext","Shift-Ctrl-G":"findPrev","Shift-Ctrl-F":"replace","Shift-Ctrl-R":"replaceAll","Ctrl-[":"indentLess","Ctrl-]":"indentMore","Ctrl-U":"undoSelection","Shift-Ctrl-U":"redoSelection","Alt-U":"redoSelection",fallthrough:"basic"},Rs.emacsy={"Ctrl-F":"goCharRight","Ctrl-B":"goCharLeft","Ctrl-P":"goLineUp","Ctrl-N":"goLineDown","Alt-F":"goWordRight","Alt-B":"goWordLeft","Ctrl-A":"goLineStart","Ctrl-E":"goLineEnd","Ctrl-V":"goPageDown","Shift-Ctrl-V":"goPageUp","Ctrl-D":"delCharAfter","Ctrl-H":"delCharBefore","Alt-D":"delWordAfter","Alt-Backspace":"delWordBefore","Ctrl-K":"killLine","Ctrl-T":"transposeChars","Ctrl-O":"openLine"},Rs.macDefault={"Cmd-A":"selectAll","Cmd-D":"deleteLine","Cmd-Z":"undo","Shift-Cmd-Z":"redo","Cmd-Y":"redo","Cmd-Home":"goDocStart","Cmd-Up":"goDocStart","Cmd-End":"goDocEnd","Cmd-Down":"goDocEnd","Alt-Left":"goGroupLeft","Alt-Right":"goGroupRight","Cmd-Left":"goLineLeft","Cmd-Right":"goLineRight","Alt-Backspace":"delGroupBefore","Ctrl-Alt-Backspace":"delGroupAfter","Alt-Delete":"delGroupAfter","Cmd-S":"save","Cmd-F":"find","Cmd-G":"findNext","Shift-Cmd-G":"findPrev","Cmd-Alt-F":"replace","Shift-Cmd-Alt-F":"replaceAll","Cmd-[":"indentLess","Cmd-]":"indentMore","Cmd-Backspace":"delWrappedLineLeft","Cmd-Delete":"delWrappedLineRight","Cmd-U":"undoSelection","Shift-Cmd-U":"redoSelection","Ctrl-Up":"goDocStart","Ctrl-Down":"goDocEnd",fallthrough:["basic","emacsy"]},Rs.default=Ml?Rs.macDefault:Rs.pcDefault;var Bs={selectAll:Mi,singleSelection:function(e){return e.setSelection(e.getCursor("anchor"),e.getCursor("head"),Gl)},killLine:function(e){return co(e,function(t){if(t.empty()){var r=M(e.doc,t.head.line).text.length;return t.head.ch==r&&t.head.line<e.lastLine()?{from:t.head,to:E(t.head.line+1,0)}:{from:t.head,to:E(t.head.line,r)}}return{from:t.from(),to:t.to()}})},deleteLine:function(e){return co(e,function(t){return{from:E(t.from().line,0),to:U(e.doc,E(t.to().line+1,0))}})},delLineLeft:function(e){return co(e,function(e){return{from:E(e.from().line,0),to:e.from()}})},delWrappedLineLeft:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5;return{from:e.coordsChar({left:0,top:r},"div"),to:t.from()}})},delWrappedLineRight:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5,n=e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div");return{from:t.from(),to:n}})},undo:function(e){return e.undo()},redo:function(e){return e.redo()},undoSelection:function(e){return e.undoSelection()},redoSelection:function(e){return e.redoSelection()},goDocStart:function(e){return e.extendSelection(E(e.firstLine(),0))},goDocEnd:function(e){return e.extendSelection(E(e.lastLine()))},goLineStart:function(e){return e.extendSelectionsBy(function(t){return vo(e,t.head.line)},{origin:"+move",bias:1})},goLineStartSmart:function(e){return e.extendSelectionsBy(function(t){return yo(e,t.head)},{origin:"+move",bias:1})},goLineEnd:function(e){return e.extendSelectionsBy(function(t){return mo(e,t.head.line)},{origin:"+move",bias:-1})},goLineRight:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div")},Vl)},goLineLeft:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:0,top:r},"div")},Vl)},goLineLeftSmart:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5,n=e.coordsChar({left:0,top:r},"div");return n.ch<e.getLine(n.line).search(/\S/)?yo(e,t.head):n},Vl)},goLineUp:function(e){return e.moveV(-1,"line")},goLineDown:function(e){return e.moveV(1,"line")},goPageUp:function(e){return e.moveV(-1,"page")},goPageDown:function(e){return e.moveV(1,"page")},goCharLeft:function(e){return e.moveH(-1,"char")},goCharRight:function(e){return e.moveH(1,"char")},goColumnLeft:function(e){return e.moveH(-1,"column")},goColumnRight:function(e){return e.moveH(1,"column")},goWordLeft:function(e){return e.moveH(-1,"word")},goGroupRight:function(e){return e.moveH(1,"group")},goGroupLeft:function(e){return e.moveH(-1,"group")},goWordRight:function(e){return e.moveH(1,"word")},delCharBefore:function(e){return e.deleteH(-1,"char")},delCharAfter:function(e){return e.deleteH(1,"char")},delWordBefore:function(e){return e.deleteH(-1,"word")},delWordAfter:function(e){return e.deleteH(1,"word")},delGroupBefore:function(e){return e.deleteH(-1,"group")},delGroupAfter:function(e){return e.deleteH(1,"group")},indentAuto:function(e){return e.indentSelection("smart")},indentMore:function(e){return e.indentSelection("add")},indentLess:function(e){return e.indentSelection("subtract")},insertTab:function(e){return e.replaceSelection("\t")},insertSoftTab:function(e){for(var t=[],r=e.listSelections(),n=e.options.tabSize,i=0;i<r.length;i++){var o=r[i].from(),l=f(e.getLine(o.line),o.ch,n);t.push(p(n-l%n))}e.replaceSelections(t)},defaultTab:function(e){e.somethingSelected()?e.indentSelection("add"):e.execCommand("insertTab")},transposeChars:function(e){return hn(e,function(){for(var t=e.listSelections(),r=[],n=0;n<t.length;n++)if(t[n].empty()){var i=t[n].head,o=M(e.doc,i.line).text;if(o)if(i.ch==o.length&&(i=new E(i.line,i.ch-1)),i.ch>0)i=new E(i.line,i.ch+1),e.replaceRange(o.charAt(i.ch-1)+o.charAt(i.ch-2),E(i.line,i.ch-2),i,"+transpose");else if(i.line>e.doc.first){var l=M(e.doc,i.line-1).text;l&&(i=new E(i.line,1),e.replaceRange(o.charAt(0)+e.doc.lineSeparator()+l.charAt(l.length-1),E(i.line-1,l.length-1),i,"+transpose"))}r.push(new Ts(i,i))}e.setSelections(r)})},newlineAndIndent:function(e){return hn(e,function(){for(var t=e.listSelections(),r=t.length-1;r>=0;r--)e.replaceRange(e.doc.lineSeparator(),t[r].anchor,t[r].head,"+input");t=e.listSelections();for(var n=0;n<t.length;n++)e.indentLine(t[n].from().line,null,!0);jr(e)})},openLine:function(e){return e.replaceSelection("\n","start")},toggleOverwrite:function(e){return e.toggleOverwrite()}},Gs=new Pl,Us=null,Vs=function(e,t,r){this.time=e,this.pos=t,this.button=r};Vs.prototype.compare=function(e,t,r){return this.time+400>e&&0==P(t,this.pos)&&r==this.button};var Ks,js,Xs={toString:function(){return"CodeMirror.Init"}},Ys={},_s={};jo.defaults=Ys,jo.optionHandlers=_s;var $s=[];jo.defineInitHook=function(e){return $s.push(e)};var qs=null,Zs=function(e){this.cm=e,this.lastAnchorNode=this.lastAnchorOffset=this.lastFocusNode=this.lastFocusOffset=null,this.polling=new Pl,this.composing=null,this.gracePeriod=!1,this.readDOMTimeout=null};Zs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()}),"cut"==e.type&&i.replaceSelection("",null,"cut");else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type&&i.operation(function(){i.setSelections(t.ranges,0,Gl),i.replaceSelection("",null,"cut")})}if(e.clipboardData){e.clipboardData.clearData();var r=qs.text.join("\n");if(e.clipboardData.setData("Text",r),e.clipboardData.getData("Text")==r)return void e.preventDefault()}var l=el(),s=l.firstChild;i.display.lineSpace.insertBefore(l,i.display.lineSpace.firstChild),s.value=qs.text.join("\n");var a=document.activeElement;El(s),setTimeout(function(){i.display.lineSpace.removeChild(l),a.focus(),a==o&&n.showPrimarySelection()},50)}}var r=this,n=this,i=n.cm,o=n.div=e.lineDiv;Jo(o,i.options.spellcheck),Ql(o,"paste",function(e){Me(i,e)||qo(e,i)||vl<=11&&setTimeout(dn(i,function(){return r.updateFromDOM()}),20)}),Ql(o,"compositionstart",function(e){r.composing={data:e.data,done:!1}}),Ql(o,"compositionupdate",function(e){r.composing||(r.composing={data:e.data,done:!1})}),Ql(o,"compositionend",function(e){r.composing&&(e.data!=r.composing.data&&r.readFromDOMSoon(),r.composing.done=!0)}),Ql(o,"touchstart",function(){return n.forceCompositionEnd()}),Ql(o,"input",function(){r.composing||r.readFromDOMSoon()}),Ql(o,"copy",t),Ql(o,"cut",t)},Zs.prototype.prepareSelection=function(){var e=Tr(this.cm,!1);return e.focus=this.cm.state.focused,e},Zs.prototype.showSelection=function(e,t){e&&this.cm.display.view.length&&((e.focus||t)&&this.showPrimarySelection(),this.showMultipleSelections(e))},Zs.prototype.showPrimarySelection=function(){var e=window.getSelection(),t=this.cm,r=t.doc.sel.primary(),n=r.from(),i=r.to();if(t.display.viewTo==t.display.viewFrom||n.line>=t.display.viewTo||i.line<t.display.viewFrom)e.removeAllRanges();else{var o=sl(t,e.anchorNode,e.anchorOffset),l=sl(t,e.focusNode,e.focusOffset);if(!o||o.bad||!l||l.bad||0!=P(B(o,l),n)||0!=P(R(o,l),i)){var s=t.display.view,a=n.line>=t.display.viewFrom&&nl(t,n)||{node:s[0].measure.map[2],offset:0},u=i.line<t.display.viewTo&&nl(t,i);if(!u){var c=s[s.length-1].measure,f=c.maps?c.maps[c.maps.length-1]:c.map;u={node:f[f.length-1],offset:f[f.length-2]-f[f.length-3]}}if(a&&u){var h,d=e.rangeCount&&e.getRangeAt(0);try{h=Wl(a.node,a.offset,u.offset,u.node)}catch(e){}h&&(!fl&&t.state.focused?(e.collapse(a.node,a.offset),h.collapsed||(e.removeAllRanges(),e.addRange(h))):(e.removeAllRanges(),e.addRange(h)),d&&null==e.anchorNode?e.addRange(d):fl&&this.startGracePeriod()),this.rememberSelection()}else e.removeAllRanges()}}},Zs.prototype.startGracePeriod=function(){var e=this;clearTimeout(this.gracePeriod),this.gracePeriod=setTimeout(function(){e.gracePeriod=!1,e.selectionChanged()&&e.cm.operation(function(){return e.cm.curOp.selectionChanged=!0})},20)},Zs.prototype.showMultipleSelections=function(e){r(this.cm.display.cursorDiv,e.cursors),r(this.cm.display.selectionDiv,e.selection)},Zs.prototype.rememberSelection=function(){var e=window.getSelection();this.lastAnchorNode=e.anchorNode,this.lastAnchorOffset=e.anchorOffset,this.lastFocusNode=e.focusNode,this.lastFocusOffset=e.focusOffset},Zs.prototype.selectionInEditor=function(){var e=window.getSelection();if(!e.rangeCount)return!1;var t=e.getRangeAt(0).commonAncestorContainer;return o(this.div,t)},Zs.prototype.focus=function(){"nocursor"!=this.cm.options.readOnly&&(this.selectionInEditor()||this.showSelection(this.prepareSelection(),!0),this.div.focus())},Zs.prototype.blur=function(){this.div.blur()},Zs.prototype.getField=function(){return this.div},Zs.prototype.supportsTouch=function(){return!0},Zs.prototype.receivedFocus=function(){function e(){t.cm.state.focused&&(t.pollSelection(),t.polling.set(t.cm.options.pollInterval,e))}var t=this;this.selectionInEditor()?this.pollSelection():hn(this.cm,function(){return t.cm.curOp.selectionChanged=!0}),this.polling.set(this.cm.options.pollInterval,e)},Zs.prototype.selectionChanged=function(){var e=window.getSelection();return e.anchorNode!=this.lastAnchorNode||e.anchorOffset!=this.lastAnchorOffset||e.focusNode!=this.lastFocusNode||e.focusOffset!=this.lastFocusOffset},Zs.prototype.pollSelection=function(){if(null==this.readDOMTimeout&&!this.gracePeriod&&this.selectionChanged()){var e=window.getSelection(),t=this.cm;if(kl&&bl&&this.cm.options.gutters.length&&il(e.anchorNode))return this.cm.triggerOnKeyDown({type:"keydown",keyCode:8,preventDefault:Math.abs}),this.blur(),void this.focus();if(!this.composing){this.rememberSelection();var r=sl(t,e.anchorNode,e.anchorOffset),n=sl(t,e.focusNode,e.focusOffset);r&&n&&hn(t,function(){bi(t.doc,Rn(r,n),Gl),(r.bad||n.bad)&&(t.curOp.selectionChanged=!0)})}}},Zs.prototype.pollContent=function(){null!=this.readDOMTimeout&&(clearTimeout(this.readDOMTimeout),this.readDOMTimeout=null);var e=this.cm,t=e.display,r=e.doc.sel.primary(),n=r.from(),i=r.to();if(0==n.ch&&n.line>e.firstLine()&&(n=E(n.line-1,M(e.doc,n.line-1).length)),i.ch==M(e.doc,i.line).text.length&&i.line<e.lastLine()&&(i=E(i.line+1,0)),n.line<t.viewFrom||i.line>t.viewTo-1)return!1;var o,l,s;n.line==t.viewFrom||0==(o=Lr(e,n.line))?(l=W(t.view[0].line),s=t.view[0].node):(l=W(t.view[o].line),s=t.view[o-1].node.nextSibling);var a,u,c=Lr(e,i.line);if(c==t.view.length-1?(a=t.viewTo-1,u=t.lineDiv.lastChild):(a=W(t.view[c+1].line)-1,u=t.view[c+1].node.previousSibling),!s)return!1;for(var f=e.doc.splitLines(ll(e,s,u,l,a)),h=N(e.doc,E(l,0),E(a,M(e.doc,a).text.length));f.length>1&&h.length>1;)if(g(f)==g(h))f.pop(),h.pop(),a--;else{if(f[0]!=h[0])break;f.shift(),h.shift(),l++}for(var d=0,p=0,v=f[0],m=h[0],y=Math.min(v.length,m.length);d<y&&v.charCodeAt(d)==m.charCodeAt(d);)++d;for(var b=g(f),w=g(h),x=Math.min(b.length-(1==f.length?d:0),w.length-(1==h.length?d:0));p<x&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)++p;if(1==f.length&&1==h.length&&l==n.line)for(;d&&d>n.ch&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)d--,p++;f[f.length-1]=b.slice(0,b.length-p).replace(/^\u200b+/,""),f[0]=f[0].slice(d).replace(/\u200b+$/,"");var C=E(l,d),S=E(a,h.length?g(h).length-p:0);return f.length>1||f[0]||P(C,S)?(Ei(e.doc,f,C,S,"+input"),!0):void 0},Zs.prototype.ensurePolled=function(){this.forceCompositionEnd()},Zs.prototype.reset=function(){this.forceCompositionEnd()},Zs.prototype.forceCompositionEnd=function(){this.composing&&(clearTimeout(this.readDOMTimeout),this.composing=null,this.updateFromDOM(),this.div.blur(),this.div.focus())},Zs.prototype.readFromDOMSoon=function(){var e=this;null==this.readDOMTimeout&&(this.readDOMTimeout=setTimeout(function(){if(e.readDOMTimeout=null,e.composing){if(!e.composing.done)return;e.composing=null}e.updateFromDOM()},80))},Zs.prototype.updateFromDOM=function(){var e=this;!this.cm.isReadOnly()&&this.pollContent()||hn(this.cm,function(){return vn(e.cm)})},Zs.prototype.setUneditable=function(e){e.contentEditable="false"},Zs.prototype.onKeyPress=function(e){0!=e.charCode&&(e.preventDefault(),this.cm.isReadOnly()||dn(this.cm,$o)(this.cm,String.fromCharCode(null==e.charCode?e.keyCode:e.charCode),0))},Zs.prototype.readOnlyChanged=function(e){this.div.contentEditable=String("nocursor"!=e)},Zs.prototype.onContextMenu=function(){},Zs.prototype.resetPosition=function(){},Zs.prototype.needsContentAttribute=!0;var Qs=function(e){this.cm=e,this.prevInput="",this.pollingFast=!1,this.polling=new Pl,this.hasSelection=!1,this.composing=null};Qs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()});else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type?i.setSelections(t.ranges,null,Gl):(n.prevInput="",l.value=t.text.join("\n"),El(l))}"cut"==e.type&&(i.state.cutIncoming=!0)}}var r=this,n=this,i=this.cm,o=this.wrapper=el(),l=this.textarea=o.firstChild;e.wrapper.insertBefore(o,e.wrapper.firstChild),Ll&&(l.style.width="0px"),Ql(l,"input",function(){gl&&vl>=9&&r.hasSelection&&(r.hasSelection=null),n.poll()}),Ql(l,"paste",function(e){Me(i,e)||qo(e,i)||(i.state.pasteIncoming=!0,n.fastPoll())}),Ql(l,"cut",t),Ql(l,"copy",t),Ql(e.scroller,"paste",function(t){Ft(e,t)||Me(i,t)||(i.state.pasteIncoming=!0,n.focus())}),Ql(e.lineSpace,"selectstart",function(t){Ft(e,t)||We(t)}),Ql(l,"compositionstart",function(){var e=i.getCursor("from");n.composing&&n.composing.range.clear(),n.composing={start:e,range:i.markText(e,i.getCursor("to"),{className:"CodeMirror-composing"})}}),Ql(l,"compositionend",function(){n.composing&&(n.poll(),n.composing.range.clear(),n.composing=null)})},Qs.prototype.prepareSelection=function(){var e=this.cm,t=e.display,r=e.doc,n=Tr(e);if(e.options.moveInputWithCursor){var i=sr(e,r.sel.primary().head,"div"),o=t.wrapper.getBoundingClientRect(),l=t.lineDiv.getBoundingClientRect();n.teTop=Math.max(0,Math.min(t.wrapper.clientHeight-10,i.top+l.top-o.top)),n.teLeft=Math.max(0,Math.min(t.wrapper.clientWidth-10,i.left+l.left-o.left))}return n},Qs.prototype.showSelection=function(e){var t=this.cm.display;r(t.cursorDiv,e.cursors),r(t.selectionDiv,e.selection),null!=e.teTop&&(this.wrapper.style.top=e.teTop+"px",this.wrapper.style.left=e.teLeft+"px")},Qs.prototype.reset=function(e){if(!this.contextMenuPending&&!this.composing){var t=this.cm;if(t.somethingSelected()){this.prevInput="";var r=t.getSelection();this.textarea.value=r,t.state.focused&&El(this.textarea),gl&&vl>=9&&(this.hasSelection=r)}else e||(this.prevInput=this.textarea.value="",gl&&vl>=9&&(this.hasSelection=null))}},Qs.prototype.getField=function(){return this.textarea},Qs.prototype.supportsTouch=function(){return!1},Qs.prototype.focus=function(){if("nocursor"!=this.cm.options.readOnly&&(!Tl||l()!=this.textarea))try{this.textarea.focus()}catch(e){}},Qs.prototype.blur=function(){this.textarea.blur()},Qs.prototype.resetPosition=function(){this.wrapper.style.top=this.wrapper.style.left=0},Qs.prototype.receivedFocus=function(){this.slowPoll()},Qs.prototype.slowPoll=function(){var e=this;this.pollingFast||this.polling.set(this.cm.options.pollInterval,function(){e.poll(),e.cm.state.focused&&e.slowPoll()})},Qs.prototype.fastPoll=function(){function e(){r.poll()||t?(r.pollingFast=!1,r.slowPoll()):(t=!0,r.polling.set(60,e))}var t=!1,r=this;r.pollingFast=!0,r.polling.set(20,e)},Qs.prototype.poll=function(){var e=this,t=this.cm,r=this.textarea,n=this.prevInput;if(this.contextMenuPending||!t.state.focused||ts(r)&&!n&&!this.composing||t.isReadOnly()||t.options.disableInput||t.state.keySeq)return!1;var i=r.value;if(i==n&&!t.somethingSelected())return!1;if(gl&&vl>=9&&this.hasSelection===i||Ml&&/[\uf700-\uf7ff]/.test(i))return t.display.input.reset(),!1;if(t.doc.sel==t.display.selForContextMenu){var o=i.charCodeAt(0);if(8203!=o||n||(n="​"),8666==o)return this.reset(),this.cm.execCommand("undo")}for(var l=0,s=Math.min(n.length,i.length);l<s&&n.charCodeAt(l)==i.charCodeAt(l);)++l;return hn(t,function(){$o(t,i.slice(l),n.length-l,null,e.composing?"*compose":null),i.length>1e3||i.indexOf("\n")>-1?r.value=e.prevInput="":e.prevInput=i,e.composing&&(e.composing.range.clear(),e.composing.range=t.markText(e.composing.start,t.getCursor("to"),{className:"CodeMirror-composing"}))}),!0},Qs.prototype.ensurePolled=function(){this.pollingFast&&this.poll()&&(this.pollingFast=!1)},Qs.prototype.onKeyPress=function(){gl&&vl>=9&&(this.hasSelection=null),this.fastPoll()},Qs.prototype.onContextMenu=function(e){function t(){if(null!=l.selectionStart){var e=i.somethingSelected(),t="​"+(e?l.value:"");l.value="⇚",l.value=t,n.prevInput=e?"":"​",l.selectionStart=1,l.selectionEnd=t.length,o.selForContextMenu=i.doc.sel}}function r(){if(n.contextMenuPending=!1,n.wrapper.style.cssText=c,l.style.cssText=u,gl&&vl<9&&o.scrollbars.setScrollTop(o.scroller.scrollTop=a),null!=l.selectionStart){(!gl||gl&&vl<9)&&t();var e=0,r=function(){o.selForContextMenu==i.doc.sel&&0==l.selectionStart&&l.selectionEnd>0&&"​"==n.prevInput?dn(i,Mi)(i):e++<10?o.detectingSelectAll=setTimeout(r,500):(o.selForContextMenu=null,o.input.reset())};o.detectingSelectAll=setTimeout(r,200)}}var n=this,i=n.cm,o=i.display,l=n.textarea,s=Sr(i,e),a=o.scroller.scrollTop;if(s&&!wl){i.options.resetSelectionOnContextMenu&&-1==i.doc.sel.contains(s)&&dn(i,bi)(i.doc,Rn(s),Gl);var u=l.style.cssText,c=n.wrapper.style.cssText;n.wrapper.style.cssText="position: absolute";var f=n.wrapper.getBoundingClientRect();l.style.cssText="position: absolute; width: 30px; height: 30px;\n      top: "+(e.clientY-f.top-5)+"px; left: "+(e.clientX-f.left-5)+"px;\n      z-index: 1000; background: "+(gl?"rgba(255, 255, 255, .05)":"transparent")+";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";var h;if(ml&&(h=window.scrollY),o.input.focus(),ml&&window.scrollTo(null,h),o.input.reset(),i.somethingSelected()||(l.value=n.prevInput=" "),n.contextMenuPending=!0,o.selForContextMenu=i.doc.sel,clearTimeout(o.detectingSelectAll),gl&&vl>=9&&t(),Hl){Fe(e);var d=function(){ke(window,"mouseup",d),setTimeout(r,20)};Ql(window,"mouseup",d)}else setTimeout(r,50)}},Qs.prototype.readOnlyChanged=function(e){e||this.reset(),this.textarea.disabled="nocursor"==e},Qs.prototype.setUneditable=function(){},Qs.prototype.needsContentAttribute=!1,function(e){function t(t,n,i,o){e.defaults[t]=n,i&&(r[t]=o?function(e,t,r){r!=Xs&&i(e,t,r)}:i)}var r=e.optionHandlers;e.defineOption=t,e.Init=Xs,t("value","",function(e,t){return e.setValue(t)},!0),t("mode",null,function(e,t){e.doc.modeOption=t,jn(e)},!0),t("indentUnit",2,jn,!0),t("indentWithTabs",!1),t("smartIndent",!0),t("tabSize",4,function(e){Xn(e),er(e),vn(e)},!0),t("lineSeparator",null,function(e,t){if(e.doc.lineSep=t,t){var r=[],n=e.doc.first;e.doc.iter(function(e){for(var i=0;;){var o=e.text.indexOf(t,i);if(-1==o)break;i=o+t.length,r.push(E(n,o))}n++});for(var i=r.length-1;i>=0;i--)Ei(e.doc,t,r[i],E(r[i].line,r[i].ch+t.length))}}),t("specialChars",/[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff]/g,function(e,t,r){e.state.specialChars=new RegExp(t.source+(t.test("\t")?"":"|\t"),"g"),r!=Xs&&e.refresh()}),t("specialCharPlaceholder",at,function(e){return e.refresh()},!0),t("electricChars",!0),t("inputStyle",Tl?"contenteditable":"textarea",function(){throw new Error("inputStyle can not (yet) be changed in a running editor")},!0),t("spellcheck",!1,function(e,t){return e.getInputField().spellcheck=t},!0),t("rtlMoveVisually",!Ol),t("wholeLineUpdateBefore",!0),t("theme","default",function(e){Go(e),Uo(e)},!0),t("keyMap","default",function(e,t,r){var n=uo(t),i=r!=Xs&&uo(r);i&&i.detach&&i.detach(e,n),n.attach&&n.attach(e,i||null)}),t("extraKeys",null),t("configureMouse",null),t("lineWrapping",!1,Ko,!0),t("gutters",[],function(e){Fn(e.options),Uo(e)},!0),t("fixedGutter",!0,function(e,t){e.display.gutters.style.left=t?wr(e.display)+"px":"0",e.refresh()},!0),t("coverGutterNextToScrollbar",!1,function(e){return en(e)},!0),t("scrollbarStyle","native",function(e){rn(e),en(e),e.display.scrollbars.setScrollTop(e.doc.scrollTop),e.display.scrollbars.setScrollLeft(e.doc.scrollLeft)},!0),t("lineNumbers",!1,function(e){Fn(e.options),Uo(e)},!0),t("firstLineNumber",1,Uo,!0),t("lineNumberFormatter",function(e){return e},Uo,!0),t("showCursorWhenSelecting",!1,kr,!0),t("resetSelectionOnContextMenu",!0),t("lineWiseCopyCut",!0),t("pasteLinesPerSelection",!0),t("readOnly",!1,function(e,t){"nocursor"==t&&(Fr(e),e.display.input.blur()),e.display.input.readOnlyChanged(t)}),t("disableInput",!1,function(e,t){t||e.display.input.reset()},!0),t("dragDrop",!0,Vo),t("allowDropFileTypes",null),t("cursorBlinkRate",530),t("cursorScrollMargin",0),t("cursorHeight",1,kr,!0),t("singleCursorHeightPerLine",!0,kr,!0),t("workTime",100),t("workDelay",100),t("flattenSpans",!0,Xn,!0),t("addModeClass",!1,Xn,!0),t("pollInterval",100),t("undoDepth",200,function(e,t){return e.doc.history.undoDepth=t}),t("historyEventDelay",1250),t("viewportMargin",10,function(e){return e.refresh()},!0),t("maxHighlightLength",1e4,Xn,!0),t("moveInputWithCursor",!0,function(e,t){t||e.display.input.resetPosition()}),t("tabindex",null,function(e,t){return e.display.input.getField().tabIndex=t||""}),t("autofocus",null),t("direction","ltr",function(e,t){return e.doc.setDirection(t)},!0)}(jo),function(e){var t=e.optionHandlers,r=e.helpers={};e.prototype={constructor:e,focus:function(){window.focus(),this.display.input.focus()},setOption:function(e,r){var n=this.options,i=n[e];n[e]==r&&"mode"!=e||(n[e]=r,t.hasOwnProperty(e)&&dn(this,t[e])(this,r,i),Te(this,"optionChange",this,e))},getOption:function(e){return this.options[e]},getDoc:function(){return this.doc},addKeyMap:function(e,t){this.state.keyMaps[t?"push":"unshift"](uo(e))},removeKeyMap:function(e){for(var t=this.state.keyMaps,r=0;r<t.length;++r)if(t[r]==e||t[r].name==e)return t.splice(r,1),!0},addOverlay:pn(function(t,r){var n=t.token?t:e.getMode(this.options,t);if(n.startState)throw new Error("Overlays may not be stateful.");m(this.state.overlays,{mode:n,modeSpec:t,opaque:r&&r.opaque,priority:r&&r.priority||0},function(e){return e.priority}),this.state.modeGen++,vn(this)}),removeOverlay:pn(function(e){for(var t=this,r=this.state.overlays,n=0;n<r.length;++n){var i=r[n].modeSpec;if(i==e||"string"==typeof e&&i.name==e)return r.splice(n,1),t.state.modeGen++,void vn(t)}}),indentLine:pn(function(e,t,r){"string"!=typeof t&&"number"!=typeof t&&(t=null==t?this.options.smartIndent?"smart":"prev":t?"add":"subtract"),H(this.doc,e)&&Yo(this,e,t,r)}),indentSelection:pn(function(e){for(var t=this,r=this.doc.sel.ranges,n=-1,i=0;i<r.length;i++){var o=r[i];if(o.empty())o.head.line>n&&(Yo(t,o.head.line,e,!0),n=o.head.line,i==t.doc.sel.primIndex&&jr(t));else{var l=o.from(),s=o.to(),a=Math.max(n,l.line);n=Math.min(t.lastLine(),s.line-(s.ch?0:1))+1;for(var u=a;u<n;++u)Yo(t,u,e);var c=t.doc.sel.ranges;0==l.ch&&r.length==c.length&&c[i].from().ch>0&&gi(t.doc,i,new Ts(l,c[i].to()),Gl)}}}),getTokenAt:function(e,t){return Je(this,e,t)},getLineTokens:function(e,t){return Je(this,E(e),t,!0)},getTokenTypeAt:function(e){e=U(this.doc,e);var t,r=_e(this,M(this.doc,e.line)),n=0,i=(r.length-1)/2,o=e.ch;if(0==o)t=r[2];else for(;;){var l=n+i>>1;if((l?r[2*l-1]:0)>=o)i=l;else{if(!(r[2*l+1]<o)){t=r[2*l+2];break}n=l+1}}var s=t?t.indexOf("overlay "):-1;return s<0?t:0==s?null:t.slice(0,s-1)},getModeAt:function(t){var r=this.doc.mode;return r.innerMode?e.innerMode(r,this.getTokenAt(t).state).mode:r},getHelper:function(e,t){return this.getHelpers(e,t)[0]},getHelpers:function(e,t){var n=this,i=[];if(!r.hasOwnProperty(t))return i;var o=r[t],l=this.getModeAt(e);if("string"==typeof l[t])o[l[t]]&&i.push(o[l[t]]);else if(l[t])for(var s=0;s<l[t].length;s++){var a=o[l[t][s]];a&&i.push(a)}else l.helperType&&o[l.helperType]?i.push(o[l.helperType]):o[l.name]&&i.push(o[l.name]);for(var u=0;u<o._global.length;u++){var c=o._global[u];c.pred(l,n)&&-1==h(i,c.val)&&i.push(c.val)}return i},getStateAfter:function(e,t){var r=this.doc;return e=G(r,null==e?r.first+r.size-1:e),$e(this,e+1,t).state},cursorCoords:function(e,t){var r,n=this.doc.sel.primary();return r=null==e?n.head:"object"==typeof e?U(this.doc,e):e?n.from():n.to(),sr(this,r,t||"page")},charCoords:function(e,t){return lr(this,U(this.doc,e),t||"page")},coordsChar:function(e,t){return e=or(this,e,t||"page"),cr(this,e.left,e.top)},lineAtHeight:function(e,t){return e=or(this,{top:e,left:0},t||"page").top,D(this.doc,e+this.display.viewOffset)},heightAtLine:function(e,t,r){var n,i=!1;if("number"==typeof e){var o=this.doc.first+this.doc.size-1;e<this.doc.first?e=this.doc.first:e>o&&(e=o,i=!0),n=M(this.doc,e)}else n=e;return ir(this,n,{top:0,left:0},t||"page",r||i).top+(i?this.doc.height-ye(n):0)},defaultTextHeight:function(){return mr(this.display)},defaultCharWidth:function(){return yr(this.display)},getViewport:function(){return{from:this.display.viewFrom,to:this.display.viewTo}},addWidget:function(e,t,r,n,i){var o=this.display,l=(e=sr(this,U(this.doc,e))).bottom,s=e.left;if(t.style.position="absolute",t.setAttribute("cm-ignore-events","true"),this.display.input.setUneditable(t),o.sizer.appendChild(t),"over"==n)l=e.top;else if("above"==n||"near"==n){var a=Math.max(o.wrapper.clientHeight,this.doc.height),u=Math.max(o.sizer.clientWidth,o.lineSpace.clientWidth);("above"==n||e.bottom+t.offsetHeight>a)&&e.top>t.offsetHeight?l=e.top-t.offsetHeight:e.bottom+t.offsetHeight<=a&&(l=e.bottom),s+t.offsetWidth>u&&(s=u-t.offsetWidth)}t.style.top=l+"px",t.style.left=t.style.right="","right"==i?(s=o.sizer.clientWidth-t.offsetWidth,t.style.right="0px"):("left"==i?s=0:"middle"==i&&(s=(o.sizer.clientWidth-t.offsetWidth)/2),t.style.left=s+"px"),r&&Ur(this,{left:s,top:l,right:s+t.offsetWidth,bottom:l+t.offsetHeight})},triggerOnKeyDown:pn(Lo),triggerOnKeyPress:pn(Mo),triggerOnKeyUp:To,triggerOnMouseDown:pn(Oo),execCommand:function(e){if(Bs.hasOwnProperty(e))return Bs[e].call(null,this)},triggerElectric:pn(function(e){Zo(this,e)}),findPosH:function(e,t,r,n){var i=this,o=1;t<0&&(o=-1,t=-t);for(var l=U(this.doc,e),s=0;s<t&&!(l=tl(i.doc,l,o,r,n)).hitSide;++s);return l},moveH:pn(function(e,t){var r=this;this.extendSelectionsBy(function(n){return r.display.shift||r.doc.extend||n.empty()?tl(r.doc,n.head,e,t,r.options.rtlMoveVisually):e<0?n.from():n.to()},Vl)}),deleteH:pn(function(e,t){var r=this.doc.sel,n=this.doc;r.somethingSelected()?n.replaceSelection("",null,"+delete"):co(this,function(r){var i=tl(n,r.head,e,t,!1);return e<0?{from:i,to:r.head}:{from:r.head,to:i}})}),findPosV:function(e,t,r,n){var i=this,o=1,l=n;t<0&&(o=-1,t=-t);for(var s=U(this.doc,e),a=0;a<t;++a){var u=sr(i,s,"div");if(null==l?l=u.left:u.left=l,(s=rl(i,u,o,r)).hitSide)break}return s},moveV:pn(function(e,t){var r=this,n=this.doc,i=[],o=!this.display.shift&&!n.extend&&n.sel.somethingSelected();if(n.extendSelectionsBy(function(l){if(o)return e<0?l.from():l.to();var s=sr(r,l.head,"div");null!=l.goalColumn&&(s.left=l.goalColumn),i.push(s.left);var a=rl(r,s,e,t);return"page"==t&&l==n.sel.primary()&&Kr(r,lr(r,a,"div").top-s.top),a},Vl),i.length)for(var l=0;l<n.sel.ranges.length;l++)n.sel.ranges[l].goalColumn=i[l]}),findWordAt:function(e){var t=M(this.doc,e.line).text,r=e.ch,n=e.ch;if(t){var i=this.getHelper(e,"wordChars");"before"!=e.sticky&&n!=t.length||!r?++n:--r;for(var o=t.charAt(r),l=x(o,i)?function(e){return x(e,i)}:/\s/.test(o)?function(e){return/\s/.test(e)}:function(e){return!/\s/.test(e)&&!x(e)};r>0&&l(t.charAt(r-1));)--r;for(;n<t.length&&l(t.charAt(n));)++n}return new Ts(E(e.line,r),E(e.line,n))},toggleOverwrite:function(e){null!=e&&e==this.state.overwrite||((this.state.overwrite=!this.state.overwrite)?s(this.display.cursorDiv,"CodeMirror-overwrite"):Fl(this.display.cursorDiv,"CodeMirror-overwrite"),Te(this,"overwriteToggle",this,this.state.overwrite))},hasFocus:function(){return this.display.input.getField()==l()},isReadOnly:function(){return!(!this.options.readOnly&&!this.doc.cantEdit)},scrollTo:pn(function(e,t){Xr(this,e,t)}),getScrollInfo:function(){var e=this.display.scroller;return{left:e.scrollLeft,top:e.scrollTop,height:e.scrollHeight-zt(this)-this.display.barHeight,width:e.scrollWidth-zt(this)-this.display.barWidth,clientHeight:Bt(this),clientWidth:Rt(this)}},scrollIntoView:pn(function(e,t){null==e?(e={from:this.doc.sel.primary().head,to:null},null==t&&(t=this.options.cursorScrollMargin)):"number"==typeof e?e={from:E(e,0),to:null}:null==e.from&&(e={from:e,to:null}),e.to||(e.to=e.from),e.margin=t||0,null!=e.from.line?Yr(this,e):$r(this,e.from,e.to,e.margin)}),setSize:pn(function(e,t){var r=this,n=function(e){return"number"==typeof e||/^\d+$/.test(String(e))?e+"px":e};null!=e&&(this.display.wrapper.style.width=n(e)),null!=t&&(this.display.wrapper.style.height=n(t)),this.options.lineWrapping&&Jt(this);var i=this.display.viewFrom;this.doc.iter(i,this.display.viewTo,function(e){if(e.widgets)for(var t=0;t<e.widgets.length;t++)if(e.widgets[t].noHScroll){mn(r,i,"widget");break}++i}),this.curOp.forceUpdate=!0,Te(this,"refresh",this)}),operation:function(e){return hn(this,e)},startOperation:function(){return nn(this)},endOperation:function(){return on(this)},refresh:pn(function(){var e=this.display.cachedTextHeight;vn(this),this.curOp.forceUpdate=!0,er(this),Xr(this,this.doc.scrollLeft,this.doc.scrollTop),Wn(this),(null==e||Math.abs(e-mr(this.display))>.5)&&Cr(this),Te(this,"refresh",this)}),swapDoc:pn(function(e){var t=this.doc;return t.cm=null,qn(this,e),er(this),this.display.input.reset(),Xr(this,e.scrollLeft,e.scrollTop),this.curOp.forceScroll=!0,bt(this,"swapDoc",this,t),t}),getInputField:function(){return this.display.input.getField()},getWrapperElement:function(){return this.display.wrapper},getScrollerElement:function(){return this.display.scroller},getGutterElement:function(){return this.display.gutters}},Ae(e),e.registerHelper=function(t,n,i){r.hasOwnProperty(t)||(r[t]=e[t]={_global:[]}),r[t][n]=i},e.registerGlobalHelper=function(t,n,i,o){e.registerHelper(t,n,o),r[t]._global.push({pred:i,val:o})}}(jo);var Js="iter insert remove copy getEditor constructor".split(" ");for(var ea in Ds.prototype)Ds.prototype.hasOwnProperty(ea)&&h(Js,ea)<0&&(jo.prototype[ea]=function(e){return function(){return e.apply(this.doc,arguments)}}(Ds.prototype[ea]));return Ae(Ds),jo.inputStyles={textarea:Qs,contenteditable:Zs},jo.defineMode=function(e){jo.defaults.mode||"null"==e||(jo.defaults.mode=e),Be.apply(this,arguments)},jo.defineMIME=function(e,t){os[e]=t},jo.defineMode("null",function(){return{token:function(e){return e.skipToEnd()}}}),jo.defineMIME("text/plain","null"),jo.defineExtension=function(e,t){jo.prototype[e]=t},jo.defineDocExtension=function(e,t){Ds.prototype[e]=t},jo.fromTextArea=function(e,t){function r(){e.value=a.getValue()}if(t=t?c(t):{},t.value=e.value,!t.tabindex&&e.tabIndex&&(t.tabindex=e.tabIndex),!t.placeholder&&e.placeholder&&(t.placeholder=e.placeholder),null==t.autofocus){var n=l();t.autofocus=n==e||null!=e.getAttribute("autofocus")&&n==document.body}var i;if(e.form&&(Ql(e.form,"submit",r),!t.leaveSubmitMethodAlone)){var o=e.form;i=o.submit;try{var s=o.submit=function(){r(),o.submit=i,o.submit(),o.submit=s}}catch(e){}}t.finishInit=function(t){t.save=r,t.getTextArea=function(){return e},t.toTextArea=function(){t.toTextArea=isNaN,r(),e.parentNode.removeChild(t.getWrapperElement()),e.style.display="",e.form&&(ke(e.form,"submit",r),"function"==typeof e.form.submit&&(e.form.submit=i))}},e.style.display="none";var a=jo(function(t){return e.parentNode.insertBefore(t,e.nextSibling)},t);return a},function(e){e.off=ke,e.on=Ql,e.wheelEventPixels=Pn,e.Doc=Ds,e.splitLines=es,e.countColumn=f,e.findColumn=d,e.isWordChar=w,e.Pass=Bl,e.signal=Te,e.Line=fs,e.changeEnd=Bn,e.scrollbarModel=ws,e.Pos=E,e.cmpPos=P,e.modes=is,e.mimeModes=os,e.resolveMode=Ge,e.getMode=Ue,e.modeExtensions=ls,e.extendMode=Ve,e.copyState=Ke,e.startState=Xe,e.innerMode=je,e.commands=Bs,e.keyMap=Rs,e.keyName=ao,e.isModifierKey=lo,e.lookupKey=oo,e.normalizeKeyMap=io,e.StringStream=ss,e.SharedTextMarker=As,e.TextMarker=Os,e.LineWidget=Ms,e.e_preventDefault=We,e.e_stopPropagation=De,e.e_stop=Fe,e.addClass=s,e.contains=o,e.rmClass=Fl,e.keyNames=Es}(jo),jo.version="5.30.0",jo});
      !function(e){"object"==typeof exports&&"object"==typeof module?e(require("../../lib/codemirror")):"function"==typeof define&&define.amd?define(["../../lib/codemirror"],e):e(CodeMirror)}(function(e){"use strict";function t(e,t,n,r,o,a){this.indented=e,this.column=t,this.type=n,this.info=r,this.align=o,this.prev=a}function n(e,n,r,o){var a=e.indented;return e.context&&"statement"==e.context.type&&"statement"!=r&&(a=e.context.indented),e.context=new t(a,n,r,o,null,e.context)}function r(e){var t=e.context.type;return")"!=t&&"]"!=t&&"}"!=t||(e.indented=e.context.indented),e.context=e.context.prev}function o(e,t,n){return"variable"==t.prevToken||"type"==t.prevToken||(!!/\S(?:[^- ]>|[*\]])\s*$|\*$/.test(e.string.slice(0,n))||(!(!t.typeAtEndOfLine||e.column()!=e.indentation())||void 0))}function a(e){for(;;){if(!e||"top"==e.type)return!0;if("}"==e.type&&"namespace"!=e.prev.info)return!1;e=e.prev}}function i(e){for(var t={},n=e.split(" "),r=0;r<n.length;++r)t[n[r]]=!0;return t}function l(e,t){return"function"==typeof e?e(t):e.propertyIsEnumerable(t)}function s(e,t){if(!t.startOfLine)return!1;for(var n,r=null;n=e.peek();){if("\\"==n&&e.match(/^.$/)){r=s;break}if("/"==n&&e.match(/^\/[\/\*]/,!1))break;e.next()}return t.tokenize=r,"meta"}function c(e,t){return"type"==t.prevToken&&"type"}function u(e){return e.eatWhile(/[\w\.']/),"number"}function d(e,t){if(e.backUp(1),e.match(/(R|u8R|uR|UR|LR)/)){var n=e.match(/"([^\s\\()]{0,16})\(/);return!!n&&(t.cpp11RawStringDelim=n[1],t.tokenize=m,m(e,t))}return e.match(/(u8|u|U|L)/)?!!e.match(/["']/,!1)&&"string":(e.next(),!1)}function f(e){var t=/(\w+)::~?(\w+)$/.exec(e);return t&&t[1]==t[2]}function p(e,t){for(var n;null!=(n=e.next());)if('"'==n&&!e.eat('"')){t.tokenize=null;break}return"string"}function m(e,t){var n=t.cpp11RawStringDelim.replace(/[^\w\s]/g,"\\$&");return e.match(new RegExp(".*?\\)"+n+'"'))?t.tokenize=null:e.skipToEnd(),"string"}function h(t,n){function r(e){if(e)for(var t in e)e.hasOwnProperty(t)&&o.push(t)}"string"==typeof t&&(t=[t]);var o=[];r(n.keywords),r(n.types),r(n.builtin),r(n.atoms),o.length&&(n.helperType=t[0],e.registerHelper("hintWords",t[0],o));for(var a=0;a<t.length;++a)e.defineMIME(t[a],n)}function g(e,t){for(var n=!1;!e.eol();){if(!n&&e.match('"""')){t.tokenize=null;break}n="\\"==e.next()&&!n}return"string"}function y(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!e&&!o&&t.match('"')){a=!0;break}if(e&&t.match('"""')){a=!0;break}r=t.next(),!o&&"$"==r&&t.match("{")&&t.skipTo("}"),o=!o&&"\\"==r&&!e}return!a&&e||(n.tokenize=null),"string"}}function x(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!o&&t.match('"')&&("single"==e||t.match('""'))){a=!0;break}if(!o&&t.match("``")){w=x(e),a=!0;break}r=t.next(),o="single"==e&&!o&&"\\"==r}return a&&(n.tokenize=null),"string"}}e.defineMode("clike",function(i,s){function c(e,t){var n=e.next();if(S[n]){var r=S[n](e,t);if(!1!==r)return r}if('"'==n||"'"==n)return t.tokenize=u(n),t.tokenize(e,t);if(D.test(n))return p=n,null;if(L.test(n)){if(e.backUp(1),e.match(I))return"number";e.next()}if("/"==n){if(e.eat("*"))return t.tokenize=d,d(e,t);if(e.eat("/"))return e.skipToEnd(),"comment"}if(F.test(n)){for(;!e.match(/^\/[\/*]/,!1)&&e.eat(F););return"operator"}if(e.eatWhile(z),P)for(;e.match(P);)e.eatWhile(z);var o=e.current();return l(x,o)?(l(w,o)&&(p="newstatement"),l(v,o)&&(m=!0),"keyword"):l(b,o)?"type":l(k,o)?(l(w,o)&&(p="newstatement"),"builtin"):l(_,o)?"atom":"variable"}function u(e){return function(t,n){for(var r,o=!1,a=!1;null!=(r=t.next());){if(r==e&&!o){a=!0;break}o=!o&&"\\"==r}return(a||!o&&!C)&&(n.tokenize=null),"string"}}function d(e,t){for(var n,r=!1;n=e.next();){if("/"==n&&r){t.tokenize=null;break}r="*"==n}return"comment"}function f(e,t){s.typeFirstDefinitions&&e.eol()&&a(t.context)&&(t.typeAtEndOfLine=o(e,t,e.pos))}var p,m,h=i.indentUnit,g=s.statementIndentUnit||h,y=s.dontAlignCalls,x=s.keywords||{},b=s.types||{},k=s.builtin||{},w=s.blockKeywords||{},v=s.defKeywords||{},_=s.atoms||{},S=s.hooks||{},C=s.multiLineStrings,T=!1!==s.indentStatements,M=!1!==s.indentSwitch,P=s.namespaceSeparator,D=s.isPunctuationChar||/[\[\]{}\(\),;\:\.]/,L=s.numberStart||/[\d\.]/,I=s.number||/^(?:0x[a-f\d]+|0b[01]+|(?:\d+\.?\d*|\.\d+)(?:e[-+]?\d+)?)(u|ll?|l|f)?/i,F=s.isOperatorChar||/[+\-*&%=<>!?|\/]/,z=s.isIdentifierChar||/[\w\$_\xa1-\uffff]/;return{startState:function(e){return{tokenize:null,context:new t((e||0)-h,0,"top",null,!1),indented:0,startOfLine:!0,prevToken:null}},token:function(e,t){var i=t.context;if(e.sol()&&(null==i.align&&(i.align=!1),t.indented=e.indentation(),t.startOfLine=!0),e.eatSpace())return f(e,t),null;p=m=null;var l=(t.tokenize||c)(e,t);if("comment"==l||"meta"==l)return l;if(null==i.align&&(i.align=!0),";"==p||":"==p||","==p&&e.match(/^\s*(?:\/\/.*)?$/,!1))for(;"statement"==t.context.type;)r(t);else if("{"==p)n(t,e.column(),"}");else if("["==p)n(t,e.column(),"]");else if("("==p)n(t,e.column(),")");else if("}"==p){for(;"statement"==i.type;)i=r(t);for("}"==i.type&&(i=r(t));"statement"==i.type;)i=r(t)}else p==i.type?r(t):T&&(("}"==i.type||"top"==i.type)&&";"!=p||"statement"==i.type&&"newstatement"==p)&&n(t,e.column(),"statement",e.current());if("variable"==l&&("def"==t.prevToken||s.typeFirstDefinitions&&o(e,t,e.start)&&a(t.context)&&e.match(/^\s*\(/,!1))&&(l="def"),S.token){var u=S.token(e,t,l);void 0!==u&&(l=u)}return"def"==l&&!1===s.styleDefs&&(l="variable"),t.startOfLine=!1,t.prevToken=m?"def":l||p,f(e,t),l},indent:function(t,n){if(t.tokenize!=c&&null!=t.tokenize||t.typeAtEndOfLine)return e.Pass;var r=t.context,o=n&&n.charAt(0);if("statement"==r.type&&"}"==o&&(r=r.prev),s.dontIndentStatements)for(;"statement"==r.type&&s.dontIndentStatements.test(r.info);)r=r.prev;if(S.indent){var a=S.indent(t,r,n);if("number"==typeof a)return a}var i=o==r.type,l=r.prev&&"switch"==r.prev.info;if(s.allmanIndentation&&/[{(]/.test(o)){for(;"top"!=r.type&&"}"!=r.type;)r=r.prev;return r.indented}return"statement"==r.type?r.indented+("{"==o?0:g):!r.align||y&&")"==r.type?")"!=r.type||i?r.indented+(i?0:h)+(i||!l||/^(?:case|default)\b/.test(n)?0:h):r.indented+g:r.column+(i?0:1)},electricInput:M?/^\s*(?:case .*?:|default:|\{\}?|\})$/:/^\s*[{}]$/,blockCommentStart:"/*",blockCommentEnd:"*/",lineComment:"//",fold:"brace"}});var b="auto if break case register continue return default do sizeof static else struct switch extern typedef union for goto while enum const volatile",k="int long char short double float unsigned signed void size_t ptrdiff_t";h(["text/x-csrc","text/x-c","text/x-chdr"],{name:"clike",keywords:i(b),types:i(k+" bool _Complex _Bool float_t double_t intptr_t intmax_t int8_t int16_t int32_t int64_t uintptr_t uintmax_t uint8_t uint16_t uint32_t uint64_t"),blockKeywords:i("case do else for if switch while struct"),defKeywords:i("struct"),typeFirstDefinitions:!0,atoms:i("null true false"),hooks:{"#":s,"*":c},modeProps:{fold:["brace","include"]}}),h(["text/x-c++src","text/x-c++hdr"],{name:"clike",keywords:i(b+" asm dynamic_cast namespace reinterpret_cast try explicit new static_cast typeid catch operator template typename class friend private this using const_cast inline public throw virtual delete mutable protected alignas alignof constexpr decltype nullptr noexcept thread_local final static_assert override"),types:i(k+" bool wchar_t"),blockKeywords:i("catch class do else finally for if struct switch try while"),defKeywords:i("class namespace struct enum union"),typeFirstDefinitions:!0,atoms:i("true false null"),dontIndentStatements:/^template$/,isIdentifierChar:/[\w\$_~\xa1-\uffff]/,hooks:{"#":s,"*":c,u:d,U:d,L:d,R:d,0:u,1:u,2:u,3:u,4:u,5:u,6:u,7:u,8:u,9:u,token:function(e,t,n){if("variable"==n&&"("==e.peek()&&(";"==t.prevToken||null==t.prevToken||"}"==t.prevToken)&&f(e.current()))return"def"}},namespaceSeparator:"::",modeProps:{fold:["brace","include"]}}),h("text/x-java",{name:"clike",keywords:i("abstract assert break case catch class const continue default do else enum extends final finally float for goto if implements import instanceof interface native new package private protected public return static strictfp super switch synchronized this throw throws transient try volatile while @interface"),types:i("byte short int long float double boolean char void Boolean Byte Character Double Float Integer Long Number Object Short String StringBuffer StringBuilder Void"),blockKeywords:i("catch class do else finally for if switch try while"),defKeywords:i("class interface package enum @interface"),typeFirstDefinitions:!0,atoms:i("true false null"),number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,hooks:{"@":function(e){return!e.match("interface",!1)&&(e.eatWhile(/[\w\$_]/),"meta")}},modeProps:{fold:["brace","import"]}}),h("text/x-csharp",{name:"clike",keywords:i("abstract as async await base break case catch checked class const continue default delegate do else enum event explicit extern finally fixed for foreach goto if implicit in interface internal is lock namespace new operator out override params private protected public readonly ref return sealed sizeof stackalloc static struct switch this throw try typeof unchecked unsafe using virtual void volatile while add alias ascending descending dynamic from get global group into join let orderby partial remove select set value var yield"),types:i("Action Boolean Byte Char DateTime DateTimeOffset Decimal Double Func Guid Int16 Int32 Int64 Object SByte Single String Task TimeSpan UInt16 UInt32 UInt64 bool byte char decimal double short int long object sbyte float string ushort uint ulong"),blockKeywords:i("catch class do else finally for foreach if struct switch try while"),defKeywords:i("class interface namespace struct var"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"@":function(e,t){return e.eat('"')?(t.tokenize=p,p(e,t)):(e.eatWhile(/[\w\$_]/),"meta")}}}),h("text/x-scala",{name:"clike",keywords:i("abstract case catch class def do else extends final finally for forSome if implicit import lazy match new null object override package private protected return sealed super this throw trait try type val var while with yield _ assert assume require print println printf readLine readBoolean readByte readShort readChar readInt readLong readFloat readDouble"),types:i("AnyVal App Application Array BufferedIterator BigDecimal BigInt Char Console Either Enumeration Equiv Error Exception Fractional Function IndexedSeq Int Integral Iterable Iterator List Map Numeric Nil NotNull Option Ordered Ordering PartialFunction PartialOrdering Product Proxy Range Responder Seq Serializable Set Specializable Stream StringBuilder StringContext Symbol Throwable Traversable TraversableOnce Tuple Unit Vector Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),multiLineStrings:!0,blockKeywords:i("catch class enum do else finally for forSome if match switch try while"),defKeywords:i("class enum def object package trait type val var"),atoms:i("true false null"),indentStatements:!1,indentSwitch:!1,isOperatorChar:/[+\-*&%=<>!?|\/#:@]/,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return!!e.match('""')&&(t.tokenize=g,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},"=":function(e,n){var r=n.context;return!("}"!=r.type||!r.align||!e.eat(">"))&&(n.context=new t(r.indented,r.column,r.type,r.info,null,r.prev),"operator")}},modeProps:{closeBrackets:{triples:'"'}}}),h("text/x-kotlin",{name:"clike",keywords:i("package as typealias class interface this super val var fun for is in This throw return break continue object if else while do try when !in !is as? file import where by get set abstract enum open inner override private public internal protected catch finally out final vararg reified dynamic companion constructor init sealed field property receiver param sparam lateinit data inline noinline tailrec external annotation crossinline const operator infix suspend"),types:i("Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),intendSwitch:!1,indentStatements:!1,multiLineStrings:!0,number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,blockKeywords:i("catch class do else finally for if where try while enum"),defKeywords:i("class val var object package interface fun"),atoms:i("true false null this"),hooks:{'"':function(e,t){return t.tokenize=y(e.match('""')),t.tokenize(e,t)}},modeProps:{closeBrackets:{triples:'"'}}}),h(["x-shader/x-vertex","x-shader/x-fragment"],{name:"clike",keywords:i("sampler1D sampler2D sampler3D samplerCube sampler1DShadow sampler2DShadow const attribute uniform varying break continue discard return for while do if else struct in out inout"),types:i("float int bool void vec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4 mat2 mat3 mat4"),blockKeywords:i("for while do if else struct"),builtin:i("radians degrees sin cos tan asin acos atan pow exp log exp2 sqrt inversesqrt abs sign floor ceil fract mod min max clamp mix step smoothstep length distance dot cross normalize ftransform faceforward reflect refract matrixCompMult lessThan lessThanEqual greaterThan greaterThanEqual equal notEqual any all not texture1D texture1DProj texture1DLod texture1DProjLod texture2D texture2DProj texture2DLod texture2DProjLod texture3D texture3DProj texture3DLod texture3DProjLod textureCube textureCubeLod shadow1D shadow2D shadow1DProj shadow2DProj shadow1DLod shadow2DLod shadow1DProjLod shadow2DProjLod dFdx dFdy fwidth noise1 noise2 noise3 noise4"),atoms:i("true false gl_FragColor gl_SecondaryColor gl_Normal gl_Vertex gl_MultiTexCoord0 gl_MultiTexCoord1 gl_MultiTexCoord2 gl_MultiTexCoord3 gl_MultiTexCoord4 gl_MultiTexCoord5 gl_MultiTexCoord6 gl_MultiTexCoord7 gl_FogCoord gl_PointCoord gl_Position gl_PointSize gl_ClipVertex gl_FrontColor gl_BackColor gl_FrontSecondaryColor gl_BackSecondaryColor gl_TexCoord gl_FogFragCoord gl_FragCoord gl_FrontFacing gl_FragData gl_FragDepth gl_ModelViewMatrix gl_ProjectionMatrix gl_ModelViewProjectionMatrix gl_TextureMatrix gl_NormalMatrix gl_ModelViewMatrixInverse gl_ProjectionMatrixInverse gl_ModelViewProjectionMatrixInverse gl_TexureMatrixTranspose gl_ModelViewMatrixInverseTranspose gl_ProjectionMatrixInverseTranspose gl_ModelViewProjectionMatrixInverseTranspose gl_TextureMatrixInverseTranspose gl_NormalScale gl_DepthRange gl_ClipPlane gl_Point gl_FrontMaterial gl_BackMaterial gl_LightSource gl_LightModel gl_FrontLightModelProduct gl_BackLightModelProduct gl_TextureColor gl_EyePlaneS gl_EyePlaneT gl_EyePlaneR gl_EyePlaneQ gl_FogParameters gl_MaxLights gl_MaxClipPlanes gl_MaxTextureUnits gl_MaxTextureCoords gl_MaxVertexAttribs gl_MaxVertexUniformComponents gl_MaxVaryingFloats gl_MaxVertexTextureImageUnits gl_MaxTextureImageUnits gl_MaxFragmentUniformComponents gl_MaxCombineTextureImageUnits gl_MaxDrawBuffers"),indentSwitch:!1,hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-nesc",{name:"clike",keywords:i(b+"as atomic async call command component components configuration event generic implementation includes interface module new norace nx_struct nx_union post provides signal task uses abstract extends"),types:i(k),blockKeywords:i("case do else for if switch while struct"),atoms:i("null true false"),hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-objectivec",{name:"clike",keywords:i(b+"inline restrict _Bool _Complex _Imaginary BOOL Class bycopy byref id IMP in inout nil oneway out Protocol SEL self super atomic nonatomic retain copy readwrite readonly"),types:i(k),atoms:i("YES NO NULL NILL ON OFF true false"),hooks:{"@":function(e){return e.eatWhile(/[\w\$]/),"keyword"},"#":s,indent:function(e,t,n){if("statement"==t.type&&/^@\w/.test(n))return t.indented}},modeProps:{fold:"brace"}}),h("text/x-squirrel",{name:"clike",keywords:i("base break clone continue const default delete enum extends function in class foreach local resume return this throw typeof yield constructor instanceof static"),types:i(k),blockKeywords:i("case catch class else for foreach if switch try while"),defKeywords:i("function local class"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"#":s},modeProps:{fold:["brace","include"]}});var w=null;h("text/x-ceylon",{name:"clike",keywords:i("abstracts alias assembly assert assign break case catch class continue dynamic else exists extends finally for function given if import in interface is let module new nonempty object of out outer package return satisfies super switch then this throw try value void while"),types:function(e){var t=e.charAt(0);return t===t.toUpperCase()&&t!==t.toLowerCase()},blockKeywords:i("case catch class dynamic else finally for function if interface module new object switch try while"),defKeywords:i("class dynamic function interface module object package value"),builtin:i("abstract actual aliased annotation by default deprecated doc final formal late license native optional sealed see serializable shared suppressWarnings tagged throws variable"),isPunctuationChar:/[\[\]{}\(\),;\:\.`]/,isOperatorChar:/[+\-*&%=<>!?|^~:\/]/,numberStart:/[\d#$]/,number:/^(?:#[\da-fA-F_]+|\$[01_]+|[\d_]+[kMGTPmunpf]?|[\d_]+\.[\d_]+(?:[eE][-+]?\d+|[kMGTPmunpf]|)|)/i,multiLineStrings:!0,typeFirstDefinitions:!0,atoms:i("true false null larger smaller equal empty finished"),indentSwitch:!1,styleDefs:!1,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return t.tokenize=x(e.match('""')?"triple":"single"),t.tokenize(e,t)},"`":function(e,t){return!(!w||!e.match("`"))&&(t.tokenize=w,w=null,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},token:function(e,t,n){if(("variable"==n||"type"==n)&&"."==t.prevToken)return"variable-2"}},modeProps:{fold:["brace","import"],closeBrackets:{triples:'"'}}})});
      // -------------------------------------------------------------------------
//  Part of the CodeChecker project, under the Apache License v2.0 with
//  LLVM Exceptions. See LICENSE for license information.
//  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
// -------------------------------------------------------------------------

var BugViewer = {
  _files : [],
  _reports : [],
  _lineWidgets : [],
  _navigationMenuItems : [],
  _sourceFileData : null,
  _currentReport : null,
  _lastBugEvent  : null,

  init : function (files, reports) {
    this._files = files;
    this._reports = reports;

    this.initEscapeChars();
  },

  initEscapeChars : function () {
    this.escapeChars = {
      ' ' : 'nbsp',
      '<' : 'lt',
      '>' : 'gt',
      '"' : 'quot',
      '&' : 'amp'
    };

    var regexString = '[';
    for (var key in this.escapeChars) {
      regexString += key;
    }
    regexString += ']';

    this.escapeRegExp = new RegExp( regexString, 'g');
  },

  escapeHTML : function (str) {
    var that = this;

    return str.replace(this.escapeRegExp, function (m) {
      return '&' + that.escapeChars[m] + ';';
    });
  },

  initByUrl : function () {
    if (!this._reports) return;

    var state = {};
    window.location.hash.substr(1).split('&').forEach(function (s) {
      var parts = s.split('=');
      state[parts[0]] = parts[1];
    });

    for (var key in this._reports) {
      var report = this._reports[key];
      if (report.reportHash === state['reportHash']) {
        this.navigate(report);
        return;
      }
    }

    this.navigate(this._reports[0]);
  },

  create : function () {
    this._content = document.getElementById('editor-wrapper');
    this._filepath = document.getElementById('file-path');
    this._checkerName = document.getElementById('checker-name');
    this._reviewStatusWrapper =
      document.getElementById('review-status-wrapper');
    this._reviewStatus = document.getElementById('review-status');
    this._editor = document.getElementById('editor');

    this._codeMirror = CodeMirror(this._editor, {
      mode: 'text/x-c++src',
      matchBrackets : true,
      lineNumbers : true,
      readOnly : true,
      foldGutter : true,
      extraKeys : {},
      viewportMargin : 100
    });

    this._createNavigationMenu();
  },

  navigate : function (report, item) {
    if (!item) {
      var items = this._navigationMenuItems.filter(function (navItem) {
        return navItem.report.reportHash === report.reportHash;
      });

      if (!items.length) return;

      item = items[0].widget;
    }

    this._selectedReport.classList.remove('active');
    this._selectedReport = item;
    this._selectedReport.classList.add('active');
    this.setReport(report);
  },

  _createNavigationMenu : function () {
    var that = this;

    var nav = document.getElementById('report-nav');
    var list = document.createElement('ul');
    this._reports.forEach(function (report) {
      var events = report['events'];
      var lastBugEvent = events[events.length - 1];
      var item = document.createElement('li');

      var severity = document.createElement('i');
      severity.className = 'severity-' + report.severity.toLowerCase();

      item.appendChild(severity);
      item.appendChild(document.createTextNode(lastBugEvent.message));

      item.addEventListener('click', function () {
        that.navigate(report, item);
      })
      list.appendChild(item);
      that._navigationMenuItems.push({ report : report, widget : item });
    });

    if (!this._selectedReport && list.childNodes.length) {
      this._selectedReport = list.childNodes[0];
      this._selectedReport.classList.add('active');
    }

    nav.appendChild(list);
  },

  setReport : function (report) {
    this._currentReport = report;
    var events = report['events'];
    var lastBugEvent = events[events.length - 1];
    this.setCurrentBugEvent(lastBugEvent, events.length - 1);
    this.setCheckerName(report.checkerName);
    this.setReviewStatus(report.reviewStatus);

    window.location.hash = '#reportHash=' + report.reportHash;
  },

  setCurrentBugEvent : function (event, idx) {
    this._currentBugEvent = event;
    this.setSourceFileData(this._files[event.location.file]);
    this.drawBugPath();

    this.jumpTo(event.location.line, 0);
    this.highlightBugEvent(event, idx);
  },

  highlightBugEvent : function (event, idx) {
    this._lineWidgets.forEach(function (widget) {
      var lineIdx = widget.node.getAttribute('idx');
      if (parseInt(lineIdx) === idx) {
        widget.node.classList.add('current');
      }
    });
  },

  setCheckerName : function (checkerName) {
    this._checkerName.innerHTML = checkerName;
  },

  setReviewStatus : function (status) {
    if (status) {
      var className =
        'review-status-' + status.toLowerCase().split(' ').join('-');
      this._reviewStatus.className = "review-status " + className;

      this._reviewStatus.innerHTML = status;
      this._reviewStatusWrapper.style.display = 'block';
    } else {
      this._reviewStatusWrapper.style.display = 'none';
    }
  },

  setSourceFileData : function (file) {
    if (this._sourceFileData && file.id === this._sourceFileData.id) {
      return;
    }

    this._sourceFileData = file;
    this._filepath.innerHTML = file.path;
    this._codeMirror.doc.setValue(file.content);
    this._refresh();
  },

  _refresh : function () {
    var that = this;
    setTimeout(function () {
      var fullHeight = parseInt(that._content.clientHeight);
      var headerHeight = that._filepath.clientHeight;

      that._codeMirror.setSize('auto', fullHeight - headerHeight);
      that._codeMirror.refresh();
    }, 200);
  },

  clearBubbles : function () {
    this._lineWidgets.forEach(function (widget) { widget.clear(); });
    this._lineWidgets = [];
  },

  getMessage : function (event, kind) {
    if (kind === 'macro') {
      var name = 'macro expansion' + (event.name ? ': ' + event.name : '');

      return '<span class="tag macro">' + name + '</span>'
        + this.escapeHTML(event.expansion).replace(/(?:\r\n|\r|\n)/g, '<br>');
    } else if (kind === 'note') {
      return '<span class="tag note">note</span>'
        +  this.escapeHTML(event.message).replace(/(?:\r\n|\r|\n)/g, '<br>');
    }
  },

  addExtraPathEvents : function (events, kind) {
    var that = this;

    if (!events) {
      return;
    }

    events.forEach(function (event) {
      if (event.location.file !== that._currentBugEvent.location.file) {
        return;
      }

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + kind);

      var msg = document.createElement('span');
      msg.innerHTML = that.getMessage(event, kind);
      element.appendChild(msg);

      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  drawBugPath : function () {
    var that = this;

    this.clearBubbles();

    this.addExtraPathEvents(this._currentReport.macros, 'macro');
    this.addExtraPathEvents(this._currentReport.notes, 'note');

    // Processing bug path events.
    var currentEvents = this._currentReport.events;
    currentEvents.forEach(function (event, step) {
      if (event.location.file !== that._currentBugEvent.location.file)
        return;

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';
      var type = step === currentEvents.length - 1 ? 'error' : 'info';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + type);
      element.setAttribute('idx', step);

      var enumeration = document.createElement('span');
      enumeration.setAttribute('class', 'checker-enum ' + type);
      enumeration.innerHTML = step + 1;

      if (currentEvents.length > 1)
        element.appendChild(enumeration);

      var prevBugEvent = step - 1;
      if (step > 0) {
        var prevBug = document.createElement('span');
        prevBug.setAttribute('class', 'arrow left-arrow');
        prevBug.addEventListener('click', function () {
          var event = currentEvents[prevBugEvent];
          that.setCurrentBugEvent(event, prevBugEvent);
        });
        element.appendChild(prevBug);
      }

      var msg = document.createElement('span');
      msg.innerHTML = that.escapeHTML(event.message)
        .replace(/(?:\r\n|\r|\n)/g, '<br>');

      element.appendChild(msg);

      var nextBugEvent = step + 1;
      if (nextBugEvent < currentEvents.length) {
        var nextBug = document.createElement('span');
        nextBug.setAttribute('class', 'arrow right-arrow');
        nextBug.addEventListener('click', function () {
          var event = currentEvents[nextBugEvent];
          that.setCurrentBugEvent(event, nextBugEvent);
        });
        element.appendChild(nextBug);
      }


      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  jumpTo : function (line, column) {
    var that = this;

    setTimeout(function () {
      var selPosPixel
        = that._codeMirror.charCoords({ line : line, ch : column }, 'local');
      var editorSize = {
        width  : that._editor.clientWidth,
        height : that._editor.clientHeight
      };

      that._codeMirror.scrollIntoView({
        top    : selPosPixel.top - 100,
        bottom : selPosPixel.top + editorSize.height - 150,
        left   : selPosPixel.left < editorSize.width - 100
               ? 0
               : selPosPixel.left - 50,
        right  : selPosPixel.left < editorSize.width - 100
               ? 10
               : selPosPixel.left + editorSize.width - 100
      });
    }, 0);
  }
}


      var data = {"files": {"0": {"id": 0, "path": "/home/vsts/work/1/build/tools/polly/lib/External/isl/include/isl/stdint.h", "content": "#include <stdint.h>\n"}, "1": {"id": 1, "path": "/home/vsts/work/1/build/tools/polly/lib/External/isl/isl_config.h", "content": "/* define if your compiler has __attribute__ */\n#define HAVE___ATTRIBUTE__ /**/\n\n/* most gcc compilers know a function __attribute__((__warn_unused_result__)) */\n#define GCC_WARN_UNUSED_RESULT __attribute__((__warn_unused_result__))\n\n\n/* Define to 1 if you have the declaration of `ffs', and to 0 if you don't. */\n#define HAVE_DECL_FFS 1\n\n/* Define to 1 if you have the declaration of `__builtin_ffs', and to 0 if you\n   don't. */\n#define HAVE_DECL___BUILTIN_FFS 1\n\n/* Define to 1 if you have the declaration of `_BitScanForward', and to 0 if\n   you don't. */\n#define HAVE_DECL__BITSCANFORWARD 0\n\n\n/* Define to 1 if you have the declaration of `strcasecmp', and to 0 if you\n   don't. */\n#define HAVE_DECL_STRCASECMP 1\n\n/* Define to 1 if you have the declaration of `_stricmp', and to 0 if you\n   don't. */\n#define HAVE_DECL__STRICMP 0\n\n\n/* Define to 1 if you have the declaration of `strncasecmp', and to 0 if you\n   don't. */\n#define HAVE_DECL_STRNCASECMP 1\n\n/* Define to 1 if you have the declaration of `_strnicmp', and to 0 if you\n   don't. */\n#define HAVE_DECL__STRNICMP 0\n\n\n/* Define to 1 if you have the declaration of `snprintf', and to 0 if you\n   don't. */\n#define HAVE_DECL_SNPRINTF 1\n\n/* Define to 1 if you have the declaration of `_snprintf', and to 0 if you\n   don't. */\n#define HAVE_DECL__SNPRINTF 0\n\n\n/* use gmp to implement isl_int */\n/* #undef USE_GMP_FOR_MP */\n\n/* use imath to implement isl_int */\n#define USE_IMATH_FOR_MP\n\n/* Use small integer optimization */\n#define USE_SMALL_INT_OPT\n\n#include <isl_config_post.h>\n"}, "2": {"id": 2, "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/imath/gmp_compat.h", "content": "/*\n  Name:     gmp_compat.h\n  Purpose:  Provide GMP compatiable routines for imath library\n  Author:   David Peixotto\n\n  Copyright (c) 2012 Qualcomm Innovation Center, Inc. All rights reserved.\n\n  Permission is hereby granted, free of charge, to any person obtaining a copy\n  of this software and associated documentation files (the \"Software\"), to deal\n  in the Software without restriction, including without limitation the rights\n  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n  copies of the Software, and to permit persons to whom the Software is\n  furnished to do so, subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be included in\n  all copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE\n  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n  SOFTWARE.\n */\n\n#ifndef IMATH_GMP_COMPAT_H_\n#define IMATH_GMP_COMPAT_H_\n#include \"imath.h\"\n#include \"imrat.h\"\n#include <stddef.h>\n\n#define GMPZAPI(fun) impz_ ## fun\n#define GMPQAPI(fun) impq_ ## fun\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n/*************************************************************************\n *\n * Functions with direct translations\n *\n *************************************************************************/\n/* gmp: mpq_clear */\nvoid GMPQAPI(clear)(mp_rat x);\n\n/* gmp: mpq_cmp */\nint GMPQAPI(cmp)(mp_rat op1, mp_rat op2);\n\n/* gmp: mpq_init */\nvoid GMPQAPI(init)(mp_rat x);\n\n/* gmp: mpq_mul */\nvoid GMPQAPI(mul)(mp_rat product, mp_rat multiplier, mp_rat multiplicand);\n\n/* gmp: mpq_set */\nvoid GMPQAPI(set)(mp_rat rop, mp_rat op);\n\n/* gmp: mpz_abs */\nvoid GMPZAPI(abs)(mp_int rop, mp_int op);\n\n/* gmp: mpz_add */\nvoid GMPZAPI(add)(mp_int rop, mp_int op1, mp_int op2);\n\n/* gmp: mpz_clear */\nvoid GMPZAPI(clear)(mp_int x);\n\n/* gmp: mpz_cmp_si */\nint GMPZAPI(cmp_si)(mp_int op1, long op2);\n\n/* gmp: mpz_cmpabs */\nint GMPZAPI(cmpabs)(mp_int op1, mp_int op2);\n\n/* gmp: mpz_cmp */\nint GMPZAPI(cmp)(mp_int op1, mp_int op2);\n\n/* gmp: mpz_init */\nvoid GMPZAPI(init)(mp_int x);\n\n/* gmp: mpz_mul */\nvoid GMPZAPI(mul)(mp_int rop, mp_int op1, mp_int op2);\n\n/* gmp: mpz_neg */\nvoid GMPZAPI(neg)(mp_int rop, mp_int op);\n\n/* gmp: mpz_set_si */\nvoid GMPZAPI(set_si)(mp_int rop, long op);\n\n/* gmp: mpz_set */\nvoid GMPZAPI(set)(mp_int rop, mp_int op);\n\n/* gmp: mpz_sub */\nvoid GMPZAPI(sub)(mp_int rop, mp_int op1, mp_int op2);\n\n/* gmp: mpz_swap */\nvoid GMPZAPI(swap)(mp_int rop1, mp_int rop2);\n\n/* gmp: mpq_sgn */\nint GMPQAPI(sgn)(mp_rat op);\n\n/* gmp: mpz_sgn */\nint GMPZAPI(sgn)(mp_int op);\n\n/* gmp: mpq_set_ui */\nvoid GMPQAPI(set_ui)(mp_rat rop, unsigned long op1, unsigned long op2);\n\n/* gmp: mpz_set_ui */\nvoid GMPZAPI(set_ui)(mp_int rop, unsigned long op);\n\n/* gmp: mpq_den_ref */\nmp_int GMPQAPI(denref)(mp_rat op);\n\n/* gmp: mpq_num_ref */\nmp_int GMPQAPI(numref)(mp_rat op);\n\n/* gmp: mpq_canonicalize */\nvoid GMPQAPI(canonicalize)(mp_rat op);\n\n/*************************************************************************\n *\n * Functions that can be implemented as a combination of imath functions\n *\n *************************************************************************/\n/* gmp: mpz_addmul */\nvoid GMPZAPI(addmul)(mp_int rop, mp_int op1, mp_int op2);\n\n/* gmp: mpz_divexact */\nvoid GMPZAPI(divexact)(mp_int q, mp_int n, mp_int d);\n\n/* gmp: mpz_divisible_p */\nint GMPZAPI(divisible_p)(mp_int n, mp_int d);\n\n/* gmp: mpz_submul */\nvoid GMPZAPI(submul)(mp_int rop, mp_int op1, mp_int op2);\n\n/* gmp: mpz_add_ui */\nvoid GMPZAPI(add_ui)(mp_int rop, mp_int op1, unsigned long op2);\n\n/* gmp: mpz_divexact_ui */\nvoid GMPZAPI(divexact_ui)(mp_int q, mp_int n, unsigned long d);\n\n/* gmp: mpz_mul_ui */\nvoid GMPZAPI(mul_ui)(mp_int rop, mp_int op1, unsigned long op2);\n\n/* gmp: mpz_pow_ui */\nvoid GMPZAPI(pow_ui)(mp_int rop, mp_int base, unsigned long exp);\n\n/* gmp: mpz_sub_ui */\nvoid GMPZAPI(sub_ui)(mp_int rop, mp_int op1, unsigned long op2);\n\n/* gmp: mpz_fdiv_q_ui */\nunsigned long GMPZAPI(fdiv_q_ui)(mp_int q, mp_int n, unsigned long d);\n\n/* gmp: mpz_sizeinbase */\nsize_t GMPZAPI(sizeinbase)(mp_int op, int base);\n\n/*************************************************************************\n *\n * Functions with different behavior in corner cases\n *\n *************************************************************************/\n/* gmp: mpz_gcd */\n/* gmp: When op1 = 0 and op2 = 0, return 0.*/\nvoid GMPZAPI(gcd)(mp_int rop, mp_int op1, mp_int op2);\n\n/* gmp: mpz_get_str */\n/* gmp: If str is NULL then allocate space using the default allocator. */\nchar* GMPZAPI(get_str)(char *str, int radix, mp_int op);\n\n/* gmp: mpq_get_str */\n/* gmp: If str is NULL then allocate space using the default allocator. */\n/* gmp: If value is a whole number do not print denomenator. */\n/* TODO: Need to handle 0 values better. GMP prints 0/4 instead of 0.*/\nchar* GMPQAPI(get_str)(char *str, int radix, mp_rat op);\n\n/* gmp: mpz_set_str */\n/* gmp: Allow and ignore spaces in string. */\nint GMPZAPI(set_str)(mp_int rop, char *str, int base);\n\n/* gmp: mpq_set_str */\nint GMPQAPI(set_str)(mp_rat rop, char *str, int base);\n\n/* gmp: mpz_get_ui */\n/* gmp: Return least significant bits if value is too big for a long. */\nunsigned long GMPZAPI(get_ui)(mp_int op);\n\n/* gmp: mpz_get_si */\n/* gmp: Return least significant bits if value is too bit for a long. */\n/* gmp: If value is too big for long, return the least significant\n        (8*sizeof(long)-1) bits from the op and set the sign bit according to\n        the sign of the op. */\nlong GMPZAPI(get_si)(mp_int op);\n\n/* gmp: mpz_lcm */\n/* gmp: When op1 = 0 or op2 = 0, return 0.*/\n/* gmp: The resutl of lcm(a,b) is always positive. */\nvoid GMPZAPI(lcm)(mp_int rop, mp_int op1, mp_int op2);\n\n/* gmp: mpz_mul_2exp */\n/* gmp: allow big values for op2 when op1 == 0 */\nvoid GMPZAPI(mul_2exp)(mp_int rop, mp_int op1, unsigned long op2);\n\n/*************************************************************************\n *\n * Functions needing expanded functionality\n *\n *************************************************************************/\n/* gmp: mpz_cdiv_q */\nvoid GMPZAPI(cdiv_q)(mp_int q, mp_int n, mp_int d);\n\n/* gmp: mpz_fdiv_q */\nvoid GMPZAPI(fdiv_q)(mp_int q, mp_int n, mp_int d);\n\n/* gmp: mpz_fdiv_r */\nvoid GMPZAPI(fdiv_r)(mp_int r, mp_int n, mp_int d);\n\n/* gmp: mpz_tdiv_q */\nvoid GMPZAPI(tdiv_q)(mp_int q, mp_int n, mp_int d);\n\n/* gmp: mpz_export */\nvoid* GMPZAPI(export)(void *rop, size_t *countp, int order, size_t size, int endian, size_t nails, mp_int op);\n\n/* gmp: mpz_import */\nvoid GMPZAPI(import)(mp_int rop, size_t count, int order, size_t size, int endian, size_t nails, const void* op);\n\n#ifdef __cplusplus\n}\n#endif\n#endif /* end IMATH_GMP_COMPAT_H_ */\n"}, "3": {"id": 3, "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/imath/imath.h", "content": "/*\n  Name:     imath.h\n  Purpose:  Arbitrary precision integer arithmetic routines.\n  Author:   M. J. Fromberger\n\n  Copyright (C) 2002-2007 Michael J. Fromberger, All Rights Reserved.\n\n  Permission is hereby granted, free of charge, to any person obtaining a copy\n  of this software and associated documentation files (the \"Software\"), to deal\n  in the Software without restriction, including without limitation the rights\n  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n  copies of the Software, and to permit persons to whom the Software is\n  furnished to do so, subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be included in\n  all copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE\n  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n  SOFTWARE.\n */\n\n#ifndef IMATH_H_\n#define IMATH_H_\n\n#include <limits.h>\n#include <stdbool.h>\n#include <stdint.h>\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\ntypedef unsigned char  mp_sign;\ntypedef unsigned int   mp_size;\ntypedef int            mp_result;\ntypedef long           mp_small;  /* must be a signed type */\ntypedef unsigned long  mp_usmall; /* must be an unsigned type */\n\n\n/* Build with words as uint64_t by default. */\n#ifdef USE_32BIT_WORDS\ntypedef uint16_t        mp_digit;\ntypedef uint32_t        mp_word;\n#  define MP_DIGIT_MAX  (UINT16_MAX * 1UL)\n#  define MP_WORD_MAX   (UINT32_MAX * 1UL)\n#else\ntypedef uint32_t        mp_digit;\ntypedef uint64_t        mp_word;\n#  define MP_DIGIT_MAX  (UINT32_MAX * UINT64_C(1))\n#  define MP_WORD_MAX   (UINT64_MAX)\n#endif\n\ntypedef struct {\n  mp_digit  single;\n  mp_digit* digits;\n  mp_size   alloc;\n  mp_size   used;\n  mp_sign   sign;\n} mpz_t, *mp_int;\n\nstatic inline mp_digit* MP_DIGITS(mp_int Z) { return Z->digits; }\nstatic inline mp_size   MP_ALLOC(mp_int Z)  { return Z->alloc; }\nstatic inline mp_size   MP_USED(mp_int Z)   { return Z->used; }\nstatic inline mp_sign   MP_SIGN(mp_int Z)   { return Z->sign; }\n\nextern const mp_result MP_OK;\nextern const mp_result MP_FALSE;\nextern const mp_result MP_TRUE;\nextern const mp_result MP_MEMORY;\nextern const mp_result MP_RANGE;\nextern const mp_result MP_UNDEF;\nextern const mp_result MP_TRUNC;\nextern const mp_result MP_BADARG;\nextern const mp_result MP_MINERR;\n\n#define MP_DIGIT_BIT   (sizeof(mp_digit) * CHAR_BIT)\n#define MP_WORD_BIT    (sizeof(mp_word) * CHAR_BIT)\n#define MP_SMALL_MIN   LONG_MIN\n#define MP_SMALL_MAX   LONG_MAX\n#define MP_USMALL_MAX  ULONG_MAX\n\n#define MP_MIN_RADIX   2\n#define MP_MAX_RADIX   36\n\n/** Sets the default number of digits allocated to an `mp_int` constructed by\n    `mp_int_init_size()` with `prec == 0`. Allocations are rounded up to\n    multiples of this value. `MP_DEFAULT_PREC` is the default value. Requires\n    `ndigits > 0`. */\nvoid mp_int_default_precision(mp_size ndigits);\n\n/** Sets the number of digits below which multiplication will use the standard\n    quadratic \"schoolbook\" multiplication algorithm rather than Karatsuba-Ofman.\n    Requires `ndigits >= sizeof(mp_word)`. */\nvoid mp_int_multiply_threshold(mp_size ndigits);\n\n/** A sign indicating a (strictly) negative value. */\nextern const mp_sign MP_NEG;\n\n/** A sign indicating a zero or positive value. */\nextern const mp_sign MP_ZPOS;\n\n/** Reports whether `z` is odd, having remainder 1 when divided by 2. */\nstatic inline bool mp_int_is_odd(mp_int z) { return (z->digits[0] & 1) != 0; }\n\n/** Reports whether `z` is even, having remainder 0 when divided by 2. */\nstatic inline bool mp_int_is_even(mp_int z) { return (z->digits[0] & 1) == 0; }\n\n/** Initializes `z` with 1-digit precision and sets it to zero.  This function\n    cannot fail unless `z == NULL`. */\nmp_result mp_int_init(mp_int z);\n\n/** Allocates a fresh zero-valued `mpz_t` on the heap, returning NULL in case\n    of error. The only possible error is out-of-memory. */\nmp_int mp_int_alloc(void);\n\n/** Initializes `z` with at least `prec` digits of storage, and sets it to\n    zero. If `prec` is zero, the default precision is used. In either case the\n    size is rounded up to the nearest multiple of the word size. */\nmp_result mp_int_init_size(mp_int z, mp_size prec);\n\n/** Initializes `z` to be a copy of an already-initialized value in `old`. The\n    new copy does not share storage with the original. */\nmp_result mp_int_init_copy(mp_int z, mp_int old);\n\n/** Initializes `z` to the specified signed `value` at default precision. */\nmp_result mp_int_init_value(mp_int z, mp_small value);\n\n/** Initializes `z` to the specified unsigned `value` at default precision. */\nmp_result mp_int_init_uvalue(mp_int z, mp_usmall uvalue);\n\n/** Sets `z` to the value of the specified signed `value`. */\nmp_result mp_int_set_value(mp_int z, mp_small value);\n\n/** Sets `z` to the value of the specified unsigned `value`. */\nmp_result mp_int_set_uvalue(mp_int z, mp_usmall uvalue);\n\n/** Releases the storage used by `z`. */\nvoid mp_int_clear(mp_int z);\n\n/** Releases the storage used by `z` and also `z` itself.\n    This should only be used for `z` allocated by `mp_int_alloc()`. */\nvoid mp_int_free(mp_int z);\n\n/** Replaces the value of `c` with a copy of the value of `a`. No new memory is\n    allocated unless `a` has more significant digits than `c` has allocated. */\nmp_result mp_int_copy(mp_int a, mp_int c);\n\n/** Swaps the values and storage between `a` and `c`. */\nvoid mp_int_swap(mp_int a, mp_int c);\n\n/** Sets `z` to zero. The allocated storage of `z` is not changed. */\nvoid mp_int_zero(mp_int z);\n\n/** Sets `c` to the absolute value of `a`. */\nmp_result mp_int_abs(mp_int a, mp_int c);\n\n/** Sets `c` to the additive inverse (negation) of `a`. */\nmp_result mp_int_neg(mp_int a, mp_int c);\n\n/** Sets `c` to the sum of `a` and `b`. */\nmp_result mp_int_add(mp_int a, mp_int b, mp_int c);\n\n/** Sets `c` to the sum of `a` and `value`. */\nmp_result mp_int_add_value(mp_int a, mp_small value, mp_int c);\n\n/** Sets `c` to the difference of `a` less `b`. */\nmp_result mp_int_sub(mp_int a, mp_int b, mp_int c);\n\n/** Sets `c` to the difference of `a` less `value`. */\nmp_result mp_int_sub_value(mp_int a, mp_small value, mp_int c);\n\n/** Sets `c` to the product of `a` and `b`. */\nmp_result mp_int_mul(mp_int a, mp_int b, mp_int c);\n\n/** Sets `c` to the product of `a` and `value`. */\nmp_result mp_int_mul_value(mp_int a, mp_small value, mp_int c);\n\n/** Sets `c` to the product of `a` and `2^p2`. Requires `p2 >= 0`. */\nmp_result mp_int_mul_pow2(mp_int a, mp_small p2, mp_int c);\n\n/** Sets `c` to the square of `a`. */\nmp_result mp_int_sqr(mp_int a, mp_int c);\n\n/** Sets `q` and `r` to the quotent and remainder of `a / b`. Division by\n    powers of 2 is detected and handled efficiently.  The remainder is pinned\n    to `0 <= r < b`.\n\n    Either of `q` or `r` may be NULL, but not both, and `q` and `r` may not\n    point to the same value. */\nmp_result mp_int_div(mp_int a, mp_int b, mp_int q, mp_int r);\n\n/** Sets `q` and `*r` to the quotent and remainder of `a / value`. Division by\n    powers of 2 is detected and handled efficiently. The remainder is pinned to\n    `0 <= *r < b`. Either of `q` or `r` may be NULL. */\nmp_result mp_int_div_value(mp_int a, mp_small value, mp_int q, mp_small *r);\n\n/** Sets `q` and `r` to the quotient and remainder of `a / 2^p2`. This is a\n    special case for division by powers of two that is more efficient than\n    using ordinary division. Note that `mp_int_div()` will automatically handle\n    this case, this function is for cases where you have only the exponent. */\nmp_result mp_int_div_pow2(mp_int a, mp_small p2, mp_int q, mp_int r);\n\n/** Sets `c` to the remainder of `a / m`.\n    The remainder is pinned to `0 <= c < m`. */\nmp_result mp_int_mod(mp_int a, mp_int m, mp_int c);\n\n/** Sets `c` to the value of `a` raised to the `b` power.\n    It returns `MP_RANGE` if `b < 0`. */\nmp_result mp_int_expt(mp_int a, mp_small b, mp_int c);\n\n/** Sets `c` to the value of `a` raised to the `b` power.\n    It returns `MP_RANGE` if `b < 0`. */\nmp_result mp_int_expt_value(mp_small a, mp_small b, mp_int c);\n\n/** Sets `c` to the value of `a` raised to the `b` power.\n    It returns `MP_RANGE`) if `b < 0`. */\nmp_result mp_int_expt_full(mp_int a, mp_int b, mp_int c);\n\n/** Sets `*r` to the remainder of `a / value`.\n    The remainder is pinned to `0 <= r < value`. */\nstatic inline\nmp_result mp_int_mod_value(mp_int a, mp_small value, mp_small* r) {\n  return mp_int_div_value(a, value, 0, r);\n}\n\n/** Returns the comparator of `a` and `b`. */\nint mp_int_compare(mp_int a, mp_int b);\n\n/** Returns the comparator of the magnitudes of `a` and `b`, disregarding their\n    signs. Neither `a` nor `b` is modified by the comparison. */\nint mp_int_compare_unsigned(mp_int a, mp_int b);\n\n/** Returns the comparator of `z` and zero. */\nint mp_int_compare_zero(mp_int z);\n\n/** Returns the comparator of `z` and the signed value `v`. */\nint mp_int_compare_value(mp_int z, mp_small v);\n\n/** Returns the comparator of `z` and the unsigned value `uv`. */\nint mp_int_compare_uvalue(mp_int z, mp_usmall uv);\n\n/** Reports whether `a` is divisible by `v`. */\nbool mp_int_divisible_value(mp_int a, mp_small v);\n\n/** Returns `k >= 0` such that `z` is `2^k`, if such a `k` exists. If no such\n    `k` exists, the function returns -1. */\nint mp_int_is_pow2(mp_int z);\n\n/** Sets `c` to the value of `a` raised to the `b` power, reduced modulo `m`.\n    It returns `MP_RANGE` if `b < 0` or `MP_UNDEF` if `m == 0`. */\nmp_result mp_int_exptmod(mp_int a, mp_int b, mp_int m, mp_int c);\n\n/** Sets `c` to the value of `a` raised to the `value` power, modulo `m`.\n    It returns `MP_RANGE` if `value < 0` or `MP_UNDEF` if `m == 0`. */\nmp_result mp_int_exptmod_evalue(mp_int a, mp_small value, mp_int m, mp_int c);\n\n/** Sets `c` to the value of `value` raised to the `b` power, modulo `m`.\n    It returns `MP_RANGE` if `b < 0` or `MP_UNDEF` if `m == 0`. */\nmp_result mp_int_exptmod_bvalue(mp_small value, mp_int b, mp_int m, mp_int c);\n\n/** Sets `c` to the value of `a` raised to the `b` power, reduced modulo `m`,\n    given a precomputed reduction constant `mu` defined for Barrett's modular\n    reduction algorithm.\n\n    It returns `MP_RANGE` if `b < 0` or `MP_UNDEF` if `m == 0`. */\nmp_result mp_int_exptmod_known(mp_int a, mp_int b, mp_int m, mp_int mu, mp_int c);\n\n/** Sets `c` to the reduction constant for Barrett reduction by modulus `m`.\n    Requires that `c` and `m` point to distinct locations. */\nmp_result mp_int_redux_const(mp_int m, mp_int c);\n\n/** Sets `c` to the multiplicative inverse of `a` modulo `m`, if it exists.\n    The least non-negative representative of the congruence class is computed.\n\n    It returns `MP_UNDEF` if the inverse does not exist, or `MP_RANGE` if `a ==\n    0` or `m <= 0`. */\nmp_result mp_int_invmod(mp_int a, mp_int m, mp_int c);\n\n/** Sets `c` to the greatest common divisor of `a` and `b`.\n\n    It returns `MP_UNDEF` if the GCD is undefined, such as for example if `a`\n    and `b` are both zero. */\nmp_result mp_int_gcd(mp_int a, mp_int b, mp_int c);\n\n/** Sets `c` to the greatest common divisor of `a` and `b`, and sets `x` and\n    `y` to values satisfying Bezout's identity `gcd(a, b) = ax + by`.\n\n    It returns `MP_UNDEF` if the GCD is undefined, such as for example if `a`\n    and `b` are both zero. */\nmp_result mp_int_egcd(mp_int a, mp_int b, mp_int c, mp_int x, mp_int y);\n\n/** Sets `c` to the least common multiple of `a` and `b`.\n\n    It returns `MP_UNDEF` if the LCM is undefined, such as for example if `a`\n    and `b` are both zero. */\nmp_result mp_int_lcm(mp_int a, mp_int b, mp_int c);\n\n/** Sets `c` to the greatest integer not less than the `b`th root of `a`,\n    using Newton's root-finding algorithm.\n    It returns `MP_UNDEF` if `a < 0` and `b` is even. */\nmp_result mp_int_root(mp_int a, mp_small b, mp_int c);\n\n/** Sets `c` to the greatest integer not less than the square root of `a`.\n    This is a special case of `mp_int_root()`. */\nstatic inline\nmp_result mp_int_sqrt(mp_int a, mp_int c) { return mp_int_root(a, 2, c); }\n\n/** Returns `MP_OK` if `z` is representable as `mp_small`, else `MP_RANGE`.\n    If `out` is not NULL, `*out` is set to the value of `z` when `MP_OK`. */\nmp_result mp_int_to_int(mp_int z, mp_small *out);\n\n/** Returns `MP_OK` if `z` is representable as `mp_usmall`, or `MP_RANGE`.\n    If `out` is not NULL, `*out` is set to the value of `z` when `MP_OK`. */\nmp_result mp_int_to_uint(mp_int z, mp_usmall *out);\n\n/** Converts `z` to a zero-terminated string of characters in the specified\n    `radix`, writing at most `limit` characters to `str` including the\n    terminating NUL value. A leading `-` is used to indicate a negative value.\n\n    Returns `MP_TRUNC` if `limit` was to small to write all of `z`.\n    Requires `MP_MIN_RADIX <= radix <= MP_MAX_RADIX`. */\nmp_result mp_int_to_string(mp_int z, mp_size radix, char *str, int limit);\n\n/** Reports the minimum number of characters required to represent `z` as a\n    zero-terminated string in the given `radix`.\n    Requires `MP_MIN_RADIX <= radix <= MP_MAX_RADIX`. */\nmp_result mp_int_string_len(mp_int z, mp_size radix);\n\n/** Reads a string of ASCII digits in the specified `radix` from the zero\n    terminated `str` provided into `z`. For values of `radix > 10`, the letters\n    `A`..`Z` or `a`..`z` are accepted. Letters are interpreted without respect\n    to case.\n\n    Leading whitespace is ignored, and a leading `+` or `-` is interpreted as a\n    sign flag. Processing stops when a NUL or any other character out of range\n    for a digit in the given radix is encountered.\n\n    If the whole string was consumed, `MP_OK` is returned; otherwise\n    `MP_TRUNC`. is returned.\n\n    Requires `MP_MIN_RADIX <= radix <= MP_MAX_RADIX`. */\nmp_result mp_int_read_string(mp_int z, mp_size radix, const char *str);\n\n/** Reads a string of ASCII digits in the specified `radix` from the zero\n    terminated `str` provided into `z`. For values of `radix > 10`, the letters\n    `A`..`Z` or `a`..`z` are accepted. Letters are interpreted without respect\n    to case.\n\n    Leading whitespace is ignored, and a leading `+` or `-` is interpreted as a\n    sign flag. Processing stops when a NUL or any other character out of range\n    for a digit in the given radix is encountered.\n\n    If the whole string was consumed, `MP_OK` is returned; otherwise\n    `MP_TRUNC`. is returned. If `end` is not NULL, `*end` is set to point to\n    the first unconsumed byte of the input string (the NUL byte if the whole\n    string was consumed). This emulates the behavior of the standard C\n    `strtol()` function.\n\n    Requires `MP_MIN_RADIX <= radix <= MP_MAX_RADIX`. */\nmp_result mp_int_read_cstring(mp_int z, mp_size radix, const char *str, char **end);\n\n/** Returns the number of significant bits in `z`. */\nmp_result mp_int_count_bits(mp_int z);\n\n/** Converts `z` to 2's complement binary, writing at most `limit` bytes into\n    the given `buf`.  Returns `MP_TRUNC` if the buffer limit was too small to\n    contain the whole value.  If this occurs, the contents of buf will be\n    effectively garbage, as the function uses the buffer as scratch space.\n\n    The binary representation of `z` is in base-256 with digits ordered from\n    most significant to least significant (network byte ordering).  The\n    high-order bit of the first byte is set for negative values, clear for\n    non-negative values.\n\n    As a result, non-negative values will be padded with a leading zero byte if\n    the high-order byte of the base-256 magnitude is set.  This extra byte is\n    accounted for by the `mp_int_binary_len()` function. */\nmp_result mp_int_to_binary(mp_int z, unsigned char *buf, int limit);\n\n/** Reads a 2's complement binary value from `buf` into `z`, where `len` is the\n    length of the buffer.  The contents of `buf` may be overwritten during\n    processing, although they will be restored when the function returns. */\nmp_result mp_int_read_binary(mp_int z, unsigned char *buf, int len);\n\n/** Returns the number of bytes to represent `z` in 2's complement binary. */\nmp_result mp_int_binary_len(mp_int z);\n\n/** Converts the magnitude of `z` to unsigned binary, writing at most `limit`\n    bytes into the given `buf`.  The sign of `z` is ignored, but `z` is not\n    modified.  Returns `MP_TRUNC` if the buffer limit was too small to contain\n    the whole value.  If this occurs, the contents of `buf` will be effectively\n    garbage, as the function uses the buffer as scratch space during\n    conversion.\n\n    The binary representation of `z` is in base-256 with digits ordered from\n    most significant to least significant (network byte ordering). */\nmp_result mp_int_to_unsigned(mp_int z, unsigned char *buf, int limit);\n\n/** Reads an unsigned binary value from `buf` into `z`, where `len` is the\n    length of the buffer. The contents of `buf` are not modified during\n    processing. */\nmp_result mp_int_read_unsigned(mp_int z, unsigned char *buf, int len);\n\n/** Returns the number of bytes required to represent `z` as an unsigned binary\n    value in base 256. */\nmp_result mp_int_unsigned_len(mp_int z);\n\n/** Returns a pointer to a brief, human-readable, zero-terminated string\n    describing `res`. The returned string is statically allocated and must not\n    be freed by the caller. */\nconst char *mp_error_string(mp_result res);\n\n#ifdef __cplusplus\n}\n#endif\n#endif /* end IMATH_H_ */\n"}, "4": {"id": 4, "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/imath/imrat.h", "content": "/*\n  Name:     imrat.h\n  Purpose:  Arbitrary precision rational arithmetic routines.\n  Author:   M. J. Fromberger\n\n  Copyright (C) 2002-2007 Michael J. Fromberger, All Rights Reserved.\n\n  Permission is hereby granted, free of charge, to any person obtaining a copy\n  of this software and associated documentation files (the \"Software\"), to deal\n  in the Software without restriction, including without limitation the rights\n  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n  copies of the Software, and to permit persons to whom the Software is\n  furnished to do so, subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be included in\n  all copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE\n  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n  SOFTWARE.\n */\n\n#ifndef IMRAT_H_\n#define IMRAT_H_\n\n#include <stdbool.h>\n\n#include \"imath.h\"\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\ntypedef struct {\n  mpz_t   num;    /* Numerator         */\n  mpz_t   den;    /* Denominator, <> 0 */\n} mpq_t, *mp_rat;\n\n/* Return a pointer to the numerator. */\nstatic inline mp_int MP_NUMER_P(mp_rat Q) { return &(Q->num); }\n\n/* Return a pointer to the denominator. */\nstatic inline mp_int MP_DENOM_P(mp_rat Q) { return &(Q->den); }\n\n/* Rounding constants */\ntypedef enum {\n  MP_ROUND_DOWN,\n  MP_ROUND_HALF_UP,\n  MP_ROUND_UP,\n  MP_ROUND_HALF_DOWN\n} mp_round_mode;\n\n/** Initializes `r` with 1-digit precision and sets it to zero. This function\n    cannot fail unless `r` is NULL. */\nmp_result mp_rat_init(mp_rat r);\n\n/** Allocates a fresh zero-valued `mpq_t` on the heap, returning NULL in case\n    of error. The only possible error is out-of-memory. */\nmp_rat mp_rat_alloc(void);\n\n/** Reduces `r` in-place to lowest terms and canonical form.\n\n    Zero is represented as 0/1, one as 1/1, and signs are adjusted so that the\n    sign of the value is carried by the numerator. */\nmp_result mp_rat_reduce(mp_rat r);\n\n/** Initializes `r` with at least `n_prec` digits of storage for the numerator\n    and `d_prec` digits of storage for the denominator, and value zero.\n\n    If either precision is zero, the default precision is used, rounded up to\n    the nearest word size. */\nmp_result mp_rat_init_size(mp_rat r, mp_size n_prec, mp_size d_prec);\n\n/** Initializes `r` to be a copy of an already-initialized value in `old`. The\n    new copy does not share storage with the original. */\nmp_result mp_rat_init_copy(mp_rat r, mp_rat old);\n\n/** Sets the value of `r` to the ratio of signed `numer` to signed `denom`.  It\n    returns `MP_UNDEF` if `denom` is zero. */\nmp_result mp_rat_set_value(mp_rat r, mp_small numer, mp_small denom);\n\n/** Sets the value of `r` to the ratio of unsigned `numer` to unsigned\n    `denom`. It returns `MP_UNDEF` if `denom` is zero. */\nmp_result mp_rat_set_uvalue(mp_rat r, mp_usmall numer, mp_usmall denom);\n\n/** Releases the storage used by `r`. */\nvoid mp_rat_clear(mp_rat r);\n\n/** Releases the storage used by `r` and also `r` itself.\n    This should only be used for `r` allocated by `mp_rat_alloc()`. */\nvoid mp_rat_free(mp_rat r);\n\n/** Sets `z` to a copy of the numerator of `r`. */\nmp_result mp_rat_numer(mp_rat r, mp_int z);\n\n/** Returns a pointer to the numerator of `r`. */\nmp_int mp_rat_numer_ref(mp_rat r);\n\n/** Sets `z` to a copy of the denominator of `r`. */\nmp_result mp_rat_denom(mp_rat r, mp_int z);\n\n/** Returns a pointer to the denominator of `r`. */\nmp_int mp_rat_denom_ref(mp_rat r);\n\n/** Reports the sign of `r`. */\nmp_sign mp_rat_sign(mp_rat r);\n\n/** Sets `c` to a copy of the value of `a`. No new memory is allocated unless a\n    term of `a` has more significant digits than the corresponding term of `c`\n    has allocated. */\nmp_result mp_rat_copy(mp_rat a, mp_rat c);\n\n/** Sets `r` to zero. The allocated storage of `r` is not changed. */\nvoid mp_rat_zero(mp_rat r);\n\n/** Sets `c` to the absolute value of `a`. */\nmp_result mp_rat_abs(mp_rat a, mp_rat c);\n\n/** Sets `c` to the absolute value of `a`. */\nmp_result mp_rat_neg(mp_rat a, mp_rat c);\n\n/** Sets `c` to the reciprocal of `a` if the reciprocal is defined.\n    It returns `MP_UNDEF` if `a` is zero. */\nmp_result mp_rat_recip(mp_rat a, mp_rat c);\n\n/** Sets `c` to the sum of `a` and `b`. */\nmp_result mp_rat_add(mp_rat a, mp_rat b, mp_rat c);\n\n/** Sets `c` to the difference of `a` less `b`. */\nmp_result mp_rat_sub(mp_rat a, mp_rat b, mp_rat c);\n\n/** Sets `c` to the product of `a` and `b`. */\nmp_result mp_rat_mul(mp_rat a, mp_rat b, mp_rat c);\n\n/** Sets `c` to the ratio `a / b` if that ratio is defined.\n    It returns `MP_UNDEF` if `b` is zero. */\nmp_result mp_rat_div(mp_rat a, mp_rat b, mp_rat c);\n\n/** Sets `c` to the sum of `a` and integer `b`. */\nmp_result mp_rat_add_int(mp_rat a, mp_int b, mp_rat c);\n\n/** Sets `c` to the difference of `a` less integer `b`. */\nmp_result mp_rat_sub_int(mp_rat a, mp_int b, mp_rat c);\n\n/** Sets `c` to the product of `a` and integer `b`. */\nmp_result mp_rat_mul_int(mp_rat a, mp_int b, mp_rat c);\n\n/** Sets `c` to the ratio `a / b` if that ratio is defined.\n    It returns `MP_UNDEF` if `b` is zero. */\nmp_result mp_rat_div_int(mp_rat a, mp_int b, mp_rat c);\n\n/** Sets `c` to the value of `a` raised to the `b` power.\n    It returns `MP_RANGE` if `b < 0`. */\nmp_result mp_rat_expt(mp_rat a, mp_small b, mp_rat c);\n\n/** Returns the comparator of `a` and `b`. */\nint mp_rat_compare(mp_rat a, mp_rat b);\n\n/** Returns the comparator of the magnitudes of `a` and `b`, disregarding their\n    signs. Neither `a` nor `b` is modified by the comparison. */\nint mp_rat_compare_unsigned(mp_rat a, mp_rat b);\n\n/** Returns the comparator of `r` and zero. */\nint mp_rat_compare_zero(mp_rat r);\n\n/** Returns the comparator of `r` and the signed ratio `n / d`.\n    It returns `MP_UNDEF` if `d` is zero. */\nint mp_rat_compare_value(mp_rat r, mp_small n, mp_small d);\n\n/** Reports whether `r` is an integer, having canonical denominator 1. */\nbool mp_rat_is_integer(mp_rat r);\n\n/** Reports whether the numerator and denominator of `r` can be represented as\n    small signed integers, and if so stores the corresponding values to `num`\n    and `den`. It returns `MP_RANGE` if either cannot be so represented. */\nmp_result mp_rat_to_ints(mp_rat r, mp_small *num, mp_small *den);\n\n/** Converts `r` to a zero-terminated string of the format `\"n/d\"` with `n` and\n    `d` in the specified radix and writing no more than `limit` bytes to the\n    given output buffer `str`. The output of the numerator includes a sign flag\n    if `r` is negative.  Requires `MP_MIN_RADIX <= radix <= MP_MAX_RADIX`. */\nmp_result mp_rat_to_string(mp_rat r, mp_size radix, char *str, int limit);\n\n/** Converts the value of `r` to a string in decimal-point notation with the\n    specified radix, writing no more than `limit` bytes of data to the given\n    output buffer.  It generates `prec` digits of precision, and requires\n    `MP_MIN_RADIX <= radix <= MP_MAX_RADIX`.\n\n    Ratios usually must be rounded when they are being converted for output as\n    a decimal value.  There are four rounding modes currently supported:\n\n      MP_ROUND_DOWN\n        Truncates the value toward zero.\n        Example:  12.009 to 2dp becomes 12.00\n\n      MP_ROUND_UP\n        Rounds the value away from zero:\n        Example:  12.001 to 2dp becomes 12.01, but\n                  12.000 to 2dp remains 12.00\n\n      MP_ROUND_HALF_DOWN\n         Rounds the value to nearest digit, half goes toward zero.\n         Example:  12.005 to 2dp becomes 12.00, but\n                   12.006 to 2dp becomes 12.01\n\n      MP_ROUND_HALF_UP\n         Rounds the value to nearest digit, half rounds upward.\n         Example:  12.005 to 2dp becomes 12.01, but\n                   12.004 to 2dp becomes 12.00\n*/\nmp_result mp_rat_to_decimal(mp_rat r, mp_size radix, mp_size prec,\n                            mp_round_mode round, char *str, int limit);\n\n/** Reports the minimum number of characters required to represent `r` as a\n    zero-terminated string in the given `radix`.\n    Requires `MP_MIN_RADIX <= radix <= MP_MAX_RADIX`. */\nmp_result mp_rat_string_len(mp_rat r, mp_size radix);\n\n/** Reports the length in bytes of the buffer needed to convert `r` using the\n    `mp_rat_to_decimal()` function with the specified `radix` and `prec`. The\n    buffer size estimate may slightly exceed the actual required capacity. */\nmp_result mp_rat_decimal_len(mp_rat r, mp_size radix, mp_size prec);\n\n/** Sets `r` to the value represented by a zero-terminated string `str` in the\n    format `\"n/d\"` including a sign flag. It returns `MP_UNDEF` if the encoded\n    denominator has value zero. */\nmp_result mp_rat_read_string(mp_rat r, mp_size radix, const char *str);\n\n/** Sets `r` to the value represented by a zero-terminated string `str` in the\n    format `\"n/d\"` including a sign flag. It returns `MP_UNDEF` if the encoded\n    denominator has value zero. If `end` is not NULL then `*end` is set to\n    point to the first unconsumed character in the string, after parsing.\n*/\nmp_result mp_rat_read_cstring(mp_rat r, mp_size radix, const char *str,\n\t\t\t      char **end);\n\n/** Sets `r` to the value represented by a zero-terminated string `str` having\n    one of the following formats, each with an optional leading sign flag:\n\n       n         : integer format, e.g. \"123\"\n       n/d       : ratio format, e.g., \"-12/5\"\n       z.ffff    : decimal format, e.g., \"1.627\"\n\n    It returns `MP_UNDEF` if the effective denominator is zero. If `end` is not\n    NULL then `*end` is set to point to the first unconsumed character in the\n    string, after parsing.\n*/\nmp_result mp_rat_read_ustring(mp_rat r, mp_size radix, const char *str,\n\t\t\t      char **end);\n\n/** Sets `r` to the value represented by a zero-terminated string `str` in the\n    format `\"z.ffff\"` including a sign flag. It returns `MP_UNDEF` if the\n    effective denominator. */\nmp_result mp_rat_read_decimal(mp_rat r, mp_size radix, const char *str);\n\n/** Sets `r` to the value represented by a zero-terminated string `str` in the\n    format `\"z.ffff\"` including a sign flag. It returns `MP_UNDEF` if the\n    effective denominator. If `end` is not NULL then `*end` is set to point to\n    the first unconsumed character in the string, after parsing. */\nmp_result mp_rat_read_cdecimal(mp_rat r, mp_size radix, const char *str,\n\t\t\t       char **end);\n\n#ifdef __cplusplus\n}\n#endif\n#endif /* IMRAT_H_ */\n"}, "5": {"id": 5, "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_aff_private.h", "content": "#ifndef ISL_AFF_PRIVATE_H\n#define ISL_AFF_PRIVATE_H\n\n#include <isl/aff.h>\n#include <isl/vec.h>\n#include <isl/mat.h>\n#include <isl/local_space.h>\n#include <isl_int.h>\n#include <isl_reordering.h>\n\n/* ls represents the domain space.\n *\n * If the first two elements of \"v\" (the denominator and the constant term)\n * are zero, then the isl_aff represents NaN.\n */\nstruct isl_aff {\n\tint ref;\n\n\tisl_local_space\t*ls;\n\tisl_vec\t\t*v;\n};\n\n#undef EL\n#define EL isl_aff\n\n#include <isl_list_templ.h>\n\nstruct isl_pw_aff_piece {\n\tstruct isl_set *set;\n\tstruct isl_aff *aff;\n};\n\nstruct isl_pw_aff {\n\tint ref;\n\n\tisl_space *dim;\n\n\tint n;\n\n\tsize_t size;\n\tstruct isl_pw_aff_piece p[1];\n};\n\n#undef PW\n#define PW isl_pw_aff\n\n#include <isl_pw_templ.h>\n\n#undef EL\n#define EL isl_pw_aff\n\n#include <isl_list_templ.h>\n\nstruct isl_pw_multi_aff_piece {\n\tisl_set *set;\n\tisl_multi_aff *maff;\n};\n\nstruct isl_pw_multi_aff {\n\tint ref;\n\n\tisl_space *dim;\n\n\tint n;\n\n\tsize_t size;\n\tstruct isl_pw_multi_aff_piece p[1];\n};\n\n#undef PW\n#define PW isl_pw_multi_aff\n\n#include <isl_pw_templ.h>\n\n__isl_give isl_aff *isl_aff_alloc_vec(__isl_take isl_local_space *ls,\n\t__isl_take isl_vec *v);\n__isl_give isl_aff *isl_aff_alloc(__isl_take isl_local_space *ls);\n\nisl_size isl_aff_domain_dim(__isl_keep isl_aff *aff, enum isl_dim_type type);\nisl_size isl_aff_domain_offset(__isl_keep isl_aff *aff, enum isl_dim_type type);\n\n__isl_give isl_aff *isl_aff_reset_space_and_domain(__isl_take isl_aff *aff,\n\t__isl_take isl_space *space, __isl_take isl_space *domain);\n__isl_give isl_aff *isl_aff_reset_domain_space(__isl_take isl_aff *aff,\n\t__isl_take isl_space *space);\n__isl_give isl_aff *isl_aff_realign_domain(__isl_take isl_aff *aff,\n\t__isl_take isl_reordering *r);\n\n__isl_give isl_aff *isl_aff_set_constant(__isl_take isl_aff *aff, isl_int v);\n__isl_give isl_aff *isl_aff_set_coefficient(__isl_take isl_aff *aff,\n\tenum isl_dim_type type, int pos, isl_int v);\n__isl_give isl_aff *isl_aff_add_constant(__isl_take isl_aff *aff, isl_int v);\n\n__isl_give isl_aff *isl_aff_domain_factor_domain(__isl_take isl_aff *aff);\n\nint isl_aff_plain_cmp(__isl_keep isl_aff *aff1, __isl_keep isl_aff *aff2);\n\n__isl_give isl_aff *isl_aff_remove_unused_divs(__isl_take isl_aff *aff);\n__isl_give isl_aff *isl_aff_normalize(__isl_take isl_aff *aff);\n\n__isl_give isl_aff *isl_aff_expand_divs( __isl_take isl_aff *aff,\n\t__isl_take isl_mat *div, int *exp);\n\n__isl_give isl_pw_aff *isl_pw_aff_alloc_size(__isl_take isl_space *space,\n\tint n);\n__isl_give isl_pw_aff *isl_pw_aff_reset_space(__isl_take isl_pw_aff *pwaff,\n\t__isl_take isl_space *space);\n__isl_give isl_pw_aff *isl_pw_aff_reset_domain_space(\n\t__isl_take isl_pw_aff *pwaff, __isl_take isl_space *space);\n__isl_give isl_pw_aff *isl_pw_aff_add_disjoint(\n\t__isl_take isl_pw_aff *pwaff1, __isl_take isl_pw_aff *pwaff2);\n\n__isl_give isl_pw_aff *isl_pw_aff_domain_factor_domain(\n\t__isl_take isl_pw_aff *pa);\n\n__isl_give isl_pw_aff *isl_pw_aff_union_opt(__isl_take isl_pw_aff *pwaff1,\n\t__isl_take isl_pw_aff *pwaff2, int max);\n\n__isl_give isl_pw_aff *isl_pw_aff_set_rational(__isl_take isl_pw_aff *pwaff);\n__isl_give isl_pw_aff_list *isl_pw_aff_list_set_rational(\n\t__isl_take isl_pw_aff_list *list);\n\n__isl_give isl_aff *isl_aff_scale_down(__isl_take isl_aff *aff, isl_int f);\n__isl_give isl_pw_aff *isl_pw_aff_scale(__isl_take isl_pw_aff *pwaff,\n\tisl_int f);\n__isl_give isl_pw_aff *isl_pw_aff_scale_down(__isl_take isl_pw_aff *pwaff,\n\tisl_int f);\n\nisl_bool isl_aff_matching_params(__isl_keep isl_aff *aff,\n\t__isl_keep isl_space *space);\nisl_stat isl_aff_check_match_domain_space(__isl_keep isl_aff *aff,\n\t__isl_keep isl_space *space);\n\n#undef BASE\n#define BASE aff\n\n#include <isl_multi_templ.h>\n\n__isl_give isl_multi_aff *isl_multi_aff_dup(__isl_keep isl_multi_aff *multi);\n\n__isl_give isl_multi_aff *isl_multi_aff_align_divs(\n\t__isl_take isl_multi_aff *maff);\n\n__isl_give isl_multi_aff *isl_multi_aff_from_basic_set_equalities(\n\t__isl_take isl_basic_set *bset);\n\n__isl_give isl_multi_aff *isl_multi_aff_from_aff_mat(\n\t__isl_take isl_space *space, __isl_take isl_mat *mat);\n\n#undef EL\n#define EL isl_pw_multi_aff\n\n#include <isl_list_templ.h>\n\n__isl_give isl_pw_multi_aff *isl_pw_multi_aff_move_dims(\n\t__isl_take isl_pw_multi_aff *pma,\n\tenum isl_dim_type dst_type, unsigned dst_pos,\n\tenum isl_dim_type src_type, unsigned src_pos, unsigned n);\n\n__isl_give isl_pw_multi_aff *isl_pw_multi_aff_reset_domain_space(\n\t__isl_take isl_pw_multi_aff *pwmaff, __isl_take isl_space *space);\n__isl_give isl_pw_multi_aff *isl_pw_multi_aff_reset_space(\n\t__isl_take isl_pw_multi_aff *pwmaff, __isl_take isl_space *space);\n__isl_give isl_pw_multi_aff *isl_pw_multi_aff_add_disjoint(\n\t__isl_take isl_pw_multi_aff *pma1, __isl_take isl_pw_multi_aff *pma2);\n\n__isl_give isl_pw_multi_aff *isl_pw_multi_aff_project_out(\n\t__isl_take isl_pw_multi_aff *pma,\n\tenum isl_dim_type type, unsigned first, unsigned n);\n\nisl_stat isl_seq_preimage(isl_int *dst, isl_int *src,\n\t__isl_keep isl_multi_aff *ma, int n_before, int n_after,\n\tint n_div_ma, int n_div_bmap,\n\tisl_int f, isl_int c1, isl_int c2, isl_int g, int has_denom);\n\n__isl_give isl_aff *isl_aff_substitute_equalities(__isl_take isl_aff *aff,\n\t__isl_take isl_basic_set *eq);\n__isl_give isl_pw_multi_aff *isl_pw_multi_aff_substitute(\n\t__isl_take isl_pw_multi_aff *pma, enum isl_dim_type type, unsigned pos,\n\t__isl_keep isl_pw_aff *subs);\n\nisl_stat isl_pw_aff_check_named_params(__isl_keep isl_pw_aff *pa);\nisl_stat isl_multi_aff_check_named_params(__isl_keep isl_multi_aff *ma);\nisl_stat isl_pw_multi_aff_check_named_params(__isl_keep isl_pw_multi_aff *pma);\n\nisl_bool isl_pw_aff_matching_params(__isl_keep isl_pw_aff *pa,\n\t__isl_keep isl_space *space);\nisl_stat isl_pw_aff_check_match_domain_space(__isl_keep isl_pw_aff *pa,\n\t__isl_keep isl_space *space);\n\n__isl_give isl_basic_set *isl_aff_pos_basic_set(__isl_take isl_aff *aff);\n\n#undef BASE\n#define BASE pw_aff\n#undef DOMBASE\n#define DOMBASE set\n#define EXPLICIT_DOMAIN\n\n#include <isl_multi_templ.h>\n\n#undef EXPLICIT_DOMAIN\n\n__isl_give isl_map *isl_map_intersect_multi_pw_aff_explicit_domain(\n\t__isl_take isl_map *map, __isl_keep isl_multi_pw_aff *mpa);\n\n#undef EL\n#define EL isl_union_pw_aff\n\n#include <isl_list_templ.h>\n\n#undef BASE\n#define BASE union_pw_aff\n#undef DOMBASE\n#define DOMBASE union_set\n#define EXPLICIT_DOMAIN\n\n#include <isl_multi_templ.h>\n\n#undef EXPLICIT_DOMAIN\n\n#undef EL\n#define EL isl_union_pw_multi_aff\n\n#include <isl_list_templ.h>\n\n#endif\n"}, "6": {"id": 6, "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_blk.h", "content": "/*\n * Copyright 2008-2009 Katholieke Universiteit Leuven\n *\n * Use of this software is governed by the MIT license\n *\n * Written by Sven Verdoolaege, K.U.Leuven, Departement\n * Computerwetenschappen, Celestijnenlaan 200A, B-3001 Leuven, Belgium\n */\n\n#ifndef ISL_BLK_H\n#define ISL_BLK_H\n\n#include <isl_int.h>\n\n#if defined(__cplusplus)\nextern \"C\" {\n#endif\n\nstruct isl_blk {\n\tsize_t size;\n\tisl_int *data;\n};\n\n#define ISL_BLK_CACHE_SIZE\t20\n\nstruct isl_ctx;\n\nstruct isl_blk isl_blk_alloc(struct isl_ctx *ctx, size_t n);\nstruct isl_blk isl_blk_empty(void);\nint isl_blk_is_error(struct isl_blk block);\nstruct isl_blk isl_blk_extend(struct isl_ctx *ctx, struct isl_blk block,\n\t\t\t\tsize_t new_n);\nvoid isl_blk_free(struct isl_ctx *ctx, struct isl_blk block);\nvoid isl_blk_clear_cache(struct isl_ctx *ctx);\n\n#if defined(__cplusplus)\n}\n#endif\n\n#endif\n"}, "7": {"id": 7, "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_config_post.h", "content": "#ifndef HAVE___ATTRIBUTE__\n#define __attribute__(x)\n#endif\n\n#if HAVE_DECL_FFS\n#include <strings.h>\n#endif\n\n#if (HAVE_DECL_FFS==0) && (HAVE_DECL___BUILTIN_FFS==1)\n#define ffs __builtin_ffs\n#endif\n\n#if !HAVE_DECL_FFS && !HAVE_DECL___BUILTIN_FFS && HAVE_DECL__BITSCANFORWARD\nint isl_ffs(int i);\n#define ffs isl_ffs\n#endif\n\n#if HAVE_DECL_STRCASECMP || HAVE_DECL_STRNCASECMP\n#include <strings.h>\n#endif\n\n#if !HAVE_DECL_STRCASECMP && HAVE_DECL__STRICMP\n#define strcasecmp _stricmp\n#endif\n\n#if !HAVE_DECL_STRNCASECMP && HAVE_DECL__STRNICMP\n#define strncasecmp _strnicmp\n#endif\n\n#if HAVE_DECL__SNPRINTF\n#define snprintf _snprintf\n#endif\n\n#ifdef GCC_WARN_UNUSED_RESULT\n#define WARN_UNUSED\tGCC_WARN_UNUSED_RESULT\n#else\n#define WARN_UNUSED\n#endif\n"}, "8": {"id": 8, "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_ctx_private.h", "content": "#include <isl/ctx.h>\n#include <isl_blk.h>\n\n/* \"error\" stores the last error that has occurred.\n * It is reset to isl_error_none by isl_ctx_reset_error.\n * \"error_msg\" stores the error message of the last error,\n * while \"error_file\" and \"error_line\" specify where the last error occurred.\n * \"error_msg\" and \"error_file\" always point to statically allocated\n * strings (if not NULL).\n */\nstruct isl_ctx {\n\tint\t\t\tref;\n\n\tstruct isl_stats\t*stats;\n\n\tint\t\t\t opt_allocated;\n\tstruct isl_options\t*opt;\n\tvoid\t\t\t*user_opt;\n\tstruct isl_args\t\t*user_args;\n\n\tisl_int\t\t\tzero;\n\tisl_int\t\t\tone;\n\tisl_int\t\t\ttwo;\n\tisl_int\t\t\tnegone;\n\n\tisl_int\t\t\tnormalize_gcd;\n\n\tint\t\t\tn_cached;\n\tint\t\t\tn_miss;\n\tstruct isl_blk\t\tcache[ISL_BLK_CACHE_SIZE];\n\tstruct isl_hash_table\tid_table;\n\n\tenum isl_error\t\terror;\n\tconst char\t\t*error_msg;\n\tconst char\t\t*error_file;\n\tint\t\t\terror_line;\n\n\tint\t\t\tabort;\n\n\tunsigned long\t\toperations;\n\tunsigned long\t\tmax_operations;\n};\n\nint isl_ctx_next_operation(isl_ctx *ctx);\n"}, "9": {"id": 9, "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_id_private.h", "content": "/*\n * Copyright 2008-2009 Katholieke Universiteit Leuven\n *\n * Use of this software is governed by the MIT license\n *\n * Written by Sven Verdoolaege, K.U.Leuven, Departement\n * Computerwetenschappen, Celestijnenlaan 200A, B-3001 Leuven, Belgium\n */\n\n#ifndef ISL_ID_PRIVATE_H\n#define ISL_ID_PRIVATE_H\n\n#include <isl/id.h>\n#include <isl/stream.h>\n\n/* Represent a name and/or user pointer.\n *\n * If \"free_user\" is set, then it will be called on \"user\" when\n * the last instance of the isl_id is freed.\n */\nstruct isl_id {\n\tint ref;\n\tisl_ctx *ctx;\n\n\tconst char *name;\n\tvoid *user;\n\tuint32_t hash;\n\n\t__isl_give void (*free_user)(void *user);\n};\n\n#undef EL\n#define EL isl_id\n\n#include <isl_list_templ.h>\n\nuint32_t isl_hash_id(uint32_t hash, __isl_keep isl_id *id);\nint isl_id_cmp(__isl_keep isl_id *id1, __isl_keep isl_id *id2);\n__isl_give isl_id *isl_stream_read_id(__isl_keep isl_stream *s);\n\nextern isl_id isl_id_none;\n\n#undef BASE\n#define BASE id\n\n#include <isl_multi_templ.h>\n\n#endif\n"}, "10": {"id": 10, "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_imath.h", "content": "#include <imath.h>\n#include <gmp_compat.h>\n\nuint32_t isl_imath_hash(mp_int v, uint32_t hash);\nint isl_imath_fits_ulong_p(mp_int op);\nint isl_imath_fits_slong_p(mp_int op);\nvoid isl_imath_addmul_ui(mp_int rop, mp_int op1, unsigned long op2);\nvoid isl_imath_submul_ui(mp_int rop, mp_int op1, unsigned long op2);\nvoid isl_imath_cdiv_q_ui(mp_int rop, mp_int op1, unsigned long op2);\nvoid isl_imath_fdiv_q_ui(mp_int rop, mp_int op1, unsigned long op2);\n"}, "11": {"id": 11, "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_input.c", "content": "/*\n * Copyright 2008-2009 Katholieke Universiteit Leuven\n * Copyright 2010      INRIA Saclay\n * Copyright 2012-2013 Ecole Normale Superieure\n * Copyright 2019      Cerebras Systems\n *\n * Use of this software is governed by the MIT license\n *\n * Written by Sven Verdoolaege, K.U.Leuven, Departement\n * Computerwetenschappen, Celestijnenlaan 200A, B-3001 Leuven, Belgium\n * and INRIA Saclay - Ile-de-France, Parc Club Orsay Universite,\n * ZAC des vignes, 4 rue Jacques Monod, 91893 Orsay, France \n * and Ecole Normale Superieure, 45 rue d\u2019Ulm, 75230 Paris, France\n * and Cerebras Systems, 175 S San Antonio Rd, Los Altos, CA, USA\n */\n\n#include <ctype.h>\n#include <stdio.h>\n#include <string.h>\n#include <isl_ctx_private.h>\n#include <isl_map_private.h>\n#include <isl_id_private.h>\n#include <isl/set.h>\n#include <isl_seq.h>\n#include <isl_stream_private.h>\n#include <isl/obj.h>\n#include \"isl_polynomial_private.h\"\n#include <isl/union_set.h>\n#include <isl/union_map.h>\n#include <isl_mat_private.h>\n#include <isl_aff_private.h>\n#include <isl_vec_private.h>\n#include <isl/list.h>\n#include <isl_val_private.h>\n\nstruct variable {\n\tchar    \t    \t*name;\n\tint\t     \t\t pos;\n\tstruct variable\t\t*next;\n};\n\nstruct vars {\n\tstruct isl_ctx\t*ctx;\n\tint\t\t n;\n\tstruct variable\t*v;\n};\n\nstatic struct vars *vars_new(struct isl_ctx *ctx)\n{\n\tstruct vars *v;\n\tv = isl_alloc_type(ctx, struct vars);\n\tif (!v)\n\t\treturn NULL;\n\tv->ctx = ctx;\n\tv->n = 0;\n\tv->v = NULL;\n\treturn v;\n}\n\nstatic void variable_free(struct variable *var)\n{\n\twhile (var) {\n\t\tstruct variable *next = var->next;\n\t\tfree(var->name);\n\t\tfree(var);\n\t\tvar = next;\n\t}\n}\n\nstatic void vars_free(struct vars *v)\n{\n\tif (!v)\n\t\treturn;\n\tvariable_free(v->v);\n\tfree(v);\n}\n\nstatic void vars_drop(struct vars *v, int n)\n{\n\tstruct variable *var;\n\n\tif (!v || !v->v)\n\t\treturn;\n\n\tv->n -= n;\n\n\tvar = v->v;\n\twhile (--n >= 0) {\n\t\tstruct variable *next = var->next;\n\t\tfree(var->name);\n\t\tfree(var);\n\t\tvar = next;\n\t}\n\tv->v = var;\n}\n\nstatic struct variable *variable_new(struct vars *v, const char *name, int len,\n\t\t\t\tint pos)\n{\n\tstruct variable *var;\n\tvar = isl_calloc_type(v->ctx, struct variable);\n\tif (!var)\n\t\tgoto error;\n\tvar->name = strdup(name);\n\tvar->name[len] = '\\0';\n\tvar->pos = pos;\n\tvar->next = v->v;\n\treturn var;\nerror:\n\tvariable_free(v->v);\n\treturn NULL;\n}\n\nstatic int vars_pos(struct vars *v, const char *s, int len)\n{\n\tint pos;\n\tstruct variable *q;\n\n\tif (len == -1)\n\t\tlen = strlen(s);\n\tfor (q = v->v; q; q = q->next) {\n\t\tif (strncmp(q->name, s, len) == 0 && q->name[len] == '\\0')\n\t\t\tbreak;\n\t}\n\tif (q)\n\t\tpos = q->pos;\n\telse {\n\t\tpos = v->n;\n\t\tv->v = variable_new(v, s, len, v->n);\n\t\tif (!v->v)\n\t\t\treturn -1;\n\t\tv->n++;\n\t}\n\treturn pos;\n}\n\nstatic int vars_add_anon(struct vars *v)\n{\n\tv->v = variable_new(v, \"\", 0, v->n);\n\n\tif (!v->v)\n\t\treturn -1;\n\tv->n++;\n\n\treturn 0;\n}\n\n/* Obtain next token, with some preprocessing.\n * In particular, evaluate expressions of the form x^y,\n * with x and y values.\n */\nstatic struct isl_token *next_token(__isl_keep isl_stream *s)\n{\n\tstruct isl_token *tok, *tok2;\n\n\ttok = isl_stream_next_token(s);\n\tif (!tok || tok->type != ISL_TOKEN_VALUE)\n\t\treturn tok;\n\tif (!isl_stream_eat_if_available(s, '^'))\n\t\treturn tok;\n\ttok2 = isl_stream_next_token(s);\n\tif (!tok2 || tok2->type != ISL_TOKEN_VALUE) {\n\t\tisl_stream_error(s, tok2, \"expecting constant value\");\n\t\tgoto error;\n\t}\n\n\tisl_int_pow_ui(tok->u.v, tok->u.v, isl_int_get_ui(tok2->u.v));\n\n\tisl_token_free(tok2);\n\treturn tok;\nerror:\n\tisl_token_free(tok);\n\tisl_token_free(tok2);\n\treturn NULL;\n}\n\n/* Read an isl_val from \"s\".\n *\n * The following token sequences are recognized\n *\n *\t\"infty\"\t\t->\tinfty\n *\t\"-\" \"infty\"\t->\t-infty\n *\t\"NaN\"\t\t->\tNaN\n *\tn \"/\" d\t\t->\tn/d\n *\tv\t\t->\tv\n *\n * where n, d and v are integer constants.\n */\n__isl_give isl_val *isl_stream_read_val(__isl_keep isl_stream *s)\n{\n\tstruct isl_token *tok = NULL;\n\tstruct isl_token *tok2 = NULL;\n\tisl_val *val;\n\n\ttok = next_token(s);\n\tif (!tok) {\n\t\tisl_stream_error(s, NULL, \"unexpected EOF\");\n\t\tgoto error;\n\t}\n\tif (tok->type == ISL_TOKEN_INFTY) {\n\t\tisl_token_free(tok);\n\t\treturn isl_val_infty(s->ctx);\n\t}\n\tif (tok->type == '-' &&\n\t    isl_stream_eat_if_available(s, ISL_TOKEN_INFTY)) {\n\t\tisl_token_free(tok);\n\t\treturn isl_val_neginfty(s->ctx);\n\t}\n\tif (tok->type == ISL_TOKEN_NAN) {\n\t\tisl_token_free(tok);\n\t\treturn isl_val_nan(s->ctx);\n\t}\n\tif (tok->type != ISL_TOKEN_VALUE) {\n\t\tisl_stream_error(s, tok, \"expecting value\");\n\t\tgoto error;\n\t}\n\n\tif (isl_stream_eat_if_available(s, '/')) {\n\t\ttok2 = next_token(s);\n\t\tif (!tok2) {\n\t\t\tisl_stream_error(s, NULL, \"unexpected EOF\");\n\t\t\tgoto error;\n\t\t}\n\t\tif (tok2->type != ISL_TOKEN_VALUE) {\n\t\t\tisl_stream_error(s, tok2, \"expecting value\");\n\t\t\tgoto error;\n\t\t}\n\t\tval = isl_val_rat_from_isl_int(s->ctx, tok->u.v, tok2->u.v);\n\t\tval = isl_val_normalize(val);\n\t} else {\n\t\tval = isl_val_int_from_isl_int(s->ctx, tok->u.v);\n\t}\n\n\tisl_token_free(tok);\n\tisl_token_free(tok2);\n\treturn val;\nerror:\n\tisl_token_free(tok);\n\tisl_token_free(tok2);\n\treturn NULL;\n}\n\n/* Read an isl_val from \"str\".\n */\n__isl_give isl_val *isl_val_read_from_str(isl_ctx *ctx, const char *str)\n{\n\tisl_val *val;\n\tisl_stream *s = isl_stream_new_str(ctx, str);\n\tif (!s)\n\t\treturn NULL;\n\tval = isl_stream_read_val(s);\n\tisl_stream_free(s);\n\treturn val;\n}\n\n/* Perform an integer division on *f and\n * an integer value read from the stream.\n */\nstatic isl_stat int_div_by_cst(__isl_keep isl_stream *s, isl_int *f)\n{\n\tstruct isl_token *tok;\n\n\ttok = next_token(s);\n\tif (!tok || tok->type != ISL_TOKEN_VALUE) {\n\t\tisl_stream_error(s, tok, \"expecting constant value\");\n\t\tgoto error;\n\t}\n\n\tisl_int_fdiv_q(*f, *f, tok->u.v);\n\n\tisl_token_free(tok);\n\n\treturn isl_stat_ok;\nerror:\n\tisl_token_free(tok);\n\treturn isl_stat_error;\n}\n\nstatic isl_stat accept_cst_factor(__isl_keep isl_stream *s, isl_int *f)\n{\n\tstruct isl_token *tok;\n\n\ttok = next_token(s);\n\tif (!tok || tok->type != ISL_TOKEN_VALUE) {\n\t\tisl_stream_error(s, tok, \"expecting constant value\");\n\t\tgoto error;\n\t}\n\n\tisl_int_mul(*f, *f, tok->u.v);\n\n\tisl_token_free(tok);\n\n\tif (isl_stream_eat_if_available(s, '*'))\n\t\treturn accept_cst_factor(s, f);\n\n\treturn isl_stat_ok;\nerror:\n\tisl_token_free(tok);\n\treturn isl_stat_error;\n}\n\n/* Given an affine expression aff, return an affine expression\n * for aff % d, with d the next token on the stream, which is\n * assumed to be a constant.\n *\n * We introduce an integer division q = [aff/d] and the result\n * is set to aff - d q.\n */\nstatic __isl_give isl_pw_aff *affine_mod(__isl_keep isl_stream *s,\n\tstruct vars *v, __isl_take isl_pw_aff *aff)\n{\n\tstruct isl_token *tok;\n\tisl_pw_aff *q;\n\n\ttok = next_token(s);\n\tif (!tok || tok->type != ISL_TOKEN_VALUE) {\n\t\tisl_stream_error(s, tok, \"expecting constant value\");\n\t\tgoto error;\n\t}\n\n\tq = isl_pw_aff_copy(aff);\n\tq = isl_pw_aff_scale_down(q, tok->u.v);\n\tq = isl_pw_aff_floor(q);\n\tq = isl_pw_aff_scale(q, tok->u.v);\n\n\taff = isl_pw_aff_sub(aff, q);\n\n\tisl_token_free(tok);\n\treturn aff;\nerror:\n\tisl_pw_aff_free(aff);\n\tisl_token_free(tok);\n\treturn NULL;\n}\n\nstatic __isl_give isl_pw_aff *accept_affine(__isl_keep isl_stream *s,\n\t__isl_take isl_space *space, struct vars *v);\nstatic __isl_give isl_pw_aff_list *accept_affine_list(__isl_keep isl_stream *s,\n\t__isl_take isl_space *space, struct vars *v);\n\nstatic __isl_give isl_pw_aff *accept_minmax(__isl_keep isl_stream *s,\n\t__isl_take isl_space *space, struct vars *v)\n{\n\tstruct isl_token *tok;\n\tisl_pw_aff_list *list = NULL;\n\tint min;\n\n\ttok = isl_stream_next_token(s);\n\tif (!tok)\n\t\tgoto error;\n\tmin = tok->type == ISL_TOKEN_MIN;\n\tisl_token_free(tok);\n\n\tif (isl_stream_eat(s, '('))\n\t\tgoto error;\n\n\tlist = accept_affine_list(s, isl_space_copy(space), v);\n\tif (!list)\n\t\tgoto error;\n\n\tif (isl_stream_eat(s, ')'))\n\t\tgoto error;\n\n\tisl_space_free(space);\n\treturn min ? isl_pw_aff_list_min(list) : isl_pw_aff_list_max(list);\nerror:\n\tisl_space_free(space);\n\tisl_pw_aff_list_free(list);\n\treturn NULL;\n}\n\n/* Is \"tok\" the start of an integer division?\n */\nstatic int is_start_of_div(struct isl_token *tok)\n{\n\tif (!tok)\n\t\treturn 0;\n\tif (tok->type == '[')\n\t\treturn 1;\n\tif (tok->type == ISL_TOKEN_FLOOR)\n\t\treturn 1;\n\tif (tok->type == ISL_TOKEN_CEIL)\n\t\treturn 1;\n\tif (tok->type == ISL_TOKEN_FLOORD)\n\t\treturn 1;\n\tif (tok->type == ISL_TOKEN_CEILD)\n\t\treturn 1;\n\treturn 0;\n}\n\n/* Read an integer division from \"s\" and return it as an isl_pw_aff.\n *\n * The integer division can be of the form\n *\n *\t[<affine expression>]\n *\tfloor(<affine expression>)\n *\tceil(<affine expression>)\n *\tfloord(<affine expression>,<denominator>)\n *\tceild(<affine expression>,<denominator>)\n */\nstatic __isl_give isl_pw_aff *accept_div(__isl_keep isl_stream *s,\n\t__isl_take isl_space *space, struct vars *v)\n{\n\tstruct isl_token *tok;\n\tint f = 0;\n\tint c = 0;\n\tint extra = 0;\n\tisl_pw_aff *pwaff = NULL;\n\n\tif (isl_stream_eat_if_available(s, ISL_TOKEN_FLOORD))\n\t\textra = f = 1;\n\telse if (isl_stream_eat_if_available(s, ISL_TOKEN_CEILD))\n\t\textra = c = 1;\n\telse if (isl_stream_eat_if_available(s, ISL_TOKEN_FLOOR))\n\t\tf = 1;\n\telse if (isl_stream_eat_if_available(s, ISL_TOKEN_CEIL))\n\t\tc = 1;\n\tif (f || c) {\n\t\tif (isl_stream_eat(s, '('))\n\t\t\tgoto error;\n\t} else {\n\t\tif (isl_stream_eat(s, '['))\n\t\t\tgoto error;\n\t}\n\n\tpwaff = accept_affine(s, isl_space_copy(space), v);\n\n\tif (extra) {\n\t\tif (isl_stream_eat(s, ','))\n\t\t\tgoto error;\n\n\t\ttok = next_token(s);\n\t\tif (!tok)\n\t\t\tgoto error;\n\t\tif (tok->type != ISL_TOKEN_VALUE) {\n\t\t\tisl_stream_error(s, tok, \"expected denominator\");\n\t\t\tisl_stream_push_token(s, tok);\n\t\t\tgoto error;\n\t\t}\n\t\tpwaff = isl_pw_aff_scale_down(pwaff,  tok->u.v);\n\t\tisl_token_free(tok);\n\t}\n\n\tif (c)\n\t\tpwaff = isl_pw_aff_ceil(pwaff);\n\telse\n\t\tpwaff = isl_pw_aff_floor(pwaff);\n\n\tif (f || c) {\n\t\tif (isl_stream_eat(s, ')'))\n\t\t\tgoto error;\n\t} else {\n\t\tif (isl_stream_eat(s, ']'))\n\t\t\tgoto error;\n\t}\n\n\tisl_space_free(space);\n\treturn pwaff;\nerror:\n\tisl_space_free(space);\n\tisl_pw_aff_free(pwaff);\n\treturn NULL;\n}\n\n/* Divide \"pa\" by an integer constant read from the stream.\n */\nstatic __isl_give isl_pw_aff *pw_aff_div_by_cst(__isl_keep isl_stream *s,\n\t__isl_take isl_pw_aff *pa)\n{\n\tisl_int f;\n\tisl_int_init(f);\n\tisl_int_set_si(f, 1);\n\tif (accept_cst_factor(s, &f) < 0)\n\t\tpa = isl_pw_aff_free(pa);\n\tpa = isl_pw_aff_scale_down(pa, f);\n\tisl_int_clear(f);\n\n\treturn pa;\n}\n\nstatic __isl_give isl_pw_aff *accept_affine_factor(__isl_keep isl_stream *s,\n\t__isl_take isl_space *space, struct vars *v)\n{\n\tstruct isl_token *tok = NULL;\n\tisl_pw_aff *res = NULL;\n\n\ttok = next_token(s);\n\tif (!tok) {\n\t\tisl_stream_error(s, NULL, \"unexpected EOF\");\n\t\tgoto error;\n\t}\n\n\tif (tok->type == ISL_TOKEN_AFF) {\n\t\tres = isl_pw_aff_copy(tok->u.pwaff);\n\t\tisl_token_free(tok);\n\t} else if (tok->type == ISL_TOKEN_IDENT) {\n\t\tint n = v->n;\n\t\tint pos = vars_pos(v, tok->u.s, -1);\n\t\tisl_aff *aff;\n\n\t\tif (pos < 0)\n\t\t\tgoto error;\n\t\tif (pos >= n) {\n\t\t\tvars_drop(v, v->n - n);\n\t\t\tisl_stream_error(s, tok, \"unknown identifier\");\n\t\t\tgoto error;\n\t\t}\n\n\t\taff = isl_aff_zero_on_domain(isl_local_space_from_space(isl_space_copy(space)));\n\t\tif (!aff)\n\t\t\tgoto error;\n\t\tisl_int_set_si(aff->v->el[2 + pos], 1);\n\t\tres = isl_pw_aff_from_aff(aff);\n\t\tisl_token_free(tok);\n\t} else if (tok->type == ISL_TOKEN_VALUE) {\n\t\tif (isl_stream_eat_if_available(s, '*')) {\n\t\t\tres = accept_affine_factor(s, isl_space_copy(space), v);\n\t\t\tres = isl_pw_aff_scale(res, tok->u.v);\n\t\t} else {\n\t\t\tisl_local_space *ls;\n\t\t\tisl_aff *aff;\n\t\t\tls = isl_local_space_from_space(isl_space_copy(space));\n\t\t\taff = isl_aff_zero_on_domain(ls);\n\t\t\taff = isl_aff_add_constant(aff, tok->u.v);\n\t\t\tres = isl_pw_aff_from_aff(aff);\n\t\t}\n\t\tisl_token_free(tok);\n\t} else if (tok->type == '(') {\n\t\tisl_token_free(tok);\n\t\ttok = NULL;\n\t\tres = accept_affine(s, isl_space_copy(space), v);\n\t\tif (!res)\n\t\t\tgoto error;\n\t\tif (isl_stream_eat(s, ')'))\n\t\t\tgoto error;\n\t} else if (is_start_of_div(tok)) {\n\t\tisl_stream_push_token(s, tok);\n\t\ttok = NULL;\n\t\tres = accept_div(s, isl_space_copy(space), v);\n\t} else if (tok->type == ISL_TOKEN_MIN || tok->type == ISL_TOKEN_MAX) {\n\t\tisl_stream_push_token(s, tok);\n\t\ttok = NULL;\n\t\tres = accept_minmax(s, isl_space_copy(space), v);\n\t} else {\n\t\tisl_stream_error(s, tok, \"expecting factor\");\n\t\tgoto error;\n\t}\n\tif (isl_stream_eat_if_available(s, '%') ||\n\t    isl_stream_eat_if_available(s, ISL_TOKEN_MOD)) {\n\t\tisl_space_free(space);\n\t\treturn affine_mod(s, v, res);\n\t}\n\tif (isl_stream_eat_if_available(s, '*')) {\n\t\tisl_int f;\n\t\tisl_int_init(f);\n\t\tisl_int_set_si(f, 1);\n\t\tif (accept_cst_factor(s, &f) < 0) {\n\t\t\tisl_int_clear(f);\n\t\t\tgoto error2;\n\t\t}\n\t\tres = isl_pw_aff_scale(res, f);\n\t\tisl_int_clear(f);\n\t}\n\tif (isl_stream_eat_if_available(s, '/'))\n\t\tres = pw_aff_div_by_cst(s, res);\n\tif (isl_stream_eat_if_available(s, ISL_TOKEN_INT_DIV))\n\t\tres = isl_pw_aff_floor(pw_aff_div_by_cst(s, res));\n\n\tisl_space_free(space);\n\treturn res;\nerror:\n\tisl_token_free(tok);\nerror2:\n\tisl_pw_aff_free(res);\n\tisl_space_free(space);\n\treturn NULL;\n}\n\nstatic __isl_give isl_pw_aff *add_cst(__isl_take isl_pw_aff *pwaff, isl_int v)\n{\n\tisl_aff *aff;\n\tisl_space *space;\n\n\tspace = isl_pw_aff_get_domain_space(pwaff);\n\taff = isl_aff_zero_on_domain(isl_local_space_from_space(space));\n\taff = isl_aff_add_constant(aff, v);\n\n\treturn isl_pw_aff_add(pwaff, isl_pw_aff_from_aff(aff));\n}\n\n/* Return a piecewise affine expression defined on the specified domain\n * that represents NaN.\n */\nstatic __isl_give isl_pw_aff *nan_on_domain(__isl_keep isl_space *space)\n{\n\treturn isl_pw_aff_nan_on_domain_space(isl_space_copy(space));\n}\n\nstatic __isl_give isl_pw_aff *accept_affine(__isl_keep isl_stream *s,\n\t__isl_take isl_space *space, struct vars *v)\n{\n\tstruct isl_token *tok = NULL;\n\tisl_local_space *ls;\n\tisl_pw_aff *res;\n\tint sign = 1;\n\n\tls = isl_local_space_from_space(isl_space_copy(space));\n\tres = isl_pw_aff_from_aff(isl_aff_zero_on_domain(ls));\n\tif (!res)\n\t\tgoto error;\n\n\tfor (;;) {\n\t\ttok = next_token(s);\n\t\tif (!tok) {\n\t\t\tisl_stream_error(s, NULL, \"unexpected EOF\");\n\t\t\tgoto error;\n\t\t}\n\t\tif (tok->type == '-') {\n\t\t\tsign = -sign;\n\t\t\tisl_token_free(tok);\n\t\t\tcontinue;\n\t\t}\n\t\tif (tok->type == '(' || is_start_of_div(tok) ||\n\t\t    tok->type == ISL_TOKEN_MIN || tok->type == ISL_TOKEN_MAX ||\n\t\t    tok->type == ISL_TOKEN_IDENT ||\n\t\t    tok->type == ISL_TOKEN_AFF) {\n\t\t\tisl_pw_aff *term;\n\t\t\tisl_stream_push_token(s, tok);\n\t\t\ttok = NULL;\n\t\t\tterm = accept_affine_factor(s,\n\t\t\t\t\t\t    isl_space_copy(space), v);\n\t\t\tif (sign < 0)\n\t\t\t\tres = isl_pw_aff_sub(res, term);\n\t\t\telse\n\t\t\t\tres = isl_pw_aff_add(res, term);\n\t\t\tif (!res)\n\t\t\t\tgoto error;\n\t\t\tsign = 1;\n\t\t} else if (tok->type == ISL_TOKEN_VALUE) {\n\t\t\tif (sign < 0)\n\t\t\t\tisl_int_neg(tok->u.v, tok->u.v);\n\t\t\tif (isl_stream_eat_if_available(s, '*') ||\n\t\t\t    isl_stream_next_token_is(s, ISL_TOKEN_IDENT)) {\n\t\t\t\tisl_pw_aff *term;\n\t\t\t\tterm = accept_affine_factor(s,\n\t\t\t\t\t\t    isl_space_copy(space), v);\n\t\t\t\tterm = isl_pw_aff_scale(term, tok->u.v);\n\t\t\t\tres = isl_pw_aff_add(res, term);\n\t\t\t\tif (!res)\n\t\t\t\t\tgoto error;\n\t\t\t} else {\n\t\t\t\tif (isl_stream_eat_if_available(s,\n\t\t\t\t\t\t\tISL_TOKEN_INT_DIV) &&\n\t\t\t\t    int_div_by_cst(s, &tok->u.v) < 0)\n\t\t\t\t\tgoto error;\n\t\t\t\tres = add_cst(res, tok->u.v);\n\t\t\t}\n\t\t\tsign = 1;\n\t\t} else if (tok->type == ISL_TOKEN_NAN) {\n\t\t\tres = isl_pw_aff_add(res, nan_on_domain(space));\n\t\t} else {\n\t\t\tisl_stream_error(s, tok, \"unexpected isl_token\");\n\t\t\tisl_stream_push_token(s, tok);\n\t\t\tisl_pw_aff_free(res);\n\t\t\tisl_space_free(space);\n\t\t\treturn NULL;\n\t\t}\n\t\tisl_token_free(tok);\n\n\t\ttok = next_token(s);\n\t\tif (tok && tok->type == '-') {\n\t\t\tsign = -sign;\n\t\t\tisl_token_free(tok);\n\t\t} else if (tok && tok->type == '+') {\n\t\t\t/* nothing */\n\t\t\tisl_token_free(tok);\n\t\t} else if (tok && tok->type == ISL_TOKEN_VALUE &&\n\t\t\t   isl_int_is_neg(tok->u.v)) {\n\t\t\tisl_stream_push_token(s, tok);\n\t\t} else {\n\t\t\tif (tok)\n\t\t\t\tisl_stream_push_token(s, tok);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tisl_space_free(space);\n\treturn res;\nerror:\n\tisl_space_free(space);\n\tisl_token_free(tok);\n\tisl_pw_aff_free(res);\n\treturn NULL;\n}\n\n/* Is \"type\" the type of a comparison operator between lists\n * of affine expressions?\n */\nstatic int is_list_comparator_type(int type)\n{\n\tswitch (type) {\n\tcase ISL_TOKEN_LEX_LT:\n\tcase ISL_TOKEN_LEX_GT:\n\tcase ISL_TOKEN_LEX_LE:\n\tcase ISL_TOKEN_LEX_GE:\n\t\treturn 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\nstatic int is_comparator(struct isl_token *tok)\n{\n\tif (!tok)\n\t\treturn 0;\n\tif (is_list_comparator_type(tok->type))\n\t\treturn 1;\n\n\tswitch (tok->type) {\n\tcase ISL_TOKEN_LT:\n\tcase ISL_TOKEN_GT:\n\tcase ISL_TOKEN_LE:\n\tcase ISL_TOKEN_GE:\n\tcase ISL_TOKEN_NE:\n\tcase '=':\n\t\treturn 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\nstatic __isl_give isl_map *read_formula(__isl_keep isl_stream *s,\n\tstruct vars *v, __isl_take isl_map *map, int rational);\nstatic __isl_give isl_pw_aff *accept_extended_affine(__isl_keep isl_stream *s,\n\t__isl_take isl_space *space, struct vars *v, int rational);\n\n/* Accept a ternary operator, given the first argument.\n */\nstatic __isl_give isl_pw_aff *accept_ternary(__isl_keep isl_stream *s,\n\t__isl_take isl_map *cond, struct vars *v, int rational)\n{\n\tisl_space *space;\n\tisl_pw_aff *pwaff1 = NULL, *pwaff2 = NULL, *pa_cond;\n\n\tif (!cond)\n\t\treturn NULL;\n\n\tif (isl_stream_eat(s, '?'))\n\t\tgoto error;\n\n\tspace = isl_space_wrap(isl_map_get_space(cond));\n\tpwaff1 = accept_extended_affine(s, space, v, rational);\n\tif (!pwaff1)\n\t\tgoto error;\n\n\tif (isl_stream_eat(s, ':'))\n\t\tgoto error;\n\n\tspace = isl_pw_aff_get_domain_space(pwaff1);\n\tpwaff2 = accept_extended_affine(s, space, v, rational);\n\tif (!pwaff2)\n\t\tgoto error;\n\n\tpa_cond = isl_set_indicator_function(isl_map_wrap(cond));\n\treturn isl_pw_aff_cond(pa_cond, pwaff1, pwaff2);\nerror:\n\tisl_map_free(cond);\n\tisl_pw_aff_free(pwaff1);\n\tisl_pw_aff_free(pwaff2);\n\treturn NULL;\n}\n\n/* Set *line and *col to those of the next token, if any.\n */\nstatic void set_current_line_col(__isl_keep isl_stream *s, int *line, int *col)\n{\n\tstruct isl_token *tok;\n\n\ttok = isl_stream_next_token(s);\n\tif (!tok)\n\t\treturn;\n\n\t*line = tok->line;\n\t*col = tok->col;\n\tisl_stream_push_token(s, tok);\n}\n\n/* Push a token encapsulating \"pa\" onto \"s\", with the given\n * line and column.\n */\nstatic isl_stat push_aff(__isl_keep isl_stream *s, int line, int col,\n\t__isl_take isl_pw_aff *pa)\n{\n\tstruct isl_token *tok;\n\n\ttok = isl_token_new(s->ctx, line, col, 0);\n\tif (!tok)\n\t\tgoto error;\n\ttok->type = ISL_TOKEN_AFF;\n\ttok->u.pwaff = pa;\n\tisl_stream_push_token(s, tok);\n\n\treturn isl_stat_ok;\nerror:\n\tisl_pw_aff_free(pa);\n\treturn isl_stat_error;\n}\n\n/* Is the next token a comparison operator?\n */\nstatic int next_is_comparator(__isl_keep isl_stream *s)\n{\n\tint is_comp;\n\tstruct isl_token *tok;\n\n\ttok = isl_stream_next_token(s);\n\tif (!tok)\n\t\treturn 0;\n\n\tis_comp = is_comparator(tok);\n\tisl_stream_push_token(s, tok);\n\n\treturn is_comp;\n}\n\n/* Accept an affine expression that may involve ternary operators.\n * We first read an affine expression.\n * If it is not followed by a comparison operator, we simply return it.\n * Otherwise, we assume the affine expression is part of the first\n * argument of a ternary operator and try to parse that.\n */\nstatic __isl_give isl_pw_aff *accept_extended_affine(__isl_keep isl_stream *s,\n\t__isl_take isl_space *space, struct vars *v, int rational)\n{\n\tisl_map *cond;\n\tisl_pw_aff *pwaff;\n\tint line = -1, col = -1;\n\n\tset_current_line_col(s, &line, &col);\n\n\tpwaff = accept_affine(s, space, v);\n\tif (rational)\n\t\tpwaff = isl_pw_aff_set_rational(pwaff);\n\tif (!pwaff)\n\t\treturn NULL;\n\tif (!next_is_comparator(s))\n\t\treturn pwaff;\n\n\tspace = isl_pw_aff_get_domain_space(pwaff);\n\tcond = isl_map_universe(isl_space_unwrap(space));\n\n\tif (push_aff(s, line, col, pwaff) < 0)\n\t\tcond = isl_map_free(cond);\n\tif (!cond)\n\t\treturn NULL;\n\n\tcond = read_formula(s, v, cond, rational);\n\n\treturn accept_ternary(s, cond, v, rational);\n}\n\nstatic __isl_give isl_map *read_var_def(__isl_keep isl_stream *s,\n\t__isl_take isl_map *map, enum isl_dim_type type, struct vars *v,\n\tint rational)\n{\n\tisl_pw_aff *def;\n\tisl_size pos;\n\tisl_map *def_map;\n\n\tif (type == isl_dim_param)\n\t\tpos = isl_map_dim(map, isl_dim_param);\n\telse {\n\t\tpos = isl_map_dim(map, isl_dim_in);\n\t\tif (type == isl_dim_out) {\n\t\t\tisl_size n_out = isl_map_dim(map, isl_dim_out);\n\t\t\tif (pos < 0 || n_out < 0)\n\t\t\t\treturn isl_map_free(map);\n\t\t\tpos += n_out;\n\t\t}\n\t\ttype = isl_dim_in;\n\t}\n\tif (pos < 0)\n\t\treturn isl_map_free(map);\n\t--pos;\n\n\tdef = accept_extended_affine(s, isl_space_wrap(isl_map_get_space(map)),\n\t\t\t\t\tv, rational);\n\tdef_map = isl_map_from_pw_aff(def);\n\tdef_map = isl_map_equate(def_map, type, pos, isl_dim_out, 0);\n\tdef_map = isl_set_unwrap(isl_map_domain(def_map));\n\n\tmap = isl_map_intersect(map, def_map);\n\n\treturn map;\n}\n\nstatic __isl_give isl_pw_aff_list *accept_affine_list(__isl_keep isl_stream *s,\n\t__isl_take isl_space *space, struct vars *v)\n{\n\tisl_pw_aff *pwaff;\n\tisl_pw_aff_list *list;\n\tstruct isl_token *tok = NULL;\n\n\tpwaff = accept_affine(s, isl_space_copy(space), v);\n\tlist = isl_pw_aff_list_from_pw_aff(pwaff);\n\tif (!list)\n\t\tgoto error;\n\n\tfor (;;) {\n\t\ttok = isl_stream_next_token(s);\n\t\tif (!tok) {\n\t\t\tisl_stream_error(s, NULL, \"unexpected EOF\");\n\t\t\tgoto error;\n\t\t}\n\t\tif (tok->type != ',') {\n\t\t\tisl_stream_push_token(s, tok);\n\t\t\tbreak;\n\t\t}\n\t\tisl_token_free(tok);\n\n\t\tpwaff = accept_affine(s, isl_space_copy(space), v);\n\t\tlist = isl_pw_aff_list_concat(list,\n\t\t\t\tisl_pw_aff_list_from_pw_aff(pwaff));\n\t\tif (!list)\n\t\t\tgoto error;\n\t}\n\n\tisl_space_free(space);\n\treturn list;\nerror:\n\tisl_space_free(space);\n\tisl_pw_aff_list_free(list);\n\treturn NULL;\n}\n\nstatic __isl_give isl_map *read_defined_var_list(__isl_keep isl_stream *s,\n\tstruct vars *v, __isl_take isl_map *map, int rational)\n{\n\tstruct isl_token *tok;\n\n\twhile ((tok = isl_stream_next_token(s)) != NULL) {\n\t\tint p;\n\t\tint n = v->n;\n\n\t\tif (tok->type != ISL_TOKEN_IDENT)\n\t\t\tbreak;\n\n\t\tp = vars_pos(v, tok->u.s, -1);\n\t\tif (p < 0)\n\t\t\tgoto error;\n\t\tif (p < n) {\n\t\t\tisl_stream_error(s, tok, \"expecting unique identifier\");\n\t\t\tgoto error;\n\t\t}\n\n\t\tmap = isl_map_add_dims(map, isl_dim_out, 1);\n\n\t\tisl_token_free(tok);\n\t\ttok = isl_stream_next_token(s);\n\t\tif (tok && tok->type == '=') {\n\t\t\tisl_token_free(tok);\n\t\t\tmap = read_var_def(s, map, isl_dim_out, v, rational);\n\t\t\ttok = isl_stream_next_token(s);\n\t\t}\n\n\t\tif (!tok || tok->type != ',')\n\t\t\tbreak;\n\n\t\tisl_token_free(tok);\n\t}\n\tif (tok)\n\t\tisl_stream_push_token(s, tok);\n\n\treturn map;\nerror:\n\tisl_token_free(tok);\n\tisl_map_free(map);\n\treturn NULL;\n}\n\nstatic int next_is_tuple(__isl_keep isl_stream *s)\n{\n\tstruct isl_token *tok;\n\tint is_tuple;\n\n\ttok = isl_stream_next_token(s);\n\tif (!tok)\n\t\treturn 0;\n\tif (tok->type == '[') {\n\t\tisl_stream_push_token(s, tok);\n\t\treturn 1;\n\t}\n\tif (tok->type != ISL_TOKEN_IDENT && !tok->is_keyword) {\n\t\tisl_stream_push_token(s, tok);\n\t\treturn 0;\n\t}\n\n\tis_tuple = isl_stream_next_token_is(s, '[');\n\n\tisl_stream_push_token(s, tok);\n\n\treturn is_tuple;\n}\n\n/* Does the next token mark the end of a tuple element?\n */\nstatic int next_is_end_tuple_element(__isl_keep isl_stream *s)\n{\n\treturn isl_stream_next_token_is(s, ',') ||\n\t    isl_stream_next_token_is(s, ']');\n}\n\n/* Is the next token one that necessarily forms the start of a condition?\n */\nstatic int next_is_condition_start(__isl_keep isl_stream *s)\n{\n\treturn isl_stream_next_token_is(s, ISL_TOKEN_EXISTS) ||\n\t    isl_stream_next_token_is(s, ISL_TOKEN_NOT) ||\n\t    isl_stream_next_token_is(s, ISL_TOKEN_TRUE) ||\n\t    isl_stream_next_token_is(s, ISL_TOKEN_FALSE) ||\n\t    isl_stream_next_token_is(s, ISL_TOKEN_MAP);\n}\n\n/* Is \"pa\" an expression in term of earlier dimensions?\n * The alternative is that the dimension is defined to be equal to itself,\n * meaning that it has a universe domain and an expression that depends\n * on itself.  \"i\" is the position of the expression in a sequence\n * of \"n\" expressions.  The final dimensions of \"pa\" correspond to\n * these \"n\" expressions.\n */\nstatic isl_bool pw_aff_is_expr(__isl_keep isl_pw_aff *pa, int i, int n)\n{\n\tisl_aff *aff;\n\n\tif (!pa)\n\t\treturn isl_bool_error;\n\tif (pa->n != 1)\n\t\treturn isl_bool_true;\n\tif (!isl_set_plain_is_universe(pa->p[0].set))\n\t\treturn isl_bool_true;\n\n\taff = pa->p[0].aff;\n\tif (isl_int_is_zero(aff->v->el[aff->v->size - n + i]))\n\t\treturn isl_bool_true;\n\treturn isl_bool_false;\n}\n\n/* Does the tuple contain any dimensions that are defined\n * in terms of earlier dimensions?\n */\nstatic isl_bool tuple_has_expr(__isl_keep isl_multi_pw_aff *tuple)\n{\n\tint i;\n\tisl_size n;\n\tisl_bool has_expr = isl_bool_false;\n\tisl_pw_aff *pa;\n\n\tn = isl_multi_pw_aff_dim(tuple, isl_dim_out);\n\tif (n < 0)\n\t\treturn isl_bool_error;\n\tfor (i = 0; i < n; ++i) {\n\t\tpa = isl_multi_pw_aff_get_pw_aff(tuple, i);\n\t\thas_expr = pw_aff_is_expr(pa, i, n);\n\t\tisl_pw_aff_free(pa);\n\t\tif (has_expr < 0 || has_expr)\n\t\t\tbreak;\n\t}\n\n\treturn has_expr;\n}\n\n/* Set the name of dimension \"pos\" in \"space\" to \"name\".\n * During printing, we add primes if the same name appears more than once\n * to distinguish the occurrences.  Here, we remove those primes from \"name\"\n * before setting the name of the dimension.\n */\nstatic __isl_give isl_space *space_set_dim_name(__isl_take isl_space *space,\n\tint pos, char *name)\n{\n\tchar *prime;\n\n\tif (!name)\n\t\treturn space;\n\n\tprime = strchr(name, '\\'');\n\tif (prime)\n\t\t*prime = '\\0';\n\tspace = isl_space_set_dim_name(space, isl_dim_out, pos, name);\n\tif (prime)\n\t\t*prime = '\\'';\n\n\treturn space;\n}\n\n/* Construct an isl_pw_aff defined on a \"space\" (with v->n variables)\n * that is equal to the last of those variables.\n */\nstatic __isl_give isl_pw_aff *identity_tuple_el_on_space(\n\t__isl_take isl_space *space, struct vars *v)\n{\n\tisl_aff *aff;\n\n\taff = isl_aff_zero_on_domain(isl_local_space_from_space(space));\n\taff = isl_aff_add_coefficient_si(aff, isl_dim_in, v->n - 1, 1);\n\treturn isl_pw_aff_from_aff(aff);\n}\n\n/* Construct an isl_pw_aff defined on the domain space of \"pa\"\n * that is equal to the last variable in \"v\".\n *\n * That is, if D is the domain space of \"pa\", then construct\n *\n *\tD[..., i] -> i.\n */\nstatic __isl_give isl_pw_aff *init_range(__isl_keep isl_pw_aff *pa,\n\tstruct vars *v)\n{\n\tisl_space *space;\n\n\tspace = isl_pw_aff_get_domain_space(pa);\n\treturn identity_tuple_el_on_space(space, v);\n}\n\n/* Impose the lower bound \"lower\" on the variable represented by \"range_pa\".\n *\n * In particular, \"range_pa\" is of the form\n *\n *\tD[..., i] -> i : C\n *\n * with D also the domains space of \"lower' and \"C\" some constraints.\n *\n * Return the expression\n *\n *\tD[..., i] -> i : C and i >= lower\n */\nstatic __isl_give isl_pw_aff *set_lower(__isl_take isl_pw_aff *range_pa,\n\t__isl_take isl_pw_aff *lower)\n{\n\tisl_set *range;\n\n\trange = isl_pw_aff_ge_set(isl_pw_aff_copy(range_pa), lower);\n\treturn isl_pw_aff_intersect_domain(range_pa, range);\n}\n\n/* Impose the upper bound \"upper\" on the variable represented by \"range_pa\".\n *\n * In particular, \"range_pa\" is of the form\n *\n *\tD[..., i] -> i : C\n *\n * with D also the domains space of \"upper' and \"C\" some constraints.\n *\n * Return the expression\n *\n *\tD[..., i] -> i : C and i <= upper\n */\nstatic __isl_give isl_pw_aff *set_upper(__isl_take isl_pw_aff *range_pa,\n\t__isl_take isl_pw_aff *upper)\n{\n\tisl_set *range;\n\n\trange = isl_pw_aff_le_set(isl_pw_aff_copy(range_pa), upper);\n\treturn isl_pw_aff_intersect_domain(range_pa, range);\n}\n\n/* Construct a piecewise affine expression corresponding\n * to the last variable in \"v\" that is greater than or equal to \"pa\".\n *\n * In particular, if D is the domain space of \"pa\",\n * then construct the expression\n *\n *\tD[..., i] -> i,\n *\n * impose lower bound \"pa\" and return\n *\n *\tD[..., i] -> i : i >= pa\n */\nstatic __isl_give isl_pw_aff *construct_lower(__isl_take isl_pw_aff *pa,\n\tstruct vars *v)\n{\n\treturn set_lower(init_range(pa, v), pa);\n}\n\n/* Construct a piecewise affine expression corresponding\n * to the last variable in \"v\" that is smaller than or equal to \"pa\".\n *\n * In particular, if D is the domain space of \"pa\",\n * then construct the expression\n *\n *\tD[..., i] -> i,\n *\n * impose lower bound \"pa\" and return\n *\n *\tD[..., i] -> i : i <= pa\n */\nstatic __isl_give isl_pw_aff *construct_upper(__isl_take isl_pw_aff *pa,\n\tstruct vars *v)\n{\n\treturn set_upper(init_range(pa, v), pa);\n}\n\n/* Construct a piecewise affine expression corresponding\n * to the last variable in \"v\" that ranges between \"pa\" and \"pa2\".\n *\n * In particular, if D is the domain space of \"pa\" (and \"pa2\"),\n * then construct the expression\n *\n *\tD[..., i] -> i,\n *\n * impose lower bound \"pa\" and upper bound \"pa2\" and return\n *\n *\tD[..., i] -> i : pa <= i <= pa2\n */\nstatic __isl_give isl_pw_aff *construct_range(__isl_take isl_pw_aff *pa,\n\t__isl_take isl_pw_aff *pa2, struct vars *v)\n{\n\treturn set_upper(set_lower(init_range(pa, v), pa), pa2);\n}\n\nstatic int resolve_paren_expr(__isl_keep isl_stream *s,\n\tstruct vars *v, __isl_take isl_map *map, int rational);\n\n/* Given that the (piecewise) affine expression \"pa\"\n * has just been parsed, followed by a colon,\n * continue parsing as part of a piecewise affine expression.\n *\n * In particular, check if the colon is followed by a condition.\n * If so, parse the conditions(a) on \"pa\" and include them in the domain.\n * Otherwise, if the colon is followed by another (piecewise) affine expression\n * then consider the two expressions as endpoints of a range of values and\n * return a piecewise affine expression that takes values in that range.\n * Note that an affine expression followed by a comparison operator\n * is considered to be part of a condition.\n * If the colon is not followed by anything (inside the tuple element),\n * then consider \"pa\" as a lower bound on a range of values without upper bound\n * and return a piecewise affine expression that takes values in that range.\n */\nstatic __isl_give isl_pw_aff *update_piecewise_affine_colon(\n\t__isl_take isl_pw_aff *pa, __isl_keep isl_stream *s,\n\tstruct vars *v, int rational)\n{\n\tisl_space *dom_space;\n\tisl_map *map;\n\n\tdom_space = isl_pw_aff_get_domain_space(pa);\n\tmap = isl_map_universe(isl_space_from_domain(dom_space));\n\n\tif (isl_stream_next_token_is(s, '('))\n\t\tif (resolve_paren_expr(s, v, isl_map_copy(map), rational))\n\t\t\tgoto error;\n\tif (next_is_end_tuple_element(s)) {\n\t\tisl_map_free(map);\n\t\treturn construct_lower(pa, v);\n\t}\n\tif (!next_is_condition_start(s)) {\n\t\tint line = -1, col = -1;\n\t\tisl_space *space;\n\t\tisl_pw_aff *pa2;\n\n\t\tset_current_line_col(s, &line, &col);\n\t\tspace = isl_space_wrap(isl_map_get_space(map));\n\t\tpa2 = accept_affine(s, space, v);\n\t\tif (rational)\n\t\t\tpa2 = isl_pw_aff_set_rational(pa2);\n\t\tif (!next_is_comparator(s)) {\n\t\t\tisl_map_free(map);\n\t\t\tpa2 = isl_pw_aff_domain_factor_domain(pa2);\n\t\t\treturn construct_range(pa, pa2, v);\n\t\t}\n\t\tif (push_aff(s, line, col, pa2) < 0)\n\t\t\tgoto error;\n\t}\n\n\tmap = read_formula(s, v, map, rational);\n\tpa = isl_pw_aff_intersect_domain(pa, isl_map_domain(map));\n\n\treturn pa;\nerror:\n\tisl_map_free(map);\n\tisl_pw_aff_free(pa);\n\treturn NULL;\n}\n\n/* Accept a piecewise affine expression.\n *\n * At the outer level, the piecewise affine expression may be of the form\n *\n *\taff1 : condition1; aff2 : conditions2; ...\n *\n * or one of\n *\n *\taff :\n *\taff1 : aff2\n *\t: aff\n *\t:\n *\n * or simply\n *\n *\taff\n *\n * each of the affine expressions may in turn include ternary operators.\n *\n * If the first token is a colon, then the expression must be\n * \":\" or \": aff2\", depending on whether anything follows the colon\n * inside the tuple element.\n * The first is considered to represent an arbitrary value.\n * The second is considered to represent a range of values\n * with the given upper bound and no lower bound.\n *\n * There may be parentheses around some subexpression of \"aff1\"\n * around \"aff1\" itself, around \"aff1 : condition1\" and/or\n * around the entire piecewise affine expression.\n * We therefore remove the opening parenthesis (if any) from the stream\n * in case the closing parenthesis follows the colon, but if the closing\n * parenthesis is the first thing in the stream after the parsed affine\n * expression, we push the parsed expression onto the stream and parse\n * again in case the parentheses enclose some subexpression of \"aff1\".\n */\nstatic __isl_give isl_pw_aff *accept_piecewise_affine(__isl_keep isl_stream *s,\n\t__isl_take isl_space *space, struct vars *v, int rational)\n{\n\tisl_pw_aff *res;\n\tisl_space *res_space;\n\n\tif (isl_stream_eat_if_available(s, ':')) {\n\t\tif (next_is_end_tuple_element(s))\n\t\t\treturn identity_tuple_el_on_space(space, v);\n\t\telse\n\t\t\treturn construct_upper(accept_affine(s, space, v), v);\n\t}\n\n\tres_space = isl_space_from_domain(isl_space_copy(space));\n\tres_space = isl_space_add_dims(res_space, isl_dim_out, 1);\n\tres = isl_pw_aff_empty(res_space);\n\tdo {\n\t\tisl_pw_aff *pa;\n\t\tint seen_paren;\n\t\tint line = -1, col = -1;\n\n\t\tset_current_line_col(s, &line, &col);\n\t\tseen_paren = isl_stream_eat_if_available(s, '(');\n\t\tif (seen_paren)\n\t\t\tpa = accept_piecewise_affine(s, isl_space_copy(space),\n\t\t\t\t\t\t\tv, rational);\n\t\telse\n\t\t\tpa = accept_extended_affine(s, isl_space_copy(space),\n\t\t\t\t\t\t\tv, rational);\n\t\tif (seen_paren && isl_stream_eat_if_available(s, ')')) {\n\t\t\tseen_paren = 0;\n\t\t\tif (push_aff(s, line, col, pa) < 0)\n\t\t\t\tgoto error;\n\t\t\tpa = accept_extended_affine(s, isl_space_copy(space),\n\t\t\t\t\t\t\tv, rational);\n\t\t}\n\t\tif (isl_stream_eat_if_available(s, ':'))\n\t\t\tpa = update_piecewise_affine_colon(pa, s, v, rational);\n\n\t\tres = isl_pw_aff_union_add(res, pa);\n\n\t\tif (seen_paren && isl_stream_eat(s, ')'))\n\t\t\tgoto error;\n\t} while (isl_stream_eat_if_available(s, ';'));\n\n\tisl_space_free(space);\n\n\treturn res;\nerror:\n\tisl_space_free(space);\n\treturn isl_pw_aff_free(res);\n}\n\n/* Read an affine expression from \"s\" for use in read_tuple.\n *\n * accept_extended_affine requires a wrapped space as input.\n * read_tuple on the other hand expects each isl_pw_aff\n * to have an anonymous space.  We therefore adjust the space\n * of the isl_pw_aff before returning it.\n */\nstatic __isl_give isl_pw_aff *read_tuple_var_def(__isl_keep isl_stream *s,\n\tstruct vars *v, int rational)\n{\n\tisl_space *space;\n\tisl_pw_aff *def;\n\n\tspace = isl_space_wrap(isl_space_alloc(s->ctx, 0, v->n, 0));\n\n\tdef = accept_piecewise_affine(s, space, v, rational);\n\tdef = isl_pw_aff_domain_factor_domain(def);\n\n\treturn def;\n}\n\n/* Read a list of tuple elements by calling \"read_el\" on each of them and\n * return a space with the same number of set dimensions derived from\n * the parameter space \"space\" and possibly updated by \"read_el\".\n * The elements in the list are separated by either \",\" or \"][\".\n * If \"comma\" is set then only \",\" is allowed.\n */\nstatic __isl_give isl_space *read_tuple_list(__isl_keep isl_stream *s,\n\tstruct vars *v, __isl_take isl_space *space, int rational, int comma,\n\t__isl_give isl_space *(*read_el)(__isl_keep isl_stream *s,\n\t\tstruct vars *v, __isl_take isl_space *space, int rational,\n\t\tvoid *user),\n\tvoid *user)\n{\n\tif (!space)\n\t\treturn NULL;\n\n\tspace = isl_space_set_from_params(space);\n\n\tif (isl_stream_next_token_is(s, ']'))\n\t\treturn space;\n\n\tfor (;;) {\n\t\tstruct isl_token *tok;\n\n\t\tspace = isl_space_add_dims(space, isl_dim_set, 1);\n\n\t\tspace = read_el(s, v, space, rational, user);\n\t\tif (!space)\n\t\t\treturn NULL;\n\n\t\ttok = isl_stream_next_token(s);\n\t\tif (!comma && tok && tok->type == ']' &&\n\t\t    isl_stream_next_token_is(s, '[')) {\n\t\t\tisl_token_free(tok);\n\t\t\ttok = isl_stream_next_token(s);\n\t\t} else if (!tok || tok->type != ',') {\n\t\t\tif (tok)\n\t\t\t\tisl_stream_push_token(s, tok);\n\t\t\tbreak;\n\t\t}\n\n\t\tisl_token_free(tok);\n\t}\n\n\treturn space;\n}\n\n/* Read a tuple space from \"s\" derived from the parameter space \"space\".\n * Call \"read_el\" on each element in the tuples.\n */\nstatic __isl_give isl_space *read_tuple_space(__isl_keep isl_stream *s,\n\tstruct vars *v, __isl_take isl_space *space, int rational, int comma,\n\t__isl_give isl_space *(*read_el)(__isl_keep isl_stream *s,\n\t\tstruct vars *v, __isl_take isl_space *space, int rational,\n\t\tvoid *user),\n\tvoid *user)\n{\n\tstruct isl_token *tok;\n\tchar *name = NULL;\n\tisl_space *res = NULL;\n\n\ttok = isl_stream_next_token(s);\n\tif (!tok)\n\t\tgoto error;\n\tif (tok->type == ISL_TOKEN_IDENT || tok->is_keyword) {\n\t\tname = strdup(tok->u.s);\n\t\tisl_token_free(tok);\n\t\tif (!name)\n\t\t\tgoto error;\n\t} else\n\t\tisl_stream_push_token(s, tok);\n\tif (isl_stream_eat(s, '['))\n\t\tgoto error;\n\tif (next_is_tuple(s)) {\n\t\tisl_space *out;\n\t\tres = read_tuple_space(s, v, isl_space_copy(space),\n\t\t\t\t\trational, comma, read_el, user);\n\t\tif (isl_stream_eat(s, ISL_TOKEN_TO))\n\t\t\tgoto error;\n\t\tout = read_tuple_space(s, v, isl_space_copy(space),\n\t\t\t\t\trational, comma, read_el, user);\n\t\tres = isl_space_product(res, out);\n\t} else\n\t\tres = read_tuple_list(s, v, isl_space_copy(space),\n\t\t\t\t\trational, comma, read_el, user);\n\tif (isl_stream_eat(s, ']'))\n\t\tgoto error;\n\n\tif (name) {\n\t\tres = isl_space_set_tuple_name(res, isl_dim_set, name);\n\t\tfree(name);\n\t}\n\n\tisl_space_free(space);\n\treturn res;\nerror:\n\tfree(name);\n\tisl_space_free(res);\n\tisl_space_free(space);\n\treturn NULL;\n}\n\n/* Construct an isl_pw_aff defined on a space with v->n variables\n * that is equal to the last of those variables.\n */\nstatic __isl_give isl_pw_aff *identity_tuple_el(struct vars *v)\n{\n\tisl_space *space;\n\n\tspace = isl_space_set_alloc(v->ctx, 0, v->n);\n\treturn identity_tuple_el_on_space(space, v);\n}\n\n/* This function is called for each element in a tuple inside read_tuple.\n * Add a new variable to \"v\" and construct a corresponding isl_pw_aff defined\n * over a space containing all variables in \"v\" defined so far.\n * The isl_pw_aff expresses the new variable in terms of earlier variables\n * if a definition is provided.  Otherwise, it is represented as being\n * equal to itself.\n * Add the isl_pw_aff to *list.\n * If the new variable was named, then adjust \"space\" accordingly and\n * return the updated space.\n */\nstatic __isl_give isl_space *read_tuple_pw_aff_el(__isl_keep isl_stream *s,\n\tstruct vars *v, __isl_take isl_space *space, int rational, void *user)\n{\n\tisl_pw_aff_list **list = (isl_pw_aff_list **) user;\n\tisl_pw_aff *pa;\n\tstruct isl_token *tok;\n\tint new_name = 0;\n\n\ttok = next_token(s);\n\tif (!tok) {\n\t\tisl_stream_error(s, NULL, \"unexpected EOF\");\n\t\treturn isl_space_free(space);\n\t}\n\n\tif (tok->type == ISL_TOKEN_IDENT) {\n\t\tint n = v->n;\n\t\tint p = vars_pos(v, tok->u.s, -1);\n\t\tif (p < 0)\n\t\t\tgoto error;\n\t\tnew_name = p >= n;\n\t}\n\n\tif (tok->type == '*') {\n\t\tif (vars_add_anon(v) < 0)\n\t\t\tgoto error;\n\t\tisl_token_free(tok);\n\t\tpa = identity_tuple_el(v);\n\t} else if (new_name) {\n\t\tisl_size pos = isl_space_dim(space, isl_dim_out);\n\t\tif (pos < 0)\n\t\t\tgoto error;\n\t\tpos -= 1;\n\t\tspace = space_set_dim_name(space, pos, v->v->name);\n\t\tisl_token_free(tok);\n\t\tif (isl_stream_eat_if_available(s, '='))\n\t\t\tpa = read_tuple_var_def(s, v, rational);\n\t\telse\n\t\t\tpa = identity_tuple_el(v);\n\t} else {\n\t\tisl_stream_push_token(s, tok);\n\t\ttok = NULL;\n\t\tif (vars_add_anon(v) < 0)\n\t\t\tgoto error;\n\t\tpa = read_tuple_var_def(s, v, rational);\n\t}\n\n\t*list = isl_pw_aff_list_add(*list, pa);\n\tif (!*list)\n\t\treturn isl_space_free(space);\n\n\treturn space;\nerror:\n\tisl_token_free(tok);\n\treturn isl_space_free(space);\n}\n\n/* Read a tuple and represent it as an isl_multi_pw_aff.\n * The range space of the isl_multi_pw_aff is the space of the tuple.\n * The domain space is an anonymous space\n * with a dimension for each variable in the set of variables in \"v\",\n * including the variables in the range.\n * If a given dimension is not defined in terms of earlier dimensions in\n * the input, then the corresponding isl_pw_aff is set equal to one time\n * the variable corresponding to the dimension being defined.\n *\n * The elements in the tuple are collected in a list by read_tuple_pw_aff_el.\n * Each element in this list is defined over a space representing\n * the variables defined so far.  We need to adjust the earlier\n * elements to have as many variables in the domain as the final\n * element in the list.\n */\nstatic __isl_give isl_multi_pw_aff *read_tuple(__isl_keep isl_stream *s,\n\tstruct vars *v, int rational, int comma)\n{\n\tint i;\n\tisl_size n;\n\tisl_space *space;\n\tisl_pw_aff_list *list;\n\n\tspace = isl_space_params_alloc(v->ctx, 0);\n\tlist = isl_pw_aff_list_alloc(s->ctx, 0);\n\tspace = read_tuple_space(s, v, space, rational, comma,\n\t\t\t\t&read_tuple_pw_aff_el, &list);\n\tn = isl_space_dim(space, isl_dim_set);\n\tif (n < 0)\n\t\tspace = isl_space_free(space);\n\tfor (i = 0; i + 1 < n; ++i) {\n\t\tisl_pw_aff *pa;\n\n\t\tpa = isl_pw_aff_list_get_pw_aff(list, i);\n\t\tpa = isl_pw_aff_add_dims(pa, isl_dim_in, n - (i + 1));\n\t\tlist = isl_pw_aff_list_set_pw_aff(list, i, pa);\n\t}\n\n\tspace = isl_space_from_range(space);\n\tspace = isl_space_add_dims(space, isl_dim_in, v->n);\n\treturn isl_multi_pw_aff_from_pw_aff_list(space, list);\n}\n\n/* Add the tuple represented by the isl_multi_pw_aff \"tuple\" to \"map\".\n * We first create the appropriate space in \"map\" based on the range\n * space of this isl_multi_pw_aff.  Then, we add equalities based\n * on the affine expressions.  These live in an anonymous space,\n * however, so we first need to reset the space to that of \"map\".\n */\nstatic __isl_give isl_map *map_from_tuple(__isl_take isl_multi_pw_aff *tuple,\n\t__isl_take isl_map *map, enum isl_dim_type type, struct vars *v,\n\tint rational)\n{\n\tint i;\n\tisl_size n;\n\tisl_ctx *ctx;\n\tisl_space *space = NULL;\n\n\tn = isl_multi_pw_aff_dim(tuple, isl_dim_out);\n\tif (!map || n < 0)\n\t\tgoto error;\n\tctx = isl_multi_pw_aff_get_ctx(tuple);\n\tspace = isl_space_range(isl_multi_pw_aff_get_space(tuple));\n\tif (!space)\n\t\tgoto error;\n\n\tif (type == isl_dim_param) {\n\t\tif (isl_space_has_tuple_name(space, isl_dim_set) ||\n\t\t    isl_space_is_wrapping(space)) {\n\t\t\tisl_die(ctx, isl_error_invalid,\n\t\t\t\t\"parameter tuples cannot be named or nested\",\n\t\t\t\tgoto error);\n\t\t}\n\t\tmap = isl_map_add_dims(map, type, n);\n\t\tfor (i = 0; i < n; ++i) {\n\t\t\tisl_id *id;\n\t\t\tif (!isl_space_has_dim_name(space, isl_dim_set, i))\n\t\t\t\tisl_die(ctx, isl_error_invalid,\n\t\t\t\t\t\"parameters must be named\",\n\t\t\t\t\tgoto error);\n\t\t\tid = isl_space_get_dim_id(space, isl_dim_set, i);\n\t\t\tmap = isl_map_set_dim_id(map, isl_dim_param, i, id);\n\t\t}\n\t} else if (type == isl_dim_in) {\n\t\tisl_set *set;\n\n\t\tset = isl_set_universe(isl_space_copy(space));\n\t\tif (rational)\n\t\t\tset = isl_set_set_rational(set);\n\t\tset = isl_set_intersect_params(set, isl_map_params(map));\n\t\tmap = isl_map_from_domain(set);\n\t} else {\n\t\tisl_set *set;\n\n\t\tset = isl_set_universe(isl_space_copy(space));\n\t\tif (rational)\n\t\t\tset = isl_set_set_rational(set);\n\t\tmap = isl_map_from_domain_and_range(isl_map_domain(map), set);\n\t}\n\n\tfor (i = 0; i < n; ++i) {\n\t\tisl_pw_aff *pa;\n\t\tisl_space *space;\n\t\tisl_aff *aff;\n\t\tisl_set *set;\n\t\tisl_map *map_i;\n\n\t\tpa = isl_multi_pw_aff_get_pw_aff(tuple, i);\n\t\tspace = isl_pw_aff_get_domain_space(pa);\n\t\taff = isl_aff_zero_on_domain(isl_local_space_from_space(space));\n\t\taff = isl_aff_add_coefficient_si(aff,\n\t\t\t\t\t\tisl_dim_in, v->n - n + i, -1);\n\t\tpa = isl_pw_aff_add(pa, isl_pw_aff_from_aff(aff));\n\t\tif (rational)\n\t\t\tpa = isl_pw_aff_set_rational(pa);\n\t\tset = isl_pw_aff_zero_set(pa);\n\t\tmap_i = isl_map_from_range(set);\n\t\tmap_i = isl_map_reset_space(map_i, isl_map_get_space(map));\n\t\tmap = isl_map_intersect(map, map_i);\n\t}\n\n\tisl_space_free(space);\n\tisl_multi_pw_aff_free(tuple);\n\treturn map;\nerror:\n\tisl_space_free(space);\n\tisl_multi_pw_aff_free(tuple);\n\tisl_map_free(map);\n\treturn NULL;\n}\n\n/* Read a tuple from \"s\" and add it to \"map\".\n * The tuple is initially represented as an isl_multi_pw_aff and\n * then added to \"map\".\n */\nstatic __isl_give isl_map *read_map_tuple(__isl_keep isl_stream *s,\n\t__isl_take isl_map *map, enum isl_dim_type type, struct vars *v,\n\tint rational, int comma)\n{\n\tisl_multi_pw_aff *tuple;\n\n\ttuple = read_tuple(s, v, rational, comma);\n\tif (!tuple)\n\t\treturn isl_map_free(map);\n\n\treturn map_from_tuple(tuple, map, type, v, rational);\n}\n\n/* Given two equal-length lists of piecewise affine expression with the space\n * of \"set\" as domain, construct a set in the same space that expresses\n * that \"left\" and \"right\" satisfy the comparison \"type\".\n *\n * A space is constructed of the same dimension as the number of elements\n * in the two lists.  The comparison is then expressed in a map from\n * this space to itself and wrapped into a set.  Finally the two lists\n * of piecewise affine expressions are plugged into this set.\n *\n * Let S be the space of \"set\" and T the constructed space.\n * The lists are first changed into two isl_multi_pw_affs in S -> T and\n * then combined into an isl_multi_pw_aff in S -> [T -> T],\n * while the comparison is first expressed in T -> T, then [T -> T]\n * and finally in S.\n */\nstatic __isl_give isl_set *list_cmp(__isl_keep isl_set *set, int type,\n\t__isl_take isl_pw_aff_list *left, __isl_take isl_pw_aff_list *right)\n{\n\tisl_space *space;\n\tisl_size n;\n\tisl_multi_pw_aff *mpa1, *mpa2;\n\n\tn = isl_pw_aff_list_n_pw_aff(left);\n\tif (!set || n < 0 || !right)\n\t\tgoto error;\n\n\tspace = isl_set_get_space(set);\n\tspace = isl_space_from_domain(space);\n\tspace = isl_space_add_dims(space, isl_dim_out, n);\n\tmpa1 = isl_multi_pw_aff_from_pw_aff_list(isl_space_copy(space), left);\n\tmpa2 = isl_multi_pw_aff_from_pw_aff_list(isl_space_copy(space), right);\n\tmpa1 = isl_multi_pw_aff_range_product(mpa1, mpa2);\n\n\tspace = isl_space_range(space);\n\tswitch (type) {\n\tcase ISL_TOKEN_LEX_LT:\n\t\tset = isl_map_wrap(isl_map_lex_lt(space));\n\t\tbreak;\n\tcase ISL_TOKEN_LEX_GT:\n\t\tset = isl_map_wrap(isl_map_lex_gt(space));\n\t\tbreak;\n\tcase ISL_TOKEN_LEX_LE:\n\t\tset = isl_map_wrap(isl_map_lex_le(space));\n\t\tbreak;\n\tcase ISL_TOKEN_LEX_GE:\n\t\tset = isl_map_wrap(isl_map_lex_ge(space));\n\t\tbreak;\n\tdefault:\n\t\tisl_multi_pw_aff_free(mpa1);\n\t\tisl_space_free(space);\n\t\tisl_die(isl_set_get_ctx(set), isl_error_internal,\n\t\t\t\"unhandled list comparison type\", return NULL);\n\t}\n\tset = isl_set_preimage_multi_pw_aff(set, mpa1);\n\treturn set;\nerror:\n\tisl_pw_aff_list_free(left);\n\tisl_pw_aff_list_free(right);\n\treturn NULL;\n}\n\n/* Construct constraints of the form\n *\n *\ta op b\n *\n * where a is an element in \"left\", op is an operator of type \"type\" and\n * b is an element in \"right\", add the constraints to \"set\" and return\n * the result.\n * \"rational\" is set if the constraints should be treated as\n * a rational constraints.\n *\n * If \"type\" is the type of a comparison operator between lists\n * of affine expressions, then a single (compound) constraint\n * is constructed by list_cmp instead.\n */\nstatic __isl_give isl_set *construct_constraints(\n\t__isl_take isl_set *set, int type,\n\t__isl_keep isl_pw_aff_list *left, __isl_keep isl_pw_aff_list *right,\n\tint rational)\n{\n\tisl_set *cond;\n\n\tleft = isl_pw_aff_list_copy(left);\n\tright = isl_pw_aff_list_copy(right);\n\tif (rational) {\n\t\tleft = isl_pw_aff_list_set_rational(left);\n\t\tright = isl_pw_aff_list_set_rational(right);\n\t}\n\tif (is_list_comparator_type(type))\n\t\tcond = list_cmp(set, type, left, right);\n\telse if (type == ISL_TOKEN_LE)\n\t\tcond = isl_pw_aff_list_le_set(left, right);\n\telse if (type == ISL_TOKEN_GE)\n\t\tcond = isl_pw_aff_list_ge_set(left, right);\n\telse if (type == ISL_TOKEN_LT)\n\t\tcond = isl_pw_aff_list_lt_set(left, right);\n\telse if (type == ISL_TOKEN_GT)\n\t\tcond = isl_pw_aff_list_gt_set(left, right);\n\telse if (type == ISL_TOKEN_NE)\n\t\tcond = isl_pw_aff_list_ne_set(left, right);\n\telse\n\t\tcond = isl_pw_aff_list_eq_set(left, right);\n\n\treturn isl_set_intersect(set, cond);\n}\n\n/* Read a constraint from \"s\", add it to \"map\" and return the result.\n * \"v\" contains a description of the identifiers parsed so far.\n * \"rational\" is set if the constraint should be treated as\n * a rational constraint.\n * The constraint read from \"s\" may be applied to multiple pairs\n * of affine expressions and may be chained.\n * In particular, a list of affine expressions is read, followed\n * by a comparison operator and another list of affine expressions.\n * The comparison operator is then applied to each pair of elements\n * in the two lists and the results are added to \"map\".\n * However, if the operator expects two lists of affine expressions,\n * then it is applied directly to those lists and the two lists\n * are required to have the same length.\n * If the next token is another comparison operator, then another\n * list of affine expressions is read and the process repeats.\n *\n * The processing is performed on a wrapped copy of \"map\" because\n * an affine expression cannot have a binary relation as domain.\n */\nstatic __isl_give isl_map *add_constraint(__isl_keep isl_stream *s,\n\tstruct vars *v, __isl_take isl_map *map, int rational)\n{\n\tstruct isl_token *tok;\n\tint type;\n\tisl_pw_aff_list *list1 = NULL, *list2 = NULL;\n\tisl_size n1, n2;\n\tisl_set *set;\n\n\tset = isl_map_wrap(map);\n\tlist1 = accept_affine_list(s, isl_set_get_space(set), v);\n\tif (!list1)\n\t\tgoto error;\n\ttok = isl_stream_next_token(s);\n\tif (!is_comparator(tok)) {\n\t\tisl_stream_error(s, tok, \"missing operator\");\n\t\tif (tok)\n\t\t\tisl_stream_push_token(s, tok);\n\t\tgoto error;\n\t}\n\ttype = tok->type;\n\tisl_token_free(tok);\n\tfor (;;) {\n\t\tlist2 = accept_affine_list(s, isl_set_get_space(set), v);\n\t\tn1 = isl_pw_aff_list_n_pw_aff(list1);\n\t\tn2 = isl_pw_aff_list_n_pw_aff(list2);\n\t\tif (n1 < 0 || n2 < 0)\n\t\t\tgoto error;\n\t\tif (is_list_comparator_type(type) && n1 != n2) {\n\t\t\tisl_stream_error(s, NULL,\n\t\t\t\t\t\"list arguments not of same size\");\n\t\t\tgoto error;\n\t\t}\n\n\t\tset = construct_constraints(set, type, list1, list2, rational);\n\t\tisl_pw_aff_list_free(list1);\n\t\tlist1 = list2;\n\n\t\tif (!next_is_comparator(s))\n\t\t\tbreak;\n\t\ttok = isl_stream_next_token(s);\n\t\ttype = tok->type;\n\t\tisl_token_free(tok);\n\t}\n\tisl_pw_aff_list_free(list1);\n\n\treturn isl_set_unwrap(set);\nerror:\n\tisl_pw_aff_list_free(list1);\n\tisl_pw_aff_list_free(list2);\n\tisl_set_free(set);\n\treturn NULL;\n}\n\nstatic __isl_give isl_map *read_exists(__isl_keep isl_stream *s,\n\tstruct vars *v, __isl_take isl_map *map, int rational)\n{\n\tint n = v->n;\n\tint seen_paren = isl_stream_eat_if_available(s, '(');\n\n\tmap = isl_map_from_domain(isl_map_wrap(map));\n\tmap = read_defined_var_list(s, v, map, rational);\n\n\tif (isl_stream_eat(s, ':'))\n\t\tgoto error;\n\n\tmap = read_formula(s, v, map, rational);\n\tmap = isl_set_unwrap(isl_map_domain(map));\n\n\tvars_drop(v, v->n - n);\n\tif (seen_paren && isl_stream_eat(s, ')'))\n\t\tgoto error;\n\n\treturn map;\nerror:\n\tisl_map_free(map);\n\treturn NULL;\n}\n\n/* Parse an expression between parentheses and push the result\n * back on the stream.\n *\n * The parsed expression may be either an affine expression\n * or a condition.  The first type is pushed onto the stream\n * as an isl_pw_aff, while the second is pushed as an isl_map.\n *\n * If the initial token indicates the start of a condition,\n * we parse it as such.\n * Otherwise, we first parse an affine expression and push\n * that onto the stream.  If the affine expression covers the\n * entire expression between parentheses, we return.\n * Otherwise, we assume that the affine expression is the\n * start of a condition and continue parsing.\n */\nstatic int resolve_paren_expr(__isl_keep isl_stream *s,\n\tstruct vars *v, __isl_take isl_map *map, int rational)\n{\n\tstruct isl_token *tok, *tok2;\n\tint has_paren;\n\tint line, col;\n\tisl_pw_aff *pwaff;\n\n\ttok = isl_stream_next_token(s);\n\tif (!tok || tok->type != '(')\n\t\tgoto error;\n\n\tif (isl_stream_next_token_is(s, '('))\n\t\tif (resolve_paren_expr(s, v, isl_map_copy(map), rational))\n\t\t\tgoto error;\n\n\tif (next_is_condition_start(s)) {\n\t\tmap = read_formula(s, v, map, rational);\n\t\tif (isl_stream_eat(s, ')'))\n\t\t\tgoto error;\n\t\ttok->type = ISL_TOKEN_MAP;\n\t\ttok->u.map = map;\n\t\tisl_stream_push_token(s, tok);\n\t\treturn 0;\n\t}\n\n\ttok2 = isl_stream_next_token(s);\n\tif (!tok2)\n\t\tgoto error;\n\tline = tok2->line;\n\tcol = tok2->col;\n\tisl_stream_push_token(s, tok2);\n\n\tpwaff = accept_affine(s, isl_space_wrap(isl_map_get_space(map)), v);\n\tif (!pwaff)\n\t\tgoto error;\n\n\thas_paren = isl_stream_eat_if_available(s, ')');\n\n\tif (push_aff(s, line, col, pwaff) < 0)\n\t\tgoto error;\n\n\tif (has_paren) {\n\t\tisl_token_free(tok);\n\t\tisl_map_free(map);\n\t\treturn 0;\n\t}\n\n\tmap = read_formula(s, v, map, rational);\n\tif (isl_stream_eat(s, ')'))\n\t\tgoto error;\n\n\ttok->type = ISL_TOKEN_MAP;\n\ttok->u.map = map;\n\tisl_stream_push_token(s, tok);\n\n\treturn 0;\nerror:\n\tisl_token_free(tok);\n\tisl_map_free(map);\n\treturn -1;\n}\n\nstatic __isl_give isl_map *read_conjunct(__isl_keep isl_stream *s,\n\tstruct vars *v, __isl_take isl_map *map, int rational)\n{\n\tif (isl_stream_next_token_is(s, '('))\n\t\tif (resolve_paren_expr(s, v, isl_map_copy(map), rational))\n\t\t\tgoto error;\n\n\tif (isl_stream_next_token_is(s, ISL_TOKEN_MAP)) {\n\t\tstruct isl_token *tok;\n\t\ttok = isl_stream_next_token(s);\n\t\tif (!tok)\n\t\t\tgoto error;\n\t\tisl_map_free(map);\n\t\tmap = isl_map_copy(tok->u.map);\n\t\tisl_token_free(tok);\n\t\treturn map;\n\t}\n\n\tif (isl_stream_eat_if_available(s, ISL_TOKEN_EXISTS))\n\t\treturn read_exists(s, v, map, rational);\n\n\tif (isl_stream_eat_if_available(s, ISL_TOKEN_TRUE))\n\t\treturn map;\n\n\tif (isl_stream_eat_if_available(s, ISL_TOKEN_FALSE)) {\n\t\tisl_space *space = isl_map_get_space(map);\n\t\tisl_map_free(map);\n\t\treturn isl_map_empty(space);\n\t}\n\t\t\n\treturn add_constraint(s, v, map, rational);\nerror:\n\tisl_map_free(map);\n\treturn NULL;\n}\n\nstatic __isl_give isl_map *read_conjuncts(__isl_keep isl_stream *s,\n\tstruct vars *v, __isl_take isl_map *map, int rational)\n{\n\tisl_map *res;\n\tint negate;\n\n\tnegate = isl_stream_eat_if_available(s, ISL_TOKEN_NOT);\n\tres = read_conjunct(s, v, isl_map_copy(map), rational);\n\tif (negate)\n\t\tres = isl_map_subtract(isl_map_copy(map), res);\n\n\twhile (res && isl_stream_eat_if_available(s, ISL_TOKEN_AND)) {\n\t\tisl_map *res_i;\n\n\t\tnegate = isl_stream_eat_if_available(s, ISL_TOKEN_NOT);\n\t\tres_i = read_conjunct(s, v, isl_map_copy(map), rational);\n\t\tif (negate)\n\t\t\tres = isl_map_subtract(res, res_i);\n\t\telse\n\t\t\tres = isl_map_intersect(res, res_i);\n\t}\n\n\tisl_map_free(map);\n\treturn res;\n}\n\nstatic __isl_give isl_map *read_disjuncts(__isl_keep isl_stream *s,\n\tstruct vars *v, __isl_take isl_map *map, int rational)\n{\n\tisl_map *res;\n\n\tif (isl_stream_next_token_is(s, '}'))\n\t\treturn map;\n\n\tres = read_conjuncts(s, v, isl_map_copy(map), rational);\n\twhile (isl_stream_eat_if_available(s, ISL_TOKEN_OR)) {\n\t\tisl_map *res_i;\n\n\t\tres_i = read_conjuncts(s, v, isl_map_copy(map), rational);\n\t\tres = isl_map_union(res, res_i);\n\t}\n\n\tisl_map_free(map);\n\treturn res;\n}\n\n/* Read a first order formula from \"s\", add the corresponding\n * constraints to \"map\" and return the result.\n *\n * In particular, read a formula of the form\n *\n *\ta\n *\n * or\n *\n *\ta implies b\n *\n * where a and b are disjunctions.\n *\n * In the first case, map is replaced by\n *\n *\tmap \\cap { [..] : a }\n *\n * In the second case, it is replaced by\n *\n *\t(map \\setminus { [..] : a}) \\cup (map \\cap { [..] : b })\n */\nstatic __isl_give isl_map *read_formula(__isl_keep isl_stream *s,\n\tstruct vars *v, __isl_take isl_map *map, int rational)\n{\n\tisl_map *res;\n\n\tres = read_disjuncts(s, v, isl_map_copy(map), rational);\n\n\tif (isl_stream_eat_if_available(s, ISL_TOKEN_IMPLIES)) {\n\t\tisl_map *res2;\n\n\t\tres = isl_map_subtract(isl_map_copy(map), res);\n\t\tres2 = read_disjuncts(s, v, map, rational);\n\t\tres = isl_map_union(res, res2);\n\t} else\n\t\tisl_map_free(map);\n\n\treturn res;\n}\n\nstatic isl_size polylib_pos_to_isl_pos(__isl_keep isl_basic_map *bmap, int pos)\n{\n\tisl_size n_out, n_in, n_param, n_div;\n\n\tn_param = isl_basic_map_dim(bmap, isl_dim_param);\n\tn_in = isl_basic_map_dim(bmap, isl_dim_in);\n\tn_out = isl_basic_map_dim(bmap, isl_dim_out);\n\tn_div = isl_basic_map_dim(bmap, isl_dim_div);\n\tif (n_param < 0 || n_in < 0 || n_out < 0 || n_div < 0)\n\t\treturn isl_size_error;\n\n\tif (pos < n_out)\n\t\treturn 1 + n_param + n_in + pos;\n\tpos -= n_out;\n\n\tif (pos < n_in)\n\t\treturn 1 + n_param + pos;\n\tpos -= n_in;\n\n\tif (pos < n_div)\n\t\treturn 1 + n_param + n_in + n_out + pos;\n\tpos -= n_div;\n\n\tif (pos < n_param)\n\t\treturn 1 + pos;\n\n\treturn 0;\n}\n\nstatic __isl_give isl_basic_map *basic_map_read_polylib_constraint(\n\t__isl_keep isl_stream *s, __isl_take isl_basic_map *bmap)\n{\n\tint j;\n\tstruct isl_token *tok;\n\tint type;\n\tint k;\n\tisl_int *c;\n\tisl_size total;\n\n\tif (!bmap)\n\t\treturn NULL;\n\n\ttok = isl_stream_next_token(s);\n\tif (!tok || tok->type != ISL_TOKEN_VALUE) {\n\t\tisl_stream_error(s, tok, \"expecting coefficient\");\n\t\tif (tok)\n\t\t\tisl_stream_push_token(s, tok);\n\t\tgoto error;\n\t}\n\tif (!tok->on_new_line) {\n\t\tisl_stream_error(s, tok, \"coefficient should appear on new line\");\n\t\tisl_stream_push_token(s, tok);\n\t\tgoto error;\n\t}\n\n\ttype = isl_int_get_si(tok->u.v);\n\tisl_token_free(tok);\n\n\tisl_assert(s->ctx, type == 0 || type == 1, goto error);\n\tif (type == 0) {\n\t\tk = isl_basic_map_alloc_equality(bmap);\n\t\tc = bmap->eq[k];\n\t} else {\n\t\tk = isl_basic_map_alloc_inequality(bmap);\n\t\tc = bmap->ineq[k];\n\t}\n\tif (k < 0)\n\t\tgoto error;\n\n\ttotal = isl_basic_map_dim(bmap, isl_dim_all);\n\tif (total < 0)\n\t\treturn isl_basic_map_free(bmap);\n\tfor (j = 0; j < 1 + total; ++j) {\n\t\tisl_size pos;\n\t\ttok = isl_stream_next_token(s);\n\t\tif (!tok || tok->type != ISL_TOKEN_VALUE) {\n\t\t\tisl_stream_error(s, tok, \"expecting coefficient\");\n\t\t\tif (tok)\n\t\t\t\tisl_stream_push_token(s, tok);\n\t\t\tgoto error;\n\t\t}\n\t\tif (tok->on_new_line) {\n\t\t\tisl_stream_error(s, tok,\n\t\t\t\t\"coefficient should not appear on new line\");\n\t\t\tisl_stream_push_token(s, tok);\n\t\t\tgoto error;\n\t\t}\n\t\tpos = polylib_pos_to_isl_pos(bmap, j);\n\t\tif (pos >= 0)\n\t\t\tisl_int_set(c[pos], tok->u.v);\n\t\tisl_token_free(tok);\n\t\tif (pos < 0)\n\t\t\treturn isl_basic_map_free(bmap);\n\t}\n\n\treturn bmap;\nerror:\n\tisl_basic_map_free(bmap);\n\treturn NULL;\n}\n\nstatic __isl_give isl_basic_map *basic_map_read_polylib(\n\t__isl_keep isl_stream *s)\n{\n\tint i;\n\tstruct isl_token *tok;\n\tstruct isl_token *tok2;\n\tint n_row, n_col;\n\tint on_new_line;\n\tunsigned in = 0, out, local = 0;\n\tstruct isl_basic_map *bmap = NULL;\n\tint nparam = 0;\n\n\ttok = isl_stream_next_token(s);\n\tif (!tok) {\n\t\tisl_stream_error(s, NULL, \"unexpected EOF\");\n\t\treturn NULL;\n\t}\n\ttok2 = isl_stream_next_token(s);\n\tif (!tok2) {\n\t\tisl_token_free(tok);\n\t\tisl_stream_error(s, NULL, \"unexpected EOF\");\n\t\treturn NULL;\n\t}\n\tif (tok->type != ISL_TOKEN_VALUE || tok2->type != ISL_TOKEN_VALUE) {\n\t\tisl_stream_push_token(s, tok2);\n\t\tisl_stream_push_token(s, tok);\n\t\tisl_stream_error(s, NULL,\n\t\t\t\t \"expecting constraint matrix dimensions\");\n\t\treturn NULL;\n\t}\n\tn_row = isl_int_get_si(tok->u.v);\n\tn_col = isl_int_get_si(tok2->u.v);\n\ton_new_line = tok2->on_new_line;\n\tisl_token_free(tok2);\n\tisl_token_free(tok);\n\tisl_assert(s->ctx, !on_new_line, return NULL);\n\tisl_assert(s->ctx, n_row >= 0, return NULL);\n\tisl_assert(s->ctx, n_col >= 2 + nparam, return NULL);\n\ttok = isl_stream_next_token_on_same_line(s);\n\tif (tok) {\n\t\tif (tok->type != ISL_TOKEN_VALUE) {\n\t\t\tisl_stream_error(s, tok,\n\t\t\t\t    \"expecting number of output dimensions\");\n\t\t\tisl_stream_push_token(s, tok);\n\t\t\tgoto error;\n\t\t}\n\t\tout = isl_int_get_si(tok->u.v);\n\t\tisl_token_free(tok);\n\n\t\ttok = isl_stream_next_token_on_same_line(s);\n\t\tif (!tok || tok->type != ISL_TOKEN_VALUE) {\n\t\t\tisl_stream_error(s, tok,\n\t\t\t\t    \"expecting number of input dimensions\");\n\t\t\tif (tok)\n\t\t\t\tisl_stream_push_token(s, tok);\n\t\t\tgoto error;\n\t\t}\n\t\tin = isl_int_get_si(tok->u.v);\n\t\tisl_token_free(tok);\n\n\t\ttok = isl_stream_next_token_on_same_line(s);\n\t\tif (!tok || tok->type != ISL_TOKEN_VALUE) {\n\t\t\tisl_stream_error(s, tok,\n\t\t\t\t    \"expecting number of existentials\");\n\t\t\tif (tok)\n\t\t\t\tisl_stream_push_token(s, tok);\n\t\t\tgoto error;\n\t\t}\n\t\tlocal = isl_int_get_si(tok->u.v);\n\t\tisl_token_free(tok);\n\n\t\ttok = isl_stream_next_token_on_same_line(s);\n\t\tif (!tok || tok->type != ISL_TOKEN_VALUE) {\n\t\t\tisl_stream_error(s, tok,\n\t\t\t\t    \"expecting number of parameters\");\n\t\t\tif (tok)\n\t\t\t\tisl_stream_push_token(s, tok);\n\t\t\tgoto error;\n\t\t}\n\t\tnparam = isl_int_get_si(tok->u.v);\n\t\tisl_token_free(tok);\n\t\tif (n_col != 1 + out + in + local + nparam + 1) {\n\t\t\tisl_stream_error(s, NULL,\n\t\t\t\t    \"dimensions don't match\");\n\t\t\tgoto error;\n\t\t}\n\t} else\n\t\tout = n_col - 2 - nparam;\n\tbmap = isl_basic_map_alloc(s->ctx, nparam, in, out, local, n_row, n_row);\n\tif (!bmap)\n\t\treturn NULL;\n\n\tfor (i = 0; i < local; ++i) {\n\t\tint k = isl_basic_map_alloc_div(bmap);\n\t\tif (k < 0)\n\t\t\tgoto error;\n\t\tisl_seq_clr(bmap->div[k], 1 + 1 + nparam + in + out + local);\n\t}\n\n\tfor (i = 0; i < n_row; ++i)\n\t\tbmap = basic_map_read_polylib_constraint(s, bmap);\n\n\ttok = isl_stream_next_token_on_same_line(s);\n\tif (tok) {\n\t\tisl_stream_error(s, tok, \"unexpected extra token on line\");\n\t\tisl_stream_push_token(s, tok);\n\t\tgoto error;\n\t}\n\n\tbmap = isl_basic_map_simplify(bmap);\n\tbmap = isl_basic_map_finalize(bmap);\n\treturn bmap;\nerror:\n\tisl_basic_map_free(bmap);\n\treturn NULL;\n}\n\nstatic __isl_give isl_map *map_read_polylib(__isl_keep isl_stream *s)\n{\n\tstruct isl_token *tok;\n\tstruct isl_token *tok2;\n\tint i, n;\n\tstruct isl_map *map;\n\n\ttok = isl_stream_next_token(s);\n\tif (!tok) {\n\t\tisl_stream_error(s, NULL, \"unexpected EOF\");\n\t\treturn NULL;\n\t}\n\ttok2 = isl_stream_next_token_on_same_line(s);\n\tif (tok2 && tok2->type == ISL_TOKEN_VALUE) {\n\t\tisl_stream_push_token(s, tok2);\n\t\tisl_stream_push_token(s, tok);\n\t\treturn isl_map_from_basic_map(basic_map_read_polylib(s));\n\t}\n\tif (tok2) {\n\t\tisl_stream_error(s, tok2, \"unexpected token\");\n\t\tisl_stream_push_token(s, tok2);\n\t\tisl_stream_push_token(s, tok);\n\t\treturn NULL;\n\t}\n\tn = isl_int_get_si(tok->u.v);\n\tisl_token_free(tok);\n\n\tisl_assert(s->ctx, n >= 1, return NULL);\n\n\tmap = isl_map_from_basic_map(basic_map_read_polylib(s));\n\n\tfor (i = 1; map && i < n; ++i)\n\t\tmap = isl_map_union(map,\n\t\t\tisl_map_from_basic_map(basic_map_read_polylib(s)));\n\n\treturn map;\n}\n\nstatic int optional_power(__isl_keep isl_stream *s)\n{\n\tint pow;\n\tstruct isl_token *tok;\n\n\ttok = isl_stream_next_token(s);\n\tif (!tok)\n\t\treturn 1;\n\tif (tok->type != '^') {\n\t\tisl_stream_push_token(s, tok);\n\t\treturn 1;\n\t}\n\tisl_token_free(tok);\n\ttok = isl_stream_next_token(s);\n\tif (!tok || tok->type != ISL_TOKEN_VALUE) {\n\t\tisl_stream_error(s, tok, \"expecting exponent\");\n\t\tif (tok)\n\t\t\tisl_stream_push_token(s, tok);\n\t\treturn 1;\n\t}\n\tpow = isl_int_get_si(tok->u.v);\n\tisl_token_free(tok);\n\treturn pow;\n}\n\nstatic __isl_give isl_pw_qpolynomial *read_term(__isl_keep isl_stream *s,\n\t__isl_keep isl_map *map, struct vars *v);\n\nstatic __isl_give isl_pw_qpolynomial *read_factor(__isl_keep isl_stream *s,\n\t__isl_keep isl_map *map, struct vars *v)\n{\n\tisl_pw_qpolynomial *pwqp;\n\tstruct isl_token *tok;\n\n\ttok = next_token(s);\n\tif (!tok) {\n\t\tisl_stream_error(s, NULL, \"unexpected EOF\");\n\t\treturn NULL;\n\t}\n\tif (tok->type == '(') {\n\t\tint pow;\n\n\t\tisl_token_free(tok);\n\t\tpwqp = read_term(s, map, v);\n\t\tif (!pwqp)\n\t\t\treturn NULL;\n\t\tif (isl_stream_eat(s, ')'))\n\t\t\tgoto error;\n\t\tpow = optional_power(s);\n\t\tpwqp = isl_pw_qpolynomial_pow(pwqp, pow);\n\t} else if (tok->type == ISL_TOKEN_VALUE) {\n\t\tstruct isl_token *tok2;\n\t\tisl_qpolynomial *qp;\n\n\t\ttok2 = isl_stream_next_token(s);\n\t\tif (tok2 && tok2->type == '/') {\n\t\t\tisl_token_free(tok2);\n\t\t\ttok2 = next_token(s);\n\t\t\tif (!tok2 || tok2->type != ISL_TOKEN_VALUE) {\n\t\t\t\tisl_stream_error(s, tok2, \"expected denominator\");\n\t\t\t\tisl_token_free(tok);\n\t\t\t\tisl_token_free(tok2);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tqp = isl_qpolynomial_rat_cst_on_domain(isl_map_get_space(map),\n\t\t\t\t\t\t    tok->u.v, tok2->u.v);\n\t\t\tisl_token_free(tok2);\n\t\t} else {\n\t\t\tisl_stream_push_token(s, tok2);\n\t\t\tqp = isl_qpolynomial_cst_on_domain(isl_map_get_space(map),\n\t\t\t\t\t\ttok->u.v);\n\t\t}\n\t\tisl_token_free(tok);\n\t\tpwqp = isl_pw_qpolynomial_from_qpolynomial(qp);\n\t} else if (tok->type == ISL_TOKEN_INFTY) {\n\t\tisl_qpolynomial *qp;\n\t\tisl_token_free(tok);\n\t\tqp = isl_qpolynomial_infty_on_domain(isl_map_get_space(map));\n\t\tpwqp = isl_pw_qpolynomial_from_qpolynomial(qp);\n\t} else if (tok->type == ISL_TOKEN_NAN) {\n\t\tisl_qpolynomial *qp;\n\t\tisl_token_free(tok);\n\t\tqp = isl_qpolynomial_nan_on_domain(isl_map_get_space(map));\n\t\tpwqp = isl_pw_qpolynomial_from_qpolynomial(qp);\n\t} else if (tok->type == ISL_TOKEN_IDENT) {\n\t\tint n = v->n;\n\t\tint pos = vars_pos(v, tok->u.s, -1);\n\t\tint pow;\n\t\tisl_qpolynomial *qp;\n\t\tif (pos < 0) {\n\t\t\tisl_token_free(tok);\n\t\t\treturn NULL;\n\t\t}\n\t\tif (pos >= n) {\n\t\t\tvars_drop(v, v->n - n);\n\t\t\tisl_stream_error(s, tok, \"unknown identifier\");\n\t\t\tisl_token_free(tok);\n\t\t\treturn NULL;\n\t\t}\n\t\tisl_token_free(tok);\n\t\tpow = optional_power(s);\n\t\tqp = isl_qpolynomial_var_pow_on_domain(isl_map_get_space(map), pos, pow);\n\t\tpwqp = isl_pw_qpolynomial_from_qpolynomial(qp);\n\t} else if (is_start_of_div(tok)) {\n\t\tisl_pw_aff *pwaff;\n\t\tint pow;\n\n\t\tisl_stream_push_token(s, tok);\n\t\tpwaff = accept_div(s, isl_map_get_space(map), v);\n\t\tpow = optional_power(s);\n\t\tpwqp = isl_pw_qpolynomial_from_pw_aff(pwaff);\n\t\tpwqp = isl_pw_qpolynomial_pow(pwqp, pow);\n\t} else if (tok->type == '-') {\n\t\tisl_token_free(tok);\n\t\tpwqp = read_factor(s, map, v);\n\t\tpwqp = isl_pw_qpolynomial_neg(pwqp);\n\t} else {\n\t\tisl_stream_error(s, tok, \"unexpected isl_token\");\n\t\tisl_stream_push_token(s, tok);\n\t\treturn NULL;\n\t}\n\n\tif (isl_stream_eat_if_available(s, '*') ||\n\t    isl_stream_next_token_is(s, ISL_TOKEN_IDENT)) {\n\t\tisl_pw_qpolynomial *pwqp2;\n\n\t\tpwqp2 = read_factor(s, map, v);\n\t\tpwqp = isl_pw_qpolynomial_mul(pwqp, pwqp2);\n\t}\n\n\treturn pwqp;\nerror:\n\tisl_pw_qpolynomial_free(pwqp);\n\treturn NULL;\n}\n\nstatic __isl_give isl_pw_qpolynomial *read_term(__isl_keep isl_stream *s,\n\t__isl_keep isl_map *map, struct vars *v)\n{\n\tstruct isl_token *tok;\n\tisl_pw_qpolynomial *pwqp;\n\n\tpwqp = read_factor(s, map, v);\n\n\tfor (;;) {\n\t\ttok = next_token(s);\n\t\tif (!tok)\n\t\t\treturn pwqp;\n\n\t\tif (tok->type == '+') {\n\t\t\tisl_pw_qpolynomial *pwqp2;\n\n\t\t\tisl_token_free(tok);\n\t\t\tpwqp2 = read_factor(s, map, v);\n\t\t\tpwqp = isl_pw_qpolynomial_add(pwqp, pwqp2);\n\t\t} else if (tok->type == '-') {\n\t\t\tisl_pw_qpolynomial *pwqp2;\n\n\t\t\tisl_token_free(tok);\n\t\t\tpwqp2 = read_factor(s, map, v);\n\t\t\tpwqp = isl_pw_qpolynomial_sub(pwqp, pwqp2);\n\t\t} else if (tok->type == ISL_TOKEN_VALUE &&\n\t\t\t    isl_int_is_neg(tok->u.v)) {\n\t\t\tisl_pw_qpolynomial *pwqp2;\n\n\t\t\tisl_stream_push_token(s, tok);\n\t\t\tpwqp2 = read_factor(s, map, v);\n\t\t\tpwqp = isl_pw_qpolynomial_add(pwqp, pwqp2);\n\t\t} else {\n\t\t\tisl_stream_push_token(s, tok);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn pwqp;\n}\n\nstatic __isl_give isl_map *read_optional_formula(__isl_keep isl_stream *s,\n\t__isl_take isl_map *map, struct vars *v, int rational)\n{\n\tstruct isl_token *tok;\n\n\ttok = isl_stream_next_token(s);\n\tif (!tok) {\n\t\tisl_stream_error(s, NULL, \"unexpected EOF\");\n\t\tgoto error;\n\t}\n\tif (tok->type == ':' ||\n\t    (tok->type == ISL_TOKEN_OR && !strcmp(tok->u.s, \"|\"))) {\n\t\tisl_token_free(tok);\n\t\tmap = read_formula(s, v, map, rational);\n\t} else\n\t\tisl_stream_push_token(s, tok);\n\n\treturn map;\nerror:\n\tisl_map_free(map);\n\treturn NULL;\n}\n\nstatic struct isl_obj obj_read_poly(__isl_keep isl_stream *s,\n\t__isl_take isl_map *map, struct vars *v, int n)\n{\n\tstruct isl_obj obj = { isl_obj_pw_qpolynomial, NULL };\n\tisl_pw_qpolynomial *pwqp;\n\tstruct isl_set *set;\n\n\tpwqp = read_term(s, map, v);\n\tmap = read_optional_formula(s, map, v, 0);\n\tset = isl_map_range(map);\n\n\tpwqp = isl_pw_qpolynomial_intersect_domain(pwqp, set);\n\n\tvars_drop(v, v->n - n);\n\n\tobj.v = pwqp;\n\treturn obj;\n}\n\nstatic struct isl_obj obj_read_poly_or_fold(__isl_keep isl_stream *s,\n\t__isl_take isl_set *set, struct vars *v, int n)\n{\n\tint min, max;\n\tstruct isl_obj obj = { isl_obj_pw_qpolynomial_fold, NULL };\n\tisl_pw_qpolynomial *pwqp;\n\tisl_pw_qpolynomial_fold *pwf = NULL;\n\tenum isl_fold fold;\n\n\tmax = isl_stream_eat_if_available(s, ISL_TOKEN_MAX);\n\tmin = !max && isl_stream_eat_if_available(s, ISL_TOKEN_MIN);\n\tif (!min && !max)\n\t\treturn obj_read_poly(s, set, v, n);\n\tfold = max ? isl_fold_max : isl_fold_min;\n\n\tif (isl_stream_eat(s, '('))\n\t\tgoto error;\n\n\tpwqp = read_term(s, set, v);\n\tpwf = isl_pw_qpolynomial_fold_from_pw_qpolynomial(fold, pwqp);\n\n\twhile (isl_stream_eat_if_available(s, ',')) {\n\t\tisl_pw_qpolynomial_fold *pwf_i;\n\t\tpwqp = read_term(s, set, v);\n\t\tpwf_i = isl_pw_qpolynomial_fold_from_pw_qpolynomial(fold, pwqp);\n\t\tpwf = isl_pw_qpolynomial_fold_fold(pwf, pwf_i);\n\t}\n\n\tif (isl_stream_eat(s, ')'))\n\t\tgoto error;\n\n\tset = read_optional_formula(s, set, v, 0);\n\tpwf = isl_pw_qpolynomial_fold_intersect_domain(pwf, set);\n\n\tvars_drop(v, v->n - n);\n\n\tobj.v = pwf;\n\treturn obj;\nerror:\n\tisl_set_free(set);\n\tisl_pw_qpolynomial_fold_free(pwf);\n\tobj.type = isl_obj_none;\n\treturn obj;\n}\n\nstatic int is_rational(__isl_keep isl_stream *s)\n{\n\tstruct isl_token *tok;\n\n\ttok = isl_stream_next_token(s);\n\tif (!tok)\n\t\treturn 0;\n\tif (tok->type == ISL_TOKEN_RAT && isl_stream_next_token_is(s, ':')) {\n\t\tisl_token_free(tok);\n\t\tisl_stream_eat(s, ':');\n\t\treturn 1;\n\t}\n\n\tisl_stream_push_token(s, tok);\n\n\treturn 0;\n}\n\nstatic struct isl_obj obj_read_body(__isl_keep isl_stream *s,\n\t__isl_take isl_map *map, struct vars *v)\n{\n\tstruct isl_token *tok;\n\tstruct isl_obj obj = { isl_obj_set, NULL };\n\tint n = v->n;\n\tint rational;\n\n\trational = is_rational(s);\n\tif (rational)\n\t\tmap = isl_map_set_rational(map);\n\n\tif (isl_stream_next_token_is(s, ':')) {\n\t\tobj.type = isl_obj_set;\n\t\tobj.v = read_optional_formula(s, map, v, rational);\n\t\treturn obj;\n\t}\n\n\tif (!next_is_tuple(s))\n\t\treturn obj_read_poly_or_fold(s, map, v, n);\n\n\tmap = read_map_tuple(s, map, isl_dim_in, v, rational, 0);\n\tif (!map)\n\t\tgoto error;\n\ttok = isl_stream_next_token(s);\n\tif (!tok)\n\t\tgoto error;\n\tif (tok->type == ISL_TOKEN_TO) {\n\t\tobj.type = isl_obj_map;\n\t\tisl_token_free(tok);\n\t\tif (!next_is_tuple(s)) {\n\t\t\tisl_set *set = isl_map_domain(map);\n\t\t\treturn obj_read_poly_or_fold(s, set, v, n);\n\t\t}\n\t\tmap = read_map_tuple(s, map, isl_dim_out, v, rational, 0);\n\t\tif (!map)\n\t\t\tgoto error;\n\t} else {\n\t\tmap = isl_map_domain(map);\n\t\tisl_stream_push_token(s, tok);\n\t}\n\n\tmap = read_optional_formula(s, map, v, rational);\n\n\tvars_drop(v, v->n - n);\n\n\tobj.v = map;\n\treturn obj;\nerror:\n\tisl_map_free(map);\n\tobj.type = isl_obj_none;\n\treturn obj;\n}\n\nstatic struct isl_obj to_union(isl_ctx *ctx, struct isl_obj obj)\n{\n\tif (obj.type == isl_obj_map) {\n\t\tobj.v = isl_union_map_from_map(obj.v);\n\t\tobj.type = isl_obj_union_map;\n\t} else if (obj.type == isl_obj_set) {\n\t\tobj.v = isl_union_set_from_set(obj.v);\n\t\tobj.type = isl_obj_union_set;\n\t} else if (obj.type == isl_obj_pw_qpolynomial) {\n\t\tobj.v = isl_union_pw_qpolynomial_from_pw_qpolynomial(obj.v);\n\t\tobj.type = isl_obj_union_pw_qpolynomial;\n\t} else if (obj.type == isl_obj_pw_qpolynomial_fold) {\n\t\tobj.v = isl_union_pw_qpolynomial_fold_from_pw_qpolynomial_fold(obj.v);\n\t\tobj.type = isl_obj_union_pw_qpolynomial_fold;\n\t} else\n\t\tisl_assert(ctx, 0, goto error);\n\treturn obj;\nerror:\n\tobj.type->free(obj.v);\n\tobj.type = isl_obj_none;\n\treturn obj;\n}\n\nstatic struct isl_obj obj_add(__isl_keep isl_stream *s,\n\tstruct isl_obj obj1, struct isl_obj obj2)\n{\n\tif (obj2.type == isl_obj_none || !obj2.v)\n\t\tgoto error;\n\tif (obj1.type == isl_obj_set && obj2.type == isl_obj_union_set)\n\t\tobj1 = to_union(s->ctx, obj1);\n\tif (obj1.type == isl_obj_union_set && obj2.type == isl_obj_set)\n\t\tobj2 = to_union(s->ctx, obj2);\n\tif (obj1.type == isl_obj_map && obj2.type == isl_obj_union_map)\n\t\tobj1 = to_union(s->ctx, obj1);\n\tif (obj1.type == isl_obj_union_map && obj2.type == isl_obj_map)\n\t\tobj2 = to_union(s->ctx, obj2);\n\tif (obj1.type == isl_obj_pw_qpolynomial &&\n\t    obj2.type == isl_obj_union_pw_qpolynomial)\n\t\tobj1 = to_union(s->ctx, obj1);\n\tif (obj1.type == isl_obj_union_pw_qpolynomial &&\n\t    obj2.type == isl_obj_pw_qpolynomial)\n\t\tobj2 = to_union(s->ctx, obj2);\n\tif (obj1.type == isl_obj_pw_qpolynomial_fold &&\n\t    obj2.type == isl_obj_union_pw_qpolynomial_fold)\n\t\tobj1 = to_union(s->ctx, obj1);\n\tif (obj1.type == isl_obj_union_pw_qpolynomial_fold &&\n\t    obj2.type == isl_obj_pw_qpolynomial_fold)\n\t\tobj2 = to_union(s->ctx, obj2);\n\tif (obj1.type != obj2.type) {\n\t\tisl_stream_error(s, NULL,\n\t\t\t\t\"attempt to combine incompatible objects\");\n\t\tgoto error;\n\t}\n\tif (!obj1.type->add)\n\t\tisl_die(s->ctx, isl_error_internal,\n\t\t\t\"combination not supported on object type\", goto error);\n\tif (obj1.type == isl_obj_map && !isl_map_has_equal_space(obj1.v, obj2.v)) {\n\t\tobj1 = to_union(s->ctx, obj1);\n\t\tobj2 = to_union(s->ctx, obj2);\n\t}\n\tif (obj1.type == isl_obj_set && !isl_set_has_equal_space(obj1.v, obj2.v)) {\n\t\tobj1 = to_union(s->ctx, obj1);\n\t\tobj2 = to_union(s->ctx, obj2);\n\t}\n\tif (obj1.type == isl_obj_pw_qpolynomial &&\n\t    !isl_pw_qpolynomial_has_equal_space(obj1.v, obj2.v)) {\n\t\tobj1 = to_union(s->ctx, obj1);\n\t\tobj2 = to_union(s->ctx, obj2);\n\t}\n\tif (obj1.type == isl_obj_pw_qpolynomial_fold &&\n\t    !isl_pw_qpolynomial_fold_has_equal_space(obj1.v, obj2.v)) {\n\t\tobj1 = to_union(s->ctx, obj1);\n\t\tobj2 = to_union(s->ctx, obj2);\n\t}\n\tobj1.v = obj1.type->add(obj1.v, obj2.v);\n\treturn obj1;\nerror:\n\tobj1.type->free(obj1.v);\n\tobj2.type->free(obj2.v);\n\tobj1.type = isl_obj_none;\n\tobj1.v = NULL;\n\treturn obj1;\n}\n\n/* Are the first two tokens on \"s\", \"domain\" (either as a string\n * or as an identifier) followed by \":\"?\n */\nstatic int next_is_domain_colon(__isl_keep isl_stream *s)\n{\n\tstruct isl_token *tok;\n\tchar *name;\n\tint res;\n\n\ttok = isl_stream_next_token(s);\n\tif (!tok)\n\t\treturn 0;\n\tif (tok->type != ISL_TOKEN_IDENT && tok->type != ISL_TOKEN_STRING) {\n\t\tisl_stream_push_token(s, tok);\n\t\treturn 0;\n\t}\n\n\tname = isl_token_get_str(s->ctx, tok);\n\tres = !strcmp(name, \"domain\") && isl_stream_next_token_is(s, ':');\n\tfree(name);\n\n\tisl_stream_push_token(s, tok);\n\n\treturn res;\n}\n\n/* Do the first tokens on \"s\" look like a schedule?\n *\n * The root of a schedule is always a domain node, so the first thing\n * we expect in the stream is a domain key, i.e., \"domain\" followed\n * by \":\".  If the schedule was printed in YAML flow style, then\n * we additionally expect a \"{\" to open the outer mapping.\n */\nstatic int next_is_schedule(__isl_keep isl_stream *s)\n{\n\tstruct isl_token *tok;\n\tint is_schedule;\n\n\ttok = isl_stream_next_token(s);\n\tif (!tok)\n\t\treturn 0;\n\tif (tok->type != '{') {\n\t\tisl_stream_push_token(s, tok);\n\t\treturn next_is_domain_colon(s);\n\t}\n\n\tis_schedule = next_is_domain_colon(s);\n\tisl_stream_push_token(s, tok);\n\n\treturn is_schedule;\n}\n\n/* Read an isl_schedule from \"s\" and store it in an isl_obj.\n */\nstatic struct isl_obj schedule_read(__isl_keep isl_stream *s)\n{\n\tstruct isl_obj obj;\n\n\tobj.type = isl_obj_schedule;\n\tobj.v = isl_stream_read_schedule(s);\n\n\treturn obj;\n}\n\n/* Read a disjunction of object bodies from \"s\".\n * That is, read the inside of the braces, but not the braces themselves.\n * \"v\" contains a description of the identifiers parsed so far.\n * \"map\" contains information about the parameters.\n */\nstatic struct isl_obj obj_read_disjuncts(__isl_keep isl_stream *s,\n\tstruct vars *v, __isl_keep isl_map *map)\n{\n\tstruct isl_obj obj = { isl_obj_set, NULL };\n\n\tif (isl_stream_next_token_is(s, '}')) {\n\t\tobj.type = isl_obj_union_set;\n\t\tobj.v = isl_union_set_empty(isl_map_get_space(map));\n\t\treturn obj;\n\t}\n\n\tfor (;;) {\n\t\tstruct isl_obj o;\n\t\to = obj_read_body(s, isl_map_copy(map), v);\n\t\tif (!obj.v)\n\t\t\tobj = o;\n\t\telse\n\t\t\tobj = obj_add(s, obj, o);\n\t\tif (obj.type == isl_obj_none || !obj.v)\n\t\t\treturn obj;\n\t\tif (!isl_stream_eat_if_available(s, ';'))\n\t\t\tbreak;\n\t\tif (isl_stream_next_token_is(s, '}'))\n\t\t\tbreak;\n\t}\n\n\treturn obj;\n}\n\nstatic struct isl_obj obj_read(__isl_keep isl_stream *s)\n{\n\tisl_map *map = NULL;\n\tstruct isl_token *tok;\n\tstruct vars *v = NULL;\n\tstruct isl_obj obj = { isl_obj_set, NULL };\n\n\tif (next_is_schedule(s))\n\t\treturn schedule_read(s);\n\n\ttok = next_token(s);\n\tif (!tok) {\n\t\tisl_stream_error(s, NULL, \"unexpected EOF\");\n\t\tgoto error;\n\t}\n\tif (tok->type == ISL_TOKEN_VALUE) {\n\t\tstruct isl_token *tok2;\n\t\tstruct isl_map *map;\n\n\t\ttok2 = isl_stream_next_token(s);\n\t\tif (!tok2 || tok2->type != ISL_TOKEN_VALUE ||\n\t\t    isl_int_is_neg(tok2->u.v)) {\n\t\t\tif (tok2)\n\t\t\t\tisl_stream_push_token(s, tok2);\n\t\t\tobj.type = isl_obj_val;\n\t\t\tobj.v = isl_val_int_from_isl_int(s->ctx, tok->u.v);\n\t\t\tisl_token_free(tok);\n\t\t\treturn obj;\n\t\t}\n\t\tisl_stream_push_token(s, tok2);\n\t\tisl_stream_push_token(s, tok);\n\t\tmap = map_read_polylib(s);\n\t\tif (!map)\n\t\t\tgoto error;\n\t\tif (isl_map_may_be_set(map))\n\t\t\tobj.v = isl_map_range(map);\n\t\telse {\n\t\t\tobj.type = isl_obj_map;\n\t\t\tobj.v = map;\n\t\t}\n\t\treturn obj;\n\t}\n\tv = vars_new(s->ctx);\n\tif (!v) {\n\t\tisl_stream_push_token(s, tok);\n\t\tgoto error;\n\t}\n\tmap = isl_map_universe(isl_space_params_alloc(s->ctx, 0));\n\tif (tok->type == '[') {\n\t\tisl_stream_push_token(s, tok);\n\t\tmap = read_map_tuple(s, map, isl_dim_param, v, 0, 0);\n\t\tif (!map)\n\t\t\tgoto error;\n\t\ttok = isl_stream_next_token(s);\n\t\tif (!tok || tok->type != ISL_TOKEN_TO) {\n\t\t\tisl_stream_error(s, tok, \"expecting '->'\");\n\t\t\tif (tok)\n\t\t\t\tisl_stream_push_token(s, tok);\n\t\t\tgoto error;\n\t\t}\n\t\tisl_token_free(tok);\n\t\ttok = isl_stream_next_token(s);\n\t}\n\tif (!tok || tok->type != '{') {\n\t\tisl_stream_error(s, tok, \"expecting '{'\");\n\t\tif (tok)\n\t\t\tisl_stream_push_token(s, tok);\n\t\tgoto error;\n\t}\n\tisl_token_free(tok);\n\n\ttok = isl_stream_next_token(s);\n\tif (!tok)\n\t\t;\n\telse if (tok->type == ISL_TOKEN_IDENT && !strcmp(tok->u.s, \"Sym\")) {\n\t\tisl_token_free(tok);\n\t\tif (isl_stream_eat(s, '='))\n\t\t\tgoto error;\n\t\tmap = read_map_tuple(s, map, isl_dim_param, v, 0, 1);\n\t\tif (!map)\n\t\t\tgoto error;\n\t} else\n\t\tisl_stream_push_token(s, tok);\n\n\tobj = obj_read_disjuncts(s, v, map);\n\tif (obj.type == isl_obj_none || !obj.v)\n\t\tgoto error;\n\n\ttok = isl_stream_next_token(s);\n\tif (tok && tok->type == '}') {\n\t\tisl_token_free(tok);\n\t} else {\n\t\tisl_stream_error(s, tok, \"unexpected isl_token\");\n\t\tif (tok)\n\t\t\tisl_token_free(tok);\n\t\tgoto error;\n\t}\n\n\tvars_free(v);\n\tisl_map_free(map);\n\n\treturn obj;\nerror:\n\tisl_map_free(map);\n\tobj.type->free(obj.v);\n\tif (v)\n\t\tvars_free(v);\n\tobj.v = NULL;\n\treturn obj;\n}\n\nstruct isl_obj isl_stream_read_obj(__isl_keep isl_stream *s)\n{\n\treturn obj_read(s);\n}\n\n__isl_give isl_map *isl_stream_read_map(__isl_keep isl_stream *s)\n{\n\tstruct isl_obj obj;\n\n\tobj = obj_read(s);\n\tif (obj.v)\n\t\tisl_assert(s->ctx, obj.type == isl_obj_map ||\n\t\t\t\t   obj.type == isl_obj_set, goto error);\n\t\n\tif (obj.type == isl_obj_set)\n\t\tobj.v = isl_map_from_range(obj.v);\n\n\treturn obj.v;\nerror:\n\tobj.type->free(obj.v);\n\treturn NULL;\n}\n\n__isl_give isl_set *isl_stream_read_set(__isl_keep isl_stream *s)\n{\n\tstruct isl_obj obj;\n\n\tobj = obj_read(s);\n\tif (obj.v) {\n\t\tif (obj.type == isl_obj_map && isl_map_may_be_set(obj.v)) {\n\t\t\tobj.v = isl_map_range(obj.v);\n\t\t\tobj.type = isl_obj_set;\n\t\t}\n\t\tisl_assert(s->ctx, obj.type == isl_obj_set, goto error);\n\t}\n\n\treturn obj.v;\nerror:\n\tobj.type->free(obj.v);\n\treturn NULL;\n}\n\n__isl_give isl_union_map *isl_stream_read_union_map(__isl_keep isl_stream *s)\n{\n\tstruct isl_obj obj;\n\n\tobj = obj_read(s);\n\tif (obj.type == isl_obj_map) {\n\t\tobj.type = isl_obj_union_map;\n\t\tobj.v = isl_union_map_from_map(obj.v);\n\t}\n\tif (obj.type == isl_obj_set) {\n\t\tobj.type = isl_obj_union_set;\n\t\tobj.v = isl_union_set_from_set(obj.v);\n\t}\n\tif (obj.v && obj.type == isl_obj_union_set &&\n\t    isl_union_set_is_empty(obj.v))\n\t\tobj.type = isl_obj_union_map;\n\tif (obj.v && obj.type != isl_obj_union_map)\n\t\tisl_die(s->ctx, isl_error_invalid, \"invalid input\", goto error);\n\n\treturn obj.v;\nerror:\n\tobj.type->free(obj.v);\n\treturn NULL;\n}\n\n/* Extract an isl_union_set from \"obj\".\n * This only works if the object was detected as either a set\n * (in which case it is converted to a union set) or a union set.\n */\nstatic __isl_give isl_union_set *extract_union_set(isl_ctx *ctx,\n\tstruct isl_obj obj)\n{\n\tif (obj.type == isl_obj_set) {\n\t\tobj.type = isl_obj_union_set;\n\t\tobj.v = isl_union_set_from_set(obj.v);\n\t}\n\tif (obj.v)\n\t\tisl_assert(ctx, obj.type == isl_obj_union_set, goto error);\n\n\treturn obj.v;\nerror:\n\tobj.type->free(obj.v);\n\treturn NULL;\n}\n\n/* Read an isl_union_set from \"s\".\n * First read a generic object and then try and extract\n * an isl_union_set from that.\n */\n__isl_give isl_union_set *isl_stream_read_union_set(__isl_keep isl_stream *s)\n{\n\tstruct isl_obj obj;\n\n\tobj = obj_read(s);\n\treturn extract_union_set(s->ctx, obj);\n}\n\nstatic __isl_give isl_basic_map *basic_map_read(__isl_keep isl_stream *s)\n{\n\tstruct isl_obj obj;\n\tstruct isl_map *map;\n\tstruct isl_basic_map *bmap;\n\n\tobj = obj_read(s);\n\tif (obj.v && (obj.type != isl_obj_map && obj.type != isl_obj_set))\n\t\tisl_die(s->ctx, isl_error_invalid, \"not a (basic) set or map\",\n\t\t\tgoto error);\n\tmap = obj.v;\n\tif (!map)\n\t\treturn NULL;\n\n\tif (map->n > 1)\n\t\tisl_die(s->ctx, isl_error_invalid,\n\t\t\t\"set or map description involves \"\n\t\t\t\"more than one disjunct\", goto error);\n\n\tif (map->n == 0)\n\t\tbmap = isl_basic_map_empty(isl_map_get_space(map));\n\telse\n\t\tbmap = isl_basic_map_copy(map->p[0]);\n\n\tisl_map_free(map);\n\n\treturn bmap;\nerror:\n\tobj.type->free(obj.v);\n\treturn NULL;\n}\n\nstatic __isl_give isl_basic_set *basic_set_read(__isl_keep isl_stream *s)\n{\n\tisl_basic_map *bmap;\n\tbmap = basic_map_read(s);\n\tif (!bmap)\n\t\treturn NULL;\n\tif (!isl_basic_map_may_be_set(bmap))\n\t\tisl_die(s->ctx, isl_error_invalid,\n\t\t\t\"input is not a set\", goto error);\n\treturn isl_basic_map_range(bmap);\nerror:\n\tisl_basic_map_free(bmap);\n\treturn NULL;\n}\n\n__isl_give isl_basic_map *isl_basic_map_read_from_file(isl_ctx *ctx,\n\tFILE *input)\n{\n\tstruct isl_basic_map *bmap;\n\tisl_stream *s = isl_stream_new_file(ctx, input);\n\tif (!s)\n\t\treturn NULL;\n\tbmap = basic_map_read(s);\n\tisl_stream_free(s);\n\treturn bmap;\n}\n\n__isl_give isl_basic_set *isl_basic_set_read_from_file(isl_ctx *ctx,\n\tFILE *input)\n{\n\tisl_basic_set *bset;\n\tisl_stream *s = isl_stream_new_file(ctx, input);\n\tif (!s)\n\t\treturn NULL;\n\tbset = basic_set_read(s);\n\tisl_stream_free(s);\n\treturn bset;\n}\n\n__isl_give isl_basic_map *isl_basic_map_read_from_str(isl_ctx *ctx,\n\tconst char *str)\n{\n\tstruct isl_basic_map *bmap;\n\tisl_stream *s = isl_stream_new_str(ctx, str);\n\tif (!s)\n\t\treturn NULL;\n\tbmap = basic_map_read(s);\n\tisl_stream_free(s);\n\treturn bmap;\n}\n\n__isl_give isl_basic_set *isl_basic_set_read_from_str(isl_ctx *ctx,\n\tconst char *str)\n{\n\tisl_basic_set *bset;\n\tisl_stream *s = isl_stream_new_str(ctx, str);\n\tif (!s)\n\t\treturn NULL;\n\tbset = basic_set_read(s);\n\tisl_stream_free(s);\n\treturn bset;\n}\n\n__isl_give isl_map *isl_map_read_from_file(struct isl_ctx *ctx,\n\tFILE *input)\n{\n\tstruct isl_map *map;\n\tisl_stream *s = isl_stream_new_file(ctx, input);\n\tif (!s)\n\t\treturn NULL;\n\tmap = isl_stream_read_map(s);\n\tisl_stream_free(s);\n\treturn map;\n}\n\n__isl_give isl_map *isl_map_read_from_str(struct isl_ctx *ctx,\n\tconst char *str)\n{\n\tstruct isl_map *map;\n\tisl_stream *s = isl_stream_new_str(ctx, str);\n\tif (!s)\n\t\treturn NULL;\n\tmap = isl_stream_read_map(s);\n\tisl_stream_free(s);\n\treturn map;\n}\n\n__isl_give isl_set *isl_set_read_from_file(struct isl_ctx *ctx,\n\tFILE *input)\n{\n\tisl_set *set;\n\tisl_stream *s = isl_stream_new_file(ctx, input);\n\tif (!s)\n\t\treturn NULL;\n\tset = isl_stream_read_set(s);\n\tisl_stream_free(s);\n\treturn set;\n}\n\n__isl_give isl_set *isl_set_read_from_str(isl_ctx *ctx, const char *str)\n{\n\tisl_set *set;\n\tisl_stream *s = isl_stream_new_str(ctx, str);\n\tif (!s)\n\t\treturn NULL;\n\tset = isl_stream_read_set(s);\n\tisl_stream_free(s);\n\treturn set;\n}\n\n__isl_give isl_union_map *isl_union_map_read_from_file(isl_ctx *ctx,\n\tFILE *input)\n{\n\tisl_union_map *umap;\n\tisl_stream *s = isl_stream_new_file(ctx, input);\n\tif (!s)\n\t\treturn NULL;\n\tumap = isl_stream_read_union_map(s);\n\tisl_stream_free(s);\n\treturn umap;\n}\n\n__isl_give isl_union_map *isl_union_map_read_from_str(struct isl_ctx *ctx,\n\t\tconst char *str)\n{\n\tisl_union_map *umap;\n\tisl_stream *s = isl_stream_new_str(ctx, str);\n\tif (!s)\n\t\treturn NULL;\n\tumap = isl_stream_read_union_map(s);\n\tisl_stream_free(s);\n\treturn umap;\n}\n\n__isl_give isl_union_set *isl_union_set_read_from_file(isl_ctx *ctx,\n\tFILE *input)\n{\n\tisl_union_set *uset;\n\tisl_stream *s = isl_stream_new_file(ctx, input);\n\tif (!s)\n\t\treturn NULL;\n\tuset = isl_stream_read_union_set(s);\n\tisl_stream_free(s);\n\treturn uset;\n}\n\n__isl_give isl_union_set *isl_union_set_read_from_str(struct isl_ctx *ctx,\n\t\tconst char *str)\n{\n\tisl_union_set *uset;\n\tisl_stream *s = isl_stream_new_str(ctx, str);\n\tif (!s)\n\t\treturn NULL;\n\tuset = isl_stream_read_union_set(s);\n\tisl_stream_free(s);\n\treturn uset;\n}\n\nstatic __isl_give isl_vec *isl_vec_read_polylib(__isl_keep isl_stream *s)\n{\n\tstruct isl_vec *vec = NULL;\n\tstruct isl_token *tok;\n\tunsigned size;\n\tint j;\n\n\ttok = isl_stream_next_token(s);\n\tif (!tok || tok->type != ISL_TOKEN_VALUE) {\n\t\tisl_stream_error(s, tok, \"expecting vector length\");\n\t\tgoto error;\n\t}\n\n\tsize = isl_int_get_si(tok->u.v);\n\tisl_token_free(tok);\n\n\tvec = isl_vec_alloc(s->ctx, size);\n\n\tfor (j = 0; j < size; ++j) {\n\t\ttok = isl_stream_next_token(s);\n\t\tif (!tok || tok->type != ISL_TOKEN_VALUE) {\n\t\t\tisl_stream_error(s, tok, \"expecting constant value\");\n\t\t\tgoto error;\n\t\t}\n\t\tisl_int_set(vec->el[j], tok->u.v);\n\t\tisl_token_free(tok);\n\t}\n\n\treturn vec;\nerror:\n\tisl_token_free(tok);\n\tisl_vec_free(vec);\n\treturn NULL;\n}\n\nstatic __isl_give isl_vec *vec_read(__isl_keep isl_stream *s)\n{\n\treturn isl_vec_read_polylib(s);\n}\n\n__isl_give isl_vec *isl_vec_read_from_file(isl_ctx *ctx, FILE *input)\n{\n\tisl_vec *v;\n\tisl_stream *s = isl_stream_new_file(ctx, input);\n\tif (!s)\n\t\treturn NULL;\n\tv = vec_read(s);\n\tisl_stream_free(s);\n\treturn v;\n}\n\n__isl_give isl_pw_qpolynomial *isl_stream_read_pw_qpolynomial(\n\t__isl_keep isl_stream *s)\n{\n\tstruct isl_obj obj;\n\n\tobj = obj_read(s);\n\tif (obj.v)\n\t\tisl_assert(s->ctx, obj.type == isl_obj_pw_qpolynomial,\n\t\t\t   goto error);\n\n\treturn obj.v;\nerror:\n\tobj.type->free(obj.v);\n\treturn NULL;\n}\n\n__isl_give isl_pw_qpolynomial *isl_pw_qpolynomial_read_from_str(isl_ctx *ctx,\n\t\tconst char *str)\n{\n\tisl_pw_qpolynomial *pwqp;\n\tisl_stream *s = isl_stream_new_str(ctx, str);\n\tif (!s)\n\t\treturn NULL;\n\tpwqp = isl_stream_read_pw_qpolynomial(s);\n\tisl_stream_free(s);\n\treturn pwqp;\n}\n\n__isl_give isl_pw_qpolynomial *isl_pw_qpolynomial_read_from_file(isl_ctx *ctx,\n\t\tFILE *input)\n{\n\tisl_pw_qpolynomial *pwqp;\n\tisl_stream *s = isl_stream_new_file(ctx, input);\n\tif (!s)\n\t\treturn NULL;\n\tpwqp = isl_stream_read_pw_qpolynomial(s);\n\tisl_stream_free(s);\n\treturn pwqp;\n}\n\n/* Read an isl_pw_qpolynomial_fold from \"s\".\n * First read a generic object and\n * then check that it is an isl_pw_qpolynomial_fold.\n */\n__isl_give isl_pw_qpolynomial_fold *isl_stream_read_pw_qpolynomial_fold(\n\t__isl_keep isl_stream *s)\n{\n\tstruct isl_obj obj;\n\n\tobj = obj_read(s);\n\tif (obj.v && obj.type != isl_obj_pw_qpolynomial_fold)\n\t\tisl_die(s->ctx, isl_error_invalid, \"invalid input\", goto error);\n\n\treturn obj.v;\nerror:\n\tobj.type->free(obj.v);\n\treturn NULL;\n}\n\n/* Read an isl_pw_qpolynomial_fold from \"str\".\n */\n__isl_give isl_pw_qpolynomial_fold *isl_pw_qpolynomial_fold_read_from_str(\n\tisl_ctx *ctx, const char *str)\n{\n\tisl_pw_qpolynomial_fold *pwqp;\n\tisl_stream *s;\n\n\ts = isl_stream_new_str(ctx, str);\n\tif (!s)\n\t\treturn NULL;\n\tpwqp = isl_stream_read_pw_qpolynomial_fold(s);\n\tisl_stream_free(s);\n\n\treturn pwqp;\n}\n\n/* Is the next token an identifier not in \"v\"?\n */\nstatic int next_is_fresh_ident(__isl_keep isl_stream *s, struct vars *v)\n{\n\tint n = v->n;\n\tint fresh;\n\tstruct isl_token *tok;\n\n\ttok = isl_stream_next_token(s);\n\tif (!tok)\n\t\treturn 0;\n\tfresh = tok->type == ISL_TOKEN_IDENT && vars_pos(v, tok->u.s, -1) >= n;\n\tisl_stream_push_token(s, tok);\n\n\tvars_drop(v, v->n - n);\n\n\treturn fresh;\n}\n\n/* First read the domain of the affine expression, which may be\n * a parameter space or a set.\n * The tricky part is that we don't know if the domain is a set or not,\n * so when we are trying to read the domain, we may actually be reading\n * the affine expression itself (defined on a parameter domains)\n * If the tuple we are reading is named, we assume it's the domain.\n * Also, if inside the tuple, the first thing we find is a nested tuple\n * or a new identifier, we again assume it's the domain.\n * Finally, if the tuple is empty, then it must be the domain\n * since it does not contain an affine expression.\n * Otherwise, we assume we are reading an affine expression.\n */\nstatic __isl_give isl_set *read_aff_domain(__isl_keep isl_stream *s,\n\t__isl_take isl_set *dom, struct vars *v)\n{\n\tstruct isl_token *tok, *tok2;\n\tint is_empty;\n\n\ttok = isl_stream_next_token(s);\n\tif (tok && (tok->type == ISL_TOKEN_IDENT || tok->is_keyword)) {\n\t\tisl_stream_push_token(s, tok);\n\t\treturn read_map_tuple(s, dom, isl_dim_set, v, 0, 0);\n\t}\n\tif (!tok || tok->type != '[') {\n\t\tisl_stream_error(s, tok, \"expecting '['\");\n\t\tgoto error;\n\t}\n\ttok2 = isl_stream_next_token(s);\n\tis_empty = tok2 && tok2->type == ']';\n\tif (tok2)\n\t\tisl_stream_push_token(s, tok2);\n\tif (is_empty || next_is_tuple(s) || next_is_fresh_ident(s, v)) {\n\t\tisl_stream_push_token(s, tok);\n\t\tdom = read_map_tuple(s, dom, isl_dim_set, v, 0, 0);\n\t} else\n\t\tisl_stream_push_token(s, tok);\n\n\treturn dom;\nerror:\n\tif (tok)\n\t\tisl_stream_push_token(s, tok);\n\tisl_set_free(dom);\n\treturn NULL;\n}\n\n/* Read an affine expression from \"s\".\n */\n__isl_give isl_aff *isl_stream_read_aff(__isl_keep isl_stream *s)\n{\n\tisl_aff *aff;\n\tisl_multi_aff *ma;\n\tisl_size dim;\n\n\tma = isl_stream_read_multi_aff(s);\n\tdim = isl_multi_aff_dim(ma, isl_dim_out);\n\tif (dim < 0)\n\t\tgoto error;\n\tif (dim != 1)\n\t\tisl_die(s->ctx, isl_error_invalid,\n\t\t\t\"expecting single affine expression\",\n\t\t\tgoto error);\n\n\taff = isl_multi_aff_get_aff(ma, 0);\n\tisl_multi_aff_free(ma);\n\treturn aff;\nerror:\n\tisl_multi_aff_free(ma);\n\treturn NULL;\n}\n\n/* Read a piecewise affine expression from \"s\" with domain (space) \"dom\".\n */\nstatic __isl_give isl_pw_aff *read_pw_aff_with_dom(__isl_keep isl_stream *s,\n\t__isl_take isl_set *dom, struct vars *v)\n{\n\tisl_pw_aff *pwaff = NULL;\n\n\tif (!isl_set_is_params(dom) && isl_stream_eat(s, ISL_TOKEN_TO))\n\t\tgoto error;\n\n\tif (isl_stream_eat(s, '['))\n\t\tgoto error;\n\n\tpwaff = accept_affine(s, isl_set_get_space(dom), v);\n\n\tif (isl_stream_eat(s, ']'))\n\t\tgoto error;\n\n\tdom = read_optional_formula(s, dom, v, 0);\n\tpwaff = isl_pw_aff_intersect_domain(pwaff, dom);\n\n\treturn pwaff;\nerror:\n\tisl_set_free(dom);\n\tisl_pw_aff_free(pwaff);\n\treturn NULL;\n}\n\n__isl_give isl_pw_aff *isl_stream_read_pw_aff(__isl_keep isl_stream *s)\n{\n\tstruct vars *v;\n\tisl_set *dom = NULL;\n\tisl_set *aff_dom;\n\tisl_pw_aff *pa = NULL;\n\tint n;\n\n\tv = vars_new(s->ctx);\n\tif (!v)\n\t\treturn NULL;\n\n\tdom = isl_set_universe(isl_space_params_alloc(s->ctx, 0));\n\tif (next_is_tuple(s)) {\n\t\tdom = read_map_tuple(s, dom, isl_dim_param, v, 1, 0);\n\t\tif (isl_stream_eat(s, ISL_TOKEN_TO))\n\t\t\tgoto error;\n\t}\n\tif (isl_stream_eat(s, '{'))\n\t\tgoto error;\n\n\tn = v->n;\n\taff_dom = read_aff_domain(s, isl_set_copy(dom), v);\n\tpa = read_pw_aff_with_dom(s, aff_dom, v);\n\tvars_drop(v, v->n - n);\n\n\twhile (isl_stream_eat_if_available(s, ';')) {\n\t\tisl_pw_aff *pa_i;\n\n\t\tn = v->n;\n\t\taff_dom = read_aff_domain(s, isl_set_copy(dom), v);\n\t\tpa_i = read_pw_aff_with_dom(s, aff_dom, v);\n\t\tvars_drop(v, v->n - n);\n\n\t\tpa = isl_pw_aff_union_add(pa, pa_i);\n\t}\n\n\tif (isl_stream_eat(s, '}'))\n\t\tgoto error;\n\n\tvars_free(v);\n\tisl_set_free(dom);\n\treturn pa;\nerror:\n\tvars_free(v);\n\tisl_set_free(dom);\n\tisl_pw_aff_free(pa);\n\treturn NULL;\n}\n\n__isl_give isl_aff *isl_aff_read_from_str(isl_ctx *ctx, const char *str)\n{\n\tisl_aff *aff;\n\tisl_stream *s = isl_stream_new_str(ctx, str);\n\tif (!s)\n\t\treturn NULL;\n\taff = isl_stream_read_aff(s);\n\tisl_stream_free(s);\n\treturn aff;\n}\n\n__isl_give isl_pw_aff *isl_pw_aff_read_from_str(isl_ctx *ctx, const char *str)\n{\n\tisl_pw_aff *pa;\n\tisl_stream *s = isl_stream_new_str(ctx, str);\n\tif (!s)\n\t\treturn NULL;\n\tpa = isl_stream_read_pw_aff(s);\n\tisl_stream_free(s);\n\treturn pa;\n}\n\n/* Extract an isl_multi_pw_aff with domain space \"dom_space\"\n * from a tuple \"tuple\" read by read_tuple.\n *\n * Note that the function read_tuple accepts tuples where some output or\n * set dimensions are defined in terms of other output or set dimensions\n * since this function is also used to read maps.  As a special case,\n * read_tuple also accept dimensions that are defined in terms of themselves\n * (i.e., that are not defined).\n * These cases are not allowed when extracting an isl_multi_pw_aff so check\n * that the definitions of the output/set dimensions do not involve any\n * output/set dimensions.\n * Finally, drop the output dimensions from the domain of the result\n * of read_tuple (which is of the form [input, output] -> [output],\n * with anonymous domain) and reset the space.\n */\nstatic __isl_give isl_multi_pw_aff *extract_mpa_from_tuple(\n\t__isl_take isl_space *dom_space, __isl_keep isl_multi_pw_aff *tuple)\n{\n\tint i;\n\tisl_size dim, n;\n\tisl_space *space;\n\tisl_multi_pw_aff *mpa;\n\n\tn = isl_multi_pw_aff_dim(tuple, isl_dim_out);\n\tdim = isl_space_dim(dom_space, isl_dim_all);\n\tif (n < 0 || dim < 0)\n\t\tdom_space = isl_space_free(dom_space);\n\tspace = isl_space_range(isl_multi_pw_aff_get_space(tuple));\n\tspace = isl_space_align_params(space, isl_space_copy(dom_space));\n\tif (!isl_space_is_params(dom_space))\n\t\tspace = isl_space_map_from_domain_and_range(\n\t\t\t\tisl_space_copy(dom_space), space);\n\tisl_space_free(dom_space);\n\tmpa = isl_multi_pw_aff_alloc(space);\n\n\tfor (i = 0; i < n; ++i) {\n\t\tisl_pw_aff *pa;\n\t\tpa = isl_multi_pw_aff_get_pw_aff(tuple, i);\n\t\tif (!pa)\n\t\t\treturn isl_multi_pw_aff_free(mpa);\n\t\tif (isl_pw_aff_involves_dims(pa, isl_dim_in, dim, i + 1)) {\n\t\t\tisl_ctx *ctx = isl_pw_aff_get_ctx(pa);\n\t\t\tisl_pw_aff_free(pa);\n\t\t\tisl_die(ctx, isl_error_invalid,\n\t\t\t\t\"not an affine expression\",\n\t\t\t\treturn isl_multi_pw_aff_free(mpa));\n\t\t}\n\t\tpa = isl_pw_aff_drop_dims(pa, isl_dim_in, dim, n);\n\t\tspace = isl_multi_pw_aff_get_domain_space(mpa);\n\t\tpa = isl_pw_aff_reset_domain_space(pa, space);\n\t\tmpa = isl_multi_pw_aff_set_pw_aff(mpa, i, pa);\n\t}\n\n\treturn mpa;\n}\n\n/* Read a tuple of affine expressions, together with optional constraints\n * on the domain from \"s\".  \"dom\" represents the initial constraints\n * on the domain.\n *\n * The isl_multi_aff may live in either a set or a map space.\n * First read the first tuple and check if it is followed by a \"->\".\n * If so, convert the tuple into the domain of the isl_multi_pw_aff and\n * read in the next tuple.  This tuple (or the first tuple if it was\n * not followed by a \"->\") is then converted into an isl_multi_pw_aff\n * through a call to extract_mpa_from_tuple.\n * The result is converted to an isl_pw_multi_aff and\n * its domain is intersected with the domain.\n */\nstatic __isl_give isl_pw_multi_aff *read_conditional_multi_aff(\n\t__isl_keep isl_stream *s, __isl_take isl_set *dom, struct vars *v)\n{\n\tisl_multi_pw_aff *tuple;\n\tisl_multi_pw_aff *mpa;\n\tisl_pw_multi_aff *pma;\n\tint n = v->n;\n\n\ttuple = read_tuple(s, v, 0, 0);\n\tif (!tuple)\n\t\tgoto error;\n\tif (isl_stream_eat_if_available(s, ISL_TOKEN_TO)) {\n\t\tisl_map *map = map_from_tuple(tuple, dom, isl_dim_in, v, 0);\n\t\tdom = isl_map_domain(map);\n\t\ttuple = read_tuple(s, v, 0, 0);\n\t\tif (!tuple)\n\t\t\tgoto error;\n\t}\n\tmpa = extract_mpa_from_tuple(isl_set_get_space(dom), tuple);\n\tisl_multi_pw_aff_free(tuple);\n\tif (!mpa)\n\t\tdom = isl_set_free(dom);\n\n\tdom = read_optional_formula(s, dom, v, 0);\n\n\tvars_drop(v, v->n - n);\n\n\tpma = isl_pw_multi_aff_from_multi_pw_aff(mpa);\n\tpma = isl_pw_multi_aff_intersect_domain(pma, dom);\n\n\treturn pma;\nerror:\n\tisl_set_free(dom);\n\treturn NULL;\n}\n\n/* Read an isl_union_pw_multi_aff from \"s\".\n *\n * In particular, first read the parameters and then read a sequence\n * of zero or more tuples of affine expressions with optional conditions and\n * add them up.\n */\n__isl_give isl_union_pw_multi_aff *isl_stream_read_union_pw_multi_aff(\n\t__isl_keep isl_stream *s)\n{\n\tstruct vars *v;\n\tisl_set *dom;\n\tisl_union_pw_multi_aff *upma = NULL;\n\n\tv = vars_new(s->ctx);\n\tif (!v)\n\t\treturn NULL;\n\n\tdom = isl_set_universe(isl_space_params_alloc(s->ctx, 0));\n\tif (next_is_tuple(s)) {\n\t\tdom = read_map_tuple(s, dom, isl_dim_param, v, 1, 0);\n\t\tif (isl_stream_eat(s, ISL_TOKEN_TO))\n\t\t\tgoto error;\n\t}\n\tif (isl_stream_eat(s, '{'))\n\t\tgoto error;\n\n\tupma = isl_union_pw_multi_aff_empty(isl_set_get_space(dom));\n\n\tdo {\n\t\tisl_pw_multi_aff *pma;\n\t\tisl_union_pw_multi_aff *upma2;\n\n\t\tif (isl_stream_next_token_is(s, '}'))\n\t\t\tbreak;\n\n\t\tpma = read_conditional_multi_aff(s, isl_set_copy(dom), v);\n\t\tupma2 = isl_union_pw_multi_aff_from_pw_multi_aff(pma);\n\t\tupma = isl_union_pw_multi_aff_union_add(upma, upma2);\n\t\tif (!upma)\n\t\t\tgoto error;\n\t} while (isl_stream_eat_if_available(s, ';'));\n\n\tif (isl_stream_eat(s, '}'))\n\t\tgoto error;\n\n\tisl_set_free(dom);\n\tvars_free(v);\n\treturn upma;\nerror:\n\tisl_union_pw_multi_aff_free(upma);\n\tisl_set_free(dom);\n\tvars_free(v);\n\treturn NULL;\n}\n\n/* Read an isl_pw_multi_aff from \"s\".\n *\n * Read a more generic isl_union_pw_multi_aff first and\n * then check that the result lives in a single space.\n */\n__isl_give isl_pw_multi_aff *isl_stream_read_pw_multi_aff(\n\t__isl_keep isl_stream *s)\n{\n\tisl_bool single_space;\n\tisl_union_pw_multi_aff *upma;\n\n\tupma = isl_stream_read_union_pw_multi_aff(s);\n\tsingle_space = isl_union_pw_multi_aff_isa_pw_multi_aff(upma);\n\tif (single_space < 0)\n\t\tupma = isl_union_pw_multi_aff_free(upma);\n\telse if (!single_space)\n\t\tisl_die(s->ctx, isl_error_invalid,\n\t\t\t\"expecting expression in single space\",\n\t\t\tupma = isl_union_pw_multi_aff_free(upma));\n\treturn isl_union_pw_multi_aff_as_pw_multi_aff(upma);\n}\n\n__isl_give isl_pw_multi_aff *isl_pw_multi_aff_read_from_str(isl_ctx *ctx,\n\tconst char *str)\n{\n\tisl_pw_multi_aff *pma;\n\tisl_stream *s = isl_stream_new_str(ctx, str);\n\tif (!s)\n\t\treturn NULL;\n\tpma = isl_stream_read_pw_multi_aff(s);\n\tisl_stream_free(s);\n\treturn pma;\n}\n\n/* Read an isl_union_pw_multi_aff from \"str\".\n */\n__isl_give isl_union_pw_multi_aff *isl_union_pw_multi_aff_read_from_str(\n\tisl_ctx *ctx, const char *str)\n{\n\tisl_union_pw_multi_aff *upma;\n\tisl_stream *s = isl_stream_new_str(ctx, str);\n\tif (!s)\n\t\treturn NULL;\n\tupma = isl_stream_read_union_pw_multi_aff(s);\n\tisl_stream_free(s);\n\treturn upma;\n}\n\n/* Assuming \"pa\" represents a single affine expression defined on a universe\n * domain, extract this affine expression.\n */\nstatic __isl_give isl_aff *aff_from_pw_aff(__isl_take isl_pw_aff *pa)\n{\n\tisl_aff *aff;\n\n\tif (!pa)\n\t\treturn NULL;\n\tif (pa->n != 1)\n\t\tisl_die(isl_pw_aff_get_ctx(pa), isl_error_invalid,\n\t\t\t\"expecting single affine expression\",\n\t\t\tgoto error);\n\tif (!isl_set_plain_is_universe(pa->p[0].set))\n\t\tisl_die(isl_pw_aff_get_ctx(pa), isl_error_invalid,\n\t\t\t\"expecting universe domain\",\n\t\t\tgoto error);\n\n\taff = isl_aff_copy(pa->p[0].aff);\n\tisl_pw_aff_free(pa);\n\treturn aff;\nerror:\n\tisl_pw_aff_free(pa);\n\treturn NULL;\n}\n\n#undef BASE\n#define BASE val\n\n#include <isl_multi_read_no_explicit_domain_templ.c>\n\n#undef BASE\n#define BASE id\n\n#include <isl_multi_read_no_explicit_domain_templ.c>\n\n/* Read a multi-affine expression from \"s\".\n * If the multi-affine expression has a domain, then the tuple\n * representing this domain cannot involve any affine expressions.\n * The tuple representing the actual expressions needs to consist\n * of only affine expressions.  Moreover, these expressions can\n * only depend on parameters and input dimensions and not on other\n * output dimensions.\n */\n__isl_give isl_multi_aff *isl_stream_read_multi_aff(__isl_keep isl_stream *s)\n{\n\tstruct vars *v;\n\tisl_set *dom = NULL;\n\tisl_multi_pw_aff *tuple = NULL;\n\tint i;\n\tisl_size dim, n;\n\tisl_space *space, *dom_space;\n\tisl_multi_aff *ma = NULL;\n\n\tv = vars_new(s->ctx);\n\tif (!v)\n\t\treturn NULL;\n\n\tdom = isl_set_universe(isl_space_params_alloc(s->ctx, 0));\n\tif (next_is_tuple(s)) {\n\t\tdom = read_map_tuple(s, dom, isl_dim_param, v, 1, 0);\n\t\tif (isl_stream_eat(s, ISL_TOKEN_TO))\n\t\t\tgoto error;\n\t}\n\tif (!isl_set_plain_is_universe(dom))\n\t\tisl_die(s->ctx, isl_error_invalid,\n\t\t\t\"expecting universe parameter domain\", goto error);\n\tif (isl_stream_eat(s, '{'))\n\t\tgoto error;\n\n\ttuple = read_tuple(s, v, 0, 0);\n\tif (!tuple)\n\t\tgoto error;\n\tif (isl_stream_eat_if_available(s, ISL_TOKEN_TO)) {\n\t\tisl_set *set;\n\t\tisl_space *space;\n\t\tisl_bool has_expr;\n\n\t\thas_expr = tuple_has_expr(tuple);\n\t\tif (has_expr < 0)\n\t\t\tgoto error;\n\t\tif (has_expr)\n\t\t\tisl_die(s->ctx, isl_error_invalid,\n\t\t\t\t\"expecting universe domain\", goto error);\n\t\tspace = isl_space_range(isl_multi_pw_aff_get_space(tuple));\n\t\tset = isl_set_universe(space);\n\t\tdom = isl_set_intersect_params(set, dom);\n\t\tisl_multi_pw_aff_free(tuple);\n\t\ttuple = read_tuple(s, v, 0, 0);\n\t\tif (!tuple)\n\t\t\tgoto error;\n\t}\n\n\tif (isl_stream_eat(s, '}'))\n\t\tgoto error;\n\n\tn = isl_multi_pw_aff_dim(tuple, isl_dim_out);\n\tdim = isl_set_dim(dom, isl_dim_all);\n\tif (n < 0 || dim < 0)\n\t\tgoto error;\n\tdom_space = isl_set_get_space(dom);\n\tspace = isl_space_range(isl_multi_pw_aff_get_space(tuple));\n\tspace = isl_space_align_params(space, isl_space_copy(dom_space));\n\tif (!isl_space_is_params(dom_space))\n\t\tspace = isl_space_map_from_domain_and_range(\n\t\t\t\tisl_space_copy(dom_space), space);\n\tisl_space_free(dom_space);\n\tma = isl_multi_aff_alloc(space);\n\n\tfor (i = 0; i < n; ++i) {\n\t\tisl_pw_aff *pa;\n\t\tisl_aff *aff;\n\t\tpa = isl_multi_pw_aff_get_pw_aff(tuple, i);\n\t\taff = aff_from_pw_aff(pa);\n\t\tif (!aff)\n\t\t\tgoto error;\n\t\tif (isl_aff_involves_dims(aff, isl_dim_in, dim, i + 1)) {\n\t\t\tisl_aff_free(aff);\n\t\t\tisl_die(s->ctx, isl_error_invalid,\n\t\t\t\t\"not an affine expression\", goto error);\n\t\t}\n\t\taff = isl_aff_drop_dims(aff, isl_dim_in, dim, n);\n\t\tspace = isl_multi_aff_get_domain_space(ma);\n\t\taff = isl_aff_reset_domain_space(aff, space);\n\t\tma = isl_multi_aff_set_aff(ma, i, aff);\n\t}\n\n\tisl_multi_pw_aff_free(tuple);\n\tvars_free(v);\n\tisl_set_free(dom);\n\treturn ma;\nerror:\n\tisl_multi_pw_aff_free(tuple);\n\tvars_free(v);\n\tisl_set_free(dom);\n\tisl_multi_aff_free(ma);\n\treturn NULL;\n}\n\n__isl_give isl_multi_aff *isl_multi_aff_read_from_str(isl_ctx *ctx,\n\tconst char *str)\n{\n\tisl_multi_aff *maff;\n\tisl_stream *s = isl_stream_new_str(ctx, str);\n\tif (!s)\n\t\treturn NULL;\n\tmaff = isl_stream_read_multi_aff(s);\n\tisl_stream_free(s);\n\treturn maff;\n}\n\n/* Read an isl_multi_pw_aff from \"s\".\n *\n * The input format is similar to that of map, except that any conditions\n * on the domains should be specified inside the tuple since each\n * piecewise affine expression may have a different domain.\n * However, additional, shared conditions can also be specified.\n * This is especially useful for setting the explicit domain\n * of a zero-dimensional isl_multi_pw_aff.\n *\n * Since we do not know in advance if the isl_multi_pw_aff lives\n * in a set or a map space, we first read the first tuple and check\n * if it is followed by a \"->\".  If so, we convert the tuple into\n * the domain of the isl_multi_pw_aff and read in the next tuple.\n * This tuple (or the first tuple if it was not followed by a \"->\")\n * is then converted into the isl_multi_pw_aff through a call\n * to extract_mpa_from_tuple and the domain of the result\n * is intersected with the domain.\n */\n__isl_give isl_multi_pw_aff *isl_stream_read_multi_pw_aff(\n\t__isl_keep isl_stream *s)\n{\n\tstruct vars *v;\n\tisl_set *dom = NULL;\n\tisl_multi_pw_aff *tuple = NULL;\n\tisl_multi_pw_aff *mpa = NULL;\n\n\tv = vars_new(s->ctx);\n\tif (!v)\n\t\treturn NULL;\n\n\tdom = isl_set_universe(isl_space_params_alloc(s->ctx, 0));\n\tif (next_is_tuple(s)) {\n\t\tdom = read_map_tuple(s, dom, isl_dim_param, v, 1, 0);\n\t\tif (isl_stream_eat(s, ISL_TOKEN_TO))\n\t\t\tgoto error;\n\t}\n\tif (isl_stream_eat(s, '{'))\n\t\tgoto error;\n\n\ttuple = read_tuple(s, v, 0, 0);\n\tif (!tuple)\n\t\tgoto error;\n\tif (isl_stream_eat_if_available(s, ISL_TOKEN_TO)) {\n\t\tisl_map *map = map_from_tuple(tuple, dom, isl_dim_in, v, 0);\n\t\tdom = isl_map_domain(map);\n\t\ttuple = read_tuple(s, v, 0, 0);\n\t\tif (!tuple)\n\t\t\tgoto error;\n\t}\n\n\tif (isl_stream_eat_if_available(s, ':'))\n\t\tdom = read_formula(s, v, dom, 0);\n\n\tif (isl_stream_eat(s, '}'))\n\t\tgoto error;\n\n\tmpa = extract_mpa_from_tuple(isl_set_get_space(dom), tuple);\n\n\tisl_multi_pw_aff_free(tuple);\n\tvars_free(v);\n\tmpa = isl_multi_pw_aff_intersect_domain(mpa, dom);\n\treturn mpa;\nerror:\n\tisl_multi_pw_aff_free(tuple);\n\tvars_free(v);\n\tisl_set_free(dom);\n\tisl_multi_pw_aff_free(mpa);\n\treturn NULL;\n}\n\n/* Read an isl_multi_pw_aff from \"str\".\n */\n__isl_give isl_multi_pw_aff *isl_multi_pw_aff_read_from_str(isl_ctx *ctx,\n\tconst char *str)\n{\n\tisl_multi_pw_aff *mpa;\n\tisl_stream *s = isl_stream_new_str(ctx, str);\n\tif (!s)\n\t\treturn NULL;\n\tmpa = isl_stream_read_multi_pw_aff(s);\n\tisl_stream_free(s);\n\treturn mpa;\n}\n\n/* Read the body of an isl_union_pw_aff from \"s\" with parameter domain \"dom\".\n */\nstatic __isl_give isl_union_pw_aff *read_union_pw_aff_with_dom(\n\t__isl_keep isl_stream *s, __isl_take isl_set *dom, struct vars *v)\n{\n\tisl_pw_aff *pa;\n\tisl_union_pw_aff *upa = NULL;\n\tisl_set *aff_dom;\n\tint n;\n\n\tn = v->n;\n\taff_dom = read_aff_domain(s, isl_set_copy(dom), v);\n\tpa = read_pw_aff_with_dom(s, aff_dom, v);\n\tvars_drop(v, v->n - n);\n\n\tupa = isl_union_pw_aff_from_pw_aff(pa);\n\n\twhile (isl_stream_eat_if_available(s, ';')) {\n\t\tisl_pw_aff *pa_i;\n\t\tisl_union_pw_aff *upa_i;\n\n\t\tn = v->n;\n\t\taff_dom = read_aff_domain(s, isl_set_copy(dom), v);\n\t\tpa_i = read_pw_aff_with_dom(s, aff_dom, v);\n\t\tvars_drop(v, v->n - n);\n\n\t\tupa_i = isl_union_pw_aff_from_pw_aff(pa_i);\n\t\tupa = isl_union_pw_aff_union_add(upa, upa_i);\n\t}\n\n\tisl_set_free(dom);\n\treturn upa;\n}\n\n/* Read an isl_union_pw_aff from \"s\".\n *\n * First check if there are any paramters, then read in the opening brace\n * and use read_union_pw_aff_with_dom to read in the body of\n * the isl_union_pw_aff.  Finally, read the closing brace.\n */\n__isl_give isl_union_pw_aff *isl_stream_read_union_pw_aff(\n\t__isl_keep isl_stream *s)\n{\n\tstruct vars *v;\n\tisl_set *dom;\n\tisl_union_pw_aff *upa = NULL;\n\n\tv = vars_new(s->ctx);\n\tif (!v)\n\t\treturn NULL;\n\n\tdom = isl_set_universe(isl_space_params_alloc(s->ctx, 0));\n\tif (next_is_tuple(s)) {\n\t\tdom = read_map_tuple(s, dom, isl_dim_param, v, 1, 0);\n\t\tif (isl_stream_eat(s, ISL_TOKEN_TO))\n\t\t\tgoto error;\n\t}\n\tif (isl_stream_eat(s, '{'))\n\t\tgoto error;\n\n\tupa = read_union_pw_aff_with_dom(s, isl_set_copy(dom), v);\n\n\tif (isl_stream_eat(s, '}'))\n\t\tgoto error;\n\n\tvars_free(v);\n\tisl_set_free(dom);\n\treturn upa;\nerror:\n\tvars_free(v);\n\tisl_set_free(dom);\n\tisl_union_pw_aff_free(upa);\n\treturn NULL;\n}\n\n/* Read an isl_union_pw_aff from \"str\".\n */\n__isl_give isl_union_pw_aff *isl_union_pw_aff_read_from_str(isl_ctx *ctx,\n\tconst char *str)\n{\n\tisl_union_pw_aff *upa;\n\tisl_stream *s = isl_stream_new_str(ctx, str);\n\tif (!s)\n\t\treturn NULL;\n\tupa = isl_stream_read_union_pw_aff(s);\n\tisl_stream_free(s);\n\treturn upa;\n}\n\n/* This function is called for each element in a tuple inside\n * isl_stream_read_multi_union_pw_aff.\n *\n * Read a '{', the union piecewise affine expression body and a '}' and\n * add the isl_union_pw_aff to *list.\n */\nstatic __isl_give isl_space *read_union_pw_aff_el(__isl_keep isl_stream *s,\n\tstruct vars *v, __isl_take isl_space *space, int rational, void *user)\n{\n\tisl_set *dom;\n\tisl_union_pw_aff *upa;\n\tisl_union_pw_aff_list **list = (isl_union_pw_aff_list **) user;\n\n\tdom = isl_set_universe(isl_space_params(isl_space_copy(space)));\n\tif (isl_stream_eat(s, '{'))\n\t\tgoto error;\n\tupa = read_union_pw_aff_with_dom(s, dom, v);\n\t*list = isl_union_pw_aff_list_add(*list, upa);\n\tif (isl_stream_eat(s, '}'))\n\t\treturn isl_space_free(space);\n\tif (!*list)\n\t\treturn isl_space_free(space);\n\treturn space;\nerror:\n\tisl_set_free(dom);\n\treturn isl_space_free(space);\n}\n\n/* Do the next tokens in \"s\" correspond to an empty tuple?\n * In particular, does the stream start with a '[', followed by a ']',\n * not followed by a \"->\"?\n */\nstatic int next_is_empty_tuple(__isl_keep isl_stream *s)\n{\n\tstruct isl_token *tok, *tok2, *tok3;\n\tint is_empty_tuple = 0;\n\n\ttok = isl_stream_next_token(s);\n\tif (!tok)\n\t\treturn 0;\n\tif (tok->type != '[') {\n\t\tisl_stream_push_token(s, tok);\n\t\treturn 0;\n\t}\n\n\ttok2 = isl_stream_next_token(s);\n\tif (tok2 && tok2->type == ']') {\n\t\ttok3 = isl_stream_next_token(s);\n\t\tis_empty_tuple = !tok || tok->type != ISL_TOKEN_TO;\n\t\tif (tok3)\n\t\t\tisl_stream_push_token(s, tok3);\n\t}\n\tif (tok2)\n\t\tisl_stream_push_token(s, tok2);\n\tisl_stream_push_token(s, tok);\n\n\treturn is_empty_tuple;\n}\n\n/* Do the next tokens in \"s\" correspond to a tuple of parameters?\n * In particular, does the stream start with a '[' that is not\n * followed by a '{' or a nested tuple?\n */\nstatic int next_is_param_tuple(__isl_keep isl_stream *s)\n{\n\tstruct isl_token *tok, *tok2;\n\tint is_tuple;\n\n\ttok = isl_stream_next_token(s);\n\tif (!tok)\n\t\treturn 0;\n\tif (tok->type != '[' || next_is_tuple(s)) {\n\t\tisl_stream_push_token(s, tok);\n\t\treturn 0;\n\t}\n\n\ttok2 = isl_stream_next_token(s);\n\tis_tuple = tok2 && tok2->type != '{';\n\tif (tok2)\n\t\tisl_stream_push_token(s, tok2);\n\tisl_stream_push_token(s, tok);\n\n\treturn is_tuple;\n}\n\n/* Read the core of a body of an isl_multi_union_pw_aff from \"s\",\n * i.e., everything except the parameter specification and\n * without shared domain constraints.\n * \"v\" contains a description of the identifiers parsed so far.\n * The parameters, if any, are specified by \"space\".\n *\n * The body is of the form\n *\n *\t[{ [..] : ... ; [..] : ... }, { [..] : ... ; [..] : ... }]\n *\n * Read the tuple, collecting the individual isl_union_pw_aff\n * elements in a list and construct the result from the tuple space and\n * the list.\n */\nstatic __isl_give isl_multi_union_pw_aff *read_multi_union_pw_aff_body_core(\n\t__isl_keep isl_stream *s, struct vars *v, __isl_take isl_space *space)\n{\n\tisl_union_pw_aff_list *list;\n\tisl_multi_union_pw_aff *mupa;\n\n\tlist = isl_union_pw_aff_list_alloc(s->ctx, 0);\n\tspace = read_tuple_space(s, v, space, 1, 0,\n\t\t\t\t&read_union_pw_aff_el, &list);\n\tmupa = isl_multi_union_pw_aff_from_union_pw_aff_list(space, list);\n\n\treturn mupa;\n}\n\n/* Read the body of an isl_union_set from \"s\",\n * i.e., everything except the parameter specification.\n * \"v\" contains a description of the identifiers parsed so far.\n * The parameters, if any, are specified by \"space\".\n *\n * First read a generic disjunction of object bodies and then try and extract\n * an isl_union_set from that.\n */\nstatic __isl_give isl_union_set *read_union_set_body(__isl_keep isl_stream *s,\n\tstruct vars *v, __isl_take isl_space *space)\n{\n\tstruct isl_obj obj = { isl_obj_set, NULL };\n\tisl_map *map;\n\n\tmap = isl_set_universe(space);\n\tif (isl_stream_eat(s, '{') < 0)\n\t\tgoto error;\n\tobj = obj_read_disjuncts(s, v, map);\n\tif (isl_stream_eat(s, '}') < 0)\n\t\tgoto error;\n\tisl_map_free(map);\n\n\treturn extract_union_set(s->ctx, obj);\nerror:\n\tobj.type->free(obj.v);\n\tisl_map_free(map);\n\treturn NULL;\n}\n\n/* Read the body of an isl_multi_union_pw_aff from \"s\",\n * i.e., everything except the parameter specification.\n * \"v\" contains a description of the identifiers parsed so far.\n * The parameters, if any, are specified by \"space\".\n *\n * In particular, handle the special case with shared domain constraints.\n * These are specified as\n *\n *\t([...] : ...)\n *\n * and are especially useful for setting the explicit domain\n * of a zero-dimensional isl_multi_union_pw_aff.\n * The core isl_multi_union_pw_aff body ([...]) is read by\n * read_multi_union_pw_aff_body_core.\n */\nstatic __isl_give isl_multi_union_pw_aff *read_multi_union_pw_aff_body(\n\t__isl_keep isl_stream *s, struct vars *v, __isl_take isl_space *space)\n{\n\tisl_multi_union_pw_aff *mupa;\n\n\tif (!isl_stream_next_token_is(s, '('))\n\t\treturn read_multi_union_pw_aff_body_core(s, v, space);\n\n\tif (isl_stream_eat(s, '(') < 0)\n\t\tgoto error;\n\tmupa = read_multi_union_pw_aff_body_core(s, v, isl_space_copy(space));\n\tif (isl_stream_eat_if_available(s, ':')) {\n\t\tisl_union_set *dom;\n\n\t\tdom = read_union_set_body(s, v, space);\n\t\tmupa = isl_multi_union_pw_aff_intersect_domain(mupa, dom);\n\t} else {\n\t\tisl_space_free(space);\n\t}\n\tif (isl_stream_eat(s, ')') < 0)\n\t\treturn isl_multi_union_pw_aff_free(mupa);\n\n\treturn mupa;\nerror:\n\tisl_space_free(space);\n\treturn NULL;\n}\n\n/* Read an isl_multi_union_pw_aff from \"s\".\n *\n * The input has the form\n *\n *\t[{ [..] : ... ; [..] : ... }, { [..] : ... ; [..] : ... }]\n *\n * or\n *\n *\t[..] -> [{ [..] : ... ; [..] : ... }, { [..] : ... ; [..] : ... }]\n *\n * Additionally, a shared domain may be specified as\n *\n *\t([..] : ...)\n *\n * or\n *\n *\t[..] -> ([..] : ...)\n *\n * The first case is handled by the caller, the second case\n * is handled by read_multi_union_pw_aff_body.\n *\n * We first check for the special case of an empty tuple \"[]\".\n * Then we check if there are any parameters.\n * Finally, read the tuple and construct the result.\n */\nstatic __isl_give isl_multi_union_pw_aff *read_multi_union_pw_aff_core(\n\t__isl_keep isl_stream *s)\n{\n\tstruct vars *v;\n\tisl_set *dom = NULL;\n\tisl_space *space;\n\tisl_multi_union_pw_aff *mupa = NULL;\n\n\tif (next_is_empty_tuple(s)) {\n\t\tif (isl_stream_eat(s, '['))\n\t\t\treturn NULL;\n\t\tif (isl_stream_eat(s, ']'))\n\t\t\treturn NULL;\n\t\tspace = isl_space_set_alloc(s->ctx, 0, 0);\n\t\treturn isl_multi_union_pw_aff_zero(space);\n\t}\n\n\tv = vars_new(s->ctx);\n\tif (!v)\n\t\treturn NULL;\n\n\tdom = isl_set_universe(isl_space_params_alloc(s->ctx, 0));\n\tif (next_is_param_tuple(s)) {\n\t\tdom = read_map_tuple(s, dom, isl_dim_param, v, 1, 0);\n\t\tif (isl_stream_eat(s, ISL_TOKEN_TO))\n\t\t\tgoto error;\n\t}\n\tspace = isl_set_get_space(dom);\n\tisl_set_free(dom);\n\tmupa = read_multi_union_pw_aff_body(s, v, space);\n\n\tvars_free(v);\n\n\treturn mupa;\nerror:\n\tvars_free(v);\n\tisl_set_free(dom);\n\tisl_multi_union_pw_aff_free(mupa);\n\treturn NULL;\n}\n\n/* Read an isl_multi_union_pw_aff from \"s\".\n *\n * In particular, handle the special case with shared domain constraints.\n * These are specified as\n *\n *\t([...] : ...)\n *\n * and are especially useful for setting the explicit domain\n * of a zero-dimensional isl_multi_union_pw_aff.\n * The core isl_multi_union_pw_aff ([...]) is read by\n * read_multi_union_pw_aff_core.\n */\n__isl_give isl_multi_union_pw_aff *isl_stream_read_multi_union_pw_aff(\n\t__isl_keep isl_stream *s)\n{\n\tisl_multi_union_pw_aff *mupa;\n\n\tif (!isl_stream_next_token_is(s, '('))\n\t\treturn read_multi_union_pw_aff_core(s);\n\n\tif (isl_stream_eat(s, '(') < 0)\n\t\treturn NULL;\n\tmupa = read_multi_union_pw_aff_core(s);\n\tif (isl_stream_eat_if_available(s, ':')) {\n\t\tisl_union_set *dom;\n\n\t\tdom = isl_stream_read_union_set(s);\n\t\tmupa = isl_multi_union_pw_aff_intersect_domain(mupa, dom);\n\t}\n\tif (isl_stream_eat(s, ')') < 0)\n\t\treturn isl_multi_union_pw_aff_free(mupa);\n\treturn mupa;\n}\n\n/* Read an isl_multi_union_pw_aff from \"str\".\n */\n__isl_give isl_multi_union_pw_aff *isl_multi_union_pw_aff_read_from_str(\n\tisl_ctx *ctx, const char *str)\n{\n\tisl_multi_union_pw_aff *mupa;\n\tisl_stream *s = isl_stream_new_str(ctx, str);\n\tif (!s)\n\t\treturn NULL;\n\tmupa = isl_stream_read_multi_union_pw_aff(s);\n\tisl_stream_free(s);\n\treturn mupa;\n}\n\n__isl_give isl_union_pw_qpolynomial *isl_stream_read_union_pw_qpolynomial(\n\t__isl_keep isl_stream *s)\n{\n\tstruct isl_obj obj;\n\n\tobj = obj_read(s);\n\tif (obj.type == isl_obj_pw_qpolynomial) {\n\t\tobj.type = isl_obj_union_pw_qpolynomial;\n\t\tobj.v = isl_union_pw_qpolynomial_from_pw_qpolynomial(obj.v);\n\t}\n\tif (obj.v)\n\t\tisl_assert(s->ctx, obj.type == isl_obj_union_pw_qpolynomial,\n\t\t\t   goto error);\n\n\treturn obj.v;\nerror:\n\tobj.type->free(obj.v);\n\treturn NULL;\n}\n\n__isl_give isl_union_pw_qpolynomial *isl_union_pw_qpolynomial_read_from_str(\n\tisl_ctx *ctx, const char *str)\n{\n\tisl_union_pw_qpolynomial *upwqp;\n\tisl_stream *s = isl_stream_new_str(ctx, str);\n\tif (!s)\n\t\treturn NULL;\n\tupwqp = isl_stream_read_union_pw_qpolynomial(s);\n\tisl_stream_free(s);\n\treturn upwqp;\n}\n"}, "12": {"id": 12, "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_int.h", "content": "/*\n * Copyright 2008-2009 Katholieke Universiteit Leuven\n *\n * Use of this software is governed by the MIT license\n *\n * Written by Sven Verdoolaege, K.U.Leuven, Departement\n * Computerwetenschappen, Celestijnenlaan 200A, B-3001 Leuven, Belgium\n */\n\n#ifndef ISL_INT_H\n#define ISL_INT_H\n#define ISL_DEPRECATED_INT_H\n\n#include <isl/hash.h>\n#include <isl/printer.h>\n#include <string.h>\n#include <isl_config.h>\n\n#ifdef USE_GMP_FOR_MP\n#include <isl_int_gmp.h>\n#endif\n\n#ifdef USE_IMATH_FOR_MP\n#ifdef USE_SMALL_INT_OPT\n#include <isl_int_sioimath.h>\n#else /* USE_SMALL_INT_OPT */\n#include <isl_int_imath.h>\n#endif /* USE_SMALL_INT_OPT */\n#endif /* USE_IMATH_FOR_MP */\n\n#define isl_int_is_zero(i)\t(isl_int_sgn(i) == 0)\n#define isl_int_is_one(i)\t(isl_int_cmp_si(i,1) == 0)\n#define isl_int_is_negone(i)\t(isl_int_cmp_si(i,-1) == 0)\n#define isl_int_is_pos(i)\t(isl_int_sgn(i) > 0)\n#define isl_int_is_neg(i)\t(isl_int_sgn(i) < 0)\n#define isl_int_is_nonpos(i)\t(isl_int_sgn(i) <= 0)\n#define isl_int_is_nonneg(i)\t(isl_int_sgn(i) >= 0)\n\n#ifndef USE_SMALL_INT_OPT\n#define isl_int_print(out,i,width)\t\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\t\\\n\t\tchar *s;\t\t\t\t\t\t\\\n\t\ts = isl_int_get_str(i);\t\t\t\t\t\\\n\t\tfprintf(out, \"%*s\", width, s);\t\t\t\t\\\n\t\tisl_int_free_str(s);                                        \\\n\t} while (0)\n#endif /* USE_SMALL_INT_OPT */\n\n__isl_give isl_printer *isl_printer_print_isl_int(__isl_take isl_printer *p,\n\tisl_int i);\n\n#endif /* ISL_INT_H */\n"}, "13": {"id": 13, "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_int_sioimath.h", "content": "/*\n * Copyright 2015 INRIA Paris-Rocquencourt\n *\n * Use of this software is governed by the MIT license\n *\n * Written by Michael Kruse, INRIA Paris-Rocquencourt,\n * Domaine de Voluceau, Rocquenqourt, B.P. 105,\n * 78153 Le Chesnay Cedex France\n */\n#ifndef ISL_INT_SIOIMATH_H\n#define ISL_INT_SIOIMATH_H\n\n#include <inttypes.h>\n#include <limits.h>\n#include <stdint.h>\n#include <stdlib.h>\n\n#include <isl_imath.h>\n#include <isl/hash.h>\n\n#define ARRAY_SIZE(array) (sizeof(array)/sizeof(*array))\n\n/* Visual Studio before VS2015 does not support the inline keyword when\n * compiling in C mode because it was introduced in C99 which it does not\n * officially support.  Instead, it has a proprietary extension using __inline.\n */\n#if defined(_MSC_VER) && (_MSC_VER < 1900)\n#define inline __inline\n#endif\n\n/* The type to represent integers optimized for small values. It is either a\n * pointer to an mp_int ( = mpz_t*; big representation) or an int32_t (small\n * represenation) with a discriminator at the least significant bit. In big\n * representation it will be always zero because of heap alignment. It is set\n * to 1 for small representation and use the 32 most significant bits for the\n * int32_t.\n *\n * Structure on 64 bit machines, with 8-byte aligment (3 bits):\n *\n * Big representation:\n * MSB                                                          LSB\n * |------------------------------------------------------------000\n * |                            mpz_t*                            |\n * |                           != NULL                            |\n *\n * Small representation:\n * MSB                           32                             LSB\n * |------------------------------|00000000000000000000000000000001\n * |          int32_t             |\n * |  2147483647 ... -2147483647  |\n *                                                                ^\n *                                                                |\n *                                                        discriminator bit\n *\n * On 32 bit machines isl_sioimath type is blown up to 8 bytes, i.e.\n * isl_sioimath is guaranteed to be at least 8 bytes. This is to ensure the\n * int32_t can be hidden in that type without data loss. In the future we might\n * optimize this to use 31 hidden bits in a 32 bit pointer. We may also use 63\n * bits on 64 bit machines, but this comes with the cost of additional overflow\n * checks because there is no standardized 128 bit integer we could expand to.\n *\n * We use native integer types and avoid union structures to avoid assumptions\n * on the machine's endianness.\n *\n * This implementation makes the following assumptions:\n * - long can represent any int32_t\n * - mp_small is signed long\n * - mp_usmall is unsigned long\n * - adresses returned by malloc are aligned to 2-byte boundaries (leastmost\n *   bit is zero)\n */\n#if UINT64_MAX > UINTPTR_MAX\ntypedef uint64_t isl_sioimath;\n#else\ntypedef uintptr_t isl_sioimath;\n#endif\n\n/* The negation of the smallest possible number in int32_t, INT32_MIN\n * (0x80000000u, -2147483648), cannot be represented in an int32_t, therefore\n * every operation that may produce this value needs to special-case it.\n * The operations are:\n * abs(INT32_MIN)\n * -INT32_MIN   (negation)\n * -1 * INT32_MIN (multiplication)\n * INT32_MIN/-1 (any division: divexact, fdiv, cdiv, tdiv)\n * To avoid checking these cases, we exclude INT32_MIN from small\n * representation.\n */\n#define ISL_SIOIMATH_SMALL_MIN (-INT32_MAX)\n\n/* Largest possible number in small representation */\n#define ISL_SIOIMATH_SMALL_MAX INT32_MAX\n\n/* Used for function parameters the function modifies. */\ntypedef isl_sioimath *isl_sioimath_ptr;\n\n/* Used for function parameters that are read-only. */\ntypedef isl_sioimath isl_sioimath_src;\n\n/* Return whether the argument is stored in small representation.\n */\ninline int isl_sioimath_is_small(isl_sioimath val)\n{\n\treturn val & 0x00000001;\n}\n\n/* Return whether the argument is stored in big representation.\n */\ninline int isl_sioimath_is_big(isl_sioimath val)\n{\n\treturn !isl_sioimath_is_small(val);\n}\n\n/* Get the number of an isl_int in small representation. Result is undefined if\n * val is not stored in that format.\n */\ninline int32_t isl_sioimath_get_small(isl_sioimath val)\n{\n\treturn val >> 32;\n}\n\n/* Get the number of an in isl_int in big representation. Result is undefined if\n * val is not stored in that format.\n */\ninline mp_int isl_sioimath_get_big(isl_sioimath val)\n{\n\treturn (mp_int)(uintptr_t) val;\n}\n\n/* Return 1 if val is stored in small representation and store its value to\n * small. We rely on the compiler to optimize the isl_sioimath_get_small such\n * that the shift is moved into the branch that executes in case of small\n * representation. If there is no such branch, then a single shift is still\n * cheaper than introducing branching code.\n */\ninline int isl_sioimath_decode_small(isl_sioimath val, int32_t *small)\n{\n\t*small = isl_sioimath_get_small(val);\n\treturn isl_sioimath_is_small(val);\n}\n\n/* Return 1 if val is stored in big representation and store its value to big.\n */\ninline int isl_sioimath_decode_big(isl_sioimath val, mp_int *big)\n{\n\t*big = isl_sioimath_get_big(val);\n\treturn isl_sioimath_is_big(val);\n}\n\n/* Encode a small representation into an isl_int.\n */\ninline isl_sioimath isl_sioimath_encode_small(int32_t val)\n{\n\treturn ((isl_sioimath) val) << 32 | 0x00000001;\n}\n\n/* Encode a big representation.\n */\ninline isl_sioimath isl_sioimath_encode_big(mp_int val)\n{\n\treturn (isl_sioimath)(uintptr_t) val;\n}\n\n/* A common situation is to call an IMath function with at least one argument\n * that is currently in small representation or an integer parameter, i.e. a big\n * representation of the same number is required. Promoting the original\n * argument comes with multiple problems, such as modifying a read-only\n * argument, the responsibility of deallocation and the execution cost. Instead,\n * we make a copy by 'faking' the IMath internal structure.\n *\n * We reserve the maximum number of required digits on the stack to avoid heap\n * allocations.\n *\n * mp_digit can be uint32_t or uint16_t. This code must work for little and big\n * endian digits. The structure for an uint64_t argument and 32-bit mp_digits is\n * sketched below.\n *\n * |----------------------------|\n *            uint64_t\n *\n * |-------------||-------------|\n *    mp_digit        mp_digit\n *    digits[1]       digits[0]\n * Most sig digit  Least sig digit\n */\ntypedef struct {\n\tmpz_t big;\n\tmp_digit digits[(sizeof(uintmax_t) + sizeof(mp_digit) - 1) /\n\t                sizeof(mp_digit)];\n} isl_sioimath_scratchspace_t;\n\n/* Convert a native integer to IMath's digit representation. A native integer\n * might be big- or little endian, but IMath always stores the least significant\n * digit in the lowest array indices.  memcpy therefore is not possible.\n *\n * We also have to consider that long and mp_digit can be of different sizes,\n * depending on the compiler (LP64, LLP64) and IMath's USE_64BIT_WORDS. This\n * macro should work for all of them.\n *\n * \"used\" is set to the number of written digits. It must be minimal (IMath\n * checks zeroness using the used field), but always at least one.  Also note\n * that the result of num>>(sizeof(num)*CHAR_BIT) is undefined.\n */\n#define ISL_SIOIMATH_TO_DIGITS(num, digits, used)                              \\\n\tdo {                                                                   \\\n\t\tint i = 0;                                                     \\\n\t\tdo {                                                           \\\n\t\t\t(digits)[i] =                                          \\\n\t\t\t    ((num) >> (sizeof(mp_digit) * CHAR_BIT * i));      \\\n\t\t\ti += 1;                                                \\\n\t\t\tif (i >= (sizeof(num) + sizeof(mp_digit) - 1) /        \\\n\t\t\t             sizeof(mp_digit))                         \\\n\t\t\t\tbreak;                                         \\\n\t\t\tif (((num) >> (sizeof(mp_digit) * CHAR_BIT * i)) == 0) \\\n\t\t\t\tbreak;                                         \\\n\t\t} while (1);                                                   \\\n\t\t(used) = i;                                                    \\\n\t} while (0)\n\ninline void isl_siomath_uint32_to_digits(uint32_t num, mp_digit *digits,\n\tmp_size *used)\n{\n\tISL_SIOIMATH_TO_DIGITS(num, digits, *used);\n}\n\ninline void isl_siomath_ulong_to_digits(unsigned long num, mp_digit *digits,\n\tmp_size *used)\n{\n\tISL_SIOIMATH_TO_DIGITS(num, digits, *used);\n}\n\ninline void isl_siomath_uint64_to_digits(uint64_t num, mp_digit *digits,\n\tmp_size *used)\n{\n\tISL_SIOIMATH_TO_DIGITS(num, digits, *used);\n}\n\n/* Get the IMath representation of an isl_int without modifying it.\n * For the case it is not in big representation yet, pass some scratch space we\n * can use to store the big representation in.\n * In order to avoid requiring init and free on the scratch space, we directly\n * modify the internal representation.\n *\n * The name derives from its indented use: getting the big representation of an\n * input (src) argument.\n */\ninline mp_int isl_sioimath_bigarg_src(isl_sioimath arg,\n\tisl_sioimath_scratchspace_t *scratch)\n{\n\tmp_int big;\n\tint32_t small;\n\tuint32_t num;\n\n\tif (isl_sioimath_decode_big(arg, &big))\n\t\treturn big;\n\n\tsmall = isl_sioimath_get_small(arg);\n\tscratch->big.digits = scratch->digits;\n\tscratch->big.alloc = ARRAY_SIZE(scratch->digits);\n\tif (small >= 0) {\n\t\tscratch->big.sign = MP_ZPOS;\n\t\tnum = small;\n\t} else {\n\t\tscratch->big.sign = MP_NEG;\n\t\tnum = -small;\n\t}\n\n\tisl_siomath_uint32_to_digits(num, scratch->digits, &scratch->big.used);\n\treturn &scratch->big;\n}\n\n/* Create a temporary IMath mp_int for a signed long.\n */\ninline mp_int isl_sioimath_siarg_src(signed long arg,\n\tisl_sioimath_scratchspace_t *scratch)\n{\n\tunsigned long num;\n\n\tscratch->big.digits = scratch->digits;\n\tscratch->big.alloc = ARRAY_SIZE(scratch->digits);\n\tif (arg >= 0) {\n\t\tscratch->big.sign = MP_ZPOS;\n\t\tnum = arg;\n\t} else {\n\t\tscratch->big.sign = MP_NEG;\n\t\tnum = (arg == LONG_MIN) ? ((unsigned long) LONG_MAX) + 1 : -arg;\n\t}\n\n\tisl_siomath_ulong_to_digits(num, scratch->digits, &scratch->big.used);\n\treturn &scratch->big;\n}\n\n/* Create a temporary IMath mp_int for an int64_t.\n */\ninline mp_int isl_sioimath_si64arg_src(int64_t arg,\n\tisl_sioimath_scratchspace_t *scratch)\n{\n\tuint64_t num;\n\n\tscratch->big.digits = scratch->digits;\n\tscratch->big.alloc = ARRAY_SIZE(scratch->digits);\n\tif (arg >= 0) {\n\t\tscratch->big.sign = MP_ZPOS;\n\t\tnum = arg;\n\t} else {\n\t\tscratch->big.sign = MP_NEG;\n\t\tnum = (arg == INT64_MIN) ? ((uint64_t) INT64_MAX) + 1 : -arg;\n\t}\n\n\tisl_siomath_uint64_to_digits(num, scratch->digits, &scratch->big.used);\n\treturn &scratch->big;\n}\n\n/* Create a temporary IMath mp_int for an unsigned long.\n */\ninline mp_int isl_sioimath_uiarg_src(unsigned long arg,\n\tisl_sioimath_scratchspace_t *scratch)\n{\n\tscratch->big.digits = scratch->digits;\n\tscratch->big.alloc = ARRAY_SIZE(scratch->digits);\n\tscratch->big.sign = MP_ZPOS;\n\n\tisl_siomath_ulong_to_digits(arg, scratch->digits, &scratch->big.used);\n\treturn &scratch->big;\n}\n\n/* Ensure big representation. Does not preserve the current number.\n * Callers may use the fact that the value _is_ preserved if the presentation\n * was big before.\n */\ninline mp_int isl_sioimath_reinit_big(isl_sioimath_ptr ptr)\n{\n\tif (isl_sioimath_is_small(*ptr))\n\t\t*ptr = isl_sioimath_encode_big(mp_int_alloc());\n\treturn isl_sioimath_get_big(*ptr);\n}\n\n/* Set ptr to a number in small representation.\n */\ninline void isl_sioimath_set_small(isl_sioimath_ptr ptr, int32_t val)\n{\n\tif (isl_sioimath_is_big(*ptr))\n\t\tmp_int_free(isl_sioimath_get_big(*ptr));\n\t*ptr = isl_sioimath_encode_small(val);\n}\n\n/* Set ptr to val, choosing small representation if possible.\n */\ninline void isl_sioimath_set_int32(isl_sioimath_ptr ptr, int32_t val)\n{\n\tif (ISL_SIOIMATH_SMALL_MIN <= val && val <= ISL_SIOIMATH_SMALL_MAX) {\n\t\tisl_sioimath_set_small(ptr, val);\n\t\treturn;\n\t}\n\n\tmp_int_init_value(isl_sioimath_reinit_big(ptr), val);\n}\n\n/* Assign an int64_t number using small representation if possible.\n */\ninline void isl_sioimath_set_int64(isl_sioimath_ptr ptr, int64_t val)\n{\n\tif (ISL_SIOIMATH_SMALL_MIN <= val && val <= ISL_SIOIMATH_SMALL_MAX) {\n\t\tisl_sioimath_set_small(ptr, val);\n\t\treturn;\n\t}\n\n\tisl_sioimath_scratchspace_t scratch;\n\tmp_int_copy(isl_sioimath_si64arg_src(val, &scratch),\n\t    isl_sioimath_reinit_big(ptr));\n}\n\n/* Convert to big representation while preserving the current number.\n */\ninline void isl_sioimath_promote(isl_sioimath_ptr dst)\n{\n\tint32_t small;\n\n\tif (isl_sioimath_is_big(*dst))\n\t\treturn;\n\n\tsmall = isl_sioimath_get_small(*dst);\n\tmp_int_set_value(isl_sioimath_reinit_big(dst), small);\n}\n\n/* Convert to small representation while preserving the current number. Does\n * nothing if dst doesn't fit small representation.\n */\ninline void isl_sioimath_try_demote(isl_sioimath_ptr dst)\n{\n\tmp_small small;\n\n\tif (isl_sioimath_is_small(*dst))\n\t\treturn;\n\n\tif (mp_int_to_int(isl_sioimath_get_big(*dst), &small) != MP_OK)\n\t\treturn;\n\n\tif (ISL_SIOIMATH_SMALL_MIN <= small && small <= ISL_SIOIMATH_SMALL_MAX)\n\t\tisl_sioimath_set_small(dst, small);\n}\n\n/* Initialize an isl_int. The implicit value is 0 in small representation.\n */\ninline void isl_sioimath_init(isl_sioimath_ptr dst)\n{\n\t*dst = isl_sioimath_encode_small(0);\n}\n\n/* Free the resources taken by an isl_int.\n */\ninline void isl_sioimath_clear(isl_sioimath_ptr dst)\n{\n\tif (isl_sioimath_is_small(*dst))\n\t\treturn;\n\n\tmp_int_free(isl_sioimath_get_big(*dst));\n}\n\n/* Copy the value of one isl_int to another.\n */\ninline void isl_sioimath_set(isl_sioimath_ptr dst, isl_sioimath_src val)\n{\n\tif (isl_sioimath_is_small(val)) {\n\t\tisl_sioimath_set_small(dst, isl_sioimath_get_small(val));\n\t\treturn;\n\t}\n\n\tmp_int_copy(isl_sioimath_get_big(val), isl_sioimath_reinit_big(dst));\n}\n\n/* Store a signed long into an isl_int.\n */\ninline void isl_sioimath_set_si(isl_sioimath_ptr dst, long val)\n{\n\tif (ISL_SIOIMATH_SMALL_MIN <= val && val <= ISL_SIOIMATH_SMALL_MAX) {\n\t\tisl_sioimath_set_small(dst, val);\n\t\treturn;\n\t}\n\n\tmp_int_set_value(isl_sioimath_reinit_big(dst), val);\n}\n\n/* Store an unsigned long into an isl_int.\n */\ninline void isl_sioimath_set_ui(isl_sioimath_ptr dst, unsigned long val)\n{\n\tif (val <= ISL_SIOIMATH_SMALL_MAX) {\n\t\tisl_sioimath_set_small(dst, val);\n\t\treturn;\n\t}\n\n\tmp_int_set_uvalue(isl_sioimath_reinit_big(dst), val);\n}\n\n/* Return whether a number can be represented by a signed long.\n */\ninline int isl_sioimath_fits_slong(isl_sioimath_src val)\n{\n\tmp_small dummy;\n\n\tif (isl_sioimath_is_small(val))\n\t\treturn 1;\n\n\treturn mp_int_to_int(isl_sioimath_get_big(val), &dummy) == MP_OK;\n}\n\n/* Return a number as signed long. Result is undefined if the number cannot be\n * represented as long.\n */\ninline long isl_sioimath_get_si(isl_sioimath_src val)\n{\n\tmp_small result;\n\n\tif (isl_sioimath_is_small(val))\n\t\treturn isl_sioimath_get_small(val);\n\n\tmp_int_to_int(isl_sioimath_get_big(val), &result);\n\treturn result;\n}\n\n/* Return whether a number can be represented as unsigned long.\n */\ninline int isl_sioimath_fits_ulong(isl_sioimath_src val)\n{\n\tmp_usmall dummy;\n\n\tif (isl_sioimath_is_small(val))\n\t\treturn isl_sioimath_get_small(val) >= 0;\n\n\treturn mp_int_to_uint(isl_sioimath_get_big(val), &dummy) == MP_OK;\n}\n\n/* Return a number as unsigned long. Result is undefined if the number cannot be\n * represented as unsigned long.\n */\ninline unsigned long isl_sioimath_get_ui(isl_sioimath_src val)\n{\n\tmp_usmall result;\n\n\tif (isl_sioimath_is_small(val))\n\t\treturn isl_sioimath_get_small(val);\n\n\tmp_int_to_uint(isl_sioimath_get_big(val), &result);\n\treturn result;\n}\n\n/* Return a number as floating point value.\n */\ninline double isl_sioimath_get_d(isl_sioimath_src val)\n{\n\tmp_int big;\n\tdouble result = 0;\n\tint i;\n\n\tif (isl_sioimath_is_small(val))\n\t\treturn isl_sioimath_get_small(val);\n\n\tbig = isl_sioimath_get_big(val);\n\tfor (i = 0; i < big->used; ++i)\n\t\tresult = result * (double) ((uintmax_t) MP_DIGIT_MAX + 1) +\n\t\t         (double) big->digits[i];\n\n\tif (big->sign == MP_NEG)\n\t\tresult = -result;\n\n\treturn result;\n}\n\n/* Format a number as decimal string.\n *\n * The largest possible string from small representation is 12 characters\n * (\"-2147483647\").\n */\ninline char *isl_sioimath_get_str(isl_sioimath_src val)\n{\n\tchar *result;\n\n\tif (isl_sioimath_is_small(val)) {\n\t\tresult = malloc(12);\n\t\tsnprintf(result, 12, \"%\" PRIi32, isl_sioimath_get_small(val));\n\t\treturn result;\n\t}\n\n\treturn impz_get_str(NULL, 10, isl_sioimath_get_big(val));\n}\n\n/* Return the absolute value.\n */\ninline void isl_sioimath_abs(isl_sioimath_ptr dst, isl_sioimath_src arg)\n{\n\tif (isl_sioimath_is_small(arg)) {\n\t\tisl_sioimath_set_small(dst, labs(isl_sioimath_get_small(arg)));\n\t\treturn;\n\t}\n\n\tmp_int_abs(isl_sioimath_get_big(arg), isl_sioimath_reinit_big(dst));\n}\n\n/* Return the negation of a number.\n */\ninline void isl_sioimath_neg(isl_sioimath_ptr dst, isl_sioimath_src arg)\n{\n\tif (isl_sioimath_is_small(arg)) {\n\t\tisl_sioimath_set_small(dst, -isl_sioimath_get_small(arg));\n\t\treturn;\n\t}\n\n\tmp_int_neg(isl_sioimath_get_big(arg), isl_sioimath_reinit_big(dst));\n}\n\n/* Swap two isl_ints.\n *\n * isl_sioimath can be copied bytewise; nothing depends on its address. It can\n * also be stored in a CPU register.\n */\ninline void isl_sioimath_swap(isl_sioimath_ptr lhs, isl_sioimath_ptr rhs)\n{\n\tisl_sioimath tmp = *lhs;\n\t*lhs = *rhs;\n\t*rhs = tmp;\n}\n\n/* Add an unsigned long to the number.\n *\n * On LP64 unsigned long exceeds the range of an int64_t, therefore we check in\n * advance whether small representation possibly overflows.\n */\ninline void isl_sioimath_add_ui(isl_sioimath_ptr dst, isl_sioimath lhs,\n\tunsigned long rhs)\n{\n\tint32_t smalllhs;\n\tisl_sioimath_scratchspace_t lhsscratch;\n\n\tif (isl_sioimath_decode_small(lhs, &smalllhs) &&\n\t    (rhs <= (uint64_t) INT64_MAX - (uint64_t) ISL_SIOIMATH_SMALL_MAX)) {\n\t\tisl_sioimath_set_int64(dst, (int64_t) smalllhs + rhs);\n\t\treturn;\n\t}\n\n\timpz_add_ui(isl_sioimath_reinit_big(dst),\n\t    isl_sioimath_bigarg_src(lhs, &lhsscratch), rhs);\n\tisl_sioimath_try_demote(dst);\n}\n\n/* Subtract an unsigned long.\n *\n * On LP64 unsigned long exceeds the range of an int64_t.  If\n * ISL_SIOIMATH_SMALL_MIN-rhs>=INT64_MIN we can do the calculation using int64_t\n * without risking an overflow.\n */\ninline void isl_sioimath_sub_ui(isl_sioimath_ptr dst, isl_sioimath lhs,\n\t\t\t\tunsigned long rhs)\n{\n\tint32_t smalllhs;\n\tisl_sioimath_scratchspace_t lhsscratch;\n\n\tif (isl_sioimath_decode_small(lhs, &smalllhs) &&\n\t    (rhs < (uint64_t) INT64_MIN - (uint64_t) ISL_SIOIMATH_SMALL_MIN)) {\n\t\tisl_sioimath_set_int64(dst, (int64_t) smalllhs - rhs);\n\t\treturn;\n\t}\n\n\timpz_sub_ui(isl_sioimath_reinit_big(dst),\n\t    isl_sioimath_bigarg_src(lhs, &lhsscratch), rhs);\n\tisl_sioimath_try_demote(dst);\n}\n\n/* Sum of two isl_ints.\n */\ninline void isl_sioimath_add(isl_sioimath_ptr dst, isl_sioimath_src lhs,\n\tisl_sioimath_src rhs)\n{\n\tisl_sioimath_scratchspace_t scratchlhs, scratchrhs;\n\tint32_t smalllhs, smallrhs;\n\n\tif (isl_sioimath_decode_small(lhs, &smalllhs) &&\n\t    isl_sioimath_decode_small(rhs, &smallrhs)) {\n\t\tisl_sioimath_set_int64(\n\t\t    dst, (int64_t) smalllhs + (int64_t) smallrhs);\n\t\treturn;\n\t}\n\n\tmp_int_add(isl_sioimath_bigarg_src(lhs, &scratchlhs),\n\t    isl_sioimath_bigarg_src(rhs, &scratchrhs),\n\t    isl_sioimath_reinit_big(dst));\n\tisl_sioimath_try_demote(dst);\n}\n\n/* Subtract two isl_ints.\n */\ninline void isl_sioimath_sub(isl_sioimath_ptr dst, isl_sioimath_src lhs,\n\tisl_sioimath_src rhs)\n{\n\tisl_sioimath_scratchspace_t scratchlhs, scratchrhs;\n\tint32_t smalllhs, smallrhs;\n\n\tif (isl_sioimath_decode_small(lhs, &smalllhs) &&\n\t    isl_sioimath_decode_small(rhs, &smallrhs)) {\n\t\tisl_sioimath_set_int64(\n\t\t    dst, (int64_t) smalllhs - (int64_t) smallrhs);\n\t\treturn;\n\t}\n\n\tmp_int_sub(isl_sioimath_bigarg_src(lhs, &scratchlhs),\n\t    isl_sioimath_bigarg_src(rhs, &scratchrhs),\n\t    isl_sioimath_reinit_big(dst));\n\tisl_sioimath_try_demote(dst);\n}\n\n/* Multiply two isl_ints.\n */\ninline void isl_sioimath_mul(isl_sioimath_ptr dst, isl_sioimath_src lhs,\n\tisl_sioimath_src rhs)\n{\n\tisl_sioimath_scratchspace_t scratchlhs, scratchrhs;\n\tint32_t smalllhs, smallrhs;\n\n\tif (isl_sioimath_decode_small(lhs, &smalllhs) &&\n\t    isl_sioimath_decode_small(rhs, &smallrhs)) {\n\t\tisl_sioimath_set_int64(\n\t\t    dst, (int64_t) smalllhs * (int64_t) smallrhs);\n\t\treturn;\n\t}\n\n\tmp_int_mul(isl_sioimath_bigarg_src(lhs, &scratchlhs),\n\t    isl_sioimath_bigarg_src(rhs, &scratchrhs),\n\t    isl_sioimath_reinit_big(dst));\n\tisl_sioimath_try_demote(dst);\n}\n\n/* Shift lhs by rhs bits to the left and store the result in dst. Effectively,\n * this operation computes 'lhs * 2^rhs'.\n */\ninline void isl_sioimath_mul_2exp(isl_sioimath_ptr dst, isl_sioimath lhs,\n\tunsigned long rhs)\n{\n\tisl_sioimath_scratchspace_t scratchlhs;\n\tint32_t smalllhs;\n\n\tif (isl_sioimath_decode_small(lhs, &smalllhs) && (rhs <= 32ul)) {\n\t\tisl_sioimath_set_int64(dst, ((int64_t) smalllhs) << rhs);\n\t\treturn;\n\t}\n\n\tmp_int_mul_pow2(isl_sioimath_bigarg_src(lhs, &scratchlhs), rhs,\n\t    isl_sioimath_reinit_big(dst));\n}\n\n/* Multiply an isl_int and a signed long.\n */\ninline void isl_sioimath_mul_si(isl_sioimath_ptr dst, isl_sioimath lhs,\n\tsigned long rhs)\n{\n\tisl_sioimath_scratchspace_t scratchlhs, scratchrhs;\n\tint32_t smalllhs;\n\n\tif (isl_sioimath_decode_small(lhs, &smalllhs) && (rhs > LONG_MIN) &&\n\t    (labs(rhs) <= UINT32_MAX)) {\n\t\tisl_sioimath_set_int64(dst, (int64_t) smalllhs * (int64_t) rhs);\n\t\treturn;\n\t}\n\n\tmp_int_mul(isl_sioimath_bigarg_src(lhs, &scratchlhs),\n\t    isl_sioimath_siarg_src(rhs, &scratchrhs),\n\t    isl_sioimath_reinit_big(dst));\n\tisl_sioimath_try_demote(dst);\n}\n\n/* Multiply an isl_int and an unsigned long.\n */\ninline void isl_sioimath_mul_ui(isl_sioimath_ptr dst, isl_sioimath lhs,\n\tunsigned long rhs)\n{\n\tisl_sioimath_scratchspace_t scratchlhs, scratchrhs;\n\tint32_t smalllhs;\n\n\tif (isl_sioimath_decode_small(lhs, &smalllhs) && (rhs <= UINT32_MAX)) {\n\t\tisl_sioimath_set_int64(dst, (int64_t) smalllhs * (int64_t) rhs);\n\t\treturn;\n\t}\n\n\tmp_int_mul(isl_sioimath_bigarg_src(lhs, &scratchlhs),\n\t    isl_sioimath_uiarg_src(rhs, &scratchrhs),\n\t    isl_sioimath_reinit_big(dst));\n\tisl_sioimath_try_demote(dst);\n}\n\n/* Compute the power of an isl_int to an unsigned long.\n * Always let IMath do it; the result is unlikely to be small except in some\n * special cases.\n * Note: 0^0 == 1\n */\ninline void isl_sioimath_pow_ui(isl_sioimath_ptr dst, isl_sioimath_src lhs,\n\tunsigned long rhs)\n{\n\tisl_sioimath_scratchspace_t scratchlhs, scratchrhs;\n\tint32_t smalllhs;\n\n\tswitch (rhs) {\n\tcase 0:\n\t\tisl_sioimath_set_small(dst, 1);\n\t\treturn;\n\tcase 1:\n\t\tisl_sioimath_set(dst, lhs);\n\t\treturn;\n\tcase 2:\n\t\tisl_sioimath_mul(dst, lhs, lhs);\n\t\treturn;\n\t}\n\n\tif (isl_sioimath_decode_small(lhs, &smalllhs)) {\n\t\tswitch (smalllhs) {\n\t\tcase 0:\n\t\t\tisl_sioimath_set_small(dst, 0);\n\t\t\treturn;\n\t\tcase 1:\n\t\t\tisl_sioimath_set_small(dst, 1);\n\t\t\treturn;\n\t\tcase 2:\n\t\t\tisl_sioimath_set_small(dst, 1);\n\t\t\tisl_sioimath_mul_2exp(dst, *dst, rhs);\n\t\t\treturn;\n\t\tdefault:\n\t\t\tif ((MP_SMALL_MIN <= rhs) && (rhs <= MP_SMALL_MAX)) {\n\t\t\t\tmp_int_expt_value(smalllhs, rhs,\n\t\t\t\t    isl_sioimath_reinit_big(dst));\n\t\t\t\tisl_sioimath_try_demote(dst);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\n\tmp_int_expt_full(isl_sioimath_bigarg_src(lhs, &scratchlhs),\n\t    isl_sioimath_uiarg_src(rhs, &scratchrhs),\n\t    isl_sioimath_reinit_big(dst));\n\tisl_sioimath_try_demote(dst);\n}\n\n/* Fused multiply-add.\n */\ninline void isl_sioimath_addmul(isl_sioimath_ptr dst, isl_sioimath_src lhs,\n\tisl_sioimath_src rhs)\n{\n\tisl_sioimath tmp;\n\tisl_sioimath_init(&tmp);\n\tisl_sioimath_mul(&tmp, lhs, rhs);\n\tisl_sioimath_add(dst, *dst, tmp);\n\tisl_sioimath_clear(&tmp);\n}\n\n/* Fused multiply-add with an unsigned long.\n */\ninline void isl_sioimath_addmul_ui(isl_sioimath_ptr dst, isl_sioimath_src lhs,\n\tunsigned long rhs)\n{\n\tisl_sioimath tmp;\n\tisl_sioimath_init(&tmp);\n\tisl_sioimath_mul_ui(&tmp, lhs, rhs);\n\tisl_sioimath_add(dst, *dst, tmp);\n\tisl_sioimath_clear(&tmp);\n}\n\n/* Fused multiply-subtract.\n */\ninline void isl_sioimath_submul(isl_sioimath_ptr dst, isl_sioimath_src lhs,\n\tisl_sioimath_src rhs)\n{\n\tisl_sioimath tmp;\n\tisl_sioimath_init(&tmp);\n\tisl_sioimath_mul(&tmp, lhs, rhs);\n\tisl_sioimath_sub(dst, *dst, tmp);\n\tisl_sioimath_clear(&tmp);\n}\n\n/* Fused multiply-add with an unsigned long.\n */\ninline void isl_sioimath_submul_ui(isl_sioimath_ptr dst, isl_sioimath_src lhs,\n\tunsigned long rhs)\n{\n\tisl_sioimath tmp;\n\tisl_sioimath_init(&tmp);\n\tisl_sioimath_mul_ui(&tmp, lhs, rhs);\n\tisl_sioimath_sub(dst, *dst, tmp);\n\tisl_sioimath_clear(&tmp);\n}\n\nvoid isl_sioimath_gcd(isl_sioimath_ptr dst, isl_sioimath_src lhs,\n\t\t      isl_sioimath_src rhs);\nvoid isl_sioimath_lcm(isl_sioimath_ptr dst, isl_sioimath_src lhs,\n\t\t      isl_sioimath_src rhs);\n\n/* Divide lhs by rhs, rounding to zero (Truncate).\n */\ninline void isl_sioimath_tdiv_q(isl_sioimath_ptr dst, isl_sioimath_src lhs,\n\tisl_sioimath_src rhs)\n{\n\tisl_sioimath_scratchspace_t lhsscratch, rhsscratch;\n\tint32_t lhssmall, rhssmall;\n\n\tif (isl_sioimath_decode_small(lhs, &lhssmall) &&\n\t    isl_sioimath_decode_small(rhs, &rhssmall)) {\n\t\tisl_sioimath_set_small(dst, lhssmall / rhssmall);\n\t\treturn;\n\t}\n\n\tmp_int_div(isl_sioimath_bigarg_src(lhs, &lhsscratch),\n\t    isl_sioimath_bigarg_src(rhs, &rhsscratch),\n\t    isl_sioimath_reinit_big(dst), NULL);\n\tisl_sioimath_try_demote(dst);\n\treturn;\n}\n\n/* Divide lhs by an unsigned long rhs, rounding to zero (Truncate).\n */\ninline void isl_sioimath_tdiv_q_ui(isl_sioimath_ptr dst, isl_sioimath_src lhs,\n\tunsigned long rhs)\n{\n\tisl_sioimath_scratchspace_t lhsscratch, rhsscratch;\n\tint32_t lhssmall;\n\n\tif (isl_sioimath_is_small(lhs) && (rhs <= (unsigned long) INT32_MAX)) {\n\t\tlhssmall = isl_sioimath_get_small(lhs);\n\t\tisl_sioimath_set_small(dst, lhssmall / (int32_t) rhs);\n\t\treturn;\n\t}\n\n\tif (rhs <= MP_SMALL_MAX) {\n\t\tmp_int_div_value(isl_sioimath_bigarg_src(lhs, &lhsscratch), rhs,\n\t\t    isl_sioimath_reinit_big(dst), NULL);\n\t\tisl_sioimath_try_demote(dst);\n\t\treturn;\n\t}\n\n\tmp_int_div(isl_sioimath_bigarg_src(lhs, &lhsscratch),\n\t    isl_sioimath_uiarg_src(rhs, &rhsscratch),\n\t    isl_sioimath_reinit_big(dst), NULL);\n\tisl_sioimath_try_demote(dst);\n}\n\n/* Divide lhs by rhs, rounding to positive infinity (Ceil).\n */\ninline void isl_sioimath_cdiv_q(isl_sioimath_ptr dst, isl_sioimath_src lhs,\n\tisl_sioimath_src rhs)\n{\n\tint32_t lhssmall, rhssmall;\n\tisl_sioimath_scratchspace_t lhsscratch, rhsscratch;\n\tint32_t q;\n\n\tif (isl_sioimath_decode_small(lhs, &lhssmall) &&\n\t    isl_sioimath_decode_small(rhs, &rhssmall)) {\n\t\tif ((lhssmall >= 0) && (rhssmall >= 0))\n\t\t\tq = ((int64_t) lhssmall + (int64_t) rhssmall - 1) /\n\t\t\t    rhssmall;\n\t\telse if ((lhssmall < 0) && (rhssmall < 0))\n\t\t\tq = ((int64_t) lhssmall + (int64_t) rhssmall + 1) /\n\t\t\t    rhssmall;\n\t\telse\n\t\t\tq = lhssmall / rhssmall;\n\t\tisl_sioimath_set_small(dst, q);\n\t\treturn;\n\t}\n\n\timpz_cdiv_q(isl_sioimath_reinit_big(dst),\n\t    isl_sioimath_bigarg_src(lhs, &lhsscratch),\n\t    isl_sioimath_bigarg_src(rhs, &rhsscratch));\n\tisl_sioimath_try_demote(dst);\n}\n\n/* Compute the division of lhs by a rhs of type unsigned long, rounding towards\n * positive infinity (Ceil).\n */\ninline void isl_sioimath_cdiv_q_ui(isl_sioimath_ptr dst, isl_sioimath_src lhs,\n\tunsigned long rhs)\n{\n\tisl_sioimath_scratchspace_t lhsscratch, rhsscratch;\n\tint32_t lhssmall, q;\n\n\tif (isl_sioimath_decode_small(lhs, &lhssmall) && (rhs <= INT32_MAX)) {\n\t\tif (lhssmall >= 0)\n\t\t\tq = ((int64_t) lhssmall + ((int64_t) rhs - 1)) /\n\t\t\t    (int64_t) rhs;\n\t\telse\n\t\t\tq = lhssmall / (int32_t) rhs;\n\t\tisl_sioimath_set_small(dst, q);\n\t\treturn;\n\t}\n\n\timpz_cdiv_q(isl_sioimath_reinit_big(dst),\n\t    isl_sioimath_bigarg_src(lhs, &lhsscratch),\n\t    isl_sioimath_uiarg_src(rhs, &rhsscratch));\n\tisl_sioimath_try_demote(dst);\n}\n\n/* Divide lhs by rhs, rounding to negative infinity (Floor).\n */\ninline void isl_sioimath_fdiv_q(isl_sioimath_ptr dst, isl_sioimath_src lhs,\n\tisl_sioimath_src rhs)\n{\n\tisl_sioimath_scratchspace_t lhsscratch, rhsscratch;\n\tint32_t lhssmall, rhssmall;\n\tint32_t q;\n\n\tif (isl_sioimath_decode_small(lhs, &lhssmall) &&\n\t    isl_sioimath_decode_small(rhs, &rhssmall)) {\n\t\tif ((lhssmall < 0) && (rhssmall >= 0))\n\t\t\tq = ((int64_t) lhssmall - ((int64_t) rhssmall - 1)) /\n\t\t\t    rhssmall;\n\t\telse if ((lhssmall >= 0) && (rhssmall < 0))\n\t\t\tq = ((int64_t) lhssmall - ((int64_t) rhssmall + 1)) /\n\t\t\t    rhssmall;\n\t\telse\n\t\t\tq = lhssmall / rhssmall;\n\t\tisl_sioimath_set_small(dst, q);\n\t\treturn;\n\t}\n\n\timpz_fdiv_q(isl_sioimath_reinit_big(dst),\n\t    isl_sioimath_bigarg_src(lhs, &lhsscratch),\n\t    isl_sioimath_bigarg_src(rhs, &rhsscratch));\n\tisl_sioimath_try_demote(dst);\n}\n\n/* Compute the division of lhs by a rhs of type unsigned long, rounding towards\n * negative infinity (Floor).\n */\ninline void isl_sioimath_fdiv_q_ui(isl_sioimath_ptr dst, isl_sioimath_src lhs,\n\tunsigned long rhs)\n{\n\tisl_sioimath_scratchspace_t lhsscratch, rhsscratch;\n\tint32_t lhssmall, q;\n\n\tif (isl_sioimath_decode_small(lhs, &lhssmall) && (rhs <= INT32_MAX)) {\n\t\tif (lhssmall >= 0)\n\t\t\tq = (uint32_t) lhssmall / rhs;\n\t\telse\n\t\t\tq = ((int64_t) lhssmall - ((int64_t) rhs - 1)) /\n\t\t\t    (int64_t) rhs;\n\t\tisl_sioimath_set_small(dst, q);\n\t\treturn;\n\t}\n\n\timpz_fdiv_q(isl_sioimath_reinit_big(dst),\n\t    isl_sioimath_bigarg_src(lhs, &lhsscratch),\n\t    isl_sioimath_uiarg_src(rhs, &rhsscratch));\n\tisl_sioimath_try_demote(dst);\n}\n\n/* Get the remainder of: lhs divided by rhs rounded towards negative infinite\n * (Floor).\n */\ninline void isl_sioimath_fdiv_r(isl_sioimath_ptr dst, isl_sioimath_src lhs,\n\tisl_sioimath_src rhs)\n{\n\tisl_sioimath_scratchspace_t lhsscratch, rhsscratch;\n\tint64_t lhssmall, rhssmall;\n\tint32_t r;\n\n\tif (isl_sioimath_is_small(lhs) && isl_sioimath_is_small(rhs)) {\n\t\tlhssmall = isl_sioimath_get_small(lhs);\n\t\trhssmall = isl_sioimath_get_small(rhs);\n\t\tr = (rhssmall + lhssmall % rhssmall) % rhssmall;\n\t\tisl_sioimath_set_small(dst, r);\n\t\treturn;\n\t}\n\n\timpz_fdiv_r(isl_sioimath_reinit_big(dst),\n\t    isl_sioimath_bigarg_src(lhs, &lhsscratch),\n\t    isl_sioimath_bigarg_src(rhs, &rhsscratch));\n\tisl_sioimath_try_demote(dst);\n}\n\nvoid isl_sioimath_read(isl_sioimath_ptr dst, const char *str);\n\n/* Return:\n *   +1 for a positive number\n *   -1 for a negative number\n *    0 if the number is zero\n */\ninline int isl_sioimath_sgn(isl_sioimath_src arg)\n{\n\tint32_t small;\n\n\tif (isl_sioimath_decode_small(arg, &small))\n\t\treturn (small > 0) - (small < 0);\n\n\treturn mp_int_compare_zero(isl_sioimath_get_big(arg));\n}\n\n/* Return:\n *   +1 if lhs > rhs\n *   -1 if lhs < rhs\n *    0 if lhs = rhs\n */\ninline int isl_sioimath_cmp(isl_sioimath_src lhs, isl_sioimath_src rhs)\n{\n\tisl_sioimath_scratchspace_t lhsscratch, rhsscratch;\n\tint32_t lhssmall, rhssmall;\n\n\tif (isl_sioimath_decode_small(lhs, &lhssmall) &&\n\t    isl_sioimath_decode_small(rhs, &rhssmall))\n\t\treturn (lhssmall > rhssmall) - (lhssmall < rhssmall);\n\n\tif (isl_sioimath_decode_small(rhs, &rhssmall))\n\t\treturn mp_int_compare_value(\n\t\t    isl_sioimath_bigarg_src(lhs, &lhsscratch), rhssmall);\n\n\tif (isl_sioimath_decode_small(lhs, &lhssmall))\n\t\treturn -mp_int_compare_value(\n\t\t           isl_sioimath_bigarg_src(rhs, &rhsscratch), lhssmall);\n\n\treturn mp_int_compare(\n\t    isl_sioimath_get_big(lhs), isl_sioimath_get_big(rhs));\n}\n\n/* As isl_sioimath_cmp, but with signed long rhs.\n */\ninline int isl_sioimath_cmp_si(isl_sioimath_src lhs, signed long rhs)\n{\n\tint32_t lhssmall;\n\n\tif (isl_sioimath_decode_small(lhs, &lhssmall))\n\t\treturn (lhssmall > rhs) - (lhssmall < rhs);\n\n\treturn mp_int_compare_value(isl_sioimath_get_big(lhs), rhs);\n}\n\n/* Return:\n *   +1 if |lhs| > |rhs|\n *   -1 if |lhs| < |rhs|\n *    0 if |lhs| = |rhs|\n */\ninline int isl_sioimath_abs_cmp(isl_sioimath_src lhs, isl_sioimath_src rhs)\n{\n\tisl_sioimath_scratchspace_t lhsscratch, rhsscratch;\n\tint32_t lhssmall, rhssmall;\n\n\tif (isl_sioimath_decode_small(lhs, &lhssmall) &&\n\t    isl_sioimath_decode_small(rhs, &rhssmall)) {\n\t\tlhssmall = labs(lhssmall);\n\t\trhssmall = labs(rhssmall);\n\t\treturn (lhssmall > rhssmall) - (lhssmall < rhssmall);\n\t}\n\n\treturn mp_int_compare_unsigned(\n\t    isl_sioimath_bigarg_src(lhs, &lhsscratch),\n\t    isl_sioimath_bigarg_src(rhs, &rhsscratch));\n}\n\n/* Return whether lhs is divisible by rhs.\n * In particular, can rhs be multiplied by some integer to result in lhs?\n * If rhs is zero, then this means lhs has to be zero too.\n */\ninline int isl_sioimath_is_divisible_by(isl_sioimath_src lhs,\n\t\t\t\t\tisl_sioimath_src rhs)\n{\n\tisl_sioimath_scratchspace_t lhsscratch, rhsscratch;\n\tint32_t lhssmall, rhssmall;\n\tmpz_t rem;\n\tint cmp;\n\n\tif (isl_sioimath_sgn(rhs) == 0)\n\t\treturn isl_sioimath_sgn(lhs) == 0;\n\n\tif (isl_sioimath_decode_small(lhs, &lhssmall) &&\n\t    isl_sioimath_decode_small(rhs, &rhssmall))\n\t\treturn lhssmall % rhssmall == 0;\n\n\tif (isl_sioimath_decode_small(rhs, &rhssmall))\n\t\treturn mp_int_divisible_value(\n\t\t    isl_sioimath_bigarg_src(lhs, &lhsscratch), rhssmall);\n\n\tmp_int_init(&rem);\n\tmp_int_div(isl_sioimath_bigarg_src(lhs, &lhsscratch),\n\t    isl_sioimath_bigarg_src(rhs, &rhsscratch), NULL, &rem);\n\tcmp = mp_int_compare_zero(&rem);\n\tmp_int_clear(&rem);\n\treturn cmp == 0;\n}\n\n/* Return a hash code of an isl_sioimath.\n * The hash code for a number in small and big representation must be identical\n * on the same machine because small representation if not obligatory if fits.\n */\ninline uint32_t isl_sioimath_hash(isl_sioimath_src arg, uint32_t hash)\n{\n\tint32_t small;\n\tint i;\n\tuint32_t num;\n\tmp_digit digits[(sizeof(uint32_t) + sizeof(mp_digit) - 1) /\n\t                sizeof(mp_digit)];\n\tmp_size used;\n\tconst unsigned char *digitdata = (const unsigned char *) &digits;\n\n\tif (isl_sioimath_decode_small(arg, &small)) {\n\t\tif (small < 0)\n\t\t\tisl_hash_byte(hash, 0xFF);\n\t\tnum = labs(small);\n\n\t\tisl_siomath_uint32_to_digits(num, digits, &used);\n\t\tfor (i = 0; i < used * sizeof(mp_digit); i += 1)\n\t\t\tisl_hash_byte(hash, digitdata[i]);\n\t\treturn hash;\n\t}\n\n\treturn isl_imath_hash(isl_sioimath_get_big(arg), hash);\n}\n\n/* Return the number of digits in a number of the given base or more, i.e. the\n * string length without sign and null terminator.\n *\n * Current implementation for small representation returns the maximal number\n * of binary digits in that representation, which can be much larger than the\n * smallest possible solution.\n */\ninline size_t isl_sioimath_sizeinbase(isl_sioimath_src arg, int base)\n{\n\tint32_t small;\n\n\tif (isl_sioimath_decode_small(arg, &small))\n\t\treturn sizeof(int32_t) * CHAR_BIT - 1;\n\n\treturn impz_sizeinbase(isl_sioimath_get_big(arg), base);\n}\n\nvoid isl_sioimath_print(FILE *out, isl_sioimath_src i, int width);\nvoid isl_sioimath_dump(isl_sioimath_src arg);\n\ntypedef isl_sioimath isl_int[1];\n#define isl_int_init(i)\t\t\tisl_sioimath_init((i))\n#define isl_int_clear(i)\t\tisl_sioimath_clear((i))\n\n#define isl_int_set(r, i)\t\tisl_sioimath_set((r), *(i))\n#define isl_int_set_si(r, i)\t\tisl_sioimath_set_si((r), i)\n#define isl_int_set_ui(r, i)\t\tisl_sioimath_set_ui((r), i)\n#define isl_int_fits_slong(r)\t\tisl_sioimath_fits_slong(*(r))\n#define isl_int_get_si(r)\t\tisl_sioimath_get_si(*(r))\n#define isl_int_fits_ulong(r)\t\tisl_sioimath_fits_ulong(*(r))\n#define isl_int_get_ui(r)\t\tisl_sioimath_get_ui(*(r))\n#define isl_int_get_d(r)\t\tisl_sioimath_get_d(*(r))\n#define isl_int_get_str(r)\t\tisl_sioimath_get_str(*(r))\n#define isl_int_abs(r, i)\t\tisl_sioimath_abs((r), *(i))\n#define isl_int_neg(r, i)\t\tisl_sioimath_neg((r), *(i))\n#define isl_int_swap(i, j)\t\tisl_sioimath_swap((i), (j))\n#define isl_int_swap_or_set(i, j)\tisl_sioimath_swap((i), (j))\n#define isl_int_add_ui(r, i, j)\t\tisl_sioimath_add_ui((r), *(i), j)\n#define isl_int_sub_ui(r, i, j)\t\tisl_sioimath_sub_ui((r), *(i), j)\n\n#define isl_int_add(r, i, j)\t\tisl_sioimath_add((r), *(i), *(j))\n#define isl_int_sub(r, i, j)\t\tisl_sioimath_sub((r), *(i), *(j))\n#define isl_int_mul(r, i, j)\t\tisl_sioimath_mul((r), *(i), *(j))\n#define isl_int_mul_2exp(r, i, j)\tisl_sioimath_mul_2exp((r), *(i), j)\n#define isl_int_mul_si(r, i, j)\t\tisl_sioimath_mul_si((r), *(i), j)\n#define isl_int_mul_ui(r, i, j)\t\tisl_sioimath_mul_ui((r), *(i), j)\n#define isl_int_pow_ui(r, i, j)\t\tisl_sioimath_pow_ui((r), *(i), j)\n#define isl_int_addmul(r, i, j)\t\tisl_sioimath_addmul((r), *(i), *(j))\n#define isl_int_addmul_ui(r, i, j)\tisl_sioimath_addmul_ui((r), *(i), j)\n#define isl_int_submul(r, i, j)\t\tisl_sioimath_submul((r), *(i), *(j))\n#define isl_int_submul_ui(r, i, j)\tisl_sioimath_submul_ui((r), *(i), j)\n\n#define isl_int_gcd(r, i, j)\t\tisl_sioimath_gcd((r), *(i), *(j))\n#define isl_int_lcm(r, i, j)\t\tisl_sioimath_lcm((r), *(i), *(j))\n#define isl_int_divexact(r, i, j)\tisl_sioimath_tdiv_q((r), *(i), *(j))\n#define isl_int_divexact_ui(r, i, j)\tisl_sioimath_tdiv_q_ui((r), *(i), j)\n#define isl_int_tdiv_q(r, i, j)\t\tisl_sioimath_tdiv_q((r), *(i), *(j))\n#define isl_int_cdiv_q(r, i, j)\t\tisl_sioimath_cdiv_q((r), *(i), *(j))\n#define isl_int_cdiv_q_ui(r, i, j)\tisl_sioimath_cdiv_q_ui((r), *(i), j)\n#define isl_int_fdiv_q(r, i, j)\t\tisl_sioimath_fdiv_q((r), *(i), *(j))\n#define isl_int_fdiv_r(r, i, j)\t\tisl_sioimath_fdiv_r((r), *(i), *(j))\n#define isl_int_fdiv_q_ui(r, i, j)\tisl_sioimath_fdiv_q_ui((r), *(i), j)\n\n#define isl_int_read(r, s)\t\tisl_sioimath_read((r), s)\n#define isl_int_sgn(i)\t\t\tisl_sioimath_sgn(*(i))\n#define isl_int_cmp(i, j)\t\tisl_sioimath_cmp(*(i), *(j))\n#define isl_int_cmp_si(i, si)\t\tisl_sioimath_cmp_si(*(i), si)\n#define isl_int_eq(i, j)\t\t(isl_sioimath_cmp(*(i), *(j)) == 0)\n#define isl_int_ne(i, j)\t\t(isl_sioimath_cmp(*(i), *(j)) != 0)\n#define isl_int_lt(i, j)\t\t(isl_sioimath_cmp(*(i), *(j)) < 0)\n#define isl_int_le(i, j)\t\t(isl_sioimath_cmp(*(i), *(j)) <= 0)\n#define isl_int_gt(i, j)\t\t(isl_sioimath_cmp(*(i), *(j)) > 0)\n#define isl_int_ge(i, j)\t\t(isl_sioimath_cmp(*(i), *(j)) >= 0)\n#define isl_int_abs_cmp(i, j)\t\tisl_sioimath_abs_cmp(*(i), *(j))\n#define isl_int_abs_eq(i, j)\t\t(isl_sioimath_abs_cmp(*(i), *(j)) == 0)\n#define isl_int_abs_ne(i, j)\t\t(isl_sioimath_abs_cmp(*(i), *(j)) != 0)\n#define isl_int_abs_lt(i, j)\t\t(isl_sioimath_abs_cmp(*(i), *(j)) < 0)\n#define isl_int_abs_gt(i, j)\t\t(isl_sioimath_abs_cmp(*(i), *(j)) > 0)\n#define isl_int_abs_ge(i, j)\t\t(isl_sioimath_abs_cmp(*(i), *(j)) >= 0)\n#define isl_int_is_divisible_by(i, j)\tisl_sioimath_is_divisible_by(*(i), *(j))\n\n#define isl_int_hash(v, h)\t\tisl_sioimath_hash(*(v), h)\n#define isl_int_free_str(s)\t\tfree(s)\n#define isl_int_print(out, i, width)\tisl_sioimath_print(out, *(i), width)\n\n#endif /* ISL_INT_SIOIMATH_H */\n"}, "14": {"id": 14, "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_list_macro.h", "content": "#define xCAT(A,B) A ## B\n#define CAT(A,B) xCAT(A,B)\n#undef EL\n#define EL CAT(isl_,EL_BASE)\n#define xFN(TYPE,NAME) TYPE ## _ ## NAME\n#define FN(TYPE,NAME) xFN(TYPE,NAME)\n#define xLIST(EL) EL ## _list\n#define LIST(EL) xLIST(EL)\n"}, "15": {"id": 15, "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_list_private.h", "content": "#ifndef ISL_LIST_PRIVATE_H\n#define ISL_LIST_PRIVATE_H\n\n#include <isl/list.h>\n\n#define ISL_DECLARE_LIST_FN_PRIVATE(EL)\t\t\t\t\t\\\n__isl_keep isl_##EL *isl_##EL##_list_peek(\t\t\t\t\\\n\t__isl_keep isl_##EL##_list *list, int index);\n\n#endif\n"}, "16": {"id": 16, "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_list_templ.h", "content": "#define xFN(TYPE,NAME) TYPE ## _ ## NAME\n#define FN(TYPE,NAME) xFN(TYPE,NAME)\n#define xLIST(EL) EL ## _list\n#define LIST(EL) xLIST(EL)\n\nstruct LIST(EL) {\n\tint ref;\n\tisl_ctx *ctx;\n\n\tint n;\n\n\tsize_t size;\n\tstruct EL *p[1];\n};\n\n__isl_give LIST(EL) *FN(LIST(EL),dup)(__isl_keep LIST(EL) *list);\n"}, "17": {"id": 17, "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_map_private.h", "content": "/*\n * Copyright 2008-2009 Katholieke Universiteit Leuven\n *\n * Use of this software is governed by the MIT license\n *\n * Written by Sven Verdoolaege, K.U.Leuven, Departement\n * Computerwetenschappen, Celestijnenlaan 200A, B-3001 Leuven, Belgium\n */\n\n#ifndef ISL_MAP_PRIVATE_H\n#define ISL_MAP_PRIVATE_H\n\n#define isl_basic_set\tisl_basic_map\n#define isl_maybe_isl_basic_set\tisl_maybe_isl_basic_map\n#define isl_set\t\tisl_map\n#define isl_basic_set_list\tisl_basic_map_list\n#define isl_set_list\tisl_map_list\n#include <isl/list.h>\n#include <isl/set.h>\n#include <isl/map.h>\n#include <isl_reordering.h>\n#include <isl/vec.h>\n#include <isl/hash.h>\n#include <isl_blk.h>\n\n/* A \"basic map\" is a relation between two sets of variables,\n * called the \"in\" and \"out\" variables.\n * A \"basic set\" is a basic map with a zero-dimensional\n * domain.\n *\n * It is implemented as a set with two extra fields:\n * n_in is the number of in variables\n * n_out is the number of out variables\n * n_in + n_out should be equal to set.dim\n */\nstruct isl_basic_map {\n\tint ref;\n#define ISL_BASIC_MAP_FINAL\t\t(1 << 0)\n#define ISL_BASIC_MAP_EMPTY\t\t(1 << 1)\n#define ISL_BASIC_MAP_NO_IMPLICIT\t(1 << 2)\n#define ISL_BASIC_MAP_NO_REDUNDANT\t(1 << 3)\n#define ISL_BASIC_MAP_RATIONAL\t\t(1 << 4)\n#define ISL_BASIC_MAP_SORTED\t\t(1 << 5)\n#define ISL_BASIC_MAP_NORMALIZED_DIVS\t(1 << 6)\n#define ISL_BASIC_MAP_ALL_EQUALITIES\t(1 << 7)\n#define ISL_BASIC_MAP_REDUCED_COEFFICIENTS\t(1 << 8)\n#define ISL_BASIC_SET_FINAL\t\t(1 << 0)\n#define ISL_BASIC_SET_EMPTY\t\t(1 << 1)\n#define ISL_BASIC_SET_NO_IMPLICIT\t(1 << 2)\n#define ISL_BASIC_SET_NO_REDUNDANT\t(1 << 3)\n#define ISL_BASIC_SET_RATIONAL\t\t(1 << 4)\n#define ISL_BASIC_SET_SORTED\t\t(1 << 5)\n#define ISL_BASIC_SET_NORMALIZED_DIVS\t(1 << 6)\n#define ISL_BASIC_SET_ALL_EQUALITIES\t(1 << 7)\n#define ISL_BASIC_SET_REDUCED_COEFFICIENTS\t(1 << 8)\n\tunsigned flags;\n\n\tstruct isl_ctx *ctx;\n\n\tisl_space *dim;\n\tunsigned extra;\n\n\tunsigned n_eq;\n\tunsigned n_ineq;\n\n\tsize_t c_size;\n\tisl_int **eq;\n\tisl_int **ineq;\n\n\tunsigned n_div;\n\n\tisl_int **div;\n\n\tstruct isl_vec *sample;\n\n\tstruct isl_blk block;\n\tstruct isl_blk block2;\n};\n\n#undef EL\n#define EL isl_basic_set\n\n#include <isl_list_templ.h>\n\n/* A \"map\" is a (possibly disjoint) union of basic maps.\n * A \"set\" is a (possibly disjoint) union of basic sets.\n *\n * Currently, the isl_set structure is identical to the isl_map structure\n * and the library depends on this correspondence internally.\n * However, users should not depend on this correspondence.\n *\n * \"cached_simple_hull\" contains copies of the unshifted and shifted\n * simple hulls, if they have already been computed.  Otherwise,\n * the entries are NULL.\n */\nstruct isl_map {\n\tint ref;\n#define ISL_MAP_DISJOINT\t\t(1 << 0)\n#define ISL_MAP_NORMALIZED\t\t(1 << 1)\n#define ISL_SET_DISJOINT\t\t(1 << 0)\n#define ISL_SET_NORMALIZED\t\t(1 << 1)\n\tunsigned flags;\n\tisl_basic_map *cached_simple_hull[2];\n\n\tstruct isl_ctx *ctx;\n\n\tisl_space *dim;\n\n\tint n;\n\n\tsize_t size;\n\tstruct isl_basic_map *p[1];\n};\n\n#undef EL\n#define EL isl_set\n\n#include <isl_list_templ.h>\n\n__isl_give isl_basic_set *isl_basic_set_alloc(isl_ctx *ctx,\n\tunsigned nparam, unsigned dim, unsigned extra,\n\tunsigned n_eq, unsigned n_ineq);\n__isl_give isl_basic_set *isl_basic_set_extend_constraints(\n\t__isl_take isl_basic_set *base, unsigned n_eq, unsigned n_ineq);\n__isl_give isl_basic_set *isl_basic_set_finalize(\n\t__isl_take isl_basic_set *bset);\n__isl_give isl_basic_set *isl_basic_set_dup(__isl_keep isl_basic_set *bset);\n__isl_give isl_basic_set *isl_basic_set_simplify(\n\t__isl_take isl_basic_set *bset);\n\n__isl_give isl_basic_map *isl_basic_map_alloc(isl_ctx *ctx,\n\tunsigned nparam, unsigned in, unsigned out, unsigned extra,\n\tunsigned n_eq, unsigned n_ineq);\n__isl_give isl_basic_map *isl_basic_map_mark_final(\n\t__isl_take isl_basic_map *bmap);\n__isl_give isl_basic_map *isl_basic_map_finalize(\n\t__isl_take isl_basic_map *bmap);\n__isl_give isl_basic_map *isl_basic_map_extend_constraints(\n\t__isl_take isl_basic_map *base, unsigned n_eq, unsigned n_ineq);\n__isl_give isl_basic_map *isl_basic_map_simplify(\n\t__isl_take isl_basic_map *bmap);\n\n__isl_give isl_set *isl_set_add_basic_set(__isl_take isl_set *set,\n\t__isl_take isl_basic_set *bset);\n\n__isl_give isl_map *isl_map_add_basic_map(__isl_take isl_map *map,\n\t__isl_take isl_basic_map *bmap);\n__isl_give isl_map *isl_map_dup(__isl_keep isl_map *map);\n\n__isl_give isl_basic_set *isl_basic_set_from_underlying_set(\n\t__isl_take isl_basic_set *bset, __isl_take isl_basic_set *like);\n\n__isl_give isl_map *isl_map_realign(__isl_take isl_map *map,\n\t__isl_take isl_reordering *r);\n__isl_give isl_set *isl_set_realign(__isl_take isl_set *set,\n\t__isl_take isl_reordering *r);\n\n__isl_give isl_basic_map *isl_basic_map_reset(__isl_take isl_basic_map *bmap,\n\tenum isl_dim_type type);\n__isl_give isl_map *isl_map_reset(__isl_take isl_map *map,\n\tenum isl_dim_type type);\n\n__isl_keep isl_space *isl_basic_map_peek_space(\n\t__isl_keep const isl_basic_map *bmap);\n__isl_keep isl_space *isl_basic_set_peek_space(__isl_keep isl_basic_set *bset);\n__isl_keep isl_space *isl_map_peek_space(__isl_keep const isl_map *map);\n__isl_keep isl_space *isl_set_peek_space(__isl_keep isl_set *set);\n\n__isl_give isl_basic_set *isl_basic_set_reset_space(\n\t__isl_take isl_basic_set *bset, __isl_take isl_space *space);\n__isl_give isl_basic_map *isl_basic_map_reset_space(\n\t__isl_take isl_basic_map *bmap, __isl_take isl_space *space);\n__isl_give isl_map *isl_map_reset_space(__isl_take isl_map *map,\n\t__isl_take isl_space *space);\n__isl_give isl_map *isl_map_reset_equal_dim_space(__isl_take isl_map *map,\n\t__isl_take isl_space *space);\n\nisl_size isl_basic_map_var_offset(__isl_keep isl_basic_map *bmap,\n\tenum isl_dim_type type);\nisl_size isl_basic_set_var_offset(__isl_keep isl_basic_set *bset,\n\tenum isl_dim_type type);\nunsigned isl_basic_map_offset(__isl_keep isl_basic_map *bmap,\n\t\t\t\t\tenum isl_dim_type type);\nunsigned isl_basic_set_offset(__isl_keep isl_basic_set *bset,\n\t\t\t\t\tenum isl_dim_type type);\n\nisl_bool isl_basic_map_may_be_set(__isl_keep isl_basic_map *bmap);\nint isl_map_may_be_set(__isl_keep isl_map *map);\nisl_bool isl_map_compatible_domain(__isl_keep isl_map *map,\n\t__isl_keep isl_set *set);\nisl_bool isl_basic_map_compatible_domain(__isl_keep isl_basic_map *bmap,\n\t__isl_keep isl_basic_set *bset);\nisl_bool isl_basic_map_compatible_range(__isl_keep isl_basic_map *bmap,\n\t__isl_keep isl_basic_set *bset);\n\n__isl_give isl_basic_map *isl_basic_map_extend(__isl_take isl_basic_map *base,\n\tunsigned extra, unsigned n_eq, unsigned n_ineq);\n__isl_give isl_basic_set *isl_basic_set_extend(__isl_take isl_basic_set *base,\n\tunsigned extra, unsigned n_eq, unsigned n_ineq);\n\n__isl_give isl_map *isl_map_grow(__isl_take isl_map *map, int n);\n__isl_give isl_set *isl_set_grow(__isl_take isl_set *set, int n);\n\nisl_bool isl_basic_set_contains(__isl_keep isl_basic_set *bset,\n\t__isl_keep isl_vec *vec);\nisl_bool isl_basic_map_contains(__isl_keep isl_basic_map *bmap,\n\t__isl_keep isl_vec *vec);\n\n__isl_give isl_basic_set *isl_basic_set_alloc_space(__isl_take isl_space *space,\n\t\tunsigned extra, unsigned n_eq, unsigned n_ineq);\n__isl_give isl_set *isl_set_alloc_space(__isl_take isl_space *space, int n,\n\tunsigned flags);\n__isl_give isl_basic_map *isl_basic_map_alloc_space(__isl_take isl_space *space,\n\t\tunsigned extra, unsigned n_eq, unsigned n_ineq);\n__isl_give isl_map *isl_map_alloc_space(__isl_take isl_space *space, int n,\n\tunsigned flags);\n\nint isl_basic_map_alloc_equality(__isl_keep isl_basic_map *bmap);\nint isl_basic_set_alloc_equality(__isl_keep isl_basic_set *bset);\n__isl_give isl_basic_set *isl_basic_set_free_inequality(\n\t__isl_take isl_basic_set *bset, unsigned n);\n__isl_give isl_basic_map *isl_basic_map_free_equality(\n\t__isl_take isl_basic_map *bmap, unsigned n);\n__isl_give isl_basic_set *isl_basic_set_free_equality(\n\t__isl_take isl_basic_set *bset, unsigned n);\nint isl_basic_set_alloc_inequality(__isl_keep isl_basic_set *bset);\nint isl_basic_map_alloc_inequality(__isl_keep isl_basic_map *bmap);\n__isl_give isl_basic_map *isl_basic_map_free_inequality(\n\t__isl_take isl_basic_map *bmap, unsigned n);\nint isl_basic_map_alloc_div(__isl_keep isl_basic_map *bmap);\n__isl_give isl_basic_map *isl_basic_map_insert_div(\n\t__isl_take isl_basic_map *bmap, int pos, __isl_keep isl_vec *div);\nint isl_basic_set_alloc_div(__isl_keep isl_basic_set *bset);\nisl_stat isl_basic_map_free_div(__isl_keep isl_basic_map *bmap, unsigned n);\n__isl_give isl_basic_map *isl_basic_map_drop_div(\n\t__isl_take isl_basic_map *bmap, unsigned div);\nvoid isl_basic_map_inequality_to_equality(\n\t\t__isl_keep isl_basic_map *bmap, unsigned pos);\nint isl_basic_map_drop_equality(__isl_keep isl_basic_map *bmap, unsigned pos);\nint isl_basic_set_drop_inequality(__isl_keep isl_basic_set *bset, unsigned pos);\nint isl_basic_map_drop_inequality(__isl_keep isl_basic_map *bmap, unsigned pos);\n__isl_give isl_basic_set *isl_basic_set_add_eq(__isl_take isl_basic_set *bset,\n\tisl_int *eq);\n__isl_give isl_basic_map *isl_basic_map_add_eq(__isl_take isl_basic_map *bmap,\n\tisl_int *eq);\n__isl_give isl_basic_set *isl_basic_set_add_ineq(__isl_take isl_basic_set *bset,\n\tisl_int *ineq);\n__isl_give isl_basic_map *isl_basic_map_add_ineq(__isl_take isl_basic_map *bmap,\n\tisl_int *ineq);\n\n__isl_give isl_basic_set *isl_basic_set_tighten_outward(\n\t__isl_take isl_basic_set *bset, __isl_keep isl_vec *vec);\n\n__isl_give isl_basic_map *isl_inequality_negate(__isl_take isl_basic_map *bmap,\n\tunsigned pos);\n\nisl_bool isl_basic_map_has_single_reference(__isl_keep isl_basic_map *bmap);\n__isl_give isl_basic_set *isl_basic_set_cow(__isl_take isl_basic_set *bset);\n__isl_give isl_basic_map *isl_basic_map_cow(__isl_take isl_basic_map *bmap);\n__isl_give isl_set *isl_set_cow(__isl_take isl_set *set);\n__isl_give isl_map *isl_map_cow(__isl_take isl_map *map);\n\nuint32_t isl_basic_map_get_hash(__isl_keep isl_basic_map *bmap);\n\n__isl_give isl_set *isl_basic_set_list_union(\n\t__isl_take isl_basic_set_list *list);\n\n__isl_give isl_basic_map *isl_basic_map_set_to_empty(\n\t__isl_take isl_basic_map *bmap);\n__isl_give isl_basic_set *isl_basic_set_set_to_empty(\n\t__isl_take isl_basic_set *bset);\n__isl_give isl_basic_map *isl_basic_map_swap_div(__isl_take isl_basic_map *bmap,\n\tint a, int b);\n__isl_give isl_basic_map *isl_basic_map_order_divs(\n\t__isl_take isl_basic_map *bmap);\n__isl_give isl_map *isl_map_order_divs(__isl_take isl_map *map);\n__isl_give isl_basic_map *isl_basic_map_align_divs(\n\t__isl_take isl_basic_map *dst, __isl_keep isl_basic_map *src);\n__isl_give isl_map *isl_map_align_divs_to_basic_map_list(\n\t__isl_take isl_map *map, __isl_keep isl_basic_map_list *list);\n__isl_give isl_basic_map_list *isl_basic_map_list_align_divs_to_basic_map(\n\t__isl_take isl_basic_map_list *list, __isl_keep isl_basic_map *bmap);\n__isl_give isl_map *isl_map_align_divs_internal(__isl_take isl_map *map);\n__isl_give isl_basic_set *isl_basic_set_sort_divs(\n\t__isl_take isl_basic_set *bset);\n__isl_give isl_basic_map *isl_basic_map_sort_divs(\n\t__isl_take isl_basic_map *bmap);\n__isl_give isl_map *isl_map_sort_divs(__isl_take isl_map *map);\n__isl_give isl_basic_map *isl_basic_map_gauss5(__isl_take isl_basic_map *bmap,\n\tint *progress,\n\tisl_stat (*swap)(unsigned a, unsigned b, void *user),\n\tisl_stat (*drop)(unsigned n, void *user), void *user);\n__isl_give isl_basic_map *isl_basic_map_gauss(__isl_take isl_basic_map *bmap,\n\tint *progress);\n__isl_give isl_basic_set *isl_basic_set_gauss(\n\t__isl_take isl_basic_set *bset, int *progress);\nint isl_basic_map_constraint_cmp(__isl_keep isl_basic_map *bmap,\n\tisl_int *c1, isl_int *c2);\n__isl_give isl_basic_map *isl_basic_map_sort_constraints(\n\t__isl_take isl_basic_map *bmap);\n__isl_give isl_basic_set *isl_basic_set_sort_constraints(\n\t__isl_take isl_basic_set *bset);\nint isl_basic_map_plain_cmp(__isl_keep isl_basic_map *bmap1,\n\t__isl_keep isl_basic_map *bmap2);\nisl_bool isl_basic_map_plain_is_equal(__isl_keep isl_basic_map *bmap1,\n\t__isl_keep isl_basic_map *bmap2);\n__isl_give isl_basic_map *isl_basic_map_normalize_constraints(\n\t__isl_take isl_basic_map *bmap);\n__isl_give isl_basic_set *isl_basic_set_normalize_constraints(\n\t__isl_take isl_basic_set *bset);\n__isl_give isl_basic_map *isl_basic_map_implicit_equalities(\n\t__isl_take isl_basic_map *bmap);\n__isl_give isl_basic_set *isl_basic_map_underlying_set(\n\t__isl_take isl_basic_map *bmap);\n__isl_give isl_basic_set *isl_basic_set_underlying_set(\n\t\t__isl_take isl_basic_set *bset);\n__isl_give isl_basic_set_list *isl_basic_map_list_underlying_set(\n\t__isl_take isl_basic_map_list *list);\n__isl_give isl_set *isl_map_underlying_set(__isl_take isl_map *map);\n__isl_give isl_basic_map *isl_basic_map_overlying_set(\n\t__isl_take isl_basic_set *bset, __isl_take isl_basic_map *like);\n__isl_give isl_basic_set *isl_basic_set_drop_constraints_involving_unknown_divs(\n\t__isl_take isl_basic_set *bset);\n__isl_give isl_basic_map *isl_basic_map_drop_constraints_involving_unknown_divs(\n\t__isl_take isl_basic_map *bmap);\n__isl_give isl_map *isl_map_drop_constraints_involving_unknown_divs(\n\t__isl_take isl_map *map);\n__isl_give isl_basic_map *isl_basic_map_drop_constraints_involving(\n\t__isl_take isl_basic_map *bmap, unsigned first, unsigned n);\n__isl_give isl_basic_set *isl_basic_set_drop_constraints_involving(\n\t__isl_take isl_basic_set *bset, unsigned first, unsigned n);\n__isl_give isl_basic_set *isl_basic_set_drop(__isl_take isl_basic_set *bset,\n\tenum isl_dim_type type, unsigned first, unsigned n);\n__isl_give isl_basic_map *isl_basic_map_drop(__isl_take isl_basic_map *bmap,\n\tenum isl_dim_type type, unsigned first, unsigned n);\n__isl_give isl_set *isl_set_drop(__isl_take isl_set *set,\n\tenum isl_dim_type type, unsigned first, unsigned n);\n__isl_give isl_basic_set *isl_basic_set_drop_dims(\n\t__isl_take isl_basic_set *bset, unsigned first, unsigned n);\n__isl_give isl_map *isl_map_drop(__isl_take isl_map *map,\n\tenum isl_dim_type type, unsigned first, unsigned n);\n__isl_give isl_basic_map *isl_basic_map_drop_unrelated_constraints(\n\t__isl_take isl_basic_map *bmap, __isl_take int *group);\n\n__isl_give isl_basic_map *isl_basic_map_eliminate_pure_unit_divs(\n\t__isl_take isl_basic_map *bmap);\n__isl_give isl_basic_map *isl_basic_map_remove_duplicate_constraints(\n\t__isl_take isl_basic_map *bmap, int *progress, int detect_divs);\n__isl_give isl_basic_map *isl_basic_map_detect_inequality_pairs(\n\t__isl_take isl_basic_map *bmap, int *progress);\n\n__isl_give isl_map *isl_map_remove_empty_parts(__isl_take isl_map *map);\n__isl_give isl_set *isl_set_remove_empty_parts(__isl_take isl_set *set);\n__isl_give isl_map *isl_map_remove_obvious_duplicates(__isl_take isl_map *map);\n\n__isl_give isl_set *isl_set_normalize(__isl_take isl_set *set);\n\n__isl_give isl_basic_map *isl_basic_map_eliminate_vars(\n\t__isl_take isl_basic_map *bmap, unsigned pos, unsigned n);\n__isl_give isl_basic_set *isl_basic_set_eliminate_vars(\n\t__isl_take isl_basic_set *bset, unsigned pos, unsigned n);\n\n__isl_give isl_map *isl_map_eliminate(__isl_take isl_map *map,\n\tenum isl_dim_type type, unsigned first, unsigned n);\n__isl_give isl_set *isl_set_eliminate(__isl_take isl_set *set,\n\tenum isl_dim_type type, unsigned first, unsigned n);\n__isl_give isl_map *isl_map_project_onto(__isl_take isl_map *map,\n\tenum isl_dim_type type, unsigned first, unsigned n);\n\n__isl_give isl_basic_map *isl_basic_map_add_div_constraint(\n\t__isl_take isl_basic_map *bmap, unsigned div, int sign);\n__isl_give isl_basic_map *isl_basic_map_add_div_constraints(\n\t__isl_take isl_basic_map *bmap, unsigned div);\n__isl_give isl_basic_map *isl_basic_map_add_known_div_constraints(\n\t__isl_take isl_basic_map *bmap);\n__isl_give isl_basic_map *isl_basic_map_drop_redundant_divs(\n\t__isl_take isl_basic_map *bmap);\n\n__isl_give isl_basic_set *isl_basic_set_recession_cone(\n\t__isl_take isl_basic_set *bset);\n__isl_give isl_basic_set *isl_basic_set_lineality_space(\n\t__isl_take isl_basic_set *bset);\n__isl_give isl_basic_set *isl_set_combined_lineality_space(\n\t__isl_take isl_set *set);\n\n__isl_give isl_basic_set *isl_basic_set_set_integral(\n\t__isl_take isl_basic_set *bset);\n__isl_give isl_basic_set *isl_basic_set_set_rational(\n\t__isl_take isl_basic_set *bset);\n__isl_give isl_set *isl_set_set_rational(__isl_take isl_set *set);\n__isl_give isl_basic_map *isl_basic_map_set_rational(\n\t__isl_take isl_basic_map *bmap);\n__isl_give isl_map *isl_map_set_rational(__isl_take isl_map *map);\n\nisl_bool isl_map_is_rational(__isl_keep isl_map *map);\nisl_bool isl_set_is_rational(__isl_keep isl_set *set);\n\nisl_bool isl_map_has_rational(__isl_keep isl_map *map);\nisl_bool isl_set_has_rational(__isl_keep isl_set *set);\n\n__isl_give isl_basic_map *isl_basic_map_from_multi_aff2(\n\t__isl_take isl_multi_aff *maff, int rational);\n__isl_give isl_map *isl_map_from_multi_aff_internal(\n\t__isl_take isl_multi_aff *ma);\n__isl_give isl_map *isl_map_from_pw_aff_internal(__isl_take isl_pw_aff *pa);\n__isl_give isl_map *isl_map_from_pw_multi_aff_internal(\n\t__isl_take isl_pw_multi_aff *pma);\n\nstruct isl_mat;\n\n__isl_give isl_basic_set *isl_basic_set_preimage(\n\t__isl_take isl_basic_set *bset, __isl_take isl_mat *mat);\n__isl_give isl_set *isl_set_preimage(\n\t__isl_take isl_set *set, __isl_take isl_mat *mat);\n\n__isl_give isl_basic_map *isl_basic_map_transform_dims(\n\t__isl_take isl_basic_map *bmap, enum isl_dim_type type, unsigned first,\n\t__isl_take isl_mat *trans);\n__isl_give isl_basic_set *isl_basic_set_transform_dims(\n\t__isl_take isl_basic_set *bset, enum isl_dim_type type, unsigned first,\n\t__isl_take isl_mat *trans);\n\nisl_int *isl_set_wrap_facet(__isl_keep isl_set *set,\n\tisl_int *facet, isl_int *ridge);\n\nisl_bool isl_basic_map_contains_point(__isl_keep isl_basic_map *bmap,\n\t__isl_keep isl_point *point);\nisl_bool isl_set_contains_point(__isl_keep isl_set *set,\n\t__isl_keep isl_point *point);\n\nisl_stat isl_basic_set_vars_get_sign(__isl_keep isl_basic_set *bset,\n\tunsigned first, unsigned n, int *signs);\nisl_stat isl_set_foreach_orthant(__isl_keep isl_set *set,\n\tisl_stat (*fn)(__isl_take isl_set *orthant, int *signs, void *user),\n\tvoid *user);\n\nisl_bool isl_basic_set_eq_is_stride(__isl_keep isl_basic_set *bset, int i);\n\nisl_bool isl_basic_map_is_div_constraint(__isl_keep isl_basic_map *bmap,\n\tisl_int *constraint, unsigned div);\n\n__isl_give isl_basic_set *isl_basic_set_from_local_space(\n\t__isl_take isl_local_space *ls);\n__isl_give isl_basic_map *isl_basic_map_from_local_space(\n\t__isl_take isl_local_space *ls);\n__isl_give isl_basic_set *isl_basic_set_expand_divs(\n\t__isl_take isl_basic_set *bset, __isl_take isl_mat *div, int *exp);\n__isl_give isl_basic_map *isl_basic_map_expand_divs(\n\t__isl_take isl_basic_set *bmap, __isl_take isl_mat *div, int *exp);\n\nisl_size isl_basic_set_n_equality(__isl_keep isl_basic_set *bset);\nisl_size isl_basic_map_n_equality(__isl_keep isl_basic_map *bmap);\nisl_size isl_basic_set_n_inequality(__isl_keep isl_basic_set *bset);\nisl_size isl_basic_map_n_inequality(__isl_keep isl_basic_map *bmap);\n\n__isl_give isl_basic_map *isl_basic_map_mark_div_unknown(\n\t__isl_take isl_basic_map *bmap, int div);\nisl_bool isl_basic_map_div_is_marked_unknown(__isl_keep isl_basic_map *bmap,\n\tint div);\nisl_bool isl_basic_map_div_is_known(__isl_keep isl_basic_map *bmap, int div);\nint isl_basic_set_first_unknown_div(__isl_keep isl_basic_set *bset);\nint isl_basic_map_first_unknown_div(__isl_keep isl_basic_map *bmap);\nisl_bool isl_basic_map_divs_known(__isl_keep isl_basic_map *bmap);\nisl_bool isl_map_divs_known(__isl_keep isl_map *map);\n__isl_give isl_mat *isl_basic_set_get_divs(__isl_keep isl_basic_set *bset);\n__isl_give isl_mat *isl_basic_map_get_divs(__isl_keep isl_basic_map *bmap);\n\nisl_bool isl_set_every_basic_set(__isl_keep isl_set *set,\n\tisl_bool (*test)(__isl_keep isl_basic_set *bset, void *user),\n\tvoid *user);\n__isl_give isl_map *isl_map_inline_foreach_basic_map(__isl_take isl_map *map,\n\t__isl_give isl_basic_map *(*fn)(__isl_take isl_basic_map *bmap));\n\nisl_stat isl_basic_set_check_no_params(__isl_keep isl_basic_set *bset);\nisl_stat isl_basic_set_check_no_locals(__isl_keep isl_basic_set *bset);\n\nisl_stat isl_basic_set_check_range(__isl_keep isl_basic_set *bset,\n\tenum isl_dim_type type, unsigned first, unsigned n);\nisl_stat isl_set_check_range(__isl_keep isl_set *set,\n\tenum isl_dim_type type, unsigned first, unsigned n);\nisl_stat isl_basic_map_check_range(__isl_keep isl_basic_map *bmap,\n\tenum isl_dim_type type, unsigned first, unsigned n);\nisl_stat isl_map_check_named_params(__isl_keep isl_map *map);\n\nisl_bool isl_map_has_equal_params(__isl_keep isl_map *map1,\n\t__isl_keep isl_map *map2);\nisl_bool isl_basic_set_space_has_equal_params(__isl_keep isl_basic_set *bset,\n\t__isl_keep isl_space *space);\nisl_bool isl_set_space_has_equal_params(__isl_keep isl_set *set,\n\t__isl_keep isl_space *space);\nisl_bool isl_map_space_has_equal_params(__isl_keep isl_map *map,\n\t__isl_keep isl_space *space);\n\nisl_stat isl_map_align_params_bin(__isl_keep isl_map **map1,\n\t__isl_keep isl_map **map2);\nisl_stat isl_map_align_params_set(__isl_keep isl_map **map,\n\t__isl_keep isl_set **set);\nisl_bool isl_map_align_params_map_map_and_test(__isl_keep isl_map *map1,\n\t__isl_keep isl_map *map2,\n\tisl_bool (*fn)(__isl_keep isl_map *map1, __isl_keep isl_map *map2));\n\n__isl_give isl_set *isl_set_substitute(__isl_take isl_set *set,\n\tenum isl_dim_type type, unsigned pos, __isl_keep isl_aff *subs);\n\n__isl_give isl_set *isl_set_gist_params_basic_set(__isl_take isl_set *set,\n\t__isl_take isl_basic_set *context);\n\nisl_bool isl_map_compatible_range(__isl_keep isl_map *map,\n\t__isl_keep isl_set *set);\n\nisl_bool isl_basic_map_plain_is_non_empty(__isl_keep isl_basic_map *bmap);\nisl_bool isl_basic_map_plain_is_single_valued(__isl_keep isl_basic_map *bmap);\n\nisl_bool isl_map_is_set(__isl_keep isl_map *map);\nisl_bool isl_map_is_params(__isl_keep isl_map *map);\n\nisl_bool isl_basic_set_plain_dim_is_fixed(__isl_keep isl_basic_set *bset,\n\tunsigned dim, isl_int *val);\n\n__isl_give isl_set *isl_set_plain_gist_basic_set(__isl_take isl_set *set,\n\t__isl_take isl_basic_set *context);\n__isl_give isl_map *isl_map_plain_gist_basic_map(__isl_take isl_map *map,\n\t__isl_take isl_basic_map *context);\n__isl_give isl_map *isl_map_plain_gist(__isl_take isl_map *map,\n\t__isl_take isl_map *context);\n\n__isl_give isl_basic_set *isl_basic_set_plain_affine_hull(\n\t__isl_take isl_basic_set *bset);\n__isl_give isl_basic_map *isl_basic_map_plain_affine_hull(\n\t__isl_take isl_basic_map *bmap);\n\nisl_stat isl_basic_set_dim_residue_class(__isl_keep isl_basic_set *bset,\n\tint pos, isl_int *modulo, isl_int *residue);\nisl_stat isl_set_dim_residue_class(__isl_keep isl_set *set,\n\tint pos, isl_int *modulo, isl_int *residue);\n\n__isl_give isl_basic_set *isl_basic_set_fix(__isl_take isl_basic_set *bset,\n\tenum isl_dim_type type, unsigned pos, isl_int value);\n__isl_give isl_basic_map *isl_basic_map_fix(__isl_take isl_basic_map *bmap,\n\tenum isl_dim_type type, unsigned pos, isl_int value);\n__isl_give isl_set *isl_set_fix(__isl_take isl_set *set,\n\tenum isl_dim_type type, unsigned pos, isl_int value);\nisl_bool isl_map_plain_is_fixed(__isl_keep isl_map *map,\n\tenum isl_dim_type type, unsigned pos, isl_int *val);\n\nint isl_basic_map_output_defining_equality(__isl_keep isl_basic_map *bmap,\n\tint pos, int *div, int *ineq);\n\n__isl_give isl_basic_map *isl_basic_map_reduce_coefficients(\n\t__isl_take isl_basic_map *bmap);\n\n__isl_give isl_basic_map *isl_basic_map_shift_div(\n\t__isl_take isl_basic_map *bmap, int div, int pos, isl_int shift);\n\nint isl_basic_set_count_upto(__isl_keep isl_basic_set *bset,\n\tisl_int max, isl_int *count);\nint isl_set_count_upto(__isl_keep isl_set *set, isl_int max, isl_int *count);\n\nisl_bool isl_map_space_tuple_is_equal(__isl_keep isl_map *map,\n\tenum isl_dim_type type1, __isl_keep isl_space *space,\n\tenum isl_dim_type type2);\nisl_bool isl_map_tuple_is_equal(__isl_keep isl_map *map1,\n\tenum isl_dim_type type1, __isl_keep isl_map *map2,\n\tenum isl_dim_type type2);\nisl_bool isl_map_has_space(__isl_keep isl_map *map,\n\t__isl_keep isl_space *space);\nisl_bool isl_map_has_space_tuples(__isl_keep isl_map *map,\n\t__isl_keep isl_space *space);\n\nisl_bool isl_basic_map_is_transformation(__isl_keep isl_basic_map *bmap);\nisl_stat isl_map_check_transformation(__isl_keep isl_map *map);\nisl_stat isl_basic_set_check_equal_space(__isl_keep isl_basic_set *bset1,\n\t__isl_keep isl_basic_set *bset2);\nisl_stat isl_basic_map_check_equal_space(__isl_keep isl_basic_map *bmap1,\n\t__isl_keep isl_basic_map *bmap2);\nisl_stat isl_set_basic_set_check_equal_space(__isl_keep isl_set *set,\n\t__isl_keep isl_basic_set *bset);\nisl_stat isl_map_basic_map_check_equal_space(__isl_keep isl_map *map,\n\t__isl_keep isl_basic_map *bmap);\nisl_stat isl_map_check_equal_space(__isl_keep isl_map *map1,\n\t__isl_keep isl_map *map2);\n\nisl_bool isl_basic_map_applies_range(__isl_keep isl_basic_map *bmap1,\n\t__isl_keep isl_basic_map *bmap2);\n\n__isl_give isl_mat *isl_basic_set_extract_equalities(\n\t__isl_keep isl_basic_set *bset);\n\nisl_bool isl_basic_map_equal_div_expr_part(__isl_keep isl_basic_map *bmap1,\n\tint pos1, __isl_keep isl_basic_map *bmap2, int pos2,\n\tunsigned first, unsigned n);\nisl_bool isl_basic_map_equal_div_expr_except_constant(\n\t__isl_keep isl_basic_map *bmap1, int pos1,\n\t__isl_keep isl_basic_map *bmap2, int pos2);\n__isl_give isl_basic_map *isl_basic_map_set_div_expr_constant_num_si_inplace(\n\t__isl_take isl_basic_map *bmap, int div, int value);\n\n#endif\n"}, "18": {"id": 18, "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_mat_private.h", "content": "#ifndef ISL_MAT_PRIVATE_H\n#define ISL_MAT_PRIVATE_H\n\n#include <isl/mat.h>\n#include <isl_blk.h>\n\nstruct isl_mat {\n\tint ref;\n\n\tstruct isl_ctx *ctx;\n\n#define ISL_MAT_BORROWED\t\t(1 << 0)\n\tunsigned flags;\n\n\tunsigned n_row;\n\tunsigned n_col;\n\n\tisl_int **row;\n\n\t/* actual size of the rows in memory; n_col <= max_col */\n\tunsigned max_col;\n\n\tstruct isl_blk block;\n};\n\nuint32_t isl_mat_get_hash(__isl_keep isl_mat *mat);\n\n__isl_give isl_mat *isl_mat_zero(isl_ctx *ctx, unsigned n_row, unsigned n_col);\n__isl_give isl_mat *isl_mat_dup(__isl_keep isl_mat *mat);\n__isl_give isl_mat *isl_mat_cow(__isl_take isl_mat *mat);\n__isl_give isl_mat *isl_mat_sub_alloc(__isl_keep isl_mat *mat,\n\tunsigned first_row, unsigned n_row, unsigned first_col, unsigned n_col);\n__isl_give isl_mat *isl_mat_sub_alloc6(isl_ctx *ctx, isl_int **row,\n\tunsigned first_row, unsigned n_row, unsigned first_col, unsigned n_col);\nvoid isl_mat_sub_copy(struct isl_ctx *ctx, isl_int **dst, isl_int **src,\n\tunsigned n_row, unsigned dst_col, unsigned src_col, unsigned n_col);\nvoid isl_mat_sub_neg(struct isl_ctx *ctx, isl_int **dst, isl_int **src,\n\tunsigned n_row, unsigned dst_col, unsigned src_col, unsigned n_col);\nisl_stat isl_mat_sub_transform(isl_int **row, unsigned n_row,\n\tunsigned first_col, __isl_take isl_mat *mat);\n__isl_give isl_mat *isl_mat_diag(isl_ctx *ctx, unsigned n_row, isl_int d);\n\n__isl_give isl_mat *isl_mat_reverse_gauss(__isl_take isl_mat *mat);\n\n__isl_give isl_mat *isl_mat_scale(__isl_take isl_mat *mat, isl_int m);\n__isl_give isl_mat *isl_mat_scale_down_row(__isl_take isl_mat *mat, int row,\n\tisl_int m);\n\n__isl_give isl_vec *isl_mat_get_row(__isl_keep isl_mat *mat, unsigned row);\n\n__isl_give isl_mat *isl_mat_lexnonneg_rows(__isl_take isl_mat *mat);\n\nisl_bool isl_mat_is_scaled_identity(__isl_keep isl_mat *mat);\n\nisl_stat isl_mat_row_gcd(__isl_keep isl_mat *mat, int row, isl_int *gcd);\n\nvoid isl_mat_col_mul(__isl_keep isl_mat *mat, int dst_col, isl_int f,\n\tint src_col);\nvoid isl_mat_col_submul(__isl_keep isl_mat *mat,\n\t\t\tint dst_col, isl_int f, int src_col);\n__isl_give isl_mat *isl_mat_col_addmul(__isl_take isl_mat *mat, int dst_col,\n\tisl_int f, int src_col);\n__isl_give isl_mat *isl_mat_col_neg(__isl_take isl_mat *mat, int col);\n__isl_give isl_mat *isl_mat_row_neg(__isl_take isl_mat *mat, int row);\n\nint isl_mat_get_element(__isl_keep isl_mat *mat, int row, int col, isl_int *v);\n__isl_give isl_mat *isl_mat_set_element(__isl_take isl_mat *mat,\n\tint row, int col, isl_int v);\n\n#endif\n"}, "19": {"id": 19, "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_morph.h", "content": "/*\n * Copyright 2010      INRIA Saclay\n *\n * Use of this software is governed by the MIT license\n *\n * Written by Sven Verdoolaege, INRIA Saclay - Ile-de-France,\n * Parc Club Orsay Universite, ZAC des vignes, 4 rue Jacques Monod,\n * 91893 Orsay, France \n */\n\n#ifndef ISL_MORHP_H\n#define ISL_MORHP_H\n\n#include <stdio.h>\n#include <isl/id_type.h>\n#include <isl/space.h>\n#include <isl/mat.h>\n#include <isl/set.h>\n\n#if defined(__cplusplus)\nextern \"C\" {\n#endif\n\n/* An isl_morph is a \"morphism\" on (basic) sets.\n * \"map\" is an affine mapping from \"dom\" to \"ran\"\n * and \"inv\" is the inverse mapping.\n */\nstruct isl_morph {\n\tint ref;\n\n\tisl_basic_set *dom;\n\tisl_basic_set *ran;\n\n\tisl_mat *map;\n\tisl_mat *inv;\n};\ntypedef struct isl_morph isl_morph;\n\nisl_ctx *isl_morph_get_ctx(__isl_keep isl_morph *morph);\n\n__isl_give isl_morph *isl_morph_alloc(\n\t__isl_take isl_basic_set *dom, __isl_take isl_basic_set *ran,\n\t__isl_take isl_mat *map, __isl_take isl_mat *inv);\n__isl_give isl_morph *isl_morph_copy(__isl_keep isl_morph *morph);\n__isl_give isl_morph *isl_morph_identity(__isl_keep isl_basic_set *bset);\n__isl_null isl_morph *isl_morph_free(__isl_take isl_morph *morph);\n\nisl_stat isl_morph_check_applies(__isl_keep isl_morph *morph,\n\t__isl_keep isl_space *space);\n\n__isl_give isl_space *isl_morph_get_dom_space(__isl_keep isl_morph *morph);\n__isl_give isl_space *isl_morph_get_ran_space(__isl_keep isl_morph *morph);\n__isl_give isl_multi_aff *isl_morph_get_var_multi_aff(\n\t__isl_keep isl_morph *morph);\nisl_size isl_morph_dom_dim(__isl_keep isl_morph *morph, enum isl_dim_type type);\nisl_size isl_morph_ran_dim(__isl_keep isl_morph *morph, enum isl_dim_type type);\n\n__isl_give isl_morph *isl_morph_remove_dom_dims(__isl_take isl_morph *morph,\n\tenum isl_dim_type type, unsigned first, unsigned n);\n__isl_give isl_morph *isl_morph_remove_ran_dims(__isl_take isl_morph *morph,\n\tenum isl_dim_type type, unsigned first, unsigned n);\n__isl_give isl_morph *isl_morph_dom_params(__isl_take isl_morph *morph);\n__isl_give isl_morph *isl_morph_ran_params(__isl_take isl_morph *morph);\n\n__isl_give isl_morph *isl_morph_compose(__isl_take isl_morph *morph1,\n\t__isl_take isl_morph *morph2);\n__isl_give isl_morph *isl_morph_inverse(__isl_take isl_morph *morph);\n\nvoid isl_morph_print_internal(__isl_take isl_morph *morph, FILE *out);\nvoid isl_morph_dump(__isl_take isl_morph *morph);\n\n__isl_give isl_morph *isl_basic_set_variable_compression(\n\t__isl_keep isl_basic_set *bset, enum isl_dim_type type);\n__isl_give isl_morph *isl_basic_set_variable_compression_with_id(\n\t__isl_keep isl_basic_set *bset, __isl_keep isl_id *id);\n__isl_give isl_morph *isl_basic_set_parameter_compression(\n\t__isl_keep isl_basic_set *bset);\n__isl_give isl_morph *isl_basic_set_full_compression(\n\t__isl_keep isl_basic_set *bset);\n\n__isl_give isl_basic_set *isl_morph_basic_set(__isl_take isl_morph *morph,\n\t__isl_take isl_basic_set *bset);\n__isl_give isl_set *isl_morph_set(__isl_take isl_morph *morph,\n\t__isl_take isl_set *set);\n__isl_give isl_vec *isl_morph_vec(__isl_take isl_morph *morph,\n\t__isl_take isl_vec *vec);\n\n#if defined(__cplusplus)\n}\n#endif\n\n#endif\n"}, "20": {"id": 20, "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_multi_macro.h", "content": "#undef EL_BASE\n#define EL_BASE BASE\n#include <isl_list_macro.h>\n\n#define xMULTI(BASE) isl_multi_ ## BASE\n#define MULTI(BASE) xMULTI(BASE)\n#undef DOM\n#define DOM CAT(isl_,DOMBASE)\n"}, "21": {"id": 21, "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_multi_templ.h", "content": "#include <isl/space.h>\n\n#include <isl_multi_macro.h>\n\n/* A multiple expression with base expressions of type EL.\n *\n * \"space\" is the space in which the multiple expression lives.\n * \"n\" is the number of base expression and is equal\n * to the output or set dimension of \"space\".\n * \"p\" is an array of size \"n\" of base expressions.\n * The array is only accessible when n > 0.\n * \"dom\" is the explicit domain, if present\n * The explicit domain is only accessible when n == 0.\n */\nstruct MULTI(BASE) {\n\tint ref;\n\tisl_space *space;\n\n\tint n;\n\tstruct {\n#ifdef EXPLICIT_DOMAIN\n\t\tDOM *dom;\n#endif\n\t\tEL *p[1];\n\t} u;\n};\n\n__isl_give MULTI(BASE) *CAT(MULTI(BASE),_alloc)(__isl_take isl_space *space);\n__isl_keep isl_space *FN(MULTI(BASE),peek_space)(__isl_keep MULTI(BASE) *multi);\n\n#ifdef EXPLICIT_DOMAIN\nisl_bool CAT(MULTI(BASE),_has_non_trivial_domain)(\n\t__isl_keep MULTI(BASE) *multi);\n#endif\n"}, "22": {"id": 22, "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_polynomial_private.h", "content": "#include <stdio.h>\n#include <isl_int.h>\n#include <isl/map.h>\n#include <isl/mat.h>\n#include <isl_morph.h>\n#include <isl/polynomial.h>\n#include <isl_reordering.h>\n#include \"isl_list_private.h\"\n\nstruct isl_poly {\n\tint ref;\n\tstruct isl_ctx *ctx;\n\n\tint var;\n};\ntypedef struct isl_poly isl_poly;\n\nstruct isl_poly_cst {\n\tstruct isl_poly poly;\n\tisl_int n;\n\tisl_int d;\n};\ntypedef struct isl_poly_cst isl_poly_cst;\n\nstruct isl_poly_rec {\n\tstruct isl_poly poly;\n\tint n;\n\n\tsize_t size;\n\tisl_poly *p[];\n};\ntypedef struct isl_poly_rec isl_poly_rec;\n\n/* dim represents the domain space.\n */\nstruct isl_qpolynomial {\n\tint ref;\n\n\tisl_space *dim;\n\tstruct isl_mat *div;\n\tisl_poly *poly;\n};\n\n#undef EL\n#define EL isl_qpolynomial\n\n#include <isl_list_templ.h>\n\nstruct isl_term {\n\tint ref;\n\n\tisl_int n;\n\tisl_int d;\n\n\tisl_space *dim;\n\tstruct isl_mat *div;\n\n\tint pow[1];\n};\n\nstruct isl_pw_qpolynomial_piece {\n\tstruct isl_set *set;\n\tstruct isl_qpolynomial *qp;\n};\n\nstruct isl_pw_qpolynomial {\n\tint ref;\n\n\tisl_space *dim;\n\n\tint n;\n\n\tsize_t size;\n\tstruct isl_pw_qpolynomial_piece p[1];\n};\n\n#undef PW\n#define PW isl_pw_qpolynomial\n\n#include <isl_pw_templ.h>\n\n#undef EL\n#define EL isl_pw_qpolynomial\n\n#include <isl_list_templ.h>\n\n/* dim represents the domain space.\n */\nstruct isl_qpolynomial_fold {\n\tint ref;\n\n\tenum isl_fold type;\n\tisl_space *dim;\n\n\tisl_qpolynomial_list *list;\n};\n\nstruct isl_pw_qpolynomial_fold_piece {\n\tstruct isl_set *set;\n\tstruct isl_qpolynomial_fold *fold;\n};\n\nstruct isl_pw_qpolynomial_fold {\n\tint ref;\n\n\tenum isl_fold type;\n\tisl_space *dim;\n\n\tint n;\n\n\tsize_t size;\n\tstruct isl_pw_qpolynomial_fold_piece p[1];\n};\n\n#undef PW\n#define PW isl_pw_qpolynomial_fold\n\n#include <isl_pw_templ.h>\n\n#undef EL\n#define EL isl_pw_qpolynomial_fold\n\n#include <isl_list_templ.h>\n\nvoid isl_term_get_num(__isl_keep isl_term *term, isl_int *n);\n\n__isl_give isl_poly *isl_poly_zero(struct isl_ctx *ctx);\n__isl_give isl_poly *isl_poly_copy(__isl_keep isl_poly *poly);\n__isl_give isl_poly *isl_poly_cow(__isl_take isl_poly *poly);\n__isl_give isl_poly *isl_poly_dup(__isl_keep isl_poly *poly);\n__isl_null isl_poly *isl_poly_free(__isl_take isl_poly *poly);\n__isl_give struct isl_poly *isl_poly_mul(__isl_take struct isl_poly *poly1,\n\t__isl_take struct isl_poly *poly2);\n\nisl_bool isl_poly_is_cst(__isl_keep isl_poly *poly);\nisl_bool isl_poly_is_zero(__isl_keep isl_poly *poly);\nisl_bool isl_poly_is_one(__isl_keep isl_poly *poly);\nisl_bool isl_poly_is_negone(__isl_keep isl_poly *poly);\n__isl_keep isl_poly_cst *isl_poly_as_cst(__isl_keep isl_poly *poly);\n__isl_keep isl_poly_rec *isl_poly_as_rec(__isl_keep isl_poly *poly);\n\n__isl_give isl_poly *isl_poly_sum(__isl_take isl_poly *poly1,\n\t__isl_take isl_poly *poly2);\n__isl_give struct isl_poly *isl_poly_mul_isl_int(\n\t__isl_take isl_poly *poly, isl_int v);\n\n__isl_give isl_qpolynomial *isl_qpolynomial_alloc(__isl_take isl_space *space,\n\tunsigned n_div, __isl_take isl_poly *poly);\n__isl_give isl_qpolynomial *isl_qpolynomial_cow(__isl_take isl_qpolynomial *qp);\n__isl_give isl_qpolynomial *isl_qpolynomial_dup(__isl_keep isl_qpolynomial *qp);\n\n__isl_give isl_qpolynomial *isl_qpolynomial_cst_on_domain(\n\t__isl_take isl_space *domain,\n\tisl_int v);\n__isl_give isl_qpolynomial *isl_qpolynomial_rat_cst_on_domain(\n\t__isl_take isl_space *domain, const isl_int n, const isl_int d);\n__isl_give isl_qpolynomial *isl_qpolynomial_var_pow_on_domain(\n\t__isl_take isl_space *domain,\n\tint pos, int power);\nisl_bool isl_qpolynomial_is_one(__isl_keep isl_qpolynomial *qp);\nisl_bool isl_qpolynomial_is_affine(__isl_keep isl_qpolynomial *qp);\nisl_bool isl_qpolynomial_is_cst(__isl_keep isl_qpolynomial *qp,\n\tisl_int *n, isl_int *d);\n\nunsigned isl_qpolynomial_domain_offset(__isl_keep isl_qpolynomial *qp,\n\tenum isl_dim_type type);\n\n__isl_give isl_qpolynomial *isl_qpolynomial_add_on_domain(\n\t__isl_keep isl_set *dom,\n\t__isl_take isl_qpolynomial *qp1,\n\t__isl_take isl_qpolynomial *qp2);\n\nint isl_qpolynomial_plain_cmp(__isl_keep isl_qpolynomial *qp1,\n\t__isl_keep isl_qpolynomial *qp2);\n\nint isl_qpolynomial_degree(__isl_keep isl_qpolynomial *poly);\n__isl_give isl_qpolynomial *isl_qpolynomial_coeff(\n\t__isl_keep isl_qpolynomial *poly,\n\tenum isl_dim_type type, unsigned pos, int deg);\n\n__isl_give isl_vec *isl_qpolynomial_extract_affine(\n\t__isl_keep isl_qpolynomial *qp);\n__isl_give isl_qpolynomial *isl_qpolynomial_from_affine(\n\t__isl_take isl_space *space, isl_int *f, isl_int denom);\n\n__isl_give isl_pw_qpolynomial *isl_pw_qpolynomial_cow(\n\t__isl_take isl_pw_qpolynomial *pwqp);\n\n__isl_give isl_pw_qpolynomial *isl_pw_qpolynomial_add_piece(\n\t__isl_take isl_pw_qpolynomial *pwqp,\n\t__isl_take isl_set *set, __isl_take isl_qpolynomial *qp);\nint isl_pw_qpolynomial_is_one(__isl_keep isl_pw_qpolynomial *pwqp);\n\n__isl_give isl_pw_qpolynomial *isl_pw_qpolynomial_project_out(\n\t__isl_take isl_pw_qpolynomial *pwqp,\n\tenum isl_dim_type type, unsigned first, unsigned n);\n\n__isl_give isl_val *isl_qpolynomial_opt_on_domain(\n\t__isl_take isl_qpolynomial *qp, __isl_take isl_set *set, int max);\n\nenum isl_fold isl_fold_type_negate(enum isl_fold type);\n\n__isl_give isl_qpolynomial_fold *isl_qpolynomial_fold_cow(\n\t__isl_take isl_qpolynomial_fold *fold);\n__isl_give isl_qpolynomial_fold *isl_qpolynomial_fold_dup(\n\t__isl_keep isl_qpolynomial_fold *fold);\n\n__isl_keep isl_qpolynomial_list *isl_qpolynomial_fold_peek_list(\n\t__isl_keep isl_qpolynomial_fold *fold);\n\n__isl_give isl_pw_qpolynomial_fold *isl_pw_qpolynomial_fold_cow(\n\t__isl_take isl_pw_qpolynomial_fold *pwf);\n\n__isl_give isl_qpolynomial_fold *isl_qpolynomial_fold_add_on_domain(\n\t__isl_keep isl_set *set,\n\t__isl_take isl_qpolynomial_fold *fold1,\n\t__isl_take isl_qpolynomial_fold *fold2);\n__isl_give isl_qpolynomial_fold *isl_qpolynomial_fold_fold_on_domain(\n\t__isl_keep isl_set *set,\n\t__isl_take isl_qpolynomial_fold *fold1,\n\t__isl_take isl_qpolynomial_fold *fold2);\n\nint isl_qpolynomial_fold_plain_cmp(__isl_keep isl_qpolynomial_fold *fold1,\n\t__isl_keep isl_qpolynomial_fold *fold2);\n\n__isl_give isl_val *isl_qpolynomial_fold_opt_on_domain(\n\t__isl_take isl_qpolynomial_fold *fold, __isl_take isl_set *set, int max);\n\nisl_bool isl_pw_qpolynomial_fold_covers(\n\t__isl_keep isl_pw_qpolynomial_fold *pwf1,\n\t__isl_keep isl_pw_qpolynomial_fold *pwf2);\n\n__isl_give isl_qpolynomial *isl_qpolynomial_morph_domain(\n\t__isl_take isl_qpolynomial *qp, __isl_take isl_morph *morph);\n__isl_give isl_pw_qpolynomial *isl_pw_qpolynomial_morph_domain(\n\t__isl_take isl_pw_qpolynomial *pwqp, __isl_take isl_morph *morph);\n__isl_give isl_qpolynomial_fold *isl_qpolynomial_fold_morph_domain(\n\t__isl_take isl_qpolynomial_fold *fold, __isl_take isl_morph *morph);\n__isl_give isl_pw_qpolynomial_fold *isl_pw_qpolynomial_fold_morph_domain(\n\t__isl_take isl_pw_qpolynomial_fold *pwf, __isl_take isl_morph *morph);\n\n__isl_give isl_qpolynomial *isl_qpolynomial_lift(__isl_take isl_qpolynomial *qp,\n\t__isl_take isl_space *space);\n__isl_give isl_qpolynomial_fold *isl_qpolynomial_fold_lift(\n\t__isl_take isl_qpolynomial_fold *fold, __isl_take isl_space *space);\n\n__isl_give isl_qpolynomial *isl_qpolynomial_substitute_equalities(\n\t__isl_take isl_qpolynomial *qp, __isl_take isl_basic_set *eq);\n__isl_give isl_qpolynomial_fold *isl_qpolynomial_fold_substitute_equalities(\n\t__isl_take isl_qpolynomial_fold *fold, __isl_take isl_basic_set *eq);\n__isl_give isl_qpolynomial_fold *isl_qpolynomial_fold_gist(\n\t__isl_take isl_qpolynomial_fold *fold, __isl_take isl_set *context);\n\n__isl_give isl_qpolynomial *isl_qpolynomial_realign_domain(\n\t__isl_take isl_qpolynomial *qp, __isl_take isl_reordering *r);\n__isl_give isl_qpolynomial_fold *isl_qpolynomial_fold_realign_domain(\n\t__isl_take isl_qpolynomial_fold *fold, __isl_take isl_reordering *r);\n__isl_give isl_pw_qpolynomial *isl_pw_qpolynomial_realign_domain(\n\t__isl_take isl_pw_qpolynomial *pwqp, __isl_take isl_reordering *r);\n__isl_give isl_pw_qpolynomial_fold *isl_pw_qpolynomial_fold_realign_domain(\n\t__isl_take isl_pw_qpolynomial_fold *pwf, __isl_take isl_reordering *r);\n\n__isl_give isl_pw_qpolynomial *isl_pw_qpolynomial_reset_space(\n\t__isl_take isl_pw_qpolynomial *pwqp, __isl_take isl_space *space);\n__isl_give isl_qpolynomial *isl_qpolynomial_reset_domain_space(\n\t__isl_take isl_qpolynomial *qp, __isl_take isl_space *space);\n__isl_give isl_qpolynomial *isl_qpolynomial_reset_space_and_domain(\n\t__isl_take isl_qpolynomial *qp, __isl_take isl_space *space,\n\t__isl_take isl_space *domain);\n__isl_give isl_qpolynomial_fold *isl_qpolynomial_fold_reset_domain_space(\n\t__isl_take isl_qpolynomial_fold *fold, __isl_take isl_space *space);\n__isl_give isl_qpolynomial_fold *isl_qpolynomial_fold_reset_space_and_domain(\n\t__isl_take isl_qpolynomial_fold *fold, __isl_take isl_space *space,\n\t__isl_take isl_space *domain);\n__isl_give isl_pw_qpolynomial_fold *isl_pw_qpolynomial_fold_reset_domain_space(\n\t__isl_take isl_pw_qpolynomial_fold *pwf, __isl_take isl_space *space);\n\n__isl_give isl_val *isl_qpolynomial_get_den(__isl_keep isl_qpolynomial *qp);\n__isl_give isl_qpolynomial *isl_qpolynomial_add_isl_int(\n\t__isl_take isl_qpolynomial *qp, isl_int v);\n__isl_give isl_qpolynomial *isl_qpolynomial_mul_isl_int(\n\t__isl_take isl_qpolynomial *qp, isl_int v);\n__isl_give isl_pw_qpolynomial *isl_pw_qpolynomial_mul_isl_int(\n\t__isl_take isl_pw_qpolynomial *pwqp, isl_int v);\n\n__isl_give isl_qpolynomial_fold *isl_qpolynomial_fold_scale(\n\t__isl_take isl_qpolynomial_fold *fold, isl_int v);\n\n__isl_give isl_qpolynomial_fold *isl_qpolynomial_fold_mul_isl_int(\n\t__isl_take isl_qpolynomial_fold *fold, isl_int v);\n__isl_give isl_pw_qpolynomial_fold *isl_pw_qpolynomial_fold_mul_isl_int(\n\t__isl_take isl_pw_qpolynomial_fold *pwf, isl_int v);\n__isl_give isl_union_pw_qpolynomial *isl_union_pw_qpolynomial_mul_isl_int(\n\t__isl_take isl_union_pw_qpolynomial *upwqp, isl_int v);\n__isl_give isl_union_pw_qpolynomial_fold *\nisl_union_pw_qpolynomial_fold_mul_isl_int(\n\t__isl_take isl_union_pw_qpolynomial_fold *upwf, isl_int v);\n\nISL_DECLARE_LIST_FN_PRIVATE(qpolynomial)\n"}, "23": {"id": 23, "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_pw_macro.h", "content": "#define xCAT(A,B) A ## B\n#define CAT(A,B) xCAT(A,B)\n#undef EL\n#define EL CAT(isl_,BASE)\n#define xFN(TYPE,NAME) TYPE ## _ ## NAME\n#define FN(TYPE,NAME) xFN(TYPE,NAME)\n#define xS(TYPE,NAME) struct TYPE ## _ ## NAME\n#define S(TYPE,NAME) xS(TYPE,NAME)\n"}, "24": {"id": 24, "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_pw_templ.h", "content": "#include <isl/space.h>\n\n#include <isl_pw_macro.h>\n\n__isl_keep isl_space *FN(PW,peek_space)(__isl_keep PW *pw);\n"}, "25": {"id": 25, "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_reordering.h", "content": "#ifndef ISL_REORDERING_H\n#define ISL_REORDERING_H\n\n#include <isl/space.h>\n\n/* pos maps original dimensions to new dimensions.\n * The final space is given by \"space\".\n * The number of dimensions (i.e., the range of values) in the result\n * may be larger than the number of dimensions in the input.\n * In particular, the possible values of the entries in pos ranges from 0 to\n * the total dimension of dim - 1, unless isl_reordering_extend\n * has been called.\n */\nstruct isl_reordering {\n\tint ref;\n\tisl_space *space;\n\tunsigned len;\n\tint pos[1];\n};\ntypedef struct isl_reordering isl_reordering;\n\nisl_ctx *isl_reordering_get_ctx(__isl_keep isl_reordering *r);\n__isl_keep isl_space *isl_reordering_peek_space(__isl_keep isl_reordering *r);\n__isl_give isl_space *isl_reordering_get_space(__isl_keep isl_reordering *r);\n__isl_give isl_reordering *isl_parameter_alignment_reordering(\n\t__isl_keep isl_space *alignee, __isl_keep isl_space *aligner);\n__isl_give isl_reordering *isl_reordering_unbind_params_insert_domain(\n\t__isl_keep isl_space *space, __isl_keep isl_multi_id *tuple);\n__isl_give isl_reordering *isl_reordering_copy(__isl_keep isl_reordering *exp);\n__isl_null isl_reordering *isl_reordering_free(__isl_take isl_reordering *exp);\n__isl_give isl_reordering *isl_reordering_extend_space(\n\t__isl_take isl_reordering *exp, __isl_take isl_space *space);\n__isl_give isl_reordering *isl_reordering_extend(__isl_take isl_reordering *exp,\n\tunsigned extra);\n\n#endif\n"}, "26": {"id": 26, "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_seq.h", "content": "/*\n * Copyright 2008-2009 Katholieke Universiteit Leuven\n *\n * Use of this software is governed by the MIT license\n *\n * Written by Sven Verdoolaege, K.U.Leuven, Departement\n * Computerwetenschappen, Celestijnenlaan 200A, B-3001 Leuven, Belgium\n */\n\n#ifndef ISL_SEQ_H\n#define ISL_SEQ_H\n\n#include <sys/types.h>\n#include <isl_int.h>\n#include <isl/ctx.h>\n\n#if defined(__cplusplus)\nextern \"C\" {\n#endif\n\n/* Some common operations on sequences of isl_int's */\n\nvoid isl_seq_clr(isl_int *p, unsigned len);\nvoid isl_seq_set(isl_int *p, isl_int v, unsigned len);\nvoid isl_seq_set_si(isl_int *p, int v, unsigned len);\nvoid isl_seq_neg(isl_int *dst, isl_int *src, unsigned len);\nvoid isl_seq_cpy(isl_int *dst, isl_int *src, unsigned len);\nvoid isl_seq_addmul(isl_int *dst, isl_int f, isl_int *src, unsigned len);\nvoid isl_seq_submul(isl_int *dst, isl_int f, isl_int *src, unsigned len);\nvoid isl_seq_swp_or_cpy(isl_int *dst, isl_int *src, unsigned len);\nvoid isl_seq_scale(isl_int *dst, isl_int *src, isl_int f, unsigned len);\nvoid isl_seq_scale_down(isl_int *dst, isl_int *src, isl_int f, unsigned len);\nvoid isl_seq_cdiv_q(isl_int *dst, isl_int *src, isl_int m, unsigned len);\nvoid isl_seq_fdiv_q(isl_int *dst, isl_int *src, isl_int m, unsigned len);\nvoid isl_seq_fdiv_r(isl_int *dst, isl_int *src, isl_int m, unsigned len);\nvoid isl_seq_combine(isl_int *dst, isl_int m1, isl_int *src1,\n\t\t\tisl_int m2, isl_int *src2, unsigned len);\nvoid isl_seq_elim(isl_int *dst, isl_int *src, unsigned pos, unsigned len,\n\t\t  isl_int *m);\nvoid isl_seq_abs_max(isl_int *p, unsigned len, isl_int *max);\nvoid isl_seq_gcd(isl_int *p, unsigned len, isl_int *gcd);\nvoid isl_seq_lcm(isl_int *p, unsigned len, isl_int *lcm);\nvoid isl_seq_normalize(struct isl_ctx *ctx, isl_int *p, unsigned len);\nvoid isl_seq_inner_product(isl_int *p1, isl_int *p2, unsigned len,\n\t\t\t   isl_int *prod);\nint isl_seq_first_non_zero(isl_int *p, unsigned len);\nint isl_seq_last_non_zero(isl_int *p, unsigned len);\nint isl_seq_abs_min_non_zero(isl_int *p, unsigned len);\nint isl_seq_eq(isl_int *p1, isl_int *p2, unsigned len);\nint isl_seq_cmp(isl_int *p1, isl_int *p2, unsigned len);\nint isl_seq_is_neg(isl_int *p1, isl_int *p2, unsigned len);\n\nvoid isl_seq_substitute(isl_int *p, int pos, isl_int *subs,\n\tint p_len, int subs_len, isl_int v);\n\nuint32_t isl_seq_get_hash(isl_int *p, unsigned len);\nuint32_t isl_seq_get_hash_bits(isl_int *p, unsigned len, unsigned bits);\n\n#if defined(__cplusplus)\n}\n#endif\n\n#endif\n"}, "27": {"id": 27, "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_stream_private.h", "content": "#include <isl_int.h>\n#include <isl/stream.h>\n#include <isl_yaml.h>\n\nstruct isl_token {\n\tint type;\n\n\tunsigned int on_new_line : 1;\n\tunsigned is_keyword : 1;\n\tint line;\n\tint col;\n\n\tunion {\n\t\tisl_int\tv;\n\t\tchar\t*s;\n\t\tisl_map *map;\n\t\tisl_pw_aff *pwaff;\n\t} u;\n};\n\nstruct isl_token *isl_token_new(isl_ctx *ctx,\n\tint line, int col, unsigned on_new_line);\n\n/* An input stream that may be either a file or a string.\n *\n * line and col are the line and column number of the next character (1-based).\n * start_line and start_col are set by isl_stream_getc to point\n * to the position of the returned character.\n * last_line is the line number of the previous token.\n *\n * yaml_state and yaml_indent keep track of the currently active YAML\n * elements.  yaml_size is the size of these arrays, while yaml_depth\n * is the number of elements currently in use.\n * yaml_state and yaml_indent may be NULL if no YAML parsing is being\n * performed.\n * yaml_state keeps track of what is expected next at each level.\n * yaml_indent keeps track of the indentation at each level, with\n * ISL_YAML_INDENT_FLOW meaning that the element is in flow format\n * (such that the indentation is not relevant).\n */\nstruct isl_stream {\n\tstruct isl_ctx\t*ctx;\n\tFILE        \t*file;\n\tconst char  \t*str;\n\tint\t    \tline;\n\tint\t    \tcol;\n\tint\t\tstart_line;\n\tint\t\tstart_col;\n\tint\t\tlast_line;\n\tint\t    \teof;\n\n\tchar\t    \t*buffer;\n\tsize_t\t    \tsize;\n\tsize_t\t    \tlen;\n\tint\t    \tc;\n\tint\t\tun[5];\n\tint\t\tn_un;\n\n\tstruct isl_token\t*tokens[5];\n\tint\t    \tn_token;\n\n\tstruct isl_hash_table\t*keywords;\n\tenum isl_token_type\t next_type;\n\n\tint\t\t\tyaml_depth;\n\tint\t\t\tyaml_size;\n\tenum isl_yaml_state\t*yaml_state;\n\tint\t\t\t*yaml_indent;\n};\n"}, "28": {"id": 28, "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_val_private.h", "content": "#ifndef ISL_VAL_PRIVATE_H\n#define ISL_VAL_PRIVATE_H\n\n#include <isl_int.h>\n#include <isl/val.h>\n#include <isl/local_space.h>\n#include <isl_reordering.h>\n\n/* Represents a \"value\", which may be an integer value, a rational value,\n * plus or minus infinity or \"not a number\".\n *\n * Internally, +infinity is represented as 1/0,\n * -infinity as -1/0 and NaN as 0/0.\n *\n * A rational value is always normalized before it is passed to the user.\n */\nstruct isl_val {\n\tint ref;\n\tisl_ctx *ctx;\n\n\tisl_int n;\n\tisl_int d;\n};\n\n#undef EL\n#define EL isl_val\n\n#include <isl_list_templ.h>\n\n__isl_give isl_val *isl_val_alloc(isl_ctx *ctx);\n__isl_give isl_val *isl_val_normalize(__isl_take isl_val *v);\n__isl_give isl_val *isl_val_int_from_isl_int(isl_ctx *ctx, isl_int n);\n__isl_give isl_val *isl_val_rat_from_isl_int(isl_ctx *ctx,\n\tisl_int n, isl_int d);\n__isl_give isl_val *isl_val_cow(__isl_take isl_val *val);\n\nisl_stat isl_val_get_num_isl_int(__isl_keep isl_val *v, isl_int *n);\n\nisl_bool isl_val_involves_dims(__isl_keep isl_val *v, enum isl_dim_type type,\n\tunsigned first, unsigned n);\n__isl_give isl_val *isl_val_insert_dims(__isl_take isl_val *v,\n\tenum isl_dim_type type, unsigned first, unsigned n);\n__isl_give isl_val *isl_val_set_dim_name(__isl_take isl_val *v,\n\tenum isl_dim_type type, unsigned pos, const char *s);\n\n__isl_give isl_val *isl_val_scale_val(__isl_take isl_val *v1,\n\t__isl_take isl_val *v2);\n__isl_give isl_val *isl_val_scale_down_val(__isl_take isl_val *v1,\n\t__isl_take isl_val *v2);\n__isl_give isl_val *isl_val_mod_val(__isl_take isl_val *v1,\n\t__isl_take isl_val *v2);\n\nisl_bool isl_val_plain_is_equal(__isl_keep isl_val *val1,\n\t__isl_keep isl_val *val2);\n\n#undef BASE\n#define BASE val\n\n#include <isl_multi_templ.h>\n\n#endif\n"}, "29": {"id": 29, "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_vec_private.h", "content": "#ifndef ISL_VEC_PRIVATE_H\n#define ISL_VEC_PRIVATE_H\n\n#include <isl_blk.h>\n#include <isl/vec.h>\n\nstruct isl_vec {\n\tint ref;\n\n\tstruct isl_ctx *ctx;\n\n\tunsigned size;\n\tisl_int *el;\n\n\tstruct isl_blk block;\n};\n\nuint32_t isl_vec_get_hash(__isl_keep isl_vec *vec);\n\n__isl_give isl_vec *isl_vec_cow(__isl_take isl_vec *vec);\n\nvoid isl_vec_lcm(__isl_keep isl_vec *vec, isl_int *lcm);\n__isl_give isl_vec *isl_vec_set(__isl_take isl_vec *vec, isl_int v);\n\nisl_bool isl_vec_is_zero(__isl_keep isl_vec *vec);\n\n__isl_give isl_vec *isl_vec_expand(__isl_take isl_vec *vec, int pos, int n,\n\tint *exp, int expanded);\n\n#endif\n"}, "30": {"id": 30, "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_yaml.h", "content": "#ifndef ISL_YAML_H\n#define ISL_YAML_H\n\n#define ISL_YAML_INDENT_FLOW\t\t-1\n\nenum isl_yaml_state {\n\tisl_yaml_none,\n\tisl_yaml_mapping_first_key_start,\n\tisl_yaml_mapping_key_start,\n\tisl_yaml_mapping_key,\n\tisl_yaml_mapping_val_start,\n\tisl_yaml_mapping_val,\n\tisl_yaml_sequence_first_start,\n\tisl_yaml_sequence_start,\n\tisl_yaml_sequence\n};\n\n#endif\n"}}, "reports": [{"events": [{"location": {"col": 1, "file": 0, "line": 1}, "message": "header is missing header guard"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/build/tools/polly/lib/External/isl/include/isl/stdint.h", "reportHash": "68ef19784306aec92b6e580ecf56a18a", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 1, "file": 1, "line": 1}, "message": "header is missing header guard"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/build/tools/polly/lib/External/isl/isl_config.h", "reportHash": "a05cfde27e8270838e8b940e6c8debf3", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 2, "line": 27}, "message": "LLVM_POLLY_LIB_EXTERNAL_ISL_IMATH_GMP_COMPAT_H (fixit)"}, {"location": {"col": 9, "file": 2, "line": 27}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/imath/gmp_compat.h", "reportHash": "357ee01db3e1d0dbd9edbdeb6a82fae2", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 3, "line": 27}, "message": "LLVM_POLLY_LIB_EXTERNAL_ISL_IMATH_IMATH_H (fixit)"}, {"location": {"col": 9, "file": 3, "line": 27}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/imath/imath.h", "reportHash": "309fd44a36e6c4213209aa437c401daa", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 4, "line": 27}, "message": "LLVM_POLLY_LIB_EXTERNAL_ISL_IMATH_IMRAT_H (fixit)"}, {"location": {"col": 9, "file": 4, "line": 27}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/imath/imrat.h", "reportHash": "90bb80b3a416b81e48248e9c3753ce12", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 5, "line": 1}, "message": "LLVM_POLLY_LIB_EXTERNAL_ISL_ISL_AFF_PRIVATE_H (fixit)"}, {"location": {"col": 9, "file": 5, "line": 1}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_aff_private.h", "reportHash": "10463b5570fab7f91ccff18653673181", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 6, "line": 10}, "message": "LLVM_POLLY_LIB_EXTERNAL_ISL_ISL_BLK_H (fixit)"}, {"location": {"col": 9, "file": 6, "line": 10}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_blk.h", "reportHash": "a9756bf81a3ce41dad6cd57ee4a8b5b5", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 1, "file": 7, "line": 1}, "message": "header is missing header guard"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_config_post.h", "reportHash": "f0ce1224479be3da5cee97157ab81cdb", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 1, "file": 8, "line": 1}, "message": "header is missing header guard"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_ctx_private.h", "reportHash": "0864b306886607fde1a2c1808645781b", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 9, "line": 10}, "message": "LLVM_POLLY_LIB_EXTERNAL_ISL_ISL_ID_PRIVATE_H (fixit)"}, {"location": {"col": 9, "file": 9, "line": 10}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_id_private.h", "reportHash": "11b0d367fc7829018655e98ee7839d4c", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 1, "file": 10, "line": 1}, "message": "header is missing header guard"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_imath.h", "reportHash": "1e403c9dffeba754ef64319743948672", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 13, "file": 11, "line": 2306}, "message": "comparison of integers of different signs: 'int' and 'unsigned int'"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_input.c", "reportHash": "c1f02799fa96af62dda6d4f5ebd48181", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 16, "file": 11, "line": 2317}, "message": "comparison of integers of different signs: 'int' and 'unsigned int'"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_input.c", "reportHash": "62de058cdc86d29e0b0259b564ee7d72", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 16, "file": 11, "line": 3316}, "message": "comparison of integers of different signs: 'int' and 'unsigned int'"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_input.c", "reportHash": "59cf2974b84c77ca34607279a14e27ca", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 9, "file": 12, "line": 10}, "message": "LLVM_POLLY_LIB_EXTERNAL_ISL_ISL_INT_H (fixit)"}, {"location": {"col": 9, "file": 12, "line": 10}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_int.h", "reportHash": "a49484dc60bb0283ba93295bc1d969b7", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 13, "line": 10}, "message": "LLVM_POLLY_LIB_EXTERNAL_ISL_ISL_INT_SIOIMATH_H (fixit)"}, {"location": {"col": 9, "file": 13, "line": 10}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_int_sioimath.h", "reportHash": "cd5d31ccaab8049dae64a498f7f83ed1", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 10, "file": 13, "line": 211}, "message": "expanded from macro 'ISL_SIOIMATH_TO_DIGITS'"}, {"location": {"col": 2, "file": 13, "line": 223}, "message": "comparison of integers of different signs: 'int' and 'unsigned long'"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_int_sioimath.h", "reportHash": "128ea05251e317b458fdea1cab4c6cf5", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 10, "file": 13, "line": 211}, "message": "expanded from macro 'ISL_SIOIMATH_TO_DIGITS'"}, {"location": {"col": 2, "file": 13, "line": 229}, "message": "comparison of integers of different signs: 'int' and 'unsigned long'"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_int_sioimath.h", "reportHash": "128ea05251e317b458fdea1cab4c6cf5", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 10, "file": 13, "line": 211}, "message": "expanded from macro 'ISL_SIOIMATH_TO_DIGITS'"}, {"location": {"col": 2, "file": 13, "line": 235}, "message": "comparison of integers of different signs: 'int' and 'unsigned long'"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_int_sioimath.h", "reportHash": "128ea05251e317b458fdea1cab4c6cf5", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 16, "file": 13, "line": 520}, "message": "comparison of integers of different signs: 'int' and 'mp_size' (aka 'unsigned int')"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_int_sioimath.h", "reportHash": "7300aefb32ec0d4fea782780b61090ea", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 22, "file": 13, "line": 785}, "message": "comparison of integers of different signs: 'long' and 'unsigned long'"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_int_sioimath.h", "reportHash": "5c57817518f87b43180bbb728de54137", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 17, "file": 13, "line": 1161}, "message": "comparison of integers of different signs: 'int' and 'unsigned long'"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_int_sioimath.h", "reportHash": "b1e450149dc34999f39e896d0b89b0db", "checkerName": "clang-diagnostic-sign-compare", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 1, "file": 14, "line": 1}, "message": "header is missing header guard"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_list_macro.h", "reportHash": "d8124b32c0f5b641c00325ddd4873a8d", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 15, "line": 1}, "message": "LLVM_POLLY_LIB_EXTERNAL_ISL_ISL_LIST_PRIVATE_H (fixit)"}, {"location": {"col": 9, "file": 15, "line": 1}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_list_private.h", "reportHash": "3df9ccfe854677bdd2038666bd631172", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 1, "file": 16, "line": 1}, "message": "header is missing header guard"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_list_templ.h", "reportHash": "44a43530fe7f24ea704d9b2d73634320", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 17, "line": 10}, "message": "LLVM_POLLY_LIB_EXTERNAL_ISL_ISL_MAP_PRIVATE_H (fixit)"}, {"location": {"col": 9, "file": 17, "line": 10}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_map_private.h", "reportHash": "883367cd706f6a02718cd11c8540eb8b", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 18, "line": 1}, "message": "LLVM_POLLY_LIB_EXTERNAL_ISL_ISL_MAT_PRIVATE_H (fixit)"}, {"location": {"col": 9, "file": 18, "line": 1}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_mat_private.h", "reportHash": "d4d41e86723b0c5df0245f7853768416", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 19, "line": 11}, "message": "LLVM_POLLY_LIB_EXTERNAL_ISL_ISL_MORPH_H (fixit)"}, {"location": {"col": 9, "file": 19, "line": 11}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_morph.h", "reportHash": "1cad6e20a6b08caed863b4ac681b3d4d", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 1, "file": 20, "line": 1}, "message": "header is missing header guard"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_multi_macro.h", "reportHash": "46b790811a283ce57d55a124951369ab", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 1, "file": 21, "line": 1}, "message": "header is missing header guard"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_multi_templ.h", "reportHash": "4351a86f1b7bf936e4bf41b4d3a7b07d", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 1, "file": 22, "line": 1}, "message": "header is missing header guard"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_polynomial_private.h", "reportHash": "d4f83d5510a304147504d73b1d0937b4", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 1, "file": 23, "line": 1}, "message": "header is missing header guard"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_pw_macro.h", "reportHash": "e30dca6f805cfd458a7dbd66ea96ef93", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 1, "file": 24, "line": 1}, "message": "header is missing header guard"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_pw_templ.h", "reportHash": "aa30db4e5250dbb38871ae51d663f840", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 25, "line": 1}, "message": "LLVM_POLLY_LIB_EXTERNAL_ISL_ISL_REORDERING_H (fixit)"}, {"location": {"col": 9, "file": 25, "line": 1}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_reordering.h", "reportHash": "4c377d80a0fb5c6db77d46c05826ed38", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 26, "line": 10}, "message": "LLVM_POLLY_LIB_EXTERNAL_ISL_ISL_SEQ_H (fixit)"}, {"location": {"col": 9, "file": 26, "line": 10}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_seq.h", "reportHash": "880c13f4aefc1610c41d27e75258d115", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 1, "file": 27, "line": 1}, "message": "header is missing header guard"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_stream_private.h", "reportHash": "576b3ebbebfaaaeede7e26c36e36bb6d", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 28, "line": 1}, "message": "LLVM_POLLY_LIB_EXTERNAL_ISL_ISL_VAL_PRIVATE_H (fixit)"}, {"location": {"col": 9, "file": 28, "line": 1}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_val_private.h", "reportHash": "5b5a8f5f6f8484668165fa1ca0580819", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 29, "line": 1}, "message": "LLVM_POLLY_LIB_EXTERNAL_ISL_ISL_VEC_PRIVATE_H (fixit)"}, {"location": {"col": 9, "file": 29, "line": 1}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_vec_private.h", "reportHash": "56c5f8291279b16f5a0c9efce59bdc3b", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 30, "line": 1}, "message": "LLVM_POLLY_LIB_EXTERNAL_ISL_ISL_YAML_H (fixit)"}, {"location": {"col": 9, "file": 30, "line": 1}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/polly/lib/External/isl/isl_yaml.h", "reportHash": "b223d62e50cf7b6f6ac435ccfaf617f5", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}]};
      window.onload = function() {
        if (!browserCompatible) {
          setNonCompatibleBrowserMessage();
        } else {
          BugViewer.init(data.files, data.reports);
          BugViewer.create();
          BugViewer.initByUrl();
        }
      };
    </script>
  </head>
  <body>
  <div class="container">
    <div id="content">
      <div id="side-bar">
        <div class="header">
          <a href="index.html" class="button">&#8249; Return to List</a>
        </div>
        <div id="report-nav">
          <div class="header">Reports</div>
        </div>
      </div>
      <div id="editor-wrapper">
        <div class="header">
          <div id="file">
            <span class="label">File:</span>
            <span id="file-path"></span>
          </div>
          <div id="checker">
            <span class="label">Checker name:</span>
            <span id="checker-name"></span>
          </div>
          <div id="review-status-wrapper">
            <span class="label">Review status:</span>
            <span id="review-status"></span>
          </div>
        </div>
        <div id="editor"></div>
      </div>
    </div>
  </div>
  </body>
</html>
