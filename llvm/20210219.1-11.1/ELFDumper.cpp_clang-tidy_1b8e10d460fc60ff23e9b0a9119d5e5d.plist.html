<!DOCTYPE html>
<html>
  <head>
    <title>Plist HTML Viewer</title>

    <meta charset="UTF-8">

    <style type="text/css">
      .CodeMirror{font-family:monospace;height:300px;color:#000;direction:ltr}.CodeMirror-lines{padding:4px 0}.CodeMirror pre{padding:0 4px}.CodeMirror-gutter-filler,.CodeMirror-scrollbar-filler{background-color:#fff}.CodeMirror-gutters{border-right:1px solid #ddd;background-color:#f7f7f7;white-space:nowrap}.CodeMirror-linenumber{padding:0 3px 0 5px;min-width:20px;text-align:right;color:#999;white-space:nowrap}.CodeMirror-guttermarker{color:#000}.CodeMirror-guttermarker-subtle{color:#999}.CodeMirror-cursor{border-left:1px solid #000;border-right:none;width:0}.CodeMirror div.CodeMirror-secondarycursor{border-left:1px solid silver}.cm-fat-cursor .CodeMirror-cursor{width:auto;border:0!important;background:#7e7}.cm-fat-cursor div.CodeMirror-cursors{z-index:1}.cm-animate-fat-cursor{width:auto;border:0;-webkit-animation:blink 1.06s steps(1) infinite;-moz-animation:blink 1.06s steps(1) infinite;animation:blink 1.06s steps(1) infinite;background-color:#7e7}@-moz-keyframes blink{50%{background-color:transparent}}@-webkit-keyframes blink{50%{background-color:transparent}}@keyframes blink{50%{background-color:transparent}}.cm-tab{display:inline-block;text-decoration:inherit}.CodeMirror-rulers{position:absolute;left:0;right:0;top:-50px;bottom:-20px;overflow:hidden}.CodeMirror-ruler{border-left:1px solid #ccc;top:0;bottom:0;position:absolute}.cm-s-default .cm-header{color:#00f}.cm-s-default .cm-quote{color:#090}.cm-negative{color:#d44}.cm-positive{color:#292}.cm-header,.cm-strong{font-weight:700}.cm-em{font-style:italic}.cm-link{text-decoration:underline}.cm-strikethrough{text-decoration:line-through}.cm-s-default .cm-keyword{color:#708}.cm-s-default .cm-atom{color:#219}.cm-s-default .cm-number{color:#164}.cm-s-default .cm-def{color:#00f}.cm-s-default .cm-variable-2{color:#05a}.cm-s-default .cm-type,.cm-s-default .cm-variable-3{color:#085}.cm-s-default .cm-comment{color:#a50}.cm-s-default .cm-string{color:#a11}.cm-s-default .cm-string-2{color:#f50}.cm-s-default .cm-meta{color:#555}.cm-s-default .cm-qualifier{color:#555}.cm-s-default .cm-builtin{color:#30a}.cm-s-default .cm-bracket{color:#997}.cm-s-default .cm-tag{color:#170}.cm-s-default .cm-attribute{color:#00c}.cm-s-default .cm-hr{color:#999}.cm-s-default .cm-link{color:#00c}.cm-s-default .cm-error{color:red}.cm-invalidchar{color:red}.CodeMirror-composing{border-bottom:2px solid}div.CodeMirror span.CodeMirror-matchingbracket{color:#0f0}div.CodeMirror span.CodeMirror-nonmatchingbracket{color:#f22}.CodeMirror-matchingtag{background:rgba(255,150,0,.3)}.CodeMirror-activeline-background{background:#e8f2ff}.CodeMirror{position:relative;overflow:hidden;background:#fff}.CodeMirror-scroll{overflow:scroll!important;margin-bottom:-30px;margin-right:-30px;padding-bottom:30px;height:100%;outline:0;position:relative}.CodeMirror-sizer{position:relative;border-right:30px solid transparent}.CodeMirror-gutter-filler,.CodeMirror-hscrollbar,.CodeMirror-scrollbar-filler,.CodeMirror-vscrollbar{position:absolute;z-index:6;display:none}.CodeMirror-vscrollbar{right:0;top:0;overflow-x:hidden;overflow-y:scroll}.CodeMirror-hscrollbar{bottom:0;left:0;overflow-y:hidden;overflow-x:scroll}.CodeMirror-scrollbar-filler{right:0;bottom:0}.CodeMirror-gutter-filler{left:0;bottom:0}.CodeMirror-gutters{position:absolute;left:0;top:0;min-height:100%;z-index:3}.CodeMirror-gutter{white-space:normal;height:100%;display:inline-block;vertical-align:top;margin-bottom:-30px}.CodeMirror-gutter-wrapper{position:absolute;z-index:4;background:0 0!important;border:none!important}.CodeMirror-gutter-background{position:absolute;top:0;bottom:0;z-index:4}.CodeMirror-gutter-elt{position:absolute;cursor:default;z-index:4}.CodeMirror-gutter-wrapper ::selection{background-color:transparent}.CodeMirror-gutter-wrapper ::-moz-selection{background-color:transparent}.CodeMirror-lines{cursor:text;min-height:1px}.CodeMirror pre{-moz-border-radius:0;-webkit-border-radius:0;border-radius:0;border-width:0;background:0 0;font-family:inherit;font-size:inherit;margin:0;white-space:pre;word-wrap:normal;line-height:inherit;color:inherit;z-index:2;position:relative;overflow:visible;-webkit-tap-highlight-color:transparent;-webkit-font-variant-ligatures:contextual;font-variant-ligatures:contextual}.CodeMirror-wrap pre{word-wrap:break-word;white-space:pre-wrap;word-break:normal}.CodeMirror-linebackground{position:absolute;left:0;right:0;top:0;bottom:0;z-index:0}.CodeMirror-linewidget{position:relative;z-index:2;overflow:auto}.CodeMirror-rtl pre{direction:rtl}.CodeMirror-code{outline:0}.CodeMirror-gutter,.CodeMirror-gutters,.CodeMirror-linenumber,.CodeMirror-scroll,.CodeMirror-sizer{-moz-box-sizing:content-box;box-sizing:content-box}.CodeMirror-measure{position:absolute;width:100%;height:0;overflow:hidden;visibility:hidden}.CodeMirror-cursor{position:absolute;pointer-events:none}.CodeMirror-measure pre{position:static}div.CodeMirror-cursors{visibility:hidden;position:relative;z-index:3}div.CodeMirror-dragcursors{visibility:visible}.CodeMirror-focused div.CodeMirror-cursors{visibility:visible}.CodeMirror-selected{background:#d9d9d9}.CodeMirror-focused .CodeMirror-selected{background:#d7d4f0}.CodeMirror-crosshair{cursor:crosshair}.CodeMirror-line::selection,.CodeMirror-line>span::selection,.CodeMirror-line>span>span::selection{background:#d7d4f0}.CodeMirror-line::-moz-selection,.CodeMirror-line>span::-moz-selection,.CodeMirror-line>span>span::-moz-selection{background:#d7d4f0}.cm-searching{background-color:#ffa;background-color:rgba(255,255,0,.4)}.cm-force-border{padding-right:.1px}@media print{.CodeMirror div.CodeMirror-cursors{visibility:hidden}}.cm-tab-wrap-hack:after{content:''}span.CodeMirror-selectedtext{background:0 0}
/*# sourceMappingURL=codemirror.min.css.map */

      .severity-low {
  background-color: #669603;
}

.severity-low:after {
  content : 'L';
}

.severity-unspecified {
  background-color: #666666;
}

.severity-unspecified:after {
  content : 'U';
}

.severity-style {
  background-color: #9932cc;
}

.severity-style:after {
  content : 'S';
}

.severity-medium {
  background-color: #a9d323;
  color: black;
}

.severity-medium:after {
  content : 'M';
}

.severity-high {
  background-color: #ffa800;
}

.severity-high:after {
  content : 'H';
}

.severity-critical {
  background-color: #e92625;
}

.severity-critical:after {
  content : 'C';
}

i[class*="severity-"] {
  line-height: normal;
  text-transform: capitalize;
  font-size: 0.8em;
  font-weight: bold;
  color: white;
  display: inline-block;
  width: 16px;
  height: 16px;
  text-align: center;
  font-family: sans-serif;
}

      html, body {
  width: 100%;
  height: 100%;
  padding: 0px;
  margin: 0px;
}

div.container {
  padding: 10px;
}

#content {
  height: 100%;
  display: block;
  overflow: hidden;
}

#content > div {
  margin: 10px;
  overflow: hidden;
  border: 1px solid #ddd;
  border-radius: 3px;
  overflow: hidden;
  height: 97%;
}

.button {
  background-color: #f1f1f1;
  text-decoration: none;
  display: inline-block;
  padding: 8px 16px;
  color: black;
  cursor: pointer;
}

.button:hover {
  background-color: #ddd;
  color: black;
}

.review-status {
  color: white;
  text-align: center;
}

.review-status-confirmed {
  background-color: #e92625;
}

.review-status-false-positive {
  background-color: grey;
}

.review-status-intentional {
  background-color: #669603;
}

      div.container {
  width: 100%;
  height: 100%;
  padding: 0px;
}

#editor-wrapper {
  margin: 10px;
}

#side-bar {
  float: left;
  width: 260px;
  margin: 0px;
}

#report-nav ul {
  list-style-type: none;
  padding: 0;
  margin: 0;
  overflow-y: auto;
  height: 100%;
}

#report-nav ul > li {
  padding: .4em;
  background-color: #fff;
  border-bottom: 1px solid rgba(0,0,0,.125);
  text-align: left;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

#report-nav ul > li.active {
  background-color: #427ea9;
  color: white;
}

#report-nav ul > li:hover {
  background-color: #427ea9;
  color: white;
  cursor: pointer;
}

#report-nav ul a {
  text-decoration: none;
}

#report-nav i[class*="severity-"] {
  margin-right: 5px;
}

.header {
  border-bottom: 1px solid lightgrey;
  font-family: monospace;
  padding: 10px;
  background-color: #fafbfc;
  border-bottom: 1px solid #e1e4e8;
  border-top-left-radius: 2px;
  border-top-right-radius: 2px;
}

#report-nav .header {
  font-weight: bold;
}

#editor-wrapper .header > div {
  padding-top: 2px;
}

#file-path,
#checker-name {
  color: #195ea2;
}

#review-status {
  padding: 0px 5px;
}

#file-path {
  font-family: monospace;
}

.check-msg {
  display: inline-block;
  padding: 3px 6px;
  margin: 1px;
  -webkit-border-radius: 5px;
  -moz-border-radius: 5px;
  border-radius: 5px;
}

.check-msg.info {
  color: #00546f;
  background-color: #bfdfe9;
  border: 1px solid #87a8b3;
}

.check-msg.error {
  background-color: #f2dede;
  color: #a94442;
  border: 1px solid #ebcccc;
}

.check-msg.macro {
  background-color: #d7dac2;
  color: #4f5c6d;
  border: 1px solid #d7dac2;
}

.check-msg.note {
  background-color: #d7d7d7;
  color: #4f5c6d;
  border: 1px solid #bfbfbf;
}

.check-msg.current {
  border: 2px dashed #3692ff;
}

.check-msg .tag {
  padding: 1px 5px;
  text-align: center;
  border-radius: 2px;
  margin-right: 5px;
  text-decoration: inherit;
}

.check-msg .tag.macro {
  background-color: #83876a;
  color: white;
  text-transform: capitalize;
}

.check-msg .tag.note {
  background-color: #9299a1;
  color: white;
  text-transform: capitalize;
}

.checker-enum {
  color: white;
  padding: 1px 5px;
  text-align: center;
  border-radius: 25px;
  margin-right: 5px;
  text-decoration: inherit;
}

.checker-enum.info {
  background-color: #427ea9;
}

.checker-enum.error {
  background-color: #a94442;
}

.arrow {
  border: solid black;
  border-width: 0 3px 3px 0;
  display: inline-block;
  padding: 3px;
  cursor: pointer;
  margin: 0px 5px;
}

.arrow:hover {
  border: solid #437ea8;
  border-width: 0 3px 3px 0;
}

.left-arrow {
  transform: rotate(135deg);
  -webkit-transform: rotate(135deg);
}

.right-arrow {
  transform: rotate(-45deg);
  -webkit-transform: rotate(-45deg);
}

    </style>

    <script type="text/javascript">
      function setNonCompatibleBrowserMessage() {
  document.body.innerHTML =
    '<h2 style="margin-left: 20px;">Your browser is not compatible with CodeChecker Viewer!</h2> \
     <p style="margin-left: 20px;">The version required for the following browsers are:</p> \
     <ul style="margin-left: 20px;"> \
     <li>Internet Explorer: version 9 or newer</li> \
     <li>Firefox: version 22.0 or newer</li> \
     </ul>';
}

// http://stackoverflow.com/questions/5916900/how-can-you-detect-the-version-of-a-browser
var browserVersion = (function(){
  var ua = navigator.userAgent, tem,
    M = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];

  if (/trident/i.test(M[1])) {
    tem = /\brv[ :]+(\d+)/g.exec(ua) || [];
    return 'IE ' + (tem[1] || '');
  }

  if (M[1] === 'Chrome') {
    tem = ua.match(/\b(OPR|Edge)\/(\d+)/);
    if (tem != null) return tem.slice(1).join(' ').replace('OPR', 'Opera');
  }

  M = M[2] ? [M[1], M[2]] : [navigator.appName, navigator.appVersion, '-?'];
  if ((tem = ua.match(/version\/(\d+)/i)) != null) M.splice(1, 1, tem[1]);
    return M.join(' ');
})();

var pos = browserVersion.indexOf(' ');
var browser = browserVersion.substr(0, pos);
var version = parseInt(browserVersion.substr(pos + 1));

var browserCompatible
  = browser === 'Firefox'
  ? version >= 22
  : browser === 'IE'
  ? version >= 9
  : true;


      /* MIT License

Copyright (C) 2017 by Marijn Haverbeke <marijnh@gmail.com> and others

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
 */
      !function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):e.CodeMirror=t()}(this,function(){"use strict";function e(e){return new RegExp("(^|\\s)"+e+"(?:$|\\s)\\s*")}function t(e){for(var t=e.childNodes.length;t>0;--t)e.removeChild(e.firstChild);return e}function r(e,r){return t(e).appendChild(r)}function n(e,t,r,n){var i=document.createElement(e);if(r&&(i.className=r),n&&(i.style.cssText=n),"string"==typeof t)i.appendChild(document.createTextNode(t));else if(t)for(var o=0;o<t.length;++o)i.appendChild(t[o]);return i}function i(e,t,r,i){var o=n(e,t,r,i);return o.setAttribute("role","presentation"),o}function o(e,t){if(3==t.nodeType&&(t=t.parentNode),e.contains)return e.contains(t);do{if(11==t.nodeType&&(t=t.host),t==e)return!0}while(t=t.parentNode)}function l(){var e;try{e=document.activeElement}catch(t){e=document.body||null}for(;e&&e.shadowRoot&&e.shadowRoot.activeElement;)e=e.shadowRoot.activeElement;return e}function s(t,r){var n=t.className;e(r).test(n)||(t.className+=(n?" ":"")+r)}function a(t,r){for(var n=t.split(" "),i=0;i<n.length;i++)n[i]&&!e(n[i]).test(r)&&(r+=" "+n[i]);return r}function u(e){var t=Array.prototype.slice.call(arguments,1);return function(){return e.apply(null,t)}}function c(e,t,r){t||(t={});for(var n in e)!e.hasOwnProperty(n)||!1===r&&t.hasOwnProperty(n)||(t[n]=e[n]);return t}function f(e,t,r,n,i){null==t&&-1==(t=e.search(/[^\s\u00a0]/))&&(t=e.length);for(var o=n||0,l=i||0;;){var s=e.indexOf("\t",o);if(s<0||s>=t)return l+(t-o);l+=s-o,l+=r-l%r,o=s+1}}function h(e,t){for(var r=0;r<e.length;++r)if(e[r]==t)return r;return-1}function d(e,t,r){for(var n=0,i=0;;){var o=e.indexOf("\t",n);-1==o&&(o=e.length);var l=o-n;if(o==e.length||i+l>=t)return n+Math.min(l,t-i);if(i+=o-n,i+=r-i%r,n=o+1,i>=t)return n}}function p(e){for(;Kl.length<=e;)Kl.push(g(Kl)+" ");return Kl[e]}function g(e){return e[e.length-1]}function v(e,t){for(var r=[],n=0;n<e.length;n++)r[n]=t(e[n],n);return r}function m(e,t,r){for(var n=0,i=r(t);n<e.length&&r(e[n])<=i;)n++;e.splice(n,0,t)}function y(){}function b(e,t){var r;return Object.create?r=Object.create(e):(y.prototype=e,r=new y),t&&c(t,r),r}function w(e){return/\w/.test(e)||e>""&&(e.toUpperCase()!=e.toLowerCase()||jl.test(e))}function x(e,t){return t?!!(t.source.indexOf("\\w")>-1&&w(e))||t.test(e):w(e)}function C(e){for(var t in e)if(e.hasOwnProperty(t)&&e[t])return!1;return!0}function S(e){return e.charCodeAt(0)>=768&&Xl.test(e)}function L(e,t,r){for(;(r<0?t>0:t<e.length)&&S(e.charAt(t));)t+=r;return t}function k(e,t,r){for(var n=t>r?-1:1;;){if(t==r)return t;var i=(t+r)/2,o=n<0?Math.ceil(i):Math.floor(i);if(o==t)return e(o)?t:r;e(o)?r=o:t=o+n}}function T(e,t,r){var o=this;this.input=r,o.scrollbarFiller=n("div",null,"CodeMirror-scrollbar-filler"),o.scrollbarFiller.setAttribute("cm-not-content","true"),o.gutterFiller=n("div",null,"CodeMirror-gutter-filler"),o.gutterFiller.setAttribute("cm-not-content","true"),o.lineDiv=i("div",null,"CodeMirror-code"),o.selectionDiv=n("div",null,null,"position: relative; z-index: 1"),o.cursorDiv=n("div",null,"CodeMirror-cursors"),o.measure=n("div",null,"CodeMirror-measure"),o.lineMeasure=n("div",null,"CodeMirror-measure"),o.lineSpace=i("div",[o.measure,o.lineMeasure,o.selectionDiv,o.cursorDiv,o.lineDiv],null,"position: relative; outline: none");var l=i("div",[o.lineSpace],"CodeMirror-lines");o.mover=n("div",[l],null,"position: relative"),o.sizer=n("div",[o.mover],"CodeMirror-sizer"),o.sizerWidth=null,o.heightForcer=n("div",null,null,"position: absolute; height: "+Rl+"px; width: 1px;"),o.gutters=n("div",null,"CodeMirror-gutters"),o.lineGutter=null,o.scroller=n("div",[o.sizer,o.heightForcer,o.gutters],"CodeMirror-scroll"),o.scroller.setAttribute("tabIndex","-1"),o.wrapper=n("div",[o.scrollbarFiller,o.gutterFiller,o.scroller],"CodeMirror"),gl&&vl<8&&(o.gutters.style.zIndex=-1,o.scroller.style.paddingRight=0),ml||fl&&Tl||(o.scroller.draggable=!0),e&&(e.appendChild?e.appendChild(o.wrapper):e(o.wrapper)),o.viewFrom=o.viewTo=t.first,o.reportedViewFrom=o.reportedViewTo=t.first,o.view=[],o.renderedView=null,o.externalMeasured=null,o.viewOffset=0,o.lastWrapHeight=o.lastWrapWidth=0,o.updateLineNumbers=null,o.nativeBarWidth=o.barHeight=o.barWidth=0,o.scrollbarsClipped=!1,o.lineNumWidth=o.lineNumInnerWidth=o.lineNumChars=null,o.alignWidgets=!1,o.cachedCharWidth=o.cachedTextHeight=o.cachedPaddingH=null,o.maxLine=null,o.maxLineLength=0,o.maxLineChanged=!1,o.wheelDX=o.wheelDY=o.wheelStartX=o.wheelStartY=null,o.shift=!1,o.selForContextMenu=null,o.activeTouch=null,r.init(o)}function M(e,t){if((t-=e.first)<0||t>=e.size)throw new Error("There is no line "+(t+e.first)+" in the document.");for(var r=e;!r.lines;)for(var n=0;;++n){var i=r.children[n],o=i.chunkSize();if(t<o){r=i;break}t-=o}return r.lines[t]}function N(e,t,r){var n=[],i=t.line;return e.iter(t.line,r.line+1,function(e){var o=e.text;i==r.line&&(o=o.slice(0,r.ch)),i==t.line&&(o=o.slice(t.ch)),n.push(o),++i}),n}function O(e,t,r){var n=[];return e.iter(t,r,function(e){n.push(e.text)}),n}function A(e,t){var r=t-e.height;if(r)for(var n=e;n;n=n.parent)n.height+=r}function W(e){if(null==e.parent)return null;for(var t=e.parent,r=h(t.lines,e),n=t.parent;n;t=n,n=n.parent)for(var i=0;n.children[i]!=t;++i)r+=n.children[i].chunkSize();return r+t.first}function D(e,t){var r=e.first;e:do{for(var n=0;n<e.children.length;++n){var i=e.children[n],o=i.height;if(t<o){e=i;continue e}t-=o,r+=i.chunkSize()}return r}while(!e.lines);for(var l=0;l<e.lines.length;++l){var s=e.lines[l].height;if(t<s)break;t-=s}return r+l}function H(e,t){return t>=e.first&&t<e.first+e.size}function F(e,t){return String(e.lineNumberFormatter(t+e.firstLineNumber))}function E(e,t,r){if(void 0===r&&(r=null),!(this instanceof E))return new E(e,t,r);this.line=e,this.ch=t,this.sticky=r}function P(e,t){return e.line-t.line||e.ch-t.ch}function I(e,t){return e.sticky==t.sticky&&0==P(e,t)}function z(e){return E(e.line,e.ch)}function R(e,t){return P(e,t)<0?t:e}function B(e,t){return P(e,t)<0?e:t}function G(e,t){return Math.max(e.first,Math.min(t,e.first+e.size-1))}function U(e,t){if(t.line<e.first)return E(e.first,0);var r=e.first+e.size-1;return t.line>r?E(r,M(e,r).text.length):V(t,M(e,t.line).text.length)}function V(e,t){var r=e.ch;return null==r||r>t?E(e.line,t):r<0?E(e.line,0):e}function K(e,t){for(var r=[],n=0;n<t.length;n++)r[n]=U(e,t[n]);return r}function j(){Yl=!0}function X(){_l=!0}function Y(e,t,r){this.marker=e,this.from=t,this.to=r}function _(e,t){if(e)for(var r=0;r<e.length;++r){var n=e[r];if(n.marker==t)return n}}function $(e,t){for(var r,n=0;n<e.length;++n)e[n]!=t&&(r||(r=[])).push(e[n]);return r}function q(e,t){e.markedSpans=e.markedSpans?e.markedSpans.concat([t]):[t],t.marker.attachLine(e)}function Z(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t)||o.from==t&&"bookmark"==l.type&&(!r||!o.marker.insertLeft)){var s=null==o.to||(l.inclusiveRight?o.to>=t:o.to>t);(n||(n=[])).push(new Y(l,o.from,s?null:o.to))}}return n}function Q(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.to||(l.inclusiveRight?o.to>=t:o.to>t)||o.from==t&&"bookmark"==l.type&&(!r||o.marker.insertLeft)){var s=null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t);(n||(n=[])).push(new Y(l,s?null:o.from-t,null==o.to?null:o.to-t))}}return n}function J(e,t){if(t.full)return null;var r=H(e,t.from.line)&&M(e,t.from.line).markedSpans,n=H(e,t.to.line)&&M(e,t.to.line).markedSpans;if(!r&&!n)return null;var i=t.from.ch,o=t.to.ch,l=0==P(t.from,t.to),s=Z(r,i,l),a=Q(n,o,l),u=1==t.text.length,c=g(t.text).length+(u?i:0);if(s)for(var f=0;f<s.length;++f){var h=s[f];if(null==h.to){var d=_(a,h.marker);d?u&&(h.to=null==d.to?null:d.to+c):h.to=i}}if(a)for(var p=0;p<a.length;++p){var v=a[p];null!=v.to&&(v.to+=c),null==v.from?_(s,v.marker)||(v.from=c,u&&(s||(s=[])).push(v)):(v.from+=c,u&&(s||(s=[])).push(v))}s&&(s=ee(s)),a&&a!=s&&(a=ee(a));var m=[s];if(!u){var y,b=t.text.length-2;if(b>0&&s)for(var w=0;w<s.length;++w)null==s[w].to&&(y||(y=[])).push(new Y(s[w].marker,null,null));for(var x=0;x<b;++x)m.push(y);m.push(a)}return m}function ee(e){for(var t=0;t<e.length;++t){var r=e[t];null!=r.from&&r.from==r.to&&!1!==r.marker.clearWhenEmpty&&e.splice(t--,1)}return e.length?e:null}function te(e,t,r){var n=null;if(e.iter(t.line,r.line+1,function(e){if(e.markedSpans)for(var t=0;t<e.markedSpans.length;++t){var r=e.markedSpans[t].marker;!r.readOnly||n&&-1!=h(n,r)||(n||(n=[])).push(r)}}),!n)return null;for(var i=[{from:t,to:r}],o=0;o<n.length;++o)for(var l=n[o],s=l.find(0),a=0;a<i.length;++a){var u=i[a];if(!(P(u.to,s.from)<0||P(u.from,s.to)>0)){var c=[a,1],f=P(u.from,s.from),d=P(u.to,s.to);(f<0||!l.inclusiveLeft&&!f)&&c.push({from:u.from,to:s.from}),(d>0||!l.inclusiveRight&&!d)&&c.push({from:s.to,to:u.to}),i.splice.apply(i,c),a+=c.length-3}}return i}function re(e){var t=e.markedSpans;if(t){for(var r=0;r<t.length;++r)t[r].marker.detachLine(e);e.markedSpans=null}}function ne(e,t){if(t){for(var r=0;r<t.length;++r)t[r].marker.attachLine(e);e.markedSpans=t}}function ie(e){return e.inclusiveLeft?-1:0}function oe(e){return e.inclusiveRight?1:0}function le(e,t){var r=e.lines.length-t.lines.length;if(0!=r)return r;var n=e.find(),i=t.find(),o=P(n.from,i.from)||ie(e)-ie(t);if(o)return-o;var l=P(n.to,i.to)||oe(e)-oe(t);return l||t.id-e.id}function se(e,t){var r,n=_l&&e.markedSpans;if(n)for(var i=void 0,o=0;o<n.length;++o)(i=n[o]).marker.collapsed&&null==(t?i.from:i.to)&&(!r||le(r,i.marker)<0)&&(r=i.marker);return r}function ae(e){return se(e,!0)}function ue(e){return se(e,!1)}function ce(e,t,r,n,i){var o=M(e,t),l=_l&&o.markedSpans;if(l)for(var s=0;s<l.length;++s){var a=l[s];if(a.marker.collapsed){var u=a.marker.find(0),c=P(u.from,r)||ie(a.marker)-ie(i),f=P(u.to,n)||oe(a.marker)-oe(i);if(!(c>=0&&f<=0||c<=0&&f>=0)&&(c<=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.to,r)>=0:P(u.to,r)>0)||c>=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.from,n)<=0:P(u.from,n)<0)))return!0}}}function fe(e){for(var t;t=ae(e);)e=t.find(-1,!0).line;return e}function he(e){for(var t;t=ue(e);)e=t.find(1,!0).line;return e}function de(e){for(var t,r;t=ue(e);)e=t.find(1,!0).line,(r||(r=[])).push(e);return r}function pe(e,t){var r=M(e,t),n=fe(r);return r==n?t:W(n)}function ge(e,t){if(t>e.lastLine())return t;var r,n=M(e,t);if(!ve(e,n))return t;for(;r=ue(n);)n=r.find(1,!0).line;return W(n)+1}function ve(e,t){var r=_l&&t.markedSpans;if(r)for(var n=void 0,i=0;i<r.length;++i)if((n=r[i]).marker.collapsed){if(null==n.from)return!0;if(!n.marker.widgetNode&&0==n.from&&n.marker.inclusiveLeft&&me(e,t,n))return!0}}function me(e,t,r){if(null==r.to){var n=r.marker.find(1,!0);return me(e,n.line,_(n.line.markedSpans,r.marker))}if(r.marker.inclusiveRight&&r.to==t.text.length)return!0;for(var i=void 0,o=0;o<t.markedSpans.length;++o)if((i=t.markedSpans[o]).marker.collapsed&&!i.marker.widgetNode&&i.from==r.to&&(null==i.to||i.to!=r.from)&&(i.marker.inclusiveLeft||r.marker.inclusiveRight)&&me(e,t,i))return!0}function ye(e){for(var t=0,r=(e=fe(e)).parent,n=0;n<r.lines.length;++n){var i=r.lines[n];if(i==e)break;t+=i.height}for(var o=r.parent;o;r=o,o=r.parent)for(var l=0;l<o.children.length;++l){var s=o.children[l];if(s==r)break;t+=s.height}return t}function be(e){if(0==e.height)return 0;for(var t,r=e.text.length,n=e;t=ae(n);){var i=t.find(0,!0);n=i.from.line,r+=i.from.ch-i.to.ch}for(n=e;t=ue(n);){var o=t.find(0,!0);r-=n.text.length-o.from.ch,r+=(n=o.to.line).text.length-o.to.ch}return r}function we(e){var t=e.display,r=e.doc;t.maxLine=M(r,r.first),t.maxLineLength=be(t.maxLine),t.maxLineChanged=!0,r.iter(function(e){var r=be(e);r>t.maxLineLength&&(t.maxLineLength=r,t.maxLine=e)})}function xe(e,t,r,n){if(!e)return n(t,r,"ltr",0);for(var i=!1,o=0;o<e.length;++o){var l=e[o];(l.from<r&&l.to>t||t==r&&l.to==t)&&(n(Math.max(l.from,t),Math.min(l.to,r),1==l.level?"rtl":"ltr",o),i=!0)}i||n(t,r,"ltr")}function Ce(e,t,r){var n;$l=null;for(var i=0;i<e.length;++i){var o=e[i];if(o.from<t&&o.to>t)return i;o.to==t&&(o.from!=o.to&&"before"==r?n=i:$l=i),o.from==t&&(o.from!=o.to&&"before"!=r?n=i:$l=i)}return null!=n?n:$l}function Se(e,t){var r=e.order;return null==r&&(r=e.order=ql(e.text,t)),r}function Le(e,t){return e._handlers&&e._handlers[t]||Zl}function ke(e,t,r){if(e.removeEventListener)e.removeEventListener(t,r,!1);else if(e.detachEvent)e.detachEvent("on"+t,r);else{var n=e._handlers,i=n&&n[t];if(i){var o=h(i,r);o>-1&&(n[t]=i.slice(0,o).concat(i.slice(o+1)))}}}function Te(e,t){var r=Le(e,t);if(r.length)for(var n=Array.prototype.slice.call(arguments,2),i=0;i<r.length;++i)r[i].apply(null,n)}function Me(e,t,r){return"string"==typeof t&&(t={type:t,preventDefault:function(){this.defaultPrevented=!0}}),Te(e,r||t.type,e,t),He(t)||t.codemirrorIgnore}function Ne(e){var t=e._handlers&&e._handlers.cursorActivity;if(t)for(var r=e.curOp.cursorActivityHandlers||(e.curOp.cursorActivityHandlers=[]),n=0;n<t.length;++n)-1==h(r,t[n])&&r.push(t[n])}function Oe(e,t){return Le(e,t).length>0}function Ae(e){e.prototype.on=function(e,t){Ql(this,e,t)},e.prototype.off=function(e,t){ke(this,e,t)}}function We(e){e.preventDefault?e.preventDefault():e.returnValue=!1}function De(e){e.stopPropagation?e.stopPropagation():e.cancelBubble=!0}function He(e){return null!=e.defaultPrevented?e.defaultPrevented:0==e.returnValue}function Fe(e){We(e),De(e)}function Ee(e){return e.target||e.srcElement}function Pe(e){var t=e.which;return null==t&&(1&e.button?t=1:2&e.button?t=3:4&e.button&&(t=2)),Ml&&e.ctrlKey&&1==t&&(t=3),t}function Ie(e){if(null==Il){var t=n("span","​");r(e,n("span",[t,document.createTextNode("x")])),0!=e.firstChild.offsetHeight&&(Il=t.offsetWidth<=1&&t.offsetHeight>2&&!(gl&&vl<8))}var i=Il?n("span","​"):n("span"," ",null,"display: inline-block; width: 1px; margin-right: -1px");return i.setAttribute("cm-text",""),i}function ze(e){if(null!=zl)return zl;var n=r(e,document.createTextNode("AخA")),i=Wl(n,0,1).getBoundingClientRect(),o=Wl(n,1,2).getBoundingClientRect();return t(e),!(!i||i.left==i.right)&&(zl=o.right-i.right<3)}function Re(e){if(null!=ns)return ns;var t=r(e,n("span","x")),i=t.getBoundingClientRect(),o=Wl(t,0,1).getBoundingClientRect();return ns=Math.abs(i.left-o.left)>1}function Be(e,t){arguments.length>2&&(t.dependencies=Array.prototype.slice.call(arguments,2)),is[e]=t}function Ge(e){if("string"==typeof e&&os.hasOwnProperty(e))e=os[e];else if(e&&"string"==typeof e.name&&os.hasOwnProperty(e.name)){var t=os[e.name];"string"==typeof t&&(t={name:t}),(e=b(t,e)).name=t.name}else{if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+xml$/.test(e))return Ge("application/xml");if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+json$/.test(e))return Ge("application/json")}return"string"==typeof e?{name:e}:e||{name:"null"}}function Ue(e,t){t=Ge(t);var r=is[t.name];if(!r)return Ue(e,"text/plain");var n=r(e,t);if(ls.hasOwnProperty(t.name)){var i=ls[t.name];for(var o in i)i.hasOwnProperty(o)&&(n.hasOwnProperty(o)&&(n["_"+o]=n[o]),n[o]=i[o])}if(n.name=t.name,t.helperType&&(n.helperType=t.helperType),t.modeProps)for(var l in t.modeProps)n[l]=t.modeProps[l];return n}function Ve(e,t){c(t,ls.hasOwnProperty(e)?ls[e]:ls[e]={})}function Ke(e,t){if(!0===t)return t;if(e.copyState)return e.copyState(t);var r={};for(var n in t){var i=t[n];i instanceof Array&&(i=i.concat([])),r[n]=i}return r}function je(e,t){for(var r;e.innerMode&&(r=e.innerMode(t))&&r.mode!=e;)t=r.state,e=r.mode;return r||{mode:e,state:t}}function Xe(e,t,r){return!e.startState||e.startState(t,r)}function Ye(e,t,r,n){var i=[e.state.modeGen],o={};tt(e,t.text,e.doc.mode,r,function(e,t){return i.push(e,t)},o,n);for(var l=r.state,s=0;s<e.state.overlays.length;++s)!function(n){var l=e.state.overlays[n],s=1,a=0;r.state=!0,tt(e,t.text,l.mode,r,function(e,t){for(var r=s;a<e;){var n=i[s];n>e&&i.splice(s,1,e,i[s+1],n),s+=2,a=Math.min(e,n)}if(t)if(l.opaque)i.splice(r,s-r,e,"overlay "+t),s=r+2;else for(;r<s;r+=2){var o=i[r+1];i[r+1]=(o?o+" ":"")+"overlay "+t}},o)}(s);return r.state=l,{styles:i,classes:o.bgClass||o.textClass?o:null}}function _e(e,t,r){if(!t.styles||t.styles[0]!=e.state.modeGen){var n=$e(e,W(t)),i=t.text.length>e.options.maxHighlightLength&&Ke(e.doc.mode,n.state),o=Ye(e,t,n);i&&(n.state=i),t.stateAfter=n.save(!i),t.styles=o.styles,o.classes?t.styleClasses=o.classes:t.styleClasses&&(t.styleClasses=null),r===e.doc.highlightFrontier&&(e.doc.modeFrontier=Math.max(e.doc.modeFrontier,++e.doc.highlightFrontier))}return t.styles}function $e(e,t,r){var n=e.doc,i=e.display;if(!n.mode.startState)return new us(n,!0,t);var o=rt(e,t,r),l=o>n.first&&M(n,o-1).stateAfter,s=l?us.fromSaved(n,l,o):new us(n,Xe(n.mode),o);return n.iter(o,t,function(r){qe(e,r.text,s);var n=s.line;r.stateAfter=n==t-1||n%5==0||n>=i.viewFrom&&n<i.viewTo?s.save():null,s.nextLine()}),r&&(n.modeFrontier=s.line),s}function qe(e,t,r,n){var i=e.doc.mode,o=new ss(t,e.options.tabSize,r);for(o.start=o.pos=n||0,""==t&&Ze(i,r.state);!o.eol();)Qe(i,o,r.state),o.start=o.pos}function Ze(e,t){if(e.blankLine)return e.blankLine(t);if(e.innerMode){var r=je(e,t);return r.mode.blankLine?r.mode.blankLine(r.state):void 0}}function Qe(e,t,r,n){for(var i=0;i<10;i++){n&&(n[0]=je(e,r).mode);var o=e.token(t,r);if(t.pos>t.start)return o}throw new Error("Mode "+e.name+" failed to advance stream.")}function Je(e,t,r,n){var i,o,l=e.doc,s=l.mode,a=M(l,(t=U(l,t)).line),u=$e(e,t.line,r),c=new ss(a.text,e.options.tabSize,u);for(n&&(o=[]);(n||c.pos<t.ch)&&!c.eol();)c.start=c.pos,i=Qe(s,c,u.state),n&&o.push(new cs(c,i,Ke(l.mode,u.state)));return n?o:new cs(c,i,u.state)}function et(e,t){if(e)for(;;){var r=e.match(/(?:^|\s+)line-(background-)?(\S+)/);if(!r)break;e=e.slice(0,r.index)+e.slice(r.index+r[0].length);var n=r[1]?"bgClass":"textClass";null==t[n]?t[n]=r[2]:new RegExp("(?:^|s)"+r[2]+"(?:$|s)").test(t[n])||(t[n]+=" "+r[2])}return e}function tt(e,t,r,n,i,o,l){var s=r.flattenSpans;null==s&&(s=e.options.flattenSpans);var a,u=0,c=null,f=new ss(t,e.options.tabSize,n),h=e.options.addModeClass&&[null];for(""==t&&et(Ze(r,n.state),o);!f.eol();){if(f.pos>e.options.maxHighlightLength?(s=!1,l&&qe(e,t,n,f.pos),f.pos=t.length,a=null):a=et(Qe(r,f,n.state,h),o),h){var d=h[0].name;d&&(a="m-"+(a?d+" "+a:d))}if(!s||c!=a){for(;u<f.start;)i(u=Math.min(f.start,u+5e3),c);c=a}f.start=f.pos}for(;u<f.pos;){var p=Math.min(f.pos,u+5e3);i(p,c),u=p}}function rt(e,t,r){for(var n,i,o=e.doc,l=r?-1:t-(e.doc.mode.innerMode?1e3:100),s=t;s>l;--s){if(s<=o.first)return o.first;var a=M(o,s-1),u=a.stateAfter;if(u&&(!r||s+(u instanceof as?u.lookAhead:0)<=o.modeFrontier))return s;var c=f(a.text,null,e.options.tabSize);(null==i||n>c)&&(i=s-1,n=c)}return i}function nt(e,t){if(e.modeFrontier=Math.min(e.modeFrontier,t),!(e.highlightFrontier<t-10)){for(var r=e.first,n=t-1;n>r;n--){var i=M(e,n).stateAfter;if(i&&(!(i instanceof as)||n+i.lookAhead<t)){r=n+1;break}}e.highlightFrontier=Math.min(e.highlightFrontier,r)}}function it(e,t,r,n){e.text=t,e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null),null!=e.order&&(e.order=null),re(e),ne(e,r);var i=n?n(e):1;i!=e.height&&A(e,i)}function ot(e){e.parent=null,re(e)}function lt(e,t){if(!e||/^\s*$/.test(e))return null;var r=t.addModeClass?ps:ds;return r[e]||(r[e]=e.replace(/\S+/g,"cm-$&"))}function st(e,t){var r=i("span",null,null,ml?"padding-right: .1px":null),n={pre:i("pre",[r],"CodeMirror-line"),content:r,col:0,pos:0,cm:e,trailingSpace:!1,splitSpaces:(gl||ml)&&e.getOption("lineWrapping")};t.measure={};for(var o=0;o<=(t.rest?t.rest.length:0);o++){var l=o?t.rest[o-1]:t.line,s=void 0;n.pos=0,n.addToken=ut,ze(e.display.measure)&&(s=Se(l,e.doc.direction))&&(n.addToken=ft(n.addToken,s)),n.map=[],dt(l,n,_e(e,l,t!=e.display.externalMeasured&&W(l))),l.styleClasses&&(l.styleClasses.bgClass&&(n.bgClass=a(l.styleClasses.bgClass,n.bgClass||"")),l.styleClasses.textClass&&(n.textClass=a(l.styleClasses.textClass,n.textClass||""))),0==n.map.length&&n.map.push(0,0,n.content.appendChild(Ie(e.display.measure))),0==o?(t.measure.map=n.map,t.measure.cache={}):((t.measure.maps||(t.measure.maps=[])).push(n.map),(t.measure.caches||(t.measure.caches=[])).push({}))}if(ml){var u=n.content.lastChild;(/\bcm-tab\b/.test(u.className)||u.querySelector&&u.querySelector(".cm-tab"))&&(n.content.className="cm-tab-wrap-hack")}return Te(e,"renderLine",e,t.line,n.pre),n.pre.className&&(n.textClass=a(n.pre.className,n.textClass||"")),n}function at(e){var t=n("span","•","cm-invalidchar");return t.title="\\u"+e.charCodeAt(0).toString(16),t.setAttribute("aria-label",t.title),t}function ut(e,t,r,i,o,l,s){if(t){var a,u=e.splitSpaces?ct(t,e.trailingSpace):t,c=e.cm.state.specialChars,f=!1;if(c.test(t)){a=document.createDocumentFragment();for(var h=0;;){c.lastIndex=h;var d=c.exec(t),g=d?d.index-h:t.length-h;if(g){var v=document.createTextNode(u.slice(h,h+g));gl&&vl<9?a.appendChild(n("span",[v])):a.appendChild(v),e.map.push(e.pos,e.pos+g,v),e.col+=g,e.pos+=g}if(!d)break;h+=g+1;var m=void 0;if("\t"==d[0]){var y=e.cm.options.tabSize,b=y-e.col%y;(m=a.appendChild(n("span",p(b),"cm-tab"))).setAttribute("role","presentation"),m.setAttribute("cm-text","\t"),e.col+=b}else"\r"==d[0]||"\n"==d[0]?((m=a.appendChild(n("span","\r"==d[0]?"␍":"␤","cm-invalidchar"))).setAttribute("cm-text",d[0]),e.col+=1):((m=e.cm.options.specialCharPlaceholder(d[0])).setAttribute("cm-text",d[0]),gl&&vl<9?a.appendChild(n("span",[m])):a.appendChild(m),e.col+=1);e.map.push(e.pos,e.pos+1,m),e.pos++}}else e.col+=t.length,a=document.createTextNode(u),e.map.push(e.pos,e.pos+t.length,a),gl&&vl<9&&(f=!0),e.pos+=t.length;if(e.trailingSpace=32==u.charCodeAt(t.length-1),r||i||o||f||s){var w=r||"";i&&(w+=i),o&&(w+=o);var x=n("span",[a],w,s);return l&&(x.title=l),e.content.appendChild(x)}e.content.appendChild(a)}}function ct(e,t){if(e.length>1&&!/  /.test(e))return e;for(var r=t,n="",i=0;i<e.length;i++){var o=e.charAt(i);" "!=o||!r||i!=e.length-1&&32!=e.charCodeAt(i+1)||(o=" "),n+=o,r=" "==o}return n}function ft(e,t){return function(r,n,i,o,l,s,a){i=i?i+" cm-force-border":"cm-force-border";for(var u=r.pos,c=u+n.length;;){for(var f=void 0,h=0;h<t.length&&!((f=t[h]).to>u&&f.from<=u);h++);if(f.to>=c)return e(r,n,i,o,l,s,a);e(r,n.slice(0,f.to-u),i,o,null,s,a),o=null,n=n.slice(f.to-u),u=f.to}}}function ht(e,t,r,n){var i=!n&&r.widgetNode;i&&e.map.push(e.pos,e.pos+t,i),!n&&e.cm.display.input.needsContentAttribute&&(i||(i=e.content.appendChild(document.createElement("span"))),i.setAttribute("cm-marker",r.id)),i&&(e.cm.display.input.setUneditable(i),e.content.appendChild(i)),e.pos+=t,e.trailingSpace=!1}function dt(e,t,r){var n=e.markedSpans,i=e.text,o=0;if(n)for(var l,s,a,u,c,f,h,d=i.length,p=0,g=1,v="",m=0;;){if(m==p){a=u=c=f=s="",h=null,m=1/0;for(var y=[],b=void 0,w=0;w<n.length;++w){var x=n[w],C=x.marker;"bookmark"==C.type&&x.from==p&&C.widgetNode?y.push(C):x.from<=p&&(null==x.to||x.to>p||C.collapsed&&x.to==p&&x.from==p)?(null!=x.to&&x.to!=p&&m>x.to&&(m=x.to,u=""),C.className&&(a+=" "+C.className),C.css&&(s=(s?s+";":"")+C.css),C.startStyle&&x.from==p&&(c+=" "+C.startStyle),C.endStyle&&x.to==m&&(b||(b=[])).push(C.endStyle,x.to),C.title&&!f&&(f=C.title),C.collapsed&&(!h||le(h.marker,C)<0)&&(h=x)):x.from>p&&m>x.from&&(m=x.from)}if(b)for(var S=0;S<b.length;S+=2)b[S+1]==m&&(u+=" "+b[S]);if(!h||h.from==p)for(var L=0;L<y.length;++L)ht(t,0,y[L]);if(h&&(h.from||0)==p){if(ht(t,(null==h.to?d+1:h.to)-p,h.marker,null==h.from),null==h.to)return;h.to==p&&(h=!1)}}if(p>=d)break;for(var k=Math.min(d,m);;){if(v){var T=p+v.length;if(!h){var M=T>k?v.slice(0,k-p):v;t.addToken(t,M,l?l+a:a,c,p+M.length==m?u:"",f,s)}if(T>=k){v=v.slice(k-p),p=k;break}p=T,c=""}v=i.slice(o,o=r[g++]),l=lt(r[g++],t.cm.options)}}else for(var N=1;N<r.length;N+=2)t.addToken(t,i.slice(o,o=r[N]),lt(r[N+1],t.cm.options))}function pt(e,t,r){this.line=t,this.rest=de(t),this.size=this.rest?W(g(this.rest))-r+1:1,this.node=this.text=null,this.hidden=ve(e,t)}function gt(e,t,r){for(var n,i=[],o=t;o<r;o=n){var l=new pt(e.doc,M(e.doc,o),o);n=o+l.size,i.push(l)}return i}function vt(e){gs?gs.ops.push(e):e.ownsGroup=gs={ops:[e],delayedCallbacks:[]}}function mt(e){var t=e.delayedCallbacks,r=0;do{for(;r<t.length;r++)t[r].call(null);for(var n=0;n<e.ops.length;n++){var i=e.ops[n];if(i.cursorActivityHandlers)for(;i.cursorActivityCalled<i.cursorActivityHandlers.length;)i.cursorActivityHandlers[i.cursorActivityCalled++].call(null,i.cm)}}while(r<t.length)}function yt(e,t){var r=e.ownsGroup;if(r)try{mt(r)}finally{gs=null,t(r)}}function bt(e,t){var r=Le(e,t);if(r.length){var n,i=Array.prototype.slice.call(arguments,2);gs?n=gs.delayedCallbacks:vs?n=vs:(n=vs=[],setTimeout(wt,0));for(var o=0;o<r.length;++o)!function(e){n.push(function(){return r[e].apply(null,i)})}(o)}}function wt(){var e=vs;vs=null;for(var t=0;t<e.length;++t)e[t]()}function xt(e,t,r,n){for(var i=0;i<t.changes.length;i++){var o=t.changes[i];"text"==o?kt(e,t):"gutter"==o?Mt(e,t,r,n):"class"==o?Tt(e,t):"widget"==o&&Nt(e,t,n)}t.changes=null}function Ct(e){return e.node==e.text&&(e.node=n("div",null,null,"position: relative"),e.text.parentNode&&e.text.parentNode.replaceChild(e.node,e.text),e.node.appendChild(e.text),gl&&vl<8&&(e.node.style.zIndex=2)),e.node}function St(e,t){var r=t.bgClass?t.bgClass+" "+(t.line.bgClass||""):t.line.bgClass;if(r&&(r+=" CodeMirror-linebackground"),t.background)r?t.background.className=r:(t.background.parentNode.removeChild(t.background),t.background=null);else if(r){var i=Ct(t);t.background=i.insertBefore(n("div",null,r),i.firstChild),e.display.input.setUneditable(t.background)}}function Lt(e,t){var r=e.display.externalMeasured;return r&&r.line==t.line?(e.display.externalMeasured=null,t.measure=r.measure,r.built):st(e,t)}function kt(e,t){var r=t.text.className,n=Lt(e,t);t.text==t.node&&(t.node=n.pre),t.text.parentNode.replaceChild(n.pre,t.text),t.text=n.pre,n.bgClass!=t.bgClass||n.textClass!=t.textClass?(t.bgClass=n.bgClass,t.textClass=n.textClass,Tt(e,t)):r&&(t.text.className=r)}function Tt(e,t){St(e,t),t.line.wrapClass?Ct(t).className=t.line.wrapClass:t.node!=t.text&&(t.node.className="");var r=t.textClass?t.textClass+" "+(t.line.textClass||""):t.line.textClass;t.text.className=r||""}function Mt(e,t,r,i){if(t.gutter&&(t.node.removeChild(t.gutter),t.gutter=null),t.gutterBackground&&(t.node.removeChild(t.gutterBackground),t.gutterBackground=null),t.line.gutterClass){var o=Ct(t);t.gutterBackground=n("div",null,"CodeMirror-gutter-background "+t.line.gutterClass,"left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px; width: "+i.gutterTotalWidth+"px"),e.display.input.setUneditable(t.gutterBackground),o.insertBefore(t.gutterBackground,t.text)}var l=t.line.gutterMarkers;if(e.options.lineNumbers||l){var s=Ct(t),a=t.gutter=n("div",null,"CodeMirror-gutter-wrapper","left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px");if(e.display.input.setUneditable(a),s.insertBefore(a,t.text),t.line.gutterClass&&(a.className+=" "+t.line.gutterClass),!e.options.lineNumbers||l&&l["CodeMirror-linenumbers"]||(t.lineNumber=a.appendChild(n("div",F(e.options,r),"CodeMirror-linenumber CodeMirror-gutter-elt","left: "+i.gutterLeft["CodeMirror-linenumbers"]+"px; width: "+e.display.lineNumInnerWidth+"px"))),l)for(var u=0;u<e.options.gutters.length;++u){var c=e.options.gutters[u],f=l.hasOwnProperty(c)&&l[c];f&&a.appendChild(n("div",[f],"CodeMirror-gutter-elt","left: "+i.gutterLeft[c]+"px; width: "+i.gutterWidth[c]+"px"))}}}function Nt(e,t,r){t.alignable&&(t.alignable=null);for(var n=t.node.firstChild,i=void 0;n;n=i)i=n.nextSibling,"CodeMirror-linewidget"==n.className&&t.node.removeChild(n);At(e,t,r)}function Ot(e,t,r,n){var i=Lt(e,t);return t.text=t.node=i.pre,i.bgClass&&(t.bgClass=i.bgClass),i.textClass&&(t.textClass=i.textClass),Tt(e,t),Mt(e,t,r,n),At(e,t,n),t.node}function At(e,t,r){if(Wt(e,t.line,t,r,!0),t.rest)for(var n=0;n<t.rest.length;n++)Wt(e,t.rest[n],t,r,!1)}function Wt(e,t,r,i,o){if(t.widgets)for(var l=Ct(r),s=0,a=t.widgets;s<a.length;++s){var u=a[s],c=n("div",[u.node],"CodeMirror-linewidget");u.handleMouseEvents||c.setAttribute("cm-ignore-events","true"),Dt(u,c,r,i),e.display.input.setUneditable(c),o&&u.above?l.insertBefore(c,r.gutter||r.text):l.appendChild(c),bt(u,"redraw")}}function Dt(e,t,r,n){if(e.noHScroll){(r.alignable||(r.alignable=[])).push(t);var i=n.wrapperWidth;t.style.left=n.fixedPos+"px",e.coverGutter||(i-=n.gutterTotalWidth,t.style.paddingLeft=n.gutterTotalWidth+"px"),t.style.width=i+"px"}e.coverGutter&&(t.style.zIndex=5,t.style.position="relative",e.noHScroll||(t.style.marginLeft=-n.gutterTotalWidth+"px"))}function Ht(e){if(null!=e.height)return e.height;var t=e.doc.cm;if(!t)return 0;if(!o(document.body,e.node)){var i="position: relative;";e.coverGutter&&(i+="margin-left: -"+t.display.gutters.offsetWidth+"px;"),e.noHScroll&&(i+="width: "+t.display.wrapper.clientWidth+"px;"),r(t.display.measure,n("div",[e.node],null,i))}return e.height=e.node.parentNode.offsetHeight}function Ft(e,t){for(var r=Ee(t);r!=e.wrapper;r=r.parentNode)if(!r||1==r.nodeType&&"true"==r.getAttribute("cm-ignore-events")||r.parentNode==e.sizer&&r!=e.mover)return!0}function Et(e){return e.lineSpace.offsetTop}function Pt(e){return e.mover.offsetHeight-e.lineSpace.offsetHeight}function It(e){if(e.cachedPaddingH)return e.cachedPaddingH;var t=r(e.measure,n("pre","x")),i=window.getComputedStyle?window.getComputedStyle(t):t.currentStyle,o={left:parseInt(i.paddingLeft),right:parseInt(i.paddingRight)};return isNaN(o.left)||isNaN(o.right)||(e.cachedPaddingH=o),o}function zt(e){return Rl-e.display.nativeBarWidth}function Rt(e){return e.display.scroller.clientWidth-zt(e)-e.display.barWidth}function Bt(e){return e.display.scroller.clientHeight-zt(e)-e.display.barHeight}function Gt(e,t,r){var n=e.options.lineWrapping,i=n&&Rt(e);if(!t.measure.heights||n&&t.measure.width!=i){var o=t.measure.heights=[];if(n){t.measure.width=i;for(var l=t.text.firstChild.getClientRects(),s=0;s<l.length-1;s++){var a=l[s],u=l[s+1];Math.abs(a.bottom-u.bottom)>2&&o.push((a.bottom+u.top)/2-r.top)}}o.push(r.bottom-r.top)}}function Ut(e,t,r){if(e.line==t)return{map:e.measure.map,cache:e.measure.cache};for(var n=0;n<e.rest.length;n++)if(e.rest[n]==t)return{map:e.measure.maps[n],cache:e.measure.caches[n]};for(var i=0;i<e.rest.length;i++)if(W(e.rest[i])>r)return{map:e.measure.maps[i],cache:e.measure.caches[i],before:!0}}function Vt(e,t){var n=W(t=fe(t)),i=e.display.externalMeasured=new pt(e.doc,t,n);i.lineN=n;var o=i.built=st(e,i);return i.text=o.pre,r(e.display.lineMeasure,o.pre),i}function Kt(e,t,r,n){return Yt(e,Xt(e,t),r,n)}function jt(e,t){if(t>=e.display.viewFrom&&t<e.display.viewTo)return e.display.view[Lr(e,t)];var r=e.display.externalMeasured;return r&&t>=r.lineN&&t<r.lineN+r.size?r:void 0}function Xt(e,t){var r=W(t),n=jt(e,r);n&&!n.text?n=null:n&&n.changes&&(xt(e,n,r,br(e)),e.curOp.forceUpdate=!0),n||(n=Vt(e,t));var i=Ut(n,t,r);return{line:t,view:n,rect:null,map:i.map,cache:i.cache,before:i.before,hasHeights:!1}}function Yt(e,t,r,n,i){t.before&&(r=-1);var o,l=r+(n||"");return t.cache.hasOwnProperty(l)?o=t.cache[l]:(t.rect||(t.rect=t.view.text.getBoundingClientRect()),t.hasHeights||(Gt(e,t.view,t.rect),t.hasHeights=!0),(o=qt(e,t,r,n)).bogus||(t.cache[l]=o)),{left:o.left,right:o.right,top:i?o.rtop:o.top,bottom:i?o.rbottom:o.bottom}}function _t(e,t,r){for(var n,i,o,l,s,a,u=0;u<e.length;u+=3)if(s=e[u],a=e[u+1],t<s?(i=0,o=1,l="left"):t<a?o=(i=t-s)+1:(u==e.length-3||t==a&&e[u+3]>t)&&(i=(o=a-s)-1,t>=a&&(l="right")),null!=i){if(n=e[u+2],s==a&&r==(n.insertLeft?"left":"right")&&(l=r),"left"==r&&0==i)for(;u&&e[u-2]==e[u-3]&&e[u-1].insertLeft;)n=e[2+(u-=3)],l="left";if("right"==r&&i==a-s)for(;u<e.length-3&&e[u+3]==e[u+4]&&!e[u+5].insertLeft;)n=e[(u+=3)+2],l="right";break}return{node:n,start:i,end:o,collapse:l,coverStart:s,coverEnd:a}}function $t(e,t){var r=ms;if("left"==t)for(var n=0;n<e.length&&(r=e[n]).left==r.right;n++);else for(var i=e.length-1;i>=0&&(r=e[i]).left==r.right;i--);return r}function qt(e,t,r,n){var i,o=_t(t.map,r,n),l=o.node,s=o.start,a=o.end,u=o.collapse;if(3==l.nodeType){for(var c=0;c<4;c++){for(;s&&S(t.line.text.charAt(o.coverStart+s));)--s;for(;o.coverStart+a<o.coverEnd&&S(t.line.text.charAt(o.coverStart+a));)++a;if((i=gl&&vl<9&&0==s&&a==o.coverEnd-o.coverStart?l.parentNode.getBoundingClientRect():$t(Wl(l,s,a).getClientRects(),n)).left||i.right||0==s)break;a=s,s-=1,u="right"}gl&&vl<11&&(i=Zt(e.display.measure,i))}else{s>0&&(u=n="right");var f;i=e.options.lineWrapping&&(f=l.getClientRects()).length>1?f["right"==n?f.length-1:0]:l.getBoundingClientRect()}if(gl&&vl<9&&!s&&(!i||!i.left&&!i.right)){var h=l.parentNode.getClientRects()[0];i=h?{left:h.left,right:h.left+yr(e.display),top:h.top,bottom:h.bottom}:ms}for(var d=i.top-t.rect.top,p=i.bottom-t.rect.top,g=(d+p)/2,v=t.view.measure.heights,m=0;m<v.length-1&&!(g<v[m]);m++);var y=m?v[m-1]:0,b=v[m],w={left:("right"==u?i.right:i.left)-t.rect.left,right:("left"==u?i.left:i.right)-t.rect.left,top:y,bottom:b};return i.left||i.right||(w.bogus=!0),e.options.singleCursorHeightPerLine||(w.rtop=d,w.rbottom=p),w}function Zt(e,t){if(!window.screen||null==screen.logicalXDPI||screen.logicalXDPI==screen.deviceXDPI||!Re(e))return t;var r=screen.logicalXDPI/screen.deviceXDPI,n=screen.logicalYDPI/screen.deviceYDPI;return{left:t.left*r,right:t.right*r,top:t.top*n,bottom:t.bottom*n}}function Qt(e){if(e.measure&&(e.measure.cache={},e.measure.heights=null,e.rest))for(var t=0;t<e.rest.length;t++)e.measure.caches[t]={}}function Jt(e){e.display.externalMeasure=null,t(e.display.lineMeasure);for(var r=0;r<e.display.view.length;r++)Qt(e.display.view[r])}function er(e){Jt(e),e.display.cachedCharWidth=e.display.cachedTextHeight=e.display.cachedPaddingH=null,e.options.lineWrapping||(e.display.maxLineChanged=!0),e.display.lineNumChars=null}function tr(){return bl&&kl?-(document.body.getBoundingClientRect().left-parseInt(getComputedStyle(document.body).marginLeft)):window.pageXOffset||(document.documentElement||document.body).scrollLeft}function rr(){return bl&&kl?-(document.body.getBoundingClientRect().top-parseInt(getComputedStyle(document.body).marginTop)):window.pageYOffset||(document.documentElement||document.body).scrollTop}function nr(e){var t=0;if(e.widgets)for(var r=0;r<e.widgets.length;++r)e.widgets[r].above&&(t+=Ht(e.widgets[r]));return t}function ir(e,t,r,n,i){if(!i){var o=nr(t);r.top+=o,r.bottom+=o}if("line"==n)return r;n||(n="local");var l=ye(t);if("local"==n?l+=Et(e.display):l-=e.display.viewOffset,"page"==n||"window"==n){var s=e.display.lineSpace.getBoundingClientRect();l+=s.top+("window"==n?0:rr());var a=s.left+("window"==n?0:tr());r.left+=a,r.right+=a}return r.top+=l,r.bottom+=l,r}function or(e,t,r){if("div"==r)return t;var n=t.left,i=t.top;if("page"==r)n-=tr(),i-=rr();else if("local"==r||!r){var o=e.display.sizer.getBoundingClientRect();n+=o.left,i+=o.top}var l=e.display.lineSpace.getBoundingClientRect();return{left:n-l.left,top:i-l.top}}function lr(e,t,r,n,i){return n||(n=M(e.doc,t.line)),ir(e,n,Kt(e,n,t.ch,i),r)}function sr(e,t,r,n,i,o){function l(t,l){var s=Yt(e,i,t,l?"right":"left",o);return l?s.left=s.right:s.right=s.left,ir(e,n,s,r)}function s(e,t,r){var n=1==a[t].level;return l(r?e-1:e,n!=r)}n=n||M(e.doc,t.line),i||(i=Xt(e,n));var a=Se(n,e.doc.direction),u=t.ch,c=t.sticky;if(u>=n.text.length?(u=n.text.length,c="before"):u<=0&&(u=0,c="after"),!a)return l("before"==c?u-1:u,"before"==c);var f=Ce(a,u,c),h=$l,d=s(u,f,"before"==c);return null!=h&&(d.other=s(u,h,"before"!=c)),d}function ar(e,t){var r=0;t=U(e.doc,t),e.options.lineWrapping||(r=yr(e.display)*t.ch);var n=M(e.doc,t.line),i=ye(n)+Et(e.display);return{left:r,right:r,top:i,bottom:i+n.height}}function ur(e,t,r,n,i){var o=E(e,t,r);return o.xRel=i,n&&(o.outside=!0),o}function cr(e,t,r){var n=e.doc;if((r+=e.display.viewOffset)<0)return ur(n.first,0,null,!0,-1);var i=D(n,r),o=n.first+n.size-1;if(i>o)return ur(n.first+n.size-1,M(n,o).text.length,null,!0,1);t<0&&(t=0);for(var l=M(n,i);;){var s=pr(e,l,i,t,r),a=ue(l),u=a&&a.find(0,!0);if(!a||!(s.ch>u.from.ch||s.ch==u.from.ch&&s.xRel>0))return s;i=W(l=u.to.line)}}function fr(e,t,r,n){n-=nr(t);var i=t.text.length,o=k(function(t){return Yt(e,r,t-1).bottom<=n},i,0);return i=k(function(t){return Yt(e,r,t).top>n},o,i),{begin:o,end:i}}function hr(e,t,r,n){return r||(r=Xt(e,t)),fr(e,t,r,ir(e,t,Yt(e,r,n),"line").top)}function dr(e,t,r,n){return!(e.bottom<=r)&&(e.top>r||(n?e.left:e.right)>t)}function pr(e,t,r,n,i){i-=ye(t);var o=Xt(e,t),l=nr(t),s=0,a=t.text.length,u=!0,c=Se(t,e.doc.direction);if(c){var f=(e.options.lineWrapping?vr:gr)(e,t,r,o,c,n,i);s=(u=1!=f.level)?f.from:f.to-1,a=u?f.to:f.from-1}var h,d,p=null,g=null,v=k(function(t){var r=Yt(e,o,t);return r.top+=l,r.bottom+=l,!!dr(r,n,i,!1)&&(r.top<=i&&r.left<=n&&(p=t,g=r),!0)},s,a),m=!1;if(g){var y=n-g.left<g.right-n,b=y==u;v=p+(b?0:1),d=b?"after":"before",h=y?g.left:g.right}else{u||v!=a&&v!=s||v++,d=0==v?"after":v==t.text.length?"before":Yt(e,o,v-(u?1:0)).bottom+l<=i==u?"after":"before";var w=sr(e,E(r,v,d),"line",t,o);h=w.left,m=i<w.top||i>=w.bottom}return v=L(t.text,v,1),ur(r,v,d,m,n-h)}function gr(e,t,r,n,i,o,l){var s=k(function(s){var a=i[s],u=1!=a.level;return dr(sr(e,E(r,u?a.to:a.from,u?"before":"after"),"line",t,n),o,l,!0)},0,i.length-1),a=i[s];if(s>0){var u=1!=a.level,c=sr(e,E(r,u?a.from:a.to,u?"after":"before"),"line",t,n);dr(c,o,l,!0)&&c.top>l&&(a=i[s-1])}return a}function vr(e,t,r,n,i,o,l){for(var s=fr(e,t,n,l),a=s.begin,u=s.end,c=null,f=null,h=0;h<i.length;h++){var d=i[h];if(!(d.from>=u||d.to<=a)){var p=Yt(e,n,1!=d.level?Math.min(u,d.to)-1:Math.max(a,d.from)).right,g=p<o?o-p+1e9:p-o;(!c||f>g)&&(c=d,f=g)}}return c||(c=i[i.length-1]),c.from<a&&(c={from:a,to:c.to,level:c.level}),c.to>u&&(c={from:c.from,to:u,level:c.level}),c}function mr(e){if(null!=e.cachedTextHeight)return e.cachedTextHeight;if(null==hs){hs=n("pre");for(var i=0;i<49;++i)hs.appendChild(document.createTextNode("x")),hs.appendChild(n("br"));hs.appendChild(document.createTextNode("x"))}r(e.measure,hs);var o=hs.offsetHeight/50;return o>3&&(e.cachedTextHeight=o),t(e.measure),o||1}function yr(e){if(null!=e.cachedCharWidth)return e.cachedCharWidth;var t=n("span","xxxxxxxxxx"),i=n("pre",[t]);r(e.measure,i);var o=t.getBoundingClientRect(),l=(o.right-o.left)/10;return l>2&&(e.cachedCharWidth=l),l||10}function br(e){for(var t=e.display,r={},n={},i=t.gutters.clientLeft,o=t.gutters.firstChild,l=0;o;o=o.nextSibling,++l)r[e.options.gutters[l]]=o.offsetLeft+o.clientLeft+i,n[e.options.gutters[l]]=o.clientWidth;return{fixedPos:wr(t),gutterTotalWidth:t.gutters.offsetWidth,gutterLeft:r,gutterWidth:n,wrapperWidth:t.wrapper.clientWidth}}function wr(e){return e.scroller.getBoundingClientRect().left-e.sizer.getBoundingClientRect().left}function xr(e){var t=mr(e.display),r=e.options.lineWrapping,n=r&&Math.max(5,e.display.scroller.clientWidth/yr(e.display)-3);return function(i){if(ve(e.doc,i))return 0;var o=0;if(i.widgets)for(var l=0;l<i.widgets.length;l++)i.widgets[l].height&&(o+=i.widgets[l].height);return r?o+(Math.ceil(i.text.length/n)||1)*t:o+t}}function Cr(e){var t=e.doc,r=xr(e);t.iter(function(e){var t=r(e);t!=e.height&&A(e,t)})}function Sr(e,t,r,n){var i=e.display;if(!r&&"true"==Ee(t).getAttribute("cm-not-content"))return null;var o,l,s=i.lineSpace.getBoundingClientRect();try{o=t.clientX-s.left,l=t.clientY-s.top}catch(t){return null}var a,u=cr(e,o,l);if(n&&1==u.xRel&&(a=M(e.doc,u.line).text).length==u.ch){var c=f(a,a.length,e.options.tabSize)-a.length;u=E(u.line,Math.max(0,Math.round((o-It(e.display).left)/yr(e.display))-c))}return u}function Lr(e,t){if(t>=e.display.viewTo)return null;if((t-=e.display.viewFrom)<0)return null;for(var r=e.display.view,n=0;n<r.length;n++)if((t-=r[n].size)<0)return n}function kr(e){e.display.input.showSelection(e.display.input.prepareSelection())}function Tr(e,t){void 0===t&&(t=!0);for(var r=e.doc,n={},i=n.cursors=document.createDocumentFragment(),o=n.selection=document.createDocumentFragment(),l=0;l<r.sel.ranges.length;l++)if(t||l!=r.sel.primIndex){var s=r.sel.ranges[l];if(!(s.from().line>=e.display.viewTo||s.to().line<e.display.viewFrom)){var a=s.empty();(a||e.options.showCursorWhenSelecting)&&Mr(e,s.head,i),a||Or(e,s,o)}}return n}function Mr(e,t,r){var i=sr(e,t,"div",null,null,!e.options.singleCursorHeightPerLine),o=r.appendChild(n("div"," ","CodeMirror-cursor"));if(o.style.left=i.left+"px",o.style.top=i.top+"px",o.style.height=Math.max(0,i.bottom-i.top)*e.options.cursorHeight+"px",i.other){var l=r.appendChild(n("div"," ","CodeMirror-cursor CodeMirror-secondarycursor"));l.style.display="",l.style.left=i.other.left+"px",l.style.top=i.other.top+"px",l.style.height=.85*(i.other.bottom-i.other.top)+"px"}}function Nr(e,t){return e.top-t.top||e.left-t.left}function Or(e,t,r){function i(e,t,r,i){t<0&&(t=0),t=Math.round(t),i=Math.round(i),a.appendChild(n("div",null,"CodeMirror-selected","position: absolute; left: "+e+"px;\n                             top: "+t+"px; width: "+(null==r?f-e:r)+"px;\n                             height: "+(i-t)+"px"))}function o(t,r,n){function o(r,n){return lr(e,E(t,r),"div",u,n)}var l,a,u=M(s,t),h=u.text.length,d=Se(u,s.direction);return xe(d,r||0,null==n?h:n,function(t,s,p,g){var v=o(t,"ltr"==p?"left":"right"),m=o(s-1,"ltr"==p?"right":"left");if("ltr"==p){var y=null==r&&0==t?c:v.left,b=null==n&&s==h?f:m.right;m.top-v.top<=3?i(y,m.top,b-y,m.bottom):(i(y,v.top,null,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top),i(c,m.top,m.right,m.bottom))}else if(t<s){var w=null==r&&0==t?f:v.right,x=null==n&&s==h?c:m.left;if(m.top-v.top<=3)i(x,m.top,w-x,m.bottom);else{var C=c;if(g){var S=hr(e,u,null,t).end;C=o(S-(/\s/.test(u.text.charAt(S-1))?2:1),"left").left}i(C,v.top,w-C,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top);var L=null;d.length,L=o(hr(e,u,null,s).begin,"right").right-x,i(x,m.top,L,m.bottom)}}(!l||Nr(v,l)<0)&&(l=v),Nr(m,l)<0&&(l=m),(!a||Nr(v,a)<0)&&(a=v),Nr(m,a)<0&&(a=m)}),{start:l,end:a}}var l=e.display,s=e.doc,a=document.createDocumentFragment(),u=It(e.display),c=u.left,f=Math.max(l.sizerWidth,Rt(e)-l.sizer.offsetLeft)-u.right,h=t.from(),d=t.to();if(h.line==d.line)o(h.line,h.ch,d.ch);else{var p=M(s,h.line),g=M(s,d.line),v=fe(p)==fe(g),m=o(h.line,h.ch,v?p.text.length+1:null).end,y=o(d.line,v?0:null,d.ch).start;v&&(m.top<y.top-2?(i(m.right,m.top,null,m.bottom),i(c,y.top,y.left,y.bottom)):i(m.right,m.top,y.left-m.right,m.bottom)),m.bottom<y.top&&i(c,m.bottom,null,y.top)}r.appendChild(a)}function Ar(e){if(e.state.focused){var t=e.display;clearInterval(t.blinker);var r=!0;t.cursorDiv.style.visibility="",e.options.cursorBlinkRate>0?t.blinker=setInterval(function(){return t.cursorDiv.style.visibility=(r=!r)?"":"hidden"},e.options.cursorBlinkRate):e.options.cursorBlinkRate<0&&(t.cursorDiv.style.visibility="hidden")}}function Wr(e){e.state.focused||(e.display.input.focus(),Hr(e))}function Dr(e){e.state.delayingBlurEvent=!0,setTimeout(function(){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1,Fr(e))},100)}function Hr(e,t){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1),"nocursor"!=e.options.readOnly&&(e.state.focused||(Te(e,"focus",e,t),e.state.focused=!0,s(e.display.wrapper,"CodeMirror-focused"),e.curOp||e.display.selForContextMenu==e.doc.sel||(e.display.input.reset(),ml&&setTimeout(function(){return e.display.input.reset(!0)},20)),e.display.input.receivedFocus()),Ar(e))}function Fr(e,t){e.state.delayingBlurEvent||(e.state.focused&&(Te(e,"blur",e,t),e.state.focused=!1,Fl(e.display.wrapper,"CodeMirror-focused")),clearInterval(e.display.blinker),setTimeout(function(){e.state.focused||(e.display.shift=!1)},150))}function Er(e){for(var t=e.display,r=t.lineDiv.offsetTop,n=0;n<t.view.length;n++){var i=t.view[n],o=void 0;if(!i.hidden){if(gl&&vl<8){var l=i.node.offsetTop+i.node.offsetHeight;o=l-r,r=l}else{var s=i.node.getBoundingClientRect();o=s.bottom-s.top}var a=i.line.height-o;if(o<2&&(o=mr(t)),(a>.005||a<-.005)&&(A(i.line,o),Pr(i.line),i.rest))for(var u=0;u<i.rest.length;u++)Pr(i.rest[u])}}}function Pr(e){if(e.widgets)for(var t=0;t<e.widgets.length;++t)e.widgets[t].height=e.widgets[t].node.parentNode.offsetHeight}function Ir(e,t,r){var n=r&&null!=r.top?Math.max(0,r.top):e.scroller.scrollTop;n=Math.floor(n-Et(e));var i=r&&null!=r.bottom?r.bottom:n+e.wrapper.clientHeight,o=D(t,n),l=D(t,i);if(r&&r.ensure){var s=r.ensure.from.line,a=r.ensure.to.line;s<o?(o=s,l=D(t,ye(M(t,s))+e.wrapper.clientHeight)):Math.min(a,t.lastLine())>=l&&(o=D(t,ye(M(t,a))-e.wrapper.clientHeight),l=a)}return{from:o,to:Math.max(l,o+1)}}function zr(e){var t=e.display,r=t.view;if(t.alignWidgets||t.gutters.firstChild&&e.options.fixedGutter){for(var n=wr(t)-t.scroller.scrollLeft+e.doc.scrollLeft,i=t.gutters.offsetWidth,o=n+"px",l=0;l<r.length;l++)if(!r[l].hidden){e.options.fixedGutter&&(r[l].gutter&&(r[l].gutter.style.left=o),r[l].gutterBackground&&(r[l].gutterBackground.style.left=o));var s=r[l].alignable;if(s)for(var a=0;a<s.length;a++)s[a].style.left=o}e.options.fixedGutter&&(t.gutters.style.left=n+i+"px")}}function Rr(e){if(!e.options.lineNumbers)return!1;var t=e.doc,r=F(e.options,t.first+t.size-1),i=e.display;if(r.length!=i.lineNumChars){var o=i.measure.appendChild(n("div",[n("div",r)],"CodeMirror-linenumber CodeMirror-gutter-elt")),l=o.firstChild.offsetWidth,s=o.offsetWidth-l;return i.lineGutter.style.width="",i.lineNumInnerWidth=Math.max(l,i.lineGutter.offsetWidth-s)+1,i.lineNumWidth=i.lineNumInnerWidth+s,i.lineNumChars=i.lineNumInnerWidth?r.length:-1,i.lineGutter.style.width=i.lineNumWidth+"px",Wn(e),!0}return!1}function Br(e,t){if(!Me(e,"scrollCursorIntoView")){var r=e.display,i=r.sizer.getBoundingClientRect(),o=null;if(t.top+i.top<0?o=!0:t.bottom+i.top>(window.innerHeight||document.documentElement.clientHeight)&&(o=!1),null!=o&&!Sl){var l=n("div","​",null,"position: absolute;\n                         top: "+(t.top-r.viewOffset-Et(e.display))+"px;\n                         height: "+(t.bottom-t.top+zt(e)+r.barHeight)+"px;\n                         left: "+t.left+"px; width: "+Math.max(2,t.right-t.left)+"px;");e.display.lineSpace.appendChild(l),l.scrollIntoView(o),e.display.lineSpace.removeChild(l)}}}function Gr(e,t,r,n){null==n&&(n=0);var i;e.options.lineWrapping||t!=r||(r="before"==(t=t.ch?E(t.line,"before"==t.sticky?t.ch-1:t.ch,"after"):t).sticky?E(t.line,t.ch+1,"before"):t);for(var o=0;o<5;o++){var l=!1,s=sr(e,t),a=r&&r!=t?sr(e,r):s,u=Vr(e,i={left:Math.min(s.left,a.left),top:Math.min(s.top,a.top)-n,right:Math.max(s.left,a.left),bottom:Math.max(s.bottom,a.bottom)+n}),c=e.doc.scrollTop,f=e.doc.scrollLeft;if(null!=u.scrollTop&&(qr(e,u.scrollTop),Math.abs(e.doc.scrollTop-c)>1&&(l=!0)),null!=u.scrollLeft&&(Qr(e,u.scrollLeft),Math.abs(e.doc.scrollLeft-f)>1&&(l=!0)),!l)break}return i}function Ur(e,t){var r=Vr(e,t);null!=r.scrollTop&&qr(e,r.scrollTop),null!=r.scrollLeft&&Qr(e,r.scrollLeft)}function Vr(e,t){var r=e.display,n=mr(e.display);t.top<0&&(t.top=0);var i=e.curOp&&null!=e.curOp.scrollTop?e.curOp.scrollTop:r.scroller.scrollTop,o=Bt(e),l={};t.bottom-t.top>o&&(t.bottom=t.top+o);var s=e.doc.height+Pt(r),a=t.top<n,u=t.bottom>s-n;if(t.top<i)l.scrollTop=a?0:t.top;else if(t.bottom>i+o){var c=Math.min(t.top,(u?s:t.bottom)-o);c!=i&&(l.scrollTop=c)}var f=e.curOp&&null!=e.curOp.scrollLeft?e.curOp.scrollLeft:r.scroller.scrollLeft,h=Rt(e)-(e.options.fixedGutter?r.gutters.offsetWidth:0),d=t.right-t.left>h;return d&&(t.right=t.left+h),t.left<10?l.scrollLeft=0:t.left<f?l.scrollLeft=Math.max(0,t.left-(d?0:10)):t.right>h+f-3&&(l.scrollLeft=t.right+(d?0:10)-h),l}function Kr(e,t){null!=t&&(_r(e),e.curOp.scrollTop=(null==e.curOp.scrollTop?e.doc.scrollTop:e.curOp.scrollTop)+t)}function jr(e){_r(e);var t=e.getCursor();e.curOp.scrollToPos={from:t,to:t,margin:e.options.cursorScrollMargin}}function Xr(e,t,r){null==t&&null==r||_r(e),null!=t&&(e.curOp.scrollLeft=t),null!=r&&(e.curOp.scrollTop=r)}function Yr(e,t){_r(e),e.curOp.scrollToPos=t}function _r(e){var t=e.curOp.scrollToPos;t&&(e.curOp.scrollToPos=null,$r(e,ar(e,t.from),ar(e,t.to),t.margin))}function $r(e,t,r,n){var i=Vr(e,{left:Math.min(t.left,r.left),top:Math.min(t.top,r.top)-n,right:Math.max(t.right,r.right),bottom:Math.max(t.bottom,r.bottom)+n});Xr(e,i.scrollLeft,i.scrollTop)}function qr(e,t){Math.abs(e.doc.scrollTop-t)<2||(fl||On(e,{top:t}),Zr(e,t,!0),fl&&On(e),Cn(e,100))}function Zr(e,t,r){t=Math.min(e.display.scroller.scrollHeight-e.display.scroller.clientHeight,t),(e.display.scroller.scrollTop!=t||r)&&(e.doc.scrollTop=t,e.display.scrollbars.setScrollTop(t),e.display.scroller.scrollTop!=t&&(e.display.scroller.scrollTop=t))}function Qr(e,t,r,n){t=Math.min(t,e.display.scroller.scrollWidth-e.display.scroller.clientWidth),(r?t==e.doc.scrollLeft:Math.abs(e.doc.scrollLeft-t)<2)&&!n||(e.doc.scrollLeft=t,zr(e),e.display.scroller.scrollLeft!=t&&(e.display.scroller.scrollLeft=t),e.display.scrollbars.setScrollLeft(t))}function Jr(e){var t=e.display,r=t.gutters.offsetWidth,n=Math.round(e.doc.height+Pt(e.display));return{clientHeight:t.scroller.clientHeight,viewHeight:t.wrapper.clientHeight,scrollWidth:t.scroller.scrollWidth,clientWidth:t.scroller.clientWidth,viewWidth:t.wrapper.clientWidth,barLeft:e.options.fixedGutter?r:0,docHeight:n,scrollHeight:n+zt(e)+t.barHeight,nativeBarWidth:t.nativeBarWidth,gutterWidth:r}}function en(e,t){t||(t=Jr(e));var r=e.display.barWidth,n=e.display.barHeight;tn(e,t);for(var i=0;i<4&&r!=e.display.barWidth||n!=e.display.barHeight;i++)r!=e.display.barWidth&&e.options.lineWrapping&&Er(e),tn(e,Jr(e)),r=e.display.barWidth,n=e.display.barHeight}function tn(e,t){var r=e.display,n=r.scrollbars.update(t);r.sizer.style.paddingRight=(r.barWidth=n.right)+"px",r.sizer.style.paddingBottom=(r.barHeight=n.bottom)+"px",r.heightForcer.style.borderBottom=n.bottom+"px solid transparent",n.right&&n.bottom?(r.scrollbarFiller.style.display="block",r.scrollbarFiller.style.height=n.bottom+"px",r.scrollbarFiller.style.width=n.right+"px"):r.scrollbarFiller.style.display="",n.bottom&&e.options.coverGutterNextToScrollbar&&e.options.fixedGutter?(r.gutterFiller.style.display="block",r.gutterFiller.style.height=n.bottom+"px",r.gutterFiller.style.width=t.gutterWidth+"px"):r.gutterFiller.style.display=""}function rn(e){e.display.scrollbars&&(e.display.scrollbars.clear(),e.display.scrollbars.addClass&&Fl(e.display.wrapper,e.display.scrollbars.addClass)),e.display.scrollbars=new ws[e.options.scrollbarStyle](function(t){e.display.wrapper.insertBefore(t,e.display.scrollbarFiller),Ql(t,"mousedown",function(){e.state.focused&&setTimeout(function(){return e.display.input.focus()},0)}),t.setAttribute("cm-not-content","true")},function(t,r){"horizontal"==r?Qr(e,t):qr(e,t)},e),e.display.scrollbars.addClass&&s(e.display.wrapper,e.display.scrollbars.addClass)}function nn(e){e.curOp={cm:e,viewChanged:!1,startHeight:e.doc.height,forceUpdate:!1,updateInput:null,typing:!1,changeObjs:null,cursorActivityHandlers:null,cursorActivityCalled:0,selectionChanged:!1,updateMaxLine:!1,scrollLeft:null,scrollTop:null,scrollToPos:null,focus:!1,id:++xs},vt(e.curOp)}function on(e){yt(e.curOp,function(e){for(var t=0;t<e.ops.length;t++)e.ops[t].cm.curOp=null;ln(e)})}function ln(e){for(var t=e.ops,r=0;r<t.length;r++)sn(t[r]);for(var n=0;n<t.length;n++)an(t[n]);for(var i=0;i<t.length;i++)un(t[i]);for(var o=0;o<t.length;o++)cn(t[o]);for(var l=0;l<t.length;l++)fn(t[l])}function sn(e){var t=e.cm,r=t.display;Ln(t),e.updateMaxLine&&we(t),e.mustUpdate=e.viewChanged||e.forceUpdate||null!=e.scrollTop||e.scrollToPos&&(e.scrollToPos.from.line<r.viewFrom||e.scrollToPos.to.line>=r.viewTo)||r.maxLineChanged&&t.options.lineWrapping,e.update=e.mustUpdate&&new Cs(t,e.mustUpdate&&{top:e.scrollTop,ensure:e.scrollToPos},e.forceUpdate)}function an(e){e.updatedDisplay=e.mustUpdate&&Mn(e.cm,e.update)}function un(e){var t=e.cm,r=t.display;e.updatedDisplay&&Er(t),e.barMeasure=Jr(t),r.maxLineChanged&&!t.options.lineWrapping&&(e.adjustWidthTo=Kt(t,r.maxLine,r.maxLine.text.length).left+3,t.display.sizerWidth=e.adjustWidthTo,e.barMeasure.scrollWidth=Math.max(r.scroller.clientWidth,r.sizer.offsetLeft+e.adjustWidthTo+zt(t)+t.display.barWidth),e.maxScrollLeft=Math.max(0,r.sizer.offsetLeft+e.adjustWidthTo-Rt(t))),(e.updatedDisplay||e.selectionChanged)&&(e.preparedSelection=r.input.prepareSelection())}function cn(e){var t=e.cm;null!=e.adjustWidthTo&&(t.display.sizer.style.minWidth=e.adjustWidthTo+"px",e.maxScrollLeft<t.doc.scrollLeft&&Qr(t,Math.min(t.display.scroller.scrollLeft,e.maxScrollLeft),!0),t.display.maxLineChanged=!1);var r=e.focus&&e.focus==l();e.preparedSelection&&t.display.input.showSelection(e.preparedSelection,r),(e.updatedDisplay||e.startHeight!=t.doc.height)&&en(t,e.barMeasure),e.updatedDisplay&&Dn(t,e.barMeasure),e.selectionChanged&&Ar(t),t.state.focused&&e.updateInput&&t.display.input.reset(e.typing),r&&Wr(e.cm)}function fn(e){var t=e.cm,r=t.display,n=t.doc;e.updatedDisplay&&Nn(t,e.update),null==r.wheelStartX||null==e.scrollTop&&null==e.scrollLeft&&!e.scrollToPos||(r.wheelStartX=r.wheelStartY=null),null!=e.scrollTop&&Zr(t,e.scrollTop,e.forceScroll),null!=e.scrollLeft&&Qr(t,e.scrollLeft,!0,!0),e.scrollToPos&&Br(t,Gr(t,U(n,e.scrollToPos.from),U(n,e.scrollToPos.to),e.scrollToPos.margin));var i=e.maybeHiddenMarkers,o=e.maybeUnhiddenMarkers;if(i)for(var l=0;l<i.length;++l)i[l].lines.length||Te(i[l],"hide");if(o)for(var s=0;s<o.length;++s)o[s].lines.length&&Te(o[s],"unhide");r.wrapper.offsetHeight&&(n.scrollTop=t.display.scroller.scrollTop),e.changeObjs&&Te(t,"changes",t,e.changeObjs),e.update&&e.update.finish()}function hn(e,t){if(e.curOp)return t();nn(e);try{return t()}finally{on(e)}}function dn(e,t){return function(){if(e.curOp)return t.apply(e,arguments);nn(e);try{return t.apply(e,arguments)}finally{on(e)}}}function pn(e){return function(){if(this.curOp)return e.apply(this,arguments);nn(this);try{return e.apply(this,arguments)}finally{on(this)}}}function gn(e){return function(){var t=this.cm;if(!t||t.curOp)return e.apply(this,arguments);nn(t);try{return e.apply(this,arguments)}finally{on(t)}}}function vn(e,t,r,n){null==t&&(t=e.doc.first),null==r&&(r=e.doc.first+e.doc.size),n||(n=0);var i=e.display;if(n&&r<i.viewTo&&(null==i.updateLineNumbers||i.updateLineNumbers>t)&&(i.updateLineNumbers=t),e.curOp.viewChanged=!0,t>=i.viewTo)_l&&pe(e.doc,t)<i.viewTo&&yn(e);else if(r<=i.viewFrom)_l&&ge(e.doc,r+n)>i.viewFrom?yn(e):(i.viewFrom+=n,i.viewTo+=n);else if(t<=i.viewFrom&&r>=i.viewTo)yn(e);else if(t<=i.viewFrom){var o=bn(e,r,r+n,1);o?(i.view=i.view.slice(o.index),i.viewFrom=o.lineN,i.viewTo+=n):yn(e)}else if(r>=i.viewTo){var l=bn(e,t,t,-1);l?(i.view=i.view.slice(0,l.index),i.viewTo=l.lineN):yn(e)}else{var s=bn(e,t,t,-1),a=bn(e,r,r+n,1);s&&a?(i.view=i.view.slice(0,s.index).concat(gt(e,s.lineN,a.lineN)).concat(i.view.slice(a.index)),i.viewTo+=n):yn(e)}var u=i.externalMeasured;u&&(r<u.lineN?u.lineN+=n:t<u.lineN+u.size&&(i.externalMeasured=null))}function mn(e,t,r){e.curOp.viewChanged=!0;var n=e.display,i=e.display.externalMeasured;if(i&&t>=i.lineN&&t<i.lineN+i.size&&(n.externalMeasured=null),!(t<n.viewFrom||t>=n.viewTo)){var o=n.view[Lr(e,t)];if(null!=o.node){var l=o.changes||(o.changes=[]);-1==h(l,r)&&l.push(r)}}}function yn(e){e.display.viewFrom=e.display.viewTo=e.doc.first,e.display.view=[],e.display.viewOffset=0}function bn(e,t,r,n){var i,o=Lr(e,t),l=e.display.view;if(!_l||r==e.doc.first+e.doc.size)return{index:o,lineN:r};for(var s=e.display.viewFrom,a=0;a<o;a++)s+=l[a].size;if(s!=t){if(n>0){if(o==l.length-1)return null;i=s+l[o].size-t,o++}else i=s-t;t+=i,r+=i}for(;pe(e.doc,r)!=r;){if(o==(n<0?0:l.length-1))return null;r+=n*l[o-(n<0?1:0)].size,o+=n}return{index:o,lineN:r}}function wn(e,t,r){var n=e.display;0==n.view.length||t>=n.viewTo||r<=n.viewFrom?(n.view=gt(e,t,r),n.viewFrom=t):(n.viewFrom>t?n.view=gt(e,t,n.viewFrom).concat(n.view):n.viewFrom<t&&(n.view=n.view.slice(Lr(e,t))),n.viewFrom=t,n.viewTo<r?n.view=n.view.concat(gt(e,n.viewTo,r)):n.viewTo>r&&(n.view=n.view.slice(0,Lr(e,r)))),n.viewTo=r}function xn(e){for(var t=e.display.view,r=0,n=0;n<t.length;n++){var i=t[n];i.hidden||i.node&&!i.changes||++r}return r}function Cn(e,t){e.doc.highlightFrontier<e.display.viewTo&&e.state.highlight.set(t,u(Sn,e))}function Sn(e){var t=e.doc;if(!(t.highlightFrontier>=e.display.viewTo)){var r=+new Date+e.options.workTime,n=$e(e,t.highlightFrontier),i=[];t.iter(n.line,Math.min(t.first+t.size,e.display.viewTo+500),function(o){if(n.line>=e.display.viewFrom){var l=o.styles,s=o.text.length>e.options.maxHighlightLength?Ke(t.mode,n.state):null,a=Ye(e,o,n,!0);s&&(n.state=s),o.styles=a.styles;var u=o.styleClasses,c=a.classes;c?o.styleClasses=c:u&&(o.styleClasses=null);for(var f=!l||l.length!=o.styles.length||u!=c&&(!u||!c||u.bgClass!=c.bgClass||u.textClass!=c.textClass),h=0;!f&&h<l.length;++h)f=l[h]!=o.styles[h];f&&i.push(n.line),o.stateAfter=n.save(),n.nextLine()}else o.text.length<=e.options.maxHighlightLength&&qe(e,o.text,n),o.stateAfter=n.line%5==0?n.save():null,n.nextLine();if(+new Date>r)return Cn(e,e.options.workDelay),!0}),t.highlightFrontier=n.line,t.modeFrontier=Math.max(t.modeFrontier,n.line),i.length&&hn(e,function(){for(var t=0;t<i.length;t++)mn(e,i[t],"text")})}}function Ln(e){var t=e.display;!t.scrollbarsClipped&&t.scroller.offsetWidth&&(t.nativeBarWidth=t.scroller.offsetWidth-t.scroller.clientWidth,t.heightForcer.style.height=zt(e)+"px",t.sizer.style.marginBottom=-t.nativeBarWidth+"px",t.sizer.style.borderRightWidth=zt(e)+"px",t.scrollbarsClipped=!0)}function kn(e){if(e.hasFocus())return null;var t=l();if(!t||!o(e.display.lineDiv,t))return null;var r={activeElt:t};if(window.getSelection){var n=window.getSelection();n.anchorNode&&n.extend&&o(e.display.lineDiv,n.anchorNode)&&(r.anchorNode=n.anchorNode,r.anchorOffset=n.anchorOffset,r.focusNode=n.focusNode,r.focusOffset=n.focusOffset)}return r}function Tn(e){if(e&&e.activeElt&&e.activeElt!=l()&&(e.activeElt.focus(),e.anchorNode&&o(document.body,e.anchorNode)&&o(document.body,e.focusNode))){var t=window.getSelection(),r=document.createRange();r.setEnd(e.anchorNode,e.anchorOffset),r.collapse(!1),t.removeAllRanges(),t.addRange(r),t.extend(e.focusNode,e.focusOffset)}}function Mn(e,r){var n=e.display,i=e.doc;if(r.editorIsHidden)return yn(e),!1;if(!r.force&&r.visible.from>=n.viewFrom&&r.visible.to<=n.viewTo&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo)&&n.renderedView==n.view&&0==xn(e))return!1;Rr(e)&&(yn(e),r.dims=br(e));var o=i.first+i.size,l=Math.max(r.visible.from-e.options.viewportMargin,i.first),s=Math.min(o,r.visible.to+e.options.viewportMargin);n.viewFrom<l&&l-n.viewFrom<20&&(l=Math.max(i.first,n.viewFrom)),n.viewTo>s&&n.viewTo-s<20&&(s=Math.min(o,n.viewTo)),_l&&(l=pe(e.doc,l),s=ge(e.doc,s));var a=l!=n.viewFrom||s!=n.viewTo||n.lastWrapHeight!=r.wrapperHeight||n.lastWrapWidth!=r.wrapperWidth;wn(e,l,s),n.viewOffset=ye(M(e.doc,n.viewFrom)),e.display.mover.style.top=n.viewOffset+"px";var u=xn(e);if(!a&&0==u&&!r.force&&n.renderedView==n.view&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo))return!1;var c=kn(e);return u>4&&(n.lineDiv.style.display="none"),An(e,n.updateLineNumbers,r.dims),u>4&&(n.lineDiv.style.display=""),n.renderedView=n.view,Tn(c),t(n.cursorDiv),t(n.selectionDiv),n.gutters.style.height=n.sizer.style.minHeight=0,a&&(n.lastWrapHeight=r.wrapperHeight,n.lastWrapWidth=r.wrapperWidth,Cn(e,400)),n.updateLineNumbers=null,!0}function Nn(e,t){for(var r=t.viewport,n=!0;(n&&e.options.lineWrapping&&t.oldDisplayWidth!=Rt(e)||(r&&null!=r.top&&(r={top:Math.min(e.doc.height+Pt(e.display)-Bt(e),r.top)}),t.visible=Ir(e.display,e.doc,r),!(t.visible.from>=e.display.viewFrom&&t.visible.to<=e.display.viewTo)))&&Mn(e,t);n=!1){Er(e);var i=Jr(e);kr(e),en(e,i),Dn(e,i),t.force=!1}t.signal(e,"update",e),e.display.viewFrom==e.display.reportedViewFrom&&e.display.viewTo==e.display.reportedViewTo||(t.signal(e,"viewportChange",e,e.display.viewFrom,e.display.viewTo),e.display.reportedViewFrom=e.display.viewFrom,e.display.reportedViewTo=e.display.viewTo)}function On(e,t){var r=new Cs(e,t);if(Mn(e,r)){Er(e),Nn(e,r);var n=Jr(e);kr(e),en(e,n),Dn(e,n),r.finish()}}function An(e,r,n){function i(t){var r=t.nextSibling;return ml&&Ml&&e.display.currentWheelTarget==t?t.style.display="none":t.parentNode.removeChild(t),r}for(var o=e.display,l=e.options.lineNumbers,s=o.lineDiv,a=s.firstChild,u=o.view,c=o.viewFrom,f=0;f<u.length;f++){var d=u[f];if(d.hidden);else if(d.node&&d.node.parentNode==s){for(;a!=d.node;)a=i(a);var p=l&&null!=r&&r<=c&&d.lineNumber;d.changes&&(h(d.changes,"gutter")>-1&&(p=!1),xt(e,d,c,n)),p&&(t(d.lineNumber),d.lineNumber.appendChild(document.createTextNode(F(e.options,c)))),a=d.node.nextSibling}else{var g=Ot(e,d,c,n);s.insertBefore(g,a)}c+=d.size}for(;a;)a=i(a)}function Wn(e){var t=e.display.gutters.offsetWidth;e.display.sizer.style.marginLeft=t+"px"}function Dn(e,t){e.display.sizer.style.minHeight=t.docHeight+"px",e.display.heightForcer.style.top=t.docHeight+"px",e.display.gutters.style.height=t.docHeight+e.display.barHeight+zt(e)+"px"}function Hn(e){var r=e.display.gutters,i=e.options.gutters;t(r);for(var o=0;o<i.length;++o){var l=i[o],s=r.appendChild(n("div",null,"CodeMirror-gutter "+l));"CodeMirror-linenumbers"==l&&(e.display.lineGutter=s,s.style.width=(e.display.lineNumWidth||1)+"px")}r.style.display=o?"":"none",Wn(e)}function Fn(e){var t=h(e.gutters,"CodeMirror-linenumbers");-1==t&&e.lineNumbers?e.gutters=e.gutters.concat(["CodeMirror-linenumbers"]):t>-1&&!e.lineNumbers&&(e.gutters=e.gutters.slice(0),e.gutters.splice(t,1))}function En(e){var t=e.wheelDeltaX,r=e.wheelDeltaY;return null==t&&e.detail&&e.axis==e.HORIZONTAL_AXIS&&(t=e.detail),null==r&&e.detail&&e.axis==e.VERTICAL_AXIS?r=e.detail:null==r&&(r=e.wheelDelta),{x:t,y:r}}function Pn(e){var t=En(e);return t.x*=Ls,t.y*=Ls,t}function In(e,t){var r=En(t),n=r.x,i=r.y,o=e.display,l=o.scroller,s=l.scrollWidth>l.clientWidth,a=l.scrollHeight>l.clientHeight;if(n&&s||i&&a){if(i&&Ml&&ml)e:for(var u=t.target,c=o.view;u!=l;u=u.parentNode)for(var f=0;f<c.length;f++)if(c[f].node==u){e.display.currentWheelTarget=u;break e}if(n&&!fl&&!wl&&null!=Ls)return i&&a&&qr(e,Math.max(0,l.scrollTop+i*Ls)),Qr(e,Math.max(0,l.scrollLeft+n*Ls)),(!i||i&&a)&&We(t),void(o.wheelStartX=null);if(i&&null!=Ls){var h=i*Ls,d=e.doc.scrollTop,p=d+o.wrapper.clientHeight;h<0?d=Math.max(0,d+h-50):p=Math.min(e.doc.height,p+h+50),On(e,{top:d,bottom:p})}Ss<20&&(null==o.wheelStartX?(o.wheelStartX=l.scrollLeft,o.wheelStartY=l.scrollTop,o.wheelDX=n,o.wheelDY=i,setTimeout(function(){if(null!=o.wheelStartX){var e=l.scrollLeft-o.wheelStartX,t=l.scrollTop-o.wheelStartY,r=t&&o.wheelDY&&t/o.wheelDY||e&&o.wheelDX&&e/o.wheelDX;o.wheelStartX=o.wheelStartY=null,r&&(Ls=(Ls*Ss+r)/(Ss+1),++Ss)}},200)):(o.wheelDX+=n,o.wheelDY+=i))}}function zn(e,t){var r=e[t];e.sort(function(e,t){return P(e.from(),t.from())}),t=h(e,r);for(var n=1;n<e.length;n++){var i=e[n],o=e[n-1];if(P(o.to(),i.from())>=0){var l=B(o.from(),i.from()),s=R(o.to(),i.to()),a=o.empty()?i.from()==i.head:o.from()==o.head;n<=t&&--t,e.splice(--n,2,new Ts(a?s:l,a?l:s))}}return new ks(e,t)}function Rn(e,t){return new ks([new Ts(e,t||e)],0)}function Bn(e){return e.text?E(e.from.line+e.text.length-1,g(e.text).length+(1==e.text.length?e.from.ch:0)):e.to}function Gn(e,t){if(P(e,t.from)<0)return e;if(P(e,t.to)<=0)return Bn(t);var r=e.line+t.text.length-(t.to.line-t.from.line)-1,n=e.ch;return e.line==t.to.line&&(n+=Bn(t).ch-t.to.ch),E(r,n)}function Un(e,t){for(var r=[],n=0;n<e.sel.ranges.length;n++){var i=e.sel.ranges[n];r.push(new Ts(Gn(i.anchor,t),Gn(i.head,t)))}return zn(r,e.sel.primIndex)}function Vn(e,t,r){return e.line==t.line?E(r.line,e.ch-t.ch+r.ch):E(r.line+(e.line-t.line),e.ch)}function Kn(e,t,r){for(var n=[],i=E(e.first,0),o=i,l=0;l<t.length;l++){var s=t[l],a=Vn(s.from,i,o),u=Vn(Bn(s),i,o);if(i=s.to,o=u,"around"==r){var c=e.sel.ranges[l],f=P(c.head,c.anchor)<0;n[l]=new Ts(f?u:a,f?a:u)}else n[l]=new Ts(a,a)}return new ks(n,e.sel.primIndex)}function jn(e){e.doc.mode=Ue(e.options,e.doc.modeOption),Xn(e)}function Xn(e){e.doc.iter(function(e){e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null)}),e.doc.modeFrontier=e.doc.highlightFrontier=e.doc.first,Cn(e,100),e.state.modeGen++,e.curOp&&vn(e)}function Yn(e,t){return 0==t.from.ch&&0==t.to.ch&&""==g(t.text)&&(!e.cm||e.cm.options.wholeLineUpdateBefore)}function _n(e,t,r,n){function i(e){return r?r[e]:null}function o(e,r,i){it(e,r,i,n),bt(e,"change",e,t)}function l(e,t){for(var r=[],o=e;o<t;++o)r.push(new fs(u[o],i(o),n));return r}var s=t.from,a=t.to,u=t.text,c=M(e,s.line),f=M(e,a.line),h=g(u),d=i(u.length-1),p=a.line-s.line;if(t.full)e.insert(0,l(0,u.length)),e.remove(u.length,e.size-u.length);else if(Yn(e,t)){var v=l(0,u.length-1);o(f,f.text,d),p&&e.remove(s.line,p),v.length&&e.insert(s.line,v)}else if(c==f)if(1==u.length)o(c,c.text.slice(0,s.ch)+h+c.text.slice(a.ch),d);else{var m=l(1,u.length-1);m.push(new fs(h+c.text.slice(a.ch),d,n)),o(c,c.text.slice(0,s.ch)+u[0],i(0)),e.insert(s.line+1,m)}else if(1==u.length)o(c,c.text.slice(0,s.ch)+u[0]+f.text.slice(a.ch),i(0)),e.remove(s.line+1,p);else{o(c,c.text.slice(0,s.ch)+u[0],i(0)),o(f,h+f.text.slice(a.ch),d);var y=l(1,u.length-1);p>1&&e.remove(s.line+1,p-1),e.insert(s.line+1,y)}bt(e,"change",e,t)}function $n(e,t,r){function n(e,i,o){if(e.linked)for(var l=0;l<e.linked.length;++l){var s=e.linked[l];if(s.doc!=i){var a=o&&s.sharedHist;r&&!a||(t(s.doc,a),n(s.doc,e,a))}}}n(e,null,!0)}function qn(e,t){if(t.cm)throw new Error("This document is already in use.");e.doc=t,t.cm=e,Cr(e),jn(e),Zn(e),e.options.lineWrapping||we(e),e.options.mode=t.modeOption,vn(e)}function Zn(e){("rtl"==e.doc.direction?s:Fl)(e.display.lineDiv,"CodeMirror-rtl")}function Qn(e){hn(e,function(){Zn(e),vn(e)})}function Jn(e){this.done=[],this.undone=[],this.undoDepth=1/0,this.lastModTime=this.lastSelTime=0,this.lastOp=this.lastSelOp=null,this.lastOrigin=this.lastSelOrigin=null,this.generation=this.maxGeneration=e||1}function ei(e,t){var r={from:z(t.from),to:Bn(t),text:N(e,t.from,t.to)};return si(e,r,t.from.line,t.to.line+1),$n(e,function(e){return si(e,r,t.from.line,t.to.line+1)},!0),r}function ti(e){for(;e.length&&g(e).ranges;)e.pop()}function ri(e,t){return t?(ti(e.done),g(e.done)):e.done.length&&!g(e.done).ranges?g(e.done):e.done.length>1&&!e.done[e.done.length-2].ranges?(e.done.pop(),g(e.done)):void 0}function ni(e,t,r,n){var i=e.history;i.undone.length=0;var o,l,s=+new Date;if((i.lastOp==n||i.lastOrigin==t.origin&&t.origin&&("+"==t.origin.charAt(0)&&e.cm&&i.lastModTime>s-e.cm.options.historyEventDelay||"*"==t.origin.charAt(0)))&&(o=ri(i,i.lastOp==n)))l=g(o.changes),0==P(t.from,t.to)&&0==P(t.from,l.to)?l.to=Bn(t):o.changes.push(ei(e,t));else{var a=g(i.done);for(a&&a.ranges||li(e.sel,i.done),o={changes:[ei(e,t)],generation:i.generation},i.done.push(o);i.done.length>i.undoDepth;)i.done.shift(),i.done[0].ranges||i.done.shift()}i.done.push(r),i.generation=++i.maxGeneration,i.lastModTime=i.lastSelTime=s,i.lastOp=i.lastSelOp=n,i.lastOrigin=i.lastSelOrigin=t.origin,l||Te(e,"historyAdded")}function ii(e,t,r,n){var i=t.charAt(0);return"*"==i||"+"==i&&r.ranges.length==n.ranges.length&&r.somethingSelected()==n.somethingSelected()&&new Date-e.history.lastSelTime<=(e.cm?e.cm.options.historyEventDelay:500)}function oi(e,t,r,n){var i=e.history,o=n&&n.origin;r==i.lastSelOp||o&&i.lastSelOrigin==o&&(i.lastModTime==i.lastSelTime&&i.lastOrigin==o||ii(e,o,g(i.done),t))?i.done[i.done.length-1]=t:li(t,i.done),i.lastSelTime=+new Date,i.lastSelOrigin=o,i.lastSelOp=r,n&&!1!==n.clearRedo&&ti(i.undone)}function li(e,t){var r=g(t);r&&r.ranges&&r.equals(e)||t.push(e)}function si(e,t,r,n){var i=t["spans_"+e.id],o=0;e.iter(Math.max(e.first,r),Math.min(e.first+e.size,n),function(r){r.markedSpans&&((i||(i=t["spans_"+e.id]={}))[o]=r.markedSpans),++o})}function ai(e){if(!e)return null;for(var t,r=0;r<e.length;++r)e[r].marker.explicitlyCleared?t||(t=e.slice(0,r)):t&&t.push(e[r]);return t?t.length?t:null:e}function ui(e,t){var r=t["spans_"+e.id];if(!r)return null;for(var n=[],i=0;i<t.text.length;++i)n.push(ai(r[i]));return n}function ci(e,t){var r=ui(e,t),n=J(e,t);if(!r)return n;if(!n)return r;for(var i=0;i<r.length;++i){var o=r[i],l=n[i];if(o&&l)e:for(var s=0;s<l.length;++s){for(var a=l[s],u=0;u<o.length;++u)if(o[u].marker==a.marker)continue e;o.push(a)}else l&&(r[i]=l)}return r}function fi(e,t,r){for(var n=[],i=0;i<e.length;++i){var o=e[i];if(o.ranges)n.push(r?ks.prototype.deepCopy.call(o):o);else{var l=o.changes,s=[];n.push({changes:s});for(var a=0;a<l.length;++a){var u=l[a],c=void 0;if(s.push({from:u.from,to:u.to,text:u.text}),t)for(var f in u)(c=f.match(/^spans_(\d+)$/))&&h(t,Number(c[1]))>-1&&(g(s)[f]=u[f],delete u[f])}}}return n}function hi(e,t,r,n){if(n){var i=e.anchor;if(r){var o=P(t,i)<0;o!=P(r,i)<0?(i=t,t=r):o!=P(t,r)<0&&(t=r)}return new Ts(i,t)}return new Ts(r||t,t)}function di(e,t,r,n,i){null==i&&(i=e.cm&&(e.cm.display.shift||e.extend)),bi(e,new ks([hi(e.sel.primary(),t,r,i)],0),n)}function pi(e,t,r){for(var n=[],i=e.cm&&(e.cm.display.shift||e.extend),o=0;o<e.sel.ranges.length;o++)n[o]=hi(e.sel.ranges[o],t[o],null,i);bi(e,zn(n,e.sel.primIndex),r)}function gi(e,t,r,n){var i=e.sel.ranges.slice(0);i[t]=r,bi(e,zn(i,e.sel.primIndex),n)}function vi(e,t,r,n){bi(e,Rn(t,r),n)}function mi(e,t,r){var n={ranges:t.ranges,update:function(t){var r=this;this.ranges=[];for(var n=0;n<t.length;n++)r.ranges[n]=new Ts(U(e,t[n].anchor),U(e,t[n].head))},origin:r&&r.origin};return Te(e,"beforeSelectionChange",e,n),e.cm&&Te(e.cm,"beforeSelectionChange",e.cm,n),n.ranges!=t.ranges?zn(n.ranges,n.ranges.length-1):t}function yi(e,t,r){var n=e.history.done,i=g(n);i&&i.ranges?(n[n.length-1]=t,wi(e,t,r)):bi(e,t,r)}function bi(e,t,r){wi(e,t,r),oi(e,e.sel,e.cm?e.cm.curOp.id:NaN,r)}function wi(e,t,r){(Oe(e,"beforeSelectionChange")||e.cm&&Oe(e.cm,"beforeSelectionChange"))&&(t=mi(e,t,r)),xi(e,Si(e,t,r&&r.bias||(P(t.primary().head,e.sel.primary().head)<0?-1:1),!0)),r&&!1===r.scroll||!e.cm||jr(e.cm)}function xi(e,t){t.equals(e.sel)||(e.sel=t,e.cm&&(e.cm.curOp.updateInput=e.cm.curOp.selectionChanged=!0,Ne(e.cm)),bt(e,"cursorActivity",e))}function Ci(e){xi(e,Si(e,e.sel,null,!1))}function Si(e,t,r,n){for(var i,o=0;o<t.ranges.length;o++){var l=t.ranges[o],s=t.ranges.length==e.sel.ranges.length&&e.sel.ranges[o],a=ki(e,l.anchor,s&&s.anchor,r,n),u=ki(e,l.head,s&&s.head,r,n);(i||a!=l.anchor||u!=l.head)&&(i||(i=t.ranges.slice(0,o)),i[o]=new Ts(a,u))}return i?zn(i,t.primIndex):t}function Li(e,t,r,n,i){var o=M(e,t.line);if(o.markedSpans)for(var l=0;l<o.markedSpans.length;++l){var s=o.markedSpans[l],a=s.marker;if((null==s.from||(a.inclusiveLeft?s.from<=t.ch:s.from<t.ch))&&(null==s.to||(a.inclusiveRight?s.to>=t.ch:s.to>t.ch))){if(i&&(Te(a,"beforeCursorEnter"),a.explicitlyCleared)){if(o.markedSpans){--l;continue}break}if(!a.atomic)continue;if(r){var u=a.find(n<0?1:-1),c=void 0;if((n<0?a.inclusiveRight:a.inclusiveLeft)&&(u=Ti(e,u,-n,u&&u.line==t.line?o:null)),u&&u.line==t.line&&(c=P(u,r))&&(n<0?c<0:c>0))return Li(e,u,t,n,i)}var f=a.find(n<0?-1:1);return(n<0?a.inclusiveLeft:a.inclusiveRight)&&(f=Ti(e,f,n,f.line==t.line?o:null)),f?Li(e,f,t,n,i):null}}return t}function ki(e,t,r,n,i){var o=n||1,l=Li(e,t,r,o,i)||!i&&Li(e,t,r,o,!0)||Li(e,t,r,-o,i)||!i&&Li(e,t,r,-o,!0);return l||(e.cantEdit=!0,E(e.first,0))}function Ti(e,t,r,n){return r<0&&0==t.ch?t.line>e.first?U(e,E(t.line-1)):null:r>0&&t.ch==(n||M(e,t.line)).text.length?t.line<e.first+e.size-1?E(t.line+1,0):null:new E(t.line,t.ch+r)}function Mi(e){e.setSelection(E(e.firstLine(),0),E(e.lastLine()),Gl)}function Ni(e,t,r){var n={canceled:!1,from:t.from,to:t.to,text:t.text,origin:t.origin,cancel:function(){return n.canceled=!0}};return r&&(n.update=function(t,r,i,o){t&&(n.from=U(e,t)),r&&(n.to=U(e,r)),i&&(n.text=i),void 0!==o&&(n.origin=o)}),Te(e,"beforeChange",e,n),e.cm&&Te(e.cm,"beforeChange",e.cm,n),n.canceled?null:{from:n.from,to:n.to,text:n.text,origin:n.origin}}function Oi(e,t,r){if(e.cm){if(!e.cm.curOp)return dn(e.cm,Oi)(e,t,r);if(e.cm.state.suppressEdits)return}if(!(Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"))||(t=Ni(e,t,!0))){var n=Yl&&!r&&te(e,t.from,t.to);if(n)for(var i=n.length-1;i>=0;--i)Ai(e,{from:n[i].from,to:n[i].to,text:i?[""]:t.text,origin:t.origin});else Ai(e,t)}}function Ai(e,t){if(1!=t.text.length||""!=t.text[0]||0!=P(t.from,t.to)){var r=Un(e,t);ni(e,t,r,e.cm?e.cm.curOp.id:NaN),Hi(e,t,r,J(e,t));var n=[];$n(e,function(e,r){r||-1!=h(n,e.history)||(zi(e.history,t),n.push(e.history)),Hi(e,t,null,J(e,t))})}}function Wi(e,t,r){if(!e.cm||!e.cm.state.suppressEdits||r){for(var n,i=e.history,o=e.sel,l="undo"==t?i.done:i.undone,s="undo"==t?i.undone:i.done,a=0;a<l.length&&(n=l[a],r?!n.ranges||n.equals(e.sel):n.ranges);a++);if(a!=l.length){for(i.lastOrigin=i.lastSelOrigin=null;(n=l.pop()).ranges;){if(li(n,s),r&&!n.equals(e.sel))return void bi(e,n,{clearRedo:!1});o=n}var u=[];li(o,s),s.push({changes:u,generation:i.generation}),i.generation=n.generation||++i.maxGeneration;for(var c=Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"),f=n.changes.length-1;f>=0;--f){var d=function(r){var i=n.changes[r];if(i.origin=t,c&&!Ni(e,i,!1))return l.length=0,{};u.push(ei(e,i));var o=r?Un(e,i):g(l);Hi(e,i,o,ci(e,i)),!r&&e.cm&&e.cm.scrollIntoView({from:i.from,to:Bn(i)});var s=[];$n(e,function(e,t){t||-1!=h(s,e.history)||(zi(e.history,i),s.push(e.history)),Hi(e,i,null,ci(e,i))})}(f);if(d)return d.v}}}}function Di(e,t){if(0!=t&&(e.first+=t,e.sel=new ks(v(e.sel.ranges,function(e){return new Ts(E(e.anchor.line+t,e.anchor.ch),E(e.head.line+t,e.head.ch))}),e.sel.primIndex),e.cm)){vn(e.cm,e.first,e.first-t,t);for(var r=e.cm.display,n=r.viewFrom;n<r.viewTo;n++)mn(e.cm,n,"gutter")}}function Hi(e,t,r,n){if(e.cm&&!e.cm.curOp)return dn(e.cm,Hi)(e,t,r,n);if(t.to.line<e.first)Di(e,t.text.length-1-(t.to.line-t.from.line));else if(!(t.from.line>e.lastLine())){if(t.from.line<e.first){var i=t.text.length-1-(e.first-t.from.line);Di(e,i),t={from:E(e.first,0),to:E(t.to.line+i,t.to.ch),text:[g(t.text)],origin:t.origin}}var o=e.lastLine();t.to.line>o&&(t={from:t.from,to:E(o,M(e,o).text.length),text:[t.text[0]],origin:t.origin}),t.removed=N(e,t.from,t.to),r||(r=Un(e,t)),e.cm?Fi(e.cm,t,n):_n(e,t,n),wi(e,r,Gl)}}function Fi(e,t,r){var n=e.doc,i=e.display,o=t.from,l=t.to,s=!1,a=o.line;e.options.lineWrapping||(a=W(fe(M(n,o.line))),n.iter(a,l.line+1,function(e){if(e==i.maxLine)return s=!0,!0})),n.sel.contains(t.from,t.to)>-1&&Ne(e),_n(n,t,r,xr(e)),e.options.lineWrapping||(n.iter(a,o.line+t.text.length,function(e){var t=be(e);t>i.maxLineLength&&(i.maxLine=e,i.maxLineLength=t,i.maxLineChanged=!0,s=!1)}),s&&(e.curOp.updateMaxLine=!0)),nt(n,o.line),Cn(e,400);var u=t.text.length-(l.line-o.line)-1;t.full?vn(e):o.line!=l.line||1!=t.text.length||Yn(e.doc,t)?vn(e,o.line,l.line+1,u):mn(e,o.line,"text");var c=Oe(e,"changes"),f=Oe(e,"change");if(f||c){var h={from:o,to:l,text:t.text,removed:t.removed,origin:t.origin};f&&bt(e,"change",e,h),c&&(e.curOp.changeObjs||(e.curOp.changeObjs=[])).push(h)}e.display.selForContextMenu=null}function Ei(e,t,r,n,i){if(n||(n=r),P(n,r)<0){var o;r=(o=[n,r])[0],n=o[1]}"string"==typeof t&&(t=e.splitLines(t)),Oi(e,{from:r,to:n,text:t,origin:i})}function Pi(e,t,r,n){r<e.line?e.line+=n:t<e.line&&(e.line=t,e.ch=0)}function Ii(e,t,r,n){for(var i=0;i<e.length;++i){var o=e[i],l=!0;if(o.ranges){o.copied||((o=e[i]=o.deepCopy()).copied=!0);for(var s=0;s<o.ranges.length;s++)Pi(o.ranges[s].anchor,t,r,n),Pi(o.ranges[s].head,t,r,n)}else{for(var a=0;a<o.changes.length;++a){var u=o.changes[a];if(r<u.from.line)u.from=E(u.from.line+n,u.from.ch),u.to=E(u.to.line+n,u.to.ch);else if(t<=u.to.line){l=!1;break}}l||(e.splice(0,i+1),i=0)}}}function zi(e,t){var r=t.from.line,n=t.to.line,i=t.text.length-(n-r)-1;Ii(e.done,r,n,i),Ii(e.undone,r,n,i)}function Ri(e,t,r,n){var i=t,o=t;return"number"==typeof t?o=M(e,G(e,t)):i=W(t),null==i?null:(n(o,i)&&e.cm&&mn(e.cm,i,r),o)}function Bi(e){var t=this;this.lines=e,this.parent=null;for(var r=0,n=0;n<e.length;++n)e[n].parent=t,r+=e[n].height;this.height=r}function Gi(e){var t=this;this.children=e;for(var r=0,n=0,i=0;i<e.length;++i){var o=e[i];r+=o.chunkSize(),n+=o.height,o.parent=t}this.size=r,this.height=n,this.parent=null}function Ui(e,t,r){ye(t)<(e.curOp&&e.curOp.scrollTop||e.doc.scrollTop)&&Kr(e,r)}function Vi(e,t,r,n){var i=new Ms(e,r,n),o=e.cm;return o&&i.noHScroll&&(o.display.alignWidgets=!0),Ri(e,t,"widget",function(t){var r=t.widgets||(t.widgets=[]);if(null==i.insertAt?r.push(i):r.splice(Math.min(r.length-1,Math.max(0,i.insertAt)),0,i),i.line=t,o&&!ve(e,t)){var n=ye(t)<e.scrollTop;A(t,t.height+Ht(i)),n&&Kr(o,i.height),o.curOp.forceUpdate=!0}return!0}),bt(o,"lineWidgetAdded",o,i,"number"==typeof t?t:W(t)),i}function Ki(e,t,r,n,o){if(n&&n.shared)return ji(e,t,r,n,o);if(e.cm&&!e.cm.curOp)return dn(e.cm,Ki)(e,t,r,n,o);var l=new Os(e,o),s=P(t,r);if(n&&c(n,l,!1),s>0||0==s&&!1!==l.clearWhenEmpty)return l;if(l.replacedWith&&(l.collapsed=!0,l.widgetNode=i("span",[l.replacedWith],"CodeMirror-widget"),n.handleMouseEvents||l.widgetNode.setAttribute("cm-ignore-events","true"),n.insertLeft&&(l.widgetNode.insertLeft=!0)),l.collapsed){if(ce(e,t.line,t,r,l)||t.line!=r.line&&ce(e,r.line,t,r,l))throw new Error("Inserting collapsed marker partially overlapping an existing one");X()}l.addToHistory&&ni(e,{from:t,to:r,origin:"markText"},e.sel,NaN);var a,u=t.line,f=e.cm;if(e.iter(u,r.line+1,function(e){f&&l.collapsed&&!f.options.lineWrapping&&fe(e)==f.display.maxLine&&(a=!0),l.collapsed&&u!=t.line&&A(e,0),q(e,new Y(l,u==t.line?t.ch:null,u==r.line?r.ch:null)),++u}),l.collapsed&&e.iter(t.line,r.line+1,function(t){ve(e,t)&&A(t,0)}),l.clearOnEnter&&Ql(l,"beforeCursorEnter",function(){return l.clear()}),l.readOnly&&(j(),(e.history.done.length||e.history.undone.length)&&e.clearHistory()),l.collapsed&&(l.id=++Ns,l.atomic=!0),f){if(a&&(f.curOp.updateMaxLine=!0),l.collapsed)vn(f,t.line,r.line+1);else if(l.className||l.title||l.startStyle||l.endStyle||l.css)for(var h=t.line;h<=r.line;h++)mn(f,h,"text");l.atomic&&Ci(f.doc),bt(f,"markerAdded",f,l)}return l}function ji(e,t,r,n,i){(n=c(n)).shared=!1;var o=[Ki(e,t,r,n,i)],l=o[0],s=n.widgetNode;return $n(e,function(e){s&&(n.widgetNode=s.cloneNode(!0)),o.push(Ki(e,U(e,t),U(e,r),n,i));for(var a=0;a<e.linked.length;++a)if(e.linked[a].isParent)return;l=g(o)}),new As(o,l)}function Xi(e){return e.findMarks(E(e.first,0),e.clipPos(E(e.lastLine())),function(e){return e.parent})}function Yi(e,t){for(var r=0;r<t.length;r++){var n=t[r],i=n.find(),o=e.clipPos(i.from),l=e.clipPos(i.to);if(P(o,l)){var s=Ki(e,o,l,n.primary,n.primary.type);n.markers.push(s),s.parent=n}}}function _i(e){for(var t=0;t<e.length;t++)!function(t){var r=e[t],n=[r.primary.doc];$n(r.primary.doc,function(e){return n.push(e)});for(var i=0;i<r.markers.length;i++){var o=r.markers[i];-1==h(n,o.doc)&&(o.parent=null,r.markers.splice(i--,1))}}(t)}function $i(e){var t=this;if(Qi(t),!Me(t,e)&&!Ft(t.display,e)){We(e),gl&&(Hs=+new Date);var r=Sr(t,e,!0),n=e.dataTransfer.files;if(r&&!t.isReadOnly())if(n&&n.length&&window.FileReader&&window.File)for(var i=n.length,o=Array(i),l=0,s=0;s<i;++s)!function(e,n){if(!t.options.allowDropFileTypes||-1!=h(t.options.allowDropFileTypes,e.type)){var s=new FileReader;s.onload=dn(t,function(){var e=s.result;if(/[\x00-\x08\x0e-\x1f]{2}/.test(e)&&(e=""),o[n]=e,++l==i){var a={from:r=U(t.doc,r),to:r,text:t.doc.splitLines(o.join(t.doc.lineSeparator())),origin:"paste"};Oi(t.doc,a),yi(t.doc,Rn(r,Bn(a)))}}),s.readAsText(e)}}(n[s],s);else{if(t.state.draggingText&&t.doc.sel.contains(r)>-1)return t.state.draggingText(e),void setTimeout(function(){return t.display.input.focus()},20);try{var a=e.dataTransfer.getData("Text");if(a){var u;if(t.state.draggingText&&!t.state.draggingText.copy&&(u=t.listSelections()),wi(t.doc,Rn(r,r)),u)for(var c=0;c<u.length;++c)Ei(t.doc,"",u[c].anchor,u[c].head,"drag");t.replaceSelection(a,"around","paste"),t.display.input.focus()}}catch(e){}}}}function qi(e,t){if(gl&&(!e.state.draggingText||+new Date-Hs<100))Fe(t);else if(!Me(e,t)&&!Ft(e.display,t)&&(t.dataTransfer.setData("Text",e.getSelection()),t.dataTransfer.effectAllowed="copyMove",t.dataTransfer.setDragImage&&!xl)){var r=n("img",null,null,"position: fixed; left: 0; top: 0;");r.src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",wl&&(r.width=r.height=1,e.display.wrapper.appendChild(r),r._top=r.offsetTop),t.dataTransfer.setDragImage(r,0,0),wl&&r.parentNode.removeChild(r)}}function Zi(e,t){var i=Sr(e,t);if(i){var o=document.createDocumentFragment();Mr(e,i,o),e.display.dragCursor||(e.display.dragCursor=n("div",null,"CodeMirror-cursors CodeMirror-dragcursors"),e.display.lineSpace.insertBefore(e.display.dragCursor,e.display.cursorDiv)),r(e.display.dragCursor,o)}}function Qi(e){e.display.dragCursor&&(e.display.lineSpace.removeChild(e.display.dragCursor),e.display.dragCursor=null)}function Ji(e){if(document.getElementsByClassName)for(var t=document.getElementsByClassName("CodeMirror"),r=0;r<t.length;r++){var n=t[r].CodeMirror;n&&e(n)}}function eo(){Fs||(to(),Fs=!0)}function to(){var e;Ql(window,"resize",function(){null==e&&(e=setTimeout(function(){e=null,Ji(ro)},100))}),Ql(window,"blur",function(){return Ji(Fr)})}function ro(e){var t=e.display;t.lastWrapHeight==t.wrapper.clientHeight&&t.lastWrapWidth==t.wrapper.clientWidth||(t.cachedCharWidth=t.cachedTextHeight=t.cachedPaddingH=null,t.scrollbarsClipped=!1,e.setSize())}function no(e){var t=e.split(/-(?!$)/);e=t[t.length-1];for(var r,n,i,o,l=0;l<t.length-1;l++){var s=t[l];if(/^(cmd|meta|m)$/i.test(s))o=!0;else if(/^a(lt)?$/i.test(s))r=!0;else if(/^(c|ctrl|control)$/i.test(s))n=!0;else{if(!/^s(hift)?$/i.test(s))throw new Error("Unrecognized modifier name: "+s);i=!0}}return r&&(e="Alt-"+e),n&&(e="Ctrl-"+e),o&&(e="Cmd-"+e),i&&(e="Shift-"+e),e}function io(e){var t={};for(var r in e)if(e.hasOwnProperty(r)){var n=e[r];if(/^(name|fallthrough|(de|at)tach)$/.test(r))continue;if("..."==n){delete e[r];continue}for(var i=v(r.split(" "),no),o=0;o<i.length;o++){var l=void 0,s=void 0;o==i.length-1?(s=i.join(" "),l=n):(s=i.slice(0,o+1).join(" "),l="...");var a=t[s];if(a){if(a!=l)throw new Error("Inconsistent bindings for "+s)}else t[s]=l}delete e[r]}for(var u in t)e[u]=t[u];return e}function oo(e,t,r,n){var i=(t=uo(t)).call?t.call(e,n):t[e];if(!1===i)return"nothing";if("..."===i)return"multi";if(null!=i&&r(i))return"handled";if(t.fallthrough){if("[object Array]"!=Object.prototype.toString.call(t.fallthrough))return oo(e,t.fallthrough,r,n);for(var o=0;o<t.fallthrough.length;o++){var l=oo(e,t.fallthrough[o],r,n);if(l)return l}}}function lo(e){var t="string"==typeof e?e:Es[e.keyCode];return"Ctrl"==t||"Alt"==t||"Shift"==t||"Mod"==t}function so(e,t,r){var n=e;return t.altKey&&"Alt"!=n&&(e="Alt-"+e),(Dl?t.metaKey:t.ctrlKey)&&"Ctrl"!=n&&(e="Ctrl-"+e),(Dl?t.ctrlKey:t.metaKey)&&"Cmd"!=n&&(e="Cmd-"+e),!r&&t.shiftKey&&"Shift"!=n&&(e="Shift-"+e),e}function ao(e,t){if(wl&&34==e.keyCode&&e.char)return!1;var r=Es[e.keyCode];return null!=r&&!e.altGraphKey&&so(r,e,t)}function uo(e){return"string"==typeof e?Rs[e]:e}function co(e,t){for(var r=e.doc.sel.ranges,n=[],i=0;i<r.length;i++){for(var o=t(r[i]);n.length&&P(o.from,g(n).to)<=0;){var l=n.pop();if(P(l.from,o.from)<0){o.from=l.from;break}}n.push(o)}hn(e,function(){for(var t=n.length-1;t>=0;t--)Ei(e.doc,"",n[t].from,n[t].to,"+delete");jr(e)})}function fo(e,t,r){var n=L(e.text,t+r,r);return n<0||n>e.text.length?null:n}function ho(e,t,r){var n=fo(e,t.ch,r);return null==n?null:new E(t.line,n,r<0?"after":"before")}function po(e,t,r,n,i){if(e){var o=Se(r,t.doc.direction);if(o){var l,s=i<0?g(o):o[0],a=i<0==(1==s.level)?"after":"before";if(s.level>0){var u=Xt(t,r);l=i<0?r.text.length-1:0;var c=Yt(t,u,l).top;l=k(function(e){return Yt(t,u,e).top==c},i<0==(1==s.level)?s.from:s.to-1,l),"before"==a&&(l=fo(r,l,1))}else l=i<0?s.to:s.from;return new E(n,l,a)}}return new E(n,i<0?r.text.length:0,i<0?"before":"after")}function go(e,t,r,n){var i=Se(t,e.doc.direction);if(!i)return ho(t,r,n);r.ch>=t.text.length?(r.ch=t.text.length,r.sticky="before"):r.ch<=0&&(r.ch=0,r.sticky="after");var o=Ce(i,r.ch,r.sticky),l=i[o];if("ltr"==e.doc.direction&&l.level%2==0&&(n>0?l.to>r.ch:l.from<r.ch))return ho(t,r,n);var s,a=function(e,r){return fo(t,e instanceof E?e.ch:e,r)},u=function(r){return e.options.lineWrapping?(s=s||Xt(e,t),hr(e,t,s,r)):{begin:0,end:t.text.length}},c=u("before"==r.sticky?a(r,-1):r.ch);if("rtl"==e.doc.direction||1==l.level){var f=1==l.level==n<0,h=a(r,f?1:-1);if(null!=h&&(f?h<=l.to&&h<=c.end:h>=l.from&&h>=c.begin)){var d=f?"before":"after";return new E(r.line,h,d)}}var p=function(e,t,n){for(var o=function(e,t){return t?new E(r.line,a(e,1),"before"):new E(r.line,e,"after")};e>=0&&e<i.length;e+=t){var l=i[e],s=t>0==(1!=l.level),u=s?n.begin:a(n.end,-1);if(l.from<=u&&u<l.to)return o(u,s);if(u=s?l.from:a(l.to,-1),n.begin<=u&&u<n.end)return o(u,s)}},g=p(o+n,n,c);if(g)return g;var v=n>0?c.end:a(c.begin,-1);return null==v||n>0&&v==t.text.length||!(g=p(n>0?0:i.length-1,n,u(v)))?null:g}function vo(e,t){var r=M(e.doc,t),n=fe(r);return n!=r&&(t=W(n)),po(!0,e,n,t,1)}function mo(e,t){var r=M(e.doc,t),n=he(r);return n!=r&&(t=W(n)),po(!0,e,r,t,-1)}function yo(e,t){var r=vo(e,t.line),n=M(e.doc,r.line),i=Se(n,e.doc.direction);if(!i||0==i[0].level){var o=Math.max(0,n.text.search(/\S/)),l=t.line==r.line&&t.ch<=o&&t.ch;return E(r.line,l?0:o,r.sticky)}return r}function bo(e,t,r){if("string"==typeof t&&!(t=Bs[t]))return!1;e.display.input.ensurePolled();var n=e.display.shift,i=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),r&&(e.display.shift=!1),i=t(e)!=Bl}finally{e.display.shift=n,e.state.suppressEdits=!1}return i}function wo(e,t,r){for(var n=0;n<e.state.keyMaps.length;n++){var i=oo(t,e.state.keyMaps[n],r,e);if(i)return i}return e.options.extraKeys&&oo(t,e.options.extraKeys,r,e)||oo(t,e.options.keyMap,r,e)}function xo(e,t,r,n){var i=e.state.keySeq;if(i){if(lo(t))return"handled";Gs.set(50,function(){e.state.keySeq==i&&(e.state.keySeq=null,e.display.input.reset())}),t=i+" "+t}var o=wo(e,t,n);return"multi"==o&&(e.state.keySeq=t),"handled"==o&&bt(e,"keyHandled",e,t,r),"handled"!=o&&"multi"!=o||(We(r),Ar(e)),i&&!o&&/\'$/.test(t)?(We(r),!0):!!o}function Co(e,t){var r=ao(t,!0);return!!r&&(t.shiftKey&&!e.state.keySeq?xo(e,"Shift-"+r,t,function(t){return bo(e,t,!0)})||xo(e,r,t,function(t){if("string"==typeof t?/^go[A-Z]/.test(t):t.motion)return bo(e,t)}):xo(e,r,t,function(t){return bo(e,t)}))}function So(e,t,r){return xo(e,"'"+r+"'",t,function(t){return bo(e,t,!0)})}function Lo(e){var t=this;if(t.curOp.focus=l(),!Me(t,e)){gl&&vl<11&&27==e.keyCode&&(e.returnValue=!1);var r=e.keyCode;t.display.shift=16==r||e.shiftKey;var n=Co(t,e);wl&&(Us=n?r:null,!n&&88==r&&!rs&&(Ml?e.metaKey:e.ctrlKey)&&t.replaceSelection("",null,"cut")),18!=r||/\bCodeMirror-crosshair\b/.test(t.display.lineDiv.className)||ko(t)}}function ko(e){function t(e){18!=e.keyCode&&e.altKey||(Fl(r,"CodeMirror-crosshair"),ke(document,"keyup",t),ke(document,"mouseover",t))}var r=e.display.lineDiv;s(r,"CodeMirror-crosshair"),Ql(document,"keyup",t),Ql(document,"mouseover",t)}function To(e){16==e.keyCode&&(this.doc.sel.shift=!1),Me(this,e)}function Mo(e){var t=this;if(!(Ft(t.display,e)||Me(t,e)||e.ctrlKey&&!e.altKey||Ml&&e.metaKey)){var r=e.keyCode,n=e.charCode;if(wl&&r==Us)return Us=null,void We(e);if(!wl||e.which&&!(e.which<10)||!Co(t,e)){var i=String.fromCharCode(null==n?r:n);"\b"!=i&&(So(t,e,i)||t.display.input.onKeyPress(e))}}}function No(e,t){var r=+new Date;return js&&js.compare(r,e,t)?(Ks=js=null,"triple"):Ks&&Ks.compare(r,e,t)?(js=new Vs(r,e,t),Ks=null,"double"):(Ks=new Vs(r,e,t),js=null,"single")}function Oo(e){var t=this,r=t.display;if(!(Me(t,e)||r.activeTouch&&r.input.supportsTouch()))if(r.input.ensurePolled(),r.shift=e.shiftKey,Ft(r,e))ml||(r.scroller.draggable=!1,setTimeout(function(){return r.scroller.draggable=!0},100));else if(!zo(t,e)){var n=Sr(t,e),i=Pe(e),o=n?No(n,i):"single";window.focus(),1==i&&t.state.selectingText&&t.state.selectingText(e),n&&Ao(t,i,n,o,e)||(1==i?n?Do(t,n,o,e):Ee(e)==r.scroller&&We(e):2==i?(n&&di(t.doc,n),setTimeout(function(){return r.input.focus()},20)):3==i&&(Hl?Ro(t,e):Dr(t)))}}function Ao(e,t,r,n,i){var o="Click";return"double"==n?o="Double"+o:"triple"==n&&(o="Triple"+o),o=(1==t?"Left":2==t?"Middle":"Right")+o,xo(e,so(o,i),i,function(t){if("string"==typeof t&&(t=Bs[t]),!t)return!1;var n=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),n=t(e,r)!=Bl}finally{e.state.suppressEdits=!1}return n})}function Wo(e,t,r){var n=e.getOption("configureMouse"),i=n?n(e,t,r):{};if(null==i.unit){var o=Nl?r.shiftKey&&r.metaKey:r.altKey;i.unit=o?"rectangle":"single"==t?"char":"double"==t?"word":"line"}return(null==i.extend||e.doc.extend)&&(i.extend=e.doc.extend||r.shiftKey),null==i.addNew&&(i.addNew=Ml?r.metaKey:r.ctrlKey),null==i.moveOnDrag&&(i.moveOnDrag=!(Ml?r.altKey:r.ctrlKey)),i}function Do(e,t,r,n){gl?setTimeout(u(Wr,e),0):e.curOp.focus=l();var i,o=Wo(e,r,n),s=e.doc.sel;e.options.dragDrop&&Jl&&!e.isReadOnly()&&"single"==r&&(i=s.contains(t))>-1&&(P((i=s.ranges[i]).from(),t)<0||t.xRel>0)&&(P(i.to(),t)>0||t.xRel<0)?Ho(e,n,t,o):Eo(e,n,t,o)}function Ho(e,t,r,n){var i=e.display,o=!1,l=dn(e,function(t){ml&&(i.scroller.draggable=!1),e.state.draggingText=!1,ke(document,"mouseup",l),ke(document,"mousemove",s),ke(i.scroller,"dragstart",a),ke(i.scroller,"drop",l),o||(We(t),n.addNew||di(e.doc,r,null,null,n.extend),ml||gl&&9==vl?setTimeout(function(){document.body.focus(),i.input.focus()},20):i.input.focus())}),s=function(e){o=o||Math.abs(t.clientX-e.clientX)+Math.abs(t.clientY-e.clientY)>=10},a=function(){return o=!0};ml&&(i.scroller.draggable=!0),e.state.draggingText=l,l.copy=!n.moveOnDrag,i.scroller.dragDrop&&i.scroller.dragDrop(),Ql(document,"mouseup",l),Ql(document,"mousemove",s),Ql(i.scroller,"dragstart",a),Ql(i.scroller,"drop",l),Dr(e),setTimeout(function(){return i.input.focus()},20)}function Fo(e,t,r){if("char"==r)return new Ts(t,t);if("word"==r)return e.findWordAt(t);if("line"==r)return new Ts(E(t.line,0),U(e.doc,E(t.line+1,0)));var n=r(e,t);return new Ts(n.from,n.to)}function Eo(e,t,r,n){function i(t){if(0!=P(m,t))if(m=t,"rectangle"==n.unit){for(var i=[],o=e.options.tabSize,l=f(M(u,r.line).text,r.ch,o),s=f(M(u,t.line).text,t.ch,o),a=Math.min(l,s),g=Math.max(l,s),v=Math.min(r.line,t.line),y=Math.min(e.lastLine(),Math.max(r.line,t.line));v<=y;v++){var b=M(u,v).text,w=d(b,a,o);a==g?i.push(new Ts(E(v,w),E(v,w))):b.length>w&&i.push(new Ts(E(v,w),E(v,d(b,g,o))))}i.length||i.push(new Ts(r,r)),bi(u,zn(p.ranges.slice(0,h).concat(i),h),{origin:"*mouse",scroll:!1}),e.scrollIntoView(t)}else{var x,C=c,S=Fo(e,t,n.unit),L=C.anchor;P(S.anchor,L)>0?(x=S.head,L=B(C.from(),S.anchor)):(x=S.anchor,L=R(C.to(),S.head));var k=p.ranges.slice(0);k[h]=Po(e,new Ts(U(u,L),x)),bi(u,zn(k,h),Ul)}}function o(t){var r=++b,s=Sr(e,t,!0,"rectangle"==n.unit);if(s)if(0!=P(s,m)){e.curOp.focus=l(),i(s);var c=Ir(a,u);(s.line>=c.to||s.line<c.from)&&setTimeout(dn(e,function(){b==r&&o(t)}),150)}else{var f=t.clientY<y.top?-20:t.clientY>y.bottom?20:0;f&&setTimeout(dn(e,function(){b==r&&(a.scroller.scrollTop+=f,o(t))}),50)}}function s(t){e.state.selectingText=!1,b=1/0,We(t),a.input.focus(),ke(document,"mousemove",w),ke(document,"mouseup",x),u.history.lastSelOrigin=null}var a=e.display,u=e.doc;We(t);var c,h,p=u.sel,g=p.ranges;if(n.addNew&&!n.extend?(h=u.sel.contains(r),c=h>-1?g[h]:new Ts(r,r)):(c=u.sel.primary(),h=u.sel.primIndex),"rectangle"==n.unit)n.addNew||(c=new Ts(r,r)),r=Sr(e,t,!0,!0),h=-1;else{var v=Fo(e,r,n.unit);c=n.extend?hi(c,v.anchor,v.head,n.extend):v}n.addNew?-1==h?(h=g.length,bi(u,zn(g.concat([c]),h),{scroll:!1,origin:"*mouse"})):g.length>1&&g[h].empty()&&"char"==n.unit&&!n.extend?(bi(u,zn(g.slice(0,h).concat(g.slice(h+1)),0),{scroll:!1,origin:"*mouse"}),p=u.sel):gi(u,h,c,Ul):(h=0,bi(u,new ks([c],0),Ul),p=u.sel);var m=r,y=a.wrapper.getBoundingClientRect(),b=0,w=dn(e,function(e){Pe(e)?o(e):s(e)}),x=dn(e,s);e.state.selectingText=x,Ql(document,"mousemove",w),Ql(document,"mouseup",x)}function Po(e,t){var r=t.anchor,n=t.head,i=M(e.doc,r.line);if(0==P(r,n)&&r.sticky==n.sticky)return t;var o=Se(i);if(!o)return t;var l=Ce(o,r.ch,r.sticky),s=o[l];if(s.from!=r.ch&&s.to!=r.ch)return t;var a=l+(s.from==r.ch==(1!=s.level)?0:1);if(0==a||a==o.length)return t;var u;if(n.line!=r.line)u=(n.line-r.line)*("ltr"==e.doc.direction?1:-1)>0;else{var c=Ce(o,n.ch,n.sticky),f=c-l||(n.ch-r.ch)*(1==s.level?-1:1);u=c==a-1||c==a?f<0:f>0}var h=o[a+(u?-1:0)],d=u==(1==h.level),p=d?h.from:h.to,g=d?"after":"before";return r.ch==p&&r.sticky==g?t:new Ts(new E(r.line,p,g),n)}function Io(e,t,r,n){var i,o;if(t.touches)i=t.touches[0].clientX,o=t.touches[0].clientY;else try{i=t.clientX,o=t.clientY}catch(t){return!1}if(i>=Math.floor(e.display.gutters.getBoundingClientRect().right))return!1;n&&We(t);var l=e.display,s=l.lineDiv.getBoundingClientRect();if(o>s.bottom||!Oe(e,r))return He(t);o-=s.top-l.viewOffset;for(var a=0;a<e.options.gutters.length;++a){var u=l.gutters.childNodes[a];if(u&&u.getBoundingClientRect().right>=i)return Te(e,r,e,D(e.doc,o),e.options.gutters[a],t),He(t)}}function zo(e,t){return Io(e,t,"gutterClick",!0)}function Ro(e,t){Ft(e.display,t)||Bo(e,t)||Me(e,t,"contextmenu")||e.display.input.onContextMenu(t)}function Bo(e,t){return!!Oe(e,"gutterContextMenu")&&Io(e,t,"gutterContextMenu",!1)}function Go(e){e.display.wrapper.className=e.display.wrapper.className.replace(/\s*cm-s-\S+/g,"")+e.options.theme.replace(/(^|\s)\s*/g," cm-s-"),er(e)}function Uo(e){Hn(e),vn(e),zr(e)}function Vo(e,t,r){if(!t!=!(r&&r!=Xs)){var n=e.display.dragFunctions,i=t?Ql:ke;i(e.display.scroller,"dragstart",n.start),i(e.display.scroller,"dragenter",n.enter),i(e.display.scroller,"dragover",n.over),i(e.display.scroller,"dragleave",n.leave),i(e.display.scroller,"drop",n.drop)}}function Ko(e){e.options.lineWrapping?(s(e.display.wrapper,"CodeMirror-wrap"),e.display.sizer.style.minWidth="",e.display.sizerWidth=null):(Fl(e.display.wrapper,"CodeMirror-wrap"),we(e)),Cr(e),vn(e),er(e),setTimeout(function(){return en(e)},100)}function jo(e,t){var r=this;if(!(this instanceof jo))return new jo(e,t);this.options=t=t?c(t):{},c(Ys,t,!1),Fn(t);var n=t.value;"string"==typeof n&&(n=new Ds(n,t.mode,null,t.lineSeparator,t.direction)),this.doc=n;var i=new jo.inputStyles[t.inputStyle](this),o=this.display=new T(e,n,i);o.wrapper.CodeMirror=this,Hn(this),Go(this),t.lineWrapping&&(this.display.wrapper.className+=" CodeMirror-wrap"),rn(this),this.state={keyMaps:[],overlays:[],modeGen:0,overwrite:!1,delayingBlurEvent:!1,focused:!1,suppressEdits:!1,pasteIncoming:!1,cutIncoming:!1,selectingText:!1,draggingText:!1,highlight:new Pl,keySeq:null,specialChars:null},t.autofocus&&!Tl&&o.input.focus(),gl&&vl<11&&setTimeout(function(){return r.display.input.reset(!0)},20),Xo(this),eo(),nn(this),this.curOp.forceUpdate=!0,qn(this,n),t.autofocus&&!Tl||this.hasFocus()?setTimeout(u(Hr,this),20):Fr(this);for(var l in _s)_s.hasOwnProperty(l)&&_s[l](r,t[l],Xs);Rr(this),t.finishInit&&t.finishInit(this);for(var s=0;s<$s.length;++s)$s[s](r);on(this),ml&&t.lineWrapping&&"optimizelegibility"==getComputedStyle(o.lineDiv).textRendering&&(o.lineDiv.style.textRendering="auto")}function Xo(e){function t(){i.activeTouch&&(o=setTimeout(function(){return i.activeTouch=null},1e3),(l=i.activeTouch).end=+new Date)}function r(e){if(1!=e.touches.length)return!1;var t=e.touches[0];return t.radiusX<=1&&t.radiusY<=1}function n(e,t){if(null==t.left)return!0;var r=t.left-e.left,n=t.top-e.top;return r*r+n*n>400}var i=e.display;Ql(i.scroller,"mousedown",dn(e,Oo)),gl&&vl<11?Ql(i.scroller,"dblclick",dn(e,function(t){if(!Me(e,t)){var r=Sr(e,t);if(r&&!zo(e,t)&&!Ft(e.display,t)){We(t);var n=e.findWordAt(r);di(e.doc,n.anchor,n.head)}}})):Ql(i.scroller,"dblclick",function(t){return Me(e,t)||We(t)}),Hl||Ql(i.scroller,"contextmenu",function(t){return Ro(e,t)});var o,l={end:0};Ql(i.scroller,"touchstart",function(t){if(!Me(e,t)&&!r(t)&&!zo(e,t)){i.input.ensurePolled(),clearTimeout(o);var n=+new Date;i.activeTouch={start:n,moved:!1,prev:n-l.end<=300?l:null},1==t.touches.length&&(i.activeTouch.left=t.touches[0].pageX,i.activeTouch.top=t.touches[0].pageY)}}),Ql(i.scroller,"touchmove",function(){i.activeTouch&&(i.activeTouch.moved=!0)}),Ql(i.scroller,"touchend",function(r){var o=i.activeTouch;if(o&&!Ft(i,r)&&null!=o.left&&!o.moved&&new Date-o.start<300){var l,s=e.coordsChar(i.activeTouch,"page");l=!o.prev||n(o,o.prev)?new Ts(s,s):!o.prev.prev||n(o,o.prev.prev)?e.findWordAt(s):new Ts(E(s.line,0),U(e.doc,E(s.line+1,0))),e.setSelection(l.anchor,l.head),e.focus(),We(r)}t()}),Ql(i.scroller,"touchcancel",t),Ql(i.scroller,"scroll",function(){i.scroller.clientHeight&&(qr(e,i.scroller.scrollTop),Qr(e,i.scroller.scrollLeft,!0),Te(e,"scroll",e))}),Ql(i.scroller,"mousewheel",function(t){return In(e,t)}),Ql(i.scroller,"DOMMouseScroll",function(t){return In(e,t)}),Ql(i.wrapper,"scroll",function(){return i.wrapper.scrollTop=i.wrapper.scrollLeft=0}),i.dragFunctions={enter:function(t){Me(e,t)||Fe(t)},over:function(t){Me(e,t)||(Zi(e,t),Fe(t))},start:function(t){return qi(e,t)},drop:dn(e,$i),leave:function(t){Me(e,t)||Qi(e)}};var s=i.input.getField();Ql(s,"keyup",function(t){return To.call(e,t)}),Ql(s,"keydown",dn(e,Lo)),Ql(s,"keypress",dn(e,Mo)),Ql(s,"focus",function(t){return Hr(e,t)}),Ql(s,"blur",function(t){return Fr(e,t)})}function Yo(e,t,r,n){var i,o=e.doc;null==r&&(r="add"),"smart"==r&&(o.mode.indent?i=$e(e,t).state:r="prev");var l=e.options.tabSize,s=M(o,t),a=f(s.text,null,l);s.stateAfter&&(s.stateAfter=null);var u,c=s.text.match(/^\s*/)[0];if(n||/\S/.test(s.text)){if("smart"==r&&((u=o.mode.indent(i,s.text.slice(c.length),s.text))==Bl||u>150)){if(!n)return;r="prev"}}else u=0,r="not";"prev"==r?u=t>o.first?f(M(o,t-1).text,null,l):0:"add"==r?u=a+e.options.indentUnit:"subtract"==r?u=a-e.options.indentUnit:"number"==typeof r&&(u=a+r),u=Math.max(0,u);var h="",d=0;if(e.options.indentWithTabs)for(var g=Math.floor(u/l);g;--g)d+=l,h+="\t";if(d<u&&(h+=p(u-d)),h!=c)return Ei(o,h,E(t,0),E(t,c.length),"+input"),s.stateAfter=null,!0;for(var v=0;v<o.sel.ranges.length;v++){var m=o.sel.ranges[v];if(m.head.line==t&&m.head.ch<c.length){var y=E(t,c.length);gi(o,v,new Ts(y,y));break}}}function _o(e){qs=e}function $o(e,t,r,n,i){var o=e.doc;e.display.shift=!1,n||(n=o.sel);var l=e.state.pasteIncoming||"paste"==i,s=es(t),a=null;if(l&&n.ranges.length>1)if(qs&&qs.text.join("\n")==t){if(n.ranges.length%qs.text.length==0){a=[];for(var u=0;u<qs.text.length;u++)a.push(o.splitLines(qs.text[u]))}}else s.length==n.ranges.length&&e.options.pasteLinesPerSelection&&(a=v(s,function(e){return[e]}));for(var c,f=n.ranges.length-1;f>=0;f--){var h=n.ranges[f],d=h.from(),p=h.to();h.empty()&&(r&&r>0?d=E(d.line,d.ch-r):e.state.overwrite&&!l?p=E(p.line,Math.min(M(o,p.line).text.length,p.ch+g(s).length)):qs&&qs.lineWise&&qs.text.join("\n")==t&&(d=p=E(d.line,0))),c=e.curOp.updateInput;var m={from:d,to:p,text:a?a[f%a.length]:s,origin:i||(l?"paste":e.state.cutIncoming?"cut":"+input")};Oi(e.doc,m),bt(e,"inputRead",e,m)}t&&!l&&Zo(e,t),jr(e),e.curOp.updateInput=c,e.curOp.typing=!0,e.state.pasteIncoming=e.state.cutIncoming=!1}function qo(e,t){var r=e.clipboardData&&e.clipboardData.getData("Text");if(r)return e.preventDefault(),t.isReadOnly()||t.options.disableInput||hn(t,function(){return $o(t,r,0,null,"paste")}),!0}function Zo(e,t){if(e.options.electricChars&&e.options.smartIndent)for(var r=e.doc.sel,n=r.ranges.length-1;n>=0;n--){var i=r.ranges[n];if(!(i.head.ch>100||n&&r.ranges[n-1].head.line==i.head.line)){var o=e.getModeAt(i.head),l=!1;if(o.electricChars){for(var s=0;s<o.electricChars.length;s++)if(t.indexOf(o.electricChars.charAt(s))>-1){l=Yo(e,i.head.line,"smart");break}}else o.electricInput&&o.electricInput.test(M(e.doc,i.head.line).text.slice(0,i.head.ch))&&(l=Yo(e,i.head.line,"smart"));l&&bt(e,"electricInput",e,i.head.line)}}}function Qo(e){for(var t=[],r=[],n=0;n<e.doc.sel.ranges.length;n++){var i=e.doc.sel.ranges[n].head.line,o={anchor:E(i,0),head:E(i+1,0)};r.push(o),t.push(e.getRange(o.anchor,o.head))}return{text:t,ranges:r}}function Jo(e,t){e.setAttribute("autocorrect","off"),e.setAttribute("autocapitalize","off"),e.setAttribute("spellcheck",!!t)}function el(){var e=n("textarea",null,null,"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none"),t=n("div",[e],null,"overflow: hidden; position: relative; width: 3px; height: 0px;");return ml?e.style.width="1000px":e.setAttribute("wrap","off"),Ll&&(e.style.border="1px solid black"),Jo(e),t}function tl(e,t,r,n,i){function o(){var n=t.line+r;return!(n<e.first||n>=e.first+e.size)&&(t=new E(n,t.ch,t.sticky),u=M(e,n))}function l(n){var l;if(null==(l=i?go(e.cm,u,t,r):ho(u,t,r))){if(n||!o())return!1;t=po(i,e.cm,u,t.line,r)}else t=l;return!0}var s=t,a=r,u=M(e,t.line);if("char"==n)l();else if("column"==n)l(!0);else if("word"==n||"group"==n)for(var c=null,f="group"==n,h=e.cm&&e.cm.getHelper(t,"wordChars"),d=!0;!(r<0)||l(!d);d=!1){var p=u.text.charAt(t.ch)||"\n",g=x(p,h)?"w":f&&"\n"==p?"n":!f||/\s/.test(p)?null:"p";if(!f||d||g||(g="s"),c&&c!=g){r<0&&(r=1,l(),t.sticky="after");break}if(g&&(c=g),r>0&&!l(!d))break}var v=ki(e,t,s,a,!0);return I(s,v)&&(v.hitSide=!0),v}function rl(e,t,r,n){var i,o=e.doc,l=t.left;if("page"==n){var s=Math.min(e.display.wrapper.clientHeight,window.innerHeight||document.documentElement.clientHeight),a=Math.max(s-.5*mr(e.display),3);i=(r>0?t.bottom:t.top)+r*a}else"line"==n&&(i=r>0?t.bottom+3:t.top-3);for(var u;(u=cr(e,l,i)).outside;){if(r<0?i<=0:i>=o.height){u.hitSide=!0;break}i+=5*r}return u}function nl(e,t){var r=jt(e,t.line);if(!r||r.hidden)return null;var n=M(e.doc,t.line),i=Ut(r,n,t.line),o=Se(n,e.doc.direction),l="left";o&&(l=Ce(o,t.ch)%2?"right":"left");var s=_t(i.map,t.ch,l);return s.offset="right"==s.collapse?s.end:s.start,s}function il(e){for(var t=e;t;t=t.parentNode)if(/CodeMirror-gutter-wrapper/.test(t.className))return!0;return!1}function ol(e,t){return t&&(e.bad=!0),e}function ll(e,t,r,n,i){function o(e){return function(t){return t.id==e}}function l(){c&&(u+=f,c=!1)}function s(e){e&&(l(),u+=e)}function a(t){if(1==t.nodeType){var r=t.getAttribute("cm-text");if(null!=r)return void s(r||t.textContent.replace(/\u200b/g,""));var u,h=t.getAttribute("cm-marker");if(h){var d=e.findMarks(E(n,0),E(i+1,0),o(+h));return void(d.length&&(u=d[0].find(0))&&s(N(e.doc,u.from,u.to).join(f)))}if("false"==t.getAttribute("contenteditable"))return;var p=/^(pre|div|p)$/i.test(t.nodeName);p&&l();for(var g=0;g<t.childNodes.length;g++)a(t.childNodes[g]);p&&(c=!0)}else 3==t.nodeType&&s(t.nodeValue)}for(var u="",c=!1,f=e.doc.lineSeparator();a(t),t!=r;)t=t.nextSibling;return u}function sl(e,t,r){var n;if(t==e.display.lineDiv){if(!(n=e.display.lineDiv.childNodes[r]))return ol(e.clipPos(E(e.display.viewTo-1)),!0);t=null,r=0}else for(n=t;;n=n.parentNode){if(!n||n==e.display.lineDiv)return null;if(n.parentNode&&n.parentNode==e.display.lineDiv)break}for(var i=0;i<e.display.view.length;i++){var o=e.display.view[i];if(o.node==n)return al(o,t,r)}}function al(e,t,r){function n(t,r,n){for(var i=-1;i<(f?f.length:0);i++)for(var o=i<0?c.map:f[i],l=0;l<o.length;l+=3){var s=o[l+2];if(s==t||s==r){var a=W(i<0?e.line:e.rest[i]),u=o[l]+n;return(n<0||s!=t)&&(u=o[l+(n?1:0)]),E(a,u)}}}var i=e.text.firstChild,l=!1;if(!t||!o(i,t))return ol(E(W(e.line),0),!0);if(t==i&&(l=!0,t=i.childNodes[r],r=0,!t)){var s=e.rest?g(e.rest):e.line;return ol(E(W(s),s.text.length),l)}var a=3==t.nodeType?t:null,u=t;for(a||1!=t.childNodes.length||3!=t.firstChild.nodeType||(a=t.firstChild,r&&(r=a.nodeValue.length));u.parentNode!=i;)u=u.parentNode;var c=e.measure,f=c.maps,h=n(a,u,r);if(h)return ol(h,l);for(var d=u.nextSibling,p=a?a.nodeValue.length-r:0;d;d=d.nextSibling){if(h=n(d,d.firstChild,0))return ol(E(h.line,h.ch-p),l);p+=d.textContent.length}for(var v=u.previousSibling,m=r;v;v=v.previousSibling){if(h=n(v,v.firstChild,-1))return ol(E(h.line,h.ch+m),l);m+=v.textContent.length}}var ul=navigator.userAgent,cl=navigator.platform,fl=/gecko\/\d/i.test(ul),hl=/MSIE \d/.test(ul),dl=/Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(ul),pl=/Edge\/(\d+)/.exec(ul),gl=hl||dl||pl,vl=gl&&(hl?document.documentMode||6:+(pl||dl)[1]),ml=!pl&&/WebKit\//.test(ul),yl=ml&&/Qt\/\d+\.\d+/.test(ul),bl=!pl&&/Chrome\//.test(ul),wl=/Opera\//.test(ul),xl=/Apple Computer/.test(navigator.vendor),Cl=/Mac OS X 1\d\D([8-9]|\d\d)\D/.test(ul),Sl=/PhantomJS/.test(ul),Ll=!pl&&/AppleWebKit/.test(ul)&&/Mobile\/\w+/.test(ul),kl=/Android/.test(ul),Tl=Ll||kl||/webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(ul),Ml=Ll||/Mac/.test(cl),Nl=/\bCrOS\b/.test(ul),Ol=/win/i.test(cl),Al=wl&&ul.match(/Version\/(\d*\.\d*)/);Al&&(Al=Number(Al[1])),Al&&Al>=15&&(wl=!1,ml=!0);var Wl,Dl=Ml&&(yl||wl&&(null==Al||Al<12.11)),Hl=fl||gl&&vl>=9,Fl=function(t,r){var n=t.className,i=e(r).exec(n);if(i){var o=n.slice(i.index+i[0].length);t.className=n.slice(0,i.index)+(o?i[1]+o:"")}};Wl=document.createRange?function(e,t,r,n){var i=document.createRange();return i.setEnd(n||e,r),i.setStart(e,t),i}:function(e,t,r){var n=document.body.createTextRange();try{n.moveToElementText(e.parentNode)}catch(e){return n}return n.collapse(!0),n.moveEnd("character",r),n.moveStart("character",t),n};var El=function(e){e.select()};Ll?El=function(e){e.selectionStart=0,e.selectionEnd=e.value.length}:gl&&(El=function(e){try{e.select()}catch(e){}});var Pl=function(){this.id=null};Pl.prototype.set=function(e,t){clearTimeout(this.id),this.id=setTimeout(t,e)};var Il,zl,Rl=30,Bl={toString:function(){return"CodeMirror.Pass"}},Gl={scroll:!1},Ul={origin:"*mouse"},Vl={origin:"+move"},Kl=[""],jl=/[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/,Xl=/[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/,Yl=!1,_l=!1,$l=null,ql=function(){function e(e){return e<=247?r.charAt(e):1424<=e&&e<=1524?"R":1536<=e&&e<=1785?n.charAt(e-1536):1774<=e&&e<=2220?"r":8192<=e&&e<=8203?"w":8204==e?"b":"L"}function t(e,t,r){this.level=e,this.from=t,this.to=r}var r="bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN",n="nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111",i=/[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/,o=/[stwN]/,l=/[LRr]/,s=/[Lb1n]/,a=/[1n]/;return function(r,n){var u="ltr"==n?"L":"R";if(0==r.length||"ltr"==n&&!i.test(r))return!1;for(var c=r.length,f=[],h=0;h<c;++h)f.push(e(r.charCodeAt(h)));for(var d=0,p=u;d<c;++d){var v=f[d];"m"==v?f[d]=p:p=v}for(var m=0,y=u;m<c;++m){var b=f[m];"1"==b&&"r"==y?f[m]="n":l.test(b)&&(y=b,"r"==b&&(f[m]="R"))}for(var w=1,x=f[0];w<c-1;++w){var C=f[w];"+"==C&&"1"==x&&"1"==f[w+1]?f[w]="1":","!=C||x!=f[w+1]||"1"!=x&&"n"!=x||(f[w]=x),x=C}for(var S=0;S<c;++S){var L=f[S];if(","==L)f[S]="N";else if("%"==L){var k=void 0;for(k=S+1;k<c&&"%"==f[k];++k);for(var T=S&&"!"==f[S-1]||k<c&&"1"==f[k]?"1":"N",M=S;M<k;++M)f[M]=T;S=k-1}}for(var N=0,O=u;N<c;++N){var A=f[N];"L"==O&&"1"==A?f[N]="L":l.test(A)&&(O=A)}for(var W=0;W<c;++W)if(o.test(f[W])){var D=void 0;for(D=W+1;D<c&&o.test(f[D]);++D);for(var H="L"==(W?f[W-1]:u),F=H==("L"==(D<c?f[D]:u))?H?"L":"R":u,E=W;E<D;++E)f[E]=F;W=D-1}for(var P,I=[],z=0;z<c;)if(s.test(f[z])){var R=z;for(++z;z<c&&s.test(f[z]);++z);I.push(new t(0,R,z))}else{var B=z,G=I.length;for(++z;z<c&&"L"!=f[z];++z);for(var U=B;U<z;)if(a.test(f[U])){B<U&&I.splice(G,0,new t(1,B,U));var V=U;for(++U;U<z&&a.test(f[U]);++U);I.splice(G,0,new t(2,V,U)),B=U}else++U;B<z&&I.splice(G,0,new t(1,B,z))}return 1==I[0].level&&(P=r.match(/^\s+/))&&(I[0].from=P[0].length,I.unshift(new t(0,0,P[0].length))),1==g(I).level&&(P=r.match(/\s+$/))&&(g(I).to-=P[0].length,I.push(new t(0,c-P[0].length,c))),"rtl"==n?I.reverse():I}}(),Zl=[],Ql=function(e,t,r){if(e.addEventListener)e.addEventListener(t,r,!1);else if(e.attachEvent)e.attachEvent("on"+t,r);else{var n=e._handlers||(e._handlers={});n[t]=(n[t]||Zl).concat(r)}},Jl=function(){if(gl&&vl<9)return!1;var e=n("div");return"draggable"in e||"dragDrop"in e}(),es=3!="\n\nb".split(/\n/).length?function(e){for(var t=0,r=[],n=e.length;t<=n;){var i=e.indexOf("\n",t);-1==i&&(i=e.length);var o=e.slice(t,"\r"==e.charAt(i-1)?i-1:i),l=o.indexOf("\r");-1!=l?(r.push(o.slice(0,l)),t+=l+1):(r.push(o),t=i+1)}return r}:function(e){return e.split(/\r\n?|\n/)},ts=window.getSelection?function(e){try{return e.selectionStart!=e.selectionEnd}catch(e){return!1}}:function(e){var t;try{t=e.ownerDocument.selection.createRange()}catch(e){}return!(!t||t.parentElement()!=e)&&0!=t.compareEndPoints("StartToEnd",t)},rs=function(){var e=n("div");return"oncopy"in e||(e.setAttribute("oncopy","return;"),"function"==typeof e.oncopy)}(),ns=null,is={},os={},ls={},ss=function(e,t,r){this.pos=this.start=0,this.string=e,this.tabSize=t||8,this.lastColumnPos=this.lastColumnValue=0,this.lineStart=0,this.lineOracle=r};ss.prototype.eol=function(){return this.pos>=this.string.length},ss.prototype.sol=function(){return this.pos==this.lineStart},ss.prototype.peek=function(){return this.string.charAt(this.pos)||void 0},ss.prototype.next=function(){if(this.pos<this.string.length)return this.string.charAt(this.pos++)},ss.prototype.eat=function(e){var t=this.string.charAt(this.pos);if("string"==typeof e?t==e:t&&(e.test?e.test(t):e(t)))return++this.pos,t},ss.prototype.eatWhile=function(e){for(var t=this.pos;this.eat(e););return this.pos>t},ss.prototype.eatSpace=function(){for(var e=this,t=this.pos;/[\s\u00a0]/.test(this.string.charAt(this.pos));)++e.pos;return this.pos>t},ss.prototype.skipToEnd=function(){this.pos=this.string.length},ss.prototype.skipTo=function(e){var t=this.string.indexOf(e,this.pos);if(t>-1)return this.pos=t,!0},ss.prototype.backUp=function(e){this.pos-=e},ss.prototype.column=function(){return this.lastColumnPos<this.start&&(this.lastColumnValue=f(this.string,this.start,this.tabSize,this.lastColumnPos,this.lastColumnValue),this.lastColumnPos=this.start),this.lastColumnValue-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.indentation=function(){return f(this.string,null,this.tabSize)-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.match=function(e,t,r){if("string"!=typeof e){var n=this.string.slice(this.pos).match(e);return n&&n.index>0?null:(n&&!1!==t&&(this.pos+=n[0].length),n)}var i=function(e){return r?e.toLowerCase():e};if(i(this.string.substr(this.pos,e.length))==i(e))return!1!==t&&(this.pos+=e.length),!0},ss.prototype.current=function(){return this.string.slice(this.start,this.pos)},ss.prototype.hideFirstChars=function(e,t){this.lineStart+=e;try{return t()}finally{this.lineStart-=e}},ss.prototype.lookAhead=function(e){var t=this.lineOracle;return t&&t.lookAhead(e)};var as=function(e,t){this.state=e,this.lookAhead=t},us=function(e,t,r,n){this.state=t,this.doc=e,this.line=r,this.maxLookAhead=n||0};us.prototype.lookAhead=function(e){var t=this.doc.getLine(this.line+e);return null!=t&&e>this.maxLookAhead&&(this.maxLookAhead=e),t},us.prototype.nextLine=function(){this.line++,this.maxLookAhead>0&&this.maxLookAhead--},us.fromSaved=function(e,t,r){return t instanceof as?new us(e,Ke(e.mode,t.state),r,t.lookAhead):new us(e,Ke(e.mode,t),r)},us.prototype.save=function(e){var t=!1!==e?Ke(this.doc.mode,this.state):this.state;return this.maxLookAhead>0?new as(t,this.maxLookAhead):t};var cs=function(e,t,r){this.start=e.start,this.end=e.pos,this.string=e.current(),this.type=t||null,this.state=r},fs=function(e,t,r){this.text=e,ne(this,t),this.height=r?r(this):1};fs.prototype.lineNo=function(){return W(this)},Ae(fs);var hs,ds={},ps={},gs=null,vs=null,ms={left:0,right:0,top:0,bottom:0},ys=function(e,t,r){this.cm=r;var i=this.vert=n("div",[n("div",null,null,"min-width: 1px")],"CodeMirror-vscrollbar"),o=this.horiz=n("div",[n("div",null,null,"height: 100%; min-height: 1px")],"CodeMirror-hscrollbar");e(i),e(o),Ql(i,"scroll",function(){i.clientHeight&&t(i.scrollTop,"vertical")}),Ql(o,"scroll",function(){o.clientWidth&&t(o.scrollLeft,"horizontal")}),this.checkedZeroWidth=!1,gl&&vl<8&&(this.horiz.style.minHeight=this.vert.style.minWidth="18px")};ys.prototype.update=function(e){var t=e.scrollWidth>e.clientWidth+1,r=e.scrollHeight>e.clientHeight+1,n=e.nativeBarWidth;if(r){this.vert.style.display="block",this.vert.style.bottom=t?n+"px":"0";var i=e.viewHeight-(t?n:0);this.vert.firstChild.style.height=Math.max(0,e.scrollHeight-e.clientHeight+i)+"px"}else this.vert.style.display="",this.vert.firstChild.style.height="0";if(t){this.horiz.style.display="block",this.horiz.style.right=r?n+"px":"0",this.horiz.style.left=e.barLeft+"px";var o=e.viewWidth-e.barLeft-(r?n:0);this.horiz.firstChild.style.width=Math.max(0,e.scrollWidth-e.clientWidth+o)+"px"}else this.horiz.style.display="",this.horiz.firstChild.style.width="0";return!this.checkedZeroWidth&&e.clientHeight>0&&(0==n&&this.zeroWidthHack(),this.checkedZeroWidth=!0),{right:r?n:0,bottom:t?n:0}},ys.prototype.setScrollLeft=function(e){this.horiz.scrollLeft!=e&&(this.horiz.scrollLeft=e),this.disableHoriz&&this.enableZeroWidthBar(this.horiz,this.disableHoriz,"horiz")},ys.prototype.setScrollTop=function(e){this.vert.scrollTop!=e&&(this.vert.scrollTop=e),this.disableVert&&this.enableZeroWidthBar(this.vert,this.disableVert,"vert")},ys.prototype.zeroWidthHack=function(){var e=Ml&&!Cl?"12px":"18px";this.horiz.style.height=this.vert.style.width=e,this.horiz.style.pointerEvents=this.vert.style.pointerEvents="none",this.disableHoriz=new Pl,this.disableVert=new Pl},ys.prototype.enableZeroWidthBar=function(e,t,r){function n(){var i=e.getBoundingClientRect();("vert"==r?document.elementFromPoint(i.right-1,(i.top+i.bottom)/2):document.elementFromPoint((i.right+i.left)/2,i.bottom-1))!=e?e.style.pointerEvents="none":t.set(1e3,n)}e.style.pointerEvents="auto",t.set(1e3,n)},ys.prototype.clear=function(){var e=this.horiz.parentNode;e.removeChild(this.horiz),e.removeChild(this.vert)};var bs=function(){};bs.prototype.update=function(){return{bottom:0,right:0}},bs.prototype.setScrollLeft=function(){},bs.prototype.setScrollTop=function(){},bs.prototype.clear=function(){};var ws={native:ys,null:bs},xs=0,Cs=function(e,t,r){var n=e.display;this.viewport=t,this.visible=Ir(n,e.doc,t),this.editorIsHidden=!n.wrapper.offsetWidth,this.wrapperHeight=n.wrapper.clientHeight,this.wrapperWidth=n.wrapper.clientWidth,this.oldDisplayWidth=Rt(e),this.force=r,this.dims=br(e),this.events=[]};Cs.prototype.signal=function(e,t){Oe(e,t)&&this.events.push(arguments)},Cs.prototype.finish=function(){for(var e=this,t=0;t<this.events.length;t++)Te.apply(null,e.events[t])};var Ss=0,Ls=null;gl?Ls=-.53:fl?Ls=15:bl?Ls=-.7:xl&&(Ls=-1/3);var ks=function(e,t){this.ranges=e,this.primIndex=t};ks.prototype.primary=function(){return this.ranges[this.primIndex]},ks.prototype.equals=function(e){var t=this;if(e==this)return!0;if(e.primIndex!=this.primIndex||e.ranges.length!=this.ranges.length)return!1;for(var r=0;r<this.ranges.length;r++){var n=t.ranges[r],i=e.ranges[r];if(!I(n.anchor,i.anchor)||!I(n.head,i.head))return!1}return!0},ks.prototype.deepCopy=function(){for(var e=this,t=[],r=0;r<this.ranges.length;r++)t[r]=new Ts(z(e.ranges[r].anchor),z(e.ranges[r].head));return new ks(t,this.primIndex)},ks.prototype.somethingSelected=function(){for(var e=this,t=0;t<this.ranges.length;t++)if(!e.ranges[t].empty())return!0;return!1},ks.prototype.contains=function(e,t){var r=this;t||(t=e);for(var n=0;n<this.ranges.length;n++){var i=r.ranges[n];if(P(t,i.from())>=0&&P(e,i.to())<=0)return n}return-1};var Ts=function(e,t){this.anchor=e,this.head=t};Ts.prototype.from=function(){return B(this.anchor,this.head)},Ts.prototype.to=function(){return R(this.anchor,this.head)},Ts.prototype.empty=function(){return this.head.line==this.anchor.line&&this.head.ch==this.anchor.ch},Bi.prototype={chunkSize:function(){return this.lines.length},removeInner:function(e,t){for(var r=this,n=e,i=e+t;n<i;++n){var o=r.lines[n];r.height-=o.height,ot(o),bt(o,"delete")}this.lines.splice(e,t)},collapse:function(e){e.push.apply(e,this.lines)},insertInner:function(e,t,r){var n=this;this.height+=r,this.lines=this.lines.slice(0,e).concat(t).concat(this.lines.slice(e));for(var i=0;i<t.length;++i)t[i].parent=n},iterN:function(e,t,r){for(var n=this,i=e+t;e<i;++e)if(r(n.lines[e]))return!0}},Gi.prototype={chunkSize:function(){return this.size},removeInner:function(e,t){var r=this;this.size-=t;for(var n=0;n<this.children.length;++n){var i=r.children[n],o=i.chunkSize();if(e<o){var l=Math.min(t,o-e),s=i.height;if(i.removeInner(e,l),r.height-=s-i.height,o==l&&(r.children.splice(n--,1),i.parent=null),0==(t-=l))break;e=0}else e-=o}if(this.size-t<25&&(this.children.length>1||!(this.children[0]instanceof Bi))){var a=[];this.collapse(a),this.children=[new Bi(a)],this.children[0].parent=this}},collapse:function(e){for(var t=this,r=0;r<this.children.length;++r)t.children[r].collapse(e)},insertInner:function(e,t,r){var n=this;this.size+=t.length,this.height+=r;for(var i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<=l){if(o.insertInner(e,t,r),o.lines&&o.lines.length>50){for(var s=o.lines.length%25+25,a=s;a<o.lines.length;){var u=new Bi(o.lines.slice(a,a+=25));o.height-=u.height,n.children.splice(++i,0,u),u.parent=n}o.lines=o.lines.slice(0,s),n.maybeSpill()}break}e-=l}},maybeSpill:function(){if(!(this.children.length<=10)){var e=this;do{var t=new Gi(e.children.splice(e.children.length-5,5));if(e.parent){e.size-=t.size,e.height-=t.height;var r=h(e.parent.children,e);e.parent.children.splice(r+1,0,t)}else{var n=new Gi(e.children);n.parent=e,e.children=[n,t],e=n}t.parent=e.parent}while(e.children.length>10);e.parent.maybeSpill()}},iterN:function(e,t,r){for(var n=this,i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<l){var s=Math.min(t,l-e);if(o.iterN(e,s,r))return!0;if(0==(t-=s))break;e=0}else e-=l}}};var Ms=function(e,t,r){var n=this;if(r)for(var i in r)r.hasOwnProperty(i)&&(n[i]=r[i]);this.doc=e,this.node=t};Ms.prototype.clear=function(){var e=this,t=this.doc.cm,r=this.line.widgets,n=this.line,i=W(n);if(null!=i&&r){for(var o=0;o<r.length;++o)r[o]==e&&r.splice(o--,1);r.length||(n.widgets=null);var l=Ht(this);A(n,Math.max(0,n.height-l)),t&&(hn(t,function(){Ui(t,n,-l),mn(t,i,"widget")}),bt(t,"lineWidgetCleared",t,this,i))}},Ms.prototype.changed=function(){var e=this,t=this.height,r=this.doc.cm,n=this.line;this.height=null;var i=Ht(this)-t;i&&(A(n,n.height+i),r&&hn(r,function(){r.curOp.forceUpdate=!0,Ui(r,n,i),bt(r,"lineWidgetChanged",r,e,W(n))}))},Ae(Ms);var Ns=0,Os=function(e,t){this.lines=[],this.type=t,this.doc=e,this.id=++Ns};Os.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){var t=this.doc.cm,r=t&&!t.curOp;if(r&&nn(t),Oe(this,"clear")){var n=this.find();n&&bt(this,"clear",n.from,n.to)}for(var i=null,o=null,l=0;l<this.lines.length;++l){var s=e.lines[l],a=_(s.markedSpans,e);t&&!e.collapsed?mn(t,W(s),"text"):t&&(null!=a.to&&(o=W(s)),null!=a.from&&(i=W(s))),s.markedSpans=$(s.markedSpans,a),null==a.from&&e.collapsed&&!ve(e.doc,s)&&t&&A(s,mr(t.display))}if(t&&this.collapsed&&!t.options.lineWrapping)for(var u=0;u<this.lines.length;++u){var c=fe(e.lines[u]),f=be(c);f>t.display.maxLineLength&&(t.display.maxLine=c,t.display.maxLineLength=f,t.display.maxLineChanged=!0)}null!=i&&t&&this.collapsed&&vn(t,i,o+1),this.lines.length=0,this.explicitlyCleared=!0,this.atomic&&this.doc.cantEdit&&(this.doc.cantEdit=!1,t&&Ci(t.doc)),t&&bt(t,"markerCleared",t,this,i,o),r&&on(t),this.parent&&this.parent.clear()}},Os.prototype.find=function(e,t){var r=this;null==e&&"bookmark"==this.type&&(e=1);for(var n,i,o=0;o<this.lines.length;++o){var l=r.lines[o],s=_(l.markedSpans,r);if(null!=s.from&&(n=E(t?l:W(l),s.from),-1==e))return n;if(null!=s.to&&(i=E(t?l:W(l),s.to),1==e))return i}return n&&{from:n,to:i}},Os.prototype.changed=function(){var e=this,t=this.find(-1,!0),r=this,n=this.doc.cm;t&&n&&hn(n,function(){var i=t.line,o=W(t.line),l=jt(n,o);if(l&&(Qt(l),n.curOp.selectionChanged=n.curOp.forceUpdate=!0),n.curOp.updateMaxLine=!0,!ve(r.doc,i)&&null!=r.height){var s=r.height;r.height=null;var a=Ht(r)-s;a&&A(i,i.height+a)}bt(n,"markerChanged",n,e)})},Os.prototype.attachLine=function(e){if(!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;t.maybeHiddenMarkers&&-1!=h(t.maybeHiddenMarkers,this)||(t.maybeUnhiddenMarkers||(t.maybeUnhiddenMarkers=[])).push(this)}this.lines.push(e)},Os.prototype.detachLine=function(e){if(this.lines.splice(h(this.lines,e),1),!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;(t.maybeHiddenMarkers||(t.maybeHiddenMarkers=[])).push(this)}},Ae(Os);var As=function(e,t){var r=this;this.markers=e,this.primary=t;for(var n=0;n<e.length;++n)e[n].parent=r};As.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){this.explicitlyCleared=!0;for(var t=0;t<this.markers.length;++t)e.markers[t].clear();bt(this,"clear")}},As.prototype.find=function(e,t){return this.primary.find(e,t)},Ae(As);var Ws=0,Ds=function(e,t,r,n,i){if(!(this instanceof Ds))return new Ds(e,t,r,n,i);null==r&&(r=0),Gi.call(this,[new Bi([new fs("",null)])]),this.first=r,this.scrollTop=this.scrollLeft=0,this.cantEdit=!1,this.cleanGeneration=1,this.modeFrontier=this.highlightFrontier=r;var o=E(r,0);this.sel=Rn(o),this.history=new Jn(null),this.id=++Ws,this.modeOption=t,this.lineSep=n,this.direction="rtl"==i?"rtl":"ltr",this.extend=!1,"string"==typeof e&&(e=this.splitLines(e)),_n(this,{from:o,to:o,text:e}),bi(this,Rn(o),Gl)};Ds.prototype=b(Gi.prototype,{constructor:Ds,iter:function(e,t,r){r?this.iterN(e-this.first,t-e,r):this.iterN(this.first,this.first+this.size,e)},insert:function(e,t){for(var r=0,n=0;n<t.length;++n)r+=t[n].height;this.insertInner(e-this.first,t,r)},remove:function(e,t){this.removeInner(e-this.first,t)},getValue:function(e){var t=O(this,this.first,this.first+this.size);return!1===e?t:t.join(e||this.lineSeparator())},setValue:gn(function(e){var t=E(this.first,0),r=this.first+this.size-1;Oi(this,{from:t,to:E(r,M(this,r).text.length),text:this.splitLines(e),origin:"setValue",full:!0},!0),this.cm&&Xr(this.cm,0,0),bi(this,Rn(t),Gl)}),replaceRange:function(e,t,r,n){Ei(this,e,t=U(this,t),r=r?U(this,r):t,n)},getRange:function(e,t,r){var n=N(this,U(this,e),U(this,t));return!1===r?n:n.join(r||this.lineSeparator())},getLine:function(e){var t=this.getLineHandle(e);return t&&t.text},getLineHandle:function(e){if(H(this,e))return M(this,e)},getLineNumber:function(e){return W(e)},getLineHandleVisualStart:function(e){return"number"==typeof e&&(e=M(this,e)),fe(e)},lineCount:function(){return this.size},firstLine:function(){return this.first},lastLine:function(){return this.first+this.size-1},clipPos:function(e){return U(this,e)},getCursor:function(e){var t=this.sel.primary();return null==e||"head"==e?t.head:"anchor"==e?t.anchor:"end"==e||"to"==e||!1===e?t.to():t.from()},listSelections:function(){return this.sel.ranges},somethingSelected:function(){return this.sel.somethingSelected()},setCursor:gn(function(e,t,r){vi(this,U(this,"number"==typeof e?E(e,t||0):e),null,r)}),setSelection:gn(function(e,t,r){vi(this,U(this,e),U(this,t||e),r)}),extendSelection:gn(function(e,t,r){di(this,U(this,e),t&&U(this,t),r)}),extendSelections:gn(function(e,t){pi(this,K(this,e),t)}),extendSelectionsBy:gn(function(e,t){pi(this,K(this,v(this.sel.ranges,e)),t)}),setSelections:gn(function(e,t,r){var n=this;if(e.length){for(var i=[],o=0;o<e.length;o++)i[o]=new Ts(U(n,e[o].anchor),U(n,e[o].head));null==t&&(t=Math.min(e.length-1,this.sel.primIndex)),bi(this,zn(i,t),r)}}),addSelection:gn(function(e,t,r){var n=this.sel.ranges.slice(0);n.push(new Ts(U(this,e),U(this,t||e))),bi(this,zn(n,n.length-1),r)}),getSelection:function(e){for(var t,r=this,n=this.sel.ranges,i=0;i<n.length;i++){var o=N(r,n[i].from(),n[i].to());t=t?t.concat(o):o}return!1===e?t:t.join(e||this.lineSeparator())},getSelections:function(e){for(var t=this,r=[],n=this.sel.ranges,i=0;i<n.length;i++){var o=N(t,n[i].from(),n[i].to());!1!==e&&(o=o.join(e||t.lineSeparator())),r[i]=o}return r},replaceSelection:function(e,t,r){for(var n=[],i=0;i<this.sel.ranges.length;i++)n[i]=e;this.replaceSelections(n,t,r||"+input")},replaceSelections:gn(function(e,t,r){for(var n=this,i=[],o=this.sel,l=0;l<o.ranges.length;l++){var s=o.ranges[l];i[l]={from:s.from(),to:s.to(),text:n.splitLines(e[l]),origin:r}}for(var a=t&&"end"!=t&&Kn(this,i,t),u=i.length-1;u>=0;u--)Oi(n,i[u]);a?yi(this,a):this.cm&&jr(this.cm)}),undo:gn(function(){Wi(this,"undo")}),redo:gn(function(){Wi(this,"redo")}),undoSelection:gn(function(){Wi(this,"undo",!0)}),redoSelection:gn(function(){Wi(this,"redo",!0)}),setExtending:function(e){this.extend=e},getExtending:function(){return this.extend},historySize:function(){for(var e=this.history,t=0,r=0,n=0;n<e.done.length;n++)e.done[n].ranges||++t;for(var i=0;i<e.undone.length;i++)e.undone[i].ranges||++r;return{undo:t,redo:r}},clearHistory:function(){this.history=new Jn(this.history.maxGeneration)},markClean:function(){this.cleanGeneration=this.changeGeneration(!0)},changeGeneration:function(e){return e&&(this.history.lastOp=this.history.lastSelOp=this.history.lastOrigin=null),this.history.generation},isClean:function(e){return this.history.generation==(e||this.cleanGeneration)},getHistory:function(){return{done:fi(this.history.done),undone:fi(this.history.undone)}},setHistory:function(e){var t=this.history=new Jn(this.history.maxGeneration);t.done=fi(e.done.slice(0),null,!0),t.undone=fi(e.undone.slice(0),null,!0)},setGutterMarker:gn(function(e,t,r){return Ri(this,e,"gutter",function(e){var n=e.gutterMarkers||(e.gutterMarkers={});return n[t]=r,!r&&C(n)&&(e.gutterMarkers=null),!0})}),clearGutter:gn(function(e){var t=this;this.iter(function(r){r.gutterMarkers&&r.gutterMarkers[e]&&Ri(t,r,"gutter",function(){return r.gutterMarkers[e]=null,C(r.gutterMarkers)&&(r.gutterMarkers=null),!0})})}),lineInfo:function(e){var t;if("number"==typeof e){if(!H(this,e))return null;if(t=e,!(e=M(this,e)))return null}else if(null==(t=W(e)))return null;return{line:t,handle:e,text:e.text,gutterMarkers:e.gutterMarkers,textClass:e.textClass,bgClass:e.bgClass,wrapClass:e.wrapClass,widgets:e.widgets}},addLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass";if(t[i]){if(e(n).test(t[i]))return!1;t[i]+=" "+n}else t[i]=n;return!0})}),removeLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass",o=t[i];if(!o)return!1;if(null==n)t[i]=null;else{var l=o.match(e(n));if(!l)return!1;var s=l.index+l[0].length;t[i]=o.slice(0,l.index)+(l.index&&s!=o.length?" ":"")+o.slice(s)||null}return!0})}),addLineWidget:gn(function(e,t,r){return Vi(this,e,t,r)}),removeLineWidget:function(e){e.clear()},markText:function(e,t,r){return Ki(this,U(this,e),U(this,t),r,r&&r.type||"range")},setBookmark:function(e,t){var r={replacedWith:t&&(null==t.nodeType?t.widget:t),insertLeft:t&&t.insertLeft,clearWhenEmpty:!1,shared:t&&t.shared,handleMouseEvents:t&&t.handleMouseEvents};return e=U(this,e),Ki(this,e,e,r,"bookmark")},findMarksAt:function(e){var t=[],r=M(this,(e=U(this,e)).line).markedSpans;if(r)for(var n=0;n<r.length;++n){var i=r[n];(null==i.from||i.from<=e.ch)&&(null==i.to||i.to>=e.ch)&&t.push(i.marker.parent||i.marker)}return t},findMarks:function(e,t,r){e=U(this,e),t=U(this,t);var n=[],i=e.line;return this.iter(e.line,t.line+1,function(o){var l=o.markedSpans;if(l)for(var s=0;s<l.length;s++){var a=l[s];null!=a.to&&i==e.line&&e.ch>=a.to||null==a.from&&i!=e.line||null!=a.from&&i==t.line&&a.from>=t.ch||r&&!r(a.marker)||n.push(a.marker.parent||a.marker)}++i}),n},getAllMarks:function(){var e=[];return this.iter(function(t){var r=t.markedSpans;if(r)for(var n=0;n<r.length;++n)null!=r[n].from&&e.push(r[n].marker)}),e},posFromIndex:function(e){var t,r=this.first,n=this.lineSeparator().length;return this.iter(function(i){var o=i.text.length+n;if(o>e)return t=e,!0;e-=o,++r}),U(this,E(r,t))},indexFromPos:function(e){var t=(e=U(this,e)).ch;if(e.line<this.first||e.ch<0)return 0;var r=this.lineSeparator().length;return this.iter(this.first,e.line,function(e){t+=e.text.length+r}),t},copy:function(e){var t=new Ds(O(this,this.first,this.first+this.size),this.modeOption,this.first,this.lineSep,this.direction);return t.scrollTop=this.scrollTop,t.scrollLeft=this.scrollLeft,t.sel=this.sel,t.extend=!1,e&&(t.history.undoDepth=this.history.undoDepth,t.setHistory(this.getHistory())),t},linkedDoc:function(e){e||(e={});var t=this.first,r=this.first+this.size;null!=e.from&&e.from>t&&(t=e.from),null!=e.to&&e.to<r&&(r=e.to);var n=new Ds(O(this,t,r),e.mode||this.modeOption,t,this.lineSep,this.direction);return e.sharedHist&&(n.history=this.history),(this.linked||(this.linked=[])).push({doc:n,sharedHist:e.sharedHist}),n.linked=[{doc:this,isParent:!0,sharedHist:e.sharedHist}],Yi(n,Xi(this)),n},unlinkDoc:function(e){var t=this;if(e instanceof jo&&(e=e.doc),this.linked)for(var r=0;r<this.linked.length;++r)if(t.linked[r].doc==e){t.linked.splice(r,1),e.unlinkDoc(t),_i(Xi(t));break}if(e.history==this.history){var n=[e.id];$n(e,function(e){return n.push(e.id)},!0),e.history=new Jn(null),e.history.done=fi(this.history.done,n),e.history.undone=fi(this.history.undone,n)}},iterLinkedDocs:function(e){$n(this,e)},getMode:function(){return this.mode},getEditor:function(){return this.cm},splitLines:function(e){return this.lineSep?e.split(this.lineSep):es(e)},lineSeparator:function(){return this.lineSep||"\n"},setDirection:gn(function(e){"rtl"!=e&&(e="ltr"),e!=this.direction&&(this.direction=e,this.iter(function(e){return e.order=null}),this.cm&&Qn(this.cm))})}),Ds.prototype.eachLine=Ds.prototype.iter;for(var Hs=0,Fs=!1,Es={3:"Enter",8:"Backspace",9:"Tab",13:"Enter",16:"Shift",17:"Ctrl",18:"Alt",19:"Pause",20:"CapsLock",27:"Esc",32:"Space",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"Left",38:"Up",39:"Right",40:"Down",44:"PrintScrn",45:"Insert",46:"Delete",59:";",61:"=",91:"Mod",92:"Mod",93:"Mod",106:"*",107:"=",109:"-",110:".",111:"/",127:"Delete",173:"-",186:";",187:"=",188:",",189:"-",190:".",191:"/",192:"`",219:"[",220:"\\",221:"]",222:"'",63232:"Up",63233:"Down",63234:"Left",63235:"Right",63272:"Delete",63273:"Home",63275:"End",63276:"PageUp",63277:"PageDown",63302:"Insert"},Ps=0;Ps<10;Ps++)Es[Ps+48]=Es[Ps+96]=String(Ps);for(var Is=65;Is<=90;Is++)Es[Is]=String.fromCharCode(Is);for(var zs=1;zs<=12;zs++)Es[zs+111]=Es[zs+63235]="F"+zs;var Rs={};Rs.basic={Left:"goCharLeft",Right:"goCharRight",Up:"goLineUp",Down:"goLineDown",End:"goLineEnd",Home:"goLineStartSmart",PageUp:"goPageUp",PageDown:"goPageDown",Delete:"delCharAfter",Backspace:"delCharBefore","Shift-Backspace":"delCharBefore",Tab:"defaultTab","Shift-Tab":"indentAuto",Enter:"newlineAndIndent",Insert:"toggleOverwrite",Esc:"singleSelection"},Rs.pcDefault={"Ctrl-A":"selectAll","Ctrl-D":"deleteLine","Ctrl-Z":"undo","Shift-Ctrl-Z":"redo","Ctrl-Y":"redo","Ctrl-Home":"goDocStart","Ctrl-End":"goDocEnd","Ctrl-Up":"goLineUp","Ctrl-Down":"goLineDown","Ctrl-Left":"goGroupLeft","Ctrl-Right":"goGroupRight","Alt-Left":"goLineStart","Alt-Right":"goLineEnd","Ctrl-Backspace":"delGroupBefore","Ctrl-Delete":"delGroupAfter","Ctrl-S":"save","Ctrl-F":"find","Ctrl-G":"findNext","Shift-Ctrl-G":"findPrev","Shift-Ctrl-F":"replace","Shift-Ctrl-R":"replaceAll","Ctrl-[":"indentLess","Ctrl-]":"indentMore","Ctrl-U":"undoSelection","Shift-Ctrl-U":"redoSelection","Alt-U":"redoSelection",fallthrough:"basic"},Rs.emacsy={"Ctrl-F":"goCharRight","Ctrl-B":"goCharLeft","Ctrl-P":"goLineUp","Ctrl-N":"goLineDown","Alt-F":"goWordRight","Alt-B":"goWordLeft","Ctrl-A":"goLineStart","Ctrl-E":"goLineEnd","Ctrl-V":"goPageDown","Shift-Ctrl-V":"goPageUp","Ctrl-D":"delCharAfter","Ctrl-H":"delCharBefore","Alt-D":"delWordAfter","Alt-Backspace":"delWordBefore","Ctrl-K":"killLine","Ctrl-T":"transposeChars","Ctrl-O":"openLine"},Rs.macDefault={"Cmd-A":"selectAll","Cmd-D":"deleteLine","Cmd-Z":"undo","Shift-Cmd-Z":"redo","Cmd-Y":"redo","Cmd-Home":"goDocStart","Cmd-Up":"goDocStart","Cmd-End":"goDocEnd","Cmd-Down":"goDocEnd","Alt-Left":"goGroupLeft","Alt-Right":"goGroupRight","Cmd-Left":"goLineLeft","Cmd-Right":"goLineRight","Alt-Backspace":"delGroupBefore","Ctrl-Alt-Backspace":"delGroupAfter","Alt-Delete":"delGroupAfter","Cmd-S":"save","Cmd-F":"find","Cmd-G":"findNext","Shift-Cmd-G":"findPrev","Cmd-Alt-F":"replace","Shift-Cmd-Alt-F":"replaceAll","Cmd-[":"indentLess","Cmd-]":"indentMore","Cmd-Backspace":"delWrappedLineLeft","Cmd-Delete":"delWrappedLineRight","Cmd-U":"undoSelection","Shift-Cmd-U":"redoSelection","Ctrl-Up":"goDocStart","Ctrl-Down":"goDocEnd",fallthrough:["basic","emacsy"]},Rs.default=Ml?Rs.macDefault:Rs.pcDefault;var Bs={selectAll:Mi,singleSelection:function(e){return e.setSelection(e.getCursor("anchor"),e.getCursor("head"),Gl)},killLine:function(e){return co(e,function(t){if(t.empty()){var r=M(e.doc,t.head.line).text.length;return t.head.ch==r&&t.head.line<e.lastLine()?{from:t.head,to:E(t.head.line+1,0)}:{from:t.head,to:E(t.head.line,r)}}return{from:t.from(),to:t.to()}})},deleteLine:function(e){return co(e,function(t){return{from:E(t.from().line,0),to:U(e.doc,E(t.to().line+1,0))}})},delLineLeft:function(e){return co(e,function(e){return{from:E(e.from().line,0),to:e.from()}})},delWrappedLineLeft:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5;return{from:e.coordsChar({left:0,top:r},"div"),to:t.from()}})},delWrappedLineRight:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5,n=e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div");return{from:t.from(),to:n}})},undo:function(e){return e.undo()},redo:function(e){return e.redo()},undoSelection:function(e){return e.undoSelection()},redoSelection:function(e){return e.redoSelection()},goDocStart:function(e){return e.extendSelection(E(e.firstLine(),0))},goDocEnd:function(e){return e.extendSelection(E(e.lastLine()))},goLineStart:function(e){return e.extendSelectionsBy(function(t){return vo(e,t.head.line)},{origin:"+move",bias:1})},goLineStartSmart:function(e){return e.extendSelectionsBy(function(t){return yo(e,t.head)},{origin:"+move",bias:1})},goLineEnd:function(e){return e.extendSelectionsBy(function(t){return mo(e,t.head.line)},{origin:"+move",bias:-1})},goLineRight:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div")},Vl)},goLineLeft:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:0,top:r},"div")},Vl)},goLineLeftSmart:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5,n=e.coordsChar({left:0,top:r},"div");return n.ch<e.getLine(n.line).search(/\S/)?yo(e,t.head):n},Vl)},goLineUp:function(e){return e.moveV(-1,"line")},goLineDown:function(e){return e.moveV(1,"line")},goPageUp:function(e){return e.moveV(-1,"page")},goPageDown:function(e){return e.moveV(1,"page")},goCharLeft:function(e){return e.moveH(-1,"char")},goCharRight:function(e){return e.moveH(1,"char")},goColumnLeft:function(e){return e.moveH(-1,"column")},goColumnRight:function(e){return e.moveH(1,"column")},goWordLeft:function(e){return e.moveH(-1,"word")},goGroupRight:function(e){return e.moveH(1,"group")},goGroupLeft:function(e){return e.moveH(-1,"group")},goWordRight:function(e){return e.moveH(1,"word")},delCharBefore:function(e){return e.deleteH(-1,"char")},delCharAfter:function(e){return e.deleteH(1,"char")},delWordBefore:function(e){return e.deleteH(-1,"word")},delWordAfter:function(e){return e.deleteH(1,"word")},delGroupBefore:function(e){return e.deleteH(-1,"group")},delGroupAfter:function(e){return e.deleteH(1,"group")},indentAuto:function(e){return e.indentSelection("smart")},indentMore:function(e){return e.indentSelection("add")},indentLess:function(e){return e.indentSelection("subtract")},insertTab:function(e){return e.replaceSelection("\t")},insertSoftTab:function(e){for(var t=[],r=e.listSelections(),n=e.options.tabSize,i=0;i<r.length;i++){var o=r[i].from(),l=f(e.getLine(o.line),o.ch,n);t.push(p(n-l%n))}e.replaceSelections(t)},defaultTab:function(e){e.somethingSelected()?e.indentSelection("add"):e.execCommand("insertTab")},transposeChars:function(e){return hn(e,function(){for(var t=e.listSelections(),r=[],n=0;n<t.length;n++)if(t[n].empty()){var i=t[n].head,o=M(e.doc,i.line).text;if(o)if(i.ch==o.length&&(i=new E(i.line,i.ch-1)),i.ch>0)i=new E(i.line,i.ch+1),e.replaceRange(o.charAt(i.ch-1)+o.charAt(i.ch-2),E(i.line,i.ch-2),i,"+transpose");else if(i.line>e.doc.first){var l=M(e.doc,i.line-1).text;l&&(i=new E(i.line,1),e.replaceRange(o.charAt(0)+e.doc.lineSeparator()+l.charAt(l.length-1),E(i.line-1,l.length-1),i,"+transpose"))}r.push(new Ts(i,i))}e.setSelections(r)})},newlineAndIndent:function(e){return hn(e,function(){for(var t=e.listSelections(),r=t.length-1;r>=0;r--)e.replaceRange(e.doc.lineSeparator(),t[r].anchor,t[r].head,"+input");t=e.listSelections();for(var n=0;n<t.length;n++)e.indentLine(t[n].from().line,null,!0);jr(e)})},openLine:function(e){return e.replaceSelection("\n","start")},toggleOverwrite:function(e){return e.toggleOverwrite()}},Gs=new Pl,Us=null,Vs=function(e,t,r){this.time=e,this.pos=t,this.button=r};Vs.prototype.compare=function(e,t,r){return this.time+400>e&&0==P(t,this.pos)&&r==this.button};var Ks,js,Xs={toString:function(){return"CodeMirror.Init"}},Ys={},_s={};jo.defaults=Ys,jo.optionHandlers=_s;var $s=[];jo.defineInitHook=function(e){return $s.push(e)};var qs=null,Zs=function(e){this.cm=e,this.lastAnchorNode=this.lastAnchorOffset=this.lastFocusNode=this.lastFocusOffset=null,this.polling=new Pl,this.composing=null,this.gracePeriod=!1,this.readDOMTimeout=null};Zs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()}),"cut"==e.type&&i.replaceSelection("",null,"cut");else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type&&i.operation(function(){i.setSelections(t.ranges,0,Gl),i.replaceSelection("",null,"cut")})}if(e.clipboardData){e.clipboardData.clearData();var r=qs.text.join("\n");if(e.clipboardData.setData("Text",r),e.clipboardData.getData("Text")==r)return void e.preventDefault()}var l=el(),s=l.firstChild;i.display.lineSpace.insertBefore(l,i.display.lineSpace.firstChild),s.value=qs.text.join("\n");var a=document.activeElement;El(s),setTimeout(function(){i.display.lineSpace.removeChild(l),a.focus(),a==o&&n.showPrimarySelection()},50)}}var r=this,n=this,i=n.cm,o=n.div=e.lineDiv;Jo(o,i.options.spellcheck),Ql(o,"paste",function(e){Me(i,e)||qo(e,i)||vl<=11&&setTimeout(dn(i,function(){return r.updateFromDOM()}),20)}),Ql(o,"compositionstart",function(e){r.composing={data:e.data,done:!1}}),Ql(o,"compositionupdate",function(e){r.composing||(r.composing={data:e.data,done:!1})}),Ql(o,"compositionend",function(e){r.composing&&(e.data!=r.composing.data&&r.readFromDOMSoon(),r.composing.done=!0)}),Ql(o,"touchstart",function(){return n.forceCompositionEnd()}),Ql(o,"input",function(){r.composing||r.readFromDOMSoon()}),Ql(o,"copy",t),Ql(o,"cut",t)},Zs.prototype.prepareSelection=function(){var e=Tr(this.cm,!1);return e.focus=this.cm.state.focused,e},Zs.prototype.showSelection=function(e,t){e&&this.cm.display.view.length&&((e.focus||t)&&this.showPrimarySelection(),this.showMultipleSelections(e))},Zs.prototype.showPrimarySelection=function(){var e=window.getSelection(),t=this.cm,r=t.doc.sel.primary(),n=r.from(),i=r.to();if(t.display.viewTo==t.display.viewFrom||n.line>=t.display.viewTo||i.line<t.display.viewFrom)e.removeAllRanges();else{var o=sl(t,e.anchorNode,e.anchorOffset),l=sl(t,e.focusNode,e.focusOffset);if(!o||o.bad||!l||l.bad||0!=P(B(o,l),n)||0!=P(R(o,l),i)){var s=t.display.view,a=n.line>=t.display.viewFrom&&nl(t,n)||{node:s[0].measure.map[2],offset:0},u=i.line<t.display.viewTo&&nl(t,i);if(!u){var c=s[s.length-1].measure,f=c.maps?c.maps[c.maps.length-1]:c.map;u={node:f[f.length-1],offset:f[f.length-2]-f[f.length-3]}}if(a&&u){var h,d=e.rangeCount&&e.getRangeAt(0);try{h=Wl(a.node,a.offset,u.offset,u.node)}catch(e){}h&&(!fl&&t.state.focused?(e.collapse(a.node,a.offset),h.collapsed||(e.removeAllRanges(),e.addRange(h))):(e.removeAllRanges(),e.addRange(h)),d&&null==e.anchorNode?e.addRange(d):fl&&this.startGracePeriod()),this.rememberSelection()}else e.removeAllRanges()}}},Zs.prototype.startGracePeriod=function(){var e=this;clearTimeout(this.gracePeriod),this.gracePeriod=setTimeout(function(){e.gracePeriod=!1,e.selectionChanged()&&e.cm.operation(function(){return e.cm.curOp.selectionChanged=!0})},20)},Zs.prototype.showMultipleSelections=function(e){r(this.cm.display.cursorDiv,e.cursors),r(this.cm.display.selectionDiv,e.selection)},Zs.prototype.rememberSelection=function(){var e=window.getSelection();this.lastAnchorNode=e.anchorNode,this.lastAnchorOffset=e.anchorOffset,this.lastFocusNode=e.focusNode,this.lastFocusOffset=e.focusOffset},Zs.prototype.selectionInEditor=function(){var e=window.getSelection();if(!e.rangeCount)return!1;var t=e.getRangeAt(0).commonAncestorContainer;return o(this.div,t)},Zs.prototype.focus=function(){"nocursor"!=this.cm.options.readOnly&&(this.selectionInEditor()||this.showSelection(this.prepareSelection(),!0),this.div.focus())},Zs.prototype.blur=function(){this.div.blur()},Zs.prototype.getField=function(){return this.div},Zs.prototype.supportsTouch=function(){return!0},Zs.prototype.receivedFocus=function(){function e(){t.cm.state.focused&&(t.pollSelection(),t.polling.set(t.cm.options.pollInterval,e))}var t=this;this.selectionInEditor()?this.pollSelection():hn(this.cm,function(){return t.cm.curOp.selectionChanged=!0}),this.polling.set(this.cm.options.pollInterval,e)},Zs.prototype.selectionChanged=function(){var e=window.getSelection();return e.anchorNode!=this.lastAnchorNode||e.anchorOffset!=this.lastAnchorOffset||e.focusNode!=this.lastFocusNode||e.focusOffset!=this.lastFocusOffset},Zs.prototype.pollSelection=function(){if(null==this.readDOMTimeout&&!this.gracePeriod&&this.selectionChanged()){var e=window.getSelection(),t=this.cm;if(kl&&bl&&this.cm.options.gutters.length&&il(e.anchorNode))return this.cm.triggerOnKeyDown({type:"keydown",keyCode:8,preventDefault:Math.abs}),this.blur(),void this.focus();if(!this.composing){this.rememberSelection();var r=sl(t,e.anchorNode,e.anchorOffset),n=sl(t,e.focusNode,e.focusOffset);r&&n&&hn(t,function(){bi(t.doc,Rn(r,n),Gl),(r.bad||n.bad)&&(t.curOp.selectionChanged=!0)})}}},Zs.prototype.pollContent=function(){null!=this.readDOMTimeout&&(clearTimeout(this.readDOMTimeout),this.readDOMTimeout=null);var e=this.cm,t=e.display,r=e.doc.sel.primary(),n=r.from(),i=r.to();if(0==n.ch&&n.line>e.firstLine()&&(n=E(n.line-1,M(e.doc,n.line-1).length)),i.ch==M(e.doc,i.line).text.length&&i.line<e.lastLine()&&(i=E(i.line+1,0)),n.line<t.viewFrom||i.line>t.viewTo-1)return!1;var o,l,s;n.line==t.viewFrom||0==(o=Lr(e,n.line))?(l=W(t.view[0].line),s=t.view[0].node):(l=W(t.view[o].line),s=t.view[o-1].node.nextSibling);var a,u,c=Lr(e,i.line);if(c==t.view.length-1?(a=t.viewTo-1,u=t.lineDiv.lastChild):(a=W(t.view[c+1].line)-1,u=t.view[c+1].node.previousSibling),!s)return!1;for(var f=e.doc.splitLines(ll(e,s,u,l,a)),h=N(e.doc,E(l,0),E(a,M(e.doc,a).text.length));f.length>1&&h.length>1;)if(g(f)==g(h))f.pop(),h.pop(),a--;else{if(f[0]!=h[0])break;f.shift(),h.shift(),l++}for(var d=0,p=0,v=f[0],m=h[0],y=Math.min(v.length,m.length);d<y&&v.charCodeAt(d)==m.charCodeAt(d);)++d;for(var b=g(f),w=g(h),x=Math.min(b.length-(1==f.length?d:0),w.length-(1==h.length?d:0));p<x&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)++p;if(1==f.length&&1==h.length&&l==n.line)for(;d&&d>n.ch&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)d--,p++;f[f.length-1]=b.slice(0,b.length-p).replace(/^\u200b+/,""),f[0]=f[0].slice(d).replace(/\u200b+$/,"");var C=E(l,d),S=E(a,h.length?g(h).length-p:0);return f.length>1||f[0]||P(C,S)?(Ei(e.doc,f,C,S,"+input"),!0):void 0},Zs.prototype.ensurePolled=function(){this.forceCompositionEnd()},Zs.prototype.reset=function(){this.forceCompositionEnd()},Zs.prototype.forceCompositionEnd=function(){this.composing&&(clearTimeout(this.readDOMTimeout),this.composing=null,this.updateFromDOM(),this.div.blur(),this.div.focus())},Zs.prototype.readFromDOMSoon=function(){var e=this;null==this.readDOMTimeout&&(this.readDOMTimeout=setTimeout(function(){if(e.readDOMTimeout=null,e.composing){if(!e.composing.done)return;e.composing=null}e.updateFromDOM()},80))},Zs.prototype.updateFromDOM=function(){var e=this;!this.cm.isReadOnly()&&this.pollContent()||hn(this.cm,function(){return vn(e.cm)})},Zs.prototype.setUneditable=function(e){e.contentEditable="false"},Zs.prototype.onKeyPress=function(e){0!=e.charCode&&(e.preventDefault(),this.cm.isReadOnly()||dn(this.cm,$o)(this.cm,String.fromCharCode(null==e.charCode?e.keyCode:e.charCode),0))},Zs.prototype.readOnlyChanged=function(e){this.div.contentEditable=String("nocursor"!=e)},Zs.prototype.onContextMenu=function(){},Zs.prototype.resetPosition=function(){},Zs.prototype.needsContentAttribute=!0;var Qs=function(e){this.cm=e,this.prevInput="",this.pollingFast=!1,this.polling=new Pl,this.hasSelection=!1,this.composing=null};Qs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()});else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type?i.setSelections(t.ranges,null,Gl):(n.prevInput="",l.value=t.text.join("\n"),El(l))}"cut"==e.type&&(i.state.cutIncoming=!0)}}var r=this,n=this,i=this.cm,o=this.wrapper=el(),l=this.textarea=o.firstChild;e.wrapper.insertBefore(o,e.wrapper.firstChild),Ll&&(l.style.width="0px"),Ql(l,"input",function(){gl&&vl>=9&&r.hasSelection&&(r.hasSelection=null),n.poll()}),Ql(l,"paste",function(e){Me(i,e)||qo(e,i)||(i.state.pasteIncoming=!0,n.fastPoll())}),Ql(l,"cut",t),Ql(l,"copy",t),Ql(e.scroller,"paste",function(t){Ft(e,t)||Me(i,t)||(i.state.pasteIncoming=!0,n.focus())}),Ql(e.lineSpace,"selectstart",function(t){Ft(e,t)||We(t)}),Ql(l,"compositionstart",function(){var e=i.getCursor("from");n.composing&&n.composing.range.clear(),n.composing={start:e,range:i.markText(e,i.getCursor("to"),{className:"CodeMirror-composing"})}}),Ql(l,"compositionend",function(){n.composing&&(n.poll(),n.composing.range.clear(),n.composing=null)})},Qs.prototype.prepareSelection=function(){var e=this.cm,t=e.display,r=e.doc,n=Tr(e);if(e.options.moveInputWithCursor){var i=sr(e,r.sel.primary().head,"div"),o=t.wrapper.getBoundingClientRect(),l=t.lineDiv.getBoundingClientRect();n.teTop=Math.max(0,Math.min(t.wrapper.clientHeight-10,i.top+l.top-o.top)),n.teLeft=Math.max(0,Math.min(t.wrapper.clientWidth-10,i.left+l.left-o.left))}return n},Qs.prototype.showSelection=function(e){var t=this.cm.display;r(t.cursorDiv,e.cursors),r(t.selectionDiv,e.selection),null!=e.teTop&&(this.wrapper.style.top=e.teTop+"px",this.wrapper.style.left=e.teLeft+"px")},Qs.prototype.reset=function(e){if(!this.contextMenuPending&&!this.composing){var t=this.cm;if(t.somethingSelected()){this.prevInput="";var r=t.getSelection();this.textarea.value=r,t.state.focused&&El(this.textarea),gl&&vl>=9&&(this.hasSelection=r)}else e||(this.prevInput=this.textarea.value="",gl&&vl>=9&&(this.hasSelection=null))}},Qs.prototype.getField=function(){return this.textarea},Qs.prototype.supportsTouch=function(){return!1},Qs.prototype.focus=function(){if("nocursor"!=this.cm.options.readOnly&&(!Tl||l()!=this.textarea))try{this.textarea.focus()}catch(e){}},Qs.prototype.blur=function(){this.textarea.blur()},Qs.prototype.resetPosition=function(){this.wrapper.style.top=this.wrapper.style.left=0},Qs.prototype.receivedFocus=function(){this.slowPoll()},Qs.prototype.slowPoll=function(){var e=this;this.pollingFast||this.polling.set(this.cm.options.pollInterval,function(){e.poll(),e.cm.state.focused&&e.slowPoll()})},Qs.prototype.fastPoll=function(){function e(){r.poll()||t?(r.pollingFast=!1,r.slowPoll()):(t=!0,r.polling.set(60,e))}var t=!1,r=this;r.pollingFast=!0,r.polling.set(20,e)},Qs.prototype.poll=function(){var e=this,t=this.cm,r=this.textarea,n=this.prevInput;if(this.contextMenuPending||!t.state.focused||ts(r)&&!n&&!this.composing||t.isReadOnly()||t.options.disableInput||t.state.keySeq)return!1;var i=r.value;if(i==n&&!t.somethingSelected())return!1;if(gl&&vl>=9&&this.hasSelection===i||Ml&&/[\uf700-\uf7ff]/.test(i))return t.display.input.reset(),!1;if(t.doc.sel==t.display.selForContextMenu){var o=i.charCodeAt(0);if(8203!=o||n||(n="​"),8666==o)return this.reset(),this.cm.execCommand("undo")}for(var l=0,s=Math.min(n.length,i.length);l<s&&n.charCodeAt(l)==i.charCodeAt(l);)++l;return hn(t,function(){$o(t,i.slice(l),n.length-l,null,e.composing?"*compose":null),i.length>1e3||i.indexOf("\n")>-1?r.value=e.prevInput="":e.prevInput=i,e.composing&&(e.composing.range.clear(),e.composing.range=t.markText(e.composing.start,t.getCursor("to"),{className:"CodeMirror-composing"}))}),!0},Qs.prototype.ensurePolled=function(){this.pollingFast&&this.poll()&&(this.pollingFast=!1)},Qs.prototype.onKeyPress=function(){gl&&vl>=9&&(this.hasSelection=null),this.fastPoll()},Qs.prototype.onContextMenu=function(e){function t(){if(null!=l.selectionStart){var e=i.somethingSelected(),t="​"+(e?l.value:"");l.value="⇚",l.value=t,n.prevInput=e?"":"​",l.selectionStart=1,l.selectionEnd=t.length,o.selForContextMenu=i.doc.sel}}function r(){if(n.contextMenuPending=!1,n.wrapper.style.cssText=c,l.style.cssText=u,gl&&vl<9&&o.scrollbars.setScrollTop(o.scroller.scrollTop=a),null!=l.selectionStart){(!gl||gl&&vl<9)&&t();var e=0,r=function(){o.selForContextMenu==i.doc.sel&&0==l.selectionStart&&l.selectionEnd>0&&"​"==n.prevInput?dn(i,Mi)(i):e++<10?o.detectingSelectAll=setTimeout(r,500):(o.selForContextMenu=null,o.input.reset())};o.detectingSelectAll=setTimeout(r,200)}}var n=this,i=n.cm,o=i.display,l=n.textarea,s=Sr(i,e),a=o.scroller.scrollTop;if(s&&!wl){i.options.resetSelectionOnContextMenu&&-1==i.doc.sel.contains(s)&&dn(i,bi)(i.doc,Rn(s),Gl);var u=l.style.cssText,c=n.wrapper.style.cssText;n.wrapper.style.cssText="position: absolute";var f=n.wrapper.getBoundingClientRect();l.style.cssText="position: absolute; width: 30px; height: 30px;\n      top: "+(e.clientY-f.top-5)+"px; left: "+(e.clientX-f.left-5)+"px;\n      z-index: 1000; background: "+(gl?"rgba(255, 255, 255, .05)":"transparent")+";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";var h;if(ml&&(h=window.scrollY),o.input.focus(),ml&&window.scrollTo(null,h),o.input.reset(),i.somethingSelected()||(l.value=n.prevInput=" "),n.contextMenuPending=!0,o.selForContextMenu=i.doc.sel,clearTimeout(o.detectingSelectAll),gl&&vl>=9&&t(),Hl){Fe(e);var d=function(){ke(window,"mouseup",d),setTimeout(r,20)};Ql(window,"mouseup",d)}else setTimeout(r,50)}},Qs.prototype.readOnlyChanged=function(e){e||this.reset(),this.textarea.disabled="nocursor"==e},Qs.prototype.setUneditable=function(){},Qs.prototype.needsContentAttribute=!1,function(e){function t(t,n,i,o){e.defaults[t]=n,i&&(r[t]=o?function(e,t,r){r!=Xs&&i(e,t,r)}:i)}var r=e.optionHandlers;e.defineOption=t,e.Init=Xs,t("value","",function(e,t){return e.setValue(t)},!0),t("mode",null,function(e,t){e.doc.modeOption=t,jn(e)},!0),t("indentUnit",2,jn,!0),t("indentWithTabs",!1),t("smartIndent",!0),t("tabSize",4,function(e){Xn(e),er(e),vn(e)},!0),t("lineSeparator",null,function(e,t){if(e.doc.lineSep=t,t){var r=[],n=e.doc.first;e.doc.iter(function(e){for(var i=0;;){var o=e.text.indexOf(t,i);if(-1==o)break;i=o+t.length,r.push(E(n,o))}n++});for(var i=r.length-1;i>=0;i--)Ei(e.doc,t,r[i],E(r[i].line,r[i].ch+t.length))}}),t("specialChars",/[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff]/g,function(e,t,r){e.state.specialChars=new RegExp(t.source+(t.test("\t")?"":"|\t"),"g"),r!=Xs&&e.refresh()}),t("specialCharPlaceholder",at,function(e){return e.refresh()},!0),t("electricChars",!0),t("inputStyle",Tl?"contenteditable":"textarea",function(){throw new Error("inputStyle can not (yet) be changed in a running editor")},!0),t("spellcheck",!1,function(e,t){return e.getInputField().spellcheck=t},!0),t("rtlMoveVisually",!Ol),t("wholeLineUpdateBefore",!0),t("theme","default",function(e){Go(e),Uo(e)},!0),t("keyMap","default",function(e,t,r){var n=uo(t),i=r!=Xs&&uo(r);i&&i.detach&&i.detach(e,n),n.attach&&n.attach(e,i||null)}),t("extraKeys",null),t("configureMouse",null),t("lineWrapping",!1,Ko,!0),t("gutters",[],function(e){Fn(e.options),Uo(e)},!0),t("fixedGutter",!0,function(e,t){e.display.gutters.style.left=t?wr(e.display)+"px":"0",e.refresh()},!0),t("coverGutterNextToScrollbar",!1,function(e){return en(e)},!0),t("scrollbarStyle","native",function(e){rn(e),en(e),e.display.scrollbars.setScrollTop(e.doc.scrollTop),e.display.scrollbars.setScrollLeft(e.doc.scrollLeft)},!0),t("lineNumbers",!1,function(e){Fn(e.options),Uo(e)},!0),t("firstLineNumber",1,Uo,!0),t("lineNumberFormatter",function(e){return e},Uo,!0),t("showCursorWhenSelecting",!1,kr,!0),t("resetSelectionOnContextMenu",!0),t("lineWiseCopyCut",!0),t("pasteLinesPerSelection",!0),t("readOnly",!1,function(e,t){"nocursor"==t&&(Fr(e),e.display.input.blur()),e.display.input.readOnlyChanged(t)}),t("disableInput",!1,function(e,t){t||e.display.input.reset()},!0),t("dragDrop",!0,Vo),t("allowDropFileTypes",null),t("cursorBlinkRate",530),t("cursorScrollMargin",0),t("cursorHeight",1,kr,!0),t("singleCursorHeightPerLine",!0,kr,!0),t("workTime",100),t("workDelay",100),t("flattenSpans",!0,Xn,!0),t("addModeClass",!1,Xn,!0),t("pollInterval",100),t("undoDepth",200,function(e,t){return e.doc.history.undoDepth=t}),t("historyEventDelay",1250),t("viewportMargin",10,function(e){return e.refresh()},!0),t("maxHighlightLength",1e4,Xn,!0),t("moveInputWithCursor",!0,function(e,t){t||e.display.input.resetPosition()}),t("tabindex",null,function(e,t){return e.display.input.getField().tabIndex=t||""}),t("autofocus",null),t("direction","ltr",function(e,t){return e.doc.setDirection(t)},!0)}(jo),function(e){var t=e.optionHandlers,r=e.helpers={};e.prototype={constructor:e,focus:function(){window.focus(),this.display.input.focus()},setOption:function(e,r){var n=this.options,i=n[e];n[e]==r&&"mode"!=e||(n[e]=r,t.hasOwnProperty(e)&&dn(this,t[e])(this,r,i),Te(this,"optionChange",this,e))},getOption:function(e){return this.options[e]},getDoc:function(){return this.doc},addKeyMap:function(e,t){this.state.keyMaps[t?"push":"unshift"](uo(e))},removeKeyMap:function(e){for(var t=this.state.keyMaps,r=0;r<t.length;++r)if(t[r]==e||t[r].name==e)return t.splice(r,1),!0},addOverlay:pn(function(t,r){var n=t.token?t:e.getMode(this.options,t);if(n.startState)throw new Error("Overlays may not be stateful.");m(this.state.overlays,{mode:n,modeSpec:t,opaque:r&&r.opaque,priority:r&&r.priority||0},function(e){return e.priority}),this.state.modeGen++,vn(this)}),removeOverlay:pn(function(e){for(var t=this,r=this.state.overlays,n=0;n<r.length;++n){var i=r[n].modeSpec;if(i==e||"string"==typeof e&&i.name==e)return r.splice(n,1),t.state.modeGen++,void vn(t)}}),indentLine:pn(function(e,t,r){"string"!=typeof t&&"number"!=typeof t&&(t=null==t?this.options.smartIndent?"smart":"prev":t?"add":"subtract"),H(this.doc,e)&&Yo(this,e,t,r)}),indentSelection:pn(function(e){for(var t=this,r=this.doc.sel.ranges,n=-1,i=0;i<r.length;i++){var o=r[i];if(o.empty())o.head.line>n&&(Yo(t,o.head.line,e,!0),n=o.head.line,i==t.doc.sel.primIndex&&jr(t));else{var l=o.from(),s=o.to(),a=Math.max(n,l.line);n=Math.min(t.lastLine(),s.line-(s.ch?0:1))+1;for(var u=a;u<n;++u)Yo(t,u,e);var c=t.doc.sel.ranges;0==l.ch&&r.length==c.length&&c[i].from().ch>0&&gi(t.doc,i,new Ts(l,c[i].to()),Gl)}}}),getTokenAt:function(e,t){return Je(this,e,t)},getLineTokens:function(e,t){return Je(this,E(e),t,!0)},getTokenTypeAt:function(e){e=U(this.doc,e);var t,r=_e(this,M(this.doc,e.line)),n=0,i=(r.length-1)/2,o=e.ch;if(0==o)t=r[2];else for(;;){var l=n+i>>1;if((l?r[2*l-1]:0)>=o)i=l;else{if(!(r[2*l+1]<o)){t=r[2*l+2];break}n=l+1}}var s=t?t.indexOf("overlay "):-1;return s<0?t:0==s?null:t.slice(0,s-1)},getModeAt:function(t){var r=this.doc.mode;return r.innerMode?e.innerMode(r,this.getTokenAt(t).state).mode:r},getHelper:function(e,t){return this.getHelpers(e,t)[0]},getHelpers:function(e,t){var n=this,i=[];if(!r.hasOwnProperty(t))return i;var o=r[t],l=this.getModeAt(e);if("string"==typeof l[t])o[l[t]]&&i.push(o[l[t]]);else if(l[t])for(var s=0;s<l[t].length;s++){var a=o[l[t][s]];a&&i.push(a)}else l.helperType&&o[l.helperType]?i.push(o[l.helperType]):o[l.name]&&i.push(o[l.name]);for(var u=0;u<o._global.length;u++){var c=o._global[u];c.pred(l,n)&&-1==h(i,c.val)&&i.push(c.val)}return i},getStateAfter:function(e,t){var r=this.doc;return e=G(r,null==e?r.first+r.size-1:e),$e(this,e+1,t).state},cursorCoords:function(e,t){var r,n=this.doc.sel.primary();return r=null==e?n.head:"object"==typeof e?U(this.doc,e):e?n.from():n.to(),sr(this,r,t||"page")},charCoords:function(e,t){return lr(this,U(this.doc,e),t||"page")},coordsChar:function(e,t){return e=or(this,e,t||"page"),cr(this,e.left,e.top)},lineAtHeight:function(e,t){return e=or(this,{top:e,left:0},t||"page").top,D(this.doc,e+this.display.viewOffset)},heightAtLine:function(e,t,r){var n,i=!1;if("number"==typeof e){var o=this.doc.first+this.doc.size-1;e<this.doc.first?e=this.doc.first:e>o&&(e=o,i=!0),n=M(this.doc,e)}else n=e;return ir(this,n,{top:0,left:0},t||"page",r||i).top+(i?this.doc.height-ye(n):0)},defaultTextHeight:function(){return mr(this.display)},defaultCharWidth:function(){return yr(this.display)},getViewport:function(){return{from:this.display.viewFrom,to:this.display.viewTo}},addWidget:function(e,t,r,n,i){var o=this.display,l=(e=sr(this,U(this.doc,e))).bottom,s=e.left;if(t.style.position="absolute",t.setAttribute("cm-ignore-events","true"),this.display.input.setUneditable(t),o.sizer.appendChild(t),"over"==n)l=e.top;else if("above"==n||"near"==n){var a=Math.max(o.wrapper.clientHeight,this.doc.height),u=Math.max(o.sizer.clientWidth,o.lineSpace.clientWidth);("above"==n||e.bottom+t.offsetHeight>a)&&e.top>t.offsetHeight?l=e.top-t.offsetHeight:e.bottom+t.offsetHeight<=a&&(l=e.bottom),s+t.offsetWidth>u&&(s=u-t.offsetWidth)}t.style.top=l+"px",t.style.left=t.style.right="","right"==i?(s=o.sizer.clientWidth-t.offsetWidth,t.style.right="0px"):("left"==i?s=0:"middle"==i&&(s=(o.sizer.clientWidth-t.offsetWidth)/2),t.style.left=s+"px"),r&&Ur(this,{left:s,top:l,right:s+t.offsetWidth,bottom:l+t.offsetHeight})},triggerOnKeyDown:pn(Lo),triggerOnKeyPress:pn(Mo),triggerOnKeyUp:To,triggerOnMouseDown:pn(Oo),execCommand:function(e){if(Bs.hasOwnProperty(e))return Bs[e].call(null,this)},triggerElectric:pn(function(e){Zo(this,e)}),findPosH:function(e,t,r,n){var i=this,o=1;t<0&&(o=-1,t=-t);for(var l=U(this.doc,e),s=0;s<t&&!(l=tl(i.doc,l,o,r,n)).hitSide;++s);return l},moveH:pn(function(e,t){var r=this;this.extendSelectionsBy(function(n){return r.display.shift||r.doc.extend||n.empty()?tl(r.doc,n.head,e,t,r.options.rtlMoveVisually):e<0?n.from():n.to()},Vl)}),deleteH:pn(function(e,t){var r=this.doc.sel,n=this.doc;r.somethingSelected()?n.replaceSelection("",null,"+delete"):co(this,function(r){var i=tl(n,r.head,e,t,!1);return e<0?{from:i,to:r.head}:{from:r.head,to:i}})}),findPosV:function(e,t,r,n){var i=this,o=1,l=n;t<0&&(o=-1,t=-t);for(var s=U(this.doc,e),a=0;a<t;++a){var u=sr(i,s,"div");if(null==l?l=u.left:u.left=l,(s=rl(i,u,o,r)).hitSide)break}return s},moveV:pn(function(e,t){var r=this,n=this.doc,i=[],o=!this.display.shift&&!n.extend&&n.sel.somethingSelected();if(n.extendSelectionsBy(function(l){if(o)return e<0?l.from():l.to();var s=sr(r,l.head,"div");null!=l.goalColumn&&(s.left=l.goalColumn),i.push(s.left);var a=rl(r,s,e,t);return"page"==t&&l==n.sel.primary()&&Kr(r,lr(r,a,"div").top-s.top),a},Vl),i.length)for(var l=0;l<n.sel.ranges.length;l++)n.sel.ranges[l].goalColumn=i[l]}),findWordAt:function(e){var t=M(this.doc,e.line).text,r=e.ch,n=e.ch;if(t){var i=this.getHelper(e,"wordChars");"before"!=e.sticky&&n!=t.length||!r?++n:--r;for(var o=t.charAt(r),l=x(o,i)?function(e){return x(e,i)}:/\s/.test(o)?function(e){return/\s/.test(e)}:function(e){return!/\s/.test(e)&&!x(e)};r>0&&l(t.charAt(r-1));)--r;for(;n<t.length&&l(t.charAt(n));)++n}return new Ts(E(e.line,r),E(e.line,n))},toggleOverwrite:function(e){null!=e&&e==this.state.overwrite||((this.state.overwrite=!this.state.overwrite)?s(this.display.cursorDiv,"CodeMirror-overwrite"):Fl(this.display.cursorDiv,"CodeMirror-overwrite"),Te(this,"overwriteToggle",this,this.state.overwrite))},hasFocus:function(){return this.display.input.getField()==l()},isReadOnly:function(){return!(!this.options.readOnly&&!this.doc.cantEdit)},scrollTo:pn(function(e,t){Xr(this,e,t)}),getScrollInfo:function(){var e=this.display.scroller;return{left:e.scrollLeft,top:e.scrollTop,height:e.scrollHeight-zt(this)-this.display.barHeight,width:e.scrollWidth-zt(this)-this.display.barWidth,clientHeight:Bt(this),clientWidth:Rt(this)}},scrollIntoView:pn(function(e,t){null==e?(e={from:this.doc.sel.primary().head,to:null},null==t&&(t=this.options.cursorScrollMargin)):"number"==typeof e?e={from:E(e,0),to:null}:null==e.from&&(e={from:e,to:null}),e.to||(e.to=e.from),e.margin=t||0,null!=e.from.line?Yr(this,e):$r(this,e.from,e.to,e.margin)}),setSize:pn(function(e,t){var r=this,n=function(e){return"number"==typeof e||/^\d+$/.test(String(e))?e+"px":e};null!=e&&(this.display.wrapper.style.width=n(e)),null!=t&&(this.display.wrapper.style.height=n(t)),this.options.lineWrapping&&Jt(this);var i=this.display.viewFrom;this.doc.iter(i,this.display.viewTo,function(e){if(e.widgets)for(var t=0;t<e.widgets.length;t++)if(e.widgets[t].noHScroll){mn(r,i,"widget");break}++i}),this.curOp.forceUpdate=!0,Te(this,"refresh",this)}),operation:function(e){return hn(this,e)},startOperation:function(){return nn(this)},endOperation:function(){return on(this)},refresh:pn(function(){var e=this.display.cachedTextHeight;vn(this),this.curOp.forceUpdate=!0,er(this),Xr(this,this.doc.scrollLeft,this.doc.scrollTop),Wn(this),(null==e||Math.abs(e-mr(this.display))>.5)&&Cr(this),Te(this,"refresh",this)}),swapDoc:pn(function(e){var t=this.doc;return t.cm=null,qn(this,e),er(this),this.display.input.reset(),Xr(this,e.scrollLeft,e.scrollTop),this.curOp.forceScroll=!0,bt(this,"swapDoc",this,t),t}),getInputField:function(){return this.display.input.getField()},getWrapperElement:function(){return this.display.wrapper},getScrollerElement:function(){return this.display.scroller},getGutterElement:function(){return this.display.gutters}},Ae(e),e.registerHelper=function(t,n,i){r.hasOwnProperty(t)||(r[t]=e[t]={_global:[]}),r[t][n]=i},e.registerGlobalHelper=function(t,n,i,o){e.registerHelper(t,n,o),r[t]._global.push({pred:i,val:o})}}(jo);var Js="iter insert remove copy getEditor constructor".split(" ");for(var ea in Ds.prototype)Ds.prototype.hasOwnProperty(ea)&&h(Js,ea)<0&&(jo.prototype[ea]=function(e){return function(){return e.apply(this.doc,arguments)}}(Ds.prototype[ea]));return Ae(Ds),jo.inputStyles={textarea:Qs,contenteditable:Zs},jo.defineMode=function(e){jo.defaults.mode||"null"==e||(jo.defaults.mode=e),Be.apply(this,arguments)},jo.defineMIME=function(e,t){os[e]=t},jo.defineMode("null",function(){return{token:function(e){return e.skipToEnd()}}}),jo.defineMIME("text/plain","null"),jo.defineExtension=function(e,t){jo.prototype[e]=t},jo.defineDocExtension=function(e,t){Ds.prototype[e]=t},jo.fromTextArea=function(e,t){function r(){e.value=a.getValue()}if(t=t?c(t):{},t.value=e.value,!t.tabindex&&e.tabIndex&&(t.tabindex=e.tabIndex),!t.placeholder&&e.placeholder&&(t.placeholder=e.placeholder),null==t.autofocus){var n=l();t.autofocus=n==e||null!=e.getAttribute("autofocus")&&n==document.body}var i;if(e.form&&(Ql(e.form,"submit",r),!t.leaveSubmitMethodAlone)){var o=e.form;i=o.submit;try{var s=o.submit=function(){r(),o.submit=i,o.submit(),o.submit=s}}catch(e){}}t.finishInit=function(t){t.save=r,t.getTextArea=function(){return e},t.toTextArea=function(){t.toTextArea=isNaN,r(),e.parentNode.removeChild(t.getWrapperElement()),e.style.display="",e.form&&(ke(e.form,"submit",r),"function"==typeof e.form.submit&&(e.form.submit=i))}},e.style.display="none";var a=jo(function(t){return e.parentNode.insertBefore(t,e.nextSibling)},t);return a},function(e){e.off=ke,e.on=Ql,e.wheelEventPixels=Pn,e.Doc=Ds,e.splitLines=es,e.countColumn=f,e.findColumn=d,e.isWordChar=w,e.Pass=Bl,e.signal=Te,e.Line=fs,e.changeEnd=Bn,e.scrollbarModel=ws,e.Pos=E,e.cmpPos=P,e.modes=is,e.mimeModes=os,e.resolveMode=Ge,e.getMode=Ue,e.modeExtensions=ls,e.extendMode=Ve,e.copyState=Ke,e.startState=Xe,e.innerMode=je,e.commands=Bs,e.keyMap=Rs,e.keyName=ao,e.isModifierKey=lo,e.lookupKey=oo,e.normalizeKeyMap=io,e.StringStream=ss,e.SharedTextMarker=As,e.TextMarker=Os,e.LineWidget=Ms,e.e_preventDefault=We,e.e_stopPropagation=De,e.e_stop=Fe,e.addClass=s,e.contains=o,e.rmClass=Fl,e.keyNames=Es}(jo),jo.version="5.30.0",jo});
      !function(e){"object"==typeof exports&&"object"==typeof module?e(require("../../lib/codemirror")):"function"==typeof define&&define.amd?define(["../../lib/codemirror"],e):e(CodeMirror)}(function(e){"use strict";function t(e,t,n,r,o,a){this.indented=e,this.column=t,this.type=n,this.info=r,this.align=o,this.prev=a}function n(e,n,r,o){var a=e.indented;return e.context&&"statement"==e.context.type&&"statement"!=r&&(a=e.context.indented),e.context=new t(a,n,r,o,null,e.context)}function r(e){var t=e.context.type;return")"!=t&&"]"!=t&&"}"!=t||(e.indented=e.context.indented),e.context=e.context.prev}function o(e,t,n){return"variable"==t.prevToken||"type"==t.prevToken||(!!/\S(?:[^- ]>|[*\]])\s*$|\*$/.test(e.string.slice(0,n))||(!(!t.typeAtEndOfLine||e.column()!=e.indentation())||void 0))}function a(e){for(;;){if(!e||"top"==e.type)return!0;if("}"==e.type&&"namespace"!=e.prev.info)return!1;e=e.prev}}function i(e){for(var t={},n=e.split(" "),r=0;r<n.length;++r)t[n[r]]=!0;return t}function l(e,t){return"function"==typeof e?e(t):e.propertyIsEnumerable(t)}function s(e,t){if(!t.startOfLine)return!1;for(var n,r=null;n=e.peek();){if("\\"==n&&e.match(/^.$/)){r=s;break}if("/"==n&&e.match(/^\/[\/\*]/,!1))break;e.next()}return t.tokenize=r,"meta"}function c(e,t){return"type"==t.prevToken&&"type"}function u(e){return e.eatWhile(/[\w\.']/),"number"}function d(e,t){if(e.backUp(1),e.match(/(R|u8R|uR|UR|LR)/)){var n=e.match(/"([^\s\\()]{0,16})\(/);return!!n&&(t.cpp11RawStringDelim=n[1],t.tokenize=m,m(e,t))}return e.match(/(u8|u|U|L)/)?!!e.match(/["']/,!1)&&"string":(e.next(),!1)}function f(e){var t=/(\w+)::~?(\w+)$/.exec(e);return t&&t[1]==t[2]}function p(e,t){for(var n;null!=(n=e.next());)if('"'==n&&!e.eat('"')){t.tokenize=null;break}return"string"}function m(e,t){var n=t.cpp11RawStringDelim.replace(/[^\w\s]/g,"\\$&");return e.match(new RegExp(".*?\\)"+n+'"'))?t.tokenize=null:e.skipToEnd(),"string"}function h(t,n){function r(e){if(e)for(var t in e)e.hasOwnProperty(t)&&o.push(t)}"string"==typeof t&&(t=[t]);var o=[];r(n.keywords),r(n.types),r(n.builtin),r(n.atoms),o.length&&(n.helperType=t[0],e.registerHelper("hintWords",t[0],o));for(var a=0;a<t.length;++a)e.defineMIME(t[a],n)}function g(e,t){for(var n=!1;!e.eol();){if(!n&&e.match('"""')){t.tokenize=null;break}n="\\"==e.next()&&!n}return"string"}function y(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!e&&!o&&t.match('"')){a=!0;break}if(e&&t.match('"""')){a=!0;break}r=t.next(),!o&&"$"==r&&t.match("{")&&t.skipTo("}"),o=!o&&"\\"==r&&!e}return!a&&e||(n.tokenize=null),"string"}}function x(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!o&&t.match('"')&&("single"==e||t.match('""'))){a=!0;break}if(!o&&t.match("``")){w=x(e),a=!0;break}r=t.next(),o="single"==e&&!o&&"\\"==r}return a&&(n.tokenize=null),"string"}}e.defineMode("clike",function(i,s){function c(e,t){var n=e.next();if(S[n]){var r=S[n](e,t);if(!1!==r)return r}if('"'==n||"'"==n)return t.tokenize=u(n),t.tokenize(e,t);if(D.test(n))return p=n,null;if(L.test(n)){if(e.backUp(1),e.match(I))return"number";e.next()}if("/"==n){if(e.eat("*"))return t.tokenize=d,d(e,t);if(e.eat("/"))return e.skipToEnd(),"comment"}if(F.test(n)){for(;!e.match(/^\/[\/*]/,!1)&&e.eat(F););return"operator"}if(e.eatWhile(z),P)for(;e.match(P);)e.eatWhile(z);var o=e.current();return l(x,o)?(l(w,o)&&(p="newstatement"),l(v,o)&&(m=!0),"keyword"):l(b,o)?"type":l(k,o)?(l(w,o)&&(p="newstatement"),"builtin"):l(_,o)?"atom":"variable"}function u(e){return function(t,n){for(var r,o=!1,a=!1;null!=(r=t.next());){if(r==e&&!o){a=!0;break}o=!o&&"\\"==r}return(a||!o&&!C)&&(n.tokenize=null),"string"}}function d(e,t){for(var n,r=!1;n=e.next();){if("/"==n&&r){t.tokenize=null;break}r="*"==n}return"comment"}function f(e,t){s.typeFirstDefinitions&&e.eol()&&a(t.context)&&(t.typeAtEndOfLine=o(e,t,e.pos))}var p,m,h=i.indentUnit,g=s.statementIndentUnit||h,y=s.dontAlignCalls,x=s.keywords||{},b=s.types||{},k=s.builtin||{},w=s.blockKeywords||{},v=s.defKeywords||{},_=s.atoms||{},S=s.hooks||{},C=s.multiLineStrings,T=!1!==s.indentStatements,M=!1!==s.indentSwitch,P=s.namespaceSeparator,D=s.isPunctuationChar||/[\[\]{}\(\),;\:\.]/,L=s.numberStart||/[\d\.]/,I=s.number||/^(?:0x[a-f\d]+|0b[01]+|(?:\d+\.?\d*|\.\d+)(?:e[-+]?\d+)?)(u|ll?|l|f)?/i,F=s.isOperatorChar||/[+\-*&%=<>!?|\/]/,z=s.isIdentifierChar||/[\w\$_\xa1-\uffff]/;return{startState:function(e){return{tokenize:null,context:new t((e||0)-h,0,"top",null,!1),indented:0,startOfLine:!0,prevToken:null}},token:function(e,t){var i=t.context;if(e.sol()&&(null==i.align&&(i.align=!1),t.indented=e.indentation(),t.startOfLine=!0),e.eatSpace())return f(e,t),null;p=m=null;var l=(t.tokenize||c)(e,t);if("comment"==l||"meta"==l)return l;if(null==i.align&&(i.align=!0),";"==p||":"==p||","==p&&e.match(/^\s*(?:\/\/.*)?$/,!1))for(;"statement"==t.context.type;)r(t);else if("{"==p)n(t,e.column(),"}");else if("["==p)n(t,e.column(),"]");else if("("==p)n(t,e.column(),")");else if("}"==p){for(;"statement"==i.type;)i=r(t);for("}"==i.type&&(i=r(t));"statement"==i.type;)i=r(t)}else p==i.type?r(t):T&&(("}"==i.type||"top"==i.type)&&";"!=p||"statement"==i.type&&"newstatement"==p)&&n(t,e.column(),"statement",e.current());if("variable"==l&&("def"==t.prevToken||s.typeFirstDefinitions&&o(e,t,e.start)&&a(t.context)&&e.match(/^\s*\(/,!1))&&(l="def"),S.token){var u=S.token(e,t,l);void 0!==u&&(l=u)}return"def"==l&&!1===s.styleDefs&&(l="variable"),t.startOfLine=!1,t.prevToken=m?"def":l||p,f(e,t),l},indent:function(t,n){if(t.tokenize!=c&&null!=t.tokenize||t.typeAtEndOfLine)return e.Pass;var r=t.context,o=n&&n.charAt(0);if("statement"==r.type&&"}"==o&&(r=r.prev),s.dontIndentStatements)for(;"statement"==r.type&&s.dontIndentStatements.test(r.info);)r=r.prev;if(S.indent){var a=S.indent(t,r,n);if("number"==typeof a)return a}var i=o==r.type,l=r.prev&&"switch"==r.prev.info;if(s.allmanIndentation&&/[{(]/.test(o)){for(;"top"!=r.type&&"}"!=r.type;)r=r.prev;return r.indented}return"statement"==r.type?r.indented+("{"==o?0:g):!r.align||y&&")"==r.type?")"!=r.type||i?r.indented+(i?0:h)+(i||!l||/^(?:case|default)\b/.test(n)?0:h):r.indented+g:r.column+(i?0:1)},electricInput:M?/^\s*(?:case .*?:|default:|\{\}?|\})$/:/^\s*[{}]$/,blockCommentStart:"/*",blockCommentEnd:"*/",lineComment:"//",fold:"brace"}});var b="auto if break case register continue return default do sizeof static else struct switch extern typedef union for goto while enum const volatile",k="int long char short double float unsigned signed void size_t ptrdiff_t";h(["text/x-csrc","text/x-c","text/x-chdr"],{name:"clike",keywords:i(b),types:i(k+" bool _Complex _Bool float_t double_t intptr_t intmax_t int8_t int16_t int32_t int64_t uintptr_t uintmax_t uint8_t uint16_t uint32_t uint64_t"),blockKeywords:i("case do else for if switch while struct"),defKeywords:i("struct"),typeFirstDefinitions:!0,atoms:i("null true false"),hooks:{"#":s,"*":c},modeProps:{fold:["brace","include"]}}),h(["text/x-c++src","text/x-c++hdr"],{name:"clike",keywords:i(b+" asm dynamic_cast namespace reinterpret_cast try explicit new static_cast typeid catch operator template typename class friend private this using const_cast inline public throw virtual delete mutable protected alignas alignof constexpr decltype nullptr noexcept thread_local final static_assert override"),types:i(k+" bool wchar_t"),blockKeywords:i("catch class do else finally for if struct switch try while"),defKeywords:i("class namespace struct enum union"),typeFirstDefinitions:!0,atoms:i("true false null"),dontIndentStatements:/^template$/,isIdentifierChar:/[\w\$_~\xa1-\uffff]/,hooks:{"#":s,"*":c,u:d,U:d,L:d,R:d,0:u,1:u,2:u,3:u,4:u,5:u,6:u,7:u,8:u,9:u,token:function(e,t,n){if("variable"==n&&"("==e.peek()&&(";"==t.prevToken||null==t.prevToken||"}"==t.prevToken)&&f(e.current()))return"def"}},namespaceSeparator:"::",modeProps:{fold:["brace","include"]}}),h("text/x-java",{name:"clike",keywords:i("abstract assert break case catch class const continue default do else enum extends final finally float for goto if implements import instanceof interface native new package private protected public return static strictfp super switch synchronized this throw throws transient try volatile while @interface"),types:i("byte short int long float double boolean char void Boolean Byte Character Double Float Integer Long Number Object Short String StringBuffer StringBuilder Void"),blockKeywords:i("catch class do else finally for if switch try while"),defKeywords:i("class interface package enum @interface"),typeFirstDefinitions:!0,atoms:i("true false null"),number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,hooks:{"@":function(e){return!e.match("interface",!1)&&(e.eatWhile(/[\w\$_]/),"meta")}},modeProps:{fold:["brace","import"]}}),h("text/x-csharp",{name:"clike",keywords:i("abstract as async await base break case catch checked class const continue default delegate do else enum event explicit extern finally fixed for foreach goto if implicit in interface internal is lock namespace new operator out override params private protected public readonly ref return sealed sizeof stackalloc static struct switch this throw try typeof unchecked unsafe using virtual void volatile while add alias ascending descending dynamic from get global group into join let orderby partial remove select set value var yield"),types:i("Action Boolean Byte Char DateTime DateTimeOffset Decimal Double Func Guid Int16 Int32 Int64 Object SByte Single String Task TimeSpan UInt16 UInt32 UInt64 bool byte char decimal double short int long object sbyte float string ushort uint ulong"),blockKeywords:i("catch class do else finally for foreach if struct switch try while"),defKeywords:i("class interface namespace struct var"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"@":function(e,t){return e.eat('"')?(t.tokenize=p,p(e,t)):(e.eatWhile(/[\w\$_]/),"meta")}}}),h("text/x-scala",{name:"clike",keywords:i("abstract case catch class def do else extends final finally for forSome if implicit import lazy match new null object override package private protected return sealed super this throw trait try type val var while with yield _ assert assume require print println printf readLine readBoolean readByte readShort readChar readInt readLong readFloat readDouble"),types:i("AnyVal App Application Array BufferedIterator BigDecimal BigInt Char Console Either Enumeration Equiv Error Exception Fractional Function IndexedSeq Int Integral Iterable Iterator List Map Numeric Nil NotNull Option Ordered Ordering PartialFunction PartialOrdering Product Proxy Range Responder Seq Serializable Set Specializable Stream StringBuilder StringContext Symbol Throwable Traversable TraversableOnce Tuple Unit Vector Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),multiLineStrings:!0,blockKeywords:i("catch class enum do else finally for forSome if match switch try while"),defKeywords:i("class enum def object package trait type val var"),atoms:i("true false null"),indentStatements:!1,indentSwitch:!1,isOperatorChar:/[+\-*&%=<>!?|\/#:@]/,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return!!e.match('""')&&(t.tokenize=g,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},"=":function(e,n){var r=n.context;return!("}"!=r.type||!r.align||!e.eat(">"))&&(n.context=new t(r.indented,r.column,r.type,r.info,null,r.prev),"operator")}},modeProps:{closeBrackets:{triples:'"'}}}),h("text/x-kotlin",{name:"clike",keywords:i("package as typealias class interface this super val var fun for is in This throw return break continue object if else while do try when !in !is as? file import where by get set abstract enum open inner override private public internal protected catch finally out final vararg reified dynamic companion constructor init sealed field property receiver param sparam lateinit data inline noinline tailrec external annotation crossinline const operator infix suspend"),types:i("Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),intendSwitch:!1,indentStatements:!1,multiLineStrings:!0,number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,blockKeywords:i("catch class do else finally for if where try while enum"),defKeywords:i("class val var object package interface fun"),atoms:i("true false null this"),hooks:{'"':function(e,t){return t.tokenize=y(e.match('""')),t.tokenize(e,t)}},modeProps:{closeBrackets:{triples:'"'}}}),h(["x-shader/x-vertex","x-shader/x-fragment"],{name:"clike",keywords:i("sampler1D sampler2D sampler3D samplerCube sampler1DShadow sampler2DShadow const attribute uniform varying break continue discard return for while do if else struct in out inout"),types:i("float int bool void vec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4 mat2 mat3 mat4"),blockKeywords:i("for while do if else struct"),builtin:i("radians degrees sin cos tan asin acos atan pow exp log exp2 sqrt inversesqrt abs sign floor ceil fract mod min max clamp mix step smoothstep length distance dot cross normalize ftransform faceforward reflect refract matrixCompMult lessThan lessThanEqual greaterThan greaterThanEqual equal notEqual any all not texture1D texture1DProj texture1DLod texture1DProjLod texture2D texture2DProj texture2DLod texture2DProjLod texture3D texture3DProj texture3DLod texture3DProjLod textureCube textureCubeLod shadow1D shadow2D shadow1DProj shadow2DProj shadow1DLod shadow2DLod shadow1DProjLod shadow2DProjLod dFdx dFdy fwidth noise1 noise2 noise3 noise4"),atoms:i("true false gl_FragColor gl_SecondaryColor gl_Normal gl_Vertex gl_MultiTexCoord0 gl_MultiTexCoord1 gl_MultiTexCoord2 gl_MultiTexCoord3 gl_MultiTexCoord4 gl_MultiTexCoord5 gl_MultiTexCoord6 gl_MultiTexCoord7 gl_FogCoord gl_PointCoord gl_Position gl_PointSize gl_ClipVertex gl_FrontColor gl_BackColor gl_FrontSecondaryColor gl_BackSecondaryColor gl_TexCoord gl_FogFragCoord gl_FragCoord gl_FrontFacing gl_FragData gl_FragDepth gl_ModelViewMatrix gl_ProjectionMatrix gl_ModelViewProjectionMatrix gl_TextureMatrix gl_NormalMatrix gl_ModelViewMatrixInverse gl_ProjectionMatrixInverse gl_ModelViewProjectionMatrixInverse gl_TexureMatrixTranspose gl_ModelViewMatrixInverseTranspose gl_ProjectionMatrixInverseTranspose gl_ModelViewProjectionMatrixInverseTranspose gl_TextureMatrixInverseTranspose gl_NormalScale gl_DepthRange gl_ClipPlane gl_Point gl_FrontMaterial gl_BackMaterial gl_LightSource gl_LightModel gl_FrontLightModelProduct gl_BackLightModelProduct gl_TextureColor gl_EyePlaneS gl_EyePlaneT gl_EyePlaneR gl_EyePlaneQ gl_FogParameters gl_MaxLights gl_MaxClipPlanes gl_MaxTextureUnits gl_MaxTextureCoords gl_MaxVertexAttribs gl_MaxVertexUniformComponents gl_MaxVaryingFloats gl_MaxVertexTextureImageUnits gl_MaxTextureImageUnits gl_MaxFragmentUniformComponents gl_MaxCombineTextureImageUnits gl_MaxDrawBuffers"),indentSwitch:!1,hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-nesc",{name:"clike",keywords:i(b+"as atomic async call command component components configuration event generic implementation includes interface module new norace nx_struct nx_union post provides signal task uses abstract extends"),types:i(k),blockKeywords:i("case do else for if switch while struct"),atoms:i("null true false"),hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-objectivec",{name:"clike",keywords:i(b+"inline restrict _Bool _Complex _Imaginary BOOL Class bycopy byref id IMP in inout nil oneway out Protocol SEL self super atomic nonatomic retain copy readwrite readonly"),types:i(k),atoms:i("YES NO NULL NILL ON OFF true false"),hooks:{"@":function(e){return e.eatWhile(/[\w\$]/),"keyword"},"#":s,indent:function(e,t,n){if("statement"==t.type&&/^@\w/.test(n))return t.indented}},modeProps:{fold:"brace"}}),h("text/x-squirrel",{name:"clike",keywords:i("base break clone continue const default delete enum extends function in class foreach local resume return this throw typeof yield constructor instanceof static"),types:i(k),blockKeywords:i("case catch class else for foreach if switch try while"),defKeywords:i("function local class"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"#":s},modeProps:{fold:["brace","include"]}});var w=null;h("text/x-ceylon",{name:"clike",keywords:i("abstracts alias assembly assert assign break case catch class continue dynamic else exists extends finally for function given if import in interface is let module new nonempty object of out outer package return satisfies super switch then this throw try value void while"),types:function(e){var t=e.charAt(0);return t===t.toUpperCase()&&t!==t.toLowerCase()},blockKeywords:i("case catch class dynamic else finally for function if interface module new object switch try while"),defKeywords:i("class dynamic function interface module object package value"),builtin:i("abstract actual aliased annotation by default deprecated doc final formal late license native optional sealed see serializable shared suppressWarnings tagged throws variable"),isPunctuationChar:/[\[\]{}\(\),;\:\.`]/,isOperatorChar:/[+\-*&%=<>!?|^~:\/]/,numberStart:/[\d#$]/,number:/^(?:#[\da-fA-F_]+|\$[01_]+|[\d_]+[kMGTPmunpf]?|[\d_]+\.[\d_]+(?:[eE][-+]?\d+|[kMGTPmunpf]|)|)/i,multiLineStrings:!0,typeFirstDefinitions:!0,atoms:i("true false null larger smaller equal empty finished"),indentSwitch:!1,styleDefs:!1,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return t.tokenize=x(e.match('""')?"triple":"single"),t.tokenize(e,t)},"`":function(e,t){return!(!w||!e.match("`"))&&(t.tokenize=w,w=null,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},token:function(e,t,n){if(("variable"==n||"type"==n)&&"."==t.prevToken)return"variable-2"}},modeProps:{fold:["brace","import"],closeBrackets:{triples:'"'}}})});
      // -------------------------------------------------------------------------
//  Part of the CodeChecker project, under the Apache License v2.0 with
//  LLVM Exceptions. See LICENSE for license information.
//  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
// -------------------------------------------------------------------------

var BugViewer = {
  _files : [],
  _reports : [],
  _lineWidgets : [],
  _navigationMenuItems : [],
  _sourceFileData : null,
  _currentReport : null,
  _lastBugEvent  : null,

  init : function (files, reports) {
    this._files = files;
    this._reports = reports;

    this.initEscapeChars();
  },

  initEscapeChars : function () {
    this.escapeChars = {
      ' ' : 'nbsp',
      '<' : 'lt',
      '>' : 'gt',
      '"' : 'quot',
      '&' : 'amp'
    };

    var regexString = '[';
    for (var key in this.escapeChars) {
      regexString += key;
    }
    regexString += ']';

    this.escapeRegExp = new RegExp( regexString, 'g');
  },

  escapeHTML : function (str) {
    var that = this;

    return str.replace(this.escapeRegExp, function (m) {
      return '&' + that.escapeChars[m] + ';';
    });
  },

  initByUrl : function () {
    if (!this._reports) return;

    var state = {};
    window.location.hash.substr(1).split('&').forEach(function (s) {
      var parts = s.split('=');
      state[parts[0]] = parts[1];
    });

    for (var key in this._reports) {
      var report = this._reports[key];
      if (report.reportHash === state['reportHash']) {
        this.navigate(report);
        return;
      }
    }

    this.navigate(this._reports[0]);
  },

  create : function () {
    this._content = document.getElementById('editor-wrapper');
    this._filepath = document.getElementById('file-path');
    this._checkerName = document.getElementById('checker-name');
    this._reviewStatusWrapper =
      document.getElementById('review-status-wrapper');
    this._reviewStatus = document.getElementById('review-status');
    this._editor = document.getElementById('editor');

    this._codeMirror = CodeMirror(this._editor, {
      mode: 'text/x-c++src',
      matchBrackets : true,
      lineNumbers : true,
      readOnly : true,
      foldGutter : true,
      extraKeys : {},
      viewportMargin : 100
    });

    this._createNavigationMenu();
  },

  navigate : function (report, item) {
    if (!item) {
      var items = this._navigationMenuItems.filter(function (navItem) {
        return navItem.report.reportHash === report.reportHash;
      });

      if (!items.length) return;

      item = items[0].widget;
    }

    this._selectedReport.classList.remove('active');
    this._selectedReport = item;
    this._selectedReport.classList.add('active');
    this.setReport(report);
  },

  _createNavigationMenu : function () {
    var that = this;

    var nav = document.getElementById('report-nav');
    var list = document.createElement('ul');
    this._reports.forEach(function (report) {
      var events = report['events'];
      var lastBugEvent = events[events.length - 1];
      var item = document.createElement('li');

      var severity = document.createElement('i');
      severity.className = 'severity-' + report.severity.toLowerCase();

      item.appendChild(severity);
      item.appendChild(document.createTextNode(lastBugEvent.message));

      item.addEventListener('click', function () {
        that.navigate(report, item);
      })
      list.appendChild(item);
      that._navigationMenuItems.push({ report : report, widget : item });
    });

    if (!this._selectedReport && list.childNodes.length) {
      this._selectedReport = list.childNodes[0];
      this._selectedReport.classList.add('active');
    }

    nav.appendChild(list);
  },

  setReport : function (report) {
    this._currentReport = report;
    var events = report['events'];
    var lastBugEvent = events[events.length - 1];
    this.setCurrentBugEvent(lastBugEvent, events.length - 1);
    this.setCheckerName(report.checkerName);
    this.setReviewStatus(report.reviewStatus);

    window.location.hash = '#reportHash=' + report.reportHash;
  },

  setCurrentBugEvent : function (event, idx) {
    this._currentBugEvent = event;
    this.setSourceFileData(this._files[event.location.file]);
    this.drawBugPath();

    this.jumpTo(event.location.line, 0);
    this.highlightBugEvent(event, idx);
  },

  highlightBugEvent : function (event, idx) {
    this._lineWidgets.forEach(function (widget) {
      var lineIdx = widget.node.getAttribute('idx');
      if (parseInt(lineIdx) === idx) {
        widget.node.classList.add('current');
      }
    });
  },

  setCheckerName : function (checkerName) {
    this._checkerName.innerHTML = checkerName;
  },

  setReviewStatus : function (status) {
    if (status) {
      var className =
        'review-status-' + status.toLowerCase().split(' ').join('-');
      this._reviewStatus.className = "review-status " + className;

      this._reviewStatus.innerHTML = status;
      this._reviewStatusWrapper.style.display = 'block';
    } else {
      this._reviewStatusWrapper.style.display = 'none';
    }
  },

  setSourceFileData : function (file) {
    if (this._sourceFileData && file.id === this._sourceFileData.id) {
      return;
    }

    this._sourceFileData = file;
    this._filepath.innerHTML = file.path;
    this._codeMirror.doc.setValue(file.content);
    this._refresh();
  },

  _refresh : function () {
    var that = this;
    setTimeout(function () {
      var fullHeight = parseInt(that._content.clientHeight);
      var headerHeight = that._filepath.clientHeight;

      that._codeMirror.setSize('auto', fullHeight - headerHeight);
      that._codeMirror.refresh();
    }, 200);
  },

  clearBubbles : function () {
    this._lineWidgets.forEach(function (widget) { widget.clear(); });
    this._lineWidgets = [];
  },

  getMessage : function (event, kind) {
    if (kind === 'macro') {
      var name = 'macro expansion' + (event.name ? ': ' + event.name : '');

      return '<span class="tag macro">' + name + '</span>'
        + this.escapeHTML(event.expansion).replace(/(?:\r\n|\r|\n)/g, '<br>');
    } else if (kind === 'note') {
      return '<span class="tag note">note</span>'
        +  this.escapeHTML(event.message).replace(/(?:\r\n|\r|\n)/g, '<br>');
    }
  },

  addExtraPathEvents : function (events, kind) {
    var that = this;

    if (!events) {
      return;
    }

    events.forEach(function (event) {
      if (event.location.file !== that._currentBugEvent.location.file) {
        return;
      }

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + kind);

      var msg = document.createElement('span');
      msg.innerHTML = that.getMessage(event, kind);
      element.appendChild(msg);

      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  drawBugPath : function () {
    var that = this;

    this.clearBubbles();

    this.addExtraPathEvents(this._currentReport.macros, 'macro');
    this.addExtraPathEvents(this._currentReport.notes, 'note');

    // Processing bug path events.
    var currentEvents = this._currentReport.events;
    currentEvents.forEach(function (event, step) {
      if (event.location.file !== that._currentBugEvent.location.file)
        return;

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';
      var type = step === currentEvents.length - 1 ? 'error' : 'info';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + type);
      element.setAttribute('idx', step);

      var enumeration = document.createElement('span');
      enumeration.setAttribute('class', 'checker-enum ' + type);
      enumeration.innerHTML = step + 1;

      if (currentEvents.length > 1)
        element.appendChild(enumeration);

      var prevBugEvent = step - 1;
      if (step > 0) {
        var prevBug = document.createElement('span');
        prevBug.setAttribute('class', 'arrow left-arrow');
        prevBug.addEventListener('click', function () {
          var event = currentEvents[prevBugEvent];
          that.setCurrentBugEvent(event, prevBugEvent);
        });
        element.appendChild(prevBug);
      }

      var msg = document.createElement('span');
      msg.innerHTML = that.escapeHTML(event.message)
        .replace(/(?:\r\n|\r|\n)/g, '<br>');

      element.appendChild(msg);

      var nextBugEvent = step + 1;
      if (nextBugEvent < currentEvents.length) {
        var nextBug = document.createElement('span');
        nextBug.setAttribute('class', 'arrow right-arrow');
        nextBug.addEventListener('click', function () {
          var event = currentEvents[nextBugEvent];
          that.setCurrentBugEvent(event, nextBugEvent);
        });
        element.appendChild(nextBug);
      }


      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  jumpTo : function (line, column) {
    var that = this;

    setTimeout(function () {
      var selPosPixel
        = that._codeMirror.charCoords({ line : line, ch : column }, 'local');
      var editorSize = {
        width  : that._editor.clientWidth,
        height : that._editor.clientHeight
      };

      that._codeMirror.scrollIntoView({
        top    : selPosPixel.top - 100,
        bottom : selPosPixel.top + editorSize.height - 150,
        left   : selPosPixel.left < editorSize.width - 100
               ? 0
               : selPosPixel.left - 50,
        right  : selPosPixel.left < editorSize.width - 100
               ? 10
               : selPosPixel.left + editorSize.width - 100
      });
    }, 0);
  }
}


      var data = {"files": {"4": {"id": 4, "path": "/home/vsts/work/1/llvm-project/llvm/tools/llvm-readobj/ARMEHABIPrinter.h", "content": "//===--- ARMEHABIPrinter.h - ARM EHABI Unwind Information Printer ----------===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_TOOLS_LLVM_READOBJ_ARMEHABIPRINTER_H\n#define LLVM_TOOLS_LLVM_READOBJ_ARMEHABIPRINTER_H\n\n#include \"llvm-readobj.h\"\n#include \"llvm/ADT/STLExtras.h\"\n#include \"llvm/Object/ELF.h\"\n#include \"llvm/Object/ELFTypes.h\"\n#include \"llvm/Support/ARMEHABI.h\"\n#include \"llvm/Support/Debug.h\"\n#include \"llvm/Support/Endian.h\"\n#include \"llvm/Support/Format.h\"\n#include \"llvm/Support/ScopedPrinter.h\"\n#include \"llvm/Support/type_traits.h\"\n\nnamespace llvm {\nnamespace ARM {\nnamespace EHABI {\n\nclass OpcodeDecoder {\n  ScopedPrinter &SW;\n  raw_ostream &OS;\n\n  struct RingEntry {\n    uint8_t Mask;\n    uint8_t Value;\n    void (OpcodeDecoder::*Routine)(const uint8_t *Opcodes, unsigned &OI);\n  };\n  static ArrayRef<RingEntry> ring();\n\n  void Decode_00xxxxxx(const uint8_t *Opcodes, unsigned &OI);\n  void Decode_01xxxxxx(const uint8_t *Opcodes, unsigned &OI);\n  void Decode_1000iiii_iiiiiiii(const uint8_t *Opcodes, unsigned &OI);\n  void Decode_10011101(const uint8_t *Opcodes, unsigned &OI);\n  void Decode_10011111(const uint8_t *Opcodes, unsigned &OI);\n  void Decode_1001nnnn(const uint8_t *Opcodes, unsigned &OI);\n  void Decode_10100nnn(const uint8_t *Opcodes, unsigned &OI);\n  void Decode_10101nnn(const uint8_t *Opcodes, unsigned &OI);\n  void Decode_10110000(const uint8_t *Opcodes, unsigned &OI);\n  void Decode_10110001_0000iiii(const uint8_t *Opcodes, unsigned &OI);\n  void Decode_10110010_uleb128(const uint8_t *Opcodes, unsigned &OI);\n  void Decode_10110011_sssscccc(const uint8_t *Opcodes, unsigned &OI);\n  void Decode_101101nn(const uint8_t *Opcodes, unsigned &OI);\n  void Decode_10111nnn(const uint8_t *Opcodes, unsigned &OI);\n  void Decode_11000110_sssscccc(const uint8_t *Opcodes, unsigned &OI);\n  void Decode_11000111_0000iiii(const uint8_t *Opcodes, unsigned &OI);\n  void Decode_11001000_sssscccc(const uint8_t *Opcodes, unsigned &OI);\n  void Decode_11001001_sssscccc(const uint8_t *Opcodes, unsigned &OI);\n  void Decode_11001yyy(const uint8_t *Opcodes, unsigned &OI);\n  void Decode_11000nnn(const uint8_t *Opcodes, unsigned &OI);\n  void Decode_11010nnn(const uint8_t *Opcodes, unsigned &OI);\n  void Decode_11xxxyyy(const uint8_t *Opcodes, unsigned &OI);\n\n  void PrintGPR(uint16_t GPRMask);\n  void PrintRegisters(uint32_t Mask, StringRef Prefix);\n\npublic:\n  OpcodeDecoder(ScopedPrinter &SW) : SW(SW), OS(SW.getOStream()) {}\n  void Decode(const uint8_t *Opcodes, off_t Offset, size_t Length);\n};\n\ninline ArrayRef<OpcodeDecoder::RingEntry> OpcodeDecoder::ring() {\n  static const OpcodeDecoder::RingEntry Ring[] = {\n      {0xc0, 0x00, &OpcodeDecoder::Decode_00xxxxxx},\n      {0xc0, 0x40, &OpcodeDecoder::Decode_01xxxxxx},\n      {0xf0, 0x80, &OpcodeDecoder::Decode_1000iiii_iiiiiiii},\n      {0xff, 0x9d, &OpcodeDecoder::Decode_10011101},\n      {0xff, 0x9f, &OpcodeDecoder::Decode_10011111},\n      {0xf0, 0x90, &OpcodeDecoder::Decode_1001nnnn},\n      {0xf8, 0xa0, &OpcodeDecoder::Decode_10100nnn},\n      {0xf8, 0xa8, &OpcodeDecoder::Decode_10101nnn},\n      {0xff, 0xb0, &OpcodeDecoder::Decode_10110000},\n      {0xff, 0xb1, &OpcodeDecoder::Decode_10110001_0000iiii},\n      {0xff, 0xb2, &OpcodeDecoder::Decode_10110010_uleb128},\n      {0xff, 0xb3, &OpcodeDecoder::Decode_10110011_sssscccc},\n      {0xfc, 0xb4, &OpcodeDecoder::Decode_101101nn},\n      {0xf8, 0xb8, &OpcodeDecoder::Decode_10111nnn},\n      {0xff, 0xc6, &OpcodeDecoder::Decode_11000110_sssscccc},\n      {0xff, 0xc7, &OpcodeDecoder::Decode_11000111_0000iiii},\n      {0xff, 0xc8, &OpcodeDecoder::Decode_11001000_sssscccc},\n      {0xff, 0xc9, &OpcodeDecoder::Decode_11001001_sssscccc},\n      {0xc8, 0xc8, &OpcodeDecoder::Decode_11001yyy},\n      {0xf8, 0xc0, &OpcodeDecoder::Decode_11000nnn},\n      {0xf8, 0xd0, &OpcodeDecoder::Decode_11010nnn},\n      {0xc0, 0xc0, &OpcodeDecoder::Decode_11xxxyyy},\n  };\n  return makeArrayRef(Ring);\n}\n\ninline void OpcodeDecoder::Decode_00xxxxxx(const uint8_t *Opcodes,\n                                           unsigned &OI) {\n  uint8_t Opcode = Opcodes[OI++ ^ 3];\n  SW.startLine() << format(\"0x%02X      ; vsp = vsp + %u\\n\", Opcode,\n                           ((Opcode & 0x3f) << 2) + 4);\n}\ninline void OpcodeDecoder::Decode_01xxxxxx(const uint8_t *Opcodes,\n                                           unsigned &OI) {\n  uint8_t Opcode = Opcodes[OI++ ^ 3];\n  SW.startLine() << format(\"0x%02X      ; vsp = vsp - %u\\n\", Opcode,\n                           ((Opcode & 0x3f) << 2) + 4);\n}\ninline void OpcodeDecoder::Decode_1000iiii_iiiiiiii(const uint8_t *Opcodes,\n                                                    unsigned &OI) {\n  uint8_t Opcode0 = Opcodes[OI++ ^ 3];\n  uint8_t Opcode1 = Opcodes[OI++ ^ 3];\n\n  uint16_t GPRMask = (Opcode1 << 4) | ((Opcode0 & 0x0f) << 12);\n  SW.startLine()\n    << format(\"0x%02X 0x%02X ; %s\",\n              Opcode0, Opcode1, GPRMask ? \"pop \" : \"refuse to unwind\");\n  if (GPRMask)\n    PrintGPR(GPRMask);\n  OS << '\\n';\n}\ninline void OpcodeDecoder::Decode_10011101(const uint8_t *Opcodes,\n                                           unsigned &OI) {\n  uint8_t Opcode = Opcodes[OI++ ^ 3];\n  SW.startLine() << format(\"0x%02X      ; reserved (ARM MOVrr)\\n\", Opcode);\n}\ninline void OpcodeDecoder::Decode_10011111(const uint8_t *Opcodes,\n                                           unsigned &OI) {\n  uint8_t Opcode = Opcodes[OI++ ^ 3];\n  SW.startLine() << format(\"0x%02X      ; reserved (WiMMX MOVrr)\\n\", Opcode);\n}\ninline void OpcodeDecoder::Decode_1001nnnn(const uint8_t *Opcodes,\n                                           unsigned &OI) {\n  uint8_t Opcode = Opcodes[OI++ ^ 3];\n  SW.startLine() << format(\"0x%02X      ; vsp = r%u\\n\", Opcode, (Opcode & 0x0f));\n}\ninline void OpcodeDecoder::Decode_10100nnn(const uint8_t *Opcodes,\n                                           unsigned &OI) {\n  uint8_t Opcode = Opcodes[OI++ ^ 3];\n  SW.startLine() << format(\"0x%02X      ; pop \", Opcode);\n  PrintGPR((((1 << ((Opcode & 0x7) + 1)) - 1) << 4));\n  OS << '\\n';\n}\ninline void OpcodeDecoder::Decode_10101nnn(const uint8_t *Opcodes,\n                                           unsigned &OI) {\n  uint8_t Opcode = Opcodes[OI++ ^ 3];\n  SW.startLine() << format(\"0x%02X      ; pop \", Opcode);\n  PrintGPR((((1 << ((Opcode & 0x7) + 1)) - 1) << 4) | (1 << 14));\n  OS << '\\n';\n}\ninline void OpcodeDecoder::Decode_10110000(const uint8_t *Opcodes,\n                                           unsigned &OI) {\n  uint8_t Opcode = Opcodes[OI++ ^ 3];\n  SW.startLine() << format(\"0x%02X      ; finish\\n\", Opcode);\n}\ninline void OpcodeDecoder::Decode_10110001_0000iiii(const uint8_t *Opcodes,\n                                                    unsigned &OI) {\n  uint8_t Opcode0 = Opcodes[OI++ ^ 3];\n  uint8_t Opcode1 = Opcodes[OI++ ^ 3];\n\n  SW.startLine()\n    << format(\"0x%02X 0x%02X ; %s\", Opcode0, Opcode1,\n              ((Opcode1 & 0xf0) || Opcode1 == 0x00) ? \"spare\" : \"pop \");\n  if (((Opcode1 & 0xf0) == 0x00) && Opcode1)\n    PrintGPR((Opcode1 & 0x0f));\n  OS << '\\n';\n}\ninline void OpcodeDecoder::Decode_10110010_uleb128(const uint8_t *Opcodes,\n                                                   unsigned &OI) {\n  uint8_t Opcode = Opcodes[OI++ ^ 3];\n  SW.startLine() << format(\"0x%02X \", Opcode);\n\n  SmallVector<uint8_t, 4> ULEB;\n  do { ULEB.push_back(Opcodes[OI ^ 3]); } while (Opcodes[OI++ ^ 3] & 0x80);\n\n  for (unsigned BI = 0, BE = ULEB.size(); BI != BE; ++BI)\n    OS << format(\"0x%02X \", ULEB[BI]);\n\n  uint64_t Value = 0;\n  for (unsigned BI = 0, BE = ULEB.size(); BI != BE; ++BI)\n    Value = Value | ((ULEB[BI] & 0x7f) << (7 * BI));\n\n  OS << format(\"; vsp = vsp + %\" PRIu64 \"\\n\", 0x204 + (Value << 2));\n}\ninline void OpcodeDecoder::Decode_10110011_sssscccc(const uint8_t *Opcodes,\n                                                    unsigned &OI) {\n  uint8_t Opcode0 = Opcodes[OI++ ^ 3];\n  uint8_t Opcode1 = Opcodes[OI++ ^ 3];\n  SW.startLine() << format(\"0x%02X 0x%02X ; pop \", Opcode0, Opcode1);\n  uint8_t Start = ((Opcode1 & 0xf0) >> 4);\n  uint8_t Count = ((Opcode1 & 0x0f) >> 0);\n  PrintRegisters((((1 << (Count + 1)) - 1) << Start), \"d\");\n  OS << '\\n';\n}\ninline void OpcodeDecoder::Decode_101101nn(const uint8_t *Opcodes,\n                                           unsigned &OI) {\n  uint8_t Opcode = Opcodes[OI++ ^ 3];\n  SW.startLine() << format(\"0x%02X      ; spare\\n\", Opcode);\n}\ninline void OpcodeDecoder::Decode_10111nnn(const uint8_t *Opcodes,\n                                           unsigned &OI) {\n  uint8_t Opcode = Opcodes[OI++ ^ 3];\n  SW.startLine() << format(\"0x%02X      ; pop \", Opcode);\n  PrintRegisters((((1 << ((Opcode & 0x07) + 1)) - 1) << 8), \"d\");\n  OS << '\\n';\n}\ninline void OpcodeDecoder::Decode_11000110_sssscccc(const uint8_t *Opcodes,\n                                                    unsigned &OI) {\n  uint8_t Opcode0 = Opcodes[OI++ ^ 3];\n  uint8_t Opcode1 = Opcodes[OI++ ^ 3];\n  SW.startLine() << format(\"0x%02X 0x%02X ; pop \", Opcode0, Opcode1);\n  uint8_t Start = ((Opcode1 & 0xf0) >> 4);\n  uint8_t Count = ((Opcode1 & 0x0f) >> 0);\n  PrintRegisters((((1 << (Count + 1)) - 1) << Start), \"wR\");\n  OS << '\\n';\n}\ninline void OpcodeDecoder::Decode_11000111_0000iiii(const uint8_t *Opcodes,\n                                                    unsigned &OI) {\n  uint8_t Opcode0 = Opcodes[OI++ ^ 3];\n  uint8_t Opcode1 = Opcodes[OI++ ^ 3];\n  SW.startLine()\n    << format(\"0x%02X 0x%02X ; %s\", Opcode0, Opcode1,\n              ((Opcode1 & 0xf0) || Opcode1 == 0x00) ? \"spare\" : \"pop \");\n  if ((Opcode1 & 0xf0) == 0x00 && Opcode1)\n      PrintRegisters(Opcode1 & 0x0f, \"wCGR\");\n  OS << '\\n';\n}\ninline void OpcodeDecoder::Decode_11001000_sssscccc(const uint8_t *Opcodes,\n                                                    unsigned &OI) {\n  uint8_t Opcode0 = Opcodes[OI++ ^ 3];\n  uint8_t Opcode1 = Opcodes[OI++ ^ 3];\n  SW.startLine() << format(\"0x%02X 0x%02X ; pop \", Opcode0, Opcode1);\n  uint8_t Start = 16 + ((Opcode1 & 0xf0) >> 4);\n  uint8_t Count = ((Opcode1 & 0x0f) >> 0);\n  PrintRegisters((((1 << (Count + 1)) - 1) << Start), \"d\");\n  OS << '\\n';\n}\ninline void OpcodeDecoder::Decode_11001001_sssscccc(const uint8_t *Opcodes,\n                                                    unsigned &OI) {\n  uint8_t Opcode0 = Opcodes[OI++ ^ 3];\n  uint8_t Opcode1 = Opcodes[OI++ ^ 3];\n  SW.startLine() << format(\"0x%02X 0x%02X ; pop \", Opcode0, Opcode1);\n  uint8_t Start = ((Opcode1 & 0xf0) >> 4);\n  uint8_t Count = ((Opcode1 & 0x0f) >> 0);\n  PrintRegisters((((1 << (Count + 1)) - 1) << Start), \"d\");\n  OS << '\\n';\n}\ninline void OpcodeDecoder::Decode_11001yyy(const uint8_t *Opcodes,\n                                           unsigned &OI) {\n  uint8_t Opcode = Opcodes[OI++ ^ 3];\n  SW.startLine() << format(\"0x%02X      ; spare\\n\", Opcode);\n}\ninline void OpcodeDecoder::Decode_11000nnn(const uint8_t *Opcodes,\n                                           unsigned &OI) {\n  uint8_t Opcode = Opcodes[OI++ ^ 3];\n  SW.startLine() << format(\"0x%02X      ; pop \", Opcode);\n  PrintRegisters((((1 << ((Opcode & 0x07) + 1)) - 1) << 10), \"wR\");\n  OS << '\\n';\n}\ninline void OpcodeDecoder::Decode_11010nnn(const uint8_t *Opcodes,\n                                           unsigned &OI) {\n  uint8_t Opcode = Opcodes[OI++ ^ 3];\n  SW.startLine() << format(\"0x%02X      ; pop \", Opcode);\n  PrintRegisters((((1 << ((Opcode & 0x07) + 1)) - 1) << 8), \"d\");\n  OS << '\\n';\n}\ninline void OpcodeDecoder::Decode_11xxxyyy(const uint8_t *Opcodes,\n                                           unsigned &OI) {\n  uint8_t Opcode = Opcodes[OI++ ^ 3];\n  SW.startLine() << format(\"0x%02X      ; spare\\n\", Opcode);\n}\n\ninline void OpcodeDecoder::PrintGPR(uint16_t GPRMask) {\n  static const char *GPRRegisterNames[16] = {\n    \"r0\", \"r1\", \"r2\", \"r3\", \"r4\", \"r5\", \"r6\", \"r7\", \"r8\", \"r9\", \"r10\",\n    \"fp\", \"ip\", \"sp\", \"lr\", \"pc\"\n  };\n\n  OS << '{';\n  bool Comma = false;\n  for (unsigned RI = 0, RE = 17; RI < RE; ++RI) {\n    if (GPRMask & (1 << RI)) {\n      if (Comma)\n        OS << \", \";\n      OS << GPRRegisterNames[RI];\n      Comma = true;\n    }\n  }\n  OS << '}';\n}\n\ninline void OpcodeDecoder::PrintRegisters(uint32_t VFPMask, StringRef Prefix) {\n  OS << '{';\n  bool Comma = false;\n  for (unsigned RI = 0, RE = 32; RI < RE; ++RI) {\n    if (VFPMask & (1 << RI)) {\n      if (Comma)\n        OS << \", \";\n      OS << Prefix << RI;\n      Comma = true;\n    }\n  }\n  OS << '}';\n}\n\ninline void OpcodeDecoder::Decode(const uint8_t *Opcodes, off_t Offset,\n                                  size_t Length) {\n  for (unsigned OCI = Offset; OCI < Length + Offset; ) {\n    bool Decoded = false;\n    for (const auto &RE : ring()) {\n      if ((Opcodes[OCI ^ 3] & RE.Mask) == RE.Value) {\n        (this->*RE.Routine)(Opcodes, OCI);\n        Decoded = true;\n        break;\n      }\n    }\n    if (!Decoded)\n      SW.startLine() << format(\"0x%02X      ; reserved\\n\", Opcodes[OCI++ ^ 3]);\n  }\n}\n\ntemplate <typename ET>\nclass PrinterContext {\n  typedef typename ET::Sym Elf_Sym;\n  typedef typename ET::Shdr Elf_Shdr;\n  typedef typename ET::Rel Elf_Rel;\n  typedef typename ET::Word Elf_Word;\n\n  ScopedPrinter &SW;\n  const object::ELFFile<ET> &ELF;\n  StringRef FileName;\n  const Elf_Shdr *Symtab;\n  ArrayRef<Elf_Word> ShndxTable;\n\n  static const size_t IndexTableEntrySize;\n\n  static uint64_t PREL31(uint32_t Address, uint32_t Place) {\n    uint64_t Location = Address & 0x7fffffff;\n    if (Location & 0x40000000)\n      Location |= (uint64_t) ~0x7fffffff;\n    return Location + Place;\n  }\n\n  ErrorOr<StringRef> FunctionAtAddress(uint64_t Address,\n                                       Optional<unsigned> SectionIndex) const;\n  const Elf_Shdr *FindExceptionTable(unsigned IndexTableIndex,\n                                     off_t IndexTableOffset) const;\n\n  void PrintIndexTable(unsigned SectionIndex, const Elf_Shdr *IT) const;\n  void PrintExceptionTable(const Elf_Shdr &EHT,\n                           uint64_t TableEntryOffset) const;\n  void PrintOpcodes(const uint8_t *Entry, size_t Length, off_t Offset) const;\n\npublic:\n  PrinterContext(ScopedPrinter &SW, const object::ELFFile<ET> &ELF,\n                 StringRef FileName, const Elf_Shdr *Symtab)\n      : SW(SW), ELF(ELF), FileName(FileName), Symtab(Symtab) {}\n\n  void PrintUnwindInformation() const;\n};\n\ntemplate <typename ET>\nconst size_t PrinterContext<ET>::IndexTableEntrySize = 8;\n\ntemplate <typename ET>\nErrorOr<StringRef>\nPrinterContext<ET>::FunctionAtAddress(uint64_t Address,\n                                      Optional<unsigned> SectionIndex) const {\n  if (!Symtab)\n    return inconvertibleErrorCode();\n  auto StrTableOrErr = ELF.getStringTableForSymtab(*Symtab);\n  if (!StrTableOrErr)\n    reportError(StrTableOrErr.takeError(), FileName);\n  StringRef StrTable = *StrTableOrErr;\n\n  for (const Elf_Sym &Sym : unwrapOrError(FileName, ELF.symbols(Symtab))) {\n    if (SectionIndex && *SectionIndex != Sym.st_shndx)\n      continue;\n\n    if (Sym.st_value == Address && Sym.getType() == ELF::STT_FUNC) {\n      auto NameOrErr = Sym.getName(StrTable);\n      if (!NameOrErr) {\n        // TODO: Actually report errors helpfully.\n        consumeError(NameOrErr.takeError());\n        return inconvertibleErrorCode();\n      }\n      return *NameOrErr;\n    }\n  }\n\n  return inconvertibleErrorCode();\n}\n\ntemplate <typename ET>\nconst typename ET::Shdr *\nPrinterContext<ET>::FindExceptionTable(unsigned IndexSectionIndex,\n                                       off_t IndexTableOffset) const {\n  /// Iterate through the sections, searching for the relocation section\n  /// associated with the unwind index table section specified by\n  /// IndexSectionIndex.  Iterate the associated section searching for the\n  /// relocation associated with the index table entry specified by\n  /// IndexTableOffset.  The symbol is the section symbol for the exception\n  /// handling table.  Use this symbol to recover the actual exception handling\n  /// table.\n\n  for (const Elf_Shdr &Sec : unwrapOrError(FileName, ELF.sections())) {\n    if (Sec.sh_type != ELF::SHT_REL || Sec.sh_info != IndexSectionIndex)\n      continue;\n\n    auto SymTabOrErr = ELF.getSection(Sec.sh_link);\n    if (!SymTabOrErr)\n      reportError(SymTabOrErr.takeError(), FileName);\n    const Elf_Shdr *SymTab = *SymTabOrErr;\n\n    for (const Elf_Rel &R : unwrapOrError(FileName, ELF.rels(Sec))) {\n      if (R.r_offset != static_cast<unsigned>(IndexTableOffset))\n        continue;\n\n      typename ET::Rela RelA;\n      RelA.r_offset = R.r_offset;\n      RelA.r_info = R.r_info;\n      RelA.r_addend = 0;\n\n      const Elf_Sym *Symbol =\n          unwrapOrError(FileName, ELF.getRelocationSymbol(RelA, SymTab));\n\n      auto Ret = ELF.getSection(*Symbol, SymTab, ShndxTable);\n      if (!Ret)\n        report_fatal_error(errorToErrorCode(Ret.takeError()).message());\n      return *Ret;\n    }\n  }\n  return nullptr;\n}\n\ntemplate <typename ET>\nstatic const typename ET::Shdr *\nfindSectionContainingAddress(const object::ELFFile<ET> &Obj, StringRef FileName,\n                             uint64_t Address) {\n  for (const typename ET::Shdr &Sec : unwrapOrError(FileName, Obj.sections()))\n    if (Address >= Sec.sh_addr && Address < Sec.sh_addr + Sec.sh_size)\n      return &Sec;\n  return nullptr;\n}\n\ntemplate <typename ET>\nvoid PrinterContext<ET>::PrintExceptionTable(const Elf_Shdr &EHT,\n                                             uint64_t TableEntryOffset) const {\n  // TODO: handle failure.\n  Expected<ArrayRef<uint8_t>> Contents = ELF.getSectionContents(EHT);\n  if (!Contents)\n    return;\n\n  /// ARM EHABI Section 6.2 - The generic model\n  ///\n  /// An exception-handling table entry for the generic model is laid out as:\n  ///\n  ///  3 3\n  ///  1 0                            0\n  /// +-+------------------------------+\n  /// |0|  personality routine offset  |\n  /// +-+------------------------------+\n  /// |  personality routine data ...  |\n  ///\n  ///\n  /// ARM EHABI Section 6.3 - The ARM-defined compact model\n  ///\n  /// An exception-handling table entry for the compact model looks like:\n  ///\n  ///  3 3 2 2  2 2\n  ///  1 0 8 7  4 3                     0\n  /// +-+---+----+-----------------------+\n  /// |1| 0 | Ix | data for pers routine |\n  /// +-+---+----+-----------------------+\n  /// |  more personality routine data   |\n\n  const support::ulittle32_t Word =\n    *reinterpret_cast<const support::ulittle32_t *>(Contents->data() + TableEntryOffset);\n\n  if (Word & 0x80000000) {\n    SW.printString(\"Model\", StringRef(\"Compact\"));\n\n    unsigned PersonalityIndex = (Word & 0x0f000000) >> 24;\n    SW.printNumber(\"PersonalityIndex\", PersonalityIndex);\n\n    switch (PersonalityIndex) {\n    case AEABI_UNWIND_CPP_PR0:\n      PrintOpcodes(Contents->data() + TableEntryOffset, 3, 1);\n      break;\n    case AEABI_UNWIND_CPP_PR1:\n    case AEABI_UNWIND_CPP_PR2:\n      unsigned AdditionalWords = (Word & 0x00ff0000) >> 16;\n      PrintOpcodes(Contents->data() + TableEntryOffset, 2 + 4 * AdditionalWords,\n                   2);\n      break;\n    }\n  } else {\n    SW.printString(\"Model\", StringRef(\"Generic\"));\n    const bool IsRelocatable = ELF.getHeader().e_type == ELF::ET_REL;\n    uint64_t Address = IsRelocatable\n                           ? PREL31(Word, EHT.sh_addr)\n                           : PREL31(Word, EHT.sh_addr + TableEntryOffset);\n    SW.printHex(\"PersonalityRoutineAddress\", Address);\n    Optional<unsigned> SecIndex =\n        IsRelocatable ? Optional<unsigned>(EHT.sh_link) : None;\n    if (ErrorOr<StringRef> Name = FunctionAtAddress(Address, SecIndex))\n      SW.printString(\"PersonalityRoutineName\", *Name);\n  }\n}\n\ntemplate <typename ET>\nvoid PrinterContext<ET>::PrintOpcodes(const uint8_t *Entry,\n                                      size_t Length, off_t Offset) const {\n  ListScope OCC(SW, \"Opcodes\");\n  OpcodeDecoder(OCC.W).Decode(Entry, Offset, Length);\n}\n\ntemplate <typename ET>\nvoid PrinterContext<ET>::PrintIndexTable(unsigned SectionIndex,\n                                         const Elf_Shdr *IT) const {\n  // TODO: handle failure.\n  Expected<ArrayRef<uint8_t>> Contents = ELF.getSectionContents(*IT);\n  if (!Contents)\n    return;\n\n  /// ARM EHABI Section 5 - Index Table Entries\n  /// * The first word contains a PREL31 offset to the start of a function with\n  ///   bit 31 clear\n  /// * The second word contains one of:\n  ///   - The PREL31 offset of the start of the table entry for the function,\n  ///     with bit 31 clear\n  ///   - The exception-handling table entry itself with bit 31 set\n  ///   - The special bit pattern EXIDX_CANTUNWIND, indicating that associated\n  ///     frames cannot be unwound\n\n  const support::ulittle32_t *Data =\n    reinterpret_cast<const support::ulittle32_t *>(Contents->data());\n  const unsigned Entries = IT->sh_size / IndexTableEntrySize;\n  const bool IsRelocatable = ELF.getHeader().e_type == ELF::ET_REL;\n\n  ListScope E(SW, \"Entries\");\n  for (unsigned Entry = 0; Entry < Entries; ++Entry) {\n    DictScope E(SW, \"Entry\");\n\n    const support::ulittle32_t Word0 =\n      Data[Entry * (IndexTableEntrySize / sizeof(*Data)) + 0];\n    const support::ulittle32_t Word1 =\n      Data[Entry * (IndexTableEntrySize / sizeof(*Data)) + 1];\n\n    if (Word0 & 0x80000000) {\n      errs() << \"corrupt unwind data in section \" << SectionIndex << \"\\n\";\n      continue;\n    }\n\n    // FIXME: For a relocatable object ideally we might want to:\n    // 1) Find a relocation for the offset of Word0.\n    // 2) Verify this relocation is of an expected type (R_ARM_PREL31) and\n    //    verify the symbol index.\n    // 3) Resolve the relocation using it's symbol value, addend etc.\n    // Currently the code assumes that Word0 contains an addend of a\n    // R_ARM_PREL31 REL relocation that references a section symbol. RELA\n    // relocations are not supported and it works because addresses of sections\n    // are nulls in relocatable objects.\n    //\n    // For a non-relocatable object, Word0 contains a place-relative signed\n    // offset to the referenced entity.\n    const uint64_t Address =\n        IsRelocatable\n            ? PREL31(Word0, IT->sh_addr)\n            : PREL31(Word0, IT->sh_addr + Entry * IndexTableEntrySize);\n    SW.printHex(\"FunctionAddress\", Address);\n\n    // In a relocatable output we might have many .ARM.exidx sections linked to\n    // their code sections via the sh_link field. For a non-relocatable ELF file\n    // the sh_link field is not reliable, because we have one .ARM.exidx section\n    // normally, but might have many code sections.\n    Optional<unsigned> SecIndex =\n        IsRelocatable ? Optional<unsigned>(IT->sh_link) : None;\n    if (ErrorOr<StringRef> Name = FunctionAtAddress(Address, SecIndex))\n      SW.printString(\"FunctionName\", *Name);\n\n    if (Word1 == EXIDX_CANTUNWIND) {\n      SW.printString(\"Model\", StringRef(\"CantUnwind\"));\n      continue;\n    }\n\n    if (Word1 & 0x80000000) {\n      SW.printString(\"Model\", StringRef(\"Compact (Inline)\"));\n\n      unsigned PersonalityIndex = (Word1 & 0x0f000000) >> 24;\n      SW.printNumber(\"PersonalityIndex\", PersonalityIndex);\n\n      PrintOpcodes(Contents->data() + Entry * IndexTableEntrySize + 4, 3, 1);\n    } else {\n      const Elf_Shdr *EHT;\n      uint64_t TableEntryAddress;\n      if (IsRelocatable) {\n        TableEntryAddress = PREL31(Word1, IT->sh_addr);\n        EHT = FindExceptionTable(SectionIndex, Entry * IndexTableEntrySize + 4);\n      } else {\n        TableEntryAddress =\n            PREL31(Word1, IT->sh_addr + Entry * IndexTableEntrySize + 4);\n        EHT = findSectionContainingAddress(ELF, FileName, TableEntryAddress);\n      }\n\n      if (EHT)\n        // TODO: handle failure.\n        if (Expected<StringRef> Name = ELF.getSectionName(*EHT))\n          SW.printString(\"ExceptionHandlingTable\", *Name);\n\n      SW.printHex(IsRelocatable ? \"TableEntryOffset\" : \"TableEntryAddress\",\n                  TableEntryAddress);\n      if (EHT) {\n        if (IsRelocatable)\n          PrintExceptionTable(*EHT, TableEntryAddress);\n        else\n          PrintExceptionTable(*EHT, TableEntryAddress - EHT->sh_addr);\n      }\n    }\n  }\n}\n\ntemplate <typename ET>\nvoid PrinterContext<ET>::PrintUnwindInformation() const {\n  DictScope UI(SW, \"UnwindInformation\");\n\n  int SectionIndex = 0;\n  for (const Elf_Shdr &Sec : unwrapOrError(FileName, ELF.sections())) {\n    if (Sec.sh_type == ELF::SHT_ARM_EXIDX) {\n      DictScope UIT(SW, \"UnwindIndexTable\");\n\n      SW.printNumber(\"SectionIndex\", SectionIndex);\n      // TODO: handle failure.\n      if (Expected<StringRef> SectionName = ELF.getSectionName(Sec))\n        SW.printString(\"SectionName\", *SectionName);\n      SW.printHex(\"SectionOffset\", Sec.sh_offset);\n\n      PrintIndexTable(SectionIndex, &Sec);\n    }\n    ++SectionIndex;\n  }\n}\n}\n}\n}\n\n#endif\n"}, "5": {"id": 5, "path": "/home/vsts/work/1/llvm-project/llvm/tools/llvm-readobj/ELFDumper.cpp", "content": "//===- ELFDumper.cpp - ELF-specific dumper --------------------------------===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n///\n/// \\file\n/// This file implements the ELF-specific dumper for llvm-readobj.\n///\n//===----------------------------------------------------------------------===//\n\n#include \"ARMEHABIPrinter.h\"\n#include \"DwarfCFIEHPrinter.h\"\n#include \"ObjDumper.h\"\n#include \"StackMapPrinter.h\"\n#include \"llvm-readobj.h\"\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/ADT/DenseMap.h\"\n#include \"llvm/ADT/DenseSet.h\"\n#include \"llvm/ADT/MapVector.h\"\n#include \"llvm/ADT/Optional.h\"\n#include \"llvm/ADT/PointerIntPair.h\"\n#include \"llvm/ADT/STLExtras.h\"\n#include \"llvm/ADT/SmallString.h\"\n#include \"llvm/ADT/SmallVector.h\"\n#include \"llvm/ADT/StringExtras.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/ADT/Twine.h\"\n#include \"llvm/BinaryFormat/AMDGPUMetadataVerifier.h\"\n#include \"llvm/BinaryFormat/ELF.h\"\n#include \"llvm/Demangle/Demangle.h\"\n#include \"llvm/Object/ELF.h\"\n#include \"llvm/Object/ELFObjectFile.h\"\n#include \"llvm/Object/ELFTypes.h\"\n#include \"llvm/Object/Error.h\"\n#include \"llvm/Object/ObjectFile.h\"\n#include \"llvm/Object/RelocationResolver.h\"\n#include \"llvm/Object/StackMapParser.h\"\n#include \"llvm/Support/AMDGPUMetadata.h\"\n#include \"llvm/Support/ARMAttributeParser.h\"\n#include \"llvm/Support/ARMBuildAttributes.h\"\n#include \"llvm/Support/Casting.h\"\n#include \"llvm/Support/Compiler.h\"\n#include \"llvm/Support/Endian.h\"\n#include \"llvm/Support/ErrorHandling.h\"\n#include \"llvm/Support/Format.h\"\n#include \"llvm/Support/FormatVariadic.h\"\n#include \"llvm/Support/FormattedStream.h\"\n#include \"llvm/Support/LEB128.h\"\n#include \"llvm/Support/MathExtras.h\"\n#include \"llvm/Support/MipsABIFlags.h\"\n#include \"llvm/Support/RISCVAttributeParser.h\"\n#include \"llvm/Support/RISCVAttributes.h\"\n#include \"llvm/Support/ScopedPrinter.h\"\n#include \"llvm/Support/raw_ostream.h\"\n#include <algorithm>\n#include <cinttypes>\n#include <cstddef>\n#include <cstdint>\n#include <cstdlib>\n#include <iterator>\n#include <memory>\n#include <string>\n#include <system_error>\n#include <vector>\n\nusing namespace llvm;\nusing namespace llvm::object;\nusing namespace ELF;\n\n#define LLVM_READOBJ_ENUM_CASE(ns, enum)                                       \\\n  case ns::enum:                                                               \\\n    return #enum;\n\n#define ENUM_ENT(enum, altName)                                                \\\n  { #enum, altName, ELF::enum }\n\n#define ENUM_ENT_1(enum)                                                       \\\n  { #enum, #enum, ELF::enum }\n\nnamespace {\n\ntemplate <class ELFT> struct RelSymbol {\n  RelSymbol(const typename ELFT::Sym *S, StringRef N)\n      : Sym(S), Name(N.str()) {}\n  const typename ELFT::Sym *Sym;\n  std::string Name;\n};\n\n/// Represents a contiguous uniform range in the file. We cannot just create a\n/// range directly because when creating one of these from the .dynamic table\n/// the size, entity size and virtual address are different entries in arbitrary\n/// order (DT_REL, DT_RELSZ, DT_RELENT for example).\nstruct DynRegionInfo {\n  DynRegionInfo(const Binary &Owner, const ObjDumper &D)\n      : Obj(&Owner), Dumper(&D) {}\n  DynRegionInfo(const Binary &Owner, const ObjDumper &D, const uint8_t *A,\n                uint64_t S, uint64_t ES)\n      : Addr(A), Size(S), EntSize(ES), Obj(&Owner), Dumper(&D) {}\n\n  /// Address in current address space.\n  const uint8_t *Addr = nullptr;\n  /// Size in bytes of the region.\n  uint64_t Size = 0;\n  /// Size of each entity in the region.\n  uint64_t EntSize = 0;\n\n  /// Owner object. Used for error reporting.\n  const Binary *Obj;\n  /// Dumper used for error reporting.\n  const ObjDumper *Dumper;\n  /// Error prefix. Used for error reporting to provide more information.\n  std::string Context;\n  /// Region size name. Used for error reporting.\n  StringRef SizePrintName = \"size\";\n  /// Entry size name. Used for error reporting. If this field is empty, errors\n  /// will not mention the entry size.\n  StringRef EntSizePrintName = \"entry size\";\n\n  template <typename Type> ArrayRef<Type> getAsArrayRef() const {\n    const Type *Start = reinterpret_cast<const Type *>(Addr);\n    if (!Start)\n      return {Start, Start};\n\n    const uint64_t Offset =\n        Addr - (const uint8_t *)Obj->getMemoryBufferRef().getBufferStart();\n    const uint64_t ObjSize = Obj->getMemoryBufferRef().getBufferSize();\n\n    if (Size > ObjSize - Offset) {\n      Dumper->reportUniqueWarning(\n          \"unable to read data at 0x\" + Twine::utohexstr(Offset) +\n          \" of size 0x\" + Twine::utohexstr(Size) + \" (\" + SizePrintName +\n          \"): it goes past the end of the file of size 0x\" +\n          Twine::utohexstr(ObjSize));\n      return {Start, Start};\n    }\n\n    if (EntSize == sizeof(Type) && (Size % EntSize == 0))\n      return {Start, Start + (Size / EntSize)};\n\n    std::string Msg;\n    if (!Context.empty())\n      Msg += Context + \" has \";\n\n    Msg += (\"invalid \" + SizePrintName + \" (0x\" + Twine::utohexstr(Size) + \")\")\n               .str();\n    if (!EntSizePrintName.empty())\n      Msg +=\n          (\" or \" + EntSizePrintName + \" (0x\" + Twine::utohexstr(EntSize) + \")\")\n              .str();\n\n    Dumper->reportUniqueWarning(Msg);\n    return {Start, Start};\n  }\n};\n\nstruct GroupMember {\n  StringRef Name;\n  uint64_t Index;\n};\n\nstruct GroupSection {\n  StringRef Name;\n  std::string Signature;\n  uint64_t ShName;\n  uint64_t Index;\n  uint32_t Link;\n  uint32_t Info;\n  uint32_t Type;\n  std::vector<GroupMember> Members;\n};\n\nnamespace {\n\nstruct NoteType {\n  uint32_t ID;\n  StringRef Name;\n};\n\n} // namespace\n\ntemplate <class ELFT> class Relocation {\npublic:\n  Relocation(const typename ELFT::Rel &R, bool IsMips64EL)\n      : Type(R.getType(IsMips64EL)), Symbol(R.getSymbol(IsMips64EL)),\n        Offset(R.r_offset), Info(R.r_info) {}\n\n  Relocation(const typename ELFT::Rela &R, bool IsMips64EL)\n      : Relocation((const typename ELFT::Rel &)R, IsMips64EL) {\n    Addend = R.r_addend;\n  }\n\n  uint32_t Type;\n  uint32_t Symbol;\n  typename ELFT::uint Offset;\n  typename ELFT::uint Info;\n  Optional<int64_t> Addend;\n};\n\ntemplate <class ELFT> class MipsGOTParser;\n\ntemplate <typename ELFT> class ELFDumper : public ObjDumper {\n  LLVM_ELF_IMPORT_TYPES_ELFT(ELFT)\n\npublic:\n  ELFDumper(const object::ELFObjectFile<ELFT> &ObjF, ScopedPrinter &Writer);\n\n  void printUnwindInfo() override;\n  void printNeededLibraries() override;\n  void printHashTable() override;\n  void printGnuHashTable() override;\n  void printLoadName() override;\n  void printVersionInfo() override;\n  void printArchSpecificInfo() override;\n  void printStackMap() const override;\n\n  const object::ELFObjectFile<ELFT> &getElfObject() const { return ObjF; };\n\n  std::string describe(const Elf_Shdr &Sec) const;\n\n  unsigned getHashTableEntSize() const {\n    // EM_S390 and ELF::EM_ALPHA platforms use 8-bytes entries in SHT_HASH\n    // sections. This violates the ELF specification.\n    if (Obj.getHeader().e_machine == ELF::EM_S390 ||\n        Obj.getHeader().e_machine == ELF::EM_ALPHA)\n      return 8;\n    return 4;\n  }\n\n  Elf_Dyn_Range dynamic_table() const {\n    // A valid .dynamic section contains an array of entries terminated\n    // with a DT_NULL entry. However, sometimes the section content may\n    // continue past the DT_NULL entry, so to dump the section correctly,\n    // we first find the end of the entries by iterating over them.\n    Elf_Dyn_Range Table = DynamicTable.template getAsArrayRef<Elf_Dyn>();\n\n    size_t Size = 0;\n    while (Size < Table.size())\n      if (Table[Size++].getTag() == DT_NULL)\n        break;\n\n    return Table.slice(0, Size);\n  }\n\n  Elf_Sym_Range dynamic_symbols() const {\n    if (!DynSymRegion)\n      return Elf_Sym_Range();\n    return DynSymRegion->template getAsArrayRef<Elf_Sym>();\n  }\n\n  const Elf_Shdr *findSectionByName(StringRef Name) const;\n\n  StringRef getDynamicStringTable() const { return DynamicStringTable; }\n\nprotected:\n  virtual void printVersionSymbolSection(const Elf_Shdr *Sec) = 0;\n  virtual void printVersionDefinitionSection(const Elf_Shdr *Sec) = 0;\n  virtual void printVersionDependencySection(const Elf_Shdr *Sec) = 0;\n\n  void\n  printDependentLibsHelper(function_ref<void(const Elf_Shdr &)> OnSectionStart,\n                           function_ref<void(StringRef, uint64_t)> OnLibEntry);\n\n  virtual void printRelRelaReloc(const Relocation<ELFT> &R,\n                                 const RelSymbol<ELFT> &RelSym) = 0;\n  virtual void printRelrReloc(const Elf_Relr &R) = 0;\n  virtual void printDynamicRelocHeader(unsigned Type, StringRef Name,\n                                       const DynRegionInfo &Reg) {}\n  void printReloc(const Relocation<ELFT> &R, unsigned RelIndex,\n                  const Elf_Shdr &Sec, const Elf_Shdr *SymTab);\n  void printDynamicReloc(const Relocation<ELFT> &R);\n  void printDynamicRelocationsHelper();\n  void printRelocationsHelper(const Elf_Shdr &Sec);\n  void forEachRelocationDo(\n      const Elf_Shdr &Sec, bool RawRelr,\n      llvm::function_ref<void(const Relocation<ELFT> &, unsigned,\n                              const Elf_Shdr &, const Elf_Shdr *)>\n          RelRelaFn,\n      llvm::function_ref<void(const Elf_Relr &)> RelrFn);\n\n  virtual void printSymtabMessage(const Elf_Shdr *Symtab, size_t Offset,\n                                  bool NonVisibilityBitsUsed) const {};\n  virtual void printSymbol(const Elf_Sym &Symbol, unsigned SymIndex,\n                           DataRegion<Elf_Word> ShndxTable,\n                           Optional<StringRef> StrTable, bool IsDynamic,\n                           bool NonVisibilityBitsUsed) const = 0;\n\n  virtual void printMipsABIFlags() = 0;\n  virtual void printMipsGOT(const MipsGOTParser<ELFT> &Parser) = 0;\n  virtual void printMipsPLT(const MipsGOTParser<ELFT> &Parser) = 0;\n\n  Expected<ArrayRef<Elf_Versym>>\n  getVersionTable(const Elf_Shdr &Sec, ArrayRef<Elf_Sym> *SymTab,\n                  StringRef *StrTab, const Elf_Shdr **SymTabSec) const;\n  StringRef getPrintableSectionName(const Elf_Shdr &Sec) const;\n\n  std::vector<GroupSection> getGroups();\n\n  bool printFunctionStackSize(uint64_t SymValue,\n                              Optional<const Elf_Shdr *> FunctionSec,\n                              const Elf_Shdr &StackSizeSec, DataExtractor Data,\n                              uint64_t *Offset);\n  void printStackSize(const Relocation<ELFT> &R, const Elf_Shdr &RelocSec,\n                      unsigned Ndx, const Elf_Shdr *SymTab,\n                      const Elf_Shdr *FunctionSec, const Elf_Shdr &StackSizeSec,\n                      const RelocationResolver &Resolver, DataExtractor Data);\n  virtual void printStackSizeEntry(uint64_t Size, StringRef FuncName) = 0;\n\n  void printRelocatableStackSizes(std::function<void()> PrintHeader);\n  void printNonRelocatableStackSizes(std::function<void()> PrintHeader);\n\n  const object::ELFObjectFile<ELFT> &ObjF;\n  const ELFFile<ELFT> &Obj;\n  StringRef FileName;\n\n  Expected<DynRegionInfo> createDRI(uint64_t Offset, uint64_t Size,\n                                    uint64_t EntSize) {\n    if (Offset + Size < Offset || Offset + Size > Obj.getBufSize())\n      return createError(\"offset (0x\" + Twine::utohexstr(Offset) +\n                         \") + size (0x\" + Twine::utohexstr(Size) +\n                         \") is greater than the file size (0x\" +\n                         Twine::utohexstr(Obj.getBufSize()) + \")\");\n    return DynRegionInfo(ObjF, *this, Obj.base() + Offset, Size, EntSize);\n  }\n\n  void printAttributes();\n  void printMipsReginfo();\n  void printMipsOptions();\n\n  std::pair<const Elf_Phdr *, const Elf_Shdr *> findDynamic();\n  void loadDynamicTable();\n  void parseDynamicTable();\n\n  Expected<StringRef> getSymbolVersion(const Elf_Sym &Sym,\n                                       bool &IsDefault) const;\n  Expected<SmallVector<Optional<VersionEntry>, 0> *> getVersionMap() const;\n\n  DynRegionInfo DynRelRegion;\n  DynRegionInfo DynRelaRegion;\n  DynRegionInfo DynRelrRegion;\n  DynRegionInfo DynPLTRelRegion;\n  Optional<DynRegionInfo> DynSymRegion;\n  DynRegionInfo DynSymTabShndxRegion;\n  DynRegionInfo DynamicTable;\n  StringRef DynamicStringTable;\n  const Elf_Hash *HashTable = nullptr;\n  const Elf_GnuHash *GnuHashTable = nullptr;\n  const Elf_Shdr *DotSymtabSec = nullptr;\n  const Elf_Shdr *DotDynsymSec = nullptr;\n  const Elf_Shdr *DotCGProfileSec = nullptr;\n  const Elf_Shdr *DotAddrsigSec = nullptr;\n  DenseMap<const Elf_Shdr *, ArrayRef<Elf_Word>> ShndxTables;\n  Optional<uint64_t> SONameOffset;\n\n  const Elf_Shdr *SymbolVersionSection = nullptr;   // .gnu.version\n  const Elf_Shdr *SymbolVersionNeedSection = nullptr; // .gnu.version_r\n  const Elf_Shdr *SymbolVersionDefSection = nullptr; // .gnu.version_d\n\n  std::string getFullSymbolName(const Elf_Sym &Symbol, unsigned SymIndex,\n                                DataRegion<Elf_Word> ShndxTable,\n                                Optional<StringRef> StrTable,\n                                bool IsDynamic) const;\n  Expected<unsigned>\n  getSymbolSectionIndex(const Elf_Sym &Symbol, unsigned SymIndex,\n                        DataRegion<Elf_Word> ShndxTable) const;\n  Expected<StringRef> getSymbolSectionName(const Elf_Sym &Symbol,\n                                           unsigned SectionIndex) const;\n  std::string getStaticSymbolName(uint32_t Index) const;\n  StringRef getDynamicString(uint64_t Value) const;\n\n  void printSymbolsHelper(bool IsDynamic) const;\n  std::string getDynamicEntry(uint64_t Type, uint64_t Value) const;\n\n  Expected<RelSymbol<ELFT>> getRelocationTarget(const Relocation<ELFT> &R,\n                                                const Elf_Shdr *SymTab) const;\n\n  ArrayRef<Elf_Word> getShndxTable(const Elf_Shdr *Symtab) const;\n\nprivate:\n  mutable SmallVector<Optional<VersionEntry>, 0> VersionMap;\n};\n\ntemplate <class ELFT>\nstd::string ELFDumper<ELFT>::describe(const Elf_Shdr &Sec) const {\n  return ::describe(Obj, Sec);\n}\n\nnamespace {\n\ntemplate <class ELFT> struct SymtabLink {\n  typename ELFT::SymRange Symbols;\n  StringRef StringTable;\n  const typename ELFT::Shdr *SymTab;\n};\n\n// Returns the linked symbol table, symbols and associated string table for a\n// given section.\ntemplate <class ELFT>\nExpected<SymtabLink<ELFT>> getLinkAsSymtab(const ELFFile<ELFT> &Obj,\n                                           const typename ELFT::Shdr &Sec,\n                                           unsigned ExpectedType) {\n  Expected<const typename ELFT::Shdr *> SymtabOrErr =\n      Obj.getSection(Sec.sh_link);\n  if (!SymtabOrErr)\n    return createError(\"invalid section linked to \" + describe(Obj, Sec) +\n                       \": \" + toString(SymtabOrErr.takeError()));\n\n  if ((*SymtabOrErr)->sh_type != ExpectedType)\n    return createError(\n        \"invalid section linked to \" + describe(Obj, Sec) + \": expected \" +\n        object::getELFSectionTypeName(Obj.getHeader().e_machine, ExpectedType) +\n        \", but got \" +\n        object::getELFSectionTypeName(Obj.getHeader().e_machine,\n                                      (*SymtabOrErr)->sh_type));\n\n  Expected<StringRef> StrTabOrErr = Obj.getLinkAsStrtab(**SymtabOrErr);\n  if (!StrTabOrErr)\n    return createError(\n        \"can't get a string table for the symbol table linked to \" +\n        describe(Obj, Sec) + \": \" + toString(StrTabOrErr.takeError()));\n\n  Expected<typename ELFT::SymRange> SymsOrErr = Obj.symbols(*SymtabOrErr);\n  if (!SymsOrErr)\n    return createError(\"unable to read symbols from the \" + describe(Obj, Sec) +\n                       \": \" + toString(SymsOrErr.takeError()));\n\n  return SymtabLink<ELFT>{*SymsOrErr, *StrTabOrErr, *SymtabOrErr};\n}\n\n} // namespace\n\ntemplate <class ELFT>\nExpected<ArrayRef<typename ELFT::Versym>>\nELFDumper<ELFT>::getVersionTable(const Elf_Shdr &Sec, ArrayRef<Elf_Sym> *SymTab,\n                                 StringRef *StrTab,\n                                 const Elf_Shdr **SymTabSec) const {\n  assert((!SymTab && !StrTab && !SymTabSec) || (SymTab && StrTab && SymTabSec));\n  if (reinterpret_cast<uintptr_t>(Obj.base() + Sec.sh_offset) %\n          sizeof(uint16_t) !=\n      0)\n    return createError(\"the \" + describe(Sec) + \" is misaligned\");\n\n  Expected<ArrayRef<Elf_Versym>> VersionsOrErr =\n      Obj.template getSectionContentsAsArray<Elf_Versym>(Sec);\n  if (!VersionsOrErr)\n    return createError(\"cannot read content of \" + describe(Sec) + \": \" +\n                       toString(VersionsOrErr.takeError()));\n\n  Expected<SymtabLink<ELFT>> SymTabOrErr =\n      getLinkAsSymtab(Obj, Sec, SHT_DYNSYM);\n  if (!SymTabOrErr) {\n    reportUniqueWarning(SymTabOrErr.takeError());\n    return *VersionsOrErr;\n  }\n\n  if (SymTabOrErr->Symbols.size() != VersionsOrErr->size())\n    reportUniqueWarning(describe(Sec) + \": the number of entries (\" +\n                        Twine(VersionsOrErr->size()) +\n                        \") does not match the number of symbols (\" +\n                        Twine(SymTabOrErr->Symbols.size()) +\n                        \") in the symbol table with index \" +\n                        Twine(Sec.sh_link));\n\n  if (SymTab) {\n    *SymTab = SymTabOrErr->Symbols;\n    *StrTab = SymTabOrErr->StringTable;\n    *SymTabSec = SymTabOrErr->SymTab;\n  }\n  return *VersionsOrErr;\n}\n\ntemplate <class ELFT>\nvoid ELFDumper<ELFT>::printSymbolsHelper(bool IsDynamic) const {\n  Optional<StringRef> StrTable;\n  size_t Entries = 0;\n  Elf_Sym_Range Syms(nullptr, nullptr);\n  const Elf_Shdr *SymtabSec = IsDynamic ? DotDynsymSec : DotSymtabSec;\n\n  if (IsDynamic) {\n    StrTable = DynamicStringTable;\n    Syms = dynamic_symbols();\n    Entries = Syms.size();\n  } else if (DotSymtabSec) {\n    if (Expected<StringRef> StrTableOrErr =\n            Obj.getStringTableForSymtab(*DotSymtabSec))\n      StrTable = *StrTableOrErr;\n    else\n      reportUniqueWarning(\n          \"unable to get the string table for the SHT_SYMTAB section: \" +\n          toString(StrTableOrErr.takeError()));\n\n    if (Expected<Elf_Sym_Range> SymsOrErr = Obj.symbols(DotSymtabSec))\n      Syms = *SymsOrErr;\n    else\n      reportUniqueWarning(\n          \"unable to read symbols from the SHT_SYMTAB section: \" +\n          toString(SymsOrErr.takeError()));\n    Entries = DotSymtabSec->getEntityCount();\n  }\n  if (Syms.empty())\n    return;\n\n  // The st_other field has 2 logical parts. The first two bits hold the symbol\n  // visibility (STV_*) and the remainder hold other platform-specific values.\n  bool NonVisibilityBitsUsed =\n      llvm::any_of(Syms, [](const Elf_Sym &S) { return S.st_other & ~0x3; });\n\n  DataRegion<Elf_Word> ShndxTable =\n      IsDynamic ? DataRegion<Elf_Word>(\n                      (const Elf_Word *)this->DynSymTabShndxRegion.Addr,\n                      this->getElfObject().getELFFile().end())\n                : DataRegion<Elf_Word>(this->getShndxTable(SymtabSec));\n\n  printSymtabMessage(SymtabSec, Entries, NonVisibilityBitsUsed);\n  for (const Elf_Sym &Sym : Syms)\n    printSymbol(Sym, &Sym - Syms.begin(), ShndxTable, StrTable, IsDynamic,\n                NonVisibilityBitsUsed);\n}\n\ntemplate <typename ELFT> class GNUELFDumper : public ELFDumper<ELFT> {\n  formatted_raw_ostream &OS;\n\npublic:\n  LLVM_ELF_IMPORT_TYPES_ELFT(ELFT)\n\n  GNUELFDumper(const object::ELFObjectFile<ELFT> &ObjF, ScopedPrinter &Writer)\n      : ELFDumper<ELFT>(ObjF, Writer),\n        OS(static_cast<formatted_raw_ostream &>(Writer.getOStream())) {\n    assert(&this->W.getOStream() == &llvm::fouts());\n  }\n\n  void printFileHeaders() override;\n  void printGroupSections() override;\n  void printRelocations() override;\n  void printSectionHeaders() override;\n  void printSymbols(bool PrintSymbols, bool PrintDynamicSymbols) override;\n  void printHashSymbols() override;\n  void printSectionDetails() override;\n  void printDependentLibs() override;\n  void printDynamicTable() override;\n  void printDynamicRelocations() override;\n  void printSymtabMessage(const Elf_Shdr *Symtab, size_t Offset,\n                          bool NonVisibilityBitsUsed) const override;\n  void printProgramHeaders(bool PrintProgramHeaders,\n                           cl::boolOrDefault PrintSectionMapping) override;\n  void printVersionSymbolSection(const Elf_Shdr *Sec) override;\n  void printVersionDefinitionSection(const Elf_Shdr *Sec) override;\n  void printVersionDependencySection(const Elf_Shdr *Sec) override;\n  void printHashHistograms() override;\n  void printCGProfile() override;\n  void printAddrsig() override;\n  void printNotes() override;\n  void printELFLinkerOptions() override;\n  void printStackSizes() override;\n\nprivate:\n  void printHashHistogram(const Elf_Hash &HashTable);\n  void printGnuHashHistogram(const Elf_GnuHash &GnuHashTable);\n  void printHashTableSymbols(const Elf_Hash &HashTable);\n  void printGnuHashTableSymbols(const Elf_GnuHash &GnuHashTable);\n\n  struct Field {\n    std::string Str;\n    unsigned Column;\n\n    Field(StringRef S, unsigned Col) : Str(std::string(S)), Column(Col) {}\n    Field(unsigned Col) : Column(Col) {}\n  };\n\n  template <typename T, typename TEnum>\n  std::string printEnum(T Value, ArrayRef<EnumEntry<TEnum>> EnumValues) const {\n    for (const EnumEntry<TEnum> &EnumItem : EnumValues)\n      if (EnumItem.Value == Value)\n        return std::string(EnumItem.AltName);\n    return to_hexString(Value, false);\n  }\n\n  template <typename T, typename TEnum>\n  std::string printFlags(T Value, ArrayRef<EnumEntry<TEnum>> EnumValues,\n                         TEnum EnumMask1 = {}, TEnum EnumMask2 = {},\n                         TEnum EnumMask3 = {}) const {\n    std::string Str;\n    for (const EnumEntry<TEnum> &Flag : EnumValues) {\n      if (Flag.Value == 0)\n        continue;\n\n      TEnum EnumMask{};\n      if (Flag.Value & EnumMask1)\n        EnumMask = EnumMask1;\n      else if (Flag.Value & EnumMask2)\n        EnumMask = EnumMask2;\n      else if (Flag.Value & EnumMask3)\n        EnumMask = EnumMask3;\n      bool IsEnum = (Flag.Value & EnumMask) != 0;\n      if ((!IsEnum && (Value & Flag.Value) == Flag.Value) ||\n          (IsEnum && (Value & EnumMask) == Flag.Value)) {\n        if (!Str.empty())\n          Str += \", \";\n        Str += Flag.AltName;\n      }\n    }\n    return Str;\n  }\n\n  formatted_raw_ostream &printField(struct Field F) const {\n    if (F.Column != 0)\n      OS.PadToColumn(F.Column);\n    OS << F.Str;\n    OS.flush();\n    return OS;\n  }\n  void printHashedSymbol(const Elf_Sym *Sym, unsigned SymIndex,\n                         DataRegion<Elf_Word> ShndxTable, StringRef StrTable,\n                         uint32_t Bucket);\n  void printRelrReloc(const Elf_Relr &R) override;\n  void printRelRelaReloc(const Relocation<ELFT> &R,\n                         const RelSymbol<ELFT> &RelSym) override;\n  void printSymbol(const Elf_Sym &Symbol, unsigned SymIndex,\n                   DataRegion<Elf_Word> ShndxTable,\n                   Optional<StringRef> StrTable, bool IsDynamic,\n                   bool NonVisibilityBitsUsed) const override;\n  void printDynamicRelocHeader(unsigned Type, StringRef Name,\n                               const DynRegionInfo &Reg) override;\n\n  std::string getSymbolSectionNdx(const Elf_Sym &Symbol, unsigned SymIndex,\n                                  DataRegion<Elf_Word> ShndxTable) const;\n  void printProgramHeaders() override;\n  void printSectionMapping() override;\n  void printGNUVersionSectionProlog(const typename ELFT::Shdr &Sec,\n                                    const Twine &Label, unsigned EntriesNum);\n\n  void printStackSizeEntry(uint64_t Size, StringRef FuncName) override;\n\n  void printMipsGOT(const MipsGOTParser<ELFT> &Parser) override;\n  void printMipsPLT(const MipsGOTParser<ELFT> &Parser) override;\n  void printMipsABIFlags() override;\n};\n\ntemplate <typename ELFT> class LLVMELFDumper : public ELFDumper<ELFT> {\npublic:\n  LLVM_ELF_IMPORT_TYPES_ELFT(ELFT)\n\n  LLVMELFDumper(const object::ELFObjectFile<ELFT> &ObjF, ScopedPrinter &Writer)\n      : ELFDumper<ELFT>(ObjF, Writer), W(Writer) {}\n\n  void printFileHeaders() override;\n  void printGroupSections() override;\n  void printRelocations() override;\n  void printSectionHeaders() override;\n  void printSymbols(bool PrintSymbols, bool PrintDynamicSymbols) override;\n  void printDependentLibs() override;\n  void printDynamicTable() override;\n  void printDynamicRelocations() override;\n  void printProgramHeaders(bool PrintProgramHeaders,\n                           cl::boolOrDefault PrintSectionMapping) override;\n  void printVersionSymbolSection(const Elf_Shdr *Sec) override;\n  void printVersionDefinitionSection(const Elf_Shdr *Sec) override;\n  void printVersionDependencySection(const Elf_Shdr *Sec) override;\n  void printHashHistograms() override;\n  void printCGProfile() override;\n  void printAddrsig() override;\n  void printNotes() override;\n  void printELFLinkerOptions() override;\n  void printStackSizes() override;\n\nprivate:\n  void printRelrReloc(const Elf_Relr &R) override;\n  void printRelRelaReloc(const Relocation<ELFT> &R,\n                         const RelSymbol<ELFT> &RelSym) override;\n\n  void printSymbolSection(const Elf_Sym &Symbol, unsigned SymIndex,\n                          DataRegion<Elf_Word> ShndxTable) const;\n  void printSymbol(const Elf_Sym &Symbol, unsigned SymIndex,\n                   DataRegion<Elf_Word> ShndxTable,\n                   Optional<StringRef> StrTable, bool IsDynamic,\n                   bool /*NonVisibilityBitsUsed*/) const override;\n  void printProgramHeaders() override;\n  void printSectionMapping() override {}\n  void printStackSizeEntry(uint64_t Size, StringRef FuncName) override;\n\n  void printMipsGOT(const MipsGOTParser<ELFT> &Parser) override;\n  void printMipsPLT(const MipsGOTParser<ELFT> &Parser) override;\n  void printMipsABIFlags() override;\n\n  ScopedPrinter &W;\n};\n\n} // end anonymous namespace\n\nnamespace llvm {\n\ntemplate <class ELFT>\nstatic std::unique_ptr<ObjDumper>\ncreateELFDumper(const ELFObjectFile<ELFT> &Obj, ScopedPrinter &Writer) {\n  if (opts::Output == opts::GNU)\n    return std::make_unique<GNUELFDumper<ELFT>>(Obj, Writer);\n  return std::make_unique<LLVMELFDumper<ELFT>>(Obj, Writer);\n}\n\nstd::unique_ptr<ObjDumper> createELFDumper(const object::ELFObjectFileBase &Obj,\n                                           ScopedPrinter &Writer) {\n  // Little-endian 32-bit\n  if (const ELF32LEObjectFile *ELFObj = dyn_cast<ELF32LEObjectFile>(&Obj))\n    return createELFDumper(*ELFObj, Writer);\n\n  // Big-endian 32-bit\n  if (const ELF32BEObjectFile *ELFObj = dyn_cast<ELF32BEObjectFile>(&Obj))\n    return createELFDumper(*ELFObj, Writer);\n\n  // Little-endian 64-bit\n  if (const ELF64LEObjectFile *ELFObj = dyn_cast<ELF64LEObjectFile>(&Obj))\n    return createELFDumper(*ELFObj, Writer);\n\n  // Big-endian 64-bit\n  return createELFDumper(*cast<ELF64BEObjectFile>(&Obj), Writer);\n}\n\n} // end namespace llvm\n\ntemplate <class ELFT>\nExpected<SmallVector<Optional<VersionEntry>, 0> *>\nELFDumper<ELFT>::getVersionMap() const {\n  // If the VersionMap has already been loaded or if there is no dynamic symtab\n  // or version table, there is nothing to do.\n  if (!VersionMap.empty() || !DynSymRegion || !SymbolVersionSection)\n    return &VersionMap;\n\n  Expected<SmallVector<Optional<VersionEntry>, 0>> MapOrErr =\n      Obj.loadVersionMap(SymbolVersionNeedSection, SymbolVersionDefSection);\n  if (MapOrErr)\n    VersionMap = *MapOrErr;\n  else\n    return MapOrErr.takeError();\n\n  return &VersionMap;\n}\n\ntemplate <typename ELFT>\nExpected<StringRef> ELFDumper<ELFT>::getSymbolVersion(const Elf_Sym &Sym,\n                                                      bool &IsDefault) const {\n  // This is a dynamic symbol. Look in the GNU symbol version table.\n  if (!SymbolVersionSection) {\n    // No version table.\n    IsDefault = false;\n    return \"\";\n  }\n\n  assert(DynSymRegion && \"DynSymRegion has not been initialised\");\n  // Determine the position in the symbol table of this entry.\n  size_t EntryIndex = (reinterpret_cast<uintptr_t>(&Sym) -\n                       reinterpret_cast<uintptr_t>(DynSymRegion->Addr)) /\n                      sizeof(Elf_Sym);\n\n  // Get the corresponding version index entry.\n  Expected<const Elf_Versym *> EntryOrErr =\n      Obj.template getEntry<Elf_Versym>(*SymbolVersionSection, EntryIndex);\n  if (!EntryOrErr)\n    return EntryOrErr.takeError();\n\n  unsigned Version = (*EntryOrErr)->vs_index;\n  if (Version == VER_NDX_LOCAL || Version == VER_NDX_GLOBAL) {\n    IsDefault = false;\n    return \"\";\n  }\n\n  Expected<SmallVector<Optional<VersionEntry>, 0> *> MapOrErr =\n      getVersionMap();\n  if (!MapOrErr)\n    return MapOrErr.takeError();\n\n  return Obj.getSymbolVersionByIndex(Version, IsDefault, **MapOrErr,\n                                     Sym.st_shndx == ELF::SHN_UNDEF);\n}\n\ntemplate <typename ELFT>\nExpected<RelSymbol<ELFT>>\nELFDumper<ELFT>::getRelocationTarget(const Relocation<ELFT> &R,\n                                     const Elf_Shdr *SymTab) const {\n  if (R.Symbol == 0)\n    return RelSymbol<ELFT>(nullptr, \"\");\n\n  Expected<const Elf_Sym *> SymOrErr =\n      Obj.template getEntry<Elf_Sym>(*SymTab, R.Symbol);\n  if (!SymOrErr)\n    return createError(\"unable to read an entry with index \" + Twine(R.Symbol) +\n                       \" from \" + describe(*SymTab) + \": \" +\n                       toString(SymOrErr.takeError()));\n  const Elf_Sym *Sym = *SymOrErr;\n  if (!Sym)\n    return RelSymbol<ELFT>(nullptr, \"\");\n\n  Expected<StringRef> StrTableOrErr = Obj.getStringTableForSymtab(*SymTab);\n  if (!StrTableOrErr)\n    return StrTableOrErr.takeError();\n\n  const Elf_Sym *FirstSym =\n      cantFail(Obj.template getEntry<Elf_Sym>(*SymTab, 0));\n  std::string SymbolName =\n      getFullSymbolName(*Sym, Sym - FirstSym, getShndxTable(SymTab),\n                        *StrTableOrErr, SymTab->sh_type == SHT_DYNSYM);\n  return RelSymbol<ELFT>(Sym, SymbolName);\n}\n\ntemplate <typename ELFT>\nArrayRef<typename ELFT::Word>\nELFDumper<ELFT>::getShndxTable(const Elf_Shdr *Symtab) const {\n  if (Symtab) {\n    auto It = ShndxTables.find(Symtab);\n    if (It != ShndxTables.end())\n      return It->second;\n  }\n  return {};\n}\n\nstatic std::string maybeDemangle(StringRef Name) {\n  return opts::Demangle ? demangle(std::string(Name)) : Name.str();\n}\n\ntemplate <typename ELFT>\nstd::string ELFDumper<ELFT>::getStaticSymbolName(uint32_t Index) const {\n  auto Warn = [&](Error E) -> std::string {\n    reportUniqueWarning(\"unable to read the name of symbol with index \" +\n                        Twine(Index) + \": \" + toString(std::move(E)));\n    return \"<?>\";\n  };\n\n  Expected<const typename ELFT::Sym *> SymOrErr =\n      Obj.getSymbol(DotSymtabSec, Index);\n  if (!SymOrErr)\n    return Warn(SymOrErr.takeError());\n\n  Expected<StringRef> StrTabOrErr = Obj.getStringTableForSymtab(*DotSymtabSec);\n  if (!StrTabOrErr)\n    return Warn(StrTabOrErr.takeError());\n\n  Expected<StringRef> NameOrErr = (*SymOrErr)->getName(*StrTabOrErr);\n  if (!NameOrErr)\n    return Warn(NameOrErr.takeError());\n  return maybeDemangle(*NameOrErr);\n}\n\ntemplate <typename ELFT>\nstd::string ELFDumper<ELFT>::getFullSymbolName(const Elf_Sym &Symbol,\n                                               unsigned SymIndex,\n                                               DataRegion<Elf_Word> ShndxTable,\n                                               Optional<StringRef> StrTable,\n                                               bool IsDynamic) const {\n  if (!StrTable)\n    return \"<?>\";\n\n  std::string SymbolName;\n  if (Expected<StringRef> NameOrErr = Symbol.getName(*StrTable)) {\n    SymbolName = maybeDemangle(*NameOrErr);\n  } else {\n    reportUniqueWarning(NameOrErr.takeError());\n    return \"<?>\";\n  }\n\n  if (SymbolName.empty() && Symbol.getType() == ELF::STT_SECTION) {\n    Expected<unsigned> SectionIndex =\n        getSymbolSectionIndex(Symbol, SymIndex, ShndxTable);\n    if (!SectionIndex) {\n      reportUniqueWarning(SectionIndex.takeError());\n      return \"<?>\";\n    }\n    Expected<StringRef> NameOrErr = getSymbolSectionName(Symbol, *SectionIndex);\n    if (!NameOrErr) {\n      reportUniqueWarning(NameOrErr.takeError());\n      return (\"<section \" + Twine(*SectionIndex) + \">\").str();\n    }\n    return std::string(*NameOrErr);\n  }\n\n  if (!IsDynamic)\n    return SymbolName;\n\n  bool IsDefault;\n  Expected<StringRef> VersionOrErr = getSymbolVersion(Symbol, IsDefault);\n  if (!VersionOrErr) {\n    reportUniqueWarning(VersionOrErr.takeError());\n    return SymbolName + \"@<corrupt>\";\n  }\n\n  if (!VersionOrErr->empty()) {\n    SymbolName += (IsDefault ? \"@@\" : \"@\");\n    SymbolName += *VersionOrErr;\n  }\n  return SymbolName;\n}\n\ntemplate <typename ELFT>\nExpected<unsigned>\nELFDumper<ELFT>::getSymbolSectionIndex(const Elf_Sym &Symbol, unsigned SymIndex,\n                                       DataRegion<Elf_Word> ShndxTable) const {\n  unsigned Ndx = Symbol.st_shndx;\n  if (Ndx == SHN_XINDEX)\n    return object::getExtendedSymbolTableIndex<ELFT>(Symbol, SymIndex,\n                                                     ShndxTable);\n  if (Ndx != SHN_UNDEF && Ndx < SHN_LORESERVE)\n    return Ndx;\n\n  auto CreateErr = [&](const Twine &Name, Optional<unsigned> Offset = None) {\n    std::string Desc;\n    if (Offset)\n      Desc = (Name + \"+0x\" + Twine::utohexstr(*Offset)).str();\n    else\n      Desc = Name.str();\n    return createError(\n        \"unable to get section index for symbol with st_shndx = 0x\" +\n        Twine::utohexstr(Ndx) + \" (\" + Desc + \")\");\n  };\n\n  if (Ndx >= ELF::SHN_LOPROC && Ndx <= ELF::SHN_HIPROC)\n    return CreateErr(\"SHN_LOPROC\", Ndx - ELF::SHN_LOPROC);\n  if (Ndx >= ELF::SHN_LOOS && Ndx <= ELF::SHN_HIOS)\n    return CreateErr(\"SHN_LOOS\", Ndx - ELF::SHN_LOOS);\n  if (Ndx == ELF::SHN_UNDEF)\n    return CreateErr(\"SHN_UNDEF\");\n  if (Ndx == ELF::SHN_ABS)\n    return CreateErr(\"SHN_ABS\");\n  if (Ndx == ELF::SHN_COMMON)\n    return CreateErr(\"SHN_COMMON\");\n  return CreateErr(\"SHN_LORESERVE\", Ndx - SHN_LORESERVE);\n}\n\ntemplate <typename ELFT>\nExpected<StringRef>\nELFDumper<ELFT>::getSymbolSectionName(const Elf_Sym &Symbol,\n                                      unsigned SectionIndex) const {\n  Expected<const Elf_Shdr *> SecOrErr = Obj.getSection(SectionIndex);\n  if (!SecOrErr)\n    return SecOrErr.takeError();\n  return Obj.getSectionName(**SecOrErr);\n}\n\ntemplate <class ELFO>\nstatic const typename ELFO::Elf_Shdr *\nfindNotEmptySectionByAddress(const ELFO &Obj, StringRef FileName,\n                             uint64_t Addr) {\n  for (const typename ELFO::Elf_Shdr &Shdr : cantFail(Obj.sections()))\n    if (Shdr.sh_addr == Addr && Shdr.sh_size > 0)\n      return &Shdr;\n  return nullptr;\n}\n\nstatic const EnumEntry<unsigned> ElfClass[] = {\n  {\"None\",   \"none\",   ELF::ELFCLASSNONE},\n  {\"32-bit\", \"ELF32\",  ELF::ELFCLASS32},\n  {\"64-bit\", \"ELF64\",  ELF::ELFCLASS64},\n};\n\nstatic const EnumEntry<unsigned> ElfDataEncoding[] = {\n  {\"None\",         \"none\",                          ELF::ELFDATANONE},\n  {\"LittleEndian\", \"2's complement, little endian\", ELF::ELFDATA2LSB},\n  {\"BigEndian\",    \"2's complement, big endian\",    ELF::ELFDATA2MSB},\n};\n\nstatic const EnumEntry<unsigned> ElfObjectFileType[] = {\n  {\"None\",         \"NONE (none)\",              ELF::ET_NONE},\n  {\"Relocatable\",  \"REL (Relocatable file)\",   ELF::ET_REL},\n  {\"Executable\",   \"EXEC (Executable file)\",   ELF::ET_EXEC},\n  {\"SharedObject\", \"DYN (Shared object file)\", ELF::ET_DYN},\n  {\"Core\",         \"CORE (Core file)\",         ELF::ET_CORE},\n};\n\nstatic const EnumEntry<unsigned> ElfOSABI[] = {\n  {\"SystemV\",      \"UNIX - System V\",      ELF::ELFOSABI_NONE},\n  {\"HPUX\",         \"UNIX - HP-UX\",         ELF::ELFOSABI_HPUX},\n  {\"NetBSD\",       \"UNIX - NetBSD\",        ELF::ELFOSABI_NETBSD},\n  {\"GNU/Linux\",    \"UNIX - GNU\",           ELF::ELFOSABI_LINUX},\n  {\"GNU/Hurd\",     \"GNU/Hurd\",             ELF::ELFOSABI_HURD},\n  {\"Solaris\",      \"UNIX - Solaris\",       ELF::ELFOSABI_SOLARIS},\n  {\"AIX\",          \"UNIX - AIX\",           ELF::ELFOSABI_AIX},\n  {\"IRIX\",         \"UNIX - IRIX\",          ELF::ELFOSABI_IRIX},\n  {\"FreeBSD\",      \"UNIX - FreeBSD\",       ELF::ELFOSABI_FREEBSD},\n  {\"TRU64\",        \"UNIX - TRU64\",         ELF::ELFOSABI_TRU64},\n  {\"Modesto\",      \"Novell - Modesto\",     ELF::ELFOSABI_MODESTO},\n  {\"OpenBSD\",      \"UNIX - OpenBSD\",       ELF::ELFOSABI_OPENBSD},\n  {\"OpenVMS\",      \"VMS - OpenVMS\",        ELF::ELFOSABI_OPENVMS},\n  {\"NSK\",          \"HP - Non-Stop Kernel\", ELF::ELFOSABI_NSK},\n  {\"AROS\",         \"AROS\",                 ELF::ELFOSABI_AROS},\n  {\"FenixOS\",      \"FenixOS\",              ELF::ELFOSABI_FENIXOS},\n  {\"CloudABI\",     \"CloudABI\",             ELF::ELFOSABI_CLOUDABI},\n  {\"Standalone\",   \"Standalone App\",       ELF::ELFOSABI_STANDALONE}\n};\n\nstatic const EnumEntry<unsigned> AMDGPUElfOSABI[] = {\n  {\"AMDGPU_HSA\",    \"AMDGPU - HSA\",    ELF::ELFOSABI_AMDGPU_HSA},\n  {\"AMDGPU_PAL\",    \"AMDGPU - PAL\",    ELF::ELFOSABI_AMDGPU_PAL},\n  {\"AMDGPU_MESA3D\", \"AMDGPU - MESA3D\", ELF::ELFOSABI_AMDGPU_MESA3D}\n};\n\nstatic const EnumEntry<unsigned> ARMElfOSABI[] = {\n  {\"ARM\", \"ARM\", ELF::ELFOSABI_ARM}\n};\n\nstatic const EnumEntry<unsigned> C6000ElfOSABI[] = {\n  {\"C6000_ELFABI\", \"Bare-metal C6000\", ELF::ELFOSABI_C6000_ELFABI},\n  {\"C6000_LINUX\",  \"Linux C6000\",      ELF::ELFOSABI_C6000_LINUX}\n};\n\nstatic const EnumEntry<unsigned> ElfMachineType[] = {\n  ENUM_ENT(EM_NONE,          \"None\"),\n  ENUM_ENT(EM_M32,           \"WE32100\"),\n  ENUM_ENT(EM_SPARC,         \"Sparc\"),\n  ENUM_ENT(EM_386,           \"Intel 80386\"),\n  ENUM_ENT(EM_68K,           \"MC68000\"),\n  ENUM_ENT(EM_88K,           \"MC88000\"),\n  ENUM_ENT(EM_IAMCU,         \"EM_IAMCU\"),\n  ENUM_ENT(EM_860,           \"Intel 80860\"),\n  ENUM_ENT(EM_MIPS,          \"MIPS R3000\"),\n  ENUM_ENT(EM_S370,          \"IBM System/370\"),\n  ENUM_ENT(EM_MIPS_RS3_LE,   \"MIPS R3000 little-endian\"),\n  ENUM_ENT(EM_PARISC,        \"HPPA\"),\n  ENUM_ENT(EM_VPP500,        \"Fujitsu VPP500\"),\n  ENUM_ENT(EM_SPARC32PLUS,   \"Sparc v8+\"),\n  ENUM_ENT(EM_960,           \"Intel 80960\"),\n  ENUM_ENT(EM_PPC,           \"PowerPC\"),\n  ENUM_ENT(EM_PPC64,         \"PowerPC64\"),\n  ENUM_ENT(EM_S390,          \"IBM S/390\"),\n  ENUM_ENT(EM_SPU,           \"SPU\"),\n  ENUM_ENT(EM_V800,          \"NEC V800 series\"),\n  ENUM_ENT(EM_FR20,          \"Fujistsu FR20\"),\n  ENUM_ENT(EM_RH32,          \"TRW RH-32\"),\n  ENUM_ENT(EM_RCE,           \"Motorola RCE\"),\n  ENUM_ENT(EM_ARM,           \"ARM\"),\n  ENUM_ENT(EM_ALPHA,         \"EM_ALPHA\"),\n  ENUM_ENT(EM_SH,            \"Hitachi SH\"),\n  ENUM_ENT(EM_SPARCV9,       \"Sparc v9\"),\n  ENUM_ENT(EM_TRICORE,       \"Siemens Tricore\"),\n  ENUM_ENT(EM_ARC,           \"ARC\"),\n  ENUM_ENT(EM_H8_300,        \"Hitachi H8/300\"),\n  ENUM_ENT(EM_H8_300H,       \"Hitachi H8/300H\"),\n  ENUM_ENT(EM_H8S,           \"Hitachi H8S\"),\n  ENUM_ENT(EM_H8_500,        \"Hitachi H8/500\"),\n  ENUM_ENT(EM_IA_64,         \"Intel IA-64\"),\n  ENUM_ENT(EM_MIPS_X,        \"Stanford MIPS-X\"),\n  ENUM_ENT(EM_COLDFIRE,      \"Motorola Coldfire\"),\n  ENUM_ENT(EM_68HC12,        \"Motorola MC68HC12 Microcontroller\"),\n  ENUM_ENT(EM_MMA,           \"Fujitsu Multimedia Accelerator\"),\n  ENUM_ENT(EM_PCP,           \"Siemens PCP\"),\n  ENUM_ENT(EM_NCPU,          \"Sony nCPU embedded RISC processor\"),\n  ENUM_ENT(EM_NDR1,          \"Denso NDR1 microprocesspr\"),\n  ENUM_ENT(EM_STARCORE,      \"Motorola Star*Core processor\"),\n  ENUM_ENT(EM_ME16,          \"Toyota ME16 processor\"),\n  ENUM_ENT(EM_ST100,         \"STMicroelectronics ST100 processor\"),\n  ENUM_ENT(EM_TINYJ,         \"Advanced Logic Corp. TinyJ embedded processor\"),\n  ENUM_ENT(EM_X86_64,        \"Advanced Micro Devices X86-64\"),\n  ENUM_ENT(EM_PDSP,          \"Sony DSP processor\"),\n  ENUM_ENT(EM_PDP10,         \"Digital Equipment Corp. PDP-10\"),\n  ENUM_ENT(EM_PDP11,         \"Digital Equipment Corp. PDP-11\"),\n  ENUM_ENT(EM_FX66,          \"Siemens FX66 microcontroller\"),\n  ENUM_ENT(EM_ST9PLUS,       \"STMicroelectronics ST9+ 8/16 bit microcontroller\"),\n  ENUM_ENT(EM_ST7,           \"STMicroelectronics ST7 8-bit microcontroller\"),\n  ENUM_ENT(EM_68HC16,        \"Motorola MC68HC16 Microcontroller\"),\n  ENUM_ENT(EM_68HC11,        \"Motorola MC68HC11 Microcontroller\"),\n  ENUM_ENT(EM_68HC08,        \"Motorola MC68HC08 Microcontroller\"),\n  ENUM_ENT(EM_68HC05,        \"Motorola MC68HC05 Microcontroller\"),\n  ENUM_ENT(EM_SVX,           \"Silicon Graphics SVx\"),\n  ENUM_ENT(EM_ST19,          \"STMicroelectronics ST19 8-bit microcontroller\"),\n  ENUM_ENT(EM_VAX,           \"Digital VAX\"),\n  ENUM_ENT(EM_CRIS,          \"Axis Communications 32-bit embedded processor\"),\n  ENUM_ENT(EM_JAVELIN,       \"Infineon Technologies 32-bit embedded cpu\"),\n  ENUM_ENT(EM_FIREPATH,      \"Element 14 64-bit DSP processor\"),\n  ENUM_ENT(EM_ZSP,           \"LSI Logic's 16-bit DSP processor\"),\n  ENUM_ENT(EM_MMIX,          \"Donald Knuth's educational 64-bit processor\"),\n  ENUM_ENT(EM_HUANY,         \"Harvard Universitys's machine-independent object format\"),\n  ENUM_ENT(EM_PRISM,         \"Vitesse Prism\"),\n  ENUM_ENT(EM_AVR,           \"Atmel AVR 8-bit microcontroller\"),\n  ENUM_ENT(EM_FR30,          \"Fujitsu FR30\"),\n  ENUM_ENT(EM_D10V,          \"Mitsubishi D10V\"),\n  ENUM_ENT(EM_D30V,          \"Mitsubishi D30V\"),\n  ENUM_ENT(EM_V850,          \"NEC v850\"),\n  ENUM_ENT(EM_M32R,          \"Renesas M32R (formerly Mitsubishi M32r)\"),\n  ENUM_ENT(EM_MN10300,       \"Matsushita MN10300\"),\n  ENUM_ENT(EM_MN10200,       \"Matsushita MN10200\"),\n  ENUM_ENT(EM_PJ,            \"picoJava\"),\n  ENUM_ENT(EM_OPENRISC,      \"OpenRISC 32-bit embedded processor\"),\n  ENUM_ENT(EM_ARC_COMPACT,   \"EM_ARC_COMPACT\"),\n  ENUM_ENT(EM_XTENSA,        \"Tensilica Xtensa Processor\"),\n  ENUM_ENT(EM_VIDEOCORE,     \"Alphamosaic VideoCore processor\"),\n  ENUM_ENT(EM_TMM_GPP,       \"Thompson Multimedia General Purpose Processor\"),\n  ENUM_ENT(EM_NS32K,         \"National Semiconductor 32000 series\"),\n  ENUM_ENT(EM_TPC,           \"Tenor Network TPC processor\"),\n  ENUM_ENT(EM_SNP1K,         \"EM_SNP1K\"),\n  ENUM_ENT(EM_ST200,         \"STMicroelectronics ST200 microcontroller\"),\n  ENUM_ENT(EM_IP2K,          \"Ubicom IP2xxx 8-bit microcontrollers\"),\n  ENUM_ENT(EM_MAX,           \"MAX Processor\"),\n  ENUM_ENT(EM_CR,            \"National Semiconductor CompactRISC\"),\n  ENUM_ENT(EM_F2MC16,        \"Fujitsu F2MC16\"),\n  ENUM_ENT(EM_MSP430,        \"Texas Instruments msp430 microcontroller\"),\n  ENUM_ENT(EM_BLACKFIN,      \"Analog Devices Blackfin\"),\n  ENUM_ENT(EM_SE_C33,        \"S1C33 Family of Seiko Epson processors\"),\n  ENUM_ENT(EM_SEP,           \"Sharp embedded microprocessor\"),\n  ENUM_ENT(EM_ARCA,          \"Arca RISC microprocessor\"),\n  ENUM_ENT(EM_UNICORE,       \"Unicore\"),\n  ENUM_ENT(EM_EXCESS,        \"eXcess 16/32/64-bit configurable embedded CPU\"),\n  ENUM_ENT(EM_DXP,           \"Icera Semiconductor Inc. Deep Execution Processor\"),\n  ENUM_ENT(EM_ALTERA_NIOS2,  \"Altera Nios\"),\n  ENUM_ENT(EM_CRX,           \"National Semiconductor CRX microprocessor\"),\n  ENUM_ENT(EM_XGATE,         \"Motorola XGATE embedded processor\"),\n  ENUM_ENT(EM_C166,          \"Infineon Technologies xc16x\"),\n  ENUM_ENT(EM_M16C,          \"Renesas M16C\"),\n  ENUM_ENT(EM_DSPIC30F,      \"Microchip Technology dsPIC30F Digital Signal Controller\"),\n  ENUM_ENT(EM_CE,            \"Freescale Communication Engine RISC core\"),\n  ENUM_ENT(EM_M32C,          \"Renesas M32C\"),\n  ENUM_ENT(EM_TSK3000,       \"Altium TSK3000 core\"),\n  ENUM_ENT(EM_RS08,          \"Freescale RS08 embedded processor\"),\n  ENUM_ENT(EM_SHARC,         \"EM_SHARC\"),\n  ENUM_ENT(EM_ECOG2,         \"Cyan Technology eCOG2 microprocessor\"),\n  ENUM_ENT(EM_SCORE7,        \"SUNPLUS S+Core\"),\n  ENUM_ENT(EM_DSP24,         \"New Japan Radio (NJR) 24-bit DSP Processor\"),\n  ENUM_ENT(EM_VIDEOCORE3,    \"Broadcom VideoCore III processor\"),\n  ENUM_ENT(EM_LATTICEMICO32, \"Lattice Mico32\"),\n  ENUM_ENT(EM_SE_C17,        \"Seiko Epson C17 family\"),\n  ENUM_ENT(EM_TI_C6000,      \"Texas Instruments TMS320C6000 DSP family\"),\n  ENUM_ENT(EM_TI_C2000,      \"Texas Instruments TMS320C2000 DSP family\"),\n  ENUM_ENT(EM_TI_C5500,      \"Texas Instruments TMS320C55x DSP family\"),\n  ENUM_ENT(EM_MMDSP_PLUS,    \"STMicroelectronics 64bit VLIW Data Signal Processor\"),\n  ENUM_ENT(EM_CYPRESS_M8C,   \"Cypress M8C microprocessor\"),\n  ENUM_ENT(EM_R32C,          \"Renesas R32C series microprocessors\"),\n  ENUM_ENT(EM_TRIMEDIA,      \"NXP Semiconductors TriMedia architecture family\"),\n  ENUM_ENT(EM_HEXAGON,       \"Qualcomm Hexagon\"),\n  ENUM_ENT(EM_8051,          \"Intel 8051 and variants\"),\n  ENUM_ENT(EM_STXP7X,        \"STMicroelectronics STxP7x family\"),\n  ENUM_ENT(EM_NDS32,         \"Andes Technology compact code size embedded RISC processor family\"),\n  ENUM_ENT(EM_ECOG1,         \"Cyan Technology eCOG1 microprocessor\"),\n  // FIXME: Following EM_ECOG1X definitions is dead code since EM_ECOG1X has\n  //        an identical number to EM_ECOG1.\n  ENUM_ENT(EM_ECOG1X,        \"Cyan Technology eCOG1X family\"),\n  ENUM_ENT(EM_MAXQ30,        \"Dallas Semiconductor MAXQ30 Core microcontrollers\"),\n  ENUM_ENT(EM_XIMO16,        \"New Japan Radio (NJR) 16-bit DSP Processor\"),\n  ENUM_ENT(EM_MANIK,         \"M2000 Reconfigurable RISC Microprocessor\"),\n  ENUM_ENT(EM_CRAYNV2,       \"Cray Inc. NV2 vector architecture\"),\n  ENUM_ENT(EM_RX,            \"Renesas RX\"),\n  ENUM_ENT(EM_METAG,         \"Imagination Technologies Meta processor architecture\"),\n  ENUM_ENT(EM_MCST_ELBRUS,   \"MCST Elbrus general purpose hardware architecture\"),\n  ENUM_ENT(EM_ECOG16,        \"Cyan Technology eCOG16 family\"),\n  ENUM_ENT(EM_CR16,          \"Xilinx MicroBlaze\"),\n  ENUM_ENT(EM_ETPU,          \"Freescale Extended Time Processing Unit\"),\n  ENUM_ENT(EM_SLE9X,         \"Infineon Technologies SLE9X core\"),\n  ENUM_ENT(EM_L10M,          \"EM_L10M\"),\n  ENUM_ENT(EM_K10M,          \"EM_K10M\"),\n  ENUM_ENT(EM_AARCH64,       \"AArch64\"),\n  ENUM_ENT(EM_AVR32,         \"Atmel Corporation 32-bit microprocessor family\"),\n  ENUM_ENT(EM_STM8,          \"STMicroeletronics STM8 8-bit microcontroller\"),\n  ENUM_ENT(EM_TILE64,        \"Tilera TILE64 multicore architecture family\"),\n  ENUM_ENT(EM_TILEPRO,       \"Tilera TILEPro multicore architecture family\"),\n  ENUM_ENT(EM_CUDA,          \"NVIDIA CUDA architecture\"),\n  ENUM_ENT(EM_TILEGX,        \"Tilera TILE-Gx multicore architecture family\"),\n  ENUM_ENT(EM_CLOUDSHIELD,   \"EM_CLOUDSHIELD\"),\n  ENUM_ENT(EM_COREA_1ST,     \"EM_COREA_1ST\"),\n  ENUM_ENT(EM_COREA_2ND,     \"EM_COREA_2ND\"),\n  ENUM_ENT(EM_ARC_COMPACT2,  \"EM_ARC_COMPACT2\"),\n  ENUM_ENT(EM_OPEN8,         \"EM_OPEN8\"),\n  ENUM_ENT(EM_RL78,          \"Renesas RL78\"),\n  ENUM_ENT(EM_VIDEOCORE5,    \"Broadcom VideoCore V processor\"),\n  ENUM_ENT(EM_78KOR,         \"EM_78KOR\"),\n  ENUM_ENT(EM_56800EX,       \"EM_56800EX\"),\n  ENUM_ENT(EM_AMDGPU,        \"EM_AMDGPU\"),\n  ENUM_ENT(EM_RISCV,         \"RISC-V\"),\n  ENUM_ENT(EM_LANAI,         \"EM_LANAI\"),\n  ENUM_ENT(EM_BPF,           \"EM_BPF\"),\n  ENUM_ENT(EM_VE,            \"NEC SX-Aurora Vector Engine\"),\n};\n\nstatic const EnumEntry<unsigned> ElfSymbolBindings[] = {\n    {\"Local\",  \"LOCAL\",  ELF::STB_LOCAL},\n    {\"Global\", \"GLOBAL\", ELF::STB_GLOBAL},\n    {\"Weak\",   \"WEAK\",   ELF::STB_WEAK},\n    {\"Unique\", \"UNIQUE\", ELF::STB_GNU_UNIQUE}};\n\nstatic const EnumEntry<unsigned> ElfSymbolVisibilities[] = {\n    {\"DEFAULT\",   \"DEFAULT\",   ELF::STV_DEFAULT},\n    {\"INTERNAL\",  \"INTERNAL\",  ELF::STV_INTERNAL},\n    {\"HIDDEN\",    \"HIDDEN\",    ELF::STV_HIDDEN},\n    {\"PROTECTED\", \"PROTECTED\", ELF::STV_PROTECTED}};\n\nstatic const EnumEntry<unsigned> AMDGPUSymbolTypes[] = {\n  { \"AMDGPU_HSA_KERNEL\",            ELF::STT_AMDGPU_HSA_KERNEL }\n};\n\nstatic const char *getGroupType(uint32_t Flag) {\n  if (Flag & ELF::GRP_COMDAT)\n    return \"COMDAT\";\n  else\n    return \"(unknown)\";\n}\n\nstatic const EnumEntry<unsigned> ElfSectionFlags[] = {\n  ENUM_ENT(SHF_WRITE,            \"W\"),\n  ENUM_ENT(SHF_ALLOC,            \"A\"),\n  ENUM_ENT(SHF_EXECINSTR,        \"X\"),\n  ENUM_ENT(SHF_MERGE,            \"M\"),\n  ENUM_ENT(SHF_STRINGS,          \"S\"),\n  ENUM_ENT(SHF_INFO_LINK,        \"I\"),\n  ENUM_ENT(SHF_LINK_ORDER,       \"L\"),\n  ENUM_ENT(SHF_OS_NONCONFORMING, \"O\"),\n  ENUM_ENT(SHF_GROUP,            \"G\"),\n  ENUM_ENT(SHF_TLS,              \"T\"),\n  ENUM_ENT(SHF_COMPRESSED,       \"C\"),\n  ENUM_ENT(SHF_GNU_RETAIN,       \"R\"),\n  ENUM_ENT(SHF_EXCLUDE,          \"E\"),\n};\n\nstatic const EnumEntry<unsigned> ElfXCoreSectionFlags[] = {\n  ENUM_ENT(XCORE_SHF_CP_SECTION, \"\"),\n  ENUM_ENT(XCORE_SHF_DP_SECTION, \"\")\n};\n\nstatic const EnumEntry<unsigned> ElfARMSectionFlags[] = {\n  ENUM_ENT(SHF_ARM_PURECODE, \"y\")\n};\n\nstatic const EnumEntry<unsigned> ElfHexagonSectionFlags[] = {\n  ENUM_ENT(SHF_HEX_GPREL, \"\")\n};\n\nstatic const EnumEntry<unsigned> ElfMipsSectionFlags[] = {\n  ENUM_ENT(SHF_MIPS_NODUPES, \"\"),\n  ENUM_ENT(SHF_MIPS_NAMES,   \"\"),\n  ENUM_ENT(SHF_MIPS_LOCAL,   \"\"),\n  ENUM_ENT(SHF_MIPS_NOSTRIP, \"\"),\n  ENUM_ENT(SHF_MIPS_GPREL,   \"\"),\n  ENUM_ENT(SHF_MIPS_MERGE,   \"\"),\n  ENUM_ENT(SHF_MIPS_ADDR,    \"\"),\n  ENUM_ENT(SHF_MIPS_STRING,  \"\")\n};\n\nstatic const EnumEntry<unsigned> ElfX86_64SectionFlags[] = {\n  ENUM_ENT(SHF_X86_64_LARGE, \"l\")\n};\n\nstatic std::vector<EnumEntry<unsigned>>\ngetSectionFlagsForTarget(unsigned EMachine) {\n  std::vector<EnumEntry<unsigned>> Ret(std::begin(ElfSectionFlags),\n                                       std::end(ElfSectionFlags));\n  switch (EMachine) {\n  case EM_ARM:\n    Ret.insert(Ret.end(), std::begin(ElfARMSectionFlags),\n               std::end(ElfARMSectionFlags));\n    break;\n  case EM_HEXAGON:\n    Ret.insert(Ret.end(), std::begin(ElfHexagonSectionFlags),\n               std::end(ElfHexagonSectionFlags));\n    break;\n  case EM_MIPS:\n    Ret.insert(Ret.end(), std::begin(ElfMipsSectionFlags),\n               std::end(ElfMipsSectionFlags));\n    break;\n  case EM_X86_64:\n    Ret.insert(Ret.end(), std::begin(ElfX86_64SectionFlags),\n               std::end(ElfX86_64SectionFlags));\n    break;\n  case EM_XCORE:\n    Ret.insert(Ret.end(), std::begin(ElfXCoreSectionFlags),\n               std::end(ElfXCoreSectionFlags));\n    break;\n  default:\n    break;\n  }\n  return Ret;\n}\n\nstatic std::string getGNUFlags(unsigned EMachine, uint64_t Flags) {\n  // Here we are trying to build the flags string in the same way as GNU does.\n  // It is not that straightforward. Imagine we have sh_flags == 0x90000000.\n  // SHF_EXCLUDE (\"E\") has a value of 0x80000000 and SHF_MASKPROC is 0xf0000000.\n  // GNU readelf will not print \"E\" or \"Ep\" in this case, but will print just\n  // \"p\". It only will print \"E\" when no other processor flag is set.\n  std::string Str;\n  bool HasUnknownFlag = false;\n  bool HasOSFlag = false;\n  bool HasProcFlag = false;\n  std::vector<EnumEntry<unsigned>> FlagsList =\n      getSectionFlagsForTarget(EMachine);\n  while (Flags) {\n    // Take the least significant bit as a flag.\n    uint64_t Flag = Flags & -Flags;\n    Flags -= Flag;\n\n    // Find the flag in the known flags list.\n    auto I = llvm::find_if(FlagsList, [=](const EnumEntry<unsigned> &E) {\n      // Flags with empty names are not printed in GNU style output.\n      return E.Value == Flag && !E.AltName.empty();\n    });\n    if (I != FlagsList.end()) {\n      Str += I->AltName;\n      continue;\n    }\n\n    // If we did not find a matching regular flag, then we deal with an OS\n    // specific flag, processor specific flag or an unknown flag.\n    if (Flag & ELF::SHF_MASKOS) {\n      HasOSFlag = true;\n      Flags &= ~ELF::SHF_MASKOS;\n    } else if (Flag & ELF::SHF_MASKPROC) {\n      HasProcFlag = true;\n      // Mask off all the processor-specific bits. This removes the SHF_EXCLUDE\n      // bit if set so that it doesn't also get printed.\n      Flags &= ~ELF::SHF_MASKPROC;\n    } else {\n      HasUnknownFlag = true;\n    }\n  }\n\n  // \"o\", \"p\" and \"x\" are printed last.\n  if (HasOSFlag)\n    Str += \"o\";\n  if (HasProcFlag)\n    Str += \"p\";\n  if (HasUnknownFlag)\n    Str += \"x\";\n  return Str;\n}\n\nstatic StringRef segmentTypeToString(unsigned Arch, unsigned Type) {\n  // Check potentially overlapped processor-specific program header type.\n  switch (Arch) {\n  case ELF::EM_ARM:\n    switch (Type) { LLVM_READOBJ_ENUM_CASE(ELF, PT_ARM_EXIDX); }\n    break;\n  case ELF::EM_MIPS:\n  case ELF::EM_MIPS_RS3_LE:\n    switch (Type) {\n      LLVM_READOBJ_ENUM_CASE(ELF, PT_MIPS_REGINFO);\n      LLVM_READOBJ_ENUM_CASE(ELF, PT_MIPS_RTPROC);\n      LLVM_READOBJ_ENUM_CASE(ELF, PT_MIPS_OPTIONS);\n      LLVM_READOBJ_ENUM_CASE(ELF, PT_MIPS_ABIFLAGS);\n    }\n    break;\n  }\n\n  switch (Type) {\n    LLVM_READOBJ_ENUM_CASE(ELF, PT_NULL);\n    LLVM_READOBJ_ENUM_CASE(ELF, PT_LOAD);\n    LLVM_READOBJ_ENUM_CASE(ELF, PT_DYNAMIC);\n    LLVM_READOBJ_ENUM_CASE(ELF, PT_INTERP);\n    LLVM_READOBJ_ENUM_CASE(ELF, PT_NOTE);\n    LLVM_READOBJ_ENUM_CASE(ELF, PT_SHLIB);\n    LLVM_READOBJ_ENUM_CASE(ELF, PT_PHDR);\n    LLVM_READOBJ_ENUM_CASE(ELF, PT_TLS);\n\n    LLVM_READOBJ_ENUM_CASE(ELF, PT_GNU_EH_FRAME);\n    LLVM_READOBJ_ENUM_CASE(ELF, PT_SUNW_UNWIND);\n\n    LLVM_READOBJ_ENUM_CASE(ELF, PT_GNU_STACK);\n    LLVM_READOBJ_ENUM_CASE(ELF, PT_GNU_RELRO);\n    LLVM_READOBJ_ENUM_CASE(ELF, PT_GNU_PROPERTY);\n\n    LLVM_READOBJ_ENUM_CASE(ELF, PT_OPENBSD_RANDOMIZE);\n    LLVM_READOBJ_ENUM_CASE(ELF, PT_OPENBSD_WXNEEDED);\n    LLVM_READOBJ_ENUM_CASE(ELF, PT_OPENBSD_BOOTDATA);\n  default:\n    return \"\";\n  }\n}\n\nstatic std::string getGNUPtType(unsigned Arch, unsigned Type) {\n  StringRef Seg = segmentTypeToString(Arch, Type);\n  if (Seg.empty())\n    return std::string(\"<unknown>: \") + to_string(format_hex(Type, 1));\n\n  // E.g. \"PT_ARM_EXIDX\" -> \"EXIDX\".\n  if (Seg.startswith(\"PT_ARM_\"))\n    return Seg.drop_front(7).str();\n\n  // E.g. \"PT_MIPS_REGINFO\" -> \"REGINFO\".\n  if (Seg.startswith(\"PT_MIPS_\"))\n    return Seg.drop_front(8).str();\n\n  // E.g. \"PT_LOAD\" -> \"LOAD\".\n  assert(Seg.startswith(\"PT_\"));\n  return Seg.drop_front(3).str();\n}\n\nstatic const EnumEntry<unsigned> ElfSegmentFlags[] = {\n  LLVM_READOBJ_ENUM_ENT(ELF, PF_X),\n  LLVM_READOBJ_ENUM_ENT(ELF, PF_W),\n  LLVM_READOBJ_ENUM_ENT(ELF, PF_R)\n};\n\nstatic const EnumEntry<unsigned> ElfHeaderMipsFlags[] = {\n  ENUM_ENT(EF_MIPS_NOREORDER, \"noreorder\"),\n  ENUM_ENT(EF_MIPS_PIC, \"pic\"),\n  ENUM_ENT(EF_MIPS_CPIC, \"cpic\"),\n  ENUM_ENT(EF_MIPS_ABI2, \"abi2\"),\n  ENUM_ENT(EF_MIPS_32BITMODE, \"32bitmode\"),\n  ENUM_ENT(EF_MIPS_FP64, \"fp64\"),\n  ENUM_ENT(EF_MIPS_NAN2008, \"nan2008\"),\n  ENUM_ENT(EF_MIPS_ABI_O32, \"o32\"),\n  ENUM_ENT(EF_MIPS_ABI_O64, \"o64\"),\n  ENUM_ENT(EF_MIPS_ABI_EABI32, \"eabi32\"),\n  ENUM_ENT(EF_MIPS_ABI_EABI64, \"eabi64\"),\n  ENUM_ENT(EF_MIPS_MACH_3900, \"3900\"),\n  ENUM_ENT(EF_MIPS_MACH_4010, \"4010\"),\n  ENUM_ENT(EF_MIPS_MACH_4100, \"4100\"),\n  ENUM_ENT(EF_MIPS_MACH_4650, \"4650\"),\n  ENUM_ENT(EF_MIPS_MACH_4120, \"4120\"),\n  ENUM_ENT(EF_MIPS_MACH_4111, \"4111\"),\n  ENUM_ENT(EF_MIPS_MACH_SB1, \"sb1\"),\n  ENUM_ENT(EF_MIPS_MACH_OCTEON, \"octeon\"),\n  ENUM_ENT(EF_MIPS_MACH_XLR, \"xlr\"),\n  ENUM_ENT(EF_MIPS_MACH_OCTEON2, \"octeon2\"),\n  ENUM_ENT(EF_MIPS_MACH_OCTEON3, \"octeon3\"),\n  ENUM_ENT(EF_MIPS_MACH_5400, \"5400\"),\n  ENUM_ENT(EF_MIPS_MACH_5900, \"5900\"),\n  ENUM_ENT(EF_MIPS_MACH_5500, \"5500\"),\n  ENUM_ENT(EF_MIPS_MACH_9000, \"9000\"),\n  ENUM_ENT(EF_MIPS_MACH_LS2E, \"loongson-2e\"),\n  ENUM_ENT(EF_MIPS_MACH_LS2F, \"loongson-2f\"),\n  ENUM_ENT(EF_MIPS_MACH_LS3A, \"loongson-3a\"),\n  ENUM_ENT(EF_MIPS_MICROMIPS, \"micromips\"),\n  ENUM_ENT(EF_MIPS_ARCH_ASE_M16, \"mips16\"),\n  ENUM_ENT(EF_MIPS_ARCH_ASE_MDMX, \"mdmx\"),\n  ENUM_ENT(EF_MIPS_ARCH_1, \"mips1\"),\n  ENUM_ENT(EF_MIPS_ARCH_2, \"mips2\"),\n  ENUM_ENT(EF_MIPS_ARCH_3, \"mips3\"),\n  ENUM_ENT(EF_MIPS_ARCH_4, \"mips4\"),\n  ENUM_ENT(EF_MIPS_ARCH_5, \"mips5\"),\n  ENUM_ENT(EF_MIPS_ARCH_32, \"mips32\"),\n  ENUM_ENT(EF_MIPS_ARCH_64, \"mips64\"),\n  ENUM_ENT(EF_MIPS_ARCH_32R2, \"mips32r2\"),\n  ENUM_ENT(EF_MIPS_ARCH_64R2, \"mips64r2\"),\n  ENUM_ENT(EF_MIPS_ARCH_32R6, \"mips32r6\"),\n  ENUM_ENT(EF_MIPS_ARCH_64R6, \"mips64r6\")\n};\n\nstatic const EnumEntry<unsigned> ElfHeaderAMDGPUFlags[] = {\n  LLVM_READOBJ_ENUM_ENT(ELF, EF_AMDGPU_MACH_NONE),\n  LLVM_READOBJ_ENUM_ENT(ELF, EF_AMDGPU_MACH_R600_R600),\n  LLVM_READOBJ_ENUM_ENT(ELF, EF_AMDGPU_MACH_R600_R630),\n  LLVM_READOBJ_ENUM_ENT(ELF, EF_AMDGPU_MACH_R600_RS880),\n  LLVM_READOBJ_ENUM_ENT(ELF, EF_AMDGPU_MACH_R600_RV670),\n  LLVM_READOBJ_ENUM_ENT(ELF, EF_AMDGPU_MACH_R600_RV710),\n  LLVM_READOBJ_ENUM_ENT(ELF, EF_AMDGPU_MACH_R600_RV730),\n  LLVM_READOBJ_ENUM_ENT(ELF, EF_AMDGPU_MACH_R600_RV770),\n  LLVM_READOBJ_ENUM_ENT(ELF, EF_AMDGPU_MACH_R600_CEDAR),\n  LLVM_READOBJ_ENUM_ENT(ELF, EF_AMDGPU_MACH_R600_CYPRESS),\n  LLVM_READOBJ_ENUM_ENT(ELF, EF_AMDGPU_MACH_R600_JUNIPER),\n  LLVM_READOBJ_ENUM_ENT(ELF, EF_AMDGPU_MACH_R600_REDWOOD),\n  LLVM_READOBJ_ENUM_ENT(ELF, EF_AMDGPU_MACH_R600_SUMO),\n  LLVM_READOBJ_ENUM_ENT(ELF, EF_AMDGPU_MACH_R600_BARTS),\n  LLVM_READOBJ_ENUM_ENT(ELF, EF_AMDGPU_MACH_R600_CAICOS),\n  LLVM_READOBJ_ENUM_ENT(ELF, EF_AMDGPU_MACH_R600_CAYMAN),\n  LLVM_READOBJ_ENUM_ENT(ELF, EF_AMDGPU_MACH_R600_TURKS),\n  LLVM_READOBJ_ENUM_ENT(ELF, EF_AMDGPU_MACH_AMDGCN_GFX600),\n  LLVM_READOBJ_ENUM_ENT(ELF, EF_AMDGPU_MACH_AMDGCN_GFX601),\n  LLVM_READOBJ_ENUM_ENT(ELF, EF_AMDGPU_MACH_AMDGCN_GFX602),\n  LLVM_READOBJ_ENUM_ENT(ELF, EF_AMDGPU_MACH_AMDGCN_GFX700),\n  LLVM_READOBJ_ENUM_ENT(ELF, EF_AMDGPU_MACH_AMDGCN_GFX701),\n  LLVM_READOBJ_ENUM_ENT(ELF, EF_AMDGPU_MACH_AMDGCN_GFX702),\n  LLVM_READOBJ_ENUM_ENT(ELF, EF_AMDGPU_MACH_AMDGCN_GFX703),\n  LLVM_READOBJ_ENUM_ENT(ELF, EF_AMDGPU_MACH_AMDGCN_GFX704),\n  LLVM_READOBJ_ENUM_ENT(ELF, EF_AMDGPU_MACH_AMDGCN_GFX705),\n  LLVM_READOBJ_ENUM_ENT(ELF, EF_AMDGPU_MACH_AMDGCN_GFX801),\n  LLVM_READOBJ_ENUM_ENT(ELF, EF_AMDGPU_MACH_AMDGCN_GFX802),\n  LLVM_READOBJ_ENUM_ENT(ELF, EF_AMDGPU_MACH_AMDGCN_GFX803),\n  LLVM_READOBJ_ENUM_ENT(ELF, EF_AMDGPU_MACH_AMDGCN_GFX805),\n  LLVM_READOBJ_ENUM_ENT(ELF, EF_AMDGPU_MACH_AMDGCN_GFX810),\n  LLVM_READOBJ_ENUM_ENT(ELF, EF_AMDGPU_MACH_AMDGCN_GFX900),\n  LLVM_READOBJ_ENUM_ENT(ELF, EF_AMDGPU_MACH_AMDGCN_GFX902),\n  LLVM_READOBJ_ENUM_ENT(ELF, EF_AMDGPU_MACH_AMDGCN_GFX904),\n  LLVM_READOBJ_ENUM_ENT(ELF, EF_AMDGPU_MACH_AMDGCN_GFX906),\n  LLVM_READOBJ_ENUM_ENT(ELF, EF_AMDGPU_MACH_AMDGCN_GFX908),\n  LLVM_READOBJ_ENUM_ENT(ELF, EF_AMDGPU_MACH_AMDGCN_GFX909),\n  LLVM_READOBJ_ENUM_ENT(ELF, EF_AMDGPU_MACH_AMDGCN_GFX90A),\n  LLVM_READOBJ_ENUM_ENT(ELF, EF_AMDGPU_MACH_AMDGCN_GFX90C),\n  LLVM_READOBJ_ENUM_ENT(ELF, EF_AMDGPU_MACH_AMDGCN_GFX1010),\n  LLVM_READOBJ_ENUM_ENT(ELF, EF_AMDGPU_MACH_AMDGCN_GFX1011),\n  LLVM_READOBJ_ENUM_ENT(ELF, EF_AMDGPU_MACH_AMDGCN_GFX1012),\n  LLVM_READOBJ_ENUM_ENT(ELF, EF_AMDGPU_MACH_AMDGCN_GFX1030),\n  LLVM_READOBJ_ENUM_ENT(ELF, EF_AMDGPU_MACH_AMDGCN_GFX1031),\n  LLVM_READOBJ_ENUM_ENT(ELF, EF_AMDGPU_MACH_AMDGCN_GFX1032),\n  LLVM_READOBJ_ENUM_ENT(ELF, EF_AMDGPU_MACH_AMDGCN_GFX1033),\n  LLVM_READOBJ_ENUM_ENT(ELF, EF_AMDGPU_XNACK),\n  LLVM_READOBJ_ENUM_ENT(ELF, EF_AMDGPU_SRAM_ECC)\n};\n\nstatic const EnumEntry<unsigned> ElfHeaderRISCVFlags[] = {\n  ENUM_ENT(EF_RISCV_RVC, \"RVC\"),\n  ENUM_ENT(EF_RISCV_FLOAT_ABI_SINGLE, \"single-float ABI\"),\n  ENUM_ENT(EF_RISCV_FLOAT_ABI_DOUBLE, \"double-float ABI\"),\n  ENUM_ENT(EF_RISCV_FLOAT_ABI_QUAD, \"quad-float ABI\"),\n  ENUM_ENT(EF_RISCV_RVE, \"RVE\")\n};\n\nstatic const EnumEntry<unsigned> ElfSymOtherFlags[] = {\n  LLVM_READOBJ_ENUM_ENT(ELF, STV_INTERNAL),\n  LLVM_READOBJ_ENUM_ENT(ELF, STV_HIDDEN),\n  LLVM_READOBJ_ENUM_ENT(ELF, STV_PROTECTED)\n};\n\nstatic const EnumEntry<unsigned> ElfMipsSymOtherFlags[] = {\n  LLVM_READOBJ_ENUM_ENT(ELF, STO_MIPS_OPTIONAL),\n  LLVM_READOBJ_ENUM_ENT(ELF, STO_MIPS_PLT),\n  LLVM_READOBJ_ENUM_ENT(ELF, STO_MIPS_PIC),\n  LLVM_READOBJ_ENUM_ENT(ELF, STO_MIPS_MICROMIPS)\n};\n\nstatic const EnumEntry<unsigned> ElfAArch64SymOtherFlags[] = {\n  LLVM_READOBJ_ENUM_ENT(ELF, STO_AARCH64_VARIANT_PCS)\n};\n\nstatic const EnumEntry<unsigned> ElfMips16SymOtherFlags[] = {\n  LLVM_READOBJ_ENUM_ENT(ELF, STO_MIPS_OPTIONAL),\n  LLVM_READOBJ_ENUM_ENT(ELF, STO_MIPS_PLT),\n  LLVM_READOBJ_ENUM_ENT(ELF, STO_MIPS_MIPS16)\n};\n\nstatic const char *getElfMipsOptionsOdkType(unsigned Odk) {\n  switch (Odk) {\n  LLVM_READOBJ_ENUM_CASE(ELF, ODK_NULL);\n  LLVM_READOBJ_ENUM_CASE(ELF, ODK_REGINFO);\n  LLVM_READOBJ_ENUM_CASE(ELF, ODK_EXCEPTIONS);\n  LLVM_READOBJ_ENUM_CASE(ELF, ODK_PAD);\n  LLVM_READOBJ_ENUM_CASE(ELF, ODK_HWPATCH);\n  LLVM_READOBJ_ENUM_CASE(ELF, ODK_FILL);\n  LLVM_READOBJ_ENUM_CASE(ELF, ODK_TAGS);\n  LLVM_READOBJ_ENUM_CASE(ELF, ODK_HWAND);\n  LLVM_READOBJ_ENUM_CASE(ELF, ODK_HWOR);\n  LLVM_READOBJ_ENUM_CASE(ELF, ODK_GP_GROUP);\n  LLVM_READOBJ_ENUM_CASE(ELF, ODK_IDENT);\n  LLVM_READOBJ_ENUM_CASE(ELF, ODK_PAGESIZE);\n  default:\n    return \"Unknown\";\n  }\n}\n\ntemplate <typename ELFT>\nstd::pair<const typename ELFT::Phdr *, const typename ELFT::Shdr *>\nELFDumper<ELFT>::findDynamic() {\n  // Try to locate the PT_DYNAMIC header.\n  const Elf_Phdr *DynamicPhdr = nullptr;\n  if (Expected<ArrayRef<Elf_Phdr>> PhdrsOrErr = Obj.program_headers()) {\n    for (const Elf_Phdr &Phdr : *PhdrsOrErr) {\n      if (Phdr.p_type != ELF::PT_DYNAMIC)\n        continue;\n      DynamicPhdr = &Phdr;\n      break;\n    }\n  } else {\n    reportUniqueWarning(\n        \"unable to read program headers to locate the PT_DYNAMIC segment: \" +\n        toString(PhdrsOrErr.takeError()));\n  }\n\n  // Try to locate the .dynamic section in the sections header table.\n  const Elf_Shdr *DynamicSec = nullptr;\n  for (const Elf_Shdr &Sec : cantFail(Obj.sections())) {\n    if (Sec.sh_type != ELF::SHT_DYNAMIC)\n      continue;\n    DynamicSec = &Sec;\n    break;\n  }\n\n  if (DynamicPhdr && ((DynamicPhdr->p_offset + DynamicPhdr->p_filesz >\n                       ObjF.getMemoryBufferRef().getBufferSize()) ||\n                      (DynamicPhdr->p_offset + DynamicPhdr->p_filesz <\n                       DynamicPhdr->p_offset))) {\n    reportUniqueWarning(\n        \"PT_DYNAMIC segment offset (0x\" +\n        Twine::utohexstr(DynamicPhdr->p_offset) + \") + file size (0x\" +\n        Twine::utohexstr(DynamicPhdr->p_filesz) +\n        \") exceeds the size of the file (0x\" +\n        Twine::utohexstr(ObjF.getMemoryBufferRef().getBufferSize()) + \")\");\n    // Don't use the broken dynamic header.\n    DynamicPhdr = nullptr;\n  }\n\n  if (DynamicPhdr && DynamicSec) {\n    if (DynamicSec->sh_addr + DynamicSec->sh_size >\n            DynamicPhdr->p_vaddr + DynamicPhdr->p_memsz ||\n        DynamicSec->sh_addr < DynamicPhdr->p_vaddr)\n      reportUniqueWarning(describe(*DynamicSec) +\n                          \" is not contained within the \"\n                          \"PT_DYNAMIC segment\");\n\n    if (DynamicSec->sh_addr != DynamicPhdr->p_vaddr)\n      reportUniqueWarning(describe(*DynamicSec) + \" is not at the start of \"\n                                                  \"PT_DYNAMIC segment\");\n  }\n\n  return std::make_pair(DynamicPhdr, DynamicSec);\n}\n\ntemplate <typename ELFT>\nvoid ELFDumper<ELFT>::loadDynamicTable() {\n  const Elf_Phdr *DynamicPhdr;\n  const Elf_Shdr *DynamicSec;\n  std::tie(DynamicPhdr, DynamicSec) = findDynamic();\n  if (!DynamicPhdr && !DynamicSec)\n    return;\n\n  DynRegionInfo FromPhdr(ObjF, *this);\n  bool IsPhdrTableValid = false;\n  if (DynamicPhdr) {\n    // Use cantFail(), because p_offset/p_filesz fields of a PT_DYNAMIC are\n    // validated in findDynamic() and so createDRI() is not expected to fail.\n    FromPhdr = cantFail(createDRI(DynamicPhdr->p_offset, DynamicPhdr->p_filesz,\n                                  sizeof(Elf_Dyn)));\n    FromPhdr.SizePrintName = \"PT_DYNAMIC size\";\n    FromPhdr.EntSizePrintName = \"\";\n    IsPhdrTableValid = !FromPhdr.template getAsArrayRef<Elf_Dyn>().empty();\n  }\n\n  // Locate the dynamic table described in a section header.\n  // Ignore sh_entsize and use the expected value for entry size explicitly.\n  // This allows us to dump dynamic sections with a broken sh_entsize\n  // field.\n  DynRegionInfo FromSec(ObjF, *this);\n  bool IsSecTableValid = false;\n  if (DynamicSec) {\n    Expected<DynRegionInfo> RegOrErr =\n        createDRI(DynamicSec->sh_offset, DynamicSec->sh_size, sizeof(Elf_Dyn));\n    if (RegOrErr) {\n      FromSec = *RegOrErr;\n      FromSec.Context = describe(*DynamicSec);\n      FromSec.EntSizePrintName = \"\";\n      IsSecTableValid = !FromSec.template getAsArrayRef<Elf_Dyn>().empty();\n    } else {\n      reportUniqueWarning(\"unable to read the dynamic table from \" +\n                          describe(*DynamicSec) + \": \" +\n                          toString(RegOrErr.takeError()));\n    }\n  }\n\n  // When we only have information from one of the SHT_DYNAMIC section header or\n  // PT_DYNAMIC program header, just use that.\n  if (!DynamicPhdr || !DynamicSec) {\n    if ((DynamicPhdr && IsPhdrTableValid) || (DynamicSec && IsSecTableValid)) {\n      DynamicTable = DynamicPhdr ? FromPhdr : FromSec;\n      parseDynamicTable();\n    } else {\n      reportUniqueWarning(\"no valid dynamic table was found\");\n    }\n    return;\n  }\n\n  // At this point we have tables found from the section header and from the\n  // dynamic segment. Usually they match, but we have to do sanity checks to\n  // verify that.\n\n  if (FromPhdr.Addr != FromSec.Addr)\n    reportUniqueWarning(\"SHT_DYNAMIC section header and PT_DYNAMIC \"\n                        \"program header disagree about \"\n                        \"the location of the dynamic table\");\n\n  if (!IsPhdrTableValid && !IsSecTableValid) {\n    reportUniqueWarning(\"no valid dynamic table was found\");\n    return;\n  }\n\n  // Information in the PT_DYNAMIC program header has priority over the\n  // information in a section header.\n  if (IsPhdrTableValid) {\n    if (!IsSecTableValid)\n      reportUniqueWarning(\n          \"SHT_DYNAMIC dynamic table is invalid: PT_DYNAMIC will be used\");\n    DynamicTable = FromPhdr;\n  } else {\n    reportUniqueWarning(\n        \"PT_DYNAMIC dynamic table is invalid: SHT_DYNAMIC will be used\");\n    DynamicTable = FromSec;\n  }\n\n  parseDynamicTable();\n}\n\ntemplate <typename ELFT>\nELFDumper<ELFT>::ELFDumper(const object::ELFObjectFile<ELFT> &O,\n                           ScopedPrinter &Writer)\n    : ObjDumper(Writer, O.getFileName()), ObjF(O), Obj(O.getELFFile()),\n      FileName(O.getFileName()), DynRelRegion(O, *this),\n      DynRelaRegion(O, *this), DynRelrRegion(O, *this),\n      DynPLTRelRegion(O, *this), DynSymTabShndxRegion(O, *this),\n      DynamicTable(O, *this) {\n  if (!O.IsContentValid())\n    return;\n\n  typename ELFT::ShdrRange Sections = cantFail(Obj.sections());\n  for (const Elf_Shdr &Sec : Sections) {\n    switch (Sec.sh_type) {\n    case ELF::SHT_SYMTAB:\n      if (!DotSymtabSec)\n        DotSymtabSec = &Sec;\n      break;\n    case ELF::SHT_DYNSYM:\n      if (!DotDynsymSec)\n        DotDynsymSec = &Sec;\n\n      if (!DynSymRegion) {\n        Expected<DynRegionInfo> RegOrErr =\n            createDRI(Sec.sh_offset, Sec.sh_size, Sec.sh_entsize);\n        if (RegOrErr) {\n          DynSymRegion = *RegOrErr;\n          DynSymRegion->Context = describe(Sec);\n\n          if (Expected<StringRef> E = Obj.getStringTableForSymtab(Sec))\n            DynamicStringTable = *E;\n          else\n            reportUniqueWarning(\"unable to get the string table for the \" +\n                                describe(Sec) + \": \" + toString(E.takeError()));\n        } else {\n          reportUniqueWarning(\"unable to read dynamic symbols from \" +\n                              describe(Sec) + \": \" +\n                              toString(RegOrErr.takeError()));\n        }\n      }\n      break;\n    case ELF::SHT_SYMTAB_SHNDX: {\n      uint32_t SymtabNdx = Sec.sh_link;\n      if (SymtabNdx >= Sections.size()) {\n        reportUniqueWarning(\n            \"unable to get the associated symbol table for \" + describe(Sec) +\n            \": sh_link (\" + Twine(SymtabNdx) +\n            \") is greater than or equal to the total number of sections (\" +\n            Twine(Sections.size()) + \")\");\n        continue;\n      }\n\n      if (Expected<ArrayRef<Elf_Word>> ShndxTableOrErr =\n              Obj.getSHNDXTable(Sec)) {\n        if (!ShndxTables.insert({&Sections[SymtabNdx], *ShndxTableOrErr})\n                 .second)\n          reportUniqueWarning(\n              \"multiple SHT_SYMTAB_SHNDX sections are linked to \" +\n              describe(Sec));\n      } else {\n        reportUniqueWarning(ShndxTableOrErr.takeError());\n      }\n      break;\n    }\n    case ELF::SHT_GNU_versym:\n      if (!SymbolVersionSection)\n        SymbolVersionSection = &Sec;\n      break;\n    case ELF::SHT_GNU_verdef:\n      if (!SymbolVersionDefSection)\n        SymbolVersionDefSection = &Sec;\n      break;\n    case ELF::SHT_GNU_verneed:\n      if (!SymbolVersionNeedSection)\n        SymbolVersionNeedSection = &Sec;\n      break;\n    case ELF::SHT_LLVM_CALL_GRAPH_PROFILE:\n      if (!DotCGProfileSec)\n        DotCGProfileSec = &Sec;\n      break;\n    case ELF::SHT_LLVM_ADDRSIG:\n      if (!DotAddrsigSec)\n        DotAddrsigSec = &Sec;\n      break;\n    }\n  }\n\n  loadDynamicTable();\n}\n\ntemplate <typename ELFT> void ELFDumper<ELFT>::parseDynamicTable() {\n  auto toMappedAddr = [&](uint64_t Tag, uint64_t VAddr) -> const uint8_t * {\n    auto MappedAddrOrError = Obj.toMappedAddr(VAddr, [&](const Twine &Msg) {\n      this->reportUniqueWarning(Msg);\n      return Error::success();\n    });\n    if (!MappedAddrOrError) {\n      this->reportUniqueWarning(\"unable to parse DT_\" +\n                                Obj.getDynamicTagAsString(Tag) + \": \" +\n                                llvm::toString(MappedAddrOrError.takeError()));\n      return nullptr;\n    }\n    return MappedAddrOrError.get();\n  };\n\n  const char *StringTableBegin = nullptr;\n  uint64_t StringTableSize = 0;\n  Optional<DynRegionInfo> DynSymFromTable;\n  for (const Elf_Dyn &Dyn : dynamic_table()) {\n    switch (Dyn.d_tag) {\n    case ELF::DT_HASH:\n      HashTable = reinterpret_cast<const Elf_Hash *>(\n          toMappedAddr(Dyn.getTag(), Dyn.getPtr()));\n      break;\n    case ELF::DT_GNU_HASH:\n      GnuHashTable = reinterpret_cast<const Elf_GnuHash *>(\n          toMappedAddr(Dyn.getTag(), Dyn.getPtr()));\n      break;\n    case ELF::DT_STRTAB:\n      StringTableBegin = reinterpret_cast<const char *>(\n          toMappedAddr(Dyn.getTag(), Dyn.getPtr()));\n      break;\n    case ELF::DT_STRSZ:\n      StringTableSize = Dyn.getVal();\n      break;\n    case ELF::DT_SYMTAB: {\n      // If we can't map the DT_SYMTAB value to an address (e.g. when there are\n      // no program headers), we ignore its value.\n      if (const uint8_t *VA = toMappedAddr(Dyn.getTag(), Dyn.getPtr())) {\n        DynSymFromTable.emplace(ObjF, *this);\n        DynSymFromTable->Addr = VA;\n        DynSymFromTable->EntSize = sizeof(Elf_Sym);\n        DynSymFromTable->EntSizePrintName = \"\";\n      }\n      break;\n    }\n    case ELF::DT_SYMENT: {\n      uint64_t Val = Dyn.getVal();\n      if (Val != sizeof(Elf_Sym))\n        this->reportUniqueWarning(\"DT_SYMENT value of 0x\" +\n                                  Twine::utohexstr(Val) +\n                                  \" is not the size of a symbol (0x\" +\n                                  Twine::utohexstr(sizeof(Elf_Sym)) + \")\");\n      break;\n    }\n    case ELF::DT_RELA:\n      DynRelaRegion.Addr = toMappedAddr(Dyn.getTag(), Dyn.getPtr());\n      break;\n    case ELF::DT_RELASZ:\n      DynRelaRegion.Size = Dyn.getVal();\n      DynRelaRegion.SizePrintName = \"DT_RELASZ value\";\n      break;\n    case ELF::DT_RELAENT:\n      DynRelaRegion.EntSize = Dyn.getVal();\n      DynRelaRegion.EntSizePrintName = \"DT_RELAENT value\";\n      break;\n    case ELF::DT_SONAME:\n      SONameOffset = Dyn.getVal();\n      break;\n    case ELF::DT_REL:\n      DynRelRegion.Addr = toMappedAddr(Dyn.getTag(), Dyn.getPtr());\n      break;\n    case ELF::DT_RELSZ:\n      DynRelRegion.Size = Dyn.getVal();\n      DynRelRegion.SizePrintName = \"DT_RELSZ value\";\n      break;\n    case ELF::DT_RELENT:\n      DynRelRegion.EntSize = Dyn.getVal();\n      DynRelRegion.EntSizePrintName = \"DT_RELENT value\";\n      break;\n    case ELF::DT_RELR:\n    case ELF::DT_ANDROID_RELR:\n      DynRelrRegion.Addr = toMappedAddr(Dyn.getTag(), Dyn.getPtr());\n      break;\n    case ELF::DT_RELRSZ:\n    case ELF::DT_ANDROID_RELRSZ:\n      DynRelrRegion.Size = Dyn.getVal();\n      DynRelrRegion.SizePrintName = Dyn.d_tag == ELF::DT_RELRSZ\n                                        ? \"DT_RELRSZ value\"\n                                        : \"DT_ANDROID_RELRSZ value\";\n      break;\n    case ELF::DT_RELRENT:\n    case ELF::DT_ANDROID_RELRENT:\n      DynRelrRegion.EntSize = Dyn.getVal();\n      DynRelrRegion.EntSizePrintName = Dyn.d_tag == ELF::DT_RELRENT\n                                           ? \"DT_RELRENT value\"\n                                           : \"DT_ANDROID_RELRENT value\";\n      break;\n    case ELF::DT_PLTREL:\n      if (Dyn.getVal() == DT_REL)\n        DynPLTRelRegion.EntSize = sizeof(Elf_Rel);\n      else if (Dyn.getVal() == DT_RELA)\n        DynPLTRelRegion.EntSize = sizeof(Elf_Rela);\n      else\n        reportUniqueWarning(Twine(\"unknown DT_PLTREL value of \") +\n                            Twine((uint64_t)Dyn.getVal()));\n      DynPLTRelRegion.EntSizePrintName = \"PLTREL entry size\";\n      break;\n    case ELF::DT_JMPREL:\n      DynPLTRelRegion.Addr = toMappedAddr(Dyn.getTag(), Dyn.getPtr());\n      break;\n    case ELF::DT_PLTRELSZ:\n      DynPLTRelRegion.Size = Dyn.getVal();\n      DynPLTRelRegion.SizePrintName = \"DT_PLTRELSZ value\";\n      break;\n    case ELF::DT_SYMTAB_SHNDX:\n      DynSymTabShndxRegion.Addr = toMappedAddr(Dyn.getTag(), Dyn.getPtr());\n      DynSymTabShndxRegion.EntSize = sizeof(Elf_Word);\n      break;\n    }\n  }\n\n  if (StringTableBegin) {\n    const uint64_t FileSize = Obj.getBufSize();\n    const uint64_t Offset = (const uint8_t *)StringTableBegin - Obj.base();\n    if (StringTableSize > FileSize - Offset)\n      reportUniqueWarning(\n          \"the dynamic string table at 0x\" + Twine::utohexstr(Offset) +\n          \" goes past the end of the file (0x\" + Twine::utohexstr(FileSize) +\n          \") with DT_STRSZ = 0x\" + Twine::utohexstr(StringTableSize));\n    else\n      DynamicStringTable = StringRef(StringTableBegin, StringTableSize);\n  }\n\n  const bool IsHashTableSupported = getHashTableEntSize() == 4;\n  if (DynSymRegion) {\n    // Often we find the information about the dynamic symbol table\n    // location in the SHT_DYNSYM section header. However, the value in\n    // DT_SYMTAB has priority, because it is used by dynamic loaders to\n    // locate .dynsym at runtime. The location we find in the section header\n    // and the location we find here should match.\n    if (DynSymFromTable && DynSymFromTable->Addr != DynSymRegion->Addr)\n      reportUniqueWarning(\n          createError(\"SHT_DYNSYM section header and DT_SYMTAB disagree about \"\n                      \"the location of the dynamic symbol table\"));\n\n    // According to the ELF gABI: \"The number of symbol table entries should\n    // equal nchain\". Check to see if the DT_HASH hash table nchain value\n    // conflicts with the number of symbols in the dynamic symbol table\n    // according to the section header.\n    if (HashTable && IsHashTableSupported) {\n      if (DynSymRegion->EntSize == 0)\n        reportUniqueWarning(\"SHT_DYNSYM section has sh_entsize == 0\");\n      else if (HashTable->nchain != DynSymRegion->Size / DynSymRegion->EntSize)\n        reportUniqueWarning(\n            \"hash table nchain (\" + Twine(HashTable->nchain) +\n            \") differs from symbol count derived from SHT_DYNSYM section \"\n            \"header (\" +\n            Twine(DynSymRegion->Size / DynSymRegion->EntSize) + \")\");\n    }\n  }\n\n  // Delay the creation of the actual dynamic symbol table until now, so that\n  // checks can always be made against the section header-based properties,\n  // without worrying about tag order.\n  if (DynSymFromTable) {\n    if (!DynSymRegion) {\n      DynSymRegion = DynSymFromTable;\n    } else {\n      DynSymRegion->Addr = DynSymFromTable->Addr;\n      DynSymRegion->EntSize = DynSymFromTable->EntSize;\n      DynSymRegion->EntSizePrintName = DynSymFromTable->EntSizePrintName;\n    }\n  }\n\n  // Derive the dynamic symbol table size from the DT_HASH hash table, if\n  // present.\n  if (HashTable && IsHashTableSupported && DynSymRegion) {\n    const uint64_t FileSize = Obj.getBufSize();\n    const uint64_t DerivedSize =\n        (uint64_t)HashTable->nchain * DynSymRegion->EntSize;\n    const uint64_t Offset = (const uint8_t *)DynSymRegion->Addr - Obj.base();\n    if (DerivedSize > FileSize - Offset)\n      reportUniqueWarning(\n          \"the size (0x\" + Twine::utohexstr(DerivedSize) +\n          \") of the dynamic symbol table at 0x\" + Twine::utohexstr(Offset) +\n          \", derived from the hash table, goes past the end of the file (0x\" +\n          Twine::utohexstr(FileSize) + \") and will be ignored\");\n    else\n      DynSymRegion->Size = HashTable->nchain * DynSymRegion->EntSize;\n  }\n}\n\ntemplate <typename ELFT> void ELFDumper<ELFT>::printVersionInfo() {\n  // Dump version symbol section.\n  printVersionSymbolSection(SymbolVersionSection);\n\n  // Dump version definition section.\n  printVersionDefinitionSection(SymbolVersionDefSection);\n\n  // Dump version dependency section.\n  printVersionDependencySection(SymbolVersionNeedSection);\n}\n\n#define LLVM_READOBJ_DT_FLAG_ENT(prefix, enum)                                 \\\n  { #enum, prefix##_##enum }\n\nstatic const EnumEntry<unsigned> ElfDynamicDTFlags[] = {\n  LLVM_READOBJ_DT_FLAG_ENT(DF, ORIGIN),\n  LLVM_READOBJ_DT_FLAG_ENT(DF, SYMBOLIC),\n  LLVM_READOBJ_DT_FLAG_ENT(DF, TEXTREL),\n  LLVM_READOBJ_DT_FLAG_ENT(DF, BIND_NOW),\n  LLVM_READOBJ_DT_FLAG_ENT(DF, STATIC_TLS)\n};\n\nstatic const EnumEntry<unsigned> ElfDynamicDTFlags1[] = {\n  LLVM_READOBJ_DT_FLAG_ENT(DF_1, NOW),\n  LLVM_READOBJ_DT_FLAG_ENT(DF_1, GLOBAL),\n  LLVM_READOBJ_DT_FLAG_ENT(DF_1, GROUP),\n  LLVM_READOBJ_DT_FLAG_ENT(DF_1, NODELETE),\n  LLVM_READOBJ_DT_FLAG_ENT(DF_1, LOADFLTR),\n  LLVM_READOBJ_DT_FLAG_ENT(DF_1, INITFIRST),\n  LLVM_READOBJ_DT_FLAG_ENT(DF_1, NOOPEN),\n  LLVM_READOBJ_DT_FLAG_ENT(DF_1, ORIGIN),\n  LLVM_READOBJ_DT_FLAG_ENT(DF_1, DIRECT),\n  LLVM_READOBJ_DT_FLAG_ENT(DF_1, TRANS),\n  LLVM_READOBJ_DT_FLAG_ENT(DF_1, INTERPOSE),\n  LLVM_READOBJ_DT_FLAG_ENT(DF_1, NODEFLIB),\n  LLVM_READOBJ_DT_FLAG_ENT(DF_1, NODUMP),\n  LLVM_READOBJ_DT_FLAG_ENT(DF_1, CONFALT),\n  LLVM_READOBJ_DT_FLAG_ENT(DF_1, ENDFILTEE),\n  LLVM_READOBJ_DT_FLAG_ENT(DF_1, DISPRELDNE),\n  LLVM_READOBJ_DT_FLAG_ENT(DF_1, DISPRELPND),\n  LLVM_READOBJ_DT_FLAG_ENT(DF_1, NODIRECT),\n  LLVM_READOBJ_DT_FLAG_ENT(DF_1, IGNMULDEF),\n  LLVM_READOBJ_DT_FLAG_ENT(DF_1, NOKSYMS),\n  LLVM_READOBJ_DT_FLAG_ENT(DF_1, NOHDR),\n  LLVM_READOBJ_DT_FLAG_ENT(DF_1, EDITED),\n  LLVM_READOBJ_DT_FLAG_ENT(DF_1, NORELOC),\n  LLVM_READOBJ_DT_FLAG_ENT(DF_1, SYMINTPOSE),\n  LLVM_READOBJ_DT_FLAG_ENT(DF_1, GLOBAUDIT),\n  LLVM_READOBJ_DT_FLAG_ENT(DF_1, SINGLETON),\n  LLVM_READOBJ_DT_FLAG_ENT(DF_1, PIE),\n};\n\nstatic const EnumEntry<unsigned> ElfDynamicDTMipsFlags[] = {\n  LLVM_READOBJ_DT_FLAG_ENT(RHF, NONE),\n  LLVM_READOBJ_DT_FLAG_ENT(RHF, QUICKSTART),\n  LLVM_READOBJ_DT_FLAG_ENT(RHF, NOTPOT),\n  LLVM_READOBJ_DT_FLAG_ENT(RHS, NO_LIBRARY_REPLACEMENT),\n  LLVM_READOBJ_DT_FLAG_ENT(RHF, NO_MOVE),\n  LLVM_READOBJ_DT_FLAG_ENT(RHF, SGI_ONLY),\n  LLVM_READOBJ_DT_FLAG_ENT(RHF, GUARANTEE_INIT),\n  LLVM_READOBJ_DT_FLAG_ENT(RHF, DELTA_C_PLUS_PLUS),\n  LLVM_READOBJ_DT_FLAG_ENT(RHF, GUARANTEE_START_INIT),\n  LLVM_READOBJ_DT_FLAG_ENT(RHF, PIXIE),\n  LLVM_READOBJ_DT_FLAG_ENT(RHF, DEFAULT_DELAY_LOAD),\n  LLVM_READOBJ_DT_FLAG_ENT(RHF, REQUICKSTART),\n  LLVM_READOBJ_DT_FLAG_ENT(RHF, REQUICKSTARTED),\n  LLVM_READOBJ_DT_FLAG_ENT(RHF, CORD),\n  LLVM_READOBJ_DT_FLAG_ENT(RHF, NO_UNRES_UNDEF),\n  LLVM_READOBJ_DT_FLAG_ENT(RHF, RLD_ORDER_SAFE)\n};\n\n#undef LLVM_READOBJ_DT_FLAG_ENT\n\ntemplate <typename T, typename TFlag>\nvoid printFlags(T Value, ArrayRef<EnumEntry<TFlag>> Flags, raw_ostream &OS) {\n  SmallVector<EnumEntry<TFlag>, 10> SetFlags;\n  for (const EnumEntry<TFlag> &Flag : Flags)\n    if (Flag.Value != 0 && (Value & Flag.Value) == Flag.Value)\n      SetFlags.push_back(Flag);\n\n  for (const EnumEntry<TFlag> &Flag : SetFlags)\n    OS << Flag.Name << \" \";\n}\n\ntemplate <class ELFT>\nconst typename ELFT::Shdr *\nELFDumper<ELFT>::findSectionByName(StringRef Name) const {\n  for (const Elf_Shdr &Shdr : cantFail(Obj.sections())) {\n    if (Expected<StringRef> NameOrErr = Obj.getSectionName(Shdr)) {\n      if (*NameOrErr == Name)\n        return &Shdr;\n    } else {\n      reportUniqueWarning(\"unable to read the name of \" + describe(Shdr) +\n                          \": \" + toString(NameOrErr.takeError()));\n    }\n  }\n  return nullptr;\n}\n\ntemplate <class ELFT>\nstd::string ELFDumper<ELFT>::getDynamicEntry(uint64_t Type,\n                                             uint64_t Value) const {\n  auto FormatHexValue = [](uint64_t V) {\n    std::string Str;\n    raw_string_ostream OS(Str);\n    const char *ConvChar =\n        (opts::Output == opts::GNU) ? \"0x%\" PRIx64 : \"0x%\" PRIX64;\n    OS << format(ConvChar, V);\n    return OS.str();\n  };\n\n  auto FormatFlags = [](uint64_t V,\n                        llvm::ArrayRef<llvm::EnumEntry<unsigned int>> Array) {\n    std::string Str;\n    raw_string_ostream OS(Str);\n    printFlags(V, Array, OS);\n    return OS.str();\n  };\n\n  // Handle custom printing of architecture specific tags\n  switch (Obj.getHeader().e_machine) {\n  case EM_AARCH64:\n    switch (Type) {\n    case DT_AARCH64_BTI_PLT:\n    case DT_AARCH64_PAC_PLT:\n    case DT_AARCH64_VARIANT_PCS:\n      return std::to_string(Value);\n    default:\n      break;\n    }\n    break;\n  case EM_HEXAGON:\n    switch (Type) {\n    case DT_HEXAGON_VER:\n      return std::to_string(Value);\n    case DT_HEXAGON_SYMSZ:\n    case DT_HEXAGON_PLT:\n      return FormatHexValue(Value);\n    default:\n      break;\n    }\n    break;\n  case EM_MIPS:\n    switch (Type) {\n    case DT_MIPS_RLD_VERSION:\n    case DT_MIPS_LOCAL_GOTNO:\n    case DT_MIPS_SYMTABNO:\n    case DT_MIPS_UNREFEXTNO:\n      return std::to_string(Value);\n    case DT_MIPS_TIME_STAMP:\n    case DT_MIPS_ICHECKSUM:\n    case DT_MIPS_IVERSION:\n    case DT_MIPS_BASE_ADDRESS:\n    case DT_MIPS_MSYM:\n    case DT_MIPS_CONFLICT:\n    case DT_MIPS_LIBLIST:\n    case DT_MIPS_CONFLICTNO:\n    case DT_MIPS_LIBLISTNO:\n    case DT_MIPS_GOTSYM:\n    case DT_MIPS_HIPAGENO:\n    case DT_MIPS_RLD_MAP:\n    case DT_MIPS_DELTA_CLASS:\n    case DT_MIPS_DELTA_CLASS_NO:\n    case DT_MIPS_DELTA_INSTANCE:\n    case DT_MIPS_DELTA_RELOC:\n    case DT_MIPS_DELTA_RELOC_NO:\n    case DT_MIPS_DELTA_SYM:\n    case DT_MIPS_DELTA_SYM_NO:\n    case DT_MIPS_DELTA_CLASSSYM:\n    case DT_MIPS_DELTA_CLASSSYM_NO:\n    case DT_MIPS_CXX_FLAGS:\n    case DT_MIPS_PIXIE_INIT:\n    case DT_MIPS_SYMBOL_LIB:\n    case DT_MIPS_LOCALPAGE_GOTIDX:\n    case DT_MIPS_LOCAL_GOTIDX:\n    case DT_MIPS_HIDDEN_GOTIDX:\n    case DT_MIPS_PROTECTED_GOTIDX:\n    case DT_MIPS_OPTIONS:\n    case DT_MIPS_INTERFACE:\n    case DT_MIPS_DYNSTR_ALIGN:\n    case DT_MIPS_INTERFACE_SIZE:\n    case DT_MIPS_RLD_TEXT_RESOLVE_ADDR:\n    case DT_MIPS_PERF_SUFFIX:\n    case DT_MIPS_COMPACT_SIZE:\n    case DT_MIPS_GP_VALUE:\n    case DT_MIPS_AUX_DYNAMIC:\n    case DT_MIPS_PLTGOT:\n    case DT_MIPS_RWPLT:\n    case DT_MIPS_RLD_MAP_REL:\n      return FormatHexValue(Value);\n    case DT_MIPS_FLAGS:\n      return FormatFlags(Value, makeArrayRef(ElfDynamicDTMipsFlags));\n    default:\n      break;\n    }\n    break;\n  default:\n    break;\n  }\n\n  switch (Type) {\n  case DT_PLTREL:\n    if (Value == DT_REL)\n      return \"REL\";\n    if (Value == DT_RELA)\n      return \"RELA\";\n    LLVM_FALLTHROUGH;\n  case DT_PLTGOT:\n  case DT_HASH:\n  case DT_STRTAB:\n  case DT_SYMTAB:\n  case DT_RELA:\n  case DT_INIT:\n  case DT_FINI:\n  case DT_REL:\n  case DT_JMPREL:\n  case DT_INIT_ARRAY:\n  case DT_FINI_ARRAY:\n  case DT_PREINIT_ARRAY:\n  case DT_DEBUG:\n  case DT_VERDEF:\n  case DT_VERNEED:\n  case DT_VERSYM:\n  case DT_GNU_HASH:\n  case DT_NULL:\n    return FormatHexValue(Value);\n  case DT_RELACOUNT:\n  case DT_RELCOUNT:\n  case DT_VERDEFNUM:\n  case DT_VERNEEDNUM:\n    return std::to_string(Value);\n  case DT_PLTRELSZ:\n  case DT_RELASZ:\n  case DT_RELAENT:\n  case DT_STRSZ:\n  case DT_SYMENT:\n  case DT_RELSZ:\n  case DT_RELENT:\n  case DT_INIT_ARRAYSZ:\n  case DT_FINI_ARRAYSZ:\n  case DT_PREINIT_ARRAYSZ:\n  case DT_ANDROID_RELSZ:\n  case DT_ANDROID_RELASZ:\n    return std::to_string(Value) + \" (bytes)\";\n  case DT_NEEDED:\n  case DT_SONAME:\n  case DT_AUXILIARY:\n  case DT_USED:\n  case DT_FILTER:\n  case DT_RPATH:\n  case DT_RUNPATH: {\n    const std::map<uint64_t, const char *> TagNames = {\n        {DT_NEEDED, \"Shared library\"},       {DT_SONAME, \"Library soname\"},\n        {DT_AUXILIARY, \"Auxiliary library\"}, {DT_USED, \"Not needed object\"},\n        {DT_FILTER, \"Filter library\"},       {DT_RPATH, \"Library rpath\"},\n        {DT_RUNPATH, \"Library runpath\"},\n    };\n\n    return (Twine(TagNames.at(Type)) + \": [\" + getDynamicString(Value) + \"]\")\n        .str();\n  }\n  case DT_FLAGS:\n    return FormatFlags(Value, makeArrayRef(ElfDynamicDTFlags));\n  case DT_FLAGS_1:\n    return FormatFlags(Value, makeArrayRef(ElfDynamicDTFlags1));\n  default:\n    return FormatHexValue(Value);\n  }\n}\n\ntemplate <class ELFT>\nStringRef ELFDumper<ELFT>::getDynamicString(uint64_t Value) const {\n  if (DynamicStringTable.empty() && !DynamicStringTable.data()) {\n    reportUniqueWarning(\"string table was not found\");\n    return \"<?>\";\n  }\n\n  auto WarnAndReturn = [this](const Twine &Msg, uint64_t Offset) {\n    reportUniqueWarning(\"string table at offset 0x\" + Twine::utohexstr(Offset) +\n                        Msg);\n    return \"<?>\";\n  };\n\n  const uint64_t FileSize = Obj.getBufSize();\n  const uint64_t Offset =\n      (const uint8_t *)DynamicStringTable.data() - Obj.base();\n  if (DynamicStringTable.size() > FileSize - Offset)\n    return WarnAndReturn(\" with size 0x\" +\n                             Twine::utohexstr(DynamicStringTable.size()) +\n                             \" goes past the end of the file (0x\" +\n                             Twine::utohexstr(FileSize) + \")\",\n                         Offset);\n\n  if (Value >= DynamicStringTable.size())\n    return WarnAndReturn(\n        \": unable to read the string at 0x\" + Twine::utohexstr(Offset + Value) +\n            \": it goes past the end of the table (0x\" +\n            Twine::utohexstr(Offset + DynamicStringTable.size()) + \")\",\n        Offset);\n\n  if (DynamicStringTable.back() != '\\0')\n    return WarnAndReturn(\": unable to read the string at 0x\" +\n                             Twine::utohexstr(Offset + Value) +\n                             \": the string table is not null-terminated\",\n                         Offset);\n\n  return DynamicStringTable.data() + Value;\n}\n\ntemplate <class ELFT> void ELFDumper<ELFT>::printUnwindInfo() {\n  DwarfCFIEH::PrinterContext<ELFT> Ctx(W, ObjF);\n  Ctx.printUnwindInformation();\n}\n\n// The namespace is needed to fix the compilation with GCC older than 7.0+.\nnamespace {\ntemplate <> void ELFDumper<ELF32LE>::printUnwindInfo() {\n  if (Obj.getHeader().e_machine == EM_ARM) {\n    ARM::EHABI::PrinterContext<ELF32LE> Ctx(W, Obj, ObjF.getFileName(),\n                                            DotSymtabSec);\n    Ctx.PrintUnwindInformation();\n  }\n  DwarfCFIEH::PrinterContext<ELF32LE> Ctx(W, ObjF);\n  Ctx.printUnwindInformation();\n}\n} // namespace\n\ntemplate <class ELFT> void ELFDumper<ELFT>::printNeededLibraries() {\n  ListScope D(W, \"NeededLibraries\");\n\n  std::vector<StringRef> Libs;\n  for (const auto &Entry : dynamic_table())\n    if (Entry.d_tag == ELF::DT_NEEDED)\n      Libs.push_back(getDynamicString(Entry.d_un.d_val));\n\n  llvm::sort(Libs);\n\n  for (StringRef L : Libs)\n    W.startLine() << L << \"\\n\";\n}\n\ntemplate <class ELFT>\nstatic Error checkHashTable(const ELFDumper<ELFT> &Dumper,\n                            const typename ELFT::Hash *H,\n                            bool *IsHeaderValid = nullptr) {\n  const ELFFile<ELFT> &Obj = Dumper.getElfObject().getELFFile();\n  const uint64_t SecOffset = (const uint8_t *)H - Obj.base();\n  if (Dumper.getHashTableEntSize() == 8) {\n    auto It = llvm::find_if(ElfMachineType, [&](const EnumEntry<unsigned> &E) {\n      return E.Value == Obj.getHeader().e_machine;\n    });\n    if (IsHeaderValid)\n      *IsHeaderValid = false;\n    return createError(\"the hash table at 0x\" + Twine::utohexstr(SecOffset) +\n                       \" is not supported: it contains non-standard 8 \"\n                       \"byte entries on \" +\n                       It->AltName + \" platform\");\n  }\n\n  auto MakeError = [&](const Twine &Msg = \"\") {\n    return createError(\"the hash table at offset 0x\" +\n                       Twine::utohexstr(SecOffset) +\n                       \" goes past the end of the file (0x\" +\n                       Twine::utohexstr(Obj.getBufSize()) + \")\" + Msg);\n  };\n\n  // Each SHT_HASH section starts from two 32-bit fields: nbucket and nchain.\n  const unsigned HeaderSize = 2 * sizeof(typename ELFT::Word);\n\n  if (IsHeaderValid)\n    *IsHeaderValid = Obj.getBufSize() - SecOffset >= HeaderSize;\n\n  if (Obj.getBufSize() - SecOffset < HeaderSize)\n    return MakeError();\n\n  if (Obj.getBufSize() - SecOffset - HeaderSize <\n      ((uint64_t)H->nbucket + H->nchain) * sizeof(typename ELFT::Word))\n    return MakeError(\", nbucket = \" + Twine(H->nbucket) +\n                     \", nchain = \" + Twine(H->nchain));\n  return Error::success();\n}\n\ntemplate <class ELFT>\nstatic Error checkGNUHashTable(const ELFFile<ELFT> &Obj,\n                               const typename ELFT::GnuHash *GnuHashTable,\n                               bool *IsHeaderValid = nullptr) {\n  const uint8_t *TableData = reinterpret_cast<const uint8_t *>(GnuHashTable);\n  assert(TableData >= Obj.base() && TableData < Obj.base() + Obj.getBufSize() &&\n         \"GnuHashTable must always point to a location inside the file\");\n\n  uint64_t TableOffset = TableData - Obj.base();\n  if (IsHeaderValid)\n    *IsHeaderValid = TableOffset + /*Header size:*/ 16 < Obj.getBufSize();\n  if (TableOffset + 16 + (uint64_t)GnuHashTable->nbuckets * 4 +\n          (uint64_t)GnuHashTable->maskwords * sizeof(typename ELFT::Off) >=\n      Obj.getBufSize())\n    return createError(\"unable to dump the SHT_GNU_HASH \"\n                       \"section at 0x\" +\n                       Twine::utohexstr(TableOffset) +\n                       \": it goes past the end of the file\");\n  return Error::success();\n}\n\ntemplate <typename ELFT> void ELFDumper<ELFT>::printHashTable() {\n  DictScope D(W, \"HashTable\");\n  if (!HashTable)\n    return;\n\n  bool IsHeaderValid;\n  Error Err = checkHashTable(*this, HashTable, &IsHeaderValid);\n  if (IsHeaderValid) {\n    W.printNumber(\"Num Buckets\", HashTable->nbucket);\n    W.printNumber(\"Num Chains\", HashTable->nchain);\n  }\n\n  if (Err) {\n    reportUniqueWarning(std::move(Err));\n    return;\n  }\n\n  W.printList(\"Buckets\", HashTable->buckets());\n  W.printList(\"Chains\", HashTable->chains());\n}\n\ntemplate <class ELFT>\nstatic Expected<ArrayRef<typename ELFT::Word>>\ngetGnuHashTableChains(Optional<DynRegionInfo> DynSymRegion,\n                      const typename ELFT::GnuHash *GnuHashTable) {\n  if (!DynSymRegion)\n    return createError(\"no dynamic symbol table found\");\n\n  ArrayRef<typename ELFT::Sym> DynSymTable =\n      DynSymRegion->template getAsArrayRef<typename ELFT::Sym>();\n  size_t NumSyms = DynSymTable.size();\n  if (!NumSyms)\n    return createError(\"the dynamic symbol table is empty\");\n\n  if (GnuHashTable->symndx < NumSyms)\n    return GnuHashTable->values(NumSyms);\n\n  // A normal empty GNU hash table section produced by linker might have\n  // symndx set to the number of dynamic symbols + 1 (for the zero symbol)\n  // and have dummy null values in the Bloom filter and in the buckets\n  // vector (or no values at all). It happens because the value of symndx is not\n  // important for dynamic loaders when the GNU hash table is empty. They just\n  // skip the whole object during symbol lookup. In such cases, the symndx value\n  // is irrelevant and we should not report a warning.\n  ArrayRef<typename ELFT::Word> Buckets = GnuHashTable->buckets();\n  if (!llvm::all_of(Buckets, [](typename ELFT::Word V) { return V == 0; }))\n    return createError(\n        \"the first hashed symbol index (\" + Twine(GnuHashTable->symndx) +\n        \") is greater than or equal to the number of dynamic symbols (\" +\n        Twine(NumSyms) + \")\");\n  // There is no way to represent an array of (dynamic symbols count - symndx)\n  // length.\n  return ArrayRef<typename ELFT::Word>();\n}\n\ntemplate <typename ELFT>\nvoid ELFDumper<ELFT>::printGnuHashTable() {\n  DictScope D(W, \"GnuHashTable\");\n  if (!GnuHashTable)\n    return;\n\n  bool IsHeaderValid;\n  Error Err = checkGNUHashTable<ELFT>(Obj, GnuHashTable, &IsHeaderValid);\n  if (IsHeaderValid) {\n    W.printNumber(\"Num Buckets\", GnuHashTable->nbuckets);\n    W.printNumber(\"First Hashed Symbol Index\", GnuHashTable->symndx);\n    W.printNumber(\"Num Mask Words\", GnuHashTable->maskwords);\n    W.printNumber(\"Shift Count\", GnuHashTable->shift2);\n  }\n\n  if (Err) {\n    reportUniqueWarning(std::move(Err));\n    return;\n  }\n\n  ArrayRef<typename ELFT::Off> BloomFilter = GnuHashTable->filter();\n  W.printHexList(\"Bloom Filter\", BloomFilter);\n\n  ArrayRef<Elf_Word> Buckets = GnuHashTable->buckets();\n  W.printList(\"Buckets\", Buckets);\n\n  Expected<ArrayRef<Elf_Word>> Chains =\n      getGnuHashTableChains<ELFT>(DynSymRegion, GnuHashTable);\n  if (!Chains) {\n    reportUniqueWarning(\"unable to dump 'Values' for the SHT_GNU_HASH \"\n                        \"section: \" +\n                        toString(Chains.takeError()));\n    return;\n  }\n\n  W.printHexList(\"Values\", *Chains);\n}\n\ntemplate <typename ELFT> void ELFDumper<ELFT>::printLoadName() {\n  StringRef SOName = \"<Not found>\";\n  if (SONameOffset)\n    SOName = getDynamicString(*SONameOffset);\n  W.printString(\"LoadName\", SOName);\n}\n\ntemplate <class ELFT> void ELFDumper<ELFT>::printArchSpecificInfo() {\n  switch (Obj.getHeader().e_machine) {\n  case EM_ARM:\n  case EM_RISCV:\n    printAttributes();\n    break;\n  case EM_MIPS: {\n    printMipsABIFlags();\n    printMipsOptions();\n    printMipsReginfo();\n    MipsGOTParser<ELFT> Parser(*this);\n    if (Error E = Parser.findGOT(dynamic_table(), dynamic_symbols()))\n      reportUniqueWarning(std::move(E));\n    else if (!Parser.isGotEmpty())\n      printMipsGOT(Parser);\n\n    if (Error E = Parser.findPLT(dynamic_table()))\n      reportUniqueWarning(std::move(E));\n    else if (!Parser.isPltEmpty())\n      printMipsPLT(Parser);\n    break;\n  }\n  default:\n    break;\n  }\n}\n\ntemplate <class ELFT> void ELFDumper<ELFT>::printAttributes() {\n  if (!Obj.isLE()) {\n    W.startLine() << \"Attributes not implemented.\\n\";\n    return;\n  }\n\n  const unsigned Machine = Obj.getHeader().e_machine;\n  assert((Machine == EM_ARM || Machine == EM_RISCV) &&\n         \"Attributes not implemented.\");\n\n  DictScope BA(W, \"BuildAttributes\");\n  for (const Elf_Shdr &Sec : cantFail(Obj.sections())) {\n    if (Sec.sh_type != ELF::SHT_ARM_ATTRIBUTES &&\n        Sec.sh_type != ELF::SHT_RISCV_ATTRIBUTES)\n      continue;\n\n    ArrayRef<uint8_t> Contents;\n    if (Expected<ArrayRef<uint8_t>> ContentOrErr =\n            Obj.getSectionContents(Sec)) {\n      Contents = *ContentOrErr;\n      if (Contents.empty()) {\n        reportUniqueWarning(\"the \" + describe(Sec) + \" is empty\");\n        continue;\n      }\n    } else {\n      reportUniqueWarning(\"unable to read the content of the \" + describe(Sec) +\n                          \": \" + toString(ContentOrErr.takeError()));\n      continue;\n    }\n\n    W.printHex(\"FormatVersion\", Contents[0]);\n\n    auto ParseAttrubutes = [&]() {\n      if (Machine == EM_ARM)\n        return ARMAttributeParser(&W).parse(Contents, support::little);\n      return RISCVAttributeParser(&W).parse(Contents, support::little);\n    };\n\n    if (Error E = ParseAttrubutes())\n      reportUniqueWarning(\"unable to dump attributes from the \" +\n                          describe(Sec) + \": \" + toString(std::move(E)));\n  }\n}\n\nnamespace {\n\ntemplate <class ELFT> class MipsGOTParser {\npublic:\n  LLVM_ELF_IMPORT_TYPES_ELFT(ELFT)\n  using Entry = typename ELFT::Addr;\n  using Entries = ArrayRef<Entry>;\n\n  const bool IsStatic;\n  const ELFFile<ELFT> &Obj;\n  const ELFDumper<ELFT> &Dumper;\n\n  MipsGOTParser(const ELFDumper<ELFT> &D);\n  Error findGOT(Elf_Dyn_Range DynTable, Elf_Sym_Range DynSyms);\n  Error findPLT(Elf_Dyn_Range DynTable);\n\n  bool isGotEmpty() const { return GotEntries.empty(); }\n  bool isPltEmpty() const { return PltEntries.empty(); }\n\n  uint64_t getGp() const;\n\n  const Entry *getGotLazyResolver() const;\n  const Entry *getGotModulePointer() const;\n  const Entry *getPltLazyResolver() const;\n  const Entry *getPltModulePointer() const;\n\n  Entries getLocalEntries() const;\n  Entries getGlobalEntries() const;\n  Entries getOtherEntries() const;\n  Entries getPltEntries() const;\n\n  uint64_t getGotAddress(const Entry * E) const;\n  int64_t getGotOffset(const Entry * E) const;\n  const Elf_Sym *getGotSym(const Entry *E) const;\n\n  uint64_t getPltAddress(const Entry * E) const;\n  const Elf_Sym *getPltSym(const Entry *E) const;\n\n  StringRef getPltStrTable() const { return PltStrTable; }\n  const Elf_Shdr *getPltSymTable() const { return PltSymTable; }\n\nprivate:\n  const Elf_Shdr *GotSec;\n  size_t LocalNum;\n  size_t GlobalNum;\n\n  const Elf_Shdr *PltSec;\n  const Elf_Shdr *PltRelSec;\n  const Elf_Shdr *PltSymTable;\n  StringRef FileName;\n\n  Elf_Sym_Range GotDynSyms;\n  StringRef PltStrTable;\n\n  Entries GotEntries;\n  Entries PltEntries;\n};\n\n} // end anonymous namespace\n\ntemplate <class ELFT>\nMipsGOTParser<ELFT>::MipsGOTParser(const ELFDumper<ELFT> &D)\n    : IsStatic(D.dynamic_table().empty()), Obj(D.getElfObject().getELFFile()),\n      Dumper(D), GotSec(nullptr), LocalNum(0), GlobalNum(0), PltSec(nullptr),\n      PltRelSec(nullptr), PltSymTable(nullptr),\n      FileName(D.getElfObject().getFileName()) {}\n\ntemplate <class ELFT>\nError MipsGOTParser<ELFT>::findGOT(Elf_Dyn_Range DynTable,\n                                   Elf_Sym_Range DynSyms) {\n  // See \"Global Offset Table\" in Chapter 5 in the following document\n  // for detailed GOT description.\n  // ftp://www.linux-mips.org/pub/linux/mips/doc/ABI/mipsabi.pdf\n\n  // Find static GOT secton.\n  if (IsStatic) {\n    GotSec = Dumper.findSectionByName(\".got\");\n    if (!GotSec)\n      return Error::success();\n\n    ArrayRef<uint8_t> Content =\n        unwrapOrError(FileName, Obj.getSectionContents(*GotSec));\n    GotEntries = Entries(reinterpret_cast<const Entry *>(Content.data()),\n                         Content.size() / sizeof(Entry));\n    LocalNum = GotEntries.size();\n    return Error::success();\n  }\n\n  // Lookup dynamic table tags which define the GOT layout.\n  Optional<uint64_t> DtPltGot;\n  Optional<uint64_t> DtLocalGotNum;\n  Optional<uint64_t> DtGotSym;\n  for (const auto &Entry : DynTable) {\n    switch (Entry.getTag()) {\n    case ELF::DT_PLTGOT:\n      DtPltGot = Entry.getVal();\n      break;\n    case ELF::DT_MIPS_LOCAL_GOTNO:\n      DtLocalGotNum = Entry.getVal();\n      break;\n    case ELF::DT_MIPS_GOTSYM:\n      DtGotSym = Entry.getVal();\n      break;\n    }\n  }\n\n  if (!DtPltGot && !DtLocalGotNum && !DtGotSym)\n    return Error::success();\n\n  if (!DtPltGot)\n    return createError(\"cannot find PLTGOT dynamic tag\");\n  if (!DtLocalGotNum)\n    return createError(\"cannot find MIPS_LOCAL_GOTNO dynamic tag\");\n  if (!DtGotSym)\n    return createError(\"cannot find MIPS_GOTSYM dynamic tag\");\n\n  size_t DynSymTotal = DynSyms.size();\n  if (*DtGotSym > DynSymTotal)\n    return createError(\"DT_MIPS_GOTSYM value (\" + Twine(*DtGotSym) +\n                       \") exceeds the number of dynamic symbols (\" +\n                       Twine(DynSymTotal) + \")\");\n\n  GotSec = findNotEmptySectionByAddress(Obj, FileName, *DtPltGot);\n  if (!GotSec)\n    return createError(\"there is no non-empty GOT section at 0x\" +\n                       Twine::utohexstr(*DtPltGot));\n\n  LocalNum = *DtLocalGotNum;\n  GlobalNum = DynSymTotal - *DtGotSym;\n\n  ArrayRef<uint8_t> Content =\n      unwrapOrError(FileName, Obj.getSectionContents(*GotSec));\n  GotEntries = Entries(reinterpret_cast<const Entry *>(Content.data()),\n                       Content.size() / sizeof(Entry));\n  GotDynSyms = DynSyms.drop_front(*DtGotSym);\n\n  return Error::success();\n}\n\ntemplate <class ELFT>\nError MipsGOTParser<ELFT>::findPLT(Elf_Dyn_Range DynTable) {\n  // Lookup dynamic table tags which define the PLT layout.\n  Optional<uint64_t> DtMipsPltGot;\n  Optional<uint64_t> DtJmpRel;\n  for (const auto &Entry : DynTable) {\n    switch (Entry.getTag()) {\n    case ELF::DT_MIPS_PLTGOT:\n      DtMipsPltGot = Entry.getVal();\n      break;\n    case ELF::DT_JMPREL:\n      DtJmpRel = Entry.getVal();\n      break;\n    }\n  }\n\n  if (!DtMipsPltGot && !DtJmpRel)\n    return Error::success();\n\n  // Find PLT section.\n  if (!DtMipsPltGot)\n    return createError(\"cannot find MIPS_PLTGOT dynamic tag\");\n  if (!DtJmpRel)\n    return createError(\"cannot find JMPREL dynamic tag\");\n\n  PltSec = findNotEmptySectionByAddress(Obj, FileName, *DtMipsPltGot);\n  if (!PltSec)\n    return createError(\"there is no non-empty PLTGOT section at 0x\" +\n                       Twine::utohexstr(*DtMipsPltGot));\n\n  PltRelSec = findNotEmptySectionByAddress(Obj, FileName, *DtJmpRel);\n  if (!PltRelSec)\n    return createError(\"there is no non-empty RELPLT section at 0x\" +\n                       Twine::utohexstr(*DtJmpRel));\n\n  if (Expected<ArrayRef<uint8_t>> PltContentOrErr =\n          Obj.getSectionContents(*PltSec))\n    PltEntries =\n        Entries(reinterpret_cast<const Entry *>(PltContentOrErr->data()),\n                PltContentOrErr->size() / sizeof(Entry));\n  else\n    return createError(\"unable to read PLTGOT section content: \" +\n                       toString(PltContentOrErr.takeError()));\n\n  if (Expected<const Elf_Shdr *> PltSymTableOrErr =\n          Obj.getSection(PltRelSec->sh_link))\n    PltSymTable = *PltSymTableOrErr;\n  else\n    return createError(\"unable to get a symbol table linked to the \" +\n                       describe(Obj, *PltRelSec) + \": \" +\n                       toString(PltSymTableOrErr.takeError()));\n\n  if (Expected<StringRef> StrTabOrErr =\n          Obj.getStringTableForSymtab(*PltSymTable))\n    PltStrTable = *StrTabOrErr;\n  else\n    return createError(\"unable to get a string table for the \" +\n                       describe(Obj, *PltSymTable) + \": \" +\n                       toString(StrTabOrErr.takeError()));\n\n  return Error::success();\n}\n\ntemplate <class ELFT> uint64_t MipsGOTParser<ELFT>::getGp() const {\n  return GotSec->sh_addr + 0x7ff0;\n}\n\ntemplate <class ELFT>\nconst typename MipsGOTParser<ELFT>::Entry *\nMipsGOTParser<ELFT>::getGotLazyResolver() const {\n  return LocalNum > 0 ? &GotEntries[0] : nullptr;\n}\n\ntemplate <class ELFT>\nconst typename MipsGOTParser<ELFT>::Entry *\nMipsGOTParser<ELFT>::getGotModulePointer() const {\n  if (LocalNum < 2)\n    return nullptr;\n  const Entry &E = GotEntries[1];\n  if ((E >> (sizeof(Entry) * 8 - 1)) == 0)\n    return nullptr;\n  return &E;\n}\n\ntemplate <class ELFT>\ntypename MipsGOTParser<ELFT>::Entries\nMipsGOTParser<ELFT>::getLocalEntries() const {\n  size_t Skip = getGotModulePointer() ? 2 : 1;\n  if (LocalNum - Skip <= 0)\n    return Entries();\n  return GotEntries.slice(Skip, LocalNum - Skip);\n}\n\ntemplate <class ELFT>\ntypename MipsGOTParser<ELFT>::Entries\nMipsGOTParser<ELFT>::getGlobalEntries() const {\n  if (GlobalNum == 0)\n    return Entries();\n  return GotEntries.slice(LocalNum, GlobalNum);\n}\n\ntemplate <class ELFT>\ntypename MipsGOTParser<ELFT>::Entries\nMipsGOTParser<ELFT>::getOtherEntries() const {\n  size_t OtherNum = GotEntries.size() - LocalNum - GlobalNum;\n  if (OtherNum == 0)\n    return Entries();\n  return GotEntries.slice(LocalNum + GlobalNum, OtherNum);\n}\n\ntemplate <class ELFT>\nuint64_t MipsGOTParser<ELFT>::getGotAddress(const Entry *E) const {\n  int64_t Offset = std::distance(GotEntries.data(), E) * sizeof(Entry);\n  return GotSec->sh_addr + Offset;\n}\n\ntemplate <class ELFT>\nint64_t MipsGOTParser<ELFT>::getGotOffset(const Entry *E) const {\n  int64_t Offset = std::distance(GotEntries.data(), E) * sizeof(Entry);\n  return Offset - 0x7ff0;\n}\n\ntemplate <class ELFT>\nconst typename MipsGOTParser<ELFT>::Elf_Sym *\nMipsGOTParser<ELFT>::getGotSym(const Entry *E) const {\n  int64_t Offset = std::distance(GotEntries.data(), E);\n  return &GotDynSyms[Offset - LocalNum];\n}\n\ntemplate <class ELFT>\nconst typename MipsGOTParser<ELFT>::Entry *\nMipsGOTParser<ELFT>::getPltLazyResolver() const {\n  return PltEntries.empty() ? nullptr : &PltEntries[0];\n}\n\ntemplate <class ELFT>\nconst typename MipsGOTParser<ELFT>::Entry *\nMipsGOTParser<ELFT>::getPltModulePointer() const {\n  return PltEntries.size() < 2 ? nullptr : &PltEntries[1];\n}\n\ntemplate <class ELFT>\ntypename MipsGOTParser<ELFT>::Entries\nMipsGOTParser<ELFT>::getPltEntries() const {\n  if (PltEntries.size() <= 2)\n    return Entries();\n  return PltEntries.slice(2, PltEntries.size() - 2);\n}\n\ntemplate <class ELFT>\nuint64_t MipsGOTParser<ELFT>::getPltAddress(const Entry *E) const {\n  int64_t Offset = std::distance(PltEntries.data(), E) * sizeof(Entry);\n  return PltSec->sh_addr + Offset;\n}\n\ntemplate <class ELFT>\nconst typename MipsGOTParser<ELFT>::Elf_Sym *\nMipsGOTParser<ELFT>::getPltSym(const Entry *E) const {\n  int64_t Offset = std::distance(getPltEntries().data(), E);\n  if (PltRelSec->sh_type == ELF::SHT_REL) {\n    Elf_Rel_Range Rels = unwrapOrError(FileName, Obj.rels(*PltRelSec));\n    return unwrapOrError(FileName,\n                         Obj.getRelocationSymbol(Rels[Offset], PltSymTable));\n  } else {\n    Elf_Rela_Range Rels = unwrapOrError(FileName, Obj.relas(*PltRelSec));\n    return unwrapOrError(FileName,\n                         Obj.getRelocationSymbol(Rels[Offset], PltSymTable));\n  }\n}\n\nstatic const EnumEntry<unsigned> ElfMipsISAExtType[] = {\n  {\"None\",                    Mips::AFL_EXT_NONE},\n  {\"Broadcom SB-1\",           Mips::AFL_EXT_SB1},\n  {\"Cavium Networks Octeon\",  Mips::AFL_EXT_OCTEON},\n  {\"Cavium Networks Octeon2\", Mips::AFL_EXT_OCTEON2},\n  {\"Cavium Networks OcteonP\", Mips::AFL_EXT_OCTEONP},\n  {\"Cavium Networks Octeon3\", Mips::AFL_EXT_OCTEON3},\n  {\"LSI R4010\",               Mips::AFL_EXT_4010},\n  {\"Loongson 2E\",             Mips::AFL_EXT_LOONGSON_2E},\n  {\"Loongson 2F\",             Mips::AFL_EXT_LOONGSON_2F},\n  {\"Loongson 3A\",             Mips::AFL_EXT_LOONGSON_3A},\n  {\"MIPS R4650\",              Mips::AFL_EXT_4650},\n  {\"MIPS R5900\",              Mips::AFL_EXT_5900},\n  {\"MIPS R10000\",             Mips::AFL_EXT_10000},\n  {\"NEC VR4100\",              Mips::AFL_EXT_4100},\n  {\"NEC VR4111/VR4181\",       Mips::AFL_EXT_4111},\n  {\"NEC VR4120\",              Mips::AFL_EXT_4120},\n  {\"NEC VR5400\",              Mips::AFL_EXT_5400},\n  {\"NEC VR5500\",              Mips::AFL_EXT_5500},\n  {\"RMI Xlr\",                 Mips::AFL_EXT_XLR},\n  {\"Toshiba R3900\",           Mips::AFL_EXT_3900}\n};\n\nstatic const EnumEntry<unsigned> ElfMipsASEFlags[] = {\n  {\"DSP\",                Mips::AFL_ASE_DSP},\n  {\"DSPR2\",              Mips::AFL_ASE_DSPR2},\n  {\"Enhanced VA Scheme\", Mips::AFL_ASE_EVA},\n  {\"MCU\",                Mips::AFL_ASE_MCU},\n  {\"MDMX\",               Mips::AFL_ASE_MDMX},\n  {\"MIPS-3D\",            Mips::AFL_ASE_MIPS3D},\n  {\"MT\",                 Mips::AFL_ASE_MT},\n  {\"SmartMIPS\",          Mips::AFL_ASE_SMARTMIPS},\n  {\"VZ\",                 Mips::AFL_ASE_VIRT},\n  {\"MSA\",                Mips::AFL_ASE_MSA},\n  {\"MIPS16\",             Mips::AFL_ASE_MIPS16},\n  {\"microMIPS\",          Mips::AFL_ASE_MICROMIPS},\n  {\"XPA\",                Mips::AFL_ASE_XPA},\n  {\"CRC\",                Mips::AFL_ASE_CRC},\n  {\"GINV\",               Mips::AFL_ASE_GINV},\n};\n\nstatic const EnumEntry<unsigned> ElfMipsFpABIType[] = {\n  {\"Hard or soft float\",                  Mips::Val_GNU_MIPS_ABI_FP_ANY},\n  {\"Hard float (double precision)\",       Mips::Val_GNU_MIPS_ABI_FP_DOUBLE},\n  {\"Hard float (single precision)\",       Mips::Val_GNU_MIPS_ABI_FP_SINGLE},\n  {\"Soft float\",                          Mips::Val_GNU_MIPS_ABI_FP_SOFT},\n  {\"Hard float (MIPS32r2 64-bit FPU 12 callee-saved)\",\n   Mips::Val_GNU_MIPS_ABI_FP_OLD_64},\n  {\"Hard float (32-bit CPU, Any FPU)\",    Mips::Val_GNU_MIPS_ABI_FP_XX},\n  {\"Hard float (32-bit CPU, 64-bit FPU)\", Mips::Val_GNU_MIPS_ABI_FP_64},\n  {\"Hard float compat (32-bit CPU, 64-bit FPU)\",\n   Mips::Val_GNU_MIPS_ABI_FP_64A}\n};\n\nstatic const EnumEntry<unsigned> ElfMipsFlags1[] {\n  {\"ODDSPREG\", Mips::AFL_FLAGS1_ODDSPREG},\n};\n\nstatic int getMipsRegisterSize(uint8_t Flag) {\n  switch (Flag) {\n  case Mips::AFL_REG_NONE:\n    return 0;\n  case Mips::AFL_REG_32:\n    return 32;\n  case Mips::AFL_REG_64:\n    return 64;\n  case Mips::AFL_REG_128:\n    return 128;\n  default:\n    return -1;\n  }\n}\n\ntemplate <class ELFT>\nstatic void printMipsReginfoData(ScopedPrinter &W,\n                                 const Elf_Mips_RegInfo<ELFT> &Reginfo) {\n  W.printHex(\"GP\", Reginfo.ri_gp_value);\n  W.printHex(\"General Mask\", Reginfo.ri_gprmask);\n  W.printHex(\"Co-Proc Mask0\", Reginfo.ri_cprmask[0]);\n  W.printHex(\"Co-Proc Mask1\", Reginfo.ri_cprmask[1]);\n  W.printHex(\"Co-Proc Mask2\", Reginfo.ri_cprmask[2]);\n  W.printHex(\"Co-Proc Mask3\", Reginfo.ri_cprmask[3]);\n}\n\ntemplate <class ELFT> void ELFDumper<ELFT>::printMipsReginfo() {\n  const Elf_Shdr *RegInfoSec = findSectionByName(\".reginfo\");\n  if (!RegInfoSec) {\n    W.startLine() << \"There is no .reginfo section in the file.\\n\";\n    return;\n  }\n\n  Expected<ArrayRef<uint8_t>> ContentsOrErr =\n      Obj.getSectionContents(*RegInfoSec);\n  if (!ContentsOrErr) {\n    this->reportUniqueWarning(\n        \"unable to read the content of the .reginfo section (\" +\n        describe(*RegInfoSec) + \"): \" + toString(ContentsOrErr.takeError()));\n    return;\n  }\n\n  if (ContentsOrErr->size() < sizeof(Elf_Mips_RegInfo<ELFT>)) {\n    this->reportUniqueWarning(\"the .reginfo section has an invalid size (0x\" +\n                              Twine::utohexstr(ContentsOrErr->size()) + \")\");\n    return;\n  }\n\n  DictScope GS(W, \"MIPS RegInfo\");\n  printMipsReginfoData(W, *reinterpret_cast<const Elf_Mips_RegInfo<ELFT> *>(\n                              ContentsOrErr->data()));\n}\n\ntemplate <class ELFT>\nstatic Expected<const Elf_Mips_Options<ELFT> *>\nreadMipsOptions(const uint8_t *SecBegin, ArrayRef<uint8_t> &SecData,\n                bool &IsSupported) {\n  if (SecData.size() < sizeof(Elf_Mips_Options<ELFT>))\n    return createError(\"the .MIPS.options section has an invalid size (0x\" +\n                       Twine::utohexstr(SecData.size()) + \")\");\n\n  const Elf_Mips_Options<ELFT> *O =\n      reinterpret_cast<const Elf_Mips_Options<ELFT> *>(SecData.data());\n  const uint8_t Size = O->size;\n  if (Size > SecData.size()) {\n    const uint64_t Offset = SecData.data() - SecBegin;\n    const uint64_t SecSize = Offset + SecData.size();\n    return createError(\"a descriptor of size 0x\" + Twine::utohexstr(Size) +\n                       \" at offset 0x\" + Twine::utohexstr(Offset) +\n                       \" goes past the end of the .MIPS.options \"\n                       \"section of size 0x\" +\n                       Twine::utohexstr(SecSize));\n  }\n\n  IsSupported = O->kind == ODK_REGINFO;\n  const size_t ExpectedSize =\n      sizeof(Elf_Mips_Options<ELFT>) + sizeof(Elf_Mips_RegInfo<ELFT>);\n\n  if (IsSupported)\n    if (Size < ExpectedSize)\n      return createError(\n          \"a .MIPS.options entry of kind \" +\n          Twine(getElfMipsOptionsOdkType(O->kind)) +\n          \" has an invalid size (0x\" + Twine::utohexstr(Size) +\n          \"), the expected size is 0x\" + Twine::utohexstr(ExpectedSize));\n\n  SecData = SecData.drop_front(Size);\n  return O;\n}\n\ntemplate <class ELFT> void ELFDumper<ELFT>::printMipsOptions() {\n  const Elf_Shdr *MipsOpts = findSectionByName(\".MIPS.options\");\n  if (!MipsOpts) {\n    W.startLine() << \"There is no .MIPS.options section in the file.\\n\";\n    return;\n  }\n\n  DictScope GS(W, \"MIPS Options\");\n\n  ArrayRef<uint8_t> Data =\n      unwrapOrError(ObjF.getFileName(), Obj.getSectionContents(*MipsOpts));\n  const uint8_t *const SecBegin = Data.begin();\n  while (!Data.empty()) {\n    bool IsSupported;\n    Expected<const Elf_Mips_Options<ELFT> *> OptsOrErr =\n        readMipsOptions<ELFT>(SecBegin, Data, IsSupported);\n    if (!OptsOrErr) {\n      reportUniqueWarning(OptsOrErr.takeError());\n      break;\n    }\n\n    unsigned Kind = (*OptsOrErr)->kind;\n    const char *Type = getElfMipsOptionsOdkType(Kind);\n    if (!IsSupported) {\n      W.startLine() << \"Unsupported MIPS options tag: \" << Type << \" (\" << Kind\n                    << \")\\n\";\n      continue;\n    }\n\n    DictScope GS(W, Type);\n    if (Kind == ODK_REGINFO)\n      printMipsReginfoData(W, (*OptsOrErr)->getRegInfo());\n    else\n      llvm_unreachable(\"unexpected .MIPS.options section descriptor kind\");\n  }\n}\n\ntemplate <class ELFT> void ELFDumper<ELFT>::printStackMap() const {\n  const Elf_Shdr *StackMapSection = findSectionByName(\".llvm_stackmaps\");\n  if (!StackMapSection)\n    return;\n\n  auto Warn = [&](Error &&E) {\n    this->reportUniqueWarning(\"unable to read the stack map from \" +\n                              describe(*StackMapSection) + \": \" +\n                              toString(std::move(E)));\n  };\n\n  Expected<ArrayRef<uint8_t>> ContentOrErr =\n      Obj.getSectionContents(*StackMapSection);\n  if (!ContentOrErr) {\n    Warn(ContentOrErr.takeError());\n    return;\n  }\n\n  if (Error E = StackMapParser<ELFT::TargetEndianness>::validateHeader(\n          *ContentOrErr)) {\n    Warn(std::move(E));\n    return;\n  }\n\n  prettyPrintStackMap(W, StackMapParser<ELFT::TargetEndianness>(*ContentOrErr));\n}\n\ntemplate <class ELFT>\nvoid ELFDumper<ELFT>::printReloc(const Relocation<ELFT> &R, unsigned RelIndex,\n                                 const Elf_Shdr &Sec, const Elf_Shdr *SymTab) {\n  Expected<RelSymbol<ELFT>> Target = getRelocationTarget(R, SymTab);\n  if (!Target)\n    reportUniqueWarning(\"unable to print relocation \" + Twine(RelIndex) +\n                        \" in \" + describe(Sec) + \": \" +\n                        toString(Target.takeError()));\n  else\n    printRelRelaReloc(R, *Target);\n}\n\nstatic inline void printFields(formatted_raw_ostream &OS, StringRef Str1,\n                               StringRef Str2) {\n  OS.PadToColumn(2u);\n  OS << Str1;\n  OS.PadToColumn(37u);\n  OS << Str2 << \"\\n\";\n  OS.flush();\n}\n\ntemplate <class ELFT>\nstatic std::string getSectionHeadersNumString(const ELFFile<ELFT> &Obj,\n                                              StringRef FileName) {\n  const typename ELFT::Ehdr &ElfHeader = Obj.getHeader();\n  if (ElfHeader.e_shnum != 0)\n    return to_string(ElfHeader.e_shnum);\n\n  Expected<ArrayRef<typename ELFT::Shdr>> ArrOrErr = Obj.sections();\n  if (!ArrOrErr) {\n    // In this case we can ignore an error, because we have already reported a\n    // warning about the broken section header table earlier.\n    consumeError(ArrOrErr.takeError());\n    return \"<?>\";\n  }\n\n  if (ArrOrErr->empty())\n    return \"0\";\n  return \"0 (\" + to_string((*ArrOrErr)[0].sh_size) + \")\";\n}\n\ntemplate <class ELFT>\nstatic std::string getSectionHeaderTableIndexString(const ELFFile<ELFT> &Obj,\n                                                    StringRef FileName) {\n  const typename ELFT::Ehdr &ElfHeader = Obj.getHeader();\n  if (ElfHeader.e_shstrndx != SHN_XINDEX)\n    return to_string(ElfHeader.e_shstrndx);\n\n  Expected<ArrayRef<typename ELFT::Shdr>> ArrOrErr = Obj.sections();\n  if (!ArrOrErr) {\n    // In this case we can ignore an error, because we have already reported a\n    // warning about the broken section header table earlier.\n    consumeError(ArrOrErr.takeError());\n    return \"<?>\";\n  }\n\n  if (ArrOrErr->empty())\n    return \"65535 (corrupt: out of range)\";\n  return to_string(ElfHeader.e_shstrndx) + \" (\" +\n         to_string((*ArrOrErr)[0].sh_link) + \")\";\n}\n\nstatic const EnumEntry<unsigned> *getObjectFileEnumEntry(unsigned Type) {\n  auto It = llvm::find_if(ElfObjectFileType, [&](const EnumEntry<unsigned> &E) {\n    return E.Value == Type;\n  });\n  if (It != makeArrayRef(ElfObjectFileType).end())\n    return It;\n  return nullptr;\n}\n\ntemplate <class ELFT> void GNUELFDumper<ELFT>::printFileHeaders() {\n  const Elf_Ehdr &e = this->Obj.getHeader();\n  OS << \"ELF Header:\\n\";\n  OS << \"  Magic:  \";\n  std::string Str;\n  for (int i = 0; i < ELF::EI_NIDENT; i++)\n    OS << format(\" %02x\", static_cast<int>(e.e_ident[i]));\n  OS << \"\\n\";\n  Str = printEnum(e.e_ident[ELF::EI_CLASS], makeArrayRef(ElfClass));\n  printFields(OS, \"Class:\", Str);\n  Str = printEnum(e.e_ident[ELF::EI_DATA], makeArrayRef(ElfDataEncoding));\n  printFields(OS, \"Data:\", Str);\n  OS.PadToColumn(2u);\n  OS << \"Version:\";\n  OS.PadToColumn(37u);\n  OS << to_hexString(e.e_ident[ELF::EI_VERSION]);\n  if (e.e_version == ELF::EV_CURRENT)\n    OS << \" (current)\";\n  OS << \"\\n\";\n  Str = printEnum(e.e_ident[ELF::EI_OSABI], makeArrayRef(ElfOSABI));\n  printFields(OS, \"OS/ABI:\", Str);\n  printFields(OS,\n              \"ABI Version:\", std::to_string(e.e_ident[ELF::EI_ABIVERSION]));\n\n  if (const EnumEntry<unsigned> *E = getObjectFileEnumEntry(e.e_type)) {\n    Str = E->AltName.str();\n  } else {\n    if (e.e_type >= ET_LOPROC)\n      Str = \"Processor Specific: (\" + to_hexString(e.e_type, false) + \")\";\n    else if (e.e_type >= ET_LOOS)\n      Str = \"OS Specific: (\" + to_hexString(e.e_type, false) + \")\";\n    else\n      Str = \"<unknown>: \" + to_hexString(e.e_type, false);\n  }\n  printFields(OS, \"Type:\", Str);\n\n  Str = printEnum(e.e_machine, makeArrayRef(ElfMachineType));\n  printFields(OS, \"Machine:\", Str);\n  Str = \"0x\" + to_hexString(e.e_version);\n  printFields(OS, \"Version:\", Str);\n  Str = \"0x\" + to_hexString(e.e_entry);\n  printFields(OS, \"Entry point address:\", Str);\n  Str = to_string(e.e_phoff) + \" (bytes into file)\";\n  printFields(OS, \"Start of program headers:\", Str);\n  Str = to_string(e.e_shoff) + \" (bytes into file)\";\n  printFields(OS, \"Start of section headers:\", Str);\n  std::string ElfFlags;\n  if (e.e_machine == EM_MIPS)\n    ElfFlags =\n        printFlags(e.e_flags, makeArrayRef(ElfHeaderMipsFlags),\n                   unsigned(ELF::EF_MIPS_ARCH), unsigned(ELF::EF_MIPS_ABI),\n                   unsigned(ELF::EF_MIPS_MACH));\n  else if (e.e_machine == EM_RISCV)\n    ElfFlags = printFlags(e.e_flags, makeArrayRef(ElfHeaderRISCVFlags));\n  Str = \"0x\" + to_hexString(e.e_flags);\n  if (!ElfFlags.empty())\n    Str = Str + \", \" + ElfFlags;\n  printFields(OS, \"Flags:\", Str);\n  Str = to_string(e.e_ehsize) + \" (bytes)\";\n  printFields(OS, \"Size of this header:\", Str);\n  Str = to_string(e.e_phentsize) + \" (bytes)\";\n  printFields(OS, \"Size of program headers:\", Str);\n  Str = to_string(e.e_phnum);\n  printFields(OS, \"Number of program headers:\", Str);\n  Str = to_string(e.e_shentsize) + \" (bytes)\";\n  printFields(OS, \"Size of section headers:\", Str);\n  Str = getSectionHeadersNumString(this->Obj, this->FileName);\n  printFields(OS, \"Number of section headers:\", Str);\n  Str = getSectionHeaderTableIndexString(this->Obj, this->FileName);\n  printFields(OS, \"Section header string table index:\", Str);\n}\n\ntemplate <class ELFT> std::vector<GroupSection> ELFDumper<ELFT>::getGroups() {\n  auto GetSignature = [&](const Elf_Sym &Sym, unsigned SymNdx,\n                          const Elf_Shdr &Symtab) -> StringRef {\n    Expected<StringRef> StrTableOrErr = Obj.getStringTableForSymtab(Symtab);\n    if (!StrTableOrErr) {\n      reportUniqueWarning(\"unable to get the string table for \" +\n                          describe(Symtab) + \": \" +\n                          toString(StrTableOrErr.takeError()));\n      return \"<?>\";\n    }\n\n    StringRef Strings = *StrTableOrErr;\n    if (Sym.st_name >= Strings.size()) {\n      reportUniqueWarning(\"unable to get the name of the symbol with index \" +\n                          Twine(SymNdx) + \": st_name (0x\" +\n                          Twine::utohexstr(Sym.st_name) +\n                          \") is past the end of the string table of size 0x\" +\n                          Twine::utohexstr(Strings.size()));\n      return \"<?>\";\n    }\n\n    return StrTableOrErr->data() + Sym.st_name;\n  };\n\n  std::vector<GroupSection> Ret;\n  uint64_t I = 0;\n  for (const Elf_Shdr &Sec : cantFail(Obj.sections())) {\n    ++I;\n    if (Sec.sh_type != ELF::SHT_GROUP)\n      continue;\n\n    StringRef Signature = \"<?>\";\n    if (Expected<const Elf_Shdr *> SymtabOrErr = Obj.getSection(Sec.sh_link)) {\n      if (Expected<const Elf_Sym *> SymOrErr =\n              Obj.template getEntry<Elf_Sym>(**SymtabOrErr, Sec.sh_info))\n        Signature = GetSignature(**SymOrErr, Sec.sh_info, **SymtabOrErr);\n      else\n        reportUniqueWarning(\"unable to get the signature symbol for \" +\n                            describe(Sec) + \": \" +\n                            toString(SymOrErr.takeError()));\n    } else {\n      reportUniqueWarning(\"unable to get the symbol table for \" +\n                          describe(Sec) + \": \" +\n                          toString(SymtabOrErr.takeError()));\n    }\n\n    ArrayRef<Elf_Word> Data;\n    if (Expected<ArrayRef<Elf_Word>> ContentsOrErr =\n            Obj.template getSectionContentsAsArray<Elf_Word>(Sec)) {\n      if (ContentsOrErr->empty())\n        reportUniqueWarning(\"unable to read the section group flag from the \" +\n                            describe(Sec) + \": the section is empty\");\n      else\n        Data = *ContentsOrErr;\n    } else {\n      reportUniqueWarning(\"unable to get the content of the \" + describe(Sec) +\n                          \": \" + toString(ContentsOrErr.takeError()));\n    }\n\n    Ret.push_back({getPrintableSectionName(Sec),\n                   maybeDemangle(Signature),\n                   Sec.sh_name,\n                   I - 1,\n                   Sec.sh_link,\n                   Sec.sh_info,\n                   Data.empty() ? Elf_Word(0) : Data[0],\n                   {}});\n\n    if (Data.empty())\n      continue;\n\n    std::vector<GroupMember> &GM = Ret.back().Members;\n    for (uint32_t Ndx : Data.slice(1)) {\n      if (Expected<const Elf_Shdr *> SecOrErr = Obj.getSection(Ndx)) {\n        GM.push_back({getPrintableSectionName(**SecOrErr), Ndx});\n      } else {\n        reportUniqueWarning(\"unable to get the section with index \" +\n                            Twine(Ndx) + \" when dumping the \" + describe(Sec) +\n                            \": \" + toString(SecOrErr.takeError()));\n        GM.push_back({\"<?>\", Ndx});\n      }\n    }\n  }\n  return Ret;\n}\n\nstatic DenseMap<uint64_t, const GroupSection *>\nmapSectionsToGroups(ArrayRef<GroupSection> Groups) {\n  DenseMap<uint64_t, const GroupSection *> Ret;\n  for (const GroupSection &G : Groups)\n    for (const GroupMember &GM : G.Members)\n      Ret.insert({GM.Index, &G});\n  return Ret;\n}\n\ntemplate <class ELFT> void GNUELFDumper<ELFT>::printGroupSections() {\n  std::vector<GroupSection> V = this->getGroups();\n  DenseMap<uint64_t, const GroupSection *> Map = mapSectionsToGroups(V);\n  for (const GroupSection &G : V) {\n    OS << \"\\n\"\n       << getGroupType(G.Type) << \" group section [\"\n       << format_decimal(G.Index, 5) << \"] `\" << G.Name << \"' [\" << G.Signature\n       << \"] contains \" << G.Members.size() << \" sections:\\n\"\n       << \"   [Index]    Name\\n\";\n    for (const GroupMember &GM : G.Members) {\n      const GroupSection *MainGroup = Map[GM.Index];\n      if (MainGroup != &G)\n        this->reportUniqueWarning(\n            \"section with index \" + Twine(GM.Index) +\n            \", included in the group section with index \" +\n            Twine(MainGroup->Index) +\n            \", was also found in the group section with index \" +\n            Twine(G.Index));\n      OS << \"   [\" << format_decimal(GM.Index, 5) << \"]   \" << GM.Name << \"\\n\";\n    }\n  }\n\n  if (V.empty())\n    OS << \"There are no section groups in this file.\\n\";\n}\n\ntemplate <class ELFT>\nvoid GNUELFDumper<ELFT>::printRelrReloc(const Elf_Relr &R) {\n  OS << to_string(format_hex_no_prefix(R, ELFT::Is64Bits ? 16 : 8)) << \"\\n\";\n}\n\ntemplate <class ELFT>\nvoid GNUELFDumper<ELFT>::printRelRelaReloc(const Relocation<ELFT> &R,\n                                           const RelSymbol<ELFT> &RelSym) {\n  // First two fields are bit width dependent. The rest of them are fixed width.\n  unsigned Bias = ELFT::Is64Bits ? 8 : 0;\n  Field Fields[5] = {0, 10 + Bias, 19 + 2 * Bias, 42 + 2 * Bias, 53 + 2 * Bias};\n  unsigned Width = ELFT::Is64Bits ? 16 : 8;\n\n  Fields[0].Str = to_string(format_hex_no_prefix(R.Offset, Width));\n  Fields[1].Str = to_string(format_hex_no_prefix(R.Info, Width));\n\n  SmallString<32> RelocName;\n  this->Obj.getRelocationTypeName(R.Type, RelocName);\n  Fields[2].Str = RelocName.c_str();\n\n  if (RelSym.Sym)\n    Fields[3].Str =\n        to_string(format_hex_no_prefix(RelSym.Sym->getValue(), Width));\n\n  Fields[4].Str = std::string(RelSym.Name);\n  for (const Field &F : Fields)\n    printField(F);\n\n  std::string Addend;\n  if (Optional<int64_t> A = R.Addend) {\n    int64_t RelAddend = *A;\n    if (!RelSym.Name.empty()) {\n      if (RelAddend < 0) {\n        Addend = \" - \";\n        RelAddend = std::abs(RelAddend);\n      } else {\n        Addend = \" + \";\n      }\n    }\n    Addend += to_hexString(RelAddend, false);\n  }\n  OS << Addend << \"\\n\";\n}\n\ntemplate <class ELFT>\nstatic void printRelocHeaderFields(formatted_raw_ostream &OS, unsigned SType) {\n  bool IsRela = SType == ELF::SHT_RELA || SType == ELF::SHT_ANDROID_RELA;\n  bool IsRelr = SType == ELF::SHT_RELR || SType == ELF::SHT_ANDROID_RELR;\n  if (ELFT::Is64Bits)\n    OS << \"    \";\n  else\n    OS << \" \";\n  if (IsRelr && opts::RawRelr)\n    OS << \"Data  \";\n  else\n    OS << \"Offset\";\n  if (ELFT::Is64Bits)\n    OS << \"             Info             Type\"\n       << \"               Symbol's Value  Symbol's Name\";\n  else\n    OS << \"     Info    Type                Sym. Value  Symbol's Name\";\n  if (IsRela)\n    OS << \" + Addend\";\n  OS << \"\\n\";\n}\n\ntemplate <class ELFT>\nvoid GNUELFDumper<ELFT>::printDynamicRelocHeader(unsigned Type, StringRef Name,\n                                                 const DynRegionInfo &Reg) {\n  uint64_t Offset = Reg.Addr - this->Obj.base();\n  OS << \"\\n'\" << Name.str().c_str() << \"' relocation section at offset 0x\"\n     << to_hexString(Offset, false) << \" contains \" << Reg.Size << \" bytes:\\n\";\n  printRelocHeaderFields<ELFT>(OS, Type);\n}\n\ntemplate <class ELFT>\nstatic bool isRelocationSec(const typename ELFT::Shdr &Sec) {\n  return Sec.sh_type == ELF::SHT_REL || Sec.sh_type == ELF::SHT_RELA ||\n         Sec.sh_type == ELF::SHT_RELR || Sec.sh_type == ELF::SHT_ANDROID_REL ||\n         Sec.sh_type == ELF::SHT_ANDROID_RELA ||\n         Sec.sh_type == ELF::SHT_ANDROID_RELR;\n}\n\ntemplate <class ELFT> void GNUELFDumper<ELFT>::printRelocations() {\n  auto GetEntriesNum = [&](const Elf_Shdr &Sec) -> Expected<size_t> {\n    // Android's packed relocation section needs to be unpacked first\n    // to get the actual number of entries.\n    if (Sec.sh_type == ELF::SHT_ANDROID_REL ||\n        Sec.sh_type == ELF::SHT_ANDROID_RELA) {\n      Expected<std::vector<typename ELFT::Rela>> RelasOrErr =\n          this->Obj.android_relas(Sec);\n      if (!RelasOrErr)\n        return RelasOrErr.takeError();\n      return RelasOrErr->size();\n    }\n\n    if (!opts::RawRelr && (Sec.sh_type == ELF::SHT_RELR ||\n                           Sec.sh_type == ELF::SHT_ANDROID_RELR)) {\n      Expected<Elf_Relr_Range> RelrsOrErr = this->Obj.relrs(Sec);\n      if (!RelrsOrErr)\n        return RelrsOrErr.takeError();\n      return this->Obj.decode_relrs(*RelrsOrErr).size();\n    }\n\n    return Sec.getEntityCount();\n  };\n\n  bool HasRelocSections = false;\n  for (const Elf_Shdr &Sec : cantFail(this->Obj.sections())) {\n    if (!isRelocationSec<ELFT>(Sec))\n      continue;\n    HasRelocSections = true;\n\n    std::string EntriesNum = \"<?>\";\n    if (Expected<size_t> NumOrErr = GetEntriesNum(Sec))\n      EntriesNum = std::to_string(*NumOrErr);\n    else\n      this->reportUniqueWarning(\"unable to get the number of relocations in \" +\n                                this->describe(Sec) + \": \" +\n                                toString(NumOrErr.takeError()));\n\n    uintX_t Offset = Sec.sh_offset;\n    StringRef Name = this->getPrintableSectionName(Sec);\n    OS << \"\\nRelocation section '\" << Name << \"' at offset 0x\"\n       << to_hexString(Offset, false) << \" contains \" << EntriesNum\n       << \" entries:\\n\";\n    printRelocHeaderFields<ELFT>(OS, Sec.sh_type);\n    this->printRelocationsHelper(Sec);\n  }\n  if (!HasRelocSections)\n    OS << \"\\nThere are no relocations in this file.\\n\";\n}\n\n// Print the offset of a particular section from anyone of the ranges:\n// [SHT_LOOS, SHT_HIOS], [SHT_LOPROC, SHT_HIPROC], [SHT_LOUSER, SHT_HIUSER].\n// If 'Type' does not fall within any of those ranges, then a string is\n// returned as '<unknown>' followed by the type value.\nstatic std::string getSectionTypeOffsetString(unsigned Type) {\n  if (Type >= SHT_LOOS && Type <= SHT_HIOS)\n    return \"LOOS+0x\" + to_hexString(Type - SHT_LOOS);\n  else if (Type >= SHT_LOPROC && Type <= SHT_HIPROC)\n    return \"LOPROC+0x\" + to_hexString(Type - SHT_LOPROC);\n  else if (Type >= SHT_LOUSER && Type <= SHT_HIUSER)\n    return \"LOUSER+0x\" + to_hexString(Type - SHT_LOUSER);\n  return \"0x\" + to_hexString(Type) + \": <unknown>\";\n}\n\nstatic std::string getSectionTypeString(unsigned Machine, unsigned Type) {\n  StringRef Name = getELFSectionTypeName(Machine, Type);\n\n  // Handle SHT_GNU_* type names.\n  if (Name.startswith(\"SHT_GNU_\")) {\n    if (Name == \"SHT_GNU_HASH\")\n      return \"GNU_HASH\";\n    // E.g. SHT_GNU_verneed -> VERNEED.\n    return Name.drop_front(8).upper();\n  }\n\n  if (Name == \"SHT_SYMTAB_SHNDX\")\n    return \"SYMTAB SECTION INDICES\";\n\n  if (Name.startswith(\"SHT_\"))\n    return Name.drop_front(4).str();\n  return getSectionTypeOffsetString(Type);\n}\n\nstatic void printSectionDescription(formatted_raw_ostream &OS,\n                                    unsigned EMachine) {\n  OS << \"Key to Flags:\\n\";\n  OS << \"  W (write), A (alloc), X (execute), M (merge), S (strings), I \"\n        \"(info),\\n\";\n  OS << \"  L (link order), O (extra OS processing required), G (group), T \"\n        \"(TLS),\\n\";\n  OS << \"  C (compressed), x (unknown), o (OS specific), E (exclude),\\n\";\n  OS << \"  R (retain)\";\n\n  if (EMachine == EM_X86_64)\n    OS << \", l (large)\";\n  else if (EMachine == EM_ARM)\n    OS << \", y (purecode)\";\n\n  OS << \", p (processor specific)\\n\";\n}\n\ntemplate <class ELFT> void GNUELFDumper<ELFT>::printSectionHeaders() {\n  unsigned Bias = ELFT::Is64Bits ? 0 : 8;\n  ArrayRef<Elf_Shdr> Sections = cantFail(this->Obj.sections());\n  OS << \"There are \" << to_string(Sections.size())\n     << \" section headers, starting at offset \"\n     << \"0x\" << to_hexString(this->Obj.getHeader().e_shoff, false) << \":\\n\\n\";\n  OS << \"Section Headers:\\n\";\n  Field Fields[11] = {\n      {\"[Nr]\", 2},        {\"Name\", 7},        {\"Type\", 25},\n      {\"Address\", 41},    {\"Off\", 58 - Bias}, {\"Size\", 65 - Bias},\n      {\"ES\", 72 - Bias},  {\"Flg\", 75 - Bias}, {\"Lk\", 79 - Bias},\n      {\"Inf\", 82 - Bias}, {\"Al\", 86 - Bias}};\n  for (const Field &F : Fields)\n    printField(F);\n  OS << \"\\n\";\n\n  StringRef SecStrTable;\n  if (Expected<StringRef> SecStrTableOrErr =\n          this->Obj.getSectionStringTable(Sections, this->WarningHandler))\n    SecStrTable = *SecStrTableOrErr;\n  else\n    this->reportUniqueWarning(SecStrTableOrErr.takeError());\n\n  size_t SectionIndex = 0;\n  for (const Elf_Shdr &Sec : Sections) {\n    Fields[0].Str = to_string(SectionIndex);\n    if (SecStrTable.empty())\n      Fields[1].Str = \"<no-strings>\";\n    else\n      Fields[1].Str = std::string(unwrapOrError<StringRef>(\n          this->FileName, this->Obj.getSectionName(Sec, SecStrTable)));\n    Fields[2].Str =\n        getSectionTypeString(this->Obj.getHeader().e_machine, Sec.sh_type);\n    Fields[3].Str =\n        to_string(format_hex_no_prefix(Sec.sh_addr, ELFT::Is64Bits ? 16 : 8));\n    Fields[4].Str = to_string(format_hex_no_prefix(Sec.sh_offset, 6));\n    Fields[5].Str = to_string(format_hex_no_prefix(Sec.sh_size, 6));\n    Fields[6].Str = to_string(format_hex_no_prefix(Sec.sh_entsize, 2));\n    Fields[7].Str = getGNUFlags(this->Obj.getHeader().e_machine, Sec.sh_flags);\n    Fields[8].Str = to_string(Sec.sh_link);\n    Fields[9].Str = to_string(Sec.sh_info);\n    Fields[10].Str = to_string(Sec.sh_addralign);\n\n    OS.PadToColumn(Fields[0].Column);\n    OS << \"[\" << right_justify(Fields[0].Str, 2) << \"]\";\n    for (int i = 1; i < 7; i++)\n      printField(Fields[i]);\n    OS.PadToColumn(Fields[7].Column);\n    OS << right_justify(Fields[7].Str, 3);\n    OS.PadToColumn(Fields[8].Column);\n    OS << right_justify(Fields[8].Str, 2);\n    OS.PadToColumn(Fields[9].Column);\n    OS << right_justify(Fields[9].Str, 3);\n    OS.PadToColumn(Fields[10].Column);\n    OS << right_justify(Fields[10].Str, 2);\n    OS << \"\\n\";\n    ++SectionIndex;\n  }\n  printSectionDescription(OS, this->Obj.getHeader().e_machine);\n}\n\ntemplate <class ELFT>\nvoid GNUELFDumper<ELFT>::printSymtabMessage(const Elf_Shdr *Symtab,\n                                            size_t Entries,\n                                            bool NonVisibilityBitsUsed) const {\n  StringRef Name;\n  if (Symtab)\n    Name = this->getPrintableSectionName(*Symtab);\n  if (!Name.empty())\n    OS << \"\\nSymbol table '\" << Name << \"'\";\n  else\n    OS << \"\\nSymbol table for image\";\n  OS << \" contains \" << Entries << \" entries:\\n\";\n\n  if (ELFT::Is64Bits)\n    OS << \"   Num:    Value          Size Type    Bind   Vis\";\n  else\n    OS << \"   Num:    Value  Size Type    Bind   Vis\";\n\n  if (NonVisibilityBitsUsed)\n    OS << \"             \";\n  OS << \"       Ndx Name\\n\";\n}\n\ntemplate <class ELFT>\nstd::string\nGNUELFDumper<ELFT>::getSymbolSectionNdx(const Elf_Sym &Symbol,\n                                        unsigned SymIndex,\n                                        DataRegion<Elf_Word> ShndxTable) const {\n  unsigned SectionIndex = Symbol.st_shndx;\n  switch (SectionIndex) {\n  case ELF::SHN_UNDEF:\n    return \"UND\";\n  case ELF::SHN_ABS:\n    return \"ABS\";\n  case ELF::SHN_COMMON:\n    return \"COM\";\n  case ELF::SHN_XINDEX: {\n    Expected<uint32_t> IndexOrErr =\n        object::getExtendedSymbolTableIndex<ELFT>(Symbol, SymIndex, ShndxTable);\n    if (!IndexOrErr) {\n      assert(Symbol.st_shndx == SHN_XINDEX &&\n             \"getExtendedSymbolTableIndex should only fail due to an invalid \"\n             \"SHT_SYMTAB_SHNDX table/reference\");\n      this->reportUniqueWarning(IndexOrErr.takeError());\n      return \"RSV[0xffff]\";\n    }\n    return to_string(format_decimal(*IndexOrErr, 3));\n  }\n  default:\n    // Find if:\n    // Processor specific\n    if (SectionIndex >= ELF::SHN_LOPROC && SectionIndex <= ELF::SHN_HIPROC)\n      return std::string(\"PRC[0x\") +\n             to_string(format_hex_no_prefix(SectionIndex, 4)) + \"]\";\n    // OS specific\n    if (SectionIndex >= ELF::SHN_LOOS && SectionIndex <= ELF::SHN_HIOS)\n      return std::string(\"OS[0x\") +\n             to_string(format_hex_no_prefix(SectionIndex, 4)) + \"]\";\n    // Architecture reserved:\n    if (SectionIndex >= ELF::SHN_LORESERVE &&\n        SectionIndex <= ELF::SHN_HIRESERVE)\n      return std::string(\"RSV[0x\") +\n             to_string(format_hex_no_prefix(SectionIndex, 4)) + \"]\";\n    // A normal section with an index\n    return to_string(format_decimal(SectionIndex, 3));\n  }\n}\n\ntemplate <class ELFT>\nvoid GNUELFDumper<ELFT>::printSymbol(const Elf_Sym &Symbol, unsigned SymIndex,\n                                     DataRegion<Elf_Word> ShndxTable,\n                                     Optional<StringRef> StrTable,\n                                     bool IsDynamic,\n                                     bool NonVisibilityBitsUsed) const {\n  unsigned Bias = ELFT::Is64Bits ? 8 : 0;\n  Field Fields[8] = {0,         8,         17 + Bias, 23 + Bias,\n                     31 + Bias, 38 + Bias, 48 + Bias, 51 + Bias};\n  Fields[0].Str = to_string(format_decimal(SymIndex, 6)) + \":\";\n  Fields[1].Str =\n      to_string(format_hex_no_prefix(Symbol.st_value, ELFT::Is64Bits ? 16 : 8));\n  Fields[2].Str = to_string(format_decimal(Symbol.st_size, 5));\n\n  unsigned char SymbolType = Symbol.getType();\n  if (this->Obj.getHeader().e_machine == ELF::EM_AMDGPU &&\n      SymbolType >= ELF::STT_LOOS && SymbolType < ELF::STT_HIOS)\n    Fields[3].Str = printEnum(SymbolType, makeArrayRef(AMDGPUSymbolTypes));\n  else\n    Fields[3].Str = printEnum(SymbolType, makeArrayRef(ElfSymbolTypes));\n\n  Fields[4].Str =\n      printEnum(Symbol.getBinding(), makeArrayRef(ElfSymbolBindings));\n  Fields[5].Str =\n      printEnum(Symbol.getVisibility(), makeArrayRef(ElfSymbolVisibilities));\n\n  if (Symbol.st_other & ~0x3) {\n    if (this->Obj.getHeader().e_machine == ELF::EM_AARCH64) {\n      uint8_t Other = Symbol.st_other & ~0x3;\n      if (Other & STO_AARCH64_VARIANT_PCS) {\n        Other &= ~STO_AARCH64_VARIANT_PCS;\n        Fields[5].Str += \" [VARIANT_PCS\";\n        if (Other != 0)\n          Fields[5].Str.append(\" | \" + to_hexString(Other, false));\n        Fields[5].Str.append(\"]\");\n      }\n    } else {\n      Fields[5].Str +=\n          \" [<other: \" + to_string(format_hex(Symbol.st_other, 2)) + \">]\";\n    }\n  }\n\n  Fields[6].Column += NonVisibilityBitsUsed ? 13 : 0;\n  Fields[6].Str = getSymbolSectionNdx(Symbol, SymIndex, ShndxTable);\n\n  Fields[7].Str = this->getFullSymbolName(Symbol, SymIndex, ShndxTable,\n                                          StrTable, IsDynamic);\n  for (const Field &Entry : Fields)\n    printField(Entry);\n  OS << \"\\n\";\n}\n\ntemplate <class ELFT>\nvoid GNUELFDumper<ELFT>::printHashedSymbol(const Elf_Sym *Symbol,\n                                           unsigned SymIndex,\n                                           DataRegion<Elf_Word> ShndxTable,\n                                           StringRef StrTable,\n                                           uint32_t Bucket) {\n  unsigned Bias = ELFT::Is64Bits ? 8 : 0;\n  Field Fields[9] = {0,         6,         11,        20 + Bias, 25 + Bias,\n                     34 + Bias, 41 + Bias, 49 + Bias, 53 + Bias};\n  Fields[0].Str = to_string(format_decimal(SymIndex, 5));\n  Fields[1].Str = to_string(format_decimal(Bucket, 3)) + \":\";\n\n  Fields[2].Str = to_string(\n      format_hex_no_prefix(Symbol->st_value, ELFT::Is64Bits ? 16 : 8));\n  Fields[3].Str = to_string(format_decimal(Symbol->st_size, 5));\n\n  unsigned char SymbolType = Symbol->getType();\n  if (this->Obj.getHeader().e_machine == ELF::EM_AMDGPU &&\n      SymbolType >= ELF::STT_LOOS && SymbolType < ELF::STT_HIOS)\n    Fields[4].Str = printEnum(SymbolType, makeArrayRef(AMDGPUSymbolTypes));\n  else\n    Fields[4].Str = printEnum(SymbolType, makeArrayRef(ElfSymbolTypes));\n\n  Fields[5].Str =\n      printEnum(Symbol->getBinding(), makeArrayRef(ElfSymbolBindings));\n  Fields[6].Str =\n      printEnum(Symbol->getVisibility(), makeArrayRef(ElfSymbolVisibilities));\n  Fields[7].Str = getSymbolSectionNdx(*Symbol, SymIndex, ShndxTable);\n  Fields[8].Str =\n      this->getFullSymbolName(*Symbol, SymIndex, ShndxTable, StrTable, true);\n\n  for (const Field &Entry : Fields)\n    printField(Entry);\n  OS << \"\\n\";\n}\n\ntemplate <class ELFT>\nvoid GNUELFDumper<ELFT>::printSymbols(bool PrintSymbols,\n                                      bool PrintDynamicSymbols) {\n  if (!PrintSymbols && !PrintDynamicSymbols)\n    return;\n  // GNU readelf prints both the .dynsym and .symtab with --symbols.\n  this->printSymbolsHelper(true);\n  if (PrintSymbols)\n    this->printSymbolsHelper(false);\n}\n\ntemplate <class ELFT>\nvoid GNUELFDumper<ELFT>::printHashTableSymbols(const Elf_Hash &SysVHash) {\n  if (this->DynamicStringTable.empty())\n    return;\n\n  if (ELFT::Is64Bits)\n    OS << \"  Num Buc:    Value          Size   Type   Bind Vis      Ndx Name\";\n  else\n    OS << \"  Num Buc:    Value  Size   Type   Bind Vis      Ndx Name\";\n  OS << \"\\n\";\n\n  Elf_Sym_Range DynSyms = this->dynamic_symbols();\n  const Elf_Sym *FirstSym = DynSyms.empty() ? nullptr : &DynSyms[0];\n  if (!FirstSym) {\n    this->reportUniqueWarning(\n        Twine(\"unable to print symbols for the .hash table: the \"\n              \"dynamic symbol table \") +\n        (this->DynSymRegion ? \"is empty\" : \"was not found\"));\n    return;\n  }\n\n  DataRegion<Elf_Word> ShndxTable(\n      (const Elf_Word *)this->DynSymTabShndxRegion.Addr, this->Obj.end());\n  auto Buckets = SysVHash.buckets();\n  auto Chains = SysVHash.chains();\n  for (uint32_t Buc = 0; Buc < SysVHash.nbucket; Buc++) {\n    if (Buckets[Buc] == ELF::STN_UNDEF)\n      continue;\n    std::vector<bool> Visited(SysVHash.nchain);\n    for (uint32_t Ch = Buckets[Buc]; Ch < SysVHash.nchain; Ch = Chains[Ch]) {\n      if (Ch == ELF::STN_UNDEF)\n        break;\n\n      if (Visited[Ch]) {\n        this->reportUniqueWarning(\".hash section is invalid: bucket \" +\n                                  Twine(Ch) +\n                                  \": a cycle was detected in the linked chain\");\n        break;\n      }\n\n      printHashedSymbol(FirstSym + Ch, Ch, ShndxTable, this->DynamicStringTable,\n                        Buc);\n      Visited[Ch] = true;\n    }\n  }\n}\n\ntemplate <class ELFT>\nvoid GNUELFDumper<ELFT>::printGnuHashTableSymbols(const Elf_GnuHash &GnuHash) {\n  if (this->DynamicStringTable.empty())\n    return;\n\n  Elf_Sym_Range DynSyms = this->dynamic_symbols();\n  const Elf_Sym *FirstSym = DynSyms.empty() ? nullptr : &DynSyms[0];\n  if (!FirstSym) {\n    this->reportUniqueWarning(\n        Twine(\"unable to print symbols for the .gnu.hash table: the \"\n              \"dynamic symbol table \") +\n        (this->DynSymRegion ? \"is empty\" : \"was not found\"));\n    return;\n  }\n\n  auto GetSymbol = [&](uint64_t SymIndex,\n                       uint64_t SymsTotal) -> const Elf_Sym * {\n    if (SymIndex >= SymsTotal) {\n      this->reportUniqueWarning(\n          \"unable to print hashed symbol with index \" + Twine(SymIndex) +\n          \", which is greater than or equal to the number of dynamic symbols \"\n          \"(\" +\n          Twine::utohexstr(SymsTotal) + \")\");\n      return nullptr;\n    }\n    return FirstSym + SymIndex;\n  };\n\n  Expected<ArrayRef<Elf_Word>> ValuesOrErr =\n      getGnuHashTableChains<ELFT>(this->DynSymRegion, &GnuHash);\n  ArrayRef<Elf_Word> Values;\n  if (!ValuesOrErr)\n    this->reportUniqueWarning(\"unable to get hash values for the SHT_GNU_HASH \"\n                              \"section: \" +\n                              toString(ValuesOrErr.takeError()));\n  else\n    Values = *ValuesOrErr;\n\n  DataRegion<Elf_Word> ShndxTable(\n      (const Elf_Word *)this->DynSymTabShndxRegion.Addr, this->Obj.end());\n  ArrayRef<Elf_Word> Buckets = GnuHash.buckets();\n  for (uint32_t Buc = 0; Buc < GnuHash.nbuckets; Buc++) {\n    if (Buckets[Buc] == ELF::STN_UNDEF)\n      continue;\n    uint32_t Index = Buckets[Buc];\n    // Print whole chain.\n    while (true) {\n      uint32_t SymIndex = Index++;\n      if (const Elf_Sym *Sym = GetSymbol(SymIndex, DynSyms.size()))\n        printHashedSymbol(Sym, SymIndex, ShndxTable, this->DynamicStringTable,\n                          Buc);\n      else\n        break;\n\n      if (SymIndex < GnuHash.symndx) {\n        this->reportUniqueWarning(\n            \"unable to read the hash value for symbol with index \" +\n            Twine(SymIndex) +\n            \", which is less than the index of the first hashed symbol (\" +\n            Twine(GnuHash.symndx) + \")\");\n        break;\n      }\n\n       // Chain ends at symbol with stopper bit.\n      if ((Values[SymIndex - GnuHash.symndx] & 1) == 1)\n        break;\n    }\n  }\n}\n\ntemplate <class ELFT> void GNUELFDumper<ELFT>::printHashSymbols() {\n  if (this->HashTable) {\n    OS << \"\\n Symbol table of .hash for image:\\n\";\n    if (Error E = checkHashTable<ELFT>(*this, this->HashTable))\n      this->reportUniqueWarning(std::move(E));\n    else\n      printHashTableSymbols(*this->HashTable);\n  }\n\n  // Try printing the .gnu.hash table.\n  if (this->GnuHashTable) {\n    OS << \"\\n Symbol table of .gnu.hash for image:\\n\";\n    if (ELFT::Is64Bits)\n      OS << \"  Num Buc:    Value          Size   Type   Bind Vis      Ndx Name\";\n    else\n      OS << \"  Num Buc:    Value  Size   Type   Bind Vis      Ndx Name\";\n    OS << \"\\n\";\n\n    if (Error E = checkGNUHashTable<ELFT>(this->Obj, this->GnuHashTable))\n      this->reportUniqueWarning(std::move(E));\n    else\n      printGnuHashTableSymbols(*this->GnuHashTable);\n  }\n}\n\ntemplate <class ELFT> void GNUELFDumper<ELFT>::printSectionDetails() {\n  ArrayRef<Elf_Shdr> Sections = cantFail(this->Obj.sections());\n  OS << \"There are \" << to_string(Sections.size())\n     << \" section headers, starting at offset \"\n     << \"0x\" << to_hexString(this->Obj.getHeader().e_shoff, false) << \":\\n\\n\";\n\n  OS << \"Section Headers:\\n\";\n\n  auto PrintFields = [&](ArrayRef<Field> V) {\n    for (const Field &F : V)\n      printField(F);\n    OS << \"\\n\";\n  };\n\n  PrintFields({{\"[Nr]\", 2}, {\"Name\", 7}});\n\n  constexpr bool Is64 = ELFT::Is64Bits;\n  PrintFields({{\"Type\", 7},\n               {Is64 ? \"Address\" : \"Addr\", 23},\n               {\"Off\", Is64 ? 40 : 32},\n               {\"Size\", Is64 ? 47 : 39},\n               {\"ES\", Is64 ? 54 : 46},\n               {\"Lk\", Is64 ? 59 : 51},\n               {\"Inf\", Is64 ? 62 : 54},\n               {\"Al\", Is64 ? 66 : 57}});\n  PrintFields({{\"Flags\", 7}});\n\n  StringRef SecStrTable;\n  if (Expected<StringRef> SecStrTableOrErr =\n          this->Obj.getSectionStringTable(Sections, this->WarningHandler))\n    SecStrTable = *SecStrTableOrErr;\n  else\n    this->reportUniqueWarning(SecStrTableOrErr.takeError());\n\n  size_t SectionIndex = 0;\n  const unsigned AddrSize = Is64 ? 16 : 8;\n  for (const Elf_Shdr &S : Sections) {\n    StringRef Name = \"<?>\";\n    if (Expected<StringRef> NameOrErr =\n            this->Obj.getSectionName(S, SecStrTable))\n      Name = *NameOrErr;\n    else\n      this->reportUniqueWarning(NameOrErr.takeError());\n\n    OS.PadToColumn(2);\n    OS << \"[\" << right_justify(to_string(SectionIndex), 2) << \"]\";\n    PrintFields({{Name, 7}});\n    PrintFields(\n        {{getSectionTypeString(this->Obj.getHeader().e_machine, S.sh_type), 7},\n         {to_string(format_hex_no_prefix(S.sh_addr, AddrSize)), 23},\n         {to_string(format_hex_no_prefix(S.sh_offset, 6)), Is64 ? 39 : 32},\n         {to_string(format_hex_no_prefix(S.sh_size, 6)), Is64 ? 47 : 39},\n         {to_string(format_hex_no_prefix(S.sh_entsize, 2)), Is64 ? 54 : 46},\n         {to_string(S.sh_link), Is64 ? 59 : 51},\n         {to_string(S.sh_info), Is64 ? 63 : 55},\n         {to_string(S.sh_addralign), Is64 ? 66 : 58}});\n\n    OS.PadToColumn(7);\n    OS << \"[\" << to_string(format_hex_no_prefix(S.sh_flags, AddrSize)) << \"]: \";\n\n    DenseMap<unsigned, StringRef> FlagToName = {\n        {SHF_WRITE, \"WRITE\"},           {SHF_ALLOC, \"ALLOC\"},\n        {SHF_EXECINSTR, \"EXEC\"},        {SHF_MERGE, \"MERGE\"},\n        {SHF_STRINGS, \"STRINGS\"},       {SHF_INFO_LINK, \"INFO LINK\"},\n        {SHF_LINK_ORDER, \"LINK ORDER\"}, {SHF_OS_NONCONFORMING, \"OS NONCONF\"},\n        {SHF_GROUP, \"GROUP\"},           {SHF_TLS, \"TLS\"},\n        {SHF_COMPRESSED, \"COMPRESSED\"}, {SHF_EXCLUDE, \"EXCLUDE\"}};\n\n    uint64_t Flags = S.sh_flags;\n    uint64_t UnknownFlags = 0;\n    bool NeedsComma = false;\n    while (Flags) {\n      // Take the least significant bit as a flag.\n      uint64_t Flag = Flags & -Flags;\n      Flags -= Flag;\n\n      auto It = FlagToName.find(Flag);\n      if (It != FlagToName.end()) {\n        if (NeedsComma)\n          OS << \", \";\n        NeedsComma = true;\n        OS << It->second;\n      } else {\n        UnknownFlags |= Flag;\n      }\n    }\n\n    auto PrintUnknownFlags = [&](uint64_t Mask, StringRef Name) {\n      uint64_t FlagsToPrint = UnknownFlags & Mask;\n      if (!FlagsToPrint)\n        return;\n\n      if (NeedsComma)\n        OS << \", \";\n      OS << Name << \" (\"\n         << to_string(format_hex_no_prefix(FlagsToPrint, AddrSize)) << \")\";\n      UnknownFlags &= ~Mask;\n      NeedsComma = true;\n    };\n\n    PrintUnknownFlags(SHF_MASKOS, \"OS\");\n    PrintUnknownFlags(SHF_MASKPROC, \"PROC\");\n    PrintUnknownFlags(uint64_t(-1), \"UNKNOWN\");\n\n    OS << \"\\n\";\n    ++SectionIndex;\n  }\n}\n\nstatic inline std::string printPhdrFlags(unsigned Flag) {\n  std::string Str;\n  Str = (Flag & PF_R) ? \"R\" : \" \";\n  Str += (Flag & PF_W) ? \"W\" : \" \";\n  Str += (Flag & PF_X) ? \"E\" : \" \";\n  return Str;\n}\n\ntemplate <class ELFT>\nstatic bool checkTLSSections(const typename ELFT::Phdr &Phdr,\n                             const typename ELFT::Shdr &Sec) {\n  if (Sec.sh_flags & ELF::SHF_TLS) {\n    // .tbss must only be shown in the PT_TLS segment.\n    if (Sec.sh_type == ELF::SHT_NOBITS)\n      return Phdr.p_type == ELF::PT_TLS;\n\n    // SHF_TLS sections are only shown in PT_TLS, PT_LOAD or PT_GNU_RELRO\n    // segments.\n    return (Phdr.p_type == ELF::PT_TLS) || (Phdr.p_type == ELF::PT_LOAD) ||\n           (Phdr.p_type == ELF::PT_GNU_RELRO);\n  }\n\n  // PT_TLS must only have SHF_TLS sections.\n  return Phdr.p_type != ELF::PT_TLS;\n}\n\ntemplate <class ELFT>\nstatic bool checkOffsets(const typename ELFT::Phdr &Phdr,\n                         const typename ELFT::Shdr &Sec) {\n  // SHT_NOBITS sections don't need to have an offset inside the segment.\n  if (Sec.sh_type == ELF::SHT_NOBITS)\n    return true;\n\n  if (Sec.sh_offset < Phdr.p_offset)\n    return false;\n\n  // Only non-empty sections can be at the end of a segment.\n  if (Sec.sh_size == 0)\n    return (Sec.sh_offset + 1 <= Phdr.p_offset + Phdr.p_filesz);\n  return Sec.sh_offset + Sec.sh_size <= Phdr.p_offset + Phdr.p_filesz;\n}\n\n// Check that an allocatable section belongs to a virtual address\n// space of a segment.\ntemplate <class ELFT>\nstatic bool checkVMA(const typename ELFT::Phdr &Phdr,\n                     const typename ELFT::Shdr &Sec) {\n  if (!(Sec.sh_flags & ELF::SHF_ALLOC))\n    return true;\n\n  if (Sec.sh_addr < Phdr.p_vaddr)\n    return false;\n\n  bool IsTbss =\n      (Sec.sh_type == ELF::SHT_NOBITS) && ((Sec.sh_flags & ELF::SHF_TLS) != 0);\n  // .tbss is special, it only has memory in PT_TLS and has NOBITS properties.\n  bool IsTbssInNonTLS = IsTbss && Phdr.p_type != ELF::PT_TLS;\n  // Only non-empty sections can be at the end of a segment.\n  if (Sec.sh_size == 0 || IsTbssInNonTLS)\n    return Sec.sh_addr + 1 <= Phdr.p_vaddr + Phdr.p_memsz;\n  return Sec.sh_addr + Sec.sh_size <= Phdr.p_vaddr + Phdr.p_memsz;\n}\n\ntemplate <class ELFT>\nstatic bool checkPTDynamic(const typename ELFT::Phdr &Phdr,\n                           const typename ELFT::Shdr &Sec) {\n  if (Phdr.p_type != ELF::PT_DYNAMIC || Phdr.p_memsz == 0 || Sec.sh_size != 0)\n    return true;\n\n  // We get here when we have an empty section. Only non-empty sections can be\n  // at the start or at the end of PT_DYNAMIC.\n  // Is section within the phdr both based on offset and VMA?\n  bool CheckOffset = (Sec.sh_type == ELF::SHT_NOBITS) ||\n                     (Sec.sh_offset > Phdr.p_offset &&\n                      Sec.sh_offset < Phdr.p_offset + Phdr.p_filesz);\n  bool CheckVA = !(Sec.sh_flags & ELF::SHF_ALLOC) ||\n                 (Sec.sh_addr > Phdr.p_vaddr && Sec.sh_addr < Phdr.p_memsz);\n  return CheckOffset && CheckVA;\n}\n\ntemplate <class ELFT>\nvoid GNUELFDumper<ELFT>::printProgramHeaders(\n    bool PrintProgramHeaders, cl::boolOrDefault PrintSectionMapping) {\n  if (PrintProgramHeaders)\n    printProgramHeaders();\n\n  // Display the section mapping along with the program headers, unless\n  // -section-mapping is explicitly set to false.\n  if (PrintSectionMapping != cl::BOU_FALSE)\n    printSectionMapping();\n}\n\ntemplate <class ELFT> void GNUELFDumper<ELFT>::printProgramHeaders() {\n  unsigned Bias = ELFT::Is64Bits ? 8 : 0;\n  const Elf_Ehdr &Header = this->Obj.getHeader();\n  Field Fields[8] = {2,         17,        26,        37 + Bias,\n                     48 + Bias, 56 + Bias, 64 + Bias, 68 + Bias};\n  OS << \"\\nElf file type is \"\n     << printEnum(Header.e_type, makeArrayRef(ElfObjectFileType)) << \"\\n\"\n     << \"Entry point \" << format_hex(Header.e_entry, 3) << \"\\n\"\n     << \"There are \" << Header.e_phnum << \" program headers,\"\n     << \" starting at offset \" << Header.e_phoff << \"\\n\\n\"\n     << \"Program Headers:\\n\";\n  if (ELFT::Is64Bits)\n    OS << \"  Type           Offset   VirtAddr           PhysAddr         \"\n       << \"  FileSiz  MemSiz   Flg Align\\n\";\n  else\n    OS << \"  Type           Offset   VirtAddr   PhysAddr   FileSiz \"\n       << \"MemSiz  Flg Align\\n\";\n\n  unsigned Width = ELFT::Is64Bits ? 18 : 10;\n  unsigned SizeWidth = ELFT::Is64Bits ? 8 : 7;\n\n  Expected<ArrayRef<Elf_Phdr>> PhdrsOrErr = this->Obj.program_headers();\n  if (!PhdrsOrErr) {\n    this->reportUniqueWarning(\"unable to dump program headers: \" +\n                              toString(PhdrsOrErr.takeError()));\n    return;\n  }\n\n  for (const Elf_Phdr &Phdr : *PhdrsOrErr) {\n    Fields[0].Str = getGNUPtType(Header.e_machine, Phdr.p_type);\n    Fields[1].Str = to_string(format_hex(Phdr.p_offset, 8));\n    Fields[2].Str = to_string(format_hex(Phdr.p_vaddr, Width));\n    Fields[3].Str = to_string(format_hex(Phdr.p_paddr, Width));\n    Fields[4].Str = to_string(format_hex(Phdr.p_filesz, SizeWidth));\n    Fields[5].Str = to_string(format_hex(Phdr.p_memsz, SizeWidth));\n    Fields[6].Str = printPhdrFlags(Phdr.p_flags);\n    Fields[7].Str = to_string(format_hex(Phdr.p_align, 1));\n    for (const Field &F : Fields)\n      printField(F);\n    if (Phdr.p_type == ELF::PT_INTERP) {\n      OS << \"\\n\";\n      auto ReportBadInterp = [&](const Twine &Msg) {\n        this->reportUniqueWarning(\n            \"unable to read program interpreter name at offset 0x\" +\n            Twine::utohexstr(Phdr.p_offset) + \": \" + Msg);\n      };\n\n      if (Phdr.p_offset >= this->Obj.getBufSize()) {\n        ReportBadInterp(\"it goes past the end of the file (0x\" +\n                        Twine::utohexstr(this->Obj.getBufSize()) + \")\");\n        continue;\n      }\n\n      const char *Data =\n          reinterpret_cast<const char *>(this->Obj.base()) + Phdr.p_offset;\n      size_t MaxSize = this->Obj.getBufSize() - Phdr.p_offset;\n      size_t Len = strnlen(Data, MaxSize);\n      if (Len == MaxSize) {\n        ReportBadInterp(\"it is not null-terminated\");\n        continue;\n      }\n\n      OS << \"      [Requesting program interpreter: \";\n      OS << StringRef(Data, Len) << \"]\";\n    }\n    OS << \"\\n\";\n  }\n}\n\ntemplate <class ELFT> void GNUELFDumper<ELFT>::printSectionMapping() {\n  OS << \"\\n Section to Segment mapping:\\n  Segment Sections...\\n\";\n  DenseSet<const Elf_Shdr *> BelongsToSegment;\n  int Phnum = 0;\n\n  Expected<ArrayRef<Elf_Phdr>> PhdrsOrErr = this->Obj.program_headers();\n  if (!PhdrsOrErr) {\n    this->reportUniqueWarning(\n        \"can't read program headers to build section to segment mapping: \" +\n        toString(PhdrsOrErr.takeError()));\n    return;\n  }\n\n  for (const Elf_Phdr &Phdr : *PhdrsOrErr) {\n    std::string Sections;\n    OS << format(\"   %2.2d     \", Phnum++);\n    // Check if each section is in a segment and then print mapping.\n    for (const Elf_Shdr &Sec : cantFail(this->Obj.sections())) {\n      if (Sec.sh_type == ELF::SHT_NULL)\n        continue;\n\n      // readelf additionally makes sure it does not print zero sized sections\n      // at end of segments and for PT_DYNAMIC both start and end of section\n      // .tbss must only be shown in PT_TLS section.\n      if (checkTLSSections<ELFT>(Phdr, Sec) && checkOffsets<ELFT>(Phdr, Sec) &&\n          checkVMA<ELFT>(Phdr, Sec) && checkPTDynamic<ELFT>(Phdr, Sec)) {\n        Sections +=\n            unwrapOrError(this->FileName, this->Obj.getSectionName(Sec)).str() +\n            \" \";\n        BelongsToSegment.insert(&Sec);\n      }\n    }\n    OS << Sections << \"\\n\";\n    OS.flush();\n  }\n\n  // Display sections that do not belong to a segment.\n  std::string Sections;\n  for (const Elf_Shdr &Sec : cantFail(this->Obj.sections())) {\n    if (BelongsToSegment.find(&Sec) == BelongsToSegment.end())\n      Sections +=\n          unwrapOrError(this->FileName, this->Obj.getSectionName(Sec)).str() +\n          ' ';\n  }\n  if (!Sections.empty()) {\n    OS << \"   None  \" << Sections << '\\n';\n    OS.flush();\n  }\n}\n\nnamespace {\n\ntemplate <class ELFT>\nRelSymbol<ELFT> getSymbolForReloc(const ELFDumper<ELFT> &Dumper,\n                                  const Relocation<ELFT> &Reloc) {\n  using Elf_Sym = typename ELFT::Sym;\n  auto WarnAndReturn = [&](const Elf_Sym *Sym,\n                           const Twine &Reason) -> RelSymbol<ELFT> {\n    Dumper.reportUniqueWarning(\n        \"unable to get name of the dynamic symbol with index \" +\n        Twine(Reloc.Symbol) + \": \" + Reason);\n    return {Sym, \"<corrupt>\"};\n  };\n\n  ArrayRef<Elf_Sym> Symbols = Dumper.dynamic_symbols();\n  const Elf_Sym *FirstSym = Symbols.begin();\n  if (!FirstSym)\n    return WarnAndReturn(nullptr, \"no dynamic symbol table found\");\n\n  // We might have an object without a section header. In this case the size of\n  // Symbols is zero, because there is no way to know the size of the dynamic\n  // table. We should allow this case and not print a warning.\n  if (!Symbols.empty() && Reloc.Symbol >= Symbols.size())\n    return WarnAndReturn(\n        nullptr,\n        \"index is greater than or equal to the number of dynamic symbols (\" +\n            Twine(Symbols.size()) + \")\");\n\n  const ELFFile<ELFT> &Obj = Dumper.getElfObject().getELFFile();\n  const uint64_t FileSize = Obj.getBufSize();\n  const uint64_t SymOffset = ((const uint8_t *)FirstSym - Obj.base()) +\n                             (uint64_t)Reloc.Symbol * sizeof(Elf_Sym);\n  if (SymOffset + sizeof(Elf_Sym) > FileSize)\n    return WarnAndReturn(nullptr, \"symbol at 0x\" + Twine::utohexstr(SymOffset) +\n                                      \" goes past the end of the file (0x\" +\n                                      Twine::utohexstr(FileSize) + \")\");\n\n  const Elf_Sym *Sym = FirstSym + Reloc.Symbol;\n  Expected<StringRef> ErrOrName = Sym->getName(Dumper.getDynamicStringTable());\n  if (!ErrOrName)\n    return WarnAndReturn(Sym, toString(ErrOrName.takeError()));\n\n  return {Sym == FirstSym ? nullptr : Sym, maybeDemangle(*ErrOrName)};\n}\n} // namespace\n\ntemplate <class ELFT>\nstatic size_t getMaxDynamicTagSize(const ELFFile<ELFT> &Obj,\n                                   typename ELFT::DynRange Tags) {\n  size_t Max = 0;\n  for (const typename ELFT::Dyn &Dyn : Tags)\n    Max = std::max(Max, Obj.getDynamicTagAsString(Dyn.d_tag).size());\n  return Max;\n}\n\ntemplate <class ELFT> void GNUELFDumper<ELFT>::printDynamicTable() {\n  Elf_Dyn_Range Table = this->dynamic_table();\n  if (Table.empty())\n    return;\n\n  OS << \"Dynamic section at offset \"\n     << format_hex(reinterpret_cast<const uint8_t *>(this->DynamicTable.Addr) -\n                       this->Obj.base(),\n                   1)\n     << \" contains \" << Table.size() << \" entries:\\n\";\n\n  // The type name is surrounded with round brackets, hence add 2.\n  size_t MaxTagSize = getMaxDynamicTagSize(this->Obj, Table) + 2;\n  // The \"Name/Value\" column should be indented from the \"Type\" column by N\n  // spaces, where N = MaxTagSize - length of \"Type\" (4) + trailing\n  // space (1) = 3.\n  OS << \"  Tag\" + std::string(ELFT::Is64Bits ? 16 : 8, ' ') + \"Type\"\n     << std::string(MaxTagSize - 3, ' ') << \"Name/Value\\n\";\n\n  std::string ValueFmt = \" %-\" + std::to_string(MaxTagSize) + \"s \";\n  for (auto Entry : Table) {\n    uintX_t Tag = Entry.getTag();\n    std::string Type =\n        std::string(\"(\") + this->Obj.getDynamicTagAsString(Tag).c_str() + \")\";\n    std::string Value = this->getDynamicEntry(Tag, Entry.getVal());\n    OS << \"  \" << format_hex(Tag, ELFT::Is64Bits ? 18 : 10)\n       << format(ValueFmt.c_str(), Type.c_str()) << Value << \"\\n\";\n  }\n}\n\ntemplate <class ELFT> void GNUELFDumper<ELFT>::printDynamicRelocations() {\n  this->printDynamicRelocationsHelper();\n}\n\ntemplate <class ELFT>\nvoid ELFDumper<ELFT>::printDynamicReloc(const Relocation<ELFT> &R) {\n  printRelRelaReloc(R, getSymbolForReloc(*this, R));\n}\n\ntemplate <class ELFT>\nvoid ELFDumper<ELFT>::printRelocationsHelper(const Elf_Shdr &Sec) {\n  this->forEachRelocationDo(\n      Sec, opts::RawRelr,\n      [&](const Relocation<ELFT> &R, unsigned Ndx, const Elf_Shdr &Sec,\n          const Elf_Shdr *SymTab) { printReloc(R, Ndx, Sec, SymTab); },\n      [&](const Elf_Relr &R) { printRelrReloc(R); });\n}\n\ntemplate <class ELFT> void ELFDumper<ELFT>::printDynamicRelocationsHelper() {\n  const bool IsMips64EL = this->Obj.isMips64EL();\n  if (this->DynRelaRegion.Size > 0) {\n    printDynamicRelocHeader(ELF::SHT_RELA, \"RELA\", this->DynRelaRegion);\n    for (const Elf_Rela &Rela :\n         this->DynRelaRegion.template getAsArrayRef<Elf_Rela>())\n      printDynamicReloc(Relocation<ELFT>(Rela, IsMips64EL));\n  }\n\n  if (this->DynRelRegion.Size > 0) {\n    printDynamicRelocHeader(ELF::SHT_REL, \"REL\", this->DynRelRegion);\n    for (const Elf_Rel &Rel :\n         this->DynRelRegion.template getAsArrayRef<Elf_Rel>())\n      printDynamicReloc(Relocation<ELFT>(Rel, IsMips64EL));\n  }\n\n  if (this->DynRelrRegion.Size > 0) {\n    printDynamicRelocHeader(ELF::SHT_REL, \"RELR\", this->DynRelrRegion);\n    Elf_Relr_Range Relrs =\n        this->DynRelrRegion.template getAsArrayRef<Elf_Relr>();\n    for (const Elf_Rel &Rel : Obj.decode_relrs(Relrs))\n      printDynamicReloc(Relocation<ELFT>(Rel, IsMips64EL));\n  }\n\n  if (this->DynPLTRelRegion.Size) {\n    if (this->DynPLTRelRegion.EntSize == sizeof(Elf_Rela)) {\n      printDynamicRelocHeader(ELF::SHT_RELA, \"PLT\", this->DynPLTRelRegion);\n      for (const Elf_Rela &Rela :\n           this->DynPLTRelRegion.template getAsArrayRef<Elf_Rela>())\n        printDynamicReloc(Relocation<ELFT>(Rela, IsMips64EL));\n    } else {\n      printDynamicRelocHeader(ELF::SHT_REL, \"PLT\", this->DynPLTRelRegion);\n      for (const Elf_Rel &Rel :\n           this->DynPLTRelRegion.template getAsArrayRef<Elf_Rel>())\n        printDynamicReloc(Relocation<ELFT>(Rel, IsMips64EL));\n    }\n  }\n}\n\ntemplate <class ELFT>\nvoid GNUELFDumper<ELFT>::printGNUVersionSectionProlog(\n    const typename ELFT::Shdr &Sec, const Twine &Label, unsigned EntriesNum) {\n  // Don't inline the SecName, because it might report a warning to stderr and\n  // corrupt the output.\n  StringRef SecName = this->getPrintableSectionName(Sec);\n  OS << Label << \" section '\" << SecName << \"' \"\n     << \"contains \" << EntriesNum << \" entries:\\n\";\n\n  StringRef LinkedSecName = \"<corrupt>\";\n  if (Expected<const typename ELFT::Shdr *> LinkedSecOrErr =\n          this->Obj.getSection(Sec.sh_link))\n    LinkedSecName = this->getPrintableSectionName(**LinkedSecOrErr);\n  else\n    this->reportUniqueWarning(\"invalid section linked to \" +\n                              this->describe(Sec) + \": \" +\n                              toString(LinkedSecOrErr.takeError()));\n\n  OS << \" Addr: \" << format_hex_no_prefix(Sec.sh_addr, 16)\n     << \"  Offset: \" << format_hex(Sec.sh_offset, 8)\n     << \"  Link: \" << Sec.sh_link << \" (\" << LinkedSecName << \")\\n\";\n}\n\ntemplate <class ELFT>\nvoid GNUELFDumper<ELFT>::printVersionSymbolSection(const Elf_Shdr *Sec) {\n  if (!Sec)\n    return;\n\n  printGNUVersionSectionProlog(*Sec, \"Version symbols\",\n                               Sec->sh_size / sizeof(Elf_Versym));\n  Expected<ArrayRef<Elf_Versym>> VerTableOrErr =\n      this->getVersionTable(*Sec, /*SymTab=*/nullptr,\n                            /*StrTab=*/nullptr, /*SymTabSec=*/nullptr);\n  if (!VerTableOrErr) {\n    this->reportUniqueWarning(VerTableOrErr.takeError());\n    return;\n  }\n\n  SmallVector<Optional<VersionEntry>, 0> *VersionMap = nullptr;\n  if (Expected<SmallVector<Optional<VersionEntry>, 0> *> MapOrErr =\n          this->getVersionMap())\n    VersionMap = *MapOrErr;\n  else\n    this->reportUniqueWarning(MapOrErr.takeError());\n\n  ArrayRef<Elf_Versym> VerTable = *VerTableOrErr;\n  std::vector<StringRef> Versions;\n  for (size_t I = 0, E = VerTable.size(); I < E; ++I) {\n    unsigned Ndx = VerTable[I].vs_index;\n    if (Ndx == VER_NDX_LOCAL || Ndx == VER_NDX_GLOBAL) {\n      Versions.emplace_back(Ndx == VER_NDX_LOCAL ? \"*local*\" : \"*global*\");\n      continue;\n    }\n\n    if (!VersionMap) {\n      Versions.emplace_back(\"<corrupt>\");\n      continue;\n    }\n\n    bool IsDefault;\n    Expected<StringRef> NameOrErr = this->Obj.getSymbolVersionByIndex(\n        Ndx, IsDefault, *VersionMap, /*IsSymHidden=*/None);\n    if (!NameOrErr) {\n      this->reportUniqueWarning(\"unable to get a version for entry \" +\n                                Twine(I) + \" of \" + this->describe(*Sec) +\n                                \": \" + toString(NameOrErr.takeError()));\n      Versions.emplace_back(\"<corrupt>\");\n      continue;\n    }\n    Versions.emplace_back(*NameOrErr);\n  }\n\n  // readelf prints 4 entries per line.\n  uint64_t Entries = VerTable.size();\n  for (uint64_t VersymRow = 0; VersymRow < Entries; VersymRow += 4) {\n    OS << \"  \" << format_hex_no_prefix(VersymRow, 3) << \":\";\n    for (uint64_t I = 0; (I < 4) && (I + VersymRow) < Entries; ++I) {\n      unsigned Ndx = VerTable[VersymRow + I].vs_index;\n      OS << format(\"%4x%c\", Ndx & VERSYM_VERSION,\n                   Ndx & VERSYM_HIDDEN ? 'h' : ' ');\n      OS << left_justify(\"(\" + std::string(Versions[VersymRow + I]) + \")\", 13);\n    }\n    OS << '\\n';\n  }\n  OS << '\\n';\n}\n\nstatic std::string versionFlagToString(unsigned Flags) {\n  if (Flags == 0)\n    return \"none\";\n\n  std::string Ret;\n  auto AddFlag = [&Ret, &Flags](unsigned Flag, StringRef Name) {\n    if (!(Flags & Flag))\n      return;\n    if (!Ret.empty())\n      Ret += \" | \";\n    Ret += Name;\n    Flags &= ~Flag;\n  };\n\n  AddFlag(VER_FLG_BASE, \"BASE\");\n  AddFlag(VER_FLG_WEAK, \"WEAK\");\n  AddFlag(VER_FLG_INFO, \"INFO\");\n  AddFlag(~0, \"<unknown>\");\n  return Ret;\n}\n\ntemplate <class ELFT>\nvoid GNUELFDumper<ELFT>::printVersionDefinitionSection(const Elf_Shdr *Sec) {\n  if (!Sec)\n    return;\n\n  printGNUVersionSectionProlog(*Sec, \"Version definition\", Sec->sh_info);\n\n  Expected<std::vector<VerDef>> V = this->Obj.getVersionDefinitions(*Sec);\n  if (!V) {\n    this->reportUniqueWarning(V.takeError());\n    return;\n  }\n\n  for (const VerDef &Def : *V) {\n    OS << format(\"  0x%04x: Rev: %u  Flags: %s  Index: %u  Cnt: %u  Name: %s\\n\",\n                 Def.Offset, Def.Version,\n                 versionFlagToString(Def.Flags).c_str(), Def.Ndx, Def.Cnt,\n                 Def.Name.data());\n    unsigned I = 0;\n    for (const VerdAux &Aux : Def.AuxV)\n      OS << format(\"  0x%04x: Parent %u: %s\\n\", Aux.Offset, ++I,\n                   Aux.Name.data());\n  }\n\n  OS << '\\n';\n}\n\ntemplate <class ELFT>\nvoid GNUELFDumper<ELFT>::printVersionDependencySection(const Elf_Shdr *Sec) {\n  if (!Sec)\n    return;\n\n  unsigned VerneedNum = Sec->sh_info;\n  printGNUVersionSectionProlog(*Sec, \"Version needs\", VerneedNum);\n\n  Expected<std::vector<VerNeed>> V =\n      this->Obj.getVersionDependencies(*Sec, this->WarningHandler);\n  if (!V) {\n    this->reportUniqueWarning(V.takeError());\n    return;\n  }\n\n  for (const VerNeed &VN : *V) {\n    OS << format(\"  0x%04x: Version: %u  File: %s  Cnt: %u\\n\", VN.Offset,\n                 VN.Version, VN.File.data(), VN.Cnt);\n    for (const VernAux &Aux : VN.AuxV)\n      OS << format(\"  0x%04x:   Name: %s  Flags: %s  Version: %u\\n\", Aux.Offset,\n                   Aux.Name.data(), versionFlagToString(Aux.Flags).c_str(),\n                   Aux.Other);\n  }\n  OS << '\\n';\n}\n\ntemplate <class ELFT>\nvoid GNUELFDumper<ELFT>::printHashHistogram(const Elf_Hash &HashTable) {\n  size_t NBucket = HashTable.nbucket;\n  size_t NChain = HashTable.nchain;\n  ArrayRef<Elf_Word> Buckets = HashTable.buckets();\n  ArrayRef<Elf_Word> Chains = HashTable.chains();\n  size_t TotalSyms = 0;\n  // If hash table is correct, we have at least chains with 0 length\n  size_t MaxChain = 1;\n  size_t CumulativeNonZero = 0;\n\n  if (NChain == 0 || NBucket == 0)\n    return;\n\n  std::vector<size_t> ChainLen(NBucket, 0);\n  // Go over all buckets and and note chain lengths of each bucket (total\n  // unique chain lengths).\n  for (size_t B = 0; B < NBucket; B++) {\n    std::vector<bool> Visited(NChain);\n    for (size_t C = Buckets[B]; C < NChain; C = Chains[C]) {\n      if (C == ELF::STN_UNDEF)\n        break;\n      if (Visited[C]) {\n        this->reportUniqueWarning(\".hash section is invalid: bucket \" +\n                                  Twine(C) +\n                                  \": a cycle was detected in the linked chain\");\n        break;\n      }\n      Visited[C] = true;\n      if (MaxChain <= ++ChainLen[B])\n        MaxChain++;\n    }\n    TotalSyms += ChainLen[B];\n  }\n\n  if (!TotalSyms)\n    return;\n\n  std::vector<size_t> Count(MaxChain, 0);\n  // Count how long is the chain for each bucket\n  for (size_t B = 0; B < NBucket; B++)\n    ++Count[ChainLen[B]];\n  // Print Number of buckets with each chain lengths and their cumulative\n  // coverage of the symbols\n  OS << \"Histogram for bucket list length (total of \" << NBucket\n     << \" buckets)\\n\"\n     << \" Length  Number     % of total  Coverage\\n\";\n  for (size_t I = 0; I < MaxChain; I++) {\n    CumulativeNonZero += Count[I] * I;\n    OS << format(\"%7lu  %-10lu (%5.1f%%)     %5.1f%%\\n\", I, Count[I],\n                 (Count[I] * 100.0) / NBucket,\n                 (CumulativeNonZero * 100.0) / TotalSyms);\n  }\n}\n\ntemplate <class ELFT>\nvoid GNUELFDumper<ELFT>::printGnuHashHistogram(\n    const Elf_GnuHash &GnuHashTable) {\n  Expected<ArrayRef<Elf_Word>> ChainsOrErr =\n      getGnuHashTableChains<ELFT>(this->DynSymRegion, &GnuHashTable);\n  if (!ChainsOrErr) {\n    this->reportUniqueWarning(\"unable to print the GNU hash table histogram: \" +\n                              toString(ChainsOrErr.takeError()));\n    return;\n  }\n\n  ArrayRef<Elf_Word> Chains = *ChainsOrErr;\n  size_t Symndx = GnuHashTable.symndx;\n  size_t TotalSyms = 0;\n  size_t MaxChain = 1;\n  size_t CumulativeNonZero = 0;\n\n  size_t NBucket = GnuHashTable.nbuckets;\n  if (Chains.empty() || NBucket == 0)\n    return;\n\n  ArrayRef<Elf_Word> Buckets = GnuHashTable.buckets();\n  std::vector<size_t> ChainLen(NBucket, 0);\n  for (size_t B = 0; B < NBucket; B++) {\n    if (!Buckets[B])\n      continue;\n    size_t Len = 1;\n    for (size_t C = Buckets[B] - Symndx;\n         C < Chains.size() && (Chains[C] & 1) == 0; C++)\n      if (MaxChain < ++Len)\n        MaxChain++;\n    ChainLen[B] = Len;\n    TotalSyms += Len;\n  }\n  MaxChain++;\n\n  if (!TotalSyms)\n    return;\n\n  std::vector<size_t> Count(MaxChain, 0);\n  for (size_t B = 0; B < NBucket; B++)\n    ++Count[ChainLen[B]];\n  // Print Number of buckets with each chain lengths and their cumulative\n  // coverage of the symbols\n  OS << \"Histogram for `.gnu.hash' bucket list length (total of \" << NBucket\n     << \" buckets)\\n\"\n     << \" Length  Number     % of total  Coverage\\n\";\n  for (size_t I = 0; I < MaxChain; I++) {\n    CumulativeNonZero += Count[I] * I;\n    OS << format(\"%7lu  %-10lu (%5.1f%%)     %5.1f%%\\n\", I, Count[I],\n                 (Count[I] * 100.0) / NBucket,\n                 (CumulativeNonZero * 100.0) / TotalSyms);\n  }\n}\n\n// Hash histogram shows statistics of how efficient the hash was for the\n// dynamic symbol table. The table shows the number of hash buckets for\n// different lengths of chains as an absolute number and percentage of the total\n// buckets, and the cumulative coverage of symbols for each set of buckets.\ntemplate <class ELFT> void GNUELFDumper<ELFT>::printHashHistograms() {\n  // Print histogram for the .hash section.\n  if (this->HashTable) {\n    if (Error E = checkHashTable<ELFT>(*this, this->HashTable))\n      this->reportUniqueWarning(std::move(E));\n    else\n      printHashHistogram(*this->HashTable);\n  }\n\n  // Print histogram for the .gnu.hash section.\n  if (this->GnuHashTable) {\n    if (Error E = checkGNUHashTable<ELFT>(this->Obj, this->GnuHashTable))\n      this->reportUniqueWarning(std::move(E));\n    else\n      printGnuHashHistogram(*this->GnuHashTable);\n  }\n}\n\ntemplate <class ELFT> void GNUELFDumper<ELFT>::printCGProfile() {\n  OS << \"GNUStyle::printCGProfile not implemented\\n\";\n}\n\nstatic Expected<std::vector<uint64_t>> toULEB128Array(ArrayRef<uint8_t> Data) {\n  std::vector<uint64_t> Ret;\n  const uint8_t *Cur = Data.begin();\n  const uint8_t *End = Data.end();\n  while (Cur != End) {\n    unsigned Size;\n    const char *Err;\n    Ret.push_back(decodeULEB128(Cur, &Size, End, &Err));\n    if (Err)\n      return createError(Err);\n    Cur += Size;\n  }\n  return Ret;\n}\n\ntemplate <class ELFT>\nstatic Expected<std::vector<uint64_t>>\ndecodeAddrsigSection(const ELFFile<ELFT> &Obj, const typename ELFT::Shdr &Sec) {\n  Expected<ArrayRef<uint8_t>> ContentsOrErr = Obj.getSectionContents(Sec);\n  if (!ContentsOrErr)\n    return ContentsOrErr.takeError();\n\n  if (Expected<std::vector<uint64_t>> SymsOrErr =\n          toULEB128Array(*ContentsOrErr))\n    return *SymsOrErr;\n  else\n    return createError(\"unable to decode \" + describe(Obj, Sec) + \": \" +\n                       toString(SymsOrErr.takeError()));\n}\n\ntemplate <class ELFT> void GNUELFDumper<ELFT>::printAddrsig() {\n  if (!this->DotAddrsigSec)\n    return;\n\n  Expected<std::vector<uint64_t>> SymsOrErr =\n      decodeAddrsigSection(this->Obj, *this->DotAddrsigSec);\n  if (!SymsOrErr) {\n    this->reportUniqueWarning(SymsOrErr.takeError());\n    return;\n  }\n\n  StringRef Name = this->getPrintableSectionName(*this->DotAddrsigSec);\n  OS << \"\\nAddress-significant symbols section '\" << Name << \"'\"\n     << \" contains \" << SymsOrErr->size() << \" entries:\\n\";\n  OS << \"   Num: Name\\n\";\n\n  Field Fields[2] = {0, 8};\n  size_t SymIndex = 0;\n  for (uint64_t Sym : *SymsOrErr) {\n    Fields[0].Str = to_string(format_decimal(++SymIndex, 6)) + \":\";\n    Fields[1].Str = this->getStaticSymbolName(Sym);\n    for (const Field &Entry : Fields)\n      printField(Entry);\n    OS << \"\\n\";\n  }\n}\n\ntemplate <typename ELFT>\nstatic std::string getGNUProperty(uint32_t Type, uint32_t DataSize,\n                                  ArrayRef<uint8_t> Data) {\n  std::string str;\n  raw_string_ostream OS(str);\n  uint32_t PrData;\n  auto DumpBit = [&](uint32_t Flag, StringRef Name) {\n    if (PrData & Flag) {\n      PrData &= ~Flag;\n      OS << Name;\n      if (PrData)\n        OS << \", \";\n    }\n  };\n\n  switch (Type) {\n  default:\n    OS << format(\"<application-specific type 0x%x>\", Type);\n    return OS.str();\n  case GNU_PROPERTY_STACK_SIZE: {\n    OS << \"stack size: \";\n    if (DataSize == sizeof(typename ELFT::uint))\n      OS << formatv(\"{0:x}\",\n                    (uint64_t)(*(const typename ELFT::Addr *)Data.data()));\n    else\n      OS << format(\"<corrupt length: 0x%x>\", DataSize);\n    return OS.str();\n  }\n  case GNU_PROPERTY_NO_COPY_ON_PROTECTED:\n    OS << \"no copy on protected\";\n    if (DataSize)\n      OS << format(\" <corrupt length: 0x%x>\", DataSize);\n    return OS.str();\n  case GNU_PROPERTY_AARCH64_FEATURE_1_AND:\n  case GNU_PROPERTY_X86_FEATURE_1_AND:\n    OS << ((Type == GNU_PROPERTY_AARCH64_FEATURE_1_AND) ? \"aarch64 feature: \"\n                                                        : \"x86 feature: \");\n    if (DataSize != 4) {\n      OS << format(\"<corrupt length: 0x%x>\", DataSize);\n      return OS.str();\n    }\n    PrData = support::endian::read32<ELFT::TargetEndianness>(Data.data());\n    if (PrData == 0) {\n      OS << \"<None>\";\n      return OS.str();\n    }\n    if (Type == GNU_PROPERTY_AARCH64_FEATURE_1_AND) {\n      DumpBit(GNU_PROPERTY_AARCH64_FEATURE_1_BTI, \"BTI\");\n      DumpBit(GNU_PROPERTY_AARCH64_FEATURE_1_PAC, \"PAC\");\n    } else {\n      DumpBit(GNU_PROPERTY_X86_FEATURE_1_IBT, \"IBT\");\n      DumpBit(GNU_PROPERTY_X86_FEATURE_1_SHSTK, \"SHSTK\");\n    }\n    if (PrData)\n      OS << format(\"<unknown flags: 0x%x>\", PrData);\n    return OS.str();\n  case GNU_PROPERTY_X86_ISA_1_NEEDED:\n  case GNU_PROPERTY_X86_ISA_1_USED:\n    OS << \"x86 ISA \"\n       << (Type == GNU_PROPERTY_X86_ISA_1_NEEDED ? \"needed: \" : \"used: \");\n    if (DataSize != 4) {\n      OS << format(\"<corrupt length: 0x%x>\", DataSize);\n      return OS.str();\n    }\n    PrData = support::endian::read32<ELFT::TargetEndianness>(Data.data());\n    if (PrData == 0) {\n      OS << \"<None>\";\n      return OS.str();\n    }\n    DumpBit(GNU_PROPERTY_X86_ISA_1_CMOV, \"CMOV\");\n    DumpBit(GNU_PROPERTY_X86_ISA_1_SSE, \"SSE\");\n    DumpBit(GNU_PROPERTY_X86_ISA_1_SSE2, \"SSE2\");\n    DumpBit(GNU_PROPERTY_X86_ISA_1_SSE3, \"SSE3\");\n    DumpBit(GNU_PROPERTY_X86_ISA_1_SSSE3, \"SSSE3\");\n    DumpBit(GNU_PROPERTY_X86_ISA_1_SSE4_1, \"SSE4_1\");\n    DumpBit(GNU_PROPERTY_X86_ISA_1_SSE4_2, \"SSE4_2\");\n    DumpBit(GNU_PROPERTY_X86_ISA_1_AVX, \"AVX\");\n    DumpBit(GNU_PROPERTY_X86_ISA_1_AVX2, \"AVX2\");\n    DumpBit(GNU_PROPERTY_X86_ISA_1_FMA, \"FMA\");\n    DumpBit(GNU_PROPERTY_X86_ISA_1_AVX512F, \"AVX512F\");\n    DumpBit(GNU_PROPERTY_X86_ISA_1_AVX512CD, \"AVX512CD\");\n    DumpBit(GNU_PROPERTY_X86_ISA_1_AVX512ER, \"AVX512ER\");\n    DumpBit(GNU_PROPERTY_X86_ISA_1_AVX512PF, \"AVX512PF\");\n    DumpBit(GNU_PROPERTY_X86_ISA_1_AVX512VL, \"AVX512VL\");\n    DumpBit(GNU_PROPERTY_X86_ISA_1_AVX512DQ, \"AVX512DQ\");\n    DumpBit(GNU_PROPERTY_X86_ISA_1_AVX512BW, \"AVX512BW\");\n    DumpBit(GNU_PROPERTY_X86_ISA_1_AVX512_4FMAPS, \"AVX512_4FMAPS\");\n    DumpBit(GNU_PROPERTY_X86_ISA_1_AVX512_4VNNIW, \"AVX512_4VNNIW\");\n    DumpBit(GNU_PROPERTY_X86_ISA_1_AVX512_BITALG, \"AVX512_BITALG\");\n    DumpBit(GNU_PROPERTY_X86_ISA_1_AVX512_IFMA, \"AVX512_IFMA\");\n    DumpBit(GNU_PROPERTY_X86_ISA_1_AVX512_VBMI, \"AVX512_VBMI\");\n    DumpBit(GNU_PROPERTY_X86_ISA_1_AVX512_VBMI2, \"AVX512_VBMI2\");\n    DumpBit(GNU_PROPERTY_X86_ISA_1_AVX512_VNNI, \"AVX512_VNNI\");\n    if (PrData)\n      OS << format(\"<unknown flags: 0x%x>\", PrData);\n    return OS.str();\n    break;\n  case GNU_PROPERTY_X86_FEATURE_2_NEEDED:\n  case GNU_PROPERTY_X86_FEATURE_2_USED:\n    OS << \"x86 feature \"\n       << (Type == GNU_PROPERTY_X86_FEATURE_2_NEEDED ? \"needed: \" : \"used: \");\n    if (DataSize != 4) {\n      OS << format(\"<corrupt length: 0x%x>\", DataSize);\n      return OS.str();\n    }\n    PrData = support::endian::read32<ELFT::TargetEndianness>(Data.data());\n    if (PrData == 0) {\n      OS << \"<None>\";\n      return OS.str();\n    }\n    DumpBit(GNU_PROPERTY_X86_FEATURE_2_X86, \"x86\");\n    DumpBit(GNU_PROPERTY_X86_FEATURE_2_X87, \"x87\");\n    DumpBit(GNU_PROPERTY_X86_FEATURE_2_MMX, \"MMX\");\n    DumpBit(GNU_PROPERTY_X86_FEATURE_2_XMM, \"XMM\");\n    DumpBit(GNU_PROPERTY_X86_FEATURE_2_YMM, \"YMM\");\n    DumpBit(GNU_PROPERTY_X86_FEATURE_2_ZMM, \"ZMM\");\n    DumpBit(GNU_PROPERTY_X86_FEATURE_2_FXSR, \"FXSR\");\n    DumpBit(GNU_PROPERTY_X86_FEATURE_2_XSAVE, \"XSAVE\");\n    DumpBit(GNU_PROPERTY_X86_FEATURE_2_XSAVEOPT, \"XSAVEOPT\");\n    DumpBit(GNU_PROPERTY_X86_FEATURE_2_XSAVEC, \"XSAVEC\");\n    if (PrData)\n      OS << format(\"<unknown flags: 0x%x>\", PrData);\n    return OS.str();\n  }\n}\n\ntemplate <typename ELFT>\nstatic SmallVector<std::string, 4> getGNUPropertyList(ArrayRef<uint8_t> Arr) {\n  using Elf_Word = typename ELFT::Word;\n\n  SmallVector<std::string, 4> Properties;\n  while (Arr.size() >= 8) {\n    uint32_t Type = *reinterpret_cast<const Elf_Word *>(Arr.data());\n    uint32_t DataSize = *reinterpret_cast<const Elf_Word *>(Arr.data() + 4);\n    Arr = Arr.drop_front(8);\n\n    // Take padding size into account if present.\n    uint64_t PaddedSize = alignTo(DataSize, sizeof(typename ELFT::uint));\n    std::string str;\n    raw_string_ostream OS(str);\n    if (Arr.size() < PaddedSize) {\n      OS << format(\"<corrupt type (0x%x) datasz: 0x%x>\", Type, DataSize);\n      Properties.push_back(OS.str());\n      break;\n    }\n    Properties.push_back(\n        getGNUProperty<ELFT>(Type, DataSize, Arr.take_front(PaddedSize)));\n    Arr = Arr.drop_front(PaddedSize);\n  }\n\n  if (!Arr.empty())\n    Properties.push_back(\"<corrupted GNU_PROPERTY_TYPE_0>\");\n\n  return Properties;\n}\n\nstruct GNUAbiTag {\n  std::string OSName;\n  std::string ABI;\n  bool IsValid;\n};\n\ntemplate <typename ELFT> static GNUAbiTag getGNUAbiTag(ArrayRef<uint8_t> Desc) {\n  typedef typename ELFT::Word Elf_Word;\n\n  ArrayRef<Elf_Word> Words(reinterpret_cast<const Elf_Word *>(Desc.begin()),\n                           reinterpret_cast<const Elf_Word *>(Desc.end()));\n\n  if (Words.size() < 4)\n    return {\"\", \"\", /*IsValid=*/false};\n\n  static const char *OSNames[] = {\n      \"Linux\", \"Hurd\", \"Solaris\", \"FreeBSD\", \"NetBSD\", \"Syllable\", \"NaCl\",\n  };\n  StringRef OSName = \"Unknown\";\n  if (Words[0] < array_lengthof(OSNames))\n    OSName = OSNames[Words[0]];\n  uint32_t Major = Words[1], Minor = Words[2], Patch = Words[3];\n  std::string str;\n  raw_string_ostream ABI(str);\n  ABI << Major << \".\" << Minor << \".\" << Patch;\n  return {std::string(OSName), ABI.str(), /*IsValid=*/true};\n}\n\nstatic std::string getGNUBuildId(ArrayRef<uint8_t> Desc) {\n  std::string str;\n  raw_string_ostream OS(str);\n  for (uint8_t B : Desc)\n    OS << format_hex_no_prefix(B, 2);\n  return OS.str();\n}\n\nstatic StringRef getGNUGoldVersion(ArrayRef<uint8_t> Desc) {\n  return StringRef(reinterpret_cast<const char *>(Desc.data()), Desc.size());\n}\n\ntemplate <typename ELFT>\nstatic bool printGNUNote(raw_ostream &OS, uint32_t NoteType,\n                         ArrayRef<uint8_t> Desc) {\n  // Return true if we were able to pretty-print the note, false otherwise.\n  switch (NoteType) {\n  default:\n    return false;\n  case ELF::NT_GNU_ABI_TAG: {\n    const GNUAbiTag &AbiTag = getGNUAbiTag<ELFT>(Desc);\n    if (!AbiTag.IsValid)\n      OS << \"    <corrupt GNU_ABI_TAG>\";\n    else\n      OS << \"    OS: \" << AbiTag.OSName << \", ABI: \" << AbiTag.ABI;\n    break;\n  }\n  case ELF::NT_GNU_BUILD_ID: {\n    OS << \"    Build ID: \" << getGNUBuildId(Desc);\n    break;\n  }\n  case ELF::NT_GNU_GOLD_VERSION:\n    OS << \"    Version: \" << getGNUGoldVersion(Desc);\n    break;\n  case ELF::NT_GNU_PROPERTY_TYPE_0:\n    OS << \"    Properties:\";\n    for (const std::string &Property : getGNUPropertyList<ELFT>(Desc))\n      OS << \"    \" << Property << \"\\n\";\n    break;\n  }\n  OS << '\\n';\n  return true;\n}\n\nstatic const EnumEntry<unsigned> FreeBSDFeatureCtlFlags[] = {\n    {\"ASLR_DISABLE\", NT_FREEBSD_FCTL_ASLR_DISABLE},\n    {\"PROTMAX_DISABLE\", NT_FREEBSD_FCTL_PROTMAX_DISABLE},\n    {\"STKGAP_DISABLE\", NT_FREEBSD_FCTL_STKGAP_DISABLE},\n    {\"WXNEEDED\", NT_FREEBSD_FCTL_WXNEEDED},\n    {\"LA48\", NT_FREEBSD_FCTL_LA48},\n    {\"ASG_DISABLE\", NT_FREEBSD_FCTL_ASG_DISABLE},\n};\n\nstruct FreeBSDNote {\n  std::string Type;\n  std::string Value;\n};\n\ntemplate <typename ELFT>\nstatic Optional<FreeBSDNote>\ngetFreeBSDNote(uint32_t NoteType, ArrayRef<uint8_t> Desc, bool IsCore) {\n  if (IsCore)\n    return None; // No pretty-printing yet.\n  switch (NoteType) {\n  case ELF::NT_FREEBSD_ABI_TAG:\n    if (Desc.size() != 4)\n      return None;\n    return FreeBSDNote{\n        \"ABI tag\",\n        utostr(support::endian::read32<ELFT::TargetEndianness>(Desc.data()))};\n  case ELF::NT_FREEBSD_ARCH_TAG:\n    return FreeBSDNote{\"Arch tag\", toStringRef(Desc).str()};\n  case ELF::NT_FREEBSD_FEATURE_CTL: {\n    if (Desc.size() != 4)\n      return None;\n    unsigned Value =\n        support::endian::read32<ELFT::TargetEndianness>(Desc.data());\n    std::string FlagsStr;\n    raw_string_ostream OS(FlagsStr);\n    printFlags(Value, makeArrayRef(FreeBSDFeatureCtlFlags), OS);\n    if (OS.str().empty())\n      OS << \"0x\" << utohexstr(Value);\n    else\n      OS << \"(0x\" << utohexstr(Value) << \")\";\n    return FreeBSDNote{\"Feature flags\", OS.str()};\n  }\n  default:\n    return None;\n  }\n}\n\nstruct AMDNote {\n  std::string Type;\n  std::string Value;\n};\n\ntemplate <typename ELFT>\nstatic AMDNote getAMDNote(uint32_t NoteType, ArrayRef<uint8_t> Desc) {\n  switch (NoteType) {\n  default:\n    return {\"\", \"\"};\n  case ELF::NT_AMD_AMDGPU_HSA_METADATA:\n    return {\n        \"HSA Metadata\",\n        std::string(reinterpret_cast<const char *>(Desc.data()), Desc.size())};\n  case ELF::NT_AMD_AMDGPU_ISA:\n    return {\n        \"ISA Version\",\n        std::string(reinterpret_cast<const char *>(Desc.data()), Desc.size())};\n  }\n}\n\nstruct AMDGPUNote {\n  std::string Type;\n  std::string Value;\n};\n\ntemplate <typename ELFT>\nstatic AMDGPUNote getAMDGPUNote(uint32_t NoteType, ArrayRef<uint8_t> Desc) {\n  switch (NoteType) {\n  default:\n    return {\"\", \"\"};\n  case ELF::NT_AMDGPU_METADATA: {\n    StringRef MsgPackString =\n        StringRef(reinterpret_cast<const char *>(Desc.data()), Desc.size());\n    msgpack::Document MsgPackDoc;\n    if (!MsgPackDoc.readFromBlob(MsgPackString, /*Multi=*/false))\n      return {\"\", \"\"};\n\n    AMDGPU::HSAMD::V3::MetadataVerifier Verifier(true);\n    std::string HSAMetadataString;\n    if (!Verifier.verify(MsgPackDoc.getRoot()))\n      HSAMetadataString = \"Invalid AMDGPU Metadata\\n\";\n\n    raw_string_ostream StrOS(HSAMetadataString);\n    if (MsgPackDoc.getRoot().isScalar()) {\n      // TODO: passing a scalar root to toYAML() asserts:\n      // (PolymorphicTraits<T>::getKind(Val) != NodeKind::Scalar &&\n      //    \"plain scalar documents are not supported\")\n      // To avoid this crash we print the raw data instead.\n      return {\"\", \"\"};\n    }\n    MsgPackDoc.toYAML(StrOS);\n    return {\"AMDGPU Metadata\", StrOS.str()};\n  }\n  }\n}\n\nstruct CoreFileMapping {\n  uint64_t Start, End, Offset;\n  StringRef Filename;\n};\n\nstruct CoreNote {\n  uint64_t PageSize;\n  std::vector<CoreFileMapping> Mappings;\n};\n\nstatic Expected<CoreNote> readCoreNote(DataExtractor Desc) {\n  // Expected format of the NT_FILE note description:\n  // 1. # of file mappings (call it N)\n  // 2. Page size\n  // 3. N (start, end, offset) triples\n  // 4. N packed filenames (null delimited)\n  // Each field is an Elf_Addr, except for filenames which are char* strings.\n\n  CoreNote Ret;\n  const int Bytes = Desc.getAddressSize();\n\n  if (!Desc.isValidOffsetForAddress(2))\n    return createError(\"the note of size 0x\" + Twine::utohexstr(Desc.size()) +\n                       \" is too short, expected at least 0x\" +\n                       Twine::utohexstr(Bytes * 2));\n  if (Desc.getData().back() != 0)\n    return createError(\"the note is not NUL terminated\");\n\n  uint64_t DescOffset = 0;\n  uint64_t FileCount = Desc.getAddress(&DescOffset);\n  Ret.PageSize = Desc.getAddress(&DescOffset);\n\n  if (!Desc.isValidOffsetForAddress(3 * FileCount * Bytes))\n    return createError(\"unable to read file mappings (found \" +\n                       Twine(FileCount) + \"): the note of size 0x\" +\n                       Twine::utohexstr(Desc.size()) + \" is too short\");\n\n  uint64_t FilenamesOffset = 0;\n  DataExtractor Filenames(\n      Desc.getData().drop_front(DescOffset + 3 * FileCount * Bytes),\n      Desc.isLittleEndian(), Desc.getAddressSize());\n\n  Ret.Mappings.resize(FileCount);\n  size_t I = 0;\n  for (CoreFileMapping &Mapping : Ret.Mappings) {\n    ++I;\n    if (!Filenames.isValidOffsetForDataOfSize(FilenamesOffset, 1))\n      return createError(\n          \"unable to read the file name for the mapping with index \" +\n          Twine(I) + \": the note of size 0x\" + Twine::utohexstr(Desc.size()) +\n          \" is truncated\");\n    Mapping.Start = Desc.getAddress(&DescOffset);\n    Mapping.End = Desc.getAddress(&DescOffset);\n    Mapping.Offset = Desc.getAddress(&DescOffset);\n    Mapping.Filename = Filenames.getCStrRef(&FilenamesOffset);\n  }\n\n  return Ret;\n}\n\ntemplate <typename ELFT>\nstatic void printCoreNote(raw_ostream &OS, const CoreNote &Note) {\n  // Length of \"0x<address>\" string.\n  const int FieldWidth = ELFT::Is64Bits ? 18 : 10;\n\n  OS << \"    Page size: \" << format_decimal(Note.PageSize, 0) << '\\n';\n  OS << \"    \" << right_justify(\"Start\", FieldWidth) << \"  \"\n     << right_justify(\"End\", FieldWidth) << \"  \"\n     << right_justify(\"Page Offset\", FieldWidth) << '\\n';\n  for (const CoreFileMapping &Mapping : Note.Mappings) {\n    OS << \"    \" << format_hex(Mapping.Start, FieldWidth) << \"  \"\n       << format_hex(Mapping.End, FieldWidth) << \"  \"\n       << format_hex(Mapping.Offset, FieldWidth) << \"\\n        \"\n       << Mapping.Filename << '\\n';\n  }\n}\n\nstatic const NoteType GenericNoteTypes[] = {\n    {ELF::NT_VERSION, \"NT_VERSION (version)\"},\n    {ELF::NT_ARCH, \"NT_ARCH (architecture)\"},\n    {ELF::NT_GNU_BUILD_ATTRIBUTE_OPEN, \"OPEN\"},\n    {ELF::NT_GNU_BUILD_ATTRIBUTE_FUNC, \"func\"},\n};\n\nstatic const NoteType GNUNoteTypes[] = {\n    {ELF::NT_GNU_ABI_TAG, \"NT_GNU_ABI_TAG (ABI version tag)\"},\n    {ELF::NT_GNU_HWCAP, \"NT_GNU_HWCAP (DSO-supplied software HWCAP info)\"},\n    {ELF::NT_GNU_BUILD_ID, \"NT_GNU_BUILD_ID (unique build ID bitstring)\"},\n    {ELF::NT_GNU_GOLD_VERSION, \"NT_GNU_GOLD_VERSION (gold version)\"},\n    {ELF::NT_GNU_PROPERTY_TYPE_0, \"NT_GNU_PROPERTY_TYPE_0 (property note)\"},\n};\n\nstatic const NoteType FreeBSDCoreNoteTypes[] = {\n    {ELF::NT_FREEBSD_THRMISC, \"NT_THRMISC (thrmisc structure)\"},\n    {ELF::NT_FREEBSD_PROCSTAT_PROC, \"NT_PROCSTAT_PROC (proc data)\"},\n    {ELF::NT_FREEBSD_PROCSTAT_FILES, \"NT_PROCSTAT_FILES (files data)\"},\n    {ELF::NT_FREEBSD_PROCSTAT_VMMAP, \"NT_PROCSTAT_VMMAP (vmmap data)\"},\n    {ELF::NT_FREEBSD_PROCSTAT_GROUPS, \"NT_PROCSTAT_GROUPS (groups data)\"},\n    {ELF::NT_FREEBSD_PROCSTAT_UMASK, \"NT_PROCSTAT_UMASK (umask data)\"},\n    {ELF::NT_FREEBSD_PROCSTAT_RLIMIT, \"NT_PROCSTAT_RLIMIT (rlimit data)\"},\n    {ELF::NT_FREEBSD_PROCSTAT_OSREL, \"NT_PROCSTAT_OSREL (osreldate data)\"},\n    {ELF::NT_FREEBSD_PROCSTAT_PSSTRINGS,\n     \"NT_PROCSTAT_PSSTRINGS (ps_strings data)\"},\n    {ELF::NT_FREEBSD_PROCSTAT_AUXV, \"NT_PROCSTAT_AUXV (auxv data)\"},\n};\n\nstatic const NoteType FreeBSDNoteTypes[] = {\n    {ELF::NT_FREEBSD_ABI_TAG, \"NT_FREEBSD_ABI_TAG (ABI version tag)\"},\n    {ELF::NT_FREEBSD_NOINIT_TAG, \"NT_FREEBSD_NOINIT_TAG (no .init tag)\"},\n    {ELF::NT_FREEBSD_ARCH_TAG, \"NT_FREEBSD_ARCH_TAG (architecture tag)\"},\n    {ELF::NT_FREEBSD_FEATURE_CTL,\n     \"NT_FREEBSD_FEATURE_CTL (FreeBSD feature control)\"},\n};\n\nstatic const NoteType AMDNoteTypes[] = {\n    {ELF::NT_AMD_AMDGPU_HSA_METADATA,\n     \"NT_AMD_AMDGPU_HSA_METADATA (HSA Metadata)\"},\n    {ELF::NT_AMD_AMDGPU_ISA, \"NT_AMD_AMDGPU_ISA (ISA Version)\"},\n    {ELF::NT_AMD_AMDGPU_PAL_METADATA,\n     \"NT_AMD_AMDGPU_PAL_METADATA (PAL Metadata)\"},\n};\n\nstatic const NoteType AMDGPUNoteTypes[] = {\n    {ELF::NT_AMDGPU_METADATA, \"NT_AMDGPU_METADATA (AMDGPU Metadata)\"},\n};\n\nstatic const NoteType CoreNoteTypes[] = {\n    {ELF::NT_PRSTATUS, \"NT_PRSTATUS (prstatus structure)\"},\n    {ELF::NT_FPREGSET, \"NT_FPREGSET (floating point registers)\"},\n    {ELF::NT_PRPSINFO, \"NT_PRPSINFO (prpsinfo structure)\"},\n    {ELF::NT_TASKSTRUCT, \"NT_TASKSTRUCT (task structure)\"},\n    {ELF::NT_AUXV, \"NT_AUXV (auxiliary vector)\"},\n    {ELF::NT_PSTATUS, \"NT_PSTATUS (pstatus structure)\"},\n    {ELF::NT_FPREGS, \"NT_FPREGS (floating point registers)\"},\n    {ELF::NT_PSINFO, \"NT_PSINFO (psinfo structure)\"},\n    {ELF::NT_LWPSTATUS, \"NT_LWPSTATUS (lwpstatus_t structure)\"},\n    {ELF::NT_LWPSINFO, \"NT_LWPSINFO (lwpsinfo_t structure)\"},\n    {ELF::NT_WIN32PSTATUS, \"NT_WIN32PSTATUS (win32_pstatus structure)\"},\n\n    {ELF::NT_PPC_VMX, \"NT_PPC_VMX (ppc Altivec registers)\"},\n    {ELF::NT_PPC_VSX, \"NT_PPC_VSX (ppc VSX registers)\"},\n    {ELF::NT_PPC_TAR, \"NT_PPC_TAR (ppc TAR register)\"},\n    {ELF::NT_PPC_PPR, \"NT_PPC_PPR (ppc PPR register)\"},\n    {ELF::NT_PPC_DSCR, \"NT_PPC_DSCR (ppc DSCR register)\"},\n    {ELF::NT_PPC_EBB, \"NT_PPC_EBB (ppc EBB registers)\"},\n    {ELF::NT_PPC_PMU, \"NT_PPC_PMU (ppc PMU registers)\"},\n    {ELF::NT_PPC_TM_CGPR, \"NT_PPC_TM_CGPR (ppc checkpointed GPR registers)\"},\n    {ELF::NT_PPC_TM_CFPR,\n     \"NT_PPC_TM_CFPR (ppc checkpointed floating point registers)\"},\n    {ELF::NT_PPC_TM_CVMX,\n     \"NT_PPC_TM_CVMX (ppc checkpointed Altivec registers)\"},\n    {ELF::NT_PPC_TM_CVSX, \"NT_PPC_TM_CVSX (ppc checkpointed VSX registers)\"},\n    {ELF::NT_PPC_TM_SPR, \"NT_PPC_TM_SPR (ppc TM special purpose registers)\"},\n    {ELF::NT_PPC_TM_CTAR, \"NT_PPC_TM_CTAR (ppc checkpointed TAR register)\"},\n    {ELF::NT_PPC_TM_CPPR, \"NT_PPC_TM_CPPR (ppc checkpointed PPR register)\"},\n    {ELF::NT_PPC_TM_CDSCR, \"NT_PPC_TM_CDSCR (ppc checkpointed DSCR register)\"},\n\n    {ELF::NT_386_TLS, \"NT_386_TLS (x86 TLS information)\"},\n    {ELF::NT_386_IOPERM, \"NT_386_IOPERM (x86 I/O permissions)\"},\n    {ELF::NT_X86_XSTATE, \"NT_X86_XSTATE (x86 XSAVE extended state)\"},\n\n    {ELF::NT_S390_HIGH_GPRS, \"NT_S390_HIGH_GPRS (s390 upper register halves)\"},\n    {ELF::NT_S390_TIMER, \"NT_S390_TIMER (s390 timer register)\"},\n    {ELF::NT_S390_TODCMP, \"NT_S390_TODCMP (s390 TOD comparator register)\"},\n    {ELF::NT_S390_TODPREG, \"NT_S390_TODPREG (s390 TOD programmable register)\"},\n    {ELF::NT_S390_CTRS, \"NT_S390_CTRS (s390 control registers)\"},\n    {ELF::NT_S390_PREFIX, \"NT_S390_PREFIX (s390 prefix register)\"},\n    {ELF::NT_S390_LAST_BREAK,\n     \"NT_S390_LAST_BREAK (s390 last breaking event address)\"},\n    {ELF::NT_S390_SYSTEM_CALL,\n     \"NT_S390_SYSTEM_CALL (s390 system call restart data)\"},\n    {ELF::NT_S390_TDB, \"NT_S390_TDB (s390 transaction diagnostic block)\"},\n    {ELF::NT_S390_VXRS_LOW,\n     \"NT_S390_VXRS_LOW (s390 vector registers 0-15 upper half)\"},\n    {ELF::NT_S390_VXRS_HIGH, \"NT_S390_VXRS_HIGH (s390 vector registers 16-31)\"},\n    {ELF::NT_S390_GS_CB, \"NT_S390_GS_CB (s390 guarded-storage registers)\"},\n    {ELF::NT_S390_GS_BC,\n     \"NT_S390_GS_BC (s390 guarded-storage broadcast control)\"},\n\n    {ELF::NT_ARM_VFP, \"NT_ARM_VFP (arm VFP registers)\"},\n    {ELF::NT_ARM_TLS, \"NT_ARM_TLS (AArch TLS registers)\"},\n    {ELF::NT_ARM_HW_BREAK,\n     \"NT_ARM_HW_BREAK (AArch hardware breakpoint registers)\"},\n    {ELF::NT_ARM_HW_WATCH,\n     \"NT_ARM_HW_WATCH (AArch hardware watchpoint registers)\"},\n\n    {ELF::NT_FILE, \"NT_FILE (mapped files)\"},\n    {ELF::NT_PRXFPREG, \"NT_PRXFPREG (user_xfpregs structure)\"},\n    {ELF::NT_SIGINFO, \"NT_SIGINFO (siginfo_t data)\"},\n};\n\ntemplate <class ELFT>\nStringRef getNoteTypeName(const typename ELFT::Note &Note, unsigned ELFType) {\n  uint32_t Type = Note.getType();\n  auto FindNote = [&](ArrayRef<NoteType> V) -> StringRef {\n    for (const NoteType &N : V)\n      if (N.ID == Type)\n        return N.Name;\n    return \"\";\n  };\n\n  StringRef Name = Note.getName();\n  if (Name == \"GNU\")\n    return FindNote(GNUNoteTypes);\n  if (Name == \"FreeBSD\") {\n    if (ELFType == ELF::ET_CORE) {\n      // FreeBSD also places the generic core notes in the FreeBSD namespace.\n      StringRef Result = FindNote(FreeBSDCoreNoteTypes);\n      if (!Result.empty())\n        return Result;\n      return FindNote(CoreNoteTypes);\n    } else {\n      return FindNote(FreeBSDNoteTypes);\n    }\n  }\n  if (Name == \"AMD\")\n    return FindNote(AMDNoteTypes);\n  if (Name == \"AMDGPU\")\n    return FindNote(AMDGPUNoteTypes);\n\n  if (ELFType == ELF::ET_CORE)\n    return FindNote(CoreNoteTypes);\n  return FindNote(GenericNoteTypes);\n}\n\ntemplate <class ELFT>\nstatic void printNotesHelper(\n    const ELFDumper<ELFT> &Dumper,\n    llvm::function_ref<void(Optional<StringRef>, typename ELFT::Off,\n                            typename ELFT::Addr)>\n        StartNotesFn,\n    llvm::function_ref<Error(const typename ELFT::Note &, bool)> ProcessNoteFn,\n    llvm::function_ref<void()> FinishNotesFn) {\n  const ELFFile<ELFT> &Obj = Dumper.getElfObject().getELFFile();\n  bool IsCoreFile = Obj.getHeader().e_type == ELF::ET_CORE;\n\n  ArrayRef<typename ELFT::Shdr> Sections = cantFail(Obj.sections());\n  if (!IsCoreFile && !Sections.empty()) {\n    for (const typename ELFT::Shdr &S : Sections) {\n      if (S.sh_type != SHT_NOTE)\n        continue;\n      StartNotesFn(expectedToOptional(Obj.getSectionName(S)), S.sh_offset,\n                   S.sh_size);\n      Error Err = Error::success();\n      size_t I = 0;\n      for (const typename ELFT::Note Note : Obj.notes(S, Err)) {\n        if (Error E = ProcessNoteFn(Note, IsCoreFile))\n          Dumper.reportUniqueWarning(\n              \"unable to read note with index \" + Twine(I) + \" from the \" +\n              describe(Obj, S) + \": \" + toString(std::move(E)));\n        ++I;\n      }\n      if (Err)\n        Dumper.reportUniqueWarning(\"unable to read notes from the \" +\n                                   describe(Obj, S) + \": \" +\n                                   toString(std::move(Err)));\n      FinishNotesFn();\n    }\n    return;\n  }\n\n  Expected<ArrayRef<typename ELFT::Phdr>> PhdrsOrErr = Obj.program_headers();\n  if (!PhdrsOrErr) {\n    Dumper.reportUniqueWarning(\n        \"unable to read program headers to locate the PT_NOTE segment: \" +\n        toString(PhdrsOrErr.takeError()));\n    return;\n  }\n\n  for (size_t I = 0, E = (*PhdrsOrErr).size(); I != E; ++I) {\n    const typename ELFT::Phdr &P = (*PhdrsOrErr)[I];\n    if (P.p_type != PT_NOTE)\n      continue;\n    StartNotesFn(/*SecName=*/None, P.p_offset, P.p_filesz);\n    Error Err = Error::success();\n    size_t Index = 0;\n    for (const typename ELFT::Note Note : Obj.notes(P, Err)) {\n      if (Error E = ProcessNoteFn(Note, IsCoreFile))\n        Dumper.reportUniqueWarning(\"unable to read note with index \" +\n                                   Twine(Index) +\n                                   \" from the PT_NOTE segment with index \" +\n                                   Twine(I) + \": \" + toString(std::move(E)));\n      ++Index;\n    }\n    if (Err)\n      Dumper.reportUniqueWarning(\n          \"unable to read notes from the PT_NOTE segment with index \" +\n          Twine(I) + \": \" + toString(std::move(Err)));\n    FinishNotesFn();\n  }\n}\n\ntemplate <class ELFT> void GNUELFDumper<ELFT>::printNotes() {\n  bool IsFirstHeader = true;\n  auto PrintHeader = [&](Optional<StringRef> SecName,\n                         const typename ELFT::Off Offset,\n                         const typename ELFT::Addr Size) {\n    // Print a newline between notes sections to match GNU readelf.\n    if (!IsFirstHeader) {\n      OS << '\\n';\n    } else {\n      IsFirstHeader = false;\n    }\n\n    OS << \"Displaying notes found \";\n\n    if (SecName)\n      OS << \"in: \" << *SecName << \"\\n\";\n    else\n      OS << \"at file offset \" << format_hex(Offset, 10) << \" with length \"\n         << format_hex(Size, 10) << \":\\n\";\n\n    OS << \"  Owner                Data size \\tDescription\\n\";\n  };\n\n  auto ProcessNote = [&](const Elf_Note &Note, bool IsCore) -> Error {\n    StringRef Name = Note.getName();\n    ArrayRef<uint8_t> Descriptor = Note.getDesc();\n    Elf_Word Type = Note.getType();\n\n    // Print the note owner/type.\n    OS << \"  \" << left_justify(Name, 20) << ' '\n       << format_hex(Descriptor.size(), 10) << '\\t';\n\n    StringRef NoteType =\n        getNoteTypeName<ELFT>(Note, this->Obj.getHeader().e_type);\n    if (!NoteType.empty())\n      OS << NoteType << '\\n';\n    else\n      OS << \"Unknown note type: (\" << format_hex(Type, 10) << \")\\n\";\n\n    // Print the description, or fallback to printing raw bytes for unknown\n    // owners/if we fail to pretty-print the contents.\n    if (Name == \"GNU\") {\n      if (printGNUNote<ELFT>(OS, Type, Descriptor))\n        return Error::success();\n    } else if (Name == \"FreeBSD\") {\n      if (Optional<FreeBSDNote> N =\n              getFreeBSDNote<ELFT>(Type, Descriptor, IsCore)) {\n        OS << \"    \" << N->Type << \": \" << N->Value << '\\n';\n        return Error::success();\n      }\n    } else if (Name == \"AMD\") {\n      const AMDNote N = getAMDNote<ELFT>(Type, Descriptor);\n      if (!N.Type.empty()) {\n        OS << \"    \" << N.Type << \":\\n        \" << N.Value << '\\n';\n        return Error::success();\n      }\n    } else if (Name == \"AMDGPU\") {\n      const AMDGPUNote N = getAMDGPUNote<ELFT>(Type, Descriptor);\n      if (!N.Type.empty()) {\n        OS << \"    \" << N.Type << \":\\n        \" << N.Value << '\\n';\n        return Error::success();\n      }\n    } else if (Name == \"CORE\") {\n      if (Type == ELF::NT_FILE) {\n        DataExtractor DescExtractor(Descriptor,\n                                    ELFT::TargetEndianness == support::little,\n                                    sizeof(Elf_Addr));\n        if (Expected<CoreNote> NoteOrErr = readCoreNote(DescExtractor)) {\n          printCoreNote<ELFT>(OS, *NoteOrErr);\n          return Error::success();\n        } else {\n          return NoteOrErr.takeError();\n        }\n      }\n    }\n    if (!Descriptor.empty()) {\n      OS << \"   description data:\";\n      for (uint8_t B : Descriptor)\n        OS << \" \" << format(\"%02x\", B);\n      OS << '\\n';\n    }\n    return Error::success();\n  };\n\n  printNotesHelper(*this, PrintHeader, ProcessNote, []() {});\n}\n\ntemplate <class ELFT> void GNUELFDumper<ELFT>::printELFLinkerOptions() {\n  OS << \"printELFLinkerOptions not implemented!\\n\";\n}\n\ntemplate <class ELFT>\nvoid ELFDumper<ELFT>::printDependentLibsHelper(\n    function_ref<void(const Elf_Shdr &)> OnSectionStart,\n    function_ref<void(StringRef, uint64_t)> OnLibEntry) {\n  auto Warn = [this](unsigned SecNdx, StringRef Msg) {\n    this->reportUniqueWarning(\"SHT_LLVM_DEPENDENT_LIBRARIES section at index \" +\n                              Twine(SecNdx) + \" is broken: \" + Msg);\n  };\n\n  unsigned I = -1;\n  for (const Elf_Shdr &Shdr : cantFail(Obj.sections())) {\n    ++I;\n    if (Shdr.sh_type != ELF::SHT_LLVM_DEPENDENT_LIBRARIES)\n      continue;\n\n    OnSectionStart(Shdr);\n\n    Expected<ArrayRef<uint8_t>> ContentsOrErr = Obj.getSectionContents(Shdr);\n    if (!ContentsOrErr) {\n      Warn(I, toString(ContentsOrErr.takeError()));\n      continue;\n    }\n\n    ArrayRef<uint8_t> Contents = *ContentsOrErr;\n    if (!Contents.empty() && Contents.back() != 0) {\n      Warn(I, \"the content is not null-terminated\");\n      continue;\n    }\n\n    for (const uint8_t *I = Contents.begin(), *E = Contents.end(); I < E;) {\n      StringRef Lib((const char *)I);\n      OnLibEntry(Lib, I - Contents.begin());\n      I += Lib.size() + 1;\n    }\n  }\n}\n\ntemplate <class ELFT>\nvoid ELFDumper<ELFT>::forEachRelocationDo(\n    const Elf_Shdr &Sec, bool RawRelr,\n    llvm::function_ref<void(const Relocation<ELFT> &, unsigned,\n                            const Elf_Shdr &, const Elf_Shdr *)>\n        RelRelaFn,\n    llvm::function_ref<void(const Elf_Relr &)> RelrFn) {\n  auto Warn = [&](Error &&E,\n                  const Twine &Prefix = \"unable to read relocations from\") {\n    this->reportUniqueWarning(Prefix + \" \" + describe(Sec) + \": \" +\n                              toString(std::move(E)));\n  };\n\n  // SHT_RELR/SHT_ANDROID_RELR sections do not have an associated symbol table.\n  // For them we should not treat the value of the sh_link field as an index of\n  // a symbol table.\n  const Elf_Shdr *SymTab;\n  if (Sec.sh_type != ELF::SHT_RELR && Sec.sh_type != ELF::SHT_ANDROID_RELR) {\n    Expected<const Elf_Shdr *> SymTabOrErr = Obj.getSection(Sec.sh_link);\n    if (!SymTabOrErr) {\n      Warn(SymTabOrErr.takeError(), \"unable to locate a symbol table for\");\n      return;\n    }\n    SymTab = *SymTabOrErr;\n  }\n\n  unsigned RelNdx = 0;\n  const bool IsMips64EL = this->Obj.isMips64EL();\n  switch (Sec.sh_type) {\n  case ELF::SHT_REL:\n    if (Expected<Elf_Rel_Range> RangeOrErr = Obj.rels(Sec)) {\n      for (const Elf_Rel &R : *RangeOrErr)\n        RelRelaFn(Relocation<ELFT>(R, IsMips64EL), RelNdx++, Sec, SymTab);\n    } else {\n      Warn(RangeOrErr.takeError());\n    }\n    break;\n  case ELF::SHT_RELA:\n    if (Expected<Elf_Rela_Range> RangeOrErr = Obj.relas(Sec)) {\n      for (const Elf_Rela &R : *RangeOrErr)\n        RelRelaFn(Relocation<ELFT>(R, IsMips64EL), RelNdx++, Sec, SymTab);\n    } else {\n      Warn(RangeOrErr.takeError());\n    }\n    break;\n  case ELF::SHT_RELR:\n  case ELF::SHT_ANDROID_RELR: {\n    Expected<Elf_Relr_Range> RangeOrErr = Obj.relrs(Sec);\n    if (!RangeOrErr) {\n      Warn(RangeOrErr.takeError());\n      break;\n    }\n    if (RawRelr) {\n      for (const Elf_Relr &R : *RangeOrErr)\n        RelrFn(R);\n      break;\n    }\n\n    for (const Elf_Rel &R : Obj.decode_relrs(*RangeOrErr))\n      RelRelaFn(Relocation<ELFT>(R, IsMips64EL), RelNdx++, Sec,\n                /*SymTab=*/nullptr);\n    break;\n  }\n  case ELF::SHT_ANDROID_REL:\n  case ELF::SHT_ANDROID_RELA:\n    if (Expected<std::vector<Elf_Rela>> RelasOrErr = Obj.android_relas(Sec)) {\n      for (const Elf_Rela &R : *RelasOrErr)\n        RelRelaFn(Relocation<ELFT>(R, IsMips64EL), RelNdx++, Sec, SymTab);\n    } else {\n      Warn(RelasOrErr.takeError());\n    }\n    break;\n  }\n}\n\ntemplate <class ELFT>\nStringRef ELFDumper<ELFT>::getPrintableSectionName(const Elf_Shdr &Sec) const {\n  StringRef Name = \"<?>\";\n  if (Expected<StringRef> SecNameOrErr =\n          Obj.getSectionName(Sec, this->WarningHandler))\n    Name = *SecNameOrErr;\n  else\n    this->reportUniqueWarning(\"unable to get the name of \" + describe(Sec) +\n                              \": \" + toString(SecNameOrErr.takeError()));\n  return Name;\n}\n\ntemplate <class ELFT> void GNUELFDumper<ELFT>::printDependentLibs() {\n  bool SectionStarted = false;\n  struct NameOffset {\n    StringRef Name;\n    uint64_t Offset;\n  };\n  std::vector<NameOffset> SecEntries;\n  NameOffset Current;\n  auto PrintSection = [&]() {\n    OS << \"Dependent libraries section \" << Current.Name << \" at offset \"\n       << format_hex(Current.Offset, 1) << \" contains \" << SecEntries.size()\n       << \" entries:\\n\";\n    for (NameOffset Entry : SecEntries)\n      OS << \"  [\" << format(\"%6\" PRIx64, Entry.Offset) << \"]  \" << Entry.Name\n         << \"\\n\";\n    OS << \"\\n\";\n    SecEntries.clear();\n  };\n\n  auto OnSectionStart = [&](const Elf_Shdr &Shdr) {\n    if (SectionStarted)\n      PrintSection();\n    SectionStarted = true;\n    Current.Offset = Shdr.sh_offset;\n    Current.Name = this->getPrintableSectionName(Shdr);\n  };\n  auto OnLibEntry = [&](StringRef Lib, uint64_t Offset) {\n    SecEntries.push_back(NameOffset{Lib, Offset});\n  };\n\n  this->printDependentLibsHelper(OnSectionStart, OnLibEntry);\n  if (SectionStarted)\n    PrintSection();\n}\n\ntemplate <class ELFT>\nbool ELFDumper<ELFT>::printFunctionStackSize(\n    uint64_t SymValue, Optional<const Elf_Shdr *> FunctionSec,\n    const Elf_Shdr &StackSizeSec, DataExtractor Data, uint64_t *Offset) {\n  uint32_t FuncSymIndex = 0;\n  if (this->DotSymtabSec) {\n    if (Expected<Elf_Sym_Range> SymsOrError = Obj.symbols(this->DotSymtabSec)) {\n      uint32_t Index = (uint32_t)-1;\n      for (const Elf_Sym &Sym : *SymsOrError) {\n        ++Index;\n\n        if (Sym.st_shndx == ELF::SHN_UNDEF || Sym.getType() != ELF::STT_FUNC)\n          continue;\n\n        if (Expected<uint64_t> SymAddrOrErr =\n                ObjF.toSymbolRef(this->DotSymtabSec, Index).getAddress()) {\n          if (SymValue != *SymAddrOrErr)\n            continue;\n        } else {\n          std::string Name = this->getStaticSymbolName(Index);\n          reportUniqueWarning(\"unable to get address of symbol '\" + Name +\n                              \"': \" + toString(SymAddrOrErr.takeError()));\n          break;\n        }\n\n        // Check if the symbol is in the right section. FunctionSec == None\n        // means \"any section\".\n        if (FunctionSec) {\n          if (Expected<const Elf_Shdr *> SecOrErr =\n                  Obj.getSection(Sym, this->DotSymtabSec,\n                                 this->getShndxTable(this->DotSymtabSec))) {\n            if (*FunctionSec != *SecOrErr)\n              continue;\n          } else {\n            std::string Name = this->getStaticSymbolName(Index);\n            // Note: it is impossible to trigger this error currently, it is\n            // untested.\n            reportUniqueWarning(\"unable to get section of symbol '\" + Name +\n                                \"': \" + toString(SecOrErr.takeError()));\n            break;\n          }\n        }\n\n        FuncSymIndex = Index;\n        break;\n      }\n    } else {\n      reportUniqueWarning(\"unable to read the symbol table: \" +\n                          toString(SymsOrError.takeError()));\n    }\n  }\n\n  std::string FuncName = \"?\";\n  if (!FuncSymIndex)\n    reportUniqueWarning(\n        \"could not identify function symbol for stack size entry in \" +\n        describe(StackSizeSec));\n  else\n    FuncName = this->getStaticSymbolName(FuncSymIndex);\n\n  // Extract the size. The expectation is that Offset is pointing to the right\n  // place, i.e. past the function address.\n  Error Err = Error::success();\n  uint64_t StackSize = Data.getULEB128(Offset, &Err);\n  if (Err) {\n    reportUniqueWarning(\"could not extract a valid stack size from \" +\n                        describe(StackSizeSec) + \": \" +\n                        toString(std::move(Err)));\n    return false;\n  }\n  printStackSizeEntry(StackSize, FuncName);\n  return true;\n}\n\ntemplate <class ELFT>\nvoid GNUELFDumper<ELFT>::printStackSizeEntry(uint64_t Size,\n                                             StringRef FuncName) {\n  OS.PadToColumn(2);\n  OS << format_decimal(Size, 11);\n  OS.PadToColumn(18);\n  OS << FuncName << \"\\n\";\n}\n\ntemplate <class ELFT>\nvoid ELFDumper<ELFT>::printStackSize(const Relocation<ELFT> &R,\n                                     const Elf_Shdr &RelocSec, unsigned Ndx,\n                                     const Elf_Shdr *SymTab,\n                                     const Elf_Shdr *FunctionSec,\n                                     const Elf_Shdr &StackSizeSec,\n                                     const RelocationResolver &Resolver,\n                                     DataExtractor Data) {\n  // This function ignores potentially erroneous input, unless it is directly\n  // related to stack size reporting.\n  const Elf_Sym *Sym = nullptr;\n  Expected<RelSymbol<ELFT>> TargetOrErr = this->getRelocationTarget(R, SymTab);\n  if (!TargetOrErr)\n    reportUniqueWarning(\"unable to get the target of relocation with index \" +\n                        Twine(Ndx) + \" in \" + describe(RelocSec) + \": \" +\n                        toString(TargetOrErr.takeError()));\n  else\n    Sym = TargetOrErr->Sym;\n\n  uint64_t RelocSymValue = 0;\n  if (Sym) {\n    Expected<const Elf_Shdr *> SectionOrErr =\n        this->Obj.getSection(*Sym, SymTab, this->getShndxTable(SymTab));\n    if (!SectionOrErr) {\n      reportUniqueWarning(\n          \"cannot identify the section for relocation symbol '\" +\n          (*TargetOrErr).Name + \"': \" + toString(SectionOrErr.takeError()));\n    } else if (*SectionOrErr != FunctionSec) {\n      reportUniqueWarning(\"relocation symbol '\" + (*TargetOrErr).Name +\n                          \"' is not in the expected section\");\n      // Pretend that the symbol is in the correct section and report its\n      // stack size anyway.\n      FunctionSec = *SectionOrErr;\n    }\n\n    RelocSymValue = Sym->st_value;\n  }\n\n  uint64_t Offset = R.Offset;\n  if (!Data.isValidOffsetForDataOfSize(Offset, sizeof(Elf_Addr) + 1)) {\n    reportUniqueWarning(\"found invalid relocation offset (0x\" +\n                        Twine::utohexstr(Offset) + \") into \" +\n                        describe(StackSizeSec) +\n                        \" while trying to extract a stack size entry\");\n    return;\n  }\n\n  uint64_t SymValue =\n      Resolver(R.Type, Offset, RelocSymValue, Data.getAddress(&Offset),\n               R.Addend.getValueOr(0));\n  this->printFunctionStackSize(SymValue, FunctionSec, StackSizeSec, Data,\n                               &Offset);\n}\n\ntemplate <class ELFT>\nvoid ELFDumper<ELFT>::printNonRelocatableStackSizes(\n    std::function<void()> PrintHeader) {\n  // This function ignores potentially erroneous input, unless it is directly\n  // related to stack size reporting.\n  for (const Elf_Shdr &Sec : cantFail(Obj.sections())) {\n    if (this->getPrintableSectionName(Sec) != \".stack_sizes\")\n      continue;\n    PrintHeader();\n    ArrayRef<uint8_t> Contents =\n        unwrapOrError(this->FileName, Obj.getSectionContents(Sec));\n    DataExtractor Data(Contents, Obj.isLE(), sizeof(Elf_Addr));\n    uint64_t Offset = 0;\n    while (Offset < Contents.size()) {\n      // The function address is followed by a ULEB representing the stack\n      // size. Check for an extra byte before we try to process the entry.\n      if (!Data.isValidOffsetForDataOfSize(Offset, sizeof(Elf_Addr) + 1)) {\n        reportUniqueWarning(\n            describe(Sec) +\n            \" ended while trying to extract a stack size entry\");\n        break;\n      }\n      uint64_t SymValue = Data.getAddress(&Offset);\n      if (!printFunctionStackSize(SymValue, /*FunctionSec=*/None, Sec, Data,\n                                  &Offset))\n        break;\n    }\n  }\n}\n\ntemplate <class ELFT>\nvoid ELFDumper<ELFT>::printRelocatableStackSizes(\n    std::function<void()> PrintHeader) {\n  // Build a map between stack size sections and their corresponding relocation\n  // sections.\n  llvm::MapVector<const Elf_Shdr *, const Elf_Shdr *> StackSizeRelocMap;\n  for (const Elf_Shdr &Sec : cantFail(Obj.sections())) {\n    StringRef SectionName;\n    if (Expected<StringRef> NameOrErr = Obj.getSectionName(Sec))\n      SectionName = *NameOrErr;\n    else\n      consumeError(NameOrErr.takeError());\n\n    // A stack size section that we haven't encountered yet is mapped to the\n    // null section until we find its corresponding relocation section.\n    if (SectionName == \".stack_sizes\")\n      if (StackSizeRelocMap\n              .insert(std::make_pair(&Sec, (const Elf_Shdr *)nullptr))\n              .second)\n        continue;\n\n    // Check relocation sections if they are relocating contents of a\n    // stack sizes section.\n    if (Sec.sh_type != ELF::SHT_RELA && Sec.sh_type != ELF::SHT_REL)\n      continue;\n\n    Expected<const Elf_Shdr *> RelSecOrErr = Obj.getSection(Sec.sh_info);\n    if (!RelSecOrErr) {\n      reportUniqueWarning(describe(Sec) +\n                          \": failed to get a relocated section: \" +\n                          toString(RelSecOrErr.takeError()));\n      continue;\n    }\n\n    const Elf_Shdr *ContentsSec = *RelSecOrErr;\n    if (this->getPrintableSectionName(**RelSecOrErr) != \".stack_sizes\")\n      continue;\n\n    // Insert a mapping from the stack sizes section to its relocation section.\n    StackSizeRelocMap[ContentsSec] = &Sec;\n  }\n\n  for (const auto &StackSizeMapEntry : StackSizeRelocMap) {\n    PrintHeader();\n    const Elf_Shdr *StackSizesELFSec = StackSizeMapEntry.first;\n    const Elf_Shdr *RelocSec = StackSizeMapEntry.second;\n\n    // Warn about stack size sections without a relocation section.\n    if (!RelocSec) {\n      reportWarning(createError(\".stack_sizes (\" + describe(*StackSizesELFSec) +\n                                \") does not have a corresponding \"\n                                \"relocation section\"),\n                    FileName);\n      continue;\n    }\n\n    // A .stack_sizes section header's sh_link field is supposed to point\n    // to the section that contains the functions whose stack sizes are\n    // described in it.\n    const Elf_Shdr *FunctionSec = unwrapOrError(\n        this->FileName, Obj.getSection(StackSizesELFSec->sh_link));\n\n    SupportsRelocation IsSupportedFn;\n    RelocationResolver Resolver;\n    std::tie(IsSupportedFn, Resolver) = getRelocationResolver(this->ObjF);\n    ArrayRef<uint8_t> Contents =\n        unwrapOrError(this->FileName, Obj.getSectionContents(*StackSizesELFSec));\n    DataExtractor Data(Contents, Obj.isLE(), sizeof(Elf_Addr));\n\n    forEachRelocationDo(\n        *RelocSec, /*RawRelr=*/false,\n        [&](const Relocation<ELFT> &R, unsigned Ndx, const Elf_Shdr &Sec,\n            const Elf_Shdr *SymTab) {\n          if (!IsSupportedFn || !IsSupportedFn(R.Type)) {\n            reportUniqueWarning(\n                describe(*RelocSec) +\n                \" contains an unsupported relocation with index \" + Twine(Ndx) +\n                \": \" + Obj.getRelocationTypeName(R.Type));\n            return;\n          }\n\n          this->printStackSize(R, *RelocSec, Ndx, SymTab, FunctionSec,\n                               *StackSizesELFSec, Resolver, Data);\n        },\n        [](const Elf_Relr &) {\n          llvm_unreachable(\"can't get here, because we only support \"\n                           \"SHT_REL/SHT_RELA sections\");\n        });\n  }\n}\n\ntemplate <class ELFT>\nvoid GNUELFDumper<ELFT>::printStackSizes() {\n  bool HeaderHasBeenPrinted = false;\n  auto PrintHeader = [&]() {\n    if (HeaderHasBeenPrinted)\n      return;\n    OS << \"\\nStack Sizes:\\n\";\n    OS.PadToColumn(9);\n    OS << \"Size\";\n    OS.PadToColumn(18);\n    OS << \"Function\\n\";\n    HeaderHasBeenPrinted = true;\n  };\n\n  // For non-relocatable objects, look directly for sections whose name starts\n  // with .stack_sizes and process the contents.\n  if (this->Obj.getHeader().e_type == ELF::ET_REL)\n    this->printRelocatableStackSizes(PrintHeader);\n  else\n    this->printNonRelocatableStackSizes(PrintHeader);\n}\n\ntemplate <class ELFT>\nvoid GNUELFDumper<ELFT>::printMipsGOT(const MipsGOTParser<ELFT> &Parser) {\n  size_t Bias = ELFT::Is64Bits ? 8 : 0;\n  auto PrintEntry = [&](const Elf_Addr *E, StringRef Purpose) {\n    OS.PadToColumn(2);\n    OS << format_hex_no_prefix(Parser.getGotAddress(E), 8 + Bias);\n    OS.PadToColumn(11 + Bias);\n    OS << format_decimal(Parser.getGotOffset(E), 6) << \"(gp)\";\n    OS.PadToColumn(22 + Bias);\n    OS << format_hex_no_prefix(*E, 8 + Bias);\n    OS.PadToColumn(31 + 2 * Bias);\n    OS << Purpose << \"\\n\";\n  };\n\n  OS << (Parser.IsStatic ? \"Static GOT:\\n\" : \"Primary GOT:\\n\");\n  OS << \" Canonical gp value: \"\n     << format_hex_no_prefix(Parser.getGp(), 8 + Bias) << \"\\n\\n\";\n\n  OS << \" Reserved entries:\\n\";\n  if (ELFT::Is64Bits)\n    OS << \"           Address     Access          Initial Purpose\\n\";\n  else\n    OS << \"   Address     Access  Initial Purpose\\n\";\n  PrintEntry(Parser.getGotLazyResolver(), \"Lazy resolver\");\n  if (Parser.getGotModulePointer())\n    PrintEntry(Parser.getGotModulePointer(), \"Module pointer (GNU extension)\");\n\n  if (!Parser.getLocalEntries().empty()) {\n    OS << \"\\n\";\n    OS << \" Local entries:\\n\";\n    if (ELFT::Is64Bits)\n      OS << \"           Address     Access          Initial\\n\";\n    else\n      OS << \"   Address     Access  Initial\\n\";\n    for (auto &E : Parser.getLocalEntries())\n      PrintEntry(&E, \"\");\n  }\n\n  if (Parser.IsStatic)\n    return;\n\n  if (!Parser.getGlobalEntries().empty()) {\n    OS << \"\\n\";\n    OS << \" Global entries:\\n\";\n    if (ELFT::Is64Bits)\n      OS << \"           Address     Access          Initial         Sym.Val.\"\n         << \" Type    Ndx Name\\n\";\n    else\n      OS << \"   Address     Access  Initial Sym.Val. Type    Ndx Name\\n\";\n\n    DataRegion<Elf_Word> ShndxTable(\n        (const Elf_Word *)this->DynSymTabShndxRegion.Addr, this->Obj.end());\n    for (auto &E : Parser.getGlobalEntries()) {\n      const Elf_Sym &Sym = *Parser.getGotSym(&E);\n      const Elf_Sym &FirstSym = this->dynamic_symbols()[0];\n      std::string SymName = this->getFullSymbolName(\n          Sym, &Sym - &FirstSym, ShndxTable, this->DynamicStringTable, false);\n\n      OS.PadToColumn(2);\n      OS << to_string(format_hex_no_prefix(Parser.getGotAddress(&E), 8 + Bias));\n      OS.PadToColumn(11 + Bias);\n      OS << to_string(format_decimal(Parser.getGotOffset(&E), 6)) + \"(gp)\";\n      OS.PadToColumn(22 + Bias);\n      OS << to_string(format_hex_no_prefix(E, 8 + Bias));\n      OS.PadToColumn(31 + 2 * Bias);\n      OS << to_string(format_hex_no_prefix(Sym.st_value, 8 + Bias));\n      OS.PadToColumn(40 + 3 * Bias);\n      OS << printEnum(Sym.getType(), makeArrayRef(ElfSymbolTypes));\n      OS.PadToColumn(48 + 3 * Bias);\n      OS << getSymbolSectionNdx(Sym, &Sym - this->dynamic_symbols().begin(),\n                                ShndxTable);\n      OS.PadToColumn(52 + 3 * Bias);\n      OS << SymName << \"\\n\";\n    }\n  }\n\n  if (!Parser.getOtherEntries().empty())\n    OS << \"\\n Number of TLS and multi-GOT entries \"\n       << Parser.getOtherEntries().size() << \"\\n\";\n}\n\ntemplate <class ELFT>\nvoid GNUELFDumper<ELFT>::printMipsPLT(const MipsGOTParser<ELFT> &Parser) {\n  size_t Bias = ELFT::Is64Bits ? 8 : 0;\n  auto PrintEntry = [&](const Elf_Addr *E, StringRef Purpose) {\n    OS.PadToColumn(2);\n    OS << format_hex_no_prefix(Parser.getPltAddress(E), 8 + Bias);\n    OS.PadToColumn(11 + Bias);\n    OS << format_hex_no_prefix(*E, 8 + Bias);\n    OS.PadToColumn(20 + 2 * Bias);\n    OS << Purpose << \"\\n\";\n  };\n\n  OS << \"PLT GOT:\\n\\n\";\n\n  OS << \" Reserved entries:\\n\";\n  OS << \"   Address  Initial Purpose\\n\";\n  PrintEntry(Parser.getPltLazyResolver(), \"PLT lazy resolver\");\n  if (Parser.getPltModulePointer())\n    PrintEntry(Parser.getPltModulePointer(), \"Module pointer\");\n\n  if (!Parser.getPltEntries().empty()) {\n    OS << \"\\n\";\n    OS << \" Entries:\\n\";\n    OS << \"   Address  Initial Sym.Val. Type    Ndx Name\\n\";\n    DataRegion<Elf_Word> ShndxTable(\n        (const Elf_Word *)this->DynSymTabShndxRegion.Addr, this->Obj.end());\n    for (auto &E : Parser.getPltEntries()) {\n      const Elf_Sym &Sym = *Parser.getPltSym(&E);\n      const Elf_Sym &FirstSym = *cantFail(\n          this->Obj.template getEntry<Elf_Sym>(*Parser.getPltSymTable(), 0));\n      std::string SymName = this->getFullSymbolName(\n          Sym, &Sym - &FirstSym, ShndxTable, this->DynamicStringTable, false);\n\n      OS.PadToColumn(2);\n      OS << to_string(format_hex_no_prefix(Parser.getPltAddress(&E), 8 + Bias));\n      OS.PadToColumn(11 + Bias);\n      OS << to_string(format_hex_no_prefix(E, 8 + Bias));\n      OS.PadToColumn(20 + 2 * Bias);\n      OS << to_string(format_hex_no_prefix(Sym.st_value, 8 + Bias));\n      OS.PadToColumn(29 + 3 * Bias);\n      OS << printEnum(Sym.getType(), makeArrayRef(ElfSymbolTypes));\n      OS.PadToColumn(37 + 3 * Bias);\n      OS << getSymbolSectionNdx(Sym, &Sym - this->dynamic_symbols().begin(),\n                                ShndxTable);\n      OS.PadToColumn(41 + 3 * Bias);\n      OS << SymName << \"\\n\";\n    }\n  }\n}\n\ntemplate <class ELFT>\nExpected<const Elf_Mips_ABIFlags<ELFT> *>\ngetMipsAbiFlagsSection(const ELFDumper<ELFT> &Dumper) {\n  const typename ELFT::Shdr *Sec = Dumper.findSectionByName(\".MIPS.abiflags\");\n  if (Sec == nullptr)\n    return nullptr;\n\n  constexpr StringRef ErrPrefix = \"unable to read the .MIPS.abiflags section: \";\n  Expected<ArrayRef<uint8_t>> DataOrErr =\n      Dumper.getElfObject().getELFFile().getSectionContents(*Sec);\n  if (!DataOrErr)\n    return createError(ErrPrefix + toString(DataOrErr.takeError()));\n\n  if (DataOrErr->size() != sizeof(Elf_Mips_ABIFlags<ELFT>))\n    return createError(ErrPrefix + \"it has a wrong size (\" +\n        Twine(DataOrErr->size()) + \")\");\n  return reinterpret_cast<const Elf_Mips_ABIFlags<ELFT> *>(DataOrErr->data());\n}\n\ntemplate <class ELFT> void GNUELFDumper<ELFT>::printMipsABIFlags() {\n  const Elf_Mips_ABIFlags<ELFT> *Flags = nullptr;\n  if (Expected<const Elf_Mips_ABIFlags<ELFT> *> SecOrErr =\n          getMipsAbiFlagsSection(*this))\n    Flags = *SecOrErr;\n  else\n    this->reportUniqueWarning(SecOrErr.takeError());\n  if (!Flags)\n    return;\n\n  OS << \"MIPS ABI Flags Version: \" << Flags->version << \"\\n\\n\";\n  OS << \"ISA: MIPS\" << int(Flags->isa_level);\n  if (Flags->isa_rev > 1)\n    OS << \"r\" << int(Flags->isa_rev);\n  OS << \"\\n\";\n  OS << \"GPR size: \" << getMipsRegisterSize(Flags->gpr_size) << \"\\n\";\n  OS << \"CPR1 size: \" << getMipsRegisterSize(Flags->cpr1_size) << \"\\n\";\n  OS << \"CPR2 size: \" << getMipsRegisterSize(Flags->cpr2_size) << \"\\n\";\n  OS << \"FP ABI: \" << printEnum(Flags->fp_abi, makeArrayRef(ElfMipsFpABIType))\n     << \"\\n\";\n  OS << \"ISA Extension: \"\n     << printEnum(Flags->isa_ext, makeArrayRef(ElfMipsISAExtType)) << \"\\n\";\n  if (Flags->ases == 0)\n    OS << \"ASEs: None\\n\";\n  else\n    // FIXME: Print each flag on a separate line.\n    OS << \"ASEs: \" << printFlags(Flags->ases, makeArrayRef(ElfMipsASEFlags))\n       << \"\\n\";\n  OS << \"FLAGS 1: \" << format_hex_no_prefix(Flags->flags1, 8, false) << \"\\n\";\n  OS << \"FLAGS 2: \" << format_hex_no_prefix(Flags->flags2, 8, false) << \"\\n\";\n  OS << \"\\n\";\n}\n\ntemplate <class ELFT> void LLVMELFDumper<ELFT>::printFileHeaders() {\n  const Elf_Ehdr &E = this->Obj.getHeader();\n  {\n    DictScope D(W, \"ElfHeader\");\n    {\n      DictScope D(W, \"Ident\");\n      W.printBinary(\"Magic\", makeArrayRef(E.e_ident).slice(ELF::EI_MAG0, 4));\n      W.printEnum(\"Class\", E.e_ident[ELF::EI_CLASS], makeArrayRef(ElfClass));\n      W.printEnum(\"DataEncoding\", E.e_ident[ELF::EI_DATA],\n                  makeArrayRef(ElfDataEncoding));\n      W.printNumber(\"FileVersion\", E.e_ident[ELF::EI_VERSION]);\n\n      auto OSABI = makeArrayRef(ElfOSABI);\n      if (E.e_ident[ELF::EI_OSABI] >= ELF::ELFOSABI_FIRST_ARCH &&\n          E.e_ident[ELF::EI_OSABI] <= ELF::ELFOSABI_LAST_ARCH) {\n        switch (E.e_machine) {\n        case ELF::EM_AMDGPU:\n          OSABI = makeArrayRef(AMDGPUElfOSABI);\n          break;\n        case ELF::EM_ARM:\n          OSABI = makeArrayRef(ARMElfOSABI);\n          break;\n        case ELF::EM_TI_C6000:\n          OSABI = makeArrayRef(C6000ElfOSABI);\n          break;\n        }\n      }\n      W.printEnum(\"OS/ABI\", E.e_ident[ELF::EI_OSABI], OSABI);\n      W.printNumber(\"ABIVersion\", E.e_ident[ELF::EI_ABIVERSION]);\n      W.printBinary(\"Unused\", makeArrayRef(E.e_ident).slice(ELF::EI_PAD));\n    }\n\n    std::string TypeStr;\n    if (const EnumEntry<unsigned> *Ent = getObjectFileEnumEntry(E.e_type)) {\n      TypeStr = Ent->Name.str();\n    } else {\n      if (E.e_type >= ET_LOPROC)\n        TypeStr = \"Processor Specific\";\n      else if (E.e_type >= ET_LOOS)\n        TypeStr = \"OS Specific\";\n      else\n        TypeStr = \"Unknown\";\n    }\n    W.printString(\"Type\", TypeStr + \" (0x\" + to_hexString(E.e_type) + \")\");\n\n    W.printEnum(\"Machine\", E.e_machine, makeArrayRef(ElfMachineType));\n    W.printNumber(\"Version\", E.e_version);\n    W.printHex(\"Entry\", E.e_entry);\n    W.printHex(\"ProgramHeaderOffset\", E.e_phoff);\n    W.printHex(\"SectionHeaderOffset\", E.e_shoff);\n    if (E.e_machine == EM_MIPS)\n      W.printFlags(\"Flags\", E.e_flags, makeArrayRef(ElfHeaderMipsFlags),\n                   unsigned(ELF::EF_MIPS_ARCH), unsigned(ELF::EF_MIPS_ABI),\n                   unsigned(ELF::EF_MIPS_MACH));\n    else if (E.e_machine == EM_AMDGPU)\n      W.printFlags(\"Flags\", E.e_flags, makeArrayRef(ElfHeaderAMDGPUFlags),\n                   unsigned(ELF::EF_AMDGPU_MACH));\n    else if (E.e_machine == EM_RISCV)\n      W.printFlags(\"Flags\", E.e_flags, makeArrayRef(ElfHeaderRISCVFlags));\n    else\n      W.printFlags(\"Flags\", E.e_flags);\n    W.printNumber(\"HeaderSize\", E.e_ehsize);\n    W.printNumber(\"ProgramHeaderEntrySize\", E.e_phentsize);\n    W.printNumber(\"ProgramHeaderCount\", E.e_phnum);\n    W.printNumber(\"SectionHeaderEntrySize\", E.e_shentsize);\n    W.printString(\"SectionHeaderCount\",\n                  getSectionHeadersNumString(this->Obj, this->FileName));\n    W.printString(\"StringTableSectionIndex\",\n                  getSectionHeaderTableIndexString(this->Obj, this->FileName));\n  }\n}\n\ntemplate <class ELFT> void LLVMELFDumper<ELFT>::printGroupSections() {\n  DictScope Lists(W, \"Groups\");\n  std::vector<GroupSection> V = this->getGroups();\n  DenseMap<uint64_t, const GroupSection *> Map = mapSectionsToGroups(V);\n  for (const GroupSection &G : V) {\n    DictScope D(W, \"Group\");\n    W.printNumber(\"Name\", G.Name, G.ShName);\n    W.printNumber(\"Index\", G.Index);\n    W.printNumber(\"Link\", G.Link);\n    W.printNumber(\"Info\", G.Info);\n    W.printHex(\"Type\", getGroupType(G.Type), G.Type);\n    W.startLine() << \"Signature: \" << G.Signature << \"\\n\";\n\n    ListScope L(W, \"Section(s) in group\");\n    for (const GroupMember &GM : G.Members) {\n      const GroupSection *MainGroup = Map[GM.Index];\n      if (MainGroup != &G)\n        this->reportUniqueWarning(\n            \"section with index \" + Twine(GM.Index) +\n            \", included in the group section with index \" +\n            Twine(MainGroup->Index) +\n            \", was also found in the group section with index \" +\n            Twine(G.Index));\n      W.startLine() << GM.Name << \" (\" << GM.Index << \")\\n\";\n    }\n  }\n\n  if (V.empty())\n    W.startLine() << \"There are no group sections in the file.\\n\";\n}\n\ntemplate <class ELFT> void LLVMELFDumper<ELFT>::printRelocations() {\n  ListScope D(W, \"Relocations\");\n\n  for (const Elf_Shdr &Sec : cantFail(this->Obj.sections())) {\n    if (!isRelocationSec<ELFT>(Sec))\n      continue;\n\n    StringRef Name = this->getPrintableSectionName(Sec);\n    unsigned SecNdx = &Sec - &cantFail(this->Obj.sections()).front();\n    W.startLine() << \"Section (\" << SecNdx << \") \" << Name << \" {\\n\";\n    W.indent();\n    this->printRelocationsHelper(Sec);\n    W.unindent();\n    W.startLine() << \"}\\n\";\n  }\n}\n\ntemplate <class ELFT>\nvoid LLVMELFDumper<ELFT>::printRelrReloc(const Elf_Relr &R) {\n  W.startLine() << W.hex(R) << \"\\n\";\n}\n\ntemplate <class ELFT>\nvoid LLVMELFDumper<ELFT>::printRelRelaReloc(const Relocation<ELFT> &R,\n                                            const RelSymbol<ELFT> &RelSym) {\n  StringRef SymbolName = RelSym.Name;\n  SmallString<32> RelocName;\n  this->Obj.getRelocationTypeName(R.Type, RelocName);\n\n  if (opts::ExpandRelocs) {\n    DictScope Group(W, \"Relocation\");\n    W.printHex(\"Offset\", R.Offset);\n    W.printNumber(\"Type\", RelocName, R.Type);\n    W.printNumber(\"Symbol\", !SymbolName.empty() ? SymbolName : \"-\", R.Symbol);\n    if (R.Addend)\n      W.printHex(\"Addend\", (uintX_t)*R.Addend);\n  } else {\n    raw_ostream &OS = W.startLine();\n    OS << W.hex(R.Offset) << \" \" << RelocName << \" \"\n       << (!SymbolName.empty() ? SymbolName : \"-\");\n    if (R.Addend)\n      OS << \" \" << W.hex((uintX_t)*R.Addend);\n    OS << \"\\n\";\n  }\n}\n\ntemplate <class ELFT> void LLVMELFDumper<ELFT>::printSectionHeaders() {\n  ListScope SectionsD(W, \"Sections\");\n\n  int SectionIndex = -1;\n  std::vector<EnumEntry<unsigned>> FlagsList =\n      getSectionFlagsForTarget(this->Obj.getHeader().e_machine);\n  for (const Elf_Shdr &Sec : cantFail(this->Obj.sections())) {\n    DictScope SectionD(W, \"Section\");\n    W.printNumber(\"Index\", ++SectionIndex);\n    W.printNumber(\"Name\", this->getPrintableSectionName(Sec), Sec.sh_name);\n    W.printHex(\"Type\",\n               object::getELFSectionTypeName(this->Obj.getHeader().e_machine,\n                                             Sec.sh_type),\n               Sec.sh_type);\n    W.printFlags(\"Flags\", Sec.sh_flags, makeArrayRef(FlagsList));\n    W.printHex(\"Address\", Sec.sh_addr);\n    W.printHex(\"Offset\", Sec.sh_offset);\n    W.printNumber(\"Size\", Sec.sh_size);\n    W.printNumber(\"Link\", Sec.sh_link);\n    W.printNumber(\"Info\", Sec.sh_info);\n    W.printNumber(\"AddressAlignment\", Sec.sh_addralign);\n    W.printNumber(\"EntrySize\", Sec.sh_entsize);\n\n    if (opts::SectionRelocations) {\n      ListScope D(W, \"Relocations\");\n      this->printRelocationsHelper(Sec);\n    }\n\n    if (opts::SectionSymbols) {\n      ListScope D(W, \"Symbols\");\n      if (this->DotSymtabSec) {\n        StringRef StrTable = unwrapOrError(\n            this->FileName,\n            this->Obj.getStringTableForSymtab(*this->DotSymtabSec));\n        ArrayRef<Elf_Word> ShndxTable = this->getShndxTable(this->DotSymtabSec);\n\n        typename ELFT::SymRange Symbols = unwrapOrError(\n            this->FileName, this->Obj.symbols(this->DotSymtabSec));\n        for (const Elf_Sym &Sym : Symbols) {\n          const Elf_Shdr *SymSec = unwrapOrError(\n              this->FileName,\n              this->Obj.getSection(Sym, this->DotSymtabSec, ShndxTable));\n          if (SymSec == &Sec)\n            printSymbol(Sym, &Sym - &Symbols[0], ShndxTable, StrTable, false,\n                        false);\n        }\n      }\n    }\n\n    if (opts::SectionData && Sec.sh_type != ELF::SHT_NOBITS) {\n      ArrayRef<uint8_t> Data =\n          unwrapOrError(this->FileName, this->Obj.getSectionContents(Sec));\n      W.printBinaryBlock(\n          \"SectionData\",\n          StringRef(reinterpret_cast<const char *>(Data.data()), Data.size()));\n    }\n  }\n}\n\ntemplate <class ELFT>\nvoid LLVMELFDumper<ELFT>::printSymbolSection(\n    const Elf_Sym &Symbol, unsigned SymIndex,\n    DataRegion<Elf_Word> ShndxTable) const {\n  auto GetSectionSpecialType = [&]() -> Optional<StringRef> {\n    if (Symbol.isUndefined())\n      return StringRef(\"Undefined\");\n    if (Symbol.isProcessorSpecific())\n      return StringRef(\"Processor Specific\");\n    if (Symbol.isOSSpecific())\n      return StringRef(\"Operating System Specific\");\n    if (Symbol.isAbsolute())\n      return StringRef(\"Absolute\");\n    if (Symbol.isCommon())\n      return StringRef(\"Common\");\n    if (Symbol.isReserved() && Symbol.st_shndx != SHN_XINDEX)\n      return StringRef(\"Reserved\");\n    return None;\n  };\n\n  if (Optional<StringRef> Type = GetSectionSpecialType()) {\n    W.printHex(\"Section\", *Type, Symbol.st_shndx);\n    return;\n  }\n\n  Expected<unsigned> SectionIndex =\n      this->getSymbolSectionIndex(Symbol, SymIndex, ShndxTable);\n  if (!SectionIndex) {\n    assert(Symbol.st_shndx == SHN_XINDEX &&\n           \"getSymbolSectionIndex should only fail due to an invalid \"\n           \"SHT_SYMTAB_SHNDX table/reference\");\n    this->reportUniqueWarning(SectionIndex.takeError());\n    W.printHex(\"Section\", \"Reserved\", SHN_XINDEX);\n    return;\n  }\n\n  Expected<StringRef> SectionName =\n      this->getSymbolSectionName(Symbol, *SectionIndex);\n  if (!SectionName) {\n    // Don't report an invalid section name if the section headers are missing.\n    // In such situations, all sections will be \"invalid\".\n    if (!this->ObjF.sections().empty())\n      this->reportUniqueWarning(SectionName.takeError());\n    else\n      consumeError(SectionName.takeError());\n    W.printHex(\"Section\", \"<?>\", *SectionIndex);\n  } else {\n    W.printHex(\"Section\", *SectionName, *SectionIndex);\n  }\n}\n\ntemplate <class ELFT>\nvoid LLVMELFDumper<ELFT>::printSymbol(const Elf_Sym &Symbol, unsigned SymIndex,\n                                      DataRegion<Elf_Word> ShndxTable,\n                                      Optional<StringRef> StrTable,\n                                      bool IsDynamic,\n                                      bool /*NonVisibilityBitsUsed*/) const {\n  std::string FullSymbolName = this->getFullSymbolName(\n      Symbol, SymIndex, ShndxTable, StrTable, IsDynamic);\n  unsigned char SymbolType = Symbol.getType();\n\n  DictScope D(W, \"Symbol\");\n  W.printNumber(\"Name\", FullSymbolName, Symbol.st_name);\n  W.printHex(\"Value\", Symbol.st_value);\n  W.printNumber(\"Size\", Symbol.st_size);\n  W.printEnum(\"Binding\", Symbol.getBinding(), makeArrayRef(ElfSymbolBindings));\n  if (this->Obj.getHeader().e_machine == ELF::EM_AMDGPU &&\n      SymbolType >= ELF::STT_LOOS && SymbolType < ELF::STT_HIOS)\n    W.printEnum(\"Type\", SymbolType, makeArrayRef(AMDGPUSymbolTypes));\n  else\n    W.printEnum(\"Type\", SymbolType, makeArrayRef(ElfSymbolTypes));\n  if (Symbol.st_other == 0)\n    // Usually st_other flag is zero. Do not pollute the output\n    // by flags enumeration in that case.\n    W.printNumber(\"Other\", 0);\n  else {\n    std::vector<EnumEntry<unsigned>> SymOtherFlags(std::begin(ElfSymOtherFlags),\n                                                   std::end(ElfSymOtherFlags));\n    if (this->Obj.getHeader().e_machine == EM_MIPS) {\n      // Someones in their infinite wisdom decided to make STO_MIPS_MIPS16\n      // flag overlapped with other ST_MIPS_xxx flags. So consider both\n      // cases separately.\n      if ((Symbol.st_other & STO_MIPS_MIPS16) == STO_MIPS_MIPS16)\n        SymOtherFlags.insert(SymOtherFlags.end(),\n                             std::begin(ElfMips16SymOtherFlags),\n                             std::end(ElfMips16SymOtherFlags));\n      else\n        SymOtherFlags.insert(SymOtherFlags.end(),\n                             std::begin(ElfMipsSymOtherFlags),\n                             std::end(ElfMipsSymOtherFlags));\n    } else if (this->Obj.getHeader().e_machine == EM_AARCH64) {\n      SymOtherFlags.insert(SymOtherFlags.end(),\n                           std::begin(ElfAArch64SymOtherFlags),\n                           std::end(ElfAArch64SymOtherFlags));\n    }\n    W.printFlags(\"Other\", Symbol.st_other, makeArrayRef(SymOtherFlags), 0x3u);\n  }\n  printSymbolSection(Symbol, SymIndex, ShndxTable);\n}\n\ntemplate <class ELFT>\nvoid LLVMELFDumper<ELFT>::printSymbols(bool PrintSymbols,\n                                       bool PrintDynamicSymbols) {\n  if (PrintSymbols) {\n    ListScope Group(W, \"Symbols\");\n    this->printSymbolsHelper(false);\n  }\n  if (PrintDynamicSymbols) {\n    ListScope Group(W, \"DynamicSymbols\");\n    this->printSymbolsHelper(true);\n  }\n}\n\ntemplate <class ELFT> void LLVMELFDumper<ELFT>::printDynamicTable() {\n  Elf_Dyn_Range Table = this->dynamic_table();\n  if (Table.empty())\n    return;\n\n  W.startLine() << \"DynamicSection [ (\" << Table.size() << \" entries)\\n\";\n\n  size_t MaxTagSize = getMaxDynamicTagSize(this->Obj, Table);\n  // The \"Name/Value\" column should be indented from the \"Type\" column by N\n  // spaces, where N = MaxTagSize - length of \"Type\" (4) + trailing\n  // space (1) = -3.\n  W.startLine() << \"  Tag\" << std::string(ELFT::Is64Bits ? 16 : 8, ' ')\n                << \"Type\" << std::string(MaxTagSize - 3, ' ') << \"Name/Value\\n\";\n\n  std::string ValueFmt = \"%-\" + std::to_string(MaxTagSize) + \"s \";\n  for (auto Entry : Table) {\n    uintX_t Tag = Entry.getTag();\n    std::string Value = this->getDynamicEntry(Tag, Entry.getVal());\n    W.startLine() << \"  \" << format_hex(Tag, ELFT::Is64Bits ? 18 : 10, true)\n                  << \" \"\n                  << format(ValueFmt.c_str(),\n                            this->Obj.getDynamicTagAsString(Tag).c_str())\n                  << Value << \"\\n\";\n  }\n  W.startLine() << \"]\\n\";\n}\n\ntemplate <class ELFT> void LLVMELFDumper<ELFT>::printDynamicRelocations() {\n  W.startLine() << \"Dynamic Relocations {\\n\";\n  W.indent();\n  this->printDynamicRelocationsHelper();\n  W.unindent();\n  W.startLine() << \"}\\n\";\n}\n\ntemplate <class ELFT>\nvoid LLVMELFDumper<ELFT>::printProgramHeaders(\n    bool PrintProgramHeaders, cl::boolOrDefault PrintSectionMapping) {\n  if (PrintProgramHeaders)\n    printProgramHeaders();\n  if (PrintSectionMapping == cl::BOU_TRUE)\n    printSectionMapping();\n}\n\ntemplate <class ELFT> void LLVMELFDumper<ELFT>::printProgramHeaders() {\n  ListScope L(W, \"ProgramHeaders\");\n\n  Expected<ArrayRef<Elf_Phdr>> PhdrsOrErr = this->Obj.program_headers();\n  if (!PhdrsOrErr) {\n    this->reportUniqueWarning(\"unable to dump program headers: \" +\n                              toString(PhdrsOrErr.takeError()));\n    return;\n  }\n\n  for (const Elf_Phdr &Phdr : *PhdrsOrErr) {\n    DictScope P(W, \"ProgramHeader\");\n    StringRef Type =\n        segmentTypeToString(this->Obj.getHeader().e_machine, Phdr.p_type);\n\n    W.printHex(\"Type\", Type.empty() ? \"Unknown\" : Type, Phdr.p_type);\n    W.printHex(\"Offset\", Phdr.p_offset);\n    W.printHex(\"VirtualAddress\", Phdr.p_vaddr);\n    W.printHex(\"PhysicalAddress\", Phdr.p_paddr);\n    W.printNumber(\"FileSize\", Phdr.p_filesz);\n    W.printNumber(\"MemSize\", Phdr.p_memsz);\n    W.printFlags(\"Flags\", Phdr.p_flags, makeArrayRef(ElfSegmentFlags));\n    W.printNumber(\"Alignment\", Phdr.p_align);\n  }\n}\n\ntemplate <class ELFT>\nvoid LLVMELFDumper<ELFT>::printVersionSymbolSection(const Elf_Shdr *Sec) {\n  ListScope SS(W, \"VersionSymbols\");\n  if (!Sec)\n    return;\n\n  StringRef StrTable;\n  ArrayRef<Elf_Sym> Syms;\n  const Elf_Shdr *SymTabSec;\n  Expected<ArrayRef<Elf_Versym>> VerTableOrErr =\n      this->getVersionTable(*Sec, &Syms, &StrTable, &SymTabSec);\n  if (!VerTableOrErr) {\n    this->reportUniqueWarning(VerTableOrErr.takeError());\n    return;\n  }\n\n  if (StrTable.empty() || Syms.empty() || Syms.size() != VerTableOrErr->size())\n    return;\n\n  ArrayRef<Elf_Word> ShNdxTable = this->getShndxTable(SymTabSec);\n  for (size_t I = 0, E = Syms.size(); I < E; ++I) {\n    DictScope S(W, \"Symbol\");\n    W.printNumber(\"Version\", (*VerTableOrErr)[I].vs_index & VERSYM_VERSION);\n    W.printString(\"Name\",\n                  this->getFullSymbolName(Syms[I], I, ShNdxTable, StrTable,\n                                          /*IsDynamic=*/true));\n  }\n}\n\nstatic const EnumEntry<unsigned> SymVersionFlags[] = {\n    {\"Base\", \"BASE\", VER_FLG_BASE},\n    {\"Weak\", \"WEAK\", VER_FLG_WEAK},\n    {\"Info\", \"INFO\", VER_FLG_INFO}};\n\ntemplate <class ELFT>\nvoid LLVMELFDumper<ELFT>::printVersionDefinitionSection(const Elf_Shdr *Sec) {\n  ListScope SD(W, \"VersionDefinitions\");\n  if (!Sec)\n    return;\n\n  Expected<std::vector<VerDef>> V = this->Obj.getVersionDefinitions(*Sec);\n  if (!V) {\n    this->reportUniqueWarning(V.takeError());\n    return;\n  }\n\n  for (const VerDef &D : *V) {\n    DictScope Def(W, \"Definition\");\n    W.printNumber(\"Version\", D.Version);\n    W.printFlags(\"Flags\", D.Flags, makeArrayRef(SymVersionFlags));\n    W.printNumber(\"Index\", D.Ndx);\n    W.printNumber(\"Hash\", D.Hash);\n    W.printString(\"Name\", D.Name.c_str());\n    W.printList(\n        \"Predecessors\", D.AuxV,\n        [](raw_ostream &OS, const VerdAux &Aux) { OS << Aux.Name.c_str(); });\n  }\n}\n\ntemplate <class ELFT>\nvoid LLVMELFDumper<ELFT>::printVersionDependencySection(const Elf_Shdr *Sec) {\n  ListScope SD(W, \"VersionRequirements\");\n  if (!Sec)\n    return;\n\n  Expected<std::vector<VerNeed>> V =\n      this->Obj.getVersionDependencies(*Sec, this->WarningHandler);\n  if (!V) {\n    this->reportUniqueWarning(V.takeError());\n    return;\n  }\n\n  for (const VerNeed &VN : *V) {\n    DictScope Entry(W, \"Dependency\");\n    W.printNumber(\"Version\", VN.Version);\n    W.printNumber(\"Count\", VN.Cnt);\n    W.printString(\"FileName\", VN.File.c_str());\n\n    ListScope L(W, \"Entries\");\n    for (const VernAux &Aux : VN.AuxV) {\n      DictScope Entry(W, \"Entry\");\n      W.printNumber(\"Hash\", Aux.Hash);\n      W.printFlags(\"Flags\", Aux.Flags, makeArrayRef(SymVersionFlags));\n      W.printNumber(\"Index\", Aux.Other);\n      W.printString(\"Name\", Aux.Name.c_str());\n    }\n  }\n}\n\ntemplate <class ELFT> void LLVMELFDumper<ELFT>::printHashHistograms() {\n  W.startLine() << \"Hash Histogram not implemented!\\n\";\n}\n\ntemplate <class ELFT> void LLVMELFDumper<ELFT>::printCGProfile() {\n  ListScope L(W, \"CGProfile\");\n  if (!this->DotCGProfileSec)\n    return;\n\n  Expected<ArrayRef<Elf_CGProfile>> CGProfileOrErr =\n      this->Obj.template getSectionContentsAsArray<Elf_CGProfile>(\n          *this->DotCGProfileSec);\n  if (!CGProfileOrErr) {\n    this->reportUniqueWarning(\n        \"unable to dump the SHT_LLVM_CALL_GRAPH_PROFILE section: \" +\n        toString(CGProfileOrErr.takeError()));\n    return;\n  }\n\n  for (const Elf_CGProfile &CGPE : *CGProfileOrErr) {\n    DictScope D(W, \"CGProfileEntry\");\n    W.printNumber(\"From\", this->getStaticSymbolName(CGPE.cgp_from),\n                  CGPE.cgp_from);\n    W.printNumber(\"To\", this->getStaticSymbolName(CGPE.cgp_to),\n                  CGPE.cgp_to);\n    W.printNumber(\"Weight\", CGPE.cgp_weight);\n  }\n}\n\ntemplate <class ELFT> void LLVMELFDumper<ELFT>::printAddrsig() {\n  ListScope L(W, \"Addrsig\");\n  if (!this->DotAddrsigSec)\n    return;\n\n  Expected<std::vector<uint64_t>> SymsOrErr =\n      decodeAddrsigSection(this->Obj, *this->DotAddrsigSec);\n  if (!SymsOrErr) {\n    this->reportUniqueWarning(SymsOrErr.takeError());\n    return;\n  }\n\n  for (uint64_t Sym : *SymsOrErr)\n    W.printNumber(\"Sym\", this->getStaticSymbolName(Sym), Sym);\n}\n\ntemplate <typename ELFT>\nstatic bool printGNUNoteLLVMStyle(uint32_t NoteType, ArrayRef<uint8_t> Desc,\n                                  ScopedPrinter &W) {\n  // Return true if we were able to pretty-print the note, false otherwise.\n  switch (NoteType) {\n  default:\n    return false;\n  case ELF::NT_GNU_ABI_TAG: {\n    const GNUAbiTag &AbiTag = getGNUAbiTag<ELFT>(Desc);\n    if (!AbiTag.IsValid) {\n      W.printString(\"ABI\", \"<corrupt GNU_ABI_TAG>\");\n      return false;\n    } else {\n      W.printString(\"OS\", AbiTag.OSName);\n      W.printString(\"ABI\", AbiTag.ABI);\n    }\n    break;\n  }\n  case ELF::NT_GNU_BUILD_ID: {\n    W.printString(\"Build ID\", getGNUBuildId(Desc));\n    break;\n  }\n  case ELF::NT_GNU_GOLD_VERSION:\n    W.printString(\"Version\", getGNUGoldVersion(Desc));\n    break;\n  case ELF::NT_GNU_PROPERTY_TYPE_0:\n    ListScope D(W, \"Property\");\n    for (const std::string &Property : getGNUPropertyList<ELFT>(Desc))\n      W.printString(Property);\n    break;\n  }\n  return true;\n}\n\nstatic void printCoreNoteLLVMStyle(const CoreNote &Note, ScopedPrinter &W) {\n  W.printNumber(\"Page Size\", Note.PageSize);\n  for (const CoreFileMapping &Mapping : Note.Mappings) {\n    ListScope D(W, \"Mapping\");\n    W.printHex(\"Start\", Mapping.Start);\n    W.printHex(\"End\", Mapping.End);\n    W.printHex(\"Offset\", Mapping.Offset);\n    W.printString(\"Filename\", Mapping.Filename);\n  }\n}\n\ntemplate <class ELFT> void LLVMELFDumper<ELFT>::printNotes() {\n  ListScope L(W, \"Notes\");\n\n  std::unique_ptr<DictScope> NoteScope;\n  auto StartNotes = [&](Optional<StringRef> SecName,\n                        const typename ELFT::Off Offset,\n                        const typename ELFT::Addr Size) {\n    NoteScope = std::make_unique<DictScope>(W, \"NoteSection\");\n    W.printString(\"Name\", SecName ? *SecName : \"<?>\");\n    W.printHex(\"Offset\", Offset);\n    W.printHex(\"Size\", Size);\n  };\n\n  auto EndNotes = [&] { NoteScope.reset(); };\n\n  auto ProcessNote = [&](const Elf_Note &Note, bool IsCore) -> Error {\n    DictScope D2(W, \"Note\");\n    StringRef Name = Note.getName();\n    ArrayRef<uint8_t> Descriptor = Note.getDesc();\n    Elf_Word Type = Note.getType();\n\n    // Print the note owner/type.\n    W.printString(\"Owner\", Name);\n    W.printHex(\"Data size\", Descriptor.size());\n\n    StringRef NoteType =\n        getNoteTypeName<ELFT>(Note, this->Obj.getHeader().e_type);\n    if (!NoteType.empty())\n      W.printString(\"Type\", NoteType);\n    else\n      W.printString(\"Type\",\n                    \"Unknown (\" + to_string(format_hex(Type, 10)) + \")\");\n\n    // Print the description, or fallback to printing raw bytes for unknown\n    // owners/if we fail to pretty-print the contents.\n    if (Name == \"GNU\") {\n      if (printGNUNoteLLVMStyle<ELFT>(Type, Descriptor, W))\n        return Error::success();\n    } else if (Name == \"FreeBSD\") {\n      if (Optional<FreeBSDNote> N =\n              getFreeBSDNote<ELFT>(Type, Descriptor, IsCore)) {\n        W.printString(N->Type, N->Value);\n        return Error::success();\n      }\n    } else if (Name == \"AMD\") {\n      const AMDNote N = getAMDNote<ELFT>(Type, Descriptor);\n      if (!N.Type.empty()) {\n        W.printString(N.Type, N.Value);\n        return Error::success();\n      }\n    } else if (Name == \"AMDGPU\") {\n      const AMDGPUNote N = getAMDGPUNote<ELFT>(Type, Descriptor);\n      if (!N.Type.empty()) {\n        W.printString(N.Type, N.Value);\n        return Error::success();\n      }\n    } else if (Name == \"CORE\") {\n      if (Type == ELF::NT_FILE) {\n        DataExtractor DescExtractor(Descriptor,\n                                    ELFT::TargetEndianness == support::little,\n                                    sizeof(Elf_Addr));\n        if (Expected<CoreNote> N = readCoreNote(DescExtractor)) {\n          printCoreNoteLLVMStyle(*N, W);\n          return Error::success();\n        } else {\n          return N.takeError();\n        }\n      }\n    }\n    if (!Descriptor.empty()) {\n      W.printBinaryBlock(\"Description data\", Descriptor);\n    }\n    return Error::success();\n  };\n\n  printNotesHelper(*this, StartNotes, ProcessNote, EndNotes);\n}\n\ntemplate <class ELFT> void LLVMELFDumper<ELFT>::printELFLinkerOptions() {\n  ListScope L(W, \"LinkerOptions\");\n\n  unsigned I = -1;\n  for (const Elf_Shdr &Shdr : cantFail(this->Obj.sections())) {\n    ++I;\n    if (Shdr.sh_type != ELF::SHT_LLVM_LINKER_OPTIONS)\n      continue;\n\n    Expected<ArrayRef<uint8_t>> ContentsOrErr =\n        this->Obj.getSectionContents(Shdr);\n    if (!ContentsOrErr) {\n      this->reportUniqueWarning(\"unable to read the content of the \"\n                                \"SHT_LLVM_LINKER_OPTIONS section: \" +\n                                toString(ContentsOrErr.takeError()));\n      continue;\n    }\n    if (ContentsOrErr->empty())\n      continue;\n\n    if (ContentsOrErr->back() != 0) {\n      this->reportUniqueWarning(\"SHT_LLVM_LINKER_OPTIONS section at index \" +\n                                Twine(I) +\n                                \" is broken: the \"\n                                \"content is not null-terminated\");\n      continue;\n    }\n\n    SmallVector<StringRef, 16> Strings;\n    toStringRef(ContentsOrErr->drop_back()).split(Strings, '\\0');\n    if (Strings.size() % 2 != 0) {\n      this->reportUniqueWarning(\n          \"SHT_LLVM_LINKER_OPTIONS section at index \" + Twine(I) +\n          \" is broken: an incomplete \"\n          \"key-value pair was found. The last possible key was: \\\"\" +\n          Strings.back() + \"\\\"\");\n      continue;\n    }\n\n    for (size_t I = 0; I < Strings.size(); I += 2)\n      W.printString(Strings[I], Strings[I + 1]);\n  }\n}\n\ntemplate <class ELFT> void LLVMELFDumper<ELFT>::printDependentLibs() {\n  ListScope L(W, \"DependentLibs\");\n  this->printDependentLibsHelper(\n      [](const Elf_Shdr &) {},\n      [this](StringRef Lib, uint64_t) { W.printString(Lib); });\n}\n\ntemplate <class ELFT> void LLVMELFDumper<ELFT>::printStackSizes() {\n  ListScope L(W, \"StackSizes\");\n  if (this->Obj.getHeader().e_type == ELF::ET_REL)\n    this->printRelocatableStackSizes([]() {});\n  else\n    this->printNonRelocatableStackSizes([]() {});\n}\n\ntemplate <class ELFT>\nvoid LLVMELFDumper<ELFT>::printStackSizeEntry(uint64_t Size, StringRef FuncName) {\n  DictScope D(W, \"Entry\");\n  W.printString(\"Function\", FuncName);\n  W.printHex(\"Size\", Size);\n}\n\ntemplate <class ELFT>\nvoid LLVMELFDumper<ELFT>::printMipsGOT(const MipsGOTParser<ELFT> &Parser) {\n  auto PrintEntry = [&](const Elf_Addr *E) {\n    W.printHex(\"Address\", Parser.getGotAddress(E));\n    W.printNumber(\"Access\", Parser.getGotOffset(E));\n    W.printHex(\"Initial\", *E);\n  };\n\n  DictScope GS(W, Parser.IsStatic ? \"Static GOT\" : \"Primary GOT\");\n\n  W.printHex(\"Canonical gp value\", Parser.getGp());\n  {\n    ListScope RS(W, \"Reserved entries\");\n    {\n      DictScope D(W, \"Entry\");\n      PrintEntry(Parser.getGotLazyResolver());\n      W.printString(\"Purpose\", StringRef(\"Lazy resolver\"));\n    }\n\n    if (Parser.getGotModulePointer()) {\n      DictScope D(W, \"Entry\");\n      PrintEntry(Parser.getGotModulePointer());\n      W.printString(\"Purpose\", StringRef(\"Module pointer (GNU extension)\"));\n    }\n  }\n  {\n    ListScope LS(W, \"Local entries\");\n    for (auto &E : Parser.getLocalEntries()) {\n      DictScope D(W, \"Entry\");\n      PrintEntry(&E);\n    }\n  }\n\n  if (Parser.IsStatic)\n    return;\n\n  {\n    ListScope GS(W, \"Global entries\");\n    for (auto &E : Parser.getGlobalEntries()) {\n      DictScope D(W, \"Entry\");\n\n      PrintEntry(&E);\n\n      const Elf_Sym &Sym = *Parser.getGotSym(&E);\n      W.printHex(\"Value\", Sym.st_value);\n      W.printEnum(\"Type\", Sym.getType(), makeArrayRef(ElfSymbolTypes));\n\n      const unsigned SymIndex = &Sym - this->dynamic_symbols().begin();\n      DataRegion<Elf_Word> ShndxTable(\n          (const Elf_Word *)this->DynSymTabShndxRegion.Addr, this->Obj.end());\n      printSymbolSection(Sym, SymIndex, ShndxTable);\n\n      std::string SymName = this->getFullSymbolName(\n          Sym, SymIndex, ShndxTable, this->DynamicStringTable, true);\n      W.printNumber(\"Name\", SymName, Sym.st_name);\n    }\n  }\n\n  W.printNumber(\"Number of TLS and multi-GOT entries\",\n                uint64_t(Parser.getOtherEntries().size()));\n}\n\ntemplate <class ELFT>\nvoid LLVMELFDumper<ELFT>::printMipsPLT(const MipsGOTParser<ELFT> &Parser) {\n  auto PrintEntry = [&](const Elf_Addr *E) {\n    W.printHex(\"Address\", Parser.getPltAddress(E));\n    W.printHex(\"Initial\", *E);\n  };\n\n  DictScope GS(W, \"PLT GOT\");\n\n  {\n    ListScope RS(W, \"Reserved entries\");\n    {\n      DictScope D(W, \"Entry\");\n      PrintEntry(Parser.getPltLazyResolver());\n      W.printString(\"Purpose\", StringRef(\"PLT lazy resolver\"));\n    }\n\n    if (auto E = Parser.getPltModulePointer()) {\n      DictScope D(W, \"Entry\");\n      PrintEntry(E);\n      W.printString(\"Purpose\", StringRef(\"Module pointer\"));\n    }\n  }\n  {\n    ListScope LS(W, \"Entries\");\n    DataRegion<Elf_Word> ShndxTable(\n        (const Elf_Word *)this->DynSymTabShndxRegion.Addr, this->Obj.end());\n    for (auto &E : Parser.getPltEntries()) {\n      DictScope D(W, \"Entry\");\n      PrintEntry(&E);\n\n      const Elf_Sym &Sym = *Parser.getPltSym(&E);\n      W.printHex(\"Value\", Sym.st_value);\n      W.printEnum(\"Type\", Sym.getType(), makeArrayRef(ElfSymbolTypes));\n      printSymbolSection(Sym, &Sym - this->dynamic_symbols().begin(),\n                         ShndxTable);\n\n      const Elf_Sym *FirstSym = cantFail(\n          this->Obj.template getEntry<Elf_Sym>(*Parser.getPltSymTable(), 0));\n      std::string SymName = this->getFullSymbolName(\n          Sym, &Sym - FirstSym, ShndxTable, Parser.getPltStrTable(), true);\n      W.printNumber(\"Name\", SymName, Sym.st_name);\n    }\n  }\n}\n\ntemplate <class ELFT> void LLVMELFDumper<ELFT>::printMipsABIFlags() {\n  const Elf_Mips_ABIFlags<ELFT> *Flags;\n  if (Expected<const Elf_Mips_ABIFlags<ELFT> *> SecOrErr =\n          getMipsAbiFlagsSection(*this)) {\n    Flags = *SecOrErr;\n    if (!Flags) {\n      W.startLine() << \"There is no .MIPS.abiflags section in the file.\\n\";\n      return;\n    }\n  } else {\n    this->reportUniqueWarning(SecOrErr.takeError());\n    return;\n  }\n\n  raw_ostream &OS = W.getOStream();\n  DictScope GS(W, \"MIPS ABI Flags\");\n\n  W.printNumber(\"Version\", Flags->version);\n  W.startLine() << \"ISA: \";\n  if (Flags->isa_rev <= 1)\n    OS << format(\"MIPS%u\", Flags->isa_level);\n  else\n    OS << format(\"MIPS%ur%u\", Flags->isa_level, Flags->isa_rev);\n  OS << \"\\n\";\n  W.printEnum(\"ISA Extension\", Flags->isa_ext, makeArrayRef(ElfMipsISAExtType));\n  W.printFlags(\"ASEs\", Flags->ases, makeArrayRef(ElfMipsASEFlags));\n  W.printEnum(\"FP ABI\", Flags->fp_abi, makeArrayRef(ElfMipsFpABIType));\n  W.printNumber(\"GPR size\", getMipsRegisterSize(Flags->gpr_size));\n  W.printNumber(\"CPR1 size\", getMipsRegisterSize(Flags->cpr1_size));\n  W.printNumber(\"CPR2 size\", getMipsRegisterSize(Flags->cpr2_size));\n  W.printFlags(\"Flags 1\", Flags->flags1, makeArrayRef(ElfMipsFlags1));\n  W.printHex(\"Flags 2\", Flags->flags2);\n}\n"}}, "reports": [{"events": [{"location": {"col": 21, "file": 4, "line": 396}, "message": "the definition seen here"}, {"location": {"col": 19, "file": 4, "line": 346}, "message": "differing parameters are named here: ('IndexTableIndex'), in definition: ('IndexSectionIndex')"}, {"location": {"col": 19, "file": 4, "line": 346}, "message": "function 'llvm::ARM::EHABI::PrinterContext::FindExceptionTable' has a definition with different parameter names"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/tools/llvm-readobj/ARMEHABIPrinter.h", "reportHash": "51e3853e6b74dfeaa9e3f2281347c20f", "checkerName": "readability-inconsistent-declaration-parameter-name", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 26, "file": 5, "line": 3560}, "message": "the definition seen here"}, {"location": {"col": 8, "file": 5, "line": 544}, "message": "differing parameters are named here: ('Offset'), in definition: ('Entries')"}, {"location": {"col": 8, "file": 5, "line": 544}, "message": "function '(anonymous namespace)::GNUELFDumper::printSymtabMessage' has a definition with different parameter names"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/tools/llvm-readobj/ELFDumper.cpp", "reportHash": "0b1c00d52353e2e8519e9bc8448db81f", "checkerName": "readability-inconsistent-declaration-parameter-name", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 26, "file": 5, "line": 3727}, "message": "the definition seen here"}, {"location": {"col": 8, "file": 5, "line": 561}, "message": "differing parameters are named here: ('HashTable'), in definition: ('SysVHash')"}, {"location": {"col": 8, "file": 5, "line": 561}, "message": "function '(anonymous namespace)::GNUELFDumper::printHashTableSymbols' has a definition with different parameter names"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/tools/llvm-readobj/ELFDumper.cpp", "reportHash": "9d5277677ab2830d1e63f57f2a9bcd19", "checkerName": "readability-inconsistent-declaration-parameter-name", "reviewStatus": null, "severity": "STYLE"}]};
      window.onload = function() {
        if (!browserCompatible) {
          setNonCompatibleBrowserMessage();
        } else {
          BugViewer.init(data.files, data.reports);
          BugViewer.create();
          BugViewer.initByUrl();
        }
      };
    </script>
  </head>
  <body>
  <div class="container">
    <div id="content">
      <div id="side-bar">
        <div class="header">
          <a href="index.html" class="button">&#8249; Return to List</a>
        </div>
        <div id="report-nav">
          <div class="header">Reports</div>
        </div>
      </div>
      <div id="editor-wrapper">
        <div class="header">
          <div id="file">
            <span class="label">File:</span>
            <span id="file-path"></span>
          </div>
          <div id="checker">
            <span class="label">Checker name:</span>
            <span id="checker-name"></span>
          </div>
          <div id="review-status-wrapper">
            <span class="label">Review status:</span>
            <span id="review-status"></span>
          </div>
        </div>
        <div id="editor"></div>
      </div>
    </div>
  </div>
  </body>
</html>
