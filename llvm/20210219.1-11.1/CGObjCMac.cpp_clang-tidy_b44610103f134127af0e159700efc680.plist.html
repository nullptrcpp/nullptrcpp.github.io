<!DOCTYPE html>
<html>
  <head>
    <title>Plist HTML Viewer</title>

    <meta charset="UTF-8">

    <style type="text/css">
      .CodeMirror{font-family:monospace;height:300px;color:#000;direction:ltr}.CodeMirror-lines{padding:4px 0}.CodeMirror pre{padding:0 4px}.CodeMirror-gutter-filler,.CodeMirror-scrollbar-filler{background-color:#fff}.CodeMirror-gutters{border-right:1px solid #ddd;background-color:#f7f7f7;white-space:nowrap}.CodeMirror-linenumber{padding:0 3px 0 5px;min-width:20px;text-align:right;color:#999;white-space:nowrap}.CodeMirror-guttermarker{color:#000}.CodeMirror-guttermarker-subtle{color:#999}.CodeMirror-cursor{border-left:1px solid #000;border-right:none;width:0}.CodeMirror div.CodeMirror-secondarycursor{border-left:1px solid silver}.cm-fat-cursor .CodeMirror-cursor{width:auto;border:0!important;background:#7e7}.cm-fat-cursor div.CodeMirror-cursors{z-index:1}.cm-animate-fat-cursor{width:auto;border:0;-webkit-animation:blink 1.06s steps(1) infinite;-moz-animation:blink 1.06s steps(1) infinite;animation:blink 1.06s steps(1) infinite;background-color:#7e7}@-moz-keyframes blink{50%{background-color:transparent}}@-webkit-keyframes blink{50%{background-color:transparent}}@keyframes blink{50%{background-color:transparent}}.cm-tab{display:inline-block;text-decoration:inherit}.CodeMirror-rulers{position:absolute;left:0;right:0;top:-50px;bottom:-20px;overflow:hidden}.CodeMirror-ruler{border-left:1px solid #ccc;top:0;bottom:0;position:absolute}.cm-s-default .cm-header{color:#00f}.cm-s-default .cm-quote{color:#090}.cm-negative{color:#d44}.cm-positive{color:#292}.cm-header,.cm-strong{font-weight:700}.cm-em{font-style:italic}.cm-link{text-decoration:underline}.cm-strikethrough{text-decoration:line-through}.cm-s-default .cm-keyword{color:#708}.cm-s-default .cm-atom{color:#219}.cm-s-default .cm-number{color:#164}.cm-s-default .cm-def{color:#00f}.cm-s-default .cm-variable-2{color:#05a}.cm-s-default .cm-type,.cm-s-default .cm-variable-3{color:#085}.cm-s-default .cm-comment{color:#a50}.cm-s-default .cm-string{color:#a11}.cm-s-default .cm-string-2{color:#f50}.cm-s-default .cm-meta{color:#555}.cm-s-default .cm-qualifier{color:#555}.cm-s-default .cm-builtin{color:#30a}.cm-s-default .cm-bracket{color:#997}.cm-s-default .cm-tag{color:#170}.cm-s-default .cm-attribute{color:#00c}.cm-s-default .cm-hr{color:#999}.cm-s-default .cm-link{color:#00c}.cm-s-default .cm-error{color:red}.cm-invalidchar{color:red}.CodeMirror-composing{border-bottom:2px solid}div.CodeMirror span.CodeMirror-matchingbracket{color:#0f0}div.CodeMirror span.CodeMirror-nonmatchingbracket{color:#f22}.CodeMirror-matchingtag{background:rgba(255,150,0,.3)}.CodeMirror-activeline-background{background:#e8f2ff}.CodeMirror{position:relative;overflow:hidden;background:#fff}.CodeMirror-scroll{overflow:scroll!important;margin-bottom:-30px;margin-right:-30px;padding-bottom:30px;height:100%;outline:0;position:relative}.CodeMirror-sizer{position:relative;border-right:30px solid transparent}.CodeMirror-gutter-filler,.CodeMirror-hscrollbar,.CodeMirror-scrollbar-filler,.CodeMirror-vscrollbar{position:absolute;z-index:6;display:none}.CodeMirror-vscrollbar{right:0;top:0;overflow-x:hidden;overflow-y:scroll}.CodeMirror-hscrollbar{bottom:0;left:0;overflow-y:hidden;overflow-x:scroll}.CodeMirror-scrollbar-filler{right:0;bottom:0}.CodeMirror-gutter-filler{left:0;bottom:0}.CodeMirror-gutters{position:absolute;left:0;top:0;min-height:100%;z-index:3}.CodeMirror-gutter{white-space:normal;height:100%;display:inline-block;vertical-align:top;margin-bottom:-30px}.CodeMirror-gutter-wrapper{position:absolute;z-index:4;background:0 0!important;border:none!important}.CodeMirror-gutter-background{position:absolute;top:0;bottom:0;z-index:4}.CodeMirror-gutter-elt{position:absolute;cursor:default;z-index:4}.CodeMirror-gutter-wrapper ::selection{background-color:transparent}.CodeMirror-gutter-wrapper ::-moz-selection{background-color:transparent}.CodeMirror-lines{cursor:text;min-height:1px}.CodeMirror pre{-moz-border-radius:0;-webkit-border-radius:0;border-radius:0;border-width:0;background:0 0;font-family:inherit;font-size:inherit;margin:0;white-space:pre;word-wrap:normal;line-height:inherit;color:inherit;z-index:2;position:relative;overflow:visible;-webkit-tap-highlight-color:transparent;-webkit-font-variant-ligatures:contextual;font-variant-ligatures:contextual}.CodeMirror-wrap pre{word-wrap:break-word;white-space:pre-wrap;word-break:normal}.CodeMirror-linebackground{position:absolute;left:0;right:0;top:0;bottom:0;z-index:0}.CodeMirror-linewidget{position:relative;z-index:2;overflow:auto}.CodeMirror-rtl pre{direction:rtl}.CodeMirror-code{outline:0}.CodeMirror-gutter,.CodeMirror-gutters,.CodeMirror-linenumber,.CodeMirror-scroll,.CodeMirror-sizer{-moz-box-sizing:content-box;box-sizing:content-box}.CodeMirror-measure{position:absolute;width:100%;height:0;overflow:hidden;visibility:hidden}.CodeMirror-cursor{position:absolute;pointer-events:none}.CodeMirror-measure pre{position:static}div.CodeMirror-cursors{visibility:hidden;position:relative;z-index:3}div.CodeMirror-dragcursors{visibility:visible}.CodeMirror-focused div.CodeMirror-cursors{visibility:visible}.CodeMirror-selected{background:#d9d9d9}.CodeMirror-focused .CodeMirror-selected{background:#d7d4f0}.CodeMirror-crosshair{cursor:crosshair}.CodeMirror-line::selection,.CodeMirror-line>span::selection,.CodeMirror-line>span>span::selection{background:#d7d4f0}.CodeMirror-line::-moz-selection,.CodeMirror-line>span::-moz-selection,.CodeMirror-line>span>span::-moz-selection{background:#d7d4f0}.cm-searching{background-color:#ffa;background-color:rgba(255,255,0,.4)}.cm-force-border{padding-right:.1px}@media print{.CodeMirror div.CodeMirror-cursors{visibility:hidden}}.cm-tab-wrap-hack:after{content:''}span.CodeMirror-selectedtext{background:0 0}
/*# sourceMappingURL=codemirror.min.css.map */

      .severity-low {
  background-color: #669603;
}

.severity-low:after {
  content : 'L';
}

.severity-unspecified {
  background-color: #666666;
}

.severity-unspecified:after {
  content : 'U';
}

.severity-style {
  background-color: #9932cc;
}

.severity-style:after {
  content : 'S';
}

.severity-medium {
  background-color: #a9d323;
  color: black;
}

.severity-medium:after {
  content : 'M';
}

.severity-high {
  background-color: #ffa800;
}

.severity-high:after {
  content : 'H';
}

.severity-critical {
  background-color: #e92625;
}

.severity-critical:after {
  content : 'C';
}

i[class*="severity-"] {
  line-height: normal;
  text-transform: capitalize;
  font-size: 0.8em;
  font-weight: bold;
  color: white;
  display: inline-block;
  width: 16px;
  height: 16px;
  text-align: center;
  font-family: sans-serif;
}

      html, body {
  width: 100%;
  height: 100%;
  padding: 0px;
  margin: 0px;
}

div.container {
  padding: 10px;
}

#content {
  height: 100%;
  display: block;
  overflow: hidden;
}

#content > div {
  margin: 10px;
  overflow: hidden;
  border: 1px solid #ddd;
  border-radius: 3px;
  overflow: hidden;
  height: 97%;
}

.button {
  background-color: #f1f1f1;
  text-decoration: none;
  display: inline-block;
  padding: 8px 16px;
  color: black;
  cursor: pointer;
}

.button:hover {
  background-color: #ddd;
  color: black;
}

.review-status {
  color: white;
  text-align: center;
}

.review-status-confirmed {
  background-color: #e92625;
}

.review-status-false-positive {
  background-color: grey;
}

.review-status-intentional {
  background-color: #669603;
}

      div.container {
  width: 100%;
  height: 100%;
  padding: 0px;
}

#editor-wrapper {
  margin: 10px;
}

#side-bar {
  float: left;
  width: 260px;
  margin: 0px;
}

#report-nav ul {
  list-style-type: none;
  padding: 0;
  margin: 0;
  overflow-y: auto;
  height: 100%;
}

#report-nav ul > li {
  padding: .4em;
  background-color: #fff;
  border-bottom: 1px solid rgba(0,0,0,.125);
  text-align: left;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

#report-nav ul > li.active {
  background-color: #427ea9;
  color: white;
}

#report-nav ul > li:hover {
  background-color: #427ea9;
  color: white;
  cursor: pointer;
}

#report-nav ul a {
  text-decoration: none;
}

#report-nav i[class*="severity-"] {
  margin-right: 5px;
}

.header {
  border-bottom: 1px solid lightgrey;
  font-family: monospace;
  padding: 10px;
  background-color: #fafbfc;
  border-bottom: 1px solid #e1e4e8;
  border-top-left-radius: 2px;
  border-top-right-radius: 2px;
}

#report-nav .header {
  font-weight: bold;
}

#editor-wrapper .header > div {
  padding-top: 2px;
}

#file-path,
#checker-name {
  color: #195ea2;
}

#review-status {
  padding: 0px 5px;
}

#file-path {
  font-family: monospace;
}

.check-msg {
  display: inline-block;
  padding: 3px 6px;
  margin: 1px;
  -webkit-border-radius: 5px;
  -moz-border-radius: 5px;
  border-radius: 5px;
}

.check-msg.info {
  color: #00546f;
  background-color: #bfdfe9;
  border: 1px solid #87a8b3;
}

.check-msg.error {
  background-color: #f2dede;
  color: #a94442;
  border: 1px solid #ebcccc;
}

.check-msg.macro {
  background-color: #d7dac2;
  color: #4f5c6d;
  border: 1px solid #d7dac2;
}

.check-msg.note {
  background-color: #d7d7d7;
  color: #4f5c6d;
  border: 1px solid #bfbfbf;
}

.check-msg.current {
  border: 2px dashed #3692ff;
}

.check-msg .tag {
  padding: 1px 5px;
  text-align: center;
  border-radius: 2px;
  margin-right: 5px;
  text-decoration: inherit;
}

.check-msg .tag.macro {
  background-color: #83876a;
  color: white;
  text-transform: capitalize;
}

.check-msg .tag.note {
  background-color: #9299a1;
  color: white;
  text-transform: capitalize;
}

.checker-enum {
  color: white;
  padding: 1px 5px;
  text-align: center;
  border-radius: 25px;
  margin-right: 5px;
  text-decoration: inherit;
}

.checker-enum.info {
  background-color: #427ea9;
}

.checker-enum.error {
  background-color: #a94442;
}

.arrow {
  border: solid black;
  border-width: 0 3px 3px 0;
  display: inline-block;
  padding: 3px;
  cursor: pointer;
  margin: 0px 5px;
}

.arrow:hover {
  border: solid #437ea8;
  border-width: 0 3px 3px 0;
}

.left-arrow {
  transform: rotate(135deg);
  -webkit-transform: rotate(135deg);
}

.right-arrow {
  transform: rotate(-45deg);
  -webkit-transform: rotate(-45deg);
}

    </style>

    <script type="text/javascript">
      function setNonCompatibleBrowserMessage() {
  document.body.innerHTML =
    '<h2 style="margin-left: 20px;">Your browser is not compatible with CodeChecker Viewer!</h2> \
     <p style="margin-left: 20px;">The version required for the following browsers are:</p> \
     <ul style="margin-left: 20px;"> \
     <li>Internet Explorer: version 9 or newer</li> \
     <li>Firefox: version 22.0 or newer</li> \
     </ul>';
}

// http://stackoverflow.com/questions/5916900/how-can-you-detect-the-version-of-a-browser
var browserVersion = (function(){
  var ua = navigator.userAgent, tem,
    M = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];

  if (/trident/i.test(M[1])) {
    tem = /\brv[ :]+(\d+)/g.exec(ua) || [];
    return 'IE ' + (tem[1] || '');
  }

  if (M[1] === 'Chrome') {
    tem = ua.match(/\b(OPR|Edge)\/(\d+)/);
    if (tem != null) return tem.slice(1).join(' ').replace('OPR', 'Opera');
  }

  M = M[2] ? [M[1], M[2]] : [navigator.appName, navigator.appVersion, '-?'];
  if ((tem = ua.match(/version\/(\d+)/i)) != null) M.splice(1, 1, tem[1]);
    return M.join(' ');
})();

var pos = browserVersion.indexOf(' ');
var browser = browserVersion.substr(0, pos);
var version = parseInt(browserVersion.substr(pos + 1));

var browserCompatible
  = browser === 'Firefox'
  ? version >= 22
  : browser === 'IE'
  ? version >= 9
  : true;


      /* MIT License

Copyright (C) 2017 by Marijn Haverbeke <marijnh@gmail.com> and others

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
 */
      !function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):e.CodeMirror=t()}(this,function(){"use strict";function e(e){return new RegExp("(^|\\s)"+e+"(?:$|\\s)\\s*")}function t(e){for(var t=e.childNodes.length;t>0;--t)e.removeChild(e.firstChild);return e}function r(e,r){return t(e).appendChild(r)}function n(e,t,r,n){var i=document.createElement(e);if(r&&(i.className=r),n&&(i.style.cssText=n),"string"==typeof t)i.appendChild(document.createTextNode(t));else if(t)for(var o=0;o<t.length;++o)i.appendChild(t[o]);return i}function i(e,t,r,i){var o=n(e,t,r,i);return o.setAttribute("role","presentation"),o}function o(e,t){if(3==t.nodeType&&(t=t.parentNode),e.contains)return e.contains(t);do{if(11==t.nodeType&&(t=t.host),t==e)return!0}while(t=t.parentNode)}function l(){var e;try{e=document.activeElement}catch(t){e=document.body||null}for(;e&&e.shadowRoot&&e.shadowRoot.activeElement;)e=e.shadowRoot.activeElement;return e}function s(t,r){var n=t.className;e(r).test(n)||(t.className+=(n?" ":"")+r)}function a(t,r){for(var n=t.split(" "),i=0;i<n.length;i++)n[i]&&!e(n[i]).test(r)&&(r+=" "+n[i]);return r}function u(e){var t=Array.prototype.slice.call(arguments,1);return function(){return e.apply(null,t)}}function c(e,t,r){t||(t={});for(var n in e)!e.hasOwnProperty(n)||!1===r&&t.hasOwnProperty(n)||(t[n]=e[n]);return t}function f(e,t,r,n,i){null==t&&-1==(t=e.search(/[^\s\u00a0]/))&&(t=e.length);for(var o=n||0,l=i||0;;){var s=e.indexOf("\t",o);if(s<0||s>=t)return l+(t-o);l+=s-o,l+=r-l%r,o=s+1}}function h(e,t){for(var r=0;r<e.length;++r)if(e[r]==t)return r;return-1}function d(e,t,r){for(var n=0,i=0;;){var o=e.indexOf("\t",n);-1==o&&(o=e.length);var l=o-n;if(o==e.length||i+l>=t)return n+Math.min(l,t-i);if(i+=o-n,i+=r-i%r,n=o+1,i>=t)return n}}function p(e){for(;Kl.length<=e;)Kl.push(g(Kl)+" ");return Kl[e]}function g(e){return e[e.length-1]}function v(e,t){for(var r=[],n=0;n<e.length;n++)r[n]=t(e[n],n);return r}function m(e,t,r){for(var n=0,i=r(t);n<e.length&&r(e[n])<=i;)n++;e.splice(n,0,t)}function y(){}function b(e,t){var r;return Object.create?r=Object.create(e):(y.prototype=e,r=new y),t&&c(t,r),r}function w(e){return/\w/.test(e)||e>""&&(e.toUpperCase()!=e.toLowerCase()||jl.test(e))}function x(e,t){return t?!!(t.source.indexOf("\\w")>-1&&w(e))||t.test(e):w(e)}function C(e){for(var t in e)if(e.hasOwnProperty(t)&&e[t])return!1;return!0}function S(e){return e.charCodeAt(0)>=768&&Xl.test(e)}function L(e,t,r){for(;(r<0?t>0:t<e.length)&&S(e.charAt(t));)t+=r;return t}function k(e,t,r){for(var n=t>r?-1:1;;){if(t==r)return t;var i=(t+r)/2,o=n<0?Math.ceil(i):Math.floor(i);if(o==t)return e(o)?t:r;e(o)?r=o:t=o+n}}function T(e,t,r){var o=this;this.input=r,o.scrollbarFiller=n("div",null,"CodeMirror-scrollbar-filler"),o.scrollbarFiller.setAttribute("cm-not-content","true"),o.gutterFiller=n("div",null,"CodeMirror-gutter-filler"),o.gutterFiller.setAttribute("cm-not-content","true"),o.lineDiv=i("div",null,"CodeMirror-code"),o.selectionDiv=n("div",null,null,"position: relative; z-index: 1"),o.cursorDiv=n("div",null,"CodeMirror-cursors"),o.measure=n("div",null,"CodeMirror-measure"),o.lineMeasure=n("div",null,"CodeMirror-measure"),o.lineSpace=i("div",[o.measure,o.lineMeasure,o.selectionDiv,o.cursorDiv,o.lineDiv],null,"position: relative; outline: none");var l=i("div",[o.lineSpace],"CodeMirror-lines");o.mover=n("div",[l],null,"position: relative"),o.sizer=n("div",[o.mover],"CodeMirror-sizer"),o.sizerWidth=null,o.heightForcer=n("div",null,null,"position: absolute; height: "+Rl+"px; width: 1px;"),o.gutters=n("div",null,"CodeMirror-gutters"),o.lineGutter=null,o.scroller=n("div",[o.sizer,o.heightForcer,o.gutters],"CodeMirror-scroll"),o.scroller.setAttribute("tabIndex","-1"),o.wrapper=n("div",[o.scrollbarFiller,o.gutterFiller,o.scroller],"CodeMirror"),gl&&vl<8&&(o.gutters.style.zIndex=-1,o.scroller.style.paddingRight=0),ml||fl&&Tl||(o.scroller.draggable=!0),e&&(e.appendChild?e.appendChild(o.wrapper):e(o.wrapper)),o.viewFrom=o.viewTo=t.first,o.reportedViewFrom=o.reportedViewTo=t.first,o.view=[],o.renderedView=null,o.externalMeasured=null,o.viewOffset=0,o.lastWrapHeight=o.lastWrapWidth=0,o.updateLineNumbers=null,o.nativeBarWidth=o.barHeight=o.barWidth=0,o.scrollbarsClipped=!1,o.lineNumWidth=o.lineNumInnerWidth=o.lineNumChars=null,o.alignWidgets=!1,o.cachedCharWidth=o.cachedTextHeight=o.cachedPaddingH=null,o.maxLine=null,o.maxLineLength=0,o.maxLineChanged=!1,o.wheelDX=o.wheelDY=o.wheelStartX=o.wheelStartY=null,o.shift=!1,o.selForContextMenu=null,o.activeTouch=null,r.init(o)}function M(e,t){if((t-=e.first)<0||t>=e.size)throw new Error("There is no line "+(t+e.first)+" in the document.");for(var r=e;!r.lines;)for(var n=0;;++n){var i=r.children[n],o=i.chunkSize();if(t<o){r=i;break}t-=o}return r.lines[t]}function N(e,t,r){var n=[],i=t.line;return e.iter(t.line,r.line+1,function(e){var o=e.text;i==r.line&&(o=o.slice(0,r.ch)),i==t.line&&(o=o.slice(t.ch)),n.push(o),++i}),n}function O(e,t,r){var n=[];return e.iter(t,r,function(e){n.push(e.text)}),n}function A(e,t){var r=t-e.height;if(r)for(var n=e;n;n=n.parent)n.height+=r}function W(e){if(null==e.parent)return null;for(var t=e.parent,r=h(t.lines,e),n=t.parent;n;t=n,n=n.parent)for(var i=0;n.children[i]!=t;++i)r+=n.children[i].chunkSize();return r+t.first}function D(e,t){var r=e.first;e:do{for(var n=0;n<e.children.length;++n){var i=e.children[n],o=i.height;if(t<o){e=i;continue e}t-=o,r+=i.chunkSize()}return r}while(!e.lines);for(var l=0;l<e.lines.length;++l){var s=e.lines[l].height;if(t<s)break;t-=s}return r+l}function H(e,t){return t>=e.first&&t<e.first+e.size}function F(e,t){return String(e.lineNumberFormatter(t+e.firstLineNumber))}function E(e,t,r){if(void 0===r&&(r=null),!(this instanceof E))return new E(e,t,r);this.line=e,this.ch=t,this.sticky=r}function P(e,t){return e.line-t.line||e.ch-t.ch}function I(e,t){return e.sticky==t.sticky&&0==P(e,t)}function z(e){return E(e.line,e.ch)}function R(e,t){return P(e,t)<0?t:e}function B(e,t){return P(e,t)<0?e:t}function G(e,t){return Math.max(e.first,Math.min(t,e.first+e.size-1))}function U(e,t){if(t.line<e.first)return E(e.first,0);var r=e.first+e.size-1;return t.line>r?E(r,M(e,r).text.length):V(t,M(e,t.line).text.length)}function V(e,t){var r=e.ch;return null==r||r>t?E(e.line,t):r<0?E(e.line,0):e}function K(e,t){for(var r=[],n=0;n<t.length;n++)r[n]=U(e,t[n]);return r}function j(){Yl=!0}function X(){_l=!0}function Y(e,t,r){this.marker=e,this.from=t,this.to=r}function _(e,t){if(e)for(var r=0;r<e.length;++r){var n=e[r];if(n.marker==t)return n}}function $(e,t){for(var r,n=0;n<e.length;++n)e[n]!=t&&(r||(r=[])).push(e[n]);return r}function q(e,t){e.markedSpans=e.markedSpans?e.markedSpans.concat([t]):[t],t.marker.attachLine(e)}function Z(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t)||o.from==t&&"bookmark"==l.type&&(!r||!o.marker.insertLeft)){var s=null==o.to||(l.inclusiveRight?o.to>=t:o.to>t);(n||(n=[])).push(new Y(l,o.from,s?null:o.to))}}return n}function Q(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.to||(l.inclusiveRight?o.to>=t:o.to>t)||o.from==t&&"bookmark"==l.type&&(!r||o.marker.insertLeft)){var s=null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t);(n||(n=[])).push(new Y(l,s?null:o.from-t,null==o.to?null:o.to-t))}}return n}function J(e,t){if(t.full)return null;var r=H(e,t.from.line)&&M(e,t.from.line).markedSpans,n=H(e,t.to.line)&&M(e,t.to.line).markedSpans;if(!r&&!n)return null;var i=t.from.ch,o=t.to.ch,l=0==P(t.from,t.to),s=Z(r,i,l),a=Q(n,o,l),u=1==t.text.length,c=g(t.text).length+(u?i:0);if(s)for(var f=0;f<s.length;++f){var h=s[f];if(null==h.to){var d=_(a,h.marker);d?u&&(h.to=null==d.to?null:d.to+c):h.to=i}}if(a)for(var p=0;p<a.length;++p){var v=a[p];null!=v.to&&(v.to+=c),null==v.from?_(s,v.marker)||(v.from=c,u&&(s||(s=[])).push(v)):(v.from+=c,u&&(s||(s=[])).push(v))}s&&(s=ee(s)),a&&a!=s&&(a=ee(a));var m=[s];if(!u){var y,b=t.text.length-2;if(b>0&&s)for(var w=0;w<s.length;++w)null==s[w].to&&(y||(y=[])).push(new Y(s[w].marker,null,null));for(var x=0;x<b;++x)m.push(y);m.push(a)}return m}function ee(e){for(var t=0;t<e.length;++t){var r=e[t];null!=r.from&&r.from==r.to&&!1!==r.marker.clearWhenEmpty&&e.splice(t--,1)}return e.length?e:null}function te(e,t,r){var n=null;if(e.iter(t.line,r.line+1,function(e){if(e.markedSpans)for(var t=0;t<e.markedSpans.length;++t){var r=e.markedSpans[t].marker;!r.readOnly||n&&-1!=h(n,r)||(n||(n=[])).push(r)}}),!n)return null;for(var i=[{from:t,to:r}],o=0;o<n.length;++o)for(var l=n[o],s=l.find(0),a=0;a<i.length;++a){var u=i[a];if(!(P(u.to,s.from)<0||P(u.from,s.to)>0)){var c=[a,1],f=P(u.from,s.from),d=P(u.to,s.to);(f<0||!l.inclusiveLeft&&!f)&&c.push({from:u.from,to:s.from}),(d>0||!l.inclusiveRight&&!d)&&c.push({from:s.to,to:u.to}),i.splice.apply(i,c),a+=c.length-3}}return i}function re(e){var t=e.markedSpans;if(t){for(var r=0;r<t.length;++r)t[r].marker.detachLine(e);e.markedSpans=null}}function ne(e,t){if(t){for(var r=0;r<t.length;++r)t[r].marker.attachLine(e);e.markedSpans=t}}function ie(e){return e.inclusiveLeft?-1:0}function oe(e){return e.inclusiveRight?1:0}function le(e,t){var r=e.lines.length-t.lines.length;if(0!=r)return r;var n=e.find(),i=t.find(),o=P(n.from,i.from)||ie(e)-ie(t);if(o)return-o;var l=P(n.to,i.to)||oe(e)-oe(t);return l||t.id-e.id}function se(e,t){var r,n=_l&&e.markedSpans;if(n)for(var i=void 0,o=0;o<n.length;++o)(i=n[o]).marker.collapsed&&null==(t?i.from:i.to)&&(!r||le(r,i.marker)<0)&&(r=i.marker);return r}function ae(e){return se(e,!0)}function ue(e){return se(e,!1)}function ce(e,t,r,n,i){var o=M(e,t),l=_l&&o.markedSpans;if(l)for(var s=0;s<l.length;++s){var a=l[s];if(a.marker.collapsed){var u=a.marker.find(0),c=P(u.from,r)||ie(a.marker)-ie(i),f=P(u.to,n)||oe(a.marker)-oe(i);if(!(c>=0&&f<=0||c<=0&&f>=0)&&(c<=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.to,r)>=0:P(u.to,r)>0)||c>=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.from,n)<=0:P(u.from,n)<0)))return!0}}}function fe(e){for(var t;t=ae(e);)e=t.find(-1,!0).line;return e}function he(e){for(var t;t=ue(e);)e=t.find(1,!0).line;return e}function de(e){for(var t,r;t=ue(e);)e=t.find(1,!0).line,(r||(r=[])).push(e);return r}function pe(e,t){var r=M(e,t),n=fe(r);return r==n?t:W(n)}function ge(e,t){if(t>e.lastLine())return t;var r,n=M(e,t);if(!ve(e,n))return t;for(;r=ue(n);)n=r.find(1,!0).line;return W(n)+1}function ve(e,t){var r=_l&&t.markedSpans;if(r)for(var n=void 0,i=0;i<r.length;++i)if((n=r[i]).marker.collapsed){if(null==n.from)return!0;if(!n.marker.widgetNode&&0==n.from&&n.marker.inclusiveLeft&&me(e,t,n))return!0}}function me(e,t,r){if(null==r.to){var n=r.marker.find(1,!0);return me(e,n.line,_(n.line.markedSpans,r.marker))}if(r.marker.inclusiveRight&&r.to==t.text.length)return!0;for(var i=void 0,o=0;o<t.markedSpans.length;++o)if((i=t.markedSpans[o]).marker.collapsed&&!i.marker.widgetNode&&i.from==r.to&&(null==i.to||i.to!=r.from)&&(i.marker.inclusiveLeft||r.marker.inclusiveRight)&&me(e,t,i))return!0}function ye(e){for(var t=0,r=(e=fe(e)).parent,n=0;n<r.lines.length;++n){var i=r.lines[n];if(i==e)break;t+=i.height}for(var o=r.parent;o;r=o,o=r.parent)for(var l=0;l<o.children.length;++l){var s=o.children[l];if(s==r)break;t+=s.height}return t}function be(e){if(0==e.height)return 0;for(var t,r=e.text.length,n=e;t=ae(n);){var i=t.find(0,!0);n=i.from.line,r+=i.from.ch-i.to.ch}for(n=e;t=ue(n);){var o=t.find(0,!0);r-=n.text.length-o.from.ch,r+=(n=o.to.line).text.length-o.to.ch}return r}function we(e){var t=e.display,r=e.doc;t.maxLine=M(r,r.first),t.maxLineLength=be(t.maxLine),t.maxLineChanged=!0,r.iter(function(e){var r=be(e);r>t.maxLineLength&&(t.maxLineLength=r,t.maxLine=e)})}function xe(e,t,r,n){if(!e)return n(t,r,"ltr",0);for(var i=!1,o=0;o<e.length;++o){var l=e[o];(l.from<r&&l.to>t||t==r&&l.to==t)&&(n(Math.max(l.from,t),Math.min(l.to,r),1==l.level?"rtl":"ltr",o),i=!0)}i||n(t,r,"ltr")}function Ce(e,t,r){var n;$l=null;for(var i=0;i<e.length;++i){var o=e[i];if(o.from<t&&o.to>t)return i;o.to==t&&(o.from!=o.to&&"before"==r?n=i:$l=i),o.from==t&&(o.from!=o.to&&"before"!=r?n=i:$l=i)}return null!=n?n:$l}function Se(e,t){var r=e.order;return null==r&&(r=e.order=ql(e.text,t)),r}function Le(e,t){return e._handlers&&e._handlers[t]||Zl}function ke(e,t,r){if(e.removeEventListener)e.removeEventListener(t,r,!1);else if(e.detachEvent)e.detachEvent("on"+t,r);else{var n=e._handlers,i=n&&n[t];if(i){var o=h(i,r);o>-1&&(n[t]=i.slice(0,o).concat(i.slice(o+1)))}}}function Te(e,t){var r=Le(e,t);if(r.length)for(var n=Array.prototype.slice.call(arguments,2),i=0;i<r.length;++i)r[i].apply(null,n)}function Me(e,t,r){return"string"==typeof t&&(t={type:t,preventDefault:function(){this.defaultPrevented=!0}}),Te(e,r||t.type,e,t),He(t)||t.codemirrorIgnore}function Ne(e){var t=e._handlers&&e._handlers.cursorActivity;if(t)for(var r=e.curOp.cursorActivityHandlers||(e.curOp.cursorActivityHandlers=[]),n=0;n<t.length;++n)-1==h(r,t[n])&&r.push(t[n])}function Oe(e,t){return Le(e,t).length>0}function Ae(e){e.prototype.on=function(e,t){Ql(this,e,t)},e.prototype.off=function(e,t){ke(this,e,t)}}function We(e){e.preventDefault?e.preventDefault():e.returnValue=!1}function De(e){e.stopPropagation?e.stopPropagation():e.cancelBubble=!0}function He(e){return null!=e.defaultPrevented?e.defaultPrevented:0==e.returnValue}function Fe(e){We(e),De(e)}function Ee(e){return e.target||e.srcElement}function Pe(e){var t=e.which;return null==t&&(1&e.button?t=1:2&e.button?t=3:4&e.button&&(t=2)),Ml&&e.ctrlKey&&1==t&&(t=3),t}function Ie(e){if(null==Il){var t=n("span","​");r(e,n("span",[t,document.createTextNode("x")])),0!=e.firstChild.offsetHeight&&(Il=t.offsetWidth<=1&&t.offsetHeight>2&&!(gl&&vl<8))}var i=Il?n("span","​"):n("span"," ",null,"display: inline-block; width: 1px; margin-right: -1px");return i.setAttribute("cm-text",""),i}function ze(e){if(null!=zl)return zl;var n=r(e,document.createTextNode("AخA")),i=Wl(n,0,1).getBoundingClientRect(),o=Wl(n,1,2).getBoundingClientRect();return t(e),!(!i||i.left==i.right)&&(zl=o.right-i.right<3)}function Re(e){if(null!=ns)return ns;var t=r(e,n("span","x")),i=t.getBoundingClientRect(),o=Wl(t,0,1).getBoundingClientRect();return ns=Math.abs(i.left-o.left)>1}function Be(e,t){arguments.length>2&&(t.dependencies=Array.prototype.slice.call(arguments,2)),is[e]=t}function Ge(e){if("string"==typeof e&&os.hasOwnProperty(e))e=os[e];else if(e&&"string"==typeof e.name&&os.hasOwnProperty(e.name)){var t=os[e.name];"string"==typeof t&&(t={name:t}),(e=b(t,e)).name=t.name}else{if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+xml$/.test(e))return Ge("application/xml");if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+json$/.test(e))return Ge("application/json")}return"string"==typeof e?{name:e}:e||{name:"null"}}function Ue(e,t){t=Ge(t);var r=is[t.name];if(!r)return Ue(e,"text/plain");var n=r(e,t);if(ls.hasOwnProperty(t.name)){var i=ls[t.name];for(var o in i)i.hasOwnProperty(o)&&(n.hasOwnProperty(o)&&(n["_"+o]=n[o]),n[o]=i[o])}if(n.name=t.name,t.helperType&&(n.helperType=t.helperType),t.modeProps)for(var l in t.modeProps)n[l]=t.modeProps[l];return n}function Ve(e,t){c(t,ls.hasOwnProperty(e)?ls[e]:ls[e]={})}function Ke(e,t){if(!0===t)return t;if(e.copyState)return e.copyState(t);var r={};for(var n in t){var i=t[n];i instanceof Array&&(i=i.concat([])),r[n]=i}return r}function je(e,t){for(var r;e.innerMode&&(r=e.innerMode(t))&&r.mode!=e;)t=r.state,e=r.mode;return r||{mode:e,state:t}}function Xe(e,t,r){return!e.startState||e.startState(t,r)}function Ye(e,t,r,n){var i=[e.state.modeGen],o={};tt(e,t.text,e.doc.mode,r,function(e,t){return i.push(e,t)},o,n);for(var l=r.state,s=0;s<e.state.overlays.length;++s)!function(n){var l=e.state.overlays[n],s=1,a=0;r.state=!0,tt(e,t.text,l.mode,r,function(e,t){for(var r=s;a<e;){var n=i[s];n>e&&i.splice(s,1,e,i[s+1],n),s+=2,a=Math.min(e,n)}if(t)if(l.opaque)i.splice(r,s-r,e,"overlay "+t),s=r+2;else for(;r<s;r+=2){var o=i[r+1];i[r+1]=(o?o+" ":"")+"overlay "+t}},o)}(s);return r.state=l,{styles:i,classes:o.bgClass||o.textClass?o:null}}function _e(e,t,r){if(!t.styles||t.styles[0]!=e.state.modeGen){var n=$e(e,W(t)),i=t.text.length>e.options.maxHighlightLength&&Ke(e.doc.mode,n.state),o=Ye(e,t,n);i&&(n.state=i),t.stateAfter=n.save(!i),t.styles=o.styles,o.classes?t.styleClasses=o.classes:t.styleClasses&&(t.styleClasses=null),r===e.doc.highlightFrontier&&(e.doc.modeFrontier=Math.max(e.doc.modeFrontier,++e.doc.highlightFrontier))}return t.styles}function $e(e,t,r){var n=e.doc,i=e.display;if(!n.mode.startState)return new us(n,!0,t);var o=rt(e,t,r),l=o>n.first&&M(n,o-1).stateAfter,s=l?us.fromSaved(n,l,o):new us(n,Xe(n.mode),o);return n.iter(o,t,function(r){qe(e,r.text,s);var n=s.line;r.stateAfter=n==t-1||n%5==0||n>=i.viewFrom&&n<i.viewTo?s.save():null,s.nextLine()}),r&&(n.modeFrontier=s.line),s}function qe(e,t,r,n){var i=e.doc.mode,o=new ss(t,e.options.tabSize,r);for(o.start=o.pos=n||0,""==t&&Ze(i,r.state);!o.eol();)Qe(i,o,r.state),o.start=o.pos}function Ze(e,t){if(e.blankLine)return e.blankLine(t);if(e.innerMode){var r=je(e,t);return r.mode.blankLine?r.mode.blankLine(r.state):void 0}}function Qe(e,t,r,n){for(var i=0;i<10;i++){n&&(n[0]=je(e,r).mode);var o=e.token(t,r);if(t.pos>t.start)return o}throw new Error("Mode "+e.name+" failed to advance stream.")}function Je(e,t,r,n){var i,o,l=e.doc,s=l.mode,a=M(l,(t=U(l,t)).line),u=$e(e,t.line,r),c=new ss(a.text,e.options.tabSize,u);for(n&&(o=[]);(n||c.pos<t.ch)&&!c.eol();)c.start=c.pos,i=Qe(s,c,u.state),n&&o.push(new cs(c,i,Ke(l.mode,u.state)));return n?o:new cs(c,i,u.state)}function et(e,t){if(e)for(;;){var r=e.match(/(?:^|\s+)line-(background-)?(\S+)/);if(!r)break;e=e.slice(0,r.index)+e.slice(r.index+r[0].length);var n=r[1]?"bgClass":"textClass";null==t[n]?t[n]=r[2]:new RegExp("(?:^|s)"+r[2]+"(?:$|s)").test(t[n])||(t[n]+=" "+r[2])}return e}function tt(e,t,r,n,i,o,l){var s=r.flattenSpans;null==s&&(s=e.options.flattenSpans);var a,u=0,c=null,f=new ss(t,e.options.tabSize,n),h=e.options.addModeClass&&[null];for(""==t&&et(Ze(r,n.state),o);!f.eol();){if(f.pos>e.options.maxHighlightLength?(s=!1,l&&qe(e,t,n,f.pos),f.pos=t.length,a=null):a=et(Qe(r,f,n.state,h),o),h){var d=h[0].name;d&&(a="m-"+(a?d+" "+a:d))}if(!s||c!=a){for(;u<f.start;)i(u=Math.min(f.start,u+5e3),c);c=a}f.start=f.pos}for(;u<f.pos;){var p=Math.min(f.pos,u+5e3);i(p,c),u=p}}function rt(e,t,r){for(var n,i,o=e.doc,l=r?-1:t-(e.doc.mode.innerMode?1e3:100),s=t;s>l;--s){if(s<=o.first)return o.first;var a=M(o,s-1),u=a.stateAfter;if(u&&(!r||s+(u instanceof as?u.lookAhead:0)<=o.modeFrontier))return s;var c=f(a.text,null,e.options.tabSize);(null==i||n>c)&&(i=s-1,n=c)}return i}function nt(e,t){if(e.modeFrontier=Math.min(e.modeFrontier,t),!(e.highlightFrontier<t-10)){for(var r=e.first,n=t-1;n>r;n--){var i=M(e,n).stateAfter;if(i&&(!(i instanceof as)||n+i.lookAhead<t)){r=n+1;break}}e.highlightFrontier=Math.min(e.highlightFrontier,r)}}function it(e,t,r,n){e.text=t,e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null),null!=e.order&&(e.order=null),re(e),ne(e,r);var i=n?n(e):1;i!=e.height&&A(e,i)}function ot(e){e.parent=null,re(e)}function lt(e,t){if(!e||/^\s*$/.test(e))return null;var r=t.addModeClass?ps:ds;return r[e]||(r[e]=e.replace(/\S+/g,"cm-$&"))}function st(e,t){var r=i("span",null,null,ml?"padding-right: .1px":null),n={pre:i("pre",[r],"CodeMirror-line"),content:r,col:0,pos:0,cm:e,trailingSpace:!1,splitSpaces:(gl||ml)&&e.getOption("lineWrapping")};t.measure={};for(var o=0;o<=(t.rest?t.rest.length:0);o++){var l=o?t.rest[o-1]:t.line,s=void 0;n.pos=0,n.addToken=ut,ze(e.display.measure)&&(s=Se(l,e.doc.direction))&&(n.addToken=ft(n.addToken,s)),n.map=[],dt(l,n,_e(e,l,t!=e.display.externalMeasured&&W(l))),l.styleClasses&&(l.styleClasses.bgClass&&(n.bgClass=a(l.styleClasses.bgClass,n.bgClass||"")),l.styleClasses.textClass&&(n.textClass=a(l.styleClasses.textClass,n.textClass||""))),0==n.map.length&&n.map.push(0,0,n.content.appendChild(Ie(e.display.measure))),0==o?(t.measure.map=n.map,t.measure.cache={}):((t.measure.maps||(t.measure.maps=[])).push(n.map),(t.measure.caches||(t.measure.caches=[])).push({}))}if(ml){var u=n.content.lastChild;(/\bcm-tab\b/.test(u.className)||u.querySelector&&u.querySelector(".cm-tab"))&&(n.content.className="cm-tab-wrap-hack")}return Te(e,"renderLine",e,t.line,n.pre),n.pre.className&&(n.textClass=a(n.pre.className,n.textClass||"")),n}function at(e){var t=n("span","•","cm-invalidchar");return t.title="\\u"+e.charCodeAt(0).toString(16),t.setAttribute("aria-label",t.title),t}function ut(e,t,r,i,o,l,s){if(t){var a,u=e.splitSpaces?ct(t,e.trailingSpace):t,c=e.cm.state.specialChars,f=!1;if(c.test(t)){a=document.createDocumentFragment();for(var h=0;;){c.lastIndex=h;var d=c.exec(t),g=d?d.index-h:t.length-h;if(g){var v=document.createTextNode(u.slice(h,h+g));gl&&vl<9?a.appendChild(n("span",[v])):a.appendChild(v),e.map.push(e.pos,e.pos+g,v),e.col+=g,e.pos+=g}if(!d)break;h+=g+1;var m=void 0;if("\t"==d[0]){var y=e.cm.options.tabSize,b=y-e.col%y;(m=a.appendChild(n("span",p(b),"cm-tab"))).setAttribute("role","presentation"),m.setAttribute("cm-text","\t"),e.col+=b}else"\r"==d[0]||"\n"==d[0]?((m=a.appendChild(n("span","\r"==d[0]?"␍":"␤","cm-invalidchar"))).setAttribute("cm-text",d[0]),e.col+=1):((m=e.cm.options.specialCharPlaceholder(d[0])).setAttribute("cm-text",d[0]),gl&&vl<9?a.appendChild(n("span",[m])):a.appendChild(m),e.col+=1);e.map.push(e.pos,e.pos+1,m),e.pos++}}else e.col+=t.length,a=document.createTextNode(u),e.map.push(e.pos,e.pos+t.length,a),gl&&vl<9&&(f=!0),e.pos+=t.length;if(e.trailingSpace=32==u.charCodeAt(t.length-1),r||i||o||f||s){var w=r||"";i&&(w+=i),o&&(w+=o);var x=n("span",[a],w,s);return l&&(x.title=l),e.content.appendChild(x)}e.content.appendChild(a)}}function ct(e,t){if(e.length>1&&!/  /.test(e))return e;for(var r=t,n="",i=0;i<e.length;i++){var o=e.charAt(i);" "!=o||!r||i!=e.length-1&&32!=e.charCodeAt(i+1)||(o=" "),n+=o,r=" "==o}return n}function ft(e,t){return function(r,n,i,o,l,s,a){i=i?i+" cm-force-border":"cm-force-border";for(var u=r.pos,c=u+n.length;;){for(var f=void 0,h=0;h<t.length&&!((f=t[h]).to>u&&f.from<=u);h++);if(f.to>=c)return e(r,n,i,o,l,s,a);e(r,n.slice(0,f.to-u),i,o,null,s,a),o=null,n=n.slice(f.to-u),u=f.to}}}function ht(e,t,r,n){var i=!n&&r.widgetNode;i&&e.map.push(e.pos,e.pos+t,i),!n&&e.cm.display.input.needsContentAttribute&&(i||(i=e.content.appendChild(document.createElement("span"))),i.setAttribute("cm-marker",r.id)),i&&(e.cm.display.input.setUneditable(i),e.content.appendChild(i)),e.pos+=t,e.trailingSpace=!1}function dt(e,t,r){var n=e.markedSpans,i=e.text,o=0;if(n)for(var l,s,a,u,c,f,h,d=i.length,p=0,g=1,v="",m=0;;){if(m==p){a=u=c=f=s="",h=null,m=1/0;for(var y=[],b=void 0,w=0;w<n.length;++w){var x=n[w],C=x.marker;"bookmark"==C.type&&x.from==p&&C.widgetNode?y.push(C):x.from<=p&&(null==x.to||x.to>p||C.collapsed&&x.to==p&&x.from==p)?(null!=x.to&&x.to!=p&&m>x.to&&(m=x.to,u=""),C.className&&(a+=" "+C.className),C.css&&(s=(s?s+";":"")+C.css),C.startStyle&&x.from==p&&(c+=" "+C.startStyle),C.endStyle&&x.to==m&&(b||(b=[])).push(C.endStyle,x.to),C.title&&!f&&(f=C.title),C.collapsed&&(!h||le(h.marker,C)<0)&&(h=x)):x.from>p&&m>x.from&&(m=x.from)}if(b)for(var S=0;S<b.length;S+=2)b[S+1]==m&&(u+=" "+b[S]);if(!h||h.from==p)for(var L=0;L<y.length;++L)ht(t,0,y[L]);if(h&&(h.from||0)==p){if(ht(t,(null==h.to?d+1:h.to)-p,h.marker,null==h.from),null==h.to)return;h.to==p&&(h=!1)}}if(p>=d)break;for(var k=Math.min(d,m);;){if(v){var T=p+v.length;if(!h){var M=T>k?v.slice(0,k-p):v;t.addToken(t,M,l?l+a:a,c,p+M.length==m?u:"",f,s)}if(T>=k){v=v.slice(k-p),p=k;break}p=T,c=""}v=i.slice(o,o=r[g++]),l=lt(r[g++],t.cm.options)}}else for(var N=1;N<r.length;N+=2)t.addToken(t,i.slice(o,o=r[N]),lt(r[N+1],t.cm.options))}function pt(e,t,r){this.line=t,this.rest=de(t),this.size=this.rest?W(g(this.rest))-r+1:1,this.node=this.text=null,this.hidden=ve(e,t)}function gt(e,t,r){for(var n,i=[],o=t;o<r;o=n){var l=new pt(e.doc,M(e.doc,o),o);n=o+l.size,i.push(l)}return i}function vt(e){gs?gs.ops.push(e):e.ownsGroup=gs={ops:[e],delayedCallbacks:[]}}function mt(e){var t=e.delayedCallbacks,r=0;do{for(;r<t.length;r++)t[r].call(null);for(var n=0;n<e.ops.length;n++){var i=e.ops[n];if(i.cursorActivityHandlers)for(;i.cursorActivityCalled<i.cursorActivityHandlers.length;)i.cursorActivityHandlers[i.cursorActivityCalled++].call(null,i.cm)}}while(r<t.length)}function yt(e,t){var r=e.ownsGroup;if(r)try{mt(r)}finally{gs=null,t(r)}}function bt(e,t){var r=Le(e,t);if(r.length){var n,i=Array.prototype.slice.call(arguments,2);gs?n=gs.delayedCallbacks:vs?n=vs:(n=vs=[],setTimeout(wt,0));for(var o=0;o<r.length;++o)!function(e){n.push(function(){return r[e].apply(null,i)})}(o)}}function wt(){var e=vs;vs=null;for(var t=0;t<e.length;++t)e[t]()}function xt(e,t,r,n){for(var i=0;i<t.changes.length;i++){var o=t.changes[i];"text"==o?kt(e,t):"gutter"==o?Mt(e,t,r,n):"class"==o?Tt(e,t):"widget"==o&&Nt(e,t,n)}t.changes=null}function Ct(e){return e.node==e.text&&(e.node=n("div",null,null,"position: relative"),e.text.parentNode&&e.text.parentNode.replaceChild(e.node,e.text),e.node.appendChild(e.text),gl&&vl<8&&(e.node.style.zIndex=2)),e.node}function St(e,t){var r=t.bgClass?t.bgClass+" "+(t.line.bgClass||""):t.line.bgClass;if(r&&(r+=" CodeMirror-linebackground"),t.background)r?t.background.className=r:(t.background.parentNode.removeChild(t.background),t.background=null);else if(r){var i=Ct(t);t.background=i.insertBefore(n("div",null,r),i.firstChild),e.display.input.setUneditable(t.background)}}function Lt(e,t){var r=e.display.externalMeasured;return r&&r.line==t.line?(e.display.externalMeasured=null,t.measure=r.measure,r.built):st(e,t)}function kt(e,t){var r=t.text.className,n=Lt(e,t);t.text==t.node&&(t.node=n.pre),t.text.parentNode.replaceChild(n.pre,t.text),t.text=n.pre,n.bgClass!=t.bgClass||n.textClass!=t.textClass?(t.bgClass=n.bgClass,t.textClass=n.textClass,Tt(e,t)):r&&(t.text.className=r)}function Tt(e,t){St(e,t),t.line.wrapClass?Ct(t).className=t.line.wrapClass:t.node!=t.text&&(t.node.className="");var r=t.textClass?t.textClass+" "+(t.line.textClass||""):t.line.textClass;t.text.className=r||""}function Mt(e,t,r,i){if(t.gutter&&(t.node.removeChild(t.gutter),t.gutter=null),t.gutterBackground&&(t.node.removeChild(t.gutterBackground),t.gutterBackground=null),t.line.gutterClass){var o=Ct(t);t.gutterBackground=n("div",null,"CodeMirror-gutter-background "+t.line.gutterClass,"left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px; width: "+i.gutterTotalWidth+"px"),e.display.input.setUneditable(t.gutterBackground),o.insertBefore(t.gutterBackground,t.text)}var l=t.line.gutterMarkers;if(e.options.lineNumbers||l){var s=Ct(t),a=t.gutter=n("div",null,"CodeMirror-gutter-wrapper","left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px");if(e.display.input.setUneditable(a),s.insertBefore(a,t.text),t.line.gutterClass&&(a.className+=" "+t.line.gutterClass),!e.options.lineNumbers||l&&l["CodeMirror-linenumbers"]||(t.lineNumber=a.appendChild(n("div",F(e.options,r),"CodeMirror-linenumber CodeMirror-gutter-elt","left: "+i.gutterLeft["CodeMirror-linenumbers"]+"px; width: "+e.display.lineNumInnerWidth+"px"))),l)for(var u=0;u<e.options.gutters.length;++u){var c=e.options.gutters[u],f=l.hasOwnProperty(c)&&l[c];f&&a.appendChild(n("div",[f],"CodeMirror-gutter-elt","left: "+i.gutterLeft[c]+"px; width: "+i.gutterWidth[c]+"px"))}}}function Nt(e,t,r){t.alignable&&(t.alignable=null);for(var n=t.node.firstChild,i=void 0;n;n=i)i=n.nextSibling,"CodeMirror-linewidget"==n.className&&t.node.removeChild(n);At(e,t,r)}function Ot(e,t,r,n){var i=Lt(e,t);return t.text=t.node=i.pre,i.bgClass&&(t.bgClass=i.bgClass),i.textClass&&(t.textClass=i.textClass),Tt(e,t),Mt(e,t,r,n),At(e,t,n),t.node}function At(e,t,r){if(Wt(e,t.line,t,r,!0),t.rest)for(var n=0;n<t.rest.length;n++)Wt(e,t.rest[n],t,r,!1)}function Wt(e,t,r,i,o){if(t.widgets)for(var l=Ct(r),s=0,a=t.widgets;s<a.length;++s){var u=a[s],c=n("div",[u.node],"CodeMirror-linewidget");u.handleMouseEvents||c.setAttribute("cm-ignore-events","true"),Dt(u,c,r,i),e.display.input.setUneditable(c),o&&u.above?l.insertBefore(c,r.gutter||r.text):l.appendChild(c),bt(u,"redraw")}}function Dt(e,t,r,n){if(e.noHScroll){(r.alignable||(r.alignable=[])).push(t);var i=n.wrapperWidth;t.style.left=n.fixedPos+"px",e.coverGutter||(i-=n.gutterTotalWidth,t.style.paddingLeft=n.gutterTotalWidth+"px"),t.style.width=i+"px"}e.coverGutter&&(t.style.zIndex=5,t.style.position="relative",e.noHScroll||(t.style.marginLeft=-n.gutterTotalWidth+"px"))}function Ht(e){if(null!=e.height)return e.height;var t=e.doc.cm;if(!t)return 0;if(!o(document.body,e.node)){var i="position: relative;";e.coverGutter&&(i+="margin-left: -"+t.display.gutters.offsetWidth+"px;"),e.noHScroll&&(i+="width: "+t.display.wrapper.clientWidth+"px;"),r(t.display.measure,n("div",[e.node],null,i))}return e.height=e.node.parentNode.offsetHeight}function Ft(e,t){for(var r=Ee(t);r!=e.wrapper;r=r.parentNode)if(!r||1==r.nodeType&&"true"==r.getAttribute("cm-ignore-events")||r.parentNode==e.sizer&&r!=e.mover)return!0}function Et(e){return e.lineSpace.offsetTop}function Pt(e){return e.mover.offsetHeight-e.lineSpace.offsetHeight}function It(e){if(e.cachedPaddingH)return e.cachedPaddingH;var t=r(e.measure,n("pre","x")),i=window.getComputedStyle?window.getComputedStyle(t):t.currentStyle,o={left:parseInt(i.paddingLeft),right:parseInt(i.paddingRight)};return isNaN(o.left)||isNaN(o.right)||(e.cachedPaddingH=o),o}function zt(e){return Rl-e.display.nativeBarWidth}function Rt(e){return e.display.scroller.clientWidth-zt(e)-e.display.barWidth}function Bt(e){return e.display.scroller.clientHeight-zt(e)-e.display.barHeight}function Gt(e,t,r){var n=e.options.lineWrapping,i=n&&Rt(e);if(!t.measure.heights||n&&t.measure.width!=i){var o=t.measure.heights=[];if(n){t.measure.width=i;for(var l=t.text.firstChild.getClientRects(),s=0;s<l.length-1;s++){var a=l[s],u=l[s+1];Math.abs(a.bottom-u.bottom)>2&&o.push((a.bottom+u.top)/2-r.top)}}o.push(r.bottom-r.top)}}function Ut(e,t,r){if(e.line==t)return{map:e.measure.map,cache:e.measure.cache};for(var n=0;n<e.rest.length;n++)if(e.rest[n]==t)return{map:e.measure.maps[n],cache:e.measure.caches[n]};for(var i=0;i<e.rest.length;i++)if(W(e.rest[i])>r)return{map:e.measure.maps[i],cache:e.measure.caches[i],before:!0}}function Vt(e,t){var n=W(t=fe(t)),i=e.display.externalMeasured=new pt(e.doc,t,n);i.lineN=n;var o=i.built=st(e,i);return i.text=o.pre,r(e.display.lineMeasure,o.pre),i}function Kt(e,t,r,n){return Yt(e,Xt(e,t),r,n)}function jt(e,t){if(t>=e.display.viewFrom&&t<e.display.viewTo)return e.display.view[Lr(e,t)];var r=e.display.externalMeasured;return r&&t>=r.lineN&&t<r.lineN+r.size?r:void 0}function Xt(e,t){var r=W(t),n=jt(e,r);n&&!n.text?n=null:n&&n.changes&&(xt(e,n,r,br(e)),e.curOp.forceUpdate=!0),n||(n=Vt(e,t));var i=Ut(n,t,r);return{line:t,view:n,rect:null,map:i.map,cache:i.cache,before:i.before,hasHeights:!1}}function Yt(e,t,r,n,i){t.before&&(r=-1);var o,l=r+(n||"");return t.cache.hasOwnProperty(l)?o=t.cache[l]:(t.rect||(t.rect=t.view.text.getBoundingClientRect()),t.hasHeights||(Gt(e,t.view,t.rect),t.hasHeights=!0),(o=qt(e,t,r,n)).bogus||(t.cache[l]=o)),{left:o.left,right:o.right,top:i?o.rtop:o.top,bottom:i?o.rbottom:o.bottom}}function _t(e,t,r){for(var n,i,o,l,s,a,u=0;u<e.length;u+=3)if(s=e[u],a=e[u+1],t<s?(i=0,o=1,l="left"):t<a?o=(i=t-s)+1:(u==e.length-3||t==a&&e[u+3]>t)&&(i=(o=a-s)-1,t>=a&&(l="right")),null!=i){if(n=e[u+2],s==a&&r==(n.insertLeft?"left":"right")&&(l=r),"left"==r&&0==i)for(;u&&e[u-2]==e[u-3]&&e[u-1].insertLeft;)n=e[2+(u-=3)],l="left";if("right"==r&&i==a-s)for(;u<e.length-3&&e[u+3]==e[u+4]&&!e[u+5].insertLeft;)n=e[(u+=3)+2],l="right";break}return{node:n,start:i,end:o,collapse:l,coverStart:s,coverEnd:a}}function $t(e,t){var r=ms;if("left"==t)for(var n=0;n<e.length&&(r=e[n]).left==r.right;n++);else for(var i=e.length-1;i>=0&&(r=e[i]).left==r.right;i--);return r}function qt(e,t,r,n){var i,o=_t(t.map,r,n),l=o.node,s=o.start,a=o.end,u=o.collapse;if(3==l.nodeType){for(var c=0;c<4;c++){for(;s&&S(t.line.text.charAt(o.coverStart+s));)--s;for(;o.coverStart+a<o.coverEnd&&S(t.line.text.charAt(o.coverStart+a));)++a;if((i=gl&&vl<9&&0==s&&a==o.coverEnd-o.coverStart?l.parentNode.getBoundingClientRect():$t(Wl(l,s,a).getClientRects(),n)).left||i.right||0==s)break;a=s,s-=1,u="right"}gl&&vl<11&&(i=Zt(e.display.measure,i))}else{s>0&&(u=n="right");var f;i=e.options.lineWrapping&&(f=l.getClientRects()).length>1?f["right"==n?f.length-1:0]:l.getBoundingClientRect()}if(gl&&vl<9&&!s&&(!i||!i.left&&!i.right)){var h=l.parentNode.getClientRects()[0];i=h?{left:h.left,right:h.left+yr(e.display),top:h.top,bottom:h.bottom}:ms}for(var d=i.top-t.rect.top,p=i.bottom-t.rect.top,g=(d+p)/2,v=t.view.measure.heights,m=0;m<v.length-1&&!(g<v[m]);m++);var y=m?v[m-1]:0,b=v[m],w={left:("right"==u?i.right:i.left)-t.rect.left,right:("left"==u?i.left:i.right)-t.rect.left,top:y,bottom:b};return i.left||i.right||(w.bogus=!0),e.options.singleCursorHeightPerLine||(w.rtop=d,w.rbottom=p),w}function Zt(e,t){if(!window.screen||null==screen.logicalXDPI||screen.logicalXDPI==screen.deviceXDPI||!Re(e))return t;var r=screen.logicalXDPI/screen.deviceXDPI,n=screen.logicalYDPI/screen.deviceYDPI;return{left:t.left*r,right:t.right*r,top:t.top*n,bottom:t.bottom*n}}function Qt(e){if(e.measure&&(e.measure.cache={},e.measure.heights=null,e.rest))for(var t=0;t<e.rest.length;t++)e.measure.caches[t]={}}function Jt(e){e.display.externalMeasure=null,t(e.display.lineMeasure);for(var r=0;r<e.display.view.length;r++)Qt(e.display.view[r])}function er(e){Jt(e),e.display.cachedCharWidth=e.display.cachedTextHeight=e.display.cachedPaddingH=null,e.options.lineWrapping||(e.display.maxLineChanged=!0),e.display.lineNumChars=null}function tr(){return bl&&kl?-(document.body.getBoundingClientRect().left-parseInt(getComputedStyle(document.body).marginLeft)):window.pageXOffset||(document.documentElement||document.body).scrollLeft}function rr(){return bl&&kl?-(document.body.getBoundingClientRect().top-parseInt(getComputedStyle(document.body).marginTop)):window.pageYOffset||(document.documentElement||document.body).scrollTop}function nr(e){var t=0;if(e.widgets)for(var r=0;r<e.widgets.length;++r)e.widgets[r].above&&(t+=Ht(e.widgets[r]));return t}function ir(e,t,r,n,i){if(!i){var o=nr(t);r.top+=o,r.bottom+=o}if("line"==n)return r;n||(n="local");var l=ye(t);if("local"==n?l+=Et(e.display):l-=e.display.viewOffset,"page"==n||"window"==n){var s=e.display.lineSpace.getBoundingClientRect();l+=s.top+("window"==n?0:rr());var a=s.left+("window"==n?0:tr());r.left+=a,r.right+=a}return r.top+=l,r.bottom+=l,r}function or(e,t,r){if("div"==r)return t;var n=t.left,i=t.top;if("page"==r)n-=tr(),i-=rr();else if("local"==r||!r){var o=e.display.sizer.getBoundingClientRect();n+=o.left,i+=o.top}var l=e.display.lineSpace.getBoundingClientRect();return{left:n-l.left,top:i-l.top}}function lr(e,t,r,n,i){return n||(n=M(e.doc,t.line)),ir(e,n,Kt(e,n,t.ch,i),r)}function sr(e,t,r,n,i,o){function l(t,l){var s=Yt(e,i,t,l?"right":"left",o);return l?s.left=s.right:s.right=s.left,ir(e,n,s,r)}function s(e,t,r){var n=1==a[t].level;return l(r?e-1:e,n!=r)}n=n||M(e.doc,t.line),i||(i=Xt(e,n));var a=Se(n,e.doc.direction),u=t.ch,c=t.sticky;if(u>=n.text.length?(u=n.text.length,c="before"):u<=0&&(u=0,c="after"),!a)return l("before"==c?u-1:u,"before"==c);var f=Ce(a,u,c),h=$l,d=s(u,f,"before"==c);return null!=h&&(d.other=s(u,h,"before"!=c)),d}function ar(e,t){var r=0;t=U(e.doc,t),e.options.lineWrapping||(r=yr(e.display)*t.ch);var n=M(e.doc,t.line),i=ye(n)+Et(e.display);return{left:r,right:r,top:i,bottom:i+n.height}}function ur(e,t,r,n,i){var o=E(e,t,r);return o.xRel=i,n&&(o.outside=!0),o}function cr(e,t,r){var n=e.doc;if((r+=e.display.viewOffset)<0)return ur(n.first,0,null,!0,-1);var i=D(n,r),o=n.first+n.size-1;if(i>o)return ur(n.first+n.size-1,M(n,o).text.length,null,!0,1);t<0&&(t=0);for(var l=M(n,i);;){var s=pr(e,l,i,t,r),a=ue(l),u=a&&a.find(0,!0);if(!a||!(s.ch>u.from.ch||s.ch==u.from.ch&&s.xRel>0))return s;i=W(l=u.to.line)}}function fr(e,t,r,n){n-=nr(t);var i=t.text.length,o=k(function(t){return Yt(e,r,t-1).bottom<=n},i,0);return i=k(function(t){return Yt(e,r,t).top>n},o,i),{begin:o,end:i}}function hr(e,t,r,n){return r||(r=Xt(e,t)),fr(e,t,r,ir(e,t,Yt(e,r,n),"line").top)}function dr(e,t,r,n){return!(e.bottom<=r)&&(e.top>r||(n?e.left:e.right)>t)}function pr(e,t,r,n,i){i-=ye(t);var o=Xt(e,t),l=nr(t),s=0,a=t.text.length,u=!0,c=Se(t,e.doc.direction);if(c){var f=(e.options.lineWrapping?vr:gr)(e,t,r,o,c,n,i);s=(u=1!=f.level)?f.from:f.to-1,a=u?f.to:f.from-1}var h,d,p=null,g=null,v=k(function(t){var r=Yt(e,o,t);return r.top+=l,r.bottom+=l,!!dr(r,n,i,!1)&&(r.top<=i&&r.left<=n&&(p=t,g=r),!0)},s,a),m=!1;if(g){var y=n-g.left<g.right-n,b=y==u;v=p+(b?0:1),d=b?"after":"before",h=y?g.left:g.right}else{u||v!=a&&v!=s||v++,d=0==v?"after":v==t.text.length?"before":Yt(e,o,v-(u?1:0)).bottom+l<=i==u?"after":"before";var w=sr(e,E(r,v,d),"line",t,o);h=w.left,m=i<w.top||i>=w.bottom}return v=L(t.text,v,1),ur(r,v,d,m,n-h)}function gr(e,t,r,n,i,o,l){var s=k(function(s){var a=i[s],u=1!=a.level;return dr(sr(e,E(r,u?a.to:a.from,u?"before":"after"),"line",t,n),o,l,!0)},0,i.length-1),a=i[s];if(s>0){var u=1!=a.level,c=sr(e,E(r,u?a.from:a.to,u?"after":"before"),"line",t,n);dr(c,o,l,!0)&&c.top>l&&(a=i[s-1])}return a}function vr(e,t,r,n,i,o,l){for(var s=fr(e,t,n,l),a=s.begin,u=s.end,c=null,f=null,h=0;h<i.length;h++){var d=i[h];if(!(d.from>=u||d.to<=a)){var p=Yt(e,n,1!=d.level?Math.min(u,d.to)-1:Math.max(a,d.from)).right,g=p<o?o-p+1e9:p-o;(!c||f>g)&&(c=d,f=g)}}return c||(c=i[i.length-1]),c.from<a&&(c={from:a,to:c.to,level:c.level}),c.to>u&&(c={from:c.from,to:u,level:c.level}),c}function mr(e){if(null!=e.cachedTextHeight)return e.cachedTextHeight;if(null==hs){hs=n("pre");for(var i=0;i<49;++i)hs.appendChild(document.createTextNode("x")),hs.appendChild(n("br"));hs.appendChild(document.createTextNode("x"))}r(e.measure,hs);var o=hs.offsetHeight/50;return o>3&&(e.cachedTextHeight=o),t(e.measure),o||1}function yr(e){if(null!=e.cachedCharWidth)return e.cachedCharWidth;var t=n("span","xxxxxxxxxx"),i=n("pre",[t]);r(e.measure,i);var o=t.getBoundingClientRect(),l=(o.right-o.left)/10;return l>2&&(e.cachedCharWidth=l),l||10}function br(e){for(var t=e.display,r={},n={},i=t.gutters.clientLeft,o=t.gutters.firstChild,l=0;o;o=o.nextSibling,++l)r[e.options.gutters[l]]=o.offsetLeft+o.clientLeft+i,n[e.options.gutters[l]]=o.clientWidth;return{fixedPos:wr(t),gutterTotalWidth:t.gutters.offsetWidth,gutterLeft:r,gutterWidth:n,wrapperWidth:t.wrapper.clientWidth}}function wr(e){return e.scroller.getBoundingClientRect().left-e.sizer.getBoundingClientRect().left}function xr(e){var t=mr(e.display),r=e.options.lineWrapping,n=r&&Math.max(5,e.display.scroller.clientWidth/yr(e.display)-3);return function(i){if(ve(e.doc,i))return 0;var o=0;if(i.widgets)for(var l=0;l<i.widgets.length;l++)i.widgets[l].height&&(o+=i.widgets[l].height);return r?o+(Math.ceil(i.text.length/n)||1)*t:o+t}}function Cr(e){var t=e.doc,r=xr(e);t.iter(function(e){var t=r(e);t!=e.height&&A(e,t)})}function Sr(e,t,r,n){var i=e.display;if(!r&&"true"==Ee(t).getAttribute("cm-not-content"))return null;var o,l,s=i.lineSpace.getBoundingClientRect();try{o=t.clientX-s.left,l=t.clientY-s.top}catch(t){return null}var a,u=cr(e,o,l);if(n&&1==u.xRel&&(a=M(e.doc,u.line).text).length==u.ch){var c=f(a,a.length,e.options.tabSize)-a.length;u=E(u.line,Math.max(0,Math.round((o-It(e.display).left)/yr(e.display))-c))}return u}function Lr(e,t){if(t>=e.display.viewTo)return null;if((t-=e.display.viewFrom)<0)return null;for(var r=e.display.view,n=0;n<r.length;n++)if((t-=r[n].size)<0)return n}function kr(e){e.display.input.showSelection(e.display.input.prepareSelection())}function Tr(e,t){void 0===t&&(t=!0);for(var r=e.doc,n={},i=n.cursors=document.createDocumentFragment(),o=n.selection=document.createDocumentFragment(),l=0;l<r.sel.ranges.length;l++)if(t||l!=r.sel.primIndex){var s=r.sel.ranges[l];if(!(s.from().line>=e.display.viewTo||s.to().line<e.display.viewFrom)){var a=s.empty();(a||e.options.showCursorWhenSelecting)&&Mr(e,s.head,i),a||Or(e,s,o)}}return n}function Mr(e,t,r){var i=sr(e,t,"div",null,null,!e.options.singleCursorHeightPerLine),o=r.appendChild(n("div"," ","CodeMirror-cursor"));if(o.style.left=i.left+"px",o.style.top=i.top+"px",o.style.height=Math.max(0,i.bottom-i.top)*e.options.cursorHeight+"px",i.other){var l=r.appendChild(n("div"," ","CodeMirror-cursor CodeMirror-secondarycursor"));l.style.display="",l.style.left=i.other.left+"px",l.style.top=i.other.top+"px",l.style.height=.85*(i.other.bottom-i.other.top)+"px"}}function Nr(e,t){return e.top-t.top||e.left-t.left}function Or(e,t,r){function i(e,t,r,i){t<0&&(t=0),t=Math.round(t),i=Math.round(i),a.appendChild(n("div",null,"CodeMirror-selected","position: absolute; left: "+e+"px;\n                             top: "+t+"px; width: "+(null==r?f-e:r)+"px;\n                             height: "+(i-t)+"px"))}function o(t,r,n){function o(r,n){return lr(e,E(t,r),"div",u,n)}var l,a,u=M(s,t),h=u.text.length,d=Se(u,s.direction);return xe(d,r||0,null==n?h:n,function(t,s,p,g){var v=o(t,"ltr"==p?"left":"right"),m=o(s-1,"ltr"==p?"right":"left");if("ltr"==p){var y=null==r&&0==t?c:v.left,b=null==n&&s==h?f:m.right;m.top-v.top<=3?i(y,m.top,b-y,m.bottom):(i(y,v.top,null,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top),i(c,m.top,m.right,m.bottom))}else if(t<s){var w=null==r&&0==t?f:v.right,x=null==n&&s==h?c:m.left;if(m.top-v.top<=3)i(x,m.top,w-x,m.bottom);else{var C=c;if(g){var S=hr(e,u,null,t).end;C=o(S-(/\s/.test(u.text.charAt(S-1))?2:1),"left").left}i(C,v.top,w-C,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top);var L=null;d.length,L=o(hr(e,u,null,s).begin,"right").right-x,i(x,m.top,L,m.bottom)}}(!l||Nr(v,l)<0)&&(l=v),Nr(m,l)<0&&(l=m),(!a||Nr(v,a)<0)&&(a=v),Nr(m,a)<0&&(a=m)}),{start:l,end:a}}var l=e.display,s=e.doc,a=document.createDocumentFragment(),u=It(e.display),c=u.left,f=Math.max(l.sizerWidth,Rt(e)-l.sizer.offsetLeft)-u.right,h=t.from(),d=t.to();if(h.line==d.line)o(h.line,h.ch,d.ch);else{var p=M(s,h.line),g=M(s,d.line),v=fe(p)==fe(g),m=o(h.line,h.ch,v?p.text.length+1:null).end,y=o(d.line,v?0:null,d.ch).start;v&&(m.top<y.top-2?(i(m.right,m.top,null,m.bottom),i(c,y.top,y.left,y.bottom)):i(m.right,m.top,y.left-m.right,m.bottom)),m.bottom<y.top&&i(c,m.bottom,null,y.top)}r.appendChild(a)}function Ar(e){if(e.state.focused){var t=e.display;clearInterval(t.blinker);var r=!0;t.cursorDiv.style.visibility="",e.options.cursorBlinkRate>0?t.blinker=setInterval(function(){return t.cursorDiv.style.visibility=(r=!r)?"":"hidden"},e.options.cursorBlinkRate):e.options.cursorBlinkRate<0&&(t.cursorDiv.style.visibility="hidden")}}function Wr(e){e.state.focused||(e.display.input.focus(),Hr(e))}function Dr(e){e.state.delayingBlurEvent=!0,setTimeout(function(){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1,Fr(e))},100)}function Hr(e,t){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1),"nocursor"!=e.options.readOnly&&(e.state.focused||(Te(e,"focus",e,t),e.state.focused=!0,s(e.display.wrapper,"CodeMirror-focused"),e.curOp||e.display.selForContextMenu==e.doc.sel||(e.display.input.reset(),ml&&setTimeout(function(){return e.display.input.reset(!0)},20)),e.display.input.receivedFocus()),Ar(e))}function Fr(e,t){e.state.delayingBlurEvent||(e.state.focused&&(Te(e,"blur",e,t),e.state.focused=!1,Fl(e.display.wrapper,"CodeMirror-focused")),clearInterval(e.display.blinker),setTimeout(function(){e.state.focused||(e.display.shift=!1)},150))}function Er(e){for(var t=e.display,r=t.lineDiv.offsetTop,n=0;n<t.view.length;n++){var i=t.view[n],o=void 0;if(!i.hidden){if(gl&&vl<8){var l=i.node.offsetTop+i.node.offsetHeight;o=l-r,r=l}else{var s=i.node.getBoundingClientRect();o=s.bottom-s.top}var a=i.line.height-o;if(o<2&&(o=mr(t)),(a>.005||a<-.005)&&(A(i.line,o),Pr(i.line),i.rest))for(var u=0;u<i.rest.length;u++)Pr(i.rest[u])}}}function Pr(e){if(e.widgets)for(var t=0;t<e.widgets.length;++t)e.widgets[t].height=e.widgets[t].node.parentNode.offsetHeight}function Ir(e,t,r){var n=r&&null!=r.top?Math.max(0,r.top):e.scroller.scrollTop;n=Math.floor(n-Et(e));var i=r&&null!=r.bottom?r.bottom:n+e.wrapper.clientHeight,o=D(t,n),l=D(t,i);if(r&&r.ensure){var s=r.ensure.from.line,a=r.ensure.to.line;s<o?(o=s,l=D(t,ye(M(t,s))+e.wrapper.clientHeight)):Math.min(a,t.lastLine())>=l&&(o=D(t,ye(M(t,a))-e.wrapper.clientHeight),l=a)}return{from:o,to:Math.max(l,o+1)}}function zr(e){var t=e.display,r=t.view;if(t.alignWidgets||t.gutters.firstChild&&e.options.fixedGutter){for(var n=wr(t)-t.scroller.scrollLeft+e.doc.scrollLeft,i=t.gutters.offsetWidth,o=n+"px",l=0;l<r.length;l++)if(!r[l].hidden){e.options.fixedGutter&&(r[l].gutter&&(r[l].gutter.style.left=o),r[l].gutterBackground&&(r[l].gutterBackground.style.left=o));var s=r[l].alignable;if(s)for(var a=0;a<s.length;a++)s[a].style.left=o}e.options.fixedGutter&&(t.gutters.style.left=n+i+"px")}}function Rr(e){if(!e.options.lineNumbers)return!1;var t=e.doc,r=F(e.options,t.first+t.size-1),i=e.display;if(r.length!=i.lineNumChars){var o=i.measure.appendChild(n("div",[n("div",r)],"CodeMirror-linenumber CodeMirror-gutter-elt")),l=o.firstChild.offsetWidth,s=o.offsetWidth-l;return i.lineGutter.style.width="",i.lineNumInnerWidth=Math.max(l,i.lineGutter.offsetWidth-s)+1,i.lineNumWidth=i.lineNumInnerWidth+s,i.lineNumChars=i.lineNumInnerWidth?r.length:-1,i.lineGutter.style.width=i.lineNumWidth+"px",Wn(e),!0}return!1}function Br(e,t){if(!Me(e,"scrollCursorIntoView")){var r=e.display,i=r.sizer.getBoundingClientRect(),o=null;if(t.top+i.top<0?o=!0:t.bottom+i.top>(window.innerHeight||document.documentElement.clientHeight)&&(o=!1),null!=o&&!Sl){var l=n("div","​",null,"position: absolute;\n                         top: "+(t.top-r.viewOffset-Et(e.display))+"px;\n                         height: "+(t.bottom-t.top+zt(e)+r.barHeight)+"px;\n                         left: "+t.left+"px; width: "+Math.max(2,t.right-t.left)+"px;");e.display.lineSpace.appendChild(l),l.scrollIntoView(o),e.display.lineSpace.removeChild(l)}}}function Gr(e,t,r,n){null==n&&(n=0);var i;e.options.lineWrapping||t!=r||(r="before"==(t=t.ch?E(t.line,"before"==t.sticky?t.ch-1:t.ch,"after"):t).sticky?E(t.line,t.ch+1,"before"):t);for(var o=0;o<5;o++){var l=!1,s=sr(e,t),a=r&&r!=t?sr(e,r):s,u=Vr(e,i={left:Math.min(s.left,a.left),top:Math.min(s.top,a.top)-n,right:Math.max(s.left,a.left),bottom:Math.max(s.bottom,a.bottom)+n}),c=e.doc.scrollTop,f=e.doc.scrollLeft;if(null!=u.scrollTop&&(qr(e,u.scrollTop),Math.abs(e.doc.scrollTop-c)>1&&(l=!0)),null!=u.scrollLeft&&(Qr(e,u.scrollLeft),Math.abs(e.doc.scrollLeft-f)>1&&(l=!0)),!l)break}return i}function Ur(e,t){var r=Vr(e,t);null!=r.scrollTop&&qr(e,r.scrollTop),null!=r.scrollLeft&&Qr(e,r.scrollLeft)}function Vr(e,t){var r=e.display,n=mr(e.display);t.top<0&&(t.top=0);var i=e.curOp&&null!=e.curOp.scrollTop?e.curOp.scrollTop:r.scroller.scrollTop,o=Bt(e),l={};t.bottom-t.top>o&&(t.bottom=t.top+o);var s=e.doc.height+Pt(r),a=t.top<n,u=t.bottom>s-n;if(t.top<i)l.scrollTop=a?0:t.top;else if(t.bottom>i+o){var c=Math.min(t.top,(u?s:t.bottom)-o);c!=i&&(l.scrollTop=c)}var f=e.curOp&&null!=e.curOp.scrollLeft?e.curOp.scrollLeft:r.scroller.scrollLeft,h=Rt(e)-(e.options.fixedGutter?r.gutters.offsetWidth:0),d=t.right-t.left>h;return d&&(t.right=t.left+h),t.left<10?l.scrollLeft=0:t.left<f?l.scrollLeft=Math.max(0,t.left-(d?0:10)):t.right>h+f-3&&(l.scrollLeft=t.right+(d?0:10)-h),l}function Kr(e,t){null!=t&&(_r(e),e.curOp.scrollTop=(null==e.curOp.scrollTop?e.doc.scrollTop:e.curOp.scrollTop)+t)}function jr(e){_r(e);var t=e.getCursor();e.curOp.scrollToPos={from:t,to:t,margin:e.options.cursorScrollMargin}}function Xr(e,t,r){null==t&&null==r||_r(e),null!=t&&(e.curOp.scrollLeft=t),null!=r&&(e.curOp.scrollTop=r)}function Yr(e,t){_r(e),e.curOp.scrollToPos=t}function _r(e){var t=e.curOp.scrollToPos;t&&(e.curOp.scrollToPos=null,$r(e,ar(e,t.from),ar(e,t.to),t.margin))}function $r(e,t,r,n){var i=Vr(e,{left:Math.min(t.left,r.left),top:Math.min(t.top,r.top)-n,right:Math.max(t.right,r.right),bottom:Math.max(t.bottom,r.bottom)+n});Xr(e,i.scrollLeft,i.scrollTop)}function qr(e,t){Math.abs(e.doc.scrollTop-t)<2||(fl||On(e,{top:t}),Zr(e,t,!0),fl&&On(e),Cn(e,100))}function Zr(e,t,r){t=Math.min(e.display.scroller.scrollHeight-e.display.scroller.clientHeight,t),(e.display.scroller.scrollTop!=t||r)&&(e.doc.scrollTop=t,e.display.scrollbars.setScrollTop(t),e.display.scroller.scrollTop!=t&&(e.display.scroller.scrollTop=t))}function Qr(e,t,r,n){t=Math.min(t,e.display.scroller.scrollWidth-e.display.scroller.clientWidth),(r?t==e.doc.scrollLeft:Math.abs(e.doc.scrollLeft-t)<2)&&!n||(e.doc.scrollLeft=t,zr(e),e.display.scroller.scrollLeft!=t&&(e.display.scroller.scrollLeft=t),e.display.scrollbars.setScrollLeft(t))}function Jr(e){var t=e.display,r=t.gutters.offsetWidth,n=Math.round(e.doc.height+Pt(e.display));return{clientHeight:t.scroller.clientHeight,viewHeight:t.wrapper.clientHeight,scrollWidth:t.scroller.scrollWidth,clientWidth:t.scroller.clientWidth,viewWidth:t.wrapper.clientWidth,barLeft:e.options.fixedGutter?r:0,docHeight:n,scrollHeight:n+zt(e)+t.barHeight,nativeBarWidth:t.nativeBarWidth,gutterWidth:r}}function en(e,t){t||(t=Jr(e));var r=e.display.barWidth,n=e.display.barHeight;tn(e,t);for(var i=0;i<4&&r!=e.display.barWidth||n!=e.display.barHeight;i++)r!=e.display.barWidth&&e.options.lineWrapping&&Er(e),tn(e,Jr(e)),r=e.display.barWidth,n=e.display.barHeight}function tn(e,t){var r=e.display,n=r.scrollbars.update(t);r.sizer.style.paddingRight=(r.barWidth=n.right)+"px",r.sizer.style.paddingBottom=(r.barHeight=n.bottom)+"px",r.heightForcer.style.borderBottom=n.bottom+"px solid transparent",n.right&&n.bottom?(r.scrollbarFiller.style.display="block",r.scrollbarFiller.style.height=n.bottom+"px",r.scrollbarFiller.style.width=n.right+"px"):r.scrollbarFiller.style.display="",n.bottom&&e.options.coverGutterNextToScrollbar&&e.options.fixedGutter?(r.gutterFiller.style.display="block",r.gutterFiller.style.height=n.bottom+"px",r.gutterFiller.style.width=t.gutterWidth+"px"):r.gutterFiller.style.display=""}function rn(e){e.display.scrollbars&&(e.display.scrollbars.clear(),e.display.scrollbars.addClass&&Fl(e.display.wrapper,e.display.scrollbars.addClass)),e.display.scrollbars=new ws[e.options.scrollbarStyle](function(t){e.display.wrapper.insertBefore(t,e.display.scrollbarFiller),Ql(t,"mousedown",function(){e.state.focused&&setTimeout(function(){return e.display.input.focus()},0)}),t.setAttribute("cm-not-content","true")},function(t,r){"horizontal"==r?Qr(e,t):qr(e,t)},e),e.display.scrollbars.addClass&&s(e.display.wrapper,e.display.scrollbars.addClass)}function nn(e){e.curOp={cm:e,viewChanged:!1,startHeight:e.doc.height,forceUpdate:!1,updateInput:null,typing:!1,changeObjs:null,cursorActivityHandlers:null,cursorActivityCalled:0,selectionChanged:!1,updateMaxLine:!1,scrollLeft:null,scrollTop:null,scrollToPos:null,focus:!1,id:++xs},vt(e.curOp)}function on(e){yt(e.curOp,function(e){for(var t=0;t<e.ops.length;t++)e.ops[t].cm.curOp=null;ln(e)})}function ln(e){for(var t=e.ops,r=0;r<t.length;r++)sn(t[r]);for(var n=0;n<t.length;n++)an(t[n]);for(var i=0;i<t.length;i++)un(t[i]);for(var o=0;o<t.length;o++)cn(t[o]);for(var l=0;l<t.length;l++)fn(t[l])}function sn(e){var t=e.cm,r=t.display;Ln(t),e.updateMaxLine&&we(t),e.mustUpdate=e.viewChanged||e.forceUpdate||null!=e.scrollTop||e.scrollToPos&&(e.scrollToPos.from.line<r.viewFrom||e.scrollToPos.to.line>=r.viewTo)||r.maxLineChanged&&t.options.lineWrapping,e.update=e.mustUpdate&&new Cs(t,e.mustUpdate&&{top:e.scrollTop,ensure:e.scrollToPos},e.forceUpdate)}function an(e){e.updatedDisplay=e.mustUpdate&&Mn(e.cm,e.update)}function un(e){var t=e.cm,r=t.display;e.updatedDisplay&&Er(t),e.barMeasure=Jr(t),r.maxLineChanged&&!t.options.lineWrapping&&(e.adjustWidthTo=Kt(t,r.maxLine,r.maxLine.text.length).left+3,t.display.sizerWidth=e.adjustWidthTo,e.barMeasure.scrollWidth=Math.max(r.scroller.clientWidth,r.sizer.offsetLeft+e.adjustWidthTo+zt(t)+t.display.barWidth),e.maxScrollLeft=Math.max(0,r.sizer.offsetLeft+e.adjustWidthTo-Rt(t))),(e.updatedDisplay||e.selectionChanged)&&(e.preparedSelection=r.input.prepareSelection())}function cn(e){var t=e.cm;null!=e.adjustWidthTo&&(t.display.sizer.style.minWidth=e.adjustWidthTo+"px",e.maxScrollLeft<t.doc.scrollLeft&&Qr(t,Math.min(t.display.scroller.scrollLeft,e.maxScrollLeft),!0),t.display.maxLineChanged=!1);var r=e.focus&&e.focus==l();e.preparedSelection&&t.display.input.showSelection(e.preparedSelection,r),(e.updatedDisplay||e.startHeight!=t.doc.height)&&en(t,e.barMeasure),e.updatedDisplay&&Dn(t,e.barMeasure),e.selectionChanged&&Ar(t),t.state.focused&&e.updateInput&&t.display.input.reset(e.typing),r&&Wr(e.cm)}function fn(e){var t=e.cm,r=t.display,n=t.doc;e.updatedDisplay&&Nn(t,e.update),null==r.wheelStartX||null==e.scrollTop&&null==e.scrollLeft&&!e.scrollToPos||(r.wheelStartX=r.wheelStartY=null),null!=e.scrollTop&&Zr(t,e.scrollTop,e.forceScroll),null!=e.scrollLeft&&Qr(t,e.scrollLeft,!0,!0),e.scrollToPos&&Br(t,Gr(t,U(n,e.scrollToPos.from),U(n,e.scrollToPos.to),e.scrollToPos.margin));var i=e.maybeHiddenMarkers,o=e.maybeUnhiddenMarkers;if(i)for(var l=0;l<i.length;++l)i[l].lines.length||Te(i[l],"hide");if(o)for(var s=0;s<o.length;++s)o[s].lines.length&&Te(o[s],"unhide");r.wrapper.offsetHeight&&(n.scrollTop=t.display.scroller.scrollTop),e.changeObjs&&Te(t,"changes",t,e.changeObjs),e.update&&e.update.finish()}function hn(e,t){if(e.curOp)return t();nn(e);try{return t()}finally{on(e)}}function dn(e,t){return function(){if(e.curOp)return t.apply(e,arguments);nn(e);try{return t.apply(e,arguments)}finally{on(e)}}}function pn(e){return function(){if(this.curOp)return e.apply(this,arguments);nn(this);try{return e.apply(this,arguments)}finally{on(this)}}}function gn(e){return function(){var t=this.cm;if(!t||t.curOp)return e.apply(this,arguments);nn(t);try{return e.apply(this,arguments)}finally{on(t)}}}function vn(e,t,r,n){null==t&&(t=e.doc.first),null==r&&(r=e.doc.first+e.doc.size),n||(n=0);var i=e.display;if(n&&r<i.viewTo&&(null==i.updateLineNumbers||i.updateLineNumbers>t)&&(i.updateLineNumbers=t),e.curOp.viewChanged=!0,t>=i.viewTo)_l&&pe(e.doc,t)<i.viewTo&&yn(e);else if(r<=i.viewFrom)_l&&ge(e.doc,r+n)>i.viewFrom?yn(e):(i.viewFrom+=n,i.viewTo+=n);else if(t<=i.viewFrom&&r>=i.viewTo)yn(e);else if(t<=i.viewFrom){var o=bn(e,r,r+n,1);o?(i.view=i.view.slice(o.index),i.viewFrom=o.lineN,i.viewTo+=n):yn(e)}else if(r>=i.viewTo){var l=bn(e,t,t,-1);l?(i.view=i.view.slice(0,l.index),i.viewTo=l.lineN):yn(e)}else{var s=bn(e,t,t,-1),a=bn(e,r,r+n,1);s&&a?(i.view=i.view.slice(0,s.index).concat(gt(e,s.lineN,a.lineN)).concat(i.view.slice(a.index)),i.viewTo+=n):yn(e)}var u=i.externalMeasured;u&&(r<u.lineN?u.lineN+=n:t<u.lineN+u.size&&(i.externalMeasured=null))}function mn(e,t,r){e.curOp.viewChanged=!0;var n=e.display,i=e.display.externalMeasured;if(i&&t>=i.lineN&&t<i.lineN+i.size&&(n.externalMeasured=null),!(t<n.viewFrom||t>=n.viewTo)){var o=n.view[Lr(e,t)];if(null!=o.node){var l=o.changes||(o.changes=[]);-1==h(l,r)&&l.push(r)}}}function yn(e){e.display.viewFrom=e.display.viewTo=e.doc.first,e.display.view=[],e.display.viewOffset=0}function bn(e,t,r,n){var i,o=Lr(e,t),l=e.display.view;if(!_l||r==e.doc.first+e.doc.size)return{index:o,lineN:r};for(var s=e.display.viewFrom,a=0;a<o;a++)s+=l[a].size;if(s!=t){if(n>0){if(o==l.length-1)return null;i=s+l[o].size-t,o++}else i=s-t;t+=i,r+=i}for(;pe(e.doc,r)!=r;){if(o==(n<0?0:l.length-1))return null;r+=n*l[o-(n<0?1:0)].size,o+=n}return{index:o,lineN:r}}function wn(e,t,r){var n=e.display;0==n.view.length||t>=n.viewTo||r<=n.viewFrom?(n.view=gt(e,t,r),n.viewFrom=t):(n.viewFrom>t?n.view=gt(e,t,n.viewFrom).concat(n.view):n.viewFrom<t&&(n.view=n.view.slice(Lr(e,t))),n.viewFrom=t,n.viewTo<r?n.view=n.view.concat(gt(e,n.viewTo,r)):n.viewTo>r&&(n.view=n.view.slice(0,Lr(e,r)))),n.viewTo=r}function xn(e){for(var t=e.display.view,r=0,n=0;n<t.length;n++){var i=t[n];i.hidden||i.node&&!i.changes||++r}return r}function Cn(e,t){e.doc.highlightFrontier<e.display.viewTo&&e.state.highlight.set(t,u(Sn,e))}function Sn(e){var t=e.doc;if(!(t.highlightFrontier>=e.display.viewTo)){var r=+new Date+e.options.workTime,n=$e(e,t.highlightFrontier),i=[];t.iter(n.line,Math.min(t.first+t.size,e.display.viewTo+500),function(o){if(n.line>=e.display.viewFrom){var l=o.styles,s=o.text.length>e.options.maxHighlightLength?Ke(t.mode,n.state):null,a=Ye(e,o,n,!0);s&&(n.state=s),o.styles=a.styles;var u=o.styleClasses,c=a.classes;c?o.styleClasses=c:u&&(o.styleClasses=null);for(var f=!l||l.length!=o.styles.length||u!=c&&(!u||!c||u.bgClass!=c.bgClass||u.textClass!=c.textClass),h=0;!f&&h<l.length;++h)f=l[h]!=o.styles[h];f&&i.push(n.line),o.stateAfter=n.save(),n.nextLine()}else o.text.length<=e.options.maxHighlightLength&&qe(e,o.text,n),o.stateAfter=n.line%5==0?n.save():null,n.nextLine();if(+new Date>r)return Cn(e,e.options.workDelay),!0}),t.highlightFrontier=n.line,t.modeFrontier=Math.max(t.modeFrontier,n.line),i.length&&hn(e,function(){for(var t=0;t<i.length;t++)mn(e,i[t],"text")})}}function Ln(e){var t=e.display;!t.scrollbarsClipped&&t.scroller.offsetWidth&&(t.nativeBarWidth=t.scroller.offsetWidth-t.scroller.clientWidth,t.heightForcer.style.height=zt(e)+"px",t.sizer.style.marginBottom=-t.nativeBarWidth+"px",t.sizer.style.borderRightWidth=zt(e)+"px",t.scrollbarsClipped=!0)}function kn(e){if(e.hasFocus())return null;var t=l();if(!t||!o(e.display.lineDiv,t))return null;var r={activeElt:t};if(window.getSelection){var n=window.getSelection();n.anchorNode&&n.extend&&o(e.display.lineDiv,n.anchorNode)&&(r.anchorNode=n.anchorNode,r.anchorOffset=n.anchorOffset,r.focusNode=n.focusNode,r.focusOffset=n.focusOffset)}return r}function Tn(e){if(e&&e.activeElt&&e.activeElt!=l()&&(e.activeElt.focus(),e.anchorNode&&o(document.body,e.anchorNode)&&o(document.body,e.focusNode))){var t=window.getSelection(),r=document.createRange();r.setEnd(e.anchorNode,e.anchorOffset),r.collapse(!1),t.removeAllRanges(),t.addRange(r),t.extend(e.focusNode,e.focusOffset)}}function Mn(e,r){var n=e.display,i=e.doc;if(r.editorIsHidden)return yn(e),!1;if(!r.force&&r.visible.from>=n.viewFrom&&r.visible.to<=n.viewTo&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo)&&n.renderedView==n.view&&0==xn(e))return!1;Rr(e)&&(yn(e),r.dims=br(e));var o=i.first+i.size,l=Math.max(r.visible.from-e.options.viewportMargin,i.first),s=Math.min(o,r.visible.to+e.options.viewportMargin);n.viewFrom<l&&l-n.viewFrom<20&&(l=Math.max(i.first,n.viewFrom)),n.viewTo>s&&n.viewTo-s<20&&(s=Math.min(o,n.viewTo)),_l&&(l=pe(e.doc,l),s=ge(e.doc,s));var a=l!=n.viewFrom||s!=n.viewTo||n.lastWrapHeight!=r.wrapperHeight||n.lastWrapWidth!=r.wrapperWidth;wn(e,l,s),n.viewOffset=ye(M(e.doc,n.viewFrom)),e.display.mover.style.top=n.viewOffset+"px";var u=xn(e);if(!a&&0==u&&!r.force&&n.renderedView==n.view&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo))return!1;var c=kn(e);return u>4&&(n.lineDiv.style.display="none"),An(e,n.updateLineNumbers,r.dims),u>4&&(n.lineDiv.style.display=""),n.renderedView=n.view,Tn(c),t(n.cursorDiv),t(n.selectionDiv),n.gutters.style.height=n.sizer.style.minHeight=0,a&&(n.lastWrapHeight=r.wrapperHeight,n.lastWrapWidth=r.wrapperWidth,Cn(e,400)),n.updateLineNumbers=null,!0}function Nn(e,t){for(var r=t.viewport,n=!0;(n&&e.options.lineWrapping&&t.oldDisplayWidth!=Rt(e)||(r&&null!=r.top&&(r={top:Math.min(e.doc.height+Pt(e.display)-Bt(e),r.top)}),t.visible=Ir(e.display,e.doc,r),!(t.visible.from>=e.display.viewFrom&&t.visible.to<=e.display.viewTo)))&&Mn(e,t);n=!1){Er(e);var i=Jr(e);kr(e),en(e,i),Dn(e,i),t.force=!1}t.signal(e,"update",e),e.display.viewFrom==e.display.reportedViewFrom&&e.display.viewTo==e.display.reportedViewTo||(t.signal(e,"viewportChange",e,e.display.viewFrom,e.display.viewTo),e.display.reportedViewFrom=e.display.viewFrom,e.display.reportedViewTo=e.display.viewTo)}function On(e,t){var r=new Cs(e,t);if(Mn(e,r)){Er(e),Nn(e,r);var n=Jr(e);kr(e),en(e,n),Dn(e,n),r.finish()}}function An(e,r,n){function i(t){var r=t.nextSibling;return ml&&Ml&&e.display.currentWheelTarget==t?t.style.display="none":t.parentNode.removeChild(t),r}for(var o=e.display,l=e.options.lineNumbers,s=o.lineDiv,a=s.firstChild,u=o.view,c=o.viewFrom,f=0;f<u.length;f++){var d=u[f];if(d.hidden);else if(d.node&&d.node.parentNode==s){for(;a!=d.node;)a=i(a);var p=l&&null!=r&&r<=c&&d.lineNumber;d.changes&&(h(d.changes,"gutter")>-1&&(p=!1),xt(e,d,c,n)),p&&(t(d.lineNumber),d.lineNumber.appendChild(document.createTextNode(F(e.options,c)))),a=d.node.nextSibling}else{var g=Ot(e,d,c,n);s.insertBefore(g,a)}c+=d.size}for(;a;)a=i(a)}function Wn(e){var t=e.display.gutters.offsetWidth;e.display.sizer.style.marginLeft=t+"px"}function Dn(e,t){e.display.sizer.style.minHeight=t.docHeight+"px",e.display.heightForcer.style.top=t.docHeight+"px",e.display.gutters.style.height=t.docHeight+e.display.barHeight+zt(e)+"px"}function Hn(e){var r=e.display.gutters,i=e.options.gutters;t(r);for(var o=0;o<i.length;++o){var l=i[o],s=r.appendChild(n("div",null,"CodeMirror-gutter "+l));"CodeMirror-linenumbers"==l&&(e.display.lineGutter=s,s.style.width=(e.display.lineNumWidth||1)+"px")}r.style.display=o?"":"none",Wn(e)}function Fn(e){var t=h(e.gutters,"CodeMirror-linenumbers");-1==t&&e.lineNumbers?e.gutters=e.gutters.concat(["CodeMirror-linenumbers"]):t>-1&&!e.lineNumbers&&(e.gutters=e.gutters.slice(0),e.gutters.splice(t,1))}function En(e){var t=e.wheelDeltaX,r=e.wheelDeltaY;return null==t&&e.detail&&e.axis==e.HORIZONTAL_AXIS&&(t=e.detail),null==r&&e.detail&&e.axis==e.VERTICAL_AXIS?r=e.detail:null==r&&(r=e.wheelDelta),{x:t,y:r}}function Pn(e){var t=En(e);return t.x*=Ls,t.y*=Ls,t}function In(e,t){var r=En(t),n=r.x,i=r.y,o=e.display,l=o.scroller,s=l.scrollWidth>l.clientWidth,a=l.scrollHeight>l.clientHeight;if(n&&s||i&&a){if(i&&Ml&&ml)e:for(var u=t.target,c=o.view;u!=l;u=u.parentNode)for(var f=0;f<c.length;f++)if(c[f].node==u){e.display.currentWheelTarget=u;break e}if(n&&!fl&&!wl&&null!=Ls)return i&&a&&qr(e,Math.max(0,l.scrollTop+i*Ls)),Qr(e,Math.max(0,l.scrollLeft+n*Ls)),(!i||i&&a)&&We(t),void(o.wheelStartX=null);if(i&&null!=Ls){var h=i*Ls,d=e.doc.scrollTop,p=d+o.wrapper.clientHeight;h<0?d=Math.max(0,d+h-50):p=Math.min(e.doc.height,p+h+50),On(e,{top:d,bottom:p})}Ss<20&&(null==o.wheelStartX?(o.wheelStartX=l.scrollLeft,o.wheelStartY=l.scrollTop,o.wheelDX=n,o.wheelDY=i,setTimeout(function(){if(null!=o.wheelStartX){var e=l.scrollLeft-o.wheelStartX,t=l.scrollTop-o.wheelStartY,r=t&&o.wheelDY&&t/o.wheelDY||e&&o.wheelDX&&e/o.wheelDX;o.wheelStartX=o.wheelStartY=null,r&&(Ls=(Ls*Ss+r)/(Ss+1),++Ss)}},200)):(o.wheelDX+=n,o.wheelDY+=i))}}function zn(e,t){var r=e[t];e.sort(function(e,t){return P(e.from(),t.from())}),t=h(e,r);for(var n=1;n<e.length;n++){var i=e[n],o=e[n-1];if(P(o.to(),i.from())>=0){var l=B(o.from(),i.from()),s=R(o.to(),i.to()),a=o.empty()?i.from()==i.head:o.from()==o.head;n<=t&&--t,e.splice(--n,2,new Ts(a?s:l,a?l:s))}}return new ks(e,t)}function Rn(e,t){return new ks([new Ts(e,t||e)],0)}function Bn(e){return e.text?E(e.from.line+e.text.length-1,g(e.text).length+(1==e.text.length?e.from.ch:0)):e.to}function Gn(e,t){if(P(e,t.from)<0)return e;if(P(e,t.to)<=0)return Bn(t);var r=e.line+t.text.length-(t.to.line-t.from.line)-1,n=e.ch;return e.line==t.to.line&&(n+=Bn(t).ch-t.to.ch),E(r,n)}function Un(e,t){for(var r=[],n=0;n<e.sel.ranges.length;n++){var i=e.sel.ranges[n];r.push(new Ts(Gn(i.anchor,t),Gn(i.head,t)))}return zn(r,e.sel.primIndex)}function Vn(e,t,r){return e.line==t.line?E(r.line,e.ch-t.ch+r.ch):E(r.line+(e.line-t.line),e.ch)}function Kn(e,t,r){for(var n=[],i=E(e.first,0),o=i,l=0;l<t.length;l++){var s=t[l],a=Vn(s.from,i,o),u=Vn(Bn(s),i,o);if(i=s.to,o=u,"around"==r){var c=e.sel.ranges[l],f=P(c.head,c.anchor)<0;n[l]=new Ts(f?u:a,f?a:u)}else n[l]=new Ts(a,a)}return new ks(n,e.sel.primIndex)}function jn(e){e.doc.mode=Ue(e.options,e.doc.modeOption),Xn(e)}function Xn(e){e.doc.iter(function(e){e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null)}),e.doc.modeFrontier=e.doc.highlightFrontier=e.doc.first,Cn(e,100),e.state.modeGen++,e.curOp&&vn(e)}function Yn(e,t){return 0==t.from.ch&&0==t.to.ch&&""==g(t.text)&&(!e.cm||e.cm.options.wholeLineUpdateBefore)}function _n(e,t,r,n){function i(e){return r?r[e]:null}function o(e,r,i){it(e,r,i,n),bt(e,"change",e,t)}function l(e,t){for(var r=[],o=e;o<t;++o)r.push(new fs(u[o],i(o),n));return r}var s=t.from,a=t.to,u=t.text,c=M(e,s.line),f=M(e,a.line),h=g(u),d=i(u.length-1),p=a.line-s.line;if(t.full)e.insert(0,l(0,u.length)),e.remove(u.length,e.size-u.length);else if(Yn(e,t)){var v=l(0,u.length-1);o(f,f.text,d),p&&e.remove(s.line,p),v.length&&e.insert(s.line,v)}else if(c==f)if(1==u.length)o(c,c.text.slice(0,s.ch)+h+c.text.slice(a.ch),d);else{var m=l(1,u.length-1);m.push(new fs(h+c.text.slice(a.ch),d,n)),o(c,c.text.slice(0,s.ch)+u[0],i(0)),e.insert(s.line+1,m)}else if(1==u.length)o(c,c.text.slice(0,s.ch)+u[0]+f.text.slice(a.ch),i(0)),e.remove(s.line+1,p);else{o(c,c.text.slice(0,s.ch)+u[0],i(0)),o(f,h+f.text.slice(a.ch),d);var y=l(1,u.length-1);p>1&&e.remove(s.line+1,p-1),e.insert(s.line+1,y)}bt(e,"change",e,t)}function $n(e,t,r){function n(e,i,o){if(e.linked)for(var l=0;l<e.linked.length;++l){var s=e.linked[l];if(s.doc!=i){var a=o&&s.sharedHist;r&&!a||(t(s.doc,a),n(s.doc,e,a))}}}n(e,null,!0)}function qn(e,t){if(t.cm)throw new Error("This document is already in use.");e.doc=t,t.cm=e,Cr(e),jn(e),Zn(e),e.options.lineWrapping||we(e),e.options.mode=t.modeOption,vn(e)}function Zn(e){("rtl"==e.doc.direction?s:Fl)(e.display.lineDiv,"CodeMirror-rtl")}function Qn(e){hn(e,function(){Zn(e),vn(e)})}function Jn(e){this.done=[],this.undone=[],this.undoDepth=1/0,this.lastModTime=this.lastSelTime=0,this.lastOp=this.lastSelOp=null,this.lastOrigin=this.lastSelOrigin=null,this.generation=this.maxGeneration=e||1}function ei(e,t){var r={from:z(t.from),to:Bn(t),text:N(e,t.from,t.to)};return si(e,r,t.from.line,t.to.line+1),$n(e,function(e){return si(e,r,t.from.line,t.to.line+1)},!0),r}function ti(e){for(;e.length&&g(e).ranges;)e.pop()}function ri(e,t){return t?(ti(e.done),g(e.done)):e.done.length&&!g(e.done).ranges?g(e.done):e.done.length>1&&!e.done[e.done.length-2].ranges?(e.done.pop(),g(e.done)):void 0}function ni(e,t,r,n){var i=e.history;i.undone.length=0;var o,l,s=+new Date;if((i.lastOp==n||i.lastOrigin==t.origin&&t.origin&&("+"==t.origin.charAt(0)&&e.cm&&i.lastModTime>s-e.cm.options.historyEventDelay||"*"==t.origin.charAt(0)))&&(o=ri(i,i.lastOp==n)))l=g(o.changes),0==P(t.from,t.to)&&0==P(t.from,l.to)?l.to=Bn(t):o.changes.push(ei(e,t));else{var a=g(i.done);for(a&&a.ranges||li(e.sel,i.done),o={changes:[ei(e,t)],generation:i.generation},i.done.push(o);i.done.length>i.undoDepth;)i.done.shift(),i.done[0].ranges||i.done.shift()}i.done.push(r),i.generation=++i.maxGeneration,i.lastModTime=i.lastSelTime=s,i.lastOp=i.lastSelOp=n,i.lastOrigin=i.lastSelOrigin=t.origin,l||Te(e,"historyAdded")}function ii(e,t,r,n){var i=t.charAt(0);return"*"==i||"+"==i&&r.ranges.length==n.ranges.length&&r.somethingSelected()==n.somethingSelected()&&new Date-e.history.lastSelTime<=(e.cm?e.cm.options.historyEventDelay:500)}function oi(e,t,r,n){var i=e.history,o=n&&n.origin;r==i.lastSelOp||o&&i.lastSelOrigin==o&&(i.lastModTime==i.lastSelTime&&i.lastOrigin==o||ii(e,o,g(i.done),t))?i.done[i.done.length-1]=t:li(t,i.done),i.lastSelTime=+new Date,i.lastSelOrigin=o,i.lastSelOp=r,n&&!1!==n.clearRedo&&ti(i.undone)}function li(e,t){var r=g(t);r&&r.ranges&&r.equals(e)||t.push(e)}function si(e,t,r,n){var i=t["spans_"+e.id],o=0;e.iter(Math.max(e.first,r),Math.min(e.first+e.size,n),function(r){r.markedSpans&&((i||(i=t["spans_"+e.id]={}))[o]=r.markedSpans),++o})}function ai(e){if(!e)return null;for(var t,r=0;r<e.length;++r)e[r].marker.explicitlyCleared?t||(t=e.slice(0,r)):t&&t.push(e[r]);return t?t.length?t:null:e}function ui(e,t){var r=t["spans_"+e.id];if(!r)return null;for(var n=[],i=0;i<t.text.length;++i)n.push(ai(r[i]));return n}function ci(e,t){var r=ui(e,t),n=J(e,t);if(!r)return n;if(!n)return r;for(var i=0;i<r.length;++i){var o=r[i],l=n[i];if(o&&l)e:for(var s=0;s<l.length;++s){for(var a=l[s],u=0;u<o.length;++u)if(o[u].marker==a.marker)continue e;o.push(a)}else l&&(r[i]=l)}return r}function fi(e,t,r){for(var n=[],i=0;i<e.length;++i){var o=e[i];if(o.ranges)n.push(r?ks.prototype.deepCopy.call(o):o);else{var l=o.changes,s=[];n.push({changes:s});for(var a=0;a<l.length;++a){var u=l[a],c=void 0;if(s.push({from:u.from,to:u.to,text:u.text}),t)for(var f in u)(c=f.match(/^spans_(\d+)$/))&&h(t,Number(c[1]))>-1&&(g(s)[f]=u[f],delete u[f])}}}return n}function hi(e,t,r,n){if(n){var i=e.anchor;if(r){var o=P(t,i)<0;o!=P(r,i)<0?(i=t,t=r):o!=P(t,r)<0&&(t=r)}return new Ts(i,t)}return new Ts(r||t,t)}function di(e,t,r,n,i){null==i&&(i=e.cm&&(e.cm.display.shift||e.extend)),bi(e,new ks([hi(e.sel.primary(),t,r,i)],0),n)}function pi(e,t,r){for(var n=[],i=e.cm&&(e.cm.display.shift||e.extend),o=0;o<e.sel.ranges.length;o++)n[o]=hi(e.sel.ranges[o],t[o],null,i);bi(e,zn(n,e.sel.primIndex),r)}function gi(e,t,r,n){var i=e.sel.ranges.slice(0);i[t]=r,bi(e,zn(i,e.sel.primIndex),n)}function vi(e,t,r,n){bi(e,Rn(t,r),n)}function mi(e,t,r){var n={ranges:t.ranges,update:function(t){var r=this;this.ranges=[];for(var n=0;n<t.length;n++)r.ranges[n]=new Ts(U(e,t[n].anchor),U(e,t[n].head))},origin:r&&r.origin};return Te(e,"beforeSelectionChange",e,n),e.cm&&Te(e.cm,"beforeSelectionChange",e.cm,n),n.ranges!=t.ranges?zn(n.ranges,n.ranges.length-1):t}function yi(e,t,r){var n=e.history.done,i=g(n);i&&i.ranges?(n[n.length-1]=t,wi(e,t,r)):bi(e,t,r)}function bi(e,t,r){wi(e,t,r),oi(e,e.sel,e.cm?e.cm.curOp.id:NaN,r)}function wi(e,t,r){(Oe(e,"beforeSelectionChange")||e.cm&&Oe(e.cm,"beforeSelectionChange"))&&(t=mi(e,t,r)),xi(e,Si(e,t,r&&r.bias||(P(t.primary().head,e.sel.primary().head)<0?-1:1),!0)),r&&!1===r.scroll||!e.cm||jr(e.cm)}function xi(e,t){t.equals(e.sel)||(e.sel=t,e.cm&&(e.cm.curOp.updateInput=e.cm.curOp.selectionChanged=!0,Ne(e.cm)),bt(e,"cursorActivity",e))}function Ci(e){xi(e,Si(e,e.sel,null,!1))}function Si(e,t,r,n){for(var i,o=0;o<t.ranges.length;o++){var l=t.ranges[o],s=t.ranges.length==e.sel.ranges.length&&e.sel.ranges[o],a=ki(e,l.anchor,s&&s.anchor,r,n),u=ki(e,l.head,s&&s.head,r,n);(i||a!=l.anchor||u!=l.head)&&(i||(i=t.ranges.slice(0,o)),i[o]=new Ts(a,u))}return i?zn(i,t.primIndex):t}function Li(e,t,r,n,i){var o=M(e,t.line);if(o.markedSpans)for(var l=0;l<o.markedSpans.length;++l){var s=o.markedSpans[l],a=s.marker;if((null==s.from||(a.inclusiveLeft?s.from<=t.ch:s.from<t.ch))&&(null==s.to||(a.inclusiveRight?s.to>=t.ch:s.to>t.ch))){if(i&&(Te(a,"beforeCursorEnter"),a.explicitlyCleared)){if(o.markedSpans){--l;continue}break}if(!a.atomic)continue;if(r){var u=a.find(n<0?1:-1),c=void 0;if((n<0?a.inclusiveRight:a.inclusiveLeft)&&(u=Ti(e,u,-n,u&&u.line==t.line?o:null)),u&&u.line==t.line&&(c=P(u,r))&&(n<0?c<0:c>0))return Li(e,u,t,n,i)}var f=a.find(n<0?-1:1);return(n<0?a.inclusiveLeft:a.inclusiveRight)&&(f=Ti(e,f,n,f.line==t.line?o:null)),f?Li(e,f,t,n,i):null}}return t}function ki(e,t,r,n,i){var o=n||1,l=Li(e,t,r,o,i)||!i&&Li(e,t,r,o,!0)||Li(e,t,r,-o,i)||!i&&Li(e,t,r,-o,!0);return l||(e.cantEdit=!0,E(e.first,0))}function Ti(e,t,r,n){return r<0&&0==t.ch?t.line>e.first?U(e,E(t.line-1)):null:r>0&&t.ch==(n||M(e,t.line)).text.length?t.line<e.first+e.size-1?E(t.line+1,0):null:new E(t.line,t.ch+r)}function Mi(e){e.setSelection(E(e.firstLine(),0),E(e.lastLine()),Gl)}function Ni(e,t,r){var n={canceled:!1,from:t.from,to:t.to,text:t.text,origin:t.origin,cancel:function(){return n.canceled=!0}};return r&&(n.update=function(t,r,i,o){t&&(n.from=U(e,t)),r&&(n.to=U(e,r)),i&&(n.text=i),void 0!==o&&(n.origin=o)}),Te(e,"beforeChange",e,n),e.cm&&Te(e.cm,"beforeChange",e.cm,n),n.canceled?null:{from:n.from,to:n.to,text:n.text,origin:n.origin}}function Oi(e,t,r){if(e.cm){if(!e.cm.curOp)return dn(e.cm,Oi)(e,t,r);if(e.cm.state.suppressEdits)return}if(!(Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"))||(t=Ni(e,t,!0))){var n=Yl&&!r&&te(e,t.from,t.to);if(n)for(var i=n.length-1;i>=0;--i)Ai(e,{from:n[i].from,to:n[i].to,text:i?[""]:t.text,origin:t.origin});else Ai(e,t)}}function Ai(e,t){if(1!=t.text.length||""!=t.text[0]||0!=P(t.from,t.to)){var r=Un(e,t);ni(e,t,r,e.cm?e.cm.curOp.id:NaN),Hi(e,t,r,J(e,t));var n=[];$n(e,function(e,r){r||-1!=h(n,e.history)||(zi(e.history,t),n.push(e.history)),Hi(e,t,null,J(e,t))})}}function Wi(e,t,r){if(!e.cm||!e.cm.state.suppressEdits||r){for(var n,i=e.history,o=e.sel,l="undo"==t?i.done:i.undone,s="undo"==t?i.undone:i.done,a=0;a<l.length&&(n=l[a],r?!n.ranges||n.equals(e.sel):n.ranges);a++);if(a!=l.length){for(i.lastOrigin=i.lastSelOrigin=null;(n=l.pop()).ranges;){if(li(n,s),r&&!n.equals(e.sel))return void bi(e,n,{clearRedo:!1});o=n}var u=[];li(o,s),s.push({changes:u,generation:i.generation}),i.generation=n.generation||++i.maxGeneration;for(var c=Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"),f=n.changes.length-1;f>=0;--f){var d=function(r){var i=n.changes[r];if(i.origin=t,c&&!Ni(e,i,!1))return l.length=0,{};u.push(ei(e,i));var o=r?Un(e,i):g(l);Hi(e,i,o,ci(e,i)),!r&&e.cm&&e.cm.scrollIntoView({from:i.from,to:Bn(i)});var s=[];$n(e,function(e,t){t||-1!=h(s,e.history)||(zi(e.history,i),s.push(e.history)),Hi(e,i,null,ci(e,i))})}(f);if(d)return d.v}}}}function Di(e,t){if(0!=t&&(e.first+=t,e.sel=new ks(v(e.sel.ranges,function(e){return new Ts(E(e.anchor.line+t,e.anchor.ch),E(e.head.line+t,e.head.ch))}),e.sel.primIndex),e.cm)){vn(e.cm,e.first,e.first-t,t);for(var r=e.cm.display,n=r.viewFrom;n<r.viewTo;n++)mn(e.cm,n,"gutter")}}function Hi(e,t,r,n){if(e.cm&&!e.cm.curOp)return dn(e.cm,Hi)(e,t,r,n);if(t.to.line<e.first)Di(e,t.text.length-1-(t.to.line-t.from.line));else if(!(t.from.line>e.lastLine())){if(t.from.line<e.first){var i=t.text.length-1-(e.first-t.from.line);Di(e,i),t={from:E(e.first,0),to:E(t.to.line+i,t.to.ch),text:[g(t.text)],origin:t.origin}}var o=e.lastLine();t.to.line>o&&(t={from:t.from,to:E(o,M(e,o).text.length),text:[t.text[0]],origin:t.origin}),t.removed=N(e,t.from,t.to),r||(r=Un(e,t)),e.cm?Fi(e.cm,t,n):_n(e,t,n),wi(e,r,Gl)}}function Fi(e,t,r){var n=e.doc,i=e.display,o=t.from,l=t.to,s=!1,a=o.line;e.options.lineWrapping||(a=W(fe(M(n,o.line))),n.iter(a,l.line+1,function(e){if(e==i.maxLine)return s=!0,!0})),n.sel.contains(t.from,t.to)>-1&&Ne(e),_n(n,t,r,xr(e)),e.options.lineWrapping||(n.iter(a,o.line+t.text.length,function(e){var t=be(e);t>i.maxLineLength&&(i.maxLine=e,i.maxLineLength=t,i.maxLineChanged=!0,s=!1)}),s&&(e.curOp.updateMaxLine=!0)),nt(n,o.line),Cn(e,400);var u=t.text.length-(l.line-o.line)-1;t.full?vn(e):o.line!=l.line||1!=t.text.length||Yn(e.doc,t)?vn(e,o.line,l.line+1,u):mn(e,o.line,"text");var c=Oe(e,"changes"),f=Oe(e,"change");if(f||c){var h={from:o,to:l,text:t.text,removed:t.removed,origin:t.origin};f&&bt(e,"change",e,h),c&&(e.curOp.changeObjs||(e.curOp.changeObjs=[])).push(h)}e.display.selForContextMenu=null}function Ei(e,t,r,n,i){if(n||(n=r),P(n,r)<0){var o;r=(o=[n,r])[0],n=o[1]}"string"==typeof t&&(t=e.splitLines(t)),Oi(e,{from:r,to:n,text:t,origin:i})}function Pi(e,t,r,n){r<e.line?e.line+=n:t<e.line&&(e.line=t,e.ch=0)}function Ii(e,t,r,n){for(var i=0;i<e.length;++i){var o=e[i],l=!0;if(o.ranges){o.copied||((o=e[i]=o.deepCopy()).copied=!0);for(var s=0;s<o.ranges.length;s++)Pi(o.ranges[s].anchor,t,r,n),Pi(o.ranges[s].head,t,r,n)}else{for(var a=0;a<o.changes.length;++a){var u=o.changes[a];if(r<u.from.line)u.from=E(u.from.line+n,u.from.ch),u.to=E(u.to.line+n,u.to.ch);else if(t<=u.to.line){l=!1;break}}l||(e.splice(0,i+1),i=0)}}}function zi(e,t){var r=t.from.line,n=t.to.line,i=t.text.length-(n-r)-1;Ii(e.done,r,n,i),Ii(e.undone,r,n,i)}function Ri(e,t,r,n){var i=t,o=t;return"number"==typeof t?o=M(e,G(e,t)):i=W(t),null==i?null:(n(o,i)&&e.cm&&mn(e.cm,i,r),o)}function Bi(e){var t=this;this.lines=e,this.parent=null;for(var r=0,n=0;n<e.length;++n)e[n].parent=t,r+=e[n].height;this.height=r}function Gi(e){var t=this;this.children=e;for(var r=0,n=0,i=0;i<e.length;++i){var o=e[i];r+=o.chunkSize(),n+=o.height,o.parent=t}this.size=r,this.height=n,this.parent=null}function Ui(e,t,r){ye(t)<(e.curOp&&e.curOp.scrollTop||e.doc.scrollTop)&&Kr(e,r)}function Vi(e,t,r,n){var i=new Ms(e,r,n),o=e.cm;return o&&i.noHScroll&&(o.display.alignWidgets=!0),Ri(e,t,"widget",function(t){var r=t.widgets||(t.widgets=[]);if(null==i.insertAt?r.push(i):r.splice(Math.min(r.length-1,Math.max(0,i.insertAt)),0,i),i.line=t,o&&!ve(e,t)){var n=ye(t)<e.scrollTop;A(t,t.height+Ht(i)),n&&Kr(o,i.height),o.curOp.forceUpdate=!0}return!0}),bt(o,"lineWidgetAdded",o,i,"number"==typeof t?t:W(t)),i}function Ki(e,t,r,n,o){if(n&&n.shared)return ji(e,t,r,n,o);if(e.cm&&!e.cm.curOp)return dn(e.cm,Ki)(e,t,r,n,o);var l=new Os(e,o),s=P(t,r);if(n&&c(n,l,!1),s>0||0==s&&!1!==l.clearWhenEmpty)return l;if(l.replacedWith&&(l.collapsed=!0,l.widgetNode=i("span",[l.replacedWith],"CodeMirror-widget"),n.handleMouseEvents||l.widgetNode.setAttribute("cm-ignore-events","true"),n.insertLeft&&(l.widgetNode.insertLeft=!0)),l.collapsed){if(ce(e,t.line,t,r,l)||t.line!=r.line&&ce(e,r.line,t,r,l))throw new Error("Inserting collapsed marker partially overlapping an existing one");X()}l.addToHistory&&ni(e,{from:t,to:r,origin:"markText"},e.sel,NaN);var a,u=t.line,f=e.cm;if(e.iter(u,r.line+1,function(e){f&&l.collapsed&&!f.options.lineWrapping&&fe(e)==f.display.maxLine&&(a=!0),l.collapsed&&u!=t.line&&A(e,0),q(e,new Y(l,u==t.line?t.ch:null,u==r.line?r.ch:null)),++u}),l.collapsed&&e.iter(t.line,r.line+1,function(t){ve(e,t)&&A(t,0)}),l.clearOnEnter&&Ql(l,"beforeCursorEnter",function(){return l.clear()}),l.readOnly&&(j(),(e.history.done.length||e.history.undone.length)&&e.clearHistory()),l.collapsed&&(l.id=++Ns,l.atomic=!0),f){if(a&&(f.curOp.updateMaxLine=!0),l.collapsed)vn(f,t.line,r.line+1);else if(l.className||l.title||l.startStyle||l.endStyle||l.css)for(var h=t.line;h<=r.line;h++)mn(f,h,"text");l.atomic&&Ci(f.doc),bt(f,"markerAdded",f,l)}return l}function ji(e,t,r,n,i){(n=c(n)).shared=!1;var o=[Ki(e,t,r,n,i)],l=o[0],s=n.widgetNode;return $n(e,function(e){s&&(n.widgetNode=s.cloneNode(!0)),o.push(Ki(e,U(e,t),U(e,r),n,i));for(var a=0;a<e.linked.length;++a)if(e.linked[a].isParent)return;l=g(o)}),new As(o,l)}function Xi(e){return e.findMarks(E(e.first,0),e.clipPos(E(e.lastLine())),function(e){return e.parent})}function Yi(e,t){for(var r=0;r<t.length;r++){var n=t[r],i=n.find(),o=e.clipPos(i.from),l=e.clipPos(i.to);if(P(o,l)){var s=Ki(e,o,l,n.primary,n.primary.type);n.markers.push(s),s.parent=n}}}function _i(e){for(var t=0;t<e.length;t++)!function(t){var r=e[t],n=[r.primary.doc];$n(r.primary.doc,function(e){return n.push(e)});for(var i=0;i<r.markers.length;i++){var o=r.markers[i];-1==h(n,o.doc)&&(o.parent=null,r.markers.splice(i--,1))}}(t)}function $i(e){var t=this;if(Qi(t),!Me(t,e)&&!Ft(t.display,e)){We(e),gl&&(Hs=+new Date);var r=Sr(t,e,!0),n=e.dataTransfer.files;if(r&&!t.isReadOnly())if(n&&n.length&&window.FileReader&&window.File)for(var i=n.length,o=Array(i),l=0,s=0;s<i;++s)!function(e,n){if(!t.options.allowDropFileTypes||-1!=h(t.options.allowDropFileTypes,e.type)){var s=new FileReader;s.onload=dn(t,function(){var e=s.result;if(/[\x00-\x08\x0e-\x1f]{2}/.test(e)&&(e=""),o[n]=e,++l==i){var a={from:r=U(t.doc,r),to:r,text:t.doc.splitLines(o.join(t.doc.lineSeparator())),origin:"paste"};Oi(t.doc,a),yi(t.doc,Rn(r,Bn(a)))}}),s.readAsText(e)}}(n[s],s);else{if(t.state.draggingText&&t.doc.sel.contains(r)>-1)return t.state.draggingText(e),void setTimeout(function(){return t.display.input.focus()},20);try{var a=e.dataTransfer.getData("Text");if(a){var u;if(t.state.draggingText&&!t.state.draggingText.copy&&(u=t.listSelections()),wi(t.doc,Rn(r,r)),u)for(var c=0;c<u.length;++c)Ei(t.doc,"",u[c].anchor,u[c].head,"drag");t.replaceSelection(a,"around","paste"),t.display.input.focus()}}catch(e){}}}}function qi(e,t){if(gl&&(!e.state.draggingText||+new Date-Hs<100))Fe(t);else if(!Me(e,t)&&!Ft(e.display,t)&&(t.dataTransfer.setData("Text",e.getSelection()),t.dataTransfer.effectAllowed="copyMove",t.dataTransfer.setDragImage&&!xl)){var r=n("img",null,null,"position: fixed; left: 0; top: 0;");r.src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",wl&&(r.width=r.height=1,e.display.wrapper.appendChild(r),r._top=r.offsetTop),t.dataTransfer.setDragImage(r,0,0),wl&&r.parentNode.removeChild(r)}}function Zi(e,t){var i=Sr(e,t);if(i){var o=document.createDocumentFragment();Mr(e,i,o),e.display.dragCursor||(e.display.dragCursor=n("div",null,"CodeMirror-cursors CodeMirror-dragcursors"),e.display.lineSpace.insertBefore(e.display.dragCursor,e.display.cursorDiv)),r(e.display.dragCursor,o)}}function Qi(e){e.display.dragCursor&&(e.display.lineSpace.removeChild(e.display.dragCursor),e.display.dragCursor=null)}function Ji(e){if(document.getElementsByClassName)for(var t=document.getElementsByClassName("CodeMirror"),r=0;r<t.length;r++){var n=t[r].CodeMirror;n&&e(n)}}function eo(){Fs||(to(),Fs=!0)}function to(){var e;Ql(window,"resize",function(){null==e&&(e=setTimeout(function(){e=null,Ji(ro)},100))}),Ql(window,"blur",function(){return Ji(Fr)})}function ro(e){var t=e.display;t.lastWrapHeight==t.wrapper.clientHeight&&t.lastWrapWidth==t.wrapper.clientWidth||(t.cachedCharWidth=t.cachedTextHeight=t.cachedPaddingH=null,t.scrollbarsClipped=!1,e.setSize())}function no(e){var t=e.split(/-(?!$)/);e=t[t.length-1];for(var r,n,i,o,l=0;l<t.length-1;l++){var s=t[l];if(/^(cmd|meta|m)$/i.test(s))o=!0;else if(/^a(lt)?$/i.test(s))r=!0;else if(/^(c|ctrl|control)$/i.test(s))n=!0;else{if(!/^s(hift)?$/i.test(s))throw new Error("Unrecognized modifier name: "+s);i=!0}}return r&&(e="Alt-"+e),n&&(e="Ctrl-"+e),o&&(e="Cmd-"+e),i&&(e="Shift-"+e),e}function io(e){var t={};for(var r in e)if(e.hasOwnProperty(r)){var n=e[r];if(/^(name|fallthrough|(de|at)tach)$/.test(r))continue;if("..."==n){delete e[r];continue}for(var i=v(r.split(" "),no),o=0;o<i.length;o++){var l=void 0,s=void 0;o==i.length-1?(s=i.join(" "),l=n):(s=i.slice(0,o+1).join(" "),l="...");var a=t[s];if(a){if(a!=l)throw new Error("Inconsistent bindings for "+s)}else t[s]=l}delete e[r]}for(var u in t)e[u]=t[u];return e}function oo(e,t,r,n){var i=(t=uo(t)).call?t.call(e,n):t[e];if(!1===i)return"nothing";if("..."===i)return"multi";if(null!=i&&r(i))return"handled";if(t.fallthrough){if("[object Array]"!=Object.prototype.toString.call(t.fallthrough))return oo(e,t.fallthrough,r,n);for(var o=0;o<t.fallthrough.length;o++){var l=oo(e,t.fallthrough[o],r,n);if(l)return l}}}function lo(e){var t="string"==typeof e?e:Es[e.keyCode];return"Ctrl"==t||"Alt"==t||"Shift"==t||"Mod"==t}function so(e,t,r){var n=e;return t.altKey&&"Alt"!=n&&(e="Alt-"+e),(Dl?t.metaKey:t.ctrlKey)&&"Ctrl"!=n&&(e="Ctrl-"+e),(Dl?t.ctrlKey:t.metaKey)&&"Cmd"!=n&&(e="Cmd-"+e),!r&&t.shiftKey&&"Shift"!=n&&(e="Shift-"+e),e}function ao(e,t){if(wl&&34==e.keyCode&&e.char)return!1;var r=Es[e.keyCode];return null!=r&&!e.altGraphKey&&so(r,e,t)}function uo(e){return"string"==typeof e?Rs[e]:e}function co(e,t){for(var r=e.doc.sel.ranges,n=[],i=0;i<r.length;i++){for(var o=t(r[i]);n.length&&P(o.from,g(n).to)<=0;){var l=n.pop();if(P(l.from,o.from)<0){o.from=l.from;break}}n.push(o)}hn(e,function(){for(var t=n.length-1;t>=0;t--)Ei(e.doc,"",n[t].from,n[t].to,"+delete");jr(e)})}function fo(e,t,r){var n=L(e.text,t+r,r);return n<0||n>e.text.length?null:n}function ho(e,t,r){var n=fo(e,t.ch,r);return null==n?null:new E(t.line,n,r<0?"after":"before")}function po(e,t,r,n,i){if(e){var o=Se(r,t.doc.direction);if(o){var l,s=i<0?g(o):o[0],a=i<0==(1==s.level)?"after":"before";if(s.level>0){var u=Xt(t,r);l=i<0?r.text.length-1:0;var c=Yt(t,u,l).top;l=k(function(e){return Yt(t,u,e).top==c},i<0==(1==s.level)?s.from:s.to-1,l),"before"==a&&(l=fo(r,l,1))}else l=i<0?s.to:s.from;return new E(n,l,a)}}return new E(n,i<0?r.text.length:0,i<0?"before":"after")}function go(e,t,r,n){var i=Se(t,e.doc.direction);if(!i)return ho(t,r,n);r.ch>=t.text.length?(r.ch=t.text.length,r.sticky="before"):r.ch<=0&&(r.ch=0,r.sticky="after");var o=Ce(i,r.ch,r.sticky),l=i[o];if("ltr"==e.doc.direction&&l.level%2==0&&(n>0?l.to>r.ch:l.from<r.ch))return ho(t,r,n);var s,a=function(e,r){return fo(t,e instanceof E?e.ch:e,r)},u=function(r){return e.options.lineWrapping?(s=s||Xt(e,t),hr(e,t,s,r)):{begin:0,end:t.text.length}},c=u("before"==r.sticky?a(r,-1):r.ch);if("rtl"==e.doc.direction||1==l.level){var f=1==l.level==n<0,h=a(r,f?1:-1);if(null!=h&&(f?h<=l.to&&h<=c.end:h>=l.from&&h>=c.begin)){var d=f?"before":"after";return new E(r.line,h,d)}}var p=function(e,t,n){for(var o=function(e,t){return t?new E(r.line,a(e,1),"before"):new E(r.line,e,"after")};e>=0&&e<i.length;e+=t){var l=i[e],s=t>0==(1!=l.level),u=s?n.begin:a(n.end,-1);if(l.from<=u&&u<l.to)return o(u,s);if(u=s?l.from:a(l.to,-1),n.begin<=u&&u<n.end)return o(u,s)}},g=p(o+n,n,c);if(g)return g;var v=n>0?c.end:a(c.begin,-1);return null==v||n>0&&v==t.text.length||!(g=p(n>0?0:i.length-1,n,u(v)))?null:g}function vo(e,t){var r=M(e.doc,t),n=fe(r);return n!=r&&(t=W(n)),po(!0,e,n,t,1)}function mo(e,t){var r=M(e.doc,t),n=he(r);return n!=r&&(t=W(n)),po(!0,e,r,t,-1)}function yo(e,t){var r=vo(e,t.line),n=M(e.doc,r.line),i=Se(n,e.doc.direction);if(!i||0==i[0].level){var o=Math.max(0,n.text.search(/\S/)),l=t.line==r.line&&t.ch<=o&&t.ch;return E(r.line,l?0:o,r.sticky)}return r}function bo(e,t,r){if("string"==typeof t&&!(t=Bs[t]))return!1;e.display.input.ensurePolled();var n=e.display.shift,i=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),r&&(e.display.shift=!1),i=t(e)!=Bl}finally{e.display.shift=n,e.state.suppressEdits=!1}return i}function wo(e,t,r){for(var n=0;n<e.state.keyMaps.length;n++){var i=oo(t,e.state.keyMaps[n],r,e);if(i)return i}return e.options.extraKeys&&oo(t,e.options.extraKeys,r,e)||oo(t,e.options.keyMap,r,e)}function xo(e,t,r,n){var i=e.state.keySeq;if(i){if(lo(t))return"handled";Gs.set(50,function(){e.state.keySeq==i&&(e.state.keySeq=null,e.display.input.reset())}),t=i+" "+t}var o=wo(e,t,n);return"multi"==o&&(e.state.keySeq=t),"handled"==o&&bt(e,"keyHandled",e,t,r),"handled"!=o&&"multi"!=o||(We(r),Ar(e)),i&&!o&&/\'$/.test(t)?(We(r),!0):!!o}function Co(e,t){var r=ao(t,!0);return!!r&&(t.shiftKey&&!e.state.keySeq?xo(e,"Shift-"+r,t,function(t){return bo(e,t,!0)})||xo(e,r,t,function(t){if("string"==typeof t?/^go[A-Z]/.test(t):t.motion)return bo(e,t)}):xo(e,r,t,function(t){return bo(e,t)}))}function So(e,t,r){return xo(e,"'"+r+"'",t,function(t){return bo(e,t,!0)})}function Lo(e){var t=this;if(t.curOp.focus=l(),!Me(t,e)){gl&&vl<11&&27==e.keyCode&&(e.returnValue=!1);var r=e.keyCode;t.display.shift=16==r||e.shiftKey;var n=Co(t,e);wl&&(Us=n?r:null,!n&&88==r&&!rs&&(Ml?e.metaKey:e.ctrlKey)&&t.replaceSelection("",null,"cut")),18!=r||/\bCodeMirror-crosshair\b/.test(t.display.lineDiv.className)||ko(t)}}function ko(e){function t(e){18!=e.keyCode&&e.altKey||(Fl(r,"CodeMirror-crosshair"),ke(document,"keyup",t),ke(document,"mouseover",t))}var r=e.display.lineDiv;s(r,"CodeMirror-crosshair"),Ql(document,"keyup",t),Ql(document,"mouseover",t)}function To(e){16==e.keyCode&&(this.doc.sel.shift=!1),Me(this,e)}function Mo(e){var t=this;if(!(Ft(t.display,e)||Me(t,e)||e.ctrlKey&&!e.altKey||Ml&&e.metaKey)){var r=e.keyCode,n=e.charCode;if(wl&&r==Us)return Us=null,void We(e);if(!wl||e.which&&!(e.which<10)||!Co(t,e)){var i=String.fromCharCode(null==n?r:n);"\b"!=i&&(So(t,e,i)||t.display.input.onKeyPress(e))}}}function No(e,t){var r=+new Date;return js&&js.compare(r,e,t)?(Ks=js=null,"triple"):Ks&&Ks.compare(r,e,t)?(js=new Vs(r,e,t),Ks=null,"double"):(Ks=new Vs(r,e,t),js=null,"single")}function Oo(e){var t=this,r=t.display;if(!(Me(t,e)||r.activeTouch&&r.input.supportsTouch()))if(r.input.ensurePolled(),r.shift=e.shiftKey,Ft(r,e))ml||(r.scroller.draggable=!1,setTimeout(function(){return r.scroller.draggable=!0},100));else if(!zo(t,e)){var n=Sr(t,e),i=Pe(e),o=n?No(n,i):"single";window.focus(),1==i&&t.state.selectingText&&t.state.selectingText(e),n&&Ao(t,i,n,o,e)||(1==i?n?Do(t,n,o,e):Ee(e)==r.scroller&&We(e):2==i?(n&&di(t.doc,n),setTimeout(function(){return r.input.focus()},20)):3==i&&(Hl?Ro(t,e):Dr(t)))}}function Ao(e,t,r,n,i){var o="Click";return"double"==n?o="Double"+o:"triple"==n&&(o="Triple"+o),o=(1==t?"Left":2==t?"Middle":"Right")+o,xo(e,so(o,i),i,function(t){if("string"==typeof t&&(t=Bs[t]),!t)return!1;var n=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),n=t(e,r)!=Bl}finally{e.state.suppressEdits=!1}return n})}function Wo(e,t,r){var n=e.getOption("configureMouse"),i=n?n(e,t,r):{};if(null==i.unit){var o=Nl?r.shiftKey&&r.metaKey:r.altKey;i.unit=o?"rectangle":"single"==t?"char":"double"==t?"word":"line"}return(null==i.extend||e.doc.extend)&&(i.extend=e.doc.extend||r.shiftKey),null==i.addNew&&(i.addNew=Ml?r.metaKey:r.ctrlKey),null==i.moveOnDrag&&(i.moveOnDrag=!(Ml?r.altKey:r.ctrlKey)),i}function Do(e,t,r,n){gl?setTimeout(u(Wr,e),0):e.curOp.focus=l();var i,o=Wo(e,r,n),s=e.doc.sel;e.options.dragDrop&&Jl&&!e.isReadOnly()&&"single"==r&&(i=s.contains(t))>-1&&(P((i=s.ranges[i]).from(),t)<0||t.xRel>0)&&(P(i.to(),t)>0||t.xRel<0)?Ho(e,n,t,o):Eo(e,n,t,o)}function Ho(e,t,r,n){var i=e.display,o=!1,l=dn(e,function(t){ml&&(i.scroller.draggable=!1),e.state.draggingText=!1,ke(document,"mouseup",l),ke(document,"mousemove",s),ke(i.scroller,"dragstart",a),ke(i.scroller,"drop",l),o||(We(t),n.addNew||di(e.doc,r,null,null,n.extend),ml||gl&&9==vl?setTimeout(function(){document.body.focus(),i.input.focus()},20):i.input.focus())}),s=function(e){o=o||Math.abs(t.clientX-e.clientX)+Math.abs(t.clientY-e.clientY)>=10},a=function(){return o=!0};ml&&(i.scroller.draggable=!0),e.state.draggingText=l,l.copy=!n.moveOnDrag,i.scroller.dragDrop&&i.scroller.dragDrop(),Ql(document,"mouseup",l),Ql(document,"mousemove",s),Ql(i.scroller,"dragstart",a),Ql(i.scroller,"drop",l),Dr(e),setTimeout(function(){return i.input.focus()},20)}function Fo(e,t,r){if("char"==r)return new Ts(t,t);if("word"==r)return e.findWordAt(t);if("line"==r)return new Ts(E(t.line,0),U(e.doc,E(t.line+1,0)));var n=r(e,t);return new Ts(n.from,n.to)}function Eo(e,t,r,n){function i(t){if(0!=P(m,t))if(m=t,"rectangle"==n.unit){for(var i=[],o=e.options.tabSize,l=f(M(u,r.line).text,r.ch,o),s=f(M(u,t.line).text,t.ch,o),a=Math.min(l,s),g=Math.max(l,s),v=Math.min(r.line,t.line),y=Math.min(e.lastLine(),Math.max(r.line,t.line));v<=y;v++){var b=M(u,v).text,w=d(b,a,o);a==g?i.push(new Ts(E(v,w),E(v,w))):b.length>w&&i.push(new Ts(E(v,w),E(v,d(b,g,o))))}i.length||i.push(new Ts(r,r)),bi(u,zn(p.ranges.slice(0,h).concat(i),h),{origin:"*mouse",scroll:!1}),e.scrollIntoView(t)}else{var x,C=c,S=Fo(e,t,n.unit),L=C.anchor;P(S.anchor,L)>0?(x=S.head,L=B(C.from(),S.anchor)):(x=S.anchor,L=R(C.to(),S.head));var k=p.ranges.slice(0);k[h]=Po(e,new Ts(U(u,L),x)),bi(u,zn(k,h),Ul)}}function o(t){var r=++b,s=Sr(e,t,!0,"rectangle"==n.unit);if(s)if(0!=P(s,m)){e.curOp.focus=l(),i(s);var c=Ir(a,u);(s.line>=c.to||s.line<c.from)&&setTimeout(dn(e,function(){b==r&&o(t)}),150)}else{var f=t.clientY<y.top?-20:t.clientY>y.bottom?20:0;f&&setTimeout(dn(e,function(){b==r&&(a.scroller.scrollTop+=f,o(t))}),50)}}function s(t){e.state.selectingText=!1,b=1/0,We(t),a.input.focus(),ke(document,"mousemove",w),ke(document,"mouseup",x),u.history.lastSelOrigin=null}var a=e.display,u=e.doc;We(t);var c,h,p=u.sel,g=p.ranges;if(n.addNew&&!n.extend?(h=u.sel.contains(r),c=h>-1?g[h]:new Ts(r,r)):(c=u.sel.primary(),h=u.sel.primIndex),"rectangle"==n.unit)n.addNew||(c=new Ts(r,r)),r=Sr(e,t,!0,!0),h=-1;else{var v=Fo(e,r,n.unit);c=n.extend?hi(c,v.anchor,v.head,n.extend):v}n.addNew?-1==h?(h=g.length,bi(u,zn(g.concat([c]),h),{scroll:!1,origin:"*mouse"})):g.length>1&&g[h].empty()&&"char"==n.unit&&!n.extend?(bi(u,zn(g.slice(0,h).concat(g.slice(h+1)),0),{scroll:!1,origin:"*mouse"}),p=u.sel):gi(u,h,c,Ul):(h=0,bi(u,new ks([c],0),Ul),p=u.sel);var m=r,y=a.wrapper.getBoundingClientRect(),b=0,w=dn(e,function(e){Pe(e)?o(e):s(e)}),x=dn(e,s);e.state.selectingText=x,Ql(document,"mousemove",w),Ql(document,"mouseup",x)}function Po(e,t){var r=t.anchor,n=t.head,i=M(e.doc,r.line);if(0==P(r,n)&&r.sticky==n.sticky)return t;var o=Se(i);if(!o)return t;var l=Ce(o,r.ch,r.sticky),s=o[l];if(s.from!=r.ch&&s.to!=r.ch)return t;var a=l+(s.from==r.ch==(1!=s.level)?0:1);if(0==a||a==o.length)return t;var u;if(n.line!=r.line)u=(n.line-r.line)*("ltr"==e.doc.direction?1:-1)>0;else{var c=Ce(o,n.ch,n.sticky),f=c-l||(n.ch-r.ch)*(1==s.level?-1:1);u=c==a-1||c==a?f<0:f>0}var h=o[a+(u?-1:0)],d=u==(1==h.level),p=d?h.from:h.to,g=d?"after":"before";return r.ch==p&&r.sticky==g?t:new Ts(new E(r.line,p,g),n)}function Io(e,t,r,n){var i,o;if(t.touches)i=t.touches[0].clientX,o=t.touches[0].clientY;else try{i=t.clientX,o=t.clientY}catch(t){return!1}if(i>=Math.floor(e.display.gutters.getBoundingClientRect().right))return!1;n&&We(t);var l=e.display,s=l.lineDiv.getBoundingClientRect();if(o>s.bottom||!Oe(e,r))return He(t);o-=s.top-l.viewOffset;for(var a=0;a<e.options.gutters.length;++a){var u=l.gutters.childNodes[a];if(u&&u.getBoundingClientRect().right>=i)return Te(e,r,e,D(e.doc,o),e.options.gutters[a],t),He(t)}}function zo(e,t){return Io(e,t,"gutterClick",!0)}function Ro(e,t){Ft(e.display,t)||Bo(e,t)||Me(e,t,"contextmenu")||e.display.input.onContextMenu(t)}function Bo(e,t){return!!Oe(e,"gutterContextMenu")&&Io(e,t,"gutterContextMenu",!1)}function Go(e){e.display.wrapper.className=e.display.wrapper.className.replace(/\s*cm-s-\S+/g,"")+e.options.theme.replace(/(^|\s)\s*/g," cm-s-"),er(e)}function Uo(e){Hn(e),vn(e),zr(e)}function Vo(e,t,r){if(!t!=!(r&&r!=Xs)){var n=e.display.dragFunctions,i=t?Ql:ke;i(e.display.scroller,"dragstart",n.start),i(e.display.scroller,"dragenter",n.enter),i(e.display.scroller,"dragover",n.over),i(e.display.scroller,"dragleave",n.leave),i(e.display.scroller,"drop",n.drop)}}function Ko(e){e.options.lineWrapping?(s(e.display.wrapper,"CodeMirror-wrap"),e.display.sizer.style.minWidth="",e.display.sizerWidth=null):(Fl(e.display.wrapper,"CodeMirror-wrap"),we(e)),Cr(e),vn(e),er(e),setTimeout(function(){return en(e)},100)}function jo(e,t){var r=this;if(!(this instanceof jo))return new jo(e,t);this.options=t=t?c(t):{},c(Ys,t,!1),Fn(t);var n=t.value;"string"==typeof n&&(n=new Ds(n,t.mode,null,t.lineSeparator,t.direction)),this.doc=n;var i=new jo.inputStyles[t.inputStyle](this),o=this.display=new T(e,n,i);o.wrapper.CodeMirror=this,Hn(this),Go(this),t.lineWrapping&&(this.display.wrapper.className+=" CodeMirror-wrap"),rn(this),this.state={keyMaps:[],overlays:[],modeGen:0,overwrite:!1,delayingBlurEvent:!1,focused:!1,suppressEdits:!1,pasteIncoming:!1,cutIncoming:!1,selectingText:!1,draggingText:!1,highlight:new Pl,keySeq:null,specialChars:null},t.autofocus&&!Tl&&o.input.focus(),gl&&vl<11&&setTimeout(function(){return r.display.input.reset(!0)},20),Xo(this),eo(),nn(this),this.curOp.forceUpdate=!0,qn(this,n),t.autofocus&&!Tl||this.hasFocus()?setTimeout(u(Hr,this),20):Fr(this);for(var l in _s)_s.hasOwnProperty(l)&&_s[l](r,t[l],Xs);Rr(this),t.finishInit&&t.finishInit(this);for(var s=0;s<$s.length;++s)$s[s](r);on(this),ml&&t.lineWrapping&&"optimizelegibility"==getComputedStyle(o.lineDiv).textRendering&&(o.lineDiv.style.textRendering="auto")}function Xo(e){function t(){i.activeTouch&&(o=setTimeout(function(){return i.activeTouch=null},1e3),(l=i.activeTouch).end=+new Date)}function r(e){if(1!=e.touches.length)return!1;var t=e.touches[0];return t.radiusX<=1&&t.radiusY<=1}function n(e,t){if(null==t.left)return!0;var r=t.left-e.left,n=t.top-e.top;return r*r+n*n>400}var i=e.display;Ql(i.scroller,"mousedown",dn(e,Oo)),gl&&vl<11?Ql(i.scroller,"dblclick",dn(e,function(t){if(!Me(e,t)){var r=Sr(e,t);if(r&&!zo(e,t)&&!Ft(e.display,t)){We(t);var n=e.findWordAt(r);di(e.doc,n.anchor,n.head)}}})):Ql(i.scroller,"dblclick",function(t){return Me(e,t)||We(t)}),Hl||Ql(i.scroller,"contextmenu",function(t){return Ro(e,t)});var o,l={end:0};Ql(i.scroller,"touchstart",function(t){if(!Me(e,t)&&!r(t)&&!zo(e,t)){i.input.ensurePolled(),clearTimeout(o);var n=+new Date;i.activeTouch={start:n,moved:!1,prev:n-l.end<=300?l:null},1==t.touches.length&&(i.activeTouch.left=t.touches[0].pageX,i.activeTouch.top=t.touches[0].pageY)}}),Ql(i.scroller,"touchmove",function(){i.activeTouch&&(i.activeTouch.moved=!0)}),Ql(i.scroller,"touchend",function(r){var o=i.activeTouch;if(o&&!Ft(i,r)&&null!=o.left&&!o.moved&&new Date-o.start<300){var l,s=e.coordsChar(i.activeTouch,"page");l=!o.prev||n(o,o.prev)?new Ts(s,s):!o.prev.prev||n(o,o.prev.prev)?e.findWordAt(s):new Ts(E(s.line,0),U(e.doc,E(s.line+1,0))),e.setSelection(l.anchor,l.head),e.focus(),We(r)}t()}),Ql(i.scroller,"touchcancel",t),Ql(i.scroller,"scroll",function(){i.scroller.clientHeight&&(qr(e,i.scroller.scrollTop),Qr(e,i.scroller.scrollLeft,!0),Te(e,"scroll",e))}),Ql(i.scroller,"mousewheel",function(t){return In(e,t)}),Ql(i.scroller,"DOMMouseScroll",function(t){return In(e,t)}),Ql(i.wrapper,"scroll",function(){return i.wrapper.scrollTop=i.wrapper.scrollLeft=0}),i.dragFunctions={enter:function(t){Me(e,t)||Fe(t)},over:function(t){Me(e,t)||(Zi(e,t),Fe(t))},start:function(t){return qi(e,t)},drop:dn(e,$i),leave:function(t){Me(e,t)||Qi(e)}};var s=i.input.getField();Ql(s,"keyup",function(t){return To.call(e,t)}),Ql(s,"keydown",dn(e,Lo)),Ql(s,"keypress",dn(e,Mo)),Ql(s,"focus",function(t){return Hr(e,t)}),Ql(s,"blur",function(t){return Fr(e,t)})}function Yo(e,t,r,n){var i,o=e.doc;null==r&&(r="add"),"smart"==r&&(o.mode.indent?i=$e(e,t).state:r="prev");var l=e.options.tabSize,s=M(o,t),a=f(s.text,null,l);s.stateAfter&&(s.stateAfter=null);var u,c=s.text.match(/^\s*/)[0];if(n||/\S/.test(s.text)){if("smart"==r&&((u=o.mode.indent(i,s.text.slice(c.length),s.text))==Bl||u>150)){if(!n)return;r="prev"}}else u=0,r="not";"prev"==r?u=t>o.first?f(M(o,t-1).text,null,l):0:"add"==r?u=a+e.options.indentUnit:"subtract"==r?u=a-e.options.indentUnit:"number"==typeof r&&(u=a+r),u=Math.max(0,u);var h="",d=0;if(e.options.indentWithTabs)for(var g=Math.floor(u/l);g;--g)d+=l,h+="\t";if(d<u&&(h+=p(u-d)),h!=c)return Ei(o,h,E(t,0),E(t,c.length),"+input"),s.stateAfter=null,!0;for(var v=0;v<o.sel.ranges.length;v++){var m=o.sel.ranges[v];if(m.head.line==t&&m.head.ch<c.length){var y=E(t,c.length);gi(o,v,new Ts(y,y));break}}}function _o(e){qs=e}function $o(e,t,r,n,i){var o=e.doc;e.display.shift=!1,n||(n=o.sel);var l=e.state.pasteIncoming||"paste"==i,s=es(t),a=null;if(l&&n.ranges.length>1)if(qs&&qs.text.join("\n")==t){if(n.ranges.length%qs.text.length==0){a=[];for(var u=0;u<qs.text.length;u++)a.push(o.splitLines(qs.text[u]))}}else s.length==n.ranges.length&&e.options.pasteLinesPerSelection&&(a=v(s,function(e){return[e]}));for(var c,f=n.ranges.length-1;f>=0;f--){var h=n.ranges[f],d=h.from(),p=h.to();h.empty()&&(r&&r>0?d=E(d.line,d.ch-r):e.state.overwrite&&!l?p=E(p.line,Math.min(M(o,p.line).text.length,p.ch+g(s).length)):qs&&qs.lineWise&&qs.text.join("\n")==t&&(d=p=E(d.line,0))),c=e.curOp.updateInput;var m={from:d,to:p,text:a?a[f%a.length]:s,origin:i||(l?"paste":e.state.cutIncoming?"cut":"+input")};Oi(e.doc,m),bt(e,"inputRead",e,m)}t&&!l&&Zo(e,t),jr(e),e.curOp.updateInput=c,e.curOp.typing=!0,e.state.pasteIncoming=e.state.cutIncoming=!1}function qo(e,t){var r=e.clipboardData&&e.clipboardData.getData("Text");if(r)return e.preventDefault(),t.isReadOnly()||t.options.disableInput||hn(t,function(){return $o(t,r,0,null,"paste")}),!0}function Zo(e,t){if(e.options.electricChars&&e.options.smartIndent)for(var r=e.doc.sel,n=r.ranges.length-1;n>=0;n--){var i=r.ranges[n];if(!(i.head.ch>100||n&&r.ranges[n-1].head.line==i.head.line)){var o=e.getModeAt(i.head),l=!1;if(o.electricChars){for(var s=0;s<o.electricChars.length;s++)if(t.indexOf(o.electricChars.charAt(s))>-1){l=Yo(e,i.head.line,"smart");break}}else o.electricInput&&o.electricInput.test(M(e.doc,i.head.line).text.slice(0,i.head.ch))&&(l=Yo(e,i.head.line,"smart"));l&&bt(e,"electricInput",e,i.head.line)}}}function Qo(e){for(var t=[],r=[],n=0;n<e.doc.sel.ranges.length;n++){var i=e.doc.sel.ranges[n].head.line,o={anchor:E(i,0),head:E(i+1,0)};r.push(o),t.push(e.getRange(o.anchor,o.head))}return{text:t,ranges:r}}function Jo(e,t){e.setAttribute("autocorrect","off"),e.setAttribute("autocapitalize","off"),e.setAttribute("spellcheck",!!t)}function el(){var e=n("textarea",null,null,"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none"),t=n("div",[e],null,"overflow: hidden; position: relative; width: 3px; height: 0px;");return ml?e.style.width="1000px":e.setAttribute("wrap","off"),Ll&&(e.style.border="1px solid black"),Jo(e),t}function tl(e,t,r,n,i){function o(){var n=t.line+r;return!(n<e.first||n>=e.first+e.size)&&(t=new E(n,t.ch,t.sticky),u=M(e,n))}function l(n){var l;if(null==(l=i?go(e.cm,u,t,r):ho(u,t,r))){if(n||!o())return!1;t=po(i,e.cm,u,t.line,r)}else t=l;return!0}var s=t,a=r,u=M(e,t.line);if("char"==n)l();else if("column"==n)l(!0);else if("word"==n||"group"==n)for(var c=null,f="group"==n,h=e.cm&&e.cm.getHelper(t,"wordChars"),d=!0;!(r<0)||l(!d);d=!1){var p=u.text.charAt(t.ch)||"\n",g=x(p,h)?"w":f&&"\n"==p?"n":!f||/\s/.test(p)?null:"p";if(!f||d||g||(g="s"),c&&c!=g){r<0&&(r=1,l(),t.sticky="after");break}if(g&&(c=g),r>0&&!l(!d))break}var v=ki(e,t,s,a,!0);return I(s,v)&&(v.hitSide=!0),v}function rl(e,t,r,n){var i,o=e.doc,l=t.left;if("page"==n){var s=Math.min(e.display.wrapper.clientHeight,window.innerHeight||document.documentElement.clientHeight),a=Math.max(s-.5*mr(e.display),3);i=(r>0?t.bottom:t.top)+r*a}else"line"==n&&(i=r>0?t.bottom+3:t.top-3);for(var u;(u=cr(e,l,i)).outside;){if(r<0?i<=0:i>=o.height){u.hitSide=!0;break}i+=5*r}return u}function nl(e,t){var r=jt(e,t.line);if(!r||r.hidden)return null;var n=M(e.doc,t.line),i=Ut(r,n,t.line),o=Se(n,e.doc.direction),l="left";o&&(l=Ce(o,t.ch)%2?"right":"left");var s=_t(i.map,t.ch,l);return s.offset="right"==s.collapse?s.end:s.start,s}function il(e){for(var t=e;t;t=t.parentNode)if(/CodeMirror-gutter-wrapper/.test(t.className))return!0;return!1}function ol(e,t){return t&&(e.bad=!0),e}function ll(e,t,r,n,i){function o(e){return function(t){return t.id==e}}function l(){c&&(u+=f,c=!1)}function s(e){e&&(l(),u+=e)}function a(t){if(1==t.nodeType){var r=t.getAttribute("cm-text");if(null!=r)return void s(r||t.textContent.replace(/\u200b/g,""));var u,h=t.getAttribute("cm-marker");if(h){var d=e.findMarks(E(n,0),E(i+1,0),o(+h));return void(d.length&&(u=d[0].find(0))&&s(N(e.doc,u.from,u.to).join(f)))}if("false"==t.getAttribute("contenteditable"))return;var p=/^(pre|div|p)$/i.test(t.nodeName);p&&l();for(var g=0;g<t.childNodes.length;g++)a(t.childNodes[g]);p&&(c=!0)}else 3==t.nodeType&&s(t.nodeValue)}for(var u="",c=!1,f=e.doc.lineSeparator();a(t),t!=r;)t=t.nextSibling;return u}function sl(e,t,r){var n;if(t==e.display.lineDiv){if(!(n=e.display.lineDiv.childNodes[r]))return ol(e.clipPos(E(e.display.viewTo-1)),!0);t=null,r=0}else for(n=t;;n=n.parentNode){if(!n||n==e.display.lineDiv)return null;if(n.parentNode&&n.parentNode==e.display.lineDiv)break}for(var i=0;i<e.display.view.length;i++){var o=e.display.view[i];if(o.node==n)return al(o,t,r)}}function al(e,t,r){function n(t,r,n){for(var i=-1;i<(f?f.length:0);i++)for(var o=i<0?c.map:f[i],l=0;l<o.length;l+=3){var s=o[l+2];if(s==t||s==r){var a=W(i<0?e.line:e.rest[i]),u=o[l]+n;return(n<0||s!=t)&&(u=o[l+(n?1:0)]),E(a,u)}}}var i=e.text.firstChild,l=!1;if(!t||!o(i,t))return ol(E(W(e.line),0),!0);if(t==i&&(l=!0,t=i.childNodes[r],r=0,!t)){var s=e.rest?g(e.rest):e.line;return ol(E(W(s),s.text.length),l)}var a=3==t.nodeType?t:null,u=t;for(a||1!=t.childNodes.length||3!=t.firstChild.nodeType||(a=t.firstChild,r&&(r=a.nodeValue.length));u.parentNode!=i;)u=u.parentNode;var c=e.measure,f=c.maps,h=n(a,u,r);if(h)return ol(h,l);for(var d=u.nextSibling,p=a?a.nodeValue.length-r:0;d;d=d.nextSibling){if(h=n(d,d.firstChild,0))return ol(E(h.line,h.ch-p),l);p+=d.textContent.length}for(var v=u.previousSibling,m=r;v;v=v.previousSibling){if(h=n(v,v.firstChild,-1))return ol(E(h.line,h.ch+m),l);m+=v.textContent.length}}var ul=navigator.userAgent,cl=navigator.platform,fl=/gecko\/\d/i.test(ul),hl=/MSIE \d/.test(ul),dl=/Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(ul),pl=/Edge\/(\d+)/.exec(ul),gl=hl||dl||pl,vl=gl&&(hl?document.documentMode||6:+(pl||dl)[1]),ml=!pl&&/WebKit\//.test(ul),yl=ml&&/Qt\/\d+\.\d+/.test(ul),bl=!pl&&/Chrome\//.test(ul),wl=/Opera\//.test(ul),xl=/Apple Computer/.test(navigator.vendor),Cl=/Mac OS X 1\d\D([8-9]|\d\d)\D/.test(ul),Sl=/PhantomJS/.test(ul),Ll=!pl&&/AppleWebKit/.test(ul)&&/Mobile\/\w+/.test(ul),kl=/Android/.test(ul),Tl=Ll||kl||/webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(ul),Ml=Ll||/Mac/.test(cl),Nl=/\bCrOS\b/.test(ul),Ol=/win/i.test(cl),Al=wl&&ul.match(/Version\/(\d*\.\d*)/);Al&&(Al=Number(Al[1])),Al&&Al>=15&&(wl=!1,ml=!0);var Wl,Dl=Ml&&(yl||wl&&(null==Al||Al<12.11)),Hl=fl||gl&&vl>=9,Fl=function(t,r){var n=t.className,i=e(r).exec(n);if(i){var o=n.slice(i.index+i[0].length);t.className=n.slice(0,i.index)+(o?i[1]+o:"")}};Wl=document.createRange?function(e,t,r,n){var i=document.createRange();return i.setEnd(n||e,r),i.setStart(e,t),i}:function(e,t,r){var n=document.body.createTextRange();try{n.moveToElementText(e.parentNode)}catch(e){return n}return n.collapse(!0),n.moveEnd("character",r),n.moveStart("character",t),n};var El=function(e){e.select()};Ll?El=function(e){e.selectionStart=0,e.selectionEnd=e.value.length}:gl&&(El=function(e){try{e.select()}catch(e){}});var Pl=function(){this.id=null};Pl.prototype.set=function(e,t){clearTimeout(this.id),this.id=setTimeout(t,e)};var Il,zl,Rl=30,Bl={toString:function(){return"CodeMirror.Pass"}},Gl={scroll:!1},Ul={origin:"*mouse"},Vl={origin:"+move"},Kl=[""],jl=/[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/,Xl=/[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/,Yl=!1,_l=!1,$l=null,ql=function(){function e(e){return e<=247?r.charAt(e):1424<=e&&e<=1524?"R":1536<=e&&e<=1785?n.charAt(e-1536):1774<=e&&e<=2220?"r":8192<=e&&e<=8203?"w":8204==e?"b":"L"}function t(e,t,r){this.level=e,this.from=t,this.to=r}var r="bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN",n="nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111",i=/[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/,o=/[stwN]/,l=/[LRr]/,s=/[Lb1n]/,a=/[1n]/;return function(r,n){var u="ltr"==n?"L":"R";if(0==r.length||"ltr"==n&&!i.test(r))return!1;for(var c=r.length,f=[],h=0;h<c;++h)f.push(e(r.charCodeAt(h)));for(var d=0,p=u;d<c;++d){var v=f[d];"m"==v?f[d]=p:p=v}for(var m=0,y=u;m<c;++m){var b=f[m];"1"==b&&"r"==y?f[m]="n":l.test(b)&&(y=b,"r"==b&&(f[m]="R"))}for(var w=1,x=f[0];w<c-1;++w){var C=f[w];"+"==C&&"1"==x&&"1"==f[w+1]?f[w]="1":","!=C||x!=f[w+1]||"1"!=x&&"n"!=x||(f[w]=x),x=C}for(var S=0;S<c;++S){var L=f[S];if(","==L)f[S]="N";else if("%"==L){var k=void 0;for(k=S+1;k<c&&"%"==f[k];++k);for(var T=S&&"!"==f[S-1]||k<c&&"1"==f[k]?"1":"N",M=S;M<k;++M)f[M]=T;S=k-1}}for(var N=0,O=u;N<c;++N){var A=f[N];"L"==O&&"1"==A?f[N]="L":l.test(A)&&(O=A)}for(var W=0;W<c;++W)if(o.test(f[W])){var D=void 0;for(D=W+1;D<c&&o.test(f[D]);++D);for(var H="L"==(W?f[W-1]:u),F=H==("L"==(D<c?f[D]:u))?H?"L":"R":u,E=W;E<D;++E)f[E]=F;W=D-1}for(var P,I=[],z=0;z<c;)if(s.test(f[z])){var R=z;for(++z;z<c&&s.test(f[z]);++z);I.push(new t(0,R,z))}else{var B=z,G=I.length;for(++z;z<c&&"L"!=f[z];++z);for(var U=B;U<z;)if(a.test(f[U])){B<U&&I.splice(G,0,new t(1,B,U));var V=U;for(++U;U<z&&a.test(f[U]);++U);I.splice(G,0,new t(2,V,U)),B=U}else++U;B<z&&I.splice(G,0,new t(1,B,z))}return 1==I[0].level&&(P=r.match(/^\s+/))&&(I[0].from=P[0].length,I.unshift(new t(0,0,P[0].length))),1==g(I).level&&(P=r.match(/\s+$/))&&(g(I).to-=P[0].length,I.push(new t(0,c-P[0].length,c))),"rtl"==n?I.reverse():I}}(),Zl=[],Ql=function(e,t,r){if(e.addEventListener)e.addEventListener(t,r,!1);else if(e.attachEvent)e.attachEvent("on"+t,r);else{var n=e._handlers||(e._handlers={});n[t]=(n[t]||Zl).concat(r)}},Jl=function(){if(gl&&vl<9)return!1;var e=n("div");return"draggable"in e||"dragDrop"in e}(),es=3!="\n\nb".split(/\n/).length?function(e){for(var t=0,r=[],n=e.length;t<=n;){var i=e.indexOf("\n",t);-1==i&&(i=e.length);var o=e.slice(t,"\r"==e.charAt(i-1)?i-1:i),l=o.indexOf("\r");-1!=l?(r.push(o.slice(0,l)),t+=l+1):(r.push(o),t=i+1)}return r}:function(e){return e.split(/\r\n?|\n/)},ts=window.getSelection?function(e){try{return e.selectionStart!=e.selectionEnd}catch(e){return!1}}:function(e){var t;try{t=e.ownerDocument.selection.createRange()}catch(e){}return!(!t||t.parentElement()!=e)&&0!=t.compareEndPoints("StartToEnd",t)},rs=function(){var e=n("div");return"oncopy"in e||(e.setAttribute("oncopy","return;"),"function"==typeof e.oncopy)}(),ns=null,is={},os={},ls={},ss=function(e,t,r){this.pos=this.start=0,this.string=e,this.tabSize=t||8,this.lastColumnPos=this.lastColumnValue=0,this.lineStart=0,this.lineOracle=r};ss.prototype.eol=function(){return this.pos>=this.string.length},ss.prototype.sol=function(){return this.pos==this.lineStart},ss.prototype.peek=function(){return this.string.charAt(this.pos)||void 0},ss.prototype.next=function(){if(this.pos<this.string.length)return this.string.charAt(this.pos++)},ss.prototype.eat=function(e){var t=this.string.charAt(this.pos);if("string"==typeof e?t==e:t&&(e.test?e.test(t):e(t)))return++this.pos,t},ss.prototype.eatWhile=function(e){for(var t=this.pos;this.eat(e););return this.pos>t},ss.prototype.eatSpace=function(){for(var e=this,t=this.pos;/[\s\u00a0]/.test(this.string.charAt(this.pos));)++e.pos;return this.pos>t},ss.prototype.skipToEnd=function(){this.pos=this.string.length},ss.prototype.skipTo=function(e){var t=this.string.indexOf(e,this.pos);if(t>-1)return this.pos=t,!0},ss.prototype.backUp=function(e){this.pos-=e},ss.prototype.column=function(){return this.lastColumnPos<this.start&&(this.lastColumnValue=f(this.string,this.start,this.tabSize,this.lastColumnPos,this.lastColumnValue),this.lastColumnPos=this.start),this.lastColumnValue-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.indentation=function(){return f(this.string,null,this.tabSize)-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.match=function(e,t,r){if("string"!=typeof e){var n=this.string.slice(this.pos).match(e);return n&&n.index>0?null:(n&&!1!==t&&(this.pos+=n[0].length),n)}var i=function(e){return r?e.toLowerCase():e};if(i(this.string.substr(this.pos,e.length))==i(e))return!1!==t&&(this.pos+=e.length),!0},ss.prototype.current=function(){return this.string.slice(this.start,this.pos)},ss.prototype.hideFirstChars=function(e,t){this.lineStart+=e;try{return t()}finally{this.lineStart-=e}},ss.prototype.lookAhead=function(e){var t=this.lineOracle;return t&&t.lookAhead(e)};var as=function(e,t){this.state=e,this.lookAhead=t},us=function(e,t,r,n){this.state=t,this.doc=e,this.line=r,this.maxLookAhead=n||0};us.prototype.lookAhead=function(e){var t=this.doc.getLine(this.line+e);return null!=t&&e>this.maxLookAhead&&(this.maxLookAhead=e),t},us.prototype.nextLine=function(){this.line++,this.maxLookAhead>0&&this.maxLookAhead--},us.fromSaved=function(e,t,r){return t instanceof as?new us(e,Ke(e.mode,t.state),r,t.lookAhead):new us(e,Ke(e.mode,t),r)},us.prototype.save=function(e){var t=!1!==e?Ke(this.doc.mode,this.state):this.state;return this.maxLookAhead>0?new as(t,this.maxLookAhead):t};var cs=function(e,t,r){this.start=e.start,this.end=e.pos,this.string=e.current(),this.type=t||null,this.state=r},fs=function(e,t,r){this.text=e,ne(this,t),this.height=r?r(this):1};fs.prototype.lineNo=function(){return W(this)},Ae(fs);var hs,ds={},ps={},gs=null,vs=null,ms={left:0,right:0,top:0,bottom:0},ys=function(e,t,r){this.cm=r;var i=this.vert=n("div",[n("div",null,null,"min-width: 1px")],"CodeMirror-vscrollbar"),o=this.horiz=n("div",[n("div",null,null,"height: 100%; min-height: 1px")],"CodeMirror-hscrollbar");e(i),e(o),Ql(i,"scroll",function(){i.clientHeight&&t(i.scrollTop,"vertical")}),Ql(o,"scroll",function(){o.clientWidth&&t(o.scrollLeft,"horizontal")}),this.checkedZeroWidth=!1,gl&&vl<8&&(this.horiz.style.minHeight=this.vert.style.minWidth="18px")};ys.prototype.update=function(e){var t=e.scrollWidth>e.clientWidth+1,r=e.scrollHeight>e.clientHeight+1,n=e.nativeBarWidth;if(r){this.vert.style.display="block",this.vert.style.bottom=t?n+"px":"0";var i=e.viewHeight-(t?n:0);this.vert.firstChild.style.height=Math.max(0,e.scrollHeight-e.clientHeight+i)+"px"}else this.vert.style.display="",this.vert.firstChild.style.height="0";if(t){this.horiz.style.display="block",this.horiz.style.right=r?n+"px":"0",this.horiz.style.left=e.barLeft+"px";var o=e.viewWidth-e.barLeft-(r?n:0);this.horiz.firstChild.style.width=Math.max(0,e.scrollWidth-e.clientWidth+o)+"px"}else this.horiz.style.display="",this.horiz.firstChild.style.width="0";return!this.checkedZeroWidth&&e.clientHeight>0&&(0==n&&this.zeroWidthHack(),this.checkedZeroWidth=!0),{right:r?n:0,bottom:t?n:0}},ys.prototype.setScrollLeft=function(e){this.horiz.scrollLeft!=e&&(this.horiz.scrollLeft=e),this.disableHoriz&&this.enableZeroWidthBar(this.horiz,this.disableHoriz,"horiz")},ys.prototype.setScrollTop=function(e){this.vert.scrollTop!=e&&(this.vert.scrollTop=e),this.disableVert&&this.enableZeroWidthBar(this.vert,this.disableVert,"vert")},ys.prototype.zeroWidthHack=function(){var e=Ml&&!Cl?"12px":"18px";this.horiz.style.height=this.vert.style.width=e,this.horiz.style.pointerEvents=this.vert.style.pointerEvents="none",this.disableHoriz=new Pl,this.disableVert=new Pl},ys.prototype.enableZeroWidthBar=function(e,t,r){function n(){var i=e.getBoundingClientRect();("vert"==r?document.elementFromPoint(i.right-1,(i.top+i.bottom)/2):document.elementFromPoint((i.right+i.left)/2,i.bottom-1))!=e?e.style.pointerEvents="none":t.set(1e3,n)}e.style.pointerEvents="auto",t.set(1e3,n)},ys.prototype.clear=function(){var e=this.horiz.parentNode;e.removeChild(this.horiz),e.removeChild(this.vert)};var bs=function(){};bs.prototype.update=function(){return{bottom:0,right:0}},bs.prototype.setScrollLeft=function(){},bs.prototype.setScrollTop=function(){},bs.prototype.clear=function(){};var ws={native:ys,null:bs},xs=0,Cs=function(e,t,r){var n=e.display;this.viewport=t,this.visible=Ir(n,e.doc,t),this.editorIsHidden=!n.wrapper.offsetWidth,this.wrapperHeight=n.wrapper.clientHeight,this.wrapperWidth=n.wrapper.clientWidth,this.oldDisplayWidth=Rt(e),this.force=r,this.dims=br(e),this.events=[]};Cs.prototype.signal=function(e,t){Oe(e,t)&&this.events.push(arguments)},Cs.prototype.finish=function(){for(var e=this,t=0;t<this.events.length;t++)Te.apply(null,e.events[t])};var Ss=0,Ls=null;gl?Ls=-.53:fl?Ls=15:bl?Ls=-.7:xl&&(Ls=-1/3);var ks=function(e,t){this.ranges=e,this.primIndex=t};ks.prototype.primary=function(){return this.ranges[this.primIndex]},ks.prototype.equals=function(e){var t=this;if(e==this)return!0;if(e.primIndex!=this.primIndex||e.ranges.length!=this.ranges.length)return!1;for(var r=0;r<this.ranges.length;r++){var n=t.ranges[r],i=e.ranges[r];if(!I(n.anchor,i.anchor)||!I(n.head,i.head))return!1}return!0},ks.prototype.deepCopy=function(){for(var e=this,t=[],r=0;r<this.ranges.length;r++)t[r]=new Ts(z(e.ranges[r].anchor),z(e.ranges[r].head));return new ks(t,this.primIndex)},ks.prototype.somethingSelected=function(){for(var e=this,t=0;t<this.ranges.length;t++)if(!e.ranges[t].empty())return!0;return!1},ks.prototype.contains=function(e,t){var r=this;t||(t=e);for(var n=0;n<this.ranges.length;n++){var i=r.ranges[n];if(P(t,i.from())>=0&&P(e,i.to())<=0)return n}return-1};var Ts=function(e,t){this.anchor=e,this.head=t};Ts.prototype.from=function(){return B(this.anchor,this.head)},Ts.prototype.to=function(){return R(this.anchor,this.head)},Ts.prototype.empty=function(){return this.head.line==this.anchor.line&&this.head.ch==this.anchor.ch},Bi.prototype={chunkSize:function(){return this.lines.length},removeInner:function(e,t){for(var r=this,n=e,i=e+t;n<i;++n){var o=r.lines[n];r.height-=o.height,ot(o),bt(o,"delete")}this.lines.splice(e,t)},collapse:function(e){e.push.apply(e,this.lines)},insertInner:function(e,t,r){var n=this;this.height+=r,this.lines=this.lines.slice(0,e).concat(t).concat(this.lines.slice(e));for(var i=0;i<t.length;++i)t[i].parent=n},iterN:function(e,t,r){for(var n=this,i=e+t;e<i;++e)if(r(n.lines[e]))return!0}},Gi.prototype={chunkSize:function(){return this.size},removeInner:function(e,t){var r=this;this.size-=t;for(var n=0;n<this.children.length;++n){var i=r.children[n],o=i.chunkSize();if(e<o){var l=Math.min(t,o-e),s=i.height;if(i.removeInner(e,l),r.height-=s-i.height,o==l&&(r.children.splice(n--,1),i.parent=null),0==(t-=l))break;e=0}else e-=o}if(this.size-t<25&&(this.children.length>1||!(this.children[0]instanceof Bi))){var a=[];this.collapse(a),this.children=[new Bi(a)],this.children[0].parent=this}},collapse:function(e){for(var t=this,r=0;r<this.children.length;++r)t.children[r].collapse(e)},insertInner:function(e,t,r){var n=this;this.size+=t.length,this.height+=r;for(var i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<=l){if(o.insertInner(e,t,r),o.lines&&o.lines.length>50){for(var s=o.lines.length%25+25,a=s;a<o.lines.length;){var u=new Bi(o.lines.slice(a,a+=25));o.height-=u.height,n.children.splice(++i,0,u),u.parent=n}o.lines=o.lines.slice(0,s),n.maybeSpill()}break}e-=l}},maybeSpill:function(){if(!(this.children.length<=10)){var e=this;do{var t=new Gi(e.children.splice(e.children.length-5,5));if(e.parent){e.size-=t.size,e.height-=t.height;var r=h(e.parent.children,e);e.parent.children.splice(r+1,0,t)}else{var n=new Gi(e.children);n.parent=e,e.children=[n,t],e=n}t.parent=e.parent}while(e.children.length>10);e.parent.maybeSpill()}},iterN:function(e,t,r){for(var n=this,i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<l){var s=Math.min(t,l-e);if(o.iterN(e,s,r))return!0;if(0==(t-=s))break;e=0}else e-=l}}};var Ms=function(e,t,r){var n=this;if(r)for(var i in r)r.hasOwnProperty(i)&&(n[i]=r[i]);this.doc=e,this.node=t};Ms.prototype.clear=function(){var e=this,t=this.doc.cm,r=this.line.widgets,n=this.line,i=W(n);if(null!=i&&r){for(var o=0;o<r.length;++o)r[o]==e&&r.splice(o--,1);r.length||(n.widgets=null);var l=Ht(this);A(n,Math.max(0,n.height-l)),t&&(hn(t,function(){Ui(t,n,-l),mn(t,i,"widget")}),bt(t,"lineWidgetCleared",t,this,i))}},Ms.prototype.changed=function(){var e=this,t=this.height,r=this.doc.cm,n=this.line;this.height=null;var i=Ht(this)-t;i&&(A(n,n.height+i),r&&hn(r,function(){r.curOp.forceUpdate=!0,Ui(r,n,i),bt(r,"lineWidgetChanged",r,e,W(n))}))},Ae(Ms);var Ns=0,Os=function(e,t){this.lines=[],this.type=t,this.doc=e,this.id=++Ns};Os.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){var t=this.doc.cm,r=t&&!t.curOp;if(r&&nn(t),Oe(this,"clear")){var n=this.find();n&&bt(this,"clear",n.from,n.to)}for(var i=null,o=null,l=0;l<this.lines.length;++l){var s=e.lines[l],a=_(s.markedSpans,e);t&&!e.collapsed?mn(t,W(s),"text"):t&&(null!=a.to&&(o=W(s)),null!=a.from&&(i=W(s))),s.markedSpans=$(s.markedSpans,a),null==a.from&&e.collapsed&&!ve(e.doc,s)&&t&&A(s,mr(t.display))}if(t&&this.collapsed&&!t.options.lineWrapping)for(var u=0;u<this.lines.length;++u){var c=fe(e.lines[u]),f=be(c);f>t.display.maxLineLength&&(t.display.maxLine=c,t.display.maxLineLength=f,t.display.maxLineChanged=!0)}null!=i&&t&&this.collapsed&&vn(t,i,o+1),this.lines.length=0,this.explicitlyCleared=!0,this.atomic&&this.doc.cantEdit&&(this.doc.cantEdit=!1,t&&Ci(t.doc)),t&&bt(t,"markerCleared",t,this,i,o),r&&on(t),this.parent&&this.parent.clear()}},Os.prototype.find=function(e,t){var r=this;null==e&&"bookmark"==this.type&&(e=1);for(var n,i,o=0;o<this.lines.length;++o){var l=r.lines[o],s=_(l.markedSpans,r);if(null!=s.from&&(n=E(t?l:W(l),s.from),-1==e))return n;if(null!=s.to&&(i=E(t?l:W(l),s.to),1==e))return i}return n&&{from:n,to:i}},Os.prototype.changed=function(){var e=this,t=this.find(-1,!0),r=this,n=this.doc.cm;t&&n&&hn(n,function(){var i=t.line,o=W(t.line),l=jt(n,o);if(l&&(Qt(l),n.curOp.selectionChanged=n.curOp.forceUpdate=!0),n.curOp.updateMaxLine=!0,!ve(r.doc,i)&&null!=r.height){var s=r.height;r.height=null;var a=Ht(r)-s;a&&A(i,i.height+a)}bt(n,"markerChanged",n,e)})},Os.prototype.attachLine=function(e){if(!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;t.maybeHiddenMarkers&&-1!=h(t.maybeHiddenMarkers,this)||(t.maybeUnhiddenMarkers||(t.maybeUnhiddenMarkers=[])).push(this)}this.lines.push(e)},Os.prototype.detachLine=function(e){if(this.lines.splice(h(this.lines,e),1),!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;(t.maybeHiddenMarkers||(t.maybeHiddenMarkers=[])).push(this)}},Ae(Os);var As=function(e,t){var r=this;this.markers=e,this.primary=t;for(var n=0;n<e.length;++n)e[n].parent=r};As.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){this.explicitlyCleared=!0;for(var t=0;t<this.markers.length;++t)e.markers[t].clear();bt(this,"clear")}},As.prototype.find=function(e,t){return this.primary.find(e,t)},Ae(As);var Ws=0,Ds=function(e,t,r,n,i){if(!(this instanceof Ds))return new Ds(e,t,r,n,i);null==r&&(r=0),Gi.call(this,[new Bi([new fs("",null)])]),this.first=r,this.scrollTop=this.scrollLeft=0,this.cantEdit=!1,this.cleanGeneration=1,this.modeFrontier=this.highlightFrontier=r;var o=E(r,0);this.sel=Rn(o),this.history=new Jn(null),this.id=++Ws,this.modeOption=t,this.lineSep=n,this.direction="rtl"==i?"rtl":"ltr",this.extend=!1,"string"==typeof e&&(e=this.splitLines(e)),_n(this,{from:o,to:o,text:e}),bi(this,Rn(o),Gl)};Ds.prototype=b(Gi.prototype,{constructor:Ds,iter:function(e,t,r){r?this.iterN(e-this.first,t-e,r):this.iterN(this.first,this.first+this.size,e)},insert:function(e,t){for(var r=0,n=0;n<t.length;++n)r+=t[n].height;this.insertInner(e-this.first,t,r)},remove:function(e,t){this.removeInner(e-this.first,t)},getValue:function(e){var t=O(this,this.first,this.first+this.size);return!1===e?t:t.join(e||this.lineSeparator())},setValue:gn(function(e){var t=E(this.first,0),r=this.first+this.size-1;Oi(this,{from:t,to:E(r,M(this,r).text.length),text:this.splitLines(e),origin:"setValue",full:!0},!0),this.cm&&Xr(this.cm,0,0),bi(this,Rn(t),Gl)}),replaceRange:function(e,t,r,n){Ei(this,e,t=U(this,t),r=r?U(this,r):t,n)},getRange:function(e,t,r){var n=N(this,U(this,e),U(this,t));return!1===r?n:n.join(r||this.lineSeparator())},getLine:function(e){var t=this.getLineHandle(e);return t&&t.text},getLineHandle:function(e){if(H(this,e))return M(this,e)},getLineNumber:function(e){return W(e)},getLineHandleVisualStart:function(e){return"number"==typeof e&&(e=M(this,e)),fe(e)},lineCount:function(){return this.size},firstLine:function(){return this.first},lastLine:function(){return this.first+this.size-1},clipPos:function(e){return U(this,e)},getCursor:function(e){var t=this.sel.primary();return null==e||"head"==e?t.head:"anchor"==e?t.anchor:"end"==e||"to"==e||!1===e?t.to():t.from()},listSelections:function(){return this.sel.ranges},somethingSelected:function(){return this.sel.somethingSelected()},setCursor:gn(function(e,t,r){vi(this,U(this,"number"==typeof e?E(e,t||0):e),null,r)}),setSelection:gn(function(e,t,r){vi(this,U(this,e),U(this,t||e),r)}),extendSelection:gn(function(e,t,r){di(this,U(this,e),t&&U(this,t),r)}),extendSelections:gn(function(e,t){pi(this,K(this,e),t)}),extendSelectionsBy:gn(function(e,t){pi(this,K(this,v(this.sel.ranges,e)),t)}),setSelections:gn(function(e,t,r){var n=this;if(e.length){for(var i=[],o=0;o<e.length;o++)i[o]=new Ts(U(n,e[o].anchor),U(n,e[o].head));null==t&&(t=Math.min(e.length-1,this.sel.primIndex)),bi(this,zn(i,t),r)}}),addSelection:gn(function(e,t,r){var n=this.sel.ranges.slice(0);n.push(new Ts(U(this,e),U(this,t||e))),bi(this,zn(n,n.length-1),r)}),getSelection:function(e){for(var t,r=this,n=this.sel.ranges,i=0;i<n.length;i++){var o=N(r,n[i].from(),n[i].to());t=t?t.concat(o):o}return!1===e?t:t.join(e||this.lineSeparator())},getSelections:function(e){for(var t=this,r=[],n=this.sel.ranges,i=0;i<n.length;i++){var o=N(t,n[i].from(),n[i].to());!1!==e&&(o=o.join(e||t.lineSeparator())),r[i]=o}return r},replaceSelection:function(e,t,r){for(var n=[],i=0;i<this.sel.ranges.length;i++)n[i]=e;this.replaceSelections(n,t,r||"+input")},replaceSelections:gn(function(e,t,r){for(var n=this,i=[],o=this.sel,l=0;l<o.ranges.length;l++){var s=o.ranges[l];i[l]={from:s.from(),to:s.to(),text:n.splitLines(e[l]),origin:r}}for(var a=t&&"end"!=t&&Kn(this,i,t),u=i.length-1;u>=0;u--)Oi(n,i[u]);a?yi(this,a):this.cm&&jr(this.cm)}),undo:gn(function(){Wi(this,"undo")}),redo:gn(function(){Wi(this,"redo")}),undoSelection:gn(function(){Wi(this,"undo",!0)}),redoSelection:gn(function(){Wi(this,"redo",!0)}),setExtending:function(e){this.extend=e},getExtending:function(){return this.extend},historySize:function(){for(var e=this.history,t=0,r=0,n=0;n<e.done.length;n++)e.done[n].ranges||++t;for(var i=0;i<e.undone.length;i++)e.undone[i].ranges||++r;return{undo:t,redo:r}},clearHistory:function(){this.history=new Jn(this.history.maxGeneration)},markClean:function(){this.cleanGeneration=this.changeGeneration(!0)},changeGeneration:function(e){return e&&(this.history.lastOp=this.history.lastSelOp=this.history.lastOrigin=null),this.history.generation},isClean:function(e){return this.history.generation==(e||this.cleanGeneration)},getHistory:function(){return{done:fi(this.history.done),undone:fi(this.history.undone)}},setHistory:function(e){var t=this.history=new Jn(this.history.maxGeneration);t.done=fi(e.done.slice(0),null,!0),t.undone=fi(e.undone.slice(0),null,!0)},setGutterMarker:gn(function(e,t,r){return Ri(this,e,"gutter",function(e){var n=e.gutterMarkers||(e.gutterMarkers={});return n[t]=r,!r&&C(n)&&(e.gutterMarkers=null),!0})}),clearGutter:gn(function(e){var t=this;this.iter(function(r){r.gutterMarkers&&r.gutterMarkers[e]&&Ri(t,r,"gutter",function(){return r.gutterMarkers[e]=null,C(r.gutterMarkers)&&(r.gutterMarkers=null),!0})})}),lineInfo:function(e){var t;if("number"==typeof e){if(!H(this,e))return null;if(t=e,!(e=M(this,e)))return null}else if(null==(t=W(e)))return null;return{line:t,handle:e,text:e.text,gutterMarkers:e.gutterMarkers,textClass:e.textClass,bgClass:e.bgClass,wrapClass:e.wrapClass,widgets:e.widgets}},addLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass";if(t[i]){if(e(n).test(t[i]))return!1;t[i]+=" "+n}else t[i]=n;return!0})}),removeLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass",o=t[i];if(!o)return!1;if(null==n)t[i]=null;else{var l=o.match(e(n));if(!l)return!1;var s=l.index+l[0].length;t[i]=o.slice(0,l.index)+(l.index&&s!=o.length?" ":"")+o.slice(s)||null}return!0})}),addLineWidget:gn(function(e,t,r){return Vi(this,e,t,r)}),removeLineWidget:function(e){e.clear()},markText:function(e,t,r){return Ki(this,U(this,e),U(this,t),r,r&&r.type||"range")},setBookmark:function(e,t){var r={replacedWith:t&&(null==t.nodeType?t.widget:t),insertLeft:t&&t.insertLeft,clearWhenEmpty:!1,shared:t&&t.shared,handleMouseEvents:t&&t.handleMouseEvents};return e=U(this,e),Ki(this,e,e,r,"bookmark")},findMarksAt:function(e){var t=[],r=M(this,(e=U(this,e)).line).markedSpans;if(r)for(var n=0;n<r.length;++n){var i=r[n];(null==i.from||i.from<=e.ch)&&(null==i.to||i.to>=e.ch)&&t.push(i.marker.parent||i.marker)}return t},findMarks:function(e,t,r){e=U(this,e),t=U(this,t);var n=[],i=e.line;return this.iter(e.line,t.line+1,function(o){var l=o.markedSpans;if(l)for(var s=0;s<l.length;s++){var a=l[s];null!=a.to&&i==e.line&&e.ch>=a.to||null==a.from&&i!=e.line||null!=a.from&&i==t.line&&a.from>=t.ch||r&&!r(a.marker)||n.push(a.marker.parent||a.marker)}++i}),n},getAllMarks:function(){var e=[];return this.iter(function(t){var r=t.markedSpans;if(r)for(var n=0;n<r.length;++n)null!=r[n].from&&e.push(r[n].marker)}),e},posFromIndex:function(e){var t,r=this.first,n=this.lineSeparator().length;return this.iter(function(i){var o=i.text.length+n;if(o>e)return t=e,!0;e-=o,++r}),U(this,E(r,t))},indexFromPos:function(e){var t=(e=U(this,e)).ch;if(e.line<this.first||e.ch<0)return 0;var r=this.lineSeparator().length;return this.iter(this.first,e.line,function(e){t+=e.text.length+r}),t},copy:function(e){var t=new Ds(O(this,this.first,this.first+this.size),this.modeOption,this.first,this.lineSep,this.direction);return t.scrollTop=this.scrollTop,t.scrollLeft=this.scrollLeft,t.sel=this.sel,t.extend=!1,e&&(t.history.undoDepth=this.history.undoDepth,t.setHistory(this.getHistory())),t},linkedDoc:function(e){e||(e={});var t=this.first,r=this.first+this.size;null!=e.from&&e.from>t&&(t=e.from),null!=e.to&&e.to<r&&(r=e.to);var n=new Ds(O(this,t,r),e.mode||this.modeOption,t,this.lineSep,this.direction);return e.sharedHist&&(n.history=this.history),(this.linked||(this.linked=[])).push({doc:n,sharedHist:e.sharedHist}),n.linked=[{doc:this,isParent:!0,sharedHist:e.sharedHist}],Yi(n,Xi(this)),n},unlinkDoc:function(e){var t=this;if(e instanceof jo&&(e=e.doc),this.linked)for(var r=0;r<this.linked.length;++r)if(t.linked[r].doc==e){t.linked.splice(r,1),e.unlinkDoc(t),_i(Xi(t));break}if(e.history==this.history){var n=[e.id];$n(e,function(e){return n.push(e.id)},!0),e.history=new Jn(null),e.history.done=fi(this.history.done,n),e.history.undone=fi(this.history.undone,n)}},iterLinkedDocs:function(e){$n(this,e)},getMode:function(){return this.mode},getEditor:function(){return this.cm},splitLines:function(e){return this.lineSep?e.split(this.lineSep):es(e)},lineSeparator:function(){return this.lineSep||"\n"},setDirection:gn(function(e){"rtl"!=e&&(e="ltr"),e!=this.direction&&(this.direction=e,this.iter(function(e){return e.order=null}),this.cm&&Qn(this.cm))})}),Ds.prototype.eachLine=Ds.prototype.iter;for(var Hs=0,Fs=!1,Es={3:"Enter",8:"Backspace",9:"Tab",13:"Enter",16:"Shift",17:"Ctrl",18:"Alt",19:"Pause",20:"CapsLock",27:"Esc",32:"Space",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"Left",38:"Up",39:"Right",40:"Down",44:"PrintScrn",45:"Insert",46:"Delete",59:";",61:"=",91:"Mod",92:"Mod",93:"Mod",106:"*",107:"=",109:"-",110:".",111:"/",127:"Delete",173:"-",186:";",187:"=",188:",",189:"-",190:".",191:"/",192:"`",219:"[",220:"\\",221:"]",222:"'",63232:"Up",63233:"Down",63234:"Left",63235:"Right",63272:"Delete",63273:"Home",63275:"End",63276:"PageUp",63277:"PageDown",63302:"Insert"},Ps=0;Ps<10;Ps++)Es[Ps+48]=Es[Ps+96]=String(Ps);for(var Is=65;Is<=90;Is++)Es[Is]=String.fromCharCode(Is);for(var zs=1;zs<=12;zs++)Es[zs+111]=Es[zs+63235]="F"+zs;var Rs={};Rs.basic={Left:"goCharLeft",Right:"goCharRight",Up:"goLineUp",Down:"goLineDown",End:"goLineEnd",Home:"goLineStartSmart",PageUp:"goPageUp",PageDown:"goPageDown",Delete:"delCharAfter",Backspace:"delCharBefore","Shift-Backspace":"delCharBefore",Tab:"defaultTab","Shift-Tab":"indentAuto",Enter:"newlineAndIndent",Insert:"toggleOverwrite",Esc:"singleSelection"},Rs.pcDefault={"Ctrl-A":"selectAll","Ctrl-D":"deleteLine","Ctrl-Z":"undo","Shift-Ctrl-Z":"redo","Ctrl-Y":"redo","Ctrl-Home":"goDocStart","Ctrl-End":"goDocEnd","Ctrl-Up":"goLineUp","Ctrl-Down":"goLineDown","Ctrl-Left":"goGroupLeft","Ctrl-Right":"goGroupRight","Alt-Left":"goLineStart","Alt-Right":"goLineEnd","Ctrl-Backspace":"delGroupBefore","Ctrl-Delete":"delGroupAfter","Ctrl-S":"save","Ctrl-F":"find","Ctrl-G":"findNext","Shift-Ctrl-G":"findPrev","Shift-Ctrl-F":"replace","Shift-Ctrl-R":"replaceAll","Ctrl-[":"indentLess","Ctrl-]":"indentMore","Ctrl-U":"undoSelection","Shift-Ctrl-U":"redoSelection","Alt-U":"redoSelection",fallthrough:"basic"},Rs.emacsy={"Ctrl-F":"goCharRight","Ctrl-B":"goCharLeft","Ctrl-P":"goLineUp","Ctrl-N":"goLineDown","Alt-F":"goWordRight","Alt-B":"goWordLeft","Ctrl-A":"goLineStart","Ctrl-E":"goLineEnd","Ctrl-V":"goPageDown","Shift-Ctrl-V":"goPageUp","Ctrl-D":"delCharAfter","Ctrl-H":"delCharBefore","Alt-D":"delWordAfter","Alt-Backspace":"delWordBefore","Ctrl-K":"killLine","Ctrl-T":"transposeChars","Ctrl-O":"openLine"},Rs.macDefault={"Cmd-A":"selectAll","Cmd-D":"deleteLine","Cmd-Z":"undo","Shift-Cmd-Z":"redo","Cmd-Y":"redo","Cmd-Home":"goDocStart","Cmd-Up":"goDocStart","Cmd-End":"goDocEnd","Cmd-Down":"goDocEnd","Alt-Left":"goGroupLeft","Alt-Right":"goGroupRight","Cmd-Left":"goLineLeft","Cmd-Right":"goLineRight","Alt-Backspace":"delGroupBefore","Ctrl-Alt-Backspace":"delGroupAfter","Alt-Delete":"delGroupAfter","Cmd-S":"save","Cmd-F":"find","Cmd-G":"findNext","Shift-Cmd-G":"findPrev","Cmd-Alt-F":"replace","Shift-Cmd-Alt-F":"replaceAll","Cmd-[":"indentLess","Cmd-]":"indentMore","Cmd-Backspace":"delWrappedLineLeft","Cmd-Delete":"delWrappedLineRight","Cmd-U":"undoSelection","Shift-Cmd-U":"redoSelection","Ctrl-Up":"goDocStart","Ctrl-Down":"goDocEnd",fallthrough:["basic","emacsy"]},Rs.default=Ml?Rs.macDefault:Rs.pcDefault;var Bs={selectAll:Mi,singleSelection:function(e){return e.setSelection(e.getCursor("anchor"),e.getCursor("head"),Gl)},killLine:function(e){return co(e,function(t){if(t.empty()){var r=M(e.doc,t.head.line).text.length;return t.head.ch==r&&t.head.line<e.lastLine()?{from:t.head,to:E(t.head.line+1,0)}:{from:t.head,to:E(t.head.line,r)}}return{from:t.from(),to:t.to()}})},deleteLine:function(e){return co(e,function(t){return{from:E(t.from().line,0),to:U(e.doc,E(t.to().line+1,0))}})},delLineLeft:function(e){return co(e,function(e){return{from:E(e.from().line,0),to:e.from()}})},delWrappedLineLeft:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5;return{from:e.coordsChar({left:0,top:r},"div"),to:t.from()}})},delWrappedLineRight:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5,n=e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div");return{from:t.from(),to:n}})},undo:function(e){return e.undo()},redo:function(e){return e.redo()},undoSelection:function(e){return e.undoSelection()},redoSelection:function(e){return e.redoSelection()},goDocStart:function(e){return e.extendSelection(E(e.firstLine(),0))},goDocEnd:function(e){return e.extendSelection(E(e.lastLine()))},goLineStart:function(e){return e.extendSelectionsBy(function(t){return vo(e,t.head.line)},{origin:"+move",bias:1})},goLineStartSmart:function(e){return e.extendSelectionsBy(function(t){return yo(e,t.head)},{origin:"+move",bias:1})},goLineEnd:function(e){return e.extendSelectionsBy(function(t){return mo(e,t.head.line)},{origin:"+move",bias:-1})},goLineRight:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div")},Vl)},goLineLeft:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:0,top:r},"div")},Vl)},goLineLeftSmart:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5,n=e.coordsChar({left:0,top:r},"div");return n.ch<e.getLine(n.line).search(/\S/)?yo(e,t.head):n},Vl)},goLineUp:function(e){return e.moveV(-1,"line")},goLineDown:function(e){return e.moveV(1,"line")},goPageUp:function(e){return e.moveV(-1,"page")},goPageDown:function(e){return e.moveV(1,"page")},goCharLeft:function(e){return e.moveH(-1,"char")},goCharRight:function(e){return e.moveH(1,"char")},goColumnLeft:function(e){return e.moveH(-1,"column")},goColumnRight:function(e){return e.moveH(1,"column")},goWordLeft:function(e){return e.moveH(-1,"word")},goGroupRight:function(e){return e.moveH(1,"group")},goGroupLeft:function(e){return e.moveH(-1,"group")},goWordRight:function(e){return e.moveH(1,"word")},delCharBefore:function(e){return e.deleteH(-1,"char")},delCharAfter:function(e){return e.deleteH(1,"char")},delWordBefore:function(e){return e.deleteH(-1,"word")},delWordAfter:function(e){return e.deleteH(1,"word")},delGroupBefore:function(e){return e.deleteH(-1,"group")},delGroupAfter:function(e){return e.deleteH(1,"group")},indentAuto:function(e){return e.indentSelection("smart")},indentMore:function(e){return e.indentSelection("add")},indentLess:function(e){return e.indentSelection("subtract")},insertTab:function(e){return e.replaceSelection("\t")},insertSoftTab:function(e){for(var t=[],r=e.listSelections(),n=e.options.tabSize,i=0;i<r.length;i++){var o=r[i].from(),l=f(e.getLine(o.line),o.ch,n);t.push(p(n-l%n))}e.replaceSelections(t)},defaultTab:function(e){e.somethingSelected()?e.indentSelection("add"):e.execCommand("insertTab")},transposeChars:function(e){return hn(e,function(){for(var t=e.listSelections(),r=[],n=0;n<t.length;n++)if(t[n].empty()){var i=t[n].head,o=M(e.doc,i.line).text;if(o)if(i.ch==o.length&&(i=new E(i.line,i.ch-1)),i.ch>0)i=new E(i.line,i.ch+1),e.replaceRange(o.charAt(i.ch-1)+o.charAt(i.ch-2),E(i.line,i.ch-2),i,"+transpose");else if(i.line>e.doc.first){var l=M(e.doc,i.line-1).text;l&&(i=new E(i.line,1),e.replaceRange(o.charAt(0)+e.doc.lineSeparator()+l.charAt(l.length-1),E(i.line-1,l.length-1),i,"+transpose"))}r.push(new Ts(i,i))}e.setSelections(r)})},newlineAndIndent:function(e){return hn(e,function(){for(var t=e.listSelections(),r=t.length-1;r>=0;r--)e.replaceRange(e.doc.lineSeparator(),t[r].anchor,t[r].head,"+input");t=e.listSelections();for(var n=0;n<t.length;n++)e.indentLine(t[n].from().line,null,!0);jr(e)})},openLine:function(e){return e.replaceSelection("\n","start")},toggleOverwrite:function(e){return e.toggleOverwrite()}},Gs=new Pl,Us=null,Vs=function(e,t,r){this.time=e,this.pos=t,this.button=r};Vs.prototype.compare=function(e,t,r){return this.time+400>e&&0==P(t,this.pos)&&r==this.button};var Ks,js,Xs={toString:function(){return"CodeMirror.Init"}},Ys={},_s={};jo.defaults=Ys,jo.optionHandlers=_s;var $s=[];jo.defineInitHook=function(e){return $s.push(e)};var qs=null,Zs=function(e){this.cm=e,this.lastAnchorNode=this.lastAnchorOffset=this.lastFocusNode=this.lastFocusOffset=null,this.polling=new Pl,this.composing=null,this.gracePeriod=!1,this.readDOMTimeout=null};Zs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()}),"cut"==e.type&&i.replaceSelection("",null,"cut");else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type&&i.operation(function(){i.setSelections(t.ranges,0,Gl),i.replaceSelection("",null,"cut")})}if(e.clipboardData){e.clipboardData.clearData();var r=qs.text.join("\n");if(e.clipboardData.setData("Text",r),e.clipboardData.getData("Text")==r)return void e.preventDefault()}var l=el(),s=l.firstChild;i.display.lineSpace.insertBefore(l,i.display.lineSpace.firstChild),s.value=qs.text.join("\n");var a=document.activeElement;El(s),setTimeout(function(){i.display.lineSpace.removeChild(l),a.focus(),a==o&&n.showPrimarySelection()},50)}}var r=this,n=this,i=n.cm,o=n.div=e.lineDiv;Jo(o,i.options.spellcheck),Ql(o,"paste",function(e){Me(i,e)||qo(e,i)||vl<=11&&setTimeout(dn(i,function(){return r.updateFromDOM()}),20)}),Ql(o,"compositionstart",function(e){r.composing={data:e.data,done:!1}}),Ql(o,"compositionupdate",function(e){r.composing||(r.composing={data:e.data,done:!1})}),Ql(o,"compositionend",function(e){r.composing&&(e.data!=r.composing.data&&r.readFromDOMSoon(),r.composing.done=!0)}),Ql(o,"touchstart",function(){return n.forceCompositionEnd()}),Ql(o,"input",function(){r.composing||r.readFromDOMSoon()}),Ql(o,"copy",t),Ql(o,"cut",t)},Zs.prototype.prepareSelection=function(){var e=Tr(this.cm,!1);return e.focus=this.cm.state.focused,e},Zs.prototype.showSelection=function(e,t){e&&this.cm.display.view.length&&((e.focus||t)&&this.showPrimarySelection(),this.showMultipleSelections(e))},Zs.prototype.showPrimarySelection=function(){var e=window.getSelection(),t=this.cm,r=t.doc.sel.primary(),n=r.from(),i=r.to();if(t.display.viewTo==t.display.viewFrom||n.line>=t.display.viewTo||i.line<t.display.viewFrom)e.removeAllRanges();else{var o=sl(t,e.anchorNode,e.anchorOffset),l=sl(t,e.focusNode,e.focusOffset);if(!o||o.bad||!l||l.bad||0!=P(B(o,l),n)||0!=P(R(o,l),i)){var s=t.display.view,a=n.line>=t.display.viewFrom&&nl(t,n)||{node:s[0].measure.map[2],offset:0},u=i.line<t.display.viewTo&&nl(t,i);if(!u){var c=s[s.length-1].measure,f=c.maps?c.maps[c.maps.length-1]:c.map;u={node:f[f.length-1],offset:f[f.length-2]-f[f.length-3]}}if(a&&u){var h,d=e.rangeCount&&e.getRangeAt(0);try{h=Wl(a.node,a.offset,u.offset,u.node)}catch(e){}h&&(!fl&&t.state.focused?(e.collapse(a.node,a.offset),h.collapsed||(e.removeAllRanges(),e.addRange(h))):(e.removeAllRanges(),e.addRange(h)),d&&null==e.anchorNode?e.addRange(d):fl&&this.startGracePeriod()),this.rememberSelection()}else e.removeAllRanges()}}},Zs.prototype.startGracePeriod=function(){var e=this;clearTimeout(this.gracePeriod),this.gracePeriod=setTimeout(function(){e.gracePeriod=!1,e.selectionChanged()&&e.cm.operation(function(){return e.cm.curOp.selectionChanged=!0})},20)},Zs.prototype.showMultipleSelections=function(e){r(this.cm.display.cursorDiv,e.cursors),r(this.cm.display.selectionDiv,e.selection)},Zs.prototype.rememberSelection=function(){var e=window.getSelection();this.lastAnchorNode=e.anchorNode,this.lastAnchorOffset=e.anchorOffset,this.lastFocusNode=e.focusNode,this.lastFocusOffset=e.focusOffset},Zs.prototype.selectionInEditor=function(){var e=window.getSelection();if(!e.rangeCount)return!1;var t=e.getRangeAt(0).commonAncestorContainer;return o(this.div,t)},Zs.prototype.focus=function(){"nocursor"!=this.cm.options.readOnly&&(this.selectionInEditor()||this.showSelection(this.prepareSelection(),!0),this.div.focus())},Zs.prototype.blur=function(){this.div.blur()},Zs.prototype.getField=function(){return this.div},Zs.prototype.supportsTouch=function(){return!0},Zs.prototype.receivedFocus=function(){function e(){t.cm.state.focused&&(t.pollSelection(),t.polling.set(t.cm.options.pollInterval,e))}var t=this;this.selectionInEditor()?this.pollSelection():hn(this.cm,function(){return t.cm.curOp.selectionChanged=!0}),this.polling.set(this.cm.options.pollInterval,e)},Zs.prototype.selectionChanged=function(){var e=window.getSelection();return e.anchorNode!=this.lastAnchorNode||e.anchorOffset!=this.lastAnchorOffset||e.focusNode!=this.lastFocusNode||e.focusOffset!=this.lastFocusOffset},Zs.prototype.pollSelection=function(){if(null==this.readDOMTimeout&&!this.gracePeriod&&this.selectionChanged()){var e=window.getSelection(),t=this.cm;if(kl&&bl&&this.cm.options.gutters.length&&il(e.anchorNode))return this.cm.triggerOnKeyDown({type:"keydown",keyCode:8,preventDefault:Math.abs}),this.blur(),void this.focus();if(!this.composing){this.rememberSelection();var r=sl(t,e.anchorNode,e.anchorOffset),n=sl(t,e.focusNode,e.focusOffset);r&&n&&hn(t,function(){bi(t.doc,Rn(r,n),Gl),(r.bad||n.bad)&&(t.curOp.selectionChanged=!0)})}}},Zs.prototype.pollContent=function(){null!=this.readDOMTimeout&&(clearTimeout(this.readDOMTimeout),this.readDOMTimeout=null);var e=this.cm,t=e.display,r=e.doc.sel.primary(),n=r.from(),i=r.to();if(0==n.ch&&n.line>e.firstLine()&&(n=E(n.line-1,M(e.doc,n.line-1).length)),i.ch==M(e.doc,i.line).text.length&&i.line<e.lastLine()&&(i=E(i.line+1,0)),n.line<t.viewFrom||i.line>t.viewTo-1)return!1;var o,l,s;n.line==t.viewFrom||0==(o=Lr(e,n.line))?(l=W(t.view[0].line),s=t.view[0].node):(l=W(t.view[o].line),s=t.view[o-1].node.nextSibling);var a,u,c=Lr(e,i.line);if(c==t.view.length-1?(a=t.viewTo-1,u=t.lineDiv.lastChild):(a=W(t.view[c+1].line)-1,u=t.view[c+1].node.previousSibling),!s)return!1;for(var f=e.doc.splitLines(ll(e,s,u,l,a)),h=N(e.doc,E(l,0),E(a,M(e.doc,a).text.length));f.length>1&&h.length>1;)if(g(f)==g(h))f.pop(),h.pop(),a--;else{if(f[0]!=h[0])break;f.shift(),h.shift(),l++}for(var d=0,p=0,v=f[0],m=h[0],y=Math.min(v.length,m.length);d<y&&v.charCodeAt(d)==m.charCodeAt(d);)++d;for(var b=g(f),w=g(h),x=Math.min(b.length-(1==f.length?d:0),w.length-(1==h.length?d:0));p<x&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)++p;if(1==f.length&&1==h.length&&l==n.line)for(;d&&d>n.ch&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)d--,p++;f[f.length-1]=b.slice(0,b.length-p).replace(/^\u200b+/,""),f[0]=f[0].slice(d).replace(/\u200b+$/,"");var C=E(l,d),S=E(a,h.length?g(h).length-p:0);return f.length>1||f[0]||P(C,S)?(Ei(e.doc,f,C,S,"+input"),!0):void 0},Zs.prototype.ensurePolled=function(){this.forceCompositionEnd()},Zs.prototype.reset=function(){this.forceCompositionEnd()},Zs.prototype.forceCompositionEnd=function(){this.composing&&(clearTimeout(this.readDOMTimeout),this.composing=null,this.updateFromDOM(),this.div.blur(),this.div.focus())},Zs.prototype.readFromDOMSoon=function(){var e=this;null==this.readDOMTimeout&&(this.readDOMTimeout=setTimeout(function(){if(e.readDOMTimeout=null,e.composing){if(!e.composing.done)return;e.composing=null}e.updateFromDOM()},80))},Zs.prototype.updateFromDOM=function(){var e=this;!this.cm.isReadOnly()&&this.pollContent()||hn(this.cm,function(){return vn(e.cm)})},Zs.prototype.setUneditable=function(e){e.contentEditable="false"},Zs.prototype.onKeyPress=function(e){0!=e.charCode&&(e.preventDefault(),this.cm.isReadOnly()||dn(this.cm,$o)(this.cm,String.fromCharCode(null==e.charCode?e.keyCode:e.charCode),0))},Zs.prototype.readOnlyChanged=function(e){this.div.contentEditable=String("nocursor"!=e)},Zs.prototype.onContextMenu=function(){},Zs.prototype.resetPosition=function(){},Zs.prototype.needsContentAttribute=!0;var Qs=function(e){this.cm=e,this.prevInput="",this.pollingFast=!1,this.polling=new Pl,this.hasSelection=!1,this.composing=null};Qs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()});else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type?i.setSelections(t.ranges,null,Gl):(n.prevInput="",l.value=t.text.join("\n"),El(l))}"cut"==e.type&&(i.state.cutIncoming=!0)}}var r=this,n=this,i=this.cm,o=this.wrapper=el(),l=this.textarea=o.firstChild;e.wrapper.insertBefore(o,e.wrapper.firstChild),Ll&&(l.style.width="0px"),Ql(l,"input",function(){gl&&vl>=9&&r.hasSelection&&(r.hasSelection=null),n.poll()}),Ql(l,"paste",function(e){Me(i,e)||qo(e,i)||(i.state.pasteIncoming=!0,n.fastPoll())}),Ql(l,"cut",t),Ql(l,"copy",t),Ql(e.scroller,"paste",function(t){Ft(e,t)||Me(i,t)||(i.state.pasteIncoming=!0,n.focus())}),Ql(e.lineSpace,"selectstart",function(t){Ft(e,t)||We(t)}),Ql(l,"compositionstart",function(){var e=i.getCursor("from");n.composing&&n.composing.range.clear(),n.composing={start:e,range:i.markText(e,i.getCursor("to"),{className:"CodeMirror-composing"})}}),Ql(l,"compositionend",function(){n.composing&&(n.poll(),n.composing.range.clear(),n.composing=null)})},Qs.prototype.prepareSelection=function(){var e=this.cm,t=e.display,r=e.doc,n=Tr(e);if(e.options.moveInputWithCursor){var i=sr(e,r.sel.primary().head,"div"),o=t.wrapper.getBoundingClientRect(),l=t.lineDiv.getBoundingClientRect();n.teTop=Math.max(0,Math.min(t.wrapper.clientHeight-10,i.top+l.top-o.top)),n.teLeft=Math.max(0,Math.min(t.wrapper.clientWidth-10,i.left+l.left-o.left))}return n},Qs.prototype.showSelection=function(e){var t=this.cm.display;r(t.cursorDiv,e.cursors),r(t.selectionDiv,e.selection),null!=e.teTop&&(this.wrapper.style.top=e.teTop+"px",this.wrapper.style.left=e.teLeft+"px")},Qs.prototype.reset=function(e){if(!this.contextMenuPending&&!this.composing){var t=this.cm;if(t.somethingSelected()){this.prevInput="";var r=t.getSelection();this.textarea.value=r,t.state.focused&&El(this.textarea),gl&&vl>=9&&(this.hasSelection=r)}else e||(this.prevInput=this.textarea.value="",gl&&vl>=9&&(this.hasSelection=null))}},Qs.prototype.getField=function(){return this.textarea},Qs.prototype.supportsTouch=function(){return!1},Qs.prototype.focus=function(){if("nocursor"!=this.cm.options.readOnly&&(!Tl||l()!=this.textarea))try{this.textarea.focus()}catch(e){}},Qs.prototype.blur=function(){this.textarea.blur()},Qs.prototype.resetPosition=function(){this.wrapper.style.top=this.wrapper.style.left=0},Qs.prototype.receivedFocus=function(){this.slowPoll()},Qs.prototype.slowPoll=function(){var e=this;this.pollingFast||this.polling.set(this.cm.options.pollInterval,function(){e.poll(),e.cm.state.focused&&e.slowPoll()})},Qs.prototype.fastPoll=function(){function e(){r.poll()||t?(r.pollingFast=!1,r.slowPoll()):(t=!0,r.polling.set(60,e))}var t=!1,r=this;r.pollingFast=!0,r.polling.set(20,e)},Qs.prototype.poll=function(){var e=this,t=this.cm,r=this.textarea,n=this.prevInput;if(this.contextMenuPending||!t.state.focused||ts(r)&&!n&&!this.composing||t.isReadOnly()||t.options.disableInput||t.state.keySeq)return!1;var i=r.value;if(i==n&&!t.somethingSelected())return!1;if(gl&&vl>=9&&this.hasSelection===i||Ml&&/[\uf700-\uf7ff]/.test(i))return t.display.input.reset(),!1;if(t.doc.sel==t.display.selForContextMenu){var o=i.charCodeAt(0);if(8203!=o||n||(n="​"),8666==o)return this.reset(),this.cm.execCommand("undo")}for(var l=0,s=Math.min(n.length,i.length);l<s&&n.charCodeAt(l)==i.charCodeAt(l);)++l;return hn(t,function(){$o(t,i.slice(l),n.length-l,null,e.composing?"*compose":null),i.length>1e3||i.indexOf("\n")>-1?r.value=e.prevInput="":e.prevInput=i,e.composing&&(e.composing.range.clear(),e.composing.range=t.markText(e.composing.start,t.getCursor("to"),{className:"CodeMirror-composing"}))}),!0},Qs.prototype.ensurePolled=function(){this.pollingFast&&this.poll()&&(this.pollingFast=!1)},Qs.prototype.onKeyPress=function(){gl&&vl>=9&&(this.hasSelection=null),this.fastPoll()},Qs.prototype.onContextMenu=function(e){function t(){if(null!=l.selectionStart){var e=i.somethingSelected(),t="​"+(e?l.value:"");l.value="⇚",l.value=t,n.prevInput=e?"":"​",l.selectionStart=1,l.selectionEnd=t.length,o.selForContextMenu=i.doc.sel}}function r(){if(n.contextMenuPending=!1,n.wrapper.style.cssText=c,l.style.cssText=u,gl&&vl<9&&o.scrollbars.setScrollTop(o.scroller.scrollTop=a),null!=l.selectionStart){(!gl||gl&&vl<9)&&t();var e=0,r=function(){o.selForContextMenu==i.doc.sel&&0==l.selectionStart&&l.selectionEnd>0&&"​"==n.prevInput?dn(i,Mi)(i):e++<10?o.detectingSelectAll=setTimeout(r,500):(o.selForContextMenu=null,o.input.reset())};o.detectingSelectAll=setTimeout(r,200)}}var n=this,i=n.cm,o=i.display,l=n.textarea,s=Sr(i,e),a=o.scroller.scrollTop;if(s&&!wl){i.options.resetSelectionOnContextMenu&&-1==i.doc.sel.contains(s)&&dn(i,bi)(i.doc,Rn(s),Gl);var u=l.style.cssText,c=n.wrapper.style.cssText;n.wrapper.style.cssText="position: absolute";var f=n.wrapper.getBoundingClientRect();l.style.cssText="position: absolute; width: 30px; height: 30px;\n      top: "+(e.clientY-f.top-5)+"px; left: "+(e.clientX-f.left-5)+"px;\n      z-index: 1000; background: "+(gl?"rgba(255, 255, 255, .05)":"transparent")+";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";var h;if(ml&&(h=window.scrollY),o.input.focus(),ml&&window.scrollTo(null,h),o.input.reset(),i.somethingSelected()||(l.value=n.prevInput=" "),n.contextMenuPending=!0,o.selForContextMenu=i.doc.sel,clearTimeout(o.detectingSelectAll),gl&&vl>=9&&t(),Hl){Fe(e);var d=function(){ke(window,"mouseup",d),setTimeout(r,20)};Ql(window,"mouseup",d)}else setTimeout(r,50)}},Qs.prototype.readOnlyChanged=function(e){e||this.reset(),this.textarea.disabled="nocursor"==e},Qs.prototype.setUneditable=function(){},Qs.prototype.needsContentAttribute=!1,function(e){function t(t,n,i,o){e.defaults[t]=n,i&&(r[t]=o?function(e,t,r){r!=Xs&&i(e,t,r)}:i)}var r=e.optionHandlers;e.defineOption=t,e.Init=Xs,t("value","",function(e,t){return e.setValue(t)},!0),t("mode",null,function(e,t){e.doc.modeOption=t,jn(e)},!0),t("indentUnit",2,jn,!0),t("indentWithTabs",!1),t("smartIndent",!0),t("tabSize",4,function(e){Xn(e),er(e),vn(e)},!0),t("lineSeparator",null,function(e,t){if(e.doc.lineSep=t,t){var r=[],n=e.doc.first;e.doc.iter(function(e){for(var i=0;;){var o=e.text.indexOf(t,i);if(-1==o)break;i=o+t.length,r.push(E(n,o))}n++});for(var i=r.length-1;i>=0;i--)Ei(e.doc,t,r[i],E(r[i].line,r[i].ch+t.length))}}),t("specialChars",/[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff]/g,function(e,t,r){e.state.specialChars=new RegExp(t.source+(t.test("\t")?"":"|\t"),"g"),r!=Xs&&e.refresh()}),t("specialCharPlaceholder",at,function(e){return e.refresh()},!0),t("electricChars",!0),t("inputStyle",Tl?"contenteditable":"textarea",function(){throw new Error("inputStyle can not (yet) be changed in a running editor")},!0),t("spellcheck",!1,function(e,t){return e.getInputField().spellcheck=t},!0),t("rtlMoveVisually",!Ol),t("wholeLineUpdateBefore",!0),t("theme","default",function(e){Go(e),Uo(e)},!0),t("keyMap","default",function(e,t,r){var n=uo(t),i=r!=Xs&&uo(r);i&&i.detach&&i.detach(e,n),n.attach&&n.attach(e,i||null)}),t("extraKeys",null),t("configureMouse",null),t("lineWrapping",!1,Ko,!0),t("gutters",[],function(e){Fn(e.options),Uo(e)},!0),t("fixedGutter",!0,function(e,t){e.display.gutters.style.left=t?wr(e.display)+"px":"0",e.refresh()},!0),t("coverGutterNextToScrollbar",!1,function(e){return en(e)},!0),t("scrollbarStyle","native",function(e){rn(e),en(e),e.display.scrollbars.setScrollTop(e.doc.scrollTop),e.display.scrollbars.setScrollLeft(e.doc.scrollLeft)},!0),t("lineNumbers",!1,function(e){Fn(e.options),Uo(e)},!0),t("firstLineNumber",1,Uo,!0),t("lineNumberFormatter",function(e){return e},Uo,!0),t("showCursorWhenSelecting",!1,kr,!0),t("resetSelectionOnContextMenu",!0),t("lineWiseCopyCut",!0),t("pasteLinesPerSelection",!0),t("readOnly",!1,function(e,t){"nocursor"==t&&(Fr(e),e.display.input.blur()),e.display.input.readOnlyChanged(t)}),t("disableInput",!1,function(e,t){t||e.display.input.reset()},!0),t("dragDrop",!0,Vo),t("allowDropFileTypes",null),t("cursorBlinkRate",530),t("cursorScrollMargin",0),t("cursorHeight",1,kr,!0),t("singleCursorHeightPerLine",!0,kr,!0),t("workTime",100),t("workDelay",100),t("flattenSpans",!0,Xn,!0),t("addModeClass",!1,Xn,!0),t("pollInterval",100),t("undoDepth",200,function(e,t){return e.doc.history.undoDepth=t}),t("historyEventDelay",1250),t("viewportMargin",10,function(e){return e.refresh()},!0),t("maxHighlightLength",1e4,Xn,!0),t("moveInputWithCursor",!0,function(e,t){t||e.display.input.resetPosition()}),t("tabindex",null,function(e,t){return e.display.input.getField().tabIndex=t||""}),t("autofocus",null),t("direction","ltr",function(e,t){return e.doc.setDirection(t)},!0)}(jo),function(e){var t=e.optionHandlers,r=e.helpers={};e.prototype={constructor:e,focus:function(){window.focus(),this.display.input.focus()},setOption:function(e,r){var n=this.options,i=n[e];n[e]==r&&"mode"!=e||(n[e]=r,t.hasOwnProperty(e)&&dn(this,t[e])(this,r,i),Te(this,"optionChange",this,e))},getOption:function(e){return this.options[e]},getDoc:function(){return this.doc},addKeyMap:function(e,t){this.state.keyMaps[t?"push":"unshift"](uo(e))},removeKeyMap:function(e){for(var t=this.state.keyMaps,r=0;r<t.length;++r)if(t[r]==e||t[r].name==e)return t.splice(r,1),!0},addOverlay:pn(function(t,r){var n=t.token?t:e.getMode(this.options,t);if(n.startState)throw new Error("Overlays may not be stateful.");m(this.state.overlays,{mode:n,modeSpec:t,opaque:r&&r.opaque,priority:r&&r.priority||0},function(e){return e.priority}),this.state.modeGen++,vn(this)}),removeOverlay:pn(function(e){for(var t=this,r=this.state.overlays,n=0;n<r.length;++n){var i=r[n].modeSpec;if(i==e||"string"==typeof e&&i.name==e)return r.splice(n,1),t.state.modeGen++,void vn(t)}}),indentLine:pn(function(e,t,r){"string"!=typeof t&&"number"!=typeof t&&(t=null==t?this.options.smartIndent?"smart":"prev":t?"add":"subtract"),H(this.doc,e)&&Yo(this,e,t,r)}),indentSelection:pn(function(e){for(var t=this,r=this.doc.sel.ranges,n=-1,i=0;i<r.length;i++){var o=r[i];if(o.empty())o.head.line>n&&(Yo(t,o.head.line,e,!0),n=o.head.line,i==t.doc.sel.primIndex&&jr(t));else{var l=o.from(),s=o.to(),a=Math.max(n,l.line);n=Math.min(t.lastLine(),s.line-(s.ch?0:1))+1;for(var u=a;u<n;++u)Yo(t,u,e);var c=t.doc.sel.ranges;0==l.ch&&r.length==c.length&&c[i].from().ch>0&&gi(t.doc,i,new Ts(l,c[i].to()),Gl)}}}),getTokenAt:function(e,t){return Je(this,e,t)},getLineTokens:function(e,t){return Je(this,E(e),t,!0)},getTokenTypeAt:function(e){e=U(this.doc,e);var t,r=_e(this,M(this.doc,e.line)),n=0,i=(r.length-1)/2,o=e.ch;if(0==o)t=r[2];else for(;;){var l=n+i>>1;if((l?r[2*l-1]:0)>=o)i=l;else{if(!(r[2*l+1]<o)){t=r[2*l+2];break}n=l+1}}var s=t?t.indexOf("overlay "):-1;return s<0?t:0==s?null:t.slice(0,s-1)},getModeAt:function(t){var r=this.doc.mode;return r.innerMode?e.innerMode(r,this.getTokenAt(t).state).mode:r},getHelper:function(e,t){return this.getHelpers(e,t)[0]},getHelpers:function(e,t){var n=this,i=[];if(!r.hasOwnProperty(t))return i;var o=r[t],l=this.getModeAt(e);if("string"==typeof l[t])o[l[t]]&&i.push(o[l[t]]);else if(l[t])for(var s=0;s<l[t].length;s++){var a=o[l[t][s]];a&&i.push(a)}else l.helperType&&o[l.helperType]?i.push(o[l.helperType]):o[l.name]&&i.push(o[l.name]);for(var u=0;u<o._global.length;u++){var c=o._global[u];c.pred(l,n)&&-1==h(i,c.val)&&i.push(c.val)}return i},getStateAfter:function(e,t){var r=this.doc;return e=G(r,null==e?r.first+r.size-1:e),$e(this,e+1,t).state},cursorCoords:function(e,t){var r,n=this.doc.sel.primary();return r=null==e?n.head:"object"==typeof e?U(this.doc,e):e?n.from():n.to(),sr(this,r,t||"page")},charCoords:function(e,t){return lr(this,U(this.doc,e),t||"page")},coordsChar:function(e,t){return e=or(this,e,t||"page"),cr(this,e.left,e.top)},lineAtHeight:function(e,t){return e=or(this,{top:e,left:0},t||"page").top,D(this.doc,e+this.display.viewOffset)},heightAtLine:function(e,t,r){var n,i=!1;if("number"==typeof e){var o=this.doc.first+this.doc.size-1;e<this.doc.first?e=this.doc.first:e>o&&(e=o,i=!0),n=M(this.doc,e)}else n=e;return ir(this,n,{top:0,left:0},t||"page",r||i).top+(i?this.doc.height-ye(n):0)},defaultTextHeight:function(){return mr(this.display)},defaultCharWidth:function(){return yr(this.display)},getViewport:function(){return{from:this.display.viewFrom,to:this.display.viewTo}},addWidget:function(e,t,r,n,i){var o=this.display,l=(e=sr(this,U(this.doc,e))).bottom,s=e.left;if(t.style.position="absolute",t.setAttribute("cm-ignore-events","true"),this.display.input.setUneditable(t),o.sizer.appendChild(t),"over"==n)l=e.top;else if("above"==n||"near"==n){var a=Math.max(o.wrapper.clientHeight,this.doc.height),u=Math.max(o.sizer.clientWidth,o.lineSpace.clientWidth);("above"==n||e.bottom+t.offsetHeight>a)&&e.top>t.offsetHeight?l=e.top-t.offsetHeight:e.bottom+t.offsetHeight<=a&&(l=e.bottom),s+t.offsetWidth>u&&(s=u-t.offsetWidth)}t.style.top=l+"px",t.style.left=t.style.right="","right"==i?(s=o.sizer.clientWidth-t.offsetWidth,t.style.right="0px"):("left"==i?s=0:"middle"==i&&(s=(o.sizer.clientWidth-t.offsetWidth)/2),t.style.left=s+"px"),r&&Ur(this,{left:s,top:l,right:s+t.offsetWidth,bottom:l+t.offsetHeight})},triggerOnKeyDown:pn(Lo),triggerOnKeyPress:pn(Mo),triggerOnKeyUp:To,triggerOnMouseDown:pn(Oo),execCommand:function(e){if(Bs.hasOwnProperty(e))return Bs[e].call(null,this)},triggerElectric:pn(function(e){Zo(this,e)}),findPosH:function(e,t,r,n){var i=this,o=1;t<0&&(o=-1,t=-t);for(var l=U(this.doc,e),s=0;s<t&&!(l=tl(i.doc,l,o,r,n)).hitSide;++s);return l},moveH:pn(function(e,t){var r=this;this.extendSelectionsBy(function(n){return r.display.shift||r.doc.extend||n.empty()?tl(r.doc,n.head,e,t,r.options.rtlMoveVisually):e<0?n.from():n.to()},Vl)}),deleteH:pn(function(e,t){var r=this.doc.sel,n=this.doc;r.somethingSelected()?n.replaceSelection("",null,"+delete"):co(this,function(r){var i=tl(n,r.head,e,t,!1);return e<0?{from:i,to:r.head}:{from:r.head,to:i}})}),findPosV:function(e,t,r,n){var i=this,o=1,l=n;t<0&&(o=-1,t=-t);for(var s=U(this.doc,e),a=0;a<t;++a){var u=sr(i,s,"div");if(null==l?l=u.left:u.left=l,(s=rl(i,u,o,r)).hitSide)break}return s},moveV:pn(function(e,t){var r=this,n=this.doc,i=[],o=!this.display.shift&&!n.extend&&n.sel.somethingSelected();if(n.extendSelectionsBy(function(l){if(o)return e<0?l.from():l.to();var s=sr(r,l.head,"div");null!=l.goalColumn&&(s.left=l.goalColumn),i.push(s.left);var a=rl(r,s,e,t);return"page"==t&&l==n.sel.primary()&&Kr(r,lr(r,a,"div").top-s.top),a},Vl),i.length)for(var l=0;l<n.sel.ranges.length;l++)n.sel.ranges[l].goalColumn=i[l]}),findWordAt:function(e){var t=M(this.doc,e.line).text,r=e.ch,n=e.ch;if(t){var i=this.getHelper(e,"wordChars");"before"!=e.sticky&&n!=t.length||!r?++n:--r;for(var o=t.charAt(r),l=x(o,i)?function(e){return x(e,i)}:/\s/.test(o)?function(e){return/\s/.test(e)}:function(e){return!/\s/.test(e)&&!x(e)};r>0&&l(t.charAt(r-1));)--r;for(;n<t.length&&l(t.charAt(n));)++n}return new Ts(E(e.line,r),E(e.line,n))},toggleOverwrite:function(e){null!=e&&e==this.state.overwrite||((this.state.overwrite=!this.state.overwrite)?s(this.display.cursorDiv,"CodeMirror-overwrite"):Fl(this.display.cursorDiv,"CodeMirror-overwrite"),Te(this,"overwriteToggle",this,this.state.overwrite))},hasFocus:function(){return this.display.input.getField()==l()},isReadOnly:function(){return!(!this.options.readOnly&&!this.doc.cantEdit)},scrollTo:pn(function(e,t){Xr(this,e,t)}),getScrollInfo:function(){var e=this.display.scroller;return{left:e.scrollLeft,top:e.scrollTop,height:e.scrollHeight-zt(this)-this.display.barHeight,width:e.scrollWidth-zt(this)-this.display.barWidth,clientHeight:Bt(this),clientWidth:Rt(this)}},scrollIntoView:pn(function(e,t){null==e?(e={from:this.doc.sel.primary().head,to:null},null==t&&(t=this.options.cursorScrollMargin)):"number"==typeof e?e={from:E(e,0),to:null}:null==e.from&&(e={from:e,to:null}),e.to||(e.to=e.from),e.margin=t||0,null!=e.from.line?Yr(this,e):$r(this,e.from,e.to,e.margin)}),setSize:pn(function(e,t){var r=this,n=function(e){return"number"==typeof e||/^\d+$/.test(String(e))?e+"px":e};null!=e&&(this.display.wrapper.style.width=n(e)),null!=t&&(this.display.wrapper.style.height=n(t)),this.options.lineWrapping&&Jt(this);var i=this.display.viewFrom;this.doc.iter(i,this.display.viewTo,function(e){if(e.widgets)for(var t=0;t<e.widgets.length;t++)if(e.widgets[t].noHScroll){mn(r,i,"widget");break}++i}),this.curOp.forceUpdate=!0,Te(this,"refresh",this)}),operation:function(e){return hn(this,e)},startOperation:function(){return nn(this)},endOperation:function(){return on(this)},refresh:pn(function(){var e=this.display.cachedTextHeight;vn(this),this.curOp.forceUpdate=!0,er(this),Xr(this,this.doc.scrollLeft,this.doc.scrollTop),Wn(this),(null==e||Math.abs(e-mr(this.display))>.5)&&Cr(this),Te(this,"refresh",this)}),swapDoc:pn(function(e){var t=this.doc;return t.cm=null,qn(this,e),er(this),this.display.input.reset(),Xr(this,e.scrollLeft,e.scrollTop),this.curOp.forceScroll=!0,bt(this,"swapDoc",this,t),t}),getInputField:function(){return this.display.input.getField()},getWrapperElement:function(){return this.display.wrapper},getScrollerElement:function(){return this.display.scroller},getGutterElement:function(){return this.display.gutters}},Ae(e),e.registerHelper=function(t,n,i){r.hasOwnProperty(t)||(r[t]=e[t]={_global:[]}),r[t][n]=i},e.registerGlobalHelper=function(t,n,i,o){e.registerHelper(t,n,o),r[t]._global.push({pred:i,val:o})}}(jo);var Js="iter insert remove copy getEditor constructor".split(" ");for(var ea in Ds.prototype)Ds.prototype.hasOwnProperty(ea)&&h(Js,ea)<0&&(jo.prototype[ea]=function(e){return function(){return e.apply(this.doc,arguments)}}(Ds.prototype[ea]));return Ae(Ds),jo.inputStyles={textarea:Qs,contenteditable:Zs},jo.defineMode=function(e){jo.defaults.mode||"null"==e||(jo.defaults.mode=e),Be.apply(this,arguments)},jo.defineMIME=function(e,t){os[e]=t},jo.defineMode("null",function(){return{token:function(e){return e.skipToEnd()}}}),jo.defineMIME("text/plain","null"),jo.defineExtension=function(e,t){jo.prototype[e]=t},jo.defineDocExtension=function(e,t){Ds.prototype[e]=t},jo.fromTextArea=function(e,t){function r(){e.value=a.getValue()}if(t=t?c(t):{},t.value=e.value,!t.tabindex&&e.tabIndex&&(t.tabindex=e.tabIndex),!t.placeholder&&e.placeholder&&(t.placeholder=e.placeholder),null==t.autofocus){var n=l();t.autofocus=n==e||null!=e.getAttribute("autofocus")&&n==document.body}var i;if(e.form&&(Ql(e.form,"submit",r),!t.leaveSubmitMethodAlone)){var o=e.form;i=o.submit;try{var s=o.submit=function(){r(),o.submit=i,o.submit(),o.submit=s}}catch(e){}}t.finishInit=function(t){t.save=r,t.getTextArea=function(){return e},t.toTextArea=function(){t.toTextArea=isNaN,r(),e.parentNode.removeChild(t.getWrapperElement()),e.style.display="",e.form&&(ke(e.form,"submit",r),"function"==typeof e.form.submit&&(e.form.submit=i))}},e.style.display="none";var a=jo(function(t){return e.parentNode.insertBefore(t,e.nextSibling)},t);return a},function(e){e.off=ke,e.on=Ql,e.wheelEventPixels=Pn,e.Doc=Ds,e.splitLines=es,e.countColumn=f,e.findColumn=d,e.isWordChar=w,e.Pass=Bl,e.signal=Te,e.Line=fs,e.changeEnd=Bn,e.scrollbarModel=ws,e.Pos=E,e.cmpPos=P,e.modes=is,e.mimeModes=os,e.resolveMode=Ge,e.getMode=Ue,e.modeExtensions=ls,e.extendMode=Ve,e.copyState=Ke,e.startState=Xe,e.innerMode=je,e.commands=Bs,e.keyMap=Rs,e.keyName=ao,e.isModifierKey=lo,e.lookupKey=oo,e.normalizeKeyMap=io,e.StringStream=ss,e.SharedTextMarker=As,e.TextMarker=Os,e.LineWidget=Ms,e.e_preventDefault=We,e.e_stopPropagation=De,e.e_stop=Fe,e.addClass=s,e.contains=o,e.rmClass=Fl,e.keyNames=Es}(jo),jo.version="5.30.0",jo});
      !function(e){"object"==typeof exports&&"object"==typeof module?e(require("../../lib/codemirror")):"function"==typeof define&&define.amd?define(["../../lib/codemirror"],e):e(CodeMirror)}(function(e){"use strict";function t(e,t,n,r,o,a){this.indented=e,this.column=t,this.type=n,this.info=r,this.align=o,this.prev=a}function n(e,n,r,o){var a=e.indented;return e.context&&"statement"==e.context.type&&"statement"!=r&&(a=e.context.indented),e.context=new t(a,n,r,o,null,e.context)}function r(e){var t=e.context.type;return")"!=t&&"]"!=t&&"}"!=t||(e.indented=e.context.indented),e.context=e.context.prev}function o(e,t,n){return"variable"==t.prevToken||"type"==t.prevToken||(!!/\S(?:[^- ]>|[*\]])\s*$|\*$/.test(e.string.slice(0,n))||(!(!t.typeAtEndOfLine||e.column()!=e.indentation())||void 0))}function a(e){for(;;){if(!e||"top"==e.type)return!0;if("}"==e.type&&"namespace"!=e.prev.info)return!1;e=e.prev}}function i(e){for(var t={},n=e.split(" "),r=0;r<n.length;++r)t[n[r]]=!0;return t}function l(e,t){return"function"==typeof e?e(t):e.propertyIsEnumerable(t)}function s(e,t){if(!t.startOfLine)return!1;for(var n,r=null;n=e.peek();){if("\\"==n&&e.match(/^.$/)){r=s;break}if("/"==n&&e.match(/^\/[\/\*]/,!1))break;e.next()}return t.tokenize=r,"meta"}function c(e,t){return"type"==t.prevToken&&"type"}function u(e){return e.eatWhile(/[\w\.']/),"number"}function d(e,t){if(e.backUp(1),e.match(/(R|u8R|uR|UR|LR)/)){var n=e.match(/"([^\s\\()]{0,16})\(/);return!!n&&(t.cpp11RawStringDelim=n[1],t.tokenize=m,m(e,t))}return e.match(/(u8|u|U|L)/)?!!e.match(/["']/,!1)&&"string":(e.next(),!1)}function f(e){var t=/(\w+)::~?(\w+)$/.exec(e);return t&&t[1]==t[2]}function p(e,t){for(var n;null!=(n=e.next());)if('"'==n&&!e.eat('"')){t.tokenize=null;break}return"string"}function m(e,t){var n=t.cpp11RawStringDelim.replace(/[^\w\s]/g,"\\$&");return e.match(new RegExp(".*?\\)"+n+'"'))?t.tokenize=null:e.skipToEnd(),"string"}function h(t,n){function r(e){if(e)for(var t in e)e.hasOwnProperty(t)&&o.push(t)}"string"==typeof t&&(t=[t]);var o=[];r(n.keywords),r(n.types),r(n.builtin),r(n.atoms),o.length&&(n.helperType=t[0],e.registerHelper("hintWords",t[0],o));for(var a=0;a<t.length;++a)e.defineMIME(t[a],n)}function g(e,t){for(var n=!1;!e.eol();){if(!n&&e.match('"""')){t.tokenize=null;break}n="\\"==e.next()&&!n}return"string"}function y(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!e&&!o&&t.match('"')){a=!0;break}if(e&&t.match('"""')){a=!0;break}r=t.next(),!o&&"$"==r&&t.match("{")&&t.skipTo("}"),o=!o&&"\\"==r&&!e}return!a&&e||(n.tokenize=null),"string"}}function x(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!o&&t.match('"')&&("single"==e||t.match('""'))){a=!0;break}if(!o&&t.match("``")){w=x(e),a=!0;break}r=t.next(),o="single"==e&&!o&&"\\"==r}return a&&(n.tokenize=null),"string"}}e.defineMode("clike",function(i,s){function c(e,t){var n=e.next();if(S[n]){var r=S[n](e,t);if(!1!==r)return r}if('"'==n||"'"==n)return t.tokenize=u(n),t.tokenize(e,t);if(D.test(n))return p=n,null;if(L.test(n)){if(e.backUp(1),e.match(I))return"number";e.next()}if("/"==n){if(e.eat("*"))return t.tokenize=d,d(e,t);if(e.eat("/"))return e.skipToEnd(),"comment"}if(F.test(n)){for(;!e.match(/^\/[\/*]/,!1)&&e.eat(F););return"operator"}if(e.eatWhile(z),P)for(;e.match(P);)e.eatWhile(z);var o=e.current();return l(x,o)?(l(w,o)&&(p="newstatement"),l(v,o)&&(m=!0),"keyword"):l(b,o)?"type":l(k,o)?(l(w,o)&&(p="newstatement"),"builtin"):l(_,o)?"atom":"variable"}function u(e){return function(t,n){for(var r,o=!1,a=!1;null!=(r=t.next());){if(r==e&&!o){a=!0;break}o=!o&&"\\"==r}return(a||!o&&!C)&&(n.tokenize=null),"string"}}function d(e,t){for(var n,r=!1;n=e.next();){if("/"==n&&r){t.tokenize=null;break}r="*"==n}return"comment"}function f(e,t){s.typeFirstDefinitions&&e.eol()&&a(t.context)&&(t.typeAtEndOfLine=o(e,t,e.pos))}var p,m,h=i.indentUnit,g=s.statementIndentUnit||h,y=s.dontAlignCalls,x=s.keywords||{},b=s.types||{},k=s.builtin||{},w=s.blockKeywords||{},v=s.defKeywords||{},_=s.atoms||{},S=s.hooks||{},C=s.multiLineStrings,T=!1!==s.indentStatements,M=!1!==s.indentSwitch,P=s.namespaceSeparator,D=s.isPunctuationChar||/[\[\]{}\(\),;\:\.]/,L=s.numberStart||/[\d\.]/,I=s.number||/^(?:0x[a-f\d]+|0b[01]+|(?:\d+\.?\d*|\.\d+)(?:e[-+]?\d+)?)(u|ll?|l|f)?/i,F=s.isOperatorChar||/[+\-*&%=<>!?|\/]/,z=s.isIdentifierChar||/[\w\$_\xa1-\uffff]/;return{startState:function(e){return{tokenize:null,context:new t((e||0)-h,0,"top",null,!1),indented:0,startOfLine:!0,prevToken:null}},token:function(e,t){var i=t.context;if(e.sol()&&(null==i.align&&(i.align=!1),t.indented=e.indentation(),t.startOfLine=!0),e.eatSpace())return f(e,t),null;p=m=null;var l=(t.tokenize||c)(e,t);if("comment"==l||"meta"==l)return l;if(null==i.align&&(i.align=!0),";"==p||":"==p||","==p&&e.match(/^\s*(?:\/\/.*)?$/,!1))for(;"statement"==t.context.type;)r(t);else if("{"==p)n(t,e.column(),"}");else if("["==p)n(t,e.column(),"]");else if("("==p)n(t,e.column(),")");else if("}"==p){for(;"statement"==i.type;)i=r(t);for("}"==i.type&&(i=r(t));"statement"==i.type;)i=r(t)}else p==i.type?r(t):T&&(("}"==i.type||"top"==i.type)&&";"!=p||"statement"==i.type&&"newstatement"==p)&&n(t,e.column(),"statement",e.current());if("variable"==l&&("def"==t.prevToken||s.typeFirstDefinitions&&o(e,t,e.start)&&a(t.context)&&e.match(/^\s*\(/,!1))&&(l="def"),S.token){var u=S.token(e,t,l);void 0!==u&&(l=u)}return"def"==l&&!1===s.styleDefs&&(l="variable"),t.startOfLine=!1,t.prevToken=m?"def":l||p,f(e,t),l},indent:function(t,n){if(t.tokenize!=c&&null!=t.tokenize||t.typeAtEndOfLine)return e.Pass;var r=t.context,o=n&&n.charAt(0);if("statement"==r.type&&"}"==o&&(r=r.prev),s.dontIndentStatements)for(;"statement"==r.type&&s.dontIndentStatements.test(r.info);)r=r.prev;if(S.indent){var a=S.indent(t,r,n);if("number"==typeof a)return a}var i=o==r.type,l=r.prev&&"switch"==r.prev.info;if(s.allmanIndentation&&/[{(]/.test(o)){for(;"top"!=r.type&&"}"!=r.type;)r=r.prev;return r.indented}return"statement"==r.type?r.indented+("{"==o?0:g):!r.align||y&&")"==r.type?")"!=r.type||i?r.indented+(i?0:h)+(i||!l||/^(?:case|default)\b/.test(n)?0:h):r.indented+g:r.column+(i?0:1)},electricInput:M?/^\s*(?:case .*?:|default:|\{\}?|\})$/:/^\s*[{}]$/,blockCommentStart:"/*",blockCommentEnd:"*/",lineComment:"//",fold:"brace"}});var b="auto if break case register continue return default do sizeof static else struct switch extern typedef union for goto while enum const volatile",k="int long char short double float unsigned signed void size_t ptrdiff_t";h(["text/x-csrc","text/x-c","text/x-chdr"],{name:"clike",keywords:i(b),types:i(k+" bool _Complex _Bool float_t double_t intptr_t intmax_t int8_t int16_t int32_t int64_t uintptr_t uintmax_t uint8_t uint16_t uint32_t uint64_t"),blockKeywords:i("case do else for if switch while struct"),defKeywords:i("struct"),typeFirstDefinitions:!0,atoms:i("null true false"),hooks:{"#":s,"*":c},modeProps:{fold:["brace","include"]}}),h(["text/x-c++src","text/x-c++hdr"],{name:"clike",keywords:i(b+" asm dynamic_cast namespace reinterpret_cast try explicit new static_cast typeid catch operator template typename class friend private this using const_cast inline public throw virtual delete mutable protected alignas alignof constexpr decltype nullptr noexcept thread_local final static_assert override"),types:i(k+" bool wchar_t"),blockKeywords:i("catch class do else finally for if struct switch try while"),defKeywords:i("class namespace struct enum union"),typeFirstDefinitions:!0,atoms:i("true false null"),dontIndentStatements:/^template$/,isIdentifierChar:/[\w\$_~\xa1-\uffff]/,hooks:{"#":s,"*":c,u:d,U:d,L:d,R:d,0:u,1:u,2:u,3:u,4:u,5:u,6:u,7:u,8:u,9:u,token:function(e,t,n){if("variable"==n&&"("==e.peek()&&(";"==t.prevToken||null==t.prevToken||"}"==t.prevToken)&&f(e.current()))return"def"}},namespaceSeparator:"::",modeProps:{fold:["brace","include"]}}),h("text/x-java",{name:"clike",keywords:i("abstract assert break case catch class const continue default do else enum extends final finally float for goto if implements import instanceof interface native new package private protected public return static strictfp super switch synchronized this throw throws transient try volatile while @interface"),types:i("byte short int long float double boolean char void Boolean Byte Character Double Float Integer Long Number Object Short String StringBuffer StringBuilder Void"),blockKeywords:i("catch class do else finally for if switch try while"),defKeywords:i("class interface package enum @interface"),typeFirstDefinitions:!0,atoms:i("true false null"),number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,hooks:{"@":function(e){return!e.match("interface",!1)&&(e.eatWhile(/[\w\$_]/),"meta")}},modeProps:{fold:["brace","import"]}}),h("text/x-csharp",{name:"clike",keywords:i("abstract as async await base break case catch checked class const continue default delegate do else enum event explicit extern finally fixed for foreach goto if implicit in interface internal is lock namespace new operator out override params private protected public readonly ref return sealed sizeof stackalloc static struct switch this throw try typeof unchecked unsafe using virtual void volatile while add alias ascending descending dynamic from get global group into join let orderby partial remove select set value var yield"),types:i("Action Boolean Byte Char DateTime DateTimeOffset Decimal Double Func Guid Int16 Int32 Int64 Object SByte Single String Task TimeSpan UInt16 UInt32 UInt64 bool byte char decimal double short int long object sbyte float string ushort uint ulong"),blockKeywords:i("catch class do else finally for foreach if struct switch try while"),defKeywords:i("class interface namespace struct var"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"@":function(e,t){return e.eat('"')?(t.tokenize=p,p(e,t)):(e.eatWhile(/[\w\$_]/),"meta")}}}),h("text/x-scala",{name:"clike",keywords:i("abstract case catch class def do else extends final finally for forSome if implicit import lazy match new null object override package private protected return sealed super this throw trait try type val var while with yield _ assert assume require print println printf readLine readBoolean readByte readShort readChar readInt readLong readFloat readDouble"),types:i("AnyVal App Application Array BufferedIterator BigDecimal BigInt Char Console Either Enumeration Equiv Error Exception Fractional Function IndexedSeq Int Integral Iterable Iterator List Map Numeric Nil NotNull Option Ordered Ordering PartialFunction PartialOrdering Product Proxy Range Responder Seq Serializable Set Specializable Stream StringBuilder StringContext Symbol Throwable Traversable TraversableOnce Tuple Unit Vector Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),multiLineStrings:!0,blockKeywords:i("catch class enum do else finally for forSome if match switch try while"),defKeywords:i("class enum def object package trait type val var"),atoms:i("true false null"),indentStatements:!1,indentSwitch:!1,isOperatorChar:/[+\-*&%=<>!?|\/#:@]/,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return!!e.match('""')&&(t.tokenize=g,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},"=":function(e,n){var r=n.context;return!("}"!=r.type||!r.align||!e.eat(">"))&&(n.context=new t(r.indented,r.column,r.type,r.info,null,r.prev),"operator")}},modeProps:{closeBrackets:{triples:'"'}}}),h("text/x-kotlin",{name:"clike",keywords:i("package as typealias class interface this super val var fun for is in This throw return break continue object if else while do try when !in !is as? file import where by get set abstract enum open inner override private public internal protected catch finally out final vararg reified dynamic companion constructor init sealed field property receiver param sparam lateinit data inline noinline tailrec external annotation crossinline const operator infix suspend"),types:i("Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),intendSwitch:!1,indentStatements:!1,multiLineStrings:!0,number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,blockKeywords:i("catch class do else finally for if where try while enum"),defKeywords:i("class val var object package interface fun"),atoms:i("true false null this"),hooks:{'"':function(e,t){return t.tokenize=y(e.match('""')),t.tokenize(e,t)}},modeProps:{closeBrackets:{triples:'"'}}}),h(["x-shader/x-vertex","x-shader/x-fragment"],{name:"clike",keywords:i("sampler1D sampler2D sampler3D samplerCube sampler1DShadow sampler2DShadow const attribute uniform varying break continue discard return for while do if else struct in out inout"),types:i("float int bool void vec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4 mat2 mat3 mat4"),blockKeywords:i("for while do if else struct"),builtin:i("radians degrees sin cos tan asin acos atan pow exp log exp2 sqrt inversesqrt abs sign floor ceil fract mod min max clamp mix step smoothstep length distance dot cross normalize ftransform faceforward reflect refract matrixCompMult lessThan lessThanEqual greaterThan greaterThanEqual equal notEqual any all not texture1D texture1DProj texture1DLod texture1DProjLod texture2D texture2DProj texture2DLod texture2DProjLod texture3D texture3DProj texture3DLod texture3DProjLod textureCube textureCubeLod shadow1D shadow2D shadow1DProj shadow2DProj shadow1DLod shadow2DLod shadow1DProjLod shadow2DProjLod dFdx dFdy fwidth noise1 noise2 noise3 noise4"),atoms:i("true false gl_FragColor gl_SecondaryColor gl_Normal gl_Vertex gl_MultiTexCoord0 gl_MultiTexCoord1 gl_MultiTexCoord2 gl_MultiTexCoord3 gl_MultiTexCoord4 gl_MultiTexCoord5 gl_MultiTexCoord6 gl_MultiTexCoord7 gl_FogCoord gl_PointCoord gl_Position gl_PointSize gl_ClipVertex gl_FrontColor gl_BackColor gl_FrontSecondaryColor gl_BackSecondaryColor gl_TexCoord gl_FogFragCoord gl_FragCoord gl_FrontFacing gl_FragData gl_FragDepth gl_ModelViewMatrix gl_ProjectionMatrix gl_ModelViewProjectionMatrix gl_TextureMatrix gl_NormalMatrix gl_ModelViewMatrixInverse gl_ProjectionMatrixInverse gl_ModelViewProjectionMatrixInverse gl_TexureMatrixTranspose gl_ModelViewMatrixInverseTranspose gl_ProjectionMatrixInverseTranspose gl_ModelViewProjectionMatrixInverseTranspose gl_TextureMatrixInverseTranspose gl_NormalScale gl_DepthRange gl_ClipPlane gl_Point gl_FrontMaterial gl_BackMaterial gl_LightSource gl_LightModel gl_FrontLightModelProduct gl_BackLightModelProduct gl_TextureColor gl_EyePlaneS gl_EyePlaneT gl_EyePlaneR gl_EyePlaneQ gl_FogParameters gl_MaxLights gl_MaxClipPlanes gl_MaxTextureUnits gl_MaxTextureCoords gl_MaxVertexAttribs gl_MaxVertexUniformComponents gl_MaxVaryingFloats gl_MaxVertexTextureImageUnits gl_MaxTextureImageUnits gl_MaxFragmentUniformComponents gl_MaxCombineTextureImageUnits gl_MaxDrawBuffers"),indentSwitch:!1,hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-nesc",{name:"clike",keywords:i(b+"as atomic async call command component components configuration event generic implementation includes interface module new norace nx_struct nx_union post provides signal task uses abstract extends"),types:i(k),blockKeywords:i("case do else for if switch while struct"),atoms:i("null true false"),hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-objectivec",{name:"clike",keywords:i(b+"inline restrict _Bool _Complex _Imaginary BOOL Class bycopy byref id IMP in inout nil oneway out Protocol SEL self super atomic nonatomic retain copy readwrite readonly"),types:i(k),atoms:i("YES NO NULL NILL ON OFF true false"),hooks:{"@":function(e){return e.eatWhile(/[\w\$]/),"keyword"},"#":s,indent:function(e,t,n){if("statement"==t.type&&/^@\w/.test(n))return t.indented}},modeProps:{fold:"brace"}}),h("text/x-squirrel",{name:"clike",keywords:i("base break clone continue const default delete enum extends function in class foreach local resume return this throw typeof yield constructor instanceof static"),types:i(k),blockKeywords:i("case catch class else for foreach if switch try while"),defKeywords:i("function local class"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"#":s},modeProps:{fold:["brace","include"]}});var w=null;h("text/x-ceylon",{name:"clike",keywords:i("abstracts alias assembly assert assign break case catch class continue dynamic else exists extends finally for function given if import in interface is let module new nonempty object of out outer package return satisfies super switch then this throw try value void while"),types:function(e){var t=e.charAt(0);return t===t.toUpperCase()&&t!==t.toLowerCase()},blockKeywords:i("case catch class dynamic else finally for function if interface module new object switch try while"),defKeywords:i("class dynamic function interface module object package value"),builtin:i("abstract actual aliased annotation by default deprecated doc final formal late license native optional sealed see serializable shared suppressWarnings tagged throws variable"),isPunctuationChar:/[\[\]{}\(\),;\:\.`]/,isOperatorChar:/[+\-*&%=<>!?|^~:\/]/,numberStart:/[\d#$]/,number:/^(?:#[\da-fA-F_]+|\$[01_]+|[\d_]+[kMGTPmunpf]?|[\d_]+\.[\d_]+(?:[eE][-+]?\d+|[kMGTPmunpf]|)|)/i,multiLineStrings:!0,typeFirstDefinitions:!0,atoms:i("true false null larger smaller equal empty finished"),indentSwitch:!1,styleDefs:!1,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return t.tokenize=x(e.match('""')?"triple":"single"),t.tokenize(e,t)},"`":function(e,t){return!(!w||!e.match("`"))&&(t.tokenize=w,w=null,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},token:function(e,t,n){if(("variable"==n||"type"==n)&&"."==t.prevToken)return"variable-2"}},modeProps:{fold:["brace","import"],closeBrackets:{triples:'"'}}})});
      // -------------------------------------------------------------------------
//  Part of the CodeChecker project, under the Apache License v2.0 with
//  LLVM Exceptions. See LICENSE for license information.
//  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
// -------------------------------------------------------------------------

var BugViewer = {
  _files : [],
  _reports : [],
  _lineWidgets : [],
  _navigationMenuItems : [],
  _sourceFileData : null,
  _currentReport : null,
  _lastBugEvent  : null,

  init : function (files, reports) {
    this._files = files;
    this._reports = reports;

    this.initEscapeChars();
  },

  initEscapeChars : function () {
    this.escapeChars = {
      ' ' : 'nbsp',
      '<' : 'lt',
      '>' : 'gt',
      '"' : 'quot',
      '&' : 'amp'
    };

    var regexString = '[';
    for (var key in this.escapeChars) {
      regexString += key;
    }
    regexString += ']';

    this.escapeRegExp = new RegExp( regexString, 'g');
  },

  escapeHTML : function (str) {
    var that = this;

    return str.replace(this.escapeRegExp, function (m) {
      return '&' + that.escapeChars[m] + ';';
    });
  },

  initByUrl : function () {
    if (!this._reports) return;

    var state = {};
    window.location.hash.substr(1).split('&').forEach(function (s) {
      var parts = s.split('=');
      state[parts[0]] = parts[1];
    });

    for (var key in this._reports) {
      var report = this._reports[key];
      if (report.reportHash === state['reportHash']) {
        this.navigate(report);
        return;
      }
    }

    this.navigate(this._reports[0]);
  },

  create : function () {
    this._content = document.getElementById('editor-wrapper');
    this._filepath = document.getElementById('file-path');
    this._checkerName = document.getElementById('checker-name');
    this._reviewStatusWrapper =
      document.getElementById('review-status-wrapper');
    this._reviewStatus = document.getElementById('review-status');
    this._editor = document.getElementById('editor');

    this._codeMirror = CodeMirror(this._editor, {
      mode: 'text/x-c++src',
      matchBrackets : true,
      lineNumbers : true,
      readOnly : true,
      foldGutter : true,
      extraKeys : {},
      viewportMargin : 100
    });

    this._createNavigationMenu();
  },

  navigate : function (report, item) {
    if (!item) {
      var items = this._navigationMenuItems.filter(function (navItem) {
        return navItem.report.reportHash === report.reportHash;
      });

      if (!items.length) return;

      item = items[0].widget;
    }

    this._selectedReport.classList.remove('active');
    this._selectedReport = item;
    this._selectedReport.classList.add('active');
    this.setReport(report);
  },

  _createNavigationMenu : function () {
    var that = this;

    var nav = document.getElementById('report-nav');
    var list = document.createElement('ul');
    this._reports.forEach(function (report) {
      var events = report['events'];
      var lastBugEvent = events[events.length - 1];
      var item = document.createElement('li');

      var severity = document.createElement('i');
      severity.className = 'severity-' + report.severity.toLowerCase();

      item.appendChild(severity);
      item.appendChild(document.createTextNode(lastBugEvent.message));

      item.addEventListener('click', function () {
        that.navigate(report, item);
      })
      list.appendChild(item);
      that._navigationMenuItems.push({ report : report, widget : item });
    });

    if (!this._selectedReport && list.childNodes.length) {
      this._selectedReport = list.childNodes[0];
      this._selectedReport.classList.add('active');
    }

    nav.appendChild(list);
  },

  setReport : function (report) {
    this._currentReport = report;
    var events = report['events'];
    var lastBugEvent = events[events.length - 1];
    this.setCurrentBugEvent(lastBugEvent, events.length - 1);
    this.setCheckerName(report.checkerName);
    this.setReviewStatus(report.reviewStatus);

    window.location.hash = '#reportHash=' + report.reportHash;
  },

  setCurrentBugEvent : function (event, idx) {
    this._currentBugEvent = event;
    this.setSourceFileData(this._files[event.location.file]);
    this.drawBugPath();

    this.jumpTo(event.location.line, 0);
    this.highlightBugEvent(event, idx);
  },

  highlightBugEvent : function (event, idx) {
    this._lineWidgets.forEach(function (widget) {
      var lineIdx = widget.node.getAttribute('idx');
      if (parseInt(lineIdx) === idx) {
        widget.node.classList.add('current');
      }
    });
  },

  setCheckerName : function (checkerName) {
    this._checkerName.innerHTML = checkerName;
  },

  setReviewStatus : function (status) {
    if (status) {
      var className =
        'review-status-' + status.toLowerCase().split(' ').join('-');
      this._reviewStatus.className = "review-status " + className;

      this._reviewStatus.innerHTML = status;
      this._reviewStatusWrapper.style.display = 'block';
    } else {
      this._reviewStatusWrapper.style.display = 'none';
    }
  },

  setSourceFileData : function (file) {
    if (this._sourceFileData && file.id === this._sourceFileData.id) {
      return;
    }

    this._sourceFileData = file;
    this._filepath.innerHTML = file.path;
    this._codeMirror.doc.setValue(file.content);
    this._refresh();
  },

  _refresh : function () {
    var that = this;
    setTimeout(function () {
      var fullHeight = parseInt(that._content.clientHeight);
      var headerHeight = that._filepath.clientHeight;

      that._codeMirror.setSize('auto', fullHeight - headerHeight);
      that._codeMirror.refresh();
    }, 200);
  },

  clearBubbles : function () {
    this._lineWidgets.forEach(function (widget) { widget.clear(); });
    this._lineWidgets = [];
  },

  getMessage : function (event, kind) {
    if (kind === 'macro') {
      var name = 'macro expansion' + (event.name ? ': ' + event.name : '');

      return '<span class="tag macro">' + name + '</span>'
        + this.escapeHTML(event.expansion).replace(/(?:\r\n|\r|\n)/g, '<br>');
    } else if (kind === 'note') {
      return '<span class="tag note">note</span>'
        +  this.escapeHTML(event.message).replace(/(?:\r\n|\r|\n)/g, '<br>');
    }
  },

  addExtraPathEvents : function (events, kind) {
    var that = this;

    if (!events) {
      return;
    }

    events.forEach(function (event) {
      if (event.location.file !== that._currentBugEvent.location.file) {
        return;
      }

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + kind);

      var msg = document.createElement('span');
      msg.innerHTML = that.getMessage(event, kind);
      element.appendChild(msg);

      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  drawBugPath : function () {
    var that = this;

    this.clearBubbles();

    this.addExtraPathEvents(this._currentReport.macros, 'macro');
    this.addExtraPathEvents(this._currentReport.notes, 'note');

    // Processing bug path events.
    var currentEvents = this._currentReport.events;
    currentEvents.forEach(function (event, step) {
      if (event.location.file !== that._currentBugEvent.location.file)
        return;

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';
      var type = step === currentEvents.length - 1 ? 'error' : 'info';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + type);
      element.setAttribute('idx', step);

      var enumeration = document.createElement('span');
      enumeration.setAttribute('class', 'checker-enum ' + type);
      enumeration.innerHTML = step + 1;

      if (currentEvents.length > 1)
        element.appendChild(enumeration);

      var prevBugEvent = step - 1;
      if (step > 0) {
        var prevBug = document.createElement('span');
        prevBug.setAttribute('class', 'arrow left-arrow');
        prevBug.addEventListener('click', function () {
          var event = currentEvents[prevBugEvent];
          that.setCurrentBugEvent(event, prevBugEvent);
        });
        element.appendChild(prevBug);
      }

      var msg = document.createElement('span');
      msg.innerHTML = that.escapeHTML(event.message)
        .replace(/(?:\r\n|\r|\n)/g, '<br>');

      element.appendChild(msg);

      var nextBugEvent = step + 1;
      if (nextBugEvent < currentEvents.length) {
        var nextBug = document.createElement('span');
        nextBug.setAttribute('class', 'arrow right-arrow');
        nextBug.addEventListener('click', function () {
          var event = currentEvents[nextBugEvent];
          that.setCurrentBugEvent(event, nextBugEvent);
        });
        element.appendChild(nextBug);
      }


      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  jumpTo : function (line, column) {
    var that = this;

    setTimeout(function () {
      var selPosPixel
        = that._codeMirror.charCoords({ line : line, ch : column }, 'local');
      var editorSize = {
        width  : that._editor.clientWidth,
        height : that._editor.clientHeight
      };

      that._codeMirror.scrollIntoView({
        top    : selPosPixel.top - 100,
        bottom : selPosPixel.top + editorSize.height - 150,
        left   : selPosPixel.left < editorSize.width - 100
               ? 0
               : selPosPixel.left - 50,
        right  : selPosPixel.left < editorSize.width - 100
               ? 10
               : selPosPixel.left + editorSize.width - 100
      });
    }, 0);
  }
}


      var data = {"files": {"0": {"id": 0, "path": "/home/vsts/work/1/llvm-project/clang/lib/CodeGen/CGObjCMac.cpp", "content": "//===------- CGObjCMac.cpp - Interface to Apple Objective-C Runtime -------===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This provides Objective-C code generation targeting the Apple runtime.\n//\n//===----------------------------------------------------------------------===//\n\n#include \"CGBlocks.h\"\n#include \"CGCleanup.h\"\n#include \"CGObjCRuntime.h\"\n#include \"CGRecordLayout.h\"\n#include \"CodeGenFunction.h\"\n#include \"CodeGenModule.h\"\n#include \"clang/AST/ASTContext.h\"\n#include \"clang/AST/Attr.h\"\n#include \"clang/AST/Decl.h\"\n#include \"clang/AST/DeclObjC.h\"\n#include \"clang/AST/Mangle.h\"\n#include \"clang/AST/RecordLayout.h\"\n#include \"clang/AST/StmtObjC.h\"\n#include \"clang/Basic/CodeGenOptions.h\"\n#include \"clang/Basic/LangOptions.h\"\n#include \"clang/CodeGen/CGFunctionInfo.h\"\n#include \"clang/CodeGen/ConstantInitBuilder.h\"\n#include \"llvm/ADT/CachedHashString.h\"\n#include \"llvm/ADT/DenseSet.h\"\n#include \"llvm/ADT/SetVector.h\"\n#include \"llvm/ADT/SmallPtrSet.h\"\n#include \"llvm/ADT/SmallString.h\"\n#include \"llvm/ADT/UniqueVector.h\"\n#include \"llvm/IR/DataLayout.h\"\n#include \"llvm/IR/InlineAsm.h\"\n#include \"llvm/IR/IntrinsicInst.h\"\n#include \"llvm/IR/LLVMContext.h\"\n#include \"llvm/IR/Module.h\"\n#include \"llvm/Support/ScopedPrinter.h\"\n#include \"llvm/Support/raw_ostream.h\"\n#include <cstdio>\n\nusing namespace clang;\nusing namespace CodeGen;\n\nnamespace {\n\n// FIXME: We should find a nicer way to make the labels for metadata, string\n// concatenation is lame.\n\nclass ObjCCommonTypesHelper {\nprotected:\n  llvm::LLVMContext &VMContext;\n\nprivate:\n  // The types of these functions don't really matter because we\n  // should always bitcast before calling them.\n\n  /// id objc_msgSend (id, SEL, ...)\n  ///\n  /// The default messenger, used for sends whose ABI is unchanged from\n  /// the all-integer/pointer case.\n  llvm::FunctionCallee getMessageSendFn() const {\n    // Add the non-lazy-bind attribute, since objc_msgSend is likely to\n    // be called a lot.\n    llvm::Type *params[] = { ObjectPtrTy, SelectorPtrTy };\n    return CGM.CreateRuntimeFunction(\n        llvm::FunctionType::get(ObjectPtrTy, params, true), \"objc_msgSend\",\n        llvm::AttributeList::get(CGM.getLLVMContext(),\n                                 llvm::AttributeList::FunctionIndex,\n                                 llvm::Attribute::NonLazyBind));\n  }\n\n  /// void objc_msgSend_stret (id, SEL, ...)\n  ///\n  /// The messenger used when the return value is an aggregate returned\n  /// by indirect reference in the first argument, and therefore the\n  /// self and selector parameters are shifted over by one.\n  llvm::FunctionCallee getMessageSendStretFn() const {\n    llvm::Type *params[] = { ObjectPtrTy, SelectorPtrTy };\n    return CGM.CreateRuntimeFunction(llvm::FunctionType::get(CGM.VoidTy,\n                                                             params, true),\n                                     \"objc_msgSend_stret\");\n  }\n\n  /// [double | long double] objc_msgSend_fpret(id self, SEL op, ...)\n  ///\n  /// The messenger used when the return value is returned on the x87\n  /// floating-point stack; without a special entrypoint, the nil case\n  /// would be unbalanced.\n  llvm::FunctionCallee getMessageSendFpretFn() const {\n    llvm::Type *params[] = { ObjectPtrTy, SelectorPtrTy };\n    return CGM.CreateRuntimeFunction(llvm::FunctionType::get(CGM.DoubleTy,\n                                                             params, true),\n                                     \"objc_msgSend_fpret\");\n  }\n\n  /// _Complex long double objc_msgSend_fp2ret(id self, SEL op, ...)\n  ///\n  /// The messenger used when the return value is returned in two values on the\n  /// x87 floating point stack; without a special entrypoint, the nil case\n  /// would be unbalanced. Only used on 64-bit X86.\n  llvm::FunctionCallee getMessageSendFp2retFn() const {\n    llvm::Type *params[] = { ObjectPtrTy, SelectorPtrTy };\n    llvm::Type *longDoubleType = llvm::Type::getX86_FP80Ty(VMContext);\n    llvm::Type *resultType =\n        llvm::StructType::get(longDoubleType, longDoubleType);\n\n    return CGM.CreateRuntimeFunction(llvm::FunctionType::get(resultType,\n                                                             params, true),\n                                     \"objc_msgSend_fp2ret\");\n  }\n\n  /// id objc_msgSendSuper(struct objc_super *super, SEL op, ...)\n  ///\n  /// The messenger used for super calls, which have different dispatch\n  /// semantics.  The class passed is the superclass of the current\n  /// class.\n  llvm::FunctionCallee getMessageSendSuperFn() const {\n    llvm::Type *params[] = { SuperPtrTy, SelectorPtrTy };\n    return CGM.CreateRuntimeFunction(llvm::FunctionType::get(ObjectPtrTy,\n                                                             params, true),\n                                     \"objc_msgSendSuper\");\n  }\n\n  /// id objc_msgSendSuper2(struct objc_super *super, SEL op, ...)\n  ///\n  /// A slightly different messenger used for super calls.  The class\n  /// passed is the current class.\n  llvm::FunctionCallee getMessageSendSuperFn2() const {\n    llvm::Type *params[] = { SuperPtrTy, SelectorPtrTy };\n    return CGM.CreateRuntimeFunction(llvm::FunctionType::get(ObjectPtrTy,\n                                                             params, true),\n                                     \"objc_msgSendSuper2\");\n  }\n\n  /// void objc_msgSendSuper_stret(void *stretAddr, struct objc_super *super,\n  ///                              SEL op, ...)\n  ///\n  /// The messenger used for super calls which return an aggregate indirectly.\n  llvm::FunctionCallee getMessageSendSuperStretFn() const {\n    llvm::Type *params[] = { Int8PtrTy, SuperPtrTy, SelectorPtrTy };\n    return CGM.CreateRuntimeFunction(\n      llvm::FunctionType::get(CGM.VoidTy, params, true),\n      \"objc_msgSendSuper_stret\");\n  }\n\n  /// void objc_msgSendSuper2_stret(void * stretAddr, struct objc_super *super,\n  ///                               SEL op, ...)\n  ///\n  /// objc_msgSendSuper_stret with the super2 semantics.\n  llvm::FunctionCallee getMessageSendSuperStretFn2() const {\n    llvm::Type *params[] = { Int8PtrTy, SuperPtrTy, SelectorPtrTy };\n    return CGM.CreateRuntimeFunction(\n      llvm::FunctionType::get(CGM.VoidTy, params, true),\n      \"objc_msgSendSuper2_stret\");\n  }\n\n  llvm::FunctionCallee getMessageSendSuperFpretFn() const {\n    // There is no objc_msgSendSuper_fpret? How can that work?\n    return getMessageSendSuperFn();\n  }\n\n  llvm::FunctionCallee getMessageSendSuperFpretFn2() const {\n    // There is no objc_msgSendSuper_fpret? How can that work?\n    return getMessageSendSuperFn2();\n  }\n\nprotected:\n  CodeGen::CodeGenModule &CGM;\n\npublic:\n  llvm::IntegerType *ShortTy, *IntTy, *LongTy;\n  llvm::PointerType *Int8PtrTy, *Int8PtrPtrTy;\n  llvm::Type *IvarOffsetVarTy;\n\n  /// ObjectPtrTy - LLVM type for object handles (typeof(id))\n  llvm::PointerType *ObjectPtrTy;\n\n  /// PtrObjectPtrTy - LLVM type for id *\n  llvm::PointerType *PtrObjectPtrTy;\n\n  /// SelectorPtrTy - LLVM type for selector handles (typeof(SEL))\n  llvm::PointerType *SelectorPtrTy;\n\nprivate:\n  /// ProtocolPtrTy - LLVM type for external protocol handles\n  /// (typeof(Protocol))\n  llvm::Type *ExternalProtocolPtrTy;\n\npublic:\n  llvm::Type *getExternalProtocolPtrTy() {\n    if (!ExternalProtocolPtrTy) {\n      // FIXME: It would be nice to unify this with the opaque type, so that the\n      // IR comes out a bit cleaner.\n      CodeGen::CodeGenTypes &Types = CGM.getTypes();\n      ASTContext &Ctx = CGM.getContext();\n      llvm::Type *T = Types.ConvertType(Ctx.getObjCProtoType());\n      ExternalProtocolPtrTy = llvm::PointerType::getUnqual(T);\n    }\n\n    return ExternalProtocolPtrTy;\n  }\n\n  // SuperCTy - clang type for struct objc_super.\n  QualType SuperCTy;\n  // SuperPtrCTy - clang type for struct objc_super *.\n  QualType SuperPtrCTy;\n\n  /// SuperTy - LLVM type for struct objc_super.\n  llvm::StructType *SuperTy;\n  /// SuperPtrTy - LLVM type for struct objc_super *.\n  llvm::PointerType *SuperPtrTy;\n\n  /// PropertyTy - LLVM type for struct objc_property (struct _prop_t\n  /// in GCC parlance).\n  llvm::StructType *PropertyTy;\n\n  /// PropertyListTy - LLVM type for struct objc_property_list\n  /// (_prop_list_t in GCC parlance).\n  llvm::StructType *PropertyListTy;\n  /// PropertyListPtrTy - LLVM type for struct objc_property_list*.\n  llvm::PointerType *PropertyListPtrTy;\n\n  // MethodTy - LLVM type for struct objc_method.\n  llvm::StructType *MethodTy;\n\n  /// CacheTy - LLVM type for struct objc_cache.\n  llvm::Type *CacheTy;\n  /// CachePtrTy - LLVM type for struct objc_cache *.\n  llvm::PointerType *CachePtrTy;\n\n  llvm::FunctionCallee getGetPropertyFn() {\n    CodeGen::CodeGenTypes &Types = CGM.getTypes();\n    ASTContext &Ctx = CGM.getContext();\n    // id objc_getProperty (id, SEL, ptrdiff_t, bool)\n    CanQualType IdType = Ctx.getCanonicalParamType(Ctx.getObjCIdType());\n    CanQualType SelType = Ctx.getCanonicalParamType(Ctx.getObjCSelType());\n    CanQualType Params[] = {\n        IdType, SelType,\n        Ctx.getPointerDiffType()->getCanonicalTypeUnqualified(), Ctx.BoolTy};\n    llvm::FunctionType *FTy =\n        Types.GetFunctionType(\n          Types.arrangeBuiltinFunctionDeclaration(IdType, Params));\n    return CGM.CreateRuntimeFunction(FTy, \"objc_getProperty\");\n  }\n\n  llvm::FunctionCallee getSetPropertyFn() {\n    CodeGen::CodeGenTypes &Types = CGM.getTypes();\n    ASTContext &Ctx = CGM.getContext();\n    // void objc_setProperty (id, SEL, ptrdiff_t, id, bool, bool)\n    CanQualType IdType = Ctx.getCanonicalParamType(Ctx.getObjCIdType());\n    CanQualType SelType = Ctx.getCanonicalParamType(Ctx.getObjCSelType());\n    CanQualType Params[] = {\n        IdType,\n        SelType,\n        Ctx.getPointerDiffType()->getCanonicalTypeUnqualified(),\n        IdType,\n        Ctx.BoolTy,\n        Ctx.BoolTy};\n    llvm::FunctionType *FTy =\n        Types.GetFunctionType(\n          Types.arrangeBuiltinFunctionDeclaration(Ctx.VoidTy, Params));\n    return CGM.CreateRuntimeFunction(FTy, \"objc_setProperty\");\n  }\n\n  llvm::FunctionCallee getOptimizedSetPropertyFn(bool atomic, bool copy) {\n    CodeGen::CodeGenTypes &Types = CGM.getTypes();\n    ASTContext &Ctx = CGM.getContext();\n    // void objc_setProperty_atomic(id self, SEL _cmd,\n    //                              id newValue, ptrdiff_t offset);\n    // void objc_setProperty_nonatomic(id self, SEL _cmd,\n    //                                 id newValue, ptrdiff_t offset);\n    // void objc_setProperty_atomic_copy(id self, SEL _cmd,\n    //                                   id newValue, ptrdiff_t offset);\n    // void objc_setProperty_nonatomic_copy(id self, SEL _cmd,\n    //                                      id newValue, ptrdiff_t offset);\n\n    SmallVector<CanQualType,4> Params;\n    CanQualType IdType = Ctx.getCanonicalParamType(Ctx.getObjCIdType());\n    CanQualType SelType = Ctx.getCanonicalParamType(Ctx.getObjCSelType());\n    Params.push_back(IdType);\n    Params.push_back(SelType);\n    Params.push_back(IdType);\n    Params.push_back(Ctx.getPointerDiffType()->getCanonicalTypeUnqualified());\n    llvm::FunctionType *FTy =\n        Types.GetFunctionType(\n          Types.arrangeBuiltinFunctionDeclaration(Ctx.VoidTy, Params));\n    const char *name;\n    if (atomic && copy)\n      name = \"objc_setProperty_atomic_copy\";\n    else if (atomic && !copy)\n      name = \"objc_setProperty_atomic\";\n    else if (!atomic && copy)\n      name = \"objc_setProperty_nonatomic_copy\";\n    else\n      name = \"objc_setProperty_nonatomic\";\n\n    return CGM.CreateRuntimeFunction(FTy, name);\n  }\n\n  llvm::FunctionCallee getCopyStructFn() {\n    CodeGen::CodeGenTypes &Types = CGM.getTypes();\n    ASTContext &Ctx = CGM.getContext();\n    // void objc_copyStruct (void *, const void *, size_t, bool, bool)\n    SmallVector<CanQualType,5> Params;\n    Params.push_back(Ctx.VoidPtrTy);\n    Params.push_back(Ctx.VoidPtrTy);\n    Params.push_back(Ctx.getSizeType());\n    Params.push_back(Ctx.BoolTy);\n    Params.push_back(Ctx.BoolTy);\n    llvm::FunctionType *FTy =\n        Types.GetFunctionType(\n          Types.arrangeBuiltinFunctionDeclaration(Ctx.VoidTy, Params));\n    return CGM.CreateRuntimeFunction(FTy, \"objc_copyStruct\");\n  }\n\n  /// This routine declares and returns address of:\n  /// void objc_copyCppObjectAtomic(\n  ///         void *dest, const void *src,\n  ///         void (*copyHelper) (void *dest, const void *source));\n  llvm::FunctionCallee getCppAtomicObjectFunction() {\n    CodeGen::CodeGenTypes &Types = CGM.getTypes();\n    ASTContext &Ctx = CGM.getContext();\n    /// void objc_copyCppObjectAtomic(void *dest, const void *src, void *helper);\n    SmallVector<CanQualType,3> Params;\n    Params.push_back(Ctx.VoidPtrTy);\n    Params.push_back(Ctx.VoidPtrTy);\n    Params.push_back(Ctx.VoidPtrTy);\n    llvm::FunctionType *FTy =\n        Types.GetFunctionType(\n          Types.arrangeBuiltinFunctionDeclaration(Ctx.VoidTy, Params));\n    return CGM.CreateRuntimeFunction(FTy, \"objc_copyCppObjectAtomic\");\n  }\n\n  llvm::FunctionCallee getEnumerationMutationFn() {\n    CodeGen::CodeGenTypes &Types = CGM.getTypes();\n    ASTContext &Ctx = CGM.getContext();\n    // void objc_enumerationMutation (id)\n    SmallVector<CanQualType,1> Params;\n    Params.push_back(Ctx.getCanonicalParamType(Ctx.getObjCIdType()));\n    llvm::FunctionType *FTy =\n        Types.GetFunctionType(\n          Types.arrangeBuiltinFunctionDeclaration(Ctx.VoidTy, Params));\n    return CGM.CreateRuntimeFunction(FTy, \"objc_enumerationMutation\");\n  }\n\n  llvm::FunctionCallee getLookUpClassFn() {\n    CodeGen::CodeGenTypes &Types = CGM.getTypes();\n    ASTContext &Ctx = CGM.getContext();\n    // Class objc_lookUpClass (const char *)\n    SmallVector<CanQualType,1> Params;\n    Params.push_back(\n      Ctx.getCanonicalType(Ctx.getPointerType(Ctx.CharTy.withConst())));\n    llvm::FunctionType *FTy =\n        Types.GetFunctionType(Types.arrangeBuiltinFunctionDeclaration(\n                                Ctx.getCanonicalType(Ctx.getObjCClassType()),\n                                Params));\n    return CGM.CreateRuntimeFunction(FTy, \"objc_lookUpClass\");\n  }\n\n  /// GcReadWeakFn -- LLVM objc_read_weak (id *src) function.\n  llvm::FunctionCallee getGcReadWeakFn() {\n    // id objc_read_weak (id *)\n    llvm::Type *args[] = { ObjectPtrTy->getPointerTo() };\n    llvm::FunctionType *FTy =\n      llvm::FunctionType::get(ObjectPtrTy, args, false);\n    return CGM.CreateRuntimeFunction(FTy, \"objc_read_weak\");\n  }\n\n  /// GcAssignWeakFn -- LLVM objc_assign_weak function.\n  llvm::FunctionCallee getGcAssignWeakFn() {\n    // id objc_assign_weak (id, id *)\n    llvm::Type *args[] = { ObjectPtrTy, ObjectPtrTy->getPointerTo() };\n    llvm::FunctionType *FTy =\n      llvm::FunctionType::get(ObjectPtrTy, args, false);\n    return CGM.CreateRuntimeFunction(FTy, \"objc_assign_weak\");\n  }\n\n  /// GcAssignGlobalFn -- LLVM objc_assign_global function.\n  llvm::FunctionCallee getGcAssignGlobalFn() {\n    // id objc_assign_global(id, id *)\n    llvm::Type *args[] = { ObjectPtrTy, ObjectPtrTy->getPointerTo() };\n    llvm::FunctionType *FTy =\n      llvm::FunctionType::get(ObjectPtrTy, args, false);\n    return CGM.CreateRuntimeFunction(FTy, \"objc_assign_global\");\n  }\n\n  /// GcAssignThreadLocalFn -- LLVM objc_assign_threadlocal function.\n  llvm::FunctionCallee getGcAssignThreadLocalFn() {\n    // id objc_assign_threadlocal(id src, id * dest)\n    llvm::Type *args[] = { ObjectPtrTy, ObjectPtrTy->getPointerTo() };\n    llvm::FunctionType *FTy =\n      llvm::FunctionType::get(ObjectPtrTy, args, false);\n    return CGM.CreateRuntimeFunction(FTy, \"objc_assign_threadlocal\");\n  }\n\n  /// GcAssignIvarFn -- LLVM objc_assign_ivar function.\n  llvm::FunctionCallee getGcAssignIvarFn() {\n    // id objc_assign_ivar(id, id *, ptrdiff_t)\n    llvm::Type *args[] = { ObjectPtrTy, ObjectPtrTy->getPointerTo(),\n                           CGM.PtrDiffTy };\n    llvm::FunctionType *FTy =\n      llvm::FunctionType::get(ObjectPtrTy, args, false);\n    return CGM.CreateRuntimeFunction(FTy, \"objc_assign_ivar\");\n  }\n\n  /// GcMemmoveCollectableFn -- LLVM objc_memmove_collectable function.\n  llvm::FunctionCallee GcMemmoveCollectableFn() {\n    // void *objc_memmove_collectable(void *dst, const void *src, size_t size)\n    llvm::Type *args[] = { Int8PtrTy, Int8PtrTy, LongTy };\n    llvm::FunctionType *FTy = llvm::FunctionType::get(Int8PtrTy, args, false);\n    return CGM.CreateRuntimeFunction(FTy, \"objc_memmove_collectable\");\n  }\n\n  /// GcAssignStrongCastFn -- LLVM objc_assign_strongCast function.\n  llvm::FunctionCallee getGcAssignStrongCastFn() {\n    // id objc_assign_strongCast(id, id *)\n    llvm::Type *args[] = { ObjectPtrTy, ObjectPtrTy->getPointerTo() };\n    llvm::FunctionType *FTy =\n      llvm::FunctionType::get(ObjectPtrTy, args, false);\n    return CGM.CreateRuntimeFunction(FTy, \"objc_assign_strongCast\");\n  }\n\n  /// ExceptionThrowFn - LLVM objc_exception_throw function.\n  llvm::FunctionCallee getExceptionThrowFn() {\n    // void objc_exception_throw(id)\n    llvm::Type *args[] = { ObjectPtrTy };\n    llvm::FunctionType *FTy =\n      llvm::FunctionType::get(CGM.VoidTy, args, false);\n    return CGM.CreateRuntimeFunction(FTy, \"objc_exception_throw\");\n  }\n\n  /// ExceptionRethrowFn - LLVM objc_exception_rethrow function.\n  llvm::FunctionCallee getExceptionRethrowFn() {\n    // void objc_exception_rethrow(void)\n    llvm::FunctionType *FTy = llvm::FunctionType::get(CGM.VoidTy, false);\n    return CGM.CreateRuntimeFunction(FTy, \"objc_exception_rethrow\");\n  }\n\n  /// SyncEnterFn - LLVM object_sync_enter function.\n  llvm::FunctionCallee getSyncEnterFn() {\n    // int objc_sync_enter (id)\n    llvm::Type *args[] = { ObjectPtrTy };\n    llvm::FunctionType *FTy =\n      llvm::FunctionType::get(CGM.IntTy, args, false);\n    return CGM.CreateRuntimeFunction(FTy, \"objc_sync_enter\");\n  }\n\n  /// SyncExitFn - LLVM object_sync_exit function.\n  llvm::FunctionCallee getSyncExitFn() {\n    // int objc_sync_exit (id)\n    llvm::Type *args[] = { ObjectPtrTy };\n    llvm::FunctionType *FTy =\n      llvm::FunctionType::get(CGM.IntTy, args, false);\n    return CGM.CreateRuntimeFunction(FTy, \"objc_sync_exit\");\n  }\n\n  llvm::FunctionCallee getSendFn(bool IsSuper) const {\n    return IsSuper ? getMessageSendSuperFn() : getMessageSendFn();\n  }\n\n  llvm::FunctionCallee getSendFn2(bool IsSuper) const {\n    return IsSuper ? getMessageSendSuperFn2() : getMessageSendFn();\n  }\n\n  llvm::FunctionCallee getSendStretFn(bool IsSuper) const {\n    return IsSuper ? getMessageSendSuperStretFn() : getMessageSendStretFn();\n  }\n\n  llvm::FunctionCallee getSendStretFn2(bool IsSuper) const {\n    return IsSuper ? getMessageSendSuperStretFn2() : getMessageSendStretFn();\n  }\n\n  llvm::FunctionCallee getSendFpretFn(bool IsSuper) const {\n    return IsSuper ? getMessageSendSuperFpretFn() : getMessageSendFpretFn();\n  }\n\n  llvm::FunctionCallee getSendFpretFn2(bool IsSuper) const {\n    return IsSuper ? getMessageSendSuperFpretFn2() : getMessageSendFpretFn();\n  }\n\n  llvm::FunctionCallee getSendFp2retFn(bool IsSuper) const {\n    return IsSuper ? getMessageSendSuperFn() : getMessageSendFp2retFn();\n  }\n\n  llvm::FunctionCallee getSendFp2RetFn2(bool IsSuper) const {\n    return IsSuper ? getMessageSendSuperFn2() : getMessageSendFp2retFn();\n  }\n\n  ObjCCommonTypesHelper(CodeGen::CodeGenModule &cgm);\n};\n\n/// ObjCTypesHelper - Helper class that encapsulates lazy\n/// construction of varies types used during ObjC generation.\nclass ObjCTypesHelper : public ObjCCommonTypesHelper {\npublic:\n  /// SymtabTy - LLVM type for struct objc_symtab.\n  llvm::StructType *SymtabTy;\n  /// SymtabPtrTy - LLVM type for struct objc_symtab *.\n  llvm::PointerType *SymtabPtrTy;\n  /// ModuleTy - LLVM type for struct objc_module.\n  llvm::StructType *ModuleTy;\n\n  /// ProtocolTy - LLVM type for struct objc_protocol.\n  llvm::StructType *ProtocolTy;\n  /// ProtocolPtrTy - LLVM type for struct objc_protocol *.\n  llvm::PointerType *ProtocolPtrTy;\n  /// ProtocolExtensionTy - LLVM type for struct\n  /// objc_protocol_extension.\n  llvm::StructType *ProtocolExtensionTy;\n  /// ProtocolExtensionTy - LLVM type for struct\n  /// objc_protocol_extension *.\n  llvm::PointerType *ProtocolExtensionPtrTy;\n  /// MethodDescriptionTy - LLVM type for struct\n  /// objc_method_description.\n  llvm::StructType *MethodDescriptionTy;\n  /// MethodDescriptionListTy - LLVM type for struct\n  /// objc_method_description_list.\n  llvm::StructType *MethodDescriptionListTy;\n  /// MethodDescriptionListPtrTy - LLVM type for struct\n  /// objc_method_description_list *.\n  llvm::PointerType *MethodDescriptionListPtrTy;\n  /// ProtocolListTy - LLVM type for struct objc_property_list.\n  llvm::StructType *ProtocolListTy;\n  /// ProtocolListPtrTy - LLVM type for struct objc_property_list*.\n  llvm::PointerType *ProtocolListPtrTy;\n  /// CategoryTy - LLVM type for struct objc_category.\n  llvm::StructType *CategoryTy;\n  /// ClassTy - LLVM type for struct objc_class.\n  llvm::StructType *ClassTy;\n  /// ClassPtrTy - LLVM type for struct objc_class *.\n  llvm::PointerType *ClassPtrTy;\n  /// ClassExtensionTy - LLVM type for struct objc_class_ext.\n  llvm::StructType *ClassExtensionTy;\n  /// ClassExtensionPtrTy - LLVM type for struct objc_class_ext *.\n  llvm::PointerType *ClassExtensionPtrTy;\n  // IvarTy - LLVM type for struct objc_ivar.\n  llvm::StructType *IvarTy;\n  /// IvarListTy - LLVM type for struct objc_ivar_list.\n  llvm::StructType *IvarListTy;\n  /// IvarListPtrTy - LLVM type for struct objc_ivar_list *.\n  llvm::PointerType *IvarListPtrTy;\n  /// MethodListTy - LLVM type for struct objc_method_list.\n  llvm::StructType *MethodListTy;\n  /// MethodListPtrTy - LLVM type for struct objc_method_list *.\n  llvm::PointerType *MethodListPtrTy;\n\n  /// ExceptionDataTy - LLVM type for struct _objc_exception_data.\n  llvm::StructType *ExceptionDataTy;\n\n  /// ExceptionTryEnterFn - LLVM objc_exception_try_enter function.\n  llvm::FunctionCallee getExceptionTryEnterFn() {\n    llvm::Type *params[] = { ExceptionDataTy->getPointerTo() };\n    return CGM.CreateRuntimeFunction(\n      llvm::FunctionType::get(CGM.VoidTy, params, false),\n      \"objc_exception_try_enter\");\n  }\n\n  /// ExceptionTryExitFn - LLVM objc_exception_try_exit function.\n  llvm::FunctionCallee getExceptionTryExitFn() {\n    llvm::Type *params[] = { ExceptionDataTy->getPointerTo() };\n    return CGM.CreateRuntimeFunction(\n      llvm::FunctionType::get(CGM.VoidTy, params, false),\n      \"objc_exception_try_exit\");\n  }\n\n  /// ExceptionExtractFn - LLVM objc_exception_extract function.\n  llvm::FunctionCallee getExceptionExtractFn() {\n    llvm::Type *params[] = { ExceptionDataTy->getPointerTo() };\n    return CGM.CreateRuntimeFunction(llvm::FunctionType::get(ObjectPtrTy,\n                                                             params, false),\n                                     \"objc_exception_extract\");\n  }\n\n  /// ExceptionMatchFn - LLVM objc_exception_match function.\n  llvm::FunctionCallee getExceptionMatchFn() {\n    llvm::Type *params[] = { ClassPtrTy, ObjectPtrTy };\n    return CGM.CreateRuntimeFunction(\n      llvm::FunctionType::get(CGM.Int32Ty, params, false),\n      \"objc_exception_match\");\n  }\n\n  /// SetJmpFn - LLVM _setjmp function.\n  llvm::FunctionCallee getSetJmpFn() {\n    // This is specifically the prototype for x86.\n    llvm::Type *params[] = { CGM.Int32Ty->getPointerTo() };\n    return CGM.CreateRuntimeFunction(\n        llvm::FunctionType::get(CGM.Int32Ty, params, false), \"_setjmp\",\n        llvm::AttributeList::get(CGM.getLLVMContext(),\n                                 llvm::AttributeList::FunctionIndex,\n                                 llvm::Attribute::NonLazyBind));\n  }\n\npublic:\n  ObjCTypesHelper(CodeGen::CodeGenModule &cgm);\n};\n\n/// ObjCNonFragileABITypesHelper - will have all types needed by objective-c's\n/// modern abi\nclass ObjCNonFragileABITypesHelper : public ObjCCommonTypesHelper {\npublic:\n  // MethodListnfABITy - LLVM for struct _method_list_t\n  llvm::StructType *MethodListnfABITy;\n\n  // MethodListnfABIPtrTy - LLVM for struct _method_list_t*\n  llvm::PointerType *MethodListnfABIPtrTy;\n\n  // ProtocolnfABITy = LLVM for struct _protocol_t\n  llvm::StructType *ProtocolnfABITy;\n\n  // ProtocolnfABIPtrTy = LLVM for struct _protocol_t*\n  llvm::PointerType *ProtocolnfABIPtrTy;\n\n  // ProtocolListnfABITy - LLVM for struct _objc_protocol_list\n  llvm::StructType *ProtocolListnfABITy;\n\n  // ProtocolListnfABIPtrTy - LLVM for struct _objc_protocol_list*\n  llvm::PointerType *ProtocolListnfABIPtrTy;\n\n  // ClassnfABITy - LLVM for struct _class_t\n  llvm::StructType *ClassnfABITy;\n\n  // ClassnfABIPtrTy - LLVM for struct _class_t*\n  llvm::PointerType *ClassnfABIPtrTy;\n\n  // IvarnfABITy - LLVM for struct _ivar_t\n  llvm::StructType *IvarnfABITy;\n\n  // IvarListnfABITy - LLVM for struct _ivar_list_t\n  llvm::StructType *IvarListnfABITy;\n\n  // IvarListnfABIPtrTy = LLVM for struct _ivar_list_t*\n  llvm::PointerType *IvarListnfABIPtrTy;\n\n  // ClassRonfABITy - LLVM for struct _class_ro_t\n  llvm::StructType *ClassRonfABITy;\n\n  // ImpnfABITy - LLVM for id (*)(id, SEL, ...)\n  llvm::PointerType *ImpnfABITy;\n\n  // CategorynfABITy - LLVM for struct _category_t\n  llvm::StructType *CategorynfABITy;\n\n  // New types for nonfragile abi messaging.\n\n  // MessageRefTy - LLVM for:\n  // struct _message_ref_t {\n  //   IMP messenger;\n  //   SEL name;\n  // };\n  llvm::StructType *MessageRefTy;\n  // MessageRefCTy - clang type for struct _message_ref_t\n  QualType MessageRefCTy;\n\n  // MessageRefPtrTy - LLVM for struct _message_ref_t*\n  llvm::Type *MessageRefPtrTy;\n  // MessageRefCPtrTy - clang type for struct _message_ref_t*\n  QualType MessageRefCPtrTy;\n\n  // SuperMessageRefTy - LLVM for:\n  // struct _super_message_ref_t {\n  //   SUPER_IMP messenger;\n  //   SEL name;\n  // };\n  llvm::StructType *SuperMessageRefTy;\n\n  // SuperMessageRefPtrTy - LLVM for struct _super_message_ref_t*\n  llvm::PointerType *SuperMessageRefPtrTy;\n\n  llvm::FunctionCallee getMessageSendFixupFn() {\n    // id objc_msgSend_fixup(id, struct message_ref_t*, ...)\n    llvm::Type *params[] = { ObjectPtrTy, MessageRefPtrTy };\n    return CGM.CreateRuntimeFunction(llvm::FunctionType::get(ObjectPtrTy,\n                                                             params, true),\n                                     \"objc_msgSend_fixup\");\n  }\n\n  llvm::FunctionCallee getMessageSendFpretFixupFn() {\n    // id objc_msgSend_fpret_fixup(id, struct message_ref_t*, ...)\n    llvm::Type *params[] = { ObjectPtrTy, MessageRefPtrTy };\n    return CGM.CreateRuntimeFunction(llvm::FunctionType::get(ObjectPtrTy,\n                                                             params, true),\n                                     \"objc_msgSend_fpret_fixup\");\n  }\n\n  llvm::FunctionCallee getMessageSendStretFixupFn() {\n    // id objc_msgSend_stret_fixup(id, struct message_ref_t*, ...)\n    llvm::Type *params[] = { ObjectPtrTy, MessageRefPtrTy };\n    return CGM.CreateRuntimeFunction(llvm::FunctionType::get(ObjectPtrTy,\n                                                             params, true),\n                                     \"objc_msgSend_stret_fixup\");\n  }\n\n  llvm::FunctionCallee getMessageSendSuper2FixupFn() {\n    // id objc_msgSendSuper2_fixup (struct objc_super *,\n    //                              struct _super_message_ref_t*, ...)\n    llvm::Type *params[] = { SuperPtrTy, SuperMessageRefPtrTy };\n    return  CGM.CreateRuntimeFunction(llvm::FunctionType::get(ObjectPtrTy,\n                                                              params, true),\n                                      \"objc_msgSendSuper2_fixup\");\n  }\n\n  llvm::FunctionCallee getMessageSendSuper2StretFixupFn() {\n    // id objc_msgSendSuper2_stret_fixup(struct objc_super *,\n    //                                   struct _super_message_ref_t*, ...)\n    llvm::Type *params[] = { SuperPtrTy, SuperMessageRefPtrTy };\n    return  CGM.CreateRuntimeFunction(llvm::FunctionType::get(ObjectPtrTy,\n                                                              params, true),\n                                      \"objc_msgSendSuper2_stret_fixup\");\n  }\n\n  llvm::FunctionCallee getObjCEndCatchFn() {\n    return CGM.CreateRuntimeFunction(llvm::FunctionType::get(CGM.VoidTy, false),\n                                     \"objc_end_catch\");\n  }\n\n  llvm::FunctionCallee getObjCBeginCatchFn() {\n    llvm::Type *params[] = { Int8PtrTy };\n    return CGM.CreateRuntimeFunction(llvm::FunctionType::get(Int8PtrTy,\n                                                             params, false),\n                                     \"objc_begin_catch\");\n  }\n\n  /// Class objc_loadClassref (void *)\n  ///\n  /// Loads from a classref. For Objective-C stub classes, this invokes the\n  /// initialization callback stored inside the stub. For all other classes\n  /// this simply dereferences the pointer.\n  llvm::FunctionCallee getLoadClassrefFn() const {\n    // Add the non-lazy-bind attribute, since objc_loadClassref is likely to\n    // be called a lot.\n    //\n    // Also it is safe to make it readnone, since we never load or store the\n    // classref except by calling this function.\n    llvm::Type *params[] = { Int8PtrPtrTy };\n    llvm::FunctionCallee F = CGM.CreateRuntimeFunction(\n        llvm::FunctionType::get(ClassnfABIPtrTy, params, false),\n        \"objc_loadClassref\",\n        llvm::AttributeList::get(CGM.getLLVMContext(),\n                                 llvm::AttributeList::FunctionIndex,\n                                 {llvm::Attribute::NonLazyBind,\n                                  llvm::Attribute::ReadNone,\n                                  llvm::Attribute::NoUnwind}));\n    if (!CGM.getTriple().isOSBinFormatCOFF())\n      cast<llvm::Function>(F.getCallee())->setLinkage(\n        llvm::Function::ExternalWeakLinkage);\n\n    return F;\n  }\n\n  llvm::StructType *EHTypeTy;\n  llvm::Type *EHTypePtrTy;\n\n  ObjCNonFragileABITypesHelper(CodeGen::CodeGenModule &cgm);\n};\n\nenum class ObjCLabelType {\n  ClassName,\n  MethodVarName,\n  MethodVarType,\n  PropertyName,\n};\n\nclass CGObjCCommonMac : public CodeGen::CGObjCRuntime {\npublic:\n  class SKIP_SCAN {\n  public:\n    unsigned skip;\n    unsigned scan;\n    SKIP_SCAN(unsigned _skip = 0, unsigned _scan = 0)\n      : skip(_skip), scan(_scan) {}\n  };\n\n  /// opcode for captured block variables layout 'instructions'.\n  /// In the following descriptions, 'I' is the value of the immediate field.\n  /// (field following the opcode).\n  ///\n  enum BLOCK_LAYOUT_OPCODE {\n    /// An operator which affects how the following layout should be\n    /// interpreted.\n    ///   I == 0: Halt interpretation and treat everything else as\n    ///           a non-pointer.  Note that this instruction is equal\n    ///           to '\\0'.\n    ///   I != 0: Currently unused.\n    BLOCK_LAYOUT_OPERATOR            = 0,\n\n    /// The next I+1 bytes do not contain a value of object pointer type.\n    /// Note that this can leave the stream unaligned, meaning that\n    /// subsequent word-size instructions do not begin at a multiple of\n    /// the pointer size.\n    BLOCK_LAYOUT_NON_OBJECT_BYTES    = 1,\n\n    /// The next I+1 words do not contain a value of object pointer type.\n    /// This is simply an optimized version of BLOCK_LAYOUT_BYTES for\n    /// when the required skip quantity is a multiple of the pointer size.\n    BLOCK_LAYOUT_NON_OBJECT_WORDS    = 2,\n\n    /// The next I+1 words are __strong pointers to Objective-C\n    /// objects or blocks.\n    BLOCK_LAYOUT_STRONG              = 3,\n\n    /// The next I+1 words are pointers to __block variables.\n    BLOCK_LAYOUT_BYREF               = 4,\n\n    /// The next I+1 words are __weak pointers to Objective-C\n    /// objects or blocks.\n    BLOCK_LAYOUT_WEAK                = 5,\n\n    /// The next I+1 words are __unsafe_unretained pointers to\n    /// Objective-C objects or blocks.\n    BLOCK_LAYOUT_UNRETAINED          = 6\n\n    /// The next I+1 words are block or object pointers with some\n    /// as-yet-unspecified ownership semantics.  If we add more\n    /// flavors of ownership semantics, values will be taken from\n    /// this range.\n    ///\n    /// This is included so that older tools can at least continue\n    /// processing the layout past such things.\n    //BLOCK_LAYOUT_OWNERSHIP_UNKNOWN = 7..10,\n\n    /// All other opcodes are reserved.  Halt interpretation and\n    /// treat everything else as opaque.\n  };\n\n  class RUN_SKIP {\n  public:\n    enum BLOCK_LAYOUT_OPCODE opcode;\n    CharUnits block_var_bytepos;\n    CharUnits block_var_size;\n    RUN_SKIP(enum BLOCK_LAYOUT_OPCODE Opcode = BLOCK_LAYOUT_OPERATOR,\n             CharUnits BytePos = CharUnits::Zero(),\n             CharUnits Size = CharUnits::Zero())\n    : opcode(Opcode), block_var_bytepos(BytePos),  block_var_size(Size) {}\n\n    // Allow sorting based on byte pos.\n    bool operator<(const RUN_SKIP &b) const {\n      return block_var_bytepos < b.block_var_bytepos;\n    }\n  };\n\nprotected:\n  llvm::LLVMContext &VMContext;\n  // FIXME! May not be needing this after all.\n  unsigned ObjCABI;\n\n  // arc/mrr layout of captured block literal variables.\n  SmallVector<RUN_SKIP, 16> RunSkipBlockVars;\n\n  /// LazySymbols - Symbols to generate a lazy reference for. See\n  /// DefinedSymbols and FinishModule().\n  llvm::SetVector<IdentifierInfo*> LazySymbols;\n\n  /// DefinedSymbols - External symbols which are defined by this\n  /// module. The symbols in this list and LazySymbols are used to add\n  /// special linker symbols which ensure that Objective-C modules are\n  /// linked properly.\n  llvm::SetVector<IdentifierInfo*> DefinedSymbols;\n\n  /// ClassNames - uniqued class names.\n  llvm::StringMap<llvm::GlobalVariable*> ClassNames;\n\n  /// MethodVarNames - uniqued method variable names.\n  llvm::DenseMap<Selector, llvm::GlobalVariable*> MethodVarNames;\n\n  /// DefinedCategoryNames - list of category names in form Class_Category.\n  llvm::SmallSetVector<llvm::CachedHashString, 16> DefinedCategoryNames;\n\n  /// MethodVarTypes - uniqued method type signatures. We have to use\n  /// a StringMap here because have no other unique reference.\n  llvm::StringMap<llvm::GlobalVariable*> MethodVarTypes;\n\n  /// MethodDefinitions - map of methods which have been defined in\n  /// this translation unit.\n  llvm::DenseMap<const ObjCMethodDecl*, llvm::Function*> MethodDefinitions;\n\n  /// DirectMethodDefinitions - map of direct methods which have been defined in\n  /// this translation unit.\n  llvm::DenseMap<const ObjCMethodDecl*, llvm::Function*> DirectMethodDefinitions;\n\n  /// PropertyNames - uniqued method variable names.\n  llvm::DenseMap<IdentifierInfo*, llvm::GlobalVariable*> PropertyNames;\n\n  /// ClassReferences - uniqued class references.\n  llvm::DenseMap<IdentifierInfo*, llvm::GlobalVariable*> ClassReferences;\n\n  /// SelectorReferences - uniqued selector references.\n  llvm::DenseMap<Selector, llvm::GlobalVariable*> SelectorReferences;\n\n  /// Protocols - Protocols for which an objc_protocol structure has\n  /// been emitted. Forward declarations are handled by creating an\n  /// empty structure whose initializer is filled in when/if defined.\n  llvm::DenseMap<IdentifierInfo*, llvm::GlobalVariable*> Protocols;\n\n  /// DefinedProtocols - Protocols which have actually been\n  /// defined. We should not need this, see FIXME in GenerateProtocol.\n  llvm::DenseSet<IdentifierInfo*> DefinedProtocols;\n\n  /// DefinedClasses - List of defined classes.\n  SmallVector<llvm::GlobalValue*, 16> DefinedClasses;\n\n  /// ImplementedClasses - List of @implemented classes.\n  SmallVector<const ObjCInterfaceDecl*, 16> ImplementedClasses;\n\n  /// DefinedNonLazyClasses - List of defined \"non-lazy\" classes.\n  SmallVector<llvm::GlobalValue*, 16> DefinedNonLazyClasses;\n\n  /// DefinedCategories - List of defined categories.\n  SmallVector<llvm::GlobalValue*, 16> DefinedCategories;\n\n  /// DefinedStubCategories - List of defined categories on class stubs.\n  SmallVector<llvm::GlobalValue*, 16> DefinedStubCategories;\n\n  /// DefinedNonLazyCategories - List of defined \"non-lazy\" categories.\n  SmallVector<llvm::GlobalValue*, 16> DefinedNonLazyCategories;\n\n  /// Cached reference to the class for constant strings. This value has type\n  /// int * but is actually an Obj-C class pointer.\n  llvm::WeakTrackingVH ConstantStringClassRef;\n\n  /// The LLVM type corresponding to NSConstantString.\n  llvm::StructType *NSConstantStringType = nullptr;\n\n  llvm::StringMap<llvm::GlobalVariable *> NSConstantStringMap;\n\n  /// GetMethodVarName - Return a unique constant for the given\n  /// selector's name. The return value has type char *.\n  llvm::Constant *GetMethodVarName(Selector Sel);\n  llvm::Constant *GetMethodVarName(IdentifierInfo *Ident);\n\n  /// GetMethodVarType - Return a unique constant for the given\n  /// method's type encoding string. The return value has type char *.\n\n  // FIXME: This is a horrible name.\n  llvm::Constant *GetMethodVarType(const ObjCMethodDecl *D,\n                                   bool Extended = false);\n  llvm::Constant *GetMethodVarType(const FieldDecl *D);\n\n  /// GetPropertyName - Return a unique constant for the given\n  /// name. The return value has type char *.\n  llvm::Constant *GetPropertyName(IdentifierInfo *Ident);\n\n  // FIXME: This can be dropped once string functions are unified.\n  llvm::Constant *GetPropertyTypeString(const ObjCPropertyDecl *PD,\n                                        const Decl *Container);\n\n  /// GetClassName - Return a unique constant for the given selector's\n  /// runtime name (which may change via use of objc_runtime_name attribute on\n  /// class or protocol definition. The return value has type char *.\n  llvm::Constant *GetClassName(StringRef RuntimeName);\n\n  llvm::Function *GetMethodDefinition(const ObjCMethodDecl *MD);\n\n  /// BuildIvarLayout - Builds ivar layout bitmap for the class\n  /// implementation for the __strong or __weak case.\n  ///\n  /// \\param hasMRCWeakIvars - Whether we are compiling in MRC and there\n  ///   are any weak ivars defined directly in the class.  Meaningless unless\n  ///   building a weak layout.  Does not guarantee that the layout will\n  ///   actually have any entries, because the ivar might be under-aligned.\n  llvm::Constant *BuildIvarLayout(const ObjCImplementationDecl *OI,\n                                  CharUnits beginOffset,\n                                  CharUnits endOffset,\n                                  bool forStrongLayout,\n                                  bool hasMRCWeakIvars);\n\n  llvm::Constant *BuildStrongIvarLayout(const ObjCImplementationDecl *OI,\n                                        CharUnits beginOffset,\n                                        CharUnits endOffset) {\n    return BuildIvarLayout(OI, beginOffset, endOffset, true, false);\n  }\n\n  llvm::Constant *BuildWeakIvarLayout(const ObjCImplementationDecl *OI,\n                                      CharUnits beginOffset,\n                                      CharUnits endOffset,\n                                      bool hasMRCWeakIvars) {\n    return BuildIvarLayout(OI, beginOffset, endOffset, false, hasMRCWeakIvars);\n  }\n\n  Qualifiers::ObjCLifetime getBlockCaptureLifetime(QualType QT, bool ByrefLayout);\n\n  void UpdateRunSkipBlockVars(bool IsByref,\n                              Qualifiers::ObjCLifetime LifeTime,\n                              CharUnits FieldOffset,\n                              CharUnits FieldSize);\n\n  void BuildRCBlockVarRecordLayout(const RecordType *RT,\n                                   CharUnits BytePos, bool &HasUnion,\n                                   bool ByrefLayout=false);\n\n  void BuildRCRecordLayout(const llvm::StructLayout *RecLayout,\n                           const RecordDecl *RD,\n                           ArrayRef<const FieldDecl*> RecFields,\n                           CharUnits BytePos, bool &HasUnion,\n                           bool ByrefLayout);\n\n  uint64_t InlineLayoutInstruction(SmallVectorImpl<unsigned char> &Layout);\n\n  llvm::Constant *getBitmapBlockLayout(bool ComputeByrefLayout);\n\n  /// GetIvarLayoutName - Returns a unique constant for the given\n  /// ivar layout bitmap.\n  llvm::Constant *GetIvarLayoutName(IdentifierInfo *Ident,\n                                    const ObjCCommonTypesHelper &ObjCTypes);\n\n  /// EmitPropertyList - Emit the given property list. The return\n  /// value has type PropertyListPtrTy.\n  llvm::Constant *EmitPropertyList(Twine Name,\n                                   const Decl *Container,\n                                   const ObjCContainerDecl *OCD,\n                                   const ObjCCommonTypesHelper &ObjCTypes,\n                                   bool IsClassProperty);\n\n  /// EmitProtocolMethodTypes - Generate the array of extended method type\n  /// strings. The return value has type Int8PtrPtrTy.\n  llvm::Constant *EmitProtocolMethodTypes(Twine Name,\n                                          ArrayRef<llvm::Constant*> MethodTypes,\n                                       const ObjCCommonTypesHelper &ObjCTypes);\n\n  /// GetProtocolRef - Return a reference to the internal protocol\n  /// description, creating an empty one if it has not been\n  /// defined. The return value has type ProtocolPtrTy.\n  llvm::Constant *GetProtocolRef(const ObjCProtocolDecl *PD);\n\n  /// Return a reference to the given Class using runtime calls rather than\n  /// by a symbol reference.\n  llvm::Value *EmitClassRefViaRuntime(CodeGenFunction &CGF,\n                                      const ObjCInterfaceDecl *ID,\n                                      ObjCCommonTypesHelper &ObjCTypes);\n\n  std::string GetSectionName(StringRef Section, StringRef MachOAttributes);\n\npublic:\n  /// CreateMetadataVar - Create a global variable with internal\n  /// linkage for use by the Objective-C runtime.\n  ///\n  /// This is a convenience wrapper which not only creates the\n  /// variable, but also sets the section and alignment and adds the\n  /// global to the \"llvm.used\" list.\n  ///\n  /// \\param Name - The variable name.\n  /// \\param Init - The variable initializer; this is also used to\n  ///   define the type of the variable.\n  /// \\param Section - The section the variable should go into, or empty.\n  /// \\param Align - The alignment for the variable, or 0.\n  /// \\param AddToUsed - Whether the variable should be added to\n  ///   \"llvm.used\".\n  llvm::GlobalVariable *CreateMetadataVar(Twine Name,\n                                          ConstantStructBuilder &Init,\n                                          StringRef Section, CharUnits Align,\n                                          bool AddToUsed);\n  llvm::GlobalVariable *CreateMetadataVar(Twine Name,\n                                          llvm::Constant *Init,\n                                          StringRef Section, CharUnits Align,\n                                          bool AddToUsed);\n\n  llvm::GlobalVariable *CreateCStringLiteral(StringRef Name,\n                                             ObjCLabelType LabelType,\n                                             bool ForceNonFragileABI = false,\n                                             bool NullTerminate = true);\n\nprotected:\n  CodeGen::RValue EmitMessageSend(CodeGen::CodeGenFunction &CGF,\n                                  ReturnValueSlot Return,\n                                  QualType ResultType,\n                                  Selector Sel,\n                                  llvm::Value *Arg0,\n                                  QualType Arg0Ty,\n                                  bool IsSuper,\n                                  const CallArgList &CallArgs,\n                                  const ObjCMethodDecl *OMD,\n                                  const ObjCInterfaceDecl *ClassReceiver,\n                                  const ObjCCommonTypesHelper &ObjCTypes);\n\n  /// EmitImageInfo - Emit the image info marker used to encode some module\n  /// level information.\n  void EmitImageInfo();\n\npublic:\n  CGObjCCommonMac(CodeGen::CodeGenModule &cgm)\n      : CGObjCRuntime(cgm), VMContext(cgm.getLLVMContext()) {}\n\n  bool isNonFragileABI() const {\n    return ObjCABI == 2;\n  }\n\n  ConstantAddress GenerateConstantString(const StringLiteral *SL) override;\n  ConstantAddress GenerateConstantNSString(const StringLiteral *SL);\n\n  llvm::Function *GenerateMethod(const ObjCMethodDecl *OMD,\n                                 const ObjCContainerDecl *CD=nullptr) override;\n\n  llvm::Function *GenerateDirectMethod(const ObjCMethodDecl *OMD,\n                                       const ObjCContainerDecl *CD);\n\n  void GenerateDirectMethodPrologue(CodeGenFunction &CGF, llvm::Function *Fn,\n                                    const ObjCMethodDecl *OMD,\n                                    const ObjCContainerDecl *CD) override;\n\n  void GenerateProtocol(const ObjCProtocolDecl *PD) override;\n\n  /// GetOrEmitProtocolRef - Get a forward reference to the protocol\n  /// object for the given declaration, emitting it if needed. These\n  /// forward references will be filled in with empty bodies if no\n  /// definition is seen. The return value has type ProtocolPtrTy.\n  virtual llvm::Constant *GetOrEmitProtocolRef(const ObjCProtocolDecl *PD)=0;\n\n  virtual llvm::Constant *getNSConstantStringClassRef() = 0;\n\n  llvm::Constant *BuildGCBlockLayout(CodeGen::CodeGenModule &CGM,\n                                     const CGBlockInfo &blockInfo) override;\n  llvm::Constant *BuildRCBlockLayout(CodeGen::CodeGenModule &CGM,\n                                     const CGBlockInfo &blockInfo) override;\n  std::string getRCBlockLayoutStr(CodeGen::CodeGenModule &CGM,\n                                  const CGBlockInfo &blockInfo) override;\n\n  llvm::Constant *BuildByrefLayout(CodeGen::CodeGenModule &CGM,\n                                   QualType T) override;\n\nprivate:\n  void fillRunSkipBlockVars(CodeGenModule &CGM, const CGBlockInfo &blockInfo);\n};\n\nnamespace {\n\nenum class MethodListType {\n  CategoryInstanceMethods,\n  CategoryClassMethods,\n  InstanceMethods,\n  ClassMethods,\n  ProtocolInstanceMethods,\n  ProtocolClassMethods,\n  OptionalProtocolInstanceMethods,\n  OptionalProtocolClassMethods,\n};\n\n/// A convenience class for splitting the methods of a protocol into\n/// the four interesting groups.\nclass ProtocolMethodLists {\npublic:\n  enum Kind {\n    RequiredInstanceMethods,\n    RequiredClassMethods,\n    OptionalInstanceMethods,\n    OptionalClassMethods\n  };\n  enum {\n    NumProtocolMethodLists = 4\n  };\n\n  static MethodListType getMethodListKind(Kind kind) {\n    switch (kind) {\n    case RequiredInstanceMethods:\n      return MethodListType::ProtocolInstanceMethods;\n    case RequiredClassMethods:\n      return MethodListType::ProtocolClassMethods;\n    case OptionalInstanceMethods:\n      return MethodListType::OptionalProtocolInstanceMethods;\n    case OptionalClassMethods:\n      return MethodListType::OptionalProtocolClassMethods;\n    }\n    llvm_unreachable(\"bad kind\");\n  }\n\n  SmallVector<const ObjCMethodDecl *, 4> Methods[NumProtocolMethodLists];\n\n  static ProtocolMethodLists get(const ObjCProtocolDecl *PD) {\n    ProtocolMethodLists result;\n\n    for (auto MD : PD->methods()) {\n      size_t index = (2 * size_t(MD->isOptional()))\n                   + (size_t(MD->isClassMethod()));\n      result.Methods[index].push_back(MD);\n    }\n\n    return result;\n  }\n\n  template <class Self>\n  SmallVector<llvm::Constant*, 8> emitExtendedTypesArray(Self *self) const {\n    // In both ABIs, the method types list is parallel with the\n    // concatenation of the methods arrays in the following order:\n    //   instance methods\n    //   class methods\n    //   optional instance methods\n    //   optional class methods\n    SmallVector<llvm::Constant*, 8> result;\n\n    // Methods is already in the correct order for both ABIs.\n    for (auto &list : Methods) {\n      for (auto MD : list) {\n        result.push_back(self->GetMethodVarType(MD, true));\n      }\n    }\n\n    return result;\n  }\n\n  template <class Self>\n  llvm::Constant *emitMethodList(Self *self, const ObjCProtocolDecl *PD,\n                                 Kind kind) const {\n    return self->emitMethodList(PD->getObjCRuntimeNameAsString(),\n                                getMethodListKind(kind), Methods[kind]);\n  }\n};\n\n} // end anonymous namespace\n\nclass CGObjCMac : public CGObjCCommonMac {\nprivate:\n  friend ProtocolMethodLists;\n\n  ObjCTypesHelper ObjCTypes;\n\n  /// EmitModuleInfo - Another marker encoding module level\n  /// information.\n  void EmitModuleInfo();\n\n  /// EmitModuleSymols - Emit module symbols, the list of defined\n  /// classes and categories. The result has type SymtabPtrTy.\n  llvm::Constant *EmitModuleSymbols();\n\n  /// FinishModule - Write out global data structures at the end of\n  /// processing a translation unit.\n  void FinishModule();\n\n  /// EmitClassExtension - Generate the class extension structure used\n  /// to store the weak ivar layout and properties. The return value\n  /// has type ClassExtensionPtrTy.\n  llvm::Constant *EmitClassExtension(const ObjCImplementationDecl *ID,\n                                     CharUnits instanceSize,\n                                     bool hasMRCWeakIvars,\n                                     bool isMetaclass);\n\n  /// EmitClassRef - Return a Value*, of type ObjCTypes.ClassPtrTy,\n  /// for the given class.\n  llvm::Value *EmitClassRef(CodeGenFunction &CGF,\n                            const ObjCInterfaceDecl *ID);\n\n  llvm::Value *EmitClassRefFromId(CodeGenFunction &CGF,\n                                  IdentifierInfo *II);\n\n  llvm::Value *EmitNSAutoreleasePoolClassRef(CodeGenFunction &CGF) override;\n\n  /// EmitSuperClassRef - Emits reference to class's main metadata class.\n  llvm::Value *EmitSuperClassRef(const ObjCInterfaceDecl *ID);\n\n  /// EmitIvarList - Emit the ivar list for the given\n  /// implementation. If ForClass is true the list of class ivars\n  /// (i.e. metaclass ivars) is emitted, otherwise the list of\n  /// interface ivars will be emitted. The return value has type\n  /// IvarListPtrTy.\n  llvm::Constant *EmitIvarList(const ObjCImplementationDecl *ID,\n                               bool ForClass);\n\n  /// EmitMetaClass - Emit a forward reference to the class structure\n  /// for the metaclass of the given interface. The return value has\n  /// type ClassPtrTy.\n  llvm::Constant *EmitMetaClassRef(const ObjCInterfaceDecl *ID);\n\n  /// EmitMetaClass - Emit a class structure for the metaclass of the\n  /// given implementation. The return value has type ClassPtrTy.\n  llvm::Constant *EmitMetaClass(const ObjCImplementationDecl *ID,\n                                llvm::Constant *Protocols,\n                                ArrayRef<const ObjCMethodDecl *> Methods);\n\n  void emitMethodConstant(ConstantArrayBuilder &builder,\n                          const ObjCMethodDecl *MD);\n\n  void emitMethodDescriptionConstant(ConstantArrayBuilder &builder,\n                                     const ObjCMethodDecl *MD);\n\n  /// EmitMethodList - Emit the method list for the given\n  /// implementation. The return value has type MethodListPtrTy.\n  llvm::Constant *emitMethodList(Twine Name, MethodListType MLT,\n                                 ArrayRef<const ObjCMethodDecl *> Methods);\n\n  /// GetOrEmitProtocol - Get the protocol object for the given\n  /// declaration, emitting it if necessary. The return value has type\n  /// ProtocolPtrTy.\n  llvm::Constant *GetOrEmitProtocol(const ObjCProtocolDecl *PD) override;\n\n  /// GetOrEmitProtocolRef - Get a forward reference to the protocol\n  /// object for the given declaration, emitting it if needed. These\n  /// forward references will be filled in with empty bodies if no\n  /// definition is seen. The return value has type ProtocolPtrTy.\n  llvm::Constant *GetOrEmitProtocolRef(const ObjCProtocolDecl *PD) override;\n\n  /// EmitProtocolExtension - Generate the protocol extension\n  /// structure used to store optional instance and class methods, and\n  /// protocol properties. The return value has type\n  /// ProtocolExtensionPtrTy.\n  llvm::Constant *\n  EmitProtocolExtension(const ObjCProtocolDecl *PD,\n                        const ProtocolMethodLists &methodLists);\n\n  /// EmitProtocolList - Generate the list of referenced\n  /// protocols. The return value has type ProtocolListPtrTy.\n  llvm::Constant *EmitProtocolList(Twine Name,\n                                   ObjCProtocolDecl::protocol_iterator begin,\n                                   ObjCProtocolDecl::protocol_iterator end);\n\n  /// EmitSelector - Return a Value*, of type ObjCTypes.SelectorPtrTy,\n  /// for the given selector.\n  llvm::Value *EmitSelector(CodeGenFunction &CGF, Selector Sel);\n  Address EmitSelectorAddr(Selector Sel);\n\npublic:\n  CGObjCMac(CodeGen::CodeGenModule &cgm);\n\n  llvm::Constant *getNSConstantStringClassRef() override;\n\n  llvm::Function *ModuleInitFunction() override;\n\n  CodeGen::RValue GenerateMessageSend(CodeGen::CodeGenFunction &CGF,\n                                      ReturnValueSlot Return,\n                                      QualType ResultType,\n                                      Selector Sel, llvm::Value *Receiver,\n                                      const CallArgList &CallArgs,\n                                      const ObjCInterfaceDecl *Class,\n                                      const ObjCMethodDecl *Method) override;\n\n  CodeGen::RValue\n  GenerateMessageSendSuper(CodeGen::CodeGenFunction &CGF,\n                           ReturnValueSlot Return, QualType ResultType,\n                           Selector Sel, const ObjCInterfaceDecl *Class,\n                           bool isCategoryImpl, llvm::Value *Receiver,\n                           bool IsClassMessage, const CallArgList &CallArgs,\n                           const ObjCMethodDecl *Method) override;\n\n  llvm::Value *GetClass(CodeGenFunction &CGF,\n                        const ObjCInterfaceDecl *ID) override;\n\n  llvm::Value *GetSelector(CodeGenFunction &CGF, Selector Sel) override;\n  Address GetAddrOfSelector(CodeGenFunction &CGF, Selector Sel) override;\n\n  /// The NeXT/Apple runtimes do not support typed selectors; just emit an\n  /// untyped one.\n  llvm::Value *GetSelector(CodeGenFunction &CGF,\n                           const ObjCMethodDecl *Method) override;\n\n  llvm::Constant *GetEHType(QualType T) override;\n\n  void GenerateCategory(const ObjCCategoryImplDecl *CMD) override;\n\n  void GenerateClass(const ObjCImplementationDecl *ClassDecl) override;\n\n  void RegisterAlias(const ObjCCompatibleAliasDecl *OAD) override {}\n\n  llvm::Value *GenerateProtocolRef(CodeGenFunction &CGF,\n                                   const ObjCProtocolDecl *PD) override;\n\n  llvm::FunctionCallee GetPropertyGetFunction() override;\n  llvm::FunctionCallee GetPropertySetFunction() override;\n  llvm::FunctionCallee GetOptimizedPropertySetFunction(bool atomic,\n                                                       bool copy) override;\n  llvm::FunctionCallee GetGetStructFunction() override;\n  llvm::FunctionCallee GetSetStructFunction() override;\n  llvm::FunctionCallee GetCppAtomicObjectGetFunction() override;\n  llvm::FunctionCallee GetCppAtomicObjectSetFunction() override;\n  llvm::FunctionCallee EnumerationMutationFunction() override;\n\n  void EmitTryStmt(CodeGen::CodeGenFunction &CGF,\n                   const ObjCAtTryStmt &S) override;\n  void EmitSynchronizedStmt(CodeGen::CodeGenFunction &CGF,\n                            const ObjCAtSynchronizedStmt &S) override;\n  void EmitTryOrSynchronizedStmt(CodeGen::CodeGenFunction &CGF, const Stmt &S);\n  void EmitThrowStmt(CodeGen::CodeGenFunction &CGF, const ObjCAtThrowStmt &S,\n                     bool ClearInsertionPoint=true) override;\n  llvm::Value * EmitObjCWeakRead(CodeGen::CodeGenFunction &CGF,\n                                 Address AddrWeakObj) override;\n  void EmitObjCWeakAssign(CodeGen::CodeGenFunction &CGF,\n                          llvm::Value *src, Address dst) override;\n  void EmitObjCGlobalAssign(CodeGen::CodeGenFunction &CGF,\n                            llvm::Value *src, Address dest,\n                            bool threadlocal = false) override;\n  void EmitObjCIvarAssign(CodeGen::CodeGenFunction &CGF,\n                          llvm::Value *src, Address dest,\n                          llvm::Value *ivarOffset) override;\n  void EmitObjCStrongCastAssign(CodeGen::CodeGenFunction &CGF,\n                                llvm::Value *src, Address dest) override;\n  void EmitGCMemmoveCollectable(CodeGen::CodeGenFunction &CGF,\n                                Address dest, Address src,\n                                llvm::Value *size) override;\n\n  LValue EmitObjCValueForIvar(CodeGen::CodeGenFunction &CGF, QualType ObjectTy,\n                              llvm::Value *BaseValue, const ObjCIvarDecl *Ivar,\n                              unsigned CVRQualifiers) override;\n  llvm::Value *EmitIvarOffset(CodeGen::CodeGenFunction &CGF,\n                              const ObjCInterfaceDecl *Interface,\n                              const ObjCIvarDecl *Ivar) override;\n};\n\nclass CGObjCNonFragileABIMac : public CGObjCCommonMac {\nprivate:\n  friend ProtocolMethodLists;\n  ObjCNonFragileABITypesHelper ObjCTypes;\n  llvm::GlobalVariable* ObjCEmptyCacheVar;\n  llvm::Constant* ObjCEmptyVtableVar;\n\n  /// SuperClassReferences - uniqued super class references.\n  llvm::DenseMap<IdentifierInfo*, llvm::GlobalVariable*> SuperClassReferences;\n\n  /// MetaClassReferences - uniqued meta class references.\n  llvm::DenseMap<IdentifierInfo*, llvm::GlobalVariable*> MetaClassReferences;\n\n  /// EHTypeReferences - uniqued class ehtype references.\n  llvm::DenseMap<IdentifierInfo*, llvm::GlobalVariable*> EHTypeReferences;\n\n  /// VTableDispatchMethods - List of methods for which we generate\n  /// vtable-based message dispatch.\n  llvm::DenseSet<Selector> VTableDispatchMethods;\n\n  /// DefinedMetaClasses - List of defined meta-classes.\n  std::vector<llvm::GlobalValue*> DefinedMetaClasses;\n\n  /// isVTableDispatchedSelector - Returns true if SEL is a\n  /// vtable-based selector.\n  bool isVTableDispatchedSelector(Selector Sel);\n\n  /// FinishNonFragileABIModule - Write out global data structures at the end of\n  /// processing a translation unit.\n  void FinishNonFragileABIModule();\n\n  /// AddModuleClassList - Add the given list of class pointers to the\n  /// module with the provided symbol and section names.\n  void AddModuleClassList(ArrayRef<llvm::GlobalValue *> Container,\n                          StringRef SymbolName, StringRef SectionName);\n\n  llvm::GlobalVariable * BuildClassRoTInitializer(unsigned flags,\n                                              unsigned InstanceStart,\n                                              unsigned InstanceSize,\n                                              const ObjCImplementationDecl *ID);\n  llvm::GlobalVariable *BuildClassObject(const ObjCInterfaceDecl *CI,\n                                         bool isMetaclass,\n                                         llvm::Constant *IsAGV,\n                                         llvm::Constant *SuperClassGV,\n                                         llvm::Constant *ClassRoGV,\n                                         bool HiddenVisibility);\n\n  void emitMethodConstant(ConstantArrayBuilder &builder,\n                            const ObjCMethodDecl *MD,\n                            bool forProtocol);\n\n  /// Emit the method list for the given implementation. The return value\n  /// has type MethodListnfABITy.\n  llvm::Constant *emitMethodList(Twine Name, MethodListType MLT,\n                                 ArrayRef<const ObjCMethodDecl *> Methods);\n\n  /// EmitIvarList - Emit the ivar list for the given\n  /// implementation. If ForClass is true the list of class ivars\n  /// (i.e. metaclass ivars) is emitted, otherwise the list of\n  /// interface ivars will be emitted. The return value has type\n  /// IvarListnfABIPtrTy.\n  llvm::Constant *EmitIvarList(const ObjCImplementationDecl *ID);\n\n  llvm::Constant *EmitIvarOffsetVar(const ObjCInterfaceDecl *ID,\n                                    const ObjCIvarDecl *Ivar,\n                                    unsigned long int offset);\n\n  /// GetOrEmitProtocol - Get the protocol object for the given\n  /// declaration, emitting it if necessary. The return value has type\n  /// ProtocolPtrTy.\n  llvm::Constant *GetOrEmitProtocol(const ObjCProtocolDecl *PD) override;\n\n  /// GetOrEmitProtocolRef - Get a forward reference to the protocol\n  /// object for the given declaration, emitting it if needed. These\n  /// forward references will be filled in with empty bodies if no\n  /// definition is seen. The return value has type ProtocolPtrTy.\n  llvm::Constant *GetOrEmitProtocolRef(const ObjCProtocolDecl *PD) override;\n\n  /// EmitProtocolList - Generate the list of referenced\n  /// protocols. The return value has type ProtocolListPtrTy.\n  llvm::Constant *EmitProtocolList(Twine Name,\n                                   ObjCProtocolDecl::protocol_iterator begin,\n                                   ObjCProtocolDecl::protocol_iterator end);\n\n  CodeGen::RValue EmitVTableMessageSend(CodeGen::CodeGenFunction &CGF,\n                                        ReturnValueSlot Return,\n                                        QualType ResultType,\n                                        Selector Sel,\n                                        llvm::Value *Receiver,\n                                        QualType Arg0Ty,\n                                        bool IsSuper,\n                                        const CallArgList &CallArgs,\n                                        const ObjCMethodDecl *Method);\n\n  /// GetClassGlobal - Return the global variable for the Objective-C\n  /// class of the given name.\n  llvm::Constant *GetClassGlobal(StringRef Name,\n                                 ForDefinition_t IsForDefinition,\n                                 bool Weak = false, bool DLLImport = false);\n  llvm::Constant *GetClassGlobal(const ObjCInterfaceDecl *ID,\n                                 bool isMetaclass,\n                                 ForDefinition_t isForDefinition);\n\n  llvm::Constant *GetClassGlobalForClassRef(const ObjCInterfaceDecl *ID);\n\n  llvm::Value *EmitLoadOfClassRef(CodeGenFunction &CGF,\n                                  const ObjCInterfaceDecl *ID,\n                                  llvm::GlobalVariable *Entry);\n\n  /// EmitClassRef - Return a Value*, of type ObjCTypes.ClassPtrTy,\n  /// for the given class reference.\n  llvm::Value *EmitClassRef(CodeGenFunction &CGF,\n                            const ObjCInterfaceDecl *ID);\n\n  llvm::Value *EmitClassRefFromId(CodeGenFunction &CGF,\n                                  IdentifierInfo *II,\n                                  const ObjCInterfaceDecl *ID);\n\n  llvm::Value *EmitNSAutoreleasePoolClassRef(CodeGenFunction &CGF) override;\n\n  /// EmitSuperClassRef - Return a Value*, of type ObjCTypes.ClassPtrTy,\n  /// for the given super class reference.\n  llvm::Value *EmitSuperClassRef(CodeGenFunction &CGF,\n                                 const ObjCInterfaceDecl *ID);\n\n  /// EmitMetaClassRef - Return a Value * of the address of _class_t\n  /// meta-data\n  llvm::Value *EmitMetaClassRef(CodeGenFunction &CGF,\n                                const ObjCInterfaceDecl *ID, bool Weak);\n\n  /// ObjCIvarOffsetVariable - Returns the ivar offset variable for\n  /// the given ivar.\n  ///\n  llvm::GlobalVariable * ObjCIvarOffsetVariable(\n    const ObjCInterfaceDecl *ID,\n    const ObjCIvarDecl *Ivar);\n\n  /// EmitSelector - Return a Value*, of type ObjCTypes.SelectorPtrTy,\n  /// for the given selector.\n  llvm::Value *EmitSelector(CodeGenFunction &CGF, Selector Sel);\n  Address EmitSelectorAddr(Selector Sel);\n\n  /// GetInterfaceEHType - Get the cached ehtype for the given Objective-C\n  /// interface. The return value has type EHTypePtrTy.\n  llvm::Constant *GetInterfaceEHType(const ObjCInterfaceDecl *ID,\n                                     ForDefinition_t IsForDefinition);\n\n  StringRef getMetaclassSymbolPrefix() const { return \"OBJC_METACLASS_$_\"; }\n\n  StringRef getClassSymbolPrefix() const { return \"OBJC_CLASS_$_\"; }\n\n  void GetClassSizeInfo(const ObjCImplementationDecl *OID,\n                        uint32_t &InstanceStart,\n                        uint32_t &InstanceSize);\n\n  // Shamelessly stolen from Analysis/CFRefCount.cpp\n  Selector GetNullarySelector(const char* name) const {\n    IdentifierInfo* II = &CGM.getContext().Idents.get(name);\n    return CGM.getContext().Selectors.getSelector(0, &II);\n  }\n\n  Selector GetUnarySelector(const char* name) const {\n    IdentifierInfo* II = &CGM.getContext().Idents.get(name);\n    return CGM.getContext().Selectors.getSelector(1, &II);\n  }\n\n  /// ImplementationIsNonLazy - Check whether the given category or\n  /// class implementation is \"non-lazy\".\n  bool ImplementationIsNonLazy(const ObjCImplDecl *OD) const;\n\n  bool IsIvarOffsetKnownIdempotent(const CodeGen::CodeGenFunction &CGF,\n                                   const ObjCIvarDecl *IV) {\n    // Annotate the load as an invariant load iff inside an instance method\n    // and ivar belongs to instance method's class and one of its super class.\n    // This check is needed because the ivar offset is a lazily\n    // initialised value that may depend on objc_msgSend to perform a fixup on\n    // the first message dispatch.\n    //\n    // An additional opportunity to mark the load as invariant arises when the\n    // base of the ivar access is a parameter to an Objective C method.\n    // However, because the parameters are not available in the current\n    // interface, we cannot perform this check.\n    //\n    // Note that for direct methods, because objc_msgSend is skipped,\n    // and that the method may be inlined, this optimization actually\n    // can't be performed.\n    if (const ObjCMethodDecl *MD =\n          dyn_cast_or_null<ObjCMethodDecl>(CGF.CurFuncDecl))\n      if (MD->isInstanceMethod() && !MD->isDirectMethod())\n        if (const ObjCInterfaceDecl *ID = MD->getClassInterface())\n          return IV->getContainingInterface()->isSuperClassOf(ID);\n    return false;\n  }\n\n  bool isClassLayoutKnownStatically(const ObjCInterfaceDecl *ID) {\n    // NSObject is a fixed size. If we can see the @implementation of a class\n    // which inherits from NSObject then we know that all it's offsets also must\n    // be fixed. FIXME: Can we do this if see a chain of super classes with\n    // implementations leading to NSObject?\n    return ID->getImplementation() && ID->getSuperClass() &&\n           ID->getSuperClass()->getName() == \"NSObject\";\n  }\n\npublic:\n  CGObjCNonFragileABIMac(CodeGen::CodeGenModule &cgm);\n\n  llvm::Constant *getNSConstantStringClassRef() override;\n\n  llvm::Function *ModuleInitFunction() override;\n\n  CodeGen::RValue GenerateMessageSend(CodeGen::CodeGenFunction &CGF,\n                                      ReturnValueSlot Return,\n                                      QualType ResultType, Selector Sel,\n                                      llvm::Value *Receiver,\n                                      const CallArgList &CallArgs,\n                                      const ObjCInterfaceDecl *Class,\n                                      const ObjCMethodDecl *Method) override;\n\n  CodeGen::RValue\n  GenerateMessageSendSuper(CodeGen::CodeGenFunction &CGF,\n                           ReturnValueSlot Return, QualType ResultType,\n                           Selector Sel, const ObjCInterfaceDecl *Class,\n                           bool isCategoryImpl, llvm::Value *Receiver,\n                           bool IsClassMessage, const CallArgList &CallArgs,\n                           const ObjCMethodDecl *Method) override;\n\n  llvm::Value *GetClass(CodeGenFunction &CGF,\n                        const ObjCInterfaceDecl *ID) override;\n\n  llvm::Value *GetSelector(CodeGenFunction &CGF, Selector Sel) override\n    { return EmitSelector(CGF, Sel); }\n  Address GetAddrOfSelector(CodeGenFunction &CGF, Selector Sel) override\n    { return EmitSelectorAddr(Sel); }\n\n  /// The NeXT/Apple runtimes do not support typed selectors; just emit an\n  /// untyped one.\n  llvm::Value *GetSelector(CodeGenFunction &CGF,\n                           const ObjCMethodDecl *Method) override\n    { return EmitSelector(CGF, Method->getSelector()); }\n\n  void GenerateCategory(const ObjCCategoryImplDecl *CMD) override;\n\n  void GenerateClass(const ObjCImplementationDecl *ClassDecl) override;\n\n  void RegisterAlias(const ObjCCompatibleAliasDecl *OAD) override {}\n\n  llvm::Value *GenerateProtocolRef(CodeGenFunction &CGF,\n                                   const ObjCProtocolDecl *PD) override;\n\n  llvm::Constant *GetEHType(QualType T) override;\n\n  llvm::FunctionCallee GetPropertyGetFunction() override {\n    return ObjCTypes.getGetPropertyFn();\n  }\n  llvm::FunctionCallee GetPropertySetFunction() override {\n    return ObjCTypes.getSetPropertyFn();\n  }\n\n  llvm::FunctionCallee GetOptimizedPropertySetFunction(bool atomic,\n                                                       bool copy) override {\n    return ObjCTypes.getOptimizedSetPropertyFn(atomic, copy);\n  }\n\n  llvm::FunctionCallee GetSetStructFunction() override {\n    return ObjCTypes.getCopyStructFn();\n  }\n\n  llvm::FunctionCallee GetGetStructFunction() override {\n    return ObjCTypes.getCopyStructFn();\n  }\n\n  llvm::FunctionCallee GetCppAtomicObjectSetFunction() override {\n    return ObjCTypes.getCppAtomicObjectFunction();\n  }\n\n  llvm::FunctionCallee GetCppAtomicObjectGetFunction() override {\n    return ObjCTypes.getCppAtomicObjectFunction();\n  }\n\n  llvm::FunctionCallee EnumerationMutationFunction() override {\n    return ObjCTypes.getEnumerationMutationFn();\n  }\n\n  void EmitTryStmt(CodeGen::CodeGenFunction &CGF,\n                   const ObjCAtTryStmt &S) override;\n  void EmitSynchronizedStmt(CodeGen::CodeGenFunction &CGF,\n                            const ObjCAtSynchronizedStmt &S) override;\n  void EmitThrowStmt(CodeGen::CodeGenFunction &CGF, const ObjCAtThrowStmt &S,\n                     bool ClearInsertionPoint=true) override;\n  llvm::Value * EmitObjCWeakRead(CodeGen::CodeGenFunction &CGF,\n                                 Address AddrWeakObj) override;\n  void EmitObjCWeakAssign(CodeGen::CodeGenFunction &CGF,\n                          llvm::Value *src, Address edst) override;\n  void EmitObjCGlobalAssign(CodeGen::CodeGenFunction &CGF,\n                            llvm::Value *src, Address dest,\n                            bool threadlocal = false) override;\n  void EmitObjCIvarAssign(CodeGen::CodeGenFunction &CGF,\n                          llvm::Value *src, Address dest,\n                          llvm::Value *ivarOffset) override;\n  void EmitObjCStrongCastAssign(CodeGen::CodeGenFunction &CGF,\n                                llvm::Value *src, Address dest) override;\n  void EmitGCMemmoveCollectable(CodeGen::CodeGenFunction &CGF,\n                                Address dest, Address src,\n                                llvm::Value *size) override;\n  LValue EmitObjCValueForIvar(CodeGen::CodeGenFunction &CGF, QualType ObjectTy,\n                              llvm::Value *BaseValue, const ObjCIvarDecl *Ivar,\n                              unsigned CVRQualifiers) override;\n  llvm::Value *EmitIvarOffset(CodeGen::CodeGenFunction &CGF,\n                              const ObjCInterfaceDecl *Interface,\n                              const ObjCIvarDecl *Ivar) override;\n};\n\n/// A helper class for performing the null-initialization of a return\n/// value.\nstruct NullReturnState {\n  llvm::BasicBlock *NullBB;\n  NullReturnState() : NullBB(nullptr) {}\n\n  /// Perform a null-check of the given receiver.\n  void init(CodeGenFunction &CGF, llvm::Value *receiver) {\n    // Make blocks for the null-receiver and call edges.\n    NullBB = CGF.createBasicBlock(\"msgSend.null-receiver\");\n    llvm::BasicBlock *callBB = CGF.createBasicBlock(\"msgSend.call\");\n\n    // Check for a null receiver and, if there is one, jump to the\n    // null-receiver block.  There's no point in trying to avoid it:\n    // we're always going to put *something* there, because otherwise\n    // we shouldn't have done this null-check in the first place.\n    llvm::Value *isNull = CGF.Builder.CreateIsNull(receiver);\n    CGF.Builder.CreateCondBr(isNull, NullBB, callBB);\n\n    // Otherwise, start performing the call.\n    CGF.EmitBlock(callBB);\n  }\n\n  /// Complete the null-return operation.  It is valid to call this\n  /// regardless of whether 'init' has been called.\n  RValue complete(CodeGenFunction &CGF,\n                  ReturnValueSlot returnSlot,\n                  RValue result,\n                  QualType resultType,\n                  const CallArgList &CallArgs,\n                  const ObjCMethodDecl *Method) {\n    // If we never had to do a null-check, just use the raw result.\n    if (!NullBB) return result;\n\n    // The continuation block.  This will be left null if we don't have an\n    // IP, which can happen if the method we're calling is marked noreturn.\n    llvm::BasicBlock *contBB = nullptr;\n\n    // Finish the call path.\n    llvm::BasicBlock *callBB = CGF.Builder.GetInsertBlock();\n    if (callBB) {\n      contBB = CGF.createBasicBlock(\"msgSend.cont\");\n      CGF.Builder.CreateBr(contBB);\n    }\n\n    // Okay, start emitting the null-receiver block.\n    CGF.EmitBlock(NullBB);\n\n    // Release any consumed arguments we've got.\n    if (Method) {\n      CallArgList::const_iterator I = CallArgs.begin();\n      for (ObjCMethodDecl::param_const_iterator i = Method->param_begin(),\n           e = Method->param_end(); i != e; ++i, ++I) {\n        const ParmVarDecl *ParamDecl = (*i);\n        if (ParamDecl->hasAttr<NSConsumedAttr>()) {\n          RValue RV = I->getRValue(CGF);\n          assert(RV.isScalar() &&\n                 \"NullReturnState::complete - arg not on object\");\n          CGF.EmitARCRelease(RV.getScalarVal(), ARCImpreciseLifetime);\n        } else {\n          QualType QT = ParamDecl->getType();\n          auto *RT = QT->getAs<RecordType>();\n          if (RT && RT->getDecl()->isParamDestroyedInCallee()) {\n            RValue RV = I->getRValue(CGF);\n            QualType::DestructionKind DtorKind = QT.isDestructedType();\n            switch (DtorKind) {\n            case QualType::DK_cxx_destructor:\n              CGF.destroyCXXObject(CGF, RV.getAggregateAddress(), QT);\n              break;\n            case QualType::DK_nontrivial_c_struct:\n              CGF.destroyNonTrivialCStruct(CGF, RV.getAggregateAddress(), QT);\n              break;\n            default:\n              llvm_unreachable(\"unexpected dtor kind\");\n              break;\n            }\n          }\n        }\n      }\n    }\n\n    // The phi code below assumes that we haven't needed any control flow yet.\n    assert(CGF.Builder.GetInsertBlock() == NullBB);\n\n    // If we've got a void return, just jump to the continuation block.\n    if (result.isScalar() && resultType->isVoidType()) {\n      // No jumps required if the message-send was noreturn.\n      if (contBB) CGF.EmitBlock(contBB);\n      return result;\n    }\n\n    // If we've got a scalar return, build a phi.\n    if (result.isScalar()) {\n      // Derive the null-initialization value.\n      llvm::Value *null =\n          CGF.EmitFromMemory(CGF.CGM.EmitNullConstant(resultType), resultType);\n\n      // If no join is necessary, just flow out.\n      if (!contBB) return RValue::get(null);\n\n      // Otherwise, build a phi.\n      CGF.EmitBlock(contBB);\n      llvm::PHINode *phi = CGF.Builder.CreatePHI(null->getType(), 2);\n      phi->addIncoming(result.getScalarVal(), callBB);\n      phi->addIncoming(null, NullBB);\n      return RValue::get(phi);\n    }\n\n    // If we've got an aggregate return, null the buffer out.\n    // FIXME: maybe we should be doing things differently for all the\n    // cases where the ABI has us returning (1) non-agg values in\n    // memory or (2) agg values in registers.\n    if (result.isAggregate()) {\n      assert(result.isAggregate() && \"null init of non-aggregate result?\");\n      if (!returnSlot.isUnused())\n        CGF.EmitNullInitialization(result.getAggregateAddress(), resultType);\n      if (contBB) CGF.EmitBlock(contBB);\n      return result;\n    }\n\n    // Complex types.\n    CGF.EmitBlock(contBB);\n    CodeGenFunction::ComplexPairTy callResult = result.getComplexVal();\n\n    // Find the scalar type and its zero value.\n    llvm::Type *scalarTy = callResult.first->getType();\n    llvm::Constant *scalarZero = llvm::Constant::getNullValue(scalarTy);\n\n    // Build phis for both coordinates.\n    llvm::PHINode *real = CGF.Builder.CreatePHI(scalarTy, 2);\n    real->addIncoming(callResult.first, callBB);\n    real->addIncoming(scalarZero, NullBB);\n    llvm::PHINode *imag = CGF.Builder.CreatePHI(scalarTy, 2);\n    imag->addIncoming(callResult.second, callBB);\n    imag->addIncoming(scalarZero, NullBB);\n    return RValue::getComplex(real, imag);\n  }\n};\n\n} // end anonymous namespace\n\n/* *** Helper Functions *** */\n\n/// getConstantGEP() - Help routine to construct simple GEPs.\nstatic llvm::Constant *getConstantGEP(llvm::LLVMContext &VMContext,\n                                      llvm::GlobalVariable *C, unsigned idx0,\n                                      unsigned idx1) {\n  llvm::Value *Idxs[] = {\n    llvm::ConstantInt::get(llvm::Type::getInt32Ty(VMContext), idx0),\n    llvm::ConstantInt::get(llvm::Type::getInt32Ty(VMContext), idx1)\n  };\n  return llvm::ConstantExpr::getGetElementPtr(C->getValueType(), C, Idxs);\n}\n\n/// hasObjCExceptionAttribute - Return true if this class or any super\n/// class has the __objc_exception__ attribute.\nstatic bool hasObjCExceptionAttribute(ASTContext &Context,\n                                      const ObjCInterfaceDecl *OID) {\n  if (OID->hasAttr<ObjCExceptionAttr>())\n    return true;\n  if (const ObjCInterfaceDecl *Super = OID->getSuperClass())\n    return hasObjCExceptionAttribute(Context, Super);\n  return false;\n}\n\nstatic llvm::GlobalValue::LinkageTypes\ngetLinkageTypeForObjCMetadata(CodeGenModule &CGM, StringRef Section) {\n  if (CGM.getTriple().isOSBinFormatMachO() &&\n      (Section.empty() || Section.startswith(\"__DATA\")))\n    return llvm::GlobalValue::InternalLinkage;\n  return llvm::GlobalValue::PrivateLinkage;\n}\n\n/// A helper function to create an internal or private global variable.\nstatic llvm::GlobalVariable *\nfinishAndCreateGlobal(ConstantInitBuilder::StructBuilder &Builder,\n                     const llvm::Twine &Name, CodeGenModule &CGM) {\n  std::string SectionName;\n  if (CGM.getTriple().isOSBinFormatMachO())\n    SectionName = \"__DATA, __objc_const\";\n  auto *GV = Builder.finishAndCreateGlobal(\n      Name, CGM.getPointerAlign(), /*constant*/ false,\n      getLinkageTypeForObjCMetadata(CGM, SectionName));\n  GV->setSection(SectionName);\n  return GV;\n}\n\n/* *** CGObjCMac Public Interface *** */\n\nCGObjCMac::CGObjCMac(CodeGen::CodeGenModule &cgm) : CGObjCCommonMac(cgm),\n                                                    ObjCTypes(cgm) {\n  ObjCABI = 1;\n  EmitImageInfo();\n}\n\n/// GetClass - Return a reference to the class for the given interface\n/// decl.\nllvm::Value *CGObjCMac::GetClass(CodeGenFunction &CGF,\n                                 const ObjCInterfaceDecl *ID) {\n  return EmitClassRef(CGF, ID);\n}\n\n/// GetSelector - Return the pointer to the unique'd string for this selector.\nllvm::Value *CGObjCMac::GetSelector(CodeGenFunction &CGF, Selector Sel) {\n  return EmitSelector(CGF, Sel);\n}\nAddress CGObjCMac::GetAddrOfSelector(CodeGenFunction &CGF, Selector Sel) {\n  return EmitSelectorAddr(Sel);\n}\nllvm::Value *CGObjCMac::GetSelector(CodeGenFunction &CGF, const ObjCMethodDecl\n                                    *Method) {\n  return EmitSelector(CGF, Method->getSelector());\n}\n\nllvm::Constant *CGObjCMac::GetEHType(QualType T) {\n  if (T->isObjCIdType() ||\n      T->isObjCQualifiedIdType()) {\n    return CGM.GetAddrOfRTTIDescriptor(\n              CGM.getContext().getObjCIdRedefinitionType(), /*ForEH=*/true);\n  }\n  if (T->isObjCClassType() ||\n      T->isObjCQualifiedClassType()) {\n    return CGM.GetAddrOfRTTIDescriptor(\n             CGM.getContext().getObjCClassRedefinitionType(), /*ForEH=*/true);\n  }\n  if (T->isObjCObjectPointerType())\n    return CGM.GetAddrOfRTTIDescriptor(T,  /*ForEH=*/true);\n\n  llvm_unreachable(\"asking for catch type for ObjC type in fragile runtime\");\n}\n\n/// Generate a constant CFString object.\n/*\n  struct __builtin_CFString {\n  const int *isa; // point to __CFConstantStringClassReference\n  int flags;\n  const char *str;\n  long length;\n  };\n*/\n\n/// or Generate a constant NSString object.\n/*\n   struct __builtin_NSString {\n     const int *isa; // point to __NSConstantStringClassReference\n     const char *str;\n     unsigned int length;\n   };\n*/\n\nConstantAddress\nCGObjCCommonMac::GenerateConstantString(const StringLiteral *SL) {\n  return (!CGM.getLangOpts().NoConstantCFStrings\n            ? CGM.GetAddrOfConstantCFString(SL)\n            : GenerateConstantNSString(SL));\n}\n\nstatic llvm::StringMapEntry<llvm::GlobalVariable *> &\nGetConstantStringEntry(llvm::StringMap<llvm::GlobalVariable *> &Map,\n                       const StringLiteral *Literal, unsigned &StringLength) {\n  StringRef String = Literal->getString();\n  StringLength = String.size();\n  return *Map.insert(std::make_pair(String, nullptr)).first;\n}\n\nllvm::Constant *CGObjCMac::getNSConstantStringClassRef() {\n  if (llvm::Value *V = ConstantStringClassRef)\n    return cast<llvm::Constant>(V);\n\n  auto &StringClass = CGM.getLangOpts().ObjCConstantStringClass;\n  std::string str =\n    StringClass.empty() ? \"_NSConstantStringClassReference\"\n                        : \"_\" + StringClass + \"ClassReference\";\n\n  llvm::Type *PTy = llvm::ArrayType::get(CGM.IntTy, 0);\n  auto GV = CGM.CreateRuntimeVariable(PTy, str);\n  auto V = llvm::ConstantExpr::getBitCast(GV, CGM.IntTy->getPointerTo());\n  ConstantStringClassRef = V;\n  return V;\n}\n\nllvm::Constant *CGObjCNonFragileABIMac::getNSConstantStringClassRef() {\n  if (llvm::Value *V = ConstantStringClassRef)\n    return cast<llvm::Constant>(V);\n\n  auto &StringClass = CGM.getLangOpts().ObjCConstantStringClass;\n  std::string str =\n    StringClass.empty() ? \"OBJC_CLASS_$_NSConstantString\"\n                        : \"OBJC_CLASS_$_\" + StringClass;\n  llvm::Constant *GV = GetClassGlobal(str, NotForDefinition);\n\n  // Make sure the result is of the correct type.\n  auto V = llvm::ConstantExpr::getBitCast(GV, CGM.IntTy->getPointerTo());\n\n  ConstantStringClassRef = V;\n  return V;\n}\n\nConstantAddress\nCGObjCCommonMac::GenerateConstantNSString(const StringLiteral *Literal) {\n  unsigned StringLength = 0;\n  llvm::StringMapEntry<llvm::GlobalVariable *> &Entry =\n    GetConstantStringEntry(NSConstantStringMap, Literal, StringLength);\n\n  if (auto *C = Entry.second)\n    return ConstantAddress(C, CharUnits::fromQuantity(C->getAlignment()));\n\n  // If we don't already have it, get _NSConstantStringClassReference.\n  llvm::Constant *Class = getNSConstantStringClassRef();\n\n  // If we don't already have it, construct the type for a constant NSString.\n  if (!NSConstantStringType) {\n    NSConstantStringType =\n      llvm::StructType::create({\n        CGM.Int32Ty->getPointerTo(),\n        CGM.Int8PtrTy,\n        CGM.IntTy\n      }, \"struct.__builtin_NSString\");\n  }\n\n  ConstantInitBuilder Builder(CGM);\n  auto Fields = Builder.beginStruct(NSConstantStringType);\n\n  // Class pointer.\n  Fields.add(Class);\n\n  // String pointer.\n  llvm::Constant *C =\n    llvm::ConstantDataArray::getString(VMContext, Entry.first());\n\n  llvm::GlobalValue::LinkageTypes Linkage = llvm::GlobalValue::PrivateLinkage;\n  bool isConstant = !CGM.getLangOpts().WritableStrings;\n\n  auto *GV = new llvm::GlobalVariable(CGM.getModule(), C->getType(), isConstant,\n                                      Linkage, C, \".str\");\n  GV->setUnnamedAddr(llvm::GlobalValue::UnnamedAddr::Global);\n  // Don't enforce the target's minimum global alignment, since the only use\n  // of the string is via this class initializer.\n  GV->setAlignment(llvm::Align(1));\n  Fields.addBitCast(GV, CGM.Int8PtrTy);\n\n  // String length.\n  Fields.addInt(CGM.IntTy, StringLength);\n\n  // The struct.\n  CharUnits Alignment = CGM.getPointerAlign();\n  GV = Fields.finishAndCreateGlobal(\"_unnamed_nsstring_\", Alignment,\n                                    /*constant*/ true,\n                                    llvm::GlobalVariable::PrivateLinkage);\n  const char *NSStringSection = \"__OBJC,__cstring_object,regular,no_dead_strip\";\n  const char *NSStringNonFragileABISection =\n      \"__DATA,__objc_stringobj,regular,no_dead_strip\";\n  // FIXME. Fix section.\n  GV->setSection(CGM.getLangOpts().ObjCRuntime.isNonFragile()\n                     ? NSStringNonFragileABISection\n                     : NSStringSection);\n  Entry.second = GV;\n\n  return ConstantAddress(GV, Alignment);\n}\n\nenum {\n  kCFTaggedObjectID_Integer = (1 << 1) + 1\n};\n\n/// Generates a message send where the super is the receiver.  This is\n/// a message send to self with special delivery semantics indicating\n/// which class's method should be called.\nCodeGen::RValue\nCGObjCMac::GenerateMessageSendSuper(CodeGen::CodeGenFunction &CGF,\n                                    ReturnValueSlot Return,\n                                    QualType ResultType,\n                                    Selector Sel,\n                                    const ObjCInterfaceDecl *Class,\n                                    bool isCategoryImpl,\n                                    llvm::Value *Receiver,\n                                    bool IsClassMessage,\n                                    const CodeGen::CallArgList &CallArgs,\n                                    const ObjCMethodDecl *Method) {\n  // Create and init a super structure; this is a (receiver, class)\n  // pair we will pass to objc_msgSendSuper.\n  Address ObjCSuper =\n    CGF.CreateTempAlloca(ObjCTypes.SuperTy, CGF.getPointerAlign(),\n                         \"objc_super\");\n  llvm::Value *ReceiverAsObject =\n    CGF.Builder.CreateBitCast(Receiver, ObjCTypes.ObjectPtrTy);\n  CGF.Builder.CreateStore(ReceiverAsObject,\n                          CGF.Builder.CreateStructGEP(ObjCSuper, 0));\n\n  // If this is a class message the metaclass is passed as the target.\n  llvm::Value *Target;\n  if (IsClassMessage) {\n    if (isCategoryImpl) {\n      // Message sent to 'super' in a class method defined in a category\n      // implementation requires an odd treatment.\n      // If we are in a class method, we must retrieve the\n      // _metaclass_ for the current class, pointed at by\n      // the class's \"isa\" pointer.  The following assumes that\n      // isa\" is the first ivar in a class (which it must be).\n      Target = EmitClassRef(CGF, Class->getSuperClass());\n      Target = CGF.Builder.CreateStructGEP(ObjCTypes.ClassTy, Target, 0);\n      Target = CGF.Builder.CreateAlignedLoad(Target, CGF.getPointerAlign());\n    } else {\n      llvm::Constant *MetaClassPtr = EmitMetaClassRef(Class);\n      llvm::Value *SuperPtr =\n          CGF.Builder.CreateStructGEP(ObjCTypes.ClassTy, MetaClassPtr, 1);\n      llvm::Value *Super =\n        CGF.Builder.CreateAlignedLoad(SuperPtr, CGF.getPointerAlign());\n      Target = Super;\n    }\n  } else if (isCategoryImpl)\n    Target = EmitClassRef(CGF, Class->getSuperClass());\n  else {\n    llvm::Value *ClassPtr = EmitSuperClassRef(Class);\n    ClassPtr = CGF.Builder.CreateStructGEP(ObjCTypes.ClassTy, ClassPtr, 1);\n    Target = CGF.Builder.CreateAlignedLoad(ClassPtr, CGF.getPointerAlign());\n  }\n  // FIXME: We shouldn't need to do this cast, rectify the ASTContext and\n  // ObjCTypes types.\n  llvm::Type *ClassTy =\n    CGM.getTypes().ConvertType(CGF.getContext().getObjCClassType());\n  Target = CGF.Builder.CreateBitCast(Target, ClassTy);\n  CGF.Builder.CreateStore(Target, CGF.Builder.CreateStructGEP(ObjCSuper, 1));\n  return EmitMessageSend(CGF, Return, ResultType, Sel, ObjCSuper.getPointer(),\n                         ObjCTypes.SuperPtrCTy, true, CallArgs, Method, Class,\n                         ObjCTypes);\n}\n\n/// Generate code for a message send expression.\nCodeGen::RValue CGObjCMac::GenerateMessageSend(CodeGen::CodeGenFunction &CGF,\n                                               ReturnValueSlot Return,\n                                               QualType ResultType,\n                                               Selector Sel,\n                                               llvm::Value *Receiver,\n                                               const CallArgList &CallArgs,\n                                               const ObjCInterfaceDecl *Class,\n                                               const ObjCMethodDecl *Method) {\n  return EmitMessageSend(CGF, Return, ResultType, Sel, Receiver,\n                         CGF.getContext().getObjCIdType(), false, CallArgs,\n                         Method, Class, ObjCTypes);\n}\n\nstatic bool isWeakLinkedClass(const ObjCInterfaceDecl *ID) {\n  do {\n    if (ID->isWeakImported())\n      return true;\n  } while ((ID = ID->getSuperClass()));\n\n  return false;\n}\n\nCodeGen::RValue\nCGObjCCommonMac::EmitMessageSend(CodeGen::CodeGenFunction &CGF,\n                                 ReturnValueSlot Return,\n                                 QualType ResultType,\n                                 Selector Sel,\n                                 llvm::Value *Arg0,\n                                 QualType Arg0Ty,\n                                 bool IsSuper,\n                                 const CallArgList &CallArgs,\n                                 const ObjCMethodDecl *Method,\n                                 const ObjCInterfaceDecl *ClassReceiver,\n                                 const ObjCCommonTypesHelper &ObjCTypes) {\n  CodeGenTypes &Types = CGM.getTypes();\n  auto selTy = CGF.getContext().getObjCSelType();\n  llvm::Value *SelValue;\n\n  if (Method && Method->isDirectMethod()) {\n    // Direct methods will synthesize the proper `_cmd` internally,\n    // so just don't bother with setting the `_cmd` argument.\n    assert(!IsSuper);\n    SelValue = llvm::UndefValue::get(Types.ConvertType(selTy));\n  } else {\n    SelValue = GetSelector(CGF, Sel);\n  }\n\n  CallArgList ActualArgs;\n  if (!IsSuper)\n    Arg0 = CGF.Builder.CreateBitCast(Arg0, ObjCTypes.ObjectPtrTy);\n  ActualArgs.add(RValue::get(Arg0), Arg0Ty);\n  ActualArgs.add(RValue::get(SelValue), selTy);\n  ActualArgs.addFrom(CallArgs);\n\n  // If we're calling a method, use the formal signature.\n  MessageSendInfo MSI = getMessageSendInfo(Method, ResultType, ActualArgs);\n\n  if (Method)\n    assert(CGM.getContext().getCanonicalType(Method->getReturnType()) ==\n               CGM.getContext().getCanonicalType(ResultType) &&\n           \"Result type mismatch!\");\n\n  bool ReceiverCanBeNull = true;\n\n  // Super dispatch assumes that self is non-null; even the messenger\n  // doesn't have a null check internally.\n  if (IsSuper) {\n    ReceiverCanBeNull = false;\n\n  // If this is a direct dispatch of a class method, check whether the class,\n  // or anything in its hierarchy, was weak-linked.\n  } else if (ClassReceiver && Method && Method->isClassMethod()) {\n    ReceiverCanBeNull = isWeakLinkedClass(ClassReceiver);\n\n  // If we're emitting a method, and self is const (meaning just ARC, for now),\n  // and the receiver is a load of self, then self is a valid object.\n  } else if (auto CurMethod =\n               dyn_cast_or_null<ObjCMethodDecl>(CGF.CurCodeDecl)) {\n    auto Self = CurMethod->getSelfDecl();\n    if (Self->getType().isConstQualified()) {\n      if (auto LI = dyn_cast<llvm::LoadInst>(Arg0->stripPointerCasts())) {\n        llvm::Value *SelfAddr = CGF.GetAddrOfLocalVar(Self).getPointer();\n        if (SelfAddr == LI->getPointerOperand()) {\n          ReceiverCanBeNull = false;\n        }\n      }\n    }\n  }\n\n  bool RequiresNullCheck = false;\n\n  llvm::FunctionCallee Fn = nullptr;\n  if (Method && Method->isDirectMethod()) {\n    Fn = GenerateDirectMethod(Method, Method->getClassInterface());\n  } else if (CGM.ReturnSlotInterferesWithArgs(MSI.CallInfo)) {\n    if (ReceiverCanBeNull) RequiresNullCheck = true;\n    Fn = (ObjCABI == 2) ?  ObjCTypes.getSendStretFn2(IsSuper)\n      : ObjCTypes.getSendStretFn(IsSuper);\n  } else if (CGM.ReturnTypeUsesFPRet(ResultType)) {\n    Fn = (ObjCABI == 2) ? ObjCTypes.getSendFpretFn2(IsSuper)\n      : ObjCTypes.getSendFpretFn(IsSuper);\n  } else if (CGM.ReturnTypeUsesFP2Ret(ResultType)) {\n    Fn = (ObjCABI == 2) ? ObjCTypes.getSendFp2RetFn2(IsSuper)\n      : ObjCTypes.getSendFp2retFn(IsSuper);\n  } else {\n    // arm64 uses objc_msgSend for stret methods and yet null receiver check\n    // must be made for it.\n    if (ReceiverCanBeNull && CGM.ReturnTypeUsesSRet(MSI.CallInfo))\n      RequiresNullCheck = true;\n    Fn = (ObjCABI == 2) ? ObjCTypes.getSendFn2(IsSuper)\n      : ObjCTypes.getSendFn(IsSuper);\n  }\n\n  // Cast function to proper signature\n  llvm::Constant *BitcastFn = cast<llvm::Constant>(\n      CGF.Builder.CreateBitCast(Fn.getCallee(), MSI.MessengerType));\n\n  // We don't need to emit a null check to zero out an indirect result if the\n  // result is ignored.\n  if (Return.isUnused())\n    RequiresNullCheck = false;\n\n  // Emit a null-check if there's a consumed argument other than the receiver.\n  if (!RequiresNullCheck && CGM.getLangOpts().ObjCAutoRefCount && Method) {\n    for (const auto *ParamDecl : Method->parameters()) {\n      if (ParamDecl->isDestroyedInCallee()) {\n        RequiresNullCheck = true;\n        break;\n      }\n    }\n  }\n\n  NullReturnState nullReturn;\n  if (RequiresNullCheck) {\n    nullReturn.init(CGF, Arg0);\n  }\n\n  llvm::CallBase *CallSite;\n  CGCallee Callee = CGCallee::forDirect(BitcastFn);\n  RValue rvalue = CGF.EmitCall(MSI.CallInfo, Callee, Return, ActualArgs,\n                               &CallSite);\n\n  // Mark the call as noreturn if the method is marked noreturn and the\n  // receiver cannot be null.\n  if (Method && Method->hasAttr<NoReturnAttr>() && !ReceiverCanBeNull) {\n    CallSite->setDoesNotReturn();\n  }\n\n  return nullReturn.complete(CGF, Return, rvalue, ResultType, CallArgs,\n                             RequiresNullCheck ? Method : nullptr);\n}\n\nstatic Qualifiers::GC GetGCAttrTypeForType(ASTContext &Ctx, QualType FQT,\n                                           bool pointee = false) {\n  // Note that GC qualification applies recursively to C pointer types\n  // that aren't otherwise decorated.  This is weird, but it's probably\n  // an intentional workaround to the unreliable placement of GC qualifiers.\n  if (FQT.isObjCGCStrong())\n    return Qualifiers::Strong;\n\n  if (FQT.isObjCGCWeak())\n    return Qualifiers::Weak;\n\n  if (auto ownership = FQT.getObjCLifetime()) {\n    // Ownership does not apply recursively to C pointer types.\n    if (pointee) return Qualifiers::GCNone;\n    switch (ownership) {\n    case Qualifiers::OCL_Weak: return Qualifiers::Weak;\n    case Qualifiers::OCL_Strong: return Qualifiers::Strong;\n    case Qualifiers::OCL_ExplicitNone: return Qualifiers::GCNone;\n    case Qualifiers::OCL_Autoreleasing: llvm_unreachable(\"autoreleasing ivar?\");\n    case Qualifiers::OCL_None: llvm_unreachable(\"known nonzero\");\n    }\n    llvm_unreachable(\"bad objc ownership\");\n  }\n\n  // Treat unqualified retainable pointers as strong.\n  if (FQT->isObjCObjectPointerType() || FQT->isBlockPointerType())\n    return Qualifiers::Strong;\n\n  // Walk into C pointer types, but only in GC.\n  if (Ctx.getLangOpts().getGC() != LangOptions::NonGC) {\n    if (const PointerType *PT = FQT->getAs<PointerType>())\n      return GetGCAttrTypeForType(Ctx, PT->getPointeeType(), /*pointee*/ true);\n  }\n\n  return Qualifiers::GCNone;\n}\n\nnamespace {\n  struct IvarInfo {\n    CharUnits Offset;\n    uint64_t SizeInWords;\n    IvarInfo(CharUnits offset, uint64_t sizeInWords)\n      : Offset(offset), SizeInWords(sizeInWords) {}\n\n    // Allow sorting based on byte pos.\n    bool operator<(const IvarInfo &other) const {\n      return Offset < other.Offset;\n    }\n  };\n\n  /// A helper class for building GC layout strings.\n  class IvarLayoutBuilder {\n    CodeGenModule &CGM;\n\n    /// The start of the layout.  Offsets will be relative to this value,\n    /// and entries less than this value will be silently discarded.\n    CharUnits InstanceBegin;\n\n    /// The end of the layout.  Offsets will never exceed this value.\n    CharUnits InstanceEnd;\n\n    /// Whether we're generating the strong layout or the weak layout.\n    bool ForStrongLayout;\n\n    /// Whether the offsets in IvarsInfo might be out-of-order.\n    bool IsDisordered = false;\n\n    llvm::SmallVector<IvarInfo, 8> IvarsInfo;\n\n  public:\n    IvarLayoutBuilder(CodeGenModule &CGM, CharUnits instanceBegin,\n                      CharUnits instanceEnd, bool forStrongLayout)\n      : CGM(CGM), InstanceBegin(instanceBegin), InstanceEnd(instanceEnd),\n        ForStrongLayout(forStrongLayout) {\n    }\n\n    void visitRecord(const RecordType *RT, CharUnits offset);\n\n    template <class Iterator, class GetOffsetFn>\n    void visitAggregate(Iterator begin, Iterator end,\n                        CharUnits aggrOffset,\n                        const GetOffsetFn &getOffset);\n\n    void visitField(const FieldDecl *field, CharUnits offset);\n\n    /// Add the layout of a block implementation.\n    void visitBlock(const CGBlockInfo &blockInfo);\n\n    /// Is there any information for an interesting bitmap?\n    bool hasBitmapData() const { return !IvarsInfo.empty(); }\n\n    llvm::Constant *buildBitmap(CGObjCCommonMac &CGObjC,\n                                llvm::SmallVectorImpl<unsigned char> &buffer);\n\n    static void dump(ArrayRef<unsigned char> buffer) {\n      const unsigned char *s = buffer.data();\n      for (unsigned i = 0, e = buffer.size(); i < e; i++)\n        if (!(s[i] & 0xf0))\n          printf(\"0x0%x%s\", s[i], s[i] != 0 ? \", \" : \"\");\n        else\n          printf(\"0x%x%s\",  s[i], s[i] != 0 ? \", \" : \"\");\n      printf(\"\\n\");\n    }\n  };\n} // end anonymous namespace\n\nllvm::Constant *CGObjCCommonMac::BuildGCBlockLayout(CodeGenModule &CGM,\n                                                const CGBlockInfo &blockInfo) {\n\n  llvm::Constant *nullPtr = llvm::Constant::getNullValue(CGM.Int8PtrTy);\n  if (CGM.getLangOpts().getGC() == LangOptions::NonGC)\n    return nullPtr;\n\n  IvarLayoutBuilder builder(CGM, CharUnits::Zero(), blockInfo.BlockSize,\n                            /*for strong layout*/ true);\n\n  builder.visitBlock(blockInfo);\n\n  if (!builder.hasBitmapData())\n    return nullPtr;\n\n  llvm::SmallVector<unsigned char, 32> buffer;\n  llvm::Constant *C = builder.buildBitmap(*this, buffer);\n  if (CGM.getLangOpts().ObjCGCBitmapPrint && !buffer.empty()) {\n    printf(\"\\n block variable layout for block: \");\n    builder.dump(buffer);\n  }\n\n  return C;\n}\n\nvoid IvarLayoutBuilder::visitBlock(const CGBlockInfo &blockInfo) {\n  // __isa is the first field in block descriptor and must assume by runtime's\n  // convention that it is GC'able.\n  IvarsInfo.push_back(IvarInfo(CharUnits::Zero(), 1));\n\n  const BlockDecl *blockDecl = blockInfo.getBlockDecl();\n\n  // Ignore the optional 'this' capture: C++ objects are not assumed\n  // to be GC'ed.\n\n  CharUnits lastFieldOffset;\n\n  // Walk the captured variables.\n  for (const auto &CI : blockDecl->captures()) {\n    const VarDecl *variable = CI.getVariable();\n    QualType type = variable->getType();\n\n    const CGBlockInfo::Capture &capture = blockInfo.getCapture(variable);\n\n    // Ignore constant captures.\n    if (capture.isConstant()) continue;\n\n    CharUnits fieldOffset = capture.getOffset();\n\n    // Block fields are not necessarily ordered; if we detect that we're\n    // adding them out-of-order, make sure we sort later.\n    if (fieldOffset < lastFieldOffset)\n      IsDisordered = true;\n    lastFieldOffset = fieldOffset;\n\n    // __block variables are passed by their descriptor address.\n    if (CI.isByRef()) {\n      IvarsInfo.push_back(IvarInfo(fieldOffset, /*size in words*/ 1));\n      continue;\n    }\n\n    assert(!type->isArrayType() && \"array variable should not be caught\");\n    if (const RecordType *record = type->getAs<RecordType>()) {\n      visitRecord(record, fieldOffset);\n      continue;\n    }\n\n    Qualifiers::GC GCAttr = GetGCAttrTypeForType(CGM.getContext(), type);\n\n    if (GCAttr == Qualifiers::Strong) {\n      assert(CGM.getContext().getTypeSize(type)\n                == CGM.getTarget().getPointerWidth(0));\n      IvarsInfo.push_back(IvarInfo(fieldOffset, /*size in words*/ 1));\n    }\n  }\n}\n\n/// getBlockCaptureLifetime - This routine returns life time of the captured\n/// block variable for the purpose of block layout meta-data generation. FQT is\n/// the type of the variable captured in the block.\nQualifiers::ObjCLifetime CGObjCCommonMac::getBlockCaptureLifetime(QualType FQT,\n                                                                  bool ByrefLayout) {\n  // If it has an ownership qualifier, we're done.\n  if (auto lifetime = FQT.getObjCLifetime())\n    return lifetime;\n\n  // If it doesn't, and this is ARC, it has no ownership.\n  if (CGM.getLangOpts().ObjCAutoRefCount)\n    return Qualifiers::OCL_None;\n\n  // In MRC, retainable pointers are owned by non-__block variables.\n  if (FQT->isObjCObjectPointerType() || FQT->isBlockPointerType())\n    return ByrefLayout ? Qualifiers::OCL_ExplicitNone : Qualifiers::OCL_Strong;\n\n  return Qualifiers::OCL_None;\n}\n\nvoid CGObjCCommonMac::UpdateRunSkipBlockVars(bool IsByref,\n                                             Qualifiers::ObjCLifetime LifeTime,\n                                             CharUnits FieldOffset,\n                                             CharUnits FieldSize) {\n  // __block variables are passed by their descriptor address.\n  if (IsByref)\n    RunSkipBlockVars.push_back(RUN_SKIP(BLOCK_LAYOUT_BYREF, FieldOffset,\n                                        FieldSize));\n  else if (LifeTime == Qualifiers::OCL_Strong)\n    RunSkipBlockVars.push_back(RUN_SKIP(BLOCK_LAYOUT_STRONG, FieldOffset,\n                                        FieldSize));\n  else if (LifeTime == Qualifiers::OCL_Weak)\n    RunSkipBlockVars.push_back(RUN_SKIP(BLOCK_LAYOUT_WEAK, FieldOffset,\n                                        FieldSize));\n  else if (LifeTime == Qualifiers::OCL_ExplicitNone)\n    RunSkipBlockVars.push_back(RUN_SKIP(BLOCK_LAYOUT_UNRETAINED, FieldOffset,\n                                        FieldSize));\n  else\n    RunSkipBlockVars.push_back(RUN_SKIP(BLOCK_LAYOUT_NON_OBJECT_BYTES,\n                                        FieldOffset,\n                                        FieldSize));\n}\n\nvoid CGObjCCommonMac::BuildRCRecordLayout(const llvm::StructLayout *RecLayout,\n                                          const RecordDecl *RD,\n                                          ArrayRef<const FieldDecl*> RecFields,\n                                          CharUnits BytePos, bool &HasUnion,\n                                          bool ByrefLayout) {\n  bool IsUnion = (RD && RD->isUnion());\n  CharUnits MaxUnionSize = CharUnits::Zero();\n  const FieldDecl *MaxField = nullptr;\n  const FieldDecl *LastFieldBitfieldOrUnnamed = nullptr;\n  CharUnits MaxFieldOffset = CharUnits::Zero();\n  CharUnits LastBitfieldOrUnnamedOffset = CharUnits::Zero();\n\n  if (RecFields.empty())\n    return;\n  unsigned ByteSizeInBits = CGM.getTarget().getCharWidth();\n\n  for (unsigned i = 0, e = RecFields.size(); i != e; ++i) {\n    const FieldDecl *Field = RecFields[i];\n    // Note that 'i' here is actually the field index inside RD of Field,\n    // although this dependency is hidden.\n    const ASTRecordLayout &RL = CGM.getContext().getASTRecordLayout(RD);\n    CharUnits FieldOffset =\n      CGM.getContext().toCharUnitsFromBits(RL.getFieldOffset(i));\n\n    // Skip over unnamed or bitfields\n    if (!Field->getIdentifier() || Field->isBitField()) {\n      LastFieldBitfieldOrUnnamed = Field;\n      LastBitfieldOrUnnamedOffset = FieldOffset;\n      continue;\n    }\n\n    LastFieldBitfieldOrUnnamed = nullptr;\n    QualType FQT = Field->getType();\n    if (FQT->isRecordType() || FQT->isUnionType()) {\n      if (FQT->isUnionType())\n        HasUnion = true;\n\n      BuildRCBlockVarRecordLayout(FQT->getAs<RecordType>(),\n                                  BytePos + FieldOffset, HasUnion);\n      continue;\n    }\n\n    if (const ArrayType *Array = CGM.getContext().getAsArrayType(FQT)) {\n      auto *CArray = cast<ConstantArrayType>(Array);\n      uint64_t ElCount = CArray->getSize().getZExtValue();\n      assert(CArray && \"only array with known element size is supported\");\n      FQT = CArray->getElementType();\n      while (const ArrayType *Array = CGM.getContext().getAsArrayType(FQT)) {\n        auto *CArray = cast<ConstantArrayType>(Array);\n        ElCount *= CArray->getSize().getZExtValue();\n        FQT = CArray->getElementType();\n      }\n      if (FQT->isRecordType() && ElCount) {\n        int OldIndex = RunSkipBlockVars.size() - 1;\n        auto *RT = FQT->castAs<RecordType>();\n        BuildRCBlockVarRecordLayout(RT, BytePos + FieldOffset, HasUnion);\n\n        // Replicate layout information for each array element. Note that\n        // one element is already done.\n        uint64_t ElIx = 1;\n        for (int FirstIndex = RunSkipBlockVars.size() - 1 ;ElIx < ElCount; ElIx++) {\n          CharUnits Size = CGM.getContext().getTypeSizeInChars(RT);\n          for (int i = OldIndex+1; i <= FirstIndex; ++i)\n            RunSkipBlockVars.push_back(\n              RUN_SKIP(RunSkipBlockVars[i].opcode,\n              RunSkipBlockVars[i].block_var_bytepos + Size*ElIx,\n              RunSkipBlockVars[i].block_var_size));\n        }\n        continue;\n      }\n    }\n    CharUnits FieldSize = CGM.getContext().getTypeSizeInChars(Field->getType());\n    if (IsUnion) {\n      CharUnits UnionIvarSize = FieldSize;\n      if (UnionIvarSize > MaxUnionSize) {\n        MaxUnionSize = UnionIvarSize;\n        MaxField = Field;\n        MaxFieldOffset = FieldOffset;\n      }\n    } else {\n      UpdateRunSkipBlockVars(false,\n                             getBlockCaptureLifetime(FQT, ByrefLayout),\n                             BytePos + FieldOffset,\n                             FieldSize);\n    }\n  }\n\n  if (LastFieldBitfieldOrUnnamed) {\n    if (LastFieldBitfieldOrUnnamed->isBitField()) {\n      // Last field was a bitfield. Must update the info.\n      uint64_t BitFieldSize\n        = LastFieldBitfieldOrUnnamed->getBitWidthValue(CGM.getContext());\n      unsigned UnsSize = (BitFieldSize / ByteSizeInBits) +\n                        ((BitFieldSize % ByteSizeInBits) != 0);\n      CharUnits Size = CharUnits::fromQuantity(UnsSize);\n      Size += LastBitfieldOrUnnamedOffset;\n      UpdateRunSkipBlockVars(false,\n                             getBlockCaptureLifetime(LastFieldBitfieldOrUnnamed->getType(),\n                                                     ByrefLayout),\n                             BytePos + LastBitfieldOrUnnamedOffset,\n                             Size);\n    } else {\n      assert(!LastFieldBitfieldOrUnnamed->getIdentifier() &&\"Expected unnamed\");\n      // Last field was unnamed. Must update skip info.\n      CharUnits FieldSize\n        = CGM.getContext().getTypeSizeInChars(LastFieldBitfieldOrUnnamed->getType());\n      UpdateRunSkipBlockVars(false,\n                             getBlockCaptureLifetime(LastFieldBitfieldOrUnnamed->getType(),\n                                                     ByrefLayout),\n                             BytePos + LastBitfieldOrUnnamedOffset,\n                             FieldSize);\n    }\n  }\n\n  if (MaxField)\n    UpdateRunSkipBlockVars(false,\n                           getBlockCaptureLifetime(MaxField->getType(), ByrefLayout),\n                           BytePos + MaxFieldOffset,\n                           MaxUnionSize);\n}\n\nvoid CGObjCCommonMac::BuildRCBlockVarRecordLayout(const RecordType *RT,\n                                                  CharUnits BytePos,\n                                                  bool &HasUnion,\n                                                  bool ByrefLayout) {\n  const RecordDecl *RD = RT->getDecl();\n  SmallVector<const FieldDecl*, 16> Fields(RD->fields());\n  llvm::Type *Ty = CGM.getTypes().ConvertType(QualType(RT, 0));\n  const llvm::StructLayout *RecLayout =\n    CGM.getDataLayout().getStructLayout(cast<llvm::StructType>(Ty));\n\n  BuildRCRecordLayout(RecLayout, RD, Fields, BytePos, HasUnion, ByrefLayout);\n}\n\n/// InlineLayoutInstruction - This routine produce an inline instruction for the\n/// block variable layout if it can. If not, it returns 0. Rules are as follow:\n/// If ((uintptr_t) layout) < (1 << 12), the layout is inline. In the 64bit world,\n/// an inline layout of value 0x0000000000000xyz is interpreted as follows:\n/// x captured object pointers of BLOCK_LAYOUT_STRONG. Followed by\n/// y captured object of BLOCK_LAYOUT_BYREF. Followed by\n/// z captured object of BLOCK_LAYOUT_WEAK. If any of the above is missing, zero\n/// replaces it. For example, 0x00000x00 means x BLOCK_LAYOUT_STRONG and no\n/// BLOCK_LAYOUT_BYREF and no BLOCK_LAYOUT_WEAK objects are captured.\nuint64_t CGObjCCommonMac::InlineLayoutInstruction(\n                                    SmallVectorImpl<unsigned char> &Layout) {\n  uint64_t Result = 0;\n  if (Layout.size() <= 3) {\n    unsigned size = Layout.size();\n    unsigned strong_word_count = 0, byref_word_count=0, weak_word_count=0;\n    unsigned char inst;\n    enum BLOCK_LAYOUT_OPCODE opcode ;\n    switch (size) {\n      case 3:\n        inst = Layout[0];\n        opcode = (enum BLOCK_LAYOUT_OPCODE) (inst >> 4);\n        if (opcode == BLOCK_LAYOUT_STRONG)\n          strong_word_count = (inst & 0xF)+1;\n        else\n          return 0;\n        inst = Layout[1];\n        opcode = (enum BLOCK_LAYOUT_OPCODE) (inst >> 4);\n        if (opcode == BLOCK_LAYOUT_BYREF)\n          byref_word_count = (inst & 0xF)+1;\n        else\n          return 0;\n        inst = Layout[2];\n        opcode = (enum BLOCK_LAYOUT_OPCODE) (inst >> 4);\n        if (opcode == BLOCK_LAYOUT_WEAK)\n          weak_word_count = (inst & 0xF)+1;\n        else\n          return 0;\n        break;\n\n      case 2:\n        inst = Layout[0];\n        opcode = (enum BLOCK_LAYOUT_OPCODE) (inst >> 4);\n        if (opcode == BLOCK_LAYOUT_STRONG) {\n          strong_word_count = (inst & 0xF)+1;\n          inst = Layout[1];\n          opcode = (enum BLOCK_LAYOUT_OPCODE) (inst >> 4);\n          if (opcode == BLOCK_LAYOUT_BYREF)\n            byref_word_count = (inst & 0xF)+1;\n          else if (opcode == BLOCK_LAYOUT_WEAK)\n            weak_word_count = (inst & 0xF)+1;\n          else\n            return 0;\n        }\n        else if (opcode == BLOCK_LAYOUT_BYREF) {\n          byref_word_count = (inst & 0xF)+1;\n          inst = Layout[1];\n          opcode = (enum BLOCK_LAYOUT_OPCODE) (inst >> 4);\n          if (opcode == BLOCK_LAYOUT_WEAK)\n            weak_word_count = (inst & 0xF)+1;\n          else\n            return 0;\n        }\n        else\n          return 0;\n        break;\n\n      case 1:\n        inst = Layout[0];\n        opcode = (enum BLOCK_LAYOUT_OPCODE) (inst >> 4);\n        if (opcode == BLOCK_LAYOUT_STRONG)\n          strong_word_count = (inst & 0xF)+1;\n        else if (opcode == BLOCK_LAYOUT_BYREF)\n          byref_word_count = (inst & 0xF)+1;\n        else if (opcode == BLOCK_LAYOUT_WEAK)\n          weak_word_count = (inst & 0xF)+1;\n        else\n          return 0;\n        break;\n\n      default:\n        return 0;\n    }\n\n    // Cannot inline when any of the word counts is 15. Because this is one less\n    // than the actual work count (so 15 means 16 actual word counts),\n    // and we can only display 0 thru 15 word counts.\n    if (strong_word_count == 16 || byref_word_count == 16 || weak_word_count == 16)\n      return 0;\n\n    unsigned count =\n      (strong_word_count != 0) + (byref_word_count != 0) + (weak_word_count != 0);\n\n    if (size == count) {\n      if (strong_word_count)\n        Result = strong_word_count;\n      Result <<= 4;\n      if (byref_word_count)\n        Result += byref_word_count;\n      Result <<= 4;\n      if (weak_word_count)\n        Result += weak_word_count;\n    }\n  }\n  return Result;\n}\n\nllvm::Constant *CGObjCCommonMac::getBitmapBlockLayout(bool ComputeByrefLayout) {\n  llvm::Constant *nullPtr = llvm::Constant::getNullValue(CGM.Int8PtrTy);\n  if (RunSkipBlockVars.empty())\n    return nullPtr;\n  unsigned WordSizeInBits = CGM.getTarget().getPointerWidth(0);\n  unsigned ByteSizeInBits = CGM.getTarget().getCharWidth();\n  unsigned WordSizeInBytes = WordSizeInBits/ByteSizeInBits;\n\n  // Sort on byte position; captures might not be allocated in order,\n  // and unions can do funny things.\n  llvm::array_pod_sort(RunSkipBlockVars.begin(), RunSkipBlockVars.end());\n  SmallVector<unsigned char, 16> Layout;\n\n  unsigned size = RunSkipBlockVars.size();\n  for (unsigned i = 0; i < size; i++) {\n    enum BLOCK_LAYOUT_OPCODE opcode = RunSkipBlockVars[i].opcode;\n    CharUnits start_byte_pos = RunSkipBlockVars[i].block_var_bytepos;\n    CharUnits end_byte_pos = start_byte_pos;\n    unsigned j = i+1;\n    while (j < size) {\n      if (opcode == RunSkipBlockVars[j].opcode) {\n        end_byte_pos = RunSkipBlockVars[j++].block_var_bytepos;\n        i++;\n      }\n      else\n        break;\n    }\n    CharUnits size_in_bytes =\n    end_byte_pos - start_byte_pos + RunSkipBlockVars[j-1].block_var_size;\n    if (j < size) {\n      CharUnits gap =\n      RunSkipBlockVars[j].block_var_bytepos -\n      RunSkipBlockVars[j-1].block_var_bytepos - RunSkipBlockVars[j-1].block_var_size;\n      size_in_bytes += gap;\n    }\n    CharUnits residue_in_bytes = CharUnits::Zero();\n    if (opcode == BLOCK_LAYOUT_NON_OBJECT_BYTES) {\n      residue_in_bytes = size_in_bytes % WordSizeInBytes;\n      size_in_bytes -= residue_in_bytes;\n      opcode = BLOCK_LAYOUT_NON_OBJECT_WORDS;\n    }\n\n    unsigned size_in_words = size_in_bytes.getQuantity() / WordSizeInBytes;\n    while (size_in_words >= 16) {\n      // Note that value in imm. is one less that the actual\n      // value. So, 0xf means 16 words follow!\n      unsigned char inst = (opcode << 4) | 0xf;\n      Layout.push_back(inst);\n      size_in_words -= 16;\n    }\n    if (size_in_words > 0) {\n      // Note that value in imm. is one less that the actual\n      // value. So, we subtract 1 away!\n      unsigned char inst = (opcode << 4) | (size_in_words-1);\n      Layout.push_back(inst);\n    }\n    if (residue_in_bytes > CharUnits::Zero()) {\n      unsigned char inst =\n      (BLOCK_LAYOUT_NON_OBJECT_BYTES << 4) | (residue_in_bytes.getQuantity()-1);\n      Layout.push_back(inst);\n    }\n  }\n\n  while (!Layout.empty()) {\n    unsigned char inst = Layout.back();\n    enum BLOCK_LAYOUT_OPCODE opcode = (enum BLOCK_LAYOUT_OPCODE) (inst >> 4);\n    if (opcode == BLOCK_LAYOUT_NON_OBJECT_BYTES || opcode == BLOCK_LAYOUT_NON_OBJECT_WORDS)\n      Layout.pop_back();\n    else\n      break;\n  }\n\n  uint64_t Result = InlineLayoutInstruction(Layout);\n  if (Result != 0) {\n    // Block variable layout instruction has been inlined.\n    if (CGM.getLangOpts().ObjCGCBitmapPrint) {\n      if (ComputeByrefLayout)\n        printf(\"\\n Inline BYREF variable layout: \");\n      else\n        printf(\"\\n Inline block variable layout: \");\n      printf(\"0x0%\" PRIx64 \"\", Result);\n      if (auto numStrong = (Result & 0xF00) >> 8)\n        printf(\", BL_STRONG:%d\", (int) numStrong);\n      if (auto numByref = (Result & 0x0F0) >> 4)\n        printf(\", BL_BYREF:%d\", (int) numByref);\n      if (auto numWeak = (Result & 0x00F) >> 0)\n        printf(\", BL_WEAK:%d\", (int) numWeak);\n      printf(\", BL_OPERATOR:0\\n\");\n    }\n    return llvm::ConstantInt::get(CGM.IntPtrTy, Result);\n  }\n\n  unsigned char inst = (BLOCK_LAYOUT_OPERATOR << 4) | 0;\n  Layout.push_back(inst);\n  std::string BitMap;\n  for (unsigned i = 0, e = Layout.size(); i != e; i++)\n    BitMap += Layout[i];\n\n  if (CGM.getLangOpts().ObjCGCBitmapPrint) {\n    if (ComputeByrefLayout)\n      printf(\"\\n Byref variable layout: \");\n    else\n      printf(\"\\n Block variable layout: \");\n    for (unsigned i = 0, e = BitMap.size(); i != e; i++) {\n      unsigned char inst = BitMap[i];\n      enum BLOCK_LAYOUT_OPCODE opcode = (enum BLOCK_LAYOUT_OPCODE) (inst >> 4);\n      unsigned delta = 1;\n      switch (opcode) {\n        case BLOCK_LAYOUT_OPERATOR:\n          printf(\"BL_OPERATOR:\");\n          delta = 0;\n          break;\n        case BLOCK_LAYOUT_NON_OBJECT_BYTES:\n          printf(\"BL_NON_OBJECT_BYTES:\");\n          break;\n        case BLOCK_LAYOUT_NON_OBJECT_WORDS:\n          printf(\"BL_NON_OBJECT_WORD:\");\n          break;\n        case BLOCK_LAYOUT_STRONG:\n          printf(\"BL_STRONG:\");\n          break;\n        case BLOCK_LAYOUT_BYREF:\n          printf(\"BL_BYREF:\");\n          break;\n        case BLOCK_LAYOUT_WEAK:\n          printf(\"BL_WEAK:\");\n          break;\n        case BLOCK_LAYOUT_UNRETAINED:\n          printf(\"BL_UNRETAINED:\");\n          break;\n      }\n      // Actual value of word count is one more that what is in the imm.\n      // field of the instruction\n      printf(\"%d\", (inst & 0xf) + delta);\n      if (i < e-1)\n        printf(\", \");\n      else\n        printf(\"\\n\");\n    }\n  }\n\n  auto *Entry = CreateCStringLiteral(BitMap, ObjCLabelType::ClassName,\n                                     /*ForceNonFragileABI=*/true,\n                                     /*NullTerminate=*/false);\n  return getConstantGEP(VMContext, Entry, 0, 0);\n}\n\nstatic std::string getBlockLayoutInfoString(\n    const SmallVectorImpl<CGObjCCommonMac::RUN_SKIP> &RunSkipBlockVars,\n    bool HasCopyDisposeHelpers) {\n  std::string Str;\n  for (const CGObjCCommonMac::RUN_SKIP &R : RunSkipBlockVars) {\n    if (R.opcode == CGObjCCommonMac::BLOCK_LAYOUT_UNRETAINED) {\n      // Copy/dispose helpers don't have any information about\n      // __unsafe_unretained captures, so unconditionally concatenate a string.\n      Str += \"u\";\n    } else if (HasCopyDisposeHelpers) {\n      // Information about __strong, __weak, or byref captures has already been\n      // encoded into the names of the copy/dispose helpers. We have to add a\n      // string here only when the copy/dispose helpers aren't generated (which\n      // happens when the block is non-escaping).\n      continue;\n    } else {\n      switch (R.opcode) {\n      case CGObjCCommonMac::BLOCK_LAYOUT_STRONG:\n        Str += \"s\";\n        break;\n      case CGObjCCommonMac::BLOCK_LAYOUT_BYREF:\n        Str += \"r\";\n        break;\n      case CGObjCCommonMac::BLOCK_LAYOUT_WEAK:\n        Str += \"w\";\n        break;\n      default:\n        continue;\n      }\n    }\n    Str += llvm::to_string(R.block_var_bytepos.getQuantity());\n    Str += \"l\" + llvm::to_string(R.block_var_size.getQuantity());\n  }\n  return Str;\n}\n\nvoid CGObjCCommonMac::fillRunSkipBlockVars(CodeGenModule &CGM,\n                                           const CGBlockInfo &blockInfo) {\n  assert(CGM.getLangOpts().getGC() == LangOptions::NonGC);\n\n  RunSkipBlockVars.clear();\n  bool hasUnion = false;\n\n  unsigned WordSizeInBits = CGM.getTarget().getPointerWidth(0);\n  unsigned ByteSizeInBits = CGM.getTarget().getCharWidth();\n  unsigned WordSizeInBytes = WordSizeInBits/ByteSizeInBits;\n\n  const BlockDecl *blockDecl = blockInfo.getBlockDecl();\n\n  // Calculate the basic layout of the block structure.\n  const llvm::StructLayout *layout =\n  CGM.getDataLayout().getStructLayout(blockInfo.StructureType);\n\n  // Ignore the optional 'this' capture: C++ objects are not assumed\n  // to be GC'ed.\n  if (blockInfo.BlockHeaderForcedGapSize != CharUnits::Zero())\n    UpdateRunSkipBlockVars(false, Qualifiers::OCL_None,\n                           blockInfo.BlockHeaderForcedGapOffset,\n                           blockInfo.BlockHeaderForcedGapSize);\n  // Walk the captured variables.\n  for (const auto &CI : blockDecl->captures()) {\n    const VarDecl *variable = CI.getVariable();\n    QualType type = variable->getType();\n\n    const CGBlockInfo::Capture &capture = blockInfo.getCapture(variable);\n\n    // Ignore constant captures.\n    if (capture.isConstant()) continue;\n\n    CharUnits fieldOffset =\n       CharUnits::fromQuantity(layout->getElementOffset(capture.getIndex()));\n\n    assert(!type->isArrayType() && \"array variable should not be caught\");\n    if (!CI.isByRef())\n      if (const RecordType *record = type->getAs<RecordType>()) {\n        BuildRCBlockVarRecordLayout(record, fieldOffset, hasUnion);\n        continue;\n      }\n    CharUnits fieldSize;\n    if (CI.isByRef())\n      fieldSize = CharUnits::fromQuantity(WordSizeInBytes);\n    else\n      fieldSize = CGM.getContext().getTypeSizeInChars(type);\n    UpdateRunSkipBlockVars(CI.isByRef(), getBlockCaptureLifetime(type, false),\n                           fieldOffset, fieldSize);\n  }\n}\n\nllvm::Constant *\nCGObjCCommonMac::BuildRCBlockLayout(CodeGenModule &CGM,\n                                    const CGBlockInfo &blockInfo) {\n  fillRunSkipBlockVars(CGM, blockInfo);\n  return getBitmapBlockLayout(false);\n}\n\nstd::string CGObjCCommonMac::getRCBlockLayoutStr(CodeGenModule &CGM,\n                                                 const CGBlockInfo &blockInfo) {\n  fillRunSkipBlockVars(CGM, blockInfo);\n  return getBlockLayoutInfoString(RunSkipBlockVars,\n                                  blockInfo.needsCopyDisposeHelpers());\n}\n\nllvm::Constant *CGObjCCommonMac::BuildByrefLayout(CodeGen::CodeGenModule &CGM,\n                                                  QualType T) {\n  assert(CGM.getLangOpts().getGC() == LangOptions::NonGC);\n  assert(!T->isArrayType() && \"__block array variable should not be caught\");\n  CharUnits fieldOffset;\n  RunSkipBlockVars.clear();\n  bool hasUnion = false;\n  if (const RecordType *record = T->getAs<RecordType>()) {\n    BuildRCBlockVarRecordLayout(record, fieldOffset, hasUnion, true /*ByrefLayout */);\n    llvm::Constant *Result = getBitmapBlockLayout(true);\n    if (isa<llvm::ConstantInt>(Result))\n      Result = llvm::ConstantExpr::getIntToPtr(Result, CGM.Int8PtrTy);\n    return Result;\n  }\n  llvm::Constant *nullPtr = llvm::Constant::getNullValue(CGM.Int8PtrTy);\n  return nullPtr;\n}\n\nllvm::Value *CGObjCMac::GenerateProtocolRef(CodeGenFunction &CGF,\n                                            const ObjCProtocolDecl *PD) {\n  // FIXME: I don't understand why gcc generates this, or where it is\n  // resolved. Investigate. Its also wasteful to look this up over and over.\n  LazySymbols.insert(&CGM.getContext().Idents.get(\"Protocol\"));\n\n  return llvm::ConstantExpr::getBitCast(GetProtocolRef(PD),\n                                        ObjCTypes.getExternalProtocolPtrTy());\n}\n\nvoid CGObjCCommonMac::GenerateProtocol(const ObjCProtocolDecl *PD) {\n  // FIXME: We shouldn't need this, the protocol decl should contain enough\n  // information to tell us whether this was a declaration or a definition.\n  DefinedProtocols.insert(PD->getIdentifier());\n\n  // If we have generated a forward reference to this protocol, emit\n  // it now. Otherwise do nothing, the protocol objects are lazily\n  // emitted.\n  if (Protocols.count(PD->getIdentifier()))\n    GetOrEmitProtocol(PD);\n}\n\nllvm::Constant *CGObjCCommonMac::GetProtocolRef(const ObjCProtocolDecl *PD) {\n  if (DefinedProtocols.count(PD->getIdentifier()))\n    return GetOrEmitProtocol(PD);\n\n  return GetOrEmitProtocolRef(PD);\n}\n\nllvm::Value *CGObjCCommonMac::EmitClassRefViaRuntime(\n               CodeGenFunction &CGF,\n               const ObjCInterfaceDecl *ID,\n               ObjCCommonTypesHelper &ObjCTypes) {\n  llvm::FunctionCallee lookUpClassFn = ObjCTypes.getLookUpClassFn();\n\n  llvm::Value *className = CGF.CGM\n                               .GetAddrOfConstantCString(std::string(\n                                   ID->getObjCRuntimeNameAsString()))\n                               .getPointer();\n  ASTContext &ctx = CGF.CGM.getContext();\n  className =\n      CGF.Builder.CreateBitCast(className,\n                                CGF.ConvertType(\n                                  ctx.getPointerType(ctx.CharTy.withConst())));\n  llvm::CallInst *call = CGF.Builder.CreateCall(lookUpClassFn, className);\n  call->setDoesNotThrow();\n  return call;\n}\n\n/*\n// Objective-C 1.0 extensions\nstruct _objc_protocol {\nstruct _objc_protocol_extension *isa;\nchar *protocol_name;\nstruct _objc_protocol_list *protocol_list;\nstruct _objc__method_prototype_list *instance_methods;\nstruct _objc__method_prototype_list *class_methods\n};\n\nSee EmitProtocolExtension().\n*/\nllvm::Constant *CGObjCMac::GetOrEmitProtocol(const ObjCProtocolDecl *PD) {\n  llvm::GlobalVariable *Entry = Protocols[PD->getIdentifier()];\n\n  // Early exit if a defining object has already been generated.\n  if (Entry && Entry->hasInitializer())\n    return Entry;\n\n  // Use the protocol definition, if there is one.\n  if (const ObjCProtocolDecl *Def = PD->getDefinition())\n    PD = Def;\n\n  // FIXME: I don't understand why gcc generates this, or where it is\n  // resolved. Investigate. Its also wasteful to look this up over and over.\n  LazySymbols.insert(&CGM.getContext().Idents.get(\"Protocol\"));\n\n  // Construct method lists.\n  auto methodLists = ProtocolMethodLists::get(PD);\n\n  ConstantInitBuilder builder(CGM);\n  auto values = builder.beginStruct(ObjCTypes.ProtocolTy);\n  values.add(EmitProtocolExtension(PD, methodLists));\n  values.add(GetClassName(PD->getObjCRuntimeNameAsString()));\n  values.add(EmitProtocolList(\"OBJC_PROTOCOL_REFS_\" + PD->getName(),\n                              PD->protocol_begin(), PD->protocol_end()));\n  values.add(methodLists.emitMethodList(this, PD,\n                              ProtocolMethodLists::RequiredInstanceMethods));\n  values.add(methodLists.emitMethodList(this, PD,\n                              ProtocolMethodLists::RequiredClassMethods));\n\n  if (Entry) {\n    // Already created, update the initializer.\n    assert(Entry->hasPrivateLinkage());\n    values.finishAndSetAsInitializer(Entry);\n  } else {\n    Entry = values.finishAndCreateGlobal(\"OBJC_PROTOCOL_\" + PD->getName(),\n                                         CGM.getPointerAlign(),\n                                         /*constant*/ false,\n                                         llvm::GlobalValue::PrivateLinkage);\n    Entry->setSection(\"__OBJC,__protocol,regular,no_dead_strip\");\n\n    Protocols[PD->getIdentifier()] = Entry;\n  }\n  CGM.addCompilerUsedGlobal(Entry);\n\n  return Entry;\n}\n\nllvm::Constant *CGObjCMac::GetOrEmitProtocolRef(const ObjCProtocolDecl *PD) {\n  llvm::GlobalVariable *&Entry = Protocols[PD->getIdentifier()];\n\n  if (!Entry) {\n    // We use the initializer as a marker of whether this is a forward\n    // reference or not. At module finalization we add the empty\n    // contents for protocols which were referenced but never defined.\n    Entry = new llvm::GlobalVariable(CGM.getModule(), ObjCTypes.ProtocolTy,\n                                     false, llvm::GlobalValue::PrivateLinkage,\n                                     nullptr, \"OBJC_PROTOCOL_\" + PD->getName());\n    Entry->setSection(\"__OBJC,__protocol,regular,no_dead_strip\");\n    // FIXME: Is this necessary? Why only for protocol?\n    Entry->setAlignment(llvm::Align(4));\n  }\n\n  return Entry;\n}\n\n/*\n  struct _objc_protocol_extension {\n  uint32_t size;\n  struct objc_method_description_list *optional_instance_methods;\n  struct objc_method_description_list *optional_class_methods;\n  struct objc_property_list *instance_properties;\n  const char ** extendedMethodTypes;\n  struct objc_property_list *class_properties;\n  };\n*/\nllvm::Constant *\nCGObjCMac::EmitProtocolExtension(const ObjCProtocolDecl *PD,\n                                 const ProtocolMethodLists &methodLists) {\n  auto optInstanceMethods =\n    methodLists.emitMethodList(this, PD,\n                               ProtocolMethodLists::OptionalInstanceMethods);\n  auto optClassMethods =\n    methodLists.emitMethodList(this, PD,\n                               ProtocolMethodLists::OptionalClassMethods);\n\n  auto extendedMethodTypes =\n    EmitProtocolMethodTypes(\"OBJC_PROTOCOL_METHOD_TYPES_\" + PD->getName(),\n                            methodLists.emitExtendedTypesArray(this),\n                            ObjCTypes);\n\n  auto instanceProperties =\n    EmitPropertyList(\"OBJC_$_PROP_PROTO_LIST_\" + PD->getName(), nullptr, PD,\n                     ObjCTypes, false);\n  auto classProperties =\n    EmitPropertyList(\"OBJC_$_CLASS_PROP_PROTO_LIST_\" + PD->getName(), nullptr,\n                     PD, ObjCTypes, true);\n\n  // Return null if no extension bits are used.\n  if (optInstanceMethods->isNullValue() &&\n      optClassMethods->isNullValue() &&\n      extendedMethodTypes->isNullValue() &&\n      instanceProperties->isNullValue() &&\n      classProperties->isNullValue()) {\n    return llvm::Constant::getNullValue(ObjCTypes.ProtocolExtensionPtrTy);\n  }\n\n  uint64_t size =\n    CGM.getDataLayout().getTypeAllocSize(ObjCTypes.ProtocolExtensionTy);\n\n  ConstantInitBuilder builder(CGM);\n  auto values = builder.beginStruct(ObjCTypes.ProtocolExtensionTy);\n  values.addInt(ObjCTypes.IntTy, size);\n  values.add(optInstanceMethods);\n  values.add(optClassMethods);\n  values.add(instanceProperties);\n  values.add(extendedMethodTypes);\n  values.add(classProperties);\n\n  // No special section, but goes in llvm.used\n  return CreateMetadataVar(\"_OBJC_PROTOCOLEXT_\" + PD->getName(), values,\n                           StringRef(), CGM.getPointerAlign(), true);\n}\n\n/*\n  struct objc_protocol_list {\n    struct objc_protocol_list *next;\n    long count;\n    Protocol *list[];\n  };\n*/\nllvm::Constant *\nCGObjCMac::EmitProtocolList(Twine name,\n                            ObjCProtocolDecl::protocol_iterator begin,\n                            ObjCProtocolDecl::protocol_iterator end) {\n  // Just return null for empty protocol lists\n  auto PDs = GetRuntimeProtocolList(begin, end);\n  if (PDs.empty())\n    return llvm::Constant::getNullValue(ObjCTypes.ProtocolListPtrTy);\n\n  ConstantInitBuilder builder(CGM);\n  auto values = builder.beginStruct();\n\n  // This field is only used by the runtime.\n  values.addNullPointer(ObjCTypes.ProtocolListPtrTy);\n\n  // Reserve a slot for the count.\n  auto countSlot = values.addPlaceholder();\n\n  auto refsArray = values.beginArray(ObjCTypes.ProtocolPtrTy);\n  for (const auto *Proto : PDs)\n    refsArray.add(GetProtocolRef(Proto));\n\n  auto count = refsArray.size();\n\n  // This list is null terminated.\n  refsArray.addNullPointer(ObjCTypes.ProtocolPtrTy);\n\n  refsArray.finishAndAddTo(values);\n  values.fillPlaceholderWithInt(countSlot, ObjCTypes.LongTy, count);\n\n  StringRef section;\n  if (CGM.getTriple().isOSBinFormatMachO())\n    section = \"__OBJC,__cat_cls_meth,regular,no_dead_strip\";\n\n  llvm::GlobalVariable *GV =\n      CreateMetadataVar(name, values, section, CGM.getPointerAlign(), false);\n  return llvm::ConstantExpr::getBitCast(GV, ObjCTypes.ProtocolListPtrTy);\n}\n\nstatic void\nPushProtocolProperties(llvm::SmallPtrSet<const IdentifierInfo*,16> &PropertySet,\n                       SmallVectorImpl<const ObjCPropertyDecl *> &Properties,\n                       const ObjCProtocolDecl *Proto,\n                       bool IsClassProperty) {\n  for (const auto *PD : Proto->properties()) {\n    if (IsClassProperty != PD->isClassProperty())\n      continue;\n    if (!PropertySet.insert(PD->getIdentifier()).second)\n      continue;\n    Properties.push_back(PD);\n  }\n\n  for (const auto *P : Proto->protocols())\n    PushProtocolProperties(PropertySet, Properties, P, IsClassProperty);\n}\n\n/*\n  struct _objc_property {\n    const char * const name;\n    const char * const attributes;\n  };\n\n  struct _objc_property_list {\n    uint32_t entsize; // sizeof (struct _objc_property)\n    uint32_t prop_count;\n    struct _objc_property[prop_count];\n  };\n*/\nllvm::Constant *CGObjCCommonMac::EmitPropertyList(Twine Name,\n                                       const Decl *Container,\n                                       const ObjCContainerDecl *OCD,\n                                       const ObjCCommonTypesHelper &ObjCTypes,\n                                       bool IsClassProperty) {\n  if (IsClassProperty) {\n    // Make this entry NULL for OS X with deployment target < 10.11, for iOS\n    // with deployment target < 9.0.\n    const llvm::Triple &Triple = CGM.getTarget().getTriple();\n    if ((Triple.isMacOSX() && Triple.isMacOSXVersionLT(10, 11)) ||\n        (Triple.isiOS() && Triple.isOSVersionLT(9)))\n      return llvm::Constant::getNullValue(ObjCTypes.PropertyListPtrTy);\n  }\n\n  SmallVector<const ObjCPropertyDecl *, 16> Properties;\n  llvm::SmallPtrSet<const IdentifierInfo*, 16> PropertySet;\n\n  if (const ObjCInterfaceDecl *OID = dyn_cast<ObjCInterfaceDecl>(OCD))\n    for (const ObjCCategoryDecl *ClassExt : OID->known_extensions())\n      for (auto *PD : ClassExt->properties()) {\n        if (IsClassProperty != PD->isClassProperty())\n          continue;\n        if (PD->isDirectProperty())\n          continue;\n        PropertySet.insert(PD->getIdentifier());\n        Properties.push_back(PD);\n      }\n\n  for (const auto *PD : OCD->properties()) {\n    if (IsClassProperty != PD->isClassProperty())\n      continue;\n    // Don't emit duplicate metadata for properties that were already in a\n    // class extension.\n    if (!PropertySet.insert(PD->getIdentifier()).second)\n      continue;\n    if (PD->isDirectProperty())\n      continue;\n    Properties.push_back(PD);\n  }\n\n  if (const ObjCInterfaceDecl *OID = dyn_cast<ObjCInterfaceDecl>(OCD)) {\n    for (const auto *P : OID->all_referenced_protocols())\n      PushProtocolProperties(PropertySet, Properties, P, IsClassProperty);\n  }\n  else if (const ObjCCategoryDecl *CD = dyn_cast<ObjCCategoryDecl>(OCD)) {\n    for (const auto *P : CD->protocols())\n      PushProtocolProperties(PropertySet, Properties, P, IsClassProperty);\n  }\n\n  // Return null for empty list.\n  if (Properties.empty())\n    return llvm::Constant::getNullValue(ObjCTypes.PropertyListPtrTy);\n\n  unsigned propertySize =\n    CGM.getDataLayout().getTypeAllocSize(ObjCTypes.PropertyTy);\n\n  ConstantInitBuilder builder(CGM);\n  auto values = builder.beginStruct();\n  values.addInt(ObjCTypes.IntTy, propertySize);\n  values.addInt(ObjCTypes.IntTy, Properties.size());\n  auto propertiesArray = values.beginArray(ObjCTypes.PropertyTy);\n  for (auto PD : Properties) {\n    auto property = propertiesArray.beginStruct(ObjCTypes.PropertyTy);\n    property.add(GetPropertyName(PD->getIdentifier()));\n    property.add(GetPropertyTypeString(PD, Container));\n    property.finishAndAddTo(propertiesArray);\n  }\n  propertiesArray.finishAndAddTo(values);\n\n  StringRef Section;\n  if (CGM.getTriple().isOSBinFormatMachO())\n    Section = (ObjCABI == 2) ? \"__DATA, __objc_const\"\n                             : \"__OBJC,__property,regular,no_dead_strip\";\n\n  llvm::GlobalVariable *GV =\n      CreateMetadataVar(Name, values, Section, CGM.getPointerAlign(), true);\n  return llvm::ConstantExpr::getBitCast(GV, ObjCTypes.PropertyListPtrTy);\n}\n\nllvm::Constant *\nCGObjCCommonMac::EmitProtocolMethodTypes(Twine Name,\n                                         ArrayRef<llvm::Constant*> MethodTypes,\n                                         const ObjCCommonTypesHelper &ObjCTypes) {\n  // Return null for empty list.\n  if (MethodTypes.empty())\n    return llvm::Constant::getNullValue(ObjCTypes.Int8PtrPtrTy);\n\n  llvm::ArrayType *AT = llvm::ArrayType::get(ObjCTypes.Int8PtrTy,\n                                             MethodTypes.size());\n  llvm::Constant *Init = llvm::ConstantArray::get(AT, MethodTypes);\n\n  StringRef Section;\n  if (CGM.getTriple().isOSBinFormatMachO() && ObjCABI == 2)\n    Section = \"__DATA, __objc_const\";\n\n  llvm::GlobalVariable *GV =\n      CreateMetadataVar(Name, Init, Section, CGM.getPointerAlign(), true);\n  return llvm::ConstantExpr::getBitCast(GV, ObjCTypes.Int8PtrPtrTy);\n}\n\n/*\n  struct _objc_category {\n  char *category_name;\n  char *class_name;\n  struct _objc_method_list *instance_methods;\n  struct _objc_method_list *class_methods;\n  struct _objc_protocol_list *protocols;\n  uint32_t size; // <rdar://4585769>\n  struct _objc_property_list *instance_properties;\n  struct _objc_property_list *class_properties;\n  };\n*/\nvoid CGObjCMac::GenerateCategory(const ObjCCategoryImplDecl *OCD) {\n  unsigned Size = CGM.getDataLayout().getTypeAllocSize(ObjCTypes.CategoryTy);\n\n  // FIXME: This is poor design, the OCD should have a pointer to the category\n  // decl. Additionally, note that Category can be null for the @implementation\n  // w/o an @interface case. Sema should just create one for us as it does for\n  // @implementation so everyone else can live life under a clear blue sky.\n  const ObjCInterfaceDecl *Interface = OCD->getClassInterface();\n  const ObjCCategoryDecl *Category =\n    Interface->FindCategoryDeclaration(OCD->getIdentifier());\n\n  SmallString<256> ExtName;\n  llvm::raw_svector_ostream(ExtName) << Interface->getName() << '_'\n                                     << OCD->getName();\n\n  ConstantInitBuilder Builder(CGM);\n  auto Values = Builder.beginStruct(ObjCTypes.CategoryTy);\n\n  enum {\n    InstanceMethods,\n    ClassMethods,\n    NumMethodLists\n  };\n  SmallVector<const ObjCMethodDecl *, 16> Methods[NumMethodLists];\n  for (const auto *MD : OCD->methods()) {\n    if (!MD->isDirectMethod())\n      Methods[unsigned(MD->isClassMethod())].push_back(MD);\n  }\n\n  Values.add(GetClassName(OCD->getName()));\n  Values.add(GetClassName(Interface->getObjCRuntimeNameAsString()));\n  LazySymbols.insert(Interface->getIdentifier());\n\n  Values.add(emitMethodList(ExtName, MethodListType::CategoryInstanceMethods,\n                            Methods[InstanceMethods]));\n  Values.add(emitMethodList(ExtName, MethodListType::CategoryClassMethods,\n                            Methods[ClassMethods]));\n  if (Category) {\n    Values.add(\n        EmitProtocolList(\"OBJC_CATEGORY_PROTOCOLS_\" + ExtName.str(),\n                         Category->protocol_begin(), Category->protocol_end()));\n  } else {\n    Values.addNullPointer(ObjCTypes.ProtocolListPtrTy);\n  }\n  Values.addInt(ObjCTypes.IntTy, Size);\n\n  // If there is no category @interface then there can be no properties.\n  if (Category) {\n    Values.add(EmitPropertyList(\"_OBJC_$_PROP_LIST_\" + ExtName.str(),\n                                OCD, Category, ObjCTypes, false));\n    Values.add(EmitPropertyList(\"_OBJC_$_CLASS_PROP_LIST_\" + ExtName.str(),\n                                OCD, Category, ObjCTypes, true));\n  } else {\n    Values.addNullPointer(ObjCTypes.PropertyListPtrTy);\n    Values.addNullPointer(ObjCTypes.PropertyListPtrTy);\n  }\n\n  llvm::GlobalVariable *GV =\n      CreateMetadataVar(\"OBJC_CATEGORY_\" + ExtName.str(), Values,\n                        \"__OBJC,__category,regular,no_dead_strip\",\n                        CGM.getPointerAlign(), true);\n  DefinedCategories.push_back(GV);\n  DefinedCategoryNames.insert(llvm::CachedHashString(ExtName));\n  // method definition entries must be clear for next implementation.\n  MethodDefinitions.clear();\n}\n\nenum FragileClassFlags {\n  /// Apparently: is not a meta-class.\n  FragileABI_Class_Factory                 = 0x00001,\n\n  /// Is a meta-class.\n  FragileABI_Class_Meta                    = 0x00002,\n\n  /// Has a non-trivial constructor or destructor.\n  FragileABI_Class_HasCXXStructors         = 0x02000,\n\n  /// Has hidden visibility.\n  FragileABI_Class_Hidden                  = 0x20000,\n\n  /// Class implementation was compiled under ARC.\n  FragileABI_Class_CompiledByARC           = 0x04000000,\n\n  /// Class implementation was compiled under MRC and has MRC weak ivars.\n  /// Exclusive with CompiledByARC.\n  FragileABI_Class_HasMRCWeakIvars         = 0x08000000,\n};\n\nenum NonFragileClassFlags {\n  /// Is a meta-class.\n  NonFragileABI_Class_Meta                 = 0x00001,\n\n  /// Is a root class.\n  NonFragileABI_Class_Root                 = 0x00002,\n\n  /// Has a non-trivial constructor or destructor.\n  NonFragileABI_Class_HasCXXStructors      = 0x00004,\n\n  /// Has hidden visibility.\n  NonFragileABI_Class_Hidden               = 0x00010,\n\n  /// Has the exception attribute.\n  NonFragileABI_Class_Exception            = 0x00020,\n\n  /// (Obsolete) ARC-specific: this class has a .release_ivars method\n  NonFragileABI_Class_HasIvarReleaser      = 0x00040,\n\n  /// Class implementation was compiled under ARC.\n  NonFragileABI_Class_CompiledByARC        = 0x00080,\n\n  /// Class has non-trivial destructors, but zero-initialization is okay.\n  NonFragileABI_Class_HasCXXDestructorOnly = 0x00100,\n\n  /// Class implementation was compiled under MRC and has MRC weak ivars.\n  /// Exclusive with CompiledByARC.\n  NonFragileABI_Class_HasMRCWeakIvars      = 0x00200,\n};\n\nstatic bool hasWeakMember(QualType type) {\n  if (type.getObjCLifetime() == Qualifiers::OCL_Weak) {\n    return true;\n  }\n\n  if (auto recType = type->getAs<RecordType>()) {\n    for (auto field : recType->getDecl()->fields()) {\n      if (hasWeakMember(field->getType()))\n        return true;\n    }\n  }\n\n  return false;\n}\n\n/// For compatibility, we only want to set the \"HasMRCWeakIvars\" flag\n/// (and actually fill in a layout string) if we really do have any\n/// __weak ivars.\nstatic bool hasMRCWeakIvars(CodeGenModule &CGM,\n                            const ObjCImplementationDecl *ID) {\n  if (!CGM.getLangOpts().ObjCWeak) return false;\n  assert(CGM.getLangOpts().getGC() == LangOptions::NonGC);\n\n  for (const ObjCIvarDecl *ivar =\n         ID->getClassInterface()->all_declared_ivar_begin();\n       ivar; ivar = ivar->getNextIvar()) {\n    if (hasWeakMember(ivar->getType()))\n      return true;\n  }\n\n  return false;\n}\n\n/*\n  struct _objc_class {\n  Class isa;\n  Class super_class;\n  const char *name;\n  long version;\n  long info;\n  long instance_size;\n  struct _objc_ivar_list *ivars;\n  struct _objc_method_list *methods;\n  struct _objc_cache *cache;\n  struct _objc_protocol_list *protocols;\n  // Objective-C 1.0 extensions (<rdr://4585769>)\n  const char *ivar_layout;\n  struct _objc_class_ext *ext;\n  };\n\n  See EmitClassExtension();\n*/\nvoid CGObjCMac::GenerateClass(const ObjCImplementationDecl *ID) {\n  IdentifierInfo *RuntimeName =\n      &CGM.getContext().Idents.get(ID->getObjCRuntimeNameAsString());\n  DefinedSymbols.insert(RuntimeName);\n\n  std::string ClassName = ID->getNameAsString();\n  // FIXME: Gross\n  ObjCInterfaceDecl *Interface =\n    const_cast<ObjCInterfaceDecl*>(ID->getClassInterface());\n  llvm::Constant *Protocols =\n      EmitProtocolList(\"OBJC_CLASS_PROTOCOLS_\" + ID->getName(),\n                       Interface->all_referenced_protocol_begin(),\n                       Interface->all_referenced_protocol_end());\n  unsigned Flags = FragileABI_Class_Factory;\n  if (ID->hasNonZeroConstructors() || ID->hasDestructors())\n    Flags |= FragileABI_Class_HasCXXStructors;\n\n  bool hasMRCWeak = false;\n\n  if (CGM.getLangOpts().ObjCAutoRefCount)\n    Flags |= FragileABI_Class_CompiledByARC;\n  else if ((hasMRCWeak = hasMRCWeakIvars(CGM, ID)))\n    Flags |= FragileABI_Class_HasMRCWeakIvars;\n\n  CharUnits Size =\n    CGM.getContext().getASTObjCImplementationLayout(ID).getSize();\n\n  // FIXME: Set CXX-structors flag.\n  if (ID->getClassInterface()->getVisibility() == HiddenVisibility)\n    Flags |= FragileABI_Class_Hidden;\n\n  enum {\n    InstanceMethods,\n    ClassMethods,\n    NumMethodLists\n  };\n  SmallVector<const ObjCMethodDecl *, 16> Methods[NumMethodLists];\n  for (const auto *MD : ID->methods()) {\n    if (!MD->isDirectMethod())\n      Methods[unsigned(MD->isClassMethod())].push_back(MD);\n  }\n\n  for (const auto *PID : ID->property_impls()) {\n    if (PID->getPropertyImplementation() == ObjCPropertyImplDecl::Synthesize) {\n      if (PID->getPropertyDecl()->isDirectProperty())\n        continue;\n      if (ObjCMethodDecl *MD = PID->getGetterMethodDecl())\n        if (GetMethodDefinition(MD))\n          Methods[InstanceMethods].push_back(MD);\n      if (ObjCMethodDecl *MD = PID->getSetterMethodDecl())\n        if (GetMethodDefinition(MD))\n          Methods[InstanceMethods].push_back(MD);\n    }\n  }\n\n  ConstantInitBuilder builder(CGM);\n  auto values = builder.beginStruct(ObjCTypes.ClassTy);\n  values.add(EmitMetaClass(ID, Protocols, Methods[ClassMethods]));\n  if (ObjCInterfaceDecl *Super = Interface->getSuperClass()) {\n    // Record a reference to the super class.\n    LazySymbols.insert(Super->getIdentifier());\n\n    values.addBitCast(GetClassName(Super->getObjCRuntimeNameAsString()),\n                      ObjCTypes.ClassPtrTy);\n  } else {\n    values.addNullPointer(ObjCTypes.ClassPtrTy);\n  }\n  values.add(GetClassName(ID->getObjCRuntimeNameAsString()));\n  // Version is always 0.\n  values.addInt(ObjCTypes.LongTy, 0);\n  values.addInt(ObjCTypes.LongTy, Flags);\n  values.addInt(ObjCTypes.LongTy, Size.getQuantity());\n  values.add(EmitIvarList(ID, false));\n  values.add(emitMethodList(ID->getName(), MethodListType::InstanceMethods,\n                            Methods[InstanceMethods]));\n  // cache is always NULL.\n  values.addNullPointer(ObjCTypes.CachePtrTy);\n  values.add(Protocols);\n  values.add(BuildStrongIvarLayout(ID, CharUnits::Zero(), Size));\n  values.add(EmitClassExtension(ID, Size, hasMRCWeak,\n                                /*isMetaclass*/ false));\n\n  std::string Name(\"OBJC_CLASS_\");\n  Name += ClassName;\n  const char *Section = \"__OBJC,__class,regular,no_dead_strip\";\n  // Check for a forward reference.\n  llvm::GlobalVariable *GV = CGM.getModule().getGlobalVariable(Name, true);\n  if (GV) {\n    assert(GV->getValueType() == ObjCTypes.ClassTy &&\n           \"Forward metaclass reference has incorrect type.\");\n    values.finishAndSetAsInitializer(GV);\n    GV->setSection(Section);\n    GV->setAlignment(CGM.getPointerAlign().getAsAlign());\n    CGM.addCompilerUsedGlobal(GV);\n  } else\n    GV = CreateMetadataVar(Name, values, Section, CGM.getPointerAlign(), true);\n  DefinedClasses.push_back(GV);\n  ImplementedClasses.push_back(Interface);\n  // method definition entries must be clear for next implementation.\n  MethodDefinitions.clear();\n}\n\nllvm::Constant *CGObjCMac::EmitMetaClass(const ObjCImplementationDecl *ID,\n                                         llvm::Constant *Protocols,\n                                ArrayRef<const ObjCMethodDecl*> Methods) {\n  unsigned Flags = FragileABI_Class_Meta;\n  unsigned Size = CGM.getDataLayout().getTypeAllocSize(ObjCTypes.ClassTy);\n\n  if (ID->getClassInterface()->getVisibility() == HiddenVisibility)\n    Flags |= FragileABI_Class_Hidden;\n\n  ConstantInitBuilder builder(CGM);\n  auto values = builder.beginStruct(ObjCTypes.ClassTy);\n  // The isa for the metaclass is the root of the hierarchy.\n  const ObjCInterfaceDecl *Root = ID->getClassInterface();\n  while (const ObjCInterfaceDecl *Super = Root->getSuperClass())\n    Root = Super;\n  values.addBitCast(GetClassName(Root->getObjCRuntimeNameAsString()),\n                    ObjCTypes.ClassPtrTy);\n  // The super class for the metaclass is emitted as the name of the\n  // super class. The runtime fixes this up to point to the\n  // *metaclass* for the super class.\n  if (ObjCInterfaceDecl *Super = ID->getClassInterface()->getSuperClass()) {\n    values.addBitCast(GetClassName(Super->getObjCRuntimeNameAsString()),\n                      ObjCTypes.ClassPtrTy);\n  } else {\n    values.addNullPointer(ObjCTypes.ClassPtrTy);\n  }\n  values.add(GetClassName(ID->getObjCRuntimeNameAsString()));\n  // Version is always 0.\n  values.addInt(ObjCTypes.LongTy, 0);\n  values.addInt(ObjCTypes.LongTy, Flags);\n  values.addInt(ObjCTypes.LongTy, Size);\n  values.add(EmitIvarList(ID, true));\n  values.add(emitMethodList(ID->getName(), MethodListType::ClassMethods,\n                            Methods));\n  // cache is always NULL.\n  values.addNullPointer(ObjCTypes.CachePtrTy);\n  values.add(Protocols);\n  // ivar_layout for metaclass is always NULL.\n  values.addNullPointer(ObjCTypes.Int8PtrTy);\n  // The class extension is used to store class properties for metaclasses.\n  values.add(EmitClassExtension(ID, CharUnits::Zero(), false/*hasMRCWeak*/,\n                                /*isMetaclass*/true));\n\n  std::string Name(\"OBJC_METACLASS_\");\n  Name += ID->getName();\n\n  // Check for a forward reference.\n  llvm::GlobalVariable *GV = CGM.getModule().getGlobalVariable(Name, true);\n  if (GV) {\n    assert(GV->getValueType() == ObjCTypes.ClassTy &&\n           \"Forward metaclass reference has incorrect type.\");\n    values.finishAndSetAsInitializer(GV);\n  } else {\n    GV = values.finishAndCreateGlobal(Name, CGM.getPointerAlign(),\n                                      /*constant*/ false,\n                                      llvm::GlobalValue::PrivateLinkage);\n  }\n  GV->setSection(\"__OBJC,__meta_class,regular,no_dead_strip\");\n  CGM.addCompilerUsedGlobal(GV);\n\n  return GV;\n}\n\nllvm::Constant *CGObjCMac::EmitMetaClassRef(const ObjCInterfaceDecl *ID) {\n  std::string Name = \"OBJC_METACLASS_\" + ID->getNameAsString();\n\n  // FIXME: Should we look these up somewhere other than the module. Its a bit\n  // silly since we only generate these while processing an implementation, so\n  // exactly one pointer would work if know when we entered/exitted an\n  // implementation block.\n\n  // Check for an existing forward reference.\n  // Previously, metaclass with internal linkage may have been defined.\n  // pass 'true' as 2nd argument so it is returned.\n  llvm::GlobalVariable *GV = CGM.getModule().getGlobalVariable(Name, true);\n  if (!GV)\n    GV = new llvm::GlobalVariable(CGM.getModule(), ObjCTypes.ClassTy, false,\n                                  llvm::GlobalValue::PrivateLinkage, nullptr,\n                                  Name);\n\n  assert(GV->getValueType() == ObjCTypes.ClassTy &&\n         \"Forward metaclass reference has incorrect type.\");\n  return GV;\n}\n\nllvm::Value *CGObjCMac::EmitSuperClassRef(const ObjCInterfaceDecl *ID) {\n  std::string Name = \"OBJC_CLASS_\" + ID->getNameAsString();\n  llvm::GlobalVariable *GV = CGM.getModule().getGlobalVariable(Name, true);\n\n  if (!GV)\n    GV = new llvm::GlobalVariable(CGM.getModule(), ObjCTypes.ClassTy, false,\n                                  llvm::GlobalValue::PrivateLinkage, nullptr,\n                                  Name);\n\n  assert(GV->getValueType() == ObjCTypes.ClassTy &&\n         \"Forward class metadata reference has incorrect type.\");\n  return GV;\n}\n\n/*\n  Emit a \"class extension\", which in this specific context means extra\n  data that doesn't fit in the normal fragile-ABI class structure, and\n  has nothing to do with the language concept of a class extension.\n\n  struct objc_class_ext {\n  uint32_t size;\n  const char *weak_ivar_layout;\n  struct _objc_property_list *properties;\n  };\n*/\nllvm::Constant *\nCGObjCMac::EmitClassExtension(const ObjCImplementationDecl *ID,\n                              CharUnits InstanceSize, bool hasMRCWeakIvars,\n                              bool isMetaclass) {\n  // Weak ivar layout.\n  llvm::Constant *layout;\n  if (isMetaclass) {\n    layout = llvm::ConstantPointerNull::get(CGM.Int8PtrTy);\n  } else {\n    layout = BuildWeakIvarLayout(ID, CharUnits::Zero(), InstanceSize,\n                                 hasMRCWeakIvars);\n  }\n\n  // Properties.\n  llvm::Constant *propertyList =\n    EmitPropertyList((isMetaclass ? Twine(\"_OBJC_$_CLASS_PROP_LIST_\")\n                                  : Twine(\"_OBJC_$_PROP_LIST_\"))\n                        + ID->getName(),\n                     ID, ID->getClassInterface(), ObjCTypes, isMetaclass);\n\n  // Return null if no extension bits are used.\n  if (layout->isNullValue() && propertyList->isNullValue()) {\n    return llvm::Constant::getNullValue(ObjCTypes.ClassExtensionPtrTy);\n  }\n\n  uint64_t size =\n    CGM.getDataLayout().getTypeAllocSize(ObjCTypes.ClassExtensionTy);\n\n  ConstantInitBuilder builder(CGM);\n  auto values = builder.beginStruct(ObjCTypes.ClassExtensionTy);\n  values.addInt(ObjCTypes.IntTy, size);\n  values.add(layout);\n  values.add(propertyList);\n\n  return CreateMetadataVar(\"OBJC_CLASSEXT_\" + ID->getName(), values,\n                           \"__OBJC,__class_ext,regular,no_dead_strip\",\n                           CGM.getPointerAlign(), true);\n}\n\n/*\n  struct objc_ivar {\n    char *ivar_name;\n    char *ivar_type;\n    int ivar_offset;\n  };\n\n  struct objc_ivar_list {\n    int ivar_count;\n    struct objc_ivar list[count];\n  };\n*/\nllvm::Constant *CGObjCMac::EmitIvarList(const ObjCImplementationDecl *ID,\n                                        bool ForClass) {\n  // When emitting the root class GCC emits ivar entries for the\n  // actual class structure. It is not clear if we need to follow this\n  // behavior; for now lets try and get away with not doing it. If so,\n  // the cleanest solution would be to make up an ObjCInterfaceDecl\n  // for the class.\n  if (ForClass)\n    return llvm::Constant::getNullValue(ObjCTypes.IvarListPtrTy);\n\n  const ObjCInterfaceDecl *OID = ID->getClassInterface();\n\n  ConstantInitBuilder builder(CGM);\n  auto ivarList = builder.beginStruct();\n  auto countSlot = ivarList.addPlaceholder();\n  auto ivars = ivarList.beginArray(ObjCTypes.IvarTy);\n\n  for (const ObjCIvarDecl *IVD = OID->all_declared_ivar_begin();\n       IVD; IVD = IVD->getNextIvar()) {\n    // Ignore unnamed bit-fields.\n    if (!IVD->getDeclName())\n      continue;\n\n    auto ivar = ivars.beginStruct(ObjCTypes.IvarTy);\n    ivar.add(GetMethodVarName(IVD->getIdentifier()));\n    ivar.add(GetMethodVarType(IVD));\n    ivar.addInt(ObjCTypes.IntTy, ComputeIvarBaseOffset(CGM, OID, IVD));\n    ivar.finishAndAddTo(ivars);\n  }\n\n  // Return null for empty list.\n  auto count = ivars.size();\n  if (count == 0) {\n    ivars.abandon();\n    ivarList.abandon();\n    return llvm::Constant::getNullValue(ObjCTypes.IvarListPtrTy);\n  }\n\n  ivars.finishAndAddTo(ivarList);\n  ivarList.fillPlaceholderWithInt(countSlot, ObjCTypes.IntTy, count);\n\n  llvm::GlobalVariable *GV;\n  if (ForClass)\n    GV =\n        CreateMetadataVar(\"OBJC_CLASS_VARIABLES_\" + ID->getName(), ivarList,\n                          \"__OBJC,__class_vars,regular,no_dead_strip\",\n                          CGM.getPointerAlign(), true);\n  else\n    GV = CreateMetadataVar(\"OBJC_INSTANCE_VARIABLES_\" + ID->getName(), ivarList,\n                           \"__OBJC,__instance_vars,regular,no_dead_strip\",\n                           CGM.getPointerAlign(), true);\n  return llvm::ConstantExpr::getBitCast(GV, ObjCTypes.IvarListPtrTy);\n}\n\n/// Build a struct objc_method_description constant for the given method.\n///\n/// struct objc_method_description {\n///   SEL method_name;\n///   char *method_types;\n/// };\nvoid CGObjCMac::emitMethodDescriptionConstant(ConstantArrayBuilder &builder,\n                                              const ObjCMethodDecl *MD) {\n  auto description = builder.beginStruct(ObjCTypes.MethodDescriptionTy);\n  description.addBitCast(GetMethodVarName(MD->getSelector()),\n                         ObjCTypes.SelectorPtrTy);\n  description.add(GetMethodVarType(MD));\n  description.finishAndAddTo(builder);\n}\n\n/// Build a struct objc_method constant for the given method.\n///\n/// struct objc_method {\n///   SEL method_name;\n///   char *method_types;\n///   void *method;\n/// };\nvoid CGObjCMac::emitMethodConstant(ConstantArrayBuilder &builder,\n                                   const ObjCMethodDecl *MD) {\n  llvm::Function *fn = GetMethodDefinition(MD);\n  assert(fn && \"no definition registered for method\");\n\n  auto method = builder.beginStruct(ObjCTypes.MethodTy);\n  method.addBitCast(GetMethodVarName(MD->getSelector()),\n                    ObjCTypes.SelectorPtrTy);\n  method.add(GetMethodVarType(MD));\n  method.addBitCast(fn, ObjCTypes.Int8PtrTy);\n  method.finishAndAddTo(builder);\n}\n\n/// Build a struct objc_method_list or struct objc_method_description_list,\n/// as appropriate.\n///\n/// struct objc_method_list {\n///   struct objc_method_list *obsolete;\n///   int count;\n///   struct objc_method methods_list[count];\n/// };\n///\n/// struct objc_method_description_list {\n///   int count;\n///   struct objc_method_description list[count];\n/// };\nllvm::Constant *CGObjCMac::emitMethodList(Twine name, MethodListType MLT,\n                                 ArrayRef<const ObjCMethodDecl *> methods) {\n  StringRef prefix;\n  StringRef section;\n  bool forProtocol = false;\n  switch (MLT) {\n  case MethodListType::CategoryInstanceMethods:\n    prefix = \"OBJC_CATEGORY_INSTANCE_METHODS_\";\n    section = \"__OBJC,__cat_inst_meth,regular,no_dead_strip\";\n    forProtocol = false;\n    break;\n  case MethodListType::CategoryClassMethods:\n    prefix = \"OBJC_CATEGORY_CLASS_METHODS_\";\n    section = \"__OBJC,__cat_cls_meth,regular,no_dead_strip\";\n    forProtocol = false;\n    break;\n  case MethodListType::InstanceMethods:\n    prefix = \"OBJC_INSTANCE_METHODS_\";\n    section = \"__OBJC,__inst_meth,regular,no_dead_strip\";\n    forProtocol = false;\n    break;\n  case MethodListType::ClassMethods:\n    prefix = \"OBJC_CLASS_METHODS_\";\n    section = \"__OBJC,__cls_meth,regular,no_dead_strip\";\n    forProtocol = false;\n    break;\n  case MethodListType::ProtocolInstanceMethods:\n    prefix = \"OBJC_PROTOCOL_INSTANCE_METHODS_\";\n    section = \"__OBJC,__cat_inst_meth,regular,no_dead_strip\";\n    forProtocol = true;\n    break;\n  case MethodListType::ProtocolClassMethods:\n    prefix = \"OBJC_PROTOCOL_CLASS_METHODS_\";\n    section = \"__OBJC,__cat_cls_meth,regular,no_dead_strip\";\n    forProtocol = true;\n    break;\n  case MethodListType::OptionalProtocolInstanceMethods:\n    prefix = \"OBJC_PROTOCOL_INSTANCE_METHODS_OPT_\";\n    section = \"__OBJC,__cat_inst_meth,regular,no_dead_strip\";\n    forProtocol = true;\n    break;\n  case MethodListType::OptionalProtocolClassMethods:\n    prefix = \"OBJC_PROTOCOL_CLASS_METHODS_OPT_\";\n    section = \"__OBJC,__cat_cls_meth,regular,no_dead_strip\";\n    forProtocol = true;\n    break;\n  }\n\n  // Return null for empty list.\n  if (methods.empty())\n    return llvm::Constant::getNullValue(forProtocol\n                                        ? ObjCTypes.MethodDescriptionListPtrTy\n                                        : ObjCTypes.MethodListPtrTy);\n\n  // For protocols, this is an objc_method_description_list, which has\n  // a slightly different structure.\n  if (forProtocol) {\n    ConstantInitBuilder builder(CGM);\n    auto values = builder.beginStruct();\n    values.addInt(ObjCTypes.IntTy, methods.size());\n    auto methodArray = values.beginArray(ObjCTypes.MethodDescriptionTy);\n    for (auto MD : methods) {\n      emitMethodDescriptionConstant(methodArray, MD);\n    }\n    methodArray.finishAndAddTo(values);\n\n    llvm::GlobalVariable *GV = CreateMetadataVar(prefix + name, values, section,\n                                                 CGM.getPointerAlign(), true);\n    return llvm::ConstantExpr::getBitCast(GV,\n                                          ObjCTypes.MethodDescriptionListPtrTy);\n  }\n\n  // Otherwise, it's an objc_method_list.\n  ConstantInitBuilder builder(CGM);\n  auto values = builder.beginStruct();\n  values.addNullPointer(ObjCTypes.Int8PtrTy);\n  values.addInt(ObjCTypes.IntTy, methods.size());\n  auto methodArray = values.beginArray(ObjCTypes.MethodTy);\n  for (auto MD : methods) {\n    if (!MD->isDirectMethod())\n      emitMethodConstant(methodArray, MD);\n  }\n  methodArray.finishAndAddTo(values);\n\n  llvm::GlobalVariable *GV = CreateMetadataVar(prefix + name, values, section,\n                                               CGM.getPointerAlign(), true);\n  return llvm::ConstantExpr::getBitCast(GV, ObjCTypes.MethodListPtrTy);\n}\n\nllvm::Function *CGObjCCommonMac::GenerateMethod(const ObjCMethodDecl *OMD,\n                                                const ObjCContainerDecl *CD) {\n  llvm::Function *Method;\n\n  if (OMD->isDirectMethod()) {\n    Method = GenerateDirectMethod(OMD, CD);\n  } else {\n    auto Name = getSymbolNameForMethod(OMD);\n\n    CodeGenTypes &Types = CGM.getTypes();\n    llvm::FunctionType *MethodTy =\n        Types.GetFunctionType(Types.arrangeObjCMethodDeclaration(OMD));\n    Method =\n        llvm::Function::Create(MethodTy, llvm::GlobalValue::InternalLinkage,\n                               Name, &CGM.getModule());\n  }\n\n  MethodDefinitions.insert(std::make_pair(OMD, Method));\n\n  return Method;\n}\n\nllvm::Function *\nCGObjCCommonMac::GenerateDirectMethod(const ObjCMethodDecl *OMD,\n                                      const ObjCContainerDecl *CD) {\n  auto *COMD = OMD->getCanonicalDecl();\n  auto I = DirectMethodDefinitions.find(COMD);\n  llvm::Function *OldFn = nullptr, *Fn = nullptr;\n\n  if (I != DirectMethodDefinitions.end()) {\n    // Objective-C allows for the declaration and implementation types\n    // to differ slightly.\n    //\n    // If we're being asked for the Function associated for a method\n    // implementation, a previous value might have been cached\n    // based on the type of the canonical declaration.\n    //\n    // If these do not match, then we'll replace this function with\n    // a new one that has the proper type below.\n    if (!OMD->getBody() || COMD->getReturnType() == OMD->getReturnType())\n      return I->second;\n    OldFn = I->second;\n  }\n\n  CodeGenTypes &Types = CGM.getTypes();\n  llvm::FunctionType *MethodTy =\n    Types.GetFunctionType(Types.arrangeObjCMethodDeclaration(OMD));\n\n  if (OldFn) {\n    Fn = llvm::Function::Create(MethodTy, llvm::GlobalValue::ExternalLinkage,\n                                \"\", &CGM.getModule());\n    Fn->takeName(OldFn);\n    OldFn->replaceAllUsesWith(\n        llvm::ConstantExpr::getBitCast(Fn, OldFn->getType()));\n    OldFn->eraseFromParent();\n\n    // Replace the cached function in the map.\n    I->second = Fn;\n  } else {\n    auto Name = getSymbolNameForMethod(OMD, /*include category*/ false);\n\n    Fn = llvm::Function::Create(MethodTy, llvm::GlobalValue::ExternalLinkage,\n                                Name, &CGM.getModule());\n    DirectMethodDefinitions.insert(std::make_pair(COMD, Fn));\n  }\n\n  return Fn;\n}\n\nvoid CGObjCCommonMac::GenerateDirectMethodPrologue(\n    CodeGenFunction &CGF, llvm::Function *Fn, const ObjCMethodDecl *OMD,\n    const ObjCContainerDecl *CD) {\n  auto &Builder = CGF.Builder;\n  bool ReceiverCanBeNull = true;\n  auto selfAddr = CGF.GetAddrOfLocalVar(OMD->getSelfDecl());\n  auto selfValue = Builder.CreateLoad(selfAddr);\n\n  // Generate:\n  //\n  // /* for class methods only to force class lazy initialization */\n  // self = [self self];\n  //\n  // /* unless the receiver is never NULL */\n  // if (self == nil) {\n  //     return (ReturnType){ };\n  // }\n  //\n  // _cmd = @selector(...)\n  // ...\n\n  if (OMD->isClassMethod()) {\n    const ObjCInterfaceDecl *OID = cast<ObjCInterfaceDecl>(CD);\n    assert(OID &&\n           \"GenerateDirectMethod() should be called with the Class Interface\");\n    Selector SelfSel = GetNullarySelector(\"self\", CGM.getContext());\n    auto ResultType = CGF.getContext().getObjCIdType();\n    RValue result;\n    CallArgList Args;\n\n    // TODO: If this method is inlined, the caller might know that `self` is\n    // already initialized; for example, it might be an ordinary Objective-C\n    // method which always receives an initialized `self`, or it might have just\n    // forced initialization on its own.\n    //\n    // We should find a way to eliminate this unnecessary initialization in such\n    // cases in LLVM.\n    result = GeneratePossiblySpecializedMessageSend(\n        CGF, ReturnValueSlot(), ResultType, SelfSel, selfValue, Args, OID,\n        nullptr, true);\n    Builder.CreateStore(result.getScalarVal(), selfAddr);\n\n    // Nullable `Class` expressions cannot be messaged with a direct method\n    // so the only reason why the receive can be null would be because\n    // of weak linking.\n    ReceiverCanBeNull = isWeakLinkedClass(OID);\n  }\n\n  if (ReceiverCanBeNull) {\n    llvm::BasicBlock *SelfIsNilBlock =\n        CGF.createBasicBlock(\"objc_direct_method.self_is_nil\");\n    llvm::BasicBlock *ContBlock =\n        CGF.createBasicBlock(\"objc_direct_method.cont\");\n\n    // if (self == nil) {\n    auto selfTy = cast<llvm::PointerType>(selfValue->getType());\n    auto Zero = llvm::ConstantPointerNull::get(selfTy);\n\n    llvm::MDBuilder MDHelper(CGM.getLLVMContext());\n    Builder.CreateCondBr(Builder.CreateICmpEQ(selfValue, Zero), SelfIsNilBlock,\n                         ContBlock, MDHelper.createBranchWeights(1, 1 << 20));\n\n    CGF.EmitBlock(SelfIsNilBlock);\n\n    //   return (ReturnType){ };\n    auto retTy = OMD->getReturnType();\n    Builder.SetInsertPoint(SelfIsNilBlock);\n    if (!retTy->isVoidType()) {\n      CGF.EmitNullInitialization(CGF.ReturnValue, retTy);\n    }\n    CGF.EmitBranchThroughCleanup(CGF.ReturnBlock);\n    // }\n\n    // rest of the body\n    CGF.EmitBlock(ContBlock);\n    Builder.SetInsertPoint(ContBlock);\n  }\n\n  // only synthesize _cmd if it's referenced\n  if (OMD->getCmdDecl()->isUsed()) {\n    Builder.CreateStore(GetSelector(CGF, OMD),\n                        CGF.GetAddrOfLocalVar(OMD->getCmdDecl()));\n  }\n}\n\nllvm::GlobalVariable *CGObjCCommonMac::CreateMetadataVar(Twine Name,\n                                               ConstantStructBuilder &Init,\n                                                         StringRef Section,\n                                                         CharUnits Align,\n                                                         bool AddToUsed) {\n  llvm::GlobalValue::LinkageTypes LT =\n      getLinkageTypeForObjCMetadata(CGM, Section);\n  llvm::GlobalVariable *GV =\n      Init.finishAndCreateGlobal(Name, Align, /*constant*/ false, LT);\n  if (!Section.empty())\n    GV->setSection(Section);\n  if (AddToUsed)\n    CGM.addCompilerUsedGlobal(GV);\n  return GV;\n}\n\nllvm::GlobalVariable *CGObjCCommonMac::CreateMetadataVar(Twine Name,\n                                                         llvm::Constant *Init,\n                                                         StringRef Section,\n                                                         CharUnits Align,\n                                                         bool AddToUsed) {\n  llvm::Type *Ty = Init->getType();\n  llvm::GlobalValue::LinkageTypes LT =\n      getLinkageTypeForObjCMetadata(CGM, Section);\n  llvm::GlobalVariable *GV =\n      new llvm::GlobalVariable(CGM.getModule(), Ty, false, LT, Init, Name);\n  if (!Section.empty())\n    GV->setSection(Section);\n  GV->setAlignment(Align.getAsAlign());\n  if (AddToUsed)\n    CGM.addCompilerUsedGlobal(GV);\n  return GV;\n}\n\nllvm::GlobalVariable *\nCGObjCCommonMac::CreateCStringLiteral(StringRef Name, ObjCLabelType Type,\n                                      bool ForceNonFragileABI,\n                                      bool NullTerminate) {\n  StringRef Label;\n  switch (Type) {\n  case ObjCLabelType::ClassName:     Label = \"OBJC_CLASS_NAME_\"; break;\n  case ObjCLabelType::MethodVarName: Label = \"OBJC_METH_VAR_NAME_\"; break;\n  case ObjCLabelType::MethodVarType: Label = \"OBJC_METH_VAR_TYPE_\"; break;\n  case ObjCLabelType::PropertyName:  Label = \"OBJC_PROP_NAME_ATTR_\"; break;\n  }\n\n  bool NonFragile = ForceNonFragileABI || isNonFragileABI();\n\n  StringRef Section;\n  switch (Type) {\n  case ObjCLabelType::ClassName:\n    Section = NonFragile ? \"__TEXT,__objc_classname,cstring_literals\"\n                         : \"__TEXT,__cstring,cstring_literals\";\n    break;\n  case ObjCLabelType::MethodVarName:\n    Section = NonFragile ? \"__TEXT,__objc_methname,cstring_literals\"\n                         : \"__TEXT,__cstring,cstring_literals\";\n    break;\n  case ObjCLabelType::MethodVarType:\n    Section = NonFragile ? \"__TEXT,__objc_methtype,cstring_literals\"\n                         : \"__TEXT,__cstring,cstring_literals\";\n    break;\n  case ObjCLabelType::PropertyName:\n    Section = NonFragile ? \"__TEXT,__objc_methname,cstring_literals\"\n                         : \"__TEXT,__cstring,cstring_literals\";\n    break;\n  }\n\n  llvm::Constant *Value =\n      llvm::ConstantDataArray::getString(VMContext, Name, NullTerminate);\n  llvm::GlobalVariable *GV =\n      new llvm::GlobalVariable(CGM.getModule(), Value->getType(),\n                               /*isConstant=*/true,\n                               llvm::GlobalValue::PrivateLinkage, Value, Label);\n  if (CGM.getTriple().isOSBinFormatMachO())\n    GV->setSection(Section);\n  GV->setUnnamedAddr(llvm::GlobalValue::UnnamedAddr::Global);\n  GV->setAlignment(CharUnits::One().getAsAlign());\n  CGM.addCompilerUsedGlobal(GV);\n\n  return GV;\n}\n\nllvm::Function *CGObjCMac::ModuleInitFunction() {\n  // Abuse this interface function as a place to finalize.\n  FinishModule();\n  return nullptr;\n}\n\nllvm::FunctionCallee CGObjCMac::GetPropertyGetFunction() {\n  return ObjCTypes.getGetPropertyFn();\n}\n\nllvm::FunctionCallee CGObjCMac::GetPropertySetFunction() {\n  return ObjCTypes.getSetPropertyFn();\n}\n\nllvm::FunctionCallee CGObjCMac::GetOptimizedPropertySetFunction(bool atomic,\n                                                                bool copy) {\n  return ObjCTypes.getOptimizedSetPropertyFn(atomic, copy);\n}\n\nllvm::FunctionCallee CGObjCMac::GetGetStructFunction() {\n  return ObjCTypes.getCopyStructFn();\n}\n\nllvm::FunctionCallee CGObjCMac::GetSetStructFunction() {\n  return ObjCTypes.getCopyStructFn();\n}\n\nllvm::FunctionCallee CGObjCMac::GetCppAtomicObjectGetFunction() {\n  return ObjCTypes.getCppAtomicObjectFunction();\n}\n\nllvm::FunctionCallee CGObjCMac::GetCppAtomicObjectSetFunction() {\n  return ObjCTypes.getCppAtomicObjectFunction();\n}\n\nllvm::FunctionCallee CGObjCMac::EnumerationMutationFunction() {\n  return ObjCTypes.getEnumerationMutationFn();\n}\n\nvoid CGObjCMac::EmitTryStmt(CodeGenFunction &CGF, const ObjCAtTryStmt &S) {\n  return EmitTryOrSynchronizedStmt(CGF, S);\n}\n\nvoid CGObjCMac::EmitSynchronizedStmt(CodeGenFunction &CGF,\n                                     const ObjCAtSynchronizedStmt &S) {\n  return EmitTryOrSynchronizedStmt(CGF, S);\n}\n\nnamespace {\n  struct PerformFragileFinally final : EHScopeStack::Cleanup {\n    const Stmt &S;\n    Address SyncArgSlot;\n    Address CallTryExitVar;\n    Address ExceptionData;\n    ObjCTypesHelper &ObjCTypes;\n    PerformFragileFinally(const Stmt *S,\n                          Address SyncArgSlot,\n                          Address CallTryExitVar,\n                          Address ExceptionData,\n                          ObjCTypesHelper *ObjCTypes)\n      : S(*S), SyncArgSlot(SyncArgSlot), CallTryExitVar(CallTryExitVar),\n        ExceptionData(ExceptionData), ObjCTypes(*ObjCTypes) {}\n\n    void Emit(CodeGenFunction &CGF, Flags flags) override {\n      // Check whether we need to call objc_exception_try_exit.\n      // In optimized code, this branch will always be folded.\n      llvm::BasicBlock *FinallyCallExit =\n        CGF.createBasicBlock(\"finally.call_exit\");\n      llvm::BasicBlock *FinallyNoCallExit =\n        CGF.createBasicBlock(\"finally.no_call_exit\");\n      CGF.Builder.CreateCondBr(CGF.Builder.CreateLoad(CallTryExitVar),\n                               FinallyCallExit, FinallyNoCallExit);\n\n      CGF.EmitBlock(FinallyCallExit);\n      CGF.EmitNounwindRuntimeCall(ObjCTypes.getExceptionTryExitFn(),\n                                  ExceptionData.getPointer());\n\n      CGF.EmitBlock(FinallyNoCallExit);\n\n      if (isa<ObjCAtTryStmt>(S)) {\n        if (const ObjCAtFinallyStmt* FinallyStmt =\n              cast<ObjCAtTryStmt>(S).getFinallyStmt()) {\n          // Don't try to do the @finally if this is an EH cleanup.\n          if (flags.isForEHCleanup()) return;\n\n          // Save the current cleanup destination in case there's\n          // control flow inside the finally statement.\n          llvm::Value *CurCleanupDest =\n            CGF.Builder.CreateLoad(CGF.getNormalCleanupDestSlot());\n\n          CGF.EmitStmt(FinallyStmt->getFinallyBody());\n\n          if (CGF.HaveInsertPoint()) {\n            CGF.Builder.CreateStore(CurCleanupDest,\n                                    CGF.getNormalCleanupDestSlot());\n          } else {\n            // Currently, the end of the cleanup must always exist.\n            CGF.EnsureInsertPoint();\n          }\n        }\n      } else {\n        // Emit objc_sync_exit(expr); as finally's sole statement for\n        // @synchronized.\n        llvm::Value *SyncArg = CGF.Builder.CreateLoad(SyncArgSlot);\n        CGF.EmitNounwindRuntimeCall(ObjCTypes.getSyncExitFn(), SyncArg);\n      }\n    }\n  };\n\n  class FragileHazards {\n    CodeGenFunction &CGF;\n    SmallVector<llvm::Value*, 20> Locals;\n    llvm::DenseSet<llvm::BasicBlock*> BlocksBeforeTry;\n\n    llvm::InlineAsm *ReadHazard;\n    llvm::InlineAsm *WriteHazard;\n\n    llvm::FunctionType *GetAsmFnType();\n\n    void collectLocals();\n    void emitReadHazard(CGBuilderTy &Builder);\n\n  public:\n    FragileHazards(CodeGenFunction &CGF);\n\n    void emitWriteHazard();\n    void emitHazardsInNewBlocks();\n  };\n} // end anonymous namespace\n\n/// Create the fragile-ABI read and write hazards based on the current\n/// state of the function, which is presumed to be immediately prior\n/// to a @try block.  These hazards are used to maintain correct\n/// semantics in the face of optimization and the fragile ABI's\n/// cavalier use of setjmp/longjmp.\nFragileHazards::FragileHazards(CodeGenFunction &CGF) : CGF(CGF) {\n  collectLocals();\n\n  if (Locals.empty()) return;\n\n  // Collect all the blocks in the function.\n  for (llvm::Function::iterator\n         I = CGF.CurFn->begin(), E = CGF.CurFn->end(); I != E; ++I)\n    BlocksBeforeTry.insert(&*I);\n\n  llvm::FunctionType *AsmFnTy = GetAsmFnType();\n\n  // Create a read hazard for the allocas.  This inhibits dead-store\n  // optimizations and forces the values to memory.  This hazard is\n  // inserted before any 'throwing' calls in the protected scope to\n  // reflect the possibility that the variables might be read from the\n  // catch block if the call throws.\n  {\n    std::string Constraint;\n    for (unsigned I = 0, E = Locals.size(); I != E; ++I) {\n      if (I) Constraint += ',';\n      Constraint += \"*m\";\n    }\n\n    ReadHazard = llvm::InlineAsm::get(AsmFnTy, \"\", Constraint, true, false);\n  }\n\n  // Create a write hazard for the allocas.  This inhibits folding\n  // loads across the hazard.  This hazard is inserted at the\n  // beginning of the catch path to reflect the possibility that the\n  // variables might have been written within the protected scope.\n  {\n    std::string Constraint;\n    for (unsigned I = 0, E = Locals.size(); I != E; ++I) {\n      if (I) Constraint += ',';\n      Constraint += \"=*m\";\n    }\n\n    WriteHazard = llvm::InlineAsm::get(AsmFnTy, \"\", Constraint, true, false);\n  }\n}\n\n/// Emit a write hazard at the current location.\nvoid FragileHazards::emitWriteHazard() {\n  if (Locals.empty()) return;\n\n  CGF.EmitNounwindRuntimeCall(WriteHazard, Locals);\n}\n\nvoid FragileHazards::emitReadHazard(CGBuilderTy &Builder) {\n  assert(!Locals.empty());\n  llvm::CallInst *call = Builder.CreateCall(ReadHazard, Locals);\n  call->setDoesNotThrow();\n  call->setCallingConv(CGF.getRuntimeCC());\n}\n\n/// Emit read hazards in all the protected blocks, i.e. all the blocks\n/// which have been inserted since the beginning of the try.\nvoid FragileHazards::emitHazardsInNewBlocks() {\n  if (Locals.empty()) return;\n\n  CGBuilderTy Builder(CGF, CGF.getLLVMContext());\n\n  // Iterate through all blocks, skipping those prior to the try.\n  for (llvm::Function::iterator\n         FI = CGF.CurFn->begin(), FE = CGF.CurFn->end(); FI != FE; ++FI) {\n    llvm::BasicBlock &BB = *FI;\n    if (BlocksBeforeTry.count(&BB)) continue;\n\n    // Walk through all the calls in the block.\n    for (llvm::BasicBlock::iterator\n           BI = BB.begin(), BE = BB.end(); BI != BE; ++BI) {\n      llvm::Instruction &I = *BI;\n\n      // Ignore instructions that aren't non-intrinsic calls.\n      // These are the only calls that can possibly call longjmp.\n      if (!isa<llvm::CallInst>(I) && !isa<llvm::InvokeInst>(I))\n        continue;\n      if (isa<llvm::IntrinsicInst>(I))\n        continue;\n\n      // Ignore call sites marked nounwind.  This may be questionable,\n      // since 'nounwind' doesn't necessarily mean 'does not call longjmp'.\n      if (cast<llvm::CallBase>(I).doesNotThrow())\n        continue;\n\n      // Insert a read hazard before the call.  This will ensure that\n      // any writes to the locals are performed before making the\n      // call.  If the call throws, then this is sufficient to\n      // guarantee correctness as long as it doesn't also write to any\n      // locals.\n      Builder.SetInsertPoint(&BB, BI);\n      emitReadHazard(Builder);\n    }\n  }\n}\n\nstatic void addIfPresent(llvm::DenseSet<llvm::Value*> &S, Address V) {\n  if (V.isValid()) S.insert(V.getPointer());\n}\n\nvoid FragileHazards::collectLocals() {\n  // Compute a set of allocas to ignore.\n  llvm::DenseSet<llvm::Value*> AllocasToIgnore;\n  addIfPresent(AllocasToIgnore, CGF.ReturnValue);\n  addIfPresent(AllocasToIgnore, CGF.NormalCleanupDest);\n\n  // Collect all the allocas currently in the function.  This is\n  // probably way too aggressive.\n  llvm::BasicBlock &Entry = CGF.CurFn->getEntryBlock();\n  for (llvm::BasicBlock::iterator\n         I = Entry.begin(), E = Entry.end(); I != E; ++I)\n    if (isa<llvm::AllocaInst>(*I) && !AllocasToIgnore.count(&*I))\n      Locals.push_back(&*I);\n}\n\nllvm::FunctionType *FragileHazards::GetAsmFnType() {\n  SmallVector<llvm::Type *, 16> tys(Locals.size());\n  for (unsigned i = 0, e = Locals.size(); i != e; ++i)\n    tys[i] = Locals[i]->getType();\n  return llvm::FunctionType::get(CGF.VoidTy, tys, false);\n}\n\n/*\n\n  Objective-C setjmp-longjmp (sjlj) Exception Handling\n  --\n\n  A catch buffer is a setjmp buffer plus:\n    - a pointer to the exception that was caught\n    - a pointer to the previous exception data buffer\n    - two pointers of reserved storage\n  Therefore catch buffers form a stack, with a pointer to the top\n  of the stack kept in thread-local storage.\n\n  objc_exception_try_enter pushes a catch buffer onto the EH stack.\n  objc_exception_try_exit pops the given catch buffer, which is\n    required to be the top of the EH stack.\n  objc_exception_throw pops the top of the EH stack, writes the\n    thrown exception into the appropriate field, and longjmps\n    to the setjmp buffer.  It crashes the process (with a printf\n    and an abort()) if there are no catch buffers on the stack.\n  objc_exception_extract just reads the exception pointer out of the\n    catch buffer.\n\n  There's no reason an implementation couldn't use a light-weight\n  setjmp here --- something like __builtin_setjmp, but API-compatible\n  with the heavyweight setjmp.  This will be more important if we ever\n  want to implement correct ObjC/C++ exception interactions for the\n  fragile ABI.\n\n  Note that for this use of setjmp/longjmp to be correct, we may need\n  to mark some local variables volatile: if a non-volatile local\n  variable is modified between the setjmp and the longjmp, it has\n  indeterminate value.  For the purposes of LLVM IR, it may be\n  sufficient to make loads and stores within the @try (to variables\n  declared outside the @try) volatile.  This is necessary for\n  optimized correctness, but is not currently being done; this is\n  being tracked as rdar://problem/8160285\n\n  The basic framework for a @try-catch-finally is as follows:\n  {\n  objc_exception_data d;\n  id _rethrow = null;\n  bool _call_try_exit = true;\n\n  objc_exception_try_enter(&d);\n  if (!setjmp(d.jmp_buf)) {\n  ... try body ...\n  } else {\n  // exception path\n  id _caught = objc_exception_extract(&d);\n\n  // enter new try scope for handlers\n  if (!setjmp(d.jmp_buf)) {\n  ... match exception and execute catch blocks ...\n\n  // fell off end, rethrow.\n  _rethrow = _caught;\n  ... jump-through-finally to finally_rethrow ...\n  } else {\n  // exception in catch block\n  _rethrow = objc_exception_extract(&d);\n  _call_try_exit = false;\n  ... jump-through-finally to finally_rethrow ...\n  }\n  }\n  ... jump-through-finally to finally_end ...\n\n  finally:\n  if (_call_try_exit)\n  objc_exception_try_exit(&d);\n\n  ... finally block ....\n  ... dispatch to finally destination ...\n\n  finally_rethrow:\n  objc_exception_throw(_rethrow);\n\n  finally_end:\n  }\n\n  This framework differs slightly from the one gcc uses, in that gcc\n  uses _rethrow to determine if objc_exception_try_exit should be called\n  and if the object should be rethrown. This breaks in the face of\n  throwing nil and introduces unnecessary branches.\n\n  We specialize this framework for a few particular circumstances:\n\n  - If there are no catch blocks, then we avoid emitting the second\n  exception handling context.\n\n  - If there is a catch-all catch block (i.e. @catch(...) or @catch(id\n  e)) we avoid emitting the code to rethrow an uncaught exception.\n\n  - FIXME: If there is no @finally block we can do a few more\n  simplifications.\n\n  Rethrows and Jumps-Through-Finally\n  --\n\n  '@throw;' is supported by pushing the currently-caught exception\n  onto ObjCEHStack while the @catch blocks are emitted.\n\n  Branches through the @finally block are handled with an ordinary\n  normal cleanup.  We do not register an EH cleanup; fragile-ABI ObjC\n  exceptions are not compatible with C++ exceptions, and this is\n  hardly the only place where this will go wrong.\n\n  @synchronized(expr) { stmt; } is emitted as if it were:\n    id synch_value = expr;\n    objc_sync_enter(synch_value);\n    @try { stmt; } @finally { objc_sync_exit(synch_value); }\n*/\n\nvoid CGObjCMac::EmitTryOrSynchronizedStmt(CodeGen::CodeGenFunction &CGF,\n                                          const Stmt &S) {\n  bool isTry = isa<ObjCAtTryStmt>(S);\n\n  // A destination for the fall-through edges of the catch handlers to\n  // jump to.\n  CodeGenFunction::JumpDest FinallyEnd =\n    CGF.getJumpDestInCurrentScope(\"finally.end\");\n\n  // A destination for the rethrow edge of the catch handlers to jump\n  // to.\n  CodeGenFunction::JumpDest FinallyRethrow =\n    CGF.getJumpDestInCurrentScope(\"finally.rethrow\");\n\n  // For @synchronized, call objc_sync_enter(sync.expr). The\n  // evaluation of the expression must occur before we enter the\n  // @synchronized.  We can't avoid a temp here because we need the\n  // value to be preserved.  If the backend ever does liveness\n  // correctly after setjmp, this will be unnecessary.\n  Address SyncArgSlot = Address::invalid();\n  if (!isTry) {\n    llvm::Value *SyncArg =\n      CGF.EmitScalarExpr(cast<ObjCAtSynchronizedStmt>(S).getSynchExpr());\n    SyncArg = CGF.Builder.CreateBitCast(SyncArg, ObjCTypes.ObjectPtrTy);\n    CGF.EmitNounwindRuntimeCall(ObjCTypes.getSyncEnterFn(), SyncArg);\n\n    SyncArgSlot = CGF.CreateTempAlloca(SyncArg->getType(),\n                                       CGF.getPointerAlign(), \"sync.arg\");\n    CGF.Builder.CreateStore(SyncArg, SyncArgSlot);\n  }\n\n  // Allocate memory for the setjmp buffer.  This needs to be kept\n  // live throughout the try and catch blocks.\n  Address ExceptionData = CGF.CreateTempAlloca(ObjCTypes.ExceptionDataTy,\n                                               CGF.getPointerAlign(),\n                                               \"exceptiondata.ptr\");\n\n  // Create the fragile hazards.  Note that this will not capture any\n  // of the allocas required for exception processing, but will\n  // capture the current basic block (which extends all the way to the\n  // setjmp call) as \"before the @try\".\n  FragileHazards Hazards(CGF);\n\n  // Create a flag indicating whether the cleanup needs to call\n  // objc_exception_try_exit.  This is true except when\n  //   - no catches match and we're branching through the cleanup\n  //     just to rethrow the exception, or\n  //   - a catch matched and we're falling out of the catch handler.\n  // The setjmp-safety rule here is that we should always store to this\n  // variable in a place that dominates the branch through the cleanup\n  // without passing through any setjmps.\n  Address CallTryExitVar = CGF.CreateTempAlloca(CGF.Builder.getInt1Ty(),\n                                                CharUnits::One(),\n                                                \"_call_try_exit\");\n\n  // A slot containing the exception to rethrow.  Only needed when we\n  // have both a @catch and a @finally.\n  Address PropagatingExnVar = Address::invalid();\n\n  // Push a normal cleanup to leave the try scope.\n  CGF.EHStack.pushCleanup<PerformFragileFinally>(NormalAndEHCleanup, &S,\n                                                 SyncArgSlot,\n                                                 CallTryExitVar,\n                                                 ExceptionData,\n                                                 &ObjCTypes);\n\n  // Enter a try block:\n  //  - Call objc_exception_try_enter to push ExceptionData on top of\n  //    the EH stack.\n  CGF.EmitNounwindRuntimeCall(ObjCTypes.getExceptionTryEnterFn(),\n                              ExceptionData.getPointer());\n\n  //  - Call setjmp on the exception data buffer.\n  llvm::Constant *Zero = llvm::ConstantInt::get(CGF.Builder.getInt32Ty(), 0);\n  llvm::Value *GEPIndexes[] = { Zero, Zero, Zero };\n  llvm::Value *SetJmpBuffer = CGF.Builder.CreateGEP(\n      ObjCTypes.ExceptionDataTy, ExceptionData.getPointer(), GEPIndexes,\n      \"setjmp_buffer\");\n  llvm::CallInst *SetJmpResult = CGF.EmitNounwindRuntimeCall(\n      ObjCTypes.getSetJmpFn(), SetJmpBuffer, \"setjmp_result\");\n  SetJmpResult->setCanReturnTwice();\n\n  // If setjmp returned 0, enter the protected block; otherwise,\n  // branch to the handler.\n  llvm::BasicBlock *TryBlock = CGF.createBasicBlock(\"try\");\n  llvm::BasicBlock *TryHandler = CGF.createBasicBlock(\"try.handler\");\n  llvm::Value *DidCatch =\n    CGF.Builder.CreateIsNotNull(SetJmpResult, \"did_catch_exception\");\n  CGF.Builder.CreateCondBr(DidCatch, TryHandler, TryBlock);\n\n  // Emit the protected block.\n  CGF.EmitBlock(TryBlock);\n  CGF.Builder.CreateStore(CGF.Builder.getTrue(), CallTryExitVar);\n  CGF.EmitStmt(isTry ? cast<ObjCAtTryStmt>(S).getTryBody()\n                     : cast<ObjCAtSynchronizedStmt>(S).getSynchBody());\n\n  CGBuilderTy::InsertPoint TryFallthroughIP = CGF.Builder.saveAndClearIP();\n\n  // Emit the exception handler block.\n  CGF.EmitBlock(TryHandler);\n\n  // Don't optimize loads of the in-scope locals across this point.\n  Hazards.emitWriteHazard();\n\n  // For a @synchronized (or a @try with no catches), just branch\n  // through the cleanup to the rethrow block.\n  if (!isTry || !cast<ObjCAtTryStmt>(S).getNumCatchStmts()) {\n    // Tell the cleanup not to re-pop the exit.\n    CGF.Builder.CreateStore(CGF.Builder.getFalse(), CallTryExitVar);\n    CGF.EmitBranchThroughCleanup(FinallyRethrow);\n\n  // Otherwise, we have to match against the caught exceptions.\n  } else {\n    // Retrieve the exception object.  We may emit multiple blocks but\n    // nothing can cross this so the value is already in SSA form.\n    llvm::CallInst *Caught =\n      CGF.EmitNounwindRuntimeCall(ObjCTypes.getExceptionExtractFn(),\n                                  ExceptionData.getPointer(), \"caught\");\n\n    // Push the exception to rethrow onto the EH value stack for the\n    // benefit of any @throws in the handlers.\n    CGF.ObjCEHValueStack.push_back(Caught);\n\n    const ObjCAtTryStmt* AtTryStmt = cast<ObjCAtTryStmt>(&S);\n\n    bool HasFinally = (AtTryStmt->getFinallyStmt() != nullptr);\n\n    llvm::BasicBlock *CatchBlock = nullptr;\n    llvm::BasicBlock *CatchHandler = nullptr;\n    if (HasFinally) {\n      // Save the currently-propagating exception before\n      // objc_exception_try_enter clears the exception slot.\n      PropagatingExnVar = CGF.CreateTempAlloca(Caught->getType(),\n                                               CGF.getPointerAlign(),\n                                               \"propagating_exception\");\n      CGF.Builder.CreateStore(Caught, PropagatingExnVar);\n\n      // Enter a new exception try block (in case a @catch block\n      // throws an exception).\n      CGF.EmitNounwindRuntimeCall(ObjCTypes.getExceptionTryEnterFn(),\n                                  ExceptionData.getPointer());\n\n      llvm::CallInst *SetJmpResult =\n        CGF.EmitNounwindRuntimeCall(ObjCTypes.getSetJmpFn(),\n                                    SetJmpBuffer, \"setjmp.result\");\n      SetJmpResult->setCanReturnTwice();\n\n      llvm::Value *Threw =\n        CGF.Builder.CreateIsNotNull(SetJmpResult, \"did_catch_exception\");\n\n      CatchBlock = CGF.createBasicBlock(\"catch\");\n      CatchHandler = CGF.createBasicBlock(\"catch_for_catch\");\n      CGF.Builder.CreateCondBr(Threw, CatchHandler, CatchBlock);\n\n      CGF.EmitBlock(CatchBlock);\n    }\n\n    CGF.Builder.CreateStore(CGF.Builder.getInt1(HasFinally), CallTryExitVar);\n\n    // Handle catch list. As a special case we check if everything is\n    // matched and avoid generating code for falling off the end if\n    // so.\n    bool AllMatched = false;\n    for (unsigned I = 0, N = AtTryStmt->getNumCatchStmts(); I != N; ++I) {\n      const ObjCAtCatchStmt *CatchStmt = AtTryStmt->getCatchStmt(I);\n\n      const VarDecl *CatchParam = CatchStmt->getCatchParamDecl();\n      const ObjCObjectPointerType *OPT = nullptr;\n\n      // catch(...) always matches.\n      if (!CatchParam) {\n        AllMatched = true;\n      } else {\n        OPT = CatchParam->getType()->getAs<ObjCObjectPointerType>();\n\n        // catch(id e) always matches under this ABI, since only\n        // ObjC exceptions end up here in the first place.\n        // FIXME: For the time being we also match id<X>; this should\n        // be rejected by Sema instead.\n        if (OPT && (OPT->isObjCIdType() || OPT->isObjCQualifiedIdType()))\n          AllMatched = true;\n      }\n\n      // If this is a catch-all, we don't need to test anything.\n      if (AllMatched) {\n        CodeGenFunction::RunCleanupsScope CatchVarCleanups(CGF);\n\n        if (CatchParam) {\n          CGF.EmitAutoVarDecl(*CatchParam);\n          assert(CGF.HaveInsertPoint() && \"DeclStmt destroyed insert point?\");\n\n          // These types work out because ConvertType(id) == i8*.\n          EmitInitOfCatchParam(CGF, Caught, CatchParam);\n        }\n\n        CGF.EmitStmt(CatchStmt->getCatchBody());\n\n        // The scope of the catch variable ends right here.\n        CatchVarCleanups.ForceCleanup();\n\n        CGF.EmitBranchThroughCleanup(FinallyEnd);\n        break;\n      }\n\n      assert(OPT && \"Unexpected non-object pointer type in @catch\");\n      const ObjCObjectType *ObjTy = OPT->getObjectType();\n\n      // FIXME: @catch (Class c) ?\n      ObjCInterfaceDecl *IDecl = ObjTy->getInterface();\n      assert(IDecl && \"Catch parameter must have Objective-C type!\");\n\n      // Check if the @catch block matches the exception object.\n      llvm::Value *Class = EmitClassRef(CGF, IDecl);\n\n      llvm::Value *matchArgs[] = { Class, Caught };\n      llvm::CallInst *Match =\n        CGF.EmitNounwindRuntimeCall(ObjCTypes.getExceptionMatchFn(),\n                                    matchArgs, \"match\");\n\n      llvm::BasicBlock *MatchedBlock = CGF.createBasicBlock(\"match\");\n      llvm::BasicBlock *NextCatchBlock = CGF.createBasicBlock(\"catch.next\");\n\n      CGF.Builder.CreateCondBr(CGF.Builder.CreateIsNotNull(Match, \"matched\"),\n                               MatchedBlock, NextCatchBlock);\n\n      // Emit the @catch block.\n      CGF.EmitBlock(MatchedBlock);\n\n      // Collect any cleanups for the catch variable.  The scope lasts until\n      // the end of the catch body.\n      CodeGenFunction::RunCleanupsScope CatchVarCleanups(CGF);\n\n      CGF.EmitAutoVarDecl(*CatchParam);\n      assert(CGF.HaveInsertPoint() && \"DeclStmt destroyed insert point?\");\n\n      // Initialize the catch variable.\n      llvm::Value *Tmp =\n        CGF.Builder.CreateBitCast(Caught,\n                                  CGF.ConvertType(CatchParam->getType()));\n      EmitInitOfCatchParam(CGF, Tmp, CatchParam);\n\n      CGF.EmitStmt(CatchStmt->getCatchBody());\n\n      // We're done with the catch variable.\n      CatchVarCleanups.ForceCleanup();\n\n      CGF.EmitBranchThroughCleanup(FinallyEnd);\n\n      CGF.EmitBlock(NextCatchBlock);\n    }\n\n    CGF.ObjCEHValueStack.pop_back();\n\n    // If nothing wanted anything to do with the caught exception,\n    // kill the extract call.\n    if (Caught->use_empty())\n      Caught->eraseFromParent();\n\n    if (!AllMatched)\n      CGF.EmitBranchThroughCleanup(FinallyRethrow);\n\n    if (HasFinally) {\n      // Emit the exception handler for the @catch blocks.\n      CGF.EmitBlock(CatchHandler);\n\n      // In theory we might now need a write hazard, but actually it's\n      // unnecessary because there's no local-accessing code between\n      // the try's write hazard and here.\n      //Hazards.emitWriteHazard();\n\n      // Extract the new exception and save it to the\n      // propagating-exception slot.\n      assert(PropagatingExnVar.isValid());\n      llvm::CallInst *NewCaught =\n        CGF.EmitNounwindRuntimeCall(ObjCTypes.getExceptionExtractFn(),\n                                    ExceptionData.getPointer(), \"caught\");\n      CGF.Builder.CreateStore(NewCaught, PropagatingExnVar);\n\n      // Don't pop the catch handler; the throw already did.\n      CGF.Builder.CreateStore(CGF.Builder.getFalse(), CallTryExitVar);\n      CGF.EmitBranchThroughCleanup(FinallyRethrow);\n    }\n  }\n\n  // Insert read hazards as required in the new blocks.\n  Hazards.emitHazardsInNewBlocks();\n\n  // Pop the cleanup.\n  CGF.Builder.restoreIP(TryFallthroughIP);\n  if (CGF.HaveInsertPoint())\n    CGF.Builder.CreateStore(CGF.Builder.getTrue(), CallTryExitVar);\n  CGF.PopCleanupBlock();\n  CGF.EmitBlock(FinallyEnd.getBlock(), true);\n\n  // Emit the rethrow block.\n  CGBuilderTy::InsertPoint SavedIP = CGF.Builder.saveAndClearIP();\n  CGF.EmitBlock(FinallyRethrow.getBlock(), true);\n  if (CGF.HaveInsertPoint()) {\n    // If we have a propagating-exception variable, check it.\n    llvm::Value *PropagatingExn;\n    if (PropagatingExnVar.isValid()) {\n      PropagatingExn = CGF.Builder.CreateLoad(PropagatingExnVar);\n\n    // Otherwise, just look in the buffer for the exception to throw.\n    } else {\n      llvm::CallInst *Caught =\n        CGF.EmitNounwindRuntimeCall(ObjCTypes.getExceptionExtractFn(),\n                                    ExceptionData.getPointer());\n      PropagatingExn = Caught;\n    }\n\n    CGF.EmitNounwindRuntimeCall(ObjCTypes.getExceptionThrowFn(),\n                                PropagatingExn);\n    CGF.Builder.CreateUnreachable();\n  }\n\n  CGF.Builder.restoreIP(SavedIP);\n}\n\nvoid CGObjCMac::EmitThrowStmt(CodeGen::CodeGenFunction &CGF,\n                              const ObjCAtThrowStmt &S,\n                              bool ClearInsertionPoint) {\n  llvm::Value *ExceptionAsObject;\n\n  if (const Expr *ThrowExpr = S.getThrowExpr()) {\n    llvm::Value *Exception = CGF.EmitObjCThrowOperand(ThrowExpr);\n    ExceptionAsObject =\n      CGF.Builder.CreateBitCast(Exception, ObjCTypes.ObjectPtrTy);\n  } else {\n    assert((!CGF.ObjCEHValueStack.empty() && CGF.ObjCEHValueStack.back()) &&\n           \"Unexpected rethrow outside @catch block.\");\n    ExceptionAsObject = CGF.ObjCEHValueStack.back();\n  }\n\n  CGF.EmitRuntimeCall(ObjCTypes.getExceptionThrowFn(), ExceptionAsObject)\n    ->setDoesNotReturn();\n  CGF.Builder.CreateUnreachable();\n\n  // Clear the insertion point to indicate we are in unreachable code.\n  if (ClearInsertionPoint)\n    CGF.Builder.ClearInsertionPoint();\n}\n\n/// EmitObjCWeakRead - Code gen for loading value of a __weak\n/// object: objc_read_weak (id *src)\n///\nllvm::Value * CGObjCMac::EmitObjCWeakRead(CodeGen::CodeGenFunction &CGF,\n                                          Address AddrWeakObj) {\n  llvm::Type* DestTy = AddrWeakObj.getElementType();\n  AddrWeakObj = CGF.Builder.CreateBitCast(AddrWeakObj,\n                                          ObjCTypes.PtrObjectPtrTy);\n  llvm::Value *read_weak =\n    CGF.EmitNounwindRuntimeCall(ObjCTypes.getGcReadWeakFn(),\n                                AddrWeakObj.getPointer(), \"weakread\");\n  read_weak = CGF.Builder.CreateBitCast(read_weak, DestTy);\n  return read_weak;\n}\n\n/// EmitObjCWeakAssign - Code gen for assigning to a __weak object.\n/// objc_assign_weak (id src, id *dst)\n///\nvoid CGObjCMac::EmitObjCWeakAssign(CodeGen::CodeGenFunction &CGF,\n                                   llvm::Value *src, Address dst) {\n  llvm::Type * SrcTy = src->getType();\n  if (!isa<llvm::PointerType>(SrcTy)) {\n    unsigned Size = CGM.getDataLayout().getTypeAllocSize(SrcTy);\n    assert(Size <= 8 && \"does not support size > 8\");\n    src = (Size == 4) ? CGF.Builder.CreateBitCast(src, CGM.Int32Ty)\n                      : CGF.Builder.CreateBitCast(src, CGM.Int64Ty);\n    src = CGF.Builder.CreateIntToPtr(src, ObjCTypes.Int8PtrTy);\n  }\n  src = CGF.Builder.CreateBitCast(src, ObjCTypes.ObjectPtrTy);\n  dst = CGF.Builder.CreateBitCast(dst, ObjCTypes.PtrObjectPtrTy);\n  llvm::Value *args[] = { src, dst.getPointer() };\n  CGF.EmitNounwindRuntimeCall(ObjCTypes.getGcAssignWeakFn(),\n                              args, \"weakassign\");\n}\n\n/// EmitObjCGlobalAssign - Code gen for assigning to a __strong object.\n/// objc_assign_global (id src, id *dst)\n///\nvoid CGObjCMac::EmitObjCGlobalAssign(CodeGen::CodeGenFunction &CGF,\n                                     llvm::Value *src, Address dst,\n                                     bool threadlocal) {\n  llvm::Type * SrcTy = src->getType();\n  if (!isa<llvm::PointerType>(SrcTy)) {\n    unsigned Size = CGM.getDataLayout().getTypeAllocSize(SrcTy);\n    assert(Size <= 8 && \"does not support size > 8\");\n    src = (Size == 4) ? CGF.Builder.CreateBitCast(src, CGM.Int32Ty)\n                      : CGF.Builder.CreateBitCast(src, CGM.Int64Ty);\n    src = CGF.Builder.CreateIntToPtr(src, ObjCTypes.Int8PtrTy);\n  }\n  src = CGF.Builder.CreateBitCast(src, ObjCTypes.ObjectPtrTy);\n  dst = CGF.Builder.CreateBitCast(dst, ObjCTypes.PtrObjectPtrTy);\n  llvm::Value *args[] = { src, dst.getPointer() };\n  if (!threadlocal)\n    CGF.EmitNounwindRuntimeCall(ObjCTypes.getGcAssignGlobalFn(),\n                                args, \"globalassign\");\n  else\n    CGF.EmitNounwindRuntimeCall(ObjCTypes.getGcAssignThreadLocalFn(),\n                                args, \"threadlocalassign\");\n}\n\n/// EmitObjCIvarAssign - Code gen for assigning to a __strong object.\n/// objc_assign_ivar (id src, id *dst, ptrdiff_t ivaroffset)\n///\nvoid CGObjCMac::EmitObjCIvarAssign(CodeGen::CodeGenFunction &CGF,\n                                   llvm::Value *src, Address dst,\n                                   llvm::Value *ivarOffset) {\n  assert(ivarOffset && \"EmitObjCIvarAssign - ivarOffset is NULL\");\n  llvm::Type * SrcTy = src->getType();\n  if (!isa<llvm::PointerType>(SrcTy)) {\n    unsigned Size = CGM.getDataLayout().getTypeAllocSize(SrcTy);\n    assert(Size <= 8 && \"does not support size > 8\");\n    src = (Size == 4) ? CGF.Builder.CreateBitCast(src, CGM.Int32Ty)\n                      : CGF.Builder.CreateBitCast(src, CGM.Int64Ty);\n    src = CGF.Builder.CreateIntToPtr(src, ObjCTypes.Int8PtrTy);\n  }\n  src = CGF.Builder.CreateBitCast(src, ObjCTypes.ObjectPtrTy);\n  dst = CGF.Builder.CreateBitCast(dst, ObjCTypes.PtrObjectPtrTy);\n  llvm::Value *args[] = { src, dst.getPointer(), ivarOffset };\n  CGF.EmitNounwindRuntimeCall(ObjCTypes.getGcAssignIvarFn(), args);\n}\n\n/// EmitObjCStrongCastAssign - Code gen for assigning to a __strong cast object.\n/// objc_assign_strongCast (id src, id *dst)\n///\nvoid CGObjCMac::EmitObjCStrongCastAssign(CodeGen::CodeGenFunction &CGF,\n                                         llvm::Value *src, Address dst) {\n  llvm::Type * SrcTy = src->getType();\n  if (!isa<llvm::PointerType>(SrcTy)) {\n    unsigned Size = CGM.getDataLayout().getTypeAllocSize(SrcTy);\n    assert(Size <= 8 && \"does not support size > 8\");\n    src = (Size == 4) ? CGF.Builder.CreateBitCast(src, CGM.Int32Ty)\n                      : CGF.Builder.CreateBitCast(src, CGM.Int64Ty);\n    src = CGF.Builder.CreateIntToPtr(src, ObjCTypes.Int8PtrTy);\n  }\n  src = CGF.Builder.CreateBitCast(src, ObjCTypes.ObjectPtrTy);\n  dst = CGF.Builder.CreateBitCast(dst, ObjCTypes.PtrObjectPtrTy);\n  llvm::Value *args[] = { src, dst.getPointer() };\n  CGF.EmitNounwindRuntimeCall(ObjCTypes.getGcAssignStrongCastFn(),\n                              args, \"strongassign\");\n}\n\nvoid CGObjCMac::EmitGCMemmoveCollectable(CodeGen::CodeGenFunction &CGF,\n                                         Address DestPtr,\n                                         Address SrcPtr,\n                                         llvm::Value *size) {\n  SrcPtr = CGF.Builder.CreateBitCast(SrcPtr, ObjCTypes.Int8PtrTy);\n  DestPtr = CGF.Builder.CreateBitCast(DestPtr, ObjCTypes.Int8PtrTy);\n  llvm::Value *args[] = { DestPtr.getPointer(), SrcPtr.getPointer(), size };\n  CGF.EmitNounwindRuntimeCall(ObjCTypes.GcMemmoveCollectableFn(), args);\n}\n\n/// EmitObjCValueForIvar - Code Gen for ivar reference.\n///\nLValue CGObjCMac::EmitObjCValueForIvar(CodeGen::CodeGenFunction &CGF,\n                                       QualType ObjectTy,\n                                       llvm::Value *BaseValue,\n                                       const ObjCIvarDecl *Ivar,\n                                       unsigned CVRQualifiers) {\n  const ObjCInterfaceDecl *ID =\n    ObjectTy->castAs<ObjCObjectType>()->getInterface();\n  return EmitValueForIvarAtOffset(CGF, ID, BaseValue, Ivar, CVRQualifiers,\n                                  EmitIvarOffset(CGF, ID, Ivar));\n}\n\nllvm::Value *CGObjCMac::EmitIvarOffset(CodeGen::CodeGenFunction &CGF,\n                                       const ObjCInterfaceDecl *Interface,\n                                       const ObjCIvarDecl *Ivar) {\n  uint64_t Offset = ComputeIvarBaseOffset(CGM, Interface, Ivar);\n  return llvm::ConstantInt::get(\n    CGM.getTypes().ConvertType(CGM.getContext().LongTy),\n    Offset);\n}\n\n/* *** Private Interface *** */\n\nstd::string CGObjCCommonMac::GetSectionName(StringRef Section,\n                                            StringRef MachOAttributes) {\n  switch (CGM.getTriple().getObjectFormat()) {\n  case llvm::Triple::UnknownObjectFormat:\n    llvm_unreachable(\"unexpected object file format\");\n  case llvm::Triple::MachO: {\n    if (MachOAttributes.empty())\n      return (\"__DATA,\" + Section).str();\n    return (\"__DATA,\" + Section + \",\" + MachOAttributes).str();\n  }\n  case llvm::Triple::ELF:\n    assert(Section.substr(0, 2) == \"__\" &&\n           \"expected the name to begin with __\");\n    return Section.substr(2).str();\n  case llvm::Triple::COFF:\n    assert(Section.substr(0, 2) == \"__\" &&\n           \"expected the name to begin with __\");\n    return (\".\" + Section.substr(2) + \"$B\").str();\n  case llvm::Triple::Wasm:\n  case llvm::Triple::GOFF:\n  case llvm::Triple::XCOFF:\n    llvm::report_fatal_error(\n        \"Objective-C support is unimplemented for object file format\");\n  }\n\n  llvm_unreachable(\"Unhandled llvm::Triple::ObjectFormatType enum\");\n}\n\n/// EmitImageInfo - Emit the image info marker used to encode some module\n/// level information.\n///\n/// See: <rdr://4810609&4810587&4810587>\n/// struct IMAGE_INFO {\n///   unsigned version;\n///   unsigned flags;\n/// };\nenum ImageInfoFlags {\n  eImageInfo_FixAndContinue      = (1 << 0), // This flag is no longer set by clang.\n  eImageInfo_GarbageCollected    = (1 << 1),\n  eImageInfo_GCOnly              = (1 << 2),\n  eImageInfo_OptimizedByDyld     = (1 << 3), // This flag is set by the dyld shared cache.\n\n  // A flag indicating that the module has no instances of a @synthesize of a\n  // superclass variable. <rdar://problem/6803242>\n  eImageInfo_CorrectedSynthesize = (1 << 4), // This flag is no longer set by clang.\n  eImageInfo_ImageIsSimulated    = (1 << 5),\n  eImageInfo_ClassProperties     = (1 << 6)\n};\n\nvoid CGObjCCommonMac::EmitImageInfo() {\n  unsigned version = 0; // Version is unused?\n  std::string Section =\n      (ObjCABI == 1)\n          ? \"__OBJC,__image_info,regular\"\n          : GetSectionName(\"__objc_imageinfo\", \"regular,no_dead_strip\");\n\n  // Generate module-level named metadata to convey this information to the\n  // linker and code-gen.\n  llvm::Module &Mod = CGM.getModule();\n\n  // Add the ObjC ABI version to the module flags.\n  Mod.addModuleFlag(llvm::Module::Error, \"Objective-C Version\", ObjCABI);\n  Mod.addModuleFlag(llvm::Module::Error, \"Objective-C Image Info Version\",\n                    version);\n  Mod.addModuleFlag(llvm::Module::Error, \"Objective-C Image Info Section\",\n                    llvm::MDString::get(VMContext, Section));\n\n  auto Int8Ty = llvm::Type::getInt8Ty(VMContext);\n  if (CGM.getLangOpts().getGC() == LangOptions::NonGC) {\n    // Non-GC overrides those files which specify GC.\n    Mod.addModuleFlag(llvm::Module::Error,\n                      \"Objective-C Garbage Collection\",\n                      llvm::ConstantInt::get(Int8Ty,0));\n  } else {\n    // Add the ObjC garbage collection value.\n    Mod.addModuleFlag(llvm::Module::Error,\n                      \"Objective-C Garbage Collection\",\n                      llvm::ConstantInt::get(Int8Ty,\n                        (uint8_t)eImageInfo_GarbageCollected));\n\n    if (CGM.getLangOpts().getGC() == LangOptions::GCOnly) {\n      // Add the ObjC GC Only value.\n      Mod.addModuleFlag(llvm::Module::Error, \"Objective-C GC Only\",\n                        eImageInfo_GCOnly);\n\n      // Require that GC be specified and set to eImageInfo_GarbageCollected.\n      llvm::Metadata *Ops[2] = {\n          llvm::MDString::get(VMContext, \"Objective-C Garbage Collection\"),\n          llvm::ConstantAsMetadata::get(llvm::ConstantInt::get(\n              Int8Ty, eImageInfo_GarbageCollected))};\n      Mod.addModuleFlag(llvm::Module::Require, \"Objective-C GC Only\",\n                        llvm::MDNode::get(VMContext, Ops));\n    }\n  }\n\n  // Indicate whether we're compiling this to run on a simulator.\n  if (CGM.getTarget().getTriple().isSimulatorEnvironment())\n    Mod.addModuleFlag(llvm::Module::Error, \"Objective-C Is Simulated\",\n                      eImageInfo_ImageIsSimulated);\n\n  // Indicate whether we are generating class properties.\n  Mod.addModuleFlag(llvm::Module::Error, \"Objective-C Class Properties\",\n                    eImageInfo_ClassProperties);\n}\n\n// struct objc_module {\n//   unsigned long version;\n//   unsigned long size;\n//   const char *name;\n//   Symtab symtab;\n// };\n\n// FIXME: Get from somewhere\nstatic const int ModuleVersion = 7;\n\nvoid CGObjCMac::EmitModuleInfo() {\n  uint64_t Size = CGM.getDataLayout().getTypeAllocSize(ObjCTypes.ModuleTy);\n\n  ConstantInitBuilder builder(CGM);\n  auto values = builder.beginStruct(ObjCTypes.ModuleTy);\n  values.addInt(ObjCTypes.LongTy, ModuleVersion);\n  values.addInt(ObjCTypes.LongTy, Size);\n  // This used to be the filename, now it is unused. <rdr://4327263>\n  values.add(GetClassName(StringRef(\"\")));\n  values.add(EmitModuleSymbols());\n  CreateMetadataVar(\"OBJC_MODULES\", values,\n                    \"__OBJC,__module_info,regular,no_dead_strip\",\n                    CGM.getPointerAlign(), true);\n}\n\nllvm::Constant *CGObjCMac::EmitModuleSymbols() {\n  unsigned NumClasses = DefinedClasses.size();\n  unsigned NumCategories = DefinedCategories.size();\n\n  // Return null if no symbols were defined.\n  if (!NumClasses && !NumCategories)\n    return llvm::Constant::getNullValue(ObjCTypes.SymtabPtrTy);\n\n  ConstantInitBuilder builder(CGM);\n  auto values = builder.beginStruct();\n  values.addInt(ObjCTypes.LongTy, 0);\n  values.addNullPointer(ObjCTypes.SelectorPtrTy);\n  values.addInt(ObjCTypes.ShortTy, NumClasses);\n  values.addInt(ObjCTypes.ShortTy, NumCategories);\n\n  // The runtime expects exactly the list of defined classes followed\n  // by the list of defined categories, in a single array.\n  auto array = values.beginArray(ObjCTypes.Int8PtrTy);\n  for (unsigned i=0; i<NumClasses; i++) {\n    const ObjCInterfaceDecl *ID = ImplementedClasses[i];\n    assert(ID);\n    if (ObjCImplementationDecl *IMP = ID->getImplementation())\n      // We are implementing a weak imported interface. Give it external linkage\n      if (ID->isWeakImported() && !IMP->isWeakImported())\n        DefinedClasses[i]->setLinkage(llvm::GlobalVariable::ExternalLinkage);\n\n    array.addBitCast(DefinedClasses[i], ObjCTypes.Int8PtrTy);\n  }\n  for (unsigned i=0; i<NumCategories; i++)\n    array.addBitCast(DefinedCategories[i], ObjCTypes.Int8PtrTy);\n\n  array.finishAndAddTo(values);\n\n  llvm::GlobalVariable *GV = CreateMetadataVar(\n      \"OBJC_SYMBOLS\", values, \"__OBJC,__symbols,regular,no_dead_strip\",\n      CGM.getPointerAlign(), true);\n  return llvm::ConstantExpr::getBitCast(GV, ObjCTypes.SymtabPtrTy);\n}\n\nllvm::Value *CGObjCMac::EmitClassRefFromId(CodeGenFunction &CGF,\n                                           IdentifierInfo *II) {\n  LazySymbols.insert(II);\n\n  llvm::GlobalVariable *&Entry = ClassReferences[II];\n\n  if (!Entry) {\n    llvm::Constant *Casted =\n    llvm::ConstantExpr::getBitCast(GetClassName(II->getName()),\n                                   ObjCTypes.ClassPtrTy);\n    Entry = CreateMetadataVar(\n        \"OBJC_CLASS_REFERENCES_\", Casted,\n        \"__OBJC,__cls_refs,literal_pointers,no_dead_strip\",\n        CGM.getPointerAlign(), true);\n  }\n\n  return CGF.Builder.CreateAlignedLoad(Entry, CGF.getPointerAlign());\n}\n\nllvm::Value *CGObjCMac::EmitClassRef(CodeGenFunction &CGF,\n                                     const ObjCInterfaceDecl *ID) {\n  // If the class has the objc_runtime_visible attribute, we need to\n  // use the Objective-C runtime to get the class.\n  if (ID->hasAttr<ObjCRuntimeVisibleAttr>())\n    return EmitClassRefViaRuntime(CGF, ID, ObjCTypes);\n\n  IdentifierInfo *RuntimeName =\n      &CGM.getContext().Idents.get(ID->getObjCRuntimeNameAsString());\n  return EmitClassRefFromId(CGF, RuntimeName);\n}\n\nllvm::Value *CGObjCMac::EmitNSAutoreleasePoolClassRef(CodeGenFunction &CGF) {\n  IdentifierInfo *II = &CGM.getContext().Idents.get(\"NSAutoreleasePool\");\n  return EmitClassRefFromId(CGF, II);\n}\n\nllvm::Value *CGObjCMac::EmitSelector(CodeGenFunction &CGF, Selector Sel) {\n  return CGF.Builder.CreateLoad(EmitSelectorAddr(Sel));\n}\n\nAddress CGObjCMac::EmitSelectorAddr(Selector Sel) {\n  CharUnits Align = CGM.getPointerAlign();\n\n  llvm::GlobalVariable *&Entry = SelectorReferences[Sel];\n  if (!Entry) {\n    llvm::Constant *Casted =\n      llvm::ConstantExpr::getBitCast(GetMethodVarName(Sel),\n                                     ObjCTypes.SelectorPtrTy);\n    Entry = CreateMetadataVar(\n        \"OBJC_SELECTOR_REFERENCES_\", Casted,\n        \"__OBJC,__message_refs,literal_pointers,no_dead_strip\", Align, true);\n    Entry->setExternallyInitialized(true);\n  }\n\n  return Address(Entry, Align);\n}\n\nllvm::Constant *CGObjCCommonMac::GetClassName(StringRef RuntimeName) {\n    llvm::GlobalVariable *&Entry = ClassNames[RuntimeName];\n    if (!Entry)\n      Entry = CreateCStringLiteral(RuntimeName, ObjCLabelType::ClassName);\n    return getConstantGEP(VMContext, Entry, 0, 0);\n}\n\nllvm::Function *CGObjCCommonMac::GetMethodDefinition(const ObjCMethodDecl *MD) {\n  llvm::DenseMap<const ObjCMethodDecl*, llvm::Function*>::iterator\n      I = MethodDefinitions.find(MD);\n  if (I != MethodDefinitions.end())\n    return I->second;\n\n  return nullptr;\n}\n\n/// GetIvarLayoutName - Returns a unique constant for the given\n/// ivar layout bitmap.\nllvm::Constant *CGObjCCommonMac::GetIvarLayoutName(IdentifierInfo *Ident,\n                                       const ObjCCommonTypesHelper &ObjCTypes) {\n  return llvm::Constant::getNullValue(ObjCTypes.Int8PtrTy);\n}\n\nvoid IvarLayoutBuilder::visitRecord(const RecordType *RT,\n                                    CharUnits offset) {\n  const RecordDecl *RD = RT->getDecl();\n\n  // If this is a union, remember that we had one, because it might mess\n  // up the ordering of layout entries.\n  if (RD->isUnion())\n    IsDisordered = true;\n\n  const ASTRecordLayout *recLayout = nullptr;\n  visitAggregate(RD->field_begin(), RD->field_end(), offset,\n                 [&](const FieldDecl *field) -> CharUnits {\n    if (!recLayout)\n      recLayout = &CGM.getContext().getASTRecordLayout(RD);\n    auto offsetInBits = recLayout->getFieldOffset(field->getFieldIndex());\n    return CGM.getContext().toCharUnitsFromBits(offsetInBits);\n  });\n}\n\ntemplate <class Iterator, class GetOffsetFn>\nvoid IvarLayoutBuilder::visitAggregate(Iterator begin, Iterator end,\n                                       CharUnits aggregateOffset,\n                                       const GetOffsetFn &getOffset) {\n  for (; begin != end; ++begin) {\n    auto field = *begin;\n\n    // Skip over bitfields.\n    if (field->isBitField()) {\n      continue;\n    }\n\n    // Compute the offset of the field within the aggregate.\n    CharUnits fieldOffset = aggregateOffset + getOffset(field);\n\n    visitField(field, fieldOffset);\n  }\n}\n\n/// Collect layout information for the given fields into IvarsInfo.\nvoid IvarLayoutBuilder::visitField(const FieldDecl *field,\n                                   CharUnits fieldOffset) {\n  QualType fieldType = field->getType();\n\n  // Drill down into arrays.\n  uint64_t numElts = 1;\n  if (auto arrayType = CGM.getContext().getAsIncompleteArrayType(fieldType)) {\n    numElts = 0;\n    fieldType = arrayType->getElementType();\n  }\n  // Unlike incomplete arrays, constant arrays can be nested.\n  while (auto arrayType = CGM.getContext().getAsConstantArrayType(fieldType)) {\n    numElts *= arrayType->getSize().getZExtValue();\n    fieldType = arrayType->getElementType();\n  }\n\n  assert(!fieldType->isArrayType() && \"ivar of non-constant array type?\");\n\n  // If we ended up with a zero-sized array, we've done what we can do within\n  // the limits of this layout encoding.\n  if (numElts == 0) return;\n\n  // Recurse if the base element type is a record type.\n  if (auto recType = fieldType->getAs<RecordType>()) {\n    size_t oldEnd = IvarsInfo.size();\n\n    visitRecord(recType, fieldOffset);\n\n    // If we have an array, replicate the first entry's layout information.\n    auto numEltEntries = IvarsInfo.size() - oldEnd;\n    if (numElts != 1 && numEltEntries != 0) {\n      CharUnits eltSize = CGM.getContext().getTypeSizeInChars(recType);\n      for (uint64_t eltIndex = 1; eltIndex != numElts; ++eltIndex) {\n        // Copy the last numEltEntries onto the end of the array, adjusting\n        // each for the element size.\n        for (size_t i = 0; i != numEltEntries; ++i) {\n          auto firstEntry = IvarsInfo[oldEnd + i];\n          IvarsInfo.push_back(IvarInfo(firstEntry.Offset + eltIndex * eltSize,\n                                       firstEntry.SizeInWords));\n        }\n      }\n    }\n\n    return;\n  }\n\n  // Classify the element type.\n  Qualifiers::GC GCAttr = GetGCAttrTypeForType(CGM.getContext(), fieldType);\n\n  // If it matches what we're looking for, add an entry.\n  if ((ForStrongLayout && GCAttr == Qualifiers::Strong)\n      || (!ForStrongLayout && GCAttr == Qualifiers::Weak)) {\n    assert(CGM.getContext().getTypeSizeInChars(fieldType)\n             == CGM.getPointerSize());\n    IvarsInfo.push_back(IvarInfo(fieldOffset, numElts));\n  }\n}\n\n/// buildBitmap - This routine does the horsework of taking the offsets of\n/// strong/weak references and creating a bitmap.  The bitmap is also\n/// returned in the given buffer, suitable for being passed to \\c dump().\nllvm::Constant *IvarLayoutBuilder::buildBitmap(CGObjCCommonMac &CGObjC,\n                                llvm::SmallVectorImpl<unsigned char> &buffer) {\n  // The bitmap is a series of skip/scan instructions, aligned to word\n  // boundaries.  The skip is performed first.\n  const unsigned char MaxNibble = 0xF;\n  const unsigned char SkipMask = 0xF0, SkipShift = 4;\n  const unsigned char ScanMask = 0x0F, ScanShift = 0;\n\n  assert(!IvarsInfo.empty() && \"generating bitmap for no data\");\n\n  // Sort the ivar info on byte position in case we encounterred a\n  // union nested in the ivar list.\n  if (IsDisordered) {\n    // This isn't a stable sort, but our algorithm should handle it fine.\n    llvm::array_pod_sort(IvarsInfo.begin(), IvarsInfo.end());\n  } else {\n    assert(llvm::is_sorted(IvarsInfo));\n  }\n  assert(IvarsInfo.back().Offset < InstanceEnd);\n\n  assert(buffer.empty());\n\n  // Skip the next N words.\n  auto skip = [&](unsigned numWords) {\n    assert(numWords > 0);\n\n    // Try to merge into the previous byte.  Since scans happen second, we\n    // can't do this if it includes a scan.\n    if (!buffer.empty() && !(buffer.back() & ScanMask)) {\n      unsigned lastSkip = buffer.back() >> SkipShift;\n      if (lastSkip < MaxNibble) {\n        unsigned claimed = std::min(MaxNibble - lastSkip, numWords);\n        numWords -= claimed;\n        lastSkip += claimed;\n        buffer.back() = (lastSkip << SkipShift);\n      }\n    }\n\n    while (numWords >= MaxNibble) {\n      buffer.push_back(MaxNibble << SkipShift);\n      numWords -= MaxNibble;\n    }\n    if (numWords) {\n      buffer.push_back(numWords << SkipShift);\n    }\n  };\n\n  // Scan the next N words.\n  auto scan = [&](unsigned numWords) {\n    assert(numWords > 0);\n\n    // Try to merge into the previous byte.  Since scans happen second, we can\n    // do this even if it includes a skip.\n    if (!buffer.empty()) {\n      unsigned lastScan = (buffer.back() & ScanMask) >> ScanShift;\n      if (lastScan < MaxNibble) {\n        unsigned claimed = std::min(MaxNibble - lastScan, numWords);\n        numWords -= claimed;\n        lastScan += claimed;\n        buffer.back() = (buffer.back() & SkipMask) | (lastScan << ScanShift);\n      }\n    }\n\n    while (numWords >= MaxNibble) {\n      buffer.push_back(MaxNibble << ScanShift);\n      numWords -= MaxNibble;\n    }\n    if (numWords) {\n      buffer.push_back(numWords << ScanShift);\n    }\n  };\n\n  // One past the end of the last scan.\n  unsigned endOfLastScanInWords = 0;\n  const CharUnits WordSize = CGM.getPointerSize();\n\n  // Consider all the scan requests.\n  for (auto &request : IvarsInfo) {\n    CharUnits beginOfScan = request.Offset - InstanceBegin;\n\n    // Ignore scan requests that don't start at an even multiple of the\n    // word size.  We can't encode them.\n    if ((beginOfScan % WordSize) != 0) continue;\n\n    // Ignore scan requests that start before the instance start.\n    // This assumes that scans never span that boundary.  The boundary\n    // isn't the true start of the ivars, because in the fragile-ARC case\n    // it's rounded up to word alignment, but the test above should leave\n    // us ignoring that possibility.\n    if (beginOfScan.isNegative()) {\n      assert(request.Offset + request.SizeInWords * WordSize <= InstanceBegin);\n      continue;\n    }\n\n    unsigned beginOfScanInWords = beginOfScan / WordSize;\n    unsigned endOfScanInWords = beginOfScanInWords + request.SizeInWords;\n\n    // If the scan starts some number of words after the last one ended,\n    // skip forward.\n    if (beginOfScanInWords > endOfLastScanInWords) {\n      skip(beginOfScanInWords - endOfLastScanInWords);\n\n    // Otherwise, start scanning where the last left off.\n    } else {\n      beginOfScanInWords = endOfLastScanInWords;\n\n      // If that leaves us with nothing to scan, ignore this request.\n      if (beginOfScanInWords >= endOfScanInWords) continue;\n    }\n\n    // Scan to the end of the request.\n    assert(beginOfScanInWords < endOfScanInWords);\n    scan(endOfScanInWords - beginOfScanInWords);\n    endOfLastScanInWords = endOfScanInWords;\n  }\n\n  if (buffer.empty())\n    return llvm::ConstantPointerNull::get(CGM.Int8PtrTy);\n\n  // For GC layouts, emit a skip to the end of the allocation so that we\n  // have precise information about the entire thing.  This isn't useful\n  // or necessary for the ARC-style layout strings.\n  if (CGM.getLangOpts().getGC() != LangOptions::NonGC) {\n    unsigned lastOffsetInWords =\n      (InstanceEnd - InstanceBegin + WordSize - CharUnits::One()) / WordSize;\n    if (lastOffsetInWords > endOfLastScanInWords) {\n      skip(lastOffsetInWords - endOfLastScanInWords);\n    }\n  }\n\n  // Null terminate the string.\n  buffer.push_back(0);\n\n  auto *Entry = CGObjC.CreateCStringLiteral(\n      reinterpret_cast<char *>(buffer.data()), ObjCLabelType::ClassName);\n  return getConstantGEP(CGM.getLLVMContext(), Entry, 0, 0);\n}\n\n/// BuildIvarLayout - Builds ivar layout bitmap for the class\n/// implementation for the __strong or __weak case.\n/// The layout map displays which words in ivar list must be skipped\n/// and which must be scanned by GC (see below). String is built of bytes.\n/// Each byte is divided up in two nibbles (4-bit each). Left nibble is count\n/// of words to skip and right nibble is count of words to scan. So, each\n/// nibble represents up to 15 workds to skip or scan. Skipping the rest is\n/// represented by a 0x00 byte which also ends the string.\n/// 1. when ForStrongLayout is true, following ivars are scanned:\n/// - id, Class\n/// - object *\n/// - __strong anything\n///\n/// 2. When ForStrongLayout is false, following ivars are scanned:\n/// - __weak anything\n///\nllvm::Constant *\nCGObjCCommonMac::BuildIvarLayout(const ObjCImplementationDecl *OMD,\n                                 CharUnits beginOffset, CharUnits endOffset,\n                                 bool ForStrongLayout, bool HasMRCWeakIvars) {\n  // If this is MRC, and we're either building a strong layout or there\n  // are no weak ivars, bail out early.\n  llvm::Type *PtrTy = CGM.Int8PtrTy;\n  if (CGM.getLangOpts().getGC() == LangOptions::NonGC &&\n      !CGM.getLangOpts().ObjCAutoRefCount &&\n      (ForStrongLayout || !HasMRCWeakIvars))\n    return llvm::Constant::getNullValue(PtrTy);\n\n  const ObjCInterfaceDecl *OI = OMD->getClassInterface();\n  SmallVector<const ObjCIvarDecl*, 32> ivars;\n\n  // GC layout strings include the complete object layout, possibly\n  // inaccurately in the non-fragile ABI; the runtime knows how to fix this\n  // up.\n  //\n  // ARC layout strings only include the class's ivars.  In non-fragile\n  // runtimes, that means starting at InstanceStart, rounded up to word\n  // alignment.  In fragile runtimes, there's no InstanceStart, so it means\n  // starting at the offset of the first ivar, rounded up to word alignment.\n  //\n  // MRC weak layout strings follow the ARC style.\n  CharUnits baseOffset;\n  if (CGM.getLangOpts().getGC() == LangOptions::NonGC) {\n    for (const ObjCIvarDecl *IVD = OI->all_declared_ivar_begin();\n         IVD; IVD = IVD->getNextIvar())\n      ivars.push_back(IVD);\n\n    if (isNonFragileABI()) {\n      baseOffset = beginOffset; // InstanceStart\n    } else if (!ivars.empty()) {\n      baseOffset =\n        CharUnits::fromQuantity(ComputeIvarBaseOffset(CGM, OMD, ivars[0]));\n    } else {\n      baseOffset = CharUnits::Zero();\n    }\n\n    baseOffset = baseOffset.alignTo(CGM.getPointerAlign());\n  }\n  else {\n    CGM.getContext().DeepCollectObjCIvars(OI, true, ivars);\n\n    baseOffset = CharUnits::Zero();\n  }\n\n  if (ivars.empty())\n    return llvm::Constant::getNullValue(PtrTy);\n\n  IvarLayoutBuilder builder(CGM, baseOffset, endOffset, ForStrongLayout);\n\n  builder.visitAggregate(ivars.begin(), ivars.end(), CharUnits::Zero(),\n                         [&](const ObjCIvarDecl *ivar) -> CharUnits {\n      return CharUnits::fromQuantity(ComputeIvarBaseOffset(CGM, OMD, ivar));\n  });\n\n  if (!builder.hasBitmapData())\n    return llvm::Constant::getNullValue(PtrTy);\n\n  llvm::SmallVector<unsigned char, 4> buffer;\n  llvm::Constant *C = builder.buildBitmap(*this, buffer);\n\n   if (CGM.getLangOpts().ObjCGCBitmapPrint && !buffer.empty()) {\n    printf(\"\\n%s ivar layout for class '%s': \",\n           ForStrongLayout ? \"strong\" : \"weak\",\n           OMD->getClassInterface()->getName().str().c_str());\n    builder.dump(buffer);\n  }\n  return C;\n}\n\nllvm::Constant *CGObjCCommonMac::GetMethodVarName(Selector Sel) {\n  llvm::GlobalVariable *&Entry = MethodVarNames[Sel];\n  // FIXME: Avoid std::string in \"Sel.getAsString()\"\n  if (!Entry)\n    Entry = CreateCStringLiteral(Sel.getAsString(), ObjCLabelType::MethodVarName);\n  return getConstantGEP(VMContext, Entry, 0, 0);\n}\n\n// FIXME: Merge into a single cstring creation function.\nllvm::Constant *CGObjCCommonMac::GetMethodVarName(IdentifierInfo *ID) {\n  return GetMethodVarName(CGM.getContext().Selectors.getNullarySelector(ID));\n}\n\nllvm::Constant *CGObjCCommonMac::GetMethodVarType(const FieldDecl *Field) {\n  std::string TypeStr;\n  CGM.getContext().getObjCEncodingForType(Field->getType(), TypeStr, Field);\n\n  llvm::GlobalVariable *&Entry = MethodVarTypes[TypeStr];\n  if (!Entry)\n    Entry = CreateCStringLiteral(TypeStr, ObjCLabelType::MethodVarType);\n  return getConstantGEP(VMContext, Entry, 0, 0);\n}\n\nllvm::Constant *CGObjCCommonMac::GetMethodVarType(const ObjCMethodDecl *D,\n                                                  bool Extended) {\n  std::string TypeStr =\n    CGM.getContext().getObjCEncodingForMethodDecl(D, Extended);\n\n  llvm::GlobalVariable *&Entry = MethodVarTypes[TypeStr];\n  if (!Entry)\n    Entry = CreateCStringLiteral(TypeStr, ObjCLabelType::MethodVarType);\n  return getConstantGEP(VMContext, Entry, 0, 0);\n}\n\n// FIXME: Merge into a single cstring creation function.\nllvm::Constant *CGObjCCommonMac::GetPropertyName(IdentifierInfo *Ident) {\n  llvm::GlobalVariable *&Entry = PropertyNames[Ident];\n  if (!Entry)\n    Entry = CreateCStringLiteral(Ident->getName(), ObjCLabelType::PropertyName);\n  return getConstantGEP(VMContext, Entry, 0, 0);\n}\n\n// FIXME: Merge into a single cstring creation function.\n// FIXME: This Decl should be more precise.\nllvm::Constant *\nCGObjCCommonMac::GetPropertyTypeString(const ObjCPropertyDecl *PD,\n                                       const Decl *Container) {\n  std::string TypeStr =\n    CGM.getContext().getObjCEncodingForPropertyDecl(PD, Container);\n  return GetPropertyName(&CGM.getContext().Idents.get(TypeStr));\n}\n\nvoid CGObjCMac::FinishModule() {\n  EmitModuleInfo();\n\n  // Emit the dummy bodies for any protocols which were referenced but\n  // never defined.\n  for (auto &entry : Protocols) {\n    llvm::GlobalVariable *global = entry.second;\n    if (global->hasInitializer())\n      continue;\n\n    ConstantInitBuilder builder(CGM);\n    auto values = builder.beginStruct(ObjCTypes.ProtocolTy);\n    values.addNullPointer(ObjCTypes.ProtocolExtensionPtrTy);\n    values.add(GetClassName(entry.first->getName()));\n    values.addNullPointer(ObjCTypes.ProtocolListPtrTy);\n    values.addNullPointer(ObjCTypes.MethodDescriptionListPtrTy);\n    values.addNullPointer(ObjCTypes.MethodDescriptionListPtrTy);\n    values.finishAndSetAsInitializer(global);\n    CGM.addCompilerUsedGlobal(global);\n  }\n\n  // Add assembler directives to add lazy undefined symbol references\n  // for classes which are referenced but not defined. This is\n  // important for correct linker interaction.\n  //\n  // FIXME: It would be nice if we had an LLVM construct for this.\n  if ((!LazySymbols.empty() || !DefinedSymbols.empty()) &&\n      CGM.getTriple().isOSBinFormatMachO()) {\n    SmallString<256> Asm;\n    Asm += CGM.getModule().getModuleInlineAsm();\n    if (!Asm.empty() && Asm.back() != '\\n')\n      Asm += '\\n';\n\n    llvm::raw_svector_ostream OS(Asm);\n    for (const auto *Sym : DefinedSymbols)\n      OS << \"\\t.objc_class_name_\" << Sym->getName() << \"=0\\n\"\n         << \"\\t.globl .objc_class_name_\" << Sym->getName() << \"\\n\";\n    for (const auto *Sym : LazySymbols)\n      OS << \"\\t.lazy_reference .objc_class_name_\" << Sym->getName() << \"\\n\";\n    for (const auto &Category : DefinedCategoryNames)\n      OS << \"\\t.objc_category_name_\" << Category << \"=0\\n\"\n         << \"\\t.globl .objc_category_name_\" << Category << \"\\n\";\n\n    CGM.getModule().setModuleInlineAsm(OS.str());\n  }\n}\n\nCGObjCNonFragileABIMac::CGObjCNonFragileABIMac(CodeGen::CodeGenModule &cgm)\n    : CGObjCCommonMac(cgm), ObjCTypes(cgm), ObjCEmptyCacheVar(nullptr),\n      ObjCEmptyVtableVar(nullptr) {\n  ObjCABI = 2;\n}\n\n/* *** */\n\nObjCCommonTypesHelper::ObjCCommonTypesHelper(CodeGen::CodeGenModule &cgm)\n  : VMContext(cgm.getLLVMContext()), CGM(cgm), ExternalProtocolPtrTy(nullptr)\n{\n  CodeGen::CodeGenTypes &Types = CGM.getTypes();\n  ASTContext &Ctx = CGM.getContext();\n\n  ShortTy = cast<llvm::IntegerType>(Types.ConvertType(Ctx.ShortTy));\n  IntTy = CGM.IntTy;\n  LongTy = cast<llvm::IntegerType>(Types.ConvertType(Ctx.LongTy));\n  Int8PtrTy = CGM.Int8PtrTy;\n  Int8PtrPtrTy = CGM.Int8PtrPtrTy;\n\n  // arm64 targets use \"int\" ivar offset variables. All others,\n  // including OS X x86_64 and Windows x86_64, use \"long\" ivar offsets.\n  if (CGM.getTarget().getTriple().getArch() == llvm::Triple::aarch64)\n    IvarOffsetVarTy = IntTy;\n  else\n    IvarOffsetVarTy = LongTy;\n\n  ObjectPtrTy =\n    cast<llvm::PointerType>(Types.ConvertType(Ctx.getObjCIdType()));\n  PtrObjectPtrTy =\n    llvm::PointerType::getUnqual(ObjectPtrTy);\n  SelectorPtrTy =\n    cast<llvm::PointerType>(Types.ConvertType(Ctx.getObjCSelType()));\n\n  // I'm not sure I like this. The implicit coordination is a bit\n  // gross. We should solve this in a reasonable fashion because this\n  // is a pretty common task (match some runtime data structure with\n  // an LLVM data structure).\n\n  // FIXME: This is leaked.\n  // FIXME: Merge with rewriter code?\n\n  // struct _objc_super {\n  //   id self;\n  //   Class cls;\n  // }\n  RecordDecl *RD = RecordDecl::Create(Ctx, TTK_Struct,\n                                      Ctx.getTranslationUnitDecl(),\n                                      SourceLocation(), SourceLocation(),\n                                      &Ctx.Idents.get(\"_objc_super\"));\n  RD->addDecl(FieldDecl::Create(Ctx, RD, SourceLocation(), SourceLocation(),\n                                nullptr, Ctx.getObjCIdType(), nullptr, nullptr,\n                                false, ICIS_NoInit));\n  RD->addDecl(FieldDecl::Create(Ctx, RD, SourceLocation(), SourceLocation(),\n                                nullptr, Ctx.getObjCClassType(), nullptr,\n                                nullptr, false, ICIS_NoInit));\n  RD->completeDefinition();\n\n  SuperCTy = Ctx.getTagDeclType(RD);\n  SuperPtrCTy = Ctx.getPointerType(SuperCTy);\n\n  SuperTy = cast<llvm::StructType>(Types.ConvertType(SuperCTy));\n  SuperPtrTy = llvm::PointerType::getUnqual(SuperTy);\n\n  // struct _prop_t {\n  //   char *name;\n  //   char *attributes;\n  // }\n  PropertyTy = llvm::StructType::create(\"struct._prop_t\", Int8PtrTy, Int8PtrTy);\n\n  // struct _prop_list_t {\n  //   uint32_t entsize;      // sizeof(struct _prop_t)\n  //   uint32_t count_of_properties;\n  //   struct _prop_t prop_list[count_of_properties];\n  // }\n  PropertyListTy = llvm::StructType::create(\n      \"struct._prop_list_t\", IntTy, IntTy, llvm::ArrayType::get(PropertyTy, 0));\n  // struct _prop_list_t *\n  PropertyListPtrTy = llvm::PointerType::getUnqual(PropertyListTy);\n\n  // struct _objc_method {\n  //   SEL _cmd;\n  //   char *method_type;\n  //   char *_imp;\n  // }\n  MethodTy = llvm::StructType::create(\"struct._objc_method\", SelectorPtrTy,\n                                      Int8PtrTy, Int8PtrTy);\n\n  // struct _objc_cache *\n  CacheTy = llvm::StructType::create(VMContext, \"struct._objc_cache\");\n  CachePtrTy = llvm::PointerType::getUnqual(CacheTy);\n}\n\nObjCTypesHelper::ObjCTypesHelper(CodeGen::CodeGenModule &cgm)\n  : ObjCCommonTypesHelper(cgm) {\n  // struct _objc_method_description {\n  //   SEL name;\n  //   char *types;\n  // }\n  MethodDescriptionTy = llvm::StructType::create(\n      \"struct._objc_method_description\", SelectorPtrTy, Int8PtrTy);\n\n  // struct _objc_method_description_list {\n  //   int count;\n  //   struct _objc_method_description[1];\n  // }\n  MethodDescriptionListTy =\n      llvm::StructType::create(\"struct._objc_method_description_list\", IntTy,\n                               llvm::ArrayType::get(MethodDescriptionTy, 0));\n\n  // struct _objc_method_description_list *\n  MethodDescriptionListPtrTy =\n    llvm::PointerType::getUnqual(MethodDescriptionListTy);\n\n  // Protocol description structures\n\n  // struct _objc_protocol_extension {\n  //   uint32_t size;  // sizeof(struct _objc_protocol_extension)\n  //   struct _objc_method_description_list *optional_instance_methods;\n  //   struct _objc_method_description_list *optional_class_methods;\n  //   struct _objc_property_list *instance_properties;\n  //   const char ** extendedMethodTypes;\n  //   struct _objc_property_list *class_properties;\n  // }\n  ProtocolExtensionTy = llvm::StructType::create(\n      \"struct._objc_protocol_extension\", IntTy, MethodDescriptionListPtrTy,\n      MethodDescriptionListPtrTy, PropertyListPtrTy, Int8PtrPtrTy,\n      PropertyListPtrTy);\n\n  // struct _objc_protocol_extension *\n  ProtocolExtensionPtrTy = llvm::PointerType::getUnqual(ProtocolExtensionTy);\n\n  // Handle recursive construction of Protocol and ProtocolList types\n\n  ProtocolTy =\n    llvm::StructType::create(VMContext, \"struct._objc_protocol\");\n\n  ProtocolListTy =\n    llvm::StructType::create(VMContext, \"struct._objc_protocol_list\");\n  ProtocolListTy->setBody(llvm::PointerType::getUnqual(ProtocolListTy), LongTy,\n                          llvm::ArrayType::get(ProtocolTy, 0));\n\n  // struct _objc_protocol {\n  //   struct _objc_protocol_extension *isa;\n  //   char *protocol_name;\n  //   struct _objc_protocol **_objc_protocol_list;\n  //   struct _objc_method_description_list *instance_methods;\n  //   struct _objc_method_description_list *class_methods;\n  // }\n  ProtocolTy->setBody(ProtocolExtensionPtrTy, Int8PtrTy,\n                      llvm::PointerType::getUnqual(ProtocolListTy),\n                      MethodDescriptionListPtrTy, MethodDescriptionListPtrTy);\n\n  // struct _objc_protocol_list *\n  ProtocolListPtrTy = llvm::PointerType::getUnqual(ProtocolListTy);\n\n  ProtocolPtrTy = llvm::PointerType::getUnqual(ProtocolTy);\n\n  // Class description structures\n\n  // struct _objc_ivar {\n  //   char *ivar_name;\n  //   char *ivar_type;\n  //   int  ivar_offset;\n  // }\n  IvarTy = llvm::StructType::create(\"struct._objc_ivar\", Int8PtrTy, Int8PtrTy,\n                                    IntTy);\n\n  // struct _objc_ivar_list *\n  IvarListTy =\n    llvm::StructType::create(VMContext, \"struct._objc_ivar_list\");\n  IvarListPtrTy = llvm::PointerType::getUnqual(IvarListTy);\n\n  // struct _objc_method_list *\n  MethodListTy =\n    llvm::StructType::create(VMContext, \"struct._objc_method_list\");\n  MethodListPtrTy = llvm::PointerType::getUnqual(MethodListTy);\n\n  // struct _objc_class_extension *\n  ClassExtensionTy = llvm::StructType::create(\n      \"struct._objc_class_extension\", IntTy, Int8PtrTy, PropertyListPtrTy);\n  ClassExtensionPtrTy = llvm::PointerType::getUnqual(ClassExtensionTy);\n\n  ClassTy = llvm::StructType::create(VMContext, \"struct._objc_class\");\n\n  // struct _objc_class {\n  //   Class isa;\n  //   Class super_class;\n  //   char *name;\n  //   long version;\n  //   long info;\n  //   long instance_size;\n  //   struct _objc_ivar_list *ivars;\n  //   struct _objc_method_list *methods;\n  //   struct _objc_cache *cache;\n  //   struct _objc_protocol_list *protocols;\n  //   char *ivar_layout;\n  //   struct _objc_class_ext *ext;\n  // };\n  ClassTy->setBody(llvm::PointerType::getUnqual(ClassTy),\n                   llvm::PointerType::getUnqual(ClassTy), Int8PtrTy, LongTy,\n                   LongTy, LongTy, IvarListPtrTy, MethodListPtrTy, CachePtrTy,\n                   ProtocolListPtrTy, Int8PtrTy, ClassExtensionPtrTy);\n\n  ClassPtrTy = llvm::PointerType::getUnqual(ClassTy);\n\n  // struct _objc_category {\n  //   char *category_name;\n  //   char *class_name;\n  //   struct _objc_method_list *instance_method;\n  //   struct _objc_method_list *class_method;\n  //   struct _objc_protocol_list *protocols;\n  //   uint32_t size;  // sizeof(struct _objc_category)\n  //   struct _objc_property_list *instance_properties;// category's @property\n  //   struct _objc_property_list *class_properties;\n  // }\n  CategoryTy = llvm::StructType::create(\n      \"struct._objc_category\", Int8PtrTy, Int8PtrTy, MethodListPtrTy,\n      MethodListPtrTy, ProtocolListPtrTy, IntTy, PropertyListPtrTy,\n      PropertyListPtrTy);\n\n  // Global metadata structures\n\n  // struct _objc_symtab {\n  //   long sel_ref_cnt;\n  //   SEL *refs;\n  //   short cls_def_cnt;\n  //   short cat_def_cnt;\n  //   char *defs[cls_def_cnt + cat_def_cnt];\n  // }\n  SymtabTy = llvm::StructType::create(\"struct._objc_symtab\", LongTy,\n                                      SelectorPtrTy, ShortTy, ShortTy,\n                                      llvm::ArrayType::get(Int8PtrTy, 0));\n  SymtabPtrTy = llvm::PointerType::getUnqual(SymtabTy);\n\n  // struct _objc_module {\n  //   long version;\n  //   long size;   // sizeof(struct _objc_module)\n  //   char *name;\n  //   struct _objc_symtab* symtab;\n  //  }\n  ModuleTy = llvm::StructType::create(\"struct._objc_module\", LongTy, LongTy,\n                                      Int8PtrTy, SymtabPtrTy);\n\n  // FIXME: This is the size of the setjmp buffer and should be target\n  // specific. 18 is what's used on 32-bit X86.\n  uint64_t SetJmpBufferSize = 18;\n\n  // Exceptions\n  llvm::Type *StackPtrTy = llvm::ArrayType::get(CGM.Int8PtrTy, 4);\n\n  ExceptionDataTy = llvm::StructType::create(\n      \"struct._objc_exception_data\",\n      llvm::ArrayType::get(CGM.Int32Ty, SetJmpBufferSize), StackPtrTy);\n}\n\nObjCNonFragileABITypesHelper::ObjCNonFragileABITypesHelper(CodeGen::CodeGenModule &cgm)\n  : ObjCCommonTypesHelper(cgm) {\n  // struct _method_list_t {\n  //   uint32_t entsize;  // sizeof(struct _objc_method)\n  //   uint32_t method_count;\n  //   struct _objc_method method_list[method_count];\n  // }\n  MethodListnfABITy =\n      llvm::StructType::create(\"struct.__method_list_t\", IntTy, IntTy,\n                               llvm::ArrayType::get(MethodTy, 0));\n  // struct method_list_t *\n  MethodListnfABIPtrTy = llvm::PointerType::getUnqual(MethodListnfABITy);\n\n  // struct _protocol_t {\n  //   id isa;  // NULL\n  //   const char * const protocol_name;\n  //   const struct _protocol_list_t * protocol_list; // super protocols\n  //   const struct method_list_t * const instance_methods;\n  //   const struct method_list_t * const class_methods;\n  //   const struct method_list_t *optionalInstanceMethods;\n  //   const struct method_list_t *optionalClassMethods;\n  //   const struct _prop_list_t * properties;\n  //   const uint32_t size;  // sizeof(struct _protocol_t)\n  //   const uint32_t flags;  // = 0\n  //   const char ** extendedMethodTypes;\n  //   const char *demangledName;\n  //   const struct _prop_list_t * class_properties;\n  // }\n\n  // Holder for struct _protocol_list_t *\n  ProtocolListnfABITy =\n    llvm::StructType::create(VMContext, \"struct._objc_protocol_list\");\n\n  ProtocolnfABITy = llvm::StructType::create(\n      \"struct._protocol_t\", ObjectPtrTy, Int8PtrTy,\n      llvm::PointerType::getUnqual(ProtocolListnfABITy), MethodListnfABIPtrTy,\n      MethodListnfABIPtrTy, MethodListnfABIPtrTy, MethodListnfABIPtrTy,\n      PropertyListPtrTy, IntTy, IntTy, Int8PtrPtrTy, Int8PtrTy,\n      PropertyListPtrTy);\n\n  // struct _protocol_t*\n  ProtocolnfABIPtrTy = llvm::PointerType::getUnqual(ProtocolnfABITy);\n\n  // struct _protocol_list_t {\n  //   long protocol_count;   // Note, this is 32/64 bit\n  //   struct _protocol_t *[protocol_count];\n  // }\n  ProtocolListnfABITy->setBody(LongTy,\n                               llvm::ArrayType::get(ProtocolnfABIPtrTy, 0));\n\n  // struct _objc_protocol_list*\n  ProtocolListnfABIPtrTy = llvm::PointerType::getUnqual(ProtocolListnfABITy);\n\n  // struct _ivar_t {\n  //   unsigned [long] int *offset;  // pointer to ivar offset location\n  //   char *name;\n  //   char *type;\n  //   uint32_t alignment;\n  //   uint32_t size;\n  // }\n  IvarnfABITy = llvm::StructType::create(\n      \"struct._ivar_t\", llvm::PointerType::getUnqual(IvarOffsetVarTy),\n      Int8PtrTy, Int8PtrTy, IntTy, IntTy);\n\n  // struct _ivar_list_t {\n  //   uint32 entsize;  // sizeof(struct _ivar_t)\n  //   uint32 count;\n  //   struct _iver_t list[count];\n  // }\n  IvarListnfABITy =\n      llvm::StructType::create(\"struct._ivar_list_t\", IntTy, IntTy,\n                               llvm::ArrayType::get(IvarnfABITy, 0));\n\n  IvarListnfABIPtrTy = llvm::PointerType::getUnqual(IvarListnfABITy);\n\n  // struct _class_ro_t {\n  //   uint32_t const flags;\n  //   uint32_t const instanceStart;\n  //   uint32_t const instanceSize;\n  //   uint32_t const reserved;  // only when building for 64bit targets\n  //   const uint8_t * const ivarLayout;\n  //   const char *const name;\n  //   const struct _method_list_t * const baseMethods;\n  //   const struct _objc_protocol_list *const baseProtocols;\n  //   const struct _ivar_list_t *const ivars;\n  //   const uint8_t * const weakIvarLayout;\n  //   const struct _prop_list_t * const properties;\n  // }\n\n  // FIXME. Add 'reserved' field in 64bit abi mode!\n  ClassRonfABITy = llvm::StructType::create(\n      \"struct._class_ro_t\", IntTy, IntTy, IntTy, Int8PtrTy, Int8PtrTy,\n      MethodListnfABIPtrTy, ProtocolListnfABIPtrTy, IvarListnfABIPtrTy,\n      Int8PtrTy, PropertyListPtrTy);\n\n  // ImpnfABITy - LLVM for id (*)(id, SEL, ...)\n  llvm::Type *params[] = { ObjectPtrTy, SelectorPtrTy };\n  ImpnfABITy = llvm::FunctionType::get(ObjectPtrTy, params, false)\n                 ->getPointerTo();\n\n  // struct _class_t {\n  //   struct _class_t *isa;\n  //   struct _class_t * const superclass;\n  //   void *cache;\n  //   IMP *vtable;\n  //   struct class_ro_t *ro;\n  // }\n\n  ClassnfABITy = llvm::StructType::create(VMContext, \"struct._class_t\");\n  ClassnfABITy->setBody(llvm::PointerType::getUnqual(ClassnfABITy),\n                        llvm::PointerType::getUnqual(ClassnfABITy), CachePtrTy,\n                        llvm::PointerType::getUnqual(ImpnfABITy),\n                        llvm::PointerType::getUnqual(ClassRonfABITy));\n\n  // LLVM for struct _class_t *\n  ClassnfABIPtrTy = llvm::PointerType::getUnqual(ClassnfABITy);\n\n  // struct _category_t {\n  //   const char * const name;\n  //   struct _class_t *const cls;\n  //   const struct _method_list_t * const instance_methods;\n  //   const struct _method_list_t * const class_methods;\n  //   const struct _protocol_list_t * const protocols;\n  //   const struct _prop_list_t * const properties;\n  //   const struct _prop_list_t * const class_properties;\n  //   const uint32_t size;\n  // }\n  CategorynfABITy = llvm::StructType::create(\n      \"struct._category_t\", Int8PtrTy, ClassnfABIPtrTy, MethodListnfABIPtrTy,\n      MethodListnfABIPtrTy, ProtocolListnfABIPtrTy, PropertyListPtrTy,\n      PropertyListPtrTy, IntTy);\n\n  // New types for nonfragile abi messaging.\n  CodeGen::CodeGenTypes &Types = CGM.getTypes();\n  ASTContext &Ctx = CGM.getContext();\n\n  // MessageRefTy - LLVM for:\n  // struct _message_ref_t {\n  //   IMP messenger;\n  //   SEL name;\n  // };\n\n  // First the clang type for struct _message_ref_t\n  RecordDecl *RD = RecordDecl::Create(Ctx, TTK_Struct,\n                                      Ctx.getTranslationUnitDecl(),\n                                      SourceLocation(), SourceLocation(),\n                                      &Ctx.Idents.get(\"_message_ref_t\"));\n  RD->addDecl(FieldDecl::Create(Ctx, RD, SourceLocation(), SourceLocation(),\n                                nullptr, Ctx.VoidPtrTy, nullptr, nullptr, false,\n                                ICIS_NoInit));\n  RD->addDecl(FieldDecl::Create(Ctx, RD, SourceLocation(), SourceLocation(),\n                                nullptr, Ctx.getObjCSelType(), nullptr, nullptr,\n                                false, ICIS_NoInit));\n  RD->completeDefinition();\n\n  MessageRefCTy = Ctx.getTagDeclType(RD);\n  MessageRefCPtrTy = Ctx.getPointerType(MessageRefCTy);\n  MessageRefTy = cast<llvm::StructType>(Types.ConvertType(MessageRefCTy));\n\n  // MessageRefPtrTy - LLVM for struct _message_ref_t*\n  MessageRefPtrTy = llvm::PointerType::getUnqual(MessageRefTy);\n\n  // SuperMessageRefTy - LLVM for:\n  // struct _super_message_ref_t {\n  //   SUPER_IMP messenger;\n  //   SEL name;\n  // };\n  SuperMessageRefTy = llvm::StructType::create(\"struct._super_message_ref_t\",\n                                               ImpnfABITy, SelectorPtrTy);\n\n  // SuperMessageRefPtrTy - LLVM for struct _super_message_ref_t*\n  SuperMessageRefPtrTy = llvm::PointerType::getUnqual(SuperMessageRefTy);\n\n\n  // struct objc_typeinfo {\n  //   const void** vtable; // objc_ehtype_vtable + 2\n  //   const char*  name;    // c++ typeinfo string\n  //   Class        cls;\n  // };\n  EHTypeTy = llvm::StructType::create(\"struct._objc_typeinfo\",\n                                      llvm::PointerType::getUnqual(Int8PtrTy),\n                                      Int8PtrTy, ClassnfABIPtrTy);\n  EHTypePtrTy = llvm::PointerType::getUnqual(EHTypeTy);\n}\n\nllvm::Function *CGObjCNonFragileABIMac::ModuleInitFunction() {\n  FinishNonFragileABIModule();\n\n  return nullptr;\n}\n\nvoid CGObjCNonFragileABIMac::AddModuleClassList(\n    ArrayRef<llvm::GlobalValue *> Container, StringRef SymbolName,\n    StringRef SectionName) {\n  unsigned NumClasses = Container.size();\n\n  if (!NumClasses)\n    return;\n\n  SmallVector<llvm::Constant*, 8> Symbols(NumClasses);\n  for (unsigned i=0; i<NumClasses; i++)\n    Symbols[i] = llvm::ConstantExpr::getBitCast(Container[i],\n                                                ObjCTypes.Int8PtrTy);\n  llvm::Constant *Init =\n    llvm::ConstantArray::get(llvm::ArrayType::get(ObjCTypes.Int8PtrTy,\n                                                  Symbols.size()),\n                             Symbols);\n\n  // Section name is obtained by calling GetSectionName, which returns\n  // sections in the __DATA segment on MachO.\n  assert((!CGM.getTriple().isOSBinFormatMachO() ||\n          SectionName.startswith(\"__DATA\")) &&\n         \"SectionName expected to start with __DATA on MachO\");\n  llvm::GlobalVariable *GV = new llvm::GlobalVariable(\n      CGM.getModule(), Init->getType(), false,\n      llvm::GlobalValue::PrivateLinkage, Init, SymbolName);\n  GV->setAlignment(\n      llvm::Align(CGM.getDataLayout().getABITypeAlignment(Init->getType())));\n  GV->setSection(SectionName);\n  CGM.addCompilerUsedGlobal(GV);\n}\n\nvoid CGObjCNonFragileABIMac::FinishNonFragileABIModule() {\n  // nonfragile abi has no module definition.\n\n  // Build list of all implemented class addresses in array\n  // L_OBJC_LABEL_CLASS_$.\n\n  for (unsigned i=0, NumClasses=ImplementedClasses.size(); i<NumClasses; i++) {\n    const ObjCInterfaceDecl *ID = ImplementedClasses[i];\n    assert(ID);\n    if (ObjCImplementationDecl *IMP = ID->getImplementation())\n      // We are implementing a weak imported interface. Give it external linkage\n      if (ID->isWeakImported() && !IMP->isWeakImported()) {\n        DefinedClasses[i]->setLinkage(llvm::GlobalVariable::ExternalLinkage);\n        DefinedMetaClasses[i]->setLinkage(llvm::GlobalVariable::ExternalLinkage);\n      }\n  }\n\n  AddModuleClassList(DefinedClasses, \"OBJC_LABEL_CLASS_$\",\n                     GetSectionName(\"__objc_classlist\",\n                                    \"regular,no_dead_strip\"));\n\n  AddModuleClassList(DefinedNonLazyClasses, \"OBJC_LABEL_NONLAZY_CLASS_$\",\n                     GetSectionName(\"__objc_nlclslist\",\n                                    \"regular,no_dead_strip\"));\n\n  // Build list of all implemented category addresses in array\n  // L_OBJC_LABEL_CATEGORY_$.\n  AddModuleClassList(DefinedCategories, \"OBJC_LABEL_CATEGORY_$\",\n                     GetSectionName(\"__objc_catlist\",\n                                    \"regular,no_dead_strip\"));\n  AddModuleClassList(DefinedStubCategories, \"OBJC_LABEL_STUB_CATEGORY_$\",\n                     GetSectionName(\"__objc_catlist2\",\n                                    \"regular,no_dead_strip\"));\n  AddModuleClassList(DefinedNonLazyCategories, \"OBJC_LABEL_NONLAZY_CATEGORY_$\",\n                     GetSectionName(\"__objc_nlcatlist\",\n                                    \"regular,no_dead_strip\"));\n\n  EmitImageInfo();\n}\n\n/// isVTableDispatchedSelector - Returns true if SEL is not in the list of\n/// VTableDispatchMethods; false otherwise. What this means is that\n/// except for the 19 selectors in the list, we generate 32bit-style\n/// message dispatch call for all the rest.\nbool CGObjCNonFragileABIMac::isVTableDispatchedSelector(Selector Sel) {\n  // At various points we've experimented with using vtable-based\n  // dispatch for all methods.\n  switch (CGM.getCodeGenOpts().getObjCDispatchMethod()) {\n  case CodeGenOptions::Legacy:\n    return false;\n  case CodeGenOptions::NonLegacy:\n    return true;\n  case CodeGenOptions::Mixed:\n    break;\n  }\n\n  // If so, see whether this selector is in the white-list of things which must\n  // use the new dispatch convention. We lazily build a dense set for this.\n  if (VTableDispatchMethods.empty()) {\n    VTableDispatchMethods.insert(GetNullarySelector(\"alloc\"));\n    VTableDispatchMethods.insert(GetNullarySelector(\"class\"));\n    VTableDispatchMethods.insert(GetNullarySelector(\"self\"));\n    VTableDispatchMethods.insert(GetNullarySelector(\"isFlipped\"));\n    VTableDispatchMethods.insert(GetNullarySelector(\"length\"));\n    VTableDispatchMethods.insert(GetNullarySelector(\"count\"));\n\n    // These are vtable-based if GC is disabled.\n    // Optimistically use vtable dispatch for hybrid compiles.\n    if (CGM.getLangOpts().getGC() != LangOptions::GCOnly) {\n      VTableDispatchMethods.insert(GetNullarySelector(\"retain\"));\n      VTableDispatchMethods.insert(GetNullarySelector(\"release\"));\n      VTableDispatchMethods.insert(GetNullarySelector(\"autorelease\"));\n    }\n\n    VTableDispatchMethods.insert(GetUnarySelector(\"allocWithZone\"));\n    VTableDispatchMethods.insert(GetUnarySelector(\"isKindOfClass\"));\n    VTableDispatchMethods.insert(GetUnarySelector(\"respondsToSelector\"));\n    VTableDispatchMethods.insert(GetUnarySelector(\"objectForKey\"));\n    VTableDispatchMethods.insert(GetUnarySelector(\"objectAtIndex\"));\n    VTableDispatchMethods.insert(GetUnarySelector(\"isEqualToString\"));\n    VTableDispatchMethods.insert(GetUnarySelector(\"isEqual\"));\n\n    // These are vtable-based if GC is enabled.\n    // Optimistically use vtable dispatch for hybrid compiles.\n    if (CGM.getLangOpts().getGC() != LangOptions::NonGC) {\n      VTableDispatchMethods.insert(GetNullarySelector(\"hash\"));\n      VTableDispatchMethods.insert(GetUnarySelector(\"addObject\"));\n\n      // \"countByEnumeratingWithState:objects:count\"\n      IdentifierInfo *KeyIdents[] = {\n        &CGM.getContext().Idents.get(\"countByEnumeratingWithState\"),\n        &CGM.getContext().Idents.get(\"objects\"),\n        &CGM.getContext().Idents.get(\"count\")\n      };\n      VTableDispatchMethods.insert(\n        CGM.getContext().Selectors.getSelector(3, KeyIdents));\n    }\n  }\n\n  return VTableDispatchMethods.count(Sel);\n}\n\n/// BuildClassRoTInitializer - generate meta-data for:\n/// struct _class_ro_t {\n///   uint32_t const flags;\n///   uint32_t const instanceStart;\n///   uint32_t const instanceSize;\n///   uint32_t const reserved;  // only when building for 64bit targets\n///   const uint8_t * const ivarLayout;\n///   const char *const name;\n///   const struct _method_list_t * const baseMethods;\n///   const struct _protocol_list_t *const baseProtocols;\n///   const struct _ivar_list_t *const ivars;\n///   const uint8_t * const weakIvarLayout;\n///   const struct _prop_list_t * const properties;\n/// }\n///\nllvm::GlobalVariable * CGObjCNonFragileABIMac::BuildClassRoTInitializer(\n  unsigned flags,\n  unsigned InstanceStart,\n  unsigned InstanceSize,\n  const ObjCImplementationDecl *ID) {\n  std::string ClassName = std::string(ID->getObjCRuntimeNameAsString());\n\n  CharUnits beginInstance = CharUnits::fromQuantity(InstanceStart);\n  CharUnits endInstance = CharUnits::fromQuantity(InstanceSize);\n\n  bool hasMRCWeak = false;\n  if (CGM.getLangOpts().ObjCAutoRefCount)\n    flags |= NonFragileABI_Class_CompiledByARC;\n  else if ((hasMRCWeak = hasMRCWeakIvars(CGM, ID)))\n    flags |= NonFragileABI_Class_HasMRCWeakIvars;\n\n  ConstantInitBuilder builder(CGM);\n  auto values = builder.beginStruct(ObjCTypes.ClassRonfABITy);\n\n  values.addInt(ObjCTypes.IntTy, flags);\n  values.addInt(ObjCTypes.IntTy, InstanceStart);\n  values.addInt(ObjCTypes.IntTy, InstanceSize);\n  values.add((flags & NonFragileABI_Class_Meta)\n                ? GetIvarLayoutName(nullptr, ObjCTypes)\n                : BuildStrongIvarLayout(ID, beginInstance, endInstance));\n  values.add(GetClassName(ID->getObjCRuntimeNameAsString()));\n\n  // const struct _method_list_t * const baseMethods;\n  SmallVector<const ObjCMethodDecl*, 16> methods;\n  if (flags & NonFragileABI_Class_Meta) {\n    for (const auto *MD : ID->class_methods())\n      if (!MD->isDirectMethod())\n        methods.push_back(MD);\n  } else {\n    for (const auto *MD : ID->instance_methods())\n      if (!MD->isDirectMethod())\n        methods.push_back(MD);\n  }\n\n  values.add(emitMethodList(ID->getObjCRuntimeNameAsString(),\n                            (flags & NonFragileABI_Class_Meta)\n                               ? MethodListType::ClassMethods\n                               : MethodListType::InstanceMethods,\n                            methods));\n\n  const ObjCInterfaceDecl *OID = ID->getClassInterface();\n  assert(OID && \"CGObjCNonFragileABIMac::BuildClassRoTInitializer\");\n  values.add(EmitProtocolList(\"_OBJC_CLASS_PROTOCOLS_$_\"\n                                + OID->getObjCRuntimeNameAsString(),\n                              OID->all_referenced_protocol_begin(),\n                              OID->all_referenced_protocol_end()));\n\n  if (flags & NonFragileABI_Class_Meta) {\n    values.addNullPointer(ObjCTypes.IvarListnfABIPtrTy);\n    values.add(GetIvarLayoutName(nullptr, ObjCTypes));\n    values.add(EmitPropertyList(\n        \"_OBJC_$_CLASS_PROP_LIST_\" + ID->getObjCRuntimeNameAsString(),\n        ID, ID->getClassInterface(), ObjCTypes, true));\n  } else {\n    values.add(EmitIvarList(ID));\n    values.add(BuildWeakIvarLayout(ID, beginInstance, endInstance, hasMRCWeak));\n    values.add(EmitPropertyList(\n        \"_OBJC_$_PROP_LIST_\" + ID->getObjCRuntimeNameAsString(),\n        ID, ID->getClassInterface(), ObjCTypes, false));\n  }\n\n  llvm::SmallString<64> roLabel;\n  llvm::raw_svector_ostream(roLabel)\n      << ((flags & NonFragileABI_Class_Meta) ? \"_OBJC_METACLASS_RO_$_\"\n                                             : \"_OBJC_CLASS_RO_$_\")\n      << ClassName;\n\n  return finishAndCreateGlobal(values, roLabel, CGM);\n}\n\n/// Build the metaclass object for a class.\n///\n/// struct _class_t {\n///   struct _class_t *isa;\n///   struct _class_t * const superclass;\n///   void *cache;\n///   IMP *vtable;\n///   struct class_ro_t *ro;\n/// }\n///\nllvm::GlobalVariable *\nCGObjCNonFragileABIMac::BuildClassObject(const ObjCInterfaceDecl *CI,\n                                         bool isMetaclass,\n                                         llvm::Constant *IsAGV,\n                                         llvm::Constant *SuperClassGV,\n                                         llvm::Constant *ClassRoGV,\n                                         bool HiddenVisibility) {\n  ConstantInitBuilder builder(CGM);\n  auto values = builder.beginStruct(ObjCTypes.ClassnfABITy);\n  values.add(IsAGV);\n  if (SuperClassGV) {\n    values.add(SuperClassGV);\n  } else {\n    values.addNullPointer(ObjCTypes.ClassnfABIPtrTy);\n  }\n  values.add(ObjCEmptyCacheVar);\n  values.add(ObjCEmptyVtableVar);\n  values.add(ClassRoGV);\n\n  llvm::GlobalVariable *GV =\n    cast<llvm::GlobalVariable>(GetClassGlobal(CI, isMetaclass, ForDefinition));\n  values.finishAndSetAsInitializer(GV);\n\n  if (CGM.getTriple().isOSBinFormatMachO())\n    GV->setSection(\"__DATA, __objc_data\");\n  GV->setAlignment(llvm::Align(\n      CGM.getDataLayout().getABITypeAlignment(ObjCTypes.ClassnfABITy)));\n  if (!CGM.getTriple().isOSBinFormatCOFF())\n    if (HiddenVisibility)\n      GV->setVisibility(llvm::GlobalValue::HiddenVisibility);\n  return GV;\n}\n\nbool CGObjCNonFragileABIMac::ImplementationIsNonLazy(\n    const ObjCImplDecl *OD) const {\n  return OD->getClassMethod(GetNullarySelector(\"load\")) != nullptr ||\n         OD->getClassInterface()->hasAttr<ObjCNonLazyClassAttr>() ||\n         OD->hasAttr<ObjCNonLazyClassAttr>();\n}\n\nvoid CGObjCNonFragileABIMac::GetClassSizeInfo(const ObjCImplementationDecl *OID,\n                                              uint32_t &InstanceStart,\n                                              uint32_t &InstanceSize) {\n  const ASTRecordLayout &RL =\n    CGM.getContext().getASTObjCImplementationLayout(OID);\n\n  // InstanceSize is really instance end.\n  InstanceSize = RL.getDataSize().getQuantity();\n\n  // If there are no fields, the start is the same as the end.\n  if (!RL.getFieldCount())\n    InstanceStart = InstanceSize;\n  else\n    InstanceStart = RL.getFieldOffset(0) / CGM.getContext().getCharWidth();\n}\n\nstatic llvm::GlobalValue::DLLStorageClassTypes getStorage(CodeGenModule &CGM,\n                                                          StringRef Name) {\n  IdentifierInfo &II = CGM.getContext().Idents.get(Name);\n  TranslationUnitDecl *TUDecl = CGM.getContext().getTranslationUnitDecl();\n  DeclContext *DC = TranslationUnitDecl::castToDeclContext(TUDecl);\n\n  const VarDecl *VD = nullptr;\n  for (const auto &Result : DC->lookup(&II))\n    if ((VD = dyn_cast<VarDecl>(Result)))\n      break;\n\n  if (!VD)\n    return llvm::GlobalValue::DLLImportStorageClass;\n  if (VD->hasAttr<DLLExportAttr>())\n    return llvm::GlobalValue::DLLExportStorageClass;\n  if (VD->hasAttr<DLLImportAttr>())\n    return llvm::GlobalValue::DLLImportStorageClass;\n  return llvm::GlobalValue::DefaultStorageClass;\n}\n\nvoid CGObjCNonFragileABIMac::GenerateClass(const ObjCImplementationDecl *ID) {\n  if (!ObjCEmptyCacheVar) {\n    ObjCEmptyCacheVar =\n        new llvm::GlobalVariable(CGM.getModule(), ObjCTypes.CacheTy, false,\n                                 llvm::GlobalValue::ExternalLinkage, nullptr,\n                                 \"_objc_empty_cache\");\n    if (CGM.getTriple().isOSBinFormatCOFF())\n      ObjCEmptyCacheVar->setDLLStorageClass(getStorage(CGM, \"_objc_empty_cache\"));\n\n    // Only OS X with deployment version <10.9 use the empty vtable symbol\n    const llvm::Triple &Triple = CGM.getTarget().getTriple();\n    if (Triple.isMacOSX() && Triple.isMacOSXVersionLT(10, 9))\n      ObjCEmptyVtableVar =\n          new llvm::GlobalVariable(CGM.getModule(), ObjCTypes.ImpnfABITy, false,\n                                   llvm::GlobalValue::ExternalLinkage, nullptr,\n                                   \"_objc_empty_vtable\");\n    else\n      ObjCEmptyVtableVar =\n        llvm::ConstantPointerNull::get(ObjCTypes.ImpnfABITy->getPointerTo());\n  }\n\n  // FIXME: Is this correct (that meta class size is never computed)?\n  uint32_t InstanceStart =\n    CGM.getDataLayout().getTypeAllocSize(ObjCTypes.ClassnfABITy);\n  uint32_t InstanceSize = InstanceStart;\n  uint32_t flags = NonFragileABI_Class_Meta;\n\n  llvm::Constant *SuperClassGV, *IsAGV;\n\n  const auto *CI = ID->getClassInterface();\n  assert(CI && \"CGObjCNonFragileABIMac::GenerateClass - class is 0\");\n\n  // Build the flags for the metaclass.\n  bool classIsHidden = (CGM.getTriple().isOSBinFormatCOFF())\n                           ? !CI->hasAttr<DLLExportAttr>()\n                           : CI->getVisibility() == HiddenVisibility;\n  if (classIsHidden)\n    flags |= NonFragileABI_Class_Hidden;\n\n  // FIXME: why is this flag set on the metaclass?\n  // ObjC metaclasses have no fields and don't really get constructed.\n  if (ID->hasNonZeroConstructors() || ID->hasDestructors()) {\n    flags |= NonFragileABI_Class_HasCXXStructors;\n    if (!ID->hasNonZeroConstructors())\n      flags |= NonFragileABI_Class_HasCXXDestructorOnly;\n  }\n\n  if (!CI->getSuperClass()) {\n    // class is root\n    flags |= NonFragileABI_Class_Root;\n\n    SuperClassGV = GetClassGlobal(CI, /*metaclass*/ false, NotForDefinition);\n    IsAGV = GetClassGlobal(CI, /*metaclass*/ true, NotForDefinition);\n  } else {\n    // Has a root. Current class is not a root.\n    const ObjCInterfaceDecl *Root = ID->getClassInterface();\n    while (const ObjCInterfaceDecl *Super = Root->getSuperClass())\n      Root = Super;\n\n    const auto *Super = CI->getSuperClass();\n    IsAGV = GetClassGlobal(Root, /*metaclass*/ true, NotForDefinition);\n    SuperClassGV = GetClassGlobal(Super, /*metaclass*/ true, NotForDefinition);\n  }\n\n  llvm::GlobalVariable *CLASS_RO_GV =\n      BuildClassRoTInitializer(flags, InstanceStart, InstanceSize, ID);\n\n  llvm::GlobalVariable *MetaTClass =\n    BuildClassObject(CI, /*metaclass*/ true,\n                     IsAGV, SuperClassGV, CLASS_RO_GV, classIsHidden);\n  CGM.setGVProperties(MetaTClass, CI);\n  DefinedMetaClasses.push_back(MetaTClass);\n\n  // Metadata for the class\n  flags = 0;\n  if (classIsHidden)\n    flags |= NonFragileABI_Class_Hidden;\n\n  if (ID->hasNonZeroConstructors() || ID->hasDestructors()) {\n    flags |= NonFragileABI_Class_HasCXXStructors;\n\n    // Set a flag to enable a runtime optimization when a class has\n    // fields that require destruction but which don't require\n    // anything except zero-initialization during construction.  This\n    // is most notably true of __strong and __weak types, but you can\n    // also imagine there being C++ types with non-trivial default\n    // constructors that merely set all fields to null.\n    if (!ID->hasNonZeroConstructors())\n      flags |= NonFragileABI_Class_HasCXXDestructorOnly;\n  }\n\n  if (hasObjCExceptionAttribute(CGM.getContext(), CI))\n    flags |= NonFragileABI_Class_Exception;\n\n  if (!CI->getSuperClass()) {\n    flags |= NonFragileABI_Class_Root;\n    SuperClassGV = nullptr;\n  } else {\n    // Has a root. Current class is not a root.\n    const auto *Super = CI->getSuperClass();\n    SuperClassGV = GetClassGlobal(Super, /*metaclass*/ false, NotForDefinition);\n  }\n\n  GetClassSizeInfo(ID, InstanceStart, InstanceSize);\n  CLASS_RO_GV =\n      BuildClassRoTInitializer(flags, InstanceStart, InstanceSize, ID);\n\n  llvm::GlobalVariable *ClassMD =\n    BuildClassObject(CI, /*metaclass*/ false,\n                     MetaTClass, SuperClassGV, CLASS_RO_GV, classIsHidden);\n  CGM.setGVProperties(ClassMD, CI);\n  DefinedClasses.push_back(ClassMD);\n  ImplementedClasses.push_back(CI);\n\n  // Determine if this class is also \"non-lazy\".\n  if (ImplementationIsNonLazy(ID))\n    DefinedNonLazyClasses.push_back(ClassMD);\n\n  // Force the definition of the EHType if necessary.\n  if (flags & NonFragileABI_Class_Exception)\n    (void) GetInterfaceEHType(CI, ForDefinition);\n  // Make sure method definition entries are all clear for next implementation.\n  MethodDefinitions.clear();\n}\n\n/// GenerateProtocolRef - This routine is called to generate code for\n/// a protocol reference expression; as in:\n/// @code\n///   @protocol(Proto1);\n/// @endcode\n/// It generates a weak reference to l_OBJC_PROTOCOL_REFERENCE_$_Proto1\n/// which will hold address of the protocol meta-data.\n///\nllvm::Value *CGObjCNonFragileABIMac::GenerateProtocolRef(CodeGenFunction &CGF,\n                                                         const ObjCProtocolDecl *PD) {\n\n  // This routine is called for @protocol only. So, we must build definition\n  // of protocol's meta-data (not a reference to it!)\n  assert(!PD->isNonRuntimeProtocol() &&\n         \"attempting to get a protocol ref to a static protocol.\");\n  llvm::Constant *Init =\n    llvm::ConstantExpr::getBitCast(GetOrEmitProtocol(PD),\n                                   ObjCTypes.getExternalProtocolPtrTy());\n\n  std::string ProtocolName(\"_OBJC_PROTOCOL_REFERENCE_$_\");\n  ProtocolName += PD->getObjCRuntimeNameAsString();\n\n  CharUnits Align = CGF.getPointerAlign();\n\n  llvm::GlobalVariable *PTGV = CGM.getModule().getGlobalVariable(ProtocolName);\n  if (PTGV)\n    return CGF.Builder.CreateAlignedLoad(PTGV, Align);\n  PTGV = new llvm::GlobalVariable(CGM.getModule(), Init->getType(), false,\n                                  llvm::GlobalValue::WeakAnyLinkage, Init,\n                                  ProtocolName);\n  PTGV->setSection(GetSectionName(\"__objc_protorefs\",\n                                  \"coalesced,no_dead_strip\"));\n  PTGV->setVisibility(llvm::GlobalValue::HiddenVisibility);\n  PTGV->setAlignment(Align.getAsAlign());\n  if (!CGM.getTriple().isOSBinFormatMachO())\n    PTGV->setComdat(CGM.getModule().getOrInsertComdat(ProtocolName));\n  CGM.addUsedGlobal(PTGV);\n  return CGF.Builder.CreateAlignedLoad(PTGV, Align);\n}\n\n/// GenerateCategory - Build metadata for a category implementation.\n/// struct _category_t {\n///   const char * const name;\n///   struct _class_t *const cls;\n///   const struct _method_list_t * const instance_methods;\n///   const struct _method_list_t * const class_methods;\n///   const struct _protocol_list_t * const protocols;\n///   const struct _prop_list_t * const properties;\n///   const struct _prop_list_t * const class_properties;\n///   const uint32_t size;\n/// }\n///\nvoid CGObjCNonFragileABIMac::GenerateCategory(const ObjCCategoryImplDecl *OCD) {\n  const ObjCInterfaceDecl *Interface = OCD->getClassInterface();\n  const char *Prefix = \"_OBJC_$_CATEGORY_\";\n\n  llvm::SmallString<64> ExtCatName(Prefix);\n  ExtCatName += Interface->getObjCRuntimeNameAsString();\n  ExtCatName += \"_$_\";\n  ExtCatName += OCD->getNameAsString();\n\n  ConstantInitBuilder builder(CGM);\n  auto values = builder.beginStruct(ObjCTypes.CategorynfABITy);\n  values.add(GetClassName(OCD->getIdentifier()->getName()));\n  // meta-class entry symbol\n  values.add(GetClassGlobal(Interface, /*metaclass*/ false, NotForDefinition));\n  std::string listName =\n      (Interface->getObjCRuntimeNameAsString() + \"_$_\" + OCD->getName()).str();\n\n  SmallVector<const ObjCMethodDecl *, 16> instanceMethods;\n  SmallVector<const ObjCMethodDecl *, 8> classMethods;\n  for (const auto *MD : OCD->methods()) {\n    if (MD->isDirectMethod())\n      continue;\n    if (MD->isInstanceMethod()) {\n      instanceMethods.push_back(MD);\n    } else {\n      classMethods.push_back(MD);\n    }\n  }\n\n  values.add(emitMethodList(listName, MethodListType::CategoryInstanceMethods,\n                            instanceMethods));\n  values.add(emitMethodList(listName, MethodListType::CategoryClassMethods,\n                            classMethods));\n\n  const ObjCCategoryDecl *Category =\n    Interface->FindCategoryDeclaration(OCD->getIdentifier());\n  if (Category) {\n    SmallString<256> ExtName;\n    llvm::raw_svector_ostream(ExtName) << Interface->getObjCRuntimeNameAsString() << \"_$_\"\n                                       << OCD->getName();\n    values.add(EmitProtocolList(\"_OBJC_CATEGORY_PROTOCOLS_$_\"\n                                   + Interface->getObjCRuntimeNameAsString() + \"_$_\"\n                                   + Category->getName(),\n                                Category->protocol_begin(),\n                                Category->protocol_end()));\n    values.add(EmitPropertyList(\"_OBJC_$_PROP_LIST_\" + ExtName.str(),\n                                OCD, Category, ObjCTypes, false));\n    values.add(EmitPropertyList(\"_OBJC_$_CLASS_PROP_LIST_\" + ExtName.str(),\n                                OCD, Category, ObjCTypes, true));\n  } else {\n    values.addNullPointer(ObjCTypes.ProtocolListnfABIPtrTy);\n    values.addNullPointer(ObjCTypes.PropertyListPtrTy);\n    values.addNullPointer(ObjCTypes.PropertyListPtrTy);\n  }\n\n  unsigned Size = CGM.getDataLayout().getTypeAllocSize(ObjCTypes.CategorynfABITy);\n  values.addInt(ObjCTypes.IntTy, Size);\n\n  llvm::GlobalVariable *GCATV =\n      finishAndCreateGlobal(values, ExtCatName.str(), CGM);\n  CGM.addCompilerUsedGlobal(GCATV);\n  if (Interface->hasAttr<ObjCClassStubAttr>())\n    DefinedStubCategories.push_back(GCATV);\n  else\n    DefinedCategories.push_back(GCATV);\n\n  // Determine if this category is also \"non-lazy\".\n  if (ImplementationIsNonLazy(OCD))\n    DefinedNonLazyCategories.push_back(GCATV);\n  // method definition entries must be clear for next implementation.\n  MethodDefinitions.clear();\n}\n\n/// emitMethodConstant - Return a struct objc_method constant.  If\n/// forProtocol is true, the implementation will be null; otherwise,\n/// the method must have a definition registered with the runtime.\n///\n/// struct _objc_method {\n///   SEL _cmd;\n///   char *method_type;\n///   char *_imp;\n/// }\nvoid CGObjCNonFragileABIMac::emitMethodConstant(ConstantArrayBuilder &builder,\n                                                const ObjCMethodDecl *MD,\n                                                bool forProtocol) {\n  auto method = builder.beginStruct(ObjCTypes.MethodTy);\n  method.addBitCast(GetMethodVarName(MD->getSelector()),\n                    ObjCTypes.SelectorPtrTy);\n  method.add(GetMethodVarType(MD));\n\n  if (forProtocol) {\n    // Protocol methods have no implementation. So, this entry is always NULL.\n    method.addNullPointer(ObjCTypes.Int8PtrTy);\n  } else {\n    llvm::Function *fn = GetMethodDefinition(MD);\n    assert(fn && \"no definition for method?\");\n    method.addBitCast(fn, ObjCTypes.Int8PtrTy);\n  }\n\n  method.finishAndAddTo(builder);\n}\n\n/// Build meta-data for method declarations.\n///\n/// struct _method_list_t {\n///   uint32_t entsize;  // sizeof(struct _objc_method)\n///   uint32_t method_count;\n///   struct _objc_method method_list[method_count];\n/// }\n///\nllvm::Constant *\nCGObjCNonFragileABIMac::emitMethodList(Twine name, MethodListType kind,\n                              ArrayRef<const ObjCMethodDecl *> methods) {\n  // Return null for empty list.\n  if (methods.empty())\n    return llvm::Constant::getNullValue(ObjCTypes.MethodListnfABIPtrTy);\n\n  StringRef prefix;\n  bool forProtocol;\n  switch (kind) {\n  case MethodListType::CategoryInstanceMethods:\n    prefix = \"_OBJC_$_CATEGORY_INSTANCE_METHODS_\";\n    forProtocol = false;\n    break;\n  case MethodListType::CategoryClassMethods:\n    prefix = \"_OBJC_$_CATEGORY_CLASS_METHODS_\";\n    forProtocol = false;\n    break;\n  case MethodListType::InstanceMethods:\n    prefix = \"_OBJC_$_INSTANCE_METHODS_\";\n    forProtocol = false;\n    break;\n  case MethodListType::ClassMethods:\n    prefix = \"_OBJC_$_CLASS_METHODS_\";\n    forProtocol = false;\n    break;\n\n  case MethodListType::ProtocolInstanceMethods:\n    prefix = \"_OBJC_$_PROTOCOL_INSTANCE_METHODS_\";\n    forProtocol = true;\n    break;\n  case MethodListType::ProtocolClassMethods:\n    prefix = \"_OBJC_$_PROTOCOL_CLASS_METHODS_\";\n    forProtocol = true;\n    break;\n  case MethodListType::OptionalProtocolInstanceMethods:\n    prefix = \"_OBJC_$_PROTOCOL_INSTANCE_METHODS_OPT_\";\n    forProtocol = true;\n    break;\n  case MethodListType::OptionalProtocolClassMethods:\n    prefix = \"_OBJC_$_PROTOCOL_CLASS_METHODS_OPT_\";\n    forProtocol = true;\n    break;\n  }\n\n  ConstantInitBuilder builder(CGM);\n  auto values = builder.beginStruct();\n\n  // sizeof(struct _objc_method)\n  unsigned Size = CGM.getDataLayout().getTypeAllocSize(ObjCTypes.MethodTy);\n  values.addInt(ObjCTypes.IntTy, Size);\n  // method_count\n  values.addInt(ObjCTypes.IntTy, methods.size());\n  auto methodArray = values.beginArray(ObjCTypes.MethodTy);\n  for (auto MD : methods)\n    emitMethodConstant(methodArray, MD, forProtocol);\n  methodArray.finishAndAddTo(values);\n\n  llvm::GlobalVariable *GV = finishAndCreateGlobal(values, prefix + name, CGM);\n  CGM.addCompilerUsedGlobal(GV);\n  return llvm::ConstantExpr::getBitCast(GV, ObjCTypes.MethodListnfABIPtrTy);\n}\n\n/// ObjCIvarOffsetVariable - Returns the ivar offset variable for\n/// the given ivar.\nllvm::GlobalVariable *\nCGObjCNonFragileABIMac::ObjCIvarOffsetVariable(const ObjCInterfaceDecl *ID,\n                                               const ObjCIvarDecl *Ivar) {\n  const ObjCInterfaceDecl *Container = Ivar->getContainingInterface();\n  llvm::SmallString<64> Name(\"OBJC_IVAR_$_\");\n  Name += Container->getObjCRuntimeNameAsString();\n  Name += \".\";\n  Name += Ivar->getName();\n  llvm::GlobalVariable *IvarOffsetGV = CGM.getModule().getGlobalVariable(Name);\n  if (!IvarOffsetGV) {\n    IvarOffsetGV =\n        new llvm::GlobalVariable(CGM.getModule(), ObjCTypes.IvarOffsetVarTy,\n                                 false, llvm::GlobalValue::ExternalLinkage,\n                                 nullptr, Name.str());\n    if (CGM.getTriple().isOSBinFormatCOFF()) {\n      bool IsPrivateOrPackage =\n          Ivar->getAccessControl() == ObjCIvarDecl::Private ||\n          Ivar->getAccessControl() == ObjCIvarDecl::Package;\n\n      const ObjCInterfaceDecl *ContainingID = Ivar->getContainingInterface();\n\n      if (ContainingID->hasAttr<DLLImportAttr>())\n        IvarOffsetGV\n            ->setDLLStorageClass(llvm::GlobalValue::DLLImportStorageClass);\n      else if (ContainingID->hasAttr<DLLExportAttr>() && !IsPrivateOrPackage)\n        IvarOffsetGV\n            ->setDLLStorageClass(llvm::GlobalValue::DLLExportStorageClass);\n    }\n  }\n  return IvarOffsetGV;\n}\n\nllvm::Constant *\nCGObjCNonFragileABIMac::EmitIvarOffsetVar(const ObjCInterfaceDecl *ID,\n                                          const ObjCIvarDecl *Ivar,\n                                          unsigned long int Offset) {\n  llvm::GlobalVariable *IvarOffsetGV = ObjCIvarOffsetVariable(ID, Ivar);\n  IvarOffsetGV->setInitializer(\n      llvm::ConstantInt::get(ObjCTypes.IvarOffsetVarTy, Offset));\n  IvarOffsetGV->setAlignment(llvm::Align(\n      CGM.getDataLayout().getABITypeAlignment(ObjCTypes.IvarOffsetVarTy)));\n\n  if (!CGM.getTriple().isOSBinFormatCOFF()) {\n    // FIXME: This matches gcc, but shouldn't the visibility be set on the use\n    // as well (i.e., in ObjCIvarOffsetVariable).\n    if (Ivar->getAccessControl() == ObjCIvarDecl::Private ||\n        Ivar->getAccessControl() == ObjCIvarDecl::Package ||\n        ID->getVisibility() == HiddenVisibility)\n      IvarOffsetGV->setVisibility(llvm::GlobalValue::HiddenVisibility);\n    else\n      IvarOffsetGV->setVisibility(llvm::GlobalValue::DefaultVisibility);\n  }\n\n  // If ID's layout is known, then make the global constant. This serves as a\n  // useful assertion: we'll never use this variable to calculate ivar offsets,\n  // so if the runtime tries to patch it then we should crash.\n  if (isClassLayoutKnownStatically(ID))\n    IvarOffsetGV->setConstant(true);\n\n  if (CGM.getTriple().isOSBinFormatMachO())\n    IvarOffsetGV->setSection(\"__DATA, __objc_ivar\");\n  return IvarOffsetGV;\n}\n\n/// EmitIvarList - Emit the ivar list for the given\n/// implementation. The return value has type\n/// IvarListnfABIPtrTy.\n///  struct _ivar_t {\n///   unsigned [long] int *offset;  // pointer to ivar offset location\n///   char *name;\n///   char *type;\n///   uint32_t alignment;\n///   uint32_t size;\n/// }\n/// struct _ivar_list_t {\n///   uint32 entsize;  // sizeof(struct _ivar_t)\n///   uint32 count;\n///   struct _iver_t list[count];\n/// }\n///\n\nllvm::Constant *CGObjCNonFragileABIMac::EmitIvarList(\n  const ObjCImplementationDecl *ID) {\n\n  ConstantInitBuilder builder(CGM);\n  auto ivarList = builder.beginStruct();\n  ivarList.addInt(ObjCTypes.IntTy,\n                  CGM.getDataLayout().getTypeAllocSize(ObjCTypes.IvarnfABITy));\n  auto ivarCountSlot = ivarList.addPlaceholder();\n  auto ivars = ivarList.beginArray(ObjCTypes.IvarnfABITy);\n\n  const ObjCInterfaceDecl *OID = ID->getClassInterface();\n  assert(OID && \"CGObjCNonFragileABIMac::EmitIvarList - null interface\");\n\n  // FIXME. Consolidate this with similar code in GenerateClass.\n\n  for (const ObjCIvarDecl *IVD = OID->all_declared_ivar_begin();\n       IVD; IVD = IVD->getNextIvar()) {\n    // Ignore unnamed bit-fields.\n    if (!IVD->getDeclName())\n      continue;\n\n    auto ivar = ivars.beginStruct(ObjCTypes.IvarnfABITy);\n    ivar.add(EmitIvarOffsetVar(ID->getClassInterface(), IVD,\n                               ComputeIvarBaseOffset(CGM, ID, IVD)));\n    ivar.add(GetMethodVarName(IVD->getIdentifier()));\n    ivar.add(GetMethodVarType(IVD));\n    llvm::Type *FieldTy =\n      CGM.getTypes().ConvertTypeForMem(IVD->getType());\n    unsigned Size = CGM.getDataLayout().getTypeAllocSize(FieldTy);\n    unsigned Align = CGM.getContext().getPreferredTypeAlign(\n      IVD->getType().getTypePtr()) >> 3;\n    Align = llvm::Log2_32(Align);\n    ivar.addInt(ObjCTypes.IntTy, Align);\n    // NOTE. Size of a bitfield does not match gcc's, because of the\n    // way bitfields are treated special in each. But I am told that\n    // 'size' for bitfield ivars is ignored by the runtime so it does\n    // not matter.  If it matters, there is enough info to get the\n    // bitfield right!\n    ivar.addInt(ObjCTypes.IntTy, Size);\n    ivar.finishAndAddTo(ivars);\n  }\n  // Return null for empty list.\n  if (ivars.empty()) {\n    ivars.abandon();\n    ivarList.abandon();\n    return llvm::Constant::getNullValue(ObjCTypes.IvarListnfABIPtrTy);\n  }\n\n  auto ivarCount = ivars.size();\n  ivars.finishAndAddTo(ivarList);\n  ivarList.fillPlaceholderWithInt(ivarCountSlot, ObjCTypes.IntTy, ivarCount);\n\n  const char *Prefix = \"_OBJC_$_INSTANCE_VARIABLES_\";\n  llvm::GlobalVariable *GV = finishAndCreateGlobal(\n      ivarList, Prefix + OID->getObjCRuntimeNameAsString(), CGM);\n  CGM.addCompilerUsedGlobal(GV);\n  return llvm::ConstantExpr::getBitCast(GV, ObjCTypes.IvarListnfABIPtrTy);\n}\n\nllvm::Constant *CGObjCNonFragileABIMac::GetOrEmitProtocolRef(\n  const ObjCProtocolDecl *PD) {\n  llvm::GlobalVariable *&Entry = Protocols[PD->getIdentifier()];\n\n  assert(!PD->isNonRuntimeProtocol() &&\n         \"attempting to GetOrEmit a non-runtime protocol\");\n  if (!Entry) {\n    // We use the initializer as a marker of whether this is a forward\n    // reference or not. At module finalization we add the empty\n    // contents for protocols which were referenced but never defined.\n    llvm::SmallString<64> Protocol;\n    llvm::raw_svector_ostream(Protocol) << \"_OBJC_PROTOCOL_$_\"\n                                        << PD->getObjCRuntimeNameAsString();\n\n    Entry = new llvm::GlobalVariable(CGM.getModule(), ObjCTypes.ProtocolnfABITy,\n                                     false, llvm::GlobalValue::ExternalLinkage,\n                                     nullptr, Protocol);\n    if (!CGM.getTriple().isOSBinFormatMachO())\n      Entry->setComdat(CGM.getModule().getOrInsertComdat(Protocol));\n  }\n\n  return Entry;\n}\n\n/// GetOrEmitProtocol - Generate the protocol meta-data:\n/// @code\n/// struct _protocol_t {\n///   id isa;  // NULL\n///   const char * const protocol_name;\n///   const struct _protocol_list_t * protocol_list; // super protocols\n///   const struct method_list_t * const instance_methods;\n///   const struct method_list_t * const class_methods;\n///   const struct method_list_t *optionalInstanceMethods;\n///   const struct method_list_t *optionalClassMethods;\n///   const struct _prop_list_t * properties;\n///   const uint32_t size;  // sizeof(struct _protocol_t)\n///   const uint32_t flags;  // = 0\n///   const char ** extendedMethodTypes;\n///   const char *demangledName;\n///   const struct _prop_list_t * class_properties;\n/// }\n/// @endcode\n///\n\nllvm::Constant *CGObjCNonFragileABIMac::GetOrEmitProtocol(\n  const ObjCProtocolDecl *PD) {\n  llvm::GlobalVariable *Entry = Protocols[PD->getIdentifier()];\n\n  // Early exit if a defining object has already been generated.\n  if (Entry && Entry->hasInitializer())\n    return Entry;\n\n  // Use the protocol definition, if there is one.\n  assert(PD->hasDefinition() &&\n         \"emitting protocol metadata without definition\");\n  PD = PD->getDefinition();\n\n  auto methodLists = ProtocolMethodLists::get(PD);\n\n  ConstantInitBuilder builder(CGM);\n  auto values = builder.beginStruct(ObjCTypes.ProtocolnfABITy);\n\n  // isa is NULL\n  values.addNullPointer(ObjCTypes.ObjectPtrTy);\n  values.add(GetClassName(PD->getObjCRuntimeNameAsString()));\n  values.add(EmitProtocolList(\"_OBJC_$_PROTOCOL_REFS_\"\n                                + PD->getObjCRuntimeNameAsString(),\n                               PD->protocol_begin(),\n                               PD->protocol_end()));\n  values.add(methodLists.emitMethodList(this, PD,\n                                 ProtocolMethodLists::RequiredInstanceMethods));\n  values.add(methodLists.emitMethodList(this, PD,\n                                 ProtocolMethodLists::RequiredClassMethods));\n  values.add(methodLists.emitMethodList(this, PD,\n                                 ProtocolMethodLists::OptionalInstanceMethods));\n  values.add(methodLists.emitMethodList(this, PD,\n                                 ProtocolMethodLists::OptionalClassMethods));\n  values.add(EmitPropertyList(\n               \"_OBJC_$_PROP_LIST_\" + PD->getObjCRuntimeNameAsString(),\n               nullptr, PD, ObjCTypes, false));\n  uint32_t Size =\n    CGM.getDataLayout().getTypeAllocSize(ObjCTypes.ProtocolnfABITy);\n  values.addInt(ObjCTypes.IntTy, Size);\n  values.addInt(ObjCTypes.IntTy, 0);\n  values.add(EmitProtocolMethodTypes(\"_OBJC_$_PROTOCOL_METHOD_TYPES_\"\n                                       + PD->getObjCRuntimeNameAsString(),\n                                     methodLists.emitExtendedTypesArray(this),\n                                     ObjCTypes));\n\n  // const char *demangledName;\n  values.addNullPointer(ObjCTypes.Int8PtrTy);\n\n  values.add(EmitPropertyList(\n      \"_OBJC_$_CLASS_PROP_LIST_\" + PD->getObjCRuntimeNameAsString(),\n      nullptr, PD, ObjCTypes, true));\n\n  if (Entry) {\n    // Already created, fix the linkage and update the initializer.\n    Entry->setLinkage(llvm::GlobalValue::WeakAnyLinkage);\n    values.finishAndSetAsInitializer(Entry);\n  } else {\n    llvm::SmallString<64> symbolName;\n    llvm::raw_svector_ostream(symbolName)\n      << \"_OBJC_PROTOCOL_$_\" << PD->getObjCRuntimeNameAsString();\n\n    Entry = values.finishAndCreateGlobal(symbolName, CGM.getPointerAlign(),\n                                         /*constant*/ false,\n                                         llvm::GlobalValue::WeakAnyLinkage);\n    if (!CGM.getTriple().isOSBinFormatMachO())\n      Entry->setComdat(CGM.getModule().getOrInsertComdat(symbolName));\n\n    Protocols[PD->getIdentifier()] = Entry;\n  }\n  Entry->setVisibility(llvm::GlobalValue::HiddenVisibility);\n  CGM.addUsedGlobal(Entry);\n\n  // Use this protocol meta-data to build protocol list table in section\n  // __DATA, __objc_protolist\n  llvm::SmallString<64> ProtocolRef;\n  llvm::raw_svector_ostream(ProtocolRef) << \"_OBJC_LABEL_PROTOCOL_$_\"\n                                         << PD->getObjCRuntimeNameAsString();\n\n  llvm::GlobalVariable *PTGV =\n    new llvm::GlobalVariable(CGM.getModule(), ObjCTypes.ProtocolnfABIPtrTy,\n                             false, llvm::GlobalValue::WeakAnyLinkage, Entry,\n                             ProtocolRef);\n  if (!CGM.getTriple().isOSBinFormatMachO())\n    PTGV->setComdat(CGM.getModule().getOrInsertComdat(ProtocolRef));\n  PTGV->setAlignment(llvm::Align(\n      CGM.getDataLayout().getABITypeAlignment(ObjCTypes.ProtocolnfABIPtrTy)));\n  PTGV->setSection(GetSectionName(\"__objc_protolist\",\n                                  \"coalesced,no_dead_strip\"));\n  PTGV->setVisibility(llvm::GlobalValue::HiddenVisibility);\n  CGM.addUsedGlobal(PTGV);\n  return Entry;\n}\n\n/// EmitProtocolList - Generate protocol list meta-data:\n/// @code\n/// struct _protocol_list_t {\n///   long protocol_count;   // Note, this is 32/64 bit\n///   struct _protocol_t[protocol_count];\n/// }\n/// @endcode\n///\nllvm::Constant *\nCGObjCNonFragileABIMac::EmitProtocolList(Twine Name,\n                                      ObjCProtocolDecl::protocol_iterator begin,\n                                      ObjCProtocolDecl::protocol_iterator end) {\n  // Just return null for empty protocol lists\n  auto Protocols = GetRuntimeProtocolList(begin, end);\n  if (Protocols.empty())\n    return llvm::Constant::getNullValue(ObjCTypes.ProtocolListnfABIPtrTy);\n\n  SmallVector<llvm::Constant *, 16> ProtocolRefs;\n  ProtocolRefs.reserve(Protocols.size());\n\n  for (const auto *PD : Protocols)\n    ProtocolRefs.push_back(GetProtocolRef(PD));\n\n  // If all of the protocols in the protocol list are objc_non_runtime_protocol\n  // just return null\n  if (ProtocolRefs.size() == 0)\n    return llvm::Constant::getNullValue(ObjCTypes.ProtocolListnfABIPtrTy);\n\n  // FIXME: We shouldn't need to do this lookup here, should we?\n  SmallString<256> TmpName;\n  Name.toVector(TmpName);\n  llvm::GlobalVariable *GV =\n    CGM.getModule().getGlobalVariable(TmpName.str(), true);\n  if (GV)\n    return llvm::ConstantExpr::getBitCast(GV, ObjCTypes.ProtocolListnfABIPtrTy);\n\n  ConstantInitBuilder builder(CGM);\n  auto values = builder.beginStruct();\n  auto countSlot = values.addPlaceholder();\n\n  // A null-terminated array of protocols.\n  auto array = values.beginArray(ObjCTypes.ProtocolnfABIPtrTy);\n  for (auto const &proto : ProtocolRefs)\n    array.add(proto);\n  auto count = array.size();\n  array.addNullPointer(ObjCTypes.ProtocolnfABIPtrTy);\n\n  array.finishAndAddTo(values);\n  values.fillPlaceholderWithInt(countSlot, ObjCTypes.LongTy, count);\n\n  GV = finishAndCreateGlobal(values, Name, CGM);\n  CGM.addCompilerUsedGlobal(GV);\n  return llvm::ConstantExpr::getBitCast(GV,\n                                        ObjCTypes.ProtocolListnfABIPtrTy);\n}\n\n/// EmitObjCValueForIvar - Code Gen for nonfragile ivar reference.\n/// This code gen. amounts to generating code for:\n/// @code\n/// (type *)((char *)base + _OBJC_IVAR_$_.ivar;\n/// @encode\n///\nLValue CGObjCNonFragileABIMac::EmitObjCValueForIvar(\n                                               CodeGen::CodeGenFunction &CGF,\n                                               QualType ObjectTy,\n                                               llvm::Value *BaseValue,\n                                               const ObjCIvarDecl *Ivar,\n                                               unsigned CVRQualifiers) {\n  ObjCInterfaceDecl *ID = ObjectTy->castAs<ObjCObjectType>()->getInterface();\n  llvm::Value *Offset = EmitIvarOffset(CGF, ID, Ivar);\n  return EmitValueForIvarAtOffset(CGF, ID, BaseValue, Ivar, CVRQualifiers,\n                                  Offset);\n}\n\nllvm::Value *\nCGObjCNonFragileABIMac::EmitIvarOffset(CodeGen::CodeGenFunction &CGF,\n                                       const ObjCInterfaceDecl *Interface,\n                                       const ObjCIvarDecl *Ivar) {\n  llvm::Value *IvarOffsetValue;\n  if (isClassLayoutKnownStatically(Interface)) {\n    IvarOffsetValue = llvm::ConstantInt::get(\n        ObjCTypes.IvarOffsetVarTy,\n        ComputeIvarBaseOffset(CGM, Interface->getImplementation(), Ivar));\n  } else {\n    llvm::GlobalVariable *GV = ObjCIvarOffsetVariable(Interface, Ivar);\n    IvarOffsetValue =\n        CGF.Builder.CreateAlignedLoad(GV, CGF.getSizeAlign(), \"ivar\");\n    if (IsIvarOffsetKnownIdempotent(CGF, Ivar))\n      cast<llvm::LoadInst>(IvarOffsetValue)\n          ->setMetadata(CGM.getModule().getMDKindID(\"invariant.load\"),\n                        llvm::MDNode::get(VMContext, None));\n  }\n\n  // This could be 32bit int or 64bit integer depending on the architecture.\n  // Cast it to 64bit integer value, if it is a 32bit integer ivar offset value\n  //  as this is what caller always expects.\n  if (ObjCTypes.IvarOffsetVarTy == ObjCTypes.IntTy)\n    IvarOffsetValue = CGF.Builder.CreateIntCast(\n        IvarOffsetValue, ObjCTypes.LongTy, true, \"ivar.conv\");\n  return IvarOffsetValue;\n}\n\nstatic void appendSelectorForMessageRefTable(std::string &buffer,\n                                             Selector selector) {\n  if (selector.isUnarySelector()) {\n    buffer += selector.getNameForSlot(0);\n    return;\n  }\n\n  for (unsigned i = 0, e = selector.getNumArgs(); i != e; ++i) {\n    buffer += selector.getNameForSlot(i);\n    buffer += '_';\n  }\n}\n\n/// Emit a \"vtable\" message send.  We emit a weak hidden-visibility\n/// struct, initially containing the selector pointer and a pointer to\n/// a \"fixup\" variant of the appropriate objc_msgSend.  To call, we\n/// load and call the function pointer, passing the address of the\n/// struct as the second parameter.  The runtime determines whether\n/// the selector is currently emitted using vtable dispatch; if so, it\n/// substitutes a stub function which simply tail-calls through the\n/// appropriate vtable slot, and if not, it substitues a stub function\n/// which tail-calls objc_msgSend.  Both stubs adjust the selector\n/// argument to correctly point to the selector.\nRValue\nCGObjCNonFragileABIMac::EmitVTableMessageSend(CodeGenFunction &CGF,\n                                              ReturnValueSlot returnSlot,\n                                              QualType resultType,\n                                              Selector selector,\n                                              llvm::Value *arg0,\n                                              QualType arg0Type,\n                                              bool isSuper,\n                                              const CallArgList &formalArgs,\n                                              const ObjCMethodDecl *method) {\n  // Compute the actual arguments.\n  CallArgList args;\n\n  // First argument: the receiver / super-call structure.\n  if (!isSuper)\n    arg0 = CGF.Builder.CreateBitCast(arg0, ObjCTypes.ObjectPtrTy);\n  args.add(RValue::get(arg0), arg0Type);\n\n  // Second argument: a pointer to the message ref structure.  Leave\n  // the actual argument value blank for now.\n  args.add(RValue::get(nullptr), ObjCTypes.MessageRefCPtrTy);\n\n  args.insert(args.end(), formalArgs.begin(), formalArgs.end());\n\n  MessageSendInfo MSI = getMessageSendInfo(method, resultType, args);\n\n  NullReturnState nullReturn;\n\n  // Find the function to call and the mangled name for the message\n  // ref structure.  Using a different mangled name wouldn't actually\n  // be a problem; it would just be a waste.\n  //\n  // The runtime currently never uses vtable dispatch for anything\n  // except normal, non-super message-sends.\n  // FIXME: don't use this for that.\n  llvm::FunctionCallee fn = nullptr;\n  std::string messageRefName(\"_\");\n  if (CGM.ReturnSlotInterferesWithArgs(MSI.CallInfo)) {\n    if (isSuper) {\n      fn = ObjCTypes.getMessageSendSuper2StretFixupFn();\n      messageRefName += \"objc_msgSendSuper2_stret_fixup\";\n    } else {\n      nullReturn.init(CGF, arg0);\n      fn = ObjCTypes.getMessageSendStretFixupFn();\n      messageRefName += \"objc_msgSend_stret_fixup\";\n    }\n  } else if (!isSuper && CGM.ReturnTypeUsesFPRet(resultType)) {\n    fn = ObjCTypes.getMessageSendFpretFixupFn();\n    messageRefName += \"objc_msgSend_fpret_fixup\";\n  } else {\n    if (isSuper) {\n      fn = ObjCTypes.getMessageSendSuper2FixupFn();\n      messageRefName += \"objc_msgSendSuper2_fixup\";\n    } else {\n      fn = ObjCTypes.getMessageSendFixupFn();\n      messageRefName += \"objc_msgSend_fixup\";\n    }\n  }\n  assert(fn && \"CGObjCNonFragileABIMac::EmitMessageSend\");\n  messageRefName += '_';\n\n  // Append the selector name, except use underscores anywhere we\n  // would have used colons.\n  appendSelectorForMessageRefTable(messageRefName, selector);\n\n  llvm::GlobalVariable *messageRef\n    = CGM.getModule().getGlobalVariable(messageRefName);\n  if (!messageRef) {\n    // Build the message ref structure.\n    ConstantInitBuilder builder(CGM);\n    auto values = builder.beginStruct();\n    values.add(cast<llvm::Constant>(fn.getCallee()));\n    values.add(GetMethodVarName(selector));\n    messageRef = values.finishAndCreateGlobal(messageRefName,\n                                              CharUnits::fromQuantity(16),\n                                              /*constant*/ false,\n                                        llvm::GlobalValue::WeakAnyLinkage);\n    messageRef->setVisibility(llvm::GlobalValue::HiddenVisibility);\n    messageRef->setSection(GetSectionName(\"__objc_msgrefs\", \"coalesced\"));\n  }\n\n  bool requiresnullCheck = false;\n  if (CGM.getLangOpts().ObjCAutoRefCount && method)\n    for (const auto *ParamDecl : method->parameters()) {\n      if (ParamDecl->isDestroyedInCallee()) {\n        if (!nullReturn.NullBB)\n          nullReturn.init(CGF, arg0);\n        requiresnullCheck = true;\n        break;\n      }\n    }\n\n  Address mref =\n    Address(CGF.Builder.CreateBitCast(messageRef, ObjCTypes.MessageRefPtrTy),\n            CGF.getPointerAlign());\n\n  // Update the message ref argument.\n  args[1].setRValue(RValue::get(mref.getPointer()));\n\n  // Load the function to call from the message ref table.\n  Address calleeAddr = CGF.Builder.CreateStructGEP(mref, 0);\n  llvm::Value *calleePtr = CGF.Builder.CreateLoad(calleeAddr, \"msgSend_fn\");\n\n  calleePtr = CGF.Builder.CreateBitCast(calleePtr, MSI.MessengerType);\n  CGCallee callee(CGCalleeInfo(), calleePtr);\n\n  RValue result = CGF.EmitCall(MSI.CallInfo, callee, returnSlot, args);\n  return nullReturn.complete(CGF, returnSlot, result, resultType, formalArgs,\n                             requiresnullCheck ? method : nullptr);\n}\n\n/// Generate code for a message send expression in the nonfragile abi.\nCodeGen::RValue\nCGObjCNonFragileABIMac::GenerateMessageSend(CodeGen::CodeGenFunction &CGF,\n                                            ReturnValueSlot Return,\n                                            QualType ResultType,\n                                            Selector Sel,\n                                            llvm::Value *Receiver,\n                                            const CallArgList &CallArgs,\n                                            const ObjCInterfaceDecl *Class,\n                                            const ObjCMethodDecl *Method) {\n  return isVTableDispatchedSelector(Sel)\n    ? EmitVTableMessageSend(CGF, Return, ResultType, Sel,\n                            Receiver, CGF.getContext().getObjCIdType(),\n                            false, CallArgs, Method)\n    : EmitMessageSend(CGF, Return, ResultType, Sel,\n                      Receiver, CGF.getContext().getObjCIdType(),\n                      false, CallArgs, Method, Class, ObjCTypes);\n}\n\nllvm::Constant *\nCGObjCNonFragileABIMac::GetClassGlobal(const ObjCInterfaceDecl *ID,\n                                       bool metaclass,\n                                       ForDefinition_t isForDefinition) {\n  auto prefix =\n    (metaclass ? getMetaclassSymbolPrefix() : getClassSymbolPrefix());\n  return GetClassGlobal((prefix + ID->getObjCRuntimeNameAsString()).str(),\n                        isForDefinition,\n                        ID->isWeakImported(),\n                        !isForDefinition\n                          && CGM.getTriple().isOSBinFormatCOFF()\n                          && ID->hasAttr<DLLImportAttr>());\n}\n\nllvm::Constant *\nCGObjCNonFragileABIMac::GetClassGlobal(StringRef Name,\n                                       ForDefinition_t IsForDefinition,\n                                       bool Weak, bool DLLImport) {\n  llvm::GlobalValue::LinkageTypes L =\n      Weak ? llvm::GlobalValue::ExternalWeakLinkage\n           : llvm::GlobalValue::ExternalLinkage;\n\n  llvm::GlobalVariable *GV = CGM.getModule().getGlobalVariable(Name);\n  if (!GV || GV->getType() != ObjCTypes.ClassnfABITy->getPointerTo()) {\n    auto *NewGV = new llvm::GlobalVariable(ObjCTypes.ClassnfABITy, false, L,\n                                           nullptr, Name);\n\n    if (DLLImport)\n      NewGV->setDLLStorageClass(llvm::GlobalValue::DLLImportStorageClass);\n\n    if (GV) {\n      GV->replaceAllUsesWith(\n          llvm::ConstantExpr::getBitCast(NewGV, GV->getType()));\n      GV->eraseFromParent();\n    }\n    GV = NewGV;\n    CGM.getModule().getGlobalList().push_back(GV);\n  }\n\n  assert(GV->getLinkage() == L);\n  return GV;\n}\n\nllvm::Constant *\nCGObjCNonFragileABIMac::GetClassGlobalForClassRef(const ObjCInterfaceDecl *ID) {\n  llvm::Constant *ClassGV = GetClassGlobal(ID, /*metaclass*/ false,\n                                           NotForDefinition);\n\n  if (!ID->hasAttr<ObjCClassStubAttr>())\n    return ClassGV;\n\n  ClassGV = llvm::ConstantExpr::getPointerCast(ClassGV, ObjCTypes.Int8PtrTy);\n\n  // Stub classes are pointer-aligned. Classrefs pointing at stub classes\n  // must set the least significant bit set to 1.\n  auto *Idx = llvm::ConstantInt::get(CGM.Int32Ty, 1);\n  return llvm::ConstantExpr::getGetElementPtr(CGM.Int8Ty, ClassGV, Idx);\n}\n\nllvm::Value *\nCGObjCNonFragileABIMac::EmitLoadOfClassRef(CodeGenFunction &CGF,\n                                           const ObjCInterfaceDecl *ID,\n                                           llvm::GlobalVariable *Entry) {\n  if (ID && ID->hasAttr<ObjCClassStubAttr>()) {\n    // Classrefs pointing at Objective-C stub classes must be loaded by calling\n    // a special runtime function.\n    return CGF.EmitRuntimeCall(\n      ObjCTypes.getLoadClassrefFn(), Entry, \"load_classref_result\");\n  }\n\n  CharUnits Align = CGF.getPointerAlign();\n  return CGF.Builder.CreateAlignedLoad(Entry, Align);\n}\n\nllvm::Value *\nCGObjCNonFragileABIMac::EmitClassRefFromId(CodeGenFunction &CGF,\n                                           IdentifierInfo *II,\n                                           const ObjCInterfaceDecl *ID) {\n  llvm::GlobalVariable *&Entry = ClassReferences[II];\n\n  if (!Entry) {\n    llvm::Constant *ClassGV;\n    if (ID) {\n      ClassGV = GetClassGlobalForClassRef(ID);\n    } else {\n      ClassGV = GetClassGlobal((getClassSymbolPrefix() + II->getName()).str(),\n                               NotForDefinition);\n      assert(ClassGV->getType() == ObjCTypes.ClassnfABIPtrTy &&\n             \"classref was emitted with the wrong type?\");\n    }\n\n    std::string SectionName =\n        GetSectionName(\"__objc_classrefs\", \"regular,no_dead_strip\");\n    Entry = new llvm::GlobalVariable(\n        CGM.getModule(), ClassGV->getType(), false,\n        getLinkageTypeForObjCMetadata(CGM, SectionName), ClassGV,\n        \"OBJC_CLASSLIST_REFERENCES_$_\");\n    Entry->setAlignment(CGF.getPointerAlign().getAsAlign());\n    if (!ID || !ID->hasAttr<ObjCClassStubAttr>())\n      Entry->setSection(SectionName);\n\n    CGM.addCompilerUsedGlobal(Entry);\n  }\n\n  return EmitLoadOfClassRef(CGF, ID, Entry);\n}\n\nllvm::Value *CGObjCNonFragileABIMac::EmitClassRef(CodeGenFunction &CGF,\n                                                  const ObjCInterfaceDecl *ID) {\n  // If the class has the objc_runtime_visible attribute, we need to\n  // use the Objective-C runtime to get the class.\n  if (ID->hasAttr<ObjCRuntimeVisibleAttr>())\n    return EmitClassRefViaRuntime(CGF, ID, ObjCTypes);\n\n  return EmitClassRefFromId(CGF, ID->getIdentifier(), ID);\n}\n\nllvm::Value *CGObjCNonFragileABIMac::EmitNSAutoreleasePoolClassRef(\n                                                    CodeGenFunction &CGF) {\n  IdentifierInfo *II = &CGM.getContext().Idents.get(\"NSAutoreleasePool\");\n  return EmitClassRefFromId(CGF, II, nullptr);\n}\n\nllvm::Value *\nCGObjCNonFragileABIMac::EmitSuperClassRef(CodeGenFunction &CGF,\n                                          const ObjCInterfaceDecl *ID) {\n  llvm::GlobalVariable *&Entry = SuperClassReferences[ID->getIdentifier()];\n\n  if (!Entry) {\n    llvm::Constant *ClassGV = GetClassGlobalForClassRef(ID);\n    std::string SectionName =\n        GetSectionName(\"__objc_superrefs\", \"regular,no_dead_strip\");\n    Entry = new llvm::GlobalVariable(CGM.getModule(), ClassGV->getType(), false,\n                                     llvm::GlobalValue::PrivateLinkage, ClassGV,\n                                     \"OBJC_CLASSLIST_SUP_REFS_$_\");\n    Entry->setAlignment(CGF.getPointerAlign().getAsAlign());\n    Entry->setSection(SectionName);\n    CGM.addCompilerUsedGlobal(Entry);\n  }\n\n  return EmitLoadOfClassRef(CGF, ID, Entry);\n}\n\n/// EmitMetaClassRef - Return a Value * of the address of _class_t\n/// meta-data\n///\nllvm::Value *CGObjCNonFragileABIMac::EmitMetaClassRef(CodeGenFunction &CGF,\n                                                      const ObjCInterfaceDecl *ID,\n                                                      bool Weak) {\n  CharUnits Align = CGF.getPointerAlign();\n  llvm::GlobalVariable * &Entry = MetaClassReferences[ID->getIdentifier()];\n  if (!Entry) {\n    auto MetaClassGV = GetClassGlobal(ID, /*metaclass*/ true, NotForDefinition);\n    std::string SectionName =\n        GetSectionName(\"__objc_superrefs\", \"regular,no_dead_strip\");\n    Entry = new llvm::GlobalVariable(CGM.getModule(), ObjCTypes.ClassnfABIPtrTy,\n                                     false, llvm::GlobalValue::PrivateLinkage,\n                                     MetaClassGV, \"OBJC_CLASSLIST_SUP_REFS_$_\");\n    Entry->setAlignment(Align.getAsAlign());\n    Entry->setSection(SectionName);\n    CGM.addCompilerUsedGlobal(Entry);\n  }\n\n  return CGF.Builder.CreateAlignedLoad(Entry, Align);\n}\n\n/// GetClass - Return a reference to the class for the given interface\n/// decl.\nllvm::Value *CGObjCNonFragileABIMac::GetClass(CodeGenFunction &CGF,\n                                              const ObjCInterfaceDecl *ID) {\n  if (ID->isWeakImported()) {\n    auto ClassGV = GetClassGlobal(ID, /*metaclass*/ false, NotForDefinition);\n    (void)ClassGV;\n    assert(!isa<llvm::GlobalVariable>(ClassGV) ||\n           cast<llvm::GlobalVariable>(ClassGV)->hasExternalWeakLinkage());\n  }\n\n  return EmitClassRef(CGF, ID);\n}\n\n/// Generates a message send where the super is the receiver.  This is\n/// a message send to self with special delivery semantics indicating\n/// which class's method should be called.\nCodeGen::RValue\nCGObjCNonFragileABIMac::GenerateMessageSendSuper(CodeGen::CodeGenFunction &CGF,\n                                                 ReturnValueSlot Return,\n                                                 QualType ResultType,\n                                                 Selector Sel,\n                                                 const ObjCInterfaceDecl *Class,\n                                                 bool isCategoryImpl,\n                                                 llvm::Value *Receiver,\n                                                 bool IsClassMessage,\n                                                 const CodeGen::CallArgList &CallArgs,\n                                                 const ObjCMethodDecl *Method) {\n  // ...\n  // Create and init a super structure; this is a (receiver, class)\n  // pair we will pass to objc_msgSendSuper.\n  Address ObjCSuper =\n    CGF.CreateTempAlloca(ObjCTypes.SuperTy, CGF.getPointerAlign(),\n                         \"objc_super\");\n\n  llvm::Value *ReceiverAsObject =\n    CGF.Builder.CreateBitCast(Receiver, ObjCTypes.ObjectPtrTy);\n  CGF.Builder.CreateStore(ReceiverAsObject,\n                          CGF.Builder.CreateStructGEP(ObjCSuper, 0));\n\n  // If this is a class message the metaclass is passed as the target.\n  llvm::Value *Target;\n  if (IsClassMessage)\n      Target = EmitMetaClassRef(CGF, Class, Class->isWeakImported());\n  else\n    Target = EmitSuperClassRef(CGF, Class);\n\n  // FIXME: We shouldn't need to do this cast, rectify the ASTContext and\n  // ObjCTypes types.\n  llvm::Type *ClassTy =\n    CGM.getTypes().ConvertType(CGF.getContext().getObjCClassType());\n  Target = CGF.Builder.CreateBitCast(Target, ClassTy);\n  CGF.Builder.CreateStore(Target, CGF.Builder.CreateStructGEP(ObjCSuper, 1));\n\n  return (isVTableDispatchedSelector(Sel))\n    ? EmitVTableMessageSend(CGF, Return, ResultType, Sel,\n                            ObjCSuper.getPointer(), ObjCTypes.SuperPtrCTy,\n                            true, CallArgs, Method)\n    : EmitMessageSend(CGF, Return, ResultType, Sel,\n                      ObjCSuper.getPointer(), ObjCTypes.SuperPtrCTy,\n                      true, CallArgs, Method, Class, ObjCTypes);\n}\n\nllvm::Value *CGObjCNonFragileABIMac::EmitSelector(CodeGenFunction &CGF,\n                                                  Selector Sel) {\n  Address Addr = EmitSelectorAddr(Sel);\n\n  llvm::LoadInst* LI = CGF.Builder.CreateLoad(Addr);\n  LI->setMetadata(CGM.getModule().getMDKindID(\"invariant.load\"),\n                  llvm::MDNode::get(VMContext, None));\n  return LI;\n}\n\nAddress CGObjCNonFragileABIMac::EmitSelectorAddr(Selector Sel) {\n  llvm::GlobalVariable *&Entry = SelectorReferences[Sel];\n  CharUnits Align = CGM.getPointerAlign();\n  if (!Entry) {\n    llvm::Constant *Casted =\n      llvm::ConstantExpr::getBitCast(GetMethodVarName(Sel),\n                                     ObjCTypes.SelectorPtrTy);\n    std::string SectionName =\n        GetSectionName(\"__objc_selrefs\", \"literal_pointers,no_dead_strip\");\n    Entry = new llvm::GlobalVariable(\n        CGM.getModule(), ObjCTypes.SelectorPtrTy, false,\n        getLinkageTypeForObjCMetadata(CGM, SectionName), Casted,\n        \"OBJC_SELECTOR_REFERENCES_\");\n    Entry->setExternallyInitialized(true);\n    Entry->setSection(SectionName);\n    Entry->setAlignment(Align.getAsAlign());\n    CGM.addCompilerUsedGlobal(Entry);\n  }\n\n  return Address(Entry, Align);\n}\n\n/// EmitObjCIvarAssign - Code gen for assigning to a __strong object.\n/// objc_assign_ivar (id src, id *dst, ptrdiff_t)\n///\nvoid CGObjCNonFragileABIMac::EmitObjCIvarAssign(CodeGen::CodeGenFunction &CGF,\n                                                llvm::Value *src,\n                                                Address dst,\n                                                llvm::Value *ivarOffset) {\n  llvm::Type * SrcTy = src->getType();\n  if (!isa<llvm::PointerType>(SrcTy)) {\n    unsigned Size = CGM.getDataLayout().getTypeAllocSize(SrcTy);\n    assert(Size <= 8 && \"does not support size > 8\");\n    src = (Size == 4 ? CGF.Builder.CreateBitCast(src, ObjCTypes.IntTy)\n           : CGF.Builder.CreateBitCast(src, ObjCTypes.LongTy));\n    src = CGF.Builder.CreateIntToPtr(src, ObjCTypes.Int8PtrTy);\n  }\n  src = CGF.Builder.CreateBitCast(src, ObjCTypes.ObjectPtrTy);\n  dst = CGF.Builder.CreateBitCast(dst, ObjCTypes.PtrObjectPtrTy);\n  llvm::Value *args[] = { src, dst.getPointer(), ivarOffset };\n  CGF.EmitNounwindRuntimeCall(ObjCTypes.getGcAssignIvarFn(), args);\n}\n\n/// EmitObjCStrongCastAssign - Code gen for assigning to a __strong cast object.\n/// objc_assign_strongCast (id src, id *dst)\n///\nvoid CGObjCNonFragileABIMac::EmitObjCStrongCastAssign(\n  CodeGen::CodeGenFunction &CGF,\n  llvm::Value *src, Address dst) {\n  llvm::Type * SrcTy = src->getType();\n  if (!isa<llvm::PointerType>(SrcTy)) {\n    unsigned Size = CGM.getDataLayout().getTypeAllocSize(SrcTy);\n    assert(Size <= 8 && \"does not support size > 8\");\n    src = (Size == 4 ? CGF.Builder.CreateBitCast(src, ObjCTypes.IntTy)\n           : CGF.Builder.CreateBitCast(src, ObjCTypes.LongTy));\n    src = CGF.Builder.CreateIntToPtr(src, ObjCTypes.Int8PtrTy);\n  }\n  src = CGF.Builder.CreateBitCast(src, ObjCTypes.ObjectPtrTy);\n  dst = CGF.Builder.CreateBitCast(dst, ObjCTypes.PtrObjectPtrTy);\n  llvm::Value *args[] = { src, dst.getPointer() };\n  CGF.EmitNounwindRuntimeCall(ObjCTypes.getGcAssignStrongCastFn(),\n                              args, \"weakassign\");\n}\n\nvoid CGObjCNonFragileABIMac::EmitGCMemmoveCollectable(\n  CodeGen::CodeGenFunction &CGF,\n  Address DestPtr,\n  Address SrcPtr,\n  llvm::Value *Size) {\n  SrcPtr = CGF.Builder.CreateBitCast(SrcPtr, ObjCTypes.Int8PtrTy);\n  DestPtr = CGF.Builder.CreateBitCast(DestPtr, ObjCTypes.Int8PtrTy);\n  llvm::Value *args[] = { DestPtr.getPointer(), SrcPtr.getPointer(), Size };\n  CGF.EmitNounwindRuntimeCall(ObjCTypes.GcMemmoveCollectableFn(), args);\n}\n\n/// EmitObjCWeakRead - Code gen for loading value of a __weak\n/// object: objc_read_weak (id *src)\n///\nllvm::Value * CGObjCNonFragileABIMac::EmitObjCWeakRead(\n  CodeGen::CodeGenFunction &CGF,\n  Address AddrWeakObj) {\n  llvm::Type *DestTy = AddrWeakObj.getElementType();\n  AddrWeakObj = CGF.Builder.CreateBitCast(AddrWeakObj, ObjCTypes.PtrObjectPtrTy);\n  llvm::Value *read_weak =\n    CGF.EmitNounwindRuntimeCall(ObjCTypes.getGcReadWeakFn(),\n                                AddrWeakObj.getPointer(), \"weakread\");\n  read_weak = CGF.Builder.CreateBitCast(read_weak, DestTy);\n  return read_weak;\n}\n\n/// EmitObjCWeakAssign - Code gen for assigning to a __weak object.\n/// objc_assign_weak (id src, id *dst)\n///\nvoid CGObjCNonFragileABIMac::EmitObjCWeakAssign(CodeGen::CodeGenFunction &CGF,\n                                                llvm::Value *src, Address dst) {\n  llvm::Type * SrcTy = src->getType();\n  if (!isa<llvm::PointerType>(SrcTy)) {\n    unsigned Size = CGM.getDataLayout().getTypeAllocSize(SrcTy);\n    assert(Size <= 8 && \"does not support size > 8\");\n    src = (Size == 4 ? CGF.Builder.CreateBitCast(src, ObjCTypes.IntTy)\n           : CGF.Builder.CreateBitCast(src, ObjCTypes.LongTy));\n    src = CGF.Builder.CreateIntToPtr(src, ObjCTypes.Int8PtrTy);\n  }\n  src = CGF.Builder.CreateBitCast(src, ObjCTypes.ObjectPtrTy);\n  dst = CGF.Builder.CreateBitCast(dst, ObjCTypes.PtrObjectPtrTy);\n  llvm::Value *args[] = { src, dst.getPointer() };\n  CGF.EmitNounwindRuntimeCall(ObjCTypes.getGcAssignWeakFn(),\n                              args, \"weakassign\");\n}\n\n/// EmitObjCGlobalAssign - Code gen for assigning to a __strong object.\n/// objc_assign_global (id src, id *dst)\n///\nvoid CGObjCNonFragileABIMac::EmitObjCGlobalAssign(CodeGen::CodeGenFunction &CGF,\n                                          llvm::Value *src, Address dst,\n                                          bool threadlocal) {\n  llvm::Type * SrcTy = src->getType();\n  if (!isa<llvm::PointerType>(SrcTy)) {\n    unsigned Size = CGM.getDataLayout().getTypeAllocSize(SrcTy);\n    assert(Size <= 8 && \"does not support size > 8\");\n    src = (Size == 4 ? CGF.Builder.CreateBitCast(src, ObjCTypes.IntTy)\n           : CGF.Builder.CreateBitCast(src, ObjCTypes.LongTy));\n    src = CGF.Builder.CreateIntToPtr(src, ObjCTypes.Int8PtrTy);\n  }\n  src = CGF.Builder.CreateBitCast(src, ObjCTypes.ObjectPtrTy);\n  dst = CGF.Builder.CreateBitCast(dst, ObjCTypes.PtrObjectPtrTy);\n  llvm::Value *args[] = { src, dst.getPointer() };\n  if (!threadlocal)\n    CGF.EmitNounwindRuntimeCall(ObjCTypes.getGcAssignGlobalFn(),\n                                args, \"globalassign\");\n  else\n    CGF.EmitNounwindRuntimeCall(ObjCTypes.getGcAssignThreadLocalFn(),\n                                args, \"threadlocalassign\");\n}\n\nvoid\nCGObjCNonFragileABIMac::EmitSynchronizedStmt(CodeGen::CodeGenFunction &CGF,\n                                             const ObjCAtSynchronizedStmt &S) {\n  EmitAtSynchronizedStmt(CGF, S, ObjCTypes.getSyncEnterFn(),\n                         ObjCTypes.getSyncExitFn());\n}\n\nllvm::Constant *\nCGObjCNonFragileABIMac::GetEHType(QualType T) {\n  // There's a particular fixed type info for 'id'.\n  if (T->isObjCIdType() || T->isObjCQualifiedIdType()) {\n    auto *IDEHType = CGM.getModule().getGlobalVariable(\"OBJC_EHTYPE_id\");\n    if (!IDEHType) {\n      IDEHType =\n          new llvm::GlobalVariable(CGM.getModule(), ObjCTypes.EHTypeTy, false,\n                                   llvm::GlobalValue::ExternalLinkage, nullptr,\n                                   \"OBJC_EHTYPE_id\");\n      if (CGM.getTriple().isOSBinFormatCOFF())\n        IDEHType->setDLLStorageClass(getStorage(CGM, \"OBJC_EHTYPE_id\"));\n    }\n    return IDEHType;\n  }\n\n  // All other types should be Objective-C interface pointer types.\n  const ObjCObjectPointerType *PT = T->getAs<ObjCObjectPointerType>();\n  assert(PT && \"Invalid @catch type.\");\n\n  const ObjCInterfaceType *IT = PT->getInterfaceType();\n  assert(IT && \"Invalid @catch type.\");\n\n  return GetInterfaceEHType(IT->getDecl(), NotForDefinition);\n}\n\nvoid CGObjCNonFragileABIMac::EmitTryStmt(CodeGen::CodeGenFunction &CGF,\n                                         const ObjCAtTryStmt &S) {\n  EmitTryCatchStmt(CGF, S, ObjCTypes.getObjCBeginCatchFn(),\n                   ObjCTypes.getObjCEndCatchFn(),\n                   ObjCTypes.getExceptionRethrowFn());\n}\n\n/// EmitThrowStmt - Generate code for a throw statement.\nvoid CGObjCNonFragileABIMac::EmitThrowStmt(CodeGen::CodeGenFunction &CGF,\n                                           const ObjCAtThrowStmt &S,\n                                           bool ClearInsertionPoint) {\n  if (const Expr *ThrowExpr = S.getThrowExpr()) {\n    llvm::Value *Exception = CGF.EmitObjCThrowOperand(ThrowExpr);\n    Exception = CGF.Builder.CreateBitCast(Exception, ObjCTypes.ObjectPtrTy);\n    llvm::CallBase *Call =\n        CGF.EmitRuntimeCallOrInvoke(ObjCTypes.getExceptionThrowFn(), Exception);\n    Call->setDoesNotReturn();\n  } else {\n    llvm::CallBase *Call =\n        CGF.EmitRuntimeCallOrInvoke(ObjCTypes.getExceptionRethrowFn());\n    Call->setDoesNotReturn();\n  }\n\n  CGF.Builder.CreateUnreachable();\n  if (ClearInsertionPoint)\n    CGF.Builder.ClearInsertionPoint();\n}\n\nllvm::Constant *\nCGObjCNonFragileABIMac::GetInterfaceEHType(const ObjCInterfaceDecl *ID,\n                                           ForDefinition_t IsForDefinition) {\n  llvm::GlobalVariable * &Entry = EHTypeReferences[ID->getIdentifier()];\n  StringRef ClassName = ID->getObjCRuntimeNameAsString();\n\n  // If we don't need a definition, return the entry if found or check\n  // if we use an external reference.\n  if (!IsForDefinition) {\n    if (Entry)\n      return Entry;\n\n    // If this type (or a super class) has the __objc_exception__\n    // attribute, emit an external reference.\n    if (hasObjCExceptionAttribute(CGM.getContext(), ID)) {\n      std::string EHTypeName = (\"OBJC_EHTYPE_$_\" + ClassName).str();\n      Entry = new llvm::GlobalVariable(CGM.getModule(), ObjCTypes.EHTypeTy,\n                                       false, llvm::GlobalValue::ExternalLinkage,\n                                       nullptr, EHTypeName);\n      CGM.setGVProperties(Entry, ID);\n      return Entry;\n    }\n  }\n\n  // Otherwise we need to either make a new entry or fill in the initializer.\n  assert((!Entry || !Entry->hasInitializer()) && \"Duplicate EHType definition\");\n\n  std::string VTableName = \"objc_ehtype_vtable\";\n  auto *VTableGV = CGM.getModule().getGlobalVariable(VTableName);\n  if (!VTableGV) {\n    VTableGV =\n        new llvm::GlobalVariable(CGM.getModule(), ObjCTypes.Int8PtrTy, false,\n                                 llvm::GlobalValue::ExternalLinkage, nullptr,\n                                 VTableName);\n    if (CGM.getTriple().isOSBinFormatCOFF())\n      VTableGV->setDLLStorageClass(getStorage(CGM, VTableName));\n  }\n\n  llvm::Value *VTableIdx = llvm::ConstantInt::get(CGM.Int32Ty, 2);\n  ConstantInitBuilder builder(CGM);\n  auto values = builder.beginStruct(ObjCTypes.EHTypeTy);\n  values.add(\n    llvm::ConstantExpr::getInBoundsGetElementPtr(VTableGV->getValueType(),\n                                                 VTableGV, VTableIdx));\n  values.add(GetClassName(ClassName));\n  values.add(GetClassGlobal(ID, /*metaclass*/ false, NotForDefinition));\n\n  llvm::GlobalValue::LinkageTypes L = IsForDefinition\n                                          ? llvm::GlobalValue::ExternalLinkage\n                                          : llvm::GlobalValue::WeakAnyLinkage;\n  if (Entry) {\n    values.finishAndSetAsInitializer(Entry);\n    Entry->setAlignment(CGM.getPointerAlign().getAsAlign());\n  } else {\n    Entry = values.finishAndCreateGlobal(\"OBJC_EHTYPE_$_\" + ClassName,\n                                         CGM.getPointerAlign(),\n                                         /*constant*/ false,\n                                         L);\n    if (hasObjCExceptionAttribute(CGM.getContext(), ID))\n      CGM.setGVProperties(Entry, ID);\n  }\n  assert(Entry->getLinkage() == L);\n\n  if (!CGM.getTriple().isOSBinFormatCOFF())\n    if (ID->getVisibility() == HiddenVisibility)\n      Entry->setVisibility(llvm::GlobalValue::HiddenVisibility);\n\n  if (IsForDefinition)\n    if (CGM.getTriple().isOSBinFormatMachO())\n      Entry->setSection(\"__DATA,__objc_const\");\n\n  return Entry;\n}\n\n/* *** */\n\nCodeGen::CGObjCRuntime *\nCodeGen::CreateMacObjCRuntime(CodeGen::CodeGenModule &CGM) {\n  switch (CGM.getLangOpts().ObjCRuntime.getKind()) {\n  case ObjCRuntime::FragileMacOSX:\n  return new CGObjCMac(CGM);\n\n  case ObjCRuntime::MacOSX:\n  case ObjCRuntime::iOS:\n  case ObjCRuntime::WatchOS:\n    return new CGObjCNonFragileABIMac(CGM);\n\n  case ObjCRuntime::GNUstep:\n  case ObjCRuntime::GCC:\n  case ObjCRuntime::ObjFW:\n    llvm_unreachable(\"these runtimes are not Mac runtimes\");\n  }\n  llvm_unreachable(\"bad runtime\");\n}\n"}}, "reports": [{"events": [{"location": {"col": 18, "file": 0, "line": 5607}, "message": "the definition seen here"}, {"location": {"col": 19, "file": 0, "line": 964}, "message": "differing parameters are named here: ('OI'), in definition: ('OMD')"}, {"location": {"col": 19, "file": 0, "line": 964}, "message": "function '(anonymous namespace)::CGObjCCommonMac::BuildIvarLayout' has a definition with different parameter names"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/lib/CodeGen/CGObjCMac.cpp", "reportHash": "9eadc9e1c6b868ba8ddd5f5232918485", "checkerName": "readability-inconsistent-declaration-parameter-name", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 18, "file": 0, "line": 2008}, "message": "the definition seen here"}, {"location": {"col": 19, "file": 0, "line": 1091}, "message": "differing parameters are named here: ('SL'), in definition: ('Literal')"}, {"location": {"col": 19, "file": 0, "line": 1091}, "message": "function '(anonymous namespace)::CGObjCCommonMac::GenerateConstantNSString' has a definition with different parameter names"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/lib/CodeGen/CGObjCMac.cpp", "reportHash": "e280dcffd6e261573cc75761d7a32eb6", "checkerName": "readability-inconsistent-declaration-parameter-name", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 17, "file": 0, "line": 3394}, "message": "the definition seen here"}, {"location": {"col": 8, "file": 0, "line": 1347}, "message": "differing parameters are named here: ('CMD'), in definition: ('OCD')"}, {"location": {"col": 8, "file": 0, "line": 1347}, "message": "function '(anonymous namespace)::CGObjCMac::GenerateCategory' has a definition with different parameter names"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/lib/CodeGen/CGObjCMac.cpp", "reportHash": "3a08564d211e10d510c9bfc69e9c79cb", "checkerName": "readability-inconsistent-declaration-parameter-name", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 17, "file": 0, "line": 3564}, "message": "the definition seen here"}, {"location": {"col": 8, "file": 0, "line": 1349}, "message": "differing parameters are named here: ('ClassDecl'), in definition: ('ID')"}, {"location": {"col": 8, "file": 0, "line": 1349}, "message": "function '(anonymous namespace)::CGObjCMac::GenerateClass' has a definition with different parameter names"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/lib/CodeGen/CGObjCMac.cpp", "reportHash": "4b626ea5ad6b55d5da07bc058145d17d", "checkerName": "readability-inconsistent-declaration-parameter-name", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 17, "file": 0, "line": 5006}, "message": "the definition seen here"}, {"location": {"col": 8, "file": 0, "line": 1377}, "message": "differing parameters are named here: ('dest'), in definition: ('dst')"}, {"location": {"col": 8, "file": 0, "line": 1377}, "message": "function '(anonymous namespace)::CGObjCMac::EmitObjCGlobalAssign' has a definition with different parameter names"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/lib/CodeGen/CGObjCMac.cpp", "reportHash": "4891d513d2eafc933911cb31d5c05dc1", "checkerName": "readability-inconsistent-declaration-parameter-name", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 17, "file": 0, "line": 5031}, "message": "the definition seen here"}, {"location": {"col": 8, "file": 0, "line": 1380}, "message": "differing parameters are named here: ('dest'), in definition: ('dst')"}, {"location": {"col": 8, "file": 0, "line": 1380}, "message": "function '(anonymous namespace)::CGObjCMac::EmitObjCIvarAssign' has a definition with different parameter names"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/lib/CodeGen/CGObjCMac.cpp", "reportHash": "f2382268f2200c2bddb8db9a71827dba", "checkerName": "readability-inconsistent-declaration-parameter-name", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 17, "file": 0, "line": 5052}, "message": "the definition seen here"}, {"location": {"col": 8, "file": 0, "line": 1383}, "message": "differing parameters are named here: ('dest'), in definition: ('dst')"}, {"location": {"col": 8, "file": 0, "line": 1383}, "message": "function '(anonymous namespace)::CGObjCMac::EmitObjCStrongCastAssign' has a definition with different parameter names"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/lib/CodeGen/CGObjCMac.cpp", "reportHash": "21cc046bd19f1e58ca7235fbbc5aed40", "checkerName": "readability-inconsistent-declaration-parameter-name", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 25, "file": 0, "line": 6822}, "message": "the definition seen here"}, {"location": {"col": 19, "file": 0, "line": 1450}, "message": "differing parameters are named here: ('MLT'), in definition: ('kind')"}, {"location": {"col": 19, "file": 0, "line": 1450}, "message": "function '(anonymous namespace)::CGObjCNonFragileABIMac::emitMethodList' has a definition with different parameter names"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/lib/CodeGen/CGObjCMac.cpp", "reportHash": "6336bdccb55cb062cd04d38d8d6b56a8", "checkerName": "readability-inconsistent-declaration-parameter-name", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 30, "file": 0, "line": 6711}, "message": "the definition seen here"}, {"location": {"col": 8, "file": 0, "line": 1637}, "message": "differing parameters are named here: ('CMD'), in definition: ('OCD')"}, {"location": {"col": 8, "file": 0, "line": 1637}, "message": "function '(anonymous namespace)::CGObjCNonFragileABIMac::GenerateCategory' has a definition with different parameter names"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/lib/CodeGen/CGObjCMac.cpp", "reportHash": "648542895295ab7356ae3fb5fe815e8a", "checkerName": "readability-inconsistent-declaration-parameter-name", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 30, "file": 0, "line": 6534}, "message": "the definition seen here"}, {"location": {"col": 8, "file": 0, "line": 1639}, "message": "differing parameters are named here: ('ClassDecl'), in definition: ('ID')"}, {"location": {"col": 8, "file": 0, "line": 1639}, "message": "function '(anonymous namespace)::CGObjCNonFragileABIMac::GenerateClass' has a definition with different parameter names"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/lib/CodeGen/CGObjCMac.cpp", "reportHash": "9b32ff1ae784ae17e7407469de5bcaf4", "checkerName": "readability-inconsistent-declaration-parameter-name", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 30, "file": 0, "line": 7770}, "message": "the definition seen here"}, {"location": {"col": 8, "file": 0, "line": 1690}, "message": "differing parameters are named here: ('dest'), in definition: ('dst')"}, {"location": {"col": 8, "file": 0, "line": 1690}, "message": "function '(anonymous namespace)::CGObjCNonFragileABIMac::EmitObjCGlobalAssign' has a definition with different parameter names"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/lib/CodeGen/CGObjCMac.cpp", "reportHash": "a50c9001f84be62bc878e1741692afd9", "checkerName": "readability-inconsistent-declaration-parameter-name", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 30, "file": 0, "line": 7682}, "message": "the definition seen here"}, {"location": {"col": 8, "file": 0, "line": 1693}, "message": "differing parameters are named here: ('dest'), in definition: ('dst')"}, {"location": {"col": 8, "file": 0, "line": 1693}, "message": "function '(anonymous namespace)::CGObjCNonFragileABIMac::EmitObjCIvarAssign' has a definition with different parameter names"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/lib/CodeGen/CGObjCMac.cpp", "reportHash": "0ded94566d1b016c543dceec5ea6f73d", "checkerName": "readability-inconsistent-declaration-parameter-name", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 30, "file": 0, "line": 7703}, "message": "the definition seen here"}, {"location": {"col": 8, "file": 0, "line": 1696}, "message": "differing parameters are named here: ('dest'), in definition: ('dst')"}, {"location": {"col": 8, "file": 0, "line": 1696}, "message": "function '(anonymous namespace)::CGObjCNonFragileABIMac::EmitObjCStrongCastAssign' has a definition with different parameter names"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/lib/CodeGen/CGObjCMac.cpp", "reportHash": "770140262daae2cf0451faaddfa7bc92", "checkerName": "readability-inconsistent-declaration-parameter-name", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 25, "file": 0, "line": 5372}, "message": "the definition seen here"}, {"location": {"col": 10, "file": 0, "line": 2369}, "message": "differing parameters are named here: ('aggrOffset'), in definition: ('aggregateOffset')"}, {"location": {"col": 10, "file": 0, "line": 2369}, "message": "function '(anonymous namespace)::IvarLayoutBuilder::visitAggregate' has a definition with different parameter names"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang/lib/CodeGen/CGObjCMac.cpp", "reportHash": "63cfa6887500fe1cc30747016e80626f", "checkerName": "readability-inconsistent-declaration-parameter-name", "reviewStatus": null, "severity": "STYLE"}]};
      window.onload = function() {
        if (!browserCompatible) {
          setNonCompatibleBrowserMessage();
        } else {
          BugViewer.init(data.files, data.reports);
          BugViewer.create();
          BugViewer.initByUrl();
        }
      };
    </script>
  </head>
  <body>
  <div class="container">
    <div id="content">
      <div id="side-bar">
        <div class="header">
          <a href="index.html" class="button">&#8249; Return to List</a>
        </div>
        <div id="report-nav">
          <div class="header">Reports</div>
        </div>
      </div>
      <div id="editor-wrapper">
        <div class="header">
          <div id="file">
            <span class="label">File:</span>
            <span id="file-path"></span>
          </div>
          <div id="checker">
            <span class="label">Checker name:</span>
            <span id="checker-name"></span>
          </div>
          <div id="review-status-wrapper">
            <span class="label">Review status:</span>
            <span id="review-status"></span>
          </div>
        </div>
        <div id="editor"></div>
      </div>
    </div>
  </div>
  </body>
</html>
