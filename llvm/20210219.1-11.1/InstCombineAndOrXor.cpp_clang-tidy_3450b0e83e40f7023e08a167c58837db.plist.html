<!DOCTYPE html>
<html>
  <head>
    <title>Plist HTML Viewer</title>

    <meta charset="UTF-8">

    <style type="text/css">
      .CodeMirror{font-family:monospace;height:300px;color:#000;direction:ltr}.CodeMirror-lines{padding:4px 0}.CodeMirror pre{padding:0 4px}.CodeMirror-gutter-filler,.CodeMirror-scrollbar-filler{background-color:#fff}.CodeMirror-gutters{border-right:1px solid #ddd;background-color:#f7f7f7;white-space:nowrap}.CodeMirror-linenumber{padding:0 3px 0 5px;min-width:20px;text-align:right;color:#999;white-space:nowrap}.CodeMirror-guttermarker{color:#000}.CodeMirror-guttermarker-subtle{color:#999}.CodeMirror-cursor{border-left:1px solid #000;border-right:none;width:0}.CodeMirror div.CodeMirror-secondarycursor{border-left:1px solid silver}.cm-fat-cursor .CodeMirror-cursor{width:auto;border:0!important;background:#7e7}.cm-fat-cursor div.CodeMirror-cursors{z-index:1}.cm-animate-fat-cursor{width:auto;border:0;-webkit-animation:blink 1.06s steps(1) infinite;-moz-animation:blink 1.06s steps(1) infinite;animation:blink 1.06s steps(1) infinite;background-color:#7e7}@-moz-keyframes blink{50%{background-color:transparent}}@-webkit-keyframes blink{50%{background-color:transparent}}@keyframes blink{50%{background-color:transparent}}.cm-tab{display:inline-block;text-decoration:inherit}.CodeMirror-rulers{position:absolute;left:0;right:0;top:-50px;bottom:-20px;overflow:hidden}.CodeMirror-ruler{border-left:1px solid #ccc;top:0;bottom:0;position:absolute}.cm-s-default .cm-header{color:#00f}.cm-s-default .cm-quote{color:#090}.cm-negative{color:#d44}.cm-positive{color:#292}.cm-header,.cm-strong{font-weight:700}.cm-em{font-style:italic}.cm-link{text-decoration:underline}.cm-strikethrough{text-decoration:line-through}.cm-s-default .cm-keyword{color:#708}.cm-s-default .cm-atom{color:#219}.cm-s-default .cm-number{color:#164}.cm-s-default .cm-def{color:#00f}.cm-s-default .cm-variable-2{color:#05a}.cm-s-default .cm-type,.cm-s-default .cm-variable-3{color:#085}.cm-s-default .cm-comment{color:#a50}.cm-s-default .cm-string{color:#a11}.cm-s-default .cm-string-2{color:#f50}.cm-s-default .cm-meta{color:#555}.cm-s-default .cm-qualifier{color:#555}.cm-s-default .cm-builtin{color:#30a}.cm-s-default .cm-bracket{color:#997}.cm-s-default .cm-tag{color:#170}.cm-s-default .cm-attribute{color:#00c}.cm-s-default .cm-hr{color:#999}.cm-s-default .cm-link{color:#00c}.cm-s-default .cm-error{color:red}.cm-invalidchar{color:red}.CodeMirror-composing{border-bottom:2px solid}div.CodeMirror span.CodeMirror-matchingbracket{color:#0f0}div.CodeMirror span.CodeMirror-nonmatchingbracket{color:#f22}.CodeMirror-matchingtag{background:rgba(255,150,0,.3)}.CodeMirror-activeline-background{background:#e8f2ff}.CodeMirror{position:relative;overflow:hidden;background:#fff}.CodeMirror-scroll{overflow:scroll!important;margin-bottom:-30px;margin-right:-30px;padding-bottom:30px;height:100%;outline:0;position:relative}.CodeMirror-sizer{position:relative;border-right:30px solid transparent}.CodeMirror-gutter-filler,.CodeMirror-hscrollbar,.CodeMirror-scrollbar-filler,.CodeMirror-vscrollbar{position:absolute;z-index:6;display:none}.CodeMirror-vscrollbar{right:0;top:0;overflow-x:hidden;overflow-y:scroll}.CodeMirror-hscrollbar{bottom:0;left:0;overflow-y:hidden;overflow-x:scroll}.CodeMirror-scrollbar-filler{right:0;bottom:0}.CodeMirror-gutter-filler{left:0;bottom:0}.CodeMirror-gutters{position:absolute;left:0;top:0;min-height:100%;z-index:3}.CodeMirror-gutter{white-space:normal;height:100%;display:inline-block;vertical-align:top;margin-bottom:-30px}.CodeMirror-gutter-wrapper{position:absolute;z-index:4;background:0 0!important;border:none!important}.CodeMirror-gutter-background{position:absolute;top:0;bottom:0;z-index:4}.CodeMirror-gutter-elt{position:absolute;cursor:default;z-index:4}.CodeMirror-gutter-wrapper ::selection{background-color:transparent}.CodeMirror-gutter-wrapper ::-moz-selection{background-color:transparent}.CodeMirror-lines{cursor:text;min-height:1px}.CodeMirror pre{-moz-border-radius:0;-webkit-border-radius:0;border-radius:0;border-width:0;background:0 0;font-family:inherit;font-size:inherit;margin:0;white-space:pre;word-wrap:normal;line-height:inherit;color:inherit;z-index:2;position:relative;overflow:visible;-webkit-tap-highlight-color:transparent;-webkit-font-variant-ligatures:contextual;font-variant-ligatures:contextual}.CodeMirror-wrap pre{word-wrap:break-word;white-space:pre-wrap;word-break:normal}.CodeMirror-linebackground{position:absolute;left:0;right:0;top:0;bottom:0;z-index:0}.CodeMirror-linewidget{position:relative;z-index:2;overflow:auto}.CodeMirror-rtl pre{direction:rtl}.CodeMirror-code{outline:0}.CodeMirror-gutter,.CodeMirror-gutters,.CodeMirror-linenumber,.CodeMirror-scroll,.CodeMirror-sizer{-moz-box-sizing:content-box;box-sizing:content-box}.CodeMirror-measure{position:absolute;width:100%;height:0;overflow:hidden;visibility:hidden}.CodeMirror-cursor{position:absolute;pointer-events:none}.CodeMirror-measure pre{position:static}div.CodeMirror-cursors{visibility:hidden;position:relative;z-index:3}div.CodeMirror-dragcursors{visibility:visible}.CodeMirror-focused div.CodeMirror-cursors{visibility:visible}.CodeMirror-selected{background:#d9d9d9}.CodeMirror-focused .CodeMirror-selected{background:#d7d4f0}.CodeMirror-crosshair{cursor:crosshair}.CodeMirror-line::selection,.CodeMirror-line>span::selection,.CodeMirror-line>span>span::selection{background:#d7d4f0}.CodeMirror-line::-moz-selection,.CodeMirror-line>span::-moz-selection,.CodeMirror-line>span>span::-moz-selection{background:#d7d4f0}.cm-searching{background-color:#ffa;background-color:rgba(255,255,0,.4)}.cm-force-border{padding-right:.1px}@media print{.CodeMirror div.CodeMirror-cursors{visibility:hidden}}.cm-tab-wrap-hack:after{content:''}span.CodeMirror-selectedtext{background:0 0}
/*# sourceMappingURL=codemirror.min.css.map */

      .severity-low {
  background-color: #669603;
}

.severity-low:after {
  content : 'L';
}

.severity-unspecified {
  background-color: #666666;
}

.severity-unspecified:after {
  content : 'U';
}

.severity-style {
  background-color: #9932cc;
}

.severity-style:after {
  content : 'S';
}

.severity-medium {
  background-color: #a9d323;
  color: black;
}

.severity-medium:after {
  content : 'M';
}

.severity-high {
  background-color: #ffa800;
}

.severity-high:after {
  content : 'H';
}

.severity-critical {
  background-color: #e92625;
}

.severity-critical:after {
  content : 'C';
}

i[class*="severity-"] {
  line-height: normal;
  text-transform: capitalize;
  font-size: 0.8em;
  font-weight: bold;
  color: white;
  display: inline-block;
  width: 16px;
  height: 16px;
  text-align: center;
  font-family: sans-serif;
}

      html, body {
  width: 100%;
  height: 100%;
  padding: 0px;
  margin: 0px;
}

div.container {
  padding: 10px;
}

#content {
  height: 100%;
  display: block;
  overflow: hidden;
}

#content > div {
  margin: 10px;
  overflow: hidden;
  border: 1px solid #ddd;
  border-radius: 3px;
  overflow: hidden;
  height: 97%;
}

.button {
  background-color: #f1f1f1;
  text-decoration: none;
  display: inline-block;
  padding: 8px 16px;
  color: black;
  cursor: pointer;
}

.button:hover {
  background-color: #ddd;
  color: black;
}

.review-status {
  color: white;
  text-align: center;
}

.review-status-confirmed {
  background-color: #e92625;
}

.review-status-false-positive {
  background-color: grey;
}

.review-status-intentional {
  background-color: #669603;
}

      div.container {
  width: 100%;
  height: 100%;
  padding: 0px;
}

#editor-wrapper {
  margin: 10px;
}

#side-bar {
  float: left;
  width: 260px;
  margin: 0px;
}

#report-nav ul {
  list-style-type: none;
  padding: 0;
  margin: 0;
  overflow-y: auto;
  height: 100%;
}

#report-nav ul > li {
  padding: .4em;
  background-color: #fff;
  border-bottom: 1px solid rgba(0,0,0,.125);
  text-align: left;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

#report-nav ul > li.active {
  background-color: #427ea9;
  color: white;
}

#report-nav ul > li:hover {
  background-color: #427ea9;
  color: white;
  cursor: pointer;
}

#report-nav ul a {
  text-decoration: none;
}

#report-nav i[class*="severity-"] {
  margin-right: 5px;
}

.header {
  border-bottom: 1px solid lightgrey;
  font-family: monospace;
  padding: 10px;
  background-color: #fafbfc;
  border-bottom: 1px solid #e1e4e8;
  border-top-left-radius: 2px;
  border-top-right-radius: 2px;
}

#report-nav .header {
  font-weight: bold;
}

#editor-wrapper .header > div {
  padding-top: 2px;
}

#file-path,
#checker-name {
  color: #195ea2;
}

#review-status {
  padding: 0px 5px;
}

#file-path {
  font-family: monospace;
}

.check-msg {
  display: inline-block;
  padding: 3px 6px;
  margin: 1px;
  -webkit-border-radius: 5px;
  -moz-border-radius: 5px;
  border-radius: 5px;
}

.check-msg.info {
  color: #00546f;
  background-color: #bfdfe9;
  border: 1px solid #87a8b3;
}

.check-msg.error {
  background-color: #f2dede;
  color: #a94442;
  border: 1px solid #ebcccc;
}

.check-msg.macro {
  background-color: #d7dac2;
  color: #4f5c6d;
  border: 1px solid #d7dac2;
}

.check-msg.note {
  background-color: #d7d7d7;
  color: #4f5c6d;
  border: 1px solid #bfbfbf;
}

.check-msg.current {
  border: 2px dashed #3692ff;
}

.check-msg .tag {
  padding: 1px 5px;
  text-align: center;
  border-radius: 2px;
  margin-right: 5px;
  text-decoration: inherit;
}

.check-msg .tag.macro {
  background-color: #83876a;
  color: white;
  text-transform: capitalize;
}

.check-msg .tag.note {
  background-color: #9299a1;
  color: white;
  text-transform: capitalize;
}

.checker-enum {
  color: white;
  padding: 1px 5px;
  text-align: center;
  border-radius: 25px;
  margin-right: 5px;
  text-decoration: inherit;
}

.checker-enum.info {
  background-color: #427ea9;
}

.checker-enum.error {
  background-color: #a94442;
}

.arrow {
  border: solid black;
  border-width: 0 3px 3px 0;
  display: inline-block;
  padding: 3px;
  cursor: pointer;
  margin: 0px 5px;
}

.arrow:hover {
  border: solid #437ea8;
  border-width: 0 3px 3px 0;
}

.left-arrow {
  transform: rotate(135deg);
  -webkit-transform: rotate(135deg);
}

.right-arrow {
  transform: rotate(-45deg);
  -webkit-transform: rotate(-45deg);
}

    </style>

    <script type="text/javascript">
      function setNonCompatibleBrowserMessage() {
  document.body.innerHTML =
    '<h2 style="margin-left: 20px;">Your browser is not compatible with CodeChecker Viewer!</h2> \
     <p style="margin-left: 20px;">The version required for the following browsers are:</p> \
     <ul style="margin-left: 20px;"> \
     <li>Internet Explorer: version 9 or newer</li> \
     <li>Firefox: version 22.0 or newer</li> \
     </ul>';
}

// http://stackoverflow.com/questions/5916900/how-can-you-detect-the-version-of-a-browser
var browserVersion = (function(){
  var ua = navigator.userAgent, tem,
    M = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];

  if (/trident/i.test(M[1])) {
    tem = /\brv[ :]+(\d+)/g.exec(ua) || [];
    return 'IE ' + (tem[1] || '');
  }

  if (M[1] === 'Chrome') {
    tem = ua.match(/\b(OPR|Edge)\/(\d+)/);
    if (tem != null) return tem.slice(1).join(' ').replace('OPR', 'Opera');
  }

  M = M[2] ? [M[1], M[2]] : [navigator.appName, navigator.appVersion, '-?'];
  if ((tem = ua.match(/version\/(\d+)/i)) != null) M.splice(1, 1, tem[1]);
    return M.join(' ');
})();

var pos = browserVersion.indexOf(' ');
var browser = browserVersion.substr(0, pos);
var version = parseInt(browserVersion.substr(pos + 1));

var browserCompatible
  = browser === 'Firefox'
  ? version >= 22
  : browser === 'IE'
  ? version >= 9
  : true;


      /* MIT License

Copyright (C) 2017 by Marijn Haverbeke <marijnh@gmail.com> and others

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
 */
      !function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):e.CodeMirror=t()}(this,function(){"use strict";function e(e){return new RegExp("(^|\\s)"+e+"(?:$|\\s)\\s*")}function t(e){for(var t=e.childNodes.length;t>0;--t)e.removeChild(e.firstChild);return e}function r(e,r){return t(e).appendChild(r)}function n(e,t,r,n){var i=document.createElement(e);if(r&&(i.className=r),n&&(i.style.cssText=n),"string"==typeof t)i.appendChild(document.createTextNode(t));else if(t)for(var o=0;o<t.length;++o)i.appendChild(t[o]);return i}function i(e,t,r,i){var o=n(e,t,r,i);return o.setAttribute("role","presentation"),o}function o(e,t){if(3==t.nodeType&&(t=t.parentNode),e.contains)return e.contains(t);do{if(11==t.nodeType&&(t=t.host),t==e)return!0}while(t=t.parentNode)}function l(){var e;try{e=document.activeElement}catch(t){e=document.body||null}for(;e&&e.shadowRoot&&e.shadowRoot.activeElement;)e=e.shadowRoot.activeElement;return e}function s(t,r){var n=t.className;e(r).test(n)||(t.className+=(n?" ":"")+r)}function a(t,r){for(var n=t.split(" "),i=0;i<n.length;i++)n[i]&&!e(n[i]).test(r)&&(r+=" "+n[i]);return r}function u(e){var t=Array.prototype.slice.call(arguments,1);return function(){return e.apply(null,t)}}function c(e,t,r){t||(t={});for(var n in e)!e.hasOwnProperty(n)||!1===r&&t.hasOwnProperty(n)||(t[n]=e[n]);return t}function f(e,t,r,n,i){null==t&&-1==(t=e.search(/[^\s\u00a0]/))&&(t=e.length);for(var o=n||0,l=i||0;;){var s=e.indexOf("\t",o);if(s<0||s>=t)return l+(t-o);l+=s-o,l+=r-l%r,o=s+1}}function h(e,t){for(var r=0;r<e.length;++r)if(e[r]==t)return r;return-1}function d(e,t,r){for(var n=0,i=0;;){var o=e.indexOf("\t",n);-1==o&&(o=e.length);var l=o-n;if(o==e.length||i+l>=t)return n+Math.min(l,t-i);if(i+=o-n,i+=r-i%r,n=o+1,i>=t)return n}}function p(e){for(;Kl.length<=e;)Kl.push(g(Kl)+" ");return Kl[e]}function g(e){return e[e.length-1]}function v(e,t){for(var r=[],n=0;n<e.length;n++)r[n]=t(e[n],n);return r}function m(e,t,r){for(var n=0,i=r(t);n<e.length&&r(e[n])<=i;)n++;e.splice(n,0,t)}function y(){}function b(e,t){var r;return Object.create?r=Object.create(e):(y.prototype=e,r=new y),t&&c(t,r),r}function w(e){return/\w/.test(e)||e>""&&(e.toUpperCase()!=e.toLowerCase()||jl.test(e))}function x(e,t){return t?!!(t.source.indexOf("\\w")>-1&&w(e))||t.test(e):w(e)}function C(e){for(var t in e)if(e.hasOwnProperty(t)&&e[t])return!1;return!0}function S(e){return e.charCodeAt(0)>=768&&Xl.test(e)}function L(e,t,r){for(;(r<0?t>0:t<e.length)&&S(e.charAt(t));)t+=r;return t}function k(e,t,r){for(var n=t>r?-1:1;;){if(t==r)return t;var i=(t+r)/2,o=n<0?Math.ceil(i):Math.floor(i);if(o==t)return e(o)?t:r;e(o)?r=o:t=o+n}}function T(e,t,r){var o=this;this.input=r,o.scrollbarFiller=n("div",null,"CodeMirror-scrollbar-filler"),o.scrollbarFiller.setAttribute("cm-not-content","true"),o.gutterFiller=n("div",null,"CodeMirror-gutter-filler"),o.gutterFiller.setAttribute("cm-not-content","true"),o.lineDiv=i("div",null,"CodeMirror-code"),o.selectionDiv=n("div",null,null,"position: relative; z-index: 1"),o.cursorDiv=n("div",null,"CodeMirror-cursors"),o.measure=n("div",null,"CodeMirror-measure"),o.lineMeasure=n("div",null,"CodeMirror-measure"),o.lineSpace=i("div",[o.measure,o.lineMeasure,o.selectionDiv,o.cursorDiv,o.lineDiv],null,"position: relative; outline: none");var l=i("div",[o.lineSpace],"CodeMirror-lines");o.mover=n("div",[l],null,"position: relative"),o.sizer=n("div",[o.mover],"CodeMirror-sizer"),o.sizerWidth=null,o.heightForcer=n("div",null,null,"position: absolute; height: "+Rl+"px; width: 1px;"),o.gutters=n("div",null,"CodeMirror-gutters"),o.lineGutter=null,o.scroller=n("div",[o.sizer,o.heightForcer,o.gutters],"CodeMirror-scroll"),o.scroller.setAttribute("tabIndex","-1"),o.wrapper=n("div",[o.scrollbarFiller,o.gutterFiller,o.scroller],"CodeMirror"),gl&&vl<8&&(o.gutters.style.zIndex=-1,o.scroller.style.paddingRight=0),ml||fl&&Tl||(o.scroller.draggable=!0),e&&(e.appendChild?e.appendChild(o.wrapper):e(o.wrapper)),o.viewFrom=o.viewTo=t.first,o.reportedViewFrom=o.reportedViewTo=t.first,o.view=[],o.renderedView=null,o.externalMeasured=null,o.viewOffset=0,o.lastWrapHeight=o.lastWrapWidth=0,o.updateLineNumbers=null,o.nativeBarWidth=o.barHeight=o.barWidth=0,o.scrollbarsClipped=!1,o.lineNumWidth=o.lineNumInnerWidth=o.lineNumChars=null,o.alignWidgets=!1,o.cachedCharWidth=o.cachedTextHeight=o.cachedPaddingH=null,o.maxLine=null,o.maxLineLength=0,o.maxLineChanged=!1,o.wheelDX=o.wheelDY=o.wheelStartX=o.wheelStartY=null,o.shift=!1,o.selForContextMenu=null,o.activeTouch=null,r.init(o)}function M(e,t){if((t-=e.first)<0||t>=e.size)throw new Error("There is no line "+(t+e.first)+" in the document.");for(var r=e;!r.lines;)for(var n=0;;++n){var i=r.children[n],o=i.chunkSize();if(t<o){r=i;break}t-=o}return r.lines[t]}function N(e,t,r){var n=[],i=t.line;return e.iter(t.line,r.line+1,function(e){var o=e.text;i==r.line&&(o=o.slice(0,r.ch)),i==t.line&&(o=o.slice(t.ch)),n.push(o),++i}),n}function O(e,t,r){var n=[];return e.iter(t,r,function(e){n.push(e.text)}),n}function A(e,t){var r=t-e.height;if(r)for(var n=e;n;n=n.parent)n.height+=r}function W(e){if(null==e.parent)return null;for(var t=e.parent,r=h(t.lines,e),n=t.parent;n;t=n,n=n.parent)for(var i=0;n.children[i]!=t;++i)r+=n.children[i].chunkSize();return r+t.first}function D(e,t){var r=e.first;e:do{for(var n=0;n<e.children.length;++n){var i=e.children[n],o=i.height;if(t<o){e=i;continue e}t-=o,r+=i.chunkSize()}return r}while(!e.lines);for(var l=0;l<e.lines.length;++l){var s=e.lines[l].height;if(t<s)break;t-=s}return r+l}function H(e,t){return t>=e.first&&t<e.first+e.size}function F(e,t){return String(e.lineNumberFormatter(t+e.firstLineNumber))}function E(e,t,r){if(void 0===r&&(r=null),!(this instanceof E))return new E(e,t,r);this.line=e,this.ch=t,this.sticky=r}function P(e,t){return e.line-t.line||e.ch-t.ch}function I(e,t){return e.sticky==t.sticky&&0==P(e,t)}function z(e){return E(e.line,e.ch)}function R(e,t){return P(e,t)<0?t:e}function B(e,t){return P(e,t)<0?e:t}function G(e,t){return Math.max(e.first,Math.min(t,e.first+e.size-1))}function U(e,t){if(t.line<e.first)return E(e.first,0);var r=e.first+e.size-1;return t.line>r?E(r,M(e,r).text.length):V(t,M(e,t.line).text.length)}function V(e,t){var r=e.ch;return null==r||r>t?E(e.line,t):r<0?E(e.line,0):e}function K(e,t){for(var r=[],n=0;n<t.length;n++)r[n]=U(e,t[n]);return r}function j(){Yl=!0}function X(){_l=!0}function Y(e,t,r){this.marker=e,this.from=t,this.to=r}function _(e,t){if(e)for(var r=0;r<e.length;++r){var n=e[r];if(n.marker==t)return n}}function $(e,t){for(var r,n=0;n<e.length;++n)e[n]!=t&&(r||(r=[])).push(e[n]);return r}function q(e,t){e.markedSpans=e.markedSpans?e.markedSpans.concat([t]):[t],t.marker.attachLine(e)}function Z(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t)||o.from==t&&"bookmark"==l.type&&(!r||!o.marker.insertLeft)){var s=null==o.to||(l.inclusiveRight?o.to>=t:o.to>t);(n||(n=[])).push(new Y(l,o.from,s?null:o.to))}}return n}function Q(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.to||(l.inclusiveRight?o.to>=t:o.to>t)||o.from==t&&"bookmark"==l.type&&(!r||o.marker.insertLeft)){var s=null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t);(n||(n=[])).push(new Y(l,s?null:o.from-t,null==o.to?null:o.to-t))}}return n}function J(e,t){if(t.full)return null;var r=H(e,t.from.line)&&M(e,t.from.line).markedSpans,n=H(e,t.to.line)&&M(e,t.to.line).markedSpans;if(!r&&!n)return null;var i=t.from.ch,o=t.to.ch,l=0==P(t.from,t.to),s=Z(r,i,l),a=Q(n,o,l),u=1==t.text.length,c=g(t.text).length+(u?i:0);if(s)for(var f=0;f<s.length;++f){var h=s[f];if(null==h.to){var d=_(a,h.marker);d?u&&(h.to=null==d.to?null:d.to+c):h.to=i}}if(a)for(var p=0;p<a.length;++p){var v=a[p];null!=v.to&&(v.to+=c),null==v.from?_(s,v.marker)||(v.from=c,u&&(s||(s=[])).push(v)):(v.from+=c,u&&(s||(s=[])).push(v))}s&&(s=ee(s)),a&&a!=s&&(a=ee(a));var m=[s];if(!u){var y,b=t.text.length-2;if(b>0&&s)for(var w=0;w<s.length;++w)null==s[w].to&&(y||(y=[])).push(new Y(s[w].marker,null,null));for(var x=0;x<b;++x)m.push(y);m.push(a)}return m}function ee(e){for(var t=0;t<e.length;++t){var r=e[t];null!=r.from&&r.from==r.to&&!1!==r.marker.clearWhenEmpty&&e.splice(t--,1)}return e.length?e:null}function te(e,t,r){var n=null;if(e.iter(t.line,r.line+1,function(e){if(e.markedSpans)for(var t=0;t<e.markedSpans.length;++t){var r=e.markedSpans[t].marker;!r.readOnly||n&&-1!=h(n,r)||(n||(n=[])).push(r)}}),!n)return null;for(var i=[{from:t,to:r}],o=0;o<n.length;++o)for(var l=n[o],s=l.find(0),a=0;a<i.length;++a){var u=i[a];if(!(P(u.to,s.from)<0||P(u.from,s.to)>0)){var c=[a,1],f=P(u.from,s.from),d=P(u.to,s.to);(f<0||!l.inclusiveLeft&&!f)&&c.push({from:u.from,to:s.from}),(d>0||!l.inclusiveRight&&!d)&&c.push({from:s.to,to:u.to}),i.splice.apply(i,c),a+=c.length-3}}return i}function re(e){var t=e.markedSpans;if(t){for(var r=0;r<t.length;++r)t[r].marker.detachLine(e);e.markedSpans=null}}function ne(e,t){if(t){for(var r=0;r<t.length;++r)t[r].marker.attachLine(e);e.markedSpans=t}}function ie(e){return e.inclusiveLeft?-1:0}function oe(e){return e.inclusiveRight?1:0}function le(e,t){var r=e.lines.length-t.lines.length;if(0!=r)return r;var n=e.find(),i=t.find(),o=P(n.from,i.from)||ie(e)-ie(t);if(o)return-o;var l=P(n.to,i.to)||oe(e)-oe(t);return l||t.id-e.id}function se(e,t){var r,n=_l&&e.markedSpans;if(n)for(var i=void 0,o=0;o<n.length;++o)(i=n[o]).marker.collapsed&&null==(t?i.from:i.to)&&(!r||le(r,i.marker)<0)&&(r=i.marker);return r}function ae(e){return se(e,!0)}function ue(e){return se(e,!1)}function ce(e,t,r,n,i){var o=M(e,t),l=_l&&o.markedSpans;if(l)for(var s=0;s<l.length;++s){var a=l[s];if(a.marker.collapsed){var u=a.marker.find(0),c=P(u.from,r)||ie(a.marker)-ie(i),f=P(u.to,n)||oe(a.marker)-oe(i);if(!(c>=0&&f<=0||c<=0&&f>=0)&&(c<=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.to,r)>=0:P(u.to,r)>0)||c>=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.from,n)<=0:P(u.from,n)<0)))return!0}}}function fe(e){for(var t;t=ae(e);)e=t.find(-1,!0).line;return e}function he(e){for(var t;t=ue(e);)e=t.find(1,!0).line;return e}function de(e){for(var t,r;t=ue(e);)e=t.find(1,!0).line,(r||(r=[])).push(e);return r}function pe(e,t){var r=M(e,t),n=fe(r);return r==n?t:W(n)}function ge(e,t){if(t>e.lastLine())return t;var r,n=M(e,t);if(!ve(e,n))return t;for(;r=ue(n);)n=r.find(1,!0).line;return W(n)+1}function ve(e,t){var r=_l&&t.markedSpans;if(r)for(var n=void 0,i=0;i<r.length;++i)if((n=r[i]).marker.collapsed){if(null==n.from)return!0;if(!n.marker.widgetNode&&0==n.from&&n.marker.inclusiveLeft&&me(e,t,n))return!0}}function me(e,t,r){if(null==r.to){var n=r.marker.find(1,!0);return me(e,n.line,_(n.line.markedSpans,r.marker))}if(r.marker.inclusiveRight&&r.to==t.text.length)return!0;for(var i=void 0,o=0;o<t.markedSpans.length;++o)if((i=t.markedSpans[o]).marker.collapsed&&!i.marker.widgetNode&&i.from==r.to&&(null==i.to||i.to!=r.from)&&(i.marker.inclusiveLeft||r.marker.inclusiveRight)&&me(e,t,i))return!0}function ye(e){for(var t=0,r=(e=fe(e)).parent,n=0;n<r.lines.length;++n){var i=r.lines[n];if(i==e)break;t+=i.height}for(var o=r.parent;o;r=o,o=r.parent)for(var l=0;l<o.children.length;++l){var s=o.children[l];if(s==r)break;t+=s.height}return t}function be(e){if(0==e.height)return 0;for(var t,r=e.text.length,n=e;t=ae(n);){var i=t.find(0,!0);n=i.from.line,r+=i.from.ch-i.to.ch}for(n=e;t=ue(n);){var o=t.find(0,!0);r-=n.text.length-o.from.ch,r+=(n=o.to.line).text.length-o.to.ch}return r}function we(e){var t=e.display,r=e.doc;t.maxLine=M(r,r.first),t.maxLineLength=be(t.maxLine),t.maxLineChanged=!0,r.iter(function(e){var r=be(e);r>t.maxLineLength&&(t.maxLineLength=r,t.maxLine=e)})}function xe(e,t,r,n){if(!e)return n(t,r,"ltr",0);for(var i=!1,o=0;o<e.length;++o){var l=e[o];(l.from<r&&l.to>t||t==r&&l.to==t)&&(n(Math.max(l.from,t),Math.min(l.to,r),1==l.level?"rtl":"ltr",o),i=!0)}i||n(t,r,"ltr")}function Ce(e,t,r){var n;$l=null;for(var i=0;i<e.length;++i){var o=e[i];if(o.from<t&&o.to>t)return i;o.to==t&&(o.from!=o.to&&"before"==r?n=i:$l=i),o.from==t&&(o.from!=o.to&&"before"!=r?n=i:$l=i)}return null!=n?n:$l}function Se(e,t){var r=e.order;return null==r&&(r=e.order=ql(e.text,t)),r}function Le(e,t){return e._handlers&&e._handlers[t]||Zl}function ke(e,t,r){if(e.removeEventListener)e.removeEventListener(t,r,!1);else if(e.detachEvent)e.detachEvent("on"+t,r);else{var n=e._handlers,i=n&&n[t];if(i){var o=h(i,r);o>-1&&(n[t]=i.slice(0,o).concat(i.slice(o+1)))}}}function Te(e,t){var r=Le(e,t);if(r.length)for(var n=Array.prototype.slice.call(arguments,2),i=0;i<r.length;++i)r[i].apply(null,n)}function Me(e,t,r){return"string"==typeof t&&(t={type:t,preventDefault:function(){this.defaultPrevented=!0}}),Te(e,r||t.type,e,t),He(t)||t.codemirrorIgnore}function Ne(e){var t=e._handlers&&e._handlers.cursorActivity;if(t)for(var r=e.curOp.cursorActivityHandlers||(e.curOp.cursorActivityHandlers=[]),n=0;n<t.length;++n)-1==h(r,t[n])&&r.push(t[n])}function Oe(e,t){return Le(e,t).length>0}function Ae(e){e.prototype.on=function(e,t){Ql(this,e,t)},e.prototype.off=function(e,t){ke(this,e,t)}}function We(e){e.preventDefault?e.preventDefault():e.returnValue=!1}function De(e){e.stopPropagation?e.stopPropagation():e.cancelBubble=!0}function He(e){return null!=e.defaultPrevented?e.defaultPrevented:0==e.returnValue}function Fe(e){We(e),De(e)}function Ee(e){return e.target||e.srcElement}function Pe(e){var t=e.which;return null==t&&(1&e.button?t=1:2&e.button?t=3:4&e.button&&(t=2)),Ml&&e.ctrlKey&&1==t&&(t=3),t}function Ie(e){if(null==Il){var t=n("span","​");r(e,n("span",[t,document.createTextNode("x")])),0!=e.firstChild.offsetHeight&&(Il=t.offsetWidth<=1&&t.offsetHeight>2&&!(gl&&vl<8))}var i=Il?n("span","​"):n("span"," ",null,"display: inline-block; width: 1px; margin-right: -1px");return i.setAttribute("cm-text",""),i}function ze(e){if(null!=zl)return zl;var n=r(e,document.createTextNode("AخA")),i=Wl(n,0,1).getBoundingClientRect(),o=Wl(n,1,2).getBoundingClientRect();return t(e),!(!i||i.left==i.right)&&(zl=o.right-i.right<3)}function Re(e){if(null!=ns)return ns;var t=r(e,n("span","x")),i=t.getBoundingClientRect(),o=Wl(t,0,1).getBoundingClientRect();return ns=Math.abs(i.left-o.left)>1}function Be(e,t){arguments.length>2&&(t.dependencies=Array.prototype.slice.call(arguments,2)),is[e]=t}function Ge(e){if("string"==typeof e&&os.hasOwnProperty(e))e=os[e];else if(e&&"string"==typeof e.name&&os.hasOwnProperty(e.name)){var t=os[e.name];"string"==typeof t&&(t={name:t}),(e=b(t,e)).name=t.name}else{if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+xml$/.test(e))return Ge("application/xml");if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+json$/.test(e))return Ge("application/json")}return"string"==typeof e?{name:e}:e||{name:"null"}}function Ue(e,t){t=Ge(t);var r=is[t.name];if(!r)return Ue(e,"text/plain");var n=r(e,t);if(ls.hasOwnProperty(t.name)){var i=ls[t.name];for(var o in i)i.hasOwnProperty(o)&&(n.hasOwnProperty(o)&&(n["_"+o]=n[o]),n[o]=i[o])}if(n.name=t.name,t.helperType&&(n.helperType=t.helperType),t.modeProps)for(var l in t.modeProps)n[l]=t.modeProps[l];return n}function Ve(e,t){c(t,ls.hasOwnProperty(e)?ls[e]:ls[e]={})}function Ke(e,t){if(!0===t)return t;if(e.copyState)return e.copyState(t);var r={};for(var n in t){var i=t[n];i instanceof Array&&(i=i.concat([])),r[n]=i}return r}function je(e,t){for(var r;e.innerMode&&(r=e.innerMode(t))&&r.mode!=e;)t=r.state,e=r.mode;return r||{mode:e,state:t}}function Xe(e,t,r){return!e.startState||e.startState(t,r)}function Ye(e,t,r,n){var i=[e.state.modeGen],o={};tt(e,t.text,e.doc.mode,r,function(e,t){return i.push(e,t)},o,n);for(var l=r.state,s=0;s<e.state.overlays.length;++s)!function(n){var l=e.state.overlays[n],s=1,a=0;r.state=!0,tt(e,t.text,l.mode,r,function(e,t){for(var r=s;a<e;){var n=i[s];n>e&&i.splice(s,1,e,i[s+1],n),s+=2,a=Math.min(e,n)}if(t)if(l.opaque)i.splice(r,s-r,e,"overlay "+t),s=r+2;else for(;r<s;r+=2){var o=i[r+1];i[r+1]=(o?o+" ":"")+"overlay "+t}},o)}(s);return r.state=l,{styles:i,classes:o.bgClass||o.textClass?o:null}}function _e(e,t,r){if(!t.styles||t.styles[0]!=e.state.modeGen){var n=$e(e,W(t)),i=t.text.length>e.options.maxHighlightLength&&Ke(e.doc.mode,n.state),o=Ye(e,t,n);i&&(n.state=i),t.stateAfter=n.save(!i),t.styles=o.styles,o.classes?t.styleClasses=o.classes:t.styleClasses&&(t.styleClasses=null),r===e.doc.highlightFrontier&&(e.doc.modeFrontier=Math.max(e.doc.modeFrontier,++e.doc.highlightFrontier))}return t.styles}function $e(e,t,r){var n=e.doc,i=e.display;if(!n.mode.startState)return new us(n,!0,t);var o=rt(e,t,r),l=o>n.first&&M(n,o-1).stateAfter,s=l?us.fromSaved(n,l,o):new us(n,Xe(n.mode),o);return n.iter(o,t,function(r){qe(e,r.text,s);var n=s.line;r.stateAfter=n==t-1||n%5==0||n>=i.viewFrom&&n<i.viewTo?s.save():null,s.nextLine()}),r&&(n.modeFrontier=s.line),s}function qe(e,t,r,n){var i=e.doc.mode,o=new ss(t,e.options.tabSize,r);for(o.start=o.pos=n||0,""==t&&Ze(i,r.state);!o.eol();)Qe(i,o,r.state),o.start=o.pos}function Ze(e,t){if(e.blankLine)return e.blankLine(t);if(e.innerMode){var r=je(e,t);return r.mode.blankLine?r.mode.blankLine(r.state):void 0}}function Qe(e,t,r,n){for(var i=0;i<10;i++){n&&(n[0]=je(e,r).mode);var o=e.token(t,r);if(t.pos>t.start)return o}throw new Error("Mode "+e.name+" failed to advance stream.")}function Je(e,t,r,n){var i,o,l=e.doc,s=l.mode,a=M(l,(t=U(l,t)).line),u=$e(e,t.line,r),c=new ss(a.text,e.options.tabSize,u);for(n&&(o=[]);(n||c.pos<t.ch)&&!c.eol();)c.start=c.pos,i=Qe(s,c,u.state),n&&o.push(new cs(c,i,Ke(l.mode,u.state)));return n?o:new cs(c,i,u.state)}function et(e,t){if(e)for(;;){var r=e.match(/(?:^|\s+)line-(background-)?(\S+)/);if(!r)break;e=e.slice(0,r.index)+e.slice(r.index+r[0].length);var n=r[1]?"bgClass":"textClass";null==t[n]?t[n]=r[2]:new RegExp("(?:^|s)"+r[2]+"(?:$|s)").test(t[n])||(t[n]+=" "+r[2])}return e}function tt(e,t,r,n,i,o,l){var s=r.flattenSpans;null==s&&(s=e.options.flattenSpans);var a,u=0,c=null,f=new ss(t,e.options.tabSize,n),h=e.options.addModeClass&&[null];for(""==t&&et(Ze(r,n.state),o);!f.eol();){if(f.pos>e.options.maxHighlightLength?(s=!1,l&&qe(e,t,n,f.pos),f.pos=t.length,a=null):a=et(Qe(r,f,n.state,h),o),h){var d=h[0].name;d&&(a="m-"+(a?d+" "+a:d))}if(!s||c!=a){for(;u<f.start;)i(u=Math.min(f.start,u+5e3),c);c=a}f.start=f.pos}for(;u<f.pos;){var p=Math.min(f.pos,u+5e3);i(p,c),u=p}}function rt(e,t,r){for(var n,i,o=e.doc,l=r?-1:t-(e.doc.mode.innerMode?1e3:100),s=t;s>l;--s){if(s<=o.first)return o.first;var a=M(o,s-1),u=a.stateAfter;if(u&&(!r||s+(u instanceof as?u.lookAhead:0)<=o.modeFrontier))return s;var c=f(a.text,null,e.options.tabSize);(null==i||n>c)&&(i=s-1,n=c)}return i}function nt(e,t){if(e.modeFrontier=Math.min(e.modeFrontier,t),!(e.highlightFrontier<t-10)){for(var r=e.first,n=t-1;n>r;n--){var i=M(e,n).stateAfter;if(i&&(!(i instanceof as)||n+i.lookAhead<t)){r=n+1;break}}e.highlightFrontier=Math.min(e.highlightFrontier,r)}}function it(e,t,r,n){e.text=t,e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null),null!=e.order&&(e.order=null),re(e),ne(e,r);var i=n?n(e):1;i!=e.height&&A(e,i)}function ot(e){e.parent=null,re(e)}function lt(e,t){if(!e||/^\s*$/.test(e))return null;var r=t.addModeClass?ps:ds;return r[e]||(r[e]=e.replace(/\S+/g,"cm-$&"))}function st(e,t){var r=i("span",null,null,ml?"padding-right: .1px":null),n={pre:i("pre",[r],"CodeMirror-line"),content:r,col:0,pos:0,cm:e,trailingSpace:!1,splitSpaces:(gl||ml)&&e.getOption("lineWrapping")};t.measure={};for(var o=0;o<=(t.rest?t.rest.length:0);o++){var l=o?t.rest[o-1]:t.line,s=void 0;n.pos=0,n.addToken=ut,ze(e.display.measure)&&(s=Se(l,e.doc.direction))&&(n.addToken=ft(n.addToken,s)),n.map=[],dt(l,n,_e(e,l,t!=e.display.externalMeasured&&W(l))),l.styleClasses&&(l.styleClasses.bgClass&&(n.bgClass=a(l.styleClasses.bgClass,n.bgClass||"")),l.styleClasses.textClass&&(n.textClass=a(l.styleClasses.textClass,n.textClass||""))),0==n.map.length&&n.map.push(0,0,n.content.appendChild(Ie(e.display.measure))),0==o?(t.measure.map=n.map,t.measure.cache={}):((t.measure.maps||(t.measure.maps=[])).push(n.map),(t.measure.caches||(t.measure.caches=[])).push({}))}if(ml){var u=n.content.lastChild;(/\bcm-tab\b/.test(u.className)||u.querySelector&&u.querySelector(".cm-tab"))&&(n.content.className="cm-tab-wrap-hack")}return Te(e,"renderLine",e,t.line,n.pre),n.pre.className&&(n.textClass=a(n.pre.className,n.textClass||"")),n}function at(e){var t=n("span","•","cm-invalidchar");return t.title="\\u"+e.charCodeAt(0).toString(16),t.setAttribute("aria-label",t.title),t}function ut(e,t,r,i,o,l,s){if(t){var a,u=e.splitSpaces?ct(t,e.trailingSpace):t,c=e.cm.state.specialChars,f=!1;if(c.test(t)){a=document.createDocumentFragment();for(var h=0;;){c.lastIndex=h;var d=c.exec(t),g=d?d.index-h:t.length-h;if(g){var v=document.createTextNode(u.slice(h,h+g));gl&&vl<9?a.appendChild(n("span",[v])):a.appendChild(v),e.map.push(e.pos,e.pos+g,v),e.col+=g,e.pos+=g}if(!d)break;h+=g+1;var m=void 0;if("\t"==d[0]){var y=e.cm.options.tabSize,b=y-e.col%y;(m=a.appendChild(n("span",p(b),"cm-tab"))).setAttribute("role","presentation"),m.setAttribute("cm-text","\t"),e.col+=b}else"\r"==d[0]||"\n"==d[0]?((m=a.appendChild(n("span","\r"==d[0]?"␍":"␤","cm-invalidchar"))).setAttribute("cm-text",d[0]),e.col+=1):((m=e.cm.options.specialCharPlaceholder(d[0])).setAttribute("cm-text",d[0]),gl&&vl<9?a.appendChild(n("span",[m])):a.appendChild(m),e.col+=1);e.map.push(e.pos,e.pos+1,m),e.pos++}}else e.col+=t.length,a=document.createTextNode(u),e.map.push(e.pos,e.pos+t.length,a),gl&&vl<9&&(f=!0),e.pos+=t.length;if(e.trailingSpace=32==u.charCodeAt(t.length-1),r||i||o||f||s){var w=r||"";i&&(w+=i),o&&(w+=o);var x=n("span",[a],w,s);return l&&(x.title=l),e.content.appendChild(x)}e.content.appendChild(a)}}function ct(e,t){if(e.length>1&&!/  /.test(e))return e;for(var r=t,n="",i=0;i<e.length;i++){var o=e.charAt(i);" "!=o||!r||i!=e.length-1&&32!=e.charCodeAt(i+1)||(o=" "),n+=o,r=" "==o}return n}function ft(e,t){return function(r,n,i,o,l,s,a){i=i?i+" cm-force-border":"cm-force-border";for(var u=r.pos,c=u+n.length;;){for(var f=void 0,h=0;h<t.length&&!((f=t[h]).to>u&&f.from<=u);h++);if(f.to>=c)return e(r,n,i,o,l,s,a);e(r,n.slice(0,f.to-u),i,o,null,s,a),o=null,n=n.slice(f.to-u),u=f.to}}}function ht(e,t,r,n){var i=!n&&r.widgetNode;i&&e.map.push(e.pos,e.pos+t,i),!n&&e.cm.display.input.needsContentAttribute&&(i||(i=e.content.appendChild(document.createElement("span"))),i.setAttribute("cm-marker",r.id)),i&&(e.cm.display.input.setUneditable(i),e.content.appendChild(i)),e.pos+=t,e.trailingSpace=!1}function dt(e,t,r){var n=e.markedSpans,i=e.text,o=0;if(n)for(var l,s,a,u,c,f,h,d=i.length,p=0,g=1,v="",m=0;;){if(m==p){a=u=c=f=s="",h=null,m=1/0;for(var y=[],b=void 0,w=0;w<n.length;++w){var x=n[w],C=x.marker;"bookmark"==C.type&&x.from==p&&C.widgetNode?y.push(C):x.from<=p&&(null==x.to||x.to>p||C.collapsed&&x.to==p&&x.from==p)?(null!=x.to&&x.to!=p&&m>x.to&&(m=x.to,u=""),C.className&&(a+=" "+C.className),C.css&&(s=(s?s+";":"")+C.css),C.startStyle&&x.from==p&&(c+=" "+C.startStyle),C.endStyle&&x.to==m&&(b||(b=[])).push(C.endStyle,x.to),C.title&&!f&&(f=C.title),C.collapsed&&(!h||le(h.marker,C)<0)&&(h=x)):x.from>p&&m>x.from&&(m=x.from)}if(b)for(var S=0;S<b.length;S+=2)b[S+1]==m&&(u+=" "+b[S]);if(!h||h.from==p)for(var L=0;L<y.length;++L)ht(t,0,y[L]);if(h&&(h.from||0)==p){if(ht(t,(null==h.to?d+1:h.to)-p,h.marker,null==h.from),null==h.to)return;h.to==p&&(h=!1)}}if(p>=d)break;for(var k=Math.min(d,m);;){if(v){var T=p+v.length;if(!h){var M=T>k?v.slice(0,k-p):v;t.addToken(t,M,l?l+a:a,c,p+M.length==m?u:"",f,s)}if(T>=k){v=v.slice(k-p),p=k;break}p=T,c=""}v=i.slice(o,o=r[g++]),l=lt(r[g++],t.cm.options)}}else for(var N=1;N<r.length;N+=2)t.addToken(t,i.slice(o,o=r[N]),lt(r[N+1],t.cm.options))}function pt(e,t,r){this.line=t,this.rest=de(t),this.size=this.rest?W(g(this.rest))-r+1:1,this.node=this.text=null,this.hidden=ve(e,t)}function gt(e,t,r){for(var n,i=[],o=t;o<r;o=n){var l=new pt(e.doc,M(e.doc,o),o);n=o+l.size,i.push(l)}return i}function vt(e){gs?gs.ops.push(e):e.ownsGroup=gs={ops:[e],delayedCallbacks:[]}}function mt(e){var t=e.delayedCallbacks,r=0;do{for(;r<t.length;r++)t[r].call(null);for(var n=0;n<e.ops.length;n++){var i=e.ops[n];if(i.cursorActivityHandlers)for(;i.cursorActivityCalled<i.cursorActivityHandlers.length;)i.cursorActivityHandlers[i.cursorActivityCalled++].call(null,i.cm)}}while(r<t.length)}function yt(e,t){var r=e.ownsGroup;if(r)try{mt(r)}finally{gs=null,t(r)}}function bt(e,t){var r=Le(e,t);if(r.length){var n,i=Array.prototype.slice.call(arguments,2);gs?n=gs.delayedCallbacks:vs?n=vs:(n=vs=[],setTimeout(wt,0));for(var o=0;o<r.length;++o)!function(e){n.push(function(){return r[e].apply(null,i)})}(o)}}function wt(){var e=vs;vs=null;for(var t=0;t<e.length;++t)e[t]()}function xt(e,t,r,n){for(var i=0;i<t.changes.length;i++){var o=t.changes[i];"text"==o?kt(e,t):"gutter"==o?Mt(e,t,r,n):"class"==o?Tt(e,t):"widget"==o&&Nt(e,t,n)}t.changes=null}function Ct(e){return e.node==e.text&&(e.node=n("div",null,null,"position: relative"),e.text.parentNode&&e.text.parentNode.replaceChild(e.node,e.text),e.node.appendChild(e.text),gl&&vl<8&&(e.node.style.zIndex=2)),e.node}function St(e,t){var r=t.bgClass?t.bgClass+" "+(t.line.bgClass||""):t.line.bgClass;if(r&&(r+=" CodeMirror-linebackground"),t.background)r?t.background.className=r:(t.background.parentNode.removeChild(t.background),t.background=null);else if(r){var i=Ct(t);t.background=i.insertBefore(n("div",null,r),i.firstChild),e.display.input.setUneditable(t.background)}}function Lt(e,t){var r=e.display.externalMeasured;return r&&r.line==t.line?(e.display.externalMeasured=null,t.measure=r.measure,r.built):st(e,t)}function kt(e,t){var r=t.text.className,n=Lt(e,t);t.text==t.node&&(t.node=n.pre),t.text.parentNode.replaceChild(n.pre,t.text),t.text=n.pre,n.bgClass!=t.bgClass||n.textClass!=t.textClass?(t.bgClass=n.bgClass,t.textClass=n.textClass,Tt(e,t)):r&&(t.text.className=r)}function Tt(e,t){St(e,t),t.line.wrapClass?Ct(t).className=t.line.wrapClass:t.node!=t.text&&(t.node.className="");var r=t.textClass?t.textClass+" "+(t.line.textClass||""):t.line.textClass;t.text.className=r||""}function Mt(e,t,r,i){if(t.gutter&&(t.node.removeChild(t.gutter),t.gutter=null),t.gutterBackground&&(t.node.removeChild(t.gutterBackground),t.gutterBackground=null),t.line.gutterClass){var o=Ct(t);t.gutterBackground=n("div",null,"CodeMirror-gutter-background "+t.line.gutterClass,"left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px; width: "+i.gutterTotalWidth+"px"),e.display.input.setUneditable(t.gutterBackground),o.insertBefore(t.gutterBackground,t.text)}var l=t.line.gutterMarkers;if(e.options.lineNumbers||l){var s=Ct(t),a=t.gutter=n("div",null,"CodeMirror-gutter-wrapper","left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px");if(e.display.input.setUneditable(a),s.insertBefore(a,t.text),t.line.gutterClass&&(a.className+=" "+t.line.gutterClass),!e.options.lineNumbers||l&&l["CodeMirror-linenumbers"]||(t.lineNumber=a.appendChild(n("div",F(e.options,r),"CodeMirror-linenumber CodeMirror-gutter-elt","left: "+i.gutterLeft["CodeMirror-linenumbers"]+"px; width: "+e.display.lineNumInnerWidth+"px"))),l)for(var u=0;u<e.options.gutters.length;++u){var c=e.options.gutters[u],f=l.hasOwnProperty(c)&&l[c];f&&a.appendChild(n("div",[f],"CodeMirror-gutter-elt","left: "+i.gutterLeft[c]+"px; width: "+i.gutterWidth[c]+"px"))}}}function Nt(e,t,r){t.alignable&&(t.alignable=null);for(var n=t.node.firstChild,i=void 0;n;n=i)i=n.nextSibling,"CodeMirror-linewidget"==n.className&&t.node.removeChild(n);At(e,t,r)}function Ot(e,t,r,n){var i=Lt(e,t);return t.text=t.node=i.pre,i.bgClass&&(t.bgClass=i.bgClass),i.textClass&&(t.textClass=i.textClass),Tt(e,t),Mt(e,t,r,n),At(e,t,n),t.node}function At(e,t,r){if(Wt(e,t.line,t,r,!0),t.rest)for(var n=0;n<t.rest.length;n++)Wt(e,t.rest[n],t,r,!1)}function Wt(e,t,r,i,o){if(t.widgets)for(var l=Ct(r),s=0,a=t.widgets;s<a.length;++s){var u=a[s],c=n("div",[u.node],"CodeMirror-linewidget");u.handleMouseEvents||c.setAttribute("cm-ignore-events","true"),Dt(u,c,r,i),e.display.input.setUneditable(c),o&&u.above?l.insertBefore(c,r.gutter||r.text):l.appendChild(c),bt(u,"redraw")}}function Dt(e,t,r,n){if(e.noHScroll){(r.alignable||(r.alignable=[])).push(t);var i=n.wrapperWidth;t.style.left=n.fixedPos+"px",e.coverGutter||(i-=n.gutterTotalWidth,t.style.paddingLeft=n.gutterTotalWidth+"px"),t.style.width=i+"px"}e.coverGutter&&(t.style.zIndex=5,t.style.position="relative",e.noHScroll||(t.style.marginLeft=-n.gutterTotalWidth+"px"))}function Ht(e){if(null!=e.height)return e.height;var t=e.doc.cm;if(!t)return 0;if(!o(document.body,e.node)){var i="position: relative;";e.coverGutter&&(i+="margin-left: -"+t.display.gutters.offsetWidth+"px;"),e.noHScroll&&(i+="width: "+t.display.wrapper.clientWidth+"px;"),r(t.display.measure,n("div",[e.node],null,i))}return e.height=e.node.parentNode.offsetHeight}function Ft(e,t){for(var r=Ee(t);r!=e.wrapper;r=r.parentNode)if(!r||1==r.nodeType&&"true"==r.getAttribute("cm-ignore-events")||r.parentNode==e.sizer&&r!=e.mover)return!0}function Et(e){return e.lineSpace.offsetTop}function Pt(e){return e.mover.offsetHeight-e.lineSpace.offsetHeight}function It(e){if(e.cachedPaddingH)return e.cachedPaddingH;var t=r(e.measure,n("pre","x")),i=window.getComputedStyle?window.getComputedStyle(t):t.currentStyle,o={left:parseInt(i.paddingLeft),right:parseInt(i.paddingRight)};return isNaN(o.left)||isNaN(o.right)||(e.cachedPaddingH=o),o}function zt(e){return Rl-e.display.nativeBarWidth}function Rt(e){return e.display.scroller.clientWidth-zt(e)-e.display.barWidth}function Bt(e){return e.display.scroller.clientHeight-zt(e)-e.display.barHeight}function Gt(e,t,r){var n=e.options.lineWrapping,i=n&&Rt(e);if(!t.measure.heights||n&&t.measure.width!=i){var o=t.measure.heights=[];if(n){t.measure.width=i;for(var l=t.text.firstChild.getClientRects(),s=0;s<l.length-1;s++){var a=l[s],u=l[s+1];Math.abs(a.bottom-u.bottom)>2&&o.push((a.bottom+u.top)/2-r.top)}}o.push(r.bottom-r.top)}}function Ut(e,t,r){if(e.line==t)return{map:e.measure.map,cache:e.measure.cache};for(var n=0;n<e.rest.length;n++)if(e.rest[n]==t)return{map:e.measure.maps[n],cache:e.measure.caches[n]};for(var i=0;i<e.rest.length;i++)if(W(e.rest[i])>r)return{map:e.measure.maps[i],cache:e.measure.caches[i],before:!0}}function Vt(e,t){var n=W(t=fe(t)),i=e.display.externalMeasured=new pt(e.doc,t,n);i.lineN=n;var o=i.built=st(e,i);return i.text=o.pre,r(e.display.lineMeasure,o.pre),i}function Kt(e,t,r,n){return Yt(e,Xt(e,t),r,n)}function jt(e,t){if(t>=e.display.viewFrom&&t<e.display.viewTo)return e.display.view[Lr(e,t)];var r=e.display.externalMeasured;return r&&t>=r.lineN&&t<r.lineN+r.size?r:void 0}function Xt(e,t){var r=W(t),n=jt(e,r);n&&!n.text?n=null:n&&n.changes&&(xt(e,n,r,br(e)),e.curOp.forceUpdate=!0),n||(n=Vt(e,t));var i=Ut(n,t,r);return{line:t,view:n,rect:null,map:i.map,cache:i.cache,before:i.before,hasHeights:!1}}function Yt(e,t,r,n,i){t.before&&(r=-1);var o,l=r+(n||"");return t.cache.hasOwnProperty(l)?o=t.cache[l]:(t.rect||(t.rect=t.view.text.getBoundingClientRect()),t.hasHeights||(Gt(e,t.view,t.rect),t.hasHeights=!0),(o=qt(e,t,r,n)).bogus||(t.cache[l]=o)),{left:o.left,right:o.right,top:i?o.rtop:o.top,bottom:i?o.rbottom:o.bottom}}function _t(e,t,r){for(var n,i,o,l,s,a,u=0;u<e.length;u+=3)if(s=e[u],a=e[u+1],t<s?(i=0,o=1,l="left"):t<a?o=(i=t-s)+1:(u==e.length-3||t==a&&e[u+3]>t)&&(i=(o=a-s)-1,t>=a&&(l="right")),null!=i){if(n=e[u+2],s==a&&r==(n.insertLeft?"left":"right")&&(l=r),"left"==r&&0==i)for(;u&&e[u-2]==e[u-3]&&e[u-1].insertLeft;)n=e[2+(u-=3)],l="left";if("right"==r&&i==a-s)for(;u<e.length-3&&e[u+3]==e[u+4]&&!e[u+5].insertLeft;)n=e[(u+=3)+2],l="right";break}return{node:n,start:i,end:o,collapse:l,coverStart:s,coverEnd:a}}function $t(e,t){var r=ms;if("left"==t)for(var n=0;n<e.length&&(r=e[n]).left==r.right;n++);else for(var i=e.length-1;i>=0&&(r=e[i]).left==r.right;i--);return r}function qt(e,t,r,n){var i,o=_t(t.map,r,n),l=o.node,s=o.start,a=o.end,u=o.collapse;if(3==l.nodeType){for(var c=0;c<4;c++){for(;s&&S(t.line.text.charAt(o.coverStart+s));)--s;for(;o.coverStart+a<o.coverEnd&&S(t.line.text.charAt(o.coverStart+a));)++a;if((i=gl&&vl<9&&0==s&&a==o.coverEnd-o.coverStart?l.parentNode.getBoundingClientRect():$t(Wl(l,s,a).getClientRects(),n)).left||i.right||0==s)break;a=s,s-=1,u="right"}gl&&vl<11&&(i=Zt(e.display.measure,i))}else{s>0&&(u=n="right");var f;i=e.options.lineWrapping&&(f=l.getClientRects()).length>1?f["right"==n?f.length-1:0]:l.getBoundingClientRect()}if(gl&&vl<9&&!s&&(!i||!i.left&&!i.right)){var h=l.parentNode.getClientRects()[0];i=h?{left:h.left,right:h.left+yr(e.display),top:h.top,bottom:h.bottom}:ms}for(var d=i.top-t.rect.top,p=i.bottom-t.rect.top,g=(d+p)/2,v=t.view.measure.heights,m=0;m<v.length-1&&!(g<v[m]);m++);var y=m?v[m-1]:0,b=v[m],w={left:("right"==u?i.right:i.left)-t.rect.left,right:("left"==u?i.left:i.right)-t.rect.left,top:y,bottom:b};return i.left||i.right||(w.bogus=!0),e.options.singleCursorHeightPerLine||(w.rtop=d,w.rbottom=p),w}function Zt(e,t){if(!window.screen||null==screen.logicalXDPI||screen.logicalXDPI==screen.deviceXDPI||!Re(e))return t;var r=screen.logicalXDPI/screen.deviceXDPI,n=screen.logicalYDPI/screen.deviceYDPI;return{left:t.left*r,right:t.right*r,top:t.top*n,bottom:t.bottom*n}}function Qt(e){if(e.measure&&(e.measure.cache={},e.measure.heights=null,e.rest))for(var t=0;t<e.rest.length;t++)e.measure.caches[t]={}}function Jt(e){e.display.externalMeasure=null,t(e.display.lineMeasure);for(var r=0;r<e.display.view.length;r++)Qt(e.display.view[r])}function er(e){Jt(e),e.display.cachedCharWidth=e.display.cachedTextHeight=e.display.cachedPaddingH=null,e.options.lineWrapping||(e.display.maxLineChanged=!0),e.display.lineNumChars=null}function tr(){return bl&&kl?-(document.body.getBoundingClientRect().left-parseInt(getComputedStyle(document.body).marginLeft)):window.pageXOffset||(document.documentElement||document.body).scrollLeft}function rr(){return bl&&kl?-(document.body.getBoundingClientRect().top-parseInt(getComputedStyle(document.body).marginTop)):window.pageYOffset||(document.documentElement||document.body).scrollTop}function nr(e){var t=0;if(e.widgets)for(var r=0;r<e.widgets.length;++r)e.widgets[r].above&&(t+=Ht(e.widgets[r]));return t}function ir(e,t,r,n,i){if(!i){var o=nr(t);r.top+=o,r.bottom+=o}if("line"==n)return r;n||(n="local");var l=ye(t);if("local"==n?l+=Et(e.display):l-=e.display.viewOffset,"page"==n||"window"==n){var s=e.display.lineSpace.getBoundingClientRect();l+=s.top+("window"==n?0:rr());var a=s.left+("window"==n?0:tr());r.left+=a,r.right+=a}return r.top+=l,r.bottom+=l,r}function or(e,t,r){if("div"==r)return t;var n=t.left,i=t.top;if("page"==r)n-=tr(),i-=rr();else if("local"==r||!r){var o=e.display.sizer.getBoundingClientRect();n+=o.left,i+=o.top}var l=e.display.lineSpace.getBoundingClientRect();return{left:n-l.left,top:i-l.top}}function lr(e,t,r,n,i){return n||(n=M(e.doc,t.line)),ir(e,n,Kt(e,n,t.ch,i),r)}function sr(e,t,r,n,i,o){function l(t,l){var s=Yt(e,i,t,l?"right":"left",o);return l?s.left=s.right:s.right=s.left,ir(e,n,s,r)}function s(e,t,r){var n=1==a[t].level;return l(r?e-1:e,n!=r)}n=n||M(e.doc,t.line),i||(i=Xt(e,n));var a=Se(n,e.doc.direction),u=t.ch,c=t.sticky;if(u>=n.text.length?(u=n.text.length,c="before"):u<=0&&(u=0,c="after"),!a)return l("before"==c?u-1:u,"before"==c);var f=Ce(a,u,c),h=$l,d=s(u,f,"before"==c);return null!=h&&(d.other=s(u,h,"before"!=c)),d}function ar(e,t){var r=0;t=U(e.doc,t),e.options.lineWrapping||(r=yr(e.display)*t.ch);var n=M(e.doc,t.line),i=ye(n)+Et(e.display);return{left:r,right:r,top:i,bottom:i+n.height}}function ur(e,t,r,n,i){var o=E(e,t,r);return o.xRel=i,n&&(o.outside=!0),o}function cr(e,t,r){var n=e.doc;if((r+=e.display.viewOffset)<0)return ur(n.first,0,null,!0,-1);var i=D(n,r),o=n.first+n.size-1;if(i>o)return ur(n.first+n.size-1,M(n,o).text.length,null,!0,1);t<0&&(t=0);for(var l=M(n,i);;){var s=pr(e,l,i,t,r),a=ue(l),u=a&&a.find(0,!0);if(!a||!(s.ch>u.from.ch||s.ch==u.from.ch&&s.xRel>0))return s;i=W(l=u.to.line)}}function fr(e,t,r,n){n-=nr(t);var i=t.text.length,o=k(function(t){return Yt(e,r,t-1).bottom<=n},i,0);return i=k(function(t){return Yt(e,r,t).top>n},o,i),{begin:o,end:i}}function hr(e,t,r,n){return r||(r=Xt(e,t)),fr(e,t,r,ir(e,t,Yt(e,r,n),"line").top)}function dr(e,t,r,n){return!(e.bottom<=r)&&(e.top>r||(n?e.left:e.right)>t)}function pr(e,t,r,n,i){i-=ye(t);var o=Xt(e,t),l=nr(t),s=0,a=t.text.length,u=!0,c=Se(t,e.doc.direction);if(c){var f=(e.options.lineWrapping?vr:gr)(e,t,r,o,c,n,i);s=(u=1!=f.level)?f.from:f.to-1,a=u?f.to:f.from-1}var h,d,p=null,g=null,v=k(function(t){var r=Yt(e,o,t);return r.top+=l,r.bottom+=l,!!dr(r,n,i,!1)&&(r.top<=i&&r.left<=n&&(p=t,g=r),!0)},s,a),m=!1;if(g){var y=n-g.left<g.right-n,b=y==u;v=p+(b?0:1),d=b?"after":"before",h=y?g.left:g.right}else{u||v!=a&&v!=s||v++,d=0==v?"after":v==t.text.length?"before":Yt(e,o,v-(u?1:0)).bottom+l<=i==u?"after":"before";var w=sr(e,E(r,v,d),"line",t,o);h=w.left,m=i<w.top||i>=w.bottom}return v=L(t.text,v,1),ur(r,v,d,m,n-h)}function gr(e,t,r,n,i,o,l){var s=k(function(s){var a=i[s],u=1!=a.level;return dr(sr(e,E(r,u?a.to:a.from,u?"before":"after"),"line",t,n),o,l,!0)},0,i.length-1),a=i[s];if(s>0){var u=1!=a.level,c=sr(e,E(r,u?a.from:a.to,u?"after":"before"),"line",t,n);dr(c,o,l,!0)&&c.top>l&&(a=i[s-1])}return a}function vr(e,t,r,n,i,o,l){for(var s=fr(e,t,n,l),a=s.begin,u=s.end,c=null,f=null,h=0;h<i.length;h++){var d=i[h];if(!(d.from>=u||d.to<=a)){var p=Yt(e,n,1!=d.level?Math.min(u,d.to)-1:Math.max(a,d.from)).right,g=p<o?o-p+1e9:p-o;(!c||f>g)&&(c=d,f=g)}}return c||(c=i[i.length-1]),c.from<a&&(c={from:a,to:c.to,level:c.level}),c.to>u&&(c={from:c.from,to:u,level:c.level}),c}function mr(e){if(null!=e.cachedTextHeight)return e.cachedTextHeight;if(null==hs){hs=n("pre");for(var i=0;i<49;++i)hs.appendChild(document.createTextNode("x")),hs.appendChild(n("br"));hs.appendChild(document.createTextNode("x"))}r(e.measure,hs);var o=hs.offsetHeight/50;return o>3&&(e.cachedTextHeight=o),t(e.measure),o||1}function yr(e){if(null!=e.cachedCharWidth)return e.cachedCharWidth;var t=n("span","xxxxxxxxxx"),i=n("pre",[t]);r(e.measure,i);var o=t.getBoundingClientRect(),l=(o.right-o.left)/10;return l>2&&(e.cachedCharWidth=l),l||10}function br(e){for(var t=e.display,r={},n={},i=t.gutters.clientLeft,o=t.gutters.firstChild,l=0;o;o=o.nextSibling,++l)r[e.options.gutters[l]]=o.offsetLeft+o.clientLeft+i,n[e.options.gutters[l]]=o.clientWidth;return{fixedPos:wr(t),gutterTotalWidth:t.gutters.offsetWidth,gutterLeft:r,gutterWidth:n,wrapperWidth:t.wrapper.clientWidth}}function wr(e){return e.scroller.getBoundingClientRect().left-e.sizer.getBoundingClientRect().left}function xr(e){var t=mr(e.display),r=e.options.lineWrapping,n=r&&Math.max(5,e.display.scroller.clientWidth/yr(e.display)-3);return function(i){if(ve(e.doc,i))return 0;var o=0;if(i.widgets)for(var l=0;l<i.widgets.length;l++)i.widgets[l].height&&(o+=i.widgets[l].height);return r?o+(Math.ceil(i.text.length/n)||1)*t:o+t}}function Cr(e){var t=e.doc,r=xr(e);t.iter(function(e){var t=r(e);t!=e.height&&A(e,t)})}function Sr(e,t,r,n){var i=e.display;if(!r&&"true"==Ee(t).getAttribute("cm-not-content"))return null;var o,l,s=i.lineSpace.getBoundingClientRect();try{o=t.clientX-s.left,l=t.clientY-s.top}catch(t){return null}var a,u=cr(e,o,l);if(n&&1==u.xRel&&(a=M(e.doc,u.line).text).length==u.ch){var c=f(a,a.length,e.options.tabSize)-a.length;u=E(u.line,Math.max(0,Math.round((o-It(e.display).left)/yr(e.display))-c))}return u}function Lr(e,t){if(t>=e.display.viewTo)return null;if((t-=e.display.viewFrom)<0)return null;for(var r=e.display.view,n=0;n<r.length;n++)if((t-=r[n].size)<0)return n}function kr(e){e.display.input.showSelection(e.display.input.prepareSelection())}function Tr(e,t){void 0===t&&(t=!0);for(var r=e.doc,n={},i=n.cursors=document.createDocumentFragment(),o=n.selection=document.createDocumentFragment(),l=0;l<r.sel.ranges.length;l++)if(t||l!=r.sel.primIndex){var s=r.sel.ranges[l];if(!(s.from().line>=e.display.viewTo||s.to().line<e.display.viewFrom)){var a=s.empty();(a||e.options.showCursorWhenSelecting)&&Mr(e,s.head,i),a||Or(e,s,o)}}return n}function Mr(e,t,r){var i=sr(e,t,"div",null,null,!e.options.singleCursorHeightPerLine),o=r.appendChild(n("div"," ","CodeMirror-cursor"));if(o.style.left=i.left+"px",o.style.top=i.top+"px",o.style.height=Math.max(0,i.bottom-i.top)*e.options.cursorHeight+"px",i.other){var l=r.appendChild(n("div"," ","CodeMirror-cursor CodeMirror-secondarycursor"));l.style.display="",l.style.left=i.other.left+"px",l.style.top=i.other.top+"px",l.style.height=.85*(i.other.bottom-i.other.top)+"px"}}function Nr(e,t){return e.top-t.top||e.left-t.left}function Or(e,t,r){function i(e,t,r,i){t<0&&(t=0),t=Math.round(t),i=Math.round(i),a.appendChild(n("div",null,"CodeMirror-selected","position: absolute; left: "+e+"px;\n                             top: "+t+"px; width: "+(null==r?f-e:r)+"px;\n                             height: "+(i-t)+"px"))}function o(t,r,n){function o(r,n){return lr(e,E(t,r),"div",u,n)}var l,a,u=M(s,t),h=u.text.length,d=Se(u,s.direction);return xe(d,r||0,null==n?h:n,function(t,s,p,g){var v=o(t,"ltr"==p?"left":"right"),m=o(s-1,"ltr"==p?"right":"left");if("ltr"==p){var y=null==r&&0==t?c:v.left,b=null==n&&s==h?f:m.right;m.top-v.top<=3?i(y,m.top,b-y,m.bottom):(i(y,v.top,null,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top),i(c,m.top,m.right,m.bottom))}else if(t<s){var w=null==r&&0==t?f:v.right,x=null==n&&s==h?c:m.left;if(m.top-v.top<=3)i(x,m.top,w-x,m.bottom);else{var C=c;if(g){var S=hr(e,u,null,t).end;C=o(S-(/\s/.test(u.text.charAt(S-1))?2:1),"left").left}i(C,v.top,w-C,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top);var L=null;d.length,L=o(hr(e,u,null,s).begin,"right").right-x,i(x,m.top,L,m.bottom)}}(!l||Nr(v,l)<0)&&(l=v),Nr(m,l)<0&&(l=m),(!a||Nr(v,a)<0)&&(a=v),Nr(m,a)<0&&(a=m)}),{start:l,end:a}}var l=e.display,s=e.doc,a=document.createDocumentFragment(),u=It(e.display),c=u.left,f=Math.max(l.sizerWidth,Rt(e)-l.sizer.offsetLeft)-u.right,h=t.from(),d=t.to();if(h.line==d.line)o(h.line,h.ch,d.ch);else{var p=M(s,h.line),g=M(s,d.line),v=fe(p)==fe(g),m=o(h.line,h.ch,v?p.text.length+1:null).end,y=o(d.line,v?0:null,d.ch).start;v&&(m.top<y.top-2?(i(m.right,m.top,null,m.bottom),i(c,y.top,y.left,y.bottom)):i(m.right,m.top,y.left-m.right,m.bottom)),m.bottom<y.top&&i(c,m.bottom,null,y.top)}r.appendChild(a)}function Ar(e){if(e.state.focused){var t=e.display;clearInterval(t.blinker);var r=!0;t.cursorDiv.style.visibility="",e.options.cursorBlinkRate>0?t.blinker=setInterval(function(){return t.cursorDiv.style.visibility=(r=!r)?"":"hidden"},e.options.cursorBlinkRate):e.options.cursorBlinkRate<0&&(t.cursorDiv.style.visibility="hidden")}}function Wr(e){e.state.focused||(e.display.input.focus(),Hr(e))}function Dr(e){e.state.delayingBlurEvent=!0,setTimeout(function(){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1,Fr(e))},100)}function Hr(e,t){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1),"nocursor"!=e.options.readOnly&&(e.state.focused||(Te(e,"focus",e,t),e.state.focused=!0,s(e.display.wrapper,"CodeMirror-focused"),e.curOp||e.display.selForContextMenu==e.doc.sel||(e.display.input.reset(),ml&&setTimeout(function(){return e.display.input.reset(!0)},20)),e.display.input.receivedFocus()),Ar(e))}function Fr(e,t){e.state.delayingBlurEvent||(e.state.focused&&(Te(e,"blur",e,t),e.state.focused=!1,Fl(e.display.wrapper,"CodeMirror-focused")),clearInterval(e.display.blinker),setTimeout(function(){e.state.focused||(e.display.shift=!1)},150))}function Er(e){for(var t=e.display,r=t.lineDiv.offsetTop,n=0;n<t.view.length;n++){var i=t.view[n],o=void 0;if(!i.hidden){if(gl&&vl<8){var l=i.node.offsetTop+i.node.offsetHeight;o=l-r,r=l}else{var s=i.node.getBoundingClientRect();o=s.bottom-s.top}var a=i.line.height-o;if(o<2&&(o=mr(t)),(a>.005||a<-.005)&&(A(i.line,o),Pr(i.line),i.rest))for(var u=0;u<i.rest.length;u++)Pr(i.rest[u])}}}function Pr(e){if(e.widgets)for(var t=0;t<e.widgets.length;++t)e.widgets[t].height=e.widgets[t].node.parentNode.offsetHeight}function Ir(e,t,r){var n=r&&null!=r.top?Math.max(0,r.top):e.scroller.scrollTop;n=Math.floor(n-Et(e));var i=r&&null!=r.bottom?r.bottom:n+e.wrapper.clientHeight,o=D(t,n),l=D(t,i);if(r&&r.ensure){var s=r.ensure.from.line,a=r.ensure.to.line;s<o?(o=s,l=D(t,ye(M(t,s))+e.wrapper.clientHeight)):Math.min(a,t.lastLine())>=l&&(o=D(t,ye(M(t,a))-e.wrapper.clientHeight),l=a)}return{from:o,to:Math.max(l,o+1)}}function zr(e){var t=e.display,r=t.view;if(t.alignWidgets||t.gutters.firstChild&&e.options.fixedGutter){for(var n=wr(t)-t.scroller.scrollLeft+e.doc.scrollLeft,i=t.gutters.offsetWidth,o=n+"px",l=0;l<r.length;l++)if(!r[l].hidden){e.options.fixedGutter&&(r[l].gutter&&(r[l].gutter.style.left=o),r[l].gutterBackground&&(r[l].gutterBackground.style.left=o));var s=r[l].alignable;if(s)for(var a=0;a<s.length;a++)s[a].style.left=o}e.options.fixedGutter&&(t.gutters.style.left=n+i+"px")}}function Rr(e){if(!e.options.lineNumbers)return!1;var t=e.doc,r=F(e.options,t.first+t.size-1),i=e.display;if(r.length!=i.lineNumChars){var o=i.measure.appendChild(n("div",[n("div",r)],"CodeMirror-linenumber CodeMirror-gutter-elt")),l=o.firstChild.offsetWidth,s=o.offsetWidth-l;return i.lineGutter.style.width="",i.lineNumInnerWidth=Math.max(l,i.lineGutter.offsetWidth-s)+1,i.lineNumWidth=i.lineNumInnerWidth+s,i.lineNumChars=i.lineNumInnerWidth?r.length:-1,i.lineGutter.style.width=i.lineNumWidth+"px",Wn(e),!0}return!1}function Br(e,t){if(!Me(e,"scrollCursorIntoView")){var r=e.display,i=r.sizer.getBoundingClientRect(),o=null;if(t.top+i.top<0?o=!0:t.bottom+i.top>(window.innerHeight||document.documentElement.clientHeight)&&(o=!1),null!=o&&!Sl){var l=n("div","​",null,"position: absolute;\n                         top: "+(t.top-r.viewOffset-Et(e.display))+"px;\n                         height: "+(t.bottom-t.top+zt(e)+r.barHeight)+"px;\n                         left: "+t.left+"px; width: "+Math.max(2,t.right-t.left)+"px;");e.display.lineSpace.appendChild(l),l.scrollIntoView(o),e.display.lineSpace.removeChild(l)}}}function Gr(e,t,r,n){null==n&&(n=0);var i;e.options.lineWrapping||t!=r||(r="before"==(t=t.ch?E(t.line,"before"==t.sticky?t.ch-1:t.ch,"after"):t).sticky?E(t.line,t.ch+1,"before"):t);for(var o=0;o<5;o++){var l=!1,s=sr(e,t),a=r&&r!=t?sr(e,r):s,u=Vr(e,i={left:Math.min(s.left,a.left),top:Math.min(s.top,a.top)-n,right:Math.max(s.left,a.left),bottom:Math.max(s.bottom,a.bottom)+n}),c=e.doc.scrollTop,f=e.doc.scrollLeft;if(null!=u.scrollTop&&(qr(e,u.scrollTop),Math.abs(e.doc.scrollTop-c)>1&&(l=!0)),null!=u.scrollLeft&&(Qr(e,u.scrollLeft),Math.abs(e.doc.scrollLeft-f)>1&&(l=!0)),!l)break}return i}function Ur(e,t){var r=Vr(e,t);null!=r.scrollTop&&qr(e,r.scrollTop),null!=r.scrollLeft&&Qr(e,r.scrollLeft)}function Vr(e,t){var r=e.display,n=mr(e.display);t.top<0&&(t.top=0);var i=e.curOp&&null!=e.curOp.scrollTop?e.curOp.scrollTop:r.scroller.scrollTop,o=Bt(e),l={};t.bottom-t.top>o&&(t.bottom=t.top+o);var s=e.doc.height+Pt(r),a=t.top<n,u=t.bottom>s-n;if(t.top<i)l.scrollTop=a?0:t.top;else if(t.bottom>i+o){var c=Math.min(t.top,(u?s:t.bottom)-o);c!=i&&(l.scrollTop=c)}var f=e.curOp&&null!=e.curOp.scrollLeft?e.curOp.scrollLeft:r.scroller.scrollLeft,h=Rt(e)-(e.options.fixedGutter?r.gutters.offsetWidth:0),d=t.right-t.left>h;return d&&(t.right=t.left+h),t.left<10?l.scrollLeft=0:t.left<f?l.scrollLeft=Math.max(0,t.left-(d?0:10)):t.right>h+f-3&&(l.scrollLeft=t.right+(d?0:10)-h),l}function Kr(e,t){null!=t&&(_r(e),e.curOp.scrollTop=(null==e.curOp.scrollTop?e.doc.scrollTop:e.curOp.scrollTop)+t)}function jr(e){_r(e);var t=e.getCursor();e.curOp.scrollToPos={from:t,to:t,margin:e.options.cursorScrollMargin}}function Xr(e,t,r){null==t&&null==r||_r(e),null!=t&&(e.curOp.scrollLeft=t),null!=r&&(e.curOp.scrollTop=r)}function Yr(e,t){_r(e),e.curOp.scrollToPos=t}function _r(e){var t=e.curOp.scrollToPos;t&&(e.curOp.scrollToPos=null,$r(e,ar(e,t.from),ar(e,t.to),t.margin))}function $r(e,t,r,n){var i=Vr(e,{left:Math.min(t.left,r.left),top:Math.min(t.top,r.top)-n,right:Math.max(t.right,r.right),bottom:Math.max(t.bottom,r.bottom)+n});Xr(e,i.scrollLeft,i.scrollTop)}function qr(e,t){Math.abs(e.doc.scrollTop-t)<2||(fl||On(e,{top:t}),Zr(e,t,!0),fl&&On(e),Cn(e,100))}function Zr(e,t,r){t=Math.min(e.display.scroller.scrollHeight-e.display.scroller.clientHeight,t),(e.display.scroller.scrollTop!=t||r)&&(e.doc.scrollTop=t,e.display.scrollbars.setScrollTop(t),e.display.scroller.scrollTop!=t&&(e.display.scroller.scrollTop=t))}function Qr(e,t,r,n){t=Math.min(t,e.display.scroller.scrollWidth-e.display.scroller.clientWidth),(r?t==e.doc.scrollLeft:Math.abs(e.doc.scrollLeft-t)<2)&&!n||(e.doc.scrollLeft=t,zr(e),e.display.scroller.scrollLeft!=t&&(e.display.scroller.scrollLeft=t),e.display.scrollbars.setScrollLeft(t))}function Jr(e){var t=e.display,r=t.gutters.offsetWidth,n=Math.round(e.doc.height+Pt(e.display));return{clientHeight:t.scroller.clientHeight,viewHeight:t.wrapper.clientHeight,scrollWidth:t.scroller.scrollWidth,clientWidth:t.scroller.clientWidth,viewWidth:t.wrapper.clientWidth,barLeft:e.options.fixedGutter?r:0,docHeight:n,scrollHeight:n+zt(e)+t.barHeight,nativeBarWidth:t.nativeBarWidth,gutterWidth:r}}function en(e,t){t||(t=Jr(e));var r=e.display.barWidth,n=e.display.barHeight;tn(e,t);for(var i=0;i<4&&r!=e.display.barWidth||n!=e.display.barHeight;i++)r!=e.display.barWidth&&e.options.lineWrapping&&Er(e),tn(e,Jr(e)),r=e.display.barWidth,n=e.display.barHeight}function tn(e,t){var r=e.display,n=r.scrollbars.update(t);r.sizer.style.paddingRight=(r.barWidth=n.right)+"px",r.sizer.style.paddingBottom=(r.barHeight=n.bottom)+"px",r.heightForcer.style.borderBottom=n.bottom+"px solid transparent",n.right&&n.bottom?(r.scrollbarFiller.style.display="block",r.scrollbarFiller.style.height=n.bottom+"px",r.scrollbarFiller.style.width=n.right+"px"):r.scrollbarFiller.style.display="",n.bottom&&e.options.coverGutterNextToScrollbar&&e.options.fixedGutter?(r.gutterFiller.style.display="block",r.gutterFiller.style.height=n.bottom+"px",r.gutterFiller.style.width=t.gutterWidth+"px"):r.gutterFiller.style.display=""}function rn(e){e.display.scrollbars&&(e.display.scrollbars.clear(),e.display.scrollbars.addClass&&Fl(e.display.wrapper,e.display.scrollbars.addClass)),e.display.scrollbars=new ws[e.options.scrollbarStyle](function(t){e.display.wrapper.insertBefore(t,e.display.scrollbarFiller),Ql(t,"mousedown",function(){e.state.focused&&setTimeout(function(){return e.display.input.focus()},0)}),t.setAttribute("cm-not-content","true")},function(t,r){"horizontal"==r?Qr(e,t):qr(e,t)},e),e.display.scrollbars.addClass&&s(e.display.wrapper,e.display.scrollbars.addClass)}function nn(e){e.curOp={cm:e,viewChanged:!1,startHeight:e.doc.height,forceUpdate:!1,updateInput:null,typing:!1,changeObjs:null,cursorActivityHandlers:null,cursorActivityCalled:0,selectionChanged:!1,updateMaxLine:!1,scrollLeft:null,scrollTop:null,scrollToPos:null,focus:!1,id:++xs},vt(e.curOp)}function on(e){yt(e.curOp,function(e){for(var t=0;t<e.ops.length;t++)e.ops[t].cm.curOp=null;ln(e)})}function ln(e){for(var t=e.ops,r=0;r<t.length;r++)sn(t[r]);for(var n=0;n<t.length;n++)an(t[n]);for(var i=0;i<t.length;i++)un(t[i]);for(var o=0;o<t.length;o++)cn(t[o]);for(var l=0;l<t.length;l++)fn(t[l])}function sn(e){var t=e.cm,r=t.display;Ln(t),e.updateMaxLine&&we(t),e.mustUpdate=e.viewChanged||e.forceUpdate||null!=e.scrollTop||e.scrollToPos&&(e.scrollToPos.from.line<r.viewFrom||e.scrollToPos.to.line>=r.viewTo)||r.maxLineChanged&&t.options.lineWrapping,e.update=e.mustUpdate&&new Cs(t,e.mustUpdate&&{top:e.scrollTop,ensure:e.scrollToPos},e.forceUpdate)}function an(e){e.updatedDisplay=e.mustUpdate&&Mn(e.cm,e.update)}function un(e){var t=e.cm,r=t.display;e.updatedDisplay&&Er(t),e.barMeasure=Jr(t),r.maxLineChanged&&!t.options.lineWrapping&&(e.adjustWidthTo=Kt(t,r.maxLine,r.maxLine.text.length).left+3,t.display.sizerWidth=e.adjustWidthTo,e.barMeasure.scrollWidth=Math.max(r.scroller.clientWidth,r.sizer.offsetLeft+e.adjustWidthTo+zt(t)+t.display.barWidth),e.maxScrollLeft=Math.max(0,r.sizer.offsetLeft+e.adjustWidthTo-Rt(t))),(e.updatedDisplay||e.selectionChanged)&&(e.preparedSelection=r.input.prepareSelection())}function cn(e){var t=e.cm;null!=e.adjustWidthTo&&(t.display.sizer.style.minWidth=e.adjustWidthTo+"px",e.maxScrollLeft<t.doc.scrollLeft&&Qr(t,Math.min(t.display.scroller.scrollLeft,e.maxScrollLeft),!0),t.display.maxLineChanged=!1);var r=e.focus&&e.focus==l();e.preparedSelection&&t.display.input.showSelection(e.preparedSelection,r),(e.updatedDisplay||e.startHeight!=t.doc.height)&&en(t,e.barMeasure),e.updatedDisplay&&Dn(t,e.barMeasure),e.selectionChanged&&Ar(t),t.state.focused&&e.updateInput&&t.display.input.reset(e.typing),r&&Wr(e.cm)}function fn(e){var t=e.cm,r=t.display,n=t.doc;e.updatedDisplay&&Nn(t,e.update),null==r.wheelStartX||null==e.scrollTop&&null==e.scrollLeft&&!e.scrollToPos||(r.wheelStartX=r.wheelStartY=null),null!=e.scrollTop&&Zr(t,e.scrollTop,e.forceScroll),null!=e.scrollLeft&&Qr(t,e.scrollLeft,!0,!0),e.scrollToPos&&Br(t,Gr(t,U(n,e.scrollToPos.from),U(n,e.scrollToPos.to),e.scrollToPos.margin));var i=e.maybeHiddenMarkers,o=e.maybeUnhiddenMarkers;if(i)for(var l=0;l<i.length;++l)i[l].lines.length||Te(i[l],"hide");if(o)for(var s=0;s<o.length;++s)o[s].lines.length&&Te(o[s],"unhide");r.wrapper.offsetHeight&&(n.scrollTop=t.display.scroller.scrollTop),e.changeObjs&&Te(t,"changes",t,e.changeObjs),e.update&&e.update.finish()}function hn(e,t){if(e.curOp)return t();nn(e);try{return t()}finally{on(e)}}function dn(e,t){return function(){if(e.curOp)return t.apply(e,arguments);nn(e);try{return t.apply(e,arguments)}finally{on(e)}}}function pn(e){return function(){if(this.curOp)return e.apply(this,arguments);nn(this);try{return e.apply(this,arguments)}finally{on(this)}}}function gn(e){return function(){var t=this.cm;if(!t||t.curOp)return e.apply(this,arguments);nn(t);try{return e.apply(this,arguments)}finally{on(t)}}}function vn(e,t,r,n){null==t&&(t=e.doc.first),null==r&&(r=e.doc.first+e.doc.size),n||(n=0);var i=e.display;if(n&&r<i.viewTo&&(null==i.updateLineNumbers||i.updateLineNumbers>t)&&(i.updateLineNumbers=t),e.curOp.viewChanged=!0,t>=i.viewTo)_l&&pe(e.doc,t)<i.viewTo&&yn(e);else if(r<=i.viewFrom)_l&&ge(e.doc,r+n)>i.viewFrom?yn(e):(i.viewFrom+=n,i.viewTo+=n);else if(t<=i.viewFrom&&r>=i.viewTo)yn(e);else if(t<=i.viewFrom){var o=bn(e,r,r+n,1);o?(i.view=i.view.slice(o.index),i.viewFrom=o.lineN,i.viewTo+=n):yn(e)}else if(r>=i.viewTo){var l=bn(e,t,t,-1);l?(i.view=i.view.slice(0,l.index),i.viewTo=l.lineN):yn(e)}else{var s=bn(e,t,t,-1),a=bn(e,r,r+n,1);s&&a?(i.view=i.view.slice(0,s.index).concat(gt(e,s.lineN,a.lineN)).concat(i.view.slice(a.index)),i.viewTo+=n):yn(e)}var u=i.externalMeasured;u&&(r<u.lineN?u.lineN+=n:t<u.lineN+u.size&&(i.externalMeasured=null))}function mn(e,t,r){e.curOp.viewChanged=!0;var n=e.display,i=e.display.externalMeasured;if(i&&t>=i.lineN&&t<i.lineN+i.size&&(n.externalMeasured=null),!(t<n.viewFrom||t>=n.viewTo)){var o=n.view[Lr(e,t)];if(null!=o.node){var l=o.changes||(o.changes=[]);-1==h(l,r)&&l.push(r)}}}function yn(e){e.display.viewFrom=e.display.viewTo=e.doc.first,e.display.view=[],e.display.viewOffset=0}function bn(e,t,r,n){var i,o=Lr(e,t),l=e.display.view;if(!_l||r==e.doc.first+e.doc.size)return{index:o,lineN:r};for(var s=e.display.viewFrom,a=0;a<o;a++)s+=l[a].size;if(s!=t){if(n>0){if(o==l.length-1)return null;i=s+l[o].size-t,o++}else i=s-t;t+=i,r+=i}for(;pe(e.doc,r)!=r;){if(o==(n<0?0:l.length-1))return null;r+=n*l[o-(n<0?1:0)].size,o+=n}return{index:o,lineN:r}}function wn(e,t,r){var n=e.display;0==n.view.length||t>=n.viewTo||r<=n.viewFrom?(n.view=gt(e,t,r),n.viewFrom=t):(n.viewFrom>t?n.view=gt(e,t,n.viewFrom).concat(n.view):n.viewFrom<t&&(n.view=n.view.slice(Lr(e,t))),n.viewFrom=t,n.viewTo<r?n.view=n.view.concat(gt(e,n.viewTo,r)):n.viewTo>r&&(n.view=n.view.slice(0,Lr(e,r)))),n.viewTo=r}function xn(e){for(var t=e.display.view,r=0,n=0;n<t.length;n++){var i=t[n];i.hidden||i.node&&!i.changes||++r}return r}function Cn(e,t){e.doc.highlightFrontier<e.display.viewTo&&e.state.highlight.set(t,u(Sn,e))}function Sn(e){var t=e.doc;if(!(t.highlightFrontier>=e.display.viewTo)){var r=+new Date+e.options.workTime,n=$e(e,t.highlightFrontier),i=[];t.iter(n.line,Math.min(t.first+t.size,e.display.viewTo+500),function(o){if(n.line>=e.display.viewFrom){var l=o.styles,s=o.text.length>e.options.maxHighlightLength?Ke(t.mode,n.state):null,a=Ye(e,o,n,!0);s&&(n.state=s),o.styles=a.styles;var u=o.styleClasses,c=a.classes;c?o.styleClasses=c:u&&(o.styleClasses=null);for(var f=!l||l.length!=o.styles.length||u!=c&&(!u||!c||u.bgClass!=c.bgClass||u.textClass!=c.textClass),h=0;!f&&h<l.length;++h)f=l[h]!=o.styles[h];f&&i.push(n.line),o.stateAfter=n.save(),n.nextLine()}else o.text.length<=e.options.maxHighlightLength&&qe(e,o.text,n),o.stateAfter=n.line%5==0?n.save():null,n.nextLine();if(+new Date>r)return Cn(e,e.options.workDelay),!0}),t.highlightFrontier=n.line,t.modeFrontier=Math.max(t.modeFrontier,n.line),i.length&&hn(e,function(){for(var t=0;t<i.length;t++)mn(e,i[t],"text")})}}function Ln(e){var t=e.display;!t.scrollbarsClipped&&t.scroller.offsetWidth&&(t.nativeBarWidth=t.scroller.offsetWidth-t.scroller.clientWidth,t.heightForcer.style.height=zt(e)+"px",t.sizer.style.marginBottom=-t.nativeBarWidth+"px",t.sizer.style.borderRightWidth=zt(e)+"px",t.scrollbarsClipped=!0)}function kn(e){if(e.hasFocus())return null;var t=l();if(!t||!o(e.display.lineDiv,t))return null;var r={activeElt:t};if(window.getSelection){var n=window.getSelection();n.anchorNode&&n.extend&&o(e.display.lineDiv,n.anchorNode)&&(r.anchorNode=n.anchorNode,r.anchorOffset=n.anchorOffset,r.focusNode=n.focusNode,r.focusOffset=n.focusOffset)}return r}function Tn(e){if(e&&e.activeElt&&e.activeElt!=l()&&(e.activeElt.focus(),e.anchorNode&&o(document.body,e.anchorNode)&&o(document.body,e.focusNode))){var t=window.getSelection(),r=document.createRange();r.setEnd(e.anchorNode,e.anchorOffset),r.collapse(!1),t.removeAllRanges(),t.addRange(r),t.extend(e.focusNode,e.focusOffset)}}function Mn(e,r){var n=e.display,i=e.doc;if(r.editorIsHidden)return yn(e),!1;if(!r.force&&r.visible.from>=n.viewFrom&&r.visible.to<=n.viewTo&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo)&&n.renderedView==n.view&&0==xn(e))return!1;Rr(e)&&(yn(e),r.dims=br(e));var o=i.first+i.size,l=Math.max(r.visible.from-e.options.viewportMargin,i.first),s=Math.min(o,r.visible.to+e.options.viewportMargin);n.viewFrom<l&&l-n.viewFrom<20&&(l=Math.max(i.first,n.viewFrom)),n.viewTo>s&&n.viewTo-s<20&&(s=Math.min(o,n.viewTo)),_l&&(l=pe(e.doc,l),s=ge(e.doc,s));var a=l!=n.viewFrom||s!=n.viewTo||n.lastWrapHeight!=r.wrapperHeight||n.lastWrapWidth!=r.wrapperWidth;wn(e,l,s),n.viewOffset=ye(M(e.doc,n.viewFrom)),e.display.mover.style.top=n.viewOffset+"px";var u=xn(e);if(!a&&0==u&&!r.force&&n.renderedView==n.view&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo))return!1;var c=kn(e);return u>4&&(n.lineDiv.style.display="none"),An(e,n.updateLineNumbers,r.dims),u>4&&(n.lineDiv.style.display=""),n.renderedView=n.view,Tn(c),t(n.cursorDiv),t(n.selectionDiv),n.gutters.style.height=n.sizer.style.minHeight=0,a&&(n.lastWrapHeight=r.wrapperHeight,n.lastWrapWidth=r.wrapperWidth,Cn(e,400)),n.updateLineNumbers=null,!0}function Nn(e,t){for(var r=t.viewport,n=!0;(n&&e.options.lineWrapping&&t.oldDisplayWidth!=Rt(e)||(r&&null!=r.top&&(r={top:Math.min(e.doc.height+Pt(e.display)-Bt(e),r.top)}),t.visible=Ir(e.display,e.doc,r),!(t.visible.from>=e.display.viewFrom&&t.visible.to<=e.display.viewTo)))&&Mn(e,t);n=!1){Er(e);var i=Jr(e);kr(e),en(e,i),Dn(e,i),t.force=!1}t.signal(e,"update",e),e.display.viewFrom==e.display.reportedViewFrom&&e.display.viewTo==e.display.reportedViewTo||(t.signal(e,"viewportChange",e,e.display.viewFrom,e.display.viewTo),e.display.reportedViewFrom=e.display.viewFrom,e.display.reportedViewTo=e.display.viewTo)}function On(e,t){var r=new Cs(e,t);if(Mn(e,r)){Er(e),Nn(e,r);var n=Jr(e);kr(e),en(e,n),Dn(e,n),r.finish()}}function An(e,r,n){function i(t){var r=t.nextSibling;return ml&&Ml&&e.display.currentWheelTarget==t?t.style.display="none":t.parentNode.removeChild(t),r}for(var o=e.display,l=e.options.lineNumbers,s=o.lineDiv,a=s.firstChild,u=o.view,c=o.viewFrom,f=0;f<u.length;f++){var d=u[f];if(d.hidden);else if(d.node&&d.node.parentNode==s){for(;a!=d.node;)a=i(a);var p=l&&null!=r&&r<=c&&d.lineNumber;d.changes&&(h(d.changes,"gutter")>-1&&(p=!1),xt(e,d,c,n)),p&&(t(d.lineNumber),d.lineNumber.appendChild(document.createTextNode(F(e.options,c)))),a=d.node.nextSibling}else{var g=Ot(e,d,c,n);s.insertBefore(g,a)}c+=d.size}for(;a;)a=i(a)}function Wn(e){var t=e.display.gutters.offsetWidth;e.display.sizer.style.marginLeft=t+"px"}function Dn(e,t){e.display.sizer.style.minHeight=t.docHeight+"px",e.display.heightForcer.style.top=t.docHeight+"px",e.display.gutters.style.height=t.docHeight+e.display.barHeight+zt(e)+"px"}function Hn(e){var r=e.display.gutters,i=e.options.gutters;t(r);for(var o=0;o<i.length;++o){var l=i[o],s=r.appendChild(n("div",null,"CodeMirror-gutter "+l));"CodeMirror-linenumbers"==l&&(e.display.lineGutter=s,s.style.width=(e.display.lineNumWidth||1)+"px")}r.style.display=o?"":"none",Wn(e)}function Fn(e){var t=h(e.gutters,"CodeMirror-linenumbers");-1==t&&e.lineNumbers?e.gutters=e.gutters.concat(["CodeMirror-linenumbers"]):t>-1&&!e.lineNumbers&&(e.gutters=e.gutters.slice(0),e.gutters.splice(t,1))}function En(e){var t=e.wheelDeltaX,r=e.wheelDeltaY;return null==t&&e.detail&&e.axis==e.HORIZONTAL_AXIS&&(t=e.detail),null==r&&e.detail&&e.axis==e.VERTICAL_AXIS?r=e.detail:null==r&&(r=e.wheelDelta),{x:t,y:r}}function Pn(e){var t=En(e);return t.x*=Ls,t.y*=Ls,t}function In(e,t){var r=En(t),n=r.x,i=r.y,o=e.display,l=o.scroller,s=l.scrollWidth>l.clientWidth,a=l.scrollHeight>l.clientHeight;if(n&&s||i&&a){if(i&&Ml&&ml)e:for(var u=t.target,c=o.view;u!=l;u=u.parentNode)for(var f=0;f<c.length;f++)if(c[f].node==u){e.display.currentWheelTarget=u;break e}if(n&&!fl&&!wl&&null!=Ls)return i&&a&&qr(e,Math.max(0,l.scrollTop+i*Ls)),Qr(e,Math.max(0,l.scrollLeft+n*Ls)),(!i||i&&a)&&We(t),void(o.wheelStartX=null);if(i&&null!=Ls){var h=i*Ls,d=e.doc.scrollTop,p=d+o.wrapper.clientHeight;h<0?d=Math.max(0,d+h-50):p=Math.min(e.doc.height,p+h+50),On(e,{top:d,bottom:p})}Ss<20&&(null==o.wheelStartX?(o.wheelStartX=l.scrollLeft,o.wheelStartY=l.scrollTop,o.wheelDX=n,o.wheelDY=i,setTimeout(function(){if(null!=o.wheelStartX){var e=l.scrollLeft-o.wheelStartX,t=l.scrollTop-o.wheelStartY,r=t&&o.wheelDY&&t/o.wheelDY||e&&o.wheelDX&&e/o.wheelDX;o.wheelStartX=o.wheelStartY=null,r&&(Ls=(Ls*Ss+r)/(Ss+1),++Ss)}},200)):(o.wheelDX+=n,o.wheelDY+=i))}}function zn(e,t){var r=e[t];e.sort(function(e,t){return P(e.from(),t.from())}),t=h(e,r);for(var n=1;n<e.length;n++){var i=e[n],o=e[n-1];if(P(o.to(),i.from())>=0){var l=B(o.from(),i.from()),s=R(o.to(),i.to()),a=o.empty()?i.from()==i.head:o.from()==o.head;n<=t&&--t,e.splice(--n,2,new Ts(a?s:l,a?l:s))}}return new ks(e,t)}function Rn(e,t){return new ks([new Ts(e,t||e)],0)}function Bn(e){return e.text?E(e.from.line+e.text.length-1,g(e.text).length+(1==e.text.length?e.from.ch:0)):e.to}function Gn(e,t){if(P(e,t.from)<0)return e;if(P(e,t.to)<=0)return Bn(t);var r=e.line+t.text.length-(t.to.line-t.from.line)-1,n=e.ch;return e.line==t.to.line&&(n+=Bn(t).ch-t.to.ch),E(r,n)}function Un(e,t){for(var r=[],n=0;n<e.sel.ranges.length;n++){var i=e.sel.ranges[n];r.push(new Ts(Gn(i.anchor,t),Gn(i.head,t)))}return zn(r,e.sel.primIndex)}function Vn(e,t,r){return e.line==t.line?E(r.line,e.ch-t.ch+r.ch):E(r.line+(e.line-t.line),e.ch)}function Kn(e,t,r){for(var n=[],i=E(e.first,0),o=i,l=0;l<t.length;l++){var s=t[l],a=Vn(s.from,i,o),u=Vn(Bn(s),i,o);if(i=s.to,o=u,"around"==r){var c=e.sel.ranges[l],f=P(c.head,c.anchor)<0;n[l]=new Ts(f?u:a,f?a:u)}else n[l]=new Ts(a,a)}return new ks(n,e.sel.primIndex)}function jn(e){e.doc.mode=Ue(e.options,e.doc.modeOption),Xn(e)}function Xn(e){e.doc.iter(function(e){e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null)}),e.doc.modeFrontier=e.doc.highlightFrontier=e.doc.first,Cn(e,100),e.state.modeGen++,e.curOp&&vn(e)}function Yn(e,t){return 0==t.from.ch&&0==t.to.ch&&""==g(t.text)&&(!e.cm||e.cm.options.wholeLineUpdateBefore)}function _n(e,t,r,n){function i(e){return r?r[e]:null}function o(e,r,i){it(e,r,i,n),bt(e,"change",e,t)}function l(e,t){for(var r=[],o=e;o<t;++o)r.push(new fs(u[o],i(o),n));return r}var s=t.from,a=t.to,u=t.text,c=M(e,s.line),f=M(e,a.line),h=g(u),d=i(u.length-1),p=a.line-s.line;if(t.full)e.insert(0,l(0,u.length)),e.remove(u.length,e.size-u.length);else if(Yn(e,t)){var v=l(0,u.length-1);o(f,f.text,d),p&&e.remove(s.line,p),v.length&&e.insert(s.line,v)}else if(c==f)if(1==u.length)o(c,c.text.slice(0,s.ch)+h+c.text.slice(a.ch),d);else{var m=l(1,u.length-1);m.push(new fs(h+c.text.slice(a.ch),d,n)),o(c,c.text.slice(0,s.ch)+u[0],i(0)),e.insert(s.line+1,m)}else if(1==u.length)o(c,c.text.slice(0,s.ch)+u[0]+f.text.slice(a.ch),i(0)),e.remove(s.line+1,p);else{o(c,c.text.slice(0,s.ch)+u[0],i(0)),o(f,h+f.text.slice(a.ch),d);var y=l(1,u.length-1);p>1&&e.remove(s.line+1,p-1),e.insert(s.line+1,y)}bt(e,"change",e,t)}function $n(e,t,r){function n(e,i,o){if(e.linked)for(var l=0;l<e.linked.length;++l){var s=e.linked[l];if(s.doc!=i){var a=o&&s.sharedHist;r&&!a||(t(s.doc,a),n(s.doc,e,a))}}}n(e,null,!0)}function qn(e,t){if(t.cm)throw new Error("This document is already in use.");e.doc=t,t.cm=e,Cr(e),jn(e),Zn(e),e.options.lineWrapping||we(e),e.options.mode=t.modeOption,vn(e)}function Zn(e){("rtl"==e.doc.direction?s:Fl)(e.display.lineDiv,"CodeMirror-rtl")}function Qn(e){hn(e,function(){Zn(e),vn(e)})}function Jn(e){this.done=[],this.undone=[],this.undoDepth=1/0,this.lastModTime=this.lastSelTime=0,this.lastOp=this.lastSelOp=null,this.lastOrigin=this.lastSelOrigin=null,this.generation=this.maxGeneration=e||1}function ei(e,t){var r={from:z(t.from),to:Bn(t),text:N(e,t.from,t.to)};return si(e,r,t.from.line,t.to.line+1),$n(e,function(e){return si(e,r,t.from.line,t.to.line+1)},!0),r}function ti(e){for(;e.length&&g(e).ranges;)e.pop()}function ri(e,t){return t?(ti(e.done),g(e.done)):e.done.length&&!g(e.done).ranges?g(e.done):e.done.length>1&&!e.done[e.done.length-2].ranges?(e.done.pop(),g(e.done)):void 0}function ni(e,t,r,n){var i=e.history;i.undone.length=0;var o,l,s=+new Date;if((i.lastOp==n||i.lastOrigin==t.origin&&t.origin&&("+"==t.origin.charAt(0)&&e.cm&&i.lastModTime>s-e.cm.options.historyEventDelay||"*"==t.origin.charAt(0)))&&(o=ri(i,i.lastOp==n)))l=g(o.changes),0==P(t.from,t.to)&&0==P(t.from,l.to)?l.to=Bn(t):o.changes.push(ei(e,t));else{var a=g(i.done);for(a&&a.ranges||li(e.sel,i.done),o={changes:[ei(e,t)],generation:i.generation},i.done.push(o);i.done.length>i.undoDepth;)i.done.shift(),i.done[0].ranges||i.done.shift()}i.done.push(r),i.generation=++i.maxGeneration,i.lastModTime=i.lastSelTime=s,i.lastOp=i.lastSelOp=n,i.lastOrigin=i.lastSelOrigin=t.origin,l||Te(e,"historyAdded")}function ii(e,t,r,n){var i=t.charAt(0);return"*"==i||"+"==i&&r.ranges.length==n.ranges.length&&r.somethingSelected()==n.somethingSelected()&&new Date-e.history.lastSelTime<=(e.cm?e.cm.options.historyEventDelay:500)}function oi(e,t,r,n){var i=e.history,o=n&&n.origin;r==i.lastSelOp||o&&i.lastSelOrigin==o&&(i.lastModTime==i.lastSelTime&&i.lastOrigin==o||ii(e,o,g(i.done),t))?i.done[i.done.length-1]=t:li(t,i.done),i.lastSelTime=+new Date,i.lastSelOrigin=o,i.lastSelOp=r,n&&!1!==n.clearRedo&&ti(i.undone)}function li(e,t){var r=g(t);r&&r.ranges&&r.equals(e)||t.push(e)}function si(e,t,r,n){var i=t["spans_"+e.id],o=0;e.iter(Math.max(e.first,r),Math.min(e.first+e.size,n),function(r){r.markedSpans&&((i||(i=t["spans_"+e.id]={}))[o]=r.markedSpans),++o})}function ai(e){if(!e)return null;for(var t,r=0;r<e.length;++r)e[r].marker.explicitlyCleared?t||(t=e.slice(0,r)):t&&t.push(e[r]);return t?t.length?t:null:e}function ui(e,t){var r=t["spans_"+e.id];if(!r)return null;for(var n=[],i=0;i<t.text.length;++i)n.push(ai(r[i]));return n}function ci(e,t){var r=ui(e,t),n=J(e,t);if(!r)return n;if(!n)return r;for(var i=0;i<r.length;++i){var o=r[i],l=n[i];if(o&&l)e:for(var s=0;s<l.length;++s){for(var a=l[s],u=0;u<o.length;++u)if(o[u].marker==a.marker)continue e;o.push(a)}else l&&(r[i]=l)}return r}function fi(e,t,r){for(var n=[],i=0;i<e.length;++i){var o=e[i];if(o.ranges)n.push(r?ks.prototype.deepCopy.call(o):o);else{var l=o.changes,s=[];n.push({changes:s});for(var a=0;a<l.length;++a){var u=l[a],c=void 0;if(s.push({from:u.from,to:u.to,text:u.text}),t)for(var f in u)(c=f.match(/^spans_(\d+)$/))&&h(t,Number(c[1]))>-1&&(g(s)[f]=u[f],delete u[f])}}}return n}function hi(e,t,r,n){if(n){var i=e.anchor;if(r){var o=P(t,i)<0;o!=P(r,i)<0?(i=t,t=r):o!=P(t,r)<0&&(t=r)}return new Ts(i,t)}return new Ts(r||t,t)}function di(e,t,r,n,i){null==i&&(i=e.cm&&(e.cm.display.shift||e.extend)),bi(e,new ks([hi(e.sel.primary(),t,r,i)],0),n)}function pi(e,t,r){for(var n=[],i=e.cm&&(e.cm.display.shift||e.extend),o=0;o<e.sel.ranges.length;o++)n[o]=hi(e.sel.ranges[o],t[o],null,i);bi(e,zn(n,e.sel.primIndex),r)}function gi(e,t,r,n){var i=e.sel.ranges.slice(0);i[t]=r,bi(e,zn(i,e.sel.primIndex),n)}function vi(e,t,r,n){bi(e,Rn(t,r),n)}function mi(e,t,r){var n={ranges:t.ranges,update:function(t){var r=this;this.ranges=[];for(var n=0;n<t.length;n++)r.ranges[n]=new Ts(U(e,t[n].anchor),U(e,t[n].head))},origin:r&&r.origin};return Te(e,"beforeSelectionChange",e,n),e.cm&&Te(e.cm,"beforeSelectionChange",e.cm,n),n.ranges!=t.ranges?zn(n.ranges,n.ranges.length-1):t}function yi(e,t,r){var n=e.history.done,i=g(n);i&&i.ranges?(n[n.length-1]=t,wi(e,t,r)):bi(e,t,r)}function bi(e,t,r){wi(e,t,r),oi(e,e.sel,e.cm?e.cm.curOp.id:NaN,r)}function wi(e,t,r){(Oe(e,"beforeSelectionChange")||e.cm&&Oe(e.cm,"beforeSelectionChange"))&&(t=mi(e,t,r)),xi(e,Si(e,t,r&&r.bias||(P(t.primary().head,e.sel.primary().head)<0?-1:1),!0)),r&&!1===r.scroll||!e.cm||jr(e.cm)}function xi(e,t){t.equals(e.sel)||(e.sel=t,e.cm&&(e.cm.curOp.updateInput=e.cm.curOp.selectionChanged=!0,Ne(e.cm)),bt(e,"cursorActivity",e))}function Ci(e){xi(e,Si(e,e.sel,null,!1))}function Si(e,t,r,n){for(var i,o=0;o<t.ranges.length;o++){var l=t.ranges[o],s=t.ranges.length==e.sel.ranges.length&&e.sel.ranges[o],a=ki(e,l.anchor,s&&s.anchor,r,n),u=ki(e,l.head,s&&s.head,r,n);(i||a!=l.anchor||u!=l.head)&&(i||(i=t.ranges.slice(0,o)),i[o]=new Ts(a,u))}return i?zn(i,t.primIndex):t}function Li(e,t,r,n,i){var o=M(e,t.line);if(o.markedSpans)for(var l=0;l<o.markedSpans.length;++l){var s=o.markedSpans[l],a=s.marker;if((null==s.from||(a.inclusiveLeft?s.from<=t.ch:s.from<t.ch))&&(null==s.to||(a.inclusiveRight?s.to>=t.ch:s.to>t.ch))){if(i&&(Te(a,"beforeCursorEnter"),a.explicitlyCleared)){if(o.markedSpans){--l;continue}break}if(!a.atomic)continue;if(r){var u=a.find(n<0?1:-1),c=void 0;if((n<0?a.inclusiveRight:a.inclusiveLeft)&&(u=Ti(e,u,-n,u&&u.line==t.line?o:null)),u&&u.line==t.line&&(c=P(u,r))&&(n<0?c<0:c>0))return Li(e,u,t,n,i)}var f=a.find(n<0?-1:1);return(n<0?a.inclusiveLeft:a.inclusiveRight)&&(f=Ti(e,f,n,f.line==t.line?o:null)),f?Li(e,f,t,n,i):null}}return t}function ki(e,t,r,n,i){var o=n||1,l=Li(e,t,r,o,i)||!i&&Li(e,t,r,o,!0)||Li(e,t,r,-o,i)||!i&&Li(e,t,r,-o,!0);return l||(e.cantEdit=!0,E(e.first,0))}function Ti(e,t,r,n){return r<0&&0==t.ch?t.line>e.first?U(e,E(t.line-1)):null:r>0&&t.ch==(n||M(e,t.line)).text.length?t.line<e.first+e.size-1?E(t.line+1,0):null:new E(t.line,t.ch+r)}function Mi(e){e.setSelection(E(e.firstLine(),0),E(e.lastLine()),Gl)}function Ni(e,t,r){var n={canceled:!1,from:t.from,to:t.to,text:t.text,origin:t.origin,cancel:function(){return n.canceled=!0}};return r&&(n.update=function(t,r,i,o){t&&(n.from=U(e,t)),r&&(n.to=U(e,r)),i&&(n.text=i),void 0!==o&&(n.origin=o)}),Te(e,"beforeChange",e,n),e.cm&&Te(e.cm,"beforeChange",e.cm,n),n.canceled?null:{from:n.from,to:n.to,text:n.text,origin:n.origin}}function Oi(e,t,r){if(e.cm){if(!e.cm.curOp)return dn(e.cm,Oi)(e,t,r);if(e.cm.state.suppressEdits)return}if(!(Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"))||(t=Ni(e,t,!0))){var n=Yl&&!r&&te(e,t.from,t.to);if(n)for(var i=n.length-1;i>=0;--i)Ai(e,{from:n[i].from,to:n[i].to,text:i?[""]:t.text,origin:t.origin});else Ai(e,t)}}function Ai(e,t){if(1!=t.text.length||""!=t.text[0]||0!=P(t.from,t.to)){var r=Un(e,t);ni(e,t,r,e.cm?e.cm.curOp.id:NaN),Hi(e,t,r,J(e,t));var n=[];$n(e,function(e,r){r||-1!=h(n,e.history)||(zi(e.history,t),n.push(e.history)),Hi(e,t,null,J(e,t))})}}function Wi(e,t,r){if(!e.cm||!e.cm.state.suppressEdits||r){for(var n,i=e.history,o=e.sel,l="undo"==t?i.done:i.undone,s="undo"==t?i.undone:i.done,a=0;a<l.length&&(n=l[a],r?!n.ranges||n.equals(e.sel):n.ranges);a++);if(a!=l.length){for(i.lastOrigin=i.lastSelOrigin=null;(n=l.pop()).ranges;){if(li(n,s),r&&!n.equals(e.sel))return void bi(e,n,{clearRedo:!1});o=n}var u=[];li(o,s),s.push({changes:u,generation:i.generation}),i.generation=n.generation||++i.maxGeneration;for(var c=Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"),f=n.changes.length-1;f>=0;--f){var d=function(r){var i=n.changes[r];if(i.origin=t,c&&!Ni(e,i,!1))return l.length=0,{};u.push(ei(e,i));var o=r?Un(e,i):g(l);Hi(e,i,o,ci(e,i)),!r&&e.cm&&e.cm.scrollIntoView({from:i.from,to:Bn(i)});var s=[];$n(e,function(e,t){t||-1!=h(s,e.history)||(zi(e.history,i),s.push(e.history)),Hi(e,i,null,ci(e,i))})}(f);if(d)return d.v}}}}function Di(e,t){if(0!=t&&(e.first+=t,e.sel=new ks(v(e.sel.ranges,function(e){return new Ts(E(e.anchor.line+t,e.anchor.ch),E(e.head.line+t,e.head.ch))}),e.sel.primIndex),e.cm)){vn(e.cm,e.first,e.first-t,t);for(var r=e.cm.display,n=r.viewFrom;n<r.viewTo;n++)mn(e.cm,n,"gutter")}}function Hi(e,t,r,n){if(e.cm&&!e.cm.curOp)return dn(e.cm,Hi)(e,t,r,n);if(t.to.line<e.first)Di(e,t.text.length-1-(t.to.line-t.from.line));else if(!(t.from.line>e.lastLine())){if(t.from.line<e.first){var i=t.text.length-1-(e.first-t.from.line);Di(e,i),t={from:E(e.first,0),to:E(t.to.line+i,t.to.ch),text:[g(t.text)],origin:t.origin}}var o=e.lastLine();t.to.line>o&&(t={from:t.from,to:E(o,M(e,o).text.length),text:[t.text[0]],origin:t.origin}),t.removed=N(e,t.from,t.to),r||(r=Un(e,t)),e.cm?Fi(e.cm,t,n):_n(e,t,n),wi(e,r,Gl)}}function Fi(e,t,r){var n=e.doc,i=e.display,o=t.from,l=t.to,s=!1,a=o.line;e.options.lineWrapping||(a=W(fe(M(n,o.line))),n.iter(a,l.line+1,function(e){if(e==i.maxLine)return s=!0,!0})),n.sel.contains(t.from,t.to)>-1&&Ne(e),_n(n,t,r,xr(e)),e.options.lineWrapping||(n.iter(a,o.line+t.text.length,function(e){var t=be(e);t>i.maxLineLength&&(i.maxLine=e,i.maxLineLength=t,i.maxLineChanged=!0,s=!1)}),s&&(e.curOp.updateMaxLine=!0)),nt(n,o.line),Cn(e,400);var u=t.text.length-(l.line-o.line)-1;t.full?vn(e):o.line!=l.line||1!=t.text.length||Yn(e.doc,t)?vn(e,o.line,l.line+1,u):mn(e,o.line,"text");var c=Oe(e,"changes"),f=Oe(e,"change");if(f||c){var h={from:o,to:l,text:t.text,removed:t.removed,origin:t.origin};f&&bt(e,"change",e,h),c&&(e.curOp.changeObjs||(e.curOp.changeObjs=[])).push(h)}e.display.selForContextMenu=null}function Ei(e,t,r,n,i){if(n||(n=r),P(n,r)<0){var o;r=(o=[n,r])[0],n=o[1]}"string"==typeof t&&(t=e.splitLines(t)),Oi(e,{from:r,to:n,text:t,origin:i})}function Pi(e,t,r,n){r<e.line?e.line+=n:t<e.line&&(e.line=t,e.ch=0)}function Ii(e,t,r,n){for(var i=0;i<e.length;++i){var o=e[i],l=!0;if(o.ranges){o.copied||((o=e[i]=o.deepCopy()).copied=!0);for(var s=0;s<o.ranges.length;s++)Pi(o.ranges[s].anchor,t,r,n),Pi(o.ranges[s].head,t,r,n)}else{for(var a=0;a<o.changes.length;++a){var u=o.changes[a];if(r<u.from.line)u.from=E(u.from.line+n,u.from.ch),u.to=E(u.to.line+n,u.to.ch);else if(t<=u.to.line){l=!1;break}}l||(e.splice(0,i+1),i=0)}}}function zi(e,t){var r=t.from.line,n=t.to.line,i=t.text.length-(n-r)-1;Ii(e.done,r,n,i),Ii(e.undone,r,n,i)}function Ri(e,t,r,n){var i=t,o=t;return"number"==typeof t?o=M(e,G(e,t)):i=W(t),null==i?null:(n(o,i)&&e.cm&&mn(e.cm,i,r),o)}function Bi(e){var t=this;this.lines=e,this.parent=null;for(var r=0,n=0;n<e.length;++n)e[n].parent=t,r+=e[n].height;this.height=r}function Gi(e){var t=this;this.children=e;for(var r=0,n=0,i=0;i<e.length;++i){var o=e[i];r+=o.chunkSize(),n+=o.height,o.parent=t}this.size=r,this.height=n,this.parent=null}function Ui(e,t,r){ye(t)<(e.curOp&&e.curOp.scrollTop||e.doc.scrollTop)&&Kr(e,r)}function Vi(e,t,r,n){var i=new Ms(e,r,n),o=e.cm;return o&&i.noHScroll&&(o.display.alignWidgets=!0),Ri(e,t,"widget",function(t){var r=t.widgets||(t.widgets=[]);if(null==i.insertAt?r.push(i):r.splice(Math.min(r.length-1,Math.max(0,i.insertAt)),0,i),i.line=t,o&&!ve(e,t)){var n=ye(t)<e.scrollTop;A(t,t.height+Ht(i)),n&&Kr(o,i.height),o.curOp.forceUpdate=!0}return!0}),bt(o,"lineWidgetAdded",o,i,"number"==typeof t?t:W(t)),i}function Ki(e,t,r,n,o){if(n&&n.shared)return ji(e,t,r,n,o);if(e.cm&&!e.cm.curOp)return dn(e.cm,Ki)(e,t,r,n,o);var l=new Os(e,o),s=P(t,r);if(n&&c(n,l,!1),s>0||0==s&&!1!==l.clearWhenEmpty)return l;if(l.replacedWith&&(l.collapsed=!0,l.widgetNode=i("span",[l.replacedWith],"CodeMirror-widget"),n.handleMouseEvents||l.widgetNode.setAttribute("cm-ignore-events","true"),n.insertLeft&&(l.widgetNode.insertLeft=!0)),l.collapsed){if(ce(e,t.line,t,r,l)||t.line!=r.line&&ce(e,r.line,t,r,l))throw new Error("Inserting collapsed marker partially overlapping an existing one");X()}l.addToHistory&&ni(e,{from:t,to:r,origin:"markText"},e.sel,NaN);var a,u=t.line,f=e.cm;if(e.iter(u,r.line+1,function(e){f&&l.collapsed&&!f.options.lineWrapping&&fe(e)==f.display.maxLine&&(a=!0),l.collapsed&&u!=t.line&&A(e,0),q(e,new Y(l,u==t.line?t.ch:null,u==r.line?r.ch:null)),++u}),l.collapsed&&e.iter(t.line,r.line+1,function(t){ve(e,t)&&A(t,0)}),l.clearOnEnter&&Ql(l,"beforeCursorEnter",function(){return l.clear()}),l.readOnly&&(j(),(e.history.done.length||e.history.undone.length)&&e.clearHistory()),l.collapsed&&(l.id=++Ns,l.atomic=!0),f){if(a&&(f.curOp.updateMaxLine=!0),l.collapsed)vn(f,t.line,r.line+1);else if(l.className||l.title||l.startStyle||l.endStyle||l.css)for(var h=t.line;h<=r.line;h++)mn(f,h,"text");l.atomic&&Ci(f.doc),bt(f,"markerAdded",f,l)}return l}function ji(e,t,r,n,i){(n=c(n)).shared=!1;var o=[Ki(e,t,r,n,i)],l=o[0],s=n.widgetNode;return $n(e,function(e){s&&(n.widgetNode=s.cloneNode(!0)),o.push(Ki(e,U(e,t),U(e,r),n,i));for(var a=0;a<e.linked.length;++a)if(e.linked[a].isParent)return;l=g(o)}),new As(o,l)}function Xi(e){return e.findMarks(E(e.first,0),e.clipPos(E(e.lastLine())),function(e){return e.parent})}function Yi(e,t){for(var r=0;r<t.length;r++){var n=t[r],i=n.find(),o=e.clipPos(i.from),l=e.clipPos(i.to);if(P(o,l)){var s=Ki(e,o,l,n.primary,n.primary.type);n.markers.push(s),s.parent=n}}}function _i(e){for(var t=0;t<e.length;t++)!function(t){var r=e[t],n=[r.primary.doc];$n(r.primary.doc,function(e){return n.push(e)});for(var i=0;i<r.markers.length;i++){var o=r.markers[i];-1==h(n,o.doc)&&(o.parent=null,r.markers.splice(i--,1))}}(t)}function $i(e){var t=this;if(Qi(t),!Me(t,e)&&!Ft(t.display,e)){We(e),gl&&(Hs=+new Date);var r=Sr(t,e,!0),n=e.dataTransfer.files;if(r&&!t.isReadOnly())if(n&&n.length&&window.FileReader&&window.File)for(var i=n.length,o=Array(i),l=0,s=0;s<i;++s)!function(e,n){if(!t.options.allowDropFileTypes||-1!=h(t.options.allowDropFileTypes,e.type)){var s=new FileReader;s.onload=dn(t,function(){var e=s.result;if(/[\x00-\x08\x0e-\x1f]{2}/.test(e)&&(e=""),o[n]=e,++l==i){var a={from:r=U(t.doc,r),to:r,text:t.doc.splitLines(o.join(t.doc.lineSeparator())),origin:"paste"};Oi(t.doc,a),yi(t.doc,Rn(r,Bn(a)))}}),s.readAsText(e)}}(n[s],s);else{if(t.state.draggingText&&t.doc.sel.contains(r)>-1)return t.state.draggingText(e),void setTimeout(function(){return t.display.input.focus()},20);try{var a=e.dataTransfer.getData("Text");if(a){var u;if(t.state.draggingText&&!t.state.draggingText.copy&&(u=t.listSelections()),wi(t.doc,Rn(r,r)),u)for(var c=0;c<u.length;++c)Ei(t.doc,"",u[c].anchor,u[c].head,"drag");t.replaceSelection(a,"around","paste"),t.display.input.focus()}}catch(e){}}}}function qi(e,t){if(gl&&(!e.state.draggingText||+new Date-Hs<100))Fe(t);else if(!Me(e,t)&&!Ft(e.display,t)&&(t.dataTransfer.setData("Text",e.getSelection()),t.dataTransfer.effectAllowed="copyMove",t.dataTransfer.setDragImage&&!xl)){var r=n("img",null,null,"position: fixed; left: 0; top: 0;");r.src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",wl&&(r.width=r.height=1,e.display.wrapper.appendChild(r),r._top=r.offsetTop),t.dataTransfer.setDragImage(r,0,0),wl&&r.parentNode.removeChild(r)}}function Zi(e,t){var i=Sr(e,t);if(i){var o=document.createDocumentFragment();Mr(e,i,o),e.display.dragCursor||(e.display.dragCursor=n("div",null,"CodeMirror-cursors CodeMirror-dragcursors"),e.display.lineSpace.insertBefore(e.display.dragCursor,e.display.cursorDiv)),r(e.display.dragCursor,o)}}function Qi(e){e.display.dragCursor&&(e.display.lineSpace.removeChild(e.display.dragCursor),e.display.dragCursor=null)}function Ji(e){if(document.getElementsByClassName)for(var t=document.getElementsByClassName("CodeMirror"),r=0;r<t.length;r++){var n=t[r].CodeMirror;n&&e(n)}}function eo(){Fs||(to(),Fs=!0)}function to(){var e;Ql(window,"resize",function(){null==e&&(e=setTimeout(function(){e=null,Ji(ro)},100))}),Ql(window,"blur",function(){return Ji(Fr)})}function ro(e){var t=e.display;t.lastWrapHeight==t.wrapper.clientHeight&&t.lastWrapWidth==t.wrapper.clientWidth||(t.cachedCharWidth=t.cachedTextHeight=t.cachedPaddingH=null,t.scrollbarsClipped=!1,e.setSize())}function no(e){var t=e.split(/-(?!$)/);e=t[t.length-1];for(var r,n,i,o,l=0;l<t.length-1;l++){var s=t[l];if(/^(cmd|meta|m)$/i.test(s))o=!0;else if(/^a(lt)?$/i.test(s))r=!0;else if(/^(c|ctrl|control)$/i.test(s))n=!0;else{if(!/^s(hift)?$/i.test(s))throw new Error("Unrecognized modifier name: "+s);i=!0}}return r&&(e="Alt-"+e),n&&(e="Ctrl-"+e),o&&(e="Cmd-"+e),i&&(e="Shift-"+e),e}function io(e){var t={};for(var r in e)if(e.hasOwnProperty(r)){var n=e[r];if(/^(name|fallthrough|(de|at)tach)$/.test(r))continue;if("..."==n){delete e[r];continue}for(var i=v(r.split(" "),no),o=0;o<i.length;o++){var l=void 0,s=void 0;o==i.length-1?(s=i.join(" "),l=n):(s=i.slice(0,o+1).join(" "),l="...");var a=t[s];if(a){if(a!=l)throw new Error("Inconsistent bindings for "+s)}else t[s]=l}delete e[r]}for(var u in t)e[u]=t[u];return e}function oo(e,t,r,n){var i=(t=uo(t)).call?t.call(e,n):t[e];if(!1===i)return"nothing";if("..."===i)return"multi";if(null!=i&&r(i))return"handled";if(t.fallthrough){if("[object Array]"!=Object.prototype.toString.call(t.fallthrough))return oo(e,t.fallthrough,r,n);for(var o=0;o<t.fallthrough.length;o++){var l=oo(e,t.fallthrough[o],r,n);if(l)return l}}}function lo(e){var t="string"==typeof e?e:Es[e.keyCode];return"Ctrl"==t||"Alt"==t||"Shift"==t||"Mod"==t}function so(e,t,r){var n=e;return t.altKey&&"Alt"!=n&&(e="Alt-"+e),(Dl?t.metaKey:t.ctrlKey)&&"Ctrl"!=n&&(e="Ctrl-"+e),(Dl?t.ctrlKey:t.metaKey)&&"Cmd"!=n&&(e="Cmd-"+e),!r&&t.shiftKey&&"Shift"!=n&&(e="Shift-"+e),e}function ao(e,t){if(wl&&34==e.keyCode&&e.char)return!1;var r=Es[e.keyCode];return null!=r&&!e.altGraphKey&&so(r,e,t)}function uo(e){return"string"==typeof e?Rs[e]:e}function co(e,t){for(var r=e.doc.sel.ranges,n=[],i=0;i<r.length;i++){for(var o=t(r[i]);n.length&&P(o.from,g(n).to)<=0;){var l=n.pop();if(P(l.from,o.from)<0){o.from=l.from;break}}n.push(o)}hn(e,function(){for(var t=n.length-1;t>=0;t--)Ei(e.doc,"",n[t].from,n[t].to,"+delete");jr(e)})}function fo(e,t,r){var n=L(e.text,t+r,r);return n<0||n>e.text.length?null:n}function ho(e,t,r){var n=fo(e,t.ch,r);return null==n?null:new E(t.line,n,r<0?"after":"before")}function po(e,t,r,n,i){if(e){var o=Se(r,t.doc.direction);if(o){var l,s=i<0?g(o):o[0],a=i<0==(1==s.level)?"after":"before";if(s.level>0){var u=Xt(t,r);l=i<0?r.text.length-1:0;var c=Yt(t,u,l).top;l=k(function(e){return Yt(t,u,e).top==c},i<0==(1==s.level)?s.from:s.to-1,l),"before"==a&&(l=fo(r,l,1))}else l=i<0?s.to:s.from;return new E(n,l,a)}}return new E(n,i<0?r.text.length:0,i<0?"before":"after")}function go(e,t,r,n){var i=Se(t,e.doc.direction);if(!i)return ho(t,r,n);r.ch>=t.text.length?(r.ch=t.text.length,r.sticky="before"):r.ch<=0&&(r.ch=0,r.sticky="after");var o=Ce(i,r.ch,r.sticky),l=i[o];if("ltr"==e.doc.direction&&l.level%2==0&&(n>0?l.to>r.ch:l.from<r.ch))return ho(t,r,n);var s,a=function(e,r){return fo(t,e instanceof E?e.ch:e,r)},u=function(r){return e.options.lineWrapping?(s=s||Xt(e,t),hr(e,t,s,r)):{begin:0,end:t.text.length}},c=u("before"==r.sticky?a(r,-1):r.ch);if("rtl"==e.doc.direction||1==l.level){var f=1==l.level==n<0,h=a(r,f?1:-1);if(null!=h&&(f?h<=l.to&&h<=c.end:h>=l.from&&h>=c.begin)){var d=f?"before":"after";return new E(r.line,h,d)}}var p=function(e,t,n){for(var o=function(e,t){return t?new E(r.line,a(e,1),"before"):new E(r.line,e,"after")};e>=0&&e<i.length;e+=t){var l=i[e],s=t>0==(1!=l.level),u=s?n.begin:a(n.end,-1);if(l.from<=u&&u<l.to)return o(u,s);if(u=s?l.from:a(l.to,-1),n.begin<=u&&u<n.end)return o(u,s)}},g=p(o+n,n,c);if(g)return g;var v=n>0?c.end:a(c.begin,-1);return null==v||n>0&&v==t.text.length||!(g=p(n>0?0:i.length-1,n,u(v)))?null:g}function vo(e,t){var r=M(e.doc,t),n=fe(r);return n!=r&&(t=W(n)),po(!0,e,n,t,1)}function mo(e,t){var r=M(e.doc,t),n=he(r);return n!=r&&(t=W(n)),po(!0,e,r,t,-1)}function yo(e,t){var r=vo(e,t.line),n=M(e.doc,r.line),i=Se(n,e.doc.direction);if(!i||0==i[0].level){var o=Math.max(0,n.text.search(/\S/)),l=t.line==r.line&&t.ch<=o&&t.ch;return E(r.line,l?0:o,r.sticky)}return r}function bo(e,t,r){if("string"==typeof t&&!(t=Bs[t]))return!1;e.display.input.ensurePolled();var n=e.display.shift,i=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),r&&(e.display.shift=!1),i=t(e)!=Bl}finally{e.display.shift=n,e.state.suppressEdits=!1}return i}function wo(e,t,r){for(var n=0;n<e.state.keyMaps.length;n++){var i=oo(t,e.state.keyMaps[n],r,e);if(i)return i}return e.options.extraKeys&&oo(t,e.options.extraKeys,r,e)||oo(t,e.options.keyMap,r,e)}function xo(e,t,r,n){var i=e.state.keySeq;if(i){if(lo(t))return"handled";Gs.set(50,function(){e.state.keySeq==i&&(e.state.keySeq=null,e.display.input.reset())}),t=i+" "+t}var o=wo(e,t,n);return"multi"==o&&(e.state.keySeq=t),"handled"==o&&bt(e,"keyHandled",e,t,r),"handled"!=o&&"multi"!=o||(We(r),Ar(e)),i&&!o&&/\'$/.test(t)?(We(r),!0):!!o}function Co(e,t){var r=ao(t,!0);return!!r&&(t.shiftKey&&!e.state.keySeq?xo(e,"Shift-"+r,t,function(t){return bo(e,t,!0)})||xo(e,r,t,function(t){if("string"==typeof t?/^go[A-Z]/.test(t):t.motion)return bo(e,t)}):xo(e,r,t,function(t){return bo(e,t)}))}function So(e,t,r){return xo(e,"'"+r+"'",t,function(t){return bo(e,t,!0)})}function Lo(e){var t=this;if(t.curOp.focus=l(),!Me(t,e)){gl&&vl<11&&27==e.keyCode&&(e.returnValue=!1);var r=e.keyCode;t.display.shift=16==r||e.shiftKey;var n=Co(t,e);wl&&(Us=n?r:null,!n&&88==r&&!rs&&(Ml?e.metaKey:e.ctrlKey)&&t.replaceSelection("",null,"cut")),18!=r||/\bCodeMirror-crosshair\b/.test(t.display.lineDiv.className)||ko(t)}}function ko(e){function t(e){18!=e.keyCode&&e.altKey||(Fl(r,"CodeMirror-crosshair"),ke(document,"keyup",t),ke(document,"mouseover",t))}var r=e.display.lineDiv;s(r,"CodeMirror-crosshair"),Ql(document,"keyup",t),Ql(document,"mouseover",t)}function To(e){16==e.keyCode&&(this.doc.sel.shift=!1),Me(this,e)}function Mo(e){var t=this;if(!(Ft(t.display,e)||Me(t,e)||e.ctrlKey&&!e.altKey||Ml&&e.metaKey)){var r=e.keyCode,n=e.charCode;if(wl&&r==Us)return Us=null,void We(e);if(!wl||e.which&&!(e.which<10)||!Co(t,e)){var i=String.fromCharCode(null==n?r:n);"\b"!=i&&(So(t,e,i)||t.display.input.onKeyPress(e))}}}function No(e,t){var r=+new Date;return js&&js.compare(r,e,t)?(Ks=js=null,"triple"):Ks&&Ks.compare(r,e,t)?(js=new Vs(r,e,t),Ks=null,"double"):(Ks=new Vs(r,e,t),js=null,"single")}function Oo(e){var t=this,r=t.display;if(!(Me(t,e)||r.activeTouch&&r.input.supportsTouch()))if(r.input.ensurePolled(),r.shift=e.shiftKey,Ft(r,e))ml||(r.scroller.draggable=!1,setTimeout(function(){return r.scroller.draggable=!0},100));else if(!zo(t,e)){var n=Sr(t,e),i=Pe(e),o=n?No(n,i):"single";window.focus(),1==i&&t.state.selectingText&&t.state.selectingText(e),n&&Ao(t,i,n,o,e)||(1==i?n?Do(t,n,o,e):Ee(e)==r.scroller&&We(e):2==i?(n&&di(t.doc,n),setTimeout(function(){return r.input.focus()},20)):3==i&&(Hl?Ro(t,e):Dr(t)))}}function Ao(e,t,r,n,i){var o="Click";return"double"==n?o="Double"+o:"triple"==n&&(o="Triple"+o),o=(1==t?"Left":2==t?"Middle":"Right")+o,xo(e,so(o,i),i,function(t){if("string"==typeof t&&(t=Bs[t]),!t)return!1;var n=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),n=t(e,r)!=Bl}finally{e.state.suppressEdits=!1}return n})}function Wo(e,t,r){var n=e.getOption("configureMouse"),i=n?n(e,t,r):{};if(null==i.unit){var o=Nl?r.shiftKey&&r.metaKey:r.altKey;i.unit=o?"rectangle":"single"==t?"char":"double"==t?"word":"line"}return(null==i.extend||e.doc.extend)&&(i.extend=e.doc.extend||r.shiftKey),null==i.addNew&&(i.addNew=Ml?r.metaKey:r.ctrlKey),null==i.moveOnDrag&&(i.moveOnDrag=!(Ml?r.altKey:r.ctrlKey)),i}function Do(e,t,r,n){gl?setTimeout(u(Wr,e),0):e.curOp.focus=l();var i,o=Wo(e,r,n),s=e.doc.sel;e.options.dragDrop&&Jl&&!e.isReadOnly()&&"single"==r&&(i=s.contains(t))>-1&&(P((i=s.ranges[i]).from(),t)<0||t.xRel>0)&&(P(i.to(),t)>0||t.xRel<0)?Ho(e,n,t,o):Eo(e,n,t,o)}function Ho(e,t,r,n){var i=e.display,o=!1,l=dn(e,function(t){ml&&(i.scroller.draggable=!1),e.state.draggingText=!1,ke(document,"mouseup",l),ke(document,"mousemove",s),ke(i.scroller,"dragstart",a),ke(i.scroller,"drop",l),o||(We(t),n.addNew||di(e.doc,r,null,null,n.extend),ml||gl&&9==vl?setTimeout(function(){document.body.focus(),i.input.focus()},20):i.input.focus())}),s=function(e){o=o||Math.abs(t.clientX-e.clientX)+Math.abs(t.clientY-e.clientY)>=10},a=function(){return o=!0};ml&&(i.scroller.draggable=!0),e.state.draggingText=l,l.copy=!n.moveOnDrag,i.scroller.dragDrop&&i.scroller.dragDrop(),Ql(document,"mouseup",l),Ql(document,"mousemove",s),Ql(i.scroller,"dragstart",a),Ql(i.scroller,"drop",l),Dr(e),setTimeout(function(){return i.input.focus()},20)}function Fo(e,t,r){if("char"==r)return new Ts(t,t);if("word"==r)return e.findWordAt(t);if("line"==r)return new Ts(E(t.line,0),U(e.doc,E(t.line+1,0)));var n=r(e,t);return new Ts(n.from,n.to)}function Eo(e,t,r,n){function i(t){if(0!=P(m,t))if(m=t,"rectangle"==n.unit){for(var i=[],o=e.options.tabSize,l=f(M(u,r.line).text,r.ch,o),s=f(M(u,t.line).text,t.ch,o),a=Math.min(l,s),g=Math.max(l,s),v=Math.min(r.line,t.line),y=Math.min(e.lastLine(),Math.max(r.line,t.line));v<=y;v++){var b=M(u,v).text,w=d(b,a,o);a==g?i.push(new Ts(E(v,w),E(v,w))):b.length>w&&i.push(new Ts(E(v,w),E(v,d(b,g,o))))}i.length||i.push(new Ts(r,r)),bi(u,zn(p.ranges.slice(0,h).concat(i),h),{origin:"*mouse",scroll:!1}),e.scrollIntoView(t)}else{var x,C=c,S=Fo(e,t,n.unit),L=C.anchor;P(S.anchor,L)>0?(x=S.head,L=B(C.from(),S.anchor)):(x=S.anchor,L=R(C.to(),S.head));var k=p.ranges.slice(0);k[h]=Po(e,new Ts(U(u,L),x)),bi(u,zn(k,h),Ul)}}function o(t){var r=++b,s=Sr(e,t,!0,"rectangle"==n.unit);if(s)if(0!=P(s,m)){e.curOp.focus=l(),i(s);var c=Ir(a,u);(s.line>=c.to||s.line<c.from)&&setTimeout(dn(e,function(){b==r&&o(t)}),150)}else{var f=t.clientY<y.top?-20:t.clientY>y.bottom?20:0;f&&setTimeout(dn(e,function(){b==r&&(a.scroller.scrollTop+=f,o(t))}),50)}}function s(t){e.state.selectingText=!1,b=1/0,We(t),a.input.focus(),ke(document,"mousemove",w),ke(document,"mouseup",x),u.history.lastSelOrigin=null}var a=e.display,u=e.doc;We(t);var c,h,p=u.sel,g=p.ranges;if(n.addNew&&!n.extend?(h=u.sel.contains(r),c=h>-1?g[h]:new Ts(r,r)):(c=u.sel.primary(),h=u.sel.primIndex),"rectangle"==n.unit)n.addNew||(c=new Ts(r,r)),r=Sr(e,t,!0,!0),h=-1;else{var v=Fo(e,r,n.unit);c=n.extend?hi(c,v.anchor,v.head,n.extend):v}n.addNew?-1==h?(h=g.length,bi(u,zn(g.concat([c]),h),{scroll:!1,origin:"*mouse"})):g.length>1&&g[h].empty()&&"char"==n.unit&&!n.extend?(bi(u,zn(g.slice(0,h).concat(g.slice(h+1)),0),{scroll:!1,origin:"*mouse"}),p=u.sel):gi(u,h,c,Ul):(h=0,bi(u,new ks([c],0),Ul),p=u.sel);var m=r,y=a.wrapper.getBoundingClientRect(),b=0,w=dn(e,function(e){Pe(e)?o(e):s(e)}),x=dn(e,s);e.state.selectingText=x,Ql(document,"mousemove",w),Ql(document,"mouseup",x)}function Po(e,t){var r=t.anchor,n=t.head,i=M(e.doc,r.line);if(0==P(r,n)&&r.sticky==n.sticky)return t;var o=Se(i);if(!o)return t;var l=Ce(o,r.ch,r.sticky),s=o[l];if(s.from!=r.ch&&s.to!=r.ch)return t;var a=l+(s.from==r.ch==(1!=s.level)?0:1);if(0==a||a==o.length)return t;var u;if(n.line!=r.line)u=(n.line-r.line)*("ltr"==e.doc.direction?1:-1)>0;else{var c=Ce(o,n.ch,n.sticky),f=c-l||(n.ch-r.ch)*(1==s.level?-1:1);u=c==a-1||c==a?f<0:f>0}var h=o[a+(u?-1:0)],d=u==(1==h.level),p=d?h.from:h.to,g=d?"after":"before";return r.ch==p&&r.sticky==g?t:new Ts(new E(r.line,p,g),n)}function Io(e,t,r,n){var i,o;if(t.touches)i=t.touches[0].clientX,o=t.touches[0].clientY;else try{i=t.clientX,o=t.clientY}catch(t){return!1}if(i>=Math.floor(e.display.gutters.getBoundingClientRect().right))return!1;n&&We(t);var l=e.display,s=l.lineDiv.getBoundingClientRect();if(o>s.bottom||!Oe(e,r))return He(t);o-=s.top-l.viewOffset;for(var a=0;a<e.options.gutters.length;++a){var u=l.gutters.childNodes[a];if(u&&u.getBoundingClientRect().right>=i)return Te(e,r,e,D(e.doc,o),e.options.gutters[a],t),He(t)}}function zo(e,t){return Io(e,t,"gutterClick",!0)}function Ro(e,t){Ft(e.display,t)||Bo(e,t)||Me(e,t,"contextmenu")||e.display.input.onContextMenu(t)}function Bo(e,t){return!!Oe(e,"gutterContextMenu")&&Io(e,t,"gutterContextMenu",!1)}function Go(e){e.display.wrapper.className=e.display.wrapper.className.replace(/\s*cm-s-\S+/g,"")+e.options.theme.replace(/(^|\s)\s*/g," cm-s-"),er(e)}function Uo(e){Hn(e),vn(e),zr(e)}function Vo(e,t,r){if(!t!=!(r&&r!=Xs)){var n=e.display.dragFunctions,i=t?Ql:ke;i(e.display.scroller,"dragstart",n.start),i(e.display.scroller,"dragenter",n.enter),i(e.display.scroller,"dragover",n.over),i(e.display.scroller,"dragleave",n.leave),i(e.display.scroller,"drop",n.drop)}}function Ko(e){e.options.lineWrapping?(s(e.display.wrapper,"CodeMirror-wrap"),e.display.sizer.style.minWidth="",e.display.sizerWidth=null):(Fl(e.display.wrapper,"CodeMirror-wrap"),we(e)),Cr(e),vn(e),er(e),setTimeout(function(){return en(e)},100)}function jo(e,t){var r=this;if(!(this instanceof jo))return new jo(e,t);this.options=t=t?c(t):{},c(Ys,t,!1),Fn(t);var n=t.value;"string"==typeof n&&(n=new Ds(n,t.mode,null,t.lineSeparator,t.direction)),this.doc=n;var i=new jo.inputStyles[t.inputStyle](this),o=this.display=new T(e,n,i);o.wrapper.CodeMirror=this,Hn(this),Go(this),t.lineWrapping&&(this.display.wrapper.className+=" CodeMirror-wrap"),rn(this),this.state={keyMaps:[],overlays:[],modeGen:0,overwrite:!1,delayingBlurEvent:!1,focused:!1,suppressEdits:!1,pasteIncoming:!1,cutIncoming:!1,selectingText:!1,draggingText:!1,highlight:new Pl,keySeq:null,specialChars:null},t.autofocus&&!Tl&&o.input.focus(),gl&&vl<11&&setTimeout(function(){return r.display.input.reset(!0)},20),Xo(this),eo(),nn(this),this.curOp.forceUpdate=!0,qn(this,n),t.autofocus&&!Tl||this.hasFocus()?setTimeout(u(Hr,this),20):Fr(this);for(var l in _s)_s.hasOwnProperty(l)&&_s[l](r,t[l],Xs);Rr(this),t.finishInit&&t.finishInit(this);for(var s=0;s<$s.length;++s)$s[s](r);on(this),ml&&t.lineWrapping&&"optimizelegibility"==getComputedStyle(o.lineDiv).textRendering&&(o.lineDiv.style.textRendering="auto")}function Xo(e){function t(){i.activeTouch&&(o=setTimeout(function(){return i.activeTouch=null},1e3),(l=i.activeTouch).end=+new Date)}function r(e){if(1!=e.touches.length)return!1;var t=e.touches[0];return t.radiusX<=1&&t.radiusY<=1}function n(e,t){if(null==t.left)return!0;var r=t.left-e.left,n=t.top-e.top;return r*r+n*n>400}var i=e.display;Ql(i.scroller,"mousedown",dn(e,Oo)),gl&&vl<11?Ql(i.scroller,"dblclick",dn(e,function(t){if(!Me(e,t)){var r=Sr(e,t);if(r&&!zo(e,t)&&!Ft(e.display,t)){We(t);var n=e.findWordAt(r);di(e.doc,n.anchor,n.head)}}})):Ql(i.scroller,"dblclick",function(t){return Me(e,t)||We(t)}),Hl||Ql(i.scroller,"contextmenu",function(t){return Ro(e,t)});var o,l={end:0};Ql(i.scroller,"touchstart",function(t){if(!Me(e,t)&&!r(t)&&!zo(e,t)){i.input.ensurePolled(),clearTimeout(o);var n=+new Date;i.activeTouch={start:n,moved:!1,prev:n-l.end<=300?l:null},1==t.touches.length&&(i.activeTouch.left=t.touches[0].pageX,i.activeTouch.top=t.touches[0].pageY)}}),Ql(i.scroller,"touchmove",function(){i.activeTouch&&(i.activeTouch.moved=!0)}),Ql(i.scroller,"touchend",function(r){var o=i.activeTouch;if(o&&!Ft(i,r)&&null!=o.left&&!o.moved&&new Date-o.start<300){var l,s=e.coordsChar(i.activeTouch,"page");l=!o.prev||n(o,o.prev)?new Ts(s,s):!o.prev.prev||n(o,o.prev.prev)?e.findWordAt(s):new Ts(E(s.line,0),U(e.doc,E(s.line+1,0))),e.setSelection(l.anchor,l.head),e.focus(),We(r)}t()}),Ql(i.scroller,"touchcancel",t),Ql(i.scroller,"scroll",function(){i.scroller.clientHeight&&(qr(e,i.scroller.scrollTop),Qr(e,i.scroller.scrollLeft,!0),Te(e,"scroll",e))}),Ql(i.scroller,"mousewheel",function(t){return In(e,t)}),Ql(i.scroller,"DOMMouseScroll",function(t){return In(e,t)}),Ql(i.wrapper,"scroll",function(){return i.wrapper.scrollTop=i.wrapper.scrollLeft=0}),i.dragFunctions={enter:function(t){Me(e,t)||Fe(t)},over:function(t){Me(e,t)||(Zi(e,t),Fe(t))},start:function(t){return qi(e,t)},drop:dn(e,$i),leave:function(t){Me(e,t)||Qi(e)}};var s=i.input.getField();Ql(s,"keyup",function(t){return To.call(e,t)}),Ql(s,"keydown",dn(e,Lo)),Ql(s,"keypress",dn(e,Mo)),Ql(s,"focus",function(t){return Hr(e,t)}),Ql(s,"blur",function(t){return Fr(e,t)})}function Yo(e,t,r,n){var i,o=e.doc;null==r&&(r="add"),"smart"==r&&(o.mode.indent?i=$e(e,t).state:r="prev");var l=e.options.tabSize,s=M(o,t),a=f(s.text,null,l);s.stateAfter&&(s.stateAfter=null);var u,c=s.text.match(/^\s*/)[0];if(n||/\S/.test(s.text)){if("smart"==r&&((u=o.mode.indent(i,s.text.slice(c.length),s.text))==Bl||u>150)){if(!n)return;r="prev"}}else u=0,r="not";"prev"==r?u=t>o.first?f(M(o,t-1).text,null,l):0:"add"==r?u=a+e.options.indentUnit:"subtract"==r?u=a-e.options.indentUnit:"number"==typeof r&&(u=a+r),u=Math.max(0,u);var h="",d=0;if(e.options.indentWithTabs)for(var g=Math.floor(u/l);g;--g)d+=l,h+="\t";if(d<u&&(h+=p(u-d)),h!=c)return Ei(o,h,E(t,0),E(t,c.length),"+input"),s.stateAfter=null,!0;for(var v=0;v<o.sel.ranges.length;v++){var m=o.sel.ranges[v];if(m.head.line==t&&m.head.ch<c.length){var y=E(t,c.length);gi(o,v,new Ts(y,y));break}}}function _o(e){qs=e}function $o(e,t,r,n,i){var o=e.doc;e.display.shift=!1,n||(n=o.sel);var l=e.state.pasteIncoming||"paste"==i,s=es(t),a=null;if(l&&n.ranges.length>1)if(qs&&qs.text.join("\n")==t){if(n.ranges.length%qs.text.length==0){a=[];for(var u=0;u<qs.text.length;u++)a.push(o.splitLines(qs.text[u]))}}else s.length==n.ranges.length&&e.options.pasteLinesPerSelection&&(a=v(s,function(e){return[e]}));for(var c,f=n.ranges.length-1;f>=0;f--){var h=n.ranges[f],d=h.from(),p=h.to();h.empty()&&(r&&r>0?d=E(d.line,d.ch-r):e.state.overwrite&&!l?p=E(p.line,Math.min(M(o,p.line).text.length,p.ch+g(s).length)):qs&&qs.lineWise&&qs.text.join("\n")==t&&(d=p=E(d.line,0))),c=e.curOp.updateInput;var m={from:d,to:p,text:a?a[f%a.length]:s,origin:i||(l?"paste":e.state.cutIncoming?"cut":"+input")};Oi(e.doc,m),bt(e,"inputRead",e,m)}t&&!l&&Zo(e,t),jr(e),e.curOp.updateInput=c,e.curOp.typing=!0,e.state.pasteIncoming=e.state.cutIncoming=!1}function qo(e,t){var r=e.clipboardData&&e.clipboardData.getData("Text");if(r)return e.preventDefault(),t.isReadOnly()||t.options.disableInput||hn(t,function(){return $o(t,r,0,null,"paste")}),!0}function Zo(e,t){if(e.options.electricChars&&e.options.smartIndent)for(var r=e.doc.sel,n=r.ranges.length-1;n>=0;n--){var i=r.ranges[n];if(!(i.head.ch>100||n&&r.ranges[n-1].head.line==i.head.line)){var o=e.getModeAt(i.head),l=!1;if(o.electricChars){for(var s=0;s<o.electricChars.length;s++)if(t.indexOf(o.electricChars.charAt(s))>-1){l=Yo(e,i.head.line,"smart");break}}else o.electricInput&&o.electricInput.test(M(e.doc,i.head.line).text.slice(0,i.head.ch))&&(l=Yo(e,i.head.line,"smart"));l&&bt(e,"electricInput",e,i.head.line)}}}function Qo(e){for(var t=[],r=[],n=0;n<e.doc.sel.ranges.length;n++){var i=e.doc.sel.ranges[n].head.line,o={anchor:E(i,0),head:E(i+1,0)};r.push(o),t.push(e.getRange(o.anchor,o.head))}return{text:t,ranges:r}}function Jo(e,t){e.setAttribute("autocorrect","off"),e.setAttribute("autocapitalize","off"),e.setAttribute("spellcheck",!!t)}function el(){var e=n("textarea",null,null,"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none"),t=n("div",[e],null,"overflow: hidden; position: relative; width: 3px; height: 0px;");return ml?e.style.width="1000px":e.setAttribute("wrap","off"),Ll&&(e.style.border="1px solid black"),Jo(e),t}function tl(e,t,r,n,i){function o(){var n=t.line+r;return!(n<e.first||n>=e.first+e.size)&&(t=new E(n,t.ch,t.sticky),u=M(e,n))}function l(n){var l;if(null==(l=i?go(e.cm,u,t,r):ho(u,t,r))){if(n||!o())return!1;t=po(i,e.cm,u,t.line,r)}else t=l;return!0}var s=t,a=r,u=M(e,t.line);if("char"==n)l();else if("column"==n)l(!0);else if("word"==n||"group"==n)for(var c=null,f="group"==n,h=e.cm&&e.cm.getHelper(t,"wordChars"),d=!0;!(r<0)||l(!d);d=!1){var p=u.text.charAt(t.ch)||"\n",g=x(p,h)?"w":f&&"\n"==p?"n":!f||/\s/.test(p)?null:"p";if(!f||d||g||(g="s"),c&&c!=g){r<0&&(r=1,l(),t.sticky="after");break}if(g&&(c=g),r>0&&!l(!d))break}var v=ki(e,t,s,a,!0);return I(s,v)&&(v.hitSide=!0),v}function rl(e,t,r,n){var i,o=e.doc,l=t.left;if("page"==n){var s=Math.min(e.display.wrapper.clientHeight,window.innerHeight||document.documentElement.clientHeight),a=Math.max(s-.5*mr(e.display),3);i=(r>0?t.bottom:t.top)+r*a}else"line"==n&&(i=r>0?t.bottom+3:t.top-3);for(var u;(u=cr(e,l,i)).outside;){if(r<0?i<=0:i>=o.height){u.hitSide=!0;break}i+=5*r}return u}function nl(e,t){var r=jt(e,t.line);if(!r||r.hidden)return null;var n=M(e.doc,t.line),i=Ut(r,n,t.line),o=Se(n,e.doc.direction),l="left";o&&(l=Ce(o,t.ch)%2?"right":"left");var s=_t(i.map,t.ch,l);return s.offset="right"==s.collapse?s.end:s.start,s}function il(e){for(var t=e;t;t=t.parentNode)if(/CodeMirror-gutter-wrapper/.test(t.className))return!0;return!1}function ol(e,t){return t&&(e.bad=!0),e}function ll(e,t,r,n,i){function o(e){return function(t){return t.id==e}}function l(){c&&(u+=f,c=!1)}function s(e){e&&(l(),u+=e)}function a(t){if(1==t.nodeType){var r=t.getAttribute("cm-text");if(null!=r)return void s(r||t.textContent.replace(/\u200b/g,""));var u,h=t.getAttribute("cm-marker");if(h){var d=e.findMarks(E(n,0),E(i+1,0),o(+h));return void(d.length&&(u=d[0].find(0))&&s(N(e.doc,u.from,u.to).join(f)))}if("false"==t.getAttribute("contenteditable"))return;var p=/^(pre|div|p)$/i.test(t.nodeName);p&&l();for(var g=0;g<t.childNodes.length;g++)a(t.childNodes[g]);p&&(c=!0)}else 3==t.nodeType&&s(t.nodeValue)}for(var u="",c=!1,f=e.doc.lineSeparator();a(t),t!=r;)t=t.nextSibling;return u}function sl(e,t,r){var n;if(t==e.display.lineDiv){if(!(n=e.display.lineDiv.childNodes[r]))return ol(e.clipPos(E(e.display.viewTo-1)),!0);t=null,r=0}else for(n=t;;n=n.parentNode){if(!n||n==e.display.lineDiv)return null;if(n.parentNode&&n.parentNode==e.display.lineDiv)break}for(var i=0;i<e.display.view.length;i++){var o=e.display.view[i];if(o.node==n)return al(o,t,r)}}function al(e,t,r){function n(t,r,n){for(var i=-1;i<(f?f.length:0);i++)for(var o=i<0?c.map:f[i],l=0;l<o.length;l+=3){var s=o[l+2];if(s==t||s==r){var a=W(i<0?e.line:e.rest[i]),u=o[l]+n;return(n<0||s!=t)&&(u=o[l+(n?1:0)]),E(a,u)}}}var i=e.text.firstChild,l=!1;if(!t||!o(i,t))return ol(E(W(e.line),0),!0);if(t==i&&(l=!0,t=i.childNodes[r],r=0,!t)){var s=e.rest?g(e.rest):e.line;return ol(E(W(s),s.text.length),l)}var a=3==t.nodeType?t:null,u=t;for(a||1!=t.childNodes.length||3!=t.firstChild.nodeType||(a=t.firstChild,r&&(r=a.nodeValue.length));u.parentNode!=i;)u=u.parentNode;var c=e.measure,f=c.maps,h=n(a,u,r);if(h)return ol(h,l);for(var d=u.nextSibling,p=a?a.nodeValue.length-r:0;d;d=d.nextSibling){if(h=n(d,d.firstChild,0))return ol(E(h.line,h.ch-p),l);p+=d.textContent.length}for(var v=u.previousSibling,m=r;v;v=v.previousSibling){if(h=n(v,v.firstChild,-1))return ol(E(h.line,h.ch+m),l);m+=v.textContent.length}}var ul=navigator.userAgent,cl=navigator.platform,fl=/gecko\/\d/i.test(ul),hl=/MSIE \d/.test(ul),dl=/Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(ul),pl=/Edge\/(\d+)/.exec(ul),gl=hl||dl||pl,vl=gl&&(hl?document.documentMode||6:+(pl||dl)[1]),ml=!pl&&/WebKit\//.test(ul),yl=ml&&/Qt\/\d+\.\d+/.test(ul),bl=!pl&&/Chrome\//.test(ul),wl=/Opera\//.test(ul),xl=/Apple Computer/.test(navigator.vendor),Cl=/Mac OS X 1\d\D([8-9]|\d\d)\D/.test(ul),Sl=/PhantomJS/.test(ul),Ll=!pl&&/AppleWebKit/.test(ul)&&/Mobile\/\w+/.test(ul),kl=/Android/.test(ul),Tl=Ll||kl||/webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(ul),Ml=Ll||/Mac/.test(cl),Nl=/\bCrOS\b/.test(ul),Ol=/win/i.test(cl),Al=wl&&ul.match(/Version\/(\d*\.\d*)/);Al&&(Al=Number(Al[1])),Al&&Al>=15&&(wl=!1,ml=!0);var Wl,Dl=Ml&&(yl||wl&&(null==Al||Al<12.11)),Hl=fl||gl&&vl>=9,Fl=function(t,r){var n=t.className,i=e(r).exec(n);if(i){var o=n.slice(i.index+i[0].length);t.className=n.slice(0,i.index)+(o?i[1]+o:"")}};Wl=document.createRange?function(e,t,r,n){var i=document.createRange();return i.setEnd(n||e,r),i.setStart(e,t),i}:function(e,t,r){var n=document.body.createTextRange();try{n.moveToElementText(e.parentNode)}catch(e){return n}return n.collapse(!0),n.moveEnd("character",r),n.moveStart("character",t),n};var El=function(e){e.select()};Ll?El=function(e){e.selectionStart=0,e.selectionEnd=e.value.length}:gl&&(El=function(e){try{e.select()}catch(e){}});var Pl=function(){this.id=null};Pl.prototype.set=function(e,t){clearTimeout(this.id),this.id=setTimeout(t,e)};var Il,zl,Rl=30,Bl={toString:function(){return"CodeMirror.Pass"}},Gl={scroll:!1},Ul={origin:"*mouse"},Vl={origin:"+move"},Kl=[""],jl=/[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/,Xl=/[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/,Yl=!1,_l=!1,$l=null,ql=function(){function e(e){return e<=247?r.charAt(e):1424<=e&&e<=1524?"R":1536<=e&&e<=1785?n.charAt(e-1536):1774<=e&&e<=2220?"r":8192<=e&&e<=8203?"w":8204==e?"b":"L"}function t(e,t,r){this.level=e,this.from=t,this.to=r}var r="bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN",n="nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111",i=/[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/,o=/[stwN]/,l=/[LRr]/,s=/[Lb1n]/,a=/[1n]/;return function(r,n){var u="ltr"==n?"L":"R";if(0==r.length||"ltr"==n&&!i.test(r))return!1;for(var c=r.length,f=[],h=0;h<c;++h)f.push(e(r.charCodeAt(h)));for(var d=0,p=u;d<c;++d){var v=f[d];"m"==v?f[d]=p:p=v}for(var m=0,y=u;m<c;++m){var b=f[m];"1"==b&&"r"==y?f[m]="n":l.test(b)&&(y=b,"r"==b&&(f[m]="R"))}for(var w=1,x=f[0];w<c-1;++w){var C=f[w];"+"==C&&"1"==x&&"1"==f[w+1]?f[w]="1":","!=C||x!=f[w+1]||"1"!=x&&"n"!=x||(f[w]=x),x=C}for(var S=0;S<c;++S){var L=f[S];if(","==L)f[S]="N";else if("%"==L){var k=void 0;for(k=S+1;k<c&&"%"==f[k];++k);for(var T=S&&"!"==f[S-1]||k<c&&"1"==f[k]?"1":"N",M=S;M<k;++M)f[M]=T;S=k-1}}for(var N=0,O=u;N<c;++N){var A=f[N];"L"==O&&"1"==A?f[N]="L":l.test(A)&&(O=A)}for(var W=0;W<c;++W)if(o.test(f[W])){var D=void 0;for(D=W+1;D<c&&o.test(f[D]);++D);for(var H="L"==(W?f[W-1]:u),F=H==("L"==(D<c?f[D]:u))?H?"L":"R":u,E=W;E<D;++E)f[E]=F;W=D-1}for(var P,I=[],z=0;z<c;)if(s.test(f[z])){var R=z;for(++z;z<c&&s.test(f[z]);++z);I.push(new t(0,R,z))}else{var B=z,G=I.length;for(++z;z<c&&"L"!=f[z];++z);for(var U=B;U<z;)if(a.test(f[U])){B<U&&I.splice(G,0,new t(1,B,U));var V=U;for(++U;U<z&&a.test(f[U]);++U);I.splice(G,0,new t(2,V,U)),B=U}else++U;B<z&&I.splice(G,0,new t(1,B,z))}return 1==I[0].level&&(P=r.match(/^\s+/))&&(I[0].from=P[0].length,I.unshift(new t(0,0,P[0].length))),1==g(I).level&&(P=r.match(/\s+$/))&&(g(I).to-=P[0].length,I.push(new t(0,c-P[0].length,c))),"rtl"==n?I.reverse():I}}(),Zl=[],Ql=function(e,t,r){if(e.addEventListener)e.addEventListener(t,r,!1);else if(e.attachEvent)e.attachEvent("on"+t,r);else{var n=e._handlers||(e._handlers={});n[t]=(n[t]||Zl).concat(r)}},Jl=function(){if(gl&&vl<9)return!1;var e=n("div");return"draggable"in e||"dragDrop"in e}(),es=3!="\n\nb".split(/\n/).length?function(e){for(var t=0,r=[],n=e.length;t<=n;){var i=e.indexOf("\n",t);-1==i&&(i=e.length);var o=e.slice(t,"\r"==e.charAt(i-1)?i-1:i),l=o.indexOf("\r");-1!=l?(r.push(o.slice(0,l)),t+=l+1):(r.push(o),t=i+1)}return r}:function(e){return e.split(/\r\n?|\n/)},ts=window.getSelection?function(e){try{return e.selectionStart!=e.selectionEnd}catch(e){return!1}}:function(e){var t;try{t=e.ownerDocument.selection.createRange()}catch(e){}return!(!t||t.parentElement()!=e)&&0!=t.compareEndPoints("StartToEnd",t)},rs=function(){var e=n("div");return"oncopy"in e||(e.setAttribute("oncopy","return;"),"function"==typeof e.oncopy)}(),ns=null,is={},os={},ls={},ss=function(e,t,r){this.pos=this.start=0,this.string=e,this.tabSize=t||8,this.lastColumnPos=this.lastColumnValue=0,this.lineStart=0,this.lineOracle=r};ss.prototype.eol=function(){return this.pos>=this.string.length},ss.prototype.sol=function(){return this.pos==this.lineStart},ss.prototype.peek=function(){return this.string.charAt(this.pos)||void 0},ss.prototype.next=function(){if(this.pos<this.string.length)return this.string.charAt(this.pos++)},ss.prototype.eat=function(e){var t=this.string.charAt(this.pos);if("string"==typeof e?t==e:t&&(e.test?e.test(t):e(t)))return++this.pos,t},ss.prototype.eatWhile=function(e){for(var t=this.pos;this.eat(e););return this.pos>t},ss.prototype.eatSpace=function(){for(var e=this,t=this.pos;/[\s\u00a0]/.test(this.string.charAt(this.pos));)++e.pos;return this.pos>t},ss.prototype.skipToEnd=function(){this.pos=this.string.length},ss.prototype.skipTo=function(e){var t=this.string.indexOf(e,this.pos);if(t>-1)return this.pos=t,!0},ss.prototype.backUp=function(e){this.pos-=e},ss.prototype.column=function(){return this.lastColumnPos<this.start&&(this.lastColumnValue=f(this.string,this.start,this.tabSize,this.lastColumnPos,this.lastColumnValue),this.lastColumnPos=this.start),this.lastColumnValue-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.indentation=function(){return f(this.string,null,this.tabSize)-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.match=function(e,t,r){if("string"!=typeof e){var n=this.string.slice(this.pos).match(e);return n&&n.index>0?null:(n&&!1!==t&&(this.pos+=n[0].length),n)}var i=function(e){return r?e.toLowerCase():e};if(i(this.string.substr(this.pos,e.length))==i(e))return!1!==t&&(this.pos+=e.length),!0},ss.prototype.current=function(){return this.string.slice(this.start,this.pos)},ss.prototype.hideFirstChars=function(e,t){this.lineStart+=e;try{return t()}finally{this.lineStart-=e}},ss.prototype.lookAhead=function(e){var t=this.lineOracle;return t&&t.lookAhead(e)};var as=function(e,t){this.state=e,this.lookAhead=t},us=function(e,t,r,n){this.state=t,this.doc=e,this.line=r,this.maxLookAhead=n||0};us.prototype.lookAhead=function(e){var t=this.doc.getLine(this.line+e);return null!=t&&e>this.maxLookAhead&&(this.maxLookAhead=e),t},us.prototype.nextLine=function(){this.line++,this.maxLookAhead>0&&this.maxLookAhead--},us.fromSaved=function(e,t,r){return t instanceof as?new us(e,Ke(e.mode,t.state),r,t.lookAhead):new us(e,Ke(e.mode,t),r)},us.prototype.save=function(e){var t=!1!==e?Ke(this.doc.mode,this.state):this.state;return this.maxLookAhead>0?new as(t,this.maxLookAhead):t};var cs=function(e,t,r){this.start=e.start,this.end=e.pos,this.string=e.current(),this.type=t||null,this.state=r},fs=function(e,t,r){this.text=e,ne(this,t),this.height=r?r(this):1};fs.prototype.lineNo=function(){return W(this)},Ae(fs);var hs,ds={},ps={},gs=null,vs=null,ms={left:0,right:0,top:0,bottom:0},ys=function(e,t,r){this.cm=r;var i=this.vert=n("div",[n("div",null,null,"min-width: 1px")],"CodeMirror-vscrollbar"),o=this.horiz=n("div",[n("div",null,null,"height: 100%; min-height: 1px")],"CodeMirror-hscrollbar");e(i),e(o),Ql(i,"scroll",function(){i.clientHeight&&t(i.scrollTop,"vertical")}),Ql(o,"scroll",function(){o.clientWidth&&t(o.scrollLeft,"horizontal")}),this.checkedZeroWidth=!1,gl&&vl<8&&(this.horiz.style.minHeight=this.vert.style.minWidth="18px")};ys.prototype.update=function(e){var t=e.scrollWidth>e.clientWidth+1,r=e.scrollHeight>e.clientHeight+1,n=e.nativeBarWidth;if(r){this.vert.style.display="block",this.vert.style.bottom=t?n+"px":"0";var i=e.viewHeight-(t?n:0);this.vert.firstChild.style.height=Math.max(0,e.scrollHeight-e.clientHeight+i)+"px"}else this.vert.style.display="",this.vert.firstChild.style.height="0";if(t){this.horiz.style.display="block",this.horiz.style.right=r?n+"px":"0",this.horiz.style.left=e.barLeft+"px";var o=e.viewWidth-e.barLeft-(r?n:0);this.horiz.firstChild.style.width=Math.max(0,e.scrollWidth-e.clientWidth+o)+"px"}else this.horiz.style.display="",this.horiz.firstChild.style.width="0";return!this.checkedZeroWidth&&e.clientHeight>0&&(0==n&&this.zeroWidthHack(),this.checkedZeroWidth=!0),{right:r?n:0,bottom:t?n:0}},ys.prototype.setScrollLeft=function(e){this.horiz.scrollLeft!=e&&(this.horiz.scrollLeft=e),this.disableHoriz&&this.enableZeroWidthBar(this.horiz,this.disableHoriz,"horiz")},ys.prototype.setScrollTop=function(e){this.vert.scrollTop!=e&&(this.vert.scrollTop=e),this.disableVert&&this.enableZeroWidthBar(this.vert,this.disableVert,"vert")},ys.prototype.zeroWidthHack=function(){var e=Ml&&!Cl?"12px":"18px";this.horiz.style.height=this.vert.style.width=e,this.horiz.style.pointerEvents=this.vert.style.pointerEvents="none",this.disableHoriz=new Pl,this.disableVert=new Pl},ys.prototype.enableZeroWidthBar=function(e,t,r){function n(){var i=e.getBoundingClientRect();("vert"==r?document.elementFromPoint(i.right-1,(i.top+i.bottom)/2):document.elementFromPoint((i.right+i.left)/2,i.bottom-1))!=e?e.style.pointerEvents="none":t.set(1e3,n)}e.style.pointerEvents="auto",t.set(1e3,n)},ys.prototype.clear=function(){var e=this.horiz.parentNode;e.removeChild(this.horiz),e.removeChild(this.vert)};var bs=function(){};bs.prototype.update=function(){return{bottom:0,right:0}},bs.prototype.setScrollLeft=function(){},bs.prototype.setScrollTop=function(){},bs.prototype.clear=function(){};var ws={native:ys,null:bs},xs=0,Cs=function(e,t,r){var n=e.display;this.viewport=t,this.visible=Ir(n,e.doc,t),this.editorIsHidden=!n.wrapper.offsetWidth,this.wrapperHeight=n.wrapper.clientHeight,this.wrapperWidth=n.wrapper.clientWidth,this.oldDisplayWidth=Rt(e),this.force=r,this.dims=br(e),this.events=[]};Cs.prototype.signal=function(e,t){Oe(e,t)&&this.events.push(arguments)},Cs.prototype.finish=function(){for(var e=this,t=0;t<this.events.length;t++)Te.apply(null,e.events[t])};var Ss=0,Ls=null;gl?Ls=-.53:fl?Ls=15:bl?Ls=-.7:xl&&(Ls=-1/3);var ks=function(e,t){this.ranges=e,this.primIndex=t};ks.prototype.primary=function(){return this.ranges[this.primIndex]},ks.prototype.equals=function(e){var t=this;if(e==this)return!0;if(e.primIndex!=this.primIndex||e.ranges.length!=this.ranges.length)return!1;for(var r=0;r<this.ranges.length;r++){var n=t.ranges[r],i=e.ranges[r];if(!I(n.anchor,i.anchor)||!I(n.head,i.head))return!1}return!0},ks.prototype.deepCopy=function(){for(var e=this,t=[],r=0;r<this.ranges.length;r++)t[r]=new Ts(z(e.ranges[r].anchor),z(e.ranges[r].head));return new ks(t,this.primIndex)},ks.prototype.somethingSelected=function(){for(var e=this,t=0;t<this.ranges.length;t++)if(!e.ranges[t].empty())return!0;return!1},ks.prototype.contains=function(e,t){var r=this;t||(t=e);for(var n=0;n<this.ranges.length;n++){var i=r.ranges[n];if(P(t,i.from())>=0&&P(e,i.to())<=0)return n}return-1};var Ts=function(e,t){this.anchor=e,this.head=t};Ts.prototype.from=function(){return B(this.anchor,this.head)},Ts.prototype.to=function(){return R(this.anchor,this.head)},Ts.prototype.empty=function(){return this.head.line==this.anchor.line&&this.head.ch==this.anchor.ch},Bi.prototype={chunkSize:function(){return this.lines.length},removeInner:function(e,t){for(var r=this,n=e,i=e+t;n<i;++n){var o=r.lines[n];r.height-=o.height,ot(o),bt(o,"delete")}this.lines.splice(e,t)},collapse:function(e){e.push.apply(e,this.lines)},insertInner:function(e,t,r){var n=this;this.height+=r,this.lines=this.lines.slice(0,e).concat(t).concat(this.lines.slice(e));for(var i=0;i<t.length;++i)t[i].parent=n},iterN:function(e,t,r){for(var n=this,i=e+t;e<i;++e)if(r(n.lines[e]))return!0}},Gi.prototype={chunkSize:function(){return this.size},removeInner:function(e,t){var r=this;this.size-=t;for(var n=0;n<this.children.length;++n){var i=r.children[n],o=i.chunkSize();if(e<o){var l=Math.min(t,o-e),s=i.height;if(i.removeInner(e,l),r.height-=s-i.height,o==l&&(r.children.splice(n--,1),i.parent=null),0==(t-=l))break;e=0}else e-=o}if(this.size-t<25&&(this.children.length>1||!(this.children[0]instanceof Bi))){var a=[];this.collapse(a),this.children=[new Bi(a)],this.children[0].parent=this}},collapse:function(e){for(var t=this,r=0;r<this.children.length;++r)t.children[r].collapse(e)},insertInner:function(e,t,r){var n=this;this.size+=t.length,this.height+=r;for(var i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<=l){if(o.insertInner(e,t,r),o.lines&&o.lines.length>50){for(var s=o.lines.length%25+25,a=s;a<o.lines.length;){var u=new Bi(o.lines.slice(a,a+=25));o.height-=u.height,n.children.splice(++i,0,u),u.parent=n}o.lines=o.lines.slice(0,s),n.maybeSpill()}break}e-=l}},maybeSpill:function(){if(!(this.children.length<=10)){var e=this;do{var t=new Gi(e.children.splice(e.children.length-5,5));if(e.parent){e.size-=t.size,e.height-=t.height;var r=h(e.parent.children,e);e.parent.children.splice(r+1,0,t)}else{var n=new Gi(e.children);n.parent=e,e.children=[n,t],e=n}t.parent=e.parent}while(e.children.length>10);e.parent.maybeSpill()}},iterN:function(e,t,r){for(var n=this,i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<l){var s=Math.min(t,l-e);if(o.iterN(e,s,r))return!0;if(0==(t-=s))break;e=0}else e-=l}}};var Ms=function(e,t,r){var n=this;if(r)for(var i in r)r.hasOwnProperty(i)&&(n[i]=r[i]);this.doc=e,this.node=t};Ms.prototype.clear=function(){var e=this,t=this.doc.cm,r=this.line.widgets,n=this.line,i=W(n);if(null!=i&&r){for(var o=0;o<r.length;++o)r[o]==e&&r.splice(o--,1);r.length||(n.widgets=null);var l=Ht(this);A(n,Math.max(0,n.height-l)),t&&(hn(t,function(){Ui(t,n,-l),mn(t,i,"widget")}),bt(t,"lineWidgetCleared",t,this,i))}},Ms.prototype.changed=function(){var e=this,t=this.height,r=this.doc.cm,n=this.line;this.height=null;var i=Ht(this)-t;i&&(A(n,n.height+i),r&&hn(r,function(){r.curOp.forceUpdate=!0,Ui(r,n,i),bt(r,"lineWidgetChanged",r,e,W(n))}))},Ae(Ms);var Ns=0,Os=function(e,t){this.lines=[],this.type=t,this.doc=e,this.id=++Ns};Os.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){var t=this.doc.cm,r=t&&!t.curOp;if(r&&nn(t),Oe(this,"clear")){var n=this.find();n&&bt(this,"clear",n.from,n.to)}for(var i=null,o=null,l=0;l<this.lines.length;++l){var s=e.lines[l],a=_(s.markedSpans,e);t&&!e.collapsed?mn(t,W(s),"text"):t&&(null!=a.to&&(o=W(s)),null!=a.from&&(i=W(s))),s.markedSpans=$(s.markedSpans,a),null==a.from&&e.collapsed&&!ve(e.doc,s)&&t&&A(s,mr(t.display))}if(t&&this.collapsed&&!t.options.lineWrapping)for(var u=0;u<this.lines.length;++u){var c=fe(e.lines[u]),f=be(c);f>t.display.maxLineLength&&(t.display.maxLine=c,t.display.maxLineLength=f,t.display.maxLineChanged=!0)}null!=i&&t&&this.collapsed&&vn(t,i,o+1),this.lines.length=0,this.explicitlyCleared=!0,this.atomic&&this.doc.cantEdit&&(this.doc.cantEdit=!1,t&&Ci(t.doc)),t&&bt(t,"markerCleared",t,this,i,o),r&&on(t),this.parent&&this.parent.clear()}},Os.prototype.find=function(e,t){var r=this;null==e&&"bookmark"==this.type&&(e=1);for(var n,i,o=0;o<this.lines.length;++o){var l=r.lines[o],s=_(l.markedSpans,r);if(null!=s.from&&(n=E(t?l:W(l),s.from),-1==e))return n;if(null!=s.to&&(i=E(t?l:W(l),s.to),1==e))return i}return n&&{from:n,to:i}},Os.prototype.changed=function(){var e=this,t=this.find(-1,!0),r=this,n=this.doc.cm;t&&n&&hn(n,function(){var i=t.line,o=W(t.line),l=jt(n,o);if(l&&(Qt(l),n.curOp.selectionChanged=n.curOp.forceUpdate=!0),n.curOp.updateMaxLine=!0,!ve(r.doc,i)&&null!=r.height){var s=r.height;r.height=null;var a=Ht(r)-s;a&&A(i,i.height+a)}bt(n,"markerChanged",n,e)})},Os.prototype.attachLine=function(e){if(!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;t.maybeHiddenMarkers&&-1!=h(t.maybeHiddenMarkers,this)||(t.maybeUnhiddenMarkers||(t.maybeUnhiddenMarkers=[])).push(this)}this.lines.push(e)},Os.prototype.detachLine=function(e){if(this.lines.splice(h(this.lines,e),1),!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;(t.maybeHiddenMarkers||(t.maybeHiddenMarkers=[])).push(this)}},Ae(Os);var As=function(e,t){var r=this;this.markers=e,this.primary=t;for(var n=0;n<e.length;++n)e[n].parent=r};As.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){this.explicitlyCleared=!0;for(var t=0;t<this.markers.length;++t)e.markers[t].clear();bt(this,"clear")}},As.prototype.find=function(e,t){return this.primary.find(e,t)},Ae(As);var Ws=0,Ds=function(e,t,r,n,i){if(!(this instanceof Ds))return new Ds(e,t,r,n,i);null==r&&(r=0),Gi.call(this,[new Bi([new fs("",null)])]),this.first=r,this.scrollTop=this.scrollLeft=0,this.cantEdit=!1,this.cleanGeneration=1,this.modeFrontier=this.highlightFrontier=r;var o=E(r,0);this.sel=Rn(o),this.history=new Jn(null),this.id=++Ws,this.modeOption=t,this.lineSep=n,this.direction="rtl"==i?"rtl":"ltr",this.extend=!1,"string"==typeof e&&(e=this.splitLines(e)),_n(this,{from:o,to:o,text:e}),bi(this,Rn(o),Gl)};Ds.prototype=b(Gi.prototype,{constructor:Ds,iter:function(e,t,r){r?this.iterN(e-this.first,t-e,r):this.iterN(this.first,this.first+this.size,e)},insert:function(e,t){for(var r=0,n=0;n<t.length;++n)r+=t[n].height;this.insertInner(e-this.first,t,r)},remove:function(e,t){this.removeInner(e-this.first,t)},getValue:function(e){var t=O(this,this.first,this.first+this.size);return!1===e?t:t.join(e||this.lineSeparator())},setValue:gn(function(e){var t=E(this.first,0),r=this.first+this.size-1;Oi(this,{from:t,to:E(r,M(this,r).text.length),text:this.splitLines(e),origin:"setValue",full:!0},!0),this.cm&&Xr(this.cm,0,0),bi(this,Rn(t),Gl)}),replaceRange:function(e,t,r,n){Ei(this,e,t=U(this,t),r=r?U(this,r):t,n)},getRange:function(e,t,r){var n=N(this,U(this,e),U(this,t));return!1===r?n:n.join(r||this.lineSeparator())},getLine:function(e){var t=this.getLineHandle(e);return t&&t.text},getLineHandle:function(e){if(H(this,e))return M(this,e)},getLineNumber:function(e){return W(e)},getLineHandleVisualStart:function(e){return"number"==typeof e&&(e=M(this,e)),fe(e)},lineCount:function(){return this.size},firstLine:function(){return this.first},lastLine:function(){return this.first+this.size-1},clipPos:function(e){return U(this,e)},getCursor:function(e){var t=this.sel.primary();return null==e||"head"==e?t.head:"anchor"==e?t.anchor:"end"==e||"to"==e||!1===e?t.to():t.from()},listSelections:function(){return this.sel.ranges},somethingSelected:function(){return this.sel.somethingSelected()},setCursor:gn(function(e,t,r){vi(this,U(this,"number"==typeof e?E(e,t||0):e),null,r)}),setSelection:gn(function(e,t,r){vi(this,U(this,e),U(this,t||e),r)}),extendSelection:gn(function(e,t,r){di(this,U(this,e),t&&U(this,t),r)}),extendSelections:gn(function(e,t){pi(this,K(this,e),t)}),extendSelectionsBy:gn(function(e,t){pi(this,K(this,v(this.sel.ranges,e)),t)}),setSelections:gn(function(e,t,r){var n=this;if(e.length){for(var i=[],o=0;o<e.length;o++)i[o]=new Ts(U(n,e[o].anchor),U(n,e[o].head));null==t&&(t=Math.min(e.length-1,this.sel.primIndex)),bi(this,zn(i,t),r)}}),addSelection:gn(function(e,t,r){var n=this.sel.ranges.slice(0);n.push(new Ts(U(this,e),U(this,t||e))),bi(this,zn(n,n.length-1),r)}),getSelection:function(e){for(var t,r=this,n=this.sel.ranges,i=0;i<n.length;i++){var o=N(r,n[i].from(),n[i].to());t=t?t.concat(o):o}return!1===e?t:t.join(e||this.lineSeparator())},getSelections:function(e){for(var t=this,r=[],n=this.sel.ranges,i=0;i<n.length;i++){var o=N(t,n[i].from(),n[i].to());!1!==e&&(o=o.join(e||t.lineSeparator())),r[i]=o}return r},replaceSelection:function(e,t,r){for(var n=[],i=0;i<this.sel.ranges.length;i++)n[i]=e;this.replaceSelections(n,t,r||"+input")},replaceSelections:gn(function(e,t,r){for(var n=this,i=[],o=this.sel,l=0;l<o.ranges.length;l++){var s=o.ranges[l];i[l]={from:s.from(),to:s.to(),text:n.splitLines(e[l]),origin:r}}for(var a=t&&"end"!=t&&Kn(this,i,t),u=i.length-1;u>=0;u--)Oi(n,i[u]);a?yi(this,a):this.cm&&jr(this.cm)}),undo:gn(function(){Wi(this,"undo")}),redo:gn(function(){Wi(this,"redo")}),undoSelection:gn(function(){Wi(this,"undo",!0)}),redoSelection:gn(function(){Wi(this,"redo",!0)}),setExtending:function(e){this.extend=e},getExtending:function(){return this.extend},historySize:function(){for(var e=this.history,t=0,r=0,n=0;n<e.done.length;n++)e.done[n].ranges||++t;for(var i=0;i<e.undone.length;i++)e.undone[i].ranges||++r;return{undo:t,redo:r}},clearHistory:function(){this.history=new Jn(this.history.maxGeneration)},markClean:function(){this.cleanGeneration=this.changeGeneration(!0)},changeGeneration:function(e){return e&&(this.history.lastOp=this.history.lastSelOp=this.history.lastOrigin=null),this.history.generation},isClean:function(e){return this.history.generation==(e||this.cleanGeneration)},getHistory:function(){return{done:fi(this.history.done),undone:fi(this.history.undone)}},setHistory:function(e){var t=this.history=new Jn(this.history.maxGeneration);t.done=fi(e.done.slice(0),null,!0),t.undone=fi(e.undone.slice(0),null,!0)},setGutterMarker:gn(function(e,t,r){return Ri(this,e,"gutter",function(e){var n=e.gutterMarkers||(e.gutterMarkers={});return n[t]=r,!r&&C(n)&&(e.gutterMarkers=null),!0})}),clearGutter:gn(function(e){var t=this;this.iter(function(r){r.gutterMarkers&&r.gutterMarkers[e]&&Ri(t,r,"gutter",function(){return r.gutterMarkers[e]=null,C(r.gutterMarkers)&&(r.gutterMarkers=null),!0})})}),lineInfo:function(e){var t;if("number"==typeof e){if(!H(this,e))return null;if(t=e,!(e=M(this,e)))return null}else if(null==(t=W(e)))return null;return{line:t,handle:e,text:e.text,gutterMarkers:e.gutterMarkers,textClass:e.textClass,bgClass:e.bgClass,wrapClass:e.wrapClass,widgets:e.widgets}},addLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass";if(t[i]){if(e(n).test(t[i]))return!1;t[i]+=" "+n}else t[i]=n;return!0})}),removeLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass",o=t[i];if(!o)return!1;if(null==n)t[i]=null;else{var l=o.match(e(n));if(!l)return!1;var s=l.index+l[0].length;t[i]=o.slice(0,l.index)+(l.index&&s!=o.length?" ":"")+o.slice(s)||null}return!0})}),addLineWidget:gn(function(e,t,r){return Vi(this,e,t,r)}),removeLineWidget:function(e){e.clear()},markText:function(e,t,r){return Ki(this,U(this,e),U(this,t),r,r&&r.type||"range")},setBookmark:function(e,t){var r={replacedWith:t&&(null==t.nodeType?t.widget:t),insertLeft:t&&t.insertLeft,clearWhenEmpty:!1,shared:t&&t.shared,handleMouseEvents:t&&t.handleMouseEvents};return e=U(this,e),Ki(this,e,e,r,"bookmark")},findMarksAt:function(e){var t=[],r=M(this,(e=U(this,e)).line).markedSpans;if(r)for(var n=0;n<r.length;++n){var i=r[n];(null==i.from||i.from<=e.ch)&&(null==i.to||i.to>=e.ch)&&t.push(i.marker.parent||i.marker)}return t},findMarks:function(e,t,r){e=U(this,e),t=U(this,t);var n=[],i=e.line;return this.iter(e.line,t.line+1,function(o){var l=o.markedSpans;if(l)for(var s=0;s<l.length;s++){var a=l[s];null!=a.to&&i==e.line&&e.ch>=a.to||null==a.from&&i!=e.line||null!=a.from&&i==t.line&&a.from>=t.ch||r&&!r(a.marker)||n.push(a.marker.parent||a.marker)}++i}),n},getAllMarks:function(){var e=[];return this.iter(function(t){var r=t.markedSpans;if(r)for(var n=0;n<r.length;++n)null!=r[n].from&&e.push(r[n].marker)}),e},posFromIndex:function(e){var t,r=this.first,n=this.lineSeparator().length;return this.iter(function(i){var o=i.text.length+n;if(o>e)return t=e,!0;e-=o,++r}),U(this,E(r,t))},indexFromPos:function(e){var t=(e=U(this,e)).ch;if(e.line<this.first||e.ch<0)return 0;var r=this.lineSeparator().length;return this.iter(this.first,e.line,function(e){t+=e.text.length+r}),t},copy:function(e){var t=new Ds(O(this,this.first,this.first+this.size),this.modeOption,this.first,this.lineSep,this.direction);return t.scrollTop=this.scrollTop,t.scrollLeft=this.scrollLeft,t.sel=this.sel,t.extend=!1,e&&(t.history.undoDepth=this.history.undoDepth,t.setHistory(this.getHistory())),t},linkedDoc:function(e){e||(e={});var t=this.first,r=this.first+this.size;null!=e.from&&e.from>t&&(t=e.from),null!=e.to&&e.to<r&&(r=e.to);var n=new Ds(O(this,t,r),e.mode||this.modeOption,t,this.lineSep,this.direction);return e.sharedHist&&(n.history=this.history),(this.linked||(this.linked=[])).push({doc:n,sharedHist:e.sharedHist}),n.linked=[{doc:this,isParent:!0,sharedHist:e.sharedHist}],Yi(n,Xi(this)),n},unlinkDoc:function(e){var t=this;if(e instanceof jo&&(e=e.doc),this.linked)for(var r=0;r<this.linked.length;++r)if(t.linked[r].doc==e){t.linked.splice(r,1),e.unlinkDoc(t),_i(Xi(t));break}if(e.history==this.history){var n=[e.id];$n(e,function(e){return n.push(e.id)},!0),e.history=new Jn(null),e.history.done=fi(this.history.done,n),e.history.undone=fi(this.history.undone,n)}},iterLinkedDocs:function(e){$n(this,e)},getMode:function(){return this.mode},getEditor:function(){return this.cm},splitLines:function(e){return this.lineSep?e.split(this.lineSep):es(e)},lineSeparator:function(){return this.lineSep||"\n"},setDirection:gn(function(e){"rtl"!=e&&(e="ltr"),e!=this.direction&&(this.direction=e,this.iter(function(e){return e.order=null}),this.cm&&Qn(this.cm))})}),Ds.prototype.eachLine=Ds.prototype.iter;for(var Hs=0,Fs=!1,Es={3:"Enter",8:"Backspace",9:"Tab",13:"Enter",16:"Shift",17:"Ctrl",18:"Alt",19:"Pause",20:"CapsLock",27:"Esc",32:"Space",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"Left",38:"Up",39:"Right",40:"Down",44:"PrintScrn",45:"Insert",46:"Delete",59:";",61:"=",91:"Mod",92:"Mod",93:"Mod",106:"*",107:"=",109:"-",110:".",111:"/",127:"Delete",173:"-",186:";",187:"=",188:",",189:"-",190:".",191:"/",192:"`",219:"[",220:"\\",221:"]",222:"'",63232:"Up",63233:"Down",63234:"Left",63235:"Right",63272:"Delete",63273:"Home",63275:"End",63276:"PageUp",63277:"PageDown",63302:"Insert"},Ps=0;Ps<10;Ps++)Es[Ps+48]=Es[Ps+96]=String(Ps);for(var Is=65;Is<=90;Is++)Es[Is]=String.fromCharCode(Is);for(var zs=1;zs<=12;zs++)Es[zs+111]=Es[zs+63235]="F"+zs;var Rs={};Rs.basic={Left:"goCharLeft",Right:"goCharRight",Up:"goLineUp",Down:"goLineDown",End:"goLineEnd",Home:"goLineStartSmart",PageUp:"goPageUp",PageDown:"goPageDown",Delete:"delCharAfter",Backspace:"delCharBefore","Shift-Backspace":"delCharBefore",Tab:"defaultTab","Shift-Tab":"indentAuto",Enter:"newlineAndIndent",Insert:"toggleOverwrite",Esc:"singleSelection"},Rs.pcDefault={"Ctrl-A":"selectAll","Ctrl-D":"deleteLine","Ctrl-Z":"undo","Shift-Ctrl-Z":"redo","Ctrl-Y":"redo","Ctrl-Home":"goDocStart","Ctrl-End":"goDocEnd","Ctrl-Up":"goLineUp","Ctrl-Down":"goLineDown","Ctrl-Left":"goGroupLeft","Ctrl-Right":"goGroupRight","Alt-Left":"goLineStart","Alt-Right":"goLineEnd","Ctrl-Backspace":"delGroupBefore","Ctrl-Delete":"delGroupAfter","Ctrl-S":"save","Ctrl-F":"find","Ctrl-G":"findNext","Shift-Ctrl-G":"findPrev","Shift-Ctrl-F":"replace","Shift-Ctrl-R":"replaceAll","Ctrl-[":"indentLess","Ctrl-]":"indentMore","Ctrl-U":"undoSelection","Shift-Ctrl-U":"redoSelection","Alt-U":"redoSelection",fallthrough:"basic"},Rs.emacsy={"Ctrl-F":"goCharRight","Ctrl-B":"goCharLeft","Ctrl-P":"goLineUp","Ctrl-N":"goLineDown","Alt-F":"goWordRight","Alt-B":"goWordLeft","Ctrl-A":"goLineStart","Ctrl-E":"goLineEnd","Ctrl-V":"goPageDown","Shift-Ctrl-V":"goPageUp","Ctrl-D":"delCharAfter","Ctrl-H":"delCharBefore","Alt-D":"delWordAfter","Alt-Backspace":"delWordBefore","Ctrl-K":"killLine","Ctrl-T":"transposeChars","Ctrl-O":"openLine"},Rs.macDefault={"Cmd-A":"selectAll","Cmd-D":"deleteLine","Cmd-Z":"undo","Shift-Cmd-Z":"redo","Cmd-Y":"redo","Cmd-Home":"goDocStart","Cmd-Up":"goDocStart","Cmd-End":"goDocEnd","Cmd-Down":"goDocEnd","Alt-Left":"goGroupLeft","Alt-Right":"goGroupRight","Cmd-Left":"goLineLeft","Cmd-Right":"goLineRight","Alt-Backspace":"delGroupBefore","Ctrl-Alt-Backspace":"delGroupAfter","Alt-Delete":"delGroupAfter","Cmd-S":"save","Cmd-F":"find","Cmd-G":"findNext","Shift-Cmd-G":"findPrev","Cmd-Alt-F":"replace","Shift-Cmd-Alt-F":"replaceAll","Cmd-[":"indentLess","Cmd-]":"indentMore","Cmd-Backspace":"delWrappedLineLeft","Cmd-Delete":"delWrappedLineRight","Cmd-U":"undoSelection","Shift-Cmd-U":"redoSelection","Ctrl-Up":"goDocStart","Ctrl-Down":"goDocEnd",fallthrough:["basic","emacsy"]},Rs.default=Ml?Rs.macDefault:Rs.pcDefault;var Bs={selectAll:Mi,singleSelection:function(e){return e.setSelection(e.getCursor("anchor"),e.getCursor("head"),Gl)},killLine:function(e){return co(e,function(t){if(t.empty()){var r=M(e.doc,t.head.line).text.length;return t.head.ch==r&&t.head.line<e.lastLine()?{from:t.head,to:E(t.head.line+1,0)}:{from:t.head,to:E(t.head.line,r)}}return{from:t.from(),to:t.to()}})},deleteLine:function(e){return co(e,function(t){return{from:E(t.from().line,0),to:U(e.doc,E(t.to().line+1,0))}})},delLineLeft:function(e){return co(e,function(e){return{from:E(e.from().line,0),to:e.from()}})},delWrappedLineLeft:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5;return{from:e.coordsChar({left:0,top:r},"div"),to:t.from()}})},delWrappedLineRight:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5,n=e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div");return{from:t.from(),to:n}})},undo:function(e){return e.undo()},redo:function(e){return e.redo()},undoSelection:function(e){return e.undoSelection()},redoSelection:function(e){return e.redoSelection()},goDocStart:function(e){return e.extendSelection(E(e.firstLine(),0))},goDocEnd:function(e){return e.extendSelection(E(e.lastLine()))},goLineStart:function(e){return e.extendSelectionsBy(function(t){return vo(e,t.head.line)},{origin:"+move",bias:1})},goLineStartSmart:function(e){return e.extendSelectionsBy(function(t){return yo(e,t.head)},{origin:"+move",bias:1})},goLineEnd:function(e){return e.extendSelectionsBy(function(t){return mo(e,t.head.line)},{origin:"+move",bias:-1})},goLineRight:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div")},Vl)},goLineLeft:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:0,top:r},"div")},Vl)},goLineLeftSmart:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5,n=e.coordsChar({left:0,top:r},"div");return n.ch<e.getLine(n.line).search(/\S/)?yo(e,t.head):n},Vl)},goLineUp:function(e){return e.moveV(-1,"line")},goLineDown:function(e){return e.moveV(1,"line")},goPageUp:function(e){return e.moveV(-1,"page")},goPageDown:function(e){return e.moveV(1,"page")},goCharLeft:function(e){return e.moveH(-1,"char")},goCharRight:function(e){return e.moveH(1,"char")},goColumnLeft:function(e){return e.moveH(-1,"column")},goColumnRight:function(e){return e.moveH(1,"column")},goWordLeft:function(e){return e.moveH(-1,"word")},goGroupRight:function(e){return e.moveH(1,"group")},goGroupLeft:function(e){return e.moveH(-1,"group")},goWordRight:function(e){return e.moveH(1,"word")},delCharBefore:function(e){return e.deleteH(-1,"char")},delCharAfter:function(e){return e.deleteH(1,"char")},delWordBefore:function(e){return e.deleteH(-1,"word")},delWordAfter:function(e){return e.deleteH(1,"word")},delGroupBefore:function(e){return e.deleteH(-1,"group")},delGroupAfter:function(e){return e.deleteH(1,"group")},indentAuto:function(e){return e.indentSelection("smart")},indentMore:function(e){return e.indentSelection("add")},indentLess:function(e){return e.indentSelection("subtract")},insertTab:function(e){return e.replaceSelection("\t")},insertSoftTab:function(e){for(var t=[],r=e.listSelections(),n=e.options.tabSize,i=0;i<r.length;i++){var o=r[i].from(),l=f(e.getLine(o.line),o.ch,n);t.push(p(n-l%n))}e.replaceSelections(t)},defaultTab:function(e){e.somethingSelected()?e.indentSelection("add"):e.execCommand("insertTab")},transposeChars:function(e){return hn(e,function(){for(var t=e.listSelections(),r=[],n=0;n<t.length;n++)if(t[n].empty()){var i=t[n].head,o=M(e.doc,i.line).text;if(o)if(i.ch==o.length&&(i=new E(i.line,i.ch-1)),i.ch>0)i=new E(i.line,i.ch+1),e.replaceRange(o.charAt(i.ch-1)+o.charAt(i.ch-2),E(i.line,i.ch-2),i,"+transpose");else if(i.line>e.doc.first){var l=M(e.doc,i.line-1).text;l&&(i=new E(i.line,1),e.replaceRange(o.charAt(0)+e.doc.lineSeparator()+l.charAt(l.length-1),E(i.line-1,l.length-1),i,"+transpose"))}r.push(new Ts(i,i))}e.setSelections(r)})},newlineAndIndent:function(e){return hn(e,function(){for(var t=e.listSelections(),r=t.length-1;r>=0;r--)e.replaceRange(e.doc.lineSeparator(),t[r].anchor,t[r].head,"+input");t=e.listSelections();for(var n=0;n<t.length;n++)e.indentLine(t[n].from().line,null,!0);jr(e)})},openLine:function(e){return e.replaceSelection("\n","start")},toggleOverwrite:function(e){return e.toggleOverwrite()}},Gs=new Pl,Us=null,Vs=function(e,t,r){this.time=e,this.pos=t,this.button=r};Vs.prototype.compare=function(e,t,r){return this.time+400>e&&0==P(t,this.pos)&&r==this.button};var Ks,js,Xs={toString:function(){return"CodeMirror.Init"}},Ys={},_s={};jo.defaults=Ys,jo.optionHandlers=_s;var $s=[];jo.defineInitHook=function(e){return $s.push(e)};var qs=null,Zs=function(e){this.cm=e,this.lastAnchorNode=this.lastAnchorOffset=this.lastFocusNode=this.lastFocusOffset=null,this.polling=new Pl,this.composing=null,this.gracePeriod=!1,this.readDOMTimeout=null};Zs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()}),"cut"==e.type&&i.replaceSelection("",null,"cut");else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type&&i.operation(function(){i.setSelections(t.ranges,0,Gl),i.replaceSelection("",null,"cut")})}if(e.clipboardData){e.clipboardData.clearData();var r=qs.text.join("\n");if(e.clipboardData.setData("Text",r),e.clipboardData.getData("Text")==r)return void e.preventDefault()}var l=el(),s=l.firstChild;i.display.lineSpace.insertBefore(l,i.display.lineSpace.firstChild),s.value=qs.text.join("\n");var a=document.activeElement;El(s),setTimeout(function(){i.display.lineSpace.removeChild(l),a.focus(),a==o&&n.showPrimarySelection()},50)}}var r=this,n=this,i=n.cm,o=n.div=e.lineDiv;Jo(o,i.options.spellcheck),Ql(o,"paste",function(e){Me(i,e)||qo(e,i)||vl<=11&&setTimeout(dn(i,function(){return r.updateFromDOM()}),20)}),Ql(o,"compositionstart",function(e){r.composing={data:e.data,done:!1}}),Ql(o,"compositionupdate",function(e){r.composing||(r.composing={data:e.data,done:!1})}),Ql(o,"compositionend",function(e){r.composing&&(e.data!=r.composing.data&&r.readFromDOMSoon(),r.composing.done=!0)}),Ql(o,"touchstart",function(){return n.forceCompositionEnd()}),Ql(o,"input",function(){r.composing||r.readFromDOMSoon()}),Ql(o,"copy",t),Ql(o,"cut",t)},Zs.prototype.prepareSelection=function(){var e=Tr(this.cm,!1);return e.focus=this.cm.state.focused,e},Zs.prototype.showSelection=function(e,t){e&&this.cm.display.view.length&&((e.focus||t)&&this.showPrimarySelection(),this.showMultipleSelections(e))},Zs.prototype.showPrimarySelection=function(){var e=window.getSelection(),t=this.cm,r=t.doc.sel.primary(),n=r.from(),i=r.to();if(t.display.viewTo==t.display.viewFrom||n.line>=t.display.viewTo||i.line<t.display.viewFrom)e.removeAllRanges();else{var o=sl(t,e.anchorNode,e.anchorOffset),l=sl(t,e.focusNode,e.focusOffset);if(!o||o.bad||!l||l.bad||0!=P(B(o,l),n)||0!=P(R(o,l),i)){var s=t.display.view,a=n.line>=t.display.viewFrom&&nl(t,n)||{node:s[0].measure.map[2],offset:0},u=i.line<t.display.viewTo&&nl(t,i);if(!u){var c=s[s.length-1].measure,f=c.maps?c.maps[c.maps.length-1]:c.map;u={node:f[f.length-1],offset:f[f.length-2]-f[f.length-3]}}if(a&&u){var h,d=e.rangeCount&&e.getRangeAt(0);try{h=Wl(a.node,a.offset,u.offset,u.node)}catch(e){}h&&(!fl&&t.state.focused?(e.collapse(a.node,a.offset),h.collapsed||(e.removeAllRanges(),e.addRange(h))):(e.removeAllRanges(),e.addRange(h)),d&&null==e.anchorNode?e.addRange(d):fl&&this.startGracePeriod()),this.rememberSelection()}else e.removeAllRanges()}}},Zs.prototype.startGracePeriod=function(){var e=this;clearTimeout(this.gracePeriod),this.gracePeriod=setTimeout(function(){e.gracePeriod=!1,e.selectionChanged()&&e.cm.operation(function(){return e.cm.curOp.selectionChanged=!0})},20)},Zs.prototype.showMultipleSelections=function(e){r(this.cm.display.cursorDiv,e.cursors),r(this.cm.display.selectionDiv,e.selection)},Zs.prototype.rememberSelection=function(){var e=window.getSelection();this.lastAnchorNode=e.anchorNode,this.lastAnchorOffset=e.anchorOffset,this.lastFocusNode=e.focusNode,this.lastFocusOffset=e.focusOffset},Zs.prototype.selectionInEditor=function(){var e=window.getSelection();if(!e.rangeCount)return!1;var t=e.getRangeAt(0).commonAncestorContainer;return o(this.div,t)},Zs.prototype.focus=function(){"nocursor"!=this.cm.options.readOnly&&(this.selectionInEditor()||this.showSelection(this.prepareSelection(),!0),this.div.focus())},Zs.prototype.blur=function(){this.div.blur()},Zs.prototype.getField=function(){return this.div},Zs.prototype.supportsTouch=function(){return!0},Zs.prototype.receivedFocus=function(){function e(){t.cm.state.focused&&(t.pollSelection(),t.polling.set(t.cm.options.pollInterval,e))}var t=this;this.selectionInEditor()?this.pollSelection():hn(this.cm,function(){return t.cm.curOp.selectionChanged=!0}),this.polling.set(this.cm.options.pollInterval,e)},Zs.prototype.selectionChanged=function(){var e=window.getSelection();return e.anchorNode!=this.lastAnchorNode||e.anchorOffset!=this.lastAnchorOffset||e.focusNode!=this.lastFocusNode||e.focusOffset!=this.lastFocusOffset},Zs.prototype.pollSelection=function(){if(null==this.readDOMTimeout&&!this.gracePeriod&&this.selectionChanged()){var e=window.getSelection(),t=this.cm;if(kl&&bl&&this.cm.options.gutters.length&&il(e.anchorNode))return this.cm.triggerOnKeyDown({type:"keydown",keyCode:8,preventDefault:Math.abs}),this.blur(),void this.focus();if(!this.composing){this.rememberSelection();var r=sl(t,e.anchorNode,e.anchorOffset),n=sl(t,e.focusNode,e.focusOffset);r&&n&&hn(t,function(){bi(t.doc,Rn(r,n),Gl),(r.bad||n.bad)&&(t.curOp.selectionChanged=!0)})}}},Zs.prototype.pollContent=function(){null!=this.readDOMTimeout&&(clearTimeout(this.readDOMTimeout),this.readDOMTimeout=null);var e=this.cm,t=e.display,r=e.doc.sel.primary(),n=r.from(),i=r.to();if(0==n.ch&&n.line>e.firstLine()&&(n=E(n.line-1,M(e.doc,n.line-1).length)),i.ch==M(e.doc,i.line).text.length&&i.line<e.lastLine()&&(i=E(i.line+1,0)),n.line<t.viewFrom||i.line>t.viewTo-1)return!1;var o,l,s;n.line==t.viewFrom||0==(o=Lr(e,n.line))?(l=W(t.view[0].line),s=t.view[0].node):(l=W(t.view[o].line),s=t.view[o-1].node.nextSibling);var a,u,c=Lr(e,i.line);if(c==t.view.length-1?(a=t.viewTo-1,u=t.lineDiv.lastChild):(a=W(t.view[c+1].line)-1,u=t.view[c+1].node.previousSibling),!s)return!1;for(var f=e.doc.splitLines(ll(e,s,u,l,a)),h=N(e.doc,E(l,0),E(a,M(e.doc,a).text.length));f.length>1&&h.length>1;)if(g(f)==g(h))f.pop(),h.pop(),a--;else{if(f[0]!=h[0])break;f.shift(),h.shift(),l++}for(var d=0,p=0,v=f[0],m=h[0],y=Math.min(v.length,m.length);d<y&&v.charCodeAt(d)==m.charCodeAt(d);)++d;for(var b=g(f),w=g(h),x=Math.min(b.length-(1==f.length?d:0),w.length-(1==h.length?d:0));p<x&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)++p;if(1==f.length&&1==h.length&&l==n.line)for(;d&&d>n.ch&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)d--,p++;f[f.length-1]=b.slice(0,b.length-p).replace(/^\u200b+/,""),f[0]=f[0].slice(d).replace(/\u200b+$/,"");var C=E(l,d),S=E(a,h.length?g(h).length-p:0);return f.length>1||f[0]||P(C,S)?(Ei(e.doc,f,C,S,"+input"),!0):void 0},Zs.prototype.ensurePolled=function(){this.forceCompositionEnd()},Zs.prototype.reset=function(){this.forceCompositionEnd()},Zs.prototype.forceCompositionEnd=function(){this.composing&&(clearTimeout(this.readDOMTimeout),this.composing=null,this.updateFromDOM(),this.div.blur(),this.div.focus())},Zs.prototype.readFromDOMSoon=function(){var e=this;null==this.readDOMTimeout&&(this.readDOMTimeout=setTimeout(function(){if(e.readDOMTimeout=null,e.composing){if(!e.composing.done)return;e.composing=null}e.updateFromDOM()},80))},Zs.prototype.updateFromDOM=function(){var e=this;!this.cm.isReadOnly()&&this.pollContent()||hn(this.cm,function(){return vn(e.cm)})},Zs.prototype.setUneditable=function(e){e.contentEditable="false"},Zs.prototype.onKeyPress=function(e){0!=e.charCode&&(e.preventDefault(),this.cm.isReadOnly()||dn(this.cm,$o)(this.cm,String.fromCharCode(null==e.charCode?e.keyCode:e.charCode),0))},Zs.prototype.readOnlyChanged=function(e){this.div.contentEditable=String("nocursor"!=e)},Zs.prototype.onContextMenu=function(){},Zs.prototype.resetPosition=function(){},Zs.prototype.needsContentAttribute=!0;var Qs=function(e){this.cm=e,this.prevInput="",this.pollingFast=!1,this.polling=new Pl,this.hasSelection=!1,this.composing=null};Qs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()});else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type?i.setSelections(t.ranges,null,Gl):(n.prevInput="",l.value=t.text.join("\n"),El(l))}"cut"==e.type&&(i.state.cutIncoming=!0)}}var r=this,n=this,i=this.cm,o=this.wrapper=el(),l=this.textarea=o.firstChild;e.wrapper.insertBefore(o,e.wrapper.firstChild),Ll&&(l.style.width="0px"),Ql(l,"input",function(){gl&&vl>=9&&r.hasSelection&&(r.hasSelection=null),n.poll()}),Ql(l,"paste",function(e){Me(i,e)||qo(e,i)||(i.state.pasteIncoming=!0,n.fastPoll())}),Ql(l,"cut",t),Ql(l,"copy",t),Ql(e.scroller,"paste",function(t){Ft(e,t)||Me(i,t)||(i.state.pasteIncoming=!0,n.focus())}),Ql(e.lineSpace,"selectstart",function(t){Ft(e,t)||We(t)}),Ql(l,"compositionstart",function(){var e=i.getCursor("from");n.composing&&n.composing.range.clear(),n.composing={start:e,range:i.markText(e,i.getCursor("to"),{className:"CodeMirror-composing"})}}),Ql(l,"compositionend",function(){n.composing&&(n.poll(),n.composing.range.clear(),n.composing=null)})},Qs.prototype.prepareSelection=function(){var e=this.cm,t=e.display,r=e.doc,n=Tr(e);if(e.options.moveInputWithCursor){var i=sr(e,r.sel.primary().head,"div"),o=t.wrapper.getBoundingClientRect(),l=t.lineDiv.getBoundingClientRect();n.teTop=Math.max(0,Math.min(t.wrapper.clientHeight-10,i.top+l.top-o.top)),n.teLeft=Math.max(0,Math.min(t.wrapper.clientWidth-10,i.left+l.left-o.left))}return n},Qs.prototype.showSelection=function(e){var t=this.cm.display;r(t.cursorDiv,e.cursors),r(t.selectionDiv,e.selection),null!=e.teTop&&(this.wrapper.style.top=e.teTop+"px",this.wrapper.style.left=e.teLeft+"px")},Qs.prototype.reset=function(e){if(!this.contextMenuPending&&!this.composing){var t=this.cm;if(t.somethingSelected()){this.prevInput="";var r=t.getSelection();this.textarea.value=r,t.state.focused&&El(this.textarea),gl&&vl>=9&&(this.hasSelection=r)}else e||(this.prevInput=this.textarea.value="",gl&&vl>=9&&(this.hasSelection=null))}},Qs.prototype.getField=function(){return this.textarea},Qs.prototype.supportsTouch=function(){return!1},Qs.prototype.focus=function(){if("nocursor"!=this.cm.options.readOnly&&(!Tl||l()!=this.textarea))try{this.textarea.focus()}catch(e){}},Qs.prototype.blur=function(){this.textarea.blur()},Qs.prototype.resetPosition=function(){this.wrapper.style.top=this.wrapper.style.left=0},Qs.prototype.receivedFocus=function(){this.slowPoll()},Qs.prototype.slowPoll=function(){var e=this;this.pollingFast||this.polling.set(this.cm.options.pollInterval,function(){e.poll(),e.cm.state.focused&&e.slowPoll()})},Qs.prototype.fastPoll=function(){function e(){r.poll()||t?(r.pollingFast=!1,r.slowPoll()):(t=!0,r.polling.set(60,e))}var t=!1,r=this;r.pollingFast=!0,r.polling.set(20,e)},Qs.prototype.poll=function(){var e=this,t=this.cm,r=this.textarea,n=this.prevInput;if(this.contextMenuPending||!t.state.focused||ts(r)&&!n&&!this.composing||t.isReadOnly()||t.options.disableInput||t.state.keySeq)return!1;var i=r.value;if(i==n&&!t.somethingSelected())return!1;if(gl&&vl>=9&&this.hasSelection===i||Ml&&/[\uf700-\uf7ff]/.test(i))return t.display.input.reset(),!1;if(t.doc.sel==t.display.selForContextMenu){var o=i.charCodeAt(0);if(8203!=o||n||(n="​"),8666==o)return this.reset(),this.cm.execCommand("undo")}for(var l=0,s=Math.min(n.length,i.length);l<s&&n.charCodeAt(l)==i.charCodeAt(l);)++l;return hn(t,function(){$o(t,i.slice(l),n.length-l,null,e.composing?"*compose":null),i.length>1e3||i.indexOf("\n")>-1?r.value=e.prevInput="":e.prevInput=i,e.composing&&(e.composing.range.clear(),e.composing.range=t.markText(e.composing.start,t.getCursor("to"),{className:"CodeMirror-composing"}))}),!0},Qs.prototype.ensurePolled=function(){this.pollingFast&&this.poll()&&(this.pollingFast=!1)},Qs.prototype.onKeyPress=function(){gl&&vl>=9&&(this.hasSelection=null),this.fastPoll()},Qs.prototype.onContextMenu=function(e){function t(){if(null!=l.selectionStart){var e=i.somethingSelected(),t="​"+(e?l.value:"");l.value="⇚",l.value=t,n.prevInput=e?"":"​",l.selectionStart=1,l.selectionEnd=t.length,o.selForContextMenu=i.doc.sel}}function r(){if(n.contextMenuPending=!1,n.wrapper.style.cssText=c,l.style.cssText=u,gl&&vl<9&&o.scrollbars.setScrollTop(o.scroller.scrollTop=a),null!=l.selectionStart){(!gl||gl&&vl<9)&&t();var e=0,r=function(){o.selForContextMenu==i.doc.sel&&0==l.selectionStart&&l.selectionEnd>0&&"​"==n.prevInput?dn(i,Mi)(i):e++<10?o.detectingSelectAll=setTimeout(r,500):(o.selForContextMenu=null,o.input.reset())};o.detectingSelectAll=setTimeout(r,200)}}var n=this,i=n.cm,o=i.display,l=n.textarea,s=Sr(i,e),a=o.scroller.scrollTop;if(s&&!wl){i.options.resetSelectionOnContextMenu&&-1==i.doc.sel.contains(s)&&dn(i,bi)(i.doc,Rn(s),Gl);var u=l.style.cssText,c=n.wrapper.style.cssText;n.wrapper.style.cssText="position: absolute";var f=n.wrapper.getBoundingClientRect();l.style.cssText="position: absolute; width: 30px; height: 30px;\n      top: "+(e.clientY-f.top-5)+"px; left: "+(e.clientX-f.left-5)+"px;\n      z-index: 1000; background: "+(gl?"rgba(255, 255, 255, .05)":"transparent")+";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";var h;if(ml&&(h=window.scrollY),o.input.focus(),ml&&window.scrollTo(null,h),o.input.reset(),i.somethingSelected()||(l.value=n.prevInput=" "),n.contextMenuPending=!0,o.selForContextMenu=i.doc.sel,clearTimeout(o.detectingSelectAll),gl&&vl>=9&&t(),Hl){Fe(e);var d=function(){ke(window,"mouseup",d),setTimeout(r,20)};Ql(window,"mouseup",d)}else setTimeout(r,50)}},Qs.prototype.readOnlyChanged=function(e){e||this.reset(),this.textarea.disabled="nocursor"==e},Qs.prototype.setUneditable=function(){},Qs.prototype.needsContentAttribute=!1,function(e){function t(t,n,i,o){e.defaults[t]=n,i&&(r[t]=o?function(e,t,r){r!=Xs&&i(e,t,r)}:i)}var r=e.optionHandlers;e.defineOption=t,e.Init=Xs,t("value","",function(e,t){return e.setValue(t)},!0),t("mode",null,function(e,t){e.doc.modeOption=t,jn(e)},!0),t("indentUnit",2,jn,!0),t("indentWithTabs",!1),t("smartIndent",!0),t("tabSize",4,function(e){Xn(e),er(e),vn(e)},!0),t("lineSeparator",null,function(e,t){if(e.doc.lineSep=t,t){var r=[],n=e.doc.first;e.doc.iter(function(e){for(var i=0;;){var o=e.text.indexOf(t,i);if(-1==o)break;i=o+t.length,r.push(E(n,o))}n++});for(var i=r.length-1;i>=0;i--)Ei(e.doc,t,r[i],E(r[i].line,r[i].ch+t.length))}}),t("specialChars",/[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff]/g,function(e,t,r){e.state.specialChars=new RegExp(t.source+(t.test("\t")?"":"|\t"),"g"),r!=Xs&&e.refresh()}),t("specialCharPlaceholder",at,function(e){return e.refresh()},!0),t("electricChars",!0),t("inputStyle",Tl?"contenteditable":"textarea",function(){throw new Error("inputStyle can not (yet) be changed in a running editor")},!0),t("spellcheck",!1,function(e,t){return e.getInputField().spellcheck=t},!0),t("rtlMoveVisually",!Ol),t("wholeLineUpdateBefore",!0),t("theme","default",function(e){Go(e),Uo(e)},!0),t("keyMap","default",function(e,t,r){var n=uo(t),i=r!=Xs&&uo(r);i&&i.detach&&i.detach(e,n),n.attach&&n.attach(e,i||null)}),t("extraKeys",null),t("configureMouse",null),t("lineWrapping",!1,Ko,!0),t("gutters",[],function(e){Fn(e.options),Uo(e)},!0),t("fixedGutter",!0,function(e,t){e.display.gutters.style.left=t?wr(e.display)+"px":"0",e.refresh()},!0),t("coverGutterNextToScrollbar",!1,function(e){return en(e)},!0),t("scrollbarStyle","native",function(e){rn(e),en(e),e.display.scrollbars.setScrollTop(e.doc.scrollTop),e.display.scrollbars.setScrollLeft(e.doc.scrollLeft)},!0),t("lineNumbers",!1,function(e){Fn(e.options),Uo(e)},!0),t("firstLineNumber",1,Uo,!0),t("lineNumberFormatter",function(e){return e},Uo,!0),t("showCursorWhenSelecting",!1,kr,!0),t("resetSelectionOnContextMenu",!0),t("lineWiseCopyCut",!0),t("pasteLinesPerSelection",!0),t("readOnly",!1,function(e,t){"nocursor"==t&&(Fr(e),e.display.input.blur()),e.display.input.readOnlyChanged(t)}),t("disableInput",!1,function(e,t){t||e.display.input.reset()},!0),t("dragDrop",!0,Vo),t("allowDropFileTypes",null),t("cursorBlinkRate",530),t("cursorScrollMargin",0),t("cursorHeight",1,kr,!0),t("singleCursorHeightPerLine",!0,kr,!0),t("workTime",100),t("workDelay",100),t("flattenSpans",!0,Xn,!0),t("addModeClass",!1,Xn,!0),t("pollInterval",100),t("undoDepth",200,function(e,t){return e.doc.history.undoDepth=t}),t("historyEventDelay",1250),t("viewportMargin",10,function(e){return e.refresh()},!0),t("maxHighlightLength",1e4,Xn,!0),t("moveInputWithCursor",!0,function(e,t){t||e.display.input.resetPosition()}),t("tabindex",null,function(e,t){return e.display.input.getField().tabIndex=t||""}),t("autofocus",null),t("direction","ltr",function(e,t){return e.doc.setDirection(t)},!0)}(jo),function(e){var t=e.optionHandlers,r=e.helpers={};e.prototype={constructor:e,focus:function(){window.focus(),this.display.input.focus()},setOption:function(e,r){var n=this.options,i=n[e];n[e]==r&&"mode"!=e||(n[e]=r,t.hasOwnProperty(e)&&dn(this,t[e])(this,r,i),Te(this,"optionChange",this,e))},getOption:function(e){return this.options[e]},getDoc:function(){return this.doc},addKeyMap:function(e,t){this.state.keyMaps[t?"push":"unshift"](uo(e))},removeKeyMap:function(e){for(var t=this.state.keyMaps,r=0;r<t.length;++r)if(t[r]==e||t[r].name==e)return t.splice(r,1),!0},addOverlay:pn(function(t,r){var n=t.token?t:e.getMode(this.options,t);if(n.startState)throw new Error("Overlays may not be stateful.");m(this.state.overlays,{mode:n,modeSpec:t,opaque:r&&r.opaque,priority:r&&r.priority||0},function(e){return e.priority}),this.state.modeGen++,vn(this)}),removeOverlay:pn(function(e){for(var t=this,r=this.state.overlays,n=0;n<r.length;++n){var i=r[n].modeSpec;if(i==e||"string"==typeof e&&i.name==e)return r.splice(n,1),t.state.modeGen++,void vn(t)}}),indentLine:pn(function(e,t,r){"string"!=typeof t&&"number"!=typeof t&&(t=null==t?this.options.smartIndent?"smart":"prev":t?"add":"subtract"),H(this.doc,e)&&Yo(this,e,t,r)}),indentSelection:pn(function(e){for(var t=this,r=this.doc.sel.ranges,n=-1,i=0;i<r.length;i++){var o=r[i];if(o.empty())o.head.line>n&&(Yo(t,o.head.line,e,!0),n=o.head.line,i==t.doc.sel.primIndex&&jr(t));else{var l=o.from(),s=o.to(),a=Math.max(n,l.line);n=Math.min(t.lastLine(),s.line-(s.ch?0:1))+1;for(var u=a;u<n;++u)Yo(t,u,e);var c=t.doc.sel.ranges;0==l.ch&&r.length==c.length&&c[i].from().ch>0&&gi(t.doc,i,new Ts(l,c[i].to()),Gl)}}}),getTokenAt:function(e,t){return Je(this,e,t)},getLineTokens:function(e,t){return Je(this,E(e),t,!0)},getTokenTypeAt:function(e){e=U(this.doc,e);var t,r=_e(this,M(this.doc,e.line)),n=0,i=(r.length-1)/2,o=e.ch;if(0==o)t=r[2];else for(;;){var l=n+i>>1;if((l?r[2*l-1]:0)>=o)i=l;else{if(!(r[2*l+1]<o)){t=r[2*l+2];break}n=l+1}}var s=t?t.indexOf("overlay "):-1;return s<0?t:0==s?null:t.slice(0,s-1)},getModeAt:function(t){var r=this.doc.mode;return r.innerMode?e.innerMode(r,this.getTokenAt(t).state).mode:r},getHelper:function(e,t){return this.getHelpers(e,t)[0]},getHelpers:function(e,t){var n=this,i=[];if(!r.hasOwnProperty(t))return i;var o=r[t],l=this.getModeAt(e);if("string"==typeof l[t])o[l[t]]&&i.push(o[l[t]]);else if(l[t])for(var s=0;s<l[t].length;s++){var a=o[l[t][s]];a&&i.push(a)}else l.helperType&&o[l.helperType]?i.push(o[l.helperType]):o[l.name]&&i.push(o[l.name]);for(var u=0;u<o._global.length;u++){var c=o._global[u];c.pred(l,n)&&-1==h(i,c.val)&&i.push(c.val)}return i},getStateAfter:function(e,t){var r=this.doc;return e=G(r,null==e?r.first+r.size-1:e),$e(this,e+1,t).state},cursorCoords:function(e,t){var r,n=this.doc.sel.primary();return r=null==e?n.head:"object"==typeof e?U(this.doc,e):e?n.from():n.to(),sr(this,r,t||"page")},charCoords:function(e,t){return lr(this,U(this.doc,e),t||"page")},coordsChar:function(e,t){return e=or(this,e,t||"page"),cr(this,e.left,e.top)},lineAtHeight:function(e,t){return e=or(this,{top:e,left:0},t||"page").top,D(this.doc,e+this.display.viewOffset)},heightAtLine:function(e,t,r){var n,i=!1;if("number"==typeof e){var o=this.doc.first+this.doc.size-1;e<this.doc.first?e=this.doc.first:e>o&&(e=o,i=!0),n=M(this.doc,e)}else n=e;return ir(this,n,{top:0,left:0},t||"page",r||i).top+(i?this.doc.height-ye(n):0)},defaultTextHeight:function(){return mr(this.display)},defaultCharWidth:function(){return yr(this.display)},getViewport:function(){return{from:this.display.viewFrom,to:this.display.viewTo}},addWidget:function(e,t,r,n,i){var o=this.display,l=(e=sr(this,U(this.doc,e))).bottom,s=e.left;if(t.style.position="absolute",t.setAttribute("cm-ignore-events","true"),this.display.input.setUneditable(t),o.sizer.appendChild(t),"over"==n)l=e.top;else if("above"==n||"near"==n){var a=Math.max(o.wrapper.clientHeight,this.doc.height),u=Math.max(o.sizer.clientWidth,o.lineSpace.clientWidth);("above"==n||e.bottom+t.offsetHeight>a)&&e.top>t.offsetHeight?l=e.top-t.offsetHeight:e.bottom+t.offsetHeight<=a&&(l=e.bottom),s+t.offsetWidth>u&&(s=u-t.offsetWidth)}t.style.top=l+"px",t.style.left=t.style.right="","right"==i?(s=o.sizer.clientWidth-t.offsetWidth,t.style.right="0px"):("left"==i?s=0:"middle"==i&&(s=(o.sizer.clientWidth-t.offsetWidth)/2),t.style.left=s+"px"),r&&Ur(this,{left:s,top:l,right:s+t.offsetWidth,bottom:l+t.offsetHeight})},triggerOnKeyDown:pn(Lo),triggerOnKeyPress:pn(Mo),triggerOnKeyUp:To,triggerOnMouseDown:pn(Oo),execCommand:function(e){if(Bs.hasOwnProperty(e))return Bs[e].call(null,this)},triggerElectric:pn(function(e){Zo(this,e)}),findPosH:function(e,t,r,n){var i=this,o=1;t<0&&(o=-1,t=-t);for(var l=U(this.doc,e),s=0;s<t&&!(l=tl(i.doc,l,o,r,n)).hitSide;++s);return l},moveH:pn(function(e,t){var r=this;this.extendSelectionsBy(function(n){return r.display.shift||r.doc.extend||n.empty()?tl(r.doc,n.head,e,t,r.options.rtlMoveVisually):e<0?n.from():n.to()},Vl)}),deleteH:pn(function(e,t){var r=this.doc.sel,n=this.doc;r.somethingSelected()?n.replaceSelection("",null,"+delete"):co(this,function(r){var i=tl(n,r.head,e,t,!1);return e<0?{from:i,to:r.head}:{from:r.head,to:i}})}),findPosV:function(e,t,r,n){var i=this,o=1,l=n;t<0&&(o=-1,t=-t);for(var s=U(this.doc,e),a=0;a<t;++a){var u=sr(i,s,"div");if(null==l?l=u.left:u.left=l,(s=rl(i,u,o,r)).hitSide)break}return s},moveV:pn(function(e,t){var r=this,n=this.doc,i=[],o=!this.display.shift&&!n.extend&&n.sel.somethingSelected();if(n.extendSelectionsBy(function(l){if(o)return e<0?l.from():l.to();var s=sr(r,l.head,"div");null!=l.goalColumn&&(s.left=l.goalColumn),i.push(s.left);var a=rl(r,s,e,t);return"page"==t&&l==n.sel.primary()&&Kr(r,lr(r,a,"div").top-s.top),a},Vl),i.length)for(var l=0;l<n.sel.ranges.length;l++)n.sel.ranges[l].goalColumn=i[l]}),findWordAt:function(e){var t=M(this.doc,e.line).text,r=e.ch,n=e.ch;if(t){var i=this.getHelper(e,"wordChars");"before"!=e.sticky&&n!=t.length||!r?++n:--r;for(var o=t.charAt(r),l=x(o,i)?function(e){return x(e,i)}:/\s/.test(o)?function(e){return/\s/.test(e)}:function(e){return!/\s/.test(e)&&!x(e)};r>0&&l(t.charAt(r-1));)--r;for(;n<t.length&&l(t.charAt(n));)++n}return new Ts(E(e.line,r),E(e.line,n))},toggleOverwrite:function(e){null!=e&&e==this.state.overwrite||((this.state.overwrite=!this.state.overwrite)?s(this.display.cursorDiv,"CodeMirror-overwrite"):Fl(this.display.cursorDiv,"CodeMirror-overwrite"),Te(this,"overwriteToggle",this,this.state.overwrite))},hasFocus:function(){return this.display.input.getField()==l()},isReadOnly:function(){return!(!this.options.readOnly&&!this.doc.cantEdit)},scrollTo:pn(function(e,t){Xr(this,e,t)}),getScrollInfo:function(){var e=this.display.scroller;return{left:e.scrollLeft,top:e.scrollTop,height:e.scrollHeight-zt(this)-this.display.barHeight,width:e.scrollWidth-zt(this)-this.display.barWidth,clientHeight:Bt(this),clientWidth:Rt(this)}},scrollIntoView:pn(function(e,t){null==e?(e={from:this.doc.sel.primary().head,to:null},null==t&&(t=this.options.cursorScrollMargin)):"number"==typeof e?e={from:E(e,0),to:null}:null==e.from&&(e={from:e,to:null}),e.to||(e.to=e.from),e.margin=t||0,null!=e.from.line?Yr(this,e):$r(this,e.from,e.to,e.margin)}),setSize:pn(function(e,t){var r=this,n=function(e){return"number"==typeof e||/^\d+$/.test(String(e))?e+"px":e};null!=e&&(this.display.wrapper.style.width=n(e)),null!=t&&(this.display.wrapper.style.height=n(t)),this.options.lineWrapping&&Jt(this);var i=this.display.viewFrom;this.doc.iter(i,this.display.viewTo,function(e){if(e.widgets)for(var t=0;t<e.widgets.length;t++)if(e.widgets[t].noHScroll){mn(r,i,"widget");break}++i}),this.curOp.forceUpdate=!0,Te(this,"refresh",this)}),operation:function(e){return hn(this,e)},startOperation:function(){return nn(this)},endOperation:function(){return on(this)},refresh:pn(function(){var e=this.display.cachedTextHeight;vn(this),this.curOp.forceUpdate=!0,er(this),Xr(this,this.doc.scrollLeft,this.doc.scrollTop),Wn(this),(null==e||Math.abs(e-mr(this.display))>.5)&&Cr(this),Te(this,"refresh",this)}),swapDoc:pn(function(e){var t=this.doc;return t.cm=null,qn(this,e),er(this),this.display.input.reset(),Xr(this,e.scrollLeft,e.scrollTop),this.curOp.forceScroll=!0,bt(this,"swapDoc",this,t),t}),getInputField:function(){return this.display.input.getField()},getWrapperElement:function(){return this.display.wrapper},getScrollerElement:function(){return this.display.scroller},getGutterElement:function(){return this.display.gutters}},Ae(e),e.registerHelper=function(t,n,i){r.hasOwnProperty(t)||(r[t]=e[t]={_global:[]}),r[t][n]=i},e.registerGlobalHelper=function(t,n,i,o){e.registerHelper(t,n,o),r[t]._global.push({pred:i,val:o})}}(jo);var Js="iter insert remove copy getEditor constructor".split(" ");for(var ea in Ds.prototype)Ds.prototype.hasOwnProperty(ea)&&h(Js,ea)<0&&(jo.prototype[ea]=function(e){return function(){return e.apply(this.doc,arguments)}}(Ds.prototype[ea]));return Ae(Ds),jo.inputStyles={textarea:Qs,contenteditable:Zs},jo.defineMode=function(e){jo.defaults.mode||"null"==e||(jo.defaults.mode=e),Be.apply(this,arguments)},jo.defineMIME=function(e,t){os[e]=t},jo.defineMode("null",function(){return{token:function(e){return e.skipToEnd()}}}),jo.defineMIME("text/plain","null"),jo.defineExtension=function(e,t){jo.prototype[e]=t},jo.defineDocExtension=function(e,t){Ds.prototype[e]=t},jo.fromTextArea=function(e,t){function r(){e.value=a.getValue()}if(t=t?c(t):{},t.value=e.value,!t.tabindex&&e.tabIndex&&(t.tabindex=e.tabIndex),!t.placeholder&&e.placeholder&&(t.placeholder=e.placeholder),null==t.autofocus){var n=l();t.autofocus=n==e||null!=e.getAttribute("autofocus")&&n==document.body}var i;if(e.form&&(Ql(e.form,"submit",r),!t.leaveSubmitMethodAlone)){var o=e.form;i=o.submit;try{var s=o.submit=function(){r(),o.submit=i,o.submit(),o.submit=s}}catch(e){}}t.finishInit=function(t){t.save=r,t.getTextArea=function(){return e},t.toTextArea=function(){t.toTextArea=isNaN,r(),e.parentNode.removeChild(t.getWrapperElement()),e.style.display="",e.form&&(ke(e.form,"submit",r),"function"==typeof e.form.submit&&(e.form.submit=i))}},e.style.display="none";var a=jo(function(t){return e.parentNode.insertBefore(t,e.nextSibling)},t);return a},function(e){e.off=ke,e.on=Ql,e.wheelEventPixels=Pn,e.Doc=Ds,e.splitLines=es,e.countColumn=f,e.findColumn=d,e.isWordChar=w,e.Pass=Bl,e.signal=Te,e.Line=fs,e.changeEnd=Bn,e.scrollbarModel=ws,e.Pos=E,e.cmpPos=P,e.modes=is,e.mimeModes=os,e.resolveMode=Ge,e.getMode=Ue,e.modeExtensions=ls,e.extendMode=Ve,e.copyState=Ke,e.startState=Xe,e.innerMode=je,e.commands=Bs,e.keyMap=Rs,e.keyName=ao,e.isModifierKey=lo,e.lookupKey=oo,e.normalizeKeyMap=io,e.StringStream=ss,e.SharedTextMarker=As,e.TextMarker=Os,e.LineWidget=Ms,e.e_preventDefault=We,e.e_stopPropagation=De,e.e_stop=Fe,e.addClass=s,e.contains=o,e.rmClass=Fl,e.keyNames=Es}(jo),jo.version="5.30.0",jo});
      !function(e){"object"==typeof exports&&"object"==typeof module?e(require("../../lib/codemirror")):"function"==typeof define&&define.amd?define(["../../lib/codemirror"],e):e(CodeMirror)}(function(e){"use strict";function t(e,t,n,r,o,a){this.indented=e,this.column=t,this.type=n,this.info=r,this.align=o,this.prev=a}function n(e,n,r,o){var a=e.indented;return e.context&&"statement"==e.context.type&&"statement"!=r&&(a=e.context.indented),e.context=new t(a,n,r,o,null,e.context)}function r(e){var t=e.context.type;return")"!=t&&"]"!=t&&"}"!=t||(e.indented=e.context.indented),e.context=e.context.prev}function o(e,t,n){return"variable"==t.prevToken||"type"==t.prevToken||(!!/\S(?:[^- ]>|[*\]])\s*$|\*$/.test(e.string.slice(0,n))||(!(!t.typeAtEndOfLine||e.column()!=e.indentation())||void 0))}function a(e){for(;;){if(!e||"top"==e.type)return!0;if("}"==e.type&&"namespace"!=e.prev.info)return!1;e=e.prev}}function i(e){for(var t={},n=e.split(" "),r=0;r<n.length;++r)t[n[r]]=!0;return t}function l(e,t){return"function"==typeof e?e(t):e.propertyIsEnumerable(t)}function s(e,t){if(!t.startOfLine)return!1;for(var n,r=null;n=e.peek();){if("\\"==n&&e.match(/^.$/)){r=s;break}if("/"==n&&e.match(/^\/[\/\*]/,!1))break;e.next()}return t.tokenize=r,"meta"}function c(e,t){return"type"==t.prevToken&&"type"}function u(e){return e.eatWhile(/[\w\.']/),"number"}function d(e,t){if(e.backUp(1),e.match(/(R|u8R|uR|UR|LR)/)){var n=e.match(/"([^\s\\()]{0,16})\(/);return!!n&&(t.cpp11RawStringDelim=n[1],t.tokenize=m,m(e,t))}return e.match(/(u8|u|U|L)/)?!!e.match(/["']/,!1)&&"string":(e.next(),!1)}function f(e){var t=/(\w+)::~?(\w+)$/.exec(e);return t&&t[1]==t[2]}function p(e,t){for(var n;null!=(n=e.next());)if('"'==n&&!e.eat('"')){t.tokenize=null;break}return"string"}function m(e,t){var n=t.cpp11RawStringDelim.replace(/[^\w\s]/g,"\\$&");return e.match(new RegExp(".*?\\)"+n+'"'))?t.tokenize=null:e.skipToEnd(),"string"}function h(t,n){function r(e){if(e)for(var t in e)e.hasOwnProperty(t)&&o.push(t)}"string"==typeof t&&(t=[t]);var o=[];r(n.keywords),r(n.types),r(n.builtin),r(n.atoms),o.length&&(n.helperType=t[0],e.registerHelper("hintWords",t[0],o));for(var a=0;a<t.length;++a)e.defineMIME(t[a],n)}function g(e,t){for(var n=!1;!e.eol();){if(!n&&e.match('"""')){t.tokenize=null;break}n="\\"==e.next()&&!n}return"string"}function y(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!e&&!o&&t.match('"')){a=!0;break}if(e&&t.match('"""')){a=!0;break}r=t.next(),!o&&"$"==r&&t.match("{")&&t.skipTo("}"),o=!o&&"\\"==r&&!e}return!a&&e||(n.tokenize=null),"string"}}function x(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!o&&t.match('"')&&("single"==e||t.match('""'))){a=!0;break}if(!o&&t.match("``")){w=x(e),a=!0;break}r=t.next(),o="single"==e&&!o&&"\\"==r}return a&&(n.tokenize=null),"string"}}e.defineMode("clike",function(i,s){function c(e,t){var n=e.next();if(S[n]){var r=S[n](e,t);if(!1!==r)return r}if('"'==n||"'"==n)return t.tokenize=u(n),t.tokenize(e,t);if(D.test(n))return p=n,null;if(L.test(n)){if(e.backUp(1),e.match(I))return"number";e.next()}if("/"==n){if(e.eat("*"))return t.tokenize=d,d(e,t);if(e.eat("/"))return e.skipToEnd(),"comment"}if(F.test(n)){for(;!e.match(/^\/[\/*]/,!1)&&e.eat(F););return"operator"}if(e.eatWhile(z),P)for(;e.match(P);)e.eatWhile(z);var o=e.current();return l(x,o)?(l(w,o)&&(p="newstatement"),l(v,o)&&(m=!0),"keyword"):l(b,o)?"type":l(k,o)?(l(w,o)&&(p="newstatement"),"builtin"):l(_,o)?"atom":"variable"}function u(e){return function(t,n){for(var r,o=!1,a=!1;null!=(r=t.next());){if(r==e&&!o){a=!0;break}o=!o&&"\\"==r}return(a||!o&&!C)&&(n.tokenize=null),"string"}}function d(e,t){for(var n,r=!1;n=e.next();){if("/"==n&&r){t.tokenize=null;break}r="*"==n}return"comment"}function f(e,t){s.typeFirstDefinitions&&e.eol()&&a(t.context)&&(t.typeAtEndOfLine=o(e,t,e.pos))}var p,m,h=i.indentUnit,g=s.statementIndentUnit||h,y=s.dontAlignCalls,x=s.keywords||{},b=s.types||{},k=s.builtin||{},w=s.blockKeywords||{},v=s.defKeywords||{},_=s.atoms||{},S=s.hooks||{},C=s.multiLineStrings,T=!1!==s.indentStatements,M=!1!==s.indentSwitch,P=s.namespaceSeparator,D=s.isPunctuationChar||/[\[\]{}\(\),;\:\.]/,L=s.numberStart||/[\d\.]/,I=s.number||/^(?:0x[a-f\d]+|0b[01]+|(?:\d+\.?\d*|\.\d+)(?:e[-+]?\d+)?)(u|ll?|l|f)?/i,F=s.isOperatorChar||/[+\-*&%=<>!?|\/]/,z=s.isIdentifierChar||/[\w\$_\xa1-\uffff]/;return{startState:function(e){return{tokenize:null,context:new t((e||0)-h,0,"top",null,!1),indented:0,startOfLine:!0,prevToken:null}},token:function(e,t){var i=t.context;if(e.sol()&&(null==i.align&&(i.align=!1),t.indented=e.indentation(),t.startOfLine=!0),e.eatSpace())return f(e,t),null;p=m=null;var l=(t.tokenize||c)(e,t);if("comment"==l||"meta"==l)return l;if(null==i.align&&(i.align=!0),";"==p||":"==p||","==p&&e.match(/^\s*(?:\/\/.*)?$/,!1))for(;"statement"==t.context.type;)r(t);else if("{"==p)n(t,e.column(),"}");else if("["==p)n(t,e.column(),"]");else if("("==p)n(t,e.column(),")");else if("}"==p){for(;"statement"==i.type;)i=r(t);for("}"==i.type&&(i=r(t));"statement"==i.type;)i=r(t)}else p==i.type?r(t):T&&(("}"==i.type||"top"==i.type)&&";"!=p||"statement"==i.type&&"newstatement"==p)&&n(t,e.column(),"statement",e.current());if("variable"==l&&("def"==t.prevToken||s.typeFirstDefinitions&&o(e,t,e.start)&&a(t.context)&&e.match(/^\s*\(/,!1))&&(l="def"),S.token){var u=S.token(e,t,l);void 0!==u&&(l=u)}return"def"==l&&!1===s.styleDefs&&(l="variable"),t.startOfLine=!1,t.prevToken=m?"def":l||p,f(e,t),l},indent:function(t,n){if(t.tokenize!=c&&null!=t.tokenize||t.typeAtEndOfLine)return e.Pass;var r=t.context,o=n&&n.charAt(0);if("statement"==r.type&&"}"==o&&(r=r.prev),s.dontIndentStatements)for(;"statement"==r.type&&s.dontIndentStatements.test(r.info);)r=r.prev;if(S.indent){var a=S.indent(t,r,n);if("number"==typeof a)return a}var i=o==r.type,l=r.prev&&"switch"==r.prev.info;if(s.allmanIndentation&&/[{(]/.test(o)){for(;"top"!=r.type&&"}"!=r.type;)r=r.prev;return r.indented}return"statement"==r.type?r.indented+("{"==o?0:g):!r.align||y&&")"==r.type?")"!=r.type||i?r.indented+(i?0:h)+(i||!l||/^(?:case|default)\b/.test(n)?0:h):r.indented+g:r.column+(i?0:1)},electricInput:M?/^\s*(?:case .*?:|default:|\{\}?|\})$/:/^\s*[{}]$/,blockCommentStart:"/*",blockCommentEnd:"*/",lineComment:"//",fold:"brace"}});var b="auto if break case register continue return default do sizeof static else struct switch extern typedef union for goto while enum const volatile",k="int long char short double float unsigned signed void size_t ptrdiff_t";h(["text/x-csrc","text/x-c","text/x-chdr"],{name:"clike",keywords:i(b),types:i(k+" bool _Complex _Bool float_t double_t intptr_t intmax_t int8_t int16_t int32_t int64_t uintptr_t uintmax_t uint8_t uint16_t uint32_t uint64_t"),blockKeywords:i("case do else for if switch while struct"),defKeywords:i("struct"),typeFirstDefinitions:!0,atoms:i("null true false"),hooks:{"#":s,"*":c},modeProps:{fold:["brace","include"]}}),h(["text/x-c++src","text/x-c++hdr"],{name:"clike",keywords:i(b+" asm dynamic_cast namespace reinterpret_cast try explicit new static_cast typeid catch operator template typename class friend private this using const_cast inline public throw virtual delete mutable protected alignas alignof constexpr decltype nullptr noexcept thread_local final static_assert override"),types:i(k+" bool wchar_t"),blockKeywords:i("catch class do else finally for if struct switch try while"),defKeywords:i("class namespace struct enum union"),typeFirstDefinitions:!0,atoms:i("true false null"),dontIndentStatements:/^template$/,isIdentifierChar:/[\w\$_~\xa1-\uffff]/,hooks:{"#":s,"*":c,u:d,U:d,L:d,R:d,0:u,1:u,2:u,3:u,4:u,5:u,6:u,7:u,8:u,9:u,token:function(e,t,n){if("variable"==n&&"("==e.peek()&&(";"==t.prevToken||null==t.prevToken||"}"==t.prevToken)&&f(e.current()))return"def"}},namespaceSeparator:"::",modeProps:{fold:["brace","include"]}}),h("text/x-java",{name:"clike",keywords:i("abstract assert break case catch class const continue default do else enum extends final finally float for goto if implements import instanceof interface native new package private protected public return static strictfp super switch synchronized this throw throws transient try volatile while @interface"),types:i("byte short int long float double boolean char void Boolean Byte Character Double Float Integer Long Number Object Short String StringBuffer StringBuilder Void"),blockKeywords:i("catch class do else finally for if switch try while"),defKeywords:i("class interface package enum @interface"),typeFirstDefinitions:!0,atoms:i("true false null"),number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,hooks:{"@":function(e){return!e.match("interface",!1)&&(e.eatWhile(/[\w\$_]/),"meta")}},modeProps:{fold:["brace","import"]}}),h("text/x-csharp",{name:"clike",keywords:i("abstract as async await base break case catch checked class const continue default delegate do else enum event explicit extern finally fixed for foreach goto if implicit in interface internal is lock namespace new operator out override params private protected public readonly ref return sealed sizeof stackalloc static struct switch this throw try typeof unchecked unsafe using virtual void volatile while add alias ascending descending dynamic from get global group into join let orderby partial remove select set value var yield"),types:i("Action Boolean Byte Char DateTime DateTimeOffset Decimal Double Func Guid Int16 Int32 Int64 Object SByte Single String Task TimeSpan UInt16 UInt32 UInt64 bool byte char decimal double short int long object sbyte float string ushort uint ulong"),blockKeywords:i("catch class do else finally for foreach if struct switch try while"),defKeywords:i("class interface namespace struct var"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"@":function(e,t){return e.eat('"')?(t.tokenize=p,p(e,t)):(e.eatWhile(/[\w\$_]/),"meta")}}}),h("text/x-scala",{name:"clike",keywords:i("abstract case catch class def do else extends final finally for forSome if implicit import lazy match new null object override package private protected return sealed super this throw trait try type val var while with yield _ assert assume require print println printf readLine readBoolean readByte readShort readChar readInt readLong readFloat readDouble"),types:i("AnyVal App Application Array BufferedIterator BigDecimal BigInt Char Console Either Enumeration Equiv Error Exception Fractional Function IndexedSeq Int Integral Iterable Iterator List Map Numeric Nil NotNull Option Ordered Ordering PartialFunction PartialOrdering Product Proxy Range Responder Seq Serializable Set Specializable Stream StringBuilder StringContext Symbol Throwable Traversable TraversableOnce Tuple Unit Vector Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),multiLineStrings:!0,blockKeywords:i("catch class enum do else finally for forSome if match switch try while"),defKeywords:i("class enum def object package trait type val var"),atoms:i("true false null"),indentStatements:!1,indentSwitch:!1,isOperatorChar:/[+\-*&%=<>!?|\/#:@]/,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return!!e.match('""')&&(t.tokenize=g,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},"=":function(e,n){var r=n.context;return!("}"!=r.type||!r.align||!e.eat(">"))&&(n.context=new t(r.indented,r.column,r.type,r.info,null,r.prev),"operator")}},modeProps:{closeBrackets:{triples:'"'}}}),h("text/x-kotlin",{name:"clike",keywords:i("package as typealias class interface this super val var fun for is in This throw return break continue object if else while do try when !in !is as? file import where by get set abstract enum open inner override private public internal protected catch finally out final vararg reified dynamic companion constructor init sealed field property receiver param sparam lateinit data inline noinline tailrec external annotation crossinline const operator infix suspend"),types:i("Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),intendSwitch:!1,indentStatements:!1,multiLineStrings:!0,number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,blockKeywords:i("catch class do else finally for if where try while enum"),defKeywords:i("class val var object package interface fun"),atoms:i("true false null this"),hooks:{'"':function(e,t){return t.tokenize=y(e.match('""')),t.tokenize(e,t)}},modeProps:{closeBrackets:{triples:'"'}}}),h(["x-shader/x-vertex","x-shader/x-fragment"],{name:"clike",keywords:i("sampler1D sampler2D sampler3D samplerCube sampler1DShadow sampler2DShadow const attribute uniform varying break continue discard return for while do if else struct in out inout"),types:i("float int bool void vec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4 mat2 mat3 mat4"),blockKeywords:i("for while do if else struct"),builtin:i("radians degrees sin cos tan asin acos atan pow exp log exp2 sqrt inversesqrt abs sign floor ceil fract mod min max clamp mix step smoothstep length distance dot cross normalize ftransform faceforward reflect refract matrixCompMult lessThan lessThanEqual greaterThan greaterThanEqual equal notEqual any all not texture1D texture1DProj texture1DLod texture1DProjLod texture2D texture2DProj texture2DLod texture2DProjLod texture3D texture3DProj texture3DLod texture3DProjLod textureCube textureCubeLod shadow1D shadow2D shadow1DProj shadow2DProj shadow1DLod shadow2DLod shadow1DProjLod shadow2DProjLod dFdx dFdy fwidth noise1 noise2 noise3 noise4"),atoms:i("true false gl_FragColor gl_SecondaryColor gl_Normal gl_Vertex gl_MultiTexCoord0 gl_MultiTexCoord1 gl_MultiTexCoord2 gl_MultiTexCoord3 gl_MultiTexCoord4 gl_MultiTexCoord5 gl_MultiTexCoord6 gl_MultiTexCoord7 gl_FogCoord gl_PointCoord gl_Position gl_PointSize gl_ClipVertex gl_FrontColor gl_BackColor gl_FrontSecondaryColor gl_BackSecondaryColor gl_TexCoord gl_FogFragCoord gl_FragCoord gl_FrontFacing gl_FragData gl_FragDepth gl_ModelViewMatrix gl_ProjectionMatrix gl_ModelViewProjectionMatrix gl_TextureMatrix gl_NormalMatrix gl_ModelViewMatrixInverse gl_ProjectionMatrixInverse gl_ModelViewProjectionMatrixInverse gl_TexureMatrixTranspose gl_ModelViewMatrixInverseTranspose gl_ProjectionMatrixInverseTranspose gl_ModelViewProjectionMatrixInverseTranspose gl_TextureMatrixInverseTranspose gl_NormalScale gl_DepthRange gl_ClipPlane gl_Point gl_FrontMaterial gl_BackMaterial gl_LightSource gl_LightModel gl_FrontLightModelProduct gl_BackLightModelProduct gl_TextureColor gl_EyePlaneS gl_EyePlaneT gl_EyePlaneR gl_EyePlaneQ gl_FogParameters gl_MaxLights gl_MaxClipPlanes gl_MaxTextureUnits gl_MaxTextureCoords gl_MaxVertexAttribs gl_MaxVertexUniformComponents gl_MaxVaryingFloats gl_MaxVertexTextureImageUnits gl_MaxTextureImageUnits gl_MaxFragmentUniformComponents gl_MaxCombineTextureImageUnits gl_MaxDrawBuffers"),indentSwitch:!1,hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-nesc",{name:"clike",keywords:i(b+"as atomic async call command component components configuration event generic implementation includes interface module new norace nx_struct nx_union post provides signal task uses abstract extends"),types:i(k),blockKeywords:i("case do else for if switch while struct"),atoms:i("null true false"),hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-objectivec",{name:"clike",keywords:i(b+"inline restrict _Bool _Complex _Imaginary BOOL Class bycopy byref id IMP in inout nil oneway out Protocol SEL self super atomic nonatomic retain copy readwrite readonly"),types:i(k),atoms:i("YES NO NULL NILL ON OFF true false"),hooks:{"@":function(e){return e.eatWhile(/[\w\$]/),"keyword"},"#":s,indent:function(e,t,n){if("statement"==t.type&&/^@\w/.test(n))return t.indented}},modeProps:{fold:"brace"}}),h("text/x-squirrel",{name:"clike",keywords:i("base break clone continue const default delete enum extends function in class foreach local resume return this throw typeof yield constructor instanceof static"),types:i(k),blockKeywords:i("case catch class else for foreach if switch try while"),defKeywords:i("function local class"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"#":s},modeProps:{fold:["brace","include"]}});var w=null;h("text/x-ceylon",{name:"clike",keywords:i("abstracts alias assembly assert assign break case catch class continue dynamic else exists extends finally for function given if import in interface is let module new nonempty object of out outer package return satisfies super switch then this throw try value void while"),types:function(e){var t=e.charAt(0);return t===t.toUpperCase()&&t!==t.toLowerCase()},blockKeywords:i("case catch class dynamic else finally for function if interface module new object switch try while"),defKeywords:i("class dynamic function interface module object package value"),builtin:i("abstract actual aliased annotation by default deprecated doc final formal late license native optional sealed see serializable shared suppressWarnings tagged throws variable"),isPunctuationChar:/[\[\]{}\(\),;\:\.`]/,isOperatorChar:/[+\-*&%=<>!?|^~:\/]/,numberStart:/[\d#$]/,number:/^(?:#[\da-fA-F_]+|\$[01_]+|[\d_]+[kMGTPmunpf]?|[\d_]+\.[\d_]+(?:[eE][-+]?\d+|[kMGTPmunpf]|)|)/i,multiLineStrings:!0,typeFirstDefinitions:!0,atoms:i("true false null larger smaller equal empty finished"),indentSwitch:!1,styleDefs:!1,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return t.tokenize=x(e.match('""')?"triple":"single"),t.tokenize(e,t)},"`":function(e,t){return!(!w||!e.match("`"))&&(t.tokenize=w,w=null,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},token:function(e,t,n){if(("variable"==n||"type"==n)&&"."==t.prevToken)return"variable-2"}},modeProps:{fold:["brace","import"],closeBrackets:{triples:'"'}}})});
      // -------------------------------------------------------------------------
//  Part of the CodeChecker project, under the Apache License v2.0 with
//  LLVM Exceptions. See LICENSE for license information.
//  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
// -------------------------------------------------------------------------

var BugViewer = {
  _files : [],
  _reports : [],
  _lineWidgets : [],
  _navigationMenuItems : [],
  _sourceFileData : null,
  _currentReport : null,
  _lastBugEvent  : null,

  init : function (files, reports) {
    this._files = files;
    this._reports = reports;

    this.initEscapeChars();
  },

  initEscapeChars : function () {
    this.escapeChars = {
      ' ' : 'nbsp',
      '<' : 'lt',
      '>' : 'gt',
      '"' : 'quot',
      '&' : 'amp'
    };

    var regexString = '[';
    for (var key in this.escapeChars) {
      regexString += key;
    }
    regexString += ']';

    this.escapeRegExp = new RegExp( regexString, 'g');
  },

  escapeHTML : function (str) {
    var that = this;

    return str.replace(this.escapeRegExp, function (m) {
      return '&' + that.escapeChars[m] + ';';
    });
  },

  initByUrl : function () {
    if (!this._reports) return;

    var state = {};
    window.location.hash.substr(1).split('&').forEach(function (s) {
      var parts = s.split('=');
      state[parts[0]] = parts[1];
    });

    for (var key in this._reports) {
      var report = this._reports[key];
      if (report.reportHash === state['reportHash']) {
        this.navigate(report);
        return;
      }
    }

    this.navigate(this._reports[0]);
  },

  create : function () {
    this._content = document.getElementById('editor-wrapper');
    this._filepath = document.getElementById('file-path');
    this._checkerName = document.getElementById('checker-name');
    this._reviewStatusWrapper =
      document.getElementById('review-status-wrapper');
    this._reviewStatus = document.getElementById('review-status');
    this._editor = document.getElementById('editor');

    this._codeMirror = CodeMirror(this._editor, {
      mode: 'text/x-c++src',
      matchBrackets : true,
      lineNumbers : true,
      readOnly : true,
      foldGutter : true,
      extraKeys : {},
      viewportMargin : 100
    });

    this._createNavigationMenu();
  },

  navigate : function (report, item) {
    if (!item) {
      var items = this._navigationMenuItems.filter(function (navItem) {
        return navItem.report.reportHash === report.reportHash;
      });

      if (!items.length) return;

      item = items[0].widget;
    }

    this._selectedReport.classList.remove('active');
    this._selectedReport = item;
    this._selectedReport.classList.add('active');
    this.setReport(report);
  },

  _createNavigationMenu : function () {
    var that = this;

    var nav = document.getElementById('report-nav');
    var list = document.createElement('ul');
    this._reports.forEach(function (report) {
      var events = report['events'];
      var lastBugEvent = events[events.length - 1];
      var item = document.createElement('li');

      var severity = document.createElement('i');
      severity.className = 'severity-' + report.severity.toLowerCase();

      item.appendChild(severity);
      item.appendChild(document.createTextNode(lastBugEvent.message));

      item.addEventListener('click', function () {
        that.navigate(report, item);
      })
      list.appendChild(item);
      that._navigationMenuItems.push({ report : report, widget : item });
    });

    if (!this._selectedReport && list.childNodes.length) {
      this._selectedReport = list.childNodes[0];
      this._selectedReport.classList.add('active');
    }

    nav.appendChild(list);
  },

  setReport : function (report) {
    this._currentReport = report;
    var events = report['events'];
    var lastBugEvent = events[events.length - 1];
    this.setCurrentBugEvent(lastBugEvent, events.length - 1);
    this.setCheckerName(report.checkerName);
    this.setReviewStatus(report.reviewStatus);

    window.location.hash = '#reportHash=' + report.reportHash;
  },

  setCurrentBugEvent : function (event, idx) {
    this._currentBugEvent = event;
    this.setSourceFileData(this._files[event.location.file]);
    this.drawBugPath();

    this.jumpTo(event.location.line, 0);
    this.highlightBugEvent(event, idx);
  },

  highlightBugEvent : function (event, idx) {
    this._lineWidgets.forEach(function (widget) {
      var lineIdx = widget.node.getAttribute('idx');
      if (parseInt(lineIdx) === idx) {
        widget.node.classList.add('current');
      }
    });
  },

  setCheckerName : function (checkerName) {
    this._checkerName.innerHTML = checkerName;
  },

  setReviewStatus : function (status) {
    if (status) {
      var className =
        'review-status-' + status.toLowerCase().split(' ').join('-');
      this._reviewStatus.className = "review-status " + className;

      this._reviewStatus.innerHTML = status;
      this._reviewStatusWrapper.style.display = 'block';
    } else {
      this._reviewStatusWrapper.style.display = 'none';
    }
  },

  setSourceFileData : function (file) {
    if (this._sourceFileData && file.id === this._sourceFileData.id) {
      return;
    }

    this._sourceFileData = file;
    this._filepath.innerHTML = file.path;
    this._codeMirror.doc.setValue(file.content);
    this._refresh();
  },

  _refresh : function () {
    var that = this;
    setTimeout(function () {
      var fullHeight = parseInt(that._content.clientHeight);
      var headerHeight = that._filepath.clientHeight;

      that._codeMirror.setSize('auto', fullHeight - headerHeight);
      that._codeMirror.refresh();
    }, 200);
  },

  clearBubbles : function () {
    this._lineWidgets.forEach(function (widget) { widget.clear(); });
    this._lineWidgets = [];
  },

  getMessage : function (event, kind) {
    if (kind === 'macro') {
      var name = 'macro expansion' + (event.name ? ': ' + event.name : '');

      return '<span class="tag macro">' + name + '</span>'
        + this.escapeHTML(event.expansion).replace(/(?:\r\n|\r|\n)/g, '<br>');
    } else if (kind === 'note') {
      return '<span class="tag note">note</span>'
        +  this.escapeHTML(event.message).replace(/(?:\r\n|\r|\n)/g, '<br>');
    }
  },

  addExtraPathEvents : function (events, kind) {
    var that = this;

    if (!events) {
      return;
    }

    events.forEach(function (event) {
      if (event.location.file !== that._currentBugEvent.location.file) {
        return;
      }

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + kind);

      var msg = document.createElement('span');
      msg.innerHTML = that.getMessage(event, kind);
      element.appendChild(msg);

      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  drawBugPath : function () {
    var that = this;

    this.clearBubbles();

    this.addExtraPathEvents(this._currentReport.macros, 'macro');
    this.addExtraPathEvents(this._currentReport.notes, 'note');

    // Processing bug path events.
    var currentEvents = this._currentReport.events;
    currentEvents.forEach(function (event, step) {
      if (event.location.file !== that._currentBugEvent.location.file)
        return;

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';
      var type = step === currentEvents.length - 1 ? 'error' : 'info';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + type);
      element.setAttribute('idx', step);

      var enumeration = document.createElement('span');
      enumeration.setAttribute('class', 'checker-enum ' + type);
      enumeration.innerHTML = step + 1;

      if (currentEvents.length > 1)
        element.appendChild(enumeration);

      var prevBugEvent = step - 1;
      if (step > 0) {
        var prevBug = document.createElement('span');
        prevBug.setAttribute('class', 'arrow left-arrow');
        prevBug.addEventListener('click', function () {
          var event = currentEvents[prevBugEvent];
          that.setCurrentBugEvent(event, prevBugEvent);
        });
        element.appendChild(prevBug);
      }

      var msg = document.createElement('span');
      msg.innerHTML = that.escapeHTML(event.message)
        .replace(/(?:\r\n|\r|\n)/g, '<br>');

      element.appendChild(msg);

      var nextBugEvent = step + 1;
      if (nextBugEvent < currentEvents.length) {
        var nextBug = document.createElement('span');
        nextBug.setAttribute('class', 'arrow right-arrow');
        nextBug.addEventListener('click', function () {
          var event = currentEvents[nextBugEvent];
          that.setCurrentBugEvent(event, nextBugEvent);
        });
        element.appendChild(nextBug);
      }


      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  jumpTo : function (line, column) {
    var that = this;

    setTimeout(function () {
      var selPosPixel
        = that._codeMirror.charCoords({ line : line, ch : column }, 'local');
      var editorSize = {
        width  : that._editor.clientWidth,
        height : that._editor.clientHeight
      };

      that._codeMirror.scrollIntoView({
        top    : selPosPixel.top - 100,
        bottom : selPosPixel.top + editorSize.height - 150,
        left   : selPosPixel.left < editorSize.width - 100
               ? 0
               : selPosPixel.left - 50,
        right  : selPosPixel.left < editorSize.width - 100
               ? 10
               : selPosPixel.left + editorSize.width - 100
      });
    }, 0);
  }
}


      var data = {"files": {"4": {"id": 4, "path": "/home/vsts/work/1/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineAndOrXor.cpp", "content": "//===- InstCombineAndOrXor.cpp --------------------------------------------===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file implements the visitAnd, visitOr, and visitXor functions.\n//\n//===----------------------------------------------------------------------===//\n\n#include \"InstCombineInternal.h\"\n#include \"llvm/Analysis/CmpInstAnalysis.h\"\n#include \"llvm/Analysis/InstructionSimplify.h\"\n#include \"llvm/IR/ConstantRange.h\"\n#include \"llvm/IR/Intrinsics.h\"\n#include \"llvm/IR/PatternMatch.h\"\n#include \"llvm/Transforms/InstCombine/InstCombiner.h\"\n#include \"llvm/Transforms/Utils/Local.h\"\n\nusing namespace llvm;\nusing namespace PatternMatch;\n\n#define DEBUG_TYPE \"instcombine\"\n\n/// Similar to getICmpCode but for FCmpInst. This encodes a fcmp predicate into\n/// a four bit mask.\nstatic unsigned getFCmpCode(FCmpInst::Predicate CC) {\n  assert(FCmpInst::FCMP_FALSE <= CC && CC <= FCmpInst::FCMP_TRUE &&\n         \"Unexpected FCmp predicate!\");\n  // Take advantage of the bit pattern of FCmpInst::Predicate here.\n  //                                                 U L G E\n  static_assert(FCmpInst::FCMP_FALSE ==  0, \"\");  // 0 0 0 0\n  static_assert(FCmpInst::FCMP_OEQ   ==  1, \"\");  // 0 0 0 1\n  static_assert(FCmpInst::FCMP_OGT   ==  2, \"\");  // 0 0 1 0\n  static_assert(FCmpInst::FCMP_OGE   ==  3, \"\");  // 0 0 1 1\n  static_assert(FCmpInst::FCMP_OLT   ==  4, \"\");  // 0 1 0 0\n  static_assert(FCmpInst::FCMP_OLE   ==  5, \"\");  // 0 1 0 1\n  static_assert(FCmpInst::FCMP_ONE   ==  6, \"\");  // 0 1 1 0\n  static_assert(FCmpInst::FCMP_ORD   ==  7, \"\");  // 0 1 1 1\n  static_assert(FCmpInst::FCMP_UNO   ==  8, \"\");  // 1 0 0 0\n  static_assert(FCmpInst::FCMP_UEQ   ==  9, \"\");  // 1 0 0 1\n  static_assert(FCmpInst::FCMP_UGT   == 10, \"\");  // 1 0 1 0\n  static_assert(FCmpInst::FCMP_UGE   == 11, \"\");  // 1 0 1 1\n  static_assert(FCmpInst::FCMP_ULT   == 12, \"\");  // 1 1 0 0\n  static_assert(FCmpInst::FCMP_ULE   == 13, \"\");  // 1 1 0 1\n  static_assert(FCmpInst::FCMP_UNE   == 14, \"\");  // 1 1 1 0\n  static_assert(FCmpInst::FCMP_TRUE  == 15, \"\");  // 1 1 1 1\n  return CC;\n}\n\n/// This is the complement of getICmpCode, which turns an opcode and two\n/// operands into either a constant true or false, or a brand new ICmp\n/// instruction. The sign is passed in to determine which kind of predicate to\n/// use in the new icmp instruction.\nstatic Value *getNewICmpValue(unsigned Code, bool Sign, Value *LHS, Value *RHS,\n                              InstCombiner::BuilderTy &Builder) {\n  ICmpInst::Predicate NewPred;\n  if (Constant *TorF = getPredForICmpCode(Code, Sign, LHS->getType(), NewPred))\n    return TorF;\n  return Builder.CreateICmp(NewPred, LHS, RHS);\n}\n\n/// This is the complement of getFCmpCode, which turns an opcode and two\n/// operands into either a FCmp instruction, or a true/false constant.\nstatic Value *getFCmpValue(unsigned Code, Value *LHS, Value *RHS,\n                           InstCombiner::BuilderTy &Builder) {\n  const auto Pred = static_cast<FCmpInst::Predicate>(Code);\n  assert(FCmpInst::FCMP_FALSE <= Pred && Pred <= FCmpInst::FCMP_TRUE &&\n         \"Unexpected FCmp predicate!\");\n  if (Pred == FCmpInst::FCMP_FALSE)\n    return ConstantInt::get(CmpInst::makeCmpResultType(LHS->getType()), 0);\n  if (Pred == FCmpInst::FCMP_TRUE)\n    return ConstantInt::get(CmpInst::makeCmpResultType(LHS->getType()), 1);\n  return Builder.CreateFCmp(Pred, LHS, RHS);\n}\n\n/// Transform BITWISE_OP(BSWAP(A),BSWAP(B)) or\n/// BITWISE_OP(BSWAP(A), Constant) to BSWAP(BITWISE_OP(A, B))\n/// \\param I Binary operator to transform.\n/// \\return Pointer to node that must replace the original binary operator, or\n///         null pointer if no transformation was made.\nstatic Value *SimplifyBSwap(BinaryOperator &I,\n                            InstCombiner::BuilderTy &Builder) {\n  assert(I.isBitwiseLogicOp() && \"Unexpected opcode for bswap simplifying\");\n\n  Value *OldLHS = I.getOperand(0);\n  Value *OldRHS = I.getOperand(1);\n\n  Value *NewLHS;\n  if (!match(OldLHS, m_BSwap(m_Value(NewLHS))))\n    return nullptr;\n\n  Value *NewRHS;\n  const APInt *C;\n\n  if (match(OldRHS, m_BSwap(m_Value(NewRHS)))) {\n    // OP( BSWAP(x), BSWAP(y) ) -> BSWAP( OP(x, y) )\n    if (!OldLHS->hasOneUse() && !OldRHS->hasOneUse())\n      return nullptr;\n    // NewRHS initialized by the matcher.\n  } else if (match(OldRHS, m_APInt(C))) {\n    // OP( BSWAP(x), CONSTANT ) -> BSWAP( OP(x, BSWAP(CONSTANT) ) )\n    if (!OldLHS->hasOneUse())\n      return nullptr;\n    NewRHS = ConstantInt::get(I.getType(), C->byteSwap());\n  } else\n    return nullptr;\n\n  Value *BinOp = Builder.CreateBinOp(I.getOpcode(), NewLHS, NewRHS);\n  Function *F = Intrinsic::getDeclaration(I.getModule(), Intrinsic::bswap,\n                                          I.getType());\n  return Builder.CreateCall(F, BinOp);\n}\n\n/// Emit a computation of: (V >= Lo && V < Hi) if Inside is true, otherwise\n/// (V < Lo || V >= Hi). This method expects that Lo < Hi. IsSigned indicates\n/// whether to treat V, Lo, and Hi as signed or not.\nValue *InstCombinerImpl::insertRangeTest(Value *V, const APInt &Lo,\n                                         const APInt &Hi, bool isSigned,\n                                         bool Inside) {\n  assert((isSigned ? Lo.slt(Hi) : Lo.ult(Hi)) &&\n         \"Lo is not < Hi in range emission code!\");\n\n  Type *Ty = V->getType();\n\n  // V >= Min && V <  Hi --> V <  Hi\n  // V <  Min || V >= Hi --> V >= Hi\n  ICmpInst::Predicate Pred = Inside ? ICmpInst::ICMP_ULT : ICmpInst::ICMP_UGE;\n  if (isSigned ? Lo.isMinSignedValue() : Lo.isMinValue()) {\n    Pred = isSigned ? ICmpInst::getSignedPredicate(Pred) : Pred;\n    return Builder.CreateICmp(Pred, V, ConstantInt::get(Ty, Hi));\n  }\n\n  // V >= Lo && V <  Hi --> V - Lo u<  Hi - Lo\n  // V <  Lo || V >= Hi --> V - Lo u>= Hi - Lo\n  Value *VMinusLo =\n      Builder.CreateSub(V, ConstantInt::get(Ty, Lo), V->getName() + \".off\");\n  Constant *HiMinusLo = ConstantInt::get(Ty, Hi - Lo);\n  return Builder.CreateICmp(Pred, VMinusLo, HiMinusLo);\n}\n\n/// Classify (icmp eq (A & B), C) and (icmp ne (A & B), C) as matching patterns\n/// that can be simplified.\n/// One of A and B is considered the mask. The other is the value. This is\n/// described as the \"AMask\" or \"BMask\" part of the enum. If the enum contains\n/// only \"Mask\", then both A and B can be considered masks. If A is the mask,\n/// then it was proven that (A & C) == C. This is trivial if C == A or C == 0.\n/// If both A and C are constants, this proof is also easy.\n/// For the following explanations, we assume that A is the mask.\n///\n/// \"AllOnes\" declares that the comparison is true only if (A & B) == A or all\n/// bits of A are set in B.\n///   Example: (icmp eq (A & 3), 3) -> AMask_AllOnes\n///\n/// \"AllZeros\" declares that the comparison is true only if (A & B) == 0 or all\n/// bits of A are cleared in B.\n///   Example: (icmp eq (A & 3), 0) -> Mask_AllZeroes\n///\n/// \"Mixed\" declares that (A & B) == C and C might or might not contain any\n/// number of one bits and zero bits.\n///   Example: (icmp eq (A & 3), 1) -> AMask_Mixed\n///\n/// \"Not\" means that in above descriptions \"==\" should be replaced by \"!=\".\n///   Example: (icmp ne (A & 3), 3) -> AMask_NotAllOnes\n///\n/// If the mask A contains a single bit, then the following is equivalent:\n///    (icmp eq (A & B), A) equals (icmp ne (A & B), 0)\n///    (icmp ne (A & B), A) equals (icmp eq (A & B), 0)\nenum MaskedICmpType {\n  AMask_AllOnes           =     1,\n  AMask_NotAllOnes        =     2,\n  BMask_AllOnes           =     4,\n  BMask_NotAllOnes        =     8,\n  Mask_AllZeros           =    16,\n  Mask_NotAllZeros        =    32,\n  AMask_Mixed             =    64,\n  AMask_NotMixed          =   128,\n  BMask_Mixed             =   256,\n  BMask_NotMixed          =   512\n};\n\n/// Return the set of patterns (from MaskedICmpType) that (icmp SCC (A & B), C)\n/// satisfies.\nstatic unsigned getMaskedICmpType(Value *A, Value *B, Value *C,\n                                  ICmpInst::Predicate Pred) {\n  ConstantInt *ACst = dyn_cast<ConstantInt>(A);\n  ConstantInt *BCst = dyn_cast<ConstantInt>(B);\n  ConstantInt *CCst = dyn_cast<ConstantInt>(C);\n  bool IsEq = (Pred == ICmpInst::ICMP_EQ);\n  bool IsAPow2 = (ACst && !ACst->isZero() && ACst->getValue().isPowerOf2());\n  bool IsBPow2 = (BCst && !BCst->isZero() && BCst->getValue().isPowerOf2());\n  unsigned MaskVal = 0;\n  if (CCst && CCst->isZero()) {\n    // if C is zero, then both A and B qualify as mask\n    MaskVal |= (IsEq ? (Mask_AllZeros | AMask_Mixed | BMask_Mixed)\n                     : (Mask_NotAllZeros | AMask_NotMixed | BMask_NotMixed));\n    if (IsAPow2)\n      MaskVal |= (IsEq ? (AMask_NotAllOnes | AMask_NotMixed)\n                       : (AMask_AllOnes | AMask_Mixed));\n    if (IsBPow2)\n      MaskVal |= (IsEq ? (BMask_NotAllOnes | BMask_NotMixed)\n                       : (BMask_AllOnes | BMask_Mixed));\n    return MaskVal;\n  }\n\n  if (A == C) {\n    MaskVal |= (IsEq ? (AMask_AllOnes | AMask_Mixed)\n                     : (AMask_NotAllOnes | AMask_NotMixed));\n    if (IsAPow2)\n      MaskVal |= (IsEq ? (Mask_NotAllZeros | AMask_NotMixed)\n                       : (Mask_AllZeros | AMask_Mixed));\n  } else if (ACst && CCst && ConstantExpr::getAnd(ACst, CCst) == CCst) {\n    MaskVal |= (IsEq ? AMask_Mixed : AMask_NotMixed);\n  }\n\n  if (B == C) {\n    MaskVal |= (IsEq ? (BMask_AllOnes | BMask_Mixed)\n                     : (BMask_NotAllOnes | BMask_NotMixed));\n    if (IsBPow2)\n      MaskVal |= (IsEq ? (Mask_NotAllZeros | BMask_NotMixed)\n                       : (Mask_AllZeros | BMask_Mixed));\n  } else if (BCst && CCst && ConstantExpr::getAnd(BCst, CCst) == CCst) {\n    MaskVal |= (IsEq ? BMask_Mixed : BMask_NotMixed);\n  }\n\n  return MaskVal;\n}\n\n/// Convert an analysis of a masked ICmp into its equivalent if all boolean\n/// operations had the opposite sense. Since each \"NotXXX\" flag (recording !=)\n/// is adjacent to the corresponding normal flag (recording ==), this just\n/// involves swapping those bits over.\nstatic unsigned conjugateICmpMask(unsigned Mask) {\n  unsigned NewMask;\n  NewMask = (Mask & (AMask_AllOnes | BMask_AllOnes | Mask_AllZeros |\n                     AMask_Mixed | BMask_Mixed))\n            << 1;\n\n  NewMask |= (Mask & (AMask_NotAllOnes | BMask_NotAllOnes | Mask_NotAllZeros |\n                      AMask_NotMixed | BMask_NotMixed))\n             >> 1;\n\n  return NewMask;\n}\n\n// Adapts the external decomposeBitTestICmp for local use.\nstatic bool decomposeBitTestICmp(Value *LHS, Value *RHS, CmpInst::Predicate &Pred,\n                                 Value *&X, Value *&Y, Value *&Z) {\n  APInt Mask;\n  if (!llvm::decomposeBitTestICmp(LHS, RHS, Pred, X, Mask))\n    return false;\n\n  Y = ConstantInt::get(X->getType(), Mask);\n  Z = ConstantInt::get(X->getType(), 0);\n  return true;\n}\n\n/// Handle (icmp(A & B) ==/!= C) &/| (icmp(A & D) ==/!= E).\n/// Return the pattern classes (from MaskedICmpType) for the left hand side and\n/// the right hand side as a pair.\n/// LHS and RHS are the left hand side and the right hand side ICmps and PredL\n/// and PredR are their predicates, respectively.\nstatic\nOptional<std::pair<unsigned, unsigned>>\ngetMaskedTypeForICmpPair(Value *&A, Value *&B, Value *&C,\n                         Value *&D, Value *&E, ICmpInst *LHS,\n                         ICmpInst *RHS,\n                         ICmpInst::Predicate &PredL,\n                         ICmpInst::Predicate &PredR) {\n  // vectors are not (yet?) supported. Don't support pointers either.\n  if (!LHS->getOperand(0)->getType()->isIntegerTy() ||\n      !RHS->getOperand(0)->getType()->isIntegerTy())\n    return None;\n\n  // Here comes the tricky part:\n  // LHS might be of the form L11 & L12 == X, X == L21 & L22,\n  // and L11 & L12 == L21 & L22. The same goes for RHS.\n  // Now we must find those components L** and R**, that are equal, so\n  // that we can extract the parameters A, B, C, D, and E for the canonical\n  // above.\n  Value *L1 = LHS->getOperand(0);\n  Value *L2 = LHS->getOperand(1);\n  Value *L11, *L12, *L21, *L22;\n  // Check whether the icmp can be decomposed into a bit test.\n  if (decomposeBitTestICmp(L1, L2, PredL, L11, L12, L2)) {\n    L21 = L22 = L1 = nullptr;\n  } else {\n    // Look for ANDs in the LHS icmp.\n    if (!match(L1, m_And(m_Value(L11), m_Value(L12)))) {\n      // Any icmp can be viewed as being trivially masked; if it allows us to\n      // remove one, it's worth it.\n      L11 = L1;\n      L12 = Constant::getAllOnesValue(L1->getType());\n    }\n\n    if (!match(L2, m_And(m_Value(L21), m_Value(L22)))) {\n      L21 = L2;\n      L22 = Constant::getAllOnesValue(L2->getType());\n    }\n  }\n\n  // Bail if LHS was a icmp that can't be decomposed into an equality.\n  if (!ICmpInst::isEquality(PredL))\n    return None;\n\n  Value *R1 = RHS->getOperand(0);\n  Value *R2 = RHS->getOperand(1);\n  Value *R11, *R12;\n  bool Ok = false;\n  if (decomposeBitTestICmp(R1, R2, PredR, R11, R12, R2)) {\n    if (R11 == L11 || R11 == L12 || R11 == L21 || R11 == L22) {\n      A = R11;\n      D = R12;\n    } else if (R12 == L11 || R12 == L12 || R12 == L21 || R12 == L22) {\n      A = R12;\n      D = R11;\n    } else {\n      return None;\n    }\n    E = R2;\n    R1 = nullptr;\n    Ok = true;\n  } else {\n    if (!match(R1, m_And(m_Value(R11), m_Value(R12)))) {\n      // As before, model no mask as a trivial mask if it'll let us do an\n      // optimization.\n      R11 = R1;\n      R12 = Constant::getAllOnesValue(R1->getType());\n    }\n\n    if (R11 == L11 || R11 == L12 || R11 == L21 || R11 == L22) {\n      A = R11;\n      D = R12;\n      E = R2;\n      Ok = true;\n    } else if (R12 == L11 || R12 == L12 || R12 == L21 || R12 == L22) {\n      A = R12;\n      D = R11;\n      E = R2;\n      Ok = true;\n    }\n  }\n\n  // Bail if RHS was a icmp that can't be decomposed into an equality.\n  if (!ICmpInst::isEquality(PredR))\n    return None;\n\n  // Look for ANDs on the right side of the RHS icmp.\n  if (!Ok) {\n    if (!match(R2, m_And(m_Value(R11), m_Value(R12)))) {\n      R11 = R2;\n      R12 = Constant::getAllOnesValue(R2->getType());\n    }\n\n    if (R11 == L11 || R11 == L12 || R11 == L21 || R11 == L22) {\n      A = R11;\n      D = R12;\n      E = R1;\n      Ok = true;\n    } else if (R12 == L11 || R12 == L12 || R12 == L21 || R12 == L22) {\n      A = R12;\n      D = R11;\n      E = R1;\n      Ok = true;\n    } else {\n      return None;\n    }\n  }\n  if (!Ok)\n    return None;\n\n  if (L11 == A) {\n    B = L12;\n    C = L2;\n  } else if (L12 == A) {\n    B = L11;\n    C = L2;\n  } else if (L21 == A) {\n    B = L22;\n    C = L1;\n  } else if (L22 == A) {\n    B = L21;\n    C = L1;\n  }\n\n  unsigned LeftType = getMaskedICmpType(A, B, C, PredL);\n  unsigned RightType = getMaskedICmpType(A, D, E, PredR);\n  return Optional<std::pair<unsigned, unsigned>>(std::make_pair(LeftType, RightType));\n}\n\n/// Try to fold (icmp(A & B) ==/!= C) &/| (icmp(A & D) ==/!= E) into a single\n/// (icmp(A & X) ==/!= Y), where the left-hand side is of type Mask_NotAllZeros\n/// and the right hand side is of type BMask_Mixed. For example,\n/// (icmp (A & 12) != 0) & (icmp (A & 15) == 8) -> (icmp (A & 15) == 8).\nstatic Value *foldLogOpOfMaskedICmps_NotAllZeros_BMask_Mixed(\n    ICmpInst *LHS, ICmpInst *RHS, bool IsAnd, Value *A, Value *B, Value *C,\n    Value *D, Value *E, ICmpInst::Predicate PredL, ICmpInst::Predicate PredR,\n    InstCombiner::BuilderTy &Builder) {\n  // We are given the canonical form:\n  //   (icmp ne (A & B), 0) & (icmp eq (A & D), E).\n  // where D & E == E.\n  //\n  // If IsAnd is false, we get it in negated form:\n  //   (icmp eq (A & B), 0) | (icmp ne (A & D), E) ->\n  //      !((icmp ne (A & B), 0) & (icmp eq (A & D), E)).\n  //\n  // We currently handle the case of B, C, D, E are constant.\n  //\n  ConstantInt *BCst, *CCst, *DCst, *ECst;\n  if (!match(B, m_ConstantInt(BCst)) || !match(C, m_ConstantInt(CCst)) ||\n      !match(D, m_ConstantInt(DCst)) || !match(E, m_ConstantInt(ECst)))\n    return nullptr;\n\n  ICmpInst::Predicate NewCC = IsAnd ? ICmpInst::ICMP_EQ : ICmpInst::ICMP_NE;\n\n  // Update E to the canonical form when D is a power of two and RHS is\n  // canonicalized as,\n  // (icmp ne (A & D), 0) -> (icmp eq (A & D), D) or\n  // (icmp ne (A & D), D) -> (icmp eq (A & D), 0).\n  if (PredR != NewCC)\n    ECst = cast<ConstantInt>(ConstantExpr::getXor(DCst, ECst));\n\n  // If B or D is zero, skip because if LHS or RHS can be trivially folded by\n  // other folding rules and this pattern won't apply any more.\n  if (BCst->getValue() == 0 || DCst->getValue() == 0)\n    return nullptr;\n\n  // If B and D don't intersect, ie. (B & D) == 0, no folding because we can't\n  // deduce anything from it.\n  // For example,\n  // (icmp ne (A & 12), 0) & (icmp eq (A & 3), 1) -> no folding.\n  if ((BCst->getValue() & DCst->getValue()) == 0)\n    return nullptr;\n\n  // If the following two conditions are met:\n  //\n  // 1. mask B covers only a single bit that's not covered by mask D, that is,\n  // (B & (B ^ D)) is a power of 2 (in other words, B minus the intersection of\n  // B and D has only one bit set) and,\n  //\n  // 2. RHS (and E) indicates that the rest of B's bits are zero (in other\n  // words, the intersection of B and D is zero), that is, ((B & D) & E) == 0\n  //\n  // then that single bit in B must be one and thus the whole expression can be\n  // folded to\n  //   (A & (B | D)) == (B & (B ^ D)) | E.\n  //\n  // For example,\n  // (icmp ne (A & 12), 0) & (icmp eq (A & 7), 1) -> (icmp eq (A & 15), 9)\n  // (icmp ne (A & 15), 0) & (icmp eq (A & 7), 0) -> (icmp eq (A & 15), 8)\n  if ((((BCst->getValue() & DCst->getValue()) & ECst->getValue()) == 0) &&\n      (BCst->getValue() & (BCst->getValue() ^ DCst->getValue())).isPowerOf2()) {\n    APInt BorD = BCst->getValue() | DCst->getValue();\n    APInt BandBxorDorE = (BCst->getValue() & (BCst->getValue() ^ DCst->getValue())) |\n        ECst->getValue();\n    Value *NewMask = ConstantInt::get(BCst->getType(), BorD);\n    Value *NewMaskedValue = ConstantInt::get(BCst->getType(), BandBxorDorE);\n    Value *NewAnd = Builder.CreateAnd(A, NewMask);\n    return Builder.CreateICmp(NewCC, NewAnd, NewMaskedValue);\n  }\n\n  auto IsSubSetOrEqual = [](ConstantInt *C1, ConstantInt *C2) {\n    return (C1->getValue() & C2->getValue()) == C1->getValue();\n  };\n  auto IsSuperSetOrEqual = [](ConstantInt *C1, ConstantInt *C2) {\n    return (C1->getValue() & C2->getValue()) == C2->getValue();\n  };\n\n  // In the following, we consider only the cases where B is a superset of D, B\n  // is a subset of D, or B == D because otherwise there's at least one bit\n  // covered by B but not D, in which case we can't deduce much from it, so\n  // no folding (aside from the single must-be-one bit case right above.)\n  // For example,\n  // (icmp ne (A & 14), 0) & (icmp eq (A & 3), 1) -> no folding.\n  if (!IsSubSetOrEqual(BCst, DCst) && !IsSuperSetOrEqual(BCst, DCst))\n    return nullptr;\n\n  // At this point, either B is a superset of D, B is a subset of D or B == D.\n\n  // If E is zero, if B is a subset of (or equal to) D, LHS and RHS contradict\n  // and the whole expression becomes false (or true if negated), otherwise, no\n  // folding.\n  // For example,\n  // (icmp ne (A & 3), 0) & (icmp eq (A & 7), 0) -> false.\n  // (icmp ne (A & 15), 0) & (icmp eq (A & 3), 0) -> no folding.\n  if (ECst->isZero()) {\n    if (IsSubSetOrEqual(BCst, DCst))\n      return ConstantInt::get(LHS->getType(), !IsAnd);\n    return nullptr;\n  }\n\n  // At this point, B, D, E aren't zero and (B & D) == B, (B & D) == D or B ==\n  // D. If B is a superset of (or equal to) D, since E is not zero, LHS is\n  // subsumed by RHS (RHS implies LHS.) So the whole expression becomes\n  // RHS. For example,\n  // (icmp ne (A & 255), 0) & (icmp eq (A & 15), 8) -> (icmp eq (A & 15), 8).\n  // (icmp ne (A & 15), 0) & (icmp eq (A & 15), 8) -> (icmp eq (A & 15), 8).\n  if (IsSuperSetOrEqual(BCst, DCst))\n    return RHS;\n  // Otherwise, B is a subset of D. If B and E have a common bit set,\n  // ie. (B & E) != 0, then LHS is subsumed by RHS. For example.\n  // (icmp ne (A & 12), 0) & (icmp eq (A & 15), 8) -> (icmp eq (A & 15), 8).\n  assert(IsSubSetOrEqual(BCst, DCst) && \"Precondition due to above code\");\n  if ((BCst->getValue() & ECst->getValue()) != 0)\n    return RHS;\n  // Otherwise, LHS and RHS contradict and the whole expression becomes false\n  // (or true if negated.) For example,\n  // (icmp ne (A & 7), 0) & (icmp eq (A & 15), 8) -> false.\n  // (icmp ne (A & 6), 0) & (icmp eq (A & 15), 8) -> false.\n  return ConstantInt::get(LHS->getType(), !IsAnd);\n}\n\n/// Try to fold (icmp(A & B) ==/!= 0) &/| (icmp(A & D) ==/!= E) into a single\n/// (icmp(A & X) ==/!= Y), where the left-hand side and the right hand side\n/// aren't of the common mask pattern type.\nstatic Value *foldLogOpOfMaskedICmpsAsymmetric(\n    ICmpInst *LHS, ICmpInst *RHS, bool IsAnd, Value *A, Value *B, Value *C,\n    Value *D, Value *E, ICmpInst::Predicate PredL, ICmpInst::Predicate PredR,\n    unsigned LHSMask, unsigned RHSMask, InstCombiner::BuilderTy &Builder) {\n  assert(ICmpInst::isEquality(PredL) && ICmpInst::isEquality(PredR) &&\n         \"Expected equality predicates for masked type of icmps.\");\n  // Handle Mask_NotAllZeros-BMask_Mixed cases.\n  // (icmp ne/eq (A & B), C) &/| (icmp eq/ne (A & D), E), or\n  // (icmp eq/ne (A & B), C) &/| (icmp ne/eq (A & D), E)\n  //    which gets swapped to\n  //    (icmp ne/eq (A & D), E) &/| (icmp eq/ne (A & B), C).\n  if (!IsAnd) {\n    LHSMask = conjugateICmpMask(LHSMask);\n    RHSMask = conjugateICmpMask(RHSMask);\n  }\n  if ((LHSMask & Mask_NotAllZeros) && (RHSMask & BMask_Mixed)) {\n    if (Value *V = foldLogOpOfMaskedICmps_NotAllZeros_BMask_Mixed(\n            LHS, RHS, IsAnd, A, B, C, D, E,\n            PredL, PredR, Builder)) {\n      return V;\n    }\n  } else if ((LHSMask & BMask_Mixed) && (RHSMask & Mask_NotAllZeros)) {\n    if (Value *V = foldLogOpOfMaskedICmps_NotAllZeros_BMask_Mixed(\n            RHS, LHS, IsAnd, A, D, E, B, C,\n            PredR, PredL, Builder)) {\n      return V;\n    }\n  }\n  return nullptr;\n}\n\n/// Try to fold (icmp(A & B) ==/!= C) &/| (icmp(A & D) ==/!= E)\n/// into a single (icmp(A & X) ==/!= Y).\nstatic Value *foldLogOpOfMaskedICmps(ICmpInst *LHS, ICmpInst *RHS, bool IsAnd,\n                                     InstCombiner::BuilderTy &Builder) {\n  Value *A = nullptr, *B = nullptr, *C = nullptr, *D = nullptr, *E = nullptr;\n  ICmpInst::Predicate PredL = LHS->getPredicate(), PredR = RHS->getPredicate();\n  Optional<std::pair<unsigned, unsigned>> MaskPair =\n      getMaskedTypeForICmpPair(A, B, C, D, E, LHS, RHS, PredL, PredR);\n  if (!MaskPair)\n    return nullptr;\n  assert(ICmpInst::isEquality(PredL) && ICmpInst::isEquality(PredR) &&\n         \"Expected equality predicates for masked type of icmps.\");\n  unsigned LHSMask = MaskPair->first;\n  unsigned RHSMask = MaskPair->second;\n  unsigned Mask = LHSMask & RHSMask;\n  if (Mask == 0) {\n    // Even if the two sides don't share a common pattern, check if folding can\n    // still happen.\n    if (Value *V = foldLogOpOfMaskedICmpsAsymmetric(\n            LHS, RHS, IsAnd, A, B, C, D, E, PredL, PredR, LHSMask, RHSMask,\n            Builder))\n      return V;\n    return nullptr;\n  }\n\n  // In full generality:\n  //     (icmp (A & B) Op C) | (icmp (A & D) Op E)\n  // ==  ![ (icmp (A & B) !Op C) & (icmp (A & D) !Op E) ]\n  //\n  // If the latter can be converted into (icmp (A & X) Op Y) then the former is\n  // equivalent to (icmp (A & X) !Op Y).\n  //\n  // Therefore, we can pretend for the rest of this function that we're dealing\n  // with the conjunction, provided we flip the sense of any comparisons (both\n  // input and output).\n\n  // In most cases we're going to produce an EQ for the \"&&\" case.\n  ICmpInst::Predicate NewCC = IsAnd ? ICmpInst::ICMP_EQ : ICmpInst::ICMP_NE;\n  if (!IsAnd) {\n    // Convert the masking analysis into its equivalent with negated\n    // comparisons.\n    Mask = conjugateICmpMask(Mask);\n  }\n\n  if (Mask & Mask_AllZeros) {\n    // (icmp eq (A & B), 0) & (icmp eq (A & D), 0)\n    // -> (icmp eq (A & (B|D)), 0)\n    Value *NewOr = Builder.CreateOr(B, D);\n    Value *NewAnd = Builder.CreateAnd(A, NewOr);\n    // We can't use C as zero because we might actually handle\n    //   (icmp ne (A & B), B) & (icmp ne (A & D), D)\n    // with B and D, having a single bit set.\n    Value *Zero = Constant::getNullValue(A->getType());\n    return Builder.CreateICmp(NewCC, NewAnd, Zero);\n  }\n  if (Mask & BMask_AllOnes) {\n    // (icmp eq (A & B), B) & (icmp eq (A & D), D)\n    // -> (icmp eq (A & (B|D)), (B|D))\n    Value *NewOr = Builder.CreateOr(B, D);\n    Value *NewAnd = Builder.CreateAnd(A, NewOr);\n    return Builder.CreateICmp(NewCC, NewAnd, NewOr);\n  }\n  if (Mask & AMask_AllOnes) {\n    // (icmp eq (A & B), A) & (icmp eq (A & D), A)\n    // -> (icmp eq (A & (B&D)), A)\n    Value *NewAnd1 = Builder.CreateAnd(B, D);\n    Value *NewAnd2 = Builder.CreateAnd(A, NewAnd1);\n    return Builder.CreateICmp(NewCC, NewAnd2, A);\n  }\n\n  // Remaining cases assume at least that B and D are constant, and depend on\n  // their actual values. This isn't strictly necessary, just a \"handle the\n  // easy cases for now\" decision.\n  ConstantInt *BCst, *DCst;\n  if (!match(B, m_ConstantInt(BCst)) || !match(D, m_ConstantInt(DCst)))\n    return nullptr;\n\n  if (Mask & (Mask_NotAllZeros | BMask_NotAllOnes)) {\n    // (icmp ne (A & B), 0) & (icmp ne (A & D), 0) and\n    // (icmp ne (A & B), B) & (icmp ne (A & D), D)\n    //     -> (icmp ne (A & B), 0) or (icmp ne (A & D), 0)\n    // Only valid if one of the masks is a superset of the other (check \"B&D\" is\n    // the same as either B or D).\n    APInt NewMask = BCst->getValue() & DCst->getValue();\n\n    if (NewMask == BCst->getValue())\n      return LHS;\n    else if (NewMask == DCst->getValue())\n      return RHS;\n  }\n\n  if (Mask & AMask_NotAllOnes) {\n    // (icmp ne (A & B), B) & (icmp ne (A & D), D)\n    //     -> (icmp ne (A & B), A) or (icmp ne (A & D), A)\n    // Only valid if one of the masks is a superset of the other (check \"B|D\" is\n    // the same as either B or D).\n    APInt NewMask = BCst->getValue() | DCst->getValue();\n\n    if (NewMask == BCst->getValue())\n      return LHS;\n    else if (NewMask == DCst->getValue())\n      return RHS;\n  }\n\n  if (Mask & BMask_Mixed) {\n    // (icmp eq (A & B), C) & (icmp eq (A & D), E)\n    // We already know that B & C == C && D & E == E.\n    // If we can prove that (B & D) & (C ^ E) == 0, that is, the bits of\n    // C and E, which are shared by both the mask B and the mask D, don't\n    // contradict, then we can transform to\n    // -> (icmp eq (A & (B|D)), (C|E))\n    // Currently, we only handle the case of B, C, D, and E being constant.\n    // We can't simply use C and E because we might actually handle\n    //   (icmp ne (A & B), B) & (icmp eq (A & D), D)\n    // with B and D, having a single bit set.\n    ConstantInt *CCst, *ECst;\n    if (!match(C, m_ConstantInt(CCst)) || !match(E, m_ConstantInt(ECst)))\n      return nullptr;\n    if (PredL != NewCC)\n      CCst = cast<ConstantInt>(ConstantExpr::getXor(BCst, CCst));\n    if (PredR != NewCC)\n      ECst = cast<ConstantInt>(ConstantExpr::getXor(DCst, ECst));\n\n    // If there is a conflict, we should actually return a false for the\n    // whole construct.\n    if (((BCst->getValue() & DCst->getValue()) &\n         (CCst->getValue() ^ ECst->getValue())).getBoolValue())\n      return ConstantInt::get(LHS->getType(), !IsAnd);\n\n    Value *NewOr1 = Builder.CreateOr(B, D);\n    Value *NewOr2 = ConstantExpr::getOr(CCst, ECst);\n    Value *NewAnd = Builder.CreateAnd(A, NewOr1);\n    return Builder.CreateICmp(NewCC, NewAnd, NewOr2);\n  }\n\n  return nullptr;\n}\n\n/// Try to fold a signed range checked with lower bound 0 to an unsigned icmp.\n/// Example: (icmp sge x, 0) & (icmp slt x, n) --> icmp ult x, n\n/// If \\p Inverted is true then the check is for the inverted range, e.g.\n/// (icmp slt x, 0) | (icmp sgt x, n) --> icmp ugt x, n\nValue *InstCombinerImpl::simplifyRangeCheck(ICmpInst *Cmp0, ICmpInst *Cmp1,\n                                            bool Inverted) {\n  // Check the lower range comparison, e.g. x >= 0\n  // InstCombine already ensured that if there is a constant it's on the RHS.\n  ConstantInt *RangeStart = dyn_cast<ConstantInt>(Cmp0->getOperand(1));\n  if (!RangeStart)\n    return nullptr;\n\n  ICmpInst::Predicate Pred0 = (Inverted ? Cmp0->getInversePredicate() :\n                               Cmp0->getPredicate());\n\n  // Accept x > -1 or x >= 0 (after potentially inverting the predicate).\n  if (!((Pred0 == ICmpInst::ICMP_SGT && RangeStart->isMinusOne()) ||\n        (Pred0 == ICmpInst::ICMP_SGE && RangeStart->isZero())))\n    return nullptr;\n\n  ICmpInst::Predicate Pred1 = (Inverted ? Cmp1->getInversePredicate() :\n                               Cmp1->getPredicate());\n\n  Value *Input = Cmp0->getOperand(0);\n  Value *RangeEnd;\n  if (Cmp1->getOperand(0) == Input) {\n    // For the upper range compare we have: icmp x, n\n    RangeEnd = Cmp1->getOperand(1);\n  } else if (Cmp1->getOperand(1) == Input) {\n    // For the upper range compare we have: icmp n, x\n    RangeEnd = Cmp1->getOperand(0);\n    Pred1 = ICmpInst::getSwappedPredicate(Pred1);\n  } else {\n    return nullptr;\n  }\n\n  // Check the upper range comparison, e.g. x < n\n  ICmpInst::Predicate NewPred;\n  switch (Pred1) {\n    case ICmpInst::ICMP_SLT: NewPred = ICmpInst::ICMP_ULT; break;\n    case ICmpInst::ICMP_SLE: NewPred = ICmpInst::ICMP_ULE; break;\n    default: return nullptr;\n  }\n\n  // This simplification is only valid if the upper range is not negative.\n  KnownBits Known = computeKnownBits(RangeEnd, /*Depth=*/0, Cmp1);\n  if (!Known.isNonNegative())\n    return nullptr;\n\n  if (Inverted)\n    NewPred = ICmpInst::getInversePredicate(NewPred);\n\n  return Builder.CreateICmp(NewPred, Input, RangeEnd);\n}\n\nstatic Value *\nfoldAndOrOfEqualityCmpsWithConstants(ICmpInst *LHS, ICmpInst *RHS,\n                                     bool JoinedByAnd,\n                                     InstCombiner::BuilderTy &Builder) {\n  Value *X = LHS->getOperand(0);\n  if (X != RHS->getOperand(0))\n    return nullptr;\n\n  const APInt *C1, *C2;\n  if (!match(LHS->getOperand(1), m_APInt(C1)) ||\n      !match(RHS->getOperand(1), m_APInt(C2)))\n    return nullptr;\n\n  // We only handle (X != C1 && X != C2) and (X == C1 || X == C2).\n  ICmpInst::Predicate Pred = LHS->getPredicate();\n  if (Pred !=  RHS->getPredicate())\n    return nullptr;\n  if (JoinedByAnd && Pred != ICmpInst::ICMP_NE)\n    return nullptr;\n  if (!JoinedByAnd && Pred != ICmpInst::ICMP_EQ)\n    return nullptr;\n\n  // The larger unsigned constant goes on the right.\n  if (C1->ugt(*C2))\n    std::swap(C1, C2);\n\n  APInt Xor = *C1 ^ *C2;\n  if (Xor.isPowerOf2()) {\n    // If LHSC and RHSC differ by only one bit, then set that bit in X and\n    // compare against the larger constant:\n    // (X == C1 || X == C2) --> (X | (C1 ^ C2)) == C2\n    // (X != C1 && X != C2) --> (X | (C1 ^ C2)) != C2\n    // We choose an 'or' with a Pow2 constant rather than the inverse mask with\n    // 'and' because that may lead to smaller codegen from a smaller constant.\n    Value *Or = Builder.CreateOr(X, ConstantInt::get(X->getType(), Xor));\n    return Builder.CreateICmp(Pred, Or, ConstantInt::get(X->getType(), *C2));\n  }\n\n  // Special case: get the ordering right when the values wrap around zero.\n  // Ie, we assumed the constants were unsigned when swapping earlier.\n  if (C1->isNullValue() && C2->isAllOnesValue())\n    std::swap(C1, C2);\n\n  if (*C1 == *C2 - 1) {\n    // (X == 13 || X == 14) --> X - 13 <=u 1\n    // (X != 13 && X != 14) --> X - 13  >u 1\n    // An 'add' is the canonical IR form, so favor that over a 'sub'.\n    Value *Add = Builder.CreateAdd(X, ConstantInt::get(X->getType(), -(*C1)));\n    auto NewPred = JoinedByAnd ? ICmpInst::ICMP_UGT : ICmpInst::ICMP_ULE;\n    return Builder.CreateICmp(NewPred, Add, ConstantInt::get(X->getType(), 1));\n  }\n\n  return nullptr;\n}\n\n// Fold (iszero(A & K1) | iszero(A & K2)) -> (A & (K1 | K2)) != (K1 | K2)\n// Fold (!iszero(A & K1) & !iszero(A & K2)) -> (A & (K1 | K2)) == (K1 | K2)\nValue *InstCombinerImpl::foldAndOrOfICmpsOfAndWithPow2(ICmpInst *LHS,\n                                                       ICmpInst *RHS,\n                                                       BinaryOperator &Logic) {\n  bool JoinedByAnd = Logic.getOpcode() == Instruction::And;\n  assert((JoinedByAnd || Logic.getOpcode() == Instruction::Or) &&\n         \"Wrong opcode\");\n  ICmpInst::Predicate Pred = LHS->getPredicate();\n  if (Pred != RHS->getPredicate())\n    return nullptr;\n  if (JoinedByAnd && Pred != ICmpInst::ICMP_NE)\n    return nullptr;\n  if (!JoinedByAnd && Pred != ICmpInst::ICMP_EQ)\n    return nullptr;\n\n  if (!match(LHS->getOperand(1), m_Zero()) ||\n      !match(RHS->getOperand(1), m_Zero()))\n    return nullptr;\n\n  Value *A, *B, *C, *D;\n  if (match(LHS->getOperand(0), m_And(m_Value(A), m_Value(B))) &&\n      match(RHS->getOperand(0), m_And(m_Value(C), m_Value(D)))) {\n    if (A == D || B == D)\n      std::swap(C, D);\n    if (B == C)\n      std::swap(A, B);\n\n    if (A == C &&\n        isKnownToBeAPowerOfTwo(B, false, 0, &Logic) &&\n        isKnownToBeAPowerOfTwo(D, false, 0, &Logic)) {\n      Value *Mask = Builder.CreateOr(B, D);\n      Value *Masked = Builder.CreateAnd(A, Mask);\n      auto NewPred = JoinedByAnd ? ICmpInst::ICMP_EQ : ICmpInst::ICMP_NE;\n      return Builder.CreateICmp(NewPred, Masked, Mask);\n    }\n  }\n\n  return nullptr;\n}\n\n/// General pattern:\n///   X & Y\n///\n/// Where Y is checking that all the high bits (covered by a mask 4294967168)\n/// are uniform, i.e.  %arg & 4294967168  can be either  4294967168  or  0\n/// Pattern can be one of:\n///   %t = add        i32 %arg,    128\n///   %r = icmp   ult i32 %t,      256\n/// Or\n///   %t0 = shl       i32 %arg,    24\n///   %t1 = ashr      i32 %t0,     24\n///   %r  = icmp  eq  i32 %t1,     %arg\n/// Or\n///   %t0 = trunc     i32 %arg  to i8\n///   %t1 = sext      i8  %t0   to i32\n///   %r  = icmp  eq  i32 %t1,     %arg\n/// This pattern is a signed truncation check.\n///\n/// And X is checking that some bit in that same mask is zero.\n/// I.e. can be one of:\n///   %r = icmp sgt i32   %arg,    -1\n/// Or\n///   %t = and      i32   %arg,    2147483648\n///   %r = icmp eq  i32   %t,      0\n///\n/// Since we are checking that all the bits in that mask are the same,\n/// and a particular bit is zero, what we are really checking is that all the\n/// masked bits are zero.\n/// So this should be transformed to:\n///   %r = icmp ult i32 %arg, 128\nstatic Value *foldSignedTruncationCheck(ICmpInst *ICmp0, ICmpInst *ICmp1,\n                                        Instruction &CxtI,\n                                        InstCombiner::BuilderTy &Builder) {\n  assert(CxtI.getOpcode() == Instruction::And);\n\n  // Match  icmp ult (add %arg, C01), C1   (C1 == C01 << 1; powers of two)\n  auto tryToMatchSignedTruncationCheck = [](ICmpInst *ICmp, Value *&X,\n                                            APInt &SignBitMask) -> bool {\n    CmpInst::Predicate Pred;\n    const APInt *I01, *I1; // powers of two; I1 == I01 << 1\n    if (!(match(ICmp,\n                m_ICmp(Pred, m_Add(m_Value(X), m_Power2(I01)), m_Power2(I1))) &&\n          Pred == ICmpInst::ICMP_ULT && I1->ugt(*I01) && I01->shl(1) == *I1))\n      return false;\n    // Which bit is the new sign bit as per the 'signed truncation' pattern?\n    SignBitMask = *I01;\n    return true;\n  };\n\n  // One icmp needs to be 'signed truncation check'.\n  // We need to match this first, else we will mismatch commutative cases.\n  Value *X1;\n  APInt HighestBit;\n  ICmpInst *OtherICmp;\n  if (tryToMatchSignedTruncationCheck(ICmp1, X1, HighestBit))\n    OtherICmp = ICmp0;\n  else if (tryToMatchSignedTruncationCheck(ICmp0, X1, HighestBit))\n    OtherICmp = ICmp1;\n  else\n    return nullptr;\n\n  assert(HighestBit.isPowerOf2() && \"expected to be power of two (non-zero)\");\n\n  // Try to match/decompose into:  icmp eq (X & Mask), 0\n  auto tryToDecompose = [](ICmpInst *ICmp, Value *&X,\n                           APInt &UnsetBitsMask) -> bool {\n    CmpInst::Predicate Pred = ICmp->getPredicate();\n    // Can it be decomposed into  icmp eq (X & Mask), 0  ?\n    if (llvm::decomposeBitTestICmp(ICmp->getOperand(0), ICmp->getOperand(1),\n                                   Pred, X, UnsetBitsMask,\n                                   /*LookThroughTrunc=*/false) &&\n        Pred == ICmpInst::ICMP_EQ)\n      return true;\n    // Is it  icmp eq (X & Mask), 0  already?\n    const APInt *Mask;\n    if (match(ICmp, m_ICmp(Pred, m_And(m_Value(X), m_APInt(Mask)), m_Zero())) &&\n        Pred == ICmpInst::ICMP_EQ) {\n      UnsetBitsMask = *Mask;\n      return true;\n    }\n    return false;\n  };\n\n  // And the other icmp needs to be decomposable into a bit test.\n  Value *X0;\n  APInt UnsetBitsMask;\n  if (!tryToDecompose(OtherICmp, X0, UnsetBitsMask))\n    return nullptr;\n\n  assert(!UnsetBitsMask.isNullValue() && \"empty mask makes no sense.\");\n\n  // Are they working on the same value?\n  Value *X;\n  if (X1 == X0) {\n    // Ok as is.\n    X = X1;\n  } else if (match(X0, m_Trunc(m_Specific(X1)))) {\n    UnsetBitsMask = UnsetBitsMask.zext(X1->getType()->getScalarSizeInBits());\n    X = X1;\n  } else\n    return nullptr;\n\n  // So which bits should be uniform as per the 'signed truncation check'?\n  // (all the bits starting with (i.e. including) HighestBit)\n  APInt SignBitsMask = ~(HighestBit - 1U);\n\n  // UnsetBitsMask must have some common bits with SignBitsMask,\n  if (!UnsetBitsMask.intersects(SignBitsMask))\n    return nullptr;\n\n  // Does UnsetBitsMask contain any bits outside of SignBitsMask?\n  if (!UnsetBitsMask.isSubsetOf(SignBitsMask)) {\n    APInt OtherHighestBit = (~UnsetBitsMask) + 1U;\n    if (!OtherHighestBit.isPowerOf2())\n      return nullptr;\n    HighestBit = APIntOps::umin(HighestBit, OtherHighestBit);\n  }\n  // Else, if it does not, then all is ok as-is.\n\n  // %r = icmp ult %X, SignBit\n  return Builder.CreateICmpULT(X, ConstantInt::get(X->getType(), HighestBit),\n                               CxtI.getName() + \".simplified\");\n}\n\n/// Reduce a pair of compares that check if a value has exactly 1 bit set.\nstatic Value *foldIsPowerOf2(ICmpInst *Cmp0, ICmpInst *Cmp1, bool JoinedByAnd,\n                             InstCombiner::BuilderTy &Builder) {\n  // Handle 'and' / 'or' commutation: make the equality check the first operand.\n  if (JoinedByAnd && Cmp1->getPredicate() == ICmpInst::ICMP_NE)\n    std::swap(Cmp0, Cmp1);\n  else if (!JoinedByAnd && Cmp1->getPredicate() == ICmpInst::ICMP_EQ)\n    std::swap(Cmp0, Cmp1);\n\n  // (X != 0) && (ctpop(X) u< 2) --> ctpop(X) == 1\n  CmpInst::Predicate Pred0, Pred1;\n  Value *X;\n  if (JoinedByAnd && match(Cmp0, m_ICmp(Pred0, m_Value(X), m_ZeroInt())) &&\n      match(Cmp1, m_ICmp(Pred1, m_Intrinsic<Intrinsic::ctpop>(m_Specific(X)),\n                         m_SpecificInt(2))) &&\n      Pred0 == ICmpInst::ICMP_NE && Pred1 == ICmpInst::ICMP_ULT) {\n    Value *CtPop = Cmp1->getOperand(0);\n    return Builder.CreateICmpEQ(CtPop, ConstantInt::get(CtPop->getType(), 1));\n  }\n  // (X == 0) || (ctpop(X) u> 1) --> ctpop(X) != 1\n  if (!JoinedByAnd && match(Cmp0, m_ICmp(Pred0, m_Value(X), m_ZeroInt())) &&\n      match(Cmp1, m_ICmp(Pred1, m_Intrinsic<Intrinsic::ctpop>(m_Specific(X)),\n                         m_SpecificInt(1))) &&\n      Pred0 == ICmpInst::ICMP_EQ && Pred1 == ICmpInst::ICMP_UGT) {\n    Value *CtPop = Cmp1->getOperand(0);\n    return Builder.CreateICmpNE(CtPop, ConstantInt::get(CtPop->getType(), 1));\n  }\n  return nullptr;\n}\n\n/// Commuted variants are assumed to be handled by calling this function again\n/// with the parameters swapped.\nstatic Value *foldUnsignedUnderflowCheck(ICmpInst *ZeroICmp,\n                                         ICmpInst *UnsignedICmp, bool IsAnd,\n                                         const SimplifyQuery &Q,\n                                         InstCombiner::BuilderTy &Builder) {\n  Value *ZeroCmpOp;\n  ICmpInst::Predicate EqPred;\n  if (!match(ZeroICmp, m_ICmp(EqPred, m_Value(ZeroCmpOp), m_Zero())) ||\n      !ICmpInst::isEquality(EqPred))\n    return nullptr;\n\n  auto IsKnownNonZero = [&](Value *V) {\n    return isKnownNonZero(V, Q.DL, /*Depth=*/0, Q.AC, Q.CxtI, Q.DT);\n  };\n\n  ICmpInst::Predicate UnsignedPred;\n\n  Value *A, *B;\n  if (match(UnsignedICmp,\n            m_c_ICmp(UnsignedPred, m_Specific(ZeroCmpOp), m_Value(A))) &&\n      match(ZeroCmpOp, m_c_Add(m_Specific(A), m_Value(B))) &&\n      (ZeroICmp->hasOneUse() || UnsignedICmp->hasOneUse())) {\n    auto GetKnownNonZeroAndOther = [&](Value *&NonZero, Value *&Other) {\n      if (!IsKnownNonZero(NonZero))\n        std::swap(NonZero, Other);\n      return IsKnownNonZero(NonZero);\n    };\n\n    // Given  ZeroCmpOp = (A + B)\n    //   ZeroCmpOp <= A && ZeroCmpOp != 0  -->  (0-B) <  A\n    //   ZeroCmpOp >  A || ZeroCmpOp == 0  -->  (0-B) >= A\n    //\n    //   ZeroCmpOp <  A && ZeroCmpOp != 0  -->  (0-X) <  Y  iff\n    //   ZeroCmpOp >= A || ZeroCmpOp == 0  -->  (0-X) >= Y  iff\n    //     with X being the value (A/B) that is known to be non-zero,\n    //     and Y being remaining value.\n    if (UnsignedPred == ICmpInst::ICMP_ULE && EqPred == ICmpInst::ICMP_NE &&\n        IsAnd)\n      return Builder.CreateICmpULT(Builder.CreateNeg(B), A);\n    if (UnsignedPred == ICmpInst::ICMP_ULT && EqPred == ICmpInst::ICMP_NE &&\n        IsAnd && GetKnownNonZeroAndOther(B, A))\n      return Builder.CreateICmpULT(Builder.CreateNeg(B), A);\n    if (UnsignedPred == ICmpInst::ICMP_UGT && EqPred == ICmpInst::ICMP_EQ &&\n        !IsAnd)\n      return Builder.CreateICmpUGE(Builder.CreateNeg(B), A);\n    if (UnsignedPred == ICmpInst::ICMP_UGE && EqPred == ICmpInst::ICMP_EQ &&\n        !IsAnd && GetKnownNonZeroAndOther(B, A))\n      return Builder.CreateICmpUGE(Builder.CreateNeg(B), A);\n  }\n\n  Value *Base, *Offset;\n  if (!match(ZeroCmpOp, m_Sub(m_Value(Base), m_Value(Offset))))\n    return nullptr;\n\n  if (!match(UnsignedICmp,\n             m_c_ICmp(UnsignedPred, m_Specific(Base), m_Specific(Offset))) ||\n      !ICmpInst::isUnsigned(UnsignedPred))\n    return nullptr;\n\n  // Base >=/> Offset && (Base - Offset) != 0  <-->  Base > Offset\n  // (no overflow and not null)\n  if ((UnsignedPred == ICmpInst::ICMP_UGE ||\n       UnsignedPred == ICmpInst::ICMP_UGT) &&\n      EqPred == ICmpInst::ICMP_NE && IsAnd)\n    return Builder.CreateICmpUGT(Base, Offset);\n\n  // Base <=/< Offset || (Base - Offset) == 0  <-->  Base <= Offset\n  // (overflow or null)\n  if ((UnsignedPred == ICmpInst::ICMP_ULE ||\n       UnsignedPred == ICmpInst::ICMP_ULT) &&\n      EqPred == ICmpInst::ICMP_EQ && !IsAnd)\n    return Builder.CreateICmpULE(Base, Offset);\n\n  // Base <= Offset && (Base - Offset) != 0  -->  Base < Offset\n  if (UnsignedPred == ICmpInst::ICMP_ULE && EqPred == ICmpInst::ICMP_NE &&\n      IsAnd)\n    return Builder.CreateICmpULT(Base, Offset);\n\n  // Base > Offset || (Base - Offset) == 0  -->  Base >= Offset\n  if (UnsignedPred == ICmpInst::ICMP_UGT && EqPred == ICmpInst::ICMP_EQ &&\n      !IsAnd)\n    return Builder.CreateICmpUGE(Base, Offset);\n\n  return nullptr;\n}\n\n/// Reduce logic-of-compares with equality to a constant by substituting a\n/// common operand with the constant. Callers are expected to call this with\n/// Cmp0/Cmp1 switched to handle logic op commutativity.\nstatic Value *foldAndOrOfICmpsWithConstEq(ICmpInst *Cmp0, ICmpInst *Cmp1,\n                                          BinaryOperator &Logic,\n                                          InstCombiner::BuilderTy &Builder,\n                                          const SimplifyQuery &Q) {\n  bool IsAnd = Logic.getOpcode() == Instruction::And;\n  assert((IsAnd || Logic.getOpcode() == Instruction::Or) && \"Wrong logic op\");\n\n  // Match an equality compare with a non-poison constant as Cmp0.\n  // Also, give up if the compare can be constant-folded to avoid looping.\n  ICmpInst::Predicate Pred0;\n  Value *X;\n  Constant *C;\n  if (!match(Cmp0, m_ICmp(Pred0, m_Value(X), m_Constant(C))) ||\n      !isGuaranteedNotToBeUndefOrPoison(C) || isa<Constant>(X))\n    return nullptr;\n  if ((IsAnd && Pred0 != ICmpInst::ICMP_EQ) ||\n      (!IsAnd && Pred0 != ICmpInst::ICMP_NE))\n    return nullptr;\n\n  // The other compare must include a common operand (X). Canonicalize the\n  // common operand as operand 1 (Pred1 is swapped if the common operand was\n  // operand 0).\n  Value *Y;\n  ICmpInst::Predicate Pred1;\n  if (!match(Cmp1, m_c_ICmp(Pred1, m_Value(Y), m_Deferred(X))))\n    return nullptr;\n\n  // Replace variable with constant value equivalence to remove a variable use:\n  // (X == C) && (Y Pred1 X) --> (X == C) && (Y Pred1 C)\n  // (X != C) || (Y Pred1 X) --> (X != C) || (Y Pred1 C)\n  // Can think of the 'or' substitution with the 'and' bool equivalent:\n  // A || B --> A || (!A && B)\n  Value *SubstituteCmp = SimplifyICmpInst(Pred1, Y, C, Q);\n  if (!SubstituteCmp) {\n    // If we need to create a new instruction, require that the old compare can\n    // be removed.\n    if (!Cmp1->hasOneUse())\n      return nullptr;\n    SubstituteCmp = Builder.CreateICmp(Pred1, Y, C);\n  }\n  return Builder.CreateBinOp(Logic.getOpcode(), Cmp0, SubstituteCmp);\n}\n\n/// Fold (icmp)&(icmp) if possible.\nValue *InstCombinerImpl::foldAndOfICmps(ICmpInst *LHS, ICmpInst *RHS,\n                                        BinaryOperator &And) {\n  const SimplifyQuery Q = SQ.getWithInstruction(&And);\n\n  // Fold (!iszero(A & K1) & !iszero(A & K2)) ->  (A & (K1 | K2)) == (K1 | K2)\n  // if K1 and K2 are a one-bit mask.\n  if (Value *V = foldAndOrOfICmpsOfAndWithPow2(LHS, RHS, And))\n    return V;\n\n  ICmpInst::Predicate PredL = LHS->getPredicate(), PredR = RHS->getPredicate();\n\n  // (icmp1 A, B) & (icmp2 A, B) --> (icmp3 A, B)\n  if (predicatesFoldable(PredL, PredR)) {\n    if (LHS->getOperand(0) == RHS->getOperand(1) &&\n        LHS->getOperand(1) == RHS->getOperand(0))\n      LHS->swapOperands();\n    if (LHS->getOperand(0) == RHS->getOperand(0) &&\n        LHS->getOperand(1) == RHS->getOperand(1)) {\n      Value *Op0 = LHS->getOperand(0), *Op1 = LHS->getOperand(1);\n      unsigned Code = getICmpCode(LHS) & getICmpCode(RHS);\n      bool IsSigned = LHS->isSigned() || RHS->isSigned();\n      return getNewICmpValue(Code, IsSigned, Op0, Op1, Builder);\n    }\n  }\n\n  // handle (roughly):  (icmp eq (A & B), C) & (icmp eq (A & D), E)\n  if (Value *V = foldLogOpOfMaskedICmps(LHS, RHS, true, Builder))\n    return V;\n\n  if (Value *V = foldAndOrOfICmpsWithConstEq(LHS, RHS, And, Builder, Q))\n    return V;\n  if (Value *V = foldAndOrOfICmpsWithConstEq(RHS, LHS, And, Builder, Q))\n    return V;\n\n  // E.g. (icmp sge x, 0) & (icmp slt x, n) --> icmp ult x, n\n  if (Value *V = simplifyRangeCheck(LHS, RHS, /*Inverted=*/false))\n    return V;\n\n  // E.g. (icmp slt x, n) & (icmp sge x, 0) --> icmp ult x, n\n  if (Value *V = simplifyRangeCheck(RHS, LHS, /*Inverted=*/false))\n    return V;\n\n  if (Value *V = foldAndOrOfEqualityCmpsWithConstants(LHS, RHS, true, Builder))\n    return V;\n\n  if (Value *V = foldSignedTruncationCheck(LHS, RHS, And, Builder))\n    return V;\n\n  if (Value *V = foldIsPowerOf2(LHS, RHS, true /* JoinedByAnd */, Builder))\n    return V;\n\n  if (Value *X =\n          foldUnsignedUnderflowCheck(LHS, RHS, /*IsAnd=*/true, Q, Builder))\n    return X;\n  if (Value *X =\n          foldUnsignedUnderflowCheck(RHS, LHS, /*IsAnd=*/true, Q, Builder))\n    return X;\n\n  // This only handles icmp of constants: (icmp1 A, C1) & (icmp2 B, C2).\n  Value *LHS0 = LHS->getOperand(0), *RHS0 = RHS->getOperand(0);\n\n  ConstantInt *LHSC, *RHSC;\n  if (!match(LHS->getOperand(1), m_ConstantInt(LHSC)) ||\n      !match(RHS->getOperand(1), m_ConstantInt(RHSC)))\n    return nullptr;\n\n  if (LHSC == RHSC && PredL == PredR) {\n    // (icmp ult A, C) & (icmp ult B, C) --> (icmp ult (A|B), C)\n    // where C is a power of 2 or\n    // (icmp eq A, 0) & (icmp eq B, 0) --> (icmp eq (A|B), 0)\n    if ((PredL == ICmpInst::ICMP_ULT && LHSC->getValue().isPowerOf2()) ||\n        (PredL == ICmpInst::ICMP_EQ && LHSC->isZero())) {\n      Value *NewOr = Builder.CreateOr(LHS0, RHS0);\n      return Builder.CreateICmp(PredL, NewOr, LHSC);\n    }\n  }\n\n  // (trunc x) == C1 & (and x, CA) == C2 -> (and x, CA|CMAX) == C1|C2\n  // where CMAX is the all ones value for the truncated type,\n  // iff the lower bits of C2 and CA are zero.\n  if (PredL == ICmpInst::ICMP_EQ && PredL == PredR && LHS->hasOneUse() &&\n      RHS->hasOneUse()) {\n    Value *V;\n    ConstantInt *AndC, *SmallC = nullptr, *BigC = nullptr;\n\n    // (trunc x) == C1 & (and x, CA) == C2\n    // (and x, CA) == C2 & (trunc x) == C1\n    if (match(RHS0, m_Trunc(m_Value(V))) &&\n        match(LHS0, m_And(m_Specific(V), m_ConstantInt(AndC)))) {\n      SmallC = RHSC;\n      BigC = LHSC;\n    } else if (match(LHS0, m_Trunc(m_Value(V))) &&\n               match(RHS0, m_And(m_Specific(V), m_ConstantInt(AndC)))) {\n      SmallC = LHSC;\n      BigC = RHSC;\n    }\n\n    if (SmallC && BigC) {\n      unsigned BigBitSize = BigC->getType()->getBitWidth();\n      unsigned SmallBitSize = SmallC->getType()->getBitWidth();\n\n      // Check that the low bits are zero.\n      APInt Low = APInt::getLowBitsSet(BigBitSize, SmallBitSize);\n      if ((Low & AndC->getValue()).isNullValue() &&\n          (Low & BigC->getValue()).isNullValue()) {\n        Value *NewAnd = Builder.CreateAnd(V, Low | AndC->getValue());\n        APInt N = SmallC->getValue().zext(BigBitSize) | BigC->getValue();\n        Value *NewVal = ConstantInt::get(AndC->getType()->getContext(), N);\n        return Builder.CreateICmp(PredL, NewAnd, NewVal);\n      }\n    }\n  }\n\n  // From here on, we only handle:\n  //    (icmp1 A, C1) & (icmp2 A, C2) --> something simpler.\n  if (LHS0 != RHS0)\n    return nullptr;\n\n  // ICMP_[US][GL]E X, C is folded to ICMP_[US][GL]T elsewhere.\n  if (PredL == ICmpInst::ICMP_UGE || PredL == ICmpInst::ICMP_ULE ||\n      PredR == ICmpInst::ICMP_UGE || PredR == ICmpInst::ICMP_ULE ||\n      PredL == ICmpInst::ICMP_SGE || PredL == ICmpInst::ICMP_SLE ||\n      PredR == ICmpInst::ICMP_SGE || PredR == ICmpInst::ICMP_SLE)\n    return nullptr;\n\n  // We can't fold (ugt x, C) & (sgt x, C2).\n  if (!predicatesFoldable(PredL, PredR))\n    return nullptr;\n\n  // Ensure that the larger constant is on the RHS.\n  bool ShouldSwap;\n  if (CmpInst::isSigned(PredL) ||\n      (ICmpInst::isEquality(PredL) && CmpInst::isSigned(PredR)))\n    ShouldSwap = LHSC->getValue().sgt(RHSC->getValue());\n  else\n    ShouldSwap = LHSC->getValue().ugt(RHSC->getValue());\n\n  if (ShouldSwap) {\n    std::swap(LHS, RHS);\n    std::swap(LHSC, RHSC);\n    std::swap(PredL, PredR);\n  }\n\n  // At this point, we know we have two icmp instructions\n  // comparing a value against two constants and and'ing the result\n  // together.  Because of the above check, we know that we only have\n  // icmp eq, icmp ne, icmp [su]lt, and icmp [SU]gt here. We also know\n  // (from the icmp folding check above), that the two constants\n  // are not equal and that the larger constant is on the RHS\n  assert(LHSC != RHSC && \"Compares not folded above?\");\n\n  switch (PredL) {\n  default:\n    llvm_unreachable(\"Unknown integer condition code!\");\n  case ICmpInst::ICMP_NE:\n    switch (PredR) {\n    default:\n      llvm_unreachable(\"Unknown integer condition code!\");\n    case ICmpInst::ICMP_ULT:\n      // (X != 13 & X u< 14) -> X < 13\n      if (LHSC->getValue() == (RHSC->getValue() - 1))\n        return Builder.CreateICmpULT(LHS0, LHSC);\n      if (LHSC->isZero()) // (X != 0 & X u< C) -> X-1 u< C-1\n        return insertRangeTest(LHS0, LHSC->getValue() + 1, RHSC->getValue(),\n                               false, true);\n      break; // (X != 13 & X u< 15) -> no change\n    case ICmpInst::ICMP_SLT:\n      // (X != 13 & X s< 14) -> X < 13\n      if (LHSC->getValue() == (RHSC->getValue() - 1))\n        return Builder.CreateICmpSLT(LHS0, LHSC);\n      // (X != INT_MIN & X s< C) -> X-(INT_MIN+1) u< (C-(INT_MIN+1))\n      if (LHSC->isMinValue(true))\n        return insertRangeTest(LHS0, LHSC->getValue() + 1, RHSC->getValue(),\n                               true, true);\n      break; // (X != 13 & X s< 15) -> no change\n    case ICmpInst::ICMP_NE:\n      // Potential folds for this case should already be handled.\n      break;\n    }\n    break;\n  case ICmpInst::ICMP_UGT:\n    switch (PredR) {\n    default:\n      llvm_unreachable(\"Unknown integer condition code!\");\n    case ICmpInst::ICMP_NE:\n      // (X u> 13 & X != 14) -> X u> 14\n      if (RHSC->getValue() == (LHSC->getValue() + 1))\n        return Builder.CreateICmp(PredL, LHS0, RHSC);\n      // X u> C & X != UINT_MAX -> (X-(C+1)) u< UINT_MAX-(C+1)\n      if (RHSC->isMaxValue(false))\n        return insertRangeTest(LHS0, LHSC->getValue() + 1, RHSC->getValue(),\n                               false, true);\n      break;                 // (X u> 13 & X != 15) -> no change\n    case ICmpInst::ICMP_ULT: // (X u> 13 & X u< 15) -> (X-14) u< 1\n      return insertRangeTest(LHS0, LHSC->getValue() + 1, RHSC->getValue(),\n                             false, true);\n    }\n    break;\n  case ICmpInst::ICMP_SGT:\n    switch (PredR) {\n    default:\n      llvm_unreachable(\"Unknown integer condition code!\");\n    case ICmpInst::ICMP_NE:\n      // (X s> 13 & X != 14) -> X s> 14\n      if (RHSC->getValue() == (LHSC->getValue() + 1))\n        return Builder.CreateICmp(PredL, LHS0, RHSC);\n      // X s> C & X != INT_MAX -> (X-(C+1)) u< INT_MAX-(C+1)\n      if (RHSC->isMaxValue(true))\n        return insertRangeTest(LHS0, LHSC->getValue() + 1, RHSC->getValue(),\n                               true, true);\n      break;                 // (X s> 13 & X != 15) -> no change\n    case ICmpInst::ICMP_SLT: // (X s> 13 & X s< 15) -> (X-14) u< 1\n      return insertRangeTest(LHS0, LHSC->getValue() + 1, RHSC->getValue(), true,\n                             true);\n    }\n    break;\n  }\n\n  return nullptr;\n}\n\nValue *InstCombinerImpl::foldLogicOfFCmps(FCmpInst *LHS, FCmpInst *RHS,\n                                          bool IsAnd) {\n  Value *LHS0 = LHS->getOperand(0), *LHS1 = LHS->getOperand(1);\n  Value *RHS0 = RHS->getOperand(0), *RHS1 = RHS->getOperand(1);\n  FCmpInst::Predicate PredL = LHS->getPredicate(), PredR = RHS->getPredicate();\n\n  if (LHS0 == RHS1 && RHS0 == LHS1) {\n    // Swap RHS operands to match LHS.\n    PredR = FCmpInst::getSwappedPredicate(PredR);\n    std::swap(RHS0, RHS1);\n  }\n\n  // Simplify (fcmp cc0 x, y) & (fcmp cc1 x, y).\n  // Suppose the relation between x and y is R, where R is one of\n  // U(1000), L(0100), G(0010) or E(0001), and CC0 and CC1 are the bitmasks for\n  // testing the desired relations.\n  //\n  // Since (R & CC0) and (R & CC1) are either R or 0, we actually have this:\n  //    bool(R & CC0) && bool(R & CC1)\n  //  = bool((R & CC0) & (R & CC1))\n  //  = bool(R & (CC0 & CC1)) <= by re-association, commutation, and idempotency\n  //\n  // Since (R & CC0) and (R & CC1) are either R or 0, we actually have this:\n  //    bool(R & CC0) || bool(R & CC1)\n  //  = bool((R & CC0) | (R & CC1))\n  //  = bool(R & (CC0 | CC1)) <= by reversed distribution (contribution? ;)\n  if (LHS0 == RHS0 && LHS1 == RHS1) {\n    unsigned FCmpCodeL = getFCmpCode(PredL);\n    unsigned FCmpCodeR = getFCmpCode(PredR);\n    unsigned NewPred = IsAnd ? FCmpCodeL & FCmpCodeR : FCmpCodeL | FCmpCodeR;\n    return getFCmpValue(NewPred, LHS0, LHS1, Builder);\n  }\n\n  if ((PredL == FCmpInst::FCMP_ORD && PredR == FCmpInst::FCMP_ORD && IsAnd) ||\n      (PredL == FCmpInst::FCMP_UNO && PredR == FCmpInst::FCMP_UNO && !IsAnd)) {\n    if (LHS0->getType() != RHS0->getType())\n      return nullptr;\n\n    // FCmp canonicalization ensures that (fcmp ord/uno X, X) and\n    // (fcmp ord/uno X, C) will be transformed to (fcmp X, +0.0).\n    if (match(LHS1, m_PosZeroFP()) && match(RHS1, m_PosZeroFP()))\n      // Ignore the constants because they are obviously not NANs:\n      // (fcmp ord x, 0.0) & (fcmp ord y, 0.0)  -> (fcmp ord x, y)\n      // (fcmp uno x, 0.0) | (fcmp uno y, 0.0)  -> (fcmp uno x, y)\n      return Builder.CreateFCmp(PredL, LHS0, RHS0);\n  }\n\n  return nullptr;\n}\n\n/// This a limited reassociation for a special case (see above) where we are\n/// checking if two values are either both NAN (unordered) or not-NAN (ordered).\n/// This could be handled more generally in '-reassociation', but it seems like\n/// an unlikely pattern for a large number of logic ops and fcmps.\nstatic Instruction *reassociateFCmps(BinaryOperator &BO,\n                                     InstCombiner::BuilderTy &Builder) {\n  Instruction::BinaryOps Opcode = BO.getOpcode();\n  assert((Opcode == Instruction::And || Opcode == Instruction::Or) &&\n         \"Expecting and/or op for fcmp transform\");\n\n  // There are 4 commuted variants of the pattern. Canonicalize operands of this\n  // logic op so an fcmp is operand 0 and a matching logic op is operand 1.\n  Value *Op0 = BO.getOperand(0), *Op1 = BO.getOperand(1), *X;\n  FCmpInst::Predicate Pred;\n  if (match(Op1, m_FCmp(Pred, m_Value(), m_AnyZeroFP())))\n    std::swap(Op0, Op1);\n\n  // Match inner binop and the predicate for combining 2 NAN checks into 1.\n  BinaryOperator *BO1;\n  FCmpInst::Predicate NanPred = Opcode == Instruction::And ? FCmpInst::FCMP_ORD\n                                                           : FCmpInst::FCMP_UNO;\n  if (!match(Op0, m_FCmp(Pred, m_Value(X), m_AnyZeroFP())) || Pred != NanPred ||\n      !match(Op1, m_BinOp(BO1)) || BO1->getOpcode() != Opcode)\n    return nullptr;\n\n  // The inner logic op must have a matching fcmp operand.\n  Value *BO10 = BO1->getOperand(0), *BO11 = BO1->getOperand(1), *Y;\n  if (!match(BO10, m_FCmp(Pred, m_Value(Y), m_AnyZeroFP())) ||\n      Pred != NanPred || X->getType() != Y->getType())\n    std::swap(BO10, BO11);\n\n  if (!match(BO10, m_FCmp(Pred, m_Value(Y), m_AnyZeroFP())) ||\n      Pred != NanPred || X->getType() != Y->getType())\n    return nullptr;\n\n  // and (fcmp ord X, 0), (and (fcmp ord Y, 0), Z) --> and (fcmp ord X, Y), Z\n  // or  (fcmp uno X, 0), (or  (fcmp uno Y, 0), Z) --> or  (fcmp uno X, Y), Z\n  Value *NewFCmp = Builder.CreateFCmp(Pred, X, Y);\n  if (auto *NewFCmpInst = dyn_cast<FCmpInst>(NewFCmp)) {\n    // Intersect FMF from the 2 source fcmps.\n    NewFCmpInst->copyIRFlags(Op0);\n    NewFCmpInst->andIRFlags(BO10);\n  }\n  return BinaryOperator::Create(Opcode, NewFCmp, BO11);\n}\n\n/// Match De Morgan's Laws:\n/// (~A & ~B) == (~(A | B))\n/// (~A | ~B) == (~(A & B))\nstatic Instruction *matchDeMorgansLaws(BinaryOperator &I,\n                                       InstCombiner::BuilderTy &Builder) {\n  auto Opcode = I.getOpcode();\n  assert((Opcode == Instruction::And || Opcode == Instruction::Or) &&\n         \"Trying to match De Morgan's Laws with something other than and/or\");\n\n  // Flip the logic operation.\n  Opcode = (Opcode == Instruction::And) ? Instruction::Or : Instruction::And;\n\n  Value *A, *B;\n  if (match(I.getOperand(0), m_OneUse(m_Not(m_Value(A)))) &&\n      match(I.getOperand(1), m_OneUse(m_Not(m_Value(B)))) &&\n      !InstCombiner::isFreeToInvert(A, A->hasOneUse()) &&\n      !InstCombiner::isFreeToInvert(B, B->hasOneUse())) {\n    Value *AndOr = Builder.CreateBinOp(Opcode, A, B, I.getName() + \".demorgan\");\n    return BinaryOperator::CreateNot(AndOr);\n  }\n\n  return nullptr;\n}\n\nbool InstCombinerImpl::shouldOptimizeCast(CastInst *CI) {\n  Value *CastSrc = CI->getOperand(0);\n\n  // Noop casts and casts of constants should be eliminated trivially.\n  if (CI->getSrcTy() == CI->getDestTy() || isa<Constant>(CastSrc))\n    return false;\n\n  // If this cast is paired with another cast that can be eliminated, we prefer\n  // to have it eliminated.\n  if (const auto *PrecedingCI = dyn_cast<CastInst>(CastSrc))\n    if (isEliminableCastPair(PrecedingCI, CI))\n      return false;\n\n  return true;\n}\n\n/// Fold {and,or,xor} (cast X), C.\nstatic Instruction *foldLogicCastConstant(BinaryOperator &Logic, CastInst *Cast,\n                                          InstCombiner::BuilderTy &Builder) {\n  Constant *C = dyn_cast<Constant>(Logic.getOperand(1));\n  if (!C)\n    return nullptr;\n\n  auto LogicOpc = Logic.getOpcode();\n  Type *DestTy = Logic.getType();\n  Type *SrcTy = Cast->getSrcTy();\n\n  // Move the logic operation ahead of a zext or sext if the constant is\n  // unchanged in the smaller source type. Performing the logic in a smaller\n  // type may provide more information to later folds, and the smaller logic\n  // instruction may be cheaper (particularly in the case of vectors).\n  Value *X;\n  if (match(Cast, m_OneUse(m_ZExt(m_Value(X))))) {\n    Constant *TruncC = ConstantExpr::getTrunc(C, SrcTy);\n    Constant *ZextTruncC = ConstantExpr::getZExt(TruncC, DestTy);\n    if (ZextTruncC == C) {\n      // LogicOpc (zext X), C --> zext (LogicOpc X, C)\n      Value *NewOp = Builder.CreateBinOp(LogicOpc, X, TruncC);\n      return new ZExtInst(NewOp, DestTy);\n    }\n  }\n\n  if (match(Cast, m_OneUse(m_SExt(m_Value(X))))) {\n    Constant *TruncC = ConstantExpr::getTrunc(C, SrcTy);\n    Constant *SextTruncC = ConstantExpr::getSExt(TruncC, DestTy);\n    if (SextTruncC == C) {\n      // LogicOpc (sext X), C --> sext (LogicOpc X, C)\n      Value *NewOp = Builder.CreateBinOp(LogicOpc, X, TruncC);\n      return new SExtInst(NewOp, DestTy);\n    }\n  }\n\n  return nullptr;\n}\n\n/// Fold {and,or,xor} (cast X), Y.\nInstruction *InstCombinerImpl::foldCastedBitwiseLogic(BinaryOperator &I) {\n  auto LogicOpc = I.getOpcode();\n  assert(I.isBitwiseLogicOp() && \"Unexpected opcode for bitwise logic folding\");\n\n  Value *Op0 = I.getOperand(0), *Op1 = I.getOperand(1);\n  CastInst *Cast0 = dyn_cast<CastInst>(Op0);\n  if (!Cast0)\n    return nullptr;\n\n  // This must be a cast from an integer or integer vector source type to allow\n  // transformation of the logic operation to the source type.\n  Type *DestTy = I.getType();\n  Type *SrcTy = Cast0->getSrcTy();\n  if (!SrcTy->isIntOrIntVectorTy())\n    return nullptr;\n\n  if (Instruction *Ret = foldLogicCastConstant(I, Cast0, Builder))\n    return Ret;\n\n  CastInst *Cast1 = dyn_cast<CastInst>(Op1);\n  if (!Cast1)\n    return nullptr;\n\n  // Both operands of the logic operation are casts. The casts must be of the\n  // same type for reduction.\n  auto CastOpcode = Cast0->getOpcode();\n  if (CastOpcode != Cast1->getOpcode() || SrcTy != Cast1->getSrcTy())\n    return nullptr;\n\n  Value *Cast0Src = Cast0->getOperand(0);\n  Value *Cast1Src = Cast1->getOperand(0);\n\n  // fold logic(cast(A), cast(B)) -> cast(logic(A, B))\n  if (shouldOptimizeCast(Cast0) && shouldOptimizeCast(Cast1)) {\n    Value *NewOp = Builder.CreateBinOp(LogicOpc, Cast0Src, Cast1Src,\n                                        I.getName());\n    return CastInst::Create(CastOpcode, NewOp, DestTy);\n  }\n\n  // For now, only 'and'/'or' have optimizations after this.\n  if (LogicOpc == Instruction::Xor)\n    return nullptr;\n\n  // If this is logic(cast(icmp), cast(icmp)), try to fold this even if the\n  // cast is otherwise not optimizable.  This happens for vector sexts.\n  ICmpInst *ICmp0 = dyn_cast<ICmpInst>(Cast0Src);\n  ICmpInst *ICmp1 = dyn_cast<ICmpInst>(Cast1Src);\n  if (ICmp0 && ICmp1) {\n    Value *Res = LogicOpc == Instruction::And ? foldAndOfICmps(ICmp0, ICmp1, I)\n                                              : foldOrOfICmps(ICmp0, ICmp1, I);\n    if (Res)\n      return CastInst::Create(CastOpcode, Res, DestTy);\n    return nullptr;\n  }\n\n  // If this is logic(cast(fcmp), cast(fcmp)), try to fold this even if the\n  // cast is otherwise not optimizable.  This happens for vector sexts.\n  FCmpInst *FCmp0 = dyn_cast<FCmpInst>(Cast0Src);\n  FCmpInst *FCmp1 = dyn_cast<FCmpInst>(Cast1Src);\n  if (FCmp0 && FCmp1)\n    if (Value *R = foldLogicOfFCmps(FCmp0, FCmp1, LogicOpc == Instruction::And))\n      return CastInst::Create(CastOpcode, R, DestTy);\n\n  return nullptr;\n}\n\nstatic Instruction *foldAndToXor(BinaryOperator &I,\n                                 InstCombiner::BuilderTy &Builder) {\n  assert(I.getOpcode() == Instruction::And);\n  Value *Op0 = I.getOperand(0);\n  Value *Op1 = I.getOperand(1);\n  Value *A, *B;\n\n  // Operand complexity canonicalization guarantees that the 'or' is Op0.\n  // (A | B) & ~(A & B) --> A ^ B\n  // (A | B) & ~(B & A) --> A ^ B\n  if (match(&I, m_BinOp(m_Or(m_Value(A), m_Value(B)),\n                        m_Not(m_c_And(m_Deferred(A), m_Deferred(B))))))\n    return BinaryOperator::CreateXor(A, B);\n\n  // (A | ~B) & (~A | B) --> ~(A ^ B)\n  // (A | ~B) & (B | ~A) --> ~(A ^ B)\n  // (~B | A) & (~A | B) --> ~(A ^ B)\n  // (~B | A) & (B | ~A) --> ~(A ^ B)\n  if (Op0->hasOneUse() || Op1->hasOneUse())\n    if (match(&I, m_BinOp(m_c_Or(m_Value(A), m_Not(m_Value(B))),\n                          m_c_Or(m_Not(m_Deferred(A)), m_Deferred(B)))))\n      return BinaryOperator::CreateNot(Builder.CreateXor(A, B));\n\n  return nullptr;\n}\n\nstatic Instruction *foldOrToXor(BinaryOperator &I,\n                                InstCombiner::BuilderTy &Builder) {\n  assert(I.getOpcode() == Instruction::Or);\n  Value *Op0 = I.getOperand(0);\n  Value *Op1 = I.getOperand(1);\n  Value *A, *B;\n\n  // Operand complexity canonicalization guarantees that the 'and' is Op0.\n  // (A & B) | ~(A | B) --> ~(A ^ B)\n  // (A & B) | ~(B | A) --> ~(A ^ B)\n  if (Op0->hasOneUse() || Op1->hasOneUse())\n    if (match(Op0, m_And(m_Value(A), m_Value(B))) &&\n        match(Op1, m_Not(m_c_Or(m_Specific(A), m_Specific(B)))))\n      return BinaryOperator::CreateNot(Builder.CreateXor(A, B));\n\n  // Operand complexity canonicalization guarantees that the 'xor' is Op0.\n  // (A ^ B) | ~(A | B) --> ~(A & B)\n  // (A ^ B) | ~(B | A) --> ~(A & B)\n  if (Op0->hasOneUse() || Op1->hasOneUse())\n    if (match(Op0, m_Xor(m_Value(A), m_Value(B))) &&\n        match(Op1, m_Not(m_c_Or(m_Specific(A), m_Specific(B)))))\n      return BinaryOperator::CreateNot(Builder.CreateAnd(A, B));\n\n  // (A & ~B) | (~A & B) --> A ^ B\n  // (A & ~B) | (B & ~A) --> A ^ B\n  // (~B & A) | (~A & B) --> A ^ B\n  // (~B & A) | (B & ~A) --> A ^ B\n  if (match(Op0, m_c_And(m_Value(A), m_Not(m_Value(B)))) &&\n      match(Op1, m_c_And(m_Not(m_Specific(A)), m_Specific(B))))\n    return BinaryOperator::CreateXor(A, B);\n\n  return nullptr;\n}\n\n/// Return true if a constant shift amount is always less than the specified\n/// bit-width. If not, the shift could create poison in the narrower type.\nstatic bool canNarrowShiftAmt(Constant *C, unsigned BitWidth) {\n  APInt Threshold(C->getType()->getScalarSizeInBits(), BitWidth);\n  return match(C, m_SpecificInt_ICMP(ICmpInst::ICMP_ULT, Threshold));\n}\n\n/// Try to use narrower ops (sink zext ops) for an 'and' with binop operand and\n/// a common zext operand: and (binop (zext X), C), (zext X).\nInstruction *InstCombinerImpl::narrowMaskedBinOp(BinaryOperator &And) {\n  // This transform could also apply to {or, and, xor}, but there are better\n  // folds for those cases, so we don't expect those patterns here. AShr is not\n  // handled because it should always be transformed to LShr in this sequence.\n  // The subtract transform is different because it has a constant on the left.\n  // Add/mul commute the constant to RHS; sub with constant RHS becomes add.\n  Value *Op0 = And.getOperand(0), *Op1 = And.getOperand(1);\n  Constant *C;\n  if (!match(Op0, m_OneUse(m_Add(m_Specific(Op1), m_Constant(C)))) &&\n      !match(Op0, m_OneUse(m_Mul(m_Specific(Op1), m_Constant(C)))) &&\n      !match(Op0, m_OneUse(m_LShr(m_Specific(Op1), m_Constant(C)))) &&\n      !match(Op0, m_OneUse(m_Shl(m_Specific(Op1), m_Constant(C)))) &&\n      !match(Op0, m_OneUse(m_Sub(m_Constant(C), m_Specific(Op1)))))\n    return nullptr;\n\n  Value *X;\n  if (!match(Op1, m_ZExt(m_Value(X))) || Op1->hasNUsesOrMore(3))\n    return nullptr;\n\n  Type *Ty = And.getType();\n  if (!isa<VectorType>(Ty) && !shouldChangeType(Ty, X->getType()))\n    return nullptr;\n\n  // If we're narrowing a shift, the shift amount must be safe (less than the\n  // width) in the narrower type. If the shift amount is greater, instsimplify\n  // usually handles that case, but we can't guarantee/assert it.\n  Instruction::BinaryOps Opc = cast<BinaryOperator>(Op0)->getOpcode();\n  if (Opc == Instruction::LShr || Opc == Instruction::Shl)\n    if (!canNarrowShiftAmt(C, X->getType()->getScalarSizeInBits()))\n      return nullptr;\n\n  // and (sub C, (zext X)), (zext X) --> zext (and (sub C', X), X)\n  // and (binop (zext X), C), (zext X) --> zext (and (binop X, C'), X)\n  Value *NewC = ConstantExpr::getTrunc(C, X->getType());\n  Value *NewBO = Opc == Instruction::Sub ? Builder.CreateBinOp(Opc, NewC, X)\n                                         : Builder.CreateBinOp(Opc, X, NewC);\n  return new ZExtInst(Builder.CreateAnd(NewBO, X), Ty);\n}\n\n// FIXME: We use commutative matchers (m_c_*) for some, but not all, matches\n// here. We should standardize that construct where it is needed or choose some\n// other way to ensure that commutated variants of patterns are not missed.\nInstruction *InstCombinerImpl::visitAnd(BinaryOperator &I) {\n  Type *Ty = I.getType();\n\n  if (Value *V = SimplifyAndInst(I.getOperand(0), I.getOperand(1),\n                                 SQ.getWithInstruction(&I)))\n    return replaceInstUsesWith(I, V);\n\n  if (SimplifyAssociativeOrCommutative(I))\n    return &I;\n\n  if (Instruction *X = foldVectorBinop(I))\n    return X;\n\n  // See if we can simplify any instructions used by the instruction whose sole\n  // purpose is to compute bits we don't care about.\n  if (SimplifyDemandedInstructionBits(I))\n    return &I;\n\n  // Do this before using distributive laws to catch simple and/or/not patterns.\n  if (Instruction *Xor = foldAndToXor(I, Builder))\n    return Xor;\n\n  // (A|B)&(A|C) -> A|(B&C) etc\n  if (Value *V = SimplifyUsingDistributiveLaws(I))\n    return replaceInstUsesWith(I, V);\n\n  if (Value *V = SimplifyBSwap(I, Builder))\n    return replaceInstUsesWith(I, V);\n\n  Value *Op0 = I.getOperand(0), *Op1 = I.getOperand(1);\n\n  Value *X, *Y;\n  if (match(Op0, m_OneUse(m_LogicalShift(m_One(), m_Value(X)))) &&\n      match(Op1, m_One())) {\n    // (1 << X) & 1 --> zext(X == 0)\n    // (1 >> X) & 1 --> zext(X == 0)\n    Value *IsZero = Builder.CreateICmpEQ(X, ConstantInt::get(Ty, 0));\n    return new ZExtInst(IsZero, Ty);\n  }\n\n  const APInt *C;\n  if (match(Op1, m_APInt(C))) {\n    const APInt *XorC;\n    if (match(Op0, m_OneUse(m_Xor(m_Value(X), m_APInt(XorC))))) {\n      // (X ^ C1) & C2 --> (X & C2) ^ (C1&C2)\n      Constant *NewC = ConstantInt::get(Ty, *C & *XorC);\n      Value *And = Builder.CreateAnd(X, Op1);\n      And->takeName(Op0);\n      return BinaryOperator::CreateXor(And, NewC);\n    }\n\n    const APInt *OrC;\n    if (match(Op0, m_OneUse(m_Or(m_Value(X), m_APInt(OrC))))) {\n      // (X | C1) & C2 --> (X & C2^(C1&C2)) | (C1&C2)\n      // NOTE: This reduces the number of bits set in the & mask, which\n      // can expose opportunities for store narrowing for scalars.\n      // NOTE: SimplifyDemandedBits should have already removed bits from C1\n      // that aren't set in C2. Meaning we can replace (C1&C2) with C1 in\n      // above, but this feels safer.\n      APInt Together = *C & *OrC;\n      Value *And = Builder.CreateAnd(X, ConstantInt::get(Ty, Together ^ *C));\n      And->takeName(Op0);\n      return BinaryOperator::CreateOr(And, ConstantInt::get(Ty, Together));\n    }\n\n    // If the mask is only needed on one incoming arm, push the 'and' op up.\n    if (match(Op0, m_OneUse(m_Xor(m_Value(X), m_Value(Y)))) ||\n        match(Op0, m_OneUse(m_Or(m_Value(X), m_Value(Y))))) {\n      APInt NotAndMask(~(*C));\n      BinaryOperator::BinaryOps BinOp = cast<BinaryOperator>(Op0)->getOpcode();\n      if (MaskedValueIsZero(X, NotAndMask, 0, &I)) {\n        // Not masking anything out for the LHS, move mask to RHS.\n        // and ({x}or X, Y), C --> {x}or X, (and Y, C)\n        Value *NewRHS = Builder.CreateAnd(Y, Op1, Y->getName() + \".masked\");\n        return BinaryOperator::Create(BinOp, X, NewRHS);\n      }\n      if (!isa<Constant>(Y) && MaskedValueIsZero(Y, NotAndMask, 0, &I)) {\n        // Not masking anything out for the RHS, move mask to LHS.\n        // and ({x}or X, Y), C --> {x}or (and X, C), Y\n        Value *NewLHS = Builder.CreateAnd(X, Op1, X->getName() + \".masked\");\n        return BinaryOperator::Create(BinOp, NewLHS, Y);\n      }\n    }\n\n    unsigned Width = Ty->getScalarSizeInBits();\n    const APInt *ShiftC;\n    if (match(Op0, m_OneUse(m_SExt(m_AShr(m_Value(X), m_APInt(ShiftC)))))) {\n      if (*C == APInt::getLowBitsSet(Width, Width - ShiftC->getZExtValue())) {\n        // We are clearing high bits that were potentially set by sext+ashr:\n        // and (sext (ashr X, ShiftC)), C --> lshr (sext X), ShiftC\n        Value *Sext = Builder.CreateSExt(X, Ty);\n        Constant *ShAmtC = ConstantInt::get(Ty, ShiftC->zext(Width));\n        return BinaryOperator::CreateLShr(Sext, ShAmtC);\n      }\n    }\n\n    const APInt *AddC;\n    if (match(Op0, m_Add(m_Value(X), m_APInt(AddC)))) {\n      // If we add zeros to every bit below a mask, the add has no effect:\n      // (X + AddC) & LowMaskC --> X & LowMaskC\n      unsigned Ctlz = C->countLeadingZeros();\n      APInt LowMask(APInt::getLowBitsSet(Width, Width - Ctlz));\n      if ((*AddC & LowMask).isNullValue())\n        return BinaryOperator::CreateAnd(X, Op1);\n\n      // If we are masking the result of the add down to exactly one bit and\n      // the constant we are adding has no bits set below that bit, then the\n      // add is flipping a single bit. Example:\n      // (X + 4) & 4 --> (X & 4) ^ 4\n      if (Op0->hasOneUse() && C->isPowerOf2() && (*AddC & (*C - 1)) == 0) {\n        assert((*C & *AddC) != 0 && \"Expected common bit\");\n        Value *NewAnd = Builder.CreateAnd(X, Op1);\n        return BinaryOperator::CreateXor(NewAnd, Op1);\n      }\n    }\n  }\n\n  ConstantInt *AndRHS;\n  if (match(Op1, m_ConstantInt(AndRHS))) {\n    const APInt &AndRHSMask = AndRHS->getValue();\n\n    // Optimize a variety of ((val OP C1) & C2) combinations...\n    if (BinaryOperator *Op0I = dyn_cast<BinaryOperator>(Op0)) {\n      // ((C1 OP zext(X)) & C2) -> zext((C1-X) & C2) if C2 fits in the bitwidth\n      // of X and OP behaves well when given trunc(C1) and X.\n      // TODO: Do this for vectors by using m_APInt instead of m_ConstantInt.\n      switch (Op0I->getOpcode()) {\n      default:\n        break;\n      case Instruction::Xor:\n      case Instruction::Or:\n      case Instruction::Mul:\n      case Instruction::Add:\n      case Instruction::Sub:\n        Value *X;\n        ConstantInt *C1;\n        // TODO: The one use restrictions could be relaxed a little if the AND\n        // is going to be removed.\n        if (match(Op0I, m_OneUse(m_c_BinOp(m_OneUse(m_ZExt(m_Value(X))),\n                                           m_ConstantInt(C1))))) {\n          if (AndRHSMask.isIntN(X->getType()->getScalarSizeInBits())) {\n            auto *TruncC1 = ConstantExpr::getTrunc(C1, X->getType());\n            Value *BinOp;\n            Value *Op0LHS = Op0I->getOperand(0);\n            if (isa<ZExtInst>(Op0LHS))\n              BinOp = Builder.CreateBinOp(Op0I->getOpcode(), X, TruncC1);\n            else\n              BinOp = Builder.CreateBinOp(Op0I->getOpcode(), TruncC1, X);\n            auto *TruncC2 = ConstantExpr::getTrunc(AndRHS, X->getType());\n            auto *And = Builder.CreateAnd(BinOp, TruncC2);\n            return new ZExtInst(And, Ty);\n          }\n        }\n      }\n    }\n  }\n\n  if (match(&I, m_And(m_OneUse(m_Shl(m_ZExt(m_Value(X)), m_Value(Y))),\n                      m_SignMask())) &&\n      match(Y, m_SpecificInt_ICMP(\n                   ICmpInst::Predicate::ICMP_EQ,\n                   APInt(Ty->getScalarSizeInBits(),\n                         Ty->getScalarSizeInBits() -\n                             X->getType()->getScalarSizeInBits())))) {\n    auto *SExt = Builder.CreateSExt(X, Ty, X->getName() + \".signext\");\n    auto *SanitizedSignMask = cast<Constant>(Op1);\n    // We must be careful with the undef elements of the sign bit mask, however:\n    // the mask elt can be undef iff the shift amount for that lane was undef,\n    // otherwise we need to sanitize undef masks to zero.\n    SanitizedSignMask = Constant::replaceUndefsWith(\n        SanitizedSignMask, ConstantInt::getNullValue(Ty->getScalarType()));\n    SanitizedSignMask =\n        Constant::mergeUndefsWith(SanitizedSignMask, cast<Constant>(Y));\n    return BinaryOperator::CreateAnd(SExt, SanitizedSignMask);\n  }\n\n  if (Instruction *Z = narrowMaskedBinOp(I))\n    return Z;\n\n  if (Instruction *FoldedLogic = foldBinOpIntoSelectOrPhi(I))\n    return FoldedLogic;\n\n  if (Instruction *DeMorgan = matchDeMorgansLaws(I, Builder))\n    return DeMorgan;\n\n  {\n    Value *A, *B, *C;\n    // A & (A ^ B) --> A & ~B\n    if (match(Op1, m_OneUse(m_c_Xor(m_Specific(Op0), m_Value(B)))))\n      return BinaryOperator::CreateAnd(Op0, Builder.CreateNot(B));\n    // (A ^ B) & A --> A & ~B\n    if (match(Op0, m_OneUse(m_c_Xor(m_Specific(Op1), m_Value(B)))))\n      return BinaryOperator::CreateAnd(Op1, Builder.CreateNot(B));\n\n    // A & ~(A ^ B) --> A & B\n    if (match(Op1, m_Not(m_c_Xor(m_Specific(Op0), m_Value(B)))))\n      return BinaryOperator::CreateAnd(Op0, B);\n    // ~(A ^ B) & A --> A & B\n    if (match(Op0, m_Not(m_c_Xor(m_Specific(Op1), m_Value(B)))))\n      return BinaryOperator::CreateAnd(Op1, B);\n\n    // (A ^ B) & ((B ^ C) ^ A) -> (A ^ B) & ~C\n    if (match(Op0, m_Xor(m_Value(A), m_Value(B))))\n      if (match(Op1, m_Xor(m_Xor(m_Specific(B), m_Value(C)), m_Specific(A))))\n        if (Op1->hasOneUse() || isFreeToInvert(C, C->hasOneUse()))\n          return BinaryOperator::CreateAnd(Op0, Builder.CreateNot(C));\n\n    // ((A ^ C) ^ B) & (B ^ A) -> (B ^ A) & ~C\n    if (match(Op0, m_Xor(m_Xor(m_Value(A), m_Value(C)), m_Value(B))))\n      if (match(Op1, m_Xor(m_Specific(B), m_Specific(A))))\n        if (Op0->hasOneUse() || isFreeToInvert(C, C->hasOneUse()))\n          return BinaryOperator::CreateAnd(Op1, Builder.CreateNot(C));\n\n    // (A | B) & ((~A) ^ B) -> (A & B)\n    // (A | B) & (B ^ (~A)) -> (A & B)\n    // (B | A) & ((~A) ^ B) -> (A & B)\n    // (B | A) & (B ^ (~A)) -> (A & B)\n    if (match(Op1, m_c_Xor(m_Not(m_Value(A)), m_Value(B))) &&\n        match(Op0, m_c_Or(m_Specific(A), m_Specific(B))))\n      return BinaryOperator::CreateAnd(A, B);\n\n    // ((~A) ^ B) & (A | B) -> (A & B)\n    // ((~A) ^ B) & (B | A) -> (A & B)\n    // (B ^ (~A)) & (A | B) -> (A & B)\n    // (B ^ (~A)) & (B | A) -> (A & B)\n    if (match(Op0, m_c_Xor(m_Not(m_Value(A)), m_Value(B))) &&\n        match(Op1, m_c_Or(m_Specific(A), m_Specific(B))))\n      return BinaryOperator::CreateAnd(A, B);\n  }\n\n  {\n    ICmpInst *LHS = dyn_cast<ICmpInst>(Op0);\n    ICmpInst *RHS = dyn_cast<ICmpInst>(Op1);\n    if (LHS && RHS)\n      if (Value *Res = foldAndOfICmps(LHS, RHS, I))\n        return replaceInstUsesWith(I, Res);\n\n    // TODO: Make this recursive; it's a little tricky because an arbitrary\n    // number of 'and' instructions might have to be created.\n    if (LHS && match(Op1, m_OneUse(m_And(m_Value(X), m_Value(Y))))) {\n      if (auto *Cmp = dyn_cast<ICmpInst>(X))\n        if (Value *Res = foldAndOfICmps(LHS, Cmp, I))\n          return replaceInstUsesWith(I, Builder.CreateAnd(Res, Y));\n      if (auto *Cmp = dyn_cast<ICmpInst>(Y))\n        if (Value *Res = foldAndOfICmps(LHS, Cmp, I))\n          return replaceInstUsesWith(I, Builder.CreateAnd(Res, X));\n    }\n    if (RHS && match(Op0, m_OneUse(m_And(m_Value(X), m_Value(Y))))) {\n      if (auto *Cmp = dyn_cast<ICmpInst>(X))\n        if (Value *Res = foldAndOfICmps(Cmp, RHS, I))\n          return replaceInstUsesWith(I, Builder.CreateAnd(Res, Y));\n      if (auto *Cmp = dyn_cast<ICmpInst>(Y))\n        if (Value *Res = foldAndOfICmps(Cmp, RHS, I))\n          return replaceInstUsesWith(I, Builder.CreateAnd(Res, X));\n    }\n  }\n\n  if (FCmpInst *LHS = dyn_cast<FCmpInst>(I.getOperand(0)))\n    if (FCmpInst *RHS = dyn_cast<FCmpInst>(I.getOperand(1)))\n      if (Value *Res = foldLogicOfFCmps(LHS, RHS, true))\n        return replaceInstUsesWith(I, Res);\n\n  if (Instruction *FoldedFCmps = reassociateFCmps(I, Builder))\n    return FoldedFCmps;\n\n  if (Instruction *CastedAnd = foldCastedBitwiseLogic(I))\n    return CastedAnd;\n\n  // and(sext(A), B) / and(B, sext(A)) --> A ? B : 0, where A is i1 or <N x i1>.\n  Value *A;\n  if (match(Op0, m_OneUse(m_SExt(m_Value(A)))) &&\n      A->getType()->isIntOrIntVectorTy(1))\n    return SelectInst::Create(A, Op1, Constant::getNullValue(Ty));\n  if (match(Op1, m_OneUse(m_SExt(m_Value(A)))) &&\n      A->getType()->isIntOrIntVectorTy(1))\n    return SelectInst::Create(A, Op0, Constant::getNullValue(Ty));\n\n  // and(ashr(subNSW(Y, X), ScalarSizeInBits(Y)-1), X) --> X s> Y ? X : 0.\n  if (match(&I, m_c_And(m_OneUse(m_AShr(\n                            m_NSWSub(m_Value(Y), m_Value(X)),\n                            m_SpecificInt(Ty->getScalarSizeInBits() - 1))),\n                        m_Deferred(X)))) {\n    Value *NewICmpInst = Builder.CreateICmpSGT(X, Y);\n    return SelectInst::Create(NewICmpInst, X, ConstantInt::getNullValue(Ty));\n  }\n\n  // (~x) & y  -->  ~(x | (~y))  iff that gets rid of inversions\n  if (sinkNotIntoOtherHandOfAndOrOr(I))\n    return &I;\n\n  return nullptr;\n}\n\nInstruction *InstCombinerImpl::matchBSwapOrBitReverse(BinaryOperator &Or,\n                                                      bool MatchBSwaps,\n                                                      bool MatchBitReversals) {\n  assert(Or.getOpcode() == Instruction::Or && \"bswap requires an 'or'\");\n  Value *Op0 = Or.getOperand(0), *Op1 = Or.getOperand(1);\n\n  // Look through zero extends.\n  if (Instruction *Ext = dyn_cast<ZExtInst>(Op0))\n    Op0 = Ext->getOperand(0);\n\n  if (Instruction *Ext = dyn_cast<ZExtInst>(Op1))\n    Op1 = Ext->getOperand(0);\n\n  // (A | B) | C  and  A | (B | C)                  -> bswap if possible.\n  bool OrWithOrs = match(Op0, m_Or(m_Value(), m_Value())) ||\n                   match(Op1, m_Or(m_Value(), m_Value()));\n\n  // (A >> B) | C  and  (A << B) | C                -> bswap if possible.\n  bool OrWithShifts = match(Op0, m_LogicalShift(m_Value(), m_Value())) ||\n                      match(Op1, m_LogicalShift(m_Value(), m_Value()));\n\n  // (A & B) | C  and  A | (B & C)                  -> bswap if possible.\n  bool OrWithAnds = match(Op0, m_And(m_Value(), m_Value())) ||\n                    match(Op1, m_And(m_Value(), m_Value()));\n\n  // fshl(A,B,C) | D  and  A | fshl(B,C,D)          -> bswap if possible.\n  // fshr(A,B,C) | D  and  A | fshr(B,C,D)          -> bswap if possible.\n  bool OrWithFunnels = match(Op0, m_FShl(m_Value(), m_Value(), m_Value())) ||\n                       match(Op0, m_FShr(m_Value(), m_Value(), m_Value())) ||\n                       match(Op0, m_FShl(m_Value(), m_Value(), m_Value())) ||\n                       match(Op0, m_FShr(m_Value(), m_Value(), m_Value()));\n\n  // TODO: Do we need all these filtering checks or should we just rely on\n  // recognizeBSwapOrBitReverseIdiom + collectBitParts to reject them quickly?\n  if (!OrWithOrs && !OrWithShifts && !OrWithAnds && !OrWithFunnels)\n    return nullptr;\n\n  SmallVector<Instruction *, 4> Insts;\n  if (!recognizeBSwapOrBitReverseIdiom(&Or, MatchBSwaps, MatchBitReversals,\n                                       Insts))\n    return nullptr;\n  Instruction *LastInst = Insts.pop_back_val();\n  LastInst->removeFromParent();\n\n  for (auto *Inst : Insts)\n    Worklist.push(Inst);\n  return LastInst;\n}\n\n/// Match UB-safe variants of the funnel shift intrinsic.\nstatic Instruction *matchFunnelShift(Instruction &Or, InstCombinerImpl &IC) {\n  // TODO: Can we reduce the code duplication between this and the related\n  // rotate matching code under visitSelect and visitTrunc?\n  unsigned Width = Or.getType()->getScalarSizeInBits();\n\n  // First, find an or'd pair of opposite shifts:\n  // or (lshr ShVal0, ShAmt0), (shl ShVal1, ShAmt1)\n  BinaryOperator *Or0, *Or1;\n  if (!match(Or.getOperand(0), m_BinOp(Or0)) ||\n      !match(Or.getOperand(1), m_BinOp(Or1)))\n    return nullptr;\n\n  Value *ShVal0, *ShVal1, *ShAmt0, *ShAmt1;\n  if (!match(Or0, m_OneUse(m_LogicalShift(m_Value(ShVal0), m_Value(ShAmt0)))) ||\n      !match(Or1, m_OneUse(m_LogicalShift(m_Value(ShVal1), m_Value(ShAmt1)))) ||\n      Or0->getOpcode() == Or1->getOpcode())\n    return nullptr;\n\n  // Canonicalize to or(shl(ShVal0, ShAmt0), lshr(ShVal1, ShAmt1)).\n  if (Or0->getOpcode() == BinaryOperator::LShr) {\n    std::swap(Or0, Or1);\n    std::swap(ShVal0, ShVal1);\n    std::swap(ShAmt0, ShAmt1);\n  }\n  assert(Or0->getOpcode() == BinaryOperator::Shl &&\n         Or1->getOpcode() == BinaryOperator::LShr &&\n         \"Illegal or(shift,shift) pair\");\n\n  // Match the shift amount operands for a funnel shift pattern. This always\n  // matches a subtraction on the R operand.\n  auto matchShiftAmount = [&](Value *L, Value *R, unsigned Width) -> Value * {\n    // Check for constant shift amounts that sum to the bitwidth.\n    const APInt *LI, *RI;\n    if (match(L, m_APIntAllowUndef(LI)) && match(R, m_APIntAllowUndef(RI)))\n      if (LI->ult(Width) && RI->ult(Width) && (*LI + *RI) == Width)\n        return ConstantInt::get(L->getType(), *LI);\n\n    Constant *LC, *RC;\n    if (match(L, m_Constant(LC)) && match(R, m_Constant(RC)) &&\n        match(L, m_SpecificInt_ICMP(ICmpInst::ICMP_ULT, APInt(Width, Width))) &&\n        match(R, m_SpecificInt_ICMP(ICmpInst::ICMP_ULT, APInt(Width, Width))) &&\n        match(ConstantExpr::getAdd(LC, RC), m_SpecificIntAllowUndef(Width)))\n      return ConstantExpr::mergeUndefsWith(LC, RC);\n\n    // (shl ShVal, X) | (lshr ShVal, (Width - x)) iff X < Width.\n    // We limit this to X < Width in case the backend re-expands the intrinsic,\n    // and has to reintroduce a shift modulo operation (InstCombine might remove\n    // it after this fold). This still doesn't guarantee that the final codegen\n    // will match this original pattern.\n    if (match(R, m_OneUse(m_Sub(m_SpecificInt(Width), m_Specific(L))))) {\n      KnownBits KnownL = IC.computeKnownBits(L, /*Depth*/ 0, &Or);\n      return KnownL.getMaxValue().ult(Width) ? L : nullptr;\n    }\n\n    // For non-constant cases, the following patterns currently only work for\n    // rotation patterns.\n    // TODO: Add general funnel-shift compatible patterns.\n    if (ShVal0 != ShVal1)\n      return nullptr;\n\n    // For non-constant cases we don't support non-pow2 shift masks.\n    // TODO: Is it worth matching urem as well?\n    if (!isPowerOf2_32(Width))\n      return nullptr;\n\n    // The shift amount may be masked with negation:\n    // (shl ShVal, (X & (Width - 1))) | (lshr ShVal, ((-X) & (Width - 1)))\n    Value *X;\n    unsigned Mask = Width - 1;\n    if (match(L, m_And(m_Value(X), m_SpecificInt(Mask))) &&\n        match(R, m_And(m_Neg(m_Specific(X)), m_SpecificInt(Mask))))\n      return X;\n\n    // Similar to above, but the shift amount may be extended after masking,\n    // so return the extended value as the parameter for the intrinsic.\n    if (match(L, m_ZExt(m_And(m_Value(X), m_SpecificInt(Mask)))) &&\n        match(R, m_And(m_Neg(m_ZExt(m_And(m_Specific(X), m_SpecificInt(Mask)))),\n                       m_SpecificInt(Mask))))\n      return L;\n\n    if (match(L, m_ZExt(m_And(m_Value(X), m_SpecificInt(Mask)))) &&\n        match(R, m_ZExt(m_And(m_Neg(m_Specific(X)), m_SpecificInt(Mask)))))\n      return L;\n\n    return nullptr;\n  };\n\n  Value *ShAmt = matchShiftAmount(ShAmt0, ShAmt1, Width);\n  bool IsFshl = true; // Sub on LSHR.\n  if (!ShAmt) {\n    ShAmt = matchShiftAmount(ShAmt1, ShAmt0, Width);\n    IsFshl = false; // Sub on SHL.\n  }\n  if (!ShAmt)\n    return nullptr;\n\n  Intrinsic::ID IID = IsFshl ? Intrinsic::fshl : Intrinsic::fshr;\n  Function *F = Intrinsic::getDeclaration(Or.getModule(), IID, Or.getType());\n  return IntrinsicInst::Create(F, {ShVal0, ShVal1, ShAmt});\n}\n\n/// Attempt to combine or(zext(x),shl(zext(y),bw/2) concat packing patterns.\nstatic Instruction *matchOrConcat(Instruction &Or,\n                                  InstCombiner::BuilderTy &Builder) {\n  assert(Or.getOpcode() == Instruction::Or && \"bswap requires an 'or'\");\n  Value *Op0 = Or.getOperand(0), *Op1 = Or.getOperand(1);\n  Type *Ty = Or.getType();\n\n  unsigned Width = Ty->getScalarSizeInBits();\n  if ((Width & 1) != 0)\n    return nullptr;\n  unsigned HalfWidth = Width / 2;\n\n  // Canonicalize zext (lower half) to LHS.\n  if (!isa<ZExtInst>(Op0))\n    std::swap(Op0, Op1);\n\n  // Find lower/upper half.\n  Value *LowerSrc, *ShlVal, *UpperSrc;\n  const APInt *C;\n  if (!match(Op0, m_OneUse(m_ZExt(m_Value(LowerSrc)))) ||\n      !match(Op1, m_OneUse(m_Shl(m_Value(ShlVal), m_APInt(C)))) ||\n      !match(ShlVal, m_OneUse(m_ZExt(m_Value(UpperSrc)))))\n    return nullptr;\n  if (*C != HalfWidth || LowerSrc->getType() != UpperSrc->getType() ||\n      LowerSrc->getType()->getScalarSizeInBits() != HalfWidth)\n    return nullptr;\n\n  auto ConcatIntrinsicCalls = [&](Intrinsic::ID id, Value *Lo, Value *Hi) {\n    Value *NewLower = Builder.CreateZExt(Lo, Ty);\n    Value *NewUpper = Builder.CreateZExt(Hi, Ty);\n    NewUpper = Builder.CreateShl(NewUpper, HalfWidth);\n    Value *BinOp = Builder.CreateOr(NewLower, NewUpper);\n    Function *F = Intrinsic::getDeclaration(Or.getModule(), id, Ty);\n    return Builder.CreateCall(F, BinOp);\n  };\n\n  // BSWAP: Push the concat down, swapping the lower/upper sources.\n  // concat(bswap(x),bswap(y)) -> bswap(concat(x,y))\n  Value *LowerBSwap, *UpperBSwap;\n  if (match(LowerSrc, m_BSwap(m_Value(LowerBSwap))) &&\n      match(UpperSrc, m_BSwap(m_Value(UpperBSwap))))\n    return ConcatIntrinsicCalls(Intrinsic::bswap, UpperBSwap, LowerBSwap);\n\n  // BITREVERSE: Push the concat down, swapping the lower/upper sources.\n  // concat(bitreverse(x),bitreverse(y)) -> bitreverse(concat(x,y))\n  Value *LowerBRev, *UpperBRev;\n  if (match(LowerSrc, m_BitReverse(m_Value(LowerBRev))) &&\n      match(UpperSrc, m_BitReverse(m_Value(UpperBRev))))\n    return ConcatIntrinsicCalls(Intrinsic::bitreverse, UpperBRev, LowerBRev);\n\n  return nullptr;\n}\n\n/// If all elements of two constant vectors are 0/-1 and inverses, return true.\nstatic bool areInverseVectorBitmasks(Constant *C1, Constant *C2) {\n  unsigned NumElts = cast<FixedVectorType>(C1->getType())->getNumElements();\n  for (unsigned i = 0; i != NumElts; ++i) {\n    Constant *EltC1 = C1->getAggregateElement(i);\n    Constant *EltC2 = C2->getAggregateElement(i);\n    if (!EltC1 || !EltC2)\n      return false;\n\n    // One element must be all ones, and the other must be all zeros.\n    if (!((match(EltC1, m_Zero()) && match(EltC2, m_AllOnes())) ||\n          (match(EltC2, m_Zero()) && match(EltC1, m_AllOnes()))))\n      return false;\n  }\n  return true;\n}\n\n/// We have an expression of the form (A & C) | (B & D). If A is a scalar or\n/// vector composed of all-zeros or all-ones values and is the bitwise 'not' of\n/// B, it can be used as the condition operand of a select instruction.\nValue *InstCombinerImpl::getSelectCondition(Value *A, Value *B) {\n  // Step 1: We may have peeked through bitcasts in the caller.\n  // Exit immediately if we don't have (vector) integer types.\n  Type *Ty = A->getType();\n  if (!Ty->isIntOrIntVectorTy() || !B->getType()->isIntOrIntVectorTy())\n    return nullptr;\n\n  // Step 2: We need 0 or all-1's bitmasks.\n  if (ComputeNumSignBits(A) != Ty->getScalarSizeInBits())\n    return nullptr;\n\n  // Step 3: If B is the 'not' value of A, we have our answer.\n  if (match(A, m_Not(m_Specific(B)))) {\n    // If these are scalars or vectors of i1, A can be used directly.\n    if (Ty->isIntOrIntVectorTy(1))\n      return A;\n    return Builder.CreateTrunc(A, CmpInst::makeCmpResultType(Ty));\n  }\n\n  // If both operands are constants, see if the constants are inverse bitmasks.\n  Constant *AConst, *BConst;\n  if (match(A, m_Constant(AConst)) && match(B, m_Constant(BConst)))\n    if (AConst == ConstantExpr::getNot(BConst))\n      return Builder.CreateZExtOrTrunc(A, CmpInst::makeCmpResultType(Ty));\n\n  // Look for more complex patterns. The 'not' op may be hidden behind various\n  // casts. Look through sexts and bitcasts to find the booleans.\n  Value *Cond;\n  Value *NotB;\n  if (match(A, m_SExt(m_Value(Cond))) &&\n      Cond->getType()->isIntOrIntVectorTy(1) &&\n      match(B, m_OneUse(m_Not(m_Value(NotB))))) {\n    NotB = peekThroughBitcast(NotB, true);\n    if (match(NotB, m_SExt(m_Specific(Cond))))\n      return Cond;\n  }\n\n  // All scalar (and most vector) possibilities should be handled now.\n  // Try more matches that only apply to non-splat constant vectors.\n  if (!Ty->isVectorTy())\n    return nullptr;\n\n  // If both operands are xor'd with constants using the same sexted boolean\n  // operand, see if the constants are inverse bitmasks.\n  // TODO: Use ConstantExpr::getNot()?\n  if (match(A, (m_Xor(m_SExt(m_Value(Cond)), m_Constant(AConst)))) &&\n      match(B, (m_Xor(m_SExt(m_Specific(Cond)), m_Constant(BConst)))) &&\n      Cond->getType()->isIntOrIntVectorTy(1) &&\n      areInverseVectorBitmasks(AConst, BConst)) {\n    AConst = ConstantExpr::getTrunc(AConst, CmpInst::makeCmpResultType(Ty));\n    return Builder.CreateXor(Cond, AConst);\n  }\n  return nullptr;\n}\n\n/// We have an expression of the form (A & C) | (B & D). Try to simplify this\n/// to \"A' ? C : D\", where A' is a boolean or vector of booleans.\nValue *InstCombinerImpl::matchSelectFromAndOr(Value *A, Value *C, Value *B,\n                                              Value *D) {\n  // The potential condition of the select may be bitcasted. In that case, look\n  // through its bitcast and the corresponding bitcast of the 'not' condition.\n  Type *OrigType = A->getType();\n  A = peekThroughBitcast(A, true);\n  B = peekThroughBitcast(B, true);\n  if (Value *Cond = getSelectCondition(A, B)) {\n    // ((bc Cond) & C) | ((bc ~Cond) & D) --> bc (select Cond, (bc C), (bc D))\n    // The bitcasts will either all exist or all not exist. The builder will\n    // not create unnecessary casts if the types already match.\n    Value *BitcastC = Builder.CreateBitCast(C, A->getType());\n    Value *BitcastD = Builder.CreateBitCast(D, A->getType());\n    Value *Select = Builder.CreateSelect(Cond, BitcastC, BitcastD);\n    return Builder.CreateBitCast(Select, OrigType);\n  }\n\n  return nullptr;\n}\n\n/// Fold (icmp)|(icmp) if possible.\nValue *InstCombinerImpl::foldOrOfICmps(ICmpInst *LHS, ICmpInst *RHS,\n                                       BinaryOperator &Or) {\n  const SimplifyQuery Q = SQ.getWithInstruction(&Or);\n\n  // Fold (iszero(A & K1) | iszero(A & K2)) ->  (A & (K1 | K2)) != (K1 | K2)\n  // if K1 and K2 are a one-bit mask.\n  if (Value *V = foldAndOrOfICmpsOfAndWithPow2(LHS, RHS, Or))\n    return V;\n\n  ICmpInst::Predicate PredL = LHS->getPredicate(), PredR = RHS->getPredicate();\n  Value *LHS0 = LHS->getOperand(0), *RHS0 = RHS->getOperand(0);\n  Value *LHS1 = LHS->getOperand(1), *RHS1 = RHS->getOperand(1);\n  auto *LHSC = dyn_cast<ConstantInt>(LHS1);\n  auto *RHSC = dyn_cast<ConstantInt>(RHS1);\n\n  // Fold (icmp ult/ule (A + C1), C3) | (icmp ult/ule (A + C2), C3)\n  //                   -->  (icmp ult/ule ((A & ~(C1 ^ C2)) + max(C1, C2)), C3)\n  // The original condition actually refers to the following two ranges:\n  // [MAX_UINT-C1+1, MAX_UINT-C1+1+C3] and [MAX_UINT-C2+1, MAX_UINT-C2+1+C3]\n  // We can fold these two ranges if:\n  // 1) C1 and C2 is unsigned greater than C3.\n  // 2) The two ranges are separated.\n  // 3) C1 ^ C2 is one-bit mask.\n  // 4) LowRange1 ^ LowRange2 and HighRange1 ^ HighRange2 are one-bit mask.\n  // This implies all values in the two ranges differ by exactly one bit.\n  if ((PredL == ICmpInst::ICMP_ULT || PredL == ICmpInst::ICMP_ULE) &&\n      PredL == PredR && LHSC && RHSC && LHS->hasOneUse() && RHS->hasOneUse() &&\n      LHSC->getType() == RHSC->getType() &&\n      LHSC->getValue() == (RHSC->getValue())) {\n\n    Value *AddOpnd;\n    ConstantInt *LAddC, *RAddC;\n    if (match(LHS0, m_Add(m_Value(AddOpnd), m_ConstantInt(LAddC))) &&\n        match(RHS0, m_Add(m_Specific(AddOpnd), m_ConstantInt(RAddC))) &&\n        LAddC->getValue().ugt(LHSC->getValue()) &&\n        RAddC->getValue().ugt(LHSC->getValue())) {\n\n      APInt DiffC = LAddC->getValue() ^ RAddC->getValue();\n      if (DiffC.isPowerOf2()) {\n        ConstantInt *MaxAddC = nullptr;\n        if (LAddC->getValue().ult(RAddC->getValue()))\n          MaxAddC = RAddC;\n        else\n          MaxAddC = LAddC;\n\n        APInt RRangeLow = -RAddC->getValue();\n        APInt RRangeHigh = RRangeLow + LHSC->getValue();\n        APInt LRangeLow = -LAddC->getValue();\n        APInt LRangeHigh = LRangeLow + LHSC->getValue();\n        APInt LowRangeDiff = RRangeLow ^ LRangeLow;\n        APInt HighRangeDiff = RRangeHigh ^ LRangeHigh;\n        APInt RangeDiff = LRangeLow.sgt(RRangeLow) ? LRangeLow - RRangeLow\n                                                   : RRangeLow - LRangeLow;\n\n        if (LowRangeDiff.isPowerOf2() && LowRangeDiff == HighRangeDiff &&\n            RangeDiff.ugt(LHSC->getValue())) {\n          Value *MaskC = ConstantInt::get(LAddC->getType(), ~DiffC);\n\n          Value *NewAnd = Builder.CreateAnd(AddOpnd, MaskC);\n          Value *NewAdd = Builder.CreateAdd(NewAnd, MaxAddC);\n          return Builder.CreateICmp(LHS->getPredicate(), NewAdd, LHSC);\n        }\n      }\n    }\n  }\n\n  // (icmp1 A, B) | (icmp2 A, B) --> (icmp3 A, B)\n  if (predicatesFoldable(PredL, PredR)) {\n    if (LHS0 == RHS1 && LHS1 == RHS0)\n      LHS->swapOperands();\n    if (LHS0 == RHS0 && LHS1 == RHS1) {\n      unsigned Code = getICmpCode(LHS) | getICmpCode(RHS);\n      bool IsSigned = LHS->isSigned() || RHS->isSigned();\n      return getNewICmpValue(Code, IsSigned, LHS0, LHS1, Builder);\n    }\n  }\n\n  // handle (roughly):\n  // (icmp ne (A & B), C) | (icmp ne (A & D), E)\n  if (Value *V = foldLogOpOfMaskedICmps(LHS, RHS, false, Builder))\n    return V;\n\n  if (LHS->hasOneUse() || RHS->hasOneUse()) {\n    // (icmp eq B, 0) | (icmp ult A, B) -> (icmp ule A, B-1)\n    // (icmp eq B, 0) | (icmp ugt B, A) -> (icmp ule A, B-1)\n    Value *A = nullptr, *B = nullptr;\n    if (PredL == ICmpInst::ICMP_EQ && match(LHS1, m_Zero())) {\n      B = LHS0;\n      if (PredR == ICmpInst::ICMP_ULT && LHS0 == RHS1)\n        A = RHS0;\n      else if (PredR == ICmpInst::ICMP_UGT && LHS0 == RHS0)\n        A = RHS1;\n    }\n    // (icmp ult A, B) | (icmp eq B, 0) -> (icmp ule A, B-1)\n    // (icmp ugt B, A) | (icmp eq B, 0) -> (icmp ule A, B-1)\n    else if (PredR == ICmpInst::ICMP_EQ && match(RHS1, m_Zero())) {\n      B = RHS0;\n      if (PredL == ICmpInst::ICMP_ULT && RHS0 == LHS1)\n        A = LHS0;\n      else if (PredL == ICmpInst::ICMP_UGT && RHS0 == LHS0)\n        A = LHS1;\n    }\n    if (A && B && B->getType()->isIntOrIntVectorTy())\n      return Builder.CreateICmp(\n          ICmpInst::ICMP_UGE,\n          Builder.CreateAdd(B, Constant::getAllOnesValue(B->getType())), A);\n  }\n\n  if (Value *V = foldAndOrOfICmpsWithConstEq(LHS, RHS, Or, Builder, Q))\n    return V;\n  if (Value *V = foldAndOrOfICmpsWithConstEq(RHS, LHS, Or, Builder, Q))\n    return V;\n\n  // E.g. (icmp slt x, 0) | (icmp sgt x, n) --> icmp ugt x, n\n  if (Value *V = simplifyRangeCheck(LHS, RHS, /*Inverted=*/true))\n    return V;\n\n  // E.g. (icmp sgt x, n) | (icmp slt x, 0) --> icmp ugt x, n\n  if (Value *V = simplifyRangeCheck(RHS, LHS, /*Inverted=*/true))\n    return V;\n\n  if (Value *V = foldAndOrOfEqualityCmpsWithConstants(LHS, RHS, false, Builder))\n    return V;\n\n  if (Value *V = foldIsPowerOf2(LHS, RHS, false /* JoinedByAnd */, Builder))\n    return V;\n\n  if (Value *X =\n          foldUnsignedUnderflowCheck(LHS, RHS, /*IsAnd=*/false, Q, Builder))\n    return X;\n  if (Value *X =\n          foldUnsignedUnderflowCheck(RHS, LHS, /*IsAnd=*/false, Q, Builder))\n    return X;\n\n  // (icmp ne A, 0) | (icmp ne B, 0) --> (icmp ne (A|B), 0)\n  // TODO: Remove this when foldLogOpOfMaskedICmps can handle vectors.\n  if (PredL == ICmpInst::ICMP_NE && match(LHS1, m_Zero()) &&\n      PredR == ICmpInst::ICMP_NE && match(RHS1, m_Zero()) &&\n      LHS0->getType()->isIntOrIntVectorTy() &&\n      LHS0->getType() == RHS0->getType()) {\n    Value *NewOr = Builder.CreateOr(LHS0, RHS0);\n    return Builder.CreateICmp(PredL, NewOr,\n                              Constant::getNullValue(NewOr->getType()));\n  }\n\n  // This only handles icmp of constants: (icmp1 A, C1) | (icmp2 B, C2).\n  if (!LHSC || !RHSC)\n    return nullptr;\n\n  // (icmp ult (X + CA), C1) | (icmp eq X, C2) -> (icmp ule (X + CA), C1)\n  //   iff C2 + CA == C1.\n  if (PredL == ICmpInst::ICMP_ULT && PredR == ICmpInst::ICMP_EQ) {\n    ConstantInt *AddC;\n    if (match(LHS0, m_Add(m_Specific(RHS0), m_ConstantInt(AddC))))\n      if (RHSC->getValue() + AddC->getValue() == LHSC->getValue())\n        return Builder.CreateICmpULE(LHS0, LHSC);\n  }\n\n  // From here on, we only handle:\n  //    (icmp1 A, C1) | (icmp2 A, C2) --> something simpler.\n  if (LHS0 != RHS0)\n    return nullptr;\n\n  // ICMP_[US][GL]E X, C is folded to ICMP_[US][GL]T elsewhere.\n  if (PredL == ICmpInst::ICMP_UGE || PredL == ICmpInst::ICMP_ULE ||\n      PredR == ICmpInst::ICMP_UGE || PredR == ICmpInst::ICMP_ULE ||\n      PredL == ICmpInst::ICMP_SGE || PredL == ICmpInst::ICMP_SLE ||\n      PredR == ICmpInst::ICMP_SGE || PredR == ICmpInst::ICMP_SLE)\n    return nullptr;\n\n  // We can't fold (ugt x, C) | (sgt x, C2).\n  if (!predicatesFoldable(PredL, PredR))\n    return nullptr;\n\n  // Ensure that the larger constant is on the RHS.\n  bool ShouldSwap;\n  if (CmpInst::isSigned(PredL) ||\n      (ICmpInst::isEquality(PredL) && CmpInst::isSigned(PredR)))\n    ShouldSwap = LHSC->getValue().sgt(RHSC->getValue());\n  else\n    ShouldSwap = LHSC->getValue().ugt(RHSC->getValue());\n\n  if (ShouldSwap) {\n    std::swap(LHS, RHS);\n    std::swap(LHSC, RHSC);\n    std::swap(PredL, PredR);\n  }\n\n  // At this point, we know we have two icmp instructions\n  // comparing a value against two constants and or'ing the result\n  // together.  Because of the above check, we know that we only have\n  // ICMP_EQ, ICMP_NE, ICMP_LT, and ICMP_GT here. We also know (from the\n  // icmp folding check above), that the two constants are not\n  // equal.\n  assert(LHSC != RHSC && \"Compares not folded above?\");\n\n  switch (PredL) {\n  default:\n    llvm_unreachable(\"Unknown integer condition code!\");\n  case ICmpInst::ICMP_EQ:\n    switch (PredR) {\n    default:\n      llvm_unreachable(\"Unknown integer condition code!\");\n    case ICmpInst::ICMP_EQ:\n      // Potential folds for this case should already be handled.\n      break;\n    case ICmpInst::ICMP_UGT:\n      // (X == 0 || X u> C) -> (X-1) u>= C\n      if (LHSC->isMinValue(false))\n        return insertRangeTest(LHS0, LHSC->getValue() + 1, RHSC->getValue() + 1,\n                               false, false);\n      // (X == 13 | X u> 14) -> no change\n      break;\n    case ICmpInst::ICMP_SGT:\n      // (X == INT_MIN || X s> C) -> (X-(INT_MIN+1)) u>= C-INT_MIN\n      if (LHSC->isMinValue(true))\n        return insertRangeTest(LHS0, LHSC->getValue() + 1, RHSC->getValue() + 1,\n                               true, false);\n      // (X == 13 | X s> 14) -> no change\n      break;\n    }\n    break;\n  case ICmpInst::ICMP_ULT:\n    switch (PredR) {\n    default:\n      llvm_unreachable(\"Unknown integer condition code!\");\n    case ICmpInst::ICMP_EQ: // (X u< 13 | X == 14) -> no change\n      // (X u< C || X == UINT_MAX) => (X-C) u>= UINT_MAX-C\n      if (RHSC->isMaxValue(false))\n        return insertRangeTest(LHS0, LHSC->getValue(), RHSC->getValue(),\n                               false, false);\n      break;\n    case ICmpInst::ICMP_UGT: // (X u< 13 | X u> 15) -> (X-13) u> 2\n      assert(!RHSC->isMaxValue(false) && \"Missed icmp simplification\");\n      return insertRangeTest(LHS0, LHSC->getValue(), RHSC->getValue() + 1,\n                             false, false);\n    }\n    break;\n  case ICmpInst::ICMP_SLT:\n    switch (PredR) {\n    default:\n      llvm_unreachable(\"Unknown integer condition code!\");\n    case ICmpInst::ICMP_EQ:\n      // (X s< C || X == INT_MAX) => (X-C) u>= INT_MAX-C\n      if (RHSC->isMaxValue(true))\n        return insertRangeTest(LHS0, LHSC->getValue(), RHSC->getValue(),\n                               true, false);\n      // (X s< 13 | X == 14) -> no change\n      break;\n    case ICmpInst::ICMP_SGT: // (X s< 13 | X s> 15) -> (X-13) u> 2\n      assert(!RHSC->isMaxValue(true) && \"Missed icmp simplification\");\n      return insertRangeTest(LHS0, LHSC->getValue(), RHSC->getValue() + 1, true,\n                             false);\n    }\n    break;\n  }\n  return nullptr;\n}\n\n// FIXME: We use commutative matchers (m_c_*) for some, but not all, matches\n// here. We should standardize that construct where it is needed or choose some\n// other way to ensure that commutated variants of patterns are not missed.\nInstruction *InstCombinerImpl::visitOr(BinaryOperator &I) {\n  if (Value *V = SimplifyOrInst(I.getOperand(0), I.getOperand(1),\n                                SQ.getWithInstruction(&I)))\n    return replaceInstUsesWith(I, V);\n\n  if (SimplifyAssociativeOrCommutative(I))\n    return &I;\n\n  if (Instruction *X = foldVectorBinop(I))\n    return X;\n\n  // See if we can simplify any instructions used by the instruction whose sole\n  // purpose is to compute bits we don't care about.\n  if (SimplifyDemandedInstructionBits(I))\n    return &I;\n\n  // Do this before using distributive laws to catch simple and/or/not patterns.\n  if (Instruction *Xor = foldOrToXor(I, Builder))\n    return Xor;\n\n  // (A&B)|(A&C) -> A&(B|C) etc\n  if (Value *V = SimplifyUsingDistributiveLaws(I))\n    return replaceInstUsesWith(I, V);\n\n  if (Value *V = SimplifyBSwap(I, Builder))\n    return replaceInstUsesWith(I, V);\n\n  if (Instruction *FoldedLogic = foldBinOpIntoSelectOrPhi(I))\n    return FoldedLogic;\n\n  if (Instruction *BSwap = matchBSwapOrBitReverse(I, /*MatchBSwaps*/ true,\n                                                  /*MatchBitReversals*/ false))\n    return BSwap;\n\n  if (Instruction *Funnel = matchFunnelShift(I, *this))\n    return Funnel;\n\n  if (Instruction *Concat = matchOrConcat(I, Builder))\n    return replaceInstUsesWith(I, Concat);\n\n  Value *X, *Y;\n  const APInt *CV;\n  if (match(&I, m_c_Or(m_OneUse(m_Xor(m_Value(X), m_APInt(CV))), m_Value(Y))) &&\n      !CV->isAllOnesValue() && MaskedValueIsZero(Y, *CV, 0, &I)) {\n    // (X ^ C) | Y -> (X | Y) ^ C iff Y & C == 0\n    // The check for a 'not' op is for efficiency (if Y is known zero --> ~X).\n    Value *Or = Builder.CreateOr(X, Y);\n    return BinaryOperator::CreateXor(Or, ConstantInt::get(I.getType(), *CV));\n  }\n\n  // (A & C)|(B & D)\n  Value *Op0 = I.getOperand(0), *Op1 = I.getOperand(1);\n  Value *A, *B, *C, *D;\n  if (match(Op0, m_And(m_Value(A), m_Value(C))) &&\n      match(Op1, m_And(m_Value(B), m_Value(D)))) {\n    // (A & C1)|(B & C2)\n    ConstantInt *C1, *C2;\n    if (match(C, m_ConstantInt(C1)) && match(D, m_ConstantInt(C2))) {\n      Value *V1 = nullptr, *V2 = nullptr;\n      if ((C1->getValue() & C2->getValue()).isNullValue()) {\n        // ((V | N) & C1) | (V & C2) --> (V|N) & (C1|C2)\n        // iff (C1&C2) == 0 and (N&~C1) == 0\n        if (match(A, m_Or(m_Value(V1), m_Value(V2))) &&\n            ((V1 == B &&\n              MaskedValueIsZero(V2, ~C1->getValue(), 0, &I)) || // (V|N)\n             (V2 == B &&\n              MaskedValueIsZero(V1, ~C1->getValue(), 0, &I))))  // (N|V)\n          return BinaryOperator::CreateAnd(A,\n                                Builder.getInt(C1->getValue()|C2->getValue()));\n        // Or commutes, try both ways.\n        if (match(B, m_Or(m_Value(V1), m_Value(V2))) &&\n            ((V1 == A &&\n              MaskedValueIsZero(V2, ~C2->getValue(), 0, &I)) || // (V|N)\n             (V2 == A &&\n              MaskedValueIsZero(V1, ~C2->getValue(), 0, &I))))  // (N|V)\n          return BinaryOperator::CreateAnd(B,\n                                 Builder.getInt(C1->getValue()|C2->getValue()));\n\n        // ((V|C3)&C1) | ((V|C4)&C2) --> (V|C3|C4)&(C1|C2)\n        // iff (C1&C2) == 0 and (C3&~C1) == 0 and (C4&~C2) == 0.\n        ConstantInt *C3 = nullptr, *C4 = nullptr;\n        if (match(A, m_Or(m_Value(V1), m_ConstantInt(C3))) &&\n            (C3->getValue() & ~C1->getValue()).isNullValue() &&\n            match(B, m_Or(m_Specific(V1), m_ConstantInt(C4))) &&\n            (C4->getValue() & ~C2->getValue()).isNullValue()) {\n          V2 = Builder.CreateOr(V1, ConstantExpr::getOr(C3, C4), \"bitfield\");\n          return BinaryOperator::CreateAnd(V2,\n                                 Builder.getInt(C1->getValue()|C2->getValue()));\n        }\n      }\n\n      if (C1->getValue() == ~C2->getValue()) {\n        Value *X;\n\n        // ((X|B)&C1)|(B&C2) -> (X&C1) | B iff C1 == ~C2\n        if (match(A, m_c_Or(m_Value(X), m_Specific(B))))\n          return BinaryOperator::CreateOr(Builder.CreateAnd(X, C1), B);\n        // (A&C2)|((X|A)&C1) -> (X&C2) | A iff C1 == ~C2\n        if (match(B, m_c_Or(m_Specific(A), m_Value(X))))\n          return BinaryOperator::CreateOr(Builder.CreateAnd(X, C2), A);\n\n        // ((X^B)&C1)|(B&C2) -> (X&C1) ^ B iff C1 == ~C2\n        if (match(A, m_c_Xor(m_Value(X), m_Specific(B))))\n          return BinaryOperator::CreateXor(Builder.CreateAnd(X, C1), B);\n        // (A&C2)|((X^A)&C1) -> (X&C2) ^ A iff C1 == ~C2\n        if (match(B, m_c_Xor(m_Specific(A), m_Value(X))))\n          return BinaryOperator::CreateXor(Builder.CreateAnd(X, C2), A);\n      }\n    }\n\n    // Don't try to form a select if it's unlikely that we'll get rid of at\n    // least one of the operands. A select is generally more expensive than the\n    // 'or' that it is replacing.\n    if (Op0->hasOneUse() || Op1->hasOneUse()) {\n      // (Cond & C) | (~Cond & D) -> Cond ? C : D, and commuted variants.\n      if (Value *V = matchSelectFromAndOr(A, C, B, D))\n        return replaceInstUsesWith(I, V);\n      if (Value *V = matchSelectFromAndOr(A, C, D, B))\n        return replaceInstUsesWith(I, V);\n      if (Value *V = matchSelectFromAndOr(C, A, B, D))\n        return replaceInstUsesWith(I, V);\n      if (Value *V = matchSelectFromAndOr(C, A, D, B))\n        return replaceInstUsesWith(I, V);\n      if (Value *V = matchSelectFromAndOr(B, D, A, C))\n        return replaceInstUsesWith(I, V);\n      if (Value *V = matchSelectFromAndOr(B, D, C, A))\n        return replaceInstUsesWith(I, V);\n      if (Value *V = matchSelectFromAndOr(D, B, A, C))\n        return replaceInstUsesWith(I, V);\n      if (Value *V = matchSelectFromAndOr(D, B, C, A))\n        return replaceInstUsesWith(I, V);\n    }\n  }\n\n  // (A ^ B) | ((B ^ C) ^ A) -> (A ^ B) | C\n  if (match(Op0, m_Xor(m_Value(A), m_Value(B))))\n    if (match(Op1, m_Xor(m_Xor(m_Specific(B), m_Value(C)), m_Specific(A))))\n      return BinaryOperator::CreateOr(Op0, C);\n\n  // ((A ^ C) ^ B) | (B ^ A) -> (B ^ A) | C\n  if (match(Op0, m_Xor(m_Xor(m_Value(A), m_Value(C)), m_Value(B))))\n    if (match(Op1, m_Xor(m_Specific(B), m_Specific(A))))\n      return BinaryOperator::CreateOr(Op1, C);\n\n  // ((B | C) & A) | B -> B | (A & C)\n  if (match(Op0, m_And(m_Or(m_Specific(Op1), m_Value(C)), m_Value(A))))\n    return BinaryOperator::CreateOr(Op1, Builder.CreateAnd(A, C));\n\n  if (Instruction *DeMorgan = matchDeMorgansLaws(I, Builder))\n    return DeMorgan;\n\n  // Canonicalize xor to the RHS.\n  bool SwappedForXor = false;\n  if (match(Op0, m_Xor(m_Value(), m_Value()))) {\n    std::swap(Op0, Op1);\n    SwappedForXor = true;\n  }\n\n  // A | ( A ^ B) -> A |  B\n  // A | (~A ^ B) -> A | ~B\n  // (A & B) | (A ^ B)\n  if (match(Op1, m_Xor(m_Value(A), m_Value(B)))) {\n    if (Op0 == A || Op0 == B)\n      return BinaryOperator::CreateOr(A, B);\n\n    if (match(Op0, m_And(m_Specific(A), m_Specific(B))) ||\n        match(Op0, m_And(m_Specific(B), m_Specific(A))))\n      return BinaryOperator::CreateOr(A, B);\n\n    if (Op1->hasOneUse() && match(A, m_Not(m_Specific(Op0)))) {\n      Value *Not = Builder.CreateNot(B, B->getName() + \".not\");\n      return BinaryOperator::CreateOr(Not, Op0);\n    }\n    if (Op1->hasOneUse() && match(B, m_Not(m_Specific(Op0)))) {\n      Value *Not = Builder.CreateNot(A, A->getName() + \".not\");\n      return BinaryOperator::CreateOr(Not, Op0);\n    }\n  }\n\n  // A | ~(A | B) -> A | ~B\n  // A | ~(A ^ B) -> A | ~B\n  if (match(Op1, m_Not(m_Value(A))))\n    if (BinaryOperator *B = dyn_cast<BinaryOperator>(A))\n      if ((Op0 == B->getOperand(0) || Op0 == B->getOperand(1)) &&\n          Op1->hasOneUse() && (B->getOpcode() == Instruction::Or ||\n                               B->getOpcode() == Instruction::Xor)) {\n        Value *NotOp = Op0 == B->getOperand(0) ? B->getOperand(1) :\n                                                 B->getOperand(0);\n        Value *Not = Builder.CreateNot(NotOp, NotOp->getName() + \".not\");\n        return BinaryOperator::CreateOr(Not, Op0);\n      }\n\n  if (SwappedForXor)\n    std::swap(Op0, Op1);\n\n  {\n    ICmpInst *LHS = dyn_cast<ICmpInst>(Op0);\n    ICmpInst *RHS = dyn_cast<ICmpInst>(Op1);\n    if (LHS && RHS)\n      if (Value *Res = foldOrOfICmps(LHS, RHS, I))\n        return replaceInstUsesWith(I, Res);\n\n    // TODO: Make this recursive; it's a little tricky because an arbitrary\n    // number of 'or' instructions might have to be created.\n    Value *X, *Y;\n    if (LHS && match(Op1, m_OneUse(m_Or(m_Value(X), m_Value(Y))))) {\n      if (auto *Cmp = dyn_cast<ICmpInst>(X))\n        if (Value *Res = foldOrOfICmps(LHS, Cmp, I))\n          return replaceInstUsesWith(I, Builder.CreateOr(Res, Y));\n      if (auto *Cmp = dyn_cast<ICmpInst>(Y))\n        if (Value *Res = foldOrOfICmps(LHS, Cmp, I))\n          return replaceInstUsesWith(I, Builder.CreateOr(Res, X));\n    }\n    if (RHS && match(Op0, m_OneUse(m_Or(m_Value(X), m_Value(Y))))) {\n      if (auto *Cmp = dyn_cast<ICmpInst>(X))\n        if (Value *Res = foldOrOfICmps(Cmp, RHS, I))\n          return replaceInstUsesWith(I, Builder.CreateOr(Res, Y));\n      if (auto *Cmp = dyn_cast<ICmpInst>(Y))\n        if (Value *Res = foldOrOfICmps(Cmp, RHS, I))\n          return replaceInstUsesWith(I, Builder.CreateOr(Res, X));\n    }\n  }\n\n  if (FCmpInst *LHS = dyn_cast<FCmpInst>(I.getOperand(0)))\n    if (FCmpInst *RHS = dyn_cast<FCmpInst>(I.getOperand(1)))\n      if (Value *Res = foldLogicOfFCmps(LHS, RHS, false))\n        return replaceInstUsesWith(I, Res);\n\n  if (Instruction *FoldedFCmps = reassociateFCmps(I, Builder))\n    return FoldedFCmps;\n\n  if (Instruction *CastedOr = foldCastedBitwiseLogic(I))\n    return CastedOr;\n\n  // or(sext(A), B) / or(B, sext(A)) --> A ? -1 : B, where A is i1 or <N x i1>.\n  if (match(Op0, m_OneUse(m_SExt(m_Value(A)))) &&\n      A->getType()->isIntOrIntVectorTy(1))\n    return SelectInst::Create(A, ConstantInt::getSigned(I.getType(), -1), Op1);\n  if (match(Op1, m_OneUse(m_SExt(m_Value(A)))) &&\n      A->getType()->isIntOrIntVectorTy(1))\n    return SelectInst::Create(A, ConstantInt::getSigned(I.getType(), -1), Op0);\n\n  // Note: If we've gotten to the point of visiting the outer OR, then the\n  // inner one couldn't be simplified.  If it was a constant, then it won't\n  // be simplified by a later pass either, so we try swapping the inner/outer\n  // ORs in the hopes that we'll be able to simplify it this way.\n  // (X|C) | V --> (X|V) | C\n  ConstantInt *CI;\n  if (Op0->hasOneUse() && !match(Op1, m_ConstantInt()) &&\n      match(Op0, m_Or(m_Value(A), m_ConstantInt(CI)))) {\n    Value *Inner = Builder.CreateOr(A, Op1);\n    Inner->takeName(Op0);\n    return BinaryOperator::CreateOr(Inner, CI);\n  }\n\n  // Change (or (bool?A:B),(bool?C:D)) --> (bool?(or A,C):(or B,D))\n  // Since this OR statement hasn't been optimized further yet, we hope\n  // that this transformation will allow the new ORs to be optimized.\n  {\n    Value *X = nullptr, *Y = nullptr;\n    if (Op0->hasOneUse() && Op1->hasOneUse() &&\n        match(Op0, m_Select(m_Value(X), m_Value(A), m_Value(B))) &&\n        match(Op1, m_Select(m_Value(Y), m_Value(C), m_Value(D))) && X == Y) {\n      Value *orTrue = Builder.CreateOr(A, C);\n      Value *orFalse = Builder.CreateOr(B, D);\n      return SelectInst::Create(X, orTrue, orFalse);\n    }\n  }\n\n  // or(ashr(subNSW(Y, X), ScalarSizeInBits(Y) - 1), X)  --> X s> Y ? -1 : X.\n  {\n    Value *X, *Y;\n    Type *Ty = I.getType();\n    if (match(&I, m_c_Or(m_OneUse(m_AShr(\n                             m_NSWSub(m_Value(Y), m_Value(X)),\n                             m_SpecificInt(Ty->getScalarSizeInBits() - 1))),\n                         m_Deferred(X)))) {\n      Value *NewICmpInst = Builder.CreateICmpSGT(X, Y);\n      Value *AllOnes = ConstantInt::getAllOnesValue(Ty);\n      return SelectInst::Create(NewICmpInst, AllOnes, X);\n    }\n  }\n\n  if (Instruction *V =\n          canonicalizeCondSignextOfHighBitExtractToSignextHighBitExtract(I))\n    return V;\n\n  CmpInst::Predicate Pred;\n  Value *Mul, *Ov, *MulIsNotZero, *UMulWithOv;\n  // Check if the OR weakens the overflow condition for umul.with.overflow by\n  // treating any non-zero result as overflow. In that case, we overflow if both\n  // umul.with.overflow operands are != 0, as in that case the result can only\n  // be 0, iff the multiplication overflows.\n  if (match(&I,\n            m_c_Or(m_CombineAnd(m_ExtractValue<1>(m_Value(UMulWithOv)),\n                                m_Value(Ov)),\n                   m_CombineAnd(m_ICmp(Pred,\n                                       m_CombineAnd(m_ExtractValue<0>(\n                                                        m_Deferred(UMulWithOv)),\n                                                    m_Value(Mul)),\n                                       m_ZeroInt()),\n                                m_Value(MulIsNotZero)))) &&\n      (Ov->hasOneUse() || (MulIsNotZero->hasOneUse() && Mul->hasOneUse())) &&\n      Pred == CmpInst::ICMP_NE) {\n    Value *A, *B;\n    if (match(UMulWithOv, m_Intrinsic<Intrinsic::umul_with_overflow>(\n                              m_Value(A), m_Value(B)))) {\n      Value *NotNullA = Builder.CreateIsNotNull(A);\n      Value *NotNullB = Builder.CreateIsNotNull(B);\n      return BinaryOperator::CreateAnd(NotNullA, NotNullB);\n    }\n  }\n\n  // (~x) | y  -->  ~(x & (~y))  iff that gets rid of inversions\n  if (sinkNotIntoOtherHandOfAndOrOr(I))\n    return &I;\n\n  return nullptr;\n}\n\n/// A ^ B can be specified using other logic ops in a variety of patterns. We\n/// can fold these early and efficiently by morphing an existing instruction.\nstatic Instruction *foldXorToXor(BinaryOperator &I,\n                                 InstCombiner::BuilderTy &Builder) {\n  assert(I.getOpcode() == Instruction::Xor);\n  Value *Op0 = I.getOperand(0);\n  Value *Op1 = I.getOperand(1);\n  Value *A, *B;\n\n  // There are 4 commuted variants for each of the basic patterns.\n\n  // (A & B) ^ (A | B) -> A ^ B\n  // (A & B) ^ (B | A) -> A ^ B\n  // (A | B) ^ (A & B) -> A ^ B\n  // (A | B) ^ (B & A) -> A ^ B\n  if (match(&I, m_c_Xor(m_And(m_Value(A), m_Value(B)),\n                        m_c_Or(m_Deferred(A), m_Deferred(B)))))\n    return BinaryOperator::CreateXor(A, B);\n\n  // (A | ~B) ^ (~A | B) -> A ^ B\n  // (~B | A) ^ (~A | B) -> A ^ B\n  // (~A | B) ^ (A | ~B) -> A ^ B\n  // (B | ~A) ^ (A | ~B) -> A ^ B\n  if (match(&I, m_Xor(m_c_Or(m_Value(A), m_Not(m_Value(B))),\n                      m_c_Or(m_Not(m_Deferred(A)), m_Deferred(B)))))\n    return BinaryOperator::CreateXor(A, B);\n\n  // (A & ~B) ^ (~A & B) -> A ^ B\n  // (~B & A) ^ (~A & B) -> A ^ B\n  // (~A & B) ^ (A & ~B) -> A ^ B\n  // (B & ~A) ^ (A & ~B) -> A ^ B\n  if (match(&I, m_Xor(m_c_And(m_Value(A), m_Not(m_Value(B))),\n                      m_c_And(m_Not(m_Deferred(A)), m_Deferred(B)))))\n    return BinaryOperator::CreateXor(A, B);\n\n  // For the remaining cases we need to get rid of one of the operands.\n  if (!Op0->hasOneUse() && !Op1->hasOneUse())\n    return nullptr;\n\n  // (A | B) ^ ~(A & B) -> ~(A ^ B)\n  // (A | B) ^ ~(B & A) -> ~(A ^ B)\n  // (A & B) ^ ~(A | B) -> ~(A ^ B)\n  // (A & B) ^ ~(B | A) -> ~(A ^ B)\n  // Complexity sorting ensures the not will be on the right side.\n  if ((match(Op0, m_Or(m_Value(A), m_Value(B))) &&\n       match(Op1, m_Not(m_c_And(m_Specific(A), m_Specific(B))))) ||\n      (match(Op0, m_And(m_Value(A), m_Value(B))) &&\n       match(Op1, m_Not(m_c_Or(m_Specific(A), m_Specific(B))))))\n    return BinaryOperator::CreateNot(Builder.CreateXor(A, B));\n\n  return nullptr;\n}\n\nValue *InstCombinerImpl::foldXorOfICmps(ICmpInst *LHS, ICmpInst *RHS,\n                                        BinaryOperator &I) {\n  assert(I.getOpcode() == Instruction::Xor && I.getOperand(0) == LHS &&\n         I.getOperand(1) == RHS && \"Should be 'xor' with these operands\");\n\n  if (predicatesFoldable(LHS->getPredicate(), RHS->getPredicate())) {\n    if (LHS->getOperand(0) == RHS->getOperand(1) &&\n        LHS->getOperand(1) == RHS->getOperand(0))\n      LHS->swapOperands();\n    if (LHS->getOperand(0) == RHS->getOperand(0) &&\n        LHS->getOperand(1) == RHS->getOperand(1)) {\n      // (icmp1 A, B) ^ (icmp2 A, B) --> (icmp3 A, B)\n      Value *Op0 = LHS->getOperand(0), *Op1 = LHS->getOperand(1);\n      unsigned Code = getICmpCode(LHS) ^ getICmpCode(RHS);\n      bool IsSigned = LHS->isSigned() || RHS->isSigned();\n      return getNewICmpValue(Code, IsSigned, Op0, Op1, Builder);\n    }\n  }\n\n  // TODO: This can be generalized to compares of non-signbits using\n  // decomposeBitTestICmp(). It could be enhanced more by using (something like)\n  // foldLogOpOfMaskedICmps().\n  ICmpInst::Predicate PredL = LHS->getPredicate(), PredR = RHS->getPredicate();\n  Value *LHS0 = LHS->getOperand(0), *LHS1 = LHS->getOperand(1);\n  Value *RHS0 = RHS->getOperand(0), *RHS1 = RHS->getOperand(1);\n  if ((LHS->hasOneUse() || RHS->hasOneUse()) &&\n      LHS0->getType() == RHS0->getType() &&\n      LHS0->getType()->isIntOrIntVectorTy()) {\n    // (X > -1) ^ (Y > -1) --> (X ^ Y) < 0\n    // (X <  0) ^ (Y <  0) --> (X ^ Y) < 0\n    if ((PredL == CmpInst::ICMP_SGT && match(LHS1, m_AllOnes()) &&\n         PredR == CmpInst::ICMP_SGT && match(RHS1, m_AllOnes())) ||\n        (PredL == CmpInst::ICMP_SLT && match(LHS1, m_Zero()) &&\n         PredR == CmpInst::ICMP_SLT && match(RHS1, m_Zero()))) {\n      Value *Zero = ConstantInt::getNullValue(LHS0->getType());\n      return Builder.CreateICmpSLT(Builder.CreateXor(LHS0, RHS0), Zero);\n    }\n    // (X > -1) ^ (Y <  0) --> (X ^ Y) > -1\n    // (X <  0) ^ (Y > -1) --> (X ^ Y) > -1\n    if ((PredL == CmpInst::ICMP_SGT && match(LHS1, m_AllOnes()) &&\n         PredR == CmpInst::ICMP_SLT && match(RHS1, m_Zero())) ||\n        (PredL == CmpInst::ICMP_SLT && match(LHS1, m_Zero()) &&\n         PredR == CmpInst::ICMP_SGT && match(RHS1, m_AllOnes()))) {\n      Value *MinusOne = ConstantInt::getAllOnesValue(LHS0->getType());\n      return Builder.CreateICmpSGT(Builder.CreateXor(LHS0, RHS0), MinusOne);\n    }\n  }\n\n  // Instead of trying to imitate the folds for and/or, decompose this 'xor'\n  // into those logic ops. That is, try to turn this into an and-of-icmps\n  // because we have many folds for that pattern.\n  //\n  // This is based on a truth table definition of xor:\n  // X ^ Y --> (X | Y) & !(X & Y)\n  if (Value *OrICmp = SimplifyBinOp(Instruction::Or, LHS, RHS, SQ)) {\n    // TODO: If OrICmp is true, then the definition of xor simplifies to !(X&Y).\n    // TODO: If OrICmp is false, the whole thing is false (InstSimplify?).\n    if (Value *AndICmp = SimplifyBinOp(Instruction::And, LHS, RHS, SQ)) {\n      // TODO: Independently handle cases where the 'and' side is a constant.\n      ICmpInst *X = nullptr, *Y = nullptr;\n      if (OrICmp == LHS && AndICmp == RHS) {\n        // (LHS | RHS) & !(LHS & RHS) --> LHS & !RHS  --> X & !Y\n        X = LHS;\n        Y = RHS;\n      }\n      if (OrICmp == RHS && AndICmp == LHS) {\n        // !(LHS & RHS) & (LHS | RHS) --> !LHS & RHS  --> !Y & X\n        X = RHS;\n        Y = LHS;\n      }\n      if (X && Y && (Y->hasOneUse() || canFreelyInvertAllUsersOf(Y, &I))) {\n        // Invert the predicate of 'Y', thus inverting its output.\n        Y->setPredicate(Y->getInversePredicate());\n        // So, are there other uses of Y?\n        if (!Y->hasOneUse()) {\n          // We need to adapt other uses of Y though. Get a value that matches\n          // the original value of Y before inversion. While this increases\n          // immediate instruction count, we have just ensured that all the\n          // users are freely-invertible, so that 'not' *will* get folded away.\n          BuilderTy::InsertPointGuard Guard(Builder);\n          // Set insertion point to right after the Y.\n          Builder.SetInsertPoint(Y->getParent(), ++(Y->getIterator()));\n          Value *NotY = Builder.CreateNot(Y, Y->getName() + \".not\");\n          // Replace all uses of Y (excluding the one in NotY!) with NotY.\n          Worklist.pushUsersToWorkList(*Y);\n          Y->replaceUsesWithIf(NotY,\n                               [NotY](Use &U) { return U.getUser() != NotY; });\n        }\n        // All done.\n        return Builder.CreateAnd(LHS, RHS);\n      }\n    }\n  }\n\n  return nullptr;\n}\n\n/// If we have a masked merge, in the canonical form of:\n/// (assuming that A only has one use.)\n///   |        A  |  |B|\n///   ((x ^ y) & M) ^ y\n///    |  D  |\n/// * If M is inverted:\n///      |  D  |\n///     ((x ^ y) & ~M) ^ y\n///   We can canonicalize by swapping the final xor operand\n///   to eliminate the 'not' of the mask.\n///     ((x ^ y) & M) ^ x\n/// * If M is a constant, and D has one use, we transform to 'and' / 'or' ops\n///   because that shortens the dependency chain and improves analysis:\n///     (x & M) | (y & ~M)\nstatic Instruction *visitMaskedMerge(BinaryOperator &I,\n                                     InstCombiner::BuilderTy &Builder) {\n  Value *B, *X, *D;\n  Value *M;\n  if (!match(&I, m_c_Xor(m_Value(B),\n                         m_OneUse(m_c_And(\n                             m_CombineAnd(m_c_Xor(m_Deferred(B), m_Value(X)),\n                                          m_Value(D)),\n                             m_Value(M))))))\n    return nullptr;\n\n  Value *NotM;\n  if (match(M, m_Not(m_Value(NotM)))) {\n    // De-invert the mask and swap the value in B part.\n    Value *NewA = Builder.CreateAnd(D, NotM);\n    return BinaryOperator::CreateXor(NewA, X);\n  }\n\n  Constant *C;\n  if (D->hasOneUse() && match(M, m_Constant(C))) {\n    // Propagating undef is unsafe. Clamp undef elements to -1.\n    Type *EltTy = C->getType()->getScalarType();\n    C = Constant::replaceUndefsWith(C, ConstantInt::getAllOnesValue(EltTy));\n    // Unfold.\n    Value *LHS = Builder.CreateAnd(X, C);\n    Value *NotC = Builder.CreateNot(C);\n    Value *RHS = Builder.CreateAnd(B, NotC);\n    return BinaryOperator::CreateOr(LHS, RHS);\n  }\n\n  return nullptr;\n}\n\n// Transform\n//   ~(x ^ y)\n// into:\n//   (~x) ^ y\n// or into\n//   x ^ (~y)\nstatic Instruction *sinkNotIntoXor(BinaryOperator &I,\n                                   InstCombiner::BuilderTy &Builder) {\n  Value *X, *Y;\n  // FIXME: one-use check is not needed in general, but currently we are unable\n  // to fold 'not' into 'icmp', if that 'icmp' has multiple uses. (D35182)\n  if (!match(&I, m_Not(m_OneUse(m_Xor(m_Value(X), m_Value(Y))))))\n    return nullptr;\n\n  // We only want to do the transform if it is free to do.\n  if (InstCombiner::isFreeToInvert(X, X->hasOneUse())) {\n    // Ok, good.\n  } else if (InstCombiner::isFreeToInvert(Y, Y->hasOneUse())) {\n    std::swap(X, Y);\n  } else\n    return nullptr;\n\n  Value *NotX = Builder.CreateNot(X, X->getName() + \".not\");\n  return BinaryOperator::CreateXor(NotX, Y, I.getName() + \".demorgan\");\n}\n\n// Transform\n//   z = (~x) &/| y\n// into:\n//   z = ~(x |/& (~y))\n// iff y is free to invert and all uses of z can be freely updated.\nbool InstCombinerImpl::sinkNotIntoOtherHandOfAndOrOr(BinaryOperator &I) {\n  Instruction::BinaryOps NewOpc;\n  switch (I.getOpcode()) {\n  case Instruction::And:\n    NewOpc = Instruction::Or;\n    break;\n  case Instruction::Or:\n    NewOpc = Instruction::And;\n    break;\n  default:\n    return false;\n  };\n\n  Value *X, *Y;\n  if (!match(&I, m_c_BinOp(m_Not(m_Value(X)), m_Value(Y))))\n    return false;\n\n  // Will we be able to fold the `not` into Y eventually?\n  if (!InstCombiner::isFreeToInvert(Y, Y->hasOneUse()))\n    return false;\n\n  // And can our users be adapted?\n  if (!InstCombiner::canFreelyInvertAllUsersOf(&I, /*IgnoredUser=*/nullptr))\n    return false;\n\n  Value *NotY = Builder.CreateNot(Y, Y->getName() + \".not\");\n  Value *NewBinOp =\n      BinaryOperator::Create(NewOpc, X, NotY, I.getName() + \".not\");\n  Builder.Insert(NewBinOp);\n  replaceInstUsesWith(I, NewBinOp);\n  // We can not just create an outer `not`, it will most likely be immediately\n  // folded back, reconstructing our initial pattern, and causing an\n  // infinite combine loop, so immediately manually fold it away.\n  freelyInvertAllUsersOf(NewBinOp);\n  return true;\n}\n\n// FIXME: We use commutative matchers (m_c_*) for some, but not all, matches\n// here. We should standardize that construct where it is needed or choose some\n// other way to ensure that commutated variants of patterns are not missed.\nInstruction *InstCombinerImpl::visitXor(BinaryOperator &I) {\n  if (Value *V = SimplifyXorInst(I.getOperand(0), I.getOperand(1),\n                                 SQ.getWithInstruction(&I)))\n    return replaceInstUsesWith(I, V);\n\n  if (SimplifyAssociativeOrCommutative(I))\n    return &I;\n\n  if (Instruction *X = foldVectorBinop(I))\n    return X;\n\n  if (Instruction *NewXor = foldXorToXor(I, Builder))\n    return NewXor;\n\n  // (A&B)^(A&C) -> A&(B^C) etc\n  if (Value *V = SimplifyUsingDistributiveLaws(I))\n    return replaceInstUsesWith(I, V);\n\n  // See if we can simplify any instructions used by the instruction whose sole\n  // purpose is to compute bits we don't care about.\n  if (SimplifyDemandedInstructionBits(I))\n    return &I;\n\n  if (Value *V = SimplifyBSwap(I, Builder))\n    return replaceInstUsesWith(I, V);\n\n  Value *Op0 = I.getOperand(0), *Op1 = I.getOperand(1);\n  Type *Ty = I.getType();\n\n  // Fold (X & M) ^ (Y & ~M) -> (X & M) | (Y & ~M)\n  // This it a special case in haveNoCommonBitsSet, but the computeKnownBits\n  // calls in there are unnecessary as SimplifyDemandedInstructionBits should\n  // have already taken care of those cases.\n  Value *M;\n  if (match(&I, m_c_Xor(m_c_And(m_Not(m_Value(M)), m_Value()),\n                        m_c_And(m_Deferred(M), m_Value()))))\n    return BinaryOperator::CreateOr(Op0, Op1);\n\n  // Apply DeMorgan's Law for 'nand' / 'nor' logic with an inverted operand.\n  Value *X, *Y;\n\n  // We must eliminate the and/or (one-use) for these transforms to not increase\n  // the instruction count.\n  // ~(~X & Y) --> (X | ~Y)\n  // ~(Y & ~X) --> (X | ~Y)\n  if (match(&I, m_Not(m_OneUse(m_c_And(m_Not(m_Value(X)), m_Value(Y)))))) {\n    Value *NotY = Builder.CreateNot(Y, Y->getName() + \".not\");\n    return BinaryOperator::CreateOr(X, NotY);\n  }\n  // ~(~X | Y) --> (X & ~Y)\n  // ~(Y | ~X) --> (X & ~Y)\n  if (match(&I, m_Not(m_OneUse(m_c_Or(m_Not(m_Value(X)), m_Value(Y)))))) {\n    Value *NotY = Builder.CreateNot(Y, Y->getName() + \".not\");\n    return BinaryOperator::CreateAnd(X, NotY);\n  }\n\n  if (Instruction *Xor = visitMaskedMerge(I, Builder))\n    return Xor;\n\n  // Is this a 'not' (~) fed by a binary operator?\n  BinaryOperator *NotVal;\n  if (match(&I, m_Not(m_BinOp(NotVal)))) {\n    if (NotVal->getOpcode() == Instruction::And ||\n        NotVal->getOpcode() == Instruction::Or) {\n      // Apply DeMorgan's Law when inverts are free:\n      // ~(X & Y) --> (~X | ~Y)\n      // ~(X | Y) --> (~X & ~Y)\n      if (isFreeToInvert(NotVal->getOperand(0),\n                         NotVal->getOperand(0)->hasOneUse()) &&\n          isFreeToInvert(NotVal->getOperand(1),\n                         NotVal->getOperand(1)->hasOneUse())) {\n        Value *NotX = Builder.CreateNot(NotVal->getOperand(0), \"notlhs\");\n        Value *NotY = Builder.CreateNot(NotVal->getOperand(1), \"notrhs\");\n        if (NotVal->getOpcode() == Instruction::And)\n          return BinaryOperator::CreateOr(NotX, NotY);\n        return BinaryOperator::CreateAnd(NotX, NotY);\n      }\n    }\n\n    // ~(X - Y) --> ~X + Y\n    if (match(NotVal, m_Sub(m_Value(X), m_Value(Y))))\n      if (isa<Constant>(X) || NotVal->hasOneUse())\n        return BinaryOperator::CreateAdd(Builder.CreateNot(X), Y);\n\n    // ~(~X >>s Y) --> (X >>s Y)\n    if (match(NotVal, m_AShr(m_Not(m_Value(X)), m_Value(Y))))\n      return BinaryOperator::CreateAShr(X, Y);\n\n    // If we are inverting a right-shifted constant, we may be able to eliminate\n    // the 'not' by inverting the constant and using the opposite shift type.\n    // Canonicalization rules ensure that only a negative constant uses 'ashr',\n    // but we must check that in case that transform has not fired yet.\n\n    // ~(C >>s Y) --> ~C >>u Y (when inverting the replicated sign bits)\n    Constant *C;\n    if (match(NotVal, m_AShr(m_Constant(C), m_Value(Y))) &&\n        match(C, m_Negative())) {\n      // We matched a negative constant, so propagating undef is unsafe.\n      // Clamp undef elements to -1.\n      Type *EltTy = Ty->getScalarType();\n      C = Constant::replaceUndefsWith(C, ConstantInt::getAllOnesValue(EltTy));\n      return BinaryOperator::CreateLShr(ConstantExpr::getNot(C), Y);\n    }\n\n    // ~(C >>u Y) --> ~C >>s Y (when inverting the replicated sign bits)\n    if (match(NotVal, m_LShr(m_Constant(C), m_Value(Y))) &&\n        match(C, m_NonNegative())) {\n      // We matched a non-negative constant, so propagating undef is unsafe.\n      // Clamp undef elements to 0.\n      Type *EltTy = Ty->getScalarType();\n      C = Constant::replaceUndefsWith(C, ConstantInt::getNullValue(EltTy));\n      return BinaryOperator::CreateAShr(ConstantExpr::getNot(C), Y);\n    }\n\n    // ~(X + C) --> -(C + 1) - X\n    if (match(Op0, m_Add(m_Value(X), m_Constant(C))))\n      return BinaryOperator::CreateSub(ConstantExpr::getNeg(AddOne(C)), X);\n\n    // ~(~X + Y) --> X - Y\n    if (match(NotVal, m_c_Add(m_Not(m_Value(X)), m_Value(Y))))\n      return BinaryOperator::CreateWithCopiedFlags(Instruction::Sub, X, Y,\n                                                   NotVal);\n  }\n\n  // Use DeMorgan and reassociation to eliminate a 'not' op.\n  Constant *C1;\n  if (match(Op1, m_Constant(C1))) {\n    Constant *C2;\n    if (match(Op0, m_OneUse(m_Or(m_Not(m_Value(X)), m_Constant(C2))))) {\n      // (~X | C2) ^ C1 --> ((X & ~C2) ^ -1) ^ C1 --> (X & ~C2) ^ ~C1\n      Value *And = Builder.CreateAnd(X, ConstantExpr::getNot(C2));\n      return BinaryOperator::CreateXor(And, ConstantExpr::getNot(C1));\n    }\n    if (match(Op0, m_OneUse(m_And(m_Not(m_Value(X)), m_Constant(C2))))) {\n      // (~X & C2) ^ C1 --> ((X | ~C2) ^ -1) ^ C1 --> (X | ~C2) ^ ~C1\n      Value *Or = Builder.CreateOr(X, ConstantExpr::getNot(C2));\n      return BinaryOperator::CreateXor(Or, ConstantExpr::getNot(C1));\n    }\n  }\n\n  // not (cmp A, B) = !cmp A, B\n  CmpInst::Predicate Pred;\n  if (match(&I, m_Not(m_OneUse(m_Cmp(Pred, m_Value(), m_Value()))))) {\n    cast<CmpInst>(Op0)->setPredicate(CmpInst::getInversePredicate(Pred));\n    return replaceInstUsesWith(I, Op0);\n  }\n\n  {\n    const APInt *RHSC;\n    if (match(Op1, m_APInt(RHSC))) {\n      Value *X;\n      const APInt *C;\n      // (C - X) ^ signmaskC --> (C + signmaskC) - X\n      if (RHSC->isSignMask() && match(Op0, m_Sub(m_APInt(C), m_Value(X))))\n        return BinaryOperator::CreateSub(ConstantInt::get(Ty, *C + *RHSC), X);\n\n      // (X + C) ^ signmaskC --> X + (C + signmaskC)\n      if (RHSC->isSignMask() && match(Op0, m_Add(m_Value(X), m_APInt(C))))\n        return BinaryOperator::CreateAdd(X, ConstantInt::get(Ty, *C + *RHSC));\n\n      // (X | C) ^ RHSC --> X ^ (C ^ RHSC) iff X & C == 0\n      if (match(Op0, m_Or(m_Value(X), m_APInt(C))) &&\n          MaskedValueIsZero(X, *C, 0, &I))\n        return BinaryOperator::CreateXor(X, ConstantInt::get(Ty, *C ^ *RHSC));\n\n      // If RHSC is inverting the remaining bits of shifted X,\n      // canonicalize to a 'not' before the shift to help SCEV and codegen:\n      // (X << C) ^ RHSC --> ~X << C\n      if (match(Op0, m_OneUse(m_Shl(m_Value(X), m_APInt(C)))) &&\n          *RHSC == APInt::getAllOnesValue(Ty->getScalarSizeInBits()).shl(*C)) {\n        Value *NotX = Builder.CreateNot(X);\n        return BinaryOperator::CreateShl(NotX, ConstantInt::get(Ty, *C));\n      }\n      // (X >>u C) ^ RHSC --> ~X >>u C\n      if (match(Op0, m_OneUse(m_LShr(m_Value(X), m_APInt(C)))) &&\n          *RHSC == APInt::getAllOnesValue(Ty->getScalarSizeInBits()).lshr(*C)) {\n        Value *NotX = Builder.CreateNot(X);\n        return BinaryOperator::CreateLShr(NotX, ConstantInt::get(Ty, *C));\n      }\n      // TODO: We could handle 'ashr' here as well. That would be matching\n      //       a 'not' op and moving it before the shift. Doing that requires\n      //       preventing the inverse fold in canShiftBinOpWithConstantRHS().\n    }\n  }\n\n  // FIXME: This should not be limited to scalar (pull into APInt match above).\n  {\n    Value *X;\n    ConstantInt *C1, *C2, *C3;\n    // ((X^C1) >> C2) ^ C3 -> (X>>C2) ^ ((C1>>C2)^C3)\n    if (match(Op1, m_ConstantInt(C3)) &&\n        match(Op0, m_LShr(m_Xor(m_Value(X), m_ConstantInt(C1)),\n                          m_ConstantInt(C2))) &&\n        Op0->hasOneUse()) {\n      // fold (C1 >> C2) ^ C3\n      APInt FoldConst = C1->getValue().lshr(C2->getValue());\n      FoldConst ^= C3->getValue();\n      // Prepare the two operands.\n      auto *Opnd0 = cast<Instruction>(Builder.CreateLShr(X, C2));\n      Opnd0->takeName(cast<Instruction>(Op0));\n      Opnd0->setDebugLoc(I.getDebugLoc());\n      return BinaryOperator::CreateXor(Opnd0, ConstantInt::get(Ty, FoldConst));\n    }\n  }\n\n  if (Instruction *FoldedLogic = foldBinOpIntoSelectOrPhi(I))\n    return FoldedLogic;\n\n  // Y ^ (X | Y) --> X & ~Y\n  // Y ^ (Y | X) --> X & ~Y\n  if (match(Op1, m_OneUse(m_c_Or(m_Value(X), m_Specific(Op0)))))\n    return BinaryOperator::CreateAnd(X, Builder.CreateNot(Op0));\n  // (X | Y) ^ Y --> X & ~Y\n  // (Y | X) ^ Y --> X & ~Y\n  if (match(Op0, m_OneUse(m_c_Or(m_Value(X), m_Specific(Op1)))))\n    return BinaryOperator::CreateAnd(X, Builder.CreateNot(Op1));\n\n  // Y ^ (X & Y) --> ~X & Y\n  // Y ^ (Y & X) --> ~X & Y\n  if (match(Op1, m_OneUse(m_c_And(m_Value(X), m_Specific(Op0)))))\n    return BinaryOperator::CreateAnd(Op0, Builder.CreateNot(X));\n  // (X & Y) ^ Y --> ~X & Y\n  // (Y & X) ^ Y --> ~X & Y\n  // Canonical form is (X & C) ^ C; don't touch that.\n  // TODO: A 'not' op is better for analysis and codegen, but demanded bits must\n  //       be fixed to prefer that (otherwise we get infinite looping).\n  if (!match(Op1, m_Constant()) &&\n      match(Op0, m_OneUse(m_c_And(m_Value(X), m_Specific(Op1)))))\n    return BinaryOperator::CreateAnd(Op1, Builder.CreateNot(X));\n\n  Value *A, *B, *C;\n  // (A ^ B) ^ (A | C) --> (~A & C) ^ B -- There are 4 commuted variants.\n  if (match(&I, m_c_Xor(m_OneUse(m_Xor(m_Value(A), m_Value(B))),\n                        m_OneUse(m_c_Or(m_Deferred(A), m_Value(C))))))\n      return BinaryOperator::CreateXor(\n          Builder.CreateAnd(Builder.CreateNot(A), C), B);\n\n  // (A ^ B) ^ (B | C) --> (~B & C) ^ A -- There are 4 commuted variants.\n  if (match(&I, m_c_Xor(m_OneUse(m_Xor(m_Value(A), m_Value(B))),\n                        m_OneUse(m_c_Or(m_Deferred(B), m_Value(C))))))\n      return BinaryOperator::CreateXor(\n          Builder.CreateAnd(Builder.CreateNot(B), C), A);\n\n  // (A & B) ^ (A ^ B) -> (A | B)\n  if (match(Op0, m_And(m_Value(A), m_Value(B))) &&\n      match(Op1, m_c_Xor(m_Specific(A), m_Specific(B))))\n    return BinaryOperator::CreateOr(A, B);\n  // (A ^ B) ^ (A & B) -> (A | B)\n  if (match(Op0, m_Xor(m_Value(A), m_Value(B))) &&\n      match(Op1, m_c_And(m_Specific(A), m_Specific(B))))\n    return BinaryOperator::CreateOr(A, B);\n\n  // (A & ~B) ^ ~A -> ~(A & B)\n  // (~B & A) ^ ~A -> ~(A & B)\n  if (match(Op0, m_c_And(m_Value(A), m_Not(m_Value(B)))) &&\n      match(Op1, m_Not(m_Specific(A))))\n    return BinaryOperator::CreateNot(Builder.CreateAnd(A, B));\n\n  // (~A & B) ^ A --> A | B -- There are 4 commuted variants.\n  if (match(&I, m_c_Xor(m_c_And(m_Not(m_Value(A)), m_Value(B)), m_Deferred(A))))\n    return BinaryOperator::CreateOr(A, B);\n\n  // (A | B) ^ (A | C) --> (B ^ C) & ~A -- There are 4 commuted variants.\n  // TODO: Loosen one-use restriction if common operand is a constant.\n  Value *D;\n  if (match(Op0, m_OneUse(m_Or(m_Value(A), m_Value(B)))) &&\n      match(Op1, m_OneUse(m_Or(m_Value(C), m_Value(D))))) {\n    if (B == C || B == D)\n      std::swap(A, B);\n    if (A == C)\n      std::swap(C, D);\n    if (A == D) {\n      Value *NotA = Builder.CreateNot(A);\n      return BinaryOperator::CreateAnd(Builder.CreateXor(B, C), NotA);\n    }\n  }\n\n  if (auto *LHS = dyn_cast<ICmpInst>(I.getOperand(0)))\n    if (auto *RHS = dyn_cast<ICmpInst>(I.getOperand(1)))\n      if (Value *V = foldXorOfICmps(LHS, RHS, I))\n        return replaceInstUsesWith(I, V);\n\n  if (Instruction *CastedXor = foldCastedBitwiseLogic(I))\n    return CastedXor;\n\n  // Canonicalize a shifty way to code absolute value to the common pattern.\n  // There are 4 potential commuted variants. Move the 'ashr' candidate to Op1.\n  // We're relying on the fact that we only do this transform when the shift has\n  // exactly 2 uses and the add has exactly 1 use (otherwise, we might increase\n  // instructions).\n  if (Op0->hasNUses(2))\n    std::swap(Op0, Op1);\n\n  const APInt *ShAmt;\n  if (match(Op1, m_AShr(m_Value(A), m_APInt(ShAmt))) &&\n      Op1->hasNUses(2) && *ShAmt == Ty->getScalarSizeInBits() - 1 &&\n      match(Op0, m_OneUse(m_c_Add(m_Specific(A), m_Specific(Op1))))) {\n    // B = ashr i32 A, 31 ; smear the sign bit\n    // xor (add A, B), B  ; add -1 and flip bits if negative\n    // --> (A < 0) ? -A : A\n    Value *Cmp = Builder.CreateICmpSLT(A, ConstantInt::getNullValue(Ty));\n    // Copy the nuw/nsw flags from the add to the negate.\n    auto *Add = cast<BinaryOperator>(Op0);\n    Value *Neg = Builder.CreateNeg(A, \"\", Add->hasNoUnsignedWrap(),\n                                   Add->hasNoSignedWrap());\n    return SelectInst::Create(Cmp, Neg, A);\n  }\n\n  // Eliminate a bitwise 'not' op of 'not' min/max by inverting the min/max:\n  //\n  //   %notx = xor i32 %x, -1\n  //   %cmp1 = icmp sgt i32 %notx, %y\n  //   %smax = select i1 %cmp1, i32 %notx, i32 %y\n  //   %res = xor i32 %smax, -1\n  // =>\n  //   %noty = xor i32 %y, -1\n  //   %cmp2 = icmp slt %x, %noty\n  //   %res = select i1 %cmp2, i32 %x, i32 %noty\n  //\n  // Same is applicable for smin/umax/umin.\n  if (match(Op1, m_AllOnes()) && Op0->hasOneUse()) {\n    Value *LHS, *RHS;\n    SelectPatternFlavor SPF = matchSelectPattern(Op0, LHS, RHS).Flavor;\n    if (SelectPatternResult::isMinOrMax(SPF)) {\n      // It's possible we get here before the not has been simplified, so make\n      // sure the input to the not isn't freely invertible.\n      if (match(LHS, m_Not(m_Value(X))) && !isFreeToInvert(X, X->hasOneUse())) {\n        Value *NotY = Builder.CreateNot(RHS);\n        return SelectInst::Create(\n            Builder.CreateICmp(getInverseMinMaxPred(SPF), X, NotY), X, NotY);\n      }\n\n      // It's possible we get here before the not has been simplified, so make\n      // sure the input to the not isn't freely invertible.\n      if (match(RHS, m_Not(m_Value(Y))) && !isFreeToInvert(Y, Y->hasOneUse())) {\n        Value *NotX = Builder.CreateNot(LHS);\n        return SelectInst::Create(\n            Builder.CreateICmp(getInverseMinMaxPred(SPF), NotX, Y), NotX, Y);\n      }\n\n      // If both sides are freely invertible, then we can get rid of the xor\n      // completely.\n      if (isFreeToInvert(LHS, !LHS->hasNUsesOrMore(3)) &&\n          isFreeToInvert(RHS, !RHS->hasNUsesOrMore(3))) {\n        Value *NotLHS = Builder.CreateNot(LHS);\n        Value *NotRHS = Builder.CreateNot(RHS);\n        return SelectInst::Create(\n            Builder.CreateICmp(getInverseMinMaxPred(SPF), NotLHS, NotRHS),\n            NotLHS, NotRHS);\n      }\n    }\n\n    // Pull 'not' into operands of select if both operands are one-use compares\n    // or one is one-use compare and the other one is a constant.\n    // Inverting the predicates eliminates the 'not' operation.\n    // Example:\n    //   not (select ?, (cmp TPred, ?, ?), (cmp FPred, ?, ?) -->\n    //     select ?, (cmp InvTPred, ?, ?), (cmp InvFPred, ?, ?)\n    //   not (select ?, (cmp TPred, ?, ?), true -->\n    //     select ?, (cmp InvTPred, ?, ?), false\n    if (auto *Sel = dyn_cast<SelectInst>(Op0)) {\n      Value *TV = Sel->getTrueValue();\n      Value *FV = Sel->getFalseValue();\n      auto *CmpT = dyn_cast<CmpInst>(TV);\n      auto *CmpF = dyn_cast<CmpInst>(FV);\n      bool InvertibleT = (CmpT && CmpT->hasOneUse()) || isa<Constant>(TV);\n      bool InvertibleF = (CmpF && CmpF->hasOneUse()) || isa<Constant>(FV);\n      if (InvertibleT && InvertibleF) {\n        if (CmpT)\n          CmpT->setPredicate(CmpT->getInversePredicate());\n        else\n          Sel->setTrueValue(ConstantExpr::getNot(cast<Constant>(TV)));\n        if (CmpF)\n          CmpF->setPredicate(CmpF->getInversePredicate());\n        else\n          Sel->setFalseValue(ConstantExpr::getNot(cast<Constant>(FV)));\n        return replaceInstUsesWith(I, Sel);\n      }\n    }\n  }\n\n  if (Instruction *NewXor = sinkNotIntoXor(I, Builder))\n    return NewXor;\n\n  // Otherwise, if all else failed, try to hoist the xor-by-constant:\n  //   (X ^ C) ^ Y --> (X ^ Y) ^ C\n  // Just like we do in other places, we completely avoid the fold\n  // for constantexprs, at least to avoid endless combine loop.\n  if (match(&I, m_c_Xor(m_OneUse(m_Xor(m_CombineAnd(m_Value(X),\n                                                    m_Unless(m_ConstantExpr())),\n                                       m_ImmConstant(C1))),\n                        m_Value(Y))))\n    return BinaryOperator::CreateXor(Builder.CreateXor(X, Y), C1);\n\n  return nullptr;\n}\n"}, "3": {"id": 3, "path": "/home/vsts/work/1/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineInternal.h", "content": "//===- InstCombineInternal.h - InstCombine pass internals -------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n/// \\file\n///\n/// This file provides internal interfaces used to implement the InstCombine.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_LIB_TRANSFORMS_INSTCOMBINE_INSTCOMBINEINTERNAL_H\n#define LLVM_LIB_TRANSFORMS_INSTCOMBINE_INSTCOMBINEINTERNAL_H\n\n#include \"llvm/ADT/Statistic.h\"\n#include \"llvm/Analysis/InstructionSimplify.h\"\n#include \"llvm/Analysis/TargetFolder.h\"\n#include \"llvm/Analysis/ValueTracking.h\"\n#include \"llvm/IR/IRBuilder.h\"\n#include \"llvm/IR/InstVisitor.h\"\n#include \"llvm/IR/PatternMatch.h\"\n#include \"llvm/Support/Debug.h\"\n#include \"llvm/Support/KnownBits.h\"\n#include \"llvm/Transforms/InstCombine/InstCombineWorklist.h\"\n#include \"llvm/Transforms/InstCombine/InstCombiner.h\"\n#include \"llvm/Transforms/Utils/Local.h\"\n#include <cassert>\n\n#define DEBUG_TYPE \"instcombine\"\n\nusing namespace llvm::PatternMatch;\n\n// As a default, let's assume that we want to be aggressive,\n// and attempt to traverse with no limits in attempt to sink negation.\nstatic constexpr unsigned NegatorDefaultMaxDepth = ~0U;\n\n// Let's guesstimate that most often we will end up visiting/producing\n// fairly small number of new instructions.\nstatic constexpr unsigned NegatorMaxNodesSSO = 16;\n\nnamespace llvm {\n\nclass AAResults;\nclass APInt;\nclass AssumptionCache;\nclass BlockFrequencyInfo;\nclass DataLayout;\nclass DominatorTree;\nclass GEPOperator;\nclass GlobalVariable;\nclass LoopInfo;\nclass OptimizationRemarkEmitter;\nclass ProfileSummaryInfo;\nclass TargetLibraryInfo;\nclass User;\n\nclass LLVM_LIBRARY_VISIBILITY InstCombinerImpl final\n    : public InstCombiner,\n      public InstVisitor<InstCombinerImpl, Instruction *> {\npublic:\n  InstCombinerImpl(InstCombineWorklist &Worklist, BuilderTy &Builder,\n                   bool MinimizeSize, AAResults *AA, AssumptionCache &AC,\n                   TargetLibraryInfo &TLI, TargetTransformInfo &TTI,\n                   DominatorTree &DT, OptimizationRemarkEmitter &ORE,\n                   BlockFrequencyInfo *BFI, ProfileSummaryInfo *PSI,\n                   const DataLayout &DL, LoopInfo *LI)\n      : InstCombiner(Worklist, Builder, MinimizeSize, AA, AC, TLI, TTI, DT, ORE,\n                     BFI, PSI, DL, LI) {}\n\n  virtual ~InstCombinerImpl() {}\n\n  /// Run the combiner over the entire worklist until it is empty.\n  ///\n  /// \\returns true if the IR is changed.\n  bool run();\n\n  // Visitation implementation - Implement instruction combining for different\n  // instruction types.  The semantics are as follows:\n  // Return Value:\n  //    null        - No change was made\n  //     I          - Change was made, I is still valid, I may be dead though\n  //   otherwise    - Change was made, replace I with returned instruction\n  //\n  Instruction *visitFNeg(UnaryOperator &I);\n  Instruction *visitAdd(BinaryOperator &I);\n  Instruction *visitFAdd(BinaryOperator &I);\n  Value *OptimizePointerDifference(\n      Value *LHS, Value *RHS, Type *Ty, bool isNUW);\n  Instruction *visitSub(BinaryOperator &I);\n  Instruction *visitFSub(BinaryOperator &I);\n  Instruction *visitMul(BinaryOperator &I);\n  Instruction *visitFMul(BinaryOperator &I);\n  Instruction *visitURem(BinaryOperator &I);\n  Instruction *visitSRem(BinaryOperator &I);\n  Instruction *visitFRem(BinaryOperator &I);\n  bool simplifyDivRemOfSelectWithZeroOp(BinaryOperator &I);\n  Instruction *commonIRemTransforms(BinaryOperator &I);\n  Instruction *commonIDivTransforms(BinaryOperator &I);\n  Instruction *visitUDiv(BinaryOperator &I);\n  Instruction *visitSDiv(BinaryOperator &I);\n  Instruction *visitFDiv(BinaryOperator &I);\n  Value *simplifyRangeCheck(ICmpInst *Cmp0, ICmpInst *Cmp1, bool Inverted);\n  Instruction *visitAnd(BinaryOperator &I);\n  Instruction *visitOr(BinaryOperator &I);\n  bool sinkNotIntoOtherHandOfAndOrOr(BinaryOperator &I);\n  Instruction *visitXor(BinaryOperator &I);\n  Instruction *visitShl(BinaryOperator &I);\n  Value *reassociateShiftAmtsOfTwoSameDirectionShifts(\n      BinaryOperator *Sh0, const SimplifyQuery &SQ,\n      bool AnalyzeForSignBitExtraction = false);\n  Instruction *canonicalizeCondSignextOfHighBitExtractToSignextHighBitExtract(\n      BinaryOperator &I);\n  Instruction *foldVariableSignZeroExtensionOfVariableHighBitExtract(\n      BinaryOperator &OldAShr);\n  Instruction *visitAShr(BinaryOperator &I);\n  Instruction *visitLShr(BinaryOperator &I);\n  Instruction *commonShiftTransforms(BinaryOperator &I);\n  Instruction *visitFCmpInst(FCmpInst &I);\n  CmpInst *canonicalizeICmpPredicate(CmpInst &I);\n  Instruction *visitICmpInst(ICmpInst &I);\n  Instruction *FoldShiftByConstant(Value *Op0, Constant *Op1,\n                                   BinaryOperator &I);\n  Instruction *commonCastTransforms(CastInst &CI);\n  Instruction *commonPointerCastTransforms(CastInst &CI);\n  Instruction *visitTrunc(TruncInst &CI);\n  Instruction *visitZExt(ZExtInst &CI);\n  Instruction *visitSExt(SExtInst &CI);\n  Instruction *visitFPTrunc(FPTruncInst &CI);\n  Instruction *visitFPExt(CastInst &CI);\n  Instruction *visitFPToUI(FPToUIInst &FI);\n  Instruction *visitFPToSI(FPToSIInst &FI);\n  Instruction *visitUIToFP(CastInst &CI);\n  Instruction *visitSIToFP(CastInst &CI);\n  Instruction *visitPtrToInt(PtrToIntInst &CI);\n  Instruction *visitIntToPtr(IntToPtrInst &CI);\n  Instruction *visitBitCast(BitCastInst &CI);\n  Instruction *visitAddrSpaceCast(AddrSpaceCastInst &CI);\n  Instruction *foldItoFPtoI(CastInst &FI);\n  Instruction *visitSelectInst(SelectInst &SI);\n  Instruction *visitCallInst(CallInst &CI);\n  Instruction *visitInvokeInst(InvokeInst &II);\n  Instruction *visitCallBrInst(CallBrInst &CBI);\n\n  Instruction *SliceUpIllegalIntegerPHI(PHINode &PN);\n  Instruction *visitPHINode(PHINode &PN);\n  Instruction *visitGetElementPtrInst(GetElementPtrInst &GEP);\n  Instruction *visitAllocaInst(AllocaInst &AI);\n  Instruction *visitAllocSite(Instruction &FI);\n  Instruction *visitFree(CallInst &FI);\n  Instruction *visitLoadInst(LoadInst &LI);\n  Instruction *visitStoreInst(StoreInst &SI);\n  Instruction *visitAtomicRMWInst(AtomicRMWInst &SI);\n  Instruction *visitUnconditionalBranchInst(BranchInst &BI);\n  Instruction *visitBranchInst(BranchInst &BI);\n  Instruction *visitFenceInst(FenceInst &FI);\n  Instruction *visitSwitchInst(SwitchInst &SI);\n  Instruction *visitReturnInst(ReturnInst &RI);\n  Instruction *visitUnreachableInst(UnreachableInst &I);\n  Instruction *\n  foldAggregateConstructionIntoAggregateReuse(InsertValueInst &OrigIVI);\n  Instruction *visitInsertValueInst(InsertValueInst &IV);\n  Instruction *visitInsertElementInst(InsertElementInst &IE);\n  Instruction *visitExtractElementInst(ExtractElementInst &EI);\n  Instruction *visitShuffleVectorInst(ShuffleVectorInst &SVI);\n  Instruction *visitExtractValueInst(ExtractValueInst &EV);\n  Instruction *visitLandingPadInst(LandingPadInst &LI);\n  Instruction *visitVAEndInst(VAEndInst &I);\n  Instruction *visitFreeze(FreezeInst &I);\n\n  /// Specify what to return for unhandled instructions.\n  Instruction *visitInstruction(Instruction &I) { return nullptr; }\n\n  /// True when DB dominates all uses of DI except UI.\n  /// UI must be in the same block as DI.\n  /// The routine checks that the DI parent and DB are different.\n  bool dominatesAllUses(const Instruction *DI, const Instruction *UI,\n                        const BasicBlock *DB) const;\n\n  /// Try to replace select with select operand SIOpd in SI-ICmp sequence.\n  bool replacedSelectWithOperand(SelectInst *SI, const ICmpInst *Icmp,\n                                 const unsigned SIOpd);\n\n  LoadInst *combineLoadToNewType(LoadInst &LI, Type *NewTy,\n                                 const Twine &Suffix = \"\");\n\nprivate:\n  bool shouldChangeType(unsigned FromBitWidth, unsigned ToBitWidth) const;\n  bool shouldChangeType(Type *From, Type *To) const;\n  Value *dyn_castNegVal(Value *V) const;\n  Type *FindElementAtOffset(PointerType *PtrTy, int64_t Offset,\n                            SmallVectorImpl<Value *> &NewIndices);\n\n  /// Classify whether a cast is worth optimizing.\n  ///\n  /// This is a helper to decide whether the simplification of\n  /// logic(cast(A), cast(B)) to cast(logic(A, B)) should be performed.\n  ///\n  /// \\param CI The cast we are interested in.\n  ///\n  /// \\return true if this cast actually results in any code being generated and\n  /// if it cannot already be eliminated by some other transformation.\n  bool shouldOptimizeCast(CastInst *CI);\n\n  /// Try to optimize a sequence of instructions checking if an operation\n  /// on LHS and RHS overflows.\n  ///\n  /// If this overflow check is done via one of the overflow check intrinsics,\n  /// then CtxI has to be the call instruction calling that intrinsic.  If this\n  /// overflow check is done by arithmetic followed by a compare, then CtxI has\n  /// to be the arithmetic instruction.\n  ///\n  /// If a simplification is possible, stores the simplified result of the\n  /// operation in OperationResult and result of the overflow check in\n  /// OverflowResult, and return true.  If no simplification is possible,\n  /// returns false.\n  bool OptimizeOverflowCheck(Instruction::BinaryOps BinaryOp, bool IsSigned,\n                             Value *LHS, Value *RHS,\n                             Instruction &CtxI, Value *&OperationResult,\n                             Constant *&OverflowResult);\n\n  Instruction *visitCallBase(CallBase &Call);\n  Instruction *tryOptimizeCall(CallInst *CI);\n  bool transformConstExprCastCall(CallBase &Call);\n  Instruction *transformCallThroughTrampoline(CallBase &Call,\n                                              IntrinsicInst &Tramp);\n\n  Value *simplifyMaskedLoad(IntrinsicInst &II);\n  Instruction *simplifyMaskedStore(IntrinsicInst &II);\n  Instruction *simplifyMaskedGather(IntrinsicInst &II);\n  Instruction *simplifyMaskedScatter(IntrinsicInst &II);\n\n  /// Transform (zext icmp) to bitwise / integer operations in order to\n  /// eliminate it.\n  ///\n  /// \\param ICI The icmp of the (zext icmp) pair we are interested in.\n  /// \\parem CI The zext of the (zext icmp) pair we are interested in.\n  /// \\param DoTransform Pass false to just test whether the given (zext icmp)\n  /// would be transformed. Pass true to actually perform the transformation.\n  ///\n  /// \\return null if the transformation cannot be performed. If the\n  /// transformation can be performed the new instruction that replaces the\n  /// (zext icmp) pair will be returned (if \\p DoTransform is false the\n  /// unmodified \\p ICI will be returned in this case).\n  Instruction *transformZExtICmp(ICmpInst *ICI, ZExtInst &CI,\n                                 bool DoTransform = true);\n\n  Instruction *transformSExtICmp(ICmpInst *ICI, Instruction &CI);\n\n  bool willNotOverflowSignedAdd(const Value *LHS, const Value *RHS,\n                                const Instruction &CxtI) const {\n    return computeOverflowForSignedAdd(LHS, RHS, &CxtI) ==\n           OverflowResult::NeverOverflows;\n  }\n\n  bool willNotOverflowUnsignedAdd(const Value *LHS, const Value *RHS,\n                                  const Instruction &CxtI) const {\n    return computeOverflowForUnsignedAdd(LHS, RHS, &CxtI) ==\n           OverflowResult::NeverOverflows;\n  }\n\n  bool willNotOverflowAdd(const Value *LHS, const Value *RHS,\n                          const Instruction &CxtI, bool IsSigned) const {\n    return IsSigned ? willNotOverflowSignedAdd(LHS, RHS, CxtI)\n                    : willNotOverflowUnsignedAdd(LHS, RHS, CxtI);\n  }\n\n  bool willNotOverflowSignedSub(const Value *LHS, const Value *RHS,\n                                const Instruction &CxtI) const {\n    return computeOverflowForSignedSub(LHS, RHS, &CxtI) ==\n           OverflowResult::NeverOverflows;\n  }\n\n  bool willNotOverflowUnsignedSub(const Value *LHS, const Value *RHS,\n                                  const Instruction &CxtI) const {\n    return computeOverflowForUnsignedSub(LHS, RHS, &CxtI) ==\n           OverflowResult::NeverOverflows;\n  }\n\n  bool willNotOverflowSub(const Value *LHS, const Value *RHS,\n                          const Instruction &CxtI, bool IsSigned) const {\n    return IsSigned ? willNotOverflowSignedSub(LHS, RHS, CxtI)\n                    : willNotOverflowUnsignedSub(LHS, RHS, CxtI);\n  }\n\n  bool willNotOverflowSignedMul(const Value *LHS, const Value *RHS,\n                                const Instruction &CxtI) const {\n    return computeOverflowForSignedMul(LHS, RHS, &CxtI) ==\n           OverflowResult::NeverOverflows;\n  }\n\n  bool willNotOverflowUnsignedMul(const Value *LHS, const Value *RHS,\n                                  const Instruction &CxtI) const {\n    return computeOverflowForUnsignedMul(LHS, RHS, &CxtI) ==\n           OverflowResult::NeverOverflows;\n  }\n\n  bool willNotOverflowMul(const Value *LHS, const Value *RHS,\n                          const Instruction &CxtI, bool IsSigned) const {\n    return IsSigned ? willNotOverflowSignedMul(LHS, RHS, CxtI)\n                    : willNotOverflowUnsignedMul(LHS, RHS, CxtI);\n  }\n\n  bool willNotOverflow(BinaryOperator::BinaryOps Opcode, const Value *LHS,\n                       const Value *RHS, const Instruction &CxtI,\n                       bool IsSigned) const {\n    switch (Opcode) {\n    case Instruction::Add: return willNotOverflowAdd(LHS, RHS, CxtI, IsSigned);\n    case Instruction::Sub: return willNotOverflowSub(LHS, RHS, CxtI, IsSigned);\n    case Instruction::Mul: return willNotOverflowMul(LHS, RHS, CxtI, IsSigned);\n    default: llvm_unreachable(\"Unexpected opcode for overflow query\");\n    }\n  }\n\n  Value *EmitGEPOffset(User *GEP);\n  Instruction *scalarizePHI(ExtractElementInst &EI, PHINode *PN);\n  Instruction *foldCastedBitwiseLogic(BinaryOperator &I);\n  Instruction *narrowBinOp(TruncInst &Trunc);\n  Instruction *narrowMaskedBinOp(BinaryOperator &And);\n  Instruction *narrowMathIfNoOverflow(BinaryOperator &I);\n  Instruction *narrowFunnelShift(TruncInst &Trunc);\n  Instruction *optimizeBitCastFromPhi(CastInst &CI, PHINode *PN);\n  Instruction *matchSAddSubSat(SelectInst &MinMax1);\n\n  void freelyInvertAllUsersOf(Value *V);\n\n  /// Determine if a pair of casts can be replaced by a single cast.\n  ///\n  /// \\param CI1 The first of a pair of casts.\n  /// \\param CI2 The second of a pair of casts.\n  ///\n  /// \\return 0 if the cast pair cannot be eliminated, otherwise returns an\n  /// Instruction::CastOps value for a cast that can replace the pair, casting\n  /// CI1->getSrcTy() to CI2->getDstTy().\n  ///\n  /// \\see CastInst::isEliminableCastPair\n  Instruction::CastOps isEliminableCastPair(const CastInst *CI1,\n                                            const CastInst *CI2);\n\n  Value *foldAndOfICmps(ICmpInst *LHS, ICmpInst *RHS, BinaryOperator &And);\n  Value *foldOrOfICmps(ICmpInst *LHS, ICmpInst *RHS, BinaryOperator &Or);\n  Value *foldXorOfICmps(ICmpInst *LHS, ICmpInst *RHS, BinaryOperator &Xor);\n\n  /// Optimize (fcmp)&(fcmp) or (fcmp)|(fcmp).\n  /// NOTE: Unlike most of instcombine, this returns a Value which should\n  /// already be inserted into the function.\n  Value *foldLogicOfFCmps(FCmpInst *LHS, FCmpInst *RHS, bool IsAnd);\n\n  Value *foldAndOrOfICmpsOfAndWithPow2(ICmpInst *LHS, ICmpInst *RHS,\n                                       BinaryOperator &Logic);\n  Value *matchSelectFromAndOr(Value *A, Value *B, Value *C, Value *D);\n  Value *getSelectCondition(Value *A, Value *B);\n\n  Instruction *foldIntrinsicWithOverflowCommon(IntrinsicInst *II);\n  Instruction *foldFPSignBitOps(BinaryOperator &I);\n\npublic:\n  /// Inserts an instruction \\p New before instruction \\p Old\n  ///\n  /// Also adds the new instruction to the worklist and returns \\p New so that\n  /// it is suitable for use as the return from the visitation patterns.\n  Instruction *InsertNewInstBefore(Instruction *New, Instruction &Old) {\n    assert(New && !New->getParent() &&\n           \"New instruction already inserted into a basic block!\");\n    BasicBlock *BB = Old.getParent();\n    BB->getInstList().insert(Old.getIterator(), New); // Insert inst\n    Worklist.add(New);\n    return New;\n  }\n\n  /// Same as InsertNewInstBefore, but also sets the debug loc.\n  Instruction *InsertNewInstWith(Instruction *New, Instruction &Old) {\n    New->setDebugLoc(Old.getDebugLoc());\n    return InsertNewInstBefore(New, Old);\n  }\n\n  /// A combiner-aware RAUW-like routine.\n  ///\n  /// This method is to be used when an instruction is found to be dead,\n  /// replaceable with another preexisting expression. Here we add all uses of\n  /// I to the worklist, replace all uses of I with the new value, then return\n  /// I, so that the inst combiner will know that I was modified.\n  Instruction *replaceInstUsesWith(Instruction &I, Value *V) {\n    // If there are no uses to replace, then we return nullptr to indicate that\n    // no changes were made to the program.\n    if (I.use_empty()) return nullptr;\n\n    Worklist.pushUsersToWorkList(I); // Add all modified instrs to worklist.\n\n    // If we are replacing the instruction with itself, this must be in a\n    // segment of unreachable code, so just clobber the instruction.\n    if (&I == V)\n      V = UndefValue::get(I.getType());\n\n    LLVM_DEBUG(dbgs() << \"IC: Replacing \" << I << \"\\n\"\n                      << \"    with \" << *V << '\\n');\n\n    I.replaceAllUsesWith(V);\n    MadeIRChange = true;\n    return &I;\n  }\n\n  /// Replace operand of instruction and add old operand to the worklist.\n  Instruction *replaceOperand(Instruction &I, unsigned OpNum, Value *V) {\n    Worklist.addValue(I.getOperand(OpNum));\n    I.setOperand(OpNum, V);\n    return &I;\n  }\n\n  /// Replace use and add the previously used value to the worklist.\n  void replaceUse(Use &U, Value *NewValue) {\n    Worklist.addValue(U);\n    U = NewValue;\n  }\n\n  /// Creates a result tuple for an overflow intrinsic \\p II with a given\n  /// \\p Result and a constant \\p Overflow value.\n  Instruction *CreateOverflowTuple(IntrinsicInst *II, Value *Result,\n                                   Constant *Overflow) {\n    Constant *V[] = {UndefValue::get(Result->getType()), Overflow};\n    StructType *ST = cast<StructType>(II->getType());\n    Constant *Struct = ConstantStruct::get(ST, V);\n    return InsertValueInst::Create(Struct, Result, 0);\n  }\n\n  /// Create and insert the idiom we use to indicate a block is unreachable\n  /// without having to rewrite the CFG from within InstCombine.\n  void CreateNonTerminatorUnreachable(Instruction *InsertAt) {\n    auto &Ctx = InsertAt->getContext();\n    new StoreInst(ConstantInt::getTrue(Ctx),\n                  UndefValue::get(Type::getInt1PtrTy(Ctx)),\n                  InsertAt);\n  }\n\n\n  /// Combiner aware instruction erasure.\n  ///\n  /// When dealing with an instruction that has side effects or produces a void\n  /// value, we can't rely on DCE to delete the instruction. Instead, visit\n  /// methods should return the value returned by this function.\n  Instruction *eraseInstFromFunction(Instruction &I) override {\n    LLVM_DEBUG(dbgs() << \"IC: ERASE \" << I << '\\n');\n    assert(I.use_empty() && \"Cannot erase instruction that is used!\");\n    salvageDebugInfo(I);\n\n    // Make sure that we reprocess all operands now that we reduced their\n    // use counts.\n    for (Use &Operand : I.operands())\n      if (auto *Inst = dyn_cast<Instruction>(Operand))\n        Worklist.add(Inst);\n\n    Worklist.remove(&I);\n    I.eraseFromParent();\n    MadeIRChange = true;\n    return nullptr; // Don't do anything with FI\n  }\n\n  void computeKnownBits(const Value *V, KnownBits &Known,\n                        unsigned Depth, const Instruction *CxtI) const {\n    llvm::computeKnownBits(V, Known, DL, Depth, &AC, CxtI, &DT);\n  }\n\n  KnownBits computeKnownBits(const Value *V, unsigned Depth,\n                             const Instruction *CxtI) const {\n    return llvm::computeKnownBits(V, DL, Depth, &AC, CxtI, &DT);\n  }\n\n  bool isKnownToBeAPowerOfTwo(const Value *V, bool OrZero = false,\n                              unsigned Depth = 0,\n                              const Instruction *CxtI = nullptr) {\n    return llvm::isKnownToBeAPowerOfTwo(V, DL, OrZero, Depth, &AC, CxtI, &DT);\n  }\n\n  bool MaskedValueIsZero(const Value *V, const APInt &Mask, unsigned Depth = 0,\n                         const Instruction *CxtI = nullptr) const {\n    return llvm::MaskedValueIsZero(V, Mask, DL, Depth, &AC, CxtI, &DT);\n  }\n\n  unsigned ComputeNumSignBits(const Value *Op, unsigned Depth = 0,\n                              const Instruction *CxtI = nullptr) const {\n    return llvm::ComputeNumSignBits(Op, DL, Depth, &AC, CxtI, &DT);\n  }\n\n  OverflowResult computeOverflowForUnsignedMul(const Value *LHS,\n                                               const Value *RHS,\n                                               const Instruction *CxtI) const {\n    return llvm::computeOverflowForUnsignedMul(LHS, RHS, DL, &AC, CxtI, &DT);\n  }\n\n  OverflowResult computeOverflowForSignedMul(const Value *LHS,\n                                             const Value *RHS,\n                                             const Instruction *CxtI) const {\n    return llvm::computeOverflowForSignedMul(LHS, RHS, DL, &AC, CxtI, &DT);\n  }\n\n  OverflowResult computeOverflowForUnsignedAdd(const Value *LHS,\n                                               const Value *RHS,\n                                               const Instruction *CxtI) const {\n    return llvm::computeOverflowForUnsignedAdd(LHS, RHS, DL, &AC, CxtI, &DT);\n  }\n\n  OverflowResult computeOverflowForSignedAdd(const Value *LHS,\n                                             const Value *RHS,\n                                             const Instruction *CxtI) const {\n    return llvm::computeOverflowForSignedAdd(LHS, RHS, DL, &AC, CxtI, &DT);\n  }\n\n  OverflowResult computeOverflowForUnsignedSub(const Value *LHS,\n                                               const Value *RHS,\n                                               const Instruction *CxtI) const {\n    return llvm::computeOverflowForUnsignedSub(LHS, RHS, DL, &AC, CxtI, &DT);\n  }\n\n  OverflowResult computeOverflowForSignedSub(const Value *LHS, const Value *RHS,\n                                             const Instruction *CxtI) const {\n    return llvm::computeOverflowForSignedSub(LHS, RHS, DL, &AC, CxtI, &DT);\n  }\n\n  OverflowResult computeOverflow(\n      Instruction::BinaryOps BinaryOp, bool IsSigned,\n      Value *LHS, Value *RHS, Instruction *CxtI) const;\n\n  /// Performs a few simplifications for operators which are associative\n  /// or commutative.\n  bool SimplifyAssociativeOrCommutative(BinaryOperator &I);\n\n  /// Tries to simplify binary operations which some other binary\n  /// operation distributes over.\n  ///\n  /// It does this by either by factorizing out common terms (eg \"(A*B)+(A*C)\"\n  /// -> \"A*(B+C)\") or expanding out if this results in simplifications (eg: \"A\n  /// & (B | C) -> (A&B) | (A&C)\" if this is a win).  Returns the simplified\n  /// value, or null if it didn't simplify.\n  Value *SimplifyUsingDistributiveLaws(BinaryOperator &I);\n\n  /// Tries to simplify add operations using the definition of remainder.\n  ///\n  /// The definition of remainder is X % C = X - (X / C ) * C. The add\n  /// expression X % C0 + (( X / C0 ) % C1) * C0 can be simplified to\n  /// X % (C0 * C1)\n  Value *SimplifyAddWithRemainder(BinaryOperator &I);\n\n  // Binary Op helper for select operations where the expression can be\n  // efficiently reorganized.\n  Value *SimplifySelectsFeedingBinaryOp(BinaryOperator &I, Value *LHS,\n                                        Value *RHS);\n\n  /// This tries to simplify binary operations by factorizing out common terms\n  /// (e. g. \"(A*B)+(A*C)\" -> \"A*(B+C)\").\n  Value *tryFactorization(BinaryOperator &, Instruction::BinaryOps, Value *,\n                          Value *, Value *, Value *);\n\n  /// Match a select chain which produces one of three values based on whether\n  /// the LHS is less than, equal to, or greater than RHS respectively.\n  /// Return true if we matched a three way compare idiom. The LHS, RHS, Less,\n  /// Equal and Greater values are saved in the matching process and returned to\n  /// the caller.\n  bool matchThreeWayIntCompare(SelectInst *SI, Value *&LHS, Value *&RHS,\n                               ConstantInt *&Less, ConstantInt *&Equal,\n                               ConstantInt *&Greater);\n\n  /// Attempts to replace V with a simpler value based on the demanded\n  /// bits.\n  Value *SimplifyDemandedUseBits(Value *V, APInt DemandedMask, KnownBits &Known,\n                                 unsigned Depth, Instruction *CxtI);\n  bool SimplifyDemandedBits(Instruction *I, unsigned Op,\n                            const APInt &DemandedMask, KnownBits &Known,\n                            unsigned Depth = 0) override;\n\n  /// Helper routine of SimplifyDemandedUseBits. It computes KnownZero/KnownOne\n  /// bits. It also tries to handle simplifications that can be done based on\n  /// DemandedMask, but without modifying the Instruction.\n  Value *SimplifyMultipleUseDemandedBits(Instruction *I,\n                                         const APInt &DemandedMask,\n                                         KnownBits &Known,\n                                         unsigned Depth, Instruction *CxtI);\n\n  /// Helper routine of SimplifyDemandedUseBits. It tries to simplify demanded\n  /// bit for \"r1 = shr x, c1; r2 = shl r1, c2\" instruction sequence.\n  Value *simplifyShrShlDemandedBits(\n      Instruction *Shr, const APInt &ShrOp1, Instruction *Shl,\n      const APInt &ShlOp1, const APInt &DemandedMask, KnownBits &Known);\n\n  /// Tries to simplify operands to an integer instruction based on its\n  /// demanded bits.\n  bool SimplifyDemandedInstructionBits(Instruction &Inst);\n\n  virtual Value *\n  SimplifyDemandedVectorElts(Value *V, APInt DemandedElts, APInt &UndefElts,\n                             unsigned Depth = 0,\n                             bool AllowMultipleUsers = false) override;\n\n  /// Canonicalize the position of binops relative to shufflevector.\n  Instruction *foldVectorBinop(BinaryOperator &Inst);\n  Instruction *foldVectorSelect(SelectInst &Sel);\n\n  /// Given a binary operator, cast instruction, or select which has a PHI node\n  /// as operand #0, see if we can fold the instruction into the PHI (which is\n  /// only possible if all operands to the PHI are constants).\n  Instruction *foldOpIntoPhi(Instruction &I, PHINode *PN);\n\n  /// Given an instruction with a select as one operand and a constant as the\n  /// other operand, try to fold the binary operator into the select arguments.\n  /// This also works for Cast instructions, which obviously do not have a\n  /// second operand.\n  Instruction *FoldOpIntoSelect(Instruction &Op, SelectInst *SI);\n\n  /// This is a convenience wrapper function for the above two functions.\n  Instruction *foldBinOpIntoSelectOrPhi(BinaryOperator &I);\n\n  Instruction *foldAddWithConstant(BinaryOperator &Add);\n\n  /// Try to rotate an operation below a PHI node, using PHI nodes for\n  /// its operands.\n  Instruction *foldPHIArgOpIntoPHI(PHINode &PN);\n  Instruction *foldPHIArgBinOpIntoPHI(PHINode &PN);\n  Instruction *foldPHIArgInsertValueInstructionIntoPHI(PHINode &PN);\n  Instruction *foldPHIArgExtractValueInstructionIntoPHI(PHINode &PN);\n  Instruction *foldPHIArgGEPIntoPHI(PHINode &PN);\n  Instruction *foldPHIArgLoadIntoPHI(PHINode &PN);\n  Instruction *foldPHIArgZextsIntoPHI(PHINode &PN);\n\n  /// If an integer typed PHI has only one use which is an IntToPtr operation,\n  /// replace the PHI with an existing pointer typed PHI if it exists. Otherwise\n  /// insert a new pointer typed PHI and replace the original one.\n  Instruction *foldIntegerTypedPHI(PHINode &PN);\n\n  /// Helper function for FoldPHIArgXIntoPHI() to set debug location for the\n  /// folded operation.\n  void PHIArgMergedDebugLoc(Instruction *Inst, PHINode &PN);\n\n  Instruction *foldGEPICmp(GEPOperator *GEPLHS, Value *RHS,\n                           ICmpInst::Predicate Cond, Instruction &I);\n  Instruction *foldAllocaCmp(ICmpInst &ICI, const AllocaInst *Alloca,\n                             const Value *Other);\n  Instruction *foldCmpLoadFromIndexedGlobal(GetElementPtrInst *GEP,\n                                            GlobalVariable *GV, CmpInst &ICI,\n                                            ConstantInt *AndCst = nullptr);\n  Instruction *foldFCmpIntToFPConst(FCmpInst &I, Instruction *LHSI,\n                                    Constant *RHSC);\n  Instruction *foldICmpAddOpConst(Value *X, const APInt &C,\n                                  ICmpInst::Predicate Pred);\n  Instruction *foldICmpWithCastOp(ICmpInst &ICI);\n\n  Instruction *foldICmpUsingKnownBits(ICmpInst &Cmp);\n  Instruction *foldICmpWithDominatingICmp(ICmpInst &Cmp);\n  Instruction *foldICmpWithConstant(ICmpInst &Cmp);\n  Instruction *foldICmpInstWithConstant(ICmpInst &Cmp);\n  Instruction *foldICmpInstWithConstantNotInt(ICmpInst &Cmp);\n  Instruction *foldICmpBinOp(ICmpInst &Cmp, const SimplifyQuery &SQ);\n  Instruction *foldICmpEquality(ICmpInst &Cmp);\n  Instruction *foldIRemByPowerOfTwoToBitTest(ICmpInst &I);\n  Instruction *foldSignBitTest(ICmpInst &I);\n  Instruction *foldICmpWithZero(ICmpInst &Cmp);\n\n  Value *foldUnsignedMultiplicationOverflowCheck(ICmpInst &Cmp);\n\n  Instruction *foldICmpSelectConstant(ICmpInst &Cmp, SelectInst *Select,\n                                      ConstantInt *C);\n  Instruction *foldICmpTruncConstant(ICmpInst &Cmp, TruncInst *Trunc,\n                                     const APInt &C);\n  Instruction *foldICmpAndConstant(ICmpInst &Cmp, BinaryOperator *And,\n                                   const APInt &C);\n  Instruction *foldICmpXorConstant(ICmpInst &Cmp, BinaryOperator *Xor,\n                                   const APInt &C);\n  Instruction *foldICmpOrConstant(ICmpInst &Cmp, BinaryOperator *Or,\n                                  const APInt &C);\n  Instruction *foldICmpMulConstant(ICmpInst &Cmp, BinaryOperator *Mul,\n                                   const APInt &C);\n  Instruction *foldICmpShlConstant(ICmpInst &Cmp, BinaryOperator *Shl,\n                                   const APInt &C);\n  Instruction *foldICmpShrConstant(ICmpInst &Cmp, BinaryOperator *Shr,\n                                   const APInt &C);\n  Instruction *foldICmpSRemConstant(ICmpInst &Cmp, BinaryOperator *UDiv,\n                                    const APInt &C);\n  Instruction *foldICmpUDivConstant(ICmpInst &Cmp, BinaryOperator *UDiv,\n                                    const APInt &C);\n  Instruction *foldICmpDivConstant(ICmpInst &Cmp, BinaryOperator *Div,\n                                   const APInt &C);\n  Instruction *foldICmpSubConstant(ICmpInst &Cmp, BinaryOperator *Sub,\n                                   const APInt &C);\n  Instruction *foldICmpAddConstant(ICmpInst &Cmp, BinaryOperator *Add,\n                                   const APInt &C);\n  Instruction *foldICmpAndConstConst(ICmpInst &Cmp, BinaryOperator *And,\n                                     const APInt &C1);\n  Instruction *foldICmpAndShift(ICmpInst &Cmp, BinaryOperator *And,\n                                const APInt &C1, const APInt &C2);\n  Instruction *foldICmpShrConstConst(ICmpInst &I, Value *ShAmt, const APInt &C1,\n                                     const APInt &C2);\n  Instruction *foldICmpShlConstConst(ICmpInst &I, Value *ShAmt, const APInt &C1,\n                                     const APInt &C2);\n\n  Instruction *foldICmpBinOpEqualityWithConstant(ICmpInst &Cmp,\n                                                 BinaryOperator *BO,\n                                                 const APInt &C);\n  Instruction *foldICmpIntrinsicWithConstant(ICmpInst &ICI, IntrinsicInst *II,\n                                             const APInt &C);\n  Instruction *foldICmpEqIntrinsicWithConstant(ICmpInst &ICI, IntrinsicInst *II,\n                                               const APInt &C);\n\n  // Helpers of visitSelectInst().\n  Instruction *foldSelectExtConst(SelectInst &Sel);\n  Instruction *foldSelectOpOp(SelectInst &SI, Instruction *TI, Instruction *FI);\n  Instruction *foldSelectIntoOp(SelectInst &SI, Value *, Value *);\n  Instruction *foldSPFofSPF(Instruction *Inner, SelectPatternFlavor SPF1,\n                            Value *A, Value *B, Instruction &Outer,\n                            SelectPatternFlavor SPF2, Value *C);\n  Instruction *foldSelectInstWithICmp(SelectInst &SI, ICmpInst *ICI);\n  Instruction *foldSelectValueEquivalence(SelectInst &SI, ICmpInst &ICI);\n\n  Value *insertRangeTest(Value *V, const APInt &Lo, const APInt &Hi,\n                         bool isSigned, bool Inside);\n  Instruction *PromoteCastOfAllocation(BitCastInst &CI, AllocaInst &AI);\n  bool mergeStoreIntoSuccessor(StoreInst &SI);\n\n  /// Given an 'or' instruction, check to see if it is part of a\n  /// bswap/bitreverse idiom. If so, return the equivalent bswap/bitreverse\n  /// intrinsic.\n  Instruction *matchBSwapOrBitReverse(BinaryOperator &Or, bool MatchBSwaps,\n                                      bool MatchBitReversals);\n\n  Instruction *SimplifyAnyMemTransfer(AnyMemTransferInst *MI);\n  Instruction *SimplifyAnyMemSet(AnyMemSetInst *MI);\n\n  Value *EvaluateInDifferentType(Value *V, Type *Ty, bool isSigned);\n\n  /// Returns a value X such that Val = X * Scale, or null if none.\n  ///\n  /// If the multiplication is known not to overflow then NoSignedWrap is set.\n  Value *Descale(Value *Val, APInt Scale, bool &NoSignedWrap);\n};\n\nclass Negator final {\n  /// Top-to-bottom, def-to-use negated instruction tree we produced.\n  SmallVector<Instruction *, NegatorMaxNodesSSO> NewInstructions;\n\n  using BuilderTy = IRBuilder<TargetFolder, IRBuilderCallbackInserter>;\n  BuilderTy Builder;\n\n  const DataLayout &DL;\n  AssumptionCache &AC;\n  const DominatorTree &DT;\n\n  const bool IsTrulyNegation;\n\n  SmallDenseMap<Value *, Value *> NegationsCache;\n\n  Negator(LLVMContext &C, const DataLayout &DL, AssumptionCache &AC,\n          const DominatorTree &DT, bool IsTrulyNegation);\n\n#if LLVM_ENABLE_STATS\n  unsigned NumValuesVisitedInThisNegator = 0;\n  ~Negator();\n#endif\n\n  using Result = std::pair<ArrayRef<Instruction *> /*NewInstructions*/,\n                           Value * /*NegatedRoot*/>;\n\n  std::array<Value *, 2> getSortedOperandsOfBinOp(Instruction *I);\n\n  LLVM_NODISCARD Value *visitImpl(Value *V, unsigned Depth);\n\n  LLVM_NODISCARD Value *negate(Value *V, unsigned Depth);\n\n  /// Recurse depth-first and attempt to sink the negation.\n  /// FIXME: use worklist?\n  LLVM_NODISCARD Optional<Result> run(Value *Root);\n\n  Negator(const Negator &) = delete;\n  Negator(Negator &&) = delete;\n  Negator &operator=(const Negator &) = delete;\n  Negator &operator=(Negator &&) = delete;\n\npublic:\n  /// Attempt to negate \\p Root. Retuns nullptr if negation can't be performed,\n  /// otherwise returns negated value.\n  LLVM_NODISCARD static Value *Negate(bool LHSIsZero, Value *Root,\n                                      InstCombinerImpl &IC);\n};\n\n} // end namespace llvm\n\n#undef DEBUG_TYPE\n\n#endif // LLVM_LIB_TRANSFORMS_INSTCOMBINE_INSTCOMBINEINTERNAL_H\n"}}, "reports": [{"events": [{"location": {"col": 26, "file": 4, "line": 2930}, "message": "the definition seen here"}, {"location": {"col": 10, "file": 3, "line": 344}, "message": "differing parameters are named here: ('Xor'), in definition: ('I')"}, {"location": {"col": 10, "file": 3, "line": 344}, "message": "function 'llvm::InstCombinerImpl::foldXorOfICmps' has a definition with different parameter names"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineInternal.h", "reportHash": "e8e6884ca119b81b734ef139086769ed", "checkerName": "readability-inconsistent-declaration-parameter-name", "reviewStatus": null, "severity": "STYLE"}, {"events": [{"location": {"col": 26, "file": 4, "line": 2274}, "message": "the definition seen here"}, {"location": {"col": 10, "file": 3, "line": 353}, "message": "differing parameters are named here: ('B', 'C'), in definition: ('C', 'B')"}, {"location": {"col": 10, "file": 3, "line": 353}, "message": "function 'llvm::InstCombinerImpl::matchSelectFromAndOr' has a definition with different parameter names"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineInternal.h", "reportHash": "0dc992a19c015125d6c8f51f6b5a1c2e", "checkerName": "readability-inconsistent-declaration-parameter-name", "reviewStatus": null, "severity": "STYLE"}]};
      window.onload = function() {
        if (!browserCompatible) {
          setNonCompatibleBrowserMessage();
        } else {
          BugViewer.init(data.files, data.reports);
          BugViewer.create();
          BugViewer.initByUrl();
        }
      };
    </script>
  </head>
  <body>
  <div class="container">
    <div id="content">
      <div id="side-bar">
        <div class="header">
          <a href="index.html" class="button">&#8249; Return to List</a>
        </div>
        <div id="report-nav">
          <div class="header">Reports</div>
        </div>
      </div>
      <div id="editor-wrapper">
        <div class="header">
          <div id="file">
            <span class="label">File:</span>
            <span id="file-path"></span>
          </div>
          <div id="checker">
            <span class="label">Checker name:</span>
            <span id="checker-name"></span>
          </div>
          <div id="review-status-wrapper">
            <span class="label">Review status:</span>
            <span id="review-status"></span>
          </div>
        </div>
        <div id="editor"></div>
      </div>
    </div>
  </div>
  </body>
</html>
