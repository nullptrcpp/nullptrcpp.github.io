<!DOCTYPE html>
<html>
  <head>
    <title>Plist HTML Viewer</title>

    <meta charset="UTF-8">

    <style type="text/css">
      .CodeMirror{font-family:monospace;height:300px;color:#000;direction:ltr}.CodeMirror-lines{padding:4px 0}.CodeMirror pre{padding:0 4px}.CodeMirror-gutter-filler,.CodeMirror-scrollbar-filler{background-color:#fff}.CodeMirror-gutters{border-right:1px solid #ddd;background-color:#f7f7f7;white-space:nowrap}.CodeMirror-linenumber{padding:0 3px 0 5px;min-width:20px;text-align:right;color:#999;white-space:nowrap}.CodeMirror-guttermarker{color:#000}.CodeMirror-guttermarker-subtle{color:#999}.CodeMirror-cursor{border-left:1px solid #000;border-right:none;width:0}.CodeMirror div.CodeMirror-secondarycursor{border-left:1px solid silver}.cm-fat-cursor .CodeMirror-cursor{width:auto;border:0!important;background:#7e7}.cm-fat-cursor div.CodeMirror-cursors{z-index:1}.cm-animate-fat-cursor{width:auto;border:0;-webkit-animation:blink 1.06s steps(1) infinite;-moz-animation:blink 1.06s steps(1) infinite;animation:blink 1.06s steps(1) infinite;background-color:#7e7}@-moz-keyframes blink{50%{background-color:transparent}}@-webkit-keyframes blink{50%{background-color:transparent}}@keyframes blink{50%{background-color:transparent}}.cm-tab{display:inline-block;text-decoration:inherit}.CodeMirror-rulers{position:absolute;left:0;right:0;top:-50px;bottom:-20px;overflow:hidden}.CodeMirror-ruler{border-left:1px solid #ccc;top:0;bottom:0;position:absolute}.cm-s-default .cm-header{color:#00f}.cm-s-default .cm-quote{color:#090}.cm-negative{color:#d44}.cm-positive{color:#292}.cm-header,.cm-strong{font-weight:700}.cm-em{font-style:italic}.cm-link{text-decoration:underline}.cm-strikethrough{text-decoration:line-through}.cm-s-default .cm-keyword{color:#708}.cm-s-default .cm-atom{color:#219}.cm-s-default .cm-number{color:#164}.cm-s-default .cm-def{color:#00f}.cm-s-default .cm-variable-2{color:#05a}.cm-s-default .cm-type,.cm-s-default .cm-variable-3{color:#085}.cm-s-default .cm-comment{color:#a50}.cm-s-default .cm-string{color:#a11}.cm-s-default .cm-string-2{color:#f50}.cm-s-default .cm-meta{color:#555}.cm-s-default .cm-qualifier{color:#555}.cm-s-default .cm-builtin{color:#30a}.cm-s-default .cm-bracket{color:#997}.cm-s-default .cm-tag{color:#170}.cm-s-default .cm-attribute{color:#00c}.cm-s-default .cm-hr{color:#999}.cm-s-default .cm-link{color:#00c}.cm-s-default .cm-error{color:red}.cm-invalidchar{color:red}.CodeMirror-composing{border-bottom:2px solid}div.CodeMirror span.CodeMirror-matchingbracket{color:#0f0}div.CodeMirror span.CodeMirror-nonmatchingbracket{color:#f22}.CodeMirror-matchingtag{background:rgba(255,150,0,.3)}.CodeMirror-activeline-background{background:#e8f2ff}.CodeMirror{position:relative;overflow:hidden;background:#fff}.CodeMirror-scroll{overflow:scroll!important;margin-bottom:-30px;margin-right:-30px;padding-bottom:30px;height:100%;outline:0;position:relative}.CodeMirror-sizer{position:relative;border-right:30px solid transparent}.CodeMirror-gutter-filler,.CodeMirror-hscrollbar,.CodeMirror-scrollbar-filler,.CodeMirror-vscrollbar{position:absolute;z-index:6;display:none}.CodeMirror-vscrollbar{right:0;top:0;overflow-x:hidden;overflow-y:scroll}.CodeMirror-hscrollbar{bottom:0;left:0;overflow-y:hidden;overflow-x:scroll}.CodeMirror-scrollbar-filler{right:0;bottom:0}.CodeMirror-gutter-filler{left:0;bottom:0}.CodeMirror-gutters{position:absolute;left:0;top:0;min-height:100%;z-index:3}.CodeMirror-gutter{white-space:normal;height:100%;display:inline-block;vertical-align:top;margin-bottom:-30px}.CodeMirror-gutter-wrapper{position:absolute;z-index:4;background:0 0!important;border:none!important}.CodeMirror-gutter-background{position:absolute;top:0;bottom:0;z-index:4}.CodeMirror-gutter-elt{position:absolute;cursor:default;z-index:4}.CodeMirror-gutter-wrapper ::selection{background-color:transparent}.CodeMirror-gutter-wrapper ::-moz-selection{background-color:transparent}.CodeMirror-lines{cursor:text;min-height:1px}.CodeMirror pre{-moz-border-radius:0;-webkit-border-radius:0;border-radius:0;border-width:0;background:0 0;font-family:inherit;font-size:inherit;margin:0;white-space:pre;word-wrap:normal;line-height:inherit;color:inherit;z-index:2;position:relative;overflow:visible;-webkit-tap-highlight-color:transparent;-webkit-font-variant-ligatures:contextual;font-variant-ligatures:contextual}.CodeMirror-wrap pre{word-wrap:break-word;white-space:pre-wrap;word-break:normal}.CodeMirror-linebackground{position:absolute;left:0;right:0;top:0;bottom:0;z-index:0}.CodeMirror-linewidget{position:relative;z-index:2;overflow:auto}.CodeMirror-rtl pre{direction:rtl}.CodeMirror-code{outline:0}.CodeMirror-gutter,.CodeMirror-gutters,.CodeMirror-linenumber,.CodeMirror-scroll,.CodeMirror-sizer{-moz-box-sizing:content-box;box-sizing:content-box}.CodeMirror-measure{position:absolute;width:100%;height:0;overflow:hidden;visibility:hidden}.CodeMirror-cursor{position:absolute;pointer-events:none}.CodeMirror-measure pre{position:static}div.CodeMirror-cursors{visibility:hidden;position:relative;z-index:3}div.CodeMirror-dragcursors{visibility:visible}.CodeMirror-focused div.CodeMirror-cursors{visibility:visible}.CodeMirror-selected{background:#d9d9d9}.CodeMirror-focused .CodeMirror-selected{background:#d7d4f0}.CodeMirror-crosshair{cursor:crosshair}.CodeMirror-line::selection,.CodeMirror-line>span::selection,.CodeMirror-line>span>span::selection{background:#d7d4f0}.CodeMirror-line::-moz-selection,.CodeMirror-line>span::-moz-selection,.CodeMirror-line>span>span::-moz-selection{background:#d7d4f0}.cm-searching{background-color:#ffa;background-color:rgba(255,255,0,.4)}.cm-force-border{padding-right:.1px}@media print{.CodeMirror div.CodeMirror-cursors{visibility:hidden}}.cm-tab-wrap-hack:after{content:''}span.CodeMirror-selectedtext{background:0 0}
/*# sourceMappingURL=codemirror.min.css.map */

      .severity-low {
  background-color: #669603;
}

.severity-low:after {
  content : 'L';
}

.severity-unspecified {
  background-color: #666666;
}

.severity-unspecified:after {
  content : 'U';
}

.severity-style {
  background-color: #9932cc;
}

.severity-style:after {
  content : 'S';
}

.severity-medium {
  background-color: #a9d323;
  color: black;
}

.severity-medium:after {
  content : 'M';
}

.severity-high {
  background-color: #ffa800;
}

.severity-high:after {
  content : 'H';
}

.severity-critical {
  background-color: #e92625;
}

.severity-critical:after {
  content : 'C';
}

i[class*="severity-"] {
  line-height: normal;
  text-transform: capitalize;
  font-size: 0.8em;
  font-weight: bold;
  color: white;
  display: inline-block;
  width: 16px;
  height: 16px;
  text-align: center;
  font-family: sans-serif;
}

      html, body {
  width: 100%;
  height: 100%;
  padding: 0px;
  margin: 0px;
}

div.container {
  padding: 10px;
}

#content {
  height: 100%;
  display: block;
  overflow: hidden;
}

#content > div {
  margin: 10px;
  overflow: hidden;
  border: 1px solid #ddd;
  border-radius: 3px;
  overflow: hidden;
  height: 97%;
}

.button {
  background-color: #f1f1f1;
  text-decoration: none;
  display: inline-block;
  padding: 8px 16px;
  color: black;
  cursor: pointer;
}

.button:hover {
  background-color: #ddd;
  color: black;
}

.review-status {
  color: white;
  text-align: center;
}

.review-status-confirmed {
  background-color: #e92625;
}

.review-status-false-positive {
  background-color: grey;
}

.review-status-intentional {
  background-color: #669603;
}

      div.container {
  width: 100%;
  height: 100%;
  padding: 0px;
}

#editor-wrapper {
  margin: 10px;
}

#side-bar {
  float: left;
  width: 260px;
  margin: 0px;
}

#report-nav ul {
  list-style-type: none;
  padding: 0;
  margin: 0;
  overflow-y: auto;
  height: 100%;
}

#report-nav ul > li {
  padding: .4em;
  background-color: #fff;
  border-bottom: 1px solid rgba(0,0,0,.125);
  text-align: left;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

#report-nav ul > li.active {
  background-color: #427ea9;
  color: white;
}

#report-nav ul > li:hover {
  background-color: #427ea9;
  color: white;
  cursor: pointer;
}

#report-nav ul a {
  text-decoration: none;
}

#report-nav i[class*="severity-"] {
  margin-right: 5px;
}

.header {
  border-bottom: 1px solid lightgrey;
  font-family: monospace;
  padding: 10px;
  background-color: #fafbfc;
  border-bottom: 1px solid #e1e4e8;
  border-top-left-radius: 2px;
  border-top-right-radius: 2px;
}

#report-nav .header {
  font-weight: bold;
}

#editor-wrapper .header > div {
  padding-top: 2px;
}

#file-path,
#checker-name {
  color: #195ea2;
}

#review-status {
  padding: 0px 5px;
}

#file-path {
  font-family: monospace;
}

.check-msg {
  display: inline-block;
  padding: 3px 6px;
  margin: 1px;
  -webkit-border-radius: 5px;
  -moz-border-radius: 5px;
  border-radius: 5px;
}

.check-msg.info {
  color: #00546f;
  background-color: #bfdfe9;
  border: 1px solid #87a8b3;
}

.check-msg.error {
  background-color: #f2dede;
  color: #a94442;
  border: 1px solid #ebcccc;
}

.check-msg.macro {
  background-color: #d7dac2;
  color: #4f5c6d;
  border: 1px solid #d7dac2;
}

.check-msg.note {
  background-color: #d7d7d7;
  color: #4f5c6d;
  border: 1px solid #bfbfbf;
}

.check-msg.current {
  border: 2px dashed #3692ff;
}

.check-msg .tag {
  padding: 1px 5px;
  text-align: center;
  border-radius: 2px;
  margin-right: 5px;
  text-decoration: inherit;
}

.check-msg .tag.macro {
  background-color: #83876a;
  color: white;
  text-transform: capitalize;
}

.check-msg .tag.note {
  background-color: #9299a1;
  color: white;
  text-transform: capitalize;
}

.checker-enum {
  color: white;
  padding: 1px 5px;
  text-align: center;
  border-radius: 25px;
  margin-right: 5px;
  text-decoration: inherit;
}

.checker-enum.info {
  background-color: #427ea9;
}

.checker-enum.error {
  background-color: #a94442;
}

.arrow {
  border: solid black;
  border-width: 0 3px 3px 0;
  display: inline-block;
  padding: 3px;
  cursor: pointer;
  margin: 0px 5px;
}

.arrow:hover {
  border: solid #437ea8;
  border-width: 0 3px 3px 0;
}

.left-arrow {
  transform: rotate(135deg);
  -webkit-transform: rotate(135deg);
}

.right-arrow {
  transform: rotate(-45deg);
  -webkit-transform: rotate(-45deg);
}

    </style>

    <script type="text/javascript">
      function setNonCompatibleBrowserMessage() {
  document.body.innerHTML =
    '<h2 style="margin-left: 20px;">Your browser is not compatible with CodeChecker Viewer!</h2> \
     <p style="margin-left: 20px;">The version required for the following browsers are:</p> \
     <ul style="margin-left: 20px;"> \
     <li>Internet Explorer: version 9 or newer</li> \
     <li>Firefox: version 22.0 or newer</li> \
     </ul>';
}

// http://stackoverflow.com/questions/5916900/how-can-you-detect-the-version-of-a-browser
var browserVersion = (function(){
  var ua = navigator.userAgent, tem,
    M = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];

  if (/trident/i.test(M[1])) {
    tem = /\brv[ :]+(\d+)/g.exec(ua) || [];
    return 'IE ' + (tem[1] || '');
  }

  if (M[1] === 'Chrome') {
    tem = ua.match(/\b(OPR|Edge)\/(\d+)/);
    if (tem != null) return tem.slice(1).join(' ').replace('OPR', 'Opera');
  }

  M = M[2] ? [M[1], M[2]] : [navigator.appName, navigator.appVersion, '-?'];
  if ((tem = ua.match(/version\/(\d+)/i)) != null) M.splice(1, 1, tem[1]);
    return M.join(' ');
})();

var pos = browserVersion.indexOf(' ');
var browser = browserVersion.substr(0, pos);
var version = parseInt(browserVersion.substr(pos + 1));

var browserCompatible
  = browser === 'Firefox'
  ? version >= 22
  : browser === 'IE'
  ? version >= 9
  : true;


      /* MIT License

Copyright (C) 2017 by Marijn Haverbeke <marijnh@gmail.com> and others

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
 */
      !function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):e.CodeMirror=t()}(this,function(){"use strict";function e(e){return new RegExp("(^|\\s)"+e+"(?:$|\\s)\\s*")}function t(e){for(var t=e.childNodes.length;t>0;--t)e.removeChild(e.firstChild);return e}function r(e,r){return t(e).appendChild(r)}function n(e,t,r,n){var i=document.createElement(e);if(r&&(i.className=r),n&&(i.style.cssText=n),"string"==typeof t)i.appendChild(document.createTextNode(t));else if(t)for(var o=0;o<t.length;++o)i.appendChild(t[o]);return i}function i(e,t,r,i){var o=n(e,t,r,i);return o.setAttribute("role","presentation"),o}function o(e,t){if(3==t.nodeType&&(t=t.parentNode),e.contains)return e.contains(t);do{if(11==t.nodeType&&(t=t.host),t==e)return!0}while(t=t.parentNode)}function l(){var e;try{e=document.activeElement}catch(t){e=document.body||null}for(;e&&e.shadowRoot&&e.shadowRoot.activeElement;)e=e.shadowRoot.activeElement;return e}function s(t,r){var n=t.className;e(r).test(n)||(t.className+=(n?" ":"")+r)}function a(t,r){for(var n=t.split(" "),i=0;i<n.length;i++)n[i]&&!e(n[i]).test(r)&&(r+=" "+n[i]);return r}function u(e){var t=Array.prototype.slice.call(arguments,1);return function(){return e.apply(null,t)}}function c(e,t,r){t||(t={});for(var n in e)!e.hasOwnProperty(n)||!1===r&&t.hasOwnProperty(n)||(t[n]=e[n]);return t}function f(e,t,r,n,i){null==t&&-1==(t=e.search(/[^\s\u00a0]/))&&(t=e.length);for(var o=n||0,l=i||0;;){var s=e.indexOf("\t",o);if(s<0||s>=t)return l+(t-o);l+=s-o,l+=r-l%r,o=s+1}}function h(e,t){for(var r=0;r<e.length;++r)if(e[r]==t)return r;return-1}function d(e,t,r){for(var n=0,i=0;;){var o=e.indexOf("\t",n);-1==o&&(o=e.length);var l=o-n;if(o==e.length||i+l>=t)return n+Math.min(l,t-i);if(i+=o-n,i+=r-i%r,n=o+1,i>=t)return n}}function p(e){for(;Kl.length<=e;)Kl.push(g(Kl)+" ");return Kl[e]}function g(e){return e[e.length-1]}function v(e,t){for(var r=[],n=0;n<e.length;n++)r[n]=t(e[n],n);return r}function m(e,t,r){for(var n=0,i=r(t);n<e.length&&r(e[n])<=i;)n++;e.splice(n,0,t)}function y(){}function b(e,t){var r;return Object.create?r=Object.create(e):(y.prototype=e,r=new y),t&&c(t,r),r}function w(e){return/\w/.test(e)||e>""&&(e.toUpperCase()!=e.toLowerCase()||jl.test(e))}function x(e,t){return t?!!(t.source.indexOf("\\w")>-1&&w(e))||t.test(e):w(e)}function C(e){for(var t in e)if(e.hasOwnProperty(t)&&e[t])return!1;return!0}function S(e){return e.charCodeAt(0)>=768&&Xl.test(e)}function L(e,t,r){for(;(r<0?t>0:t<e.length)&&S(e.charAt(t));)t+=r;return t}function k(e,t,r){for(var n=t>r?-1:1;;){if(t==r)return t;var i=(t+r)/2,o=n<0?Math.ceil(i):Math.floor(i);if(o==t)return e(o)?t:r;e(o)?r=o:t=o+n}}function T(e,t,r){var o=this;this.input=r,o.scrollbarFiller=n("div",null,"CodeMirror-scrollbar-filler"),o.scrollbarFiller.setAttribute("cm-not-content","true"),o.gutterFiller=n("div",null,"CodeMirror-gutter-filler"),o.gutterFiller.setAttribute("cm-not-content","true"),o.lineDiv=i("div",null,"CodeMirror-code"),o.selectionDiv=n("div",null,null,"position: relative; z-index: 1"),o.cursorDiv=n("div",null,"CodeMirror-cursors"),o.measure=n("div",null,"CodeMirror-measure"),o.lineMeasure=n("div",null,"CodeMirror-measure"),o.lineSpace=i("div",[o.measure,o.lineMeasure,o.selectionDiv,o.cursorDiv,o.lineDiv],null,"position: relative; outline: none");var l=i("div",[o.lineSpace],"CodeMirror-lines");o.mover=n("div",[l],null,"position: relative"),o.sizer=n("div",[o.mover],"CodeMirror-sizer"),o.sizerWidth=null,o.heightForcer=n("div",null,null,"position: absolute; height: "+Rl+"px; width: 1px;"),o.gutters=n("div",null,"CodeMirror-gutters"),o.lineGutter=null,o.scroller=n("div",[o.sizer,o.heightForcer,o.gutters],"CodeMirror-scroll"),o.scroller.setAttribute("tabIndex","-1"),o.wrapper=n("div",[o.scrollbarFiller,o.gutterFiller,o.scroller],"CodeMirror"),gl&&vl<8&&(o.gutters.style.zIndex=-1,o.scroller.style.paddingRight=0),ml||fl&&Tl||(o.scroller.draggable=!0),e&&(e.appendChild?e.appendChild(o.wrapper):e(o.wrapper)),o.viewFrom=o.viewTo=t.first,o.reportedViewFrom=o.reportedViewTo=t.first,o.view=[],o.renderedView=null,o.externalMeasured=null,o.viewOffset=0,o.lastWrapHeight=o.lastWrapWidth=0,o.updateLineNumbers=null,o.nativeBarWidth=o.barHeight=o.barWidth=0,o.scrollbarsClipped=!1,o.lineNumWidth=o.lineNumInnerWidth=o.lineNumChars=null,o.alignWidgets=!1,o.cachedCharWidth=o.cachedTextHeight=o.cachedPaddingH=null,o.maxLine=null,o.maxLineLength=0,o.maxLineChanged=!1,o.wheelDX=o.wheelDY=o.wheelStartX=o.wheelStartY=null,o.shift=!1,o.selForContextMenu=null,o.activeTouch=null,r.init(o)}function M(e,t){if((t-=e.first)<0||t>=e.size)throw new Error("There is no line "+(t+e.first)+" in the document.");for(var r=e;!r.lines;)for(var n=0;;++n){var i=r.children[n],o=i.chunkSize();if(t<o){r=i;break}t-=o}return r.lines[t]}function N(e,t,r){var n=[],i=t.line;return e.iter(t.line,r.line+1,function(e){var o=e.text;i==r.line&&(o=o.slice(0,r.ch)),i==t.line&&(o=o.slice(t.ch)),n.push(o),++i}),n}function O(e,t,r){var n=[];return e.iter(t,r,function(e){n.push(e.text)}),n}function A(e,t){var r=t-e.height;if(r)for(var n=e;n;n=n.parent)n.height+=r}function W(e){if(null==e.parent)return null;for(var t=e.parent,r=h(t.lines,e),n=t.parent;n;t=n,n=n.parent)for(var i=0;n.children[i]!=t;++i)r+=n.children[i].chunkSize();return r+t.first}function D(e,t){var r=e.first;e:do{for(var n=0;n<e.children.length;++n){var i=e.children[n],o=i.height;if(t<o){e=i;continue e}t-=o,r+=i.chunkSize()}return r}while(!e.lines);for(var l=0;l<e.lines.length;++l){var s=e.lines[l].height;if(t<s)break;t-=s}return r+l}function H(e,t){return t>=e.first&&t<e.first+e.size}function F(e,t){return String(e.lineNumberFormatter(t+e.firstLineNumber))}function E(e,t,r){if(void 0===r&&(r=null),!(this instanceof E))return new E(e,t,r);this.line=e,this.ch=t,this.sticky=r}function P(e,t){return e.line-t.line||e.ch-t.ch}function I(e,t){return e.sticky==t.sticky&&0==P(e,t)}function z(e){return E(e.line,e.ch)}function R(e,t){return P(e,t)<0?t:e}function B(e,t){return P(e,t)<0?e:t}function G(e,t){return Math.max(e.first,Math.min(t,e.first+e.size-1))}function U(e,t){if(t.line<e.first)return E(e.first,0);var r=e.first+e.size-1;return t.line>r?E(r,M(e,r).text.length):V(t,M(e,t.line).text.length)}function V(e,t){var r=e.ch;return null==r||r>t?E(e.line,t):r<0?E(e.line,0):e}function K(e,t){for(var r=[],n=0;n<t.length;n++)r[n]=U(e,t[n]);return r}function j(){Yl=!0}function X(){_l=!0}function Y(e,t,r){this.marker=e,this.from=t,this.to=r}function _(e,t){if(e)for(var r=0;r<e.length;++r){var n=e[r];if(n.marker==t)return n}}function $(e,t){for(var r,n=0;n<e.length;++n)e[n]!=t&&(r||(r=[])).push(e[n]);return r}function q(e,t){e.markedSpans=e.markedSpans?e.markedSpans.concat([t]):[t],t.marker.attachLine(e)}function Z(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t)||o.from==t&&"bookmark"==l.type&&(!r||!o.marker.insertLeft)){var s=null==o.to||(l.inclusiveRight?o.to>=t:o.to>t);(n||(n=[])).push(new Y(l,o.from,s?null:o.to))}}return n}function Q(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.to||(l.inclusiveRight?o.to>=t:o.to>t)||o.from==t&&"bookmark"==l.type&&(!r||o.marker.insertLeft)){var s=null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t);(n||(n=[])).push(new Y(l,s?null:o.from-t,null==o.to?null:o.to-t))}}return n}function J(e,t){if(t.full)return null;var r=H(e,t.from.line)&&M(e,t.from.line).markedSpans,n=H(e,t.to.line)&&M(e,t.to.line).markedSpans;if(!r&&!n)return null;var i=t.from.ch,o=t.to.ch,l=0==P(t.from,t.to),s=Z(r,i,l),a=Q(n,o,l),u=1==t.text.length,c=g(t.text).length+(u?i:0);if(s)for(var f=0;f<s.length;++f){var h=s[f];if(null==h.to){var d=_(a,h.marker);d?u&&(h.to=null==d.to?null:d.to+c):h.to=i}}if(a)for(var p=0;p<a.length;++p){var v=a[p];null!=v.to&&(v.to+=c),null==v.from?_(s,v.marker)||(v.from=c,u&&(s||(s=[])).push(v)):(v.from+=c,u&&(s||(s=[])).push(v))}s&&(s=ee(s)),a&&a!=s&&(a=ee(a));var m=[s];if(!u){var y,b=t.text.length-2;if(b>0&&s)for(var w=0;w<s.length;++w)null==s[w].to&&(y||(y=[])).push(new Y(s[w].marker,null,null));for(var x=0;x<b;++x)m.push(y);m.push(a)}return m}function ee(e){for(var t=0;t<e.length;++t){var r=e[t];null!=r.from&&r.from==r.to&&!1!==r.marker.clearWhenEmpty&&e.splice(t--,1)}return e.length?e:null}function te(e,t,r){var n=null;if(e.iter(t.line,r.line+1,function(e){if(e.markedSpans)for(var t=0;t<e.markedSpans.length;++t){var r=e.markedSpans[t].marker;!r.readOnly||n&&-1!=h(n,r)||(n||(n=[])).push(r)}}),!n)return null;for(var i=[{from:t,to:r}],o=0;o<n.length;++o)for(var l=n[o],s=l.find(0),a=0;a<i.length;++a){var u=i[a];if(!(P(u.to,s.from)<0||P(u.from,s.to)>0)){var c=[a,1],f=P(u.from,s.from),d=P(u.to,s.to);(f<0||!l.inclusiveLeft&&!f)&&c.push({from:u.from,to:s.from}),(d>0||!l.inclusiveRight&&!d)&&c.push({from:s.to,to:u.to}),i.splice.apply(i,c),a+=c.length-3}}return i}function re(e){var t=e.markedSpans;if(t){for(var r=0;r<t.length;++r)t[r].marker.detachLine(e);e.markedSpans=null}}function ne(e,t){if(t){for(var r=0;r<t.length;++r)t[r].marker.attachLine(e);e.markedSpans=t}}function ie(e){return e.inclusiveLeft?-1:0}function oe(e){return e.inclusiveRight?1:0}function le(e,t){var r=e.lines.length-t.lines.length;if(0!=r)return r;var n=e.find(),i=t.find(),o=P(n.from,i.from)||ie(e)-ie(t);if(o)return-o;var l=P(n.to,i.to)||oe(e)-oe(t);return l||t.id-e.id}function se(e,t){var r,n=_l&&e.markedSpans;if(n)for(var i=void 0,o=0;o<n.length;++o)(i=n[o]).marker.collapsed&&null==(t?i.from:i.to)&&(!r||le(r,i.marker)<0)&&(r=i.marker);return r}function ae(e){return se(e,!0)}function ue(e){return se(e,!1)}function ce(e,t,r,n,i){var o=M(e,t),l=_l&&o.markedSpans;if(l)for(var s=0;s<l.length;++s){var a=l[s];if(a.marker.collapsed){var u=a.marker.find(0),c=P(u.from,r)||ie(a.marker)-ie(i),f=P(u.to,n)||oe(a.marker)-oe(i);if(!(c>=0&&f<=0||c<=0&&f>=0)&&(c<=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.to,r)>=0:P(u.to,r)>0)||c>=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.from,n)<=0:P(u.from,n)<0)))return!0}}}function fe(e){for(var t;t=ae(e);)e=t.find(-1,!0).line;return e}function he(e){for(var t;t=ue(e);)e=t.find(1,!0).line;return e}function de(e){for(var t,r;t=ue(e);)e=t.find(1,!0).line,(r||(r=[])).push(e);return r}function pe(e,t){var r=M(e,t),n=fe(r);return r==n?t:W(n)}function ge(e,t){if(t>e.lastLine())return t;var r,n=M(e,t);if(!ve(e,n))return t;for(;r=ue(n);)n=r.find(1,!0).line;return W(n)+1}function ve(e,t){var r=_l&&t.markedSpans;if(r)for(var n=void 0,i=0;i<r.length;++i)if((n=r[i]).marker.collapsed){if(null==n.from)return!0;if(!n.marker.widgetNode&&0==n.from&&n.marker.inclusiveLeft&&me(e,t,n))return!0}}function me(e,t,r){if(null==r.to){var n=r.marker.find(1,!0);return me(e,n.line,_(n.line.markedSpans,r.marker))}if(r.marker.inclusiveRight&&r.to==t.text.length)return!0;for(var i=void 0,o=0;o<t.markedSpans.length;++o)if((i=t.markedSpans[o]).marker.collapsed&&!i.marker.widgetNode&&i.from==r.to&&(null==i.to||i.to!=r.from)&&(i.marker.inclusiveLeft||r.marker.inclusiveRight)&&me(e,t,i))return!0}function ye(e){for(var t=0,r=(e=fe(e)).parent,n=0;n<r.lines.length;++n){var i=r.lines[n];if(i==e)break;t+=i.height}for(var o=r.parent;o;r=o,o=r.parent)for(var l=0;l<o.children.length;++l){var s=o.children[l];if(s==r)break;t+=s.height}return t}function be(e){if(0==e.height)return 0;for(var t,r=e.text.length,n=e;t=ae(n);){var i=t.find(0,!0);n=i.from.line,r+=i.from.ch-i.to.ch}for(n=e;t=ue(n);){var o=t.find(0,!0);r-=n.text.length-o.from.ch,r+=(n=o.to.line).text.length-o.to.ch}return r}function we(e){var t=e.display,r=e.doc;t.maxLine=M(r,r.first),t.maxLineLength=be(t.maxLine),t.maxLineChanged=!0,r.iter(function(e){var r=be(e);r>t.maxLineLength&&(t.maxLineLength=r,t.maxLine=e)})}function xe(e,t,r,n){if(!e)return n(t,r,"ltr",0);for(var i=!1,o=0;o<e.length;++o){var l=e[o];(l.from<r&&l.to>t||t==r&&l.to==t)&&(n(Math.max(l.from,t),Math.min(l.to,r),1==l.level?"rtl":"ltr",o),i=!0)}i||n(t,r,"ltr")}function Ce(e,t,r){var n;$l=null;for(var i=0;i<e.length;++i){var o=e[i];if(o.from<t&&o.to>t)return i;o.to==t&&(o.from!=o.to&&"before"==r?n=i:$l=i),o.from==t&&(o.from!=o.to&&"before"!=r?n=i:$l=i)}return null!=n?n:$l}function Se(e,t){var r=e.order;return null==r&&(r=e.order=ql(e.text,t)),r}function Le(e,t){return e._handlers&&e._handlers[t]||Zl}function ke(e,t,r){if(e.removeEventListener)e.removeEventListener(t,r,!1);else if(e.detachEvent)e.detachEvent("on"+t,r);else{var n=e._handlers,i=n&&n[t];if(i){var o=h(i,r);o>-1&&(n[t]=i.slice(0,o).concat(i.slice(o+1)))}}}function Te(e,t){var r=Le(e,t);if(r.length)for(var n=Array.prototype.slice.call(arguments,2),i=0;i<r.length;++i)r[i].apply(null,n)}function Me(e,t,r){return"string"==typeof t&&(t={type:t,preventDefault:function(){this.defaultPrevented=!0}}),Te(e,r||t.type,e,t),He(t)||t.codemirrorIgnore}function Ne(e){var t=e._handlers&&e._handlers.cursorActivity;if(t)for(var r=e.curOp.cursorActivityHandlers||(e.curOp.cursorActivityHandlers=[]),n=0;n<t.length;++n)-1==h(r,t[n])&&r.push(t[n])}function Oe(e,t){return Le(e,t).length>0}function Ae(e){e.prototype.on=function(e,t){Ql(this,e,t)},e.prototype.off=function(e,t){ke(this,e,t)}}function We(e){e.preventDefault?e.preventDefault():e.returnValue=!1}function De(e){e.stopPropagation?e.stopPropagation():e.cancelBubble=!0}function He(e){return null!=e.defaultPrevented?e.defaultPrevented:0==e.returnValue}function Fe(e){We(e),De(e)}function Ee(e){return e.target||e.srcElement}function Pe(e){var t=e.which;return null==t&&(1&e.button?t=1:2&e.button?t=3:4&e.button&&(t=2)),Ml&&e.ctrlKey&&1==t&&(t=3),t}function Ie(e){if(null==Il){var t=n("span","​");r(e,n("span",[t,document.createTextNode("x")])),0!=e.firstChild.offsetHeight&&(Il=t.offsetWidth<=1&&t.offsetHeight>2&&!(gl&&vl<8))}var i=Il?n("span","​"):n("span"," ",null,"display: inline-block; width: 1px; margin-right: -1px");return i.setAttribute("cm-text",""),i}function ze(e){if(null!=zl)return zl;var n=r(e,document.createTextNode("AخA")),i=Wl(n,0,1).getBoundingClientRect(),o=Wl(n,1,2).getBoundingClientRect();return t(e),!(!i||i.left==i.right)&&(zl=o.right-i.right<3)}function Re(e){if(null!=ns)return ns;var t=r(e,n("span","x")),i=t.getBoundingClientRect(),o=Wl(t,0,1).getBoundingClientRect();return ns=Math.abs(i.left-o.left)>1}function Be(e,t){arguments.length>2&&(t.dependencies=Array.prototype.slice.call(arguments,2)),is[e]=t}function Ge(e){if("string"==typeof e&&os.hasOwnProperty(e))e=os[e];else if(e&&"string"==typeof e.name&&os.hasOwnProperty(e.name)){var t=os[e.name];"string"==typeof t&&(t={name:t}),(e=b(t,e)).name=t.name}else{if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+xml$/.test(e))return Ge("application/xml");if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+json$/.test(e))return Ge("application/json")}return"string"==typeof e?{name:e}:e||{name:"null"}}function Ue(e,t){t=Ge(t);var r=is[t.name];if(!r)return Ue(e,"text/plain");var n=r(e,t);if(ls.hasOwnProperty(t.name)){var i=ls[t.name];for(var o in i)i.hasOwnProperty(o)&&(n.hasOwnProperty(o)&&(n["_"+o]=n[o]),n[o]=i[o])}if(n.name=t.name,t.helperType&&(n.helperType=t.helperType),t.modeProps)for(var l in t.modeProps)n[l]=t.modeProps[l];return n}function Ve(e,t){c(t,ls.hasOwnProperty(e)?ls[e]:ls[e]={})}function Ke(e,t){if(!0===t)return t;if(e.copyState)return e.copyState(t);var r={};for(var n in t){var i=t[n];i instanceof Array&&(i=i.concat([])),r[n]=i}return r}function je(e,t){for(var r;e.innerMode&&(r=e.innerMode(t))&&r.mode!=e;)t=r.state,e=r.mode;return r||{mode:e,state:t}}function Xe(e,t,r){return!e.startState||e.startState(t,r)}function Ye(e,t,r,n){var i=[e.state.modeGen],o={};tt(e,t.text,e.doc.mode,r,function(e,t){return i.push(e,t)},o,n);for(var l=r.state,s=0;s<e.state.overlays.length;++s)!function(n){var l=e.state.overlays[n],s=1,a=0;r.state=!0,tt(e,t.text,l.mode,r,function(e,t){for(var r=s;a<e;){var n=i[s];n>e&&i.splice(s,1,e,i[s+1],n),s+=2,a=Math.min(e,n)}if(t)if(l.opaque)i.splice(r,s-r,e,"overlay "+t),s=r+2;else for(;r<s;r+=2){var o=i[r+1];i[r+1]=(o?o+" ":"")+"overlay "+t}},o)}(s);return r.state=l,{styles:i,classes:o.bgClass||o.textClass?o:null}}function _e(e,t,r){if(!t.styles||t.styles[0]!=e.state.modeGen){var n=$e(e,W(t)),i=t.text.length>e.options.maxHighlightLength&&Ke(e.doc.mode,n.state),o=Ye(e,t,n);i&&(n.state=i),t.stateAfter=n.save(!i),t.styles=o.styles,o.classes?t.styleClasses=o.classes:t.styleClasses&&(t.styleClasses=null),r===e.doc.highlightFrontier&&(e.doc.modeFrontier=Math.max(e.doc.modeFrontier,++e.doc.highlightFrontier))}return t.styles}function $e(e,t,r){var n=e.doc,i=e.display;if(!n.mode.startState)return new us(n,!0,t);var o=rt(e,t,r),l=o>n.first&&M(n,o-1).stateAfter,s=l?us.fromSaved(n,l,o):new us(n,Xe(n.mode),o);return n.iter(o,t,function(r){qe(e,r.text,s);var n=s.line;r.stateAfter=n==t-1||n%5==0||n>=i.viewFrom&&n<i.viewTo?s.save():null,s.nextLine()}),r&&(n.modeFrontier=s.line),s}function qe(e,t,r,n){var i=e.doc.mode,o=new ss(t,e.options.tabSize,r);for(o.start=o.pos=n||0,""==t&&Ze(i,r.state);!o.eol();)Qe(i,o,r.state),o.start=o.pos}function Ze(e,t){if(e.blankLine)return e.blankLine(t);if(e.innerMode){var r=je(e,t);return r.mode.blankLine?r.mode.blankLine(r.state):void 0}}function Qe(e,t,r,n){for(var i=0;i<10;i++){n&&(n[0]=je(e,r).mode);var o=e.token(t,r);if(t.pos>t.start)return o}throw new Error("Mode "+e.name+" failed to advance stream.")}function Je(e,t,r,n){var i,o,l=e.doc,s=l.mode,a=M(l,(t=U(l,t)).line),u=$e(e,t.line,r),c=new ss(a.text,e.options.tabSize,u);for(n&&(o=[]);(n||c.pos<t.ch)&&!c.eol();)c.start=c.pos,i=Qe(s,c,u.state),n&&o.push(new cs(c,i,Ke(l.mode,u.state)));return n?o:new cs(c,i,u.state)}function et(e,t){if(e)for(;;){var r=e.match(/(?:^|\s+)line-(background-)?(\S+)/);if(!r)break;e=e.slice(0,r.index)+e.slice(r.index+r[0].length);var n=r[1]?"bgClass":"textClass";null==t[n]?t[n]=r[2]:new RegExp("(?:^|s)"+r[2]+"(?:$|s)").test(t[n])||(t[n]+=" "+r[2])}return e}function tt(e,t,r,n,i,o,l){var s=r.flattenSpans;null==s&&(s=e.options.flattenSpans);var a,u=0,c=null,f=new ss(t,e.options.tabSize,n),h=e.options.addModeClass&&[null];for(""==t&&et(Ze(r,n.state),o);!f.eol();){if(f.pos>e.options.maxHighlightLength?(s=!1,l&&qe(e,t,n,f.pos),f.pos=t.length,a=null):a=et(Qe(r,f,n.state,h),o),h){var d=h[0].name;d&&(a="m-"+(a?d+" "+a:d))}if(!s||c!=a){for(;u<f.start;)i(u=Math.min(f.start,u+5e3),c);c=a}f.start=f.pos}for(;u<f.pos;){var p=Math.min(f.pos,u+5e3);i(p,c),u=p}}function rt(e,t,r){for(var n,i,o=e.doc,l=r?-1:t-(e.doc.mode.innerMode?1e3:100),s=t;s>l;--s){if(s<=o.first)return o.first;var a=M(o,s-1),u=a.stateAfter;if(u&&(!r||s+(u instanceof as?u.lookAhead:0)<=o.modeFrontier))return s;var c=f(a.text,null,e.options.tabSize);(null==i||n>c)&&(i=s-1,n=c)}return i}function nt(e,t){if(e.modeFrontier=Math.min(e.modeFrontier,t),!(e.highlightFrontier<t-10)){for(var r=e.first,n=t-1;n>r;n--){var i=M(e,n).stateAfter;if(i&&(!(i instanceof as)||n+i.lookAhead<t)){r=n+1;break}}e.highlightFrontier=Math.min(e.highlightFrontier,r)}}function it(e,t,r,n){e.text=t,e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null),null!=e.order&&(e.order=null),re(e),ne(e,r);var i=n?n(e):1;i!=e.height&&A(e,i)}function ot(e){e.parent=null,re(e)}function lt(e,t){if(!e||/^\s*$/.test(e))return null;var r=t.addModeClass?ps:ds;return r[e]||(r[e]=e.replace(/\S+/g,"cm-$&"))}function st(e,t){var r=i("span",null,null,ml?"padding-right: .1px":null),n={pre:i("pre",[r],"CodeMirror-line"),content:r,col:0,pos:0,cm:e,trailingSpace:!1,splitSpaces:(gl||ml)&&e.getOption("lineWrapping")};t.measure={};for(var o=0;o<=(t.rest?t.rest.length:0);o++){var l=o?t.rest[o-1]:t.line,s=void 0;n.pos=0,n.addToken=ut,ze(e.display.measure)&&(s=Se(l,e.doc.direction))&&(n.addToken=ft(n.addToken,s)),n.map=[],dt(l,n,_e(e,l,t!=e.display.externalMeasured&&W(l))),l.styleClasses&&(l.styleClasses.bgClass&&(n.bgClass=a(l.styleClasses.bgClass,n.bgClass||"")),l.styleClasses.textClass&&(n.textClass=a(l.styleClasses.textClass,n.textClass||""))),0==n.map.length&&n.map.push(0,0,n.content.appendChild(Ie(e.display.measure))),0==o?(t.measure.map=n.map,t.measure.cache={}):((t.measure.maps||(t.measure.maps=[])).push(n.map),(t.measure.caches||(t.measure.caches=[])).push({}))}if(ml){var u=n.content.lastChild;(/\bcm-tab\b/.test(u.className)||u.querySelector&&u.querySelector(".cm-tab"))&&(n.content.className="cm-tab-wrap-hack")}return Te(e,"renderLine",e,t.line,n.pre),n.pre.className&&(n.textClass=a(n.pre.className,n.textClass||"")),n}function at(e){var t=n("span","•","cm-invalidchar");return t.title="\\u"+e.charCodeAt(0).toString(16),t.setAttribute("aria-label",t.title),t}function ut(e,t,r,i,o,l,s){if(t){var a,u=e.splitSpaces?ct(t,e.trailingSpace):t,c=e.cm.state.specialChars,f=!1;if(c.test(t)){a=document.createDocumentFragment();for(var h=0;;){c.lastIndex=h;var d=c.exec(t),g=d?d.index-h:t.length-h;if(g){var v=document.createTextNode(u.slice(h,h+g));gl&&vl<9?a.appendChild(n("span",[v])):a.appendChild(v),e.map.push(e.pos,e.pos+g,v),e.col+=g,e.pos+=g}if(!d)break;h+=g+1;var m=void 0;if("\t"==d[0]){var y=e.cm.options.tabSize,b=y-e.col%y;(m=a.appendChild(n("span",p(b),"cm-tab"))).setAttribute("role","presentation"),m.setAttribute("cm-text","\t"),e.col+=b}else"\r"==d[0]||"\n"==d[0]?((m=a.appendChild(n("span","\r"==d[0]?"␍":"␤","cm-invalidchar"))).setAttribute("cm-text",d[0]),e.col+=1):((m=e.cm.options.specialCharPlaceholder(d[0])).setAttribute("cm-text",d[0]),gl&&vl<9?a.appendChild(n("span",[m])):a.appendChild(m),e.col+=1);e.map.push(e.pos,e.pos+1,m),e.pos++}}else e.col+=t.length,a=document.createTextNode(u),e.map.push(e.pos,e.pos+t.length,a),gl&&vl<9&&(f=!0),e.pos+=t.length;if(e.trailingSpace=32==u.charCodeAt(t.length-1),r||i||o||f||s){var w=r||"";i&&(w+=i),o&&(w+=o);var x=n("span",[a],w,s);return l&&(x.title=l),e.content.appendChild(x)}e.content.appendChild(a)}}function ct(e,t){if(e.length>1&&!/  /.test(e))return e;for(var r=t,n="",i=0;i<e.length;i++){var o=e.charAt(i);" "!=o||!r||i!=e.length-1&&32!=e.charCodeAt(i+1)||(o=" "),n+=o,r=" "==o}return n}function ft(e,t){return function(r,n,i,o,l,s,a){i=i?i+" cm-force-border":"cm-force-border";for(var u=r.pos,c=u+n.length;;){for(var f=void 0,h=0;h<t.length&&!((f=t[h]).to>u&&f.from<=u);h++);if(f.to>=c)return e(r,n,i,o,l,s,a);e(r,n.slice(0,f.to-u),i,o,null,s,a),o=null,n=n.slice(f.to-u),u=f.to}}}function ht(e,t,r,n){var i=!n&&r.widgetNode;i&&e.map.push(e.pos,e.pos+t,i),!n&&e.cm.display.input.needsContentAttribute&&(i||(i=e.content.appendChild(document.createElement("span"))),i.setAttribute("cm-marker",r.id)),i&&(e.cm.display.input.setUneditable(i),e.content.appendChild(i)),e.pos+=t,e.trailingSpace=!1}function dt(e,t,r){var n=e.markedSpans,i=e.text,o=0;if(n)for(var l,s,a,u,c,f,h,d=i.length,p=0,g=1,v="",m=0;;){if(m==p){a=u=c=f=s="",h=null,m=1/0;for(var y=[],b=void 0,w=0;w<n.length;++w){var x=n[w],C=x.marker;"bookmark"==C.type&&x.from==p&&C.widgetNode?y.push(C):x.from<=p&&(null==x.to||x.to>p||C.collapsed&&x.to==p&&x.from==p)?(null!=x.to&&x.to!=p&&m>x.to&&(m=x.to,u=""),C.className&&(a+=" "+C.className),C.css&&(s=(s?s+";":"")+C.css),C.startStyle&&x.from==p&&(c+=" "+C.startStyle),C.endStyle&&x.to==m&&(b||(b=[])).push(C.endStyle,x.to),C.title&&!f&&(f=C.title),C.collapsed&&(!h||le(h.marker,C)<0)&&(h=x)):x.from>p&&m>x.from&&(m=x.from)}if(b)for(var S=0;S<b.length;S+=2)b[S+1]==m&&(u+=" "+b[S]);if(!h||h.from==p)for(var L=0;L<y.length;++L)ht(t,0,y[L]);if(h&&(h.from||0)==p){if(ht(t,(null==h.to?d+1:h.to)-p,h.marker,null==h.from),null==h.to)return;h.to==p&&(h=!1)}}if(p>=d)break;for(var k=Math.min(d,m);;){if(v){var T=p+v.length;if(!h){var M=T>k?v.slice(0,k-p):v;t.addToken(t,M,l?l+a:a,c,p+M.length==m?u:"",f,s)}if(T>=k){v=v.slice(k-p),p=k;break}p=T,c=""}v=i.slice(o,o=r[g++]),l=lt(r[g++],t.cm.options)}}else for(var N=1;N<r.length;N+=2)t.addToken(t,i.slice(o,o=r[N]),lt(r[N+1],t.cm.options))}function pt(e,t,r){this.line=t,this.rest=de(t),this.size=this.rest?W(g(this.rest))-r+1:1,this.node=this.text=null,this.hidden=ve(e,t)}function gt(e,t,r){for(var n,i=[],o=t;o<r;o=n){var l=new pt(e.doc,M(e.doc,o),o);n=o+l.size,i.push(l)}return i}function vt(e){gs?gs.ops.push(e):e.ownsGroup=gs={ops:[e],delayedCallbacks:[]}}function mt(e){var t=e.delayedCallbacks,r=0;do{for(;r<t.length;r++)t[r].call(null);for(var n=0;n<e.ops.length;n++){var i=e.ops[n];if(i.cursorActivityHandlers)for(;i.cursorActivityCalled<i.cursorActivityHandlers.length;)i.cursorActivityHandlers[i.cursorActivityCalled++].call(null,i.cm)}}while(r<t.length)}function yt(e,t){var r=e.ownsGroup;if(r)try{mt(r)}finally{gs=null,t(r)}}function bt(e,t){var r=Le(e,t);if(r.length){var n,i=Array.prototype.slice.call(arguments,2);gs?n=gs.delayedCallbacks:vs?n=vs:(n=vs=[],setTimeout(wt,0));for(var o=0;o<r.length;++o)!function(e){n.push(function(){return r[e].apply(null,i)})}(o)}}function wt(){var e=vs;vs=null;for(var t=0;t<e.length;++t)e[t]()}function xt(e,t,r,n){for(var i=0;i<t.changes.length;i++){var o=t.changes[i];"text"==o?kt(e,t):"gutter"==o?Mt(e,t,r,n):"class"==o?Tt(e,t):"widget"==o&&Nt(e,t,n)}t.changes=null}function Ct(e){return e.node==e.text&&(e.node=n("div",null,null,"position: relative"),e.text.parentNode&&e.text.parentNode.replaceChild(e.node,e.text),e.node.appendChild(e.text),gl&&vl<8&&(e.node.style.zIndex=2)),e.node}function St(e,t){var r=t.bgClass?t.bgClass+" "+(t.line.bgClass||""):t.line.bgClass;if(r&&(r+=" CodeMirror-linebackground"),t.background)r?t.background.className=r:(t.background.parentNode.removeChild(t.background),t.background=null);else if(r){var i=Ct(t);t.background=i.insertBefore(n("div",null,r),i.firstChild),e.display.input.setUneditable(t.background)}}function Lt(e,t){var r=e.display.externalMeasured;return r&&r.line==t.line?(e.display.externalMeasured=null,t.measure=r.measure,r.built):st(e,t)}function kt(e,t){var r=t.text.className,n=Lt(e,t);t.text==t.node&&(t.node=n.pre),t.text.parentNode.replaceChild(n.pre,t.text),t.text=n.pre,n.bgClass!=t.bgClass||n.textClass!=t.textClass?(t.bgClass=n.bgClass,t.textClass=n.textClass,Tt(e,t)):r&&(t.text.className=r)}function Tt(e,t){St(e,t),t.line.wrapClass?Ct(t).className=t.line.wrapClass:t.node!=t.text&&(t.node.className="");var r=t.textClass?t.textClass+" "+(t.line.textClass||""):t.line.textClass;t.text.className=r||""}function Mt(e,t,r,i){if(t.gutter&&(t.node.removeChild(t.gutter),t.gutter=null),t.gutterBackground&&(t.node.removeChild(t.gutterBackground),t.gutterBackground=null),t.line.gutterClass){var o=Ct(t);t.gutterBackground=n("div",null,"CodeMirror-gutter-background "+t.line.gutterClass,"left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px; width: "+i.gutterTotalWidth+"px"),e.display.input.setUneditable(t.gutterBackground),o.insertBefore(t.gutterBackground,t.text)}var l=t.line.gutterMarkers;if(e.options.lineNumbers||l){var s=Ct(t),a=t.gutter=n("div",null,"CodeMirror-gutter-wrapper","left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px");if(e.display.input.setUneditable(a),s.insertBefore(a,t.text),t.line.gutterClass&&(a.className+=" "+t.line.gutterClass),!e.options.lineNumbers||l&&l["CodeMirror-linenumbers"]||(t.lineNumber=a.appendChild(n("div",F(e.options,r),"CodeMirror-linenumber CodeMirror-gutter-elt","left: "+i.gutterLeft["CodeMirror-linenumbers"]+"px; width: "+e.display.lineNumInnerWidth+"px"))),l)for(var u=0;u<e.options.gutters.length;++u){var c=e.options.gutters[u],f=l.hasOwnProperty(c)&&l[c];f&&a.appendChild(n("div",[f],"CodeMirror-gutter-elt","left: "+i.gutterLeft[c]+"px; width: "+i.gutterWidth[c]+"px"))}}}function Nt(e,t,r){t.alignable&&(t.alignable=null);for(var n=t.node.firstChild,i=void 0;n;n=i)i=n.nextSibling,"CodeMirror-linewidget"==n.className&&t.node.removeChild(n);At(e,t,r)}function Ot(e,t,r,n){var i=Lt(e,t);return t.text=t.node=i.pre,i.bgClass&&(t.bgClass=i.bgClass),i.textClass&&(t.textClass=i.textClass),Tt(e,t),Mt(e,t,r,n),At(e,t,n),t.node}function At(e,t,r){if(Wt(e,t.line,t,r,!0),t.rest)for(var n=0;n<t.rest.length;n++)Wt(e,t.rest[n],t,r,!1)}function Wt(e,t,r,i,o){if(t.widgets)for(var l=Ct(r),s=0,a=t.widgets;s<a.length;++s){var u=a[s],c=n("div",[u.node],"CodeMirror-linewidget");u.handleMouseEvents||c.setAttribute("cm-ignore-events","true"),Dt(u,c,r,i),e.display.input.setUneditable(c),o&&u.above?l.insertBefore(c,r.gutter||r.text):l.appendChild(c),bt(u,"redraw")}}function Dt(e,t,r,n){if(e.noHScroll){(r.alignable||(r.alignable=[])).push(t);var i=n.wrapperWidth;t.style.left=n.fixedPos+"px",e.coverGutter||(i-=n.gutterTotalWidth,t.style.paddingLeft=n.gutterTotalWidth+"px"),t.style.width=i+"px"}e.coverGutter&&(t.style.zIndex=5,t.style.position="relative",e.noHScroll||(t.style.marginLeft=-n.gutterTotalWidth+"px"))}function Ht(e){if(null!=e.height)return e.height;var t=e.doc.cm;if(!t)return 0;if(!o(document.body,e.node)){var i="position: relative;";e.coverGutter&&(i+="margin-left: -"+t.display.gutters.offsetWidth+"px;"),e.noHScroll&&(i+="width: "+t.display.wrapper.clientWidth+"px;"),r(t.display.measure,n("div",[e.node],null,i))}return e.height=e.node.parentNode.offsetHeight}function Ft(e,t){for(var r=Ee(t);r!=e.wrapper;r=r.parentNode)if(!r||1==r.nodeType&&"true"==r.getAttribute("cm-ignore-events")||r.parentNode==e.sizer&&r!=e.mover)return!0}function Et(e){return e.lineSpace.offsetTop}function Pt(e){return e.mover.offsetHeight-e.lineSpace.offsetHeight}function It(e){if(e.cachedPaddingH)return e.cachedPaddingH;var t=r(e.measure,n("pre","x")),i=window.getComputedStyle?window.getComputedStyle(t):t.currentStyle,o={left:parseInt(i.paddingLeft),right:parseInt(i.paddingRight)};return isNaN(o.left)||isNaN(o.right)||(e.cachedPaddingH=o),o}function zt(e){return Rl-e.display.nativeBarWidth}function Rt(e){return e.display.scroller.clientWidth-zt(e)-e.display.barWidth}function Bt(e){return e.display.scroller.clientHeight-zt(e)-e.display.barHeight}function Gt(e,t,r){var n=e.options.lineWrapping,i=n&&Rt(e);if(!t.measure.heights||n&&t.measure.width!=i){var o=t.measure.heights=[];if(n){t.measure.width=i;for(var l=t.text.firstChild.getClientRects(),s=0;s<l.length-1;s++){var a=l[s],u=l[s+1];Math.abs(a.bottom-u.bottom)>2&&o.push((a.bottom+u.top)/2-r.top)}}o.push(r.bottom-r.top)}}function Ut(e,t,r){if(e.line==t)return{map:e.measure.map,cache:e.measure.cache};for(var n=0;n<e.rest.length;n++)if(e.rest[n]==t)return{map:e.measure.maps[n],cache:e.measure.caches[n]};for(var i=0;i<e.rest.length;i++)if(W(e.rest[i])>r)return{map:e.measure.maps[i],cache:e.measure.caches[i],before:!0}}function Vt(e,t){var n=W(t=fe(t)),i=e.display.externalMeasured=new pt(e.doc,t,n);i.lineN=n;var o=i.built=st(e,i);return i.text=o.pre,r(e.display.lineMeasure,o.pre),i}function Kt(e,t,r,n){return Yt(e,Xt(e,t),r,n)}function jt(e,t){if(t>=e.display.viewFrom&&t<e.display.viewTo)return e.display.view[Lr(e,t)];var r=e.display.externalMeasured;return r&&t>=r.lineN&&t<r.lineN+r.size?r:void 0}function Xt(e,t){var r=W(t),n=jt(e,r);n&&!n.text?n=null:n&&n.changes&&(xt(e,n,r,br(e)),e.curOp.forceUpdate=!0),n||(n=Vt(e,t));var i=Ut(n,t,r);return{line:t,view:n,rect:null,map:i.map,cache:i.cache,before:i.before,hasHeights:!1}}function Yt(e,t,r,n,i){t.before&&(r=-1);var o,l=r+(n||"");return t.cache.hasOwnProperty(l)?o=t.cache[l]:(t.rect||(t.rect=t.view.text.getBoundingClientRect()),t.hasHeights||(Gt(e,t.view,t.rect),t.hasHeights=!0),(o=qt(e,t,r,n)).bogus||(t.cache[l]=o)),{left:o.left,right:o.right,top:i?o.rtop:o.top,bottom:i?o.rbottom:o.bottom}}function _t(e,t,r){for(var n,i,o,l,s,a,u=0;u<e.length;u+=3)if(s=e[u],a=e[u+1],t<s?(i=0,o=1,l="left"):t<a?o=(i=t-s)+1:(u==e.length-3||t==a&&e[u+3]>t)&&(i=(o=a-s)-1,t>=a&&(l="right")),null!=i){if(n=e[u+2],s==a&&r==(n.insertLeft?"left":"right")&&(l=r),"left"==r&&0==i)for(;u&&e[u-2]==e[u-3]&&e[u-1].insertLeft;)n=e[2+(u-=3)],l="left";if("right"==r&&i==a-s)for(;u<e.length-3&&e[u+3]==e[u+4]&&!e[u+5].insertLeft;)n=e[(u+=3)+2],l="right";break}return{node:n,start:i,end:o,collapse:l,coverStart:s,coverEnd:a}}function $t(e,t){var r=ms;if("left"==t)for(var n=0;n<e.length&&(r=e[n]).left==r.right;n++);else for(var i=e.length-1;i>=0&&(r=e[i]).left==r.right;i--);return r}function qt(e,t,r,n){var i,o=_t(t.map,r,n),l=o.node,s=o.start,a=o.end,u=o.collapse;if(3==l.nodeType){for(var c=0;c<4;c++){for(;s&&S(t.line.text.charAt(o.coverStart+s));)--s;for(;o.coverStart+a<o.coverEnd&&S(t.line.text.charAt(o.coverStart+a));)++a;if((i=gl&&vl<9&&0==s&&a==o.coverEnd-o.coverStart?l.parentNode.getBoundingClientRect():$t(Wl(l,s,a).getClientRects(),n)).left||i.right||0==s)break;a=s,s-=1,u="right"}gl&&vl<11&&(i=Zt(e.display.measure,i))}else{s>0&&(u=n="right");var f;i=e.options.lineWrapping&&(f=l.getClientRects()).length>1?f["right"==n?f.length-1:0]:l.getBoundingClientRect()}if(gl&&vl<9&&!s&&(!i||!i.left&&!i.right)){var h=l.parentNode.getClientRects()[0];i=h?{left:h.left,right:h.left+yr(e.display),top:h.top,bottom:h.bottom}:ms}for(var d=i.top-t.rect.top,p=i.bottom-t.rect.top,g=(d+p)/2,v=t.view.measure.heights,m=0;m<v.length-1&&!(g<v[m]);m++);var y=m?v[m-1]:0,b=v[m],w={left:("right"==u?i.right:i.left)-t.rect.left,right:("left"==u?i.left:i.right)-t.rect.left,top:y,bottom:b};return i.left||i.right||(w.bogus=!0),e.options.singleCursorHeightPerLine||(w.rtop=d,w.rbottom=p),w}function Zt(e,t){if(!window.screen||null==screen.logicalXDPI||screen.logicalXDPI==screen.deviceXDPI||!Re(e))return t;var r=screen.logicalXDPI/screen.deviceXDPI,n=screen.logicalYDPI/screen.deviceYDPI;return{left:t.left*r,right:t.right*r,top:t.top*n,bottom:t.bottom*n}}function Qt(e){if(e.measure&&(e.measure.cache={},e.measure.heights=null,e.rest))for(var t=0;t<e.rest.length;t++)e.measure.caches[t]={}}function Jt(e){e.display.externalMeasure=null,t(e.display.lineMeasure);for(var r=0;r<e.display.view.length;r++)Qt(e.display.view[r])}function er(e){Jt(e),e.display.cachedCharWidth=e.display.cachedTextHeight=e.display.cachedPaddingH=null,e.options.lineWrapping||(e.display.maxLineChanged=!0),e.display.lineNumChars=null}function tr(){return bl&&kl?-(document.body.getBoundingClientRect().left-parseInt(getComputedStyle(document.body).marginLeft)):window.pageXOffset||(document.documentElement||document.body).scrollLeft}function rr(){return bl&&kl?-(document.body.getBoundingClientRect().top-parseInt(getComputedStyle(document.body).marginTop)):window.pageYOffset||(document.documentElement||document.body).scrollTop}function nr(e){var t=0;if(e.widgets)for(var r=0;r<e.widgets.length;++r)e.widgets[r].above&&(t+=Ht(e.widgets[r]));return t}function ir(e,t,r,n,i){if(!i){var o=nr(t);r.top+=o,r.bottom+=o}if("line"==n)return r;n||(n="local");var l=ye(t);if("local"==n?l+=Et(e.display):l-=e.display.viewOffset,"page"==n||"window"==n){var s=e.display.lineSpace.getBoundingClientRect();l+=s.top+("window"==n?0:rr());var a=s.left+("window"==n?0:tr());r.left+=a,r.right+=a}return r.top+=l,r.bottom+=l,r}function or(e,t,r){if("div"==r)return t;var n=t.left,i=t.top;if("page"==r)n-=tr(),i-=rr();else if("local"==r||!r){var o=e.display.sizer.getBoundingClientRect();n+=o.left,i+=o.top}var l=e.display.lineSpace.getBoundingClientRect();return{left:n-l.left,top:i-l.top}}function lr(e,t,r,n,i){return n||(n=M(e.doc,t.line)),ir(e,n,Kt(e,n,t.ch,i),r)}function sr(e,t,r,n,i,o){function l(t,l){var s=Yt(e,i,t,l?"right":"left",o);return l?s.left=s.right:s.right=s.left,ir(e,n,s,r)}function s(e,t,r){var n=1==a[t].level;return l(r?e-1:e,n!=r)}n=n||M(e.doc,t.line),i||(i=Xt(e,n));var a=Se(n,e.doc.direction),u=t.ch,c=t.sticky;if(u>=n.text.length?(u=n.text.length,c="before"):u<=0&&(u=0,c="after"),!a)return l("before"==c?u-1:u,"before"==c);var f=Ce(a,u,c),h=$l,d=s(u,f,"before"==c);return null!=h&&(d.other=s(u,h,"before"!=c)),d}function ar(e,t){var r=0;t=U(e.doc,t),e.options.lineWrapping||(r=yr(e.display)*t.ch);var n=M(e.doc,t.line),i=ye(n)+Et(e.display);return{left:r,right:r,top:i,bottom:i+n.height}}function ur(e,t,r,n,i){var o=E(e,t,r);return o.xRel=i,n&&(o.outside=!0),o}function cr(e,t,r){var n=e.doc;if((r+=e.display.viewOffset)<0)return ur(n.first,0,null,!0,-1);var i=D(n,r),o=n.first+n.size-1;if(i>o)return ur(n.first+n.size-1,M(n,o).text.length,null,!0,1);t<0&&(t=0);for(var l=M(n,i);;){var s=pr(e,l,i,t,r),a=ue(l),u=a&&a.find(0,!0);if(!a||!(s.ch>u.from.ch||s.ch==u.from.ch&&s.xRel>0))return s;i=W(l=u.to.line)}}function fr(e,t,r,n){n-=nr(t);var i=t.text.length,o=k(function(t){return Yt(e,r,t-1).bottom<=n},i,0);return i=k(function(t){return Yt(e,r,t).top>n},o,i),{begin:o,end:i}}function hr(e,t,r,n){return r||(r=Xt(e,t)),fr(e,t,r,ir(e,t,Yt(e,r,n),"line").top)}function dr(e,t,r,n){return!(e.bottom<=r)&&(e.top>r||(n?e.left:e.right)>t)}function pr(e,t,r,n,i){i-=ye(t);var o=Xt(e,t),l=nr(t),s=0,a=t.text.length,u=!0,c=Se(t,e.doc.direction);if(c){var f=(e.options.lineWrapping?vr:gr)(e,t,r,o,c,n,i);s=(u=1!=f.level)?f.from:f.to-1,a=u?f.to:f.from-1}var h,d,p=null,g=null,v=k(function(t){var r=Yt(e,o,t);return r.top+=l,r.bottom+=l,!!dr(r,n,i,!1)&&(r.top<=i&&r.left<=n&&(p=t,g=r),!0)},s,a),m=!1;if(g){var y=n-g.left<g.right-n,b=y==u;v=p+(b?0:1),d=b?"after":"before",h=y?g.left:g.right}else{u||v!=a&&v!=s||v++,d=0==v?"after":v==t.text.length?"before":Yt(e,o,v-(u?1:0)).bottom+l<=i==u?"after":"before";var w=sr(e,E(r,v,d),"line",t,o);h=w.left,m=i<w.top||i>=w.bottom}return v=L(t.text,v,1),ur(r,v,d,m,n-h)}function gr(e,t,r,n,i,o,l){var s=k(function(s){var a=i[s],u=1!=a.level;return dr(sr(e,E(r,u?a.to:a.from,u?"before":"after"),"line",t,n),o,l,!0)},0,i.length-1),a=i[s];if(s>0){var u=1!=a.level,c=sr(e,E(r,u?a.from:a.to,u?"after":"before"),"line",t,n);dr(c,o,l,!0)&&c.top>l&&(a=i[s-1])}return a}function vr(e,t,r,n,i,o,l){for(var s=fr(e,t,n,l),a=s.begin,u=s.end,c=null,f=null,h=0;h<i.length;h++){var d=i[h];if(!(d.from>=u||d.to<=a)){var p=Yt(e,n,1!=d.level?Math.min(u,d.to)-1:Math.max(a,d.from)).right,g=p<o?o-p+1e9:p-o;(!c||f>g)&&(c=d,f=g)}}return c||(c=i[i.length-1]),c.from<a&&(c={from:a,to:c.to,level:c.level}),c.to>u&&(c={from:c.from,to:u,level:c.level}),c}function mr(e){if(null!=e.cachedTextHeight)return e.cachedTextHeight;if(null==hs){hs=n("pre");for(var i=0;i<49;++i)hs.appendChild(document.createTextNode("x")),hs.appendChild(n("br"));hs.appendChild(document.createTextNode("x"))}r(e.measure,hs);var o=hs.offsetHeight/50;return o>3&&(e.cachedTextHeight=o),t(e.measure),o||1}function yr(e){if(null!=e.cachedCharWidth)return e.cachedCharWidth;var t=n("span","xxxxxxxxxx"),i=n("pre",[t]);r(e.measure,i);var o=t.getBoundingClientRect(),l=(o.right-o.left)/10;return l>2&&(e.cachedCharWidth=l),l||10}function br(e){for(var t=e.display,r={},n={},i=t.gutters.clientLeft,o=t.gutters.firstChild,l=0;o;o=o.nextSibling,++l)r[e.options.gutters[l]]=o.offsetLeft+o.clientLeft+i,n[e.options.gutters[l]]=o.clientWidth;return{fixedPos:wr(t),gutterTotalWidth:t.gutters.offsetWidth,gutterLeft:r,gutterWidth:n,wrapperWidth:t.wrapper.clientWidth}}function wr(e){return e.scroller.getBoundingClientRect().left-e.sizer.getBoundingClientRect().left}function xr(e){var t=mr(e.display),r=e.options.lineWrapping,n=r&&Math.max(5,e.display.scroller.clientWidth/yr(e.display)-3);return function(i){if(ve(e.doc,i))return 0;var o=0;if(i.widgets)for(var l=0;l<i.widgets.length;l++)i.widgets[l].height&&(o+=i.widgets[l].height);return r?o+(Math.ceil(i.text.length/n)||1)*t:o+t}}function Cr(e){var t=e.doc,r=xr(e);t.iter(function(e){var t=r(e);t!=e.height&&A(e,t)})}function Sr(e,t,r,n){var i=e.display;if(!r&&"true"==Ee(t).getAttribute("cm-not-content"))return null;var o,l,s=i.lineSpace.getBoundingClientRect();try{o=t.clientX-s.left,l=t.clientY-s.top}catch(t){return null}var a,u=cr(e,o,l);if(n&&1==u.xRel&&(a=M(e.doc,u.line).text).length==u.ch){var c=f(a,a.length,e.options.tabSize)-a.length;u=E(u.line,Math.max(0,Math.round((o-It(e.display).left)/yr(e.display))-c))}return u}function Lr(e,t){if(t>=e.display.viewTo)return null;if((t-=e.display.viewFrom)<0)return null;for(var r=e.display.view,n=0;n<r.length;n++)if((t-=r[n].size)<0)return n}function kr(e){e.display.input.showSelection(e.display.input.prepareSelection())}function Tr(e,t){void 0===t&&(t=!0);for(var r=e.doc,n={},i=n.cursors=document.createDocumentFragment(),o=n.selection=document.createDocumentFragment(),l=0;l<r.sel.ranges.length;l++)if(t||l!=r.sel.primIndex){var s=r.sel.ranges[l];if(!(s.from().line>=e.display.viewTo||s.to().line<e.display.viewFrom)){var a=s.empty();(a||e.options.showCursorWhenSelecting)&&Mr(e,s.head,i),a||Or(e,s,o)}}return n}function Mr(e,t,r){var i=sr(e,t,"div",null,null,!e.options.singleCursorHeightPerLine),o=r.appendChild(n("div"," ","CodeMirror-cursor"));if(o.style.left=i.left+"px",o.style.top=i.top+"px",o.style.height=Math.max(0,i.bottom-i.top)*e.options.cursorHeight+"px",i.other){var l=r.appendChild(n("div"," ","CodeMirror-cursor CodeMirror-secondarycursor"));l.style.display="",l.style.left=i.other.left+"px",l.style.top=i.other.top+"px",l.style.height=.85*(i.other.bottom-i.other.top)+"px"}}function Nr(e,t){return e.top-t.top||e.left-t.left}function Or(e,t,r){function i(e,t,r,i){t<0&&(t=0),t=Math.round(t),i=Math.round(i),a.appendChild(n("div",null,"CodeMirror-selected","position: absolute; left: "+e+"px;\n                             top: "+t+"px; width: "+(null==r?f-e:r)+"px;\n                             height: "+(i-t)+"px"))}function o(t,r,n){function o(r,n){return lr(e,E(t,r),"div",u,n)}var l,a,u=M(s,t),h=u.text.length,d=Se(u,s.direction);return xe(d,r||0,null==n?h:n,function(t,s,p,g){var v=o(t,"ltr"==p?"left":"right"),m=o(s-1,"ltr"==p?"right":"left");if("ltr"==p){var y=null==r&&0==t?c:v.left,b=null==n&&s==h?f:m.right;m.top-v.top<=3?i(y,m.top,b-y,m.bottom):(i(y,v.top,null,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top),i(c,m.top,m.right,m.bottom))}else if(t<s){var w=null==r&&0==t?f:v.right,x=null==n&&s==h?c:m.left;if(m.top-v.top<=3)i(x,m.top,w-x,m.bottom);else{var C=c;if(g){var S=hr(e,u,null,t).end;C=o(S-(/\s/.test(u.text.charAt(S-1))?2:1),"left").left}i(C,v.top,w-C,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top);var L=null;d.length,L=o(hr(e,u,null,s).begin,"right").right-x,i(x,m.top,L,m.bottom)}}(!l||Nr(v,l)<0)&&(l=v),Nr(m,l)<0&&(l=m),(!a||Nr(v,a)<0)&&(a=v),Nr(m,a)<0&&(a=m)}),{start:l,end:a}}var l=e.display,s=e.doc,a=document.createDocumentFragment(),u=It(e.display),c=u.left,f=Math.max(l.sizerWidth,Rt(e)-l.sizer.offsetLeft)-u.right,h=t.from(),d=t.to();if(h.line==d.line)o(h.line,h.ch,d.ch);else{var p=M(s,h.line),g=M(s,d.line),v=fe(p)==fe(g),m=o(h.line,h.ch,v?p.text.length+1:null).end,y=o(d.line,v?0:null,d.ch).start;v&&(m.top<y.top-2?(i(m.right,m.top,null,m.bottom),i(c,y.top,y.left,y.bottom)):i(m.right,m.top,y.left-m.right,m.bottom)),m.bottom<y.top&&i(c,m.bottom,null,y.top)}r.appendChild(a)}function Ar(e){if(e.state.focused){var t=e.display;clearInterval(t.blinker);var r=!0;t.cursorDiv.style.visibility="",e.options.cursorBlinkRate>0?t.blinker=setInterval(function(){return t.cursorDiv.style.visibility=(r=!r)?"":"hidden"},e.options.cursorBlinkRate):e.options.cursorBlinkRate<0&&(t.cursorDiv.style.visibility="hidden")}}function Wr(e){e.state.focused||(e.display.input.focus(),Hr(e))}function Dr(e){e.state.delayingBlurEvent=!0,setTimeout(function(){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1,Fr(e))},100)}function Hr(e,t){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1),"nocursor"!=e.options.readOnly&&(e.state.focused||(Te(e,"focus",e,t),e.state.focused=!0,s(e.display.wrapper,"CodeMirror-focused"),e.curOp||e.display.selForContextMenu==e.doc.sel||(e.display.input.reset(),ml&&setTimeout(function(){return e.display.input.reset(!0)},20)),e.display.input.receivedFocus()),Ar(e))}function Fr(e,t){e.state.delayingBlurEvent||(e.state.focused&&(Te(e,"blur",e,t),e.state.focused=!1,Fl(e.display.wrapper,"CodeMirror-focused")),clearInterval(e.display.blinker),setTimeout(function(){e.state.focused||(e.display.shift=!1)},150))}function Er(e){for(var t=e.display,r=t.lineDiv.offsetTop,n=0;n<t.view.length;n++){var i=t.view[n],o=void 0;if(!i.hidden){if(gl&&vl<8){var l=i.node.offsetTop+i.node.offsetHeight;o=l-r,r=l}else{var s=i.node.getBoundingClientRect();o=s.bottom-s.top}var a=i.line.height-o;if(o<2&&(o=mr(t)),(a>.005||a<-.005)&&(A(i.line,o),Pr(i.line),i.rest))for(var u=0;u<i.rest.length;u++)Pr(i.rest[u])}}}function Pr(e){if(e.widgets)for(var t=0;t<e.widgets.length;++t)e.widgets[t].height=e.widgets[t].node.parentNode.offsetHeight}function Ir(e,t,r){var n=r&&null!=r.top?Math.max(0,r.top):e.scroller.scrollTop;n=Math.floor(n-Et(e));var i=r&&null!=r.bottom?r.bottom:n+e.wrapper.clientHeight,o=D(t,n),l=D(t,i);if(r&&r.ensure){var s=r.ensure.from.line,a=r.ensure.to.line;s<o?(o=s,l=D(t,ye(M(t,s))+e.wrapper.clientHeight)):Math.min(a,t.lastLine())>=l&&(o=D(t,ye(M(t,a))-e.wrapper.clientHeight),l=a)}return{from:o,to:Math.max(l,o+1)}}function zr(e){var t=e.display,r=t.view;if(t.alignWidgets||t.gutters.firstChild&&e.options.fixedGutter){for(var n=wr(t)-t.scroller.scrollLeft+e.doc.scrollLeft,i=t.gutters.offsetWidth,o=n+"px",l=0;l<r.length;l++)if(!r[l].hidden){e.options.fixedGutter&&(r[l].gutter&&(r[l].gutter.style.left=o),r[l].gutterBackground&&(r[l].gutterBackground.style.left=o));var s=r[l].alignable;if(s)for(var a=0;a<s.length;a++)s[a].style.left=o}e.options.fixedGutter&&(t.gutters.style.left=n+i+"px")}}function Rr(e){if(!e.options.lineNumbers)return!1;var t=e.doc,r=F(e.options,t.first+t.size-1),i=e.display;if(r.length!=i.lineNumChars){var o=i.measure.appendChild(n("div",[n("div",r)],"CodeMirror-linenumber CodeMirror-gutter-elt")),l=o.firstChild.offsetWidth,s=o.offsetWidth-l;return i.lineGutter.style.width="",i.lineNumInnerWidth=Math.max(l,i.lineGutter.offsetWidth-s)+1,i.lineNumWidth=i.lineNumInnerWidth+s,i.lineNumChars=i.lineNumInnerWidth?r.length:-1,i.lineGutter.style.width=i.lineNumWidth+"px",Wn(e),!0}return!1}function Br(e,t){if(!Me(e,"scrollCursorIntoView")){var r=e.display,i=r.sizer.getBoundingClientRect(),o=null;if(t.top+i.top<0?o=!0:t.bottom+i.top>(window.innerHeight||document.documentElement.clientHeight)&&(o=!1),null!=o&&!Sl){var l=n("div","​",null,"position: absolute;\n                         top: "+(t.top-r.viewOffset-Et(e.display))+"px;\n                         height: "+(t.bottom-t.top+zt(e)+r.barHeight)+"px;\n                         left: "+t.left+"px; width: "+Math.max(2,t.right-t.left)+"px;");e.display.lineSpace.appendChild(l),l.scrollIntoView(o),e.display.lineSpace.removeChild(l)}}}function Gr(e,t,r,n){null==n&&(n=0);var i;e.options.lineWrapping||t!=r||(r="before"==(t=t.ch?E(t.line,"before"==t.sticky?t.ch-1:t.ch,"after"):t).sticky?E(t.line,t.ch+1,"before"):t);for(var o=0;o<5;o++){var l=!1,s=sr(e,t),a=r&&r!=t?sr(e,r):s,u=Vr(e,i={left:Math.min(s.left,a.left),top:Math.min(s.top,a.top)-n,right:Math.max(s.left,a.left),bottom:Math.max(s.bottom,a.bottom)+n}),c=e.doc.scrollTop,f=e.doc.scrollLeft;if(null!=u.scrollTop&&(qr(e,u.scrollTop),Math.abs(e.doc.scrollTop-c)>1&&(l=!0)),null!=u.scrollLeft&&(Qr(e,u.scrollLeft),Math.abs(e.doc.scrollLeft-f)>1&&(l=!0)),!l)break}return i}function Ur(e,t){var r=Vr(e,t);null!=r.scrollTop&&qr(e,r.scrollTop),null!=r.scrollLeft&&Qr(e,r.scrollLeft)}function Vr(e,t){var r=e.display,n=mr(e.display);t.top<0&&(t.top=0);var i=e.curOp&&null!=e.curOp.scrollTop?e.curOp.scrollTop:r.scroller.scrollTop,o=Bt(e),l={};t.bottom-t.top>o&&(t.bottom=t.top+o);var s=e.doc.height+Pt(r),a=t.top<n,u=t.bottom>s-n;if(t.top<i)l.scrollTop=a?0:t.top;else if(t.bottom>i+o){var c=Math.min(t.top,(u?s:t.bottom)-o);c!=i&&(l.scrollTop=c)}var f=e.curOp&&null!=e.curOp.scrollLeft?e.curOp.scrollLeft:r.scroller.scrollLeft,h=Rt(e)-(e.options.fixedGutter?r.gutters.offsetWidth:0),d=t.right-t.left>h;return d&&(t.right=t.left+h),t.left<10?l.scrollLeft=0:t.left<f?l.scrollLeft=Math.max(0,t.left-(d?0:10)):t.right>h+f-3&&(l.scrollLeft=t.right+(d?0:10)-h),l}function Kr(e,t){null!=t&&(_r(e),e.curOp.scrollTop=(null==e.curOp.scrollTop?e.doc.scrollTop:e.curOp.scrollTop)+t)}function jr(e){_r(e);var t=e.getCursor();e.curOp.scrollToPos={from:t,to:t,margin:e.options.cursorScrollMargin}}function Xr(e,t,r){null==t&&null==r||_r(e),null!=t&&(e.curOp.scrollLeft=t),null!=r&&(e.curOp.scrollTop=r)}function Yr(e,t){_r(e),e.curOp.scrollToPos=t}function _r(e){var t=e.curOp.scrollToPos;t&&(e.curOp.scrollToPos=null,$r(e,ar(e,t.from),ar(e,t.to),t.margin))}function $r(e,t,r,n){var i=Vr(e,{left:Math.min(t.left,r.left),top:Math.min(t.top,r.top)-n,right:Math.max(t.right,r.right),bottom:Math.max(t.bottom,r.bottom)+n});Xr(e,i.scrollLeft,i.scrollTop)}function qr(e,t){Math.abs(e.doc.scrollTop-t)<2||(fl||On(e,{top:t}),Zr(e,t,!0),fl&&On(e),Cn(e,100))}function Zr(e,t,r){t=Math.min(e.display.scroller.scrollHeight-e.display.scroller.clientHeight,t),(e.display.scroller.scrollTop!=t||r)&&(e.doc.scrollTop=t,e.display.scrollbars.setScrollTop(t),e.display.scroller.scrollTop!=t&&(e.display.scroller.scrollTop=t))}function Qr(e,t,r,n){t=Math.min(t,e.display.scroller.scrollWidth-e.display.scroller.clientWidth),(r?t==e.doc.scrollLeft:Math.abs(e.doc.scrollLeft-t)<2)&&!n||(e.doc.scrollLeft=t,zr(e),e.display.scroller.scrollLeft!=t&&(e.display.scroller.scrollLeft=t),e.display.scrollbars.setScrollLeft(t))}function Jr(e){var t=e.display,r=t.gutters.offsetWidth,n=Math.round(e.doc.height+Pt(e.display));return{clientHeight:t.scroller.clientHeight,viewHeight:t.wrapper.clientHeight,scrollWidth:t.scroller.scrollWidth,clientWidth:t.scroller.clientWidth,viewWidth:t.wrapper.clientWidth,barLeft:e.options.fixedGutter?r:0,docHeight:n,scrollHeight:n+zt(e)+t.barHeight,nativeBarWidth:t.nativeBarWidth,gutterWidth:r}}function en(e,t){t||(t=Jr(e));var r=e.display.barWidth,n=e.display.barHeight;tn(e,t);for(var i=0;i<4&&r!=e.display.barWidth||n!=e.display.barHeight;i++)r!=e.display.barWidth&&e.options.lineWrapping&&Er(e),tn(e,Jr(e)),r=e.display.barWidth,n=e.display.barHeight}function tn(e,t){var r=e.display,n=r.scrollbars.update(t);r.sizer.style.paddingRight=(r.barWidth=n.right)+"px",r.sizer.style.paddingBottom=(r.barHeight=n.bottom)+"px",r.heightForcer.style.borderBottom=n.bottom+"px solid transparent",n.right&&n.bottom?(r.scrollbarFiller.style.display="block",r.scrollbarFiller.style.height=n.bottom+"px",r.scrollbarFiller.style.width=n.right+"px"):r.scrollbarFiller.style.display="",n.bottom&&e.options.coverGutterNextToScrollbar&&e.options.fixedGutter?(r.gutterFiller.style.display="block",r.gutterFiller.style.height=n.bottom+"px",r.gutterFiller.style.width=t.gutterWidth+"px"):r.gutterFiller.style.display=""}function rn(e){e.display.scrollbars&&(e.display.scrollbars.clear(),e.display.scrollbars.addClass&&Fl(e.display.wrapper,e.display.scrollbars.addClass)),e.display.scrollbars=new ws[e.options.scrollbarStyle](function(t){e.display.wrapper.insertBefore(t,e.display.scrollbarFiller),Ql(t,"mousedown",function(){e.state.focused&&setTimeout(function(){return e.display.input.focus()},0)}),t.setAttribute("cm-not-content","true")},function(t,r){"horizontal"==r?Qr(e,t):qr(e,t)},e),e.display.scrollbars.addClass&&s(e.display.wrapper,e.display.scrollbars.addClass)}function nn(e){e.curOp={cm:e,viewChanged:!1,startHeight:e.doc.height,forceUpdate:!1,updateInput:null,typing:!1,changeObjs:null,cursorActivityHandlers:null,cursorActivityCalled:0,selectionChanged:!1,updateMaxLine:!1,scrollLeft:null,scrollTop:null,scrollToPos:null,focus:!1,id:++xs},vt(e.curOp)}function on(e){yt(e.curOp,function(e){for(var t=0;t<e.ops.length;t++)e.ops[t].cm.curOp=null;ln(e)})}function ln(e){for(var t=e.ops,r=0;r<t.length;r++)sn(t[r]);for(var n=0;n<t.length;n++)an(t[n]);for(var i=0;i<t.length;i++)un(t[i]);for(var o=0;o<t.length;o++)cn(t[o]);for(var l=0;l<t.length;l++)fn(t[l])}function sn(e){var t=e.cm,r=t.display;Ln(t),e.updateMaxLine&&we(t),e.mustUpdate=e.viewChanged||e.forceUpdate||null!=e.scrollTop||e.scrollToPos&&(e.scrollToPos.from.line<r.viewFrom||e.scrollToPos.to.line>=r.viewTo)||r.maxLineChanged&&t.options.lineWrapping,e.update=e.mustUpdate&&new Cs(t,e.mustUpdate&&{top:e.scrollTop,ensure:e.scrollToPos},e.forceUpdate)}function an(e){e.updatedDisplay=e.mustUpdate&&Mn(e.cm,e.update)}function un(e){var t=e.cm,r=t.display;e.updatedDisplay&&Er(t),e.barMeasure=Jr(t),r.maxLineChanged&&!t.options.lineWrapping&&(e.adjustWidthTo=Kt(t,r.maxLine,r.maxLine.text.length).left+3,t.display.sizerWidth=e.adjustWidthTo,e.barMeasure.scrollWidth=Math.max(r.scroller.clientWidth,r.sizer.offsetLeft+e.adjustWidthTo+zt(t)+t.display.barWidth),e.maxScrollLeft=Math.max(0,r.sizer.offsetLeft+e.adjustWidthTo-Rt(t))),(e.updatedDisplay||e.selectionChanged)&&(e.preparedSelection=r.input.prepareSelection())}function cn(e){var t=e.cm;null!=e.adjustWidthTo&&(t.display.sizer.style.minWidth=e.adjustWidthTo+"px",e.maxScrollLeft<t.doc.scrollLeft&&Qr(t,Math.min(t.display.scroller.scrollLeft,e.maxScrollLeft),!0),t.display.maxLineChanged=!1);var r=e.focus&&e.focus==l();e.preparedSelection&&t.display.input.showSelection(e.preparedSelection,r),(e.updatedDisplay||e.startHeight!=t.doc.height)&&en(t,e.barMeasure),e.updatedDisplay&&Dn(t,e.barMeasure),e.selectionChanged&&Ar(t),t.state.focused&&e.updateInput&&t.display.input.reset(e.typing),r&&Wr(e.cm)}function fn(e){var t=e.cm,r=t.display,n=t.doc;e.updatedDisplay&&Nn(t,e.update),null==r.wheelStartX||null==e.scrollTop&&null==e.scrollLeft&&!e.scrollToPos||(r.wheelStartX=r.wheelStartY=null),null!=e.scrollTop&&Zr(t,e.scrollTop,e.forceScroll),null!=e.scrollLeft&&Qr(t,e.scrollLeft,!0,!0),e.scrollToPos&&Br(t,Gr(t,U(n,e.scrollToPos.from),U(n,e.scrollToPos.to),e.scrollToPos.margin));var i=e.maybeHiddenMarkers,o=e.maybeUnhiddenMarkers;if(i)for(var l=0;l<i.length;++l)i[l].lines.length||Te(i[l],"hide");if(o)for(var s=0;s<o.length;++s)o[s].lines.length&&Te(o[s],"unhide");r.wrapper.offsetHeight&&(n.scrollTop=t.display.scroller.scrollTop),e.changeObjs&&Te(t,"changes",t,e.changeObjs),e.update&&e.update.finish()}function hn(e,t){if(e.curOp)return t();nn(e);try{return t()}finally{on(e)}}function dn(e,t){return function(){if(e.curOp)return t.apply(e,arguments);nn(e);try{return t.apply(e,arguments)}finally{on(e)}}}function pn(e){return function(){if(this.curOp)return e.apply(this,arguments);nn(this);try{return e.apply(this,arguments)}finally{on(this)}}}function gn(e){return function(){var t=this.cm;if(!t||t.curOp)return e.apply(this,arguments);nn(t);try{return e.apply(this,arguments)}finally{on(t)}}}function vn(e,t,r,n){null==t&&(t=e.doc.first),null==r&&(r=e.doc.first+e.doc.size),n||(n=0);var i=e.display;if(n&&r<i.viewTo&&(null==i.updateLineNumbers||i.updateLineNumbers>t)&&(i.updateLineNumbers=t),e.curOp.viewChanged=!0,t>=i.viewTo)_l&&pe(e.doc,t)<i.viewTo&&yn(e);else if(r<=i.viewFrom)_l&&ge(e.doc,r+n)>i.viewFrom?yn(e):(i.viewFrom+=n,i.viewTo+=n);else if(t<=i.viewFrom&&r>=i.viewTo)yn(e);else if(t<=i.viewFrom){var o=bn(e,r,r+n,1);o?(i.view=i.view.slice(o.index),i.viewFrom=o.lineN,i.viewTo+=n):yn(e)}else if(r>=i.viewTo){var l=bn(e,t,t,-1);l?(i.view=i.view.slice(0,l.index),i.viewTo=l.lineN):yn(e)}else{var s=bn(e,t,t,-1),a=bn(e,r,r+n,1);s&&a?(i.view=i.view.slice(0,s.index).concat(gt(e,s.lineN,a.lineN)).concat(i.view.slice(a.index)),i.viewTo+=n):yn(e)}var u=i.externalMeasured;u&&(r<u.lineN?u.lineN+=n:t<u.lineN+u.size&&(i.externalMeasured=null))}function mn(e,t,r){e.curOp.viewChanged=!0;var n=e.display,i=e.display.externalMeasured;if(i&&t>=i.lineN&&t<i.lineN+i.size&&(n.externalMeasured=null),!(t<n.viewFrom||t>=n.viewTo)){var o=n.view[Lr(e,t)];if(null!=o.node){var l=o.changes||(o.changes=[]);-1==h(l,r)&&l.push(r)}}}function yn(e){e.display.viewFrom=e.display.viewTo=e.doc.first,e.display.view=[],e.display.viewOffset=0}function bn(e,t,r,n){var i,o=Lr(e,t),l=e.display.view;if(!_l||r==e.doc.first+e.doc.size)return{index:o,lineN:r};for(var s=e.display.viewFrom,a=0;a<o;a++)s+=l[a].size;if(s!=t){if(n>0){if(o==l.length-1)return null;i=s+l[o].size-t,o++}else i=s-t;t+=i,r+=i}for(;pe(e.doc,r)!=r;){if(o==(n<0?0:l.length-1))return null;r+=n*l[o-(n<0?1:0)].size,o+=n}return{index:o,lineN:r}}function wn(e,t,r){var n=e.display;0==n.view.length||t>=n.viewTo||r<=n.viewFrom?(n.view=gt(e,t,r),n.viewFrom=t):(n.viewFrom>t?n.view=gt(e,t,n.viewFrom).concat(n.view):n.viewFrom<t&&(n.view=n.view.slice(Lr(e,t))),n.viewFrom=t,n.viewTo<r?n.view=n.view.concat(gt(e,n.viewTo,r)):n.viewTo>r&&(n.view=n.view.slice(0,Lr(e,r)))),n.viewTo=r}function xn(e){for(var t=e.display.view,r=0,n=0;n<t.length;n++){var i=t[n];i.hidden||i.node&&!i.changes||++r}return r}function Cn(e,t){e.doc.highlightFrontier<e.display.viewTo&&e.state.highlight.set(t,u(Sn,e))}function Sn(e){var t=e.doc;if(!(t.highlightFrontier>=e.display.viewTo)){var r=+new Date+e.options.workTime,n=$e(e,t.highlightFrontier),i=[];t.iter(n.line,Math.min(t.first+t.size,e.display.viewTo+500),function(o){if(n.line>=e.display.viewFrom){var l=o.styles,s=o.text.length>e.options.maxHighlightLength?Ke(t.mode,n.state):null,a=Ye(e,o,n,!0);s&&(n.state=s),o.styles=a.styles;var u=o.styleClasses,c=a.classes;c?o.styleClasses=c:u&&(o.styleClasses=null);for(var f=!l||l.length!=o.styles.length||u!=c&&(!u||!c||u.bgClass!=c.bgClass||u.textClass!=c.textClass),h=0;!f&&h<l.length;++h)f=l[h]!=o.styles[h];f&&i.push(n.line),o.stateAfter=n.save(),n.nextLine()}else o.text.length<=e.options.maxHighlightLength&&qe(e,o.text,n),o.stateAfter=n.line%5==0?n.save():null,n.nextLine();if(+new Date>r)return Cn(e,e.options.workDelay),!0}),t.highlightFrontier=n.line,t.modeFrontier=Math.max(t.modeFrontier,n.line),i.length&&hn(e,function(){for(var t=0;t<i.length;t++)mn(e,i[t],"text")})}}function Ln(e){var t=e.display;!t.scrollbarsClipped&&t.scroller.offsetWidth&&(t.nativeBarWidth=t.scroller.offsetWidth-t.scroller.clientWidth,t.heightForcer.style.height=zt(e)+"px",t.sizer.style.marginBottom=-t.nativeBarWidth+"px",t.sizer.style.borderRightWidth=zt(e)+"px",t.scrollbarsClipped=!0)}function kn(e){if(e.hasFocus())return null;var t=l();if(!t||!o(e.display.lineDiv,t))return null;var r={activeElt:t};if(window.getSelection){var n=window.getSelection();n.anchorNode&&n.extend&&o(e.display.lineDiv,n.anchorNode)&&(r.anchorNode=n.anchorNode,r.anchorOffset=n.anchorOffset,r.focusNode=n.focusNode,r.focusOffset=n.focusOffset)}return r}function Tn(e){if(e&&e.activeElt&&e.activeElt!=l()&&(e.activeElt.focus(),e.anchorNode&&o(document.body,e.anchorNode)&&o(document.body,e.focusNode))){var t=window.getSelection(),r=document.createRange();r.setEnd(e.anchorNode,e.anchorOffset),r.collapse(!1),t.removeAllRanges(),t.addRange(r),t.extend(e.focusNode,e.focusOffset)}}function Mn(e,r){var n=e.display,i=e.doc;if(r.editorIsHidden)return yn(e),!1;if(!r.force&&r.visible.from>=n.viewFrom&&r.visible.to<=n.viewTo&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo)&&n.renderedView==n.view&&0==xn(e))return!1;Rr(e)&&(yn(e),r.dims=br(e));var o=i.first+i.size,l=Math.max(r.visible.from-e.options.viewportMargin,i.first),s=Math.min(o,r.visible.to+e.options.viewportMargin);n.viewFrom<l&&l-n.viewFrom<20&&(l=Math.max(i.first,n.viewFrom)),n.viewTo>s&&n.viewTo-s<20&&(s=Math.min(o,n.viewTo)),_l&&(l=pe(e.doc,l),s=ge(e.doc,s));var a=l!=n.viewFrom||s!=n.viewTo||n.lastWrapHeight!=r.wrapperHeight||n.lastWrapWidth!=r.wrapperWidth;wn(e,l,s),n.viewOffset=ye(M(e.doc,n.viewFrom)),e.display.mover.style.top=n.viewOffset+"px";var u=xn(e);if(!a&&0==u&&!r.force&&n.renderedView==n.view&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo))return!1;var c=kn(e);return u>4&&(n.lineDiv.style.display="none"),An(e,n.updateLineNumbers,r.dims),u>4&&(n.lineDiv.style.display=""),n.renderedView=n.view,Tn(c),t(n.cursorDiv),t(n.selectionDiv),n.gutters.style.height=n.sizer.style.minHeight=0,a&&(n.lastWrapHeight=r.wrapperHeight,n.lastWrapWidth=r.wrapperWidth,Cn(e,400)),n.updateLineNumbers=null,!0}function Nn(e,t){for(var r=t.viewport,n=!0;(n&&e.options.lineWrapping&&t.oldDisplayWidth!=Rt(e)||(r&&null!=r.top&&(r={top:Math.min(e.doc.height+Pt(e.display)-Bt(e),r.top)}),t.visible=Ir(e.display,e.doc,r),!(t.visible.from>=e.display.viewFrom&&t.visible.to<=e.display.viewTo)))&&Mn(e,t);n=!1){Er(e);var i=Jr(e);kr(e),en(e,i),Dn(e,i),t.force=!1}t.signal(e,"update",e),e.display.viewFrom==e.display.reportedViewFrom&&e.display.viewTo==e.display.reportedViewTo||(t.signal(e,"viewportChange",e,e.display.viewFrom,e.display.viewTo),e.display.reportedViewFrom=e.display.viewFrom,e.display.reportedViewTo=e.display.viewTo)}function On(e,t){var r=new Cs(e,t);if(Mn(e,r)){Er(e),Nn(e,r);var n=Jr(e);kr(e),en(e,n),Dn(e,n),r.finish()}}function An(e,r,n){function i(t){var r=t.nextSibling;return ml&&Ml&&e.display.currentWheelTarget==t?t.style.display="none":t.parentNode.removeChild(t),r}for(var o=e.display,l=e.options.lineNumbers,s=o.lineDiv,a=s.firstChild,u=o.view,c=o.viewFrom,f=0;f<u.length;f++){var d=u[f];if(d.hidden);else if(d.node&&d.node.parentNode==s){for(;a!=d.node;)a=i(a);var p=l&&null!=r&&r<=c&&d.lineNumber;d.changes&&(h(d.changes,"gutter")>-1&&(p=!1),xt(e,d,c,n)),p&&(t(d.lineNumber),d.lineNumber.appendChild(document.createTextNode(F(e.options,c)))),a=d.node.nextSibling}else{var g=Ot(e,d,c,n);s.insertBefore(g,a)}c+=d.size}for(;a;)a=i(a)}function Wn(e){var t=e.display.gutters.offsetWidth;e.display.sizer.style.marginLeft=t+"px"}function Dn(e,t){e.display.sizer.style.minHeight=t.docHeight+"px",e.display.heightForcer.style.top=t.docHeight+"px",e.display.gutters.style.height=t.docHeight+e.display.barHeight+zt(e)+"px"}function Hn(e){var r=e.display.gutters,i=e.options.gutters;t(r);for(var o=0;o<i.length;++o){var l=i[o],s=r.appendChild(n("div",null,"CodeMirror-gutter "+l));"CodeMirror-linenumbers"==l&&(e.display.lineGutter=s,s.style.width=(e.display.lineNumWidth||1)+"px")}r.style.display=o?"":"none",Wn(e)}function Fn(e){var t=h(e.gutters,"CodeMirror-linenumbers");-1==t&&e.lineNumbers?e.gutters=e.gutters.concat(["CodeMirror-linenumbers"]):t>-1&&!e.lineNumbers&&(e.gutters=e.gutters.slice(0),e.gutters.splice(t,1))}function En(e){var t=e.wheelDeltaX,r=e.wheelDeltaY;return null==t&&e.detail&&e.axis==e.HORIZONTAL_AXIS&&(t=e.detail),null==r&&e.detail&&e.axis==e.VERTICAL_AXIS?r=e.detail:null==r&&(r=e.wheelDelta),{x:t,y:r}}function Pn(e){var t=En(e);return t.x*=Ls,t.y*=Ls,t}function In(e,t){var r=En(t),n=r.x,i=r.y,o=e.display,l=o.scroller,s=l.scrollWidth>l.clientWidth,a=l.scrollHeight>l.clientHeight;if(n&&s||i&&a){if(i&&Ml&&ml)e:for(var u=t.target,c=o.view;u!=l;u=u.parentNode)for(var f=0;f<c.length;f++)if(c[f].node==u){e.display.currentWheelTarget=u;break e}if(n&&!fl&&!wl&&null!=Ls)return i&&a&&qr(e,Math.max(0,l.scrollTop+i*Ls)),Qr(e,Math.max(0,l.scrollLeft+n*Ls)),(!i||i&&a)&&We(t),void(o.wheelStartX=null);if(i&&null!=Ls){var h=i*Ls,d=e.doc.scrollTop,p=d+o.wrapper.clientHeight;h<0?d=Math.max(0,d+h-50):p=Math.min(e.doc.height,p+h+50),On(e,{top:d,bottom:p})}Ss<20&&(null==o.wheelStartX?(o.wheelStartX=l.scrollLeft,o.wheelStartY=l.scrollTop,o.wheelDX=n,o.wheelDY=i,setTimeout(function(){if(null!=o.wheelStartX){var e=l.scrollLeft-o.wheelStartX,t=l.scrollTop-o.wheelStartY,r=t&&o.wheelDY&&t/o.wheelDY||e&&o.wheelDX&&e/o.wheelDX;o.wheelStartX=o.wheelStartY=null,r&&(Ls=(Ls*Ss+r)/(Ss+1),++Ss)}},200)):(o.wheelDX+=n,o.wheelDY+=i))}}function zn(e,t){var r=e[t];e.sort(function(e,t){return P(e.from(),t.from())}),t=h(e,r);for(var n=1;n<e.length;n++){var i=e[n],o=e[n-1];if(P(o.to(),i.from())>=0){var l=B(o.from(),i.from()),s=R(o.to(),i.to()),a=o.empty()?i.from()==i.head:o.from()==o.head;n<=t&&--t,e.splice(--n,2,new Ts(a?s:l,a?l:s))}}return new ks(e,t)}function Rn(e,t){return new ks([new Ts(e,t||e)],0)}function Bn(e){return e.text?E(e.from.line+e.text.length-1,g(e.text).length+(1==e.text.length?e.from.ch:0)):e.to}function Gn(e,t){if(P(e,t.from)<0)return e;if(P(e,t.to)<=0)return Bn(t);var r=e.line+t.text.length-(t.to.line-t.from.line)-1,n=e.ch;return e.line==t.to.line&&(n+=Bn(t).ch-t.to.ch),E(r,n)}function Un(e,t){for(var r=[],n=0;n<e.sel.ranges.length;n++){var i=e.sel.ranges[n];r.push(new Ts(Gn(i.anchor,t),Gn(i.head,t)))}return zn(r,e.sel.primIndex)}function Vn(e,t,r){return e.line==t.line?E(r.line,e.ch-t.ch+r.ch):E(r.line+(e.line-t.line),e.ch)}function Kn(e,t,r){for(var n=[],i=E(e.first,0),o=i,l=0;l<t.length;l++){var s=t[l],a=Vn(s.from,i,o),u=Vn(Bn(s),i,o);if(i=s.to,o=u,"around"==r){var c=e.sel.ranges[l],f=P(c.head,c.anchor)<0;n[l]=new Ts(f?u:a,f?a:u)}else n[l]=new Ts(a,a)}return new ks(n,e.sel.primIndex)}function jn(e){e.doc.mode=Ue(e.options,e.doc.modeOption),Xn(e)}function Xn(e){e.doc.iter(function(e){e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null)}),e.doc.modeFrontier=e.doc.highlightFrontier=e.doc.first,Cn(e,100),e.state.modeGen++,e.curOp&&vn(e)}function Yn(e,t){return 0==t.from.ch&&0==t.to.ch&&""==g(t.text)&&(!e.cm||e.cm.options.wholeLineUpdateBefore)}function _n(e,t,r,n){function i(e){return r?r[e]:null}function o(e,r,i){it(e,r,i,n),bt(e,"change",e,t)}function l(e,t){for(var r=[],o=e;o<t;++o)r.push(new fs(u[o],i(o),n));return r}var s=t.from,a=t.to,u=t.text,c=M(e,s.line),f=M(e,a.line),h=g(u),d=i(u.length-1),p=a.line-s.line;if(t.full)e.insert(0,l(0,u.length)),e.remove(u.length,e.size-u.length);else if(Yn(e,t)){var v=l(0,u.length-1);o(f,f.text,d),p&&e.remove(s.line,p),v.length&&e.insert(s.line,v)}else if(c==f)if(1==u.length)o(c,c.text.slice(0,s.ch)+h+c.text.slice(a.ch),d);else{var m=l(1,u.length-1);m.push(new fs(h+c.text.slice(a.ch),d,n)),o(c,c.text.slice(0,s.ch)+u[0],i(0)),e.insert(s.line+1,m)}else if(1==u.length)o(c,c.text.slice(0,s.ch)+u[0]+f.text.slice(a.ch),i(0)),e.remove(s.line+1,p);else{o(c,c.text.slice(0,s.ch)+u[0],i(0)),o(f,h+f.text.slice(a.ch),d);var y=l(1,u.length-1);p>1&&e.remove(s.line+1,p-1),e.insert(s.line+1,y)}bt(e,"change",e,t)}function $n(e,t,r){function n(e,i,o){if(e.linked)for(var l=0;l<e.linked.length;++l){var s=e.linked[l];if(s.doc!=i){var a=o&&s.sharedHist;r&&!a||(t(s.doc,a),n(s.doc,e,a))}}}n(e,null,!0)}function qn(e,t){if(t.cm)throw new Error("This document is already in use.");e.doc=t,t.cm=e,Cr(e),jn(e),Zn(e),e.options.lineWrapping||we(e),e.options.mode=t.modeOption,vn(e)}function Zn(e){("rtl"==e.doc.direction?s:Fl)(e.display.lineDiv,"CodeMirror-rtl")}function Qn(e){hn(e,function(){Zn(e),vn(e)})}function Jn(e){this.done=[],this.undone=[],this.undoDepth=1/0,this.lastModTime=this.lastSelTime=0,this.lastOp=this.lastSelOp=null,this.lastOrigin=this.lastSelOrigin=null,this.generation=this.maxGeneration=e||1}function ei(e,t){var r={from:z(t.from),to:Bn(t),text:N(e,t.from,t.to)};return si(e,r,t.from.line,t.to.line+1),$n(e,function(e){return si(e,r,t.from.line,t.to.line+1)},!0),r}function ti(e){for(;e.length&&g(e).ranges;)e.pop()}function ri(e,t){return t?(ti(e.done),g(e.done)):e.done.length&&!g(e.done).ranges?g(e.done):e.done.length>1&&!e.done[e.done.length-2].ranges?(e.done.pop(),g(e.done)):void 0}function ni(e,t,r,n){var i=e.history;i.undone.length=0;var o,l,s=+new Date;if((i.lastOp==n||i.lastOrigin==t.origin&&t.origin&&("+"==t.origin.charAt(0)&&e.cm&&i.lastModTime>s-e.cm.options.historyEventDelay||"*"==t.origin.charAt(0)))&&(o=ri(i,i.lastOp==n)))l=g(o.changes),0==P(t.from,t.to)&&0==P(t.from,l.to)?l.to=Bn(t):o.changes.push(ei(e,t));else{var a=g(i.done);for(a&&a.ranges||li(e.sel,i.done),o={changes:[ei(e,t)],generation:i.generation},i.done.push(o);i.done.length>i.undoDepth;)i.done.shift(),i.done[0].ranges||i.done.shift()}i.done.push(r),i.generation=++i.maxGeneration,i.lastModTime=i.lastSelTime=s,i.lastOp=i.lastSelOp=n,i.lastOrigin=i.lastSelOrigin=t.origin,l||Te(e,"historyAdded")}function ii(e,t,r,n){var i=t.charAt(0);return"*"==i||"+"==i&&r.ranges.length==n.ranges.length&&r.somethingSelected()==n.somethingSelected()&&new Date-e.history.lastSelTime<=(e.cm?e.cm.options.historyEventDelay:500)}function oi(e,t,r,n){var i=e.history,o=n&&n.origin;r==i.lastSelOp||o&&i.lastSelOrigin==o&&(i.lastModTime==i.lastSelTime&&i.lastOrigin==o||ii(e,o,g(i.done),t))?i.done[i.done.length-1]=t:li(t,i.done),i.lastSelTime=+new Date,i.lastSelOrigin=o,i.lastSelOp=r,n&&!1!==n.clearRedo&&ti(i.undone)}function li(e,t){var r=g(t);r&&r.ranges&&r.equals(e)||t.push(e)}function si(e,t,r,n){var i=t["spans_"+e.id],o=0;e.iter(Math.max(e.first,r),Math.min(e.first+e.size,n),function(r){r.markedSpans&&((i||(i=t["spans_"+e.id]={}))[o]=r.markedSpans),++o})}function ai(e){if(!e)return null;for(var t,r=0;r<e.length;++r)e[r].marker.explicitlyCleared?t||(t=e.slice(0,r)):t&&t.push(e[r]);return t?t.length?t:null:e}function ui(e,t){var r=t["spans_"+e.id];if(!r)return null;for(var n=[],i=0;i<t.text.length;++i)n.push(ai(r[i]));return n}function ci(e,t){var r=ui(e,t),n=J(e,t);if(!r)return n;if(!n)return r;for(var i=0;i<r.length;++i){var o=r[i],l=n[i];if(o&&l)e:for(var s=0;s<l.length;++s){for(var a=l[s],u=0;u<o.length;++u)if(o[u].marker==a.marker)continue e;o.push(a)}else l&&(r[i]=l)}return r}function fi(e,t,r){for(var n=[],i=0;i<e.length;++i){var o=e[i];if(o.ranges)n.push(r?ks.prototype.deepCopy.call(o):o);else{var l=o.changes,s=[];n.push({changes:s});for(var a=0;a<l.length;++a){var u=l[a],c=void 0;if(s.push({from:u.from,to:u.to,text:u.text}),t)for(var f in u)(c=f.match(/^spans_(\d+)$/))&&h(t,Number(c[1]))>-1&&(g(s)[f]=u[f],delete u[f])}}}return n}function hi(e,t,r,n){if(n){var i=e.anchor;if(r){var o=P(t,i)<0;o!=P(r,i)<0?(i=t,t=r):o!=P(t,r)<0&&(t=r)}return new Ts(i,t)}return new Ts(r||t,t)}function di(e,t,r,n,i){null==i&&(i=e.cm&&(e.cm.display.shift||e.extend)),bi(e,new ks([hi(e.sel.primary(),t,r,i)],0),n)}function pi(e,t,r){for(var n=[],i=e.cm&&(e.cm.display.shift||e.extend),o=0;o<e.sel.ranges.length;o++)n[o]=hi(e.sel.ranges[o],t[o],null,i);bi(e,zn(n,e.sel.primIndex),r)}function gi(e,t,r,n){var i=e.sel.ranges.slice(0);i[t]=r,bi(e,zn(i,e.sel.primIndex),n)}function vi(e,t,r,n){bi(e,Rn(t,r),n)}function mi(e,t,r){var n={ranges:t.ranges,update:function(t){var r=this;this.ranges=[];for(var n=0;n<t.length;n++)r.ranges[n]=new Ts(U(e,t[n].anchor),U(e,t[n].head))},origin:r&&r.origin};return Te(e,"beforeSelectionChange",e,n),e.cm&&Te(e.cm,"beforeSelectionChange",e.cm,n),n.ranges!=t.ranges?zn(n.ranges,n.ranges.length-1):t}function yi(e,t,r){var n=e.history.done,i=g(n);i&&i.ranges?(n[n.length-1]=t,wi(e,t,r)):bi(e,t,r)}function bi(e,t,r){wi(e,t,r),oi(e,e.sel,e.cm?e.cm.curOp.id:NaN,r)}function wi(e,t,r){(Oe(e,"beforeSelectionChange")||e.cm&&Oe(e.cm,"beforeSelectionChange"))&&(t=mi(e,t,r)),xi(e,Si(e,t,r&&r.bias||(P(t.primary().head,e.sel.primary().head)<0?-1:1),!0)),r&&!1===r.scroll||!e.cm||jr(e.cm)}function xi(e,t){t.equals(e.sel)||(e.sel=t,e.cm&&(e.cm.curOp.updateInput=e.cm.curOp.selectionChanged=!0,Ne(e.cm)),bt(e,"cursorActivity",e))}function Ci(e){xi(e,Si(e,e.sel,null,!1))}function Si(e,t,r,n){for(var i,o=0;o<t.ranges.length;o++){var l=t.ranges[o],s=t.ranges.length==e.sel.ranges.length&&e.sel.ranges[o],a=ki(e,l.anchor,s&&s.anchor,r,n),u=ki(e,l.head,s&&s.head,r,n);(i||a!=l.anchor||u!=l.head)&&(i||(i=t.ranges.slice(0,o)),i[o]=new Ts(a,u))}return i?zn(i,t.primIndex):t}function Li(e,t,r,n,i){var o=M(e,t.line);if(o.markedSpans)for(var l=0;l<o.markedSpans.length;++l){var s=o.markedSpans[l],a=s.marker;if((null==s.from||(a.inclusiveLeft?s.from<=t.ch:s.from<t.ch))&&(null==s.to||(a.inclusiveRight?s.to>=t.ch:s.to>t.ch))){if(i&&(Te(a,"beforeCursorEnter"),a.explicitlyCleared)){if(o.markedSpans){--l;continue}break}if(!a.atomic)continue;if(r){var u=a.find(n<0?1:-1),c=void 0;if((n<0?a.inclusiveRight:a.inclusiveLeft)&&(u=Ti(e,u,-n,u&&u.line==t.line?o:null)),u&&u.line==t.line&&(c=P(u,r))&&(n<0?c<0:c>0))return Li(e,u,t,n,i)}var f=a.find(n<0?-1:1);return(n<0?a.inclusiveLeft:a.inclusiveRight)&&(f=Ti(e,f,n,f.line==t.line?o:null)),f?Li(e,f,t,n,i):null}}return t}function ki(e,t,r,n,i){var o=n||1,l=Li(e,t,r,o,i)||!i&&Li(e,t,r,o,!0)||Li(e,t,r,-o,i)||!i&&Li(e,t,r,-o,!0);return l||(e.cantEdit=!0,E(e.first,0))}function Ti(e,t,r,n){return r<0&&0==t.ch?t.line>e.first?U(e,E(t.line-1)):null:r>0&&t.ch==(n||M(e,t.line)).text.length?t.line<e.first+e.size-1?E(t.line+1,0):null:new E(t.line,t.ch+r)}function Mi(e){e.setSelection(E(e.firstLine(),0),E(e.lastLine()),Gl)}function Ni(e,t,r){var n={canceled:!1,from:t.from,to:t.to,text:t.text,origin:t.origin,cancel:function(){return n.canceled=!0}};return r&&(n.update=function(t,r,i,o){t&&(n.from=U(e,t)),r&&(n.to=U(e,r)),i&&(n.text=i),void 0!==o&&(n.origin=o)}),Te(e,"beforeChange",e,n),e.cm&&Te(e.cm,"beforeChange",e.cm,n),n.canceled?null:{from:n.from,to:n.to,text:n.text,origin:n.origin}}function Oi(e,t,r){if(e.cm){if(!e.cm.curOp)return dn(e.cm,Oi)(e,t,r);if(e.cm.state.suppressEdits)return}if(!(Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"))||(t=Ni(e,t,!0))){var n=Yl&&!r&&te(e,t.from,t.to);if(n)for(var i=n.length-1;i>=0;--i)Ai(e,{from:n[i].from,to:n[i].to,text:i?[""]:t.text,origin:t.origin});else Ai(e,t)}}function Ai(e,t){if(1!=t.text.length||""!=t.text[0]||0!=P(t.from,t.to)){var r=Un(e,t);ni(e,t,r,e.cm?e.cm.curOp.id:NaN),Hi(e,t,r,J(e,t));var n=[];$n(e,function(e,r){r||-1!=h(n,e.history)||(zi(e.history,t),n.push(e.history)),Hi(e,t,null,J(e,t))})}}function Wi(e,t,r){if(!e.cm||!e.cm.state.suppressEdits||r){for(var n,i=e.history,o=e.sel,l="undo"==t?i.done:i.undone,s="undo"==t?i.undone:i.done,a=0;a<l.length&&(n=l[a],r?!n.ranges||n.equals(e.sel):n.ranges);a++);if(a!=l.length){for(i.lastOrigin=i.lastSelOrigin=null;(n=l.pop()).ranges;){if(li(n,s),r&&!n.equals(e.sel))return void bi(e,n,{clearRedo:!1});o=n}var u=[];li(o,s),s.push({changes:u,generation:i.generation}),i.generation=n.generation||++i.maxGeneration;for(var c=Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"),f=n.changes.length-1;f>=0;--f){var d=function(r){var i=n.changes[r];if(i.origin=t,c&&!Ni(e,i,!1))return l.length=0,{};u.push(ei(e,i));var o=r?Un(e,i):g(l);Hi(e,i,o,ci(e,i)),!r&&e.cm&&e.cm.scrollIntoView({from:i.from,to:Bn(i)});var s=[];$n(e,function(e,t){t||-1!=h(s,e.history)||(zi(e.history,i),s.push(e.history)),Hi(e,i,null,ci(e,i))})}(f);if(d)return d.v}}}}function Di(e,t){if(0!=t&&(e.first+=t,e.sel=new ks(v(e.sel.ranges,function(e){return new Ts(E(e.anchor.line+t,e.anchor.ch),E(e.head.line+t,e.head.ch))}),e.sel.primIndex),e.cm)){vn(e.cm,e.first,e.first-t,t);for(var r=e.cm.display,n=r.viewFrom;n<r.viewTo;n++)mn(e.cm,n,"gutter")}}function Hi(e,t,r,n){if(e.cm&&!e.cm.curOp)return dn(e.cm,Hi)(e,t,r,n);if(t.to.line<e.first)Di(e,t.text.length-1-(t.to.line-t.from.line));else if(!(t.from.line>e.lastLine())){if(t.from.line<e.first){var i=t.text.length-1-(e.first-t.from.line);Di(e,i),t={from:E(e.first,0),to:E(t.to.line+i,t.to.ch),text:[g(t.text)],origin:t.origin}}var o=e.lastLine();t.to.line>o&&(t={from:t.from,to:E(o,M(e,o).text.length),text:[t.text[0]],origin:t.origin}),t.removed=N(e,t.from,t.to),r||(r=Un(e,t)),e.cm?Fi(e.cm,t,n):_n(e,t,n),wi(e,r,Gl)}}function Fi(e,t,r){var n=e.doc,i=e.display,o=t.from,l=t.to,s=!1,a=o.line;e.options.lineWrapping||(a=W(fe(M(n,o.line))),n.iter(a,l.line+1,function(e){if(e==i.maxLine)return s=!0,!0})),n.sel.contains(t.from,t.to)>-1&&Ne(e),_n(n,t,r,xr(e)),e.options.lineWrapping||(n.iter(a,o.line+t.text.length,function(e){var t=be(e);t>i.maxLineLength&&(i.maxLine=e,i.maxLineLength=t,i.maxLineChanged=!0,s=!1)}),s&&(e.curOp.updateMaxLine=!0)),nt(n,o.line),Cn(e,400);var u=t.text.length-(l.line-o.line)-1;t.full?vn(e):o.line!=l.line||1!=t.text.length||Yn(e.doc,t)?vn(e,o.line,l.line+1,u):mn(e,o.line,"text");var c=Oe(e,"changes"),f=Oe(e,"change");if(f||c){var h={from:o,to:l,text:t.text,removed:t.removed,origin:t.origin};f&&bt(e,"change",e,h),c&&(e.curOp.changeObjs||(e.curOp.changeObjs=[])).push(h)}e.display.selForContextMenu=null}function Ei(e,t,r,n,i){if(n||(n=r),P(n,r)<0){var o;r=(o=[n,r])[0],n=o[1]}"string"==typeof t&&(t=e.splitLines(t)),Oi(e,{from:r,to:n,text:t,origin:i})}function Pi(e,t,r,n){r<e.line?e.line+=n:t<e.line&&(e.line=t,e.ch=0)}function Ii(e,t,r,n){for(var i=0;i<e.length;++i){var o=e[i],l=!0;if(o.ranges){o.copied||((o=e[i]=o.deepCopy()).copied=!0);for(var s=0;s<o.ranges.length;s++)Pi(o.ranges[s].anchor,t,r,n),Pi(o.ranges[s].head,t,r,n)}else{for(var a=0;a<o.changes.length;++a){var u=o.changes[a];if(r<u.from.line)u.from=E(u.from.line+n,u.from.ch),u.to=E(u.to.line+n,u.to.ch);else if(t<=u.to.line){l=!1;break}}l||(e.splice(0,i+1),i=0)}}}function zi(e,t){var r=t.from.line,n=t.to.line,i=t.text.length-(n-r)-1;Ii(e.done,r,n,i),Ii(e.undone,r,n,i)}function Ri(e,t,r,n){var i=t,o=t;return"number"==typeof t?o=M(e,G(e,t)):i=W(t),null==i?null:(n(o,i)&&e.cm&&mn(e.cm,i,r),o)}function Bi(e){var t=this;this.lines=e,this.parent=null;for(var r=0,n=0;n<e.length;++n)e[n].parent=t,r+=e[n].height;this.height=r}function Gi(e){var t=this;this.children=e;for(var r=0,n=0,i=0;i<e.length;++i){var o=e[i];r+=o.chunkSize(),n+=o.height,o.parent=t}this.size=r,this.height=n,this.parent=null}function Ui(e,t,r){ye(t)<(e.curOp&&e.curOp.scrollTop||e.doc.scrollTop)&&Kr(e,r)}function Vi(e,t,r,n){var i=new Ms(e,r,n),o=e.cm;return o&&i.noHScroll&&(o.display.alignWidgets=!0),Ri(e,t,"widget",function(t){var r=t.widgets||(t.widgets=[]);if(null==i.insertAt?r.push(i):r.splice(Math.min(r.length-1,Math.max(0,i.insertAt)),0,i),i.line=t,o&&!ve(e,t)){var n=ye(t)<e.scrollTop;A(t,t.height+Ht(i)),n&&Kr(o,i.height),o.curOp.forceUpdate=!0}return!0}),bt(o,"lineWidgetAdded",o,i,"number"==typeof t?t:W(t)),i}function Ki(e,t,r,n,o){if(n&&n.shared)return ji(e,t,r,n,o);if(e.cm&&!e.cm.curOp)return dn(e.cm,Ki)(e,t,r,n,o);var l=new Os(e,o),s=P(t,r);if(n&&c(n,l,!1),s>0||0==s&&!1!==l.clearWhenEmpty)return l;if(l.replacedWith&&(l.collapsed=!0,l.widgetNode=i("span",[l.replacedWith],"CodeMirror-widget"),n.handleMouseEvents||l.widgetNode.setAttribute("cm-ignore-events","true"),n.insertLeft&&(l.widgetNode.insertLeft=!0)),l.collapsed){if(ce(e,t.line,t,r,l)||t.line!=r.line&&ce(e,r.line,t,r,l))throw new Error("Inserting collapsed marker partially overlapping an existing one");X()}l.addToHistory&&ni(e,{from:t,to:r,origin:"markText"},e.sel,NaN);var a,u=t.line,f=e.cm;if(e.iter(u,r.line+1,function(e){f&&l.collapsed&&!f.options.lineWrapping&&fe(e)==f.display.maxLine&&(a=!0),l.collapsed&&u!=t.line&&A(e,0),q(e,new Y(l,u==t.line?t.ch:null,u==r.line?r.ch:null)),++u}),l.collapsed&&e.iter(t.line,r.line+1,function(t){ve(e,t)&&A(t,0)}),l.clearOnEnter&&Ql(l,"beforeCursorEnter",function(){return l.clear()}),l.readOnly&&(j(),(e.history.done.length||e.history.undone.length)&&e.clearHistory()),l.collapsed&&(l.id=++Ns,l.atomic=!0),f){if(a&&(f.curOp.updateMaxLine=!0),l.collapsed)vn(f,t.line,r.line+1);else if(l.className||l.title||l.startStyle||l.endStyle||l.css)for(var h=t.line;h<=r.line;h++)mn(f,h,"text");l.atomic&&Ci(f.doc),bt(f,"markerAdded",f,l)}return l}function ji(e,t,r,n,i){(n=c(n)).shared=!1;var o=[Ki(e,t,r,n,i)],l=o[0],s=n.widgetNode;return $n(e,function(e){s&&(n.widgetNode=s.cloneNode(!0)),o.push(Ki(e,U(e,t),U(e,r),n,i));for(var a=0;a<e.linked.length;++a)if(e.linked[a].isParent)return;l=g(o)}),new As(o,l)}function Xi(e){return e.findMarks(E(e.first,0),e.clipPos(E(e.lastLine())),function(e){return e.parent})}function Yi(e,t){for(var r=0;r<t.length;r++){var n=t[r],i=n.find(),o=e.clipPos(i.from),l=e.clipPos(i.to);if(P(o,l)){var s=Ki(e,o,l,n.primary,n.primary.type);n.markers.push(s),s.parent=n}}}function _i(e){for(var t=0;t<e.length;t++)!function(t){var r=e[t],n=[r.primary.doc];$n(r.primary.doc,function(e){return n.push(e)});for(var i=0;i<r.markers.length;i++){var o=r.markers[i];-1==h(n,o.doc)&&(o.parent=null,r.markers.splice(i--,1))}}(t)}function $i(e){var t=this;if(Qi(t),!Me(t,e)&&!Ft(t.display,e)){We(e),gl&&(Hs=+new Date);var r=Sr(t,e,!0),n=e.dataTransfer.files;if(r&&!t.isReadOnly())if(n&&n.length&&window.FileReader&&window.File)for(var i=n.length,o=Array(i),l=0,s=0;s<i;++s)!function(e,n){if(!t.options.allowDropFileTypes||-1!=h(t.options.allowDropFileTypes,e.type)){var s=new FileReader;s.onload=dn(t,function(){var e=s.result;if(/[\x00-\x08\x0e-\x1f]{2}/.test(e)&&(e=""),o[n]=e,++l==i){var a={from:r=U(t.doc,r),to:r,text:t.doc.splitLines(o.join(t.doc.lineSeparator())),origin:"paste"};Oi(t.doc,a),yi(t.doc,Rn(r,Bn(a)))}}),s.readAsText(e)}}(n[s],s);else{if(t.state.draggingText&&t.doc.sel.contains(r)>-1)return t.state.draggingText(e),void setTimeout(function(){return t.display.input.focus()},20);try{var a=e.dataTransfer.getData("Text");if(a){var u;if(t.state.draggingText&&!t.state.draggingText.copy&&(u=t.listSelections()),wi(t.doc,Rn(r,r)),u)for(var c=0;c<u.length;++c)Ei(t.doc,"",u[c].anchor,u[c].head,"drag");t.replaceSelection(a,"around","paste"),t.display.input.focus()}}catch(e){}}}}function qi(e,t){if(gl&&(!e.state.draggingText||+new Date-Hs<100))Fe(t);else if(!Me(e,t)&&!Ft(e.display,t)&&(t.dataTransfer.setData("Text",e.getSelection()),t.dataTransfer.effectAllowed="copyMove",t.dataTransfer.setDragImage&&!xl)){var r=n("img",null,null,"position: fixed; left: 0; top: 0;");r.src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",wl&&(r.width=r.height=1,e.display.wrapper.appendChild(r),r._top=r.offsetTop),t.dataTransfer.setDragImage(r,0,0),wl&&r.parentNode.removeChild(r)}}function Zi(e,t){var i=Sr(e,t);if(i){var o=document.createDocumentFragment();Mr(e,i,o),e.display.dragCursor||(e.display.dragCursor=n("div",null,"CodeMirror-cursors CodeMirror-dragcursors"),e.display.lineSpace.insertBefore(e.display.dragCursor,e.display.cursorDiv)),r(e.display.dragCursor,o)}}function Qi(e){e.display.dragCursor&&(e.display.lineSpace.removeChild(e.display.dragCursor),e.display.dragCursor=null)}function Ji(e){if(document.getElementsByClassName)for(var t=document.getElementsByClassName("CodeMirror"),r=0;r<t.length;r++){var n=t[r].CodeMirror;n&&e(n)}}function eo(){Fs||(to(),Fs=!0)}function to(){var e;Ql(window,"resize",function(){null==e&&(e=setTimeout(function(){e=null,Ji(ro)},100))}),Ql(window,"blur",function(){return Ji(Fr)})}function ro(e){var t=e.display;t.lastWrapHeight==t.wrapper.clientHeight&&t.lastWrapWidth==t.wrapper.clientWidth||(t.cachedCharWidth=t.cachedTextHeight=t.cachedPaddingH=null,t.scrollbarsClipped=!1,e.setSize())}function no(e){var t=e.split(/-(?!$)/);e=t[t.length-1];for(var r,n,i,o,l=0;l<t.length-1;l++){var s=t[l];if(/^(cmd|meta|m)$/i.test(s))o=!0;else if(/^a(lt)?$/i.test(s))r=!0;else if(/^(c|ctrl|control)$/i.test(s))n=!0;else{if(!/^s(hift)?$/i.test(s))throw new Error("Unrecognized modifier name: "+s);i=!0}}return r&&(e="Alt-"+e),n&&(e="Ctrl-"+e),o&&(e="Cmd-"+e),i&&(e="Shift-"+e),e}function io(e){var t={};for(var r in e)if(e.hasOwnProperty(r)){var n=e[r];if(/^(name|fallthrough|(de|at)tach)$/.test(r))continue;if("..."==n){delete e[r];continue}for(var i=v(r.split(" "),no),o=0;o<i.length;o++){var l=void 0,s=void 0;o==i.length-1?(s=i.join(" "),l=n):(s=i.slice(0,o+1).join(" "),l="...");var a=t[s];if(a){if(a!=l)throw new Error("Inconsistent bindings for "+s)}else t[s]=l}delete e[r]}for(var u in t)e[u]=t[u];return e}function oo(e,t,r,n){var i=(t=uo(t)).call?t.call(e,n):t[e];if(!1===i)return"nothing";if("..."===i)return"multi";if(null!=i&&r(i))return"handled";if(t.fallthrough){if("[object Array]"!=Object.prototype.toString.call(t.fallthrough))return oo(e,t.fallthrough,r,n);for(var o=0;o<t.fallthrough.length;o++){var l=oo(e,t.fallthrough[o],r,n);if(l)return l}}}function lo(e){var t="string"==typeof e?e:Es[e.keyCode];return"Ctrl"==t||"Alt"==t||"Shift"==t||"Mod"==t}function so(e,t,r){var n=e;return t.altKey&&"Alt"!=n&&(e="Alt-"+e),(Dl?t.metaKey:t.ctrlKey)&&"Ctrl"!=n&&(e="Ctrl-"+e),(Dl?t.ctrlKey:t.metaKey)&&"Cmd"!=n&&(e="Cmd-"+e),!r&&t.shiftKey&&"Shift"!=n&&(e="Shift-"+e),e}function ao(e,t){if(wl&&34==e.keyCode&&e.char)return!1;var r=Es[e.keyCode];return null!=r&&!e.altGraphKey&&so(r,e,t)}function uo(e){return"string"==typeof e?Rs[e]:e}function co(e,t){for(var r=e.doc.sel.ranges,n=[],i=0;i<r.length;i++){for(var o=t(r[i]);n.length&&P(o.from,g(n).to)<=0;){var l=n.pop();if(P(l.from,o.from)<0){o.from=l.from;break}}n.push(o)}hn(e,function(){for(var t=n.length-1;t>=0;t--)Ei(e.doc,"",n[t].from,n[t].to,"+delete");jr(e)})}function fo(e,t,r){var n=L(e.text,t+r,r);return n<0||n>e.text.length?null:n}function ho(e,t,r){var n=fo(e,t.ch,r);return null==n?null:new E(t.line,n,r<0?"after":"before")}function po(e,t,r,n,i){if(e){var o=Se(r,t.doc.direction);if(o){var l,s=i<0?g(o):o[0],a=i<0==(1==s.level)?"after":"before";if(s.level>0){var u=Xt(t,r);l=i<0?r.text.length-1:0;var c=Yt(t,u,l).top;l=k(function(e){return Yt(t,u,e).top==c},i<0==(1==s.level)?s.from:s.to-1,l),"before"==a&&(l=fo(r,l,1))}else l=i<0?s.to:s.from;return new E(n,l,a)}}return new E(n,i<0?r.text.length:0,i<0?"before":"after")}function go(e,t,r,n){var i=Se(t,e.doc.direction);if(!i)return ho(t,r,n);r.ch>=t.text.length?(r.ch=t.text.length,r.sticky="before"):r.ch<=0&&(r.ch=0,r.sticky="after");var o=Ce(i,r.ch,r.sticky),l=i[o];if("ltr"==e.doc.direction&&l.level%2==0&&(n>0?l.to>r.ch:l.from<r.ch))return ho(t,r,n);var s,a=function(e,r){return fo(t,e instanceof E?e.ch:e,r)},u=function(r){return e.options.lineWrapping?(s=s||Xt(e,t),hr(e,t,s,r)):{begin:0,end:t.text.length}},c=u("before"==r.sticky?a(r,-1):r.ch);if("rtl"==e.doc.direction||1==l.level){var f=1==l.level==n<0,h=a(r,f?1:-1);if(null!=h&&(f?h<=l.to&&h<=c.end:h>=l.from&&h>=c.begin)){var d=f?"before":"after";return new E(r.line,h,d)}}var p=function(e,t,n){for(var o=function(e,t){return t?new E(r.line,a(e,1),"before"):new E(r.line,e,"after")};e>=0&&e<i.length;e+=t){var l=i[e],s=t>0==(1!=l.level),u=s?n.begin:a(n.end,-1);if(l.from<=u&&u<l.to)return o(u,s);if(u=s?l.from:a(l.to,-1),n.begin<=u&&u<n.end)return o(u,s)}},g=p(o+n,n,c);if(g)return g;var v=n>0?c.end:a(c.begin,-1);return null==v||n>0&&v==t.text.length||!(g=p(n>0?0:i.length-1,n,u(v)))?null:g}function vo(e,t){var r=M(e.doc,t),n=fe(r);return n!=r&&(t=W(n)),po(!0,e,n,t,1)}function mo(e,t){var r=M(e.doc,t),n=he(r);return n!=r&&(t=W(n)),po(!0,e,r,t,-1)}function yo(e,t){var r=vo(e,t.line),n=M(e.doc,r.line),i=Se(n,e.doc.direction);if(!i||0==i[0].level){var o=Math.max(0,n.text.search(/\S/)),l=t.line==r.line&&t.ch<=o&&t.ch;return E(r.line,l?0:o,r.sticky)}return r}function bo(e,t,r){if("string"==typeof t&&!(t=Bs[t]))return!1;e.display.input.ensurePolled();var n=e.display.shift,i=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),r&&(e.display.shift=!1),i=t(e)!=Bl}finally{e.display.shift=n,e.state.suppressEdits=!1}return i}function wo(e,t,r){for(var n=0;n<e.state.keyMaps.length;n++){var i=oo(t,e.state.keyMaps[n],r,e);if(i)return i}return e.options.extraKeys&&oo(t,e.options.extraKeys,r,e)||oo(t,e.options.keyMap,r,e)}function xo(e,t,r,n){var i=e.state.keySeq;if(i){if(lo(t))return"handled";Gs.set(50,function(){e.state.keySeq==i&&(e.state.keySeq=null,e.display.input.reset())}),t=i+" "+t}var o=wo(e,t,n);return"multi"==o&&(e.state.keySeq=t),"handled"==o&&bt(e,"keyHandled",e,t,r),"handled"!=o&&"multi"!=o||(We(r),Ar(e)),i&&!o&&/\'$/.test(t)?(We(r),!0):!!o}function Co(e,t){var r=ao(t,!0);return!!r&&(t.shiftKey&&!e.state.keySeq?xo(e,"Shift-"+r,t,function(t){return bo(e,t,!0)})||xo(e,r,t,function(t){if("string"==typeof t?/^go[A-Z]/.test(t):t.motion)return bo(e,t)}):xo(e,r,t,function(t){return bo(e,t)}))}function So(e,t,r){return xo(e,"'"+r+"'",t,function(t){return bo(e,t,!0)})}function Lo(e){var t=this;if(t.curOp.focus=l(),!Me(t,e)){gl&&vl<11&&27==e.keyCode&&(e.returnValue=!1);var r=e.keyCode;t.display.shift=16==r||e.shiftKey;var n=Co(t,e);wl&&(Us=n?r:null,!n&&88==r&&!rs&&(Ml?e.metaKey:e.ctrlKey)&&t.replaceSelection("",null,"cut")),18!=r||/\bCodeMirror-crosshair\b/.test(t.display.lineDiv.className)||ko(t)}}function ko(e){function t(e){18!=e.keyCode&&e.altKey||(Fl(r,"CodeMirror-crosshair"),ke(document,"keyup",t),ke(document,"mouseover",t))}var r=e.display.lineDiv;s(r,"CodeMirror-crosshair"),Ql(document,"keyup",t),Ql(document,"mouseover",t)}function To(e){16==e.keyCode&&(this.doc.sel.shift=!1),Me(this,e)}function Mo(e){var t=this;if(!(Ft(t.display,e)||Me(t,e)||e.ctrlKey&&!e.altKey||Ml&&e.metaKey)){var r=e.keyCode,n=e.charCode;if(wl&&r==Us)return Us=null,void We(e);if(!wl||e.which&&!(e.which<10)||!Co(t,e)){var i=String.fromCharCode(null==n?r:n);"\b"!=i&&(So(t,e,i)||t.display.input.onKeyPress(e))}}}function No(e,t){var r=+new Date;return js&&js.compare(r,e,t)?(Ks=js=null,"triple"):Ks&&Ks.compare(r,e,t)?(js=new Vs(r,e,t),Ks=null,"double"):(Ks=new Vs(r,e,t),js=null,"single")}function Oo(e){var t=this,r=t.display;if(!(Me(t,e)||r.activeTouch&&r.input.supportsTouch()))if(r.input.ensurePolled(),r.shift=e.shiftKey,Ft(r,e))ml||(r.scroller.draggable=!1,setTimeout(function(){return r.scroller.draggable=!0},100));else if(!zo(t,e)){var n=Sr(t,e),i=Pe(e),o=n?No(n,i):"single";window.focus(),1==i&&t.state.selectingText&&t.state.selectingText(e),n&&Ao(t,i,n,o,e)||(1==i?n?Do(t,n,o,e):Ee(e)==r.scroller&&We(e):2==i?(n&&di(t.doc,n),setTimeout(function(){return r.input.focus()},20)):3==i&&(Hl?Ro(t,e):Dr(t)))}}function Ao(e,t,r,n,i){var o="Click";return"double"==n?o="Double"+o:"triple"==n&&(o="Triple"+o),o=(1==t?"Left":2==t?"Middle":"Right")+o,xo(e,so(o,i),i,function(t){if("string"==typeof t&&(t=Bs[t]),!t)return!1;var n=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),n=t(e,r)!=Bl}finally{e.state.suppressEdits=!1}return n})}function Wo(e,t,r){var n=e.getOption("configureMouse"),i=n?n(e,t,r):{};if(null==i.unit){var o=Nl?r.shiftKey&&r.metaKey:r.altKey;i.unit=o?"rectangle":"single"==t?"char":"double"==t?"word":"line"}return(null==i.extend||e.doc.extend)&&(i.extend=e.doc.extend||r.shiftKey),null==i.addNew&&(i.addNew=Ml?r.metaKey:r.ctrlKey),null==i.moveOnDrag&&(i.moveOnDrag=!(Ml?r.altKey:r.ctrlKey)),i}function Do(e,t,r,n){gl?setTimeout(u(Wr,e),0):e.curOp.focus=l();var i,o=Wo(e,r,n),s=e.doc.sel;e.options.dragDrop&&Jl&&!e.isReadOnly()&&"single"==r&&(i=s.contains(t))>-1&&(P((i=s.ranges[i]).from(),t)<0||t.xRel>0)&&(P(i.to(),t)>0||t.xRel<0)?Ho(e,n,t,o):Eo(e,n,t,o)}function Ho(e,t,r,n){var i=e.display,o=!1,l=dn(e,function(t){ml&&(i.scroller.draggable=!1),e.state.draggingText=!1,ke(document,"mouseup",l),ke(document,"mousemove",s),ke(i.scroller,"dragstart",a),ke(i.scroller,"drop",l),o||(We(t),n.addNew||di(e.doc,r,null,null,n.extend),ml||gl&&9==vl?setTimeout(function(){document.body.focus(),i.input.focus()},20):i.input.focus())}),s=function(e){o=o||Math.abs(t.clientX-e.clientX)+Math.abs(t.clientY-e.clientY)>=10},a=function(){return o=!0};ml&&(i.scroller.draggable=!0),e.state.draggingText=l,l.copy=!n.moveOnDrag,i.scroller.dragDrop&&i.scroller.dragDrop(),Ql(document,"mouseup",l),Ql(document,"mousemove",s),Ql(i.scroller,"dragstart",a),Ql(i.scroller,"drop",l),Dr(e),setTimeout(function(){return i.input.focus()},20)}function Fo(e,t,r){if("char"==r)return new Ts(t,t);if("word"==r)return e.findWordAt(t);if("line"==r)return new Ts(E(t.line,0),U(e.doc,E(t.line+1,0)));var n=r(e,t);return new Ts(n.from,n.to)}function Eo(e,t,r,n){function i(t){if(0!=P(m,t))if(m=t,"rectangle"==n.unit){for(var i=[],o=e.options.tabSize,l=f(M(u,r.line).text,r.ch,o),s=f(M(u,t.line).text,t.ch,o),a=Math.min(l,s),g=Math.max(l,s),v=Math.min(r.line,t.line),y=Math.min(e.lastLine(),Math.max(r.line,t.line));v<=y;v++){var b=M(u,v).text,w=d(b,a,o);a==g?i.push(new Ts(E(v,w),E(v,w))):b.length>w&&i.push(new Ts(E(v,w),E(v,d(b,g,o))))}i.length||i.push(new Ts(r,r)),bi(u,zn(p.ranges.slice(0,h).concat(i),h),{origin:"*mouse",scroll:!1}),e.scrollIntoView(t)}else{var x,C=c,S=Fo(e,t,n.unit),L=C.anchor;P(S.anchor,L)>0?(x=S.head,L=B(C.from(),S.anchor)):(x=S.anchor,L=R(C.to(),S.head));var k=p.ranges.slice(0);k[h]=Po(e,new Ts(U(u,L),x)),bi(u,zn(k,h),Ul)}}function o(t){var r=++b,s=Sr(e,t,!0,"rectangle"==n.unit);if(s)if(0!=P(s,m)){e.curOp.focus=l(),i(s);var c=Ir(a,u);(s.line>=c.to||s.line<c.from)&&setTimeout(dn(e,function(){b==r&&o(t)}),150)}else{var f=t.clientY<y.top?-20:t.clientY>y.bottom?20:0;f&&setTimeout(dn(e,function(){b==r&&(a.scroller.scrollTop+=f,o(t))}),50)}}function s(t){e.state.selectingText=!1,b=1/0,We(t),a.input.focus(),ke(document,"mousemove",w),ke(document,"mouseup",x),u.history.lastSelOrigin=null}var a=e.display,u=e.doc;We(t);var c,h,p=u.sel,g=p.ranges;if(n.addNew&&!n.extend?(h=u.sel.contains(r),c=h>-1?g[h]:new Ts(r,r)):(c=u.sel.primary(),h=u.sel.primIndex),"rectangle"==n.unit)n.addNew||(c=new Ts(r,r)),r=Sr(e,t,!0,!0),h=-1;else{var v=Fo(e,r,n.unit);c=n.extend?hi(c,v.anchor,v.head,n.extend):v}n.addNew?-1==h?(h=g.length,bi(u,zn(g.concat([c]),h),{scroll:!1,origin:"*mouse"})):g.length>1&&g[h].empty()&&"char"==n.unit&&!n.extend?(bi(u,zn(g.slice(0,h).concat(g.slice(h+1)),0),{scroll:!1,origin:"*mouse"}),p=u.sel):gi(u,h,c,Ul):(h=0,bi(u,new ks([c],0),Ul),p=u.sel);var m=r,y=a.wrapper.getBoundingClientRect(),b=0,w=dn(e,function(e){Pe(e)?o(e):s(e)}),x=dn(e,s);e.state.selectingText=x,Ql(document,"mousemove",w),Ql(document,"mouseup",x)}function Po(e,t){var r=t.anchor,n=t.head,i=M(e.doc,r.line);if(0==P(r,n)&&r.sticky==n.sticky)return t;var o=Se(i);if(!o)return t;var l=Ce(o,r.ch,r.sticky),s=o[l];if(s.from!=r.ch&&s.to!=r.ch)return t;var a=l+(s.from==r.ch==(1!=s.level)?0:1);if(0==a||a==o.length)return t;var u;if(n.line!=r.line)u=(n.line-r.line)*("ltr"==e.doc.direction?1:-1)>0;else{var c=Ce(o,n.ch,n.sticky),f=c-l||(n.ch-r.ch)*(1==s.level?-1:1);u=c==a-1||c==a?f<0:f>0}var h=o[a+(u?-1:0)],d=u==(1==h.level),p=d?h.from:h.to,g=d?"after":"before";return r.ch==p&&r.sticky==g?t:new Ts(new E(r.line,p,g),n)}function Io(e,t,r,n){var i,o;if(t.touches)i=t.touches[0].clientX,o=t.touches[0].clientY;else try{i=t.clientX,o=t.clientY}catch(t){return!1}if(i>=Math.floor(e.display.gutters.getBoundingClientRect().right))return!1;n&&We(t);var l=e.display,s=l.lineDiv.getBoundingClientRect();if(o>s.bottom||!Oe(e,r))return He(t);o-=s.top-l.viewOffset;for(var a=0;a<e.options.gutters.length;++a){var u=l.gutters.childNodes[a];if(u&&u.getBoundingClientRect().right>=i)return Te(e,r,e,D(e.doc,o),e.options.gutters[a],t),He(t)}}function zo(e,t){return Io(e,t,"gutterClick",!0)}function Ro(e,t){Ft(e.display,t)||Bo(e,t)||Me(e,t,"contextmenu")||e.display.input.onContextMenu(t)}function Bo(e,t){return!!Oe(e,"gutterContextMenu")&&Io(e,t,"gutterContextMenu",!1)}function Go(e){e.display.wrapper.className=e.display.wrapper.className.replace(/\s*cm-s-\S+/g,"")+e.options.theme.replace(/(^|\s)\s*/g," cm-s-"),er(e)}function Uo(e){Hn(e),vn(e),zr(e)}function Vo(e,t,r){if(!t!=!(r&&r!=Xs)){var n=e.display.dragFunctions,i=t?Ql:ke;i(e.display.scroller,"dragstart",n.start),i(e.display.scroller,"dragenter",n.enter),i(e.display.scroller,"dragover",n.over),i(e.display.scroller,"dragleave",n.leave),i(e.display.scroller,"drop",n.drop)}}function Ko(e){e.options.lineWrapping?(s(e.display.wrapper,"CodeMirror-wrap"),e.display.sizer.style.minWidth="",e.display.sizerWidth=null):(Fl(e.display.wrapper,"CodeMirror-wrap"),we(e)),Cr(e),vn(e),er(e),setTimeout(function(){return en(e)},100)}function jo(e,t){var r=this;if(!(this instanceof jo))return new jo(e,t);this.options=t=t?c(t):{},c(Ys,t,!1),Fn(t);var n=t.value;"string"==typeof n&&(n=new Ds(n,t.mode,null,t.lineSeparator,t.direction)),this.doc=n;var i=new jo.inputStyles[t.inputStyle](this),o=this.display=new T(e,n,i);o.wrapper.CodeMirror=this,Hn(this),Go(this),t.lineWrapping&&(this.display.wrapper.className+=" CodeMirror-wrap"),rn(this),this.state={keyMaps:[],overlays:[],modeGen:0,overwrite:!1,delayingBlurEvent:!1,focused:!1,suppressEdits:!1,pasteIncoming:!1,cutIncoming:!1,selectingText:!1,draggingText:!1,highlight:new Pl,keySeq:null,specialChars:null},t.autofocus&&!Tl&&o.input.focus(),gl&&vl<11&&setTimeout(function(){return r.display.input.reset(!0)},20),Xo(this),eo(),nn(this),this.curOp.forceUpdate=!0,qn(this,n),t.autofocus&&!Tl||this.hasFocus()?setTimeout(u(Hr,this),20):Fr(this);for(var l in _s)_s.hasOwnProperty(l)&&_s[l](r,t[l],Xs);Rr(this),t.finishInit&&t.finishInit(this);for(var s=0;s<$s.length;++s)$s[s](r);on(this),ml&&t.lineWrapping&&"optimizelegibility"==getComputedStyle(o.lineDiv).textRendering&&(o.lineDiv.style.textRendering="auto")}function Xo(e){function t(){i.activeTouch&&(o=setTimeout(function(){return i.activeTouch=null},1e3),(l=i.activeTouch).end=+new Date)}function r(e){if(1!=e.touches.length)return!1;var t=e.touches[0];return t.radiusX<=1&&t.radiusY<=1}function n(e,t){if(null==t.left)return!0;var r=t.left-e.left,n=t.top-e.top;return r*r+n*n>400}var i=e.display;Ql(i.scroller,"mousedown",dn(e,Oo)),gl&&vl<11?Ql(i.scroller,"dblclick",dn(e,function(t){if(!Me(e,t)){var r=Sr(e,t);if(r&&!zo(e,t)&&!Ft(e.display,t)){We(t);var n=e.findWordAt(r);di(e.doc,n.anchor,n.head)}}})):Ql(i.scroller,"dblclick",function(t){return Me(e,t)||We(t)}),Hl||Ql(i.scroller,"contextmenu",function(t){return Ro(e,t)});var o,l={end:0};Ql(i.scroller,"touchstart",function(t){if(!Me(e,t)&&!r(t)&&!zo(e,t)){i.input.ensurePolled(),clearTimeout(o);var n=+new Date;i.activeTouch={start:n,moved:!1,prev:n-l.end<=300?l:null},1==t.touches.length&&(i.activeTouch.left=t.touches[0].pageX,i.activeTouch.top=t.touches[0].pageY)}}),Ql(i.scroller,"touchmove",function(){i.activeTouch&&(i.activeTouch.moved=!0)}),Ql(i.scroller,"touchend",function(r){var o=i.activeTouch;if(o&&!Ft(i,r)&&null!=o.left&&!o.moved&&new Date-o.start<300){var l,s=e.coordsChar(i.activeTouch,"page");l=!o.prev||n(o,o.prev)?new Ts(s,s):!o.prev.prev||n(o,o.prev.prev)?e.findWordAt(s):new Ts(E(s.line,0),U(e.doc,E(s.line+1,0))),e.setSelection(l.anchor,l.head),e.focus(),We(r)}t()}),Ql(i.scroller,"touchcancel",t),Ql(i.scroller,"scroll",function(){i.scroller.clientHeight&&(qr(e,i.scroller.scrollTop),Qr(e,i.scroller.scrollLeft,!0),Te(e,"scroll",e))}),Ql(i.scroller,"mousewheel",function(t){return In(e,t)}),Ql(i.scroller,"DOMMouseScroll",function(t){return In(e,t)}),Ql(i.wrapper,"scroll",function(){return i.wrapper.scrollTop=i.wrapper.scrollLeft=0}),i.dragFunctions={enter:function(t){Me(e,t)||Fe(t)},over:function(t){Me(e,t)||(Zi(e,t),Fe(t))},start:function(t){return qi(e,t)},drop:dn(e,$i),leave:function(t){Me(e,t)||Qi(e)}};var s=i.input.getField();Ql(s,"keyup",function(t){return To.call(e,t)}),Ql(s,"keydown",dn(e,Lo)),Ql(s,"keypress",dn(e,Mo)),Ql(s,"focus",function(t){return Hr(e,t)}),Ql(s,"blur",function(t){return Fr(e,t)})}function Yo(e,t,r,n){var i,o=e.doc;null==r&&(r="add"),"smart"==r&&(o.mode.indent?i=$e(e,t).state:r="prev");var l=e.options.tabSize,s=M(o,t),a=f(s.text,null,l);s.stateAfter&&(s.stateAfter=null);var u,c=s.text.match(/^\s*/)[0];if(n||/\S/.test(s.text)){if("smart"==r&&((u=o.mode.indent(i,s.text.slice(c.length),s.text))==Bl||u>150)){if(!n)return;r="prev"}}else u=0,r="not";"prev"==r?u=t>o.first?f(M(o,t-1).text,null,l):0:"add"==r?u=a+e.options.indentUnit:"subtract"==r?u=a-e.options.indentUnit:"number"==typeof r&&(u=a+r),u=Math.max(0,u);var h="",d=0;if(e.options.indentWithTabs)for(var g=Math.floor(u/l);g;--g)d+=l,h+="\t";if(d<u&&(h+=p(u-d)),h!=c)return Ei(o,h,E(t,0),E(t,c.length),"+input"),s.stateAfter=null,!0;for(var v=0;v<o.sel.ranges.length;v++){var m=o.sel.ranges[v];if(m.head.line==t&&m.head.ch<c.length){var y=E(t,c.length);gi(o,v,new Ts(y,y));break}}}function _o(e){qs=e}function $o(e,t,r,n,i){var o=e.doc;e.display.shift=!1,n||(n=o.sel);var l=e.state.pasteIncoming||"paste"==i,s=es(t),a=null;if(l&&n.ranges.length>1)if(qs&&qs.text.join("\n")==t){if(n.ranges.length%qs.text.length==0){a=[];for(var u=0;u<qs.text.length;u++)a.push(o.splitLines(qs.text[u]))}}else s.length==n.ranges.length&&e.options.pasteLinesPerSelection&&(a=v(s,function(e){return[e]}));for(var c,f=n.ranges.length-1;f>=0;f--){var h=n.ranges[f],d=h.from(),p=h.to();h.empty()&&(r&&r>0?d=E(d.line,d.ch-r):e.state.overwrite&&!l?p=E(p.line,Math.min(M(o,p.line).text.length,p.ch+g(s).length)):qs&&qs.lineWise&&qs.text.join("\n")==t&&(d=p=E(d.line,0))),c=e.curOp.updateInput;var m={from:d,to:p,text:a?a[f%a.length]:s,origin:i||(l?"paste":e.state.cutIncoming?"cut":"+input")};Oi(e.doc,m),bt(e,"inputRead",e,m)}t&&!l&&Zo(e,t),jr(e),e.curOp.updateInput=c,e.curOp.typing=!0,e.state.pasteIncoming=e.state.cutIncoming=!1}function qo(e,t){var r=e.clipboardData&&e.clipboardData.getData("Text");if(r)return e.preventDefault(),t.isReadOnly()||t.options.disableInput||hn(t,function(){return $o(t,r,0,null,"paste")}),!0}function Zo(e,t){if(e.options.electricChars&&e.options.smartIndent)for(var r=e.doc.sel,n=r.ranges.length-1;n>=0;n--){var i=r.ranges[n];if(!(i.head.ch>100||n&&r.ranges[n-1].head.line==i.head.line)){var o=e.getModeAt(i.head),l=!1;if(o.electricChars){for(var s=0;s<o.electricChars.length;s++)if(t.indexOf(o.electricChars.charAt(s))>-1){l=Yo(e,i.head.line,"smart");break}}else o.electricInput&&o.electricInput.test(M(e.doc,i.head.line).text.slice(0,i.head.ch))&&(l=Yo(e,i.head.line,"smart"));l&&bt(e,"electricInput",e,i.head.line)}}}function Qo(e){for(var t=[],r=[],n=0;n<e.doc.sel.ranges.length;n++){var i=e.doc.sel.ranges[n].head.line,o={anchor:E(i,0),head:E(i+1,0)};r.push(o),t.push(e.getRange(o.anchor,o.head))}return{text:t,ranges:r}}function Jo(e,t){e.setAttribute("autocorrect","off"),e.setAttribute("autocapitalize","off"),e.setAttribute("spellcheck",!!t)}function el(){var e=n("textarea",null,null,"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none"),t=n("div",[e],null,"overflow: hidden; position: relative; width: 3px; height: 0px;");return ml?e.style.width="1000px":e.setAttribute("wrap","off"),Ll&&(e.style.border="1px solid black"),Jo(e),t}function tl(e,t,r,n,i){function o(){var n=t.line+r;return!(n<e.first||n>=e.first+e.size)&&(t=new E(n,t.ch,t.sticky),u=M(e,n))}function l(n){var l;if(null==(l=i?go(e.cm,u,t,r):ho(u,t,r))){if(n||!o())return!1;t=po(i,e.cm,u,t.line,r)}else t=l;return!0}var s=t,a=r,u=M(e,t.line);if("char"==n)l();else if("column"==n)l(!0);else if("word"==n||"group"==n)for(var c=null,f="group"==n,h=e.cm&&e.cm.getHelper(t,"wordChars"),d=!0;!(r<0)||l(!d);d=!1){var p=u.text.charAt(t.ch)||"\n",g=x(p,h)?"w":f&&"\n"==p?"n":!f||/\s/.test(p)?null:"p";if(!f||d||g||(g="s"),c&&c!=g){r<0&&(r=1,l(),t.sticky="after");break}if(g&&(c=g),r>0&&!l(!d))break}var v=ki(e,t,s,a,!0);return I(s,v)&&(v.hitSide=!0),v}function rl(e,t,r,n){var i,o=e.doc,l=t.left;if("page"==n){var s=Math.min(e.display.wrapper.clientHeight,window.innerHeight||document.documentElement.clientHeight),a=Math.max(s-.5*mr(e.display),3);i=(r>0?t.bottom:t.top)+r*a}else"line"==n&&(i=r>0?t.bottom+3:t.top-3);for(var u;(u=cr(e,l,i)).outside;){if(r<0?i<=0:i>=o.height){u.hitSide=!0;break}i+=5*r}return u}function nl(e,t){var r=jt(e,t.line);if(!r||r.hidden)return null;var n=M(e.doc,t.line),i=Ut(r,n,t.line),o=Se(n,e.doc.direction),l="left";o&&(l=Ce(o,t.ch)%2?"right":"left");var s=_t(i.map,t.ch,l);return s.offset="right"==s.collapse?s.end:s.start,s}function il(e){for(var t=e;t;t=t.parentNode)if(/CodeMirror-gutter-wrapper/.test(t.className))return!0;return!1}function ol(e,t){return t&&(e.bad=!0),e}function ll(e,t,r,n,i){function o(e){return function(t){return t.id==e}}function l(){c&&(u+=f,c=!1)}function s(e){e&&(l(),u+=e)}function a(t){if(1==t.nodeType){var r=t.getAttribute("cm-text");if(null!=r)return void s(r||t.textContent.replace(/\u200b/g,""));var u,h=t.getAttribute("cm-marker");if(h){var d=e.findMarks(E(n,0),E(i+1,0),o(+h));return void(d.length&&(u=d[0].find(0))&&s(N(e.doc,u.from,u.to).join(f)))}if("false"==t.getAttribute("contenteditable"))return;var p=/^(pre|div|p)$/i.test(t.nodeName);p&&l();for(var g=0;g<t.childNodes.length;g++)a(t.childNodes[g]);p&&(c=!0)}else 3==t.nodeType&&s(t.nodeValue)}for(var u="",c=!1,f=e.doc.lineSeparator();a(t),t!=r;)t=t.nextSibling;return u}function sl(e,t,r){var n;if(t==e.display.lineDiv){if(!(n=e.display.lineDiv.childNodes[r]))return ol(e.clipPos(E(e.display.viewTo-1)),!0);t=null,r=0}else for(n=t;;n=n.parentNode){if(!n||n==e.display.lineDiv)return null;if(n.parentNode&&n.parentNode==e.display.lineDiv)break}for(var i=0;i<e.display.view.length;i++){var o=e.display.view[i];if(o.node==n)return al(o,t,r)}}function al(e,t,r){function n(t,r,n){for(var i=-1;i<(f?f.length:0);i++)for(var o=i<0?c.map:f[i],l=0;l<o.length;l+=3){var s=o[l+2];if(s==t||s==r){var a=W(i<0?e.line:e.rest[i]),u=o[l]+n;return(n<0||s!=t)&&(u=o[l+(n?1:0)]),E(a,u)}}}var i=e.text.firstChild,l=!1;if(!t||!o(i,t))return ol(E(W(e.line),0),!0);if(t==i&&(l=!0,t=i.childNodes[r],r=0,!t)){var s=e.rest?g(e.rest):e.line;return ol(E(W(s),s.text.length),l)}var a=3==t.nodeType?t:null,u=t;for(a||1!=t.childNodes.length||3!=t.firstChild.nodeType||(a=t.firstChild,r&&(r=a.nodeValue.length));u.parentNode!=i;)u=u.parentNode;var c=e.measure,f=c.maps,h=n(a,u,r);if(h)return ol(h,l);for(var d=u.nextSibling,p=a?a.nodeValue.length-r:0;d;d=d.nextSibling){if(h=n(d,d.firstChild,0))return ol(E(h.line,h.ch-p),l);p+=d.textContent.length}for(var v=u.previousSibling,m=r;v;v=v.previousSibling){if(h=n(v,v.firstChild,-1))return ol(E(h.line,h.ch+m),l);m+=v.textContent.length}}var ul=navigator.userAgent,cl=navigator.platform,fl=/gecko\/\d/i.test(ul),hl=/MSIE \d/.test(ul),dl=/Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(ul),pl=/Edge\/(\d+)/.exec(ul),gl=hl||dl||pl,vl=gl&&(hl?document.documentMode||6:+(pl||dl)[1]),ml=!pl&&/WebKit\//.test(ul),yl=ml&&/Qt\/\d+\.\d+/.test(ul),bl=!pl&&/Chrome\//.test(ul),wl=/Opera\//.test(ul),xl=/Apple Computer/.test(navigator.vendor),Cl=/Mac OS X 1\d\D([8-9]|\d\d)\D/.test(ul),Sl=/PhantomJS/.test(ul),Ll=!pl&&/AppleWebKit/.test(ul)&&/Mobile\/\w+/.test(ul),kl=/Android/.test(ul),Tl=Ll||kl||/webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(ul),Ml=Ll||/Mac/.test(cl),Nl=/\bCrOS\b/.test(ul),Ol=/win/i.test(cl),Al=wl&&ul.match(/Version\/(\d*\.\d*)/);Al&&(Al=Number(Al[1])),Al&&Al>=15&&(wl=!1,ml=!0);var Wl,Dl=Ml&&(yl||wl&&(null==Al||Al<12.11)),Hl=fl||gl&&vl>=9,Fl=function(t,r){var n=t.className,i=e(r).exec(n);if(i){var o=n.slice(i.index+i[0].length);t.className=n.slice(0,i.index)+(o?i[1]+o:"")}};Wl=document.createRange?function(e,t,r,n){var i=document.createRange();return i.setEnd(n||e,r),i.setStart(e,t),i}:function(e,t,r){var n=document.body.createTextRange();try{n.moveToElementText(e.parentNode)}catch(e){return n}return n.collapse(!0),n.moveEnd("character",r),n.moveStart("character",t),n};var El=function(e){e.select()};Ll?El=function(e){e.selectionStart=0,e.selectionEnd=e.value.length}:gl&&(El=function(e){try{e.select()}catch(e){}});var Pl=function(){this.id=null};Pl.prototype.set=function(e,t){clearTimeout(this.id),this.id=setTimeout(t,e)};var Il,zl,Rl=30,Bl={toString:function(){return"CodeMirror.Pass"}},Gl={scroll:!1},Ul={origin:"*mouse"},Vl={origin:"+move"},Kl=[""],jl=/[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/,Xl=/[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/,Yl=!1,_l=!1,$l=null,ql=function(){function e(e){return e<=247?r.charAt(e):1424<=e&&e<=1524?"R":1536<=e&&e<=1785?n.charAt(e-1536):1774<=e&&e<=2220?"r":8192<=e&&e<=8203?"w":8204==e?"b":"L"}function t(e,t,r){this.level=e,this.from=t,this.to=r}var r="bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN",n="nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111",i=/[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/,o=/[stwN]/,l=/[LRr]/,s=/[Lb1n]/,a=/[1n]/;return function(r,n){var u="ltr"==n?"L":"R";if(0==r.length||"ltr"==n&&!i.test(r))return!1;for(var c=r.length,f=[],h=0;h<c;++h)f.push(e(r.charCodeAt(h)));for(var d=0,p=u;d<c;++d){var v=f[d];"m"==v?f[d]=p:p=v}for(var m=0,y=u;m<c;++m){var b=f[m];"1"==b&&"r"==y?f[m]="n":l.test(b)&&(y=b,"r"==b&&(f[m]="R"))}for(var w=1,x=f[0];w<c-1;++w){var C=f[w];"+"==C&&"1"==x&&"1"==f[w+1]?f[w]="1":","!=C||x!=f[w+1]||"1"!=x&&"n"!=x||(f[w]=x),x=C}for(var S=0;S<c;++S){var L=f[S];if(","==L)f[S]="N";else if("%"==L){var k=void 0;for(k=S+1;k<c&&"%"==f[k];++k);for(var T=S&&"!"==f[S-1]||k<c&&"1"==f[k]?"1":"N",M=S;M<k;++M)f[M]=T;S=k-1}}for(var N=0,O=u;N<c;++N){var A=f[N];"L"==O&&"1"==A?f[N]="L":l.test(A)&&(O=A)}for(var W=0;W<c;++W)if(o.test(f[W])){var D=void 0;for(D=W+1;D<c&&o.test(f[D]);++D);for(var H="L"==(W?f[W-1]:u),F=H==("L"==(D<c?f[D]:u))?H?"L":"R":u,E=W;E<D;++E)f[E]=F;W=D-1}for(var P,I=[],z=0;z<c;)if(s.test(f[z])){var R=z;for(++z;z<c&&s.test(f[z]);++z);I.push(new t(0,R,z))}else{var B=z,G=I.length;for(++z;z<c&&"L"!=f[z];++z);for(var U=B;U<z;)if(a.test(f[U])){B<U&&I.splice(G,0,new t(1,B,U));var V=U;for(++U;U<z&&a.test(f[U]);++U);I.splice(G,0,new t(2,V,U)),B=U}else++U;B<z&&I.splice(G,0,new t(1,B,z))}return 1==I[0].level&&(P=r.match(/^\s+/))&&(I[0].from=P[0].length,I.unshift(new t(0,0,P[0].length))),1==g(I).level&&(P=r.match(/\s+$/))&&(g(I).to-=P[0].length,I.push(new t(0,c-P[0].length,c))),"rtl"==n?I.reverse():I}}(),Zl=[],Ql=function(e,t,r){if(e.addEventListener)e.addEventListener(t,r,!1);else if(e.attachEvent)e.attachEvent("on"+t,r);else{var n=e._handlers||(e._handlers={});n[t]=(n[t]||Zl).concat(r)}},Jl=function(){if(gl&&vl<9)return!1;var e=n("div");return"draggable"in e||"dragDrop"in e}(),es=3!="\n\nb".split(/\n/).length?function(e){for(var t=0,r=[],n=e.length;t<=n;){var i=e.indexOf("\n",t);-1==i&&(i=e.length);var o=e.slice(t,"\r"==e.charAt(i-1)?i-1:i),l=o.indexOf("\r");-1!=l?(r.push(o.slice(0,l)),t+=l+1):(r.push(o),t=i+1)}return r}:function(e){return e.split(/\r\n?|\n/)},ts=window.getSelection?function(e){try{return e.selectionStart!=e.selectionEnd}catch(e){return!1}}:function(e){var t;try{t=e.ownerDocument.selection.createRange()}catch(e){}return!(!t||t.parentElement()!=e)&&0!=t.compareEndPoints("StartToEnd",t)},rs=function(){var e=n("div");return"oncopy"in e||(e.setAttribute("oncopy","return;"),"function"==typeof e.oncopy)}(),ns=null,is={},os={},ls={},ss=function(e,t,r){this.pos=this.start=0,this.string=e,this.tabSize=t||8,this.lastColumnPos=this.lastColumnValue=0,this.lineStart=0,this.lineOracle=r};ss.prototype.eol=function(){return this.pos>=this.string.length},ss.prototype.sol=function(){return this.pos==this.lineStart},ss.prototype.peek=function(){return this.string.charAt(this.pos)||void 0},ss.prototype.next=function(){if(this.pos<this.string.length)return this.string.charAt(this.pos++)},ss.prototype.eat=function(e){var t=this.string.charAt(this.pos);if("string"==typeof e?t==e:t&&(e.test?e.test(t):e(t)))return++this.pos,t},ss.prototype.eatWhile=function(e){for(var t=this.pos;this.eat(e););return this.pos>t},ss.prototype.eatSpace=function(){for(var e=this,t=this.pos;/[\s\u00a0]/.test(this.string.charAt(this.pos));)++e.pos;return this.pos>t},ss.prototype.skipToEnd=function(){this.pos=this.string.length},ss.prototype.skipTo=function(e){var t=this.string.indexOf(e,this.pos);if(t>-1)return this.pos=t,!0},ss.prototype.backUp=function(e){this.pos-=e},ss.prototype.column=function(){return this.lastColumnPos<this.start&&(this.lastColumnValue=f(this.string,this.start,this.tabSize,this.lastColumnPos,this.lastColumnValue),this.lastColumnPos=this.start),this.lastColumnValue-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.indentation=function(){return f(this.string,null,this.tabSize)-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.match=function(e,t,r){if("string"!=typeof e){var n=this.string.slice(this.pos).match(e);return n&&n.index>0?null:(n&&!1!==t&&(this.pos+=n[0].length),n)}var i=function(e){return r?e.toLowerCase():e};if(i(this.string.substr(this.pos,e.length))==i(e))return!1!==t&&(this.pos+=e.length),!0},ss.prototype.current=function(){return this.string.slice(this.start,this.pos)},ss.prototype.hideFirstChars=function(e,t){this.lineStart+=e;try{return t()}finally{this.lineStart-=e}},ss.prototype.lookAhead=function(e){var t=this.lineOracle;return t&&t.lookAhead(e)};var as=function(e,t){this.state=e,this.lookAhead=t},us=function(e,t,r,n){this.state=t,this.doc=e,this.line=r,this.maxLookAhead=n||0};us.prototype.lookAhead=function(e){var t=this.doc.getLine(this.line+e);return null!=t&&e>this.maxLookAhead&&(this.maxLookAhead=e),t},us.prototype.nextLine=function(){this.line++,this.maxLookAhead>0&&this.maxLookAhead--},us.fromSaved=function(e,t,r){return t instanceof as?new us(e,Ke(e.mode,t.state),r,t.lookAhead):new us(e,Ke(e.mode,t),r)},us.prototype.save=function(e){var t=!1!==e?Ke(this.doc.mode,this.state):this.state;return this.maxLookAhead>0?new as(t,this.maxLookAhead):t};var cs=function(e,t,r){this.start=e.start,this.end=e.pos,this.string=e.current(),this.type=t||null,this.state=r},fs=function(e,t,r){this.text=e,ne(this,t),this.height=r?r(this):1};fs.prototype.lineNo=function(){return W(this)},Ae(fs);var hs,ds={},ps={},gs=null,vs=null,ms={left:0,right:0,top:0,bottom:0},ys=function(e,t,r){this.cm=r;var i=this.vert=n("div",[n("div",null,null,"min-width: 1px")],"CodeMirror-vscrollbar"),o=this.horiz=n("div",[n("div",null,null,"height: 100%; min-height: 1px")],"CodeMirror-hscrollbar");e(i),e(o),Ql(i,"scroll",function(){i.clientHeight&&t(i.scrollTop,"vertical")}),Ql(o,"scroll",function(){o.clientWidth&&t(o.scrollLeft,"horizontal")}),this.checkedZeroWidth=!1,gl&&vl<8&&(this.horiz.style.minHeight=this.vert.style.minWidth="18px")};ys.prototype.update=function(e){var t=e.scrollWidth>e.clientWidth+1,r=e.scrollHeight>e.clientHeight+1,n=e.nativeBarWidth;if(r){this.vert.style.display="block",this.vert.style.bottom=t?n+"px":"0";var i=e.viewHeight-(t?n:0);this.vert.firstChild.style.height=Math.max(0,e.scrollHeight-e.clientHeight+i)+"px"}else this.vert.style.display="",this.vert.firstChild.style.height="0";if(t){this.horiz.style.display="block",this.horiz.style.right=r?n+"px":"0",this.horiz.style.left=e.barLeft+"px";var o=e.viewWidth-e.barLeft-(r?n:0);this.horiz.firstChild.style.width=Math.max(0,e.scrollWidth-e.clientWidth+o)+"px"}else this.horiz.style.display="",this.horiz.firstChild.style.width="0";return!this.checkedZeroWidth&&e.clientHeight>0&&(0==n&&this.zeroWidthHack(),this.checkedZeroWidth=!0),{right:r?n:0,bottom:t?n:0}},ys.prototype.setScrollLeft=function(e){this.horiz.scrollLeft!=e&&(this.horiz.scrollLeft=e),this.disableHoriz&&this.enableZeroWidthBar(this.horiz,this.disableHoriz,"horiz")},ys.prototype.setScrollTop=function(e){this.vert.scrollTop!=e&&(this.vert.scrollTop=e),this.disableVert&&this.enableZeroWidthBar(this.vert,this.disableVert,"vert")},ys.prototype.zeroWidthHack=function(){var e=Ml&&!Cl?"12px":"18px";this.horiz.style.height=this.vert.style.width=e,this.horiz.style.pointerEvents=this.vert.style.pointerEvents="none",this.disableHoriz=new Pl,this.disableVert=new Pl},ys.prototype.enableZeroWidthBar=function(e,t,r){function n(){var i=e.getBoundingClientRect();("vert"==r?document.elementFromPoint(i.right-1,(i.top+i.bottom)/2):document.elementFromPoint((i.right+i.left)/2,i.bottom-1))!=e?e.style.pointerEvents="none":t.set(1e3,n)}e.style.pointerEvents="auto",t.set(1e3,n)},ys.prototype.clear=function(){var e=this.horiz.parentNode;e.removeChild(this.horiz),e.removeChild(this.vert)};var bs=function(){};bs.prototype.update=function(){return{bottom:0,right:0}},bs.prototype.setScrollLeft=function(){},bs.prototype.setScrollTop=function(){},bs.prototype.clear=function(){};var ws={native:ys,null:bs},xs=0,Cs=function(e,t,r){var n=e.display;this.viewport=t,this.visible=Ir(n,e.doc,t),this.editorIsHidden=!n.wrapper.offsetWidth,this.wrapperHeight=n.wrapper.clientHeight,this.wrapperWidth=n.wrapper.clientWidth,this.oldDisplayWidth=Rt(e),this.force=r,this.dims=br(e),this.events=[]};Cs.prototype.signal=function(e,t){Oe(e,t)&&this.events.push(arguments)},Cs.prototype.finish=function(){for(var e=this,t=0;t<this.events.length;t++)Te.apply(null,e.events[t])};var Ss=0,Ls=null;gl?Ls=-.53:fl?Ls=15:bl?Ls=-.7:xl&&(Ls=-1/3);var ks=function(e,t){this.ranges=e,this.primIndex=t};ks.prototype.primary=function(){return this.ranges[this.primIndex]},ks.prototype.equals=function(e){var t=this;if(e==this)return!0;if(e.primIndex!=this.primIndex||e.ranges.length!=this.ranges.length)return!1;for(var r=0;r<this.ranges.length;r++){var n=t.ranges[r],i=e.ranges[r];if(!I(n.anchor,i.anchor)||!I(n.head,i.head))return!1}return!0},ks.prototype.deepCopy=function(){for(var e=this,t=[],r=0;r<this.ranges.length;r++)t[r]=new Ts(z(e.ranges[r].anchor),z(e.ranges[r].head));return new ks(t,this.primIndex)},ks.prototype.somethingSelected=function(){for(var e=this,t=0;t<this.ranges.length;t++)if(!e.ranges[t].empty())return!0;return!1},ks.prototype.contains=function(e,t){var r=this;t||(t=e);for(var n=0;n<this.ranges.length;n++){var i=r.ranges[n];if(P(t,i.from())>=0&&P(e,i.to())<=0)return n}return-1};var Ts=function(e,t){this.anchor=e,this.head=t};Ts.prototype.from=function(){return B(this.anchor,this.head)},Ts.prototype.to=function(){return R(this.anchor,this.head)},Ts.prototype.empty=function(){return this.head.line==this.anchor.line&&this.head.ch==this.anchor.ch},Bi.prototype={chunkSize:function(){return this.lines.length},removeInner:function(e,t){for(var r=this,n=e,i=e+t;n<i;++n){var o=r.lines[n];r.height-=o.height,ot(o),bt(o,"delete")}this.lines.splice(e,t)},collapse:function(e){e.push.apply(e,this.lines)},insertInner:function(e,t,r){var n=this;this.height+=r,this.lines=this.lines.slice(0,e).concat(t).concat(this.lines.slice(e));for(var i=0;i<t.length;++i)t[i].parent=n},iterN:function(e,t,r){for(var n=this,i=e+t;e<i;++e)if(r(n.lines[e]))return!0}},Gi.prototype={chunkSize:function(){return this.size},removeInner:function(e,t){var r=this;this.size-=t;for(var n=0;n<this.children.length;++n){var i=r.children[n],o=i.chunkSize();if(e<o){var l=Math.min(t,o-e),s=i.height;if(i.removeInner(e,l),r.height-=s-i.height,o==l&&(r.children.splice(n--,1),i.parent=null),0==(t-=l))break;e=0}else e-=o}if(this.size-t<25&&(this.children.length>1||!(this.children[0]instanceof Bi))){var a=[];this.collapse(a),this.children=[new Bi(a)],this.children[0].parent=this}},collapse:function(e){for(var t=this,r=0;r<this.children.length;++r)t.children[r].collapse(e)},insertInner:function(e,t,r){var n=this;this.size+=t.length,this.height+=r;for(var i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<=l){if(o.insertInner(e,t,r),o.lines&&o.lines.length>50){for(var s=o.lines.length%25+25,a=s;a<o.lines.length;){var u=new Bi(o.lines.slice(a,a+=25));o.height-=u.height,n.children.splice(++i,0,u),u.parent=n}o.lines=o.lines.slice(0,s),n.maybeSpill()}break}e-=l}},maybeSpill:function(){if(!(this.children.length<=10)){var e=this;do{var t=new Gi(e.children.splice(e.children.length-5,5));if(e.parent){e.size-=t.size,e.height-=t.height;var r=h(e.parent.children,e);e.parent.children.splice(r+1,0,t)}else{var n=new Gi(e.children);n.parent=e,e.children=[n,t],e=n}t.parent=e.parent}while(e.children.length>10);e.parent.maybeSpill()}},iterN:function(e,t,r){for(var n=this,i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<l){var s=Math.min(t,l-e);if(o.iterN(e,s,r))return!0;if(0==(t-=s))break;e=0}else e-=l}}};var Ms=function(e,t,r){var n=this;if(r)for(var i in r)r.hasOwnProperty(i)&&(n[i]=r[i]);this.doc=e,this.node=t};Ms.prototype.clear=function(){var e=this,t=this.doc.cm,r=this.line.widgets,n=this.line,i=W(n);if(null!=i&&r){for(var o=0;o<r.length;++o)r[o]==e&&r.splice(o--,1);r.length||(n.widgets=null);var l=Ht(this);A(n,Math.max(0,n.height-l)),t&&(hn(t,function(){Ui(t,n,-l),mn(t,i,"widget")}),bt(t,"lineWidgetCleared",t,this,i))}},Ms.prototype.changed=function(){var e=this,t=this.height,r=this.doc.cm,n=this.line;this.height=null;var i=Ht(this)-t;i&&(A(n,n.height+i),r&&hn(r,function(){r.curOp.forceUpdate=!0,Ui(r,n,i),bt(r,"lineWidgetChanged",r,e,W(n))}))},Ae(Ms);var Ns=0,Os=function(e,t){this.lines=[],this.type=t,this.doc=e,this.id=++Ns};Os.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){var t=this.doc.cm,r=t&&!t.curOp;if(r&&nn(t),Oe(this,"clear")){var n=this.find();n&&bt(this,"clear",n.from,n.to)}for(var i=null,o=null,l=0;l<this.lines.length;++l){var s=e.lines[l],a=_(s.markedSpans,e);t&&!e.collapsed?mn(t,W(s),"text"):t&&(null!=a.to&&(o=W(s)),null!=a.from&&(i=W(s))),s.markedSpans=$(s.markedSpans,a),null==a.from&&e.collapsed&&!ve(e.doc,s)&&t&&A(s,mr(t.display))}if(t&&this.collapsed&&!t.options.lineWrapping)for(var u=0;u<this.lines.length;++u){var c=fe(e.lines[u]),f=be(c);f>t.display.maxLineLength&&(t.display.maxLine=c,t.display.maxLineLength=f,t.display.maxLineChanged=!0)}null!=i&&t&&this.collapsed&&vn(t,i,o+1),this.lines.length=0,this.explicitlyCleared=!0,this.atomic&&this.doc.cantEdit&&(this.doc.cantEdit=!1,t&&Ci(t.doc)),t&&bt(t,"markerCleared",t,this,i,o),r&&on(t),this.parent&&this.parent.clear()}},Os.prototype.find=function(e,t){var r=this;null==e&&"bookmark"==this.type&&(e=1);for(var n,i,o=0;o<this.lines.length;++o){var l=r.lines[o],s=_(l.markedSpans,r);if(null!=s.from&&(n=E(t?l:W(l),s.from),-1==e))return n;if(null!=s.to&&(i=E(t?l:W(l),s.to),1==e))return i}return n&&{from:n,to:i}},Os.prototype.changed=function(){var e=this,t=this.find(-1,!0),r=this,n=this.doc.cm;t&&n&&hn(n,function(){var i=t.line,o=W(t.line),l=jt(n,o);if(l&&(Qt(l),n.curOp.selectionChanged=n.curOp.forceUpdate=!0),n.curOp.updateMaxLine=!0,!ve(r.doc,i)&&null!=r.height){var s=r.height;r.height=null;var a=Ht(r)-s;a&&A(i,i.height+a)}bt(n,"markerChanged",n,e)})},Os.prototype.attachLine=function(e){if(!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;t.maybeHiddenMarkers&&-1!=h(t.maybeHiddenMarkers,this)||(t.maybeUnhiddenMarkers||(t.maybeUnhiddenMarkers=[])).push(this)}this.lines.push(e)},Os.prototype.detachLine=function(e){if(this.lines.splice(h(this.lines,e),1),!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;(t.maybeHiddenMarkers||(t.maybeHiddenMarkers=[])).push(this)}},Ae(Os);var As=function(e,t){var r=this;this.markers=e,this.primary=t;for(var n=0;n<e.length;++n)e[n].parent=r};As.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){this.explicitlyCleared=!0;for(var t=0;t<this.markers.length;++t)e.markers[t].clear();bt(this,"clear")}},As.prototype.find=function(e,t){return this.primary.find(e,t)},Ae(As);var Ws=0,Ds=function(e,t,r,n,i){if(!(this instanceof Ds))return new Ds(e,t,r,n,i);null==r&&(r=0),Gi.call(this,[new Bi([new fs("",null)])]),this.first=r,this.scrollTop=this.scrollLeft=0,this.cantEdit=!1,this.cleanGeneration=1,this.modeFrontier=this.highlightFrontier=r;var o=E(r,0);this.sel=Rn(o),this.history=new Jn(null),this.id=++Ws,this.modeOption=t,this.lineSep=n,this.direction="rtl"==i?"rtl":"ltr",this.extend=!1,"string"==typeof e&&(e=this.splitLines(e)),_n(this,{from:o,to:o,text:e}),bi(this,Rn(o),Gl)};Ds.prototype=b(Gi.prototype,{constructor:Ds,iter:function(e,t,r){r?this.iterN(e-this.first,t-e,r):this.iterN(this.first,this.first+this.size,e)},insert:function(e,t){for(var r=0,n=0;n<t.length;++n)r+=t[n].height;this.insertInner(e-this.first,t,r)},remove:function(e,t){this.removeInner(e-this.first,t)},getValue:function(e){var t=O(this,this.first,this.first+this.size);return!1===e?t:t.join(e||this.lineSeparator())},setValue:gn(function(e){var t=E(this.first,0),r=this.first+this.size-1;Oi(this,{from:t,to:E(r,M(this,r).text.length),text:this.splitLines(e),origin:"setValue",full:!0},!0),this.cm&&Xr(this.cm,0,0),bi(this,Rn(t),Gl)}),replaceRange:function(e,t,r,n){Ei(this,e,t=U(this,t),r=r?U(this,r):t,n)},getRange:function(e,t,r){var n=N(this,U(this,e),U(this,t));return!1===r?n:n.join(r||this.lineSeparator())},getLine:function(e){var t=this.getLineHandle(e);return t&&t.text},getLineHandle:function(e){if(H(this,e))return M(this,e)},getLineNumber:function(e){return W(e)},getLineHandleVisualStart:function(e){return"number"==typeof e&&(e=M(this,e)),fe(e)},lineCount:function(){return this.size},firstLine:function(){return this.first},lastLine:function(){return this.first+this.size-1},clipPos:function(e){return U(this,e)},getCursor:function(e){var t=this.sel.primary();return null==e||"head"==e?t.head:"anchor"==e?t.anchor:"end"==e||"to"==e||!1===e?t.to():t.from()},listSelections:function(){return this.sel.ranges},somethingSelected:function(){return this.sel.somethingSelected()},setCursor:gn(function(e,t,r){vi(this,U(this,"number"==typeof e?E(e,t||0):e),null,r)}),setSelection:gn(function(e,t,r){vi(this,U(this,e),U(this,t||e),r)}),extendSelection:gn(function(e,t,r){di(this,U(this,e),t&&U(this,t),r)}),extendSelections:gn(function(e,t){pi(this,K(this,e),t)}),extendSelectionsBy:gn(function(e,t){pi(this,K(this,v(this.sel.ranges,e)),t)}),setSelections:gn(function(e,t,r){var n=this;if(e.length){for(var i=[],o=0;o<e.length;o++)i[o]=new Ts(U(n,e[o].anchor),U(n,e[o].head));null==t&&(t=Math.min(e.length-1,this.sel.primIndex)),bi(this,zn(i,t),r)}}),addSelection:gn(function(e,t,r){var n=this.sel.ranges.slice(0);n.push(new Ts(U(this,e),U(this,t||e))),bi(this,zn(n,n.length-1),r)}),getSelection:function(e){for(var t,r=this,n=this.sel.ranges,i=0;i<n.length;i++){var o=N(r,n[i].from(),n[i].to());t=t?t.concat(o):o}return!1===e?t:t.join(e||this.lineSeparator())},getSelections:function(e){for(var t=this,r=[],n=this.sel.ranges,i=0;i<n.length;i++){var o=N(t,n[i].from(),n[i].to());!1!==e&&(o=o.join(e||t.lineSeparator())),r[i]=o}return r},replaceSelection:function(e,t,r){for(var n=[],i=0;i<this.sel.ranges.length;i++)n[i]=e;this.replaceSelections(n,t,r||"+input")},replaceSelections:gn(function(e,t,r){for(var n=this,i=[],o=this.sel,l=0;l<o.ranges.length;l++){var s=o.ranges[l];i[l]={from:s.from(),to:s.to(),text:n.splitLines(e[l]),origin:r}}for(var a=t&&"end"!=t&&Kn(this,i,t),u=i.length-1;u>=0;u--)Oi(n,i[u]);a?yi(this,a):this.cm&&jr(this.cm)}),undo:gn(function(){Wi(this,"undo")}),redo:gn(function(){Wi(this,"redo")}),undoSelection:gn(function(){Wi(this,"undo",!0)}),redoSelection:gn(function(){Wi(this,"redo",!0)}),setExtending:function(e){this.extend=e},getExtending:function(){return this.extend},historySize:function(){for(var e=this.history,t=0,r=0,n=0;n<e.done.length;n++)e.done[n].ranges||++t;for(var i=0;i<e.undone.length;i++)e.undone[i].ranges||++r;return{undo:t,redo:r}},clearHistory:function(){this.history=new Jn(this.history.maxGeneration)},markClean:function(){this.cleanGeneration=this.changeGeneration(!0)},changeGeneration:function(e){return e&&(this.history.lastOp=this.history.lastSelOp=this.history.lastOrigin=null),this.history.generation},isClean:function(e){return this.history.generation==(e||this.cleanGeneration)},getHistory:function(){return{done:fi(this.history.done),undone:fi(this.history.undone)}},setHistory:function(e){var t=this.history=new Jn(this.history.maxGeneration);t.done=fi(e.done.slice(0),null,!0),t.undone=fi(e.undone.slice(0),null,!0)},setGutterMarker:gn(function(e,t,r){return Ri(this,e,"gutter",function(e){var n=e.gutterMarkers||(e.gutterMarkers={});return n[t]=r,!r&&C(n)&&(e.gutterMarkers=null),!0})}),clearGutter:gn(function(e){var t=this;this.iter(function(r){r.gutterMarkers&&r.gutterMarkers[e]&&Ri(t,r,"gutter",function(){return r.gutterMarkers[e]=null,C(r.gutterMarkers)&&(r.gutterMarkers=null),!0})})}),lineInfo:function(e){var t;if("number"==typeof e){if(!H(this,e))return null;if(t=e,!(e=M(this,e)))return null}else if(null==(t=W(e)))return null;return{line:t,handle:e,text:e.text,gutterMarkers:e.gutterMarkers,textClass:e.textClass,bgClass:e.bgClass,wrapClass:e.wrapClass,widgets:e.widgets}},addLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass";if(t[i]){if(e(n).test(t[i]))return!1;t[i]+=" "+n}else t[i]=n;return!0})}),removeLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass",o=t[i];if(!o)return!1;if(null==n)t[i]=null;else{var l=o.match(e(n));if(!l)return!1;var s=l.index+l[0].length;t[i]=o.slice(0,l.index)+(l.index&&s!=o.length?" ":"")+o.slice(s)||null}return!0})}),addLineWidget:gn(function(e,t,r){return Vi(this,e,t,r)}),removeLineWidget:function(e){e.clear()},markText:function(e,t,r){return Ki(this,U(this,e),U(this,t),r,r&&r.type||"range")},setBookmark:function(e,t){var r={replacedWith:t&&(null==t.nodeType?t.widget:t),insertLeft:t&&t.insertLeft,clearWhenEmpty:!1,shared:t&&t.shared,handleMouseEvents:t&&t.handleMouseEvents};return e=U(this,e),Ki(this,e,e,r,"bookmark")},findMarksAt:function(e){var t=[],r=M(this,(e=U(this,e)).line).markedSpans;if(r)for(var n=0;n<r.length;++n){var i=r[n];(null==i.from||i.from<=e.ch)&&(null==i.to||i.to>=e.ch)&&t.push(i.marker.parent||i.marker)}return t},findMarks:function(e,t,r){e=U(this,e),t=U(this,t);var n=[],i=e.line;return this.iter(e.line,t.line+1,function(o){var l=o.markedSpans;if(l)for(var s=0;s<l.length;s++){var a=l[s];null!=a.to&&i==e.line&&e.ch>=a.to||null==a.from&&i!=e.line||null!=a.from&&i==t.line&&a.from>=t.ch||r&&!r(a.marker)||n.push(a.marker.parent||a.marker)}++i}),n},getAllMarks:function(){var e=[];return this.iter(function(t){var r=t.markedSpans;if(r)for(var n=0;n<r.length;++n)null!=r[n].from&&e.push(r[n].marker)}),e},posFromIndex:function(e){var t,r=this.first,n=this.lineSeparator().length;return this.iter(function(i){var o=i.text.length+n;if(o>e)return t=e,!0;e-=o,++r}),U(this,E(r,t))},indexFromPos:function(e){var t=(e=U(this,e)).ch;if(e.line<this.first||e.ch<0)return 0;var r=this.lineSeparator().length;return this.iter(this.first,e.line,function(e){t+=e.text.length+r}),t},copy:function(e){var t=new Ds(O(this,this.first,this.first+this.size),this.modeOption,this.first,this.lineSep,this.direction);return t.scrollTop=this.scrollTop,t.scrollLeft=this.scrollLeft,t.sel=this.sel,t.extend=!1,e&&(t.history.undoDepth=this.history.undoDepth,t.setHistory(this.getHistory())),t},linkedDoc:function(e){e||(e={});var t=this.first,r=this.first+this.size;null!=e.from&&e.from>t&&(t=e.from),null!=e.to&&e.to<r&&(r=e.to);var n=new Ds(O(this,t,r),e.mode||this.modeOption,t,this.lineSep,this.direction);return e.sharedHist&&(n.history=this.history),(this.linked||(this.linked=[])).push({doc:n,sharedHist:e.sharedHist}),n.linked=[{doc:this,isParent:!0,sharedHist:e.sharedHist}],Yi(n,Xi(this)),n},unlinkDoc:function(e){var t=this;if(e instanceof jo&&(e=e.doc),this.linked)for(var r=0;r<this.linked.length;++r)if(t.linked[r].doc==e){t.linked.splice(r,1),e.unlinkDoc(t),_i(Xi(t));break}if(e.history==this.history){var n=[e.id];$n(e,function(e){return n.push(e.id)},!0),e.history=new Jn(null),e.history.done=fi(this.history.done,n),e.history.undone=fi(this.history.undone,n)}},iterLinkedDocs:function(e){$n(this,e)},getMode:function(){return this.mode},getEditor:function(){return this.cm},splitLines:function(e){return this.lineSep?e.split(this.lineSep):es(e)},lineSeparator:function(){return this.lineSep||"\n"},setDirection:gn(function(e){"rtl"!=e&&(e="ltr"),e!=this.direction&&(this.direction=e,this.iter(function(e){return e.order=null}),this.cm&&Qn(this.cm))})}),Ds.prototype.eachLine=Ds.prototype.iter;for(var Hs=0,Fs=!1,Es={3:"Enter",8:"Backspace",9:"Tab",13:"Enter",16:"Shift",17:"Ctrl",18:"Alt",19:"Pause",20:"CapsLock",27:"Esc",32:"Space",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"Left",38:"Up",39:"Right",40:"Down",44:"PrintScrn",45:"Insert",46:"Delete",59:";",61:"=",91:"Mod",92:"Mod",93:"Mod",106:"*",107:"=",109:"-",110:".",111:"/",127:"Delete",173:"-",186:";",187:"=",188:",",189:"-",190:".",191:"/",192:"`",219:"[",220:"\\",221:"]",222:"'",63232:"Up",63233:"Down",63234:"Left",63235:"Right",63272:"Delete",63273:"Home",63275:"End",63276:"PageUp",63277:"PageDown",63302:"Insert"},Ps=0;Ps<10;Ps++)Es[Ps+48]=Es[Ps+96]=String(Ps);for(var Is=65;Is<=90;Is++)Es[Is]=String.fromCharCode(Is);for(var zs=1;zs<=12;zs++)Es[zs+111]=Es[zs+63235]="F"+zs;var Rs={};Rs.basic={Left:"goCharLeft",Right:"goCharRight",Up:"goLineUp",Down:"goLineDown",End:"goLineEnd",Home:"goLineStartSmart",PageUp:"goPageUp",PageDown:"goPageDown",Delete:"delCharAfter",Backspace:"delCharBefore","Shift-Backspace":"delCharBefore",Tab:"defaultTab","Shift-Tab":"indentAuto",Enter:"newlineAndIndent",Insert:"toggleOverwrite",Esc:"singleSelection"},Rs.pcDefault={"Ctrl-A":"selectAll","Ctrl-D":"deleteLine","Ctrl-Z":"undo","Shift-Ctrl-Z":"redo","Ctrl-Y":"redo","Ctrl-Home":"goDocStart","Ctrl-End":"goDocEnd","Ctrl-Up":"goLineUp","Ctrl-Down":"goLineDown","Ctrl-Left":"goGroupLeft","Ctrl-Right":"goGroupRight","Alt-Left":"goLineStart","Alt-Right":"goLineEnd","Ctrl-Backspace":"delGroupBefore","Ctrl-Delete":"delGroupAfter","Ctrl-S":"save","Ctrl-F":"find","Ctrl-G":"findNext","Shift-Ctrl-G":"findPrev","Shift-Ctrl-F":"replace","Shift-Ctrl-R":"replaceAll","Ctrl-[":"indentLess","Ctrl-]":"indentMore","Ctrl-U":"undoSelection","Shift-Ctrl-U":"redoSelection","Alt-U":"redoSelection",fallthrough:"basic"},Rs.emacsy={"Ctrl-F":"goCharRight","Ctrl-B":"goCharLeft","Ctrl-P":"goLineUp","Ctrl-N":"goLineDown","Alt-F":"goWordRight","Alt-B":"goWordLeft","Ctrl-A":"goLineStart","Ctrl-E":"goLineEnd","Ctrl-V":"goPageDown","Shift-Ctrl-V":"goPageUp","Ctrl-D":"delCharAfter","Ctrl-H":"delCharBefore","Alt-D":"delWordAfter","Alt-Backspace":"delWordBefore","Ctrl-K":"killLine","Ctrl-T":"transposeChars","Ctrl-O":"openLine"},Rs.macDefault={"Cmd-A":"selectAll","Cmd-D":"deleteLine","Cmd-Z":"undo","Shift-Cmd-Z":"redo","Cmd-Y":"redo","Cmd-Home":"goDocStart","Cmd-Up":"goDocStart","Cmd-End":"goDocEnd","Cmd-Down":"goDocEnd","Alt-Left":"goGroupLeft","Alt-Right":"goGroupRight","Cmd-Left":"goLineLeft","Cmd-Right":"goLineRight","Alt-Backspace":"delGroupBefore","Ctrl-Alt-Backspace":"delGroupAfter","Alt-Delete":"delGroupAfter","Cmd-S":"save","Cmd-F":"find","Cmd-G":"findNext","Shift-Cmd-G":"findPrev","Cmd-Alt-F":"replace","Shift-Cmd-Alt-F":"replaceAll","Cmd-[":"indentLess","Cmd-]":"indentMore","Cmd-Backspace":"delWrappedLineLeft","Cmd-Delete":"delWrappedLineRight","Cmd-U":"undoSelection","Shift-Cmd-U":"redoSelection","Ctrl-Up":"goDocStart","Ctrl-Down":"goDocEnd",fallthrough:["basic","emacsy"]},Rs.default=Ml?Rs.macDefault:Rs.pcDefault;var Bs={selectAll:Mi,singleSelection:function(e){return e.setSelection(e.getCursor("anchor"),e.getCursor("head"),Gl)},killLine:function(e){return co(e,function(t){if(t.empty()){var r=M(e.doc,t.head.line).text.length;return t.head.ch==r&&t.head.line<e.lastLine()?{from:t.head,to:E(t.head.line+1,0)}:{from:t.head,to:E(t.head.line,r)}}return{from:t.from(),to:t.to()}})},deleteLine:function(e){return co(e,function(t){return{from:E(t.from().line,0),to:U(e.doc,E(t.to().line+1,0))}})},delLineLeft:function(e){return co(e,function(e){return{from:E(e.from().line,0),to:e.from()}})},delWrappedLineLeft:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5;return{from:e.coordsChar({left:0,top:r},"div"),to:t.from()}})},delWrappedLineRight:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5,n=e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div");return{from:t.from(),to:n}})},undo:function(e){return e.undo()},redo:function(e){return e.redo()},undoSelection:function(e){return e.undoSelection()},redoSelection:function(e){return e.redoSelection()},goDocStart:function(e){return e.extendSelection(E(e.firstLine(),0))},goDocEnd:function(e){return e.extendSelection(E(e.lastLine()))},goLineStart:function(e){return e.extendSelectionsBy(function(t){return vo(e,t.head.line)},{origin:"+move",bias:1})},goLineStartSmart:function(e){return e.extendSelectionsBy(function(t){return yo(e,t.head)},{origin:"+move",bias:1})},goLineEnd:function(e){return e.extendSelectionsBy(function(t){return mo(e,t.head.line)},{origin:"+move",bias:-1})},goLineRight:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div")},Vl)},goLineLeft:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:0,top:r},"div")},Vl)},goLineLeftSmart:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5,n=e.coordsChar({left:0,top:r},"div");return n.ch<e.getLine(n.line).search(/\S/)?yo(e,t.head):n},Vl)},goLineUp:function(e){return e.moveV(-1,"line")},goLineDown:function(e){return e.moveV(1,"line")},goPageUp:function(e){return e.moveV(-1,"page")},goPageDown:function(e){return e.moveV(1,"page")},goCharLeft:function(e){return e.moveH(-1,"char")},goCharRight:function(e){return e.moveH(1,"char")},goColumnLeft:function(e){return e.moveH(-1,"column")},goColumnRight:function(e){return e.moveH(1,"column")},goWordLeft:function(e){return e.moveH(-1,"word")},goGroupRight:function(e){return e.moveH(1,"group")},goGroupLeft:function(e){return e.moveH(-1,"group")},goWordRight:function(e){return e.moveH(1,"word")},delCharBefore:function(e){return e.deleteH(-1,"char")},delCharAfter:function(e){return e.deleteH(1,"char")},delWordBefore:function(e){return e.deleteH(-1,"word")},delWordAfter:function(e){return e.deleteH(1,"word")},delGroupBefore:function(e){return e.deleteH(-1,"group")},delGroupAfter:function(e){return e.deleteH(1,"group")},indentAuto:function(e){return e.indentSelection("smart")},indentMore:function(e){return e.indentSelection("add")},indentLess:function(e){return e.indentSelection("subtract")},insertTab:function(e){return e.replaceSelection("\t")},insertSoftTab:function(e){for(var t=[],r=e.listSelections(),n=e.options.tabSize,i=0;i<r.length;i++){var o=r[i].from(),l=f(e.getLine(o.line),o.ch,n);t.push(p(n-l%n))}e.replaceSelections(t)},defaultTab:function(e){e.somethingSelected()?e.indentSelection("add"):e.execCommand("insertTab")},transposeChars:function(e){return hn(e,function(){for(var t=e.listSelections(),r=[],n=0;n<t.length;n++)if(t[n].empty()){var i=t[n].head,o=M(e.doc,i.line).text;if(o)if(i.ch==o.length&&(i=new E(i.line,i.ch-1)),i.ch>0)i=new E(i.line,i.ch+1),e.replaceRange(o.charAt(i.ch-1)+o.charAt(i.ch-2),E(i.line,i.ch-2),i,"+transpose");else if(i.line>e.doc.first){var l=M(e.doc,i.line-1).text;l&&(i=new E(i.line,1),e.replaceRange(o.charAt(0)+e.doc.lineSeparator()+l.charAt(l.length-1),E(i.line-1,l.length-1),i,"+transpose"))}r.push(new Ts(i,i))}e.setSelections(r)})},newlineAndIndent:function(e){return hn(e,function(){for(var t=e.listSelections(),r=t.length-1;r>=0;r--)e.replaceRange(e.doc.lineSeparator(),t[r].anchor,t[r].head,"+input");t=e.listSelections();for(var n=0;n<t.length;n++)e.indentLine(t[n].from().line,null,!0);jr(e)})},openLine:function(e){return e.replaceSelection("\n","start")},toggleOverwrite:function(e){return e.toggleOverwrite()}},Gs=new Pl,Us=null,Vs=function(e,t,r){this.time=e,this.pos=t,this.button=r};Vs.prototype.compare=function(e,t,r){return this.time+400>e&&0==P(t,this.pos)&&r==this.button};var Ks,js,Xs={toString:function(){return"CodeMirror.Init"}},Ys={},_s={};jo.defaults=Ys,jo.optionHandlers=_s;var $s=[];jo.defineInitHook=function(e){return $s.push(e)};var qs=null,Zs=function(e){this.cm=e,this.lastAnchorNode=this.lastAnchorOffset=this.lastFocusNode=this.lastFocusOffset=null,this.polling=new Pl,this.composing=null,this.gracePeriod=!1,this.readDOMTimeout=null};Zs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()}),"cut"==e.type&&i.replaceSelection("",null,"cut");else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type&&i.operation(function(){i.setSelections(t.ranges,0,Gl),i.replaceSelection("",null,"cut")})}if(e.clipboardData){e.clipboardData.clearData();var r=qs.text.join("\n");if(e.clipboardData.setData("Text",r),e.clipboardData.getData("Text")==r)return void e.preventDefault()}var l=el(),s=l.firstChild;i.display.lineSpace.insertBefore(l,i.display.lineSpace.firstChild),s.value=qs.text.join("\n");var a=document.activeElement;El(s),setTimeout(function(){i.display.lineSpace.removeChild(l),a.focus(),a==o&&n.showPrimarySelection()},50)}}var r=this,n=this,i=n.cm,o=n.div=e.lineDiv;Jo(o,i.options.spellcheck),Ql(o,"paste",function(e){Me(i,e)||qo(e,i)||vl<=11&&setTimeout(dn(i,function(){return r.updateFromDOM()}),20)}),Ql(o,"compositionstart",function(e){r.composing={data:e.data,done:!1}}),Ql(o,"compositionupdate",function(e){r.composing||(r.composing={data:e.data,done:!1})}),Ql(o,"compositionend",function(e){r.composing&&(e.data!=r.composing.data&&r.readFromDOMSoon(),r.composing.done=!0)}),Ql(o,"touchstart",function(){return n.forceCompositionEnd()}),Ql(o,"input",function(){r.composing||r.readFromDOMSoon()}),Ql(o,"copy",t),Ql(o,"cut",t)},Zs.prototype.prepareSelection=function(){var e=Tr(this.cm,!1);return e.focus=this.cm.state.focused,e},Zs.prototype.showSelection=function(e,t){e&&this.cm.display.view.length&&((e.focus||t)&&this.showPrimarySelection(),this.showMultipleSelections(e))},Zs.prototype.showPrimarySelection=function(){var e=window.getSelection(),t=this.cm,r=t.doc.sel.primary(),n=r.from(),i=r.to();if(t.display.viewTo==t.display.viewFrom||n.line>=t.display.viewTo||i.line<t.display.viewFrom)e.removeAllRanges();else{var o=sl(t,e.anchorNode,e.anchorOffset),l=sl(t,e.focusNode,e.focusOffset);if(!o||o.bad||!l||l.bad||0!=P(B(o,l),n)||0!=P(R(o,l),i)){var s=t.display.view,a=n.line>=t.display.viewFrom&&nl(t,n)||{node:s[0].measure.map[2],offset:0},u=i.line<t.display.viewTo&&nl(t,i);if(!u){var c=s[s.length-1].measure,f=c.maps?c.maps[c.maps.length-1]:c.map;u={node:f[f.length-1],offset:f[f.length-2]-f[f.length-3]}}if(a&&u){var h,d=e.rangeCount&&e.getRangeAt(0);try{h=Wl(a.node,a.offset,u.offset,u.node)}catch(e){}h&&(!fl&&t.state.focused?(e.collapse(a.node,a.offset),h.collapsed||(e.removeAllRanges(),e.addRange(h))):(e.removeAllRanges(),e.addRange(h)),d&&null==e.anchorNode?e.addRange(d):fl&&this.startGracePeriod()),this.rememberSelection()}else e.removeAllRanges()}}},Zs.prototype.startGracePeriod=function(){var e=this;clearTimeout(this.gracePeriod),this.gracePeriod=setTimeout(function(){e.gracePeriod=!1,e.selectionChanged()&&e.cm.operation(function(){return e.cm.curOp.selectionChanged=!0})},20)},Zs.prototype.showMultipleSelections=function(e){r(this.cm.display.cursorDiv,e.cursors),r(this.cm.display.selectionDiv,e.selection)},Zs.prototype.rememberSelection=function(){var e=window.getSelection();this.lastAnchorNode=e.anchorNode,this.lastAnchorOffset=e.anchorOffset,this.lastFocusNode=e.focusNode,this.lastFocusOffset=e.focusOffset},Zs.prototype.selectionInEditor=function(){var e=window.getSelection();if(!e.rangeCount)return!1;var t=e.getRangeAt(0).commonAncestorContainer;return o(this.div,t)},Zs.prototype.focus=function(){"nocursor"!=this.cm.options.readOnly&&(this.selectionInEditor()||this.showSelection(this.prepareSelection(),!0),this.div.focus())},Zs.prototype.blur=function(){this.div.blur()},Zs.prototype.getField=function(){return this.div},Zs.prototype.supportsTouch=function(){return!0},Zs.prototype.receivedFocus=function(){function e(){t.cm.state.focused&&(t.pollSelection(),t.polling.set(t.cm.options.pollInterval,e))}var t=this;this.selectionInEditor()?this.pollSelection():hn(this.cm,function(){return t.cm.curOp.selectionChanged=!0}),this.polling.set(this.cm.options.pollInterval,e)},Zs.prototype.selectionChanged=function(){var e=window.getSelection();return e.anchorNode!=this.lastAnchorNode||e.anchorOffset!=this.lastAnchorOffset||e.focusNode!=this.lastFocusNode||e.focusOffset!=this.lastFocusOffset},Zs.prototype.pollSelection=function(){if(null==this.readDOMTimeout&&!this.gracePeriod&&this.selectionChanged()){var e=window.getSelection(),t=this.cm;if(kl&&bl&&this.cm.options.gutters.length&&il(e.anchorNode))return this.cm.triggerOnKeyDown({type:"keydown",keyCode:8,preventDefault:Math.abs}),this.blur(),void this.focus();if(!this.composing){this.rememberSelection();var r=sl(t,e.anchorNode,e.anchorOffset),n=sl(t,e.focusNode,e.focusOffset);r&&n&&hn(t,function(){bi(t.doc,Rn(r,n),Gl),(r.bad||n.bad)&&(t.curOp.selectionChanged=!0)})}}},Zs.prototype.pollContent=function(){null!=this.readDOMTimeout&&(clearTimeout(this.readDOMTimeout),this.readDOMTimeout=null);var e=this.cm,t=e.display,r=e.doc.sel.primary(),n=r.from(),i=r.to();if(0==n.ch&&n.line>e.firstLine()&&(n=E(n.line-1,M(e.doc,n.line-1).length)),i.ch==M(e.doc,i.line).text.length&&i.line<e.lastLine()&&(i=E(i.line+1,0)),n.line<t.viewFrom||i.line>t.viewTo-1)return!1;var o,l,s;n.line==t.viewFrom||0==(o=Lr(e,n.line))?(l=W(t.view[0].line),s=t.view[0].node):(l=W(t.view[o].line),s=t.view[o-1].node.nextSibling);var a,u,c=Lr(e,i.line);if(c==t.view.length-1?(a=t.viewTo-1,u=t.lineDiv.lastChild):(a=W(t.view[c+1].line)-1,u=t.view[c+1].node.previousSibling),!s)return!1;for(var f=e.doc.splitLines(ll(e,s,u,l,a)),h=N(e.doc,E(l,0),E(a,M(e.doc,a).text.length));f.length>1&&h.length>1;)if(g(f)==g(h))f.pop(),h.pop(),a--;else{if(f[0]!=h[0])break;f.shift(),h.shift(),l++}for(var d=0,p=0,v=f[0],m=h[0],y=Math.min(v.length,m.length);d<y&&v.charCodeAt(d)==m.charCodeAt(d);)++d;for(var b=g(f),w=g(h),x=Math.min(b.length-(1==f.length?d:0),w.length-(1==h.length?d:0));p<x&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)++p;if(1==f.length&&1==h.length&&l==n.line)for(;d&&d>n.ch&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)d--,p++;f[f.length-1]=b.slice(0,b.length-p).replace(/^\u200b+/,""),f[0]=f[0].slice(d).replace(/\u200b+$/,"");var C=E(l,d),S=E(a,h.length?g(h).length-p:0);return f.length>1||f[0]||P(C,S)?(Ei(e.doc,f,C,S,"+input"),!0):void 0},Zs.prototype.ensurePolled=function(){this.forceCompositionEnd()},Zs.prototype.reset=function(){this.forceCompositionEnd()},Zs.prototype.forceCompositionEnd=function(){this.composing&&(clearTimeout(this.readDOMTimeout),this.composing=null,this.updateFromDOM(),this.div.blur(),this.div.focus())},Zs.prototype.readFromDOMSoon=function(){var e=this;null==this.readDOMTimeout&&(this.readDOMTimeout=setTimeout(function(){if(e.readDOMTimeout=null,e.composing){if(!e.composing.done)return;e.composing=null}e.updateFromDOM()},80))},Zs.prototype.updateFromDOM=function(){var e=this;!this.cm.isReadOnly()&&this.pollContent()||hn(this.cm,function(){return vn(e.cm)})},Zs.prototype.setUneditable=function(e){e.contentEditable="false"},Zs.prototype.onKeyPress=function(e){0!=e.charCode&&(e.preventDefault(),this.cm.isReadOnly()||dn(this.cm,$o)(this.cm,String.fromCharCode(null==e.charCode?e.keyCode:e.charCode),0))},Zs.prototype.readOnlyChanged=function(e){this.div.contentEditable=String("nocursor"!=e)},Zs.prototype.onContextMenu=function(){},Zs.prototype.resetPosition=function(){},Zs.prototype.needsContentAttribute=!0;var Qs=function(e){this.cm=e,this.prevInput="",this.pollingFast=!1,this.polling=new Pl,this.hasSelection=!1,this.composing=null};Qs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()});else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type?i.setSelections(t.ranges,null,Gl):(n.prevInput="",l.value=t.text.join("\n"),El(l))}"cut"==e.type&&(i.state.cutIncoming=!0)}}var r=this,n=this,i=this.cm,o=this.wrapper=el(),l=this.textarea=o.firstChild;e.wrapper.insertBefore(o,e.wrapper.firstChild),Ll&&(l.style.width="0px"),Ql(l,"input",function(){gl&&vl>=9&&r.hasSelection&&(r.hasSelection=null),n.poll()}),Ql(l,"paste",function(e){Me(i,e)||qo(e,i)||(i.state.pasteIncoming=!0,n.fastPoll())}),Ql(l,"cut",t),Ql(l,"copy",t),Ql(e.scroller,"paste",function(t){Ft(e,t)||Me(i,t)||(i.state.pasteIncoming=!0,n.focus())}),Ql(e.lineSpace,"selectstart",function(t){Ft(e,t)||We(t)}),Ql(l,"compositionstart",function(){var e=i.getCursor("from");n.composing&&n.composing.range.clear(),n.composing={start:e,range:i.markText(e,i.getCursor("to"),{className:"CodeMirror-composing"})}}),Ql(l,"compositionend",function(){n.composing&&(n.poll(),n.composing.range.clear(),n.composing=null)})},Qs.prototype.prepareSelection=function(){var e=this.cm,t=e.display,r=e.doc,n=Tr(e);if(e.options.moveInputWithCursor){var i=sr(e,r.sel.primary().head,"div"),o=t.wrapper.getBoundingClientRect(),l=t.lineDiv.getBoundingClientRect();n.teTop=Math.max(0,Math.min(t.wrapper.clientHeight-10,i.top+l.top-o.top)),n.teLeft=Math.max(0,Math.min(t.wrapper.clientWidth-10,i.left+l.left-o.left))}return n},Qs.prototype.showSelection=function(e){var t=this.cm.display;r(t.cursorDiv,e.cursors),r(t.selectionDiv,e.selection),null!=e.teTop&&(this.wrapper.style.top=e.teTop+"px",this.wrapper.style.left=e.teLeft+"px")},Qs.prototype.reset=function(e){if(!this.contextMenuPending&&!this.composing){var t=this.cm;if(t.somethingSelected()){this.prevInput="";var r=t.getSelection();this.textarea.value=r,t.state.focused&&El(this.textarea),gl&&vl>=9&&(this.hasSelection=r)}else e||(this.prevInput=this.textarea.value="",gl&&vl>=9&&(this.hasSelection=null))}},Qs.prototype.getField=function(){return this.textarea},Qs.prototype.supportsTouch=function(){return!1},Qs.prototype.focus=function(){if("nocursor"!=this.cm.options.readOnly&&(!Tl||l()!=this.textarea))try{this.textarea.focus()}catch(e){}},Qs.prototype.blur=function(){this.textarea.blur()},Qs.prototype.resetPosition=function(){this.wrapper.style.top=this.wrapper.style.left=0},Qs.prototype.receivedFocus=function(){this.slowPoll()},Qs.prototype.slowPoll=function(){var e=this;this.pollingFast||this.polling.set(this.cm.options.pollInterval,function(){e.poll(),e.cm.state.focused&&e.slowPoll()})},Qs.prototype.fastPoll=function(){function e(){r.poll()||t?(r.pollingFast=!1,r.slowPoll()):(t=!0,r.polling.set(60,e))}var t=!1,r=this;r.pollingFast=!0,r.polling.set(20,e)},Qs.prototype.poll=function(){var e=this,t=this.cm,r=this.textarea,n=this.prevInput;if(this.contextMenuPending||!t.state.focused||ts(r)&&!n&&!this.composing||t.isReadOnly()||t.options.disableInput||t.state.keySeq)return!1;var i=r.value;if(i==n&&!t.somethingSelected())return!1;if(gl&&vl>=9&&this.hasSelection===i||Ml&&/[\uf700-\uf7ff]/.test(i))return t.display.input.reset(),!1;if(t.doc.sel==t.display.selForContextMenu){var o=i.charCodeAt(0);if(8203!=o||n||(n="​"),8666==o)return this.reset(),this.cm.execCommand("undo")}for(var l=0,s=Math.min(n.length,i.length);l<s&&n.charCodeAt(l)==i.charCodeAt(l);)++l;return hn(t,function(){$o(t,i.slice(l),n.length-l,null,e.composing?"*compose":null),i.length>1e3||i.indexOf("\n")>-1?r.value=e.prevInput="":e.prevInput=i,e.composing&&(e.composing.range.clear(),e.composing.range=t.markText(e.composing.start,t.getCursor("to"),{className:"CodeMirror-composing"}))}),!0},Qs.prototype.ensurePolled=function(){this.pollingFast&&this.poll()&&(this.pollingFast=!1)},Qs.prototype.onKeyPress=function(){gl&&vl>=9&&(this.hasSelection=null),this.fastPoll()},Qs.prototype.onContextMenu=function(e){function t(){if(null!=l.selectionStart){var e=i.somethingSelected(),t="​"+(e?l.value:"");l.value="⇚",l.value=t,n.prevInput=e?"":"​",l.selectionStart=1,l.selectionEnd=t.length,o.selForContextMenu=i.doc.sel}}function r(){if(n.contextMenuPending=!1,n.wrapper.style.cssText=c,l.style.cssText=u,gl&&vl<9&&o.scrollbars.setScrollTop(o.scroller.scrollTop=a),null!=l.selectionStart){(!gl||gl&&vl<9)&&t();var e=0,r=function(){o.selForContextMenu==i.doc.sel&&0==l.selectionStart&&l.selectionEnd>0&&"​"==n.prevInput?dn(i,Mi)(i):e++<10?o.detectingSelectAll=setTimeout(r,500):(o.selForContextMenu=null,o.input.reset())};o.detectingSelectAll=setTimeout(r,200)}}var n=this,i=n.cm,o=i.display,l=n.textarea,s=Sr(i,e),a=o.scroller.scrollTop;if(s&&!wl){i.options.resetSelectionOnContextMenu&&-1==i.doc.sel.contains(s)&&dn(i,bi)(i.doc,Rn(s),Gl);var u=l.style.cssText,c=n.wrapper.style.cssText;n.wrapper.style.cssText="position: absolute";var f=n.wrapper.getBoundingClientRect();l.style.cssText="position: absolute; width: 30px; height: 30px;\n      top: "+(e.clientY-f.top-5)+"px; left: "+(e.clientX-f.left-5)+"px;\n      z-index: 1000; background: "+(gl?"rgba(255, 255, 255, .05)":"transparent")+";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";var h;if(ml&&(h=window.scrollY),o.input.focus(),ml&&window.scrollTo(null,h),o.input.reset(),i.somethingSelected()||(l.value=n.prevInput=" "),n.contextMenuPending=!0,o.selForContextMenu=i.doc.sel,clearTimeout(o.detectingSelectAll),gl&&vl>=9&&t(),Hl){Fe(e);var d=function(){ke(window,"mouseup",d),setTimeout(r,20)};Ql(window,"mouseup",d)}else setTimeout(r,50)}},Qs.prototype.readOnlyChanged=function(e){e||this.reset(),this.textarea.disabled="nocursor"==e},Qs.prototype.setUneditable=function(){},Qs.prototype.needsContentAttribute=!1,function(e){function t(t,n,i,o){e.defaults[t]=n,i&&(r[t]=o?function(e,t,r){r!=Xs&&i(e,t,r)}:i)}var r=e.optionHandlers;e.defineOption=t,e.Init=Xs,t("value","",function(e,t){return e.setValue(t)},!0),t("mode",null,function(e,t){e.doc.modeOption=t,jn(e)},!0),t("indentUnit",2,jn,!0),t("indentWithTabs",!1),t("smartIndent",!0),t("tabSize",4,function(e){Xn(e),er(e),vn(e)},!0),t("lineSeparator",null,function(e,t){if(e.doc.lineSep=t,t){var r=[],n=e.doc.first;e.doc.iter(function(e){for(var i=0;;){var o=e.text.indexOf(t,i);if(-1==o)break;i=o+t.length,r.push(E(n,o))}n++});for(var i=r.length-1;i>=0;i--)Ei(e.doc,t,r[i],E(r[i].line,r[i].ch+t.length))}}),t("specialChars",/[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff]/g,function(e,t,r){e.state.specialChars=new RegExp(t.source+(t.test("\t")?"":"|\t"),"g"),r!=Xs&&e.refresh()}),t("specialCharPlaceholder",at,function(e){return e.refresh()},!0),t("electricChars",!0),t("inputStyle",Tl?"contenteditable":"textarea",function(){throw new Error("inputStyle can not (yet) be changed in a running editor")},!0),t("spellcheck",!1,function(e,t){return e.getInputField().spellcheck=t},!0),t("rtlMoveVisually",!Ol),t("wholeLineUpdateBefore",!0),t("theme","default",function(e){Go(e),Uo(e)},!0),t("keyMap","default",function(e,t,r){var n=uo(t),i=r!=Xs&&uo(r);i&&i.detach&&i.detach(e,n),n.attach&&n.attach(e,i||null)}),t("extraKeys",null),t("configureMouse",null),t("lineWrapping",!1,Ko,!0),t("gutters",[],function(e){Fn(e.options),Uo(e)},!0),t("fixedGutter",!0,function(e,t){e.display.gutters.style.left=t?wr(e.display)+"px":"0",e.refresh()},!0),t("coverGutterNextToScrollbar",!1,function(e){return en(e)},!0),t("scrollbarStyle","native",function(e){rn(e),en(e),e.display.scrollbars.setScrollTop(e.doc.scrollTop),e.display.scrollbars.setScrollLeft(e.doc.scrollLeft)},!0),t("lineNumbers",!1,function(e){Fn(e.options),Uo(e)},!0),t("firstLineNumber",1,Uo,!0),t("lineNumberFormatter",function(e){return e},Uo,!0),t("showCursorWhenSelecting",!1,kr,!0),t("resetSelectionOnContextMenu",!0),t("lineWiseCopyCut",!0),t("pasteLinesPerSelection",!0),t("readOnly",!1,function(e,t){"nocursor"==t&&(Fr(e),e.display.input.blur()),e.display.input.readOnlyChanged(t)}),t("disableInput",!1,function(e,t){t||e.display.input.reset()},!0),t("dragDrop",!0,Vo),t("allowDropFileTypes",null),t("cursorBlinkRate",530),t("cursorScrollMargin",0),t("cursorHeight",1,kr,!0),t("singleCursorHeightPerLine",!0,kr,!0),t("workTime",100),t("workDelay",100),t("flattenSpans",!0,Xn,!0),t("addModeClass",!1,Xn,!0),t("pollInterval",100),t("undoDepth",200,function(e,t){return e.doc.history.undoDepth=t}),t("historyEventDelay",1250),t("viewportMargin",10,function(e){return e.refresh()},!0),t("maxHighlightLength",1e4,Xn,!0),t("moveInputWithCursor",!0,function(e,t){t||e.display.input.resetPosition()}),t("tabindex",null,function(e,t){return e.display.input.getField().tabIndex=t||""}),t("autofocus",null),t("direction","ltr",function(e,t){return e.doc.setDirection(t)},!0)}(jo),function(e){var t=e.optionHandlers,r=e.helpers={};e.prototype={constructor:e,focus:function(){window.focus(),this.display.input.focus()},setOption:function(e,r){var n=this.options,i=n[e];n[e]==r&&"mode"!=e||(n[e]=r,t.hasOwnProperty(e)&&dn(this,t[e])(this,r,i),Te(this,"optionChange",this,e))},getOption:function(e){return this.options[e]},getDoc:function(){return this.doc},addKeyMap:function(e,t){this.state.keyMaps[t?"push":"unshift"](uo(e))},removeKeyMap:function(e){for(var t=this.state.keyMaps,r=0;r<t.length;++r)if(t[r]==e||t[r].name==e)return t.splice(r,1),!0},addOverlay:pn(function(t,r){var n=t.token?t:e.getMode(this.options,t);if(n.startState)throw new Error("Overlays may not be stateful.");m(this.state.overlays,{mode:n,modeSpec:t,opaque:r&&r.opaque,priority:r&&r.priority||0},function(e){return e.priority}),this.state.modeGen++,vn(this)}),removeOverlay:pn(function(e){for(var t=this,r=this.state.overlays,n=0;n<r.length;++n){var i=r[n].modeSpec;if(i==e||"string"==typeof e&&i.name==e)return r.splice(n,1),t.state.modeGen++,void vn(t)}}),indentLine:pn(function(e,t,r){"string"!=typeof t&&"number"!=typeof t&&(t=null==t?this.options.smartIndent?"smart":"prev":t?"add":"subtract"),H(this.doc,e)&&Yo(this,e,t,r)}),indentSelection:pn(function(e){for(var t=this,r=this.doc.sel.ranges,n=-1,i=0;i<r.length;i++){var o=r[i];if(o.empty())o.head.line>n&&(Yo(t,o.head.line,e,!0),n=o.head.line,i==t.doc.sel.primIndex&&jr(t));else{var l=o.from(),s=o.to(),a=Math.max(n,l.line);n=Math.min(t.lastLine(),s.line-(s.ch?0:1))+1;for(var u=a;u<n;++u)Yo(t,u,e);var c=t.doc.sel.ranges;0==l.ch&&r.length==c.length&&c[i].from().ch>0&&gi(t.doc,i,new Ts(l,c[i].to()),Gl)}}}),getTokenAt:function(e,t){return Je(this,e,t)},getLineTokens:function(e,t){return Je(this,E(e),t,!0)},getTokenTypeAt:function(e){e=U(this.doc,e);var t,r=_e(this,M(this.doc,e.line)),n=0,i=(r.length-1)/2,o=e.ch;if(0==o)t=r[2];else for(;;){var l=n+i>>1;if((l?r[2*l-1]:0)>=o)i=l;else{if(!(r[2*l+1]<o)){t=r[2*l+2];break}n=l+1}}var s=t?t.indexOf("overlay "):-1;return s<0?t:0==s?null:t.slice(0,s-1)},getModeAt:function(t){var r=this.doc.mode;return r.innerMode?e.innerMode(r,this.getTokenAt(t).state).mode:r},getHelper:function(e,t){return this.getHelpers(e,t)[0]},getHelpers:function(e,t){var n=this,i=[];if(!r.hasOwnProperty(t))return i;var o=r[t],l=this.getModeAt(e);if("string"==typeof l[t])o[l[t]]&&i.push(o[l[t]]);else if(l[t])for(var s=0;s<l[t].length;s++){var a=o[l[t][s]];a&&i.push(a)}else l.helperType&&o[l.helperType]?i.push(o[l.helperType]):o[l.name]&&i.push(o[l.name]);for(var u=0;u<o._global.length;u++){var c=o._global[u];c.pred(l,n)&&-1==h(i,c.val)&&i.push(c.val)}return i},getStateAfter:function(e,t){var r=this.doc;return e=G(r,null==e?r.first+r.size-1:e),$e(this,e+1,t).state},cursorCoords:function(e,t){var r,n=this.doc.sel.primary();return r=null==e?n.head:"object"==typeof e?U(this.doc,e):e?n.from():n.to(),sr(this,r,t||"page")},charCoords:function(e,t){return lr(this,U(this.doc,e),t||"page")},coordsChar:function(e,t){return e=or(this,e,t||"page"),cr(this,e.left,e.top)},lineAtHeight:function(e,t){return e=or(this,{top:e,left:0},t||"page").top,D(this.doc,e+this.display.viewOffset)},heightAtLine:function(e,t,r){var n,i=!1;if("number"==typeof e){var o=this.doc.first+this.doc.size-1;e<this.doc.first?e=this.doc.first:e>o&&(e=o,i=!0),n=M(this.doc,e)}else n=e;return ir(this,n,{top:0,left:0},t||"page",r||i).top+(i?this.doc.height-ye(n):0)},defaultTextHeight:function(){return mr(this.display)},defaultCharWidth:function(){return yr(this.display)},getViewport:function(){return{from:this.display.viewFrom,to:this.display.viewTo}},addWidget:function(e,t,r,n,i){var o=this.display,l=(e=sr(this,U(this.doc,e))).bottom,s=e.left;if(t.style.position="absolute",t.setAttribute("cm-ignore-events","true"),this.display.input.setUneditable(t),o.sizer.appendChild(t),"over"==n)l=e.top;else if("above"==n||"near"==n){var a=Math.max(o.wrapper.clientHeight,this.doc.height),u=Math.max(o.sizer.clientWidth,o.lineSpace.clientWidth);("above"==n||e.bottom+t.offsetHeight>a)&&e.top>t.offsetHeight?l=e.top-t.offsetHeight:e.bottom+t.offsetHeight<=a&&(l=e.bottom),s+t.offsetWidth>u&&(s=u-t.offsetWidth)}t.style.top=l+"px",t.style.left=t.style.right="","right"==i?(s=o.sizer.clientWidth-t.offsetWidth,t.style.right="0px"):("left"==i?s=0:"middle"==i&&(s=(o.sizer.clientWidth-t.offsetWidth)/2),t.style.left=s+"px"),r&&Ur(this,{left:s,top:l,right:s+t.offsetWidth,bottom:l+t.offsetHeight})},triggerOnKeyDown:pn(Lo),triggerOnKeyPress:pn(Mo),triggerOnKeyUp:To,triggerOnMouseDown:pn(Oo),execCommand:function(e){if(Bs.hasOwnProperty(e))return Bs[e].call(null,this)},triggerElectric:pn(function(e){Zo(this,e)}),findPosH:function(e,t,r,n){var i=this,o=1;t<0&&(o=-1,t=-t);for(var l=U(this.doc,e),s=0;s<t&&!(l=tl(i.doc,l,o,r,n)).hitSide;++s);return l},moveH:pn(function(e,t){var r=this;this.extendSelectionsBy(function(n){return r.display.shift||r.doc.extend||n.empty()?tl(r.doc,n.head,e,t,r.options.rtlMoveVisually):e<0?n.from():n.to()},Vl)}),deleteH:pn(function(e,t){var r=this.doc.sel,n=this.doc;r.somethingSelected()?n.replaceSelection("",null,"+delete"):co(this,function(r){var i=tl(n,r.head,e,t,!1);return e<0?{from:i,to:r.head}:{from:r.head,to:i}})}),findPosV:function(e,t,r,n){var i=this,o=1,l=n;t<0&&(o=-1,t=-t);for(var s=U(this.doc,e),a=0;a<t;++a){var u=sr(i,s,"div");if(null==l?l=u.left:u.left=l,(s=rl(i,u,o,r)).hitSide)break}return s},moveV:pn(function(e,t){var r=this,n=this.doc,i=[],o=!this.display.shift&&!n.extend&&n.sel.somethingSelected();if(n.extendSelectionsBy(function(l){if(o)return e<0?l.from():l.to();var s=sr(r,l.head,"div");null!=l.goalColumn&&(s.left=l.goalColumn),i.push(s.left);var a=rl(r,s,e,t);return"page"==t&&l==n.sel.primary()&&Kr(r,lr(r,a,"div").top-s.top),a},Vl),i.length)for(var l=0;l<n.sel.ranges.length;l++)n.sel.ranges[l].goalColumn=i[l]}),findWordAt:function(e){var t=M(this.doc,e.line).text,r=e.ch,n=e.ch;if(t){var i=this.getHelper(e,"wordChars");"before"!=e.sticky&&n!=t.length||!r?++n:--r;for(var o=t.charAt(r),l=x(o,i)?function(e){return x(e,i)}:/\s/.test(o)?function(e){return/\s/.test(e)}:function(e){return!/\s/.test(e)&&!x(e)};r>0&&l(t.charAt(r-1));)--r;for(;n<t.length&&l(t.charAt(n));)++n}return new Ts(E(e.line,r),E(e.line,n))},toggleOverwrite:function(e){null!=e&&e==this.state.overwrite||((this.state.overwrite=!this.state.overwrite)?s(this.display.cursorDiv,"CodeMirror-overwrite"):Fl(this.display.cursorDiv,"CodeMirror-overwrite"),Te(this,"overwriteToggle",this,this.state.overwrite))},hasFocus:function(){return this.display.input.getField()==l()},isReadOnly:function(){return!(!this.options.readOnly&&!this.doc.cantEdit)},scrollTo:pn(function(e,t){Xr(this,e,t)}),getScrollInfo:function(){var e=this.display.scroller;return{left:e.scrollLeft,top:e.scrollTop,height:e.scrollHeight-zt(this)-this.display.barHeight,width:e.scrollWidth-zt(this)-this.display.barWidth,clientHeight:Bt(this),clientWidth:Rt(this)}},scrollIntoView:pn(function(e,t){null==e?(e={from:this.doc.sel.primary().head,to:null},null==t&&(t=this.options.cursorScrollMargin)):"number"==typeof e?e={from:E(e,0),to:null}:null==e.from&&(e={from:e,to:null}),e.to||(e.to=e.from),e.margin=t||0,null!=e.from.line?Yr(this,e):$r(this,e.from,e.to,e.margin)}),setSize:pn(function(e,t){var r=this,n=function(e){return"number"==typeof e||/^\d+$/.test(String(e))?e+"px":e};null!=e&&(this.display.wrapper.style.width=n(e)),null!=t&&(this.display.wrapper.style.height=n(t)),this.options.lineWrapping&&Jt(this);var i=this.display.viewFrom;this.doc.iter(i,this.display.viewTo,function(e){if(e.widgets)for(var t=0;t<e.widgets.length;t++)if(e.widgets[t].noHScroll){mn(r,i,"widget");break}++i}),this.curOp.forceUpdate=!0,Te(this,"refresh",this)}),operation:function(e){return hn(this,e)},startOperation:function(){return nn(this)},endOperation:function(){return on(this)},refresh:pn(function(){var e=this.display.cachedTextHeight;vn(this),this.curOp.forceUpdate=!0,er(this),Xr(this,this.doc.scrollLeft,this.doc.scrollTop),Wn(this),(null==e||Math.abs(e-mr(this.display))>.5)&&Cr(this),Te(this,"refresh",this)}),swapDoc:pn(function(e){var t=this.doc;return t.cm=null,qn(this,e),er(this),this.display.input.reset(),Xr(this,e.scrollLeft,e.scrollTop),this.curOp.forceScroll=!0,bt(this,"swapDoc",this,t),t}),getInputField:function(){return this.display.input.getField()},getWrapperElement:function(){return this.display.wrapper},getScrollerElement:function(){return this.display.scroller},getGutterElement:function(){return this.display.gutters}},Ae(e),e.registerHelper=function(t,n,i){r.hasOwnProperty(t)||(r[t]=e[t]={_global:[]}),r[t][n]=i},e.registerGlobalHelper=function(t,n,i,o){e.registerHelper(t,n,o),r[t]._global.push({pred:i,val:o})}}(jo);var Js="iter insert remove copy getEditor constructor".split(" ");for(var ea in Ds.prototype)Ds.prototype.hasOwnProperty(ea)&&h(Js,ea)<0&&(jo.prototype[ea]=function(e){return function(){return e.apply(this.doc,arguments)}}(Ds.prototype[ea]));return Ae(Ds),jo.inputStyles={textarea:Qs,contenteditable:Zs},jo.defineMode=function(e){jo.defaults.mode||"null"==e||(jo.defaults.mode=e),Be.apply(this,arguments)},jo.defineMIME=function(e,t){os[e]=t},jo.defineMode("null",function(){return{token:function(e){return e.skipToEnd()}}}),jo.defineMIME("text/plain","null"),jo.defineExtension=function(e,t){jo.prototype[e]=t},jo.defineDocExtension=function(e,t){Ds.prototype[e]=t},jo.fromTextArea=function(e,t){function r(){e.value=a.getValue()}if(t=t?c(t):{},t.value=e.value,!t.tabindex&&e.tabIndex&&(t.tabindex=e.tabIndex),!t.placeholder&&e.placeholder&&(t.placeholder=e.placeholder),null==t.autofocus){var n=l();t.autofocus=n==e||null!=e.getAttribute("autofocus")&&n==document.body}var i;if(e.form&&(Ql(e.form,"submit",r),!t.leaveSubmitMethodAlone)){var o=e.form;i=o.submit;try{var s=o.submit=function(){r(),o.submit=i,o.submit(),o.submit=s}}catch(e){}}t.finishInit=function(t){t.save=r,t.getTextArea=function(){return e},t.toTextArea=function(){t.toTextArea=isNaN,r(),e.parentNode.removeChild(t.getWrapperElement()),e.style.display="",e.form&&(ke(e.form,"submit",r),"function"==typeof e.form.submit&&(e.form.submit=i))}},e.style.display="none";var a=jo(function(t){return e.parentNode.insertBefore(t,e.nextSibling)},t);return a},function(e){e.off=ke,e.on=Ql,e.wheelEventPixels=Pn,e.Doc=Ds,e.splitLines=es,e.countColumn=f,e.findColumn=d,e.isWordChar=w,e.Pass=Bl,e.signal=Te,e.Line=fs,e.changeEnd=Bn,e.scrollbarModel=ws,e.Pos=E,e.cmpPos=P,e.modes=is,e.mimeModes=os,e.resolveMode=Ge,e.getMode=Ue,e.modeExtensions=ls,e.extendMode=Ve,e.copyState=Ke,e.startState=Xe,e.innerMode=je,e.commands=Bs,e.keyMap=Rs,e.keyName=ao,e.isModifierKey=lo,e.lookupKey=oo,e.normalizeKeyMap=io,e.StringStream=ss,e.SharedTextMarker=As,e.TextMarker=Os,e.LineWidget=Ms,e.e_preventDefault=We,e.e_stopPropagation=De,e.e_stop=Fe,e.addClass=s,e.contains=o,e.rmClass=Fl,e.keyNames=Es}(jo),jo.version="5.30.0",jo});
      !function(e){"object"==typeof exports&&"object"==typeof module?e(require("../../lib/codemirror")):"function"==typeof define&&define.amd?define(["../../lib/codemirror"],e):e(CodeMirror)}(function(e){"use strict";function t(e,t,n,r,o,a){this.indented=e,this.column=t,this.type=n,this.info=r,this.align=o,this.prev=a}function n(e,n,r,o){var a=e.indented;return e.context&&"statement"==e.context.type&&"statement"!=r&&(a=e.context.indented),e.context=new t(a,n,r,o,null,e.context)}function r(e){var t=e.context.type;return")"!=t&&"]"!=t&&"}"!=t||(e.indented=e.context.indented),e.context=e.context.prev}function o(e,t,n){return"variable"==t.prevToken||"type"==t.prevToken||(!!/\S(?:[^- ]>|[*\]])\s*$|\*$/.test(e.string.slice(0,n))||(!(!t.typeAtEndOfLine||e.column()!=e.indentation())||void 0))}function a(e){for(;;){if(!e||"top"==e.type)return!0;if("}"==e.type&&"namespace"!=e.prev.info)return!1;e=e.prev}}function i(e){for(var t={},n=e.split(" "),r=0;r<n.length;++r)t[n[r]]=!0;return t}function l(e,t){return"function"==typeof e?e(t):e.propertyIsEnumerable(t)}function s(e,t){if(!t.startOfLine)return!1;for(var n,r=null;n=e.peek();){if("\\"==n&&e.match(/^.$/)){r=s;break}if("/"==n&&e.match(/^\/[\/\*]/,!1))break;e.next()}return t.tokenize=r,"meta"}function c(e,t){return"type"==t.prevToken&&"type"}function u(e){return e.eatWhile(/[\w\.']/),"number"}function d(e,t){if(e.backUp(1),e.match(/(R|u8R|uR|UR|LR)/)){var n=e.match(/"([^\s\\()]{0,16})\(/);return!!n&&(t.cpp11RawStringDelim=n[1],t.tokenize=m,m(e,t))}return e.match(/(u8|u|U|L)/)?!!e.match(/["']/,!1)&&"string":(e.next(),!1)}function f(e){var t=/(\w+)::~?(\w+)$/.exec(e);return t&&t[1]==t[2]}function p(e,t){for(var n;null!=(n=e.next());)if('"'==n&&!e.eat('"')){t.tokenize=null;break}return"string"}function m(e,t){var n=t.cpp11RawStringDelim.replace(/[^\w\s]/g,"\\$&");return e.match(new RegExp(".*?\\)"+n+'"'))?t.tokenize=null:e.skipToEnd(),"string"}function h(t,n){function r(e){if(e)for(var t in e)e.hasOwnProperty(t)&&o.push(t)}"string"==typeof t&&(t=[t]);var o=[];r(n.keywords),r(n.types),r(n.builtin),r(n.atoms),o.length&&(n.helperType=t[0],e.registerHelper("hintWords",t[0],o));for(var a=0;a<t.length;++a)e.defineMIME(t[a],n)}function g(e,t){for(var n=!1;!e.eol();){if(!n&&e.match('"""')){t.tokenize=null;break}n="\\"==e.next()&&!n}return"string"}function y(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!e&&!o&&t.match('"')){a=!0;break}if(e&&t.match('"""')){a=!0;break}r=t.next(),!o&&"$"==r&&t.match("{")&&t.skipTo("}"),o=!o&&"\\"==r&&!e}return!a&&e||(n.tokenize=null),"string"}}function x(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!o&&t.match('"')&&("single"==e||t.match('""'))){a=!0;break}if(!o&&t.match("``")){w=x(e),a=!0;break}r=t.next(),o="single"==e&&!o&&"\\"==r}return a&&(n.tokenize=null),"string"}}e.defineMode("clike",function(i,s){function c(e,t){var n=e.next();if(S[n]){var r=S[n](e,t);if(!1!==r)return r}if('"'==n||"'"==n)return t.tokenize=u(n),t.tokenize(e,t);if(D.test(n))return p=n,null;if(L.test(n)){if(e.backUp(1),e.match(I))return"number";e.next()}if("/"==n){if(e.eat("*"))return t.tokenize=d,d(e,t);if(e.eat("/"))return e.skipToEnd(),"comment"}if(F.test(n)){for(;!e.match(/^\/[\/*]/,!1)&&e.eat(F););return"operator"}if(e.eatWhile(z),P)for(;e.match(P);)e.eatWhile(z);var o=e.current();return l(x,o)?(l(w,o)&&(p="newstatement"),l(v,o)&&(m=!0),"keyword"):l(b,o)?"type":l(k,o)?(l(w,o)&&(p="newstatement"),"builtin"):l(_,o)?"atom":"variable"}function u(e){return function(t,n){for(var r,o=!1,a=!1;null!=(r=t.next());){if(r==e&&!o){a=!0;break}o=!o&&"\\"==r}return(a||!o&&!C)&&(n.tokenize=null),"string"}}function d(e,t){for(var n,r=!1;n=e.next();){if("/"==n&&r){t.tokenize=null;break}r="*"==n}return"comment"}function f(e,t){s.typeFirstDefinitions&&e.eol()&&a(t.context)&&(t.typeAtEndOfLine=o(e,t,e.pos))}var p,m,h=i.indentUnit,g=s.statementIndentUnit||h,y=s.dontAlignCalls,x=s.keywords||{},b=s.types||{},k=s.builtin||{},w=s.blockKeywords||{},v=s.defKeywords||{},_=s.atoms||{},S=s.hooks||{},C=s.multiLineStrings,T=!1!==s.indentStatements,M=!1!==s.indentSwitch,P=s.namespaceSeparator,D=s.isPunctuationChar||/[\[\]{}\(\),;\:\.]/,L=s.numberStart||/[\d\.]/,I=s.number||/^(?:0x[a-f\d]+|0b[01]+|(?:\d+\.?\d*|\.\d+)(?:e[-+]?\d+)?)(u|ll?|l|f)?/i,F=s.isOperatorChar||/[+\-*&%=<>!?|\/]/,z=s.isIdentifierChar||/[\w\$_\xa1-\uffff]/;return{startState:function(e){return{tokenize:null,context:new t((e||0)-h,0,"top",null,!1),indented:0,startOfLine:!0,prevToken:null}},token:function(e,t){var i=t.context;if(e.sol()&&(null==i.align&&(i.align=!1),t.indented=e.indentation(),t.startOfLine=!0),e.eatSpace())return f(e,t),null;p=m=null;var l=(t.tokenize||c)(e,t);if("comment"==l||"meta"==l)return l;if(null==i.align&&(i.align=!0),";"==p||":"==p||","==p&&e.match(/^\s*(?:\/\/.*)?$/,!1))for(;"statement"==t.context.type;)r(t);else if("{"==p)n(t,e.column(),"}");else if("["==p)n(t,e.column(),"]");else if("("==p)n(t,e.column(),")");else if("}"==p){for(;"statement"==i.type;)i=r(t);for("}"==i.type&&(i=r(t));"statement"==i.type;)i=r(t)}else p==i.type?r(t):T&&(("}"==i.type||"top"==i.type)&&";"!=p||"statement"==i.type&&"newstatement"==p)&&n(t,e.column(),"statement",e.current());if("variable"==l&&("def"==t.prevToken||s.typeFirstDefinitions&&o(e,t,e.start)&&a(t.context)&&e.match(/^\s*\(/,!1))&&(l="def"),S.token){var u=S.token(e,t,l);void 0!==u&&(l=u)}return"def"==l&&!1===s.styleDefs&&(l="variable"),t.startOfLine=!1,t.prevToken=m?"def":l||p,f(e,t),l},indent:function(t,n){if(t.tokenize!=c&&null!=t.tokenize||t.typeAtEndOfLine)return e.Pass;var r=t.context,o=n&&n.charAt(0);if("statement"==r.type&&"}"==o&&(r=r.prev),s.dontIndentStatements)for(;"statement"==r.type&&s.dontIndentStatements.test(r.info);)r=r.prev;if(S.indent){var a=S.indent(t,r,n);if("number"==typeof a)return a}var i=o==r.type,l=r.prev&&"switch"==r.prev.info;if(s.allmanIndentation&&/[{(]/.test(o)){for(;"top"!=r.type&&"}"!=r.type;)r=r.prev;return r.indented}return"statement"==r.type?r.indented+("{"==o?0:g):!r.align||y&&")"==r.type?")"!=r.type||i?r.indented+(i?0:h)+(i||!l||/^(?:case|default)\b/.test(n)?0:h):r.indented+g:r.column+(i?0:1)},electricInput:M?/^\s*(?:case .*?:|default:|\{\}?|\})$/:/^\s*[{}]$/,blockCommentStart:"/*",blockCommentEnd:"*/",lineComment:"//",fold:"brace"}});var b="auto if break case register continue return default do sizeof static else struct switch extern typedef union for goto while enum const volatile",k="int long char short double float unsigned signed void size_t ptrdiff_t";h(["text/x-csrc","text/x-c","text/x-chdr"],{name:"clike",keywords:i(b),types:i(k+" bool _Complex _Bool float_t double_t intptr_t intmax_t int8_t int16_t int32_t int64_t uintptr_t uintmax_t uint8_t uint16_t uint32_t uint64_t"),blockKeywords:i("case do else for if switch while struct"),defKeywords:i("struct"),typeFirstDefinitions:!0,atoms:i("null true false"),hooks:{"#":s,"*":c},modeProps:{fold:["brace","include"]}}),h(["text/x-c++src","text/x-c++hdr"],{name:"clike",keywords:i(b+" asm dynamic_cast namespace reinterpret_cast try explicit new static_cast typeid catch operator template typename class friend private this using const_cast inline public throw virtual delete mutable protected alignas alignof constexpr decltype nullptr noexcept thread_local final static_assert override"),types:i(k+" bool wchar_t"),blockKeywords:i("catch class do else finally for if struct switch try while"),defKeywords:i("class namespace struct enum union"),typeFirstDefinitions:!0,atoms:i("true false null"),dontIndentStatements:/^template$/,isIdentifierChar:/[\w\$_~\xa1-\uffff]/,hooks:{"#":s,"*":c,u:d,U:d,L:d,R:d,0:u,1:u,2:u,3:u,4:u,5:u,6:u,7:u,8:u,9:u,token:function(e,t,n){if("variable"==n&&"("==e.peek()&&(";"==t.prevToken||null==t.prevToken||"}"==t.prevToken)&&f(e.current()))return"def"}},namespaceSeparator:"::",modeProps:{fold:["brace","include"]}}),h("text/x-java",{name:"clike",keywords:i("abstract assert break case catch class const continue default do else enum extends final finally float for goto if implements import instanceof interface native new package private protected public return static strictfp super switch synchronized this throw throws transient try volatile while @interface"),types:i("byte short int long float double boolean char void Boolean Byte Character Double Float Integer Long Number Object Short String StringBuffer StringBuilder Void"),blockKeywords:i("catch class do else finally for if switch try while"),defKeywords:i("class interface package enum @interface"),typeFirstDefinitions:!0,atoms:i("true false null"),number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,hooks:{"@":function(e){return!e.match("interface",!1)&&(e.eatWhile(/[\w\$_]/),"meta")}},modeProps:{fold:["brace","import"]}}),h("text/x-csharp",{name:"clike",keywords:i("abstract as async await base break case catch checked class const continue default delegate do else enum event explicit extern finally fixed for foreach goto if implicit in interface internal is lock namespace new operator out override params private protected public readonly ref return sealed sizeof stackalloc static struct switch this throw try typeof unchecked unsafe using virtual void volatile while add alias ascending descending dynamic from get global group into join let orderby partial remove select set value var yield"),types:i("Action Boolean Byte Char DateTime DateTimeOffset Decimal Double Func Guid Int16 Int32 Int64 Object SByte Single String Task TimeSpan UInt16 UInt32 UInt64 bool byte char decimal double short int long object sbyte float string ushort uint ulong"),blockKeywords:i("catch class do else finally for foreach if struct switch try while"),defKeywords:i("class interface namespace struct var"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"@":function(e,t){return e.eat('"')?(t.tokenize=p,p(e,t)):(e.eatWhile(/[\w\$_]/),"meta")}}}),h("text/x-scala",{name:"clike",keywords:i("abstract case catch class def do else extends final finally for forSome if implicit import lazy match new null object override package private protected return sealed super this throw trait try type val var while with yield _ assert assume require print println printf readLine readBoolean readByte readShort readChar readInt readLong readFloat readDouble"),types:i("AnyVal App Application Array BufferedIterator BigDecimal BigInt Char Console Either Enumeration Equiv Error Exception Fractional Function IndexedSeq Int Integral Iterable Iterator List Map Numeric Nil NotNull Option Ordered Ordering PartialFunction PartialOrdering Product Proxy Range Responder Seq Serializable Set Specializable Stream StringBuilder StringContext Symbol Throwable Traversable TraversableOnce Tuple Unit Vector Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),multiLineStrings:!0,blockKeywords:i("catch class enum do else finally for forSome if match switch try while"),defKeywords:i("class enum def object package trait type val var"),atoms:i("true false null"),indentStatements:!1,indentSwitch:!1,isOperatorChar:/[+\-*&%=<>!?|\/#:@]/,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return!!e.match('""')&&(t.tokenize=g,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},"=":function(e,n){var r=n.context;return!("}"!=r.type||!r.align||!e.eat(">"))&&(n.context=new t(r.indented,r.column,r.type,r.info,null,r.prev),"operator")}},modeProps:{closeBrackets:{triples:'"'}}}),h("text/x-kotlin",{name:"clike",keywords:i("package as typealias class interface this super val var fun for is in This throw return break continue object if else while do try when !in !is as? file import where by get set abstract enum open inner override private public internal protected catch finally out final vararg reified dynamic companion constructor init sealed field property receiver param sparam lateinit data inline noinline tailrec external annotation crossinline const operator infix suspend"),types:i("Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),intendSwitch:!1,indentStatements:!1,multiLineStrings:!0,number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,blockKeywords:i("catch class do else finally for if where try while enum"),defKeywords:i("class val var object package interface fun"),atoms:i("true false null this"),hooks:{'"':function(e,t){return t.tokenize=y(e.match('""')),t.tokenize(e,t)}},modeProps:{closeBrackets:{triples:'"'}}}),h(["x-shader/x-vertex","x-shader/x-fragment"],{name:"clike",keywords:i("sampler1D sampler2D sampler3D samplerCube sampler1DShadow sampler2DShadow const attribute uniform varying break continue discard return for while do if else struct in out inout"),types:i("float int bool void vec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4 mat2 mat3 mat4"),blockKeywords:i("for while do if else struct"),builtin:i("radians degrees sin cos tan asin acos atan pow exp log exp2 sqrt inversesqrt abs sign floor ceil fract mod min max clamp mix step smoothstep length distance dot cross normalize ftransform faceforward reflect refract matrixCompMult lessThan lessThanEqual greaterThan greaterThanEqual equal notEqual any all not texture1D texture1DProj texture1DLod texture1DProjLod texture2D texture2DProj texture2DLod texture2DProjLod texture3D texture3DProj texture3DLod texture3DProjLod textureCube textureCubeLod shadow1D shadow2D shadow1DProj shadow2DProj shadow1DLod shadow2DLod shadow1DProjLod shadow2DProjLod dFdx dFdy fwidth noise1 noise2 noise3 noise4"),atoms:i("true false gl_FragColor gl_SecondaryColor gl_Normal gl_Vertex gl_MultiTexCoord0 gl_MultiTexCoord1 gl_MultiTexCoord2 gl_MultiTexCoord3 gl_MultiTexCoord4 gl_MultiTexCoord5 gl_MultiTexCoord6 gl_MultiTexCoord7 gl_FogCoord gl_PointCoord gl_Position gl_PointSize gl_ClipVertex gl_FrontColor gl_BackColor gl_FrontSecondaryColor gl_BackSecondaryColor gl_TexCoord gl_FogFragCoord gl_FragCoord gl_FrontFacing gl_FragData gl_FragDepth gl_ModelViewMatrix gl_ProjectionMatrix gl_ModelViewProjectionMatrix gl_TextureMatrix gl_NormalMatrix gl_ModelViewMatrixInverse gl_ProjectionMatrixInverse gl_ModelViewProjectionMatrixInverse gl_TexureMatrixTranspose gl_ModelViewMatrixInverseTranspose gl_ProjectionMatrixInverseTranspose gl_ModelViewProjectionMatrixInverseTranspose gl_TextureMatrixInverseTranspose gl_NormalScale gl_DepthRange gl_ClipPlane gl_Point gl_FrontMaterial gl_BackMaterial gl_LightSource gl_LightModel gl_FrontLightModelProduct gl_BackLightModelProduct gl_TextureColor gl_EyePlaneS gl_EyePlaneT gl_EyePlaneR gl_EyePlaneQ gl_FogParameters gl_MaxLights gl_MaxClipPlanes gl_MaxTextureUnits gl_MaxTextureCoords gl_MaxVertexAttribs gl_MaxVertexUniformComponents gl_MaxVaryingFloats gl_MaxVertexTextureImageUnits gl_MaxTextureImageUnits gl_MaxFragmentUniformComponents gl_MaxCombineTextureImageUnits gl_MaxDrawBuffers"),indentSwitch:!1,hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-nesc",{name:"clike",keywords:i(b+"as atomic async call command component components configuration event generic implementation includes interface module new norace nx_struct nx_union post provides signal task uses abstract extends"),types:i(k),blockKeywords:i("case do else for if switch while struct"),atoms:i("null true false"),hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-objectivec",{name:"clike",keywords:i(b+"inline restrict _Bool _Complex _Imaginary BOOL Class bycopy byref id IMP in inout nil oneway out Protocol SEL self super atomic nonatomic retain copy readwrite readonly"),types:i(k),atoms:i("YES NO NULL NILL ON OFF true false"),hooks:{"@":function(e){return e.eatWhile(/[\w\$]/),"keyword"},"#":s,indent:function(e,t,n){if("statement"==t.type&&/^@\w/.test(n))return t.indented}},modeProps:{fold:"brace"}}),h("text/x-squirrel",{name:"clike",keywords:i("base break clone continue const default delete enum extends function in class foreach local resume return this throw typeof yield constructor instanceof static"),types:i(k),blockKeywords:i("case catch class else for foreach if switch try while"),defKeywords:i("function local class"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"#":s},modeProps:{fold:["brace","include"]}});var w=null;h("text/x-ceylon",{name:"clike",keywords:i("abstracts alias assembly assert assign break case catch class continue dynamic else exists extends finally for function given if import in interface is let module new nonempty object of out outer package return satisfies super switch then this throw try value void while"),types:function(e){var t=e.charAt(0);return t===t.toUpperCase()&&t!==t.toLowerCase()},blockKeywords:i("case catch class dynamic else finally for function if interface module new object switch try while"),defKeywords:i("class dynamic function interface module object package value"),builtin:i("abstract actual aliased annotation by default deprecated doc final formal late license native optional sealed see serializable shared suppressWarnings tagged throws variable"),isPunctuationChar:/[\[\]{}\(\),;\:\.`]/,isOperatorChar:/[+\-*&%=<>!?|^~:\/]/,numberStart:/[\d#$]/,number:/^(?:#[\da-fA-F_]+|\$[01_]+|[\d_]+[kMGTPmunpf]?|[\d_]+\.[\d_]+(?:[eE][-+]?\d+|[kMGTPmunpf]|)|)/i,multiLineStrings:!0,typeFirstDefinitions:!0,atoms:i("true false null larger smaller equal empty finished"),indentSwitch:!1,styleDefs:!1,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return t.tokenize=x(e.match('""')?"triple":"single"),t.tokenize(e,t)},"`":function(e,t){return!(!w||!e.match("`"))&&(t.tokenize=w,w=null,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},token:function(e,t,n){if(("variable"==n||"type"==n)&&"."==t.prevToken)return"variable-2"}},modeProps:{fold:["brace","import"],closeBrackets:{triples:'"'}}})});
      // -------------------------------------------------------------------------
//  Part of the CodeChecker project, under the Apache License v2.0 with
//  LLVM Exceptions. See LICENSE for license information.
//  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
// -------------------------------------------------------------------------

var BugViewer = {
  _files : [],
  _reports : [],
  _lineWidgets : [],
  _navigationMenuItems : [],
  _sourceFileData : null,
  _currentReport : null,
  _lastBugEvent  : null,

  init : function (files, reports) {
    this._files = files;
    this._reports = reports;

    this.initEscapeChars();
  },

  initEscapeChars : function () {
    this.escapeChars = {
      ' ' : 'nbsp',
      '<' : 'lt',
      '>' : 'gt',
      '"' : 'quot',
      '&' : 'amp'
    };

    var regexString = '[';
    for (var key in this.escapeChars) {
      regexString += key;
    }
    regexString += ']';

    this.escapeRegExp = new RegExp( regexString, 'g');
  },

  escapeHTML : function (str) {
    var that = this;

    return str.replace(this.escapeRegExp, function (m) {
      return '&' + that.escapeChars[m] + ';';
    });
  },

  initByUrl : function () {
    if (!this._reports) return;

    var state = {};
    window.location.hash.substr(1).split('&').forEach(function (s) {
      var parts = s.split('=');
      state[parts[0]] = parts[1];
    });

    for (var key in this._reports) {
      var report = this._reports[key];
      if (report.reportHash === state['reportHash']) {
        this.navigate(report);
        return;
      }
    }

    this.navigate(this._reports[0]);
  },

  create : function () {
    this._content = document.getElementById('editor-wrapper');
    this._filepath = document.getElementById('file-path');
    this._checkerName = document.getElementById('checker-name');
    this._reviewStatusWrapper =
      document.getElementById('review-status-wrapper');
    this._reviewStatus = document.getElementById('review-status');
    this._editor = document.getElementById('editor');

    this._codeMirror = CodeMirror(this._editor, {
      mode: 'text/x-c++src',
      matchBrackets : true,
      lineNumbers : true,
      readOnly : true,
      foldGutter : true,
      extraKeys : {},
      viewportMargin : 100
    });

    this._createNavigationMenu();
  },

  navigate : function (report, item) {
    if (!item) {
      var items = this._navigationMenuItems.filter(function (navItem) {
        return navItem.report.reportHash === report.reportHash;
      });

      if (!items.length) return;

      item = items[0].widget;
    }

    this._selectedReport.classList.remove('active');
    this._selectedReport = item;
    this._selectedReport.classList.add('active');
    this.setReport(report);
  },

  _createNavigationMenu : function () {
    var that = this;

    var nav = document.getElementById('report-nav');
    var list = document.createElement('ul');
    this._reports.forEach(function (report) {
      var events = report['events'];
      var lastBugEvent = events[events.length - 1];
      var item = document.createElement('li');

      var severity = document.createElement('i');
      severity.className = 'severity-' + report.severity.toLowerCase();

      item.appendChild(severity);
      item.appendChild(document.createTextNode(lastBugEvent.message));

      item.addEventListener('click', function () {
        that.navigate(report, item);
      })
      list.appendChild(item);
      that._navigationMenuItems.push({ report : report, widget : item });
    });

    if (!this._selectedReport && list.childNodes.length) {
      this._selectedReport = list.childNodes[0];
      this._selectedReport.classList.add('active');
    }

    nav.appendChild(list);
  },

  setReport : function (report) {
    this._currentReport = report;
    var events = report['events'];
    var lastBugEvent = events[events.length - 1];
    this.setCurrentBugEvent(lastBugEvent, events.length - 1);
    this.setCheckerName(report.checkerName);
    this.setReviewStatus(report.reviewStatus);

    window.location.hash = '#reportHash=' + report.reportHash;
  },

  setCurrentBugEvent : function (event, idx) {
    this._currentBugEvent = event;
    this.setSourceFileData(this._files[event.location.file]);
    this.drawBugPath();

    this.jumpTo(event.location.line, 0);
    this.highlightBugEvent(event, idx);
  },

  highlightBugEvent : function (event, idx) {
    this._lineWidgets.forEach(function (widget) {
      var lineIdx = widget.node.getAttribute('idx');
      if (parseInt(lineIdx) === idx) {
        widget.node.classList.add('current');
      }
    });
  },

  setCheckerName : function (checkerName) {
    this._checkerName.innerHTML = checkerName;
  },

  setReviewStatus : function (status) {
    if (status) {
      var className =
        'review-status-' + status.toLowerCase().split(' ').join('-');
      this._reviewStatus.className = "review-status " + className;

      this._reviewStatus.innerHTML = status;
      this._reviewStatusWrapper.style.display = 'block';
    } else {
      this._reviewStatusWrapper.style.display = 'none';
    }
  },

  setSourceFileData : function (file) {
    if (this._sourceFileData && file.id === this._sourceFileData.id) {
      return;
    }

    this._sourceFileData = file;
    this._filepath.innerHTML = file.path;
    this._codeMirror.doc.setValue(file.content);
    this._refresh();
  },

  _refresh : function () {
    var that = this;
    setTimeout(function () {
      var fullHeight = parseInt(that._content.clientHeight);
      var headerHeight = that._filepath.clientHeight;

      that._codeMirror.setSize('auto', fullHeight - headerHeight);
      that._codeMirror.refresh();
    }, 200);
  },

  clearBubbles : function () {
    this._lineWidgets.forEach(function (widget) { widget.clear(); });
    this._lineWidgets = [];
  },

  getMessage : function (event, kind) {
    if (kind === 'macro') {
      var name = 'macro expansion' + (event.name ? ': ' + event.name : '');

      return '<span class="tag macro">' + name + '</span>'
        + this.escapeHTML(event.expansion).replace(/(?:\r\n|\r|\n)/g, '<br>');
    } else if (kind === 'note') {
      return '<span class="tag note">note</span>'
        +  this.escapeHTML(event.message).replace(/(?:\r\n|\r|\n)/g, '<br>');
    }
  },

  addExtraPathEvents : function (events, kind) {
    var that = this;

    if (!events) {
      return;
    }

    events.forEach(function (event) {
      if (event.location.file !== that._currentBugEvent.location.file) {
        return;
      }

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + kind);

      var msg = document.createElement('span');
      msg.innerHTML = that.getMessage(event, kind);
      element.appendChild(msg);

      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  drawBugPath : function () {
    var that = this;

    this.clearBubbles();

    this.addExtraPathEvents(this._currentReport.macros, 'macro');
    this.addExtraPathEvents(this._currentReport.notes, 'note');

    // Processing bug path events.
    var currentEvents = this._currentReport.events;
    currentEvents.forEach(function (event, step) {
      if (event.location.file !== that._currentBugEvent.location.file)
        return;

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';
      var type = step === currentEvents.length - 1 ? 'error' : 'info';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + type);
      element.setAttribute('idx', step);

      var enumeration = document.createElement('span');
      enumeration.setAttribute('class', 'checker-enum ' + type);
      enumeration.innerHTML = step + 1;

      if (currentEvents.length > 1)
        element.appendChild(enumeration);

      var prevBugEvent = step - 1;
      if (step > 0) {
        var prevBug = document.createElement('span');
        prevBug.setAttribute('class', 'arrow left-arrow');
        prevBug.addEventListener('click', function () {
          var event = currentEvents[prevBugEvent];
          that.setCurrentBugEvent(event, prevBugEvent);
        });
        element.appendChild(prevBug);
      }

      var msg = document.createElement('span');
      msg.innerHTML = that.escapeHTML(event.message)
        .replace(/(?:\r\n|\r|\n)/g, '<br>');

      element.appendChild(msg);

      var nextBugEvent = step + 1;
      if (nextBugEvent < currentEvents.length) {
        var nextBug = document.createElement('span');
        nextBug.setAttribute('class', 'arrow right-arrow');
        nextBug.addEventListener('click', function () {
          var event = currentEvents[nextBugEvent];
          that.setCurrentBugEvent(event, nextBugEvent);
        });
        element.appendChild(nextBug);
      }


      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  jumpTo : function (line, column) {
    var that = this;

    setTimeout(function () {
      var selPosPixel
        = that._codeMirror.charCoords({ line : line, ch : column }, 'local');
      var editorSize = {
        width  : that._editor.clientWidth,
        height : that._editor.clientHeight
      };

      that._codeMirror.scrollIntoView({
        top    : selPosPixel.top - 100,
        bottom : selPosPixel.top + editorSize.height - 150,
        left   : selPosPixel.left < editorSize.width - 100
               ? 0
               : selPosPixel.left - 50,
        right  : selPosPixel.left < editorSize.width - 100
               ? 10
               : selPosPixel.left + editorSize.width - 100
      });
    }, 0);
  }
}


      var data = {"files": {"19": {"id": 19, "path": "/home/vsts/work/1/llvm-project/compiler-rt/lib/tsan/rtl/tsan_interceptors_posix.cpp", "content": "//===-- tsan_interceptors_posix.cpp ---------------------------------------===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file is a part of ThreadSanitizer (TSan), a race detector.\n//\n// FIXME: move as many interceptors as possible into\n// sanitizer_common/sanitizer_common_interceptors.inc\n//===----------------------------------------------------------------------===//\n\n#include \"sanitizer_common/sanitizer_atomic.h\"\n#include \"sanitizer_common/sanitizer_errno.h\"\n#include \"sanitizer_common/sanitizer_libc.h\"\n#include \"sanitizer_common/sanitizer_linux.h\"\n#include \"sanitizer_common/sanitizer_platform_limits_netbsd.h\"\n#include \"sanitizer_common/sanitizer_platform_limits_posix.h\"\n#include \"sanitizer_common/sanitizer_placement_new.h\"\n#include \"sanitizer_common/sanitizer_posix.h\"\n#include \"sanitizer_common/sanitizer_stacktrace.h\"\n#include \"sanitizer_common/sanitizer_tls_get_addr.h\"\n#include \"interception/interception.h\"\n#include \"tsan_interceptors.h\"\n#include \"tsan_interface.h\"\n#include \"tsan_platform.h\"\n#include \"tsan_suppressions.h\"\n#include \"tsan_rtl.h\"\n#include \"tsan_mman.h\"\n#include \"tsan_fd.h\"\n\n#include <stdarg.h>\n\nusing namespace __tsan;\n\n#if SANITIZER_FREEBSD || SANITIZER_MAC\n#define stdout __stdoutp\n#define stderr __stderrp\n#endif\n\n#if SANITIZER_NETBSD\n#define dirfd(dirp) (*(int *)(dirp))\n#define fileno_unlocked(fp)              \\\n  (((__sanitizer_FILE *)fp)->_file == -1 \\\n       ? -1                              \\\n       : (int)(unsigned short)(((__sanitizer_FILE *)fp)->_file))\n\n#define stdout ((__sanitizer_FILE*)&__sF[1])\n#define stderr ((__sanitizer_FILE*)&__sF[2])\n\n#define nanosleep __nanosleep50\n#define vfork __vfork14\n#endif\n\n#ifdef __mips__\nconst int kSigCount = 129;\n#else\nconst int kSigCount = 65;\n#endif\n\n#ifdef __mips__\nstruct ucontext_t {\n  u64 opaque[768 / sizeof(u64) + 1];\n};\n#else\nstruct ucontext_t {\n  // The size is determined by looking at sizeof of real ucontext_t on linux.\n  u64 opaque[936 / sizeof(u64) + 1];\n};\n#endif\n\n#if defined(__x86_64__) || defined(__mips__) || SANITIZER_PPC64V1\n#define PTHREAD_ABI_BASE  \"GLIBC_2.3.2\"\n#elif defined(__aarch64__) || SANITIZER_PPC64V2\n#define PTHREAD_ABI_BASE  \"GLIBC_2.17\"\n#endif\n\nextern \"C\" int pthread_attr_init(void *attr);\nextern \"C\" int pthread_attr_destroy(void *attr);\nDECLARE_REAL(int, pthread_attr_getdetachstate, void *, void *)\nextern \"C\" int pthread_attr_setstacksize(void *attr, uptr stacksize);\nextern \"C\" int pthread_key_create(unsigned *key, void (*destructor)(void* v));\nextern \"C\" int pthread_setspecific(unsigned key, const void *v);\nDECLARE_REAL(int, pthread_mutexattr_gettype, void *, void *)\nDECLARE_REAL(int, fflush, __sanitizer_FILE *fp)\nDECLARE_REAL_AND_INTERCEPTOR(void *, malloc, uptr size)\nDECLARE_REAL_AND_INTERCEPTOR(void, free, void *ptr)\nextern \"C\" void *pthread_self();\nextern \"C\" void _exit(int status);\n#if !SANITIZER_NETBSD\nextern \"C\" int fileno_unlocked(void *stream);\nextern \"C\" int dirfd(void *dirp);\n#endif\n#if SANITIZER_GLIBC\nextern \"C\" int mallopt(int param, int value);\n#endif\n#if SANITIZER_NETBSD\nextern __sanitizer_FILE __sF[];\n#else\nextern __sanitizer_FILE *stdout, *stderr;\n#endif\n#if !SANITIZER_FREEBSD && !SANITIZER_MAC && !SANITIZER_NETBSD\nconst int PTHREAD_MUTEX_RECURSIVE = 1;\nconst int PTHREAD_MUTEX_RECURSIVE_NP = 1;\n#else\nconst int PTHREAD_MUTEX_RECURSIVE = 2;\nconst int PTHREAD_MUTEX_RECURSIVE_NP = 2;\n#endif\n#if !SANITIZER_FREEBSD && !SANITIZER_MAC && !SANITIZER_NETBSD\nconst int EPOLL_CTL_ADD = 1;\n#endif\nconst int SIGILL = 4;\nconst int SIGTRAP = 5;\nconst int SIGABRT = 6;\nconst int SIGFPE = 8;\nconst int SIGSEGV = 11;\nconst int SIGPIPE = 13;\nconst int SIGTERM = 15;\n#if defined(__mips__) || SANITIZER_FREEBSD || SANITIZER_MAC || SANITIZER_NETBSD\nconst int SIGBUS = 10;\nconst int SIGSYS = 12;\n#else\nconst int SIGBUS = 7;\nconst int SIGSYS = 31;\n#endif\nvoid *const MAP_FAILED = (void*)-1;\n#if SANITIZER_NETBSD\nconst int PTHREAD_BARRIER_SERIAL_THREAD = 1234567;\n#elif !SANITIZER_MAC\nconst int PTHREAD_BARRIER_SERIAL_THREAD = -1;\n#endif\nconst int MAP_FIXED = 0x10;\ntypedef long long_t;\ntypedef __sanitizer::u16 mode_t;\n\n// From /usr/include/unistd.h\n# define F_ULOCK 0      /* Unlock a previously locked region.  */\n# define F_LOCK  1      /* Lock a region for exclusive use.  */\n# define F_TLOCK 2      /* Test and lock a region for exclusive use.  */\n# define F_TEST  3      /* Test a region for other processes locks.  */\n\n#if SANITIZER_FREEBSD || SANITIZER_MAC || SANITIZER_NETBSD\nconst int SA_SIGINFO = 0x40;\nconst int SIG_SETMASK = 3;\n#elif defined(__mips__)\nconst int SA_SIGINFO = 8;\nconst int SIG_SETMASK = 3;\n#else\nconst int SA_SIGINFO = 4;\nconst int SIG_SETMASK = 2;\n#endif\n\n#define COMMON_INTERCEPTOR_NOTHING_IS_INITIALIZED \\\n  (cur_thread_init(), !cur_thread()->is_inited)\n\nnamespace __tsan {\nstruct SignalDesc {\n  bool armed;\n  bool sigaction;\n  __sanitizer_siginfo siginfo;\n  ucontext_t ctx;\n};\n\nstruct ThreadSignalContext {\n  int int_signal_send;\n  atomic_uintptr_t in_blocking_func;\n  atomic_uintptr_t have_pending_signals;\n  SignalDesc pending_signals[kSigCount];\n  // emptyset and oldset are too big for stack.\n  __sanitizer_sigset_t emptyset;\n  __sanitizer_sigset_t oldset;\n};\n\n// The sole reason tsan wraps atexit callbacks is to establish synchronization\n// between callback setup and callback execution.\nstruct AtExitCtx {\n  void (*f)();\n  void *arg;\n};\n\n// InterceptorContext holds all global data required for interceptors.\n// It's explicitly constructed in InitializeInterceptors with placement new\n// and is never destroyed. This allows usage of members with non-trivial\n// constructors and destructors.\nstruct InterceptorContext {\n  // The object is 64-byte aligned, because we want hot data to be located\n  // in a single cache line if possible (it's accessed in every interceptor).\n  ALIGNED(64) LibIgnore libignore;\n  __sanitizer_sigaction sigactions[kSigCount];\n#if !SANITIZER_MAC && !SANITIZER_NETBSD\n  unsigned finalize_key;\n#endif\n\n  BlockingMutex atexit_mu;\n  Vector<struct AtExitCtx *> AtExitStack;\n\n  InterceptorContext()\n      : libignore(LINKER_INITIALIZED), AtExitStack() {\n  }\n};\n\nstatic ALIGNED(64) char interceptor_placeholder[sizeof(InterceptorContext)];\nInterceptorContext *interceptor_ctx() {\n  return reinterpret_cast<InterceptorContext*>(&interceptor_placeholder[0]);\n}\n\nLibIgnore *libignore() {\n  return &interceptor_ctx()->libignore;\n}\n\nvoid InitializeLibIgnore() {\n  const SuppressionContext &supp = *Suppressions();\n  const uptr n = supp.SuppressionCount();\n  for (uptr i = 0; i < n; i++) {\n    const Suppression *s = supp.SuppressionAt(i);\n    if (0 == internal_strcmp(s->type, kSuppressionLib))\n      libignore()->AddIgnoredLibrary(s->templ);\n  }\n  if (flags()->ignore_noninstrumented_modules)\n    libignore()->IgnoreNoninstrumentedModules(true);\n  libignore()->OnLibraryLoaded(0);\n}\n\n// The following two hooks can be used by for cooperative scheduling when\n// locking.\n#ifdef TSAN_EXTERNAL_HOOKS\nvoid OnPotentiallyBlockingRegionBegin();\nvoid OnPotentiallyBlockingRegionEnd();\n#else\nSANITIZER_WEAK_CXX_DEFAULT_IMPL void OnPotentiallyBlockingRegionBegin() {}\nSANITIZER_WEAK_CXX_DEFAULT_IMPL void OnPotentiallyBlockingRegionEnd() {}\n#endif\n\n}  // namespace __tsan\n\nstatic ThreadSignalContext *SigCtx(ThreadState *thr) {\n  ThreadSignalContext *ctx = (ThreadSignalContext*)thr->signal_ctx;\n  if (ctx == 0 && !thr->is_dead) {\n    ctx = (ThreadSignalContext*)MmapOrDie(sizeof(*ctx), \"ThreadSignalContext\");\n    MemoryResetRange(thr, (uptr)&SigCtx, (uptr)ctx, sizeof(*ctx));\n    thr->signal_ctx = ctx;\n  }\n  return ctx;\n}\n\nScopedInterceptor::ScopedInterceptor(ThreadState *thr, const char *fname,\n                                     uptr pc)\n    : thr_(thr), pc_(pc), in_ignored_lib_(false), ignoring_(false) {\n  Initialize(thr);\n  if (!thr_->is_inited) return;\n  if (!thr_->ignore_interceptors) FuncEntry(thr, pc);\n  DPrintf(\"#%d: intercept %s()\\n\", thr_->tid, fname);\n  ignoring_ =\n      !thr_->in_ignored_lib && (flags()->ignore_interceptors_accesses ||\n                                libignore()->IsIgnored(pc, &in_ignored_lib_));\n  EnableIgnores();\n}\n\nScopedInterceptor::~ScopedInterceptor() {\n  if (!thr_->is_inited) return;\n  DisableIgnores();\n  if (!thr_->ignore_interceptors) {\n    ProcessPendingSignals(thr_);\n    FuncExit(thr_);\n    CheckNoLocks(thr_);\n  }\n}\n\nvoid ScopedInterceptor::EnableIgnores() {\n  if (ignoring_) {\n    ThreadIgnoreBegin(thr_, pc_, /*save_stack=*/false);\n    if (flags()->ignore_noninstrumented_modules) thr_->suppress_reports++;\n    if (in_ignored_lib_) {\n      DCHECK(!thr_->in_ignored_lib);\n      thr_->in_ignored_lib = true;\n    }\n  }\n}\n\nvoid ScopedInterceptor::DisableIgnores() {\n  if (ignoring_) {\n    ThreadIgnoreEnd(thr_, pc_);\n    if (flags()->ignore_noninstrumented_modules) thr_->suppress_reports--;\n    if (in_ignored_lib_) {\n      DCHECK(thr_->in_ignored_lib);\n      thr_->in_ignored_lib = false;\n    }\n  }\n}\n\n#define TSAN_INTERCEPT(func) INTERCEPT_FUNCTION(func)\n#if SANITIZER_FREEBSD\n# define TSAN_INTERCEPT_VER(func, ver) INTERCEPT_FUNCTION(func)\n# define TSAN_MAYBE_INTERCEPT_NETBSD_ALIAS(func)\n# define TSAN_MAYBE_INTERCEPT_NETBSD_ALIAS_THR(func)\n#elif SANITIZER_NETBSD\n# define TSAN_INTERCEPT_VER(func, ver) INTERCEPT_FUNCTION(func)\n# define TSAN_MAYBE_INTERCEPT_NETBSD_ALIAS(func) \\\n         INTERCEPT_FUNCTION(__libc_##func)\n# define TSAN_MAYBE_INTERCEPT_NETBSD_ALIAS_THR(func) \\\n         INTERCEPT_FUNCTION(__libc_thr_##func)\n#else\n# define TSAN_INTERCEPT_VER(func, ver) INTERCEPT_FUNCTION_VER(func, ver)\n# define TSAN_MAYBE_INTERCEPT_NETBSD_ALIAS(func)\n# define TSAN_MAYBE_INTERCEPT_NETBSD_ALIAS_THR(func)\n#endif\n\n#define READ_STRING_OF_LEN(thr, pc, s, len, n)                 \\\n  MemoryAccessRange((thr), (pc), (uptr)(s),                         \\\n    common_flags()->strict_string_checks ? (len) + 1 : (n), false)\n\n#define READ_STRING(thr, pc, s, n)                             \\\n    READ_STRING_OF_LEN((thr), (pc), (s), internal_strlen(s), (n))\n\n#define BLOCK_REAL(name) (BlockingCall(thr), REAL(name))\n\nstruct BlockingCall {\n  explicit BlockingCall(ThreadState *thr)\n      : thr(thr)\n      , ctx(SigCtx(thr)) {\n    for (;;) {\n      atomic_store(&ctx->in_blocking_func, 1, memory_order_relaxed);\n      if (atomic_load(&ctx->have_pending_signals, memory_order_relaxed) == 0)\n        break;\n      atomic_store(&ctx->in_blocking_func, 0, memory_order_relaxed);\n      ProcessPendingSignals(thr);\n    }\n    // When we are in a \"blocking call\", we process signals asynchronously\n    // (right when they arrive). In this context we do not expect to be\n    // executing any user/runtime code. The known interceptor sequence when\n    // this is not true is: pthread_join -> munmap(stack). It's fine\n    // to ignore munmap in this case -- we handle stack shadow separately.\n    thr->ignore_interceptors++;\n  }\n\n  ~BlockingCall() {\n    thr->ignore_interceptors--;\n    atomic_store(&ctx->in_blocking_func, 0, memory_order_relaxed);\n  }\n\n  ThreadState *thr;\n  ThreadSignalContext *ctx;\n};\n\nTSAN_INTERCEPTOR(unsigned, sleep, unsigned sec) {\n  SCOPED_TSAN_INTERCEPTOR(sleep, sec);\n  unsigned res = BLOCK_REAL(sleep)(sec);\n  AfterSleep(thr, pc);\n  return res;\n}\n\nTSAN_INTERCEPTOR(int, usleep, long_t usec) {\n  SCOPED_TSAN_INTERCEPTOR(usleep, usec);\n  int res = BLOCK_REAL(usleep)(usec);\n  AfterSleep(thr, pc);\n  return res;\n}\n\nTSAN_INTERCEPTOR(int, nanosleep, void *req, void *rem) {\n  SCOPED_TSAN_INTERCEPTOR(nanosleep, req, rem);\n  int res = BLOCK_REAL(nanosleep)(req, rem);\n  AfterSleep(thr, pc);\n  return res;\n}\n\nTSAN_INTERCEPTOR(int, pause, int fake) {\n  SCOPED_TSAN_INTERCEPTOR(pause, fake);\n  return BLOCK_REAL(pause)(fake);\n}\n\nstatic void at_exit_wrapper() {\n  AtExitCtx *ctx;\n  {\n    // Ensure thread-safety.\n    BlockingMutexLock l(&interceptor_ctx()->atexit_mu);\n\n    // Pop AtExitCtx from the top of the stack of callback functions\n    uptr element = interceptor_ctx()->AtExitStack.Size() - 1;\n    ctx = interceptor_ctx()->AtExitStack[element];\n    interceptor_ctx()->AtExitStack.PopBack();\n  }\n\n  Acquire(cur_thread(), (uptr)0, (uptr)ctx);\n  ((void(*)())ctx->f)();\n  InternalFree(ctx);\n}\n\nstatic void cxa_at_exit_wrapper(void *arg) {\n  Acquire(cur_thread(), 0, (uptr)arg);\n  AtExitCtx *ctx = (AtExitCtx*)arg;\n  ((void(*)(void *arg))ctx->f)(ctx->arg);\n  InternalFree(ctx);\n}\n\nstatic int setup_at_exit_wrapper(ThreadState *thr, uptr pc, void(*f)(),\n      void *arg, void *dso);\n\n#if !SANITIZER_ANDROID\nTSAN_INTERCEPTOR(int, atexit, void (*f)()) {\n  if (in_symbolizer())\n    return 0;\n  // We want to setup the atexit callback even if we are in ignored lib\n  // or after fork.\n  SCOPED_INTERCEPTOR_RAW(atexit, f);\n  return setup_at_exit_wrapper(thr, pc, (void(*)())f, 0, 0);\n}\n#endif\n\nTSAN_INTERCEPTOR(int, __cxa_atexit, void (*f)(void *a), void *arg, void *dso) {\n  if (in_symbolizer())\n    return 0;\n  SCOPED_TSAN_INTERCEPTOR(__cxa_atexit, f, arg, dso);\n  return setup_at_exit_wrapper(thr, pc, (void(*)())f, arg, dso);\n}\n\nstatic int setup_at_exit_wrapper(ThreadState *thr, uptr pc, void(*f)(),\n      void *arg, void *dso) {\n  AtExitCtx *ctx = (AtExitCtx*)InternalAlloc(sizeof(AtExitCtx));\n  ctx->f = f;\n  ctx->arg = arg;\n  Release(thr, pc, (uptr)ctx);\n  // Memory allocation in __cxa_atexit will race with free during exit,\n  // because we do not see synchronization around atexit callback list.\n  ThreadIgnoreBegin(thr, pc);\n  int res;\n  if (!dso) {\n    // NetBSD does not preserve the 2nd argument if dso is equal to 0\n    // Store ctx in a local stack-like structure\n\n    // Ensure thread-safety.\n    BlockingMutexLock l(&interceptor_ctx()->atexit_mu);\n\n    res = REAL(__cxa_atexit)((void (*)(void *a))at_exit_wrapper, 0, 0);\n    // Push AtExitCtx on the top of the stack of callback functions\n    if (!res) {\n      interceptor_ctx()->AtExitStack.PushBack(ctx);\n    }\n  } else {\n    res = REAL(__cxa_atexit)(cxa_at_exit_wrapper, ctx, dso);\n  }\n  ThreadIgnoreEnd(thr, pc);\n  return res;\n}\n\n#if !SANITIZER_MAC && !SANITIZER_NETBSD\nstatic void on_exit_wrapper(int status, void *arg) {\n  ThreadState *thr = cur_thread();\n  uptr pc = 0;\n  Acquire(thr, pc, (uptr)arg);\n  AtExitCtx *ctx = (AtExitCtx*)arg;\n  ((void(*)(int status, void *arg))ctx->f)(status, ctx->arg);\n  InternalFree(ctx);\n}\n\nTSAN_INTERCEPTOR(int, on_exit, void(*f)(int, void*), void *arg) {\n  if (in_symbolizer())\n    return 0;\n  SCOPED_TSAN_INTERCEPTOR(on_exit, f, arg);\n  AtExitCtx *ctx = (AtExitCtx*)InternalAlloc(sizeof(AtExitCtx));\n  ctx->f = (void(*)())f;\n  ctx->arg = arg;\n  Release(thr, pc, (uptr)ctx);\n  // Memory allocation in __cxa_atexit will race with free during exit,\n  // because we do not see synchronization around atexit callback list.\n  ThreadIgnoreBegin(thr, pc);\n  int res = REAL(on_exit)(on_exit_wrapper, ctx);\n  ThreadIgnoreEnd(thr, pc);\n  return res;\n}\n#define TSAN_MAYBE_INTERCEPT_ON_EXIT TSAN_INTERCEPT(on_exit)\n#else\n#define TSAN_MAYBE_INTERCEPT_ON_EXIT\n#endif\n\n// Cleanup old bufs.\nstatic void JmpBufGarbageCollect(ThreadState *thr, uptr sp) {\n  for (uptr i = 0; i < thr->jmp_bufs.Size(); i++) {\n    JmpBuf *buf = &thr->jmp_bufs[i];\n    if (buf->sp <= sp) {\n      uptr sz = thr->jmp_bufs.Size();\n      internal_memcpy(buf, &thr->jmp_bufs[sz - 1], sizeof(*buf));\n      thr->jmp_bufs.PopBack();\n      i--;\n    }\n  }\n}\n\nstatic void SetJmp(ThreadState *thr, uptr sp) {\n  if (!thr->is_inited)  // called from libc guts during bootstrap\n    return;\n  // Cleanup old bufs.\n  JmpBufGarbageCollect(thr, sp);\n  // Remember the buf.\n  JmpBuf *buf = thr->jmp_bufs.PushBack();\n  buf->sp = sp;\n  buf->shadow_stack_pos = thr->shadow_stack_pos;\n  ThreadSignalContext *sctx = SigCtx(thr);\n  buf->int_signal_send = sctx ? sctx->int_signal_send : 0;\n  buf->in_blocking_func = sctx ?\n      atomic_load(&sctx->in_blocking_func, memory_order_relaxed) :\n      false;\n  buf->in_signal_handler = atomic_load(&thr->in_signal_handler,\n      memory_order_relaxed);\n}\n\nstatic void LongJmp(ThreadState *thr, uptr *env) {\n  uptr sp = ExtractLongJmpSp(env);\n  // Find the saved buf with matching sp.\n  for (uptr i = 0; i < thr->jmp_bufs.Size(); i++) {\n    JmpBuf *buf = &thr->jmp_bufs[i];\n    if (buf->sp == sp) {\n      CHECK_GE(thr->shadow_stack_pos, buf->shadow_stack_pos);\n      // Unwind the stack.\n      while (thr->shadow_stack_pos > buf->shadow_stack_pos)\n        FuncExit(thr);\n      ThreadSignalContext *sctx = SigCtx(thr);\n      if (sctx) {\n        sctx->int_signal_send = buf->int_signal_send;\n        atomic_store(&sctx->in_blocking_func, buf->in_blocking_func,\n            memory_order_relaxed);\n      }\n      atomic_store(&thr->in_signal_handler, buf->in_signal_handler,\n          memory_order_relaxed);\n      JmpBufGarbageCollect(thr, buf->sp - 1);  // do not collect buf->sp\n      return;\n    }\n  }\n  Printf(\"ThreadSanitizer: can't find longjmp buf\\n\");\n  CHECK(0);\n}\n\n// FIXME: put everything below into a common extern \"C\" block?\nextern \"C\" void __tsan_setjmp(uptr sp) {\n  cur_thread_init();\n  SetJmp(cur_thread(), sp);\n}\n\n#if SANITIZER_MAC\nTSAN_INTERCEPTOR(int, setjmp, void *env);\nTSAN_INTERCEPTOR(int, _setjmp, void *env);\nTSAN_INTERCEPTOR(int, sigsetjmp, void *env);\n#else  // SANITIZER_MAC\n\n#if SANITIZER_NETBSD\n#define setjmp_symname __setjmp14\n#define sigsetjmp_symname __sigsetjmp14\n#else\n#define setjmp_symname setjmp\n#define sigsetjmp_symname sigsetjmp\n#endif\n\n#define TSAN_INTERCEPTOR_SETJMP_(x) __interceptor_ ## x\n#define TSAN_INTERCEPTOR_SETJMP__(x) TSAN_INTERCEPTOR_SETJMP_(x)\n#define TSAN_INTERCEPTOR_SETJMP TSAN_INTERCEPTOR_SETJMP__(setjmp_symname)\n#define TSAN_INTERCEPTOR_SIGSETJMP TSAN_INTERCEPTOR_SETJMP__(sigsetjmp_symname)\n\n#define TSAN_STRING_SETJMP SANITIZER_STRINGIFY(setjmp_symname)\n#define TSAN_STRING_SIGSETJMP SANITIZER_STRINGIFY(sigsetjmp_symname)\n\n// Not called.  Merely to satisfy TSAN_INTERCEPT().\nextern \"C\" SANITIZER_INTERFACE_ATTRIBUTE\nint TSAN_INTERCEPTOR_SETJMP(void *env);\nextern \"C\" int TSAN_INTERCEPTOR_SETJMP(void *env) {\n  CHECK(0);\n  return 0;\n}\n\n// FIXME: any reason to have a separate declaration?\nextern \"C\" SANITIZER_INTERFACE_ATTRIBUTE\nint __interceptor__setjmp(void *env);\nextern \"C\" int __interceptor__setjmp(void *env) {\n  CHECK(0);\n  return 0;\n}\n\nextern \"C\" SANITIZER_INTERFACE_ATTRIBUTE\nint TSAN_INTERCEPTOR_SIGSETJMP(void *env);\nextern \"C\" int TSAN_INTERCEPTOR_SIGSETJMP(void *env) {\n  CHECK(0);\n  return 0;\n}\n\n#if !SANITIZER_NETBSD\nextern \"C\" SANITIZER_INTERFACE_ATTRIBUTE\nint __interceptor___sigsetjmp(void *env);\nextern \"C\" int __interceptor___sigsetjmp(void *env) {\n  CHECK(0);\n  return 0;\n}\n#endif\n\nextern \"C\" int setjmp_symname(void *env);\nextern \"C\" int _setjmp(void *env);\nextern \"C\" int sigsetjmp_symname(void *env);\n#if !SANITIZER_NETBSD\nextern \"C\" int __sigsetjmp(void *env);\n#endif\nDEFINE_REAL(int, setjmp_symname, void *env)\nDEFINE_REAL(int, _setjmp, void *env)\nDEFINE_REAL(int, sigsetjmp_symname, void *env)\n#if !SANITIZER_NETBSD\nDEFINE_REAL(int, __sigsetjmp, void *env)\n#endif\n#endif  // SANITIZER_MAC\n\n#if SANITIZER_NETBSD\n#define longjmp_symname __longjmp14\n#define siglongjmp_symname __siglongjmp14\n#else\n#define longjmp_symname longjmp\n#define siglongjmp_symname siglongjmp\n#endif\n\nTSAN_INTERCEPTOR(void, longjmp_symname, uptr *env, int val) {\n  // Note: if we call REAL(longjmp) in the context of ScopedInterceptor,\n  // bad things will happen. We will jump over ScopedInterceptor dtor and can\n  // leave thr->in_ignored_lib set.\n  {\n    SCOPED_INTERCEPTOR_RAW(longjmp_symname, env, val);\n  }\n  LongJmp(cur_thread(), env);\n  REAL(longjmp_symname)(env, val);\n}\n\nTSAN_INTERCEPTOR(void, siglongjmp_symname, uptr *env, int val) {\n  {\n    SCOPED_INTERCEPTOR_RAW(siglongjmp_symname, env, val);\n  }\n  LongJmp(cur_thread(), env);\n  REAL(siglongjmp_symname)(env, val);\n}\n\n#if SANITIZER_NETBSD\nTSAN_INTERCEPTOR(void, _longjmp, uptr *env, int val) {\n  {\n    SCOPED_INTERCEPTOR_RAW(_longjmp, env, val);\n  }\n  LongJmp(cur_thread(), env);\n  REAL(_longjmp)(env, val);\n}\n#endif\n\n#if !SANITIZER_MAC\nTSAN_INTERCEPTOR(void*, malloc, uptr size) {\n  if (in_symbolizer())\n    return InternalAlloc(size);\n  void *p = 0;\n  {\n    SCOPED_INTERCEPTOR_RAW(malloc, size);\n    p = user_alloc(thr, pc, size);\n  }\n  invoke_malloc_hook(p, size);\n  return p;\n}\n\n// In glibc<2.25, dynamic TLS blocks are allocated by __libc_memalign. Intercept\n// __libc_memalign so that (1) we can detect races (2) free will not be called\n// on libc internally allocated blocks.\nTSAN_INTERCEPTOR(void*, __libc_memalign, uptr align, uptr sz) {\n  SCOPED_INTERCEPTOR_RAW(__libc_memalign, align, sz);\n  return user_memalign(thr, pc, align, sz);\n}\n\nTSAN_INTERCEPTOR(void*, calloc, uptr size, uptr n) {\n  if (in_symbolizer())\n    return InternalCalloc(size, n);\n  void *p = 0;\n  {\n    SCOPED_INTERCEPTOR_RAW(calloc, size, n);\n    p = user_calloc(thr, pc, size, n);\n  }\n  invoke_malloc_hook(p, n * size);\n  return p;\n}\n\nTSAN_INTERCEPTOR(void*, realloc, void *p, uptr size) {\n  if (in_symbolizer())\n    return InternalRealloc(p, size);\n  if (p)\n    invoke_free_hook(p);\n  {\n    SCOPED_INTERCEPTOR_RAW(realloc, p, size);\n    p = user_realloc(thr, pc, p, size);\n  }\n  invoke_malloc_hook(p, size);\n  return p;\n}\n\nTSAN_INTERCEPTOR(void*, reallocarray, void *p, uptr size, uptr n) {\n  if (in_symbolizer())\n    return InternalReallocArray(p, size, n);\n  if (p)\n    invoke_free_hook(p);\n  {\n    SCOPED_INTERCEPTOR_RAW(reallocarray, p, size, n);\n    p = user_reallocarray(thr, pc, p, size, n);\n  }\n  invoke_malloc_hook(p, size);\n  return p;\n}\n\nTSAN_INTERCEPTOR(void, free, void *p) {\n  if (p == 0)\n    return;\n  if (in_symbolizer())\n    return InternalFree(p);\n  invoke_free_hook(p);\n  SCOPED_INTERCEPTOR_RAW(free, p);\n  user_free(thr, pc, p);\n}\n\nTSAN_INTERCEPTOR(void, cfree, void *p) {\n  if (p == 0)\n    return;\n  if (in_symbolizer())\n    return InternalFree(p);\n  invoke_free_hook(p);\n  SCOPED_INTERCEPTOR_RAW(cfree, p);\n  user_free(thr, pc, p);\n}\n\nTSAN_INTERCEPTOR(uptr, malloc_usable_size, void *p) {\n  SCOPED_INTERCEPTOR_RAW(malloc_usable_size, p);\n  return user_alloc_usable_size(p);\n}\n#endif\n\nTSAN_INTERCEPTOR(char *, strcpy, char *dst, const char *src) {\n  SCOPED_TSAN_INTERCEPTOR(strcpy, dst, src);\n  uptr srclen = internal_strlen(src);\n  MemoryAccessRange(thr, pc, (uptr)dst, srclen + 1, true);\n  MemoryAccessRange(thr, pc, (uptr)src, srclen + 1, false);\n  return REAL(strcpy)(dst, src);\n}\n\nTSAN_INTERCEPTOR(char*, strncpy, char *dst, char *src, uptr n) {\n  SCOPED_TSAN_INTERCEPTOR(strncpy, dst, src, n);\n  uptr srclen = internal_strnlen(src, n);\n  MemoryAccessRange(thr, pc, (uptr)dst, n, true);\n  MemoryAccessRange(thr, pc, (uptr)src, min(srclen + 1, n), false);\n  return REAL(strncpy)(dst, src, n);\n}\n\nTSAN_INTERCEPTOR(char*, strdup, const char *str) {\n  SCOPED_TSAN_INTERCEPTOR(strdup, str);\n  // strdup will call malloc, so no instrumentation is required here.\n  return REAL(strdup)(str);\n}\n\n// Zero out addr if it points into shadow memory and was provided as a hint\n// only, i.e., MAP_FIXED is not set.\nstatic bool fix_mmap_addr(void **addr, long_t sz, int flags) {\n  if (*addr) {\n    if (!IsAppMem((uptr)*addr) || !IsAppMem((uptr)*addr + sz - 1)) {\n      if (flags & MAP_FIXED) {\n        errno = errno_EINVAL;\n        return false;\n      } else {\n        *addr = 0;\n      }\n    }\n  }\n  return true;\n}\n\ntemplate <class Mmap>\nstatic void *mmap_interceptor(ThreadState *thr, uptr pc, Mmap real_mmap,\n                              void *addr, SIZE_T sz, int prot, int flags,\n                              int fd, OFF64_T off) {\n  if (!fix_mmap_addr(&addr, sz, flags)) return MAP_FAILED;\n  void *res = real_mmap(addr, sz, prot, flags, fd, off);\n  if (res != MAP_FAILED) {\n    if (!IsAppMem((uptr)res) || !IsAppMem((uptr)res + sz - 1)) {\n      Report(\"ThreadSanitizer: mmap at bad address: addr=%p size=%p res=%p\\n\",\n             addr, (void*)sz, res);\n      Die();\n    }\n    if (fd > 0) FdAccess(thr, pc, fd);\n    MemoryRangeImitateWriteOrResetRange(thr, pc, (uptr)res, sz);\n  }\n  return res;\n}\n\nTSAN_INTERCEPTOR(int, munmap, void *addr, long_t sz) {\n  SCOPED_TSAN_INTERCEPTOR(munmap, addr, sz);\n  UnmapShadow(thr, (uptr)addr, sz);\n  int res = REAL(munmap)(addr, sz);\n  return res;\n}\n\n#if SANITIZER_LINUX\nTSAN_INTERCEPTOR(void*, memalign, uptr align, uptr sz) {\n  SCOPED_INTERCEPTOR_RAW(memalign, align, sz);\n  return user_memalign(thr, pc, align, sz);\n}\n#define TSAN_MAYBE_INTERCEPT_MEMALIGN TSAN_INTERCEPT(memalign)\n#else\n#define TSAN_MAYBE_INTERCEPT_MEMALIGN\n#endif\n\n#if !SANITIZER_MAC\nTSAN_INTERCEPTOR(void*, aligned_alloc, uptr align, uptr sz) {\n  if (in_symbolizer())\n    return InternalAlloc(sz, nullptr, align);\n  SCOPED_INTERCEPTOR_RAW(aligned_alloc, align, sz);\n  return user_aligned_alloc(thr, pc, align, sz);\n}\n\nTSAN_INTERCEPTOR(void*, valloc, uptr sz) {\n  if (in_symbolizer())\n    return InternalAlloc(sz, nullptr, GetPageSizeCached());\n  SCOPED_INTERCEPTOR_RAW(valloc, sz);\n  return user_valloc(thr, pc, sz);\n}\n#endif\n\n#if SANITIZER_LINUX\nTSAN_INTERCEPTOR(void*, pvalloc, uptr sz) {\n  if (in_symbolizer()) {\n    uptr PageSize = GetPageSizeCached();\n    sz = sz ? RoundUpTo(sz, PageSize) : PageSize;\n    return InternalAlloc(sz, nullptr, PageSize);\n  }\n  SCOPED_INTERCEPTOR_RAW(pvalloc, sz);\n  return user_pvalloc(thr, pc, sz);\n}\n#define TSAN_MAYBE_INTERCEPT_PVALLOC TSAN_INTERCEPT(pvalloc)\n#else\n#define TSAN_MAYBE_INTERCEPT_PVALLOC\n#endif\n\n#if !SANITIZER_MAC\nTSAN_INTERCEPTOR(int, posix_memalign, void **memptr, uptr align, uptr sz) {\n  if (in_symbolizer()) {\n    void *p = InternalAlloc(sz, nullptr, align);\n    if (!p)\n      return errno_ENOMEM;\n    *memptr = p;\n    return 0;\n  }\n  SCOPED_INTERCEPTOR_RAW(posix_memalign, memptr, align, sz);\n  return user_posix_memalign(thr, pc, memptr, align, sz);\n}\n#endif\n\n// __cxa_guard_acquire and friends need to be intercepted in a special way -\n// regular interceptors will break statically-linked libstdc++. Linux\n// interceptors are especially defined as weak functions (so that they don't\n// cause link errors when user defines them as well). So they silently\n// auto-disable themselves when such symbol is already present in the binary. If\n// we link libstdc++ statically, it will bring own __cxa_guard_acquire which\n// will silently replace our interceptor.  That's why on Linux we simply export\n// these interceptors with INTERFACE_ATTRIBUTE.\n// On OS X, we don't support statically linking, so we just use a regular\n// interceptor.\n#if SANITIZER_MAC\n#define STDCXX_INTERCEPTOR TSAN_INTERCEPTOR\n#else\n#define STDCXX_INTERCEPTOR(rettype, name, ...) \\\n  extern \"C\" rettype INTERFACE_ATTRIBUTE name(__VA_ARGS__)\n#endif\n\n// Used in thread-safe function static initialization.\nSTDCXX_INTERCEPTOR(int, __cxa_guard_acquire, atomic_uint32_t *g) {\n  SCOPED_INTERCEPTOR_RAW(__cxa_guard_acquire, g);\n  OnPotentiallyBlockingRegionBegin();\n  auto on_exit = at_scope_exit(&OnPotentiallyBlockingRegionEnd);\n  for (;;) {\n    u32 cmp = atomic_load(g, memory_order_acquire);\n    if (cmp == 0) {\n      if (atomic_compare_exchange_strong(g, &cmp, 1<<16, memory_order_relaxed))\n        return 1;\n    } else if (cmp == 1) {\n      Acquire(thr, pc, (uptr)g);\n      return 0;\n    } else {\n      internal_sched_yield();\n    }\n  }\n}\n\nSTDCXX_INTERCEPTOR(void, __cxa_guard_release, atomic_uint32_t *g) {\n  SCOPED_INTERCEPTOR_RAW(__cxa_guard_release, g);\n  Release(thr, pc, (uptr)g);\n  atomic_store(g, 1, memory_order_release);\n}\n\nSTDCXX_INTERCEPTOR(void, __cxa_guard_abort, atomic_uint32_t *g) {\n  SCOPED_INTERCEPTOR_RAW(__cxa_guard_abort, g);\n  atomic_store(g, 0, memory_order_relaxed);\n}\n\nnamespace __tsan {\nvoid DestroyThreadState() {\n  ThreadState *thr = cur_thread();\n  Processor *proc = thr->proc();\n  ThreadFinish(thr);\n  ProcUnwire(proc, thr);\n  ProcDestroy(proc);\n  DTLS_Destroy();\n  cur_thread_finalize();\n}\n\nvoid PlatformCleanUpThreadState(ThreadState *thr) {\n  ThreadSignalContext *sctx = thr->signal_ctx;\n  if (sctx) {\n    thr->signal_ctx = 0;\n    UnmapOrDie(sctx, sizeof(*sctx));\n  }\n}\n}  // namespace __tsan\n\n#if !SANITIZER_MAC && !SANITIZER_NETBSD && !SANITIZER_FREEBSD\nstatic void thread_finalize(void *v) {\n  uptr iter = (uptr)v;\n  if (iter > 1) {\n    if (pthread_setspecific(interceptor_ctx()->finalize_key,\n        (void*)(iter - 1))) {\n      Printf(\"ThreadSanitizer: failed to set thread key\\n\");\n      Die();\n    }\n    return;\n  }\n  DestroyThreadState();\n}\n#endif\n\n\nstruct ThreadParam {\n  void* (*callback)(void *arg);\n  void *param;\n  atomic_uintptr_t tid;\n};\n\nextern \"C\" void *__tsan_thread_start_func(void *arg) {\n  ThreadParam *p = (ThreadParam*)arg;\n  void* (*callback)(void *arg) = p->callback;\n  void *param = p->param;\n  int tid = 0;\n  {\n    cur_thread_init();\n    ThreadState *thr = cur_thread();\n    // Thread-local state is not initialized yet.\n    ScopedIgnoreInterceptors ignore;\n#if !SANITIZER_MAC && !SANITIZER_NETBSD && !SANITIZER_FREEBSD\n    ThreadIgnoreBegin(thr, 0);\n    if (pthread_setspecific(interceptor_ctx()->finalize_key,\n                            (void *)GetPthreadDestructorIterations())) {\n      Printf(\"ThreadSanitizer: failed to set thread key\\n\");\n      Die();\n    }\n    ThreadIgnoreEnd(thr, 0);\n#endif\n    while ((tid = atomic_load(&p->tid, memory_order_acquire)) == 0)\n      internal_sched_yield();\n    Processor *proc = ProcCreate();\n    ProcWire(proc, thr);\n    ThreadStart(thr, tid, GetTid(), ThreadType::Regular);\n    atomic_store(&p->tid, 0, memory_order_release);\n  }\n  void *res = callback(param);\n  // Prevent the callback from being tail called,\n  // it mixes up stack traces.\n  volatile int foo = 42;\n  foo++;\n  return res;\n}\n\nTSAN_INTERCEPTOR(int, pthread_create,\n    void *th, void *attr, void *(*callback)(void*), void * param) {\n  SCOPED_INTERCEPTOR_RAW(pthread_create, th, attr, callback, param);\n\n  MaybeSpawnBackgroundThread();\n\n  if (ctx->after_multithreaded_fork) {\n    if (flags()->die_after_fork) {\n      Report(\"ThreadSanitizer: starting new threads after multi-threaded \"\n          \"fork is not supported. Dying (set die_after_fork=0 to override)\\n\");\n      Die();\n    } else {\n      VPrintf(1, \"ThreadSanitizer: starting new threads after multi-threaded \"\n          \"fork is not supported (pid %d). Continuing because of \"\n          \"die_after_fork=0, but you are on your own\\n\", internal_getpid());\n    }\n  }\n  __sanitizer_pthread_attr_t myattr;\n  if (attr == 0) {\n    pthread_attr_init(&myattr);\n    attr = &myattr;\n  }\n  int detached = 0;\n  REAL(pthread_attr_getdetachstate)(attr, &detached);\n  AdjustStackSize(attr);\n\n  ThreadParam p;\n  p.callback = callback;\n  p.param = param;\n  atomic_store(&p.tid, 0, memory_order_relaxed);\n  int res = -1;\n  {\n    // Otherwise we see false positives in pthread stack manipulation.\n    ScopedIgnoreInterceptors ignore;\n    ThreadIgnoreBegin(thr, pc);\n    res = REAL(pthread_create)(th, attr, __tsan_thread_start_func, &p);\n    ThreadIgnoreEnd(thr, pc);\n  }\n  if (res == 0) {\n    int tid = ThreadCreate(thr, pc, *(uptr*)th, IsStateDetached(detached));\n    CHECK_NE(tid, 0);\n    // Synchronization on p.tid serves two purposes:\n    // 1. ThreadCreate must finish before the new thread starts.\n    //    Otherwise the new thread can call pthread_detach, but the pthread_t\n    //    identifier is not yet registered in ThreadRegistry by ThreadCreate.\n    // 2. ThreadStart must finish before this thread continues.\n    //    Otherwise, this thread can call pthread_detach and reset thr->sync\n    //    before the new thread got a chance to acquire from it in ThreadStart.\n    atomic_store(&p.tid, tid, memory_order_release);\n    while (atomic_load(&p.tid, memory_order_acquire) != 0)\n      internal_sched_yield();\n  }\n  if (attr == &myattr)\n    pthread_attr_destroy(&myattr);\n  return res;\n}\n\nTSAN_INTERCEPTOR(int, pthread_join, void *th, void **ret) {\n  SCOPED_INTERCEPTOR_RAW(pthread_join, th, ret);\n  int tid = ThreadConsumeTid(thr, pc, (uptr)th);\n  ThreadIgnoreBegin(thr, pc);\n  int res = BLOCK_REAL(pthread_join)(th, ret);\n  ThreadIgnoreEnd(thr, pc);\n  if (res == 0) {\n    ThreadJoin(thr, pc, tid);\n  }\n  return res;\n}\n\nDEFINE_REAL_PTHREAD_FUNCTIONS\n\nTSAN_INTERCEPTOR(int, pthread_detach, void *th) {\n  SCOPED_INTERCEPTOR_RAW(pthread_detach, th);\n  int tid = ThreadConsumeTid(thr, pc, (uptr)th);\n  int res = REAL(pthread_detach)(th);\n  if (res == 0) {\n    ThreadDetach(thr, pc, tid);\n  }\n  return res;\n}\n\nTSAN_INTERCEPTOR(void, pthread_exit, void *retval) {\n  {\n    SCOPED_INTERCEPTOR_RAW(pthread_exit, retval);\n#if !SANITIZER_MAC && !SANITIZER_ANDROID\n    CHECK_EQ(thr, &cur_thread_placeholder);\n#endif\n  }\n  REAL(pthread_exit)(retval);\n}\n\n#if SANITIZER_LINUX\nTSAN_INTERCEPTOR(int, pthread_tryjoin_np, void *th, void **ret) {\n  SCOPED_INTERCEPTOR_RAW(pthread_tryjoin_np, th, ret);\n  int tid = ThreadConsumeTid(thr, pc, (uptr)th);\n  ThreadIgnoreBegin(thr, pc);\n  int res = REAL(pthread_tryjoin_np)(th, ret);\n  ThreadIgnoreEnd(thr, pc);\n  if (res == 0)\n    ThreadJoin(thr, pc, tid);\n  else\n    ThreadNotJoined(thr, pc, tid, (uptr)th);\n  return res;\n}\n\nTSAN_INTERCEPTOR(int, pthread_timedjoin_np, void *th, void **ret,\n                 const struct timespec *abstime) {\n  SCOPED_INTERCEPTOR_RAW(pthread_timedjoin_np, th, ret, abstime);\n  int tid = ThreadConsumeTid(thr, pc, (uptr)th);\n  ThreadIgnoreBegin(thr, pc);\n  int res = BLOCK_REAL(pthread_timedjoin_np)(th, ret, abstime);\n  ThreadIgnoreEnd(thr, pc);\n  if (res == 0)\n    ThreadJoin(thr, pc, tid);\n  else\n    ThreadNotJoined(thr, pc, tid, (uptr)th);\n  return res;\n}\n#endif\n\n// Problem:\n// NPTL implementation of pthread_cond has 2 versions (2.2.5 and 2.3.2).\n// pthread_cond_t has different size in the different versions.\n// If call new REAL functions for old pthread_cond_t, they will corrupt memory\n// after pthread_cond_t (old cond is smaller).\n// If we call old REAL functions for new pthread_cond_t, we will lose  some\n// functionality (e.g. old functions do not support waiting against\n// CLOCK_REALTIME).\n// Proper handling would require to have 2 versions of interceptors as well.\n// But this is messy, in particular requires linker scripts when sanitizer\n// runtime is linked into a shared library.\n// Instead we assume we don't have dynamic libraries built against old\n// pthread (2.2.5 is dated by 2002). And provide legacy_pthread_cond flag\n// that allows to work with old libraries (but this mode does not support\n// some features, e.g. pthread_condattr_getpshared).\nstatic void *init_cond(void *c, bool force = false) {\n  // sizeof(pthread_cond_t) >= sizeof(uptr) in both versions.\n  // So we allocate additional memory on the side large enough to hold\n  // any pthread_cond_t object. Always call new REAL functions, but pass\n  // the aux object to them.\n  // Note: the code assumes that PTHREAD_COND_INITIALIZER initializes\n  // first word of pthread_cond_t to zero.\n  // It's all relevant only for linux.\n  if (!common_flags()->legacy_pthread_cond)\n    return c;\n  atomic_uintptr_t *p = (atomic_uintptr_t*)c;\n  uptr cond = atomic_load(p, memory_order_acquire);\n  if (!force && cond != 0)\n    return (void*)cond;\n  void *newcond = WRAP(malloc)(pthread_cond_t_sz);\n  internal_memset(newcond, 0, pthread_cond_t_sz);\n  if (atomic_compare_exchange_strong(p, &cond, (uptr)newcond,\n      memory_order_acq_rel))\n    return newcond;\n  WRAP(free)(newcond);\n  return (void*)cond;\n}\n\nnamespace {\n\ntemplate <class Fn>\nstruct CondMutexUnlockCtx {\n  ScopedInterceptor *si;\n  ThreadState *thr;\n  uptr pc;\n  void *m;\n  void *c;\n  const Fn &fn;\n\n  int Cancel() const { return fn(); }\n  void Unlock() const;\n};\n\ntemplate <class Fn>\nvoid CondMutexUnlockCtx<Fn>::Unlock() const {\n  // pthread_cond_wait interceptor has enabled async signal delivery\n  // (see BlockingCall below). Disable async signals since we are running\n  // tsan code. Also ScopedInterceptor and BlockingCall destructors won't run\n  // since the thread is cancelled, so we have to manually execute them\n  // (the thread still can run some user code due to pthread_cleanup_push).\n  ThreadSignalContext *ctx = SigCtx(thr);\n  CHECK_EQ(atomic_load(&ctx->in_blocking_func, memory_order_relaxed), 1);\n  atomic_store(&ctx->in_blocking_func, 0, memory_order_relaxed);\n  MutexPostLock(thr, pc, (uptr)m, MutexFlagDoPreLockOnPostLock);\n  // Undo BlockingCall ctor effects.\n  thr->ignore_interceptors--;\n  si->~ScopedInterceptor();\n}\n}  // namespace\n\nINTERCEPTOR(int, pthread_cond_init, void *c, void *a) {\n  void *cond = init_cond(c, true);\n  SCOPED_TSAN_INTERCEPTOR(pthread_cond_init, cond, a);\n  MemoryAccessRange(thr, pc, (uptr)c, sizeof(uptr), true);\n  return REAL(pthread_cond_init)(cond, a);\n}\n\ntemplate <class Fn>\nint cond_wait(ThreadState *thr, uptr pc, ScopedInterceptor *si, const Fn &fn,\n              void *c, void *m) {\n  MemoryAccessRange(thr, pc, (uptr)c, sizeof(uptr), false);\n  MutexUnlock(thr, pc, (uptr)m);\n  int res = 0;\n  // This ensures that we handle mutex lock even in case of pthread_cancel.\n  // See test/tsan/cond_cancel.cpp.\n  {\n    // Enable signal delivery while the thread is blocked.\n    BlockingCall bc(thr);\n    CondMutexUnlockCtx<Fn> arg = {si, thr, pc, m, c, fn};\n    res = call_pthread_cancel_with_cleanup(\n        [](void *arg) -> int {\n          return ((const CondMutexUnlockCtx<Fn> *)arg)->Cancel();\n        },\n        [](void *arg) { ((const CondMutexUnlockCtx<Fn> *)arg)->Unlock(); },\n        &arg);\n  }\n  if (res == errno_EOWNERDEAD) MutexRepair(thr, pc, (uptr)m);\n  MutexPostLock(thr, pc, (uptr)m, MutexFlagDoPreLockOnPostLock);\n  return res;\n}\n\nINTERCEPTOR(int, pthread_cond_wait, void *c, void *m) {\n  void *cond = init_cond(c);\n  SCOPED_TSAN_INTERCEPTOR(pthread_cond_wait, cond, m);\n  return cond_wait(\n      thr, pc, &si, [=]() { return REAL(pthread_cond_wait)(cond, m); }, cond,\n      m);\n}\n\nINTERCEPTOR(int, pthread_cond_timedwait, void *c, void *m, void *abstime) {\n  void *cond = init_cond(c);\n  SCOPED_TSAN_INTERCEPTOR(pthread_cond_timedwait, cond, m, abstime);\n  return cond_wait(\n      thr, pc, &si,\n      [=]() { return REAL(pthread_cond_timedwait)(cond, m, abstime); }, cond,\n      m);\n}\n\n#if SANITIZER_LINUX\nINTERCEPTOR(int, pthread_cond_clockwait, void *c, void *m,\n            __sanitizer_clockid_t clock, void *abstime) {\n  void *cond = init_cond(c);\n  SCOPED_TSAN_INTERCEPTOR(pthread_cond_clockwait, cond, m, clock, abstime);\n  return cond_wait(\n      thr, pc, &si,\n      [=]() { return REAL(pthread_cond_clockwait)(cond, m, clock, abstime); },\n      cond, m);\n}\n#define TSAN_MAYBE_PTHREAD_COND_CLOCKWAIT TSAN_INTERCEPT(pthread_cond_clockwait)\n#else\n#define TSAN_MAYBE_PTHREAD_COND_CLOCKWAIT\n#endif\n\n#if SANITIZER_MAC\nINTERCEPTOR(int, pthread_cond_timedwait_relative_np, void *c, void *m,\n            void *reltime) {\n  void *cond = init_cond(c);\n  SCOPED_TSAN_INTERCEPTOR(pthread_cond_timedwait_relative_np, cond, m, reltime);\n  return cond_wait(\n      thr, pc, &si,\n      [=]() {\n        return REAL(pthread_cond_timedwait_relative_np)(cond, m, reltime);\n      },\n      cond, m);\n}\n#endif\n\nINTERCEPTOR(int, pthread_cond_signal, void *c) {\n  void *cond = init_cond(c);\n  SCOPED_TSAN_INTERCEPTOR(pthread_cond_signal, cond);\n  MemoryAccessRange(thr, pc, (uptr)c, sizeof(uptr), false);\n  return REAL(pthread_cond_signal)(cond);\n}\n\nINTERCEPTOR(int, pthread_cond_broadcast, void *c) {\n  void *cond = init_cond(c);\n  SCOPED_TSAN_INTERCEPTOR(pthread_cond_broadcast, cond);\n  MemoryAccessRange(thr, pc, (uptr)c, sizeof(uptr), false);\n  return REAL(pthread_cond_broadcast)(cond);\n}\n\nINTERCEPTOR(int, pthread_cond_destroy, void *c) {\n  void *cond = init_cond(c);\n  SCOPED_TSAN_INTERCEPTOR(pthread_cond_destroy, cond);\n  MemoryAccessRange(thr, pc, (uptr)c, sizeof(uptr), true);\n  int res = REAL(pthread_cond_destroy)(cond);\n  if (common_flags()->legacy_pthread_cond) {\n    // Free our aux cond and zero the pointer to not leave dangling pointers.\n    WRAP(free)(cond);\n    atomic_store((atomic_uintptr_t*)c, 0, memory_order_relaxed);\n  }\n  return res;\n}\n\nTSAN_INTERCEPTOR(int, pthread_mutex_init, void *m, void *a) {\n  SCOPED_TSAN_INTERCEPTOR(pthread_mutex_init, m, a);\n  int res = REAL(pthread_mutex_init)(m, a);\n  if (res == 0) {\n    u32 flagz = 0;\n    if (a) {\n      int type = 0;\n      if (REAL(pthread_mutexattr_gettype)(a, &type) == 0)\n        if (type == PTHREAD_MUTEX_RECURSIVE ||\n            type == PTHREAD_MUTEX_RECURSIVE_NP)\n          flagz |= MutexFlagWriteReentrant;\n    }\n    MutexCreate(thr, pc, (uptr)m, flagz);\n  }\n  return res;\n}\n\nTSAN_INTERCEPTOR(int, pthread_mutex_destroy, void *m) {\n  SCOPED_TSAN_INTERCEPTOR(pthread_mutex_destroy, m);\n  int res = REAL(pthread_mutex_destroy)(m);\n  if (res == 0 || res == errno_EBUSY) {\n    MutexDestroy(thr, pc, (uptr)m);\n  }\n  return res;\n}\n\nTSAN_INTERCEPTOR(int, pthread_mutex_trylock, void *m) {\n  SCOPED_TSAN_INTERCEPTOR(pthread_mutex_trylock, m);\n  int res = REAL(pthread_mutex_trylock)(m);\n  if (res == errno_EOWNERDEAD)\n    MutexRepair(thr, pc, (uptr)m);\n  if (res == 0 || res == errno_EOWNERDEAD)\n    MutexPostLock(thr, pc, (uptr)m, MutexFlagTryLock);\n  return res;\n}\n\n#if !SANITIZER_MAC\nTSAN_INTERCEPTOR(int, pthread_mutex_timedlock, void *m, void *abstime) {\n  SCOPED_TSAN_INTERCEPTOR(pthread_mutex_timedlock, m, abstime);\n  int res = REAL(pthread_mutex_timedlock)(m, abstime);\n  if (res == 0) {\n    MutexPostLock(thr, pc, (uptr)m, MutexFlagTryLock);\n  }\n  return res;\n}\n#endif\n\n#if !SANITIZER_MAC\nTSAN_INTERCEPTOR(int, pthread_spin_init, void *m, int pshared) {\n  SCOPED_TSAN_INTERCEPTOR(pthread_spin_init, m, pshared);\n  int res = REAL(pthread_spin_init)(m, pshared);\n  if (res == 0) {\n    MutexCreate(thr, pc, (uptr)m);\n  }\n  return res;\n}\n\nTSAN_INTERCEPTOR(int, pthread_spin_destroy, void *m) {\n  SCOPED_TSAN_INTERCEPTOR(pthread_spin_destroy, m);\n  int res = REAL(pthread_spin_destroy)(m);\n  if (res == 0) {\n    MutexDestroy(thr, pc, (uptr)m);\n  }\n  return res;\n}\n\nTSAN_INTERCEPTOR(int, pthread_spin_lock, void *m) {\n  SCOPED_TSAN_INTERCEPTOR(pthread_spin_lock, m);\n  MutexPreLock(thr, pc, (uptr)m);\n  int res = REAL(pthread_spin_lock)(m);\n  if (res == 0) {\n    MutexPostLock(thr, pc, (uptr)m);\n  }\n  return res;\n}\n\nTSAN_INTERCEPTOR(int, pthread_spin_trylock, void *m) {\n  SCOPED_TSAN_INTERCEPTOR(pthread_spin_trylock, m);\n  int res = REAL(pthread_spin_trylock)(m);\n  if (res == 0) {\n    MutexPostLock(thr, pc, (uptr)m, MutexFlagTryLock);\n  }\n  return res;\n}\n\nTSAN_INTERCEPTOR(int, pthread_spin_unlock, void *m) {\n  SCOPED_TSAN_INTERCEPTOR(pthread_spin_unlock, m);\n  MutexUnlock(thr, pc, (uptr)m);\n  int res = REAL(pthread_spin_unlock)(m);\n  return res;\n}\n#endif\n\nTSAN_INTERCEPTOR(int, pthread_rwlock_init, void *m, void *a) {\n  SCOPED_TSAN_INTERCEPTOR(pthread_rwlock_init, m, a);\n  int res = REAL(pthread_rwlock_init)(m, a);\n  if (res == 0) {\n    MutexCreate(thr, pc, (uptr)m);\n  }\n  return res;\n}\n\nTSAN_INTERCEPTOR(int, pthread_rwlock_destroy, void *m) {\n  SCOPED_TSAN_INTERCEPTOR(pthread_rwlock_destroy, m);\n  int res = REAL(pthread_rwlock_destroy)(m);\n  if (res == 0) {\n    MutexDestroy(thr, pc, (uptr)m);\n  }\n  return res;\n}\n\nTSAN_INTERCEPTOR(int, pthread_rwlock_rdlock, void *m) {\n  SCOPED_TSAN_INTERCEPTOR(pthread_rwlock_rdlock, m);\n  MutexPreReadLock(thr, pc, (uptr)m);\n  int res = REAL(pthread_rwlock_rdlock)(m);\n  if (res == 0) {\n    MutexPostReadLock(thr, pc, (uptr)m);\n  }\n  return res;\n}\n\nTSAN_INTERCEPTOR(int, pthread_rwlock_tryrdlock, void *m) {\n  SCOPED_TSAN_INTERCEPTOR(pthread_rwlock_tryrdlock, m);\n  int res = REAL(pthread_rwlock_tryrdlock)(m);\n  if (res == 0) {\n    MutexPostReadLock(thr, pc, (uptr)m, MutexFlagTryLock);\n  }\n  return res;\n}\n\n#if !SANITIZER_MAC\nTSAN_INTERCEPTOR(int, pthread_rwlock_timedrdlock, void *m, void *abstime) {\n  SCOPED_TSAN_INTERCEPTOR(pthread_rwlock_timedrdlock, m, abstime);\n  int res = REAL(pthread_rwlock_timedrdlock)(m, abstime);\n  if (res == 0) {\n    MutexPostReadLock(thr, pc, (uptr)m);\n  }\n  return res;\n}\n#endif\n\nTSAN_INTERCEPTOR(int, pthread_rwlock_wrlock, void *m) {\n  SCOPED_TSAN_INTERCEPTOR(pthread_rwlock_wrlock, m);\n  MutexPreLock(thr, pc, (uptr)m);\n  int res = REAL(pthread_rwlock_wrlock)(m);\n  if (res == 0) {\n    MutexPostLock(thr, pc, (uptr)m);\n  }\n  return res;\n}\n\nTSAN_INTERCEPTOR(int, pthread_rwlock_trywrlock, void *m) {\n  SCOPED_TSAN_INTERCEPTOR(pthread_rwlock_trywrlock, m);\n  int res = REAL(pthread_rwlock_trywrlock)(m);\n  if (res == 0) {\n    MutexPostLock(thr, pc, (uptr)m, MutexFlagTryLock);\n  }\n  return res;\n}\n\n#if !SANITIZER_MAC\nTSAN_INTERCEPTOR(int, pthread_rwlock_timedwrlock, void *m, void *abstime) {\n  SCOPED_TSAN_INTERCEPTOR(pthread_rwlock_timedwrlock, m, abstime);\n  int res = REAL(pthread_rwlock_timedwrlock)(m, abstime);\n  if (res == 0) {\n    MutexPostLock(thr, pc, (uptr)m, MutexFlagTryLock);\n  }\n  return res;\n}\n#endif\n\nTSAN_INTERCEPTOR(int, pthread_rwlock_unlock, void *m) {\n  SCOPED_TSAN_INTERCEPTOR(pthread_rwlock_unlock, m);\n  MutexReadOrWriteUnlock(thr, pc, (uptr)m);\n  int res = REAL(pthread_rwlock_unlock)(m);\n  return res;\n}\n\n#if !SANITIZER_MAC\nTSAN_INTERCEPTOR(int, pthread_barrier_init, void *b, void *a, unsigned count) {\n  SCOPED_TSAN_INTERCEPTOR(pthread_barrier_init, b, a, count);\n  MemoryWrite(thr, pc, (uptr)b, kSizeLog1);\n  int res = REAL(pthread_barrier_init)(b, a, count);\n  return res;\n}\n\nTSAN_INTERCEPTOR(int, pthread_barrier_destroy, void *b) {\n  SCOPED_TSAN_INTERCEPTOR(pthread_barrier_destroy, b);\n  MemoryWrite(thr, pc, (uptr)b, kSizeLog1);\n  int res = REAL(pthread_barrier_destroy)(b);\n  return res;\n}\n\nTSAN_INTERCEPTOR(int, pthread_barrier_wait, void *b) {\n  SCOPED_TSAN_INTERCEPTOR(pthread_barrier_wait, b);\n  Release(thr, pc, (uptr)b);\n  MemoryRead(thr, pc, (uptr)b, kSizeLog1);\n  int res = REAL(pthread_barrier_wait)(b);\n  MemoryRead(thr, pc, (uptr)b, kSizeLog1);\n  if (res == 0 || res == PTHREAD_BARRIER_SERIAL_THREAD) {\n    Acquire(thr, pc, (uptr)b);\n  }\n  return res;\n}\n#endif\n\nTSAN_INTERCEPTOR(int, pthread_once, void *o, void (*f)()) {\n  SCOPED_INTERCEPTOR_RAW(pthread_once, o, f);\n  if (o == 0 || f == 0)\n    return errno_EINVAL;\n  atomic_uint32_t *a;\n\n  if (SANITIZER_MAC)\n    a = static_cast<atomic_uint32_t*>((void *)((char *)o + sizeof(long_t)));\n  else if (SANITIZER_NETBSD)\n    a = static_cast<atomic_uint32_t*>\n          ((void *)((char *)o + __sanitizer::pthread_mutex_t_sz));\n  else\n    a = static_cast<atomic_uint32_t*>(o);\n\n  u32 v = atomic_load(a, memory_order_acquire);\n  if (v == 0 && atomic_compare_exchange_strong(a, &v, 1,\n                                               memory_order_relaxed)) {\n    (*f)();\n    if (!thr->in_ignored_lib)\n      Release(thr, pc, (uptr)o);\n    atomic_store(a, 2, memory_order_release);\n  } else {\n    while (v != 2) {\n      internal_sched_yield();\n      v = atomic_load(a, memory_order_acquire);\n    }\n    if (!thr->in_ignored_lib)\n      Acquire(thr, pc, (uptr)o);\n  }\n  return 0;\n}\n\n#if SANITIZER_LINUX && !SANITIZER_ANDROID\nTSAN_INTERCEPTOR(int, __fxstat, int version, int fd, void *buf) {\n  SCOPED_TSAN_INTERCEPTOR(__fxstat, version, fd, buf);\n  if (fd > 0)\n    FdAccess(thr, pc, fd);\n  return REAL(__fxstat)(version, fd, buf);\n}\n#define TSAN_MAYBE_INTERCEPT___FXSTAT TSAN_INTERCEPT(__fxstat)\n#else\n#define TSAN_MAYBE_INTERCEPT___FXSTAT\n#endif\n\nTSAN_INTERCEPTOR(int, fstat, int fd, void *buf) {\n#if SANITIZER_FREEBSD || SANITIZER_MAC || SANITIZER_ANDROID || SANITIZER_NETBSD\n  SCOPED_TSAN_INTERCEPTOR(fstat, fd, buf);\n  if (fd > 0)\n    FdAccess(thr, pc, fd);\n  return REAL(fstat)(fd, buf);\n#else\n  SCOPED_TSAN_INTERCEPTOR(__fxstat, 0, fd, buf);\n  if (fd > 0)\n    FdAccess(thr, pc, fd);\n  return REAL(__fxstat)(0, fd, buf);\n#endif\n}\n\n#if SANITIZER_LINUX && !SANITIZER_ANDROID\nTSAN_INTERCEPTOR(int, __fxstat64, int version, int fd, void *buf) {\n  SCOPED_TSAN_INTERCEPTOR(__fxstat64, version, fd, buf);\n  if (fd > 0)\n    FdAccess(thr, pc, fd);\n  return REAL(__fxstat64)(version, fd, buf);\n}\n#define TSAN_MAYBE_INTERCEPT___FXSTAT64 TSAN_INTERCEPT(__fxstat64)\n#else\n#define TSAN_MAYBE_INTERCEPT___FXSTAT64\n#endif\n\n#if SANITIZER_LINUX && !SANITIZER_ANDROID\nTSAN_INTERCEPTOR(int, fstat64, int fd, void *buf) {\n  SCOPED_TSAN_INTERCEPTOR(__fxstat64, 0, fd, buf);\n  if (fd > 0)\n    FdAccess(thr, pc, fd);\n  return REAL(__fxstat64)(0, fd, buf);\n}\n#define TSAN_MAYBE_INTERCEPT_FSTAT64 TSAN_INTERCEPT(fstat64)\n#else\n#define TSAN_MAYBE_INTERCEPT_FSTAT64\n#endif\n\nTSAN_INTERCEPTOR(int, open, const char *name, int oflag, ...) {\n  va_list ap;\n  va_start(ap, oflag);\n  mode_t mode = va_arg(ap, int);\n  va_end(ap);\n  SCOPED_TSAN_INTERCEPTOR(open, name, oflag, mode);\n  READ_STRING(thr, pc, name, 0);\n  int fd = REAL(open)(name, oflag, mode);\n  if (fd >= 0)\n    FdFileCreate(thr, pc, fd);\n  return fd;\n}\n\n#if SANITIZER_LINUX\nTSAN_INTERCEPTOR(int, open64, const char *name, int oflag, ...) {\n  va_list ap;\n  va_start(ap, oflag);\n  mode_t mode = va_arg(ap, int);\n  va_end(ap);\n  SCOPED_TSAN_INTERCEPTOR(open64, name, oflag, mode);\n  READ_STRING(thr, pc, name, 0);\n  int fd = REAL(open64)(name, oflag, mode);\n  if (fd >= 0)\n    FdFileCreate(thr, pc, fd);\n  return fd;\n}\n#define TSAN_MAYBE_INTERCEPT_OPEN64 TSAN_INTERCEPT(open64)\n#else\n#define TSAN_MAYBE_INTERCEPT_OPEN64\n#endif\n\nTSAN_INTERCEPTOR(int, creat, const char *name, int mode) {\n  SCOPED_TSAN_INTERCEPTOR(creat, name, mode);\n  READ_STRING(thr, pc, name, 0);\n  int fd = REAL(creat)(name, mode);\n  if (fd >= 0)\n    FdFileCreate(thr, pc, fd);\n  return fd;\n}\n\n#if SANITIZER_LINUX\nTSAN_INTERCEPTOR(int, creat64, const char *name, int mode) {\n  SCOPED_TSAN_INTERCEPTOR(creat64, name, mode);\n  READ_STRING(thr, pc, name, 0);\n  int fd = REAL(creat64)(name, mode);\n  if (fd >= 0)\n    FdFileCreate(thr, pc, fd);\n  return fd;\n}\n#define TSAN_MAYBE_INTERCEPT_CREAT64 TSAN_INTERCEPT(creat64)\n#else\n#define TSAN_MAYBE_INTERCEPT_CREAT64\n#endif\n\nTSAN_INTERCEPTOR(int, dup, int oldfd) {\n  SCOPED_TSAN_INTERCEPTOR(dup, oldfd);\n  int newfd = REAL(dup)(oldfd);\n  if (oldfd >= 0 && newfd >= 0 && newfd != oldfd)\n    FdDup(thr, pc, oldfd, newfd, true);\n  return newfd;\n}\n\nTSAN_INTERCEPTOR(int, dup2, int oldfd, int newfd) {\n  SCOPED_TSAN_INTERCEPTOR(dup2, oldfd, newfd);\n  int newfd2 = REAL(dup2)(oldfd, newfd);\n  if (oldfd >= 0 && newfd2 >= 0 && newfd2 != oldfd)\n    FdDup(thr, pc, oldfd, newfd2, false);\n  return newfd2;\n}\n\n#if !SANITIZER_MAC\nTSAN_INTERCEPTOR(int, dup3, int oldfd, int newfd, int flags) {\n  SCOPED_TSAN_INTERCEPTOR(dup3, oldfd, newfd, flags);\n  int newfd2 = REAL(dup3)(oldfd, newfd, flags);\n  if (oldfd >= 0 && newfd2 >= 0 && newfd2 != oldfd)\n    FdDup(thr, pc, oldfd, newfd2, false);\n  return newfd2;\n}\n#endif\n\n#if SANITIZER_LINUX\nTSAN_INTERCEPTOR(int, eventfd, unsigned initval, int flags) {\n  SCOPED_TSAN_INTERCEPTOR(eventfd, initval, flags);\n  int fd = REAL(eventfd)(initval, flags);\n  if (fd >= 0)\n    FdEventCreate(thr, pc, fd);\n  return fd;\n}\n#define TSAN_MAYBE_INTERCEPT_EVENTFD TSAN_INTERCEPT(eventfd)\n#else\n#define TSAN_MAYBE_INTERCEPT_EVENTFD\n#endif\n\n#if SANITIZER_LINUX\nTSAN_INTERCEPTOR(int, signalfd, int fd, void *mask, int flags) {\n  SCOPED_TSAN_INTERCEPTOR(signalfd, fd, mask, flags);\n  if (fd >= 0)\n    FdClose(thr, pc, fd);\n  fd = REAL(signalfd)(fd, mask, flags);\n  if (fd >= 0)\n    FdSignalCreate(thr, pc, fd);\n  return fd;\n}\n#define TSAN_MAYBE_INTERCEPT_SIGNALFD TSAN_INTERCEPT(signalfd)\n#else\n#define TSAN_MAYBE_INTERCEPT_SIGNALFD\n#endif\n\n#if SANITIZER_LINUX\nTSAN_INTERCEPTOR(int, inotify_init, int fake) {\n  SCOPED_TSAN_INTERCEPTOR(inotify_init, fake);\n  int fd = REAL(inotify_init)(fake);\n  if (fd >= 0)\n    FdInotifyCreate(thr, pc, fd);\n  return fd;\n}\n#define TSAN_MAYBE_INTERCEPT_INOTIFY_INIT TSAN_INTERCEPT(inotify_init)\n#else\n#define TSAN_MAYBE_INTERCEPT_INOTIFY_INIT\n#endif\n\n#if SANITIZER_LINUX\nTSAN_INTERCEPTOR(int, inotify_init1, int flags) {\n  SCOPED_TSAN_INTERCEPTOR(inotify_init1, flags);\n  int fd = REAL(inotify_init1)(flags);\n  if (fd >= 0)\n    FdInotifyCreate(thr, pc, fd);\n  return fd;\n}\n#define TSAN_MAYBE_INTERCEPT_INOTIFY_INIT1 TSAN_INTERCEPT(inotify_init1)\n#else\n#define TSAN_MAYBE_INTERCEPT_INOTIFY_INIT1\n#endif\n\nTSAN_INTERCEPTOR(int, socket, int domain, int type, int protocol) {\n  SCOPED_TSAN_INTERCEPTOR(socket, domain, type, protocol);\n  int fd = REAL(socket)(domain, type, protocol);\n  if (fd >= 0)\n    FdSocketCreate(thr, pc, fd);\n  return fd;\n}\n\nTSAN_INTERCEPTOR(int, socketpair, int domain, int type, int protocol, int *fd) {\n  SCOPED_TSAN_INTERCEPTOR(socketpair, domain, type, protocol, fd);\n  int res = REAL(socketpair)(domain, type, protocol, fd);\n  if (res == 0 && fd[0] >= 0 && fd[1] >= 0)\n    FdPipeCreate(thr, pc, fd[0], fd[1]);\n  return res;\n}\n\nTSAN_INTERCEPTOR(int, connect, int fd, void *addr, unsigned addrlen) {\n  SCOPED_TSAN_INTERCEPTOR(connect, fd, addr, addrlen);\n  FdSocketConnecting(thr, pc, fd);\n  int res = REAL(connect)(fd, addr, addrlen);\n  if (res == 0 && fd >= 0)\n    FdSocketConnect(thr, pc, fd);\n  return res;\n}\n\nTSAN_INTERCEPTOR(int, bind, int fd, void *addr, unsigned addrlen) {\n  SCOPED_TSAN_INTERCEPTOR(bind, fd, addr, addrlen);\n  int res = REAL(bind)(fd, addr, addrlen);\n  if (fd > 0 && res == 0)\n    FdAccess(thr, pc, fd);\n  return res;\n}\n\nTSAN_INTERCEPTOR(int, listen, int fd, int backlog) {\n  SCOPED_TSAN_INTERCEPTOR(listen, fd, backlog);\n  int res = REAL(listen)(fd, backlog);\n  if (fd > 0 && res == 0)\n    FdAccess(thr, pc, fd);\n  return res;\n}\n\nTSAN_INTERCEPTOR(int, close, int fd) {\n  SCOPED_TSAN_INTERCEPTOR(close, fd);\n  if (fd >= 0)\n    FdClose(thr, pc, fd);\n  return REAL(close)(fd);\n}\n\n#if SANITIZER_LINUX\nTSAN_INTERCEPTOR(int, __close, int fd) {\n  SCOPED_TSAN_INTERCEPTOR(__close, fd);\n  if (fd >= 0)\n    FdClose(thr, pc, fd);\n  return REAL(__close)(fd);\n}\n#define TSAN_MAYBE_INTERCEPT___CLOSE TSAN_INTERCEPT(__close)\n#else\n#define TSAN_MAYBE_INTERCEPT___CLOSE\n#endif\n\n// glibc guts\n#if SANITIZER_LINUX && !SANITIZER_ANDROID\nTSAN_INTERCEPTOR(void, __res_iclose, void *state, bool free_addr) {\n  SCOPED_TSAN_INTERCEPTOR(__res_iclose, state, free_addr);\n  int fds[64];\n  int cnt = ExtractResolvFDs(state, fds, ARRAY_SIZE(fds));\n  for (int i = 0; i < cnt; i++) {\n    if (fds[i] > 0)\n      FdClose(thr, pc, fds[i]);\n  }\n  REAL(__res_iclose)(state, free_addr);\n}\n#define TSAN_MAYBE_INTERCEPT___RES_ICLOSE TSAN_INTERCEPT(__res_iclose)\n#else\n#define TSAN_MAYBE_INTERCEPT___RES_ICLOSE\n#endif\n\nTSAN_INTERCEPTOR(int, pipe, int *pipefd) {\n  SCOPED_TSAN_INTERCEPTOR(pipe, pipefd);\n  int res = REAL(pipe)(pipefd);\n  if (res == 0 && pipefd[0] >= 0 && pipefd[1] >= 0)\n    FdPipeCreate(thr, pc, pipefd[0], pipefd[1]);\n  return res;\n}\n\n#if !SANITIZER_MAC\nTSAN_INTERCEPTOR(int, pipe2, int *pipefd, int flags) {\n  SCOPED_TSAN_INTERCEPTOR(pipe2, pipefd, flags);\n  int res = REAL(pipe2)(pipefd, flags);\n  if (res == 0 && pipefd[0] >= 0 && pipefd[1] >= 0)\n    FdPipeCreate(thr, pc, pipefd[0], pipefd[1]);\n  return res;\n}\n#endif\n\nTSAN_INTERCEPTOR(int, unlink, char *path) {\n  SCOPED_TSAN_INTERCEPTOR(unlink, path);\n  Release(thr, pc, File2addr(path));\n  int res = REAL(unlink)(path);\n  return res;\n}\n\nTSAN_INTERCEPTOR(void*, tmpfile, int fake) {\n  SCOPED_TSAN_INTERCEPTOR(tmpfile, fake);\n  void *res = REAL(tmpfile)(fake);\n  if (res) {\n    int fd = fileno_unlocked(res);\n    if (fd >= 0)\n      FdFileCreate(thr, pc, fd);\n  }\n  return res;\n}\n\n#if SANITIZER_LINUX\nTSAN_INTERCEPTOR(void*, tmpfile64, int fake) {\n  SCOPED_TSAN_INTERCEPTOR(tmpfile64, fake);\n  void *res = REAL(tmpfile64)(fake);\n  if (res) {\n    int fd = fileno_unlocked(res);\n    if (fd >= 0)\n      FdFileCreate(thr, pc, fd);\n  }\n  return res;\n}\n#define TSAN_MAYBE_INTERCEPT_TMPFILE64 TSAN_INTERCEPT(tmpfile64)\n#else\n#define TSAN_MAYBE_INTERCEPT_TMPFILE64\n#endif\n\nstatic void FlushStreams() {\n  // Flushing all the streams here may freeze the process if a child thread is\n  // performing file stream operations at the same time.\n  REAL(fflush)(stdout);\n  REAL(fflush)(stderr);\n}\n\nTSAN_INTERCEPTOR(void, abort, int fake) {\n  SCOPED_TSAN_INTERCEPTOR(abort, fake);\n  FlushStreams();\n  REAL(abort)(fake);\n}\n\nTSAN_INTERCEPTOR(int, rmdir, char *path) {\n  SCOPED_TSAN_INTERCEPTOR(rmdir, path);\n  Release(thr, pc, Dir2addr(path));\n  int res = REAL(rmdir)(path);\n  return res;\n}\n\nTSAN_INTERCEPTOR(int, closedir, void *dirp) {\n  SCOPED_TSAN_INTERCEPTOR(closedir, dirp);\n  if (dirp) {\n    int fd = dirfd(dirp);\n    FdClose(thr, pc, fd);\n  }\n  return REAL(closedir)(dirp);\n}\n\n#if SANITIZER_LINUX\nTSAN_INTERCEPTOR(int, epoll_create, int size) {\n  SCOPED_TSAN_INTERCEPTOR(epoll_create, size);\n  int fd = REAL(epoll_create)(size);\n  if (fd >= 0)\n    FdPollCreate(thr, pc, fd);\n  return fd;\n}\n\nTSAN_INTERCEPTOR(int, epoll_create1, int flags) {\n  SCOPED_TSAN_INTERCEPTOR(epoll_create1, flags);\n  int fd = REAL(epoll_create1)(flags);\n  if (fd >= 0)\n    FdPollCreate(thr, pc, fd);\n  return fd;\n}\n\nTSAN_INTERCEPTOR(int, epoll_ctl, int epfd, int op, int fd, void *ev) {\n  SCOPED_TSAN_INTERCEPTOR(epoll_ctl, epfd, op, fd, ev);\n  if (epfd >= 0)\n    FdAccess(thr, pc, epfd);\n  if (epfd >= 0 && fd >= 0)\n    FdAccess(thr, pc, fd);\n  if (op == EPOLL_CTL_ADD && epfd >= 0)\n    FdRelease(thr, pc, epfd);\n  int res = REAL(epoll_ctl)(epfd, op, fd, ev);\n  return res;\n}\n\nTSAN_INTERCEPTOR(int, epoll_wait, int epfd, void *ev, int cnt, int timeout) {\n  SCOPED_TSAN_INTERCEPTOR(epoll_wait, epfd, ev, cnt, timeout);\n  if (epfd >= 0)\n    FdAccess(thr, pc, epfd);\n  int res = BLOCK_REAL(epoll_wait)(epfd, ev, cnt, timeout);\n  if (res > 0 && epfd >= 0)\n    FdAcquire(thr, pc, epfd);\n  return res;\n}\n\nTSAN_INTERCEPTOR(int, epoll_pwait, int epfd, void *ev, int cnt, int timeout,\n                 void *sigmask) {\n  SCOPED_TSAN_INTERCEPTOR(epoll_pwait, epfd, ev, cnt, timeout, sigmask);\n  if (epfd >= 0)\n    FdAccess(thr, pc, epfd);\n  int res = BLOCK_REAL(epoll_pwait)(epfd, ev, cnt, timeout, sigmask);\n  if (res > 0 && epfd >= 0)\n    FdAcquire(thr, pc, epfd);\n  return res;\n}\n\n#define TSAN_MAYBE_INTERCEPT_EPOLL \\\n    TSAN_INTERCEPT(epoll_create); \\\n    TSAN_INTERCEPT(epoll_create1); \\\n    TSAN_INTERCEPT(epoll_ctl); \\\n    TSAN_INTERCEPT(epoll_wait); \\\n    TSAN_INTERCEPT(epoll_pwait)\n#else\n#define TSAN_MAYBE_INTERCEPT_EPOLL\n#endif\n\n// The following functions are intercepted merely to process pending signals.\n// If program blocks signal X, we must deliver the signal before the function\n// returns. Similarly, if program unblocks a signal (or returns from sigsuspend)\n// it's better to deliver the signal straight away.\nTSAN_INTERCEPTOR(int, sigsuspend, const __sanitizer_sigset_t *mask) {\n  SCOPED_TSAN_INTERCEPTOR(sigsuspend, mask);\n  return REAL(sigsuspend)(mask);\n}\n\nTSAN_INTERCEPTOR(int, sigblock, int mask) {\n  SCOPED_TSAN_INTERCEPTOR(sigblock, mask);\n  return REAL(sigblock)(mask);\n}\n\nTSAN_INTERCEPTOR(int, sigsetmask, int mask) {\n  SCOPED_TSAN_INTERCEPTOR(sigsetmask, mask);\n  return REAL(sigsetmask)(mask);\n}\n\nTSAN_INTERCEPTOR(int, pthread_sigmask, int how, const __sanitizer_sigset_t *set,\n    __sanitizer_sigset_t *oldset) {\n  SCOPED_TSAN_INTERCEPTOR(pthread_sigmask, how, set, oldset);\n  return REAL(pthread_sigmask)(how, set, oldset);\n}\n\nnamespace __tsan {\n\nstatic void CallUserSignalHandler(ThreadState *thr, bool sync, bool acquire,\n                                  bool sigact, int sig,\n                                  __sanitizer_siginfo *info, void *uctx) {\n  __sanitizer_sigaction *sigactions = interceptor_ctx()->sigactions;\n  if (acquire)\n    Acquire(thr, 0, (uptr)&sigactions[sig]);\n  // Signals are generally asynchronous, so if we receive a signals when\n  // ignores are enabled we should disable ignores. This is critical for sync\n  // and interceptors, because otherwise we can miss syncronization and report\n  // false races.\n  int ignore_reads_and_writes = thr->ignore_reads_and_writes;\n  int ignore_interceptors = thr->ignore_interceptors;\n  int ignore_sync = thr->ignore_sync;\n  if (!ctx->after_multithreaded_fork) {\n    thr->ignore_reads_and_writes = 0;\n    thr->fast_state.ClearIgnoreBit();\n    thr->ignore_interceptors = 0;\n    thr->ignore_sync = 0;\n  }\n  // Ensure that the handler does not spoil errno.\n  const int saved_errno = errno;\n  errno = 99;\n  // This code races with sigaction. Be careful to not read sa_sigaction twice.\n  // Also need to remember pc for reporting before the call,\n  // because the handler can reset it.\n  volatile uptr pc =\n      sigact ? (uptr)sigactions[sig].sigaction : (uptr)sigactions[sig].handler;\n  if (pc != sig_dfl && pc != sig_ign) {\n    if (sigact)\n      ((__sanitizer_sigactionhandler_ptr)pc)(sig, info, uctx);\n    else\n      ((__sanitizer_sighandler_ptr)pc)(sig);\n  }\n  if (!ctx->after_multithreaded_fork) {\n    thr->ignore_reads_and_writes = ignore_reads_and_writes;\n    if (ignore_reads_and_writes)\n      thr->fast_state.SetIgnoreBit();\n    thr->ignore_interceptors = ignore_interceptors;\n    thr->ignore_sync = ignore_sync;\n  }\n  // We do not detect errno spoiling for SIGTERM,\n  // because some SIGTERM handlers do spoil errno but reraise SIGTERM,\n  // tsan reports false positive in such case.\n  // It's difficult to properly detect this situation (reraise),\n  // because in async signal processing case (when handler is called directly\n  // from rtl_generic_sighandler) we have not yet received the reraised\n  // signal; and it looks too fragile to intercept all ways to reraise a signal.\n  if (flags()->report_bugs && !sync && sig != SIGTERM && errno != 99) {\n    VarSizeStackTrace stack;\n    // StackTrace::GetNestInstructionPc(pc) is used because return address is\n    // expected, OutputReport() will undo this.\n    ObtainCurrentStack(thr, StackTrace::GetNextInstructionPc(pc), &stack);\n    ThreadRegistryLock l(ctx->thread_registry);\n    ScopedReport rep(ReportTypeErrnoInSignal);\n    if (!IsFiredSuppression(ctx, ReportTypeErrnoInSignal, stack)) {\n      rep.AddStack(stack, true);\n      OutputReport(thr, rep);\n    }\n  }\n  errno = saved_errno;\n}\n\nvoid ProcessPendingSignals(ThreadState *thr) {\n  ThreadSignalContext *sctx = SigCtx(thr);\n  if (sctx == 0 ||\n      atomic_load(&sctx->have_pending_signals, memory_order_relaxed) == 0)\n    return;\n  atomic_store(&sctx->have_pending_signals, 0, memory_order_relaxed);\n  atomic_fetch_add(&thr->in_signal_handler, 1, memory_order_relaxed);\n  internal_sigfillset(&sctx->emptyset);\n  int res = REAL(pthread_sigmask)(SIG_SETMASK, &sctx->emptyset, &sctx->oldset);\n  CHECK_EQ(res, 0);\n  for (int sig = 0; sig < kSigCount; sig++) {\n    SignalDesc *signal = &sctx->pending_signals[sig];\n    if (signal->armed) {\n      signal->armed = false;\n      CallUserSignalHandler(thr, false, true, signal->sigaction, sig,\n          &signal->siginfo, &signal->ctx);\n    }\n  }\n  res = REAL(pthread_sigmask)(SIG_SETMASK, &sctx->oldset, 0);\n  CHECK_EQ(res, 0);\n  atomic_fetch_add(&thr->in_signal_handler, -1, memory_order_relaxed);\n}\n\n}  // namespace __tsan\n\nstatic bool is_sync_signal(ThreadSignalContext *sctx, int sig) {\n  return sig == SIGSEGV || sig == SIGBUS || sig == SIGILL || sig == SIGTRAP ||\n         sig == SIGABRT || sig == SIGFPE || sig == SIGPIPE || sig == SIGSYS ||\n         // If we are sending signal to ourselves, we must process it now.\n         (sctx && sig == sctx->int_signal_send);\n}\n\nvoid ALWAYS_INLINE rtl_generic_sighandler(bool sigact, int sig,\n                                          __sanitizer_siginfo *info,\n                                          void *ctx) {\n  cur_thread_init();\n  ThreadState *thr = cur_thread();\n  ThreadSignalContext *sctx = SigCtx(thr);\n  if (sig < 0 || sig >= kSigCount) {\n    VPrintf(1, \"ThreadSanitizer: ignoring signal %d\\n\", sig);\n    return;\n  }\n  // Don't mess with synchronous signals.\n  const bool sync = is_sync_signal(sctx, sig);\n  if (sync ||\n      // If we are in blocking function, we can safely process it now\n      // (but check if we are in a recursive interceptor,\n      // i.e. pthread_join()->munmap()).\n      (sctx && atomic_load(&sctx->in_blocking_func, memory_order_relaxed))) {\n    atomic_fetch_add(&thr->in_signal_handler, 1, memory_order_relaxed);\n    if (sctx && atomic_load(&sctx->in_blocking_func, memory_order_relaxed)) {\n      atomic_store(&sctx->in_blocking_func, 0, memory_order_relaxed);\n      CallUserSignalHandler(thr, sync, true, sigact, sig, info, ctx);\n      atomic_store(&sctx->in_blocking_func, 1, memory_order_relaxed);\n    } else {\n      // Be very conservative with when we do acquire in this case.\n      // It's unsafe to do acquire in async handlers, because ThreadState\n      // can be in inconsistent state.\n      // SIGSYS looks relatively safe -- it's synchronous and can actually\n      // need some global state.\n      bool acq = (sig == SIGSYS);\n      CallUserSignalHandler(thr, sync, acq, sigact, sig, info, ctx);\n    }\n    atomic_fetch_add(&thr->in_signal_handler, -1, memory_order_relaxed);\n    return;\n  }\n\n  if (sctx == 0)\n    return;\n  SignalDesc *signal = &sctx->pending_signals[sig];\n  if (signal->armed == false) {\n    signal->armed = true;\n    signal->sigaction = sigact;\n    if (info)\n      internal_memcpy(&signal->siginfo, info, sizeof(*info));\n    if (ctx)\n      internal_memcpy(&signal->ctx, ctx, sizeof(signal->ctx));\n    atomic_store(&sctx->have_pending_signals, 1, memory_order_relaxed);\n  }\n}\n\nstatic void rtl_sighandler(int sig) {\n  rtl_generic_sighandler(false, sig, 0, 0);\n}\n\nstatic void rtl_sigaction(int sig, __sanitizer_siginfo *info, void *ctx) {\n  rtl_generic_sighandler(true, sig, info, ctx);\n}\n\nTSAN_INTERCEPTOR(int, raise, int sig) {\n  SCOPED_TSAN_INTERCEPTOR(raise, sig);\n  ThreadSignalContext *sctx = SigCtx(thr);\n  CHECK_NE(sctx, 0);\n  int prev = sctx->int_signal_send;\n  sctx->int_signal_send = sig;\n  int res = REAL(raise)(sig);\n  CHECK_EQ(sctx->int_signal_send, sig);\n  sctx->int_signal_send = prev;\n  return res;\n}\n\nTSAN_INTERCEPTOR(int, kill, int pid, int sig) {\n  SCOPED_TSAN_INTERCEPTOR(kill, pid, sig);\n  ThreadSignalContext *sctx = SigCtx(thr);\n  CHECK_NE(sctx, 0);\n  int prev = sctx->int_signal_send;\n  if (pid == (int)internal_getpid()) {\n    sctx->int_signal_send = sig;\n  }\n  int res = REAL(kill)(pid, sig);\n  if (pid == (int)internal_getpid()) {\n    CHECK_EQ(sctx->int_signal_send, sig);\n    sctx->int_signal_send = prev;\n  }\n  return res;\n}\n\nTSAN_INTERCEPTOR(int, pthread_kill, void *tid, int sig) {\n  SCOPED_TSAN_INTERCEPTOR(pthread_kill, tid, sig);\n  ThreadSignalContext *sctx = SigCtx(thr);\n  CHECK_NE(sctx, 0);\n  int prev = sctx->int_signal_send;\n  if (tid == pthread_self()) {\n    sctx->int_signal_send = sig;\n  }\n  int res = REAL(pthread_kill)(tid, sig);\n  if (tid == pthread_self()) {\n    CHECK_EQ(sctx->int_signal_send, sig);\n    sctx->int_signal_send = prev;\n  }\n  return res;\n}\n\nTSAN_INTERCEPTOR(int, gettimeofday, void *tv, void *tz) {\n  SCOPED_TSAN_INTERCEPTOR(gettimeofday, tv, tz);\n  // It's intercepted merely to process pending signals.\n  return REAL(gettimeofday)(tv, tz);\n}\n\nTSAN_INTERCEPTOR(int, getaddrinfo, void *node, void *service,\n    void *hints, void *rv) {\n  SCOPED_TSAN_INTERCEPTOR(getaddrinfo, node, service, hints, rv);\n  // We miss atomic synchronization in getaddrinfo,\n  // and can report false race between malloc and free\n  // inside of getaddrinfo. So ignore memory accesses.\n  ThreadIgnoreBegin(thr, pc);\n  int res = REAL(getaddrinfo)(node, service, hints, rv);\n  ThreadIgnoreEnd(thr, pc);\n  return res;\n}\n\nTSAN_INTERCEPTOR(int, fork, int fake) {\n  if (in_symbolizer())\n    return REAL(fork)(fake);\n  SCOPED_INTERCEPTOR_RAW(fork, fake);\n  ForkBefore(thr, pc);\n  int pid;\n  {\n    // On OS X, REAL(fork) can call intercepted functions (OSSpinLockLock), and\n    // we'll assert in CheckNoLocks() unless we ignore interceptors.\n    ScopedIgnoreInterceptors ignore;\n    pid = REAL(fork)(fake);\n  }\n  if (pid == 0) {\n    // child\n    ForkChildAfter(thr, pc);\n    FdOnFork(thr, pc);\n  } else if (pid > 0) {\n    // parent\n    ForkParentAfter(thr, pc);\n  } else {\n    // error\n    ForkParentAfter(thr, pc);\n  }\n  return pid;\n}\n\nTSAN_INTERCEPTOR(int, vfork, int fake) {\n  // Some programs (e.g. openjdk) call close for all file descriptors\n  // in the child process. Under tsan it leads to false positives, because\n  // address space is shared, so the parent process also thinks that\n  // the descriptors are closed (while they are actually not).\n  // This leads to false positives due to missed synchronization.\n  // Strictly saying this is undefined behavior, because vfork child is not\n  // allowed to call any functions other than exec/exit. But this is what\n  // openjdk does, so we want to handle it.\n  // We could disable interceptors in the child process. But it's not possible\n  // to simply intercept and wrap vfork, because vfork child is not allowed\n  // to return from the function that calls vfork, and that's exactly what\n  // we would do. So this would require some assembly trickery as well.\n  // Instead we simply turn vfork into fork.\n  return WRAP(fork)(fake);\n}\n\n#if !SANITIZER_MAC && !SANITIZER_ANDROID\ntypedef int (*dl_iterate_phdr_cb_t)(__sanitizer_dl_phdr_info *info, SIZE_T size,\n                                    void *data);\nstruct dl_iterate_phdr_data {\n  ThreadState *thr;\n  uptr pc;\n  dl_iterate_phdr_cb_t cb;\n  void *data;\n};\n\nstatic bool IsAppNotRodata(uptr addr) {\n  return IsAppMem(addr) && *(u64*)MemToShadow(addr) != kShadowRodata;\n}\n\nstatic int dl_iterate_phdr_cb(__sanitizer_dl_phdr_info *info, SIZE_T size,\n                              void *data) {\n  dl_iterate_phdr_data *cbdata = (dl_iterate_phdr_data *)data;\n  // dlopen/dlclose allocate/free dynamic-linker-internal memory, which is later\n  // accessible in dl_iterate_phdr callback. But we don't see synchronization\n  // inside of dynamic linker, so we \"unpoison\" it here in order to not\n  // produce false reports. Ignoring malloc/free in dlopen/dlclose is not enough\n  // because some libc functions call __libc_dlopen.\n  if (info && IsAppNotRodata((uptr)info->dlpi_name))\n    MemoryResetRange(cbdata->thr, cbdata->pc, (uptr)info->dlpi_name,\n                     internal_strlen(info->dlpi_name));\n  int res = cbdata->cb(info, size, cbdata->data);\n  // Perform the check one more time in case info->dlpi_name was overwritten\n  // by user callback.\n  if (info && IsAppNotRodata((uptr)info->dlpi_name))\n    MemoryResetRange(cbdata->thr, cbdata->pc, (uptr)info->dlpi_name,\n                     internal_strlen(info->dlpi_name));\n  return res;\n}\n\nTSAN_INTERCEPTOR(int, dl_iterate_phdr, dl_iterate_phdr_cb_t cb, void *data) {\n  SCOPED_TSAN_INTERCEPTOR(dl_iterate_phdr, cb, data);\n  dl_iterate_phdr_data cbdata;\n  cbdata.thr = thr;\n  cbdata.pc = pc;\n  cbdata.cb = cb;\n  cbdata.data = data;\n  int res = REAL(dl_iterate_phdr)(dl_iterate_phdr_cb, &cbdata);\n  return res;\n}\n#endif\n\nstatic int OnExit(ThreadState *thr) {\n  int status = Finalize(thr);\n  FlushStreams();\n  return status;\n}\n\nstruct TsanInterceptorContext {\n  ThreadState *thr;\n  const uptr caller_pc;\n  const uptr pc;\n};\n\n#if !SANITIZER_MAC\nstatic void HandleRecvmsg(ThreadState *thr, uptr pc,\n    __sanitizer_msghdr *msg) {\n  int fds[64];\n  int cnt = ExtractRecvmsgFDs(msg, fds, ARRAY_SIZE(fds));\n  for (int i = 0; i < cnt; i++)\n    FdEventCreate(thr, pc, fds[i]);\n}\n#endif\n\n#include \"sanitizer_common/sanitizer_platform_interceptors.h\"\n// Causes interceptor recursion (getaddrinfo() and fopen())\n#undef SANITIZER_INTERCEPT_GETADDRINFO\n// We define our own.\n#if SANITIZER_INTERCEPT_TLS_GET_ADDR\n#define NEED_TLS_GET_ADDR\n#endif\n#undef SANITIZER_INTERCEPT_TLS_GET_ADDR\n#undef SANITIZER_INTERCEPT_PTHREAD_SIGMASK\n\n#define COMMON_INTERCEPT_FUNCTION(name) INTERCEPT_FUNCTION(name)\n#define COMMON_INTERCEPT_FUNCTION_VER(name, ver)                          \\\n  INTERCEPT_FUNCTION_VER(name, ver)\n#define COMMON_INTERCEPT_FUNCTION_VER_UNVERSIONED_FALLBACK(name, ver) \\\n  (INTERCEPT_FUNCTION_VER(name, ver) || INTERCEPT_FUNCTION(name))\n\n#define COMMON_INTERCEPTOR_WRITE_RANGE(ctx, ptr, size)                    \\\n  MemoryAccessRange(((TsanInterceptorContext *)ctx)->thr,                 \\\n                    ((TsanInterceptorContext *)ctx)->pc, (uptr)ptr, size, \\\n                    true)\n\n#define COMMON_INTERCEPTOR_READ_RANGE(ctx, ptr, size)                       \\\n  MemoryAccessRange(((TsanInterceptorContext *) ctx)->thr,                  \\\n                    ((TsanInterceptorContext *) ctx)->pc, (uptr) ptr, size, \\\n                    false)\n\n#define COMMON_INTERCEPTOR_ENTER(ctx, func, ...)      \\\n  SCOPED_TSAN_INTERCEPTOR(func, __VA_ARGS__);         \\\n  TsanInterceptorContext _ctx = {thr, caller_pc, pc}; \\\n  ctx = (void *)&_ctx;                                \\\n  (void) ctx;\n\n#define COMMON_INTERCEPTOR_ENTER_NOIGNORE(ctx, func, ...) \\\n  SCOPED_INTERCEPTOR_RAW(func, __VA_ARGS__);              \\\n  TsanInterceptorContext _ctx = {thr, caller_pc, pc};     \\\n  ctx = (void *)&_ctx;                                    \\\n  (void) ctx;\n\n#define COMMON_INTERCEPTOR_FILE_OPEN(ctx, file, path) \\\n  if (path)                                           \\\n    Acquire(thr, pc, File2addr(path));                \\\n  if (file) {                                         \\\n    int fd = fileno_unlocked(file);                   \\\n    if (fd >= 0) FdFileCreate(thr, pc, fd);           \\\n  }\n\n#define COMMON_INTERCEPTOR_FILE_CLOSE(ctx, file) \\\n  if (file) {                                    \\\n    int fd = fileno_unlocked(file);              \\\n    if (fd >= 0) FdClose(thr, pc, fd);           \\\n  }\n\n#define COMMON_INTERCEPTOR_LIBRARY_LOADED(filename, handle) \\\n  libignore()->OnLibraryLoaded(filename)\n\n#define COMMON_INTERCEPTOR_LIBRARY_UNLOADED() \\\n  libignore()->OnLibraryUnloaded()\n\n#define COMMON_INTERCEPTOR_ACQUIRE(ctx, u) \\\n  Acquire(((TsanInterceptorContext *) ctx)->thr, pc, u)\n\n#define COMMON_INTERCEPTOR_RELEASE(ctx, u) \\\n  Release(((TsanInterceptorContext *) ctx)->thr, pc, u)\n\n#define COMMON_INTERCEPTOR_DIR_ACQUIRE(ctx, path) \\\n  Acquire(((TsanInterceptorContext *) ctx)->thr, pc, Dir2addr(path))\n\n#define COMMON_INTERCEPTOR_FD_ACQUIRE(ctx, fd) \\\n  FdAcquire(((TsanInterceptorContext *) ctx)->thr, pc, fd)\n\n#define COMMON_INTERCEPTOR_FD_RELEASE(ctx, fd) \\\n  FdRelease(((TsanInterceptorContext *) ctx)->thr, pc, fd)\n\n#define COMMON_INTERCEPTOR_FD_ACCESS(ctx, fd) \\\n  FdAccess(((TsanInterceptorContext *) ctx)->thr, pc, fd)\n\n#define COMMON_INTERCEPTOR_FD_SOCKET_ACCEPT(ctx, fd, newfd) \\\n  FdSocketAccept(((TsanInterceptorContext *) ctx)->thr, pc, fd, newfd)\n\n#define COMMON_INTERCEPTOR_SET_THREAD_NAME(ctx, name) \\\n  ThreadSetName(((TsanInterceptorContext *) ctx)->thr, name)\n\n#define COMMON_INTERCEPTOR_SET_PTHREAD_NAME(ctx, thread, name) \\\n  __tsan::ctx->thread_registry->SetThreadNameByUserId(thread, name)\n\n#define COMMON_INTERCEPTOR_BLOCK_REAL(name) BLOCK_REAL(name)\n\n#define COMMON_INTERCEPTOR_ON_EXIT(ctx) \\\n  OnExit(((TsanInterceptorContext *) ctx)->thr)\n\n#define COMMON_INTERCEPTOR_MUTEX_PRE_LOCK(ctx, m) \\\n  MutexPreLock(((TsanInterceptorContext *)ctx)->thr, \\\n            ((TsanInterceptorContext *)ctx)->pc, (uptr)m)\n\n#define COMMON_INTERCEPTOR_MUTEX_POST_LOCK(ctx, m) \\\n  MutexPostLock(((TsanInterceptorContext *)ctx)->thr, \\\n            ((TsanInterceptorContext *)ctx)->pc, (uptr)m)\n\n#define COMMON_INTERCEPTOR_MUTEX_UNLOCK(ctx, m) \\\n  MutexUnlock(((TsanInterceptorContext *)ctx)->thr, \\\n            ((TsanInterceptorContext *)ctx)->pc, (uptr)m)\n\n#define COMMON_INTERCEPTOR_MUTEX_REPAIR(ctx, m) \\\n  MutexRepair(((TsanInterceptorContext *)ctx)->thr, \\\n            ((TsanInterceptorContext *)ctx)->pc, (uptr)m)\n\n#define COMMON_INTERCEPTOR_MUTEX_INVALID(ctx, m) \\\n  MutexInvalidAccess(((TsanInterceptorContext *)ctx)->thr, \\\n                     ((TsanInterceptorContext *)ctx)->pc, (uptr)m)\n\n#define COMMON_INTERCEPTOR_MMAP_IMPL(ctx, mmap, addr, sz, prot, flags, fd,  \\\n                                     off)                                   \\\n  do {                                                                      \\\n    return mmap_interceptor(thr, pc, REAL(mmap), addr, sz, prot, flags, fd, \\\n                            off);                                           \\\n  } while (false)\n\n#if !SANITIZER_MAC\n#define COMMON_INTERCEPTOR_HANDLE_RECVMSG(ctx, msg) \\\n  HandleRecvmsg(((TsanInterceptorContext *)ctx)->thr, \\\n      ((TsanInterceptorContext *)ctx)->pc, msg)\n#endif\n\n#define COMMON_INTERCEPTOR_GET_TLS_RANGE(begin, end)                           \\\n  if (TsanThread *t = GetCurrentThread()) {                                    \\\n    *begin = t->tls_begin();                                                   \\\n    *end = t->tls_end();                                                       \\\n  } else {                                                                     \\\n    *begin = *end = 0;                                                         \\\n  }\n\n#define COMMON_INTERCEPTOR_USER_CALLBACK_START() \\\n  SCOPED_TSAN_INTERCEPTOR_USER_CALLBACK_START()\n\n#define COMMON_INTERCEPTOR_USER_CALLBACK_END() \\\n  SCOPED_TSAN_INTERCEPTOR_USER_CALLBACK_END()\n\n#include \"sanitizer_common/sanitizer_common_interceptors.inc\"\n\nstatic int sigaction_impl(int sig, const __sanitizer_sigaction *act,\n                          __sanitizer_sigaction *old);\nstatic __sanitizer_sighandler_ptr signal_impl(int sig,\n                                              __sanitizer_sighandler_ptr h);\n\n#define SIGNAL_INTERCEPTOR_SIGACTION_IMPL(signo, act, oldact) \\\n  { return sigaction_impl(signo, act, oldact); }\n\n#define SIGNAL_INTERCEPTOR_SIGNAL_IMPL(func, signo, handler) \\\n  { return (uptr)signal_impl(signo, (__sanitizer_sighandler_ptr)handler); }\n\n#include \"sanitizer_common/sanitizer_signal_interceptors.inc\"\n\nint sigaction_impl(int sig, const __sanitizer_sigaction *act,\n                   __sanitizer_sigaction *old) {\n  // Note: if we call REAL(sigaction) directly for any reason without proxying\n  // the signal handler through rtl_sigaction, very bad things will happen.\n  // The handler will run synchronously and corrupt tsan per-thread state.\n  SCOPED_INTERCEPTOR_RAW(sigaction, sig, act, old);\n  __sanitizer_sigaction *sigactions = interceptor_ctx()->sigactions;\n  __sanitizer_sigaction old_stored;\n  if (old) internal_memcpy(&old_stored, &sigactions[sig], sizeof(old_stored));\n  __sanitizer_sigaction newact;\n  if (act) {\n    // Copy act into sigactions[sig].\n    // Can't use struct copy, because compiler can emit call to memcpy.\n    // Can't use internal_memcpy, because it copies byte-by-byte,\n    // and signal handler reads the handler concurrently. It it can read\n    // some bytes from old value and some bytes from new value.\n    // Use volatile to prevent insertion of memcpy.\n    sigactions[sig].handler =\n        *(volatile __sanitizer_sighandler_ptr const *)&act->handler;\n    sigactions[sig].sa_flags = *(volatile int const *)&act->sa_flags;\n    internal_memcpy(&sigactions[sig].sa_mask, &act->sa_mask,\n                    sizeof(sigactions[sig].sa_mask));\n#if !SANITIZER_FREEBSD && !SANITIZER_MAC && !SANITIZER_NETBSD\n    sigactions[sig].sa_restorer = act->sa_restorer;\n#endif\n    internal_memcpy(&newact, act, sizeof(newact));\n    internal_sigfillset(&newact.sa_mask);\n    if ((uptr)act->handler != sig_ign && (uptr)act->handler != sig_dfl) {\n      if (newact.sa_flags & SA_SIGINFO)\n        newact.sigaction = rtl_sigaction;\n      else\n        newact.handler = rtl_sighandler;\n    }\n    ReleaseStore(thr, pc, (uptr)&sigactions[sig]);\n    act = &newact;\n  }\n  int res = REAL(sigaction)(sig, act, old);\n  if (res == 0 && old) {\n    uptr cb = (uptr)old->sigaction;\n    if (cb == (uptr)rtl_sigaction || cb == (uptr)rtl_sighandler) {\n      internal_memcpy(old, &old_stored, sizeof(*old));\n    }\n  }\n  return res;\n}\n\nstatic __sanitizer_sighandler_ptr signal_impl(int sig,\n                                              __sanitizer_sighandler_ptr h) {\n  __sanitizer_sigaction act;\n  act.handler = h;\n  internal_memset(&act.sa_mask, -1, sizeof(act.sa_mask));\n  act.sa_flags = 0;\n  __sanitizer_sigaction old;\n  int res = sigaction_symname(sig, &act, &old);\n  if (res) return (__sanitizer_sighandler_ptr)sig_err;\n  return old.handler;\n}\n\n#define TSAN_SYSCALL() \\\n  ThreadState *thr = cur_thread(); \\\n  if (thr->ignore_interceptors) \\\n    return; \\\n  ScopedSyscall scoped_syscall(thr) \\\n/**/\n\nstruct ScopedSyscall {\n  ThreadState *thr;\n\n  explicit ScopedSyscall(ThreadState *thr)\n      : thr(thr) {\n    Initialize(thr);\n  }\n\n  ~ScopedSyscall() {\n    ProcessPendingSignals(thr);\n  }\n};\n\n#if !SANITIZER_FREEBSD && !SANITIZER_MAC\nstatic void syscall_access_range(uptr pc, uptr p, uptr s, bool write) {\n  TSAN_SYSCALL();\n  MemoryAccessRange(thr, pc, p, s, write);\n}\n\nstatic USED void syscall_acquire(uptr pc, uptr addr) {\n  TSAN_SYSCALL();\n  Acquire(thr, pc, addr);\n  DPrintf(\"syscall_acquire(%p)\\n\", addr);\n}\n\nstatic USED void syscall_release(uptr pc, uptr addr) {\n  TSAN_SYSCALL();\n  DPrintf(\"syscall_release(%p)\\n\", addr);\n  Release(thr, pc, addr);\n}\n\nstatic void syscall_fd_close(uptr pc, int fd) {\n  TSAN_SYSCALL();\n  FdClose(thr, pc, fd);\n}\n\nstatic USED void syscall_fd_acquire(uptr pc, int fd) {\n  TSAN_SYSCALL();\n  FdAcquire(thr, pc, fd);\n  DPrintf(\"syscall_fd_acquire(%p)\\n\", fd);\n}\n\nstatic USED void syscall_fd_release(uptr pc, int fd) {\n  TSAN_SYSCALL();\n  DPrintf(\"syscall_fd_release(%p)\\n\", fd);\n  FdRelease(thr, pc, fd);\n}\n\nstatic void syscall_pre_fork(uptr pc) {\n  TSAN_SYSCALL();\n  ForkBefore(thr, pc);\n}\n\nstatic void syscall_post_fork(uptr pc, int pid) {\n  TSAN_SYSCALL();\n  if (pid == 0) {\n    // child\n    ForkChildAfter(thr, pc);\n    FdOnFork(thr, pc);\n  } else if (pid > 0) {\n    // parent\n    ForkParentAfter(thr, pc);\n  } else {\n    // error\n    ForkParentAfter(thr, pc);\n  }\n}\n#endif\n\n#define COMMON_SYSCALL_PRE_READ_RANGE(p, s) \\\n  syscall_access_range(GET_CALLER_PC(), (uptr)(p), (uptr)(s), false)\n\n#define COMMON_SYSCALL_PRE_WRITE_RANGE(p, s) \\\n  syscall_access_range(GET_CALLER_PC(), (uptr)(p), (uptr)(s), true)\n\n#define COMMON_SYSCALL_POST_READ_RANGE(p, s) \\\n  do {                                       \\\n    (void)(p);                               \\\n    (void)(s);                               \\\n  } while (false)\n\n#define COMMON_SYSCALL_POST_WRITE_RANGE(p, s) \\\n  do {                                        \\\n    (void)(p);                                \\\n    (void)(s);                                \\\n  } while (false)\n\n#define COMMON_SYSCALL_ACQUIRE(addr) \\\n    syscall_acquire(GET_CALLER_PC(), (uptr)(addr))\n\n#define COMMON_SYSCALL_RELEASE(addr) \\\n    syscall_release(GET_CALLER_PC(), (uptr)(addr))\n\n#define COMMON_SYSCALL_FD_CLOSE(fd) syscall_fd_close(GET_CALLER_PC(), fd)\n\n#define COMMON_SYSCALL_FD_ACQUIRE(fd) syscall_fd_acquire(GET_CALLER_PC(), fd)\n\n#define COMMON_SYSCALL_FD_RELEASE(fd) syscall_fd_release(GET_CALLER_PC(), fd)\n\n#define COMMON_SYSCALL_PRE_FORK() \\\n  syscall_pre_fork(GET_CALLER_PC())\n\n#define COMMON_SYSCALL_POST_FORK(res) \\\n  syscall_post_fork(GET_CALLER_PC(), res)\n\n#include \"sanitizer_common/sanitizer_common_syscalls.inc\"\n#include \"sanitizer_common/sanitizer_syscalls_netbsd.inc\"\n\n#ifdef NEED_TLS_GET_ADDR\n// Define own interceptor instead of sanitizer_common's for three reasons:\n// 1. It must not process pending signals.\n//    Signal handlers may contain MOVDQA instruction (see below).\n// 2. It must be as simple as possible to not contain MOVDQA.\n// 3. Sanitizer_common version uses COMMON_INTERCEPTOR_INITIALIZE_RANGE which\n//    is empty for tsan (meant only for msan).\n// Note: __tls_get_addr can be called with mis-aligned stack due to:\n// https://gcc.gnu.org/bugzilla/show_bug.cgi?id=58066\n// So the interceptor must work with mis-aligned stack, in particular, does not\n// execute MOVDQA with stack addresses.\nTSAN_INTERCEPTOR(void *, __tls_get_addr, void *arg) {\n  void *res = REAL(__tls_get_addr)(arg);\n  ThreadState *thr = cur_thread();\n  if (!thr)\n    return res;\n  DTLS::DTV *dtv = DTLS_on_tls_get_addr(arg, res, thr->tls_addr,\n                                        thr->tls_addr + thr->tls_size);\n  if (!dtv)\n    return res;\n  // New DTLS block has been allocated.\n  MemoryResetRange(thr, 0, dtv->beg, dtv->size);\n  return res;\n}\n#endif\n\n#if SANITIZER_NETBSD\nTSAN_INTERCEPTOR(void, _lwp_exit) {\n  SCOPED_TSAN_INTERCEPTOR(_lwp_exit);\n  DestroyThreadState();\n  REAL(_lwp_exit)();\n}\n#define TSAN_MAYBE_INTERCEPT__LWP_EXIT TSAN_INTERCEPT(_lwp_exit)\n#else\n#define TSAN_MAYBE_INTERCEPT__LWP_EXIT\n#endif\n\n#if SANITIZER_FREEBSD\nTSAN_INTERCEPTOR(void, thr_exit, tid_t *state) {\n  SCOPED_TSAN_INTERCEPTOR(thr_exit, state);\n  DestroyThreadState();\n  REAL(thr_exit(state));\n}\n#define TSAN_MAYBE_INTERCEPT_THR_EXIT TSAN_INTERCEPT(thr_exit)\n#else\n#define TSAN_MAYBE_INTERCEPT_THR_EXIT\n#endif\n\nTSAN_INTERCEPTOR_NETBSD_ALIAS(int, cond_init, void *c, void *a)\nTSAN_INTERCEPTOR_NETBSD_ALIAS(int, cond_signal, void *c)\nTSAN_INTERCEPTOR_NETBSD_ALIAS(int, cond_broadcast, void *c)\nTSAN_INTERCEPTOR_NETBSD_ALIAS(int, cond_wait, void *c, void *m)\nTSAN_INTERCEPTOR_NETBSD_ALIAS(int, cond_destroy, void *c)\nTSAN_INTERCEPTOR_NETBSD_ALIAS(int, mutex_init, void *m, void *a)\nTSAN_INTERCEPTOR_NETBSD_ALIAS(int, mutex_destroy, void *m)\nTSAN_INTERCEPTOR_NETBSD_ALIAS(int, mutex_trylock, void *m)\nTSAN_INTERCEPTOR_NETBSD_ALIAS(int, rwlock_init, void *m, void *a)\nTSAN_INTERCEPTOR_NETBSD_ALIAS(int, rwlock_destroy, void *m)\nTSAN_INTERCEPTOR_NETBSD_ALIAS(int, rwlock_rdlock, void *m)\nTSAN_INTERCEPTOR_NETBSD_ALIAS(int, rwlock_tryrdlock, void *m)\nTSAN_INTERCEPTOR_NETBSD_ALIAS(int, rwlock_wrlock, void *m)\nTSAN_INTERCEPTOR_NETBSD_ALIAS(int, rwlock_trywrlock, void *m)\nTSAN_INTERCEPTOR_NETBSD_ALIAS(int, rwlock_unlock, void *m)\nTSAN_INTERCEPTOR_NETBSD_ALIAS_THR(int, once, void *o, void (*f)())\nTSAN_INTERCEPTOR_NETBSD_ALIAS_THR2(int, sigsetmask, sigmask, int a, void *b,\n  void *c)\n\nnamespace __tsan {\n\nstatic void finalize(void *arg) {\n  ThreadState *thr = cur_thread();\n  int status = Finalize(thr);\n  // Make sure the output is not lost.\n  FlushStreams();\n  if (status)\n    Die();\n}\n\n#if !SANITIZER_MAC && !SANITIZER_ANDROID\nstatic void unreachable() {\n  Report(\"FATAL: ThreadSanitizer: unreachable called\\n\");\n  Die();\n}\n#endif\n\n// Define default implementation since interception of libdispatch  is optional.\nSANITIZER_WEAK_ATTRIBUTE void InitializeLibdispatchInterceptors() {}\n\nvoid InitializeInterceptors() {\n#if !SANITIZER_MAC\n  // We need to setup it early, because functions like dlsym() can call it.\n  REAL(memset) = internal_memset;\n  REAL(memcpy) = internal_memcpy;\n#endif\n\n  // Instruct libc malloc to consume less memory.\n#if SANITIZER_GLIBC\n  mallopt(1, 0);  // M_MXFAST\n  mallopt(-3, 32*1024);  // M_MMAP_THRESHOLD\n#endif\n\n  new(interceptor_ctx()) InterceptorContext();\n\n  InitializeCommonInterceptors();\n  InitializeSignalInterceptors();\n  InitializeLibdispatchInterceptors();\n\n#if !SANITIZER_MAC\n  // We can not use TSAN_INTERCEPT to get setjmp addr,\n  // because it does &setjmp and setjmp is not present in some versions of libc.\n  using __interception::InterceptFunction;\n  InterceptFunction(TSAN_STRING_SETJMP, (uptr*)&REAL(setjmp_symname), 0, 0);\n  InterceptFunction(\"_setjmp\", (uptr*)&REAL(_setjmp), 0, 0);\n  InterceptFunction(TSAN_STRING_SIGSETJMP, (uptr*)&REAL(sigsetjmp_symname), 0,\n                    0);\n#if !SANITIZER_NETBSD\n  InterceptFunction(\"__sigsetjmp\", (uptr*)&REAL(__sigsetjmp), 0, 0);\n#endif\n#endif\n\n  TSAN_INTERCEPT(longjmp_symname);\n  TSAN_INTERCEPT(siglongjmp_symname);\n#if SANITIZER_NETBSD\n  TSAN_INTERCEPT(_longjmp);\n#endif\n\n  TSAN_INTERCEPT(malloc);\n  TSAN_INTERCEPT(__libc_memalign);\n  TSAN_INTERCEPT(calloc);\n  TSAN_INTERCEPT(realloc);\n  TSAN_INTERCEPT(reallocarray);\n  TSAN_INTERCEPT(free);\n  TSAN_INTERCEPT(cfree);\n  TSAN_INTERCEPT(munmap);\n  TSAN_MAYBE_INTERCEPT_MEMALIGN;\n  TSAN_INTERCEPT(valloc);\n  TSAN_MAYBE_INTERCEPT_PVALLOC;\n  TSAN_INTERCEPT(posix_memalign);\n\n  TSAN_INTERCEPT(strcpy);\n  TSAN_INTERCEPT(strncpy);\n  TSAN_INTERCEPT(strdup);\n\n  TSAN_INTERCEPT(pthread_create);\n  TSAN_INTERCEPT(pthread_join);\n  TSAN_INTERCEPT(pthread_detach);\n  TSAN_INTERCEPT(pthread_exit);\n  #if SANITIZER_LINUX\n  TSAN_INTERCEPT(pthread_tryjoin_np);\n  TSAN_INTERCEPT(pthread_timedjoin_np);\n  #endif\n\n  TSAN_INTERCEPT_VER(pthread_cond_init, PTHREAD_ABI_BASE);\n  TSAN_INTERCEPT_VER(pthread_cond_signal, PTHREAD_ABI_BASE);\n  TSAN_INTERCEPT_VER(pthread_cond_broadcast, PTHREAD_ABI_BASE);\n  TSAN_INTERCEPT_VER(pthread_cond_wait, PTHREAD_ABI_BASE);\n  TSAN_INTERCEPT_VER(pthread_cond_timedwait, PTHREAD_ABI_BASE);\n  TSAN_INTERCEPT_VER(pthread_cond_destroy, PTHREAD_ABI_BASE);\n\n  TSAN_MAYBE_PTHREAD_COND_CLOCKWAIT;\n\n  TSAN_INTERCEPT(pthread_mutex_init);\n  TSAN_INTERCEPT(pthread_mutex_destroy);\n  TSAN_INTERCEPT(pthread_mutex_trylock);\n  TSAN_INTERCEPT(pthread_mutex_timedlock);\n\n  TSAN_INTERCEPT(pthread_spin_init);\n  TSAN_INTERCEPT(pthread_spin_destroy);\n  TSAN_INTERCEPT(pthread_spin_lock);\n  TSAN_INTERCEPT(pthread_spin_trylock);\n  TSAN_INTERCEPT(pthread_spin_unlock);\n\n  TSAN_INTERCEPT(pthread_rwlock_init);\n  TSAN_INTERCEPT(pthread_rwlock_destroy);\n  TSAN_INTERCEPT(pthread_rwlock_rdlock);\n  TSAN_INTERCEPT(pthread_rwlock_tryrdlock);\n  TSAN_INTERCEPT(pthread_rwlock_timedrdlock);\n  TSAN_INTERCEPT(pthread_rwlock_wrlock);\n  TSAN_INTERCEPT(pthread_rwlock_trywrlock);\n  TSAN_INTERCEPT(pthread_rwlock_timedwrlock);\n  TSAN_INTERCEPT(pthread_rwlock_unlock);\n\n  TSAN_INTERCEPT(pthread_barrier_init);\n  TSAN_INTERCEPT(pthread_barrier_destroy);\n  TSAN_INTERCEPT(pthread_barrier_wait);\n\n  TSAN_INTERCEPT(pthread_once);\n\n  TSAN_INTERCEPT(fstat);\n  TSAN_MAYBE_INTERCEPT___FXSTAT;\n  TSAN_MAYBE_INTERCEPT_FSTAT64;\n  TSAN_MAYBE_INTERCEPT___FXSTAT64;\n  TSAN_INTERCEPT(open);\n  TSAN_MAYBE_INTERCEPT_OPEN64;\n  TSAN_INTERCEPT(creat);\n  TSAN_MAYBE_INTERCEPT_CREAT64;\n  TSAN_INTERCEPT(dup);\n  TSAN_INTERCEPT(dup2);\n  TSAN_INTERCEPT(dup3);\n  TSAN_MAYBE_INTERCEPT_EVENTFD;\n  TSAN_MAYBE_INTERCEPT_SIGNALFD;\n  TSAN_MAYBE_INTERCEPT_INOTIFY_INIT;\n  TSAN_MAYBE_INTERCEPT_INOTIFY_INIT1;\n  TSAN_INTERCEPT(socket);\n  TSAN_INTERCEPT(socketpair);\n  TSAN_INTERCEPT(connect);\n  TSAN_INTERCEPT(bind);\n  TSAN_INTERCEPT(listen);\n  TSAN_MAYBE_INTERCEPT_EPOLL;\n  TSAN_INTERCEPT(close);\n  TSAN_MAYBE_INTERCEPT___CLOSE;\n  TSAN_MAYBE_INTERCEPT___RES_ICLOSE;\n  TSAN_INTERCEPT(pipe);\n  TSAN_INTERCEPT(pipe2);\n\n  TSAN_INTERCEPT(unlink);\n  TSAN_INTERCEPT(tmpfile);\n  TSAN_MAYBE_INTERCEPT_TMPFILE64;\n  TSAN_INTERCEPT(abort);\n  TSAN_INTERCEPT(rmdir);\n  TSAN_INTERCEPT(closedir);\n\n  TSAN_INTERCEPT(sigsuspend);\n  TSAN_INTERCEPT(sigblock);\n  TSAN_INTERCEPT(sigsetmask);\n  TSAN_INTERCEPT(pthread_sigmask);\n  TSAN_INTERCEPT(raise);\n  TSAN_INTERCEPT(kill);\n  TSAN_INTERCEPT(pthread_kill);\n  TSAN_INTERCEPT(sleep);\n  TSAN_INTERCEPT(usleep);\n  TSAN_INTERCEPT(nanosleep);\n  TSAN_INTERCEPT(pause);\n  TSAN_INTERCEPT(gettimeofday);\n  TSAN_INTERCEPT(getaddrinfo);\n\n  TSAN_INTERCEPT(fork);\n  TSAN_INTERCEPT(vfork);\n#if !SANITIZER_ANDROID\n  TSAN_INTERCEPT(dl_iterate_phdr);\n#endif\n  TSAN_MAYBE_INTERCEPT_ON_EXIT;\n  TSAN_INTERCEPT(__cxa_atexit);\n  TSAN_INTERCEPT(_exit);\n\n#ifdef NEED_TLS_GET_ADDR\n  TSAN_INTERCEPT(__tls_get_addr);\n#endif\n\n  TSAN_MAYBE_INTERCEPT__LWP_EXIT;\n  TSAN_MAYBE_INTERCEPT_THR_EXIT;\n\n#if !SANITIZER_MAC && !SANITIZER_ANDROID\n  // Need to setup it, because interceptors check that the function is resolved.\n  // But atexit is emitted directly into the module, so can't be resolved.\n  REAL(atexit) = (int(*)(void(*)()))unreachable;\n#endif\n\n  if (REAL(__cxa_atexit)(&finalize, 0, 0)) {\n    Printf(\"ThreadSanitizer: failed to setup atexit callback\\n\");\n    Die();\n  }\n\n#if !SANITIZER_MAC && !SANITIZER_NETBSD && !SANITIZER_FREEBSD\n  if (pthread_key_create(&interceptor_ctx()->finalize_key, &thread_finalize)) {\n    Printf(\"ThreadSanitizer: failed to create thread key\\n\");\n    Die();\n  }\n#endif\n\n  TSAN_MAYBE_INTERCEPT_NETBSD_ALIAS(cond_init);\n  TSAN_MAYBE_INTERCEPT_NETBSD_ALIAS(cond_signal);\n  TSAN_MAYBE_INTERCEPT_NETBSD_ALIAS(cond_broadcast);\n  TSAN_MAYBE_INTERCEPT_NETBSD_ALIAS(cond_wait);\n  TSAN_MAYBE_INTERCEPT_NETBSD_ALIAS(cond_destroy);\n  TSAN_MAYBE_INTERCEPT_NETBSD_ALIAS(mutex_init);\n  TSAN_MAYBE_INTERCEPT_NETBSD_ALIAS(mutex_destroy);\n  TSAN_MAYBE_INTERCEPT_NETBSD_ALIAS(mutex_trylock);\n  TSAN_MAYBE_INTERCEPT_NETBSD_ALIAS(rwlock_init);\n  TSAN_MAYBE_INTERCEPT_NETBSD_ALIAS(rwlock_destroy);\n  TSAN_MAYBE_INTERCEPT_NETBSD_ALIAS(rwlock_rdlock);\n  TSAN_MAYBE_INTERCEPT_NETBSD_ALIAS(rwlock_tryrdlock);\n  TSAN_MAYBE_INTERCEPT_NETBSD_ALIAS(rwlock_wrlock);\n  TSAN_MAYBE_INTERCEPT_NETBSD_ALIAS(rwlock_trywrlock);\n  TSAN_MAYBE_INTERCEPT_NETBSD_ALIAS(rwlock_unlock);\n  TSAN_MAYBE_INTERCEPT_NETBSD_ALIAS_THR(once);\n  TSAN_MAYBE_INTERCEPT_NETBSD_ALIAS_THR(sigsetmask);\n\n  FdInit();\n}\n\n}  // namespace __tsan\n\n// Invisible barrier for tests.\n// There were several unsuccessful iterations for this functionality:\n// 1. Initially it was implemented in user code using\n//    REAL(pthread_barrier_wait). But pthread_barrier_wait is not supported on\n//    MacOS. Futexes are linux-specific for this matter.\n// 2. Then we switched to atomics+usleep(10). But usleep produced parasitic\n//    \"as-if synchronized via sleep\" messages in reports which failed some\n//    output tests.\n// 3. Then we switched to atomics+sched_yield. But this produced tons of tsan-\n//    visible events, which lead to \"failed to restore stack trace\" failures.\n// Note that no_sanitize_thread attribute does not turn off atomic interception\n// so attaching it to the function defined in user code does not help.\n// That's why we now have what we have.\nextern \"C\" SANITIZER_INTERFACE_ATTRIBUTE\nvoid __tsan_testonly_barrier_init(u64 *barrier, u32 count) {\n  if (count >= (1 << 8)) {\n      Printf(\"barrier_init: count is too large (%d)\\n\", count);\n      Die();\n  }\n  // 8 lsb is thread count, the remaining are count of entered threads.\n  *barrier = count;\n}\n\nextern \"C\" SANITIZER_INTERFACE_ATTRIBUTE\nvoid __tsan_testonly_barrier_wait(u64 *barrier) {\n  unsigned old = __atomic_fetch_add(barrier, 1 << 8, __ATOMIC_RELAXED);\n  unsigned old_epoch = (old >> 8) / (old & 0xff);\n  for (;;) {\n    unsigned cur = __atomic_load_n(barrier, __ATOMIC_RELAXED);\n    unsigned cur_epoch = (cur >> 8) / (cur & 0xff);\n    if (cur_epoch != old_epoch)\n      return;\n    internal_sched_yield();\n  }\n}\n"}, "18": {"id": 18, "path": "/home/vsts/work/1/llvm-project/compiler-rt/lib/sanitizer_common/sanitizer_common_interceptors.inc", "content": "//===-- sanitizer_common_interceptors.inc -----------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// Common function interceptors for tools like AddressSanitizer,\n// ThreadSanitizer, MemorySanitizer, etc.\n//\n// This file should be included into the tool's interceptor file,\n// which has to define its own macros:\n//   COMMON_INTERCEPTOR_ENTER\n//   COMMON_INTERCEPTOR_ENTER_NOIGNORE\n//   COMMON_INTERCEPTOR_READ_RANGE\n//   COMMON_INTERCEPTOR_WRITE_RANGE\n//   COMMON_INTERCEPTOR_INITIALIZE_RANGE\n//   COMMON_INTERCEPTOR_DIR_ACQUIRE\n//   COMMON_INTERCEPTOR_FD_ACQUIRE\n//   COMMON_INTERCEPTOR_FD_RELEASE\n//   COMMON_INTERCEPTOR_FD_ACCESS\n//   COMMON_INTERCEPTOR_SET_THREAD_NAME\n//   COMMON_INTERCEPTOR_ON_DLOPEN\n//   COMMON_INTERCEPTOR_ON_EXIT\n//   COMMON_INTERCEPTOR_MUTEX_PRE_LOCK\n//   COMMON_INTERCEPTOR_MUTEX_POST_LOCK\n//   COMMON_INTERCEPTOR_MUTEX_UNLOCK\n//   COMMON_INTERCEPTOR_MUTEX_REPAIR\n//   COMMON_INTERCEPTOR_SET_PTHREAD_NAME\n//   COMMON_INTERCEPTOR_HANDLE_RECVMSG\n//   COMMON_INTERCEPTOR_NOTHING_IS_INITIALIZED\n//   COMMON_INTERCEPTOR_MEMSET_IMPL\n//   COMMON_INTERCEPTOR_MEMMOVE_IMPL\n//   COMMON_INTERCEPTOR_MEMCPY_IMPL\n//   COMMON_INTERCEPTOR_MMAP_IMPL\n//   COMMON_INTERCEPTOR_COPY_STRING\n//   COMMON_INTERCEPTOR_STRNDUP_IMPL\n//   COMMON_INTERCEPTOR_STRERROR\n//===----------------------------------------------------------------------===//\n\n#include \"interception/interception.h\"\n#include \"sanitizer_addrhashmap.h\"\n#include \"sanitizer_errno.h\"\n#include \"sanitizer_placement_new.h\"\n#include \"sanitizer_platform_interceptors.h\"\n#include \"sanitizer_symbolizer.h\"\n#include \"sanitizer_tls_get_addr.h\"\n\n#include <stdarg.h>\n\n#if SANITIZER_INTERCEPTOR_HOOKS\n#define CALL_WEAK_INTERCEPTOR_HOOK(f, ...) f(__VA_ARGS__);\n#define DECLARE_WEAK_INTERCEPTOR_HOOK(f, ...) \\\n  SANITIZER_INTERFACE_WEAK_DEF(void, f, __VA_ARGS__) {}\n#else\n#define DECLARE_WEAK_INTERCEPTOR_HOOK(f, ...)\n#define CALL_WEAK_INTERCEPTOR_HOOK(f, ...)\n\n#endif  // SANITIZER_INTERCEPTOR_HOOKS\n\n#if SANITIZER_WINDOWS && !defined(va_copy)\n#define va_copy(dst, src) ((dst) = (src))\n#endif // _WIN32\n\n#if SANITIZER_FREEBSD\n#define pthread_setname_np pthread_set_name_np\n#define inet_aton __inet_aton\n#define inet_pton __inet_pton\n#define iconv __bsd_iconv\n#endif\n\n#if SANITIZER_NETBSD\n#define clock_getres __clock_getres50\n#define clock_gettime __clock_gettime50\n#define clock_settime __clock_settime50\n#define ctime __ctime50\n#define ctime_r __ctime_r50\n#define devname __devname50\n#define fgetpos __fgetpos50\n#define fsetpos __fsetpos50\n#define fstatvfs __fstatvfs90\n#define fstatvfs1 __fstatvfs190\n#define fts_children __fts_children60\n#define fts_close __fts_close60\n#define fts_open __fts_open60\n#define fts_read __fts_read60\n#define fts_set __fts_set60\n#define getitimer __getitimer50\n#define getmntinfo __getmntinfo90\n#define getpwent __getpwent50\n#define getpwnam __getpwnam50\n#define getpwnam_r __getpwnam_r50\n#define getpwuid __getpwuid50\n#define getpwuid_r __getpwuid_r50\n#define getutent __getutent50\n#define getutxent __getutxent50\n#define getutxid __getutxid50\n#define getutxline __getutxline50\n#define getvfsstat __getvfsstat90\n#define pututxline __pututxline50\n#define glob __glob30\n#define gmtime __gmtime50\n#define gmtime_r __gmtime_r50\n#define localtime __locatime50\n#define localtime_r __localtime_r50\n#define mktime __mktime50\n#define lstat __lstat50\n#define opendir __opendir30\n#define readdir __readdir30\n#define readdir_r __readdir_r30\n#define scandir __scandir30\n#define setitimer __setitimer50\n#define setlocale __setlocale50\n#define shmctl __shmctl50\n#define sigaltstack __sigaltstack14\n#define sigemptyset __sigemptyset14\n#define sigfillset __sigfillset14\n#define sigpending __sigpending14\n#define sigprocmask __sigprocmask14\n#define sigtimedwait __sigtimedwait50\n#define stat __stat50\n#define statvfs __statvfs90\n#define statvfs1 __statvfs190\n#define time __time50\n#define times __times13\n#define unvis __unvis50\n#define wait3 __wait350\n#define wait4 __wait450\nextern const unsigned short *_ctype_tab_;\nextern const short *_toupper_tab_;\nextern const short *_tolower_tab_;\n#endif\n\n// Platform-specific options.\n#if SANITIZER_MAC\n#define PLATFORM_HAS_DIFFERENT_MEMCPY_AND_MEMMOVE false\n#elif SANITIZER_WINDOWS64\n#define PLATFORM_HAS_DIFFERENT_MEMCPY_AND_MEMMOVE false\n#else\n#define PLATFORM_HAS_DIFFERENT_MEMCPY_AND_MEMMOVE true\n#endif  // SANITIZER_MAC\n\n#ifndef COMMON_INTERCEPTOR_INITIALIZE_RANGE\n#define COMMON_INTERCEPTOR_INITIALIZE_RANGE(p, size) {}\n#endif\n\n#ifndef COMMON_INTERCEPTOR_UNPOISON_PARAM\n#define COMMON_INTERCEPTOR_UNPOISON_PARAM(count) {}\n#endif\n\n#ifndef COMMON_INTERCEPTOR_FD_ACCESS\n#define COMMON_INTERCEPTOR_FD_ACCESS(ctx, fd) {}\n#endif\n\n#ifndef COMMON_INTERCEPTOR_MUTEX_PRE_LOCK\n#define COMMON_INTERCEPTOR_MUTEX_PRE_LOCK(ctx, m) {}\n#endif\n\n#ifndef COMMON_INTERCEPTOR_MUTEX_POST_LOCK\n#define COMMON_INTERCEPTOR_MUTEX_POST_LOCK(ctx, m) {}\n#endif\n\n#ifndef COMMON_INTERCEPTOR_MUTEX_UNLOCK\n#define COMMON_INTERCEPTOR_MUTEX_UNLOCK(ctx, m) {}\n#endif\n\n#ifndef COMMON_INTERCEPTOR_MUTEX_REPAIR\n#define COMMON_INTERCEPTOR_MUTEX_REPAIR(ctx, m) {}\n#endif\n\n#ifndef COMMON_INTERCEPTOR_MUTEX_INVALID\n#define COMMON_INTERCEPTOR_MUTEX_INVALID(ctx, m) {}\n#endif\n\n#ifndef COMMON_INTERCEPTOR_HANDLE_RECVMSG\n#define COMMON_INTERCEPTOR_HANDLE_RECVMSG(ctx, msg) ((void)(msg))\n#endif\n\n#ifndef COMMON_INTERCEPTOR_FILE_OPEN\n#define COMMON_INTERCEPTOR_FILE_OPEN(ctx, file, path) {}\n#endif\n\n#ifndef COMMON_INTERCEPTOR_FILE_CLOSE\n#define COMMON_INTERCEPTOR_FILE_CLOSE(ctx, file) {}\n#endif\n\n#ifndef COMMON_INTERCEPTOR_LIBRARY_LOADED\n#define COMMON_INTERCEPTOR_LIBRARY_LOADED(filename, handle) {}\n#endif\n\n#ifndef COMMON_INTERCEPTOR_LIBRARY_UNLOADED\n#define COMMON_INTERCEPTOR_LIBRARY_UNLOADED() {}\n#endif\n\n#ifndef COMMON_INTERCEPTOR_ENTER_NOIGNORE\n#define COMMON_INTERCEPTOR_ENTER_NOIGNORE(ctx, ...) \\\n  COMMON_INTERCEPTOR_ENTER(ctx, __VA_ARGS__)\n#endif\n\n#ifndef COMMON_INTERCEPTOR_NOTHING_IS_INITIALIZED\n#define COMMON_INTERCEPTOR_NOTHING_IS_INITIALIZED (0)\n#endif\n\n#define COMMON_INTERCEPTOR_READ_STRING(ctx, s, n)                   \\\n    COMMON_INTERCEPTOR_READ_RANGE((ctx), (s),                       \\\n      common_flags()->strict_string_checks ? (REAL(strlen)(s)) + 1 : (n) )\n\n#ifndef COMMON_INTERCEPTOR_ON_DLOPEN\n#define COMMON_INTERCEPTOR_ON_DLOPEN(filename, flag) \\\n  CheckNoDeepBind(filename, flag);\n#endif\n\n#ifndef COMMON_INTERCEPTOR_GET_TLS_RANGE\n#define COMMON_INTERCEPTOR_GET_TLS_RANGE(begin, end) *begin = *end = 0;\n#endif\n\n#ifndef COMMON_INTERCEPTOR_ACQUIRE\n#define COMMON_INTERCEPTOR_ACQUIRE(ctx, u) {}\n#endif\n\n#ifndef COMMON_INTERCEPTOR_RELEASE\n#define COMMON_INTERCEPTOR_RELEASE(ctx, u) {}\n#endif\n\n#ifndef COMMON_INTERCEPTOR_USER_CALLBACK_START\n#define COMMON_INTERCEPTOR_USER_CALLBACK_START() {}\n#endif\n\n#ifndef COMMON_INTERCEPTOR_USER_CALLBACK_END\n#define COMMON_INTERCEPTOR_USER_CALLBACK_END() {}\n#endif\n\n#ifdef SANITIZER_NLDBL_VERSION\n#define COMMON_INTERCEPT_FUNCTION_LDBL(fn)                          \\\n    COMMON_INTERCEPT_FUNCTION_VER(fn, SANITIZER_NLDBL_VERSION)\n#else\n#define COMMON_INTERCEPT_FUNCTION_LDBL(fn)                          \\\n    COMMON_INTERCEPT_FUNCTION(fn)\n#endif\n\n#if SANITIZER_GLIBC\n// If we could not find the versioned symbol, fall back to an unversioned\n// lookup. This is needed to work around a GLibc bug that causes dlsym\n// with RTLD_NEXT to return the oldest versioned symbol.\n// See https://sourceware.org/bugzilla/show_bug.cgi?id=14932.\n// For certain symbols (e.g. regexec) we have to perform a versioned lookup,\n// but that versioned symbol will only exist for architectures where the\n// oldest Glibc version pre-dates support for that architecture.\n// For example, regexec@GLIBC_2.3.4 exists on x86_64, but not RISC-V.\n// See also https://gcc.gnu.org/bugzilla/show_bug.cgi?id=98920.\n#define COMMON_INTERCEPT_FUNCTION_GLIBC_VER_MIN(fn, ver) \\\n  COMMON_INTERCEPT_FUNCTION_VER_UNVERSIONED_FALLBACK(fn, ver)\n#else\n#define COMMON_INTERCEPT_FUNCTION_GLIBC_VER_MIN(fn, ver) \\\n  COMMON_INTERCEPT_FUNCTION(fn)\n#endif\n\n#ifndef COMMON_INTERCEPTOR_MEMSET_IMPL\n#define COMMON_INTERCEPTOR_MEMSET_IMPL(ctx, dst, v, size) \\\n  {                                                       \\\n    if (COMMON_INTERCEPTOR_NOTHING_IS_INITIALIZED)        \\\n      return internal_memset(dst, v, size);               \\\n    COMMON_INTERCEPTOR_ENTER(ctx, memset, dst, v, size);  \\\n    if (common_flags()->intercept_intrin)                 \\\n      COMMON_INTERCEPTOR_WRITE_RANGE(ctx, dst, size);     \\\n    return REAL(memset)(dst, v, size);                    \\\n  }\n#endif\n\n#ifndef COMMON_INTERCEPTOR_MEMMOVE_IMPL\n#define COMMON_INTERCEPTOR_MEMMOVE_IMPL(ctx, dst, src, size) \\\n  {                                                          \\\n    if (COMMON_INTERCEPTOR_NOTHING_IS_INITIALIZED)           \\\n      return internal_memmove(dst, src, size);               \\\n    COMMON_INTERCEPTOR_ENTER(ctx, memmove, dst, src, size);  \\\n    if (common_flags()->intercept_intrin) {                  \\\n      COMMON_INTERCEPTOR_WRITE_RANGE(ctx, dst, size);        \\\n      COMMON_INTERCEPTOR_READ_RANGE(ctx, src, size);         \\\n    }                                                        \\\n    return REAL(memmove)(dst, src, size);                    \\\n  }\n#endif\n\n#ifndef COMMON_INTERCEPTOR_MEMCPY_IMPL\n#define COMMON_INTERCEPTOR_MEMCPY_IMPL(ctx, dst, src, size) \\\n  {                                                         \\\n    if (COMMON_INTERCEPTOR_NOTHING_IS_INITIALIZED) {        \\\n      return internal_memmove(dst, src, size);              \\\n    }                                                       \\\n    COMMON_INTERCEPTOR_ENTER(ctx, memcpy, dst, src, size);  \\\n    if (common_flags()->intercept_intrin) {                 \\\n      COMMON_INTERCEPTOR_WRITE_RANGE(ctx, dst, size);       \\\n      COMMON_INTERCEPTOR_READ_RANGE(ctx, src, size);        \\\n    }                                                       \\\n    return REAL(memcpy)(dst, src, size);                    \\\n  }\n#endif\n\n#ifndef COMMON_INTERCEPTOR_MMAP_IMPL\n#define COMMON_INTERCEPTOR_MMAP_IMPL(ctx, mmap, addr, sz, prot, flags, fd, \\\n                                     off)                                  \\\n  { return REAL(mmap)(addr, sz, prot, flags, fd, off); }\n#endif\n\n#ifndef COMMON_INTERCEPTOR_COPY_STRING\n#define COMMON_INTERCEPTOR_COPY_STRING(ctx, to, from, size) {}\n#endif\n\n#ifndef COMMON_INTERCEPTOR_STRNDUP_IMPL\n#define COMMON_INTERCEPTOR_STRNDUP_IMPL(ctx, s, size)                         \\\n  COMMON_INTERCEPTOR_ENTER(ctx, strndup, s, size);                            \\\n  uptr copy_length = internal_strnlen(s, size);                               \\\n  char *new_mem = (char *)WRAP(malloc)(copy_length + 1);                      \\\n  if (common_flags()->intercept_strndup) {                                    \\\n    COMMON_INTERCEPTOR_READ_STRING(ctx, s, Min(size, copy_length + 1));       \\\n  }                                                                           \\\n  COMMON_INTERCEPTOR_COPY_STRING(ctx, new_mem, s, copy_length);               \\\n  internal_memcpy(new_mem, s, copy_length);                                   \\\n  new_mem[copy_length] = '\\0';                                                \\\n  return new_mem;\n#endif\n\n#ifndef COMMON_INTERCEPTOR_STRERROR\n#define COMMON_INTERCEPTOR_STRERROR() {}\n#endif\n\nstruct FileMetadata {\n  // For open_memstream().\n  char **addr;\n  SIZE_T *size;\n};\n\nstruct CommonInterceptorMetadata {\n  enum {\n    CIMT_INVALID = 0,\n    CIMT_FILE\n  } type;\n  union {\n    FileMetadata file;\n  };\n};\n\n#if SI_POSIX\ntypedef AddrHashMap<CommonInterceptorMetadata, 31051> MetadataHashMap;\n\nstatic MetadataHashMap *interceptor_metadata_map;\n\nUNUSED static void SetInterceptorMetadata(__sanitizer_FILE *addr,\n                                          const FileMetadata &file) {\n  MetadataHashMap::Handle h(interceptor_metadata_map, (uptr)addr);\n  CHECK(h.created());\n  h->type = CommonInterceptorMetadata::CIMT_FILE;\n  h->file = file;\n}\n\nUNUSED static const FileMetadata *GetInterceptorMetadata(\n    __sanitizer_FILE *addr) {\n  MetadataHashMap::Handle h(interceptor_metadata_map, (uptr)addr,\n                            /* remove */ false,\n                            /* create */ false);\n  if (addr && h.exists()) {\n    CHECK(!h.created());\n    CHECK(h->type == CommonInterceptorMetadata::CIMT_FILE);\n    return &h->file;\n  } else {\n    return 0;\n  }\n}\n\nUNUSED static void DeleteInterceptorMetadata(void *addr) {\n  MetadataHashMap::Handle h(interceptor_metadata_map, (uptr)addr, true);\n  CHECK(h.exists());\n}\n#endif  // SI_POSIX\n\n#if SANITIZER_INTERCEPT_STRLEN\nINTERCEPTOR(SIZE_T, strlen, const char *s) {\n  // Sometimes strlen is called prior to InitializeCommonInterceptors,\n  // in which case the REAL(strlen) typically used in\n  // COMMON_INTERCEPTOR_ENTER will fail.  We use internal_strlen here\n  // to handle that.\n  if (COMMON_INTERCEPTOR_NOTHING_IS_INITIALIZED)\n    return internal_strlen(s);\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, strlen, s);\n  SIZE_T result = REAL(strlen)(s);\n  if (common_flags()->intercept_strlen)\n    COMMON_INTERCEPTOR_READ_RANGE(ctx, s, result + 1);\n  return result;\n}\n#define INIT_STRLEN COMMON_INTERCEPT_FUNCTION(strlen)\n#else\n#define INIT_STRLEN\n#endif\n\n#if SANITIZER_INTERCEPT_STRNLEN\nINTERCEPTOR(SIZE_T, strnlen, const char *s, SIZE_T maxlen) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, strnlen, s, maxlen);\n  SIZE_T length = REAL(strnlen)(s, maxlen);\n  if (common_flags()->intercept_strlen)\n    COMMON_INTERCEPTOR_READ_RANGE(ctx, s, Min(length + 1, maxlen));\n  return length;\n}\n#define INIT_STRNLEN COMMON_INTERCEPT_FUNCTION(strnlen)\n#else\n#define INIT_STRNLEN\n#endif\n\n#if SANITIZER_INTERCEPT_STRNDUP\nINTERCEPTOR(char*, strndup, const char *s, uptr size) {\n  void *ctx;\n  COMMON_INTERCEPTOR_STRNDUP_IMPL(ctx, s, size);\n}\n#define INIT_STRNDUP COMMON_INTERCEPT_FUNCTION(strndup)\n#else\n#define INIT_STRNDUP\n#endif // SANITIZER_INTERCEPT_STRNDUP\n\n#if SANITIZER_INTERCEPT___STRNDUP\nINTERCEPTOR(char*, __strndup, const char *s, uptr size) {\n  void *ctx;\n  COMMON_INTERCEPTOR_STRNDUP_IMPL(ctx, s, size);\n}\n#define INIT___STRNDUP COMMON_INTERCEPT_FUNCTION(__strndup)\n#else\n#define INIT___STRNDUP\n#endif // SANITIZER_INTERCEPT___STRNDUP\n\n#if SANITIZER_INTERCEPT_TEXTDOMAIN\nINTERCEPTOR(char*, textdomain, const char *domainname) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, textdomain, domainname);\n  if (domainname) COMMON_INTERCEPTOR_READ_STRING(ctx, domainname, 0);\n  char *domain = REAL(textdomain)(domainname);\n  if (domain) {\n    COMMON_INTERCEPTOR_INITIALIZE_RANGE(domain, REAL(strlen)(domain) + 1);\n  }\n  return domain;\n}\n#define INIT_TEXTDOMAIN COMMON_INTERCEPT_FUNCTION(textdomain)\n#else\n#define INIT_TEXTDOMAIN\n#endif\n\n#if SANITIZER_INTERCEPT_STRCMP\nstatic inline int CharCmpX(unsigned char c1, unsigned char c2) {\n  return (c1 == c2) ? 0 : (c1 < c2) ? -1 : 1;\n}\n\nDECLARE_WEAK_INTERCEPTOR_HOOK(__sanitizer_weak_hook_strcmp, uptr called_pc,\n                              const char *s1, const char *s2, int result)\n\nINTERCEPTOR(int, strcmp, const char *s1, const char *s2) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, strcmp, s1, s2);\n  unsigned char c1, c2;\n  uptr i;\n  for (i = 0;; i++) {\n    c1 = (unsigned char)s1[i];\n    c2 = (unsigned char)s2[i];\n    if (c1 != c2 || c1 == '\\0') break;\n  }\n  if (common_flags()->intercept_strcmp) {\n    COMMON_INTERCEPTOR_READ_STRING(ctx, s1, i + 1);\n    COMMON_INTERCEPTOR_READ_STRING(ctx, s2, i + 1);\n  }\n  int result = CharCmpX(c1, c2);\n  CALL_WEAK_INTERCEPTOR_HOOK(__sanitizer_weak_hook_strcmp, GET_CALLER_PC(), s1,\n                             s2, result);\n  return result;\n}\n\nDECLARE_WEAK_INTERCEPTOR_HOOK(__sanitizer_weak_hook_strncmp, uptr called_pc,\n                              const char *s1, const char *s2, uptr n,\n                              int result)\n\nINTERCEPTOR(int, strncmp, const char *s1, const char *s2, uptr size) {\n  if (COMMON_INTERCEPTOR_NOTHING_IS_INITIALIZED)\n    return internal_strncmp(s1, s2, size);\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, strncmp, s1, s2, size);\n  unsigned char c1 = 0, c2 = 0;\n  uptr i;\n  for (i = 0; i < size; i++) {\n    c1 = (unsigned char)s1[i];\n    c2 = (unsigned char)s2[i];\n    if (c1 != c2 || c1 == '\\0') break;\n  }\n  uptr i1 = i;\n  uptr i2 = i;\n  if (common_flags()->strict_string_checks) {\n    for (; i1 < size && s1[i1]; i1++) {}\n    for (; i2 < size && s2[i2]; i2++) {}\n  }\n  COMMON_INTERCEPTOR_READ_RANGE((ctx), (s1), Min(i1 + 1, size));\n  COMMON_INTERCEPTOR_READ_RANGE((ctx), (s2), Min(i2 + 1, size));\n  int result = CharCmpX(c1, c2);\n  CALL_WEAK_INTERCEPTOR_HOOK(__sanitizer_weak_hook_strncmp, GET_CALLER_PC(), s1,\n                             s2, size, result);\n  return result;\n}\n\n#define INIT_STRCMP COMMON_INTERCEPT_FUNCTION(strcmp)\n#define INIT_STRNCMP COMMON_INTERCEPT_FUNCTION(strncmp)\n#else\n#define INIT_STRCMP\n#define INIT_STRNCMP\n#endif\n\n#if SANITIZER_INTERCEPT_STRCASECMP\nstatic inline int CharCaseCmp(unsigned char c1, unsigned char c2) {\n  int c1_low = ToLower(c1);\n  int c2_low = ToLower(c2);\n  return c1_low - c2_low;\n}\n\nDECLARE_WEAK_INTERCEPTOR_HOOK(__sanitizer_weak_hook_strcasecmp, uptr called_pc,\n                              const char *s1, const char *s2, int result)\n\nINTERCEPTOR(int, strcasecmp, const char *s1, const char *s2) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, strcasecmp, s1, s2);\n  unsigned char c1 = 0, c2 = 0;\n  uptr i;\n  for (i = 0;; i++) {\n    c1 = (unsigned char)s1[i];\n    c2 = (unsigned char)s2[i];\n    if (CharCaseCmp(c1, c2) != 0 || c1 == '\\0') break;\n  }\n  COMMON_INTERCEPTOR_READ_STRING(ctx, s1, i + 1);\n  COMMON_INTERCEPTOR_READ_STRING(ctx, s2, i + 1);\n  int result = CharCaseCmp(c1, c2);\n  CALL_WEAK_INTERCEPTOR_HOOK(__sanitizer_weak_hook_strcasecmp, GET_CALLER_PC(),\n                             s1, s2, result);\n  return result;\n}\n\nDECLARE_WEAK_INTERCEPTOR_HOOK(__sanitizer_weak_hook_strncasecmp, uptr called_pc,\n                              const char *s1, const char *s2, uptr size,\n                              int result)\n\nINTERCEPTOR(int, strncasecmp, const char *s1, const char *s2, SIZE_T size) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, strncasecmp, s1, s2, size);\n  unsigned char c1 = 0, c2 = 0;\n  uptr i;\n  for (i = 0; i < size; i++) {\n    c1 = (unsigned char)s1[i];\n    c2 = (unsigned char)s2[i];\n    if (CharCaseCmp(c1, c2) != 0 || c1 == '\\0') break;\n  }\n  uptr i1 = i;\n  uptr i2 = i;\n  if (common_flags()->strict_string_checks) {\n    for (; i1 < size && s1[i1]; i1++) {}\n    for (; i2 < size && s2[i2]; i2++) {}\n  }\n  COMMON_INTERCEPTOR_READ_RANGE((ctx), (s1), Min(i1 + 1, size));\n  COMMON_INTERCEPTOR_READ_RANGE((ctx), (s2), Min(i2 + 1, size));\n  int result = CharCaseCmp(c1, c2);\n  CALL_WEAK_INTERCEPTOR_HOOK(__sanitizer_weak_hook_strncasecmp, GET_CALLER_PC(),\n                             s1, s2, size, result);\n  return result;\n}\n\n#define INIT_STRCASECMP COMMON_INTERCEPT_FUNCTION(strcasecmp)\n#define INIT_STRNCASECMP COMMON_INTERCEPT_FUNCTION(strncasecmp)\n#else\n#define INIT_STRCASECMP\n#define INIT_STRNCASECMP\n#endif\n\n#if SANITIZER_INTERCEPT_STRSTR || SANITIZER_INTERCEPT_STRCASESTR\nstatic inline void StrstrCheck(void *ctx, char *r, const char *s1,\n                               const char *s2) {\n    uptr len1 = REAL(strlen)(s1);\n    uptr len2 = REAL(strlen)(s2);\n    COMMON_INTERCEPTOR_READ_STRING(ctx, s1, r ? r - s1 + len2 : len1 + 1);\n    COMMON_INTERCEPTOR_READ_RANGE(ctx, s2, len2 + 1);\n}\n#endif\n\n#if SANITIZER_INTERCEPT_STRSTR\n\nDECLARE_WEAK_INTERCEPTOR_HOOK(__sanitizer_weak_hook_strstr, uptr called_pc,\n                              const char *s1, const char *s2, char *result)\n\nINTERCEPTOR(char*, strstr, const char *s1, const char *s2) {\n  if (COMMON_INTERCEPTOR_NOTHING_IS_INITIALIZED)\n    return internal_strstr(s1, s2);\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, strstr, s1, s2);\n  char *r = REAL(strstr)(s1, s2);\n  if (common_flags()->intercept_strstr)\n    StrstrCheck(ctx, r, s1, s2);\n  CALL_WEAK_INTERCEPTOR_HOOK(__sanitizer_weak_hook_strstr, GET_CALLER_PC(), s1,\n                             s2, r);\n  return r;\n}\n\n#define INIT_STRSTR COMMON_INTERCEPT_FUNCTION(strstr);\n#else\n#define INIT_STRSTR\n#endif\n\n#if SANITIZER_INTERCEPT_STRCASESTR\n\nDECLARE_WEAK_INTERCEPTOR_HOOK(__sanitizer_weak_hook_strcasestr, uptr called_pc,\n                              const char *s1, const char *s2, char *result)\n\nINTERCEPTOR(char*, strcasestr, const char *s1, const char *s2) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, strcasestr, s1, s2);\n  char *r = REAL(strcasestr)(s1, s2);\n  if (common_flags()->intercept_strstr)\n    StrstrCheck(ctx, r, s1, s2);\n  CALL_WEAK_INTERCEPTOR_HOOK(__sanitizer_weak_hook_strcasestr, GET_CALLER_PC(),\n                             s1, s2, r);\n  return r;\n}\n\n#define INIT_STRCASESTR COMMON_INTERCEPT_FUNCTION(strcasestr);\n#else\n#define INIT_STRCASESTR\n#endif\n\n#if SANITIZER_INTERCEPT_STRTOK\n\nINTERCEPTOR(char*, strtok, char *str, const char *delimiters) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, strtok, str, delimiters);\n  if (!common_flags()->intercept_strtok) {\n    return REAL(strtok)(str, delimiters);\n  }\n  if (common_flags()->strict_string_checks) {\n    // If strict_string_checks is enabled, we check the whole first argument\n    // string on the first call (strtok saves this string in a static buffer\n    // for subsequent calls). We do not need to check strtok's result.\n    // As the delimiters can change, we check them every call.\n    if (str != nullptr) {\n      COMMON_INTERCEPTOR_READ_RANGE(ctx, str, REAL(strlen)(str) + 1);\n    }\n    COMMON_INTERCEPTOR_READ_RANGE(ctx, delimiters,\n                                  REAL(strlen)(delimiters) + 1);\n    return REAL(strtok)(str, delimiters);\n  } else {\n    // However, when strict_string_checks is disabled we cannot check the\n    // whole string on the first call. Instead, we check the result string\n    // which is guaranteed to be a NULL-terminated substring of the first\n    // argument. We also conservatively check one character of str and the\n    // delimiters.\n    if (str != nullptr) {\n      COMMON_INTERCEPTOR_READ_STRING(ctx, str, 1);\n    }\n    COMMON_INTERCEPTOR_READ_RANGE(ctx, delimiters, 1);\n    char *result = REAL(strtok)(str, delimiters);\n    if (result != nullptr) {\n      COMMON_INTERCEPTOR_READ_RANGE(ctx, result, REAL(strlen)(result) + 1);\n    } else if (str != nullptr) {\n      // No delimiter were found, it's safe to assume that the entire str was\n      // scanned.\n      COMMON_INTERCEPTOR_READ_RANGE(ctx, str, REAL(strlen)(str) + 1);\n    }\n    return result;\n  }\n}\n\n#define INIT_STRTOK COMMON_INTERCEPT_FUNCTION(strtok)\n#else\n#define INIT_STRTOK\n#endif\n\n#if SANITIZER_INTERCEPT_MEMMEM\nDECLARE_WEAK_INTERCEPTOR_HOOK(__sanitizer_weak_hook_memmem, uptr called_pc,\n                              const void *s1, SIZE_T len1, const void *s2,\n                              SIZE_T len2, void *result)\n\nINTERCEPTOR(void*, memmem, const void *s1, SIZE_T len1, const void *s2,\n            SIZE_T len2) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, memmem, s1, len1, s2, len2);\n  void *r = REAL(memmem)(s1, len1, s2, len2);\n  if (common_flags()->intercept_memmem) {\n    COMMON_INTERCEPTOR_READ_RANGE(ctx, s1, len1);\n    COMMON_INTERCEPTOR_READ_RANGE(ctx, s2, len2);\n  }\n  CALL_WEAK_INTERCEPTOR_HOOK(__sanitizer_weak_hook_memmem, GET_CALLER_PC(),\n                             s1, len1, s2, len2, r);\n  return r;\n}\n\n#define INIT_MEMMEM COMMON_INTERCEPT_FUNCTION(memmem);\n#else\n#define INIT_MEMMEM\n#endif  // SANITIZER_INTERCEPT_MEMMEM\n\n#if SANITIZER_INTERCEPT_STRCHR\nINTERCEPTOR(char*, strchr, const char *s, int c) {\n  void *ctx;\n  if (COMMON_INTERCEPTOR_NOTHING_IS_INITIALIZED)\n    return internal_strchr(s, c);\n  COMMON_INTERCEPTOR_ENTER(ctx, strchr, s, c);\n  char *result = REAL(strchr)(s, c);\n  if (common_flags()->intercept_strchr) {\n    // Keep strlen as macro argument, as macro may ignore it.\n    COMMON_INTERCEPTOR_READ_STRING(ctx, s,\n      (result ? result - s : REAL(strlen)(s)) + 1);\n  }\n  return result;\n}\n#define INIT_STRCHR COMMON_INTERCEPT_FUNCTION(strchr)\n#else\n#define INIT_STRCHR\n#endif\n\n#if SANITIZER_INTERCEPT_STRCHRNUL\nINTERCEPTOR(char*, strchrnul, const char *s, int c) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, strchrnul, s, c);\n  char *result = REAL(strchrnul)(s, c);\n  uptr len = result - s + 1;\n  if (common_flags()->intercept_strchr)\n    COMMON_INTERCEPTOR_READ_STRING(ctx, s, len);\n  return result;\n}\n#define INIT_STRCHRNUL COMMON_INTERCEPT_FUNCTION(strchrnul)\n#else\n#define INIT_STRCHRNUL\n#endif\n\n#if SANITIZER_INTERCEPT_STRRCHR\nINTERCEPTOR(char*, strrchr, const char *s, int c) {\n  void *ctx;\n  if (COMMON_INTERCEPTOR_NOTHING_IS_INITIALIZED)\n    return internal_strrchr(s, c);\n  COMMON_INTERCEPTOR_ENTER(ctx, strrchr, s, c);\n  if (common_flags()->intercept_strchr)\n    COMMON_INTERCEPTOR_READ_RANGE(ctx, s, REAL(strlen)(s) + 1);\n  return REAL(strrchr)(s, c);\n}\n#define INIT_STRRCHR COMMON_INTERCEPT_FUNCTION(strrchr)\n#else\n#define INIT_STRRCHR\n#endif\n\n#if SANITIZER_INTERCEPT_STRSPN\nINTERCEPTOR(SIZE_T, strspn, const char *s1, const char *s2) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, strspn, s1, s2);\n  SIZE_T r = REAL(strspn)(s1, s2);\n  if (common_flags()->intercept_strspn) {\n    COMMON_INTERCEPTOR_READ_RANGE(ctx, s2, REAL(strlen)(s2) + 1);\n    COMMON_INTERCEPTOR_READ_STRING(ctx, s1, r + 1);\n  }\n  return r;\n}\n\nINTERCEPTOR(SIZE_T, strcspn, const char *s1, const char *s2) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, strcspn, s1, s2);\n  SIZE_T r = REAL(strcspn)(s1, s2);\n  if (common_flags()->intercept_strspn) {\n    COMMON_INTERCEPTOR_READ_RANGE(ctx, s2, REAL(strlen)(s2) + 1);\n    COMMON_INTERCEPTOR_READ_STRING(ctx, s1, r + 1);\n  }\n  return r;\n}\n\n#define INIT_STRSPN \\\n  COMMON_INTERCEPT_FUNCTION(strspn); \\\n  COMMON_INTERCEPT_FUNCTION(strcspn);\n#else\n#define INIT_STRSPN\n#endif\n\n#if SANITIZER_INTERCEPT_STRPBRK\nINTERCEPTOR(char *, strpbrk, const char *s1, const char *s2) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, strpbrk, s1, s2);\n  char *r = REAL(strpbrk)(s1, s2);\n  if (common_flags()->intercept_strpbrk) {\n    COMMON_INTERCEPTOR_READ_RANGE(ctx, s2, REAL(strlen)(s2) + 1);\n    COMMON_INTERCEPTOR_READ_STRING(ctx, s1,\n        r ? r - s1 + 1 : REAL(strlen)(s1) + 1);\n  }\n  return r;\n}\n\n#define INIT_STRPBRK COMMON_INTERCEPT_FUNCTION(strpbrk);\n#else\n#define INIT_STRPBRK\n#endif\n\n#if SANITIZER_INTERCEPT_MEMSET\nINTERCEPTOR(void *, memset, void *dst, int v, uptr size) {\n  void *ctx;\n  COMMON_INTERCEPTOR_MEMSET_IMPL(ctx, dst, v, size);\n}\n\n#define INIT_MEMSET COMMON_INTERCEPT_FUNCTION(memset)\n#else\n#define INIT_MEMSET\n#endif\n\n#if SANITIZER_INTERCEPT_MEMMOVE\nINTERCEPTOR(void *, memmove, void *dst, const void *src, uptr size) {\n  void *ctx;\n  COMMON_INTERCEPTOR_MEMMOVE_IMPL(ctx, dst, src, size);\n}\n\n#define INIT_MEMMOVE COMMON_INTERCEPT_FUNCTION(memmove)\n#else\n#define INIT_MEMMOVE\n#endif\n\n#if SANITIZER_INTERCEPT_MEMCPY\nINTERCEPTOR(void *, memcpy, void *dst, const void *src, uptr size) {\n  // On OS X, calling internal_memcpy here will cause memory corruptions,\n  // because memcpy and memmove are actually aliases of the same\n  // implementation.  We need to use internal_memmove here.\n  // N.B.: If we switch this to internal_ we'll have to use internal_memmove\n  // due to memcpy being an alias of memmove on OS X.\n  void *ctx;\n  if (PLATFORM_HAS_DIFFERENT_MEMCPY_AND_MEMMOVE) {\n    COMMON_INTERCEPTOR_MEMCPY_IMPL(ctx, dst, src, size);\n  } else {\n    COMMON_INTERCEPTOR_MEMMOVE_IMPL(ctx, dst, src, size);\n  }\n}\n\n#define INIT_MEMCPY                                  \\\n  do {                                               \\\n    if (PLATFORM_HAS_DIFFERENT_MEMCPY_AND_MEMMOVE) { \\\n      COMMON_INTERCEPT_FUNCTION(memcpy);             \\\n    } else {                                         \\\n      ASSIGN_REAL(memcpy, memmove);                  \\\n    }                                                \\\n    CHECK(REAL(memcpy));                             \\\n  } while (false)\n\n#else\n#define INIT_MEMCPY\n#endif\n\n#if SANITIZER_INTERCEPT_MEMCMP\nDECLARE_WEAK_INTERCEPTOR_HOOK(__sanitizer_weak_hook_memcmp, uptr called_pc,\n                              const void *s1, const void *s2, uptr n,\n                              int result)\n\n// Common code for `memcmp` and `bcmp`.\nint MemcmpInterceptorCommon(void *ctx,\n                            int (*real_fn)(const void *, const void *, uptr),\n                            const void *a1, const void *a2, uptr size) {\n  if (common_flags()->intercept_memcmp) {\n    if (common_flags()->strict_memcmp) {\n      // Check the entire regions even if the first bytes of the buffers are\n      // different.\n      COMMON_INTERCEPTOR_READ_RANGE(ctx, a1, size);\n      COMMON_INTERCEPTOR_READ_RANGE(ctx, a2, size);\n      // Fallthrough to REAL(memcmp) below.\n    } else {\n      unsigned char c1 = 0, c2 = 0;\n      const unsigned char *s1 = (const unsigned char*)a1;\n      const unsigned char *s2 = (const unsigned char*)a2;\n      uptr i;\n      for (i = 0; i < size; i++) {\n        c1 = s1[i];\n        c2 = s2[i];\n        if (c1 != c2) break;\n      }\n      COMMON_INTERCEPTOR_READ_RANGE(ctx, s1, Min(i + 1, size));\n      COMMON_INTERCEPTOR_READ_RANGE(ctx, s2, Min(i + 1, size));\n      int r = CharCmpX(c1, c2);\n      CALL_WEAK_INTERCEPTOR_HOOK(__sanitizer_weak_hook_memcmp, GET_CALLER_PC(),\n                                 a1, a2, size, r);\n      return r;\n    }\n  }\n  int result = real_fn(a1, a2, size);\n  CALL_WEAK_INTERCEPTOR_HOOK(__sanitizer_weak_hook_memcmp, GET_CALLER_PC(), a1,\n                             a2, size, result);\n  return result;\n}\n\nINTERCEPTOR(int, memcmp, const void *a1, const void *a2, uptr size) {\n  if (COMMON_INTERCEPTOR_NOTHING_IS_INITIALIZED)\n    return internal_memcmp(a1, a2, size);\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, memcmp, a1, a2, size);\n  return MemcmpInterceptorCommon(ctx, REAL(memcmp), a1, a2, size);\n}\n\n#define INIT_MEMCMP COMMON_INTERCEPT_FUNCTION(memcmp)\n#else\n#define INIT_MEMCMP\n#endif\n\n#if SANITIZER_INTERCEPT_BCMP\nINTERCEPTOR(int, bcmp, const void *a1, const void *a2, uptr size) {\n  if (COMMON_INTERCEPTOR_NOTHING_IS_INITIALIZED)\n    return internal_memcmp(a1, a2, size);\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, bcmp, a1, a2, size);\n  return MemcmpInterceptorCommon(ctx, REAL(bcmp), a1, a2, size);\n}\n\n#define INIT_BCMP COMMON_INTERCEPT_FUNCTION(bcmp)\n#else\n#define INIT_BCMP\n#endif\n\n#if SANITIZER_INTERCEPT_MEMCHR\nINTERCEPTOR(void*, memchr, const void *s, int c, SIZE_T n) {\n  if (COMMON_INTERCEPTOR_NOTHING_IS_INITIALIZED)\n    return internal_memchr(s, c, n);\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, memchr, s, c, n);\n#if SANITIZER_WINDOWS\n  void *res;\n  if (REAL(memchr)) {\n    res = REAL(memchr)(s, c, n);\n  } else {\n    res = internal_memchr(s, c, n);\n  }\n#else\n  void *res = REAL(memchr)(s, c, n);\n#endif\n  uptr len = res ? (char *)res - (const char *)s + 1 : n;\n  COMMON_INTERCEPTOR_READ_RANGE(ctx, s, len);\n  return res;\n}\n\n#define INIT_MEMCHR COMMON_INTERCEPT_FUNCTION(memchr)\n#else\n#define INIT_MEMCHR\n#endif\n\n#if SANITIZER_INTERCEPT_MEMRCHR\nINTERCEPTOR(void*, memrchr, const void *s, int c, SIZE_T n) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, memrchr, s, c, n);\n  COMMON_INTERCEPTOR_READ_RANGE(ctx, s, n);\n  return REAL(memrchr)(s, c, n);\n}\n\n#define INIT_MEMRCHR COMMON_INTERCEPT_FUNCTION(memrchr)\n#else\n#define INIT_MEMRCHR\n#endif\n\n#if SANITIZER_INTERCEPT_FREXP\nINTERCEPTOR(double, frexp, double x, int *exp) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, frexp, x, exp);\n  // Assuming frexp() always writes to |exp|.\n  COMMON_INTERCEPTOR_WRITE_RANGE(ctx, exp, sizeof(*exp));\n  double res = REAL(frexp)(x, exp);\n  return res;\n}\n\n#define INIT_FREXP COMMON_INTERCEPT_FUNCTION(frexp);\n#else\n#define INIT_FREXP\n#endif  // SANITIZER_INTERCEPT_FREXP\n\n#if SANITIZER_INTERCEPT_FREXPF_FREXPL\nINTERCEPTOR(float, frexpf, float x, int *exp) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, frexpf, x, exp);\n  // FIXME: under ASan the call below may write to freed memory and corrupt\n  // its metadata. See\n  // https://github.com/google/sanitizers/issues/321.\n  float res = REAL(frexpf)(x, exp);\n  COMMON_INTERCEPTOR_WRITE_RANGE(ctx, exp, sizeof(*exp));\n  return res;\n}\n\nINTERCEPTOR(long double, frexpl, long double x, int *exp) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, frexpl, x, exp);\n  // FIXME: under ASan the call below may write to freed memory and corrupt\n  // its metadata. See\n  // https://github.com/google/sanitizers/issues/321.\n  long double res = REAL(frexpl)(x, exp);\n  COMMON_INTERCEPTOR_WRITE_RANGE(ctx, exp, sizeof(*exp));\n  return res;\n}\n\n#define INIT_FREXPF_FREXPL           \\\n  COMMON_INTERCEPT_FUNCTION(frexpf); \\\n  COMMON_INTERCEPT_FUNCTION_LDBL(frexpl)\n#else\n#define INIT_FREXPF_FREXPL\n#endif  // SANITIZER_INTERCEPT_FREXPF_FREXPL\n\n#if SI_POSIX\nstatic void write_iovec(void *ctx, struct __sanitizer_iovec *iovec,\n                        SIZE_T iovlen, SIZE_T maxlen) {\n  for (SIZE_T i = 0; i < iovlen && maxlen; ++i) {\n    SSIZE_T sz = Min(iovec[i].iov_len, maxlen);\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, iovec[i].iov_base, sz);\n    maxlen -= sz;\n  }\n}\n\nstatic void read_iovec(void *ctx, struct __sanitizer_iovec *iovec,\n                       SIZE_T iovlen, SIZE_T maxlen) {\n  COMMON_INTERCEPTOR_READ_RANGE(ctx, iovec, sizeof(*iovec) * iovlen);\n  for (SIZE_T i = 0; i < iovlen && maxlen; ++i) {\n    SSIZE_T sz = Min(iovec[i].iov_len, maxlen);\n    COMMON_INTERCEPTOR_READ_RANGE(ctx, iovec[i].iov_base, sz);\n    maxlen -= sz;\n  }\n}\n#endif\n\n#if SANITIZER_INTERCEPT_READ\nINTERCEPTOR(SSIZE_T, read, int fd, void *ptr, SIZE_T count) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, read, fd, ptr, count);\n  COMMON_INTERCEPTOR_FD_ACCESS(ctx, fd);\n  // FIXME: under ASan the call below may write to freed memory and corrupt\n  // its metadata. See\n  // https://github.com/google/sanitizers/issues/321.\n  SSIZE_T res = REAL(read)(fd, ptr, count);\n  if (res > 0) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, ptr, res);\n  if (res >= 0 && fd >= 0) COMMON_INTERCEPTOR_FD_ACQUIRE(ctx, fd);\n  return res;\n}\n#define INIT_READ COMMON_INTERCEPT_FUNCTION(read)\n#else\n#define INIT_READ\n#endif\n\n#if SANITIZER_INTERCEPT_FREAD\nINTERCEPTOR(SIZE_T, fread, void *ptr, SIZE_T size, SIZE_T nmemb, void *file) {\n  // libc file streams can call user-supplied functions, see fopencookie.\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, fread, ptr, size, nmemb, file);\n  // FIXME: under ASan the call below may write to freed memory and corrupt\n  // its metadata. See\n  // https://github.com/google/sanitizers/issues/321.\n  SIZE_T res = REAL(fread)(ptr, size, nmemb, file);\n  if (res > 0) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, ptr, res * size);\n  return res;\n}\n#define INIT_FREAD COMMON_INTERCEPT_FUNCTION(fread)\n#else\n#define INIT_FREAD\n#endif\n\n#if SANITIZER_INTERCEPT_PREAD\nINTERCEPTOR(SSIZE_T, pread, int fd, void *ptr, SIZE_T count, OFF_T offset) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, pread, fd, ptr, count, offset);\n  COMMON_INTERCEPTOR_FD_ACCESS(ctx, fd);\n  // FIXME: under ASan the call below may write to freed memory and corrupt\n  // its metadata. See\n  // https://github.com/google/sanitizers/issues/321.\n  SSIZE_T res = REAL(pread)(fd, ptr, count, offset);\n  if (res > 0) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, ptr, res);\n  if (res >= 0 && fd >= 0) COMMON_INTERCEPTOR_FD_ACQUIRE(ctx, fd);\n  return res;\n}\n#define INIT_PREAD COMMON_INTERCEPT_FUNCTION(pread)\n#else\n#define INIT_PREAD\n#endif\n\n#if SANITIZER_INTERCEPT_PREAD64\nINTERCEPTOR(SSIZE_T, pread64, int fd, void *ptr, SIZE_T count, OFF64_T offset) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, pread64, fd, ptr, count, offset);\n  COMMON_INTERCEPTOR_FD_ACCESS(ctx, fd);\n  // FIXME: under ASan the call below may write to freed memory and corrupt\n  // its metadata. See\n  // https://github.com/google/sanitizers/issues/321.\n  SSIZE_T res = REAL(pread64)(fd, ptr, count, offset);\n  if (res > 0) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, ptr, res);\n  if (res >= 0 && fd >= 0) COMMON_INTERCEPTOR_FD_ACQUIRE(ctx, fd);\n  return res;\n}\n#define INIT_PREAD64 COMMON_INTERCEPT_FUNCTION(pread64)\n#else\n#define INIT_PREAD64\n#endif\n\n#if SANITIZER_INTERCEPT_READV\nINTERCEPTOR_WITH_SUFFIX(SSIZE_T, readv, int fd, __sanitizer_iovec *iov,\n                        int iovcnt) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, readv, fd, iov, iovcnt);\n  COMMON_INTERCEPTOR_FD_ACCESS(ctx, fd);\n  SSIZE_T res = REAL(readv)(fd, iov, iovcnt);\n  if (res > 0) write_iovec(ctx, iov, iovcnt, res);\n  if (res >= 0 && fd >= 0) COMMON_INTERCEPTOR_FD_ACQUIRE(ctx, fd);\n  return res;\n}\n#define INIT_READV COMMON_INTERCEPT_FUNCTION(readv)\n#else\n#define INIT_READV\n#endif\n\n#if SANITIZER_INTERCEPT_PREADV\nINTERCEPTOR(SSIZE_T, preadv, int fd, __sanitizer_iovec *iov, int iovcnt,\n            OFF_T offset) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, preadv, fd, iov, iovcnt, offset);\n  COMMON_INTERCEPTOR_FD_ACCESS(ctx, fd);\n  SSIZE_T res = REAL(preadv)(fd, iov, iovcnt, offset);\n  if (res > 0) write_iovec(ctx, iov, iovcnt, res);\n  if (res >= 0 && fd >= 0) COMMON_INTERCEPTOR_FD_ACQUIRE(ctx, fd);\n  return res;\n}\n#define INIT_PREADV COMMON_INTERCEPT_FUNCTION(preadv)\n#else\n#define INIT_PREADV\n#endif\n\n#if SANITIZER_INTERCEPT_PREADV64\nINTERCEPTOR(SSIZE_T, preadv64, int fd, __sanitizer_iovec *iov, int iovcnt,\n            OFF64_T offset) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, preadv64, fd, iov, iovcnt, offset);\n  COMMON_INTERCEPTOR_FD_ACCESS(ctx, fd);\n  SSIZE_T res = REAL(preadv64)(fd, iov, iovcnt, offset);\n  if (res > 0) write_iovec(ctx, iov, iovcnt, res);\n  if (res >= 0 && fd >= 0) COMMON_INTERCEPTOR_FD_ACQUIRE(ctx, fd);\n  return res;\n}\n#define INIT_PREADV64 COMMON_INTERCEPT_FUNCTION(preadv64)\n#else\n#define INIT_PREADV64\n#endif\n\n#if SANITIZER_INTERCEPT_WRITE\nINTERCEPTOR(SSIZE_T, write, int fd, void *ptr, SIZE_T count) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, write, fd, ptr, count);\n  COMMON_INTERCEPTOR_FD_ACCESS(ctx, fd);\n  if (fd >= 0) COMMON_INTERCEPTOR_FD_RELEASE(ctx, fd);\n  SSIZE_T res = REAL(write)(fd, ptr, count);\n  // FIXME: this check should be _before_ the call to REAL(write), not after\n  if (res > 0) COMMON_INTERCEPTOR_READ_RANGE(ctx, ptr, res);\n  return res;\n}\n#define INIT_WRITE COMMON_INTERCEPT_FUNCTION(write)\n#else\n#define INIT_WRITE\n#endif\n\n#if SANITIZER_INTERCEPT_FWRITE\nINTERCEPTOR(SIZE_T, fwrite, const void *p, uptr size, uptr nmemb, void *file) {\n  // libc file streams can call user-supplied functions, see fopencookie.\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, fwrite, p, size, nmemb, file);\n  SIZE_T res = REAL(fwrite)(p, size, nmemb, file);\n  if (res > 0) COMMON_INTERCEPTOR_READ_RANGE(ctx, p, res * size);\n  return res;\n}\n#define INIT_FWRITE COMMON_INTERCEPT_FUNCTION(fwrite)\n#else\n#define INIT_FWRITE\n#endif\n\n#if SANITIZER_INTERCEPT_PWRITE\nINTERCEPTOR(SSIZE_T, pwrite, int fd, void *ptr, SIZE_T count, OFF_T offset) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, pwrite, fd, ptr, count, offset);\n  COMMON_INTERCEPTOR_FD_ACCESS(ctx, fd);\n  if (fd >= 0) COMMON_INTERCEPTOR_FD_RELEASE(ctx, fd);\n  SSIZE_T res = REAL(pwrite)(fd, ptr, count, offset);\n  if (res > 0) COMMON_INTERCEPTOR_READ_RANGE(ctx, ptr, res);\n  return res;\n}\n#define INIT_PWRITE COMMON_INTERCEPT_FUNCTION(pwrite)\n#else\n#define INIT_PWRITE\n#endif\n\n#if SANITIZER_INTERCEPT_PWRITE64\nINTERCEPTOR(SSIZE_T, pwrite64, int fd, void *ptr, OFF64_T count,\n            OFF64_T offset) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, pwrite64, fd, ptr, count, offset);\n  COMMON_INTERCEPTOR_FD_ACCESS(ctx, fd);\n  if (fd >= 0) COMMON_INTERCEPTOR_FD_RELEASE(ctx, fd);\n  SSIZE_T res = REAL(pwrite64)(fd, ptr, count, offset);\n  if (res > 0) COMMON_INTERCEPTOR_READ_RANGE(ctx, ptr, res);\n  return res;\n}\n#define INIT_PWRITE64 COMMON_INTERCEPT_FUNCTION(pwrite64)\n#else\n#define INIT_PWRITE64\n#endif\n\n#if SANITIZER_INTERCEPT_WRITEV\nINTERCEPTOR_WITH_SUFFIX(SSIZE_T, writev, int fd, __sanitizer_iovec *iov,\n                        int iovcnt) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, writev, fd, iov, iovcnt);\n  COMMON_INTERCEPTOR_FD_ACCESS(ctx, fd);\n  if (fd >= 0) COMMON_INTERCEPTOR_FD_RELEASE(ctx, fd);\n  SSIZE_T res = REAL(writev)(fd, iov, iovcnt);\n  if (res > 0) read_iovec(ctx, iov, iovcnt, res);\n  return res;\n}\n#define INIT_WRITEV COMMON_INTERCEPT_FUNCTION(writev)\n#else\n#define INIT_WRITEV\n#endif\n\n#if SANITIZER_INTERCEPT_PWRITEV\nINTERCEPTOR(SSIZE_T, pwritev, int fd, __sanitizer_iovec *iov, int iovcnt,\n            OFF_T offset) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, pwritev, fd, iov, iovcnt, offset);\n  COMMON_INTERCEPTOR_FD_ACCESS(ctx, fd);\n  if (fd >= 0) COMMON_INTERCEPTOR_FD_RELEASE(ctx, fd);\n  SSIZE_T res = REAL(pwritev)(fd, iov, iovcnt, offset);\n  if (res > 0) read_iovec(ctx, iov, iovcnt, res);\n  return res;\n}\n#define INIT_PWRITEV COMMON_INTERCEPT_FUNCTION(pwritev)\n#else\n#define INIT_PWRITEV\n#endif\n\n#if SANITIZER_INTERCEPT_PWRITEV64\nINTERCEPTOR(SSIZE_T, pwritev64, int fd, __sanitizer_iovec *iov, int iovcnt,\n            OFF64_T offset) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, pwritev64, fd, iov, iovcnt, offset);\n  COMMON_INTERCEPTOR_FD_ACCESS(ctx, fd);\n  if (fd >= 0) COMMON_INTERCEPTOR_FD_RELEASE(ctx, fd);\n  SSIZE_T res = REAL(pwritev64)(fd, iov, iovcnt, offset);\n  if (res > 0) read_iovec(ctx, iov, iovcnt, res);\n  return res;\n}\n#define INIT_PWRITEV64 COMMON_INTERCEPT_FUNCTION(pwritev64)\n#else\n#define INIT_PWRITEV64\n#endif\n\n#if SANITIZER_INTERCEPT_FGETS\nINTERCEPTOR(char *, fgets, char *s, SIZE_T size, void *file) {\n  // libc file streams can call user-supplied functions, see fopencookie.\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, fgets, s, size, file);\n  // FIXME: under ASan the call below may write to freed memory and corrupt\n  // its metadata. See\n  // https://github.com/google/sanitizers/issues/321.\n  char *res = REAL(fgets)(s, size, file);\n  if (res)\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, s, REAL(strlen)(s) + 1);\n  return res;\n}\n#define INIT_FGETS COMMON_INTERCEPT_FUNCTION(fgets)\n#else\n#define INIT_FGETS\n#endif\n\n#if SANITIZER_INTERCEPT_FPUTS\nINTERCEPTOR_WITH_SUFFIX(int, fputs, char *s, void *file) {\n  // libc file streams can call user-supplied functions, see fopencookie.\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, fputs, s, file);\n  if (!SANITIZER_MAC || s) {  // `fputs(NULL, file)` is supported on Darwin.\n    COMMON_INTERCEPTOR_READ_RANGE(ctx, s, REAL(strlen)(s) + 1);\n  }\n  return REAL(fputs)(s, file);\n}\n#define INIT_FPUTS COMMON_INTERCEPT_FUNCTION(fputs)\n#else\n#define INIT_FPUTS\n#endif\n\n#if SANITIZER_INTERCEPT_PUTS\nINTERCEPTOR(int, puts, char *s) {\n  // libc file streams can call user-supplied functions, see fopencookie.\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, puts, s);\n  if (!SANITIZER_MAC || s) {  // `puts(NULL)` is supported on Darwin.\n    COMMON_INTERCEPTOR_READ_RANGE(ctx, s, REAL(strlen)(s) + 1);\n  }\n  return REAL(puts)(s);\n}\n#define INIT_PUTS COMMON_INTERCEPT_FUNCTION(puts)\n#else\n#define INIT_PUTS\n#endif\n\n#if SANITIZER_INTERCEPT_PRCTL\nINTERCEPTOR(int, prctl, int option, unsigned long arg2, unsigned long arg3,\n            unsigned long arg4, unsigned long arg5) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, prctl, option, arg2, arg3, arg4, arg5);\n  static const int PR_SET_NAME = 15;\n  int res = REAL(prctl(option, arg2, arg3, arg4, arg5));\n  if (option == PR_SET_NAME) {\n    char buff[16];\n    internal_strncpy(buff, (char *)arg2, 15);\n    buff[15] = 0;\n    COMMON_INTERCEPTOR_SET_THREAD_NAME(ctx, buff);\n  }\n  return res;\n}\n#define INIT_PRCTL COMMON_INTERCEPT_FUNCTION(prctl)\n#else\n#define INIT_PRCTL\n#endif  // SANITIZER_INTERCEPT_PRCTL\n\n#if SANITIZER_INTERCEPT_TIME\nINTERCEPTOR(unsigned long, time, unsigned long *t) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, time, t);\n  unsigned long local_t;\n  unsigned long res = REAL(time)(&local_t);\n  if (t && res != (unsigned long)-1) {\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, t, sizeof(*t));\n    *t = local_t;\n  }\n  return res;\n}\n#define INIT_TIME COMMON_INTERCEPT_FUNCTION(time);\n#else\n#define INIT_TIME\n#endif  // SANITIZER_INTERCEPT_TIME\n\n#if SANITIZER_INTERCEPT_LOCALTIME_AND_FRIENDS\nstatic void unpoison_tm(void *ctx, __sanitizer_tm *tm) {\n  COMMON_INTERCEPTOR_WRITE_RANGE(ctx, tm, sizeof(*tm));\n#if !SANITIZER_SOLARIS\n  if (tm->tm_zone) {\n    // Can not use COMMON_INTERCEPTOR_WRITE_RANGE here, because tm->tm_zone\n    // can point to shared memory and tsan would report a data race.\n    COMMON_INTERCEPTOR_INITIALIZE_RANGE(tm->tm_zone,\n                                        REAL(strlen(tm->tm_zone)) + 1);\n  }\n#endif\n}\nINTERCEPTOR(__sanitizer_tm *, localtime, unsigned long *timep) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, localtime, timep);\n  __sanitizer_tm *res = REAL(localtime)(timep);\n  if (res) {\n    COMMON_INTERCEPTOR_READ_RANGE(ctx, timep, sizeof(*timep));\n    unpoison_tm(ctx, res);\n  }\n  return res;\n}\nINTERCEPTOR(__sanitizer_tm *, localtime_r, unsigned long *timep, void *result) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, localtime_r, timep, result);\n  __sanitizer_tm *res = REAL(localtime_r)(timep, result);\n  if (res) {\n    COMMON_INTERCEPTOR_READ_RANGE(ctx, timep, sizeof(*timep));\n    unpoison_tm(ctx, res);\n  }\n  return res;\n}\nINTERCEPTOR(__sanitizer_tm *, gmtime, unsigned long *timep) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, gmtime, timep);\n  __sanitizer_tm *res = REAL(gmtime)(timep);\n  if (res) {\n    COMMON_INTERCEPTOR_READ_RANGE(ctx, timep, sizeof(*timep));\n    unpoison_tm(ctx, res);\n  }\n  return res;\n}\nINTERCEPTOR(__sanitizer_tm *, gmtime_r, unsigned long *timep, void *result) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, gmtime_r, timep, result);\n  __sanitizer_tm *res = REAL(gmtime_r)(timep, result);\n  if (res) {\n    COMMON_INTERCEPTOR_READ_RANGE(ctx, timep, sizeof(*timep));\n    unpoison_tm(ctx, res);\n  }\n  return res;\n}\nINTERCEPTOR(char *, ctime, unsigned long *timep) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, ctime, timep);\n  // FIXME: under ASan the call below may write to freed memory and corrupt\n  // its metadata. See\n  // https://github.com/google/sanitizers/issues/321.\n  char *res = REAL(ctime)(timep);\n  if (res) {\n    COMMON_INTERCEPTOR_READ_RANGE(ctx, timep, sizeof(*timep));\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, res, REAL(strlen)(res) + 1);\n  }\n  return res;\n}\nINTERCEPTOR(char *, ctime_r, unsigned long *timep, char *result) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, ctime_r, timep, result);\n  // FIXME: under ASan the call below may write to freed memory and corrupt\n  // its metadata. See\n  // https://github.com/google/sanitizers/issues/321.\n  char *res = REAL(ctime_r)(timep, result);\n  if (res) {\n    COMMON_INTERCEPTOR_READ_RANGE(ctx, timep, sizeof(*timep));\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, res, REAL(strlen)(res) + 1);\n  }\n  return res;\n}\nINTERCEPTOR(char *, asctime, __sanitizer_tm *tm) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, asctime, tm);\n  // FIXME: under ASan the call below may write to freed memory and corrupt\n  // its metadata. See\n  // https://github.com/google/sanitizers/issues/321.\n  char *res = REAL(asctime)(tm);\n  if (res) {\n    COMMON_INTERCEPTOR_READ_RANGE(ctx, tm, sizeof(*tm));\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, res, REAL(strlen)(res) + 1);\n  }\n  return res;\n}\nINTERCEPTOR(char *, asctime_r, __sanitizer_tm *tm, char *result) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, asctime_r, tm, result);\n  // FIXME: under ASan the call below may write to freed memory and corrupt\n  // its metadata. See\n  // https://github.com/google/sanitizers/issues/321.\n  char *res = REAL(asctime_r)(tm, result);\n  if (res) {\n    COMMON_INTERCEPTOR_READ_RANGE(ctx, tm, sizeof(*tm));\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, res, REAL(strlen)(res) + 1);\n  }\n  return res;\n}\nINTERCEPTOR(long, mktime, __sanitizer_tm *tm) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, mktime, tm);\n  COMMON_INTERCEPTOR_READ_RANGE(ctx, &tm->tm_sec, sizeof(tm->tm_sec));\n  COMMON_INTERCEPTOR_READ_RANGE(ctx, &tm->tm_min, sizeof(tm->tm_min));\n  COMMON_INTERCEPTOR_READ_RANGE(ctx, &tm->tm_hour, sizeof(tm->tm_hour));\n  COMMON_INTERCEPTOR_READ_RANGE(ctx, &tm->tm_mday, sizeof(tm->tm_mday));\n  COMMON_INTERCEPTOR_READ_RANGE(ctx, &tm->tm_mon, sizeof(tm->tm_mon));\n  COMMON_INTERCEPTOR_READ_RANGE(ctx, &tm->tm_year, sizeof(tm->tm_year));\n  COMMON_INTERCEPTOR_READ_RANGE(ctx, &tm->tm_isdst, sizeof(tm->tm_isdst));\n  long res = REAL(mktime)(tm);\n  if (res != -1) unpoison_tm(ctx, tm);\n  return res;\n}\n#define INIT_LOCALTIME_AND_FRIENDS        \\\n  COMMON_INTERCEPT_FUNCTION(localtime);   \\\n  COMMON_INTERCEPT_FUNCTION(localtime_r); \\\n  COMMON_INTERCEPT_FUNCTION(gmtime);      \\\n  COMMON_INTERCEPT_FUNCTION(gmtime_r);    \\\n  COMMON_INTERCEPT_FUNCTION(ctime);       \\\n  COMMON_INTERCEPT_FUNCTION(ctime_r);     \\\n  COMMON_INTERCEPT_FUNCTION(asctime);     \\\n  COMMON_INTERCEPT_FUNCTION(asctime_r);   \\\n  COMMON_INTERCEPT_FUNCTION(mktime);\n#else\n#define INIT_LOCALTIME_AND_FRIENDS\n#endif  // SANITIZER_INTERCEPT_LOCALTIME_AND_FRIENDS\n\n#if SANITIZER_INTERCEPT_STRPTIME\nINTERCEPTOR(char *, strptime, char *s, char *format, __sanitizer_tm *tm) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, strptime, s, format, tm);\n  if (format)\n    COMMON_INTERCEPTOR_READ_RANGE(ctx, format, REAL(strlen)(format) + 1);\n  // FIXME: under ASan the call below may write to freed memory and corrupt\n  // its metadata. See\n  // https://github.com/google/sanitizers/issues/321.\n  char *res = REAL(strptime)(s, format, tm);\n  COMMON_INTERCEPTOR_READ_STRING(ctx, s, res ? res - s : 0);\n  if (res && tm) {\n    // Do not call unpoison_tm here, because strptime does not, in fact,\n    // initialize the entire struct tm. For example, tm_zone pointer is left\n    // uninitialized.\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, tm, sizeof(*tm));\n  }\n  return res;\n}\n#define INIT_STRPTIME COMMON_INTERCEPT_FUNCTION(strptime);\n#else\n#define INIT_STRPTIME\n#endif\n\n#if SANITIZER_INTERCEPT_SCANF || SANITIZER_INTERCEPT_PRINTF\n#include \"sanitizer_common_interceptors_format.inc\"\n\n#define FORMAT_INTERCEPTOR_IMPL(name, vname, ...)                              \\\n  {                                                                            \\\n    void *ctx;                                                                 \\\n    va_list ap;                                                                \\\n    va_start(ap, format);                                                      \\\n    COMMON_INTERCEPTOR_ENTER(ctx, vname, __VA_ARGS__, ap);                     \\\n    int res = WRAP(vname)(__VA_ARGS__, ap);                                    \\\n    va_end(ap);                                                                \\\n    return res;                                                                \\\n  }\n\n#endif\n\n#if SANITIZER_INTERCEPT_SCANF\n\n#define VSCANF_INTERCEPTOR_IMPL(vname, allowGnuMalloc, ...)                    \\\n  {                                                                            \\\n    void *ctx;                                                                 \\\n    COMMON_INTERCEPTOR_ENTER(ctx, vname, __VA_ARGS__);                         \\\n    va_list aq;                                                                \\\n    va_copy(aq, ap);                                                           \\\n    int res = REAL(vname)(__VA_ARGS__);                                        \\\n    if (res > 0)                                                               \\\n      scanf_common(ctx, res, allowGnuMalloc, format, aq);                      \\\n    va_end(aq);                                                                \\\n    return res;                                                                \\\n  }\n\nINTERCEPTOR(int, vscanf, const char *format, va_list ap)\nVSCANF_INTERCEPTOR_IMPL(vscanf, true, format, ap)\n\nINTERCEPTOR(int, vsscanf, const char *str, const char *format, va_list ap)\nVSCANF_INTERCEPTOR_IMPL(vsscanf, true, str, format, ap)\n\nINTERCEPTOR(int, vfscanf, void *stream, const char *format, va_list ap)\nVSCANF_INTERCEPTOR_IMPL(vfscanf, true, stream, format, ap)\n\n#if SANITIZER_INTERCEPT_ISOC99_SCANF\nINTERCEPTOR(int, __isoc99_vscanf, const char *format, va_list ap)\nVSCANF_INTERCEPTOR_IMPL(__isoc99_vscanf, false, format, ap)\n\nINTERCEPTOR(int, __isoc99_vsscanf, const char *str, const char *format,\n            va_list ap)\nVSCANF_INTERCEPTOR_IMPL(__isoc99_vsscanf, false, str, format, ap)\n\nINTERCEPTOR(int, __isoc99_vfscanf, void *stream, const char *format, va_list ap)\nVSCANF_INTERCEPTOR_IMPL(__isoc99_vfscanf, false, stream, format, ap)\n#endif  // SANITIZER_INTERCEPT_ISOC99_SCANF\n\nINTERCEPTOR(int, scanf, const char *format, ...)\nFORMAT_INTERCEPTOR_IMPL(scanf, vscanf, format)\n\nINTERCEPTOR(int, fscanf, void *stream, const char *format, ...)\nFORMAT_INTERCEPTOR_IMPL(fscanf, vfscanf, stream, format)\n\nINTERCEPTOR(int, sscanf, const char *str, const char *format, ...)\nFORMAT_INTERCEPTOR_IMPL(sscanf, vsscanf, str, format)\n\n#if SANITIZER_INTERCEPT_ISOC99_SCANF\nINTERCEPTOR(int, __isoc99_scanf, const char *format, ...)\nFORMAT_INTERCEPTOR_IMPL(__isoc99_scanf, __isoc99_vscanf, format)\n\nINTERCEPTOR(int, __isoc99_fscanf, void *stream, const char *format, ...)\nFORMAT_INTERCEPTOR_IMPL(__isoc99_fscanf, __isoc99_vfscanf, stream, format)\n\nINTERCEPTOR(int, __isoc99_sscanf, const char *str, const char *format, ...)\nFORMAT_INTERCEPTOR_IMPL(__isoc99_sscanf, __isoc99_vsscanf, str, format)\n#endif\n\n#endif\n\n#if SANITIZER_INTERCEPT_SCANF\n#define INIT_SCANF                    \\\n  COMMON_INTERCEPT_FUNCTION_LDBL(scanf);   \\\n  COMMON_INTERCEPT_FUNCTION_LDBL(sscanf);  \\\n  COMMON_INTERCEPT_FUNCTION_LDBL(fscanf);  \\\n  COMMON_INTERCEPT_FUNCTION_LDBL(vscanf);  \\\n  COMMON_INTERCEPT_FUNCTION_LDBL(vsscanf); \\\n  COMMON_INTERCEPT_FUNCTION_LDBL(vfscanf);\n#else\n#define INIT_SCANF\n#endif\n\n#if SANITIZER_INTERCEPT_ISOC99_SCANF\n#define INIT_ISOC99_SCANF                      \\\n  COMMON_INTERCEPT_FUNCTION(__isoc99_scanf);   \\\n  COMMON_INTERCEPT_FUNCTION(__isoc99_sscanf);  \\\n  COMMON_INTERCEPT_FUNCTION(__isoc99_fscanf);  \\\n  COMMON_INTERCEPT_FUNCTION(__isoc99_vscanf);  \\\n  COMMON_INTERCEPT_FUNCTION(__isoc99_vsscanf); \\\n  COMMON_INTERCEPT_FUNCTION(__isoc99_vfscanf);\n#else\n#define INIT_ISOC99_SCANF\n#endif\n\n#if SANITIZER_INTERCEPT_PRINTF\n\n#define VPRINTF_INTERCEPTOR_ENTER(vname, ...)                                  \\\n  void *ctx;                                                                   \\\n  COMMON_INTERCEPTOR_ENTER(ctx, vname, __VA_ARGS__);                           \\\n  va_list aq;                                                                  \\\n  va_copy(aq, ap);\n\n#define VPRINTF_INTERCEPTOR_RETURN()                                           \\\n  va_end(aq);\n\n#define VPRINTF_INTERCEPTOR_IMPL(vname, ...)                                   \\\n  {                                                                            \\\n    VPRINTF_INTERCEPTOR_ENTER(vname, __VA_ARGS__);                             \\\n    if (common_flags()->check_printf)                                          \\\n      printf_common(ctx, format, aq);                                          \\\n    int res = REAL(vname)(__VA_ARGS__);                                        \\\n    VPRINTF_INTERCEPTOR_RETURN();                                              \\\n    return res;                                                                \\\n  }\n\n// FIXME: under ASan the REAL() call below may write to freed memory and\n// corrupt its metadata. See\n// https://github.com/google/sanitizers/issues/321.\n#define VSPRINTF_INTERCEPTOR_IMPL(vname, str, ...)                             \\\n  {                                                                            \\\n    VPRINTF_INTERCEPTOR_ENTER(vname, str, __VA_ARGS__)                         \\\n    if (common_flags()->check_printf) {                                        \\\n      printf_common(ctx, format, aq);                                          \\\n    }                                                                          \\\n    int res = REAL(vname)(str, __VA_ARGS__);                                   \\\n    if (res >= 0) {                                                            \\\n      COMMON_INTERCEPTOR_WRITE_RANGE(ctx, str, res + 1);                       \\\n    }                                                                          \\\n    VPRINTF_INTERCEPTOR_RETURN();                                              \\\n    return res;                                                                \\\n  }\n\n// FIXME: under ASan the REAL() call below may write to freed memory and\n// corrupt its metadata. See\n// https://github.com/google/sanitizers/issues/321.\n#define VSNPRINTF_INTERCEPTOR_IMPL(vname, str, size, ...)                      \\\n  {                                                                            \\\n    VPRINTF_INTERCEPTOR_ENTER(vname, str, size, __VA_ARGS__)                   \\\n    if (common_flags()->check_printf) {                                        \\\n      printf_common(ctx, format, aq);                                          \\\n    }                                                                          \\\n    int res = REAL(vname)(str, size, __VA_ARGS__);                             \\\n    if (res >= 0) {                                                            \\\n      COMMON_INTERCEPTOR_WRITE_RANGE(ctx, str, Min(size, (SIZE_T)(res + 1)));  \\\n    }                                                                          \\\n    VPRINTF_INTERCEPTOR_RETURN();                                              \\\n    return res;                                                                \\\n  }\n\n// FIXME: under ASan the REAL() call below may write to freed memory and\n// corrupt its metadata. See\n// https://github.com/google/sanitizers/issues/321.\n#define VASPRINTF_INTERCEPTOR_IMPL(vname, strp, ...)                           \\\n  {                                                                            \\\n    VPRINTF_INTERCEPTOR_ENTER(vname, strp, __VA_ARGS__)                        \\\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, strp, sizeof(char *));                 \\\n    if (common_flags()->check_printf) {                                        \\\n      printf_common(ctx, format, aq);                                          \\\n    }                                                                          \\\n    int res = REAL(vname)(strp, __VA_ARGS__);                                  \\\n    if (res >= 0) {                                                            \\\n      COMMON_INTERCEPTOR_WRITE_RANGE(ctx, *strp, res + 1);                     \\\n    }                                                                          \\\n    VPRINTF_INTERCEPTOR_RETURN();                                              \\\n    return res;                                                                \\\n  }\n\nINTERCEPTOR(int, vprintf, const char *format, va_list ap)\nVPRINTF_INTERCEPTOR_IMPL(vprintf, format, ap)\n\nINTERCEPTOR(int, vfprintf, __sanitizer_FILE *stream, const char *format,\n            va_list ap)\nVPRINTF_INTERCEPTOR_IMPL(vfprintf, stream, format, ap)\n\nINTERCEPTOR(int, vsnprintf, char *str, SIZE_T size, const char *format,\n            va_list ap)\nVSNPRINTF_INTERCEPTOR_IMPL(vsnprintf, str, size, format, ap)\n\n#if SANITIZER_INTERCEPT___PRINTF_CHK\nINTERCEPTOR(int, __vsnprintf_chk, char *str, SIZE_T size, int flag,\n            SIZE_T size_to, const char *format, va_list ap)\nVSNPRINTF_INTERCEPTOR_IMPL(vsnprintf, str, size, format, ap)\n#endif\n\n#if SANITIZER_INTERCEPT_PRINTF_L\nINTERCEPTOR(int, vsnprintf_l, char *str, SIZE_T size, void *loc,\n            const char *format, va_list ap)\nVSNPRINTF_INTERCEPTOR_IMPL(vsnprintf_l, str, size, loc, format, ap)\n\nINTERCEPTOR(int, snprintf_l, char *str, SIZE_T size, void *loc,\n            const char *format, ...)\nFORMAT_INTERCEPTOR_IMPL(snprintf_l, vsnprintf_l, str, size, loc, format)\n#endif  // SANITIZER_INTERCEPT_PRINTF_L\n\nINTERCEPTOR(int, vsprintf, char *str, const char *format, va_list ap)\nVSPRINTF_INTERCEPTOR_IMPL(vsprintf, str, format, ap)\n\n#if SANITIZER_INTERCEPT___PRINTF_CHK\nINTERCEPTOR(int, __vsprintf_chk, char *str, int flag, SIZE_T size_to,\n            const char *format, va_list ap)\nVSPRINTF_INTERCEPTOR_IMPL(vsprintf, str, format, ap)\n#endif\n\nINTERCEPTOR(int, vasprintf, char **strp, const char *format, va_list ap)\nVASPRINTF_INTERCEPTOR_IMPL(vasprintf, strp, format, ap)\n\n#if SANITIZER_INTERCEPT_ISOC99_PRINTF\nINTERCEPTOR(int, __isoc99_vprintf, const char *format, va_list ap)\nVPRINTF_INTERCEPTOR_IMPL(__isoc99_vprintf, format, ap)\n\nINTERCEPTOR(int, __isoc99_vfprintf, __sanitizer_FILE *stream,\n            const char *format, va_list ap)\nVPRINTF_INTERCEPTOR_IMPL(__isoc99_vfprintf, stream, format, ap)\n\nINTERCEPTOR(int, __isoc99_vsnprintf, char *str, SIZE_T size, const char *format,\n            va_list ap)\nVSNPRINTF_INTERCEPTOR_IMPL(__isoc99_vsnprintf, str, size, format, ap)\n\nINTERCEPTOR(int, __isoc99_vsprintf, char *str, const char *format,\n            va_list ap)\nVSPRINTF_INTERCEPTOR_IMPL(__isoc99_vsprintf, str, format,\n                          ap)\n\n#endif  // SANITIZER_INTERCEPT_ISOC99_PRINTF\n\nINTERCEPTOR(int, printf, const char *format, ...)\nFORMAT_INTERCEPTOR_IMPL(printf, vprintf, format)\n\nINTERCEPTOR(int, fprintf, __sanitizer_FILE *stream, const char *format, ...)\nFORMAT_INTERCEPTOR_IMPL(fprintf, vfprintf, stream, format)\n\n#if SANITIZER_INTERCEPT___PRINTF_CHK\nINTERCEPTOR(int, __fprintf_chk, __sanitizer_FILE *stream, SIZE_T size,\n            const char *format, ...)\nFORMAT_INTERCEPTOR_IMPL(__fprintf_chk, vfprintf, stream, format)\n#endif\n\nINTERCEPTOR(int, sprintf, char *str, const char *format, ...)\nFORMAT_INTERCEPTOR_IMPL(sprintf, vsprintf, str, format)\n\n#if SANITIZER_INTERCEPT___PRINTF_CHK\nINTERCEPTOR(int, __sprintf_chk, char *str, int flag, SIZE_T size_to,\n            const char *format, ...)\nFORMAT_INTERCEPTOR_IMPL(__sprintf_chk, vsprintf, str, format)\n#endif\n\nINTERCEPTOR(int, snprintf, char *str, SIZE_T size, const char *format, ...)\nFORMAT_INTERCEPTOR_IMPL(snprintf, vsnprintf, str, size, format)\n\n#if SANITIZER_INTERCEPT___PRINTF_CHK\nINTERCEPTOR(int, __snprintf_chk, char *str, SIZE_T size, int flag,\n            SIZE_T size_to, const char *format, ...)\nFORMAT_INTERCEPTOR_IMPL(__snprintf_chk, vsnprintf, str, size, format)\n#endif\n\nINTERCEPTOR(int, asprintf, char **strp, const char *format, ...)\nFORMAT_INTERCEPTOR_IMPL(asprintf, vasprintf, strp, format)\n\n#if SANITIZER_INTERCEPT_ISOC99_PRINTF\nINTERCEPTOR(int, __isoc99_printf, const char *format, ...)\nFORMAT_INTERCEPTOR_IMPL(__isoc99_printf, __isoc99_vprintf, format)\n\nINTERCEPTOR(int, __isoc99_fprintf, __sanitizer_FILE *stream, const char *format,\n            ...)\nFORMAT_INTERCEPTOR_IMPL(__isoc99_fprintf, __isoc99_vfprintf, stream, format)\n\nINTERCEPTOR(int, __isoc99_sprintf, char *str, const char *format, ...)\nFORMAT_INTERCEPTOR_IMPL(__isoc99_sprintf, __isoc99_vsprintf, str, format)\n\nINTERCEPTOR(int, __isoc99_snprintf, char *str, SIZE_T size,\n            const char *format, ...)\nFORMAT_INTERCEPTOR_IMPL(__isoc99_snprintf, __isoc99_vsnprintf, str, size,\n                        format)\n\n#endif  // SANITIZER_INTERCEPT_ISOC99_PRINTF\n\n#endif  // SANITIZER_INTERCEPT_PRINTF\n\n#if SANITIZER_INTERCEPT_PRINTF\n#define INIT_PRINTF                     \\\n  COMMON_INTERCEPT_FUNCTION_LDBL(printf);    \\\n  COMMON_INTERCEPT_FUNCTION_LDBL(sprintf);   \\\n  COMMON_INTERCEPT_FUNCTION_LDBL(snprintf);  \\\n  COMMON_INTERCEPT_FUNCTION_LDBL(asprintf);  \\\n  COMMON_INTERCEPT_FUNCTION_LDBL(fprintf);   \\\n  COMMON_INTERCEPT_FUNCTION_LDBL(vprintf);   \\\n  COMMON_INTERCEPT_FUNCTION_LDBL(vsprintf);  \\\n  COMMON_INTERCEPT_FUNCTION_LDBL(vsnprintf); \\\n  COMMON_INTERCEPT_FUNCTION_LDBL(vasprintf); \\\n  COMMON_INTERCEPT_FUNCTION_LDBL(vfprintf);\n#else\n#define INIT_PRINTF\n#endif\n\n#if SANITIZER_INTERCEPT___PRINTF_CHK\n#define INIT___PRINTF_CHK                     \\\n  COMMON_INTERCEPT_FUNCTION(__sprintf_chk);   \\\n  COMMON_INTERCEPT_FUNCTION(__snprintf_chk);  \\\n  COMMON_INTERCEPT_FUNCTION(__vsprintf_chk);  \\\n  COMMON_INTERCEPT_FUNCTION(__vsnprintf_chk); \\\n  COMMON_INTERCEPT_FUNCTION(__fprintf_chk);\n#else\n#define INIT___PRINTF_CHK\n#endif\n\n#if SANITIZER_INTERCEPT_PRINTF_L\n#define INIT_PRINTF_L                     \\\n  COMMON_INTERCEPT_FUNCTION(snprintf_l);  \\\n  COMMON_INTERCEPT_FUNCTION(vsnprintf_l);\n#else\n#define INIT_PRINTF_L\n#endif\n\n#if SANITIZER_INTERCEPT_ISOC99_PRINTF\n#define INIT_ISOC99_PRINTF                       \\\n  COMMON_INTERCEPT_FUNCTION(__isoc99_printf);    \\\n  COMMON_INTERCEPT_FUNCTION(__isoc99_sprintf);   \\\n  COMMON_INTERCEPT_FUNCTION(__isoc99_snprintf);  \\\n  COMMON_INTERCEPT_FUNCTION(__isoc99_fprintf);   \\\n  COMMON_INTERCEPT_FUNCTION(__isoc99_vprintf);   \\\n  COMMON_INTERCEPT_FUNCTION(__isoc99_vsprintf);  \\\n  COMMON_INTERCEPT_FUNCTION(__isoc99_vsnprintf); \\\n  COMMON_INTERCEPT_FUNCTION(__isoc99_vfprintf);\n#else\n#define INIT_ISOC99_PRINTF\n#endif\n\n#if SANITIZER_INTERCEPT_IOCTL\n#include \"sanitizer_common_interceptors_ioctl.inc\"\n#include \"sanitizer_interceptors_ioctl_netbsd.inc\"\nINTERCEPTOR(int, ioctl, int d, unsigned long request, ...) {\n  // We need a frame pointer, because we call into ioctl_common_[pre|post] which\n  // can trigger a report and we need to be able to unwind through this\n  // function.  On Mac in debug mode we might not have a frame pointer, because\n  // ioctl_common_[pre|post] doesn't get inlined here.\n  ENABLE_FRAME_POINTER;\n\n  void *ctx;\n  va_list ap;\n  va_start(ap, request);\n  void *arg = va_arg(ap, void *);\n  va_end(ap);\n  COMMON_INTERCEPTOR_ENTER(ctx, ioctl, d, request, arg);\n\n  CHECK(ioctl_initialized);\n\n  // Note: TSan does not use common flags, and they are zero-initialized.\n  // This effectively disables ioctl handling in TSan.\n  if (!common_flags()->handle_ioctl) return REAL(ioctl)(d, request, arg);\n\n  // Although request is unsigned long, the rest of the interceptor uses it\n  // as just \"unsigned\" to save space, because we know that all values fit in\n  // \"unsigned\" - they are compile-time constants.\n\n  const ioctl_desc *desc = ioctl_lookup(request);\n  ioctl_desc decoded_desc;\n  if (!desc) {\n    VPrintf(2, \"Decoding unknown ioctl 0x%x\\n\", request);\n    if (!ioctl_decode(request, &decoded_desc))\n      Printf(\"WARNING: failed decoding unknown ioctl 0x%x\\n\", request);\n    else\n      desc = &decoded_desc;\n  }\n\n  if (desc) ioctl_common_pre(ctx, desc, d, request, arg);\n  int res = REAL(ioctl)(d, request, arg);\n  // FIXME: some ioctls have different return values for success and failure.\n  if (desc && res != -1) ioctl_common_post(ctx, desc, res, d, request, arg);\n  return res;\n}\n#define INIT_IOCTL \\\n  ioctl_init();    \\\n  COMMON_INTERCEPT_FUNCTION(ioctl);\n#else\n#define INIT_IOCTL\n#endif\n\n#if SANITIZER_POSIX\nUNUSED static void unpoison_passwd(void *ctx, __sanitizer_passwd *pwd) {\n  if (pwd) {\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, pwd, sizeof(*pwd));\n    if (pwd->pw_name)\n      COMMON_INTERCEPTOR_WRITE_RANGE(ctx, pwd->pw_name,\n                                     REAL(strlen)(pwd->pw_name) + 1);\n    if (pwd->pw_passwd)\n      COMMON_INTERCEPTOR_WRITE_RANGE(ctx, pwd->pw_passwd,\n                                     REAL(strlen)(pwd->pw_passwd) + 1);\n#if !SANITIZER_ANDROID\n    if (pwd->pw_gecos)\n      COMMON_INTERCEPTOR_WRITE_RANGE(ctx, pwd->pw_gecos,\n                                     REAL(strlen)(pwd->pw_gecos) + 1);\n#endif\n#if SANITIZER_MAC || SANITIZER_FREEBSD || SANITIZER_NETBSD\n    if (pwd->pw_class)\n      COMMON_INTERCEPTOR_WRITE_RANGE(ctx, pwd->pw_class,\n                                     REAL(strlen)(pwd->pw_class) + 1);\n#endif\n    if (pwd->pw_dir)\n      COMMON_INTERCEPTOR_WRITE_RANGE(ctx, pwd->pw_dir,\n                                     REAL(strlen)(pwd->pw_dir) + 1);\n    if (pwd->pw_shell)\n      COMMON_INTERCEPTOR_WRITE_RANGE(ctx, pwd->pw_shell,\n                                     REAL(strlen)(pwd->pw_shell) + 1);\n  }\n}\n\nUNUSED static void unpoison_group(void *ctx, __sanitizer_group *grp) {\n  if (grp) {\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, grp, sizeof(*grp));\n    if (grp->gr_name)\n      COMMON_INTERCEPTOR_WRITE_RANGE(ctx, grp->gr_name,\n                                     REAL(strlen)(grp->gr_name) + 1);\n    if (grp->gr_passwd)\n      COMMON_INTERCEPTOR_WRITE_RANGE(ctx, grp->gr_passwd,\n                                     REAL(strlen)(grp->gr_passwd) + 1);\n    char **p = grp->gr_mem;\n    for (; *p; ++p) {\n      COMMON_INTERCEPTOR_WRITE_RANGE(ctx, *p, REAL(strlen)(*p) + 1);\n    }\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, grp->gr_mem,\n                                   (p - grp->gr_mem + 1) * sizeof(*p));\n  }\n}\n#endif  // SANITIZER_POSIX\n\n#if SANITIZER_INTERCEPT_GETPWNAM_AND_FRIENDS\nINTERCEPTOR(__sanitizer_passwd *, getpwnam, const char *name) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, getpwnam, name);\n  if (name)\n    COMMON_INTERCEPTOR_READ_RANGE(ctx, name, REAL(strlen)(name) + 1);\n  __sanitizer_passwd *res = REAL(getpwnam)(name);\n  unpoison_passwd(ctx, res);\n  return res;\n}\nINTERCEPTOR(__sanitizer_passwd *, getpwuid, u32 uid) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, getpwuid, uid);\n  __sanitizer_passwd *res = REAL(getpwuid)(uid);\n  unpoison_passwd(ctx, res);\n  return res;\n}\nINTERCEPTOR(__sanitizer_group *, getgrnam, const char *name) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, getgrnam, name);\n  COMMON_INTERCEPTOR_READ_RANGE(ctx, name, REAL(strlen)(name) + 1);\n  __sanitizer_group *res = REAL(getgrnam)(name);\n  unpoison_group(ctx, res);\n  return res;\n}\nINTERCEPTOR(__sanitizer_group *, getgrgid, u32 gid) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, getgrgid, gid);\n  __sanitizer_group *res = REAL(getgrgid)(gid);\n  unpoison_group(ctx, res);\n  return res;\n}\n#define INIT_GETPWNAM_AND_FRIENDS      \\\n  COMMON_INTERCEPT_FUNCTION(getpwnam); \\\n  COMMON_INTERCEPT_FUNCTION(getpwuid); \\\n  COMMON_INTERCEPT_FUNCTION(getgrnam); \\\n  COMMON_INTERCEPT_FUNCTION(getgrgid);\n#else\n#define INIT_GETPWNAM_AND_FRIENDS\n#endif\n\n#if SANITIZER_INTERCEPT_GETPWNAM_R_AND_FRIENDS\nINTERCEPTOR(int, getpwnam_r, const char *name, __sanitizer_passwd *pwd,\n            char *buf, SIZE_T buflen, __sanitizer_passwd **result) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, getpwnam_r, name, pwd, buf, buflen, result);\n  COMMON_INTERCEPTOR_READ_RANGE(ctx, name, REAL(strlen)(name) + 1);\n  // FIXME: under ASan the call below may write to freed memory and corrupt\n  // its metadata. See\n  // https://github.com/google/sanitizers/issues/321.\n  int res = REAL(getpwnam_r)(name, pwd, buf, buflen, result);\n  if (!res && result)\n    unpoison_passwd(ctx, *result);\n  if (result) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, result, sizeof(*result));\n  return res;\n}\nINTERCEPTOR(int, getpwuid_r, u32 uid, __sanitizer_passwd *pwd, char *buf,\n            SIZE_T buflen, __sanitizer_passwd **result) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, getpwuid_r, uid, pwd, buf, buflen, result);\n  // FIXME: under ASan the call below may write to freed memory and corrupt\n  // its metadata. See\n  // https://github.com/google/sanitizers/issues/321.\n  int res = REAL(getpwuid_r)(uid, pwd, buf, buflen, result);\n  if (!res && result)\n    unpoison_passwd(ctx, *result);\n  if (result) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, result, sizeof(*result));\n  return res;\n}\nINTERCEPTOR(int, getgrnam_r, const char *name, __sanitizer_group *grp,\n            char *buf, SIZE_T buflen, __sanitizer_group **result) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, getgrnam_r, name, grp, buf, buflen, result);\n  COMMON_INTERCEPTOR_READ_RANGE(ctx, name, REAL(strlen)(name) + 1);\n  // FIXME: under ASan the call below may write to freed memory and corrupt\n  // its metadata. See\n  // https://github.com/google/sanitizers/issues/321.\n  int res = REAL(getgrnam_r)(name, grp, buf, buflen, result);\n  if (!res && result)\n    unpoison_group(ctx, *result);\n  if (result) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, result, sizeof(*result));\n  return res;\n}\nINTERCEPTOR(int, getgrgid_r, u32 gid, __sanitizer_group *grp, char *buf,\n            SIZE_T buflen, __sanitizer_group **result) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, getgrgid_r, gid, grp, buf, buflen, result);\n  // FIXME: under ASan the call below may write to freed memory and corrupt\n  // its metadata. See\n  // https://github.com/google/sanitizers/issues/321.\n  int res = REAL(getgrgid_r)(gid, grp, buf, buflen, result);\n  if (!res && result)\n    unpoison_group(ctx, *result);\n  if (result) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, result, sizeof(*result));\n  return res;\n}\n#define INIT_GETPWNAM_R_AND_FRIENDS      \\\n  COMMON_INTERCEPT_FUNCTION(getpwnam_r); \\\n  COMMON_INTERCEPT_FUNCTION(getpwuid_r); \\\n  COMMON_INTERCEPT_FUNCTION(getgrnam_r); \\\n  COMMON_INTERCEPT_FUNCTION(getgrgid_r);\n#else\n#define INIT_GETPWNAM_R_AND_FRIENDS\n#endif\n\n#if SANITIZER_INTERCEPT_GETPWENT\nINTERCEPTOR(__sanitizer_passwd *, getpwent, int dummy) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, getpwent, dummy);\n  __sanitizer_passwd *res = REAL(getpwent)(dummy);\n  unpoison_passwd(ctx, res);\n  return res;\n}\nINTERCEPTOR(__sanitizer_group *, getgrent, int dummy) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, getgrent, dummy);\n  __sanitizer_group *res = REAL(getgrent)(dummy);\n  unpoison_group(ctx, res);\n  return res;\n}\n#define INIT_GETPWENT                  \\\n  COMMON_INTERCEPT_FUNCTION(getpwent); \\\n  COMMON_INTERCEPT_FUNCTION(getgrent);\n#else\n#define INIT_GETPWENT\n#endif\n\n#if SANITIZER_INTERCEPT_FGETPWENT\nINTERCEPTOR(__sanitizer_passwd *, fgetpwent, void *fp) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, fgetpwent, fp);\n  __sanitizer_passwd *res = REAL(fgetpwent)(fp);\n  unpoison_passwd(ctx, res);\n  return res;\n}\nINTERCEPTOR(__sanitizer_group *, fgetgrent, void *fp) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, fgetgrent, fp);\n  __sanitizer_group *res = REAL(fgetgrent)(fp);\n  unpoison_group(ctx, res);\n  return res;\n}\n#define INIT_FGETPWENT                  \\\n  COMMON_INTERCEPT_FUNCTION(fgetpwent); \\\n  COMMON_INTERCEPT_FUNCTION(fgetgrent);\n#else\n#define INIT_FGETPWENT\n#endif\n\n#if SANITIZER_INTERCEPT_GETPWENT_R\nINTERCEPTOR(int, getpwent_r, __sanitizer_passwd *pwbuf, char *buf,\n            SIZE_T buflen, __sanitizer_passwd **pwbufp) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, getpwent_r, pwbuf, buf, buflen, pwbufp);\n  // FIXME: under ASan the call below may write to freed memory and corrupt\n  // its metadata. See\n  // https://github.com/google/sanitizers/issues/321.\n  int res = REAL(getpwent_r)(pwbuf, buf, buflen, pwbufp);\n  if (!res && pwbufp)\n    unpoison_passwd(ctx, *pwbufp);\n  if (pwbufp) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, pwbufp, sizeof(*pwbufp));\n  return res;\n}\nINTERCEPTOR(int, getgrent_r, __sanitizer_group *pwbuf, char *buf, SIZE_T buflen,\n            __sanitizer_group **pwbufp) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, getgrent_r, pwbuf, buf, buflen, pwbufp);\n  // FIXME: under ASan the call below may write to freed memory and corrupt\n  // its metadata. See\n  // https://github.com/google/sanitizers/issues/321.\n  int res = REAL(getgrent_r)(pwbuf, buf, buflen, pwbufp);\n  if (!res && pwbufp)\n    unpoison_group(ctx, *pwbufp);\n  if (pwbufp) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, pwbufp, sizeof(*pwbufp));\n  return res;\n}\n#define INIT_GETPWENT_R                   \\\n  COMMON_INTERCEPT_FUNCTION(getpwent_r);  \\\n  COMMON_INTERCEPT_FUNCTION(getgrent_r);\n#else\n#define INIT_GETPWENT_R\n#endif\n\n#if SANITIZER_INTERCEPT_FGETPWENT_R\nINTERCEPTOR(int, fgetpwent_r, void *fp, __sanitizer_passwd *pwbuf, char *buf,\n            SIZE_T buflen, __sanitizer_passwd **pwbufp) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, fgetpwent_r, fp, pwbuf, buf, buflen, pwbufp);\n  // FIXME: under ASan the call below may write to freed memory and corrupt\n  // its metadata. See\n  // https://github.com/google/sanitizers/issues/321.\n  int res = REAL(fgetpwent_r)(fp, pwbuf, buf, buflen, pwbufp);\n  if (!res && pwbufp)\n    unpoison_passwd(ctx, *pwbufp);\n  if (pwbufp) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, pwbufp, sizeof(*pwbufp));\n  return res;\n}\n#define INIT_FGETPWENT_R                  \\\n  COMMON_INTERCEPT_FUNCTION(fgetpwent_r);\n#else\n#define INIT_FGETPWENT_R\n#endif\n\n#if SANITIZER_INTERCEPT_FGETGRENT_R\nINTERCEPTOR(int, fgetgrent_r, void *fp, __sanitizer_group *pwbuf, char *buf,\n            SIZE_T buflen, __sanitizer_group **pwbufp) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, fgetgrent_r, fp, pwbuf, buf, buflen, pwbufp);\n  // FIXME: under ASan the call below may write to freed memory and corrupt\n  // its metadata. See\n  // https://github.com/google/sanitizers/issues/321.\n  int res = REAL(fgetgrent_r)(fp, pwbuf, buf, buflen, pwbufp);\n  if (!res && pwbufp)\n    unpoison_group(ctx, *pwbufp);\n  if (pwbufp) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, pwbufp, sizeof(*pwbufp));\n  return res;\n}\n#define INIT_FGETGRENT_R                  \\\n  COMMON_INTERCEPT_FUNCTION(fgetgrent_r);\n#else\n#define INIT_FGETGRENT_R\n#endif\n\n#if SANITIZER_INTERCEPT_SETPWENT\n// The only thing these interceptors do is disable any nested interceptors.\n// These functions may open nss modules and call uninstrumented functions from\n// them, and we don't want things like strlen() to trigger.\nINTERCEPTOR(void, setpwent, int dummy) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, setpwent, dummy);\n  REAL(setpwent)(dummy);\n}\nINTERCEPTOR(void, endpwent, int dummy) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, endpwent, dummy);\n  REAL(endpwent)(dummy);\n}\nINTERCEPTOR(void, setgrent, int dummy) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, setgrent, dummy);\n  REAL(setgrent)(dummy);\n}\nINTERCEPTOR(void, endgrent, int dummy) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, endgrent, dummy);\n  REAL(endgrent)(dummy);\n}\n#define INIT_SETPWENT                  \\\n  COMMON_INTERCEPT_FUNCTION(setpwent); \\\n  COMMON_INTERCEPT_FUNCTION(endpwent); \\\n  COMMON_INTERCEPT_FUNCTION(setgrent); \\\n  COMMON_INTERCEPT_FUNCTION(endgrent);\n#else\n#define INIT_SETPWENT\n#endif\n\n#if SANITIZER_INTERCEPT_CLOCK_GETTIME\nINTERCEPTOR(int, clock_getres, u32 clk_id, void *tp) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, clock_getres, clk_id, tp);\n  // FIXME: under ASan the call below may write to freed memory and corrupt\n  // its metadata. See\n  // https://github.com/google/sanitizers/issues/321.\n  int res = REAL(clock_getres)(clk_id, tp);\n  if (!res && tp) {\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, tp, struct_timespec_sz);\n  }\n  return res;\n}\nINTERCEPTOR(int, clock_gettime, u32 clk_id, void *tp) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, clock_gettime, clk_id, tp);\n  // FIXME: under ASan the call below may write to freed memory and corrupt\n  // its metadata. See\n  // https://github.com/google/sanitizers/issues/321.\n  int res = REAL(clock_gettime)(clk_id, tp);\n  if (!res) {\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, tp, struct_timespec_sz);\n  }\n  return res;\n}\n#if SANITIZER_GLIBC\nnamespace __sanitizer {\nextern \"C\" {\nint real_clock_gettime(u32 clk_id, void *tp) {\n  if (COMMON_INTERCEPTOR_NOTHING_IS_INITIALIZED)\n    return internal_clock_gettime(clk_id, tp);\n  return REAL(clock_gettime)(clk_id, tp);\n}\n}  // extern \"C\"\n}  // namespace __sanitizer\n#endif\nINTERCEPTOR(int, clock_settime, u32 clk_id, const void *tp) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, clock_settime, clk_id, tp);\n  COMMON_INTERCEPTOR_READ_RANGE(ctx, tp, struct_timespec_sz);\n  return REAL(clock_settime)(clk_id, tp);\n}\n#define INIT_CLOCK_GETTIME                  \\\n  COMMON_INTERCEPT_FUNCTION(clock_getres);  \\\n  COMMON_INTERCEPT_FUNCTION(clock_gettime); \\\n  COMMON_INTERCEPT_FUNCTION(clock_settime);\n#else\n#define INIT_CLOCK_GETTIME\n#endif\n\n#if SANITIZER_INTERCEPT_CLOCK_GETCPUCLOCKID\nINTERCEPTOR(int, clock_getcpuclockid, pid_t pid,\n            __sanitizer_clockid_t *clockid) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, clock_getcpuclockid, pid, clockid);\n  int res = REAL(clock_getcpuclockid)(pid, clockid);\n  if (!res && clockid) {\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, clockid, sizeof *clockid);\n  }\n  return res;\n}\n\n#define INIT_CLOCK_GETCPUCLOCKID                  \\\n  COMMON_INTERCEPT_FUNCTION(clock_getcpuclockid);\n#else\n#define INIT_CLOCK_GETCPUCLOCKID\n#endif\n\n#if SANITIZER_INTERCEPT_GETITIMER\nINTERCEPTOR(int, getitimer, int which, void *curr_value) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, getitimer, which, curr_value);\n  // FIXME: under ASan the call below may write to freed memory and corrupt\n  // its metadata. See\n  // https://github.com/google/sanitizers/issues/321.\n  int res = REAL(getitimer)(which, curr_value);\n  if (!res && curr_value) {\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, curr_value, struct_itimerval_sz);\n  }\n  return res;\n}\nINTERCEPTOR(int, setitimer, int which, const void *new_value, void *old_value) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, setitimer, which, new_value, old_value);\n  if (new_value) {\n    // itimerval can contain padding that may be legitimately uninitialized\n    const struct __sanitizer_itimerval *nv =\n        (const struct __sanitizer_itimerval *)new_value;\n    COMMON_INTERCEPTOR_READ_RANGE(ctx, &nv->it_interval.tv_sec,\n                                  sizeof(__sanitizer_time_t));\n    COMMON_INTERCEPTOR_READ_RANGE(ctx, &nv->it_interval.tv_usec,\n                                  sizeof(__sanitizer_suseconds_t));\n    COMMON_INTERCEPTOR_READ_RANGE(ctx, &nv->it_value.tv_sec,\n                                  sizeof(__sanitizer_time_t));\n    COMMON_INTERCEPTOR_READ_RANGE(ctx, &nv->it_value.tv_usec,\n                                  sizeof(__sanitizer_suseconds_t));\n  }\n  // FIXME: under ASan the call below may write to freed memory and corrupt\n  // its metadata. See\n  // https://github.com/google/sanitizers/issues/321.\n  int res = REAL(setitimer)(which, new_value, old_value);\n  if (!res && old_value) {\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, old_value, struct_itimerval_sz);\n  }\n  return res;\n}\n#define INIT_GETITIMER                  \\\n  COMMON_INTERCEPT_FUNCTION(getitimer); \\\n  COMMON_INTERCEPT_FUNCTION(setitimer);\n#else\n#define INIT_GETITIMER\n#endif\n\n#if SANITIZER_INTERCEPT_GLOB\nstatic void unpoison_glob_t(void *ctx, __sanitizer_glob_t *pglob) {\n  COMMON_INTERCEPTOR_WRITE_RANGE(ctx, pglob, sizeof(*pglob));\n  // +1 for NULL pointer at the end.\n  if (pglob->gl_pathv)\n    COMMON_INTERCEPTOR_WRITE_RANGE(\n        ctx, pglob->gl_pathv, (pglob->gl_pathc + 1) * sizeof(*pglob->gl_pathv));\n  for (SIZE_T i = 0; i < pglob->gl_pathc; ++i) {\n    char *p = pglob->gl_pathv[i];\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, p, REAL(strlen)(p) + 1);\n  }\n}\n\n#if SANITIZER_SOLARIS\nINTERCEPTOR(int, glob, const char *pattern, int flags,\n            int (*errfunc)(const char *epath, int eerrno),\n            __sanitizer_glob_t *pglob) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, glob, pattern, flags, errfunc, pglob);\n  COMMON_INTERCEPTOR_READ_STRING(ctx, pattern, 0);\n  int res = REAL(glob)(pattern, flags, errfunc, pglob);\n  if ((!res || res == glob_nomatch) && pglob) unpoison_glob_t(ctx, pglob);\n  return res;\n}\n#else\nstatic THREADLOCAL __sanitizer_glob_t *pglob_copy;\n\nstatic void wrapped_gl_closedir(void *dir) {\n  COMMON_INTERCEPTOR_UNPOISON_PARAM(1);\n  pglob_copy->gl_closedir(dir);\n}\n\nstatic void *wrapped_gl_readdir(void *dir) {\n  COMMON_INTERCEPTOR_UNPOISON_PARAM(1);\n  return pglob_copy->gl_readdir(dir);\n}\n\nstatic void *wrapped_gl_opendir(const char *s) {\n  COMMON_INTERCEPTOR_UNPOISON_PARAM(1);\n  COMMON_INTERCEPTOR_INITIALIZE_RANGE(s, REAL(strlen)(s) + 1);\n  return pglob_copy->gl_opendir(s);\n}\n\nstatic int wrapped_gl_lstat(const char *s, void *st) {\n  COMMON_INTERCEPTOR_UNPOISON_PARAM(2);\n  COMMON_INTERCEPTOR_INITIALIZE_RANGE(s, REAL(strlen)(s) + 1);\n  return pglob_copy->gl_lstat(s, st);\n}\n\nstatic int wrapped_gl_stat(const char *s, void *st) {\n  COMMON_INTERCEPTOR_UNPOISON_PARAM(2);\n  COMMON_INTERCEPTOR_INITIALIZE_RANGE(s, REAL(strlen)(s) + 1);\n  return pglob_copy->gl_stat(s, st);\n}\n\nstatic const __sanitizer_glob_t kGlobCopy = {\n      0,                  0,                   0,\n      0,                  wrapped_gl_closedir, wrapped_gl_readdir,\n      wrapped_gl_opendir, wrapped_gl_lstat,    wrapped_gl_stat};\n\nINTERCEPTOR(int, glob, const char *pattern, int flags,\n            int (*errfunc)(const char *epath, int eerrno),\n            __sanitizer_glob_t *pglob) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, glob, pattern, flags, errfunc, pglob);\n  COMMON_INTERCEPTOR_READ_STRING(ctx, pattern, 0);\n  __sanitizer_glob_t glob_copy;\n  internal_memcpy(&glob_copy, &kGlobCopy, sizeof(glob_copy));\n  if (flags & glob_altdirfunc) {\n    Swap(pglob->gl_closedir, glob_copy.gl_closedir);\n    Swap(pglob->gl_readdir, glob_copy.gl_readdir);\n    Swap(pglob->gl_opendir, glob_copy.gl_opendir);\n    Swap(pglob->gl_lstat, glob_copy.gl_lstat);\n    Swap(pglob->gl_stat, glob_copy.gl_stat);\n    pglob_copy = &glob_copy;\n  }\n  int res = REAL(glob)(pattern, flags, errfunc, pglob);\n  if (flags & glob_altdirfunc) {\n    Swap(pglob->gl_closedir, glob_copy.gl_closedir);\n    Swap(pglob->gl_readdir, glob_copy.gl_readdir);\n    Swap(pglob->gl_opendir, glob_copy.gl_opendir);\n    Swap(pglob->gl_lstat, glob_copy.gl_lstat);\n    Swap(pglob->gl_stat, glob_copy.gl_stat);\n  }\n  pglob_copy = 0;\n  if ((!res || res == glob_nomatch) && pglob) unpoison_glob_t(ctx, pglob);\n  return res;\n}\n#endif  // SANITIZER_SOLARIS\n#define INIT_GLOB                  \\\n  COMMON_INTERCEPT_FUNCTION(glob);\n#else  // SANITIZER_INTERCEPT_GLOB\n#define INIT_GLOB\n#endif  // SANITIZER_INTERCEPT_GLOB\n\n#if SANITIZER_INTERCEPT_GLOB64\nINTERCEPTOR(int, glob64, const char *pattern, int flags,\n            int (*errfunc)(const char *epath, int eerrno),\n            __sanitizer_glob_t *pglob) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, glob64, pattern, flags, errfunc, pglob);\n  COMMON_INTERCEPTOR_READ_STRING(ctx, pattern, 0);\n  __sanitizer_glob_t glob_copy;\n  internal_memcpy(&glob_copy, &kGlobCopy, sizeof(glob_copy));\n  if (flags & glob_altdirfunc) {\n    Swap(pglob->gl_closedir, glob_copy.gl_closedir);\n    Swap(pglob->gl_readdir, glob_copy.gl_readdir);\n    Swap(pglob->gl_opendir, glob_copy.gl_opendir);\n    Swap(pglob->gl_lstat, glob_copy.gl_lstat);\n    Swap(pglob->gl_stat, glob_copy.gl_stat);\n    pglob_copy = &glob_copy;\n  }\n  int res = REAL(glob64)(pattern, flags, errfunc, pglob);\n  if (flags & glob_altdirfunc) {\n    Swap(pglob->gl_closedir, glob_copy.gl_closedir);\n    Swap(pglob->gl_readdir, glob_copy.gl_readdir);\n    Swap(pglob->gl_opendir, glob_copy.gl_opendir);\n    Swap(pglob->gl_lstat, glob_copy.gl_lstat);\n    Swap(pglob->gl_stat, glob_copy.gl_stat);\n  }\n  pglob_copy = 0;\n  if ((!res || res == glob_nomatch) && pglob) unpoison_glob_t(ctx, pglob);\n  return res;\n}\n#define INIT_GLOB64                \\\n  COMMON_INTERCEPT_FUNCTION(glob64);\n#else  // SANITIZER_INTERCEPT_GLOB64\n#define INIT_GLOB64\n#endif  // SANITIZER_INTERCEPT_GLOB64\n\n#if SANITIZER_INTERCEPT_WAIT\n// According to sys/wait.h, wait(), waitid(), waitpid() may have symbol version\n// suffixes on Darwin. See the declaration of INTERCEPTOR_WITH_SUFFIX for\n// details.\nINTERCEPTOR_WITH_SUFFIX(int, wait, int *status) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, wait, status);\n  // FIXME: under ASan the call below may write to freed memory and corrupt\n  // its metadata. See\n  // https://github.com/google/sanitizers/issues/321.\n  int res = REAL(wait)(status);\n  if (res != -1 && status)\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, status, sizeof(*status));\n  return res;\n}\n// On FreeBSD id_t is always 64-bit wide.\n#if SANITIZER_FREEBSD && (SANITIZER_WORDSIZE == 32)\nINTERCEPTOR_WITH_SUFFIX(int, waitid, int idtype, long long id, void *infop,\n                        int options) {\n#else\nINTERCEPTOR_WITH_SUFFIX(int, waitid, int idtype, int id, void *infop,\n                        int options) {\n#endif\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, waitid, idtype, id, infop, options);\n  // FIXME: under ASan the call below may write to freed memory and corrupt\n  // its metadata. See\n  // https://github.com/google/sanitizers/issues/321.\n  int res = REAL(waitid)(idtype, id, infop, options);\n  if (res != -1 && infop)\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, infop, siginfo_t_sz);\n  return res;\n}\nINTERCEPTOR_WITH_SUFFIX(int, waitpid, int pid, int *status, int options) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, waitpid, pid, status, options);\n  // FIXME: under ASan the call below may write to freed memory and corrupt\n  // its metadata. See\n  // https://github.com/google/sanitizers/issues/321.\n  int res = REAL(waitpid)(pid, status, options);\n  if (res != -1 && status)\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, status, sizeof(*status));\n  return res;\n}\nINTERCEPTOR(int, wait3, int *status, int options, void *rusage) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, wait3, status, options, rusage);\n  // FIXME: under ASan the call below may write to freed memory and corrupt\n  // its metadata. See\n  // https://github.com/google/sanitizers/issues/321.\n  int res = REAL(wait3)(status, options, rusage);\n  if (res != -1) {\n    if (status) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, status, sizeof(*status));\n    if (rusage) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, rusage, struct_rusage_sz);\n  }\n  return res;\n}\n#if SANITIZER_ANDROID\nINTERCEPTOR(int, __wait4, int pid, int *status, int options, void *rusage) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, __wait4, pid, status, options, rusage);\n  // FIXME: under ASan the call below may write to freed memory and corrupt\n  // its metadata. See\n  // https://github.com/google/sanitizers/issues/321.\n  int res = REAL(__wait4)(pid, status, options, rusage);\n  if (res != -1) {\n    if (status) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, status, sizeof(*status));\n    if (rusage) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, rusage, struct_rusage_sz);\n  }\n  return res;\n}\n#define INIT_WAIT4 COMMON_INTERCEPT_FUNCTION(__wait4);\n#else\nINTERCEPTOR(int, wait4, int pid, int *status, int options, void *rusage) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, wait4, pid, status, options, rusage);\n  // FIXME: under ASan the call below may write to freed memory and corrupt\n  // its metadata. See\n  // https://github.com/google/sanitizers/issues/321.\n  int res = REAL(wait4)(pid, status, options, rusage);\n  if (res != -1) {\n    if (status) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, status, sizeof(*status));\n    if (rusage) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, rusage, struct_rusage_sz);\n  }\n  return res;\n}\n#define INIT_WAIT4 COMMON_INTERCEPT_FUNCTION(wait4);\n#endif  // SANITIZER_ANDROID\n#define INIT_WAIT                     \\\n  COMMON_INTERCEPT_FUNCTION(wait);    \\\n  COMMON_INTERCEPT_FUNCTION(waitid);  \\\n  COMMON_INTERCEPT_FUNCTION(waitpid); \\\n  COMMON_INTERCEPT_FUNCTION(wait3);\n#else\n#define INIT_WAIT\n#define INIT_WAIT4\n#endif\n\n#if SANITIZER_INTERCEPT_INET\nINTERCEPTOR(char *, inet_ntop, int af, const void *src, char *dst, u32 size) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, inet_ntop, af, src, dst, size);\n  uptr sz = __sanitizer_in_addr_sz(af);\n  if (sz) COMMON_INTERCEPTOR_READ_RANGE(ctx, src, sz);\n  // FIXME: figure out read size based on the address family.\n  // FIXME: under ASan the call below may write to freed memory and corrupt\n  // its metadata. See\n  // https://github.com/google/sanitizers/issues/321.\n  char *res = REAL(inet_ntop)(af, src, dst, size);\n  if (res) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, res, REAL(strlen)(res) + 1);\n  return res;\n}\nINTERCEPTOR(int, inet_pton, int af, const char *src, void *dst) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, inet_pton, af, src, dst);\n  COMMON_INTERCEPTOR_READ_STRING(ctx, src, 0);\n  // FIXME: figure out read size based on the address family.\n  // FIXME: under ASan the call below may write to freed memory and corrupt\n  // its metadata. See\n  // https://github.com/google/sanitizers/issues/321.\n  int res = REAL(inet_pton)(af, src, dst);\n  if (res == 1) {\n    uptr sz = __sanitizer_in_addr_sz(af);\n    if (sz) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, dst, sz);\n  }\n  return res;\n}\n#define INIT_INET                       \\\n  COMMON_INTERCEPT_FUNCTION(inet_ntop); \\\n  COMMON_INTERCEPT_FUNCTION(inet_pton);\n#else\n#define INIT_INET\n#endif\n\n#if SANITIZER_INTERCEPT_INET\nINTERCEPTOR(int, inet_aton, const char *cp, void *dst) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, inet_aton, cp, dst);\n  if (cp) COMMON_INTERCEPTOR_READ_RANGE(ctx, cp, REAL(strlen)(cp) + 1);\n  // FIXME: under ASan the call below may write to freed memory and corrupt\n  // its metadata. See\n  // https://github.com/google/sanitizers/issues/321.\n  int res = REAL(inet_aton)(cp, dst);\n  if (res != 0) {\n    uptr sz = __sanitizer_in_addr_sz(af_inet);\n    if (sz) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, dst, sz);\n  }\n  return res;\n}\n#define INIT_INET_ATON COMMON_INTERCEPT_FUNCTION(inet_aton);\n#else\n#define INIT_INET_ATON\n#endif\n\n#if SANITIZER_INTERCEPT_PTHREAD_GETSCHEDPARAM\nINTERCEPTOR(int, pthread_getschedparam, uptr thread, int *policy, int *param) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, pthread_getschedparam, thread, policy, param);\n  // FIXME: under ASan the call below may write to freed memory and corrupt\n  // its metadata. See\n  // https://github.com/google/sanitizers/issues/321.\n  int res = REAL(pthread_getschedparam)(thread, policy, param);\n  if (res == 0) {\n    if (policy) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, policy, sizeof(*policy));\n    if (param) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, param, sizeof(*param));\n  }\n  return res;\n}\n#define INIT_PTHREAD_GETSCHEDPARAM \\\n  COMMON_INTERCEPT_FUNCTION(pthread_getschedparam);\n#else\n#define INIT_PTHREAD_GETSCHEDPARAM\n#endif\n\n#if SANITIZER_INTERCEPT_GETADDRINFO\nINTERCEPTOR(int, getaddrinfo, char *node, char *service,\n            struct __sanitizer_addrinfo *hints,\n            struct __sanitizer_addrinfo **out) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, getaddrinfo, node, service, hints, out);\n  if (node) COMMON_INTERCEPTOR_READ_RANGE(ctx, node, REAL(strlen)(node) + 1);\n  if (service)\n    COMMON_INTERCEPTOR_READ_RANGE(ctx, service, REAL(strlen)(service) + 1);\n  if (hints)\n    COMMON_INTERCEPTOR_READ_RANGE(ctx, hints, sizeof(__sanitizer_addrinfo));\n  // FIXME: under ASan the call below may write to freed memory and corrupt\n  // its metadata. See\n  // https://github.com/google/sanitizers/issues/321.\n  int res = REAL(getaddrinfo)(node, service, hints, out);\n  if (res == 0 && out) {\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, out, sizeof(*out));\n    struct __sanitizer_addrinfo *p = *out;\n    while (p) {\n      COMMON_INTERCEPTOR_WRITE_RANGE(ctx, p, sizeof(*p));\n      if (p->ai_addr)\n        COMMON_INTERCEPTOR_WRITE_RANGE(ctx, p->ai_addr, p->ai_addrlen);\n      if (p->ai_canonname)\n        COMMON_INTERCEPTOR_WRITE_RANGE(ctx, p->ai_canonname,\n                                       REAL(strlen)(p->ai_canonname) + 1);\n      p = p->ai_next;\n    }\n  }\n  return res;\n}\n#define INIT_GETADDRINFO COMMON_INTERCEPT_FUNCTION(getaddrinfo);\n#else\n#define INIT_GETADDRINFO\n#endif\n\n#if SANITIZER_INTERCEPT_GETNAMEINFO\nINTERCEPTOR(int, getnameinfo, void *sockaddr, unsigned salen, char *host,\n            unsigned hostlen, char *serv, unsigned servlen, int flags) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, getnameinfo, sockaddr, salen, host, hostlen,\n                           serv, servlen, flags);\n  // FIXME: consider adding READ_RANGE(sockaddr, salen)\n  // There is padding in in_addr that may make this too noisy\n  // FIXME: under ASan the call below may write to freed memory and corrupt\n  // its metadata. See\n  // https://github.com/google/sanitizers/issues/321.\n  int res =\n      REAL(getnameinfo)(sockaddr, salen, host, hostlen, serv, servlen, flags);\n  if (res == 0) {\n    if (host && hostlen)\n      COMMON_INTERCEPTOR_WRITE_RANGE(ctx, host, REAL(strlen)(host) + 1);\n    if (serv && servlen)\n      COMMON_INTERCEPTOR_WRITE_RANGE(ctx, serv, REAL(strlen)(serv) + 1);\n  }\n  return res;\n}\n#define INIT_GETNAMEINFO COMMON_INTERCEPT_FUNCTION(getnameinfo);\n#else\n#define INIT_GETNAMEINFO\n#endif\n\n#if SANITIZER_INTERCEPT_GETSOCKNAME\nINTERCEPTOR(int, getsockname, int sock_fd, void *addr, int *addrlen) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, getsockname, sock_fd, addr, addrlen);\n  COMMON_INTERCEPTOR_READ_RANGE(ctx, addrlen, sizeof(*addrlen));\n  int addrlen_in = *addrlen;\n  // FIXME: under ASan the call below may write to freed memory and corrupt\n  // its metadata. See\n  // https://github.com/google/sanitizers/issues/321.\n  int res = REAL(getsockname)(sock_fd, addr, addrlen);\n  if (res == 0) {\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, addr, Min(addrlen_in, *addrlen));\n  }\n  return res;\n}\n#define INIT_GETSOCKNAME COMMON_INTERCEPT_FUNCTION(getsockname);\n#else\n#define INIT_GETSOCKNAME\n#endif\n\n#if SANITIZER_INTERCEPT_GETHOSTBYNAME || SANITIZER_INTERCEPT_GETHOSTBYNAME_R\nstatic void write_hostent(void *ctx, struct __sanitizer_hostent *h) {\n  COMMON_INTERCEPTOR_WRITE_RANGE(ctx, h, sizeof(__sanitizer_hostent));\n  if (h->h_name)\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, h->h_name, REAL(strlen)(h->h_name) + 1);\n  char **p = h->h_aliases;\n  while (*p) {\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, *p, REAL(strlen)(*p) + 1);\n    ++p;\n  }\n  COMMON_INTERCEPTOR_WRITE_RANGE(\n      ctx, h->h_aliases, (p - h->h_aliases + 1) * sizeof(*h->h_aliases));\n  p = h->h_addr_list;\n  while (*p) {\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, *p, h->h_length);\n    ++p;\n  }\n  COMMON_INTERCEPTOR_WRITE_RANGE(\n      ctx, h->h_addr_list, (p - h->h_addr_list + 1) * sizeof(*h->h_addr_list));\n}\n#endif\n\n#if SANITIZER_INTERCEPT_GETHOSTBYNAME\nINTERCEPTOR(struct __sanitizer_hostent *, gethostbyname, char *name) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, gethostbyname, name);\n  struct __sanitizer_hostent *res = REAL(gethostbyname)(name);\n  if (res) write_hostent(ctx, res);\n  return res;\n}\n\nINTERCEPTOR(struct __sanitizer_hostent *, gethostbyaddr, void *addr, int len,\n            int type) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, gethostbyaddr, addr, len, type);\n  COMMON_INTERCEPTOR_READ_RANGE(ctx, addr, len);\n  struct __sanitizer_hostent *res = REAL(gethostbyaddr)(addr, len, type);\n  if (res) write_hostent(ctx, res);\n  return res;\n}\n\nINTERCEPTOR(struct __sanitizer_hostent *, gethostent, int fake) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, gethostent, fake);\n  struct __sanitizer_hostent *res = REAL(gethostent)(fake);\n  if (res) write_hostent(ctx, res);\n  return res;\n}\n#define INIT_GETHOSTBYNAME                  \\\n  COMMON_INTERCEPT_FUNCTION(gethostent);    \\\n  COMMON_INTERCEPT_FUNCTION(gethostbyaddr); \\\n  COMMON_INTERCEPT_FUNCTION(gethostbyname);\n#else\n#define INIT_GETHOSTBYNAME\n#endif  // SANITIZER_INTERCEPT_GETHOSTBYNAME\n\n#if SANITIZER_INTERCEPT_GETHOSTBYNAME2\nINTERCEPTOR(struct __sanitizer_hostent *, gethostbyname2, char *name, int af) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, gethostbyname2, name, af);\n  struct __sanitizer_hostent *res = REAL(gethostbyname2)(name, af);\n  if (res) write_hostent(ctx, res);\n  return res;\n}\n#define INIT_GETHOSTBYNAME2 COMMON_INTERCEPT_FUNCTION(gethostbyname2);\n#else\n#define INIT_GETHOSTBYNAME2\n#endif  // SANITIZER_INTERCEPT_GETHOSTBYNAME2\n\n#if SANITIZER_INTERCEPT_GETHOSTBYNAME_R\nINTERCEPTOR(int, gethostbyname_r, char *name, struct __sanitizer_hostent *ret,\n            char *buf, SIZE_T buflen, __sanitizer_hostent **result,\n            int *h_errnop) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, gethostbyname_r, name, ret, buf, buflen, result,\n                           h_errnop);\n  // FIXME: under ASan the call below may write to freed memory and corrupt\n  // its metadata. See\n  // https://github.com/google/sanitizers/issues/321.\n  int res = REAL(gethostbyname_r)(name, ret, buf, buflen, result, h_errnop);\n  if (result) {\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, result, sizeof(*result));\n    if (res == 0 && *result) write_hostent(ctx, *result);\n  }\n  if (h_errnop)\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, h_errnop, sizeof(*h_errnop));\n  return res;\n}\n#define INIT_GETHOSTBYNAME_R COMMON_INTERCEPT_FUNCTION(gethostbyname_r);\n#else\n#define INIT_GETHOSTBYNAME_R\n#endif\n\n#if SANITIZER_INTERCEPT_GETHOSTENT_R\nINTERCEPTOR(int, gethostent_r, struct __sanitizer_hostent *ret, char *buf,\n            SIZE_T buflen, __sanitizer_hostent **result, int *h_errnop) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, gethostent_r, ret, buf, buflen, result,\n                           h_errnop);\n  // FIXME: under ASan the call below may write to freed memory and corrupt\n  // its metadata. See\n  // https://github.com/google/sanitizers/issues/321.\n  int res = REAL(gethostent_r)(ret, buf, buflen, result, h_errnop);\n  if (result) {\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, result, sizeof(*result));\n    if (res == 0 && *result) write_hostent(ctx, *result);\n  }\n  if (h_errnop)\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, h_errnop, sizeof(*h_errnop));\n  return res;\n}\n#define INIT_GETHOSTENT_R                  \\\n  COMMON_INTERCEPT_FUNCTION(gethostent_r);\n#else\n#define INIT_GETHOSTENT_R\n#endif\n\n#if SANITIZER_INTERCEPT_GETHOSTBYADDR_R\nINTERCEPTOR(int, gethostbyaddr_r, void *addr, int len, int type,\n            struct __sanitizer_hostent *ret, char *buf, SIZE_T buflen,\n            __sanitizer_hostent **result, int *h_errnop) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, gethostbyaddr_r, addr, len, type, ret, buf,\n                           buflen, result, h_errnop);\n  COMMON_INTERCEPTOR_READ_RANGE(ctx, addr, len);\n  // FIXME: under ASan the call below may write to freed memory and corrupt\n  // its metadata. See\n  // https://github.com/google/sanitizers/issues/321.\n  int res = REAL(gethostbyaddr_r)(addr, len, type, ret, buf, buflen, result,\n                                  h_errnop);\n  if (result) {\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, result, sizeof(*result));\n    if (res == 0 && *result) write_hostent(ctx, *result);\n  }\n  if (h_errnop)\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, h_errnop, sizeof(*h_errnop));\n  return res;\n}\n#define INIT_GETHOSTBYADDR_R                  \\\n  COMMON_INTERCEPT_FUNCTION(gethostbyaddr_r);\n#else\n#define INIT_GETHOSTBYADDR_R\n#endif\n\n#if SANITIZER_INTERCEPT_GETHOSTBYNAME2_R\nINTERCEPTOR(int, gethostbyname2_r, char *name, int af,\n            struct __sanitizer_hostent *ret, char *buf, SIZE_T buflen,\n            __sanitizer_hostent **result, int *h_errnop) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, gethostbyname2_r, name, af, ret, buf, buflen,\n                           result, h_errnop);\n  // FIXME: under ASan the call below may write to freed memory and corrupt\n  // its metadata. See\n  // https://github.com/google/sanitizers/issues/321.\n  int res =\n      REAL(gethostbyname2_r)(name, af, ret, buf, buflen, result, h_errnop);\n  if (result) {\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, result, sizeof(*result));\n    if (res == 0 && *result) write_hostent(ctx, *result);\n  }\n  if (h_errnop)\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, h_errnop, sizeof(*h_errnop));\n  return res;\n}\n#define INIT_GETHOSTBYNAME2_R                  \\\n  COMMON_INTERCEPT_FUNCTION(gethostbyname2_r);\n#else\n#define INIT_GETHOSTBYNAME2_R\n#endif\n\n#if SANITIZER_INTERCEPT_GETSOCKOPT\nINTERCEPTOR(int, getsockopt, int sockfd, int level, int optname, void *optval,\n            int *optlen) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, getsockopt, sockfd, level, optname, optval,\n                           optlen);\n  if (optlen) COMMON_INTERCEPTOR_READ_RANGE(ctx, optlen, sizeof(*optlen));\n  // FIXME: under ASan the call below may write to freed memory and corrupt\n  // its metadata. See\n  // https://github.com/google/sanitizers/issues/321.\n  int res = REAL(getsockopt)(sockfd, level, optname, optval, optlen);\n  if (res == 0)\n    if (optval && optlen) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, optval, *optlen);\n  return res;\n}\n#define INIT_GETSOCKOPT COMMON_INTERCEPT_FUNCTION(getsockopt);\n#else\n#define INIT_GETSOCKOPT\n#endif\n\n#if SANITIZER_INTERCEPT_ACCEPT\nINTERCEPTOR(int, accept, int fd, void *addr, unsigned *addrlen) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, accept, fd, addr, addrlen);\n  unsigned addrlen0 = 0;\n  if (addrlen) {\n    COMMON_INTERCEPTOR_READ_RANGE(ctx, addrlen, sizeof(*addrlen));\n    addrlen0 = *addrlen;\n  }\n  int fd2 = REAL(accept)(fd, addr, addrlen);\n  if (fd2 >= 0) {\n    if (fd >= 0) COMMON_INTERCEPTOR_FD_SOCKET_ACCEPT(ctx, fd, fd2);\n    if (addr && addrlen)\n      COMMON_INTERCEPTOR_WRITE_RANGE(ctx, addr, Min(*addrlen, addrlen0));\n  }\n  return fd2;\n}\n#define INIT_ACCEPT COMMON_INTERCEPT_FUNCTION(accept);\n#else\n#define INIT_ACCEPT\n#endif\n\n#if SANITIZER_INTERCEPT_ACCEPT4\nINTERCEPTOR(int, accept4, int fd, void *addr, unsigned *addrlen, int f) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, accept4, fd, addr, addrlen, f);\n  unsigned addrlen0 = 0;\n  if (addrlen) {\n    COMMON_INTERCEPTOR_READ_RANGE(ctx, addrlen, sizeof(*addrlen));\n    addrlen0 = *addrlen;\n  }\n  // FIXME: under ASan the call below may write to freed memory and corrupt\n  // its metadata. See\n  // https://github.com/google/sanitizers/issues/321.\n  int fd2 = REAL(accept4)(fd, addr, addrlen, f);\n  if (fd2 >= 0) {\n    if (fd >= 0) COMMON_INTERCEPTOR_FD_SOCKET_ACCEPT(ctx, fd, fd2);\n    if (addr && addrlen)\n      COMMON_INTERCEPTOR_WRITE_RANGE(ctx, addr, Min(*addrlen, addrlen0));\n  }\n  return fd2;\n}\n#define INIT_ACCEPT4 COMMON_INTERCEPT_FUNCTION(accept4);\n#else\n#define INIT_ACCEPT4\n#endif\n\n#if SANITIZER_INTERCEPT_PACCEPT\nINTERCEPTOR(int, paccept, int fd, void *addr, unsigned *addrlen,\n            __sanitizer_sigset_t *set, int f) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, paccept, fd, addr, addrlen, set, f);\n  unsigned addrlen0 = 0;\n  if (addrlen) {\n    COMMON_INTERCEPTOR_READ_RANGE(ctx, addrlen, sizeof(*addrlen));\n    addrlen0 = *addrlen;\n  }\n  if (set) COMMON_INTERCEPTOR_READ_RANGE(ctx, set, sizeof(*set));\n  int fd2 = REAL(paccept)(fd, addr, addrlen, set, f);\n  if (fd2 >= 0) {\n    if (fd >= 0) COMMON_INTERCEPTOR_FD_SOCKET_ACCEPT(ctx, fd, fd2);\n    if (addr && addrlen)\n      COMMON_INTERCEPTOR_WRITE_RANGE(ctx, addr, Min(*addrlen, addrlen0));\n  }\n  return fd2;\n}\n#define INIT_PACCEPT COMMON_INTERCEPT_FUNCTION(paccept);\n#else\n#define INIT_PACCEPT\n#endif\n\n#if SANITIZER_INTERCEPT_MODF\nINTERCEPTOR(double, modf, double x, double *iptr) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, modf, x, iptr);\n  // FIXME: under ASan the call below may write to freed memory and corrupt\n  // its metadata. See\n  // https://github.com/google/sanitizers/issues/321.\n  double res = REAL(modf)(x, iptr);\n  if (iptr) {\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, iptr, sizeof(*iptr));\n  }\n  return res;\n}\nINTERCEPTOR(float, modff, float x, float *iptr) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, modff, x, iptr);\n  // FIXME: under ASan the call below may write to freed memory and corrupt\n  // its metadata. See\n  // https://github.com/google/sanitizers/issues/321.\n  float res = REAL(modff)(x, iptr);\n  if (iptr) {\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, iptr, sizeof(*iptr));\n  }\n  return res;\n}\nINTERCEPTOR(long double, modfl, long double x, long double *iptr) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, modfl, x, iptr);\n  // FIXME: under ASan the call below may write to freed memory and corrupt\n  // its metadata. See\n  // https://github.com/google/sanitizers/issues/321.\n  long double res = REAL(modfl)(x, iptr);\n  if (iptr) {\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, iptr, sizeof(*iptr));\n  }\n  return res;\n}\n#define INIT_MODF                   \\\n  COMMON_INTERCEPT_FUNCTION(modf);  \\\n  COMMON_INTERCEPT_FUNCTION(modff); \\\n  COMMON_INTERCEPT_FUNCTION_LDBL(modfl);\n#else\n#define INIT_MODF\n#endif\n\n#if SANITIZER_INTERCEPT_RECVMSG || SANITIZER_INTERCEPT_RECVMMSG\nstatic void write_msghdr(void *ctx, struct __sanitizer_msghdr *msg,\n                         SSIZE_T maxlen) {\n  COMMON_INTERCEPTOR_WRITE_RANGE(ctx, msg, sizeof(*msg));\n  if (msg->msg_name && msg->msg_namelen)\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, msg->msg_name, msg->msg_namelen);\n  if (msg->msg_iov && msg->msg_iovlen)\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, msg->msg_iov,\n                                   sizeof(*msg->msg_iov) * msg->msg_iovlen);\n  write_iovec(ctx, msg->msg_iov, msg->msg_iovlen, maxlen);\n  if (msg->msg_control && msg->msg_controllen)\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, msg->msg_control, msg->msg_controllen);\n}\n#endif\n\n#if SANITIZER_INTERCEPT_RECVMSG\nINTERCEPTOR(SSIZE_T, recvmsg, int fd, struct __sanitizer_msghdr *msg,\n            int flags) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, recvmsg, fd, msg, flags);\n  // FIXME: under ASan the call below may write to freed memory and corrupt\n  // its metadata. See\n  // https://github.com/google/sanitizers/issues/321.\n  SSIZE_T res = REAL(recvmsg)(fd, msg, flags);\n  if (res >= 0) {\n    if (fd >= 0) COMMON_INTERCEPTOR_FD_ACQUIRE(ctx, fd);\n    if (msg) {\n      write_msghdr(ctx, msg, res);\n      COMMON_INTERCEPTOR_HANDLE_RECVMSG(ctx, msg);\n    }\n  }\n  return res;\n}\n#define INIT_RECVMSG COMMON_INTERCEPT_FUNCTION(recvmsg);\n#else\n#define INIT_RECVMSG\n#endif\n\n#if SANITIZER_INTERCEPT_RECVMMSG\nINTERCEPTOR(int, recvmmsg, int fd, struct __sanitizer_mmsghdr *msgvec,\n            unsigned int vlen, int flags, void *timeout) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, recvmmsg, fd, msgvec, vlen, flags, timeout);\n  if (timeout) COMMON_INTERCEPTOR_READ_RANGE(ctx, timeout, struct_timespec_sz);\n  int res = REAL(recvmmsg)(fd, msgvec, vlen, flags, timeout);\n  if (res >= 0) {\n    if (fd >= 0) COMMON_INTERCEPTOR_FD_ACQUIRE(ctx, fd);\n    for (int i = 0; i < res; ++i) {\n      COMMON_INTERCEPTOR_WRITE_RANGE(ctx, &msgvec[i].msg_len,\n                                     sizeof(msgvec[i].msg_len));\n      write_msghdr(ctx, &msgvec[i].msg_hdr, msgvec[i].msg_len);\n      COMMON_INTERCEPTOR_HANDLE_RECVMSG(ctx, &msgvec[i].msg_hdr);\n    }\n  }\n  return res;\n}\n#define INIT_RECVMMSG COMMON_INTERCEPT_FUNCTION(recvmmsg);\n#else\n#define INIT_RECVMMSG\n#endif\n\n#if SANITIZER_INTERCEPT_SENDMSG || SANITIZER_INTERCEPT_SENDMMSG\nstatic void read_msghdr_control(void *ctx, void *control, uptr controllen) {\n  const unsigned kCmsgDataOffset =\n      RoundUpTo(sizeof(__sanitizer_cmsghdr), sizeof(uptr));\n\n  char *p = (char *)control;\n  char *const control_end = p + controllen;\n  while (true) {\n    if (p + sizeof(__sanitizer_cmsghdr) > control_end) break;\n    __sanitizer_cmsghdr *cmsg = (__sanitizer_cmsghdr *)p;\n    COMMON_INTERCEPTOR_READ_RANGE(ctx, &cmsg->cmsg_len, sizeof(cmsg->cmsg_len));\n\n    if (p + RoundUpTo(cmsg->cmsg_len, sizeof(uptr)) > control_end) break;\n\n    COMMON_INTERCEPTOR_READ_RANGE(ctx, &cmsg->cmsg_level,\n                                  sizeof(cmsg->cmsg_level));\n    COMMON_INTERCEPTOR_READ_RANGE(ctx, &cmsg->cmsg_type,\n                                  sizeof(cmsg->cmsg_type));\n\n    if (cmsg->cmsg_len > kCmsgDataOffset) {\n      char *data = p + kCmsgDataOffset;\n      unsigned data_len = cmsg->cmsg_len - kCmsgDataOffset;\n      if (data_len > 0) COMMON_INTERCEPTOR_READ_RANGE(ctx, data, data_len);\n    }\n\n    p += RoundUpTo(cmsg->cmsg_len, sizeof(uptr));\n  }\n}\n\nstatic void read_msghdr(void *ctx, struct __sanitizer_msghdr *msg,\n                        SSIZE_T maxlen) {\n#define R(f) \\\n  COMMON_INTERCEPTOR_READ_RANGE(ctx, &msg->msg_##f, sizeof(msg->msg_##f))\n  R(name);\n  R(namelen);\n  R(iov);\n  R(iovlen);\n  R(control);\n  R(controllen);\n  R(flags);\n#undef R\n  if (msg->msg_name && msg->msg_namelen)\n    COMMON_INTERCEPTOR_READ_RANGE(ctx, msg->msg_name, msg->msg_namelen);\n  if (msg->msg_iov && msg->msg_iovlen)\n    COMMON_INTERCEPTOR_READ_RANGE(ctx, msg->msg_iov,\n                                  sizeof(*msg->msg_iov) * msg->msg_iovlen);\n  read_iovec(ctx, msg->msg_iov, msg->msg_iovlen, maxlen);\n  if (msg->msg_control && msg->msg_controllen)\n    read_msghdr_control(ctx, msg->msg_control, msg->msg_controllen);\n}\n#endif\n\n#if SANITIZER_INTERCEPT_SENDMSG\nINTERCEPTOR(SSIZE_T, sendmsg, int fd, struct __sanitizer_msghdr *msg,\n            int flags) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, sendmsg, fd, msg, flags);\n  if (fd >= 0) {\n    COMMON_INTERCEPTOR_FD_ACCESS(ctx, fd);\n    COMMON_INTERCEPTOR_FD_RELEASE(ctx, fd);\n  }\n  SSIZE_T res = REAL(sendmsg)(fd, msg, flags);\n  if (common_flags()->intercept_send && res >= 0 && msg)\n    read_msghdr(ctx, msg, res);\n  return res;\n}\n#define INIT_SENDMSG COMMON_INTERCEPT_FUNCTION(sendmsg);\n#else\n#define INIT_SENDMSG\n#endif\n\n#if SANITIZER_INTERCEPT_SENDMMSG\nINTERCEPTOR(int, sendmmsg, int fd, struct __sanitizer_mmsghdr *msgvec,\n            unsigned vlen, int flags) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, sendmmsg, fd, msgvec, vlen, flags);\n  if (fd >= 0) {\n    COMMON_INTERCEPTOR_FD_ACCESS(ctx, fd);\n    COMMON_INTERCEPTOR_FD_RELEASE(ctx, fd);\n  }\n  int res = REAL(sendmmsg)(fd, msgvec, vlen, flags);\n  if (res >= 0 && msgvec) {\n    for (int i = 0; i < res; ++i) {\n      COMMON_INTERCEPTOR_WRITE_RANGE(ctx, &msgvec[i].msg_len,\n                                     sizeof(msgvec[i].msg_len));\n      if (common_flags()->intercept_send)\n        read_msghdr(ctx, &msgvec[i].msg_hdr, msgvec[i].msg_len);\n    }\n  }\n  return res;\n}\n#define INIT_SENDMMSG COMMON_INTERCEPT_FUNCTION(sendmmsg);\n#else\n#define INIT_SENDMMSG\n#endif\n\n#if SANITIZER_INTERCEPT_SYSMSG\nINTERCEPTOR(int, msgsnd, int msqid, const void *msgp, SIZE_T msgsz,\n            int msgflg) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, msgsnd, msqid, msgp, msgsz, msgflg);\n  if (msgp)\n    COMMON_INTERCEPTOR_READ_RANGE(ctx, msgp, sizeof(long) + msgsz);\n  int res = REAL(msgsnd)(msqid, msgp, msgsz, msgflg);\n  return res;\n}\n\nINTERCEPTOR(SSIZE_T, msgrcv, int msqid, void *msgp, SIZE_T msgsz,\n            long msgtyp, int msgflg) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, msgrcv, msqid, msgp, msgsz, msgtyp, msgflg);\n  SSIZE_T len = REAL(msgrcv)(msqid, msgp, msgsz, msgtyp, msgflg);\n  if (len != -1)\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, msgp, sizeof(long) + len);\n  return len;\n}\n\n#define INIT_SYSMSG                  \\\n  COMMON_INTERCEPT_FUNCTION(msgsnd); \\\n  COMMON_INTERCEPT_FUNCTION(msgrcv);\n#else\n#define INIT_SYSMSG\n#endif\n\n#if SANITIZER_INTERCEPT_GETPEERNAME\nINTERCEPTOR(int, getpeername, int sockfd, void *addr, unsigned *addrlen) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, getpeername, sockfd, addr, addrlen);\n  unsigned addr_sz;\n  if (addrlen) addr_sz = *addrlen;\n  // FIXME: under ASan the call below may write to freed memory and corrupt\n  // its metadata. See\n  // https://github.com/google/sanitizers/issues/321.\n  int res = REAL(getpeername)(sockfd, addr, addrlen);\n  if (!res && addr && addrlen)\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, addr, Min(addr_sz, *addrlen));\n  return res;\n}\n#define INIT_GETPEERNAME COMMON_INTERCEPT_FUNCTION(getpeername);\n#else\n#define INIT_GETPEERNAME\n#endif\n\n#if SANITIZER_INTERCEPT_SYSINFO\nINTERCEPTOR(int, sysinfo, void *info) {\n  void *ctx;\n  // FIXME: under ASan the call below may write to freed memory and corrupt\n  // its metadata. See\n  // https://github.com/google/sanitizers/issues/321.\n  COMMON_INTERCEPTOR_ENTER(ctx, sysinfo, info);\n  int res = REAL(sysinfo)(info);\n  if (!res && info)\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, info, struct_sysinfo_sz);\n  return res;\n}\n#define INIT_SYSINFO COMMON_INTERCEPT_FUNCTION(sysinfo);\n#else\n#define INIT_SYSINFO\n#endif\n\n#if SANITIZER_INTERCEPT_READDIR\nINTERCEPTOR(__sanitizer_dirent *, opendir, const char *path) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, opendir, path);\n  COMMON_INTERCEPTOR_READ_RANGE(ctx, path, REAL(strlen)(path) + 1);\n  __sanitizer_dirent *res = REAL(opendir)(path);\n  if (res)\n    COMMON_INTERCEPTOR_DIR_ACQUIRE(ctx, path);\n  return res;\n}\n\nINTERCEPTOR(__sanitizer_dirent *, readdir, void *dirp) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, readdir, dirp);\n  // FIXME: under ASan the call below may write to freed memory and corrupt\n  // its metadata. See\n  // https://github.com/google/sanitizers/issues/321.\n  __sanitizer_dirent *res = REAL(readdir)(dirp);\n  if (res) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, res, res->d_reclen);\n  return res;\n}\n\nINTERCEPTOR(int, readdir_r, void *dirp, __sanitizer_dirent *entry,\n            __sanitizer_dirent **result) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, readdir_r, dirp, entry, result);\n  // FIXME: under ASan the call below may write to freed memory and corrupt\n  // its metadata. See\n  // https://github.com/google/sanitizers/issues/321.\n  int res = REAL(readdir_r)(dirp, entry, result);\n  if (!res) {\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, result, sizeof(*result));\n    if (*result)\n      COMMON_INTERCEPTOR_WRITE_RANGE(ctx, *result, (*result)->d_reclen);\n  }\n  return res;\n}\n\n#define INIT_READDIR                  \\\n  COMMON_INTERCEPT_FUNCTION(opendir); \\\n  COMMON_INTERCEPT_FUNCTION(readdir); \\\n  COMMON_INTERCEPT_FUNCTION(readdir_r);\n#else\n#define INIT_READDIR\n#endif\n\n#if SANITIZER_INTERCEPT_READDIR64\nINTERCEPTOR(__sanitizer_dirent64 *, readdir64, void *dirp) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, readdir64, dirp);\n  // FIXME: under ASan the call below may write to freed memory and corrupt\n  // its metadata. See\n  // https://github.com/google/sanitizers/issues/321.\n  __sanitizer_dirent64 *res = REAL(readdir64)(dirp);\n  if (res) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, res, res->d_reclen);\n  return res;\n}\n\nINTERCEPTOR(int, readdir64_r, void *dirp, __sanitizer_dirent64 *entry,\n            __sanitizer_dirent64 **result) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, readdir64_r, dirp, entry, result);\n  // FIXME: under ASan the call below may write to freed memory and corrupt\n  // its metadata. See\n  // https://github.com/google/sanitizers/issues/321.\n  int res = REAL(readdir64_r)(dirp, entry, result);\n  if (!res) {\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, result, sizeof(*result));\n    if (*result)\n      COMMON_INTERCEPTOR_WRITE_RANGE(ctx, *result, (*result)->d_reclen);\n  }\n  return res;\n}\n#define INIT_READDIR64                  \\\n  COMMON_INTERCEPT_FUNCTION(readdir64); \\\n  COMMON_INTERCEPT_FUNCTION(readdir64_r);\n#else\n#define INIT_READDIR64\n#endif\n\n#if SANITIZER_INTERCEPT_PTRACE\nINTERCEPTOR(uptr, ptrace, int request, int pid, void *addr, void *data) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, ptrace, request, pid, addr, data);\n  __sanitizer_iovec local_iovec;\n\n  if (data) {\n    if (request == ptrace_setregs) {\n      COMMON_INTERCEPTOR_READ_RANGE(ctx, data, struct_user_regs_struct_sz);\n    } else if (request == ptrace_setfpregs) {\n      COMMON_INTERCEPTOR_READ_RANGE(ctx, data, struct_user_fpregs_struct_sz);\n    } else if (request == ptrace_setfpxregs) {\n      COMMON_INTERCEPTOR_READ_RANGE(ctx, data, struct_user_fpxregs_struct_sz);\n    } else if (request == ptrace_setvfpregs) {\n      COMMON_INTERCEPTOR_READ_RANGE(ctx, data, struct_user_vfpregs_struct_sz);\n    } else if (request == ptrace_setsiginfo) {\n      COMMON_INTERCEPTOR_READ_RANGE(ctx, data, siginfo_t_sz);\n\n    // Some kernel might zero the iovec::iov_base in case of invalid\n    // write access.  In this case copy the invalid address for further\n    // inspection.\n    } else if (request == ptrace_setregset || request == ptrace_getregset) {\n      __sanitizer_iovec *iovec = (__sanitizer_iovec*)data;\n      COMMON_INTERCEPTOR_READ_RANGE(ctx, iovec, sizeof(*iovec));\n      local_iovec = *iovec;\n      if (request == ptrace_setregset)\n        COMMON_INTERCEPTOR_READ_RANGE(ctx, iovec->iov_base, iovec->iov_len);\n    }\n  }\n\n  // FIXME: under ASan the call below may write to freed memory and corrupt\n  // its metadata. See\n  // https://github.com/google/sanitizers/issues/321.\n  uptr res = REAL(ptrace)(request, pid, addr, data);\n\n  if (!res && data) {\n    // Note that PEEK* requests assign different meaning to the return value.\n    // This function does not handle them (nor does it need to).\n    if (request == ptrace_getregs) {\n      COMMON_INTERCEPTOR_WRITE_RANGE(ctx, data, struct_user_regs_struct_sz);\n    } else if (request == ptrace_getfpregs) {\n      COMMON_INTERCEPTOR_WRITE_RANGE(ctx, data, struct_user_fpregs_struct_sz);\n    } else if (request == ptrace_getfpxregs) {\n      COMMON_INTERCEPTOR_WRITE_RANGE(ctx, data, struct_user_fpxregs_struct_sz);\n    } else if (request == ptrace_getvfpregs) {\n      COMMON_INTERCEPTOR_WRITE_RANGE(ctx, data, struct_user_vfpregs_struct_sz);\n    } else if (request == ptrace_getsiginfo) {\n      COMMON_INTERCEPTOR_WRITE_RANGE(ctx, data, siginfo_t_sz);\n    } else if (request == ptrace_geteventmsg) {\n      COMMON_INTERCEPTOR_WRITE_RANGE(ctx, data, sizeof(unsigned long));\n    } else if (request == ptrace_getregset) {\n      __sanitizer_iovec *iovec = (__sanitizer_iovec*)data;\n      COMMON_INTERCEPTOR_WRITE_RANGE(ctx, iovec, sizeof(*iovec));\n      COMMON_INTERCEPTOR_WRITE_RANGE(ctx, local_iovec.iov_base,\n                                     local_iovec.iov_len);\n    }\n  }\n  return res;\n}\n\n#define INIT_PTRACE COMMON_INTERCEPT_FUNCTION(ptrace);\n#else\n#define INIT_PTRACE\n#endif\n\n#if SANITIZER_INTERCEPT_SETLOCALE\nstatic void unpoison_ctype_arrays(void *ctx) {\n#if SANITIZER_NETBSD\n  // These arrays contain 256 regular elements in unsigned char range + 1 EOF\n  COMMON_INTERCEPTOR_WRITE_RANGE(ctx, _ctype_tab_, 257 * sizeof(short));\n  COMMON_INTERCEPTOR_WRITE_RANGE(ctx, _toupper_tab_, 257 * sizeof(short));\n  COMMON_INTERCEPTOR_WRITE_RANGE(ctx, _tolower_tab_, 257 * sizeof(short));\n#endif\n}\n\nINTERCEPTOR(char *, setlocale, int category, char *locale) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, setlocale, category, locale);\n  if (locale)\n    COMMON_INTERCEPTOR_READ_RANGE(ctx, locale, REAL(strlen)(locale) + 1);\n  char *res = REAL(setlocale)(category, locale);\n  if (res) {\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, res, REAL(strlen)(res) + 1);\n    unpoison_ctype_arrays(ctx);\n  }\n  return res;\n}\n\n#define INIT_SETLOCALE COMMON_INTERCEPT_FUNCTION(setlocale);\n#else\n#define INIT_SETLOCALE\n#endif\n\n#if SANITIZER_INTERCEPT_GETCWD\nINTERCEPTOR(char *, getcwd, char *buf, SIZE_T size) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, getcwd, buf, size);\n  // FIXME: under ASan the call below may write to freed memory and corrupt\n  // its metadata. See\n  // https://github.com/google/sanitizers/issues/321.\n  char *res = REAL(getcwd)(buf, size);\n  if (res) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, res, REAL(strlen)(res) + 1);\n  return res;\n}\n#define INIT_GETCWD COMMON_INTERCEPT_FUNCTION(getcwd);\n#else\n#define INIT_GETCWD\n#endif\n\n#if SANITIZER_INTERCEPT_GET_CURRENT_DIR_NAME\nINTERCEPTOR(char *, get_current_dir_name, int fake) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, get_current_dir_name, fake);\n  // FIXME: under ASan the call below may write to freed memory and corrupt\n  // its metadata. See\n  // https://github.com/google/sanitizers/issues/321.\n  char *res = REAL(get_current_dir_name)(fake);\n  if (res) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, res, REAL(strlen)(res) + 1);\n  return res;\n}\n\n#define INIT_GET_CURRENT_DIR_NAME \\\n  COMMON_INTERCEPT_FUNCTION(get_current_dir_name);\n#else\n#define INIT_GET_CURRENT_DIR_NAME\n#endif\n\nUNUSED static inline void FixRealStrtolEndptr(const char *nptr, char **endptr) {\n  CHECK(endptr);\n  if (nptr == *endptr) {\n    // No digits were found at strtol call, we need to find out the last\n    // symbol accessed by strtoll on our own.\n    // We get this symbol by skipping leading blanks and optional +/- sign.\n    while (IsSpace(*nptr)) nptr++;\n    if (*nptr == '+' || *nptr == '-') nptr++;\n    *endptr = const_cast<char *>(nptr);\n  }\n  CHECK(*endptr >= nptr);\n}\n\nUNUSED static inline void StrtolFixAndCheck(void *ctx, const char *nptr,\n                             char **endptr, char *real_endptr, int base) {\n  if (endptr) {\n    *endptr = real_endptr;\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, endptr, sizeof(*endptr));\n  }\n  // If base has unsupported value, strtol can exit with EINVAL\n  // without reading any characters. So do additional checks only\n  // if base is valid.\n  bool is_valid_base = (base == 0) || (2 <= base && base <= 36);\n  if (is_valid_base) {\n    FixRealStrtolEndptr(nptr, &real_endptr);\n  }\n  COMMON_INTERCEPTOR_READ_STRING(ctx, nptr, is_valid_base ?\n                                 (real_endptr - nptr) + 1 : 0);\n}\n\n\n#if SANITIZER_INTERCEPT_STRTOIMAX\nINTERCEPTOR(INTMAX_T, strtoimax, const char *nptr, char **endptr, int base) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, strtoimax, nptr, endptr, base);\n  // FIXME: under ASan the call below may write to freed memory and corrupt\n  // its metadata. See\n  // https://github.com/google/sanitizers/issues/321.\n  char *real_endptr;\n  INTMAX_T res = REAL(strtoimax)(nptr, &real_endptr, base);\n  StrtolFixAndCheck(ctx, nptr, endptr, real_endptr, base);\n  return res;\n}\n\nINTERCEPTOR(UINTMAX_T, strtoumax, const char *nptr, char **endptr, int base) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, strtoumax, nptr, endptr, base);\n  // FIXME: under ASan the call below may write to freed memory and corrupt\n  // its metadata. See\n  // https://github.com/google/sanitizers/issues/321.\n  char *real_endptr;\n  UINTMAX_T res = REAL(strtoumax)(nptr, &real_endptr, base);\n  StrtolFixAndCheck(ctx, nptr, endptr, real_endptr, base);\n  return res;\n}\n\n#define INIT_STRTOIMAX                  \\\n  COMMON_INTERCEPT_FUNCTION(strtoimax); \\\n  COMMON_INTERCEPT_FUNCTION(strtoumax);\n#else\n#define INIT_STRTOIMAX\n#endif\n\n#if SANITIZER_INTERCEPT_MBSTOWCS\nINTERCEPTOR(SIZE_T, mbstowcs, wchar_t *dest, const char *src, SIZE_T len) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, mbstowcs, dest, src, len);\n  // FIXME: under ASan the call below may write to freed memory and corrupt\n  // its metadata. See\n  // https://github.com/google/sanitizers/issues/321.\n  SIZE_T res = REAL(mbstowcs)(dest, src, len);\n  if (res != (SIZE_T) - 1 && dest) {\n    SIZE_T write_cnt = res + (res < len);\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, dest, write_cnt * sizeof(wchar_t));\n  }\n  return res;\n}\n\nINTERCEPTOR(SIZE_T, mbsrtowcs, wchar_t *dest, const char **src, SIZE_T len,\n            void *ps) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, mbsrtowcs, dest, src, len, ps);\n  if (src) COMMON_INTERCEPTOR_READ_RANGE(ctx, src, sizeof(*src));\n  if (ps) COMMON_INTERCEPTOR_READ_RANGE(ctx, ps, mbstate_t_sz);\n  // FIXME: under ASan the call below may write to freed memory and corrupt\n  // its metadata. See\n  // https://github.com/google/sanitizers/issues/321.\n  SIZE_T res = REAL(mbsrtowcs)(dest, src, len, ps);\n  if (res != (SIZE_T)(-1) && dest && src) {\n    // This function, and several others, may or may not write the terminating\n    // \\0 character. They write it iff they clear *src.\n    SIZE_T write_cnt = res + !*src;\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, dest, write_cnt * sizeof(wchar_t));\n  }\n  return res;\n}\n\n#define INIT_MBSTOWCS                  \\\n  COMMON_INTERCEPT_FUNCTION(mbstowcs); \\\n  COMMON_INTERCEPT_FUNCTION(mbsrtowcs);\n#else\n#define INIT_MBSTOWCS\n#endif\n\n#if SANITIZER_INTERCEPT_MBSNRTOWCS\nINTERCEPTOR(SIZE_T, mbsnrtowcs, wchar_t *dest, const char **src, SIZE_T nms,\n            SIZE_T len, void *ps) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, mbsnrtowcs, dest, src, nms, len, ps);\n  if (src) {\n    COMMON_INTERCEPTOR_READ_RANGE(ctx, src, sizeof(*src));\n    if (nms) COMMON_INTERCEPTOR_READ_RANGE(ctx, *src, nms);\n  }\n  if (ps) COMMON_INTERCEPTOR_READ_RANGE(ctx, ps, mbstate_t_sz);\n  // FIXME: under ASan the call below may write to freed memory and corrupt\n  // its metadata. See\n  // https://github.com/google/sanitizers/issues/321.\n  SIZE_T res = REAL(mbsnrtowcs)(dest, src, nms, len, ps);\n  if (res != (SIZE_T)(-1) && dest && src) {\n    SIZE_T write_cnt = res + !*src;\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, dest, write_cnt * sizeof(wchar_t));\n  }\n  return res;\n}\n\n#define INIT_MBSNRTOWCS COMMON_INTERCEPT_FUNCTION(mbsnrtowcs);\n#else\n#define INIT_MBSNRTOWCS\n#endif\n\n#if SANITIZER_INTERCEPT_WCSTOMBS\nINTERCEPTOR(SIZE_T, wcstombs, char *dest, const wchar_t *src, SIZE_T len) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, wcstombs, dest, src, len);\n  // FIXME: under ASan the call below may write to freed memory and corrupt\n  // its metadata. See\n  // https://github.com/google/sanitizers/issues/321.\n  SIZE_T res = REAL(wcstombs)(dest, src, len);\n  if (res != (SIZE_T) - 1 && dest) {\n    SIZE_T write_cnt = res + (res < len);\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, dest, write_cnt);\n  }\n  return res;\n}\n\nINTERCEPTOR(SIZE_T, wcsrtombs, char *dest, const wchar_t **src, SIZE_T len,\n            void *ps) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, wcsrtombs, dest, src, len, ps);\n  if (src) COMMON_INTERCEPTOR_READ_RANGE(ctx, src, sizeof(*src));\n  if (ps) COMMON_INTERCEPTOR_READ_RANGE(ctx, ps, mbstate_t_sz);\n  // FIXME: under ASan the call below may write to freed memory and corrupt\n  // its metadata. See\n  // https://github.com/google/sanitizers/issues/321.\n  SIZE_T res = REAL(wcsrtombs)(dest, src, len, ps);\n  if (res != (SIZE_T) - 1 && dest && src) {\n    SIZE_T write_cnt = res + !*src;\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, dest, write_cnt);\n  }\n  return res;\n}\n\n#define INIT_WCSTOMBS                  \\\n  COMMON_INTERCEPT_FUNCTION(wcstombs); \\\n  COMMON_INTERCEPT_FUNCTION(wcsrtombs);\n#else\n#define INIT_WCSTOMBS\n#endif\n\n#if SANITIZER_INTERCEPT_WCSNRTOMBS\nINTERCEPTOR(SIZE_T, wcsnrtombs, char *dest, const wchar_t **src, SIZE_T nms,\n            SIZE_T len, void *ps) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, wcsnrtombs, dest, src, nms, len, ps);\n  if (src) {\n    COMMON_INTERCEPTOR_READ_RANGE(ctx, src, sizeof(*src));\n    if (nms) COMMON_INTERCEPTOR_READ_RANGE(ctx, *src, nms);\n  }\n  if (ps) COMMON_INTERCEPTOR_READ_RANGE(ctx, ps, mbstate_t_sz);\n  // FIXME: under ASan the call below may write to freed memory and corrupt\n  // its metadata. See\n  // https://github.com/google/sanitizers/issues/321.\n  SIZE_T res = REAL(wcsnrtombs)(dest, src, nms, len, ps);\n  if (res != ((SIZE_T)-1) && dest && src) {\n    SIZE_T write_cnt = res + !*src;\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, dest, write_cnt);\n  }\n  return res;\n}\n\n#define INIT_WCSNRTOMBS COMMON_INTERCEPT_FUNCTION(wcsnrtombs);\n#else\n#define INIT_WCSNRTOMBS\n#endif\n\n\n#if SANITIZER_INTERCEPT_WCRTOMB\nINTERCEPTOR(SIZE_T, wcrtomb, char *dest, wchar_t src, void *ps) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, wcrtomb, dest, src, ps);\n  if (ps) COMMON_INTERCEPTOR_READ_RANGE(ctx, ps, mbstate_t_sz);\n\n  if (!dest)\n    return REAL(wcrtomb)(dest, src, ps);\n\n  char local_dest[32];\n  SIZE_T res = REAL(wcrtomb)(local_dest, src, ps);\n  if (res != ((SIZE_T)-1)) {\n    CHECK_LE(res, sizeof(local_dest));\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, dest, res);\n    REAL(memcpy)(dest, local_dest, res);\n  }\n  return res;\n}\n\n#define INIT_WCRTOMB COMMON_INTERCEPT_FUNCTION(wcrtomb);\n#else\n#define INIT_WCRTOMB\n#endif\n\n#if SANITIZER_INTERCEPT_WCTOMB\nINTERCEPTOR(int, wctomb, char *dest, wchar_t src) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, wctomb, dest, src);\n  if (!dest)\n    return REAL(wctomb)(dest, src);\n\n  char local_dest[32];\n  int res = REAL(wctomb)(local_dest, src);\n  if (res != -1) {\n    CHECK_LE(res, sizeof(local_dest));\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, dest, res);\n    REAL(memcpy)(dest, local_dest, res);\n  }\n  return res;\n}\n\n#define INIT_WCTOMB COMMON_INTERCEPT_FUNCTION(wctomb);\n#else\n#define INIT_WCTOMB\n#endif\n\n#if SANITIZER_INTERCEPT_TCGETATTR\nINTERCEPTOR(int, tcgetattr, int fd, void *termios_p) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, tcgetattr, fd, termios_p);\n  // FIXME: under ASan the call below may write to freed memory and corrupt\n  // its metadata. See\n  // https://github.com/google/sanitizers/issues/321.\n  int res = REAL(tcgetattr)(fd, termios_p);\n  if (!res && termios_p)\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, termios_p, struct_termios_sz);\n  return res;\n}\n\n#define INIT_TCGETATTR COMMON_INTERCEPT_FUNCTION(tcgetattr);\n#else\n#define INIT_TCGETATTR\n#endif\n\n#if SANITIZER_INTERCEPT_REALPATH\nINTERCEPTOR(char *, realpath, const char *path, char *resolved_path) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, realpath, path, resolved_path);\n  if (path) COMMON_INTERCEPTOR_READ_RANGE(ctx, path, REAL(strlen)(path) + 1);\n\n  // Workaround a bug in glibc where dlsym(RTLD_NEXT, ...) returns the oldest\n  // version of a versioned symbol. For realpath(), this gives us something\n  // (called __old_realpath) that does not handle NULL in the second argument.\n  // Handle it as part of the interceptor.\n  char *allocated_path = nullptr;\n  if (!resolved_path)\n    allocated_path = resolved_path = (char *)WRAP(malloc)(path_max + 1);\n\n  char *res = REAL(realpath)(path, resolved_path);\n  if (allocated_path && !res) WRAP(free)(allocated_path);\n  if (res) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, res, REAL(strlen)(res) + 1);\n  return res;\n}\n#define INIT_REALPATH COMMON_INTERCEPT_FUNCTION(realpath);\n#else\n#define INIT_REALPATH\n#endif\n\n#if SANITIZER_INTERCEPT_CANONICALIZE_FILE_NAME\nINTERCEPTOR(char *, canonicalize_file_name, const char *path) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, canonicalize_file_name, path);\n  if (path) COMMON_INTERCEPTOR_READ_RANGE(ctx, path, REAL(strlen)(path) + 1);\n  char *res = REAL(canonicalize_file_name)(path);\n  if (res) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, res, REAL(strlen)(res) + 1);\n  return res;\n}\n#define INIT_CANONICALIZE_FILE_NAME \\\n  COMMON_INTERCEPT_FUNCTION(canonicalize_file_name);\n#else\n#define INIT_CANONICALIZE_FILE_NAME\n#endif\n\n#if SANITIZER_INTERCEPT_CONFSTR\nINTERCEPTOR(SIZE_T, confstr, int name, char *buf, SIZE_T len) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, confstr, name, buf, len);\n  // FIXME: under ASan the call below may write to freed memory and corrupt\n  // its metadata. See\n  // https://github.com/google/sanitizers/issues/321.\n  SIZE_T res = REAL(confstr)(name, buf, len);\n  if (buf && res)\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, buf, res < len ? res : len);\n  return res;\n}\n#define INIT_CONFSTR COMMON_INTERCEPT_FUNCTION(confstr);\n#else\n#define INIT_CONFSTR\n#endif\n\n#if SANITIZER_INTERCEPT_SCHED_GETAFFINITY\nINTERCEPTOR(int, sched_getaffinity, int pid, SIZE_T cpusetsize, void *mask) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, sched_getaffinity, pid, cpusetsize, mask);\n  // FIXME: under ASan the call below may write to freed memory and corrupt\n  // its metadata. See\n  // https://github.com/google/sanitizers/issues/321.\n  int res = REAL(sched_getaffinity)(pid, cpusetsize, mask);\n  if (mask && !res) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, mask, cpusetsize);\n  return res;\n}\n#define INIT_SCHED_GETAFFINITY COMMON_INTERCEPT_FUNCTION(sched_getaffinity);\n#else\n#define INIT_SCHED_GETAFFINITY\n#endif\n\n#if SANITIZER_INTERCEPT_SCHED_GETPARAM\nINTERCEPTOR(int, sched_getparam, int pid, void *param) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, sched_getparam, pid, param);\n  int res = REAL(sched_getparam)(pid, param);\n  if (!res) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, param, struct_sched_param_sz);\n  return res;\n}\n#define INIT_SCHED_GETPARAM COMMON_INTERCEPT_FUNCTION(sched_getparam);\n#else\n#define INIT_SCHED_GETPARAM\n#endif\n\n#if SANITIZER_INTERCEPT_STRERROR\nINTERCEPTOR(char *, strerror, int errnum) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, strerror, errnum);\n  COMMON_INTERCEPTOR_STRERROR();\n  char *res = REAL(strerror)(errnum);\n  if (res) COMMON_INTERCEPTOR_INITIALIZE_RANGE(res, REAL(strlen)(res) + 1);\n  return res;\n}\n#define INIT_STRERROR COMMON_INTERCEPT_FUNCTION(strerror);\n#else\n#define INIT_STRERROR\n#endif\n\n#if SANITIZER_INTERCEPT_STRERROR_R\n// There are 2 versions of strerror_r:\n//  * POSIX version returns 0 on success, negative error code on failure,\n//    writes message to buf.\n//  * GNU version returns message pointer, which points to either buf or some\n//    static storage.\n#if ((_POSIX_C_SOURCE >= 200112L || _XOPEN_SOURCE >= 600) && !_GNU_SOURCE) || \\\n    SANITIZER_MAC || SANITIZER_ANDROID || SANITIZER_NETBSD ||                 \\\n    SANITIZER_FREEBSD\n// POSIX version. Spec is not clear on whether buf is NULL-terminated.\n// At least on OSX, buf contents are valid even when the call fails.\nINTERCEPTOR(int, strerror_r, int errnum, char *buf, SIZE_T buflen) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, strerror_r, errnum, buf, buflen);\n  // FIXME: under ASan the call below may write to freed memory and corrupt\n  // its metadata. See\n  // https://github.com/google/sanitizers/issues/321.\n  int res = REAL(strerror_r)(errnum, buf, buflen);\n\n  SIZE_T sz = internal_strnlen(buf, buflen);\n  if (sz < buflen) ++sz;\n  COMMON_INTERCEPTOR_WRITE_RANGE(ctx, buf, sz);\n  return res;\n}\n#else\n// GNU version.\nINTERCEPTOR(char *, strerror_r, int errnum, char *buf, SIZE_T buflen) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, strerror_r, errnum, buf, buflen);\n  // FIXME: under ASan the call below may write to freed memory and corrupt\n  // its metadata. See\n  // https://github.com/google/sanitizers/issues/321.\n  char *res = REAL(strerror_r)(errnum, buf, buflen);\n  if (res == buf)\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, res, REAL(strlen)(res) + 1);\n  else\n    COMMON_INTERCEPTOR_INITIALIZE_RANGE(res, REAL(strlen)(res) + 1);\n  return res;\n}\n#endif //(_POSIX_C_SOURCE >= 200112L || _XOPEN_SOURCE >= 600) && !_GNU_SOURCE ||\n       //SANITIZER_MAC\n#define INIT_STRERROR_R COMMON_INTERCEPT_FUNCTION(strerror_r);\n#else\n#define INIT_STRERROR_R\n#endif\n\n#if SANITIZER_INTERCEPT_XPG_STRERROR_R\nINTERCEPTOR(int, __xpg_strerror_r, int errnum, char *buf, SIZE_T buflen) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, __xpg_strerror_r, errnum, buf, buflen);\n  // FIXME: under ASan the call below may write to freed memory and corrupt\n  // its metadata. See\n  // https://github.com/google/sanitizers/issues/321.\n  int res = REAL(__xpg_strerror_r)(errnum, buf, buflen);\n  // This version always returns a null-terminated string.\n  if (buf && buflen)\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, buf, REAL(strlen)(buf) + 1);\n  return res;\n}\n#define INIT_XPG_STRERROR_R COMMON_INTERCEPT_FUNCTION(__xpg_strerror_r);\n#else\n#define INIT_XPG_STRERROR_R\n#endif\n\n#if SANITIZER_INTERCEPT_SCANDIR\ntypedef int (*scandir_filter_f)(const struct __sanitizer_dirent *);\ntypedef int (*scandir_compar_f)(const struct __sanitizer_dirent **,\n                                const struct __sanitizer_dirent **);\n\nstatic THREADLOCAL scandir_filter_f scandir_filter;\nstatic THREADLOCAL scandir_compar_f scandir_compar;\n\nstatic int wrapped_scandir_filter(const struct __sanitizer_dirent *dir) {\n  COMMON_INTERCEPTOR_UNPOISON_PARAM(1);\n  COMMON_INTERCEPTOR_INITIALIZE_RANGE(dir, dir->d_reclen);\n  return scandir_filter(dir);\n}\n\nstatic int wrapped_scandir_compar(const struct __sanitizer_dirent **a,\n                                  const struct __sanitizer_dirent **b) {\n  COMMON_INTERCEPTOR_UNPOISON_PARAM(2);\n  COMMON_INTERCEPTOR_INITIALIZE_RANGE(a, sizeof(*a));\n  COMMON_INTERCEPTOR_INITIALIZE_RANGE(*a, (*a)->d_reclen);\n  COMMON_INTERCEPTOR_INITIALIZE_RANGE(b, sizeof(*b));\n  COMMON_INTERCEPTOR_INITIALIZE_RANGE(*b, (*b)->d_reclen);\n  return scandir_compar(a, b);\n}\n\nINTERCEPTOR(int, scandir, char *dirp, __sanitizer_dirent ***namelist,\n            scandir_filter_f filter, scandir_compar_f compar) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, scandir, dirp, namelist, filter, compar);\n  if (dirp) COMMON_INTERCEPTOR_READ_RANGE(ctx, dirp, REAL(strlen)(dirp) + 1);\n  scandir_filter = filter;\n  scandir_compar = compar;\n  // FIXME: under ASan the call below may write to freed memory and corrupt\n  // its metadata. See\n  // https://github.com/google/sanitizers/issues/321.\n  int res = REAL(scandir)(dirp, namelist,\n                          filter ? wrapped_scandir_filter : nullptr,\n                          compar ? wrapped_scandir_compar : nullptr);\n  scandir_filter = nullptr;\n  scandir_compar = nullptr;\n  if (namelist && res > 0) {\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, namelist, sizeof(*namelist));\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, *namelist, sizeof(**namelist) * res);\n    for (int i = 0; i < res; ++i)\n      COMMON_INTERCEPTOR_WRITE_RANGE(ctx, (*namelist)[i],\n                                     (*namelist)[i]->d_reclen);\n  }\n  return res;\n}\n#define INIT_SCANDIR COMMON_INTERCEPT_FUNCTION(scandir);\n#else\n#define INIT_SCANDIR\n#endif\n\n#if SANITIZER_INTERCEPT_SCANDIR64\ntypedef int (*scandir64_filter_f)(const struct __sanitizer_dirent64 *);\ntypedef int (*scandir64_compar_f)(const struct __sanitizer_dirent64 **,\n                                  const struct __sanitizer_dirent64 **);\n\nstatic THREADLOCAL scandir64_filter_f scandir64_filter;\nstatic THREADLOCAL scandir64_compar_f scandir64_compar;\n\nstatic int wrapped_scandir64_filter(const struct __sanitizer_dirent64 *dir) {\n  COMMON_INTERCEPTOR_UNPOISON_PARAM(1);\n  COMMON_INTERCEPTOR_INITIALIZE_RANGE(dir, dir->d_reclen);\n  return scandir64_filter(dir);\n}\n\nstatic int wrapped_scandir64_compar(const struct __sanitizer_dirent64 **a,\n                                    const struct __sanitizer_dirent64 **b) {\n  COMMON_INTERCEPTOR_UNPOISON_PARAM(2);\n  COMMON_INTERCEPTOR_INITIALIZE_RANGE(a, sizeof(*a));\n  COMMON_INTERCEPTOR_INITIALIZE_RANGE(*a, (*a)->d_reclen);\n  COMMON_INTERCEPTOR_INITIALIZE_RANGE(b, sizeof(*b));\n  COMMON_INTERCEPTOR_INITIALIZE_RANGE(*b, (*b)->d_reclen);\n  return scandir64_compar(a, b);\n}\n\nINTERCEPTOR(int, scandir64, char *dirp, __sanitizer_dirent64 ***namelist,\n            scandir64_filter_f filter, scandir64_compar_f compar) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, scandir64, dirp, namelist, filter, compar);\n  if (dirp) COMMON_INTERCEPTOR_READ_RANGE(ctx, dirp, REAL(strlen)(dirp) + 1);\n  scandir64_filter = filter;\n  scandir64_compar = compar;\n  // FIXME: under ASan the call below may write to freed memory and corrupt\n  // its metadata. See\n  // https://github.com/google/sanitizers/issues/321.\n  int res =\n      REAL(scandir64)(dirp, namelist,\n                      filter ? wrapped_scandir64_filter : nullptr,\n                      compar ? wrapped_scandir64_compar : nullptr);\n  scandir64_filter = nullptr;\n  scandir64_compar = nullptr;\n  if (namelist && res > 0) {\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, namelist, sizeof(*namelist));\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, *namelist, sizeof(**namelist) * res);\n    for (int i = 0; i < res; ++i)\n      COMMON_INTERCEPTOR_WRITE_RANGE(ctx, (*namelist)[i],\n                                     (*namelist)[i]->d_reclen);\n  }\n  return res;\n}\n#define INIT_SCANDIR64 COMMON_INTERCEPT_FUNCTION(scandir64);\n#else\n#define INIT_SCANDIR64\n#endif\n\n#if SANITIZER_INTERCEPT_GETGROUPS\nINTERCEPTOR(int, getgroups, int size, u32 *lst) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, getgroups, size, lst);\n  // FIXME: under ASan the call below may write to freed memory and corrupt\n  // its metadata. See\n  // https://github.com/google/sanitizers/issues/321.\n  int res = REAL(getgroups)(size, lst);\n  if (res >= 0 && lst && size > 0)\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, lst, res * sizeof(*lst));\n  return res;\n}\n#define INIT_GETGROUPS COMMON_INTERCEPT_FUNCTION(getgroups);\n#else\n#define INIT_GETGROUPS\n#endif\n\n#if SANITIZER_INTERCEPT_POLL\nstatic void read_pollfd(void *ctx, __sanitizer_pollfd *fds,\n                        __sanitizer_nfds_t nfds) {\n  for (unsigned i = 0; i < nfds; ++i) {\n    COMMON_INTERCEPTOR_READ_RANGE(ctx, &fds[i].fd, sizeof(fds[i].fd));\n    COMMON_INTERCEPTOR_READ_RANGE(ctx, &fds[i].events, sizeof(fds[i].events));\n  }\n}\n\nstatic void write_pollfd(void *ctx, __sanitizer_pollfd *fds,\n                         __sanitizer_nfds_t nfds) {\n  for (unsigned i = 0; i < nfds; ++i)\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, &fds[i].revents,\n                                   sizeof(fds[i].revents));\n}\n\nINTERCEPTOR(int, poll, __sanitizer_pollfd *fds, __sanitizer_nfds_t nfds,\n            int timeout) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, poll, fds, nfds, timeout);\n  if (fds && nfds) read_pollfd(ctx, fds, nfds);\n  int res = COMMON_INTERCEPTOR_BLOCK_REAL(poll)(fds, nfds, timeout);\n  if (fds && nfds) write_pollfd(ctx, fds, nfds);\n  return res;\n}\n#define INIT_POLL COMMON_INTERCEPT_FUNCTION(poll);\n#else\n#define INIT_POLL\n#endif\n\n#if SANITIZER_INTERCEPT_PPOLL\nINTERCEPTOR(int, ppoll, __sanitizer_pollfd *fds, __sanitizer_nfds_t nfds,\n            void *timeout_ts, __sanitizer_sigset_t *sigmask) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, ppoll, fds, nfds, timeout_ts, sigmask);\n  if (fds && nfds) read_pollfd(ctx, fds, nfds);\n  if (timeout_ts)\n    COMMON_INTERCEPTOR_READ_RANGE(ctx, timeout_ts, struct_timespec_sz);\n  if (sigmask) COMMON_INTERCEPTOR_READ_RANGE(ctx, sigmask, sizeof(*sigmask));\n  int res =\n      COMMON_INTERCEPTOR_BLOCK_REAL(ppoll)(fds, nfds, timeout_ts, sigmask);\n  if (fds && nfds) write_pollfd(ctx, fds, nfds);\n  return res;\n}\n#define INIT_PPOLL COMMON_INTERCEPT_FUNCTION(ppoll);\n#else\n#define INIT_PPOLL\n#endif\n\n#if SANITIZER_INTERCEPT_WORDEXP\nINTERCEPTOR(int, wordexp, char *s, __sanitizer_wordexp_t *p, int flags) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, wordexp, s, p, flags);\n  if (s) COMMON_INTERCEPTOR_READ_RANGE(ctx, s, REAL(strlen)(s) + 1);\n  // FIXME: under ASan the call below may write to freed memory and corrupt\n  // its metadata. See\n  // https://github.com/google/sanitizers/issues/321.\n  int res = REAL(wordexp)(s, p, flags);\n  if (!res && p) {\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, p, sizeof(*p));\n    if (p->we_wordc)\n      COMMON_INTERCEPTOR_WRITE_RANGE(ctx, p->we_wordv,\n                                     sizeof(*p->we_wordv) * p->we_wordc);\n    for (uptr i = 0; i < p->we_wordc; ++i) {\n      char *w = p->we_wordv[i];\n      if (w) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, w, REAL(strlen)(w) + 1);\n    }\n  }\n  return res;\n}\n#define INIT_WORDEXP COMMON_INTERCEPT_FUNCTION(wordexp);\n#else\n#define INIT_WORDEXP\n#endif\n\n#if SANITIZER_INTERCEPT_SIGWAIT\nINTERCEPTOR(int, sigwait, __sanitizer_sigset_t *set, int *sig) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, sigwait, set, sig);\n  if (set) COMMON_INTERCEPTOR_READ_RANGE(ctx, set, sizeof(*set));\n  // FIXME: under ASan the call below may write to freed memory and corrupt\n  // its metadata. See\n  // https://github.com/google/sanitizers/issues/321.\n  int res = REAL(sigwait)(set, sig);\n  if (!res && sig) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, sig, sizeof(*sig));\n  return res;\n}\n#define INIT_SIGWAIT COMMON_INTERCEPT_FUNCTION(sigwait);\n#else\n#define INIT_SIGWAIT\n#endif\n\n#if SANITIZER_INTERCEPT_SIGWAITINFO\nINTERCEPTOR(int, sigwaitinfo, __sanitizer_sigset_t *set, void *info) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, sigwaitinfo, set, info);\n  if (set) COMMON_INTERCEPTOR_READ_RANGE(ctx, set, sizeof(*set));\n  // FIXME: under ASan the call below may write to freed memory and corrupt\n  // its metadata. See\n  // https://github.com/google/sanitizers/issues/321.\n  int res = REAL(sigwaitinfo)(set, info);\n  if (res > 0 && info) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, info, siginfo_t_sz);\n  return res;\n}\n#define INIT_SIGWAITINFO COMMON_INTERCEPT_FUNCTION(sigwaitinfo);\n#else\n#define INIT_SIGWAITINFO\n#endif\n\n#if SANITIZER_INTERCEPT_SIGTIMEDWAIT\nINTERCEPTOR(int, sigtimedwait, __sanitizer_sigset_t *set, void *info,\n            void *timeout) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, sigtimedwait, set, info, timeout);\n  if (timeout) COMMON_INTERCEPTOR_READ_RANGE(ctx, timeout, struct_timespec_sz);\n  if (set) COMMON_INTERCEPTOR_READ_RANGE(ctx, set, sizeof(*set));\n  // FIXME: under ASan the call below may write to freed memory and corrupt\n  // its metadata. See\n  // https://github.com/google/sanitizers/issues/321.\n  int res = REAL(sigtimedwait)(set, info, timeout);\n  if (res > 0 && info) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, info, siginfo_t_sz);\n  return res;\n}\n#define INIT_SIGTIMEDWAIT COMMON_INTERCEPT_FUNCTION(sigtimedwait);\n#else\n#define INIT_SIGTIMEDWAIT\n#endif\n\n#if SANITIZER_INTERCEPT_SIGSETOPS\nINTERCEPTOR(int, sigemptyset, __sanitizer_sigset_t *set) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, sigemptyset, set);\n  // FIXME: under ASan the call below may write to freed memory and corrupt\n  // its metadata. See\n  // https://github.com/google/sanitizers/issues/321.\n  int res = REAL(sigemptyset)(set);\n  if (!res && set) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, set, sizeof(*set));\n  return res;\n}\n\nINTERCEPTOR(int, sigfillset, __sanitizer_sigset_t *set) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, sigfillset, set);\n  // FIXME: under ASan the call below may write to freed memory and corrupt\n  // its metadata. See\n  // https://github.com/google/sanitizers/issues/321.\n  int res = REAL(sigfillset)(set);\n  if (!res && set) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, set, sizeof(*set));\n  return res;\n}\n#define INIT_SIGSETOPS                    \\\n  COMMON_INTERCEPT_FUNCTION(sigemptyset); \\\n  COMMON_INTERCEPT_FUNCTION(sigfillset);\n#else\n#define INIT_SIGSETOPS\n#endif\n\n#if SANITIZER_INTERCEPT_SIGSET_LOGICOPS\nINTERCEPTOR(int, sigandset, __sanitizer_sigset_t *dst,\n            __sanitizer_sigset_t *src1, __sanitizer_sigset_t *src2) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, sigandset, dst, src1, src2);\n  if (src1)\n    COMMON_INTERCEPTOR_READ_RANGE(ctx, src1, sizeof(*src1));\n  if (src2)\n    COMMON_INTERCEPTOR_READ_RANGE(ctx, src2, sizeof(*src2));\n  int res = REAL(sigandset)(dst, src1, src2);\n  if (!res && dst)\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, dst, sizeof(*dst));\n  return res;\n}\n\nINTERCEPTOR(int, sigorset, __sanitizer_sigset_t *dst,\n            __sanitizer_sigset_t *src1, __sanitizer_sigset_t *src2) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, sigorset, dst, src1, src2);\n  if (src1)\n    COMMON_INTERCEPTOR_READ_RANGE(ctx, src1, sizeof(*src1));\n  if (src2)\n    COMMON_INTERCEPTOR_READ_RANGE(ctx, src2, sizeof(*src2));\n  int res = REAL(sigorset)(dst, src1, src2);\n  if (!res && dst)\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, dst, sizeof(*dst));\n  return res;\n}\n#define INIT_SIGSET_LOGICOPS                    \\\n  COMMON_INTERCEPT_FUNCTION(sigandset);   \\\n  COMMON_INTERCEPT_FUNCTION(sigorset);\n#else\n#define INIT_SIGSET_LOGICOPS\n#endif\n\n#if SANITIZER_INTERCEPT_SIGPENDING\nINTERCEPTOR(int, sigpending, __sanitizer_sigset_t *set) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, sigpending, set);\n  // FIXME: under ASan the call below may write to freed memory and corrupt\n  // its metadata. See\n  // https://github.com/google/sanitizers/issues/321.\n  int res = REAL(sigpending)(set);\n  if (!res && set) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, set, sizeof(*set));\n  return res;\n}\n#define INIT_SIGPENDING COMMON_INTERCEPT_FUNCTION(sigpending);\n#else\n#define INIT_SIGPENDING\n#endif\n\n#if SANITIZER_INTERCEPT_SIGPROCMASK\nINTERCEPTOR(int, sigprocmask, int how, __sanitizer_sigset_t *set,\n            __sanitizer_sigset_t *oldset) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, sigprocmask, how, set, oldset);\n  if (set) COMMON_INTERCEPTOR_READ_RANGE(ctx, set, sizeof(*set));\n  // FIXME: under ASan the call below may write to freed memory and corrupt\n  // its metadata. See\n  // https://github.com/google/sanitizers/issues/321.\n  int res = REAL(sigprocmask)(how, set, oldset);\n  if (!res && oldset)\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, oldset, sizeof(*oldset));\n  return res;\n}\n#define INIT_SIGPROCMASK COMMON_INTERCEPT_FUNCTION(sigprocmask);\n#else\n#define INIT_SIGPROCMASK\n#endif\n\n#if SANITIZER_INTERCEPT_PTHREAD_SIGMASK\nINTERCEPTOR(int, pthread_sigmask, int how, __sanitizer_sigset_t *set,\n            __sanitizer_sigset_t *oldset) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, pthread_sigmask, how, set, oldset);\n  if (set) COMMON_INTERCEPTOR_READ_RANGE(ctx, set, sizeof(*set));\n  // FIXME: under ASan the call below may write to freed memory and corrupt\n  // its metadata. See\n  // https://github.com/google/sanitizers/issues/321.\n  int res = REAL(pthread_sigmask)(how, set, oldset);\n  if (!res && oldset)\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, oldset, sizeof(*oldset));\n  return res;\n}\n#define INIT_PTHREAD_SIGMASK COMMON_INTERCEPT_FUNCTION(pthread_sigmask);\n#else\n#define INIT_PTHREAD_SIGMASK\n#endif\n\n#if SANITIZER_INTERCEPT_BACKTRACE\nINTERCEPTOR(int, backtrace, void **buffer, int size) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, backtrace, buffer, size);\n  // FIXME: under ASan the call below may write to freed memory and corrupt\n  // its metadata. See\n  // https://github.com/google/sanitizers/issues/321.\n  int res = REAL(backtrace)(buffer, size);\n  if (res && buffer)\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, buffer, res * sizeof(*buffer));\n  return res;\n}\n\nINTERCEPTOR(char **, backtrace_symbols, void **buffer, int size) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, backtrace_symbols, buffer, size);\n  if (buffer && size)\n    COMMON_INTERCEPTOR_READ_RANGE(ctx, buffer, size * sizeof(*buffer));\n  // FIXME: under ASan the call below may write to freed memory and corrupt\n  // its metadata. See\n  // https://github.com/google/sanitizers/issues/321.\n  char **res = REAL(backtrace_symbols)(buffer, size);\n  if (res && size) {\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, res, size * sizeof(*res));\n    for (int i = 0; i < size; ++i)\n      COMMON_INTERCEPTOR_WRITE_RANGE(ctx, res[i], REAL(strlen(res[i])) + 1);\n  }\n  return res;\n}\n#define INIT_BACKTRACE                  \\\n  COMMON_INTERCEPT_FUNCTION(backtrace); \\\n  COMMON_INTERCEPT_FUNCTION(backtrace_symbols);\n#else\n#define INIT_BACKTRACE\n#endif\n\n#if SANITIZER_INTERCEPT__EXIT\nINTERCEPTOR(void, _exit, int status) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, _exit, status);\n  COMMON_INTERCEPTOR_USER_CALLBACK_START();\n  int status1 = COMMON_INTERCEPTOR_ON_EXIT(ctx);\n  COMMON_INTERCEPTOR_USER_CALLBACK_END();\n  if (status == 0) status = status1;\n  REAL(_exit)(status);\n}\n#define INIT__EXIT COMMON_INTERCEPT_FUNCTION(_exit);\n#else\n#define INIT__EXIT\n#endif\n\n#if SANITIZER_INTERCEPT_PTHREAD_MUTEX\nINTERCEPTOR(int, pthread_mutex_lock, void *m) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, pthread_mutex_lock, m);\n  COMMON_INTERCEPTOR_MUTEX_PRE_LOCK(ctx, m);\n  int res = REAL(pthread_mutex_lock)(m);\n  if (res == errno_EOWNERDEAD)\n    COMMON_INTERCEPTOR_MUTEX_REPAIR(ctx, m);\n  if (res == 0 || res == errno_EOWNERDEAD)\n    COMMON_INTERCEPTOR_MUTEX_POST_LOCK(ctx, m);\n  if (res == errno_EINVAL)\n    COMMON_INTERCEPTOR_MUTEX_INVALID(ctx, m);\n  return res;\n}\n\nINTERCEPTOR(int, pthread_mutex_unlock, void *m) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, pthread_mutex_unlock, m);\n  COMMON_INTERCEPTOR_MUTEX_UNLOCK(ctx, m);\n  int res = REAL(pthread_mutex_unlock)(m);\n  if (res == errno_EINVAL)\n    COMMON_INTERCEPTOR_MUTEX_INVALID(ctx, m);\n  return res;\n}\n\n#define INIT_PTHREAD_MUTEX_LOCK COMMON_INTERCEPT_FUNCTION(pthread_mutex_lock)\n#define INIT_PTHREAD_MUTEX_UNLOCK \\\n  COMMON_INTERCEPT_FUNCTION(pthread_mutex_unlock)\n#else\n#define INIT_PTHREAD_MUTEX_LOCK\n#define INIT_PTHREAD_MUTEX_UNLOCK\n#endif\n\n#if SANITIZER_INTERCEPT___PTHREAD_MUTEX\nINTERCEPTOR(int, __pthread_mutex_lock, void *m) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, __pthread_mutex_lock, m);\n  COMMON_INTERCEPTOR_MUTEX_PRE_LOCK(ctx, m);\n  int res = REAL(__pthread_mutex_lock)(m);\n  if (res == errno_EOWNERDEAD)\n    COMMON_INTERCEPTOR_MUTEX_REPAIR(ctx, m);\n  if (res == 0 || res == errno_EOWNERDEAD)\n    COMMON_INTERCEPTOR_MUTEX_POST_LOCK(ctx, m);\n  if (res == errno_EINVAL)\n    COMMON_INTERCEPTOR_MUTEX_INVALID(ctx, m);\n  return res;\n}\n\nINTERCEPTOR(int, __pthread_mutex_unlock, void *m) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, __pthread_mutex_unlock, m);\n  COMMON_INTERCEPTOR_MUTEX_UNLOCK(ctx, m);\n  int res = REAL(__pthread_mutex_unlock)(m);\n  if (res == errno_EINVAL)\n    COMMON_INTERCEPTOR_MUTEX_INVALID(ctx, m);\n  return res;\n}\n\n#define INIT___PTHREAD_MUTEX_LOCK \\\n  COMMON_INTERCEPT_FUNCTION(__pthread_mutex_lock)\n#define INIT___PTHREAD_MUTEX_UNLOCK \\\n  COMMON_INTERCEPT_FUNCTION(__pthread_mutex_unlock)\n#else\n#define INIT___PTHREAD_MUTEX_LOCK\n#define INIT___PTHREAD_MUTEX_UNLOCK\n#endif\n\n#if SANITIZER_INTERCEPT___LIBC_MUTEX\nINTERCEPTOR(int, __libc_mutex_lock, void *m)\nALIAS(WRAPPER_NAME(pthread_mutex_lock));\n\nINTERCEPTOR(int, __libc_mutex_unlock, void *m)\nALIAS(WRAPPER_NAME(pthread_mutex_unlock));\n\nINTERCEPTOR(int, __libc_thr_setcancelstate, int state, int *oldstate)\nALIAS(WRAPPER_NAME(pthread_setcancelstate));\n\n#define INIT___LIBC_MUTEX_LOCK COMMON_INTERCEPT_FUNCTION(__libc_mutex_lock)\n#define INIT___LIBC_MUTEX_UNLOCK COMMON_INTERCEPT_FUNCTION(__libc_mutex_unlock)\n#define INIT___LIBC_THR_SETCANCELSTATE \\\n  COMMON_INTERCEPT_FUNCTION(__libc_thr_setcancelstate)\n#else\n#define INIT___LIBC_MUTEX_LOCK\n#define INIT___LIBC_MUTEX_UNLOCK\n#define INIT___LIBC_THR_SETCANCELSTATE\n#endif\n\n#if SANITIZER_INTERCEPT_GETMNTENT || SANITIZER_INTERCEPT_GETMNTENT_R\nstatic void write_mntent(void *ctx, __sanitizer_mntent *mnt) {\n  COMMON_INTERCEPTOR_WRITE_RANGE(ctx, mnt, sizeof(*mnt));\n  if (mnt->mnt_fsname)\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, mnt->mnt_fsname,\n                                   REAL(strlen)(mnt->mnt_fsname) + 1);\n  if (mnt->mnt_dir)\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, mnt->mnt_dir,\n                                   REAL(strlen)(mnt->mnt_dir) + 1);\n  if (mnt->mnt_type)\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, mnt->mnt_type,\n                                   REAL(strlen)(mnt->mnt_type) + 1);\n  if (mnt->mnt_opts)\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, mnt->mnt_opts,\n                                   REAL(strlen)(mnt->mnt_opts) + 1);\n}\n#endif\n\n#if SANITIZER_INTERCEPT_GETMNTENT\nINTERCEPTOR(__sanitizer_mntent *, getmntent, void *fp) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, getmntent, fp);\n  __sanitizer_mntent *res = REAL(getmntent)(fp);\n  if (res) write_mntent(ctx, res);\n  return res;\n}\n#define INIT_GETMNTENT COMMON_INTERCEPT_FUNCTION(getmntent);\n#else\n#define INIT_GETMNTENT\n#endif\n\n#if SANITIZER_INTERCEPT_GETMNTENT_R\nINTERCEPTOR(__sanitizer_mntent *, getmntent_r, void *fp,\n            __sanitizer_mntent *mntbuf, char *buf, int buflen) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, getmntent_r, fp, mntbuf, buf, buflen);\n  __sanitizer_mntent *res = REAL(getmntent_r)(fp, mntbuf, buf, buflen);\n  if (res) write_mntent(ctx, res);\n  return res;\n}\n#define INIT_GETMNTENT_R COMMON_INTERCEPT_FUNCTION(getmntent_r);\n#else\n#define INIT_GETMNTENT_R\n#endif\n\n#if SANITIZER_INTERCEPT_STATFS\nINTERCEPTOR(int, statfs, char *path, void *buf) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, statfs, path, buf);\n  if (path) COMMON_INTERCEPTOR_READ_RANGE(ctx, path, REAL(strlen)(path) + 1);\n  // FIXME: under ASan the call below may write to freed memory and corrupt\n  // its metadata. See\n  // https://github.com/google/sanitizers/issues/321.\n  int res = REAL(statfs)(path, buf);\n  if (!res) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, buf, struct_statfs_sz);\n  return res;\n}\nINTERCEPTOR(int, fstatfs, int fd, void *buf) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, fstatfs, fd, buf);\n  // FIXME: under ASan the call below may write to freed memory and corrupt\n  // its metadata. See\n  // https://github.com/google/sanitizers/issues/321.\n  int res = REAL(fstatfs)(fd, buf);\n  if (!res) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, buf, struct_statfs_sz);\n  return res;\n}\n#define INIT_STATFS                  \\\n  COMMON_INTERCEPT_FUNCTION(statfs); \\\n  COMMON_INTERCEPT_FUNCTION(fstatfs);\n#else\n#define INIT_STATFS\n#endif\n\n#if SANITIZER_INTERCEPT_STATFS64\nINTERCEPTOR(int, statfs64, char *path, void *buf) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, statfs64, path, buf);\n  if (path) COMMON_INTERCEPTOR_READ_RANGE(ctx, path, REAL(strlen)(path) + 1);\n  // FIXME: under ASan the call below may write to freed memory and corrupt\n  // its metadata. See\n  // https://github.com/google/sanitizers/issues/321.\n  int res = REAL(statfs64)(path, buf);\n  if (!res) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, buf, struct_statfs64_sz);\n  return res;\n}\nINTERCEPTOR(int, fstatfs64, int fd, void *buf) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, fstatfs64, fd, buf);\n  // FIXME: under ASan the call below may write to freed memory and corrupt\n  // its metadata. See\n  // https://github.com/google/sanitizers/issues/321.\n  int res = REAL(fstatfs64)(fd, buf);\n  if (!res) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, buf, struct_statfs64_sz);\n  return res;\n}\n#define INIT_STATFS64                  \\\n  COMMON_INTERCEPT_FUNCTION(statfs64); \\\n  COMMON_INTERCEPT_FUNCTION(fstatfs64);\n#else\n#define INIT_STATFS64\n#endif\n\n#if SANITIZER_INTERCEPT_STATVFS\nINTERCEPTOR(int, statvfs, char *path, void *buf) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, statvfs, path, buf);\n  if (path) COMMON_INTERCEPTOR_READ_RANGE(ctx, path, REAL(strlen)(path) + 1);\n  // FIXME: under ASan the call below may write to freed memory and corrupt\n  // its metadata. See\n  // https://github.com/google/sanitizers/issues/321.\n  int res = REAL(statvfs)(path, buf);\n  if (!res) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, buf, struct_statvfs_sz);\n  return res;\n}\nINTERCEPTOR(int, fstatvfs, int fd, void *buf) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, fstatvfs, fd, buf);\n  COMMON_INTERCEPTOR_FD_ACCESS(ctx, fd);\n  // FIXME: under ASan the call below may write to freed memory and corrupt\n  // its metadata. See\n  // https://github.com/google/sanitizers/issues/321.\n  int res = REAL(fstatvfs)(fd, buf);\n  if (!res) {\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, buf, struct_statvfs_sz);\n    if (fd >= 0)\n      COMMON_INTERCEPTOR_FD_ACQUIRE(ctx, fd);\n  }\n  return res;\n}\n#define INIT_STATVFS                  \\\n  COMMON_INTERCEPT_FUNCTION(statvfs); \\\n  COMMON_INTERCEPT_FUNCTION(fstatvfs);\n#else\n#define INIT_STATVFS\n#endif\n\n#if SANITIZER_INTERCEPT_STATVFS64\nINTERCEPTOR(int, statvfs64, char *path, void *buf) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, statvfs64, path, buf);\n  if (path) COMMON_INTERCEPTOR_READ_RANGE(ctx, path, REAL(strlen)(path) + 1);\n  // FIXME: under ASan the call below may write to freed memory and corrupt\n  // its metadata. See\n  // https://github.com/google/sanitizers/issues/321.\n  int res = REAL(statvfs64)(path, buf);\n  if (!res) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, buf, struct_statvfs64_sz);\n  return res;\n}\nINTERCEPTOR(int, fstatvfs64, int fd, void *buf) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, fstatvfs64, fd, buf);\n  // FIXME: under ASan the call below may write to freed memory and corrupt\n  // its metadata. See\n  // https://github.com/google/sanitizers/issues/321.\n  int res = REAL(fstatvfs64)(fd, buf);\n  if (!res) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, buf, struct_statvfs64_sz);\n  return res;\n}\n#define INIT_STATVFS64                  \\\n  COMMON_INTERCEPT_FUNCTION(statvfs64); \\\n  COMMON_INTERCEPT_FUNCTION(fstatvfs64);\n#else\n#define INIT_STATVFS64\n#endif\n\n#if SANITIZER_INTERCEPT_INITGROUPS\nINTERCEPTOR(int, initgroups, char *user, u32 group) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, initgroups, user, group);\n  if (user) COMMON_INTERCEPTOR_READ_RANGE(ctx, user, REAL(strlen)(user) + 1);\n  int res = REAL(initgroups)(user, group);\n  return res;\n}\n#define INIT_INITGROUPS COMMON_INTERCEPT_FUNCTION(initgroups);\n#else\n#define INIT_INITGROUPS\n#endif\n\n#if SANITIZER_INTERCEPT_ETHER_NTOA_ATON\nINTERCEPTOR(char *, ether_ntoa, __sanitizer_ether_addr *addr) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, ether_ntoa, addr);\n  if (addr) COMMON_INTERCEPTOR_READ_RANGE(ctx, addr, sizeof(*addr));\n  char *res = REAL(ether_ntoa)(addr);\n  if (res) COMMON_INTERCEPTOR_INITIALIZE_RANGE(res, REAL(strlen)(res) + 1);\n  return res;\n}\nINTERCEPTOR(__sanitizer_ether_addr *, ether_aton, char *buf) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, ether_aton, buf);\n  if (buf) COMMON_INTERCEPTOR_READ_RANGE(ctx, buf, REAL(strlen)(buf) + 1);\n  __sanitizer_ether_addr *res = REAL(ether_aton)(buf);\n  if (res) COMMON_INTERCEPTOR_INITIALIZE_RANGE(res, sizeof(*res));\n  return res;\n}\n#define INIT_ETHER_NTOA_ATON             \\\n  COMMON_INTERCEPT_FUNCTION(ether_ntoa); \\\n  COMMON_INTERCEPT_FUNCTION(ether_aton);\n#else\n#define INIT_ETHER_NTOA_ATON\n#endif\n\n#if SANITIZER_INTERCEPT_ETHER_HOST\nINTERCEPTOR(int, ether_ntohost, char *hostname, __sanitizer_ether_addr *addr) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, ether_ntohost, hostname, addr);\n  if (addr) COMMON_INTERCEPTOR_READ_RANGE(ctx, addr, sizeof(*addr));\n  // FIXME: under ASan the call below may write to freed memory and corrupt\n  // its metadata. See\n  // https://github.com/google/sanitizers/issues/321.\n  int res = REAL(ether_ntohost)(hostname, addr);\n  if (!res && hostname)\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, hostname, REAL(strlen)(hostname) + 1);\n  return res;\n}\nINTERCEPTOR(int, ether_hostton, char *hostname, __sanitizer_ether_addr *addr) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, ether_hostton, hostname, addr);\n  if (hostname)\n    COMMON_INTERCEPTOR_READ_RANGE(ctx, hostname, REAL(strlen)(hostname) + 1);\n  // FIXME: under ASan the call below may write to freed memory and corrupt\n  // its metadata. See\n  // https://github.com/google/sanitizers/issues/321.\n  int res = REAL(ether_hostton)(hostname, addr);\n  if (!res && addr) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, addr, sizeof(*addr));\n  return res;\n}\nINTERCEPTOR(int, ether_line, char *line, __sanitizer_ether_addr *addr,\n            char *hostname) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, ether_line, line, addr, hostname);\n  if (line) COMMON_INTERCEPTOR_READ_RANGE(ctx, line, REAL(strlen)(line) + 1);\n  // FIXME: under ASan the call below may write to freed memory and corrupt\n  // its metadata. See\n  // https://github.com/google/sanitizers/issues/321.\n  int res = REAL(ether_line)(line, addr, hostname);\n  if (!res) {\n    if (addr) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, addr, sizeof(*addr));\n    if (hostname)\n      COMMON_INTERCEPTOR_WRITE_RANGE(ctx, hostname, REAL(strlen)(hostname) + 1);\n  }\n  return res;\n}\n#define INIT_ETHER_HOST                     \\\n  COMMON_INTERCEPT_FUNCTION(ether_ntohost); \\\n  COMMON_INTERCEPT_FUNCTION(ether_hostton); \\\n  COMMON_INTERCEPT_FUNCTION(ether_line);\n#else\n#define INIT_ETHER_HOST\n#endif\n\n#if SANITIZER_INTERCEPT_ETHER_R\nINTERCEPTOR(char *, ether_ntoa_r, __sanitizer_ether_addr *addr, char *buf) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, ether_ntoa_r, addr, buf);\n  if (addr) COMMON_INTERCEPTOR_READ_RANGE(ctx, addr, sizeof(*addr));\n  // FIXME: under ASan the call below may write to freed memory and corrupt\n  // its metadata. See\n  // https://github.com/google/sanitizers/issues/321.\n  char *res = REAL(ether_ntoa_r)(addr, buf);\n  if (res) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, res, REAL(strlen)(res) + 1);\n  return res;\n}\nINTERCEPTOR(__sanitizer_ether_addr *, ether_aton_r, char *buf,\n            __sanitizer_ether_addr *addr) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, ether_aton_r, buf, addr);\n  if (buf) COMMON_INTERCEPTOR_READ_RANGE(ctx, buf, REAL(strlen)(buf) + 1);\n  // FIXME: under ASan the call below may write to freed memory and corrupt\n  // its metadata. See\n  // https://github.com/google/sanitizers/issues/321.\n  __sanitizer_ether_addr *res = REAL(ether_aton_r)(buf, addr);\n  if (res) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, res, sizeof(*res));\n  return res;\n}\n#define INIT_ETHER_R                       \\\n  COMMON_INTERCEPT_FUNCTION(ether_ntoa_r); \\\n  COMMON_INTERCEPT_FUNCTION(ether_aton_r);\n#else\n#define INIT_ETHER_R\n#endif\n\n#if SANITIZER_INTERCEPT_SHMCTL\nINTERCEPTOR(int, shmctl, int shmid, int cmd, void *buf) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, shmctl, shmid, cmd, buf);\n  // FIXME: under ASan the call below may write to freed memory and corrupt\n  // its metadata. See\n  // https://github.com/google/sanitizers/issues/321.\n  int res = REAL(shmctl)(shmid, cmd, buf);\n  if (res >= 0) {\n    unsigned sz = 0;\n    if (cmd == shmctl_ipc_stat || cmd == shmctl_shm_stat)\n      sz = sizeof(__sanitizer_shmid_ds);\n    else if (cmd == shmctl_ipc_info)\n      sz = struct_shminfo_sz;\n    else if (cmd == shmctl_shm_info)\n      sz = struct_shm_info_sz;\n    if (sz) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, buf, sz);\n  }\n  return res;\n}\n#define INIT_SHMCTL COMMON_INTERCEPT_FUNCTION(shmctl);\n#else\n#define INIT_SHMCTL\n#endif\n\n#if SANITIZER_INTERCEPT_RANDOM_R\nINTERCEPTOR(int, random_r, void *buf, u32 *result) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, random_r, buf, result);\n  // FIXME: under ASan the call below may write to freed memory and corrupt\n  // its metadata. See\n  // https://github.com/google/sanitizers/issues/321.\n  int res = REAL(random_r)(buf, result);\n  if (!res && result)\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, result, sizeof(*result));\n  return res;\n}\n#define INIT_RANDOM_R COMMON_INTERCEPT_FUNCTION(random_r);\n#else\n#define INIT_RANDOM_R\n#endif\n\n// FIXME: under ASan the REAL() call below may write to freed memory and corrupt\n// its metadata. See\n// https://github.com/google/sanitizers/issues/321.\n#if SANITIZER_INTERCEPT_PTHREAD_ATTR_GET ||              \\\n    SANITIZER_INTERCEPT_PTHREAD_ATTR_GET_SCHED ||        \\\n    SANITIZER_INTERCEPT_PTHREAD_ATTR_GETINHERITSSCHED || \\\n    SANITIZER_INTERCEPT_PTHREAD_MUTEXATTR_GET ||         \\\n    SANITIZER_INTERCEPT_PTHREAD_RWLOCKATTR_GET ||        \\\n    SANITIZER_INTERCEPT_PTHREAD_CONDATTR_GET ||          \\\n    SANITIZER_INTERCEPT_PTHREAD_BARRIERATTR_GET\n#define INTERCEPTOR_PTHREAD_OBJECT_ATTR_GET(fn, sz)            \\\n  INTERCEPTOR(int, fn, void *attr, void *r) {                  \\\n    void *ctx;                                                 \\\n    COMMON_INTERCEPTOR_ENTER(ctx, fn, attr, r);                \\\n    int res = REAL(fn)(attr, r);                               \\\n    if (!res && r) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, r, sz); \\\n    return res;                                                \\\n  }\n#define INTERCEPTOR_PTHREAD_ATTR_GET(what, sz) \\\n  INTERCEPTOR_PTHREAD_OBJECT_ATTR_GET(pthread_attr_get##what, sz)\n#define INTERCEPTOR_PTHREAD_MUTEXATTR_GET(what, sz) \\\n  INTERCEPTOR_PTHREAD_OBJECT_ATTR_GET(pthread_mutexattr_get##what, sz)\n#define INTERCEPTOR_PTHREAD_RWLOCKATTR_GET(what, sz) \\\n  INTERCEPTOR_PTHREAD_OBJECT_ATTR_GET(pthread_rwlockattr_get##what, sz)\n#define INTERCEPTOR_PTHREAD_CONDATTR_GET(what, sz) \\\n  INTERCEPTOR_PTHREAD_OBJECT_ATTR_GET(pthread_condattr_get##what, sz)\n#define INTERCEPTOR_PTHREAD_BARRIERATTR_GET(what, sz) \\\n  INTERCEPTOR_PTHREAD_OBJECT_ATTR_GET(pthread_barrierattr_get##what, sz)\n#endif\n\n#if SANITIZER_INTERCEPT_PTHREAD_ATTR_GET\nINTERCEPTOR_PTHREAD_ATTR_GET(detachstate, sizeof(int))\nINTERCEPTOR_PTHREAD_ATTR_GET(guardsize, sizeof(SIZE_T))\nINTERCEPTOR_PTHREAD_ATTR_GET(scope, sizeof(int))\nINTERCEPTOR_PTHREAD_ATTR_GET(stacksize, sizeof(SIZE_T))\nINTERCEPTOR(int, pthread_attr_getstack, void *attr, void **addr, SIZE_T *size) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, pthread_attr_getstack, attr, addr, size);\n  // FIXME: under ASan the call below may write to freed memory and corrupt\n  // its metadata. See\n  // https://github.com/google/sanitizers/issues/321.\n  int res = REAL(pthread_attr_getstack)(attr, addr, size);\n  if (!res) {\n    if (addr) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, addr, sizeof(*addr));\n    if (size) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, size, sizeof(*size));\n  }\n  return res;\n}\n\n// We may need to call the real pthread_attr_getstack from the run-time\n// in sanitizer_common, but we don't want to include the interception headers\n// there. So, just define this function here.\nnamespace __sanitizer {\nextern \"C\" {\nint real_pthread_attr_getstack(void *attr, void **addr, SIZE_T *size) {\n  return REAL(pthread_attr_getstack)(attr, addr, size);\n}\n}  // extern \"C\"\n}  // namespace __sanitizer\n\n#define INIT_PTHREAD_ATTR_GET                             \\\n  COMMON_INTERCEPT_FUNCTION(pthread_attr_getdetachstate); \\\n  COMMON_INTERCEPT_FUNCTION(pthread_attr_getguardsize);   \\\n  COMMON_INTERCEPT_FUNCTION(pthread_attr_getscope);       \\\n  COMMON_INTERCEPT_FUNCTION(pthread_attr_getstacksize);   \\\n  COMMON_INTERCEPT_FUNCTION(pthread_attr_getstack);\n#else\n#define INIT_PTHREAD_ATTR_GET\n#endif\n\n#if SANITIZER_INTERCEPT_PTHREAD_ATTR_GET_SCHED\nINTERCEPTOR_PTHREAD_ATTR_GET(schedparam, struct_sched_param_sz)\nINTERCEPTOR_PTHREAD_ATTR_GET(schedpolicy, sizeof(int))\n\n#define INIT_PTHREAD_ATTR_GET_SCHED                      \\\n  COMMON_INTERCEPT_FUNCTION(pthread_attr_getschedparam); \\\n  COMMON_INTERCEPT_FUNCTION(pthread_attr_getschedpolicy);\n#else\n#define INIT_PTHREAD_ATTR_GET_SCHED\n#endif\n\n#if SANITIZER_INTERCEPT_PTHREAD_ATTR_GETINHERITSCHED\nINTERCEPTOR_PTHREAD_ATTR_GET(inheritsched, sizeof(int))\n\n#define INIT_PTHREAD_ATTR_GETINHERITSCHED \\\n  COMMON_INTERCEPT_FUNCTION(pthread_attr_getinheritsched);\n#else\n#define INIT_PTHREAD_ATTR_GETINHERITSCHED\n#endif\n\n#if SANITIZER_INTERCEPT_PTHREAD_ATTR_GETAFFINITY_NP\nINTERCEPTOR(int, pthread_attr_getaffinity_np, void *attr, SIZE_T cpusetsize,\n            void *cpuset) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, pthread_attr_getaffinity_np, attr, cpusetsize,\n                           cpuset);\n  // FIXME: under ASan the call below may write to freed memory and corrupt\n  // its metadata. See\n  // https://github.com/google/sanitizers/issues/321.\n  int res = REAL(pthread_attr_getaffinity_np)(attr, cpusetsize, cpuset);\n  if (!res && cpusetsize && cpuset)\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, cpuset, cpusetsize);\n  return res;\n}\n\n#define INIT_PTHREAD_ATTR_GETAFFINITY_NP \\\n  COMMON_INTERCEPT_FUNCTION(pthread_attr_getaffinity_np);\n#else\n#define INIT_PTHREAD_ATTR_GETAFFINITY_NP\n#endif\n\n#if SANITIZER_INTERCEPT_PTHREAD_MUTEXATTR_GETPSHARED\nINTERCEPTOR_PTHREAD_MUTEXATTR_GET(pshared, sizeof(int))\n#define INIT_PTHREAD_MUTEXATTR_GETPSHARED \\\n  COMMON_INTERCEPT_FUNCTION(pthread_mutexattr_getpshared);\n#else\n#define INIT_PTHREAD_MUTEXATTR_GETPSHARED\n#endif\n\n#if SANITIZER_INTERCEPT_PTHREAD_MUTEXATTR_GETTYPE\nINTERCEPTOR_PTHREAD_MUTEXATTR_GET(type, sizeof(int))\n#define INIT_PTHREAD_MUTEXATTR_GETTYPE \\\n  COMMON_INTERCEPT_FUNCTION(pthread_mutexattr_gettype);\n#else\n#define INIT_PTHREAD_MUTEXATTR_GETTYPE\n#endif\n\n#if SANITIZER_INTERCEPT_PTHREAD_MUTEXATTR_GETPROTOCOL\nINTERCEPTOR_PTHREAD_MUTEXATTR_GET(protocol, sizeof(int))\n#define INIT_PTHREAD_MUTEXATTR_GETPROTOCOL \\\n  COMMON_INTERCEPT_FUNCTION(pthread_mutexattr_getprotocol);\n#else\n#define INIT_PTHREAD_MUTEXATTR_GETPROTOCOL\n#endif\n\n#if SANITIZER_INTERCEPT_PTHREAD_MUTEXATTR_GETPRIOCEILING\nINTERCEPTOR_PTHREAD_MUTEXATTR_GET(prioceiling, sizeof(int))\n#define INIT_PTHREAD_MUTEXATTR_GETPRIOCEILING \\\n  COMMON_INTERCEPT_FUNCTION(pthread_mutexattr_getprioceiling);\n#else\n#define INIT_PTHREAD_MUTEXATTR_GETPRIOCEILING\n#endif\n\n#if SANITIZER_INTERCEPT_PTHREAD_MUTEXATTR_GETROBUST\nINTERCEPTOR_PTHREAD_MUTEXATTR_GET(robust, sizeof(int))\n#define INIT_PTHREAD_MUTEXATTR_GETROBUST \\\n  COMMON_INTERCEPT_FUNCTION(pthread_mutexattr_getrobust);\n#else\n#define INIT_PTHREAD_MUTEXATTR_GETROBUST\n#endif\n\n#if SANITIZER_INTERCEPT_PTHREAD_MUTEXATTR_GETROBUST_NP\nINTERCEPTOR_PTHREAD_MUTEXATTR_GET(robust_np, sizeof(int))\n#define INIT_PTHREAD_MUTEXATTR_GETROBUST_NP \\\n  COMMON_INTERCEPT_FUNCTION(pthread_mutexattr_getrobust_np);\n#else\n#define INIT_PTHREAD_MUTEXATTR_GETROBUST_NP\n#endif\n\n#if SANITIZER_INTERCEPT_PTHREAD_RWLOCKATTR_GETPSHARED\nINTERCEPTOR_PTHREAD_RWLOCKATTR_GET(pshared, sizeof(int))\n#define INIT_PTHREAD_RWLOCKATTR_GETPSHARED \\\n  COMMON_INTERCEPT_FUNCTION(pthread_rwlockattr_getpshared);\n#else\n#define INIT_PTHREAD_RWLOCKATTR_GETPSHARED\n#endif\n\n#if SANITIZER_INTERCEPT_PTHREAD_RWLOCKATTR_GETKIND_NP\nINTERCEPTOR_PTHREAD_RWLOCKATTR_GET(kind_np, sizeof(int))\n#define INIT_PTHREAD_RWLOCKATTR_GETKIND_NP \\\n  COMMON_INTERCEPT_FUNCTION(pthread_rwlockattr_getkind_np);\n#else\n#define INIT_PTHREAD_RWLOCKATTR_GETKIND_NP\n#endif\n\n#if SANITIZER_INTERCEPT_PTHREAD_CONDATTR_GETPSHARED\nINTERCEPTOR_PTHREAD_CONDATTR_GET(pshared, sizeof(int))\n#define INIT_PTHREAD_CONDATTR_GETPSHARED \\\n  COMMON_INTERCEPT_FUNCTION(pthread_condattr_getpshared);\n#else\n#define INIT_PTHREAD_CONDATTR_GETPSHARED\n#endif\n\n#if SANITIZER_INTERCEPT_PTHREAD_CONDATTR_GETCLOCK\nINTERCEPTOR_PTHREAD_CONDATTR_GET(clock, sizeof(int))\n#define INIT_PTHREAD_CONDATTR_GETCLOCK \\\n  COMMON_INTERCEPT_FUNCTION(pthread_condattr_getclock);\n#else\n#define INIT_PTHREAD_CONDATTR_GETCLOCK\n#endif\n\n#if SANITIZER_INTERCEPT_PTHREAD_BARRIERATTR_GETPSHARED\nINTERCEPTOR_PTHREAD_BARRIERATTR_GET(pshared, sizeof(int)) // !mac !android\n#define INIT_PTHREAD_BARRIERATTR_GETPSHARED \\\n  COMMON_INTERCEPT_FUNCTION(pthread_barrierattr_getpshared);\n#else\n#define INIT_PTHREAD_BARRIERATTR_GETPSHARED\n#endif\n\n#if SANITIZER_INTERCEPT_TMPNAM\nINTERCEPTOR(char *, tmpnam, char *s) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, tmpnam, s);\n  char *res = REAL(tmpnam)(s);\n  if (res) {\n    if (s)\n      // FIXME: under ASan the call below may write to freed memory and corrupt\n      // its metadata. See\n      // https://github.com/google/sanitizers/issues/321.\n      COMMON_INTERCEPTOR_WRITE_RANGE(ctx, s, REAL(strlen)(s) + 1);\n    else\n      COMMON_INTERCEPTOR_INITIALIZE_RANGE(res, REAL(strlen)(res) + 1);\n  }\n  return res;\n}\n#define INIT_TMPNAM COMMON_INTERCEPT_FUNCTION(tmpnam);\n#else\n#define INIT_TMPNAM\n#endif\n\n#if SANITIZER_INTERCEPT_TMPNAM_R\nINTERCEPTOR(char *, tmpnam_r, char *s) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, tmpnam_r, s);\n  // FIXME: under ASan the call below may write to freed memory and corrupt\n  // its metadata. See\n  // https://github.com/google/sanitizers/issues/321.\n  char *res = REAL(tmpnam_r)(s);\n  if (res && s) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, s, REAL(strlen)(s) + 1);\n  return res;\n}\n#define INIT_TMPNAM_R COMMON_INTERCEPT_FUNCTION(tmpnam_r);\n#else\n#define INIT_TMPNAM_R\n#endif\n\n#if SANITIZER_INTERCEPT_PTSNAME\nINTERCEPTOR(char *, ptsname, int fd) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, ptsname, fd);\n  char *res = REAL(ptsname)(fd);\n  if (res != nullptr)\n    COMMON_INTERCEPTOR_INITIALIZE_RANGE(res, REAL(strlen)(res) + 1);\n  return res;\n}\n#define INIT_PTSNAME COMMON_INTERCEPT_FUNCTION(ptsname);\n#else\n#define INIT_PTSNAME\n#endif\n\n#if SANITIZER_INTERCEPT_PTSNAME_R\nINTERCEPTOR(int, ptsname_r, int fd, char *name, SIZE_T namesize) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, ptsname_r, fd, name, namesize);\n  int res = REAL(ptsname_r)(fd, name, namesize);\n  if (res == 0)\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, name, REAL(strlen)(name) + 1);\n  return res;\n}\n#define INIT_PTSNAME_R COMMON_INTERCEPT_FUNCTION(ptsname_r);\n#else\n#define INIT_PTSNAME_R\n#endif\n\n#if SANITIZER_INTERCEPT_TTYNAME\nINTERCEPTOR(char *, ttyname, int fd) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, ttyname, fd);\n  char *res = REAL(ttyname)(fd);\n  if (res != nullptr)\n    COMMON_INTERCEPTOR_INITIALIZE_RANGE(res, REAL(strlen)(res) + 1);\n  return res;\n}\n#define INIT_TTYNAME COMMON_INTERCEPT_FUNCTION(ttyname);\n#else\n#define INIT_TTYNAME\n#endif\n\n#if SANITIZER_INTERCEPT_TTYNAME_R\nINTERCEPTOR(int, ttyname_r, int fd, char *name, SIZE_T namesize) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, ttyname_r, fd, name, namesize);\n  int res = REAL(ttyname_r)(fd, name, namesize);\n  if (res == 0)\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, name, REAL(strlen)(name) + 1);\n  return res;\n}\n#define INIT_TTYNAME_R COMMON_INTERCEPT_FUNCTION(ttyname_r);\n#else\n#define INIT_TTYNAME_R\n#endif\n\n#if SANITIZER_INTERCEPT_TEMPNAM\nINTERCEPTOR(char *, tempnam, char *dir, char *pfx) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, tempnam, dir, pfx);\n  if (dir) COMMON_INTERCEPTOR_READ_RANGE(ctx, dir, REAL(strlen)(dir) + 1);\n  if (pfx) COMMON_INTERCEPTOR_READ_RANGE(ctx, pfx, REAL(strlen)(pfx) + 1);\n  char *res = REAL(tempnam)(dir, pfx);\n  if (res) COMMON_INTERCEPTOR_INITIALIZE_RANGE(res, REAL(strlen)(res) + 1);\n  return res;\n}\n#define INIT_TEMPNAM COMMON_INTERCEPT_FUNCTION(tempnam);\n#else\n#define INIT_TEMPNAM\n#endif\n\n#if SANITIZER_INTERCEPT_PTHREAD_SETNAME_NP && !SANITIZER_NETBSD\nINTERCEPTOR(int, pthread_setname_np, uptr thread, const char *name) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, pthread_setname_np, thread, name);\n  COMMON_INTERCEPTOR_READ_STRING(ctx, name, 0);\n  COMMON_INTERCEPTOR_SET_PTHREAD_NAME(ctx, thread, name);\n  return REAL(pthread_setname_np)(thread, name);\n}\n#define INIT_PTHREAD_SETNAME_NP COMMON_INTERCEPT_FUNCTION(pthread_setname_np);\n#elif SANITIZER_INTERCEPT_PTHREAD_SETNAME_NP && SANITIZER_NETBSD\nINTERCEPTOR(int, pthread_setname_np, uptr thread, const char *name, void *arg) {\n  void *ctx;\n  char newname[32]; // PTHREAD_MAX_NAMELEN_NP=32\n  COMMON_INTERCEPTOR_ENTER(ctx, pthread_setname_np, thread, name, arg);\n  COMMON_INTERCEPTOR_READ_STRING(ctx, name, 0);\n  internal_snprintf(newname, sizeof(newname), name, arg);\n  COMMON_INTERCEPTOR_SET_PTHREAD_NAME(ctx, thread, newname);\n  return REAL(pthread_setname_np)(thread, name, arg);\n}\n#define INIT_PTHREAD_SETNAME_NP COMMON_INTERCEPT_FUNCTION(pthread_setname_np);\n#else\n#define INIT_PTHREAD_SETNAME_NP\n#endif\n\n#if SANITIZER_INTERCEPT_PTHREAD_GETNAME_NP\nINTERCEPTOR(int, pthread_getname_np, uptr thread, char *name, SIZE_T len) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, pthread_getname_np, thread, name, len);\n  int res = REAL(pthread_getname_np)(thread, name, len);\n  if (!res)\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, name, internal_strnlen(name, len) + 1);\n  return res;\n}\n#define INIT_PTHREAD_GETNAME_NP COMMON_INTERCEPT_FUNCTION(pthread_getname_np);\n#else\n#define INIT_PTHREAD_GETNAME_NP\n#endif\n\n#if SANITIZER_INTERCEPT_SINCOS\nINTERCEPTOR(void, sincos, double x, double *sin, double *cos) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, sincos, x, sin, cos);\n  // FIXME: under ASan the call below may write to freed memory and corrupt\n  // its metadata. See\n  // https://github.com/google/sanitizers/issues/321.\n  REAL(sincos)(x, sin, cos);\n  if (sin) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, sin, sizeof(*sin));\n  if (cos) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, cos, sizeof(*cos));\n}\nINTERCEPTOR(void, sincosf, float x, float *sin, float *cos) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, sincosf, x, sin, cos);\n  // FIXME: under ASan the call below may write to freed memory and corrupt\n  // its metadata. See\n  // https://github.com/google/sanitizers/issues/321.\n  REAL(sincosf)(x, sin, cos);\n  if (sin) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, sin, sizeof(*sin));\n  if (cos) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, cos, sizeof(*cos));\n}\nINTERCEPTOR(void, sincosl, long double x, long double *sin, long double *cos) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, sincosl, x, sin, cos);\n  // FIXME: under ASan the call below may write to freed memory and corrupt\n  // its metadata. See\n  // https://github.com/google/sanitizers/issues/321.\n  REAL(sincosl)(x, sin, cos);\n  if (sin) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, sin, sizeof(*sin));\n  if (cos) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, cos, sizeof(*cos));\n}\n#define INIT_SINCOS                   \\\n  COMMON_INTERCEPT_FUNCTION(sincos);  \\\n  COMMON_INTERCEPT_FUNCTION(sincosf); \\\n  COMMON_INTERCEPT_FUNCTION_LDBL(sincosl);\n#else\n#define INIT_SINCOS\n#endif\n\n#if SANITIZER_INTERCEPT_REMQUO\nINTERCEPTOR(double, remquo, double x, double y, int *quo) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, remquo, x, y, quo);\n  // FIXME: under ASan the call below may write to freed memory and corrupt\n  // its metadata. See\n  // https://github.com/google/sanitizers/issues/321.\n  double res = REAL(remquo)(x, y, quo);\n  if (quo) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, quo, sizeof(*quo));\n  return res;\n}\nINTERCEPTOR(float, remquof, float x, float y, int *quo) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, remquof, x, y, quo);\n  // FIXME: under ASan the call below may write to freed memory and corrupt\n  // its metadata. See\n  // https://github.com/google/sanitizers/issues/321.\n  float res = REAL(remquof)(x, y, quo);\n  if (quo) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, quo, sizeof(*quo));\n  return res;\n}\n#define INIT_REMQUO                   \\\n  COMMON_INTERCEPT_FUNCTION(remquo);  \\\n  COMMON_INTERCEPT_FUNCTION(remquof);\n#else\n#define INIT_REMQUO\n#endif\n\n#if SANITIZER_INTERCEPT_REMQUOL\nINTERCEPTOR(long double, remquol, long double x, long double y, int *quo) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, remquol, x, y, quo);\n  // FIXME: under ASan the call below may write to freed memory and corrupt\n  // its metadata. See\n  // https://github.com/google/sanitizers/issues/321.\n  long double res = REAL(remquol)(x, y, quo);\n  if (quo) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, quo, sizeof(*quo));\n  return res;\n}\n#define INIT_REMQUOL                  \\\n  COMMON_INTERCEPT_FUNCTION_LDBL(remquol);\n#else\n#define INIT_REMQUOL\n#endif\n\n#if SANITIZER_INTERCEPT_LGAMMA\nextern int signgam;\nINTERCEPTOR(double, lgamma, double x) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, lgamma, x);\n  double res = REAL(lgamma)(x);\n  COMMON_INTERCEPTOR_WRITE_RANGE(ctx, &signgam, sizeof(signgam));\n  return res;\n}\nINTERCEPTOR(float, lgammaf, float x) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, lgammaf, x);\n  float res = REAL(lgammaf)(x);\n  COMMON_INTERCEPTOR_WRITE_RANGE(ctx, &signgam, sizeof(signgam));\n  return res;\n}\n#define INIT_LGAMMA                   \\\n  COMMON_INTERCEPT_FUNCTION(lgamma);  \\\n  COMMON_INTERCEPT_FUNCTION(lgammaf);\n#else\n#define INIT_LGAMMA\n#endif\n\n#if SANITIZER_INTERCEPT_LGAMMAL\nINTERCEPTOR(long double, lgammal, long double x) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, lgammal, x);\n  long double res = REAL(lgammal)(x);\n  COMMON_INTERCEPTOR_WRITE_RANGE(ctx, &signgam, sizeof(signgam));\n  return res;\n}\n#define INIT_LGAMMAL                  \\\n  COMMON_INTERCEPT_FUNCTION_LDBL(lgammal);\n#else\n#define INIT_LGAMMAL\n#endif\n\n#if SANITIZER_INTERCEPT_LGAMMA_R\nINTERCEPTOR(double, lgamma_r, double x, int *signp) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, lgamma_r, x, signp);\n  // FIXME: under ASan the call below may write to freed memory and corrupt\n  // its metadata. See\n  // https://github.com/google/sanitizers/issues/321.\n  double res = REAL(lgamma_r)(x, signp);\n  if (signp) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, signp, sizeof(*signp));\n  return res;\n}\nINTERCEPTOR(float, lgammaf_r, float x, int *signp) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, lgammaf_r, x, signp);\n  // FIXME: under ASan the call below may write to freed memory and corrupt\n  // its metadata. See\n  // https://github.com/google/sanitizers/issues/321.\n  float res = REAL(lgammaf_r)(x, signp);\n  if (signp) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, signp, sizeof(*signp));\n  return res;\n}\n#define INIT_LGAMMA_R                   \\\n  COMMON_INTERCEPT_FUNCTION(lgamma_r);  \\\n  COMMON_INTERCEPT_FUNCTION(lgammaf_r);\n#else\n#define INIT_LGAMMA_R\n#endif\n\n#if SANITIZER_INTERCEPT_LGAMMAL_R\nINTERCEPTOR(long double, lgammal_r, long double x, int *signp) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, lgammal_r, x, signp);\n  // FIXME: under ASan the call below may write to freed memory and corrupt\n  // its metadata. See\n  // https://github.com/google/sanitizers/issues/321.\n  long double res = REAL(lgammal_r)(x, signp);\n  if (signp) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, signp, sizeof(*signp));\n  return res;\n}\n#define INIT_LGAMMAL_R COMMON_INTERCEPT_FUNCTION_LDBL(lgammal_r);\n#else\n#define INIT_LGAMMAL_R\n#endif\n\n#if SANITIZER_INTERCEPT_DRAND48_R\nINTERCEPTOR(int, drand48_r, void *buffer, double *result) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, drand48_r, buffer, result);\n  // FIXME: under ASan the call below may write to freed memory and corrupt\n  // its metadata. See\n  // https://github.com/google/sanitizers/issues/321.\n  int res = REAL(drand48_r)(buffer, result);\n  if (result) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, result, sizeof(*result));\n  return res;\n}\nINTERCEPTOR(int, lrand48_r, void *buffer, long *result) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, lrand48_r, buffer, result);\n  // FIXME: under ASan the call below may write to freed memory and corrupt\n  // its metadata. See\n  // https://github.com/google/sanitizers/issues/321.\n  int res = REAL(lrand48_r)(buffer, result);\n  if (result) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, result, sizeof(*result));\n  return res;\n}\n#define INIT_DRAND48_R                  \\\n  COMMON_INTERCEPT_FUNCTION(drand48_r); \\\n  COMMON_INTERCEPT_FUNCTION(lrand48_r);\n#else\n#define INIT_DRAND48_R\n#endif\n\n#if SANITIZER_INTERCEPT_RAND_R\nINTERCEPTOR(int, rand_r, unsigned *seedp) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, rand_r, seedp);\n  COMMON_INTERCEPTOR_READ_RANGE(ctx, seedp, sizeof(*seedp));\n  return REAL(rand_r)(seedp);\n}\n#define INIT_RAND_R COMMON_INTERCEPT_FUNCTION(rand_r);\n#else\n#define INIT_RAND_R\n#endif\n\n#if SANITIZER_INTERCEPT_GETLINE\nINTERCEPTOR(SSIZE_T, getline, char **lineptr, SIZE_T *n, void *stream) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, getline, lineptr, n, stream);\n  // FIXME: under ASan the call below may write to freed memory and corrupt\n  // its metadata. See\n  // https://github.com/google/sanitizers/issues/321.\n  SSIZE_T res = REAL(getline)(lineptr, n, stream);\n  if (res > 0) {\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, lineptr, sizeof(*lineptr));\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, n, sizeof(*n));\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, *lineptr, res + 1);\n  }\n  return res;\n}\n\n// FIXME: under ASan the call below may write to freed memory and corrupt its\n// metadata. See\n// https://github.com/google/sanitizers/issues/321.\n#define GETDELIM_INTERCEPTOR_IMPL(vname)                                       \\\n  {                                                                            \\\n    void *ctx;                                                                 \\\n    COMMON_INTERCEPTOR_ENTER(ctx, vname, lineptr, n, delim, stream);           \\\n    SSIZE_T res = REAL(vname)(lineptr, n, delim, stream);                      \\\n    if (res > 0) {                                                             \\\n      COMMON_INTERCEPTOR_WRITE_RANGE(ctx, lineptr, sizeof(*lineptr));          \\\n      COMMON_INTERCEPTOR_WRITE_RANGE(ctx, n, sizeof(*n));                      \\\n      COMMON_INTERCEPTOR_WRITE_RANGE(ctx, *lineptr, res + 1);                  \\\n    }                                                                          \\\n    return res;                                                                \\\n  }\n\nINTERCEPTOR(SSIZE_T, __getdelim, char **lineptr, SIZE_T *n, int delim,\n            void *stream)\nGETDELIM_INTERCEPTOR_IMPL(__getdelim)\n\n// There's no __getdelim() on FreeBSD so we supply the getdelim() interceptor\n// with its own body.\nINTERCEPTOR(SSIZE_T, getdelim, char **lineptr, SIZE_T *n, int delim,\n            void *stream)\nGETDELIM_INTERCEPTOR_IMPL(getdelim)\n\n#define INIT_GETLINE                     \\\n  COMMON_INTERCEPT_FUNCTION(getline);    \\\n  COMMON_INTERCEPT_FUNCTION(__getdelim); \\\n  COMMON_INTERCEPT_FUNCTION(getdelim);\n#else\n#define INIT_GETLINE\n#endif\n\n#if SANITIZER_INTERCEPT_ICONV\nINTERCEPTOR(SIZE_T, iconv, void *cd, char **inbuf, SIZE_T *inbytesleft,\n            char **outbuf, SIZE_T *outbytesleft) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, iconv, cd, inbuf, inbytesleft, outbuf,\n                           outbytesleft);\n  if (inbytesleft)\n    COMMON_INTERCEPTOR_READ_RANGE(ctx, inbytesleft, sizeof(*inbytesleft));\n  if (inbuf && inbytesleft)\n    COMMON_INTERCEPTOR_READ_RANGE(ctx, *inbuf, *inbytesleft);\n  if (outbytesleft)\n    COMMON_INTERCEPTOR_READ_RANGE(ctx, outbytesleft, sizeof(*outbytesleft));\n  void *outbuf_orig = outbuf ? *outbuf : nullptr;\n  // FIXME: under ASan the call below may write to freed memory and corrupt\n  // its metadata. See\n  // https://github.com/google/sanitizers/issues/321.\n  SIZE_T res = REAL(iconv)(cd, inbuf, inbytesleft, outbuf, outbytesleft);\n  if (outbuf && *outbuf > outbuf_orig) {\n    SIZE_T sz = (char *)*outbuf - (char *)outbuf_orig;\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, outbuf_orig, sz);\n  }\n  return res;\n}\n#define INIT_ICONV COMMON_INTERCEPT_FUNCTION(iconv);\n#else\n#define INIT_ICONV\n#endif\n\n#if SANITIZER_INTERCEPT_TIMES\nINTERCEPTOR(__sanitizer_clock_t, times, void *tms) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, times, tms);\n  // FIXME: under ASan the call below may write to freed memory and corrupt\n  // its metadata. See\n  // https://github.com/google/sanitizers/issues/321.\n  __sanitizer_clock_t res = REAL(times)(tms);\n  if (res != (__sanitizer_clock_t)-1 && tms)\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, tms, struct_tms_sz);\n  return res;\n}\n#define INIT_TIMES COMMON_INTERCEPT_FUNCTION(times);\n#else\n#define INIT_TIMES\n#endif\n\n#if SANITIZER_INTERCEPT_TLS_GET_ADDR\n#if !SANITIZER_S390\n#define INIT_TLS_GET_ADDR COMMON_INTERCEPT_FUNCTION(__tls_get_addr)\n// If you see any crashes around this functions, there are 2 known issues with\n// it: 1. __tls_get_addr can be called with mis-aligned stack due to:\n// https://gcc.gnu.org/bugzilla/show_bug.cgi?id=58066\n// 2. It can be called recursively if sanitizer code uses __tls_get_addr\n// to access thread local variables (it should not happen normally,\n// because sanitizers use initial-exec tls model).\nINTERCEPTOR(void *, __tls_get_addr, void *arg) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, __tls_get_addr, arg);\n  void *res = REAL(__tls_get_addr)(arg);\n  uptr tls_begin, tls_end;\n  COMMON_INTERCEPTOR_GET_TLS_RANGE(&tls_begin, &tls_end);\n  DTLS::DTV *dtv = DTLS_on_tls_get_addr(arg, res, tls_begin, tls_end);\n  if (dtv) {\n    // New DTLS block has been allocated.\n    COMMON_INTERCEPTOR_INITIALIZE_RANGE((void *)dtv->beg, dtv->size);\n  }\n  return res;\n}\n#if SANITIZER_PPC\n// On PowerPC, we also need to intercept __tls_get_addr_opt, which has\n// mostly the same semantics as __tls_get_addr, but its presence enables\n// some optimizations in linker (which are safe to ignore here).\nextern \"C\" __attribute__((alias(\"__interceptor___tls_get_addr\"),\n                          visibility(\"default\")))\nvoid *__tls_get_addr_opt(void *arg);\n#endif\n#else // SANITIZER_S390\n// On s390, we have to intercept two functions here:\n// - __tls_get_addr_internal, which is a glibc-internal function that is like\n//   the usual __tls_get_addr, but returns a TP-relative offset instead of\n//   a proper pointer.  It is used by dlsym for TLS symbols.\n// - __tls_get_offset, which is like the above, but also takes a GOT-relative\n//   descriptor offset as an argument instead of a pointer.  GOT address\n//   is passed in r12, so it's necessary to write it in assembly.  This is\n//   the function used by the compiler.\nextern \"C\" uptr __tls_get_offset_wrapper(void *arg, uptr (*fn)(void *arg));\n#define INIT_TLS_GET_ADDR COMMON_INTERCEPT_FUNCTION(__tls_get_offset)\nDEFINE_REAL(uptr, __tls_get_offset, void *arg)\nextern \"C\" uptr __tls_get_offset(void *arg);\nextern \"C\" uptr __interceptor___tls_get_offset(void *arg);\nINTERCEPTOR(uptr, __tls_get_addr_internal, void *arg) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, __tls_get_addr_internal, arg);\n  uptr res = __tls_get_offset_wrapper(arg, REAL(__tls_get_offset));\n  uptr tp = reinterpret_cast<uptr>(__builtin_thread_pointer());\n  void *ptr = reinterpret_cast<void *>(res + tp);\n  uptr tls_begin, tls_end;\n  COMMON_INTERCEPTOR_GET_TLS_RANGE(&tls_begin, &tls_end);\n  DTLS::DTV *dtv = DTLS_on_tls_get_addr(arg, ptr, tls_begin, tls_end);\n  if (dtv) {\n    // New DTLS block has been allocated.\n    COMMON_INTERCEPTOR_INITIALIZE_RANGE((void *)dtv->beg, dtv->size);\n  }\n  return res;\n}\n// We need a hidden symbol aliasing the above, so that we can jump\n// directly to it from the assembly below.\nextern \"C\" __attribute__((alias(\"__interceptor___tls_get_addr_internal\"),\n                          visibility(\"hidden\")))\nuptr __tls_get_addr_hidden(void *arg);\n// Now carefully intercept __tls_get_offset.\nasm(\n  \".text\\n\"\n// The __intercept_ version has to exist, so that gen_dynamic_list.py\n// exports our symbol.\n  \".weak __tls_get_offset\\n\"\n  \".type __tls_get_offset, @function\\n\"\n  \"__tls_get_offset:\\n\"\n  \".global __interceptor___tls_get_offset\\n\"\n  \".type __interceptor___tls_get_offset, @function\\n\"\n  \"__interceptor___tls_get_offset:\\n\"\n#ifdef __s390x__\n  \"la %r2, 0(%r2,%r12)\\n\"\n  \"jg __tls_get_addr_hidden\\n\"\n#else\n  \"basr %r3,0\\n\"\n  \"0: la %r2,0(%r2,%r12)\\n\"\n  \"l %r4,1f-0b(%r3)\\n\"\n  \"b 0(%r4,%r3)\\n\"\n  \"1: .long __tls_get_addr_hidden - 0b\\n\"\n#endif\n  \".size __interceptor___tls_get_offset, .-__interceptor___tls_get_offset\\n\"\n// Assembly wrapper to call REAL(__tls_get_offset)(arg)\n  \".type __tls_get_offset_wrapper, @function\\n\"\n  \"__tls_get_offset_wrapper:\\n\"\n#ifdef __s390x__\n  \"sgr %r2,%r12\\n\"\n#else\n  \"sr %r2,%r12\\n\"\n#endif\n  \"br %r3\\n\"\n  \".size __tls_get_offset_wrapper, .-__tls_get_offset_wrapper\\n\"\n);\n#endif // SANITIZER_S390\n#else\n#define INIT_TLS_GET_ADDR\n#endif\n\n#if SANITIZER_INTERCEPT_LISTXATTR\nINTERCEPTOR(SSIZE_T, listxattr, const char *path, char *list, SIZE_T size) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, listxattr, path, list, size);\n  if (path) COMMON_INTERCEPTOR_READ_RANGE(ctx, path, REAL(strlen)(path) + 1);\n  // FIXME: under ASan the call below may write to freed memory and corrupt\n  // its metadata. See\n  // https://github.com/google/sanitizers/issues/321.\n  SSIZE_T res = REAL(listxattr)(path, list, size);\n  // Here and below, size == 0 is a special case where nothing is written to the\n  // buffer, and res contains the desired buffer size.\n  if (size && res > 0 && list) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, list, res);\n  return res;\n}\nINTERCEPTOR(SSIZE_T, llistxattr, const char *path, char *list, SIZE_T size) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, llistxattr, path, list, size);\n  if (path) COMMON_INTERCEPTOR_READ_RANGE(ctx, path, REAL(strlen)(path) + 1);\n  // FIXME: under ASan the call below may write to freed memory and corrupt\n  // its metadata. See\n  // https://github.com/google/sanitizers/issues/321.\n  SSIZE_T res = REAL(llistxattr)(path, list, size);\n  if (size && res > 0 && list) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, list, res);\n  return res;\n}\nINTERCEPTOR(SSIZE_T, flistxattr, int fd, char *list, SIZE_T size) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, flistxattr, fd, list, size);\n  // FIXME: under ASan the call below may write to freed memory and corrupt\n  // its metadata. See\n  // https://github.com/google/sanitizers/issues/321.\n  SSIZE_T res = REAL(flistxattr)(fd, list, size);\n  if (size && res > 0 && list) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, list, res);\n  return res;\n}\n#define INIT_LISTXATTR                   \\\n  COMMON_INTERCEPT_FUNCTION(listxattr);  \\\n  COMMON_INTERCEPT_FUNCTION(llistxattr); \\\n  COMMON_INTERCEPT_FUNCTION(flistxattr);\n#else\n#define INIT_LISTXATTR\n#endif\n\n#if SANITIZER_INTERCEPT_GETXATTR\nINTERCEPTOR(SSIZE_T, getxattr, const char *path, const char *name, char *value,\n            SIZE_T size) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, getxattr, path, name, value, size);\n  if (path) COMMON_INTERCEPTOR_READ_RANGE(ctx, path, REAL(strlen)(path) + 1);\n  if (name) COMMON_INTERCEPTOR_READ_RANGE(ctx, name, REAL(strlen)(name) + 1);\n  // FIXME: under ASan the call below may write to freed memory and corrupt\n  // its metadata. See\n  // https://github.com/google/sanitizers/issues/321.\n  SSIZE_T res = REAL(getxattr)(path, name, value, size);\n  if (size && res > 0 && value) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, value, res);\n  return res;\n}\nINTERCEPTOR(SSIZE_T, lgetxattr, const char *path, const char *name, char *value,\n            SIZE_T size) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, lgetxattr, path, name, value, size);\n  if (path) COMMON_INTERCEPTOR_READ_RANGE(ctx, path, REAL(strlen)(path) + 1);\n  if (name) COMMON_INTERCEPTOR_READ_RANGE(ctx, name, REAL(strlen)(name) + 1);\n  // FIXME: under ASan the call below may write to freed memory and corrupt\n  // its metadata. See\n  // https://github.com/google/sanitizers/issues/321.\n  SSIZE_T res = REAL(lgetxattr)(path, name, value, size);\n  if (size && res > 0 && value) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, value, res);\n  return res;\n}\nINTERCEPTOR(SSIZE_T, fgetxattr, int fd, const char *name, char *value,\n            SIZE_T size) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, fgetxattr, fd, name, value, size);\n  if (name) COMMON_INTERCEPTOR_READ_RANGE(ctx, name, REAL(strlen)(name) + 1);\n  // FIXME: under ASan the call below may write to freed memory and corrupt\n  // its metadata. See\n  // https://github.com/google/sanitizers/issues/321.\n  SSIZE_T res = REAL(fgetxattr)(fd, name, value, size);\n  if (size && res > 0 && value) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, value, res);\n  return res;\n}\n#define INIT_GETXATTR                   \\\n  COMMON_INTERCEPT_FUNCTION(getxattr);  \\\n  COMMON_INTERCEPT_FUNCTION(lgetxattr); \\\n  COMMON_INTERCEPT_FUNCTION(fgetxattr);\n#else\n#define INIT_GETXATTR\n#endif\n\n#if SANITIZER_INTERCEPT_GETRESID\nINTERCEPTOR(int, getresuid, void *ruid, void *euid, void *suid) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, getresuid, ruid, euid, suid);\n  // FIXME: under ASan the call below may write to freed memory and corrupt\n  // its metadata. See\n  // https://github.com/google/sanitizers/issues/321.\n  int res = REAL(getresuid)(ruid, euid, suid);\n  if (res >= 0) {\n    if (ruid) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, ruid, uid_t_sz);\n    if (euid) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, euid, uid_t_sz);\n    if (suid) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, suid, uid_t_sz);\n  }\n  return res;\n}\nINTERCEPTOR(int, getresgid, void *rgid, void *egid, void *sgid) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, getresgid, rgid, egid, sgid);\n  // FIXME: under ASan the call below may write to freed memory and corrupt\n  // its metadata. See\n  // https://github.com/google/sanitizers/issues/321.\n  int res = REAL(getresgid)(rgid, egid, sgid);\n  if (res >= 0) {\n    if (rgid) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, rgid, gid_t_sz);\n    if (egid) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, egid, gid_t_sz);\n    if (sgid) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, sgid, gid_t_sz);\n  }\n  return res;\n}\n#define INIT_GETRESID                   \\\n  COMMON_INTERCEPT_FUNCTION(getresuid); \\\n  COMMON_INTERCEPT_FUNCTION(getresgid);\n#else\n#define INIT_GETRESID\n#endif\n\n#if SANITIZER_INTERCEPT_GETIFADDRS\n// As long as getifaddrs()/freeifaddrs() use calloc()/free(), we don't need to\n// intercept freeifaddrs(). If that ceases to be the case, we might need to\n// intercept it to poison the memory again.\nINTERCEPTOR(int, getifaddrs, __sanitizer_ifaddrs **ifap) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, getifaddrs, ifap);\n  // FIXME: under ASan the call below may write to freed memory and corrupt\n  // its metadata. See\n  // https://github.com/google/sanitizers/issues/321.\n  int res = REAL(getifaddrs)(ifap);\n  if (res == 0 && ifap) {\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, ifap, sizeof(void *));\n    __sanitizer_ifaddrs *p = *ifap;\n    while (p) {\n      COMMON_INTERCEPTOR_WRITE_RANGE(ctx, p, sizeof(__sanitizer_ifaddrs));\n      if (p->ifa_name)\n        COMMON_INTERCEPTOR_WRITE_RANGE(ctx, p->ifa_name,\n                                       REAL(strlen)(p->ifa_name) + 1);\n      if (p->ifa_addr)\n        COMMON_INTERCEPTOR_WRITE_RANGE(ctx, p->ifa_addr, struct_sockaddr_sz);\n      if (p->ifa_netmask)\n        COMMON_INTERCEPTOR_WRITE_RANGE(ctx, p->ifa_netmask, struct_sockaddr_sz);\n      // On Linux this is a union, but the other member also points to a\n      // struct sockaddr, so the following is sufficient.\n      if (p->ifa_dstaddr)\n        COMMON_INTERCEPTOR_WRITE_RANGE(ctx, p->ifa_dstaddr, struct_sockaddr_sz);\n      // FIXME(smatveev): Unpoison p->ifa_data as well.\n      p = p->ifa_next;\n    }\n  }\n  return res;\n}\n#define INIT_GETIFADDRS                  \\\n  COMMON_INTERCEPT_FUNCTION(getifaddrs);\n#else\n#define INIT_GETIFADDRS\n#endif\n\n#if SANITIZER_INTERCEPT_IF_INDEXTONAME\nINTERCEPTOR(char *, if_indextoname, unsigned int ifindex, char* ifname) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, if_indextoname, ifindex, ifname);\n  // FIXME: under ASan the call below may write to freed memory and corrupt\n  // its metadata. See\n  // https://github.com/google/sanitizers/issues/321.\n  char *res = REAL(if_indextoname)(ifindex, ifname);\n  if (res && ifname)\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, ifname, REAL(strlen)(ifname) + 1);\n  return res;\n}\nINTERCEPTOR(unsigned int, if_nametoindex, const char* ifname) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, if_nametoindex, ifname);\n  if (ifname)\n    COMMON_INTERCEPTOR_READ_RANGE(ctx, ifname, REAL(strlen)(ifname) + 1);\n  return REAL(if_nametoindex)(ifname);\n}\n#define INIT_IF_INDEXTONAME                  \\\n  COMMON_INTERCEPT_FUNCTION(if_indextoname); \\\n  COMMON_INTERCEPT_FUNCTION(if_nametoindex);\n#else\n#define INIT_IF_INDEXTONAME\n#endif\n\n#if SANITIZER_INTERCEPT_CAPGET\nINTERCEPTOR(int, capget, void *hdrp, void *datap) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, capget, hdrp, datap);\n  if (hdrp)\n    COMMON_INTERCEPTOR_READ_RANGE(ctx, hdrp, __user_cap_header_struct_sz);\n  // FIXME: under ASan the call below may write to freed memory and corrupt\n  // its metadata. See\n  // https://github.com/google/sanitizers/issues/321.\n  int res = REAL(capget)(hdrp, datap);\n  if (res == 0 && datap)\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, datap, __user_cap_data_struct_sz);\n  // We can also return -1 and write to hdrp->version if the version passed in\n  // hdrp->version is unsupported. But that's not a trivial condition to check,\n  // and anyway COMMON_INTERCEPTOR_READ_RANGE protects us to some extent.\n  return res;\n}\nINTERCEPTOR(int, capset, void *hdrp, const void *datap) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, capset, hdrp, datap);\n  if (hdrp)\n    COMMON_INTERCEPTOR_READ_RANGE(ctx, hdrp, __user_cap_header_struct_sz);\n  if (datap)\n    COMMON_INTERCEPTOR_READ_RANGE(ctx, datap, __user_cap_data_struct_sz);\n  return REAL(capset)(hdrp, datap);\n}\n#define INIT_CAPGET                  \\\n  COMMON_INTERCEPT_FUNCTION(capget); \\\n  COMMON_INTERCEPT_FUNCTION(capset);\n#else\n#define INIT_CAPGET\n#endif\n\n#if SANITIZER_INTERCEPT_AEABI_MEM\nINTERCEPTOR(void *, __aeabi_memmove, void *to, const void *from, uptr size) {\n  void *ctx;\n  COMMON_INTERCEPTOR_MEMMOVE_IMPL(ctx, to, from, size);\n}\n\nINTERCEPTOR(void *, __aeabi_memmove4, void *to, const void *from, uptr size) {\n  void *ctx;\n  COMMON_INTERCEPTOR_MEMMOVE_IMPL(ctx, to, from, size);\n}\n\nINTERCEPTOR(void *, __aeabi_memmove8, void *to, const void *from, uptr size) {\n  void *ctx;\n  COMMON_INTERCEPTOR_MEMMOVE_IMPL(ctx, to, from, size);\n}\n\nINTERCEPTOR(void *, __aeabi_memcpy, void *to, const void *from, uptr size) {\n  void *ctx;\n  COMMON_INTERCEPTOR_MEMCPY_IMPL(ctx, to, from, size);\n}\n\nINTERCEPTOR(void *, __aeabi_memcpy4, void *to, const void *from, uptr size) {\n  void *ctx;\n  COMMON_INTERCEPTOR_MEMCPY_IMPL(ctx, to, from, size);\n}\n\nINTERCEPTOR(void *, __aeabi_memcpy8, void *to, const void *from, uptr size) {\n  void *ctx;\n  COMMON_INTERCEPTOR_MEMCPY_IMPL(ctx, to, from, size);\n}\n\n// Note the argument order.\nINTERCEPTOR(void *, __aeabi_memset, void *block, uptr size, int c) {\n  void *ctx;\n  COMMON_INTERCEPTOR_MEMSET_IMPL(ctx, block, c, size);\n}\n\nINTERCEPTOR(void *, __aeabi_memset4, void *block, uptr size, int c) {\n  void *ctx;\n  COMMON_INTERCEPTOR_MEMSET_IMPL(ctx, block, c, size);\n}\n\nINTERCEPTOR(void *, __aeabi_memset8, void *block, uptr size, int c) {\n  void *ctx;\n  COMMON_INTERCEPTOR_MEMSET_IMPL(ctx, block, c, size);\n}\n\nINTERCEPTOR(void *, __aeabi_memclr, void *block, uptr size) {\n  void *ctx;\n  COMMON_INTERCEPTOR_MEMSET_IMPL(ctx, block, 0, size);\n}\n\nINTERCEPTOR(void *, __aeabi_memclr4, void *block, uptr size) {\n  void *ctx;\n  COMMON_INTERCEPTOR_MEMSET_IMPL(ctx, block, 0, size);\n}\n\nINTERCEPTOR(void *, __aeabi_memclr8, void *block, uptr size) {\n  void *ctx;\n  COMMON_INTERCEPTOR_MEMSET_IMPL(ctx, block, 0, size);\n}\n\n#define INIT_AEABI_MEM                         \\\n  COMMON_INTERCEPT_FUNCTION(__aeabi_memmove);  \\\n  COMMON_INTERCEPT_FUNCTION(__aeabi_memmove4); \\\n  COMMON_INTERCEPT_FUNCTION(__aeabi_memmove8); \\\n  COMMON_INTERCEPT_FUNCTION(__aeabi_memcpy);   \\\n  COMMON_INTERCEPT_FUNCTION(__aeabi_memcpy4);  \\\n  COMMON_INTERCEPT_FUNCTION(__aeabi_memcpy8);  \\\n  COMMON_INTERCEPT_FUNCTION(__aeabi_memset);   \\\n  COMMON_INTERCEPT_FUNCTION(__aeabi_memset4);  \\\n  COMMON_INTERCEPT_FUNCTION(__aeabi_memset8);  \\\n  COMMON_INTERCEPT_FUNCTION(__aeabi_memclr);   \\\n  COMMON_INTERCEPT_FUNCTION(__aeabi_memclr4);  \\\n  COMMON_INTERCEPT_FUNCTION(__aeabi_memclr8);\n#else\n#define INIT_AEABI_MEM\n#endif  // SANITIZER_INTERCEPT_AEABI_MEM\n\n#if SANITIZER_INTERCEPT___BZERO\nINTERCEPTOR(void *, __bzero, void *block, uptr size) {\n  void *ctx;\n  COMMON_INTERCEPTOR_MEMSET_IMPL(ctx, block, 0, size);\n}\n#define INIT___BZERO COMMON_INTERCEPT_FUNCTION(__bzero);\n#else\n#define INIT___BZERO\n#endif  // SANITIZER_INTERCEPT___BZERO\n\n#if SANITIZER_INTERCEPT_BZERO\nINTERCEPTOR(void *, bzero, void *block, uptr size) {\n  void *ctx;\n  COMMON_INTERCEPTOR_MEMSET_IMPL(ctx, block, 0, size);\n}\n#define INIT_BZERO COMMON_INTERCEPT_FUNCTION(bzero);\n#else\n#define INIT_BZERO\n#endif  // SANITIZER_INTERCEPT_BZERO\n\n#if SANITIZER_INTERCEPT_FTIME\nINTERCEPTOR(int, ftime, __sanitizer_timeb *tp) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, ftime, tp);\n  // FIXME: under ASan the call below may write to freed memory and corrupt\n  // its metadata. See\n  // https://github.com/google/sanitizers/issues/321.\n  int res = REAL(ftime)(tp);\n  if (tp)\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, tp, sizeof(*tp));\n  return res;\n}\n#define INIT_FTIME COMMON_INTERCEPT_FUNCTION(ftime);\n#else\n#define INIT_FTIME\n#endif  // SANITIZER_INTERCEPT_FTIME\n\n#if SANITIZER_INTERCEPT_XDR\nINTERCEPTOR(void, xdrmem_create, __sanitizer_XDR *xdrs, uptr addr,\n            unsigned size, int op) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, xdrmem_create, xdrs, addr, size, op);\n  // FIXME: under ASan the call below may write to freed memory and corrupt\n  // its metadata. See\n  // https://github.com/google/sanitizers/issues/321.\n  REAL(xdrmem_create)(xdrs, addr, size, op);\n  COMMON_INTERCEPTOR_WRITE_RANGE(ctx, xdrs, sizeof(*xdrs));\n  if (op == __sanitizer_XDR_ENCODE) {\n    // It's not obvious how much data individual xdr_ routines write.\n    // Simply unpoison the entire target buffer in advance.\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, (void *)addr, size);\n  }\n}\n\nINTERCEPTOR(void, xdrstdio_create, __sanitizer_XDR *xdrs, void *file, int op) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, xdrstdio_create, xdrs, file, op);\n  // FIXME: under ASan the call below may write to freed memory and corrupt\n  // its metadata. See\n  // https://github.com/google/sanitizers/issues/321.\n  REAL(xdrstdio_create)(xdrs, file, op);\n  COMMON_INTERCEPTOR_WRITE_RANGE(ctx, xdrs, sizeof(*xdrs));\n}\n\n// FIXME: under ASan the call below may write to freed memory and corrupt\n// its metadata. See\n// https://github.com/google/sanitizers/issues/321.\n#define XDR_INTERCEPTOR(F, T)                             \\\n  INTERCEPTOR(int, F, __sanitizer_XDR *xdrs, T *p) {      \\\n    void *ctx;                                            \\\n    COMMON_INTERCEPTOR_ENTER(ctx, F, xdrs, p);            \\\n    if (p && xdrs->x_op == __sanitizer_XDR_ENCODE)        \\\n      COMMON_INTERCEPTOR_READ_RANGE(ctx, p, sizeof(*p));  \\\n    int res = REAL(F)(xdrs, p);                           \\\n    if (res && p && xdrs->x_op == __sanitizer_XDR_DECODE) \\\n      COMMON_INTERCEPTOR_WRITE_RANGE(ctx, p, sizeof(*p)); \\\n    return res;                                           \\\n  }\n\nXDR_INTERCEPTOR(xdr_short, short)\nXDR_INTERCEPTOR(xdr_u_short, unsigned short)\nXDR_INTERCEPTOR(xdr_int, int)\nXDR_INTERCEPTOR(xdr_u_int, unsigned)\nXDR_INTERCEPTOR(xdr_long, long)\nXDR_INTERCEPTOR(xdr_u_long, unsigned long)\nXDR_INTERCEPTOR(xdr_hyper, long long)\nXDR_INTERCEPTOR(xdr_u_hyper, unsigned long long)\nXDR_INTERCEPTOR(xdr_longlong_t, long long)\nXDR_INTERCEPTOR(xdr_u_longlong_t, unsigned long long)\nXDR_INTERCEPTOR(xdr_int8_t, u8)\nXDR_INTERCEPTOR(xdr_uint8_t, u8)\nXDR_INTERCEPTOR(xdr_int16_t, u16)\nXDR_INTERCEPTOR(xdr_uint16_t, u16)\nXDR_INTERCEPTOR(xdr_int32_t, u32)\nXDR_INTERCEPTOR(xdr_uint32_t, u32)\nXDR_INTERCEPTOR(xdr_int64_t, u64)\nXDR_INTERCEPTOR(xdr_uint64_t, u64)\nXDR_INTERCEPTOR(xdr_quad_t, long long)\nXDR_INTERCEPTOR(xdr_u_quad_t, unsigned long long)\nXDR_INTERCEPTOR(xdr_bool, bool)\nXDR_INTERCEPTOR(xdr_enum, int)\nXDR_INTERCEPTOR(xdr_char, char)\nXDR_INTERCEPTOR(xdr_u_char, unsigned char)\nXDR_INTERCEPTOR(xdr_float, float)\nXDR_INTERCEPTOR(xdr_double, double)\n\n// FIXME: intercept xdr_array, opaque, union, vector, reference, pointer,\n// wrapstring, sizeof\n\nINTERCEPTOR(int, xdr_bytes, __sanitizer_XDR *xdrs, char **p, unsigned *sizep,\n            unsigned maxsize) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, xdr_bytes, xdrs, p, sizep, maxsize);\n  if (p && sizep && xdrs->x_op == __sanitizer_XDR_ENCODE) {\n    COMMON_INTERCEPTOR_READ_RANGE(ctx, p, sizeof(*p));\n    COMMON_INTERCEPTOR_READ_RANGE(ctx, sizep, sizeof(*sizep));\n    COMMON_INTERCEPTOR_READ_RANGE(ctx, *p, *sizep);\n  }\n  // FIXME: under ASan the call below may write to freed memory and corrupt\n  // its metadata. See\n  // https://github.com/google/sanitizers/issues/321.\n  int res = REAL(xdr_bytes)(xdrs, p, sizep, maxsize);\n  if (p && sizep && xdrs->x_op == __sanitizer_XDR_DECODE) {\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, p, sizeof(*p));\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, sizep, sizeof(*sizep));\n    if (res && *p && *sizep) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, *p, *sizep);\n  }\n  return res;\n}\n\nINTERCEPTOR(int, xdr_string, __sanitizer_XDR *xdrs, char **p,\n            unsigned maxsize) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, xdr_string, xdrs, p, maxsize);\n  if (p && xdrs->x_op == __sanitizer_XDR_ENCODE) {\n    COMMON_INTERCEPTOR_READ_RANGE(ctx, p, sizeof(*p));\n    COMMON_INTERCEPTOR_READ_RANGE(ctx, *p, REAL(strlen)(*p) + 1);\n  }\n  // FIXME: under ASan the call below may write to freed memory and corrupt\n  // its metadata. See\n  // https://github.com/google/sanitizers/issues/321.\n  int res = REAL(xdr_string)(xdrs, p, maxsize);\n  if (p && xdrs->x_op == __sanitizer_XDR_DECODE) {\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, p, sizeof(*p));\n    if (res && *p)\n      COMMON_INTERCEPTOR_WRITE_RANGE(ctx, *p, REAL(strlen)(*p) + 1);\n  }\n  return res;\n}\n\n#define INIT_XDR                               \\\n  COMMON_INTERCEPT_FUNCTION(xdrmem_create);    \\\n  COMMON_INTERCEPT_FUNCTION(xdrstdio_create);  \\\n  COMMON_INTERCEPT_FUNCTION(xdr_short);        \\\n  COMMON_INTERCEPT_FUNCTION(xdr_u_short);      \\\n  COMMON_INTERCEPT_FUNCTION(xdr_int);          \\\n  COMMON_INTERCEPT_FUNCTION(xdr_u_int);        \\\n  COMMON_INTERCEPT_FUNCTION(xdr_long);         \\\n  COMMON_INTERCEPT_FUNCTION(xdr_u_long);       \\\n  COMMON_INTERCEPT_FUNCTION(xdr_hyper);        \\\n  COMMON_INTERCEPT_FUNCTION(xdr_u_hyper);      \\\n  COMMON_INTERCEPT_FUNCTION(xdr_longlong_t);   \\\n  COMMON_INTERCEPT_FUNCTION(xdr_u_longlong_t); \\\n  COMMON_INTERCEPT_FUNCTION(xdr_int8_t);       \\\n  COMMON_INTERCEPT_FUNCTION(xdr_uint8_t);      \\\n  COMMON_INTERCEPT_FUNCTION(xdr_int16_t);      \\\n  COMMON_INTERCEPT_FUNCTION(xdr_uint16_t);     \\\n  COMMON_INTERCEPT_FUNCTION(xdr_int32_t);      \\\n  COMMON_INTERCEPT_FUNCTION(xdr_uint32_t);     \\\n  COMMON_INTERCEPT_FUNCTION(xdr_int64_t);      \\\n  COMMON_INTERCEPT_FUNCTION(xdr_uint64_t);     \\\n  COMMON_INTERCEPT_FUNCTION(xdr_quad_t);       \\\n  COMMON_INTERCEPT_FUNCTION(xdr_u_quad_t);     \\\n  COMMON_INTERCEPT_FUNCTION(xdr_bool);         \\\n  COMMON_INTERCEPT_FUNCTION(xdr_enum);         \\\n  COMMON_INTERCEPT_FUNCTION(xdr_char);         \\\n  COMMON_INTERCEPT_FUNCTION(xdr_u_char);       \\\n  COMMON_INTERCEPT_FUNCTION(xdr_float);        \\\n  COMMON_INTERCEPT_FUNCTION(xdr_double);       \\\n  COMMON_INTERCEPT_FUNCTION(xdr_bytes);        \\\n  COMMON_INTERCEPT_FUNCTION(xdr_string);\n#else\n#define INIT_XDR\n#endif  // SANITIZER_INTERCEPT_XDR\n\n#if SANITIZER_INTERCEPT_XDRREC\ntypedef int (*xdrrec_cb)(char*, char*, int);\nstruct XdrRecWrapper {\n  char *handle;\n  xdrrec_cb rd, wr;\n};\ntypedef AddrHashMap<XdrRecWrapper *, 11> XdrRecWrapMap;\nstatic XdrRecWrapMap *xdrrec_wrap_map;\n\nstatic int xdrrec_wr_wrap(char *handle, char *buf, int count) {\n  COMMON_INTERCEPTOR_UNPOISON_PARAM(3);\n  COMMON_INTERCEPTOR_INITIALIZE_RANGE(buf, count);\n  XdrRecWrapper *wrap = (XdrRecWrapper *)handle;\n  return wrap->wr(wrap->handle, buf, count);\n}\n\nstatic int xdrrec_rd_wrap(char *handle, char *buf, int count) {\n  COMMON_INTERCEPTOR_UNPOISON_PARAM(3);\n  XdrRecWrapper *wrap = (XdrRecWrapper *)handle;\n  return wrap->rd(wrap->handle, buf, count);\n}\n\n// This doesn't apply to the solaris version as it has a different function\n// signature.\nINTERCEPTOR(void, xdrrec_create, __sanitizer_XDR *xdr, unsigned sndsize,\n            unsigned rcvsize, char *handle, int (*rd)(char*, char*, int),\n            int (*wr)(char*, char*, int)) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, xdrrec_create, xdr, sndsize, rcvsize,\n                           handle, rd, wr);\n  COMMON_INTERCEPTOR_READ_RANGE(ctx, &xdr->x_op, sizeof xdr->x_op);\n\n  // We can't allocate a wrapper on the stack, as the handle is used outside\n  // this stack frame. So we put it on the heap, and keep track of it with\n  // the HashMap (keyed by x_private). When we later need to xdr_destroy,\n  // we can index the map, free the wrapper, and then clean the map entry.\n  XdrRecWrapper *wrap_data =\n      (XdrRecWrapper *)InternalAlloc(sizeof(XdrRecWrapper));\n  wrap_data->handle = handle;\n  wrap_data->rd = rd;\n  wrap_data->wr = wr;\n  if (wr)\n    wr = xdrrec_wr_wrap;\n  if (rd)\n    rd = xdrrec_rd_wrap;\n  handle = (char *)wrap_data;\n\n  REAL(xdrrec_create)(xdr, sndsize, rcvsize, handle, rd, wr);\n  COMMON_INTERCEPTOR_WRITE_RANGE(ctx, xdr, sizeof *xdr);\n\n  XdrRecWrapMap::Handle wrap(xdrrec_wrap_map, xdr->x_private, false, true);\n  *wrap = wrap_data;\n}\n\n// We have to intercept this to be able to free wrapper memory;\n// otherwise it's not necessary.\nINTERCEPTOR(void, xdr_destroy, __sanitizer_XDR *xdr) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, xdr_destroy, xdr);\n\n  XdrRecWrapMap::Handle wrap(xdrrec_wrap_map, xdr->x_private, true);\n  InternalFree(*wrap);\n  REAL(xdr_destroy)(xdr);\n}\n#define INIT_XDRREC_LINUX \\\n  static u64 xdrrec_wrap_mem[sizeof(XdrRecWrapMap) / sizeof(u64) + 1]; \\\n  xdrrec_wrap_map = new ((void *)&xdrrec_wrap_mem) XdrRecWrapMap(); \\\n  COMMON_INTERCEPT_FUNCTION(xdrrec_create); \\\n  COMMON_INTERCEPT_FUNCTION(xdr_destroy);\n#else\n#define INIT_XDRREC_LINUX\n#endif\n\n#if SANITIZER_INTERCEPT_TSEARCH\nINTERCEPTOR(void *, tsearch, void *key, void **rootp,\n            int (*compar)(const void *, const void *)) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, tsearch, key, rootp, compar);\n  // FIXME: under ASan the call below may write to freed memory and corrupt\n  // its metadata. See\n  // https://github.com/google/sanitizers/issues/321.\n  void *res = REAL(tsearch)(key, rootp, compar);\n  if (res && *(void **)res == key)\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, res, sizeof(void *));\n  return res;\n}\n#define INIT_TSEARCH COMMON_INTERCEPT_FUNCTION(tsearch);\n#else\n#define INIT_TSEARCH\n#endif\n\n#if SANITIZER_INTERCEPT_LIBIO_INTERNALS || SANITIZER_INTERCEPT_FOPEN || \\\n    SANITIZER_INTERCEPT_OPEN_MEMSTREAM\nvoid unpoison_file(__sanitizer_FILE *fp) {\n#if SANITIZER_HAS_STRUCT_FILE\n  COMMON_INTERCEPTOR_INITIALIZE_RANGE(fp, sizeof(*fp));\n#if SANITIZER_NETBSD\n  if (fp->_bf._base && fp->_bf._size > 0)\n    COMMON_INTERCEPTOR_INITIALIZE_RANGE(fp->_bf._base,\n                                        fp->_bf._size);\n#else\n  if (fp->_IO_read_base && fp->_IO_read_base < fp->_IO_read_end)\n    COMMON_INTERCEPTOR_INITIALIZE_RANGE(fp->_IO_read_base,\n                                        fp->_IO_read_end - fp->_IO_read_base);\n  if (fp->_IO_write_base && fp->_IO_write_base < fp->_IO_write_end)\n    COMMON_INTERCEPTOR_INITIALIZE_RANGE(fp->_IO_write_base,\n                                        fp->_IO_write_end - fp->_IO_write_base);\n#endif\n#endif  // SANITIZER_HAS_STRUCT_FILE\n}\n#endif\n\n#if SANITIZER_INTERCEPT_LIBIO_INTERNALS\n// These guys are called when a .c source is built with -O2.\nINTERCEPTOR(int, __uflow, __sanitizer_FILE *fp) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, __uflow, fp);\n  int res = REAL(__uflow)(fp);\n  unpoison_file(fp);\n  return res;\n}\nINTERCEPTOR(int, __underflow, __sanitizer_FILE *fp) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, __underflow, fp);\n  int res = REAL(__underflow)(fp);\n  unpoison_file(fp);\n  return res;\n}\nINTERCEPTOR(int, __overflow, __sanitizer_FILE *fp, int ch) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, __overflow, fp, ch);\n  int res = REAL(__overflow)(fp, ch);\n  unpoison_file(fp);\n  return res;\n}\nINTERCEPTOR(int, __wuflow, __sanitizer_FILE *fp) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, __wuflow, fp);\n  int res = REAL(__wuflow)(fp);\n  unpoison_file(fp);\n  return res;\n}\nINTERCEPTOR(int, __wunderflow, __sanitizer_FILE *fp) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, __wunderflow, fp);\n  int res = REAL(__wunderflow)(fp);\n  unpoison_file(fp);\n  return res;\n}\nINTERCEPTOR(int, __woverflow, __sanitizer_FILE *fp, int ch) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, __woverflow, fp, ch);\n  int res = REAL(__woverflow)(fp, ch);\n  unpoison_file(fp);\n  return res;\n}\n#define INIT_LIBIO_INTERNALS               \\\n  COMMON_INTERCEPT_FUNCTION(__uflow);      \\\n  COMMON_INTERCEPT_FUNCTION(__underflow);  \\\n  COMMON_INTERCEPT_FUNCTION(__overflow);   \\\n  COMMON_INTERCEPT_FUNCTION(__wuflow);     \\\n  COMMON_INTERCEPT_FUNCTION(__wunderflow); \\\n  COMMON_INTERCEPT_FUNCTION(__woverflow);\n#else\n#define INIT_LIBIO_INTERNALS\n#endif\n\n#if SANITIZER_INTERCEPT_FOPEN\nINTERCEPTOR(__sanitizer_FILE *, fopen, const char *path, const char *mode) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, fopen, path, mode);\n  if (path) COMMON_INTERCEPTOR_READ_RANGE(ctx, path, REAL(strlen)(path) + 1);\n  COMMON_INTERCEPTOR_READ_RANGE(ctx, mode, REAL(strlen)(mode) + 1);\n  __sanitizer_FILE *res = REAL(fopen)(path, mode);\n  COMMON_INTERCEPTOR_FILE_OPEN(ctx, res, path);\n  if (res) unpoison_file(res);\n  return res;\n}\nINTERCEPTOR(__sanitizer_FILE *, fdopen, int fd, const char *mode) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, fdopen, fd, mode);\n  COMMON_INTERCEPTOR_READ_RANGE(ctx, mode, REAL(strlen)(mode) + 1);\n  __sanitizer_FILE *res = REAL(fdopen)(fd, mode);\n  if (res) unpoison_file(res);\n  return res;\n}\nINTERCEPTOR(__sanitizer_FILE *, freopen, const char *path, const char *mode,\n            __sanitizer_FILE *fp) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, freopen, path, mode, fp);\n  if (path) COMMON_INTERCEPTOR_READ_RANGE(ctx, path, REAL(strlen)(path) + 1);\n  COMMON_INTERCEPTOR_READ_RANGE(ctx, mode, REAL(strlen)(mode) + 1);\n  COMMON_INTERCEPTOR_FILE_CLOSE(ctx, fp);\n  __sanitizer_FILE *res = REAL(freopen)(path, mode, fp);\n  COMMON_INTERCEPTOR_FILE_OPEN(ctx, res, path);\n  if (res) unpoison_file(res);\n  return res;\n}\n#define INIT_FOPEN                   \\\n  COMMON_INTERCEPT_FUNCTION(fopen);  \\\n  COMMON_INTERCEPT_FUNCTION(fdopen); \\\n  COMMON_INTERCEPT_FUNCTION(freopen);\n#else\n#define INIT_FOPEN\n#endif\n\n#if SANITIZER_INTERCEPT_FOPEN64\nINTERCEPTOR(__sanitizer_FILE *, fopen64, const char *path, const char *mode) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, fopen64, path, mode);\n  COMMON_INTERCEPTOR_READ_RANGE(ctx, path, REAL(strlen)(path) + 1);\n  COMMON_INTERCEPTOR_READ_RANGE(ctx, mode, REAL(strlen)(mode) + 1);\n  __sanitizer_FILE *res = REAL(fopen64)(path, mode);\n  COMMON_INTERCEPTOR_FILE_OPEN(ctx, res, path);\n  if (res) unpoison_file(res);\n  return res;\n}\nINTERCEPTOR(__sanitizer_FILE *, freopen64, const char *path, const char *mode,\n            __sanitizer_FILE *fp) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, freopen64, path, mode, fp);\n  if (path) COMMON_INTERCEPTOR_READ_RANGE(ctx, path, REAL(strlen)(path) + 1);\n  COMMON_INTERCEPTOR_READ_RANGE(ctx, mode, REAL(strlen)(mode) + 1);\n  COMMON_INTERCEPTOR_FILE_CLOSE(ctx, fp);\n  __sanitizer_FILE *res = REAL(freopen64)(path, mode, fp);\n  COMMON_INTERCEPTOR_FILE_OPEN(ctx, res, path);\n  if (res) unpoison_file(res);\n  return res;\n}\n#define INIT_FOPEN64                  \\\n  COMMON_INTERCEPT_FUNCTION(fopen64); \\\n  COMMON_INTERCEPT_FUNCTION(freopen64);\n#else\n#define INIT_FOPEN64\n#endif\n\n#if SANITIZER_INTERCEPT_OPEN_MEMSTREAM\nINTERCEPTOR(__sanitizer_FILE *, open_memstream, char **ptr, SIZE_T *sizeloc) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, open_memstream, ptr, sizeloc);\n  // FIXME: under ASan the call below may write to freed memory and corrupt\n  // its metadata. See\n  // https://github.com/google/sanitizers/issues/321.\n  __sanitizer_FILE *res = REAL(open_memstream)(ptr, sizeloc);\n  if (res) {\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, ptr, sizeof(*ptr));\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, sizeloc, sizeof(*sizeloc));\n    unpoison_file(res);\n    FileMetadata file = {ptr, sizeloc};\n    SetInterceptorMetadata(res, file);\n  }\n  return res;\n}\nINTERCEPTOR(__sanitizer_FILE *, open_wmemstream, wchar_t **ptr,\n            SIZE_T *sizeloc) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, open_wmemstream, ptr, sizeloc);\n  __sanitizer_FILE *res = REAL(open_wmemstream)(ptr, sizeloc);\n  if (res) {\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, ptr, sizeof(*ptr));\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, sizeloc, sizeof(*sizeloc));\n    unpoison_file(res);\n    FileMetadata file = {(char **)ptr, sizeloc};\n    SetInterceptorMetadata(res, file);\n  }\n  return res;\n}\nINTERCEPTOR(__sanitizer_FILE *, fmemopen, void *buf, SIZE_T size,\n            const char *mode) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, fmemopen, buf, size, mode);\n  // FIXME: under ASan the call below may write to freed memory and corrupt\n  // its metadata. See\n  // https://github.com/google/sanitizers/issues/321.\n  __sanitizer_FILE *res = REAL(fmemopen)(buf, size, mode);\n  if (res) unpoison_file(res);\n  return res;\n}\n#define INIT_OPEN_MEMSTREAM                   \\\n  COMMON_INTERCEPT_FUNCTION(open_memstream);  \\\n  COMMON_INTERCEPT_FUNCTION(open_wmemstream); \\\n  COMMON_INTERCEPT_FUNCTION(fmemopen);\n#else\n#define INIT_OPEN_MEMSTREAM\n#endif\n\n#if SANITIZER_INTERCEPT_OBSTACK\nstatic void initialize_obstack(__sanitizer_obstack *obstack) {\n  COMMON_INTERCEPTOR_INITIALIZE_RANGE(obstack, sizeof(*obstack));\n  if (obstack->chunk)\n    COMMON_INTERCEPTOR_INITIALIZE_RANGE(obstack->chunk,\n                                        sizeof(*obstack->chunk));\n}\n\nINTERCEPTOR(int, _obstack_begin_1, __sanitizer_obstack *obstack, int sz,\n            int align, void *(*alloc_fn)(uptr arg, uptr sz),\n            void (*free_fn)(uptr arg, void *p)) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, _obstack_begin_1, obstack, sz, align, alloc_fn,\n                           free_fn);\n  int res = REAL(_obstack_begin_1)(obstack, sz, align, alloc_fn, free_fn);\n  if (res) initialize_obstack(obstack);\n  return res;\n}\nINTERCEPTOR(int, _obstack_begin, __sanitizer_obstack *obstack, int sz,\n            int align, void *(*alloc_fn)(uptr sz), void (*free_fn)(void *p)) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, _obstack_begin, obstack, sz, align, alloc_fn,\n                           free_fn);\n  int res = REAL(_obstack_begin)(obstack, sz, align, alloc_fn, free_fn);\n  if (res) initialize_obstack(obstack);\n  return res;\n}\nINTERCEPTOR(void, _obstack_newchunk, __sanitizer_obstack *obstack, int length) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, _obstack_newchunk, obstack, length);\n  REAL(_obstack_newchunk)(obstack, length);\n  if (obstack->chunk)\n    COMMON_INTERCEPTOR_INITIALIZE_RANGE(\n        obstack->chunk, obstack->next_free - (char *)obstack->chunk);\n}\n#define INIT_OBSTACK                           \\\n  COMMON_INTERCEPT_FUNCTION(_obstack_begin_1); \\\n  COMMON_INTERCEPT_FUNCTION(_obstack_begin);   \\\n  COMMON_INTERCEPT_FUNCTION(_obstack_newchunk);\n#else\n#define INIT_OBSTACK\n#endif\n\n#if SANITIZER_INTERCEPT_FFLUSH\nINTERCEPTOR(int, fflush, __sanitizer_FILE *fp) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, fflush, fp);\n  if (fp)\n    unpoison_file(fp);\n  int res = REAL(fflush)(fp);\n  // FIXME: handle fp == NULL\n  if (fp) {\n    const FileMetadata *m = GetInterceptorMetadata(fp);\n    if (m) COMMON_INTERCEPTOR_INITIALIZE_RANGE(*m->addr, *m->size);\n  }\n  return res;\n}\n#define INIT_FFLUSH COMMON_INTERCEPT_FUNCTION(fflush);\n#else\n#define INIT_FFLUSH\n#endif\n\n#if SANITIZER_INTERCEPT_FCLOSE\nINTERCEPTOR(int, fclose, __sanitizer_FILE *fp) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, fclose, fp);\n  COMMON_INTERCEPTOR_FILE_CLOSE(ctx, fp);\n  const FileMetadata *m = GetInterceptorMetadata(fp);\n  if (fp)\n    unpoison_file(fp);\n  int res = REAL(fclose)(fp);\n  if (m) {\n    COMMON_INTERCEPTOR_INITIALIZE_RANGE(*m->addr, *m->size);\n    DeleteInterceptorMetadata(fp);\n  }\n  return res;\n}\n#define INIT_FCLOSE COMMON_INTERCEPT_FUNCTION(fclose);\n#else\n#define INIT_FCLOSE\n#endif\n\n#if SANITIZER_INTERCEPT_DLOPEN_DLCLOSE\nINTERCEPTOR(void*, dlopen, const char *filename, int flag) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER_NOIGNORE(ctx, dlopen, filename, flag);\n  if (filename) COMMON_INTERCEPTOR_READ_STRING(ctx, filename, 0);\n  COMMON_INTERCEPTOR_ON_DLOPEN(filename, flag);\n  void *res = REAL(dlopen)(filename, flag);\n  Symbolizer::GetOrInit()->InvalidateModuleList();\n  COMMON_INTERCEPTOR_LIBRARY_LOADED(filename, res);\n  return res;\n}\n\nINTERCEPTOR(int, dlclose, void *handle) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER_NOIGNORE(ctx, dlclose, handle);\n  int res = REAL(dlclose)(handle);\n  Symbolizer::GetOrInit()->InvalidateModuleList();\n  COMMON_INTERCEPTOR_LIBRARY_UNLOADED();\n  return res;\n}\n#define INIT_DLOPEN_DLCLOSE          \\\n  COMMON_INTERCEPT_FUNCTION(dlopen); \\\n  COMMON_INTERCEPT_FUNCTION(dlclose);\n#else\n#define INIT_DLOPEN_DLCLOSE\n#endif\n\n#if SANITIZER_INTERCEPT_GETPASS\nINTERCEPTOR(char *, getpass, const char *prompt) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, getpass, prompt);\n  if (prompt)\n    COMMON_INTERCEPTOR_READ_RANGE(ctx, prompt, REAL(strlen)(prompt)+1);\n  char *res = REAL(getpass)(prompt);\n  if (res) COMMON_INTERCEPTOR_INITIALIZE_RANGE(res, REAL(strlen)(res)+1);\n  return res;\n}\n\n#define INIT_GETPASS COMMON_INTERCEPT_FUNCTION(getpass);\n#else\n#define INIT_GETPASS\n#endif\n\n#if SANITIZER_INTERCEPT_TIMERFD\nINTERCEPTOR(int, timerfd_settime, int fd, int flags, void *new_value,\n            void *old_value) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, timerfd_settime, fd, flags, new_value,\n                           old_value);\n  COMMON_INTERCEPTOR_READ_RANGE(ctx, new_value, struct_itimerspec_sz);\n  int res = REAL(timerfd_settime)(fd, flags, new_value, old_value);\n  if (res != -1 && old_value)\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, old_value, struct_itimerspec_sz);\n  return res;\n}\n\nINTERCEPTOR(int, timerfd_gettime, int fd, void *curr_value) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, timerfd_gettime, fd, curr_value);\n  int res = REAL(timerfd_gettime)(fd, curr_value);\n  if (res != -1 && curr_value)\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, curr_value, struct_itimerspec_sz);\n  return res;\n}\n#define INIT_TIMERFD                          \\\n  COMMON_INTERCEPT_FUNCTION(timerfd_settime); \\\n  COMMON_INTERCEPT_FUNCTION(timerfd_gettime);\n#else\n#define INIT_TIMERFD\n#endif\n\n#if SANITIZER_INTERCEPT_MLOCKX\n// Linux kernel has a bug that leads to kernel deadlock if a process\n// maps TBs of memory and then calls mlock().\nstatic void MlockIsUnsupported() {\n  static atomic_uint8_t printed;\n  if (atomic_exchange(&printed, 1, memory_order_relaxed))\n    return;\n  VPrintf(1, \"%s ignores mlock/mlockall/munlock/munlockall\\n\",\n          SanitizerToolName);\n}\n\nINTERCEPTOR(int, mlock, const void *addr, uptr len) {\n  MlockIsUnsupported();\n  return 0;\n}\n\nINTERCEPTOR(int, munlock, const void *addr, uptr len) {\n  MlockIsUnsupported();\n  return 0;\n}\n\nINTERCEPTOR(int, mlockall, int flags) {\n  MlockIsUnsupported();\n  return 0;\n}\n\nINTERCEPTOR(int, munlockall, void) {\n  MlockIsUnsupported();\n  return 0;\n}\n\n#define INIT_MLOCKX                                                            \\\n  COMMON_INTERCEPT_FUNCTION(mlock);                                            \\\n  COMMON_INTERCEPT_FUNCTION(munlock);                                          \\\n  COMMON_INTERCEPT_FUNCTION(mlockall);                                         \\\n  COMMON_INTERCEPT_FUNCTION(munlockall);\n\n#else\n#define INIT_MLOCKX\n#endif  // SANITIZER_INTERCEPT_MLOCKX\n\n#if SANITIZER_INTERCEPT_FOPENCOOKIE\nstruct WrappedCookie {\n  void *real_cookie;\n  __sanitizer_cookie_io_functions_t real_io_funcs;\n};\n\nstatic uptr wrapped_read(void *cookie, char *buf, uptr size) {\n  COMMON_INTERCEPTOR_UNPOISON_PARAM(3);\n  WrappedCookie *wrapped_cookie = (WrappedCookie *)cookie;\n  __sanitizer_cookie_io_read real_read = wrapped_cookie->real_io_funcs.read;\n  return real_read ? real_read(wrapped_cookie->real_cookie, buf, size) : 0;\n}\n\nstatic uptr wrapped_write(void *cookie, const char *buf, uptr size) {\n  COMMON_INTERCEPTOR_UNPOISON_PARAM(3);\n  WrappedCookie *wrapped_cookie = (WrappedCookie *)cookie;\n  __sanitizer_cookie_io_write real_write = wrapped_cookie->real_io_funcs.write;\n  return real_write ? real_write(wrapped_cookie->real_cookie, buf, size) : size;\n}\n\nstatic int wrapped_seek(void *cookie, u64 *offset, int whence) {\n  COMMON_INTERCEPTOR_UNPOISON_PARAM(3);\n  COMMON_INTERCEPTOR_INITIALIZE_RANGE(offset, sizeof(*offset));\n  WrappedCookie *wrapped_cookie = (WrappedCookie *)cookie;\n  __sanitizer_cookie_io_seek real_seek = wrapped_cookie->real_io_funcs.seek;\n  return real_seek ? real_seek(wrapped_cookie->real_cookie, offset, whence)\n                   : -1;\n}\n\nstatic int wrapped_close(void *cookie) {\n  COMMON_INTERCEPTOR_UNPOISON_PARAM(1);\n  WrappedCookie *wrapped_cookie = (WrappedCookie *)cookie;\n  __sanitizer_cookie_io_close real_close = wrapped_cookie->real_io_funcs.close;\n  int res = real_close ? real_close(wrapped_cookie->real_cookie) : 0;\n  InternalFree(wrapped_cookie);\n  return res;\n}\n\nINTERCEPTOR(__sanitizer_FILE *, fopencookie, void *cookie, const char *mode,\n            __sanitizer_cookie_io_functions_t io_funcs) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, fopencookie, cookie, mode, io_funcs);\n  WrappedCookie *wrapped_cookie =\n      (WrappedCookie *)InternalAlloc(sizeof(WrappedCookie));\n  wrapped_cookie->real_cookie = cookie;\n  wrapped_cookie->real_io_funcs = io_funcs;\n  __sanitizer_FILE *res =\n      REAL(fopencookie)(wrapped_cookie, mode, {wrapped_read, wrapped_write,\n                                               wrapped_seek, wrapped_close});\n  return res;\n}\n\n#define INIT_FOPENCOOKIE COMMON_INTERCEPT_FUNCTION(fopencookie);\n#else\n#define INIT_FOPENCOOKIE\n#endif  // SANITIZER_INTERCEPT_FOPENCOOKIE\n\n#if SANITIZER_INTERCEPT_SEM\nINTERCEPTOR(int, sem_init, __sanitizer_sem_t *s, int pshared, unsigned value) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, sem_init, s, pshared, value);\n  // Workaround a bug in glibc's \"old\" semaphore implementation by\n  // zero-initializing the sem_t contents. This has to be done here because\n  // interceptors bind to the lowest symbols version by default, hitting the\n  // buggy code path while the non-sanitized build of the same code works fine.\n  REAL(memset)(s, 0, sizeof(*s));\n  int res = REAL(sem_init)(s, pshared, value);\n  return res;\n}\n\nINTERCEPTOR(int, sem_destroy, __sanitizer_sem_t *s) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, sem_destroy, s);\n  int res = REAL(sem_destroy)(s);\n  return res;\n}\n\nINTERCEPTOR(int, sem_wait, __sanitizer_sem_t *s) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, sem_wait, s);\n  int res = COMMON_INTERCEPTOR_BLOCK_REAL(sem_wait)(s);\n  if (res == 0) {\n    COMMON_INTERCEPTOR_ACQUIRE(ctx, (uptr)s);\n  }\n  return res;\n}\n\nINTERCEPTOR(int, sem_trywait, __sanitizer_sem_t *s) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, sem_trywait, s);\n  int res = COMMON_INTERCEPTOR_BLOCK_REAL(sem_trywait)(s);\n  if (res == 0) {\n    COMMON_INTERCEPTOR_ACQUIRE(ctx, (uptr)s);\n  }\n  return res;\n}\n\nINTERCEPTOR(int, sem_timedwait, __sanitizer_sem_t *s, void *abstime) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, sem_timedwait, s, abstime);\n  COMMON_INTERCEPTOR_READ_RANGE(ctx, abstime, struct_timespec_sz);\n  int res = COMMON_INTERCEPTOR_BLOCK_REAL(sem_timedwait)(s, abstime);\n  if (res == 0) {\n    COMMON_INTERCEPTOR_ACQUIRE(ctx, (uptr)s);\n  }\n  return res;\n}\n\nINTERCEPTOR(int, sem_post, __sanitizer_sem_t *s) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, sem_post, s);\n  COMMON_INTERCEPTOR_RELEASE(ctx, (uptr)s);\n  int res = REAL(sem_post)(s);\n  return res;\n}\n\nINTERCEPTOR(int, sem_getvalue, __sanitizer_sem_t *s, int *sval) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, sem_getvalue, s, sval);\n  int res = REAL(sem_getvalue)(s, sval);\n  if (res == 0) {\n    COMMON_INTERCEPTOR_ACQUIRE(ctx, (uptr)s);\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, sval, sizeof(*sval));\n  }\n  return res;\n}\n#define INIT_SEM                                                               \\\n  COMMON_INTERCEPT_FUNCTION(sem_init);                                         \\\n  COMMON_INTERCEPT_FUNCTION(sem_destroy);                                      \\\n  COMMON_INTERCEPT_FUNCTION(sem_wait);                                         \\\n  COMMON_INTERCEPT_FUNCTION(sem_trywait);                                      \\\n  COMMON_INTERCEPT_FUNCTION(sem_timedwait);                                    \\\n  COMMON_INTERCEPT_FUNCTION(sem_post);                                         \\\n  COMMON_INTERCEPT_FUNCTION(sem_getvalue);\n#else\n#define INIT_SEM\n#endif // SANITIZER_INTERCEPT_SEM\n\n#if SANITIZER_INTERCEPT_PTHREAD_SETCANCEL\nINTERCEPTOR(int, pthread_setcancelstate, int state, int *oldstate) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, pthread_setcancelstate, state, oldstate);\n  int res = REAL(pthread_setcancelstate)(state, oldstate);\n  if (res == 0 && oldstate != nullptr)\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, oldstate, sizeof(*oldstate));\n  return res;\n}\n\nINTERCEPTOR(int, pthread_setcanceltype, int type, int *oldtype) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, pthread_setcanceltype, type, oldtype);\n  int res = REAL(pthread_setcanceltype)(type, oldtype);\n  if (res == 0 && oldtype != nullptr)\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, oldtype, sizeof(*oldtype));\n  return res;\n}\n#define INIT_PTHREAD_SETCANCEL                                                 \\\n  COMMON_INTERCEPT_FUNCTION(pthread_setcancelstate);                           \\\n  COMMON_INTERCEPT_FUNCTION(pthread_setcanceltype);\n#else\n#define INIT_PTHREAD_SETCANCEL\n#endif\n\n#if SANITIZER_INTERCEPT_MINCORE\nINTERCEPTOR(int, mincore, void *addr, uptr length, unsigned char *vec) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, mincore, addr, length, vec);\n  int res = REAL(mincore)(addr, length, vec);\n  if (res == 0) {\n    uptr page_size = GetPageSizeCached();\n    uptr vec_size = ((length + page_size - 1) & (~(page_size - 1))) / page_size;\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, vec, vec_size);\n  }\n  return res;\n}\n#define INIT_MINCORE COMMON_INTERCEPT_FUNCTION(mincore);\n#else\n#define INIT_MINCORE\n#endif\n\n#if SANITIZER_INTERCEPT_PROCESS_VM_READV\nINTERCEPTOR(SSIZE_T, process_vm_readv, int pid, __sanitizer_iovec *local_iov,\n            uptr liovcnt, __sanitizer_iovec *remote_iov, uptr riovcnt,\n            uptr flags) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, process_vm_readv, pid, local_iov, liovcnt,\n                           remote_iov, riovcnt, flags);\n  SSIZE_T res = REAL(process_vm_readv)(pid, local_iov, liovcnt, remote_iov,\n                                       riovcnt, flags);\n  if (res > 0)\n    write_iovec(ctx, local_iov, liovcnt, res);\n  return res;\n}\n\nINTERCEPTOR(SSIZE_T, process_vm_writev, int pid, __sanitizer_iovec *local_iov,\n            uptr liovcnt, __sanitizer_iovec *remote_iov, uptr riovcnt,\n            uptr flags) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, process_vm_writev, pid, local_iov, liovcnt,\n                           remote_iov, riovcnt, flags);\n  SSIZE_T res = REAL(process_vm_writev)(pid, local_iov, liovcnt, remote_iov,\n                                        riovcnt, flags);\n  if (res > 0)\n    read_iovec(ctx, local_iov, liovcnt, res);\n  return res;\n}\n#define INIT_PROCESS_VM_READV                                                  \\\n  COMMON_INTERCEPT_FUNCTION(process_vm_readv);                                 \\\n  COMMON_INTERCEPT_FUNCTION(process_vm_writev);\n#else\n#define INIT_PROCESS_VM_READV\n#endif\n\n#if SANITIZER_INTERCEPT_CTERMID\nINTERCEPTOR(char *, ctermid, char *s) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, ctermid, s);\n  char *res = REAL(ctermid)(s);\n  if (res) {\n    COMMON_INTERCEPTOR_INITIALIZE_RANGE(res, REAL(strlen)(res) + 1);\n  }\n  return res;\n}\n#define INIT_CTERMID COMMON_INTERCEPT_FUNCTION(ctermid);\n#else\n#define INIT_CTERMID\n#endif\n\n#if SANITIZER_INTERCEPT_CTERMID_R\nINTERCEPTOR(char *, ctermid_r, char *s) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, ctermid_r, s);\n  char *res = REAL(ctermid_r)(s);\n  if (res) {\n    COMMON_INTERCEPTOR_INITIALIZE_RANGE(res, REAL(strlen)(res) + 1);\n  }\n  return res;\n}\n#define INIT_CTERMID_R COMMON_INTERCEPT_FUNCTION(ctermid_r);\n#else\n#define INIT_CTERMID_R\n#endif\n\n#if SANITIZER_INTERCEPT_RECV_RECVFROM\nINTERCEPTOR(SSIZE_T, recv, int fd, void *buf, SIZE_T len, int flags) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, recv, fd, buf, len, flags);\n  COMMON_INTERCEPTOR_FD_ACCESS(ctx, fd);\n  SSIZE_T res = REAL(recv)(fd, buf, len, flags);\n  if (res > 0) {\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, buf, Min((SIZE_T)res, len));\n  }\n  if (res >= 0 && fd >= 0) COMMON_INTERCEPTOR_FD_ACQUIRE(ctx, fd);\n  return res;\n}\n\nINTERCEPTOR(SSIZE_T, recvfrom, int fd, void *buf, SIZE_T len, int flags,\n            void *srcaddr, int *addrlen) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, recvfrom, fd, buf, len, flags, srcaddr,\n                           addrlen);\n  COMMON_INTERCEPTOR_FD_ACCESS(ctx, fd);\n  SIZE_T srcaddr_sz;\n  if (srcaddr) srcaddr_sz = *addrlen;\n  (void)srcaddr_sz;  // prevent \"set but not used\" warning\n  SSIZE_T res = REAL(recvfrom)(fd, buf, len, flags, srcaddr, addrlen);\n  if (res > 0)\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, buf, Min((SIZE_T)res, len));\n  if (res >= 0 && srcaddr)\n    COMMON_INTERCEPTOR_INITIALIZE_RANGE(srcaddr,\n                                        Min((SIZE_T)*addrlen, srcaddr_sz));\n  return res;\n}\n#define INIT_RECV_RECVFROM          \\\n  COMMON_INTERCEPT_FUNCTION(recv);  \\\n  COMMON_INTERCEPT_FUNCTION(recvfrom);\n#else\n#define INIT_RECV_RECVFROM\n#endif\n\n#if SANITIZER_INTERCEPT_SEND_SENDTO\nINTERCEPTOR(SSIZE_T, send, int fd, void *buf, SIZE_T len, int flags) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, send, fd, buf, len, flags);\n  if (fd >= 0) {\n    COMMON_INTERCEPTOR_FD_ACCESS(ctx, fd);\n    COMMON_INTERCEPTOR_FD_RELEASE(ctx, fd);\n  }\n  SSIZE_T res = REAL(send)(fd, buf, len, flags);\n  if (common_flags()->intercept_send && res > 0)\n    COMMON_INTERCEPTOR_READ_RANGE(ctx, buf, Min((SIZE_T)res, len));\n  return res;\n}\n\nINTERCEPTOR(SSIZE_T, sendto, int fd, void *buf, SIZE_T len, int flags,\n            void *dstaddr, int addrlen) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, sendto, fd, buf, len, flags, dstaddr, addrlen);\n  if (fd >= 0) {\n    COMMON_INTERCEPTOR_FD_ACCESS(ctx, fd);\n    COMMON_INTERCEPTOR_FD_RELEASE(ctx, fd);\n  }\n  // Can't check dstaddr as it may have uninitialized padding at the end.\n  SSIZE_T res = REAL(sendto)(fd, buf, len, flags, dstaddr, addrlen);\n  if (common_flags()->intercept_send && res > 0)\n    COMMON_INTERCEPTOR_READ_RANGE(ctx, buf, Min((SIZE_T)res, len));\n  return res;\n}\n#define INIT_SEND_SENDTO           \\\n  COMMON_INTERCEPT_FUNCTION(send); \\\n  COMMON_INTERCEPT_FUNCTION(sendto);\n#else\n#define INIT_SEND_SENDTO\n#endif\n\n#if SANITIZER_INTERCEPT_EVENTFD_READ_WRITE\nINTERCEPTOR(int, eventfd_read, int fd, u64 *value) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, eventfd_read, fd, value);\n  COMMON_INTERCEPTOR_FD_ACCESS(ctx, fd);\n  int res = REAL(eventfd_read)(fd, value);\n  if (res == 0) {\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, value, sizeof(*value));\n    if (fd >= 0) COMMON_INTERCEPTOR_FD_ACQUIRE(ctx, fd);\n  }\n  return res;\n}\nINTERCEPTOR(int, eventfd_write, int fd, u64 value) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, eventfd_write, fd, value);\n  if (fd >= 0) {\n    COMMON_INTERCEPTOR_FD_ACCESS(ctx, fd);\n    COMMON_INTERCEPTOR_FD_RELEASE(ctx, fd);\n  }\n  int res = REAL(eventfd_write)(fd, value);\n  return res;\n}\n#define INIT_EVENTFD_READ_WRITE            \\\n  COMMON_INTERCEPT_FUNCTION(eventfd_read); \\\n  COMMON_INTERCEPT_FUNCTION(eventfd_write)\n#else\n#define INIT_EVENTFD_READ_WRITE\n#endif\n\n#if SANITIZER_INTERCEPT_STAT\nINTERCEPTOR(int, stat, const char *path, void *buf) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, stat, path, buf);\n  if (common_flags()->intercept_stat)\n    COMMON_INTERCEPTOR_READ_STRING(ctx, path, 0);\n  int res = REAL(stat)(path, buf);\n  if (!res)\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, buf, __sanitizer::struct_stat_sz);\n  return res;\n}\n#define INIT_STAT COMMON_INTERCEPT_FUNCTION(stat)\n#else\n#define INIT_STAT\n#endif\n\n#if SANITIZER_INTERCEPT_LSTAT\nINTERCEPTOR(int, lstat, const char *path, void *buf) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, lstat, path, buf);\n  if (common_flags()->intercept_stat)\n    COMMON_INTERCEPTOR_READ_STRING(ctx, path, 0);\n  int res = REAL(lstat)(path, buf);\n  if (!res)\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, buf, __sanitizer::struct_stat_sz);\n  return res;\n}\n#define INIT_LSTAT COMMON_INTERCEPT_FUNCTION(lstat)\n#else\n#define INIT_LSTAT\n#endif\n\n#if SANITIZER_INTERCEPT___XSTAT\nINTERCEPTOR(int, __xstat, int version, const char *path, void *buf) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, __xstat, version, path, buf);\n  if (common_flags()->intercept_stat)\n    COMMON_INTERCEPTOR_READ_STRING(ctx, path, 0);\n  int res = REAL(__xstat)(version, path, buf);\n  if (!res)\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, buf, __sanitizer::struct_stat_sz);\n  return res;\n}\n#define INIT___XSTAT COMMON_INTERCEPT_FUNCTION(__xstat)\n#else\n#define INIT___XSTAT\n#endif\n\n#if SANITIZER_INTERCEPT___XSTAT64\nINTERCEPTOR(int, __xstat64, int version, const char *path, void *buf) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, __xstat64, version, path, buf);\n  if (common_flags()->intercept_stat)\n    COMMON_INTERCEPTOR_READ_STRING(ctx, path, 0);\n  int res = REAL(__xstat64)(version, path, buf);\n  if (!res)\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, buf, __sanitizer::struct_stat64_sz);\n  return res;\n}\n#define INIT___XSTAT64 COMMON_INTERCEPT_FUNCTION(__xstat64)\n#else\n#define INIT___XSTAT64\n#endif\n\n#if SANITIZER_INTERCEPT___LXSTAT\nINTERCEPTOR(int, __lxstat, int version, const char *path, void *buf) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, __lxstat, version, path, buf);\n  if (common_flags()->intercept_stat)\n    COMMON_INTERCEPTOR_READ_STRING(ctx, path, 0);\n  int res = REAL(__lxstat)(version, path, buf);\n  if (!res)\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, buf, __sanitizer::struct_stat_sz);\n  return res;\n}\n#define INIT___LXSTAT COMMON_INTERCEPT_FUNCTION(__lxstat)\n#else\n#define INIT___LXSTAT\n#endif\n\n#if SANITIZER_INTERCEPT___LXSTAT64\nINTERCEPTOR(int, __lxstat64, int version, const char *path, void *buf) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, __lxstat64, version, path, buf);\n  if (common_flags()->intercept_stat)\n    COMMON_INTERCEPTOR_READ_STRING(ctx, path, 0);\n  int res = REAL(__lxstat64)(version, path, buf);\n  if (!res)\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, buf, __sanitizer::struct_stat64_sz);\n  return res;\n}\n#define INIT___LXSTAT64 COMMON_INTERCEPT_FUNCTION(__lxstat64)\n#else\n#define INIT___LXSTAT64\n#endif\n\n// FIXME: add other *stat interceptor\n\n#if SANITIZER_INTERCEPT_UTMP\nINTERCEPTOR(void *, getutent, int dummy) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, getutent, dummy);\n  void *res = REAL(getutent)(dummy);\n  if (res)\n    COMMON_INTERCEPTOR_INITIALIZE_RANGE(res, __sanitizer::struct_utmp_sz);\n  return res;\n}\nINTERCEPTOR(void *, getutid, void *ut) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, getutid, ut);\n  void *res = REAL(getutid)(ut);\n  if (res)\n    COMMON_INTERCEPTOR_INITIALIZE_RANGE(res, __sanitizer::struct_utmp_sz);\n  return res;\n}\nINTERCEPTOR(void *, getutline, void *ut) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, getutline, ut);\n  void *res = REAL(getutline)(ut);\n  if (res)\n    COMMON_INTERCEPTOR_INITIALIZE_RANGE(res, __sanitizer::struct_utmp_sz);\n  return res;\n}\n#define INIT_UTMP                      \\\n  COMMON_INTERCEPT_FUNCTION(getutent); \\\n  COMMON_INTERCEPT_FUNCTION(getutid);  \\\n  COMMON_INTERCEPT_FUNCTION(getutline);\n#else\n#define INIT_UTMP\n#endif\n\n#if SANITIZER_INTERCEPT_UTMPX\nINTERCEPTOR(void *, getutxent, int dummy) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, getutxent, dummy);\n  void *res = REAL(getutxent)(dummy);\n  if (res)\n    COMMON_INTERCEPTOR_INITIALIZE_RANGE(res, __sanitizer::struct_utmpx_sz);\n  return res;\n}\nINTERCEPTOR(void *, getutxid, void *ut) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, getutxid, ut);\n  void *res = REAL(getutxid)(ut);\n  if (res)\n    COMMON_INTERCEPTOR_INITIALIZE_RANGE(res, __sanitizer::struct_utmpx_sz);\n  return res;\n}\nINTERCEPTOR(void *, getutxline, void *ut) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, getutxline, ut);\n  void *res = REAL(getutxline)(ut);\n  if (res)\n    COMMON_INTERCEPTOR_INITIALIZE_RANGE(res, __sanitizer::struct_utmpx_sz);\n  return res;\n}\nINTERCEPTOR(void *, pututxline, const void *ut) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, pututxline, ut);\n  if (ut)\n    COMMON_INTERCEPTOR_READ_RANGE(ctx, ut, __sanitizer::struct_utmpx_sz);\n  void *res = REAL(pututxline)(ut);\n  if (res)\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, res, __sanitizer::struct_utmpx_sz);\n  return res;\n}\n#define INIT_UTMPX                      \\\n  COMMON_INTERCEPT_FUNCTION(getutxent); \\\n  COMMON_INTERCEPT_FUNCTION(getutxid);  \\\n  COMMON_INTERCEPT_FUNCTION(getutxline); \\\n  COMMON_INTERCEPT_FUNCTION(pututxline);\n#else\n#define INIT_UTMPX\n#endif\n\n#if SANITIZER_INTERCEPT_GETLOADAVG\nINTERCEPTOR(int, getloadavg, double *loadavg, int nelem) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, getloadavg, loadavg, nelem);\n  int res = REAL(getloadavg)(loadavg, nelem);\n  if (res > 0)\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, loadavg, res * sizeof(*loadavg));\n  return res;\n}\n#define INIT_GETLOADAVG                      \\\n  COMMON_INTERCEPT_FUNCTION(getloadavg);\n#else\n#define INIT_GETLOADAVG\n#endif\n\n#if SANITIZER_INTERCEPT_MCHECK_MPROBE\nINTERCEPTOR(int, mcheck, void (*abortfunc)(int mstatus)) {\n  return 0;\n}\n\nINTERCEPTOR(int, mcheck_pedantic, void (*abortfunc)(int mstatus)) {\n  return 0;\n}\n\nINTERCEPTOR(int, mprobe, void *ptr) {\n  return 0;\n}\n#endif\n\nINTERCEPTOR(SIZE_T, wcslen, const wchar_t *s) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, wcslen, s);\n  SIZE_T res = REAL(wcslen)(s);\n  COMMON_INTERCEPTOR_READ_RANGE(ctx, s, sizeof(wchar_t) * (res + 1));\n  return res;\n}\n\nINTERCEPTOR(SIZE_T, wcsnlen, const wchar_t *s, SIZE_T n) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, wcsnlen, s, n);\n  SIZE_T res = REAL(wcsnlen)(s, n);\n  COMMON_INTERCEPTOR_READ_RANGE(ctx, s, sizeof(wchar_t) * Min(res + 1, n));\n  return res;\n}\n#define INIT_WCSLEN                  \\\n  COMMON_INTERCEPT_FUNCTION(wcslen); \\\n  COMMON_INTERCEPT_FUNCTION(wcsnlen);\n\n#if SANITIZER_INTERCEPT_WCSCAT\nINTERCEPTOR(wchar_t *, wcscat, wchar_t *dst, const wchar_t *src) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, wcscat, dst, src);\n  SIZE_T src_size = REAL(wcslen)(src);\n  SIZE_T dst_size = REAL(wcslen)(dst);\n  COMMON_INTERCEPTOR_READ_RANGE(ctx, src, (src_size + 1) * sizeof(wchar_t));\n  COMMON_INTERCEPTOR_READ_RANGE(ctx, dst, (dst_size + 1) * sizeof(wchar_t));\n  COMMON_INTERCEPTOR_WRITE_RANGE(ctx, dst + dst_size,\n                                 (src_size + 1) * sizeof(wchar_t));\n  return REAL(wcscat)(dst, src);\n}\n\nINTERCEPTOR(wchar_t *, wcsncat, wchar_t *dst, const wchar_t *src, SIZE_T n) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, wcsncat, dst, src, n);\n  SIZE_T src_size = REAL(wcsnlen)(src, n);\n  SIZE_T dst_size = REAL(wcslen)(dst);\n  COMMON_INTERCEPTOR_READ_RANGE(ctx, src,\n                                Min(src_size + 1, n) * sizeof(wchar_t));\n  COMMON_INTERCEPTOR_READ_RANGE(ctx, dst, (dst_size + 1) * sizeof(wchar_t));\n  COMMON_INTERCEPTOR_WRITE_RANGE(ctx, dst + dst_size,\n                                 (src_size + 1) * sizeof(wchar_t));\n  return REAL(wcsncat)(dst, src, n);\n}\n#define INIT_WCSCAT                  \\\n  COMMON_INTERCEPT_FUNCTION(wcscat); \\\n  COMMON_INTERCEPT_FUNCTION(wcsncat);\n#else\n#define INIT_WCSCAT\n#endif\n\n#if SANITIZER_INTERCEPT_WCSDUP\nINTERCEPTOR(wchar_t *, wcsdup, wchar_t *s) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, wcsdup, s);\n  SIZE_T len = REAL(wcslen)(s);\n  COMMON_INTERCEPTOR_READ_RANGE(ctx, s, sizeof(wchar_t) * (len + 1));\n  wchar_t *result = REAL(wcsdup)(s);\n  if (result)\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, result, sizeof(wchar_t) * (len + 1));\n  return result;\n}\n\n#define INIT_WCSDUP COMMON_INTERCEPT_FUNCTION(wcsdup);\n#else\n#define INIT_WCSDUP\n#endif\n\n#if SANITIZER_INTERCEPT_STRXFRM\nstatic SIZE_T RealStrLen(const char *str) { return REAL(strlen)(str); }\n\nstatic SIZE_T RealStrLen(const wchar_t *str) { return REAL(wcslen)(str); }\n\n#define STRXFRM_INTERCEPTOR_IMPL(strxfrm, dest, src, len, ...)             \\\n  {                                                                        \\\n    void *ctx;                                                             \\\n    COMMON_INTERCEPTOR_ENTER(ctx, strxfrm, dest, src, len, ##__VA_ARGS__); \\\n    COMMON_INTERCEPTOR_READ_RANGE(ctx, src,                                \\\n                                  sizeof(*src) * (RealStrLen(src) + 1));   \\\n    SIZE_T res = REAL(strxfrm)(dest, src, len, ##__VA_ARGS__);             \\\n    if (res < len)                                                         \\\n      COMMON_INTERCEPTOR_WRITE_RANGE(ctx, dest, sizeof(*src) * (res + 1)); \\\n    return res;                                                            \\\n  }\n\nINTERCEPTOR(SIZE_T, strxfrm, char *dest, const char *src, SIZE_T len) {\n  STRXFRM_INTERCEPTOR_IMPL(strxfrm, dest, src, len);\n}\n\nINTERCEPTOR(SIZE_T, strxfrm_l, char *dest, const char *src, SIZE_T len,\n            void *locale) {\n  STRXFRM_INTERCEPTOR_IMPL(strxfrm_l, dest, src, len, locale);\n}\n\n#define INIT_STRXFRM                  \\\n  COMMON_INTERCEPT_FUNCTION(strxfrm); \\\n  COMMON_INTERCEPT_FUNCTION(strxfrm_l);\n#else\n#define INIT_STRXFRM\n#endif\n\n#if SANITIZER_INTERCEPT___STRXFRM_L\nINTERCEPTOR(SIZE_T, __strxfrm_l, char *dest, const char *src, SIZE_T len,\n            void *locale) {\n  STRXFRM_INTERCEPTOR_IMPL(__strxfrm_l, dest, src, len, locale);\n}\n\n#define INIT___STRXFRM_L COMMON_INTERCEPT_FUNCTION(__strxfrm_l);\n#else\n#define INIT___STRXFRM_L\n#endif\n\n#if SANITIZER_INTERCEPT_WCSXFRM\nINTERCEPTOR(SIZE_T, wcsxfrm, wchar_t *dest, const wchar_t *src, SIZE_T len) {\n  STRXFRM_INTERCEPTOR_IMPL(wcsxfrm, dest, src, len);\n}\n\nINTERCEPTOR(SIZE_T, wcsxfrm_l, wchar_t *dest, const wchar_t *src, SIZE_T len,\n            void *locale) {\n  STRXFRM_INTERCEPTOR_IMPL(wcsxfrm_l, dest, src, len, locale);\n}\n\n#define INIT_WCSXFRM                  \\\n  COMMON_INTERCEPT_FUNCTION(wcsxfrm); \\\n  COMMON_INTERCEPT_FUNCTION(wcsxfrm_l);\n#else\n#define INIT_WCSXFRM\n#endif\n\n#if SANITIZER_INTERCEPT___WCSXFRM_L\nINTERCEPTOR(SIZE_T, __wcsxfrm_l, wchar_t *dest, const wchar_t *src, SIZE_T len,\n            void *locale) {\n  STRXFRM_INTERCEPTOR_IMPL(__wcsxfrm_l, dest, src, len, locale);\n}\n\n#define INIT___WCSXFRM_L COMMON_INTERCEPT_FUNCTION(__wcsxfrm_l);\n#else\n#define INIT___WCSXFRM_L\n#endif\n\n#if SANITIZER_INTERCEPT_ACCT\nINTERCEPTOR(int, acct, const char *file) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, acct, file);\n  if (file)\n    COMMON_INTERCEPTOR_READ_RANGE(ctx, file, REAL(strlen)(file) + 1);\n  return REAL(acct)(file);\n}\n#define INIT_ACCT COMMON_INTERCEPT_FUNCTION(acct)\n#else\n#define INIT_ACCT\n#endif\n\n#if SANITIZER_INTERCEPT_USER_FROM_UID\nINTERCEPTOR(const char *, user_from_uid, u32 uid, int nouser) {\n  void *ctx;\n  const char *user;\n  COMMON_INTERCEPTOR_ENTER(ctx, user_from_uid, uid, nouser);\n  user = REAL(user_from_uid)(uid, nouser);\n  if (user)\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, user, REAL(strlen)(user) + 1);\n  return user;\n}\n#define INIT_USER_FROM_UID COMMON_INTERCEPT_FUNCTION(user_from_uid)\n#else\n#define INIT_USER_FROM_UID\n#endif\n\n#if SANITIZER_INTERCEPT_UID_FROM_USER\nINTERCEPTOR(int, uid_from_user, const char *name, u32 *uid) {\n  void *ctx;\n  int res;\n  COMMON_INTERCEPTOR_ENTER(ctx, uid_from_user, name, uid);\n  if (name)\n    COMMON_INTERCEPTOR_READ_RANGE(ctx, name, REAL(strlen)(name) + 1);\n  res = REAL(uid_from_user)(name, uid);\n  if (uid)\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, uid, sizeof(*uid));\n  return res;\n}\n#define INIT_UID_FROM_USER COMMON_INTERCEPT_FUNCTION(uid_from_user)\n#else\n#define INIT_UID_FROM_USER\n#endif\n\n#if SANITIZER_INTERCEPT_GROUP_FROM_GID\nINTERCEPTOR(const char *, group_from_gid, u32 gid, int nogroup) {\n  void *ctx;\n  const char *group;\n  COMMON_INTERCEPTOR_ENTER(ctx, group_from_gid, gid, nogroup);\n  group = REAL(group_from_gid)(gid, nogroup);\n  if (group)\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, group, REAL(strlen)(group) + 1);\n  return group;\n}\n#define INIT_GROUP_FROM_GID COMMON_INTERCEPT_FUNCTION(group_from_gid)\n#else\n#define INIT_GROUP_FROM_GID\n#endif\n\n#if SANITIZER_INTERCEPT_GID_FROM_GROUP\nINTERCEPTOR(int, gid_from_group, const char *group, u32 *gid) {\n  void *ctx;\n  int res;\n  COMMON_INTERCEPTOR_ENTER(ctx, gid_from_group, group, gid);\n  if (group)\n    COMMON_INTERCEPTOR_READ_RANGE(ctx, group, REAL(strlen)(group) + 1);\n  res = REAL(gid_from_group)(group, gid);\n  if (gid)\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, gid, sizeof(*gid));\n  return res;\n}\n#define INIT_GID_FROM_GROUP COMMON_INTERCEPT_FUNCTION(gid_from_group)\n#else\n#define INIT_GID_FROM_GROUP\n#endif\n\n#if SANITIZER_INTERCEPT_ACCESS\nINTERCEPTOR(int, access, const char *path, int mode) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, access, path, mode);\n  if (path)\n    COMMON_INTERCEPTOR_READ_RANGE(ctx, path, REAL(strlen)(path) + 1);\n  return REAL(access)(path, mode);\n}\n#define INIT_ACCESS COMMON_INTERCEPT_FUNCTION(access)\n#else\n#define INIT_ACCESS\n#endif\n\n#if SANITIZER_INTERCEPT_FACCESSAT\nINTERCEPTOR(int, faccessat, int fd, const char *path, int mode, int flags) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, faccessat, fd, path, mode, flags);\n  if (path)\n    COMMON_INTERCEPTOR_READ_RANGE(ctx, path, REAL(strlen)(path) + 1);\n  return REAL(faccessat)(fd, path, mode, flags);\n}\n#define INIT_FACCESSAT COMMON_INTERCEPT_FUNCTION(faccessat)\n#else\n#define INIT_FACCESSAT\n#endif\n\n#if SANITIZER_INTERCEPT_GETGROUPLIST\nINTERCEPTOR(int, getgrouplist, const char *name, u32 basegid, u32 *groups,\n            int *ngroups) {\n  void *ctx;\n  int res;\n  COMMON_INTERCEPTOR_ENTER(ctx, getgrouplist, name, basegid, groups, ngroups);\n  if (name)\n    COMMON_INTERCEPTOR_READ_RANGE(ctx, name, REAL(strlen)(name) + 1);\n  if (ngroups)\n    COMMON_INTERCEPTOR_READ_RANGE(ctx, ngroups, sizeof(*ngroups));\n  res = REAL(getgrouplist)(name, basegid, groups, ngroups);\n  if (!res && groups && ngroups) {\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, groups, sizeof(*groups) * (*ngroups));\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, ngroups, sizeof(*ngroups));\n  }\n  return res;\n}\n\n#define INIT_GETGROUPLIST COMMON_INTERCEPT_FUNCTION(getgrouplist);\n#else\n#define INIT_GETGROUPLIST\n#endif\n\n#if SANITIZER_INTERCEPT_GETGROUPMEMBERSHIP\nINTERCEPTOR(int, getgroupmembership, const char *name, u32 basegid, u32 *groups,\n            int maxgrp, int *ngroups) {\n  void *ctx;\n  int res;\n  COMMON_INTERCEPTOR_ENTER(ctx, getgroupmembership, name, basegid, groups,\n                           maxgrp, ngroups);\n  if (name)\n    COMMON_INTERCEPTOR_READ_RANGE(ctx, name, REAL(strlen)(name) + 1);\n  res = REAL(getgroupmembership)(name, basegid, groups, maxgrp, ngroups);\n  if (!res && groups && ngroups) {\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, groups, sizeof(*groups) * (*ngroups));\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, ngroups, sizeof(*ngroups));\n  }\n  return res;\n}\n\n#define INIT_GETGROUPMEMBERSHIP COMMON_INTERCEPT_FUNCTION(getgroupmembership);\n#else\n#define INIT_GETGROUPMEMBERSHIP\n#endif\n\n#if SANITIZER_INTERCEPT_READLINK\nINTERCEPTOR(SSIZE_T, readlink, const char *path, char *buf, SIZE_T bufsiz) {\n  void* ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, readlink, path, buf, bufsiz);\n  COMMON_INTERCEPTOR_READ_RANGE(ctx, path, REAL(strlen)(path) + 1);\n  SSIZE_T res = REAL(readlink)(path, buf, bufsiz);\n  if (res > 0)\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, buf, res);\n  return res;\n}\n\n#define INIT_READLINK COMMON_INTERCEPT_FUNCTION(readlink)\n#else\n#define INIT_READLINK\n#endif\n\n#if SANITIZER_INTERCEPT_READLINKAT\nINTERCEPTOR(SSIZE_T, readlinkat, int dirfd, const char *path, char *buf,\n            SIZE_T bufsiz) {\n  void* ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, readlinkat, dirfd, path, buf, bufsiz);\n  COMMON_INTERCEPTOR_READ_RANGE(ctx, path, REAL(strlen)(path) + 1);\n  SSIZE_T res = REAL(readlinkat)(dirfd, path, buf, bufsiz);\n  if (res > 0)\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, buf, res);\n  return res;\n}\n\n#define INIT_READLINKAT COMMON_INTERCEPT_FUNCTION(readlinkat)\n#else\n#define INIT_READLINKAT\n#endif\n\n#if SANITIZER_INTERCEPT_NAME_TO_HANDLE_AT\nINTERCEPTOR(int, name_to_handle_at, int dirfd, const char *pathname,\n            struct file_handle *handle, int *mount_id, int flags) {\n  void* ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, name_to_handle_at, dirfd, pathname, handle,\n                           mount_id, flags);\n  COMMON_INTERCEPTOR_READ_RANGE(ctx, pathname, REAL(strlen)(pathname) + 1);\n\n  __sanitizer_file_handle *sanitizer_handle =\n      reinterpret_cast<__sanitizer_file_handle*>(handle);\n  COMMON_INTERCEPTOR_READ_RANGE(\n      ctx, &sanitizer_handle->handle_bytes,\n      sizeof(sanitizer_handle->handle_bytes));\n\n  int res = REAL(name_to_handle_at)(dirfd, pathname, handle, mount_id, flags);\n  if (!res) {\n    COMMON_INTERCEPTOR_WRITE_RANGE(\n        ctx, &sanitizer_handle->handle_bytes,\n        sizeof(sanitizer_handle->handle_bytes));\n    COMMON_INTERCEPTOR_WRITE_RANGE(\n        ctx, &sanitizer_handle->handle_type,\n        sizeof(sanitizer_handle->handle_type));\n    COMMON_INTERCEPTOR_WRITE_RANGE(\n        ctx, &sanitizer_handle->f_handle, sanitizer_handle->handle_bytes);\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, mount_id, sizeof(*mount_id));\n  }\n  return res;\n}\n\n#define INIT_NAME_TO_HANDLE_AT COMMON_INTERCEPT_FUNCTION(name_to_handle_at)\n#else\n#define INIT_NAME_TO_HANDLE_AT\n#endif\n\n#if SANITIZER_INTERCEPT_OPEN_BY_HANDLE_AT\nINTERCEPTOR(int, open_by_handle_at, int mount_fd, struct file_handle* handle,\n            int flags) {\n  void* ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, open_by_handle_at, mount_fd, handle, flags);\n\n  __sanitizer_file_handle *sanitizer_handle =\n      reinterpret_cast<__sanitizer_file_handle*>(handle);\n  COMMON_INTERCEPTOR_READ_RANGE(\n      ctx, &sanitizer_handle->handle_bytes,\n      sizeof(sanitizer_handle->handle_bytes));\n  COMMON_INTERCEPTOR_READ_RANGE(\n      ctx, &sanitizer_handle->handle_type,\n      sizeof(sanitizer_handle->handle_type));\n  COMMON_INTERCEPTOR_READ_RANGE(\n      ctx, &sanitizer_handle->f_handle, sanitizer_handle->handle_bytes);\n\n  return REAL(open_by_handle_at)(mount_fd, handle, flags);\n}\n\n#define INIT_OPEN_BY_HANDLE_AT COMMON_INTERCEPT_FUNCTION(open_by_handle_at)\n#else\n#define INIT_OPEN_BY_HANDLE_AT\n#endif\n\n#if SANITIZER_INTERCEPT_STRLCPY\nINTERCEPTOR(SIZE_T, strlcpy, char *dst, char *src, SIZE_T size) {\n  void *ctx;\n  SIZE_T res;\n  COMMON_INTERCEPTOR_ENTER(ctx, strlcpy, dst, src, size);\n  if (src) {\n    // Keep strnlen as macro argument, as macro may ignore it.\n    COMMON_INTERCEPTOR_READ_STRING(\n        ctx, src, Min(internal_strnlen(src, size), size - 1) + 1);\n  }\n  res = REAL(strlcpy)(dst, src, size);\n  COMMON_INTERCEPTOR_COPY_STRING(ctx, dst, src, REAL(strlen)(dst) + 1);\n  return res;\n}\n\nINTERCEPTOR(SIZE_T, strlcat, char *dst, char *src, SIZE_T size) {\n  void *ctx;\n  SIZE_T len = 0;\n  COMMON_INTERCEPTOR_ENTER(ctx, strlcat, dst, src, size);\n  // src is checked in the strlcpy() interceptor\n  if (dst) {\n    len = internal_strnlen(dst, size);\n    COMMON_INTERCEPTOR_READ_STRING(ctx, dst, Min(len, size - 1) + 1);\n  }\n  // Reuse the rest of the code in the strlcpy() interceptor\n  return WRAP(strlcpy)(dst + len, src, size - len) + len;\n}\n#define INIT_STRLCPY \\\n  COMMON_INTERCEPT_FUNCTION(strlcpy); \\\n  COMMON_INTERCEPT_FUNCTION(strlcat);\n#else\n#define INIT_STRLCPY\n#endif\n\n#if SANITIZER_INTERCEPT_MMAP\nINTERCEPTOR(void *, mmap, void *addr, SIZE_T sz, int prot, int flags, int fd,\n            OFF_T off) {\n  void *ctx;\n  if (common_flags()->detect_write_exec)\n    ReportMmapWriteExec(prot);\n  if (COMMON_INTERCEPTOR_NOTHING_IS_INITIALIZED)\n    return (void *)internal_mmap(addr, sz, prot, flags, fd, off);\n  COMMON_INTERCEPTOR_ENTER(ctx, mmap, addr, sz, prot, flags, fd, off);\n  COMMON_INTERCEPTOR_MMAP_IMPL(ctx, mmap, addr, sz, prot, flags, fd, off);\n}\n\nINTERCEPTOR(int, mprotect, void *addr, SIZE_T sz, int prot) {\n  void *ctx;\n  if (common_flags()->detect_write_exec)\n    ReportMmapWriteExec(prot);\n  if (COMMON_INTERCEPTOR_NOTHING_IS_INITIALIZED)\n    return (int)internal_mprotect(addr, sz, prot);\n  COMMON_INTERCEPTOR_ENTER(ctx, mprotect, addr, sz, prot);\n  MprotectMallocZones(addr, prot);\n  return REAL(mprotect)(addr, sz, prot);\n}\n#define INIT_MMAP                                                              \\\n  COMMON_INTERCEPT_FUNCTION(mmap);                                             \\\n  COMMON_INTERCEPT_FUNCTION(mprotect);\n#else\n#define INIT_MMAP\n#endif\n\n#if SANITIZER_INTERCEPT_MMAP64\nINTERCEPTOR(void *, mmap64, void *addr, SIZE_T sz, int prot, int flags, int fd,\n            OFF64_T off) {\n  void *ctx;\n  if (common_flags()->detect_write_exec)\n    ReportMmapWriteExec(prot);\n  if (COMMON_INTERCEPTOR_NOTHING_IS_INITIALIZED)\n    return (void *)internal_mmap(addr, sz, prot, flags, fd, off);\n  COMMON_INTERCEPTOR_ENTER(ctx, mmap64, addr, sz, prot, flags, fd, off);\n  COMMON_INTERCEPTOR_MMAP_IMPL(ctx, mmap64, addr, sz, prot, flags, fd, off);\n}\n#define INIT_MMAP64 COMMON_INTERCEPT_FUNCTION(mmap64);\n#else\n#define INIT_MMAP64\n#endif\n\n#if SANITIZER_INTERCEPT_DEVNAME\nINTERCEPTOR(char *, devname, u64 dev, u32 type) {\n  void *ctx;\n  char *name;\n  COMMON_INTERCEPTOR_ENTER(ctx, devname, dev, type);\n  name = REAL(devname)(dev, type);\n  if (name)\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, name, REAL(strlen)(name) + 1);\n  return name;\n}\n#define INIT_DEVNAME COMMON_INTERCEPT_FUNCTION(devname);\n#else\n#define INIT_DEVNAME\n#endif\n\n#if SANITIZER_INTERCEPT_DEVNAME_R\n#if SANITIZER_NETBSD\n#define DEVNAME_R_RETTYPE int\n#define DEVNAME_R_SUCCESS(x) (!(x))\n#else\n#define DEVNAME_R_RETTYPE char*\n#define DEVNAME_R_SUCCESS(x) (x)\n#endif\nINTERCEPTOR(DEVNAME_R_RETTYPE, devname_r, u64 dev, u32 type, char *path,\n            uptr len) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, devname_r, dev, type, path, len);\n  DEVNAME_R_RETTYPE res = REAL(devname_r)(dev, type, path, len);\n  if (DEVNAME_R_SUCCESS(res))\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, path, REAL(strlen)(path) + 1);\n  return res;\n}\n#define INIT_DEVNAME_R COMMON_INTERCEPT_FUNCTION(devname_r);\n#else\n#define INIT_DEVNAME_R\n#endif\n\n#if SANITIZER_INTERCEPT_FGETLN\nINTERCEPTOR(char *, fgetln, __sanitizer_FILE *stream, SIZE_T *len) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, fgetln, stream, len);\n  char *str = REAL(fgetln)(stream, len);\n  if (str && len) {\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, len, sizeof(*len));\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, str, *len);\n  }\n  return str;\n}\n#define INIT_FGETLN COMMON_INTERCEPT_FUNCTION(fgetln)\n#else\n#define INIT_FGETLN\n#endif\n\n#if SANITIZER_INTERCEPT_STRMODE\nINTERCEPTOR(void, strmode, u32 mode, char *bp) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, strmode, mode, bp);\n  REAL(strmode)(mode, bp);\n  if (bp)\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, bp, REAL(strlen)(bp) + 1);\n}\n#define INIT_STRMODE COMMON_INTERCEPT_FUNCTION(strmode)\n#else\n#define INIT_STRMODE\n#endif\n\n#if SANITIZER_INTERCEPT_TTYENT\nINTERCEPTOR(struct __sanitizer_ttyent *, getttyent, void) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, getttyent);\n  struct __sanitizer_ttyent *ttyent = REAL(getttyent)();\n  if (ttyent)\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, ttyent, struct_ttyent_sz);\n  return ttyent;\n}\nINTERCEPTOR(struct __sanitizer_ttyent *, getttynam, char *name) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, getttynam, name);\n  if (name)\n    COMMON_INTERCEPTOR_READ_RANGE(ctx, name, REAL(strlen)(name) + 1);\n  struct __sanitizer_ttyent *ttyent = REAL(getttynam)(name);\n  if (ttyent)\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, ttyent, struct_ttyent_sz);\n  return ttyent;\n}\nINTERCEPTOR(int, setttyentpath, char *path) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, setttyentpath, path);\n  if (path)\n    COMMON_INTERCEPTOR_READ_RANGE(ctx, path, REAL(strlen)(path) + 1);\n  return REAL(setttyentpath)(path);\n}\n#define INIT_TTYENT \\\n  COMMON_INTERCEPT_FUNCTION(getttyent); \\\n  COMMON_INTERCEPT_FUNCTION(getttynam); \\\n  COMMON_INTERCEPT_FUNCTION(setttyentpath)\n#else\n#define INIT_TTYENT\n#endif\n\n#if SANITIZER_INTERCEPT_PROTOENT\nstatic void write_protoent(void *ctx, struct __sanitizer_protoent *p) {\n  COMMON_INTERCEPTOR_WRITE_RANGE(ctx, p, sizeof(*p));\n\n  COMMON_INTERCEPTOR_WRITE_RANGE(ctx, p->p_name, REAL(strlen)(p->p_name) + 1);\n\n  SIZE_T pp_size = 1; // One handles the trailing \\0\n\n  for (char **pp = p->p_aliases; *pp; ++pp, ++pp_size)\n      COMMON_INTERCEPTOR_WRITE_RANGE(ctx, *pp, REAL(strlen)(*pp) + 1);\n\n  COMMON_INTERCEPTOR_WRITE_RANGE(ctx, p->p_aliases,\n                                  pp_size * sizeof(char **));\n}\n\nINTERCEPTOR(struct __sanitizer_protoent *, getprotoent) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, getprotoent);\n  struct __sanitizer_protoent *p = REAL(getprotoent)();\n  if (p)\n    write_protoent(ctx, p);\n  return p;\n}\n\nINTERCEPTOR(struct __sanitizer_protoent *, getprotobyname, const char *name) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, getprotobyname, name);\n  if (name)\n    COMMON_INTERCEPTOR_READ_RANGE(ctx, name, REAL(strlen)(name) + 1);\n  struct __sanitizer_protoent *p = REAL(getprotobyname)(name);\n  if (p)\n    write_protoent(ctx, p);\n  return p;\n}\n\nINTERCEPTOR(struct __sanitizer_protoent *, getprotobynumber, int proto) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, getprotobynumber, proto);\n  struct __sanitizer_protoent *p = REAL(getprotobynumber)(proto);\n  if (p)\n    write_protoent(ctx, p);\n  return p;\n}\n#define INIT_PROTOENT \\\n  COMMON_INTERCEPT_FUNCTION(getprotoent); \\\n  COMMON_INTERCEPT_FUNCTION(getprotobyname); \\\n  COMMON_INTERCEPT_FUNCTION(getprotobynumber)\n#else\n#define INIT_PROTOENT\n#endif\n\n#if SANITIZER_INTERCEPT_PROTOENT_R\nINTERCEPTOR(int, getprotoent_r, struct __sanitizer_protoent *result_buf,\n            char *buf, SIZE_T buflen, struct __sanitizer_protoent **result) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, getprotoent_r, result_buf, buf, buflen,\n                           result);\n  int res = REAL(getprotoent_r)(result_buf, buf, buflen, result);\n\n  COMMON_INTERCEPTOR_WRITE_RANGE(ctx, result, sizeof *result);\n  if (!res && *result)\n    write_protoent(ctx, *result);\n  return res;\n}\n\nINTERCEPTOR(int, getprotobyname_r, const char *name,\n            struct __sanitizer_protoent *result_buf, char *buf, SIZE_T buflen,\n            struct __sanitizer_protoent **result) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, getprotobyname_r, name, result_buf, buf,\n                           buflen, result);\n  if (name)\n    COMMON_INTERCEPTOR_READ_RANGE(ctx, name, REAL(strlen)(name) + 1);\n  int res = REAL(getprotobyname_r)(name, result_buf, buf, buflen, result);\n\n  COMMON_INTERCEPTOR_WRITE_RANGE(ctx, result, sizeof *result);\n  if (!res && *result)\n    write_protoent(ctx, *result);\n  return res;\n}\n\nINTERCEPTOR(int, getprotobynumber_r, int num,\n            struct __sanitizer_protoent *result_buf, char *buf,\n            SIZE_T buflen, struct __sanitizer_protoent **result) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, getprotobynumber_r, num, result_buf, buf,\n                           buflen, result);\n  int res = REAL(getprotobynumber_r)(num, result_buf, buf, buflen, result);\n\n  COMMON_INTERCEPTOR_WRITE_RANGE(ctx, result, sizeof *result);\n  if (!res && *result)\n    write_protoent(ctx, *result);\n  return res;\n}\n\n#define INIT_PROTOENT_R \\\n  COMMON_INTERCEPT_FUNCTION(getprotoent_r); \\\n  COMMON_INTERCEPT_FUNCTION(getprotobyname_r); \\\n  COMMON_INTERCEPT_FUNCTION(getprotobynumber_r);\n#else\n#define INIT_PROTOENT_R\n#endif\n\n#if SANITIZER_INTERCEPT_NETENT\nINTERCEPTOR(struct __sanitizer_netent *, getnetent) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, getnetent);\n  struct __sanitizer_netent *n = REAL(getnetent)();\n  if (n) {\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, n, sizeof(*n));\n\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, n->n_name, REAL(strlen)(n->n_name) + 1);\n\n    SIZE_T nn_size = 1; // One handles the trailing \\0\n\n    for (char **nn = n->n_aliases; *nn; ++nn, ++nn_size)\n      COMMON_INTERCEPTOR_WRITE_RANGE(ctx, *nn, REAL(strlen)(*nn) + 1);\n\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, n->n_aliases,\n                                   nn_size * sizeof(char **));\n  }\n  return n;\n}\n\nINTERCEPTOR(struct __sanitizer_netent *, getnetbyname, const char *name) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, getnetbyname, name);\n  if (name)\n    COMMON_INTERCEPTOR_READ_RANGE(ctx, name, REAL(strlen)(name) + 1);\n  struct __sanitizer_netent *n = REAL(getnetbyname)(name);\n  if (n) {\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, n, sizeof(*n));\n\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, n->n_name, REAL(strlen)(n->n_name) + 1);\n\n    SIZE_T nn_size = 1; // One handles the trailing \\0\n\n    for (char **nn = n->n_aliases; *nn; ++nn, ++nn_size)\n      COMMON_INTERCEPTOR_WRITE_RANGE(ctx, *nn, REAL(strlen)(*nn) + 1);\n\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, n->n_aliases,\n                                   nn_size * sizeof(char **));\n  }\n  return n;\n}\n\nINTERCEPTOR(struct __sanitizer_netent *, getnetbyaddr, u32 net, int type) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, getnetbyaddr, net, type);\n  struct __sanitizer_netent *n = REAL(getnetbyaddr)(net, type);\n  if (n) {\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, n, sizeof(*n));\n\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, n->n_name, REAL(strlen)(n->n_name) + 1);\n\n    SIZE_T nn_size = 1; // One handles the trailing \\0\n\n    for (char **nn = n->n_aliases; *nn; ++nn, ++nn_size)\n      COMMON_INTERCEPTOR_WRITE_RANGE(ctx, *nn, REAL(strlen)(*nn) + 1);\n\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, n->n_aliases,\n                                   nn_size * sizeof(char **));\n  }\n  return n;\n}\n#define INIT_NETENT \\\n  COMMON_INTERCEPT_FUNCTION(getnetent); \\\n  COMMON_INTERCEPT_FUNCTION(getnetbyname); \\\n  COMMON_INTERCEPT_FUNCTION(getnetbyaddr)\n#else\n#define INIT_NETENT\n#endif\n\n#if SANITIZER_INTERCEPT_GETMNTINFO\nINTERCEPTOR(int, getmntinfo, void **mntbufp, int flags) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, getmntinfo, mntbufp, flags);\n  int cnt = REAL(getmntinfo)(mntbufp, flags);\n  if (cnt > 0 && mntbufp) {\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, mntbufp, sizeof(void *));\n    if (*mntbufp)\n#if SANITIZER_NETBSD\n      COMMON_INTERCEPTOR_WRITE_RANGE(ctx, *mntbufp, cnt * struct_statvfs_sz);\n#else\n      COMMON_INTERCEPTOR_WRITE_RANGE(ctx, *mntbufp, cnt * struct_statfs_sz);\n#endif\n  }\n  return cnt;\n}\n#define INIT_GETMNTINFO COMMON_INTERCEPT_FUNCTION(getmntinfo)\n#else\n#define INIT_GETMNTINFO\n#endif\n\n#if SANITIZER_INTERCEPT_MI_VECTOR_HASH\nINTERCEPTOR(void, mi_vector_hash, const void *key, SIZE_T len, u32 seed,\n            u32 hashes[3]) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, mi_vector_hash, key, len, seed, hashes);\n  if (key)\n    COMMON_INTERCEPTOR_READ_RANGE(ctx, key, len);\n  REAL(mi_vector_hash)(key, len, seed, hashes);\n  if (hashes)\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, hashes, sizeof(hashes[0]) * 3);\n}\n#define INIT_MI_VECTOR_HASH COMMON_INTERCEPT_FUNCTION(mi_vector_hash)\n#else\n#define INIT_MI_VECTOR_HASH\n#endif\n\n#if SANITIZER_INTERCEPT_SETVBUF\nINTERCEPTOR(int, setvbuf, __sanitizer_FILE *stream, char *buf, int mode,\n  SIZE_T size) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, setvbuf, stream, buf, mode, size);\n  int ret = REAL(setvbuf)(stream, buf, mode, size);\n  if (buf)\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, buf, size);\n  if (stream)\n      unpoison_file(stream);\n  return ret;\n}\n\nINTERCEPTOR(void, setbuf, __sanitizer_FILE *stream, char *buf) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, setbuf, stream, buf);\n  REAL(setbuf)(stream, buf);\n  if (buf) {\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, buf, __sanitizer_bufsiz);\n  }\n  if (stream)\n      unpoison_file(stream);\n}\n\nINTERCEPTOR(void, setbuffer, __sanitizer_FILE *stream, char *buf, int mode) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, setbuffer, stream, buf, mode);\n  REAL(setbuffer)(stream, buf, mode);\n  if (buf) {\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, buf, __sanitizer_bufsiz);\n  }\n  if (stream)\n    unpoison_file(stream);\n}\n\nINTERCEPTOR(void, setlinebuf, __sanitizer_FILE *stream) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, setlinebuf, stream);\n  REAL(setlinebuf)(stream);\n  if (stream)\n    unpoison_file(stream);\n}\n#define INIT_SETVBUF COMMON_INTERCEPT_FUNCTION(setvbuf); \\\n    COMMON_INTERCEPT_FUNCTION(setbuf); \\\n    COMMON_INTERCEPT_FUNCTION(setbuffer); \\\n    COMMON_INTERCEPT_FUNCTION(setlinebuf)\n#else\n#define INIT_SETVBUF\n#endif\n\n#if SANITIZER_INTERCEPT_GETVFSSTAT\nINTERCEPTOR(int, getvfsstat, void *buf, SIZE_T bufsize, int flags) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, getvfsstat, buf, bufsize, flags);\n  int ret = REAL(getvfsstat)(buf, bufsize, flags);\n  if (buf && ret > 0)\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, buf, ret * struct_statvfs_sz);\n  return ret;\n}\n#define INIT_GETVFSSTAT COMMON_INTERCEPT_FUNCTION(getvfsstat)\n#else\n#define INIT_GETVFSSTAT\n#endif\n\n#if SANITIZER_INTERCEPT_REGEX\nINTERCEPTOR(int, regcomp, void *preg, const char *pattern, int cflags) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, regcomp, preg, pattern, cflags);\n  if (pattern)\n    COMMON_INTERCEPTOR_READ_RANGE(ctx, pattern, REAL(strlen)(pattern) + 1);\n  int res = REAL(regcomp)(preg, pattern, cflags);\n  if (!res)\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, preg, struct_regex_sz);\n  return res;\n}\nINTERCEPTOR(int, regexec, const void *preg, const char *string, SIZE_T nmatch,\n            struct __sanitizer_regmatch *pmatch[], int eflags) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, regexec, preg, string, nmatch, pmatch, eflags);\n  if (preg)\n    COMMON_INTERCEPTOR_READ_RANGE(ctx, preg, struct_regex_sz);\n  if (string)\n    COMMON_INTERCEPTOR_READ_RANGE(ctx, string, REAL(strlen)(string) + 1);\n  int res = REAL(regexec)(preg, string, nmatch, pmatch, eflags);\n  if (!res && pmatch)\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, pmatch, nmatch * struct_regmatch_sz);\n  return res;\n}\nINTERCEPTOR(SIZE_T, regerror, int errcode, const void *preg, char *errbuf,\n            SIZE_T errbuf_size) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, regerror, errcode, preg, errbuf, errbuf_size);\n  if (preg)\n    COMMON_INTERCEPTOR_READ_RANGE(ctx, preg, struct_regex_sz);\n  SIZE_T res = REAL(regerror)(errcode, preg, errbuf, errbuf_size);\n  if (errbuf)\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, errbuf, REAL(strlen)(errbuf) + 1);\n  return res;\n}\nINTERCEPTOR(void, regfree, const void *preg) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, regfree, preg);\n  if (preg)\n    COMMON_INTERCEPTOR_READ_RANGE(ctx, preg, struct_regex_sz);\n  REAL(regfree)(preg);\n}\n#define INIT_REGEX                                                             \\\n  COMMON_INTERCEPT_FUNCTION(regcomp);                                          \\\n  COMMON_INTERCEPT_FUNCTION_GLIBC_VER_MIN(regexec, \"GLIBC_2.3.4\");             \\\n  COMMON_INTERCEPT_FUNCTION(regerror);                                         \\\n  COMMON_INTERCEPT_FUNCTION(regfree);\n#else\n#define INIT_REGEX\n#endif\n\n#if SANITIZER_INTERCEPT_REGEXSUB\nINTERCEPTOR(SSIZE_T, regnsub, char *buf, SIZE_T bufsiz, const char *sub,\n            const struct __sanitizer_regmatch *rm, const char *str) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, regnsub, buf, bufsiz, sub, rm, str);\n  if (sub)\n    COMMON_INTERCEPTOR_READ_RANGE(ctx, sub, REAL(strlen)(sub) + 1);\n  // The implementation demands and hardcodes 10 elements\n  if (rm)\n    COMMON_INTERCEPTOR_READ_RANGE(ctx, rm, 10 * struct_regmatch_sz);\n  if (str)\n    COMMON_INTERCEPTOR_READ_RANGE(ctx, str, REAL(strlen)(str) + 1);\n  SSIZE_T res = REAL(regnsub)(buf, bufsiz, sub, rm, str);\n  if (res > 0 && buf)\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, buf, REAL(strlen)(buf) + 1);\n  return res;\n}\nINTERCEPTOR(SSIZE_T, regasub, char **buf, const char *sub,\n            const struct __sanitizer_regmatch *rm, const char *sstr) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, regasub, buf, sub, rm, sstr);\n  if (sub)\n    COMMON_INTERCEPTOR_READ_RANGE(ctx, sub, REAL(strlen)(sub) + 1);\n  // Hardcode 10 elements as this is hardcoded size\n  if (rm)\n    COMMON_INTERCEPTOR_READ_RANGE(ctx, rm, 10 * struct_regmatch_sz);\n  if (sstr)\n    COMMON_INTERCEPTOR_READ_RANGE(ctx, sstr, REAL(strlen)(sstr) + 1);\n  SSIZE_T res = REAL(regasub)(buf, sub, rm, sstr);\n  if (res > 0 && buf) {\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, buf, sizeof(char *));\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, *buf, REAL(strlen)(*buf) + 1);\n  }\n  return res;\n}\n\n#define INIT_REGEXSUB                                                          \\\n  COMMON_INTERCEPT_FUNCTION(regnsub);                                          \\\n  COMMON_INTERCEPT_FUNCTION(regasub);\n#else\n#define INIT_REGEXSUB\n#endif\n\n#if SANITIZER_INTERCEPT_FTS\nINTERCEPTOR(void *, fts_open, char *const *path_argv, int options,\n            int (*compar)(void **, void **)) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, fts_open, path_argv, options, compar);\n  if (path_argv) {\n    for (char *const *pa = path_argv; ; ++pa) {\n      COMMON_INTERCEPTOR_READ_RANGE(ctx, pa, sizeof(char **));\n      if (!*pa)\n        break;\n      COMMON_INTERCEPTOR_READ_RANGE(ctx, *pa, REAL(strlen)(*pa) + 1);\n    }\n  }\n  // TODO(kamil): handle compar callback\n  void *fts = REAL(fts_open)(path_argv, options, compar);\n  if (fts)\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, fts, struct_FTS_sz);\n  return fts;\n}\n\nINTERCEPTOR(void *, fts_read, void *ftsp) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, fts_read, ftsp);\n  if (ftsp)\n    COMMON_INTERCEPTOR_READ_RANGE(ctx, ftsp, struct_FTS_sz);\n  void *ftsent = REAL(fts_read)(ftsp);\n  if (ftsent)\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, ftsent, struct_FTSENT_sz);\n  return ftsent;\n}\n\nINTERCEPTOR(void *, fts_children, void *ftsp, int options) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, fts_children, ftsp, options);\n  if (ftsp)\n    COMMON_INTERCEPTOR_READ_RANGE(ctx, ftsp, struct_FTS_sz);\n  void *ftsent = REAL(fts_children)(ftsp, options);\n  if (ftsent)\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, ftsent, struct_FTSENT_sz);\n  return ftsent;\n}\n\nINTERCEPTOR(int, fts_set, void *ftsp, void *f, int options) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, fts_set, ftsp, f, options);\n  if (ftsp)\n    COMMON_INTERCEPTOR_READ_RANGE(ctx, ftsp, struct_FTS_sz);\n  if (f)\n    COMMON_INTERCEPTOR_READ_RANGE(ctx, f, struct_FTSENT_sz);\n  return REAL(fts_set)(ftsp, f, options);\n}\n\nINTERCEPTOR(int, fts_close, void *ftsp) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, fts_close, ftsp);\n  if (ftsp)\n    COMMON_INTERCEPTOR_READ_RANGE(ctx, ftsp, struct_FTS_sz);\n  return REAL(fts_close)(ftsp);\n}\n#define INIT_FTS                                                               \\\n  COMMON_INTERCEPT_FUNCTION(fts_open);                                         \\\n  COMMON_INTERCEPT_FUNCTION(fts_read);                                         \\\n  COMMON_INTERCEPT_FUNCTION(fts_children);                                     \\\n  COMMON_INTERCEPT_FUNCTION(fts_set);                                          \\\n  COMMON_INTERCEPT_FUNCTION(fts_close);\n#else\n#define INIT_FTS\n#endif\n\n#if SANITIZER_INTERCEPT_SYSCTL\nINTERCEPTOR(int, sysctl, int *name, unsigned int namelen, void *oldp,\n            SIZE_T *oldlenp, void *newp, SIZE_T newlen) {\n  void *ctx;\n  if (COMMON_INTERCEPTOR_NOTHING_IS_INITIALIZED)\n    return internal_sysctl(name, namelen, oldp, oldlenp, newp, newlen);\n  COMMON_INTERCEPTOR_ENTER(ctx, sysctl, name, namelen, oldp, oldlenp, newp,\n                           newlen);\n  if (name)\n    COMMON_INTERCEPTOR_READ_RANGE(ctx, name, namelen * sizeof(*name));\n  if (oldlenp)\n    COMMON_INTERCEPTOR_READ_RANGE(ctx, oldlenp, sizeof(*oldlenp));\n  if (newp && newlen)\n    COMMON_INTERCEPTOR_READ_RANGE(ctx, newp, newlen);\n  int res = REAL(sysctl)(name, namelen, oldp, oldlenp, newp, newlen);\n  if (!res) {\n    if (oldlenp) {\n      COMMON_INTERCEPTOR_WRITE_RANGE(ctx, oldlenp, sizeof(*oldlenp));\n      if (oldp)\n        COMMON_INTERCEPTOR_WRITE_RANGE(ctx, oldp, *oldlenp);\n    }\n  }\n  return res;\n}\n\nINTERCEPTOR(int, sysctlbyname, char *sname, void *oldp, SIZE_T *oldlenp,\n            void *newp, SIZE_T newlen) {\n  void *ctx;\n  if (COMMON_INTERCEPTOR_NOTHING_IS_INITIALIZED)\n    return internal_sysctlbyname(sname, oldp, oldlenp, newp, newlen);\n  COMMON_INTERCEPTOR_ENTER(ctx, sysctlbyname, sname, oldp, oldlenp, newp,\n                           newlen);\n  if (sname)\n    COMMON_INTERCEPTOR_READ_RANGE(ctx, sname, REAL(strlen)(sname) + 1);\n  if (oldlenp)\n    COMMON_INTERCEPTOR_READ_RANGE(ctx, oldlenp, sizeof(*oldlenp));\n  if (newp && newlen)\n    COMMON_INTERCEPTOR_READ_RANGE(ctx, newp, newlen);\n  int res = REAL(sysctlbyname)(sname, oldp, oldlenp, newp, newlen);\n  if (!res) {\n    if (oldlenp) {\n      COMMON_INTERCEPTOR_WRITE_RANGE(ctx, oldlenp, sizeof(*oldlenp));\n      if (oldp)\n        COMMON_INTERCEPTOR_WRITE_RANGE(ctx, oldp, *oldlenp);\n    }\n  }\n  return res;\n}\n\nINTERCEPTOR(int, sysctlnametomib, const char *sname, int *name,\n            SIZE_T *namelenp) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, sysctlnametomib, sname, name, namelenp);\n  if (sname)\n    COMMON_INTERCEPTOR_READ_RANGE(ctx, sname, REAL(strlen)(sname) + 1);\n  if (namelenp)\n    COMMON_INTERCEPTOR_READ_RANGE(ctx, namelenp, sizeof(*namelenp));\n  int res = REAL(sysctlnametomib)(sname, name, namelenp);\n  if (!res) {\n    if (namelenp) {\n      COMMON_INTERCEPTOR_WRITE_RANGE(ctx, namelenp, sizeof(*namelenp));\n      if (name)\n        COMMON_INTERCEPTOR_WRITE_RANGE(ctx, name, *namelenp * sizeof(*name));\n    }\n  }\n  return res;\n}\n\n#define INIT_SYSCTL                        \\\n  COMMON_INTERCEPT_FUNCTION(sysctl);       \\\n  COMMON_INTERCEPT_FUNCTION(sysctlbyname); \\\n  COMMON_INTERCEPT_FUNCTION(sysctlnametomib);\n#else\n#define INIT_SYSCTL\n#endif\n\n#if SANITIZER_INTERCEPT_ASYSCTL\nINTERCEPTOR(void *, asysctl, const int *name, SIZE_T namelen, SIZE_T *len) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, asysctl, name, namelen, len);\n  if (name)\n    COMMON_INTERCEPTOR_READ_RANGE(ctx, name, sizeof(*name) * namelen);\n  void *res = REAL(asysctl)(name, namelen, len);\n  if (res && len) {\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, len, sizeof(*len));\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, res, *len);\n  }\n  return res;\n}\n\nINTERCEPTOR(void *, asysctlbyname, const char *sname, SIZE_T *len) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, asysctlbyname, sname, len);\n  if (sname)\n    COMMON_INTERCEPTOR_READ_RANGE(ctx, sname, REAL(strlen)(sname) + 1);\n  void *res = REAL(asysctlbyname)(sname, len);\n  if (res && len) {\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, len, sizeof(*len));\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, res, *len);\n  }\n  return res;\n}\n#define INIT_ASYSCTL                           \\\n  COMMON_INTERCEPT_FUNCTION(asysctl);          \\\n  COMMON_INTERCEPT_FUNCTION(asysctlbyname);\n#else\n#define INIT_ASYSCTL\n#endif\n\n#if SANITIZER_INTERCEPT_SYSCTLGETMIBINFO\nINTERCEPTOR(int, sysctlgetmibinfo, char *sname, int *name,\n            unsigned int *namelenp, char *cname, SIZE_T *csz, void **rnode,\n            int v) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, sysctlgetmibinfo, sname, name, namelenp, cname,\n                           csz, rnode, v);\n  if (sname)\n    COMMON_INTERCEPTOR_READ_RANGE(ctx, sname, REAL(strlen)(sname) + 1);\n  if (namelenp)\n    COMMON_INTERCEPTOR_READ_RANGE(ctx, namelenp, sizeof(*namelenp));\n  if (csz)\n    COMMON_INTERCEPTOR_READ_RANGE(ctx, csz, sizeof(*csz));\n  // Skip rnode, it's rarely used and not trivial to sanitize\n  // It's also used mostly internally\n  int res = REAL(sysctlgetmibinfo)(sname, name, namelenp, cname, csz, rnode, v);\n  if (!res) {\n    if (namelenp) {\n      COMMON_INTERCEPTOR_WRITE_RANGE(ctx, namelenp, sizeof(*namelenp));\n      if (name)\n        COMMON_INTERCEPTOR_WRITE_RANGE(ctx, name, *namelenp * sizeof(*name));\n    }\n    if (csz) {\n      COMMON_INTERCEPTOR_WRITE_RANGE(ctx, csz, sizeof(*csz));\n      if (cname)\n        COMMON_INTERCEPTOR_WRITE_RANGE(ctx, cname, *csz);\n    }\n  }\n  return res;\n}\n#define INIT_SYSCTLGETMIBINFO                  \\\n  COMMON_INTERCEPT_FUNCTION(sysctlgetmibinfo);\n#else\n#define INIT_SYSCTLGETMIBINFO\n#endif\n\n#if SANITIZER_INTERCEPT_NL_LANGINFO\nINTERCEPTOR(char *, nl_langinfo, long item) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, nl_langinfo, item);\n  char *ret = REAL(nl_langinfo)(item);\n  if (ret)\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, ret, REAL(strlen)(ret) + 1);\n  return ret;\n}\n#define INIT_NL_LANGINFO COMMON_INTERCEPT_FUNCTION(nl_langinfo)\n#else\n#define INIT_NL_LANGINFO\n#endif\n\n#if SANITIZER_INTERCEPT_MODCTL\nINTERCEPTOR(int, modctl, int operation, void *argp) {\n  void *ctx;\n  int ret;\n  COMMON_INTERCEPTOR_ENTER(ctx, modctl, operation, argp);\n\n  if (operation == modctl_load) {\n    if (argp) {\n      __sanitizer_modctl_load_t *ml = (__sanitizer_modctl_load_t *)argp;\n      COMMON_INTERCEPTOR_READ_RANGE(ctx, ml, sizeof(*ml));\n      if (ml->ml_filename)\n        COMMON_INTERCEPTOR_READ_RANGE(ctx, ml->ml_filename,\n                                      REAL(strlen)(ml->ml_filename) + 1);\n      if (ml->ml_props)\n        COMMON_INTERCEPTOR_READ_RANGE(ctx, ml->ml_props, ml->ml_propslen);\n    }\n    ret = REAL(modctl)(operation, argp);\n  } else if (operation == modctl_unload) {\n    if (argp) {\n      const char *name = (const char *)argp;\n      COMMON_INTERCEPTOR_READ_RANGE(ctx, name, REAL(strlen)(name) + 1);\n    }\n    ret = REAL(modctl)(operation, argp);\n  } else if (operation == modctl_stat) {\n    uptr iov_len;\n    struct __sanitizer_iovec *iov = (struct __sanitizer_iovec *)argp;\n    if (iov) {\n      COMMON_INTERCEPTOR_READ_RANGE(ctx, iov, sizeof(*iov));\n      iov_len = iov->iov_len;\n    }\n    ret = REAL(modctl)(operation, argp);\n    if (iov)\n      COMMON_INTERCEPTOR_WRITE_RANGE(\n          ctx, iov->iov_base, Min(iov_len,  iov->iov_len));\n  } else if (operation == modctl_exists) {\n    ret = REAL(modctl)(operation, argp);\n  } else {\n    ret = REAL(modctl)(operation, argp);\n  }\n\n  return ret;\n}\n#define INIT_MODCTL COMMON_INTERCEPT_FUNCTION(modctl)\n#else\n#define INIT_MODCTL\n#endif\n\n#if SANITIZER_INTERCEPT_STRTONUM\nINTERCEPTOR(long long, strtonum, const char *nptr, long long minval,\n            long long maxval, const char **errstr) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, strtonum, nptr, minval, maxval, errstr);\n\n  // TODO(kamil): Implement strtoll as a common inteceptor\n  char *real_endptr;\n  long long ret = (long long)REAL(strtoimax)(nptr, &real_endptr, 10);\n  StrtolFixAndCheck(ctx, nptr, nullptr, real_endptr, 10);\n\n  ret = REAL(strtonum)(nptr, minval, maxval, errstr);\n  if (errstr) {\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, errstr, sizeof(const char *));\n     if (*errstr)\n      COMMON_INTERCEPTOR_WRITE_RANGE(ctx, *errstr, REAL(strlen)(*errstr) + 1);\n  }\n  return ret;\n}\n#define INIT_STRTONUM COMMON_INTERCEPT_FUNCTION(strtonum)\n#else\n#define INIT_STRTONUM\n#endif\n\n#if SANITIZER_INTERCEPT_FPARSELN\nINTERCEPTOR(char *, fparseln, __sanitizer_FILE *stream, SIZE_T *len,\n            SIZE_T *lineno, const char delim[3], int flags) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, fparseln, stream, len, lineno, delim, flags);\n  if (lineno)\n    COMMON_INTERCEPTOR_READ_RANGE(ctx, lineno, sizeof(*lineno));\n  if (delim)\n    COMMON_INTERCEPTOR_READ_RANGE(ctx, delim, sizeof(delim[0]) * 3);\n  char *ret = REAL(fparseln)(stream, len, lineno, delim, flags);\n  if (ret) {\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, ret, REAL(strlen)(ret) + 1);\n    if (len)\n      COMMON_INTERCEPTOR_WRITE_RANGE(ctx, len, sizeof(*len));\n    if (lineno)\n      COMMON_INTERCEPTOR_WRITE_RANGE(ctx, lineno, sizeof(*lineno));\n  }\n  return ret;\n}\n#define INIT_FPARSELN COMMON_INTERCEPT_FUNCTION(fparseln)\n#else\n#define INIT_FPARSELN\n#endif\n\n#if SANITIZER_INTERCEPT_STATVFS1\nINTERCEPTOR(int, statvfs1, const char *path, void *buf, int flags) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, statvfs1, path, buf, flags);\n  if (path) COMMON_INTERCEPTOR_READ_RANGE(ctx, path, REAL(strlen)(path) + 1);\n  int res = REAL(statvfs1)(path, buf, flags);\n  if (!res) COMMON_INTERCEPTOR_WRITE_RANGE(ctx, buf, struct_statvfs_sz);\n  return res;\n}\nINTERCEPTOR(int, fstatvfs1, int fd, void *buf, int flags) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, fstatvfs1, fd, buf, flags);\n  COMMON_INTERCEPTOR_FD_ACCESS(ctx, fd);\n  int res = REAL(fstatvfs1)(fd, buf, flags);\n  if (!res) {\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, buf, struct_statvfs_sz);\n    if (fd >= 0)\n      COMMON_INTERCEPTOR_FD_ACQUIRE(ctx, fd);\n  }\n  return res;\n}\n#define INIT_STATVFS1                  \\\n  COMMON_INTERCEPT_FUNCTION(statvfs1);  \\\n  COMMON_INTERCEPT_FUNCTION(fstatvfs1);\n#else\n#define INIT_STATVFS1\n#endif\n\n#if SANITIZER_INTERCEPT_STRTOI\nINTERCEPTOR(INTMAX_T, strtoi, const char *nptr, char **endptr, int base,\n            INTMAX_T low, INTMAX_T high, int *rstatus) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, strtoi, nptr, endptr, base, low, high, rstatus);\n  char *real_endptr;\n  INTMAX_T ret = REAL(strtoi)(nptr, &real_endptr, base, low, high, rstatus);\n  StrtolFixAndCheck(ctx, nptr, endptr, real_endptr, base);\n  if (rstatus)\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, rstatus, sizeof(*rstatus));\n  return ret;\n}\n\nINTERCEPTOR(UINTMAX_T, strtou, const char *nptr, char **endptr, int base,\n            UINTMAX_T low, UINTMAX_T high, int *rstatus) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, strtou, nptr, endptr, base, low, high, rstatus);\n  char *real_endptr;\n  UINTMAX_T ret = REAL(strtou)(nptr, &real_endptr, base, low, high, rstatus);\n  StrtolFixAndCheck(ctx, nptr, endptr, real_endptr, base);\n  if (rstatus)\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, rstatus, sizeof(*rstatus));\n  return ret;\n}\n#define INIT_STRTOI                                                            \\\n  COMMON_INTERCEPT_FUNCTION(strtoi);                                           \\\n  COMMON_INTERCEPT_FUNCTION(strtou)\n#else\n#define INIT_STRTOI\n#endif\n\n#if SANITIZER_INTERCEPT_CAPSICUM\n#define CAP_RIGHTS_INIT_INTERCEPTOR(cap_rights_init, rights, ...)          \\\n  {                                                                        \\\n    void *ctx;                                                             \\\n    COMMON_INTERCEPTOR_ENTER(ctx, cap_rights_init, rights, ##__VA_ARGS__); \\\n    if (rights)                                                            \\\n      COMMON_INTERCEPTOR_READ_RANGE(ctx, rights, sizeof(*rights));         \\\n    __sanitizer_cap_rights_t *ret =                                        \\\n        REAL(cap_rights_init)(rights, ##__VA_ARGS__);                      \\\n    if (ret)                                                               \\\n      COMMON_INTERCEPTOR_WRITE_RANGE(ctx, ret, sizeof(*ret));              \\\n    return ret;                                                            \\\n  }\n\n#define CAP_RIGHTS_SET_INTERCEPTOR(cap_rights_set, rights, ...)           \\\n  {                                                                       \\\n    void *ctx;                                                            \\\n    COMMON_INTERCEPTOR_ENTER(ctx, cap_rights_set, rights, ##__VA_ARGS__); \\\n    if (rights)                                                           \\\n      COMMON_INTERCEPTOR_READ_RANGE(ctx, rights, sizeof(*rights));        \\\n    __sanitizer_cap_rights_t *ret =                                       \\\n        REAL(cap_rights_set)(rights, ##__VA_ARGS__);                      \\\n    if (ret)                                                              \\\n      COMMON_INTERCEPTOR_WRITE_RANGE(ctx, ret, sizeof(*ret));             \\\n    return ret;                                                           \\\n  }\n\n#define CAP_RIGHTS_CLEAR_INTERCEPTOR(cap_rights_clear, rights, ...)         \\\n  {                                                                         \\\n    void *ctx;                                                              \\\n    COMMON_INTERCEPTOR_ENTER(ctx, cap_rights_clear, rights, ##__VA_ARGS__); \\\n    if (rights)                                                             \\\n      COMMON_INTERCEPTOR_READ_RANGE(ctx, rights, sizeof(*rights));          \\\n    __sanitizer_cap_rights_t *ret =                                         \\\n        REAL(cap_rights_clear)(rights, ##__VA_ARGS__);                      \\\n    if (ret)                                                                \\\n      COMMON_INTERCEPTOR_WRITE_RANGE(ctx, ret, sizeof(*ret));               \\\n    return ret;                                                             \\\n  }\n\n#define CAP_RIGHTS_IS_SET_INTERCEPTOR(cap_rights_is_set, rights, ...)        \\\n  {                                                                          \\\n    void *ctx;                                                               \\\n    COMMON_INTERCEPTOR_ENTER(ctx, cap_rights_is_set, rights, ##__VA_ARGS__); \\\n    if (rights)                                                              \\\n      COMMON_INTERCEPTOR_READ_RANGE(ctx, rights, sizeof(*rights));           \\\n    return REAL(cap_rights_is_set)(rights, ##__VA_ARGS__);                   \\\n  }\n\nINTERCEPTOR(__sanitizer_cap_rights_t *, cap_rights_init,\n            __sanitizer_cap_rights_t *rights) {\n  CAP_RIGHTS_INIT_INTERCEPTOR(cap_rights_init, rights);\n}\n\nINTERCEPTOR(__sanitizer_cap_rights_t *, cap_rights_set,\n            __sanitizer_cap_rights_t *rights) {\n  CAP_RIGHTS_SET_INTERCEPTOR(cap_rights_set, rights);\n}\n\nINTERCEPTOR(__sanitizer_cap_rights_t *, cap_rights_clear,\n            __sanitizer_cap_rights_t *rights) {\n  CAP_RIGHTS_CLEAR_INTERCEPTOR(cap_rights_clear, rights);\n}\n\nINTERCEPTOR(bool, cap_rights_is_set,\n            __sanitizer_cap_rights_t *rights) {\n  CAP_RIGHTS_IS_SET_INTERCEPTOR(cap_rights_is_set, rights);\n}\n\nINTERCEPTOR(int, cap_rights_limit, int fd,\n            const __sanitizer_cap_rights_t *rights) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, cap_rights_limit, fd, rights);\n  if (rights)\n    COMMON_INTERCEPTOR_READ_RANGE(ctx, rights, sizeof(*rights));\n\n  return REAL(cap_rights_limit)(fd, rights);\n}\n\nINTERCEPTOR(int, cap_rights_get, int fd, __sanitizer_cap_rights_t *rights) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, cap_rights_get, fd, rights);\n  int ret = REAL(cap_rights_get)(fd, rights);\n  if (!ret && rights)\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, rights, sizeof(*rights));\n\n  return ret;\n}\n\nINTERCEPTOR(bool, cap_rights_is_valid, const __sanitizer_cap_rights_t *rights) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, cap_rights_is_valid, rights);\n  if (rights)\n    COMMON_INTERCEPTOR_READ_RANGE(ctx, rights, sizeof(*rights));\n\n  return REAL(cap_rights_is_valid(rights));\n}\n\nINTERCEPTOR(__sanitizer_cap_rights *, cap_rights_merge,\n  __sanitizer_cap_rights *dst, const __sanitizer_cap_rights *src) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, cap_rights_merge, dst, src);\n  if (src)\n    COMMON_INTERCEPTOR_READ_RANGE(ctx, src, sizeof(*src));\n\n  __sanitizer_cap_rights *ret = REAL(cap_rights_merge)(dst, src);\n  if (dst)\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, dst, sizeof(*dst));\n\n  return ret;\n}\n\nINTERCEPTOR(__sanitizer_cap_rights *, cap_rights_remove,\n  __sanitizer_cap_rights *dst, const __sanitizer_cap_rights *src) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, cap_rights_remove, dst, src);\n  if (src)\n    COMMON_INTERCEPTOR_READ_RANGE(ctx, src, sizeof(*src));\n\n  __sanitizer_cap_rights *ret = REAL(cap_rights_remove)(dst, src);\n  if (dst)\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, dst, sizeof(*dst));\n\n  return ret;\n}\n\nINTERCEPTOR(bool, cap_rights_contains, const __sanitizer_cap_rights *big,\n  const __sanitizer_cap_rights *little) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, cap_rights_contains, big, little);\n  if (little)\n    COMMON_INTERCEPTOR_READ_RANGE(ctx, little, sizeof(*little));\n  if (big)\n    COMMON_INTERCEPTOR_READ_RANGE(ctx, big, sizeof(*big));\n\n  return REAL(cap_rights_contains)(big, little);\n}\n\nINTERCEPTOR(int, cap_ioctls_limit, int fd, const uptr *cmds, SIZE_T ncmds) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, cap_ioctls_limit, fd, cmds, ncmds);\n  if (cmds)\n    COMMON_INTERCEPTOR_READ_RANGE(ctx, cmds, sizeof(*cmds) * ncmds);\n\n  return REAL(cap_ioctls_limit)(fd, cmds, ncmds);\n}\n\nINTERCEPTOR(int, cap_ioctls_get, int fd, uptr *cmds, SIZE_T maxcmds) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, cap_ioctls_get, fd, cmds, maxcmds);\n  int ret = REAL(cap_ioctls_get)(fd, cmds, maxcmds);\n  if (!ret && cmds)\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, cmds, sizeof(*cmds) * maxcmds);\n\n  return ret;\n}\n#define INIT_CAPSICUM                          \\\n  COMMON_INTERCEPT_FUNCTION(cap_rights_init); \\\n  COMMON_INTERCEPT_FUNCTION(cap_rights_set); \\\n  COMMON_INTERCEPT_FUNCTION(cap_rights_clear); \\\n  COMMON_INTERCEPT_FUNCTION(cap_rights_is_set); \\\n  COMMON_INTERCEPT_FUNCTION(cap_rights_get);   \\\n  COMMON_INTERCEPT_FUNCTION(cap_rights_limit); \\\n  COMMON_INTERCEPT_FUNCTION(cap_rights_contains); \\\n  COMMON_INTERCEPT_FUNCTION(cap_rights_remove); \\\n  COMMON_INTERCEPT_FUNCTION(cap_rights_merge); \\\n  COMMON_INTERCEPT_FUNCTION(cap_rights_is_valid); \\\n  COMMON_INTERCEPT_FUNCTION(cap_ioctls_get);   \\\n  COMMON_INTERCEPT_FUNCTION(cap_ioctls_limit)\n#else\n#define INIT_CAPSICUM\n#endif\n\n#if SANITIZER_INTERCEPT_SHA1\nINTERCEPTOR(void, SHA1Init, void *context) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, SHA1Init, context);\n  REAL(SHA1Init)(context);\n  if (context)\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, context, SHA1_CTX_sz);\n}\nINTERCEPTOR(void, SHA1Update, void *context, const u8 *data, unsigned len) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, SHA1Update, context, data, len);\n  if (data && len > 0)\n    COMMON_INTERCEPTOR_READ_RANGE(ctx, data, len);\n  if (context)\n    COMMON_INTERCEPTOR_READ_RANGE(ctx, context, SHA1_CTX_sz);\n  REAL(SHA1Update)(context, data, len);\n  if (context)\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, context, SHA1_CTX_sz);\n}\nINTERCEPTOR(void, SHA1Final, u8 digest[20], void *context) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, SHA1Final, digest, context);\n  if (context)\n    COMMON_INTERCEPTOR_READ_RANGE(ctx, context, SHA1_CTX_sz);\n  REAL(SHA1Final)(digest, context);\n  if (digest)\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, digest, sizeof(u8) * 20);\n}\nINTERCEPTOR(void, SHA1Transform, u32 state[5], u8 buffer[64]) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, SHA1Transform, state, buffer);\n  if (state)\n    COMMON_INTERCEPTOR_READ_RANGE(ctx, state, sizeof(u32) * 5);\n  if (buffer)\n    COMMON_INTERCEPTOR_READ_RANGE(ctx, buffer, sizeof(u8) * 64);\n  REAL(SHA1Transform)(state, buffer);\n  if (state)\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, state, sizeof(u32) * 5);\n}\nINTERCEPTOR(char *, SHA1End, void *context, char *buf) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, SHA1End, context, buf);\n  if (context)\n    COMMON_INTERCEPTOR_READ_RANGE(ctx, context, SHA1_CTX_sz);\n  char *ret = REAL(SHA1End)(context, buf);\n  if (ret)\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, ret, SHA1_return_length);\n  return ret;\n}\nINTERCEPTOR(char *, SHA1File, char *filename, char *buf) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, SHA1File, filename, buf);\n  if (filename)\n    COMMON_INTERCEPTOR_READ_RANGE(ctx, filename, REAL(strlen)(filename) + 1);\n  char *ret = REAL(SHA1File)(filename, buf);\n  if (ret)\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, ret, SHA1_return_length);\n  return ret;\n}\nINTERCEPTOR(char *, SHA1FileChunk, char *filename, char *buf, OFF_T offset,\n  OFF_T length) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, SHA1FileChunk, filename, buf, offset, length);\n  if (filename)\n    COMMON_INTERCEPTOR_READ_RANGE(ctx, filename, REAL(strlen)(filename) + 1);\n  char *ret = REAL(SHA1FileChunk)(filename, buf, offset, length);\n  if (ret)\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, ret, SHA1_return_length);\n  return ret;\n}\nINTERCEPTOR(char *, SHA1Data, u8 *data, SIZE_T len, char *buf) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, SHA1Data, data, len, buf);\n  if (data)\n    COMMON_INTERCEPTOR_READ_RANGE(ctx, data, len);\n  char *ret = REAL(SHA1Data)(data, len, buf);\n  if (ret)\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, ret, SHA1_return_length);\n  return ret;\n}\n#define INIT_SHA1                                                              \\\n  COMMON_INTERCEPT_FUNCTION(SHA1Init);                                         \\\n  COMMON_INTERCEPT_FUNCTION(SHA1Update);                                       \\\n  COMMON_INTERCEPT_FUNCTION(SHA1Final);                                        \\\n  COMMON_INTERCEPT_FUNCTION(SHA1Transform);                                    \\\n  COMMON_INTERCEPT_FUNCTION(SHA1End);                                          \\\n  COMMON_INTERCEPT_FUNCTION(SHA1File);                                         \\\n  COMMON_INTERCEPT_FUNCTION(SHA1FileChunk);                                    \\\n  COMMON_INTERCEPT_FUNCTION(SHA1Data)\n#else\n#define INIT_SHA1\n#endif\n\n#if SANITIZER_INTERCEPT_MD4\nINTERCEPTOR(void, MD4Init, void *context) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, MD4Init, context);\n  REAL(MD4Init)(context);\n  if (context)\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, context, MD4_CTX_sz);\n}\n\nINTERCEPTOR(void, MD4Update, void *context, const unsigned char *data,\n            unsigned int len) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, MD4Update, context, data, len);\n  if (data && len > 0)\n    COMMON_INTERCEPTOR_READ_RANGE(ctx, data, len);\n  if (context)\n    COMMON_INTERCEPTOR_READ_RANGE(ctx, context, MD4_CTX_sz);\n  REAL(MD4Update)(context, data, len);\n  if (context)\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, context, MD4_CTX_sz);\n}\n\nINTERCEPTOR(void, MD4Final, unsigned char digest[16], void *context) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, MD4Final, digest, context);\n  if (context)\n    COMMON_INTERCEPTOR_READ_RANGE(ctx, context, MD4_CTX_sz);\n  REAL(MD4Final)(digest, context);\n  if (digest)\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, digest, sizeof(unsigned char) * 16);\n}\n\nINTERCEPTOR(char *, MD4End, void *context, char *buf) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, MD4End, context, buf);\n  if (context)\n    COMMON_INTERCEPTOR_READ_RANGE(ctx, context, MD4_CTX_sz);\n  char *ret = REAL(MD4End)(context, buf);\n  if (ret)\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, ret, MD4_return_length);\n  return ret;\n}\n\nINTERCEPTOR(char *, MD4File, const char *filename, char *buf) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, MD4File, filename, buf);\n  if (filename)\n    COMMON_INTERCEPTOR_READ_RANGE(ctx, filename, REAL(strlen)(filename) + 1);\n  char *ret = REAL(MD4File)(filename, buf);\n  if (ret)\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, ret, MD4_return_length);\n  return ret;\n}\n\nINTERCEPTOR(char *, MD4Data, const unsigned char *data, unsigned int len,\n            char *buf) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, MD4Data, data, len, buf);\n  if (data && len > 0)\n    COMMON_INTERCEPTOR_READ_RANGE(ctx, data, len);\n  char *ret = REAL(MD4Data)(data, len, buf);\n  if (ret)\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, ret, MD4_return_length);\n  return ret;\n}\n\n#define INIT_MD4                                                               \\\n  COMMON_INTERCEPT_FUNCTION(MD4Init);                                          \\\n  COMMON_INTERCEPT_FUNCTION(MD4Update);                                        \\\n  COMMON_INTERCEPT_FUNCTION(MD4Final);                                         \\\n  COMMON_INTERCEPT_FUNCTION(MD4End);                                           \\\n  COMMON_INTERCEPT_FUNCTION(MD4File);                                          \\\n  COMMON_INTERCEPT_FUNCTION(MD4Data)\n#else\n#define INIT_MD4\n#endif\n\n#if SANITIZER_INTERCEPT_RMD160\nINTERCEPTOR(void, RMD160Init, void *context) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, RMD160Init, context);\n  REAL(RMD160Init)(context);\n  if (context)\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, context, RMD160_CTX_sz);\n}\nINTERCEPTOR(void, RMD160Update, void *context, const u8 *data, unsigned len) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, RMD160Update, context, data, len);\n  if (data && len > 0)\n    COMMON_INTERCEPTOR_READ_RANGE(ctx, data, len);\n  if (context)\n    COMMON_INTERCEPTOR_READ_RANGE(ctx, context, RMD160_CTX_sz);\n  REAL(RMD160Update)(context, data, len);\n  if (context)\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, context, RMD160_CTX_sz);\n}\nINTERCEPTOR(void, RMD160Final, u8 digest[20], void *context) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, RMD160Final, digest, context);\n  if (context)\n    COMMON_INTERCEPTOR_READ_RANGE(ctx, context, RMD160_CTX_sz);\n  REAL(RMD160Final)(digest, context);\n  if (digest)\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, digest, sizeof(u8) * 20);\n}\nINTERCEPTOR(void, RMD160Transform, u32 state[5], u16 buffer[16]) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, RMD160Transform, state, buffer);\n  if (state)\n    COMMON_INTERCEPTOR_READ_RANGE(ctx, state, sizeof(u32) * 5);\n  if (buffer)\n    COMMON_INTERCEPTOR_READ_RANGE(ctx, buffer, sizeof(u32) * 16);\n  REAL(RMD160Transform)(state, buffer);\n  if (state)\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, state, sizeof(u32) * 5);\n}\nINTERCEPTOR(char *, RMD160End, void *context, char *buf) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, RMD160End, context, buf);\n  if (context)\n    COMMON_INTERCEPTOR_READ_RANGE(ctx, context, RMD160_CTX_sz);\n  char *ret = REAL(RMD160End)(context, buf);\n  if (ret)\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, ret, RMD160_return_length);\n  return ret;\n}\nINTERCEPTOR(char *, RMD160File, char *filename, char *buf) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, RMD160File, filename, buf);\n  if (filename)\n    COMMON_INTERCEPTOR_READ_RANGE(ctx, filename, REAL(strlen)(filename) + 1);\n  char *ret = REAL(RMD160File)(filename, buf);\n  if (ret)\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, ret, RMD160_return_length);\n  return ret;\n}\nINTERCEPTOR(char *, RMD160FileChunk, char *filename, char *buf, OFF_T offset,\n  OFF_T length) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, RMD160FileChunk, filename, buf, offset, length);\n  if (filename)\n    COMMON_INTERCEPTOR_READ_RANGE(ctx, filename, REAL(strlen)(filename) + 1);\n  char *ret = REAL(RMD160FileChunk)(filename, buf, offset, length);\n  if (ret)\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, ret, RMD160_return_length);\n  return ret;\n}\nINTERCEPTOR(char *, RMD160Data, u8 *data, SIZE_T len, char *buf) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, RMD160Data, data, len, buf);\n  if (data && len > 0)\n    COMMON_INTERCEPTOR_READ_RANGE(ctx, data, len);\n  char *ret = REAL(RMD160Data)(data, len, buf);\n  if (ret)\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, ret, RMD160_return_length);\n  return ret;\n}\n#define INIT_RMD160                                                            \\\n  COMMON_INTERCEPT_FUNCTION(RMD160Init);                                       \\\n  COMMON_INTERCEPT_FUNCTION(RMD160Update);                                     \\\n  COMMON_INTERCEPT_FUNCTION(RMD160Final);                                      \\\n  COMMON_INTERCEPT_FUNCTION(RMD160Transform);                                  \\\n  COMMON_INTERCEPT_FUNCTION(RMD160End);                                        \\\n  COMMON_INTERCEPT_FUNCTION(RMD160File);                                       \\\n  COMMON_INTERCEPT_FUNCTION(RMD160FileChunk);                                  \\\n  COMMON_INTERCEPT_FUNCTION(RMD160Data)\n#else\n#define INIT_RMD160\n#endif\n\n#if SANITIZER_INTERCEPT_MD5\nINTERCEPTOR(void, MD5Init, void *context) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, MD5Init, context);\n  REAL(MD5Init)(context);\n  if (context)\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, context, MD5_CTX_sz);\n}\n\nINTERCEPTOR(void, MD5Update, void *context, const unsigned char *data,\n            unsigned int len) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, MD5Update, context, data, len);\n  if (data && len > 0)\n    COMMON_INTERCEPTOR_READ_RANGE(ctx, data, len);\n  if (context)\n    COMMON_INTERCEPTOR_READ_RANGE(ctx, context, MD5_CTX_sz);\n  REAL(MD5Update)(context, data, len);\n  if (context)\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, context, MD5_CTX_sz);\n}\n\nINTERCEPTOR(void, MD5Final, unsigned char digest[16], void *context) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, MD5Final, digest, context);\n  if (context)\n    COMMON_INTERCEPTOR_READ_RANGE(ctx, context, MD5_CTX_sz);\n  REAL(MD5Final)(digest, context);\n  if (digest)\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, digest, sizeof(unsigned char) * 16);\n}\n\nINTERCEPTOR(char *, MD5End, void *context, char *buf) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, MD5End, context, buf);\n  if (context)\n    COMMON_INTERCEPTOR_READ_RANGE(ctx, context, MD5_CTX_sz);\n  char *ret = REAL(MD5End)(context, buf);\n  if (ret)\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, ret, MD5_return_length);\n  return ret;\n}\n\nINTERCEPTOR(char *, MD5File, const char *filename, char *buf) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, MD5File, filename, buf);\n  if (filename)\n    COMMON_INTERCEPTOR_READ_RANGE(ctx, filename, REAL(strlen)(filename) + 1);\n  char *ret = REAL(MD5File)(filename, buf);\n  if (ret)\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, ret, MD5_return_length);\n  return ret;\n}\n\nINTERCEPTOR(char *, MD5Data, const unsigned char *data, unsigned int len,\n            char *buf) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, MD5Data, data, len, buf);\n  if (data && len > 0)\n    COMMON_INTERCEPTOR_READ_RANGE(ctx, data, len);\n  char *ret = REAL(MD5Data)(data, len, buf);\n  if (ret)\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, ret, MD5_return_length);\n  return ret;\n}\n\n#define INIT_MD5                                                               \\\n  COMMON_INTERCEPT_FUNCTION(MD5Init);                                          \\\n  COMMON_INTERCEPT_FUNCTION(MD5Update);                                        \\\n  COMMON_INTERCEPT_FUNCTION(MD5Final);                                         \\\n  COMMON_INTERCEPT_FUNCTION(MD5End);                                           \\\n  COMMON_INTERCEPT_FUNCTION(MD5File);                                          \\\n  COMMON_INTERCEPT_FUNCTION(MD5Data)\n#else\n#define INIT_MD5\n#endif\n\n#if SANITIZER_INTERCEPT_FSEEK\nINTERCEPTOR(int, fseek, __sanitizer_FILE *stream, long int offset, int whence) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, fseek, stream, offset, whence);\n  return REAL(fseek)(stream, offset, whence);\n}\nINTERCEPTOR(int, fseeko, __sanitizer_FILE *stream, OFF_T offset, int whence) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, fseeko, stream, offset, whence);\n  return REAL(fseeko)(stream, offset, whence);\n}\nINTERCEPTOR(long int, ftell, __sanitizer_FILE *stream) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, ftell, stream);\n  return REAL(ftell)(stream);\n}\nINTERCEPTOR(OFF_T, ftello, __sanitizer_FILE *stream) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, ftello, stream);\n  return REAL(ftello)(stream);\n}\nINTERCEPTOR(void, rewind, __sanitizer_FILE *stream) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, rewind, stream);\n  return REAL(rewind)(stream);\n}\nINTERCEPTOR(int, fgetpos, __sanitizer_FILE *stream, void *pos) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, fgetpos, stream, pos);\n  int ret = REAL(fgetpos)(stream, pos);\n  if (pos && !ret)\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, pos, fpos_t_sz);\n  return ret;\n}\nINTERCEPTOR(int, fsetpos, __sanitizer_FILE *stream, const void *pos) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, fsetpos, stream, pos);\n  if (pos)\n    COMMON_INTERCEPTOR_READ_RANGE(ctx, pos, fpos_t_sz);\n  return REAL(fsetpos)(stream, pos);\n}\n#define INIT_FSEEK \\\n  COMMON_INTERCEPT_FUNCTION(fseek); \\\n  COMMON_INTERCEPT_FUNCTION(fseeko); \\\n  COMMON_INTERCEPT_FUNCTION(ftell); \\\n  COMMON_INTERCEPT_FUNCTION(ftello); \\\n  COMMON_INTERCEPT_FUNCTION(rewind); \\\n  COMMON_INTERCEPT_FUNCTION(fgetpos); \\\n  COMMON_INTERCEPT_FUNCTION(fsetpos)\n#else\n#define INIT_FSEEK\n#endif\n\n#if SANITIZER_INTERCEPT_MD2\nINTERCEPTOR(void, MD2Init, void *context) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, MD2Init, context);\n  REAL(MD2Init)(context);\n  if (context)\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, context, MD2_CTX_sz);\n}\n\nINTERCEPTOR(void, MD2Update, void *context, const unsigned char *data,\n            unsigned int len) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, MD2Update, context, data, len);\n  if (data && len > 0)\n    COMMON_INTERCEPTOR_READ_RANGE(ctx, data, len);\n  if (context)\n    COMMON_INTERCEPTOR_READ_RANGE(ctx, context, MD2_CTX_sz);\n  REAL(MD2Update)(context, data, len);\n  if (context)\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, context, MD2_CTX_sz);\n}\n\nINTERCEPTOR(void, MD2Final, unsigned char digest[16], void *context) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, MD2Final, digest, context);\n  if (context)\n    COMMON_INTERCEPTOR_READ_RANGE(ctx, context, MD2_CTX_sz);\n  REAL(MD2Final)(digest, context);\n  if (digest)\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, digest, sizeof(unsigned char) * 16);\n}\n\nINTERCEPTOR(char *, MD2End, void *context, char *buf) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, MD2End, context, buf);\n  if (context)\n    COMMON_INTERCEPTOR_READ_RANGE(ctx, context, MD2_CTX_sz);\n  char *ret = REAL(MD2End)(context, buf);\n  if (ret)\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, ret, MD2_return_length);\n  return ret;\n}\n\nINTERCEPTOR(char *, MD2File, const char *filename, char *buf) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, MD2File, filename, buf);\n  if (filename)\n    COMMON_INTERCEPTOR_READ_RANGE(ctx, filename, REAL(strlen)(filename) + 1);\n  char *ret = REAL(MD2File)(filename, buf);\n  if (ret)\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, ret, MD2_return_length);\n  return ret;\n}\n\nINTERCEPTOR(char *, MD2Data, const unsigned char *data, unsigned int len,\n            char *buf) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, MD2Data, data, len, buf);\n  if (data && len > 0)\n    COMMON_INTERCEPTOR_READ_RANGE(ctx, data, len);\n  char *ret = REAL(MD2Data)(data, len, buf);\n  if (ret)\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, ret, MD2_return_length);\n  return ret;\n}\n\n#define INIT_MD2                                                               \\\n  COMMON_INTERCEPT_FUNCTION(MD2Init);                                          \\\n  COMMON_INTERCEPT_FUNCTION(MD2Update);                                        \\\n  COMMON_INTERCEPT_FUNCTION(MD2Final);                                         \\\n  COMMON_INTERCEPT_FUNCTION(MD2End);                                           \\\n  COMMON_INTERCEPT_FUNCTION(MD2File);                                          \\\n  COMMON_INTERCEPT_FUNCTION(MD2Data)\n#else\n#define INIT_MD2\n#endif\n\n#if SANITIZER_INTERCEPT_SHA2\n#define SHA2_INTERCEPTORS(LEN, SHA2_STATE_T) \\\n  INTERCEPTOR(void, SHA##LEN##_Init, void *context) { \\\n    void *ctx; \\\n    COMMON_INTERCEPTOR_ENTER(ctx, SHA##LEN##_Init, context); \\\n    REAL(SHA##LEN##_Init)(context); \\\n    if (context) \\\n      COMMON_INTERCEPTOR_WRITE_RANGE(ctx, context, SHA##LEN##_CTX_sz); \\\n  } \\\n  INTERCEPTOR(void, SHA##LEN##_Update, void *context, \\\n              const u8 *data, SIZE_T len) { \\\n    void *ctx; \\\n    COMMON_INTERCEPTOR_ENTER(ctx, SHA##LEN##_Update, context, data, len); \\\n    if (data && len > 0) \\\n      COMMON_INTERCEPTOR_READ_RANGE(ctx, data, len); \\\n    if (context) \\\n      COMMON_INTERCEPTOR_READ_RANGE(ctx, context, SHA##LEN##_CTX_sz); \\\n    REAL(SHA##LEN##_Update)(context, data, len); \\\n    if (context) \\\n      COMMON_INTERCEPTOR_WRITE_RANGE(ctx, context, SHA##LEN##_CTX_sz); \\\n  } \\\n  INTERCEPTOR(void, SHA##LEN##_Final, u8 digest[LEN/8], \\\n  void *context) { \\\n    void *ctx; \\\n    CHECK_EQ(SHA##LEN##_digest_length, LEN/8); \\\n    COMMON_INTERCEPTOR_ENTER(ctx, SHA##LEN##_Final, digest, context); \\\n    if (context) \\\n      COMMON_INTERCEPTOR_READ_RANGE(ctx, context, SHA##LEN##_CTX_sz); \\\n    REAL(SHA##LEN##_Final)(digest, context); \\\n    if (digest) \\\n      COMMON_INTERCEPTOR_WRITE_RANGE(ctx, digest, \\\n                                     sizeof(digest[0]) * \\\n  SHA##LEN##_digest_length); \\\n  } \\\n  INTERCEPTOR(char *, SHA##LEN##_End, void *context, char *buf) { \\\n    void *ctx; \\\n    COMMON_INTERCEPTOR_ENTER(ctx, SHA##LEN##_End, context, buf); \\\n    if (context) \\\n      COMMON_INTERCEPTOR_READ_RANGE(ctx, context, SHA##LEN##_CTX_sz); \\\n    char *ret = REAL(SHA##LEN##_End)(context, buf); \\\n    if (ret) \\\n      COMMON_INTERCEPTOR_WRITE_RANGE(ctx, ret, SHA##LEN##_return_length); \\\n    return ret; \\\n  } \\\n  INTERCEPTOR(char *, SHA##LEN##_File, const char *filename, char *buf) { \\\n    void *ctx; \\\n    COMMON_INTERCEPTOR_ENTER(ctx, SHA##LEN##_File, filename, buf); \\\n    if (filename) \\\n      COMMON_INTERCEPTOR_READ_RANGE(ctx, filename, REAL(strlen)(filename) + 1);\\\n    char *ret = REAL(SHA##LEN##_File)(filename, buf); \\\n    if (ret) \\\n      COMMON_INTERCEPTOR_WRITE_RANGE(ctx, ret, SHA##LEN##_return_length); \\\n    return ret; \\\n  } \\\n  INTERCEPTOR(char *, SHA##LEN##_FileChunk, const char *filename, char *buf, \\\n              OFF_T offset, OFF_T length) { \\\n    void *ctx; \\\n    COMMON_INTERCEPTOR_ENTER(ctx, SHA##LEN##_FileChunk, filename, buf, offset, \\\n  length); \\\n    if (filename) \\\n      COMMON_INTERCEPTOR_READ_RANGE(ctx, filename, REAL(strlen)(filename) + 1);\\\n    char *ret = REAL(SHA##LEN##_FileChunk)(filename, buf, offset, length); \\\n    if (ret) \\\n      COMMON_INTERCEPTOR_WRITE_RANGE(ctx, ret, SHA##LEN##_return_length); \\\n    return ret; \\\n  } \\\n  INTERCEPTOR(char *, SHA##LEN##_Data, u8 *data, SIZE_T len, char *buf) { \\\n    void *ctx; \\\n    COMMON_INTERCEPTOR_ENTER(ctx, SHA##LEN##_Data, data, len, buf); \\\n    if (data && len > 0) \\\n      COMMON_INTERCEPTOR_READ_RANGE(ctx, data, len); \\\n    char *ret = REAL(SHA##LEN##_Data)(data, len, buf); \\\n    if (ret) \\\n      COMMON_INTERCEPTOR_WRITE_RANGE(ctx, ret, SHA##LEN##_return_length); \\\n    return ret; \\\n  }\n\nSHA2_INTERCEPTORS(224, u32);\nSHA2_INTERCEPTORS(256, u32);\nSHA2_INTERCEPTORS(384, u64);\nSHA2_INTERCEPTORS(512, u64);\n\n#define INIT_SHA2_INTECEPTORS(LEN) \\\n  COMMON_INTERCEPT_FUNCTION(SHA##LEN##_Init); \\\n  COMMON_INTERCEPT_FUNCTION(SHA##LEN##_Update); \\\n  COMMON_INTERCEPT_FUNCTION(SHA##LEN##_Final); \\\n  COMMON_INTERCEPT_FUNCTION(SHA##LEN##_End); \\\n  COMMON_INTERCEPT_FUNCTION(SHA##LEN##_File); \\\n  COMMON_INTERCEPT_FUNCTION(SHA##LEN##_FileChunk); \\\n  COMMON_INTERCEPT_FUNCTION(SHA##LEN##_Data)\n\n#define INIT_SHA2 \\\n  INIT_SHA2_INTECEPTORS(224); \\\n  INIT_SHA2_INTECEPTORS(256); \\\n  INIT_SHA2_INTECEPTORS(384); \\\n  INIT_SHA2_INTECEPTORS(512)\n#undef SHA2_INTERCEPTORS\n#else\n#define INIT_SHA2\n#endif\n\n#if SANITIZER_INTERCEPT_VIS\nINTERCEPTOR(char *, vis, char *dst, int c, int flag, int nextc) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, vis, dst, c, flag, nextc);\n  char *end = REAL(vis)(dst, c, flag, nextc);\n  // dst is NULL terminated and end points to the NULL char\n  if (dst && end)\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, dst, end - dst + 1);\n  return end;\n}\nINTERCEPTOR(char *, nvis, char *dst, SIZE_T dlen, int c, int flag, int nextc) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, nvis, dst, dlen, c, flag, nextc);\n  char *end = REAL(nvis)(dst, dlen, c, flag, nextc);\n  // nvis cannot make sure the dst is NULL terminated\n  if (dst && end)\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, dst, end - dst + 1);\n  return end;\n}\nINTERCEPTOR(int, strvis, char *dst, const char *src, int flag) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, strvis, dst, src, flag);\n  if (src)\n    COMMON_INTERCEPTOR_READ_RANGE(ctx, src, REAL(strlen)(src) + 1);\n  int len = REAL(strvis)(dst, src, flag);\n  if (dst)\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, dst, len + 1);\n  return len;\n}\nINTERCEPTOR(int, stravis, char **dst, const char *src, int flag) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, stravis, dst, src, flag);\n  if (src)\n    COMMON_INTERCEPTOR_READ_RANGE(ctx, src, REAL(strlen)(src) + 1);\n  int len = REAL(stravis)(dst, src, flag);\n  if (dst) {\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, dst, sizeof(char *));\n    if (*dst)\n      COMMON_INTERCEPTOR_WRITE_RANGE(ctx, *dst, len + 1);\n  }\n  return len;\n}\nINTERCEPTOR(int, strnvis, char *dst, SIZE_T dlen, const char *src, int flag) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, strnvis, dst, dlen, src, flag);\n  if (src)\n    COMMON_INTERCEPTOR_READ_RANGE(ctx, src, REAL(strlen)(src) + 1);\n  int len = REAL(strnvis)(dst, dlen, src, flag);\n  // The interface will be valid even if there is no space for NULL char\n  if (dst && len > 0)\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, dst, len + 1);\n  return len;\n}\nINTERCEPTOR(int, strvisx, char *dst, const char *src, SIZE_T len, int flag) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, strvisx, dst, src, len, flag);\n  if (src)\n    COMMON_INTERCEPTOR_READ_RANGE(ctx, src, len);\n  int ret = REAL(strvisx)(dst, src, len, flag);\n  if (dst)\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, dst, ret + 1);\n  return ret;\n}\nINTERCEPTOR(int, strnvisx, char *dst, SIZE_T dlen, const char *src, SIZE_T len,\n            int flag) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, strnvisx, dst, dlen, src, len, flag);\n  if (src)\n    COMMON_INTERCEPTOR_READ_RANGE(ctx, src, len);\n  int ret = REAL(strnvisx)(dst, dlen, src, len, flag);\n  if (dst && ret >= 0)\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, dst, ret + 1);\n  return ret;\n}\nINTERCEPTOR(int, strenvisx, char *dst, SIZE_T dlen, const char *src, SIZE_T len,\n            int flag, int *cerr_ptr) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, strenvisx, dst, dlen, src, len, flag, cerr_ptr);\n  if (src)\n    COMMON_INTERCEPTOR_READ_RANGE(ctx, src, len);\n  // FIXME: only need to be checked when \"flag | VIS_NOLOCALE\" doesn't hold\n  // according to the implementation\n  if (cerr_ptr)\n    COMMON_INTERCEPTOR_READ_RANGE(ctx, cerr_ptr, sizeof(int));\n  int ret = REAL(strenvisx)(dst, dlen, src, len, flag, cerr_ptr);\n  if (dst && ret >= 0)\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, dst, ret + 1);\n  if (cerr_ptr)\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, cerr_ptr, sizeof(int));\n  return ret;\n}\nINTERCEPTOR(char *, svis, char *dst, int c, int flag, int nextc,\n            const char *extra) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, svis, dst, c, flag, nextc, extra);\n  if (extra)\n    COMMON_INTERCEPTOR_READ_RANGE(ctx, extra, REAL(strlen)(extra) + 1);\n  char *end = REAL(svis)(dst, c, flag, nextc, extra);\n  if (dst && end)\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, dst, end - dst + 1);\n  return end;\n}\nINTERCEPTOR(char *, snvis, char *dst, SIZE_T dlen, int c, int flag, int nextc,\n            const char *extra) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, snvis, dst, dlen, c, flag, nextc, extra);\n  if (extra)\n    COMMON_INTERCEPTOR_READ_RANGE(ctx, extra, REAL(strlen)(extra) + 1);\n  char *end = REAL(snvis)(dst, dlen, c, flag, nextc, extra);\n  if (dst && end)\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, dst,\n                                   Min((SIZE_T)(end - dst + 1), dlen));\n  return end;\n}\nINTERCEPTOR(int, strsvis, char *dst, const char *src, int flag,\n            const char *extra) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, strsvis, dst, src, flag, extra);\n  if (src)\n    COMMON_INTERCEPTOR_READ_RANGE(ctx, src, REAL(strlen)(src) + 1);\n  if (extra)\n    COMMON_INTERCEPTOR_READ_RANGE(ctx, extra, REAL(strlen)(extra) + 1);\n  int len = REAL(strsvis)(dst, src, flag, extra);\n  if (dst)\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, dst, len + 1);\n  return len;\n}\nINTERCEPTOR(int, strsnvis, char *dst, SIZE_T dlen, const char *src, int flag,\n            const char *extra) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, strsnvis, dst, dlen, src, flag, extra);\n  if (src)\n    COMMON_INTERCEPTOR_READ_RANGE(ctx, src, REAL(strlen)(src) + 1);\n  if (extra)\n    COMMON_INTERCEPTOR_READ_RANGE(ctx, extra, REAL(strlen)(extra) + 1);\n  int len = REAL(strsnvis)(dst, dlen, src, flag, extra);\n  // The interface will be valid even if there is no space for NULL char\n  if (dst && len >= 0)\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, dst, len + 1);\n  return len;\n}\nINTERCEPTOR(int, strsvisx, char *dst, const char *src, SIZE_T len, int flag,\n            const char *extra) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, strsvisx, dst, src, len, flag, extra);\n  if (src)\n    COMMON_INTERCEPTOR_READ_RANGE(ctx, src, len);\n  if (extra)\n    COMMON_INTERCEPTOR_READ_RANGE(ctx, extra, REAL(strlen)(extra) + 1);\n  int ret = REAL(strsvisx)(dst, src, len, flag, extra);\n  if (dst)\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, dst, ret + 1);\n  return ret;\n}\nINTERCEPTOR(int, strsnvisx, char *dst, SIZE_T dlen, const char *src, SIZE_T len,\n            int flag, const char *extra) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, strsnvisx, dst, dlen, src, len, flag, extra);\n  if (src)\n    COMMON_INTERCEPTOR_READ_RANGE(ctx, src, len);\n  if (extra)\n    COMMON_INTERCEPTOR_READ_RANGE(ctx, extra, REAL(strlen)(extra) + 1);\n  int ret = REAL(strsnvisx)(dst, dlen, src, len, flag, extra);\n  if (dst && ret >= 0)\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, dst, ret + 1);\n  return ret;\n}\nINTERCEPTOR(int, strsenvisx, char *dst, SIZE_T dlen, const char *src,\n            SIZE_T len, int flag, const char *extra, int *cerr_ptr) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, strsenvisx, dst, dlen, src, len, flag, extra,\n                           cerr_ptr);\n  if (src)\n    COMMON_INTERCEPTOR_READ_RANGE(ctx, src, len);\n  if (extra)\n    COMMON_INTERCEPTOR_READ_RANGE(ctx, extra, REAL(strlen)(extra) + 1);\n  // FIXME: only need to be checked when \"flag | VIS_NOLOCALE\" doesn't hold\n  // according to the implementation\n  if (cerr_ptr)\n    COMMON_INTERCEPTOR_READ_RANGE(ctx, cerr_ptr, sizeof(int));\n  int ret = REAL(strsenvisx)(dst, dlen, src, len, flag, extra, cerr_ptr);\n  if (dst && ret >= 0)\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, dst, ret + 1);\n  if (cerr_ptr)\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, cerr_ptr, sizeof(int));\n  return ret;\n}\nINTERCEPTOR(int, unvis, char *cp, int c, int *astate, int flag) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, unvis, cp, c, astate, flag);\n  if (astate)\n    COMMON_INTERCEPTOR_READ_RANGE(ctx, astate, sizeof(*astate));\n  int ret = REAL(unvis)(cp, c, astate, flag);\n  if (ret == unvis_valid || ret == unvis_validpush) {\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, cp, sizeof(*cp));\n  }\n  return ret;\n}\nINTERCEPTOR(int, strunvis, char *dst, const char *src) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, strunvis, dst, src);\n  if (src)\n    COMMON_INTERCEPTOR_READ_RANGE(ctx, src, REAL(strlen)(src) + 1);\n  int ret = REAL(strunvis)(dst, src);\n  if (ret != -1)\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, dst, ret + 1);\n  return ret;\n}\nINTERCEPTOR(int, strnunvis, char *dst, SIZE_T dlen, const char *src) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, strnunvis, dst, dlen, src);\n  if (src)\n    COMMON_INTERCEPTOR_READ_RANGE(ctx, src, REAL(strlen)(src) + 1);\n  int ret = REAL(strnunvis)(dst, dlen, src);\n  if (ret != -1)\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, dst, ret + 1);\n  return ret;\n}\nINTERCEPTOR(int, strunvisx, char *dst, const char *src, int flag) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, strunvisx, dst, src, flag);\n  if (src)\n    COMMON_INTERCEPTOR_READ_RANGE(ctx, src, REAL(strlen)(src) + 1);\n  int ret = REAL(strunvisx)(dst, src, flag);\n  if (ret != -1)\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, dst, ret + 1);\n  return ret;\n}\nINTERCEPTOR(int, strnunvisx, char *dst, SIZE_T dlen, const char *src,\n            int flag) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, strnunvisx, dst, dlen, src, flag);\n  if (src)\n    COMMON_INTERCEPTOR_READ_RANGE(ctx, src, REAL(strlen)(src) + 1);\n  int ret = REAL(strnunvisx)(dst, dlen, src, flag);\n  if (ret != -1)\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, dst, ret + 1);\n  return ret;\n}\n#define INIT_VIS                                                               \\\n  COMMON_INTERCEPT_FUNCTION(vis);                                              \\\n  COMMON_INTERCEPT_FUNCTION(nvis);                                             \\\n  COMMON_INTERCEPT_FUNCTION(strvis);                                           \\\n  COMMON_INTERCEPT_FUNCTION(stravis);                                          \\\n  COMMON_INTERCEPT_FUNCTION(strnvis);                                          \\\n  COMMON_INTERCEPT_FUNCTION(strvisx);                                          \\\n  COMMON_INTERCEPT_FUNCTION(strnvisx);                                         \\\n  COMMON_INTERCEPT_FUNCTION(strenvisx);                                        \\\n  COMMON_INTERCEPT_FUNCTION(svis);                                             \\\n  COMMON_INTERCEPT_FUNCTION(snvis);                                            \\\n  COMMON_INTERCEPT_FUNCTION(strsvis);                                          \\\n  COMMON_INTERCEPT_FUNCTION(strsnvis);                                         \\\n  COMMON_INTERCEPT_FUNCTION(strsvisx);                                         \\\n  COMMON_INTERCEPT_FUNCTION(strsnvisx);                                        \\\n  COMMON_INTERCEPT_FUNCTION(strsenvisx);                                       \\\n  COMMON_INTERCEPT_FUNCTION(unvis);                                            \\\n  COMMON_INTERCEPT_FUNCTION(strunvis);                                         \\\n  COMMON_INTERCEPT_FUNCTION(strnunvis);                                        \\\n  COMMON_INTERCEPT_FUNCTION(strunvisx);                                        \\\n  COMMON_INTERCEPT_FUNCTION(strnunvisx)\n#else\n#define INIT_VIS\n#endif\n\n#if SANITIZER_INTERCEPT_CDB\nINTERCEPTOR(struct __sanitizer_cdbr *, cdbr_open, const char *path, int flags) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, cdbr_open, path, flags);\n  if (path)\n    COMMON_INTERCEPTOR_READ_RANGE(ctx, path, REAL(strlen)(path) + 1);\n  struct __sanitizer_cdbr *cdbr = REAL(cdbr_open)(path, flags);\n  if (cdbr)\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, cdbr, sizeof(*cdbr));\n  return cdbr;\n}\n\nINTERCEPTOR(struct __sanitizer_cdbr *, cdbr_open_mem, void *base, SIZE_T size,\n  int flags, void (*unmap)(void *, void *, SIZE_T), void *cookie) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, cdbr_open_mem, base, size, flags, unmap,\n    cookie);\n  if (base && size)\n    COMMON_INTERCEPTOR_READ_RANGE(ctx, base, size);\n  struct __sanitizer_cdbr *cdbr =\n    REAL(cdbr_open_mem)(base, size, flags, unmap, cookie);\n  if (cdbr)\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, cdbr, sizeof(*cdbr));\n  return cdbr;\n}\n\nINTERCEPTOR(u32, cdbr_entries, struct __sanitizer_cdbr *cdbr) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, cdbr_entries, cdbr);\n  if (cdbr)\n    COMMON_INTERCEPTOR_READ_RANGE(ctx, cdbr, sizeof(*cdbr));\n  return REAL(cdbr_entries)(cdbr);\n}\n\nINTERCEPTOR(int, cdbr_get, struct __sanitizer_cdbr *cdbr, u32 index,\n            const void **data, SIZE_T *datalen) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, cdbr_get, cdbr, index, data, datalen);\n  if (cdbr)\n    COMMON_INTERCEPTOR_READ_RANGE(ctx, cdbr, sizeof(*cdbr));\n  int ret = REAL(cdbr_get)(cdbr, index, data, datalen);\n  if (!ret) {\n    if (data)\n      COMMON_INTERCEPTOR_WRITE_RANGE(ctx, data, sizeof(*data));\n    if (datalen)\n      COMMON_INTERCEPTOR_WRITE_RANGE(ctx, datalen, sizeof(*datalen));\n    if (data && datalen)\n      COMMON_INTERCEPTOR_WRITE_RANGE(ctx, *data, *datalen);\n  }\n  return ret;\n}\n\nINTERCEPTOR(int, cdbr_find, struct __sanitizer_cdbr *cdbr, const void *key,\n            SIZE_T keylen, const void **data, SIZE_T *datalen) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, cdbr_find, cdbr, key, keylen, data, datalen);\n  if (cdbr)\n    COMMON_INTERCEPTOR_READ_RANGE(ctx, cdbr, sizeof(*cdbr));\n  if (key)\n    COMMON_INTERCEPTOR_READ_RANGE(ctx, key, keylen);\n  int ret = REAL(cdbr_find)(cdbr, key, keylen, data, datalen);\n  if (!ret) {\n    if (data)\n      COMMON_INTERCEPTOR_WRITE_RANGE(ctx, data, sizeof(*data));\n    if (datalen)\n      COMMON_INTERCEPTOR_WRITE_RANGE(ctx, datalen, sizeof(*datalen));\n    if (data && datalen)\n      COMMON_INTERCEPTOR_WRITE_RANGE(ctx, *data, *datalen);\n  }\n  return ret;\n}\n\nINTERCEPTOR(void, cdbr_close, struct __sanitizer_cdbr *cdbr) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, cdbr_close, cdbr);\n  if (cdbr)\n    COMMON_INTERCEPTOR_READ_RANGE(ctx, cdbr, sizeof(*cdbr));\n  REAL(cdbr_close)(cdbr);\n}\n\nINTERCEPTOR(struct __sanitizer_cdbw *, cdbw_open) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, cdbw_open);\n  struct __sanitizer_cdbw *ret = REAL(cdbw_open)();\n  if (ret)\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, ret, sizeof(*ret));\n  return ret;\n}\n\nINTERCEPTOR(int, cdbw_put, struct __sanitizer_cdbw *cdbw, const void *key,\n  SIZE_T keylen, const void *data, SIZE_T datalen) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, cdbw_put, cdbw, key, keylen, data, datalen);\n  if (cdbw)\n    COMMON_INTERCEPTOR_READ_RANGE(ctx, cdbw, sizeof(*cdbw));\n  if (data && datalen)\n    COMMON_INTERCEPTOR_READ_RANGE(ctx, data, datalen);\n  if (key && keylen)\n    COMMON_INTERCEPTOR_READ_RANGE(ctx, key, keylen);\n  int ret = REAL(cdbw_put)(cdbw, key, keylen, data, datalen);\n  if (!ret && cdbw)\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, cdbw, sizeof(*cdbw));\n  return ret;\n}\n\nINTERCEPTOR(int, cdbw_put_data, struct __sanitizer_cdbw *cdbw, const void *data,\n  SIZE_T datalen, u32 *index) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, cdbw_put_data, cdbw, data, datalen, index);\n  if (cdbw)\n    COMMON_INTERCEPTOR_READ_RANGE(ctx, cdbw, sizeof(*cdbw));\n  if (data && datalen)\n    COMMON_INTERCEPTOR_READ_RANGE(ctx, data, datalen);\n  int ret = REAL(cdbw_put_data)(cdbw, data, datalen, index);\n  if (!ret) {\n    if (index)\n      COMMON_INTERCEPTOR_WRITE_RANGE(ctx, index, sizeof(*index));\n    if (cdbw)\n      COMMON_INTERCEPTOR_WRITE_RANGE(ctx, cdbw, sizeof(*cdbw));\n  }\n  return ret;\n}\n\nINTERCEPTOR(int, cdbw_put_key, struct __sanitizer_cdbw *cdbw, const void *key,\n  SIZE_T keylen, u32 index) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, cdbw_put_key, cdbw, key, keylen, index);\n  if (cdbw)\n    COMMON_INTERCEPTOR_READ_RANGE(ctx, cdbw, sizeof(*cdbw));\n  if (key && keylen)\n    COMMON_INTERCEPTOR_READ_RANGE(ctx, key, keylen);\n  int ret = REAL(cdbw_put_key)(cdbw, key, keylen, index);\n  if (!ret && cdbw)\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, cdbw, sizeof(*cdbw));\n  return ret;\n}\n\nINTERCEPTOR(int, cdbw_output, struct __sanitizer_cdbw *cdbw, int output,\n  const char descr[16], u32 (*seedgen)(void)) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, cdbw_output, cdbw, output, descr, seedgen);\n  COMMON_INTERCEPTOR_FD_ACCESS(ctx, output);\n  if (cdbw)\n    COMMON_INTERCEPTOR_READ_RANGE(ctx, cdbw, sizeof(*cdbw));\n  if (descr)\n    COMMON_INTERCEPTOR_READ_RANGE(ctx, descr, internal_strnlen(descr, 16));\n  if (seedgen)\n    COMMON_INTERCEPTOR_READ_RANGE(ctx, (void *)seedgen, sizeof(seedgen));\n  int ret = REAL(cdbw_output)(cdbw, output, descr, seedgen);\n  if (!ret) {\n    if (cdbw)\n      COMMON_INTERCEPTOR_WRITE_RANGE(ctx, cdbw, sizeof(*cdbw));\n    if (output >= 0)\n      COMMON_INTERCEPTOR_FD_ACQUIRE(ctx, output);\n  }\n  return ret;\n}\n\nINTERCEPTOR(void, cdbw_close, struct __sanitizer_cdbw *cdbw) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, cdbw_close, cdbw);\n  if (cdbw)\n    COMMON_INTERCEPTOR_READ_RANGE(ctx, cdbw, sizeof(*cdbw));\n  REAL(cdbw_close)(cdbw);\n}\n\n#define INIT_CDB \\\n  COMMON_INTERCEPT_FUNCTION(cdbr_open); \\\n  COMMON_INTERCEPT_FUNCTION(cdbr_open_mem); \\\n  COMMON_INTERCEPT_FUNCTION(cdbr_entries); \\\n  COMMON_INTERCEPT_FUNCTION(cdbr_get); \\\n  COMMON_INTERCEPT_FUNCTION(cdbr_find); \\\n  COMMON_INTERCEPT_FUNCTION(cdbr_close); \\\n  COMMON_INTERCEPT_FUNCTION(cdbw_open); \\\n  COMMON_INTERCEPT_FUNCTION(cdbw_put); \\\n  COMMON_INTERCEPT_FUNCTION(cdbw_put_data); \\\n  COMMON_INTERCEPT_FUNCTION(cdbw_put_key); \\\n  COMMON_INTERCEPT_FUNCTION(cdbw_output); \\\n  COMMON_INTERCEPT_FUNCTION(cdbw_close)\n#else\n#define INIT_CDB\n#endif\n\n#if SANITIZER_INTERCEPT_GETFSENT\nINTERCEPTOR(void *, getfsent) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, getfsent);\n  void *ret = REAL(getfsent)();\n  if (ret)\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, ret, struct_fstab_sz);\n  return ret;\n}\n\nINTERCEPTOR(void *, getfsspec, const char *spec) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, getfsspec, spec);\n  if (spec)\n    COMMON_INTERCEPTOR_READ_RANGE(ctx, spec, REAL(strlen)(spec) + 1);\n  void *ret = REAL(getfsspec)(spec);\n  if (ret)\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, ret, struct_fstab_sz);\n  return ret;\n}\n\nINTERCEPTOR(void *, getfsfile, const char *file) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, getfsfile, file);\n  if (file)\n    COMMON_INTERCEPTOR_READ_RANGE(ctx, file, REAL(strlen)(file) + 1);\n  void *ret = REAL(getfsfile)(file);\n  if (ret)\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, ret, struct_fstab_sz);\n  return ret;\n}\n\n#define INIT_GETFSENT \\\n  COMMON_INTERCEPT_FUNCTION(getfsent); \\\n  COMMON_INTERCEPT_FUNCTION(getfsspec); \\\n  COMMON_INTERCEPT_FUNCTION(getfsfile);\n#else\n#define INIT_GETFSENT\n#endif\n\n#if SANITIZER_INTERCEPT_ARC4RANDOM\nINTERCEPTOR(void, arc4random_buf, void *buf, SIZE_T len) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, arc4random_buf, buf, len);\n  REAL(arc4random_buf)(buf, len);\n  if (buf && len)\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, buf, len);\n}\n\nINTERCEPTOR(void, arc4random_addrandom, u8 *dat, int datlen) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, arc4random_addrandom, dat, datlen);\n  if (dat && datlen)\n    COMMON_INTERCEPTOR_READ_RANGE(ctx, dat, datlen);\n  REAL(arc4random_addrandom)(dat, datlen);\n}\n\n#define INIT_ARC4RANDOM \\\n  COMMON_INTERCEPT_FUNCTION(arc4random_buf); \\\n  COMMON_INTERCEPT_FUNCTION(arc4random_addrandom);\n#else\n#define INIT_ARC4RANDOM\n#endif\n\n#if SANITIZER_INTERCEPT_POPEN\nINTERCEPTOR(__sanitizer_FILE *, popen, const char *command, const char *type) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, popen, command, type);\n  if (command)\n    COMMON_INTERCEPTOR_READ_RANGE(ctx, command, REAL(strlen)(command) + 1);\n  if (type)\n    COMMON_INTERCEPTOR_READ_RANGE(ctx, type, REAL(strlen)(type) + 1);\n  __sanitizer_FILE *res = REAL(popen)(command, type);\n  COMMON_INTERCEPTOR_FILE_OPEN(ctx, res, nullptr);\n  if (res) unpoison_file(res);\n  return res;\n}\n#define INIT_POPEN COMMON_INTERCEPT_FUNCTION(popen)\n#else\n#define INIT_POPEN\n#endif\n\n#if SANITIZER_INTERCEPT_POPENVE\nINTERCEPTOR(__sanitizer_FILE *, popenve, const char *path,\n            char *const *argv, char *const *envp, const char *type) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, popenve, path, argv, envp, type);\n  if (path)\n    COMMON_INTERCEPTOR_READ_RANGE(ctx, path, REAL(strlen)(path) + 1);\n  if (argv) {\n    for (char *const *pa = argv; ; ++pa) {\n      COMMON_INTERCEPTOR_READ_RANGE(ctx, pa, sizeof(char **));\n      if (!*pa)\n        break;\n      COMMON_INTERCEPTOR_READ_RANGE(ctx, *pa, REAL(strlen)(*pa) + 1);\n    }\n  }\n  if (envp) {\n    for (char *const *pa = envp; ; ++pa) {\n      COMMON_INTERCEPTOR_READ_RANGE(ctx, pa, sizeof(char **));\n      if (!*pa)\n        break;\n      COMMON_INTERCEPTOR_READ_RANGE(ctx, *pa, REAL(strlen)(*pa) + 1);\n    }\n  }\n  if (type)\n    COMMON_INTERCEPTOR_READ_RANGE(ctx, type, REAL(strlen)(type) + 1);\n  __sanitizer_FILE *res = REAL(popenve)(path, argv, envp, type);\n  COMMON_INTERCEPTOR_FILE_OPEN(ctx, res, nullptr);\n  if (res) unpoison_file(res);\n  return res;\n}\n#define INIT_POPENVE COMMON_INTERCEPT_FUNCTION(popenve)\n#else\n#define INIT_POPENVE\n#endif\n\n#if SANITIZER_INTERCEPT_PCLOSE\nINTERCEPTOR(int, pclose, __sanitizer_FILE *fp) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, pclose, fp);\n  COMMON_INTERCEPTOR_FILE_CLOSE(ctx, fp);\n  const FileMetadata *m = GetInterceptorMetadata(fp);\n  int res = REAL(pclose)(fp);\n  if (m) {\n    COMMON_INTERCEPTOR_INITIALIZE_RANGE(*m->addr, *m->size);\n    DeleteInterceptorMetadata(fp);\n  }\n  return res;\n}\n#define INIT_PCLOSE COMMON_INTERCEPT_FUNCTION(pclose);\n#else\n#define INIT_PCLOSE\n#endif\n\n#if SANITIZER_INTERCEPT_FUNOPEN\ntypedef int (*funopen_readfn)(void *cookie, char *buf, int len);\ntypedef int (*funopen_writefn)(void *cookie, const char *buf, int len);\ntypedef OFF_T (*funopen_seekfn)(void *cookie, OFF_T offset, int whence);\ntypedef int (*funopen_closefn)(void *cookie);\n\nstruct WrappedFunopenCookie {\n  void *real_cookie;\n  funopen_readfn real_read;\n  funopen_writefn real_write;\n  funopen_seekfn real_seek;\n  funopen_closefn real_close;\n};\n\nstatic int wrapped_funopen_read(void *cookie, char *buf, int len) {\n  COMMON_INTERCEPTOR_UNPOISON_PARAM(3);\n  WrappedFunopenCookie *wrapped_cookie = (WrappedFunopenCookie *)cookie;\n  funopen_readfn real_read = wrapped_cookie->real_read;\n  return real_read(wrapped_cookie->real_cookie, buf, len);\n}\n\nstatic int wrapped_funopen_write(void *cookie, const char *buf, int len) {\n  COMMON_INTERCEPTOR_UNPOISON_PARAM(3);\n  WrappedFunopenCookie *wrapped_cookie = (WrappedFunopenCookie *)cookie;\n  funopen_writefn real_write = wrapped_cookie->real_write;\n  return real_write(wrapped_cookie->real_cookie, buf, len);\n}\n\nstatic OFF_T wrapped_funopen_seek(void *cookie, OFF_T offset, int whence) {\n  COMMON_INTERCEPTOR_UNPOISON_PARAM(3);\n  WrappedFunopenCookie *wrapped_cookie = (WrappedFunopenCookie *)cookie;\n  funopen_seekfn real_seek = wrapped_cookie->real_seek;\n  return real_seek(wrapped_cookie->real_cookie, offset, whence);\n}\n\nstatic int wrapped_funopen_close(void *cookie) {\n  COMMON_INTERCEPTOR_UNPOISON_PARAM(1);\n  WrappedFunopenCookie *wrapped_cookie = (WrappedFunopenCookie *)cookie;\n  funopen_closefn real_close = wrapped_cookie->real_close;\n  int res = real_close(wrapped_cookie->real_cookie);\n  InternalFree(wrapped_cookie);\n  return res;\n}\n\nINTERCEPTOR(__sanitizer_FILE *, funopen, void *cookie, funopen_readfn readfn,\n            funopen_writefn writefn, funopen_seekfn seekfn,\n            funopen_closefn closefn) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, funopen, cookie, readfn, writefn, seekfn,\n                           closefn);\n\n  WrappedFunopenCookie *wrapped_cookie =\n      (WrappedFunopenCookie *)InternalAlloc(sizeof(WrappedFunopenCookie));\n  wrapped_cookie->real_cookie = cookie;\n  wrapped_cookie->real_read = readfn;\n  wrapped_cookie->real_write = writefn;\n  wrapped_cookie->real_seek = seekfn;\n  wrapped_cookie->real_close = closefn;\n\n  __sanitizer_FILE *res =\n      REAL(funopen)(wrapped_cookie,\n                    readfn  ? wrapped_funopen_read  : nullptr,\n                    writefn ? wrapped_funopen_write : nullptr,\n                    seekfn  ? wrapped_funopen_seek  : nullptr,\n                    closefn ? wrapped_funopen_close : nullptr);\n  if (res)\n    unpoison_file(res);\n  return res;\n}\n#define INIT_FUNOPEN COMMON_INTERCEPT_FUNCTION(funopen)\n#else\n#define INIT_FUNOPEN\n#endif\n\n#if SANITIZER_INTERCEPT_FUNOPEN2\ntypedef SSIZE_T (*funopen2_readfn)(void *cookie, void *buf, SIZE_T len);\ntypedef SSIZE_T (*funopen2_writefn)(void *cookie, const void *buf, SIZE_T len);\ntypedef OFF_T (*funopen2_seekfn)(void *cookie, OFF_T offset, int whence);\ntypedef int (*funopen2_flushfn)(void *cookie);\ntypedef int (*funopen2_closefn)(void *cookie);\n\nstruct WrappedFunopen2Cookie {\n  void *real_cookie;\n  funopen2_readfn real_read;\n  funopen2_writefn real_write;\n  funopen2_seekfn real_seek;\n  funopen2_flushfn real_flush;\n  funopen2_closefn real_close;\n};\n\nstatic SSIZE_T wrapped_funopen2_read(void *cookie, void *buf, SIZE_T len) {\n  COMMON_INTERCEPTOR_UNPOISON_PARAM(3);\n  WrappedFunopen2Cookie *wrapped_cookie = (WrappedFunopen2Cookie *)cookie;\n  funopen2_readfn real_read = wrapped_cookie->real_read;\n  return real_read(wrapped_cookie->real_cookie, buf, len);\n}\n\nstatic SSIZE_T wrapped_funopen2_write(void *cookie, const void *buf,\n                                      SIZE_T len) {\n  COMMON_INTERCEPTOR_UNPOISON_PARAM(3);\n  WrappedFunopen2Cookie *wrapped_cookie = (WrappedFunopen2Cookie *)cookie;\n  funopen2_writefn real_write = wrapped_cookie->real_write;\n  return real_write(wrapped_cookie->real_cookie, buf, len);\n}\n\nstatic OFF_T wrapped_funopen2_seek(void *cookie, OFF_T offset, int whence) {\n  COMMON_INTERCEPTOR_UNPOISON_PARAM(3);\n  WrappedFunopen2Cookie *wrapped_cookie = (WrappedFunopen2Cookie *)cookie;\n  funopen2_seekfn real_seek = wrapped_cookie->real_seek;\n  return real_seek(wrapped_cookie->real_cookie, offset, whence);\n}\n\nstatic int wrapped_funopen2_flush(void *cookie) {\n  COMMON_INTERCEPTOR_UNPOISON_PARAM(1);\n  WrappedFunopen2Cookie *wrapped_cookie = (WrappedFunopen2Cookie *)cookie;\n  funopen2_flushfn real_flush = wrapped_cookie->real_flush;\n  return real_flush(wrapped_cookie->real_cookie);\n}\n\nstatic int wrapped_funopen2_close(void *cookie) {\n  COMMON_INTERCEPTOR_UNPOISON_PARAM(1);\n  WrappedFunopen2Cookie *wrapped_cookie = (WrappedFunopen2Cookie *)cookie;\n  funopen2_closefn real_close = wrapped_cookie->real_close;\n  int res = real_close(wrapped_cookie->real_cookie);\n  InternalFree(wrapped_cookie);\n  return res;\n}\n\nINTERCEPTOR(__sanitizer_FILE *, funopen2, void *cookie, funopen2_readfn readfn,\n            funopen2_writefn writefn, funopen2_seekfn seekfn,\n            funopen2_flushfn flushfn, funopen2_closefn closefn) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, funopen2, cookie, readfn, writefn, seekfn,\n                           flushfn, closefn);\n\n  WrappedFunopen2Cookie *wrapped_cookie =\n      (WrappedFunopen2Cookie *)InternalAlloc(sizeof(WrappedFunopen2Cookie));\n  wrapped_cookie->real_cookie = cookie;\n  wrapped_cookie->real_read = readfn;\n  wrapped_cookie->real_write = writefn;\n  wrapped_cookie->real_seek = seekfn;\n  wrapped_cookie->real_flush = flushfn;\n  wrapped_cookie->real_close = closefn;\n\n  __sanitizer_FILE *res =\n      REAL(funopen2)(wrapped_cookie,\n                     readfn  ? wrapped_funopen2_read  : nullptr,\n                     writefn ? wrapped_funopen2_write : nullptr,\n                     seekfn  ? wrapped_funopen2_seek  : nullptr,\n                     flushfn ? wrapped_funopen2_flush : nullptr,\n                     closefn ? wrapped_funopen2_close : nullptr);\n  if (res)\n    unpoison_file(res);\n  return res;\n}\n#define INIT_FUNOPEN2 COMMON_INTERCEPT_FUNCTION(funopen2)\n#else\n#define INIT_FUNOPEN2\n#endif\n\n#if SANITIZER_INTERCEPT_FDEVNAME\nINTERCEPTOR(char *, fdevname,  int fd) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, fdevname, fd);\n  COMMON_INTERCEPTOR_FD_ACCESS(ctx, fd);\n  char *name = REAL(fdevname)(fd);\n  if (name) {\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, name, REAL(strlen)(name) + 1);\n    if (fd > 0)\n      COMMON_INTERCEPTOR_FD_ACQUIRE(ctx, fd);\n  }\n  return name;\n}\n\nINTERCEPTOR(char *, fdevname_r,  int fd, char *buf, SIZE_T len) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, fdevname_r, fd, buf, len);\n  COMMON_INTERCEPTOR_FD_ACCESS(ctx, fd);\n  char *name = REAL(fdevname_r)(fd, buf, len);\n  if (name && buf && len > 0) {\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, buf, REAL(strlen)(buf) + 1);\n    if (fd > 0)\n      COMMON_INTERCEPTOR_FD_ACQUIRE(ctx, fd);\n  }\n  return name;\n}\n\n#define INIT_FDEVNAME \\\n  COMMON_INTERCEPT_FUNCTION(fdevname); \\\n  COMMON_INTERCEPT_FUNCTION(fdevname_r);\n#else\n#define INIT_FDEVNAME\n#endif\n\n#if SANITIZER_INTERCEPT_GETUSERSHELL\nINTERCEPTOR(char *, getusershell) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, getusershell);\n  char *res = REAL(getusershell)();\n  if (res)\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, res, REAL(strlen)(res) + 1);\n  return res;\n}\n\n#define INIT_GETUSERSHELL COMMON_INTERCEPT_FUNCTION(getusershell);\n#else\n#define INIT_GETUSERSHELL\n#endif\n\n#if SANITIZER_INTERCEPT_SL_INIT\nINTERCEPTOR(void *, sl_init) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, sl_init);\n  void *res = REAL(sl_init)();\n  if (res)\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, res, __sanitizer::struct_StringList_sz);\n  return res;\n}\n\nINTERCEPTOR(int, sl_add, void *sl, char *item) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, sl_add, sl, item);\n  if (sl)\n    COMMON_INTERCEPTOR_READ_RANGE(ctx, sl, __sanitizer::struct_StringList_sz);\n  if (item)\n    COMMON_INTERCEPTOR_READ_RANGE(ctx, item, REAL(strlen)(item) + 1);\n  int res = REAL(sl_add)(sl, item);\n  if (!res)\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, sl, __sanitizer::struct_StringList_sz);\n  return res;\n}\n\nINTERCEPTOR(char *, sl_find, void *sl, const char *item) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, sl_find, sl, item);\n  if (sl)\n    COMMON_INTERCEPTOR_READ_RANGE(ctx, sl, __sanitizer::struct_StringList_sz);\n  if (item)\n    COMMON_INTERCEPTOR_READ_RANGE(ctx, item, REAL(strlen)(item) + 1);\n  char *res = REAL(sl_find)(sl, item);\n  if (res)\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, res, REAL(strlen)(res) + 1);\n  return res;\n}\n\nINTERCEPTOR(void, sl_free, void *sl, int freeall) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, sl_free, sl, freeall);\n  if (sl)\n    COMMON_INTERCEPTOR_READ_RANGE(ctx, sl, __sanitizer::struct_StringList_sz);\n  REAL(sl_free)(sl, freeall);\n}\n\n#define INIT_SL_INIT                  \\\n  COMMON_INTERCEPT_FUNCTION(sl_init); \\\n  COMMON_INTERCEPT_FUNCTION(sl_add);  \\\n  COMMON_INTERCEPT_FUNCTION(sl_find); \\\n  COMMON_INTERCEPT_FUNCTION(sl_free);\n#else\n#define INIT_SL_INIT\n#endif\n\n#if SANITIZER_INTERCEPT_GETRANDOM\nINTERCEPTOR(SSIZE_T, getrandom, void *buf, SIZE_T buflen, unsigned int flags) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, getrandom, buf, buflen, flags);\n  SSIZE_T n = REAL(getrandom)(buf, buflen, flags);\n  if (n > 0) {\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, buf, n);\n  }\n  return n;\n}\n#define INIT_GETRANDOM COMMON_INTERCEPT_FUNCTION(getrandom)\n#else\n#define INIT_GETRANDOM\n#endif\n\n#if SANITIZER_INTERCEPT_CRYPT\nINTERCEPTOR(char *, crypt, char *key, char *salt) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, crypt, key, salt);\n  COMMON_INTERCEPTOR_READ_RANGE(ctx, key, internal_strlen(key) + 1);\n  COMMON_INTERCEPTOR_READ_RANGE(ctx, salt, internal_strlen(salt) + 1);\n  char *res = REAL(crypt)(key, salt);\n  if (res != nullptr)\n    COMMON_INTERCEPTOR_INITIALIZE_RANGE(res, internal_strlen(res) + 1);\n  return res;\n}\n#define INIT_CRYPT COMMON_INTERCEPT_FUNCTION(crypt);\n#else\n#define INIT_CRYPT\n#endif\n\n#if SANITIZER_INTERCEPT_CRYPT_R\nINTERCEPTOR(char *, crypt_r, char *key, char *salt, void *data) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, crypt_r, key, salt, data);\n  COMMON_INTERCEPTOR_READ_RANGE(ctx, key, internal_strlen(key) + 1);\n  COMMON_INTERCEPTOR_READ_RANGE(ctx, salt, internal_strlen(salt) + 1);\n  char *res = REAL(crypt_r)(key, salt, data);\n  if (res != nullptr) {\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, data,\n                                   __sanitizer::struct_crypt_data_sz);\n    COMMON_INTERCEPTOR_INITIALIZE_RANGE(res, internal_strlen(res) + 1);\n  }\n  return res;\n}\n#define INIT_CRYPT_R COMMON_INTERCEPT_FUNCTION(crypt_r);\n#else\n#define INIT_CRYPT_R\n#endif\n\n#if SANITIZER_INTERCEPT_GETENTROPY\nINTERCEPTOR(int, getentropy, void *buf, SIZE_T buflen) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, getentropy, buf, buflen);\n  int r = REAL(getentropy)(buf, buflen);\n  if (r == 0) {\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, buf, buflen);\n  }\n  return r;\n}\n#define INIT_GETENTROPY COMMON_INTERCEPT_FUNCTION(getentropy)\n#else\n#define INIT_GETENTROPY\n#endif\n\n#if SANITIZER_INTERCEPT_QSORT\n// Glibc qsort uses a temporary buffer allocated either on stack or on heap.\n// Poisoned memory from there may get copied into the comparator arguments,\n// where it needs to be dealt with. But even that is not enough - the results of\n// the sort may be copied into the input/output array based on the results of\n// the comparator calls, but directly from the temp memory, bypassing the\n// unpoisoning done in wrapped_qsort_compar. We deal with this by, again,\n// unpoisoning the entire array after the sort is done.\n//\n// We can not check that the entire array is initialized at the beginning. IMHO,\n// it's fine for parts of the sorted objects to contain uninitialized memory,\n// ex. as padding in structs.\ntypedef int (*qsort_compar_f)(const void *, const void *);\nstatic THREADLOCAL qsort_compar_f qsort_compar;\nstatic THREADLOCAL SIZE_T qsort_size;\nint wrapped_qsort_compar(const void *a, const void *b) {\n  COMMON_INTERCEPTOR_UNPOISON_PARAM(2);\n  COMMON_INTERCEPTOR_INITIALIZE_RANGE(a, qsort_size);\n  COMMON_INTERCEPTOR_INITIALIZE_RANGE(b, qsort_size);\n  return qsort_compar(a, b);\n}\n\nINTERCEPTOR(void, qsort, void *base, SIZE_T nmemb, SIZE_T size,\n            qsort_compar_f compar) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, qsort, base, nmemb, size, compar);\n  // Run the comparator over all array elements to detect any memory issues.\n  if (nmemb > 1) {\n    for (SIZE_T i = 0; i < nmemb - 1; ++i) {\n      void *p = (void *)((char *)base + i * size);\n      void *q = (void *)((char *)base + (i + 1) * size);\n      COMMON_INTERCEPTOR_UNPOISON_PARAM(2);\n      compar(p, q);\n    }\n  }\n  qsort_compar_f old_compar = qsort_compar;\n  SIZE_T old_size = qsort_size;\n  // Handle qsort() implementations that recurse using an\n  // interposable function call:\n  bool already_wrapped = compar == wrapped_qsort_compar;\n  if (already_wrapped) {\n    // This case should only happen if the qsort() implementation calls itself\n    // using a preemptible function call (e.g. the FreeBSD libc version).\n    // Check that the size and comparator arguments are as expected.\n    CHECK_NE(compar, qsort_compar);\n    CHECK_EQ(qsort_size, size);\n  } else {\n    qsort_compar = compar;\n    qsort_size = size;\n  }\n  REAL(qsort)(base, nmemb, size, wrapped_qsort_compar);\n  if (!already_wrapped) {\n    qsort_compar = old_compar;\n    qsort_size = old_size;\n  }\n  COMMON_INTERCEPTOR_WRITE_RANGE(ctx, base, nmemb * size);\n}\n#define INIT_QSORT COMMON_INTERCEPT_FUNCTION(qsort)\n#else\n#define INIT_QSORT\n#endif\n\n#if SANITIZER_INTERCEPT_QSORT_R\ntypedef int (*qsort_r_compar_f)(const void *, const void *, void *);\nstatic THREADLOCAL qsort_r_compar_f qsort_r_compar;\nstatic THREADLOCAL SIZE_T qsort_r_size;\nint wrapped_qsort_r_compar(const void *a, const void *b, void *arg) {\n  COMMON_INTERCEPTOR_UNPOISON_PARAM(3);\n  COMMON_INTERCEPTOR_INITIALIZE_RANGE(a, qsort_r_size);\n  COMMON_INTERCEPTOR_INITIALIZE_RANGE(b, qsort_r_size);\n  return qsort_r_compar(a, b, arg);\n}\n\nINTERCEPTOR(void, qsort_r, void *base, SIZE_T nmemb, SIZE_T size,\n            qsort_r_compar_f compar, void *arg) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, qsort_r, base, nmemb, size, compar, arg);\n  // Run the comparator over all array elements to detect any memory issues.\n  if (nmemb > 1) {\n    for (SIZE_T i = 0; i < nmemb - 1; ++i) {\n      void *p = (void *)((char *)base + i * size);\n      void *q = (void *)((char *)base + (i + 1) * size);\n      COMMON_INTERCEPTOR_UNPOISON_PARAM(3);\n      compar(p, q, arg);\n    }\n  }\n  qsort_r_compar_f old_compar = qsort_r_compar;\n  SIZE_T old_size = qsort_r_size;\n  // Handle qsort_r() implementations that recurse using an\n  // interposable function call:\n  bool already_wrapped = compar == wrapped_qsort_r_compar;\n  if (already_wrapped) {\n    // This case should only happen if the qsort() implementation calls itself\n    // using a preemptible function call (e.g. the FreeBSD libc version).\n    // Check that the size and comparator arguments are as expected.\n    CHECK_NE(compar, qsort_r_compar);\n    CHECK_EQ(qsort_r_size, size);\n  } else {\n    qsort_r_compar = compar;\n    qsort_r_size = size;\n  }\n  REAL(qsort_r)(base, nmemb, size, wrapped_qsort_r_compar, arg);\n  if (!already_wrapped) {\n    qsort_r_compar = old_compar;\n    qsort_r_size = old_size;\n  }\n  COMMON_INTERCEPTOR_WRITE_RANGE(ctx, base, nmemb * size);\n}\n#define INIT_QSORT_R COMMON_INTERCEPT_FUNCTION(qsort_r)\n#else\n#define INIT_QSORT_R\n#endif\n\n#if SANITIZER_INTERCEPT_SIGALTSTACK\nINTERCEPTOR(int, sigaltstack, void *ss, void *oss) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, sigaltstack, ss, oss);\n  int r = REAL(sigaltstack)(ss, oss);\n  if (r == 0 && oss != nullptr) {\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, oss, struct_stack_t_sz);\n  }\n  return r;\n}\n#define INIT_SIGALTSTACK COMMON_INTERCEPT_FUNCTION(sigaltstack)\n#else\n#define INIT_SIGALTSTACK\n#endif\n\n#if SANITIZER_INTERCEPT_UNAME\nINTERCEPTOR(int, uname, struct utsname *utsname) {\n#if SANITIZER_LINUX\n  if (COMMON_INTERCEPTOR_NOTHING_IS_INITIALIZED)\n    return internal_uname(utsname);\n#endif\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, uname, utsname);\n  int res = REAL(uname)(utsname);\n  if (!res)\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, utsname,\n                                   __sanitizer::struct_utsname_sz);\n  return res;\n}\n#define INIT_UNAME COMMON_INTERCEPT_FUNCTION(uname)\n#else\n#define INIT_UNAME\n#endif\n\n#if SANITIZER_INTERCEPT___XUNAME\n// FreeBSD's <sys/utsname.h> define uname() as\n// static __inline int uname(struct utsname *name) {\n//   return __xuname(SYS_NMLN, (void*)name);\n// }\nINTERCEPTOR(int, __xuname, int size, void *utsname) {\n  void *ctx;\n  COMMON_INTERCEPTOR_ENTER(ctx, __xuname, size, utsname);\n  int res = REAL(__xuname)(size, utsname);\n  if (!res)\n    COMMON_INTERCEPTOR_WRITE_RANGE(ctx, utsname,\n                                   __sanitizer::struct_utsname_sz);\n  return res;\n}\n#define INIT___XUNAME COMMON_INTERCEPT_FUNCTION(__xuname)\n#else\n#define INIT___XUNAME\n#endif\n\n#include \"sanitizer_common_interceptors_netbsd_compat.inc\"\n\nstatic void InitializeCommonInterceptors() {\n#if SI_POSIX\n  static u64 metadata_mem[sizeof(MetadataHashMap) / sizeof(u64) + 1];\n  interceptor_metadata_map = new ((void *)&metadata_mem) MetadataHashMap();\n#endif\n\n  INIT_MMAP;\n  INIT_MMAP64;\n  INIT_TEXTDOMAIN;\n  INIT_STRLEN;\n  INIT_STRNLEN;\n  INIT_STRNDUP;\n  INIT___STRNDUP;\n  INIT_STRCMP;\n  INIT_STRNCMP;\n  INIT_STRCASECMP;\n  INIT_STRNCASECMP;\n  INIT_STRSTR;\n  INIT_STRCASESTR;\n  INIT_STRCHR;\n  INIT_STRCHRNUL;\n  INIT_STRRCHR;\n  INIT_STRSPN;\n  INIT_STRTOK;\n  INIT_STRPBRK;\n  INIT_STRXFRM;\n  INIT___STRXFRM_L;\n  INIT_MEMSET;\n  INIT_MEMMOVE;\n  INIT_MEMCPY;\n  INIT_MEMCHR;\n  INIT_MEMCMP;\n  INIT_BCMP;\n  INIT_MEMRCHR;\n  INIT_MEMMEM;\n  INIT_READ;\n  INIT_FREAD;\n  INIT_PREAD;\n  INIT_PREAD64;\n  INIT_READV;\n  INIT_PREADV;\n  INIT_PREADV64;\n  INIT_WRITE;\n  INIT_FWRITE;\n  INIT_PWRITE;\n  INIT_PWRITE64;\n  INIT_WRITEV;\n  INIT_PWRITEV;\n  INIT_PWRITEV64;\n  INIT_FGETS;\n  INIT_FPUTS;\n  INIT_PUTS;\n  INIT_PRCTL;\n  INIT_LOCALTIME_AND_FRIENDS;\n  INIT_STRPTIME;\n  INIT_SCANF;\n  INIT_ISOC99_SCANF;\n  INIT_PRINTF;\n  INIT_PRINTF_L;\n  INIT_ISOC99_PRINTF;\n  INIT_FREXP;\n  INIT_FREXPF_FREXPL;\n  INIT_GETPWNAM_AND_FRIENDS;\n  INIT_GETPWNAM_R_AND_FRIENDS;\n  INIT_GETPWENT;\n  INIT_FGETPWENT;\n  INIT_GETPWENT_R;\n  INIT_FGETPWENT_R;\n  INIT_FGETGRENT_R;\n  INIT_SETPWENT;\n  INIT_CLOCK_GETTIME;\n  INIT_CLOCK_GETCPUCLOCKID;\n  INIT_GETITIMER;\n  INIT_TIME;\n  INIT_GLOB;\n  INIT_GLOB64;\n  INIT_WAIT;\n  INIT_WAIT4;\n  INIT_INET;\n  INIT_PTHREAD_GETSCHEDPARAM;\n  INIT_GETADDRINFO;\n  INIT_GETNAMEINFO;\n  INIT_GETSOCKNAME;\n  INIT_GETHOSTBYNAME;\n  INIT_GETHOSTBYNAME2;\n  INIT_GETHOSTBYNAME_R;\n  INIT_GETHOSTBYNAME2_R;\n  INIT_GETHOSTBYADDR_R;\n  INIT_GETHOSTENT_R;\n  INIT_GETSOCKOPT;\n  INIT_ACCEPT;\n  INIT_ACCEPT4;\n  INIT_PACCEPT;\n  INIT_MODF;\n  INIT_RECVMSG;\n  INIT_SENDMSG;\n  INIT_RECVMMSG;\n  INIT_SENDMMSG;\n  INIT_SYSMSG;\n  INIT_GETPEERNAME;\n  INIT_IOCTL;\n  INIT_INET_ATON;\n  INIT_SYSINFO;\n  INIT_READDIR;\n  INIT_READDIR64;\n  INIT_PTRACE;\n  INIT_SETLOCALE;\n  INIT_GETCWD;\n  INIT_GET_CURRENT_DIR_NAME;\n  INIT_STRTOIMAX;\n  INIT_MBSTOWCS;\n  INIT_MBSNRTOWCS;\n  INIT_WCSTOMBS;\n  INIT_WCSNRTOMBS;\n  INIT_WCRTOMB;\n  INIT_WCTOMB;\n  INIT_TCGETATTR;\n  INIT_REALPATH;\n  INIT_CANONICALIZE_FILE_NAME;\n  INIT_CONFSTR;\n  INIT_SCHED_GETAFFINITY;\n  INIT_SCHED_GETPARAM;\n  INIT_STRERROR;\n  INIT_STRERROR_R;\n  INIT_XPG_STRERROR_R;\n  INIT_SCANDIR;\n  INIT_SCANDIR64;\n  INIT_GETGROUPS;\n  INIT_POLL;\n  INIT_PPOLL;\n  INIT_WORDEXP;\n  INIT_SIGWAIT;\n  INIT_SIGWAITINFO;\n  INIT_SIGTIMEDWAIT;\n  INIT_SIGSETOPS;\n  INIT_SIGSET_LOGICOPS;\n  INIT_SIGPENDING;\n  INIT_SIGPROCMASK;\n  INIT_PTHREAD_SIGMASK;\n  INIT_BACKTRACE;\n  INIT__EXIT;\n  INIT_PTHREAD_MUTEX_LOCK;\n  INIT_PTHREAD_MUTEX_UNLOCK;\n  INIT___PTHREAD_MUTEX_LOCK;\n  INIT___PTHREAD_MUTEX_UNLOCK;\n  INIT___LIBC_MUTEX_LOCK;\n  INIT___LIBC_MUTEX_UNLOCK;\n  INIT___LIBC_THR_SETCANCELSTATE;\n  INIT_GETMNTENT;\n  INIT_GETMNTENT_R;\n  INIT_STATFS;\n  INIT_STATFS64;\n  INIT_STATVFS;\n  INIT_STATVFS64;\n  INIT_INITGROUPS;\n  INIT_ETHER_NTOA_ATON;\n  INIT_ETHER_HOST;\n  INIT_ETHER_R;\n  INIT_SHMCTL;\n  INIT_RANDOM_R;\n  INIT_PTHREAD_ATTR_GET;\n  INIT_PTHREAD_ATTR_GET_SCHED;\n  INIT_PTHREAD_ATTR_GETINHERITSCHED;\n  INIT_PTHREAD_ATTR_GETAFFINITY_NP;\n  INIT_PTHREAD_MUTEXATTR_GETPSHARED;\n  INIT_PTHREAD_MUTEXATTR_GETTYPE;\n  INIT_PTHREAD_MUTEXATTR_GETPROTOCOL;\n  INIT_PTHREAD_MUTEXATTR_GETPRIOCEILING;\n  INIT_PTHREAD_MUTEXATTR_GETROBUST;\n  INIT_PTHREAD_MUTEXATTR_GETROBUST_NP;\n  INIT_PTHREAD_RWLOCKATTR_GETPSHARED;\n  INIT_PTHREAD_RWLOCKATTR_GETKIND_NP;\n  INIT_PTHREAD_CONDATTR_GETPSHARED;\n  INIT_PTHREAD_CONDATTR_GETCLOCK;\n  INIT_PTHREAD_BARRIERATTR_GETPSHARED;\n  INIT_TMPNAM;\n  INIT_TMPNAM_R;\n  INIT_PTSNAME;\n  INIT_PTSNAME_R;\n  INIT_TTYNAME;\n  INIT_TTYNAME_R;\n  INIT_TEMPNAM;\n  INIT_PTHREAD_SETNAME_NP;\n  INIT_PTHREAD_GETNAME_NP;\n  INIT_SINCOS;\n  INIT_REMQUO;\n  INIT_REMQUOL;\n  INIT_LGAMMA;\n  INIT_LGAMMAL;\n  INIT_LGAMMA_R;\n  INIT_LGAMMAL_R;\n  INIT_DRAND48_R;\n  INIT_RAND_R;\n  INIT_GETLINE;\n  INIT_ICONV;\n  INIT_TIMES;\n  INIT_TLS_GET_ADDR;\n  INIT_LISTXATTR;\n  INIT_GETXATTR;\n  INIT_GETRESID;\n  INIT_GETIFADDRS;\n  INIT_IF_INDEXTONAME;\n  INIT_CAPGET;\n  INIT_AEABI_MEM;\n  INIT___BZERO;\n  INIT_BZERO;\n  INIT_FTIME;\n  INIT_XDR;\n  INIT_XDRREC_LINUX;\n  INIT_TSEARCH;\n  INIT_LIBIO_INTERNALS;\n  INIT_FOPEN;\n  INIT_FOPEN64;\n  INIT_OPEN_MEMSTREAM;\n  INIT_OBSTACK;\n  INIT_FFLUSH;\n  INIT_FCLOSE;\n  INIT_DLOPEN_DLCLOSE;\n  INIT_GETPASS;\n  INIT_TIMERFD;\n  INIT_MLOCKX;\n  INIT_FOPENCOOKIE;\n  INIT_SEM;\n  INIT_PTHREAD_SETCANCEL;\n  INIT_MINCORE;\n  INIT_PROCESS_VM_READV;\n  INIT_CTERMID;\n  INIT_CTERMID_R;\n  INIT_RECV_RECVFROM;\n  INIT_SEND_SENDTO;\n  INIT_STAT;\n  INIT_EVENTFD_READ_WRITE;\n  INIT_LSTAT;\n  INIT___XSTAT;\n  INIT___XSTAT64;\n  INIT___LXSTAT;\n  INIT___LXSTAT64;\n  // FIXME: add other *stat interceptors.\n  INIT_UTMP;\n  INIT_UTMPX;\n  INIT_GETLOADAVG;\n  INIT_WCSLEN;\n  INIT_WCSCAT;\n  INIT_WCSDUP;\n  INIT_WCSXFRM;\n  INIT___WCSXFRM_L;\n  INIT_ACCT;\n  INIT_USER_FROM_UID;\n  INIT_UID_FROM_USER;\n  INIT_GROUP_FROM_GID;\n  INIT_GID_FROM_GROUP;\n  INIT_ACCESS;\n  INIT_FACCESSAT;\n  INIT_GETGROUPLIST;\n  INIT_GETGROUPMEMBERSHIP;\n  INIT_READLINK;\n  INIT_READLINKAT;\n  INIT_NAME_TO_HANDLE_AT;\n  INIT_OPEN_BY_HANDLE_AT;\n  INIT_STRLCPY;\n  INIT_DEVNAME;\n  INIT_DEVNAME_R;\n  INIT_FGETLN;\n  INIT_STRMODE;\n  INIT_TTYENT;\n  INIT_PROTOENT;\n  INIT_PROTOENT_R;\n  INIT_NETENT;\n  INIT_GETMNTINFO;\n  INIT_MI_VECTOR_HASH;\n  INIT_SETVBUF;\n  INIT_GETVFSSTAT;\n  INIT_REGEX;\n  INIT_REGEXSUB;\n  INIT_FTS;\n  INIT_SYSCTL;\n  INIT_ASYSCTL;\n  INIT_SYSCTLGETMIBINFO;\n  INIT_NL_LANGINFO;\n  INIT_MODCTL;\n  INIT_STRTONUM;\n  INIT_FPARSELN;\n  INIT_STATVFS1;\n  INIT_STRTOI;\n  INIT_CAPSICUM;\n  INIT_SHA1;\n  INIT_MD4;\n  INIT_RMD160;\n  INIT_MD5;\n  INIT_FSEEK;\n  INIT_MD2;\n  INIT_SHA2;\n  INIT_VIS;\n  INIT_CDB;\n  INIT_GETFSENT;\n  INIT_ARC4RANDOM;\n  INIT_POPEN;\n  INIT_POPENVE;\n  INIT_PCLOSE;\n  INIT_FUNOPEN;\n  INIT_FUNOPEN2;\n  INIT_FDEVNAME;\n  INIT_GETUSERSHELL;\n  INIT_SL_INIT;\n  INIT_GETRANDOM;\n  INIT_CRYPT;\n  INIT_CRYPT_R;\n  INIT_GETENTROPY;\n  INIT_QSORT;\n  INIT_QSORT_R;\n  INIT_SIGALTSTACK;\n  INIT_UNAME;\n  INIT___XUNAME;\n\n  INIT___PRINTF_CHK;\n}\n"}}, "reports": [{"events": [{"location": {"col": 9, "file": 19, "line": 2282}, "message": "macro 'COMMON_INTERCEPTOR_ENTER' defined here"}, {"location": {"col": 44, "file": 18, "line": 7500}, "message": "must specify at least one argument for '...' parameter of variadic macro"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/compiler-rt/lib/sanitizer_common/sanitizer_common_interceptors.inc", "reportHash": "bafdb90d67e6bae93b1630f18a18ae87", "checkerName": "clang-diagnostic-gnu-zero-variadic-macro-arguments", "reviewStatus": null, "severity": "MEDIUM"}, {"events": [{"location": {"col": 9, "file": 19, "line": 2282}, "message": "macro 'COMMON_INTERCEPTOR_ENTER' defined here"}, {"location": {"col": 45, "file": 18, "line": 9756}, "message": "must specify at least one argument for '...' parameter of variadic macro"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/compiler-rt/lib/sanitizer_common/sanitizer_common_interceptors.inc", "reportHash": "252f1192e80cb9e40288a5b3e78c6fd0", "checkerName": "clang-diagnostic-gnu-zero-variadic-macro-arguments", "reviewStatus": null, "severity": "MEDIUM"}]};
      window.onload = function() {
        if (!browserCompatible) {
          setNonCompatibleBrowserMessage();
        } else {
          BugViewer.init(data.files, data.reports);
          BugViewer.create();
          BugViewer.initByUrl();
        }
      };
    </script>
  </head>
  <body>
  <div class="container">
    <div id="content">
      <div id="side-bar">
        <div class="header">
          <a href="index.html" class="button">&#8249; Return to List</a>
        </div>
        <div id="report-nav">
          <div class="header">Reports</div>
        </div>
      </div>
      <div id="editor-wrapper">
        <div class="header">
          <div id="file">
            <span class="label">File:</span>
            <span id="file-path"></span>
          </div>
          <div id="checker">
            <span class="label">Checker name:</span>
            <span id="checker-name"></span>
          </div>
          <div id="review-status-wrapper">
            <span class="label">Review status:</span>
            <span id="review-status"></span>
          </div>
        </div>
        <div id="editor"></div>
      </div>
    </div>
  </div>
  </body>
</html>
