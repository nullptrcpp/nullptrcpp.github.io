<!DOCTYPE html>
<html>
  <head>
    <title>Plist HTML Viewer</title>

    <meta charset="UTF-8">

    <style type="text/css">
      .CodeMirror{font-family:monospace;height:300px;color:#000;direction:ltr}.CodeMirror-lines{padding:4px 0}.CodeMirror pre{padding:0 4px}.CodeMirror-gutter-filler,.CodeMirror-scrollbar-filler{background-color:#fff}.CodeMirror-gutters{border-right:1px solid #ddd;background-color:#f7f7f7;white-space:nowrap}.CodeMirror-linenumber{padding:0 3px 0 5px;min-width:20px;text-align:right;color:#999;white-space:nowrap}.CodeMirror-guttermarker{color:#000}.CodeMirror-guttermarker-subtle{color:#999}.CodeMirror-cursor{border-left:1px solid #000;border-right:none;width:0}.CodeMirror div.CodeMirror-secondarycursor{border-left:1px solid silver}.cm-fat-cursor .CodeMirror-cursor{width:auto;border:0!important;background:#7e7}.cm-fat-cursor div.CodeMirror-cursors{z-index:1}.cm-animate-fat-cursor{width:auto;border:0;-webkit-animation:blink 1.06s steps(1) infinite;-moz-animation:blink 1.06s steps(1) infinite;animation:blink 1.06s steps(1) infinite;background-color:#7e7}@-moz-keyframes blink{50%{background-color:transparent}}@-webkit-keyframes blink{50%{background-color:transparent}}@keyframes blink{50%{background-color:transparent}}.cm-tab{display:inline-block;text-decoration:inherit}.CodeMirror-rulers{position:absolute;left:0;right:0;top:-50px;bottom:-20px;overflow:hidden}.CodeMirror-ruler{border-left:1px solid #ccc;top:0;bottom:0;position:absolute}.cm-s-default .cm-header{color:#00f}.cm-s-default .cm-quote{color:#090}.cm-negative{color:#d44}.cm-positive{color:#292}.cm-header,.cm-strong{font-weight:700}.cm-em{font-style:italic}.cm-link{text-decoration:underline}.cm-strikethrough{text-decoration:line-through}.cm-s-default .cm-keyword{color:#708}.cm-s-default .cm-atom{color:#219}.cm-s-default .cm-number{color:#164}.cm-s-default .cm-def{color:#00f}.cm-s-default .cm-variable-2{color:#05a}.cm-s-default .cm-type,.cm-s-default .cm-variable-3{color:#085}.cm-s-default .cm-comment{color:#a50}.cm-s-default .cm-string{color:#a11}.cm-s-default .cm-string-2{color:#f50}.cm-s-default .cm-meta{color:#555}.cm-s-default .cm-qualifier{color:#555}.cm-s-default .cm-builtin{color:#30a}.cm-s-default .cm-bracket{color:#997}.cm-s-default .cm-tag{color:#170}.cm-s-default .cm-attribute{color:#00c}.cm-s-default .cm-hr{color:#999}.cm-s-default .cm-link{color:#00c}.cm-s-default .cm-error{color:red}.cm-invalidchar{color:red}.CodeMirror-composing{border-bottom:2px solid}div.CodeMirror span.CodeMirror-matchingbracket{color:#0f0}div.CodeMirror span.CodeMirror-nonmatchingbracket{color:#f22}.CodeMirror-matchingtag{background:rgba(255,150,0,.3)}.CodeMirror-activeline-background{background:#e8f2ff}.CodeMirror{position:relative;overflow:hidden;background:#fff}.CodeMirror-scroll{overflow:scroll!important;margin-bottom:-30px;margin-right:-30px;padding-bottom:30px;height:100%;outline:0;position:relative}.CodeMirror-sizer{position:relative;border-right:30px solid transparent}.CodeMirror-gutter-filler,.CodeMirror-hscrollbar,.CodeMirror-scrollbar-filler,.CodeMirror-vscrollbar{position:absolute;z-index:6;display:none}.CodeMirror-vscrollbar{right:0;top:0;overflow-x:hidden;overflow-y:scroll}.CodeMirror-hscrollbar{bottom:0;left:0;overflow-y:hidden;overflow-x:scroll}.CodeMirror-scrollbar-filler{right:0;bottom:0}.CodeMirror-gutter-filler{left:0;bottom:0}.CodeMirror-gutters{position:absolute;left:0;top:0;min-height:100%;z-index:3}.CodeMirror-gutter{white-space:normal;height:100%;display:inline-block;vertical-align:top;margin-bottom:-30px}.CodeMirror-gutter-wrapper{position:absolute;z-index:4;background:0 0!important;border:none!important}.CodeMirror-gutter-background{position:absolute;top:0;bottom:0;z-index:4}.CodeMirror-gutter-elt{position:absolute;cursor:default;z-index:4}.CodeMirror-gutter-wrapper ::selection{background-color:transparent}.CodeMirror-gutter-wrapper ::-moz-selection{background-color:transparent}.CodeMirror-lines{cursor:text;min-height:1px}.CodeMirror pre{-moz-border-radius:0;-webkit-border-radius:0;border-radius:0;border-width:0;background:0 0;font-family:inherit;font-size:inherit;margin:0;white-space:pre;word-wrap:normal;line-height:inherit;color:inherit;z-index:2;position:relative;overflow:visible;-webkit-tap-highlight-color:transparent;-webkit-font-variant-ligatures:contextual;font-variant-ligatures:contextual}.CodeMirror-wrap pre{word-wrap:break-word;white-space:pre-wrap;word-break:normal}.CodeMirror-linebackground{position:absolute;left:0;right:0;top:0;bottom:0;z-index:0}.CodeMirror-linewidget{position:relative;z-index:2;overflow:auto}.CodeMirror-rtl pre{direction:rtl}.CodeMirror-code{outline:0}.CodeMirror-gutter,.CodeMirror-gutters,.CodeMirror-linenumber,.CodeMirror-scroll,.CodeMirror-sizer{-moz-box-sizing:content-box;box-sizing:content-box}.CodeMirror-measure{position:absolute;width:100%;height:0;overflow:hidden;visibility:hidden}.CodeMirror-cursor{position:absolute;pointer-events:none}.CodeMirror-measure pre{position:static}div.CodeMirror-cursors{visibility:hidden;position:relative;z-index:3}div.CodeMirror-dragcursors{visibility:visible}.CodeMirror-focused div.CodeMirror-cursors{visibility:visible}.CodeMirror-selected{background:#d9d9d9}.CodeMirror-focused .CodeMirror-selected{background:#d7d4f0}.CodeMirror-crosshair{cursor:crosshair}.CodeMirror-line::selection,.CodeMirror-line>span::selection,.CodeMirror-line>span>span::selection{background:#d7d4f0}.CodeMirror-line::-moz-selection,.CodeMirror-line>span::-moz-selection,.CodeMirror-line>span>span::-moz-selection{background:#d7d4f0}.cm-searching{background-color:#ffa;background-color:rgba(255,255,0,.4)}.cm-force-border{padding-right:.1px}@media print{.CodeMirror div.CodeMirror-cursors{visibility:hidden}}.cm-tab-wrap-hack:after{content:''}span.CodeMirror-selectedtext{background:0 0}
/*# sourceMappingURL=codemirror.min.css.map */

      .severity-low {
  background-color: #669603;
}

.severity-low:after {
  content : 'L';
}

.severity-unspecified {
  background-color: #666666;
}

.severity-unspecified:after {
  content : 'U';
}

.severity-style {
  background-color: #9932cc;
}

.severity-style:after {
  content : 'S';
}

.severity-medium {
  background-color: #a9d323;
  color: black;
}

.severity-medium:after {
  content : 'M';
}

.severity-high {
  background-color: #ffa800;
}

.severity-high:after {
  content : 'H';
}

.severity-critical {
  background-color: #e92625;
}

.severity-critical:after {
  content : 'C';
}

i[class*="severity-"] {
  line-height: normal;
  text-transform: capitalize;
  font-size: 0.8em;
  font-weight: bold;
  color: white;
  display: inline-block;
  width: 16px;
  height: 16px;
  text-align: center;
  font-family: sans-serif;
}

      html, body {
  width: 100%;
  height: 100%;
  padding: 0px;
  margin: 0px;
}

div.container {
  padding: 10px;
}

#content {
  height: 100%;
  display: block;
  overflow: hidden;
}

#content > div {
  margin: 10px;
  overflow: hidden;
  border: 1px solid #ddd;
  border-radius: 3px;
  overflow: hidden;
  height: 97%;
}

.button {
  background-color: #f1f1f1;
  text-decoration: none;
  display: inline-block;
  padding: 8px 16px;
  color: black;
  cursor: pointer;
}

.button:hover {
  background-color: #ddd;
  color: black;
}

.review-status {
  color: white;
  text-align: center;
}

.review-status-confirmed {
  background-color: #e92625;
}

.review-status-false-positive {
  background-color: grey;
}

.review-status-intentional {
  background-color: #669603;
}

      div.container {
  width: 100%;
  height: 100%;
  padding: 0px;
}

#editor-wrapper {
  margin: 10px;
}

#side-bar {
  float: left;
  width: 260px;
  margin: 0px;
}

#report-nav ul {
  list-style-type: none;
  padding: 0;
  margin: 0;
  overflow-y: auto;
  height: 100%;
}

#report-nav ul > li {
  padding: .4em;
  background-color: #fff;
  border-bottom: 1px solid rgba(0,0,0,.125);
  text-align: left;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

#report-nav ul > li.active {
  background-color: #427ea9;
  color: white;
}

#report-nav ul > li:hover {
  background-color: #427ea9;
  color: white;
  cursor: pointer;
}

#report-nav ul a {
  text-decoration: none;
}

#report-nav i[class*="severity-"] {
  margin-right: 5px;
}

.header {
  border-bottom: 1px solid lightgrey;
  font-family: monospace;
  padding: 10px;
  background-color: #fafbfc;
  border-bottom: 1px solid #e1e4e8;
  border-top-left-radius: 2px;
  border-top-right-radius: 2px;
}

#report-nav .header {
  font-weight: bold;
}

#editor-wrapper .header > div {
  padding-top: 2px;
}

#file-path,
#checker-name {
  color: #195ea2;
}

#review-status {
  padding: 0px 5px;
}

#file-path {
  font-family: monospace;
}

.check-msg {
  display: inline-block;
  padding: 3px 6px;
  margin: 1px;
  -webkit-border-radius: 5px;
  -moz-border-radius: 5px;
  border-radius: 5px;
}

.check-msg.info {
  color: #00546f;
  background-color: #bfdfe9;
  border: 1px solid #87a8b3;
}

.check-msg.error {
  background-color: #f2dede;
  color: #a94442;
  border: 1px solid #ebcccc;
}

.check-msg.macro {
  background-color: #d7dac2;
  color: #4f5c6d;
  border: 1px solid #d7dac2;
}

.check-msg.note {
  background-color: #d7d7d7;
  color: #4f5c6d;
  border: 1px solid #bfbfbf;
}

.check-msg.current {
  border: 2px dashed #3692ff;
}

.check-msg .tag {
  padding: 1px 5px;
  text-align: center;
  border-radius: 2px;
  margin-right: 5px;
  text-decoration: inherit;
}

.check-msg .tag.macro {
  background-color: #83876a;
  color: white;
  text-transform: capitalize;
}

.check-msg .tag.note {
  background-color: #9299a1;
  color: white;
  text-transform: capitalize;
}

.checker-enum {
  color: white;
  padding: 1px 5px;
  text-align: center;
  border-radius: 25px;
  margin-right: 5px;
  text-decoration: inherit;
}

.checker-enum.info {
  background-color: #427ea9;
}

.checker-enum.error {
  background-color: #a94442;
}

.arrow {
  border: solid black;
  border-width: 0 3px 3px 0;
  display: inline-block;
  padding: 3px;
  cursor: pointer;
  margin: 0px 5px;
}

.arrow:hover {
  border: solid #437ea8;
  border-width: 0 3px 3px 0;
}

.left-arrow {
  transform: rotate(135deg);
  -webkit-transform: rotate(135deg);
}

.right-arrow {
  transform: rotate(-45deg);
  -webkit-transform: rotate(-45deg);
}

    </style>

    <script type="text/javascript">
      function setNonCompatibleBrowserMessage() {
  document.body.innerHTML =
    '<h2 style="margin-left: 20px;">Your browser is not compatible with CodeChecker Viewer!</h2> \
     <p style="margin-left: 20px;">The version required for the following browsers are:</p> \
     <ul style="margin-left: 20px;"> \
     <li>Internet Explorer: version 9 or newer</li> \
     <li>Firefox: version 22.0 or newer</li> \
     </ul>';
}

// http://stackoverflow.com/questions/5916900/how-can-you-detect-the-version-of-a-browser
var browserVersion = (function(){
  var ua = navigator.userAgent, tem,
    M = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];

  if (/trident/i.test(M[1])) {
    tem = /\brv[ :]+(\d+)/g.exec(ua) || [];
    return 'IE ' + (tem[1] || '');
  }

  if (M[1] === 'Chrome') {
    tem = ua.match(/\b(OPR|Edge)\/(\d+)/);
    if (tem != null) return tem.slice(1).join(' ').replace('OPR', 'Opera');
  }

  M = M[2] ? [M[1], M[2]] : [navigator.appName, navigator.appVersion, '-?'];
  if ((tem = ua.match(/version\/(\d+)/i)) != null) M.splice(1, 1, tem[1]);
    return M.join(' ');
})();

var pos = browserVersion.indexOf(' ');
var browser = browserVersion.substr(0, pos);
var version = parseInt(browserVersion.substr(pos + 1));

var browserCompatible
  = browser === 'Firefox'
  ? version >= 22
  : browser === 'IE'
  ? version >= 9
  : true;


      /* MIT License

Copyright (C) 2017 by Marijn Haverbeke <marijnh@gmail.com> and others

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
 */
      !function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):e.CodeMirror=t()}(this,function(){"use strict";function e(e){return new RegExp("(^|\\s)"+e+"(?:$|\\s)\\s*")}function t(e){for(var t=e.childNodes.length;t>0;--t)e.removeChild(e.firstChild);return e}function r(e,r){return t(e).appendChild(r)}function n(e,t,r,n){var i=document.createElement(e);if(r&&(i.className=r),n&&(i.style.cssText=n),"string"==typeof t)i.appendChild(document.createTextNode(t));else if(t)for(var o=0;o<t.length;++o)i.appendChild(t[o]);return i}function i(e,t,r,i){var o=n(e,t,r,i);return o.setAttribute("role","presentation"),o}function o(e,t){if(3==t.nodeType&&(t=t.parentNode),e.contains)return e.contains(t);do{if(11==t.nodeType&&(t=t.host),t==e)return!0}while(t=t.parentNode)}function l(){var e;try{e=document.activeElement}catch(t){e=document.body||null}for(;e&&e.shadowRoot&&e.shadowRoot.activeElement;)e=e.shadowRoot.activeElement;return e}function s(t,r){var n=t.className;e(r).test(n)||(t.className+=(n?" ":"")+r)}function a(t,r){for(var n=t.split(" "),i=0;i<n.length;i++)n[i]&&!e(n[i]).test(r)&&(r+=" "+n[i]);return r}function u(e){var t=Array.prototype.slice.call(arguments,1);return function(){return e.apply(null,t)}}function c(e,t,r){t||(t={});for(var n in e)!e.hasOwnProperty(n)||!1===r&&t.hasOwnProperty(n)||(t[n]=e[n]);return t}function f(e,t,r,n,i){null==t&&-1==(t=e.search(/[^\s\u00a0]/))&&(t=e.length);for(var o=n||0,l=i||0;;){var s=e.indexOf("\t",o);if(s<0||s>=t)return l+(t-o);l+=s-o,l+=r-l%r,o=s+1}}function h(e,t){for(var r=0;r<e.length;++r)if(e[r]==t)return r;return-1}function d(e,t,r){for(var n=0,i=0;;){var o=e.indexOf("\t",n);-1==o&&(o=e.length);var l=o-n;if(o==e.length||i+l>=t)return n+Math.min(l,t-i);if(i+=o-n,i+=r-i%r,n=o+1,i>=t)return n}}function p(e){for(;Kl.length<=e;)Kl.push(g(Kl)+" ");return Kl[e]}function g(e){return e[e.length-1]}function v(e,t){for(var r=[],n=0;n<e.length;n++)r[n]=t(e[n],n);return r}function m(e,t,r){for(var n=0,i=r(t);n<e.length&&r(e[n])<=i;)n++;e.splice(n,0,t)}function y(){}function b(e,t){var r;return Object.create?r=Object.create(e):(y.prototype=e,r=new y),t&&c(t,r),r}function w(e){return/\w/.test(e)||e>""&&(e.toUpperCase()!=e.toLowerCase()||jl.test(e))}function x(e,t){return t?!!(t.source.indexOf("\\w")>-1&&w(e))||t.test(e):w(e)}function C(e){for(var t in e)if(e.hasOwnProperty(t)&&e[t])return!1;return!0}function S(e){return e.charCodeAt(0)>=768&&Xl.test(e)}function L(e,t,r){for(;(r<0?t>0:t<e.length)&&S(e.charAt(t));)t+=r;return t}function k(e,t,r){for(var n=t>r?-1:1;;){if(t==r)return t;var i=(t+r)/2,o=n<0?Math.ceil(i):Math.floor(i);if(o==t)return e(o)?t:r;e(o)?r=o:t=o+n}}function T(e,t,r){var o=this;this.input=r,o.scrollbarFiller=n("div",null,"CodeMirror-scrollbar-filler"),o.scrollbarFiller.setAttribute("cm-not-content","true"),o.gutterFiller=n("div",null,"CodeMirror-gutter-filler"),o.gutterFiller.setAttribute("cm-not-content","true"),o.lineDiv=i("div",null,"CodeMirror-code"),o.selectionDiv=n("div",null,null,"position: relative; z-index: 1"),o.cursorDiv=n("div",null,"CodeMirror-cursors"),o.measure=n("div",null,"CodeMirror-measure"),o.lineMeasure=n("div",null,"CodeMirror-measure"),o.lineSpace=i("div",[o.measure,o.lineMeasure,o.selectionDiv,o.cursorDiv,o.lineDiv],null,"position: relative; outline: none");var l=i("div",[o.lineSpace],"CodeMirror-lines");o.mover=n("div",[l],null,"position: relative"),o.sizer=n("div",[o.mover],"CodeMirror-sizer"),o.sizerWidth=null,o.heightForcer=n("div",null,null,"position: absolute; height: "+Rl+"px; width: 1px;"),o.gutters=n("div",null,"CodeMirror-gutters"),o.lineGutter=null,o.scroller=n("div",[o.sizer,o.heightForcer,o.gutters],"CodeMirror-scroll"),o.scroller.setAttribute("tabIndex","-1"),o.wrapper=n("div",[o.scrollbarFiller,o.gutterFiller,o.scroller],"CodeMirror"),gl&&vl<8&&(o.gutters.style.zIndex=-1,o.scroller.style.paddingRight=0),ml||fl&&Tl||(o.scroller.draggable=!0),e&&(e.appendChild?e.appendChild(o.wrapper):e(o.wrapper)),o.viewFrom=o.viewTo=t.first,o.reportedViewFrom=o.reportedViewTo=t.first,o.view=[],o.renderedView=null,o.externalMeasured=null,o.viewOffset=0,o.lastWrapHeight=o.lastWrapWidth=0,o.updateLineNumbers=null,o.nativeBarWidth=o.barHeight=o.barWidth=0,o.scrollbarsClipped=!1,o.lineNumWidth=o.lineNumInnerWidth=o.lineNumChars=null,o.alignWidgets=!1,o.cachedCharWidth=o.cachedTextHeight=o.cachedPaddingH=null,o.maxLine=null,o.maxLineLength=0,o.maxLineChanged=!1,o.wheelDX=o.wheelDY=o.wheelStartX=o.wheelStartY=null,o.shift=!1,o.selForContextMenu=null,o.activeTouch=null,r.init(o)}function M(e,t){if((t-=e.first)<0||t>=e.size)throw new Error("There is no line "+(t+e.first)+" in the document.");for(var r=e;!r.lines;)for(var n=0;;++n){var i=r.children[n],o=i.chunkSize();if(t<o){r=i;break}t-=o}return r.lines[t]}function N(e,t,r){var n=[],i=t.line;return e.iter(t.line,r.line+1,function(e){var o=e.text;i==r.line&&(o=o.slice(0,r.ch)),i==t.line&&(o=o.slice(t.ch)),n.push(o),++i}),n}function O(e,t,r){var n=[];return e.iter(t,r,function(e){n.push(e.text)}),n}function A(e,t){var r=t-e.height;if(r)for(var n=e;n;n=n.parent)n.height+=r}function W(e){if(null==e.parent)return null;for(var t=e.parent,r=h(t.lines,e),n=t.parent;n;t=n,n=n.parent)for(var i=0;n.children[i]!=t;++i)r+=n.children[i].chunkSize();return r+t.first}function D(e,t){var r=e.first;e:do{for(var n=0;n<e.children.length;++n){var i=e.children[n],o=i.height;if(t<o){e=i;continue e}t-=o,r+=i.chunkSize()}return r}while(!e.lines);for(var l=0;l<e.lines.length;++l){var s=e.lines[l].height;if(t<s)break;t-=s}return r+l}function H(e,t){return t>=e.first&&t<e.first+e.size}function F(e,t){return String(e.lineNumberFormatter(t+e.firstLineNumber))}function E(e,t,r){if(void 0===r&&(r=null),!(this instanceof E))return new E(e,t,r);this.line=e,this.ch=t,this.sticky=r}function P(e,t){return e.line-t.line||e.ch-t.ch}function I(e,t){return e.sticky==t.sticky&&0==P(e,t)}function z(e){return E(e.line,e.ch)}function R(e,t){return P(e,t)<0?t:e}function B(e,t){return P(e,t)<0?e:t}function G(e,t){return Math.max(e.first,Math.min(t,e.first+e.size-1))}function U(e,t){if(t.line<e.first)return E(e.first,0);var r=e.first+e.size-1;return t.line>r?E(r,M(e,r).text.length):V(t,M(e,t.line).text.length)}function V(e,t){var r=e.ch;return null==r||r>t?E(e.line,t):r<0?E(e.line,0):e}function K(e,t){for(var r=[],n=0;n<t.length;n++)r[n]=U(e,t[n]);return r}function j(){Yl=!0}function X(){_l=!0}function Y(e,t,r){this.marker=e,this.from=t,this.to=r}function _(e,t){if(e)for(var r=0;r<e.length;++r){var n=e[r];if(n.marker==t)return n}}function $(e,t){for(var r,n=0;n<e.length;++n)e[n]!=t&&(r||(r=[])).push(e[n]);return r}function q(e,t){e.markedSpans=e.markedSpans?e.markedSpans.concat([t]):[t],t.marker.attachLine(e)}function Z(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t)||o.from==t&&"bookmark"==l.type&&(!r||!o.marker.insertLeft)){var s=null==o.to||(l.inclusiveRight?o.to>=t:o.to>t);(n||(n=[])).push(new Y(l,o.from,s?null:o.to))}}return n}function Q(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.to||(l.inclusiveRight?o.to>=t:o.to>t)||o.from==t&&"bookmark"==l.type&&(!r||o.marker.insertLeft)){var s=null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t);(n||(n=[])).push(new Y(l,s?null:o.from-t,null==o.to?null:o.to-t))}}return n}function J(e,t){if(t.full)return null;var r=H(e,t.from.line)&&M(e,t.from.line).markedSpans,n=H(e,t.to.line)&&M(e,t.to.line).markedSpans;if(!r&&!n)return null;var i=t.from.ch,o=t.to.ch,l=0==P(t.from,t.to),s=Z(r,i,l),a=Q(n,o,l),u=1==t.text.length,c=g(t.text).length+(u?i:0);if(s)for(var f=0;f<s.length;++f){var h=s[f];if(null==h.to){var d=_(a,h.marker);d?u&&(h.to=null==d.to?null:d.to+c):h.to=i}}if(a)for(var p=0;p<a.length;++p){var v=a[p];null!=v.to&&(v.to+=c),null==v.from?_(s,v.marker)||(v.from=c,u&&(s||(s=[])).push(v)):(v.from+=c,u&&(s||(s=[])).push(v))}s&&(s=ee(s)),a&&a!=s&&(a=ee(a));var m=[s];if(!u){var y,b=t.text.length-2;if(b>0&&s)for(var w=0;w<s.length;++w)null==s[w].to&&(y||(y=[])).push(new Y(s[w].marker,null,null));for(var x=0;x<b;++x)m.push(y);m.push(a)}return m}function ee(e){for(var t=0;t<e.length;++t){var r=e[t];null!=r.from&&r.from==r.to&&!1!==r.marker.clearWhenEmpty&&e.splice(t--,1)}return e.length?e:null}function te(e,t,r){var n=null;if(e.iter(t.line,r.line+1,function(e){if(e.markedSpans)for(var t=0;t<e.markedSpans.length;++t){var r=e.markedSpans[t].marker;!r.readOnly||n&&-1!=h(n,r)||(n||(n=[])).push(r)}}),!n)return null;for(var i=[{from:t,to:r}],o=0;o<n.length;++o)for(var l=n[o],s=l.find(0),a=0;a<i.length;++a){var u=i[a];if(!(P(u.to,s.from)<0||P(u.from,s.to)>0)){var c=[a,1],f=P(u.from,s.from),d=P(u.to,s.to);(f<0||!l.inclusiveLeft&&!f)&&c.push({from:u.from,to:s.from}),(d>0||!l.inclusiveRight&&!d)&&c.push({from:s.to,to:u.to}),i.splice.apply(i,c),a+=c.length-3}}return i}function re(e){var t=e.markedSpans;if(t){for(var r=0;r<t.length;++r)t[r].marker.detachLine(e);e.markedSpans=null}}function ne(e,t){if(t){for(var r=0;r<t.length;++r)t[r].marker.attachLine(e);e.markedSpans=t}}function ie(e){return e.inclusiveLeft?-1:0}function oe(e){return e.inclusiveRight?1:0}function le(e,t){var r=e.lines.length-t.lines.length;if(0!=r)return r;var n=e.find(),i=t.find(),o=P(n.from,i.from)||ie(e)-ie(t);if(o)return-o;var l=P(n.to,i.to)||oe(e)-oe(t);return l||t.id-e.id}function se(e,t){var r,n=_l&&e.markedSpans;if(n)for(var i=void 0,o=0;o<n.length;++o)(i=n[o]).marker.collapsed&&null==(t?i.from:i.to)&&(!r||le(r,i.marker)<0)&&(r=i.marker);return r}function ae(e){return se(e,!0)}function ue(e){return se(e,!1)}function ce(e,t,r,n,i){var o=M(e,t),l=_l&&o.markedSpans;if(l)for(var s=0;s<l.length;++s){var a=l[s];if(a.marker.collapsed){var u=a.marker.find(0),c=P(u.from,r)||ie(a.marker)-ie(i),f=P(u.to,n)||oe(a.marker)-oe(i);if(!(c>=0&&f<=0||c<=0&&f>=0)&&(c<=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.to,r)>=0:P(u.to,r)>0)||c>=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.from,n)<=0:P(u.from,n)<0)))return!0}}}function fe(e){for(var t;t=ae(e);)e=t.find(-1,!0).line;return e}function he(e){for(var t;t=ue(e);)e=t.find(1,!0).line;return e}function de(e){for(var t,r;t=ue(e);)e=t.find(1,!0).line,(r||(r=[])).push(e);return r}function pe(e,t){var r=M(e,t),n=fe(r);return r==n?t:W(n)}function ge(e,t){if(t>e.lastLine())return t;var r,n=M(e,t);if(!ve(e,n))return t;for(;r=ue(n);)n=r.find(1,!0).line;return W(n)+1}function ve(e,t){var r=_l&&t.markedSpans;if(r)for(var n=void 0,i=0;i<r.length;++i)if((n=r[i]).marker.collapsed){if(null==n.from)return!0;if(!n.marker.widgetNode&&0==n.from&&n.marker.inclusiveLeft&&me(e,t,n))return!0}}function me(e,t,r){if(null==r.to){var n=r.marker.find(1,!0);return me(e,n.line,_(n.line.markedSpans,r.marker))}if(r.marker.inclusiveRight&&r.to==t.text.length)return!0;for(var i=void 0,o=0;o<t.markedSpans.length;++o)if((i=t.markedSpans[o]).marker.collapsed&&!i.marker.widgetNode&&i.from==r.to&&(null==i.to||i.to!=r.from)&&(i.marker.inclusiveLeft||r.marker.inclusiveRight)&&me(e,t,i))return!0}function ye(e){for(var t=0,r=(e=fe(e)).parent,n=0;n<r.lines.length;++n){var i=r.lines[n];if(i==e)break;t+=i.height}for(var o=r.parent;o;r=o,o=r.parent)for(var l=0;l<o.children.length;++l){var s=o.children[l];if(s==r)break;t+=s.height}return t}function be(e){if(0==e.height)return 0;for(var t,r=e.text.length,n=e;t=ae(n);){var i=t.find(0,!0);n=i.from.line,r+=i.from.ch-i.to.ch}for(n=e;t=ue(n);){var o=t.find(0,!0);r-=n.text.length-o.from.ch,r+=(n=o.to.line).text.length-o.to.ch}return r}function we(e){var t=e.display,r=e.doc;t.maxLine=M(r,r.first),t.maxLineLength=be(t.maxLine),t.maxLineChanged=!0,r.iter(function(e){var r=be(e);r>t.maxLineLength&&(t.maxLineLength=r,t.maxLine=e)})}function xe(e,t,r,n){if(!e)return n(t,r,"ltr",0);for(var i=!1,o=0;o<e.length;++o){var l=e[o];(l.from<r&&l.to>t||t==r&&l.to==t)&&(n(Math.max(l.from,t),Math.min(l.to,r),1==l.level?"rtl":"ltr",o),i=!0)}i||n(t,r,"ltr")}function Ce(e,t,r){var n;$l=null;for(var i=0;i<e.length;++i){var o=e[i];if(o.from<t&&o.to>t)return i;o.to==t&&(o.from!=o.to&&"before"==r?n=i:$l=i),o.from==t&&(o.from!=o.to&&"before"!=r?n=i:$l=i)}return null!=n?n:$l}function Se(e,t){var r=e.order;return null==r&&(r=e.order=ql(e.text,t)),r}function Le(e,t){return e._handlers&&e._handlers[t]||Zl}function ke(e,t,r){if(e.removeEventListener)e.removeEventListener(t,r,!1);else if(e.detachEvent)e.detachEvent("on"+t,r);else{var n=e._handlers,i=n&&n[t];if(i){var o=h(i,r);o>-1&&(n[t]=i.slice(0,o).concat(i.slice(o+1)))}}}function Te(e,t){var r=Le(e,t);if(r.length)for(var n=Array.prototype.slice.call(arguments,2),i=0;i<r.length;++i)r[i].apply(null,n)}function Me(e,t,r){return"string"==typeof t&&(t={type:t,preventDefault:function(){this.defaultPrevented=!0}}),Te(e,r||t.type,e,t),He(t)||t.codemirrorIgnore}function Ne(e){var t=e._handlers&&e._handlers.cursorActivity;if(t)for(var r=e.curOp.cursorActivityHandlers||(e.curOp.cursorActivityHandlers=[]),n=0;n<t.length;++n)-1==h(r,t[n])&&r.push(t[n])}function Oe(e,t){return Le(e,t).length>0}function Ae(e){e.prototype.on=function(e,t){Ql(this,e,t)},e.prototype.off=function(e,t){ke(this,e,t)}}function We(e){e.preventDefault?e.preventDefault():e.returnValue=!1}function De(e){e.stopPropagation?e.stopPropagation():e.cancelBubble=!0}function He(e){return null!=e.defaultPrevented?e.defaultPrevented:0==e.returnValue}function Fe(e){We(e),De(e)}function Ee(e){return e.target||e.srcElement}function Pe(e){var t=e.which;return null==t&&(1&e.button?t=1:2&e.button?t=3:4&e.button&&(t=2)),Ml&&e.ctrlKey&&1==t&&(t=3),t}function Ie(e){if(null==Il){var t=n("span","​");r(e,n("span",[t,document.createTextNode("x")])),0!=e.firstChild.offsetHeight&&(Il=t.offsetWidth<=1&&t.offsetHeight>2&&!(gl&&vl<8))}var i=Il?n("span","​"):n("span"," ",null,"display: inline-block; width: 1px; margin-right: -1px");return i.setAttribute("cm-text",""),i}function ze(e){if(null!=zl)return zl;var n=r(e,document.createTextNode("AخA")),i=Wl(n,0,1).getBoundingClientRect(),o=Wl(n,1,2).getBoundingClientRect();return t(e),!(!i||i.left==i.right)&&(zl=o.right-i.right<3)}function Re(e){if(null!=ns)return ns;var t=r(e,n("span","x")),i=t.getBoundingClientRect(),o=Wl(t,0,1).getBoundingClientRect();return ns=Math.abs(i.left-o.left)>1}function Be(e,t){arguments.length>2&&(t.dependencies=Array.prototype.slice.call(arguments,2)),is[e]=t}function Ge(e){if("string"==typeof e&&os.hasOwnProperty(e))e=os[e];else if(e&&"string"==typeof e.name&&os.hasOwnProperty(e.name)){var t=os[e.name];"string"==typeof t&&(t={name:t}),(e=b(t,e)).name=t.name}else{if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+xml$/.test(e))return Ge("application/xml");if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+json$/.test(e))return Ge("application/json")}return"string"==typeof e?{name:e}:e||{name:"null"}}function Ue(e,t){t=Ge(t);var r=is[t.name];if(!r)return Ue(e,"text/plain");var n=r(e,t);if(ls.hasOwnProperty(t.name)){var i=ls[t.name];for(var o in i)i.hasOwnProperty(o)&&(n.hasOwnProperty(o)&&(n["_"+o]=n[o]),n[o]=i[o])}if(n.name=t.name,t.helperType&&(n.helperType=t.helperType),t.modeProps)for(var l in t.modeProps)n[l]=t.modeProps[l];return n}function Ve(e,t){c(t,ls.hasOwnProperty(e)?ls[e]:ls[e]={})}function Ke(e,t){if(!0===t)return t;if(e.copyState)return e.copyState(t);var r={};for(var n in t){var i=t[n];i instanceof Array&&(i=i.concat([])),r[n]=i}return r}function je(e,t){for(var r;e.innerMode&&(r=e.innerMode(t))&&r.mode!=e;)t=r.state,e=r.mode;return r||{mode:e,state:t}}function Xe(e,t,r){return!e.startState||e.startState(t,r)}function Ye(e,t,r,n){var i=[e.state.modeGen],o={};tt(e,t.text,e.doc.mode,r,function(e,t){return i.push(e,t)},o,n);for(var l=r.state,s=0;s<e.state.overlays.length;++s)!function(n){var l=e.state.overlays[n],s=1,a=0;r.state=!0,tt(e,t.text,l.mode,r,function(e,t){for(var r=s;a<e;){var n=i[s];n>e&&i.splice(s,1,e,i[s+1],n),s+=2,a=Math.min(e,n)}if(t)if(l.opaque)i.splice(r,s-r,e,"overlay "+t),s=r+2;else for(;r<s;r+=2){var o=i[r+1];i[r+1]=(o?o+" ":"")+"overlay "+t}},o)}(s);return r.state=l,{styles:i,classes:o.bgClass||o.textClass?o:null}}function _e(e,t,r){if(!t.styles||t.styles[0]!=e.state.modeGen){var n=$e(e,W(t)),i=t.text.length>e.options.maxHighlightLength&&Ke(e.doc.mode,n.state),o=Ye(e,t,n);i&&(n.state=i),t.stateAfter=n.save(!i),t.styles=o.styles,o.classes?t.styleClasses=o.classes:t.styleClasses&&(t.styleClasses=null),r===e.doc.highlightFrontier&&(e.doc.modeFrontier=Math.max(e.doc.modeFrontier,++e.doc.highlightFrontier))}return t.styles}function $e(e,t,r){var n=e.doc,i=e.display;if(!n.mode.startState)return new us(n,!0,t);var o=rt(e,t,r),l=o>n.first&&M(n,o-1).stateAfter,s=l?us.fromSaved(n,l,o):new us(n,Xe(n.mode),o);return n.iter(o,t,function(r){qe(e,r.text,s);var n=s.line;r.stateAfter=n==t-1||n%5==0||n>=i.viewFrom&&n<i.viewTo?s.save():null,s.nextLine()}),r&&(n.modeFrontier=s.line),s}function qe(e,t,r,n){var i=e.doc.mode,o=new ss(t,e.options.tabSize,r);for(o.start=o.pos=n||0,""==t&&Ze(i,r.state);!o.eol();)Qe(i,o,r.state),o.start=o.pos}function Ze(e,t){if(e.blankLine)return e.blankLine(t);if(e.innerMode){var r=je(e,t);return r.mode.blankLine?r.mode.blankLine(r.state):void 0}}function Qe(e,t,r,n){for(var i=0;i<10;i++){n&&(n[0]=je(e,r).mode);var o=e.token(t,r);if(t.pos>t.start)return o}throw new Error("Mode "+e.name+" failed to advance stream.")}function Je(e,t,r,n){var i,o,l=e.doc,s=l.mode,a=M(l,(t=U(l,t)).line),u=$e(e,t.line,r),c=new ss(a.text,e.options.tabSize,u);for(n&&(o=[]);(n||c.pos<t.ch)&&!c.eol();)c.start=c.pos,i=Qe(s,c,u.state),n&&o.push(new cs(c,i,Ke(l.mode,u.state)));return n?o:new cs(c,i,u.state)}function et(e,t){if(e)for(;;){var r=e.match(/(?:^|\s+)line-(background-)?(\S+)/);if(!r)break;e=e.slice(0,r.index)+e.slice(r.index+r[0].length);var n=r[1]?"bgClass":"textClass";null==t[n]?t[n]=r[2]:new RegExp("(?:^|s)"+r[2]+"(?:$|s)").test(t[n])||(t[n]+=" "+r[2])}return e}function tt(e,t,r,n,i,o,l){var s=r.flattenSpans;null==s&&(s=e.options.flattenSpans);var a,u=0,c=null,f=new ss(t,e.options.tabSize,n),h=e.options.addModeClass&&[null];for(""==t&&et(Ze(r,n.state),o);!f.eol();){if(f.pos>e.options.maxHighlightLength?(s=!1,l&&qe(e,t,n,f.pos),f.pos=t.length,a=null):a=et(Qe(r,f,n.state,h),o),h){var d=h[0].name;d&&(a="m-"+(a?d+" "+a:d))}if(!s||c!=a){for(;u<f.start;)i(u=Math.min(f.start,u+5e3),c);c=a}f.start=f.pos}for(;u<f.pos;){var p=Math.min(f.pos,u+5e3);i(p,c),u=p}}function rt(e,t,r){for(var n,i,o=e.doc,l=r?-1:t-(e.doc.mode.innerMode?1e3:100),s=t;s>l;--s){if(s<=o.first)return o.first;var a=M(o,s-1),u=a.stateAfter;if(u&&(!r||s+(u instanceof as?u.lookAhead:0)<=o.modeFrontier))return s;var c=f(a.text,null,e.options.tabSize);(null==i||n>c)&&(i=s-1,n=c)}return i}function nt(e,t){if(e.modeFrontier=Math.min(e.modeFrontier,t),!(e.highlightFrontier<t-10)){for(var r=e.first,n=t-1;n>r;n--){var i=M(e,n).stateAfter;if(i&&(!(i instanceof as)||n+i.lookAhead<t)){r=n+1;break}}e.highlightFrontier=Math.min(e.highlightFrontier,r)}}function it(e,t,r,n){e.text=t,e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null),null!=e.order&&(e.order=null),re(e),ne(e,r);var i=n?n(e):1;i!=e.height&&A(e,i)}function ot(e){e.parent=null,re(e)}function lt(e,t){if(!e||/^\s*$/.test(e))return null;var r=t.addModeClass?ps:ds;return r[e]||(r[e]=e.replace(/\S+/g,"cm-$&"))}function st(e,t){var r=i("span",null,null,ml?"padding-right: .1px":null),n={pre:i("pre",[r],"CodeMirror-line"),content:r,col:0,pos:0,cm:e,trailingSpace:!1,splitSpaces:(gl||ml)&&e.getOption("lineWrapping")};t.measure={};for(var o=0;o<=(t.rest?t.rest.length:0);o++){var l=o?t.rest[o-1]:t.line,s=void 0;n.pos=0,n.addToken=ut,ze(e.display.measure)&&(s=Se(l,e.doc.direction))&&(n.addToken=ft(n.addToken,s)),n.map=[],dt(l,n,_e(e,l,t!=e.display.externalMeasured&&W(l))),l.styleClasses&&(l.styleClasses.bgClass&&(n.bgClass=a(l.styleClasses.bgClass,n.bgClass||"")),l.styleClasses.textClass&&(n.textClass=a(l.styleClasses.textClass,n.textClass||""))),0==n.map.length&&n.map.push(0,0,n.content.appendChild(Ie(e.display.measure))),0==o?(t.measure.map=n.map,t.measure.cache={}):((t.measure.maps||(t.measure.maps=[])).push(n.map),(t.measure.caches||(t.measure.caches=[])).push({}))}if(ml){var u=n.content.lastChild;(/\bcm-tab\b/.test(u.className)||u.querySelector&&u.querySelector(".cm-tab"))&&(n.content.className="cm-tab-wrap-hack")}return Te(e,"renderLine",e,t.line,n.pre),n.pre.className&&(n.textClass=a(n.pre.className,n.textClass||"")),n}function at(e){var t=n("span","•","cm-invalidchar");return t.title="\\u"+e.charCodeAt(0).toString(16),t.setAttribute("aria-label",t.title),t}function ut(e,t,r,i,o,l,s){if(t){var a,u=e.splitSpaces?ct(t,e.trailingSpace):t,c=e.cm.state.specialChars,f=!1;if(c.test(t)){a=document.createDocumentFragment();for(var h=0;;){c.lastIndex=h;var d=c.exec(t),g=d?d.index-h:t.length-h;if(g){var v=document.createTextNode(u.slice(h,h+g));gl&&vl<9?a.appendChild(n("span",[v])):a.appendChild(v),e.map.push(e.pos,e.pos+g,v),e.col+=g,e.pos+=g}if(!d)break;h+=g+1;var m=void 0;if("\t"==d[0]){var y=e.cm.options.tabSize,b=y-e.col%y;(m=a.appendChild(n("span",p(b),"cm-tab"))).setAttribute("role","presentation"),m.setAttribute("cm-text","\t"),e.col+=b}else"\r"==d[0]||"\n"==d[0]?((m=a.appendChild(n("span","\r"==d[0]?"␍":"␤","cm-invalidchar"))).setAttribute("cm-text",d[0]),e.col+=1):((m=e.cm.options.specialCharPlaceholder(d[0])).setAttribute("cm-text",d[0]),gl&&vl<9?a.appendChild(n("span",[m])):a.appendChild(m),e.col+=1);e.map.push(e.pos,e.pos+1,m),e.pos++}}else e.col+=t.length,a=document.createTextNode(u),e.map.push(e.pos,e.pos+t.length,a),gl&&vl<9&&(f=!0),e.pos+=t.length;if(e.trailingSpace=32==u.charCodeAt(t.length-1),r||i||o||f||s){var w=r||"";i&&(w+=i),o&&(w+=o);var x=n("span",[a],w,s);return l&&(x.title=l),e.content.appendChild(x)}e.content.appendChild(a)}}function ct(e,t){if(e.length>1&&!/  /.test(e))return e;for(var r=t,n="",i=0;i<e.length;i++){var o=e.charAt(i);" "!=o||!r||i!=e.length-1&&32!=e.charCodeAt(i+1)||(o=" "),n+=o,r=" "==o}return n}function ft(e,t){return function(r,n,i,o,l,s,a){i=i?i+" cm-force-border":"cm-force-border";for(var u=r.pos,c=u+n.length;;){for(var f=void 0,h=0;h<t.length&&!((f=t[h]).to>u&&f.from<=u);h++);if(f.to>=c)return e(r,n,i,o,l,s,a);e(r,n.slice(0,f.to-u),i,o,null,s,a),o=null,n=n.slice(f.to-u),u=f.to}}}function ht(e,t,r,n){var i=!n&&r.widgetNode;i&&e.map.push(e.pos,e.pos+t,i),!n&&e.cm.display.input.needsContentAttribute&&(i||(i=e.content.appendChild(document.createElement("span"))),i.setAttribute("cm-marker",r.id)),i&&(e.cm.display.input.setUneditable(i),e.content.appendChild(i)),e.pos+=t,e.trailingSpace=!1}function dt(e,t,r){var n=e.markedSpans,i=e.text,o=0;if(n)for(var l,s,a,u,c,f,h,d=i.length,p=0,g=1,v="",m=0;;){if(m==p){a=u=c=f=s="",h=null,m=1/0;for(var y=[],b=void 0,w=0;w<n.length;++w){var x=n[w],C=x.marker;"bookmark"==C.type&&x.from==p&&C.widgetNode?y.push(C):x.from<=p&&(null==x.to||x.to>p||C.collapsed&&x.to==p&&x.from==p)?(null!=x.to&&x.to!=p&&m>x.to&&(m=x.to,u=""),C.className&&(a+=" "+C.className),C.css&&(s=(s?s+";":"")+C.css),C.startStyle&&x.from==p&&(c+=" "+C.startStyle),C.endStyle&&x.to==m&&(b||(b=[])).push(C.endStyle,x.to),C.title&&!f&&(f=C.title),C.collapsed&&(!h||le(h.marker,C)<0)&&(h=x)):x.from>p&&m>x.from&&(m=x.from)}if(b)for(var S=0;S<b.length;S+=2)b[S+1]==m&&(u+=" "+b[S]);if(!h||h.from==p)for(var L=0;L<y.length;++L)ht(t,0,y[L]);if(h&&(h.from||0)==p){if(ht(t,(null==h.to?d+1:h.to)-p,h.marker,null==h.from),null==h.to)return;h.to==p&&(h=!1)}}if(p>=d)break;for(var k=Math.min(d,m);;){if(v){var T=p+v.length;if(!h){var M=T>k?v.slice(0,k-p):v;t.addToken(t,M,l?l+a:a,c,p+M.length==m?u:"",f,s)}if(T>=k){v=v.slice(k-p),p=k;break}p=T,c=""}v=i.slice(o,o=r[g++]),l=lt(r[g++],t.cm.options)}}else for(var N=1;N<r.length;N+=2)t.addToken(t,i.slice(o,o=r[N]),lt(r[N+1],t.cm.options))}function pt(e,t,r){this.line=t,this.rest=de(t),this.size=this.rest?W(g(this.rest))-r+1:1,this.node=this.text=null,this.hidden=ve(e,t)}function gt(e,t,r){for(var n,i=[],o=t;o<r;o=n){var l=new pt(e.doc,M(e.doc,o),o);n=o+l.size,i.push(l)}return i}function vt(e){gs?gs.ops.push(e):e.ownsGroup=gs={ops:[e],delayedCallbacks:[]}}function mt(e){var t=e.delayedCallbacks,r=0;do{for(;r<t.length;r++)t[r].call(null);for(var n=0;n<e.ops.length;n++){var i=e.ops[n];if(i.cursorActivityHandlers)for(;i.cursorActivityCalled<i.cursorActivityHandlers.length;)i.cursorActivityHandlers[i.cursorActivityCalled++].call(null,i.cm)}}while(r<t.length)}function yt(e,t){var r=e.ownsGroup;if(r)try{mt(r)}finally{gs=null,t(r)}}function bt(e,t){var r=Le(e,t);if(r.length){var n,i=Array.prototype.slice.call(arguments,2);gs?n=gs.delayedCallbacks:vs?n=vs:(n=vs=[],setTimeout(wt,0));for(var o=0;o<r.length;++o)!function(e){n.push(function(){return r[e].apply(null,i)})}(o)}}function wt(){var e=vs;vs=null;for(var t=0;t<e.length;++t)e[t]()}function xt(e,t,r,n){for(var i=0;i<t.changes.length;i++){var o=t.changes[i];"text"==o?kt(e,t):"gutter"==o?Mt(e,t,r,n):"class"==o?Tt(e,t):"widget"==o&&Nt(e,t,n)}t.changes=null}function Ct(e){return e.node==e.text&&(e.node=n("div",null,null,"position: relative"),e.text.parentNode&&e.text.parentNode.replaceChild(e.node,e.text),e.node.appendChild(e.text),gl&&vl<8&&(e.node.style.zIndex=2)),e.node}function St(e,t){var r=t.bgClass?t.bgClass+" "+(t.line.bgClass||""):t.line.bgClass;if(r&&(r+=" CodeMirror-linebackground"),t.background)r?t.background.className=r:(t.background.parentNode.removeChild(t.background),t.background=null);else if(r){var i=Ct(t);t.background=i.insertBefore(n("div",null,r),i.firstChild),e.display.input.setUneditable(t.background)}}function Lt(e,t){var r=e.display.externalMeasured;return r&&r.line==t.line?(e.display.externalMeasured=null,t.measure=r.measure,r.built):st(e,t)}function kt(e,t){var r=t.text.className,n=Lt(e,t);t.text==t.node&&(t.node=n.pre),t.text.parentNode.replaceChild(n.pre,t.text),t.text=n.pre,n.bgClass!=t.bgClass||n.textClass!=t.textClass?(t.bgClass=n.bgClass,t.textClass=n.textClass,Tt(e,t)):r&&(t.text.className=r)}function Tt(e,t){St(e,t),t.line.wrapClass?Ct(t).className=t.line.wrapClass:t.node!=t.text&&(t.node.className="");var r=t.textClass?t.textClass+" "+(t.line.textClass||""):t.line.textClass;t.text.className=r||""}function Mt(e,t,r,i){if(t.gutter&&(t.node.removeChild(t.gutter),t.gutter=null),t.gutterBackground&&(t.node.removeChild(t.gutterBackground),t.gutterBackground=null),t.line.gutterClass){var o=Ct(t);t.gutterBackground=n("div",null,"CodeMirror-gutter-background "+t.line.gutterClass,"left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px; width: "+i.gutterTotalWidth+"px"),e.display.input.setUneditable(t.gutterBackground),o.insertBefore(t.gutterBackground,t.text)}var l=t.line.gutterMarkers;if(e.options.lineNumbers||l){var s=Ct(t),a=t.gutter=n("div",null,"CodeMirror-gutter-wrapper","left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px");if(e.display.input.setUneditable(a),s.insertBefore(a,t.text),t.line.gutterClass&&(a.className+=" "+t.line.gutterClass),!e.options.lineNumbers||l&&l["CodeMirror-linenumbers"]||(t.lineNumber=a.appendChild(n("div",F(e.options,r),"CodeMirror-linenumber CodeMirror-gutter-elt","left: "+i.gutterLeft["CodeMirror-linenumbers"]+"px; width: "+e.display.lineNumInnerWidth+"px"))),l)for(var u=0;u<e.options.gutters.length;++u){var c=e.options.gutters[u],f=l.hasOwnProperty(c)&&l[c];f&&a.appendChild(n("div",[f],"CodeMirror-gutter-elt","left: "+i.gutterLeft[c]+"px; width: "+i.gutterWidth[c]+"px"))}}}function Nt(e,t,r){t.alignable&&(t.alignable=null);for(var n=t.node.firstChild,i=void 0;n;n=i)i=n.nextSibling,"CodeMirror-linewidget"==n.className&&t.node.removeChild(n);At(e,t,r)}function Ot(e,t,r,n){var i=Lt(e,t);return t.text=t.node=i.pre,i.bgClass&&(t.bgClass=i.bgClass),i.textClass&&(t.textClass=i.textClass),Tt(e,t),Mt(e,t,r,n),At(e,t,n),t.node}function At(e,t,r){if(Wt(e,t.line,t,r,!0),t.rest)for(var n=0;n<t.rest.length;n++)Wt(e,t.rest[n],t,r,!1)}function Wt(e,t,r,i,o){if(t.widgets)for(var l=Ct(r),s=0,a=t.widgets;s<a.length;++s){var u=a[s],c=n("div",[u.node],"CodeMirror-linewidget");u.handleMouseEvents||c.setAttribute("cm-ignore-events","true"),Dt(u,c,r,i),e.display.input.setUneditable(c),o&&u.above?l.insertBefore(c,r.gutter||r.text):l.appendChild(c),bt(u,"redraw")}}function Dt(e,t,r,n){if(e.noHScroll){(r.alignable||(r.alignable=[])).push(t);var i=n.wrapperWidth;t.style.left=n.fixedPos+"px",e.coverGutter||(i-=n.gutterTotalWidth,t.style.paddingLeft=n.gutterTotalWidth+"px"),t.style.width=i+"px"}e.coverGutter&&(t.style.zIndex=5,t.style.position="relative",e.noHScroll||(t.style.marginLeft=-n.gutterTotalWidth+"px"))}function Ht(e){if(null!=e.height)return e.height;var t=e.doc.cm;if(!t)return 0;if(!o(document.body,e.node)){var i="position: relative;";e.coverGutter&&(i+="margin-left: -"+t.display.gutters.offsetWidth+"px;"),e.noHScroll&&(i+="width: "+t.display.wrapper.clientWidth+"px;"),r(t.display.measure,n("div",[e.node],null,i))}return e.height=e.node.parentNode.offsetHeight}function Ft(e,t){for(var r=Ee(t);r!=e.wrapper;r=r.parentNode)if(!r||1==r.nodeType&&"true"==r.getAttribute("cm-ignore-events")||r.parentNode==e.sizer&&r!=e.mover)return!0}function Et(e){return e.lineSpace.offsetTop}function Pt(e){return e.mover.offsetHeight-e.lineSpace.offsetHeight}function It(e){if(e.cachedPaddingH)return e.cachedPaddingH;var t=r(e.measure,n("pre","x")),i=window.getComputedStyle?window.getComputedStyle(t):t.currentStyle,o={left:parseInt(i.paddingLeft),right:parseInt(i.paddingRight)};return isNaN(o.left)||isNaN(o.right)||(e.cachedPaddingH=o),o}function zt(e){return Rl-e.display.nativeBarWidth}function Rt(e){return e.display.scroller.clientWidth-zt(e)-e.display.barWidth}function Bt(e){return e.display.scroller.clientHeight-zt(e)-e.display.barHeight}function Gt(e,t,r){var n=e.options.lineWrapping,i=n&&Rt(e);if(!t.measure.heights||n&&t.measure.width!=i){var o=t.measure.heights=[];if(n){t.measure.width=i;for(var l=t.text.firstChild.getClientRects(),s=0;s<l.length-1;s++){var a=l[s],u=l[s+1];Math.abs(a.bottom-u.bottom)>2&&o.push((a.bottom+u.top)/2-r.top)}}o.push(r.bottom-r.top)}}function Ut(e,t,r){if(e.line==t)return{map:e.measure.map,cache:e.measure.cache};for(var n=0;n<e.rest.length;n++)if(e.rest[n]==t)return{map:e.measure.maps[n],cache:e.measure.caches[n]};for(var i=0;i<e.rest.length;i++)if(W(e.rest[i])>r)return{map:e.measure.maps[i],cache:e.measure.caches[i],before:!0}}function Vt(e,t){var n=W(t=fe(t)),i=e.display.externalMeasured=new pt(e.doc,t,n);i.lineN=n;var o=i.built=st(e,i);return i.text=o.pre,r(e.display.lineMeasure,o.pre),i}function Kt(e,t,r,n){return Yt(e,Xt(e,t),r,n)}function jt(e,t){if(t>=e.display.viewFrom&&t<e.display.viewTo)return e.display.view[Lr(e,t)];var r=e.display.externalMeasured;return r&&t>=r.lineN&&t<r.lineN+r.size?r:void 0}function Xt(e,t){var r=W(t),n=jt(e,r);n&&!n.text?n=null:n&&n.changes&&(xt(e,n,r,br(e)),e.curOp.forceUpdate=!0),n||(n=Vt(e,t));var i=Ut(n,t,r);return{line:t,view:n,rect:null,map:i.map,cache:i.cache,before:i.before,hasHeights:!1}}function Yt(e,t,r,n,i){t.before&&(r=-1);var o,l=r+(n||"");return t.cache.hasOwnProperty(l)?o=t.cache[l]:(t.rect||(t.rect=t.view.text.getBoundingClientRect()),t.hasHeights||(Gt(e,t.view,t.rect),t.hasHeights=!0),(o=qt(e,t,r,n)).bogus||(t.cache[l]=o)),{left:o.left,right:o.right,top:i?o.rtop:o.top,bottom:i?o.rbottom:o.bottom}}function _t(e,t,r){for(var n,i,o,l,s,a,u=0;u<e.length;u+=3)if(s=e[u],a=e[u+1],t<s?(i=0,o=1,l="left"):t<a?o=(i=t-s)+1:(u==e.length-3||t==a&&e[u+3]>t)&&(i=(o=a-s)-1,t>=a&&(l="right")),null!=i){if(n=e[u+2],s==a&&r==(n.insertLeft?"left":"right")&&(l=r),"left"==r&&0==i)for(;u&&e[u-2]==e[u-3]&&e[u-1].insertLeft;)n=e[2+(u-=3)],l="left";if("right"==r&&i==a-s)for(;u<e.length-3&&e[u+3]==e[u+4]&&!e[u+5].insertLeft;)n=e[(u+=3)+2],l="right";break}return{node:n,start:i,end:o,collapse:l,coverStart:s,coverEnd:a}}function $t(e,t){var r=ms;if("left"==t)for(var n=0;n<e.length&&(r=e[n]).left==r.right;n++);else for(var i=e.length-1;i>=0&&(r=e[i]).left==r.right;i--);return r}function qt(e,t,r,n){var i,o=_t(t.map,r,n),l=o.node,s=o.start,a=o.end,u=o.collapse;if(3==l.nodeType){for(var c=0;c<4;c++){for(;s&&S(t.line.text.charAt(o.coverStart+s));)--s;for(;o.coverStart+a<o.coverEnd&&S(t.line.text.charAt(o.coverStart+a));)++a;if((i=gl&&vl<9&&0==s&&a==o.coverEnd-o.coverStart?l.parentNode.getBoundingClientRect():$t(Wl(l,s,a).getClientRects(),n)).left||i.right||0==s)break;a=s,s-=1,u="right"}gl&&vl<11&&(i=Zt(e.display.measure,i))}else{s>0&&(u=n="right");var f;i=e.options.lineWrapping&&(f=l.getClientRects()).length>1?f["right"==n?f.length-1:0]:l.getBoundingClientRect()}if(gl&&vl<9&&!s&&(!i||!i.left&&!i.right)){var h=l.parentNode.getClientRects()[0];i=h?{left:h.left,right:h.left+yr(e.display),top:h.top,bottom:h.bottom}:ms}for(var d=i.top-t.rect.top,p=i.bottom-t.rect.top,g=(d+p)/2,v=t.view.measure.heights,m=0;m<v.length-1&&!(g<v[m]);m++);var y=m?v[m-1]:0,b=v[m],w={left:("right"==u?i.right:i.left)-t.rect.left,right:("left"==u?i.left:i.right)-t.rect.left,top:y,bottom:b};return i.left||i.right||(w.bogus=!0),e.options.singleCursorHeightPerLine||(w.rtop=d,w.rbottom=p),w}function Zt(e,t){if(!window.screen||null==screen.logicalXDPI||screen.logicalXDPI==screen.deviceXDPI||!Re(e))return t;var r=screen.logicalXDPI/screen.deviceXDPI,n=screen.logicalYDPI/screen.deviceYDPI;return{left:t.left*r,right:t.right*r,top:t.top*n,bottom:t.bottom*n}}function Qt(e){if(e.measure&&(e.measure.cache={},e.measure.heights=null,e.rest))for(var t=0;t<e.rest.length;t++)e.measure.caches[t]={}}function Jt(e){e.display.externalMeasure=null,t(e.display.lineMeasure);for(var r=0;r<e.display.view.length;r++)Qt(e.display.view[r])}function er(e){Jt(e),e.display.cachedCharWidth=e.display.cachedTextHeight=e.display.cachedPaddingH=null,e.options.lineWrapping||(e.display.maxLineChanged=!0),e.display.lineNumChars=null}function tr(){return bl&&kl?-(document.body.getBoundingClientRect().left-parseInt(getComputedStyle(document.body).marginLeft)):window.pageXOffset||(document.documentElement||document.body).scrollLeft}function rr(){return bl&&kl?-(document.body.getBoundingClientRect().top-parseInt(getComputedStyle(document.body).marginTop)):window.pageYOffset||(document.documentElement||document.body).scrollTop}function nr(e){var t=0;if(e.widgets)for(var r=0;r<e.widgets.length;++r)e.widgets[r].above&&(t+=Ht(e.widgets[r]));return t}function ir(e,t,r,n,i){if(!i){var o=nr(t);r.top+=o,r.bottom+=o}if("line"==n)return r;n||(n="local");var l=ye(t);if("local"==n?l+=Et(e.display):l-=e.display.viewOffset,"page"==n||"window"==n){var s=e.display.lineSpace.getBoundingClientRect();l+=s.top+("window"==n?0:rr());var a=s.left+("window"==n?0:tr());r.left+=a,r.right+=a}return r.top+=l,r.bottom+=l,r}function or(e,t,r){if("div"==r)return t;var n=t.left,i=t.top;if("page"==r)n-=tr(),i-=rr();else if("local"==r||!r){var o=e.display.sizer.getBoundingClientRect();n+=o.left,i+=o.top}var l=e.display.lineSpace.getBoundingClientRect();return{left:n-l.left,top:i-l.top}}function lr(e,t,r,n,i){return n||(n=M(e.doc,t.line)),ir(e,n,Kt(e,n,t.ch,i),r)}function sr(e,t,r,n,i,o){function l(t,l){var s=Yt(e,i,t,l?"right":"left",o);return l?s.left=s.right:s.right=s.left,ir(e,n,s,r)}function s(e,t,r){var n=1==a[t].level;return l(r?e-1:e,n!=r)}n=n||M(e.doc,t.line),i||(i=Xt(e,n));var a=Se(n,e.doc.direction),u=t.ch,c=t.sticky;if(u>=n.text.length?(u=n.text.length,c="before"):u<=0&&(u=0,c="after"),!a)return l("before"==c?u-1:u,"before"==c);var f=Ce(a,u,c),h=$l,d=s(u,f,"before"==c);return null!=h&&(d.other=s(u,h,"before"!=c)),d}function ar(e,t){var r=0;t=U(e.doc,t),e.options.lineWrapping||(r=yr(e.display)*t.ch);var n=M(e.doc,t.line),i=ye(n)+Et(e.display);return{left:r,right:r,top:i,bottom:i+n.height}}function ur(e,t,r,n,i){var o=E(e,t,r);return o.xRel=i,n&&(o.outside=!0),o}function cr(e,t,r){var n=e.doc;if((r+=e.display.viewOffset)<0)return ur(n.first,0,null,!0,-1);var i=D(n,r),o=n.first+n.size-1;if(i>o)return ur(n.first+n.size-1,M(n,o).text.length,null,!0,1);t<0&&(t=0);for(var l=M(n,i);;){var s=pr(e,l,i,t,r),a=ue(l),u=a&&a.find(0,!0);if(!a||!(s.ch>u.from.ch||s.ch==u.from.ch&&s.xRel>0))return s;i=W(l=u.to.line)}}function fr(e,t,r,n){n-=nr(t);var i=t.text.length,o=k(function(t){return Yt(e,r,t-1).bottom<=n},i,0);return i=k(function(t){return Yt(e,r,t).top>n},o,i),{begin:o,end:i}}function hr(e,t,r,n){return r||(r=Xt(e,t)),fr(e,t,r,ir(e,t,Yt(e,r,n),"line").top)}function dr(e,t,r,n){return!(e.bottom<=r)&&(e.top>r||(n?e.left:e.right)>t)}function pr(e,t,r,n,i){i-=ye(t);var o=Xt(e,t),l=nr(t),s=0,a=t.text.length,u=!0,c=Se(t,e.doc.direction);if(c){var f=(e.options.lineWrapping?vr:gr)(e,t,r,o,c,n,i);s=(u=1!=f.level)?f.from:f.to-1,a=u?f.to:f.from-1}var h,d,p=null,g=null,v=k(function(t){var r=Yt(e,o,t);return r.top+=l,r.bottom+=l,!!dr(r,n,i,!1)&&(r.top<=i&&r.left<=n&&(p=t,g=r),!0)},s,a),m=!1;if(g){var y=n-g.left<g.right-n,b=y==u;v=p+(b?0:1),d=b?"after":"before",h=y?g.left:g.right}else{u||v!=a&&v!=s||v++,d=0==v?"after":v==t.text.length?"before":Yt(e,o,v-(u?1:0)).bottom+l<=i==u?"after":"before";var w=sr(e,E(r,v,d),"line",t,o);h=w.left,m=i<w.top||i>=w.bottom}return v=L(t.text,v,1),ur(r,v,d,m,n-h)}function gr(e,t,r,n,i,o,l){var s=k(function(s){var a=i[s],u=1!=a.level;return dr(sr(e,E(r,u?a.to:a.from,u?"before":"after"),"line",t,n),o,l,!0)},0,i.length-1),a=i[s];if(s>0){var u=1!=a.level,c=sr(e,E(r,u?a.from:a.to,u?"after":"before"),"line",t,n);dr(c,o,l,!0)&&c.top>l&&(a=i[s-1])}return a}function vr(e,t,r,n,i,o,l){for(var s=fr(e,t,n,l),a=s.begin,u=s.end,c=null,f=null,h=0;h<i.length;h++){var d=i[h];if(!(d.from>=u||d.to<=a)){var p=Yt(e,n,1!=d.level?Math.min(u,d.to)-1:Math.max(a,d.from)).right,g=p<o?o-p+1e9:p-o;(!c||f>g)&&(c=d,f=g)}}return c||(c=i[i.length-1]),c.from<a&&(c={from:a,to:c.to,level:c.level}),c.to>u&&(c={from:c.from,to:u,level:c.level}),c}function mr(e){if(null!=e.cachedTextHeight)return e.cachedTextHeight;if(null==hs){hs=n("pre");for(var i=0;i<49;++i)hs.appendChild(document.createTextNode("x")),hs.appendChild(n("br"));hs.appendChild(document.createTextNode("x"))}r(e.measure,hs);var o=hs.offsetHeight/50;return o>3&&(e.cachedTextHeight=o),t(e.measure),o||1}function yr(e){if(null!=e.cachedCharWidth)return e.cachedCharWidth;var t=n("span","xxxxxxxxxx"),i=n("pre",[t]);r(e.measure,i);var o=t.getBoundingClientRect(),l=(o.right-o.left)/10;return l>2&&(e.cachedCharWidth=l),l||10}function br(e){for(var t=e.display,r={},n={},i=t.gutters.clientLeft,o=t.gutters.firstChild,l=0;o;o=o.nextSibling,++l)r[e.options.gutters[l]]=o.offsetLeft+o.clientLeft+i,n[e.options.gutters[l]]=o.clientWidth;return{fixedPos:wr(t),gutterTotalWidth:t.gutters.offsetWidth,gutterLeft:r,gutterWidth:n,wrapperWidth:t.wrapper.clientWidth}}function wr(e){return e.scroller.getBoundingClientRect().left-e.sizer.getBoundingClientRect().left}function xr(e){var t=mr(e.display),r=e.options.lineWrapping,n=r&&Math.max(5,e.display.scroller.clientWidth/yr(e.display)-3);return function(i){if(ve(e.doc,i))return 0;var o=0;if(i.widgets)for(var l=0;l<i.widgets.length;l++)i.widgets[l].height&&(o+=i.widgets[l].height);return r?o+(Math.ceil(i.text.length/n)||1)*t:o+t}}function Cr(e){var t=e.doc,r=xr(e);t.iter(function(e){var t=r(e);t!=e.height&&A(e,t)})}function Sr(e,t,r,n){var i=e.display;if(!r&&"true"==Ee(t).getAttribute("cm-not-content"))return null;var o,l,s=i.lineSpace.getBoundingClientRect();try{o=t.clientX-s.left,l=t.clientY-s.top}catch(t){return null}var a,u=cr(e,o,l);if(n&&1==u.xRel&&(a=M(e.doc,u.line).text).length==u.ch){var c=f(a,a.length,e.options.tabSize)-a.length;u=E(u.line,Math.max(0,Math.round((o-It(e.display).left)/yr(e.display))-c))}return u}function Lr(e,t){if(t>=e.display.viewTo)return null;if((t-=e.display.viewFrom)<0)return null;for(var r=e.display.view,n=0;n<r.length;n++)if((t-=r[n].size)<0)return n}function kr(e){e.display.input.showSelection(e.display.input.prepareSelection())}function Tr(e,t){void 0===t&&(t=!0);for(var r=e.doc,n={},i=n.cursors=document.createDocumentFragment(),o=n.selection=document.createDocumentFragment(),l=0;l<r.sel.ranges.length;l++)if(t||l!=r.sel.primIndex){var s=r.sel.ranges[l];if(!(s.from().line>=e.display.viewTo||s.to().line<e.display.viewFrom)){var a=s.empty();(a||e.options.showCursorWhenSelecting)&&Mr(e,s.head,i),a||Or(e,s,o)}}return n}function Mr(e,t,r){var i=sr(e,t,"div",null,null,!e.options.singleCursorHeightPerLine),o=r.appendChild(n("div"," ","CodeMirror-cursor"));if(o.style.left=i.left+"px",o.style.top=i.top+"px",o.style.height=Math.max(0,i.bottom-i.top)*e.options.cursorHeight+"px",i.other){var l=r.appendChild(n("div"," ","CodeMirror-cursor CodeMirror-secondarycursor"));l.style.display="",l.style.left=i.other.left+"px",l.style.top=i.other.top+"px",l.style.height=.85*(i.other.bottom-i.other.top)+"px"}}function Nr(e,t){return e.top-t.top||e.left-t.left}function Or(e,t,r){function i(e,t,r,i){t<0&&(t=0),t=Math.round(t),i=Math.round(i),a.appendChild(n("div",null,"CodeMirror-selected","position: absolute; left: "+e+"px;\n                             top: "+t+"px; width: "+(null==r?f-e:r)+"px;\n                             height: "+(i-t)+"px"))}function o(t,r,n){function o(r,n){return lr(e,E(t,r),"div",u,n)}var l,a,u=M(s,t),h=u.text.length,d=Se(u,s.direction);return xe(d,r||0,null==n?h:n,function(t,s,p,g){var v=o(t,"ltr"==p?"left":"right"),m=o(s-1,"ltr"==p?"right":"left");if("ltr"==p){var y=null==r&&0==t?c:v.left,b=null==n&&s==h?f:m.right;m.top-v.top<=3?i(y,m.top,b-y,m.bottom):(i(y,v.top,null,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top),i(c,m.top,m.right,m.bottom))}else if(t<s){var w=null==r&&0==t?f:v.right,x=null==n&&s==h?c:m.left;if(m.top-v.top<=3)i(x,m.top,w-x,m.bottom);else{var C=c;if(g){var S=hr(e,u,null,t).end;C=o(S-(/\s/.test(u.text.charAt(S-1))?2:1),"left").left}i(C,v.top,w-C,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top);var L=null;d.length,L=o(hr(e,u,null,s).begin,"right").right-x,i(x,m.top,L,m.bottom)}}(!l||Nr(v,l)<0)&&(l=v),Nr(m,l)<0&&(l=m),(!a||Nr(v,a)<0)&&(a=v),Nr(m,a)<0&&(a=m)}),{start:l,end:a}}var l=e.display,s=e.doc,a=document.createDocumentFragment(),u=It(e.display),c=u.left,f=Math.max(l.sizerWidth,Rt(e)-l.sizer.offsetLeft)-u.right,h=t.from(),d=t.to();if(h.line==d.line)o(h.line,h.ch,d.ch);else{var p=M(s,h.line),g=M(s,d.line),v=fe(p)==fe(g),m=o(h.line,h.ch,v?p.text.length+1:null).end,y=o(d.line,v?0:null,d.ch).start;v&&(m.top<y.top-2?(i(m.right,m.top,null,m.bottom),i(c,y.top,y.left,y.bottom)):i(m.right,m.top,y.left-m.right,m.bottom)),m.bottom<y.top&&i(c,m.bottom,null,y.top)}r.appendChild(a)}function Ar(e){if(e.state.focused){var t=e.display;clearInterval(t.blinker);var r=!0;t.cursorDiv.style.visibility="",e.options.cursorBlinkRate>0?t.blinker=setInterval(function(){return t.cursorDiv.style.visibility=(r=!r)?"":"hidden"},e.options.cursorBlinkRate):e.options.cursorBlinkRate<0&&(t.cursorDiv.style.visibility="hidden")}}function Wr(e){e.state.focused||(e.display.input.focus(),Hr(e))}function Dr(e){e.state.delayingBlurEvent=!0,setTimeout(function(){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1,Fr(e))},100)}function Hr(e,t){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1),"nocursor"!=e.options.readOnly&&(e.state.focused||(Te(e,"focus",e,t),e.state.focused=!0,s(e.display.wrapper,"CodeMirror-focused"),e.curOp||e.display.selForContextMenu==e.doc.sel||(e.display.input.reset(),ml&&setTimeout(function(){return e.display.input.reset(!0)},20)),e.display.input.receivedFocus()),Ar(e))}function Fr(e,t){e.state.delayingBlurEvent||(e.state.focused&&(Te(e,"blur",e,t),e.state.focused=!1,Fl(e.display.wrapper,"CodeMirror-focused")),clearInterval(e.display.blinker),setTimeout(function(){e.state.focused||(e.display.shift=!1)},150))}function Er(e){for(var t=e.display,r=t.lineDiv.offsetTop,n=0;n<t.view.length;n++){var i=t.view[n],o=void 0;if(!i.hidden){if(gl&&vl<8){var l=i.node.offsetTop+i.node.offsetHeight;o=l-r,r=l}else{var s=i.node.getBoundingClientRect();o=s.bottom-s.top}var a=i.line.height-o;if(o<2&&(o=mr(t)),(a>.005||a<-.005)&&(A(i.line,o),Pr(i.line),i.rest))for(var u=0;u<i.rest.length;u++)Pr(i.rest[u])}}}function Pr(e){if(e.widgets)for(var t=0;t<e.widgets.length;++t)e.widgets[t].height=e.widgets[t].node.parentNode.offsetHeight}function Ir(e,t,r){var n=r&&null!=r.top?Math.max(0,r.top):e.scroller.scrollTop;n=Math.floor(n-Et(e));var i=r&&null!=r.bottom?r.bottom:n+e.wrapper.clientHeight,o=D(t,n),l=D(t,i);if(r&&r.ensure){var s=r.ensure.from.line,a=r.ensure.to.line;s<o?(o=s,l=D(t,ye(M(t,s))+e.wrapper.clientHeight)):Math.min(a,t.lastLine())>=l&&(o=D(t,ye(M(t,a))-e.wrapper.clientHeight),l=a)}return{from:o,to:Math.max(l,o+1)}}function zr(e){var t=e.display,r=t.view;if(t.alignWidgets||t.gutters.firstChild&&e.options.fixedGutter){for(var n=wr(t)-t.scroller.scrollLeft+e.doc.scrollLeft,i=t.gutters.offsetWidth,o=n+"px",l=0;l<r.length;l++)if(!r[l].hidden){e.options.fixedGutter&&(r[l].gutter&&(r[l].gutter.style.left=o),r[l].gutterBackground&&(r[l].gutterBackground.style.left=o));var s=r[l].alignable;if(s)for(var a=0;a<s.length;a++)s[a].style.left=o}e.options.fixedGutter&&(t.gutters.style.left=n+i+"px")}}function Rr(e){if(!e.options.lineNumbers)return!1;var t=e.doc,r=F(e.options,t.first+t.size-1),i=e.display;if(r.length!=i.lineNumChars){var o=i.measure.appendChild(n("div",[n("div",r)],"CodeMirror-linenumber CodeMirror-gutter-elt")),l=o.firstChild.offsetWidth,s=o.offsetWidth-l;return i.lineGutter.style.width="",i.lineNumInnerWidth=Math.max(l,i.lineGutter.offsetWidth-s)+1,i.lineNumWidth=i.lineNumInnerWidth+s,i.lineNumChars=i.lineNumInnerWidth?r.length:-1,i.lineGutter.style.width=i.lineNumWidth+"px",Wn(e),!0}return!1}function Br(e,t){if(!Me(e,"scrollCursorIntoView")){var r=e.display,i=r.sizer.getBoundingClientRect(),o=null;if(t.top+i.top<0?o=!0:t.bottom+i.top>(window.innerHeight||document.documentElement.clientHeight)&&(o=!1),null!=o&&!Sl){var l=n("div","​",null,"position: absolute;\n                         top: "+(t.top-r.viewOffset-Et(e.display))+"px;\n                         height: "+(t.bottom-t.top+zt(e)+r.barHeight)+"px;\n                         left: "+t.left+"px; width: "+Math.max(2,t.right-t.left)+"px;");e.display.lineSpace.appendChild(l),l.scrollIntoView(o),e.display.lineSpace.removeChild(l)}}}function Gr(e,t,r,n){null==n&&(n=0);var i;e.options.lineWrapping||t!=r||(r="before"==(t=t.ch?E(t.line,"before"==t.sticky?t.ch-1:t.ch,"after"):t).sticky?E(t.line,t.ch+1,"before"):t);for(var o=0;o<5;o++){var l=!1,s=sr(e,t),a=r&&r!=t?sr(e,r):s,u=Vr(e,i={left:Math.min(s.left,a.left),top:Math.min(s.top,a.top)-n,right:Math.max(s.left,a.left),bottom:Math.max(s.bottom,a.bottom)+n}),c=e.doc.scrollTop,f=e.doc.scrollLeft;if(null!=u.scrollTop&&(qr(e,u.scrollTop),Math.abs(e.doc.scrollTop-c)>1&&(l=!0)),null!=u.scrollLeft&&(Qr(e,u.scrollLeft),Math.abs(e.doc.scrollLeft-f)>1&&(l=!0)),!l)break}return i}function Ur(e,t){var r=Vr(e,t);null!=r.scrollTop&&qr(e,r.scrollTop),null!=r.scrollLeft&&Qr(e,r.scrollLeft)}function Vr(e,t){var r=e.display,n=mr(e.display);t.top<0&&(t.top=0);var i=e.curOp&&null!=e.curOp.scrollTop?e.curOp.scrollTop:r.scroller.scrollTop,o=Bt(e),l={};t.bottom-t.top>o&&(t.bottom=t.top+o);var s=e.doc.height+Pt(r),a=t.top<n,u=t.bottom>s-n;if(t.top<i)l.scrollTop=a?0:t.top;else if(t.bottom>i+o){var c=Math.min(t.top,(u?s:t.bottom)-o);c!=i&&(l.scrollTop=c)}var f=e.curOp&&null!=e.curOp.scrollLeft?e.curOp.scrollLeft:r.scroller.scrollLeft,h=Rt(e)-(e.options.fixedGutter?r.gutters.offsetWidth:0),d=t.right-t.left>h;return d&&(t.right=t.left+h),t.left<10?l.scrollLeft=0:t.left<f?l.scrollLeft=Math.max(0,t.left-(d?0:10)):t.right>h+f-3&&(l.scrollLeft=t.right+(d?0:10)-h),l}function Kr(e,t){null!=t&&(_r(e),e.curOp.scrollTop=(null==e.curOp.scrollTop?e.doc.scrollTop:e.curOp.scrollTop)+t)}function jr(e){_r(e);var t=e.getCursor();e.curOp.scrollToPos={from:t,to:t,margin:e.options.cursorScrollMargin}}function Xr(e,t,r){null==t&&null==r||_r(e),null!=t&&(e.curOp.scrollLeft=t),null!=r&&(e.curOp.scrollTop=r)}function Yr(e,t){_r(e),e.curOp.scrollToPos=t}function _r(e){var t=e.curOp.scrollToPos;t&&(e.curOp.scrollToPos=null,$r(e,ar(e,t.from),ar(e,t.to),t.margin))}function $r(e,t,r,n){var i=Vr(e,{left:Math.min(t.left,r.left),top:Math.min(t.top,r.top)-n,right:Math.max(t.right,r.right),bottom:Math.max(t.bottom,r.bottom)+n});Xr(e,i.scrollLeft,i.scrollTop)}function qr(e,t){Math.abs(e.doc.scrollTop-t)<2||(fl||On(e,{top:t}),Zr(e,t,!0),fl&&On(e),Cn(e,100))}function Zr(e,t,r){t=Math.min(e.display.scroller.scrollHeight-e.display.scroller.clientHeight,t),(e.display.scroller.scrollTop!=t||r)&&(e.doc.scrollTop=t,e.display.scrollbars.setScrollTop(t),e.display.scroller.scrollTop!=t&&(e.display.scroller.scrollTop=t))}function Qr(e,t,r,n){t=Math.min(t,e.display.scroller.scrollWidth-e.display.scroller.clientWidth),(r?t==e.doc.scrollLeft:Math.abs(e.doc.scrollLeft-t)<2)&&!n||(e.doc.scrollLeft=t,zr(e),e.display.scroller.scrollLeft!=t&&(e.display.scroller.scrollLeft=t),e.display.scrollbars.setScrollLeft(t))}function Jr(e){var t=e.display,r=t.gutters.offsetWidth,n=Math.round(e.doc.height+Pt(e.display));return{clientHeight:t.scroller.clientHeight,viewHeight:t.wrapper.clientHeight,scrollWidth:t.scroller.scrollWidth,clientWidth:t.scroller.clientWidth,viewWidth:t.wrapper.clientWidth,barLeft:e.options.fixedGutter?r:0,docHeight:n,scrollHeight:n+zt(e)+t.barHeight,nativeBarWidth:t.nativeBarWidth,gutterWidth:r}}function en(e,t){t||(t=Jr(e));var r=e.display.barWidth,n=e.display.barHeight;tn(e,t);for(var i=0;i<4&&r!=e.display.barWidth||n!=e.display.barHeight;i++)r!=e.display.barWidth&&e.options.lineWrapping&&Er(e),tn(e,Jr(e)),r=e.display.barWidth,n=e.display.barHeight}function tn(e,t){var r=e.display,n=r.scrollbars.update(t);r.sizer.style.paddingRight=(r.barWidth=n.right)+"px",r.sizer.style.paddingBottom=(r.barHeight=n.bottom)+"px",r.heightForcer.style.borderBottom=n.bottom+"px solid transparent",n.right&&n.bottom?(r.scrollbarFiller.style.display="block",r.scrollbarFiller.style.height=n.bottom+"px",r.scrollbarFiller.style.width=n.right+"px"):r.scrollbarFiller.style.display="",n.bottom&&e.options.coverGutterNextToScrollbar&&e.options.fixedGutter?(r.gutterFiller.style.display="block",r.gutterFiller.style.height=n.bottom+"px",r.gutterFiller.style.width=t.gutterWidth+"px"):r.gutterFiller.style.display=""}function rn(e){e.display.scrollbars&&(e.display.scrollbars.clear(),e.display.scrollbars.addClass&&Fl(e.display.wrapper,e.display.scrollbars.addClass)),e.display.scrollbars=new ws[e.options.scrollbarStyle](function(t){e.display.wrapper.insertBefore(t,e.display.scrollbarFiller),Ql(t,"mousedown",function(){e.state.focused&&setTimeout(function(){return e.display.input.focus()},0)}),t.setAttribute("cm-not-content","true")},function(t,r){"horizontal"==r?Qr(e,t):qr(e,t)},e),e.display.scrollbars.addClass&&s(e.display.wrapper,e.display.scrollbars.addClass)}function nn(e){e.curOp={cm:e,viewChanged:!1,startHeight:e.doc.height,forceUpdate:!1,updateInput:null,typing:!1,changeObjs:null,cursorActivityHandlers:null,cursorActivityCalled:0,selectionChanged:!1,updateMaxLine:!1,scrollLeft:null,scrollTop:null,scrollToPos:null,focus:!1,id:++xs},vt(e.curOp)}function on(e){yt(e.curOp,function(e){for(var t=0;t<e.ops.length;t++)e.ops[t].cm.curOp=null;ln(e)})}function ln(e){for(var t=e.ops,r=0;r<t.length;r++)sn(t[r]);for(var n=0;n<t.length;n++)an(t[n]);for(var i=0;i<t.length;i++)un(t[i]);for(var o=0;o<t.length;o++)cn(t[o]);for(var l=0;l<t.length;l++)fn(t[l])}function sn(e){var t=e.cm,r=t.display;Ln(t),e.updateMaxLine&&we(t),e.mustUpdate=e.viewChanged||e.forceUpdate||null!=e.scrollTop||e.scrollToPos&&(e.scrollToPos.from.line<r.viewFrom||e.scrollToPos.to.line>=r.viewTo)||r.maxLineChanged&&t.options.lineWrapping,e.update=e.mustUpdate&&new Cs(t,e.mustUpdate&&{top:e.scrollTop,ensure:e.scrollToPos},e.forceUpdate)}function an(e){e.updatedDisplay=e.mustUpdate&&Mn(e.cm,e.update)}function un(e){var t=e.cm,r=t.display;e.updatedDisplay&&Er(t),e.barMeasure=Jr(t),r.maxLineChanged&&!t.options.lineWrapping&&(e.adjustWidthTo=Kt(t,r.maxLine,r.maxLine.text.length).left+3,t.display.sizerWidth=e.adjustWidthTo,e.barMeasure.scrollWidth=Math.max(r.scroller.clientWidth,r.sizer.offsetLeft+e.adjustWidthTo+zt(t)+t.display.barWidth),e.maxScrollLeft=Math.max(0,r.sizer.offsetLeft+e.adjustWidthTo-Rt(t))),(e.updatedDisplay||e.selectionChanged)&&(e.preparedSelection=r.input.prepareSelection())}function cn(e){var t=e.cm;null!=e.adjustWidthTo&&(t.display.sizer.style.minWidth=e.adjustWidthTo+"px",e.maxScrollLeft<t.doc.scrollLeft&&Qr(t,Math.min(t.display.scroller.scrollLeft,e.maxScrollLeft),!0),t.display.maxLineChanged=!1);var r=e.focus&&e.focus==l();e.preparedSelection&&t.display.input.showSelection(e.preparedSelection,r),(e.updatedDisplay||e.startHeight!=t.doc.height)&&en(t,e.barMeasure),e.updatedDisplay&&Dn(t,e.barMeasure),e.selectionChanged&&Ar(t),t.state.focused&&e.updateInput&&t.display.input.reset(e.typing),r&&Wr(e.cm)}function fn(e){var t=e.cm,r=t.display,n=t.doc;e.updatedDisplay&&Nn(t,e.update),null==r.wheelStartX||null==e.scrollTop&&null==e.scrollLeft&&!e.scrollToPos||(r.wheelStartX=r.wheelStartY=null),null!=e.scrollTop&&Zr(t,e.scrollTop,e.forceScroll),null!=e.scrollLeft&&Qr(t,e.scrollLeft,!0,!0),e.scrollToPos&&Br(t,Gr(t,U(n,e.scrollToPos.from),U(n,e.scrollToPos.to),e.scrollToPos.margin));var i=e.maybeHiddenMarkers,o=e.maybeUnhiddenMarkers;if(i)for(var l=0;l<i.length;++l)i[l].lines.length||Te(i[l],"hide");if(o)for(var s=0;s<o.length;++s)o[s].lines.length&&Te(o[s],"unhide");r.wrapper.offsetHeight&&(n.scrollTop=t.display.scroller.scrollTop),e.changeObjs&&Te(t,"changes",t,e.changeObjs),e.update&&e.update.finish()}function hn(e,t){if(e.curOp)return t();nn(e);try{return t()}finally{on(e)}}function dn(e,t){return function(){if(e.curOp)return t.apply(e,arguments);nn(e);try{return t.apply(e,arguments)}finally{on(e)}}}function pn(e){return function(){if(this.curOp)return e.apply(this,arguments);nn(this);try{return e.apply(this,arguments)}finally{on(this)}}}function gn(e){return function(){var t=this.cm;if(!t||t.curOp)return e.apply(this,arguments);nn(t);try{return e.apply(this,arguments)}finally{on(t)}}}function vn(e,t,r,n){null==t&&(t=e.doc.first),null==r&&(r=e.doc.first+e.doc.size),n||(n=0);var i=e.display;if(n&&r<i.viewTo&&(null==i.updateLineNumbers||i.updateLineNumbers>t)&&(i.updateLineNumbers=t),e.curOp.viewChanged=!0,t>=i.viewTo)_l&&pe(e.doc,t)<i.viewTo&&yn(e);else if(r<=i.viewFrom)_l&&ge(e.doc,r+n)>i.viewFrom?yn(e):(i.viewFrom+=n,i.viewTo+=n);else if(t<=i.viewFrom&&r>=i.viewTo)yn(e);else if(t<=i.viewFrom){var o=bn(e,r,r+n,1);o?(i.view=i.view.slice(o.index),i.viewFrom=o.lineN,i.viewTo+=n):yn(e)}else if(r>=i.viewTo){var l=bn(e,t,t,-1);l?(i.view=i.view.slice(0,l.index),i.viewTo=l.lineN):yn(e)}else{var s=bn(e,t,t,-1),a=bn(e,r,r+n,1);s&&a?(i.view=i.view.slice(0,s.index).concat(gt(e,s.lineN,a.lineN)).concat(i.view.slice(a.index)),i.viewTo+=n):yn(e)}var u=i.externalMeasured;u&&(r<u.lineN?u.lineN+=n:t<u.lineN+u.size&&(i.externalMeasured=null))}function mn(e,t,r){e.curOp.viewChanged=!0;var n=e.display,i=e.display.externalMeasured;if(i&&t>=i.lineN&&t<i.lineN+i.size&&(n.externalMeasured=null),!(t<n.viewFrom||t>=n.viewTo)){var o=n.view[Lr(e,t)];if(null!=o.node){var l=o.changes||(o.changes=[]);-1==h(l,r)&&l.push(r)}}}function yn(e){e.display.viewFrom=e.display.viewTo=e.doc.first,e.display.view=[],e.display.viewOffset=0}function bn(e,t,r,n){var i,o=Lr(e,t),l=e.display.view;if(!_l||r==e.doc.first+e.doc.size)return{index:o,lineN:r};for(var s=e.display.viewFrom,a=0;a<o;a++)s+=l[a].size;if(s!=t){if(n>0){if(o==l.length-1)return null;i=s+l[o].size-t,o++}else i=s-t;t+=i,r+=i}for(;pe(e.doc,r)!=r;){if(o==(n<0?0:l.length-1))return null;r+=n*l[o-(n<0?1:0)].size,o+=n}return{index:o,lineN:r}}function wn(e,t,r){var n=e.display;0==n.view.length||t>=n.viewTo||r<=n.viewFrom?(n.view=gt(e,t,r),n.viewFrom=t):(n.viewFrom>t?n.view=gt(e,t,n.viewFrom).concat(n.view):n.viewFrom<t&&(n.view=n.view.slice(Lr(e,t))),n.viewFrom=t,n.viewTo<r?n.view=n.view.concat(gt(e,n.viewTo,r)):n.viewTo>r&&(n.view=n.view.slice(0,Lr(e,r)))),n.viewTo=r}function xn(e){for(var t=e.display.view,r=0,n=0;n<t.length;n++){var i=t[n];i.hidden||i.node&&!i.changes||++r}return r}function Cn(e,t){e.doc.highlightFrontier<e.display.viewTo&&e.state.highlight.set(t,u(Sn,e))}function Sn(e){var t=e.doc;if(!(t.highlightFrontier>=e.display.viewTo)){var r=+new Date+e.options.workTime,n=$e(e,t.highlightFrontier),i=[];t.iter(n.line,Math.min(t.first+t.size,e.display.viewTo+500),function(o){if(n.line>=e.display.viewFrom){var l=o.styles,s=o.text.length>e.options.maxHighlightLength?Ke(t.mode,n.state):null,a=Ye(e,o,n,!0);s&&(n.state=s),o.styles=a.styles;var u=o.styleClasses,c=a.classes;c?o.styleClasses=c:u&&(o.styleClasses=null);for(var f=!l||l.length!=o.styles.length||u!=c&&(!u||!c||u.bgClass!=c.bgClass||u.textClass!=c.textClass),h=0;!f&&h<l.length;++h)f=l[h]!=o.styles[h];f&&i.push(n.line),o.stateAfter=n.save(),n.nextLine()}else o.text.length<=e.options.maxHighlightLength&&qe(e,o.text,n),o.stateAfter=n.line%5==0?n.save():null,n.nextLine();if(+new Date>r)return Cn(e,e.options.workDelay),!0}),t.highlightFrontier=n.line,t.modeFrontier=Math.max(t.modeFrontier,n.line),i.length&&hn(e,function(){for(var t=0;t<i.length;t++)mn(e,i[t],"text")})}}function Ln(e){var t=e.display;!t.scrollbarsClipped&&t.scroller.offsetWidth&&(t.nativeBarWidth=t.scroller.offsetWidth-t.scroller.clientWidth,t.heightForcer.style.height=zt(e)+"px",t.sizer.style.marginBottom=-t.nativeBarWidth+"px",t.sizer.style.borderRightWidth=zt(e)+"px",t.scrollbarsClipped=!0)}function kn(e){if(e.hasFocus())return null;var t=l();if(!t||!o(e.display.lineDiv,t))return null;var r={activeElt:t};if(window.getSelection){var n=window.getSelection();n.anchorNode&&n.extend&&o(e.display.lineDiv,n.anchorNode)&&(r.anchorNode=n.anchorNode,r.anchorOffset=n.anchorOffset,r.focusNode=n.focusNode,r.focusOffset=n.focusOffset)}return r}function Tn(e){if(e&&e.activeElt&&e.activeElt!=l()&&(e.activeElt.focus(),e.anchorNode&&o(document.body,e.anchorNode)&&o(document.body,e.focusNode))){var t=window.getSelection(),r=document.createRange();r.setEnd(e.anchorNode,e.anchorOffset),r.collapse(!1),t.removeAllRanges(),t.addRange(r),t.extend(e.focusNode,e.focusOffset)}}function Mn(e,r){var n=e.display,i=e.doc;if(r.editorIsHidden)return yn(e),!1;if(!r.force&&r.visible.from>=n.viewFrom&&r.visible.to<=n.viewTo&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo)&&n.renderedView==n.view&&0==xn(e))return!1;Rr(e)&&(yn(e),r.dims=br(e));var o=i.first+i.size,l=Math.max(r.visible.from-e.options.viewportMargin,i.first),s=Math.min(o,r.visible.to+e.options.viewportMargin);n.viewFrom<l&&l-n.viewFrom<20&&(l=Math.max(i.first,n.viewFrom)),n.viewTo>s&&n.viewTo-s<20&&(s=Math.min(o,n.viewTo)),_l&&(l=pe(e.doc,l),s=ge(e.doc,s));var a=l!=n.viewFrom||s!=n.viewTo||n.lastWrapHeight!=r.wrapperHeight||n.lastWrapWidth!=r.wrapperWidth;wn(e,l,s),n.viewOffset=ye(M(e.doc,n.viewFrom)),e.display.mover.style.top=n.viewOffset+"px";var u=xn(e);if(!a&&0==u&&!r.force&&n.renderedView==n.view&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo))return!1;var c=kn(e);return u>4&&(n.lineDiv.style.display="none"),An(e,n.updateLineNumbers,r.dims),u>4&&(n.lineDiv.style.display=""),n.renderedView=n.view,Tn(c),t(n.cursorDiv),t(n.selectionDiv),n.gutters.style.height=n.sizer.style.minHeight=0,a&&(n.lastWrapHeight=r.wrapperHeight,n.lastWrapWidth=r.wrapperWidth,Cn(e,400)),n.updateLineNumbers=null,!0}function Nn(e,t){for(var r=t.viewport,n=!0;(n&&e.options.lineWrapping&&t.oldDisplayWidth!=Rt(e)||(r&&null!=r.top&&(r={top:Math.min(e.doc.height+Pt(e.display)-Bt(e),r.top)}),t.visible=Ir(e.display,e.doc,r),!(t.visible.from>=e.display.viewFrom&&t.visible.to<=e.display.viewTo)))&&Mn(e,t);n=!1){Er(e);var i=Jr(e);kr(e),en(e,i),Dn(e,i),t.force=!1}t.signal(e,"update",e),e.display.viewFrom==e.display.reportedViewFrom&&e.display.viewTo==e.display.reportedViewTo||(t.signal(e,"viewportChange",e,e.display.viewFrom,e.display.viewTo),e.display.reportedViewFrom=e.display.viewFrom,e.display.reportedViewTo=e.display.viewTo)}function On(e,t){var r=new Cs(e,t);if(Mn(e,r)){Er(e),Nn(e,r);var n=Jr(e);kr(e),en(e,n),Dn(e,n),r.finish()}}function An(e,r,n){function i(t){var r=t.nextSibling;return ml&&Ml&&e.display.currentWheelTarget==t?t.style.display="none":t.parentNode.removeChild(t),r}for(var o=e.display,l=e.options.lineNumbers,s=o.lineDiv,a=s.firstChild,u=o.view,c=o.viewFrom,f=0;f<u.length;f++){var d=u[f];if(d.hidden);else if(d.node&&d.node.parentNode==s){for(;a!=d.node;)a=i(a);var p=l&&null!=r&&r<=c&&d.lineNumber;d.changes&&(h(d.changes,"gutter")>-1&&(p=!1),xt(e,d,c,n)),p&&(t(d.lineNumber),d.lineNumber.appendChild(document.createTextNode(F(e.options,c)))),a=d.node.nextSibling}else{var g=Ot(e,d,c,n);s.insertBefore(g,a)}c+=d.size}for(;a;)a=i(a)}function Wn(e){var t=e.display.gutters.offsetWidth;e.display.sizer.style.marginLeft=t+"px"}function Dn(e,t){e.display.sizer.style.minHeight=t.docHeight+"px",e.display.heightForcer.style.top=t.docHeight+"px",e.display.gutters.style.height=t.docHeight+e.display.barHeight+zt(e)+"px"}function Hn(e){var r=e.display.gutters,i=e.options.gutters;t(r);for(var o=0;o<i.length;++o){var l=i[o],s=r.appendChild(n("div",null,"CodeMirror-gutter "+l));"CodeMirror-linenumbers"==l&&(e.display.lineGutter=s,s.style.width=(e.display.lineNumWidth||1)+"px")}r.style.display=o?"":"none",Wn(e)}function Fn(e){var t=h(e.gutters,"CodeMirror-linenumbers");-1==t&&e.lineNumbers?e.gutters=e.gutters.concat(["CodeMirror-linenumbers"]):t>-1&&!e.lineNumbers&&(e.gutters=e.gutters.slice(0),e.gutters.splice(t,1))}function En(e){var t=e.wheelDeltaX,r=e.wheelDeltaY;return null==t&&e.detail&&e.axis==e.HORIZONTAL_AXIS&&(t=e.detail),null==r&&e.detail&&e.axis==e.VERTICAL_AXIS?r=e.detail:null==r&&(r=e.wheelDelta),{x:t,y:r}}function Pn(e){var t=En(e);return t.x*=Ls,t.y*=Ls,t}function In(e,t){var r=En(t),n=r.x,i=r.y,o=e.display,l=o.scroller,s=l.scrollWidth>l.clientWidth,a=l.scrollHeight>l.clientHeight;if(n&&s||i&&a){if(i&&Ml&&ml)e:for(var u=t.target,c=o.view;u!=l;u=u.parentNode)for(var f=0;f<c.length;f++)if(c[f].node==u){e.display.currentWheelTarget=u;break e}if(n&&!fl&&!wl&&null!=Ls)return i&&a&&qr(e,Math.max(0,l.scrollTop+i*Ls)),Qr(e,Math.max(0,l.scrollLeft+n*Ls)),(!i||i&&a)&&We(t),void(o.wheelStartX=null);if(i&&null!=Ls){var h=i*Ls,d=e.doc.scrollTop,p=d+o.wrapper.clientHeight;h<0?d=Math.max(0,d+h-50):p=Math.min(e.doc.height,p+h+50),On(e,{top:d,bottom:p})}Ss<20&&(null==o.wheelStartX?(o.wheelStartX=l.scrollLeft,o.wheelStartY=l.scrollTop,o.wheelDX=n,o.wheelDY=i,setTimeout(function(){if(null!=o.wheelStartX){var e=l.scrollLeft-o.wheelStartX,t=l.scrollTop-o.wheelStartY,r=t&&o.wheelDY&&t/o.wheelDY||e&&o.wheelDX&&e/o.wheelDX;o.wheelStartX=o.wheelStartY=null,r&&(Ls=(Ls*Ss+r)/(Ss+1),++Ss)}},200)):(o.wheelDX+=n,o.wheelDY+=i))}}function zn(e,t){var r=e[t];e.sort(function(e,t){return P(e.from(),t.from())}),t=h(e,r);for(var n=1;n<e.length;n++){var i=e[n],o=e[n-1];if(P(o.to(),i.from())>=0){var l=B(o.from(),i.from()),s=R(o.to(),i.to()),a=o.empty()?i.from()==i.head:o.from()==o.head;n<=t&&--t,e.splice(--n,2,new Ts(a?s:l,a?l:s))}}return new ks(e,t)}function Rn(e,t){return new ks([new Ts(e,t||e)],0)}function Bn(e){return e.text?E(e.from.line+e.text.length-1,g(e.text).length+(1==e.text.length?e.from.ch:0)):e.to}function Gn(e,t){if(P(e,t.from)<0)return e;if(P(e,t.to)<=0)return Bn(t);var r=e.line+t.text.length-(t.to.line-t.from.line)-1,n=e.ch;return e.line==t.to.line&&(n+=Bn(t).ch-t.to.ch),E(r,n)}function Un(e,t){for(var r=[],n=0;n<e.sel.ranges.length;n++){var i=e.sel.ranges[n];r.push(new Ts(Gn(i.anchor,t),Gn(i.head,t)))}return zn(r,e.sel.primIndex)}function Vn(e,t,r){return e.line==t.line?E(r.line,e.ch-t.ch+r.ch):E(r.line+(e.line-t.line),e.ch)}function Kn(e,t,r){for(var n=[],i=E(e.first,0),o=i,l=0;l<t.length;l++){var s=t[l],a=Vn(s.from,i,o),u=Vn(Bn(s),i,o);if(i=s.to,o=u,"around"==r){var c=e.sel.ranges[l],f=P(c.head,c.anchor)<0;n[l]=new Ts(f?u:a,f?a:u)}else n[l]=new Ts(a,a)}return new ks(n,e.sel.primIndex)}function jn(e){e.doc.mode=Ue(e.options,e.doc.modeOption),Xn(e)}function Xn(e){e.doc.iter(function(e){e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null)}),e.doc.modeFrontier=e.doc.highlightFrontier=e.doc.first,Cn(e,100),e.state.modeGen++,e.curOp&&vn(e)}function Yn(e,t){return 0==t.from.ch&&0==t.to.ch&&""==g(t.text)&&(!e.cm||e.cm.options.wholeLineUpdateBefore)}function _n(e,t,r,n){function i(e){return r?r[e]:null}function o(e,r,i){it(e,r,i,n),bt(e,"change",e,t)}function l(e,t){for(var r=[],o=e;o<t;++o)r.push(new fs(u[o],i(o),n));return r}var s=t.from,a=t.to,u=t.text,c=M(e,s.line),f=M(e,a.line),h=g(u),d=i(u.length-1),p=a.line-s.line;if(t.full)e.insert(0,l(0,u.length)),e.remove(u.length,e.size-u.length);else if(Yn(e,t)){var v=l(0,u.length-1);o(f,f.text,d),p&&e.remove(s.line,p),v.length&&e.insert(s.line,v)}else if(c==f)if(1==u.length)o(c,c.text.slice(0,s.ch)+h+c.text.slice(a.ch),d);else{var m=l(1,u.length-1);m.push(new fs(h+c.text.slice(a.ch),d,n)),o(c,c.text.slice(0,s.ch)+u[0],i(0)),e.insert(s.line+1,m)}else if(1==u.length)o(c,c.text.slice(0,s.ch)+u[0]+f.text.slice(a.ch),i(0)),e.remove(s.line+1,p);else{o(c,c.text.slice(0,s.ch)+u[0],i(0)),o(f,h+f.text.slice(a.ch),d);var y=l(1,u.length-1);p>1&&e.remove(s.line+1,p-1),e.insert(s.line+1,y)}bt(e,"change",e,t)}function $n(e,t,r){function n(e,i,o){if(e.linked)for(var l=0;l<e.linked.length;++l){var s=e.linked[l];if(s.doc!=i){var a=o&&s.sharedHist;r&&!a||(t(s.doc,a),n(s.doc,e,a))}}}n(e,null,!0)}function qn(e,t){if(t.cm)throw new Error("This document is already in use.");e.doc=t,t.cm=e,Cr(e),jn(e),Zn(e),e.options.lineWrapping||we(e),e.options.mode=t.modeOption,vn(e)}function Zn(e){("rtl"==e.doc.direction?s:Fl)(e.display.lineDiv,"CodeMirror-rtl")}function Qn(e){hn(e,function(){Zn(e),vn(e)})}function Jn(e){this.done=[],this.undone=[],this.undoDepth=1/0,this.lastModTime=this.lastSelTime=0,this.lastOp=this.lastSelOp=null,this.lastOrigin=this.lastSelOrigin=null,this.generation=this.maxGeneration=e||1}function ei(e,t){var r={from:z(t.from),to:Bn(t),text:N(e,t.from,t.to)};return si(e,r,t.from.line,t.to.line+1),$n(e,function(e){return si(e,r,t.from.line,t.to.line+1)},!0),r}function ti(e){for(;e.length&&g(e).ranges;)e.pop()}function ri(e,t){return t?(ti(e.done),g(e.done)):e.done.length&&!g(e.done).ranges?g(e.done):e.done.length>1&&!e.done[e.done.length-2].ranges?(e.done.pop(),g(e.done)):void 0}function ni(e,t,r,n){var i=e.history;i.undone.length=0;var o,l,s=+new Date;if((i.lastOp==n||i.lastOrigin==t.origin&&t.origin&&("+"==t.origin.charAt(0)&&e.cm&&i.lastModTime>s-e.cm.options.historyEventDelay||"*"==t.origin.charAt(0)))&&(o=ri(i,i.lastOp==n)))l=g(o.changes),0==P(t.from,t.to)&&0==P(t.from,l.to)?l.to=Bn(t):o.changes.push(ei(e,t));else{var a=g(i.done);for(a&&a.ranges||li(e.sel,i.done),o={changes:[ei(e,t)],generation:i.generation},i.done.push(o);i.done.length>i.undoDepth;)i.done.shift(),i.done[0].ranges||i.done.shift()}i.done.push(r),i.generation=++i.maxGeneration,i.lastModTime=i.lastSelTime=s,i.lastOp=i.lastSelOp=n,i.lastOrigin=i.lastSelOrigin=t.origin,l||Te(e,"historyAdded")}function ii(e,t,r,n){var i=t.charAt(0);return"*"==i||"+"==i&&r.ranges.length==n.ranges.length&&r.somethingSelected()==n.somethingSelected()&&new Date-e.history.lastSelTime<=(e.cm?e.cm.options.historyEventDelay:500)}function oi(e,t,r,n){var i=e.history,o=n&&n.origin;r==i.lastSelOp||o&&i.lastSelOrigin==o&&(i.lastModTime==i.lastSelTime&&i.lastOrigin==o||ii(e,o,g(i.done),t))?i.done[i.done.length-1]=t:li(t,i.done),i.lastSelTime=+new Date,i.lastSelOrigin=o,i.lastSelOp=r,n&&!1!==n.clearRedo&&ti(i.undone)}function li(e,t){var r=g(t);r&&r.ranges&&r.equals(e)||t.push(e)}function si(e,t,r,n){var i=t["spans_"+e.id],o=0;e.iter(Math.max(e.first,r),Math.min(e.first+e.size,n),function(r){r.markedSpans&&((i||(i=t["spans_"+e.id]={}))[o]=r.markedSpans),++o})}function ai(e){if(!e)return null;for(var t,r=0;r<e.length;++r)e[r].marker.explicitlyCleared?t||(t=e.slice(0,r)):t&&t.push(e[r]);return t?t.length?t:null:e}function ui(e,t){var r=t["spans_"+e.id];if(!r)return null;for(var n=[],i=0;i<t.text.length;++i)n.push(ai(r[i]));return n}function ci(e,t){var r=ui(e,t),n=J(e,t);if(!r)return n;if(!n)return r;for(var i=0;i<r.length;++i){var o=r[i],l=n[i];if(o&&l)e:for(var s=0;s<l.length;++s){for(var a=l[s],u=0;u<o.length;++u)if(o[u].marker==a.marker)continue e;o.push(a)}else l&&(r[i]=l)}return r}function fi(e,t,r){for(var n=[],i=0;i<e.length;++i){var o=e[i];if(o.ranges)n.push(r?ks.prototype.deepCopy.call(o):o);else{var l=o.changes,s=[];n.push({changes:s});for(var a=0;a<l.length;++a){var u=l[a],c=void 0;if(s.push({from:u.from,to:u.to,text:u.text}),t)for(var f in u)(c=f.match(/^spans_(\d+)$/))&&h(t,Number(c[1]))>-1&&(g(s)[f]=u[f],delete u[f])}}}return n}function hi(e,t,r,n){if(n){var i=e.anchor;if(r){var o=P(t,i)<0;o!=P(r,i)<0?(i=t,t=r):o!=P(t,r)<0&&(t=r)}return new Ts(i,t)}return new Ts(r||t,t)}function di(e,t,r,n,i){null==i&&(i=e.cm&&(e.cm.display.shift||e.extend)),bi(e,new ks([hi(e.sel.primary(),t,r,i)],0),n)}function pi(e,t,r){for(var n=[],i=e.cm&&(e.cm.display.shift||e.extend),o=0;o<e.sel.ranges.length;o++)n[o]=hi(e.sel.ranges[o],t[o],null,i);bi(e,zn(n,e.sel.primIndex),r)}function gi(e,t,r,n){var i=e.sel.ranges.slice(0);i[t]=r,bi(e,zn(i,e.sel.primIndex),n)}function vi(e,t,r,n){bi(e,Rn(t,r),n)}function mi(e,t,r){var n={ranges:t.ranges,update:function(t){var r=this;this.ranges=[];for(var n=0;n<t.length;n++)r.ranges[n]=new Ts(U(e,t[n].anchor),U(e,t[n].head))},origin:r&&r.origin};return Te(e,"beforeSelectionChange",e,n),e.cm&&Te(e.cm,"beforeSelectionChange",e.cm,n),n.ranges!=t.ranges?zn(n.ranges,n.ranges.length-1):t}function yi(e,t,r){var n=e.history.done,i=g(n);i&&i.ranges?(n[n.length-1]=t,wi(e,t,r)):bi(e,t,r)}function bi(e,t,r){wi(e,t,r),oi(e,e.sel,e.cm?e.cm.curOp.id:NaN,r)}function wi(e,t,r){(Oe(e,"beforeSelectionChange")||e.cm&&Oe(e.cm,"beforeSelectionChange"))&&(t=mi(e,t,r)),xi(e,Si(e,t,r&&r.bias||(P(t.primary().head,e.sel.primary().head)<0?-1:1),!0)),r&&!1===r.scroll||!e.cm||jr(e.cm)}function xi(e,t){t.equals(e.sel)||(e.sel=t,e.cm&&(e.cm.curOp.updateInput=e.cm.curOp.selectionChanged=!0,Ne(e.cm)),bt(e,"cursorActivity",e))}function Ci(e){xi(e,Si(e,e.sel,null,!1))}function Si(e,t,r,n){for(var i,o=0;o<t.ranges.length;o++){var l=t.ranges[o],s=t.ranges.length==e.sel.ranges.length&&e.sel.ranges[o],a=ki(e,l.anchor,s&&s.anchor,r,n),u=ki(e,l.head,s&&s.head,r,n);(i||a!=l.anchor||u!=l.head)&&(i||(i=t.ranges.slice(0,o)),i[o]=new Ts(a,u))}return i?zn(i,t.primIndex):t}function Li(e,t,r,n,i){var o=M(e,t.line);if(o.markedSpans)for(var l=0;l<o.markedSpans.length;++l){var s=o.markedSpans[l],a=s.marker;if((null==s.from||(a.inclusiveLeft?s.from<=t.ch:s.from<t.ch))&&(null==s.to||(a.inclusiveRight?s.to>=t.ch:s.to>t.ch))){if(i&&(Te(a,"beforeCursorEnter"),a.explicitlyCleared)){if(o.markedSpans){--l;continue}break}if(!a.atomic)continue;if(r){var u=a.find(n<0?1:-1),c=void 0;if((n<0?a.inclusiveRight:a.inclusiveLeft)&&(u=Ti(e,u,-n,u&&u.line==t.line?o:null)),u&&u.line==t.line&&(c=P(u,r))&&(n<0?c<0:c>0))return Li(e,u,t,n,i)}var f=a.find(n<0?-1:1);return(n<0?a.inclusiveLeft:a.inclusiveRight)&&(f=Ti(e,f,n,f.line==t.line?o:null)),f?Li(e,f,t,n,i):null}}return t}function ki(e,t,r,n,i){var o=n||1,l=Li(e,t,r,o,i)||!i&&Li(e,t,r,o,!0)||Li(e,t,r,-o,i)||!i&&Li(e,t,r,-o,!0);return l||(e.cantEdit=!0,E(e.first,0))}function Ti(e,t,r,n){return r<0&&0==t.ch?t.line>e.first?U(e,E(t.line-1)):null:r>0&&t.ch==(n||M(e,t.line)).text.length?t.line<e.first+e.size-1?E(t.line+1,0):null:new E(t.line,t.ch+r)}function Mi(e){e.setSelection(E(e.firstLine(),0),E(e.lastLine()),Gl)}function Ni(e,t,r){var n={canceled:!1,from:t.from,to:t.to,text:t.text,origin:t.origin,cancel:function(){return n.canceled=!0}};return r&&(n.update=function(t,r,i,o){t&&(n.from=U(e,t)),r&&(n.to=U(e,r)),i&&(n.text=i),void 0!==o&&(n.origin=o)}),Te(e,"beforeChange",e,n),e.cm&&Te(e.cm,"beforeChange",e.cm,n),n.canceled?null:{from:n.from,to:n.to,text:n.text,origin:n.origin}}function Oi(e,t,r){if(e.cm){if(!e.cm.curOp)return dn(e.cm,Oi)(e,t,r);if(e.cm.state.suppressEdits)return}if(!(Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"))||(t=Ni(e,t,!0))){var n=Yl&&!r&&te(e,t.from,t.to);if(n)for(var i=n.length-1;i>=0;--i)Ai(e,{from:n[i].from,to:n[i].to,text:i?[""]:t.text,origin:t.origin});else Ai(e,t)}}function Ai(e,t){if(1!=t.text.length||""!=t.text[0]||0!=P(t.from,t.to)){var r=Un(e,t);ni(e,t,r,e.cm?e.cm.curOp.id:NaN),Hi(e,t,r,J(e,t));var n=[];$n(e,function(e,r){r||-1!=h(n,e.history)||(zi(e.history,t),n.push(e.history)),Hi(e,t,null,J(e,t))})}}function Wi(e,t,r){if(!e.cm||!e.cm.state.suppressEdits||r){for(var n,i=e.history,o=e.sel,l="undo"==t?i.done:i.undone,s="undo"==t?i.undone:i.done,a=0;a<l.length&&(n=l[a],r?!n.ranges||n.equals(e.sel):n.ranges);a++);if(a!=l.length){for(i.lastOrigin=i.lastSelOrigin=null;(n=l.pop()).ranges;){if(li(n,s),r&&!n.equals(e.sel))return void bi(e,n,{clearRedo:!1});o=n}var u=[];li(o,s),s.push({changes:u,generation:i.generation}),i.generation=n.generation||++i.maxGeneration;for(var c=Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"),f=n.changes.length-1;f>=0;--f){var d=function(r){var i=n.changes[r];if(i.origin=t,c&&!Ni(e,i,!1))return l.length=0,{};u.push(ei(e,i));var o=r?Un(e,i):g(l);Hi(e,i,o,ci(e,i)),!r&&e.cm&&e.cm.scrollIntoView({from:i.from,to:Bn(i)});var s=[];$n(e,function(e,t){t||-1!=h(s,e.history)||(zi(e.history,i),s.push(e.history)),Hi(e,i,null,ci(e,i))})}(f);if(d)return d.v}}}}function Di(e,t){if(0!=t&&(e.first+=t,e.sel=new ks(v(e.sel.ranges,function(e){return new Ts(E(e.anchor.line+t,e.anchor.ch),E(e.head.line+t,e.head.ch))}),e.sel.primIndex),e.cm)){vn(e.cm,e.first,e.first-t,t);for(var r=e.cm.display,n=r.viewFrom;n<r.viewTo;n++)mn(e.cm,n,"gutter")}}function Hi(e,t,r,n){if(e.cm&&!e.cm.curOp)return dn(e.cm,Hi)(e,t,r,n);if(t.to.line<e.first)Di(e,t.text.length-1-(t.to.line-t.from.line));else if(!(t.from.line>e.lastLine())){if(t.from.line<e.first){var i=t.text.length-1-(e.first-t.from.line);Di(e,i),t={from:E(e.first,0),to:E(t.to.line+i,t.to.ch),text:[g(t.text)],origin:t.origin}}var o=e.lastLine();t.to.line>o&&(t={from:t.from,to:E(o,M(e,o).text.length),text:[t.text[0]],origin:t.origin}),t.removed=N(e,t.from,t.to),r||(r=Un(e,t)),e.cm?Fi(e.cm,t,n):_n(e,t,n),wi(e,r,Gl)}}function Fi(e,t,r){var n=e.doc,i=e.display,o=t.from,l=t.to,s=!1,a=o.line;e.options.lineWrapping||(a=W(fe(M(n,o.line))),n.iter(a,l.line+1,function(e){if(e==i.maxLine)return s=!0,!0})),n.sel.contains(t.from,t.to)>-1&&Ne(e),_n(n,t,r,xr(e)),e.options.lineWrapping||(n.iter(a,o.line+t.text.length,function(e){var t=be(e);t>i.maxLineLength&&(i.maxLine=e,i.maxLineLength=t,i.maxLineChanged=!0,s=!1)}),s&&(e.curOp.updateMaxLine=!0)),nt(n,o.line),Cn(e,400);var u=t.text.length-(l.line-o.line)-1;t.full?vn(e):o.line!=l.line||1!=t.text.length||Yn(e.doc,t)?vn(e,o.line,l.line+1,u):mn(e,o.line,"text");var c=Oe(e,"changes"),f=Oe(e,"change");if(f||c){var h={from:o,to:l,text:t.text,removed:t.removed,origin:t.origin};f&&bt(e,"change",e,h),c&&(e.curOp.changeObjs||(e.curOp.changeObjs=[])).push(h)}e.display.selForContextMenu=null}function Ei(e,t,r,n,i){if(n||(n=r),P(n,r)<0){var o;r=(o=[n,r])[0],n=o[1]}"string"==typeof t&&(t=e.splitLines(t)),Oi(e,{from:r,to:n,text:t,origin:i})}function Pi(e,t,r,n){r<e.line?e.line+=n:t<e.line&&(e.line=t,e.ch=0)}function Ii(e,t,r,n){for(var i=0;i<e.length;++i){var o=e[i],l=!0;if(o.ranges){o.copied||((o=e[i]=o.deepCopy()).copied=!0);for(var s=0;s<o.ranges.length;s++)Pi(o.ranges[s].anchor,t,r,n),Pi(o.ranges[s].head,t,r,n)}else{for(var a=0;a<o.changes.length;++a){var u=o.changes[a];if(r<u.from.line)u.from=E(u.from.line+n,u.from.ch),u.to=E(u.to.line+n,u.to.ch);else if(t<=u.to.line){l=!1;break}}l||(e.splice(0,i+1),i=0)}}}function zi(e,t){var r=t.from.line,n=t.to.line,i=t.text.length-(n-r)-1;Ii(e.done,r,n,i),Ii(e.undone,r,n,i)}function Ri(e,t,r,n){var i=t,o=t;return"number"==typeof t?o=M(e,G(e,t)):i=W(t),null==i?null:(n(o,i)&&e.cm&&mn(e.cm,i,r),o)}function Bi(e){var t=this;this.lines=e,this.parent=null;for(var r=0,n=0;n<e.length;++n)e[n].parent=t,r+=e[n].height;this.height=r}function Gi(e){var t=this;this.children=e;for(var r=0,n=0,i=0;i<e.length;++i){var o=e[i];r+=o.chunkSize(),n+=o.height,o.parent=t}this.size=r,this.height=n,this.parent=null}function Ui(e,t,r){ye(t)<(e.curOp&&e.curOp.scrollTop||e.doc.scrollTop)&&Kr(e,r)}function Vi(e,t,r,n){var i=new Ms(e,r,n),o=e.cm;return o&&i.noHScroll&&(o.display.alignWidgets=!0),Ri(e,t,"widget",function(t){var r=t.widgets||(t.widgets=[]);if(null==i.insertAt?r.push(i):r.splice(Math.min(r.length-1,Math.max(0,i.insertAt)),0,i),i.line=t,o&&!ve(e,t)){var n=ye(t)<e.scrollTop;A(t,t.height+Ht(i)),n&&Kr(o,i.height),o.curOp.forceUpdate=!0}return!0}),bt(o,"lineWidgetAdded",o,i,"number"==typeof t?t:W(t)),i}function Ki(e,t,r,n,o){if(n&&n.shared)return ji(e,t,r,n,o);if(e.cm&&!e.cm.curOp)return dn(e.cm,Ki)(e,t,r,n,o);var l=new Os(e,o),s=P(t,r);if(n&&c(n,l,!1),s>0||0==s&&!1!==l.clearWhenEmpty)return l;if(l.replacedWith&&(l.collapsed=!0,l.widgetNode=i("span",[l.replacedWith],"CodeMirror-widget"),n.handleMouseEvents||l.widgetNode.setAttribute("cm-ignore-events","true"),n.insertLeft&&(l.widgetNode.insertLeft=!0)),l.collapsed){if(ce(e,t.line,t,r,l)||t.line!=r.line&&ce(e,r.line,t,r,l))throw new Error("Inserting collapsed marker partially overlapping an existing one");X()}l.addToHistory&&ni(e,{from:t,to:r,origin:"markText"},e.sel,NaN);var a,u=t.line,f=e.cm;if(e.iter(u,r.line+1,function(e){f&&l.collapsed&&!f.options.lineWrapping&&fe(e)==f.display.maxLine&&(a=!0),l.collapsed&&u!=t.line&&A(e,0),q(e,new Y(l,u==t.line?t.ch:null,u==r.line?r.ch:null)),++u}),l.collapsed&&e.iter(t.line,r.line+1,function(t){ve(e,t)&&A(t,0)}),l.clearOnEnter&&Ql(l,"beforeCursorEnter",function(){return l.clear()}),l.readOnly&&(j(),(e.history.done.length||e.history.undone.length)&&e.clearHistory()),l.collapsed&&(l.id=++Ns,l.atomic=!0),f){if(a&&(f.curOp.updateMaxLine=!0),l.collapsed)vn(f,t.line,r.line+1);else if(l.className||l.title||l.startStyle||l.endStyle||l.css)for(var h=t.line;h<=r.line;h++)mn(f,h,"text");l.atomic&&Ci(f.doc),bt(f,"markerAdded",f,l)}return l}function ji(e,t,r,n,i){(n=c(n)).shared=!1;var o=[Ki(e,t,r,n,i)],l=o[0],s=n.widgetNode;return $n(e,function(e){s&&(n.widgetNode=s.cloneNode(!0)),o.push(Ki(e,U(e,t),U(e,r),n,i));for(var a=0;a<e.linked.length;++a)if(e.linked[a].isParent)return;l=g(o)}),new As(o,l)}function Xi(e){return e.findMarks(E(e.first,0),e.clipPos(E(e.lastLine())),function(e){return e.parent})}function Yi(e,t){for(var r=0;r<t.length;r++){var n=t[r],i=n.find(),o=e.clipPos(i.from),l=e.clipPos(i.to);if(P(o,l)){var s=Ki(e,o,l,n.primary,n.primary.type);n.markers.push(s),s.parent=n}}}function _i(e){for(var t=0;t<e.length;t++)!function(t){var r=e[t],n=[r.primary.doc];$n(r.primary.doc,function(e){return n.push(e)});for(var i=0;i<r.markers.length;i++){var o=r.markers[i];-1==h(n,o.doc)&&(o.parent=null,r.markers.splice(i--,1))}}(t)}function $i(e){var t=this;if(Qi(t),!Me(t,e)&&!Ft(t.display,e)){We(e),gl&&(Hs=+new Date);var r=Sr(t,e,!0),n=e.dataTransfer.files;if(r&&!t.isReadOnly())if(n&&n.length&&window.FileReader&&window.File)for(var i=n.length,o=Array(i),l=0,s=0;s<i;++s)!function(e,n){if(!t.options.allowDropFileTypes||-1!=h(t.options.allowDropFileTypes,e.type)){var s=new FileReader;s.onload=dn(t,function(){var e=s.result;if(/[\x00-\x08\x0e-\x1f]{2}/.test(e)&&(e=""),o[n]=e,++l==i){var a={from:r=U(t.doc,r),to:r,text:t.doc.splitLines(o.join(t.doc.lineSeparator())),origin:"paste"};Oi(t.doc,a),yi(t.doc,Rn(r,Bn(a)))}}),s.readAsText(e)}}(n[s],s);else{if(t.state.draggingText&&t.doc.sel.contains(r)>-1)return t.state.draggingText(e),void setTimeout(function(){return t.display.input.focus()},20);try{var a=e.dataTransfer.getData("Text");if(a){var u;if(t.state.draggingText&&!t.state.draggingText.copy&&(u=t.listSelections()),wi(t.doc,Rn(r,r)),u)for(var c=0;c<u.length;++c)Ei(t.doc,"",u[c].anchor,u[c].head,"drag");t.replaceSelection(a,"around","paste"),t.display.input.focus()}}catch(e){}}}}function qi(e,t){if(gl&&(!e.state.draggingText||+new Date-Hs<100))Fe(t);else if(!Me(e,t)&&!Ft(e.display,t)&&(t.dataTransfer.setData("Text",e.getSelection()),t.dataTransfer.effectAllowed="copyMove",t.dataTransfer.setDragImage&&!xl)){var r=n("img",null,null,"position: fixed; left: 0; top: 0;");r.src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",wl&&(r.width=r.height=1,e.display.wrapper.appendChild(r),r._top=r.offsetTop),t.dataTransfer.setDragImage(r,0,0),wl&&r.parentNode.removeChild(r)}}function Zi(e,t){var i=Sr(e,t);if(i){var o=document.createDocumentFragment();Mr(e,i,o),e.display.dragCursor||(e.display.dragCursor=n("div",null,"CodeMirror-cursors CodeMirror-dragcursors"),e.display.lineSpace.insertBefore(e.display.dragCursor,e.display.cursorDiv)),r(e.display.dragCursor,o)}}function Qi(e){e.display.dragCursor&&(e.display.lineSpace.removeChild(e.display.dragCursor),e.display.dragCursor=null)}function Ji(e){if(document.getElementsByClassName)for(var t=document.getElementsByClassName("CodeMirror"),r=0;r<t.length;r++){var n=t[r].CodeMirror;n&&e(n)}}function eo(){Fs||(to(),Fs=!0)}function to(){var e;Ql(window,"resize",function(){null==e&&(e=setTimeout(function(){e=null,Ji(ro)},100))}),Ql(window,"blur",function(){return Ji(Fr)})}function ro(e){var t=e.display;t.lastWrapHeight==t.wrapper.clientHeight&&t.lastWrapWidth==t.wrapper.clientWidth||(t.cachedCharWidth=t.cachedTextHeight=t.cachedPaddingH=null,t.scrollbarsClipped=!1,e.setSize())}function no(e){var t=e.split(/-(?!$)/);e=t[t.length-1];for(var r,n,i,o,l=0;l<t.length-1;l++){var s=t[l];if(/^(cmd|meta|m)$/i.test(s))o=!0;else if(/^a(lt)?$/i.test(s))r=!0;else if(/^(c|ctrl|control)$/i.test(s))n=!0;else{if(!/^s(hift)?$/i.test(s))throw new Error("Unrecognized modifier name: "+s);i=!0}}return r&&(e="Alt-"+e),n&&(e="Ctrl-"+e),o&&(e="Cmd-"+e),i&&(e="Shift-"+e),e}function io(e){var t={};for(var r in e)if(e.hasOwnProperty(r)){var n=e[r];if(/^(name|fallthrough|(de|at)tach)$/.test(r))continue;if("..."==n){delete e[r];continue}for(var i=v(r.split(" "),no),o=0;o<i.length;o++){var l=void 0,s=void 0;o==i.length-1?(s=i.join(" "),l=n):(s=i.slice(0,o+1).join(" "),l="...");var a=t[s];if(a){if(a!=l)throw new Error("Inconsistent bindings for "+s)}else t[s]=l}delete e[r]}for(var u in t)e[u]=t[u];return e}function oo(e,t,r,n){var i=(t=uo(t)).call?t.call(e,n):t[e];if(!1===i)return"nothing";if("..."===i)return"multi";if(null!=i&&r(i))return"handled";if(t.fallthrough){if("[object Array]"!=Object.prototype.toString.call(t.fallthrough))return oo(e,t.fallthrough,r,n);for(var o=0;o<t.fallthrough.length;o++){var l=oo(e,t.fallthrough[o],r,n);if(l)return l}}}function lo(e){var t="string"==typeof e?e:Es[e.keyCode];return"Ctrl"==t||"Alt"==t||"Shift"==t||"Mod"==t}function so(e,t,r){var n=e;return t.altKey&&"Alt"!=n&&(e="Alt-"+e),(Dl?t.metaKey:t.ctrlKey)&&"Ctrl"!=n&&(e="Ctrl-"+e),(Dl?t.ctrlKey:t.metaKey)&&"Cmd"!=n&&(e="Cmd-"+e),!r&&t.shiftKey&&"Shift"!=n&&(e="Shift-"+e),e}function ao(e,t){if(wl&&34==e.keyCode&&e.char)return!1;var r=Es[e.keyCode];return null!=r&&!e.altGraphKey&&so(r,e,t)}function uo(e){return"string"==typeof e?Rs[e]:e}function co(e,t){for(var r=e.doc.sel.ranges,n=[],i=0;i<r.length;i++){for(var o=t(r[i]);n.length&&P(o.from,g(n).to)<=0;){var l=n.pop();if(P(l.from,o.from)<0){o.from=l.from;break}}n.push(o)}hn(e,function(){for(var t=n.length-1;t>=0;t--)Ei(e.doc,"",n[t].from,n[t].to,"+delete");jr(e)})}function fo(e,t,r){var n=L(e.text,t+r,r);return n<0||n>e.text.length?null:n}function ho(e,t,r){var n=fo(e,t.ch,r);return null==n?null:new E(t.line,n,r<0?"after":"before")}function po(e,t,r,n,i){if(e){var o=Se(r,t.doc.direction);if(o){var l,s=i<0?g(o):o[0],a=i<0==(1==s.level)?"after":"before";if(s.level>0){var u=Xt(t,r);l=i<0?r.text.length-1:0;var c=Yt(t,u,l).top;l=k(function(e){return Yt(t,u,e).top==c},i<0==(1==s.level)?s.from:s.to-1,l),"before"==a&&(l=fo(r,l,1))}else l=i<0?s.to:s.from;return new E(n,l,a)}}return new E(n,i<0?r.text.length:0,i<0?"before":"after")}function go(e,t,r,n){var i=Se(t,e.doc.direction);if(!i)return ho(t,r,n);r.ch>=t.text.length?(r.ch=t.text.length,r.sticky="before"):r.ch<=0&&(r.ch=0,r.sticky="after");var o=Ce(i,r.ch,r.sticky),l=i[o];if("ltr"==e.doc.direction&&l.level%2==0&&(n>0?l.to>r.ch:l.from<r.ch))return ho(t,r,n);var s,a=function(e,r){return fo(t,e instanceof E?e.ch:e,r)},u=function(r){return e.options.lineWrapping?(s=s||Xt(e,t),hr(e,t,s,r)):{begin:0,end:t.text.length}},c=u("before"==r.sticky?a(r,-1):r.ch);if("rtl"==e.doc.direction||1==l.level){var f=1==l.level==n<0,h=a(r,f?1:-1);if(null!=h&&(f?h<=l.to&&h<=c.end:h>=l.from&&h>=c.begin)){var d=f?"before":"after";return new E(r.line,h,d)}}var p=function(e,t,n){for(var o=function(e,t){return t?new E(r.line,a(e,1),"before"):new E(r.line,e,"after")};e>=0&&e<i.length;e+=t){var l=i[e],s=t>0==(1!=l.level),u=s?n.begin:a(n.end,-1);if(l.from<=u&&u<l.to)return o(u,s);if(u=s?l.from:a(l.to,-1),n.begin<=u&&u<n.end)return o(u,s)}},g=p(o+n,n,c);if(g)return g;var v=n>0?c.end:a(c.begin,-1);return null==v||n>0&&v==t.text.length||!(g=p(n>0?0:i.length-1,n,u(v)))?null:g}function vo(e,t){var r=M(e.doc,t),n=fe(r);return n!=r&&(t=W(n)),po(!0,e,n,t,1)}function mo(e,t){var r=M(e.doc,t),n=he(r);return n!=r&&(t=W(n)),po(!0,e,r,t,-1)}function yo(e,t){var r=vo(e,t.line),n=M(e.doc,r.line),i=Se(n,e.doc.direction);if(!i||0==i[0].level){var o=Math.max(0,n.text.search(/\S/)),l=t.line==r.line&&t.ch<=o&&t.ch;return E(r.line,l?0:o,r.sticky)}return r}function bo(e,t,r){if("string"==typeof t&&!(t=Bs[t]))return!1;e.display.input.ensurePolled();var n=e.display.shift,i=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),r&&(e.display.shift=!1),i=t(e)!=Bl}finally{e.display.shift=n,e.state.suppressEdits=!1}return i}function wo(e,t,r){for(var n=0;n<e.state.keyMaps.length;n++){var i=oo(t,e.state.keyMaps[n],r,e);if(i)return i}return e.options.extraKeys&&oo(t,e.options.extraKeys,r,e)||oo(t,e.options.keyMap,r,e)}function xo(e,t,r,n){var i=e.state.keySeq;if(i){if(lo(t))return"handled";Gs.set(50,function(){e.state.keySeq==i&&(e.state.keySeq=null,e.display.input.reset())}),t=i+" "+t}var o=wo(e,t,n);return"multi"==o&&(e.state.keySeq=t),"handled"==o&&bt(e,"keyHandled",e,t,r),"handled"!=o&&"multi"!=o||(We(r),Ar(e)),i&&!o&&/\'$/.test(t)?(We(r),!0):!!o}function Co(e,t){var r=ao(t,!0);return!!r&&(t.shiftKey&&!e.state.keySeq?xo(e,"Shift-"+r,t,function(t){return bo(e,t,!0)})||xo(e,r,t,function(t){if("string"==typeof t?/^go[A-Z]/.test(t):t.motion)return bo(e,t)}):xo(e,r,t,function(t){return bo(e,t)}))}function So(e,t,r){return xo(e,"'"+r+"'",t,function(t){return bo(e,t,!0)})}function Lo(e){var t=this;if(t.curOp.focus=l(),!Me(t,e)){gl&&vl<11&&27==e.keyCode&&(e.returnValue=!1);var r=e.keyCode;t.display.shift=16==r||e.shiftKey;var n=Co(t,e);wl&&(Us=n?r:null,!n&&88==r&&!rs&&(Ml?e.metaKey:e.ctrlKey)&&t.replaceSelection("",null,"cut")),18!=r||/\bCodeMirror-crosshair\b/.test(t.display.lineDiv.className)||ko(t)}}function ko(e){function t(e){18!=e.keyCode&&e.altKey||(Fl(r,"CodeMirror-crosshair"),ke(document,"keyup",t),ke(document,"mouseover",t))}var r=e.display.lineDiv;s(r,"CodeMirror-crosshair"),Ql(document,"keyup",t),Ql(document,"mouseover",t)}function To(e){16==e.keyCode&&(this.doc.sel.shift=!1),Me(this,e)}function Mo(e){var t=this;if(!(Ft(t.display,e)||Me(t,e)||e.ctrlKey&&!e.altKey||Ml&&e.metaKey)){var r=e.keyCode,n=e.charCode;if(wl&&r==Us)return Us=null,void We(e);if(!wl||e.which&&!(e.which<10)||!Co(t,e)){var i=String.fromCharCode(null==n?r:n);"\b"!=i&&(So(t,e,i)||t.display.input.onKeyPress(e))}}}function No(e,t){var r=+new Date;return js&&js.compare(r,e,t)?(Ks=js=null,"triple"):Ks&&Ks.compare(r,e,t)?(js=new Vs(r,e,t),Ks=null,"double"):(Ks=new Vs(r,e,t),js=null,"single")}function Oo(e){var t=this,r=t.display;if(!(Me(t,e)||r.activeTouch&&r.input.supportsTouch()))if(r.input.ensurePolled(),r.shift=e.shiftKey,Ft(r,e))ml||(r.scroller.draggable=!1,setTimeout(function(){return r.scroller.draggable=!0},100));else if(!zo(t,e)){var n=Sr(t,e),i=Pe(e),o=n?No(n,i):"single";window.focus(),1==i&&t.state.selectingText&&t.state.selectingText(e),n&&Ao(t,i,n,o,e)||(1==i?n?Do(t,n,o,e):Ee(e)==r.scroller&&We(e):2==i?(n&&di(t.doc,n),setTimeout(function(){return r.input.focus()},20)):3==i&&(Hl?Ro(t,e):Dr(t)))}}function Ao(e,t,r,n,i){var o="Click";return"double"==n?o="Double"+o:"triple"==n&&(o="Triple"+o),o=(1==t?"Left":2==t?"Middle":"Right")+o,xo(e,so(o,i),i,function(t){if("string"==typeof t&&(t=Bs[t]),!t)return!1;var n=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),n=t(e,r)!=Bl}finally{e.state.suppressEdits=!1}return n})}function Wo(e,t,r){var n=e.getOption("configureMouse"),i=n?n(e,t,r):{};if(null==i.unit){var o=Nl?r.shiftKey&&r.metaKey:r.altKey;i.unit=o?"rectangle":"single"==t?"char":"double"==t?"word":"line"}return(null==i.extend||e.doc.extend)&&(i.extend=e.doc.extend||r.shiftKey),null==i.addNew&&(i.addNew=Ml?r.metaKey:r.ctrlKey),null==i.moveOnDrag&&(i.moveOnDrag=!(Ml?r.altKey:r.ctrlKey)),i}function Do(e,t,r,n){gl?setTimeout(u(Wr,e),0):e.curOp.focus=l();var i,o=Wo(e,r,n),s=e.doc.sel;e.options.dragDrop&&Jl&&!e.isReadOnly()&&"single"==r&&(i=s.contains(t))>-1&&(P((i=s.ranges[i]).from(),t)<0||t.xRel>0)&&(P(i.to(),t)>0||t.xRel<0)?Ho(e,n,t,o):Eo(e,n,t,o)}function Ho(e,t,r,n){var i=e.display,o=!1,l=dn(e,function(t){ml&&(i.scroller.draggable=!1),e.state.draggingText=!1,ke(document,"mouseup",l),ke(document,"mousemove",s),ke(i.scroller,"dragstart",a),ke(i.scroller,"drop",l),o||(We(t),n.addNew||di(e.doc,r,null,null,n.extend),ml||gl&&9==vl?setTimeout(function(){document.body.focus(),i.input.focus()},20):i.input.focus())}),s=function(e){o=o||Math.abs(t.clientX-e.clientX)+Math.abs(t.clientY-e.clientY)>=10},a=function(){return o=!0};ml&&(i.scroller.draggable=!0),e.state.draggingText=l,l.copy=!n.moveOnDrag,i.scroller.dragDrop&&i.scroller.dragDrop(),Ql(document,"mouseup",l),Ql(document,"mousemove",s),Ql(i.scroller,"dragstart",a),Ql(i.scroller,"drop",l),Dr(e),setTimeout(function(){return i.input.focus()},20)}function Fo(e,t,r){if("char"==r)return new Ts(t,t);if("word"==r)return e.findWordAt(t);if("line"==r)return new Ts(E(t.line,0),U(e.doc,E(t.line+1,0)));var n=r(e,t);return new Ts(n.from,n.to)}function Eo(e,t,r,n){function i(t){if(0!=P(m,t))if(m=t,"rectangle"==n.unit){for(var i=[],o=e.options.tabSize,l=f(M(u,r.line).text,r.ch,o),s=f(M(u,t.line).text,t.ch,o),a=Math.min(l,s),g=Math.max(l,s),v=Math.min(r.line,t.line),y=Math.min(e.lastLine(),Math.max(r.line,t.line));v<=y;v++){var b=M(u,v).text,w=d(b,a,o);a==g?i.push(new Ts(E(v,w),E(v,w))):b.length>w&&i.push(new Ts(E(v,w),E(v,d(b,g,o))))}i.length||i.push(new Ts(r,r)),bi(u,zn(p.ranges.slice(0,h).concat(i),h),{origin:"*mouse",scroll:!1}),e.scrollIntoView(t)}else{var x,C=c,S=Fo(e,t,n.unit),L=C.anchor;P(S.anchor,L)>0?(x=S.head,L=B(C.from(),S.anchor)):(x=S.anchor,L=R(C.to(),S.head));var k=p.ranges.slice(0);k[h]=Po(e,new Ts(U(u,L),x)),bi(u,zn(k,h),Ul)}}function o(t){var r=++b,s=Sr(e,t,!0,"rectangle"==n.unit);if(s)if(0!=P(s,m)){e.curOp.focus=l(),i(s);var c=Ir(a,u);(s.line>=c.to||s.line<c.from)&&setTimeout(dn(e,function(){b==r&&o(t)}),150)}else{var f=t.clientY<y.top?-20:t.clientY>y.bottom?20:0;f&&setTimeout(dn(e,function(){b==r&&(a.scroller.scrollTop+=f,o(t))}),50)}}function s(t){e.state.selectingText=!1,b=1/0,We(t),a.input.focus(),ke(document,"mousemove",w),ke(document,"mouseup",x),u.history.lastSelOrigin=null}var a=e.display,u=e.doc;We(t);var c,h,p=u.sel,g=p.ranges;if(n.addNew&&!n.extend?(h=u.sel.contains(r),c=h>-1?g[h]:new Ts(r,r)):(c=u.sel.primary(),h=u.sel.primIndex),"rectangle"==n.unit)n.addNew||(c=new Ts(r,r)),r=Sr(e,t,!0,!0),h=-1;else{var v=Fo(e,r,n.unit);c=n.extend?hi(c,v.anchor,v.head,n.extend):v}n.addNew?-1==h?(h=g.length,bi(u,zn(g.concat([c]),h),{scroll:!1,origin:"*mouse"})):g.length>1&&g[h].empty()&&"char"==n.unit&&!n.extend?(bi(u,zn(g.slice(0,h).concat(g.slice(h+1)),0),{scroll:!1,origin:"*mouse"}),p=u.sel):gi(u,h,c,Ul):(h=0,bi(u,new ks([c],0),Ul),p=u.sel);var m=r,y=a.wrapper.getBoundingClientRect(),b=0,w=dn(e,function(e){Pe(e)?o(e):s(e)}),x=dn(e,s);e.state.selectingText=x,Ql(document,"mousemove",w),Ql(document,"mouseup",x)}function Po(e,t){var r=t.anchor,n=t.head,i=M(e.doc,r.line);if(0==P(r,n)&&r.sticky==n.sticky)return t;var o=Se(i);if(!o)return t;var l=Ce(o,r.ch,r.sticky),s=o[l];if(s.from!=r.ch&&s.to!=r.ch)return t;var a=l+(s.from==r.ch==(1!=s.level)?0:1);if(0==a||a==o.length)return t;var u;if(n.line!=r.line)u=(n.line-r.line)*("ltr"==e.doc.direction?1:-1)>0;else{var c=Ce(o,n.ch,n.sticky),f=c-l||(n.ch-r.ch)*(1==s.level?-1:1);u=c==a-1||c==a?f<0:f>0}var h=o[a+(u?-1:0)],d=u==(1==h.level),p=d?h.from:h.to,g=d?"after":"before";return r.ch==p&&r.sticky==g?t:new Ts(new E(r.line,p,g),n)}function Io(e,t,r,n){var i,o;if(t.touches)i=t.touches[0].clientX,o=t.touches[0].clientY;else try{i=t.clientX,o=t.clientY}catch(t){return!1}if(i>=Math.floor(e.display.gutters.getBoundingClientRect().right))return!1;n&&We(t);var l=e.display,s=l.lineDiv.getBoundingClientRect();if(o>s.bottom||!Oe(e,r))return He(t);o-=s.top-l.viewOffset;for(var a=0;a<e.options.gutters.length;++a){var u=l.gutters.childNodes[a];if(u&&u.getBoundingClientRect().right>=i)return Te(e,r,e,D(e.doc,o),e.options.gutters[a],t),He(t)}}function zo(e,t){return Io(e,t,"gutterClick",!0)}function Ro(e,t){Ft(e.display,t)||Bo(e,t)||Me(e,t,"contextmenu")||e.display.input.onContextMenu(t)}function Bo(e,t){return!!Oe(e,"gutterContextMenu")&&Io(e,t,"gutterContextMenu",!1)}function Go(e){e.display.wrapper.className=e.display.wrapper.className.replace(/\s*cm-s-\S+/g,"")+e.options.theme.replace(/(^|\s)\s*/g," cm-s-"),er(e)}function Uo(e){Hn(e),vn(e),zr(e)}function Vo(e,t,r){if(!t!=!(r&&r!=Xs)){var n=e.display.dragFunctions,i=t?Ql:ke;i(e.display.scroller,"dragstart",n.start),i(e.display.scroller,"dragenter",n.enter),i(e.display.scroller,"dragover",n.over),i(e.display.scroller,"dragleave",n.leave),i(e.display.scroller,"drop",n.drop)}}function Ko(e){e.options.lineWrapping?(s(e.display.wrapper,"CodeMirror-wrap"),e.display.sizer.style.minWidth="",e.display.sizerWidth=null):(Fl(e.display.wrapper,"CodeMirror-wrap"),we(e)),Cr(e),vn(e),er(e),setTimeout(function(){return en(e)},100)}function jo(e,t){var r=this;if(!(this instanceof jo))return new jo(e,t);this.options=t=t?c(t):{},c(Ys,t,!1),Fn(t);var n=t.value;"string"==typeof n&&(n=new Ds(n,t.mode,null,t.lineSeparator,t.direction)),this.doc=n;var i=new jo.inputStyles[t.inputStyle](this),o=this.display=new T(e,n,i);o.wrapper.CodeMirror=this,Hn(this),Go(this),t.lineWrapping&&(this.display.wrapper.className+=" CodeMirror-wrap"),rn(this),this.state={keyMaps:[],overlays:[],modeGen:0,overwrite:!1,delayingBlurEvent:!1,focused:!1,suppressEdits:!1,pasteIncoming:!1,cutIncoming:!1,selectingText:!1,draggingText:!1,highlight:new Pl,keySeq:null,specialChars:null},t.autofocus&&!Tl&&o.input.focus(),gl&&vl<11&&setTimeout(function(){return r.display.input.reset(!0)},20),Xo(this),eo(),nn(this),this.curOp.forceUpdate=!0,qn(this,n),t.autofocus&&!Tl||this.hasFocus()?setTimeout(u(Hr,this),20):Fr(this);for(var l in _s)_s.hasOwnProperty(l)&&_s[l](r,t[l],Xs);Rr(this),t.finishInit&&t.finishInit(this);for(var s=0;s<$s.length;++s)$s[s](r);on(this),ml&&t.lineWrapping&&"optimizelegibility"==getComputedStyle(o.lineDiv).textRendering&&(o.lineDiv.style.textRendering="auto")}function Xo(e){function t(){i.activeTouch&&(o=setTimeout(function(){return i.activeTouch=null},1e3),(l=i.activeTouch).end=+new Date)}function r(e){if(1!=e.touches.length)return!1;var t=e.touches[0];return t.radiusX<=1&&t.radiusY<=1}function n(e,t){if(null==t.left)return!0;var r=t.left-e.left,n=t.top-e.top;return r*r+n*n>400}var i=e.display;Ql(i.scroller,"mousedown",dn(e,Oo)),gl&&vl<11?Ql(i.scroller,"dblclick",dn(e,function(t){if(!Me(e,t)){var r=Sr(e,t);if(r&&!zo(e,t)&&!Ft(e.display,t)){We(t);var n=e.findWordAt(r);di(e.doc,n.anchor,n.head)}}})):Ql(i.scroller,"dblclick",function(t){return Me(e,t)||We(t)}),Hl||Ql(i.scroller,"contextmenu",function(t){return Ro(e,t)});var o,l={end:0};Ql(i.scroller,"touchstart",function(t){if(!Me(e,t)&&!r(t)&&!zo(e,t)){i.input.ensurePolled(),clearTimeout(o);var n=+new Date;i.activeTouch={start:n,moved:!1,prev:n-l.end<=300?l:null},1==t.touches.length&&(i.activeTouch.left=t.touches[0].pageX,i.activeTouch.top=t.touches[0].pageY)}}),Ql(i.scroller,"touchmove",function(){i.activeTouch&&(i.activeTouch.moved=!0)}),Ql(i.scroller,"touchend",function(r){var o=i.activeTouch;if(o&&!Ft(i,r)&&null!=o.left&&!o.moved&&new Date-o.start<300){var l,s=e.coordsChar(i.activeTouch,"page");l=!o.prev||n(o,o.prev)?new Ts(s,s):!o.prev.prev||n(o,o.prev.prev)?e.findWordAt(s):new Ts(E(s.line,0),U(e.doc,E(s.line+1,0))),e.setSelection(l.anchor,l.head),e.focus(),We(r)}t()}),Ql(i.scroller,"touchcancel",t),Ql(i.scroller,"scroll",function(){i.scroller.clientHeight&&(qr(e,i.scroller.scrollTop),Qr(e,i.scroller.scrollLeft,!0),Te(e,"scroll",e))}),Ql(i.scroller,"mousewheel",function(t){return In(e,t)}),Ql(i.scroller,"DOMMouseScroll",function(t){return In(e,t)}),Ql(i.wrapper,"scroll",function(){return i.wrapper.scrollTop=i.wrapper.scrollLeft=0}),i.dragFunctions={enter:function(t){Me(e,t)||Fe(t)},over:function(t){Me(e,t)||(Zi(e,t),Fe(t))},start:function(t){return qi(e,t)},drop:dn(e,$i),leave:function(t){Me(e,t)||Qi(e)}};var s=i.input.getField();Ql(s,"keyup",function(t){return To.call(e,t)}),Ql(s,"keydown",dn(e,Lo)),Ql(s,"keypress",dn(e,Mo)),Ql(s,"focus",function(t){return Hr(e,t)}),Ql(s,"blur",function(t){return Fr(e,t)})}function Yo(e,t,r,n){var i,o=e.doc;null==r&&(r="add"),"smart"==r&&(o.mode.indent?i=$e(e,t).state:r="prev");var l=e.options.tabSize,s=M(o,t),a=f(s.text,null,l);s.stateAfter&&(s.stateAfter=null);var u,c=s.text.match(/^\s*/)[0];if(n||/\S/.test(s.text)){if("smart"==r&&((u=o.mode.indent(i,s.text.slice(c.length),s.text))==Bl||u>150)){if(!n)return;r="prev"}}else u=0,r="not";"prev"==r?u=t>o.first?f(M(o,t-1).text,null,l):0:"add"==r?u=a+e.options.indentUnit:"subtract"==r?u=a-e.options.indentUnit:"number"==typeof r&&(u=a+r),u=Math.max(0,u);var h="",d=0;if(e.options.indentWithTabs)for(var g=Math.floor(u/l);g;--g)d+=l,h+="\t";if(d<u&&(h+=p(u-d)),h!=c)return Ei(o,h,E(t,0),E(t,c.length),"+input"),s.stateAfter=null,!0;for(var v=0;v<o.sel.ranges.length;v++){var m=o.sel.ranges[v];if(m.head.line==t&&m.head.ch<c.length){var y=E(t,c.length);gi(o,v,new Ts(y,y));break}}}function _o(e){qs=e}function $o(e,t,r,n,i){var o=e.doc;e.display.shift=!1,n||(n=o.sel);var l=e.state.pasteIncoming||"paste"==i,s=es(t),a=null;if(l&&n.ranges.length>1)if(qs&&qs.text.join("\n")==t){if(n.ranges.length%qs.text.length==0){a=[];for(var u=0;u<qs.text.length;u++)a.push(o.splitLines(qs.text[u]))}}else s.length==n.ranges.length&&e.options.pasteLinesPerSelection&&(a=v(s,function(e){return[e]}));for(var c,f=n.ranges.length-1;f>=0;f--){var h=n.ranges[f],d=h.from(),p=h.to();h.empty()&&(r&&r>0?d=E(d.line,d.ch-r):e.state.overwrite&&!l?p=E(p.line,Math.min(M(o,p.line).text.length,p.ch+g(s).length)):qs&&qs.lineWise&&qs.text.join("\n")==t&&(d=p=E(d.line,0))),c=e.curOp.updateInput;var m={from:d,to:p,text:a?a[f%a.length]:s,origin:i||(l?"paste":e.state.cutIncoming?"cut":"+input")};Oi(e.doc,m),bt(e,"inputRead",e,m)}t&&!l&&Zo(e,t),jr(e),e.curOp.updateInput=c,e.curOp.typing=!0,e.state.pasteIncoming=e.state.cutIncoming=!1}function qo(e,t){var r=e.clipboardData&&e.clipboardData.getData("Text");if(r)return e.preventDefault(),t.isReadOnly()||t.options.disableInput||hn(t,function(){return $o(t,r,0,null,"paste")}),!0}function Zo(e,t){if(e.options.electricChars&&e.options.smartIndent)for(var r=e.doc.sel,n=r.ranges.length-1;n>=0;n--){var i=r.ranges[n];if(!(i.head.ch>100||n&&r.ranges[n-1].head.line==i.head.line)){var o=e.getModeAt(i.head),l=!1;if(o.electricChars){for(var s=0;s<o.electricChars.length;s++)if(t.indexOf(o.electricChars.charAt(s))>-1){l=Yo(e,i.head.line,"smart");break}}else o.electricInput&&o.electricInput.test(M(e.doc,i.head.line).text.slice(0,i.head.ch))&&(l=Yo(e,i.head.line,"smart"));l&&bt(e,"electricInput",e,i.head.line)}}}function Qo(e){for(var t=[],r=[],n=0;n<e.doc.sel.ranges.length;n++){var i=e.doc.sel.ranges[n].head.line,o={anchor:E(i,0),head:E(i+1,0)};r.push(o),t.push(e.getRange(o.anchor,o.head))}return{text:t,ranges:r}}function Jo(e,t){e.setAttribute("autocorrect","off"),e.setAttribute("autocapitalize","off"),e.setAttribute("spellcheck",!!t)}function el(){var e=n("textarea",null,null,"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none"),t=n("div",[e],null,"overflow: hidden; position: relative; width: 3px; height: 0px;");return ml?e.style.width="1000px":e.setAttribute("wrap","off"),Ll&&(e.style.border="1px solid black"),Jo(e),t}function tl(e,t,r,n,i){function o(){var n=t.line+r;return!(n<e.first||n>=e.first+e.size)&&(t=new E(n,t.ch,t.sticky),u=M(e,n))}function l(n){var l;if(null==(l=i?go(e.cm,u,t,r):ho(u,t,r))){if(n||!o())return!1;t=po(i,e.cm,u,t.line,r)}else t=l;return!0}var s=t,a=r,u=M(e,t.line);if("char"==n)l();else if("column"==n)l(!0);else if("word"==n||"group"==n)for(var c=null,f="group"==n,h=e.cm&&e.cm.getHelper(t,"wordChars"),d=!0;!(r<0)||l(!d);d=!1){var p=u.text.charAt(t.ch)||"\n",g=x(p,h)?"w":f&&"\n"==p?"n":!f||/\s/.test(p)?null:"p";if(!f||d||g||(g="s"),c&&c!=g){r<0&&(r=1,l(),t.sticky="after");break}if(g&&(c=g),r>0&&!l(!d))break}var v=ki(e,t,s,a,!0);return I(s,v)&&(v.hitSide=!0),v}function rl(e,t,r,n){var i,o=e.doc,l=t.left;if("page"==n){var s=Math.min(e.display.wrapper.clientHeight,window.innerHeight||document.documentElement.clientHeight),a=Math.max(s-.5*mr(e.display),3);i=(r>0?t.bottom:t.top)+r*a}else"line"==n&&(i=r>0?t.bottom+3:t.top-3);for(var u;(u=cr(e,l,i)).outside;){if(r<0?i<=0:i>=o.height){u.hitSide=!0;break}i+=5*r}return u}function nl(e,t){var r=jt(e,t.line);if(!r||r.hidden)return null;var n=M(e.doc,t.line),i=Ut(r,n,t.line),o=Se(n,e.doc.direction),l="left";o&&(l=Ce(o,t.ch)%2?"right":"left");var s=_t(i.map,t.ch,l);return s.offset="right"==s.collapse?s.end:s.start,s}function il(e){for(var t=e;t;t=t.parentNode)if(/CodeMirror-gutter-wrapper/.test(t.className))return!0;return!1}function ol(e,t){return t&&(e.bad=!0),e}function ll(e,t,r,n,i){function o(e){return function(t){return t.id==e}}function l(){c&&(u+=f,c=!1)}function s(e){e&&(l(),u+=e)}function a(t){if(1==t.nodeType){var r=t.getAttribute("cm-text");if(null!=r)return void s(r||t.textContent.replace(/\u200b/g,""));var u,h=t.getAttribute("cm-marker");if(h){var d=e.findMarks(E(n,0),E(i+1,0),o(+h));return void(d.length&&(u=d[0].find(0))&&s(N(e.doc,u.from,u.to).join(f)))}if("false"==t.getAttribute("contenteditable"))return;var p=/^(pre|div|p)$/i.test(t.nodeName);p&&l();for(var g=0;g<t.childNodes.length;g++)a(t.childNodes[g]);p&&(c=!0)}else 3==t.nodeType&&s(t.nodeValue)}for(var u="",c=!1,f=e.doc.lineSeparator();a(t),t!=r;)t=t.nextSibling;return u}function sl(e,t,r){var n;if(t==e.display.lineDiv){if(!(n=e.display.lineDiv.childNodes[r]))return ol(e.clipPos(E(e.display.viewTo-1)),!0);t=null,r=0}else for(n=t;;n=n.parentNode){if(!n||n==e.display.lineDiv)return null;if(n.parentNode&&n.parentNode==e.display.lineDiv)break}for(var i=0;i<e.display.view.length;i++){var o=e.display.view[i];if(o.node==n)return al(o,t,r)}}function al(e,t,r){function n(t,r,n){for(var i=-1;i<(f?f.length:0);i++)for(var o=i<0?c.map:f[i],l=0;l<o.length;l+=3){var s=o[l+2];if(s==t||s==r){var a=W(i<0?e.line:e.rest[i]),u=o[l]+n;return(n<0||s!=t)&&(u=o[l+(n?1:0)]),E(a,u)}}}var i=e.text.firstChild,l=!1;if(!t||!o(i,t))return ol(E(W(e.line),0),!0);if(t==i&&(l=!0,t=i.childNodes[r],r=0,!t)){var s=e.rest?g(e.rest):e.line;return ol(E(W(s),s.text.length),l)}var a=3==t.nodeType?t:null,u=t;for(a||1!=t.childNodes.length||3!=t.firstChild.nodeType||(a=t.firstChild,r&&(r=a.nodeValue.length));u.parentNode!=i;)u=u.parentNode;var c=e.measure,f=c.maps,h=n(a,u,r);if(h)return ol(h,l);for(var d=u.nextSibling,p=a?a.nodeValue.length-r:0;d;d=d.nextSibling){if(h=n(d,d.firstChild,0))return ol(E(h.line,h.ch-p),l);p+=d.textContent.length}for(var v=u.previousSibling,m=r;v;v=v.previousSibling){if(h=n(v,v.firstChild,-1))return ol(E(h.line,h.ch+m),l);m+=v.textContent.length}}var ul=navigator.userAgent,cl=navigator.platform,fl=/gecko\/\d/i.test(ul),hl=/MSIE \d/.test(ul),dl=/Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(ul),pl=/Edge\/(\d+)/.exec(ul),gl=hl||dl||pl,vl=gl&&(hl?document.documentMode||6:+(pl||dl)[1]),ml=!pl&&/WebKit\//.test(ul),yl=ml&&/Qt\/\d+\.\d+/.test(ul),bl=!pl&&/Chrome\//.test(ul),wl=/Opera\//.test(ul),xl=/Apple Computer/.test(navigator.vendor),Cl=/Mac OS X 1\d\D([8-9]|\d\d)\D/.test(ul),Sl=/PhantomJS/.test(ul),Ll=!pl&&/AppleWebKit/.test(ul)&&/Mobile\/\w+/.test(ul),kl=/Android/.test(ul),Tl=Ll||kl||/webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(ul),Ml=Ll||/Mac/.test(cl),Nl=/\bCrOS\b/.test(ul),Ol=/win/i.test(cl),Al=wl&&ul.match(/Version\/(\d*\.\d*)/);Al&&(Al=Number(Al[1])),Al&&Al>=15&&(wl=!1,ml=!0);var Wl,Dl=Ml&&(yl||wl&&(null==Al||Al<12.11)),Hl=fl||gl&&vl>=9,Fl=function(t,r){var n=t.className,i=e(r).exec(n);if(i){var o=n.slice(i.index+i[0].length);t.className=n.slice(0,i.index)+(o?i[1]+o:"")}};Wl=document.createRange?function(e,t,r,n){var i=document.createRange();return i.setEnd(n||e,r),i.setStart(e,t),i}:function(e,t,r){var n=document.body.createTextRange();try{n.moveToElementText(e.parentNode)}catch(e){return n}return n.collapse(!0),n.moveEnd("character",r),n.moveStart("character",t),n};var El=function(e){e.select()};Ll?El=function(e){e.selectionStart=0,e.selectionEnd=e.value.length}:gl&&(El=function(e){try{e.select()}catch(e){}});var Pl=function(){this.id=null};Pl.prototype.set=function(e,t){clearTimeout(this.id),this.id=setTimeout(t,e)};var Il,zl,Rl=30,Bl={toString:function(){return"CodeMirror.Pass"}},Gl={scroll:!1},Ul={origin:"*mouse"},Vl={origin:"+move"},Kl=[""],jl=/[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/,Xl=/[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/,Yl=!1,_l=!1,$l=null,ql=function(){function e(e){return e<=247?r.charAt(e):1424<=e&&e<=1524?"R":1536<=e&&e<=1785?n.charAt(e-1536):1774<=e&&e<=2220?"r":8192<=e&&e<=8203?"w":8204==e?"b":"L"}function t(e,t,r){this.level=e,this.from=t,this.to=r}var r="bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN",n="nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111",i=/[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/,o=/[stwN]/,l=/[LRr]/,s=/[Lb1n]/,a=/[1n]/;return function(r,n){var u="ltr"==n?"L":"R";if(0==r.length||"ltr"==n&&!i.test(r))return!1;for(var c=r.length,f=[],h=0;h<c;++h)f.push(e(r.charCodeAt(h)));for(var d=0,p=u;d<c;++d){var v=f[d];"m"==v?f[d]=p:p=v}for(var m=0,y=u;m<c;++m){var b=f[m];"1"==b&&"r"==y?f[m]="n":l.test(b)&&(y=b,"r"==b&&(f[m]="R"))}for(var w=1,x=f[0];w<c-1;++w){var C=f[w];"+"==C&&"1"==x&&"1"==f[w+1]?f[w]="1":","!=C||x!=f[w+1]||"1"!=x&&"n"!=x||(f[w]=x),x=C}for(var S=0;S<c;++S){var L=f[S];if(","==L)f[S]="N";else if("%"==L){var k=void 0;for(k=S+1;k<c&&"%"==f[k];++k);for(var T=S&&"!"==f[S-1]||k<c&&"1"==f[k]?"1":"N",M=S;M<k;++M)f[M]=T;S=k-1}}for(var N=0,O=u;N<c;++N){var A=f[N];"L"==O&&"1"==A?f[N]="L":l.test(A)&&(O=A)}for(var W=0;W<c;++W)if(o.test(f[W])){var D=void 0;for(D=W+1;D<c&&o.test(f[D]);++D);for(var H="L"==(W?f[W-1]:u),F=H==("L"==(D<c?f[D]:u))?H?"L":"R":u,E=W;E<D;++E)f[E]=F;W=D-1}for(var P,I=[],z=0;z<c;)if(s.test(f[z])){var R=z;for(++z;z<c&&s.test(f[z]);++z);I.push(new t(0,R,z))}else{var B=z,G=I.length;for(++z;z<c&&"L"!=f[z];++z);for(var U=B;U<z;)if(a.test(f[U])){B<U&&I.splice(G,0,new t(1,B,U));var V=U;for(++U;U<z&&a.test(f[U]);++U);I.splice(G,0,new t(2,V,U)),B=U}else++U;B<z&&I.splice(G,0,new t(1,B,z))}return 1==I[0].level&&(P=r.match(/^\s+/))&&(I[0].from=P[0].length,I.unshift(new t(0,0,P[0].length))),1==g(I).level&&(P=r.match(/\s+$/))&&(g(I).to-=P[0].length,I.push(new t(0,c-P[0].length,c))),"rtl"==n?I.reverse():I}}(),Zl=[],Ql=function(e,t,r){if(e.addEventListener)e.addEventListener(t,r,!1);else if(e.attachEvent)e.attachEvent("on"+t,r);else{var n=e._handlers||(e._handlers={});n[t]=(n[t]||Zl).concat(r)}},Jl=function(){if(gl&&vl<9)return!1;var e=n("div");return"draggable"in e||"dragDrop"in e}(),es=3!="\n\nb".split(/\n/).length?function(e){for(var t=0,r=[],n=e.length;t<=n;){var i=e.indexOf("\n",t);-1==i&&(i=e.length);var o=e.slice(t,"\r"==e.charAt(i-1)?i-1:i),l=o.indexOf("\r");-1!=l?(r.push(o.slice(0,l)),t+=l+1):(r.push(o),t=i+1)}return r}:function(e){return e.split(/\r\n?|\n/)},ts=window.getSelection?function(e){try{return e.selectionStart!=e.selectionEnd}catch(e){return!1}}:function(e){var t;try{t=e.ownerDocument.selection.createRange()}catch(e){}return!(!t||t.parentElement()!=e)&&0!=t.compareEndPoints("StartToEnd",t)},rs=function(){var e=n("div");return"oncopy"in e||(e.setAttribute("oncopy","return;"),"function"==typeof e.oncopy)}(),ns=null,is={},os={},ls={},ss=function(e,t,r){this.pos=this.start=0,this.string=e,this.tabSize=t||8,this.lastColumnPos=this.lastColumnValue=0,this.lineStart=0,this.lineOracle=r};ss.prototype.eol=function(){return this.pos>=this.string.length},ss.prototype.sol=function(){return this.pos==this.lineStart},ss.prototype.peek=function(){return this.string.charAt(this.pos)||void 0},ss.prototype.next=function(){if(this.pos<this.string.length)return this.string.charAt(this.pos++)},ss.prototype.eat=function(e){var t=this.string.charAt(this.pos);if("string"==typeof e?t==e:t&&(e.test?e.test(t):e(t)))return++this.pos,t},ss.prototype.eatWhile=function(e){for(var t=this.pos;this.eat(e););return this.pos>t},ss.prototype.eatSpace=function(){for(var e=this,t=this.pos;/[\s\u00a0]/.test(this.string.charAt(this.pos));)++e.pos;return this.pos>t},ss.prototype.skipToEnd=function(){this.pos=this.string.length},ss.prototype.skipTo=function(e){var t=this.string.indexOf(e,this.pos);if(t>-1)return this.pos=t,!0},ss.prototype.backUp=function(e){this.pos-=e},ss.prototype.column=function(){return this.lastColumnPos<this.start&&(this.lastColumnValue=f(this.string,this.start,this.tabSize,this.lastColumnPos,this.lastColumnValue),this.lastColumnPos=this.start),this.lastColumnValue-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.indentation=function(){return f(this.string,null,this.tabSize)-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.match=function(e,t,r){if("string"!=typeof e){var n=this.string.slice(this.pos).match(e);return n&&n.index>0?null:(n&&!1!==t&&(this.pos+=n[0].length),n)}var i=function(e){return r?e.toLowerCase():e};if(i(this.string.substr(this.pos,e.length))==i(e))return!1!==t&&(this.pos+=e.length),!0},ss.prototype.current=function(){return this.string.slice(this.start,this.pos)},ss.prototype.hideFirstChars=function(e,t){this.lineStart+=e;try{return t()}finally{this.lineStart-=e}},ss.prototype.lookAhead=function(e){var t=this.lineOracle;return t&&t.lookAhead(e)};var as=function(e,t){this.state=e,this.lookAhead=t},us=function(e,t,r,n){this.state=t,this.doc=e,this.line=r,this.maxLookAhead=n||0};us.prototype.lookAhead=function(e){var t=this.doc.getLine(this.line+e);return null!=t&&e>this.maxLookAhead&&(this.maxLookAhead=e),t},us.prototype.nextLine=function(){this.line++,this.maxLookAhead>0&&this.maxLookAhead--},us.fromSaved=function(e,t,r){return t instanceof as?new us(e,Ke(e.mode,t.state),r,t.lookAhead):new us(e,Ke(e.mode,t),r)},us.prototype.save=function(e){var t=!1!==e?Ke(this.doc.mode,this.state):this.state;return this.maxLookAhead>0?new as(t,this.maxLookAhead):t};var cs=function(e,t,r){this.start=e.start,this.end=e.pos,this.string=e.current(),this.type=t||null,this.state=r},fs=function(e,t,r){this.text=e,ne(this,t),this.height=r?r(this):1};fs.prototype.lineNo=function(){return W(this)},Ae(fs);var hs,ds={},ps={},gs=null,vs=null,ms={left:0,right:0,top:0,bottom:0},ys=function(e,t,r){this.cm=r;var i=this.vert=n("div",[n("div",null,null,"min-width: 1px")],"CodeMirror-vscrollbar"),o=this.horiz=n("div",[n("div",null,null,"height: 100%; min-height: 1px")],"CodeMirror-hscrollbar");e(i),e(o),Ql(i,"scroll",function(){i.clientHeight&&t(i.scrollTop,"vertical")}),Ql(o,"scroll",function(){o.clientWidth&&t(o.scrollLeft,"horizontal")}),this.checkedZeroWidth=!1,gl&&vl<8&&(this.horiz.style.minHeight=this.vert.style.minWidth="18px")};ys.prototype.update=function(e){var t=e.scrollWidth>e.clientWidth+1,r=e.scrollHeight>e.clientHeight+1,n=e.nativeBarWidth;if(r){this.vert.style.display="block",this.vert.style.bottom=t?n+"px":"0";var i=e.viewHeight-(t?n:0);this.vert.firstChild.style.height=Math.max(0,e.scrollHeight-e.clientHeight+i)+"px"}else this.vert.style.display="",this.vert.firstChild.style.height="0";if(t){this.horiz.style.display="block",this.horiz.style.right=r?n+"px":"0",this.horiz.style.left=e.barLeft+"px";var o=e.viewWidth-e.barLeft-(r?n:0);this.horiz.firstChild.style.width=Math.max(0,e.scrollWidth-e.clientWidth+o)+"px"}else this.horiz.style.display="",this.horiz.firstChild.style.width="0";return!this.checkedZeroWidth&&e.clientHeight>0&&(0==n&&this.zeroWidthHack(),this.checkedZeroWidth=!0),{right:r?n:0,bottom:t?n:0}},ys.prototype.setScrollLeft=function(e){this.horiz.scrollLeft!=e&&(this.horiz.scrollLeft=e),this.disableHoriz&&this.enableZeroWidthBar(this.horiz,this.disableHoriz,"horiz")},ys.prototype.setScrollTop=function(e){this.vert.scrollTop!=e&&(this.vert.scrollTop=e),this.disableVert&&this.enableZeroWidthBar(this.vert,this.disableVert,"vert")},ys.prototype.zeroWidthHack=function(){var e=Ml&&!Cl?"12px":"18px";this.horiz.style.height=this.vert.style.width=e,this.horiz.style.pointerEvents=this.vert.style.pointerEvents="none",this.disableHoriz=new Pl,this.disableVert=new Pl},ys.prototype.enableZeroWidthBar=function(e,t,r){function n(){var i=e.getBoundingClientRect();("vert"==r?document.elementFromPoint(i.right-1,(i.top+i.bottom)/2):document.elementFromPoint((i.right+i.left)/2,i.bottom-1))!=e?e.style.pointerEvents="none":t.set(1e3,n)}e.style.pointerEvents="auto",t.set(1e3,n)},ys.prototype.clear=function(){var e=this.horiz.parentNode;e.removeChild(this.horiz),e.removeChild(this.vert)};var bs=function(){};bs.prototype.update=function(){return{bottom:0,right:0}},bs.prototype.setScrollLeft=function(){},bs.prototype.setScrollTop=function(){},bs.prototype.clear=function(){};var ws={native:ys,null:bs},xs=0,Cs=function(e,t,r){var n=e.display;this.viewport=t,this.visible=Ir(n,e.doc,t),this.editorIsHidden=!n.wrapper.offsetWidth,this.wrapperHeight=n.wrapper.clientHeight,this.wrapperWidth=n.wrapper.clientWidth,this.oldDisplayWidth=Rt(e),this.force=r,this.dims=br(e),this.events=[]};Cs.prototype.signal=function(e,t){Oe(e,t)&&this.events.push(arguments)},Cs.prototype.finish=function(){for(var e=this,t=0;t<this.events.length;t++)Te.apply(null,e.events[t])};var Ss=0,Ls=null;gl?Ls=-.53:fl?Ls=15:bl?Ls=-.7:xl&&(Ls=-1/3);var ks=function(e,t){this.ranges=e,this.primIndex=t};ks.prototype.primary=function(){return this.ranges[this.primIndex]},ks.prototype.equals=function(e){var t=this;if(e==this)return!0;if(e.primIndex!=this.primIndex||e.ranges.length!=this.ranges.length)return!1;for(var r=0;r<this.ranges.length;r++){var n=t.ranges[r],i=e.ranges[r];if(!I(n.anchor,i.anchor)||!I(n.head,i.head))return!1}return!0},ks.prototype.deepCopy=function(){for(var e=this,t=[],r=0;r<this.ranges.length;r++)t[r]=new Ts(z(e.ranges[r].anchor),z(e.ranges[r].head));return new ks(t,this.primIndex)},ks.prototype.somethingSelected=function(){for(var e=this,t=0;t<this.ranges.length;t++)if(!e.ranges[t].empty())return!0;return!1},ks.prototype.contains=function(e,t){var r=this;t||(t=e);for(var n=0;n<this.ranges.length;n++){var i=r.ranges[n];if(P(t,i.from())>=0&&P(e,i.to())<=0)return n}return-1};var Ts=function(e,t){this.anchor=e,this.head=t};Ts.prototype.from=function(){return B(this.anchor,this.head)},Ts.prototype.to=function(){return R(this.anchor,this.head)},Ts.prototype.empty=function(){return this.head.line==this.anchor.line&&this.head.ch==this.anchor.ch},Bi.prototype={chunkSize:function(){return this.lines.length},removeInner:function(e,t){for(var r=this,n=e,i=e+t;n<i;++n){var o=r.lines[n];r.height-=o.height,ot(o),bt(o,"delete")}this.lines.splice(e,t)},collapse:function(e){e.push.apply(e,this.lines)},insertInner:function(e,t,r){var n=this;this.height+=r,this.lines=this.lines.slice(0,e).concat(t).concat(this.lines.slice(e));for(var i=0;i<t.length;++i)t[i].parent=n},iterN:function(e,t,r){for(var n=this,i=e+t;e<i;++e)if(r(n.lines[e]))return!0}},Gi.prototype={chunkSize:function(){return this.size},removeInner:function(e,t){var r=this;this.size-=t;for(var n=0;n<this.children.length;++n){var i=r.children[n],o=i.chunkSize();if(e<o){var l=Math.min(t,o-e),s=i.height;if(i.removeInner(e,l),r.height-=s-i.height,o==l&&(r.children.splice(n--,1),i.parent=null),0==(t-=l))break;e=0}else e-=o}if(this.size-t<25&&(this.children.length>1||!(this.children[0]instanceof Bi))){var a=[];this.collapse(a),this.children=[new Bi(a)],this.children[0].parent=this}},collapse:function(e){for(var t=this,r=0;r<this.children.length;++r)t.children[r].collapse(e)},insertInner:function(e,t,r){var n=this;this.size+=t.length,this.height+=r;for(var i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<=l){if(o.insertInner(e,t,r),o.lines&&o.lines.length>50){for(var s=o.lines.length%25+25,a=s;a<o.lines.length;){var u=new Bi(o.lines.slice(a,a+=25));o.height-=u.height,n.children.splice(++i,0,u),u.parent=n}o.lines=o.lines.slice(0,s),n.maybeSpill()}break}e-=l}},maybeSpill:function(){if(!(this.children.length<=10)){var e=this;do{var t=new Gi(e.children.splice(e.children.length-5,5));if(e.parent){e.size-=t.size,e.height-=t.height;var r=h(e.parent.children,e);e.parent.children.splice(r+1,0,t)}else{var n=new Gi(e.children);n.parent=e,e.children=[n,t],e=n}t.parent=e.parent}while(e.children.length>10);e.parent.maybeSpill()}},iterN:function(e,t,r){for(var n=this,i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<l){var s=Math.min(t,l-e);if(o.iterN(e,s,r))return!0;if(0==(t-=s))break;e=0}else e-=l}}};var Ms=function(e,t,r){var n=this;if(r)for(var i in r)r.hasOwnProperty(i)&&(n[i]=r[i]);this.doc=e,this.node=t};Ms.prototype.clear=function(){var e=this,t=this.doc.cm,r=this.line.widgets,n=this.line,i=W(n);if(null!=i&&r){for(var o=0;o<r.length;++o)r[o]==e&&r.splice(o--,1);r.length||(n.widgets=null);var l=Ht(this);A(n,Math.max(0,n.height-l)),t&&(hn(t,function(){Ui(t,n,-l),mn(t,i,"widget")}),bt(t,"lineWidgetCleared",t,this,i))}},Ms.prototype.changed=function(){var e=this,t=this.height,r=this.doc.cm,n=this.line;this.height=null;var i=Ht(this)-t;i&&(A(n,n.height+i),r&&hn(r,function(){r.curOp.forceUpdate=!0,Ui(r,n,i),bt(r,"lineWidgetChanged",r,e,W(n))}))},Ae(Ms);var Ns=0,Os=function(e,t){this.lines=[],this.type=t,this.doc=e,this.id=++Ns};Os.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){var t=this.doc.cm,r=t&&!t.curOp;if(r&&nn(t),Oe(this,"clear")){var n=this.find();n&&bt(this,"clear",n.from,n.to)}for(var i=null,o=null,l=0;l<this.lines.length;++l){var s=e.lines[l],a=_(s.markedSpans,e);t&&!e.collapsed?mn(t,W(s),"text"):t&&(null!=a.to&&(o=W(s)),null!=a.from&&(i=W(s))),s.markedSpans=$(s.markedSpans,a),null==a.from&&e.collapsed&&!ve(e.doc,s)&&t&&A(s,mr(t.display))}if(t&&this.collapsed&&!t.options.lineWrapping)for(var u=0;u<this.lines.length;++u){var c=fe(e.lines[u]),f=be(c);f>t.display.maxLineLength&&(t.display.maxLine=c,t.display.maxLineLength=f,t.display.maxLineChanged=!0)}null!=i&&t&&this.collapsed&&vn(t,i,o+1),this.lines.length=0,this.explicitlyCleared=!0,this.atomic&&this.doc.cantEdit&&(this.doc.cantEdit=!1,t&&Ci(t.doc)),t&&bt(t,"markerCleared",t,this,i,o),r&&on(t),this.parent&&this.parent.clear()}},Os.prototype.find=function(e,t){var r=this;null==e&&"bookmark"==this.type&&(e=1);for(var n,i,o=0;o<this.lines.length;++o){var l=r.lines[o],s=_(l.markedSpans,r);if(null!=s.from&&(n=E(t?l:W(l),s.from),-1==e))return n;if(null!=s.to&&(i=E(t?l:W(l),s.to),1==e))return i}return n&&{from:n,to:i}},Os.prototype.changed=function(){var e=this,t=this.find(-1,!0),r=this,n=this.doc.cm;t&&n&&hn(n,function(){var i=t.line,o=W(t.line),l=jt(n,o);if(l&&(Qt(l),n.curOp.selectionChanged=n.curOp.forceUpdate=!0),n.curOp.updateMaxLine=!0,!ve(r.doc,i)&&null!=r.height){var s=r.height;r.height=null;var a=Ht(r)-s;a&&A(i,i.height+a)}bt(n,"markerChanged",n,e)})},Os.prototype.attachLine=function(e){if(!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;t.maybeHiddenMarkers&&-1!=h(t.maybeHiddenMarkers,this)||(t.maybeUnhiddenMarkers||(t.maybeUnhiddenMarkers=[])).push(this)}this.lines.push(e)},Os.prototype.detachLine=function(e){if(this.lines.splice(h(this.lines,e),1),!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;(t.maybeHiddenMarkers||(t.maybeHiddenMarkers=[])).push(this)}},Ae(Os);var As=function(e,t){var r=this;this.markers=e,this.primary=t;for(var n=0;n<e.length;++n)e[n].parent=r};As.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){this.explicitlyCleared=!0;for(var t=0;t<this.markers.length;++t)e.markers[t].clear();bt(this,"clear")}},As.prototype.find=function(e,t){return this.primary.find(e,t)},Ae(As);var Ws=0,Ds=function(e,t,r,n,i){if(!(this instanceof Ds))return new Ds(e,t,r,n,i);null==r&&(r=0),Gi.call(this,[new Bi([new fs("",null)])]),this.first=r,this.scrollTop=this.scrollLeft=0,this.cantEdit=!1,this.cleanGeneration=1,this.modeFrontier=this.highlightFrontier=r;var o=E(r,0);this.sel=Rn(o),this.history=new Jn(null),this.id=++Ws,this.modeOption=t,this.lineSep=n,this.direction="rtl"==i?"rtl":"ltr",this.extend=!1,"string"==typeof e&&(e=this.splitLines(e)),_n(this,{from:o,to:o,text:e}),bi(this,Rn(o),Gl)};Ds.prototype=b(Gi.prototype,{constructor:Ds,iter:function(e,t,r){r?this.iterN(e-this.first,t-e,r):this.iterN(this.first,this.first+this.size,e)},insert:function(e,t){for(var r=0,n=0;n<t.length;++n)r+=t[n].height;this.insertInner(e-this.first,t,r)},remove:function(e,t){this.removeInner(e-this.first,t)},getValue:function(e){var t=O(this,this.first,this.first+this.size);return!1===e?t:t.join(e||this.lineSeparator())},setValue:gn(function(e){var t=E(this.first,0),r=this.first+this.size-1;Oi(this,{from:t,to:E(r,M(this,r).text.length),text:this.splitLines(e),origin:"setValue",full:!0},!0),this.cm&&Xr(this.cm,0,0),bi(this,Rn(t),Gl)}),replaceRange:function(e,t,r,n){Ei(this,e,t=U(this,t),r=r?U(this,r):t,n)},getRange:function(e,t,r){var n=N(this,U(this,e),U(this,t));return!1===r?n:n.join(r||this.lineSeparator())},getLine:function(e){var t=this.getLineHandle(e);return t&&t.text},getLineHandle:function(e){if(H(this,e))return M(this,e)},getLineNumber:function(e){return W(e)},getLineHandleVisualStart:function(e){return"number"==typeof e&&(e=M(this,e)),fe(e)},lineCount:function(){return this.size},firstLine:function(){return this.first},lastLine:function(){return this.first+this.size-1},clipPos:function(e){return U(this,e)},getCursor:function(e){var t=this.sel.primary();return null==e||"head"==e?t.head:"anchor"==e?t.anchor:"end"==e||"to"==e||!1===e?t.to():t.from()},listSelections:function(){return this.sel.ranges},somethingSelected:function(){return this.sel.somethingSelected()},setCursor:gn(function(e,t,r){vi(this,U(this,"number"==typeof e?E(e,t||0):e),null,r)}),setSelection:gn(function(e,t,r){vi(this,U(this,e),U(this,t||e),r)}),extendSelection:gn(function(e,t,r){di(this,U(this,e),t&&U(this,t),r)}),extendSelections:gn(function(e,t){pi(this,K(this,e),t)}),extendSelectionsBy:gn(function(e,t){pi(this,K(this,v(this.sel.ranges,e)),t)}),setSelections:gn(function(e,t,r){var n=this;if(e.length){for(var i=[],o=0;o<e.length;o++)i[o]=new Ts(U(n,e[o].anchor),U(n,e[o].head));null==t&&(t=Math.min(e.length-1,this.sel.primIndex)),bi(this,zn(i,t),r)}}),addSelection:gn(function(e,t,r){var n=this.sel.ranges.slice(0);n.push(new Ts(U(this,e),U(this,t||e))),bi(this,zn(n,n.length-1),r)}),getSelection:function(e){for(var t,r=this,n=this.sel.ranges,i=0;i<n.length;i++){var o=N(r,n[i].from(),n[i].to());t=t?t.concat(o):o}return!1===e?t:t.join(e||this.lineSeparator())},getSelections:function(e){for(var t=this,r=[],n=this.sel.ranges,i=0;i<n.length;i++){var o=N(t,n[i].from(),n[i].to());!1!==e&&(o=o.join(e||t.lineSeparator())),r[i]=o}return r},replaceSelection:function(e,t,r){for(var n=[],i=0;i<this.sel.ranges.length;i++)n[i]=e;this.replaceSelections(n,t,r||"+input")},replaceSelections:gn(function(e,t,r){for(var n=this,i=[],o=this.sel,l=0;l<o.ranges.length;l++){var s=o.ranges[l];i[l]={from:s.from(),to:s.to(),text:n.splitLines(e[l]),origin:r}}for(var a=t&&"end"!=t&&Kn(this,i,t),u=i.length-1;u>=0;u--)Oi(n,i[u]);a?yi(this,a):this.cm&&jr(this.cm)}),undo:gn(function(){Wi(this,"undo")}),redo:gn(function(){Wi(this,"redo")}),undoSelection:gn(function(){Wi(this,"undo",!0)}),redoSelection:gn(function(){Wi(this,"redo",!0)}),setExtending:function(e){this.extend=e},getExtending:function(){return this.extend},historySize:function(){for(var e=this.history,t=0,r=0,n=0;n<e.done.length;n++)e.done[n].ranges||++t;for(var i=0;i<e.undone.length;i++)e.undone[i].ranges||++r;return{undo:t,redo:r}},clearHistory:function(){this.history=new Jn(this.history.maxGeneration)},markClean:function(){this.cleanGeneration=this.changeGeneration(!0)},changeGeneration:function(e){return e&&(this.history.lastOp=this.history.lastSelOp=this.history.lastOrigin=null),this.history.generation},isClean:function(e){return this.history.generation==(e||this.cleanGeneration)},getHistory:function(){return{done:fi(this.history.done),undone:fi(this.history.undone)}},setHistory:function(e){var t=this.history=new Jn(this.history.maxGeneration);t.done=fi(e.done.slice(0),null,!0),t.undone=fi(e.undone.slice(0),null,!0)},setGutterMarker:gn(function(e,t,r){return Ri(this,e,"gutter",function(e){var n=e.gutterMarkers||(e.gutterMarkers={});return n[t]=r,!r&&C(n)&&(e.gutterMarkers=null),!0})}),clearGutter:gn(function(e){var t=this;this.iter(function(r){r.gutterMarkers&&r.gutterMarkers[e]&&Ri(t,r,"gutter",function(){return r.gutterMarkers[e]=null,C(r.gutterMarkers)&&(r.gutterMarkers=null),!0})})}),lineInfo:function(e){var t;if("number"==typeof e){if(!H(this,e))return null;if(t=e,!(e=M(this,e)))return null}else if(null==(t=W(e)))return null;return{line:t,handle:e,text:e.text,gutterMarkers:e.gutterMarkers,textClass:e.textClass,bgClass:e.bgClass,wrapClass:e.wrapClass,widgets:e.widgets}},addLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass";if(t[i]){if(e(n).test(t[i]))return!1;t[i]+=" "+n}else t[i]=n;return!0})}),removeLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass",o=t[i];if(!o)return!1;if(null==n)t[i]=null;else{var l=o.match(e(n));if(!l)return!1;var s=l.index+l[0].length;t[i]=o.slice(0,l.index)+(l.index&&s!=o.length?" ":"")+o.slice(s)||null}return!0})}),addLineWidget:gn(function(e,t,r){return Vi(this,e,t,r)}),removeLineWidget:function(e){e.clear()},markText:function(e,t,r){return Ki(this,U(this,e),U(this,t),r,r&&r.type||"range")},setBookmark:function(e,t){var r={replacedWith:t&&(null==t.nodeType?t.widget:t),insertLeft:t&&t.insertLeft,clearWhenEmpty:!1,shared:t&&t.shared,handleMouseEvents:t&&t.handleMouseEvents};return e=U(this,e),Ki(this,e,e,r,"bookmark")},findMarksAt:function(e){var t=[],r=M(this,(e=U(this,e)).line).markedSpans;if(r)for(var n=0;n<r.length;++n){var i=r[n];(null==i.from||i.from<=e.ch)&&(null==i.to||i.to>=e.ch)&&t.push(i.marker.parent||i.marker)}return t},findMarks:function(e,t,r){e=U(this,e),t=U(this,t);var n=[],i=e.line;return this.iter(e.line,t.line+1,function(o){var l=o.markedSpans;if(l)for(var s=0;s<l.length;s++){var a=l[s];null!=a.to&&i==e.line&&e.ch>=a.to||null==a.from&&i!=e.line||null!=a.from&&i==t.line&&a.from>=t.ch||r&&!r(a.marker)||n.push(a.marker.parent||a.marker)}++i}),n},getAllMarks:function(){var e=[];return this.iter(function(t){var r=t.markedSpans;if(r)for(var n=0;n<r.length;++n)null!=r[n].from&&e.push(r[n].marker)}),e},posFromIndex:function(e){var t,r=this.first,n=this.lineSeparator().length;return this.iter(function(i){var o=i.text.length+n;if(o>e)return t=e,!0;e-=o,++r}),U(this,E(r,t))},indexFromPos:function(e){var t=(e=U(this,e)).ch;if(e.line<this.first||e.ch<0)return 0;var r=this.lineSeparator().length;return this.iter(this.first,e.line,function(e){t+=e.text.length+r}),t},copy:function(e){var t=new Ds(O(this,this.first,this.first+this.size),this.modeOption,this.first,this.lineSep,this.direction);return t.scrollTop=this.scrollTop,t.scrollLeft=this.scrollLeft,t.sel=this.sel,t.extend=!1,e&&(t.history.undoDepth=this.history.undoDepth,t.setHistory(this.getHistory())),t},linkedDoc:function(e){e||(e={});var t=this.first,r=this.first+this.size;null!=e.from&&e.from>t&&(t=e.from),null!=e.to&&e.to<r&&(r=e.to);var n=new Ds(O(this,t,r),e.mode||this.modeOption,t,this.lineSep,this.direction);return e.sharedHist&&(n.history=this.history),(this.linked||(this.linked=[])).push({doc:n,sharedHist:e.sharedHist}),n.linked=[{doc:this,isParent:!0,sharedHist:e.sharedHist}],Yi(n,Xi(this)),n},unlinkDoc:function(e){var t=this;if(e instanceof jo&&(e=e.doc),this.linked)for(var r=0;r<this.linked.length;++r)if(t.linked[r].doc==e){t.linked.splice(r,1),e.unlinkDoc(t),_i(Xi(t));break}if(e.history==this.history){var n=[e.id];$n(e,function(e){return n.push(e.id)},!0),e.history=new Jn(null),e.history.done=fi(this.history.done,n),e.history.undone=fi(this.history.undone,n)}},iterLinkedDocs:function(e){$n(this,e)},getMode:function(){return this.mode},getEditor:function(){return this.cm},splitLines:function(e){return this.lineSep?e.split(this.lineSep):es(e)},lineSeparator:function(){return this.lineSep||"\n"},setDirection:gn(function(e){"rtl"!=e&&(e="ltr"),e!=this.direction&&(this.direction=e,this.iter(function(e){return e.order=null}),this.cm&&Qn(this.cm))})}),Ds.prototype.eachLine=Ds.prototype.iter;for(var Hs=0,Fs=!1,Es={3:"Enter",8:"Backspace",9:"Tab",13:"Enter",16:"Shift",17:"Ctrl",18:"Alt",19:"Pause",20:"CapsLock",27:"Esc",32:"Space",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"Left",38:"Up",39:"Right",40:"Down",44:"PrintScrn",45:"Insert",46:"Delete",59:";",61:"=",91:"Mod",92:"Mod",93:"Mod",106:"*",107:"=",109:"-",110:".",111:"/",127:"Delete",173:"-",186:";",187:"=",188:",",189:"-",190:".",191:"/",192:"`",219:"[",220:"\\",221:"]",222:"'",63232:"Up",63233:"Down",63234:"Left",63235:"Right",63272:"Delete",63273:"Home",63275:"End",63276:"PageUp",63277:"PageDown",63302:"Insert"},Ps=0;Ps<10;Ps++)Es[Ps+48]=Es[Ps+96]=String(Ps);for(var Is=65;Is<=90;Is++)Es[Is]=String.fromCharCode(Is);for(var zs=1;zs<=12;zs++)Es[zs+111]=Es[zs+63235]="F"+zs;var Rs={};Rs.basic={Left:"goCharLeft",Right:"goCharRight",Up:"goLineUp",Down:"goLineDown",End:"goLineEnd",Home:"goLineStartSmart",PageUp:"goPageUp",PageDown:"goPageDown",Delete:"delCharAfter",Backspace:"delCharBefore","Shift-Backspace":"delCharBefore",Tab:"defaultTab","Shift-Tab":"indentAuto",Enter:"newlineAndIndent",Insert:"toggleOverwrite",Esc:"singleSelection"},Rs.pcDefault={"Ctrl-A":"selectAll","Ctrl-D":"deleteLine","Ctrl-Z":"undo","Shift-Ctrl-Z":"redo","Ctrl-Y":"redo","Ctrl-Home":"goDocStart","Ctrl-End":"goDocEnd","Ctrl-Up":"goLineUp","Ctrl-Down":"goLineDown","Ctrl-Left":"goGroupLeft","Ctrl-Right":"goGroupRight","Alt-Left":"goLineStart","Alt-Right":"goLineEnd","Ctrl-Backspace":"delGroupBefore","Ctrl-Delete":"delGroupAfter","Ctrl-S":"save","Ctrl-F":"find","Ctrl-G":"findNext","Shift-Ctrl-G":"findPrev","Shift-Ctrl-F":"replace","Shift-Ctrl-R":"replaceAll","Ctrl-[":"indentLess","Ctrl-]":"indentMore","Ctrl-U":"undoSelection","Shift-Ctrl-U":"redoSelection","Alt-U":"redoSelection",fallthrough:"basic"},Rs.emacsy={"Ctrl-F":"goCharRight","Ctrl-B":"goCharLeft","Ctrl-P":"goLineUp","Ctrl-N":"goLineDown","Alt-F":"goWordRight","Alt-B":"goWordLeft","Ctrl-A":"goLineStart","Ctrl-E":"goLineEnd","Ctrl-V":"goPageDown","Shift-Ctrl-V":"goPageUp","Ctrl-D":"delCharAfter","Ctrl-H":"delCharBefore","Alt-D":"delWordAfter","Alt-Backspace":"delWordBefore","Ctrl-K":"killLine","Ctrl-T":"transposeChars","Ctrl-O":"openLine"},Rs.macDefault={"Cmd-A":"selectAll","Cmd-D":"deleteLine","Cmd-Z":"undo","Shift-Cmd-Z":"redo","Cmd-Y":"redo","Cmd-Home":"goDocStart","Cmd-Up":"goDocStart","Cmd-End":"goDocEnd","Cmd-Down":"goDocEnd","Alt-Left":"goGroupLeft","Alt-Right":"goGroupRight","Cmd-Left":"goLineLeft","Cmd-Right":"goLineRight","Alt-Backspace":"delGroupBefore","Ctrl-Alt-Backspace":"delGroupAfter","Alt-Delete":"delGroupAfter","Cmd-S":"save","Cmd-F":"find","Cmd-G":"findNext","Shift-Cmd-G":"findPrev","Cmd-Alt-F":"replace","Shift-Cmd-Alt-F":"replaceAll","Cmd-[":"indentLess","Cmd-]":"indentMore","Cmd-Backspace":"delWrappedLineLeft","Cmd-Delete":"delWrappedLineRight","Cmd-U":"undoSelection","Shift-Cmd-U":"redoSelection","Ctrl-Up":"goDocStart","Ctrl-Down":"goDocEnd",fallthrough:["basic","emacsy"]},Rs.default=Ml?Rs.macDefault:Rs.pcDefault;var Bs={selectAll:Mi,singleSelection:function(e){return e.setSelection(e.getCursor("anchor"),e.getCursor("head"),Gl)},killLine:function(e){return co(e,function(t){if(t.empty()){var r=M(e.doc,t.head.line).text.length;return t.head.ch==r&&t.head.line<e.lastLine()?{from:t.head,to:E(t.head.line+1,0)}:{from:t.head,to:E(t.head.line,r)}}return{from:t.from(),to:t.to()}})},deleteLine:function(e){return co(e,function(t){return{from:E(t.from().line,0),to:U(e.doc,E(t.to().line+1,0))}})},delLineLeft:function(e){return co(e,function(e){return{from:E(e.from().line,0),to:e.from()}})},delWrappedLineLeft:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5;return{from:e.coordsChar({left:0,top:r},"div"),to:t.from()}})},delWrappedLineRight:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5,n=e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div");return{from:t.from(),to:n}})},undo:function(e){return e.undo()},redo:function(e){return e.redo()},undoSelection:function(e){return e.undoSelection()},redoSelection:function(e){return e.redoSelection()},goDocStart:function(e){return e.extendSelection(E(e.firstLine(),0))},goDocEnd:function(e){return e.extendSelection(E(e.lastLine()))},goLineStart:function(e){return e.extendSelectionsBy(function(t){return vo(e,t.head.line)},{origin:"+move",bias:1})},goLineStartSmart:function(e){return e.extendSelectionsBy(function(t){return yo(e,t.head)},{origin:"+move",bias:1})},goLineEnd:function(e){return e.extendSelectionsBy(function(t){return mo(e,t.head.line)},{origin:"+move",bias:-1})},goLineRight:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div")},Vl)},goLineLeft:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:0,top:r},"div")},Vl)},goLineLeftSmart:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5,n=e.coordsChar({left:0,top:r},"div");return n.ch<e.getLine(n.line).search(/\S/)?yo(e,t.head):n},Vl)},goLineUp:function(e){return e.moveV(-1,"line")},goLineDown:function(e){return e.moveV(1,"line")},goPageUp:function(e){return e.moveV(-1,"page")},goPageDown:function(e){return e.moveV(1,"page")},goCharLeft:function(e){return e.moveH(-1,"char")},goCharRight:function(e){return e.moveH(1,"char")},goColumnLeft:function(e){return e.moveH(-1,"column")},goColumnRight:function(e){return e.moveH(1,"column")},goWordLeft:function(e){return e.moveH(-1,"word")},goGroupRight:function(e){return e.moveH(1,"group")},goGroupLeft:function(e){return e.moveH(-1,"group")},goWordRight:function(e){return e.moveH(1,"word")},delCharBefore:function(e){return e.deleteH(-1,"char")},delCharAfter:function(e){return e.deleteH(1,"char")},delWordBefore:function(e){return e.deleteH(-1,"word")},delWordAfter:function(e){return e.deleteH(1,"word")},delGroupBefore:function(e){return e.deleteH(-1,"group")},delGroupAfter:function(e){return e.deleteH(1,"group")},indentAuto:function(e){return e.indentSelection("smart")},indentMore:function(e){return e.indentSelection("add")},indentLess:function(e){return e.indentSelection("subtract")},insertTab:function(e){return e.replaceSelection("\t")},insertSoftTab:function(e){for(var t=[],r=e.listSelections(),n=e.options.tabSize,i=0;i<r.length;i++){var o=r[i].from(),l=f(e.getLine(o.line),o.ch,n);t.push(p(n-l%n))}e.replaceSelections(t)},defaultTab:function(e){e.somethingSelected()?e.indentSelection("add"):e.execCommand("insertTab")},transposeChars:function(e){return hn(e,function(){for(var t=e.listSelections(),r=[],n=0;n<t.length;n++)if(t[n].empty()){var i=t[n].head,o=M(e.doc,i.line).text;if(o)if(i.ch==o.length&&(i=new E(i.line,i.ch-1)),i.ch>0)i=new E(i.line,i.ch+1),e.replaceRange(o.charAt(i.ch-1)+o.charAt(i.ch-2),E(i.line,i.ch-2),i,"+transpose");else if(i.line>e.doc.first){var l=M(e.doc,i.line-1).text;l&&(i=new E(i.line,1),e.replaceRange(o.charAt(0)+e.doc.lineSeparator()+l.charAt(l.length-1),E(i.line-1,l.length-1),i,"+transpose"))}r.push(new Ts(i,i))}e.setSelections(r)})},newlineAndIndent:function(e){return hn(e,function(){for(var t=e.listSelections(),r=t.length-1;r>=0;r--)e.replaceRange(e.doc.lineSeparator(),t[r].anchor,t[r].head,"+input");t=e.listSelections();for(var n=0;n<t.length;n++)e.indentLine(t[n].from().line,null,!0);jr(e)})},openLine:function(e){return e.replaceSelection("\n","start")},toggleOverwrite:function(e){return e.toggleOverwrite()}},Gs=new Pl,Us=null,Vs=function(e,t,r){this.time=e,this.pos=t,this.button=r};Vs.prototype.compare=function(e,t,r){return this.time+400>e&&0==P(t,this.pos)&&r==this.button};var Ks,js,Xs={toString:function(){return"CodeMirror.Init"}},Ys={},_s={};jo.defaults=Ys,jo.optionHandlers=_s;var $s=[];jo.defineInitHook=function(e){return $s.push(e)};var qs=null,Zs=function(e){this.cm=e,this.lastAnchorNode=this.lastAnchorOffset=this.lastFocusNode=this.lastFocusOffset=null,this.polling=new Pl,this.composing=null,this.gracePeriod=!1,this.readDOMTimeout=null};Zs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()}),"cut"==e.type&&i.replaceSelection("",null,"cut");else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type&&i.operation(function(){i.setSelections(t.ranges,0,Gl),i.replaceSelection("",null,"cut")})}if(e.clipboardData){e.clipboardData.clearData();var r=qs.text.join("\n");if(e.clipboardData.setData("Text",r),e.clipboardData.getData("Text")==r)return void e.preventDefault()}var l=el(),s=l.firstChild;i.display.lineSpace.insertBefore(l,i.display.lineSpace.firstChild),s.value=qs.text.join("\n");var a=document.activeElement;El(s),setTimeout(function(){i.display.lineSpace.removeChild(l),a.focus(),a==o&&n.showPrimarySelection()},50)}}var r=this,n=this,i=n.cm,o=n.div=e.lineDiv;Jo(o,i.options.spellcheck),Ql(o,"paste",function(e){Me(i,e)||qo(e,i)||vl<=11&&setTimeout(dn(i,function(){return r.updateFromDOM()}),20)}),Ql(o,"compositionstart",function(e){r.composing={data:e.data,done:!1}}),Ql(o,"compositionupdate",function(e){r.composing||(r.composing={data:e.data,done:!1})}),Ql(o,"compositionend",function(e){r.composing&&(e.data!=r.composing.data&&r.readFromDOMSoon(),r.composing.done=!0)}),Ql(o,"touchstart",function(){return n.forceCompositionEnd()}),Ql(o,"input",function(){r.composing||r.readFromDOMSoon()}),Ql(o,"copy",t),Ql(o,"cut",t)},Zs.prototype.prepareSelection=function(){var e=Tr(this.cm,!1);return e.focus=this.cm.state.focused,e},Zs.prototype.showSelection=function(e,t){e&&this.cm.display.view.length&&((e.focus||t)&&this.showPrimarySelection(),this.showMultipleSelections(e))},Zs.prototype.showPrimarySelection=function(){var e=window.getSelection(),t=this.cm,r=t.doc.sel.primary(),n=r.from(),i=r.to();if(t.display.viewTo==t.display.viewFrom||n.line>=t.display.viewTo||i.line<t.display.viewFrom)e.removeAllRanges();else{var o=sl(t,e.anchorNode,e.anchorOffset),l=sl(t,e.focusNode,e.focusOffset);if(!o||o.bad||!l||l.bad||0!=P(B(o,l),n)||0!=P(R(o,l),i)){var s=t.display.view,a=n.line>=t.display.viewFrom&&nl(t,n)||{node:s[0].measure.map[2],offset:0},u=i.line<t.display.viewTo&&nl(t,i);if(!u){var c=s[s.length-1].measure,f=c.maps?c.maps[c.maps.length-1]:c.map;u={node:f[f.length-1],offset:f[f.length-2]-f[f.length-3]}}if(a&&u){var h,d=e.rangeCount&&e.getRangeAt(0);try{h=Wl(a.node,a.offset,u.offset,u.node)}catch(e){}h&&(!fl&&t.state.focused?(e.collapse(a.node,a.offset),h.collapsed||(e.removeAllRanges(),e.addRange(h))):(e.removeAllRanges(),e.addRange(h)),d&&null==e.anchorNode?e.addRange(d):fl&&this.startGracePeriod()),this.rememberSelection()}else e.removeAllRanges()}}},Zs.prototype.startGracePeriod=function(){var e=this;clearTimeout(this.gracePeriod),this.gracePeriod=setTimeout(function(){e.gracePeriod=!1,e.selectionChanged()&&e.cm.operation(function(){return e.cm.curOp.selectionChanged=!0})},20)},Zs.prototype.showMultipleSelections=function(e){r(this.cm.display.cursorDiv,e.cursors),r(this.cm.display.selectionDiv,e.selection)},Zs.prototype.rememberSelection=function(){var e=window.getSelection();this.lastAnchorNode=e.anchorNode,this.lastAnchorOffset=e.anchorOffset,this.lastFocusNode=e.focusNode,this.lastFocusOffset=e.focusOffset},Zs.prototype.selectionInEditor=function(){var e=window.getSelection();if(!e.rangeCount)return!1;var t=e.getRangeAt(0).commonAncestorContainer;return o(this.div,t)},Zs.prototype.focus=function(){"nocursor"!=this.cm.options.readOnly&&(this.selectionInEditor()||this.showSelection(this.prepareSelection(),!0),this.div.focus())},Zs.prototype.blur=function(){this.div.blur()},Zs.prototype.getField=function(){return this.div},Zs.prototype.supportsTouch=function(){return!0},Zs.prototype.receivedFocus=function(){function e(){t.cm.state.focused&&(t.pollSelection(),t.polling.set(t.cm.options.pollInterval,e))}var t=this;this.selectionInEditor()?this.pollSelection():hn(this.cm,function(){return t.cm.curOp.selectionChanged=!0}),this.polling.set(this.cm.options.pollInterval,e)},Zs.prototype.selectionChanged=function(){var e=window.getSelection();return e.anchorNode!=this.lastAnchorNode||e.anchorOffset!=this.lastAnchorOffset||e.focusNode!=this.lastFocusNode||e.focusOffset!=this.lastFocusOffset},Zs.prototype.pollSelection=function(){if(null==this.readDOMTimeout&&!this.gracePeriod&&this.selectionChanged()){var e=window.getSelection(),t=this.cm;if(kl&&bl&&this.cm.options.gutters.length&&il(e.anchorNode))return this.cm.triggerOnKeyDown({type:"keydown",keyCode:8,preventDefault:Math.abs}),this.blur(),void this.focus();if(!this.composing){this.rememberSelection();var r=sl(t,e.anchorNode,e.anchorOffset),n=sl(t,e.focusNode,e.focusOffset);r&&n&&hn(t,function(){bi(t.doc,Rn(r,n),Gl),(r.bad||n.bad)&&(t.curOp.selectionChanged=!0)})}}},Zs.prototype.pollContent=function(){null!=this.readDOMTimeout&&(clearTimeout(this.readDOMTimeout),this.readDOMTimeout=null);var e=this.cm,t=e.display,r=e.doc.sel.primary(),n=r.from(),i=r.to();if(0==n.ch&&n.line>e.firstLine()&&(n=E(n.line-1,M(e.doc,n.line-1).length)),i.ch==M(e.doc,i.line).text.length&&i.line<e.lastLine()&&(i=E(i.line+1,0)),n.line<t.viewFrom||i.line>t.viewTo-1)return!1;var o,l,s;n.line==t.viewFrom||0==(o=Lr(e,n.line))?(l=W(t.view[0].line),s=t.view[0].node):(l=W(t.view[o].line),s=t.view[o-1].node.nextSibling);var a,u,c=Lr(e,i.line);if(c==t.view.length-1?(a=t.viewTo-1,u=t.lineDiv.lastChild):(a=W(t.view[c+1].line)-1,u=t.view[c+1].node.previousSibling),!s)return!1;for(var f=e.doc.splitLines(ll(e,s,u,l,a)),h=N(e.doc,E(l,0),E(a,M(e.doc,a).text.length));f.length>1&&h.length>1;)if(g(f)==g(h))f.pop(),h.pop(),a--;else{if(f[0]!=h[0])break;f.shift(),h.shift(),l++}for(var d=0,p=0,v=f[0],m=h[0],y=Math.min(v.length,m.length);d<y&&v.charCodeAt(d)==m.charCodeAt(d);)++d;for(var b=g(f),w=g(h),x=Math.min(b.length-(1==f.length?d:0),w.length-(1==h.length?d:0));p<x&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)++p;if(1==f.length&&1==h.length&&l==n.line)for(;d&&d>n.ch&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)d--,p++;f[f.length-1]=b.slice(0,b.length-p).replace(/^\u200b+/,""),f[0]=f[0].slice(d).replace(/\u200b+$/,"");var C=E(l,d),S=E(a,h.length?g(h).length-p:0);return f.length>1||f[0]||P(C,S)?(Ei(e.doc,f,C,S,"+input"),!0):void 0},Zs.prototype.ensurePolled=function(){this.forceCompositionEnd()},Zs.prototype.reset=function(){this.forceCompositionEnd()},Zs.prototype.forceCompositionEnd=function(){this.composing&&(clearTimeout(this.readDOMTimeout),this.composing=null,this.updateFromDOM(),this.div.blur(),this.div.focus())},Zs.prototype.readFromDOMSoon=function(){var e=this;null==this.readDOMTimeout&&(this.readDOMTimeout=setTimeout(function(){if(e.readDOMTimeout=null,e.composing){if(!e.composing.done)return;e.composing=null}e.updateFromDOM()},80))},Zs.prototype.updateFromDOM=function(){var e=this;!this.cm.isReadOnly()&&this.pollContent()||hn(this.cm,function(){return vn(e.cm)})},Zs.prototype.setUneditable=function(e){e.contentEditable="false"},Zs.prototype.onKeyPress=function(e){0!=e.charCode&&(e.preventDefault(),this.cm.isReadOnly()||dn(this.cm,$o)(this.cm,String.fromCharCode(null==e.charCode?e.keyCode:e.charCode),0))},Zs.prototype.readOnlyChanged=function(e){this.div.contentEditable=String("nocursor"!=e)},Zs.prototype.onContextMenu=function(){},Zs.prototype.resetPosition=function(){},Zs.prototype.needsContentAttribute=!0;var Qs=function(e){this.cm=e,this.prevInput="",this.pollingFast=!1,this.polling=new Pl,this.hasSelection=!1,this.composing=null};Qs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()});else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type?i.setSelections(t.ranges,null,Gl):(n.prevInput="",l.value=t.text.join("\n"),El(l))}"cut"==e.type&&(i.state.cutIncoming=!0)}}var r=this,n=this,i=this.cm,o=this.wrapper=el(),l=this.textarea=o.firstChild;e.wrapper.insertBefore(o,e.wrapper.firstChild),Ll&&(l.style.width="0px"),Ql(l,"input",function(){gl&&vl>=9&&r.hasSelection&&(r.hasSelection=null),n.poll()}),Ql(l,"paste",function(e){Me(i,e)||qo(e,i)||(i.state.pasteIncoming=!0,n.fastPoll())}),Ql(l,"cut",t),Ql(l,"copy",t),Ql(e.scroller,"paste",function(t){Ft(e,t)||Me(i,t)||(i.state.pasteIncoming=!0,n.focus())}),Ql(e.lineSpace,"selectstart",function(t){Ft(e,t)||We(t)}),Ql(l,"compositionstart",function(){var e=i.getCursor("from");n.composing&&n.composing.range.clear(),n.composing={start:e,range:i.markText(e,i.getCursor("to"),{className:"CodeMirror-composing"})}}),Ql(l,"compositionend",function(){n.composing&&(n.poll(),n.composing.range.clear(),n.composing=null)})},Qs.prototype.prepareSelection=function(){var e=this.cm,t=e.display,r=e.doc,n=Tr(e);if(e.options.moveInputWithCursor){var i=sr(e,r.sel.primary().head,"div"),o=t.wrapper.getBoundingClientRect(),l=t.lineDiv.getBoundingClientRect();n.teTop=Math.max(0,Math.min(t.wrapper.clientHeight-10,i.top+l.top-o.top)),n.teLeft=Math.max(0,Math.min(t.wrapper.clientWidth-10,i.left+l.left-o.left))}return n},Qs.prototype.showSelection=function(e){var t=this.cm.display;r(t.cursorDiv,e.cursors),r(t.selectionDiv,e.selection),null!=e.teTop&&(this.wrapper.style.top=e.teTop+"px",this.wrapper.style.left=e.teLeft+"px")},Qs.prototype.reset=function(e){if(!this.contextMenuPending&&!this.composing){var t=this.cm;if(t.somethingSelected()){this.prevInput="";var r=t.getSelection();this.textarea.value=r,t.state.focused&&El(this.textarea),gl&&vl>=9&&(this.hasSelection=r)}else e||(this.prevInput=this.textarea.value="",gl&&vl>=9&&(this.hasSelection=null))}},Qs.prototype.getField=function(){return this.textarea},Qs.prototype.supportsTouch=function(){return!1},Qs.prototype.focus=function(){if("nocursor"!=this.cm.options.readOnly&&(!Tl||l()!=this.textarea))try{this.textarea.focus()}catch(e){}},Qs.prototype.blur=function(){this.textarea.blur()},Qs.prototype.resetPosition=function(){this.wrapper.style.top=this.wrapper.style.left=0},Qs.prototype.receivedFocus=function(){this.slowPoll()},Qs.prototype.slowPoll=function(){var e=this;this.pollingFast||this.polling.set(this.cm.options.pollInterval,function(){e.poll(),e.cm.state.focused&&e.slowPoll()})},Qs.prototype.fastPoll=function(){function e(){r.poll()||t?(r.pollingFast=!1,r.slowPoll()):(t=!0,r.polling.set(60,e))}var t=!1,r=this;r.pollingFast=!0,r.polling.set(20,e)},Qs.prototype.poll=function(){var e=this,t=this.cm,r=this.textarea,n=this.prevInput;if(this.contextMenuPending||!t.state.focused||ts(r)&&!n&&!this.composing||t.isReadOnly()||t.options.disableInput||t.state.keySeq)return!1;var i=r.value;if(i==n&&!t.somethingSelected())return!1;if(gl&&vl>=9&&this.hasSelection===i||Ml&&/[\uf700-\uf7ff]/.test(i))return t.display.input.reset(),!1;if(t.doc.sel==t.display.selForContextMenu){var o=i.charCodeAt(0);if(8203!=o||n||(n="​"),8666==o)return this.reset(),this.cm.execCommand("undo")}for(var l=0,s=Math.min(n.length,i.length);l<s&&n.charCodeAt(l)==i.charCodeAt(l);)++l;return hn(t,function(){$o(t,i.slice(l),n.length-l,null,e.composing?"*compose":null),i.length>1e3||i.indexOf("\n")>-1?r.value=e.prevInput="":e.prevInput=i,e.composing&&(e.composing.range.clear(),e.composing.range=t.markText(e.composing.start,t.getCursor("to"),{className:"CodeMirror-composing"}))}),!0},Qs.prototype.ensurePolled=function(){this.pollingFast&&this.poll()&&(this.pollingFast=!1)},Qs.prototype.onKeyPress=function(){gl&&vl>=9&&(this.hasSelection=null),this.fastPoll()},Qs.prototype.onContextMenu=function(e){function t(){if(null!=l.selectionStart){var e=i.somethingSelected(),t="​"+(e?l.value:"");l.value="⇚",l.value=t,n.prevInput=e?"":"​",l.selectionStart=1,l.selectionEnd=t.length,o.selForContextMenu=i.doc.sel}}function r(){if(n.contextMenuPending=!1,n.wrapper.style.cssText=c,l.style.cssText=u,gl&&vl<9&&o.scrollbars.setScrollTop(o.scroller.scrollTop=a),null!=l.selectionStart){(!gl||gl&&vl<9)&&t();var e=0,r=function(){o.selForContextMenu==i.doc.sel&&0==l.selectionStart&&l.selectionEnd>0&&"​"==n.prevInput?dn(i,Mi)(i):e++<10?o.detectingSelectAll=setTimeout(r,500):(o.selForContextMenu=null,o.input.reset())};o.detectingSelectAll=setTimeout(r,200)}}var n=this,i=n.cm,o=i.display,l=n.textarea,s=Sr(i,e),a=o.scroller.scrollTop;if(s&&!wl){i.options.resetSelectionOnContextMenu&&-1==i.doc.sel.contains(s)&&dn(i,bi)(i.doc,Rn(s),Gl);var u=l.style.cssText,c=n.wrapper.style.cssText;n.wrapper.style.cssText="position: absolute";var f=n.wrapper.getBoundingClientRect();l.style.cssText="position: absolute; width: 30px; height: 30px;\n      top: "+(e.clientY-f.top-5)+"px; left: "+(e.clientX-f.left-5)+"px;\n      z-index: 1000; background: "+(gl?"rgba(255, 255, 255, .05)":"transparent")+";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";var h;if(ml&&(h=window.scrollY),o.input.focus(),ml&&window.scrollTo(null,h),o.input.reset(),i.somethingSelected()||(l.value=n.prevInput=" "),n.contextMenuPending=!0,o.selForContextMenu=i.doc.sel,clearTimeout(o.detectingSelectAll),gl&&vl>=9&&t(),Hl){Fe(e);var d=function(){ke(window,"mouseup",d),setTimeout(r,20)};Ql(window,"mouseup",d)}else setTimeout(r,50)}},Qs.prototype.readOnlyChanged=function(e){e||this.reset(),this.textarea.disabled="nocursor"==e},Qs.prototype.setUneditable=function(){},Qs.prototype.needsContentAttribute=!1,function(e){function t(t,n,i,o){e.defaults[t]=n,i&&(r[t]=o?function(e,t,r){r!=Xs&&i(e,t,r)}:i)}var r=e.optionHandlers;e.defineOption=t,e.Init=Xs,t("value","",function(e,t){return e.setValue(t)},!0),t("mode",null,function(e,t){e.doc.modeOption=t,jn(e)},!0),t("indentUnit",2,jn,!0),t("indentWithTabs",!1),t("smartIndent",!0),t("tabSize",4,function(e){Xn(e),er(e),vn(e)},!0),t("lineSeparator",null,function(e,t){if(e.doc.lineSep=t,t){var r=[],n=e.doc.first;e.doc.iter(function(e){for(var i=0;;){var o=e.text.indexOf(t,i);if(-1==o)break;i=o+t.length,r.push(E(n,o))}n++});for(var i=r.length-1;i>=0;i--)Ei(e.doc,t,r[i],E(r[i].line,r[i].ch+t.length))}}),t("specialChars",/[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff]/g,function(e,t,r){e.state.specialChars=new RegExp(t.source+(t.test("\t")?"":"|\t"),"g"),r!=Xs&&e.refresh()}),t("specialCharPlaceholder",at,function(e){return e.refresh()},!0),t("electricChars",!0),t("inputStyle",Tl?"contenteditable":"textarea",function(){throw new Error("inputStyle can not (yet) be changed in a running editor")},!0),t("spellcheck",!1,function(e,t){return e.getInputField().spellcheck=t},!0),t("rtlMoveVisually",!Ol),t("wholeLineUpdateBefore",!0),t("theme","default",function(e){Go(e),Uo(e)},!0),t("keyMap","default",function(e,t,r){var n=uo(t),i=r!=Xs&&uo(r);i&&i.detach&&i.detach(e,n),n.attach&&n.attach(e,i||null)}),t("extraKeys",null),t("configureMouse",null),t("lineWrapping",!1,Ko,!0),t("gutters",[],function(e){Fn(e.options),Uo(e)},!0),t("fixedGutter",!0,function(e,t){e.display.gutters.style.left=t?wr(e.display)+"px":"0",e.refresh()},!0),t("coverGutterNextToScrollbar",!1,function(e){return en(e)},!0),t("scrollbarStyle","native",function(e){rn(e),en(e),e.display.scrollbars.setScrollTop(e.doc.scrollTop),e.display.scrollbars.setScrollLeft(e.doc.scrollLeft)},!0),t("lineNumbers",!1,function(e){Fn(e.options),Uo(e)},!0),t("firstLineNumber",1,Uo,!0),t("lineNumberFormatter",function(e){return e},Uo,!0),t("showCursorWhenSelecting",!1,kr,!0),t("resetSelectionOnContextMenu",!0),t("lineWiseCopyCut",!0),t("pasteLinesPerSelection",!0),t("readOnly",!1,function(e,t){"nocursor"==t&&(Fr(e),e.display.input.blur()),e.display.input.readOnlyChanged(t)}),t("disableInput",!1,function(e,t){t||e.display.input.reset()},!0),t("dragDrop",!0,Vo),t("allowDropFileTypes",null),t("cursorBlinkRate",530),t("cursorScrollMargin",0),t("cursorHeight",1,kr,!0),t("singleCursorHeightPerLine",!0,kr,!0),t("workTime",100),t("workDelay",100),t("flattenSpans",!0,Xn,!0),t("addModeClass",!1,Xn,!0),t("pollInterval",100),t("undoDepth",200,function(e,t){return e.doc.history.undoDepth=t}),t("historyEventDelay",1250),t("viewportMargin",10,function(e){return e.refresh()},!0),t("maxHighlightLength",1e4,Xn,!0),t("moveInputWithCursor",!0,function(e,t){t||e.display.input.resetPosition()}),t("tabindex",null,function(e,t){return e.display.input.getField().tabIndex=t||""}),t("autofocus",null),t("direction","ltr",function(e,t){return e.doc.setDirection(t)},!0)}(jo),function(e){var t=e.optionHandlers,r=e.helpers={};e.prototype={constructor:e,focus:function(){window.focus(),this.display.input.focus()},setOption:function(e,r){var n=this.options,i=n[e];n[e]==r&&"mode"!=e||(n[e]=r,t.hasOwnProperty(e)&&dn(this,t[e])(this,r,i),Te(this,"optionChange",this,e))},getOption:function(e){return this.options[e]},getDoc:function(){return this.doc},addKeyMap:function(e,t){this.state.keyMaps[t?"push":"unshift"](uo(e))},removeKeyMap:function(e){for(var t=this.state.keyMaps,r=0;r<t.length;++r)if(t[r]==e||t[r].name==e)return t.splice(r,1),!0},addOverlay:pn(function(t,r){var n=t.token?t:e.getMode(this.options,t);if(n.startState)throw new Error("Overlays may not be stateful.");m(this.state.overlays,{mode:n,modeSpec:t,opaque:r&&r.opaque,priority:r&&r.priority||0},function(e){return e.priority}),this.state.modeGen++,vn(this)}),removeOverlay:pn(function(e){for(var t=this,r=this.state.overlays,n=0;n<r.length;++n){var i=r[n].modeSpec;if(i==e||"string"==typeof e&&i.name==e)return r.splice(n,1),t.state.modeGen++,void vn(t)}}),indentLine:pn(function(e,t,r){"string"!=typeof t&&"number"!=typeof t&&(t=null==t?this.options.smartIndent?"smart":"prev":t?"add":"subtract"),H(this.doc,e)&&Yo(this,e,t,r)}),indentSelection:pn(function(e){for(var t=this,r=this.doc.sel.ranges,n=-1,i=0;i<r.length;i++){var o=r[i];if(o.empty())o.head.line>n&&(Yo(t,o.head.line,e,!0),n=o.head.line,i==t.doc.sel.primIndex&&jr(t));else{var l=o.from(),s=o.to(),a=Math.max(n,l.line);n=Math.min(t.lastLine(),s.line-(s.ch?0:1))+1;for(var u=a;u<n;++u)Yo(t,u,e);var c=t.doc.sel.ranges;0==l.ch&&r.length==c.length&&c[i].from().ch>0&&gi(t.doc,i,new Ts(l,c[i].to()),Gl)}}}),getTokenAt:function(e,t){return Je(this,e,t)},getLineTokens:function(e,t){return Je(this,E(e),t,!0)},getTokenTypeAt:function(e){e=U(this.doc,e);var t,r=_e(this,M(this.doc,e.line)),n=0,i=(r.length-1)/2,o=e.ch;if(0==o)t=r[2];else for(;;){var l=n+i>>1;if((l?r[2*l-1]:0)>=o)i=l;else{if(!(r[2*l+1]<o)){t=r[2*l+2];break}n=l+1}}var s=t?t.indexOf("overlay "):-1;return s<0?t:0==s?null:t.slice(0,s-1)},getModeAt:function(t){var r=this.doc.mode;return r.innerMode?e.innerMode(r,this.getTokenAt(t).state).mode:r},getHelper:function(e,t){return this.getHelpers(e,t)[0]},getHelpers:function(e,t){var n=this,i=[];if(!r.hasOwnProperty(t))return i;var o=r[t],l=this.getModeAt(e);if("string"==typeof l[t])o[l[t]]&&i.push(o[l[t]]);else if(l[t])for(var s=0;s<l[t].length;s++){var a=o[l[t][s]];a&&i.push(a)}else l.helperType&&o[l.helperType]?i.push(o[l.helperType]):o[l.name]&&i.push(o[l.name]);for(var u=0;u<o._global.length;u++){var c=o._global[u];c.pred(l,n)&&-1==h(i,c.val)&&i.push(c.val)}return i},getStateAfter:function(e,t){var r=this.doc;return e=G(r,null==e?r.first+r.size-1:e),$e(this,e+1,t).state},cursorCoords:function(e,t){var r,n=this.doc.sel.primary();return r=null==e?n.head:"object"==typeof e?U(this.doc,e):e?n.from():n.to(),sr(this,r,t||"page")},charCoords:function(e,t){return lr(this,U(this.doc,e),t||"page")},coordsChar:function(e,t){return e=or(this,e,t||"page"),cr(this,e.left,e.top)},lineAtHeight:function(e,t){return e=or(this,{top:e,left:0},t||"page").top,D(this.doc,e+this.display.viewOffset)},heightAtLine:function(e,t,r){var n,i=!1;if("number"==typeof e){var o=this.doc.first+this.doc.size-1;e<this.doc.first?e=this.doc.first:e>o&&(e=o,i=!0),n=M(this.doc,e)}else n=e;return ir(this,n,{top:0,left:0},t||"page",r||i).top+(i?this.doc.height-ye(n):0)},defaultTextHeight:function(){return mr(this.display)},defaultCharWidth:function(){return yr(this.display)},getViewport:function(){return{from:this.display.viewFrom,to:this.display.viewTo}},addWidget:function(e,t,r,n,i){var o=this.display,l=(e=sr(this,U(this.doc,e))).bottom,s=e.left;if(t.style.position="absolute",t.setAttribute("cm-ignore-events","true"),this.display.input.setUneditable(t),o.sizer.appendChild(t),"over"==n)l=e.top;else if("above"==n||"near"==n){var a=Math.max(o.wrapper.clientHeight,this.doc.height),u=Math.max(o.sizer.clientWidth,o.lineSpace.clientWidth);("above"==n||e.bottom+t.offsetHeight>a)&&e.top>t.offsetHeight?l=e.top-t.offsetHeight:e.bottom+t.offsetHeight<=a&&(l=e.bottom),s+t.offsetWidth>u&&(s=u-t.offsetWidth)}t.style.top=l+"px",t.style.left=t.style.right="","right"==i?(s=o.sizer.clientWidth-t.offsetWidth,t.style.right="0px"):("left"==i?s=0:"middle"==i&&(s=(o.sizer.clientWidth-t.offsetWidth)/2),t.style.left=s+"px"),r&&Ur(this,{left:s,top:l,right:s+t.offsetWidth,bottom:l+t.offsetHeight})},triggerOnKeyDown:pn(Lo),triggerOnKeyPress:pn(Mo),triggerOnKeyUp:To,triggerOnMouseDown:pn(Oo),execCommand:function(e){if(Bs.hasOwnProperty(e))return Bs[e].call(null,this)},triggerElectric:pn(function(e){Zo(this,e)}),findPosH:function(e,t,r,n){var i=this,o=1;t<0&&(o=-1,t=-t);for(var l=U(this.doc,e),s=0;s<t&&!(l=tl(i.doc,l,o,r,n)).hitSide;++s);return l},moveH:pn(function(e,t){var r=this;this.extendSelectionsBy(function(n){return r.display.shift||r.doc.extend||n.empty()?tl(r.doc,n.head,e,t,r.options.rtlMoveVisually):e<0?n.from():n.to()},Vl)}),deleteH:pn(function(e,t){var r=this.doc.sel,n=this.doc;r.somethingSelected()?n.replaceSelection("",null,"+delete"):co(this,function(r){var i=tl(n,r.head,e,t,!1);return e<0?{from:i,to:r.head}:{from:r.head,to:i}})}),findPosV:function(e,t,r,n){var i=this,o=1,l=n;t<0&&(o=-1,t=-t);for(var s=U(this.doc,e),a=0;a<t;++a){var u=sr(i,s,"div");if(null==l?l=u.left:u.left=l,(s=rl(i,u,o,r)).hitSide)break}return s},moveV:pn(function(e,t){var r=this,n=this.doc,i=[],o=!this.display.shift&&!n.extend&&n.sel.somethingSelected();if(n.extendSelectionsBy(function(l){if(o)return e<0?l.from():l.to();var s=sr(r,l.head,"div");null!=l.goalColumn&&(s.left=l.goalColumn),i.push(s.left);var a=rl(r,s,e,t);return"page"==t&&l==n.sel.primary()&&Kr(r,lr(r,a,"div").top-s.top),a},Vl),i.length)for(var l=0;l<n.sel.ranges.length;l++)n.sel.ranges[l].goalColumn=i[l]}),findWordAt:function(e){var t=M(this.doc,e.line).text,r=e.ch,n=e.ch;if(t){var i=this.getHelper(e,"wordChars");"before"!=e.sticky&&n!=t.length||!r?++n:--r;for(var o=t.charAt(r),l=x(o,i)?function(e){return x(e,i)}:/\s/.test(o)?function(e){return/\s/.test(e)}:function(e){return!/\s/.test(e)&&!x(e)};r>0&&l(t.charAt(r-1));)--r;for(;n<t.length&&l(t.charAt(n));)++n}return new Ts(E(e.line,r),E(e.line,n))},toggleOverwrite:function(e){null!=e&&e==this.state.overwrite||((this.state.overwrite=!this.state.overwrite)?s(this.display.cursorDiv,"CodeMirror-overwrite"):Fl(this.display.cursorDiv,"CodeMirror-overwrite"),Te(this,"overwriteToggle",this,this.state.overwrite))},hasFocus:function(){return this.display.input.getField()==l()},isReadOnly:function(){return!(!this.options.readOnly&&!this.doc.cantEdit)},scrollTo:pn(function(e,t){Xr(this,e,t)}),getScrollInfo:function(){var e=this.display.scroller;return{left:e.scrollLeft,top:e.scrollTop,height:e.scrollHeight-zt(this)-this.display.barHeight,width:e.scrollWidth-zt(this)-this.display.barWidth,clientHeight:Bt(this),clientWidth:Rt(this)}},scrollIntoView:pn(function(e,t){null==e?(e={from:this.doc.sel.primary().head,to:null},null==t&&(t=this.options.cursorScrollMargin)):"number"==typeof e?e={from:E(e,0),to:null}:null==e.from&&(e={from:e,to:null}),e.to||(e.to=e.from),e.margin=t||0,null!=e.from.line?Yr(this,e):$r(this,e.from,e.to,e.margin)}),setSize:pn(function(e,t){var r=this,n=function(e){return"number"==typeof e||/^\d+$/.test(String(e))?e+"px":e};null!=e&&(this.display.wrapper.style.width=n(e)),null!=t&&(this.display.wrapper.style.height=n(t)),this.options.lineWrapping&&Jt(this);var i=this.display.viewFrom;this.doc.iter(i,this.display.viewTo,function(e){if(e.widgets)for(var t=0;t<e.widgets.length;t++)if(e.widgets[t].noHScroll){mn(r,i,"widget");break}++i}),this.curOp.forceUpdate=!0,Te(this,"refresh",this)}),operation:function(e){return hn(this,e)},startOperation:function(){return nn(this)},endOperation:function(){return on(this)},refresh:pn(function(){var e=this.display.cachedTextHeight;vn(this),this.curOp.forceUpdate=!0,er(this),Xr(this,this.doc.scrollLeft,this.doc.scrollTop),Wn(this),(null==e||Math.abs(e-mr(this.display))>.5)&&Cr(this),Te(this,"refresh",this)}),swapDoc:pn(function(e){var t=this.doc;return t.cm=null,qn(this,e),er(this),this.display.input.reset(),Xr(this,e.scrollLeft,e.scrollTop),this.curOp.forceScroll=!0,bt(this,"swapDoc",this,t),t}),getInputField:function(){return this.display.input.getField()},getWrapperElement:function(){return this.display.wrapper},getScrollerElement:function(){return this.display.scroller},getGutterElement:function(){return this.display.gutters}},Ae(e),e.registerHelper=function(t,n,i){r.hasOwnProperty(t)||(r[t]=e[t]={_global:[]}),r[t][n]=i},e.registerGlobalHelper=function(t,n,i,o){e.registerHelper(t,n,o),r[t]._global.push({pred:i,val:o})}}(jo);var Js="iter insert remove copy getEditor constructor".split(" ");for(var ea in Ds.prototype)Ds.prototype.hasOwnProperty(ea)&&h(Js,ea)<0&&(jo.prototype[ea]=function(e){return function(){return e.apply(this.doc,arguments)}}(Ds.prototype[ea]));return Ae(Ds),jo.inputStyles={textarea:Qs,contenteditable:Zs},jo.defineMode=function(e){jo.defaults.mode||"null"==e||(jo.defaults.mode=e),Be.apply(this,arguments)},jo.defineMIME=function(e,t){os[e]=t},jo.defineMode("null",function(){return{token:function(e){return e.skipToEnd()}}}),jo.defineMIME("text/plain","null"),jo.defineExtension=function(e,t){jo.prototype[e]=t},jo.defineDocExtension=function(e,t){Ds.prototype[e]=t},jo.fromTextArea=function(e,t){function r(){e.value=a.getValue()}if(t=t?c(t):{},t.value=e.value,!t.tabindex&&e.tabIndex&&(t.tabindex=e.tabIndex),!t.placeholder&&e.placeholder&&(t.placeholder=e.placeholder),null==t.autofocus){var n=l();t.autofocus=n==e||null!=e.getAttribute("autofocus")&&n==document.body}var i;if(e.form&&(Ql(e.form,"submit",r),!t.leaveSubmitMethodAlone)){var o=e.form;i=o.submit;try{var s=o.submit=function(){r(),o.submit=i,o.submit(),o.submit=s}}catch(e){}}t.finishInit=function(t){t.save=r,t.getTextArea=function(){return e},t.toTextArea=function(){t.toTextArea=isNaN,r(),e.parentNode.removeChild(t.getWrapperElement()),e.style.display="",e.form&&(ke(e.form,"submit",r),"function"==typeof e.form.submit&&(e.form.submit=i))}},e.style.display="none";var a=jo(function(t){return e.parentNode.insertBefore(t,e.nextSibling)},t);return a},function(e){e.off=ke,e.on=Ql,e.wheelEventPixels=Pn,e.Doc=Ds,e.splitLines=es,e.countColumn=f,e.findColumn=d,e.isWordChar=w,e.Pass=Bl,e.signal=Te,e.Line=fs,e.changeEnd=Bn,e.scrollbarModel=ws,e.Pos=E,e.cmpPos=P,e.modes=is,e.mimeModes=os,e.resolveMode=Ge,e.getMode=Ue,e.modeExtensions=ls,e.extendMode=Ve,e.copyState=Ke,e.startState=Xe,e.innerMode=je,e.commands=Bs,e.keyMap=Rs,e.keyName=ao,e.isModifierKey=lo,e.lookupKey=oo,e.normalizeKeyMap=io,e.StringStream=ss,e.SharedTextMarker=As,e.TextMarker=Os,e.LineWidget=Ms,e.e_preventDefault=We,e.e_stopPropagation=De,e.e_stop=Fe,e.addClass=s,e.contains=o,e.rmClass=Fl,e.keyNames=Es}(jo),jo.version="5.30.0",jo});
      !function(e){"object"==typeof exports&&"object"==typeof module?e(require("../../lib/codemirror")):"function"==typeof define&&define.amd?define(["../../lib/codemirror"],e):e(CodeMirror)}(function(e){"use strict";function t(e,t,n,r,o,a){this.indented=e,this.column=t,this.type=n,this.info=r,this.align=o,this.prev=a}function n(e,n,r,o){var a=e.indented;return e.context&&"statement"==e.context.type&&"statement"!=r&&(a=e.context.indented),e.context=new t(a,n,r,o,null,e.context)}function r(e){var t=e.context.type;return")"!=t&&"]"!=t&&"}"!=t||(e.indented=e.context.indented),e.context=e.context.prev}function o(e,t,n){return"variable"==t.prevToken||"type"==t.prevToken||(!!/\S(?:[^- ]>|[*\]])\s*$|\*$/.test(e.string.slice(0,n))||(!(!t.typeAtEndOfLine||e.column()!=e.indentation())||void 0))}function a(e){for(;;){if(!e||"top"==e.type)return!0;if("}"==e.type&&"namespace"!=e.prev.info)return!1;e=e.prev}}function i(e){for(var t={},n=e.split(" "),r=0;r<n.length;++r)t[n[r]]=!0;return t}function l(e,t){return"function"==typeof e?e(t):e.propertyIsEnumerable(t)}function s(e,t){if(!t.startOfLine)return!1;for(var n,r=null;n=e.peek();){if("\\"==n&&e.match(/^.$/)){r=s;break}if("/"==n&&e.match(/^\/[\/\*]/,!1))break;e.next()}return t.tokenize=r,"meta"}function c(e,t){return"type"==t.prevToken&&"type"}function u(e){return e.eatWhile(/[\w\.']/),"number"}function d(e,t){if(e.backUp(1),e.match(/(R|u8R|uR|UR|LR)/)){var n=e.match(/"([^\s\\()]{0,16})\(/);return!!n&&(t.cpp11RawStringDelim=n[1],t.tokenize=m,m(e,t))}return e.match(/(u8|u|U|L)/)?!!e.match(/["']/,!1)&&"string":(e.next(),!1)}function f(e){var t=/(\w+)::~?(\w+)$/.exec(e);return t&&t[1]==t[2]}function p(e,t){for(var n;null!=(n=e.next());)if('"'==n&&!e.eat('"')){t.tokenize=null;break}return"string"}function m(e,t){var n=t.cpp11RawStringDelim.replace(/[^\w\s]/g,"\\$&");return e.match(new RegExp(".*?\\)"+n+'"'))?t.tokenize=null:e.skipToEnd(),"string"}function h(t,n){function r(e){if(e)for(var t in e)e.hasOwnProperty(t)&&o.push(t)}"string"==typeof t&&(t=[t]);var o=[];r(n.keywords),r(n.types),r(n.builtin),r(n.atoms),o.length&&(n.helperType=t[0],e.registerHelper("hintWords",t[0],o));for(var a=0;a<t.length;++a)e.defineMIME(t[a],n)}function g(e,t){for(var n=!1;!e.eol();){if(!n&&e.match('"""')){t.tokenize=null;break}n="\\"==e.next()&&!n}return"string"}function y(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!e&&!o&&t.match('"')){a=!0;break}if(e&&t.match('"""')){a=!0;break}r=t.next(),!o&&"$"==r&&t.match("{")&&t.skipTo("}"),o=!o&&"\\"==r&&!e}return!a&&e||(n.tokenize=null),"string"}}function x(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!o&&t.match('"')&&("single"==e||t.match('""'))){a=!0;break}if(!o&&t.match("``")){w=x(e),a=!0;break}r=t.next(),o="single"==e&&!o&&"\\"==r}return a&&(n.tokenize=null),"string"}}e.defineMode("clike",function(i,s){function c(e,t){var n=e.next();if(S[n]){var r=S[n](e,t);if(!1!==r)return r}if('"'==n||"'"==n)return t.tokenize=u(n),t.tokenize(e,t);if(D.test(n))return p=n,null;if(L.test(n)){if(e.backUp(1),e.match(I))return"number";e.next()}if("/"==n){if(e.eat("*"))return t.tokenize=d,d(e,t);if(e.eat("/"))return e.skipToEnd(),"comment"}if(F.test(n)){for(;!e.match(/^\/[\/*]/,!1)&&e.eat(F););return"operator"}if(e.eatWhile(z),P)for(;e.match(P);)e.eatWhile(z);var o=e.current();return l(x,o)?(l(w,o)&&(p="newstatement"),l(v,o)&&(m=!0),"keyword"):l(b,o)?"type":l(k,o)?(l(w,o)&&(p="newstatement"),"builtin"):l(_,o)?"atom":"variable"}function u(e){return function(t,n){for(var r,o=!1,a=!1;null!=(r=t.next());){if(r==e&&!o){a=!0;break}o=!o&&"\\"==r}return(a||!o&&!C)&&(n.tokenize=null),"string"}}function d(e,t){for(var n,r=!1;n=e.next();){if("/"==n&&r){t.tokenize=null;break}r="*"==n}return"comment"}function f(e,t){s.typeFirstDefinitions&&e.eol()&&a(t.context)&&(t.typeAtEndOfLine=o(e,t,e.pos))}var p,m,h=i.indentUnit,g=s.statementIndentUnit||h,y=s.dontAlignCalls,x=s.keywords||{},b=s.types||{},k=s.builtin||{},w=s.blockKeywords||{},v=s.defKeywords||{},_=s.atoms||{},S=s.hooks||{},C=s.multiLineStrings,T=!1!==s.indentStatements,M=!1!==s.indentSwitch,P=s.namespaceSeparator,D=s.isPunctuationChar||/[\[\]{}\(\),;\:\.]/,L=s.numberStart||/[\d\.]/,I=s.number||/^(?:0x[a-f\d]+|0b[01]+|(?:\d+\.?\d*|\.\d+)(?:e[-+]?\d+)?)(u|ll?|l|f)?/i,F=s.isOperatorChar||/[+\-*&%=<>!?|\/]/,z=s.isIdentifierChar||/[\w\$_\xa1-\uffff]/;return{startState:function(e){return{tokenize:null,context:new t((e||0)-h,0,"top",null,!1),indented:0,startOfLine:!0,prevToken:null}},token:function(e,t){var i=t.context;if(e.sol()&&(null==i.align&&(i.align=!1),t.indented=e.indentation(),t.startOfLine=!0),e.eatSpace())return f(e,t),null;p=m=null;var l=(t.tokenize||c)(e,t);if("comment"==l||"meta"==l)return l;if(null==i.align&&(i.align=!0),";"==p||":"==p||","==p&&e.match(/^\s*(?:\/\/.*)?$/,!1))for(;"statement"==t.context.type;)r(t);else if("{"==p)n(t,e.column(),"}");else if("["==p)n(t,e.column(),"]");else if("("==p)n(t,e.column(),")");else if("}"==p){for(;"statement"==i.type;)i=r(t);for("}"==i.type&&(i=r(t));"statement"==i.type;)i=r(t)}else p==i.type?r(t):T&&(("}"==i.type||"top"==i.type)&&";"!=p||"statement"==i.type&&"newstatement"==p)&&n(t,e.column(),"statement",e.current());if("variable"==l&&("def"==t.prevToken||s.typeFirstDefinitions&&o(e,t,e.start)&&a(t.context)&&e.match(/^\s*\(/,!1))&&(l="def"),S.token){var u=S.token(e,t,l);void 0!==u&&(l=u)}return"def"==l&&!1===s.styleDefs&&(l="variable"),t.startOfLine=!1,t.prevToken=m?"def":l||p,f(e,t),l},indent:function(t,n){if(t.tokenize!=c&&null!=t.tokenize||t.typeAtEndOfLine)return e.Pass;var r=t.context,o=n&&n.charAt(0);if("statement"==r.type&&"}"==o&&(r=r.prev),s.dontIndentStatements)for(;"statement"==r.type&&s.dontIndentStatements.test(r.info);)r=r.prev;if(S.indent){var a=S.indent(t,r,n);if("number"==typeof a)return a}var i=o==r.type,l=r.prev&&"switch"==r.prev.info;if(s.allmanIndentation&&/[{(]/.test(o)){for(;"top"!=r.type&&"}"!=r.type;)r=r.prev;return r.indented}return"statement"==r.type?r.indented+("{"==o?0:g):!r.align||y&&")"==r.type?")"!=r.type||i?r.indented+(i?0:h)+(i||!l||/^(?:case|default)\b/.test(n)?0:h):r.indented+g:r.column+(i?0:1)},electricInput:M?/^\s*(?:case .*?:|default:|\{\}?|\})$/:/^\s*[{}]$/,blockCommentStart:"/*",blockCommentEnd:"*/",lineComment:"//",fold:"brace"}});var b="auto if break case register continue return default do sizeof static else struct switch extern typedef union for goto while enum const volatile",k="int long char short double float unsigned signed void size_t ptrdiff_t";h(["text/x-csrc","text/x-c","text/x-chdr"],{name:"clike",keywords:i(b),types:i(k+" bool _Complex _Bool float_t double_t intptr_t intmax_t int8_t int16_t int32_t int64_t uintptr_t uintmax_t uint8_t uint16_t uint32_t uint64_t"),blockKeywords:i("case do else for if switch while struct"),defKeywords:i("struct"),typeFirstDefinitions:!0,atoms:i("null true false"),hooks:{"#":s,"*":c},modeProps:{fold:["brace","include"]}}),h(["text/x-c++src","text/x-c++hdr"],{name:"clike",keywords:i(b+" asm dynamic_cast namespace reinterpret_cast try explicit new static_cast typeid catch operator template typename class friend private this using const_cast inline public throw virtual delete mutable protected alignas alignof constexpr decltype nullptr noexcept thread_local final static_assert override"),types:i(k+" bool wchar_t"),blockKeywords:i("catch class do else finally for if struct switch try while"),defKeywords:i("class namespace struct enum union"),typeFirstDefinitions:!0,atoms:i("true false null"),dontIndentStatements:/^template$/,isIdentifierChar:/[\w\$_~\xa1-\uffff]/,hooks:{"#":s,"*":c,u:d,U:d,L:d,R:d,0:u,1:u,2:u,3:u,4:u,5:u,6:u,7:u,8:u,9:u,token:function(e,t,n){if("variable"==n&&"("==e.peek()&&(";"==t.prevToken||null==t.prevToken||"}"==t.prevToken)&&f(e.current()))return"def"}},namespaceSeparator:"::",modeProps:{fold:["brace","include"]}}),h("text/x-java",{name:"clike",keywords:i("abstract assert break case catch class const continue default do else enum extends final finally float for goto if implements import instanceof interface native new package private protected public return static strictfp super switch synchronized this throw throws transient try volatile while @interface"),types:i("byte short int long float double boolean char void Boolean Byte Character Double Float Integer Long Number Object Short String StringBuffer StringBuilder Void"),blockKeywords:i("catch class do else finally for if switch try while"),defKeywords:i("class interface package enum @interface"),typeFirstDefinitions:!0,atoms:i("true false null"),number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,hooks:{"@":function(e){return!e.match("interface",!1)&&(e.eatWhile(/[\w\$_]/),"meta")}},modeProps:{fold:["brace","import"]}}),h("text/x-csharp",{name:"clike",keywords:i("abstract as async await base break case catch checked class const continue default delegate do else enum event explicit extern finally fixed for foreach goto if implicit in interface internal is lock namespace new operator out override params private protected public readonly ref return sealed sizeof stackalloc static struct switch this throw try typeof unchecked unsafe using virtual void volatile while add alias ascending descending dynamic from get global group into join let orderby partial remove select set value var yield"),types:i("Action Boolean Byte Char DateTime DateTimeOffset Decimal Double Func Guid Int16 Int32 Int64 Object SByte Single String Task TimeSpan UInt16 UInt32 UInt64 bool byte char decimal double short int long object sbyte float string ushort uint ulong"),blockKeywords:i("catch class do else finally for foreach if struct switch try while"),defKeywords:i("class interface namespace struct var"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"@":function(e,t){return e.eat('"')?(t.tokenize=p,p(e,t)):(e.eatWhile(/[\w\$_]/),"meta")}}}),h("text/x-scala",{name:"clike",keywords:i("abstract case catch class def do else extends final finally for forSome if implicit import lazy match new null object override package private protected return sealed super this throw trait try type val var while with yield _ assert assume require print println printf readLine readBoolean readByte readShort readChar readInt readLong readFloat readDouble"),types:i("AnyVal App Application Array BufferedIterator BigDecimal BigInt Char Console Either Enumeration Equiv Error Exception Fractional Function IndexedSeq Int Integral Iterable Iterator List Map Numeric Nil NotNull Option Ordered Ordering PartialFunction PartialOrdering Product Proxy Range Responder Seq Serializable Set Specializable Stream StringBuilder StringContext Symbol Throwable Traversable TraversableOnce Tuple Unit Vector Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),multiLineStrings:!0,blockKeywords:i("catch class enum do else finally for forSome if match switch try while"),defKeywords:i("class enum def object package trait type val var"),atoms:i("true false null"),indentStatements:!1,indentSwitch:!1,isOperatorChar:/[+\-*&%=<>!?|\/#:@]/,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return!!e.match('""')&&(t.tokenize=g,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},"=":function(e,n){var r=n.context;return!("}"!=r.type||!r.align||!e.eat(">"))&&(n.context=new t(r.indented,r.column,r.type,r.info,null,r.prev),"operator")}},modeProps:{closeBrackets:{triples:'"'}}}),h("text/x-kotlin",{name:"clike",keywords:i("package as typealias class interface this super val var fun for is in This throw return break continue object if else while do try when !in !is as? file import where by get set abstract enum open inner override private public internal protected catch finally out final vararg reified dynamic companion constructor init sealed field property receiver param sparam lateinit data inline noinline tailrec external annotation crossinline const operator infix suspend"),types:i("Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),intendSwitch:!1,indentStatements:!1,multiLineStrings:!0,number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,blockKeywords:i("catch class do else finally for if where try while enum"),defKeywords:i("class val var object package interface fun"),atoms:i("true false null this"),hooks:{'"':function(e,t){return t.tokenize=y(e.match('""')),t.tokenize(e,t)}},modeProps:{closeBrackets:{triples:'"'}}}),h(["x-shader/x-vertex","x-shader/x-fragment"],{name:"clike",keywords:i("sampler1D sampler2D sampler3D samplerCube sampler1DShadow sampler2DShadow const attribute uniform varying break continue discard return for while do if else struct in out inout"),types:i("float int bool void vec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4 mat2 mat3 mat4"),blockKeywords:i("for while do if else struct"),builtin:i("radians degrees sin cos tan asin acos atan pow exp log exp2 sqrt inversesqrt abs sign floor ceil fract mod min max clamp mix step smoothstep length distance dot cross normalize ftransform faceforward reflect refract matrixCompMult lessThan lessThanEqual greaterThan greaterThanEqual equal notEqual any all not texture1D texture1DProj texture1DLod texture1DProjLod texture2D texture2DProj texture2DLod texture2DProjLod texture3D texture3DProj texture3DLod texture3DProjLod textureCube textureCubeLod shadow1D shadow2D shadow1DProj shadow2DProj shadow1DLod shadow2DLod shadow1DProjLod shadow2DProjLod dFdx dFdy fwidth noise1 noise2 noise3 noise4"),atoms:i("true false gl_FragColor gl_SecondaryColor gl_Normal gl_Vertex gl_MultiTexCoord0 gl_MultiTexCoord1 gl_MultiTexCoord2 gl_MultiTexCoord3 gl_MultiTexCoord4 gl_MultiTexCoord5 gl_MultiTexCoord6 gl_MultiTexCoord7 gl_FogCoord gl_PointCoord gl_Position gl_PointSize gl_ClipVertex gl_FrontColor gl_BackColor gl_FrontSecondaryColor gl_BackSecondaryColor gl_TexCoord gl_FogFragCoord gl_FragCoord gl_FrontFacing gl_FragData gl_FragDepth gl_ModelViewMatrix gl_ProjectionMatrix gl_ModelViewProjectionMatrix gl_TextureMatrix gl_NormalMatrix gl_ModelViewMatrixInverse gl_ProjectionMatrixInverse gl_ModelViewProjectionMatrixInverse gl_TexureMatrixTranspose gl_ModelViewMatrixInverseTranspose gl_ProjectionMatrixInverseTranspose gl_ModelViewProjectionMatrixInverseTranspose gl_TextureMatrixInverseTranspose gl_NormalScale gl_DepthRange gl_ClipPlane gl_Point gl_FrontMaterial gl_BackMaterial gl_LightSource gl_LightModel gl_FrontLightModelProduct gl_BackLightModelProduct gl_TextureColor gl_EyePlaneS gl_EyePlaneT gl_EyePlaneR gl_EyePlaneQ gl_FogParameters gl_MaxLights gl_MaxClipPlanes gl_MaxTextureUnits gl_MaxTextureCoords gl_MaxVertexAttribs gl_MaxVertexUniformComponents gl_MaxVaryingFloats gl_MaxVertexTextureImageUnits gl_MaxTextureImageUnits gl_MaxFragmentUniformComponents gl_MaxCombineTextureImageUnits gl_MaxDrawBuffers"),indentSwitch:!1,hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-nesc",{name:"clike",keywords:i(b+"as atomic async call command component components configuration event generic implementation includes interface module new norace nx_struct nx_union post provides signal task uses abstract extends"),types:i(k),blockKeywords:i("case do else for if switch while struct"),atoms:i("null true false"),hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-objectivec",{name:"clike",keywords:i(b+"inline restrict _Bool _Complex _Imaginary BOOL Class bycopy byref id IMP in inout nil oneway out Protocol SEL self super atomic nonatomic retain copy readwrite readonly"),types:i(k),atoms:i("YES NO NULL NILL ON OFF true false"),hooks:{"@":function(e){return e.eatWhile(/[\w\$]/),"keyword"},"#":s,indent:function(e,t,n){if("statement"==t.type&&/^@\w/.test(n))return t.indented}},modeProps:{fold:"brace"}}),h("text/x-squirrel",{name:"clike",keywords:i("base break clone continue const default delete enum extends function in class foreach local resume return this throw typeof yield constructor instanceof static"),types:i(k),blockKeywords:i("case catch class else for foreach if switch try while"),defKeywords:i("function local class"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"#":s},modeProps:{fold:["brace","include"]}});var w=null;h("text/x-ceylon",{name:"clike",keywords:i("abstracts alias assembly assert assign break case catch class continue dynamic else exists extends finally for function given if import in interface is let module new nonempty object of out outer package return satisfies super switch then this throw try value void while"),types:function(e){var t=e.charAt(0);return t===t.toUpperCase()&&t!==t.toLowerCase()},blockKeywords:i("case catch class dynamic else finally for function if interface module new object switch try while"),defKeywords:i("class dynamic function interface module object package value"),builtin:i("abstract actual aliased annotation by default deprecated doc final formal late license native optional sealed see serializable shared suppressWarnings tagged throws variable"),isPunctuationChar:/[\[\]{}\(\),;\:\.`]/,isOperatorChar:/[+\-*&%=<>!?|^~:\/]/,numberStart:/[\d#$]/,number:/^(?:#[\da-fA-F_]+|\$[01_]+|[\d_]+[kMGTPmunpf]?|[\d_]+\.[\d_]+(?:[eE][-+]?\d+|[kMGTPmunpf]|)|)/i,multiLineStrings:!0,typeFirstDefinitions:!0,atoms:i("true false null larger smaller equal empty finished"),indentSwitch:!1,styleDefs:!1,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return t.tokenize=x(e.match('""')?"triple":"single"),t.tokenize(e,t)},"`":function(e,t){return!(!w||!e.match("`"))&&(t.tokenize=w,w=null,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},token:function(e,t,n){if(("variable"==n||"type"==n)&&"."==t.prevToken)return"variable-2"}},modeProps:{fold:["brace","import"],closeBrackets:{triples:'"'}}})});
      // -------------------------------------------------------------------------
//  Part of the CodeChecker project, under the Apache License v2.0 with
//  LLVM Exceptions. See LICENSE for license information.
//  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
// -------------------------------------------------------------------------

var BugViewer = {
  _files : [],
  _reports : [],
  _lineWidgets : [],
  _navigationMenuItems : [],
  _sourceFileData : null,
  _currentReport : null,
  _lastBugEvent  : null,

  init : function (files, reports) {
    this._files = files;
    this._reports = reports;

    this.initEscapeChars();
  },

  initEscapeChars : function () {
    this.escapeChars = {
      ' ' : 'nbsp',
      '<' : 'lt',
      '>' : 'gt',
      '"' : 'quot',
      '&' : 'amp'
    };

    var regexString = '[';
    for (var key in this.escapeChars) {
      regexString += key;
    }
    regexString += ']';

    this.escapeRegExp = new RegExp( regexString, 'g');
  },

  escapeHTML : function (str) {
    var that = this;

    return str.replace(this.escapeRegExp, function (m) {
      return '&' + that.escapeChars[m] + ';';
    });
  },

  initByUrl : function () {
    if (!this._reports) return;

    var state = {};
    window.location.hash.substr(1).split('&').forEach(function (s) {
      var parts = s.split('=');
      state[parts[0]] = parts[1];
    });

    for (var key in this._reports) {
      var report = this._reports[key];
      if (report.reportHash === state['reportHash']) {
        this.navigate(report);
        return;
      }
    }

    this.navigate(this._reports[0]);
  },

  create : function () {
    this._content = document.getElementById('editor-wrapper');
    this._filepath = document.getElementById('file-path');
    this._checkerName = document.getElementById('checker-name');
    this._reviewStatusWrapper =
      document.getElementById('review-status-wrapper');
    this._reviewStatus = document.getElementById('review-status');
    this._editor = document.getElementById('editor');

    this._codeMirror = CodeMirror(this._editor, {
      mode: 'text/x-c++src',
      matchBrackets : true,
      lineNumbers : true,
      readOnly : true,
      foldGutter : true,
      extraKeys : {},
      viewportMargin : 100
    });

    this._createNavigationMenu();
  },

  navigate : function (report, item) {
    if (!item) {
      var items = this._navigationMenuItems.filter(function (navItem) {
        return navItem.report.reportHash === report.reportHash;
      });

      if (!items.length) return;

      item = items[0].widget;
    }

    this._selectedReport.classList.remove('active');
    this._selectedReport = item;
    this._selectedReport.classList.add('active');
    this.setReport(report);
  },

  _createNavigationMenu : function () {
    var that = this;

    var nav = document.getElementById('report-nav');
    var list = document.createElement('ul');
    this._reports.forEach(function (report) {
      var events = report['events'];
      var lastBugEvent = events[events.length - 1];
      var item = document.createElement('li');

      var severity = document.createElement('i');
      severity.className = 'severity-' + report.severity.toLowerCase();

      item.appendChild(severity);
      item.appendChild(document.createTextNode(lastBugEvent.message));

      item.addEventListener('click', function () {
        that.navigate(report, item);
      })
      list.appendChild(item);
      that._navigationMenuItems.push({ report : report, widget : item });
    });

    if (!this._selectedReport && list.childNodes.length) {
      this._selectedReport = list.childNodes[0];
      this._selectedReport.classList.add('active');
    }

    nav.appendChild(list);
  },

  setReport : function (report) {
    this._currentReport = report;
    var events = report['events'];
    var lastBugEvent = events[events.length - 1];
    this.setCurrentBugEvent(lastBugEvent, events.length - 1);
    this.setCheckerName(report.checkerName);
    this.setReviewStatus(report.reviewStatus);

    window.location.hash = '#reportHash=' + report.reportHash;
  },

  setCurrentBugEvent : function (event, idx) {
    this._currentBugEvent = event;
    this.setSourceFileData(this._files[event.location.file]);
    this.drawBugPath();

    this.jumpTo(event.location.line, 0);
    this.highlightBugEvent(event, idx);
  },

  highlightBugEvent : function (event, idx) {
    this._lineWidgets.forEach(function (widget) {
      var lineIdx = widget.node.getAttribute('idx');
      if (parseInt(lineIdx) === idx) {
        widget.node.classList.add('current');
      }
    });
  },

  setCheckerName : function (checkerName) {
    this._checkerName.innerHTML = checkerName;
  },

  setReviewStatus : function (status) {
    if (status) {
      var className =
        'review-status-' + status.toLowerCase().split(' ').join('-');
      this._reviewStatus.className = "review-status " + className;

      this._reviewStatus.innerHTML = status;
      this._reviewStatusWrapper.style.display = 'block';
    } else {
      this._reviewStatusWrapper.style.display = 'none';
    }
  },

  setSourceFileData : function (file) {
    if (this._sourceFileData && file.id === this._sourceFileData.id) {
      return;
    }

    this._sourceFileData = file;
    this._filepath.innerHTML = file.path;
    this._codeMirror.doc.setValue(file.content);
    this._refresh();
  },

  _refresh : function () {
    var that = this;
    setTimeout(function () {
      var fullHeight = parseInt(that._content.clientHeight);
      var headerHeight = that._filepath.clientHeight;

      that._codeMirror.setSize('auto', fullHeight - headerHeight);
      that._codeMirror.refresh();
    }, 200);
  },

  clearBubbles : function () {
    this._lineWidgets.forEach(function (widget) { widget.clear(); });
    this._lineWidgets = [];
  },

  getMessage : function (event, kind) {
    if (kind === 'macro') {
      var name = 'macro expansion' + (event.name ? ': ' + event.name : '');

      return '<span class="tag macro">' + name + '</span>'
        + this.escapeHTML(event.expansion).replace(/(?:\r\n|\r|\n)/g, '<br>');
    } else if (kind === 'note') {
      return '<span class="tag note">note</span>'
        +  this.escapeHTML(event.message).replace(/(?:\r\n|\r|\n)/g, '<br>');
    }
  },

  addExtraPathEvents : function (events, kind) {
    var that = this;

    if (!events) {
      return;
    }

    events.forEach(function (event) {
      if (event.location.file !== that._currentBugEvent.location.file) {
        return;
      }

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + kind);

      var msg = document.createElement('span');
      msg.innerHTML = that.getMessage(event, kind);
      element.appendChild(msg);

      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  drawBugPath : function () {
    var that = this;

    this.clearBubbles();

    this.addExtraPathEvents(this._currentReport.macros, 'macro');
    this.addExtraPathEvents(this._currentReport.notes, 'note');

    // Processing bug path events.
    var currentEvents = this._currentReport.events;
    currentEvents.forEach(function (event, step) {
      if (event.location.file !== that._currentBugEvent.location.file)
        return;

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';
      var type = step === currentEvents.length - 1 ? 'error' : 'info';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + type);
      element.setAttribute('idx', step);

      var enumeration = document.createElement('span');
      enumeration.setAttribute('class', 'checker-enum ' + type);
      enumeration.innerHTML = step + 1;

      if (currentEvents.length > 1)
        element.appendChild(enumeration);

      var prevBugEvent = step - 1;
      if (step > 0) {
        var prevBug = document.createElement('span');
        prevBug.setAttribute('class', 'arrow left-arrow');
        prevBug.addEventListener('click', function () {
          var event = currentEvents[prevBugEvent];
          that.setCurrentBugEvent(event, prevBugEvent);
        });
        element.appendChild(prevBug);
      }

      var msg = document.createElement('span');
      msg.innerHTML = that.escapeHTML(event.message)
        .replace(/(?:\r\n|\r|\n)/g, '<br>');

      element.appendChild(msg);

      var nextBugEvent = step + 1;
      if (nextBugEvent < currentEvents.length) {
        var nextBug = document.createElement('span');
        nextBug.setAttribute('class', 'arrow right-arrow');
        nextBug.addEventListener('click', function () {
          var event = currentEvents[nextBugEvent];
          that.setCurrentBugEvent(event, nextBugEvent);
        });
        element.appendChild(nextBug);
      }


      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  jumpTo : function (line, column) {
    var that = this;

    setTimeout(function () {
      var selPosPixel
        = that._codeMirror.charCoords({ line : line, ch : column }, 'local');
      var editorSize = {
        width  : that._editor.clientWidth,
        height : that._editor.clientHeight
      };

      that._codeMirror.scrollIntoView({
        top    : selPosPixel.top - 100,
        bottom : selPosPixel.top + editorSize.height - 150,
        left   : selPosPixel.left < editorSize.width - 100
               ? 0
               : selPosPixel.left - 50,
        right  : selPosPixel.left < editorSize.width - 100
               ? 10
               : selPosPixel.left + editorSize.width - 100
      });
    }, 0);
  }
}


      var data = {"files": {"2": {"id": 2, "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/CollectMacros.h", "content": "//===--- CollectMacros.h -----------------------------------------*- C++-*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_TOOLS_EXTRA_CLANGD_COLLECTEDMACROS_H\n#define LLVM_CLANG_TOOLS_EXTRA_CLANGD_COLLECTEDMACROS_H\n\n#include \"AST.h\"\n#include \"Protocol.h\"\n#include \"SourceCode.h\"\n#include \"index/SymbolID.h\"\n#include \"clang/Basic/IdentifierTable.h\"\n#include \"clang/Lex/PPCallbacks.h\"\n#include \"llvm/ADT/DenseMap.h\"\n#include <string>\n\nnamespace clang {\nnamespace clangd {\n\nstruct MacroOccurrence {\n  // Instead of storing SourceLocation, we have to store the token range because\n  // SourceManager from preamble is not available when we build the AST.\n  Range Rng;\n  bool IsDefinition;\n};\n\nstruct MainFileMacros {\n  llvm::StringSet<> Names;\n  llvm::DenseMap<SymbolID, std::vector<MacroOccurrence>> MacroRefs;\n  // Somtimes it is not possible to compute the SymbolID for the Macro, e.g. a\n  // reference to an undefined macro. Store them separately, e.g. for semantic\n  // highlighting.\n  std::vector<MacroOccurrence> UnknownMacros;\n  // Ranges skipped by the preprocessor due to being inactive.\n  std::vector<Range> SkippedRanges;\n};\n\n/// Collects macro references (e.g. definitions, expansions) in the main file.\n/// It is used to:\n///  - collect macros in the preamble section of the main file (in Preamble.cpp)\n///  - collect macros after the preamble of the main file (in ParsedAST.cpp)\nclass CollectMainFileMacros : public PPCallbacks {\npublic:\n  explicit CollectMainFileMacros(const SourceManager &SM, MainFileMacros &Out)\n      : SM(SM), Out(Out) {}\n\n  void FileChanged(SourceLocation Loc, FileChangeReason,\n                   SrcMgr::CharacteristicKind, FileID) override {\n    InMainFile = isInsideMainFile(Loc, SM);\n  }\n\n  void MacroDefined(const Token &MacroName, const MacroDirective *MD) override {\n    add(MacroName, MD->getMacroInfo(), /*IsDefinition=*/true);\n  }\n\n  void MacroExpands(const Token &MacroName, const MacroDefinition &MD,\n                    SourceRange Range, const MacroArgs *Args) override {\n    add(MacroName, MD.getMacroInfo());\n  }\n\n  void MacroUndefined(const clang::Token &MacroName,\n                      const clang::MacroDefinition &MD,\n                      const clang::MacroDirective *Undef) override {\n    add(MacroName, MD.getMacroInfo());\n  }\n\n  void Ifdef(SourceLocation Loc, const Token &MacroName,\n             const MacroDefinition &MD) override {\n    add(MacroName, MD.getMacroInfo());\n  }\n\n  void Ifndef(SourceLocation Loc, const Token &MacroName,\n              const MacroDefinition &MD) override {\n    add(MacroName, MD.getMacroInfo());\n  }\n\n  void Defined(const Token &MacroName, const MacroDefinition &MD,\n               SourceRange Range) override {\n    add(MacroName, MD.getMacroInfo());\n  }\n\n  void SourceRangeSkipped(SourceRange R, SourceLocation EndifLoc) override {\n    if (!InMainFile)\n      return;\n    Position Begin = sourceLocToPosition(SM, R.getBegin());\n    Position End = sourceLocToPosition(SM, R.getEnd());\n    Out.SkippedRanges.push_back(Range{Begin, End});\n  }\n\nprivate:\n  void add(const Token &MacroNameTok, const MacroInfo *MI,\n           bool IsDefinition = false);\n  const SourceManager &SM;\n  bool InMainFile = true;\n  MainFileMacros &Out;\n};\n\n} // namespace clangd\n} // namespace clang\n\n#endif // LLVM_CLANG_TOOLS_EXTRA_CLANGD_COLLECTEDMACROS_H\n"}, "3": {"id": 3, "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/ExpectedTypes.h", "content": "//===--- ExpectedTypes.h - Simplified C++ types -----------------*- C++-*--===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n// A simplified model of C++ types that can be used to check whether they are\n// convertible between each other for the purposes of code completion ranking\n// without looking at the ASTs. Note that we don't aim to fully mimic the C++\n// conversion rules, merely try to have a model that gives useful improvements\n// to the code completion ranking.\n//\n// We define an encoding of AST types as opaque strings, which can be stored in\n// the index. Similar types (such as `int` and `long`) are folded together,\n// forming equivalence classes with the same encoding.\n//===----------------------------------------------------------------------===//\n#ifndef LLVM_CLANG_TOOLS_EXTRA_CLANGD_EXPECTED_TYPES_H\n#define LLVM_CLANG_TOOLS_EXTRA_CLANGD_EXPECTED_TYPES_H\n\n#include \"clang/AST/Type.h\"\n#include \"llvm/ADT/StringRef.h\"\n\nnamespace clang {\nclass CodeCompletionResult;\n\nnamespace clangd {\n/// A representation of a type that can be computed based on clang AST and\n/// compared for equality. The encoding is stable between different ASTs, this\n/// allows the representation to be stored in the index and compared with types\n/// coming from a different AST later.\n/// OpaqueType is a strongly-typedefed std::string, you can get the underlying\n/// string with raw().\nclass OpaqueType {\npublic:\n  /// Create a type from a code completion result.\n  static llvm::Optional<OpaqueType>\n  fromCompletionResult(ASTContext &Ctx, const CodeCompletionResult &R);\n  /// Construct an instance from a clang::QualType. This is usually a\n  /// PreferredType from a clang's completion context.\n  static llvm::Optional<OpaqueType> fromType(ASTContext &Ctx, QualType Type);\n\n  /// Get the raw byte representation of the type. You can only rely on the\n  /// types being equal iff their raw representation is the same. The particular\n  /// details of the used encoding might change over time and one should not\n  /// rely on it.\n  llvm::StringRef raw() const { return Data; }\n\n  friend bool operator==(const OpaqueType &L, const OpaqueType &R) {\n    return L.Data == R.Data;\n  }\n  friend bool operator!=(const OpaqueType &L, const OpaqueType &R) {\n    return !(L == R);\n  }\n\nprivate:\n  static llvm::Optional<OpaqueType> encode(ASTContext &Ctx, QualType Type);\n  explicit OpaqueType(std::string Data);\n\n  std::string Data;\n};\n} // namespace clangd\n} // namespace clang\n#endif\n"}, "4": {"id": 4, "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/HeuristicResolver.h", "content": "//===--- HeuristicResolver.h - Resolution of dependent names -----*- C++-*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_TOOLS_EXTRA_CLANGD_HEURISTIC_RESOLVER_H\n#define LLVM_CLANG_TOOLS_EXTRA_CLANGD_HEURISTIC_RESOLVER_H\n\n#include \"clang/AST/Decl.h\"\n#include \"llvm/ADT/STLExtras.h\"\n#include <vector>\n\nnamespace clang {\n\nclass ASTContext;\nclass CallExpr;\nclass CXXDependentScopeMemberExpr;\nclass DeclarationName;\nclass DependentScopeDeclRefExpr;\nclass NamedDecl;\nclass Type;\nclass UnresolvedUsingValueDecl;\n\nnamespace clangd {\n\n// This class heuristic resolution of declarations and types in template code.\n//\n// As a compiler, clang only needs to perform certain types of processing on\n// template code (such as resolving dependent names to declarations, or\n// resolving the type of a dependent expression) after instantiation. Indeed,\n// C++ language features such as template specialization mean such resolution\n// cannot be done accurately before instantiation\n//\n// However, template code is written and read in uninstantiated form, and clangd\n// would like to provide editor features like go-to-definition in template code\n// where possible. To this end, clangd attempts to resolve declarations and\n// types in uninstantiated code by using heuristics, understanding that the\n// results may not be fully accurate but that this is better than nothing.\n//\n// At this time, the heuristic used is a simple but effective one: assume that\n// template instantiations are based on the primary template definition and not\n// not a specialization. More advanced heuristics may be added in the future.\nclass HeuristicResolver {\npublic:\n  HeuristicResolver(ASTContext &Ctx) : Ctx(Ctx) {}\n\n  // Try to heuristically resolve certain types of expressions, declarations, or\n  // types to one or more likely-referenced declarations.\n  std::vector<const NamedDecl *>\n  resolveMemberExpr(const CXXDependentScopeMemberExpr *ME) const;\n  std::vector<const NamedDecl *>\n  resolveDeclRefExpr(const DependentScopeDeclRefExpr *RE) const;\n  std::vector<const NamedDecl *> resolveCallExpr(const CallExpr *CE) const;\n  std::vector<const NamedDecl *>\n  resolveUsingValueDecl(const UnresolvedUsingValueDecl *UUVD) const;\n  std::vector<const NamedDecl *>\n  resolveDependentNameType(const DependentNameType *DNT) const;\n  std::vector<const NamedDecl *> resolveTemplateSpecializationType(\n      const DependentTemplateSpecializationType *DTST) const;\n\n  // Try to heuristically resolve a dependent nested name specifier\n  // to the type it likely denotes. Note that *dependent* name specifiers always\n  // denote types, not namespaces.\n  const Type *\n  resolveNestedNameSpecifierToType(const NestedNameSpecifier *NNS) const;\n\nprivate:\n  ASTContext &Ctx;\n\n  // Given a tag-decl type and a member name, heuristically resolve the\n  // name to one or more declarations.\n  // The current heuristic is simply to look up the name in the primary\n  // template. This is a heuristic because the template could potentially\n  // have specializations that declare different members.\n  // Multiple declarations could be returned if the name is overloaded\n  // (e.g. an overloaded method in the primary template).\n  // This heuristic will give the desired answer in many cases, e.g.\n  // for a call to vector<T>::size().\n  std::vector<const NamedDecl *> resolveDependentMember(\n      const Type *T, DeclarationName Name,\n      llvm::function_ref<bool(const NamedDecl *ND)> Filter) const;\n\n  // Try to heuristically resolve the type of a possibly-dependent expression\n  // `E`.\n  const Type *resolveExprToType(const Expr *E) const;\n\n  // Given the type T of a dependent expression that appears of the LHS of a\n  // \"->\", heuristically find a corresponding pointee type in whose scope we\n  // could look up the name appearing on the RHS.\n  const Type *getPointeeType(const Type *T) const;\n};\n\n} // namespace clangd\n} // namespace clang\n\n#endif\n"}, "5": {"id": 5, "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/URI.h", "content": "//===--- URI.h - File URIs with schemes --------------------------*- C++-*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_TOOLS_EXTRA_CLANGD_PATHURI_H\n#define LLVM_CLANG_TOOLS_EXTRA_CLANGD_PATHURI_H\n\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/Support/Error.h\"\n#include \"llvm/Support/Registry.h\"\n\nnamespace clang {\nnamespace clangd {\n\n/// A URI describes the location of a source file.\n/// In the simplest case, this is a \"file\" URI that directly encodes the\n/// absolute path to a file. More abstract cases are possible: a shared index\n/// service might expose repo:// URIs that are relative to the source control\n/// root.\n///\n/// Clangd handles URIs of the form <scheme>:[//<authority>]<body>. It doesn't\n/// further split the authority or body into constituent parts (e.g. query\n/// strings is included in the body).\nclass URI {\npublic:\n  URI(llvm::StringRef Scheme, llvm::StringRef Authority, llvm::StringRef Body);\n\n  /// Returns decoded scheme e.g. \"https\"\n  llvm::StringRef scheme() const { return Scheme; }\n  /// Returns decoded authority e.g. \"reviews.lvm.org\"\n  llvm::StringRef authority() const { return Authority; }\n  /// Returns decoded body e.g. \"/D41946\"\n  llvm::StringRef body() const { return Body; }\n\n  /// Returns a string URI with all components percent-encoded.\n  std::string toString() const;\n\n  /// Creates a URI for a file in the given scheme. \\p Scheme must be\n  /// registered. The URI is percent-encoded.\n  static llvm::Expected<URI> create(llvm::StringRef AbsolutePath,\n                                    llvm::StringRef Scheme);\n\n  // Similar to above except this picks a registered scheme that works. If none\n  // works, this falls back to \"file\" scheme.\n  static URI create(llvm::StringRef AbsolutePath);\n\n  /// This creates a file:// URI for \\p AbsolutePath. The path must be absolute.\n  static URI createFile(llvm::StringRef AbsolutePath);\n\n  /// Parse a URI string \"<scheme>:[//<authority>/]<path>\". Percent-encoded\n  /// characters in the URI will be decoded.\n  static llvm::Expected<URI> parse(llvm::StringRef Uri);\n\n  /// Resolves the absolute path of \\p U. If there is no matching scheme, or the\n  /// URI is invalid in the scheme, this returns an error.\n  ///\n  /// \\p HintPath A related path, such as the current file or working directory,\n  /// which can help disambiguate when the same file exists in many workspaces.\n  static llvm::Expected<std::string> resolve(const URI &U,\n                                             llvm::StringRef HintPath = \"\");\n\n  /// Same as above, in addition it parses the \\p FileURI using URI::parse.\n  static llvm::Expected<std::string> resolve(llvm::StringRef FileURI,\n                                             llvm::StringRef HintPath = \"\");\n\n  /// Resolves \\p AbsPath into a canonical path of its URI, by converting\n  /// \\p AbsPath to URI and resolving the URI to get th canonical path.\n  /// This ensures that paths with the same URI are resolved into consistent\n  /// file path.\n  static llvm::Expected<std::string> resolvePath(llvm::StringRef AbsPath,\n                                                 llvm::StringRef HintPath = \"\");\n\n  /// Gets the preferred spelling of this file for #include, if there is one,\n  /// e.g. <system_header.h>, \"path/to/x.h\".\n  ///\n  /// This allows URI schemas to provide their customized include paths.\n  ///\n  /// Returns an empty string if normal include-shortening based on the absolute\n  /// path should be used.\n  /// Fails if the URI is not valid in the schema.\n  static llvm::Expected<std::string> includeSpelling(const URI &U);\n\n  friend bool operator==(const URI &LHS, const URI &RHS) {\n    return std::tie(LHS.Scheme, LHS.Authority, LHS.Body) ==\n           std::tie(RHS.Scheme, RHS.Authority, RHS.Body);\n  }\n\n  friend bool operator<(const URI &LHS, const URI &RHS) {\n    return std::tie(LHS.Scheme, LHS.Authority, LHS.Body) <\n           std::tie(RHS.Scheme, RHS.Authority, RHS.Body);\n  }\n\nprivate:\n  URI() = default;\n\n  std::string Scheme;\n  std::string Authority;\n  std::string Body;\n};\n\n/// URIScheme is an extension point for teaching clangd to recognize a custom\n/// URI scheme. This is expected to be implemented and exposed via the\n/// URISchemeRegistry.\nclass URIScheme {\npublic:\n  virtual ~URIScheme() = default;\n\n  /// Returns the absolute path of the file corresponding to the URI\n  /// authority+body in the file system. See URI::resolve for semantics of\n  /// \\p HintPath.\n  virtual llvm::Expected<std::string>\n  getAbsolutePath(llvm::StringRef Authority, llvm::StringRef Body,\n                  llvm::StringRef HintPath) const = 0;\n\n  virtual llvm::Expected<URI>\n  uriFromAbsolutePath(llvm::StringRef AbsolutePath) const = 0;\n\n  /// Returns the include path of the file (e.g. <path>, \"path\"), which can be\n  /// #included directly. See URI::includeSpelling for details.\n  virtual llvm::Expected<std::string> getIncludeSpelling(const URI &U) const {\n    return \"\"; // no customized include path for this scheme.\n  }\n};\n\n/// By default, a \"file\" scheme is supported where URI paths are always absolute\n/// in the file system.\ntypedef llvm::Registry<URIScheme> URISchemeRegistry;\n\n} // namespace clangd\n} // namespace clang\n\n#endif // LLVM_CLANG_TOOLS_EXTRA_CLANGD_PATHURI_H\n"}, "6": {"id": 6, "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/index/BackgroundRebuild.h", "content": "//===--- BackgroundIndexRebuild.h - when to rebuild the bg index--*- C++-*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file contains an implementation detail of the background indexer\n// (Background.h), which is exposed for testing.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_TOOLS_EXTRA_CLANGD_INDEX_BACKGROUND_INDEX_REBUILD_H\n#define LLVM_CLANG_TOOLS_EXTRA_CLANGD_INDEX_BACKGROUND_INDEX_REBUILD_H\n\n#include \"index/FileIndex.h\"\n#include \"index/Index.h\"\n#include \"llvm/Support/Threading.h\"\n#include <cstddef>\n\nnamespace clang {\nnamespace clangd {\n\n// The BackgroundIndexRebuilder builds the serving data structures periodically\n// in response to events in the background indexer. The goal is to ensure the\n// served data stays fairly fresh, without wasting lots of CPU rebuilding it\n// often.\n//\n// The index is always built after a set of shards are loaded from disk.\n// This happens when clangd discovers a compilation database that we've\n// previously built an index for. It's a fairly fast process that yields lots\n// of data, so we wait to get all of it.\n//\n// The index is built after indexing a few translation units, if it wasn't built\n// already. This ensures quick startup if there's no existing index.\n// Waiting for a few random TUs yields coverage of the most common headers.\n//\n// The index is rebuilt every N TUs, to keep if fresh as files are indexed.\n//\n// The index is rebuilt every time the queue goes idle, if it's stale.\n//\n// All methods are threadsafe. They're called after FileSymbols is updated\n// etc. Without external locking, the rebuilt index may include more updates\n// than intended, which is fine.\n//\n// This class is exposed in the header so it can be tested.\nclass BackgroundIndexRebuilder {\npublic:\n  BackgroundIndexRebuilder(SwapIndex *Target, FileSymbols *Source,\n                           unsigned Threads)\n      : TUsBeforeFirstBuild(Threads), Target(Target), Source(Source) {}\n\n  // Called to indicate a TU has been indexed.\n  // May rebuild, if enough TUs have been indexed.\n  void indexedTU();\n  // Called to indicate that all worker threads are idle.\n  // May reindex, if the index is not up to date.\n  void idle();\n  // Called to indicate we're going to load a batch of shards from disk.\n  // startLoading() and doneLoading() must be paired, but multiple loading\n  // sessions may happen concurrently.\n  void startLoading();\n  // Called to indicate some shards were actually loaded from disk.\n  void loadedShard(size_t ShardCount);\n  // Called to indicate we're finished loading shards from disk.\n  // May rebuild (if any were loaded).\n  void doneLoading();\n\n  // Ensures we won't start any more rebuilds.\n  void shutdown();\n\n  // Thresholds for rebuilding as TUs get indexed. Exposed for testing.\n  const unsigned TUsBeforeFirstBuild; // Typically one per worker thread.\n  const unsigned TUsBeforeRebuild = 100;\n\nprivate:\n  // Run Check under the lock, and rebuild if it returns true.\n  void maybeRebuild(const char *Reason, std::function<bool()> Check);\n  bool enoughTUsToRebuild() const;\n\n  // All transient state is guarded by the mutex.\n  std::mutex Mu;\n  bool ShouldStop = false;\n  // Index builds are versioned. ActiveVersion chases StartedVersion.\n  unsigned StartedVersion = 0;\n  unsigned ActiveVersion = 0;\n  // How many TUs have we indexed so far since startup?\n  unsigned IndexedTUs = 0;\n  unsigned IndexedTUsAtLastRebuild = 0;\n  // Are we loading shards? May be multiple concurrent sessions.\n  unsigned Loading = 0;\n  unsigned LoadedShards; // In the current loading session.\n\n  SwapIndex *Target;\n  FileSymbols *Source;\n};\n\n} // namespace clangd\n} // namespace clang\n\n#endif\n"}, "7": {"id": 7, "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/index/CanonicalIncludes.h", "content": "//===-- CanonicalIncludes.h - remap #include header -------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// At indexing time, we decide which file to #included for a symbol.\n// Usually this is the file with the canonical decl, but there are exceptions:\n// - private headers may have pragmas pointing to the matching public header.\n//   (These are \"IWYU\" pragmas, named after the include-what-you-use tool).\n// - the standard library is implemented in many files, without any pragmas.\n//   We have a lookup table for common standard library implementations.\n//   libstdc++ puts char_traits in bits/char_traits.h, but we #include <string>.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_TOOLS_EXTRA_CLANGD_INDEX_CANONICALINCLUDES_H\n#define LLVM_CLANG_TOOLS_EXTRA_CLANGD_INDEX_CANONICALINCLUDES_H\n\n#include \"clang/Lex/Preprocessor.h\"\n#include \"llvm/ADT/StringMap.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/Support/Regex.h\"\n#include <mutex>\n#include <string>\n#include <vector>\n\nnamespace clang {\nnamespace clangd {\n\n/// Maps a definition location onto an #include file, based on a set of filename\n/// rules.\n/// Only const methods (i.e. mapHeader) in this class are thread safe.\nclass CanonicalIncludes {\npublic:\n  /// Adds a string-to-string mapping from \\p Path to \\p CanonicalPath.\n  void addMapping(llvm::StringRef Path, llvm::StringRef CanonicalPath);\n\n  /// Returns the overridden include for symbol with \\p QualifiedName, or \"\".\n  llvm::StringRef mapSymbol(llvm::StringRef QualifiedName) const;\n\n  /// Returns the overridden include for for files in \\p Header, or \"\".\n  llvm::StringRef mapHeader(llvm::StringRef Header) const;\n\n  /// Adds mapping for system headers and some special symbols (e.g. STL symbols\n  /// in <iosfwd> need to be mapped individually). Approximately, the following\n  /// system headers are handled:\n  ///   - C++ standard library e.g. bits/basic_string.h$ -> <string>\n  ///   - Posix library e.g. bits/pthreadtypes.h$ -> <pthread.h>\n  ///   - Compiler extensions, e.g. include/avx512bwintrin.h$ -> <immintrin.h>\n  /// The mapping is hardcoded and hand-maintained, so it might not cover all\n  /// headers.\n  void addSystemHeadersMapping(const LangOptions &Language);\n\nprivate:\n  /// A map from full include path to a canonical path.\n  llvm::StringMap<std::string> FullPathMapping;\n  /// A map from a suffix (one or components of a path) to a canonical path.\n  /// Used only for mapping standard headers.\n  const llvm::StringMap<llvm::StringRef> *StdSuffixHeaderMapping = nullptr;\n  /// A map from fully qualified symbol names to header names.\n  /// Used only for mapping standard symbols.\n  const llvm::StringMap<llvm::StringRef> *StdSymbolMapping = nullptr;\n};\n\n/// Returns a CommentHandler that parses pragma comment on include files to\n/// determine when we should include a different header from the header that\n/// directly defines a symbol. Mappinps are registered with \\p Includes.\n///\n/// Currently it only supports IWYU private pragma:\n/// https://github.com/include-what-you-use/include-what-you-use/blob/master/docs/IWYUPragmas.md#iwyu-pragma-private\n///\n/// We ignore other pragmas:\n/// - keep: this is common but irrelevant: we do not currently remove includes\n/// - export: this is common and potentially interesting, there are three cases:\n///    * Points to a public header (common): we can suppress include2 if you\n///      already have include1. Only marginally useful.\n///    * Points to a private header annotated with `private` (somewhat commmon):\n///      Not incrementally useful as we support private.\n///    * Points to a private header without pragmas (rare). This is a reversed\n///      private pragma, and is valuable but too rare to be worthwhile.\n/// - no_include: this is about as common as private, but only affects the\n///   current file, so the value is smaller. We could add support.\n/// - friend: this is less common than private, has implementation difficulties,\n///   and affects behavior in a limited scope.\n/// - associated: extremely rare\nstd::unique_ptr<CommentHandler>\ncollectIWYUHeaderMaps(CanonicalIncludes *Includes);\n\n} // namespace clangd\n} // namespace clang\n\n#endif // LLVM_CLANG_TOOLS_EXTRA_CLANGD_INDEX_HEADERMAPCOLLECTOR_H\n"}, "8": {"id": 8, "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/index/Serialization.h", "content": "//===--- Serialization.h - Binary serialization of index data ----*- C++-*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file provides serialization of indexed symbols and other data.\n//\n// It writes sections:\n//  - metadata such as version info\n//  - a string table (which is compressed)\n//  - lists of encoded symbols\n//\n// The format has a simple versioning scheme: the format version number is\n// written in the file and non-current versions are rejected when reading.\n//\n// Human-readable YAML serialization is also supported, and recommended for\n// debugging and experiments only.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_TOOLS_EXTRA_CLANGD_INDEX_RIFF_H\n#define LLVM_CLANG_TOOLS_EXTRA_CLANGD_INDEX_RIFF_H\n\n#include \"Headers.h\"\n#include \"Index.h\"\n#include \"index/Symbol.h\"\n#include \"clang/Tooling/CompilationDatabase.h\"\n#include \"llvm/Support/Error.h\"\n\nnamespace clang {\nnamespace clangd {\n\nenum class IndexFileFormat {\n  RIFF, // Versioned binary format, suitable for production use.\n  YAML, // Human-readable format, suitable for experiments and debugging.\n};\n\n// Holds the contents of an index file that was read.\nstruct IndexFileIn {\n  llvm::Optional<SymbolSlab> Symbols;\n  llvm::Optional<RefSlab> Refs;\n  llvm::Optional<RelationSlab> Relations;\n  // Keys are URIs of the source files.\n  llvm::Optional<IncludeGraph> Sources;\n  // This contains only the Directory and CommandLine.\n  llvm::Optional<tooling::CompileCommand> Cmd;\n};\n// Parse an index file. The input must be a RIFF or YAML file.\nllvm::Expected<IndexFileIn> readIndexFile(llvm::StringRef);\n\n// Specifies the contents of an index file to be written.\nstruct IndexFileOut {\n  const SymbolSlab *Symbols = nullptr;\n  const RefSlab *Refs = nullptr;\n  const RelationSlab *Relations = nullptr;\n  // Keys are URIs of the source files.\n  const IncludeGraph *Sources = nullptr;\n  // TODO: Support serializing Dex posting lists.\n  IndexFileFormat Format = IndexFileFormat::RIFF;\n  const tooling::CompileCommand *Cmd = nullptr;\n\n  IndexFileOut() = default;\n  IndexFileOut(const IndexFileIn &I)\n      : Symbols(I.Symbols ? I.Symbols.getPointer() : nullptr),\n        Refs(I.Refs ? I.Refs.getPointer() : nullptr),\n        Relations(I.Relations ? I.Relations.getPointer() : nullptr),\n        Sources(I.Sources ? I.Sources.getPointer() : nullptr),\n        Cmd(I.Cmd ? I.Cmd.getPointer() : nullptr) {}\n};\n// Serializes an index file.\nllvm::raw_ostream &operator<<(llvm::raw_ostream &OS, const IndexFileOut &O);\n\n// Convert a single symbol to YAML, a nice debug representation.\nstd::string toYAML(const Symbol &);\nstd::string toYAML(const std::pair<SymbolID, ArrayRef<Ref>> &);\nstd::string toYAML(const Relation &);\nstd::string toYAML(const Ref &);\n\n// Deserialize a single symbol from YAML.\nllvm::Expected<clangd::Symbol> symbolFromYAML(StringRef YAML,\n                                              llvm::UniqueStringSaver *Strings);\nllvm::Expected<clangd::Ref> refFromYAML(StringRef YAML,\n                                        llvm::UniqueStringSaver *Strings);\n\n// Build an in-memory static index from an index file.\n// The size should be relatively small, so data can be managed in memory.\nstd::unique_ptr<SymbolIndex> loadIndex(llvm::StringRef Filename,\n                                       bool UseDex = true);\n\n} // namespace clangd\n} // namespace clang\n\n#endif\n"}, "9": {"id": 9, "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/index/SymbolLocation.h", "content": "//===--- SymbolLocation.h ----------------------------------------*- C++-*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_TOOLS_EXTRA_CLANGD_INDEX_SYMBOL_LOCATION_H\n#define LLVM_CLANG_TOOLS_EXTRA_CLANGD_INDEX_SYMBOL_LOCATION_H\n\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/Support/raw_ostream.h\"\n#include <cstdint>\n\nnamespace clang {\nnamespace clangd {\n\nstruct SymbolLocation {\n  // Specify a position (Line, Column) of symbol. Using Line/Column allows us to\n  // build LSP responses without reading the file content.\n  //\n  // clangd uses the following definitions, which differ slightly from LSP:\n  //  - Line is the number of newline characters (\\n) before the point.\n  //  - Column is (by default) the number of UTF-16 code between the last \\n\n  //    (or start of file) and the point.\n  //    If the `offsetEncoding` protocol extension is used to negotiate UTF-8,\n  //    then it is instead the number of *bytes* since the last \\n.\n  //\n  // Position is encoded into 32 bits to save space.\n  // If Line/Column overflow, the value will be their maximum value.\n  struct Position {\n    Position() : LineColumnPacked(0) {}\n    void setLine(uint32_t Line);\n    uint32_t line() const { return LineColumnPacked >> ColumnBits; }\n    void setColumn(uint32_t Column);\n    uint32_t column() const { return LineColumnPacked & MaxColumn; }\n    uint32_t rep() const { return LineColumnPacked; }\n\n    bool hasOverflow() const {\n      return line() == MaxLine || column() == MaxColumn;\n    }\n\n    static constexpr unsigned ColumnBits = 12;\n    static constexpr uint32_t MaxLine = (1 << (32 - ColumnBits)) - 1;\n    static constexpr uint32_t MaxColumn = (1 << ColumnBits) - 1;\n\n  private:\n    uint32_t LineColumnPacked; // Top 20 bit line, bottom 12 bits column.\n  };\n\n  /// The symbol range, using half-open range [Start, End).\n  Position Start;\n  Position End;\n\n  explicit operator bool() const { return !llvm::StringRef(FileURI).empty(); }\n\n  // The URI of the source file where a symbol occurs.\n  // The string must be null-terminated.\n  //\n  // We avoid using llvm::StringRef here to save memory.\n  // WARNING: unless you know what you are doing, it is recommended to use it\n  // via llvm::StringRef.\n  const char *FileURI = \"\";\n};\n\ninline bool operator==(const SymbolLocation::Position &L,\n                       const SymbolLocation::Position &R) {\n  return std::make_tuple(L.line(), L.column()) ==\n         std::make_tuple(R.line(), R.column());\n}\ninline bool operator<(const SymbolLocation::Position &L,\n                      const SymbolLocation::Position &R) {\n  return std::make_tuple(L.line(), L.column()) <\n         std::make_tuple(R.line(), R.column());\n}\ninline bool operator==(const SymbolLocation &L, const SymbolLocation &R) {\n  assert(L.FileURI && R.FileURI);\n  return !std::strcmp(L.FileURI, R.FileURI) &&\n         std::tie(L.Start, L.End) == std::tie(R.Start, R.End);\n}\ninline bool operator<(const SymbolLocation &L, const SymbolLocation &R) {\n  assert(L.FileURI && R.FileURI);\n  int Cmp = std::strcmp(L.FileURI, R.FileURI);\n  if (Cmp != 0)\n    return Cmp < 0;\n  return std::tie(L.Start, L.End) < std::tie(R.Start, R.End);\n}\n\nllvm::raw_ostream &operator<<(llvm::raw_ostream &, const SymbolLocation &);\n\n} // namespace clangd\n} // namespace clang\n\n#endif // LLVM_CLANG_TOOLS_EXTRA_CLANGD_INDEX_SYMBOL_LOCATION_H\n"}, "10": {"id": 10, "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/index/SymbolOrigin.h", "content": "//===--- SymbolOrigin.h ------------------------------------------*- C++-*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_TOOLS_EXTRA_CLANGD_INDEX_SYMBOL_ORIGIN_H\n#define LLVM_CLANG_TOOLS_EXTRA_CLANGD_INDEX_SYMBOL_ORIGIN_H\n\n#include \"llvm/Support/raw_ostream.h\"\n#include <cstdint>\n\nnamespace clang {\nnamespace clangd {\n\n// Describes the source of information about a symbol.\n// Mainly useful for debugging, e.g. understanding code completion results.\n// This is a bitfield as information can be combined from several sources.\nenum class SymbolOrigin : uint8_t {\n  Unknown = 0,\n  AST = 1 << 0,        // Directly from the AST (indexes should not set this).\n  Dynamic = 1 << 1,    // From the dynamic index of opened files.\n  Static = 1 << 2,     // From the static, externally-built index.\n  Merge = 1 << 3,      // A non-trivial index merge was performed.\n  Identifier = 1 << 4, // Raw identifiers in file.\n  Remote = 1 << 5,     // Remote index.\n  // Remaining bits reserved for index implementations.\n};\n\ninline SymbolOrigin operator|(SymbolOrigin A, SymbolOrigin B) {\n  return static_cast<SymbolOrigin>(static_cast<uint8_t>(A) |\n                                   static_cast<uint8_t>(B));\n}\ninline SymbolOrigin &operator|=(SymbolOrigin &A, SymbolOrigin B) {\n  return A = A | B;\n}\ninline SymbolOrigin operator&(SymbolOrigin A, SymbolOrigin B) {\n  return static_cast<SymbolOrigin>(static_cast<uint8_t>(A) &\n                                   static_cast<uint8_t>(B));\n}\n\nllvm::raw_ostream &operator<<(llvm::raw_ostream &, SymbolOrigin);\n\n} // namespace clangd\n} // namespace clang\n\n#endif // LLVM_CLANG_TOOLS_EXTRA_CLANGD_INDEX_SYMBOL_ORIGIN_H\n"}, "11": {"id": 11, "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/refactor/Tweak.h", "content": "//===--- Tweak.h -------------------------------------------------*- C++-*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n// Tweaks are small actions that run over the AST and produce edits, messages\n// etc as a result. They are local, i.e. they should take the current editor\n// context, e.g. the cursor position and selection into account.\n// The actions are executed in two stages:\n//   - Stage 1 should check whether the action is available in a current\n//     context. It should be cheap and fast to compute as it is executed for all\n//     available actions on every client request, which happen quite frequently.\n//   - Stage 2 is performed after stage 1 and can be more expensive to compute.\n//     It is performed when the user actually chooses the action.\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_TOOLS_EXTRA_CLANGD_REFACTOR_ACTIONS_TWEAK_H\n#define LLVM_CLANG_TOOLS_EXTRA_CLANGD_REFACTOR_ACTIONS_TWEAK_H\n\n#include \"ParsedAST.h\"\n#include \"Protocol.h\"\n#include \"Selection.h\"\n#include \"SourceCode.h\"\n#include \"index/Index.h\"\n#include \"support/Path.h\"\n#include \"clang/Tooling/Core/Replacement.h\"\n#include \"llvm/ADT/Optional.h\"\n#include \"llvm/ADT/StringMap.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/Support/Error.h\"\n#include <string>\n\nnamespace clang {\nnamespace clangd {\n\n/// An interface base for small context-sensitive refactoring actions.\n/// To implement a new tweak use the following pattern in a .cpp file:\n///   class MyTweak : public Tweak {\n///   public:\n///     const char* id() const override final; // defined by REGISTER_TWEAK.\n///     // implement other methods here.\n///   };\n///   REGISTER_TWEAK(MyTweak);\nclass Tweak {\npublic:\n  /// Input to prepare and apply tweaks.\n  struct Selection {\n    Selection(const SymbolIndex *Index, ParsedAST &AST, unsigned RangeBegin,\n              unsigned RangeEnd, SelectionTree ASTSelection);\n    /// The text of the active document.\n    llvm::StringRef Code;\n    /// The Index for handling codebase related queries.\n    const SymbolIndex *Index = nullptr;\n    /// The parsed active file. Never null. (Pointer so Selection is movable).\n    ParsedAST *AST;\n    /// A location of the cursor in the editor.\n    // FIXME: Cursor is redundant and should be removed\n    SourceLocation Cursor;\n    /// The begin offset of the selection\n    unsigned SelectionBegin;\n    /// The end offset of the selection\n    unsigned SelectionEnd;\n    /// The AST nodes that were selected.\n    SelectionTree ASTSelection;\n    // FIXME: provide a way to get sources and ASTs for other files.\n  };\n\n  struct Effect {\n    /// A message to be displayed to the user.\n    llvm::Optional<std::string> ShowMessage;\n    FileEdits ApplyEdits;\n\n    static Effect showMessage(StringRef S) {\n      Effect E;\n      E.ShowMessage = std::string(S);\n      return E;\n    }\n\n    /// Path is the absolute, symlink-resolved path for the file pointed by FID\n    /// in SM. Edit is generated from Replacements.\n    /// Fails if cannot figure out absolute path for FID.\n    static llvm::Expected<std::pair<Path, Edit>>\n    fileEdit(const SourceManager &SM, FileID FID,\n             tooling::Replacements Replacements);\n\n    /// Creates an effect with an Edit for the main file.\n    /// Fails if cannot figure out absolute path for main file.\n    static llvm::Expected<Tweak::Effect>\n    mainFileEdit(const SourceManager &SM, tooling::Replacements Replacements);\n  };\n\n  virtual ~Tweak() = default;\n  /// A unique id of the action, it is always equal to the name of the class\n  /// defining the Tweak. Definition is provided automatically by\n  /// REGISTER_TWEAK.\n  virtual const char *id() const = 0;\n  /// Run the first stage of the action. Returns true indicating that the\n  /// action is available and should be shown to the user. Returns false if the\n  /// action is not available.\n  /// This function should be fast, if the action requires non-trivial work it\n  /// should be moved into 'apply'.\n  /// Returns true iff the action is available and apply() can be called on it.\n  virtual bool prepare(const Selection &Sel) = 0;\n  /// Run the second stage of the action that would produce the actual effect.\n  /// EXPECTS: prepare() was called and returned true.\n  virtual Expected<Effect> apply(const Selection &Sel) = 0;\n\n  /// A one-line title of the action that should be shown to the users in the\n  /// UI.\n  /// EXPECTS: prepare() was called and returned true.\n  virtual std::string title() const = 0;\n  /// Describes what kind of action this is.\n  /// EXPECTS: prepare() was called and returned true.\n  virtual llvm::StringLiteral kind() const = 0;\n  /// Is this a 'hidden' tweak, which are off by default.\n  virtual bool hidden() const { return false; }\n};\n\n// All tweaks must be registered in the .cpp file next to their definition.\n#define REGISTER_TWEAK(Subclass)                                               \\\n  ::llvm::Registry<::clang::clangd::Tweak>::Add<Subclass>                      \\\n      TweakRegistrationFor##Subclass(#Subclass, /*Description=*/\"\");           \\\n  const char *Subclass::id() const { return #Subclass; }\n\n/// Calls prepare() on all tweaks that satisfy the filter, returning those that\n/// can run on the selection.\nstd::vector<std::unique_ptr<Tweak>>\nprepareTweaks(const Tweak::Selection &S,\n              llvm::function_ref<bool(const Tweak &)> Filter);\n\n// Calls prepare() on the tweak with a given ID.\n// If prepare() returns false, returns an error.\n// If prepare() returns true, returns the corresponding tweak.\nllvm::Expected<std::unique_ptr<Tweak>> prepareTweak(StringRef TweakID,\n                                                    const Tweak::Selection &S);\n} // namespace clangd\n} // namespace clang\n\n#endif\n"}, "12": {"id": 12, "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/unittests/Matchers.h", "content": "//===-- Matchers.h ----------------------------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// GMock matchers that aren't specific to particular tests.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_CLANG_TOOLS_EXTRA_UNITTESTS_CLANGD_MATCHERS_H\n#define LLVM_CLANG_TOOLS_EXTRA_UNITTESTS_CLANGD_MATCHERS_H\n#include \"Protocol.h\"\n#include \"gmock/gmock.h\"\n\nnamespace clang {\nnamespace clangd {\nusing ::testing::Matcher;\n\n// EXPECT_IFF expects matcher if condition is true, and Not(matcher) if false.\n// This is hard to write as a function, because matchers may be polymorphic.\n#define EXPECT_IFF(condition, value, matcher)                                  \\\n  do {                                                                         \\\n    if (condition)                                                             \\\n      EXPECT_THAT(value, matcher);                                             \\\n    else                                                                       \\\n      EXPECT_THAT(value, ::testing::Not(matcher));                             \\\n  } while (0)\n\n// HasSubsequence(m1, m2, ...) matches a vector containing elements that match\n// m1, m2 ... in that order.\n//\n// SubsequenceMatcher implements this once the type of vector is known.\ntemplate <typename T>\nclass SubsequenceMatcher\n    : public ::testing::MatcherInterface<const std::vector<T> &> {\n  std::vector<Matcher<T>> Matchers;\n\npublic:\n  SubsequenceMatcher(std::vector<Matcher<T>> M) : Matchers(M) {}\n\n  void DescribeTo(std::ostream *OS) const override {\n    *OS << \"Contains the subsequence [\";\n    const char *Sep = \"\";\n    for (const auto &M : Matchers) {\n      *OS << Sep;\n      M.DescribeTo(OS);\n      Sep = \", \";\n    }\n    *OS << \"]\";\n  }\n\n  bool MatchAndExplain(const std::vector<T> &V,\n                       ::testing::MatchResultListener *L) const override {\n    std::vector<int> Matches(Matchers.size());\n    size_t I = 0;\n    for (size_t J = 0; I < Matchers.size() && J < V.size(); ++J)\n      if (Matchers[I].Matches(V[J]))\n        Matches[I++] = J;\n    if (I == Matchers.size()) // We exhausted all matchers.\n      return true;\n    if (L->IsInterested()) {\n      *L << \"\\n  Matched:\";\n      for (size_t K = 0; K < I; ++K) {\n        *L << \"\\n\\t\";\n        Matchers[K].DescribeTo(L->stream());\n        *L << \" ==> \" << ::testing::PrintToString(V[Matches[K]]);\n      }\n      *L << \"\\n\\t\";\n      Matchers[I].DescribeTo(L->stream());\n      *L << \" ==> no subsequent match\";\n    }\n    return false;\n  }\n};\n\n// PolySubsequenceMatcher implements a \"polymorphic\" SubsequenceMatcher.\n// It captures the types of the element matchers, and can be converted to\n// Matcher<vector<T>> if each matcher can be converted to Matcher<T>.\n// This allows HasSubsequence() to accept polymorphic matchers like Not().\ntemplate <typename... M> class PolySubsequenceMatcher {\n  std::tuple<M...> Matchers;\n\npublic:\n  PolySubsequenceMatcher(M &&... Args)\n      : Matchers(std::make_tuple(std::forward<M>(Args)...)) {}\n\n  template <typename T> operator Matcher<const std::vector<T> &>() const {\n    return ::testing::MakeMatcher(new SubsequenceMatcher<T>(\n        TypedMatchers<T>(std::index_sequence_for<M...>{})));\n  }\n\nprivate:\n  template <typename T, size_t... I>\n  std::vector<Matcher<T>> TypedMatchers(std::index_sequence<I...>) const {\n    return {std::get<I>(Matchers)...};\n  }\n};\n\n// HasSubsequence(m1, m2, ...) matches a vector containing elements that match\n// m1, m2 ... in that order.\n// The real implementation is in SubsequenceMatcher.\ntemplate <typename... Args>\nPolySubsequenceMatcher<Args...> HasSubsequence(Args &&... M) {\n  return PolySubsequenceMatcher<Args...>(std::forward<Args>(M)...);\n}\n\n// EXPECT_ERROR seems like a pretty generic name, make sure it's not defined\n// already.\n#ifdef EXPECT_ERROR\n#error \"Refusing to redefine EXPECT_ERROR\"\n#endif\n\n// Consumes llvm::Expected<T>, checks it contains an error and marks it as\n// handled.\n#define EXPECT_ERROR(expectedValue)                                            \\\n  do {                                                                         \\\n    auto &&ComputedValue = (expectedValue);                                    \\\n    if (ComputedValue) {                                                       \\\n      ADD_FAILURE() << \"expected an error from \" << #expectedValue             \\\n                    << \" but got \"                                             \\\n                    << ::testing::PrintToString(*ComputedValue);               \\\n      break;                                                                   \\\n    }                                                                          \\\n    llvm::consumeError(ComputedValue.takeError());                             \\\n  } while (false)\n\n// Implements the HasValue(m) matcher for matching an Optional whose\n// value matches matcher m.\ntemplate <typename InnerMatcher> class OptionalMatcher {\npublic:\n  explicit OptionalMatcher(const InnerMatcher &matcher) : matcher_(matcher) {}\n\n  // This type conversion operator template allows Optional(m) to be\n  // used as a matcher for any Optional type whose value type is\n  // compatible with the inner matcher.\n  //\n  // The reason we do this instead of relying on\n  // MakePolymorphicMatcher() is that the latter is not flexible\n  // enough for implementing the DescribeTo() method of Optional().\n  template <typename Optional> operator Matcher<Optional>() const {\n    return MakeMatcher(new Impl<Optional>(matcher_));\n  }\n\nprivate:\n  // The monomorphic implementation that works for a particular optional type.\n  template <typename Optional>\n  class Impl : public ::testing::MatcherInterface<Optional> {\n  public:\n    using Value = typename std::remove_const<\n        typename std::remove_reference<Optional>::type>::type::value_type;\n\n    explicit Impl(const InnerMatcher &matcher)\n        : matcher_(::testing::MatcherCast<const Value &>(matcher)) {}\n\n    virtual void DescribeTo(::std::ostream *os) const {\n      *os << \"has a value that \";\n      matcher_.DescribeTo(os);\n    }\n\n    virtual void DescribeNegationTo(::std::ostream *os) const {\n      *os << \"does not have a value that \";\n      matcher_.DescribeTo(os);\n    }\n\n    virtual bool\n    MatchAndExplain(Optional optional,\n                    ::testing::MatchResultListener *listener) const {\n      if (!optional.hasValue())\n        return false;\n\n      *listener << \"which has a value \";\n      return MatchPrintAndExplain(*optional, matcher_, listener);\n    }\n\n  private:\n    const Matcher<const Value &> matcher_;\n\n    GTEST_DISALLOW_ASSIGN_(Impl);\n  };\n\n  const InnerMatcher matcher_;\n\n  GTEST_DISALLOW_ASSIGN_(OptionalMatcher);\n};\n\n// Creates a matcher that matches an Optional that has a value\n// that matches inner_matcher.\ntemplate <typename InnerMatcher>\ninline OptionalMatcher<InnerMatcher>\nHasValue(const InnerMatcher &inner_matcher) {\n  return OptionalMatcher<InnerMatcher>(inner_matcher);\n}\n\n} // namespace clangd\n} // namespace clang\n#endif\n"}, "13": {"id": 13, "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/unittests/TestFS.h", "content": "//===-- TestFS.h ------------------------------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// Allows setting up fake filesystem environments for tests.\n//\n//===----------------------------------------------------------------------===//\n#ifndef LLVM_CLANG_TOOLS_EXTRA_UNITTESTS_CLANGD_TESTFS_H\n#define LLVM_CLANG_TOOLS_EXTRA_UNITTESTS_CLANGD_TESTFS_H\n#include \"ClangdServer.h\"\n#include \"GlobalCompilationDatabase.h\"\n#include \"support/Path.h\"\n#include \"support/ThreadsafeFS.h\"\n#include \"llvm/ADT/IntrusiveRefCntPtr.h\"\n#include \"llvm/ADT/None.h\"\n#include \"llvm/ADT/Optional.h\"\n#include \"llvm/Support/Path.h\"\n#include \"llvm/Support/VirtualFileSystem.h\"\n\nnamespace clang {\nnamespace clangd {\n\n// Builds a VFS that provides access to the provided files, plus temporary\n// directories.\nllvm::IntrusiveRefCntPtr<llvm::vfs::FileSystem>\nbuildTestFS(llvm::StringMap<std::string> const &Files,\n            llvm::StringMap<time_t> const &Timestamps = {});\n\n// A VFS provider that returns TestFSes containing a provided set of files.\nclass MockFS : public ThreadsafeFS {\npublic:\n  IntrusiveRefCntPtr<llvm::vfs::FileSystem> viewImpl() const override {\n    auto MemFS = buildTestFS(Files, Timestamps);\n    if (!OverlayRealFileSystemForModules)\n      return MemFS;\n    llvm::IntrusiveRefCntPtr<llvm::vfs::OverlayFileSystem> OverlayFileSystem =\n        new llvm::vfs::OverlayFileSystem(llvm::vfs::getRealFileSystem());\n    OverlayFileSystem->pushOverlay(MemFS);\n    return OverlayFileSystem;\n  }\n\n  // If relative paths are used, they are resolved with testPath().\n  llvm::StringMap<std::string> Files;\n  llvm::StringMap<time_t> Timestamps;\n  // If true, real file system will be used as fallback for the in-memory one.\n  // This is useful for testing module support.\n  bool OverlayRealFileSystemForModules = false;\n};\n\n// A Compilation database that returns a fixed set of compile flags.\nclass MockCompilationDatabase : public GlobalCompilationDatabase {\npublic:\n  /// If \\p Directory is not empty, use that as the Directory field of the\n  /// CompileCommand, and as project SourceRoot.\n  ///\n  /// If \\p RelPathPrefix is not empty, use that as a prefix in front of the\n  /// source file name, instead of using an absolute path.\n  MockCompilationDatabase(StringRef Directory = StringRef(),\n                          StringRef RelPathPrefix = StringRef());\n\n  llvm::Optional<tooling::CompileCommand>\n  getCompileCommand(PathRef File) const override;\n\n  llvm::Optional<ProjectInfo> getProjectInfo(PathRef File) const override;\n\n  std::vector<std::string> ExtraClangFlags;\n\nprivate:\n  StringRef Directory;\n  StringRef RelPathPrefix;\n};\n\n// Returns an absolute (fake) test directory for this OS.\nconst char *testRoot();\n\n// Returns a suitable absolute path for this OS.\nstd::string testPath(PathRef File,\n                     llvm::sys::path::Style = llvm::sys::path::Style::native);\n\n// unittest: is a scheme that refers to files relative to testRoot()\n// This anchor is used to force the linker to link in the generated object file\n// and thus register unittest: URI scheme plugin.\nextern volatile int UnittestSchemeAnchorSource;\n\n} // namespace clangd\n} // namespace clang\n#endif\n"}, "29": {"id": 29, "path": "/home/vsts/work/1/llvm-project/llvm/utils/unittest/googlemock/include/gmock/gmock-actions.h", "content": "// Copyright 2007, Google Inc.\n// All rights reserved.\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are\n// met:\n//\n//     * Redistributions of source code must retain the above copyright\n// notice, this list of conditions and the following disclaimer.\n//     * Redistributions in binary form must reproduce the above\n// copyright notice, this list of conditions and the following disclaimer\n// in the documentation and/or other materials provided with the\n// distribution.\n//     * Neither the name of Google Inc. nor the names of its\n// contributors may be used to endorse or promote products derived from\n// this software without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n//\n// Author: wan@google.com (Zhanyong Wan)\n\n// Google Mock - a framework for writing C++ mock classes.\n//\n// This file implements some commonly used actions.\n\n// IWYU pragma: private, include \"gmock/gmock.h\"\n\n#ifndef GMOCK_INCLUDE_GMOCK_GMOCK_ACTIONS_H_\n#define GMOCK_INCLUDE_GMOCK_GMOCK_ACTIONS_H_\n\n#ifndef _WIN32_WCE\n# include <errno.h>\n#endif\n\n#include <algorithm>\n#include <string>\n\n#include \"gmock/internal/gmock-internal-utils.h\"\n#include \"gmock/internal/gmock-port.h\"\n\n#if GTEST_HAS_STD_TYPE_TRAITS_  // Defined by gtest-port.h via gmock-port.h.\n#include <type_traits>\n#endif\n\nnamespace testing {\n\n// To implement an action Foo, define:\n//   1. a class FooAction that implements the ActionInterface interface, and\n//   2. a factory function that creates an Action object from a\n//      const FooAction*.\n//\n// The two-level delegation design follows that of Matcher, providing\n// consistency for extension developers.  It also eases ownership\n// management as Action objects can now be copied like plain values.\n\nnamespace internal {\n\ntemplate <typename F1, typename F2>\nclass ActionAdaptor;\n\n// BuiltInDefaultValueGetter<T, true>::Get() returns a\n// default-constructed T value.  BuiltInDefaultValueGetter<T,\n// false>::Get() crashes with an error.\n//\n// This primary template is used when kDefaultConstructible is true.\ntemplate <typename T, bool kDefaultConstructible>\nstruct BuiltInDefaultValueGetter {\n  static T Get() { return T(); }\n};\ntemplate <typename T>\nstruct BuiltInDefaultValueGetter<T, false> {\n  static T Get() {\n    Assert(false, __FILE__, __LINE__,\n           \"Default action undefined for the function return type.\");\n    return internal::Invalid<T>();\n    // The above statement will never be reached, but is required in\n    // order for this function to compile.\n  }\n};\n\n// BuiltInDefaultValue<T>::Get() returns the \"built-in\" default value\n// for type T, which is NULL when T is a raw pointer type, 0 when T is\n// a numeric type, false when T is bool, or \"\" when T is string or\n// std::string.  In addition, in C++11 and above, it turns a\n// default-constructed T value if T is default constructible.  For any\n// other type T, the built-in default T value is undefined, and the\n// function will abort the process.\ntemplate <typename T>\nclass BuiltInDefaultValue {\n public:\n#if GTEST_HAS_STD_TYPE_TRAITS_\n  // This function returns true iff type T has a built-in default value.\n  static bool Exists() {\n    return ::std::is_default_constructible<T>::value;\n  }\n\n  static T Get() {\n    return BuiltInDefaultValueGetter<\n        T, ::std::is_default_constructible<T>::value>::Get();\n  }\n\n#else  // GTEST_HAS_STD_TYPE_TRAITS_\n  // This function returns true iff type T has a built-in default value.\n  static bool Exists() {\n    return false;\n  }\n\n  static T Get() {\n    return BuiltInDefaultValueGetter<T, false>::Get();\n  }\n\n#endif  // GTEST_HAS_STD_TYPE_TRAITS_\n};\n\n// This partial specialization says that we use the same built-in\n// default value for T and const T.\ntemplate <typename T>\nclass BuiltInDefaultValue<const T> {\n public:\n  static bool Exists() { return BuiltInDefaultValue<T>::Exists(); }\n  static T Get() { return BuiltInDefaultValue<T>::Get(); }\n};\n\n// This partial specialization defines the default values for pointer\n// types.\ntemplate <typename T>\nclass BuiltInDefaultValue<T*> {\n public:\n  static bool Exists() { return true; }\n  static T* Get() { return NULL; }\n};\n\n// The following specializations define the default values for\n// specific types we care about.\n#define GMOCK_DEFINE_DEFAULT_ACTION_FOR_RETURN_TYPE_(type, value) \\\n  template <> \\\n  class BuiltInDefaultValue<type> { \\\n   public: \\\n    static bool Exists() { return true; } \\\n    static type Get() { return value; } \\\n  }\n\nGMOCK_DEFINE_DEFAULT_ACTION_FOR_RETURN_TYPE_(void, );  // NOLINT\n#if GTEST_HAS_GLOBAL_STRING\nGMOCK_DEFINE_DEFAULT_ACTION_FOR_RETURN_TYPE_(::string, \"\");\n#endif  // GTEST_HAS_GLOBAL_STRING\nGMOCK_DEFINE_DEFAULT_ACTION_FOR_RETURN_TYPE_(::std::string, \"\");\nGMOCK_DEFINE_DEFAULT_ACTION_FOR_RETURN_TYPE_(bool, false);\nGMOCK_DEFINE_DEFAULT_ACTION_FOR_RETURN_TYPE_(unsigned char, '\\0');\nGMOCK_DEFINE_DEFAULT_ACTION_FOR_RETURN_TYPE_(signed char, '\\0');\nGMOCK_DEFINE_DEFAULT_ACTION_FOR_RETURN_TYPE_(char, '\\0');\n\n// There's no need for a default action for signed wchar_t, as that\n// type is the same as wchar_t for gcc, and invalid for MSVC.\n//\n// There's also no need for a default action for unsigned wchar_t, as\n// that type is the same as unsigned int for gcc, and invalid for\n// MSVC.\n#if GMOCK_WCHAR_T_IS_NATIVE_\nGMOCK_DEFINE_DEFAULT_ACTION_FOR_RETURN_TYPE_(wchar_t, 0U);  // NOLINT\n#endif\n\nGMOCK_DEFINE_DEFAULT_ACTION_FOR_RETURN_TYPE_(unsigned short, 0U);  // NOLINT\nGMOCK_DEFINE_DEFAULT_ACTION_FOR_RETURN_TYPE_(signed short, 0);     // NOLINT\nGMOCK_DEFINE_DEFAULT_ACTION_FOR_RETURN_TYPE_(unsigned int, 0U);\nGMOCK_DEFINE_DEFAULT_ACTION_FOR_RETURN_TYPE_(signed int, 0);\nGMOCK_DEFINE_DEFAULT_ACTION_FOR_RETURN_TYPE_(unsigned long, 0UL);  // NOLINT\nGMOCK_DEFINE_DEFAULT_ACTION_FOR_RETURN_TYPE_(signed long, 0L);     // NOLINT\nGMOCK_DEFINE_DEFAULT_ACTION_FOR_RETURN_TYPE_(UInt64, 0);\nGMOCK_DEFINE_DEFAULT_ACTION_FOR_RETURN_TYPE_(Int64, 0);\nGMOCK_DEFINE_DEFAULT_ACTION_FOR_RETURN_TYPE_(float, 0);\nGMOCK_DEFINE_DEFAULT_ACTION_FOR_RETURN_TYPE_(double, 0);\n\n#undef GMOCK_DEFINE_DEFAULT_ACTION_FOR_RETURN_TYPE_\n\n}  // namespace internal\n\n// When an unexpected function call is encountered, Google Mock will\n// let it return a default value if the user has specified one for its\n// return type, or if the return type has a built-in default value;\n// otherwise Google Mock won't know what value to return and will have\n// to abort the process.\n//\n// The DefaultValue<T> class allows a user to specify the\n// default value for a type T that is both copyable and publicly\n// destructible (i.e. anything that can be used as a function return\n// type).  The usage is:\n//\n//   // Sets the default value for type T to be foo.\n//   DefaultValue<T>::Set(foo);\ntemplate <typename T>\nclass DefaultValue {\n public:\n  // Sets the default value for type T; requires T to be\n  // copy-constructable and have a public destructor.\n  static void Set(T x) {\n    delete producer_;\n    producer_ = new FixedValueProducer(x);\n  }\n\n  // Provides a factory function to be called to generate the default value.\n  // This method can be used even if T is only move-constructible, but it is not\n  // limited to that case.\n  typedef T (*FactoryFunction)();\n  static void SetFactory(FactoryFunction factory) {\n    delete producer_;\n    producer_ = new FactoryValueProducer(factory);\n  }\n\n  // Unsets the default value for type T.\n  static void Clear() {\n    delete producer_;\n    producer_ = NULL;\n  }\n\n  // Returns true iff the user has set the default value for type T.\n  static bool IsSet() { return producer_ != NULL; }\n\n  // Returns true if T has a default return value set by the user or there\n  // exists a built-in default value.\n  static bool Exists() {\n    return IsSet() || internal::BuiltInDefaultValue<T>::Exists();\n  }\n\n  // Returns the default value for type T if the user has set one;\n  // otherwise returns the built-in default value. Requires that Exists()\n  // is true, which ensures that the return value is well-defined.\n  static T Get() {\n    return producer_ == NULL ?\n        internal::BuiltInDefaultValue<T>::Get() : producer_->Produce();\n  }\n\n private:\n  class ValueProducer {\n   public:\n    virtual ~ValueProducer() {}\n    virtual T Produce() = 0;\n  };\n\n  class FixedValueProducer : public ValueProducer {\n   public:\n    explicit FixedValueProducer(T value) : value_(value) {}\n    virtual T Produce() { return value_; }\n\n   private:\n    const T value_;\n    GTEST_DISALLOW_COPY_AND_ASSIGN_(FixedValueProducer);\n  };\n\n  class FactoryValueProducer : public ValueProducer {\n   public:\n    explicit FactoryValueProducer(FactoryFunction factory)\n        : factory_(factory) {}\n    virtual T Produce() { return factory_(); }\n\n   private:\n    const FactoryFunction factory_;\n    GTEST_DISALLOW_COPY_AND_ASSIGN_(FactoryValueProducer);\n  };\n\n  static ValueProducer* producer_;\n};\n\n// This partial specialization allows a user to set default values for\n// reference types.\ntemplate <typename T>\nclass DefaultValue<T&> {\n public:\n  // Sets the default value for type T&.\n  static void Set(T& x) {  // NOLINT\n    address_ = &x;\n  }\n\n  // Unsets the default value for type T&.\n  static void Clear() {\n    address_ = NULL;\n  }\n\n  // Returns true iff the user has set the default value for type T&.\n  static bool IsSet() { return address_ != NULL; }\n\n  // Returns true if T has a default return value set by the user or there\n  // exists a built-in default value.\n  static bool Exists() {\n    return IsSet() || internal::BuiltInDefaultValue<T&>::Exists();\n  }\n\n  // Returns the default value for type T& if the user has set one;\n  // otherwise returns the built-in default value if there is one;\n  // otherwise aborts the process.\n  static T& Get() {\n    return address_ == NULL ?\n        internal::BuiltInDefaultValue<T&>::Get() : *address_;\n  }\n\n private:\n  static T* address_;\n};\n\n// This specialization allows DefaultValue<void>::Get() to\n// compile.\ntemplate <>\nclass DefaultValue<void> {\n public:\n  static bool Exists() { return true; }\n  static void Get() {}\n};\n\n// Points to the user-set default value for type T.\ntemplate <typename T>\ntypename DefaultValue<T>::ValueProducer* DefaultValue<T>::producer_ = NULL;\n\n// Points to the user-set default value for type T&.\ntemplate <typename T>\nT* DefaultValue<T&>::address_ = NULL;\n\n// Implement this interface to define an action for function type F.\ntemplate <typename F>\nclass ActionInterface {\n public:\n  typedef typename internal::Function<F>::Result Result;\n  typedef typename internal::Function<F>::ArgumentTuple ArgumentTuple;\n\n  ActionInterface() {}\n  virtual ~ActionInterface() {}\n\n  // Performs the action.  This method is not const, as in general an\n  // action can have side effects and be stateful.  For example, a\n  // get-the-next-element-from-the-collection action will need to\n  // remember the current element.\n  virtual Result Perform(const ArgumentTuple& args) = 0;\n\n private:\n  GTEST_DISALLOW_COPY_AND_ASSIGN_(ActionInterface);\n};\n\n// An Action<F> is a copyable and IMMUTABLE (except by assignment)\n// object that represents an action to be taken when a mock function\n// of type F is called.  The implementation of Action<T> is just a\n// linked_ptr to const ActionInterface<T>, so copying is fairly cheap.\n// Don't inherit from Action!\n//\n// You can view an object implementing ActionInterface<F> as a\n// concrete action (including its current state), and an Action<F>\n// object as a handle to it.\ntemplate <typename F>\nclass Action {\n public:\n  typedef typename internal::Function<F>::Result Result;\n  typedef typename internal::Function<F>::ArgumentTuple ArgumentTuple;\n\n  // Constructs a null Action.  Needed for storing Action objects in\n  // STL containers.\n  Action() : impl_(NULL) {}\n\n  // Constructs an Action from its implementation.  A NULL impl is\n  // used to represent the \"do-default\" action.\n  explicit Action(ActionInterface<F>* impl) : impl_(impl) {}\n\n  // Copy constructor.\n  Action(const Action &action) = default;\n  Action &operator=(const Action &action) = default;\n\n  // This constructor allows us to turn an Action<Func> object into an\n  // Action<F>, as long as F's arguments can be implicitly converted\n  // to Func's and Func's return type can be implicitly converted to\n  // F's.\n  template <typename Func>\n  explicit Action(const Action<Func>& action);\n\n  // Returns true iff this is the DoDefault() action.\n  bool IsDoDefault() const { return impl_.get() == NULL; }\n\n  // Performs the action.  Note that this method is const even though\n  // the corresponding method in ActionInterface is not.  The reason\n  // is that a const Action<F> means that it cannot be re-bound to\n  // another concrete action, not that the concrete action it binds to\n  // cannot change state.  (Think of the difference between a const\n  // pointer and a pointer to const.)\n  Result Perform(const ArgumentTuple& args) const {\n    internal::Assert(\n        !IsDoDefault(), __FILE__, __LINE__,\n        \"You are using DoDefault() inside a composite action like \"\n        \"DoAll() or WithArgs().  This is not supported for technical \"\n        \"reasons.  Please instead spell out the default action, or \"\n        \"assign the default action to an Action variable and use \"\n        \"the variable in various places.\");\n    return impl_->Perform(args);\n  }\n\n private:\n  template <typename F1, typename F2>\n  friend class internal::ActionAdaptor;\n\n  internal::linked_ptr<ActionInterface<F> > impl_;\n};\n\n// The PolymorphicAction class template makes it easy to implement a\n// polymorphic action (i.e. an action that can be used in mock\n// functions of than one type, e.g. Return()).\n//\n// To define a polymorphic action, a user first provides a COPYABLE\n// implementation class that has a Perform() method template:\n//\n//   class FooAction {\n//    public:\n//     template <typename Result, typename ArgumentTuple>\n//     Result Perform(const ArgumentTuple& args) const {\n//       // Processes the arguments and returns a result, using\n//       // tr1::get<N>(args) to get the N-th (0-based) argument in the tuple.\n//     }\n//     ...\n//   };\n//\n// Then the user creates the polymorphic action using\n// MakePolymorphicAction(object) where object has type FooAction.  See\n// the definition of Return(void) and SetArgumentPointee<N>(value) for\n// complete examples.\ntemplate <typename Impl>\nclass PolymorphicAction {\n public:\n  explicit PolymorphicAction(const Impl& impl) : impl_(impl) {}\n\n  template <typename F>\n  operator Action<F>() const {\n    return Action<F>(new MonomorphicImpl<F>(impl_));\n  }\n\n private:\n  template <typename F>\n  class MonomorphicImpl : public ActionInterface<F> {\n   public:\n    typedef typename internal::Function<F>::Result Result;\n    typedef typename internal::Function<F>::ArgumentTuple ArgumentTuple;\n\n    explicit MonomorphicImpl(const Impl& impl) : impl_(impl) {}\n\n    virtual Result Perform(const ArgumentTuple& args) {\n      return impl_.template Perform<Result>(args);\n    }\n\n   private:\n    Impl impl_;\n\n    GTEST_DISALLOW_ASSIGN_(MonomorphicImpl);\n  };\n\n  Impl impl_;\n\n  GTEST_DISALLOW_ASSIGN_(PolymorphicAction);\n};\n\n// Creates an Action from its implementation and returns it.  The\n// created Action object owns the implementation.\ntemplate <typename F>\nAction<F> MakeAction(ActionInterface<F>* impl) {\n  return Action<F>(impl);\n}\n\n// Creates a polymorphic action from its implementation.  This is\n// easier to use than the PolymorphicAction<Impl> constructor as it\n// doesn't require you to explicitly write the template argument, e.g.\n//\n//   MakePolymorphicAction(foo);\n// vs\n//   PolymorphicAction<TypeOfFoo>(foo);\ntemplate <typename Impl>\ninline PolymorphicAction<Impl> MakePolymorphicAction(const Impl& impl) {\n  return PolymorphicAction<Impl>(impl);\n}\n\nnamespace internal {\n\n// Allows an Action<F2> object to pose as an Action<F1>, as long as F2\n// and F1 are compatible.\ntemplate <typename F1, typename F2>\nclass ActionAdaptor : public ActionInterface<F1> {\n public:\n  typedef typename internal::Function<F1>::Result Result;\n  typedef typename internal::Function<F1>::ArgumentTuple ArgumentTuple;\n\n  explicit ActionAdaptor(const Action<F2>& from) : impl_(from.impl_) {}\n\n  virtual Result Perform(const ArgumentTuple& args) {\n    return impl_->Perform(args);\n  }\n\n private:\n  const internal::linked_ptr<ActionInterface<F2> > impl_;\n\n  GTEST_DISALLOW_ASSIGN_(ActionAdaptor);\n};\n\n// Helper struct to specialize ReturnAction to execute a move instead of a copy\n// on return. Useful for move-only types, but could be used on any type.\ntemplate <typename T>\nstruct ByMoveWrapper {\n  explicit ByMoveWrapper(T value) : payload(internal::move(value)) {}\n  T payload;\n};\n\n// Implements the polymorphic Return(x) action, which can be used in\n// any function that returns the type of x, regardless of the argument\n// types.\n//\n// Note: The value passed into Return must be converted into\n// Function<F>::Result when this action is cast to Action<F> rather than\n// when that action is performed. This is important in scenarios like\n//\n// MOCK_METHOD1(Method, T(U));\n// ...\n// {\n//   Foo foo;\n//   X x(&foo);\n//   EXPECT_CALL(mock, Method(_)).WillOnce(Return(x));\n// }\n//\n// In the example above the variable x holds reference to foo which leaves\n// scope and gets destroyed.  If copying X just copies a reference to foo,\n// that copy will be left with a hanging reference.  If conversion to T\n// makes a copy of foo, the above code is safe. To support that scenario, we\n// need to make sure that the type conversion happens inside the EXPECT_CALL\n// statement, and conversion of the result of Return to Action<T(U)> is a\n// good place for that.\n//\ntemplate <typename R>\nclass ReturnAction {\n public:\n  // Constructs a ReturnAction object from the value to be returned.\n  // 'value' is passed by value instead of by const reference in order\n  // to allow Return(\"string literal\") to compile.\n  explicit ReturnAction(R value) : value_(new R(internal::move(value))) {}\n\n  // This template type conversion operator allows Return(x) to be\n  // used in ANY function that returns x's type.\n  template <typename F>\n  operator Action<F>() const {\n    // Assert statement belongs here because this is the best place to verify\n    // conditions on F. It produces the clearest error messages\n    // in most compilers.\n    // Impl really belongs in this scope as a local class but can't\n    // because MSVC produces duplicate symbols in different translation units\n    // in this case. Until MS fixes that bug we put Impl into the class scope\n    // and put the typedef both here (for use in assert statement) and\n    // in the Impl class. But both definitions must be the same.\n    typedef typename Function<F>::Result Result;\n    GTEST_COMPILE_ASSERT_(\n        !is_reference<Result>::value,\n        use_ReturnRef_instead_of_Return_to_return_a_reference);\n    return Action<F>(new Impl<R, F>(value_));\n  }\n\n private:\n  // Implements the Return(x) action for a particular function type F.\n  template <typename R_, typename F>\n  class Impl : public ActionInterface<F> {\n   public:\n    typedef typename Function<F>::Result Result;\n    typedef typename Function<F>::ArgumentTuple ArgumentTuple;\n\n    // The implicit cast is necessary when Result has more than one\n    // single-argument constructor (e.g. Result is std::vector<int>) and R\n    // has a type conversion operator template.  In that case, value_(value)\n    // won't compile as the compiler doesn't known which constructor of\n    // Result to call.  ImplicitCast_ forces the compiler to convert R to\n    // Result without considering explicit constructors, thus resolving the\n    // ambiguity. value_ is then initialized using its copy constructor.\n    explicit Impl(const linked_ptr<R>& value)\n        : value_before_cast_(*value),\n          value_(ImplicitCast_<Result>(value_before_cast_)) {}\n\n    virtual Result Perform(const ArgumentTuple&) { return value_; }\n\n   private:\n    GTEST_COMPILE_ASSERT_(!is_reference<Result>::value,\n                          Result_cannot_be_a_reference_type);\n    // We save the value before casting just in case it is being cast to a\n    // wrapper type.\n    R value_before_cast_;\n    Result value_;\n\n    GTEST_DISALLOW_COPY_AND_ASSIGN_(Impl);\n  };\n\n  // Partially specialize for ByMoveWrapper. This version of ReturnAction will\n  // move its contents instead.\n  template <typename R_, typename F>\n  class Impl<ByMoveWrapper<R_>, F> : public ActionInterface<F> {\n   public:\n    typedef typename Function<F>::Result Result;\n    typedef typename Function<F>::ArgumentTuple ArgumentTuple;\n\n    explicit Impl(const linked_ptr<R>& wrapper)\n        : performed_(false), wrapper_(wrapper) {}\n\n    virtual Result Perform(const ArgumentTuple&) {\n      GTEST_CHECK_(!performed_)\n          << \"A ByMove() action should only be performed once.\";\n      performed_ = true;\n      return internal::move(wrapper_->payload);\n    }\n\n   private:\n    bool performed_;\n    const linked_ptr<R> wrapper_;\n\n    GTEST_DISALLOW_ASSIGN_(Impl);\n  };\n\n  const linked_ptr<R> value_;\n\n  GTEST_DISALLOW_ASSIGN_(ReturnAction);\n};\n\n// Implements the ReturnNull() action.\nclass ReturnNullAction {\n public:\n  // Allows ReturnNull() to be used in any pointer-returning function. In C++11\n  // this is enforced by returning nullptr, and in non-C++11 by asserting a\n  // pointer type on compile time.\n  template <typename Result, typename ArgumentTuple>\n  static Result Perform(const ArgumentTuple&) {\n#if GTEST_LANG_CXX11\n    return nullptr;\n#else\n    GTEST_COMPILE_ASSERT_(internal::is_pointer<Result>::value,\n                          ReturnNull_can_be_used_to_return_a_pointer_only);\n    return NULL;\n#endif  // GTEST_LANG_CXX11\n  }\n};\n\n// Implements the Return() action.\nclass ReturnVoidAction {\n public:\n  // Allows Return() to be used in any void-returning function.\n  template <typename Result, typename ArgumentTuple>\n  static void Perform(const ArgumentTuple&) {\n    CompileAssertTypesEqual<void, Result>();\n  }\n};\n\n// Implements the polymorphic ReturnRef(x) action, which can be used\n// in any function that returns a reference to the type of x,\n// regardless of the argument types.\ntemplate <typename T>\nclass ReturnRefAction {\n public:\n  // Constructs a ReturnRefAction object from the reference to be returned.\n  explicit ReturnRefAction(T& ref) : ref_(ref) {}  // NOLINT\n\n  // This template type conversion operator allows ReturnRef(x) to be\n  // used in ANY function that returns a reference to x's type.\n  template <typename F>\n  operator Action<F>() const {\n    typedef typename Function<F>::Result Result;\n    // Asserts that the function return type is a reference.  This\n    // catches the user error of using ReturnRef(x) when Return(x)\n    // should be used, and generates some helpful error message.\n    GTEST_COMPILE_ASSERT_(internal::is_reference<Result>::value,\n                          use_Return_instead_of_ReturnRef_to_return_a_value);\n    return Action<F>(new Impl<F>(ref_));\n  }\n\n private:\n  // Implements the ReturnRef(x) action for a particular function type F.\n  template <typename F>\n  class Impl : public ActionInterface<F> {\n   public:\n    typedef typename Function<F>::Result Result;\n    typedef typename Function<F>::ArgumentTuple ArgumentTuple;\n\n    explicit Impl(T& ref) : ref_(ref) {}  // NOLINT\n\n    virtual Result Perform(const ArgumentTuple&) {\n      return ref_;\n    }\n\n   private:\n    T& ref_;\n\n    GTEST_DISALLOW_ASSIGN_(Impl);\n  };\n\n  T& ref_;\n\n  GTEST_DISALLOW_ASSIGN_(ReturnRefAction);\n};\n\n// Implements the polymorphic ReturnRefOfCopy(x) action, which can be\n// used in any function that returns a reference to the type of x,\n// regardless of the argument types.\ntemplate <typename T>\nclass ReturnRefOfCopyAction {\n public:\n  // Constructs a ReturnRefOfCopyAction object from the reference to\n  // be returned.\n  explicit ReturnRefOfCopyAction(const T& value) : value_(value) {}  // NOLINT\n\n  // This template type conversion operator allows ReturnRefOfCopy(x) to be\n  // used in ANY function that returns a reference to x's type.\n  template <typename F>\n  operator Action<F>() const {\n    typedef typename Function<F>::Result Result;\n    // Asserts that the function return type is a reference.  This\n    // catches the user error of using ReturnRefOfCopy(x) when Return(x)\n    // should be used, and generates some helpful error message.\n    GTEST_COMPILE_ASSERT_(\n        internal::is_reference<Result>::value,\n        use_Return_instead_of_ReturnRefOfCopy_to_return_a_value);\n    return Action<F>(new Impl<F>(value_));\n  }\n\n private:\n  // Implements the ReturnRefOfCopy(x) action for a particular function type F.\n  template <typename F>\n  class Impl : public ActionInterface<F> {\n   public:\n    typedef typename Function<F>::Result Result;\n    typedef typename Function<F>::ArgumentTuple ArgumentTuple;\n\n    explicit Impl(const T& value) : value_(value) {}  // NOLINT\n\n    virtual Result Perform(const ArgumentTuple&) {\n      return value_;\n    }\n\n   private:\n    T value_;\n\n    GTEST_DISALLOW_ASSIGN_(Impl);\n  };\n\n  const T value_;\n\n  GTEST_DISALLOW_ASSIGN_(ReturnRefOfCopyAction);\n};\n\n// Implements the polymorphic DoDefault() action.\nclass DoDefaultAction {\n public:\n  // This template type conversion operator allows DoDefault() to be\n  // used in any function.\n  template <typename F>\n  operator Action<F>() const { return Action<F>(NULL); }\n};\n\n// Implements the Assign action to set a given pointer referent to a\n// particular value.\ntemplate <typename T1, typename T2>\nclass AssignAction {\n public:\n  AssignAction(T1* ptr, T2 value) : ptr_(ptr), value_(value) {}\n\n  template <typename Result, typename ArgumentTuple>\n  void Perform(const ArgumentTuple& /* args */) const {\n    *ptr_ = value_;\n  }\n\n private:\n  T1* const ptr_;\n  const T2 value_;\n\n  GTEST_DISALLOW_ASSIGN_(AssignAction);\n};\n\n#if !GTEST_OS_WINDOWS_MOBILE\n\n// Implements the SetErrnoAndReturn action to simulate return from\n// various system calls and libc functions.\ntemplate <typename T>\nclass SetErrnoAndReturnAction {\n public:\n  SetErrnoAndReturnAction(int errno_value, T result)\n      : errno_(errno_value),\n        result_(result) {}\n  template <typename Result, typename ArgumentTuple>\n  Result Perform(const ArgumentTuple& /* args */) const {\n    errno = errno_;\n    return result_;\n  }\n\n private:\n  const int errno_;\n  const T result_;\n\n  GTEST_DISALLOW_ASSIGN_(SetErrnoAndReturnAction);\n};\n\n#endif  // !GTEST_OS_WINDOWS_MOBILE\n\n// Implements the SetArgumentPointee<N>(x) action for any function\n// whose N-th argument (0-based) is a pointer to x's type.  The\n// template parameter kIsProto is true iff type A is ProtocolMessage,\n// proto2::Message, or a sub-class of those.\ntemplate <size_t N, typename A, bool kIsProto>\nclass SetArgumentPointeeAction {\n public:\n  // Constructs an action that sets the variable pointed to by the\n  // N-th function argument to 'value'.\n  explicit SetArgumentPointeeAction(const A& value) : value_(value) {}\n\n  template <typename Result, typename ArgumentTuple>\n  void Perform(const ArgumentTuple& args) const {\n    CompileAssertTypesEqual<void, Result>();\n    *::testing::get<N>(args) = value_;\n  }\n\n private:\n  const A value_;\n\n  GTEST_DISALLOW_ASSIGN_(SetArgumentPointeeAction);\n};\n\ntemplate <size_t N, typename Proto>\nclass SetArgumentPointeeAction<N, Proto, true> {\n public:\n  // Constructs an action that sets the variable pointed to by the\n  // N-th function argument to 'proto'.  Both ProtocolMessage and\n  // proto2::Message have the CopyFrom() method, so the same\n  // implementation works for both.\n  explicit SetArgumentPointeeAction(const Proto& proto) : proto_(new Proto) {\n    proto_->CopyFrom(proto);\n  }\n\n  template <typename Result, typename ArgumentTuple>\n  void Perform(const ArgumentTuple& args) const {\n    CompileAssertTypesEqual<void, Result>();\n    ::testing::get<N>(args)->CopyFrom(*proto_);\n  }\n\n private:\n  const internal::linked_ptr<Proto> proto_;\n\n  GTEST_DISALLOW_ASSIGN_(SetArgumentPointeeAction);\n};\n\n// Implements the InvokeWithoutArgs(f) action.  The template argument\n// FunctionImpl is the implementation type of f, which can be either a\n// function pointer or a functor.  InvokeWithoutArgs(f) can be used as an\n// Action<F> as long as f's type is compatible with F (i.e. f can be\n// assigned to a tr1::function<F>).\ntemplate <typename FunctionImpl>\nclass InvokeWithoutArgsAction {\n public:\n  // The c'tor makes a copy of function_impl (either a function\n  // pointer or a functor).\n  explicit InvokeWithoutArgsAction(FunctionImpl function_impl)\n      : function_impl_(function_impl) {}\n\n  // Allows InvokeWithoutArgs(f) to be used as any action whose type is\n  // compatible with f.\n  template <typename Result, typename ArgumentTuple>\n  Result Perform(const ArgumentTuple&) { return function_impl_(); }\n\n private:\n  FunctionImpl function_impl_;\n\n  GTEST_DISALLOW_ASSIGN_(InvokeWithoutArgsAction);\n};\n\n// Implements the InvokeWithoutArgs(object_ptr, &Class::Method) action.\ntemplate <class Class, typename MethodPtr>\nclass InvokeMethodWithoutArgsAction {\n public:\n  InvokeMethodWithoutArgsAction(Class* obj_ptr, MethodPtr method_ptr)\n      : obj_ptr_(obj_ptr), method_ptr_(method_ptr) {}\n\n  template <typename Result, typename ArgumentTuple>\n  Result Perform(const ArgumentTuple&) const {\n    return (obj_ptr_->*method_ptr_)();\n  }\n\n private:\n  Class* const obj_ptr_;\n  const MethodPtr method_ptr_;\n\n  GTEST_DISALLOW_ASSIGN_(InvokeMethodWithoutArgsAction);\n};\n\n// Implements the IgnoreResult(action) action.\ntemplate <typename A>\nclass IgnoreResultAction {\n public:\n  explicit IgnoreResultAction(const A& action) : action_(action) {}\n\n  template <typename F>\n  operator Action<F>() const {\n    // Assert statement belongs here because this is the best place to verify\n    // conditions on F. It produces the clearest error messages\n    // in most compilers.\n    // Impl really belongs in this scope as a local class but can't\n    // because MSVC produces duplicate symbols in different translation units\n    // in this case. Until MS fixes that bug we put Impl into the class scope\n    // and put the typedef both here (for use in assert statement) and\n    // in the Impl class. But both definitions must be the same.\n    typedef typename internal::Function<F>::Result Result;\n\n    // Asserts at compile time that F returns void.\n    CompileAssertTypesEqual<void, Result>();\n\n    return Action<F>(new Impl<F>(action_));\n  }\n\n private:\n  template <typename F>\n  class Impl : public ActionInterface<F> {\n   public:\n    typedef typename internal::Function<F>::Result Result;\n    typedef typename internal::Function<F>::ArgumentTuple ArgumentTuple;\n\n    explicit Impl(const A& action) : action_(action) {}\n\n    virtual void Perform(const ArgumentTuple& args) {\n      // Performs the action and ignores its result.\n      action_.Perform(args);\n    }\n\n   private:\n    // Type OriginalFunction is the same as F except that its return\n    // type is IgnoredValue.\n    typedef typename internal::Function<F>::MakeResultIgnoredValue\n        OriginalFunction;\n\n    const Action<OriginalFunction> action_;\n\n    GTEST_DISALLOW_ASSIGN_(Impl);\n  };\n\n  const A action_;\n\n  GTEST_DISALLOW_ASSIGN_(IgnoreResultAction);\n};\n\n// A ReferenceWrapper<T> object represents a reference to type T,\n// which can be either const or not.  It can be explicitly converted\n// from, and implicitly converted to, a T&.  Unlike a reference,\n// ReferenceWrapper<T> can be copied and can survive template type\n// inference.  This is used to support by-reference arguments in the\n// InvokeArgument<N>(...) action.  The idea was from \"reference\n// wrappers\" in tr1, which we don't have in our source tree yet.\ntemplate <typename T>\nclass ReferenceWrapper {\n public:\n  // Constructs a ReferenceWrapper<T> object from a T&.\n  explicit ReferenceWrapper(T& l_value) : pointer_(&l_value) {}  // NOLINT\n\n  // Allows a ReferenceWrapper<T> object to be implicitly converted to\n  // a T&.\n  operator T&() const { return *pointer_; }\n private:\n  T* pointer_;\n};\n\n// Allows the expression ByRef(x) to be printed as a reference to x.\ntemplate <typename T>\nvoid PrintTo(const ReferenceWrapper<T>& ref, ::std::ostream* os) {\n  T& value = ref;\n  UniversalPrinter<T&>::Print(value, os);\n}\n\n// Does two actions sequentially.  Used for implementing the DoAll(a1,\n// a2, ...) action.\ntemplate <typename Action1, typename Action2>\nclass DoBothAction {\n public:\n  DoBothAction(Action1 action1, Action2 action2)\n      : action1_(action1), action2_(action2) {}\n\n  // This template type conversion operator allows DoAll(a1, ..., a_n)\n  // to be used in ANY function of compatible type.\n  template <typename F>\n  operator Action<F>() const {\n    return Action<F>(new Impl<F>(action1_, action2_));\n  }\n\n private:\n  // Implements the DoAll(...) action for a particular function type F.\n  template <typename F>\n  class Impl : public ActionInterface<F> {\n   public:\n    typedef typename Function<F>::Result Result;\n    typedef typename Function<F>::ArgumentTuple ArgumentTuple;\n    typedef typename Function<F>::MakeResultVoid VoidResult;\n\n    Impl(const Action<VoidResult>& action1, const Action<F>& action2)\n        : action1_(action1), action2_(action2) {}\n\n    virtual Result Perform(const ArgumentTuple& args) {\n      action1_.Perform(args);\n      return action2_.Perform(args);\n    }\n\n   private:\n    const Action<VoidResult> action1_;\n    const Action<F> action2_;\n\n    GTEST_DISALLOW_ASSIGN_(Impl);\n  };\n\n  Action1 action1_;\n  Action2 action2_;\n\n  GTEST_DISALLOW_ASSIGN_(DoBothAction);\n};\n\n}  // namespace internal\n\n// An Unused object can be implicitly constructed from ANY value.\n// This is handy when defining actions that ignore some or all of the\n// mock function arguments.  For example, given\n//\n//   MOCK_METHOD3(Foo, double(const string& label, double x, double y));\n//   MOCK_METHOD3(Bar, double(int index, double x, double y));\n//\n// instead of\n//\n//   double DistanceToOriginWithLabel(const string& label, double x, double y) {\n//     return sqrt(x*x + y*y);\n//   }\n//   double DistanceToOriginWithIndex(int index, double x, double y) {\n//     return sqrt(x*x + y*y);\n//   }\n//   ...\n//   EXEPCT_CALL(mock, Foo(\"abc\", _, _))\n//       .WillOnce(Invoke(DistanceToOriginWithLabel));\n//   EXEPCT_CALL(mock, Bar(5, _, _))\n//       .WillOnce(Invoke(DistanceToOriginWithIndex));\n//\n// you could write\n//\n//   // We can declare any uninteresting argument as Unused.\n//   double DistanceToOrigin(Unused, double x, double y) {\n//     return sqrt(x*x + y*y);\n//   }\n//   ...\n//   EXEPCT_CALL(mock, Foo(\"abc\", _, _)).WillOnce(Invoke(DistanceToOrigin));\n//   EXEPCT_CALL(mock, Bar(5, _, _)).WillOnce(Invoke(DistanceToOrigin));\ntypedef internal::IgnoredValue Unused;\n\n// This constructor allows us to turn an Action<From> object into an\n// Action<To>, as long as To's arguments can be implicitly converted\n// to From's and From's return type cann be implicitly converted to\n// To's.\ntemplate <typename To>\ntemplate <typename From>\nAction<To>::Action(const Action<From>& from)\n    : impl_(new internal::ActionAdaptor<To, From>(from)) {}\n\n// Creates an action that returns 'value'.  'value' is passed by value\n// instead of const reference - otherwise Return(\"string literal\")\n// will trigger a compiler error about using array as initializer.\ntemplate <typename R>\ninternal::ReturnAction<R> Return(R value) {\n  return internal::ReturnAction<R>(internal::move(value));\n}\n\n// Creates an action that returns NULL.\ninline PolymorphicAction<internal::ReturnNullAction> ReturnNull() {\n  return MakePolymorphicAction(internal::ReturnNullAction());\n}\n\n// Creates an action that returns from a void function.\ninline PolymorphicAction<internal::ReturnVoidAction> Return() {\n  return MakePolymorphicAction(internal::ReturnVoidAction());\n}\n\n// Creates an action that returns the reference to a variable.\ntemplate <typename R>\ninline internal::ReturnRefAction<R> ReturnRef(R& x) {  // NOLINT\n  return internal::ReturnRefAction<R>(x);\n}\n\n// Creates an action that returns the reference to a copy of the\n// argument.  The copy is created when the action is constructed and\n// lives as long as the action.\ntemplate <typename R>\ninline internal::ReturnRefOfCopyAction<R> ReturnRefOfCopy(const R& x) {\n  return internal::ReturnRefOfCopyAction<R>(x);\n}\n\n// Modifies the parent action (a Return() action) to perform a move of the\n// argument instead of a copy.\n// Return(ByMove()) actions can only be executed once and will assert this\n// invariant.\ntemplate <typename R>\ninternal::ByMoveWrapper<R> ByMove(R x) {\n  return internal::ByMoveWrapper<R>(internal::move(x));\n}\n\n// Creates an action that does the default action for the give mock function.\ninline internal::DoDefaultAction DoDefault() {\n  return internal::DoDefaultAction();\n}\n\n// Creates an action that sets the variable pointed by the N-th\n// (0-based) function argument to 'value'.\ntemplate <size_t N, typename T>\nPolymorphicAction<\n  internal::SetArgumentPointeeAction<\n    N, T, internal::IsAProtocolMessage<T>::value> >\nSetArgPointee(const T& x) {\n  return MakePolymorphicAction(internal::SetArgumentPointeeAction<\n      N, T, internal::IsAProtocolMessage<T>::value>(x));\n}\n\n#if !((GTEST_GCC_VER_ && GTEST_GCC_VER_ < 40000) || GTEST_OS_SYMBIAN)\n// This overload allows SetArgPointee() to accept a string literal.\n// GCC prior to the version 4.0 and Symbian C++ compiler cannot distinguish\n// this overload from the templated version and emit a compile error.\ntemplate <size_t N>\nPolymorphicAction<\n  internal::SetArgumentPointeeAction<N, const char*, false> >\nSetArgPointee(const char* p) {\n  return MakePolymorphicAction(internal::SetArgumentPointeeAction<\n      N, const char*, false>(p));\n}\n\ntemplate <size_t N>\nPolymorphicAction<\n  internal::SetArgumentPointeeAction<N, const wchar_t*, false> >\nSetArgPointee(const wchar_t* p) {\n  return MakePolymorphicAction(internal::SetArgumentPointeeAction<\n      N, const wchar_t*, false>(p));\n}\n#endif\n\n// The following version is DEPRECATED.\ntemplate <size_t N, typename T>\nPolymorphicAction<\n  internal::SetArgumentPointeeAction<\n    N, T, internal::IsAProtocolMessage<T>::value> >\nSetArgumentPointee(const T& x) {\n  return MakePolymorphicAction(internal::SetArgumentPointeeAction<\n      N, T, internal::IsAProtocolMessage<T>::value>(x));\n}\n\n// Creates an action that sets a pointer referent to a given value.\ntemplate <typename T1, typename T2>\nPolymorphicAction<internal::AssignAction<T1, T2> > Assign(T1* ptr, T2 val) {\n  return MakePolymorphicAction(internal::AssignAction<T1, T2>(ptr, val));\n}\n\n#if !GTEST_OS_WINDOWS_MOBILE\n\n// Creates an action that sets errno and returns the appropriate error.\ntemplate <typename T>\nPolymorphicAction<internal::SetErrnoAndReturnAction<T> >\nSetErrnoAndReturn(int errval, T result) {\n  return MakePolymorphicAction(\n      internal::SetErrnoAndReturnAction<T>(errval, result));\n}\n\n#endif  // !GTEST_OS_WINDOWS_MOBILE\n\n// Various overloads for InvokeWithoutArgs().\n\n// Creates an action that invokes 'function_impl' with no argument.\ntemplate <typename FunctionImpl>\nPolymorphicAction<internal::InvokeWithoutArgsAction<FunctionImpl> >\nInvokeWithoutArgs(FunctionImpl function_impl) {\n  return MakePolymorphicAction(\n      internal::InvokeWithoutArgsAction<FunctionImpl>(function_impl));\n}\n\n// Creates an action that invokes the given method on the given object\n// with no argument.\ntemplate <class Class, typename MethodPtr>\nPolymorphicAction<internal::InvokeMethodWithoutArgsAction<Class, MethodPtr> >\nInvokeWithoutArgs(Class* obj_ptr, MethodPtr method_ptr) {\n  return MakePolymorphicAction(\n      internal::InvokeMethodWithoutArgsAction<Class, MethodPtr>(\n          obj_ptr, method_ptr));\n}\n\n// Creates an action that performs an_action and throws away its\n// result.  In other words, it changes the return type of an_action to\n// void.  an_action MUST NOT return void, or the code won't compile.\ntemplate <typename A>\ninline internal::IgnoreResultAction<A> IgnoreResult(const A& an_action) {\n  return internal::IgnoreResultAction<A>(an_action);\n}\n\n// Creates a reference wrapper for the given L-value.  If necessary,\n// you can explicitly specify the type of the reference.  For example,\n// suppose 'derived' is an object of type Derived, ByRef(derived)\n// would wrap a Derived&.  If you want to wrap a const Base& instead,\n// where Base is a base class of Derived, just write:\n//\n//   ByRef<const Base>(derived)\ntemplate <typename T>\ninline internal::ReferenceWrapper<T> ByRef(T& l_value) {  // NOLINT\n  return internal::ReferenceWrapper<T>(l_value);\n}\n\n}  // namespace testing\n\n#endif  // GMOCK_INCLUDE_GMOCK_GMOCK_ACTIONS_H_\n"}, "30": {"id": 30, "path": "/home/vsts/work/1/llvm-project/llvm/utils/unittest/googlemock/include/gmock/gmock-cardinalities.h", "content": "// Copyright 2007, Google Inc.\n// All rights reserved.\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are\n// met:\n//\n//     * Redistributions of source code must retain the above copyright\n// notice, this list of conditions and the following disclaimer.\n//     * Redistributions in binary form must reproduce the above\n// copyright notice, this list of conditions and the following disclaimer\n// in the documentation and/or other materials provided with the\n// distribution.\n//     * Neither the name of Google Inc. nor the names of its\n// contributors may be used to endorse or promote products derived from\n// this software without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n//\n// Author: wan@google.com (Zhanyong Wan)\n\n// Google Mock - a framework for writing C++ mock classes.\n//\n// This file implements some commonly used cardinalities.  More\n// cardinalities can be defined by the user implementing the\n// CardinalityInterface interface if necessary.\n\n// IWYU pragma: private, include \"gmock/gmock.h\"\n\n#ifndef GMOCK_INCLUDE_GMOCK_GMOCK_CARDINALITIES_H_\n#define GMOCK_INCLUDE_GMOCK_GMOCK_CARDINALITIES_H_\n\n#include <limits.h>\n#include <ostream>  // NOLINT\n#include \"gmock/internal/gmock-port.h\"\n#include \"gtest/gtest.h\"\n\nnamespace testing {\n\n// To implement a cardinality Foo, define:\n//   1. a class FooCardinality that implements the\n//      CardinalityInterface interface, and\n//   2. a factory function that creates a Cardinality object from a\n//      const FooCardinality*.\n//\n// The two-level delegation design follows that of Matcher, providing\n// consistency for extension developers.  It also eases ownership\n// management as Cardinality objects can now be copied like plain values.\n\n// The implementation of a cardinality.\nclass CardinalityInterface {\n public:\n  virtual ~CardinalityInterface() {}\n\n  // Conservative estimate on the lower/upper bound of the number of\n  // calls allowed.\n  virtual int ConservativeLowerBound() const { return 0; }\n  virtual int ConservativeUpperBound() const { return INT_MAX; }\n\n  // Returns true iff call_count calls will satisfy this cardinality.\n  virtual bool IsSatisfiedByCallCount(int call_count) const = 0;\n\n  // Returns true iff call_count calls will saturate this cardinality.\n  virtual bool IsSaturatedByCallCount(int call_count) const = 0;\n\n  // Describes self to an ostream.\n  virtual void DescribeTo(::std::ostream* os) const = 0;\n};\n\n// A Cardinality is a copyable and IMMUTABLE (except by assignment)\n// object that specifies how many times a mock function is expected to\n// be called.  The implementation of Cardinality is just a linked_ptr\n// to const CardinalityInterface, so copying is fairly cheap.\n// Don't inherit from Cardinality!\nclass GTEST_API_ Cardinality {\n public:\n  // Constructs a null cardinality.  Needed for storing Cardinality\n  // objects in STL containers.\n  Cardinality() {}\n\n  // Constructs a Cardinality from its implementation.\n  explicit Cardinality(const CardinalityInterface* impl) : impl_(impl) {}\n\n  // Conservative estimate on the lower/upper bound of the number of\n  // calls allowed.\n  int ConservativeLowerBound() const { return impl_->ConservativeLowerBound(); }\n  int ConservativeUpperBound() const { return impl_->ConservativeUpperBound(); }\n\n  // Returns true iff call_count calls will satisfy this cardinality.\n  bool IsSatisfiedByCallCount(int call_count) const {\n    return impl_->IsSatisfiedByCallCount(call_count);\n  }\n\n  // Returns true iff call_count calls will saturate this cardinality.\n  bool IsSaturatedByCallCount(int call_count) const {\n    return impl_->IsSaturatedByCallCount(call_count);\n  }\n\n  // Returns true iff call_count calls will over-saturate this\n  // cardinality, i.e. exceed the maximum number of allowed calls.\n  bool IsOverSaturatedByCallCount(int call_count) const {\n    return impl_->IsSaturatedByCallCount(call_count) &&\n        !impl_->IsSatisfiedByCallCount(call_count);\n  }\n\n  // Describes self to an ostream\n  void DescribeTo(::std::ostream* os) const { impl_->DescribeTo(os); }\n\n  // Describes the given actual call count to an ostream.\n  static void DescribeActualCallCountTo(int actual_call_count,\n                                        ::std::ostream* os);\n\n private:\n  internal::linked_ptr<const CardinalityInterface> impl_;\n};\n\n// Creates a cardinality that allows at least n calls.\nGTEST_API_ Cardinality AtLeast(int n);\n\n// Creates a cardinality that allows at most n calls.\nGTEST_API_ Cardinality AtMost(int n);\n\n// Creates a cardinality that allows any number of calls.\nGTEST_API_ Cardinality AnyNumber();\n\n// Creates a cardinality that allows between min and max calls.\nGTEST_API_ Cardinality Between(int min, int max);\n\n// Creates a cardinality that allows exactly n calls.\nGTEST_API_ Cardinality Exactly(int n);\n\n// Creates a cardinality from its implementation.\ninline Cardinality MakeCardinality(const CardinalityInterface* c) {\n  return Cardinality(c);\n}\n\n}  // namespace testing\n\n#endif  // GMOCK_INCLUDE_GMOCK_GMOCK_CARDINALITIES_H_\n"}, "31": {"id": 31, "path": "/home/vsts/work/1/llvm-project/llvm/utils/unittest/googlemock/include/gmock/gmock-generated-actions.h", "content": "// This file was GENERATED by a script.  DO NOT EDIT BY HAND!!!\n\n// Copyright 2007, Google Inc.\n// All rights reserved.\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are\n// met:\n//\n//     * Redistributions of source code must retain the above copyright\n// notice, this list of conditions and the following disclaimer.\n//     * Redistributions in binary form must reproduce the above\n// copyright notice, this list of conditions and the following disclaimer\n// in the documentation and/or other materials provided with the\n// distribution.\n//     * Neither the name of Google Inc. nor the names of its\n// contributors may be used to endorse or promote products derived from\n// this software without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n//\n// Author: wan@google.com (Zhanyong Wan)\n\n// Google Mock - a framework for writing C++ mock classes.\n//\n// This file implements some commonly used variadic actions.\n\n// IWYU pragma: private, include \"gmock/gmock.h\"\n\n#ifndef GMOCK_INCLUDE_GMOCK_GMOCK_GENERATED_ACTIONS_H_\n#define GMOCK_INCLUDE_GMOCK_GMOCK_GENERATED_ACTIONS_H_\n\n#include \"gmock/gmock-actions.h\"\n#include \"gmock/internal/gmock-port.h\"\n\nnamespace testing {\nnamespace internal {\n\n// InvokeHelper<F> knows how to unpack an N-tuple and invoke an N-ary\n// function or method with the unpacked values, where F is a function\n// type that takes N arguments.\ntemplate <typename Result, typename ArgumentTuple>\nclass InvokeHelper;\n\ntemplate <typename R>\nclass InvokeHelper<R, ::testing::tuple<> > {\n public:\n  template <typename Function>\n  static R Invoke(Function function, const ::testing::tuple<>&) {\n           return function();\n  }\n\n  template <class Class, typename MethodPtr>\n  static R InvokeMethod(Class* obj_ptr,\n                        MethodPtr method_ptr,\n                        const ::testing::tuple<>&) {\n           return (obj_ptr->*method_ptr)();\n  }\n};\n\ntemplate <typename R, typename A1>\nclass InvokeHelper<R, ::testing::tuple<A1> > {\n public:\n  template <typename Function>\n  static R Invoke(Function function, const ::testing::tuple<A1>& args) {\n           return function(get<0>(args));\n  }\n\n  template <class Class, typename MethodPtr>\n  static R InvokeMethod(Class* obj_ptr,\n                        MethodPtr method_ptr,\n                        const ::testing::tuple<A1>& args) {\n           return (obj_ptr->*method_ptr)(get<0>(args));\n  }\n};\n\ntemplate <typename R, typename A1, typename A2>\nclass InvokeHelper<R, ::testing::tuple<A1, A2> > {\n public:\n  template <typename Function>\n  static R Invoke(Function function, const ::testing::tuple<A1, A2>& args) {\n           return function(get<0>(args), get<1>(args));\n  }\n\n  template <class Class, typename MethodPtr>\n  static R InvokeMethod(Class* obj_ptr,\n                        MethodPtr method_ptr,\n                        const ::testing::tuple<A1, A2>& args) {\n           return (obj_ptr->*method_ptr)(get<0>(args), get<1>(args));\n  }\n};\n\ntemplate <typename R, typename A1, typename A2, typename A3>\nclass InvokeHelper<R, ::testing::tuple<A1, A2, A3> > {\n public:\n  template <typename Function>\n  static R Invoke(Function function, const ::testing::tuple<A1, A2, A3>& args) {\n           return function(get<0>(args), get<1>(args), get<2>(args));\n  }\n\n  template <class Class, typename MethodPtr>\n  static R InvokeMethod(Class* obj_ptr,\n                        MethodPtr method_ptr,\n                        const ::testing::tuple<A1, A2, A3>& args) {\n           return (obj_ptr->*method_ptr)(get<0>(args), get<1>(args),\n               get<2>(args));\n  }\n};\n\ntemplate <typename R, typename A1, typename A2, typename A3, typename A4>\nclass InvokeHelper<R, ::testing::tuple<A1, A2, A3, A4> > {\n public:\n  template <typename Function>\n  static R Invoke(Function function, const ::testing::tuple<A1, A2, A3,\n      A4>& args) {\n           return function(get<0>(args), get<1>(args), get<2>(args),\n               get<3>(args));\n  }\n\n  template <class Class, typename MethodPtr>\n  static R InvokeMethod(Class* obj_ptr,\n                        MethodPtr method_ptr,\n                        const ::testing::tuple<A1, A2, A3, A4>& args) {\n           return (obj_ptr->*method_ptr)(get<0>(args), get<1>(args),\n               get<2>(args), get<3>(args));\n  }\n};\n\ntemplate <typename R, typename A1, typename A2, typename A3, typename A4,\n    typename A5>\nclass InvokeHelper<R, ::testing::tuple<A1, A2, A3, A4, A5> > {\n public:\n  template <typename Function>\n  static R Invoke(Function function, const ::testing::tuple<A1, A2, A3, A4,\n      A5>& args) {\n           return function(get<0>(args), get<1>(args), get<2>(args),\n               get<3>(args), get<4>(args));\n  }\n\n  template <class Class, typename MethodPtr>\n  static R InvokeMethod(Class* obj_ptr,\n                        MethodPtr method_ptr,\n                        const ::testing::tuple<A1, A2, A3, A4, A5>& args) {\n           return (obj_ptr->*method_ptr)(get<0>(args), get<1>(args),\n               get<2>(args), get<3>(args), get<4>(args));\n  }\n};\n\ntemplate <typename R, typename A1, typename A2, typename A3, typename A4,\n    typename A5, typename A6>\nclass InvokeHelper<R, ::testing::tuple<A1, A2, A3, A4, A5, A6> > {\n public:\n  template <typename Function>\n  static R Invoke(Function function, const ::testing::tuple<A1, A2, A3, A4, A5,\n      A6>& args) {\n           return function(get<0>(args), get<1>(args), get<2>(args),\n               get<3>(args), get<4>(args), get<5>(args));\n  }\n\n  template <class Class, typename MethodPtr>\n  static R InvokeMethod(Class* obj_ptr,\n                        MethodPtr method_ptr,\n                        const ::testing::tuple<A1, A2, A3, A4, A5, A6>& args) {\n           return (obj_ptr->*method_ptr)(get<0>(args), get<1>(args),\n               get<2>(args), get<3>(args), get<4>(args), get<5>(args));\n  }\n};\n\ntemplate <typename R, typename A1, typename A2, typename A3, typename A4,\n    typename A5, typename A6, typename A7>\nclass InvokeHelper<R, ::testing::tuple<A1, A2, A3, A4, A5, A6, A7> > {\n public:\n  template <typename Function>\n  static R Invoke(Function function, const ::testing::tuple<A1, A2, A3, A4, A5,\n      A6, A7>& args) {\n           return function(get<0>(args), get<1>(args), get<2>(args),\n               get<3>(args), get<4>(args), get<5>(args), get<6>(args));\n  }\n\n  template <class Class, typename MethodPtr>\n  static R InvokeMethod(Class* obj_ptr,\n                        MethodPtr method_ptr,\n                        const ::testing::tuple<A1, A2, A3, A4, A5, A6,\n                            A7>& args) {\n           return (obj_ptr->*method_ptr)(get<0>(args), get<1>(args),\n               get<2>(args), get<3>(args), get<4>(args), get<5>(args),\n               get<6>(args));\n  }\n};\n\ntemplate <typename R, typename A1, typename A2, typename A3, typename A4,\n    typename A5, typename A6, typename A7, typename A8>\nclass InvokeHelper<R, ::testing::tuple<A1, A2, A3, A4, A5, A6, A7, A8> > {\n public:\n  template <typename Function>\n  static R Invoke(Function function, const ::testing::tuple<A1, A2, A3, A4, A5,\n      A6, A7, A8>& args) {\n           return function(get<0>(args), get<1>(args), get<2>(args),\n               get<3>(args), get<4>(args), get<5>(args), get<6>(args),\n               get<7>(args));\n  }\n\n  template <class Class, typename MethodPtr>\n  static R InvokeMethod(Class* obj_ptr,\n                        MethodPtr method_ptr,\n                        const ::testing::tuple<A1, A2, A3, A4, A5, A6, A7,\n                            A8>& args) {\n           return (obj_ptr->*method_ptr)(get<0>(args), get<1>(args),\n               get<2>(args), get<3>(args), get<4>(args), get<5>(args),\n               get<6>(args), get<7>(args));\n  }\n};\n\ntemplate <typename R, typename A1, typename A2, typename A3, typename A4,\n    typename A5, typename A6, typename A7, typename A8, typename A9>\nclass InvokeHelper<R, ::testing::tuple<A1, A2, A3, A4, A5, A6, A7, A8, A9> > {\n public:\n  template <typename Function>\n  static R Invoke(Function function, const ::testing::tuple<A1, A2, A3, A4, A5,\n      A6, A7, A8, A9>& args) {\n           return function(get<0>(args), get<1>(args), get<2>(args),\n               get<3>(args), get<4>(args), get<5>(args), get<6>(args),\n               get<7>(args), get<8>(args));\n  }\n\n  template <class Class, typename MethodPtr>\n  static R InvokeMethod(Class* obj_ptr,\n                        MethodPtr method_ptr,\n                        const ::testing::tuple<A1, A2, A3, A4, A5, A6, A7, A8,\n                            A9>& args) {\n           return (obj_ptr->*method_ptr)(get<0>(args), get<1>(args),\n               get<2>(args), get<3>(args), get<4>(args), get<5>(args),\n               get<6>(args), get<7>(args), get<8>(args));\n  }\n};\n\ntemplate <typename R, typename A1, typename A2, typename A3, typename A4,\n    typename A5, typename A6, typename A7, typename A8, typename A9,\n    typename A10>\nclass InvokeHelper<R, ::testing::tuple<A1, A2, A3, A4, A5, A6, A7, A8, A9,\n    A10> > {\n public:\n  template <typename Function>\n  static R Invoke(Function function, const ::testing::tuple<A1, A2, A3, A4, A5,\n      A6, A7, A8, A9, A10>& args) {\n           return function(get<0>(args), get<1>(args), get<2>(args),\n               get<3>(args), get<4>(args), get<5>(args), get<6>(args),\n               get<7>(args), get<8>(args), get<9>(args));\n  }\n\n  template <class Class, typename MethodPtr>\n  static R InvokeMethod(Class* obj_ptr,\n                        MethodPtr method_ptr,\n                        const ::testing::tuple<A1, A2, A3, A4, A5, A6, A7, A8,\n                            A9, A10>& args) {\n           return (obj_ptr->*method_ptr)(get<0>(args), get<1>(args),\n               get<2>(args), get<3>(args), get<4>(args), get<5>(args),\n               get<6>(args), get<7>(args), get<8>(args), get<9>(args));\n  }\n};\n\n// An INTERNAL macro for extracting the type of a tuple field.  It's\n// subject to change without notice - DO NOT USE IN USER CODE!\n#define GMOCK_FIELD_(Tuple, N) \\\n    typename ::testing::tuple_element<N, Tuple>::type\n\n// SelectArgs<Result, ArgumentTuple, k1, k2, ..., k_n>::type is the\n// type of an n-ary function whose i-th (1-based) argument type is the\n// k{i}-th (0-based) field of ArgumentTuple, which must be a tuple\n// type, and whose return type is Result.  For example,\n//   SelectArgs<int, ::testing::tuple<bool, char, double, long>, 0, 3>::type\n// is int(bool, long).\n//\n// SelectArgs<Result, ArgumentTuple, k1, k2, ..., k_n>::Select(args)\n// returns the selected fields (k1, k2, ..., k_n) of args as a tuple.\n// For example,\n//   SelectArgs<int, tuple<bool, char, double>, 2, 0>::Select(\n//       ::testing::make_tuple(true, 'a', 2.5))\n// returns tuple (2.5, true).\n//\n// The numbers in list k1, k2, ..., k_n must be >= 0, where n can be\n// in the range [0, 10].  Duplicates are allowed and they don't have\n// to be in an ascending or descending order.\n\ntemplate <typename Result, typename ArgumentTuple, int k1, int k2, int k3,\n    int k4, int k5, int k6, int k7, int k8, int k9, int k10>\nclass SelectArgs {\n public:\n  typedef Result type(GMOCK_FIELD_(ArgumentTuple, k1),\n      GMOCK_FIELD_(ArgumentTuple, k2), GMOCK_FIELD_(ArgumentTuple, k3),\n      GMOCK_FIELD_(ArgumentTuple, k4), GMOCK_FIELD_(ArgumentTuple, k5),\n      GMOCK_FIELD_(ArgumentTuple, k6), GMOCK_FIELD_(ArgumentTuple, k7),\n      GMOCK_FIELD_(ArgumentTuple, k8), GMOCK_FIELD_(ArgumentTuple, k9),\n      GMOCK_FIELD_(ArgumentTuple, k10));\n  typedef typename Function<type>::ArgumentTuple SelectedArgs;\n  static SelectedArgs Select(const ArgumentTuple& args) {\n    return SelectedArgs(get<k1>(args), get<k2>(args), get<k3>(args),\n        get<k4>(args), get<k5>(args), get<k6>(args), get<k7>(args),\n        get<k8>(args), get<k9>(args), get<k10>(args));\n  }\n};\n\ntemplate <typename Result, typename ArgumentTuple>\nclass SelectArgs<Result, ArgumentTuple,\n                 -1, -1, -1, -1, -1, -1, -1, -1, -1, -1> {\n public:\n  typedef Result type();\n  typedef typename Function<type>::ArgumentTuple SelectedArgs;\n  static SelectedArgs Select(const ArgumentTuple& /* args */) {\n    return SelectedArgs();\n  }\n};\n\ntemplate <typename Result, typename ArgumentTuple, int k1>\nclass SelectArgs<Result, ArgumentTuple,\n                 k1, -1, -1, -1, -1, -1, -1, -1, -1, -1> {\n public:\n  typedef Result type(GMOCK_FIELD_(ArgumentTuple, k1));\n  typedef typename Function<type>::ArgumentTuple SelectedArgs;\n  static SelectedArgs Select(const ArgumentTuple& args) {\n    return SelectedArgs(get<k1>(args));\n  }\n};\n\ntemplate <typename Result, typename ArgumentTuple, int k1, int k2>\nclass SelectArgs<Result, ArgumentTuple,\n                 k1, k2, -1, -1, -1, -1, -1, -1, -1, -1> {\n public:\n  typedef Result type(GMOCK_FIELD_(ArgumentTuple, k1),\n      GMOCK_FIELD_(ArgumentTuple, k2));\n  typedef typename Function<type>::ArgumentTuple SelectedArgs;\n  static SelectedArgs Select(const ArgumentTuple& args) {\n    return SelectedArgs(get<k1>(args), get<k2>(args));\n  }\n};\n\ntemplate <typename Result, typename ArgumentTuple, int k1, int k2, int k3>\nclass SelectArgs<Result, ArgumentTuple,\n                 k1, k2, k3, -1, -1, -1, -1, -1, -1, -1> {\n public:\n  typedef Result type(GMOCK_FIELD_(ArgumentTuple, k1),\n      GMOCK_FIELD_(ArgumentTuple, k2), GMOCK_FIELD_(ArgumentTuple, k3));\n  typedef typename Function<type>::ArgumentTuple SelectedArgs;\n  static SelectedArgs Select(const ArgumentTuple& args) {\n    return SelectedArgs(get<k1>(args), get<k2>(args), get<k3>(args));\n  }\n};\n\ntemplate <typename Result, typename ArgumentTuple, int k1, int k2, int k3,\n    int k4>\nclass SelectArgs<Result, ArgumentTuple,\n                 k1, k2, k3, k4, -1, -1, -1, -1, -1, -1> {\n public:\n  typedef Result type(GMOCK_FIELD_(ArgumentTuple, k1),\n      GMOCK_FIELD_(ArgumentTuple, k2), GMOCK_FIELD_(ArgumentTuple, k3),\n      GMOCK_FIELD_(ArgumentTuple, k4));\n  typedef typename Function<type>::ArgumentTuple SelectedArgs;\n  static SelectedArgs Select(const ArgumentTuple& args) {\n    return SelectedArgs(get<k1>(args), get<k2>(args), get<k3>(args),\n        get<k4>(args));\n  }\n};\n\ntemplate <typename Result, typename ArgumentTuple, int k1, int k2, int k3,\n    int k4, int k5>\nclass SelectArgs<Result, ArgumentTuple,\n                 k1, k2, k3, k4, k5, -1, -1, -1, -1, -1> {\n public:\n  typedef Result type(GMOCK_FIELD_(ArgumentTuple, k1),\n      GMOCK_FIELD_(ArgumentTuple, k2), GMOCK_FIELD_(ArgumentTuple, k3),\n      GMOCK_FIELD_(ArgumentTuple, k4), GMOCK_FIELD_(ArgumentTuple, k5));\n  typedef typename Function<type>::ArgumentTuple SelectedArgs;\n  static SelectedArgs Select(const ArgumentTuple& args) {\n    return SelectedArgs(get<k1>(args), get<k2>(args), get<k3>(args),\n        get<k4>(args), get<k5>(args));\n  }\n};\n\ntemplate <typename Result, typename ArgumentTuple, int k1, int k2, int k3,\n    int k4, int k5, int k6>\nclass SelectArgs<Result, ArgumentTuple,\n                 k1, k2, k3, k4, k5, k6, -1, -1, -1, -1> {\n public:\n  typedef Result type(GMOCK_FIELD_(ArgumentTuple, k1),\n      GMOCK_FIELD_(ArgumentTuple, k2), GMOCK_FIELD_(ArgumentTuple, k3),\n      GMOCK_FIELD_(ArgumentTuple, k4), GMOCK_FIELD_(ArgumentTuple, k5),\n      GMOCK_FIELD_(ArgumentTuple, k6));\n  typedef typename Function<type>::ArgumentTuple SelectedArgs;\n  static SelectedArgs Select(const ArgumentTuple& args) {\n    return SelectedArgs(get<k1>(args), get<k2>(args), get<k3>(args),\n        get<k4>(args), get<k5>(args), get<k6>(args));\n  }\n};\n\ntemplate <typename Result, typename ArgumentTuple, int k1, int k2, int k3,\n    int k4, int k5, int k6, int k7>\nclass SelectArgs<Result, ArgumentTuple,\n                 k1, k2, k3, k4, k5, k6, k7, -1, -1, -1> {\n public:\n  typedef Result type(GMOCK_FIELD_(ArgumentTuple, k1),\n      GMOCK_FIELD_(ArgumentTuple, k2), GMOCK_FIELD_(ArgumentTuple, k3),\n      GMOCK_FIELD_(ArgumentTuple, k4), GMOCK_FIELD_(ArgumentTuple, k5),\n      GMOCK_FIELD_(ArgumentTuple, k6), GMOCK_FIELD_(ArgumentTuple, k7));\n  typedef typename Function<type>::ArgumentTuple SelectedArgs;\n  static SelectedArgs Select(const ArgumentTuple& args) {\n    return SelectedArgs(get<k1>(args), get<k2>(args), get<k3>(args),\n        get<k4>(args), get<k5>(args), get<k6>(args), get<k7>(args));\n  }\n};\n\ntemplate <typename Result, typename ArgumentTuple, int k1, int k2, int k3,\n    int k4, int k5, int k6, int k7, int k8>\nclass SelectArgs<Result, ArgumentTuple,\n                 k1, k2, k3, k4, k5, k6, k7, k8, -1, -1> {\n public:\n  typedef Result type(GMOCK_FIELD_(ArgumentTuple, k1),\n      GMOCK_FIELD_(ArgumentTuple, k2), GMOCK_FIELD_(ArgumentTuple, k3),\n      GMOCK_FIELD_(ArgumentTuple, k4), GMOCK_FIELD_(ArgumentTuple, k5),\n      GMOCK_FIELD_(ArgumentTuple, k6), GMOCK_FIELD_(ArgumentTuple, k7),\n      GMOCK_FIELD_(ArgumentTuple, k8));\n  typedef typename Function<type>::ArgumentTuple SelectedArgs;\n  static SelectedArgs Select(const ArgumentTuple& args) {\n    return SelectedArgs(get<k1>(args), get<k2>(args), get<k3>(args),\n        get<k4>(args), get<k5>(args), get<k6>(args), get<k7>(args),\n        get<k8>(args));\n  }\n};\n\ntemplate <typename Result, typename ArgumentTuple, int k1, int k2, int k3,\n    int k4, int k5, int k6, int k7, int k8, int k9>\nclass SelectArgs<Result, ArgumentTuple,\n                 k1, k2, k3, k4, k5, k6, k7, k8, k9, -1> {\n public:\n  typedef Result type(GMOCK_FIELD_(ArgumentTuple, k1),\n      GMOCK_FIELD_(ArgumentTuple, k2), GMOCK_FIELD_(ArgumentTuple, k3),\n      GMOCK_FIELD_(ArgumentTuple, k4), GMOCK_FIELD_(ArgumentTuple, k5),\n      GMOCK_FIELD_(ArgumentTuple, k6), GMOCK_FIELD_(ArgumentTuple, k7),\n      GMOCK_FIELD_(ArgumentTuple, k8), GMOCK_FIELD_(ArgumentTuple, k9));\n  typedef typename Function<type>::ArgumentTuple SelectedArgs;\n  static SelectedArgs Select(const ArgumentTuple& args) {\n    return SelectedArgs(get<k1>(args), get<k2>(args), get<k3>(args),\n        get<k4>(args), get<k5>(args), get<k6>(args), get<k7>(args),\n        get<k8>(args), get<k9>(args));\n  }\n};\n\n#undef GMOCK_FIELD_\n\n// Implements the WithArgs action.\ntemplate <typename InnerAction, int k1 = -1, int k2 = -1, int k3 = -1,\n    int k4 = -1, int k5 = -1, int k6 = -1, int k7 = -1, int k8 = -1,\n    int k9 = -1, int k10 = -1>\nclass WithArgsAction {\n public:\n  explicit WithArgsAction(const InnerAction& action) : action_(action) {}\n\n  template <typename F>\n  operator Action<F>() const { return MakeAction(new Impl<F>(action_)); }\n\n private:\n  template <typename F>\n  class Impl : public ActionInterface<F> {\n   public:\n    typedef typename Function<F>::Result Result;\n    typedef typename Function<F>::ArgumentTuple ArgumentTuple;\n\n    explicit Impl(const InnerAction& action) : action_(action) {}\n\n    virtual Result Perform(const ArgumentTuple& args) {\n      return action_.Perform(SelectArgs<Result, ArgumentTuple, k1, k2, k3, k4,\n          k5, k6, k7, k8, k9, k10>::Select(args));\n    }\n\n   private:\n    typedef typename SelectArgs<Result, ArgumentTuple,\n        k1, k2, k3, k4, k5, k6, k7, k8, k9, k10>::type InnerFunctionType;\n\n    Action<InnerFunctionType> action_;\n  };\n\n  const InnerAction action_;\n\n  GTEST_DISALLOW_ASSIGN_(WithArgsAction);\n};\n\n// A macro from the ACTION* family (defined later in this file)\n// defines an action that can be used in a mock function.  Typically,\n// these actions only care about a subset of the arguments of the mock\n// function.  For example, if such an action only uses the second\n// argument, it can be used in any mock function that takes >= 2\n// arguments where the type of the second argument is compatible.\n//\n// Therefore, the action implementation must be prepared to take more\n// arguments than it needs.  The ExcessiveArg type is used to\n// represent those excessive arguments.  In order to keep the compiler\n// error messages tractable, we define it in the testing namespace\n// instead of testing::internal.  However, this is an INTERNAL TYPE\n// and subject to change without notice, so a user MUST NOT USE THIS\n// TYPE DIRECTLY.\nstruct ExcessiveArg {};\n\n// A helper class needed for implementing the ACTION* macros.\ntemplate <typename Result, class Impl>\nclass ActionHelper {\n public:\n  static Result Perform(Impl* impl, const ::testing::tuple<>& args) {\n    return impl->template gmock_PerformImpl<>(args, ExcessiveArg(),\n        ExcessiveArg(), ExcessiveArg(), ExcessiveArg(), ExcessiveArg(),\n        ExcessiveArg(), ExcessiveArg(), ExcessiveArg(), ExcessiveArg(),\n        ExcessiveArg());\n  }\n\n  template <typename A0>\n  static Result Perform(Impl* impl, const ::testing::tuple<A0>& args) {\n    return impl->template gmock_PerformImpl<A0>(args, get<0>(args),\n        ExcessiveArg(), ExcessiveArg(), ExcessiveArg(), ExcessiveArg(),\n        ExcessiveArg(), ExcessiveArg(), ExcessiveArg(), ExcessiveArg(),\n        ExcessiveArg());\n  }\n\n  template <typename A0, typename A1>\n  static Result Perform(Impl* impl, const ::testing::tuple<A0, A1>& args) {\n    return impl->template gmock_PerformImpl<A0, A1>(args, get<0>(args),\n        get<1>(args), ExcessiveArg(), ExcessiveArg(), ExcessiveArg(),\n        ExcessiveArg(), ExcessiveArg(), ExcessiveArg(), ExcessiveArg(),\n        ExcessiveArg());\n  }\n\n  template <typename A0, typename A1, typename A2>\n  static Result Perform(Impl* impl, const ::testing::tuple<A0, A1, A2>& args) {\n    return impl->template gmock_PerformImpl<A0, A1, A2>(args, get<0>(args),\n        get<1>(args), get<2>(args), ExcessiveArg(), ExcessiveArg(),\n        ExcessiveArg(), ExcessiveArg(), ExcessiveArg(), ExcessiveArg(),\n        ExcessiveArg());\n  }\n\n  template <typename A0, typename A1, typename A2, typename A3>\n  static Result Perform(Impl* impl, const ::testing::tuple<A0, A1, A2,\n      A3>& args) {\n    return impl->template gmock_PerformImpl<A0, A1, A2, A3>(args, get<0>(args),\n        get<1>(args), get<2>(args), get<3>(args), ExcessiveArg(),\n        ExcessiveArg(), ExcessiveArg(), ExcessiveArg(), ExcessiveArg(),\n        ExcessiveArg());\n  }\n\n  template <typename A0, typename A1, typename A2, typename A3, typename A4>\n  static Result Perform(Impl* impl, const ::testing::tuple<A0, A1, A2, A3,\n      A4>& args) {\n    return impl->template gmock_PerformImpl<A0, A1, A2, A3, A4>(args,\n        get<0>(args), get<1>(args), get<2>(args), get<3>(args), get<4>(args),\n        ExcessiveArg(), ExcessiveArg(), ExcessiveArg(), ExcessiveArg(),\n        ExcessiveArg());\n  }\n\n  template <typename A0, typename A1, typename A2, typename A3, typename A4,\n      typename A5>\n  static Result Perform(Impl* impl, const ::testing::tuple<A0, A1, A2, A3, A4,\n      A5>& args) {\n    return impl->template gmock_PerformImpl<A0, A1, A2, A3, A4, A5>(args,\n        get<0>(args), get<1>(args), get<2>(args), get<3>(args), get<4>(args),\n        get<5>(args), ExcessiveArg(), ExcessiveArg(), ExcessiveArg(),\n        ExcessiveArg());\n  }\n\n  template <typename A0, typename A1, typename A2, typename A3, typename A4,\n      typename A5, typename A6>\n  static Result Perform(Impl* impl, const ::testing::tuple<A0, A1, A2, A3, A4,\n      A5, A6>& args) {\n    return impl->template gmock_PerformImpl<A0, A1, A2, A3, A4, A5, A6>(args,\n        get<0>(args), get<1>(args), get<2>(args), get<3>(args), get<4>(args),\n        get<5>(args), get<6>(args), ExcessiveArg(), ExcessiveArg(),\n        ExcessiveArg());\n  }\n\n  template <typename A0, typename A1, typename A2, typename A3, typename A4,\n      typename A5, typename A6, typename A7>\n  static Result Perform(Impl* impl, const ::testing::tuple<A0, A1, A2, A3, A4,\n      A5, A6, A7>& args) {\n    return impl->template gmock_PerformImpl<A0, A1, A2, A3, A4, A5, A6,\n        A7>(args, get<0>(args), get<1>(args), get<2>(args), get<3>(args),\n        get<4>(args), get<5>(args), get<6>(args), get<7>(args), ExcessiveArg(),\n        ExcessiveArg());\n  }\n\n  template <typename A0, typename A1, typename A2, typename A3, typename A4,\n      typename A5, typename A6, typename A7, typename A8>\n  static Result Perform(Impl* impl, const ::testing::tuple<A0, A1, A2, A3, A4,\n      A5, A6, A7, A8>& args) {\n    return impl->template gmock_PerformImpl<A0, A1, A2, A3, A4, A5, A6, A7,\n        A8>(args, get<0>(args), get<1>(args), get<2>(args), get<3>(args),\n        get<4>(args), get<5>(args), get<6>(args), get<7>(args), get<8>(args),\n        ExcessiveArg());\n  }\n\n  template <typename A0, typename A1, typename A2, typename A3, typename A4,\n      typename A5, typename A6, typename A7, typename A8, typename A9>\n  static Result Perform(Impl* impl, const ::testing::tuple<A0, A1, A2, A3, A4,\n      A5, A6, A7, A8, A9>& args) {\n    return impl->template gmock_PerformImpl<A0, A1, A2, A3, A4, A5, A6, A7, A8,\n        A9>(args, get<0>(args), get<1>(args), get<2>(args), get<3>(args),\n        get<4>(args), get<5>(args), get<6>(args), get<7>(args), get<8>(args),\n        get<9>(args));\n  }\n};\n\n}  // namespace internal\n\n// Various overloads for Invoke().\n\n// WithArgs<N1, N2, ..., Nk>(an_action) creates an action that passes\n// the selected arguments of the mock function to an_action and\n// performs it.  It serves as an adaptor between actions with\n// different argument lists.  C++ doesn't support default arguments for\n// function templates, so we have to overload it.\ntemplate <int k1, typename InnerAction>\ninline internal::WithArgsAction<InnerAction, k1>\nWithArgs(const InnerAction& action) {\n  return internal::WithArgsAction<InnerAction, k1>(action);\n}\n\ntemplate <int k1, int k2, typename InnerAction>\ninline internal::WithArgsAction<InnerAction, k1, k2>\nWithArgs(const InnerAction& action) {\n  return internal::WithArgsAction<InnerAction, k1, k2>(action);\n}\n\ntemplate <int k1, int k2, int k3, typename InnerAction>\ninline internal::WithArgsAction<InnerAction, k1, k2, k3>\nWithArgs(const InnerAction& action) {\n  return internal::WithArgsAction<InnerAction, k1, k2, k3>(action);\n}\n\ntemplate <int k1, int k2, int k3, int k4, typename InnerAction>\ninline internal::WithArgsAction<InnerAction, k1, k2, k3, k4>\nWithArgs(const InnerAction& action) {\n  return internal::WithArgsAction<InnerAction, k1, k2, k3, k4>(action);\n}\n\ntemplate <int k1, int k2, int k3, int k4, int k5, typename InnerAction>\ninline internal::WithArgsAction<InnerAction, k1, k2, k3, k4, k5>\nWithArgs(const InnerAction& action) {\n  return internal::WithArgsAction<InnerAction, k1, k2, k3, k4, k5>(action);\n}\n\ntemplate <int k1, int k2, int k3, int k4, int k5, int k6, typename InnerAction>\ninline internal::WithArgsAction<InnerAction, k1, k2, k3, k4, k5, k6>\nWithArgs(const InnerAction& action) {\n  return internal::WithArgsAction<InnerAction, k1, k2, k3, k4, k5, k6>(action);\n}\n\ntemplate <int k1, int k2, int k3, int k4, int k5, int k6, int k7,\n    typename InnerAction>\ninline internal::WithArgsAction<InnerAction, k1, k2, k3, k4, k5, k6, k7>\nWithArgs(const InnerAction& action) {\n  return internal::WithArgsAction<InnerAction, k1, k2, k3, k4, k5, k6,\n      k7>(action);\n}\n\ntemplate <int k1, int k2, int k3, int k4, int k5, int k6, int k7, int k8,\n    typename InnerAction>\ninline internal::WithArgsAction<InnerAction, k1, k2, k3, k4, k5, k6, k7, k8>\nWithArgs(const InnerAction& action) {\n  return internal::WithArgsAction<InnerAction, k1, k2, k3, k4, k5, k6, k7,\n      k8>(action);\n}\n\ntemplate <int k1, int k2, int k3, int k4, int k5, int k6, int k7, int k8,\n    int k9, typename InnerAction>\ninline internal::WithArgsAction<InnerAction, k1, k2, k3, k4, k5, k6, k7, k8, k9>\nWithArgs(const InnerAction& action) {\n  return internal::WithArgsAction<InnerAction, k1, k2, k3, k4, k5, k6, k7, k8,\n      k9>(action);\n}\n\ntemplate <int k1, int k2, int k3, int k4, int k5, int k6, int k7, int k8,\n    int k9, int k10, typename InnerAction>\ninline internal::WithArgsAction<InnerAction, k1, k2, k3, k4, k5, k6, k7, k8,\n    k9, k10>\nWithArgs(const InnerAction& action) {\n  return internal::WithArgsAction<InnerAction, k1, k2, k3, k4, k5, k6, k7, k8,\n      k9, k10>(action);\n}\n\n// Creates an action that does actions a1, a2, ..., sequentially in\n// each invocation.\ntemplate <typename Action1, typename Action2>\ninline internal::DoBothAction<Action1, Action2>\nDoAll(Action1 a1, Action2 a2) {\n  return internal::DoBothAction<Action1, Action2>(a1, a2);\n}\n\ntemplate <typename Action1, typename Action2, typename Action3>\ninline internal::DoBothAction<Action1, internal::DoBothAction<Action2,\n    Action3> >\nDoAll(Action1 a1, Action2 a2, Action3 a3) {\n  return DoAll(a1, DoAll(a2, a3));\n}\n\ntemplate <typename Action1, typename Action2, typename Action3,\n    typename Action4>\ninline internal::DoBothAction<Action1, internal::DoBothAction<Action2,\n    internal::DoBothAction<Action3, Action4> > >\nDoAll(Action1 a1, Action2 a2, Action3 a3, Action4 a4) {\n  return DoAll(a1, DoAll(a2, a3, a4));\n}\n\ntemplate <typename Action1, typename Action2, typename Action3,\n    typename Action4, typename Action5>\ninline internal::DoBothAction<Action1, internal::DoBothAction<Action2,\n    internal::DoBothAction<Action3, internal::DoBothAction<Action4,\n    Action5> > > >\nDoAll(Action1 a1, Action2 a2, Action3 a3, Action4 a4, Action5 a5) {\n  return DoAll(a1, DoAll(a2, a3, a4, a5));\n}\n\ntemplate <typename Action1, typename Action2, typename Action3,\n    typename Action4, typename Action5, typename Action6>\ninline internal::DoBothAction<Action1, internal::DoBothAction<Action2,\n    internal::DoBothAction<Action3, internal::DoBothAction<Action4,\n    internal::DoBothAction<Action5, Action6> > > > >\nDoAll(Action1 a1, Action2 a2, Action3 a3, Action4 a4, Action5 a5, Action6 a6) {\n  return DoAll(a1, DoAll(a2, a3, a4, a5, a6));\n}\n\ntemplate <typename Action1, typename Action2, typename Action3,\n    typename Action4, typename Action5, typename Action6, typename Action7>\ninline internal::DoBothAction<Action1, internal::DoBothAction<Action2,\n    internal::DoBothAction<Action3, internal::DoBothAction<Action4,\n    internal::DoBothAction<Action5, internal::DoBothAction<Action6,\n    Action7> > > > > >\nDoAll(Action1 a1, Action2 a2, Action3 a3, Action4 a4, Action5 a5, Action6 a6,\n    Action7 a7) {\n  return DoAll(a1, DoAll(a2, a3, a4, a5, a6, a7));\n}\n\ntemplate <typename Action1, typename Action2, typename Action3,\n    typename Action4, typename Action5, typename Action6, typename Action7,\n    typename Action8>\ninline internal::DoBothAction<Action1, internal::DoBothAction<Action2,\n    internal::DoBothAction<Action3, internal::DoBothAction<Action4,\n    internal::DoBothAction<Action5, internal::DoBothAction<Action6,\n    internal::DoBothAction<Action7, Action8> > > > > > >\nDoAll(Action1 a1, Action2 a2, Action3 a3, Action4 a4, Action5 a5, Action6 a6,\n    Action7 a7, Action8 a8) {\n  return DoAll(a1, DoAll(a2, a3, a4, a5, a6, a7, a8));\n}\n\ntemplate <typename Action1, typename Action2, typename Action3,\n    typename Action4, typename Action5, typename Action6, typename Action7,\n    typename Action8, typename Action9>\ninline internal::DoBothAction<Action1, internal::DoBothAction<Action2,\n    internal::DoBothAction<Action3, internal::DoBothAction<Action4,\n    internal::DoBothAction<Action5, internal::DoBothAction<Action6,\n    internal::DoBothAction<Action7, internal::DoBothAction<Action8,\n    Action9> > > > > > > >\nDoAll(Action1 a1, Action2 a2, Action3 a3, Action4 a4, Action5 a5, Action6 a6,\n    Action7 a7, Action8 a8, Action9 a9) {\n  return DoAll(a1, DoAll(a2, a3, a4, a5, a6, a7, a8, a9));\n}\n\ntemplate <typename Action1, typename Action2, typename Action3,\n    typename Action4, typename Action5, typename Action6, typename Action7,\n    typename Action8, typename Action9, typename Action10>\ninline internal::DoBothAction<Action1, internal::DoBothAction<Action2,\n    internal::DoBothAction<Action3, internal::DoBothAction<Action4,\n    internal::DoBothAction<Action5, internal::DoBothAction<Action6,\n    internal::DoBothAction<Action7, internal::DoBothAction<Action8,\n    internal::DoBothAction<Action9, Action10> > > > > > > > >\nDoAll(Action1 a1, Action2 a2, Action3 a3, Action4 a4, Action5 a5, Action6 a6,\n    Action7 a7, Action8 a8, Action9 a9, Action10 a10) {\n  return DoAll(a1, DoAll(a2, a3, a4, a5, a6, a7, a8, a9, a10));\n}\n\n}  // namespace testing\n\n// The ACTION* family of macros can be used in a namespace scope to\n// define custom actions easily.  The syntax:\n//\n//   ACTION(name) { statements; }\n//\n// will define an action with the given name that executes the\n// statements.  The value returned by the statements will be used as\n// the return value of the action.  Inside the statements, you can\n// refer to the K-th (0-based) argument of the mock function by\n// 'argK', and refer to its type by 'argK_type'.  For example:\n//\n//   ACTION(IncrementArg1) {\n//     arg1_type temp = arg1;\n//     return ++(*temp);\n//   }\n//\n// allows you to write\n//\n//   ...WillOnce(IncrementArg1());\n//\n// You can also refer to the entire argument tuple and its type by\n// 'args' and 'args_type', and refer to the mock function type and its\n// return type by 'function_type' and 'return_type'.\n//\n// Note that you don't need to specify the types of the mock function\n// arguments.  However rest assured that your code is still type-safe:\n// you'll get a compiler error if *arg1 doesn't support the ++\n// operator, or if the type of ++(*arg1) isn't compatible with the\n// mock function's return type, for example.\n//\n// Sometimes you'll want to parameterize the action.   For that you can use\n// another macro:\n//\n//   ACTION_P(name, param_name) { statements; }\n//\n// For example:\n//\n//   ACTION_P(Add, n) { return arg0 + n; }\n//\n// will allow you to write:\n//\n//   ...WillOnce(Add(5));\n//\n// Note that you don't need to provide the type of the parameter\n// either.  If you need to reference the type of a parameter named\n// 'foo', you can write 'foo_type'.  For example, in the body of\n// ACTION_P(Add, n) above, you can write 'n_type' to refer to the type\n// of 'n'.\n//\n// We also provide ACTION_P2, ACTION_P3, ..., up to ACTION_P10 to support\n// multi-parameter actions.\n//\n// For the purpose of typing, you can view\n//\n//   ACTION_Pk(Foo, p1, ..., pk) { ... }\n//\n// as shorthand for\n//\n//   template <typename p1_type, ..., typename pk_type>\n//   FooActionPk<p1_type, ..., pk_type> Foo(p1_type p1, ..., pk_type pk) { ... }\n//\n// In particular, you can provide the template type arguments\n// explicitly when invoking Foo(), as in Foo<long, bool>(5, false);\n// although usually you can rely on the compiler to infer the types\n// for you automatically.  You can assign the result of expression\n// Foo(p1, ..., pk) to a variable of type FooActionPk<p1_type, ...,\n// pk_type>.  This can be useful when composing actions.\n//\n// You can also overload actions with different numbers of parameters:\n//\n//   ACTION_P(Plus, a) { ... }\n//   ACTION_P2(Plus, a, b) { ... }\n//\n// While it's tempting to always use the ACTION* macros when defining\n// a new action, you should also consider implementing ActionInterface\n// or using MakePolymorphicAction() instead, especially if you need to\n// use the action a lot.  While these approaches require more work,\n// they give you more control on the types of the mock function\n// arguments and the action parameters, which in general leads to\n// better compiler error messages that pay off in the long run.  They\n// also allow overloading actions based on parameter types (as opposed\n// to just based on the number of parameters).\n//\n// CAVEAT:\n//\n// ACTION*() can only be used in a namespace scope.  The reason is\n// that C++ doesn't yet allow function-local types to be used to\n// instantiate templates.  The up-coming C++0x standard will fix this.\n// Once that's done, we'll consider supporting using ACTION*() inside\n// a function.\n//\n// MORE INFORMATION:\n//\n// To learn more about using these macros, please search for 'ACTION'\n// on http://code.google.com/p/googlemock/wiki/CookBook.\n\n// An internal macro needed for implementing ACTION*().\n#define GMOCK_ACTION_ARG_TYPES_AND_NAMES_UNUSED_\\\n    const args_type& args GTEST_ATTRIBUTE_UNUSED_, \\\n    arg0_type arg0 GTEST_ATTRIBUTE_UNUSED_, \\\n    arg1_type arg1 GTEST_ATTRIBUTE_UNUSED_, \\\n    arg2_type arg2 GTEST_ATTRIBUTE_UNUSED_, \\\n    arg3_type arg3 GTEST_ATTRIBUTE_UNUSED_, \\\n    arg4_type arg4 GTEST_ATTRIBUTE_UNUSED_, \\\n    arg5_type arg5 GTEST_ATTRIBUTE_UNUSED_, \\\n    arg6_type arg6 GTEST_ATTRIBUTE_UNUSED_, \\\n    arg7_type arg7 GTEST_ATTRIBUTE_UNUSED_, \\\n    arg8_type arg8 GTEST_ATTRIBUTE_UNUSED_, \\\n    arg9_type arg9 GTEST_ATTRIBUTE_UNUSED_\n\n// Sometimes you want to give an action explicit template parameters\n// that cannot be inferred from its value parameters.  ACTION() and\n// ACTION_P*() don't support that.  ACTION_TEMPLATE() remedies that\n// and can be viewed as an extension to ACTION() and ACTION_P*().\n//\n// The syntax:\n//\n//   ACTION_TEMPLATE(ActionName,\n//                   HAS_m_TEMPLATE_PARAMS(kind1, name1, ..., kind_m, name_m),\n//                   AND_n_VALUE_PARAMS(p1, ..., p_n)) { statements; }\n//\n// defines an action template that takes m explicit template\n// parameters and n value parameters.  name_i is the name of the i-th\n// template parameter, and kind_i specifies whether it's a typename,\n// an integral constant, or a template.  p_i is the name of the i-th\n// value parameter.\n//\n// Example:\n//\n//   // DuplicateArg<k, T>(output) converts the k-th argument of the mock\n//   // function to type T and copies it to *output.\n//   ACTION_TEMPLATE(DuplicateArg,\n//                   HAS_2_TEMPLATE_PARAMS(int, k, typename, T),\n//                   AND_1_VALUE_PARAMS(output)) {\n//     *output = T(::testing::get<k>(args));\n//   }\n//   ...\n//     int n;\n//     EXPECT_CALL(mock, Foo(_, _))\n//         .WillOnce(DuplicateArg<1, unsigned char>(&n));\n//\n// To create an instance of an action template, write:\n//\n//   ActionName<t1, ..., t_m>(v1, ..., v_n)\n//\n// where the ts are the template arguments and the vs are the value\n// arguments.  The value argument types are inferred by the compiler.\n// If you want to explicitly specify the value argument types, you can\n// provide additional template arguments:\n//\n//   ActionName<t1, ..., t_m, u1, ..., u_k>(v1, ..., v_n)\n//\n// where u_i is the desired type of v_i.\n//\n// ACTION_TEMPLATE and ACTION/ACTION_P* can be overloaded on the\n// number of value parameters, but not on the number of template\n// parameters.  Without the restriction, the meaning of the following\n// is unclear:\n//\n//   OverloadedAction<int, bool>(x);\n//\n// Are we using a single-template-parameter action where 'bool' refers\n// to the type of x, or are we using a two-template-parameter action\n// where the compiler is asked to infer the type of x?\n//\n// Implementation notes:\n//\n// GMOCK_INTERNAL_*_HAS_m_TEMPLATE_PARAMS and\n// GMOCK_INTERNAL_*_AND_n_VALUE_PARAMS are internal macros for\n// implementing ACTION_TEMPLATE.  The main trick we use is to create\n// new macro invocations when expanding a macro.  For example, we have\n//\n//   #define ACTION_TEMPLATE(name, template_params, value_params)\n//       ... GMOCK_INTERNAL_DECL_##template_params ...\n//\n// which causes ACTION_TEMPLATE(..., HAS_1_TEMPLATE_PARAMS(typename, T), ...)\n// to expand to\n//\n//       ... GMOCK_INTERNAL_DECL_HAS_1_TEMPLATE_PARAMS(typename, T) ...\n//\n// Since GMOCK_INTERNAL_DECL_HAS_1_TEMPLATE_PARAMS is a macro, the\n// preprocessor will continue to expand it to\n//\n//       ... typename T ...\n//\n// This technique conforms to the C++ standard and is portable.  It\n// allows us to implement action templates using O(N) code, where N is\n// the maximum number of template/value parameters supported.  Without\n// using it, we'd have to devote O(N^2) amount of code to implement all\n// combinations of m and n.\n\n// Declares the template parameters.\n#define GMOCK_INTERNAL_DECL_HAS_1_TEMPLATE_PARAMS(kind0, name0) kind0 name0\n#define GMOCK_INTERNAL_DECL_HAS_2_TEMPLATE_PARAMS(kind0, name0, kind1, \\\n    name1) kind0 name0, kind1 name1\n#define GMOCK_INTERNAL_DECL_HAS_3_TEMPLATE_PARAMS(kind0, name0, kind1, name1, \\\n    kind2, name2) kind0 name0, kind1 name1, kind2 name2\n#define GMOCK_INTERNAL_DECL_HAS_4_TEMPLATE_PARAMS(kind0, name0, kind1, name1, \\\n    kind2, name2, kind3, name3) kind0 name0, kind1 name1, kind2 name2, \\\n    kind3 name3\n#define GMOCK_INTERNAL_DECL_HAS_5_TEMPLATE_PARAMS(kind0, name0, kind1, name1, \\\n    kind2, name2, kind3, name3, kind4, name4) kind0 name0, kind1 name1, \\\n    kind2 name2, kind3 name3, kind4 name4\n#define GMOCK_INTERNAL_DECL_HAS_6_TEMPLATE_PARAMS(kind0, name0, kind1, name1, \\\n    kind2, name2, kind3, name3, kind4, name4, kind5, name5) kind0 name0, \\\n    kind1 name1, kind2 name2, kind3 name3, kind4 name4, kind5 name5\n#define GMOCK_INTERNAL_DECL_HAS_7_TEMPLATE_PARAMS(kind0, name0, kind1, name1, \\\n    kind2, name2, kind3, name3, kind4, name4, kind5, name5, kind6, \\\n    name6) kind0 name0, kind1 name1, kind2 name2, kind3 name3, kind4 name4, \\\n    kind5 name5, kind6 name6\n#define GMOCK_INTERNAL_DECL_HAS_8_TEMPLATE_PARAMS(kind0, name0, kind1, name1, \\\n    kind2, name2, kind3, name3, kind4, name4, kind5, name5, kind6, name6, \\\n    kind7, name7) kind0 name0, kind1 name1, kind2 name2, kind3 name3, \\\n    kind4 name4, kind5 name5, kind6 name6, kind7 name7\n#define GMOCK_INTERNAL_DECL_HAS_9_TEMPLATE_PARAMS(kind0, name0, kind1, name1, \\\n    kind2, name2, kind3, name3, kind4, name4, kind5, name5, kind6, name6, \\\n    kind7, name7, kind8, name8) kind0 name0, kind1 name1, kind2 name2, \\\n    kind3 name3, kind4 name4, kind5 name5, kind6 name6, kind7 name7, \\\n    kind8 name8\n#define GMOCK_INTERNAL_DECL_HAS_10_TEMPLATE_PARAMS(kind0, name0, kind1, \\\n    name1, kind2, name2, kind3, name3, kind4, name4, kind5, name5, kind6, \\\n    name6, kind7, name7, kind8, name8, kind9, name9) kind0 name0, \\\n    kind1 name1, kind2 name2, kind3 name3, kind4 name4, kind5 name5, \\\n    kind6 name6, kind7 name7, kind8 name8, kind9 name9\n\n// Lists the template parameters.\n#define GMOCK_INTERNAL_LIST_HAS_1_TEMPLATE_PARAMS(kind0, name0) name0\n#define GMOCK_INTERNAL_LIST_HAS_2_TEMPLATE_PARAMS(kind0, name0, kind1, \\\n    name1) name0, name1\n#define GMOCK_INTERNAL_LIST_HAS_3_TEMPLATE_PARAMS(kind0, name0, kind1, name1, \\\n    kind2, name2) name0, name1, name2\n#define GMOCK_INTERNAL_LIST_HAS_4_TEMPLATE_PARAMS(kind0, name0, kind1, name1, \\\n    kind2, name2, kind3, name3) name0, name1, name2, name3\n#define GMOCK_INTERNAL_LIST_HAS_5_TEMPLATE_PARAMS(kind0, name0, kind1, name1, \\\n    kind2, name2, kind3, name3, kind4, name4) name0, name1, name2, name3, \\\n    name4\n#define GMOCK_INTERNAL_LIST_HAS_6_TEMPLATE_PARAMS(kind0, name0, kind1, name1, \\\n    kind2, name2, kind3, name3, kind4, name4, kind5, name5) name0, name1, \\\n    name2, name3, name4, name5\n#define GMOCK_INTERNAL_LIST_HAS_7_TEMPLATE_PARAMS(kind0, name0, kind1, name1, \\\n    kind2, name2, kind3, name3, kind4, name4, kind5, name5, kind6, \\\n    name6) name0, name1, name2, name3, name4, name5, name6\n#define GMOCK_INTERNAL_LIST_HAS_8_TEMPLATE_PARAMS(kind0, name0, kind1, name1, \\\n    kind2, name2, kind3, name3, kind4, name4, kind5, name5, kind6, name6, \\\n    kind7, name7) name0, name1, name2, name3, name4, name5, name6, name7\n#define GMOCK_INTERNAL_LIST_HAS_9_TEMPLATE_PARAMS(kind0, name0, kind1, name1, \\\n    kind2, name2, kind3, name3, kind4, name4, kind5, name5, kind6, name6, \\\n    kind7, name7, kind8, name8) name0, name1, name2, name3, name4, name5, \\\n    name6, name7, name8\n#define GMOCK_INTERNAL_LIST_HAS_10_TEMPLATE_PARAMS(kind0, name0, kind1, \\\n    name1, kind2, name2, kind3, name3, kind4, name4, kind5, name5, kind6, \\\n    name6, kind7, name7, kind8, name8, kind9, name9) name0, name1, name2, \\\n    name3, name4, name5, name6, name7, name8, name9\n\n// Declares the types of value parameters.\n#define GMOCK_INTERNAL_DECL_TYPE_AND_0_VALUE_PARAMS()\n#define GMOCK_INTERNAL_DECL_TYPE_AND_1_VALUE_PARAMS(p0) , typename p0##_type\n#define GMOCK_INTERNAL_DECL_TYPE_AND_2_VALUE_PARAMS(p0, p1) , \\\n    typename p0##_type, typename p1##_type\n#define GMOCK_INTERNAL_DECL_TYPE_AND_3_VALUE_PARAMS(p0, p1, p2) , \\\n    typename p0##_type, typename p1##_type, typename p2##_type\n#define GMOCK_INTERNAL_DECL_TYPE_AND_4_VALUE_PARAMS(p0, p1, p2, p3) , \\\n    typename p0##_type, typename p1##_type, typename p2##_type, \\\n    typename p3##_type\n#define GMOCK_INTERNAL_DECL_TYPE_AND_5_VALUE_PARAMS(p0, p1, p2, p3, p4) , \\\n    typename p0##_type, typename p1##_type, typename p2##_type, \\\n    typename p3##_type, typename p4##_type\n#define GMOCK_INTERNAL_DECL_TYPE_AND_6_VALUE_PARAMS(p0, p1, p2, p3, p4, p5) , \\\n    typename p0##_type, typename p1##_type, typename p2##_type, \\\n    typename p3##_type, typename p4##_type, typename p5##_type\n#define GMOCK_INTERNAL_DECL_TYPE_AND_7_VALUE_PARAMS(p0, p1, p2, p3, p4, p5, \\\n    p6) , typename p0##_type, typename p1##_type, typename p2##_type, \\\n    typename p3##_type, typename p4##_type, typename p5##_type, \\\n    typename p6##_type\n#define GMOCK_INTERNAL_DECL_TYPE_AND_8_VALUE_PARAMS(p0, p1, p2, p3, p4, p5, \\\n    p6, p7) , typename p0##_type, typename p1##_type, typename p2##_type, \\\n    typename p3##_type, typename p4##_type, typename p5##_type, \\\n    typename p6##_type, typename p7##_type\n#define GMOCK_INTERNAL_DECL_TYPE_AND_9_VALUE_PARAMS(p0, p1, p2, p3, p4, p5, \\\n    p6, p7, p8) , typename p0##_type, typename p1##_type, typename p2##_type, \\\n    typename p3##_type, typename p4##_type, typename p5##_type, \\\n    typename p6##_type, typename p7##_type, typename p8##_type\n#define GMOCK_INTERNAL_DECL_TYPE_AND_10_VALUE_PARAMS(p0, p1, p2, p3, p4, p5, \\\n    p6, p7, p8, p9) , typename p0##_type, typename p1##_type, \\\n    typename p2##_type, typename p3##_type, typename p4##_type, \\\n    typename p5##_type, typename p6##_type, typename p7##_type, \\\n    typename p8##_type, typename p9##_type\n\n// Initializes the value parameters.\n#define GMOCK_INTERNAL_INIT_AND_0_VALUE_PARAMS()\\\n    ()\n#define GMOCK_INTERNAL_INIT_AND_1_VALUE_PARAMS(p0)\\\n    (p0##_type gmock_p0) : p0(gmock_p0)\n#define GMOCK_INTERNAL_INIT_AND_2_VALUE_PARAMS(p0, p1)\\\n    (p0##_type gmock_p0, p1##_type gmock_p1) : p0(gmock_p0), p1(gmock_p1)\n#define GMOCK_INTERNAL_INIT_AND_3_VALUE_PARAMS(p0, p1, p2)\\\n    (p0##_type gmock_p0, p1##_type gmock_p1, \\\n        p2##_type gmock_p2) : p0(gmock_p0), p1(gmock_p1), p2(gmock_p2)\n#define GMOCK_INTERNAL_INIT_AND_4_VALUE_PARAMS(p0, p1, p2, p3)\\\n    (p0##_type gmock_p0, p1##_type gmock_p1, p2##_type gmock_p2, \\\n        p3##_type gmock_p3) : p0(gmock_p0), p1(gmock_p1), p2(gmock_p2), \\\n        p3(gmock_p3)\n#define GMOCK_INTERNAL_INIT_AND_5_VALUE_PARAMS(p0, p1, p2, p3, p4)\\\n    (p0##_type gmock_p0, p1##_type gmock_p1, p2##_type gmock_p2, \\\n        p3##_type gmock_p3, p4##_type gmock_p4) : p0(gmock_p0), p1(gmock_p1), \\\n        p2(gmock_p2), p3(gmock_p3), p4(gmock_p4)\n#define GMOCK_INTERNAL_INIT_AND_6_VALUE_PARAMS(p0, p1, p2, p3, p4, p5)\\\n    (p0##_type gmock_p0, p1##_type gmock_p1, p2##_type gmock_p2, \\\n        p3##_type gmock_p3, p4##_type gmock_p4, \\\n        p5##_type gmock_p5) : p0(gmock_p0), p1(gmock_p1), p2(gmock_p2), \\\n        p3(gmock_p3), p4(gmock_p4), p5(gmock_p5)\n#define GMOCK_INTERNAL_INIT_AND_7_VALUE_PARAMS(p0, p1, p2, p3, p4, p5, p6)\\\n    (p0##_type gmock_p0, p1##_type gmock_p1, p2##_type gmock_p2, \\\n        p3##_type gmock_p3, p4##_type gmock_p4, p5##_type gmock_p5, \\\n        p6##_type gmock_p6) : p0(gmock_p0), p1(gmock_p1), p2(gmock_p2), \\\n        p3(gmock_p3), p4(gmock_p4), p5(gmock_p5), p6(gmock_p6)\n#define GMOCK_INTERNAL_INIT_AND_8_VALUE_PARAMS(p0, p1, p2, p3, p4, p5, p6, p7)\\\n    (p0##_type gmock_p0, p1##_type gmock_p1, p2##_type gmock_p2, \\\n        p3##_type gmock_p3, p4##_type gmock_p4, p5##_type gmock_p5, \\\n        p6##_type gmock_p6, p7##_type gmock_p7) : p0(gmock_p0), p1(gmock_p1), \\\n        p2(gmock_p2), p3(gmock_p3), p4(gmock_p4), p5(gmock_p5), p6(gmock_p6), \\\n        p7(gmock_p7)\n#define GMOCK_INTERNAL_INIT_AND_9_VALUE_PARAMS(p0, p1, p2, p3, p4, p5, p6, \\\n    p7, p8)\\\n    (p0##_type gmock_p0, p1##_type gmock_p1, p2##_type gmock_p2, \\\n        p3##_type gmock_p3, p4##_type gmock_p4, p5##_type gmock_p5, \\\n        p6##_type gmock_p6, p7##_type gmock_p7, \\\n        p8##_type gmock_p8) : p0(gmock_p0), p1(gmock_p1), p2(gmock_p2), \\\n        p3(gmock_p3), p4(gmock_p4), p5(gmock_p5), p6(gmock_p6), p7(gmock_p7), \\\n        p8(gmock_p8)\n#define GMOCK_INTERNAL_INIT_AND_10_VALUE_PARAMS(p0, p1, p2, p3, p4, p5, p6, \\\n    p7, p8, p9)\\\n    (p0##_type gmock_p0, p1##_type gmock_p1, p2##_type gmock_p2, \\\n        p3##_type gmock_p3, p4##_type gmock_p4, p5##_type gmock_p5, \\\n        p6##_type gmock_p6, p7##_type gmock_p7, p8##_type gmock_p8, \\\n        p9##_type gmock_p9) : p0(gmock_p0), p1(gmock_p1), p2(gmock_p2), \\\n        p3(gmock_p3), p4(gmock_p4), p5(gmock_p5), p6(gmock_p6), p7(gmock_p7), \\\n        p8(gmock_p8), p9(gmock_p9)\n\n// Declares the fields for storing the value parameters.\n#define GMOCK_INTERNAL_DEFN_AND_0_VALUE_PARAMS()\n#define GMOCK_INTERNAL_DEFN_AND_1_VALUE_PARAMS(p0) p0##_type p0;\n#define GMOCK_INTERNAL_DEFN_AND_2_VALUE_PARAMS(p0, p1) p0##_type p0; \\\n    p1##_type p1;\n#define GMOCK_INTERNAL_DEFN_AND_3_VALUE_PARAMS(p0, p1, p2) p0##_type p0; \\\n    p1##_type p1; p2##_type p2;\n#define GMOCK_INTERNAL_DEFN_AND_4_VALUE_PARAMS(p0, p1, p2, p3) p0##_type p0; \\\n    p1##_type p1; p2##_type p2; p3##_type p3;\n#define GMOCK_INTERNAL_DEFN_AND_5_VALUE_PARAMS(p0, p1, p2, p3, \\\n    p4) p0##_type p0; p1##_type p1; p2##_type p2; p3##_type p3; p4##_type p4;\n#define GMOCK_INTERNAL_DEFN_AND_6_VALUE_PARAMS(p0, p1, p2, p3, p4, \\\n    p5) p0##_type p0; p1##_type p1; p2##_type p2; p3##_type p3; p4##_type p4; \\\n    p5##_type p5;\n#define GMOCK_INTERNAL_DEFN_AND_7_VALUE_PARAMS(p0, p1, p2, p3, p4, p5, \\\n    p6) p0##_type p0; p1##_type p1; p2##_type p2; p3##_type p3; p4##_type p4; \\\n    p5##_type p5; p6##_type p6;\n#define GMOCK_INTERNAL_DEFN_AND_8_VALUE_PARAMS(p0, p1, p2, p3, p4, p5, p6, \\\n    p7) p0##_type p0; p1##_type p1; p2##_type p2; p3##_type p3; p4##_type p4; \\\n    p5##_type p5; p6##_type p6; p7##_type p7;\n#define GMOCK_INTERNAL_DEFN_AND_9_VALUE_PARAMS(p0, p1, p2, p3, p4, p5, p6, \\\n    p7, p8) p0##_type p0; p1##_type p1; p2##_type p2; p3##_type p3; \\\n    p4##_type p4; p5##_type p5; p6##_type p6; p7##_type p7; p8##_type p8;\n#define GMOCK_INTERNAL_DEFN_AND_10_VALUE_PARAMS(p0, p1, p2, p3, p4, p5, p6, \\\n    p7, p8, p9) p0##_type p0; p1##_type p1; p2##_type p2; p3##_type p3; \\\n    p4##_type p4; p5##_type p5; p6##_type p6; p7##_type p7; p8##_type p8; \\\n    p9##_type p9;\n\n// Lists the value parameters.\n#define GMOCK_INTERNAL_LIST_AND_0_VALUE_PARAMS()\n#define GMOCK_INTERNAL_LIST_AND_1_VALUE_PARAMS(p0) p0\n#define GMOCK_INTERNAL_LIST_AND_2_VALUE_PARAMS(p0, p1) p0, p1\n#define GMOCK_INTERNAL_LIST_AND_3_VALUE_PARAMS(p0, p1, p2) p0, p1, p2\n#define GMOCK_INTERNAL_LIST_AND_4_VALUE_PARAMS(p0, p1, p2, p3) p0, p1, p2, p3\n#define GMOCK_INTERNAL_LIST_AND_5_VALUE_PARAMS(p0, p1, p2, p3, p4) p0, p1, \\\n    p2, p3, p4\n#define GMOCK_INTERNAL_LIST_AND_6_VALUE_PARAMS(p0, p1, p2, p3, p4, p5) p0, \\\n    p1, p2, p3, p4, p5\n#define GMOCK_INTERNAL_LIST_AND_7_VALUE_PARAMS(p0, p1, p2, p3, p4, p5, \\\n    p6) p0, p1, p2, p3, p4, p5, p6\n#define GMOCK_INTERNAL_LIST_AND_8_VALUE_PARAMS(p0, p1, p2, p3, p4, p5, p6, \\\n    p7) p0, p1, p2, p3, p4, p5, p6, p7\n#define GMOCK_INTERNAL_LIST_AND_9_VALUE_PARAMS(p0, p1, p2, p3, p4, p5, p6, \\\n    p7, p8) p0, p1, p2, p3, p4, p5, p6, p7, p8\n#define GMOCK_INTERNAL_LIST_AND_10_VALUE_PARAMS(p0, p1, p2, p3, p4, p5, p6, \\\n    p7, p8, p9) p0, p1, p2, p3, p4, p5, p6, p7, p8, p9\n\n// Lists the value parameter types.\n#define GMOCK_INTERNAL_LIST_TYPE_AND_0_VALUE_PARAMS()\n#define GMOCK_INTERNAL_LIST_TYPE_AND_1_VALUE_PARAMS(p0) , p0##_type\n#define GMOCK_INTERNAL_LIST_TYPE_AND_2_VALUE_PARAMS(p0, p1) , p0##_type, \\\n    p1##_type\n#define GMOCK_INTERNAL_LIST_TYPE_AND_3_VALUE_PARAMS(p0, p1, p2) , p0##_type, \\\n    p1##_type, p2##_type\n#define GMOCK_INTERNAL_LIST_TYPE_AND_4_VALUE_PARAMS(p0, p1, p2, p3) , \\\n    p0##_type, p1##_type, p2##_type, p3##_type\n#define GMOCK_INTERNAL_LIST_TYPE_AND_5_VALUE_PARAMS(p0, p1, p2, p3, p4) , \\\n    p0##_type, p1##_type, p2##_type, p3##_type, p4##_type\n#define GMOCK_INTERNAL_LIST_TYPE_AND_6_VALUE_PARAMS(p0, p1, p2, p3, p4, p5) , \\\n    p0##_type, p1##_type, p2##_type, p3##_type, p4##_type, p5##_type\n#define GMOCK_INTERNAL_LIST_TYPE_AND_7_VALUE_PARAMS(p0, p1, p2, p3, p4, p5, \\\n    p6) , p0##_type, p1##_type, p2##_type, p3##_type, p4##_type, p5##_type, \\\n    p6##_type\n#define GMOCK_INTERNAL_LIST_TYPE_AND_8_VALUE_PARAMS(p0, p1, p2, p3, p4, p5, \\\n    p6, p7) , p0##_type, p1##_type, p2##_type, p3##_type, p4##_type, \\\n    p5##_type, p6##_type, p7##_type\n#define GMOCK_INTERNAL_LIST_TYPE_AND_9_VALUE_PARAMS(p0, p1, p2, p3, p4, p5, \\\n    p6, p7, p8) , p0##_type, p1##_type, p2##_type, p3##_type, p4##_type, \\\n    p5##_type, p6##_type, p7##_type, p8##_type\n#define GMOCK_INTERNAL_LIST_TYPE_AND_10_VALUE_PARAMS(p0, p1, p2, p3, p4, p5, \\\n    p6, p7, p8, p9) , p0##_type, p1##_type, p2##_type, p3##_type, p4##_type, \\\n    p5##_type, p6##_type, p7##_type, p8##_type, p9##_type\n\n// Declares the value parameters.\n#define GMOCK_INTERNAL_DECL_AND_0_VALUE_PARAMS()\n#define GMOCK_INTERNAL_DECL_AND_1_VALUE_PARAMS(p0) p0##_type p0\n#define GMOCK_INTERNAL_DECL_AND_2_VALUE_PARAMS(p0, p1) p0##_type p0, \\\n    p1##_type p1\n#define GMOCK_INTERNAL_DECL_AND_3_VALUE_PARAMS(p0, p1, p2) p0##_type p0, \\\n    p1##_type p1, p2##_type p2\n#define GMOCK_INTERNAL_DECL_AND_4_VALUE_PARAMS(p0, p1, p2, p3) p0##_type p0, \\\n    p1##_type p1, p2##_type p2, p3##_type p3\n#define GMOCK_INTERNAL_DECL_AND_5_VALUE_PARAMS(p0, p1, p2, p3, \\\n    p4) p0##_type p0, p1##_type p1, p2##_type p2, p3##_type p3, p4##_type p4\n#define GMOCK_INTERNAL_DECL_AND_6_VALUE_PARAMS(p0, p1, p2, p3, p4, \\\n    p5) p0##_type p0, p1##_type p1, p2##_type p2, p3##_type p3, p4##_type p4, \\\n    p5##_type p5\n#define GMOCK_INTERNAL_DECL_AND_7_VALUE_PARAMS(p0, p1, p2, p3, p4, p5, \\\n    p6) p0##_type p0, p1##_type p1, p2##_type p2, p3##_type p3, p4##_type p4, \\\n    p5##_type p5, p6##_type p6\n#define GMOCK_INTERNAL_DECL_AND_8_VALUE_PARAMS(p0, p1, p2, p3, p4, p5, p6, \\\n    p7) p0##_type p0, p1##_type p1, p2##_type p2, p3##_type p3, p4##_type p4, \\\n    p5##_type p5, p6##_type p6, p7##_type p7\n#define GMOCK_INTERNAL_DECL_AND_9_VALUE_PARAMS(p0, p1, p2, p3, p4, p5, p6, \\\n    p7, p8) p0##_type p0, p1##_type p1, p2##_type p2, p3##_type p3, \\\n    p4##_type p4, p5##_type p5, p6##_type p6, p7##_type p7, p8##_type p8\n#define GMOCK_INTERNAL_DECL_AND_10_VALUE_PARAMS(p0, p1, p2, p3, p4, p5, p6, \\\n    p7, p8, p9) p0##_type p0, p1##_type p1, p2##_type p2, p3##_type p3, \\\n    p4##_type p4, p5##_type p5, p6##_type p6, p7##_type p7, p8##_type p8, \\\n    p9##_type p9\n\n// The suffix of the class template implementing the action template.\n#define GMOCK_INTERNAL_COUNT_AND_0_VALUE_PARAMS()\n#define GMOCK_INTERNAL_COUNT_AND_1_VALUE_PARAMS(p0) P\n#define GMOCK_INTERNAL_COUNT_AND_2_VALUE_PARAMS(p0, p1) P2\n#define GMOCK_INTERNAL_COUNT_AND_3_VALUE_PARAMS(p0, p1, p2) P3\n#define GMOCK_INTERNAL_COUNT_AND_4_VALUE_PARAMS(p0, p1, p2, p3) P4\n#define GMOCK_INTERNAL_COUNT_AND_5_VALUE_PARAMS(p0, p1, p2, p3, p4) P5\n#define GMOCK_INTERNAL_COUNT_AND_6_VALUE_PARAMS(p0, p1, p2, p3, p4, p5) P6\n#define GMOCK_INTERNAL_COUNT_AND_7_VALUE_PARAMS(p0, p1, p2, p3, p4, p5, p6) P7\n#define GMOCK_INTERNAL_COUNT_AND_8_VALUE_PARAMS(p0, p1, p2, p3, p4, p5, p6, \\\n    p7) P8\n#define GMOCK_INTERNAL_COUNT_AND_9_VALUE_PARAMS(p0, p1, p2, p3, p4, p5, p6, \\\n    p7, p8) P9\n#define GMOCK_INTERNAL_COUNT_AND_10_VALUE_PARAMS(p0, p1, p2, p3, p4, p5, p6, \\\n    p7, p8, p9) P10\n\n// The name of the class template implementing the action template.\n#define GMOCK_ACTION_CLASS_(name, value_params)\\\n    GTEST_CONCAT_TOKEN_(name##Action, GMOCK_INTERNAL_COUNT_##value_params)\n\n#define ACTION_TEMPLATE(name, template_params, value_params)\\\n  template <GMOCK_INTERNAL_DECL_##template_params\\\n            GMOCK_INTERNAL_DECL_TYPE_##value_params>\\\n  class GMOCK_ACTION_CLASS_(name, value_params) {\\\n   public:\\\n    explicit GMOCK_ACTION_CLASS_(name, value_params)\\\n        GMOCK_INTERNAL_INIT_##value_params {}\\\n    template <typename F>\\\n    class gmock_Impl : public ::testing::ActionInterface<F> {\\\n     public:\\\n      typedef F function_type;\\\n      typedef typename ::testing::internal::Function<F>::Result return_type;\\\n      typedef typename ::testing::internal::Function<F>::ArgumentTuple\\\n          args_type;\\\n      explicit gmock_Impl GMOCK_INTERNAL_INIT_##value_params {}\\\n      virtual return_type Perform(const args_type& args) {\\\n        return ::testing::internal::ActionHelper<return_type, gmock_Impl>::\\\n            Perform(this, args);\\\n      }\\\n      template <typename arg0_type, typename arg1_type, typename arg2_type, \\\n          typename arg3_type, typename arg4_type, typename arg5_type, \\\n          typename arg6_type, typename arg7_type, typename arg8_type, \\\n          typename arg9_type>\\\n      return_type gmock_PerformImpl(const args_type& args, arg0_type arg0, \\\n          arg1_type arg1, arg2_type arg2, arg3_type arg3, arg4_type arg4, \\\n          arg5_type arg5, arg6_type arg6, arg7_type arg7, arg8_type arg8, \\\n          arg9_type arg9) const;\\\n      GMOCK_INTERNAL_DEFN_##value_params\\\n     private:\\\n      GTEST_DISALLOW_ASSIGN_(gmock_Impl);\\\n    };\\\n    template <typename F> operator ::testing::Action<F>() const {\\\n      return ::testing::Action<F>(\\\n          new gmock_Impl<F>(GMOCK_INTERNAL_LIST_##value_params));\\\n    }\\\n    GMOCK_INTERNAL_DEFN_##value_params\\\n   private:\\\n    GTEST_DISALLOW_ASSIGN_(GMOCK_ACTION_CLASS_(name, value_params));\\\n  };\\\n  template <GMOCK_INTERNAL_DECL_##template_params\\\n            GMOCK_INTERNAL_DECL_TYPE_##value_params>\\\n  inline GMOCK_ACTION_CLASS_(name, value_params)<\\\n      GMOCK_INTERNAL_LIST_##template_params\\\n      GMOCK_INTERNAL_LIST_TYPE_##value_params> name(\\\n          GMOCK_INTERNAL_DECL_##value_params) {\\\n    return GMOCK_ACTION_CLASS_(name, value_params)<\\\n        GMOCK_INTERNAL_LIST_##template_params\\\n        GMOCK_INTERNAL_LIST_TYPE_##value_params>(\\\n            GMOCK_INTERNAL_LIST_##value_params);\\\n  }\\\n  template <GMOCK_INTERNAL_DECL_##template_params\\\n            GMOCK_INTERNAL_DECL_TYPE_##value_params>\\\n  template <typename F>\\\n  template <typename arg0_type, typename arg1_type, typename arg2_type, \\\n      typename arg3_type, typename arg4_type, typename arg5_type, \\\n      typename arg6_type, typename arg7_type, typename arg8_type, \\\n      typename arg9_type>\\\n  typename ::testing::internal::Function<F>::Result\\\n      GMOCK_ACTION_CLASS_(name, value_params)<\\\n          GMOCK_INTERNAL_LIST_##template_params\\\n          GMOCK_INTERNAL_LIST_TYPE_##value_params>::gmock_Impl<F>::\\\n              gmock_PerformImpl(\\\n          GMOCK_ACTION_ARG_TYPES_AND_NAMES_UNUSED_) const\n\n#define ACTION(name)\\\n  class name##Action {\\\n   public:\\\n    name##Action() {}\\\n    template <typename F>\\\n    class gmock_Impl : public ::testing::ActionInterface<F> {\\\n     public:\\\n      typedef F function_type;\\\n      typedef typename ::testing::internal::Function<F>::Result return_type;\\\n      typedef typename ::testing::internal::Function<F>::ArgumentTuple\\\n          args_type;\\\n      gmock_Impl() {}\\\n      virtual return_type Perform(const args_type& args) {\\\n        return ::testing::internal::ActionHelper<return_type, gmock_Impl>::\\\n            Perform(this, args);\\\n      }\\\n      template <typename arg0_type, typename arg1_type, typename arg2_type, \\\n          typename arg3_type, typename arg4_type, typename arg5_type, \\\n          typename arg6_type, typename arg7_type, typename arg8_type, \\\n          typename arg9_type>\\\n      return_type gmock_PerformImpl(const args_type& args, arg0_type arg0, \\\n          arg1_type arg1, arg2_type arg2, arg3_type arg3, arg4_type arg4, \\\n          arg5_type arg5, arg6_type arg6, arg7_type arg7, arg8_type arg8, \\\n          arg9_type arg9) const;\\\n     private:\\\n      GTEST_DISALLOW_ASSIGN_(gmock_Impl);\\\n    };\\\n    template <typename F> operator ::testing::Action<F>() const {\\\n      return ::testing::Action<F>(new gmock_Impl<F>());\\\n    }\\\n   private:\\\n    GTEST_DISALLOW_ASSIGN_(name##Action);\\\n  };\\\n  inline name##Action name() {\\\n    return name##Action();\\\n  }\\\n  template <typename F>\\\n  template <typename arg0_type, typename arg1_type, typename arg2_type, \\\n      typename arg3_type, typename arg4_type, typename arg5_type, \\\n      typename arg6_type, typename arg7_type, typename arg8_type, \\\n      typename arg9_type>\\\n  typename ::testing::internal::Function<F>::Result\\\n      name##Action::gmock_Impl<F>::gmock_PerformImpl(\\\n          GMOCK_ACTION_ARG_TYPES_AND_NAMES_UNUSED_) const\n\n#define ACTION_P(name, p0)\\\n  template <typename p0##_type>\\\n  class name##ActionP {\\\n   public:\\\n    explicit name##ActionP(p0##_type gmock_p0) : p0(gmock_p0) {}\\\n    template <typename F>\\\n    class gmock_Impl : public ::testing::ActionInterface<F> {\\\n     public:\\\n      typedef F function_type;\\\n      typedef typename ::testing::internal::Function<F>::Result return_type;\\\n      typedef typename ::testing::internal::Function<F>::ArgumentTuple\\\n          args_type;\\\n      explicit gmock_Impl(p0##_type gmock_p0) : p0(gmock_p0) {}\\\n      virtual return_type Perform(const args_type& args) {\\\n        return ::testing::internal::ActionHelper<return_type, gmock_Impl>::\\\n            Perform(this, args);\\\n      }\\\n      template <typename arg0_type, typename arg1_type, typename arg2_type, \\\n          typename arg3_type, typename arg4_type, typename arg5_type, \\\n          typename arg6_type, typename arg7_type, typename arg8_type, \\\n          typename arg9_type>\\\n      return_type gmock_PerformImpl(const args_type& args, arg0_type arg0, \\\n          arg1_type arg1, arg2_type arg2, arg3_type arg3, arg4_type arg4, \\\n          arg5_type arg5, arg6_type arg6, arg7_type arg7, arg8_type arg8, \\\n          arg9_type arg9) const;\\\n      p0##_type p0;\\\n     private:\\\n      GTEST_DISALLOW_ASSIGN_(gmock_Impl);\\\n    };\\\n    template <typename F> operator ::testing::Action<F>() const {\\\n      return ::testing::Action<F>(new gmock_Impl<F>(p0));\\\n    }\\\n    p0##_type p0;\\\n   private:\\\n    GTEST_DISALLOW_ASSIGN_(name##ActionP);\\\n  };\\\n  template <typename p0##_type>\\\n  inline name##ActionP<p0##_type> name(p0##_type p0) {\\\n    return name##ActionP<p0##_type>(p0);\\\n  }\\\n  template <typename p0##_type>\\\n  template <typename F>\\\n  template <typename arg0_type, typename arg1_type, typename arg2_type, \\\n      typename arg3_type, typename arg4_type, typename arg5_type, \\\n      typename arg6_type, typename arg7_type, typename arg8_type, \\\n      typename arg9_type>\\\n  typename ::testing::internal::Function<F>::Result\\\n      name##ActionP<p0##_type>::gmock_Impl<F>::gmock_PerformImpl(\\\n          GMOCK_ACTION_ARG_TYPES_AND_NAMES_UNUSED_) const\n\n#define ACTION_P2(name, p0, p1)\\\n  template <typename p0##_type, typename p1##_type>\\\n  class name##ActionP2 {\\\n   public:\\\n    name##ActionP2(p0##_type gmock_p0, p1##_type gmock_p1) : p0(gmock_p0), \\\n        p1(gmock_p1) {}\\\n    template <typename F>\\\n    class gmock_Impl : public ::testing::ActionInterface<F> {\\\n     public:\\\n      typedef F function_type;\\\n      typedef typename ::testing::internal::Function<F>::Result return_type;\\\n      typedef typename ::testing::internal::Function<F>::ArgumentTuple\\\n          args_type;\\\n      gmock_Impl(p0##_type gmock_p0, p1##_type gmock_p1) : p0(gmock_p0), \\\n          p1(gmock_p1) {}\\\n      virtual return_type Perform(const args_type& args) {\\\n        return ::testing::internal::ActionHelper<return_type, gmock_Impl>::\\\n            Perform(this, args);\\\n      }\\\n      template <typename arg0_type, typename arg1_type, typename arg2_type, \\\n          typename arg3_type, typename arg4_type, typename arg5_type, \\\n          typename arg6_type, typename arg7_type, typename arg8_type, \\\n          typename arg9_type>\\\n      return_type gmock_PerformImpl(const args_type& args, arg0_type arg0, \\\n          arg1_type arg1, arg2_type arg2, arg3_type arg3, arg4_type arg4, \\\n          arg5_type arg5, arg6_type arg6, arg7_type arg7, arg8_type arg8, \\\n          arg9_type arg9) const;\\\n      p0##_type p0;\\\n      p1##_type p1;\\\n     private:\\\n      GTEST_DISALLOW_ASSIGN_(gmock_Impl);\\\n    };\\\n    template <typename F> operator ::testing::Action<F>() const {\\\n      return ::testing::Action<F>(new gmock_Impl<F>(p0, p1));\\\n    }\\\n    p0##_type p0;\\\n    p1##_type p1;\\\n   private:\\\n    GTEST_DISALLOW_ASSIGN_(name##ActionP2);\\\n  };\\\n  template <typename p0##_type, typename p1##_type>\\\n  inline name##ActionP2<p0##_type, p1##_type> name(p0##_type p0, \\\n      p1##_type p1) {\\\n    return name##ActionP2<p0##_type, p1##_type>(p0, p1);\\\n  }\\\n  template <typename p0##_type, typename p1##_type>\\\n  template <typename F>\\\n  template <typename arg0_type, typename arg1_type, typename arg2_type, \\\n      typename arg3_type, typename arg4_type, typename arg5_type, \\\n      typename arg6_type, typename arg7_type, typename arg8_type, \\\n      typename arg9_type>\\\n  typename ::testing::internal::Function<F>::Result\\\n      name##ActionP2<p0##_type, p1##_type>::gmock_Impl<F>::gmock_PerformImpl(\\\n          GMOCK_ACTION_ARG_TYPES_AND_NAMES_UNUSED_) const\n\n#define ACTION_P3(name, p0, p1, p2)\\\n  template <typename p0##_type, typename p1##_type, typename p2##_type>\\\n  class name##ActionP3 {\\\n   public:\\\n    name##ActionP3(p0##_type gmock_p0, p1##_type gmock_p1, \\\n        p2##_type gmock_p2) : p0(gmock_p0), p1(gmock_p1), p2(gmock_p2) {}\\\n    template <typename F>\\\n    class gmock_Impl : public ::testing::ActionInterface<F> {\\\n     public:\\\n      typedef F function_type;\\\n      typedef typename ::testing::internal::Function<F>::Result return_type;\\\n      typedef typename ::testing::internal::Function<F>::ArgumentTuple\\\n          args_type;\\\n      gmock_Impl(p0##_type gmock_p0, p1##_type gmock_p1, \\\n          p2##_type gmock_p2) : p0(gmock_p0), p1(gmock_p1), p2(gmock_p2) {}\\\n      virtual return_type Perform(const args_type& args) {\\\n        return ::testing::internal::ActionHelper<return_type, gmock_Impl>::\\\n            Perform(this, args);\\\n      }\\\n      template <typename arg0_type, typename arg1_type, typename arg2_type, \\\n          typename arg3_type, typename arg4_type, typename arg5_type, \\\n          typename arg6_type, typename arg7_type, typename arg8_type, \\\n          typename arg9_type>\\\n      return_type gmock_PerformImpl(const args_type& args, arg0_type arg0, \\\n          arg1_type arg1, arg2_type arg2, arg3_type arg3, arg4_type arg4, \\\n          arg5_type arg5, arg6_type arg6, arg7_type arg7, arg8_type arg8, \\\n          arg9_type arg9) const;\\\n      p0##_type p0;\\\n      p1##_type p1;\\\n      p2##_type p2;\\\n     private:\\\n      GTEST_DISALLOW_ASSIGN_(gmock_Impl);\\\n    };\\\n    template <typename F> operator ::testing::Action<F>() const {\\\n      return ::testing::Action<F>(new gmock_Impl<F>(p0, p1, p2));\\\n    }\\\n    p0##_type p0;\\\n    p1##_type p1;\\\n    p2##_type p2;\\\n   private:\\\n    GTEST_DISALLOW_ASSIGN_(name##ActionP3);\\\n  };\\\n  template <typename p0##_type, typename p1##_type, typename p2##_type>\\\n  inline name##ActionP3<p0##_type, p1##_type, p2##_type> name(p0##_type p0, \\\n      p1##_type p1, p2##_type p2) {\\\n    return name##ActionP3<p0##_type, p1##_type, p2##_type>(p0, p1, p2);\\\n  }\\\n  template <typename p0##_type, typename p1##_type, typename p2##_type>\\\n  template <typename F>\\\n  template <typename arg0_type, typename arg1_type, typename arg2_type, \\\n      typename arg3_type, typename arg4_type, typename arg5_type, \\\n      typename arg6_type, typename arg7_type, typename arg8_type, \\\n      typename arg9_type>\\\n  typename ::testing::internal::Function<F>::Result\\\n      name##ActionP3<p0##_type, p1##_type, \\\n          p2##_type>::gmock_Impl<F>::gmock_PerformImpl(\\\n          GMOCK_ACTION_ARG_TYPES_AND_NAMES_UNUSED_) const\n\n#define ACTION_P4(name, p0, p1, p2, p3)\\\n  template <typename p0##_type, typename p1##_type, typename p2##_type, \\\n      typename p3##_type>\\\n  class name##ActionP4 {\\\n   public:\\\n    name##ActionP4(p0##_type gmock_p0, p1##_type gmock_p1, \\\n        p2##_type gmock_p2, p3##_type gmock_p3) : p0(gmock_p0), p1(gmock_p1), \\\n        p2(gmock_p2), p3(gmock_p3) {}\\\n    template <typename F>\\\n    class gmock_Impl : public ::testing::ActionInterface<F> {\\\n     public:\\\n      typedef F function_type;\\\n      typedef typename ::testing::internal::Function<F>::Result return_type;\\\n      typedef typename ::testing::internal::Function<F>::ArgumentTuple\\\n          args_type;\\\n      gmock_Impl(p0##_type gmock_p0, p1##_type gmock_p1, p2##_type gmock_p2, \\\n          p3##_type gmock_p3) : p0(gmock_p0), p1(gmock_p1), p2(gmock_p2), \\\n          p3(gmock_p3) {}\\\n      virtual return_type Perform(const args_type& args) {\\\n        return ::testing::internal::ActionHelper<return_type, gmock_Impl>::\\\n            Perform(this, args);\\\n      }\\\n      template <typename arg0_type, typename arg1_type, typename arg2_type, \\\n          typename arg3_type, typename arg4_type, typename arg5_type, \\\n          typename arg6_type, typename arg7_type, typename arg8_type, \\\n          typename arg9_type>\\\n      return_type gmock_PerformImpl(const args_type& args, arg0_type arg0, \\\n          arg1_type arg1, arg2_type arg2, arg3_type arg3, arg4_type arg4, \\\n          arg5_type arg5, arg6_type arg6, arg7_type arg7, arg8_type arg8, \\\n          arg9_type arg9) const;\\\n      p0##_type p0;\\\n      p1##_type p1;\\\n      p2##_type p2;\\\n      p3##_type p3;\\\n     private:\\\n      GTEST_DISALLOW_ASSIGN_(gmock_Impl);\\\n    };\\\n    template <typename F> operator ::testing::Action<F>() const {\\\n      return ::testing::Action<F>(new gmock_Impl<F>(p0, p1, p2, p3));\\\n    }\\\n    p0##_type p0;\\\n    p1##_type p1;\\\n    p2##_type p2;\\\n    p3##_type p3;\\\n   private:\\\n    GTEST_DISALLOW_ASSIGN_(name##ActionP4);\\\n  };\\\n  template <typename p0##_type, typename p1##_type, typename p2##_type, \\\n      typename p3##_type>\\\n  inline name##ActionP4<p0##_type, p1##_type, p2##_type, \\\n      p3##_type> name(p0##_type p0, p1##_type p1, p2##_type p2, \\\n      p3##_type p3) {\\\n    return name##ActionP4<p0##_type, p1##_type, p2##_type, p3##_type>(p0, p1, \\\n        p2, p3);\\\n  }\\\n  template <typename p0##_type, typename p1##_type, typename p2##_type, \\\n      typename p3##_type>\\\n  template <typename F>\\\n  template <typename arg0_type, typename arg1_type, typename arg2_type, \\\n      typename arg3_type, typename arg4_type, typename arg5_type, \\\n      typename arg6_type, typename arg7_type, typename arg8_type, \\\n      typename arg9_type>\\\n  typename ::testing::internal::Function<F>::Result\\\n      name##ActionP4<p0##_type, p1##_type, p2##_type, \\\n          p3##_type>::gmock_Impl<F>::gmock_PerformImpl(\\\n          GMOCK_ACTION_ARG_TYPES_AND_NAMES_UNUSED_) const\n\n#define ACTION_P5(name, p0, p1, p2, p3, p4)\\\n  template <typename p0##_type, typename p1##_type, typename p2##_type, \\\n      typename p3##_type, typename p4##_type>\\\n  class name##ActionP5 {\\\n   public:\\\n    name##ActionP5(p0##_type gmock_p0, p1##_type gmock_p1, \\\n        p2##_type gmock_p2, p3##_type gmock_p3, \\\n        p4##_type gmock_p4) : p0(gmock_p0), p1(gmock_p1), p2(gmock_p2), \\\n        p3(gmock_p3), p4(gmock_p4) {}\\\n    template <typename F>\\\n    class gmock_Impl : public ::testing::ActionInterface<F> {\\\n     public:\\\n      typedef F function_type;\\\n      typedef typename ::testing::internal::Function<F>::Result return_type;\\\n      typedef typename ::testing::internal::Function<F>::ArgumentTuple\\\n          args_type;\\\n      gmock_Impl(p0##_type gmock_p0, p1##_type gmock_p1, p2##_type gmock_p2, \\\n          p3##_type gmock_p3, p4##_type gmock_p4) : p0(gmock_p0), \\\n          p1(gmock_p1), p2(gmock_p2), p3(gmock_p3), p4(gmock_p4) {}\\\n      virtual return_type Perform(const args_type& args) {\\\n        return ::testing::internal::ActionHelper<return_type, gmock_Impl>::\\\n            Perform(this, args);\\\n      }\\\n      template <typename arg0_type, typename arg1_type, typename arg2_type, \\\n          typename arg3_type, typename arg4_type, typename arg5_type, \\\n          typename arg6_type, typename arg7_type, typename arg8_type, \\\n          typename arg9_type>\\\n      return_type gmock_PerformImpl(const args_type& args, arg0_type arg0, \\\n          arg1_type arg1, arg2_type arg2, arg3_type arg3, arg4_type arg4, \\\n          arg5_type arg5, arg6_type arg6, arg7_type arg7, arg8_type arg8, \\\n          arg9_type arg9) const;\\\n      p0##_type p0;\\\n      p1##_type p1;\\\n      p2##_type p2;\\\n      p3##_type p3;\\\n      p4##_type p4;\\\n     private:\\\n      GTEST_DISALLOW_ASSIGN_(gmock_Impl);\\\n    };\\\n    template <typename F> operator ::testing::Action<F>() const {\\\n      return ::testing::Action<F>(new gmock_Impl<F>(p0, p1, p2, p3, p4));\\\n    }\\\n    p0##_type p0;\\\n    p1##_type p1;\\\n    p2##_type p2;\\\n    p3##_type p3;\\\n    p4##_type p4;\\\n   private:\\\n    GTEST_DISALLOW_ASSIGN_(name##ActionP5);\\\n  };\\\n  template <typename p0##_type, typename p1##_type, typename p2##_type, \\\n      typename p3##_type, typename p4##_type>\\\n  inline name##ActionP5<p0##_type, p1##_type, p2##_type, p3##_type, \\\n      p4##_type> name(p0##_type p0, p1##_type p1, p2##_type p2, p3##_type p3, \\\n      p4##_type p4) {\\\n    return name##ActionP5<p0##_type, p1##_type, p2##_type, p3##_type, \\\n        p4##_type>(p0, p1, p2, p3, p4);\\\n  }\\\n  template <typename p0##_type, typename p1##_type, typename p2##_type, \\\n      typename p3##_type, typename p4##_type>\\\n  template <typename F>\\\n  template <typename arg0_type, typename arg1_type, typename arg2_type, \\\n      typename arg3_type, typename arg4_type, typename arg5_type, \\\n      typename arg6_type, typename arg7_type, typename arg8_type, \\\n      typename arg9_type>\\\n  typename ::testing::internal::Function<F>::Result\\\n      name##ActionP5<p0##_type, p1##_type, p2##_type, p3##_type, \\\n          p4##_type>::gmock_Impl<F>::gmock_PerformImpl(\\\n          GMOCK_ACTION_ARG_TYPES_AND_NAMES_UNUSED_) const\n\n#define ACTION_P6(name, p0, p1, p2, p3, p4, p5)\\\n  template <typename p0##_type, typename p1##_type, typename p2##_type, \\\n      typename p3##_type, typename p4##_type, typename p5##_type>\\\n  class name##ActionP6 {\\\n   public:\\\n    name##ActionP6(p0##_type gmock_p0, p1##_type gmock_p1, \\\n        p2##_type gmock_p2, p3##_type gmock_p3, p4##_type gmock_p4, \\\n        p5##_type gmock_p5) : p0(gmock_p0), p1(gmock_p1), p2(gmock_p2), \\\n        p3(gmock_p3), p4(gmock_p4), p5(gmock_p5) {}\\\n    template <typename F>\\\n    class gmock_Impl : public ::testing::ActionInterface<F> {\\\n     public:\\\n      typedef F function_type;\\\n      typedef typename ::testing::internal::Function<F>::Result return_type;\\\n      typedef typename ::testing::internal::Function<F>::ArgumentTuple\\\n          args_type;\\\n      gmock_Impl(p0##_type gmock_p0, p1##_type gmock_p1, p2##_type gmock_p2, \\\n          p3##_type gmock_p3, p4##_type gmock_p4, \\\n          p5##_type gmock_p5) : p0(gmock_p0), p1(gmock_p1), p2(gmock_p2), \\\n          p3(gmock_p3), p4(gmock_p4), p5(gmock_p5) {}\\\n      virtual return_type Perform(const args_type& args) {\\\n        return ::testing::internal::ActionHelper<return_type, gmock_Impl>::\\\n            Perform(this, args);\\\n      }\\\n      template <typename arg0_type, typename arg1_type, typename arg2_type, \\\n          typename arg3_type, typename arg4_type, typename arg5_type, \\\n          typename arg6_type, typename arg7_type, typename arg8_type, \\\n          typename arg9_type>\\\n      return_type gmock_PerformImpl(const args_type& args, arg0_type arg0, \\\n          arg1_type arg1, arg2_type arg2, arg3_type arg3, arg4_type arg4, \\\n          arg5_type arg5, arg6_type arg6, arg7_type arg7, arg8_type arg8, \\\n          arg9_type arg9) const;\\\n      p0##_type p0;\\\n      p1##_type p1;\\\n      p2##_type p2;\\\n      p3##_type p3;\\\n      p4##_type p4;\\\n      p5##_type p5;\\\n     private:\\\n      GTEST_DISALLOW_ASSIGN_(gmock_Impl);\\\n    };\\\n    template <typename F> operator ::testing::Action<F>() const {\\\n      return ::testing::Action<F>(new gmock_Impl<F>(p0, p1, p2, p3, p4, p5));\\\n    }\\\n    p0##_type p0;\\\n    p1##_type p1;\\\n    p2##_type p2;\\\n    p3##_type p3;\\\n    p4##_type p4;\\\n    p5##_type p5;\\\n   private:\\\n    GTEST_DISALLOW_ASSIGN_(name##ActionP6);\\\n  };\\\n  template <typename p0##_type, typename p1##_type, typename p2##_type, \\\n      typename p3##_type, typename p4##_type, typename p5##_type>\\\n  inline name##ActionP6<p0##_type, p1##_type, p2##_type, p3##_type, \\\n      p4##_type, p5##_type> name(p0##_type p0, p1##_type p1, p2##_type p2, \\\n      p3##_type p3, p4##_type p4, p5##_type p5) {\\\n    return name##ActionP6<p0##_type, p1##_type, p2##_type, p3##_type, \\\n        p4##_type, p5##_type>(p0, p1, p2, p3, p4, p5);\\\n  }\\\n  template <typename p0##_type, typename p1##_type, typename p2##_type, \\\n      typename p3##_type, typename p4##_type, typename p5##_type>\\\n  template <typename F>\\\n  template <typename arg0_type, typename arg1_type, typename arg2_type, \\\n      typename arg3_type, typename arg4_type, typename arg5_type, \\\n      typename arg6_type, typename arg7_type, typename arg8_type, \\\n      typename arg9_type>\\\n  typename ::testing::internal::Function<F>::Result\\\n      name##ActionP6<p0##_type, p1##_type, p2##_type, p3##_type, p4##_type, \\\n          p5##_type>::gmock_Impl<F>::gmock_PerformImpl(\\\n          GMOCK_ACTION_ARG_TYPES_AND_NAMES_UNUSED_) const\n\n#define ACTION_P7(name, p0, p1, p2, p3, p4, p5, p6)\\\n  template <typename p0##_type, typename p1##_type, typename p2##_type, \\\n      typename p3##_type, typename p4##_type, typename p5##_type, \\\n      typename p6##_type>\\\n  class name##ActionP7 {\\\n   public:\\\n    name##ActionP7(p0##_type gmock_p0, p1##_type gmock_p1, \\\n        p2##_type gmock_p2, p3##_type gmock_p3, p4##_type gmock_p4, \\\n        p5##_type gmock_p5, p6##_type gmock_p6) : p0(gmock_p0), p1(gmock_p1), \\\n        p2(gmock_p2), p3(gmock_p3), p4(gmock_p4), p5(gmock_p5), \\\n        p6(gmock_p6) {}\\\n    template <typename F>\\\n    class gmock_Impl : public ::testing::ActionInterface<F> {\\\n     public:\\\n      typedef F function_type;\\\n      typedef typename ::testing::internal::Function<F>::Result return_type;\\\n      typedef typename ::testing::internal::Function<F>::ArgumentTuple\\\n          args_type;\\\n      gmock_Impl(p0##_type gmock_p0, p1##_type gmock_p1, p2##_type gmock_p2, \\\n          p3##_type gmock_p3, p4##_type gmock_p4, p5##_type gmock_p5, \\\n          p6##_type gmock_p6) : p0(gmock_p0), p1(gmock_p1), p2(gmock_p2), \\\n          p3(gmock_p3), p4(gmock_p4), p5(gmock_p5), p6(gmock_p6) {}\\\n      virtual return_type Perform(const args_type& args) {\\\n        return ::testing::internal::ActionHelper<return_type, gmock_Impl>::\\\n            Perform(this, args);\\\n      }\\\n      template <typename arg0_type, typename arg1_type, typename arg2_type, \\\n          typename arg3_type, typename arg4_type, typename arg5_type, \\\n          typename arg6_type, typename arg7_type, typename arg8_type, \\\n          typename arg9_type>\\\n      return_type gmock_PerformImpl(const args_type& args, arg0_type arg0, \\\n          arg1_type arg1, arg2_type arg2, arg3_type arg3, arg4_type arg4, \\\n          arg5_type arg5, arg6_type arg6, arg7_type arg7, arg8_type arg8, \\\n          arg9_type arg9) const;\\\n      p0##_type p0;\\\n      p1##_type p1;\\\n      p2##_type p2;\\\n      p3##_type p3;\\\n      p4##_type p4;\\\n      p5##_type p5;\\\n      p6##_type p6;\\\n     private:\\\n      GTEST_DISALLOW_ASSIGN_(gmock_Impl);\\\n    };\\\n    template <typename F> operator ::testing::Action<F>() const {\\\n      return ::testing::Action<F>(new gmock_Impl<F>(p0, p1, p2, p3, p4, p5, \\\n          p6));\\\n    }\\\n    p0##_type p0;\\\n    p1##_type p1;\\\n    p2##_type p2;\\\n    p3##_type p3;\\\n    p4##_type p4;\\\n    p5##_type p5;\\\n    p6##_type p6;\\\n   private:\\\n    GTEST_DISALLOW_ASSIGN_(name##ActionP7);\\\n  };\\\n  template <typename p0##_type, typename p1##_type, typename p2##_type, \\\n      typename p3##_type, typename p4##_type, typename p5##_type, \\\n      typename p6##_type>\\\n  inline name##ActionP7<p0##_type, p1##_type, p2##_type, p3##_type, \\\n      p4##_type, p5##_type, p6##_type> name(p0##_type p0, p1##_type p1, \\\n      p2##_type p2, p3##_type p3, p4##_type p4, p5##_type p5, \\\n      p6##_type p6) {\\\n    return name##ActionP7<p0##_type, p1##_type, p2##_type, p3##_type, \\\n        p4##_type, p5##_type, p6##_type>(p0, p1, p2, p3, p4, p5, p6);\\\n  }\\\n  template <typename p0##_type, typename p1##_type, typename p2##_type, \\\n      typename p3##_type, typename p4##_type, typename p5##_type, \\\n      typename p6##_type>\\\n  template <typename F>\\\n  template <typename arg0_type, typename arg1_type, typename arg2_type, \\\n      typename arg3_type, typename arg4_type, typename arg5_type, \\\n      typename arg6_type, typename arg7_type, typename arg8_type, \\\n      typename arg9_type>\\\n  typename ::testing::internal::Function<F>::Result\\\n      name##ActionP7<p0##_type, p1##_type, p2##_type, p3##_type, p4##_type, \\\n          p5##_type, p6##_type>::gmock_Impl<F>::gmock_PerformImpl(\\\n          GMOCK_ACTION_ARG_TYPES_AND_NAMES_UNUSED_) const\n\n#define ACTION_P8(name, p0, p1, p2, p3, p4, p5, p6, p7)\\\n  template <typename p0##_type, typename p1##_type, typename p2##_type, \\\n      typename p3##_type, typename p4##_type, typename p5##_type, \\\n      typename p6##_type, typename p7##_type>\\\n  class name##ActionP8 {\\\n   public:\\\n    name##ActionP8(p0##_type gmock_p0, p1##_type gmock_p1, \\\n        p2##_type gmock_p2, p3##_type gmock_p3, p4##_type gmock_p4, \\\n        p5##_type gmock_p5, p6##_type gmock_p6, \\\n        p7##_type gmock_p7) : p0(gmock_p0), p1(gmock_p1), p2(gmock_p2), \\\n        p3(gmock_p3), p4(gmock_p4), p5(gmock_p5), p6(gmock_p6), \\\n        p7(gmock_p7) {}\\\n    template <typename F>\\\n    class gmock_Impl : public ::testing::ActionInterface<F> {\\\n     public:\\\n      typedef F function_type;\\\n      typedef typename ::testing::internal::Function<F>::Result return_type;\\\n      typedef typename ::testing::internal::Function<F>::ArgumentTuple\\\n          args_type;\\\n      gmock_Impl(p0##_type gmock_p0, p1##_type gmock_p1, p2##_type gmock_p2, \\\n          p3##_type gmock_p3, p4##_type gmock_p4, p5##_type gmock_p5, \\\n          p6##_type gmock_p6, p7##_type gmock_p7) : p0(gmock_p0), \\\n          p1(gmock_p1), p2(gmock_p2), p3(gmock_p3), p4(gmock_p4), \\\n          p5(gmock_p5), p6(gmock_p6), p7(gmock_p7) {}\\\n      virtual return_type Perform(const args_type& args) {\\\n        return ::testing::internal::ActionHelper<return_type, gmock_Impl>::\\\n            Perform(this, args);\\\n      }\\\n      template <typename arg0_type, typename arg1_type, typename arg2_type, \\\n          typename arg3_type, typename arg4_type, typename arg5_type, \\\n          typename arg6_type, typename arg7_type, typename arg8_type, \\\n          typename arg9_type>\\\n      return_type gmock_PerformImpl(const args_type& args, arg0_type arg0, \\\n          arg1_type arg1, arg2_type arg2, arg3_type arg3, arg4_type arg4, \\\n          arg5_type arg5, arg6_type arg6, arg7_type arg7, arg8_type arg8, \\\n          arg9_type arg9) const;\\\n      p0##_type p0;\\\n      p1##_type p1;\\\n      p2##_type p2;\\\n      p3##_type p3;\\\n      p4##_type p4;\\\n      p5##_type p5;\\\n      p6##_type p6;\\\n      p7##_type p7;\\\n     private:\\\n      GTEST_DISALLOW_ASSIGN_(gmock_Impl);\\\n    };\\\n    template <typename F> operator ::testing::Action<F>() const {\\\n      return ::testing::Action<F>(new gmock_Impl<F>(p0, p1, p2, p3, p4, p5, \\\n          p6, p7));\\\n    }\\\n    p0##_type p0;\\\n    p1##_type p1;\\\n    p2##_type p2;\\\n    p3##_type p3;\\\n    p4##_type p4;\\\n    p5##_type p5;\\\n    p6##_type p6;\\\n    p7##_type p7;\\\n   private:\\\n    GTEST_DISALLOW_ASSIGN_(name##ActionP8);\\\n  };\\\n  template <typename p0##_type, typename p1##_type, typename p2##_type, \\\n      typename p3##_type, typename p4##_type, typename p5##_type, \\\n      typename p6##_type, typename p7##_type>\\\n  inline name##ActionP8<p0##_type, p1##_type, p2##_type, p3##_type, \\\n      p4##_type, p5##_type, p6##_type, p7##_type> name(p0##_type p0, \\\n      p1##_type p1, p2##_type p2, p3##_type p3, p4##_type p4, p5##_type p5, \\\n      p6##_type p6, p7##_type p7) {\\\n    return name##ActionP8<p0##_type, p1##_type, p2##_type, p3##_type, \\\n        p4##_type, p5##_type, p6##_type, p7##_type>(p0, p1, p2, p3, p4, p5, \\\n        p6, p7);\\\n  }\\\n  template <typename p0##_type, typename p1##_type, typename p2##_type, \\\n      typename p3##_type, typename p4##_type, typename p5##_type, \\\n      typename p6##_type, typename p7##_type>\\\n  template <typename F>\\\n  template <typename arg0_type, typename arg1_type, typename arg2_type, \\\n      typename arg3_type, typename arg4_type, typename arg5_type, \\\n      typename arg6_type, typename arg7_type, typename arg8_type, \\\n      typename arg9_type>\\\n  typename ::testing::internal::Function<F>::Result\\\n      name##ActionP8<p0##_type, p1##_type, p2##_type, p3##_type, p4##_type, \\\n          p5##_type, p6##_type, \\\n          p7##_type>::gmock_Impl<F>::gmock_PerformImpl(\\\n          GMOCK_ACTION_ARG_TYPES_AND_NAMES_UNUSED_) const\n\n#define ACTION_P9(name, p0, p1, p2, p3, p4, p5, p6, p7, p8)\\\n  template <typename p0##_type, typename p1##_type, typename p2##_type, \\\n      typename p3##_type, typename p4##_type, typename p5##_type, \\\n      typename p6##_type, typename p7##_type, typename p8##_type>\\\n  class name##ActionP9 {\\\n   public:\\\n    name##ActionP9(p0##_type gmock_p0, p1##_type gmock_p1, \\\n        p2##_type gmock_p2, p3##_type gmock_p3, p4##_type gmock_p4, \\\n        p5##_type gmock_p5, p6##_type gmock_p6, p7##_type gmock_p7, \\\n        p8##_type gmock_p8) : p0(gmock_p0), p1(gmock_p1), p2(gmock_p2), \\\n        p3(gmock_p3), p4(gmock_p4), p5(gmock_p5), p6(gmock_p6), p7(gmock_p7), \\\n        p8(gmock_p8) {}\\\n    template <typename F>\\\n    class gmock_Impl : public ::testing::ActionInterface<F> {\\\n     public:\\\n      typedef F function_type;\\\n      typedef typename ::testing::internal::Function<F>::Result return_type;\\\n      typedef typename ::testing::internal::Function<F>::ArgumentTuple\\\n          args_type;\\\n      gmock_Impl(p0##_type gmock_p0, p1##_type gmock_p1, p2##_type gmock_p2, \\\n          p3##_type gmock_p3, p4##_type gmock_p4, p5##_type gmock_p5, \\\n          p6##_type gmock_p6, p7##_type gmock_p7, \\\n          p8##_type gmock_p8) : p0(gmock_p0), p1(gmock_p1), p2(gmock_p2), \\\n          p3(gmock_p3), p4(gmock_p4), p5(gmock_p5), p6(gmock_p6), \\\n          p7(gmock_p7), p8(gmock_p8) {}\\\n      virtual return_type Perform(const args_type& args) {\\\n        return ::testing::internal::ActionHelper<return_type, gmock_Impl>::\\\n            Perform(this, args);\\\n      }\\\n      template <typename arg0_type, typename arg1_type, typename arg2_type, \\\n          typename arg3_type, typename arg4_type, typename arg5_type, \\\n          typename arg6_type, typename arg7_type, typename arg8_type, \\\n          typename arg9_type>\\\n      return_type gmock_PerformImpl(const args_type& args, arg0_type arg0, \\\n          arg1_type arg1, arg2_type arg2, arg3_type arg3, arg4_type arg4, \\\n          arg5_type arg5, arg6_type arg6, arg7_type arg7, arg8_type arg8, \\\n          arg9_type arg9) const;\\\n      p0##_type p0;\\\n      p1##_type p1;\\\n      p2##_type p2;\\\n      p3##_type p3;\\\n      p4##_type p4;\\\n      p5##_type p5;\\\n      p6##_type p6;\\\n      p7##_type p7;\\\n      p8##_type p8;\\\n     private:\\\n      GTEST_DISALLOW_ASSIGN_(gmock_Impl);\\\n    };\\\n    template <typename F> operator ::testing::Action<F>() const {\\\n      return ::testing::Action<F>(new gmock_Impl<F>(p0, p1, p2, p3, p4, p5, \\\n          p6, p7, p8));\\\n    }\\\n    p0##_type p0;\\\n    p1##_type p1;\\\n    p2##_type p2;\\\n    p3##_type p3;\\\n    p4##_type p4;\\\n    p5##_type p5;\\\n    p6##_type p6;\\\n    p7##_type p7;\\\n    p8##_type p8;\\\n   private:\\\n    GTEST_DISALLOW_ASSIGN_(name##ActionP9);\\\n  };\\\n  template <typename p0##_type, typename p1##_type, typename p2##_type, \\\n      typename p3##_type, typename p4##_type, typename p5##_type, \\\n      typename p6##_type, typename p7##_type, typename p8##_type>\\\n  inline name##ActionP9<p0##_type, p1##_type, p2##_type, p3##_type, \\\n      p4##_type, p5##_type, p6##_type, p7##_type, \\\n      p8##_type> name(p0##_type p0, p1##_type p1, p2##_type p2, p3##_type p3, \\\n      p4##_type p4, p5##_type p5, p6##_type p6, p7##_type p7, \\\n      p8##_type p8) {\\\n    return name##ActionP9<p0##_type, p1##_type, p2##_type, p3##_type, \\\n        p4##_type, p5##_type, p6##_type, p7##_type, p8##_type>(p0, p1, p2, \\\n        p3, p4, p5, p6, p7, p8);\\\n  }\\\n  template <typename p0##_type, typename p1##_type, typename p2##_type, \\\n      typename p3##_type, typename p4##_type, typename p5##_type, \\\n      typename p6##_type, typename p7##_type, typename p8##_type>\\\n  template <typename F>\\\n  template <typename arg0_type, typename arg1_type, typename arg2_type, \\\n      typename arg3_type, typename arg4_type, typename arg5_type, \\\n      typename arg6_type, typename arg7_type, typename arg8_type, \\\n      typename arg9_type>\\\n  typename ::testing::internal::Function<F>::Result\\\n      name##ActionP9<p0##_type, p1##_type, p2##_type, p3##_type, p4##_type, \\\n          p5##_type, p6##_type, p7##_type, \\\n          p8##_type>::gmock_Impl<F>::gmock_PerformImpl(\\\n          GMOCK_ACTION_ARG_TYPES_AND_NAMES_UNUSED_) const\n\n#define ACTION_P10(name, p0, p1, p2, p3, p4, p5, p6, p7, p8, p9)\\\n  template <typename p0##_type, typename p1##_type, typename p2##_type, \\\n      typename p3##_type, typename p4##_type, typename p5##_type, \\\n      typename p6##_type, typename p7##_type, typename p8##_type, \\\n      typename p9##_type>\\\n  class name##ActionP10 {\\\n   public:\\\n    name##ActionP10(p0##_type gmock_p0, p1##_type gmock_p1, \\\n        p2##_type gmock_p2, p3##_type gmock_p3, p4##_type gmock_p4, \\\n        p5##_type gmock_p5, p6##_type gmock_p6, p7##_type gmock_p7, \\\n        p8##_type gmock_p8, p9##_type gmock_p9) : p0(gmock_p0), p1(gmock_p1), \\\n        p2(gmock_p2), p3(gmock_p3), p4(gmock_p4), p5(gmock_p5), p6(gmock_p6), \\\n        p7(gmock_p7), p8(gmock_p8), p9(gmock_p9) {}\\\n    template <typename F>\\\n    class gmock_Impl : public ::testing::ActionInterface<F> {\\\n     public:\\\n      typedef F function_type;\\\n      typedef typename ::testing::internal::Function<F>::Result return_type;\\\n      typedef typename ::testing::internal::Function<F>::ArgumentTuple\\\n          args_type;\\\n      gmock_Impl(p0##_type gmock_p0, p1##_type gmock_p1, p2##_type gmock_p2, \\\n          p3##_type gmock_p3, p4##_type gmock_p4, p5##_type gmock_p5, \\\n          p6##_type gmock_p6, p7##_type gmock_p7, p8##_type gmock_p8, \\\n          p9##_type gmock_p9) : p0(gmock_p0), p1(gmock_p1), p2(gmock_p2), \\\n          p3(gmock_p3), p4(gmock_p4), p5(gmock_p5), p6(gmock_p6), \\\n          p7(gmock_p7), p8(gmock_p8), p9(gmock_p9) {}\\\n      virtual return_type Perform(const args_type& args) {\\\n        return ::testing::internal::ActionHelper<return_type, gmock_Impl>::\\\n            Perform(this, args);\\\n      }\\\n      template <typename arg0_type, typename arg1_type, typename arg2_type, \\\n          typename arg3_type, typename arg4_type, typename arg5_type, \\\n          typename arg6_type, typename arg7_type, typename arg8_type, \\\n          typename arg9_type>\\\n      return_type gmock_PerformImpl(const args_type& args, arg0_type arg0, \\\n          arg1_type arg1, arg2_type arg2, arg3_type arg3, arg4_type arg4, \\\n          arg5_type arg5, arg6_type arg6, arg7_type arg7, arg8_type arg8, \\\n          arg9_type arg9) const;\\\n      p0##_type p0;\\\n      p1##_type p1;\\\n      p2##_type p2;\\\n      p3##_type p3;\\\n      p4##_type p4;\\\n      p5##_type p5;\\\n      p6##_type p6;\\\n      p7##_type p7;\\\n      p8##_type p8;\\\n      p9##_type p9;\\\n     private:\\\n      GTEST_DISALLOW_ASSIGN_(gmock_Impl);\\\n    };\\\n    template <typename F> operator ::testing::Action<F>() const {\\\n      return ::testing::Action<F>(new gmock_Impl<F>(p0, p1, p2, p3, p4, p5, \\\n          p6, p7, p8, p9));\\\n    }\\\n    p0##_type p0;\\\n    p1##_type p1;\\\n    p2##_type p2;\\\n    p3##_type p3;\\\n    p4##_type p4;\\\n    p5##_type p5;\\\n    p6##_type p6;\\\n    p7##_type p7;\\\n    p8##_type p8;\\\n    p9##_type p9;\\\n   private:\\\n    GTEST_DISALLOW_ASSIGN_(name##ActionP10);\\\n  };\\\n  template <typename p0##_type, typename p1##_type, typename p2##_type, \\\n      typename p3##_type, typename p4##_type, typename p5##_type, \\\n      typename p6##_type, typename p7##_type, typename p8##_type, \\\n      typename p9##_type>\\\n  inline name##ActionP10<p0##_type, p1##_type, p2##_type, p3##_type, \\\n      p4##_type, p5##_type, p6##_type, p7##_type, p8##_type, \\\n      p9##_type> name(p0##_type p0, p1##_type p1, p2##_type p2, p3##_type p3, \\\n      p4##_type p4, p5##_type p5, p6##_type p6, p7##_type p7, p8##_type p8, \\\n      p9##_type p9) {\\\n    return name##ActionP10<p0##_type, p1##_type, p2##_type, p3##_type, \\\n        p4##_type, p5##_type, p6##_type, p7##_type, p8##_type, p9##_type>(p0, \\\n        p1, p2, p3, p4, p5, p6, p7, p8, p9);\\\n  }\\\n  template <typename p0##_type, typename p1##_type, typename p2##_type, \\\n      typename p3##_type, typename p4##_type, typename p5##_type, \\\n      typename p6##_type, typename p7##_type, typename p8##_type, \\\n      typename p9##_type>\\\n  template <typename F>\\\n  template <typename arg0_type, typename arg1_type, typename arg2_type, \\\n      typename arg3_type, typename arg4_type, typename arg5_type, \\\n      typename arg6_type, typename arg7_type, typename arg8_type, \\\n      typename arg9_type>\\\n  typename ::testing::internal::Function<F>::Result\\\n      name##ActionP10<p0##_type, p1##_type, p2##_type, p3##_type, p4##_type, \\\n          p5##_type, p6##_type, p7##_type, p8##_type, \\\n          p9##_type>::gmock_Impl<F>::gmock_PerformImpl(\\\n          GMOCK_ACTION_ARG_TYPES_AND_NAMES_UNUSED_) const\n\nnamespace testing {\n\n\n// The ACTION*() macros trigger warning C4100 (unreferenced formal\n// parameter) in MSVC with -W4.  Unfortunately they cannot be fixed in\n// the macro definition, as the warnings are generated when the macro\n// is expanded and macro expansion cannot contain #pragma.  Therefore\n// we suppress them here.\n#ifdef _MSC_VER\n# pragma warning(push)\n# pragma warning(disable:4100)\n#endif\n\n// Various overloads for InvokeArgument<N>().\n//\n// The InvokeArgument<N>(a1, a2, ..., a_k) action invokes the N-th\n// (0-based) argument, which must be a k-ary callable, of the mock\n// function, with arguments a1, a2, ..., a_k.\n//\n// Notes:\n//\n//   1. The arguments are passed by value by default.  If you need to\n//   pass an argument by reference, wrap it inside ByRef().  For\n//   example,\n//\n//     InvokeArgument<1>(5, string(\"Hello\"), ByRef(foo))\n//\n//   passes 5 and string(\"Hello\") by value, and passes foo by\n//   reference.\n//\n//   2. If the callable takes an argument by reference but ByRef() is\n//   not used, it will receive the reference to a copy of the value,\n//   instead of the original value.  For example, when the 0-th\n//   argument of the mock function takes a const string&, the action\n//\n//     InvokeArgument<0>(string(\"Hello\"))\n//\n//   makes a copy of the temporary string(\"Hello\") object and passes a\n//   reference of the copy, instead of the original temporary object,\n//   to the callable.  This makes it easy for a user to define an\n//   InvokeArgument action from temporary values and have it performed\n//   later.\n\nnamespace internal {\nnamespace invoke_argument {\n\n// Appears in InvokeArgumentAdl's argument list to help avoid\n// accidental calls to user functions of the same name.\nstruct AdlTag {};\n\n// InvokeArgumentAdl - a helper for InvokeArgument.\n// The basic overloads are provided here for generic functors.\n// Overloads for other custom-callables are provided in the\n// internal/custom/callback-actions.h header.\n\ntemplate <typename R, typename F>\nR InvokeArgumentAdl(AdlTag, F f) {\n  return f();\n}\ntemplate <typename R, typename F, typename A1>\nR InvokeArgumentAdl(AdlTag, F f, A1 a1) {\n  return f(a1);\n}\ntemplate <typename R, typename F, typename A1, typename A2>\nR InvokeArgumentAdl(AdlTag, F f, A1 a1, A2 a2) {\n  return f(a1, a2);\n}\ntemplate <typename R, typename F, typename A1, typename A2, typename A3>\nR InvokeArgumentAdl(AdlTag, F f, A1 a1, A2 a2, A3 a3) {\n  return f(a1, a2, a3);\n}\ntemplate <typename R, typename F, typename A1, typename A2, typename A3,\n    typename A4>\nR InvokeArgumentAdl(AdlTag, F f, A1 a1, A2 a2, A3 a3, A4 a4) {\n  return f(a1, a2, a3, a4);\n}\ntemplate <typename R, typename F, typename A1, typename A2, typename A3,\n    typename A4, typename A5>\nR InvokeArgumentAdl(AdlTag, F f, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5) {\n  return f(a1, a2, a3, a4, a5);\n}\ntemplate <typename R, typename F, typename A1, typename A2, typename A3,\n    typename A4, typename A5, typename A6>\nR InvokeArgumentAdl(AdlTag, F f, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6) {\n  return f(a1, a2, a3, a4, a5, a6);\n}\ntemplate <typename R, typename F, typename A1, typename A2, typename A3,\n    typename A4, typename A5, typename A6, typename A7>\nR InvokeArgumentAdl(AdlTag, F f, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6,\n    A7 a7) {\n  return f(a1, a2, a3, a4, a5, a6, a7);\n}\ntemplate <typename R, typename F, typename A1, typename A2, typename A3,\n    typename A4, typename A5, typename A6, typename A7, typename A8>\nR InvokeArgumentAdl(AdlTag, F f, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6,\n    A7 a7, A8 a8) {\n  return f(a1, a2, a3, a4, a5, a6, a7, a8);\n}\ntemplate <typename R, typename F, typename A1, typename A2, typename A3,\n    typename A4, typename A5, typename A6, typename A7, typename A8,\n    typename A9>\nR InvokeArgumentAdl(AdlTag, F f, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6,\n    A7 a7, A8 a8, A9 a9) {\n  return f(a1, a2, a3, a4, a5, a6, a7, a8, a9);\n}\ntemplate <typename R, typename F, typename A1, typename A2, typename A3,\n    typename A4, typename A5, typename A6, typename A7, typename A8,\n    typename A9, typename A10>\nR InvokeArgumentAdl(AdlTag, F f, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6,\n    A7 a7, A8 a8, A9 a9, A10 a10) {\n  return f(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10);\n}\n}  // namespace invoke_argument\n}  // namespace internal\n\nACTION_TEMPLATE(InvokeArgument,\n                HAS_1_TEMPLATE_PARAMS(int, k),\n                AND_0_VALUE_PARAMS()) {\n  using internal::invoke_argument::InvokeArgumentAdl;\n  return InvokeArgumentAdl<return_type>(\n      internal::invoke_argument::AdlTag(),\n      ::testing::get<k>(args));\n}\n\nACTION_TEMPLATE(InvokeArgument,\n                HAS_1_TEMPLATE_PARAMS(int, k),\n                AND_1_VALUE_PARAMS(p0)) {\n  using internal::invoke_argument::InvokeArgumentAdl;\n  return InvokeArgumentAdl<return_type>(\n      internal::invoke_argument::AdlTag(),\n      ::testing::get<k>(args), p0);\n}\n\nACTION_TEMPLATE(InvokeArgument,\n                HAS_1_TEMPLATE_PARAMS(int, k),\n                AND_2_VALUE_PARAMS(p0, p1)) {\n  using internal::invoke_argument::InvokeArgumentAdl;\n  return InvokeArgumentAdl<return_type>(\n      internal::invoke_argument::AdlTag(),\n      ::testing::get<k>(args), p0, p1);\n}\n\nACTION_TEMPLATE(InvokeArgument,\n                HAS_1_TEMPLATE_PARAMS(int, k),\n                AND_3_VALUE_PARAMS(p0, p1, p2)) {\n  using internal::invoke_argument::InvokeArgumentAdl;\n  return InvokeArgumentAdl<return_type>(\n      internal::invoke_argument::AdlTag(),\n      ::testing::get<k>(args), p0, p1, p2);\n}\n\nACTION_TEMPLATE(InvokeArgument,\n                HAS_1_TEMPLATE_PARAMS(int, k),\n                AND_4_VALUE_PARAMS(p0, p1, p2, p3)) {\n  using internal::invoke_argument::InvokeArgumentAdl;\n  return InvokeArgumentAdl<return_type>(\n      internal::invoke_argument::AdlTag(),\n      ::testing::get<k>(args), p0, p1, p2, p3);\n}\n\nACTION_TEMPLATE(InvokeArgument,\n                HAS_1_TEMPLATE_PARAMS(int, k),\n                AND_5_VALUE_PARAMS(p0, p1, p2, p3, p4)) {\n  using internal::invoke_argument::InvokeArgumentAdl;\n  return InvokeArgumentAdl<return_type>(\n      internal::invoke_argument::AdlTag(),\n      ::testing::get<k>(args), p0, p1, p2, p3, p4);\n}\n\nACTION_TEMPLATE(InvokeArgument,\n                HAS_1_TEMPLATE_PARAMS(int, k),\n                AND_6_VALUE_PARAMS(p0, p1, p2, p3, p4, p5)) {\n  using internal::invoke_argument::InvokeArgumentAdl;\n  return InvokeArgumentAdl<return_type>(\n      internal::invoke_argument::AdlTag(),\n      ::testing::get<k>(args), p0, p1, p2, p3, p4, p5);\n}\n\nACTION_TEMPLATE(InvokeArgument,\n                HAS_1_TEMPLATE_PARAMS(int, k),\n                AND_7_VALUE_PARAMS(p0, p1, p2, p3, p4, p5, p6)) {\n  using internal::invoke_argument::InvokeArgumentAdl;\n  return InvokeArgumentAdl<return_type>(\n      internal::invoke_argument::AdlTag(),\n      ::testing::get<k>(args), p0, p1, p2, p3, p4, p5, p6);\n}\n\nACTION_TEMPLATE(InvokeArgument,\n                HAS_1_TEMPLATE_PARAMS(int, k),\n                AND_8_VALUE_PARAMS(p0, p1, p2, p3, p4, p5, p6, p7)) {\n  using internal::invoke_argument::InvokeArgumentAdl;\n  return InvokeArgumentAdl<return_type>(\n      internal::invoke_argument::AdlTag(),\n      ::testing::get<k>(args), p0, p1, p2, p3, p4, p5, p6, p7);\n}\n\nACTION_TEMPLATE(InvokeArgument,\n                HAS_1_TEMPLATE_PARAMS(int, k),\n                AND_9_VALUE_PARAMS(p0, p1, p2, p3, p4, p5, p6, p7, p8)) {\n  using internal::invoke_argument::InvokeArgumentAdl;\n  return InvokeArgumentAdl<return_type>(\n      internal::invoke_argument::AdlTag(),\n      ::testing::get<k>(args), p0, p1, p2, p3, p4, p5, p6, p7, p8);\n}\n\nACTION_TEMPLATE(InvokeArgument,\n                HAS_1_TEMPLATE_PARAMS(int, k),\n                AND_10_VALUE_PARAMS(p0, p1, p2, p3, p4, p5, p6, p7, p8, p9)) {\n  using internal::invoke_argument::InvokeArgumentAdl;\n  return InvokeArgumentAdl<return_type>(\n      internal::invoke_argument::AdlTag(),\n      ::testing::get<k>(args), p0, p1, p2, p3, p4, p5, p6, p7, p8, p9);\n}\n\n// Various overloads for ReturnNew<T>().\n//\n// The ReturnNew<T>(a1, a2, ..., a_k) action returns a pointer to a new\n// instance of type T, constructed on the heap with constructor arguments\n// a1, a2, ..., and a_k. The caller assumes ownership of the returned value.\nACTION_TEMPLATE(ReturnNew,\n                HAS_1_TEMPLATE_PARAMS(typename, T),\n                AND_0_VALUE_PARAMS()) {\n  return new T();\n}\n\nACTION_TEMPLATE(ReturnNew,\n                HAS_1_TEMPLATE_PARAMS(typename, T),\n                AND_1_VALUE_PARAMS(p0)) {\n  return new T(p0);\n}\n\nACTION_TEMPLATE(ReturnNew,\n                HAS_1_TEMPLATE_PARAMS(typename, T),\n                AND_2_VALUE_PARAMS(p0, p1)) {\n  return new T(p0, p1);\n}\n\nACTION_TEMPLATE(ReturnNew,\n                HAS_1_TEMPLATE_PARAMS(typename, T),\n                AND_3_VALUE_PARAMS(p0, p1, p2)) {\n  return new T(p0, p1, p2);\n}\n\nACTION_TEMPLATE(ReturnNew,\n                HAS_1_TEMPLATE_PARAMS(typename, T),\n                AND_4_VALUE_PARAMS(p0, p1, p2, p3)) {\n  return new T(p0, p1, p2, p3);\n}\n\nACTION_TEMPLATE(ReturnNew,\n                HAS_1_TEMPLATE_PARAMS(typename, T),\n                AND_5_VALUE_PARAMS(p0, p1, p2, p3, p4)) {\n  return new T(p0, p1, p2, p3, p4);\n}\n\nACTION_TEMPLATE(ReturnNew,\n                HAS_1_TEMPLATE_PARAMS(typename, T),\n                AND_6_VALUE_PARAMS(p0, p1, p2, p3, p4, p5)) {\n  return new T(p0, p1, p2, p3, p4, p5);\n}\n\nACTION_TEMPLATE(ReturnNew,\n                HAS_1_TEMPLATE_PARAMS(typename, T),\n                AND_7_VALUE_PARAMS(p0, p1, p2, p3, p4, p5, p6)) {\n  return new T(p0, p1, p2, p3, p4, p5, p6);\n}\n\nACTION_TEMPLATE(ReturnNew,\n                HAS_1_TEMPLATE_PARAMS(typename, T),\n                AND_8_VALUE_PARAMS(p0, p1, p2, p3, p4, p5, p6, p7)) {\n  return new T(p0, p1, p2, p3, p4, p5, p6, p7);\n}\n\nACTION_TEMPLATE(ReturnNew,\n                HAS_1_TEMPLATE_PARAMS(typename, T),\n                AND_9_VALUE_PARAMS(p0, p1, p2, p3, p4, p5, p6, p7, p8)) {\n  return new T(p0, p1, p2, p3, p4, p5, p6, p7, p8);\n}\n\nACTION_TEMPLATE(ReturnNew,\n                HAS_1_TEMPLATE_PARAMS(typename, T),\n                AND_10_VALUE_PARAMS(p0, p1, p2, p3, p4, p5, p6, p7, p8, p9)) {\n  return new T(p0, p1, p2, p3, p4, p5, p6, p7, p8, p9);\n}\n\n#ifdef _MSC_VER\n# pragma warning(pop)\n#endif\n\n}  // namespace testing\n\n// Include any custom actions added by the local installation.\n// We must include this header at the end to make sure it can use the\n// declarations from this file.\n#include \"gmock/internal/custom/gmock-generated-actions.h\"\n\n#endif  // GMOCK_INCLUDE_GMOCK_GMOCK_GENERATED_ACTIONS_H_\n"}, "32": {"id": 32, "path": "/home/vsts/work/1/llvm-project/llvm/utils/unittest/googlemock/include/gmock/gmock-generated-function-mockers.h", "content": "// This file was GENERATED by command:\n//     pump.py gmock-generated-function-mockers.h.pump\n// DO NOT EDIT BY HAND!!!\n\n// Copyright 2007, Google Inc.\n// All rights reserved.\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are\n// met:\n//\n//     * Redistributions of source code must retain the above copyright\n// notice, this list of conditions and the following disclaimer.\n//     * Redistributions in binary form must reproduce the above\n// copyright notice, this list of conditions and the following disclaimer\n// in the documentation and/or other materials provided with the\n// distribution.\n//     * Neither the name of Google Inc. nor the names of its\n// contributors may be used to endorse or promote products derived from\n// this software without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n//\n// Author: wan@google.com (Zhanyong Wan)\n\n// Google Mock - a framework for writing C++ mock classes.\n//\n// This file implements function mockers of various arities.\n\n// IWYU pragma: private, include \"gmock/gmock.h\"\n\n#ifndef GMOCK_INCLUDE_GMOCK_GMOCK_GENERATED_FUNCTION_MOCKERS_H_\n#define GMOCK_INCLUDE_GMOCK_GMOCK_GENERATED_FUNCTION_MOCKERS_H_\n\n#include \"gmock/gmock-spec-builders.h\"\n#include \"gmock/internal/gmock-internal-utils.h\"\n\n#if GTEST_HAS_STD_FUNCTION_\n# include <functional>\n#endif\n\nnamespace testing {\nnamespace internal {\n\ntemplate <typename F>\nclass FunctionMockerBase;\n\n// Note: class FunctionMocker really belongs to the ::testing\n// namespace.  However if we define it in ::testing, MSVC will\n// complain when classes in ::testing::internal declare it as a\n// friend class template.  To workaround this compiler bug, we define\n// FunctionMocker in ::testing::internal and import it into ::testing.\ntemplate <typename F>\nclass FunctionMocker;\n\ntemplate <typename R>\nclass FunctionMocker<R()> : public\n    internal::FunctionMockerBase<R()> {\n public:\n  typedef R F();\n  typedef typename internal::Function<F>::ArgumentTuple ArgumentTuple;\n\n  MockSpec<F>& With() {\n    return this->current_spec();\n  }\n\n  R Invoke() {\n    // Even though gcc and MSVC don't enforce it, 'this->' is required\n    // by the C++ standard [14.6.4] here, as the base class type is\n    // dependent on the template argument (and thus shouldn't be\n    // looked into when resolving InvokeWith).\n    return this->InvokeWith(ArgumentTuple());\n  }\n};\n\ntemplate <typename R, typename A1>\nclass FunctionMocker<R(A1)> : public\n    internal::FunctionMockerBase<R(A1)> {\n public:\n  typedef R F(A1);\n  typedef typename internal::Function<F>::ArgumentTuple ArgumentTuple;\n\n  MockSpec<F>& With(const Matcher<A1>& m1) {\n    this->current_spec().SetMatchers(::testing::make_tuple(m1));\n    return this->current_spec();\n  }\n\n  R Invoke(A1 a1) {\n    // Even though gcc and MSVC don't enforce it, 'this->' is required\n    // by the C++ standard [14.6.4] here, as the base class type is\n    // dependent on the template argument (and thus shouldn't be\n    // looked into when resolving InvokeWith).\n    return this->InvokeWith(ArgumentTuple(a1));\n  }\n};\n\ntemplate <typename R, typename A1, typename A2>\nclass FunctionMocker<R(A1, A2)> : public\n    internal::FunctionMockerBase<R(A1, A2)> {\n public:\n  typedef R F(A1, A2);\n  typedef typename internal::Function<F>::ArgumentTuple ArgumentTuple;\n\n  MockSpec<F>& With(const Matcher<A1>& m1, const Matcher<A2>& m2) {\n    this->current_spec().SetMatchers(::testing::make_tuple(m1, m2));\n    return this->current_spec();\n  }\n\n  R Invoke(A1 a1, A2 a2) {\n    // Even though gcc and MSVC don't enforce it, 'this->' is required\n    // by the C++ standard [14.6.4] here, as the base class type is\n    // dependent on the template argument (and thus shouldn't be\n    // looked into when resolving InvokeWith).\n    return this->InvokeWith(ArgumentTuple(a1, a2));\n  }\n};\n\ntemplate <typename R, typename A1, typename A2, typename A3>\nclass FunctionMocker<R(A1, A2, A3)> : public\n    internal::FunctionMockerBase<R(A1, A2, A3)> {\n public:\n  typedef R F(A1, A2, A3);\n  typedef typename internal::Function<F>::ArgumentTuple ArgumentTuple;\n\n  MockSpec<F>& With(const Matcher<A1>& m1, const Matcher<A2>& m2,\n      const Matcher<A3>& m3) {\n    this->current_spec().SetMatchers(::testing::make_tuple(m1, m2, m3));\n    return this->current_spec();\n  }\n\n  R Invoke(A1 a1, A2 a2, A3 a3) {\n    // Even though gcc and MSVC don't enforce it, 'this->' is required\n    // by the C++ standard [14.6.4] here, as the base class type is\n    // dependent on the template argument (and thus shouldn't be\n    // looked into when resolving InvokeWith).\n    return this->InvokeWith(ArgumentTuple(a1, a2, a3));\n  }\n};\n\ntemplate <typename R, typename A1, typename A2, typename A3, typename A4>\nclass FunctionMocker<R(A1, A2, A3, A4)> : public\n    internal::FunctionMockerBase<R(A1, A2, A3, A4)> {\n public:\n  typedef R F(A1, A2, A3, A4);\n  typedef typename internal::Function<F>::ArgumentTuple ArgumentTuple;\n\n  MockSpec<F>& With(const Matcher<A1>& m1, const Matcher<A2>& m2,\n      const Matcher<A3>& m3, const Matcher<A4>& m4) {\n    this->current_spec().SetMatchers(::testing::make_tuple(m1, m2, m3, m4));\n    return this->current_spec();\n  }\n\n  R Invoke(A1 a1, A2 a2, A3 a3, A4 a4) {\n    // Even though gcc and MSVC don't enforce it, 'this->' is required\n    // by the C++ standard [14.6.4] here, as the base class type is\n    // dependent on the template argument (and thus shouldn't be\n    // looked into when resolving InvokeWith).\n    return this->InvokeWith(ArgumentTuple(a1, a2, a3, a4));\n  }\n};\n\ntemplate <typename R, typename A1, typename A2, typename A3, typename A4,\n    typename A5>\nclass FunctionMocker<R(A1, A2, A3, A4, A5)> : public\n    internal::FunctionMockerBase<R(A1, A2, A3, A4, A5)> {\n public:\n  typedef R F(A1, A2, A3, A4, A5);\n  typedef typename internal::Function<F>::ArgumentTuple ArgumentTuple;\n\n  MockSpec<F>& With(const Matcher<A1>& m1, const Matcher<A2>& m2,\n      const Matcher<A3>& m3, const Matcher<A4>& m4, const Matcher<A5>& m5) {\n    this->current_spec().SetMatchers(::testing::make_tuple(m1, m2, m3, m4, m5));\n    return this->current_spec();\n  }\n\n  R Invoke(A1 a1, A2 a2, A3 a3, A4 a4, A5 a5) {\n    // Even though gcc and MSVC don't enforce it, 'this->' is required\n    // by the C++ standard [14.6.4] here, as the base class type is\n    // dependent on the template argument (and thus shouldn't be\n    // looked into when resolving InvokeWith).\n    return this->InvokeWith(ArgumentTuple(a1, a2, a3, a4, a5));\n  }\n};\n\ntemplate <typename R, typename A1, typename A2, typename A3, typename A4,\n    typename A5, typename A6>\nclass FunctionMocker<R(A1, A2, A3, A4, A5, A6)> : public\n    internal::FunctionMockerBase<R(A1, A2, A3, A4, A5, A6)> {\n public:\n  typedef R F(A1, A2, A3, A4, A5, A6);\n  typedef typename internal::Function<F>::ArgumentTuple ArgumentTuple;\n\n  MockSpec<F>& With(const Matcher<A1>& m1, const Matcher<A2>& m2,\n      const Matcher<A3>& m3, const Matcher<A4>& m4, const Matcher<A5>& m5,\n      const Matcher<A6>& m6) {\n    this->current_spec().SetMatchers(::testing::make_tuple(m1, m2, m3, m4, m5,\n        m6));\n    return this->current_spec();\n  }\n\n  R Invoke(A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6) {\n    // Even though gcc and MSVC don't enforce it, 'this->' is required\n    // by the C++ standard [14.6.4] here, as the base class type is\n    // dependent on the template argument (and thus shouldn't be\n    // looked into when resolving InvokeWith).\n    return this->InvokeWith(ArgumentTuple(a1, a2, a3, a4, a5, a6));\n  }\n};\n\ntemplate <typename R, typename A1, typename A2, typename A3, typename A4,\n    typename A5, typename A6, typename A7>\nclass FunctionMocker<R(A1, A2, A3, A4, A5, A6, A7)> : public\n    internal::FunctionMockerBase<R(A1, A2, A3, A4, A5, A6, A7)> {\n public:\n  typedef R F(A1, A2, A3, A4, A5, A6, A7);\n  typedef typename internal::Function<F>::ArgumentTuple ArgumentTuple;\n\n  MockSpec<F>& With(const Matcher<A1>& m1, const Matcher<A2>& m2,\n      const Matcher<A3>& m3, const Matcher<A4>& m4, const Matcher<A5>& m5,\n      const Matcher<A6>& m6, const Matcher<A7>& m7) {\n    this->current_spec().SetMatchers(::testing::make_tuple(m1, m2, m3, m4, m5,\n        m6, m7));\n    return this->current_spec();\n  }\n\n  R Invoke(A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7) {\n    // Even though gcc and MSVC don't enforce it, 'this->' is required\n    // by the C++ standard [14.6.4] here, as the base class type is\n    // dependent on the template argument (and thus shouldn't be\n    // looked into when resolving InvokeWith).\n    return this->InvokeWith(ArgumentTuple(a1, a2, a3, a4, a5, a6, a7));\n  }\n};\n\ntemplate <typename R, typename A1, typename A2, typename A3, typename A4,\n    typename A5, typename A6, typename A7, typename A8>\nclass FunctionMocker<R(A1, A2, A3, A4, A5, A6, A7, A8)> : public\n    internal::FunctionMockerBase<R(A1, A2, A3, A4, A5, A6, A7, A8)> {\n public:\n  typedef R F(A1, A2, A3, A4, A5, A6, A7, A8);\n  typedef typename internal::Function<F>::ArgumentTuple ArgumentTuple;\n\n  MockSpec<F>& With(const Matcher<A1>& m1, const Matcher<A2>& m2,\n      const Matcher<A3>& m3, const Matcher<A4>& m4, const Matcher<A5>& m5,\n      const Matcher<A6>& m6, const Matcher<A7>& m7, const Matcher<A8>& m8) {\n    this->current_spec().SetMatchers(::testing::make_tuple(m1, m2, m3, m4, m5,\n        m6, m7, m8));\n    return this->current_spec();\n  }\n\n  R Invoke(A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8) {\n    // Even though gcc and MSVC don't enforce it, 'this->' is required\n    // by the C++ standard [14.6.4] here, as the base class type is\n    // dependent on the template argument (and thus shouldn't be\n    // looked into when resolving InvokeWith).\n    return this->InvokeWith(ArgumentTuple(a1, a2, a3, a4, a5, a6, a7, a8));\n  }\n};\n\ntemplate <typename R, typename A1, typename A2, typename A3, typename A4,\n    typename A5, typename A6, typename A7, typename A8, typename A9>\nclass FunctionMocker<R(A1, A2, A3, A4, A5, A6, A7, A8, A9)> : public\n    internal::FunctionMockerBase<R(A1, A2, A3, A4, A5, A6, A7, A8, A9)> {\n public:\n  typedef R F(A1, A2, A3, A4, A5, A6, A7, A8, A9);\n  typedef typename internal::Function<F>::ArgumentTuple ArgumentTuple;\n\n  MockSpec<F>& With(const Matcher<A1>& m1, const Matcher<A2>& m2,\n      const Matcher<A3>& m3, const Matcher<A4>& m4, const Matcher<A5>& m5,\n      const Matcher<A6>& m6, const Matcher<A7>& m7, const Matcher<A8>& m8,\n      const Matcher<A9>& m9) {\n    this->current_spec().SetMatchers(::testing::make_tuple(m1, m2, m3, m4, m5,\n        m6, m7, m8, m9));\n    return this->current_spec();\n  }\n\n  R Invoke(A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9) {\n    // Even though gcc and MSVC don't enforce it, 'this->' is required\n    // by the C++ standard [14.6.4] here, as the base class type is\n    // dependent on the template argument (and thus shouldn't be\n    // looked into when resolving InvokeWith).\n    return this->InvokeWith(ArgumentTuple(a1, a2, a3, a4, a5, a6, a7, a8, a9));\n  }\n};\n\ntemplate <typename R, typename A1, typename A2, typename A3, typename A4,\n    typename A5, typename A6, typename A7, typename A8, typename A9,\n    typename A10>\nclass FunctionMocker<R(A1, A2, A3, A4, A5, A6, A7, A8, A9, A10)> : public\n    internal::FunctionMockerBase<R(A1, A2, A3, A4, A5, A6, A7, A8, A9, A10)> {\n public:\n  typedef R F(A1, A2, A3, A4, A5, A6, A7, A8, A9, A10);\n  typedef typename internal::Function<F>::ArgumentTuple ArgumentTuple;\n\n  MockSpec<F>& With(const Matcher<A1>& m1, const Matcher<A2>& m2,\n      const Matcher<A3>& m3, const Matcher<A4>& m4, const Matcher<A5>& m5,\n      const Matcher<A6>& m6, const Matcher<A7>& m7, const Matcher<A8>& m8,\n      const Matcher<A9>& m9, const Matcher<A10>& m10) {\n    this->current_spec().SetMatchers(::testing::make_tuple(m1, m2, m3, m4, m5,\n        m6, m7, m8, m9, m10));\n    return this->current_spec();\n  }\n\n  R Invoke(A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9,\n      A10 a10) {\n    // Even though gcc and MSVC don't enforce it, 'this->' is required\n    // by the C++ standard [14.6.4] here, as the base class type is\n    // dependent on the template argument (and thus shouldn't be\n    // looked into when resolving InvokeWith).\n    return this->InvokeWith(ArgumentTuple(a1, a2, a3, a4, a5, a6, a7, a8, a9,\n        a10));\n  }\n};\n\n}  // namespace internal\n\n// The style guide prohibits \"using\" statements in a namespace scope\n// inside a header file.  However, the FunctionMocker class template\n// is meant to be defined in the ::testing namespace.  The following\n// line is just a trick for working around a bug in MSVC 8.0, which\n// cannot handle it if we define FunctionMocker in ::testing.\nusing internal::FunctionMocker;\n\n// GMOCK_RESULT_(tn, F) expands to the result type of function type F.\n// We define this as a variadic macro in case F contains unprotected\n// commas (the same reason that we use variadic macros in other places\n// in this file).\n// INTERNAL IMPLEMENTATION - DON'T USE IN USER CODE!!!\n#define GMOCK_RESULT_(tn, ...) \\\n    tn ::testing::internal::Function<__VA_ARGS__>::Result\n\n// The type of argument N of the given function type.\n// INTERNAL IMPLEMENTATION - DON'T USE IN USER CODE!!!\n#define GMOCK_ARG_(tn, N, ...) \\\n    tn ::testing::internal::Function<__VA_ARGS__>::Argument##N\n\n// The matcher type for argument N of the given function type.\n// INTERNAL IMPLEMENTATION - DON'T USE IN USER CODE!!!\n#define GMOCK_MATCHER_(tn, N, ...) \\\n    const ::testing::Matcher<GMOCK_ARG_(tn, N, __VA_ARGS__)>&\n\n// The variable for mocking the given method.\n// INTERNAL IMPLEMENTATION - DON'T USE IN USER CODE!!!\n#define GMOCK_MOCKER_(arity, constness, Method) \\\n    GTEST_CONCAT_TOKEN_(gmock##constness##arity##_##Method##_, __LINE__)\n\n// INTERNAL IMPLEMENTATION - DON'T USE IN USER CODE!!!\n#define GMOCK_METHOD0_(tn, constness, ct, Method, ...) \\\n  GMOCK_RESULT_(tn, __VA_ARGS__) ct Method( \\\n      ) constness { \\\n    GTEST_COMPILE_ASSERT_((::testing::tuple_size<                          \\\n        tn ::testing::internal::Function<__VA_ARGS__>::ArgumentTuple>::value \\\n            == 0), \\\n        this_method_does_not_take_0_arguments); \\\n    GMOCK_MOCKER_(0, constness, Method).SetOwnerAndName(this, #Method); \\\n    return GMOCK_MOCKER_(0, constness, Method).Invoke(); \\\n  } \\\n  ::testing::MockSpec<__VA_ARGS__>& \\\n      gmock_##Method() constness { \\\n    GMOCK_MOCKER_(0, constness, Method).RegisterOwner(this); \\\n    return GMOCK_MOCKER_(0, constness, Method).With(); \\\n  } \\\n  mutable ::testing::FunctionMocker<__VA_ARGS__> GMOCK_MOCKER_(0, constness, \\\n      Method)\n\n// INTERNAL IMPLEMENTATION - DON'T USE IN USER CODE!!!\n#define GMOCK_METHOD1_(tn, constness, ct, Method, ...) \\\n  GMOCK_RESULT_(tn, __VA_ARGS__) ct Method( \\\n      GMOCK_ARG_(tn, 1, __VA_ARGS__) gmock_a1) constness { \\\n    GTEST_COMPILE_ASSERT_((::testing::tuple_size<                          \\\n        tn ::testing::internal::Function<__VA_ARGS__>::ArgumentTuple>::value \\\n            == 1), \\\n        this_method_does_not_take_1_argument); \\\n    GMOCK_MOCKER_(1, constness, Method).SetOwnerAndName(this, #Method); \\\n    return GMOCK_MOCKER_(1, constness, Method).Invoke(gmock_a1); \\\n  } \\\n  ::testing::MockSpec<__VA_ARGS__>& \\\n      gmock_##Method(GMOCK_MATCHER_(tn, 1, __VA_ARGS__) gmock_a1) constness { \\\n    GMOCK_MOCKER_(1, constness, Method).RegisterOwner(this); \\\n    return GMOCK_MOCKER_(1, constness, Method).With(gmock_a1); \\\n  } \\\n  mutable ::testing::FunctionMocker<__VA_ARGS__> GMOCK_MOCKER_(1, constness, \\\n      Method)\n\n// INTERNAL IMPLEMENTATION - DON'T USE IN USER CODE!!!\n#define GMOCK_METHOD2_(tn, constness, ct, Method, ...) \\\n  GMOCK_RESULT_(tn, __VA_ARGS__) ct Method( \\\n      GMOCK_ARG_(tn, 1, __VA_ARGS__) gmock_a1, \\\n      GMOCK_ARG_(tn, 2, __VA_ARGS__) gmock_a2) constness { \\\n    GTEST_COMPILE_ASSERT_((::testing::tuple_size<                          \\\n        tn ::testing::internal::Function<__VA_ARGS__>::ArgumentTuple>::value \\\n            == 2), \\\n        this_method_does_not_take_2_arguments); \\\n    GMOCK_MOCKER_(2, constness, Method).SetOwnerAndName(this, #Method); \\\n    return GMOCK_MOCKER_(2, constness, Method).Invoke(gmock_a1, gmock_a2); \\\n  } \\\n  ::testing::MockSpec<__VA_ARGS__>& \\\n      gmock_##Method(GMOCK_MATCHER_(tn, 1, __VA_ARGS__) gmock_a1, \\\n                     GMOCK_MATCHER_(tn, 2, __VA_ARGS__) gmock_a2) constness { \\\n    GMOCK_MOCKER_(2, constness, Method).RegisterOwner(this); \\\n    return GMOCK_MOCKER_(2, constness, Method).With(gmock_a1, gmock_a2); \\\n  } \\\n  mutable ::testing::FunctionMocker<__VA_ARGS__> GMOCK_MOCKER_(2, constness, \\\n      Method)\n\n// INTERNAL IMPLEMENTATION - DON'T USE IN USER CODE!!!\n#define GMOCK_METHOD3_(tn, constness, ct, Method, ...) \\\n  GMOCK_RESULT_(tn, __VA_ARGS__) ct Method( \\\n      GMOCK_ARG_(tn, 1, __VA_ARGS__) gmock_a1, \\\n      GMOCK_ARG_(tn, 2, __VA_ARGS__) gmock_a2, \\\n      GMOCK_ARG_(tn, 3, __VA_ARGS__) gmock_a3) constness { \\\n    GTEST_COMPILE_ASSERT_((::testing::tuple_size<                          \\\n        tn ::testing::internal::Function<__VA_ARGS__>::ArgumentTuple>::value \\\n            == 3), \\\n        this_method_does_not_take_3_arguments); \\\n    GMOCK_MOCKER_(3, constness, Method).SetOwnerAndName(this, #Method); \\\n    return GMOCK_MOCKER_(3, constness, Method).Invoke(gmock_a1, gmock_a2, \\\n        gmock_a3); \\\n  } \\\n  ::testing::MockSpec<__VA_ARGS__>& \\\n      gmock_##Method(GMOCK_MATCHER_(tn, 1, __VA_ARGS__) gmock_a1, \\\n                     GMOCK_MATCHER_(tn, 2, __VA_ARGS__) gmock_a2, \\\n                     GMOCK_MATCHER_(tn, 3, __VA_ARGS__) gmock_a3) constness { \\\n    GMOCK_MOCKER_(3, constness, Method).RegisterOwner(this); \\\n    return GMOCK_MOCKER_(3, constness, Method).With(gmock_a1, gmock_a2, \\\n        gmock_a3); \\\n  } \\\n  mutable ::testing::FunctionMocker<__VA_ARGS__> GMOCK_MOCKER_(3, constness, \\\n      Method)\n\n// INTERNAL IMPLEMENTATION - DON'T USE IN USER CODE!!!\n#define GMOCK_METHOD4_(tn, constness, ct, Method, ...) \\\n  GMOCK_RESULT_(tn, __VA_ARGS__) ct Method( \\\n      GMOCK_ARG_(tn, 1, __VA_ARGS__) gmock_a1, \\\n      GMOCK_ARG_(tn, 2, __VA_ARGS__) gmock_a2, \\\n      GMOCK_ARG_(tn, 3, __VA_ARGS__) gmock_a3, \\\n      GMOCK_ARG_(tn, 4, __VA_ARGS__) gmock_a4) constness { \\\n    GTEST_COMPILE_ASSERT_((::testing::tuple_size<                          \\\n        tn ::testing::internal::Function<__VA_ARGS__>::ArgumentTuple>::value \\\n            == 4), \\\n        this_method_does_not_take_4_arguments); \\\n    GMOCK_MOCKER_(4, constness, Method).SetOwnerAndName(this, #Method); \\\n    return GMOCK_MOCKER_(4, constness, Method).Invoke(gmock_a1, gmock_a2, \\\n        gmock_a3, gmock_a4); \\\n  } \\\n  ::testing::MockSpec<__VA_ARGS__>& \\\n      gmock_##Method(GMOCK_MATCHER_(tn, 1, __VA_ARGS__) gmock_a1, \\\n                     GMOCK_MATCHER_(tn, 2, __VA_ARGS__) gmock_a2, \\\n                     GMOCK_MATCHER_(tn, 3, __VA_ARGS__) gmock_a3, \\\n                     GMOCK_MATCHER_(tn, 4, __VA_ARGS__) gmock_a4) constness { \\\n    GMOCK_MOCKER_(4, constness, Method).RegisterOwner(this); \\\n    return GMOCK_MOCKER_(4, constness, Method).With(gmock_a1, gmock_a2, \\\n        gmock_a3, gmock_a4); \\\n  } \\\n  mutable ::testing::FunctionMocker<__VA_ARGS__> GMOCK_MOCKER_(4, constness, \\\n      Method)\n\n// INTERNAL IMPLEMENTATION - DON'T USE IN USER CODE!!!\n#define GMOCK_METHOD5_(tn, constness, ct, Method, ...) \\\n  GMOCK_RESULT_(tn, __VA_ARGS__) ct Method( \\\n      GMOCK_ARG_(tn, 1, __VA_ARGS__) gmock_a1, \\\n      GMOCK_ARG_(tn, 2, __VA_ARGS__) gmock_a2, \\\n      GMOCK_ARG_(tn, 3, __VA_ARGS__) gmock_a3, \\\n      GMOCK_ARG_(tn, 4, __VA_ARGS__) gmock_a4, \\\n      GMOCK_ARG_(tn, 5, __VA_ARGS__) gmock_a5) constness { \\\n    GTEST_COMPILE_ASSERT_((::testing::tuple_size<                          \\\n        tn ::testing::internal::Function<__VA_ARGS__>::ArgumentTuple>::value \\\n            == 5), \\\n        this_method_does_not_take_5_arguments); \\\n    GMOCK_MOCKER_(5, constness, Method).SetOwnerAndName(this, #Method); \\\n    return GMOCK_MOCKER_(5, constness, Method).Invoke(gmock_a1, gmock_a2, \\\n        gmock_a3, gmock_a4, gmock_a5); \\\n  } \\\n  ::testing::MockSpec<__VA_ARGS__>& \\\n      gmock_##Method(GMOCK_MATCHER_(tn, 1, __VA_ARGS__) gmock_a1, \\\n                     GMOCK_MATCHER_(tn, 2, __VA_ARGS__) gmock_a2, \\\n                     GMOCK_MATCHER_(tn, 3, __VA_ARGS__) gmock_a3, \\\n                     GMOCK_MATCHER_(tn, 4, __VA_ARGS__) gmock_a4, \\\n                     GMOCK_MATCHER_(tn, 5, __VA_ARGS__) gmock_a5) constness { \\\n    GMOCK_MOCKER_(5, constness, Method).RegisterOwner(this); \\\n    return GMOCK_MOCKER_(5, constness, Method).With(gmock_a1, gmock_a2, \\\n        gmock_a3, gmock_a4, gmock_a5); \\\n  } \\\n  mutable ::testing::FunctionMocker<__VA_ARGS__> GMOCK_MOCKER_(5, constness, \\\n      Method)\n\n// INTERNAL IMPLEMENTATION - DON'T USE IN USER CODE!!!\n#define GMOCK_METHOD6_(tn, constness, ct, Method, ...) \\\n  GMOCK_RESULT_(tn, __VA_ARGS__) ct Method( \\\n      GMOCK_ARG_(tn, 1, __VA_ARGS__) gmock_a1, \\\n      GMOCK_ARG_(tn, 2, __VA_ARGS__) gmock_a2, \\\n      GMOCK_ARG_(tn, 3, __VA_ARGS__) gmock_a3, \\\n      GMOCK_ARG_(tn, 4, __VA_ARGS__) gmock_a4, \\\n      GMOCK_ARG_(tn, 5, __VA_ARGS__) gmock_a5, \\\n      GMOCK_ARG_(tn, 6, __VA_ARGS__) gmock_a6) constness { \\\n    GTEST_COMPILE_ASSERT_((::testing::tuple_size<                          \\\n        tn ::testing::internal::Function<__VA_ARGS__>::ArgumentTuple>::value \\\n            == 6), \\\n        this_method_does_not_take_6_arguments); \\\n    GMOCK_MOCKER_(6, constness, Method).SetOwnerAndName(this, #Method); \\\n    return GMOCK_MOCKER_(6, constness, Method).Invoke(gmock_a1, gmock_a2, \\\n        gmock_a3, gmock_a4, gmock_a5, gmock_a6); \\\n  } \\\n  ::testing::MockSpec<__VA_ARGS__>& \\\n      gmock_##Method(GMOCK_MATCHER_(tn, 1, __VA_ARGS__) gmock_a1, \\\n                     GMOCK_MATCHER_(tn, 2, __VA_ARGS__) gmock_a2, \\\n                     GMOCK_MATCHER_(tn, 3, __VA_ARGS__) gmock_a3, \\\n                     GMOCK_MATCHER_(tn, 4, __VA_ARGS__) gmock_a4, \\\n                     GMOCK_MATCHER_(tn, 5, __VA_ARGS__) gmock_a5, \\\n                     GMOCK_MATCHER_(tn, 6, __VA_ARGS__) gmock_a6) constness { \\\n    GMOCK_MOCKER_(6, constness, Method).RegisterOwner(this); \\\n    return GMOCK_MOCKER_(6, constness, Method).With(gmock_a1, gmock_a2, \\\n        gmock_a3, gmock_a4, gmock_a5, gmock_a6); \\\n  } \\\n  mutable ::testing::FunctionMocker<__VA_ARGS__> GMOCK_MOCKER_(6, constness, \\\n      Method)\n\n// INTERNAL IMPLEMENTATION - DON'T USE IN USER CODE!!!\n#define GMOCK_METHOD7_(tn, constness, ct, Method, ...) \\\n  GMOCK_RESULT_(tn, __VA_ARGS__) ct Method( \\\n      GMOCK_ARG_(tn, 1, __VA_ARGS__) gmock_a1, \\\n      GMOCK_ARG_(tn, 2, __VA_ARGS__) gmock_a2, \\\n      GMOCK_ARG_(tn, 3, __VA_ARGS__) gmock_a3, \\\n      GMOCK_ARG_(tn, 4, __VA_ARGS__) gmock_a4, \\\n      GMOCK_ARG_(tn, 5, __VA_ARGS__) gmock_a5, \\\n      GMOCK_ARG_(tn, 6, __VA_ARGS__) gmock_a6, \\\n      GMOCK_ARG_(tn, 7, __VA_ARGS__) gmock_a7) constness { \\\n    GTEST_COMPILE_ASSERT_((::testing::tuple_size<                          \\\n        tn ::testing::internal::Function<__VA_ARGS__>::ArgumentTuple>::value \\\n            == 7), \\\n        this_method_does_not_take_7_arguments); \\\n    GMOCK_MOCKER_(7, constness, Method).SetOwnerAndName(this, #Method); \\\n    return GMOCK_MOCKER_(7, constness, Method).Invoke(gmock_a1, gmock_a2, \\\n        gmock_a3, gmock_a4, gmock_a5, gmock_a6, gmock_a7); \\\n  } \\\n  ::testing::MockSpec<__VA_ARGS__>& \\\n      gmock_##Method(GMOCK_MATCHER_(tn, 1, __VA_ARGS__) gmock_a1, \\\n                     GMOCK_MATCHER_(tn, 2, __VA_ARGS__) gmock_a2, \\\n                     GMOCK_MATCHER_(tn, 3, __VA_ARGS__) gmock_a3, \\\n                     GMOCK_MATCHER_(tn, 4, __VA_ARGS__) gmock_a4, \\\n                     GMOCK_MATCHER_(tn, 5, __VA_ARGS__) gmock_a5, \\\n                     GMOCK_MATCHER_(tn, 6, __VA_ARGS__) gmock_a6, \\\n                     GMOCK_MATCHER_(tn, 7, __VA_ARGS__) gmock_a7) constness { \\\n    GMOCK_MOCKER_(7, constness, Method).RegisterOwner(this); \\\n    return GMOCK_MOCKER_(7, constness, Method).With(gmock_a1, gmock_a2, \\\n        gmock_a3, gmock_a4, gmock_a5, gmock_a6, gmock_a7); \\\n  } \\\n  mutable ::testing::FunctionMocker<__VA_ARGS__> GMOCK_MOCKER_(7, constness, \\\n      Method)\n\n// INTERNAL IMPLEMENTATION - DON'T USE IN USER CODE!!!\n#define GMOCK_METHOD8_(tn, constness, ct, Method, ...) \\\n  GMOCK_RESULT_(tn, __VA_ARGS__) ct Method( \\\n      GMOCK_ARG_(tn, 1, __VA_ARGS__) gmock_a1, \\\n      GMOCK_ARG_(tn, 2, __VA_ARGS__) gmock_a2, \\\n      GMOCK_ARG_(tn, 3, __VA_ARGS__) gmock_a3, \\\n      GMOCK_ARG_(tn, 4, __VA_ARGS__) gmock_a4, \\\n      GMOCK_ARG_(tn, 5, __VA_ARGS__) gmock_a5, \\\n      GMOCK_ARG_(tn, 6, __VA_ARGS__) gmock_a6, \\\n      GMOCK_ARG_(tn, 7, __VA_ARGS__) gmock_a7, \\\n      GMOCK_ARG_(tn, 8, __VA_ARGS__) gmock_a8) constness { \\\n    GTEST_COMPILE_ASSERT_((::testing::tuple_size<                          \\\n        tn ::testing::internal::Function<__VA_ARGS__>::ArgumentTuple>::value \\\n            == 8), \\\n        this_method_does_not_take_8_arguments); \\\n    GMOCK_MOCKER_(8, constness, Method).SetOwnerAndName(this, #Method); \\\n    return GMOCK_MOCKER_(8, constness, Method).Invoke(gmock_a1, gmock_a2, \\\n        gmock_a3, gmock_a4, gmock_a5, gmock_a6, gmock_a7, gmock_a8); \\\n  } \\\n  ::testing::MockSpec<__VA_ARGS__>& \\\n      gmock_##Method(GMOCK_MATCHER_(tn, 1, __VA_ARGS__) gmock_a1, \\\n                     GMOCK_MATCHER_(tn, 2, __VA_ARGS__) gmock_a2, \\\n                     GMOCK_MATCHER_(tn, 3, __VA_ARGS__) gmock_a3, \\\n                     GMOCK_MATCHER_(tn, 4, __VA_ARGS__) gmock_a4, \\\n                     GMOCK_MATCHER_(tn, 5, __VA_ARGS__) gmock_a5, \\\n                     GMOCK_MATCHER_(tn, 6, __VA_ARGS__) gmock_a6, \\\n                     GMOCK_MATCHER_(tn, 7, __VA_ARGS__) gmock_a7, \\\n                     GMOCK_MATCHER_(tn, 8, __VA_ARGS__) gmock_a8) constness { \\\n    GMOCK_MOCKER_(8, constness, Method).RegisterOwner(this); \\\n    return GMOCK_MOCKER_(8, constness, Method).With(gmock_a1, gmock_a2, \\\n        gmock_a3, gmock_a4, gmock_a5, gmock_a6, gmock_a7, gmock_a8); \\\n  } \\\n  mutable ::testing::FunctionMocker<__VA_ARGS__> GMOCK_MOCKER_(8, constness, \\\n      Method)\n\n// INTERNAL IMPLEMENTATION - DON'T USE IN USER CODE!!!\n#define GMOCK_METHOD9_(tn, constness, ct, Method, ...) \\\n  GMOCK_RESULT_(tn, __VA_ARGS__) ct Method( \\\n      GMOCK_ARG_(tn, 1, __VA_ARGS__) gmock_a1, \\\n      GMOCK_ARG_(tn, 2, __VA_ARGS__) gmock_a2, \\\n      GMOCK_ARG_(tn, 3, __VA_ARGS__) gmock_a3, \\\n      GMOCK_ARG_(tn, 4, __VA_ARGS__) gmock_a4, \\\n      GMOCK_ARG_(tn, 5, __VA_ARGS__) gmock_a5, \\\n      GMOCK_ARG_(tn, 6, __VA_ARGS__) gmock_a6, \\\n      GMOCK_ARG_(tn, 7, __VA_ARGS__) gmock_a7, \\\n      GMOCK_ARG_(tn, 8, __VA_ARGS__) gmock_a8, \\\n      GMOCK_ARG_(tn, 9, __VA_ARGS__) gmock_a9) constness { \\\n    GTEST_COMPILE_ASSERT_((::testing::tuple_size<                          \\\n        tn ::testing::internal::Function<__VA_ARGS__>::ArgumentTuple>::value \\\n            == 9), \\\n        this_method_does_not_take_9_arguments); \\\n    GMOCK_MOCKER_(9, constness, Method).SetOwnerAndName(this, #Method); \\\n    return GMOCK_MOCKER_(9, constness, Method).Invoke(gmock_a1, gmock_a2, \\\n        gmock_a3, gmock_a4, gmock_a5, gmock_a6, gmock_a7, gmock_a8, \\\n        gmock_a9); \\\n  } \\\n  ::testing::MockSpec<__VA_ARGS__>& \\\n      gmock_##Method(GMOCK_MATCHER_(tn, 1, __VA_ARGS__) gmock_a1, \\\n                     GMOCK_MATCHER_(tn, 2, __VA_ARGS__) gmock_a2, \\\n                     GMOCK_MATCHER_(tn, 3, __VA_ARGS__) gmock_a3, \\\n                     GMOCK_MATCHER_(tn, 4, __VA_ARGS__) gmock_a4, \\\n                     GMOCK_MATCHER_(tn, 5, __VA_ARGS__) gmock_a5, \\\n                     GMOCK_MATCHER_(tn, 6, __VA_ARGS__) gmock_a6, \\\n                     GMOCK_MATCHER_(tn, 7, __VA_ARGS__) gmock_a7, \\\n                     GMOCK_MATCHER_(tn, 8, __VA_ARGS__) gmock_a8, \\\n                     GMOCK_MATCHER_(tn, 9, __VA_ARGS__) gmock_a9) constness { \\\n    GMOCK_MOCKER_(9, constness, Method).RegisterOwner(this); \\\n    return GMOCK_MOCKER_(9, constness, Method).With(gmock_a1, gmock_a2, \\\n        gmock_a3, gmock_a4, gmock_a5, gmock_a6, gmock_a7, gmock_a8, \\\n        gmock_a9); \\\n  } \\\n  mutable ::testing::FunctionMocker<__VA_ARGS__> GMOCK_MOCKER_(9, constness, \\\n      Method)\n\n// INTERNAL IMPLEMENTATION - DON'T USE IN USER CODE!!!\n#define GMOCK_METHOD10_(tn, constness, ct, Method, ...) \\\n  GMOCK_RESULT_(tn, __VA_ARGS__) ct Method( \\\n      GMOCK_ARG_(tn, 1, __VA_ARGS__) gmock_a1, \\\n      GMOCK_ARG_(tn, 2, __VA_ARGS__) gmock_a2, \\\n      GMOCK_ARG_(tn, 3, __VA_ARGS__) gmock_a3, \\\n      GMOCK_ARG_(tn, 4, __VA_ARGS__) gmock_a4, \\\n      GMOCK_ARG_(tn, 5, __VA_ARGS__) gmock_a5, \\\n      GMOCK_ARG_(tn, 6, __VA_ARGS__) gmock_a6, \\\n      GMOCK_ARG_(tn, 7, __VA_ARGS__) gmock_a7, \\\n      GMOCK_ARG_(tn, 8, __VA_ARGS__) gmock_a8, \\\n      GMOCK_ARG_(tn, 9, __VA_ARGS__) gmock_a9, \\\n      GMOCK_ARG_(tn, 10, __VA_ARGS__) gmock_a10) constness { \\\n    GTEST_COMPILE_ASSERT_((::testing::tuple_size<                          \\\n        tn ::testing::internal::Function<__VA_ARGS__>::ArgumentTuple>::value \\\n            == 10), \\\n        this_method_does_not_take_10_arguments); \\\n    GMOCK_MOCKER_(10, constness, Method).SetOwnerAndName(this, #Method); \\\n    return GMOCK_MOCKER_(10, constness, Method).Invoke(gmock_a1, gmock_a2, \\\n        gmock_a3, gmock_a4, gmock_a5, gmock_a6, gmock_a7, gmock_a8, gmock_a9, \\\n        gmock_a10); \\\n  } \\\n  ::testing::MockSpec<__VA_ARGS__>& \\\n      gmock_##Method(GMOCK_MATCHER_(tn, 1, __VA_ARGS__) gmock_a1, \\\n                     GMOCK_MATCHER_(tn, 2, __VA_ARGS__) gmock_a2, \\\n                     GMOCK_MATCHER_(tn, 3, __VA_ARGS__) gmock_a3, \\\n                     GMOCK_MATCHER_(tn, 4, __VA_ARGS__) gmock_a4, \\\n                     GMOCK_MATCHER_(tn, 5, __VA_ARGS__) gmock_a5, \\\n                     GMOCK_MATCHER_(tn, 6, __VA_ARGS__) gmock_a6, \\\n                     GMOCK_MATCHER_(tn, 7, __VA_ARGS__) gmock_a7, \\\n                     GMOCK_MATCHER_(tn, 8, __VA_ARGS__) gmock_a8, \\\n                     GMOCK_MATCHER_(tn, 9, __VA_ARGS__) gmock_a9, \\\n                     GMOCK_MATCHER_(tn, 10, \\\n                         __VA_ARGS__) gmock_a10) constness { \\\n    GMOCK_MOCKER_(10, constness, Method).RegisterOwner(this); \\\n    return GMOCK_MOCKER_(10, constness, Method).With(gmock_a1, gmock_a2, \\\n        gmock_a3, gmock_a4, gmock_a5, gmock_a6, gmock_a7, gmock_a8, gmock_a9, \\\n        gmock_a10); \\\n  } \\\n  mutable ::testing::FunctionMocker<__VA_ARGS__> GMOCK_MOCKER_(10, constness, \\\n      Method)\n\n#define MOCK_METHOD0(m, ...) GMOCK_METHOD0_(, , , m, __VA_ARGS__)\n#define MOCK_METHOD1(m, ...) GMOCK_METHOD1_(, , , m, __VA_ARGS__)\n#define MOCK_METHOD2(m, ...) GMOCK_METHOD2_(, , , m, __VA_ARGS__)\n#define MOCK_METHOD3(m, ...) GMOCK_METHOD3_(, , , m, __VA_ARGS__)\n#define MOCK_METHOD4(m, ...) GMOCK_METHOD4_(, , , m, __VA_ARGS__)\n#define MOCK_METHOD5(m, ...) GMOCK_METHOD5_(, , , m, __VA_ARGS__)\n#define MOCK_METHOD6(m, ...) GMOCK_METHOD6_(, , , m, __VA_ARGS__)\n#define MOCK_METHOD7(m, ...) GMOCK_METHOD7_(, , , m, __VA_ARGS__)\n#define MOCK_METHOD8(m, ...) GMOCK_METHOD8_(, , , m, __VA_ARGS__)\n#define MOCK_METHOD9(m, ...) GMOCK_METHOD9_(, , , m, __VA_ARGS__)\n#define MOCK_METHOD10(m, ...) GMOCK_METHOD10_(, , , m, __VA_ARGS__)\n\n#define MOCK_CONST_METHOD0(m, ...) GMOCK_METHOD0_(, const, , m, __VA_ARGS__)\n#define MOCK_CONST_METHOD1(m, ...) GMOCK_METHOD1_(, const, , m, __VA_ARGS__)\n#define MOCK_CONST_METHOD2(m, ...) GMOCK_METHOD2_(, const, , m, __VA_ARGS__)\n#define MOCK_CONST_METHOD3(m, ...) GMOCK_METHOD3_(, const, , m, __VA_ARGS__)\n#define MOCK_CONST_METHOD4(m, ...) GMOCK_METHOD4_(, const, , m, __VA_ARGS__)\n#define MOCK_CONST_METHOD5(m, ...) GMOCK_METHOD5_(, const, , m, __VA_ARGS__)\n#define MOCK_CONST_METHOD6(m, ...) GMOCK_METHOD6_(, const, , m, __VA_ARGS__)\n#define MOCK_CONST_METHOD7(m, ...) GMOCK_METHOD7_(, const, , m, __VA_ARGS__)\n#define MOCK_CONST_METHOD8(m, ...) GMOCK_METHOD8_(, const, , m, __VA_ARGS__)\n#define MOCK_CONST_METHOD9(m, ...) GMOCK_METHOD9_(, const, , m, __VA_ARGS__)\n#define MOCK_CONST_METHOD10(m, ...) GMOCK_METHOD10_(, const, , m, __VA_ARGS__)\n\n#define MOCK_METHOD0_T(m, ...) GMOCK_METHOD0_(typename, , , m, __VA_ARGS__)\n#define MOCK_METHOD1_T(m, ...) GMOCK_METHOD1_(typename, , , m, __VA_ARGS__)\n#define MOCK_METHOD2_T(m, ...) GMOCK_METHOD2_(typename, , , m, __VA_ARGS__)\n#define MOCK_METHOD3_T(m, ...) GMOCK_METHOD3_(typename, , , m, __VA_ARGS__)\n#define MOCK_METHOD4_T(m, ...) GMOCK_METHOD4_(typename, , , m, __VA_ARGS__)\n#define MOCK_METHOD5_T(m, ...) GMOCK_METHOD5_(typename, , , m, __VA_ARGS__)\n#define MOCK_METHOD6_T(m, ...) GMOCK_METHOD6_(typename, , , m, __VA_ARGS__)\n#define MOCK_METHOD7_T(m, ...) GMOCK_METHOD7_(typename, , , m, __VA_ARGS__)\n#define MOCK_METHOD8_T(m, ...) GMOCK_METHOD8_(typename, , , m, __VA_ARGS__)\n#define MOCK_METHOD9_T(m, ...) GMOCK_METHOD9_(typename, , , m, __VA_ARGS__)\n#define MOCK_METHOD10_T(m, ...) GMOCK_METHOD10_(typename, , , m, __VA_ARGS__)\n\n#define MOCK_CONST_METHOD0_T(m, ...) \\\n    GMOCK_METHOD0_(typename, const, , m, __VA_ARGS__)\n#define MOCK_CONST_METHOD1_T(m, ...) \\\n    GMOCK_METHOD1_(typename, const, , m, __VA_ARGS__)\n#define MOCK_CONST_METHOD2_T(m, ...) \\\n    GMOCK_METHOD2_(typename, const, , m, __VA_ARGS__)\n#define MOCK_CONST_METHOD3_T(m, ...) \\\n    GMOCK_METHOD3_(typename, const, , m, __VA_ARGS__)\n#define MOCK_CONST_METHOD4_T(m, ...) \\\n    GMOCK_METHOD4_(typename, const, , m, __VA_ARGS__)\n#define MOCK_CONST_METHOD5_T(m, ...) \\\n    GMOCK_METHOD5_(typename, const, , m, __VA_ARGS__)\n#define MOCK_CONST_METHOD6_T(m, ...) \\\n    GMOCK_METHOD6_(typename, const, , m, __VA_ARGS__)\n#define MOCK_CONST_METHOD7_T(m, ...) \\\n    GMOCK_METHOD7_(typename, const, , m, __VA_ARGS__)\n#define MOCK_CONST_METHOD8_T(m, ...) \\\n    GMOCK_METHOD8_(typename, const, , m, __VA_ARGS__)\n#define MOCK_CONST_METHOD9_T(m, ...) \\\n    GMOCK_METHOD9_(typename, const, , m, __VA_ARGS__)\n#define MOCK_CONST_METHOD10_T(m, ...) \\\n    GMOCK_METHOD10_(typename, const, , m, __VA_ARGS__)\n\n#define MOCK_METHOD0_WITH_CALLTYPE(ct, m, ...) \\\n    GMOCK_METHOD0_(, , ct, m, __VA_ARGS__)\n#define MOCK_METHOD1_WITH_CALLTYPE(ct, m, ...) \\\n    GMOCK_METHOD1_(, , ct, m, __VA_ARGS__)\n#define MOCK_METHOD2_WITH_CALLTYPE(ct, m, ...) \\\n    GMOCK_METHOD2_(, , ct, m, __VA_ARGS__)\n#define MOCK_METHOD3_WITH_CALLTYPE(ct, m, ...) \\\n    GMOCK_METHOD3_(, , ct, m, __VA_ARGS__)\n#define MOCK_METHOD4_WITH_CALLTYPE(ct, m, ...) \\\n    GMOCK_METHOD4_(, , ct, m, __VA_ARGS__)\n#define MOCK_METHOD5_WITH_CALLTYPE(ct, m, ...) \\\n    GMOCK_METHOD5_(, , ct, m, __VA_ARGS__)\n#define MOCK_METHOD6_WITH_CALLTYPE(ct, m, ...) \\\n    GMOCK_METHOD6_(, , ct, m, __VA_ARGS__)\n#define MOCK_METHOD7_WITH_CALLTYPE(ct, m, ...) \\\n    GMOCK_METHOD7_(, , ct, m, __VA_ARGS__)\n#define MOCK_METHOD8_WITH_CALLTYPE(ct, m, ...) \\\n    GMOCK_METHOD8_(, , ct, m, __VA_ARGS__)\n#define MOCK_METHOD9_WITH_CALLTYPE(ct, m, ...) \\\n    GMOCK_METHOD9_(, , ct, m, __VA_ARGS__)\n#define MOCK_METHOD10_WITH_CALLTYPE(ct, m, ...) \\\n    GMOCK_METHOD10_(, , ct, m, __VA_ARGS__)\n\n#define MOCK_CONST_METHOD0_WITH_CALLTYPE(ct, m, ...) \\\n    GMOCK_METHOD0_(, const, ct, m, __VA_ARGS__)\n#define MOCK_CONST_METHOD1_WITH_CALLTYPE(ct, m, ...) \\\n    GMOCK_METHOD1_(, const, ct, m, __VA_ARGS__)\n#define MOCK_CONST_METHOD2_WITH_CALLTYPE(ct, m, ...) \\\n    GMOCK_METHOD2_(, const, ct, m, __VA_ARGS__)\n#define MOCK_CONST_METHOD3_WITH_CALLTYPE(ct, m, ...) \\\n    GMOCK_METHOD3_(, const, ct, m, __VA_ARGS__)\n#define MOCK_CONST_METHOD4_WITH_CALLTYPE(ct, m, ...) \\\n    GMOCK_METHOD4_(, const, ct, m, __VA_ARGS__)\n#define MOCK_CONST_METHOD5_WITH_CALLTYPE(ct, m, ...) \\\n    GMOCK_METHOD5_(, const, ct, m, __VA_ARGS__)\n#define MOCK_CONST_METHOD6_WITH_CALLTYPE(ct, m, ...) \\\n    GMOCK_METHOD6_(, const, ct, m, __VA_ARGS__)\n#define MOCK_CONST_METHOD7_WITH_CALLTYPE(ct, m, ...) \\\n    GMOCK_METHOD7_(, const, ct, m, __VA_ARGS__)\n#define MOCK_CONST_METHOD8_WITH_CALLTYPE(ct, m, ...) \\\n    GMOCK_METHOD8_(, const, ct, m, __VA_ARGS__)\n#define MOCK_CONST_METHOD9_WITH_CALLTYPE(ct, m, ...) \\\n    GMOCK_METHOD9_(, const, ct, m, __VA_ARGS__)\n#define MOCK_CONST_METHOD10_WITH_CALLTYPE(ct, m, ...) \\\n    GMOCK_METHOD10_(, const, ct, m, __VA_ARGS__)\n\n#define MOCK_METHOD0_T_WITH_CALLTYPE(ct, m, ...) \\\n    GMOCK_METHOD0_(typename, , ct, m, __VA_ARGS__)\n#define MOCK_METHOD1_T_WITH_CALLTYPE(ct, m, ...) \\\n    GMOCK_METHOD1_(typename, , ct, m, __VA_ARGS__)\n#define MOCK_METHOD2_T_WITH_CALLTYPE(ct, m, ...) \\\n    GMOCK_METHOD2_(typename, , ct, m, __VA_ARGS__)\n#define MOCK_METHOD3_T_WITH_CALLTYPE(ct, m, ...) \\\n    GMOCK_METHOD3_(typename, , ct, m, __VA_ARGS__)\n#define MOCK_METHOD4_T_WITH_CALLTYPE(ct, m, ...) \\\n    GMOCK_METHOD4_(typename, , ct, m, __VA_ARGS__)\n#define MOCK_METHOD5_T_WITH_CALLTYPE(ct, m, ...) \\\n    GMOCK_METHOD5_(typename, , ct, m, __VA_ARGS__)\n#define MOCK_METHOD6_T_WITH_CALLTYPE(ct, m, ...) \\\n    GMOCK_METHOD6_(typename, , ct, m, __VA_ARGS__)\n#define MOCK_METHOD7_T_WITH_CALLTYPE(ct, m, ...) \\\n    GMOCK_METHOD7_(typename, , ct, m, __VA_ARGS__)\n#define MOCK_METHOD8_T_WITH_CALLTYPE(ct, m, ...) \\\n    GMOCK_METHOD8_(typename, , ct, m, __VA_ARGS__)\n#define MOCK_METHOD9_T_WITH_CALLTYPE(ct, m, ...) \\\n    GMOCK_METHOD9_(typename, , ct, m, __VA_ARGS__)\n#define MOCK_METHOD10_T_WITH_CALLTYPE(ct, m, ...) \\\n    GMOCK_METHOD10_(typename, , ct, m, __VA_ARGS__)\n\n#define MOCK_CONST_METHOD0_T_WITH_CALLTYPE(ct, m, ...) \\\n    GMOCK_METHOD0_(typename, const, ct, m, __VA_ARGS__)\n#define MOCK_CONST_METHOD1_T_WITH_CALLTYPE(ct, m, ...) \\\n    GMOCK_METHOD1_(typename, const, ct, m, __VA_ARGS__)\n#define MOCK_CONST_METHOD2_T_WITH_CALLTYPE(ct, m, ...) \\\n    GMOCK_METHOD2_(typename, const, ct, m, __VA_ARGS__)\n#define MOCK_CONST_METHOD3_T_WITH_CALLTYPE(ct, m, ...) \\\n    GMOCK_METHOD3_(typename, const, ct, m, __VA_ARGS__)\n#define MOCK_CONST_METHOD4_T_WITH_CALLTYPE(ct, m, ...) \\\n    GMOCK_METHOD4_(typename, const, ct, m, __VA_ARGS__)\n#define MOCK_CONST_METHOD5_T_WITH_CALLTYPE(ct, m, ...) \\\n    GMOCK_METHOD5_(typename, const, ct, m, __VA_ARGS__)\n#define MOCK_CONST_METHOD6_T_WITH_CALLTYPE(ct, m, ...) \\\n    GMOCK_METHOD6_(typename, const, ct, m, __VA_ARGS__)\n#define MOCK_CONST_METHOD7_T_WITH_CALLTYPE(ct, m, ...) \\\n    GMOCK_METHOD7_(typename, const, ct, m, __VA_ARGS__)\n#define MOCK_CONST_METHOD8_T_WITH_CALLTYPE(ct, m, ...) \\\n    GMOCK_METHOD8_(typename, const, ct, m, __VA_ARGS__)\n#define MOCK_CONST_METHOD9_T_WITH_CALLTYPE(ct, m, ...) \\\n    GMOCK_METHOD9_(typename, const, ct, m, __VA_ARGS__)\n#define MOCK_CONST_METHOD10_T_WITH_CALLTYPE(ct, m, ...) \\\n    GMOCK_METHOD10_(typename, const, ct, m, __VA_ARGS__)\n\n// A MockFunction<F> class has one mock method whose type is F.  It is\n// useful when you just want your test code to emit some messages and\n// have Google Mock verify the right messages are sent (and perhaps at\n// the right times).  For example, if you are exercising code:\n//\n//   Foo(1);\n//   Foo(2);\n//   Foo(3);\n//\n// and want to verify that Foo(1) and Foo(3) both invoke\n// mock.Bar(\"a\"), but Foo(2) doesn't invoke anything, you can write:\n//\n// TEST(FooTest, InvokesBarCorrectly) {\n//   MyMock mock;\n//   MockFunction<void(string check_point_name)> check;\n//   {\n//     InSequence s;\n//\n//     EXPECT_CALL(mock, Bar(\"a\"));\n//     EXPECT_CALL(check, Call(\"1\"));\n//     EXPECT_CALL(check, Call(\"2\"));\n//     EXPECT_CALL(mock, Bar(\"a\"));\n//   }\n//   Foo(1);\n//   check.Call(\"1\");\n//   Foo(2);\n//   check.Call(\"2\");\n//   Foo(3);\n// }\n//\n// The expectation spec says that the first Bar(\"a\") must happen\n// before check point \"1\", the second Bar(\"a\") must happen after check\n// point \"2\", and nothing should happen between the two check\n// points. The explicit check points make it easy to tell which\n// Bar(\"a\") is called by which call to Foo().\n//\n// MockFunction<F> can also be used to exercise code that accepts\n// std::function<F> callbacks. To do so, use AsStdFunction() method\n// to create std::function proxy forwarding to original object's Call.\n// Example:\n//\n// TEST(FooTest, RunsCallbackWithBarArgument) {\n//   MockFunction<int(string)> callback;\n//   EXPECT_CALL(callback, Call(\"bar\")).WillOnce(Return(1));\n//   Foo(callback.AsStdFunction());\n// }\ntemplate <typename F>\nclass MockFunction;\n\ntemplate <typename R>\nclass MockFunction<R()> {\n public:\n  MockFunction() {}\n\n  MOCK_METHOD0_T(Call, R());\n\n#if GTEST_HAS_STD_FUNCTION_\n  std::function<R()> AsStdFunction() {\n    return [this]() -> R {\n      return this->Call();\n    };\n  }\n#endif  // GTEST_HAS_STD_FUNCTION_\n\n private:\n  GTEST_DISALLOW_COPY_AND_ASSIGN_(MockFunction);\n};\n\ntemplate <typename R, typename A0>\nclass MockFunction<R(A0)> {\n public:\n  MockFunction() {}\n\n  MOCK_METHOD1_T(Call, R(A0));\n\n#if GTEST_HAS_STD_FUNCTION_\n  std::function<R(A0)> AsStdFunction() {\n    return [this](A0 a0) -> R {\n      return this->Call(a0);\n    };\n  }\n#endif  // GTEST_HAS_STD_FUNCTION_\n\n private:\n  GTEST_DISALLOW_COPY_AND_ASSIGN_(MockFunction);\n};\n\ntemplate <typename R, typename A0, typename A1>\nclass MockFunction<R(A0, A1)> {\n public:\n  MockFunction() {}\n\n  MOCK_METHOD2_T(Call, R(A0, A1));\n\n#if GTEST_HAS_STD_FUNCTION_\n  std::function<R(A0, A1)> AsStdFunction() {\n    return [this](A0 a0, A1 a1) -> R {\n      return this->Call(a0, a1);\n    };\n  }\n#endif  // GTEST_HAS_STD_FUNCTION_\n\n private:\n  GTEST_DISALLOW_COPY_AND_ASSIGN_(MockFunction);\n};\n\ntemplate <typename R, typename A0, typename A1, typename A2>\nclass MockFunction<R(A0, A1, A2)> {\n public:\n  MockFunction() {}\n\n  MOCK_METHOD3_T(Call, R(A0, A1, A2));\n\n#if GTEST_HAS_STD_FUNCTION_\n  std::function<R(A0, A1, A2)> AsStdFunction() {\n    return [this](A0 a0, A1 a1, A2 a2) -> R {\n      return this->Call(a0, a1, a2);\n    };\n  }\n#endif  // GTEST_HAS_STD_FUNCTION_\n\n private:\n  GTEST_DISALLOW_COPY_AND_ASSIGN_(MockFunction);\n};\n\ntemplate <typename R, typename A0, typename A1, typename A2, typename A3>\nclass MockFunction<R(A0, A1, A2, A3)> {\n public:\n  MockFunction() {}\n\n  MOCK_METHOD4_T(Call, R(A0, A1, A2, A3));\n\n#if GTEST_HAS_STD_FUNCTION_\n  std::function<R(A0, A1, A2, A3)> AsStdFunction() {\n    return [this](A0 a0, A1 a1, A2 a2, A3 a3) -> R {\n      return this->Call(a0, a1, a2, a3);\n    };\n  }\n#endif  // GTEST_HAS_STD_FUNCTION_\n\n private:\n  GTEST_DISALLOW_COPY_AND_ASSIGN_(MockFunction);\n};\n\ntemplate <typename R, typename A0, typename A1, typename A2, typename A3,\n    typename A4>\nclass MockFunction<R(A0, A1, A2, A3, A4)> {\n public:\n  MockFunction() {}\n\n  MOCK_METHOD5_T(Call, R(A0, A1, A2, A3, A4));\n\n#if GTEST_HAS_STD_FUNCTION_\n  std::function<R(A0, A1, A2, A3, A4)> AsStdFunction() {\n    return [this](A0 a0, A1 a1, A2 a2, A3 a3, A4 a4) -> R {\n      return this->Call(a0, a1, a2, a3, a4);\n    };\n  }\n#endif  // GTEST_HAS_STD_FUNCTION_\n\n private:\n  GTEST_DISALLOW_COPY_AND_ASSIGN_(MockFunction);\n};\n\ntemplate <typename R, typename A0, typename A1, typename A2, typename A3,\n    typename A4, typename A5>\nclass MockFunction<R(A0, A1, A2, A3, A4, A5)> {\n public:\n  MockFunction() {}\n\n  MOCK_METHOD6_T(Call, R(A0, A1, A2, A3, A4, A5));\n\n#if GTEST_HAS_STD_FUNCTION_\n  std::function<R(A0, A1, A2, A3, A4, A5)> AsStdFunction() {\n    return [this](A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5) -> R {\n      return this->Call(a0, a1, a2, a3, a4, a5);\n    };\n  }\n#endif  // GTEST_HAS_STD_FUNCTION_\n\n private:\n  GTEST_DISALLOW_COPY_AND_ASSIGN_(MockFunction);\n};\n\ntemplate <typename R, typename A0, typename A1, typename A2, typename A3,\n    typename A4, typename A5, typename A6>\nclass MockFunction<R(A0, A1, A2, A3, A4, A5, A6)> {\n public:\n  MockFunction() {}\n\n  MOCK_METHOD7_T(Call, R(A0, A1, A2, A3, A4, A5, A6));\n\n#if GTEST_HAS_STD_FUNCTION_\n  std::function<R(A0, A1, A2, A3, A4, A5, A6)> AsStdFunction() {\n    return [this](A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6) -> R {\n      return this->Call(a0, a1, a2, a3, a4, a5, a6);\n    };\n  }\n#endif  // GTEST_HAS_STD_FUNCTION_\n\n private:\n  GTEST_DISALLOW_COPY_AND_ASSIGN_(MockFunction);\n};\n\ntemplate <typename R, typename A0, typename A1, typename A2, typename A3,\n    typename A4, typename A5, typename A6, typename A7>\nclass MockFunction<R(A0, A1, A2, A3, A4, A5, A6, A7)> {\n public:\n  MockFunction() {}\n\n  MOCK_METHOD8_T(Call, R(A0, A1, A2, A3, A4, A5, A6, A7));\n\n#if GTEST_HAS_STD_FUNCTION_\n  std::function<R(A0, A1, A2, A3, A4, A5, A6, A7)> AsStdFunction() {\n    return [this](A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7) -> R {\n      return this->Call(a0, a1, a2, a3, a4, a5, a6, a7);\n    };\n  }\n#endif  // GTEST_HAS_STD_FUNCTION_\n\n private:\n  GTEST_DISALLOW_COPY_AND_ASSIGN_(MockFunction);\n};\n\ntemplate <typename R, typename A0, typename A1, typename A2, typename A3,\n    typename A4, typename A5, typename A6, typename A7, typename A8>\nclass MockFunction<R(A0, A1, A2, A3, A4, A5, A6, A7, A8)> {\n public:\n  MockFunction() {}\n\n  MOCK_METHOD9_T(Call, R(A0, A1, A2, A3, A4, A5, A6, A7, A8));\n\n#if GTEST_HAS_STD_FUNCTION_\n  std::function<R(A0, A1, A2, A3, A4, A5, A6, A7, A8)> AsStdFunction() {\n    return [this](A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7,\n        A8 a8) -> R {\n      return this->Call(a0, a1, a2, a3, a4, a5, a6, a7, a8);\n    };\n  }\n#endif  // GTEST_HAS_STD_FUNCTION_\n\n private:\n  GTEST_DISALLOW_COPY_AND_ASSIGN_(MockFunction);\n};\n\ntemplate <typename R, typename A0, typename A1, typename A2, typename A3,\n    typename A4, typename A5, typename A6, typename A7, typename A8,\n    typename A9>\nclass MockFunction<R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9)> {\n public:\n  MockFunction() {}\n\n  MOCK_METHOD10_T(Call, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9));\n\n#if GTEST_HAS_STD_FUNCTION_\n  std::function<R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9)> AsStdFunction() {\n    return [this](A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7,\n        A8 a8, A9 a9) -> R {\n      return this->Call(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9);\n    };\n  }\n#endif  // GTEST_HAS_STD_FUNCTION_\n\n private:\n  GTEST_DISALLOW_COPY_AND_ASSIGN_(MockFunction);\n};\n\n}  // namespace testing\n\n#endif  // GMOCK_INCLUDE_GMOCK_GMOCK_GENERATED_FUNCTION_MOCKERS_H_\n"}, "33": {"id": 33, "path": "/home/vsts/work/1/llvm-project/llvm/utils/unittest/googlemock/include/gmock/gmock-generated-matchers.h", "content": "// This file was GENERATED by command:\n//     pump.py gmock-generated-matchers.h.pump\n// DO NOT EDIT BY HAND!!!\n\n// Copyright 2008, Google Inc.\n// All rights reserved.\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are\n// met:\n//\n//     * Redistributions of source code must retain the above copyright\n// notice, this list of conditions and the following disclaimer.\n//     * Redistributions in binary form must reproduce the above\n// copyright notice, this list of conditions and the following disclaimer\n// in the documentation and/or other materials provided with the\n// distribution.\n//     * Neither the name of Google Inc. nor the names of its\n// contributors may be used to endorse or promote products derived from\n// this software without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n// Google Mock - a framework for writing C++ mock classes.\n//\n// This file implements some commonly used variadic matchers.\n\n// IWYU pragma: private, include \"gmock/gmock.h\"\n\n#ifndef GMOCK_INCLUDE_GMOCK_GMOCK_GENERATED_MATCHERS_H_\n#define GMOCK_INCLUDE_GMOCK_GMOCK_GENERATED_MATCHERS_H_\n\n#include <iterator>\n#include <sstream>\n#include <string>\n#include <vector>\n#include \"gmock/gmock-matchers.h\"\n\nnamespace testing {\nnamespace internal {\n\n// The type of the i-th (0-based) field of Tuple.\n#define GMOCK_FIELD_TYPE_(Tuple, i) \\\n    typename ::testing::tuple_element<i, Tuple>::type\n\n// TupleFields<Tuple, k0, ..., kn> is for selecting fields from a\n// tuple of type Tuple.  It has two members:\n//\n//   type: a tuple type whose i-th field is the ki-th field of Tuple.\n//   GetSelectedFields(t): returns fields k0, ..., and kn of t as a tuple.\n//\n// For example, in class TupleFields<tuple<bool, char, int>, 2, 0>, we have:\n//\n//   type is tuple<int, bool>, and\n//   GetSelectedFields(make_tuple(true, 'a', 42)) is (42, true).\n\ntemplate <class Tuple, int k0 = -1, int k1 = -1, int k2 = -1, int k3 = -1,\n    int k4 = -1, int k5 = -1, int k6 = -1, int k7 = -1, int k8 = -1,\n    int k9 = -1>\nclass TupleFields;\n\n// This generic version is used when there are 10 selectors.\ntemplate <class Tuple, int k0, int k1, int k2, int k3, int k4, int k5, int k6,\n    int k7, int k8, int k9>\nclass TupleFields {\n public:\n  typedef ::testing::tuple<GMOCK_FIELD_TYPE_(Tuple, k0),\n      GMOCK_FIELD_TYPE_(Tuple, k1), GMOCK_FIELD_TYPE_(Tuple, k2),\n      GMOCK_FIELD_TYPE_(Tuple, k3), GMOCK_FIELD_TYPE_(Tuple, k4),\n      GMOCK_FIELD_TYPE_(Tuple, k5), GMOCK_FIELD_TYPE_(Tuple, k6),\n      GMOCK_FIELD_TYPE_(Tuple, k7), GMOCK_FIELD_TYPE_(Tuple, k8),\n      GMOCK_FIELD_TYPE_(Tuple, k9)> type;\n  static type GetSelectedFields(const Tuple& t) {\n    return type(get<k0>(t), get<k1>(t), get<k2>(t), get<k3>(t), get<k4>(t),\n        get<k5>(t), get<k6>(t), get<k7>(t), get<k8>(t), get<k9>(t));\n  }\n};\n\n// The following specialization is used for 0 ~ 9 selectors.\n\ntemplate <class Tuple>\nclass TupleFields<Tuple, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1> {\n public:\n  typedef ::testing::tuple<> type;\n  static type GetSelectedFields(const Tuple& /* t */) {\n    return type();\n  }\n};\n\ntemplate <class Tuple, int k0>\nclass TupleFields<Tuple, k0, -1, -1, -1, -1, -1, -1, -1, -1, -1> {\n public:\n  typedef ::testing::tuple<GMOCK_FIELD_TYPE_(Tuple, k0)> type;\n  static type GetSelectedFields(const Tuple& t) {\n    return type(get<k0>(t));\n  }\n};\n\ntemplate <class Tuple, int k0, int k1>\nclass TupleFields<Tuple, k0, k1, -1, -1, -1, -1, -1, -1, -1, -1> {\n public:\n  typedef ::testing::tuple<GMOCK_FIELD_TYPE_(Tuple, k0),\n      GMOCK_FIELD_TYPE_(Tuple, k1)> type;\n  static type GetSelectedFields(const Tuple& t) {\n    return type(get<k0>(t), get<k1>(t));\n  }\n};\n\ntemplate <class Tuple, int k0, int k1, int k2>\nclass TupleFields<Tuple, k0, k1, k2, -1, -1, -1, -1, -1, -1, -1> {\n public:\n  typedef ::testing::tuple<GMOCK_FIELD_TYPE_(Tuple, k0),\n      GMOCK_FIELD_TYPE_(Tuple, k1), GMOCK_FIELD_TYPE_(Tuple, k2)> type;\n  static type GetSelectedFields(const Tuple& t) {\n    return type(get<k0>(t), get<k1>(t), get<k2>(t));\n  }\n};\n\ntemplate <class Tuple, int k0, int k1, int k2, int k3>\nclass TupleFields<Tuple, k0, k1, k2, k3, -1, -1, -1, -1, -1, -1> {\n public:\n  typedef ::testing::tuple<GMOCK_FIELD_TYPE_(Tuple, k0),\n      GMOCK_FIELD_TYPE_(Tuple, k1), GMOCK_FIELD_TYPE_(Tuple, k2),\n      GMOCK_FIELD_TYPE_(Tuple, k3)> type;\n  static type GetSelectedFields(const Tuple& t) {\n    return type(get<k0>(t), get<k1>(t), get<k2>(t), get<k3>(t));\n  }\n};\n\ntemplate <class Tuple, int k0, int k1, int k2, int k3, int k4>\nclass TupleFields<Tuple, k0, k1, k2, k3, k4, -1, -1, -1, -1, -1> {\n public:\n  typedef ::testing::tuple<GMOCK_FIELD_TYPE_(Tuple, k0),\n      GMOCK_FIELD_TYPE_(Tuple, k1), GMOCK_FIELD_TYPE_(Tuple, k2),\n      GMOCK_FIELD_TYPE_(Tuple, k3), GMOCK_FIELD_TYPE_(Tuple, k4)> type;\n  static type GetSelectedFields(const Tuple& t) {\n    return type(get<k0>(t), get<k1>(t), get<k2>(t), get<k3>(t), get<k4>(t));\n  }\n};\n\ntemplate <class Tuple, int k0, int k1, int k2, int k3, int k4, int k5>\nclass TupleFields<Tuple, k0, k1, k2, k3, k4, k5, -1, -1, -1, -1> {\n public:\n  typedef ::testing::tuple<GMOCK_FIELD_TYPE_(Tuple, k0),\n      GMOCK_FIELD_TYPE_(Tuple, k1), GMOCK_FIELD_TYPE_(Tuple, k2),\n      GMOCK_FIELD_TYPE_(Tuple, k3), GMOCK_FIELD_TYPE_(Tuple, k4),\n      GMOCK_FIELD_TYPE_(Tuple, k5)> type;\n  static type GetSelectedFields(const Tuple& t) {\n    return type(get<k0>(t), get<k1>(t), get<k2>(t), get<k3>(t), get<k4>(t),\n        get<k5>(t));\n  }\n};\n\ntemplate <class Tuple, int k0, int k1, int k2, int k3, int k4, int k5, int k6>\nclass TupleFields<Tuple, k0, k1, k2, k3, k4, k5, k6, -1, -1, -1> {\n public:\n  typedef ::testing::tuple<GMOCK_FIELD_TYPE_(Tuple, k0),\n      GMOCK_FIELD_TYPE_(Tuple, k1), GMOCK_FIELD_TYPE_(Tuple, k2),\n      GMOCK_FIELD_TYPE_(Tuple, k3), GMOCK_FIELD_TYPE_(Tuple, k4),\n      GMOCK_FIELD_TYPE_(Tuple, k5), GMOCK_FIELD_TYPE_(Tuple, k6)> type;\n  static type GetSelectedFields(const Tuple& t) {\n    return type(get<k0>(t), get<k1>(t), get<k2>(t), get<k3>(t), get<k4>(t),\n        get<k5>(t), get<k6>(t));\n  }\n};\n\ntemplate <class Tuple, int k0, int k1, int k2, int k3, int k4, int k5, int k6,\n    int k7>\nclass TupleFields<Tuple, k0, k1, k2, k3, k4, k5, k6, k7, -1, -1> {\n public:\n  typedef ::testing::tuple<GMOCK_FIELD_TYPE_(Tuple, k0),\n      GMOCK_FIELD_TYPE_(Tuple, k1), GMOCK_FIELD_TYPE_(Tuple, k2),\n      GMOCK_FIELD_TYPE_(Tuple, k3), GMOCK_FIELD_TYPE_(Tuple, k4),\n      GMOCK_FIELD_TYPE_(Tuple, k5), GMOCK_FIELD_TYPE_(Tuple, k6),\n      GMOCK_FIELD_TYPE_(Tuple, k7)> type;\n  static type GetSelectedFields(const Tuple& t) {\n    return type(get<k0>(t), get<k1>(t), get<k2>(t), get<k3>(t), get<k4>(t),\n        get<k5>(t), get<k6>(t), get<k7>(t));\n  }\n};\n\ntemplate <class Tuple, int k0, int k1, int k2, int k3, int k4, int k5, int k6,\n    int k7, int k8>\nclass TupleFields<Tuple, k0, k1, k2, k3, k4, k5, k6, k7, k8, -1> {\n public:\n  typedef ::testing::tuple<GMOCK_FIELD_TYPE_(Tuple, k0),\n      GMOCK_FIELD_TYPE_(Tuple, k1), GMOCK_FIELD_TYPE_(Tuple, k2),\n      GMOCK_FIELD_TYPE_(Tuple, k3), GMOCK_FIELD_TYPE_(Tuple, k4),\n      GMOCK_FIELD_TYPE_(Tuple, k5), GMOCK_FIELD_TYPE_(Tuple, k6),\n      GMOCK_FIELD_TYPE_(Tuple, k7), GMOCK_FIELD_TYPE_(Tuple, k8)> type;\n  static type GetSelectedFields(const Tuple& t) {\n    return type(get<k0>(t), get<k1>(t), get<k2>(t), get<k3>(t), get<k4>(t),\n        get<k5>(t), get<k6>(t), get<k7>(t), get<k8>(t));\n  }\n};\n\n#undef GMOCK_FIELD_TYPE_\n\n// Implements the Args() matcher.\ntemplate <class ArgsTuple, int k0 = -1, int k1 = -1, int k2 = -1, int k3 = -1,\n    int k4 = -1, int k5 = -1, int k6 = -1, int k7 = -1, int k8 = -1,\n    int k9 = -1>\nclass ArgsMatcherImpl : public MatcherInterface<ArgsTuple> {\n public:\n  // ArgsTuple may have top-level const or reference modifiers.\n  typedef GTEST_REMOVE_REFERENCE_AND_CONST_(ArgsTuple) RawArgsTuple;\n  typedef typename internal::TupleFields<RawArgsTuple, k0, k1, k2, k3, k4, k5,\n      k6, k7, k8, k9>::type SelectedArgs;\n  typedef Matcher<const SelectedArgs&> MonomorphicInnerMatcher;\n\n  template <typename InnerMatcher>\n  explicit ArgsMatcherImpl(const InnerMatcher& inner_matcher)\n      : inner_matcher_(SafeMatcherCast<const SelectedArgs&>(inner_matcher)) {}\n\n  virtual bool MatchAndExplain(ArgsTuple args,\n                               MatchResultListener* listener) const {\n    const SelectedArgs& selected_args = GetSelectedArgs(args);\n    if (!listener->IsInterested())\n      return inner_matcher_.Matches(selected_args);\n\n    PrintIndices(listener->stream());\n    *listener << \"are \" << PrintToString(selected_args);\n\n    StringMatchResultListener inner_listener;\n    const bool match = inner_matcher_.MatchAndExplain(selected_args,\n                                                      &inner_listener);\n    PrintIfNotEmpty(inner_listener.str(), listener->stream());\n    return match;\n  }\n\n  virtual void DescribeTo(::std::ostream* os) const {\n    *os << \"are a tuple \";\n    PrintIndices(os);\n    inner_matcher_.DescribeTo(os);\n  }\n\n  virtual void DescribeNegationTo(::std::ostream* os) const {\n    *os << \"are a tuple \";\n    PrintIndices(os);\n    inner_matcher_.DescribeNegationTo(os);\n  }\n\n private:\n  static SelectedArgs GetSelectedArgs(ArgsTuple args) {\n    return TupleFields<RawArgsTuple, k0, k1, k2, k3, k4, k5, k6, k7, k8,\n        k9>::GetSelectedFields(args);\n  }\n\n  // Prints the indices of the selected fields.\n  static void PrintIndices(::std::ostream* os) {\n    *os << \"whose fields (\";\n    const int indices[10] = { k0, k1, k2, k3, k4, k5, k6, k7, k8, k9 };\n    for (int i = 0; i < 10; i++) {\n      if (indices[i] < 0)\n        break;\n\n      if (i >= 1)\n        *os << \", \";\n\n      *os << \"#\" << indices[i];\n    }\n    *os << \") \";\n  }\n\n  const MonomorphicInnerMatcher inner_matcher_;\n\n  GTEST_DISALLOW_ASSIGN_(ArgsMatcherImpl);\n};\n\ntemplate <class InnerMatcher, int k0 = -1, int k1 = -1, int k2 = -1,\n    int k3 = -1, int k4 = -1, int k5 = -1, int k6 = -1, int k7 = -1,\n    int k8 = -1, int k9 = -1>\nclass ArgsMatcher {\n public:\n  explicit ArgsMatcher(const InnerMatcher& inner_matcher)\n      : inner_matcher_(inner_matcher) {}\n\n  template <typename ArgsTuple>\n  operator Matcher<ArgsTuple>() const {\n    return MakeMatcher(new ArgsMatcherImpl<ArgsTuple, k0, k1, k2, k3, k4, k5,\n        k6, k7, k8, k9>(inner_matcher_));\n  }\n\n private:\n  const InnerMatcher inner_matcher_;\n\n  GTEST_DISALLOW_ASSIGN_(ArgsMatcher);\n};\n\n// A set of metafunctions for computing the result type of AllOf.\n// AllOf(m1, ..., mN) returns\n// AllOfResultN<decltype(m1), ..., decltype(mN)>::type.\n\n// Although AllOf isn't defined for one argument, AllOfResult1 is defined\n// to simplify the implementation.\ntemplate <typename M1>\nstruct AllOfResult1 {\n  typedef M1 type;\n};\n\ntemplate <typename M1, typename M2>\nstruct AllOfResult2 {\n  typedef BothOfMatcher<\n      typename AllOfResult1<M1>::type,\n      typename AllOfResult1<M2>::type\n  > type;\n};\n\ntemplate <typename M1, typename M2, typename M3>\nstruct AllOfResult3 {\n  typedef BothOfMatcher<\n      typename AllOfResult1<M1>::type,\n      typename AllOfResult2<M2, M3>::type\n  > type;\n};\n\ntemplate <typename M1, typename M2, typename M3, typename M4>\nstruct AllOfResult4 {\n  typedef BothOfMatcher<\n      typename AllOfResult2<M1, M2>::type,\n      typename AllOfResult2<M3, M4>::type\n  > type;\n};\n\ntemplate <typename M1, typename M2, typename M3, typename M4, typename M5>\nstruct AllOfResult5 {\n  typedef BothOfMatcher<\n      typename AllOfResult2<M1, M2>::type,\n      typename AllOfResult3<M3, M4, M5>::type\n  > type;\n};\n\ntemplate <typename M1, typename M2, typename M3, typename M4, typename M5,\n    typename M6>\nstruct AllOfResult6 {\n  typedef BothOfMatcher<\n      typename AllOfResult3<M1, M2, M3>::type,\n      typename AllOfResult3<M4, M5, M6>::type\n  > type;\n};\n\ntemplate <typename M1, typename M2, typename M3, typename M4, typename M5,\n    typename M6, typename M7>\nstruct AllOfResult7 {\n  typedef BothOfMatcher<\n      typename AllOfResult3<M1, M2, M3>::type,\n      typename AllOfResult4<M4, M5, M6, M7>::type\n  > type;\n};\n\ntemplate <typename M1, typename M2, typename M3, typename M4, typename M5,\n    typename M6, typename M7, typename M8>\nstruct AllOfResult8 {\n  typedef BothOfMatcher<\n      typename AllOfResult4<M1, M2, M3, M4>::type,\n      typename AllOfResult4<M5, M6, M7, M8>::type\n  > type;\n};\n\ntemplate <typename M1, typename M2, typename M3, typename M4, typename M5,\n    typename M6, typename M7, typename M8, typename M9>\nstruct AllOfResult9 {\n  typedef BothOfMatcher<\n      typename AllOfResult4<M1, M2, M3, M4>::type,\n      typename AllOfResult5<M5, M6, M7, M8, M9>::type\n  > type;\n};\n\ntemplate <typename M1, typename M2, typename M3, typename M4, typename M5,\n    typename M6, typename M7, typename M8, typename M9, typename M10>\nstruct AllOfResult10 {\n  typedef BothOfMatcher<\n      typename AllOfResult5<M1, M2, M3, M4, M5>::type,\n      typename AllOfResult5<M6, M7, M8, M9, M10>::type\n  > type;\n};\n\n// A set of metafunctions for computing the result type of AnyOf.\n// AnyOf(m1, ..., mN) returns\n// AnyOfResultN<decltype(m1), ..., decltype(mN)>::type.\n\n// Although AnyOf isn't defined for one argument, AnyOfResult1 is defined\n// to simplify the implementation.\ntemplate <typename M1>\nstruct AnyOfResult1 {\n  typedef M1 type;\n};\n\ntemplate <typename M1, typename M2>\nstruct AnyOfResult2 {\n  typedef EitherOfMatcher<\n      typename AnyOfResult1<M1>::type,\n      typename AnyOfResult1<M2>::type\n  > type;\n};\n\ntemplate <typename M1, typename M2, typename M3>\nstruct AnyOfResult3 {\n  typedef EitherOfMatcher<\n      typename AnyOfResult1<M1>::type,\n      typename AnyOfResult2<M2, M3>::type\n  > type;\n};\n\ntemplate <typename M1, typename M2, typename M3, typename M4>\nstruct AnyOfResult4 {\n  typedef EitherOfMatcher<\n      typename AnyOfResult2<M1, M2>::type,\n      typename AnyOfResult2<M3, M4>::type\n  > type;\n};\n\ntemplate <typename M1, typename M2, typename M3, typename M4, typename M5>\nstruct AnyOfResult5 {\n  typedef EitherOfMatcher<\n      typename AnyOfResult2<M1, M2>::type,\n      typename AnyOfResult3<M3, M4, M5>::type\n  > type;\n};\n\ntemplate <typename M1, typename M2, typename M3, typename M4, typename M5,\n    typename M6>\nstruct AnyOfResult6 {\n  typedef EitherOfMatcher<\n      typename AnyOfResult3<M1, M2, M3>::type,\n      typename AnyOfResult3<M4, M5, M6>::type\n  > type;\n};\n\ntemplate <typename M1, typename M2, typename M3, typename M4, typename M5,\n    typename M6, typename M7>\nstruct AnyOfResult7 {\n  typedef EitherOfMatcher<\n      typename AnyOfResult3<M1, M2, M3>::type,\n      typename AnyOfResult4<M4, M5, M6, M7>::type\n  > type;\n};\n\ntemplate <typename M1, typename M2, typename M3, typename M4, typename M5,\n    typename M6, typename M7, typename M8>\nstruct AnyOfResult8 {\n  typedef EitherOfMatcher<\n      typename AnyOfResult4<M1, M2, M3, M4>::type,\n      typename AnyOfResult4<M5, M6, M7, M8>::type\n  > type;\n};\n\ntemplate <typename M1, typename M2, typename M3, typename M4, typename M5,\n    typename M6, typename M7, typename M8, typename M9>\nstruct AnyOfResult9 {\n  typedef EitherOfMatcher<\n      typename AnyOfResult4<M1, M2, M3, M4>::type,\n      typename AnyOfResult5<M5, M6, M7, M8, M9>::type\n  > type;\n};\n\ntemplate <typename M1, typename M2, typename M3, typename M4, typename M5,\n    typename M6, typename M7, typename M8, typename M9, typename M10>\nstruct AnyOfResult10 {\n  typedef EitherOfMatcher<\n      typename AnyOfResult5<M1, M2, M3, M4, M5>::type,\n      typename AnyOfResult5<M6, M7, M8, M9, M10>::type\n  > type;\n};\n\n}  // namespace internal\n\n// Args<N1, N2, ..., Nk>(a_matcher) matches a tuple if the selected\n// fields of it matches a_matcher.  C++ doesn't support default\n// arguments for function templates, so we have to overload it.\ntemplate <typename InnerMatcher>\ninline internal::ArgsMatcher<InnerMatcher>\nArgs(const InnerMatcher& matcher) {\n  return internal::ArgsMatcher<InnerMatcher>(matcher);\n}\n\ntemplate <int k1, typename InnerMatcher>\ninline internal::ArgsMatcher<InnerMatcher, k1>\nArgs(const InnerMatcher& matcher) {\n  return internal::ArgsMatcher<InnerMatcher, k1>(matcher);\n}\n\ntemplate <int k1, int k2, typename InnerMatcher>\ninline internal::ArgsMatcher<InnerMatcher, k1, k2>\nArgs(const InnerMatcher& matcher) {\n  return internal::ArgsMatcher<InnerMatcher, k1, k2>(matcher);\n}\n\ntemplate <int k1, int k2, int k3, typename InnerMatcher>\ninline internal::ArgsMatcher<InnerMatcher, k1, k2, k3>\nArgs(const InnerMatcher& matcher) {\n  return internal::ArgsMatcher<InnerMatcher, k1, k2, k3>(matcher);\n}\n\ntemplate <int k1, int k2, int k3, int k4, typename InnerMatcher>\ninline internal::ArgsMatcher<InnerMatcher, k1, k2, k3, k4>\nArgs(const InnerMatcher& matcher) {\n  return internal::ArgsMatcher<InnerMatcher, k1, k2, k3, k4>(matcher);\n}\n\ntemplate <int k1, int k2, int k3, int k4, int k5, typename InnerMatcher>\ninline internal::ArgsMatcher<InnerMatcher, k1, k2, k3, k4, k5>\nArgs(const InnerMatcher& matcher) {\n  return internal::ArgsMatcher<InnerMatcher, k1, k2, k3, k4, k5>(matcher);\n}\n\ntemplate <int k1, int k2, int k3, int k4, int k5, int k6, typename InnerMatcher>\ninline internal::ArgsMatcher<InnerMatcher, k1, k2, k3, k4, k5, k6>\nArgs(const InnerMatcher& matcher) {\n  return internal::ArgsMatcher<InnerMatcher, k1, k2, k3, k4, k5, k6>(matcher);\n}\n\ntemplate <int k1, int k2, int k3, int k4, int k5, int k6, int k7,\n    typename InnerMatcher>\ninline internal::ArgsMatcher<InnerMatcher, k1, k2, k3, k4, k5, k6, k7>\nArgs(const InnerMatcher& matcher) {\n  return internal::ArgsMatcher<InnerMatcher, k1, k2, k3, k4, k5, k6,\n      k7>(matcher);\n}\n\ntemplate <int k1, int k2, int k3, int k4, int k5, int k6, int k7, int k8,\n    typename InnerMatcher>\ninline internal::ArgsMatcher<InnerMatcher, k1, k2, k3, k4, k5, k6, k7, k8>\nArgs(const InnerMatcher& matcher) {\n  return internal::ArgsMatcher<InnerMatcher, k1, k2, k3, k4, k5, k6, k7,\n      k8>(matcher);\n}\n\ntemplate <int k1, int k2, int k3, int k4, int k5, int k6, int k7, int k8,\n    int k9, typename InnerMatcher>\ninline internal::ArgsMatcher<InnerMatcher, k1, k2, k3, k4, k5, k6, k7, k8, k9>\nArgs(const InnerMatcher& matcher) {\n  return internal::ArgsMatcher<InnerMatcher, k1, k2, k3, k4, k5, k6, k7, k8,\n      k9>(matcher);\n}\n\ntemplate <int k1, int k2, int k3, int k4, int k5, int k6, int k7, int k8,\n    int k9, int k10, typename InnerMatcher>\ninline internal::ArgsMatcher<InnerMatcher, k1, k2, k3, k4, k5, k6, k7, k8, k9,\n    k10>\nArgs(const InnerMatcher& matcher) {\n  return internal::ArgsMatcher<InnerMatcher, k1, k2, k3, k4, k5, k6, k7, k8,\n      k9, k10>(matcher);\n}\n\n// ElementsAre(e_1, e_2, ... e_n) matches an STL-style container with\n// n elements, where the i-th element in the container must\n// match the i-th argument in the list.  Each argument of\n// ElementsAre() can be either a value or a matcher.  We support up to\n// 10 arguments.\n//\n// The use of DecayArray in the implementation allows ElementsAre()\n// to accept string literals, whose type is const char[N], but we\n// want to treat them as const char*.\n//\n// NOTE: Since ElementsAre() cares about the order of the elements, it\n// must not be used with containers whose elements's order is\n// undefined (e.g. hash_map).\n\ninline internal::ElementsAreMatcher<\n    ::testing::tuple<> >\nElementsAre() {\n  typedef ::testing::tuple<> Args;\n  return internal::ElementsAreMatcher<Args>(Args());\n}\n\ntemplate <typename T1>\ninline internal::ElementsAreMatcher<\n    ::testing::tuple<\n        typename internal::DecayArray<T1>::type> >\nElementsAre(const T1& e1) {\n  typedef ::testing::tuple<\n      typename internal::DecayArray<T1>::type> Args;\n  return internal::ElementsAreMatcher<Args>(Args(e1));\n}\n\ntemplate <typename T1, typename T2>\ninline internal::ElementsAreMatcher<\n    ::testing::tuple<\n        typename internal::DecayArray<T1>::type,\n        typename internal::DecayArray<T2>::type> >\nElementsAre(const T1& e1, const T2& e2) {\n  typedef ::testing::tuple<\n      typename internal::DecayArray<T1>::type,\n      typename internal::DecayArray<T2>::type> Args;\n  return internal::ElementsAreMatcher<Args>(Args(e1, e2));\n}\n\ntemplate <typename T1, typename T2, typename T3>\ninline internal::ElementsAreMatcher<\n    ::testing::tuple<\n        typename internal::DecayArray<T1>::type,\n        typename internal::DecayArray<T2>::type,\n        typename internal::DecayArray<T3>::type> >\nElementsAre(const T1& e1, const T2& e2, const T3& e3) {\n  typedef ::testing::tuple<\n      typename internal::DecayArray<T1>::type,\n      typename internal::DecayArray<T2>::type,\n      typename internal::DecayArray<T3>::type> Args;\n  return internal::ElementsAreMatcher<Args>(Args(e1, e2, e3));\n}\n\ntemplate <typename T1, typename T2, typename T3, typename T4>\ninline internal::ElementsAreMatcher<\n    ::testing::tuple<\n        typename internal::DecayArray<T1>::type,\n        typename internal::DecayArray<T2>::type,\n        typename internal::DecayArray<T3>::type,\n        typename internal::DecayArray<T4>::type> >\nElementsAre(const T1& e1, const T2& e2, const T3& e3, const T4& e4) {\n  typedef ::testing::tuple<\n      typename internal::DecayArray<T1>::type,\n      typename internal::DecayArray<T2>::type,\n      typename internal::DecayArray<T3>::type,\n      typename internal::DecayArray<T4>::type> Args;\n  return internal::ElementsAreMatcher<Args>(Args(e1, e2, e3, e4));\n}\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5>\ninline internal::ElementsAreMatcher<\n    ::testing::tuple<\n        typename internal::DecayArray<T1>::type,\n        typename internal::DecayArray<T2>::type,\n        typename internal::DecayArray<T3>::type,\n        typename internal::DecayArray<T4>::type,\n        typename internal::DecayArray<T5>::type> >\nElementsAre(const T1& e1, const T2& e2, const T3& e3, const T4& e4,\n    const T5& e5) {\n  typedef ::testing::tuple<\n      typename internal::DecayArray<T1>::type,\n      typename internal::DecayArray<T2>::type,\n      typename internal::DecayArray<T3>::type,\n      typename internal::DecayArray<T4>::type,\n      typename internal::DecayArray<T5>::type> Args;\n  return internal::ElementsAreMatcher<Args>(Args(e1, e2, e3, e4, e5));\n}\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6>\ninline internal::ElementsAreMatcher<\n    ::testing::tuple<\n        typename internal::DecayArray<T1>::type,\n        typename internal::DecayArray<T2>::type,\n        typename internal::DecayArray<T3>::type,\n        typename internal::DecayArray<T4>::type,\n        typename internal::DecayArray<T5>::type,\n        typename internal::DecayArray<T6>::type> >\nElementsAre(const T1& e1, const T2& e2, const T3& e3, const T4& e4,\n    const T5& e5, const T6& e6) {\n  typedef ::testing::tuple<\n      typename internal::DecayArray<T1>::type,\n      typename internal::DecayArray<T2>::type,\n      typename internal::DecayArray<T3>::type,\n      typename internal::DecayArray<T4>::type,\n      typename internal::DecayArray<T5>::type,\n      typename internal::DecayArray<T6>::type> Args;\n  return internal::ElementsAreMatcher<Args>(Args(e1, e2, e3, e4, e5, e6));\n}\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7>\ninline internal::ElementsAreMatcher<\n    ::testing::tuple<\n        typename internal::DecayArray<T1>::type,\n        typename internal::DecayArray<T2>::type,\n        typename internal::DecayArray<T3>::type,\n        typename internal::DecayArray<T4>::type,\n        typename internal::DecayArray<T5>::type,\n        typename internal::DecayArray<T6>::type,\n        typename internal::DecayArray<T7>::type> >\nElementsAre(const T1& e1, const T2& e2, const T3& e3, const T4& e4,\n    const T5& e5, const T6& e6, const T7& e7) {\n  typedef ::testing::tuple<\n      typename internal::DecayArray<T1>::type,\n      typename internal::DecayArray<T2>::type,\n      typename internal::DecayArray<T3>::type,\n      typename internal::DecayArray<T4>::type,\n      typename internal::DecayArray<T5>::type,\n      typename internal::DecayArray<T6>::type,\n      typename internal::DecayArray<T7>::type> Args;\n  return internal::ElementsAreMatcher<Args>(Args(e1, e2, e3, e4, e5, e6, e7));\n}\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8>\ninline internal::ElementsAreMatcher<\n    ::testing::tuple<\n        typename internal::DecayArray<T1>::type,\n        typename internal::DecayArray<T2>::type,\n        typename internal::DecayArray<T3>::type,\n        typename internal::DecayArray<T4>::type,\n        typename internal::DecayArray<T5>::type,\n        typename internal::DecayArray<T6>::type,\n        typename internal::DecayArray<T7>::type,\n        typename internal::DecayArray<T8>::type> >\nElementsAre(const T1& e1, const T2& e2, const T3& e3, const T4& e4,\n    const T5& e5, const T6& e6, const T7& e7, const T8& e8) {\n  typedef ::testing::tuple<\n      typename internal::DecayArray<T1>::type,\n      typename internal::DecayArray<T2>::type,\n      typename internal::DecayArray<T3>::type,\n      typename internal::DecayArray<T4>::type,\n      typename internal::DecayArray<T5>::type,\n      typename internal::DecayArray<T6>::type,\n      typename internal::DecayArray<T7>::type,\n      typename internal::DecayArray<T8>::type> Args;\n  return internal::ElementsAreMatcher<Args>(Args(e1, e2, e3, e4, e5, e6, e7,\n      e8));\n}\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9>\ninline internal::ElementsAreMatcher<\n    ::testing::tuple<\n        typename internal::DecayArray<T1>::type,\n        typename internal::DecayArray<T2>::type,\n        typename internal::DecayArray<T3>::type,\n        typename internal::DecayArray<T4>::type,\n        typename internal::DecayArray<T5>::type,\n        typename internal::DecayArray<T6>::type,\n        typename internal::DecayArray<T7>::type,\n        typename internal::DecayArray<T8>::type,\n        typename internal::DecayArray<T9>::type> >\nElementsAre(const T1& e1, const T2& e2, const T3& e3, const T4& e4,\n    const T5& e5, const T6& e6, const T7& e7, const T8& e8, const T9& e9) {\n  typedef ::testing::tuple<\n      typename internal::DecayArray<T1>::type,\n      typename internal::DecayArray<T2>::type,\n      typename internal::DecayArray<T3>::type,\n      typename internal::DecayArray<T4>::type,\n      typename internal::DecayArray<T5>::type,\n      typename internal::DecayArray<T6>::type,\n      typename internal::DecayArray<T7>::type,\n      typename internal::DecayArray<T8>::type,\n      typename internal::DecayArray<T9>::type> Args;\n  return internal::ElementsAreMatcher<Args>(Args(e1, e2, e3, e4, e5, e6, e7,\n      e8, e9));\n}\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10>\ninline internal::ElementsAreMatcher<\n    ::testing::tuple<\n        typename internal::DecayArray<T1>::type,\n        typename internal::DecayArray<T2>::type,\n        typename internal::DecayArray<T3>::type,\n        typename internal::DecayArray<T4>::type,\n        typename internal::DecayArray<T5>::type,\n        typename internal::DecayArray<T6>::type,\n        typename internal::DecayArray<T7>::type,\n        typename internal::DecayArray<T8>::type,\n        typename internal::DecayArray<T9>::type,\n        typename internal::DecayArray<T10>::type> >\nElementsAre(const T1& e1, const T2& e2, const T3& e3, const T4& e4,\n    const T5& e5, const T6& e6, const T7& e7, const T8& e8, const T9& e9,\n    const T10& e10) {\n  typedef ::testing::tuple<\n      typename internal::DecayArray<T1>::type,\n      typename internal::DecayArray<T2>::type,\n      typename internal::DecayArray<T3>::type,\n      typename internal::DecayArray<T4>::type,\n      typename internal::DecayArray<T5>::type,\n      typename internal::DecayArray<T6>::type,\n      typename internal::DecayArray<T7>::type,\n      typename internal::DecayArray<T8>::type,\n      typename internal::DecayArray<T9>::type,\n      typename internal::DecayArray<T10>::type> Args;\n  return internal::ElementsAreMatcher<Args>(Args(e1, e2, e3, e4, e5, e6, e7,\n      e8, e9, e10));\n}\n\n// UnorderedElementsAre(e_1, e_2, ..., e_n) is an ElementsAre extension\n// that matches n elements in any order.  We support up to n=10 arguments.\n\ninline internal::UnorderedElementsAreMatcher<\n    ::testing::tuple<> >\nUnorderedElementsAre() {\n  typedef ::testing::tuple<> Args;\n  return internal::UnorderedElementsAreMatcher<Args>(Args());\n}\n\ntemplate <typename T1>\ninline internal::UnorderedElementsAreMatcher<\n    ::testing::tuple<\n        typename internal::DecayArray<T1>::type> >\nUnorderedElementsAre(const T1& e1) {\n  typedef ::testing::tuple<\n      typename internal::DecayArray<T1>::type> Args;\n  return internal::UnorderedElementsAreMatcher<Args>(Args(e1));\n}\n\ntemplate <typename T1, typename T2>\ninline internal::UnorderedElementsAreMatcher<\n    ::testing::tuple<\n        typename internal::DecayArray<T1>::type,\n        typename internal::DecayArray<T2>::type> >\nUnorderedElementsAre(const T1& e1, const T2& e2) {\n  typedef ::testing::tuple<\n      typename internal::DecayArray<T1>::type,\n      typename internal::DecayArray<T2>::type> Args;\n  return internal::UnorderedElementsAreMatcher<Args>(Args(e1, e2));\n}\n\ntemplate <typename T1, typename T2, typename T3>\ninline internal::UnorderedElementsAreMatcher<\n    ::testing::tuple<\n        typename internal::DecayArray<T1>::type,\n        typename internal::DecayArray<T2>::type,\n        typename internal::DecayArray<T3>::type> >\nUnorderedElementsAre(const T1& e1, const T2& e2, const T3& e3) {\n  typedef ::testing::tuple<\n      typename internal::DecayArray<T1>::type,\n      typename internal::DecayArray<T2>::type,\n      typename internal::DecayArray<T3>::type> Args;\n  return internal::UnorderedElementsAreMatcher<Args>(Args(e1, e2, e3));\n}\n\ntemplate <typename T1, typename T2, typename T3, typename T4>\ninline internal::UnorderedElementsAreMatcher<\n    ::testing::tuple<\n        typename internal::DecayArray<T1>::type,\n        typename internal::DecayArray<T2>::type,\n        typename internal::DecayArray<T3>::type,\n        typename internal::DecayArray<T4>::type> >\nUnorderedElementsAre(const T1& e1, const T2& e2, const T3& e3, const T4& e4) {\n  typedef ::testing::tuple<\n      typename internal::DecayArray<T1>::type,\n      typename internal::DecayArray<T2>::type,\n      typename internal::DecayArray<T3>::type,\n      typename internal::DecayArray<T4>::type> Args;\n  return internal::UnorderedElementsAreMatcher<Args>(Args(e1, e2, e3, e4));\n}\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5>\ninline internal::UnorderedElementsAreMatcher<\n    ::testing::tuple<\n        typename internal::DecayArray<T1>::type,\n        typename internal::DecayArray<T2>::type,\n        typename internal::DecayArray<T3>::type,\n        typename internal::DecayArray<T4>::type,\n        typename internal::DecayArray<T5>::type> >\nUnorderedElementsAre(const T1& e1, const T2& e2, const T3& e3, const T4& e4,\n    const T5& e5) {\n  typedef ::testing::tuple<\n      typename internal::DecayArray<T1>::type,\n      typename internal::DecayArray<T2>::type,\n      typename internal::DecayArray<T3>::type,\n      typename internal::DecayArray<T4>::type,\n      typename internal::DecayArray<T5>::type> Args;\n  return internal::UnorderedElementsAreMatcher<Args>(Args(e1, e2, e3, e4, e5));\n}\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6>\ninline internal::UnorderedElementsAreMatcher<\n    ::testing::tuple<\n        typename internal::DecayArray<T1>::type,\n        typename internal::DecayArray<T2>::type,\n        typename internal::DecayArray<T3>::type,\n        typename internal::DecayArray<T4>::type,\n        typename internal::DecayArray<T5>::type,\n        typename internal::DecayArray<T6>::type> >\nUnorderedElementsAre(const T1& e1, const T2& e2, const T3& e3, const T4& e4,\n    const T5& e5, const T6& e6) {\n  typedef ::testing::tuple<\n      typename internal::DecayArray<T1>::type,\n      typename internal::DecayArray<T2>::type,\n      typename internal::DecayArray<T3>::type,\n      typename internal::DecayArray<T4>::type,\n      typename internal::DecayArray<T5>::type,\n      typename internal::DecayArray<T6>::type> Args;\n  return internal::UnorderedElementsAreMatcher<Args>(Args(e1, e2, e3, e4, e5,\n      e6));\n}\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7>\ninline internal::UnorderedElementsAreMatcher<\n    ::testing::tuple<\n        typename internal::DecayArray<T1>::type,\n        typename internal::DecayArray<T2>::type,\n        typename internal::DecayArray<T3>::type,\n        typename internal::DecayArray<T4>::type,\n        typename internal::DecayArray<T5>::type,\n        typename internal::DecayArray<T6>::type,\n        typename internal::DecayArray<T7>::type> >\nUnorderedElementsAre(const T1& e1, const T2& e2, const T3& e3, const T4& e4,\n    const T5& e5, const T6& e6, const T7& e7) {\n  typedef ::testing::tuple<\n      typename internal::DecayArray<T1>::type,\n      typename internal::DecayArray<T2>::type,\n      typename internal::DecayArray<T3>::type,\n      typename internal::DecayArray<T4>::type,\n      typename internal::DecayArray<T5>::type,\n      typename internal::DecayArray<T6>::type,\n      typename internal::DecayArray<T7>::type> Args;\n  return internal::UnorderedElementsAreMatcher<Args>(Args(e1, e2, e3, e4, e5,\n      e6, e7));\n}\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8>\ninline internal::UnorderedElementsAreMatcher<\n    ::testing::tuple<\n        typename internal::DecayArray<T1>::type,\n        typename internal::DecayArray<T2>::type,\n        typename internal::DecayArray<T3>::type,\n        typename internal::DecayArray<T4>::type,\n        typename internal::DecayArray<T5>::type,\n        typename internal::DecayArray<T6>::type,\n        typename internal::DecayArray<T7>::type,\n        typename internal::DecayArray<T8>::type> >\nUnorderedElementsAre(const T1& e1, const T2& e2, const T3& e3, const T4& e4,\n    const T5& e5, const T6& e6, const T7& e7, const T8& e8) {\n  typedef ::testing::tuple<\n      typename internal::DecayArray<T1>::type,\n      typename internal::DecayArray<T2>::type,\n      typename internal::DecayArray<T3>::type,\n      typename internal::DecayArray<T4>::type,\n      typename internal::DecayArray<T5>::type,\n      typename internal::DecayArray<T6>::type,\n      typename internal::DecayArray<T7>::type,\n      typename internal::DecayArray<T8>::type> Args;\n  return internal::UnorderedElementsAreMatcher<Args>(Args(e1, e2, e3, e4, e5,\n      e6, e7, e8));\n}\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9>\ninline internal::UnorderedElementsAreMatcher<\n    ::testing::tuple<\n        typename internal::DecayArray<T1>::type,\n        typename internal::DecayArray<T2>::type,\n        typename internal::DecayArray<T3>::type,\n        typename internal::DecayArray<T4>::type,\n        typename internal::DecayArray<T5>::type,\n        typename internal::DecayArray<T6>::type,\n        typename internal::DecayArray<T7>::type,\n        typename internal::DecayArray<T8>::type,\n        typename internal::DecayArray<T9>::type> >\nUnorderedElementsAre(const T1& e1, const T2& e2, const T3& e3, const T4& e4,\n    const T5& e5, const T6& e6, const T7& e7, const T8& e8, const T9& e9) {\n  typedef ::testing::tuple<\n      typename internal::DecayArray<T1>::type,\n      typename internal::DecayArray<T2>::type,\n      typename internal::DecayArray<T3>::type,\n      typename internal::DecayArray<T4>::type,\n      typename internal::DecayArray<T5>::type,\n      typename internal::DecayArray<T6>::type,\n      typename internal::DecayArray<T7>::type,\n      typename internal::DecayArray<T8>::type,\n      typename internal::DecayArray<T9>::type> Args;\n  return internal::UnorderedElementsAreMatcher<Args>(Args(e1, e2, e3, e4, e5,\n      e6, e7, e8, e9));\n}\n\ntemplate <typename T1, typename T2, typename T3, typename T4, typename T5,\n    typename T6, typename T7, typename T8, typename T9, typename T10>\ninline internal::UnorderedElementsAreMatcher<\n    ::testing::tuple<\n        typename internal::DecayArray<T1>::type,\n        typename internal::DecayArray<T2>::type,\n        typename internal::DecayArray<T3>::type,\n        typename internal::DecayArray<T4>::type,\n        typename internal::DecayArray<T5>::type,\n        typename internal::DecayArray<T6>::type,\n        typename internal::DecayArray<T7>::type,\n        typename internal::DecayArray<T8>::type,\n        typename internal::DecayArray<T9>::type,\n        typename internal::DecayArray<T10>::type> >\nUnorderedElementsAre(const T1& e1, const T2& e2, const T3& e3, const T4& e4,\n    const T5& e5, const T6& e6, const T7& e7, const T8& e8, const T9& e9,\n    const T10& e10) {\n  typedef ::testing::tuple<\n      typename internal::DecayArray<T1>::type,\n      typename internal::DecayArray<T2>::type,\n      typename internal::DecayArray<T3>::type,\n      typename internal::DecayArray<T4>::type,\n      typename internal::DecayArray<T5>::type,\n      typename internal::DecayArray<T6>::type,\n      typename internal::DecayArray<T7>::type,\n      typename internal::DecayArray<T8>::type,\n      typename internal::DecayArray<T9>::type,\n      typename internal::DecayArray<T10>::type> Args;\n  return internal::UnorderedElementsAreMatcher<Args>(Args(e1, e2, e3, e4, e5,\n      e6, e7, e8, e9, e10));\n}\n\n// AllOf(m1, m2, ..., mk) matches any value that matches all of the given\n// sub-matchers.  AllOf is called fully qualified to prevent ADL from firing.\n\ntemplate <typename M1, typename M2>\ninline typename internal::AllOfResult2<M1, M2>::type\nAllOf(M1 m1, M2 m2) {\n  return typename internal::AllOfResult2<M1, M2>::type(\n      m1,\n      m2);\n}\n\ntemplate <typename M1, typename M2, typename M3>\ninline typename internal::AllOfResult3<M1, M2, M3>::type\nAllOf(M1 m1, M2 m2, M3 m3) {\n  return typename internal::AllOfResult3<M1, M2, M3>::type(\n      m1,\n      ::testing::AllOf(m2, m3));\n}\n\ntemplate <typename M1, typename M2, typename M3, typename M4>\ninline typename internal::AllOfResult4<M1, M2, M3, M4>::type\nAllOf(M1 m1, M2 m2, M3 m3, M4 m4) {\n  return typename internal::AllOfResult4<M1, M2, M3, M4>::type(\n      ::testing::AllOf(m1, m2),\n      ::testing::AllOf(m3, m4));\n}\n\ntemplate <typename M1, typename M2, typename M3, typename M4, typename M5>\ninline typename internal::AllOfResult5<M1, M2, M3, M4, M5>::type\nAllOf(M1 m1, M2 m2, M3 m3, M4 m4, M5 m5) {\n  return typename internal::AllOfResult5<M1, M2, M3, M4, M5>::type(\n      ::testing::AllOf(m1, m2),\n      ::testing::AllOf(m3, m4, m5));\n}\n\ntemplate <typename M1, typename M2, typename M3, typename M4, typename M5,\n    typename M6>\ninline typename internal::AllOfResult6<M1, M2, M3, M4, M5, M6>::type\nAllOf(M1 m1, M2 m2, M3 m3, M4 m4, M5 m5, M6 m6) {\n  return typename internal::AllOfResult6<M1, M2, M3, M4, M5, M6>::type(\n      ::testing::AllOf(m1, m2, m3),\n      ::testing::AllOf(m4, m5, m6));\n}\n\ntemplate <typename M1, typename M2, typename M3, typename M4, typename M5,\n    typename M6, typename M7>\ninline typename internal::AllOfResult7<M1, M2, M3, M4, M5, M6, M7>::type\nAllOf(M1 m1, M2 m2, M3 m3, M4 m4, M5 m5, M6 m6, M7 m7) {\n  return typename internal::AllOfResult7<M1, M2, M3, M4, M5, M6, M7>::type(\n      ::testing::AllOf(m1, m2, m3),\n      ::testing::AllOf(m4, m5, m6, m7));\n}\n\ntemplate <typename M1, typename M2, typename M3, typename M4, typename M5,\n    typename M6, typename M7, typename M8>\ninline typename internal::AllOfResult8<M1, M2, M3, M4, M5, M6, M7, M8>::type\nAllOf(M1 m1, M2 m2, M3 m3, M4 m4, M5 m5, M6 m6, M7 m7, M8 m8) {\n  return typename internal::AllOfResult8<M1, M2, M3, M4, M5, M6, M7, M8>::type(\n      ::testing::AllOf(m1, m2, m3, m4),\n      ::testing::AllOf(m5, m6, m7, m8));\n}\n\ntemplate <typename M1, typename M2, typename M3, typename M4, typename M5,\n    typename M6, typename M7, typename M8, typename M9>\ninline typename internal::AllOfResult9<M1, M2, M3, M4, M5, M6, M7, M8, M9>::type\nAllOf(M1 m1, M2 m2, M3 m3, M4 m4, M5 m5, M6 m6, M7 m7, M8 m8, M9 m9) {\n  return typename internal::AllOfResult9<M1, M2, M3, M4, M5, M6, M7, M8,\n      M9>::type(\n      ::testing::AllOf(m1, m2, m3, m4),\n      ::testing::AllOf(m5, m6, m7, m8, m9));\n}\n\ntemplate <typename M1, typename M2, typename M3, typename M4, typename M5,\n    typename M6, typename M7, typename M8, typename M9, typename M10>\ninline typename internal::AllOfResult10<M1, M2, M3, M4, M5, M6, M7, M8, M9,\n    M10>::type\nAllOf(M1 m1, M2 m2, M3 m3, M4 m4, M5 m5, M6 m6, M7 m7, M8 m8, M9 m9, M10 m10) {\n  return typename internal::AllOfResult10<M1, M2, M3, M4, M5, M6, M7, M8, M9,\n      M10>::type(\n      ::testing::AllOf(m1, m2, m3, m4, m5),\n      ::testing::AllOf(m6, m7, m8, m9, m10));\n}\n\n// AnyOf(m1, m2, ..., mk) matches any value that matches any of the given\n// sub-matchers.  AnyOf is called fully qualified to prevent ADL from firing.\n\ntemplate <typename M1, typename M2>\ninline typename internal::AnyOfResult2<M1, M2>::type\nAnyOf(M1 m1, M2 m2) {\n  return typename internal::AnyOfResult2<M1, M2>::type(\n      m1,\n      m2);\n}\n\ntemplate <typename M1, typename M2, typename M3>\ninline typename internal::AnyOfResult3<M1, M2, M3>::type\nAnyOf(M1 m1, M2 m2, M3 m3) {\n  return typename internal::AnyOfResult3<M1, M2, M3>::type(\n      m1,\n      ::testing::AnyOf(m2, m3));\n}\n\ntemplate <typename M1, typename M2, typename M3, typename M4>\ninline typename internal::AnyOfResult4<M1, M2, M3, M4>::type\nAnyOf(M1 m1, M2 m2, M3 m3, M4 m4) {\n  return typename internal::AnyOfResult4<M1, M2, M3, M4>::type(\n      ::testing::AnyOf(m1, m2),\n      ::testing::AnyOf(m3, m4));\n}\n\ntemplate <typename M1, typename M2, typename M3, typename M4, typename M5>\ninline typename internal::AnyOfResult5<M1, M2, M3, M4, M5>::type\nAnyOf(M1 m1, M2 m2, M3 m3, M4 m4, M5 m5) {\n  return typename internal::AnyOfResult5<M1, M2, M3, M4, M5>::type(\n      ::testing::AnyOf(m1, m2),\n      ::testing::AnyOf(m3, m4, m5));\n}\n\ntemplate <typename M1, typename M2, typename M3, typename M4, typename M5,\n    typename M6>\ninline typename internal::AnyOfResult6<M1, M2, M3, M4, M5, M6>::type\nAnyOf(M1 m1, M2 m2, M3 m3, M4 m4, M5 m5, M6 m6) {\n  return typename internal::AnyOfResult6<M1, M2, M3, M4, M5, M6>::type(\n      ::testing::AnyOf(m1, m2, m3),\n      ::testing::AnyOf(m4, m5, m6));\n}\n\ntemplate <typename M1, typename M2, typename M3, typename M4, typename M5,\n    typename M6, typename M7>\ninline typename internal::AnyOfResult7<M1, M2, M3, M4, M5, M6, M7>::type\nAnyOf(M1 m1, M2 m2, M3 m3, M4 m4, M5 m5, M6 m6, M7 m7) {\n  return typename internal::AnyOfResult7<M1, M2, M3, M4, M5, M6, M7>::type(\n      ::testing::AnyOf(m1, m2, m3),\n      ::testing::AnyOf(m4, m5, m6, m7));\n}\n\ntemplate <typename M1, typename M2, typename M3, typename M4, typename M5,\n    typename M6, typename M7, typename M8>\ninline typename internal::AnyOfResult8<M1, M2, M3, M4, M5, M6, M7, M8>::type\nAnyOf(M1 m1, M2 m2, M3 m3, M4 m4, M5 m5, M6 m6, M7 m7, M8 m8) {\n  return typename internal::AnyOfResult8<M1, M2, M3, M4, M5, M6, M7, M8>::type(\n      ::testing::AnyOf(m1, m2, m3, m4),\n      ::testing::AnyOf(m5, m6, m7, m8));\n}\n\ntemplate <typename M1, typename M2, typename M3, typename M4, typename M5,\n    typename M6, typename M7, typename M8, typename M9>\ninline typename internal::AnyOfResult9<M1, M2, M3, M4, M5, M6, M7, M8, M9>::type\nAnyOf(M1 m1, M2 m2, M3 m3, M4 m4, M5 m5, M6 m6, M7 m7, M8 m8, M9 m9) {\n  return typename internal::AnyOfResult9<M1, M2, M3, M4, M5, M6, M7, M8,\n      M9>::type(\n      ::testing::AnyOf(m1, m2, m3, m4),\n      ::testing::AnyOf(m5, m6, m7, m8, m9));\n}\n\ntemplate <typename M1, typename M2, typename M3, typename M4, typename M5,\n    typename M6, typename M7, typename M8, typename M9, typename M10>\ninline typename internal::AnyOfResult10<M1, M2, M3, M4, M5, M6, M7, M8, M9,\n    M10>::type\nAnyOf(M1 m1, M2 m2, M3 m3, M4 m4, M5 m5, M6 m6, M7 m7, M8 m8, M9 m9, M10 m10) {\n  return typename internal::AnyOfResult10<M1, M2, M3, M4, M5, M6, M7, M8, M9,\n      M10>::type(\n      ::testing::AnyOf(m1, m2, m3, m4, m5),\n      ::testing::AnyOf(m6, m7, m8, m9, m10));\n}\n\n}  // namespace testing\n\n\n// The MATCHER* family of macros can be used in a namespace scope to\n// define custom matchers easily.\n//\n// Basic Usage\n// ===========\n//\n// The syntax\n//\n//   MATCHER(name, description_string) { statements; }\n//\n// defines a matcher with the given name that executes the statements,\n// which must return a bool to indicate if the match succeeds.  Inside\n// the statements, you can refer to the value being matched by 'arg',\n// and refer to its type by 'arg_type'.\n//\n// The description string documents what the matcher does, and is used\n// to generate the failure message when the match fails.  Since a\n// MATCHER() is usually defined in a header file shared by multiple\n// C++ source files, we require the description to be a C-string\n// literal to avoid possible side effects.  It can be empty, in which\n// case we'll use the sequence of words in the matcher name as the\n// description.\n//\n// For example:\n//\n//   MATCHER(IsEven, \"\") { return (arg % 2) == 0; }\n//\n// allows you to write\n//\n//   // Expects mock_foo.Bar(n) to be called where n is even.\n//   EXPECT_CALL(mock_foo, Bar(IsEven()));\n//\n// or,\n//\n//   // Verifies that the value of some_expression is even.\n//   EXPECT_THAT(some_expression, IsEven());\n//\n// If the above assertion fails, it will print something like:\n//\n//   Value of: some_expression\n//   Expected: is even\n//     Actual: 7\n//\n// where the description \"is even\" is automatically calculated from the\n// matcher name IsEven.\n//\n// Argument Type\n// =============\n//\n// Note that the type of the value being matched (arg_type) is\n// determined by the context in which you use the matcher and is\n// supplied to you by the compiler, so you don't need to worry about\n// declaring it (nor can you).  This allows the matcher to be\n// polymorphic.  For example, IsEven() can be used to match any type\n// where the value of \"(arg % 2) == 0\" can be implicitly converted to\n// a bool.  In the \"Bar(IsEven())\" example above, if method Bar()\n// takes an int, 'arg_type' will be int; if it takes an unsigned long,\n// 'arg_type' will be unsigned long; and so on.\n//\n// Parameterizing Matchers\n// =======================\n//\n// Sometimes you'll want to parameterize the matcher.  For that you\n// can use another macro:\n//\n//   MATCHER_P(name, param_name, description_string) { statements; }\n//\n// For example:\n//\n//   MATCHER_P(HasAbsoluteValue, value, \"\") { return abs(arg) == value; }\n//\n// will allow you to write:\n//\n//   EXPECT_THAT(Blah(\"a\"), HasAbsoluteValue(n));\n//\n// which may lead to this message (assuming n is 10):\n//\n//   Value of: Blah(\"a\")\n//   Expected: has absolute value 10\n//     Actual: -9\n//\n// Note that both the matcher description and its parameter are\n// printed, making the message human-friendly.\n//\n// In the matcher definition body, you can write 'foo_type' to\n// reference the type of a parameter named 'foo'.  For example, in the\n// body of MATCHER_P(HasAbsoluteValue, value) above, you can write\n// 'value_type' to refer to the type of 'value'.\n//\n// We also provide MATCHER_P2, MATCHER_P3, ..., up to MATCHER_P10 to\n// support multi-parameter matchers.\n//\n// Describing Parameterized Matchers\n// =================================\n//\n// The last argument to MATCHER*() is a string-typed expression.  The\n// expression can reference all of the matcher's parameters and a\n// special bool-typed variable named 'negation'.  When 'negation' is\n// false, the expression should evaluate to the matcher's description;\n// otherwise it should evaluate to the description of the negation of\n// the matcher.  For example,\n//\n//   using testing::PrintToString;\n//\n//   MATCHER_P2(InClosedRange, low, hi,\n//       string(negation ? \"is not\" : \"is\") + \" in range [\" +\n//       PrintToString(low) + \", \" + PrintToString(hi) + \"]\") {\n//     return low <= arg && arg <= hi;\n//   }\n//   ...\n//   EXPECT_THAT(3, InClosedRange(4, 6));\n//   EXPECT_THAT(3, Not(InClosedRange(2, 4)));\n//\n// would generate two failures that contain the text:\n//\n//   Expected: is in range [4, 6]\n//   ...\n//   Expected: is not in range [2, 4]\n//\n// If you specify \"\" as the description, the failure message will\n// contain the sequence of words in the matcher name followed by the\n// parameter values printed as a tuple.  For example,\n//\n//   MATCHER_P2(InClosedRange, low, hi, \"\") { ... }\n//   ...\n//   EXPECT_THAT(3, InClosedRange(4, 6));\n//   EXPECT_THAT(3, Not(InClosedRange(2, 4)));\n//\n// would generate two failures that contain the text:\n//\n//   Expected: in closed range (4, 6)\n//   ...\n//   Expected: not (in closed range (2, 4))\n//\n// Types of Matcher Parameters\n// ===========================\n//\n// For the purpose of typing, you can view\n//\n//   MATCHER_Pk(Foo, p1, ..., pk, description_string) { ... }\n//\n// as shorthand for\n//\n//   template <typename p1_type, ..., typename pk_type>\n//   FooMatcherPk<p1_type, ..., pk_type>\n//   Foo(p1_type p1, ..., pk_type pk) { ... }\n//\n// When you write Foo(v1, ..., vk), the compiler infers the types of\n// the parameters v1, ..., and vk for you.  If you are not happy with\n// the result of the type inference, you can specify the types by\n// explicitly instantiating the template, as in Foo<long, bool>(5,\n// false).  As said earlier, you don't get to (or need to) specify\n// 'arg_type' as that's determined by the context in which the matcher\n// is used.  You can assign the result of expression Foo(p1, ..., pk)\n// to a variable of type FooMatcherPk<p1_type, ..., pk_type>.  This\n// can be useful when composing matchers.\n//\n// While you can instantiate a matcher template with reference types,\n// passing the parameters by pointer usually makes your code more\n// readable.  If, however, you still want to pass a parameter by\n// reference, be aware that in the failure message generated by the\n// matcher you will see the value of the referenced object but not its\n// address.\n//\n// Explaining Match Results\n// ========================\n//\n// Sometimes the matcher description alone isn't enough to explain why\n// the match has failed or succeeded.  For example, when expecting a\n// long string, it can be very helpful to also print the diff between\n// the expected string and the actual one.  To achieve that, you can\n// optionally stream additional information to a special variable\n// named result_listener, whose type is a pointer to class\n// MatchResultListener:\n//\n//   MATCHER_P(EqualsLongString, str, \"\") {\n//     if (arg == str) return true;\n//\n//     *result_listener << \"the difference: \"\n///                     << DiffStrings(str, arg);\n//     return false;\n//   }\n//\n// Overloading Matchers\n// ====================\n//\n// You can overload matchers with different numbers of parameters:\n//\n//   MATCHER_P(Blah, a, description_string1) { ... }\n//   MATCHER_P2(Blah, a, b, description_string2) { ... }\n//\n// Caveats\n// =======\n//\n// When defining a new matcher, you should also consider implementing\n// MatcherInterface or using MakePolymorphicMatcher().  These\n// approaches require more work than the MATCHER* macros, but also\n// give you more control on the types of the value being matched and\n// the matcher parameters, which may leads to better compiler error\n// messages when the matcher is used wrong.  They also allow\n// overloading matchers based on parameter types (as opposed to just\n// based on the number of parameters).\n//\n// MATCHER*() can only be used in a namespace scope.  The reason is\n// that C++ doesn't yet allow function-local types to be used to\n// instantiate templates.  The up-coming C++0x standard will fix this.\n// Once that's done, we'll consider supporting using MATCHER*() inside\n// a function.\n//\n// More Information\n// ================\n//\n// To learn more about using these macros, please search for 'MATCHER'\n// on http://code.google.com/p/googlemock/wiki/CookBook.\n\n#define MATCHER(name, description)\\\n  class name##Matcher {\\\n   public:\\\n    template <typename arg_type>\\\n    class gmock_Impl : public ::testing::MatcherInterface<arg_type> {\\\n     public:\\\n      gmock_Impl()\\\n           {}\\\n      virtual bool MatchAndExplain(\\\n          arg_type arg, ::testing::MatchResultListener* result_listener) const;\\\n      virtual void DescribeTo(::std::ostream* gmock_os) const {\\\n        *gmock_os << FormatDescription(false);\\\n      }\\\n      virtual void DescribeNegationTo(::std::ostream* gmock_os) const {\\\n        *gmock_os << FormatDescription(true);\\\n      }\\\n     private:\\\n      ::testing::internal::string FormatDescription(bool negation) const {\\\n        const ::testing::internal::string gmock_description = (description);\\\n        if (!gmock_description.empty())\\\n          return gmock_description;\\\n        return ::testing::internal::FormatMatcherDescription(\\\n            negation, #name, \\\n            ::testing::internal::UniversalTersePrintTupleFieldsToStrings(\\\n                ::testing::tuple<>()));\\\n      }\\\n      GTEST_DISALLOW_ASSIGN_(gmock_Impl);\\\n    };\\\n    template <typename arg_type>\\\n    operator ::testing::Matcher<arg_type>() const {\\\n      return ::testing::Matcher<arg_type>(\\\n          new gmock_Impl<arg_type>());\\\n    }\\\n    name##Matcher() {\\\n    }\\\n   private:\\\n    GTEST_DISALLOW_ASSIGN_(name##Matcher);\\\n  };\\\n  inline name##Matcher name() {\\\n    return name##Matcher();\\\n  }\\\n  template <typename arg_type>\\\n  bool name##Matcher::gmock_Impl<arg_type>::MatchAndExplain(\\\n      arg_type arg, \\\n      ::testing::MatchResultListener* result_listener GTEST_ATTRIBUTE_UNUSED_)\\\n          const\n\n#define MATCHER_P(name, p0, description)\\\n  template <typename p0##_type>\\\n  class name##MatcherP {\\\n   public:\\\n    template <typename arg_type>\\\n    class gmock_Impl : public ::testing::MatcherInterface<arg_type> {\\\n     public:\\\n      explicit gmock_Impl(p0##_type gmock_p0)\\\n           : p0(gmock_p0) {}\\\n      virtual bool MatchAndExplain(\\\n          arg_type arg, ::testing::MatchResultListener* result_listener) const;\\\n      virtual void DescribeTo(::std::ostream* gmock_os) const {\\\n        *gmock_os << FormatDescription(false);\\\n      }\\\n      virtual void DescribeNegationTo(::std::ostream* gmock_os) const {\\\n        *gmock_os << FormatDescription(true);\\\n      }\\\n      p0##_type p0;\\\n     private:\\\n      ::testing::internal::string FormatDescription(bool negation) const {\\\n        const ::testing::internal::string gmock_description = (description);\\\n        if (!gmock_description.empty())\\\n          return gmock_description;\\\n        return ::testing::internal::FormatMatcherDescription(\\\n            negation, #name, \\\n            ::testing::internal::UniversalTersePrintTupleFieldsToStrings(\\\n                ::testing::tuple<p0##_type>(p0)));\\\n      }\\\n      GTEST_DISALLOW_ASSIGN_(gmock_Impl);\\\n    };\\\n    template <typename arg_type>\\\n    operator ::testing::Matcher<arg_type>() const {\\\n      return ::testing::Matcher<arg_type>(\\\n          new gmock_Impl<arg_type>(p0));\\\n    }\\\n    explicit name##MatcherP(p0##_type gmock_p0) : p0(gmock_p0) {\\\n    }\\\n    p0##_type p0;\\\n   private:\\\n    GTEST_DISALLOW_ASSIGN_(name##MatcherP);\\\n  };\\\n  template <typename p0##_type>\\\n  inline name##MatcherP<p0##_type> name(p0##_type p0) {\\\n    return name##MatcherP<p0##_type>(p0);\\\n  }\\\n  template <typename p0##_type>\\\n  template <typename arg_type>\\\n  bool name##MatcherP<p0##_type>::gmock_Impl<arg_type>::MatchAndExplain(\\\n      arg_type arg, \\\n      ::testing::MatchResultListener* result_listener GTEST_ATTRIBUTE_UNUSED_)\\\n          const\n\n#define MATCHER_P2(name, p0, p1, description)\\\n  template <typename p0##_type, typename p1##_type>\\\n  class name##MatcherP2 {\\\n   public:\\\n    template <typename arg_type>\\\n    class gmock_Impl : public ::testing::MatcherInterface<arg_type> {\\\n     public:\\\n      gmock_Impl(p0##_type gmock_p0, p1##_type gmock_p1)\\\n           : p0(gmock_p0), p1(gmock_p1) {}\\\n      virtual bool MatchAndExplain(\\\n          arg_type arg, ::testing::MatchResultListener* result_listener) const;\\\n      virtual void DescribeTo(::std::ostream* gmock_os) const {\\\n        *gmock_os << FormatDescription(false);\\\n      }\\\n      virtual void DescribeNegationTo(::std::ostream* gmock_os) const {\\\n        *gmock_os << FormatDescription(true);\\\n      }\\\n      p0##_type p0;\\\n      p1##_type p1;\\\n     private:\\\n      ::testing::internal::string FormatDescription(bool negation) const {\\\n        const ::testing::internal::string gmock_description = (description);\\\n        if (!gmock_description.empty())\\\n          return gmock_description;\\\n        return ::testing::internal::FormatMatcherDescription(\\\n            negation, #name, \\\n            ::testing::internal::UniversalTersePrintTupleFieldsToStrings(\\\n                ::testing::tuple<p0##_type, p1##_type>(p0, p1)));\\\n      }\\\n      GTEST_DISALLOW_ASSIGN_(gmock_Impl);\\\n    };\\\n    template <typename arg_type>\\\n    operator ::testing::Matcher<arg_type>() const {\\\n      return ::testing::Matcher<arg_type>(\\\n          new gmock_Impl<arg_type>(p0, p1));\\\n    }\\\n    name##MatcherP2(p0##_type gmock_p0, p1##_type gmock_p1) : p0(gmock_p0), \\\n        p1(gmock_p1) {\\\n    }\\\n    p0##_type p0;\\\n    p1##_type p1;\\\n   private:\\\n    GTEST_DISALLOW_ASSIGN_(name##MatcherP2);\\\n  };\\\n  template <typename p0##_type, typename p1##_type>\\\n  inline name##MatcherP2<p0##_type, p1##_type> name(p0##_type p0, \\\n      p1##_type p1) {\\\n    return name##MatcherP2<p0##_type, p1##_type>(p0, p1);\\\n  }\\\n  template <typename p0##_type, typename p1##_type>\\\n  template <typename arg_type>\\\n  bool name##MatcherP2<p0##_type, \\\n      p1##_type>::gmock_Impl<arg_type>::MatchAndExplain(\\\n      arg_type arg, \\\n      ::testing::MatchResultListener* result_listener GTEST_ATTRIBUTE_UNUSED_)\\\n          const\n\n#define MATCHER_P3(name, p0, p1, p2, description)\\\n  template <typename p0##_type, typename p1##_type, typename p2##_type>\\\n  class name##MatcherP3 {\\\n   public:\\\n    template <typename arg_type>\\\n    class gmock_Impl : public ::testing::MatcherInterface<arg_type> {\\\n     public:\\\n      gmock_Impl(p0##_type gmock_p0, p1##_type gmock_p1, p2##_type gmock_p2)\\\n           : p0(gmock_p0), p1(gmock_p1), p2(gmock_p2) {}\\\n      virtual bool MatchAndExplain(\\\n          arg_type arg, ::testing::MatchResultListener* result_listener) const;\\\n      virtual void DescribeTo(::std::ostream* gmock_os) const {\\\n        *gmock_os << FormatDescription(false);\\\n      }\\\n      virtual void DescribeNegationTo(::std::ostream* gmock_os) const {\\\n        *gmock_os << FormatDescription(true);\\\n      }\\\n      p0##_type p0;\\\n      p1##_type p1;\\\n      p2##_type p2;\\\n     private:\\\n      ::testing::internal::string FormatDescription(bool negation) const {\\\n        const ::testing::internal::string gmock_description = (description);\\\n        if (!gmock_description.empty())\\\n          return gmock_description;\\\n        return ::testing::internal::FormatMatcherDescription(\\\n            negation, #name, \\\n            ::testing::internal::UniversalTersePrintTupleFieldsToStrings(\\\n                ::testing::tuple<p0##_type, p1##_type, p2##_type>(p0, p1, \\\n                    p2)));\\\n      }\\\n      GTEST_DISALLOW_ASSIGN_(gmock_Impl);\\\n    };\\\n    template <typename arg_type>\\\n    operator ::testing::Matcher<arg_type>() const {\\\n      return ::testing::Matcher<arg_type>(\\\n          new gmock_Impl<arg_type>(p0, p1, p2));\\\n    }\\\n    name##MatcherP3(p0##_type gmock_p0, p1##_type gmock_p1, \\\n        p2##_type gmock_p2) : p0(gmock_p0), p1(gmock_p1), p2(gmock_p2) {\\\n    }\\\n    p0##_type p0;\\\n    p1##_type p1;\\\n    p2##_type p2;\\\n   private:\\\n    GTEST_DISALLOW_ASSIGN_(name##MatcherP3);\\\n  };\\\n  template <typename p0##_type, typename p1##_type, typename p2##_type>\\\n  inline name##MatcherP3<p0##_type, p1##_type, p2##_type> name(p0##_type p0, \\\n      p1##_type p1, p2##_type p2) {\\\n    return name##MatcherP3<p0##_type, p1##_type, p2##_type>(p0, p1, p2);\\\n  }\\\n  template <typename p0##_type, typename p1##_type, typename p2##_type>\\\n  template <typename arg_type>\\\n  bool name##MatcherP3<p0##_type, p1##_type, \\\n      p2##_type>::gmock_Impl<arg_type>::MatchAndExplain(\\\n      arg_type arg, \\\n      ::testing::MatchResultListener* result_listener GTEST_ATTRIBUTE_UNUSED_)\\\n          const\n\n#define MATCHER_P4(name, p0, p1, p2, p3, description)\\\n  template <typename p0##_type, typename p1##_type, typename p2##_type, \\\n      typename p3##_type>\\\n  class name##MatcherP4 {\\\n   public:\\\n    template <typename arg_type>\\\n    class gmock_Impl : public ::testing::MatcherInterface<arg_type> {\\\n     public:\\\n      gmock_Impl(p0##_type gmock_p0, p1##_type gmock_p1, p2##_type gmock_p2, \\\n          p3##_type gmock_p3)\\\n           : p0(gmock_p0), p1(gmock_p1), p2(gmock_p2), p3(gmock_p3) {}\\\n      virtual bool MatchAndExplain(\\\n          arg_type arg, ::testing::MatchResultListener* result_listener) const;\\\n      virtual void DescribeTo(::std::ostream* gmock_os) const {\\\n        *gmock_os << FormatDescription(false);\\\n      }\\\n      virtual void DescribeNegationTo(::std::ostream* gmock_os) const {\\\n        *gmock_os << FormatDescription(true);\\\n      }\\\n      p0##_type p0;\\\n      p1##_type p1;\\\n      p2##_type p2;\\\n      p3##_type p3;\\\n     private:\\\n      ::testing::internal::string FormatDescription(bool negation) const {\\\n        const ::testing::internal::string gmock_description = (description);\\\n        if (!gmock_description.empty())\\\n          return gmock_description;\\\n        return ::testing::internal::FormatMatcherDescription(\\\n            negation, #name, \\\n            ::testing::internal::UniversalTersePrintTupleFieldsToStrings(\\\n                ::testing::tuple<p0##_type, p1##_type, p2##_type, \\\n                    p3##_type>(p0, p1, p2, p3)));\\\n      }\\\n      GTEST_DISALLOW_ASSIGN_(gmock_Impl);\\\n    };\\\n    template <typename arg_type>\\\n    operator ::testing::Matcher<arg_type>() const {\\\n      return ::testing::Matcher<arg_type>(\\\n          new gmock_Impl<arg_type>(p0, p1, p2, p3));\\\n    }\\\n    name##MatcherP4(p0##_type gmock_p0, p1##_type gmock_p1, \\\n        p2##_type gmock_p2, p3##_type gmock_p3) : p0(gmock_p0), p1(gmock_p1), \\\n        p2(gmock_p2), p3(gmock_p3) {\\\n    }\\\n    p0##_type p0;\\\n    p1##_type p1;\\\n    p2##_type p2;\\\n    p3##_type p3;\\\n   private:\\\n    GTEST_DISALLOW_ASSIGN_(name##MatcherP4);\\\n  };\\\n  template <typename p0##_type, typename p1##_type, typename p2##_type, \\\n      typename p3##_type>\\\n  inline name##MatcherP4<p0##_type, p1##_type, p2##_type, \\\n      p3##_type> name(p0##_type p0, p1##_type p1, p2##_type p2, \\\n      p3##_type p3) {\\\n    return name##MatcherP4<p0##_type, p1##_type, p2##_type, p3##_type>(p0, \\\n        p1, p2, p3);\\\n  }\\\n  template <typename p0##_type, typename p1##_type, typename p2##_type, \\\n      typename p3##_type>\\\n  template <typename arg_type>\\\n  bool name##MatcherP4<p0##_type, p1##_type, p2##_type, \\\n      p3##_type>::gmock_Impl<arg_type>::MatchAndExplain(\\\n      arg_type arg, \\\n      ::testing::MatchResultListener* result_listener GTEST_ATTRIBUTE_UNUSED_)\\\n          const\n\n#define MATCHER_P5(name, p0, p1, p2, p3, p4, description)\\\n  template <typename p0##_type, typename p1##_type, typename p2##_type, \\\n      typename p3##_type, typename p4##_type>\\\n  class name##MatcherP5 {\\\n   public:\\\n    template <typename arg_type>\\\n    class gmock_Impl : public ::testing::MatcherInterface<arg_type> {\\\n     public:\\\n      gmock_Impl(p0##_type gmock_p0, p1##_type gmock_p1, p2##_type gmock_p2, \\\n          p3##_type gmock_p3, p4##_type gmock_p4)\\\n           : p0(gmock_p0), p1(gmock_p1), p2(gmock_p2), p3(gmock_p3), \\\n               p4(gmock_p4) {}\\\n      virtual bool MatchAndExplain(\\\n          arg_type arg, ::testing::MatchResultListener* result_listener) const;\\\n      virtual void DescribeTo(::std::ostream* gmock_os) const {\\\n        *gmock_os << FormatDescription(false);\\\n      }\\\n      virtual void DescribeNegationTo(::std::ostream* gmock_os) const {\\\n        *gmock_os << FormatDescription(true);\\\n      }\\\n      p0##_type p0;\\\n      p1##_type p1;\\\n      p2##_type p2;\\\n      p3##_type p3;\\\n      p4##_type p4;\\\n     private:\\\n      ::testing::internal::string FormatDescription(bool negation) const {\\\n        const ::testing::internal::string gmock_description = (description);\\\n        if (!gmock_description.empty())\\\n          return gmock_description;\\\n        return ::testing::internal::FormatMatcherDescription(\\\n            negation, #name, \\\n            ::testing::internal::UniversalTersePrintTupleFieldsToStrings(\\\n                ::testing::tuple<p0##_type, p1##_type, p2##_type, p3##_type, \\\n                    p4##_type>(p0, p1, p2, p3, p4)));\\\n      }\\\n      GTEST_DISALLOW_ASSIGN_(gmock_Impl);\\\n    };\\\n    template <typename arg_type>\\\n    operator ::testing::Matcher<arg_type>() const {\\\n      return ::testing::Matcher<arg_type>(\\\n          new gmock_Impl<arg_type>(p0, p1, p2, p3, p4));\\\n    }\\\n    name##MatcherP5(p0##_type gmock_p0, p1##_type gmock_p1, \\\n        p2##_type gmock_p2, p3##_type gmock_p3, \\\n        p4##_type gmock_p4) : p0(gmock_p0), p1(gmock_p1), p2(gmock_p2), \\\n        p3(gmock_p3), p4(gmock_p4) {\\\n    }\\\n    p0##_type p0;\\\n    p1##_type p1;\\\n    p2##_type p2;\\\n    p3##_type p3;\\\n    p4##_type p4;\\\n   private:\\\n    GTEST_DISALLOW_ASSIGN_(name##MatcherP5);\\\n  };\\\n  template <typename p0##_type, typename p1##_type, typename p2##_type, \\\n      typename p3##_type, typename p4##_type>\\\n  inline name##MatcherP5<p0##_type, p1##_type, p2##_type, p3##_type, \\\n      p4##_type> name(p0##_type p0, p1##_type p1, p2##_type p2, p3##_type p3, \\\n      p4##_type p4) {\\\n    return name##MatcherP5<p0##_type, p1##_type, p2##_type, p3##_type, \\\n        p4##_type>(p0, p1, p2, p3, p4);\\\n  }\\\n  template <typename p0##_type, typename p1##_type, typename p2##_type, \\\n      typename p3##_type, typename p4##_type>\\\n  template <typename arg_type>\\\n  bool name##MatcherP5<p0##_type, p1##_type, p2##_type, p3##_type, \\\n      p4##_type>::gmock_Impl<arg_type>::MatchAndExplain(\\\n      arg_type arg, \\\n      ::testing::MatchResultListener* result_listener GTEST_ATTRIBUTE_UNUSED_)\\\n          const\n\n#define MATCHER_P6(name, p0, p1, p2, p3, p4, p5, description)\\\n  template <typename p0##_type, typename p1##_type, typename p2##_type, \\\n      typename p3##_type, typename p4##_type, typename p5##_type>\\\n  class name##MatcherP6 {\\\n   public:\\\n    template <typename arg_type>\\\n    class gmock_Impl : public ::testing::MatcherInterface<arg_type> {\\\n     public:\\\n      gmock_Impl(p0##_type gmock_p0, p1##_type gmock_p1, p2##_type gmock_p2, \\\n          p3##_type gmock_p3, p4##_type gmock_p4, p5##_type gmock_p5)\\\n           : p0(gmock_p0), p1(gmock_p1), p2(gmock_p2), p3(gmock_p3), \\\n               p4(gmock_p4), p5(gmock_p5) {}\\\n      virtual bool MatchAndExplain(\\\n          arg_type arg, ::testing::MatchResultListener* result_listener) const;\\\n      virtual void DescribeTo(::std::ostream* gmock_os) const {\\\n        *gmock_os << FormatDescription(false);\\\n      }\\\n      virtual void DescribeNegationTo(::std::ostream* gmock_os) const {\\\n        *gmock_os << FormatDescription(true);\\\n      }\\\n      p0##_type p0;\\\n      p1##_type p1;\\\n      p2##_type p2;\\\n      p3##_type p3;\\\n      p4##_type p4;\\\n      p5##_type p5;\\\n     private:\\\n      ::testing::internal::string FormatDescription(bool negation) const {\\\n        const ::testing::internal::string gmock_description = (description);\\\n        if (!gmock_description.empty())\\\n          return gmock_description;\\\n        return ::testing::internal::FormatMatcherDescription(\\\n            negation, #name, \\\n            ::testing::internal::UniversalTersePrintTupleFieldsToStrings(\\\n                ::testing::tuple<p0##_type, p1##_type, p2##_type, p3##_type, \\\n                    p4##_type, p5##_type>(p0, p1, p2, p3, p4, p5)));\\\n      }\\\n      GTEST_DISALLOW_ASSIGN_(gmock_Impl);\\\n    };\\\n    template <typename arg_type>\\\n    operator ::testing::Matcher<arg_type>() const {\\\n      return ::testing::Matcher<arg_type>(\\\n          new gmock_Impl<arg_type>(p0, p1, p2, p3, p4, p5));\\\n    }\\\n    name##MatcherP6(p0##_type gmock_p0, p1##_type gmock_p1, \\\n        p2##_type gmock_p2, p3##_type gmock_p3, p4##_type gmock_p4, \\\n        p5##_type gmock_p5) : p0(gmock_p0), p1(gmock_p1), p2(gmock_p2), \\\n        p3(gmock_p3), p4(gmock_p4), p5(gmock_p5) {\\\n    }\\\n    p0##_type p0;\\\n    p1##_type p1;\\\n    p2##_type p2;\\\n    p3##_type p3;\\\n    p4##_type p4;\\\n    p5##_type p5;\\\n   private:\\\n    GTEST_DISALLOW_ASSIGN_(name##MatcherP6);\\\n  };\\\n  template <typename p0##_type, typename p1##_type, typename p2##_type, \\\n      typename p3##_type, typename p4##_type, typename p5##_type>\\\n  inline name##MatcherP6<p0##_type, p1##_type, p2##_type, p3##_type, \\\n      p4##_type, p5##_type> name(p0##_type p0, p1##_type p1, p2##_type p2, \\\n      p3##_type p3, p4##_type p4, p5##_type p5) {\\\n    return name##MatcherP6<p0##_type, p1##_type, p2##_type, p3##_type, \\\n        p4##_type, p5##_type>(p0, p1, p2, p3, p4, p5);\\\n  }\\\n  template <typename p0##_type, typename p1##_type, typename p2##_type, \\\n      typename p3##_type, typename p4##_type, typename p5##_type>\\\n  template <typename arg_type>\\\n  bool name##MatcherP6<p0##_type, p1##_type, p2##_type, p3##_type, p4##_type, \\\n      p5##_type>::gmock_Impl<arg_type>::MatchAndExplain(\\\n      arg_type arg, \\\n      ::testing::MatchResultListener* result_listener GTEST_ATTRIBUTE_UNUSED_)\\\n          const\n\n#define MATCHER_P7(name, p0, p1, p2, p3, p4, p5, p6, description)\\\n  template <typename p0##_type, typename p1##_type, typename p2##_type, \\\n      typename p3##_type, typename p4##_type, typename p5##_type, \\\n      typename p6##_type>\\\n  class name##MatcherP7 {\\\n   public:\\\n    template <typename arg_type>\\\n    class gmock_Impl : public ::testing::MatcherInterface<arg_type> {\\\n     public:\\\n      gmock_Impl(p0##_type gmock_p0, p1##_type gmock_p1, p2##_type gmock_p2, \\\n          p3##_type gmock_p3, p4##_type gmock_p4, p5##_type gmock_p5, \\\n          p6##_type gmock_p6)\\\n           : p0(gmock_p0), p1(gmock_p1), p2(gmock_p2), p3(gmock_p3), \\\n               p4(gmock_p4), p5(gmock_p5), p6(gmock_p6) {}\\\n      virtual bool MatchAndExplain(\\\n          arg_type arg, ::testing::MatchResultListener* result_listener) const;\\\n      virtual void DescribeTo(::std::ostream* gmock_os) const {\\\n        *gmock_os << FormatDescription(false);\\\n      }\\\n      virtual void DescribeNegationTo(::std::ostream* gmock_os) const {\\\n        *gmock_os << FormatDescription(true);\\\n      }\\\n      p0##_type p0;\\\n      p1##_type p1;\\\n      p2##_type p2;\\\n      p3##_type p3;\\\n      p4##_type p4;\\\n      p5##_type p5;\\\n      p6##_type p6;\\\n     private:\\\n      ::testing::internal::string FormatDescription(bool negation) const {\\\n        const ::testing::internal::string gmock_description = (description);\\\n        if (!gmock_description.empty())\\\n          return gmock_description;\\\n        return ::testing::internal::FormatMatcherDescription(\\\n            negation, #name, \\\n            ::testing::internal::UniversalTersePrintTupleFieldsToStrings(\\\n                ::testing::tuple<p0##_type, p1##_type, p2##_type, p3##_type, \\\n                    p4##_type, p5##_type, p6##_type>(p0, p1, p2, p3, p4, p5, \\\n                    p6)));\\\n      }\\\n      GTEST_DISALLOW_ASSIGN_(gmock_Impl);\\\n    };\\\n    template <typename arg_type>\\\n    operator ::testing::Matcher<arg_type>() const {\\\n      return ::testing::Matcher<arg_type>(\\\n          new gmock_Impl<arg_type>(p0, p1, p2, p3, p4, p5, p6));\\\n    }\\\n    name##MatcherP7(p0##_type gmock_p0, p1##_type gmock_p1, \\\n        p2##_type gmock_p2, p3##_type gmock_p3, p4##_type gmock_p4, \\\n        p5##_type gmock_p5, p6##_type gmock_p6) : p0(gmock_p0), p1(gmock_p1), \\\n        p2(gmock_p2), p3(gmock_p3), p4(gmock_p4), p5(gmock_p5), \\\n        p6(gmock_p6) {\\\n    }\\\n    p0##_type p0;\\\n    p1##_type p1;\\\n    p2##_type p2;\\\n    p3##_type p3;\\\n    p4##_type p4;\\\n    p5##_type p5;\\\n    p6##_type p6;\\\n   private:\\\n    GTEST_DISALLOW_ASSIGN_(name##MatcherP7);\\\n  };\\\n  template <typename p0##_type, typename p1##_type, typename p2##_type, \\\n      typename p3##_type, typename p4##_type, typename p5##_type, \\\n      typename p6##_type>\\\n  inline name##MatcherP7<p0##_type, p1##_type, p2##_type, p3##_type, \\\n      p4##_type, p5##_type, p6##_type> name(p0##_type p0, p1##_type p1, \\\n      p2##_type p2, p3##_type p3, p4##_type p4, p5##_type p5, \\\n      p6##_type p6) {\\\n    return name##MatcherP7<p0##_type, p1##_type, p2##_type, p3##_type, \\\n        p4##_type, p5##_type, p6##_type>(p0, p1, p2, p3, p4, p5, p6);\\\n  }\\\n  template <typename p0##_type, typename p1##_type, typename p2##_type, \\\n      typename p3##_type, typename p4##_type, typename p5##_type, \\\n      typename p6##_type>\\\n  template <typename arg_type>\\\n  bool name##MatcherP7<p0##_type, p1##_type, p2##_type, p3##_type, p4##_type, \\\n      p5##_type, p6##_type>::gmock_Impl<arg_type>::MatchAndExplain(\\\n      arg_type arg, \\\n      ::testing::MatchResultListener* result_listener GTEST_ATTRIBUTE_UNUSED_)\\\n          const\n\n#define MATCHER_P8(name, p0, p1, p2, p3, p4, p5, p6, p7, description)\\\n  template <typename p0##_type, typename p1##_type, typename p2##_type, \\\n      typename p3##_type, typename p4##_type, typename p5##_type, \\\n      typename p6##_type, typename p7##_type>\\\n  class name##MatcherP8 {\\\n   public:\\\n    template <typename arg_type>\\\n    class gmock_Impl : public ::testing::MatcherInterface<arg_type> {\\\n     public:\\\n      gmock_Impl(p0##_type gmock_p0, p1##_type gmock_p1, p2##_type gmock_p2, \\\n          p3##_type gmock_p3, p4##_type gmock_p4, p5##_type gmock_p5, \\\n          p6##_type gmock_p6, p7##_type gmock_p7)\\\n           : p0(gmock_p0), p1(gmock_p1), p2(gmock_p2), p3(gmock_p3), \\\n               p4(gmock_p4), p5(gmock_p5), p6(gmock_p6), p7(gmock_p7) {}\\\n      virtual bool MatchAndExplain(\\\n          arg_type arg, ::testing::MatchResultListener* result_listener) const;\\\n      virtual void DescribeTo(::std::ostream* gmock_os) const {\\\n        *gmock_os << FormatDescription(false);\\\n      }\\\n      virtual void DescribeNegationTo(::std::ostream* gmock_os) const {\\\n        *gmock_os << FormatDescription(true);\\\n      }\\\n      p0##_type p0;\\\n      p1##_type p1;\\\n      p2##_type p2;\\\n      p3##_type p3;\\\n      p4##_type p4;\\\n      p5##_type p5;\\\n      p6##_type p6;\\\n      p7##_type p7;\\\n     private:\\\n      ::testing::internal::string FormatDescription(bool negation) const {\\\n        const ::testing::internal::string gmock_description = (description);\\\n        if (!gmock_description.empty())\\\n          return gmock_description;\\\n        return ::testing::internal::FormatMatcherDescription(\\\n            negation, #name, \\\n            ::testing::internal::UniversalTersePrintTupleFieldsToStrings(\\\n                ::testing::tuple<p0##_type, p1##_type, p2##_type, p3##_type, \\\n                    p4##_type, p5##_type, p6##_type, p7##_type>(p0, p1, p2, \\\n                    p3, p4, p5, p6, p7)));\\\n      }\\\n      GTEST_DISALLOW_ASSIGN_(gmock_Impl);\\\n    };\\\n    template <typename arg_type>\\\n    operator ::testing::Matcher<arg_type>() const {\\\n      return ::testing::Matcher<arg_type>(\\\n          new gmock_Impl<arg_type>(p0, p1, p2, p3, p4, p5, p6, p7));\\\n    }\\\n    name##MatcherP8(p0##_type gmock_p0, p1##_type gmock_p1, \\\n        p2##_type gmock_p2, p3##_type gmock_p3, p4##_type gmock_p4, \\\n        p5##_type gmock_p5, p6##_type gmock_p6, \\\n        p7##_type gmock_p7) : p0(gmock_p0), p1(gmock_p1), p2(gmock_p2), \\\n        p3(gmock_p3), p4(gmock_p4), p5(gmock_p5), p6(gmock_p6), \\\n        p7(gmock_p7) {\\\n    }\\\n    p0##_type p0;\\\n    p1##_type p1;\\\n    p2##_type p2;\\\n    p3##_type p3;\\\n    p4##_type p4;\\\n    p5##_type p5;\\\n    p6##_type p6;\\\n    p7##_type p7;\\\n   private:\\\n    GTEST_DISALLOW_ASSIGN_(name##MatcherP8);\\\n  };\\\n  template <typename p0##_type, typename p1##_type, typename p2##_type, \\\n      typename p3##_type, typename p4##_type, typename p5##_type, \\\n      typename p6##_type, typename p7##_type>\\\n  inline name##MatcherP8<p0##_type, p1##_type, p2##_type, p3##_type, \\\n      p4##_type, p5##_type, p6##_type, p7##_type> name(p0##_type p0, \\\n      p1##_type p1, p2##_type p2, p3##_type p3, p4##_type p4, p5##_type p5, \\\n      p6##_type p6, p7##_type p7) {\\\n    return name##MatcherP8<p0##_type, p1##_type, p2##_type, p3##_type, \\\n        p4##_type, p5##_type, p6##_type, p7##_type>(p0, p1, p2, p3, p4, p5, \\\n        p6, p7);\\\n  }\\\n  template <typename p0##_type, typename p1##_type, typename p2##_type, \\\n      typename p3##_type, typename p4##_type, typename p5##_type, \\\n      typename p6##_type, typename p7##_type>\\\n  template <typename arg_type>\\\n  bool name##MatcherP8<p0##_type, p1##_type, p2##_type, p3##_type, p4##_type, \\\n      p5##_type, p6##_type, \\\n      p7##_type>::gmock_Impl<arg_type>::MatchAndExplain(\\\n      arg_type arg, \\\n      ::testing::MatchResultListener* result_listener GTEST_ATTRIBUTE_UNUSED_)\\\n          const\n\n#define MATCHER_P9(name, p0, p1, p2, p3, p4, p5, p6, p7, p8, description)\\\n  template <typename p0##_type, typename p1##_type, typename p2##_type, \\\n      typename p3##_type, typename p4##_type, typename p5##_type, \\\n      typename p6##_type, typename p7##_type, typename p8##_type>\\\n  class name##MatcherP9 {\\\n   public:\\\n    template <typename arg_type>\\\n    class gmock_Impl : public ::testing::MatcherInterface<arg_type> {\\\n     public:\\\n      gmock_Impl(p0##_type gmock_p0, p1##_type gmock_p1, p2##_type gmock_p2, \\\n          p3##_type gmock_p3, p4##_type gmock_p4, p5##_type gmock_p5, \\\n          p6##_type gmock_p6, p7##_type gmock_p7, p8##_type gmock_p8)\\\n           : p0(gmock_p0), p1(gmock_p1), p2(gmock_p2), p3(gmock_p3), \\\n               p4(gmock_p4), p5(gmock_p5), p6(gmock_p6), p7(gmock_p7), \\\n               p8(gmock_p8) {}\\\n      virtual bool MatchAndExplain(\\\n          arg_type arg, ::testing::MatchResultListener* result_listener) const;\\\n      virtual void DescribeTo(::std::ostream* gmock_os) const {\\\n        *gmock_os << FormatDescription(false);\\\n      }\\\n      virtual void DescribeNegationTo(::std::ostream* gmock_os) const {\\\n        *gmock_os << FormatDescription(true);\\\n      }\\\n      p0##_type p0;\\\n      p1##_type p1;\\\n      p2##_type p2;\\\n      p3##_type p3;\\\n      p4##_type p4;\\\n      p5##_type p5;\\\n      p6##_type p6;\\\n      p7##_type p7;\\\n      p8##_type p8;\\\n     private:\\\n      ::testing::internal::string FormatDescription(bool negation) const {\\\n        const ::testing::internal::string gmock_description = (description);\\\n        if (!gmock_description.empty())\\\n          return gmock_description;\\\n        return ::testing::internal::FormatMatcherDescription(\\\n            negation, #name, \\\n            ::testing::internal::UniversalTersePrintTupleFieldsToStrings(\\\n                ::testing::tuple<p0##_type, p1##_type, p2##_type, p3##_type, \\\n                    p4##_type, p5##_type, p6##_type, p7##_type, \\\n                    p8##_type>(p0, p1, p2, p3, p4, p5, p6, p7, p8)));\\\n      }\\\n      GTEST_DISALLOW_ASSIGN_(gmock_Impl);\\\n    };\\\n    template <typename arg_type>\\\n    operator ::testing::Matcher<arg_type>() const {\\\n      return ::testing::Matcher<arg_type>(\\\n          new gmock_Impl<arg_type>(p0, p1, p2, p3, p4, p5, p6, p7, p8));\\\n    }\\\n    name##MatcherP9(p0##_type gmock_p0, p1##_type gmock_p1, \\\n        p2##_type gmock_p2, p3##_type gmock_p3, p4##_type gmock_p4, \\\n        p5##_type gmock_p5, p6##_type gmock_p6, p7##_type gmock_p7, \\\n        p8##_type gmock_p8) : p0(gmock_p0), p1(gmock_p1), p2(gmock_p2), \\\n        p3(gmock_p3), p4(gmock_p4), p5(gmock_p5), p6(gmock_p6), p7(gmock_p7), \\\n        p8(gmock_p8) {\\\n    }\\\n    p0##_type p0;\\\n    p1##_type p1;\\\n    p2##_type p2;\\\n    p3##_type p3;\\\n    p4##_type p4;\\\n    p5##_type p5;\\\n    p6##_type p6;\\\n    p7##_type p7;\\\n    p8##_type p8;\\\n   private:\\\n    GTEST_DISALLOW_ASSIGN_(name##MatcherP9);\\\n  };\\\n  template <typename p0##_type, typename p1##_type, typename p2##_type, \\\n      typename p3##_type, typename p4##_type, typename p5##_type, \\\n      typename p6##_type, typename p7##_type, typename p8##_type>\\\n  inline name##MatcherP9<p0##_type, p1##_type, p2##_type, p3##_type, \\\n      p4##_type, p5##_type, p6##_type, p7##_type, \\\n      p8##_type> name(p0##_type p0, p1##_type p1, p2##_type p2, p3##_type p3, \\\n      p4##_type p4, p5##_type p5, p6##_type p6, p7##_type p7, \\\n      p8##_type p8) {\\\n    return name##MatcherP9<p0##_type, p1##_type, p2##_type, p3##_type, \\\n        p4##_type, p5##_type, p6##_type, p7##_type, p8##_type>(p0, p1, p2, \\\n        p3, p4, p5, p6, p7, p8);\\\n  }\\\n  template <typename p0##_type, typename p1##_type, typename p2##_type, \\\n      typename p3##_type, typename p4##_type, typename p5##_type, \\\n      typename p6##_type, typename p7##_type, typename p8##_type>\\\n  template <typename arg_type>\\\n  bool name##MatcherP9<p0##_type, p1##_type, p2##_type, p3##_type, p4##_type, \\\n      p5##_type, p6##_type, p7##_type, \\\n      p8##_type>::gmock_Impl<arg_type>::MatchAndExplain(\\\n      arg_type arg, \\\n      ::testing::MatchResultListener* result_listener GTEST_ATTRIBUTE_UNUSED_)\\\n          const\n\n#define MATCHER_P10(name, p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, description)\\\n  template <typename p0##_type, typename p1##_type, typename p2##_type, \\\n      typename p3##_type, typename p4##_type, typename p5##_type, \\\n      typename p6##_type, typename p7##_type, typename p8##_type, \\\n      typename p9##_type>\\\n  class name##MatcherP10 {\\\n   public:\\\n    template <typename arg_type>\\\n    class gmock_Impl : public ::testing::MatcherInterface<arg_type> {\\\n     public:\\\n      gmock_Impl(p0##_type gmock_p0, p1##_type gmock_p1, p2##_type gmock_p2, \\\n          p3##_type gmock_p3, p4##_type gmock_p4, p5##_type gmock_p5, \\\n          p6##_type gmock_p6, p7##_type gmock_p7, p8##_type gmock_p8, \\\n          p9##_type gmock_p9)\\\n           : p0(gmock_p0), p1(gmock_p1), p2(gmock_p2), p3(gmock_p3), \\\n               p4(gmock_p4), p5(gmock_p5), p6(gmock_p6), p7(gmock_p7), \\\n               p8(gmock_p8), p9(gmock_p9) {}\\\n      virtual bool MatchAndExplain(\\\n          arg_type arg, ::testing::MatchResultListener* result_listener) const;\\\n      virtual void DescribeTo(::std::ostream* gmock_os) const {\\\n        *gmock_os << FormatDescription(false);\\\n      }\\\n      virtual void DescribeNegationTo(::std::ostream* gmock_os) const {\\\n        *gmock_os << FormatDescription(true);\\\n      }\\\n      p0##_type p0;\\\n      p1##_type p1;\\\n      p2##_type p2;\\\n      p3##_type p3;\\\n      p4##_type p4;\\\n      p5##_type p5;\\\n      p6##_type p6;\\\n      p7##_type p7;\\\n      p8##_type p8;\\\n      p9##_type p9;\\\n     private:\\\n      ::testing::internal::string FormatDescription(bool negation) const {\\\n        const ::testing::internal::string gmock_description = (description);\\\n        if (!gmock_description.empty())\\\n          return gmock_description;\\\n        return ::testing::internal::FormatMatcherDescription(\\\n            negation, #name, \\\n            ::testing::internal::UniversalTersePrintTupleFieldsToStrings(\\\n                ::testing::tuple<p0##_type, p1##_type, p2##_type, p3##_type, \\\n                    p4##_type, p5##_type, p6##_type, p7##_type, p8##_type, \\\n                    p9##_type>(p0, p1, p2, p3, p4, p5, p6, p7, p8, p9)));\\\n      }\\\n      GTEST_DISALLOW_ASSIGN_(gmock_Impl);\\\n    };\\\n    template <typename arg_type>\\\n    operator ::testing::Matcher<arg_type>() const {\\\n      return ::testing::Matcher<arg_type>(\\\n          new gmock_Impl<arg_type>(p0, p1, p2, p3, p4, p5, p6, p7, p8, p9));\\\n    }\\\n    name##MatcherP10(p0##_type gmock_p0, p1##_type gmock_p1, \\\n        p2##_type gmock_p2, p3##_type gmock_p3, p4##_type gmock_p4, \\\n        p5##_type gmock_p5, p6##_type gmock_p6, p7##_type gmock_p7, \\\n        p8##_type gmock_p8, p9##_type gmock_p9) : p0(gmock_p0), p1(gmock_p1), \\\n        p2(gmock_p2), p3(gmock_p3), p4(gmock_p4), p5(gmock_p5), p6(gmock_p6), \\\n        p7(gmock_p7), p8(gmock_p8), p9(gmock_p9) {\\\n    }\\\n    p0##_type p0;\\\n    p1##_type p1;\\\n    p2##_type p2;\\\n    p3##_type p3;\\\n    p4##_type p4;\\\n    p5##_type p5;\\\n    p6##_type p6;\\\n    p7##_type p7;\\\n    p8##_type p8;\\\n    p9##_type p9;\\\n   private:\\\n    GTEST_DISALLOW_ASSIGN_(name##MatcherP10);\\\n  };\\\n  template <typename p0##_type, typename p1##_type, typename p2##_type, \\\n      typename p3##_type, typename p4##_type, typename p5##_type, \\\n      typename p6##_type, typename p7##_type, typename p8##_type, \\\n      typename p9##_type>\\\n  inline name##MatcherP10<p0##_type, p1##_type, p2##_type, p3##_type, \\\n      p4##_type, p5##_type, p6##_type, p7##_type, p8##_type, \\\n      p9##_type> name(p0##_type p0, p1##_type p1, p2##_type p2, p3##_type p3, \\\n      p4##_type p4, p5##_type p5, p6##_type p6, p7##_type p7, p8##_type p8, \\\n      p9##_type p9) {\\\n    return name##MatcherP10<p0##_type, p1##_type, p2##_type, p3##_type, \\\n        p4##_type, p5##_type, p6##_type, p7##_type, p8##_type, p9##_type>(p0, \\\n        p1, p2, p3, p4, p5, p6, p7, p8, p9);\\\n  }\\\n  template <typename p0##_type, typename p1##_type, typename p2##_type, \\\n      typename p3##_type, typename p4##_type, typename p5##_type, \\\n      typename p6##_type, typename p7##_type, typename p8##_type, \\\n      typename p9##_type>\\\n  template <typename arg_type>\\\n  bool name##MatcherP10<p0##_type, p1##_type, p2##_type, p3##_type, \\\n      p4##_type, p5##_type, p6##_type, p7##_type, p8##_type, \\\n      p9##_type>::gmock_Impl<arg_type>::MatchAndExplain(\\\n      arg_type arg, \\\n      ::testing::MatchResultListener* result_listener GTEST_ATTRIBUTE_UNUSED_)\\\n          const\n\n#endif  // GMOCK_INCLUDE_GMOCK_GMOCK_GENERATED_MATCHERS_H_\n"}, "34": {"id": 34, "path": "/home/vsts/work/1/llvm-project/llvm/utils/unittest/googlemock/include/gmock/gmock-generated-nice-strict.h", "content": "// This file was GENERATED by command:\n//     pump.py gmock-generated-nice-strict.h.pump\n// DO NOT EDIT BY HAND!!!\n\n// Copyright 2008, Google Inc.\n// All rights reserved.\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are\n// met:\n//\n//     * Redistributions of source code must retain the above copyright\n// notice, this list of conditions and the following disclaimer.\n//     * Redistributions in binary form must reproduce the above\n// copyright notice, this list of conditions and the following disclaimer\n// in the documentation and/or other materials provided with the\n// distribution.\n//     * Neither the name of Google Inc. nor the names of its\n// contributors may be used to endorse or promote products derived from\n// this software without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n//\n// Author: wan@google.com (Zhanyong Wan)\n\n// Implements class templates NiceMock, NaggyMock, and StrictMock.\n//\n// Given a mock class MockFoo that is created using Google Mock,\n// NiceMock<MockFoo> is a subclass of MockFoo that allows\n// uninteresting calls (i.e. calls to mock methods that have no\n// EXPECT_CALL specs), NaggyMock<MockFoo> is a subclass of MockFoo\n// that prints a warning when an uninteresting call occurs, and\n// StrictMock<MockFoo> is a subclass of MockFoo that treats all\n// uninteresting calls as errors.\n//\n// Currently a mock is naggy by default, so MockFoo and\n// NaggyMock<MockFoo> behave like the same.  However, we will soon\n// switch the default behavior of mocks to be nice, as that in general\n// leads to more maintainable tests.  When that happens, MockFoo will\n// stop behaving like NaggyMock<MockFoo> and start behaving like\n// NiceMock<MockFoo>.\n//\n// NiceMock, NaggyMock, and StrictMock \"inherit\" the constructors of\n// their respective base class, with up-to 10 arguments.  Therefore\n// you can write NiceMock<MockFoo>(5, \"a\") to construct a nice mock\n// where MockFoo has a constructor that accepts (int, const char*),\n// for example.\n//\n// A known limitation is that NiceMock<MockFoo>, NaggyMock<MockFoo>,\n// and StrictMock<MockFoo> only works for mock methods defined using\n// the MOCK_METHOD* family of macros DIRECTLY in the MockFoo class.\n// If a mock method is defined in a base class of MockFoo, the \"nice\"\n// or \"strict\" modifier may not affect it, depending on the compiler.\n// In particular, nesting NiceMock, NaggyMock, and StrictMock is NOT\n// supported.\n//\n// Another known limitation is that the constructors of the base mock\n// cannot have arguments passed by non-const reference, which are\n// banned by the Google C++ style guide anyway.\n\n// IWYU pragma: private, include \"gmock/gmock.h\"\n\n#ifndef GMOCK_INCLUDE_GMOCK_GMOCK_GENERATED_NICE_STRICT_H_\n#define GMOCK_INCLUDE_GMOCK_GMOCK_GENERATED_NICE_STRICT_H_\n\n#include \"gmock/gmock-spec-builders.h\"\n#include \"gmock/internal/gmock-port.h\"\n\nnamespace testing {\n\ntemplate <class MockClass>\nclass NiceMock : public MockClass {\n public:\n  // We don't factor out the constructor body to a common method, as\n  // we have to avoid a possible clash with members of MockClass.\n  NiceMock() {\n    ::testing::Mock::AllowUninterestingCalls(\n        internal::ImplicitCast_<MockClass*>(this));\n  }\n\n  // C++ doesn't (yet) allow inheritance of constructors, so we have\n  // to define it for each arity.\n  template <typename A1>\n  explicit NiceMock(const A1& a1) : MockClass(a1) {\n    ::testing::Mock::AllowUninterestingCalls(\n        internal::ImplicitCast_<MockClass*>(this));\n  }\n  template <typename A1, typename A2>\n  NiceMock(const A1& a1, const A2& a2) : MockClass(a1, a2) {\n    ::testing::Mock::AllowUninterestingCalls(\n        internal::ImplicitCast_<MockClass*>(this));\n  }\n\n  template <typename A1, typename A2, typename A3>\n  NiceMock(const A1& a1, const A2& a2, const A3& a3) : MockClass(a1, a2, a3) {\n    ::testing::Mock::AllowUninterestingCalls(\n        internal::ImplicitCast_<MockClass*>(this));\n  }\n\n  template <typename A1, typename A2, typename A3, typename A4>\n  NiceMock(const A1& a1, const A2& a2, const A3& a3,\n      const A4& a4) : MockClass(a1, a2, a3, a4) {\n    ::testing::Mock::AllowUninterestingCalls(\n        internal::ImplicitCast_<MockClass*>(this));\n  }\n\n  template <typename A1, typename A2, typename A3, typename A4, typename A5>\n  NiceMock(const A1& a1, const A2& a2, const A3& a3, const A4& a4,\n      const A5& a5) : MockClass(a1, a2, a3, a4, a5) {\n    ::testing::Mock::AllowUninterestingCalls(\n        internal::ImplicitCast_<MockClass*>(this));\n  }\n\n  template <typename A1, typename A2, typename A3, typename A4, typename A5,\n      typename A6>\n  NiceMock(const A1& a1, const A2& a2, const A3& a3, const A4& a4,\n      const A5& a5, const A6& a6) : MockClass(a1, a2, a3, a4, a5, a6) {\n    ::testing::Mock::AllowUninterestingCalls(\n        internal::ImplicitCast_<MockClass*>(this));\n  }\n\n  template <typename A1, typename A2, typename A3, typename A4, typename A5,\n      typename A6, typename A7>\n  NiceMock(const A1& a1, const A2& a2, const A3& a3, const A4& a4,\n      const A5& a5, const A6& a6, const A7& a7) : MockClass(a1, a2, a3, a4, a5,\n      a6, a7) {\n    ::testing::Mock::AllowUninterestingCalls(\n        internal::ImplicitCast_<MockClass*>(this));\n  }\n\n  template <typename A1, typename A2, typename A3, typename A4, typename A5,\n      typename A6, typename A7, typename A8>\n  NiceMock(const A1& a1, const A2& a2, const A3& a3, const A4& a4,\n      const A5& a5, const A6& a6, const A7& a7, const A8& a8) : MockClass(a1,\n      a2, a3, a4, a5, a6, a7, a8) {\n    ::testing::Mock::AllowUninterestingCalls(\n        internal::ImplicitCast_<MockClass*>(this));\n  }\n\n  template <typename A1, typename A2, typename A3, typename A4, typename A5,\n      typename A6, typename A7, typename A8, typename A9>\n  NiceMock(const A1& a1, const A2& a2, const A3& a3, const A4& a4,\n      const A5& a5, const A6& a6, const A7& a7, const A8& a8,\n      const A9& a9) : MockClass(a1, a2, a3, a4, a5, a6, a7, a8, a9) {\n    ::testing::Mock::AllowUninterestingCalls(\n        internal::ImplicitCast_<MockClass*>(this));\n  }\n\n  template <typename A1, typename A2, typename A3, typename A4, typename A5,\n      typename A6, typename A7, typename A8, typename A9, typename A10>\n  NiceMock(const A1& a1, const A2& a2, const A3& a3, const A4& a4,\n      const A5& a5, const A6& a6, const A7& a7, const A8& a8, const A9& a9,\n      const A10& a10) : MockClass(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10) {\n    ::testing::Mock::AllowUninterestingCalls(\n        internal::ImplicitCast_<MockClass*>(this));\n  }\n\n  virtual ~NiceMock() {\n    ::testing::Mock::UnregisterCallReaction(\n        internal::ImplicitCast_<MockClass*>(this));\n  }\n\n private:\n  GTEST_DISALLOW_COPY_AND_ASSIGN_(NiceMock);\n};\n\ntemplate <class MockClass>\nclass NaggyMock : public MockClass {\n public:\n  // We don't factor out the constructor body to a common method, as\n  // we have to avoid a possible clash with members of MockClass.\n  NaggyMock() {\n    ::testing::Mock::WarnUninterestingCalls(\n        internal::ImplicitCast_<MockClass*>(this));\n  }\n\n  // C++ doesn't (yet) allow inheritance of constructors, so we have\n  // to define it for each arity.\n  template <typename A1>\n  explicit NaggyMock(const A1& a1) : MockClass(a1) {\n    ::testing::Mock::WarnUninterestingCalls(\n        internal::ImplicitCast_<MockClass*>(this));\n  }\n  template <typename A1, typename A2>\n  NaggyMock(const A1& a1, const A2& a2) : MockClass(a1, a2) {\n    ::testing::Mock::WarnUninterestingCalls(\n        internal::ImplicitCast_<MockClass*>(this));\n  }\n\n  template <typename A1, typename A2, typename A3>\n  NaggyMock(const A1& a1, const A2& a2, const A3& a3) : MockClass(a1, a2, a3) {\n    ::testing::Mock::WarnUninterestingCalls(\n        internal::ImplicitCast_<MockClass*>(this));\n  }\n\n  template <typename A1, typename A2, typename A3, typename A4>\n  NaggyMock(const A1& a1, const A2& a2, const A3& a3,\n      const A4& a4) : MockClass(a1, a2, a3, a4) {\n    ::testing::Mock::WarnUninterestingCalls(\n        internal::ImplicitCast_<MockClass*>(this));\n  }\n\n  template <typename A1, typename A2, typename A3, typename A4, typename A5>\n  NaggyMock(const A1& a1, const A2& a2, const A3& a3, const A4& a4,\n      const A5& a5) : MockClass(a1, a2, a3, a4, a5) {\n    ::testing::Mock::WarnUninterestingCalls(\n        internal::ImplicitCast_<MockClass*>(this));\n  }\n\n  template <typename A1, typename A2, typename A3, typename A4, typename A5,\n      typename A6>\n  NaggyMock(const A1& a1, const A2& a2, const A3& a3, const A4& a4,\n      const A5& a5, const A6& a6) : MockClass(a1, a2, a3, a4, a5, a6) {\n    ::testing::Mock::WarnUninterestingCalls(\n        internal::ImplicitCast_<MockClass*>(this));\n  }\n\n  template <typename A1, typename A2, typename A3, typename A4, typename A5,\n      typename A6, typename A7>\n  NaggyMock(const A1& a1, const A2& a2, const A3& a3, const A4& a4,\n      const A5& a5, const A6& a6, const A7& a7) : MockClass(a1, a2, a3, a4, a5,\n      a6, a7) {\n    ::testing::Mock::WarnUninterestingCalls(\n        internal::ImplicitCast_<MockClass*>(this));\n  }\n\n  template <typename A1, typename A2, typename A3, typename A4, typename A5,\n      typename A6, typename A7, typename A8>\n  NaggyMock(const A1& a1, const A2& a2, const A3& a3, const A4& a4,\n      const A5& a5, const A6& a6, const A7& a7, const A8& a8) : MockClass(a1,\n      a2, a3, a4, a5, a6, a7, a8) {\n    ::testing::Mock::WarnUninterestingCalls(\n        internal::ImplicitCast_<MockClass*>(this));\n  }\n\n  template <typename A1, typename A2, typename A3, typename A4, typename A5,\n      typename A6, typename A7, typename A8, typename A9>\n  NaggyMock(const A1& a1, const A2& a2, const A3& a3, const A4& a4,\n      const A5& a5, const A6& a6, const A7& a7, const A8& a8,\n      const A9& a9) : MockClass(a1, a2, a3, a4, a5, a6, a7, a8, a9) {\n    ::testing::Mock::WarnUninterestingCalls(\n        internal::ImplicitCast_<MockClass*>(this));\n  }\n\n  template <typename A1, typename A2, typename A3, typename A4, typename A5,\n      typename A6, typename A7, typename A8, typename A9, typename A10>\n  NaggyMock(const A1& a1, const A2& a2, const A3& a3, const A4& a4,\n      const A5& a5, const A6& a6, const A7& a7, const A8& a8, const A9& a9,\n      const A10& a10) : MockClass(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10) {\n    ::testing::Mock::WarnUninterestingCalls(\n        internal::ImplicitCast_<MockClass*>(this));\n  }\n\n  virtual ~NaggyMock() {\n    ::testing::Mock::UnregisterCallReaction(\n        internal::ImplicitCast_<MockClass*>(this));\n  }\n\n private:\n  GTEST_DISALLOW_COPY_AND_ASSIGN_(NaggyMock);\n};\n\ntemplate <class MockClass>\nclass StrictMock : public MockClass {\n public:\n  // We don't factor out the constructor body to a common method, as\n  // we have to avoid a possible clash with members of MockClass.\n  StrictMock() {\n    ::testing::Mock::FailUninterestingCalls(\n        internal::ImplicitCast_<MockClass*>(this));\n  }\n\n  // C++ doesn't (yet) allow inheritance of constructors, so we have\n  // to define it for each arity.\n  template <typename A1>\n  explicit StrictMock(const A1& a1) : MockClass(a1) {\n    ::testing::Mock::FailUninterestingCalls(\n        internal::ImplicitCast_<MockClass*>(this));\n  }\n  template <typename A1, typename A2>\n  StrictMock(const A1& a1, const A2& a2) : MockClass(a1, a2) {\n    ::testing::Mock::FailUninterestingCalls(\n        internal::ImplicitCast_<MockClass*>(this));\n  }\n\n  template <typename A1, typename A2, typename A3>\n  StrictMock(const A1& a1, const A2& a2, const A3& a3) : MockClass(a1, a2, a3) {\n    ::testing::Mock::FailUninterestingCalls(\n        internal::ImplicitCast_<MockClass*>(this));\n  }\n\n  template <typename A1, typename A2, typename A3, typename A4>\n  StrictMock(const A1& a1, const A2& a2, const A3& a3,\n      const A4& a4) : MockClass(a1, a2, a3, a4) {\n    ::testing::Mock::FailUninterestingCalls(\n        internal::ImplicitCast_<MockClass*>(this));\n  }\n\n  template <typename A1, typename A2, typename A3, typename A4, typename A5>\n  StrictMock(const A1& a1, const A2& a2, const A3& a3, const A4& a4,\n      const A5& a5) : MockClass(a1, a2, a3, a4, a5) {\n    ::testing::Mock::FailUninterestingCalls(\n        internal::ImplicitCast_<MockClass*>(this));\n  }\n\n  template <typename A1, typename A2, typename A3, typename A4, typename A5,\n      typename A6>\n  StrictMock(const A1& a1, const A2& a2, const A3& a3, const A4& a4,\n      const A5& a5, const A6& a6) : MockClass(a1, a2, a3, a4, a5, a6) {\n    ::testing::Mock::FailUninterestingCalls(\n        internal::ImplicitCast_<MockClass*>(this));\n  }\n\n  template <typename A1, typename A2, typename A3, typename A4, typename A5,\n      typename A6, typename A7>\n  StrictMock(const A1& a1, const A2& a2, const A3& a3, const A4& a4,\n      const A5& a5, const A6& a6, const A7& a7) : MockClass(a1, a2, a3, a4, a5,\n      a6, a7) {\n    ::testing::Mock::FailUninterestingCalls(\n        internal::ImplicitCast_<MockClass*>(this));\n  }\n\n  template <typename A1, typename A2, typename A3, typename A4, typename A5,\n      typename A6, typename A7, typename A8>\n  StrictMock(const A1& a1, const A2& a2, const A3& a3, const A4& a4,\n      const A5& a5, const A6& a6, const A7& a7, const A8& a8) : MockClass(a1,\n      a2, a3, a4, a5, a6, a7, a8) {\n    ::testing::Mock::FailUninterestingCalls(\n        internal::ImplicitCast_<MockClass*>(this));\n  }\n\n  template <typename A1, typename A2, typename A3, typename A4, typename A5,\n      typename A6, typename A7, typename A8, typename A9>\n  StrictMock(const A1& a1, const A2& a2, const A3& a3, const A4& a4,\n      const A5& a5, const A6& a6, const A7& a7, const A8& a8,\n      const A9& a9) : MockClass(a1, a2, a3, a4, a5, a6, a7, a8, a9) {\n    ::testing::Mock::FailUninterestingCalls(\n        internal::ImplicitCast_<MockClass*>(this));\n  }\n\n  template <typename A1, typename A2, typename A3, typename A4, typename A5,\n      typename A6, typename A7, typename A8, typename A9, typename A10>\n  StrictMock(const A1& a1, const A2& a2, const A3& a3, const A4& a4,\n      const A5& a5, const A6& a6, const A7& a7, const A8& a8, const A9& a9,\n      const A10& a10) : MockClass(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10) {\n    ::testing::Mock::FailUninterestingCalls(\n        internal::ImplicitCast_<MockClass*>(this));\n  }\n\n  virtual ~StrictMock() {\n    ::testing::Mock::UnregisterCallReaction(\n        internal::ImplicitCast_<MockClass*>(this));\n  }\n\n private:\n  GTEST_DISALLOW_COPY_AND_ASSIGN_(StrictMock);\n};\n\n// The following specializations catch some (relatively more common)\n// user errors of nesting nice and strict mocks.  They do NOT catch\n// all possible errors.\n\n// These specializations are declared but not defined, as NiceMock,\n// NaggyMock, and StrictMock cannot be nested.\n\ntemplate <typename MockClass>\nclass NiceMock<NiceMock<MockClass> >;\ntemplate <typename MockClass>\nclass NiceMock<NaggyMock<MockClass> >;\ntemplate <typename MockClass>\nclass NiceMock<StrictMock<MockClass> >;\n\ntemplate <typename MockClass>\nclass NaggyMock<NiceMock<MockClass> >;\ntemplate <typename MockClass>\nclass NaggyMock<NaggyMock<MockClass> >;\ntemplate <typename MockClass>\nclass NaggyMock<StrictMock<MockClass> >;\n\ntemplate <typename MockClass>\nclass StrictMock<NiceMock<MockClass> >;\ntemplate <typename MockClass>\nclass StrictMock<NaggyMock<MockClass> >;\ntemplate <typename MockClass>\nclass StrictMock<StrictMock<MockClass> >;\n\n}  // namespace testing\n\n#endif  // GMOCK_INCLUDE_GMOCK_GMOCK_GENERATED_NICE_STRICT_H_\n"}, "35": {"id": 35, "path": "/home/vsts/work/1/llvm-project/llvm/utils/unittest/googlemock/include/gmock/gmock-matchers.h", "content": "// Copyright 2007, Google Inc.\n// All rights reserved.\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are\n// met:\n//\n//     * Redistributions of source code must retain the above copyright\n// notice, this list of conditions and the following disclaimer.\n//     * Redistributions in binary form must reproduce the above\n// copyright notice, this list of conditions and the following disclaimer\n// in the documentation and/or other materials provided with the\n// distribution.\n//     * Neither the name of Google Inc. nor the names of its\n// contributors may be used to endorse or promote products derived from\n// this software without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n//\n// Author: wan@google.com (Zhanyong Wan)\n\n// Google Mock - a framework for writing C++ mock classes.\n//\n// This file implements some commonly used argument matchers.  More\n// matchers can be defined by the user implementing the\n// MatcherInterface<T> interface if necessary.\n\n// IWYU pragma: private, include \"gmock/gmock.h\"\n\n#ifndef GMOCK_INCLUDE_GMOCK_GMOCK_MATCHERS_H_\n#define GMOCK_INCLUDE_GMOCK_GMOCK_MATCHERS_H_\n\n#include <math.h>\n#include <algorithm>\n#include <iterator>\n#include <limits>\n#include <ostream>  // NOLINT\n#include <sstream>\n#include <string>\n#include <utility>\n#include <vector>\n\n#include \"gmock/internal/gmock-internal-utils.h\"\n#include \"gmock/internal/gmock-port.h\"\n#include \"gtest/gtest.h\"\n\n#if GTEST_HAS_STD_INITIALIZER_LIST_\n# include <initializer_list>  // NOLINT -- must be after gtest.h\n#endif\n\nnamespace testing {\n\n// To implement a matcher Foo for type T, define:\n//   1. a class FooMatcherImpl that implements the\n//      MatcherInterface<T> interface, and\n//   2. a factory function that creates a Matcher<T> object from a\n//      FooMatcherImpl*.\n//\n// The two-level delegation design makes it possible to allow a user\n// to write \"v\" instead of \"Eq(v)\" where a Matcher is expected, which\n// is impossible if we pass matchers by pointers.  It also eases\n// ownership management as Matcher objects can now be copied like\n// plain values.\n\n// MatchResultListener is an abstract class.  Its << operator can be\n// used by a matcher to explain why a value matches or doesn't match.\n//\n// TODO(wan@google.com): add method\n//   bool InterestedInWhy(bool result) const;\n// to indicate whether the listener is interested in why the match\n// result is 'result'.\nclass MatchResultListener {\n public:\n  // Creates a listener object with the given underlying ostream.  The\n  // listener does not own the ostream, and does not dereference it\n  // in the constructor or destructor.\n  explicit MatchResultListener(::std::ostream* os) : stream_(os) {}\n  virtual ~MatchResultListener() = 0;  // Makes this class abstract.\n\n  // Streams x to the underlying ostream; does nothing if the ostream\n  // is NULL.\n  template <typename T>\n  MatchResultListener& operator<<(const T& x) {\n    if (stream_ != NULL)\n      *stream_ << x;\n    return *this;\n  }\n\n  // Returns the underlying ostream.\n  ::std::ostream* stream() { return stream_; }\n\n  // Returns true iff the listener is interested in an explanation of\n  // the match result.  A matcher's MatchAndExplain() method can use\n  // this information to avoid generating the explanation when no one\n  // intends to hear it.\n  bool IsInterested() const { return stream_ != NULL; }\n\n private:\n  ::std::ostream* const stream_;\n\n  GTEST_DISALLOW_COPY_AND_ASSIGN_(MatchResultListener);\n};\n\ninline MatchResultListener::~MatchResultListener() {\n}\n\n// An instance of a subclass of this knows how to describe itself as a\n// matcher.\nclass MatcherDescriberInterface {\n public:\n  virtual ~MatcherDescriberInterface() {}\n\n  // Describes this matcher to an ostream.  The function should print\n  // a verb phrase that describes the property a value matching this\n  // matcher should have.  The subject of the verb phrase is the value\n  // being matched.  For example, the DescribeTo() method of the Gt(7)\n  // matcher prints \"is greater than 7\".\n  virtual void DescribeTo(::std::ostream* os) const = 0;\n\n  // Describes the negation of this matcher to an ostream.  For\n  // example, if the description of this matcher is \"is greater than\n  // 7\", the negated description could be \"is not greater than 7\".\n  // You are not required to override this when implementing\n  // MatcherInterface, but it is highly advised so that your matcher\n  // can produce good error messages.\n  virtual void DescribeNegationTo(::std::ostream* os) const {\n    *os << \"not (\";\n    DescribeTo(os);\n    *os << \")\";\n  }\n};\n\n// The implementation of a matcher.\ntemplate <typename T>\nclass MatcherInterface : public MatcherDescriberInterface {\n public:\n  // Returns true iff the matcher matches x; also explains the match\n  // result to 'listener' if necessary (see the next paragraph), in\n  // the form of a non-restrictive relative clause (\"which ...\",\n  // \"whose ...\", etc) that describes x.  For example, the\n  // MatchAndExplain() method of the Pointee(...) matcher should\n  // generate an explanation like \"which points to ...\".\n  //\n  // Implementations of MatchAndExplain() should add an explanation of\n  // the match result *if and only if* they can provide additional\n  // information that's not already present (or not obvious) in the\n  // print-out of x and the matcher's description.  Whether the match\n  // succeeds is not a factor in deciding whether an explanation is\n  // needed, as sometimes the caller needs to print a failure message\n  // when the match succeeds (e.g. when the matcher is used inside\n  // Not()).\n  //\n  // For example, a \"has at least 10 elements\" matcher should explain\n  // what the actual element count is, regardless of the match result,\n  // as it is useful information to the reader; on the other hand, an\n  // \"is empty\" matcher probably only needs to explain what the actual\n  // size is when the match fails, as it's redundant to say that the\n  // size is 0 when the value is already known to be empty.\n  //\n  // You should override this method when defining a new matcher.\n  //\n  // It's the responsibility of the caller (Google Mock) to guarantee\n  // that 'listener' is not NULL.  This helps to simplify a matcher's\n  // implementation when it doesn't care about the performance, as it\n  // can talk to 'listener' without checking its validity first.\n  // However, in order to implement dummy listeners efficiently,\n  // listener->stream() may be NULL.\n  virtual bool MatchAndExplain(T x, MatchResultListener* listener) const = 0;\n\n  // Inherits these methods from MatcherDescriberInterface:\n  //   virtual void DescribeTo(::std::ostream* os) const = 0;\n  //   virtual void DescribeNegationTo(::std::ostream* os) const;\n};\n\n// A match result listener that stores the explanation in a string.\nclass StringMatchResultListener : public MatchResultListener {\n public:\n  StringMatchResultListener() : MatchResultListener(&ss_) {}\n\n  // Returns the explanation accumulated so far.\n  internal::string str() const { return ss_.str(); }\n\n  // Clears the explanation accumulated so far.\n  void Clear() { ss_.str(\"\"); }\n\n private:\n  ::std::stringstream ss_;\n\n  GTEST_DISALLOW_COPY_AND_ASSIGN_(StringMatchResultListener);\n};\n\nnamespace internal {\n\nstruct AnyEq {\n  template <typename A, typename B>\n  bool operator()(const A& a, const B& b) const { return a == b; }\n};\nstruct AnyNe {\n  template <typename A, typename B>\n  bool operator()(const A& a, const B& b) const { return a != b; }\n};\nstruct AnyLt {\n  template <typename A, typename B>\n  bool operator()(const A& a, const B& b) const { return a < b; }\n};\nstruct AnyGt {\n  template <typename A, typename B>\n  bool operator()(const A& a, const B& b) const { return a > b; }\n};\nstruct AnyLe {\n  template <typename A, typename B>\n  bool operator()(const A& a, const B& b) const { return a <= b; }\n};\nstruct AnyGe {\n  template <typename A, typename B>\n  bool operator()(const A& a, const B& b) const { return a >= b; }\n};\n\n// A match result listener that ignores the explanation.\nclass DummyMatchResultListener : public MatchResultListener {\n public:\n  DummyMatchResultListener() : MatchResultListener(NULL) {}\n\n private:\n  GTEST_DISALLOW_COPY_AND_ASSIGN_(DummyMatchResultListener);\n};\n\n// A match result listener that forwards the explanation to a given\n// ostream.  The difference between this and MatchResultListener is\n// that the former is concrete.\nclass StreamMatchResultListener : public MatchResultListener {\n public:\n  explicit StreamMatchResultListener(::std::ostream* os)\n      : MatchResultListener(os) {}\n\n private:\n  GTEST_DISALLOW_COPY_AND_ASSIGN_(StreamMatchResultListener);\n};\n\n// An internal class for implementing Matcher<T>, which will derive\n// from it.  We put functionalities common to all Matcher<T>\n// specializations here to avoid code duplication.\ntemplate <typename T>\nclass MatcherBase {\n public:\n  // Returns true iff the matcher matches x; also explains the match\n  // result to 'listener'.\n  bool MatchAndExplain(T x, MatchResultListener* listener) const {\n    return impl_->MatchAndExplain(x, listener);\n  }\n\n  // Returns true iff this matcher matches x.\n  bool Matches(T x) const {\n    DummyMatchResultListener dummy;\n    return MatchAndExplain(x, &dummy);\n  }\n\n  // Describes this matcher to an ostream.\n  void DescribeTo(::std::ostream* os) const { impl_->DescribeTo(os); }\n\n  // Describes the negation of this matcher to an ostream.\n  void DescribeNegationTo(::std::ostream* os) const {\n    impl_->DescribeNegationTo(os);\n  }\n\n  // Explains why x matches, or doesn't match, the matcher.\n  void ExplainMatchResultTo(T x, ::std::ostream* os) const {\n    StreamMatchResultListener listener(os);\n    MatchAndExplain(x, &listener);\n  }\n\n  // Returns the describer for this matcher object; retains ownership\n  // of the describer, which is only guaranteed to be alive when\n  // this matcher object is alive.\n  const MatcherDescriberInterface* GetDescriber() const {\n    return impl_.get();\n  }\n\n protected:\n  MatcherBase() {}\n\n  // Constructs a matcher from its implementation.\n  explicit MatcherBase(const MatcherInterface<T>* impl)\n      : impl_(impl) {}\n\n  virtual ~MatcherBase() {}\n\n private:\n  // shared_ptr (util/gtl/shared_ptr.h) and linked_ptr have similar\n  // interfaces.  The former dynamically allocates a chunk of memory\n  // to hold the reference count, while the latter tracks all\n  // references using a circular linked list without allocating\n  // memory.  It has been observed that linked_ptr performs better in\n  // typical scenarios.  However, shared_ptr can out-perform\n  // linked_ptr when there are many more uses of the copy constructor\n  // than the default constructor.\n  //\n  // If performance becomes a problem, we should see if using\n  // shared_ptr helps.\n  ::testing::internal::linked_ptr<const MatcherInterface<T> > impl_;\n};\n\n}  // namespace internal\n\n// A Matcher<T> is a copyable and IMMUTABLE (except by assignment)\n// object that can check whether a value of type T matches.  The\n// implementation of Matcher<T> is just a linked_ptr to const\n// MatcherInterface<T>, so copying is fairly cheap.  Don't inherit\n// from Matcher!\ntemplate <typename T>\nclass Matcher : public internal::MatcherBase<T> {\n public:\n  // Constructs a null matcher.  Needed for storing Matcher objects in STL\n  // containers.  A default-constructed matcher is not yet initialized.  You\n  // cannot use it until a valid value has been assigned to it.\n  explicit Matcher() {}  // NOLINT\n\n  // Constructs a matcher from its implementation.\n  explicit Matcher(const MatcherInterface<T>* impl)\n      : internal::MatcherBase<T>(impl) {}\n\n  // Implicit constructor here allows people to write\n  // EXPECT_CALL(foo, Bar(5)) instead of EXPECT_CALL(foo, Bar(Eq(5))) sometimes\n  Matcher(T value);  // NOLINT\n};\n\n// The following two specializations allow the user to write str\n// instead of Eq(str) and \"foo\" instead of Eq(\"foo\") when a string\n// matcher is expected.\ntemplate <>\nclass GTEST_API_ Matcher<const internal::string&>\n    : public internal::MatcherBase<const internal::string&> {\n public:\n  Matcher() {}\n\n  explicit Matcher(const MatcherInterface<const internal::string&>* impl)\n      : internal::MatcherBase<const internal::string&>(impl) {}\n\n  // Allows the user to write str instead of Eq(str) sometimes, where\n  // str is a string object.\n  Matcher(const internal::string& s);  // NOLINT\n\n  // Allows the user to write \"foo\" instead of Eq(\"foo\") sometimes.\n  Matcher(const char* s);  // NOLINT\n};\n\ntemplate <>\nclass GTEST_API_ Matcher<internal::string>\n    : public internal::MatcherBase<internal::string> {\n public:\n  Matcher() {}\n\n  explicit Matcher(const MatcherInterface<internal::string>* impl)\n      : internal::MatcherBase<internal::string>(impl) {}\n\n  // Allows the user to write str instead of Eq(str) sometimes, where\n  // str is a string object.\n  Matcher(const internal::string& s);  // NOLINT\n\n  // Allows the user to write \"foo\" instead of Eq(\"foo\") sometimes.\n  Matcher(const char* s);  // NOLINT\n};\n\n#if GTEST_HAS_STRING_PIECE_\n// The following two specializations allow the user to write str\n// instead of Eq(str) and \"foo\" instead of Eq(\"foo\") when a StringPiece\n// matcher is expected.\ntemplate <>\nclass GTEST_API_ Matcher<const StringPiece&>\n    : public internal::MatcherBase<const StringPiece&> {\n public:\n  Matcher() {}\n\n  explicit Matcher(const MatcherInterface<const StringPiece&>* impl)\n      : internal::MatcherBase<const StringPiece&>(impl) {}\n\n  // Allows the user to write str instead of Eq(str) sometimes, where\n  // str is a string object.\n  Matcher(const internal::string& s);  // NOLINT\n\n  // Allows the user to write \"foo\" instead of Eq(\"foo\") sometimes.\n  Matcher(const char* s);  // NOLINT\n\n  // Allows the user to pass StringPieces directly.\n  Matcher(StringPiece s);  // NOLINT\n};\n\ntemplate <>\nclass GTEST_API_ Matcher<StringPiece>\n    : public internal::MatcherBase<StringPiece> {\n public:\n  Matcher() {}\n\n  explicit Matcher(const MatcherInterface<StringPiece>* impl)\n      : internal::MatcherBase<StringPiece>(impl) {}\n\n  // Allows the user to write str instead of Eq(str) sometimes, where\n  // str is a string object.\n  Matcher(const internal::string& s);  // NOLINT\n\n  // Allows the user to write \"foo\" instead of Eq(\"foo\") sometimes.\n  Matcher(const char* s);  // NOLINT\n\n  // Allows the user to pass StringPieces directly.\n  Matcher(StringPiece s);  // NOLINT\n};\n#endif  // GTEST_HAS_STRING_PIECE_\n\n// The PolymorphicMatcher class template makes it easy to implement a\n// polymorphic matcher (i.e. a matcher that can match values of more\n// than one type, e.g. Eq(n) and NotNull()).\n//\n// To define a polymorphic matcher, a user should provide an Impl\n// class that has a DescribeTo() method and a DescribeNegationTo()\n// method, and define a member function (or member function template)\n//\n//   bool MatchAndExplain(const Value& value,\n//                        MatchResultListener* listener) const;\n//\n// See the definition of NotNull() for a complete example.\ntemplate <class Impl>\nclass PolymorphicMatcher {\n public:\n  explicit PolymorphicMatcher(const Impl& an_impl) : impl_(an_impl) {}\n\n  // Returns a mutable reference to the underlying matcher\n  // implementation object.\n  Impl& mutable_impl() { return impl_; }\n\n  // Returns an immutable reference to the underlying matcher\n  // implementation object.\n  const Impl& impl() const { return impl_; }\n\n  template <typename T>\n  operator Matcher<T>() const {\n    return Matcher<T>(new MonomorphicImpl<T>(impl_));\n  }\n\n private:\n  template <typename T>\n  class MonomorphicImpl : public MatcherInterface<T> {\n   public:\n    explicit MonomorphicImpl(const Impl& impl) : impl_(impl) {}\n\n    virtual void DescribeTo(::std::ostream* os) const {\n      impl_.DescribeTo(os);\n    }\n\n    virtual void DescribeNegationTo(::std::ostream* os) const {\n      impl_.DescribeNegationTo(os);\n    }\n\n    virtual bool MatchAndExplain(T x, MatchResultListener* listener) const {\n      return impl_.MatchAndExplain(x, listener);\n    }\n\n   private:\n    const Impl impl_;\n\n    GTEST_DISALLOW_ASSIGN_(MonomorphicImpl);\n  };\n\n  Impl impl_;\n\n  GTEST_DISALLOW_ASSIGN_(PolymorphicMatcher);\n};\n\n// Creates a matcher from its implementation.  This is easier to use\n// than the Matcher<T> constructor as it doesn't require you to\n// explicitly write the template argument, e.g.\n//\n//   MakeMatcher(foo);\n// vs\n//   Matcher<const string&>(foo);\ntemplate <typename T>\ninline Matcher<T> MakeMatcher(const MatcherInterface<T>* impl) {\n  return Matcher<T>(impl);\n}\n\n// Creates a polymorphic matcher from its implementation.  This is\n// easier to use than the PolymorphicMatcher<Impl> constructor as it\n// doesn't require you to explicitly write the template argument, e.g.\n//\n//   MakePolymorphicMatcher(foo);\n// vs\n//   PolymorphicMatcher<TypeOfFoo>(foo);\ntemplate <class Impl>\ninline PolymorphicMatcher<Impl> MakePolymorphicMatcher(const Impl& impl) {\n  return PolymorphicMatcher<Impl>(impl);\n}\n\n// Anything inside the 'internal' namespace IS INTERNAL IMPLEMENTATION\n// and MUST NOT BE USED IN USER CODE!!!\nnamespace internal {\n\n// The MatcherCastImpl class template is a helper for implementing\n// MatcherCast().  We need this helper in order to partially\n// specialize the implementation of MatcherCast() (C++ allows\n// class/struct templates to be partially specialized, but not\n// function templates.).\n\n// This general version is used when MatcherCast()'s argument is a\n// polymorphic matcher (i.e. something that can be converted to a\n// Matcher but is not one yet; for example, Eq(value)) or a value (for\n// example, \"hello\").\ntemplate <typename T, typename M>\nclass MatcherCastImpl {\n public:\n  static Matcher<T> Cast(const M& polymorphic_matcher_or_value) {\n    // M can be a polymorhic matcher, in which case we want to use\n    // its conversion operator to create Matcher<T>.  Or it can be a value\n    // that should be passed to the Matcher<T>'s constructor.\n    //\n    // We can't call Matcher<T>(polymorphic_matcher_or_value) when M is a\n    // polymorphic matcher because it'll be ambiguous if T has an implicit\n    // constructor from M (this usually happens when T has an implicit\n    // constructor from any type).\n    //\n    // It won't work to unconditionally implict_cast\n    // polymorphic_matcher_or_value to Matcher<T> because it won't trigger\n    // a user-defined conversion from M to T if one exists (assuming M is\n    // a value).\n    return CastImpl(\n        polymorphic_matcher_or_value,\n        BooleanConstant<\n            internal::ImplicitlyConvertible<M, Matcher<T> >::value>());\n  }\n\n private:\n  static Matcher<T> CastImpl(const M& value, BooleanConstant<false>) {\n    // M can't be implicitly converted to Matcher<T>, so M isn't a polymorphic\n    // matcher.  It must be a value then.  Use direct initialization to create\n    // a matcher.\n    return Matcher<T>(ImplicitCast_<T>(value));\n  }\n\n  static Matcher<T> CastImpl(const M& polymorphic_matcher_or_value,\n                             BooleanConstant<true>) {\n    // M is implicitly convertible to Matcher<T>, which means that either\n    // M is a polymorhpic matcher or Matcher<T> has an implicit constructor\n    // from M.  In both cases using the implicit conversion will produce a\n    // matcher.\n    //\n    // Even if T has an implicit constructor from M, it won't be called because\n    // creating Matcher<T> would require a chain of two user-defined conversions\n    // (first to create T from M and then to create Matcher<T> from T).\n    return polymorphic_matcher_or_value;\n  }\n};\n\n// This more specialized version is used when MatcherCast()'s argument\n// is already a Matcher.  This only compiles when type T can be\n// statically converted to type U.\ntemplate <typename T, typename U>\nclass MatcherCastImpl<T, Matcher<U> > {\n public:\n  static Matcher<T> Cast(const Matcher<U>& source_matcher) {\n    return Matcher<T>(new Impl(source_matcher));\n  }\n\n private:\n  class Impl : public MatcherInterface<T> {\n   public:\n    explicit Impl(const Matcher<U>& source_matcher)\n        : source_matcher_(source_matcher) {}\n\n    // We delegate the matching logic to the source matcher.\n    virtual bool MatchAndExplain(T x, MatchResultListener* listener) const {\n      return source_matcher_.MatchAndExplain(static_cast<U>(x), listener);\n    }\n\n    virtual void DescribeTo(::std::ostream* os) const {\n      source_matcher_.DescribeTo(os);\n    }\n\n    virtual void DescribeNegationTo(::std::ostream* os) const {\n      source_matcher_.DescribeNegationTo(os);\n    }\n\n   private:\n    const Matcher<U> source_matcher_;\n\n    GTEST_DISALLOW_ASSIGN_(Impl);\n  };\n};\n\n// This even more specialized version is used for efficiently casting\n// a matcher to its own type.\ntemplate <typename T>\nclass MatcherCastImpl<T, Matcher<T> > {\n public:\n  static Matcher<T> Cast(const Matcher<T>& matcher) { return matcher; }\n};\n\n}  // namespace internal\n\n// In order to be safe and clear, casting between different matcher\n// types is done explicitly via MatcherCast<T>(m), which takes a\n// matcher m and returns a Matcher<T>.  It compiles only when T can be\n// statically converted to the argument type of m.\ntemplate <typename T, typename M>\ninline Matcher<T> MatcherCast(const M& matcher) {\n  return internal::MatcherCastImpl<T, M>::Cast(matcher);\n}\n\n// Implements SafeMatcherCast().\n//\n// We use an intermediate class to do the actual safe casting as Nokia's\n// Symbian compiler cannot decide between\n// template <T, M> ... (M) and\n// template <T, U> ... (const Matcher<U>&)\n// for function templates but can for member function templates.\ntemplate <typename T>\nclass SafeMatcherCastImpl {\n public:\n  // This overload handles polymorphic matchers and values only since\n  // monomorphic matchers are handled by the next one.\n  template <typename M>\n  static inline Matcher<T> Cast(const M& polymorphic_matcher_or_value) {\n    return internal::MatcherCastImpl<T, M>::Cast(polymorphic_matcher_or_value);\n  }\n\n  // This overload handles monomorphic matchers.\n  //\n  // In general, if type T can be implicitly converted to type U, we can\n  // safely convert a Matcher<U> to a Matcher<T> (i.e. Matcher is\n  // contravariant): just keep a copy of the original Matcher<U>, convert the\n  // argument from type T to U, and then pass it to the underlying Matcher<U>.\n  // The only exception is when U is a reference and T is not, as the\n  // underlying Matcher<U> may be interested in the argument's address, which\n  // is not preserved in the conversion from T to U.\n  template <typename U>\n  static inline Matcher<T> Cast(const Matcher<U>& matcher) {\n    // Enforce that T can be implicitly converted to U.\n    GTEST_COMPILE_ASSERT_((internal::ImplicitlyConvertible<T, U>::value),\n                          T_must_be_implicitly_convertible_to_U);\n    // Enforce that we are not converting a non-reference type T to a reference\n    // type U.\n    GTEST_COMPILE_ASSERT_(\n        internal::is_reference<T>::value || !internal::is_reference<U>::value,\n        cannot_convert_non_referentce_arg_to_reference);\n    // In case both T and U are arithmetic types, enforce that the\n    // conversion is not lossy.\n    typedef GTEST_REMOVE_REFERENCE_AND_CONST_(T) RawT;\n    typedef GTEST_REMOVE_REFERENCE_AND_CONST_(U) RawU;\n    const bool kTIsOther = GMOCK_KIND_OF_(RawT) == internal::kOther;\n    const bool kUIsOther = GMOCK_KIND_OF_(RawU) == internal::kOther;\n    GTEST_COMPILE_ASSERT_(\n        kTIsOther || kUIsOther ||\n        (internal::LosslessArithmeticConvertible<RawT, RawU>::value),\n        conversion_of_arithmetic_types_must_be_lossless);\n    return MatcherCast<T>(matcher);\n  }\n};\n\ntemplate <typename T, typename M>\ninline Matcher<T> SafeMatcherCast(const M& polymorphic_matcher) {\n  return SafeMatcherCastImpl<T>::Cast(polymorphic_matcher);\n}\n\n// A<T>() returns a matcher that matches any value of type T.\ntemplate <typename T>\nMatcher<T> A();\n\n// Anything inside the 'internal' namespace IS INTERNAL IMPLEMENTATION\n// and MUST NOT BE USED IN USER CODE!!!\nnamespace internal {\n\n// If the explanation is not empty, prints it to the ostream.\ninline void PrintIfNotEmpty(const internal::string& explanation,\n                            ::std::ostream* os) {\n  if (explanation != \"\" && os != NULL) {\n    *os << \", \" << explanation;\n  }\n}\n\n// Returns true if the given type name is easy to read by a human.\n// This is used to decide whether printing the type of a value might\n// be helpful.\ninline bool IsReadableTypeName(const string& type_name) {\n  // We consider a type name readable if it's short or doesn't contain\n  // a template or function type.\n  return (type_name.length() <= 20 ||\n          type_name.find_first_of(\"<(\") == string::npos);\n}\n\n// Matches the value against the given matcher, prints the value and explains\n// the match result to the listener. Returns the match result.\n// 'listener' must not be NULL.\n// Value cannot be passed by const reference, because some matchers take a\n// non-const argument.\ntemplate <typename Value, typename T>\nbool MatchPrintAndExplain(Value& value, const Matcher<T>& matcher,\n                          MatchResultListener* listener) {\n  if (!listener->IsInterested()) {\n    // If the listener is not interested, we do not need to construct the\n    // inner explanation.\n    return matcher.Matches(value);\n  }\n\n  StringMatchResultListener inner_listener;\n  const bool match = matcher.MatchAndExplain(value, &inner_listener);\n\n  UniversalPrint(value, listener->stream());\n#if GTEST_HAS_RTTI\n  const string& type_name = GetTypeName<Value>();\n  if (IsReadableTypeName(type_name))\n    *listener->stream() << \" (of type \" << type_name << \")\";\n#endif\n  PrintIfNotEmpty(inner_listener.str(), listener->stream());\n\n  return match;\n}\n\n// An internal helper class for doing compile-time loop on a tuple's\n// fields.\ntemplate <size_t N>\nclass TuplePrefix {\n public:\n  // TuplePrefix<N>::Matches(matcher_tuple, value_tuple) returns true\n  // iff the first N fields of matcher_tuple matches the first N\n  // fields of value_tuple, respectively.\n  template <typename MatcherTuple, typename ValueTuple>\n  static bool Matches(const MatcherTuple& matcher_tuple,\n                      const ValueTuple& value_tuple) {\n    return TuplePrefix<N - 1>::Matches(matcher_tuple, value_tuple)\n        && get<N - 1>(matcher_tuple).Matches(get<N - 1>(value_tuple));\n  }\n\n  // TuplePrefix<N>::ExplainMatchFailuresTo(matchers, values, os)\n  // describes failures in matching the first N fields of matchers\n  // against the first N fields of values.  If there is no failure,\n  // nothing will be streamed to os.\n  template <typename MatcherTuple, typename ValueTuple>\n  static void ExplainMatchFailuresTo(const MatcherTuple& matchers,\n                                     const ValueTuple& values,\n                                     ::std::ostream* os) {\n    // First, describes failures in the first N - 1 fields.\n    TuplePrefix<N - 1>::ExplainMatchFailuresTo(matchers, values, os);\n\n    // Then describes the failure (if any) in the (N - 1)-th (0-based)\n    // field.\n    typename tuple_element<N - 1, MatcherTuple>::type matcher =\n        get<N - 1>(matchers);\n    typedef typename tuple_element<N - 1, ValueTuple>::type Value;\n    Value value = get<N - 1>(values);\n    StringMatchResultListener listener;\n    if (!matcher.MatchAndExplain(value, &listener)) {\n      // TODO(wan): include in the message the name of the parameter\n      // as used in MOCK_METHOD*() when possible.\n      *os << \"  Expected arg #\" << N - 1 << \": \";\n      get<N - 1>(matchers).DescribeTo(os);\n      *os << \"\\n           Actual: \";\n      // We remove the reference in type Value to prevent the\n      // universal printer from printing the address of value, which\n      // isn't interesting to the user most of the time.  The\n      // matcher's MatchAndExplain() method handles the case when\n      // the address is interesting.\n      internal::UniversalPrint(value, os);\n      PrintIfNotEmpty(listener.str(), os);\n      *os << \"\\n\";\n    }\n  }\n};\n\n// The base case.\ntemplate <>\nclass TuplePrefix<0> {\n public:\n  template <typename MatcherTuple, typename ValueTuple>\n  static bool Matches(const MatcherTuple& /* matcher_tuple */,\n                      const ValueTuple& /* value_tuple */) {\n    return true;\n  }\n\n  template <typename MatcherTuple, typename ValueTuple>\n  static void ExplainMatchFailuresTo(const MatcherTuple& /* matchers */,\n                                     const ValueTuple& /* values */,\n                                     ::std::ostream* /* os */) {}\n};\n\n// TupleMatches(matcher_tuple, value_tuple) returns true iff all\n// matchers in matcher_tuple match the corresponding fields in\n// value_tuple.  It is a compiler error if matcher_tuple and\n// value_tuple have different number of fields or incompatible field\n// types.\ntemplate <typename MatcherTuple, typename ValueTuple>\nbool TupleMatches(const MatcherTuple& matcher_tuple,\n                  const ValueTuple& value_tuple) {\n  // Makes sure that matcher_tuple and value_tuple have the same\n  // number of fields.\n  GTEST_COMPILE_ASSERT_(tuple_size<MatcherTuple>::value ==\n                        tuple_size<ValueTuple>::value,\n                        matcher_and_value_have_different_numbers_of_fields);\n  return TuplePrefix<tuple_size<ValueTuple>::value>::\n      Matches(matcher_tuple, value_tuple);\n}\n\n// Describes failures in matching matchers against values.  If there\n// is no failure, nothing will be streamed to os.\ntemplate <typename MatcherTuple, typename ValueTuple>\nvoid ExplainMatchFailureTupleTo(const MatcherTuple& matchers,\n                                const ValueTuple& values,\n                                ::std::ostream* os) {\n  TuplePrefix<tuple_size<MatcherTuple>::value>::ExplainMatchFailuresTo(\n      matchers, values, os);\n}\n\n// TransformTupleValues and its helper.\n//\n// TransformTupleValuesHelper hides the internal machinery that\n// TransformTupleValues uses to implement a tuple traversal.\ntemplate <typename Tuple, typename Func, typename OutIter>\nclass TransformTupleValuesHelper {\n private:\n  typedef ::testing::tuple_size<Tuple> TupleSize;\n\n public:\n  // For each member of tuple 't', taken in order, evaluates '*out++ = f(t)'.\n  // Returns the final value of 'out' in case the caller needs it.\n  static OutIter Run(Func f, const Tuple& t, OutIter out) {\n    return IterateOverTuple<Tuple, TupleSize::value>()(f, t, out);\n  }\n\n private:\n  template <typename Tup, size_t kRemainingSize>\n  struct IterateOverTuple {\n    OutIter operator() (Func f, const Tup& t, OutIter out) const {\n      *out++ = f(::testing::get<TupleSize::value - kRemainingSize>(t));\n      return IterateOverTuple<Tup, kRemainingSize - 1>()(f, t, out);\n    }\n  };\n  template <typename Tup>\n  struct IterateOverTuple<Tup, 0> {\n    OutIter operator() (Func /* f */, const Tup& /* t */, OutIter out) const {\n      return out;\n    }\n  };\n};\n\n// Successively invokes 'f(element)' on each element of the tuple 't',\n// appending each result to the 'out' iterator. Returns the final value\n// of 'out'.\ntemplate <typename Tuple, typename Func, typename OutIter>\nOutIter TransformTupleValues(Func f, const Tuple& t, OutIter out) {\n  return TransformTupleValuesHelper<Tuple, Func, OutIter>::Run(f, t, out);\n}\n\n// Implements A<T>().\ntemplate <typename T>\nclass AnyMatcherImpl : public MatcherInterface<T> {\n public:\n  virtual bool MatchAndExplain(\n      T /* x */, MatchResultListener* /* listener */) const { return true; }\n  virtual void DescribeTo(::std::ostream* os) const { *os << \"is anything\"; }\n  virtual void DescribeNegationTo(::std::ostream* os) const {\n    // This is mostly for completeness' safe, as it's not very useful\n    // to write Not(A<bool>()).  However we cannot completely rule out\n    // such a possibility, and it doesn't hurt to be prepared.\n    *os << \"never matches\";\n  }\n};\n\n// Implements _, a matcher that matches any value of any\n// type.  This is a polymorphic matcher, so we need a template type\n// conversion operator to make it appearing as a Matcher<T> for any\n// type T.\nclass AnythingMatcher {\n public:\n  template <typename T>\n  operator Matcher<T>() const { return A<T>(); }\n};\n\n// Implements a matcher that compares a given value with a\n// pre-supplied value using one of the ==, <=, <, etc, operators.  The\n// two values being compared don't have to have the same type.\n//\n// The matcher defined here is polymorphic (for example, Eq(5) can be\n// used to match an int, a short, a double, etc).  Therefore we use\n// a template type conversion operator in the implementation.\n//\n// The following template definition assumes that the Rhs parameter is\n// a \"bare\" type (i.e. neither 'const T' nor 'T&').\ntemplate <typename D, typename Rhs, typename Op>\nclass ComparisonBase {\n public:\n  explicit ComparisonBase(const Rhs& rhs) : rhs_(rhs) {}\n  template <typename Lhs>\n  operator Matcher<Lhs>() const {\n    return MakeMatcher(new Impl<Lhs>(rhs_));\n  }\n\n private:\n  template <typename Lhs>\n  class Impl : public MatcherInterface<Lhs> {\n   public:\n    explicit Impl(const Rhs& rhs) : rhs_(rhs) {}\n    virtual bool MatchAndExplain(\n        Lhs lhs, MatchResultListener* /* listener */) const {\n      return Op()(lhs, rhs_);\n    }\n    virtual void DescribeTo(::std::ostream* os) const {\n      *os << D::Desc() << \" \";\n      UniversalPrint(rhs_, os);\n    }\n    virtual void DescribeNegationTo(::std::ostream* os) const {\n      *os << D::NegatedDesc() <<  \" \";\n      UniversalPrint(rhs_, os);\n    }\n   private:\n    Rhs rhs_;\n    GTEST_DISALLOW_ASSIGN_(Impl);\n  };\n  Rhs rhs_;\n  GTEST_DISALLOW_ASSIGN_(ComparisonBase);\n};\n\ntemplate <typename Rhs>\nclass EqMatcher : public ComparisonBase<EqMatcher<Rhs>, Rhs, AnyEq> {\n public:\n  explicit EqMatcher(const Rhs& rhs)\n      : ComparisonBase<EqMatcher<Rhs>, Rhs, AnyEq>(rhs) { }\n  static const char* Desc() { return \"is equal to\"; }\n  static const char* NegatedDesc() { return \"isn't equal to\"; }\n};\ntemplate <typename Rhs>\nclass NeMatcher : public ComparisonBase<NeMatcher<Rhs>, Rhs, AnyNe> {\n public:\n  explicit NeMatcher(const Rhs& rhs)\n      : ComparisonBase<NeMatcher<Rhs>, Rhs, AnyNe>(rhs) { }\n  static const char* Desc() { return \"isn't equal to\"; }\n  static const char* NegatedDesc() { return \"is equal to\"; }\n};\ntemplate <typename Rhs>\nclass LtMatcher : public ComparisonBase<LtMatcher<Rhs>, Rhs, AnyLt> {\n public:\n  explicit LtMatcher(const Rhs& rhs)\n      : ComparisonBase<LtMatcher<Rhs>, Rhs, AnyLt>(rhs) { }\n  static const char* Desc() { return \"is <\"; }\n  static const char* NegatedDesc() { return \"isn't <\"; }\n};\ntemplate <typename Rhs>\nclass GtMatcher : public ComparisonBase<GtMatcher<Rhs>, Rhs, AnyGt> {\n public:\n  explicit GtMatcher(const Rhs& rhs)\n      : ComparisonBase<GtMatcher<Rhs>, Rhs, AnyGt>(rhs) { }\n  static const char* Desc() { return \"is >\"; }\n  static const char* NegatedDesc() { return \"isn't >\"; }\n};\ntemplate <typename Rhs>\nclass LeMatcher : public ComparisonBase<LeMatcher<Rhs>, Rhs, AnyLe> {\n public:\n  explicit LeMatcher(const Rhs& rhs)\n      : ComparisonBase<LeMatcher<Rhs>, Rhs, AnyLe>(rhs) { }\n  static const char* Desc() { return \"is <=\"; }\n  static const char* NegatedDesc() { return \"isn't <=\"; }\n};\ntemplate <typename Rhs>\nclass GeMatcher : public ComparisonBase<GeMatcher<Rhs>, Rhs, AnyGe> {\n public:\n  explicit GeMatcher(const Rhs& rhs)\n      : ComparisonBase<GeMatcher<Rhs>, Rhs, AnyGe>(rhs) { }\n  static const char* Desc() { return \"is >=\"; }\n  static const char* NegatedDesc() { return \"isn't >=\"; }\n};\n\n// Implements the polymorphic IsNull() matcher, which matches any raw or smart\n// pointer that is NULL.\nclass IsNullMatcher {\n public:\n  template <typename Pointer>\n  bool MatchAndExplain(const Pointer& p,\n                       MatchResultListener* /* listener */) const {\n#if GTEST_LANG_CXX11\n    return p == nullptr;\n#else  // GTEST_LANG_CXX11\n    return GetRawPointer(p) == NULL;\n#endif  // GTEST_LANG_CXX11\n  }\n\n  void DescribeTo(::std::ostream* os) const { *os << \"is NULL\"; }\n  void DescribeNegationTo(::std::ostream* os) const {\n    *os << \"isn't NULL\";\n  }\n};\n\n// Implements the polymorphic NotNull() matcher, which matches any raw or smart\n// pointer that is not NULL.\nclass NotNullMatcher {\n public:\n  template <typename Pointer>\n  bool MatchAndExplain(const Pointer& p,\n                       MatchResultListener* /* listener */) const {\n#if GTEST_LANG_CXX11\n    return p != nullptr;\n#else  // GTEST_LANG_CXX11\n    return GetRawPointer(p) != NULL;\n#endif  // GTEST_LANG_CXX11\n  }\n\n  void DescribeTo(::std::ostream* os) const { *os << \"isn't NULL\"; }\n  void DescribeNegationTo(::std::ostream* os) const {\n    *os << \"is NULL\";\n  }\n};\n\n// Ref(variable) matches any argument that is a reference to\n// 'variable'.  This matcher is polymorphic as it can match any\n// super type of the type of 'variable'.\n//\n// The RefMatcher template class implements Ref(variable).  It can\n// only be instantiated with a reference type.  This prevents a user\n// from mistakenly using Ref(x) to match a non-reference function\n// argument.  For example, the following will righteously cause a\n// compiler error:\n//\n//   int n;\n//   Matcher<int> m1 = Ref(n);   // This won't compile.\n//   Matcher<int&> m2 = Ref(n);  // This will compile.\ntemplate <typename T>\nclass RefMatcher;\n\ntemplate <typename T>\nclass RefMatcher<T&> {\n  // Google Mock is a generic framework and thus needs to support\n  // mocking any function types, including those that take non-const\n  // reference arguments.  Therefore the template parameter T (and\n  // Super below) can be instantiated to either a const type or a\n  // non-const type.\n public:\n  // RefMatcher() takes a T& instead of const T&, as we want the\n  // compiler to catch using Ref(const_value) as a matcher for a\n  // non-const reference.\n  explicit RefMatcher(T& x) : object_(x) {}  // NOLINT\n\n  template <typename Super>\n  operator Matcher<Super&>() const {\n    // By passing object_ (type T&) to Impl(), which expects a Super&,\n    // we make sure that Super is a super type of T.  In particular,\n    // this catches using Ref(const_value) as a matcher for a\n    // non-const reference, as you cannot implicitly convert a const\n    // reference to a non-const reference.\n    return MakeMatcher(new Impl<Super>(object_));\n  }\n\n private:\n  template <typename Super>\n  class Impl : public MatcherInterface<Super&> {\n   public:\n    explicit Impl(Super& x) : object_(x) {}  // NOLINT\n\n    // MatchAndExplain() takes a Super& (as opposed to const Super&)\n    // in order to match the interface MatcherInterface<Super&>.\n    virtual bool MatchAndExplain(\n        Super& x, MatchResultListener* listener) const {\n      *listener << \"which is located @\" << static_cast<const void*>(&x);\n      return &x == &object_;\n    }\n\n    virtual void DescribeTo(::std::ostream* os) const {\n      *os << \"references the variable \";\n      UniversalPrinter<Super&>::Print(object_, os);\n    }\n\n    virtual void DescribeNegationTo(::std::ostream* os) const {\n      *os << \"does not reference the variable \";\n      UniversalPrinter<Super&>::Print(object_, os);\n    }\n\n   private:\n    const Super& object_;\n\n    GTEST_DISALLOW_ASSIGN_(Impl);\n  };\n\n  T& object_;\n\n  GTEST_DISALLOW_ASSIGN_(RefMatcher);\n};\n\n// Polymorphic helper functions for narrow and wide string matchers.\ninline bool CaseInsensitiveCStringEquals(const char* lhs, const char* rhs) {\n  return String::CaseInsensitiveCStringEquals(lhs, rhs);\n}\n\ninline bool CaseInsensitiveCStringEquals(const wchar_t* lhs,\n                                         const wchar_t* rhs) {\n  return String::CaseInsensitiveWideCStringEquals(lhs, rhs);\n}\n\n// String comparison for narrow or wide strings that can have embedded NUL\n// characters.\ntemplate <typename StringType>\nbool CaseInsensitiveStringEquals(const StringType& s1,\n                                 const StringType& s2) {\n  // Are the heads equal?\n  if (!CaseInsensitiveCStringEquals(s1.c_str(), s2.c_str())) {\n    return false;\n  }\n\n  // Skip the equal heads.\n  const typename StringType::value_type nul = 0;\n  const size_t i1 = s1.find(nul), i2 = s2.find(nul);\n\n  // Are we at the end of either s1 or s2?\n  if (i1 == StringType::npos || i2 == StringType::npos) {\n    return i1 == i2;\n  }\n\n  // Are the tails equal?\n  return CaseInsensitiveStringEquals(s1.substr(i1 + 1), s2.substr(i2 + 1));\n}\n\n// String matchers.\n\n// Implements equality-based string matchers like StrEq, StrCaseNe, and etc.\ntemplate <typename StringType>\nclass StrEqualityMatcher {\n public:\n  StrEqualityMatcher(const StringType& str, bool expect_eq,\n                     bool case_sensitive)\n      : string_(str), expect_eq_(expect_eq), case_sensitive_(case_sensitive) {}\n\n  // Accepts pointer types, particularly:\n  //   const char*\n  //   char*\n  //   const wchar_t*\n  //   wchar_t*\n  template <typename CharType>\n  bool MatchAndExplain(CharType* s, MatchResultListener* listener) const {\n    if (s == NULL) {\n      return !expect_eq_;\n    }\n    return MatchAndExplain(StringType(s), listener);\n  }\n\n  // Matches anything that can convert to StringType.\n  //\n  // This is a template, not just a plain function with const StringType&,\n  // because StringPiece has some interfering non-explicit constructors.\n  template <typename MatcheeStringType>\n  bool MatchAndExplain(const MatcheeStringType& s,\n                       MatchResultListener* /* listener */) const {\n    const StringType& s2(s);\n    const bool eq = case_sensitive_ ? s2 == string_ :\n        CaseInsensitiveStringEquals(s2, string_);\n    return expect_eq_ == eq;\n  }\n\n  void DescribeTo(::std::ostream* os) const {\n    DescribeToHelper(expect_eq_, os);\n  }\n\n  void DescribeNegationTo(::std::ostream* os) const {\n    DescribeToHelper(!expect_eq_, os);\n  }\n\n private:\n  void DescribeToHelper(bool expect_eq, ::std::ostream* os) const {\n    *os << (expect_eq ? \"is \" : \"isn't \");\n    *os << \"equal to \";\n    if (!case_sensitive_) {\n      *os << \"(ignoring case) \";\n    }\n    UniversalPrint(string_, os);\n  }\n\n  const StringType string_;\n  const bool expect_eq_;\n  const bool case_sensitive_;\n\n  GTEST_DISALLOW_ASSIGN_(StrEqualityMatcher);\n};\n\n// Implements the polymorphic HasSubstr(substring) matcher, which\n// can be used as a Matcher<T> as long as T can be converted to a\n// string.\ntemplate <typename StringType>\nclass HasSubstrMatcher {\n public:\n  explicit HasSubstrMatcher(const StringType& substring)\n      : substring_(substring) {}\n\n  // Accepts pointer types, particularly:\n  //   const char*\n  //   char*\n  //   const wchar_t*\n  //   wchar_t*\n  template <typename CharType>\n  bool MatchAndExplain(CharType* s, MatchResultListener* listener) const {\n    return s != NULL && MatchAndExplain(StringType(s), listener);\n  }\n\n  // Matches anything that can convert to StringType.\n  //\n  // This is a template, not just a plain function with const StringType&,\n  // because StringPiece has some interfering non-explicit constructors.\n  template <typename MatcheeStringType>\n  bool MatchAndExplain(const MatcheeStringType& s,\n                       MatchResultListener* /* listener */) const {\n    const StringType& s2(s);\n    return s2.find(substring_) != StringType::npos;\n  }\n\n  // Describes what this matcher matches.\n  void DescribeTo(::std::ostream* os) const {\n    *os << \"has substring \";\n    UniversalPrint(substring_, os);\n  }\n\n  void DescribeNegationTo(::std::ostream* os) const {\n    *os << \"has no substring \";\n    UniversalPrint(substring_, os);\n  }\n\n private:\n  const StringType substring_;\n\n  GTEST_DISALLOW_ASSIGN_(HasSubstrMatcher);\n};\n\n// Implements the polymorphic StartsWith(substring) matcher, which\n// can be used as a Matcher<T> as long as T can be converted to a\n// string.\ntemplate <typename StringType>\nclass StartsWithMatcher {\n public:\n  explicit StartsWithMatcher(const StringType& prefix) : prefix_(prefix) {\n  }\n\n  // Accepts pointer types, particularly:\n  //   const char*\n  //   char*\n  //   const wchar_t*\n  //   wchar_t*\n  template <typename CharType>\n  bool MatchAndExplain(CharType* s, MatchResultListener* listener) const {\n    return s != NULL && MatchAndExplain(StringType(s), listener);\n  }\n\n  // Matches anything that can convert to StringType.\n  //\n  // This is a template, not just a plain function with const StringType&,\n  // because StringPiece has some interfering non-explicit constructors.\n  template <typename MatcheeStringType>\n  bool MatchAndExplain(const MatcheeStringType& s,\n                       MatchResultListener* /* listener */) const {\n    const StringType& s2(s);\n    return s2.length() >= prefix_.length() &&\n        s2.substr(0, prefix_.length()) == prefix_;\n  }\n\n  void DescribeTo(::std::ostream* os) const {\n    *os << \"starts with \";\n    UniversalPrint(prefix_, os);\n  }\n\n  void DescribeNegationTo(::std::ostream* os) const {\n    *os << \"doesn't start with \";\n    UniversalPrint(prefix_, os);\n  }\n\n private:\n  const StringType prefix_;\n\n  GTEST_DISALLOW_ASSIGN_(StartsWithMatcher);\n};\n\n// Implements the polymorphic EndsWith(substring) matcher, which\n// can be used as a Matcher<T> as long as T can be converted to a\n// string.\ntemplate <typename StringType>\nclass EndsWithMatcher {\n public:\n  explicit EndsWithMatcher(const StringType& suffix) : suffix_(suffix) {}\n\n  // Accepts pointer types, particularly:\n  //   const char*\n  //   char*\n  //   const wchar_t*\n  //   wchar_t*\n  template <typename CharType>\n  bool MatchAndExplain(CharType* s, MatchResultListener* listener) const {\n    return s != NULL && MatchAndExplain(StringType(s), listener);\n  }\n\n  // Matches anything that can convert to StringType.\n  //\n  // This is a template, not just a plain function with const StringType&,\n  // because StringPiece has some interfering non-explicit constructors.\n  template <typename MatcheeStringType>\n  bool MatchAndExplain(const MatcheeStringType& s,\n                       MatchResultListener* /* listener */) const {\n    const StringType& s2(s);\n    return s2.length() >= suffix_.length() &&\n        s2.substr(s2.length() - suffix_.length()) == suffix_;\n  }\n\n  void DescribeTo(::std::ostream* os) const {\n    *os << \"ends with \";\n    UniversalPrint(suffix_, os);\n  }\n\n  void DescribeNegationTo(::std::ostream* os) const {\n    *os << \"doesn't end with \";\n    UniversalPrint(suffix_, os);\n  }\n\n private:\n  const StringType suffix_;\n\n  GTEST_DISALLOW_ASSIGN_(EndsWithMatcher);\n};\n\n// Implements polymorphic matchers MatchesRegex(regex) and\n// ContainsRegex(regex), which can be used as a Matcher<T> as long as\n// T can be converted to a string.\nclass MatchesRegexMatcher {\n public:\n  MatchesRegexMatcher(const RE* regex, bool full_match)\n      : regex_(regex), full_match_(full_match) {}\n\n  // Accepts pointer types, particularly:\n  //   const char*\n  //   char*\n  //   const wchar_t*\n  //   wchar_t*\n  template <typename CharType>\n  bool MatchAndExplain(CharType* s, MatchResultListener* listener) const {\n    return s != NULL && MatchAndExplain(internal::string(s), listener);\n  }\n\n  // Matches anything that can convert to internal::string.\n  //\n  // This is a template, not just a plain function with const internal::string&,\n  // because StringPiece has some interfering non-explicit constructors.\n  template <class MatcheeStringType>\n  bool MatchAndExplain(const MatcheeStringType& s,\n                       MatchResultListener* /* listener */) const {\n    const internal::string& s2(s);\n    return full_match_ ? RE::FullMatch(s2, *regex_) :\n        RE::PartialMatch(s2, *regex_);\n  }\n\n  void DescribeTo(::std::ostream* os) const {\n    *os << (full_match_ ? \"matches\" : \"contains\")\n        << \" regular expression \";\n    UniversalPrinter<internal::string>::Print(regex_->pattern(), os);\n  }\n\n  void DescribeNegationTo(::std::ostream* os) const {\n    *os << \"doesn't \" << (full_match_ ? \"match\" : \"contain\")\n        << \" regular expression \";\n    UniversalPrinter<internal::string>::Print(regex_->pattern(), os);\n  }\n\n private:\n  const internal::linked_ptr<const RE> regex_;\n  const bool full_match_;\n\n  GTEST_DISALLOW_ASSIGN_(MatchesRegexMatcher);\n};\n\n// Implements a matcher that compares the two fields of a 2-tuple\n// using one of the ==, <=, <, etc, operators.  The two fields being\n// compared don't have to have the same type.\n//\n// The matcher defined here is polymorphic (for example, Eq() can be\n// used to match a tuple<int, short>, a tuple<const long&, double>,\n// etc).  Therefore we use a template type conversion operator in the\n// implementation.\ntemplate <typename D, typename Op>\nclass PairMatchBase {\n public:\n  template <typename T1, typename T2>\n  operator Matcher< ::testing::tuple<T1, T2> >() const {\n    return MakeMatcher(new Impl< ::testing::tuple<T1, T2> >);\n  }\n  template <typename T1, typename T2>\n  operator Matcher<const ::testing::tuple<T1, T2>&>() const {\n    return MakeMatcher(new Impl<const ::testing::tuple<T1, T2>&>);\n  }\n\n private:\n  static ::std::ostream& GetDesc(::std::ostream& os) {  // NOLINT\n    return os << D::Desc();\n  }\n\n  template <typename Tuple>\n  class Impl : public MatcherInterface<Tuple> {\n   public:\n    virtual bool MatchAndExplain(\n        Tuple args,\n        MatchResultListener* /* listener */) const {\n      return Op()(::testing::get<0>(args), ::testing::get<1>(args));\n    }\n    virtual void DescribeTo(::std::ostream* os) const {\n      *os << \"are \" << GetDesc;\n    }\n    virtual void DescribeNegationTo(::std::ostream* os) const {\n      *os << \"aren't \" << GetDesc;\n    }\n  };\n};\n\nclass Eq2Matcher : public PairMatchBase<Eq2Matcher, AnyEq> {\n public:\n  static const char* Desc() { return \"an equal pair\"; }\n};\nclass Ne2Matcher : public PairMatchBase<Ne2Matcher, AnyNe> {\n public:\n  static const char* Desc() { return \"an unequal pair\"; }\n};\nclass Lt2Matcher : public PairMatchBase<Lt2Matcher, AnyLt> {\n public:\n  static const char* Desc() { return \"a pair where the first < the second\"; }\n};\nclass Gt2Matcher : public PairMatchBase<Gt2Matcher, AnyGt> {\n public:\n  static const char* Desc() { return \"a pair where the first > the second\"; }\n};\nclass Le2Matcher : public PairMatchBase<Le2Matcher, AnyLe> {\n public:\n  static const char* Desc() { return \"a pair where the first <= the second\"; }\n};\nclass Ge2Matcher : public PairMatchBase<Ge2Matcher, AnyGe> {\n public:\n  static const char* Desc() { return \"a pair where the first >= the second\"; }\n};\n\n// Implements the Not(...) matcher for a particular argument type T.\n// We do not nest it inside the NotMatcher class template, as that\n// will prevent different instantiations of NotMatcher from sharing\n// the same NotMatcherImpl<T> class.\ntemplate <typename T>\nclass NotMatcherImpl : public MatcherInterface<T> {\n public:\n  explicit NotMatcherImpl(const Matcher<T>& matcher)\n      : matcher_(matcher) {}\n\n  virtual bool MatchAndExplain(T x, MatchResultListener* listener) const {\n    return !matcher_.MatchAndExplain(x, listener);\n  }\n\n  virtual void DescribeTo(::std::ostream* os) const {\n    matcher_.DescribeNegationTo(os);\n  }\n\n  virtual void DescribeNegationTo(::std::ostream* os) const {\n    matcher_.DescribeTo(os);\n  }\n\n private:\n  const Matcher<T> matcher_;\n\n  GTEST_DISALLOW_ASSIGN_(NotMatcherImpl);\n};\n\n// Implements the Not(m) matcher, which matches a value that doesn't\n// match matcher m.\ntemplate <typename InnerMatcher>\nclass NotMatcher {\n public:\n  explicit NotMatcher(InnerMatcher matcher) : matcher_(matcher) {}\n\n  // This template type conversion operator allows Not(m) to be used\n  // to match any type m can match.\n  template <typename T>\n  operator Matcher<T>() const {\n    return Matcher<T>(new NotMatcherImpl<T>(SafeMatcherCast<T>(matcher_)));\n  }\n\n private:\n  InnerMatcher matcher_;\n\n  GTEST_DISALLOW_ASSIGN_(NotMatcher);\n};\n\n// Implements the AllOf(m1, m2) matcher for a particular argument type\n// T. We do not nest it inside the BothOfMatcher class template, as\n// that will prevent different instantiations of BothOfMatcher from\n// sharing the same BothOfMatcherImpl<T> class.\ntemplate <typename T>\nclass BothOfMatcherImpl : public MatcherInterface<T> {\n public:\n  BothOfMatcherImpl(const Matcher<T>& matcher1, const Matcher<T>& matcher2)\n      : matcher1_(matcher1), matcher2_(matcher2) {}\n\n  virtual void DescribeTo(::std::ostream* os) const {\n    *os << \"(\";\n    matcher1_.DescribeTo(os);\n    *os << \") and (\";\n    matcher2_.DescribeTo(os);\n    *os << \")\";\n  }\n\n  virtual void DescribeNegationTo(::std::ostream* os) const {\n    *os << \"(\";\n    matcher1_.DescribeNegationTo(os);\n    *os << \") or (\";\n    matcher2_.DescribeNegationTo(os);\n    *os << \")\";\n  }\n\n  virtual bool MatchAndExplain(T x, MatchResultListener* listener) const {\n    // If either matcher1_ or matcher2_ doesn't match x, we only need\n    // to explain why one of them fails.\n    StringMatchResultListener listener1;\n    if (!matcher1_.MatchAndExplain(x, &listener1)) {\n      *listener << listener1.str();\n      return false;\n    }\n\n    StringMatchResultListener listener2;\n    if (!matcher2_.MatchAndExplain(x, &listener2)) {\n      *listener << listener2.str();\n      return false;\n    }\n\n    // Otherwise we need to explain why *both* of them match.\n    const internal::string s1 = listener1.str();\n    const internal::string s2 = listener2.str();\n\n    if (s1 == \"\") {\n      *listener << s2;\n    } else {\n      *listener << s1;\n      if (s2 != \"\") {\n        *listener << \", and \" << s2;\n      }\n    }\n    return true;\n  }\n\n private:\n  const Matcher<T> matcher1_;\n  const Matcher<T> matcher2_;\n\n  GTEST_DISALLOW_ASSIGN_(BothOfMatcherImpl);\n};\n\n#if GTEST_LANG_CXX11\n// MatcherList provides mechanisms for storing a variable number of matchers in\n// a list structure (ListType) and creating a combining matcher from such a\n// list.\n// The template is defined recursively using the following template paramters:\n//   * kSize is the length of the MatcherList.\n//   * Head is the type of the first matcher of the list.\n//   * Tail denotes the types of the remaining matchers of the list.\ntemplate <int kSize, typename Head, typename... Tail>\nstruct MatcherList {\n  typedef MatcherList<kSize - 1, Tail...> MatcherListTail;\n  typedef ::std::pair<Head, typename MatcherListTail::ListType> ListType;\n\n  // BuildList stores variadic type values in a nested pair structure.\n  // Example:\n  // MatcherList<3, int, string, float>::BuildList(5, \"foo\", 2.0) will return\n  // the corresponding result of type pair<int, pair<string, float>>.\n  static ListType BuildList(const Head& matcher, const Tail&... tail) {\n    return ListType(matcher, MatcherListTail::BuildList(tail...));\n  }\n\n  // CreateMatcher<T> creates a Matcher<T> from a given list of matchers (built\n  // by BuildList()). CombiningMatcher<T> is used to combine the matchers of the\n  // list. CombiningMatcher<T> must implement MatcherInterface<T> and have a\n  // constructor taking two Matcher<T>s as input.\n  template <typename T, template <typename /* T */> class CombiningMatcher>\n  static Matcher<T> CreateMatcher(const ListType& matchers) {\n    return Matcher<T>(new CombiningMatcher<T>(\n        SafeMatcherCast<T>(matchers.first),\n        MatcherListTail::template CreateMatcher<T, CombiningMatcher>(\n            matchers.second)));\n  }\n};\n\n// The following defines the base case for the recursive definition of\n// MatcherList.\ntemplate <typename Matcher1, typename Matcher2>\nstruct MatcherList<2, Matcher1, Matcher2> {\n  typedef ::std::pair<Matcher1, Matcher2> ListType;\n\n  static ListType BuildList(const Matcher1& matcher1,\n                            const Matcher2& matcher2) {\n    return ::std::pair<Matcher1, Matcher2>(matcher1, matcher2);\n  }\n\n  template <typename T, template <typename /* T */> class CombiningMatcher>\n  static Matcher<T> CreateMatcher(const ListType& matchers) {\n    return Matcher<T>(new CombiningMatcher<T>(\n        SafeMatcherCast<T>(matchers.first),\n        SafeMatcherCast<T>(matchers.second)));\n  }\n};\n\n// VariadicMatcher is used for the variadic implementation of\n// AllOf(m_1, m_2, ...) and AnyOf(m_1, m_2, ...).\n// CombiningMatcher<T> is used to recursively combine the provided matchers\n// (of type Args...).\ntemplate <template <typename T> class CombiningMatcher, typename... Args>\nclass VariadicMatcher {\n public:\n  VariadicMatcher(const Args&... matchers)  // NOLINT\n      : matchers_(MatcherListType::BuildList(matchers...)) {}\n\n  // This template type conversion operator allows an\n  // VariadicMatcher<Matcher1, Matcher2...> object to match any type that\n  // all of the provided matchers (Matcher1, Matcher2, ...) can match.\n  template <typename T>\n  operator Matcher<T>() const {\n    return MatcherListType::template CreateMatcher<T, CombiningMatcher>(\n        matchers_);\n  }\n\n private:\n  typedef MatcherList<sizeof...(Args), Args...> MatcherListType;\n\n  const typename MatcherListType::ListType matchers_;\n\n  GTEST_DISALLOW_ASSIGN_(VariadicMatcher);\n};\n\ntemplate <typename... Args>\nusing AllOfMatcher = VariadicMatcher<BothOfMatcherImpl, Args...>;\n\n#endif  // GTEST_LANG_CXX11\n\n// Used for implementing the AllOf(m_1, ..., m_n) matcher, which\n// matches a value that matches all of the matchers m_1, ..., and m_n.\ntemplate <typename Matcher1, typename Matcher2>\nclass BothOfMatcher {\n public:\n  BothOfMatcher(Matcher1 matcher1, Matcher2 matcher2)\n      : matcher1_(matcher1), matcher2_(matcher2) {}\n\n  // This template type conversion operator allows a\n  // BothOfMatcher<Matcher1, Matcher2> object to match any type that\n  // both Matcher1 and Matcher2 can match.\n  template <typename T>\n  operator Matcher<T>() const {\n    return Matcher<T>(new BothOfMatcherImpl<T>(SafeMatcherCast<T>(matcher1_),\n                                               SafeMatcherCast<T>(matcher2_)));\n  }\n\n private:\n  Matcher1 matcher1_;\n  Matcher2 matcher2_;\n\n  GTEST_DISALLOW_ASSIGN_(BothOfMatcher);\n};\n\n// Implements the AnyOf(m1, m2) matcher for a particular argument type\n// T.  We do not nest it inside the AnyOfMatcher class template, as\n// that will prevent different instantiations of AnyOfMatcher from\n// sharing the same EitherOfMatcherImpl<T> class.\ntemplate <typename T>\nclass EitherOfMatcherImpl : public MatcherInterface<T> {\n public:\n  EitherOfMatcherImpl(const Matcher<T>& matcher1, const Matcher<T>& matcher2)\n      : matcher1_(matcher1), matcher2_(matcher2) {}\n\n  virtual void DescribeTo(::std::ostream* os) const {\n    *os << \"(\";\n    matcher1_.DescribeTo(os);\n    *os << \") or (\";\n    matcher2_.DescribeTo(os);\n    *os << \")\";\n  }\n\n  virtual void DescribeNegationTo(::std::ostream* os) const {\n    *os << \"(\";\n    matcher1_.DescribeNegationTo(os);\n    *os << \") and (\";\n    matcher2_.DescribeNegationTo(os);\n    *os << \")\";\n  }\n\n  virtual bool MatchAndExplain(T x, MatchResultListener* listener) const {\n    // If either matcher1_ or matcher2_ matches x, we just need to\n    // explain why *one* of them matches.\n    StringMatchResultListener listener1;\n    if (matcher1_.MatchAndExplain(x, &listener1)) {\n      *listener << listener1.str();\n      return true;\n    }\n\n    StringMatchResultListener listener2;\n    if (matcher2_.MatchAndExplain(x, &listener2)) {\n      *listener << listener2.str();\n      return true;\n    }\n\n    // Otherwise we need to explain why *both* of them fail.\n    const internal::string s1 = listener1.str();\n    const internal::string s2 = listener2.str();\n\n    if (s1 == \"\") {\n      *listener << s2;\n    } else {\n      *listener << s1;\n      if (s2 != \"\") {\n        *listener << \", and \" << s2;\n      }\n    }\n    return false;\n  }\n\n private:\n  const Matcher<T> matcher1_;\n  const Matcher<T> matcher2_;\n\n  GTEST_DISALLOW_ASSIGN_(EitherOfMatcherImpl);\n};\n\n#if GTEST_LANG_CXX11\n// AnyOfMatcher is used for the variadic implementation of AnyOf(m_1, m_2, ...).\ntemplate <typename... Args>\nusing AnyOfMatcher = VariadicMatcher<EitherOfMatcherImpl, Args...>;\n\n#endif  // GTEST_LANG_CXX11\n\n// Used for implementing the AnyOf(m_1, ..., m_n) matcher, which\n// matches a value that matches at least one of the matchers m_1, ...,\n// and m_n.\ntemplate <typename Matcher1, typename Matcher2>\nclass EitherOfMatcher {\n public:\n  EitherOfMatcher(Matcher1 matcher1, Matcher2 matcher2)\n      : matcher1_(matcher1), matcher2_(matcher2) {}\n\n  // This template type conversion operator allows a\n  // EitherOfMatcher<Matcher1, Matcher2> object to match any type that\n  // both Matcher1 and Matcher2 can match.\n  template <typename T>\n  operator Matcher<T>() const {\n    return Matcher<T>(new EitherOfMatcherImpl<T>(\n        SafeMatcherCast<T>(matcher1_), SafeMatcherCast<T>(matcher2_)));\n  }\n\n private:\n  Matcher1 matcher1_;\n  Matcher2 matcher2_;\n\n  GTEST_DISALLOW_ASSIGN_(EitherOfMatcher);\n};\n\n// Used for implementing Truly(pred), which turns a predicate into a\n// matcher.\ntemplate <typename Predicate>\nclass TrulyMatcher {\n public:\n  explicit TrulyMatcher(Predicate pred) : predicate_(pred) {}\n\n  // This method template allows Truly(pred) to be used as a matcher\n  // for type T where T is the argument type of predicate 'pred'.  The\n  // argument is passed by reference as the predicate may be\n  // interested in the address of the argument.\n  template <typename T>\n  bool MatchAndExplain(T& x,  // NOLINT\n                       MatchResultListener* /* listener */) const {\n    // Without the if-statement, MSVC sometimes warns about converting\n    // a value to bool (warning 4800).\n    //\n    // We cannot write 'return !!predicate_(x);' as that doesn't work\n    // when predicate_(x) returns a class convertible to bool but\n    // having no operator!().\n    if (predicate_(x))\n      return true;\n    return false;\n  }\n\n  void DescribeTo(::std::ostream* os) const {\n    *os << \"satisfies the given predicate\";\n  }\n\n  void DescribeNegationTo(::std::ostream* os) const {\n    *os << \"doesn't satisfy the given predicate\";\n  }\n\n private:\n  Predicate predicate_;\n\n  GTEST_DISALLOW_ASSIGN_(TrulyMatcher);\n};\n\n// Used for implementing Matches(matcher), which turns a matcher into\n// a predicate.\ntemplate <typename M>\nclass MatcherAsPredicate {\n public:\n  explicit MatcherAsPredicate(M matcher) : matcher_(matcher) {}\n\n  // This template operator() allows Matches(m) to be used as a\n  // predicate on type T where m is a matcher on type T.\n  //\n  // The argument x is passed by reference instead of by value, as\n  // some matcher may be interested in its address (e.g. as in\n  // Matches(Ref(n))(x)).\n  template <typename T>\n  bool operator()(const T& x) const {\n    // We let matcher_ commit to a particular type here instead of\n    // when the MatcherAsPredicate object was constructed.  This\n    // allows us to write Matches(m) where m is a polymorphic matcher\n    // (e.g. Eq(5)).\n    //\n    // If we write Matcher<T>(matcher_).Matches(x) here, it won't\n    // compile when matcher_ has type Matcher<const T&>; if we write\n    // Matcher<const T&>(matcher_).Matches(x) here, it won't compile\n    // when matcher_ has type Matcher<T>; if we just write\n    // matcher_.Matches(x), it won't compile when matcher_ is\n    // polymorphic, e.g. Eq(5).\n    //\n    // MatcherCast<const T&>() is necessary for making the code work\n    // in all of the above situations.\n    return MatcherCast<const T&>(matcher_).Matches(x);\n  }\n\n private:\n  M matcher_;\n\n  GTEST_DISALLOW_ASSIGN_(MatcherAsPredicate);\n};\n\n// For implementing ASSERT_THAT() and EXPECT_THAT().  The template\n// argument M must be a type that can be converted to a matcher.\ntemplate <typename M>\nclass PredicateFormatterFromMatcher {\n public:\n  explicit PredicateFormatterFromMatcher(M m) : matcher_(internal::move(m)) {}\n\n  // This template () operator allows a PredicateFormatterFromMatcher\n  // object to act as a predicate-formatter suitable for using with\n  // Google Test's EXPECT_PRED_FORMAT1() macro.\n  template <typename T>\n  AssertionResult operator()(const char* value_text, const T& x) const {\n    // We convert matcher_ to a Matcher<const T&> *now* instead of\n    // when the PredicateFormatterFromMatcher object was constructed,\n    // as matcher_ may be polymorphic (e.g. NotNull()) and we won't\n    // know which type to instantiate it to until we actually see the\n    // type of x here.\n    //\n    // We write SafeMatcherCast<const T&>(matcher_) instead of\n    // Matcher<const T&>(matcher_), as the latter won't compile when\n    // matcher_ has type Matcher<T> (e.g. An<int>()).\n    // We don't write MatcherCast<const T&> either, as that allows\n    // potentially unsafe downcasting of the matcher argument.\n    const Matcher<const T&> matcher = SafeMatcherCast<const T&>(matcher_);\n    StringMatchResultListener listener;\n    if (MatchPrintAndExplain(x, matcher, &listener))\n      return AssertionSuccess();\n\n    ::std::stringstream ss;\n    ss << \"Value of: \" << value_text << \"\\n\"\n       << \"Expected: \";\n    matcher.DescribeTo(&ss);\n    ss << \"\\n  Actual: \" << listener.str();\n    return AssertionFailure() << ss.str();\n  }\n\n private:\n  const M matcher_;\n\n  GTEST_DISALLOW_ASSIGN_(PredicateFormatterFromMatcher);\n};\n\n// A helper function for converting a matcher to a predicate-formatter\n// without the user needing to explicitly write the type.  This is\n// used for implementing ASSERT_THAT() and EXPECT_THAT().\n// Implementation detail: 'matcher' is received by-value to force decaying.\ntemplate <typename M>\ninline PredicateFormatterFromMatcher<M>\nMakePredicateFormatterFromMatcher(M matcher) {\n  return PredicateFormatterFromMatcher<M>(internal::move(matcher));\n}\n\n// Implements the polymorphic floating point equality matcher, which matches\n// two float values using ULP-based approximation or, optionally, a\n// user-specified epsilon.  The template is meant to be instantiated with\n// FloatType being either float or double.\ntemplate <typename FloatType>\nclass FloatingEqMatcher {\n public:\n  // Constructor for FloatingEqMatcher.\n  // The matcher's input will be compared with expected.  The matcher treats two\n  // NANs as equal if nan_eq_nan is true.  Otherwise, under IEEE standards,\n  // equality comparisons between NANs will always return false.  We specify a\n  // negative max_abs_error_ term to indicate that ULP-based approximation will\n  // be used for comparison.\n  FloatingEqMatcher(FloatType expected, bool nan_eq_nan) :\n    expected_(expected), nan_eq_nan_(nan_eq_nan), max_abs_error_(-1) {\n  }\n\n  // Constructor that supports a user-specified max_abs_error that will be used\n  // for comparison instead of ULP-based approximation.  The max absolute\n  // should be non-negative.\n  FloatingEqMatcher(FloatType expected, bool nan_eq_nan,\n                    FloatType max_abs_error)\n      : expected_(expected),\n        nan_eq_nan_(nan_eq_nan),\n        max_abs_error_(max_abs_error) {\n    GTEST_CHECK_(max_abs_error >= 0)\n        << \", where max_abs_error is\" << max_abs_error;\n  }\n\n  // Implements floating point equality matcher as a Matcher<T>.\n  template <typename T>\n  class Impl : public MatcherInterface<T> {\n   public:\n    Impl(FloatType expected, bool nan_eq_nan, FloatType max_abs_error)\n        : expected_(expected),\n          nan_eq_nan_(nan_eq_nan),\n          max_abs_error_(max_abs_error) {}\n\n    virtual bool MatchAndExplain(T value,\n                                 MatchResultListener* listener) const {\n      const FloatingPoint<FloatType> actual(value), expected(expected_);\n\n      // Compares NaNs first, if nan_eq_nan_ is true.\n      if (actual.is_nan() || expected.is_nan()) {\n        if (actual.is_nan() && expected.is_nan()) {\n          return nan_eq_nan_;\n        }\n        // One is nan; the other is not nan.\n        return false;\n      }\n      if (HasMaxAbsError()) {\n        // We perform an equality check so that inf will match inf, regardless\n        // of error bounds.  If the result of value - expected_ would result in\n        // overflow or if either value is inf, the default result is infinity,\n        // which should only match if max_abs_error_ is also infinity.\n        if (value == expected_) {\n          return true;\n        }\n\n        const FloatType diff = value - expected_;\n        if (fabs(diff) <= max_abs_error_) {\n          return true;\n        }\n\n        if (listener->IsInterested()) {\n          *listener << \"which is \" << diff << \" from \" << expected_;\n        }\n        return false;\n      } else {\n        return actual.AlmostEquals(expected);\n      }\n    }\n\n    virtual void DescribeTo(::std::ostream* os) const {\n      // os->precision() returns the previously set precision, which we\n      // store to restore the ostream to its original configuration\n      // after outputting.\n      const ::std::streamsize old_precision = os->precision(\n          ::std::numeric_limits<FloatType>::digits10 + 2);\n      if (FloatingPoint<FloatType>(expected_).is_nan()) {\n        if (nan_eq_nan_) {\n          *os << \"is NaN\";\n        } else {\n          *os << \"never matches\";\n        }\n      } else {\n        *os << \"is approximately \" << expected_;\n        if (HasMaxAbsError()) {\n          *os << \" (absolute error <= \" << max_abs_error_ << \")\";\n        }\n      }\n      os->precision(old_precision);\n    }\n\n    virtual void DescribeNegationTo(::std::ostream* os) const {\n      // As before, get original precision.\n      const ::std::streamsize old_precision = os->precision(\n          ::std::numeric_limits<FloatType>::digits10 + 2);\n      if (FloatingPoint<FloatType>(expected_).is_nan()) {\n        if (nan_eq_nan_) {\n          *os << \"isn't NaN\";\n        } else {\n          *os << \"is anything\";\n        }\n      } else {\n        *os << \"isn't approximately \" << expected_;\n        if (HasMaxAbsError()) {\n          *os << \" (absolute error > \" << max_abs_error_ << \")\";\n        }\n      }\n      // Restore original precision.\n      os->precision(old_precision);\n    }\n\n   private:\n    bool HasMaxAbsError() const {\n      return max_abs_error_ >= 0;\n    }\n\n    const FloatType expected_;\n    const bool nan_eq_nan_;\n    // max_abs_error will be used for value comparison when >= 0.\n    const FloatType max_abs_error_;\n\n    GTEST_DISALLOW_ASSIGN_(Impl);\n  };\n\n  // The following 3 type conversion operators allow FloatEq(expected) and\n  // NanSensitiveFloatEq(expected) to be used as a Matcher<float>, a\n  // Matcher<const float&>, or a Matcher<float&>, but nothing else.\n  // (While Google's C++ coding style doesn't allow arguments passed\n  // by non-const reference, we may see them in code not conforming to\n  // the style.  Therefore Google Mock needs to support them.)\n  operator Matcher<FloatType>() const {\n    return MakeMatcher(\n        new Impl<FloatType>(expected_, nan_eq_nan_, max_abs_error_));\n  }\n\n  operator Matcher<const FloatType&>() const {\n    return MakeMatcher(\n        new Impl<const FloatType&>(expected_, nan_eq_nan_, max_abs_error_));\n  }\n\n  operator Matcher<FloatType&>() const {\n    return MakeMatcher(\n        new Impl<FloatType&>(expected_, nan_eq_nan_, max_abs_error_));\n  }\n\n private:\n  const FloatType expected_;\n  const bool nan_eq_nan_;\n  // max_abs_error will be used for value comparison when >= 0.\n  const FloatType max_abs_error_;\n\n  GTEST_DISALLOW_ASSIGN_(FloatingEqMatcher);\n};\n\n// Implements the Pointee(m) matcher for matching a pointer whose\n// pointee matches matcher m.  The pointer can be either raw or smart.\ntemplate <typename InnerMatcher>\nclass PointeeMatcher {\n public:\n  explicit PointeeMatcher(const InnerMatcher& matcher) : matcher_(matcher) {}\n\n  // This type conversion operator template allows Pointee(m) to be\n  // used as a matcher for any pointer type whose pointee type is\n  // compatible with the inner matcher, where type Pointer can be\n  // either a raw pointer or a smart pointer.\n  //\n  // The reason we do this instead of relying on\n  // MakePolymorphicMatcher() is that the latter is not flexible\n  // enough for implementing the DescribeTo() method of Pointee().\n  template <typename Pointer>\n  operator Matcher<Pointer>() const {\n    return MakeMatcher(new Impl<Pointer>(matcher_));\n  }\n\n private:\n  // The monomorphic implementation that works for a particular pointer type.\n  template <typename Pointer>\n  class Impl : public MatcherInterface<Pointer> {\n   public:\n    typedef typename PointeeOf<GTEST_REMOVE_CONST_(  // NOLINT\n        GTEST_REMOVE_REFERENCE_(Pointer))>::type Pointee;\n\n    explicit Impl(const InnerMatcher& matcher)\n        : matcher_(MatcherCast<const Pointee&>(matcher)) {}\n\n    virtual void DescribeTo(::std::ostream* os) const {\n      *os << \"points to a value that \";\n      matcher_.DescribeTo(os);\n    }\n\n    virtual void DescribeNegationTo(::std::ostream* os) const {\n      *os << \"does not point to a value that \";\n      matcher_.DescribeTo(os);\n    }\n\n    virtual bool MatchAndExplain(Pointer pointer,\n                                 MatchResultListener* listener) const {\n      if (GetRawPointer(pointer) == NULL)\n        return false;\n\n      *listener << \"which points to \";\n      return MatchPrintAndExplain(*pointer, matcher_, listener);\n    }\n\n   private:\n    const Matcher<const Pointee&> matcher_;\n\n    GTEST_DISALLOW_ASSIGN_(Impl);\n  };\n\n  const InnerMatcher matcher_;\n\n  GTEST_DISALLOW_ASSIGN_(PointeeMatcher);\n};\n\n// Implements the WhenDynamicCastTo<T>(m) matcher that matches a pointer or\n// reference that matches inner_matcher when dynamic_cast<T> is applied.\n// The result of dynamic_cast<To> is forwarded to the inner matcher.\n// If To is a pointer and the cast fails, the inner matcher will receive NULL.\n// If To is a reference and the cast fails, this matcher returns false\n// immediately.\ntemplate <typename To>\nclass WhenDynamicCastToMatcherBase {\n public:\n  explicit WhenDynamicCastToMatcherBase(const Matcher<To>& matcher)\n      : matcher_(matcher) {}\n\n  void DescribeTo(::std::ostream* os) const {\n    GetCastTypeDescription(os);\n    matcher_.DescribeTo(os);\n  }\n\n  void DescribeNegationTo(::std::ostream* os) const {\n    GetCastTypeDescription(os);\n    matcher_.DescribeNegationTo(os);\n  }\n\n protected:\n  const Matcher<To> matcher_;\n\n  static string GetToName() {\n#if GTEST_HAS_RTTI\n    return GetTypeName<To>();\n#else  // GTEST_HAS_RTTI\n    return \"the target type\";\n#endif  // GTEST_HAS_RTTI\n  }\n\n private:\n  static void GetCastTypeDescription(::std::ostream* os) {\n    *os << \"when dynamic_cast to \" << GetToName() << \", \";\n  }\n\n  GTEST_DISALLOW_ASSIGN_(WhenDynamicCastToMatcherBase);\n};\n\n// Primary template.\n// To is a pointer. Cast and forward the result.\ntemplate <typename To>\nclass WhenDynamicCastToMatcher : public WhenDynamicCastToMatcherBase<To> {\n public:\n  explicit WhenDynamicCastToMatcher(const Matcher<To>& matcher)\n      : WhenDynamicCastToMatcherBase<To>(matcher) {}\n\n  template <typename From>\n  bool MatchAndExplain(From from, MatchResultListener* listener) const {\n    // TODO(sbenza): Add more detail on failures. ie did the dyn_cast fail?\n    To to = dynamic_cast<To>(from);\n    return MatchPrintAndExplain(to, this->matcher_, listener);\n  }\n};\n\n// Specialize for references.\n// In this case we return false if the dynamic_cast fails.\ntemplate <typename To>\nclass WhenDynamicCastToMatcher<To&> : public WhenDynamicCastToMatcherBase<To&> {\n public:\n  explicit WhenDynamicCastToMatcher(const Matcher<To&>& matcher)\n      : WhenDynamicCastToMatcherBase<To&>(matcher) {}\n\n  template <typename From>\n  bool MatchAndExplain(From& from, MatchResultListener* listener) const {\n    // We don't want an std::bad_cast here, so do the cast with pointers.\n    To* to = dynamic_cast<To*>(&from);\n    if (to == NULL) {\n      *listener << \"which cannot be dynamic_cast to \" << this->GetToName();\n      return false;\n    }\n    return MatchPrintAndExplain(*to, this->matcher_, listener);\n  }\n};\n\n// Implements the Field() matcher for matching a field (i.e. member\n// variable) of an object.\ntemplate <typename Class, typename FieldType>\nclass FieldMatcher {\n public:\n  FieldMatcher(FieldType Class::*field,\n               const Matcher<const FieldType&>& matcher)\n      : field_(field), matcher_(matcher) {}\n\n  void DescribeTo(::std::ostream* os) const {\n    *os << \"is an object whose given field \";\n    matcher_.DescribeTo(os);\n  }\n\n  void DescribeNegationTo(::std::ostream* os) const {\n    *os << \"is an object whose given field \";\n    matcher_.DescribeNegationTo(os);\n  }\n\n  template <typename T>\n  bool MatchAndExplain(const T& value, MatchResultListener* listener) const {\n    return MatchAndExplainImpl(\n        typename ::testing::internal::\n            is_pointer<GTEST_REMOVE_CONST_(T)>::type(),\n        value, listener);\n  }\n\n private:\n  // The first argument of MatchAndExplainImpl() is needed to help\n  // Symbian's C++ compiler choose which overload to use.  Its type is\n  // true_type iff the Field() matcher is used to match a pointer.\n  bool MatchAndExplainImpl(false_type /* is_not_pointer */, const Class& obj,\n                           MatchResultListener* listener) const {\n    *listener << \"whose given field is \";\n    return MatchPrintAndExplain(obj.*field_, matcher_, listener);\n  }\n\n  bool MatchAndExplainImpl(true_type /* is_pointer */, const Class* p,\n                           MatchResultListener* listener) const {\n    if (p == NULL)\n      return false;\n\n    *listener << \"which points to an object \";\n    // Since *p has a field, it must be a class/struct/union type and\n    // thus cannot be a pointer.  Therefore we pass false_type() as\n    // the first argument.\n    return MatchAndExplainImpl(false_type(), *p, listener);\n  }\n\n  const FieldType Class::*field_;\n  const Matcher<const FieldType&> matcher_;\n\n  GTEST_DISALLOW_ASSIGN_(FieldMatcher);\n};\n\n// Implements the Property() matcher for matching a property\n// (i.e. return value of a getter method) of an object.\ntemplate <typename Class, typename PropertyType>\nclass PropertyMatcher {\n public:\n  // The property may have a reference type, so 'const PropertyType&'\n  // may cause double references and fail to compile.  That's why we\n  // need GTEST_REFERENCE_TO_CONST, which works regardless of\n  // PropertyType being a reference or not.\n  typedef GTEST_REFERENCE_TO_CONST_(PropertyType) RefToConstProperty;\n\n  PropertyMatcher(PropertyType (Class::*property)() const,\n                  const Matcher<RefToConstProperty>& matcher)\n      : property_(property), matcher_(matcher) {}\n\n  void DescribeTo(::std::ostream* os) const {\n    *os << \"is an object whose given property \";\n    matcher_.DescribeTo(os);\n  }\n\n  void DescribeNegationTo(::std::ostream* os) const {\n    *os << \"is an object whose given property \";\n    matcher_.DescribeNegationTo(os);\n  }\n\n  template <typename T>\n  bool MatchAndExplain(const T&value, MatchResultListener* listener) const {\n    return MatchAndExplainImpl(\n        typename ::testing::internal::\n            is_pointer<GTEST_REMOVE_CONST_(T)>::type(),\n        value, listener);\n  }\n\n private:\n  // The first argument of MatchAndExplainImpl() is needed to help\n  // Symbian's C++ compiler choose which overload to use.  Its type is\n  // true_type iff the Property() matcher is used to match a pointer.\n  bool MatchAndExplainImpl(false_type /* is_not_pointer */, const Class& obj,\n                           MatchResultListener* listener) const {\n    *listener << \"whose given property is \";\n    // Cannot pass the return value (for example, int) to MatchPrintAndExplain,\n    // which takes a non-const reference as argument.\n#if defined(_PREFAST_ ) && _MSC_VER == 1800\n    // Workaround bug in VC++ 2013's /analyze parser.\n    // https://connect.microsoft.com/VisualStudio/feedback/details/1106363/internal-compiler-error-with-analyze-due-to-failure-to-infer-move\n    posix::Abort();  // To make sure it is never run.\n    return false;\n#else\n    RefToConstProperty result = (obj.*property_)();\n    return MatchPrintAndExplain(result, matcher_, listener);\n#endif\n  }\n\n  bool MatchAndExplainImpl(true_type /* is_pointer */, const Class* p,\n                           MatchResultListener* listener) const {\n    if (p == NULL)\n      return false;\n\n    *listener << \"which points to an object \";\n    // Since *p has a property method, it must be a class/struct/union\n    // type and thus cannot be a pointer.  Therefore we pass\n    // false_type() as the first argument.\n    return MatchAndExplainImpl(false_type(), *p, listener);\n  }\n\n  PropertyType (Class::*property_)() const;\n  const Matcher<RefToConstProperty> matcher_;\n\n  GTEST_DISALLOW_ASSIGN_(PropertyMatcher);\n};\n\n// Type traits specifying various features of different functors for ResultOf.\n// The default template specifies features for functor objects.\n// Functor classes have to typedef argument_type and result_type\n// to be compatible with ResultOf.\ntemplate <typename Functor>\nstruct CallableTraits {\n  typedef typename Functor::result_type ResultType;\n  typedef Functor StorageType;\n\n  static void CheckIsValid(Functor /* functor */) {}\n  template <typename T>\n  static ResultType Invoke(Functor f, T arg) { return f(arg); }\n};\n\n// Specialization for function pointers.\ntemplate <typename ArgType, typename ResType>\nstruct CallableTraits<ResType(*)(ArgType)> {\n  typedef ResType ResultType;\n  typedef ResType(*StorageType)(ArgType);\n\n  static void CheckIsValid(ResType(*f)(ArgType)) {\n    GTEST_CHECK_(f != NULL)\n        << \"NULL function pointer is passed into ResultOf().\";\n  }\n  template <typename T>\n  static ResType Invoke(ResType(*f)(ArgType), T arg) {\n    return (*f)(arg);\n  }\n};\n\n// Implements the ResultOf() matcher for matching a return value of a\n// unary function of an object.\ntemplate <typename Callable>\nclass ResultOfMatcher {\n public:\n  typedef typename CallableTraits<Callable>::ResultType ResultType;\n\n  ResultOfMatcher(Callable callable, const Matcher<ResultType>& matcher)\n      : callable_(callable), matcher_(matcher) {\n    CallableTraits<Callable>::CheckIsValid(callable_);\n  }\n\n  template <typename T>\n  operator Matcher<T>() const {\n    return Matcher<T>(new Impl<T>(callable_, matcher_));\n  }\n\n private:\n  typedef typename CallableTraits<Callable>::StorageType CallableStorageType;\n\n  template <typename T>\n  class Impl : public MatcherInterface<T> {\n   public:\n    Impl(CallableStorageType callable, const Matcher<ResultType>& matcher)\n        : callable_(callable), matcher_(matcher) {}\n\n    virtual void DescribeTo(::std::ostream* os) const {\n      *os << \"is mapped by the given callable to a value that \";\n      matcher_.DescribeTo(os);\n    }\n\n    virtual void DescribeNegationTo(::std::ostream* os) const {\n      *os << \"is mapped by the given callable to a value that \";\n      matcher_.DescribeNegationTo(os);\n    }\n\n    virtual bool MatchAndExplain(T obj, MatchResultListener* listener) const {\n      *listener << \"which is mapped by the given callable to \";\n      // Cannot pass the return value (for example, int) to\n      // MatchPrintAndExplain, which takes a non-const reference as argument.\n      ResultType result =\n          CallableTraits<Callable>::template Invoke<T>(callable_, obj);\n      return MatchPrintAndExplain(result, matcher_, listener);\n    }\n\n   private:\n    // Functors often define operator() as non-const method even though\n    // they are actualy stateless. But we need to use them even when\n    // 'this' is a const pointer. It's the user's responsibility not to\n    // use stateful callables with ResultOf(), which does't guarantee\n    // how many times the callable will be invoked.\n    mutable CallableStorageType callable_;\n    const Matcher<ResultType> matcher_;\n\n    GTEST_DISALLOW_ASSIGN_(Impl);\n  };  // class Impl\n\n  const CallableStorageType callable_;\n  const Matcher<ResultType> matcher_;\n\n  GTEST_DISALLOW_ASSIGN_(ResultOfMatcher);\n};\n\n// Implements a matcher that checks the size of an STL-style container.\ntemplate <typename SizeMatcher>\nclass SizeIsMatcher {\n public:\n  explicit SizeIsMatcher(const SizeMatcher& size_matcher)\n       : size_matcher_(size_matcher) {\n  }\n\n  template <typename Container>\n  operator Matcher<Container>() const {\n    return MakeMatcher(new Impl<Container>(size_matcher_));\n  }\n\n  template <typename Container>\n  class Impl : public MatcherInterface<Container> {\n   public:\n    typedef internal::StlContainerView<\n         GTEST_REMOVE_REFERENCE_AND_CONST_(Container)> ContainerView;\n    typedef typename ContainerView::type::size_type SizeType;\n    explicit Impl(const SizeMatcher& size_matcher)\n        : size_matcher_(MatcherCast<SizeType>(size_matcher)) {}\n\n    virtual void DescribeTo(::std::ostream* os) const {\n      *os << \"size \";\n      size_matcher_.DescribeTo(os);\n    }\n    virtual void DescribeNegationTo(::std::ostream* os) const {\n      *os << \"size \";\n      size_matcher_.DescribeNegationTo(os);\n    }\n\n    virtual bool MatchAndExplain(Container container,\n                                 MatchResultListener* listener) const {\n      SizeType size = container.size();\n      StringMatchResultListener size_listener;\n      const bool result = size_matcher_.MatchAndExplain(size, &size_listener);\n      *listener\n          << \"whose size \" << size << (result ? \" matches\" : \" doesn't match\");\n      PrintIfNotEmpty(size_listener.str(), listener->stream());\n      return result;\n    }\n\n   private:\n    const Matcher<SizeType> size_matcher_;\n    GTEST_DISALLOW_ASSIGN_(Impl);\n  };\n\n private:\n  const SizeMatcher size_matcher_;\n  GTEST_DISALLOW_ASSIGN_(SizeIsMatcher);\n};\n\n// Implements a matcher that checks the begin()..end() distance of an STL-style\n// container.\ntemplate <typename DistanceMatcher>\nclass BeginEndDistanceIsMatcher {\n public:\n  explicit BeginEndDistanceIsMatcher(const DistanceMatcher& distance_matcher)\n      : distance_matcher_(distance_matcher) {}\n\n  template <typename Container>\n  operator Matcher<Container>() const {\n    return MakeMatcher(new Impl<Container>(distance_matcher_));\n  }\n\n  template <typename Container>\n  class Impl : public MatcherInterface<Container> {\n   public:\n    typedef GTEST_REMOVE_REFERENCE_AND_CONST_(Container) RawContainer;\n    typedef internal::StlContainerView<RawContainer> View;\n    typedef typename View::type StlContainer;\n    typedef typename View::const_reference StlContainerReference;\n    typedef decltype(std::begin(\n        std::declval<StlContainerReference>())) StlContainerConstIterator;\n    typedef typename std::iterator_traits<\n        StlContainerConstIterator>::difference_type DistanceType;\n    explicit Impl(const DistanceMatcher& distance_matcher)\n        : distance_matcher_(MatcherCast<DistanceType>(distance_matcher)) {}\n\n    virtual void DescribeTo(::std::ostream* os) const {\n      *os << \"distance between begin() and end() \";\n      distance_matcher_.DescribeTo(os);\n    }\n    virtual void DescribeNegationTo(::std::ostream* os) const {\n      *os << \"distance between begin() and end() \";\n      distance_matcher_.DescribeNegationTo(os);\n    }\n\n    virtual bool MatchAndExplain(Container container,\n                                 MatchResultListener* listener) const {\n#if GTEST_HAS_STD_BEGIN_AND_END_\n      using std::begin;\n      using std::end;\n      DistanceType distance = std::distance(begin(container), end(container));\n#else\n      DistanceType distance = std::distance(container.begin(), container.end());\n#endif\n      StringMatchResultListener distance_listener;\n      const bool result =\n          distance_matcher_.MatchAndExplain(distance, &distance_listener);\n      *listener << \"whose distance between begin() and end() \" << distance\n                << (result ? \" matches\" : \" doesn't match\");\n      PrintIfNotEmpty(distance_listener.str(), listener->stream());\n      return result;\n    }\n\n   private:\n    const Matcher<DistanceType> distance_matcher_;\n    GTEST_DISALLOW_ASSIGN_(Impl);\n  };\n\n private:\n  const DistanceMatcher distance_matcher_;\n  GTEST_DISALLOW_ASSIGN_(BeginEndDistanceIsMatcher);\n};\n\n// Implements an equality matcher for any STL-style container whose elements\n// support ==. This matcher is like Eq(), but its failure explanations provide\n// more detailed information that is useful when the container is used as a set.\n// The failure message reports elements that are in one of the operands but not\n// the other. The failure messages do not report duplicate or out-of-order\n// elements in the containers (which don't properly matter to sets, but can\n// occur if the containers are vectors or lists, for example).\n//\n// Uses the container's const_iterator, value_type, operator ==,\n// begin(), and end().\ntemplate <typename Container>\nclass ContainerEqMatcher {\n public:\n  typedef internal::StlContainerView<Container> View;\n  typedef typename View::type StlContainer;\n  typedef typename View::const_reference StlContainerReference;\n\n  // We make a copy of expected in case the elements in it are modified\n  // after this matcher is created.\n  explicit ContainerEqMatcher(const Container& expected)\n      : expected_(View::Copy(expected)) {\n    // Makes sure the user doesn't instantiate this class template\n    // with a const or reference type.\n    (void)testing::StaticAssertTypeEq<Container,\n        GTEST_REMOVE_REFERENCE_AND_CONST_(Container)>();\n  }\n\n  void DescribeTo(::std::ostream* os) const {\n    *os << \"equals \";\n    UniversalPrint(expected_, os);\n  }\n  void DescribeNegationTo(::std::ostream* os) const {\n    *os << \"does not equal \";\n    UniversalPrint(expected_, os);\n  }\n\n  template <typename LhsContainer>\n  bool MatchAndExplain(const LhsContainer& lhs,\n                       MatchResultListener* listener) const {\n    // GTEST_REMOVE_CONST_() is needed to work around an MSVC 8.0 bug\n    // that causes LhsContainer to be a const type sometimes.\n    typedef internal::StlContainerView<GTEST_REMOVE_CONST_(LhsContainer)>\n        LhsView;\n    typedef typename LhsView::type LhsStlContainer;\n    StlContainerReference lhs_stl_container = LhsView::ConstReference(lhs);\n    if (lhs_stl_container == expected_)\n      return true;\n\n    ::std::ostream* const os = listener->stream();\n    if (os != NULL) {\n      // Something is different. Check for extra values first.\n      bool printed_header = false;\n      for (typename LhsStlContainer::const_iterator it =\n               lhs_stl_container.begin();\n           it != lhs_stl_container.end(); ++it) {\n        if (internal::ArrayAwareFind(expected_.begin(), expected_.end(), *it) ==\n            expected_.end()) {\n          if (printed_header) {\n            *os << \", \";\n          } else {\n            *os << \"which has these unexpected elements: \";\n            printed_header = true;\n          }\n          UniversalPrint(*it, os);\n        }\n      }\n\n      // Now check for missing values.\n      bool printed_header2 = false;\n      for (typename StlContainer::const_iterator it = expected_.begin();\n           it != expected_.end(); ++it) {\n        if (internal::ArrayAwareFind(\n                lhs_stl_container.begin(), lhs_stl_container.end(), *it) ==\n            lhs_stl_container.end()) {\n          if (printed_header2) {\n            *os << \", \";\n          } else {\n            *os << (printed_header ? \",\\nand\" : \"which\")\n                << \" doesn't have these expected elements: \";\n            printed_header2 = true;\n          }\n          UniversalPrint(*it, os);\n        }\n      }\n    }\n\n    return false;\n  }\n\n private:\n  const StlContainer expected_;\n\n  GTEST_DISALLOW_ASSIGN_(ContainerEqMatcher);\n};\n\n// A comparator functor that uses the < operator to compare two values.\nstruct LessComparator {\n  template <typename T, typename U>\n  bool operator()(const T& lhs, const U& rhs) const { return lhs < rhs; }\n};\n\n// Implements WhenSortedBy(comparator, container_matcher).\ntemplate <typename Comparator, typename ContainerMatcher>\nclass WhenSortedByMatcher {\n public:\n  WhenSortedByMatcher(const Comparator& comparator,\n                      const ContainerMatcher& matcher)\n      : comparator_(comparator), matcher_(matcher) {}\n\n  template <typename LhsContainer>\n  operator Matcher<LhsContainer>() const {\n    return MakeMatcher(new Impl<LhsContainer>(comparator_, matcher_));\n  }\n\n  template <typename LhsContainer>\n  class Impl : public MatcherInterface<LhsContainer> {\n   public:\n    typedef internal::StlContainerView<\n         GTEST_REMOVE_REFERENCE_AND_CONST_(LhsContainer)> LhsView;\n    typedef typename LhsView::type LhsStlContainer;\n    typedef typename LhsView::const_reference LhsStlContainerReference;\n    // Transforms std::pair<const Key, Value> into std::pair<Key, Value>\n    // so that we can match associative containers.\n    typedef typename RemoveConstFromKey<\n        typename LhsStlContainer::value_type>::type LhsValue;\n\n    Impl(const Comparator& comparator, const ContainerMatcher& matcher)\n        : comparator_(comparator), matcher_(matcher) {}\n\n    virtual void DescribeTo(::std::ostream* os) const {\n      *os << \"(when sorted) \";\n      matcher_.DescribeTo(os);\n    }\n\n    virtual void DescribeNegationTo(::std::ostream* os) const {\n      *os << \"(when sorted) \";\n      matcher_.DescribeNegationTo(os);\n    }\n\n    virtual bool MatchAndExplain(LhsContainer lhs,\n                                 MatchResultListener* listener) const {\n      LhsStlContainerReference lhs_stl_container = LhsView::ConstReference(lhs);\n      ::std::vector<LhsValue> sorted_container(lhs_stl_container.begin(),\n                                               lhs_stl_container.end());\n      ::std::sort(\n           sorted_container.begin(), sorted_container.end(), comparator_);\n\n      if (!listener->IsInterested()) {\n        // If the listener is not interested, we do not need to\n        // construct the inner explanation.\n        return matcher_.Matches(sorted_container);\n      }\n\n      *listener << \"which is \";\n      UniversalPrint(sorted_container, listener->stream());\n      *listener << \" when sorted\";\n\n      StringMatchResultListener inner_listener;\n      const bool match = matcher_.MatchAndExplain(sorted_container,\n                                                  &inner_listener);\n      PrintIfNotEmpty(inner_listener.str(), listener->stream());\n      return match;\n    }\n\n   private:\n    const Comparator comparator_;\n    const Matcher<const ::std::vector<LhsValue>&> matcher_;\n\n    GTEST_DISALLOW_COPY_AND_ASSIGN_(Impl);\n  };\n\n private:\n  const Comparator comparator_;\n  const ContainerMatcher matcher_;\n\n  GTEST_DISALLOW_ASSIGN_(WhenSortedByMatcher);\n};\n\n// Implements Pointwise(tuple_matcher, rhs_container).  tuple_matcher\n// must be able to be safely cast to Matcher<tuple<const T1&, const\n// T2&> >, where T1 and T2 are the types of elements in the LHS\n// container and the RHS container respectively.\ntemplate <typename TupleMatcher, typename RhsContainer>\nclass PointwiseMatcher {\n public:\n  typedef internal::StlContainerView<RhsContainer> RhsView;\n  typedef typename RhsView::type RhsStlContainer;\n  typedef typename RhsStlContainer::value_type RhsValue;\n\n  // Like ContainerEq, we make a copy of rhs in case the elements in\n  // it are modified after this matcher is created.\n  PointwiseMatcher(const TupleMatcher& tuple_matcher, const RhsContainer& rhs)\n      : tuple_matcher_(tuple_matcher), rhs_(RhsView::Copy(rhs)) {\n    // Makes sure the user doesn't instantiate this class template\n    // with a const or reference type.\n    (void)testing::StaticAssertTypeEq<RhsContainer,\n        GTEST_REMOVE_REFERENCE_AND_CONST_(RhsContainer)>();\n  }\n\n  template <typename LhsContainer>\n  operator Matcher<LhsContainer>() const {\n    return MakeMatcher(new Impl<LhsContainer>(tuple_matcher_, rhs_));\n  }\n\n  template <typename LhsContainer>\n  class Impl : public MatcherInterface<LhsContainer> {\n   public:\n    typedef internal::StlContainerView<\n         GTEST_REMOVE_REFERENCE_AND_CONST_(LhsContainer)> LhsView;\n    typedef typename LhsView::type LhsStlContainer;\n    typedef typename LhsView::const_reference LhsStlContainerReference;\n    typedef typename LhsStlContainer::value_type LhsValue;\n    // We pass the LHS value and the RHS value to the inner matcher by\n    // reference, as they may be expensive to copy.  We must use tuple\n    // instead of pair here, as a pair cannot hold references (C++ 98,\n    // 20.2.2 [lib.pairs]).\n    typedef ::testing::tuple<const LhsValue&, const RhsValue&> InnerMatcherArg;\n\n    Impl(const TupleMatcher& tuple_matcher, const RhsStlContainer& rhs)\n        // mono_tuple_matcher_ holds a monomorphic version of the tuple matcher.\n        : mono_tuple_matcher_(SafeMatcherCast<InnerMatcherArg>(tuple_matcher)),\n          rhs_(rhs) {}\n\n    virtual void DescribeTo(::std::ostream* os) const {\n      *os << \"contains \" << rhs_.size()\n          << \" values, where each value and its corresponding value in \";\n      UniversalPrinter<RhsStlContainer>::Print(rhs_, os);\n      *os << \" \";\n      mono_tuple_matcher_.DescribeTo(os);\n    }\n    virtual void DescribeNegationTo(::std::ostream* os) const {\n      *os << \"doesn't contain exactly \" << rhs_.size()\n          << \" values, or contains a value x at some index i\"\n          << \" where x and the i-th value of \";\n      UniversalPrint(rhs_, os);\n      *os << \" \";\n      mono_tuple_matcher_.DescribeNegationTo(os);\n    }\n\n    virtual bool MatchAndExplain(LhsContainer lhs,\n                                 MatchResultListener* listener) const {\n      LhsStlContainerReference lhs_stl_container = LhsView::ConstReference(lhs);\n      const size_t actual_size = lhs_stl_container.size();\n      if (actual_size != rhs_.size()) {\n        *listener << \"which contains \" << actual_size << \" values\";\n        return false;\n      }\n\n      typename LhsStlContainer::const_iterator left = lhs_stl_container.begin();\n      typename RhsStlContainer::const_iterator right = rhs_.begin();\n      for (size_t i = 0; i != actual_size; ++i, ++left, ++right) {\n        const InnerMatcherArg value_pair(*left, *right);\n\n        if (listener->IsInterested()) {\n          StringMatchResultListener inner_listener;\n          if (!mono_tuple_matcher_.MatchAndExplain(\n                  value_pair, &inner_listener)) {\n            *listener << \"where the value pair (\";\n            UniversalPrint(*left, listener->stream());\n            *listener << \", \";\n            UniversalPrint(*right, listener->stream());\n            *listener << \") at index #\" << i << \" don't match\";\n            PrintIfNotEmpty(inner_listener.str(), listener->stream());\n            return false;\n          }\n        } else {\n          if (!mono_tuple_matcher_.Matches(value_pair))\n            return false;\n        }\n      }\n\n      return true;\n    }\n\n   private:\n    const Matcher<InnerMatcherArg> mono_tuple_matcher_;\n    const RhsStlContainer rhs_;\n\n    GTEST_DISALLOW_ASSIGN_(Impl);\n  };\n\n private:\n  const TupleMatcher tuple_matcher_;\n  const RhsStlContainer rhs_;\n\n  GTEST_DISALLOW_ASSIGN_(PointwiseMatcher);\n};\n\n// Holds the logic common to ContainsMatcherImpl and EachMatcherImpl.\ntemplate <typename Container>\nclass QuantifierMatcherImpl : public MatcherInterface<Container> {\n public:\n  typedef GTEST_REMOVE_REFERENCE_AND_CONST_(Container) RawContainer;\n  typedef StlContainerView<RawContainer> View;\n  typedef typename View::type StlContainer;\n  typedef typename View::const_reference StlContainerReference;\n  typedef typename StlContainer::value_type Element;\n\n  template <typename InnerMatcher>\n  explicit QuantifierMatcherImpl(InnerMatcher inner_matcher)\n      : inner_matcher_(\n           testing::SafeMatcherCast<const Element&>(inner_matcher)) {}\n\n  // Checks whether:\n  // * All elements in the container match, if all_elements_should_match.\n  // * Any element in the container matches, if !all_elements_should_match.\n  bool MatchAndExplainImpl(bool all_elements_should_match,\n                           Container container,\n                           MatchResultListener* listener) const {\n    StlContainerReference stl_container = View::ConstReference(container);\n    size_t i = 0;\n    for (typename StlContainer::const_iterator it = stl_container.begin();\n         it != stl_container.end(); ++it, ++i) {\n      StringMatchResultListener inner_listener;\n      const bool matches = inner_matcher_.MatchAndExplain(*it, &inner_listener);\n\n      if (matches != all_elements_should_match) {\n        *listener << \"whose element #\" << i\n                  << (matches ? \" matches\" : \" doesn't match\");\n        PrintIfNotEmpty(inner_listener.str(), listener->stream());\n        return !all_elements_should_match;\n      }\n    }\n    return all_elements_should_match;\n  }\n\n protected:\n  const Matcher<const Element&> inner_matcher_;\n\n  GTEST_DISALLOW_ASSIGN_(QuantifierMatcherImpl);\n};\n\n// Implements Contains(element_matcher) for the given argument type Container.\n// Symmetric to EachMatcherImpl.\ntemplate <typename Container>\nclass ContainsMatcherImpl : public QuantifierMatcherImpl<Container> {\n public:\n  template <typename InnerMatcher>\n  explicit ContainsMatcherImpl(InnerMatcher inner_matcher)\n      : QuantifierMatcherImpl<Container>(inner_matcher) {}\n\n  // Describes what this matcher does.\n  virtual void DescribeTo(::std::ostream* os) const {\n    *os << \"contains at least one element that \";\n    this->inner_matcher_.DescribeTo(os);\n  }\n\n  virtual void DescribeNegationTo(::std::ostream* os) const {\n    *os << \"doesn't contain any element that \";\n    this->inner_matcher_.DescribeTo(os);\n  }\n\n  virtual bool MatchAndExplain(Container container,\n                               MatchResultListener* listener) const {\n    return this->MatchAndExplainImpl(false, container, listener);\n  }\n\n private:\n  GTEST_DISALLOW_ASSIGN_(ContainsMatcherImpl);\n};\n\n// Implements Each(element_matcher) for the given argument type Container.\n// Symmetric to ContainsMatcherImpl.\ntemplate <typename Container>\nclass EachMatcherImpl : public QuantifierMatcherImpl<Container> {\n public:\n  template <typename InnerMatcher>\n  explicit EachMatcherImpl(InnerMatcher inner_matcher)\n      : QuantifierMatcherImpl<Container>(inner_matcher) {}\n\n  // Describes what this matcher does.\n  virtual void DescribeTo(::std::ostream* os) const {\n    *os << \"only contains elements that \";\n    this->inner_matcher_.DescribeTo(os);\n  }\n\n  virtual void DescribeNegationTo(::std::ostream* os) const {\n    *os << \"contains some element that \";\n    this->inner_matcher_.DescribeNegationTo(os);\n  }\n\n  virtual bool MatchAndExplain(Container container,\n                               MatchResultListener* listener) const {\n    return this->MatchAndExplainImpl(true, container, listener);\n  }\n\n private:\n  GTEST_DISALLOW_ASSIGN_(EachMatcherImpl);\n};\n\n// Implements polymorphic Contains(element_matcher).\ntemplate <typename M>\nclass ContainsMatcher {\n public:\n  explicit ContainsMatcher(M m) : inner_matcher_(m) {}\n\n  template <typename Container>\n  operator Matcher<Container>() const {\n    return MakeMatcher(new ContainsMatcherImpl<Container>(inner_matcher_));\n  }\n\n private:\n  const M inner_matcher_;\n\n  GTEST_DISALLOW_ASSIGN_(ContainsMatcher);\n};\n\n// Implements polymorphic Each(element_matcher).\ntemplate <typename M>\nclass EachMatcher {\n public:\n  explicit EachMatcher(M m) : inner_matcher_(m) {}\n\n  template <typename Container>\n  operator Matcher<Container>() const {\n    return MakeMatcher(new EachMatcherImpl<Container>(inner_matcher_));\n  }\n\n private:\n  const M inner_matcher_;\n\n  GTEST_DISALLOW_ASSIGN_(EachMatcher);\n};\n\n// Implements Key(inner_matcher) for the given argument pair type.\n// Key(inner_matcher) matches an std::pair whose 'first' field matches\n// inner_matcher.  For example, Contains(Key(Ge(5))) can be used to match an\n// std::map that contains at least one element whose key is >= 5.\ntemplate <typename PairType>\nclass KeyMatcherImpl : public MatcherInterface<PairType> {\n public:\n  typedef GTEST_REMOVE_REFERENCE_AND_CONST_(PairType) RawPairType;\n  typedef typename RawPairType::first_type KeyType;\n\n  template <typename InnerMatcher>\n  explicit KeyMatcherImpl(InnerMatcher inner_matcher)\n      : inner_matcher_(\n          testing::SafeMatcherCast<const KeyType&>(inner_matcher)) {\n  }\n\n  // Returns true iff 'key_value.first' (the key) matches the inner matcher.\n  virtual bool MatchAndExplain(PairType key_value,\n                               MatchResultListener* listener) const {\n    StringMatchResultListener inner_listener;\n    const bool match = inner_matcher_.MatchAndExplain(key_value.first,\n                                                      &inner_listener);\n    const internal::string explanation = inner_listener.str();\n    if (explanation != \"\") {\n      *listener << \"whose first field is a value \" << explanation;\n    }\n    return match;\n  }\n\n  // Describes what this matcher does.\n  virtual void DescribeTo(::std::ostream* os) const {\n    *os << \"has a key that \";\n    inner_matcher_.DescribeTo(os);\n  }\n\n  // Describes what the negation of this matcher does.\n  virtual void DescribeNegationTo(::std::ostream* os) const {\n    *os << \"doesn't have a key that \";\n    inner_matcher_.DescribeTo(os);\n  }\n\n private:\n  const Matcher<const KeyType&> inner_matcher_;\n\n  GTEST_DISALLOW_ASSIGN_(KeyMatcherImpl);\n};\n\n// Implements polymorphic Key(matcher_for_key).\ntemplate <typename M>\nclass KeyMatcher {\n public:\n  explicit KeyMatcher(M m) : matcher_for_key_(m) {}\n\n  template <typename PairType>\n  operator Matcher<PairType>() const {\n    return MakeMatcher(new KeyMatcherImpl<PairType>(matcher_for_key_));\n  }\n\n private:\n  const M matcher_for_key_;\n\n  GTEST_DISALLOW_ASSIGN_(KeyMatcher);\n};\n\n// Implements Pair(first_matcher, second_matcher) for the given argument pair\n// type with its two matchers. See Pair() function below.\ntemplate <typename PairType>\nclass PairMatcherImpl : public MatcherInterface<PairType> {\n public:\n  typedef GTEST_REMOVE_REFERENCE_AND_CONST_(PairType) RawPairType;\n  typedef typename RawPairType::first_type FirstType;\n  typedef typename RawPairType::second_type SecondType;\n\n  template <typename FirstMatcher, typename SecondMatcher>\n  PairMatcherImpl(FirstMatcher first_matcher, SecondMatcher second_matcher)\n      : first_matcher_(\n            testing::SafeMatcherCast<const FirstType&>(first_matcher)),\n        second_matcher_(\n            testing::SafeMatcherCast<const SecondType&>(second_matcher)) {\n  }\n\n  // Describes what this matcher does.\n  virtual void DescribeTo(::std::ostream* os) const {\n    *os << \"has a first field that \";\n    first_matcher_.DescribeTo(os);\n    *os << \", and has a second field that \";\n    second_matcher_.DescribeTo(os);\n  }\n\n  // Describes what the negation of this matcher does.\n  virtual void DescribeNegationTo(::std::ostream* os) const {\n    *os << \"has a first field that \";\n    first_matcher_.DescribeNegationTo(os);\n    *os << \", or has a second field that \";\n    second_matcher_.DescribeNegationTo(os);\n  }\n\n  // Returns true iff 'a_pair.first' matches first_matcher and 'a_pair.second'\n  // matches second_matcher.\n  virtual bool MatchAndExplain(PairType a_pair,\n                               MatchResultListener* listener) const {\n    if (!listener->IsInterested()) {\n      // If the listener is not interested, we don't need to construct the\n      // explanation.\n      return first_matcher_.Matches(a_pair.first) &&\n             second_matcher_.Matches(a_pair.second);\n    }\n    StringMatchResultListener first_inner_listener;\n    if (!first_matcher_.MatchAndExplain(a_pair.first,\n                                        &first_inner_listener)) {\n      *listener << \"whose first field does not match\";\n      PrintIfNotEmpty(first_inner_listener.str(), listener->stream());\n      return false;\n    }\n    StringMatchResultListener second_inner_listener;\n    if (!second_matcher_.MatchAndExplain(a_pair.second,\n                                         &second_inner_listener)) {\n      *listener << \"whose second field does not match\";\n      PrintIfNotEmpty(second_inner_listener.str(), listener->stream());\n      return false;\n    }\n    ExplainSuccess(first_inner_listener.str(), second_inner_listener.str(),\n                   listener);\n    return true;\n  }\n\n private:\n  void ExplainSuccess(const internal::string& first_explanation,\n                      const internal::string& second_explanation,\n                      MatchResultListener* listener) const {\n    *listener << \"whose both fields match\";\n    if (first_explanation != \"\") {\n      *listener << \", where the first field is a value \" << first_explanation;\n    }\n    if (second_explanation != \"\") {\n      *listener << \", \";\n      if (first_explanation != \"\") {\n        *listener << \"and \";\n      } else {\n        *listener << \"where \";\n      }\n      *listener << \"the second field is a value \" << second_explanation;\n    }\n  }\n\n  const Matcher<const FirstType&> first_matcher_;\n  const Matcher<const SecondType&> second_matcher_;\n\n  GTEST_DISALLOW_ASSIGN_(PairMatcherImpl);\n};\n\n// Implements polymorphic Pair(first_matcher, second_matcher).\ntemplate <typename FirstMatcher, typename SecondMatcher>\nclass PairMatcher {\n public:\n  PairMatcher(FirstMatcher first_matcher, SecondMatcher second_matcher)\n      : first_matcher_(first_matcher), second_matcher_(second_matcher) {}\n\n  template <typename PairType>\n  operator Matcher<PairType> () const {\n    return MakeMatcher(\n        new PairMatcherImpl<PairType>(\n            first_matcher_, second_matcher_));\n  }\n\n private:\n  const FirstMatcher first_matcher_;\n  const SecondMatcher second_matcher_;\n\n  GTEST_DISALLOW_ASSIGN_(PairMatcher);\n};\n\n// Implements ElementsAre() and ElementsAreArray().\ntemplate <typename Container>\nclass ElementsAreMatcherImpl : public MatcherInterface<Container> {\n public:\n  typedef GTEST_REMOVE_REFERENCE_AND_CONST_(Container) RawContainer;\n  typedef internal::StlContainerView<RawContainer> View;\n  typedef typename View::type StlContainer;\n  typedef typename View::const_reference StlContainerReference;\n  typedef decltype(std::begin(\n      std::declval<StlContainerReference>())) StlContainerConstIterator;\n  typedef std::remove_reference_t<decltype(\n      *std::declval<StlContainerConstIterator &>())>\n      Element;\n\n  // Constructs the matcher from a sequence of element values or\n  // element matchers.\n  template <typename InputIter>\n  ElementsAreMatcherImpl(InputIter first, InputIter last) {\n    while (first != last) {\n      matchers_.push_back(MatcherCast<const Element&>(*first++));\n    }\n  }\n\n  // Describes what this matcher does.\n  virtual void DescribeTo(::std::ostream* os) const {\n    if (count() == 0) {\n      *os << \"is empty\";\n    } else if (count() == 1) {\n      *os << \"has 1 element that \";\n      matchers_[0].DescribeTo(os);\n    } else {\n      *os << \"has \" << Elements(count()) << \" where\\n\";\n      for (size_t i = 0; i != count(); ++i) {\n        *os << \"element #\" << i << \" \";\n        matchers_[i].DescribeTo(os);\n        if (i + 1 < count()) {\n          *os << \",\\n\";\n        }\n      }\n    }\n  }\n\n  // Describes what the negation of this matcher does.\n  virtual void DescribeNegationTo(::std::ostream* os) const {\n    if (count() == 0) {\n      *os << \"isn't empty\";\n      return;\n    }\n\n    *os << \"doesn't have \" << Elements(count()) << \", or\\n\";\n    for (size_t i = 0; i != count(); ++i) {\n      *os << \"element #\" << i << \" \";\n      matchers_[i].DescribeNegationTo(os);\n      if (i + 1 < count()) {\n        *os << \", or\\n\";\n      }\n    }\n  }\n\n  virtual bool MatchAndExplain(Container container,\n                               MatchResultListener* listener) const {\n    // To work with stream-like \"containers\", we must only walk\n    // through the elements in one pass.\n\n    const bool listener_interested = listener->IsInterested();\n\n    // explanations[i] is the explanation of the element at index i.\n    ::std::vector<internal::string> explanations(count());\n    StlContainerReference stl_container = View::ConstReference(container);\n    StlContainerConstIterator it = stl_container.begin();\n    size_t exam_pos = 0;\n    bool mismatch_found = false;  // Have we found a mismatched element yet?\n\n    // Go through the elements and matchers in pairs, until we reach\n    // the end of either the elements or the matchers, or until we find a\n    // mismatch.\n    for (; it != stl_container.end() && exam_pos != count(); ++it, ++exam_pos) {\n      bool match;  // Does the current element match the current matcher?\n      if (listener_interested) {\n        StringMatchResultListener s;\n        match = matchers_[exam_pos].MatchAndExplain(*it, &s);\n        explanations[exam_pos] = s.str();\n      } else {\n        match = matchers_[exam_pos].Matches(*it);\n      }\n\n      if (!match) {\n        mismatch_found = true;\n        break;\n      }\n    }\n    // If mismatch_found is true, 'exam_pos' is the index of the mismatch.\n\n    // Find how many elements the actual container has.  We avoid\n    // calling size() s.t. this code works for stream-like \"containers\"\n    // that don't define size().\n    size_t actual_count = exam_pos;\n    for (; it != stl_container.end(); ++it) {\n      ++actual_count;\n    }\n\n    if (actual_count != count()) {\n      // The element count doesn't match.  If the container is empty,\n      // there's no need to explain anything as Google Mock already\n      // prints the empty container.  Otherwise we just need to show\n      // how many elements there actually are.\n      if (listener_interested && (actual_count != 0)) {\n        *listener << \"which has \" << Elements(actual_count);\n      }\n      return false;\n    }\n\n    if (mismatch_found) {\n      // The element count matches, but the exam_pos-th element doesn't match.\n      if (listener_interested) {\n        *listener << \"whose element #\" << exam_pos << \" doesn't match\";\n        PrintIfNotEmpty(explanations[exam_pos], listener->stream());\n      }\n      return false;\n    }\n\n    // Every element matches its expectation.  We need to explain why\n    // (the obvious ones can be skipped).\n    if (listener_interested) {\n      bool reason_printed = false;\n      for (size_t i = 0; i != count(); ++i) {\n        const internal::string& s = explanations[i];\n        if (!s.empty()) {\n          if (reason_printed) {\n            *listener << \",\\nand \";\n          }\n          *listener << \"whose element #\" << i << \" matches, \" << s;\n          reason_printed = true;\n        }\n      }\n    }\n    return true;\n  }\n\n private:\n  static Message Elements(size_t count) {\n    return Message() << count << (count == 1 ? \" element\" : \" elements\");\n  }\n\n  size_t count() const { return matchers_.size(); }\n\n  ::std::vector<Matcher<const Element&> > matchers_;\n\n  GTEST_DISALLOW_ASSIGN_(ElementsAreMatcherImpl);\n};\n\n// Connectivity matrix of (elements X matchers), in element-major order.\n// Initially, there are no edges.\n// Use NextGraph() to iterate over all possible edge configurations.\n// Use Randomize() to generate a random edge configuration.\nclass GTEST_API_ MatchMatrix {\n public:\n  MatchMatrix(size_t num_elements, size_t num_matchers)\n      : num_elements_(num_elements),\n        num_matchers_(num_matchers),\n        matched_(num_elements_* num_matchers_, 0) {\n  }\n\n  size_t LhsSize() const { return num_elements_; }\n  size_t RhsSize() const { return num_matchers_; }\n  bool HasEdge(size_t ilhs, size_t irhs) const {\n    return matched_[SpaceIndex(ilhs, irhs)] == 1;\n  }\n  void SetEdge(size_t ilhs, size_t irhs, bool b) {\n    matched_[SpaceIndex(ilhs, irhs)] = b ? 1 : 0;\n  }\n\n  // Treating the connectivity matrix as a (LhsSize()*RhsSize())-bit number,\n  // adds 1 to that number; returns false if incrementing the graph left it\n  // empty.\n  bool NextGraph();\n\n  void Randomize();\n\n  string DebugString() const;\n\n private:\n  size_t SpaceIndex(size_t ilhs, size_t irhs) const {\n    return ilhs * num_matchers_ + irhs;\n  }\n\n  size_t num_elements_;\n  size_t num_matchers_;\n\n  // Each element is a char interpreted as bool. They are stored as a\n  // flattened array in lhs-major order, use 'SpaceIndex()' to translate\n  // a (ilhs, irhs) matrix coordinate into an offset.\n  ::std::vector<char> matched_;\n};\n\ntypedef ::std::pair<size_t, size_t> ElementMatcherPair;\ntypedef ::std::vector<ElementMatcherPair> ElementMatcherPairs;\n\n// Returns a maximum bipartite matching for the specified graph 'g'.\n// The matching is represented as a vector of {element, matcher} pairs.\nGTEST_API_ ElementMatcherPairs\nFindMaxBipartiteMatching(const MatchMatrix& g);\n\nGTEST_API_ bool FindPairing(const MatchMatrix& matrix,\n                            MatchResultListener* listener);\n\n// Untyped base class for implementing UnorderedElementsAre.  By\n// putting logic that's not specific to the element type here, we\n// reduce binary bloat and increase compilation speed.\nclass GTEST_API_ UnorderedElementsAreMatcherImplBase {\n protected:\n  // A vector of matcher describers, one for each element matcher.\n  // Does not own the describers (and thus can be used only when the\n  // element matchers are alive).\n  typedef ::std::vector<const MatcherDescriberInterface*> MatcherDescriberVec;\n\n  // Describes this UnorderedElementsAre matcher.\n  void DescribeToImpl(::std::ostream* os) const;\n\n  // Describes the negation of this UnorderedElementsAre matcher.\n  void DescribeNegationToImpl(::std::ostream* os) const;\n\n  bool VerifyAllElementsAndMatchersAreMatched(\n      const ::std::vector<string>& element_printouts,\n      const MatchMatrix& matrix,\n      MatchResultListener* listener) const;\n\n  MatcherDescriberVec& matcher_describers() {\n    return matcher_describers_;\n  }\n\n  static Message Elements(size_t n) {\n    return Message() << n << \" element\" << (n == 1 ? \"\" : \"s\");\n  }\n\n private:\n  MatcherDescriberVec matcher_describers_;\n\n  GTEST_DISALLOW_ASSIGN_(UnorderedElementsAreMatcherImplBase);\n};\n\n// Implements unordered ElementsAre and unordered ElementsAreArray.\ntemplate <typename Container>\nclass UnorderedElementsAreMatcherImpl\n    : public MatcherInterface<Container>,\n      public UnorderedElementsAreMatcherImplBase {\n public:\n  typedef GTEST_REMOVE_REFERENCE_AND_CONST_(Container) RawContainer;\n  typedef internal::StlContainerView<RawContainer> View;\n  typedef typename View::type StlContainer;\n  typedef typename View::const_reference StlContainerReference;\n  typedef decltype(std::begin(\n      std::declval<StlContainerReference>())) StlContainerConstIterator;\n  typedef std::remove_reference_t<decltype(\n      *std::declval<StlContainerConstIterator &>())>\n      Element;\n\n  // Constructs the matcher from a sequence of element values or\n  // element matchers.\n  template <typename InputIter>\n  UnorderedElementsAreMatcherImpl(InputIter first, InputIter last) {\n    for (; first != last; ++first) {\n      matchers_.push_back(MatcherCast<const Element&>(*first));\n      matcher_describers().push_back(matchers_.back().GetDescriber());\n    }\n  }\n\n  // Describes what this matcher does.\n  virtual void DescribeTo(::std::ostream* os) const {\n    return UnorderedElementsAreMatcherImplBase::DescribeToImpl(os);\n  }\n\n  // Describes what the negation of this matcher does.\n  virtual void DescribeNegationTo(::std::ostream* os) const {\n    return UnorderedElementsAreMatcherImplBase::DescribeNegationToImpl(os);\n  }\n\n  virtual bool MatchAndExplain(Container container,\n                               MatchResultListener* listener) const {\n    StlContainerReference stl_container = View::ConstReference(container);\n    ::std::vector<string> element_printouts;\n    MatchMatrix matrix = AnalyzeElements(stl_container.begin(),\n                                         stl_container.end(),\n                                         &element_printouts,\n                                         listener);\n\n    const size_t actual_count = matrix.LhsSize();\n    if (actual_count == 0 && matchers_.empty()) {\n      return true;\n    }\n    if (actual_count != matchers_.size()) {\n      // The element count doesn't match.  If the container is empty,\n      // there's no need to explain anything as Google Mock already\n      // prints the empty container. Otherwise we just need to show\n      // how many elements there actually are.\n      if (actual_count != 0 && listener->IsInterested()) {\n        *listener << \"which has \" << Elements(actual_count);\n      }\n      return false;\n    }\n\n    return VerifyAllElementsAndMatchersAreMatched(element_printouts,\n                                                  matrix, listener) &&\n           FindPairing(matrix, listener);\n  }\n\n private:\n  typedef ::std::vector<Matcher<const Element&> > MatcherVec;\n\n  template <typename ElementIter>\n  MatchMatrix AnalyzeElements(ElementIter elem_first, ElementIter elem_last,\n                              ::std::vector<string>* element_printouts,\n                              MatchResultListener* listener) const {\n    element_printouts->clear();\n    ::std::vector<char> did_match;\n    size_t num_elements = 0;\n    for (; elem_first != elem_last; ++num_elements, ++elem_first) {\n      if (listener->IsInterested()) {\n        element_printouts->push_back(PrintToString(*elem_first));\n      }\n      for (size_t irhs = 0; irhs != matchers_.size(); ++irhs) {\n        did_match.push_back(Matches(matchers_[irhs])(*elem_first));\n      }\n    }\n\n    MatchMatrix matrix(num_elements, matchers_.size());\n    ::std::vector<char>::const_iterator did_match_iter = did_match.begin();\n    for (size_t ilhs = 0; ilhs != num_elements; ++ilhs) {\n      for (size_t irhs = 0; irhs != matchers_.size(); ++irhs) {\n        matrix.SetEdge(ilhs, irhs, *did_match_iter++ != 0);\n      }\n    }\n    return matrix;\n  }\n\n  MatcherVec matchers_;\n\n  GTEST_DISALLOW_ASSIGN_(UnorderedElementsAreMatcherImpl);\n};\n\n// Functor for use in TransformTuple.\n// Performs MatcherCast<Target> on an input argument of any type.\ntemplate <typename Target>\nstruct CastAndAppendTransform {\n  template <typename Arg>\n  Matcher<Target> operator()(const Arg& a) const {\n    return MatcherCast<Target>(a);\n  }\n};\n\n// Implements UnorderedElementsAre.\ntemplate <typename MatcherTuple>\nclass UnorderedElementsAreMatcher {\n public:\n  explicit UnorderedElementsAreMatcher(const MatcherTuple& args)\n      : matchers_(args) {}\n\n  template <typename Container>\n  operator Matcher<Container>() const {\n    typedef GTEST_REMOVE_REFERENCE_AND_CONST_(Container) RawContainer;\n    typedef internal::StlContainerView<RawContainer> View;\n    typedef typename View::const_reference StlContainerReference;\n    typedef decltype(std::begin(\n        std::declval<StlContainerReference>())) StlContainerConstIterator;\n    typedef std::remove_reference_t<decltype(\n        *std::declval<StlContainerConstIterator &>())>\n        Element;\n    typedef ::std::vector<Matcher<const Element&> > MatcherVec;\n    MatcherVec matchers;\n    matchers.reserve(::testing::tuple_size<MatcherTuple>::value);\n    TransformTupleValues(CastAndAppendTransform<const Element&>(), matchers_,\n                         ::std::back_inserter(matchers));\n    return MakeMatcher(new UnorderedElementsAreMatcherImpl<Container>(\n                           matchers.begin(), matchers.end()));\n  }\n\n private:\n  const MatcherTuple matchers_;\n  GTEST_DISALLOW_ASSIGN_(UnorderedElementsAreMatcher);\n};\n\n// Implements ElementsAre.\ntemplate <typename MatcherTuple>\nclass ElementsAreMatcher {\n public:\n  explicit ElementsAreMatcher(const MatcherTuple& args) : matchers_(args) {}\n\n  template <typename Container>\n  operator Matcher<Container>() const {\n    typedef GTEST_REMOVE_REFERENCE_AND_CONST_(Container) RawContainer;\n    typedef internal::StlContainerView<RawContainer> View;\n    typedef typename View::const_reference StlContainerReference;\n    typedef decltype(std::begin(\n        std::declval<StlContainerReference>())) StlContainerConstIterator;\n    typedef std::remove_reference_t<decltype(\n        *std::declval<StlContainerConstIterator &>())>\n        Element;\n    typedef ::std::vector<Matcher<const Element&> > MatcherVec;\n    MatcherVec matchers;\n    matchers.reserve(::testing::tuple_size<MatcherTuple>::value);\n    TransformTupleValues(CastAndAppendTransform<const Element&>(), matchers_,\n                         ::std::back_inserter(matchers));\n    return MakeMatcher(new ElementsAreMatcherImpl<Container>(\n                           matchers.begin(), matchers.end()));\n  }\n\n private:\n  const MatcherTuple matchers_;\n  GTEST_DISALLOW_ASSIGN_(ElementsAreMatcher);\n};\n\n// Implements UnorderedElementsAreArray().\ntemplate <typename T>\nclass UnorderedElementsAreArrayMatcher {\n public:\n  UnorderedElementsAreArrayMatcher() {}\n\n  template <typename Iter>\n  UnorderedElementsAreArrayMatcher(Iter first, Iter last)\n      : matchers_(first, last) {}\n\n  template <typename Container>\n  operator Matcher<Container>() const {\n    return MakeMatcher(\n        new UnorderedElementsAreMatcherImpl<Container>(matchers_.begin(),\n                                                       matchers_.end()));\n  }\n\n private:\n  ::std::vector<T> matchers_;\n\n  GTEST_DISALLOW_ASSIGN_(UnorderedElementsAreArrayMatcher);\n};\n\n// Implements ElementsAreArray().\ntemplate <typename T>\nclass ElementsAreArrayMatcher {\n public:\n  template <typename Iter>\n  ElementsAreArrayMatcher(Iter first, Iter last) : matchers_(first, last) {}\n\n  template <typename Container>\n  operator Matcher<Container>() const {\n    return MakeMatcher(new ElementsAreMatcherImpl<Container>(\n        matchers_.begin(), matchers_.end()));\n  }\n\n private:\n  const ::std::vector<T> matchers_;\n\n  GTEST_DISALLOW_ASSIGN_(ElementsAreArrayMatcher);\n};\n\n// Given a 2-tuple matcher tm of type Tuple2Matcher and a value second\n// of type Second, BoundSecondMatcher<Tuple2Matcher, Second>(tm,\n// second) is a polymorphic matcher that matches a value x iff tm\n// matches tuple (x, second).  Useful for implementing\n// UnorderedPointwise() in terms of UnorderedElementsAreArray().\n//\n// BoundSecondMatcher is copyable and assignable, as we need to put\n// instances of this class in a vector when implementing\n// UnorderedPointwise().\ntemplate <typename Tuple2Matcher, typename Second>\nclass BoundSecondMatcher {\n public:\n  BoundSecondMatcher(const Tuple2Matcher& tm, const Second& second)\n      : tuple2_matcher_(tm), second_value_(second) {}\n\n  template <typename T>\n  operator Matcher<T>() const {\n    return MakeMatcher(new Impl<T>(tuple2_matcher_, second_value_));\n  }\n\n  // We have to define this for UnorderedPointwise() to compile in\n  // C++98 mode, as it puts BoundSecondMatcher instances in a vector,\n  // which requires the elements to be assignable in C++98.  The\n  // compiler cannot generate the operator= for us, as Tuple2Matcher\n  // and Second may not be assignable.\n  //\n  // However, this should never be called, so the implementation just\n  // need to assert.\n  void operator=(const BoundSecondMatcher& /*rhs*/) {\n    GTEST_LOG_(FATAL) << \"BoundSecondMatcher should never be assigned.\";\n  }\n\n  BoundSecondMatcher(const BoundSecondMatcher &) = default;\n\n private:\n  template <typename T>\n  class Impl : public MatcherInterface<T> {\n   public:\n    typedef ::testing::tuple<T, Second> ArgTuple;\n\n    Impl(const Tuple2Matcher& tm, const Second& second)\n        : mono_tuple2_matcher_(SafeMatcherCast<const ArgTuple&>(tm)),\n          second_value_(second) {}\n\n    virtual void DescribeTo(::std::ostream* os) const {\n      *os << \"and \";\n      UniversalPrint(second_value_, os);\n      *os << \" \";\n      mono_tuple2_matcher_.DescribeTo(os);\n    }\n\n    virtual bool MatchAndExplain(T x, MatchResultListener* listener) const {\n      return mono_tuple2_matcher_.MatchAndExplain(ArgTuple(x, second_value_),\n                                                  listener);\n    }\n\n   private:\n    const Matcher<const ArgTuple&> mono_tuple2_matcher_;\n    const Second second_value_;\n\n    GTEST_DISALLOW_ASSIGN_(Impl);\n  };\n\n  const Tuple2Matcher tuple2_matcher_;\n  const Second second_value_;\n};\n\n// Given a 2-tuple matcher tm and a value second,\n// MatcherBindSecond(tm, second) returns a matcher that matches a\n// value x iff tm matches tuple (x, second).  Useful for implementing\n// UnorderedPointwise() in terms of UnorderedElementsAreArray().\ntemplate <typename Tuple2Matcher, typename Second>\nBoundSecondMatcher<Tuple2Matcher, Second> MatcherBindSecond(\n    const Tuple2Matcher& tm, const Second& second) {\n  return BoundSecondMatcher<Tuple2Matcher, Second>(tm, second);\n}\n\n// Returns the description for a matcher defined using the MATCHER*()\n// macro where the user-supplied description string is \"\", if\n// 'negation' is false; otherwise returns the description of the\n// negation of the matcher.  'param_values' contains a list of strings\n// that are the print-out of the matcher's parameters.\nGTEST_API_ string FormatMatcherDescription(bool negation,\n                                           const char* matcher_name,\n                                           const Strings& param_values);\n\n}  // namespace internal\n\n// ElementsAreArray(first, last)\n// ElementsAreArray(pointer, count)\n// ElementsAreArray(array)\n// ElementsAreArray(container)\n// ElementsAreArray({ e1, e2, ..., en })\n//\n// The ElementsAreArray() functions are like ElementsAre(...), except\n// that they are given a homogeneous sequence rather than taking each\n// element as a function argument. The sequence can be specified as an\n// array, a pointer and count, a vector, an initializer list, or an\n// STL iterator range. In each of these cases, the underlying sequence\n// can be either a sequence of values or a sequence of matchers.\n//\n// All forms of ElementsAreArray() make a copy of the input matcher sequence.\n\ntemplate <typename Iter>\ninline internal::ElementsAreArrayMatcher<\n    typename ::std::iterator_traits<Iter>::value_type>\nElementsAreArray(Iter first, Iter last) {\n  typedef typename ::std::iterator_traits<Iter>::value_type T;\n  return internal::ElementsAreArrayMatcher<T>(first, last);\n}\n\ntemplate <typename T>\ninline internal::ElementsAreArrayMatcher<T> ElementsAreArray(\n    const T* pointer, size_t count) {\n  return ElementsAreArray(pointer, pointer + count);\n}\n\ntemplate <typename T, size_t N>\ninline internal::ElementsAreArrayMatcher<T> ElementsAreArray(\n    const T (&array)[N]) {\n  return ElementsAreArray(array, N);\n}\n\ntemplate <typename Container>\ninline internal::ElementsAreArrayMatcher<typename Container::value_type>\nElementsAreArray(const Container& container) {\n  return ElementsAreArray(container.begin(), container.end());\n}\n\n#if GTEST_HAS_STD_INITIALIZER_LIST_\ntemplate <typename T>\ninline internal::ElementsAreArrayMatcher<T>\nElementsAreArray(::std::initializer_list<T> xs) {\n  return ElementsAreArray(xs.begin(), xs.end());\n}\n#endif\n\n// UnorderedElementsAreArray(first, last)\n// UnorderedElementsAreArray(pointer, count)\n// UnorderedElementsAreArray(array)\n// UnorderedElementsAreArray(container)\n// UnorderedElementsAreArray({ e1, e2, ..., en })\n//\n// The UnorderedElementsAreArray() functions are like\n// ElementsAreArray(...), but allow matching the elements in any order.\ntemplate <typename Iter>\ninline internal::UnorderedElementsAreArrayMatcher<\n    typename ::std::iterator_traits<Iter>::value_type>\nUnorderedElementsAreArray(Iter first, Iter last) {\n  typedef typename ::std::iterator_traits<Iter>::value_type T;\n  return internal::UnorderedElementsAreArrayMatcher<T>(first, last);\n}\n\ntemplate <typename T>\ninline internal::UnorderedElementsAreArrayMatcher<T>\nUnorderedElementsAreArray(const T* pointer, size_t count) {\n  return UnorderedElementsAreArray(pointer, pointer + count);\n}\n\ntemplate <typename T, size_t N>\ninline internal::UnorderedElementsAreArrayMatcher<T>\nUnorderedElementsAreArray(const T (&array)[N]) {\n  return UnorderedElementsAreArray(array, N);\n}\n\ntemplate <typename Container>\ninline internal::UnorderedElementsAreArrayMatcher<\n    typename Container::value_type>\nUnorderedElementsAreArray(const Container& container) {\n  return UnorderedElementsAreArray(container.begin(), container.end());\n}\n\n#if GTEST_HAS_STD_INITIALIZER_LIST_\ntemplate <typename T>\ninline internal::UnorderedElementsAreArrayMatcher<T>\nUnorderedElementsAreArray(::std::initializer_list<T> xs) {\n  return UnorderedElementsAreArray(xs.begin(), xs.end());\n}\n#endif\n\n// _ is a matcher that matches anything of any type.\n//\n// This definition is fine as:\n//\n//   1. The C++ standard permits using the name _ in a namespace that\n//      is not the global namespace or ::std.\n//   2. The AnythingMatcher class has no data member or constructor,\n//      so it's OK to create global variables of this type.\n//   3. c-style has approved of using _ in this case.\nconst internal::AnythingMatcher _ = {};\n// Creates a matcher that matches any value of the given type T.\ntemplate <typename T>\ninline Matcher<T> A() { return MakeMatcher(new internal::AnyMatcherImpl<T>()); }\n\n// Creates a matcher that matches any value of the given type T.\ntemplate <typename T>\ninline Matcher<T> An() { return A<T>(); }\n\n// Creates a polymorphic matcher that matches anything equal to x.\n// Note: if the parameter of Eq() were declared as const T&, Eq(\"foo\")\n// wouldn't compile.\ntemplate <typename T>\ninline internal::EqMatcher<T> Eq(T x) { return internal::EqMatcher<T>(x); }\n\n// Constructs a Matcher<T> from a 'value' of type T.  The constructed\n// matcher matches any value that's equal to 'value'.\ntemplate <typename T>\nMatcher<T>::Matcher(T value) { *this = Eq(value); }\n\n// Creates a monomorphic matcher that matches anything with type Lhs\n// and equal to rhs.  A user may need to use this instead of Eq(...)\n// in order to resolve an overloading ambiguity.\n//\n// TypedEq<T>(x) is just a convenient short-hand for Matcher<T>(Eq(x))\n// or Matcher<T>(x), but more readable than the latter.\n//\n// We could define similar monomorphic matchers for other comparison\n// operations (e.g. TypedLt, TypedGe, and etc), but decided not to do\n// it yet as those are used much less than Eq() in practice.  A user\n// can always write Matcher<T>(Lt(5)) to be explicit about the type,\n// for example.\ntemplate <typename Lhs, typename Rhs>\ninline Matcher<Lhs> TypedEq(const Rhs& rhs) { return Eq(rhs); }\n\n// Creates a polymorphic matcher that matches anything >= x.\ntemplate <typename Rhs>\ninline internal::GeMatcher<Rhs> Ge(Rhs x) {\n  return internal::GeMatcher<Rhs>(x);\n}\n\n// Creates a polymorphic matcher that matches anything > x.\ntemplate <typename Rhs>\ninline internal::GtMatcher<Rhs> Gt(Rhs x) {\n  return internal::GtMatcher<Rhs>(x);\n}\n\n// Creates a polymorphic matcher that matches anything <= x.\ntemplate <typename Rhs>\ninline internal::LeMatcher<Rhs> Le(Rhs x) {\n  return internal::LeMatcher<Rhs>(x);\n}\n\n// Creates a polymorphic matcher that matches anything < x.\ntemplate <typename Rhs>\ninline internal::LtMatcher<Rhs> Lt(Rhs x) {\n  return internal::LtMatcher<Rhs>(x);\n}\n\n// Creates a polymorphic matcher that matches anything != x.\ntemplate <typename Rhs>\ninline internal::NeMatcher<Rhs> Ne(Rhs x) {\n  return internal::NeMatcher<Rhs>(x);\n}\n\n// Creates a polymorphic matcher that matches any NULL pointer.\ninline PolymorphicMatcher<internal::IsNullMatcher > IsNull() {\n  return MakePolymorphicMatcher(internal::IsNullMatcher());\n}\n\n// Creates a polymorphic matcher that matches any non-NULL pointer.\n// This is convenient as Not(NULL) doesn't compile (the compiler\n// thinks that that expression is comparing a pointer with an integer).\ninline PolymorphicMatcher<internal::NotNullMatcher > NotNull() {\n  return MakePolymorphicMatcher(internal::NotNullMatcher());\n}\n\n// Creates a polymorphic matcher that matches any argument that\n// references variable x.\ntemplate <typename T>\ninline internal::RefMatcher<T&> Ref(T& x) {  // NOLINT\n  return internal::RefMatcher<T&>(x);\n}\n\n// Creates a matcher that matches any double argument approximately\n// equal to rhs, where two NANs are considered unequal.\ninline internal::FloatingEqMatcher<double> DoubleEq(double rhs) {\n  return internal::FloatingEqMatcher<double>(rhs, false);\n}\n\n// Creates a matcher that matches any double argument approximately\n// equal to rhs, including NaN values when rhs is NaN.\ninline internal::FloatingEqMatcher<double> NanSensitiveDoubleEq(double rhs) {\n  return internal::FloatingEqMatcher<double>(rhs, true);\n}\n\n// Creates a matcher that matches any double argument approximately equal to\n// rhs, up to the specified max absolute error bound, where two NANs are\n// considered unequal.  The max absolute error bound must be non-negative.\ninline internal::FloatingEqMatcher<double> DoubleNear(\n    double rhs, double max_abs_error) {\n  return internal::FloatingEqMatcher<double>(rhs, false, max_abs_error);\n}\n\n// Creates a matcher that matches any double argument approximately equal to\n// rhs, up to the specified max absolute error bound, including NaN values when\n// rhs is NaN.  The max absolute error bound must be non-negative.\ninline internal::FloatingEqMatcher<double> NanSensitiveDoubleNear(\n    double rhs, double max_abs_error) {\n  return internal::FloatingEqMatcher<double>(rhs, true, max_abs_error);\n}\n\n// Creates a matcher that matches any float argument approximately\n// equal to rhs, where two NANs are considered unequal.\ninline internal::FloatingEqMatcher<float> FloatEq(float rhs) {\n  return internal::FloatingEqMatcher<float>(rhs, false);\n}\n\n// Creates a matcher that matches any float argument approximately\n// equal to rhs, including NaN values when rhs is NaN.\ninline internal::FloatingEqMatcher<float> NanSensitiveFloatEq(float rhs) {\n  return internal::FloatingEqMatcher<float>(rhs, true);\n}\n\n// Creates a matcher that matches any float argument approximately equal to\n// rhs, up to the specified max absolute error bound, where two NANs are\n// considered unequal.  The max absolute error bound must be non-negative.\ninline internal::FloatingEqMatcher<float> FloatNear(\n    float rhs, float max_abs_error) {\n  return internal::FloatingEqMatcher<float>(rhs, false, max_abs_error);\n}\n\n// Creates a matcher that matches any float argument approximately equal to\n// rhs, up to the specified max absolute error bound, including NaN values when\n// rhs is NaN.  The max absolute error bound must be non-negative.\ninline internal::FloatingEqMatcher<float> NanSensitiveFloatNear(\n    float rhs, float max_abs_error) {\n  return internal::FloatingEqMatcher<float>(rhs, true, max_abs_error);\n}\n\n// Creates a matcher that matches a pointer (raw or smart) that points\n// to a value that matches inner_matcher.\ntemplate <typename InnerMatcher>\ninline internal::PointeeMatcher<InnerMatcher> Pointee(\n    const InnerMatcher& inner_matcher) {\n  return internal::PointeeMatcher<InnerMatcher>(inner_matcher);\n}\n\n// Creates a matcher that matches a pointer or reference that matches\n// inner_matcher when dynamic_cast<To> is applied.\n// The result of dynamic_cast<To> is forwarded to the inner matcher.\n// If To is a pointer and the cast fails, the inner matcher will receive NULL.\n// If To is a reference and the cast fails, this matcher returns false\n// immediately.\ntemplate <typename To>\ninline PolymorphicMatcher<internal::WhenDynamicCastToMatcher<To> >\nWhenDynamicCastTo(const Matcher<To>& inner_matcher) {\n  return MakePolymorphicMatcher(\n      internal::WhenDynamicCastToMatcher<To>(inner_matcher));\n}\n\n// Creates a matcher that matches an object whose given field matches\n// 'matcher'.  For example,\n//   Field(&Foo::number, Ge(5))\n// matches a Foo object x iff x.number >= 5.\ntemplate <typename Class, typename FieldType, typename FieldMatcher>\ninline PolymorphicMatcher<\n  internal::FieldMatcher<Class, FieldType> > Field(\n    FieldType Class::*field, const FieldMatcher& matcher) {\n  return MakePolymorphicMatcher(\n      internal::FieldMatcher<Class, FieldType>(\n          field, MatcherCast<const FieldType&>(matcher)));\n  // The call to MatcherCast() is required for supporting inner\n  // matchers of compatible types.  For example, it allows\n  //   Field(&Foo::bar, m)\n  // to compile where bar is an int32 and m is a matcher for int64.\n}\n\n// Creates a matcher that matches an object whose given property\n// matches 'matcher'.  For example,\n//   Property(&Foo::str, StartsWith(\"hi\"))\n// matches a Foo object x iff x.str() starts with \"hi\".\ntemplate <typename Class, typename PropertyType, typename PropertyMatcher>\ninline PolymorphicMatcher<\n  internal::PropertyMatcher<Class, PropertyType> > Property(\n    PropertyType (Class::*property)() const, const PropertyMatcher& matcher) {\n  return MakePolymorphicMatcher(\n      internal::PropertyMatcher<Class, PropertyType>(\n          property,\n          MatcherCast<GTEST_REFERENCE_TO_CONST_(PropertyType)>(matcher)));\n  // The call to MatcherCast() is required for supporting inner\n  // matchers of compatible types.  For example, it allows\n  //   Property(&Foo::bar, m)\n  // to compile where bar() returns an int32 and m is a matcher for int64.\n}\n\n// Creates a matcher that matches an object iff the result of applying\n// a callable to x matches 'matcher'.\n// For example,\n//   ResultOf(f, StartsWith(\"hi\"))\n// matches a Foo object x iff f(x) starts with \"hi\".\n// callable parameter can be a function, function pointer, or a functor.\n// Callable has to satisfy the following conditions:\n//   * It is required to keep no state affecting the results of\n//     the calls on it and make no assumptions about how many calls\n//     will be made. Any state it keeps must be protected from the\n//     concurrent access.\n//   * If it is a function object, it has to define type result_type.\n//     We recommend deriving your functor classes from std::unary_function.\ntemplate <typename Callable, typename ResultOfMatcher>\ninternal::ResultOfMatcher<Callable> ResultOf(\n    Callable callable, const ResultOfMatcher& matcher) {\n  return internal::ResultOfMatcher<Callable>(\n          callable,\n          MatcherCast<typename internal::CallableTraits<Callable>::ResultType>(\n              matcher));\n  // The call to MatcherCast() is required for supporting inner\n  // matchers of compatible types.  For example, it allows\n  //   ResultOf(Function, m)\n  // to compile where Function() returns an int32 and m is a matcher for int64.\n}\n\n// String matchers.\n\n// Matches a string equal to str.\ninline PolymorphicMatcher<internal::StrEqualityMatcher<internal::string> >\n    StrEq(const internal::string& str) {\n  return MakePolymorphicMatcher(internal::StrEqualityMatcher<internal::string>(\n      str, true, true));\n}\n\n// Matches a string not equal to str.\ninline PolymorphicMatcher<internal::StrEqualityMatcher<internal::string> >\n    StrNe(const internal::string& str) {\n  return MakePolymorphicMatcher(internal::StrEqualityMatcher<internal::string>(\n      str, false, true));\n}\n\n// Matches a string equal to str, ignoring case.\ninline PolymorphicMatcher<internal::StrEqualityMatcher<internal::string> >\n    StrCaseEq(const internal::string& str) {\n  return MakePolymorphicMatcher(internal::StrEqualityMatcher<internal::string>(\n      str, true, false));\n}\n\n// Matches a string not equal to str, ignoring case.\ninline PolymorphicMatcher<internal::StrEqualityMatcher<internal::string> >\n    StrCaseNe(const internal::string& str) {\n  return MakePolymorphicMatcher(internal::StrEqualityMatcher<internal::string>(\n      str, false, false));\n}\n\n// Creates a matcher that matches any string, std::string, or C string\n// that contains the given substring.\ninline PolymorphicMatcher<internal::HasSubstrMatcher<internal::string> >\n    HasSubstr(const internal::string& substring) {\n  return MakePolymorphicMatcher(internal::HasSubstrMatcher<internal::string>(\n      substring));\n}\n\n// Matches a string that starts with 'prefix' (case-sensitive).\ninline PolymorphicMatcher<internal::StartsWithMatcher<internal::string> >\n    StartsWith(const internal::string& prefix) {\n  return MakePolymorphicMatcher(internal::StartsWithMatcher<internal::string>(\n      prefix));\n}\n\n// Matches a string that ends with 'suffix' (case-sensitive).\ninline PolymorphicMatcher<internal::EndsWithMatcher<internal::string> >\n    EndsWith(const internal::string& suffix) {\n  return MakePolymorphicMatcher(internal::EndsWithMatcher<internal::string>(\n      suffix));\n}\n\n// Matches a string that fully matches regular expression 'regex'.\n// The matcher takes ownership of 'regex'.\ninline PolymorphicMatcher<internal::MatchesRegexMatcher> MatchesRegex(\n    const internal::RE* regex) {\n  return MakePolymorphicMatcher(internal::MatchesRegexMatcher(regex, true));\n}\ninline PolymorphicMatcher<internal::MatchesRegexMatcher> MatchesRegex(\n    const internal::string& regex) {\n  return MatchesRegex(new internal::RE(regex));\n}\n\n// Matches a string that contains regular expression 'regex'.\n// The matcher takes ownership of 'regex'.\ninline PolymorphicMatcher<internal::MatchesRegexMatcher> ContainsRegex(\n    const internal::RE* regex) {\n  return MakePolymorphicMatcher(internal::MatchesRegexMatcher(regex, false));\n}\ninline PolymorphicMatcher<internal::MatchesRegexMatcher> ContainsRegex(\n    const internal::string& regex) {\n  return ContainsRegex(new internal::RE(regex));\n}\n\n#if GTEST_HAS_GLOBAL_WSTRING || GTEST_HAS_STD_WSTRING\n// Wide string matchers.\n\n// Matches a string equal to str.\ninline PolymorphicMatcher<internal::StrEqualityMatcher<internal::wstring> >\n    StrEq(const internal::wstring& str) {\n  return MakePolymorphicMatcher(internal::StrEqualityMatcher<internal::wstring>(\n      str, true, true));\n}\n\n// Matches a string not equal to str.\ninline PolymorphicMatcher<internal::StrEqualityMatcher<internal::wstring> >\n    StrNe(const internal::wstring& str) {\n  return MakePolymorphicMatcher(internal::StrEqualityMatcher<internal::wstring>(\n      str, false, true));\n}\n\n// Matches a string equal to str, ignoring case.\ninline PolymorphicMatcher<internal::StrEqualityMatcher<internal::wstring> >\n    StrCaseEq(const internal::wstring& str) {\n  return MakePolymorphicMatcher(internal::StrEqualityMatcher<internal::wstring>(\n      str, true, false));\n}\n\n// Matches a string not equal to str, ignoring case.\ninline PolymorphicMatcher<internal::StrEqualityMatcher<internal::wstring> >\n    StrCaseNe(const internal::wstring& str) {\n  return MakePolymorphicMatcher(internal::StrEqualityMatcher<internal::wstring>(\n      str, false, false));\n}\n\n// Creates a matcher that matches any wstring, std::wstring, or C wide string\n// that contains the given substring.\ninline PolymorphicMatcher<internal::HasSubstrMatcher<internal::wstring> >\n    HasSubstr(const internal::wstring& substring) {\n  return MakePolymorphicMatcher(internal::HasSubstrMatcher<internal::wstring>(\n      substring));\n}\n\n// Matches a string that starts with 'prefix' (case-sensitive).\ninline PolymorphicMatcher<internal::StartsWithMatcher<internal::wstring> >\n    StartsWith(const internal::wstring& prefix) {\n  return MakePolymorphicMatcher(internal::StartsWithMatcher<internal::wstring>(\n      prefix));\n}\n\n// Matches a string that ends with 'suffix' (case-sensitive).\ninline PolymorphicMatcher<internal::EndsWithMatcher<internal::wstring> >\n    EndsWith(const internal::wstring& suffix) {\n  return MakePolymorphicMatcher(internal::EndsWithMatcher<internal::wstring>(\n      suffix));\n}\n\n#endif  // GTEST_HAS_GLOBAL_WSTRING || GTEST_HAS_STD_WSTRING\n\n// Creates a polymorphic matcher that matches a 2-tuple where the\n// first field == the second field.\ninline internal::Eq2Matcher Eq() { return internal::Eq2Matcher(); }\n\n// Creates a polymorphic matcher that matches a 2-tuple where the\n// first field >= the second field.\ninline internal::Ge2Matcher Ge() { return internal::Ge2Matcher(); }\n\n// Creates a polymorphic matcher that matches a 2-tuple where the\n// first field > the second field.\ninline internal::Gt2Matcher Gt() { return internal::Gt2Matcher(); }\n\n// Creates a polymorphic matcher that matches a 2-tuple where the\n// first field <= the second field.\ninline internal::Le2Matcher Le() { return internal::Le2Matcher(); }\n\n// Creates a polymorphic matcher that matches a 2-tuple where the\n// first field < the second field.\ninline internal::Lt2Matcher Lt() { return internal::Lt2Matcher(); }\n\n// Creates a polymorphic matcher that matches a 2-tuple where the\n// first field != the second field.\ninline internal::Ne2Matcher Ne() { return internal::Ne2Matcher(); }\n\n// Creates a matcher that matches any value of type T that m doesn't\n// match.\ntemplate <typename InnerMatcher>\ninline internal::NotMatcher<InnerMatcher> Not(InnerMatcher m) {\n  return internal::NotMatcher<InnerMatcher>(m);\n}\n\n// Returns a matcher that matches anything that satisfies the given\n// predicate.  The predicate can be any unary function or functor\n// whose return type can be implicitly converted to bool.\ntemplate <typename Predicate>\ninline PolymorphicMatcher<internal::TrulyMatcher<Predicate> >\nTruly(Predicate pred) {\n  return MakePolymorphicMatcher(internal::TrulyMatcher<Predicate>(pred));\n}\n\n// Returns a matcher that matches the container size. The container must\n// support both size() and size_type which all STL-like containers provide.\n// Note that the parameter 'size' can be a value of type size_type as well as\n// matcher. For instance:\n//   EXPECT_THAT(container, SizeIs(2));     // Checks container has 2 elements.\n//   EXPECT_THAT(container, SizeIs(Le(2));  // Checks container has at most 2.\ntemplate <typename SizeMatcher>\ninline internal::SizeIsMatcher<SizeMatcher>\nSizeIs(const SizeMatcher& size_matcher) {\n  return internal::SizeIsMatcher<SizeMatcher>(size_matcher);\n}\n\n// Returns a matcher that matches the distance between the container's begin()\n// iterator and its end() iterator, i.e. the size of the container. This matcher\n// can be used instead of SizeIs with containers such as std::forward_list which\n// do not implement size(). The container must provide const_iterator (with\n// valid iterator_traits), begin() and end().\ntemplate <typename DistanceMatcher>\ninline internal::BeginEndDistanceIsMatcher<DistanceMatcher>\nBeginEndDistanceIs(const DistanceMatcher& distance_matcher) {\n  return internal::BeginEndDistanceIsMatcher<DistanceMatcher>(distance_matcher);\n}\n\n// Returns a matcher that matches an equal container.\n// This matcher behaves like Eq(), but in the event of mismatch lists the\n// values that are included in one container but not the other. (Duplicate\n// values and order differences are not explained.)\ntemplate <typename Container>\ninline PolymorphicMatcher<internal::ContainerEqMatcher<  // NOLINT\n                            GTEST_REMOVE_CONST_(Container)> >\n    ContainerEq(const Container& rhs) {\n  // This following line is for working around a bug in MSVC 8.0,\n  // which causes Container to be a const type sometimes.\n  typedef GTEST_REMOVE_CONST_(Container) RawContainer;\n  return MakePolymorphicMatcher(\n      internal::ContainerEqMatcher<RawContainer>(rhs));\n}\n\n// Returns a matcher that matches a container that, when sorted using\n// the given comparator, matches container_matcher.\ntemplate <typename Comparator, typename ContainerMatcher>\ninline internal::WhenSortedByMatcher<Comparator, ContainerMatcher>\nWhenSortedBy(const Comparator& comparator,\n             const ContainerMatcher& container_matcher) {\n  return internal::WhenSortedByMatcher<Comparator, ContainerMatcher>(\n      comparator, container_matcher);\n}\n\n// Returns a matcher that matches a container that, when sorted using\n// the < operator, matches container_matcher.\ntemplate <typename ContainerMatcher>\ninline internal::WhenSortedByMatcher<internal::LessComparator, ContainerMatcher>\nWhenSorted(const ContainerMatcher& container_matcher) {\n  return\n      internal::WhenSortedByMatcher<internal::LessComparator, ContainerMatcher>(\n          internal::LessComparator(), container_matcher);\n}\n\n// Matches an STL-style container or a native array that contains the\n// same number of elements as in rhs, where its i-th element and rhs's\n// i-th element (as a pair) satisfy the given pair matcher, for all i.\n// TupleMatcher must be able to be safely cast to Matcher<tuple<const\n// T1&, const T2&> >, where T1 and T2 are the types of elements in the\n// LHS container and the RHS container respectively.\ntemplate <typename TupleMatcher, typename Container>\ninline internal::PointwiseMatcher<TupleMatcher,\n                                  GTEST_REMOVE_CONST_(Container)>\nPointwise(const TupleMatcher& tuple_matcher, const Container& rhs) {\n  // This following line is for working around a bug in MSVC 8.0,\n  // which causes Container to be a const type sometimes (e.g. when\n  // rhs is a const int[])..\n  typedef GTEST_REMOVE_CONST_(Container) RawContainer;\n  return internal::PointwiseMatcher<TupleMatcher, RawContainer>(\n      tuple_matcher, rhs);\n}\n\n#if GTEST_HAS_STD_INITIALIZER_LIST_\n\n// Supports the Pointwise(m, {a, b, c}) syntax.\ntemplate <typename TupleMatcher, typename T>\ninline internal::PointwiseMatcher<TupleMatcher, std::vector<T> > Pointwise(\n    const TupleMatcher& tuple_matcher, std::initializer_list<T> rhs) {\n  return Pointwise(tuple_matcher, std::vector<T>(rhs));\n}\n\n#endif  // GTEST_HAS_STD_INITIALIZER_LIST_\n\n// UnorderedPointwise(pair_matcher, rhs) matches an STL-style\n// container or a native array that contains the same number of\n// elements as in rhs, where in some permutation of the container, its\n// i-th element and rhs's i-th element (as a pair) satisfy the given\n// pair matcher, for all i.  Tuple2Matcher must be able to be safely\n// cast to Matcher<tuple<const T1&, const T2&> >, where T1 and T2 are\n// the types of elements in the LHS container and the RHS container\n// respectively.\n//\n// This is like Pointwise(pair_matcher, rhs), except that the element\n// order doesn't matter.\ntemplate <typename Tuple2Matcher, typename RhsContainer>\ninline internal::UnorderedElementsAreArrayMatcher<\n    typename internal::BoundSecondMatcher<\n        Tuple2Matcher, typename internal::StlContainerView<GTEST_REMOVE_CONST_(\n                           RhsContainer)>::type::value_type> >\nUnorderedPointwise(const Tuple2Matcher& tuple2_matcher,\n                   const RhsContainer& rhs_container) {\n  // This following line is for working around a bug in MSVC 8.0,\n  // which causes RhsContainer to be a const type sometimes (e.g. when\n  // rhs_container is a const int[]).\n  typedef GTEST_REMOVE_CONST_(RhsContainer) RawRhsContainer;\n\n  // RhsView allows the same code to handle RhsContainer being a\n  // STL-style container and it being a native C-style array.\n  typedef typename internal::StlContainerView<RawRhsContainer> RhsView;\n  typedef typename RhsView::type RhsStlContainer;\n  typedef typename RhsStlContainer::value_type Second;\n  const RhsStlContainer& rhs_stl_container =\n      RhsView::ConstReference(rhs_container);\n\n  // Create a matcher for each element in rhs_container.\n  ::std::vector<internal::BoundSecondMatcher<Tuple2Matcher, Second> > matchers;\n  for (typename RhsStlContainer::const_iterator it = rhs_stl_container.begin();\n       it != rhs_stl_container.end(); ++it) {\n    matchers.push_back(\n        internal::MatcherBindSecond(tuple2_matcher, *it));\n  }\n\n  // Delegate the work to UnorderedElementsAreArray().\n  return UnorderedElementsAreArray(matchers);\n}\n\n#if GTEST_HAS_STD_INITIALIZER_LIST_\n\n// Supports the UnorderedPointwise(m, {a, b, c}) syntax.\ntemplate <typename Tuple2Matcher, typename T>\ninline internal::UnorderedElementsAreArrayMatcher<\n    typename internal::BoundSecondMatcher<Tuple2Matcher, T> >\nUnorderedPointwise(const Tuple2Matcher& tuple2_matcher,\n                   std::initializer_list<T> rhs) {\n  return UnorderedPointwise(tuple2_matcher, std::vector<T>(rhs));\n}\n\n#endif  // GTEST_HAS_STD_INITIALIZER_LIST_\n\n// Matches an STL-style container or a native array that contains at\n// least one element matching the given value or matcher.\n//\n// Examples:\n//   ::std::set<int> page_ids;\n//   page_ids.insert(3);\n//   page_ids.insert(1);\n//   EXPECT_THAT(page_ids, Contains(1));\n//   EXPECT_THAT(page_ids, Contains(Gt(2)));\n//   EXPECT_THAT(page_ids, Not(Contains(4)));\n//\n//   ::std::map<int, size_t> page_lengths;\n//   page_lengths[1] = 100;\n//   EXPECT_THAT(page_lengths,\n//               Contains(::std::pair<const int, size_t>(1, 100)));\n//\n//   const char* user_ids[] = { \"joe\", \"mike\", \"tom\" };\n//   EXPECT_THAT(user_ids, Contains(Eq(::std::string(\"tom\"))));\ntemplate <typename M>\ninline internal::ContainsMatcher<M> Contains(M matcher) {\n  return internal::ContainsMatcher<M>(matcher);\n}\n\n// Matches an STL-style container or a native array that contains only\n// elements matching the given value or matcher.\n//\n// Each(m) is semantically equivalent to Not(Contains(Not(m))). Only\n// the messages are different.\n//\n// Examples:\n//   ::std::set<int> page_ids;\n//   // Each(m) matches an empty container, regardless of what m is.\n//   EXPECT_THAT(page_ids, Each(Eq(1)));\n//   EXPECT_THAT(page_ids, Each(Eq(77)));\n//\n//   page_ids.insert(3);\n//   EXPECT_THAT(page_ids, Each(Gt(0)));\n//   EXPECT_THAT(page_ids, Not(Each(Gt(4))));\n//   page_ids.insert(1);\n//   EXPECT_THAT(page_ids, Not(Each(Lt(2))));\n//\n//   ::std::map<int, size_t> page_lengths;\n//   page_lengths[1] = 100;\n//   page_lengths[2] = 200;\n//   page_lengths[3] = 300;\n//   EXPECT_THAT(page_lengths, Not(Each(Pair(1, 100))));\n//   EXPECT_THAT(page_lengths, Each(Key(Le(3))));\n//\n//   const char* user_ids[] = { \"joe\", \"mike\", \"tom\" };\n//   EXPECT_THAT(user_ids, Not(Each(Eq(::std::string(\"tom\")))));\ntemplate <typename M>\ninline internal::EachMatcher<M> Each(M matcher) {\n  return internal::EachMatcher<M>(matcher);\n}\n\n// Key(inner_matcher) matches an std::pair whose 'first' field matches\n// inner_matcher.  For example, Contains(Key(Ge(5))) can be used to match an\n// std::map that contains at least one element whose key is >= 5.\ntemplate <typename M>\ninline internal::KeyMatcher<M> Key(M inner_matcher) {\n  return internal::KeyMatcher<M>(inner_matcher);\n}\n\n// Pair(first_matcher, second_matcher) matches a std::pair whose 'first' field\n// matches first_matcher and whose 'second' field matches second_matcher.  For\n// example, EXPECT_THAT(map_type, ElementsAre(Pair(Ge(5), \"foo\"))) can be used\n// to match a std::map<int, string> that contains exactly one element whose key\n// is >= 5 and whose value equals \"foo\".\ntemplate <typename FirstMatcher, typename SecondMatcher>\ninline internal::PairMatcher<FirstMatcher, SecondMatcher>\nPair(FirstMatcher first_matcher, SecondMatcher second_matcher) {\n  return internal::PairMatcher<FirstMatcher, SecondMatcher>(\n      first_matcher, second_matcher);\n}\n\n// Returns a predicate that is satisfied by anything that matches the\n// given matcher.\ntemplate <typename M>\ninline internal::MatcherAsPredicate<M> Matches(M matcher) {\n  return internal::MatcherAsPredicate<M>(matcher);\n}\n\n// Returns true iff the value matches the matcher.\ntemplate <typename T, typename M>\ninline bool Value(const T& value, M matcher) {\n  return testing::Matches(matcher)(value);\n}\n\n// Matches the value against the given matcher and explains the match\n// result to listener.\ntemplate <typename T, typename M>\ninline bool ExplainMatchResult(\n    M matcher, const T& value, MatchResultListener* listener) {\n  return SafeMatcherCast<const T&>(matcher).MatchAndExplain(value, listener);\n}\n\n#if GTEST_LANG_CXX11\n// Define variadic matcher versions. They are overloaded in\n// gmock-generated-matchers.h for the cases supported by pre C++11 compilers.\ntemplate <typename... Args>\ninline internal::AllOfMatcher<Args...> AllOf(const Args&... matchers) {\n  return internal::AllOfMatcher<Args...>(matchers...);\n}\n\ntemplate <typename... Args>\ninline internal::AnyOfMatcher<Args...> AnyOf(const Args&... matchers) {\n  return internal::AnyOfMatcher<Args...>(matchers...);\n}\n\n#endif  // GTEST_LANG_CXX11\n\n// AllArgs(m) is a synonym of m.  This is useful in\n//\n//   EXPECT_CALL(foo, Bar(_, _)).With(AllArgs(Eq()));\n//\n// which is easier to read than\n//\n//   EXPECT_CALL(foo, Bar(_, _)).With(Eq());\ntemplate <typename InnerMatcher>\ninline InnerMatcher AllArgs(const InnerMatcher& matcher) { return matcher; }\n\n// These macros allow using matchers to check values in Google Test\n// tests.  ASSERT_THAT(value, matcher) and EXPECT_THAT(value, matcher)\n// succeed iff the value matches the matcher.  If the assertion fails,\n// the value and the description of the matcher will be printed.\n#define ASSERT_THAT(value, matcher) ASSERT_PRED_FORMAT1(\\\n    ::testing::internal::MakePredicateFormatterFromMatcher(matcher), value)\n#define EXPECT_THAT(value, matcher) EXPECT_PRED_FORMAT1(\\\n    ::testing::internal::MakePredicateFormatterFromMatcher(matcher), value)\n\n}  // namespace testing\n\n// Include any custom callback matchers added by the local installation.\n// We must include this header at the end to make sure it can use the\n// declarations from this file.\n#include \"gmock/internal/custom/gmock-matchers.h\"\n#endif  // GMOCK_INCLUDE_GMOCK_GMOCK_MATCHERS_H_\n"}, "36": {"id": 36, "path": "/home/vsts/work/1/llvm-project/llvm/utils/unittest/googlemock/include/gmock/gmock-more-actions.h", "content": "// Copyright 2007, Google Inc.\n// All rights reserved.\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are\n// met:\n//\n//     * Redistributions of source code must retain the above copyright\n// notice, this list of conditions and the following disclaimer.\n//     * Redistributions in binary form must reproduce the above\n// copyright notice, this list of conditions and the following disclaimer\n// in the documentation and/or other materials provided with the\n// distribution.\n//     * Neither the name of Google Inc. nor the names of its\n// contributors may be used to endorse or promote products derived from\n// this software without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n//\n// Author: wan@google.com (Zhanyong Wan)\n\n// Google Mock - a framework for writing C++ mock classes.\n//\n// This file implements some actions that depend on gmock-generated-actions.h.\n\n// IWYU pragma: private, include \"gmock/gmock.h\"\n\n#ifndef GMOCK_INCLUDE_GMOCK_GMOCK_MORE_ACTIONS_H_\n#define GMOCK_INCLUDE_GMOCK_GMOCK_MORE_ACTIONS_H_\n\n#include <algorithm>\n\n#include \"gmock/gmock-generated-actions.h\"\n\nnamespace testing {\nnamespace internal {\n\n// Implements the Invoke(f) action.  The template argument\n// FunctionImpl is the implementation type of f, which can be either a\n// function pointer or a functor.  Invoke(f) can be used as an\n// Action<F> as long as f's type is compatible with F (i.e. f can be\n// assigned to a tr1::function<F>).\ntemplate <typename FunctionImpl>\nclass InvokeAction {\n public:\n  // The c'tor makes a copy of function_impl (either a function\n  // pointer or a functor).\n  explicit InvokeAction(FunctionImpl function_impl)\n      : function_impl_(function_impl) {}\n\n  template <typename Result, typename ArgumentTuple>\n  Result Perform(const ArgumentTuple& args) {\n    return InvokeHelper<Result, ArgumentTuple>::Invoke(function_impl_, args);\n  }\n\n private:\n  FunctionImpl function_impl_;\n\n  GTEST_DISALLOW_ASSIGN_(InvokeAction);\n};\n\n// Implements the Invoke(object_ptr, &Class::Method) action.\ntemplate <class Class, typename MethodPtr>\nclass InvokeMethodAction {\n public:\n  InvokeMethodAction(Class* obj_ptr, MethodPtr method_ptr)\n      : method_ptr_(method_ptr), obj_ptr_(obj_ptr) {}\n\n  template <typename Result, typename ArgumentTuple>\n  Result Perform(const ArgumentTuple& args) const {\n    return InvokeHelper<Result, ArgumentTuple>::InvokeMethod(\n        obj_ptr_, method_ptr_, args);\n  }\n\n private:\n  // The order of these members matters.  Reversing the order can trigger\n  // warning C4121 in MSVC (see\n  // http://computer-programming-forum.com/7-vc.net/6fbc30265f860ad1.htm ).\n  const MethodPtr method_ptr_;\n  Class* const obj_ptr_;\n\n  GTEST_DISALLOW_ASSIGN_(InvokeMethodAction);\n};\n\n// An internal replacement for std::copy which mimics its behavior. This is\n// necessary because Visual Studio deprecates ::std::copy, issuing warning 4996.\n// However Visual Studio 2010 and later do not honor #pragmas which disable that\n// warning.\ntemplate<typename InputIterator, typename OutputIterator>\ninline OutputIterator CopyElements(InputIterator first,\n                                   InputIterator last,\n                                   OutputIterator output) {\n  for (; first != last; ++first, ++output) {\n    *output = *first;\n  }\n  return output;\n}\n\n}  // namespace internal\n\n// Various overloads for Invoke().\n\n// Creates an action that invokes 'function_impl' with the mock\n// function's arguments.\ntemplate <typename FunctionImpl>\nPolymorphicAction<internal::InvokeAction<FunctionImpl> > Invoke(\n    FunctionImpl function_impl) {\n  return MakePolymorphicAction(\n      internal::InvokeAction<FunctionImpl>(function_impl));\n}\n\n// Creates an action that invokes the given method on the given object\n// with the mock function's arguments.\ntemplate <class Class, typename MethodPtr>\nPolymorphicAction<internal::InvokeMethodAction<Class, MethodPtr> > Invoke(\n    Class* obj_ptr, MethodPtr method_ptr) {\n  return MakePolymorphicAction(\n      internal::InvokeMethodAction<Class, MethodPtr>(obj_ptr, method_ptr));\n}\n\n// WithoutArgs(inner_action) can be used in a mock function with a\n// non-empty argument list to perform inner_action, which takes no\n// argument.  In other words, it adapts an action accepting no\n// argument to one that accepts (and ignores) arguments.\ntemplate <typename InnerAction>\ninline internal::WithArgsAction<InnerAction>\nWithoutArgs(const InnerAction& action) {\n  return internal::WithArgsAction<InnerAction>(action);\n}\n\n// WithArg<k>(an_action) creates an action that passes the k-th\n// (0-based) argument of the mock function to an_action and performs\n// it.  It adapts an action accepting one argument to one that accepts\n// multiple arguments.  For convenience, we also provide\n// WithArgs<k>(an_action) (defined below) as a synonym.\ntemplate <int k, typename InnerAction>\ninline internal::WithArgsAction<InnerAction, k>\nWithArg(const InnerAction& action) {\n  return internal::WithArgsAction<InnerAction, k>(action);\n}\n\n// The ACTION*() macros trigger warning C4100 (unreferenced formal\n// parameter) in MSVC with -W4.  Unfortunately they cannot be fixed in\n// the macro definition, as the warnings are generated when the macro\n// is expanded and macro expansion cannot contain #pragma.  Therefore\n// we suppress them here.\n#ifdef _MSC_VER\n# pragma warning(push)\n# pragma warning(disable:4100)\n#endif\n\n// Action ReturnArg<k>() returns the k-th argument of the mock function.\nACTION_TEMPLATE(ReturnArg,\n                HAS_1_TEMPLATE_PARAMS(int, k),\n                AND_0_VALUE_PARAMS()) {\n  return ::testing::get<k>(args);\n}\n\n// Action SaveArg<k>(pointer) saves the k-th (0-based) argument of the\n// mock function to *pointer.\nACTION_TEMPLATE(SaveArg,\n                HAS_1_TEMPLATE_PARAMS(int, k),\n                AND_1_VALUE_PARAMS(pointer)) {\n  *pointer = ::testing::get<k>(args);\n}\n\n// Action SaveArgPointee<k>(pointer) saves the value pointed to\n// by the k-th (0-based) argument of the mock function to *pointer.\nACTION_TEMPLATE(SaveArgPointee,\n                HAS_1_TEMPLATE_PARAMS(int, k),\n                AND_1_VALUE_PARAMS(pointer)) {\n  *pointer = *::testing::get<k>(args);\n}\n\n// Action SetArgReferee<k>(value) assigns 'value' to the variable\n// referenced by the k-th (0-based) argument of the mock function.\nACTION_TEMPLATE(SetArgReferee,\n                HAS_1_TEMPLATE_PARAMS(int, k),\n                AND_1_VALUE_PARAMS(value)) {\n  typedef typename ::testing::tuple_element<k, args_type>::type argk_type;\n  // Ensures that argument #k is a reference.  If you get a compiler\n  // error on the next line, you are using SetArgReferee<k>(value) in\n  // a mock function whose k-th (0-based) argument is not a reference.\n  GTEST_COMPILE_ASSERT_(internal::is_reference<argk_type>::value,\n                        SetArgReferee_must_be_used_with_a_reference_argument);\n  ::testing::get<k>(args) = value;\n}\n\n// Action SetArrayArgument<k>(first, last) copies the elements in\n// source range [first, last) to the array pointed to by the k-th\n// (0-based) argument, which can be either a pointer or an\n// iterator. The action does not take ownership of the elements in the\n// source range.\nACTION_TEMPLATE(SetArrayArgument,\n                HAS_1_TEMPLATE_PARAMS(int, k),\n                AND_2_VALUE_PARAMS(first, last)) {\n  // Visual Studio deprecates ::std::copy, so we use our own copy in that case.\n#ifdef _MSC_VER\n  internal::CopyElements(first, last, ::testing::get<k>(args));\n#else\n  ::std::copy(first, last, ::testing::get<k>(args));\n#endif\n}\n\n// Action DeleteArg<k>() deletes the k-th (0-based) argument of the mock\n// function.\nACTION_TEMPLATE(DeleteArg,\n                HAS_1_TEMPLATE_PARAMS(int, k),\n                AND_0_VALUE_PARAMS()) {\n  delete ::testing::get<k>(args);\n}\n\n// This action returns the value pointed to by 'pointer'.\nACTION_P(ReturnPointee, pointer) { return *pointer; }\n\n// Action Throw(exception) can be used in a mock function of any type\n// to throw the given exception.  Any copyable value can be thrown.\n#if GTEST_HAS_EXCEPTIONS\n\n// Suppresses the 'unreachable code' warning that VC generates in opt modes.\n# ifdef _MSC_VER\n#  pragma warning(push)          // Saves the current warning state.\n#  pragma warning(disable:4702)  // Temporarily disables warning 4702.\n# endif\nACTION_P(Throw, exception) { throw exception; }\n# ifdef _MSC_VER\n#  pragma warning(pop)           // Restores the warning state.\n# endif\n\n#endif  // GTEST_HAS_EXCEPTIONS\n\n#ifdef _MSC_VER\n# pragma warning(pop)\n#endif\n\n}  // namespace testing\n\n#endif  // GMOCK_INCLUDE_GMOCK_GMOCK_MORE_ACTIONS_H_\n"}, "37": {"id": 37, "path": "/home/vsts/work/1/llvm-project/llvm/utils/unittest/googlemock/include/gmock/gmock-spec-builders.h", "content": "// Copyright 2007, Google Inc.\n// All rights reserved.\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are\n// met:\n//\n//     * Redistributions of source code must retain the above copyright\n// notice, this list of conditions and the following disclaimer.\n//     * Redistributions in binary form must reproduce the above\n// copyright notice, this list of conditions and the following disclaimer\n// in the documentation and/or other materials provided with the\n// distribution.\n//     * Neither the name of Google Inc. nor the names of its\n// contributors may be used to endorse or promote products derived from\n// this software without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n//\n// Author: wan@google.com (Zhanyong Wan)\n\n// Google Mock - a framework for writing C++ mock classes.\n//\n// This file implements the ON_CALL() and EXPECT_CALL() macros.\n//\n// A user can use the ON_CALL() macro to specify the default action of\n// a mock method.  The syntax is:\n//\n//   ON_CALL(mock_object, Method(argument-matchers))\n//       .With(multi-argument-matcher)\n//       .WillByDefault(action);\n//\n//  where the .With() clause is optional.\n//\n// A user can use the EXPECT_CALL() macro to specify an expectation on\n// a mock method.  The syntax is:\n//\n//   EXPECT_CALL(mock_object, Method(argument-matchers))\n//       .With(multi-argument-matchers)\n//       .Times(cardinality)\n//       .InSequence(sequences)\n//       .After(expectations)\n//       .WillOnce(action)\n//       .WillRepeatedly(action)\n//       .RetiresOnSaturation();\n//\n// where all clauses are optional, and .InSequence()/.After()/\n// .WillOnce() can appear any number of times.\n\n// IWYU pragma: private, include \"gmock/gmock.h\"\n\n#ifndef GMOCK_INCLUDE_GMOCK_GMOCK_SPEC_BUILDERS_H_\n#define GMOCK_INCLUDE_GMOCK_GMOCK_SPEC_BUILDERS_H_\n\n#include <map>\n#include <set>\n#include <sstream>\n#include <string>\n#include <vector>\n\n#if GTEST_HAS_EXCEPTIONS\n# include <stdexcept>  // NOLINT\n#endif\n\n#include \"gmock/gmock-actions.h\"\n#include \"gmock/gmock-cardinalities.h\"\n#include \"gmock/gmock-matchers.h\"\n#include \"gmock/internal/gmock-internal-utils.h\"\n#include \"gmock/internal/gmock-port.h\"\n#include \"gtest/gtest.h\"\n\nnamespace testing {\n\n// An abstract handle of an expectation.\nclass Expectation;\n\n// A set of expectation handles.\nclass ExpectationSet;\n\n// Anything inside the 'internal' namespace IS INTERNAL IMPLEMENTATION\n// and MUST NOT BE USED IN USER CODE!!!\nnamespace internal {\n\n// Implements a mock function.\ntemplate <typename F> class FunctionMocker;\n\n// Base class for expectations.\nclass ExpectationBase;\n\n// Implements an expectation.\ntemplate <typename F> class TypedExpectation;\n\n// Helper class for testing the Expectation class template.\nclass ExpectationTester;\n\n// Base class for function mockers.\ntemplate <typename F> class FunctionMockerBase;\n\n// Protects the mock object registry (in class Mock), all function\n// mockers, and all expectations.\n//\n// The reason we don't use more fine-grained protection is: when a\n// mock function Foo() is called, it needs to consult its expectations\n// to see which one should be picked.  If another thread is allowed to\n// call a mock function (either Foo() or a different one) at the same\n// time, it could affect the \"retired\" attributes of Foo()'s\n// expectations when InSequence() is used, and thus affect which\n// expectation gets picked.  Therefore, we sequence all mock function\n// calls to ensure the integrity of the mock objects' states.\nGTEST_API_ GTEST_DECLARE_STATIC_MUTEX_(g_gmock_mutex);\n\n// Untyped base class for ActionResultHolder<R>.\nclass UntypedActionResultHolderBase;\n\n// Abstract base class of FunctionMockerBase.  This is the\n// type-agnostic part of the function mocker interface.  Its pure\n// virtual methods are implemented by FunctionMockerBase.\nclass GTEST_API_ UntypedFunctionMockerBase {\n public:\n  UntypedFunctionMockerBase();\n  virtual ~UntypedFunctionMockerBase();\n\n  // Verifies that all expectations on this mock function have been\n  // satisfied.  Reports one or more Google Test non-fatal failures\n  // and returns false if not.\n  bool VerifyAndClearExpectationsLocked()\n      GTEST_EXCLUSIVE_LOCK_REQUIRED_(g_gmock_mutex);\n\n  // Clears the ON_CALL()s set on this mock function.\n  virtual void ClearDefaultActionsLocked()\n      GTEST_EXCLUSIVE_LOCK_REQUIRED_(g_gmock_mutex) = 0;\n\n  // In all of the following Untyped* functions, it's the caller's\n  // responsibility to guarantee the correctness of the arguments'\n  // types.\n\n  // Performs the default action with the given arguments and returns\n  // the action's result.  The call description string will be used in\n  // the error message to describe the call in the case the default\n  // action fails.\n  // L = *\n  virtual UntypedActionResultHolderBase* UntypedPerformDefaultAction(\n      const void* untyped_args,\n      const string& call_description) const = 0;\n\n  // Performs the given action with the given arguments and returns\n  // the action's result.\n  // L = *\n  virtual UntypedActionResultHolderBase* UntypedPerformAction(\n      const void* untyped_action,\n      const void* untyped_args) const = 0;\n\n  // Writes a message that the call is uninteresting (i.e. neither\n  // explicitly expected nor explicitly unexpected) to the given\n  // ostream.\n  virtual void UntypedDescribeUninterestingCall(\n      const void* untyped_args,\n      ::std::ostream* os) const\n          GTEST_LOCK_EXCLUDED_(g_gmock_mutex) = 0;\n\n  // Returns the expectation that matches the given function arguments\n  // (or NULL is there's no match); when a match is found,\n  // untyped_action is set to point to the action that should be\n  // performed (or NULL if the action is \"do default\"), and\n  // is_excessive is modified to indicate whether the call exceeds the\n  // expected number.\n  virtual const ExpectationBase* UntypedFindMatchingExpectation(\n      const void* untyped_args,\n      const void** untyped_action, bool* is_excessive,\n      ::std::ostream* what, ::std::ostream* why)\n          GTEST_LOCK_EXCLUDED_(g_gmock_mutex) = 0;\n\n  // Prints the given function arguments to the ostream.\n  virtual void UntypedPrintArgs(const void* untyped_args,\n                                ::std::ostream* os) const = 0;\n\n  // Sets the mock object this mock method belongs to, and registers\n  // this information in the global mock registry.  Will be called\n  // whenever an EXPECT_CALL() or ON_CALL() is executed on this mock\n  // method.\n  // TODO(wan@google.com): rename to SetAndRegisterOwner().\n  void RegisterOwner(const void* mock_obj)\n      GTEST_LOCK_EXCLUDED_(g_gmock_mutex);\n\n  // Sets the mock object this mock method belongs to, and sets the\n  // name of the mock function.  Will be called upon each invocation\n  // of this mock function.\n  void SetOwnerAndName(const void* mock_obj, const char* name)\n      GTEST_LOCK_EXCLUDED_(g_gmock_mutex);\n\n  // Returns the mock object this mock method belongs to.  Must be\n  // called after RegisterOwner() or SetOwnerAndName() has been\n  // called.\n  const void* MockObject() const\n      GTEST_LOCK_EXCLUDED_(g_gmock_mutex);\n\n  // Returns the name of this mock method.  Must be called after\n  // SetOwnerAndName() has been called.\n  const char* Name() const\n      GTEST_LOCK_EXCLUDED_(g_gmock_mutex);\n\n  // Returns the result of invoking this mock function with the given\n  // arguments.  This function can be safely called from multiple\n  // threads concurrently.  The caller is responsible for deleting the\n  // result.\n  UntypedActionResultHolderBase* UntypedInvokeWith(\n      const void* untyped_args)\n          GTEST_LOCK_EXCLUDED_(g_gmock_mutex);\n\n protected:\n  typedef std::vector<const void*> UntypedOnCallSpecs;\n\n  typedef std::vector<internal::linked_ptr<ExpectationBase> >\n  UntypedExpectations;\n\n  // Returns an Expectation object that references and co-owns exp,\n  // which must be an expectation on this mock function.\n  Expectation GetHandleOf(ExpectationBase* exp);\n\n  // Address of the mock object this mock method belongs to.  Only\n  // valid after this mock method has been called or\n  // ON_CALL/EXPECT_CALL has been invoked on it.\n  const void* mock_obj_;  // Protected by g_gmock_mutex.\n\n  // Name of the function being mocked.  Only valid after this mock\n  // method has been called.\n  const char* name_;  // Protected by g_gmock_mutex.\n\n  // All default action specs for this function mocker.\n  UntypedOnCallSpecs untyped_on_call_specs_;\n\n  // All expectations for this function mocker.\n  UntypedExpectations untyped_expectations_;\n};  // class UntypedFunctionMockerBase\n\n// Untyped base class for OnCallSpec<F>.\nclass UntypedOnCallSpecBase {\n public:\n  // The arguments are the location of the ON_CALL() statement.\n  UntypedOnCallSpecBase(const char* a_file, int a_line)\n      : file_(a_file), line_(a_line), last_clause_(kNone) {}\n\n  // Where in the source file was the default action spec defined?\n  const char* file() const { return file_; }\n  int line() const { return line_; }\n\n protected:\n  // Gives each clause in the ON_CALL() statement a name.\n  enum Clause {\n    // Do not change the order of the enum members!  The run-time\n    // syntax checking relies on it.\n    kNone,\n    kWith,\n    kWillByDefault\n  };\n\n  // Asserts that the ON_CALL() statement has a certain property.\n  void AssertSpecProperty(bool property, const string& failure_message) const {\n    Assert(property, file_, line_, failure_message);\n  }\n\n  // Expects that the ON_CALL() statement has a certain property.\n  void ExpectSpecProperty(bool property, const string& failure_message) const {\n    Expect(property, file_, line_, failure_message);\n  }\n\n  const char* file_;\n  int line_;\n\n  // The last clause in the ON_CALL() statement as seen so far.\n  // Initially kNone and changes as the statement is parsed.\n  Clause last_clause_;\n};  // class UntypedOnCallSpecBase\n\n// This template class implements an ON_CALL spec.\ntemplate <typename F>\nclass OnCallSpec : public UntypedOnCallSpecBase {\n public:\n  typedef typename Function<F>::ArgumentTuple ArgumentTuple;\n  typedef typename Function<F>::ArgumentMatcherTuple ArgumentMatcherTuple;\n\n  // Constructs an OnCallSpec object from the information inside\n  // the parenthesis of an ON_CALL() statement.\n  OnCallSpec(const char* a_file, int a_line,\n             const ArgumentMatcherTuple& matchers)\n      : UntypedOnCallSpecBase(a_file, a_line),\n        matchers_(matchers),\n        // By default, extra_matcher_ should match anything.  However,\n        // we cannot initialize it with _ as that triggers a compiler\n        // bug in Symbian's C++ compiler (cannot decide between two\n        // overloaded constructors of Matcher<const ArgumentTuple&>).\n        extra_matcher_(A<const ArgumentTuple&>()) {\n  }\n\n  // Implements the .With() clause.\n  OnCallSpec& With(const Matcher<const ArgumentTuple&>& m) {\n    // Makes sure this is called at most once.\n    ExpectSpecProperty(last_clause_ < kWith,\n                       \".With() cannot appear \"\n                       \"more than once in an ON_CALL().\");\n    last_clause_ = kWith;\n\n    extra_matcher_ = m;\n    return *this;\n  }\n\n  // Implements the .WillByDefault() clause.\n  OnCallSpec& WillByDefault(const Action<F>& action) {\n    ExpectSpecProperty(last_clause_ < kWillByDefault,\n                       \".WillByDefault() must appear \"\n                       \"exactly once in an ON_CALL().\");\n    last_clause_ = kWillByDefault;\n\n    ExpectSpecProperty(!action.IsDoDefault(),\n                       \"DoDefault() cannot be used in ON_CALL().\");\n    action_ = action;\n    return *this;\n  }\n\n  // Returns true iff the given arguments match the matchers.\n  bool Matches(const ArgumentTuple& args) const {\n    return TupleMatches(matchers_, args) && extra_matcher_.Matches(args);\n  }\n\n  // Returns the action specified by the user.\n  const Action<F>& GetAction() const {\n    AssertSpecProperty(last_clause_ == kWillByDefault,\n                       \".WillByDefault() must appear exactly \"\n                       \"once in an ON_CALL().\");\n    return action_;\n  }\n\n private:\n  // The information in statement\n  //\n  //   ON_CALL(mock_object, Method(matchers))\n  //       .With(multi-argument-matcher)\n  //       .WillByDefault(action);\n  //\n  // is recorded in the data members like this:\n  //\n  //   source file that contains the statement => file_\n  //   line number of the statement            => line_\n  //   matchers                                => matchers_\n  //   multi-argument-matcher                  => extra_matcher_\n  //   action                                  => action_\n  ArgumentMatcherTuple matchers_;\n  Matcher<const ArgumentTuple&> extra_matcher_;\n  Action<F> action_;\n};  // class OnCallSpec\n\n// Possible reactions on uninteresting calls.\nenum CallReaction {\n  kAllow,\n  kWarn,\n  kFail,\n  kDefault = kWarn  // By default, warn about uninteresting calls.\n};\n\n}  // namespace internal\n\n// Utilities for manipulating mock objects.\nclass GTEST_API_ Mock {\n public:\n  // The following public methods can be called concurrently.\n\n  // Tells Google Mock to ignore mock_obj when checking for leaked\n  // mock objects.\n  static void AllowLeak(const void* mock_obj)\n      GTEST_LOCK_EXCLUDED_(internal::g_gmock_mutex);\n\n  // Verifies and clears all expectations on the given mock object.\n  // If the expectations aren't satisfied, generates one or more\n  // Google Test non-fatal failures and returns false.\n  static bool VerifyAndClearExpectations(void* mock_obj)\n      GTEST_LOCK_EXCLUDED_(internal::g_gmock_mutex);\n\n  // Verifies all expectations on the given mock object and clears its\n  // default actions and expectations.  Returns true iff the\n  // verification was successful.\n  static bool VerifyAndClear(void* mock_obj)\n      GTEST_LOCK_EXCLUDED_(internal::g_gmock_mutex);\n\n private:\n  friend class internal::UntypedFunctionMockerBase;\n\n  // Needed for a function mocker to register itself (so that we know\n  // how to clear a mock object).\n  template <typename F>\n  friend class internal::FunctionMockerBase;\n\n  template <typename M>\n  friend class NiceMock;\n\n  template <typename M>\n  friend class NaggyMock;\n\n  template <typename M>\n  friend class StrictMock;\n\n  // Tells Google Mock to allow uninteresting calls on the given mock\n  // object.\n  static void AllowUninterestingCalls(const void* mock_obj)\n      GTEST_LOCK_EXCLUDED_(internal::g_gmock_mutex);\n\n  // Tells Google Mock to warn the user about uninteresting calls on\n  // the given mock object.\n  static void WarnUninterestingCalls(const void* mock_obj)\n      GTEST_LOCK_EXCLUDED_(internal::g_gmock_mutex);\n\n  // Tells Google Mock to fail uninteresting calls on the given mock\n  // object.\n  static void FailUninterestingCalls(const void* mock_obj)\n      GTEST_LOCK_EXCLUDED_(internal::g_gmock_mutex);\n\n  // Tells Google Mock the given mock object is being destroyed and\n  // its entry in the call-reaction table should be removed.\n  static void UnregisterCallReaction(const void* mock_obj)\n      GTEST_LOCK_EXCLUDED_(internal::g_gmock_mutex);\n\n  // Returns the reaction Google Mock will have on uninteresting calls\n  // made on the given mock object.\n  static internal::CallReaction GetReactionOnUninterestingCalls(\n      const void* mock_obj)\n          GTEST_LOCK_EXCLUDED_(internal::g_gmock_mutex);\n\n  // Verifies that all expectations on the given mock object have been\n  // satisfied.  Reports one or more Google Test non-fatal failures\n  // and returns false if not.\n  static bool VerifyAndClearExpectationsLocked(void* mock_obj)\n      GTEST_EXCLUSIVE_LOCK_REQUIRED_(internal::g_gmock_mutex);\n\n  // Clears all ON_CALL()s set on the given mock object.\n  static void ClearDefaultActionsLocked(void* mock_obj)\n      GTEST_EXCLUSIVE_LOCK_REQUIRED_(internal::g_gmock_mutex);\n\n  // Registers a mock object and a mock method it owns.\n  static void Register(\n      const void* mock_obj,\n      internal::UntypedFunctionMockerBase* mocker)\n          GTEST_LOCK_EXCLUDED_(internal::g_gmock_mutex);\n\n  // Tells Google Mock where in the source code mock_obj is used in an\n  // ON_CALL or EXPECT_CALL.  In case mock_obj is leaked, this\n  // information helps the user identify which object it is.\n  static void RegisterUseByOnCallOrExpectCall(\n      const void* mock_obj, const char* file, int line)\n          GTEST_LOCK_EXCLUDED_(internal::g_gmock_mutex);\n\n  // Unregisters a mock method; removes the owning mock object from\n  // the registry when the last mock method associated with it has\n  // been unregistered.  This is called only in the destructor of\n  // FunctionMockerBase.\n  static void UnregisterLocked(internal::UntypedFunctionMockerBase* mocker)\n      GTEST_EXCLUSIVE_LOCK_REQUIRED_(internal::g_gmock_mutex);\n};  // class Mock\n\n// An abstract handle of an expectation.  Useful in the .After()\n// clause of EXPECT_CALL() for setting the (partial) order of\n// expectations.  The syntax:\n//\n//   Expectation e1 = EXPECT_CALL(...)...;\n//   EXPECT_CALL(...).After(e1)...;\n//\n// sets two expectations where the latter can only be matched after\n// the former has been satisfied.\n//\n// Notes:\n//   - This class is copyable and has value semantics.\n//   - Constness is shallow: a const Expectation object itself cannot\n//     be modified, but the mutable methods of the ExpectationBase\n//     object it references can be called via expectation_base().\n//   - The constructors and destructor are defined out-of-line because\n//     the Symbian WINSCW compiler wants to otherwise instantiate them\n//     when it sees this class definition, at which point it doesn't have\n//     ExpectationBase available yet, leading to incorrect destruction\n//     in the linked_ptr (or compilation errors if using a checking\n//     linked_ptr).\nclass GTEST_API_ Expectation {\n public:\n  // Constructs a null object that doesn't reference any expectation.\n  Expectation();\n\n  ~Expectation();\n\n  // This single-argument ctor must not be explicit, in order to support the\n  //   Expectation e = EXPECT_CALL(...);\n  // syntax.\n  //\n  // A TypedExpectation object stores its pre-requisites as\n  // Expectation objects, and needs to call the non-const Retire()\n  // method on the ExpectationBase objects they reference.  Therefore\n  // Expectation must receive a *non-const* reference to the\n  // ExpectationBase object.\n  Expectation(internal::ExpectationBase& exp);  // NOLINT\n\n  // The compiler-generated copy ctor and operator= work exactly as\n  // intended, so we don't need to define our own.\n\n  // Returns true iff rhs references the same expectation as this object does.\n  bool operator==(const Expectation& rhs) const {\n    return expectation_base_ == rhs.expectation_base_;\n  }\n\n  bool operator!=(const Expectation& rhs) const { return !(*this == rhs); }\n\n private:\n  friend class ExpectationSet;\n  friend class Sequence;\n  friend class ::testing::internal::ExpectationBase;\n  friend class ::testing::internal::UntypedFunctionMockerBase;\n\n  template <typename F>\n  friend class ::testing::internal::FunctionMockerBase;\n\n  template <typename F>\n  friend class ::testing::internal::TypedExpectation;\n\n  // This comparator is needed for putting Expectation objects into a set.\n  class Less {\n   public:\n    bool operator()(const Expectation& lhs, const Expectation& rhs) const {\n      return lhs.expectation_base_.get() < rhs.expectation_base_.get();\n    }\n  };\n\n  typedef ::std::set<Expectation, Less> Set;\n\n  Expectation(\n      const internal::linked_ptr<internal::ExpectationBase>& expectation_base);\n\n  // Returns the expectation this object references.\n  const internal::linked_ptr<internal::ExpectationBase>&\n  expectation_base() const {\n    return expectation_base_;\n  }\n\n  // A linked_ptr that co-owns the expectation this handle references.\n  internal::linked_ptr<internal::ExpectationBase> expectation_base_;\n};\n\n// A set of expectation handles.  Useful in the .After() clause of\n// EXPECT_CALL() for setting the (partial) order of expectations.  The\n// syntax:\n//\n//   ExpectationSet es;\n//   es += EXPECT_CALL(...)...;\n//   es += EXPECT_CALL(...)...;\n//   EXPECT_CALL(...).After(es)...;\n//\n// sets three expectations where the last one can only be matched\n// after the first two have both been satisfied.\n//\n// This class is copyable and has value semantics.\nclass ExpectationSet {\n public:\n  // A bidirectional iterator that can read a const element in the set.\n  typedef Expectation::Set::const_iterator const_iterator;\n\n  // An object stored in the set.  This is an alias of Expectation.\n  typedef Expectation::Set::value_type value_type;\n\n  // Constructs an empty set.\n  ExpectationSet() {}\n\n  // This single-argument ctor must not be explicit, in order to support the\n  //   ExpectationSet es = EXPECT_CALL(...);\n  // syntax.\n  ExpectationSet(internal::ExpectationBase& exp) {  // NOLINT\n    *this += Expectation(exp);\n  }\n\n  // This single-argument ctor implements implicit conversion from\n  // Expectation and thus must not be explicit.  This allows either an\n  // Expectation or an ExpectationSet to be used in .After().\n  ExpectationSet(const Expectation& e) {  // NOLINT\n    *this += e;\n  }\n\n  // The compiler-generator ctor and operator= works exactly as\n  // intended, so we don't need to define our own.\n\n  // Returns true iff rhs contains the same set of Expectation objects\n  // as this does.\n  bool operator==(const ExpectationSet& rhs) const {\n    return expectations_ == rhs.expectations_;\n  }\n\n  bool operator!=(const ExpectationSet& rhs) const { return !(*this == rhs); }\n\n  // Implements the syntax\n  //   expectation_set += EXPECT_CALL(...);\n  ExpectationSet& operator+=(const Expectation& e) {\n    expectations_.insert(e);\n    return *this;\n  }\n\n  int size() const { return static_cast<int>(expectations_.size()); }\n\n  const_iterator begin() const { return expectations_.begin(); }\n  const_iterator end() const { return expectations_.end(); }\n\n private:\n  Expectation::Set expectations_;\n};\n\n\n// Sequence objects are used by a user to specify the relative order\n// in which the expectations should match.  They are copyable (we rely\n// on the compiler-defined copy constructor and assignment operator).\nclass GTEST_API_ Sequence {\n public:\n  // Constructs an empty sequence.\n  Sequence() : last_expectation_(new Expectation) {}\n\n  // Adds an expectation to this sequence.  The caller must ensure\n  // that no other thread is accessing this Sequence object.\n  void AddExpectation(const Expectation& expectation) const;\n\n private:\n  // The last expectation in this sequence.  We use a linked_ptr here\n  // because Sequence objects are copyable and we want the copies to\n  // be aliases.  The linked_ptr allows the copies to co-own and share\n  // the same Expectation object.\n  internal::linked_ptr<Expectation> last_expectation_;\n};  // class Sequence\n\n// An object of this type causes all EXPECT_CALL() statements\n// encountered in its scope to be put in an anonymous sequence.  The\n// work is done in the constructor and destructor.  You should only\n// create an InSequence object on the stack.\n//\n// The sole purpose for this class is to support easy definition of\n// sequential expectations, e.g.\n//\n//   {\n//     InSequence dummy;  // The name of the object doesn't matter.\n//\n//     // The following expectations must match in the order they appear.\n//     EXPECT_CALL(a, Bar())...;\n//     EXPECT_CALL(a, Baz())...;\n//     ...\n//     EXPECT_CALL(b, Xyz())...;\n//   }\n//\n// You can create InSequence objects in multiple threads, as long as\n// they are used to affect different mock objects.  The idea is that\n// each thread can create and set up its own mocks as if it's the only\n// thread.  However, for clarity of your tests we recommend you to set\n// up mocks in the main thread unless you have a good reason not to do\n// so.\nclass GTEST_API_ InSequence {\n public:\n  InSequence();\n  ~InSequence();\n private:\n  bool sequence_created_;\n\n  GTEST_DISALLOW_COPY_AND_ASSIGN_(InSequence);  // NOLINT\n} GTEST_ATTRIBUTE_UNUSED_;\n\nnamespace internal {\n\n// Points to the implicit sequence introduced by a living InSequence\n// object (if any) in the current thread or NULL.\nGTEST_API_ extern ThreadLocal<Sequence*> g_gmock_implicit_sequence;\n\n// Base class for implementing expectations.\n//\n// There are two reasons for having a type-agnostic base class for\n// Expectation:\n//\n//   1. We need to store collections of expectations of different\n//   types (e.g. all pre-requisites of a particular expectation, all\n//   expectations in a sequence).  Therefore these expectation objects\n//   must share a common base class.\n//\n//   2. We can avoid binary code bloat by moving methods not depending\n//   on the template argument of Expectation to the base class.\n//\n// This class is internal and mustn't be used by user code directly.\nclass GTEST_API_ ExpectationBase {\n public:\n  // source_text is the EXPECT_CALL(...) source that created this Expectation.\n  ExpectationBase(const char* file, int line, const string& source_text);\n\n  virtual ~ExpectationBase();\n\n  // Where in the source file was the expectation spec defined?\n  const char* file() const { return file_; }\n  int line() const { return line_; }\n  const char* source_text() const { return source_text_.c_str(); }\n  // Returns the cardinality specified in the expectation spec.\n  const Cardinality& cardinality() const { return cardinality_; }\n\n  // Describes the source file location of this expectation.\n  void DescribeLocationTo(::std::ostream* os) const {\n    *os << FormatFileLocation(file(), line()) << \" \";\n  }\n\n  // Describes how many times a function call matching this\n  // expectation has occurred.\n  void DescribeCallCountTo(::std::ostream* os) const\n      GTEST_EXCLUSIVE_LOCK_REQUIRED_(g_gmock_mutex);\n\n  // If this mock method has an extra matcher (i.e. .With(matcher)),\n  // describes it to the ostream.\n  virtual void MaybeDescribeExtraMatcherTo(::std::ostream* os) = 0;\n\n protected:\n  friend class ::testing::Expectation;\n  friend class UntypedFunctionMockerBase;\n\n  enum Clause {\n    // Don't change the order of the enum members!\n    kNone,\n    kWith,\n    kTimes,\n    kInSequence,\n    kAfter,\n    kWillOnce,\n    kWillRepeatedly,\n    kRetiresOnSaturation\n  };\n\n  typedef std::vector<const void*> UntypedActions;\n\n  // Returns an Expectation object that references and co-owns this\n  // expectation.\n  virtual Expectation GetHandle() = 0;\n\n  // Asserts that the EXPECT_CALL() statement has the given property.\n  void AssertSpecProperty(bool property, const string& failure_message) const {\n    Assert(property, file_, line_, failure_message);\n  }\n\n  // Expects that the EXPECT_CALL() statement has the given property.\n  void ExpectSpecProperty(bool property, const string& failure_message) const {\n    Expect(property, file_, line_, failure_message);\n  }\n\n  // Explicitly specifies the cardinality of this expectation.  Used\n  // by the subclasses to implement the .Times() clause.\n  void SpecifyCardinality(const Cardinality& cardinality);\n\n  // Returns true iff the user specified the cardinality explicitly\n  // using a .Times().\n  bool cardinality_specified() const { return cardinality_specified_; }\n\n  // Sets the cardinality of this expectation spec.\n  void set_cardinality(const Cardinality& a_cardinality) {\n    cardinality_ = a_cardinality;\n  }\n\n  // The following group of methods should only be called after the\n  // EXPECT_CALL() statement, and only when g_gmock_mutex is held by\n  // the current thread.\n\n  // Retires all pre-requisites of this expectation.\n  void RetireAllPreRequisites()\n      GTEST_EXCLUSIVE_LOCK_REQUIRED_(g_gmock_mutex);\n\n  // Returns true iff this expectation is retired.\n  bool is_retired() const\n      GTEST_EXCLUSIVE_LOCK_REQUIRED_(g_gmock_mutex) {\n    g_gmock_mutex.AssertHeld();\n    return retired_;\n  }\n\n  // Retires this expectation.\n  void Retire()\n      GTEST_EXCLUSIVE_LOCK_REQUIRED_(g_gmock_mutex) {\n    g_gmock_mutex.AssertHeld();\n    retired_ = true;\n  }\n\n  // Returns true iff this expectation is satisfied.\n  bool IsSatisfied() const\n      GTEST_EXCLUSIVE_LOCK_REQUIRED_(g_gmock_mutex) {\n    g_gmock_mutex.AssertHeld();\n    return cardinality().IsSatisfiedByCallCount(call_count_);\n  }\n\n  // Returns true iff this expectation is saturated.\n  bool IsSaturated() const\n      GTEST_EXCLUSIVE_LOCK_REQUIRED_(g_gmock_mutex) {\n    g_gmock_mutex.AssertHeld();\n    return cardinality().IsSaturatedByCallCount(call_count_);\n  }\n\n  // Returns true iff this expectation is over-saturated.\n  bool IsOverSaturated() const\n      GTEST_EXCLUSIVE_LOCK_REQUIRED_(g_gmock_mutex) {\n    g_gmock_mutex.AssertHeld();\n    return cardinality().IsOverSaturatedByCallCount(call_count_);\n  }\n\n  // Returns true iff all pre-requisites of this expectation are satisfied.\n  bool AllPrerequisitesAreSatisfied() const\n      GTEST_EXCLUSIVE_LOCK_REQUIRED_(g_gmock_mutex);\n\n  // Adds unsatisfied pre-requisites of this expectation to 'result'.\n  void FindUnsatisfiedPrerequisites(ExpectationSet* result) const\n      GTEST_EXCLUSIVE_LOCK_REQUIRED_(g_gmock_mutex);\n\n  // Returns the number this expectation has been invoked.\n  int call_count() const\n      GTEST_EXCLUSIVE_LOCK_REQUIRED_(g_gmock_mutex) {\n    g_gmock_mutex.AssertHeld();\n    return call_count_;\n  }\n\n  // Increments the number this expectation has been invoked.\n  void IncrementCallCount()\n      GTEST_EXCLUSIVE_LOCK_REQUIRED_(g_gmock_mutex) {\n    g_gmock_mutex.AssertHeld();\n    call_count_++;\n  }\n\n  // Checks the action count (i.e. the number of WillOnce() and\n  // WillRepeatedly() clauses) against the cardinality if this hasn't\n  // been done before.  Prints a warning if there are too many or too\n  // few actions.\n  void CheckActionCountIfNotDone() const\n      GTEST_LOCK_EXCLUDED_(mutex_);\n\n  friend class ::testing::Sequence;\n  friend class ::testing::internal::ExpectationTester;\n\n  template <typename Function>\n  friend class TypedExpectation;\n\n  // Implements the .Times() clause.\n  void UntypedTimes(const Cardinality& a_cardinality);\n\n  // This group of fields are part of the spec and won't change after\n  // an EXPECT_CALL() statement finishes.\n  const char* file_;          // The file that contains the expectation.\n  int line_;                  // The line number of the expectation.\n  const string source_text_;  // The EXPECT_CALL(...) source text.\n  // True iff the cardinality is specified explicitly.\n  bool cardinality_specified_;\n  Cardinality cardinality_;            // The cardinality of the expectation.\n  // The immediate pre-requisites (i.e. expectations that must be\n  // satisfied before this expectation can be matched) of this\n  // expectation.  We use linked_ptr in the set because we want an\n  // Expectation object to be co-owned by its FunctionMocker and its\n  // successors.  This allows multiple mock objects to be deleted at\n  // different times.\n  ExpectationSet immediate_prerequisites_;\n\n  // This group of fields are the current state of the expectation,\n  // and can change as the mock function is called.\n  int call_count_;  // How many times this expectation has been invoked.\n  bool retired_;    // True iff this expectation has retired.\n  UntypedActions untyped_actions_;\n  bool extra_matcher_specified_;\n  bool repeated_action_specified_;  // True if a WillRepeatedly() was specified.\n  bool retires_on_saturation_;\n  Clause last_clause_;\n  mutable bool action_count_checked_;  // Under mutex_.\n  mutable Mutex mutex_;  // Protects action_count_checked_.\n\n  GTEST_DISALLOW_ASSIGN_(ExpectationBase);\n};  // class ExpectationBase\n\n// Impements an expectation for the given function type.\ntemplate <typename F>\nclass TypedExpectation : public ExpectationBase {\n public:\n  typedef typename Function<F>::ArgumentTuple ArgumentTuple;\n  typedef typename Function<F>::ArgumentMatcherTuple ArgumentMatcherTuple;\n  typedef typename Function<F>::Result Result;\n\n  TypedExpectation(FunctionMockerBase<F>* owner,\n                   const char* a_file, int a_line, const string& a_source_text,\n                   const ArgumentMatcherTuple& m)\n      : ExpectationBase(a_file, a_line, a_source_text),\n        owner_(owner),\n        matchers_(m),\n        // By default, extra_matcher_ should match anything.  However,\n        // we cannot initialize it with _ as that triggers a compiler\n        // bug in Symbian's C++ compiler (cannot decide between two\n        // overloaded constructors of Matcher<const ArgumentTuple&>).\n        extra_matcher_(A<const ArgumentTuple&>()),\n        repeated_action_(DoDefault()) {}\n\n  virtual ~TypedExpectation() {\n    // Check the validity of the action count if it hasn't been done\n    // yet (for example, if the expectation was never used).\n    CheckActionCountIfNotDone();\n    for (UntypedActions::const_iterator it = untyped_actions_.begin();\n         it != untyped_actions_.end(); ++it) {\n      delete static_cast<const Action<F>*>(*it);\n    }\n  }\n\n  // Implements the .With() clause.\n  TypedExpectation& With(const Matcher<const ArgumentTuple&>& m) {\n    if (last_clause_ == kWith) {\n      ExpectSpecProperty(false,\n                         \".With() cannot appear \"\n                         \"more than once in an EXPECT_CALL().\");\n    } else {\n      ExpectSpecProperty(last_clause_ < kWith,\n                         \".With() must be the first \"\n                         \"clause in an EXPECT_CALL().\");\n    }\n    last_clause_ = kWith;\n\n    extra_matcher_ = m;\n    extra_matcher_specified_ = true;\n    return *this;\n  }\n\n  // Implements the .Times() clause.\n  TypedExpectation& Times(const Cardinality& a_cardinality) {\n    ExpectationBase::UntypedTimes(a_cardinality);\n    return *this;\n  }\n\n  // Implements the .Times() clause.\n  TypedExpectation& Times(int n) {\n    return Times(Exactly(n));\n  }\n\n  // Implements the .InSequence() clause.\n  TypedExpectation& InSequence(const Sequence& s) {\n    ExpectSpecProperty(last_clause_ <= kInSequence,\n                       \".InSequence() cannot appear after .After(),\"\n                       \" .WillOnce(), .WillRepeatedly(), or \"\n                       \".RetiresOnSaturation().\");\n    last_clause_ = kInSequence;\n\n    s.AddExpectation(GetHandle());\n    return *this;\n  }\n  TypedExpectation& InSequence(const Sequence& s1, const Sequence& s2) {\n    return InSequence(s1).InSequence(s2);\n  }\n  TypedExpectation& InSequence(const Sequence& s1, const Sequence& s2,\n                               const Sequence& s3) {\n    return InSequence(s1, s2).InSequence(s3);\n  }\n  TypedExpectation& InSequence(const Sequence& s1, const Sequence& s2,\n                               const Sequence& s3, const Sequence& s4) {\n    return InSequence(s1, s2, s3).InSequence(s4);\n  }\n  TypedExpectation& InSequence(const Sequence& s1, const Sequence& s2,\n                               const Sequence& s3, const Sequence& s4,\n                               const Sequence& s5) {\n    return InSequence(s1, s2, s3, s4).InSequence(s5);\n  }\n\n  // Implements that .After() clause.\n  TypedExpectation& After(const ExpectationSet& s) {\n    ExpectSpecProperty(last_clause_ <= kAfter,\n                       \".After() cannot appear after .WillOnce(),\"\n                       \" .WillRepeatedly(), or \"\n                       \".RetiresOnSaturation().\");\n    last_clause_ = kAfter;\n\n    for (ExpectationSet::const_iterator it = s.begin(); it != s.end(); ++it) {\n      immediate_prerequisites_ += *it;\n    }\n    return *this;\n  }\n  TypedExpectation& After(const ExpectationSet& s1, const ExpectationSet& s2) {\n    return After(s1).After(s2);\n  }\n  TypedExpectation& After(const ExpectationSet& s1, const ExpectationSet& s2,\n                          const ExpectationSet& s3) {\n    return After(s1, s2).After(s3);\n  }\n  TypedExpectation& After(const ExpectationSet& s1, const ExpectationSet& s2,\n                          const ExpectationSet& s3, const ExpectationSet& s4) {\n    return After(s1, s2, s3).After(s4);\n  }\n  TypedExpectation& After(const ExpectationSet& s1, const ExpectationSet& s2,\n                          const ExpectationSet& s3, const ExpectationSet& s4,\n                          const ExpectationSet& s5) {\n    return After(s1, s2, s3, s4).After(s5);\n  }\n\n  // Implements the .WillOnce() clause.\n  TypedExpectation& WillOnce(const Action<F>& action) {\n    ExpectSpecProperty(last_clause_ <= kWillOnce,\n                       \".WillOnce() cannot appear after \"\n                       \".WillRepeatedly() or .RetiresOnSaturation().\");\n    last_clause_ = kWillOnce;\n\n    untyped_actions_.push_back(new Action<F>(action));\n    if (!cardinality_specified()) {\n      set_cardinality(Exactly(static_cast<int>(untyped_actions_.size())));\n    }\n    return *this;\n  }\n\n  // Implements the .WillRepeatedly() clause.\n  TypedExpectation& WillRepeatedly(const Action<F>& action) {\n    if (last_clause_ == kWillRepeatedly) {\n      ExpectSpecProperty(false,\n                         \".WillRepeatedly() cannot appear \"\n                         \"more than once in an EXPECT_CALL().\");\n    } else {\n      ExpectSpecProperty(last_clause_ < kWillRepeatedly,\n                         \".WillRepeatedly() cannot appear \"\n                         \"after .RetiresOnSaturation().\");\n    }\n    last_clause_ = kWillRepeatedly;\n    repeated_action_specified_ = true;\n\n    repeated_action_ = action;\n    if (!cardinality_specified()) {\n      set_cardinality(AtLeast(static_cast<int>(untyped_actions_.size())));\n    }\n\n    // Now that no more action clauses can be specified, we check\n    // whether their count makes sense.\n    CheckActionCountIfNotDone();\n    return *this;\n  }\n\n  // Implements the .RetiresOnSaturation() clause.\n  TypedExpectation& RetiresOnSaturation() {\n    ExpectSpecProperty(last_clause_ < kRetiresOnSaturation,\n                       \".RetiresOnSaturation() cannot appear \"\n                       \"more than once.\");\n    last_clause_ = kRetiresOnSaturation;\n    retires_on_saturation_ = true;\n\n    // Now that no more action clauses can be specified, we check\n    // whether their count makes sense.\n    CheckActionCountIfNotDone();\n    return *this;\n  }\n\n  // Returns the matchers for the arguments as specified inside the\n  // EXPECT_CALL() macro.\n  const ArgumentMatcherTuple& matchers() const {\n    return matchers_;\n  }\n\n  // Returns the matcher specified by the .With() clause.\n  const Matcher<const ArgumentTuple&>& extra_matcher() const {\n    return extra_matcher_;\n  }\n\n  // Returns the action specified by the .WillRepeatedly() clause.\n  const Action<F>& repeated_action() const { return repeated_action_; }\n\n  // If this mock method has an extra matcher (i.e. .With(matcher)),\n  // describes it to the ostream.\n  virtual void MaybeDescribeExtraMatcherTo(::std::ostream* os) {\n    if (extra_matcher_specified_) {\n      *os << \"    Expected args: \";\n      extra_matcher_.DescribeTo(os);\n      *os << \"\\n\";\n    }\n  }\n\n private:\n  template <typename Function>\n  friend class FunctionMockerBase;\n\n  // Returns an Expectation object that references and co-owns this\n  // expectation.\n  virtual Expectation GetHandle() {\n    return owner_->GetHandleOf(this);\n  }\n\n  // The following methods will be called only after the EXPECT_CALL()\n  // statement finishes and when the current thread holds\n  // g_gmock_mutex.\n\n  // Returns true iff this expectation matches the given arguments.\n  bool Matches(const ArgumentTuple& args) const\n      GTEST_EXCLUSIVE_LOCK_REQUIRED_(g_gmock_mutex) {\n    g_gmock_mutex.AssertHeld();\n    return TupleMatches(matchers_, args) && extra_matcher_.Matches(args);\n  }\n\n  // Returns true iff this expectation should handle the given arguments.\n  bool ShouldHandleArguments(const ArgumentTuple& args) const\n      GTEST_EXCLUSIVE_LOCK_REQUIRED_(g_gmock_mutex) {\n    g_gmock_mutex.AssertHeld();\n\n    // In case the action count wasn't checked when the expectation\n    // was defined (e.g. if this expectation has no WillRepeatedly()\n    // or RetiresOnSaturation() clause), we check it when the\n    // expectation is used for the first time.\n    CheckActionCountIfNotDone();\n    return !is_retired() && AllPrerequisitesAreSatisfied() && Matches(args);\n  }\n\n  // Describes the result of matching the arguments against this\n  // expectation to the given ostream.\n  void ExplainMatchResultTo(\n      const ArgumentTuple& args,\n      ::std::ostream* os) const\n          GTEST_EXCLUSIVE_LOCK_REQUIRED_(g_gmock_mutex) {\n    g_gmock_mutex.AssertHeld();\n\n    if (is_retired()) {\n      *os << \"         Expected: the expectation is active\\n\"\n          << \"           Actual: it is retired\\n\";\n    } else if (!Matches(args)) {\n      if (!TupleMatches(matchers_, args)) {\n        ExplainMatchFailureTupleTo(matchers_, args, os);\n      }\n      StringMatchResultListener listener;\n      if (!extra_matcher_.MatchAndExplain(args, &listener)) {\n        *os << \"    Expected args: \";\n        extra_matcher_.DescribeTo(os);\n        *os << \"\\n           Actual: don't match\";\n\n        internal::PrintIfNotEmpty(listener.str(), os);\n        *os << \"\\n\";\n      }\n    } else if (!AllPrerequisitesAreSatisfied()) {\n      *os << \"         Expected: all pre-requisites are satisfied\\n\"\n          << \"           Actual: the following immediate pre-requisites \"\n          << \"are not satisfied:\\n\";\n      ExpectationSet unsatisfied_prereqs;\n      FindUnsatisfiedPrerequisites(&unsatisfied_prereqs);\n      int i = 0;\n      for (ExpectationSet::const_iterator it = unsatisfied_prereqs.begin();\n           it != unsatisfied_prereqs.end(); ++it) {\n        it->expectation_base()->DescribeLocationTo(os);\n        *os << \"pre-requisite #\" << i++ << \"\\n\";\n      }\n      *os << \"                   (end of pre-requisites)\\n\";\n    } else {\n      // This line is here just for completeness' sake.  It will never\n      // be executed as currently the ExplainMatchResultTo() function\n      // is called only when the mock function call does NOT match the\n      // expectation.\n      *os << \"The call matches the expectation.\\n\";\n    }\n  }\n\n  // Returns the action that should be taken for the current invocation.\n  const Action<F>& GetCurrentAction(\n      const FunctionMockerBase<F>* mocker,\n      const ArgumentTuple& args) const\n          GTEST_EXCLUSIVE_LOCK_REQUIRED_(g_gmock_mutex) {\n    g_gmock_mutex.AssertHeld();\n    const int count = call_count();\n    Assert(count >= 1, __FILE__, __LINE__,\n           \"call_count() is <= 0 when GetCurrentAction() is \"\n           \"called - this should never happen.\");\n\n    const int action_count = static_cast<int>(untyped_actions_.size());\n    if (action_count > 0 && !repeated_action_specified_ &&\n        count > action_count) {\n      // If there is at least one WillOnce() and no WillRepeatedly(),\n      // we warn the user when the WillOnce() clauses ran out.\n      ::std::stringstream ss;\n      DescribeLocationTo(&ss);\n      ss << \"Actions ran out in \" << source_text() << \"...\\n\"\n         << \"Called \" << count << \" times, but only \"\n         << action_count << \" WillOnce()\"\n         << (action_count == 1 ? \" is\" : \"s are\") << \" specified - \";\n      mocker->DescribeDefaultActionTo(args, &ss);\n      Log(kWarning, ss.str(), 1);\n    }\n\n    return count <= action_count ?\n        *static_cast<const Action<F>*>(untyped_actions_[count - 1]) :\n        repeated_action();\n  }\n\n  // Given the arguments of a mock function call, if the call will\n  // over-saturate this expectation, returns the default action;\n  // otherwise, returns the next action in this expectation.  Also\n  // describes *what* happened to 'what', and explains *why* Google\n  // Mock does it to 'why'.  This method is not const as it calls\n  // IncrementCallCount().  A return value of NULL means the default\n  // action.\n  const Action<F>* GetActionForArguments(\n      const FunctionMockerBase<F>* mocker,\n      const ArgumentTuple& args,\n      ::std::ostream* what,\n      ::std::ostream* why)\n          GTEST_EXCLUSIVE_LOCK_REQUIRED_(g_gmock_mutex) {\n    g_gmock_mutex.AssertHeld();\n    if (IsSaturated()) {\n      // We have an excessive call.\n      IncrementCallCount();\n      *what << \"Mock function called more times than expected - \";\n      mocker->DescribeDefaultActionTo(args, what);\n      DescribeCallCountTo(why);\n\n      // TODO(wan@google.com): allow the user to control whether\n      // unexpected calls should fail immediately or continue using a\n      // flag --gmock_unexpected_calls_are_fatal.\n      return NULL;\n    }\n\n    IncrementCallCount();\n    RetireAllPreRequisites();\n\n    if (retires_on_saturation_ && IsSaturated()) {\n      Retire();\n    }\n\n    // Must be done after IncrementCount()!\n    *what << \"Mock function call matches \" << source_text() <<\"...\\n\";\n    return &(GetCurrentAction(mocker, args));\n  }\n\n  // All the fields below won't change once the EXPECT_CALL()\n  // statement finishes.\n  FunctionMockerBase<F>* const owner_;\n  ArgumentMatcherTuple matchers_;\n  Matcher<const ArgumentTuple&> extra_matcher_;\n  Action<F> repeated_action_;\n\n  GTEST_DISALLOW_COPY_AND_ASSIGN_(TypedExpectation);\n};  // class TypedExpectation\n\n// A MockSpec object is used by ON_CALL() or EXPECT_CALL() for\n// specifying the default behavior of, or expectation on, a mock\n// function.\n\n// Note: class MockSpec really belongs to the ::testing namespace.\n// However if we define it in ::testing, MSVC will complain when\n// classes in ::testing::internal declare it as a friend class\n// template.  To workaround this compiler bug, we define MockSpec in\n// ::testing::internal and import it into ::testing.\n\n// Logs a message including file and line number information.\nGTEST_API_ void LogWithLocation(testing::internal::LogSeverity severity,\n                                const char* file, int line,\n                                const string& message);\n\ntemplate <typename F>\nclass MockSpec {\n public:\n  typedef typename internal::Function<F>::ArgumentTuple ArgumentTuple;\n  typedef typename internal::Function<F>::ArgumentMatcherTuple\n      ArgumentMatcherTuple;\n\n  // Constructs a MockSpec object, given the function mocker object\n  // that the spec is associated with.\n  explicit MockSpec(internal::FunctionMockerBase<F>* function_mocker)\n      : function_mocker_(function_mocker) {}\n\n  // Adds a new default action spec to the function mocker and returns\n  // the newly created spec.\n  internal::OnCallSpec<F>& InternalDefaultActionSetAt(\n      const char* file, int line, const char* obj, const char* call) {\n    LogWithLocation(internal::kInfo, file, line,\n        string(\"ON_CALL(\") + obj + \", \" + call + \") invoked\");\n    return function_mocker_->AddNewOnCallSpec(file, line, matchers_);\n  }\n\n  // Adds a new expectation spec to the function mocker and returns\n  // the newly created spec.\n  internal::TypedExpectation<F>& InternalExpectedAt(\n      const char* file, int line, const char* obj, const char* call) {\n    const string source_text(string(\"EXPECT_CALL(\") + obj + \", \" + call + \")\");\n    LogWithLocation(internal::kInfo, file, line, source_text + \" invoked\");\n    return function_mocker_->AddNewExpectation(\n        file, line, source_text, matchers_);\n  }\n\n private:\n  template <typename Function>\n  friend class internal::FunctionMocker;\n\n  void SetMatchers(const ArgumentMatcherTuple& matchers) {\n    matchers_ = matchers;\n  }\n\n  // The function mocker that owns this spec.\n  internal::FunctionMockerBase<F>* const function_mocker_;\n  // The argument matchers specified in the spec.\n  ArgumentMatcherTuple matchers_;\n\n  GTEST_DISALLOW_ASSIGN_(MockSpec);\n};  // class MockSpec\n\n// Wrapper type for generically holding an ordinary value or lvalue reference.\n// If T is not a reference type, it must be copyable or movable.\n// ReferenceOrValueWrapper<T> is movable, and will also be copyable unless\n// T is a move-only value type (which means that it will always be copyable\n// if the current platform does not support move semantics).\n//\n// The primary template defines handling for values, but function header\n// comments describe the contract for the whole template (including\n// specializations).\ntemplate <typename T>\nclass ReferenceOrValueWrapper {\n public:\n  // Constructs a wrapper from the given value/reference.\n  explicit ReferenceOrValueWrapper(T value)\n      : value_(::testing::internal::move(value)) {\n  }\n\n  // Unwraps and returns the underlying value/reference, exactly as\n  // originally passed. The behavior of calling this more than once on\n  // the same object is unspecified.\n  T Unwrap() { return ::testing::internal::move(value_); }\n\n  // Provides nondestructive access to the underlying value/reference.\n  // Always returns a const reference (more precisely,\n  // const RemoveReference<T>&). The behavior of calling this after\n  // calling Unwrap on the same object is unspecified.\n  const T& Peek() const {\n    return value_;\n  }\n\n private:\n  T value_;\n};\n\n// Specialization for lvalue reference types. See primary template\n// for documentation.\ntemplate <typename T>\nclass ReferenceOrValueWrapper<T&> {\n public:\n  // Workaround for debatable pass-by-reference lint warning (c-library-team\n  // policy precludes NOLINT in this context)\n  typedef T& reference;\n  explicit ReferenceOrValueWrapper(reference ref)\n      : value_ptr_(&ref) {}\n  T& Unwrap() { return *value_ptr_; }\n  const T& Peek() const { return *value_ptr_; }\n\n private:\n  T* value_ptr_;\n};\n\n// MSVC warns about using 'this' in base member initializer list, so\n// we need to temporarily disable the warning.  We have to do it for\n// the entire class to suppress the warning, even though it's about\n// the constructor only.\n\n#ifdef _MSC_VER\n# pragma warning(push)          // Saves the current warning state.\n# pragma warning(disable:4355)  // Temporarily disables warning 4355.\n#endif  // _MSV_VER\n\n// C++ treats the void type specially.  For example, you cannot define\n// a void-typed variable or pass a void value to a function.\n// ActionResultHolder<T> holds a value of type T, where T must be a\n// copyable type or void (T doesn't need to be default-constructable).\n// It hides the syntactic difference between void and other types, and\n// is used to unify the code for invoking both void-returning and\n// non-void-returning mock functions.\n\n// Untyped base class for ActionResultHolder<T>.\nclass UntypedActionResultHolderBase {\n public:\n  virtual ~UntypedActionResultHolderBase() {}\n\n  // Prints the held value as an action's result to os.\n  virtual void PrintAsActionResult(::std::ostream* os) const = 0;\n};\n\n// This generic definition is used when T is not void.\ntemplate <typename T>\nclass ActionResultHolder : public UntypedActionResultHolderBase {\n public:\n  // Returns the held value. Must not be called more than once.\n  T Unwrap() {\n    return result_.Unwrap();\n  }\n\n  // Prints the held value as an action's result to os.\n  virtual void PrintAsActionResult(::std::ostream* os) const {\n    *os << \"\\n          Returns: \";\n    // T may be a reference type, so we don't use UniversalPrint().\n    UniversalPrinter<T>::Print(result_.Peek(), os);\n  }\n\n  // Performs the given mock function's default action and returns the\n  // result in a new-ed ActionResultHolder.\n  template <typename F>\n  static ActionResultHolder* PerformDefaultAction(\n      const FunctionMockerBase<F>* func_mocker,\n      const typename Function<F>::ArgumentTuple& args,\n      const string& call_description) {\n    return new ActionResultHolder(Wrapper(\n        func_mocker->PerformDefaultAction(args, call_description)));\n  }\n\n  // Performs the given action and returns the result in a new-ed\n  // ActionResultHolder.\n  template <typename F>\n  static ActionResultHolder*\n  PerformAction(const Action<F>& action,\n                const typename Function<F>::ArgumentTuple& args) {\n    return new ActionResultHolder(Wrapper(action.Perform(args)));\n  }\n\n private:\n  typedef ReferenceOrValueWrapper<T> Wrapper;\n\n  explicit ActionResultHolder(Wrapper result)\n      : result_(::testing::internal::move(result)) {\n  }\n\n  Wrapper result_;\n\n  GTEST_DISALLOW_COPY_AND_ASSIGN_(ActionResultHolder);\n};\n\n// Specialization for T = void.\ntemplate <>\nclass ActionResultHolder<void> : public UntypedActionResultHolderBase {\n public:\n  void Unwrap() { }\n\n  virtual void PrintAsActionResult(::std::ostream* /* os */) const {}\n\n  // Performs the given mock function's default action and returns ownership\n  // of an empty ActionResultHolder*.\n  template <typename F>\n  static ActionResultHolder* PerformDefaultAction(\n      const FunctionMockerBase<F>* func_mocker,\n      const typename Function<F>::ArgumentTuple& args,\n      const string& call_description) {\n    func_mocker->PerformDefaultAction(args, call_description);\n    return new ActionResultHolder;\n  }\n\n  // Performs the given action and returns ownership of an empty\n  // ActionResultHolder*.\n  template <typename F>\n  static ActionResultHolder* PerformAction(\n      const Action<F>& action,\n      const typename Function<F>::ArgumentTuple& args) {\n    action.Perform(args);\n    return new ActionResultHolder;\n  }\n\n private:\n  ActionResultHolder() {}\n  GTEST_DISALLOW_COPY_AND_ASSIGN_(ActionResultHolder);\n};\n\n// The base of the function mocker class for the given function type.\n// We put the methods in this class instead of its child to avoid code\n// bloat.\ntemplate <typename F>\nclass FunctionMockerBase : public UntypedFunctionMockerBase {\n public:\n  typedef typename Function<F>::Result Result;\n  typedef typename Function<F>::ArgumentTuple ArgumentTuple;\n  typedef typename Function<F>::ArgumentMatcherTuple ArgumentMatcherTuple;\n\n  FunctionMockerBase() : current_spec_(this) {}\n\n  // The destructor verifies that all expectations on this mock\n  // function have been satisfied.  If not, it will report Google Test\n  // non-fatal failures for the violations.\n  virtual ~FunctionMockerBase()\n        GTEST_LOCK_EXCLUDED_(g_gmock_mutex) {\n    MutexLock l(&g_gmock_mutex);\n    VerifyAndClearExpectationsLocked();\n    Mock::UnregisterLocked(this);\n    ClearDefaultActionsLocked();\n  }\n\n  // Returns the ON_CALL spec that matches this mock function with the\n  // given arguments; returns NULL if no matching ON_CALL is found.\n  // L = *\n  const OnCallSpec<F>* FindOnCallSpec(\n      const ArgumentTuple& args) const {\n    for (UntypedOnCallSpecs::const_reverse_iterator it\n             = untyped_on_call_specs_.rbegin();\n         it != untyped_on_call_specs_.rend(); ++it) {\n      const OnCallSpec<F>* spec = static_cast<const OnCallSpec<F>*>(*it);\n      if (spec->Matches(args))\n        return spec;\n    }\n\n    return NULL;\n  }\n\n  // Performs the default action of this mock function on the given\n  // arguments and returns the result. Asserts (or throws if\n  // exceptions are enabled) with a helpful call descrption if there\n  // is no valid return value. This method doesn't depend on the\n  // mutable state of this object, and thus can be called concurrently\n  // without locking.\n  // L = *\n  Result PerformDefaultAction(const ArgumentTuple& args,\n                              const string& call_description) const {\n    const OnCallSpec<F>* const spec =\n        this->FindOnCallSpec(args);\n    if (spec != NULL) {\n      return spec->GetAction().Perform(args);\n    }\n    const string message = call_description +\n        \"\\n    The mock function has no default action \"\n        \"set, and its return type has no default value set.\";\n#if GTEST_HAS_EXCEPTIONS\n    if (!DefaultValue<Result>::Exists()) {\n      throw std::runtime_error(message);\n    }\n#else\n    Assert(DefaultValue<Result>::Exists(), \"\", -1, message);\n#endif\n    return DefaultValue<Result>::Get();\n  }\n\n  // Performs the default action with the given arguments and returns\n  // the action's result.  The call description string will be used in\n  // the error message to describe the call in the case the default\n  // action fails.  The caller is responsible for deleting the result.\n  // L = *\n  virtual UntypedActionResultHolderBase* UntypedPerformDefaultAction(\n      const void* untyped_args,  // must point to an ArgumentTuple\n      const string& call_description) const {\n    const ArgumentTuple& args =\n        *static_cast<const ArgumentTuple*>(untyped_args);\n    return ResultHolder::PerformDefaultAction(this, args, call_description);\n  }\n\n  // Performs the given action with the given arguments and returns\n  // the action's result.  The caller is responsible for deleting the\n  // result.\n  // L = *\n  virtual UntypedActionResultHolderBase* UntypedPerformAction(\n      const void* untyped_action, const void* untyped_args) const {\n    // Make a copy of the action before performing it, in case the\n    // action deletes the mock object (and thus deletes itself).\n    const Action<F> action = *static_cast<const Action<F>*>(untyped_action);\n    const ArgumentTuple& args =\n        *static_cast<const ArgumentTuple*>(untyped_args);\n    return ResultHolder::PerformAction(action, args);\n  }\n\n  // Implements UntypedFunctionMockerBase::ClearDefaultActionsLocked():\n  // clears the ON_CALL()s set on this mock function.\n  virtual void ClearDefaultActionsLocked()\n      GTEST_EXCLUSIVE_LOCK_REQUIRED_(g_gmock_mutex) {\n    g_gmock_mutex.AssertHeld();\n\n    // Deleting our default actions may trigger other mock objects to be\n    // deleted, for example if an action contains a reference counted smart\n    // pointer to that mock object, and that is the last reference. So if we\n    // delete our actions within the context of the global mutex we may deadlock\n    // when this method is called again. Instead, make a copy of the set of\n    // actions to delete, clear our set within the mutex, and then delete the\n    // actions outside of the mutex.\n    UntypedOnCallSpecs specs_to_delete;\n    untyped_on_call_specs_.swap(specs_to_delete);\n\n    g_gmock_mutex.Unlock();\n    for (UntypedOnCallSpecs::const_iterator it =\n             specs_to_delete.begin();\n         it != specs_to_delete.end(); ++it) {\n      delete static_cast<const OnCallSpec<F>*>(*it);\n    }\n\n    // Lock the mutex again, since the caller expects it to be locked when we\n    // return.\n    g_gmock_mutex.Lock();\n  }\n\n protected:\n  template <typename Function>\n  friend class MockSpec;\n\n  typedef ActionResultHolder<Result> ResultHolder;\n\n  // Returns the result of invoking this mock function with the given\n  // arguments.  This function can be safely called from multiple\n  // threads concurrently.\n  Result InvokeWith(const ArgumentTuple& args)\n        GTEST_LOCK_EXCLUDED_(g_gmock_mutex) {\n    scoped_ptr<ResultHolder> holder(\n        DownCast_<ResultHolder*>(this->UntypedInvokeWith(&args)));\n    return holder->Unwrap();\n  }\n\n  // Adds and returns a default action spec for this mock function.\n  OnCallSpec<F>& AddNewOnCallSpec(\n      const char* file, int line,\n      const ArgumentMatcherTuple& m)\n          GTEST_LOCK_EXCLUDED_(g_gmock_mutex) {\n    Mock::RegisterUseByOnCallOrExpectCall(MockObject(), file, line);\n    OnCallSpec<F>* const on_call_spec = new OnCallSpec<F>(file, line, m);\n    untyped_on_call_specs_.push_back(on_call_spec);\n    return *on_call_spec;\n  }\n\n  // Adds and returns an expectation spec for this mock function.\n  TypedExpectation<F>& AddNewExpectation(\n      const char* file,\n      int line,\n      const string& source_text,\n      const ArgumentMatcherTuple& m)\n          GTEST_LOCK_EXCLUDED_(g_gmock_mutex) {\n    Mock::RegisterUseByOnCallOrExpectCall(MockObject(), file, line);\n    TypedExpectation<F>* const expectation =\n        new TypedExpectation<F>(this, file, line, source_text, m);\n    const linked_ptr<ExpectationBase> untyped_expectation(expectation);\n    untyped_expectations_.push_back(untyped_expectation);\n\n    // Adds this expectation into the implicit sequence if there is one.\n    Sequence* const implicit_sequence = g_gmock_implicit_sequence.get();\n    if (implicit_sequence != NULL) {\n      implicit_sequence->AddExpectation(Expectation(untyped_expectation));\n    }\n\n    return *expectation;\n  }\n\n  // The current spec (either default action spec or expectation spec)\n  // being described on this function mocker.\n  MockSpec<F>& current_spec() { return current_spec_; }\n\n private:\n  template <typename Func> friend class TypedExpectation;\n\n  // Some utilities needed for implementing UntypedInvokeWith().\n\n  // Describes what default action will be performed for the given\n  // arguments.\n  // L = *\n  void DescribeDefaultActionTo(const ArgumentTuple& args,\n                               ::std::ostream* os) const {\n    const OnCallSpec<F>* const spec = FindOnCallSpec(args);\n\n    if (spec == NULL) {\n      *os << (internal::type_equals<Result, void>::value ?\n              \"returning directly.\\n\" :\n              \"returning default value.\\n\");\n    } else {\n      *os << \"taking default action specified at:\\n\"\n          << FormatFileLocation(spec->file(), spec->line()) << \"\\n\";\n    }\n  }\n\n  // Writes a message that the call is uninteresting (i.e. neither\n  // explicitly expected nor explicitly unexpected) to the given\n  // ostream.\n  virtual void UntypedDescribeUninterestingCall(\n      const void* untyped_args,\n      ::std::ostream* os) const\n          GTEST_LOCK_EXCLUDED_(g_gmock_mutex) {\n    const ArgumentTuple& args =\n        *static_cast<const ArgumentTuple*>(untyped_args);\n    *os << \"Uninteresting mock function call - \";\n    DescribeDefaultActionTo(args, os);\n    *os << \"    Function call: \" << Name();\n    UniversalPrint(args, os);\n  }\n\n  // Returns the expectation that matches the given function arguments\n  // (or NULL is there's no match); when a match is found,\n  // untyped_action is set to point to the action that should be\n  // performed (or NULL if the action is \"do default\"), and\n  // is_excessive is modified to indicate whether the call exceeds the\n  // expected number.\n  //\n  // Critical section: We must find the matching expectation and the\n  // corresponding action that needs to be taken in an ATOMIC\n  // transaction.  Otherwise another thread may call this mock\n  // method in the middle and mess up the state.\n  //\n  // However, performing the action has to be left out of the critical\n  // section.  The reason is that we have no control on what the\n  // action does (it can invoke an arbitrary user function or even a\n  // mock function) and excessive locking could cause a dead lock.\n  virtual const ExpectationBase* UntypedFindMatchingExpectation(\n      const void* untyped_args,\n      const void** untyped_action, bool* is_excessive,\n      ::std::ostream* what, ::std::ostream* why)\n          GTEST_LOCK_EXCLUDED_(g_gmock_mutex) {\n    const ArgumentTuple& args =\n        *static_cast<const ArgumentTuple*>(untyped_args);\n    MutexLock l(&g_gmock_mutex);\n    TypedExpectation<F>* exp = this->FindMatchingExpectationLocked(args);\n    if (exp == NULL) {  // A match wasn't found.\n      this->FormatUnexpectedCallMessageLocked(args, what, why);\n      return NULL;\n    }\n\n    // This line must be done before calling GetActionForArguments(),\n    // which will increment the call count for *exp and thus affect\n    // its saturation status.\n    *is_excessive = exp->IsSaturated();\n    const Action<F>* action = exp->GetActionForArguments(this, args, what, why);\n    if (action != NULL && action->IsDoDefault())\n      action = NULL;  // Normalize \"do default\" to NULL.\n    *untyped_action = action;\n    return exp;\n  }\n\n  // Prints the given function arguments to the ostream.\n  virtual void UntypedPrintArgs(const void* untyped_args,\n                                ::std::ostream* os) const {\n    const ArgumentTuple& args =\n        *static_cast<const ArgumentTuple*>(untyped_args);\n    UniversalPrint(args, os);\n  }\n\n  // Returns the expectation that matches the arguments, or NULL if no\n  // expectation matches them.\n  TypedExpectation<F>* FindMatchingExpectationLocked(\n      const ArgumentTuple& args) const\n          GTEST_EXCLUSIVE_LOCK_REQUIRED_(g_gmock_mutex) {\n    g_gmock_mutex.AssertHeld();\n    for (typename UntypedExpectations::const_reverse_iterator it =\n             untyped_expectations_.rbegin();\n         it != untyped_expectations_.rend(); ++it) {\n      TypedExpectation<F>* const exp =\n          static_cast<TypedExpectation<F>*>(it->get());\n      if (exp->ShouldHandleArguments(args)) {\n        return exp;\n      }\n    }\n    return NULL;\n  }\n\n  // Returns a message that the arguments don't match any expectation.\n  void FormatUnexpectedCallMessageLocked(\n      const ArgumentTuple& args,\n      ::std::ostream* os,\n      ::std::ostream* why) const\n          GTEST_EXCLUSIVE_LOCK_REQUIRED_(g_gmock_mutex) {\n    g_gmock_mutex.AssertHeld();\n    *os << \"\\nUnexpected mock function call - \";\n    DescribeDefaultActionTo(args, os);\n    PrintTriedExpectationsLocked(args, why);\n  }\n\n  // Prints a list of expectations that have been tried against the\n  // current mock function call.\n  void PrintTriedExpectationsLocked(\n      const ArgumentTuple& args,\n      ::std::ostream* why) const\n          GTEST_EXCLUSIVE_LOCK_REQUIRED_(g_gmock_mutex) {\n    g_gmock_mutex.AssertHeld();\n    const int count = static_cast<int>(untyped_expectations_.size());\n    *why << \"Google Mock tried the following \" << count << \" \"\n         << (count == 1 ? \"expectation, but it didn't match\" :\n             \"expectations, but none matched\")\n         << \":\\n\";\n    for (int i = 0; i < count; i++) {\n      TypedExpectation<F>* const expectation =\n          static_cast<TypedExpectation<F>*>(untyped_expectations_[i].get());\n      *why << \"\\n\";\n      expectation->DescribeLocationTo(why);\n      if (count > 1) {\n        *why << \"tried expectation #\" << i << \": \";\n      }\n      *why << expectation->source_text() << \"...\\n\";\n      expectation->ExplainMatchResultTo(args, why);\n      expectation->DescribeCallCountTo(why);\n    }\n  }\n\n  // The current spec (either default action spec or expectation spec)\n  // being described on this function mocker.\n  MockSpec<F> current_spec_;\n\n  // There is no generally useful and implementable semantics of\n  // copying a mock object, so copying a mock is usually a user error.\n  // Thus we disallow copying function mockers.  If the user really\n  // wants to copy a mock object, he should implement his own copy\n  // operation, for example:\n  //\n  //   class MockFoo : public Foo {\n  //    public:\n  //     // Defines a copy constructor explicitly.\n  //     MockFoo(const MockFoo& src) {}\n  //     ...\n  //   };\n  GTEST_DISALLOW_COPY_AND_ASSIGN_(FunctionMockerBase);\n};  // class FunctionMockerBase\n\n#ifdef _MSC_VER\n# pragma warning(pop)  // Restores the warning state.\n#endif  // _MSV_VER\n\n// Implements methods of FunctionMockerBase.\n\n// Verifies that all expectations on this mock function have been\n// satisfied.  Reports one or more Google Test non-fatal failures and\n// returns false if not.\n\n// Reports an uninteresting call (whose description is in msg) in the\n// manner specified by 'reaction'.\nvoid ReportUninterestingCall(CallReaction reaction, const string& msg);\n\n}  // namespace internal\n\n// The style guide prohibits \"using\" statements in a namespace scope\n// inside a header file.  However, the MockSpec class template is\n// meant to be defined in the ::testing namespace.  The following line\n// is just a trick for working around a bug in MSVC 8.0, which cannot\n// handle it if we define MockSpec in ::testing.\nusing internal::MockSpec;\n\n// Const(x) is a convenient function for obtaining a const reference\n// to x.  This is useful for setting expectations on an overloaded\n// const mock method, e.g.\n//\n//   class MockFoo : public FooInterface {\n//    public:\n//     MOCK_METHOD0(Bar, int());\n//     MOCK_CONST_METHOD0(Bar, int&());\n//   };\n//\n//   MockFoo foo;\n//   // Expects a call to non-const MockFoo::Bar().\n//   EXPECT_CALL(foo, Bar());\n//   // Expects a call to const MockFoo::Bar().\n//   EXPECT_CALL(Const(foo), Bar());\ntemplate <typename T>\ninline const T& Const(const T& x) { return x; }\n\n// Constructs an Expectation object that references and co-owns exp.\ninline Expectation::Expectation(internal::ExpectationBase& exp)  // NOLINT\n    : expectation_base_(exp.GetHandle().expectation_base()) {}\n\n}  // namespace testing\n\n// A separate macro is required to avoid compile errors when the name\n// of the method used in call is a result of macro expansion.\n// See CompilesWithMethodNameExpandedFromMacro tests in\n// internal/gmock-spec-builders_test.cc for more details.\n#define GMOCK_ON_CALL_IMPL_(obj, call) \\\n    ((obj).gmock_##call).InternalDefaultActionSetAt(__FILE__, __LINE__, \\\n                                                    #obj, #call)\n#define ON_CALL(obj, call) GMOCK_ON_CALL_IMPL_(obj, call)\n\n#define GMOCK_EXPECT_CALL_IMPL_(obj, call) \\\n    ((obj).gmock_##call).InternalExpectedAt(__FILE__, __LINE__, #obj, #call)\n#define EXPECT_CALL(obj, call) GMOCK_EXPECT_CALL_IMPL_(obj, call)\n\n#endif  // GMOCK_INCLUDE_GMOCK_GMOCK_SPEC_BUILDERS_H_\n"}, "38": {"id": 38, "path": "/home/vsts/work/1/llvm-project/llvm/utils/unittest/googlemock/include/gmock/gmock.h", "content": "// Copyright 2007, Google Inc.\n// All rights reserved.\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are\n// met:\n//\n//     * Redistributions of source code must retain the above copyright\n// notice, this list of conditions and the following disclaimer.\n//     * Redistributions in binary form must reproduce the above\n// copyright notice, this list of conditions and the following disclaimer\n// in the documentation and/or other materials provided with the\n// distribution.\n//     * Neither the name of Google Inc. nor the names of its\n// contributors may be used to endorse or promote products derived from\n// this software without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n//\n// Author: wan@google.com (Zhanyong Wan)\n\n// Google Mock - a framework for writing C++ mock classes.\n//\n// This is the main header file a user should include.\n\n#ifndef GMOCK_INCLUDE_GMOCK_GMOCK_H_\n#define GMOCK_INCLUDE_GMOCK_GMOCK_H_\n\n// This file implements the following syntax:\n//\n//   ON_CALL(mock_object.Method(...))\n//     .With(...) ?\n//     .WillByDefault(...);\n//\n// where With() is optional and WillByDefault() must appear exactly\n// once.\n//\n//   EXPECT_CALL(mock_object.Method(...))\n//     .With(...) ?\n//     .Times(...) ?\n//     .InSequence(...) *\n//     .WillOnce(...) *\n//     .WillRepeatedly(...) ?\n//     .RetiresOnSaturation() ? ;\n//\n// where all clauses are optional and WillOnce() can be repeated.\n\n#include \"gmock/gmock-actions.h\"\n#include \"gmock/gmock-cardinalities.h\"\n#include \"gmock/gmock-generated-actions.h\"\n#include \"gmock/gmock-generated-function-mockers.h\"\n#include \"gmock/gmock-generated-nice-strict.h\"\n#include \"gmock/gmock-generated-matchers.h\"\n#include \"gmock/gmock-matchers.h\"\n#include \"gmock/gmock-more-actions.h\"\n#include \"gmock/gmock-more-matchers.h\"\n#include \"gmock/internal/gmock-internal-utils.h\"\n\nnamespace testing {\n\n// Declares Google Mock flags that we want a user to use programmatically.\nGMOCK_DECLARE_bool_(catch_leaked_mocks);\nGMOCK_DECLARE_string_(verbose);\n\n// Initializes Google Mock.  This must be called before running the\n// tests.  In particular, it parses the command line for the flags\n// that Google Mock recognizes.  Whenever a Google Mock flag is seen,\n// it is removed from argv, and *argc is decremented.\n//\n// No value is returned.  Instead, the Google Mock flag variables are\n// updated.\n//\n// Since Google Test is needed for Google Mock to work, this function\n// also initializes Google Test and parses its flags, if that hasn't\n// been done.\nGTEST_API_ void InitGoogleMock(int* argc, char** argv);\n\n// This overloaded version can be used in Windows programs compiled in\n// UNICODE mode.\nGTEST_API_ void InitGoogleMock(int* argc, wchar_t** argv);\n\n}  // namespace testing\n\n#endif  // GMOCK_INCLUDE_GMOCK_GMOCK_H_\n"}, "39": {"id": 39, "path": "/home/vsts/work/1/llvm-project/llvm/utils/unittest/googlemock/include/gmock/internal/custom/gmock-generated-actions.h", "content": "// This file was GENERATED by command:\n//     pump.py gmock-generated-actions.h.pump\n// DO NOT EDIT BY HAND!!!\n\n#ifndef GMOCK_INCLUDE_GMOCK_INTERNAL_CUSTOM_GMOCK_GENERATED_ACTIONS_H_\n#define GMOCK_INCLUDE_GMOCK_INTERNAL_CUSTOM_GMOCK_GENERATED_ACTIONS_H_\n\n#endif  // GMOCK_INCLUDE_GMOCK_INTERNAL_CUSTOM_GMOCK_GENERATED_ACTIONS_H_\n"}, "40": {"id": 40, "path": "/home/vsts/work/1/llvm-project/llvm/utils/unittest/googlemock/include/gmock/internal/custom/gmock-matchers.h", "content": "// Copyright 2015, Google Inc.\n// All rights reserved.\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are\n// met:\n//\n//     * Redistributions of source code must retain the above copyright\n// notice, this list of conditions and the following disclaimer.\n//     * Redistributions in binary form must reproduce the above\n// copyright notice, this list of conditions and the following disclaimer\n// in the documentation and/or other materials provided with the\n// distribution.\n//     * Neither the name of Google Inc. nor the names of its\n// contributors may be used to endorse or promote products derived from\n// this software without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n//\n// ============================================================\n// An installation-specific extension point for gmock-matchers.h.\n// ============================================================\n//\n// Adds google3 callback support to CallableTraits.\n//\n#ifndef GMOCK_INCLUDE_GMOCK_INTERNAL_CUSTOM_CALLBACK_MATCHERS_H_\n#define GMOCK_INCLUDE_GMOCK_INTERNAL_CUSTOM_CALLBACK_MATCHERS_H_\n\n#endif  //  GMOCK_INCLUDE_GMOCK_INTERNAL_CUSTOM_CALLBACK_MATCHERS_H_\n"}, "41": {"id": 41, "path": "/home/vsts/work/1/llvm-project/llvm/utils/unittest/googlemock/include/gmock/internal/custom/gmock-port.h", "content": "// Copyright 2015, Google Inc.\n// All rights reserved.\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are\n// met:\n//\n//     * Redistributions of source code must retain the above copyright\n// notice, this list of conditions and the following disclaimer.\n//     * Redistributions in binary form must reproduce the above\n// copyright notice, this list of conditions and the following disclaimer\n// in the documentation and/or other materials provided with the\n// distribution.\n//     * Neither the name of Google Inc. nor the names of its\n// contributors may be used to endorse or promote products derived from\n// this software without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n//\n// Injection point for custom user configurations.\n// The following macros can be defined:\n//\n//   Flag related macros:\n//     GMOCK_DECLARE_bool_(name)\n//     GMOCK_DECLARE_int32_(name)\n//     GMOCK_DECLARE_string_(name)\n//     GMOCK_DEFINE_bool_(name, default_val, doc)\n//     GMOCK_DEFINE_int32_(name, default_val, doc)\n//     GMOCK_DEFINE_string_(name, default_val, doc)\n//\n// ** Custom implementation starts here **\n\n#ifndef GMOCK_INCLUDE_GMOCK_INTERNAL_CUSTOM_GMOCK_PORT_H_\n#define GMOCK_INCLUDE_GMOCK_INTERNAL_CUSTOM_GMOCK_PORT_H_\n\n#endif  // GMOCK_INCLUDE_GMOCK_INTERNAL_CUSTOM_GMOCK_PORT_H_\n"}, "42": {"id": 42, "path": "/home/vsts/work/1/llvm-project/llvm/utils/unittest/googlemock/include/gmock/internal/gmock-generated-internal-utils.h", "content": "// This file was GENERATED by command:\n//     pump.py gmock-generated-internal-utils.h.pump\n// DO NOT EDIT BY HAND!!!\n\n// Copyright 2007, Google Inc.\n// All rights reserved.\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are\n// met:\n//\n//     * Redistributions of source code must retain the above copyright\n// notice, this list of conditions and the following disclaimer.\n//     * Redistributions in binary form must reproduce the above\n// copyright notice, this list of conditions and the following disclaimer\n// in the documentation and/or other materials provided with the\n// distribution.\n//     * Neither the name of Google Inc. nor the names of its\n// contributors may be used to endorse or promote products derived from\n// this software without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n//\n// Author: wan@google.com (Zhanyong Wan)\n\n// Google Mock - a framework for writing C++ mock classes.\n//\n// This file contains template meta-programming utility classes needed\n// for implementing Google Mock.\n\n// IWYU pragma: private, include \"gmock/gmock.h\"\n\n#ifndef GMOCK_INCLUDE_GMOCK_INTERNAL_GMOCK_GENERATED_INTERNAL_UTILS_H_\n#define GMOCK_INCLUDE_GMOCK_INTERNAL_GMOCK_GENERATED_INTERNAL_UTILS_H_\n\n#include \"gmock/internal/gmock-port.h\"\n\nnamespace testing {\n\ntemplate <typename T>\nclass Matcher;\n\nnamespace internal {\n\n// An IgnoredValue object can be implicitly constructed from ANY value.\n// This is used in implementing the IgnoreResult(a) action.\nclass IgnoredValue {\n public:\n  // This constructor template allows any value to be implicitly\n  // converted to IgnoredValue.  The object has no data member and\n  // doesn't try to remember anything about the argument.  We\n  // deliberately omit the 'explicit' keyword in order to allow the\n  // conversion to be implicit.\n  template <typename T>\n  IgnoredValue(const T& /* ignored */) {}  // NOLINT(runtime/explicit)\n};\n\n// MatcherTuple<T>::type is a tuple type where each field is a Matcher\n// for the corresponding field in tuple type T.\ntemplate <typename Tuple>\nstruct MatcherTuple;\n\ntemplate <>\nstruct MatcherTuple< ::testing::tuple<> > {\n  typedef ::testing::tuple< > type;\n};\n\ntemplate <typename A1>\nstruct MatcherTuple< ::testing::tuple<A1> > {\n  typedef ::testing::tuple<Matcher<A1> > type;\n};\n\ntemplate <typename A1, typename A2>\nstruct MatcherTuple< ::testing::tuple<A1, A2> > {\n  typedef ::testing::tuple<Matcher<A1>, Matcher<A2> > type;\n};\n\ntemplate <typename A1, typename A2, typename A3>\nstruct MatcherTuple< ::testing::tuple<A1, A2, A3> > {\n  typedef ::testing::tuple<Matcher<A1>, Matcher<A2>, Matcher<A3> > type;\n};\n\ntemplate <typename A1, typename A2, typename A3, typename A4>\nstruct MatcherTuple< ::testing::tuple<A1, A2, A3, A4> > {\n  typedef ::testing::tuple<Matcher<A1>, Matcher<A2>, Matcher<A3>,\n      Matcher<A4> > type;\n};\n\ntemplate <typename A1, typename A2, typename A3, typename A4, typename A5>\nstruct MatcherTuple< ::testing::tuple<A1, A2, A3, A4, A5> > {\n  typedef ::testing::tuple<Matcher<A1>, Matcher<A2>, Matcher<A3>, Matcher<A4>,\n      Matcher<A5> > type;\n};\n\ntemplate <typename A1, typename A2, typename A3, typename A4, typename A5,\n    typename A6>\nstruct MatcherTuple< ::testing::tuple<A1, A2, A3, A4, A5, A6> > {\n  typedef ::testing::tuple<Matcher<A1>, Matcher<A2>, Matcher<A3>, Matcher<A4>,\n      Matcher<A5>, Matcher<A6> > type;\n};\n\ntemplate <typename A1, typename A2, typename A3, typename A4, typename A5,\n    typename A6, typename A7>\nstruct MatcherTuple< ::testing::tuple<A1, A2, A3, A4, A5, A6, A7> > {\n  typedef ::testing::tuple<Matcher<A1>, Matcher<A2>, Matcher<A3>, Matcher<A4>,\n      Matcher<A5>, Matcher<A6>, Matcher<A7> > type;\n};\n\ntemplate <typename A1, typename A2, typename A3, typename A4, typename A5,\n    typename A6, typename A7, typename A8>\nstruct MatcherTuple< ::testing::tuple<A1, A2, A3, A4, A5, A6, A7, A8> > {\n  typedef ::testing::tuple<Matcher<A1>, Matcher<A2>, Matcher<A3>, Matcher<A4>,\n      Matcher<A5>, Matcher<A6>, Matcher<A7>, Matcher<A8> > type;\n};\n\ntemplate <typename A1, typename A2, typename A3, typename A4, typename A5,\n    typename A6, typename A7, typename A8, typename A9>\nstruct MatcherTuple< ::testing::tuple<A1, A2, A3, A4, A5, A6, A7, A8, A9> > {\n  typedef ::testing::tuple<Matcher<A1>, Matcher<A2>, Matcher<A3>, Matcher<A4>,\n      Matcher<A5>, Matcher<A6>, Matcher<A7>, Matcher<A8>, Matcher<A9> > type;\n};\n\ntemplate <typename A1, typename A2, typename A3, typename A4, typename A5,\n    typename A6, typename A7, typename A8, typename A9, typename A10>\nstruct MatcherTuple< ::testing::tuple<A1, A2, A3, A4, A5, A6, A7, A8, A9,\n    A10> > {\n  typedef ::testing::tuple<Matcher<A1>, Matcher<A2>, Matcher<A3>, Matcher<A4>,\n      Matcher<A5>, Matcher<A6>, Matcher<A7>, Matcher<A8>, Matcher<A9>,\n      Matcher<A10> > type;\n};\n\n// Template struct Function<F>, where F must be a function type, contains\n// the following typedefs:\n//\n//   Result:               the function's return type.\n//   ArgumentN:            the type of the N-th argument, where N starts with 1.\n//   ArgumentTuple:        the tuple type consisting of all parameters of F.\n//   ArgumentMatcherTuple: the tuple type consisting of Matchers for all\n//                         parameters of F.\n//   MakeResultVoid:       the function type obtained by substituting void\n//                         for the return type of F.\n//   MakeResultIgnoredValue:\n//                         the function type obtained by substituting Something\n//                         for the return type of F.\ntemplate <typename F>\nstruct Function;\n\ntemplate <typename R>\nstruct Function<R()> {\n  typedef R Result;\n  typedef ::testing::tuple<> ArgumentTuple;\n  typedef typename MatcherTuple<ArgumentTuple>::type ArgumentMatcherTuple;\n  typedef void MakeResultVoid();\n  typedef IgnoredValue MakeResultIgnoredValue();\n};\n\ntemplate <typename R, typename A1>\nstruct Function<R(A1)>\n    : Function<R()> {\n  typedef A1 Argument1;\n  typedef ::testing::tuple<A1> ArgumentTuple;\n  typedef typename MatcherTuple<ArgumentTuple>::type ArgumentMatcherTuple;\n  typedef void MakeResultVoid(A1);\n  typedef IgnoredValue MakeResultIgnoredValue(A1);\n};\n\ntemplate <typename R, typename A1, typename A2>\nstruct Function<R(A1, A2)>\n    : Function<R(A1)> {\n  typedef A2 Argument2;\n  typedef ::testing::tuple<A1, A2> ArgumentTuple;\n  typedef typename MatcherTuple<ArgumentTuple>::type ArgumentMatcherTuple;\n  typedef void MakeResultVoid(A1, A2);\n  typedef IgnoredValue MakeResultIgnoredValue(A1, A2);\n};\n\ntemplate <typename R, typename A1, typename A2, typename A3>\nstruct Function<R(A1, A2, A3)>\n    : Function<R(A1, A2)> {\n  typedef A3 Argument3;\n  typedef ::testing::tuple<A1, A2, A3> ArgumentTuple;\n  typedef typename MatcherTuple<ArgumentTuple>::type ArgumentMatcherTuple;\n  typedef void MakeResultVoid(A1, A2, A3);\n  typedef IgnoredValue MakeResultIgnoredValue(A1, A2, A3);\n};\n\ntemplate <typename R, typename A1, typename A2, typename A3, typename A4>\nstruct Function<R(A1, A2, A3, A4)>\n    : Function<R(A1, A2, A3)> {\n  typedef A4 Argument4;\n  typedef ::testing::tuple<A1, A2, A3, A4> ArgumentTuple;\n  typedef typename MatcherTuple<ArgumentTuple>::type ArgumentMatcherTuple;\n  typedef void MakeResultVoid(A1, A2, A3, A4);\n  typedef IgnoredValue MakeResultIgnoredValue(A1, A2, A3, A4);\n};\n\ntemplate <typename R, typename A1, typename A2, typename A3, typename A4,\n    typename A5>\nstruct Function<R(A1, A2, A3, A4, A5)>\n    : Function<R(A1, A2, A3, A4)> {\n  typedef A5 Argument5;\n  typedef ::testing::tuple<A1, A2, A3, A4, A5> ArgumentTuple;\n  typedef typename MatcherTuple<ArgumentTuple>::type ArgumentMatcherTuple;\n  typedef void MakeResultVoid(A1, A2, A3, A4, A5);\n  typedef IgnoredValue MakeResultIgnoredValue(A1, A2, A3, A4, A5);\n};\n\ntemplate <typename R, typename A1, typename A2, typename A3, typename A4,\n    typename A5, typename A6>\nstruct Function<R(A1, A2, A3, A4, A5, A6)>\n    : Function<R(A1, A2, A3, A4, A5)> {\n  typedef A6 Argument6;\n  typedef ::testing::tuple<A1, A2, A3, A4, A5, A6> ArgumentTuple;\n  typedef typename MatcherTuple<ArgumentTuple>::type ArgumentMatcherTuple;\n  typedef void MakeResultVoid(A1, A2, A3, A4, A5, A6);\n  typedef IgnoredValue MakeResultIgnoredValue(A1, A2, A3, A4, A5, A6);\n};\n\ntemplate <typename R, typename A1, typename A2, typename A3, typename A4,\n    typename A5, typename A6, typename A7>\nstruct Function<R(A1, A2, A3, A4, A5, A6, A7)>\n    : Function<R(A1, A2, A3, A4, A5, A6)> {\n  typedef A7 Argument7;\n  typedef ::testing::tuple<A1, A2, A3, A4, A5, A6, A7> ArgumentTuple;\n  typedef typename MatcherTuple<ArgumentTuple>::type ArgumentMatcherTuple;\n  typedef void MakeResultVoid(A1, A2, A3, A4, A5, A6, A7);\n  typedef IgnoredValue MakeResultIgnoredValue(A1, A2, A3, A4, A5, A6, A7);\n};\n\ntemplate <typename R, typename A1, typename A2, typename A3, typename A4,\n    typename A5, typename A6, typename A7, typename A8>\nstruct Function<R(A1, A2, A3, A4, A5, A6, A7, A8)>\n    : Function<R(A1, A2, A3, A4, A5, A6, A7)> {\n  typedef A8 Argument8;\n  typedef ::testing::tuple<A1, A2, A3, A4, A5, A6, A7, A8> ArgumentTuple;\n  typedef typename MatcherTuple<ArgumentTuple>::type ArgumentMatcherTuple;\n  typedef void MakeResultVoid(A1, A2, A3, A4, A5, A6, A7, A8);\n  typedef IgnoredValue MakeResultIgnoredValue(A1, A2, A3, A4, A5, A6, A7, A8);\n};\n\ntemplate <typename R, typename A1, typename A2, typename A3, typename A4,\n    typename A5, typename A6, typename A7, typename A8, typename A9>\nstruct Function<R(A1, A2, A3, A4, A5, A6, A7, A8, A9)>\n    : Function<R(A1, A2, A3, A4, A5, A6, A7, A8)> {\n  typedef A9 Argument9;\n  typedef ::testing::tuple<A1, A2, A3, A4, A5, A6, A7, A8, A9> ArgumentTuple;\n  typedef typename MatcherTuple<ArgumentTuple>::type ArgumentMatcherTuple;\n  typedef void MakeResultVoid(A1, A2, A3, A4, A5, A6, A7, A8, A9);\n  typedef IgnoredValue MakeResultIgnoredValue(A1, A2, A3, A4, A5, A6, A7, A8,\n      A9);\n};\n\ntemplate <typename R, typename A1, typename A2, typename A3, typename A4,\n    typename A5, typename A6, typename A7, typename A8, typename A9,\n    typename A10>\nstruct Function<R(A1, A2, A3, A4, A5, A6, A7, A8, A9, A10)>\n    : Function<R(A1, A2, A3, A4, A5, A6, A7, A8, A9)> {\n  typedef A10 Argument10;\n  typedef ::testing::tuple<A1, A2, A3, A4, A5, A6, A7, A8, A9,\n      A10> ArgumentTuple;\n  typedef typename MatcherTuple<ArgumentTuple>::type ArgumentMatcherTuple;\n  typedef void MakeResultVoid(A1, A2, A3, A4, A5, A6, A7, A8, A9, A10);\n  typedef IgnoredValue MakeResultIgnoredValue(A1, A2, A3, A4, A5, A6, A7, A8,\n      A9, A10);\n};\n\n}  // namespace internal\n\n}  // namespace testing\n\n#endif  // GMOCK_INCLUDE_GMOCK_INTERNAL_GMOCK_GENERATED_INTERNAL_UTILS_H_\n"}, "43": {"id": 43, "path": "/home/vsts/work/1/llvm-project/llvm/utils/unittest/googlemock/include/gmock/internal/gmock-internal-utils.h", "content": "// Copyright 2007, Google Inc.\n// All rights reserved.\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are\n// met:\n//\n//     * Redistributions of source code must retain the above copyright\n// notice, this list of conditions and the following disclaimer.\n//     * Redistributions in binary form must reproduce the above\n// copyright notice, this list of conditions and the following disclaimer\n// in the documentation and/or other materials provided with the\n// distribution.\n//     * Neither the name of Google Inc. nor the names of its\n// contributors may be used to endorse or promote products derived from\n// this software without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n//\n// Author: wan@google.com (Zhanyong Wan)\n\n// Google Mock - a framework for writing C++ mock classes.\n//\n// This file defines some utilities useful for implementing Google\n// Mock.  They are subject to change without notice, so please DO NOT\n// USE THEM IN USER CODE.\n\n// IWYU pragma: private, include \"gmock/gmock.h\"\n\n#ifndef GMOCK_INCLUDE_GMOCK_INTERNAL_GMOCK_INTERNAL_UTILS_H_\n#define GMOCK_INCLUDE_GMOCK_INTERNAL_GMOCK_INTERNAL_UTILS_H_\n\n#include <stdio.h>\n#include <ostream>  // NOLINT\n#include <string>\n\n#include \"gmock/internal/gmock-generated-internal-utils.h\"\n#include \"gmock/internal/gmock-port.h\"\n#include \"gtest/gtest.h\"\n\nnamespace testing {\nnamespace internal {\n\n// Converts an identifier name to a space-separated list of lower-case\n// words.  Each maximum substring of the form [A-Za-z][a-z]*|\\d+ is\n// treated as one word.  For example, both \"FooBar123\" and\n// \"foo_bar_123\" are converted to \"foo bar 123\".\nGTEST_API_ string ConvertIdentifierNameToWords(const char* id_name);\n\n// PointeeOf<Pointer>::type is the type of a value pointed to by a\n// Pointer, which can be either a smart pointer or a raw pointer.  The\n// following default implementation is for the case where Pointer is a\n// smart pointer.\ntemplate <typename Pointer>\nstruct PointeeOf {\n  // Smart pointer classes define type element_type as the type of\n  // their pointees.\n  typedef typename Pointer::element_type type;\n};\n// This specialization is for the raw pointer case.\ntemplate <typename T>\nstruct PointeeOf<T*> { typedef T type; };  // NOLINT\n\n// GetRawPointer(p) returns the raw pointer underlying p when p is a\n// smart pointer, or returns p itself when p is already a raw pointer.\n// The following default implementation is for the smart pointer case.\ntemplate <typename Pointer>\ninline const typename Pointer::element_type* GetRawPointer(const Pointer& p) {\n  return p.get();\n}\n// This overloaded version is for the raw pointer case.\ntemplate <typename Element>\ninline Element* GetRawPointer(Element* p) { return p; }\n\n// This comparator allows linked_ptr to be stored in sets.\ntemplate <typename T>\nstruct LinkedPtrLessThan {\n  bool operator()(const ::testing::internal::linked_ptr<T>& lhs,\n                  const ::testing::internal::linked_ptr<T>& rhs) const {\n    return lhs.get() < rhs.get();\n  }\n};\n\n// Symbian compilation can be done with wchar_t being either a native\n// type or a typedef.  Using Google Mock with OpenC without wchar_t\n// should require the definition of _STLP_NO_WCHAR_T.\n//\n// MSVC treats wchar_t as a native type usually, but treats it as the\n// same as unsigned short when the compiler option /Zc:wchar_t- is\n// specified.  It defines _NATIVE_WCHAR_T_DEFINED symbol when wchar_t\n// is a native type.\n#if (GTEST_OS_SYMBIAN && defined(_STLP_NO_WCHAR_T)) || \\\n    (defined(_MSC_VER) && !defined(_NATIVE_WCHAR_T_DEFINED))\n// wchar_t is a typedef.\n#else\n# define GMOCK_WCHAR_T_IS_NATIVE_ 1\n#endif\n\n// signed wchar_t and unsigned wchar_t are NOT in the C++ standard.\n// Using them is a bad practice and not portable.  So DON'T use them.\n//\n// Still, Google Mock is designed to work even if the user uses signed\n// wchar_t or unsigned wchar_t (obviously, assuming the compiler\n// supports them).\n//\n// To gcc,\n//   wchar_t == signed wchar_t != unsigned wchar_t == unsigned int\n#ifdef __GNUC__\n// signed/unsigned wchar_t are valid types.\n# define GMOCK_HAS_SIGNED_WCHAR_T_ 1\n#endif\n\n// In what follows, we use the term \"kind\" to indicate whether a type\n// is bool, an integer type (excluding bool), a floating-point type,\n// or none of them.  This categorization is useful for determining\n// when a matcher argument type can be safely converted to another\n// type in the implementation of SafeMatcherCast.\nenum TypeKind {\n  kBool, kInteger, kFloatingPoint, kOther\n};\n\n// KindOf<T>::value is the kind of type T.\ntemplate <typename T> struct KindOf {\n  enum { value = kOther };  // The default kind.\n};\n\n// This macro declares that the kind of 'type' is 'kind'.\n#define GMOCK_DECLARE_KIND_(type, kind) \\\n  template <> struct KindOf<type> { enum { value = kind }; }\n\nGMOCK_DECLARE_KIND_(bool, kBool);\n\n// All standard integer types.\nGMOCK_DECLARE_KIND_(char, kInteger);\nGMOCK_DECLARE_KIND_(signed char, kInteger);\nGMOCK_DECLARE_KIND_(unsigned char, kInteger);\nGMOCK_DECLARE_KIND_(short, kInteger);  // NOLINT\nGMOCK_DECLARE_KIND_(unsigned short, kInteger);  // NOLINT\nGMOCK_DECLARE_KIND_(int, kInteger);\nGMOCK_DECLARE_KIND_(unsigned int, kInteger);\nGMOCK_DECLARE_KIND_(long, kInteger);  // NOLINT\nGMOCK_DECLARE_KIND_(unsigned long, kInteger);  // NOLINT\n\n#if GMOCK_WCHAR_T_IS_NATIVE_\nGMOCK_DECLARE_KIND_(wchar_t, kInteger);\n#endif\n\n// Non-standard integer types.\nGMOCK_DECLARE_KIND_(Int64, kInteger);\nGMOCK_DECLARE_KIND_(UInt64, kInteger);\n\n// All standard floating-point types.\nGMOCK_DECLARE_KIND_(float, kFloatingPoint);\nGMOCK_DECLARE_KIND_(double, kFloatingPoint);\nGMOCK_DECLARE_KIND_(long double, kFloatingPoint);\n\n#undef GMOCK_DECLARE_KIND_\n\n// Evaluates to the kind of 'type'.\n#define GMOCK_KIND_OF_(type) \\\n  static_cast< ::testing::internal::TypeKind>( \\\n      ::testing::internal::KindOf<type>::value)\n\n// Evaluates to true iff integer type T is signed.\n#define GMOCK_IS_SIGNED_(T) (static_cast<T>(-1) < 0)\n\n// LosslessArithmeticConvertibleImpl<kFromKind, From, kToKind, To>::value\n// is true iff arithmetic type From can be losslessly converted to\n// arithmetic type To.\n//\n// It's the user's responsibility to ensure that both From and To are\n// raw (i.e. has no CV modifier, is not a pointer, and is not a\n// reference) built-in arithmetic types, kFromKind is the kind of\n// From, and kToKind is the kind of To; the value is\n// implementation-defined when the above pre-condition is violated.\ntemplate <TypeKind kFromKind, typename From, TypeKind kToKind, typename To>\nstruct LosslessArithmeticConvertibleImpl : public false_type {};\n\n// Converting bool to bool is lossless.\ntemplate <>\nstruct LosslessArithmeticConvertibleImpl<kBool, bool, kBool, bool>\n    : public true_type {};  // NOLINT\n\n// Converting bool to any integer type is lossless.\ntemplate <typename To>\nstruct LosslessArithmeticConvertibleImpl<kBool, bool, kInteger, To>\n    : public true_type {};  // NOLINT\n\n// Converting bool to any floating-point type is lossless.\ntemplate <typename To>\nstruct LosslessArithmeticConvertibleImpl<kBool, bool, kFloatingPoint, To>\n    : public true_type {};  // NOLINT\n\n// Converting an integer to bool is lossy.\ntemplate <typename From>\nstruct LosslessArithmeticConvertibleImpl<kInteger, From, kBool, bool>\n    : public false_type {};  // NOLINT\n\n// Converting an integer to another non-bool integer is lossless iff\n// the target type's range encloses the source type's range.\ntemplate <typename From, typename To>\nstruct LosslessArithmeticConvertibleImpl<kInteger, From, kInteger, To>\n    : public bool_constant<\n      // When converting from a smaller size to a larger size, we are\n      // fine as long as we are not converting from signed to unsigned.\n      ((sizeof(From) < sizeof(To)) &&\n       (!GMOCK_IS_SIGNED_(From) || GMOCK_IS_SIGNED_(To))) ||\n      // When converting between the same size, the signedness must match.\n      ((sizeof(From) == sizeof(To)) &&\n       (GMOCK_IS_SIGNED_(From) == GMOCK_IS_SIGNED_(To)))> {};  // NOLINT\n\n#undef GMOCK_IS_SIGNED_\n\n// Converting an integer to a floating-point type may be lossy, since\n// the format of a floating-point number is implementation-defined.\ntemplate <typename From, typename To>\nstruct LosslessArithmeticConvertibleImpl<kInteger, From, kFloatingPoint, To>\n    : public false_type {};  // NOLINT\n\n// Converting a floating-point to bool is lossy.\ntemplate <typename From>\nstruct LosslessArithmeticConvertibleImpl<kFloatingPoint, From, kBool, bool>\n    : public false_type {};  // NOLINT\n\n// Converting a floating-point to an integer is lossy.\ntemplate <typename From, typename To>\nstruct LosslessArithmeticConvertibleImpl<kFloatingPoint, From, kInteger, To>\n    : public false_type {};  // NOLINT\n\n// Converting a floating-point to another floating-point is lossless\n// iff the target type is at least as big as the source type.\ntemplate <typename From, typename To>\nstruct LosslessArithmeticConvertibleImpl<\n  kFloatingPoint, From, kFloatingPoint, To>\n    : public bool_constant<sizeof(From) <= sizeof(To)> {};  // NOLINT\n\n// LosslessArithmeticConvertible<From, To>::value is true iff arithmetic\n// type From can be losslessly converted to arithmetic type To.\n//\n// It's the user's responsibility to ensure that both From and To are\n// raw (i.e. has no CV modifier, is not a pointer, and is not a\n// reference) built-in arithmetic types; the value is\n// implementation-defined when the above pre-condition is violated.\ntemplate <typename From, typename To>\nstruct LosslessArithmeticConvertible\n    : public LosslessArithmeticConvertibleImpl<\n  GMOCK_KIND_OF_(From), From, GMOCK_KIND_OF_(To), To> {};  // NOLINT\n\n// This interface knows how to report a Google Mock failure (either\n// non-fatal or fatal).\nclass FailureReporterInterface {\n public:\n  // The type of a failure (either non-fatal or fatal).\n  enum FailureType {\n    kNonfatal, kFatal\n  };\n\n  virtual ~FailureReporterInterface() {}\n\n  // Reports a failure that occurred at the given source file location.\n  virtual void ReportFailure(FailureType type, const char* file, int line,\n                             const string& message) = 0;\n};\n\n// Returns the failure reporter used by Google Mock.\nGTEST_API_ FailureReporterInterface* GetFailureReporter();\n\n// Asserts that condition is true; aborts the process with the given\n// message if condition is false.  We cannot use LOG(FATAL) or CHECK()\n// as Google Mock might be used to mock the log sink itself.  We\n// inline this function to prevent it from showing up in the stack\n// trace.\ninline void Assert(bool condition, const char* file, int line,\n                   const string& msg) {\n  if (!condition) {\n    GetFailureReporter()->ReportFailure(FailureReporterInterface::kFatal,\n                                        file, line, msg);\n  }\n}\ninline void Assert(bool condition, const char* file, int line) {\n  Assert(condition, file, line, \"Assertion failed.\");\n}\n\n// Verifies that condition is true; generates a non-fatal failure if\n// condition is false.\ninline void Expect(bool condition, const char* file, int line,\n                   const string& msg) {\n  if (!condition) {\n    GetFailureReporter()->ReportFailure(FailureReporterInterface::kNonfatal,\n                                        file, line, msg);\n  }\n}\ninline void Expect(bool condition, const char* file, int line) {\n  Expect(condition, file, line, \"Expectation failed.\");\n}\n\n// Severity level of a log.\nenum LogSeverity {\n  kInfo = 0,\n  kWarning = 1\n};\n\n// Valid values for the --gmock_verbose flag.\n\n// All logs (informational and warnings) are printed.\nconst char kInfoVerbosity[] = \"info\";\n// Only warnings are printed.\nconst char kWarningVerbosity[] = \"warning\";\n// No logs are printed.\nconst char kErrorVerbosity[] = \"error\";\n\n// Returns true iff a log with the given severity is visible according\n// to the --gmock_verbose flag.\nGTEST_API_ bool LogIsVisible(LogSeverity severity);\n\n// Prints the given message to stdout iff 'severity' >= the level\n// specified by the --gmock_verbose flag.  If stack_frames_to_skip >=\n// 0, also prints the stack trace excluding the top\n// stack_frames_to_skip frames.  In opt mode, any positive\n// stack_frames_to_skip is treated as 0, since we don't know which\n// function calls will be inlined by the compiler and need to be\n// conservative.\nGTEST_API_ void Log(LogSeverity severity,\n                    const string& message,\n                    int stack_frames_to_skip);\n\n// TODO(wan@google.com): group all type utilities together.\n\n// Type traits.\n\n// is_reference<T>::value is non-zero iff T is a reference type.\ntemplate <typename T> struct is_reference : public false_type {};\ntemplate <typename T> struct is_reference<T&> : public true_type {};\n\n// type_equals<T1, T2>::value is non-zero iff T1 and T2 are the same type.\ntemplate <typename T1, typename T2> struct type_equals : public false_type {};\ntemplate <typename T> struct type_equals<T, T> : public true_type {};\n\n// remove_reference<T>::type removes the reference from type T, if any.\ntemplate <typename T> struct remove_reference { typedef T type; };  // NOLINT\ntemplate <typename T> struct remove_reference<T&> { typedef T type; }; // NOLINT\n\n// DecayArray<T>::type turns an array type U[N] to const U* and preserves\n// other types.  Useful for saving a copy of a function argument.\ntemplate <typename T> struct DecayArray { typedef T type; };  // NOLINT\ntemplate <typename T, size_t N> struct DecayArray<T[N]> {\n  typedef const T* type;\n};\n// Sometimes people use arrays whose size is not available at the use site\n// (e.g. extern const char kNamePrefix[]).  This specialization covers that\n// case.\ntemplate <typename T> struct DecayArray<T[]> {\n  typedef const T* type;\n};\n\n// Disable MSVC warnings for infinite recursion, since in this case the\n// the recursion is unreachable.\n#ifdef _MSC_VER\n# pragma warning(push)\n# pragma warning(disable:4717)\n#endif\n\n// Invalid<T>() is usable as an expression of type T, but will terminate\n// the program with an assertion failure if actually run.  This is useful\n// when a value of type T is needed for compilation, but the statement\n// will not really be executed (or we don't care if the statement\n// crashes).\ntemplate <typename T>\ninline T Invalid() {\n  Assert(false, \"\", -1, \"Internal error: attempt to return invalid value\");\n  // This statement is unreachable, and would never terminate even if it\n  // could be reached. It is provided only to placate compiler warnings\n  // about missing return statements.\n  return Invalid<T>();\n}\n\n#ifdef _MSC_VER\n# pragma warning(pop)\n#endif\n\n// Given a raw type (i.e. having no top-level reference or const\n// modifier) RawContainer that's either an STL-style container or a\n// native array, class StlContainerView<RawContainer> has the\n// following members:\n//\n//   - type is a type that provides an STL-style container view to\n//     (i.e. implements the STL container concept for) RawContainer;\n//   - const_reference is a type that provides a reference to a const\n//     RawContainer;\n//   - ConstReference(raw_container) returns a const reference to an STL-style\n//     container view to raw_container, which is a RawContainer.\n//   - Copy(raw_container) returns an STL-style container view of a\n//     copy of raw_container, which is a RawContainer.\n//\n// This generic version is used when RawContainer itself is already an\n// STL-style container.\ntemplate <class RawContainer>\nclass StlContainerView {\n public:\n  typedef RawContainer type;\n  typedef const type& const_reference;\n\n  static const_reference ConstReference(const RawContainer& container) {\n    // Ensures that RawContainer is not a const type.\n    testing::StaticAssertTypeEq<RawContainer,\n        GTEST_REMOVE_CONST_(RawContainer)>();\n    return container;\n  }\n  static type Copy(const RawContainer& container) { return container; }\n};\n\n// This specialization is used when RawContainer is a native array type.\ntemplate <typename Element, size_t N>\nclass StlContainerView<Element[N]> {\n public:\n  typedef GTEST_REMOVE_CONST_(Element) RawElement;\n  typedef internal::NativeArray<RawElement> type;\n  // NativeArray<T> can represent a native array either by value or by\n  // reference (selected by a constructor argument), so 'const type'\n  // can be used to reference a const native array.  We cannot\n  // 'typedef const type& const_reference' here, as that would mean\n  // ConstReference() has to return a reference to a local variable.\n  typedef const type const_reference;\n\n  static const_reference ConstReference(const Element (&array)[N]) {\n    // Ensures that Element is not a const type.\n    testing::StaticAssertTypeEq<Element, RawElement>();\n#if GTEST_OS_SYMBIAN\n    // The Nokia Symbian compiler confuses itself in template instantiation\n    // for this call without the cast to Element*:\n    // function call '[testing::internal::NativeArray<char *>].NativeArray(\n    //     {lval} const char *[4], long, testing::internal::RelationToSource)'\n    //     does not match\n    // 'testing::internal::NativeArray<char *>::NativeArray(\n    //     char *const *, unsigned int, testing::internal::RelationToSource)'\n    // (instantiating: 'testing::internal::ContainsMatcherImpl\n    //     <const char * (&)[4]>::Matches(const char * (&)[4]) const')\n    // (instantiating: 'testing::internal::StlContainerView<char *[4]>::\n    //     ConstReference(const char * (&)[4])')\n    // (and though the N parameter type is mismatched in the above explicit\n    // conversion of it doesn't help - only the conversion of the array).\n    return type(const_cast<Element*>(&array[0]), N,\n                RelationToSourceReference());\n#else\n    return type(array, N, RelationToSourceReference());\n#endif  // GTEST_OS_SYMBIAN\n  }\n  static type Copy(const Element (&array)[N]) {\n#if GTEST_OS_SYMBIAN\n    return type(const_cast<Element*>(&array[0]), N, RelationToSourceCopy());\n#else\n    return type(array, N, RelationToSourceCopy());\n#endif  // GTEST_OS_SYMBIAN\n  }\n};\n\n// This specialization is used when RawContainer is a native array\n// represented as a (pointer, size) tuple.\ntemplate <typename ElementPointer, typename Size>\nclass StlContainerView< ::testing::tuple<ElementPointer, Size> > {\n public:\n  typedef GTEST_REMOVE_CONST_(\n      typename internal::PointeeOf<ElementPointer>::type) RawElement;\n  typedef internal::NativeArray<RawElement> type;\n  typedef const type const_reference;\n\n  static const_reference ConstReference(\n      const ::testing::tuple<ElementPointer, Size>& array) {\n    return type(get<0>(array), get<1>(array), RelationToSourceReference());\n  }\n  static type Copy(const ::testing::tuple<ElementPointer, Size>& array) {\n    return type(get<0>(array), get<1>(array), RelationToSourceCopy());\n  }\n};\n\n// The following specialization prevents the user from instantiating\n// StlContainer with a reference type.\ntemplate <typename T> class StlContainerView<T&>;\n\n// A type transform to remove constness from the first part of a pair.\n// Pairs like that are used as the value_type of associative containers,\n// and this transform produces a similar but assignable pair.\ntemplate <typename T>\nstruct RemoveConstFromKey {\n  typedef T type;\n};\n\n// Partially specialized to remove constness from std::pair<const K, V>.\ntemplate <typename K, typename V>\nstruct RemoveConstFromKey<std::pair<const K, V> > {\n  typedef std::pair<K, V> type;\n};\n\n// Mapping from booleans to types. Similar to boost::bool_<kValue> and\n// std::integral_constant<bool, kValue>.\ntemplate <bool kValue>\nstruct BooleanConstant {};\n\n}  // namespace internal\n}  // namespace testing\n\n#endif  // GMOCK_INCLUDE_GMOCK_INTERNAL_GMOCK_INTERNAL_UTILS_H_\n\n"}, "44": {"id": 44, "path": "/home/vsts/work/1/llvm-project/llvm/utils/unittest/googlemock/include/gmock/internal/gmock-port.h", "content": "// Copyright 2008, Google Inc.\n// All rights reserved.\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are\n// met:\n//\n//     * Redistributions of source code must retain the above copyright\n// notice, this list of conditions and the following disclaimer.\n//     * Redistributions in binary form must reproduce the above\n// copyright notice, this list of conditions and the following disclaimer\n// in the documentation and/or other materials provided with the\n// distribution.\n//     * Neither the name of Google Inc. nor the names of its\n// contributors may be used to endorse or promote products derived from\n// this software without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n//\n// Author: vadimb@google.com (Vadim Berman)\n//\n// Low-level types and utilities for porting Google Mock to various\n// platforms.  All macros ending with _ and symbols defined in an\n// internal namespace are subject to change without notice.  Code\n// outside Google Mock MUST NOT USE THEM DIRECTLY.  Macros that don't\n// end with _ are part of Google Mock's public API and can be used by\n// code outside Google Mock.\n\n// IWYU pragma: private, include \"gmock/gmock.h\"\n\n#ifndef GMOCK_INCLUDE_GMOCK_INTERNAL_GMOCK_PORT_H_\n#define GMOCK_INCLUDE_GMOCK_INTERNAL_GMOCK_PORT_H_\n\n#include <assert.h>\n#include <stdlib.h>\n#include <iostream>\n\n// Most of the utilities needed for porting Google Mock are also\n// required for Google Test and are defined in gtest-port.h.\n//\n// Note to maintainers: to reduce code duplication, prefer adding\n// portability utilities to Google Test's gtest-port.h instead of\n// here, as Google Mock depends on Google Test.  Only add a utility\n// here if it's truly specific to Google Mock.\n#include \"gtest/internal/gtest-linked_ptr.h\"\n#include \"gtest/internal/gtest-port.h\"\n#include \"gmock/internal/custom/gmock-port.h\"\n\n// To avoid conditional compilation everywhere, we make it\n// gmock-port.h's responsibility to #include the header implementing\n// tr1/tuple.  gmock-port.h does this via gtest-port.h, which is\n// guaranteed to pull in the tuple header.\n\n// For MS Visual C++, check the compiler version. At least VS 2003 is\n// required to compile Google Mock.\n#if defined(_MSC_VER) && _MSC_VER < 1310\n# error \"At least Visual C++ 2003 (7.1) is required to compile Google Mock.\"\n#endif\n\n// Macro for referencing flags.  This is public as we want the user to\n// use this syntax to reference Google Mock flags.\n#define GMOCK_FLAG(name) FLAGS_gmock_##name\n\n#if !defined(GMOCK_DECLARE_bool_)\n\n// Macros for declaring flags.\n#define GMOCK_DECLARE_bool_(name) extern GTEST_API_ bool GMOCK_FLAG(name)\n#define GMOCK_DECLARE_int32_(name) \\\n    extern GTEST_API_ ::testing::internal::Int32 GMOCK_FLAG(name)\n#define GMOCK_DECLARE_string_(name) \\\n    extern GTEST_API_ ::std::string GMOCK_FLAG(name)\n\n// Macros for defining flags.\n#define GMOCK_DEFINE_bool_(name, default_val, doc) \\\n    GTEST_API_ bool GMOCK_FLAG(name) = (default_val)\n#define GMOCK_DEFINE_int32_(name, default_val, doc) \\\n    GTEST_API_ ::testing::internal::Int32 GMOCK_FLAG(name) = (default_val)\n#define GMOCK_DEFINE_string_(name, default_val, doc) \\\n    GTEST_API_ ::std::string GMOCK_FLAG(name) = (default_val)\n\n#endif  // !defined(GMOCK_DECLARE_bool_)\n\n#endif  // GMOCK_INCLUDE_GMOCK_INTERNAL_GMOCK_PORT_H_\n"}}, "reports": [{"events": [{"location": {"col": 9, "file": 2, "line": 9}, "message": "LLVM_CLANG_TOOLS_EXTRA_CLANGD_COLLECTMACROS_H (fixit)"}, {"location": {"col": 9, "file": 2, "line": 9}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/CollectMacros.h", "reportHash": "21ef43118b583d5fa1eacd3d427ed212", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 3, "line": 18}, "message": "LLVM_CLANG_TOOLS_EXTRA_CLANGD_EXPECTEDTYPES_H (fixit)"}, {"location": {"col": 9, "file": 3, "line": 18}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/ExpectedTypes.h", "reportHash": "07b3e66ed4971710af27136439d92dc7", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 4, "line": 9}, "message": "LLVM_CLANG_TOOLS_EXTRA_CLANGD_HEURISTICRESOLVER_H (fixit)"}, {"location": {"col": 9, "file": 4, "line": 9}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/HeuristicResolver.h", "reportHash": "29fddabc8d8a21afe4fe76fe8ca10f4c", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 5, "line": 9}, "message": "LLVM_CLANG_TOOLS_EXTRA_CLANGD_URI_H (fixit)"}, {"location": {"col": 9, "file": 5, "line": 9}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/URI.h", "reportHash": "fd9082cbff4c88e8ae7c6f47d379ce77", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 6, "line": 14}, "message": "LLVM_CLANG_TOOLS_EXTRA_CLANGD_INDEX_BACKGROUNDREBUILD_H (fixit)"}, {"location": {"col": 9, "file": 6, "line": 14}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/index/BackgroundRebuild.h", "reportHash": "c1e794ebbb65d699576f02324de2bc9a", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 2, "file": 7, "line": 95}, "message": "endif // LLVM_CLANG_TOOLS_EXTRA_CLANGD_INDEX_CANONICALINCLUDES_H (fixit)"}, {"location": {"col": 2, "file": 7, "line": 95}, "message": "#endif for a header guard should reference the guard macro in a comment"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/index/CanonicalIncludes.h", "reportHash": "c7483aeb5868f58c5229cb8f8277ecc2", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 8, "line": 24}, "message": "LLVM_CLANG_TOOLS_EXTRA_CLANGD_INDEX_SERIALIZATION_H (fixit)"}, {"location": {"col": 9, "file": 8, "line": 24}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/index/Serialization.h", "reportHash": "501f813469f96b7a178770b09c082287", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 9, "line": 9}, "message": "LLVM_CLANG_TOOLS_EXTRA_CLANGD_INDEX_SYMBOLLOCATION_H (fixit)"}, {"location": {"col": 9, "file": 9, "line": 9}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/index/SymbolLocation.h", "reportHash": "d97d833a1768b13cd883e9b69354ca59", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 10, "line": 9}, "message": "LLVM_CLANG_TOOLS_EXTRA_CLANGD_INDEX_SYMBOLORIGIN_H (fixit)"}, {"location": {"col": 9, "file": 10, "line": 9}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/index/SymbolOrigin.h", "reportHash": "312cca1a410edb20d422f691227bd899", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 11, "line": 19}, "message": "LLVM_CLANG_TOOLS_EXTRA_CLANGD_REFACTOR_TWEAK_H (fixit)"}, {"location": {"col": 9, "file": 11, "line": 19}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/refactor/Tweak.h", "reportHash": "09f040d2738007a5bd9f23313611081d", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 12, "line": 13}, "message": "LLVM_CLANG_TOOLS_EXTRA_CLANGD_UNITTESTS_MATCHERS_H (fixit)"}, {"location": {"col": 9, "file": 12, "line": 13}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/unittests/Matchers.h", "reportHash": "82215334df8639d044984fbb59c32243", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 13, "line": 12}, "message": "LLVM_CLANG_TOOLS_EXTRA_CLANGD_UNITTESTS_TESTFS_H (fixit)"}, {"location": {"col": 9, "file": 13, "line": 12}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/clang-tools-extra/clangd/unittests/TestFS.h", "reportHash": "37bddab0b9dc4513d7b384dbb107fb60", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 29, "line": 38}, "message": "GMOCK_GMOCK_ACTIONS_H (fixit)"}, {"location": {"col": 9, "file": 29, "line": 38}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/utils/unittest/googlemock/include/gmock/gmock-actions.h", "reportHash": "bdf6ab7978c8b2afd1baf6e23e086d91", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 30, "line": 40}, "message": "GMOCK_GMOCK_CARDINALITIES_H (fixit)"}, {"location": {"col": 9, "file": 30, "line": 40}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/utils/unittest/googlemock/include/gmock/gmock-cardinalities.h", "reportHash": "8c950eba6313d34175f6cd5269c91939", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 31, "line": 40}, "message": "GMOCK_GMOCK_GENERATED_ACTIONS_H (fixit)"}, {"location": {"col": 9, "file": 31, "line": 40}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/utils/unittest/googlemock/include/gmock/gmock-generated-actions.h", "reportHash": "1c089cb2222d549136c939f5021afc0a", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 32, "line": 42}, "message": "GMOCK_GMOCK_GENERATED_FUNCTION_MOCKERS_H (fixit)"}, {"location": {"col": 9, "file": 32, "line": 42}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/utils/unittest/googlemock/include/gmock/gmock-generated-function-mockers.h", "reportHash": "d82c2db2facbd0f7652d2c3021196cf8", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 33, "line": 40}, "message": "GMOCK_GMOCK_GENERATED_MATCHERS_H (fixit)"}, {"location": {"col": 9, "file": 33, "line": 40}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/utils/unittest/googlemock/include/gmock/gmock-generated-matchers.h", "reportHash": "d8e7a27d2a5f53b02e4853c130943dfb", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 34, "line": 73}, "message": "GMOCK_GMOCK_GENERATED_NICE_STRICT_H (fixit)"}, {"location": {"col": 9, "file": 34, "line": 73}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/utils/unittest/googlemock/include/gmock/gmock-generated-nice-strict.h", "reportHash": "efa3882ca9a56817c4155599ff84a176", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 35, "line": 40}, "message": "GMOCK_GMOCK_MATCHERS_H (fixit)"}, {"location": {"col": 9, "file": 35, "line": 40}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/utils/unittest/googlemock/include/gmock/gmock-matchers.h", "reportHash": "a45d957dc682b82bf60b035ee7c65661", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 36, "line": 38}, "message": "GMOCK_GMOCK_MORE_ACTIONS_H (fixit)"}, {"location": {"col": 9, "file": 36, "line": 38}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/utils/unittest/googlemock/include/gmock/gmock-more-actions.h", "reportHash": "288740dce5d562a6a2b3530e7af06237", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 37, "line": 62}, "message": "GMOCK_GMOCK_SPEC_BUILDERS_H (fixit)"}, {"location": {"col": 9, "file": 37, "line": 62}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/utils/unittest/googlemock/include/gmock/gmock-spec-builders.h", "reportHash": "62305c8da491a836cb48549df43cff1c", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 38, "line": 36}, "message": "GMOCK_GMOCK_H (fixit)"}, {"location": {"col": 9, "file": 38, "line": 36}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/utils/unittest/googlemock/include/gmock/gmock.h", "reportHash": "4283368660c67bd5c56f7ee89933bb78", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 39, "line": 5}, "message": "GMOCK_INTERNAL_CUSTOM_GMOCK_GENERATED_ACTIONS_H (fixit)"}, {"location": {"col": 9, "file": 39, "line": 5}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/utils/unittest/googlemock/include/gmock/internal/custom/gmock-generated-actions.h", "reportHash": "85fc4c5ce248070140a655e8b6b4df01", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 40, "line": 36}, "message": "GMOCK_INTERNAL_CUSTOM_GMOCK_MATCHERS_H (fixit)"}, {"location": {"col": 9, "file": 40, "line": 36}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/utils/unittest/googlemock/include/gmock/internal/custom/gmock-matchers.h", "reportHash": "66dcd17c5e096de4a3a2ef0b5978d189", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 41, "line": 43}, "message": "GMOCK_INTERNAL_CUSTOM_GMOCK_PORT_H (fixit)"}, {"location": {"col": 9, "file": 41, "line": 43}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/utils/unittest/googlemock/include/gmock/internal/custom/gmock-port.h", "reportHash": "a3d6dd74aad6915740b96e40d11993c6", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 42, "line": 43}, "message": "GMOCK_INTERNAL_GMOCK_GENERATED_INTERNAL_UTILS_H (fixit)"}, {"location": {"col": 9, "file": 42, "line": 43}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/utils/unittest/googlemock/include/gmock/internal/gmock-generated-internal-utils.h", "reportHash": "6b65bc7b971f6c97f77481bbd16307ee", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 43, "line": 40}, "message": "GMOCK_INTERNAL_GMOCK_INTERNAL_UTILS_H (fixit)"}, {"location": {"col": 9, "file": 43, "line": 40}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/utils/unittest/googlemock/include/gmock/internal/gmock-internal-utils.h", "reportHash": "699ce007fb3aa86fdaccc0b5e2d8743b", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}, {"events": [{"location": {"col": 9, "file": 44, "line": 41}, "message": "GMOCK_INTERNAL_GMOCK_PORT_H (fixit)"}, {"location": {"col": 9, "file": 44, "line": 41}, "message": "header guard does not follow preferred style"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/utils/unittest/googlemock/include/gmock/internal/gmock-port.h", "reportHash": "b4e1e4c0f5794994ee6b55f3dce95885", "checkerName": "llvm-header-guard", "reviewStatus": null, "severity": "LOW"}]};
      window.onload = function() {
        if (!browserCompatible) {
          setNonCompatibleBrowserMessage();
        } else {
          BugViewer.init(data.files, data.reports);
          BugViewer.create();
          BugViewer.initByUrl();
        }
      };
    </script>
  </head>
  <body>
  <div class="container">
    <div id="content">
      <div id="side-bar">
        <div class="header">
          <a href="index.html" class="button">&#8249; Return to List</a>
        </div>
        <div id="report-nav">
          <div class="header">Reports</div>
        </div>
      </div>
      <div id="editor-wrapper">
        <div class="header">
          <div id="file">
            <span class="label">File:</span>
            <span id="file-path"></span>
          </div>
          <div id="checker">
            <span class="label">Checker name:</span>
            <span id="checker-name"></span>
          </div>
          <div id="review-status-wrapper">
            <span class="label">Review status:</span>
            <span id="review-status"></span>
          </div>
        </div>
        <div id="editor"></div>
      </div>
    </div>
  </div>
  </body>
</html>
