<!DOCTYPE html>
<html>
  <head>
    <title>Plist HTML Viewer</title>

    <meta charset="UTF-8">

    <style type="text/css">
      .CodeMirror{font-family:monospace;height:300px;color:#000;direction:ltr}.CodeMirror-lines{padding:4px 0}.CodeMirror pre{padding:0 4px}.CodeMirror-gutter-filler,.CodeMirror-scrollbar-filler{background-color:#fff}.CodeMirror-gutters{border-right:1px solid #ddd;background-color:#f7f7f7;white-space:nowrap}.CodeMirror-linenumber{padding:0 3px 0 5px;min-width:20px;text-align:right;color:#999;white-space:nowrap}.CodeMirror-guttermarker{color:#000}.CodeMirror-guttermarker-subtle{color:#999}.CodeMirror-cursor{border-left:1px solid #000;border-right:none;width:0}.CodeMirror div.CodeMirror-secondarycursor{border-left:1px solid silver}.cm-fat-cursor .CodeMirror-cursor{width:auto;border:0!important;background:#7e7}.cm-fat-cursor div.CodeMirror-cursors{z-index:1}.cm-animate-fat-cursor{width:auto;border:0;-webkit-animation:blink 1.06s steps(1) infinite;-moz-animation:blink 1.06s steps(1) infinite;animation:blink 1.06s steps(1) infinite;background-color:#7e7}@-moz-keyframes blink{50%{background-color:transparent}}@-webkit-keyframes blink{50%{background-color:transparent}}@keyframes blink{50%{background-color:transparent}}.cm-tab{display:inline-block;text-decoration:inherit}.CodeMirror-rulers{position:absolute;left:0;right:0;top:-50px;bottom:-20px;overflow:hidden}.CodeMirror-ruler{border-left:1px solid #ccc;top:0;bottom:0;position:absolute}.cm-s-default .cm-header{color:#00f}.cm-s-default .cm-quote{color:#090}.cm-negative{color:#d44}.cm-positive{color:#292}.cm-header,.cm-strong{font-weight:700}.cm-em{font-style:italic}.cm-link{text-decoration:underline}.cm-strikethrough{text-decoration:line-through}.cm-s-default .cm-keyword{color:#708}.cm-s-default .cm-atom{color:#219}.cm-s-default .cm-number{color:#164}.cm-s-default .cm-def{color:#00f}.cm-s-default .cm-variable-2{color:#05a}.cm-s-default .cm-type,.cm-s-default .cm-variable-3{color:#085}.cm-s-default .cm-comment{color:#a50}.cm-s-default .cm-string{color:#a11}.cm-s-default .cm-string-2{color:#f50}.cm-s-default .cm-meta{color:#555}.cm-s-default .cm-qualifier{color:#555}.cm-s-default .cm-builtin{color:#30a}.cm-s-default .cm-bracket{color:#997}.cm-s-default .cm-tag{color:#170}.cm-s-default .cm-attribute{color:#00c}.cm-s-default .cm-hr{color:#999}.cm-s-default .cm-link{color:#00c}.cm-s-default .cm-error{color:red}.cm-invalidchar{color:red}.CodeMirror-composing{border-bottom:2px solid}div.CodeMirror span.CodeMirror-matchingbracket{color:#0f0}div.CodeMirror span.CodeMirror-nonmatchingbracket{color:#f22}.CodeMirror-matchingtag{background:rgba(255,150,0,.3)}.CodeMirror-activeline-background{background:#e8f2ff}.CodeMirror{position:relative;overflow:hidden;background:#fff}.CodeMirror-scroll{overflow:scroll!important;margin-bottom:-30px;margin-right:-30px;padding-bottom:30px;height:100%;outline:0;position:relative}.CodeMirror-sizer{position:relative;border-right:30px solid transparent}.CodeMirror-gutter-filler,.CodeMirror-hscrollbar,.CodeMirror-scrollbar-filler,.CodeMirror-vscrollbar{position:absolute;z-index:6;display:none}.CodeMirror-vscrollbar{right:0;top:0;overflow-x:hidden;overflow-y:scroll}.CodeMirror-hscrollbar{bottom:0;left:0;overflow-y:hidden;overflow-x:scroll}.CodeMirror-scrollbar-filler{right:0;bottom:0}.CodeMirror-gutter-filler{left:0;bottom:0}.CodeMirror-gutters{position:absolute;left:0;top:0;min-height:100%;z-index:3}.CodeMirror-gutter{white-space:normal;height:100%;display:inline-block;vertical-align:top;margin-bottom:-30px}.CodeMirror-gutter-wrapper{position:absolute;z-index:4;background:0 0!important;border:none!important}.CodeMirror-gutter-background{position:absolute;top:0;bottom:0;z-index:4}.CodeMirror-gutter-elt{position:absolute;cursor:default;z-index:4}.CodeMirror-gutter-wrapper ::selection{background-color:transparent}.CodeMirror-gutter-wrapper ::-moz-selection{background-color:transparent}.CodeMirror-lines{cursor:text;min-height:1px}.CodeMirror pre{-moz-border-radius:0;-webkit-border-radius:0;border-radius:0;border-width:0;background:0 0;font-family:inherit;font-size:inherit;margin:0;white-space:pre;word-wrap:normal;line-height:inherit;color:inherit;z-index:2;position:relative;overflow:visible;-webkit-tap-highlight-color:transparent;-webkit-font-variant-ligatures:contextual;font-variant-ligatures:contextual}.CodeMirror-wrap pre{word-wrap:break-word;white-space:pre-wrap;word-break:normal}.CodeMirror-linebackground{position:absolute;left:0;right:0;top:0;bottom:0;z-index:0}.CodeMirror-linewidget{position:relative;z-index:2;overflow:auto}.CodeMirror-rtl pre{direction:rtl}.CodeMirror-code{outline:0}.CodeMirror-gutter,.CodeMirror-gutters,.CodeMirror-linenumber,.CodeMirror-scroll,.CodeMirror-sizer{-moz-box-sizing:content-box;box-sizing:content-box}.CodeMirror-measure{position:absolute;width:100%;height:0;overflow:hidden;visibility:hidden}.CodeMirror-cursor{position:absolute;pointer-events:none}.CodeMirror-measure pre{position:static}div.CodeMirror-cursors{visibility:hidden;position:relative;z-index:3}div.CodeMirror-dragcursors{visibility:visible}.CodeMirror-focused div.CodeMirror-cursors{visibility:visible}.CodeMirror-selected{background:#d9d9d9}.CodeMirror-focused .CodeMirror-selected{background:#d7d4f0}.CodeMirror-crosshair{cursor:crosshair}.CodeMirror-line::selection,.CodeMirror-line>span::selection,.CodeMirror-line>span>span::selection{background:#d7d4f0}.CodeMirror-line::-moz-selection,.CodeMirror-line>span::-moz-selection,.CodeMirror-line>span>span::-moz-selection{background:#d7d4f0}.cm-searching{background-color:#ffa;background-color:rgba(255,255,0,.4)}.cm-force-border{padding-right:.1px}@media print{.CodeMirror div.CodeMirror-cursors{visibility:hidden}}.cm-tab-wrap-hack:after{content:''}span.CodeMirror-selectedtext{background:0 0}
/*# sourceMappingURL=codemirror.min.css.map */

      .severity-low {
  background-color: #669603;
}

.severity-low:after {
  content : 'L';
}

.severity-unspecified {
  background-color: #666666;
}

.severity-unspecified:after {
  content : 'U';
}

.severity-style {
  background-color: #9932cc;
}

.severity-style:after {
  content : 'S';
}

.severity-medium {
  background-color: #a9d323;
  color: black;
}

.severity-medium:after {
  content : 'M';
}

.severity-high {
  background-color: #ffa800;
}

.severity-high:after {
  content : 'H';
}

.severity-critical {
  background-color: #e92625;
}

.severity-critical:after {
  content : 'C';
}

i[class*="severity-"] {
  line-height: normal;
  text-transform: capitalize;
  font-size: 0.8em;
  font-weight: bold;
  color: white;
  display: inline-block;
  width: 16px;
  height: 16px;
  text-align: center;
  font-family: sans-serif;
}

      html, body {
  width: 100%;
  height: 100%;
  padding: 0px;
  margin: 0px;
}

div.container {
  padding: 10px;
}

#content {
  height: 100%;
  display: block;
  overflow: hidden;
}

#content > div {
  margin: 10px;
  overflow: hidden;
  border: 1px solid #ddd;
  border-radius: 3px;
  overflow: hidden;
  height: 97%;
}

.button {
  background-color: #f1f1f1;
  text-decoration: none;
  display: inline-block;
  padding: 8px 16px;
  color: black;
  cursor: pointer;
}

.button:hover {
  background-color: #ddd;
  color: black;
}

.review-status {
  color: white;
  text-align: center;
}

.review-status-confirmed {
  background-color: #e92625;
}

.review-status-false-positive {
  background-color: grey;
}

.review-status-intentional {
  background-color: #669603;
}

      div.container {
  width: 100%;
  height: 100%;
  padding: 0px;
}

#editor-wrapper {
  margin: 10px;
}

#side-bar {
  float: left;
  width: 260px;
  margin: 0px;
}

#report-nav ul {
  list-style-type: none;
  padding: 0;
  margin: 0;
  overflow-y: auto;
  height: 100%;
}

#report-nav ul > li {
  padding: .4em;
  background-color: #fff;
  border-bottom: 1px solid rgba(0,0,0,.125);
  text-align: left;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

#report-nav ul > li.active {
  background-color: #427ea9;
  color: white;
}

#report-nav ul > li:hover {
  background-color: #427ea9;
  color: white;
  cursor: pointer;
}

#report-nav ul a {
  text-decoration: none;
}

#report-nav i[class*="severity-"] {
  margin-right: 5px;
}

.header {
  border-bottom: 1px solid lightgrey;
  font-family: monospace;
  padding: 10px;
  background-color: #fafbfc;
  border-bottom: 1px solid #e1e4e8;
  border-top-left-radius: 2px;
  border-top-right-radius: 2px;
}

#report-nav .header {
  font-weight: bold;
}

#editor-wrapper .header > div {
  padding-top: 2px;
}

#file-path,
#checker-name {
  color: #195ea2;
}

#review-status {
  padding: 0px 5px;
}

#file-path {
  font-family: monospace;
}

.check-msg {
  display: inline-block;
  padding: 3px 6px;
  margin: 1px;
  -webkit-border-radius: 5px;
  -moz-border-radius: 5px;
  border-radius: 5px;
}

.check-msg.info {
  color: #00546f;
  background-color: #bfdfe9;
  border: 1px solid #87a8b3;
}

.check-msg.error {
  background-color: #f2dede;
  color: #a94442;
  border: 1px solid #ebcccc;
}

.check-msg.macro {
  background-color: #d7dac2;
  color: #4f5c6d;
  border: 1px solid #d7dac2;
}

.check-msg.note {
  background-color: #d7d7d7;
  color: #4f5c6d;
  border: 1px solid #bfbfbf;
}

.check-msg.current {
  border: 2px dashed #3692ff;
}

.check-msg .tag {
  padding: 1px 5px;
  text-align: center;
  border-radius: 2px;
  margin-right: 5px;
  text-decoration: inherit;
}

.check-msg .tag.macro {
  background-color: #83876a;
  color: white;
  text-transform: capitalize;
}

.check-msg .tag.note {
  background-color: #9299a1;
  color: white;
  text-transform: capitalize;
}

.checker-enum {
  color: white;
  padding: 1px 5px;
  text-align: center;
  border-radius: 25px;
  margin-right: 5px;
  text-decoration: inherit;
}

.checker-enum.info {
  background-color: #427ea9;
}

.checker-enum.error {
  background-color: #a94442;
}

.arrow {
  border: solid black;
  border-width: 0 3px 3px 0;
  display: inline-block;
  padding: 3px;
  cursor: pointer;
  margin: 0px 5px;
}

.arrow:hover {
  border: solid #437ea8;
  border-width: 0 3px 3px 0;
}

.left-arrow {
  transform: rotate(135deg);
  -webkit-transform: rotate(135deg);
}

.right-arrow {
  transform: rotate(-45deg);
  -webkit-transform: rotate(-45deg);
}

    </style>

    <script type="text/javascript">
      function setNonCompatibleBrowserMessage() {
  document.body.innerHTML =
    '<h2 style="margin-left: 20px;">Your browser is not compatible with CodeChecker Viewer!</h2> \
     <p style="margin-left: 20px;">The version required for the following browsers are:</p> \
     <ul style="margin-left: 20px;"> \
     <li>Internet Explorer: version 9 or newer</li> \
     <li>Firefox: version 22.0 or newer</li> \
     </ul>';
}

// http://stackoverflow.com/questions/5916900/how-can-you-detect-the-version-of-a-browser
var browserVersion = (function(){
  var ua = navigator.userAgent, tem,
    M = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];

  if (/trident/i.test(M[1])) {
    tem = /\brv[ :]+(\d+)/g.exec(ua) || [];
    return 'IE ' + (tem[1] || '');
  }

  if (M[1] === 'Chrome') {
    tem = ua.match(/\b(OPR|Edge)\/(\d+)/);
    if (tem != null) return tem.slice(1).join(' ').replace('OPR', 'Opera');
  }

  M = M[2] ? [M[1], M[2]] : [navigator.appName, navigator.appVersion, '-?'];
  if ((tem = ua.match(/version\/(\d+)/i)) != null) M.splice(1, 1, tem[1]);
    return M.join(' ');
})();

var pos = browserVersion.indexOf(' ');
var browser = browserVersion.substr(0, pos);
var version = parseInt(browserVersion.substr(pos + 1));

var browserCompatible
  = browser === 'Firefox'
  ? version >= 22
  : browser === 'IE'
  ? version >= 9
  : true;


      /* MIT License

Copyright (C) 2017 by Marijn Haverbeke <marijnh@gmail.com> and others

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
 */
      !function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):e.CodeMirror=t()}(this,function(){"use strict";function e(e){return new RegExp("(^|\\s)"+e+"(?:$|\\s)\\s*")}function t(e){for(var t=e.childNodes.length;t>0;--t)e.removeChild(e.firstChild);return e}function r(e,r){return t(e).appendChild(r)}function n(e,t,r,n){var i=document.createElement(e);if(r&&(i.className=r),n&&(i.style.cssText=n),"string"==typeof t)i.appendChild(document.createTextNode(t));else if(t)for(var o=0;o<t.length;++o)i.appendChild(t[o]);return i}function i(e,t,r,i){var o=n(e,t,r,i);return o.setAttribute("role","presentation"),o}function o(e,t){if(3==t.nodeType&&(t=t.parentNode),e.contains)return e.contains(t);do{if(11==t.nodeType&&(t=t.host),t==e)return!0}while(t=t.parentNode)}function l(){var e;try{e=document.activeElement}catch(t){e=document.body||null}for(;e&&e.shadowRoot&&e.shadowRoot.activeElement;)e=e.shadowRoot.activeElement;return e}function s(t,r){var n=t.className;e(r).test(n)||(t.className+=(n?" ":"")+r)}function a(t,r){for(var n=t.split(" "),i=0;i<n.length;i++)n[i]&&!e(n[i]).test(r)&&(r+=" "+n[i]);return r}function u(e){var t=Array.prototype.slice.call(arguments,1);return function(){return e.apply(null,t)}}function c(e,t,r){t||(t={});for(var n in e)!e.hasOwnProperty(n)||!1===r&&t.hasOwnProperty(n)||(t[n]=e[n]);return t}function f(e,t,r,n,i){null==t&&-1==(t=e.search(/[^\s\u00a0]/))&&(t=e.length);for(var o=n||0,l=i||0;;){var s=e.indexOf("\t",o);if(s<0||s>=t)return l+(t-o);l+=s-o,l+=r-l%r,o=s+1}}function h(e,t){for(var r=0;r<e.length;++r)if(e[r]==t)return r;return-1}function d(e,t,r){for(var n=0,i=0;;){var o=e.indexOf("\t",n);-1==o&&(o=e.length);var l=o-n;if(o==e.length||i+l>=t)return n+Math.min(l,t-i);if(i+=o-n,i+=r-i%r,n=o+1,i>=t)return n}}function p(e){for(;Kl.length<=e;)Kl.push(g(Kl)+" ");return Kl[e]}function g(e){return e[e.length-1]}function v(e,t){for(var r=[],n=0;n<e.length;n++)r[n]=t(e[n],n);return r}function m(e,t,r){for(var n=0,i=r(t);n<e.length&&r(e[n])<=i;)n++;e.splice(n,0,t)}function y(){}function b(e,t){var r;return Object.create?r=Object.create(e):(y.prototype=e,r=new y),t&&c(t,r),r}function w(e){return/\w/.test(e)||e>""&&(e.toUpperCase()!=e.toLowerCase()||jl.test(e))}function x(e,t){return t?!!(t.source.indexOf("\\w")>-1&&w(e))||t.test(e):w(e)}function C(e){for(var t in e)if(e.hasOwnProperty(t)&&e[t])return!1;return!0}function S(e){return e.charCodeAt(0)>=768&&Xl.test(e)}function L(e,t,r){for(;(r<0?t>0:t<e.length)&&S(e.charAt(t));)t+=r;return t}function k(e,t,r){for(var n=t>r?-1:1;;){if(t==r)return t;var i=(t+r)/2,o=n<0?Math.ceil(i):Math.floor(i);if(o==t)return e(o)?t:r;e(o)?r=o:t=o+n}}function T(e,t,r){var o=this;this.input=r,o.scrollbarFiller=n("div",null,"CodeMirror-scrollbar-filler"),o.scrollbarFiller.setAttribute("cm-not-content","true"),o.gutterFiller=n("div",null,"CodeMirror-gutter-filler"),o.gutterFiller.setAttribute("cm-not-content","true"),o.lineDiv=i("div",null,"CodeMirror-code"),o.selectionDiv=n("div",null,null,"position: relative; z-index: 1"),o.cursorDiv=n("div",null,"CodeMirror-cursors"),o.measure=n("div",null,"CodeMirror-measure"),o.lineMeasure=n("div",null,"CodeMirror-measure"),o.lineSpace=i("div",[o.measure,o.lineMeasure,o.selectionDiv,o.cursorDiv,o.lineDiv],null,"position: relative; outline: none");var l=i("div",[o.lineSpace],"CodeMirror-lines");o.mover=n("div",[l],null,"position: relative"),o.sizer=n("div",[o.mover],"CodeMirror-sizer"),o.sizerWidth=null,o.heightForcer=n("div",null,null,"position: absolute; height: "+Rl+"px; width: 1px;"),o.gutters=n("div",null,"CodeMirror-gutters"),o.lineGutter=null,o.scroller=n("div",[o.sizer,o.heightForcer,o.gutters],"CodeMirror-scroll"),o.scroller.setAttribute("tabIndex","-1"),o.wrapper=n("div",[o.scrollbarFiller,o.gutterFiller,o.scroller],"CodeMirror"),gl&&vl<8&&(o.gutters.style.zIndex=-1,o.scroller.style.paddingRight=0),ml||fl&&Tl||(o.scroller.draggable=!0),e&&(e.appendChild?e.appendChild(o.wrapper):e(o.wrapper)),o.viewFrom=o.viewTo=t.first,o.reportedViewFrom=o.reportedViewTo=t.first,o.view=[],o.renderedView=null,o.externalMeasured=null,o.viewOffset=0,o.lastWrapHeight=o.lastWrapWidth=0,o.updateLineNumbers=null,o.nativeBarWidth=o.barHeight=o.barWidth=0,o.scrollbarsClipped=!1,o.lineNumWidth=o.lineNumInnerWidth=o.lineNumChars=null,o.alignWidgets=!1,o.cachedCharWidth=o.cachedTextHeight=o.cachedPaddingH=null,o.maxLine=null,o.maxLineLength=0,o.maxLineChanged=!1,o.wheelDX=o.wheelDY=o.wheelStartX=o.wheelStartY=null,o.shift=!1,o.selForContextMenu=null,o.activeTouch=null,r.init(o)}function M(e,t){if((t-=e.first)<0||t>=e.size)throw new Error("There is no line "+(t+e.first)+" in the document.");for(var r=e;!r.lines;)for(var n=0;;++n){var i=r.children[n],o=i.chunkSize();if(t<o){r=i;break}t-=o}return r.lines[t]}function N(e,t,r){var n=[],i=t.line;return e.iter(t.line,r.line+1,function(e){var o=e.text;i==r.line&&(o=o.slice(0,r.ch)),i==t.line&&(o=o.slice(t.ch)),n.push(o),++i}),n}function O(e,t,r){var n=[];return e.iter(t,r,function(e){n.push(e.text)}),n}function A(e,t){var r=t-e.height;if(r)for(var n=e;n;n=n.parent)n.height+=r}function W(e){if(null==e.parent)return null;for(var t=e.parent,r=h(t.lines,e),n=t.parent;n;t=n,n=n.parent)for(var i=0;n.children[i]!=t;++i)r+=n.children[i].chunkSize();return r+t.first}function D(e,t){var r=e.first;e:do{for(var n=0;n<e.children.length;++n){var i=e.children[n],o=i.height;if(t<o){e=i;continue e}t-=o,r+=i.chunkSize()}return r}while(!e.lines);for(var l=0;l<e.lines.length;++l){var s=e.lines[l].height;if(t<s)break;t-=s}return r+l}function H(e,t){return t>=e.first&&t<e.first+e.size}function F(e,t){return String(e.lineNumberFormatter(t+e.firstLineNumber))}function E(e,t,r){if(void 0===r&&(r=null),!(this instanceof E))return new E(e,t,r);this.line=e,this.ch=t,this.sticky=r}function P(e,t){return e.line-t.line||e.ch-t.ch}function I(e,t){return e.sticky==t.sticky&&0==P(e,t)}function z(e){return E(e.line,e.ch)}function R(e,t){return P(e,t)<0?t:e}function B(e,t){return P(e,t)<0?e:t}function G(e,t){return Math.max(e.first,Math.min(t,e.first+e.size-1))}function U(e,t){if(t.line<e.first)return E(e.first,0);var r=e.first+e.size-1;return t.line>r?E(r,M(e,r).text.length):V(t,M(e,t.line).text.length)}function V(e,t){var r=e.ch;return null==r||r>t?E(e.line,t):r<0?E(e.line,0):e}function K(e,t){for(var r=[],n=0;n<t.length;n++)r[n]=U(e,t[n]);return r}function j(){Yl=!0}function X(){_l=!0}function Y(e,t,r){this.marker=e,this.from=t,this.to=r}function _(e,t){if(e)for(var r=0;r<e.length;++r){var n=e[r];if(n.marker==t)return n}}function $(e,t){for(var r,n=0;n<e.length;++n)e[n]!=t&&(r||(r=[])).push(e[n]);return r}function q(e,t){e.markedSpans=e.markedSpans?e.markedSpans.concat([t]):[t],t.marker.attachLine(e)}function Z(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t)||o.from==t&&"bookmark"==l.type&&(!r||!o.marker.insertLeft)){var s=null==o.to||(l.inclusiveRight?o.to>=t:o.to>t);(n||(n=[])).push(new Y(l,o.from,s?null:o.to))}}return n}function Q(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.to||(l.inclusiveRight?o.to>=t:o.to>t)||o.from==t&&"bookmark"==l.type&&(!r||o.marker.insertLeft)){var s=null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t);(n||(n=[])).push(new Y(l,s?null:o.from-t,null==o.to?null:o.to-t))}}return n}function J(e,t){if(t.full)return null;var r=H(e,t.from.line)&&M(e,t.from.line).markedSpans,n=H(e,t.to.line)&&M(e,t.to.line).markedSpans;if(!r&&!n)return null;var i=t.from.ch,o=t.to.ch,l=0==P(t.from,t.to),s=Z(r,i,l),a=Q(n,o,l),u=1==t.text.length,c=g(t.text).length+(u?i:0);if(s)for(var f=0;f<s.length;++f){var h=s[f];if(null==h.to){var d=_(a,h.marker);d?u&&(h.to=null==d.to?null:d.to+c):h.to=i}}if(a)for(var p=0;p<a.length;++p){var v=a[p];null!=v.to&&(v.to+=c),null==v.from?_(s,v.marker)||(v.from=c,u&&(s||(s=[])).push(v)):(v.from+=c,u&&(s||(s=[])).push(v))}s&&(s=ee(s)),a&&a!=s&&(a=ee(a));var m=[s];if(!u){var y,b=t.text.length-2;if(b>0&&s)for(var w=0;w<s.length;++w)null==s[w].to&&(y||(y=[])).push(new Y(s[w].marker,null,null));for(var x=0;x<b;++x)m.push(y);m.push(a)}return m}function ee(e){for(var t=0;t<e.length;++t){var r=e[t];null!=r.from&&r.from==r.to&&!1!==r.marker.clearWhenEmpty&&e.splice(t--,1)}return e.length?e:null}function te(e,t,r){var n=null;if(e.iter(t.line,r.line+1,function(e){if(e.markedSpans)for(var t=0;t<e.markedSpans.length;++t){var r=e.markedSpans[t].marker;!r.readOnly||n&&-1!=h(n,r)||(n||(n=[])).push(r)}}),!n)return null;for(var i=[{from:t,to:r}],o=0;o<n.length;++o)for(var l=n[o],s=l.find(0),a=0;a<i.length;++a){var u=i[a];if(!(P(u.to,s.from)<0||P(u.from,s.to)>0)){var c=[a,1],f=P(u.from,s.from),d=P(u.to,s.to);(f<0||!l.inclusiveLeft&&!f)&&c.push({from:u.from,to:s.from}),(d>0||!l.inclusiveRight&&!d)&&c.push({from:s.to,to:u.to}),i.splice.apply(i,c),a+=c.length-3}}return i}function re(e){var t=e.markedSpans;if(t){for(var r=0;r<t.length;++r)t[r].marker.detachLine(e);e.markedSpans=null}}function ne(e,t){if(t){for(var r=0;r<t.length;++r)t[r].marker.attachLine(e);e.markedSpans=t}}function ie(e){return e.inclusiveLeft?-1:0}function oe(e){return e.inclusiveRight?1:0}function le(e,t){var r=e.lines.length-t.lines.length;if(0!=r)return r;var n=e.find(),i=t.find(),o=P(n.from,i.from)||ie(e)-ie(t);if(o)return-o;var l=P(n.to,i.to)||oe(e)-oe(t);return l||t.id-e.id}function se(e,t){var r,n=_l&&e.markedSpans;if(n)for(var i=void 0,o=0;o<n.length;++o)(i=n[o]).marker.collapsed&&null==(t?i.from:i.to)&&(!r||le(r,i.marker)<0)&&(r=i.marker);return r}function ae(e){return se(e,!0)}function ue(e){return se(e,!1)}function ce(e,t,r,n,i){var o=M(e,t),l=_l&&o.markedSpans;if(l)for(var s=0;s<l.length;++s){var a=l[s];if(a.marker.collapsed){var u=a.marker.find(0),c=P(u.from,r)||ie(a.marker)-ie(i),f=P(u.to,n)||oe(a.marker)-oe(i);if(!(c>=0&&f<=0||c<=0&&f>=0)&&(c<=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.to,r)>=0:P(u.to,r)>0)||c>=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.from,n)<=0:P(u.from,n)<0)))return!0}}}function fe(e){for(var t;t=ae(e);)e=t.find(-1,!0).line;return e}function he(e){for(var t;t=ue(e);)e=t.find(1,!0).line;return e}function de(e){for(var t,r;t=ue(e);)e=t.find(1,!0).line,(r||(r=[])).push(e);return r}function pe(e,t){var r=M(e,t),n=fe(r);return r==n?t:W(n)}function ge(e,t){if(t>e.lastLine())return t;var r,n=M(e,t);if(!ve(e,n))return t;for(;r=ue(n);)n=r.find(1,!0).line;return W(n)+1}function ve(e,t){var r=_l&&t.markedSpans;if(r)for(var n=void 0,i=0;i<r.length;++i)if((n=r[i]).marker.collapsed){if(null==n.from)return!0;if(!n.marker.widgetNode&&0==n.from&&n.marker.inclusiveLeft&&me(e,t,n))return!0}}function me(e,t,r){if(null==r.to){var n=r.marker.find(1,!0);return me(e,n.line,_(n.line.markedSpans,r.marker))}if(r.marker.inclusiveRight&&r.to==t.text.length)return!0;for(var i=void 0,o=0;o<t.markedSpans.length;++o)if((i=t.markedSpans[o]).marker.collapsed&&!i.marker.widgetNode&&i.from==r.to&&(null==i.to||i.to!=r.from)&&(i.marker.inclusiveLeft||r.marker.inclusiveRight)&&me(e,t,i))return!0}function ye(e){for(var t=0,r=(e=fe(e)).parent,n=0;n<r.lines.length;++n){var i=r.lines[n];if(i==e)break;t+=i.height}for(var o=r.parent;o;r=o,o=r.parent)for(var l=0;l<o.children.length;++l){var s=o.children[l];if(s==r)break;t+=s.height}return t}function be(e){if(0==e.height)return 0;for(var t,r=e.text.length,n=e;t=ae(n);){var i=t.find(0,!0);n=i.from.line,r+=i.from.ch-i.to.ch}for(n=e;t=ue(n);){var o=t.find(0,!0);r-=n.text.length-o.from.ch,r+=(n=o.to.line).text.length-o.to.ch}return r}function we(e){var t=e.display,r=e.doc;t.maxLine=M(r,r.first),t.maxLineLength=be(t.maxLine),t.maxLineChanged=!0,r.iter(function(e){var r=be(e);r>t.maxLineLength&&(t.maxLineLength=r,t.maxLine=e)})}function xe(e,t,r,n){if(!e)return n(t,r,"ltr",0);for(var i=!1,o=0;o<e.length;++o){var l=e[o];(l.from<r&&l.to>t||t==r&&l.to==t)&&(n(Math.max(l.from,t),Math.min(l.to,r),1==l.level?"rtl":"ltr",o),i=!0)}i||n(t,r,"ltr")}function Ce(e,t,r){var n;$l=null;for(var i=0;i<e.length;++i){var o=e[i];if(o.from<t&&o.to>t)return i;o.to==t&&(o.from!=o.to&&"before"==r?n=i:$l=i),o.from==t&&(o.from!=o.to&&"before"!=r?n=i:$l=i)}return null!=n?n:$l}function Se(e,t){var r=e.order;return null==r&&(r=e.order=ql(e.text,t)),r}function Le(e,t){return e._handlers&&e._handlers[t]||Zl}function ke(e,t,r){if(e.removeEventListener)e.removeEventListener(t,r,!1);else if(e.detachEvent)e.detachEvent("on"+t,r);else{var n=e._handlers,i=n&&n[t];if(i){var o=h(i,r);o>-1&&(n[t]=i.slice(0,o).concat(i.slice(o+1)))}}}function Te(e,t){var r=Le(e,t);if(r.length)for(var n=Array.prototype.slice.call(arguments,2),i=0;i<r.length;++i)r[i].apply(null,n)}function Me(e,t,r){return"string"==typeof t&&(t={type:t,preventDefault:function(){this.defaultPrevented=!0}}),Te(e,r||t.type,e,t),He(t)||t.codemirrorIgnore}function Ne(e){var t=e._handlers&&e._handlers.cursorActivity;if(t)for(var r=e.curOp.cursorActivityHandlers||(e.curOp.cursorActivityHandlers=[]),n=0;n<t.length;++n)-1==h(r,t[n])&&r.push(t[n])}function Oe(e,t){return Le(e,t).length>0}function Ae(e){e.prototype.on=function(e,t){Ql(this,e,t)},e.prototype.off=function(e,t){ke(this,e,t)}}function We(e){e.preventDefault?e.preventDefault():e.returnValue=!1}function De(e){e.stopPropagation?e.stopPropagation():e.cancelBubble=!0}function He(e){return null!=e.defaultPrevented?e.defaultPrevented:0==e.returnValue}function Fe(e){We(e),De(e)}function Ee(e){return e.target||e.srcElement}function Pe(e){var t=e.which;return null==t&&(1&e.button?t=1:2&e.button?t=3:4&e.button&&(t=2)),Ml&&e.ctrlKey&&1==t&&(t=3),t}function Ie(e){if(null==Il){var t=n("span","​");r(e,n("span",[t,document.createTextNode("x")])),0!=e.firstChild.offsetHeight&&(Il=t.offsetWidth<=1&&t.offsetHeight>2&&!(gl&&vl<8))}var i=Il?n("span","​"):n("span"," ",null,"display: inline-block; width: 1px; margin-right: -1px");return i.setAttribute("cm-text",""),i}function ze(e){if(null!=zl)return zl;var n=r(e,document.createTextNode("AخA")),i=Wl(n,0,1).getBoundingClientRect(),o=Wl(n,1,2).getBoundingClientRect();return t(e),!(!i||i.left==i.right)&&(zl=o.right-i.right<3)}function Re(e){if(null!=ns)return ns;var t=r(e,n("span","x")),i=t.getBoundingClientRect(),o=Wl(t,0,1).getBoundingClientRect();return ns=Math.abs(i.left-o.left)>1}function Be(e,t){arguments.length>2&&(t.dependencies=Array.prototype.slice.call(arguments,2)),is[e]=t}function Ge(e){if("string"==typeof e&&os.hasOwnProperty(e))e=os[e];else if(e&&"string"==typeof e.name&&os.hasOwnProperty(e.name)){var t=os[e.name];"string"==typeof t&&(t={name:t}),(e=b(t,e)).name=t.name}else{if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+xml$/.test(e))return Ge("application/xml");if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+json$/.test(e))return Ge("application/json")}return"string"==typeof e?{name:e}:e||{name:"null"}}function Ue(e,t){t=Ge(t);var r=is[t.name];if(!r)return Ue(e,"text/plain");var n=r(e,t);if(ls.hasOwnProperty(t.name)){var i=ls[t.name];for(var o in i)i.hasOwnProperty(o)&&(n.hasOwnProperty(o)&&(n["_"+o]=n[o]),n[o]=i[o])}if(n.name=t.name,t.helperType&&(n.helperType=t.helperType),t.modeProps)for(var l in t.modeProps)n[l]=t.modeProps[l];return n}function Ve(e,t){c(t,ls.hasOwnProperty(e)?ls[e]:ls[e]={})}function Ke(e,t){if(!0===t)return t;if(e.copyState)return e.copyState(t);var r={};for(var n in t){var i=t[n];i instanceof Array&&(i=i.concat([])),r[n]=i}return r}function je(e,t){for(var r;e.innerMode&&(r=e.innerMode(t))&&r.mode!=e;)t=r.state,e=r.mode;return r||{mode:e,state:t}}function Xe(e,t,r){return!e.startState||e.startState(t,r)}function Ye(e,t,r,n){var i=[e.state.modeGen],o={};tt(e,t.text,e.doc.mode,r,function(e,t){return i.push(e,t)},o,n);for(var l=r.state,s=0;s<e.state.overlays.length;++s)!function(n){var l=e.state.overlays[n],s=1,a=0;r.state=!0,tt(e,t.text,l.mode,r,function(e,t){for(var r=s;a<e;){var n=i[s];n>e&&i.splice(s,1,e,i[s+1],n),s+=2,a=Math.min(e,n)}if(t)if(l.opaque)i.splice(r,s-r,e,"overlay "+t),s=r+2;else for(;r<s;r+=2){var o=i[r+1];i[r+1]=(o?o+" ":"")+"overlay "+t}},o)}(s);return r.state=l,{styles:i,classes:o.bgClass||o.textClass?o:null}}function _e(e,t,r){if(!t.styles||t.styles[0]!=e.state.modeGen){var n=$e(e,W(t)),i=t.text.length>e.options.maxHighlightLength&&Ke(e.doc.mode,n.state),o=Ye(e,t,n);i&&(n.state=i),t.stateAfter=n.save(!i),t.styles=o.styles,o.classes?t.styleClasses=o.classes:t.styleClasses&&(t.styleClasses=null),r===e.doc.highlightFrontier&&(e.doc.modeFrontier=Math.max(e.doc.modeFrontier,++e.doc.highlightFrontier))}return t.styles}function $e(e,t,r){var n=e.doc,i=e.display;if(!n.mode.startState)return new us(n,!0,t);var o=rt(e,t,r),l=o>n.first&&M(n,o-1).stateAfter,s=l?us.fromSaved(n,l,o):new us(n,Xe(n.mode),o);return n.iter(o,t,function(r){qe(e,r.text,s);var n=s.line;r.stateAfter=n==t-1||n%5==0||n>=i.viewFrom&&n<i.viewTo?s.save():null,s.nextLine()}),r&&(n.modeFrontier=s.line),s}function qe(e,t,r,n){var i=e.doc.mode,o=new ss(t,e.options.tabSize,r);for(o.start=o.pos=n||0,""==t&&Ze(i,r.state);!o.eol();)Qe(i,o,r.state),o.start=o.pos}function Ze(e,t){if(e.blankLine)return e.blankLine(t);if(e.innerMode){var r=je(e,t);return r.mode.blankLine?r.mode.blankLine(r.state):void 0}}function Qe(e,t,r,n){for(var i=0;i<10;i++){n&&(n[0]=je(e,r).mode);var o=e.token(t,r);if(t.pos>t.start)return o}throw new Error("Mode "+e.name+" failed to advance stream.")}function Je(e,t,r,n){var i,o,l=e.doc,s=l.mode,a=M(l,(t=U(l,t)).line),u=$e(e,t.line,r),c=new ss(a.text,e.options.tabSize,u);for(n&&(o=[]);(n||c.pos<t.ch)&&!c.eol();)c.start=c.pos,i=Qe(s,c,u.state),n&&o.push(new cs(c,i,Ke(l.mode,u.state)));return n?o:new cs(c,i,u.state)}function et(e,t){if(e)for(;;){var r=e.match(/(?:^|\s+)line-(background-)?(\S+)/);if(!r)break;e=e.slice(0,r.index)+e.slice(r.index+r[0].length);var n=r[1]?"bgClass":"textClass";null==t[n]?t[n]=r[2]:new RegExp("(?:^|s)"+r[2]+"(?:$|s)").test(t[n])||(t[n]+=" "+r[2])}return e}function tt(e,t,r,n,i,o,l){var s=r.flattenSpans;null==s&&(s=e.options.flattenSpans);var a,u=0,c=null,f=new ss(t,e.options.tabSize,n),h=e.options.addModeClass&&[null];for(""==t&&et(Ze(r,n.state),o);!f.eol();){if(f.pos>e.options.maxHighlightLength?(s=!1,l&&qe(e,t,n,f.pos),f.pos=t.length,a=null):a=et(Qe(r,f,n.state,h),o),h){var d=h[0].name;d&&(a="m-"+(a?d+" "+a:d))}if(!s||c!=a){for(;u<f.start;)i(u=Math.min(f.start,u+5e3),c);c=a}f.start=f.pos}for(;u<f.pos;){var p=Math.min(f.pos,u+5e3);i(p,c),u=p}}function rt(e,t,r){for(var n,i,o=e.doc,l=r?-1:t-(e.doc.mode.innerMode?1e3:100),s=t;s>l;--s){if(s<=o.first)return o.first;var a=M(o,s-1),u=a.stateAfter;if(u&&(!r||s+(u instanceof as?u.lookAhead:0)<=o.modeFrontier))return s;var c=f(a.text,null,e.options.tabSize);(null==i||n>c)&&(i=s-1,n=c)}return i}function nt(e,t){if(e.modeFrontier=Math.min(e.modeFrontier,t),!(e.highlightFrontier<t-10)){for(var r=e.first,n=t-1;n>r;n--){var i=M(e,n).stateAfter;if(i&&(!(i instanceof as)||n+i.lookAhead<t)){r=n+1;break}}e.highlightFrontier=Math.min(e.highlightFrontier,r)}}function it(e,t,r,n){e.text=t,e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null),null!=e.order&&(e.order=null),re(e),ne(e,r);var i=n?n(e):1;i!=e.height&&A(e,i)}function ot(e){e.parent=null,re(e)}function lt(e,t){if(!e||/^\s*$/.test(e))return null;var r=t.addModeClass?ps:ds;return r[e]||(r[e]=e.replace(/\S+/g,"cm-$&"))}function st(e,t){var r=i("span",null,null,ml?"padding-right: .1px":null),n={pre:i("pre",[r],"CodeMirror-line"),content:r,col:0,pos:0,cm:e,trailingSpace:!1,splitSpaces:(gl||ml)&&e.getOption("lineWrapping")};t.measure={};for(var o=0;o<=(t.rest?t.rest.length:0);o++){var l=o?t.rest[o-1]:t.line,s=void 0;n.pos=0,n.addToken=ut,ze(e.display.measure)&&(s=Se(l,e.doc.direction))&&(n.addToken=ft(n.addToken,s)),n.map=[],dt(l,n,_e(e,l,t!=e.display.externalMeasured&&W(l))),l.styleClasses&&(l.styleClasses.bgClass&&(n.bgClass=a(l.styleClasses.bgClass,n.bgClass||"")),l.styleClasses.textClass&&(n.textClass=a(l.styleClasses.textClass,n.textClass||""))),0==n.map.length&&n.map.push(0,0,n.content.appendChild(Ie(e.display.measure))),0==o?(t.measure.map=n.map,t.measure.cache={}):((t.measure.maps||(t.measure.maps=[])).push(n.map),(t.measure.caches||(t.measure.caches=[])).push({}))}if(ml){var u=n.content.lastChild;(/\bcm-tab\b/.test(u.className)||u.querySelector&&u.querySelector(".cm-tab"))&&(n.content.className="cm-tab-wrap-hack")}return Te(e,"renderLine",e,t.line,n.pre),n.pre.className&&(n.textClass=a(n.pre.className,n.textClass||"")),n}function at(e){var t=n("span","•","cm-invalidchar");return t.title="\\u"+e.charCodeAt(0).toString(16),t.setAttribute("aria-label",t.title),t}function ut(e,t,r,i,o,l,s){if(t){var a,u=e.splitSpaces?ct(t,e.trailingSpace):t,c=e.cm.state.specialChars,f=!1;if(c.test(t)){a=document.createDocumentFragment();for(var h=0;;){c.lastIndex=h;var d=c.exec(t),g=d?d.index-h:t.length-h;if(g){var v=document.createTextNode(u.slice(h,h+g));gl&&vl<9?a.appendChild(n("span",[v])):a.appendChild(v),e.map.push(e.pos,e.pos+g,v),e.col+=g,e.pos+=g}if(!d)break;h+=g+1;var m=void 0;if("\t"==d[0]){var y=e.cm.options.tabSize,b=y-e.col%y;(m=a.appendChild(n("span",p(b),"cm-tab"))).setAttribute("role","presentation"),m.setAttribute("cm-text","\t"),e.col+=b}else"\r"==d[0]||"\n"==d[0]?((m=a.appendChild(n("span","\r"==d[0]?"␍":"␤","cm-invalidchar"))).setAttribute("cm-text",d[0]),e.col+=1):((m=e.cm.options.specialCharPlaceholder(d[0])).setAttribute("cm-text",d[0]),gl&&vl<9?a.appendChild(n("span",[m])):a.appendChild(m),e.col+=1);e.map.push(e.pos,e.pos+1,m),e.pos++}}else e.col+=t.length,a=document.createTextNode(u),e.map.push(e.pos,e.pos+t.length,a),gl&&vl<9&&(f=!0),e.pos+=t.length;if(e.trailingSpace=32==u.charCodeAt(t.length-1),r||i||o||f||s){var w=r||"";i&&(w+=i),o&&(w+=o);var x=n("span",[a],w,s);return l&&(x.title=l),e.content.appendChild(x)}e.content.appendChild(a)}}function ct(e,t){if(e.length>1&&!/  /.test(e))return e;for(var r=t,n="",i=0;i<e.length;i++){var o=e.charAt(i);" "!=o||!r||i!=e.length-1&&32!=e.charCodeAt(i+1)||(o=" "),n+=o,r=" "==o}return n}function ft(e,t){return function(r,n,i,o,l,s,a){i=i?i+" cm-force-border":"cm-force-border";for(var u=r.pos,c=u+n.length;;){for(var f=void 0,h=0;h<t.length&&!((f=t[h]).to>u&&f.from<=u);h++);if(f.to>=c)return e(r,n,i,o,l,s,a);e(r,n.slice(0,f.to-u),i,o,null,s,a),o=null,n=n.slice(f.to-u),u=f.to}}}function ht(e,t,r,n){var i=!n&&r.widgetNode;i&&e.map.push(e.pos,e.pos+t,i),!n&&e.cm.display.input.needsContentAttribute&&(i||(i=e.content.appendChild(document.createElement("span"))),i.setAttribute("cm-marker",r.id)),i&&(e.cm.display.input.setUneditable(i),e.content.appendChild(i)),e.pos+=t,e.trailingSpace=!1}function dt(e,t,r){var n=e.markedSpans,i=e.text,o=0;if(n)for(var l,s,a,u,c,f,h,d=i.length,p=0,g=1,v="",m=0;;){if(m==p){a=u=c=f=s="",h=null,m=1/0;for(var y=[],b=void 0,w=0;w<n.length;++w){var x=n[w],C=x.marker;"bookmark"==C.type&&x.from==p&&C.widgetNode?y.push(C):x.from<=p&&(null==x.to||x.to>p||C.collapsed&&x.to==p&&x.from==p)?(null!=x.to&&x.to!=p&&m>x.to&&(m=x.to,u=""),C.className&&(a+=" "+C.className),C.css&&(s=(s?s+";":"")+C.css),C.startStyle&&x.from==p&&(c+=" "+C.startStyle),C.endStyle&&x.to==m&&(b||(b=[])).push(C.endStyle,x.to),C.title&&!f&&(f=C.title),C.collapsed&&(!h||le(h.marker,C)<0)&&(h=x)):x.from>p&&m>x.from&&(m=x.from)}if(b)for(var S=0;S<b.length;S+=2)b[S+1]==m&&(u+=" "+b[S]);if(!h||h.from==p)for(var L=0;L<y.length;++L)ht(t,0,y[L]);if(h&&(h.from||0)==p){if(ht(t,(null==h.to?d+1:h.to)-p,h.marker,null==h.from),null==h.to)return;h.to==p&&(h=!1)}}if(p>=d)break;for(var k=Math.min(d,m);;){if(v){var T=p+v.length;if(!h){var M=T>k?v.slice(0,k-p):v;t.addToken(t,M,l?l+a:a,c,p+M.length==m?u:"",f,s)}if(T>=k){v=v.slice(k-p),p=k;break}p=T,c=""}v=i.slice(o,o=r[g++]),l=lt(r[g++],t.cm.options)}}else for(var N=1;N<r.length;N+=2)t.addToken(t,i.slice(o,o=r[N]),lt(r[N+1],t.cm.options))}function pt(e,t,r){this.line=t,this.rest=de(t),this.size=this.rest?W(g(this.rest))-r+1:1,this.node=this.text=null,this.hidden=ve(e,t)}function gt(e,t,r){for(var n,i=[],o=t;o<r;o=n){var l=new pt(e.doc,M(e.doc,o),o);n=o+l.size,i.push(l)}return i}function vt(e){gs?gs.ops.push(e):e.ownsGroup=gs={ops:[e],delayedCallbacks:[]}}function mt(e){var t=e.delayedCallbacks,r=0;do{for(;r<t.length;r++)t[r].call(null);for(var n=0;n<e.ops.length;n++){var i=e.ops[n];if(i.cursorActivityHandlers)for(;i.cursorActivityCalled<i.cursorActivityHandlers.length;)i.cursorActivityHandlers[i.cursorActivityCalled++].call(null,i.cm)}}while(r<t.length)}function yt(e,t){var r=e.ownsGroup;if(r)try{mt(r)}finally{gs=null,t(r)}}function bt(e,t){var r=Le(e,t);if(r.length){var n,i=Array.prototype.slice.call(arguments,2);gs?n=gs.delayedCallbacks:vs?n=vs:(n=vs=[],setTimeout(wt,0));for(var o=0;o<r.length;++o)!function(e){n.push(function(){return r[e].apply(null,i)})}(o)}}function wt(){var e=vs;vs=null;for(var t=0;t<e.length;++t)e[t]()}function xt(e,t,r,n){for(var i=0;i<t.changes.length;i++){var o=t.changes[i];"text"==o?kt(e,t):"gutter"==o?Mt(e,t,r,n):"class"==o?Tt(e,t):"widget"==o&&Nt(e,t,n)}t.changes=null}function Ct(e){return e.node==e.text&&(e.node=n("div",null,null,"position: relative"),e.text.parentNode&&e.text.parentNode.replaceChild(e.node,e.text),e.node.appendChild(e.text),gl&&vl<8&&(e.node.style.zIndex=2)),e.node}function St(e,t){var r=t.bgClass?t.bgClass+" "+(t.line.bgClass||""):t.line.bgClass;if(r&&(r+=" CodeMirror-linebackground"),t.background)r?t.background.className=r:(t.background.parentNode.removeChild(t.background),t.background=null);else if(r){var i=Ct(t);t.background=i.insertBefore(n("div",null,r),i.firstChild),e.display.input.setUneditable(t.background)}}function Lt(e,t){var r=e.display.externalMeasured;return r&&r.line==t.line?(e.display.externalMeasured=null,t.measure=r.measure,r.built):st(e,t)}function kt(e,t){var r=t.text.className,n=Lt(e,t);t.text==t.node&&(t.node=n.pre),t.text.parentNode.replaceChild(n.pre,t.text),t.text=n.pre,n.bgClass!=t.bgClass||n.textClass!=t.textClass?(t.bgClass=n.bgClass,t.textClass=n.textClass,Tt(e,t)):r&&(t.text.className=r)}function Tt(e,t){St(e,t),t.line.wrapClass?Ct(t).className=t.line.wrapClass:t.node!=t.text&&(t.node.className="");var r=t.textClass?t.textClass+" "+(t.line.textClass||""):t.line.textClass;t.text.className=r||""}function Mt(e,t,r,i){if(t.gutter&&(t.node.removeChild(t.gutter),t.gutter=null),t.gutterBackground&&(t.node.removeChild(t.gutterBackground),t.gutterBackground=null),t.line.gutterClass){var o=Ct(t);t.gutterBackground=n("div",null,"CodeMirror-gutter-background "+t.line.gutterClass,"left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px; width: "+i.gutterTotalWidth+"px"),e.display.input.setUneditable(t.gutterBackground),o.insertBefore(t.gutterBackground,t.text)}var l=t.line.gutterMarkers;if(e.options.lineNumbers||l){var s=Ct(t),a=t.gutter=n("div",null,"CodeMirror-gutter-wrapper","left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px");if(e.display.input.setUneditable(a),s.insertBefore(a,t.text),t.line.gutterClass&&(a.className+=" "+t.line.gutterClass),!e.options.lineNumbers||l&&l["CodeMirror-linenumbers"]||(t.lineNumber=a.appendChild(n("div",F(e.options,r),"CodeMirror-linenumber CodeMirror-gutter-elt","left: "+i.gutterLeft["CodeMirror-linenumbers"]+"px; width: "+e.display.lineNumInnerWidth+"px"))),l)for(var u=0;u<e.options.gutters.length;++u){var c=e.options.gutters[u],f=l.hasOwnProperty(c)&&l[c];f&&a.appendChild(n("div",[f],"CodeMirror-gutter-elt","left: "+i.gutterLeft[c]+"px; width: "+i.gutterWidth[c]+"px"))}}}function Nt(e,t,r){t.alignable&&(t.alignable=null);for(var n=t.node.firstChild,i=void 0;n;n=i)i=n.nextSibling,"CodeMirror-linewidget"==n.className&&t.node.removeChild(n);At(e,t,r)}function Ot(e,t,r,n){var i=Lt(e,t);return t.text=t.node=i.pre,i.bgClass&&(t.bgClass=i.bgClass),i.textClass&&(t.textClass=i.textClass),Tt(e,t),Mt(e,t,r,n),At(e,t,n),t.node}function At(e,t,r){if(Wt(e,t.line,t,r,!0),t.rest)for(var n=0;n<t.rest.length;n++)Wt(e,t.rest[n],t,r,!1)}function Wt(e,t,r,i,o){if(t.widgets)for(var l=Ct(r),s=0,a=t.widgets;s<a.length;++s){var u=a[s],c=n("div",[u.node],"CodeMirror-linewidget");u.handleMouseEvents||c.setAttribute("cm-ignore-events","true"),Dt(u,c,r,i),e.display.input.setUneditable(c),o&&u.above?l.insertBefore(c,r.gutter||r.text):l.appendChild(c),bt(u,"redraw")}}function Dt(e,t,r,n){if(e.noHScroll){(r.alignable||(r.alignable=[])).push(t);var i=n.wrapperWidth;t.style.left=n.fixedPos+"px",e.coverGutter||(i-=n.gutterTotalWidth,t.style.paddingLeft=n.gutterTotalWidth+"px"),t.style.width=i+"px"}e.coverGutter&&(t.style.zIndex=5,t.style.position="relative",e.noHScroll||(t.style.marginLeft=-n.gutterTotalWidth+"px"))}function Ht(e){if(null!=e.height)return e.height;var t=e.doc.cm;if(!t)return 0;if(!o(document.body,e.node)){var i="position: relative;";e.coverGutter&&(i+="margin-left: -"+t.display.gutters.offsetWidth+"px;"),e.noHScroll&&(i+="width: "+t.display.wrapper.clientWidth+"px;"),r(t.display.measure,n("div",[e.node],null,i))}return e.height=e.node.parentNode.offsetHeight}function Ft(e,t){for(var r=Ee(t);r!=e.wrapper;r=r.parentNode)if(!r||1==r.nodeType&&"true"==r.getAttribute("cm-ignore-events")||r.parentNode==e.sizer&&r!=e.mover)return!0}function Et(e){return e.lineSpace.offsetTop}function Pt(e){return e.mover.offsetHeight-e.lineSpace.offsetHeight}function It(e){if(e.cachedPaddingH)return e.cachedPaddingH;var t=r(e.measure,n("pre","x")),i=window.getComputedStyle?window.getComputedStyle(t):t.currentStyle,o={left:parseInt(i.paddingLeft),right:parseInt(i.paddingRight)};return isNaN(o.left)||isNaN(o.right)||(e.cachedPaddingH=o),o}function zt(e){return Rl-e.display.nativeBarWidth}function Rt(e){return e.display.scroller.clientWidth-zt(e)-e.display.barWidth}function Bt(e){return e.display.scroller.clientHeight-zt(e)-e.display.barHeight}function Gt(e,t,r){var n=e.options.lineWrapping,i=n&&Rt(e);if(!t.measure.heights||n&&t.measure.width!=i){var o=t.measure.heights=[];if(n){t.measure.width=i;for(var l=t.text.firstChild.getClientRects(),s=0;s<l.length-1;s++){var a=l[s],u=l[s+1];Math.abs(a.bottom-u.bottom)>2&&o.push((a.bottom+u.top)/2-r.top)}}o.push(r.bottom-r.top)}}function Ut(e,t,r){if(e.line==t)return{map:e.measure.map,cache:e.measure.cache};for(var n=0;n<e.rest.length;n++)if(e.rest[n]==t)return{map:e.measure.maps[n],cache:e.measure.caches[n]};for(var i=0;i<e.rest.length;i++)if(W(e.rest[i])>r)return{map:e.measure.maps[i],cache:e.measure.caches[i],before:!0}}function Vt(e,t){var n=W(t=fe(t)),i=e.display.externalMeasured=new pt(e.doc,t,n);i.lineN=n;var o=i.built=st(e,i);return i.text=o.pre,r(e.display.lineMeasure,o.pre),i}function Kt(e,t,r,n){return Yt(e,Xt(e,t),r,n)}function jt(e,t){if(t>=e.display.viewFrom&&t<e.display.viewTo)return e.display.view[Lr(e,t)];var r=e.display.externalMeasured;return r&&t>=r.lineN&&t<r.lineN+r.size?r:void 0}function Xt(e,t){var r=W(t),n=jt(e,r);n&&!n.text?n=null:n&&n.changes&&(xt(e,n,r,br(e)),e.curOp.forceUpdate=!0),n||(n=Vt(e,t));var i=Ut(n,t,r);return{line:t,view:n,rect:null,map:i.map,cache:i.cache,before:i.before,hasHeights:!1}}function Yt(e,t,r,n,i){t.before&&(r=-1);var o,l=r+(n||"");return t.cache.hasOwnProperty(l)?o=t.cache[l]:(t.rect||(t.rect=t.view.text.getBoundingClientRect()),t.hasHeights||(Gt(e,t.view,t.rect),t.hasHeights=!0),(o=qt(e,t,r,n)).bogus||(t.cache[l]=o)),{left:o.left,right:o.right,top:i?o.rtop:o.top,bottom:i?o.rbottom:o.bottom}}function _t(e,t,r){for(var n,i,o,l,s,a,u=0;u<e.length;u+=3)if(s=e[u],a=e[u+1],t<s?(i=0,o=1,l="left"):t<a?o=(i=t-s)+1:(u==e.length-3||t==a&&e[u+3]>t)&&(i=(o=a-s)-1,t>=a&&(l="right")),null!=i){if(n=e[u+2],s==a&&r==(n.insertLeft?"left":"right")&&(l=r),"left"==r&&0==i)for(;u&&e[u-2]==e[u-3]&&e[u-1].insertLeft;)n=e[2+(u-=3)],l="left";if("right"==r&&i==a-s)for(;u<e.length-3&&e[u+3]==e[u+4]&&!e[u+5].insertLeft;)n=e[(u+=3)+2],l="right";break}return{node:n,start:i,end:o,collapse:l,coverStart:s,coverEnd:a}}function $t(e,t){var r=ms;if("left"==t)for(var n=0;n<e.length&&(r=e[n]).left==r.right;n++);else for(var i=e.length-1;i>=0&&(r=e[i]).left==r.right;i--);return r}function qt(e,t,r,n){var i,o=_t(t.map,r,n),l=o.node,s=o.start,a=o.end,u=o.collapse;if(3==l.nodeType){for(var c=0;c<4;c++){for(;s&&S(t.line.text.charAt(o.coverStart+s));)--s;for(;o.coverStart+a<o.coverEnd&&S(t.line.text.charAt(o.coverStart+a));)++a;if((i=gl&&vl<9&&0==s&&a==o.coverEnd-o.coverStart?l.parentNode.getBoundingClientRect():$t(Wl(l,s,a).getClientRects(),n)).left||i.right||0==s)break;a=s,s-=1,u="right"}gl&&vl<11&&(i=Zt(e.display.measure,i))}else{s>0&&(u=n="right");var f;i=e.options.lineWrapping&&(f=l.getClientRects()).length>1?f["right"==n?f.length-1:0]:l.getBoundingClientRect()}if(gl&&vl<9&&!s&&(!i||!i.left&&!i.right)){var h=l.parentNode.getClientRects()[0];i=h?{left:h.left,right:h.left+yr(e.display),top:h.top,bottom:h.bottom}:ms}for(var d=i.top-t.rect.top,p=i.bottom-t.rect.top,g=(d+p)/2,v=t.view.measure.heights,m=0;m<v.length-1&&!(g<v[m]);m++);var y=m?v[m-1]:0,b=v[m],w={left:("right"==u?i.right:i.left)-t.rect.left,right:("left"==u?i.left:i.right)-t.rect.left,top:y,bottom:b};return i.left||i.right||(w.bogus=!0),e.options.singleCursorHeightPerLine||(w.rtop=d,w.rbottom=p),w}function Zt(e,t){if(!window.screen||null==screen.logicalXDPI||screen.logicalXDPI==screen.deviceXDPI||!Re(e))return t;var r=screen.logicalXDPI/screen.deviceXDPI,n=screen.logicalYDPI/screen.deviceYDPI;return{left:t.left*r,right:t.right*r,top:t.top*n,bottom:t.bottom*n}}function Qt(e){if(e.measure&&(e.measure.cache={},e.measure.heights=null,e.rest))for(var t=0;t<e.rest.length;t++)e.measure.caches[t]={}}function Jt(e){e.display.externalMeasure=null,t(e.display.lineMeasure);for(var r=0;r<e.display.view.length;r++)Qt(e.display.view[r])}function er(e){Jt(e),e.display.cachedCharWidth=e.display.cachedTextHeight=e.display.cachedPaddingH=null,e.options.lineWrapping||(e.display.maxLineChanged=!0),e.display.lineNumChars=null}function tr(){return bl&&kl?-(document.body.getBoundingClientRect().left-parseInt(getComputedStyle(document.body).marginLeft)):window.pageXOffset||(document.documentElement||document.body).scrollLeft}function rr(){return bl&&kl?-(document.body.getBoundingClientRect().top-parseInt(getComputedStyle(document.body).marginTop)):window.pageYOffset||(document.documentElement||document.body).scrollTop}function nr(e){var t=0;if(e.widgets)for(var r=0;r<e.widgets.length;++r)e.widgets[r].above&&(t+=Ht(e.widgets[r]));return t}function ir(e,t,r,n,i){if(!i){var o=nr(t);r.top+=o,r.bottom+=o}if("line"==n)return r;n||(n="local");var l=ye(t);if("local"==n?l+=Et(e.display):l-=e.display.viewOffset,"page"==n||"window"==n){var s=e.display.lineSpace.getBoundingClientRect();l+=s.top+("window"==n?0:rr());var a=s.left+("window"==n?0:tr());r.left+=a,r.right+=a}return r.top+=l,r.bottom+=l,r}function or(e,t,r){if("div"==r)return t;var n=t.left,i=t.top;if("page"==r)n-=tr(),i-=rr();else if("local"==r||!r){var o=e.display.sizer.getBoundingClientRect();n+=o.left,i+=o.top}var l=e.display.lineSpace.getBoundingClientRect();return{left:n-l.left,top:i-l.top}}function lr(e,t,r,n,i){return n||(n=M(e.doc,t.line)),ir(e,n,Kt(e,n,t.ch,i),r)}function sr(e,t,r,n,i,o){function l(t,l){var s=Yt(e,i,t,l?"right":"left",o);return l?s.left=s.right:s.right=s.left,ir(e,n,s,r)}function s(e,t,r){var n=1==a[t].level;return l(r?e-1:e,n!=r)}n=n||M(e.doc,t.line),i||(i=Xt(e,n));var a=Se(n,e.doc.direction),u=t.ch,c=t.sticky;if(u>=n.text.length?(u=n.text.length,c="before"):u<=0&&(u=0,c="after"),!a)return l("before"==c?u-1:u,"before"==c);var f=Ce(a,u,c),h=$l,d=s(u,f,"before"==c);return null!=h&&(d.other=s(u,h,"before"!=c)),d}function ar(e,t){var r=0;t=U(e.doc,t),e.options.lineWrapping||(r=yr(e.display)*t.ch);var n=M(e.doc,t.line),i=ye(n)+Et(e.display);return{left:r,right:r,top:i,bottom:i+n.height}}function ur(e,t,r,n,i){var o=E(e,t,r);return o.xRel=i,n&&(o.outside=!0),o}function cr(e,t,r){var n=e.doc;if((r+=e.display.viewOffset)<0)return ur(n.first,0,null,!0,-1);var i=D(n,r),o=n.first+n.size-1;if(i>o)return ur(n.first+n.size-1,M(n,o).text.length,null,!0,1);t<0&&(t=0);for(var l=M(n,i);;){var s=pr(e,l,i,t,r),a=ue(l),u=a&&a.find(0,!0);if(!a||!(s.ch>u.from.ch||s.ch==u.from.ch&&s.xRel>0))return s;i=W(l=u.to.line)}}function fr(e,t,r,n){n-=nr(t);var i=t.text.length,o=k(function(t){return Yt(e,r,t-1).bottom<=n},i,0);return i=k(function(t){return Yt(e,r,t).top>n},o,i),{begin:o,end:i}}function hr(e,t,r,n){return r||(r=Xt(e,t)),fr(e,t,r,ir(e,t,Yt(e,r,n),"line").top)}function dr(e,t,r,n){return!(e.bottom<=r)&&(e.top>r||(n?e.left:e.right)>t)}function pr(e,t,r,n,i){i-=ye(t);var o=Xt(e,t),l=nr(t),s=0,a=t.text.length,u=!0,c=Se(t,e.doc.direction);if(c){var f=(e.options.lineWrapping?vr:gr)(e,t,r,o,c,n,i);s=(u=1!=f.level)?f.from:f.to-1,a=u?f.to:f.from-1}var h,d,p=null,g=null,v=k(function(t){var r=Yt(e,o,t);return r.top+=l,r.bottom+=l,!!dr(r,n,i,!1)&&(r.top<=i&&r.left<=n&&(p=t,g=r),!0)},s,a),m=!1;if(g){var y=n-g.left<g.right-n,b=y==u;v=p+(b?0:1),d=b?"after":"before",h=y?g.left:g.right}else{u||v!=a&&v!=s||v++,d=0==v?"after":v==t.text.length?"before":Yt(e,o,v-(u?1:0)).bottom+l<=i==u?"after":"before";var w=sr(e,E(r,v,d),"line",t,o);h=w.left,m=i<w.top||i>=w.bottom}return v=L(t.text,v,1),ur(r,v,d,m,n-h)}function gr(e,t,r,n,i,o,l){var s=k(function(s){var a=i[s],u=1!=a.level;return dr(sr(e,E(r,u?a.to:a.from,u?"before":"after"),"line",t,n),o,l,!0)},0,i.length-1),a=i[s];if(s>0){var u=1!=a.level,c=sr(e,E(r,u?a.from:a.to,u?"after":"before"),"line",t,n);dr(c,o,l,!0)&&c.top>l&&(a=i[s-1])}return a}function vr(e,t,r,n,i,o,l){for(var s=fr(e,t,n,l),a=s.begin,u=s.end,c=null,f=null,h=0;h<i.length;h++){var d=i[h];if(!(d.from>=u||d.to<=a)){var p=Yt(e,n,1!=d.level?Math.min(u,d.to)-1:Math.max(a,d.from)).right,g=p<o?o-p+1e9:p-o;(!c||f>g)&&(c=d,f=g)}}return c||(c=i[i.length-1]),c.from<a&&(c={from:a,to:c.to,level:c.level}),c.to>u&&(c={from:c.from,to:u,level:c.level}),c}function mr(e){if(null!=e.cachedTextHeight)return e.cachedTextHeight;if(null==hs){hs=n("pre");for(var i=0;i<49;++i)hs.appendChild(document.createTextNode("x")),hs.appendChild(n("br"));hs.appendChild(document.createTextNode("x"))}r(e.measure,hs);var o=hs.offsetHeight/50;return o>3&&(e.cachedTextHeight=o),t(e.measure),o||1}function yr(e){if(null!=e.cachedCharWidth)return e.cachedCharWidth;var t=n("span","xxxxxxxxxx"),i=n("pre",[t]);r(e.measure,i);var o=t.getBoundingClientRect(),l=(o.right-o.left)/10;return l>2&&(e.cachedCharWidth=l),l||10}function br(e){for(var t=e.display,r={},n={},i=t.gutters.clientLeft,o=t.gutters.firstChild,l=0;o;o=o.nextSibling,++l)r[e.options.gutters[l]]=o.offsetLeft+o.clientLeft+i,n[e.options.gutters[l]]=o.clientWidth;return{fixedPos:wr(t),gutterTotalWidth:t.gutters.offsetWidth,gutterLeft:r,gutterWidth:n,wrapperWidth:t.wrapper.clientWidth}}function wr(e){return e.scroller.getBoundingClientRect().left-e.sizer.getBoundingClientRect().left}function xr(e){var t=mr(e.display),r=e.options.lineWrapping,n=r&&Math.max(5,e.display.scroller.clientWidth/yr(e.display)-3);return function(i){if(ve(e.doc,i))return 0;var o=0;if(i.widgets)for(var l=0;l<i.widgets.length;l++)i.widgets[l].height&&(o+=i.widgets[l].height);return r?o+(Math.ceil(i.text.length/n)||1)*t:o+t}}function Cr(e){var t=e.doc,r=xr(e);t.iter(function(e){var t=r(e);t!=e.height&&A(e,t)})}function Sr(e,t,r,n){var i=e.display;if(!r&&"true"==Ee(t).getAttribute("cm-not-content"))return null;var o,l,s=i.lineSpace.getBoundingClientRect();try{o=t.clientX-s.left,l=t.clientY-s.top}catch(t){return null}var a,u=cr(e,o,l);if(n&&1==u.xRel&&(a=M(e.doc,u.line).text).length==u.ch){var c=f(a,a.length,e.options.tabSize)-a.length;u=E(u.line,Math.max(0,Math.round((o-It(e.display).left)/yr(e.display))-c))}return u}function Lr(e,t){if(t>=e.display.viewTo)return null;if((t-=e.display.viewFrom)<0)return null;for(var r=e.display.view,n=0;n<r.length;n++)if((t-=r[n].size)<0)return n}function kr(e){e.display.input.showSelection(e.display.input.prepareSelection())}function Tr(e,t){void 0===t&&(t=!0);for(var r=e.doc,n={},i=n.cursors=document.createDocumentFragment(),o=n.selection=document.createDocumentFragment(),l=0;l<r.sel.ranges.length;l++)if(t||l!=r.sel.primIndex){var s=r.sel.ranges[l];if(!(s.from().line>=e.display.viewTo||s.to().line<e.display.viewFrom)){var a=s.empty();(a||e.options.showCursorWhenSelecting)&&Mr(e,s.head,i),a||Or(e,s,o)}}return n}function Mr(e,t,r){var i=sr(e,t,"div",null,null,!e.options.singleCursorHeightPerLine),o=r.appendChild(n("div"," ","CodeMirror-cursor"));if(o.style.left=i.left+"px",o.style.top=i.top+"px",o.style.height=Math.max(0,i.bottom-i.top)*e.options.cursorHeight+"px",i.other){var l=r.appendChild(n("div"," ","CodeMirror-cursor CodeMirror-secondarycursor"));l.style.display="",l.style.left=i.other.left+"px",l.style.top=i.other.top+"px",l.style.height=.85*(i.other.bottom-i.other.top)+"px"}}function Nr(e,t){return e.top-t.top||e.left-t.left}function Or(e,t,r){function i(e,t,r,i){t<0&&(t=0),t=Math.round(t),i=Math.round(i),a.appendChild(n("div",null,"CodeMirror-selected","position: absolute; left: "+e+"px;\n                             top: "+t+"px; width: "+(null==r?f-e:r)+"px;\n                             height: "+(i-t)+"px"))}function o(t,r,n){function o(r,n){return lr(e,E(t,r),"div",u,n)}var l,a,u=M(s,t),h=u.text.length,d=Se(u,s.direction);return xe(d,r||0,null==n?h:n,function(t,s,p,g){var v=o(t,"ltr"==p?"left":"right"),m=o(s-1,"ltr"==p?"right":"left");if("ltr"==p){var y=null==r&&0==t?c:v.left,b=null==n&&s==h?f:m.right;m.top-v.top<=3?i(y,m.top,b-y,m.bottom):(i(y,v.top,null,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top),i(c,m.top,m.right,m.bottom))}else if(t<s){var w=null==r&&0==t?f:v.right,x=null==n&&s==h?c:m.left;if(m.top-v.top<=3)i(x,m.top,w-x,m.bottom);else{var C=c;if(g){var S=hr(e,u,null,t).end;C=o(S-(/\s/.test(u.text.charAt(S-1))?2:1),"left").left}i(C,v.top,w-C,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top);var L=null;d.length,L=o(hr(e,u,null,s).begin,"right").right-x,i(x,m.top,L,m.bottom)}}(!l||Nr(v,l)<0)&&(l=v),Nr(m,l)<0&&(l=m),(!a||Nr(v,a)<0)&&(a=v),Nr(m,a)<0&&(a=m)}),{start:l,end:a}}var l=e.display,s=e.doc,a=document.createDocumentFragment(),u=It(e.display),c=u.left,f=Math.max(l.sizerWidth,Rt(e)-l.sizer.offsetLeft)-u.right,h=t.from(),d=t.to();if(h.line==d.line)o(h.line,h.ch,d.ch);else{var p=M(s,h.line),g=M(s,d.line),v=fe(p)==fe(g),m=o(h.line,h.ch,v?p.text.length+1:null).end,y=o(d.line,v?0:null,d.ch).start;v&&(m.top<y.top-2?(i(m.right,m.top,null,m.bottom),i(c,y.top,y.left,y.bottom)):i(m.right,m.top,y.left-m.right,m.bottom)),m.bottom<y.top&&i(c,m.bottom,null,y.top)}r.appendChild(a)}function Ar(e){if(e.state.focused){var t=e.display;clearInterval(t.blinker);var r=!0;t.cursorDiv.style.visibility="",e.options.cursorBlinkRate>0?t.blinker=setInterval(function(){return t.cursorDiv.style.visibility=(r=!r)?"":"hidden"},e.options.cursorBlinkRate):e.options.cursorBlinkRate<0&&(t.cursorDiv.style.visibility="hidden")}}function Wr(e){e.state.focused||(e.display.input.focus(),Hr(e))}function Dr(e){e.state.delayingBlurEvent=!0,setTimeout(function(){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1,Fr(e))},100)}function Hr(e,t){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1),"nocursor"!=e.options.readOnly&&(e.state.focused||(Te(e,"focus",e,t),e.state.focused=!0,s(e.display.wrapper,"CodeMirror-focused"),e.curOp||e.display.selForContextMenu==e.doc.sel||(e.display.input.reset(),ml&&setTimeout(function(){return e.display.input.reset(!0)},20)),e.display.input.receivedFocus()),Ar(e))}function Fr(e,t){e.state.delayingBlurEvent||(e.state.focused&&(Te(e,"blur",e,t),e.state.focused=!1,Fl(e.display.wrapper,"CodeMirror-focused")),clearInterval(e.display.blinker),setTimeout(function(){e.state.focused||(e.display.shift=!1)},150))}function Er(e){for(var t=e.display,r=t.lineDiv.offsetTop,n=0;n<t.view.length;n++){var i=t.view[n],o=void 0;if(!i.hidden){if(gl&&vl<8){var l=i.node.offsetTop+i.node.offsetHeight;o=l-r,r=l}else{var s=i.node.getBoundingClientRect();o=s.bottom-s.top}var a=i.line.height-o;if(o<2&&(o=mr(t)),(a>.005||a<-.005)&&(A(i.line,o),Pr(i.line),i.rest))for(var u=0;u<i.rest.length;u++)Pr(i.rest[u])}}}function Pr(e){if(e.widgets)for(var t=0;t<e.widgets.length;++t)e.widgets[t].height=e.widgets[t].node.parentNode.offsetHeight}function Ir(e,t,r){var n=r&&null!=r.top?Math.max(0,r.top):e.scroller.scrollTop;n=Math.floor(n-Et(e));var i=r&&null!=r.bottom?r.bottom:n+e.wrapper.clientHeight,o=D(t,n),l=D(t,i);if(r&&r.ensure){var s=r.ensure.from.line,a=r.ensure.to.line;s<o?(o=s,l=D(t,ye(M(t,s))+e.wrapper.clientHeight)):Math.min(a,t.lastLine())>=l&&(o=D(t,ye(M(t,a))-e.wrapper.clientHeight),l=a)}return{from:o,to:Math.max(l,o+1)}}function zr(e){var t=e.display,r=t.view;if(t.alignWidgets||t.gutters.firstChild&&e.options.fixedGutter){for(var n=wr(t)-t.scroller.scrollLeft+e.doc.scrollLeft,i=t.gutters.offsetWidth,o=n+"px",l=0;l<r.length;l++)if(!r[l].hidden){e.options.fixedGutter&&(r[l].gutter&&(r[l].gutter.style.left=o),r[l].gutterBackground&&(r[l].gutterBackground.style.left=o));var s=r[l].alignable;if(s)for(var a=0;a<s.length;a++)s[a].style.left=o}e.options.fixedGutter&&(t.gutters.style.left=n+i+"px")}}function Rr(e){if(!e.options.lineNumbers)return!1;var t=e.doc,r=F(e.options,t.first+t.size-1),i=e.display;if(r.length!=i.lineNumChars){var o=i.measure.appendChild(n("div",[n("div",r)],"CodeMirror-linenumber CodeMirror-gutter-elt")),l=o.firstChild.offsetWidth,s=o.offsetWidth-l;return i.lineGutter.style.width="",i.lineNumInnerWidth=Math.max(l,i.lineGutter.offsetWidth-s)+1,i.lineNumWidth=i.lineNumInnerWidth+s,i.lineNumChars=i.lineNumInnerWidth?r.length:-1,i.lineGutter.style.width=i.lineNumWidth+"px",Wn(e),!0}return!1}function Br(e,t){if(!Me(e,"scrollCursorIntoView")){var r=e.display,i=r.sizer.getBoundingClientRect(),o=null;if(t.top+i.top<0?o=!0:t.bottom+i.top>(window.innerHeight||document.documentElement.clientHeight)&&(o=!1),null!=o&&!Sl){var l=n("div","​",null,"position: absolute;\n                         top: "+(t.top-r.viewOffset-Et(e.display))+"px;\n                         height: "+(t.bottom-t.top+zt(e)+r.barHeight)+"px;\n                         left: "+t.left+"px; width: "+Math.max(2,t.right-t.left)+"px;");e.display.lineSpace.appendChild(l),l.scrollIntoView(o),e.display.lineSpace.removeChild(l)}}}function Gr(e,t,r,n){null==n&&(n=0);var i;e.options.lineWrapping||t!=r||(r="before"==(t=t.ch?E(t.line,"before"==t.sticky?t.ch-1:t.ch,"after"):t).sticky?E(t.line,t.ch+1,"before"):t);for(var o=0;o<5;o++){var l=!1,s=sr(e,t),a=r&&r!=t?sr(e,r):s,u=Vr(e,i={left:Math.min(s.left,a.left),top:Math.min(s.top,a.top)-n,right:Math.max(s.left,a.left),bottom:Math.max(s.bottom,a.bottom)+n}),c=e.doc.scrollTop,f=e.doc.scrollLeft;if(null!=u.scrollTop&&(qr(e,u.scrollTop),Math.abs(e.doc.scrollTop-c)>1&&(l=!0)),null!=u.scrollLeft&&(Qr(e,u.scrollLeft),Math.abs(e.doc.scrollLeft-f)>1&&(l=!0)),!l)break}return i}function Ur(e,t){var r=Vr(e,t);null!=r.scrollTop&&qr(e,r.scrollTop),null!=r.scrollLeft&&Qr(e,r.scrollLeft)}function Vr(e,t){var r=e.display,n=mr(e.display);t.top<0&&(t.top=0);var i=e.curOp&&null!=e.curOp.scrollTop?e.curOp.scrollTop:r.scroller.scrollTop,o=Bt(e),l={};t.bottom-t.top>o&&(t.bottom=t.top+o);var s=e.doc.height+Pt(r),a=t.top<n,u=t.bottom>s-n;if(t.top<i)l.scrollTop=a?0:t.top;else if(t.bottom>i+o){var c=Math.min(t.top,(u?s:t.bottom)-o);c!=i&&(l.scrollTop=c)}var f=e.curOp&&null!=e.curOp.scrollLeft?e.curOp.scrollLeft:r.scroller.scrollLeft,h=Rt(e)-(e.options.fixedGutter?r.gutters.offsetWidth:0),d=t.right-t.left>h;return d&&(t.right=t.left+h),t.left<10?l.scrollLeft=0:t.left<f?l.scrollLeft=Math.max(0,t.left-(d?0:10)):t.right>h+f-3&&(l.scrollLeft=t.right+(d?0:10)-h),l}function Kr(e,t){null!=t&&(_r(e),e.curOp.scrollTop=(null==e.curOp.scrollTop?e.doc.scrollTop:e.curOp.scrollTop)+t)}function jr(e){_r(e);var t=e.getCursor();e.curOp.scrollToPos={from:t,to:t,margin:e.options.cursorScrollMargin}}function Xr(e,t,r){null==t&&null==r||_r(e),null!=t&&(e.curOp.scrollLeft=t),null!=r&&(e.curOp.scrollTop=r)}function Yr(e,t){_r(e),e.curOp.scrollToPos=t}function _r(e){var t=e.curOp.scrollToPos;t&&(e.curOp.scrollToPos=null,$r(e,ar(e,t.from),ar(e,t.to),t.margin))}function $r(e,t,r,n){var i=Vr(e,{left:Math.min(t.left,r.left),top:Math.min(t.top,r.top)-n,right:Math.max(t.right,r.right),bottom:Math.max(t.bottom,r.bottom)+n});Xr(e,i.scrollLeft,i.scrollTop)}function qr(e,t){Math.abs(e.doc.scrollTop-t)<2||(fl||On(e,{top:t}),Zr(e,t,!0),fl&&On(e),Cn(e,100))}function Zr(e,t,r){t=Math.min(e.display.scroller.scrollHeight-e.display.scroller.clientHeight,t),(e.display.scroller.scrollTop!=t||r)&&(e.doc.scrollTop=t,e.display.scrollbars.setScrollTop(t),e.display.scroller.scrollTop!=t&&(e.display.scroller.scrollTop=t))}function Qr(e,t,r,n){t=Math.min(t,e.display.scroller.scrollWidth-e.display.scroller.clientWidth),(r?t==e.doc.scrollLeft:Math.abs(e.doc.scrollLeft-t)<2)&&!n||(e.doc.scrollLeft=t,zr(e),e.display.scroller.scrollLeft!=t&&(e.display.scroller.scrollLeft=t),e.display.scrollbars.setScrollLeft(t))}function Jr(e){var t=e.display,r=t.gutters.offsetWidth,n=Math.round(e.doc.height+Pt(e.display));return{clientHeight:t.scroller.clientHeight,viewHeight:t.wrapper.clientHeight,scrollWidth:t.scroller.scrollWidth,clientWidth:t.scroller.clientWidth,viewWidth:t.wrapper.clientWidth,barLeft:e.options.fixedGutter?r:0,docHeight:n,scrollHeight:n+zt(e)+t.barHeight,nativeBarWidth:t.nativeBarWidth,gutterWidth:r}}function en(e,t){t||(t=Jr(e));var r=e.display.barWidth,n=e.display.barHeight;tn(e,t);for(var i=0;i<4&&r!=e.display.barWidth||n!=e.display.barHeight;i++)r!=e.display.barWidth&&e.options.lineWrapping&&Er(e),tn(e,Jr(e)),r=e.display.barWidth,n=e.display.barHeight}function tn(e,t){var r=e.display,n=r.scrollbars.update(t);r.sizer.style.paddingRight=(r.barWidth=n.right)+"px",r.sizer.style.paddingBottom=(r.barHeight=n.bottom)+"px",r.heightForcer.style.borderBottom=n.bottom+"px solid transparent",n.right&&n.bottom?(r.scrollbarFiller.style.display="block",r.scrollbarFiller.style.height=n.bottom+"px",r.scrollbarFiller.style.width=n.right+"px"):r.scrollbarFiller.style.display="",n.bottom&&e.options.coverGutterNextToScrollbar&&e.options.fixedGutter?(r.gutterFiller.style.display="block",r.gutterFiller.style.height=n.bottom+"px",r.gutterFiller.style.width=t.gutterWidth+"px"):r.gutterFiller.style.display=""}function rn(e){e.display.scrollbars&&(e.display.scrollbars.clear(),e.display.scrollbars.addClass&&Fl(e.display.wrapper,e.display.scrollbars.addClass)),e.display.scrollbars=new ws[e.options.scrollbarStyle](function(t){e.display.wrapper.insertBefore(t,e.display.scrollbarFiller),Ql(t,"mousedown",function(){e.state.focused&&setTimeout(function(){return e.display.input.focus()},0)}),t.setAttribute("cm-not-content","true")},function(t,r){"horizontal"==r?Qr(e,t):qr(e,t)},e),e.display.scrollbars.addClass&&s(e.display.wrapper,e.display.scrollbars.addClass)}function nn(e){e.curOp={cm:e,viewChanged:!1,startHeight:e.doc.height,forceUpdate:!1,updateInput:null,typing:!1,changeObjs:null,cursorActivityHandlers:null,cursorActivityCalled:0,selectionChanged:!1,updateMaxLine:!1,scrollLeft:null,scrollTop:null,scrollToPos:null,focus:!1,id:++xs},vt(e.curOp)}function on(e){yt(e.curOp,function(e){for(var t=0;t<e.ops.length;t++)e.ops[t].cm.curOp=null;ln(e)})}function ln(e){for(var t=e.ops,r=0;r<t.length;r++)sn(t[r]);for(var n=0;n<t.length;n++)an(t[n]);for(var i=0;i<t.length;i++)un(t[i]);for(var o=0;o<t.length;o++)cn(t[o]);for(var l=0;l<t.length;l++)fn(t[l])}function sn(e){var t=e.cm,r=t.display;Ln(t),e.updateMaxLine&&we(t),e.mustUpdate=e.viewChanged||e.forceUpdate||null!=e.scrollTop||e.scrollToPos&&(e.scrollToPos.from.line<r.viewFrom||e.scrollToPos.to.line>=r.viewTo)||r.maxLineChanged&&t.options.lineWrapping,e.update=e.mustUpdate&&new Cs(t,e.mustUpdate&&{top:e.scrollTop,ensure:e.scrollToPos},e.forceUpdate)}function an(e){e.updatedDisplay=e.mustUpdate&&Mn(e.cm,e.update)}function un(e){var t=e.cm,r=t.display;e.updatedDisplay&&Er(t),e.barMeasure=Jr(t),r.maxLineChanged&&!t.options.lineWrapping&&(e.adjustWidthTo=Kt(t,r.maxLine,r.maxLine.text.length).left+3,t.display.sizerWidth=e.adjustWidthTo,e.barMeasure.scrollWidth=Math.max(r.scroller.clientWidth,r.sizer.offsetLeft+e.adjustWidthTo+zt(t)+t.display.barWidth),e.maxScrollLeft=Math.max(0,r.sizer.offsetLeft+e.adjustWidthTo-Rt(t))),(e.updatedDisplay||e.selectionChanged)&&(e.preparedSelection=r.input.prepareSelection())}function cn(e){var t=e.cm;null!=e.adjustWidthTo&&(t.display.sizer.style.minWidth=e.adjustWidthTo+"px",e.maxScrollLeft<t.doc.scrollLeft&&Qr(t,Math.min(t.display.scroller.scrollLeft,e.maxScrollLeft),!0),t.display.maxLineChanged=!1);var r=e.focus&&e.focus==l();e.preparedSelection&&t.display.input.showSelection(e.preparedSelection,r),(e.updatedDisplay||e.startHeight!=t.doc.height)&&en(t,e.barMeasure),e.updatedDisplay&&Dn(t,e.barMeasure),e.selectionChanged&&Ar(t),t.state.focused&&e.updateInput&&t.display.input.reset(e.typing),r&&Wr(e.cm)}function fn(e){var t=e.cm,r=t.display,n=t.doc;e.updatedDisplay&&Nn(t,e.update),null==r.wheelStartX||null==e.scrollTop&&null==e.scrollLeft&&!e.scrollToPos||(r.wheelStartX=r.wheelStartY=null),null!=e.scrollTop&&Zr(t,e.scrollTop,e.forceScroll),null!=e.scrollLeft&&Qr(t,e.scrollLeft,!0,!0),e.scrollToPos&&Br(t,Gr(t,U(n,e.scrollToPos.from),U(n,e.scrollToPos.to),e.scrollToPos.margin));var i=e.maybeHiddenMarkers,o=e.maybeUnhiddenMarkers;if(i)for(var l=0;l<i.length;++l)i[l].lines.length||Te(i[l],"hide");if(o)for(var s=0;s<o.length;++s)o[s].lines.length&&Te(o[s],"unhide");r.wrapper.offsetHeight&&(n.scrollTop=t.display.scroller.scrollTop),e.changeObjs&&Te(t,"changes",t,e.changeObjs),e.update&&e.update.finish()}function hn(e,t){if(e.curOp)return t();nn(e);try{return t()}finally{on(e)}}function dn(e,t){return function(){if(e.curOp)return t.apply(e,arguments);nn(e);try{return t.apply(e,arguments)}finally{on(e)}}}function pn(e){return function(){if(this.curOp)return e.apply(this,arguments);nn(this);try{return e.apply(this,arguments)}finally{on(this)}}}function gn(e){return function(){var t=this.cm;if(!t||t.curOp)return e.apply(this,arguments);nn(t);try{return e.apply(this,arguments)}finally{on(t)}}}function vn(e,t,r,n){null==t&&(t=e.doc.first),null==r&&(r=e.doc.first+e.doc.size),n||(n=0);var i=e.display;if(n&&r<i.viewTo&&(null==i.updateLineNumbers||i.updateLineNumbers>t)&&(i.updateLineNumbers=t),e.curOp.viewChanged=!0,t>=i.viewTo)_l&&pe(e.doc,t)<i.viewTo&&yn(e);else if(r<=i.viewFrom)_l&&ge(e.doc,r+n)>i.viewFrom?yn(e):(i.viewFrom+=n,i.viewTo+=n);else if(t<=i.viewFrom&&r>=i.viewTo)yn(e);else if(t<=i.viewFrom){var o=bn(e,r,r+n,1);o?(i.view=i.view.slice(o.index),i.viewFrom=o.lineN,i.viewTo+=n):yn(e)}else if(r>=i.viewTo){var l=bn(e,t,t,-1);l?(i.view=i.view.slice(0,l.index),i.viewTo=l.lineN):yn(e)}else{var s=bn(e,t,t,-1),a=bn(e,r,r+n,1);s&&a?(i.view=i.view.slice(0,s.index).concat(gt(e,s.lineN,a.lineN)).concat(i.view.slice(a.index)),i.viewTo+=n):yn(e)}var u=i.externalMeasured;u&&(r<u.lineN?u.lineN+=n:t<u.lineN+u.size&&(i.externalMeasured=null))}function mn(e,t,r){e.curOp.viewChanged=!0;var n=e.display,i=e.display.externalMeasured;if(i&&t>=i.lineN&&t<i.lineN+i.size&&(n.externalMeasured=null),!(t<n.viewFrom||t>=n.viewTo)){var o=n.view[Lr(e,t)];if(null!=o.node){var l=o.changes||(o.changes=[]);-1==h(l,r)&&l.push(r)}}}function yn(e){e.display.viewFrom=e.display.viewTo=e.doc.first,e.display.view=[],e.display.viewOffset=0}function bn(e,t,r,n){var i,o=Lr(e,t),l=e.display.view;if(!_l||r==e.doc.first+e.doc.size)return{index:o,lineN:r};for(var s=e.display.viewFrom,a=0;a<o;a++)s+=l[a].size;if(s!=t){if(n>0){if(o==l.length-1)return null;i=s+l[o].size-t,o++}else i=s-t;t+=i,r+=i}for(;pe(e.doc,r)!=r;){if(o==(n<0?0:l.length-1))return null;r+=n*l[o-(n<0?1:0)].size,o+=n}return{index:o,lineN:r}}function wn(e,t,r){var n=e.display;0==n.view.length||t>=n.viewTo||r<=n.viewFrom?(n.view=gt(e,t,r),n.viewFrom=t):(n.viewFrom>t?n.view=gt(e,t,n.viewFrom).concat(n.view):n.viewFrom<t&&(n.view=n.view.slice(Lr(e,t))),n.viewFrom=t,n.viewTo<r?n.view=n.view.concat(gt(e,n.viewTo,r)):n.viewTo>r&&(n.view=n.view.slice(0,Lr(e,r)))),n.viewTo=r}function xn(e){for(var t=e.display.view,r=0,n=0;n<t.length;n++){var i=t[n];i.hidden||i.node&&!i.changes||++r}return r}function Cn(e,t){e.doc.highlightFrontier<e.display.viewTo&&e.state.highlight.set(t,u(Sn,e))}function Sn(e){var t=e.doc;if(!(t.highlightFrontier>=e.display.viewTo)){var r=+new Date+e.options.workTime,n=$e(e,t.highlightFrontier),i=[];t.iter(n.line,Math.min(t.first+t.size,e.display.viewTo+500),function(o){if(n.line>=e.display.viewFrom){var l=o.styles,s=o.text.length>e.options.maxHighlightLength?Ke(t.mode,n.state):null,a=Ye(e,o,n,!0);s&&(n.state=s),o.styles=a.styles;var u=o.styleClasses,c=a.classes;c?o.styleClasses=c:u&&(o.styleClasses=null);for(var f=!l||l.length!=o.styles.length||u!=c&&(!u||!c||u.bgClass!=c.bgClass||u.textClass!=c.textClass),h=0;!f&&h<l.length;++h)f=l[h]!=o.styles[h];f&&i.push(n.line),o.stateAfter=n.save(),n.nextLine()}else o.text.length<=e.options.maxHighlightLength&&qe(e,o.text,n),o.stateAfter=n.line%5==0?n.save():null,n.nextLine();if(+new Date>r)return Cn(e,e.options.workDelay),!0}),t.highlightFrontier=n.line,t.modeFrontier=Math.max(t.modeFrontier,n.line),i.length&&hn(e,function(){for(var t=0;t<i.length;t++)mn(e,i[t],"text")})}}function Ln(e){var t=e.display;!t.scrollbarsClipped&&t.scroller.offsetWidth&&(t.nativeBarWidth=t.scroller.offsetWidth-t.scroller.clientWidth,t.heightForcer.style.height=zt(e)+"px",t.sizer.style.marginBottom=-t.nativeBarWidth+"px",t.sizer.style.borderRightWidth=zt(e)+"px",t.scrollbarsClipped=!0)}function kn(e){if(e.hasFocus())return null;var t=l();if(!t||!o(e.display.lineDiv,t))return null;var r={activeElt:t};if(window.getSelection){var n=window.getSelection();n.anchorNode&&n.extend&&o(e.display.lineDiv,n.anchorNode)&&(r.anchorNode=n.anchorNode,r.anchorOffset=n.anchorOffset,r.focusNode=n.focusNode,r.focusOffset=n.focusOffset)}return r}function Tn(e){if(e&&e.activeElt&&e.activeElt!=l()&&(e.activeElt.focus(),e.anchorNode&&o(document.body,e.anchorNode)&&o(document.body,e.focusNode))){var t=window.getSelection(),r=document.createRange();r.setEnd(e.anchorNode,e.anchorOffset),r.collapse(!1),t.removeAllRanges(),t.addRange(r),t.extend(e.focusNode,e.focusOffset)}}function Mn(e,r){var n=e.display,i=e.doc;if(r.editorIsHidden)return yn(e),!1;if(!r.force&&r.visible.from>=n.viewFrom&&r.visible.to<=n.viewTo&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo)&&n.renderedView==n.view&&0==xn(e))return!1;Rr(e)&&(yn(e),r.dims=br(e));var o=i.first+i.size,l=Math.max(r.visible.from-e.options.viewportMargin,i.first),s=Math.min(o,r.visible.to+e.options.viewportMargin);n.viewFrom<l&&l-n.viewFrom<20&&(l=Math.max(i.first,n.viewFrom)),n.viewTo>s&&n.viewTo-s<20&&(s=Math.min(o,n.viewTo)),_l&&(l=pe(e.doc,l),s=ge(e.doc,s));var a=l!=n.viewFrom||s!=n.viewTo||n.lastWrapHeight!=r.wrapperHeight||n.lastWrapWidth!=r.wrapperWidth;wn(e,l,s),n.viewOffset=ye(M(e.doc,n.viewFrom)),e.display.mover.style.top=n.viewOffset+"px";var u=xn(e);if(!a&&0==u&&!r.force&&n.renderedView==n.view&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo))return!1;var c=kn(e);return u>4&&(n.lineDiv.style.display="none"),An(e,n.updateLineNumbers,r.dims),u>4&&(n.lineDiv.style.display=""),n.renderedView=n.view,Tn(c),t(n.cursorDiv),t(n.selectionDiv),n.gutters.style.height=n.sizer.style.minHeight=0,a&&(n.lastWrapHeight=r.wrapperHeight,n.lastWrapWidth=r.wrapperWidth,Cn(e,400)),n.updateLineNumbers=null,!0}function Nn(e,t){for(var r=t.viewport,n=!0;(n&&e.options.lineWrapping&&t.oldDisplayWidth!=Rt(e)||(r&&null!=r.top&&(r={top:Math.min(e.doc.height+Pt(e.display)-Bt(e),r.top)}),t.visible=Ir(e.display,e.doc,r),!(t.visible.from>=e.display.viewFrom&&t.visible.to<=e.display.viewTo)))&&Mn(e,t);n=!1){Er(e);var i=Jr(e);kr(e),en(e,i),Dn(e,i),t.force=!1}t.signal(e,"update",e),e.display.viewFrom==e.display.reportedViewFrom&&e.display.viewTo==e.display.reportedViewTo||(t.signal(e,"viewportChange",e,e.display.viewFrom,e.display.viewTo),e.display.reportedViewFrom=e.display.viewFrom,e.display.reportedViewTo=e.display.viewTo)}function On(e,t){var r=new Cs(e,t);if(Mn(e,r)){Er(e),Nn(e,r);var n=Jr(e);kr(e),en(e,n),Dn(e,n),r.finish()}}function An(e,r,n){function i(t){var r=t.nextSibling;return ml&&Ml&&e.display.currentWheelTarget==t?t.style.display="none":t.parentNode.removeChild(t),r}for(var o=e.display,l=e.options.lineNumbers,s=o.lineDiv,a=s.firstChild,u=o.view,c=o.viewFrom,f=0;f<u.length;f++){var d=u[f];if(d.hidden);else if(d.node&&d.node.parentNode==s){for(;a!=d.node;)a=i(a);var p=l&&null!=r&&r<=c&&d.lineNumber;d.changes&&(h(d.changes,"gutter")>-1&&(p=!1),xt(e,d,c,n)),p&&(t(d.lineNumber),d.lineNumber.appendChild(document.createTextNode(F(e.options,c)))),a=d.node.nextSibling}else{var g=Ot(e,d,c,n);s.insertBefore(g,a)}c+=d.size}for(;a;)a=i(a)}function Wn(e){var t=e.display.gutters.offsetWidth;e.display.sizer.style.marginLeft=t+"px"}function Dn(e,t){e.display.sizer.style.minHeight=t.docHeight+"px",e.display.heightForcer.style.top=t.docHeight+"px",e.display.gutters.style.height=t.docHeight+e.display.barHeight+zt(e)+"px"}function Hn(e){var r=e.display.gutters,i=e.options.gutters;t(r);for(var o=0;o<i.length;++o){var l=i[o],s=r.appendChild(n("div",null,"CodeMirror-gutter "+l));"CodeMirror-linenumbers"==l&&(e.display.lineGutter=s,s.style.width=(e.display.lineNumWidth||1)+"px")}r.style.display=o?"":"none",Wn(e)}function Fn(e){var t=h(e.gutters,"CodeMirror-linenumbers");-1==t&&e.lineNumbers?e.gutters=e.gutters.concat(["CodeMirror-linenumbers"]):t>-1&&!e.lineNumbers&&(e.gutters=e.gutters.slice(0),e.gutters.splice(t,1))}function En(e){var t=e.wheelDeltaX,r=e.wheelDeltaY;return null==t&&e.detail&&e.axis==e.HORIZONTAL_AXIS&&(t=e.detail),null==r&&e.detail&&e.axis==e.VERTICAL_AXIS?r=e.detail:null==r&&(r=e.wheelDelta),{x:t,y:r}}function Pn(e){var t=En(e);return t.x*=Ls,t.y*=Ls,t}function In(e,t){var r=En(t),n=r.x,i=r.y,o=e.display,l=o.scroller,s=l.scrollWidth>l.clientWidth,a=l.scrollHeight>l.clientHeight;if(n&&s||i&&a){if(i&&Ml&&ml)e:for(var u=t.target,c=o.view;u!=l;u=u.parentNode)for(var f=0;f<c.length;f++)if(c[f].node==u){e.display.currentWheelTarget=u;break e}if(n&&!fl&&!wl&&null!=Ls)return i&&a&&qr(e,Math.max(0,l.scrollTop+i*Ls)),Qr(e,Math.max(0,l.scrollLeft+n*Ls)),(!i||i&&a)&&We(t),void(o.wheelStartX=null);if(i&&null!=Ls){var h=i*Ls,d=e.doc.scrollTop,p=d+o.wrapper.clientHeight;h<0?d=Math.max(0,d+h-50):p=Math.min(e.doc.height,p+h+50),On(e,{top:d,bottom:p})}Ss<20&&(null==o.wheelStartX?(o.wheelStartX=l.scrollLeft,o.wheelStartY=l.scrollTop,o.wheelDX=n,o.wheelDY=i,setTimeout(function(){if(null!=o.wheelStartX){var e=l.scrollLeft-o.wheelStartX,t=l.scrollTop-o.wheelStartY,r=t&&o.wheelDY&&t/o.wheelDY||e&&o.wheelDX&&e/o.wheelDX;o.wheelStartX=o.wheelStartY=null,r&&(Ls=(Ls*Ss+r)/(Ss+1),++Ss)}},200)):(o.wheelDX+=n,o.wheelDY+=i))}}function zn(e,t){var r=e[t];e.sort(function(e,t){return P(e.from(),t.from())}),t=h(e,r);for(var n=1;n<e.length;n++){var i=e[n],o=e[n-1];if(P(o.to(),i.from())>=0){var l=B(o.from(),i.from()),s=R(o.to(),i.to()),a=o.empty()?i.from()==i.head:o.from()==o.head;n<=t&&--t,e.splice(--n,2,new Ts(a?s:l,a?l:s))}}return new ks(e,t)}function Rn(e,t){return new ks([new Ts(e,t||e)],0)}function Bn(e){return e.text?E(e.from.line+e.text.length-1,g(e.text).length+(1==e.text.length?e.from.ch:0)):e.to}function Gn(e,t){if(P(e,t.from)<0)return e;if(P(e,t.to)<=0)return Bn(t);var r=e.line+t.text.length-(t.to.line-t.from.line)-1,n=e.ch;return e.line==t.to.line&&(n+=Bn(t).ch-t.to.ch),E(r,n)}function Un(e,t){for(var r=[],n=0;n<e.sel.ranges.length;n++){var i=e.sel.ranges[n];r.push(new Ts(Gn(i.anchor,t),Gn(i.head,t)))}return zn(r,e.sel.primIndex)}function Vn(e,t,r){return e.line==t.line?E(r.line,e.ch-t.ch+r.ch):E(r.line+(e.line-t.line),e.ch)}function Kn(e,t,r){for(var n=[],i=E(e.first,0),o=i,l=0;l<t.length;l++){var s=t[l],a=Vn(s.from,i,o),u=Vn(Bn(s),i,o);if(i=s.to,o=u,"around"==r){var c=e.sel.ranges[l],f=P(c.head,c.anchor)<0;n[l]=new Ts(f?u:a,f?a:u)}else n[l]=new Ts(a,a)}return new ks(n,e.sel.primIndex)}function jn(e){e.doc.mode=Ue(e.options,e.doc.modeOption),Xn(e)}function Xn(e){e.doc.iter(function(e){e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null)}),e.doc.modeFrontier=e.doc.highlightFrontier=e.doc.first,Cn(e,100),e.state.modeGen++,e.curOp&&vn(e)}function Yn(e,t){return 0==t.from.ch&&0==t.to.ch&&""==g(t.text)&&(!e.cm||e.cm.options.wholeLineUpdateBefore)}function _n(e,t,r,n){function i(e){return r?r[e]:null}function o(e,r,i){it(e,r,i,n),bt(e,"change",e,t)}function l(e,t){for(var r=[],o=e;o<t;++o)r.push(new fs(u[o],i(o),n));return r}var s=t.from,a=t.to,u=t.text,c=M(e,s.line),f=M(e,a.line),h=g(u),d=i(u.length-1),p=a.line-s.line;if(t.full)e.insert(0,l(0,u.length)),e.remove(u.length,e.size-u.length);else if(Yn(e,t)){var v=l(0,u.length-1);o(f,f.text,d),p&&e.remove(s.line,p),v.length&&e.insert(s.line,v)}else if(c==f)if(1==u.length)o(c,c.text.slice(0,s.ch)+h+c.text.slice(a.ch),d);else{var m=l(1,u.length-1);m.push(new fs(h+c.text.slice(a.ch),d,n)),o(c,c.text.slice(0,s.ch)+u[0],i(0)),e.insert(s.line+1,m)}else if(1==u.length)o(c,c.text.slice(0,s.ch)+u[0]+f.text.slice(a.ch),i(0)),e.remove(s.line+1,p);else{o(c,c.text.slice(0,s.ch)+u[0],i(0)),o(f,h+f.text.slice(a.ch),d);var y=l(1,u.length-1);p>1&&e.remove(s.line+1,p-1),e.insert(s.line+1,y)}bt(e,"change",e,t)}function $n(e,t,r){function n(e,i,o){if(e.linked)for(var l=0;l<e.linked.length;++l){var s=e.linked[l];if(s.doc!=i){var a=o&&s.sharedHist;r&&!a||(t(s.doc,a),n(s.doc,e,a))}}}n(e,null,!0)}function qn(e,t){if(t.cm)throw new Error("This document is already in use.");e.doc=t,t.cm=e,Cr(e),jn(e),Zn(e),e.options.lineWrapping||we(e),e.options.mode=t.modeOption,vn(e)}function Zn(e){("rtl"==e.doc.direction?s:Fl)(e.display.lineDiv,"CodeMirror-rtl")}function Qn(e){hn(e,function(){Zn(e),vn(e)})}function Jn(e){this.done=[],this.undone=[],this.undoDepth=1/0,this.lastModTime=this.lastSelTime=0,this.lastOp=this.lastSelOp=null,this.lastOrigin=this.lastSelOrigin=null,this.generation=this.maxGeneration=e||1}function ei(e,t){var r={from:z(t.from),to:Bn(t),text:N(e,t.from,t.to)};return si(e,r,t.from.line,t.to.line+1),$n(e,function(e){return si(e,r,t.from.line,t.to.line+1)},!0),r}function ti(e){for(;e.length&&g(e).ranges;)e.pop()}function ri(e,t){return t?(ti(e.done),g(e.done)):e.done.length&&!g(e.done).ranges?g(e.done):e.done.length>1&&!e.done[e.done.length-2].ranges?(e.done.pop(),g(e.done)):void 0}function ni(e,t,r,n){var i=e.history;i.undone.length=0;var o,l,s=+new Date;if((i.lastOp==n||i.lastOrigin==t.origin&&t.origin&&("+"==t.origin.charAt(0)&&e.cm&&i.lastModTime>s-e.cm.options.historyEventDelay||"*"==t.origin.charAt(0)))&&(o=ri(i,i.lastOp==n)))l=g(o.changes),0==P(t.from,t.to)&&0==P(t.from,l.to)?l.to=Bn(t):o.changes.push(ei(e,t));else{var a=g(i.done);for(a&&a.ranges||li(e.sel,i.done),o={changes:[ei(e,t)],generation:i.generation},i.done.push(o);i.done.length>i.undoDepth;)i.done.shift(),i.done[0].ranges||i.done.shift()}i.done.push(r),i.generation=++i.maxGeneration,i.lastModTime=i.lastSelTime=s,i.lastOp=i.lastSelOp=n,i.lastOrigin=i.lastSelOrigin=t.origin,l||Te(e,"historyAdded")}function ii(e,t,r,n){var i=t.charAt(0);return"*"==i||"+"==i&&r.ranges.length==n.ranges.length&&r.somethingSelected()==n.somethingSelected()&&new Date-e.history.lastSelTime<=(e.cm?e.cm.options.historyEventDelay:500)}function oi(e,t,r,n){var i=e.history,o=n&&n.origin;r==i.lastSelOp||o&&i.lastSelOrigin==o&&(i.lastModTime==i.lastSelTime&&i.lastOrigin==o||ii(e,o,g(i.done),t))?i.done[i.done.length-1]=t:li(t,i.done),i.lastSelTime=+new Date,i.lastSelOrigin=o,i.lastSelOp=r,n&&!1!==n.clearRedo&&ti(i.undone)}function li(e,t){var r=g(t);r&&r.ranges&&r.equals(e)||t.push(e)}function si(e,t,r,n){var i=t["spans_"+e.id],o=0;e.iter(Math.max(e.first,r),Math.min(e.first+e.size,n),function(r){r.markedSpans&&((i||(i=t["spans_"+e.id]={}))[o]=r.markedSpans),++o})}function ai(e){if(!e)return null;for(var t,r=0;r<e.length;++r)e[r].marker.explicitlyCleared?t||(t=e.slice(0,r)):t&&t.push(e[r]);return t?t.length?t:null:e}function ui(e,t){var r=t["spans_"+e.id];if(!r)return null;for(var n=[],i=0;i<t.text.length;++i)n.push(ai(r[i]));return n}function ci(e,t){var r=ui(e,t),n=J(e,t);if(!r)return n;if(!n)return r;for(var i=0;i<r.length;++i){var o=r[i],l=n[i];if(o&&l)e:for(var s=0;s<l.length;++s){for(var a=l[s],u=0;u<o.length;++u)if(o[u].marker==a.marker)continue e;o.push(a)}else l&&(r[i]=l)}return r}function fi(e,t,r){for(var n=[],i=0;i<e.length;++i){var o=e[i];if(o.ranges)n.push(r?ks.prototype.deepCopy.call(o):o);else{var l=o.changes,s=[];n.push({changes:s});for(var a=0;a<l.length;++a){var u=l[a],c=void 0;if(s.push({from:u.from,to:u.to,text:u.text}),t)for(var f in u)(c=f.match(/^spans_(\d+)$/))&&h(t,Number(c[1]))>-1&&(g(s)[f]=u[f],delete u[f])}}}return n}function hi(e,t,r,n){if(n){var i=e.anchor;if(r){var o=P(t,i)<0;o!=P(r,i)<0?(i=t,t=r):o!=P(t,r)<0&&(t=r)}return new Ts(i,t)}return new Ts(r||t,t)}function di(e,t,r,n,i){null==i&&(i=e.cm&&(e.cm.display.shift||e.extend)),bi(e,new ks([hi(e.sel.primary(),t,r,i)],0),n)}function pi(e,t,r){for(var n=[],i=e.cm&&(e.cm.display.shift||e.extend),o=0;o<e.sel.ranges.length;o++)n[o]=hi(e.sel.ranges[o],t[o],null,i);bi(e,zn(n,e.sel.primIndex),r)}function gi(e,t,r,n){var i=e.sel.ranges.slice(0);i[t]=r,bi(e,zn(i,e.sel.primIndex),n)}function vi(e,t,r,n){bi(e,Rn(t,r),n)}function mi(e,t,r){var n={ranges:t.ranges,update:function(t){var r=this;this.ranges=[];for(var n=0;n<t.length;n++)r.ranges[n]=new Ts(U(e,t[n].anchor),U(e,t[n].head))},origin:r&&r.origin};return Te(e,"beforeSelectionChange",e,n),e.cm&&Te(e.cm,"beforeSelectionChange",e.cm,n),n.ranges!=t.ranges?zn(n.ranges,n.ranges.length-1):t}function yi(e,t,r){var n=e.history.done,i=g(n);i&&i.ranges?(n[n.length-1]=t,wi(e,t,r)):bi(e,t,r)}function bi(e,t,r){wi(e,t,r),oi(e,e.sel,e.cm?e.cm.curOp.id:NaN,r)}function wi(e,t,r){(Oe(e,"beforeSelectionChange")||e.cm&&Oe(e.cm,"beforeSelectionChange"))&&(t=mi(e,t,r)),xi(e,Si(e,t,r&&r.bias||(P(t.primary().head,e.sel.primary().head)<0?-1:1),!0)),r&&!1===r.scroll||!e.cm||jr(e.cm)}function xi(e,t){t.equals(e.sel)||(e.sel=t,e.cm&&(e.cm.curOp.updateInput=e.cm.curOp.selectionChanged=!0,Ne(e.cm)),bt(e,"cursorActivity",e))}function Ci(e){xi(e,Si(e,e.sel,null,!1))}function Si(e,t,r,n){for(var i,o=0;o<t.ranges.length;o++){var l=t.ranges[o],s=t.ranges.length==e.sel.ranges.length&&e.sel.ranges[o],a=ki(e,l.anchor,s&&s.anchor,r,n),u=ki(e,l.head,s&&s.head,r,n);(i||a!=l.anchor||u!=l.head)&&(i||(i=t.ranges.slice(0,o)),i[o]=new Ts(a,u))}return i?zn(i,t.primIndex):t}function Li(e,t,r,n,i){var o=M(e,t.line);if(o.markedSpans)for(var l=0;l<o.markedSpans.length;++l){var s=o.markedSpans[l],a=s.marker;if((null==s.from||(a.inclusiveLeft?s.from<=t.ch:s.from<t.ch))&&(null==s.to||(a.inclusiveRight?s.to>=t.ch:s.to>t.ch))){if(i&&(Te(a,"beforeCursorEnter"),a.explicitlyCleared)){if(o.markedSpans){--l;continue}break}if(!a.atomic)continue;if(r){var u=a.find(n<0?1:-1),c=void 0;if((n<0?a.inclusiveRight:a.inclusiveLeft)&&(u=Ti(e,u,-n,u&&u.line==t.line?o:null)),u&&u.line==t.line&&(c=P(u,r))&&(n<0?c<0:c>0))return Li(e,u,t,n,i)}var f=a.find(n<0?-1:1);return(n<0?a.inclusiveLeft:a.inclusiveRight)&&(f=Ti(e,f,n,f.line==t.line?o:null)),f?Li(e,f,t,n,i):null}}return t}function ki(e,t,r,n,i){var o=n||1,l=Li(e,t,r,o,i)||!i&&Li(e,t,r,o,!0)||Li(e,t,r,-o,i)||!i&&Li(e,t,r,-o,!0);return l||(e.cantEdit=!0,E(e.first,0))}function Ti(e,t,r,n){return r<0&&0==t.ch?t.line>e.first?U(e,E(t.line-1)):null:r>0&&t.ch==(n||M(e,t.line)).text.length?t.line<e.first+e.size-1?E(t.line+1,0):null:new E(t.line,t.ch+r)}function Mi(e){e.setSelection(E(e.firstLine(),0),E(e.lastLine()),Gl)}function Ni(e,t,r){var n={canceled:!1,from:t.from,to:t.to,text:t.text,origin:t.origin,cancel:function(){return n.canceled=!0}};return r&&(n.update=function(t,r,i,o){t&&(n.from=U(e,t)),r&&(n.to=U(e,r)),i&&(n.text=i),void 0!==o&&(n.origin=o)}),Te(e,"beforeChange",e,n),e.cm&&Te(e.cm,"beforeChange",e.cm,n),n.canceled?null:{from:n.from,to:n.to,text:n.text,origin:n.origin}}function Oi(e,t,r){if(e.cm){if(!e.cm.curOp)return dn(e.cm,Oi)(e,t,r);if(e.cm.state.suppressEdits)return}if(!(Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"))||(t=Ni(e,t,!0))){var n=Yl&&!r&&te(e,t.from,t.to);if(n)for(var i=n.length-1;i>=0;--i)Ai(e,{from:n[i].from,to:n[i].to,text:i?[""]:t.text,origin:t.origin});else Ai(e,t)}}function Ai(e,t){if(1!=t.text.length||""!=t.text[0]||0!=P(t.from,t.to)){var r=Un(e,t);ni(e,t,r,e.cm?e.cm.curOp.id:NaN),Hi(e,t,r,J(e,t));var n=[];$n(e,function(e,r){r||-1!=h(n,e.history)||(zi(e.history,t),n.push(e.history)),Hi(e,t,null,J(e,t))})}}function Wi(e,t,r){if(!e.cm||!e.cm.state.suppressEdits||r){for(var n,i=e.history,o=e.sel,l="undo"==t?i.done:i.undone,s="undo"==t?i.undone:i.done,a=0;a<l.length&&(n=l[a],r?!n.ranges||n.equals(e.sel):n.ranges);a++);if(a!=l.length){for(i.lastOrigin=i.lastSelOrigin=null;(n=l.pop()).ranges;){if(li(n,s),r&&!n.equals(e.sel))return void bi(e,n,{clearRedo:!1});o=n}var u=[];li(o,s),s.push({changes:u,generation:i.generation}),i.generation=n.generation||++i.maxGeneration;for(var c=Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"),f=n.changes.length-1;f>=0;--f){var d=function(r){var i=n.changes[r];if(i.origin=t,c&&!Ni(e,i,!1))return l.length=0,{};u.push(ei(e,i));var o=r?Un(e,i):g(l);Hi(e,i,o,ci(e,i)),!r&&e.cm&&e.cm.scrollIntoView({from:i.from,to:Bn(i)});var s=[];$n(e,function(e,t){t||-1!=h(s,e.history)||(zi(e.history,i),s.push(e.history)),Hi(e,i,null,ci(e,i))})}(f);if(d)return d.v}}}}function Di(e,t){if(0!=t&&(e.first+=t,e.sel=new ks(v(e.sel.ranges,function(e){return new Ts(E(e.anchor.line+t,e.anchor.ch),E(e.head.line+t,e.head.ch))}),e.sel.primIndex),e.cm)){vn(e.cm,e.first,e.first-t,t);for(var r=e.cm.display,n=r.viewFrom;n<r.viewTo;n++)mn(e.cm,n,"gutter")}}function Hi(e,t,r,n){if(e.cm&&!e.cm.curOp)return dn(e.cm,Hi)(e,t,r,n);if(t.to.line<e.first)Di(e,t.text.length-1-(t.to.line-t.from.line));else if(!(t.from.line>e.lastLine())){if(t.from.line<e.first){var i=t.text.length-1-(e.first-t.from.line);Di(e,i),t={from:E(e.first,0),to:E(t.to.line+i,t.to.ch),text:[g(t.text)],origin:t.origin}}var o=e.lastLine();t.to.line>o&&(t={from:t.from,to:E(o,M(e,o).text.length),text:[t.text[0]],origin:t.origin}),t.removed=N(e,t.from,t.to),r||(r=Un(e,t)),e.cm?Fi(e.cm,t,n):_n(e,t,n),wi(e,r,Gl)}}function Fi(e,t,r){var n=e.doc,i=e.display,o=t.from,l=t.to,s=!1,a=o.line;e.options.lineWrapping||(a=W(fe(M(n,o.line))),n.iter(a,l.line+1,function(e){if(e==i.maxLine)return s=!0,!0})),n.sel.contains(t.from,t.to)>-1&&Ne(e),_n(n,t,r,xr(e)),e.options.lineWrapping||(n.iter(a,o.line+t.text.length,function(e){var t=be(e);t>i.maxLineLength&&(i.maxLine=e,i.maxLineLength=t,i.maxLineChanged=!0,s=!1)}),s&&(e.curOp.updateMaxLine=!0)),nt(n,o.line),Cn(e,400);var u=t.text.length-(l.line-o.line)-1;t.full?vn(e):o.line!=l.line||1!=t.text.length||Yn(e.doc,t)?vn(e,o.line,l.line+1,u):mn(e,o.line,"text");var c=Oe(e,"changes"),f=Oe(e,"change");if(f||c){var h={from:o,to:l,text:t.text,removed:t.removed,origin:t.origin};f&&bt(e,"change",e,h),c&&(e.curOp.changeObjs||(e.curOp.changeObjs=[])).push(h)}e.display.selForContextMenu=null}function Ei(e,t,r,n,i){if(n||(n=r),P(n,r)<0){var o;r=(o=[n,r])[0],n=o[1]}"string"==typeof t&&(t=e.splitLines(t)),Oi(e,{from:r,to:n,text:t,origin:i})}function Pi(e,t,r,n){r<e.line?e.line+=n:t<e.line&&(e.line=t,e.ch=0)}function Ii(e,t,r,n){for(var i=0;i<e.length;++i){var o=e[i],l=!0;if(o.ranges){o.copied||((o=e[i]=o.deepCopy()).copied=!0);for(var s=0;s<o.ranges.length;s++)Pi(o.ranges[s].anchor,t,r,n),Pi(o.ranges[s].head,t,r,n)}else{for(var a=0;a<o.changes.length;++a){var u=o.changes[a];if(r<u.from.line)u.from=E(u.from.line+n,u.from.ch),u.to=E(u.to.line+n,u.to.ch);else if(t<=u.to.line){l=!1;break}}l||(e.splice(0,i+1),i=0)}}}function zi(e,t){var r=t.from.line,n=t.to.line,i=t.text.length-(n-r)-1;Ii(e.done,r,n,i),Ii(e.undone,r,n,i)}function Ri(e,t,r,n){var i=t,o=t;return"number"==typeof t?o=M(e,G(e,t)):i=W(t),null==i?null:(n(o,i)&&e.cm&&mn(e.cm,i,r),o)}function Bi(e){var t=this;this.lines=e,this.parent=null;for(var r=0,n=0;n<e.length;++n)e[n].parent=t,r+=e[n].height;this.height=r}function Gi(e){var t=this;this.children=e;for(var r=0,n=0,i=0;i<e.length;++i){var o=e[i];r+=o.chunkSize(),n+=o.height,o.parent=t}this.size=r,this.height=n,this.parent=null}function Ui(e,t,r){ye(t)<(e.curOp&&e.curOp.scrollTop||e.doc.scrollTop)&&Kr(e,r)}function Vi(e,t,r,n){var i=new Ms(e,r,n),o=e.cm;return o&&i.noHScroll&&(o.display.alignWidgets=!0),Ri(e,t,"widget",function(t){var r=t.widgets||(t.widgets=[]);if(null==i.insertAt?r.push(i):r.splice(Math.min(r.length-1,Math.max(0,i.insertAt)),0,i),i.line=t,o&&!ve(e,t)){var n=ye(t)<e.scrollTop;A(t,t.height+Ht(i)),n&&Kr(o,i.height),o.curOp.forceUpdate=!0}return!0}),bt(o,"lineWidgetAdded",o,i,"number"==typeof t?t:W(t)),i}function Ki(e,t,r,n,o){if(n&&n.shared)return ji(e,t,r,n,o);if(e.cm&&!e.cm.curOp)return dn(e.cm,Ki)(e,t,r,n,o);var l=new Os(e,o),s=P(t,r);if(n&&c(n,l,!1),s>0||0==s&&!1!==l.clearWhenEmpty)return l;if(l.replacedWith&&(l.collapsed=!0,l.widgetNode=i("span",[l.replacedWith],"CodeMirror-widget"),n.handleMouseEvents||l.widgetNode.setAttribute("cm-ignore-events","true"),n.insertLeft&&(l.widgetNode.insertLeft=!0)),l.collapsed){if(ce(e,t.line,t,r,l)||t.line!=r.line&&ce(e,r.line,t,r,l))throw new Error("Inserting collapsed marker partially overlapping an existing one");X()}l.addToHistory&&ni(e,{from:t,to:r,origin:"markText"},e.sel,NaN);var a,u=t.line,f=e.cm;if(e.iter(u,r.line+1,function(e){f&&l.collapsed&&!f.options.lineWrapping&&fe(e)==f.display.maxLine&&(a=!0),l.collapsed&&u!=t.line&&A(e,0),q(e,new Y(l,u==t.line?t.ch:null,u==r.line?r.ch:null)),++u}),l.collapsed&&e.iter(t.line,r.line+1,function(t){ve(e,t)&&A(t,0)}),l.clearOnEnter&&Ql(l,"beforeCursorEnter",function(){return l.clear()}),l.readOnly&&(j(),(e.history.done.length||e.history.undone.length)&&e.clearHistory()),l.collapsed&&(l.id=++Ns,l.atomic=!0),f){if(a&&(f.curOp.updateMaxLine=!0),l.collapsed)vn(f,t.line,r.line+1);else if(l.className||l.title||l.startStyle||l.endStyle||l.css)for(var h=t.line;h<=r.line;h++)mn(f,h,"text");l.atomic&&Ci(f.doc),bt(f,"markerAdded",f,l)}return l}function ji(e,t,r,n,i){(n=c(n)).shared=!1;var o=[Ki(e,t,r,n,i)],l=o[0],s=n.widgetNode;return $n(e,function(e){s&&(n.widgetNode=s.cloneNode(!0)),o.push(Ki(e,U(e,t),U(e,r),n,i));for(var a=0;a<e.linked.length;++a)if(e.linked[a].isParent)return;l=g(o)}),new As(o,l)}function Xi(e){return e.findMarks(E(e.first,0),e.clipPos(E(e.lastLine())),function(e){return e.parent})}function Yi(e,t){for(var r=0;r<t.length;r++){var n=t[r],i=n.find(),o=e.clipPos(i.from),l=e.clipPos(i.to);if(P(o,l)){var s=Ki(e,o,l,n.primary,n.primary.type);n.markers.push(s),s.parent=n}}}function _i(e){for(var t=0;t<e.length;t++)!function(t){var r=e[t],n=[r.primary.doc];$n(r.primary.doc,function(e){return n.push(e)});for(var i=0;i<r.markers.length;i++){var o=r.markers[i];-1==h(n,o.doc)&&(o.parent=null,r.markers.splice(i--,1))}}(t)}function $i(e){var t=this;if(Qi(t),!Me(t,e)&&!Ft(t.display,e)){We(e),gl&&(Hs=+new Date);var r=Sr(t,e,!0),n=e.dataTransfer.files;if(r&&!t.isReadOnly())if(n&&n.length&&window.FileReader&&window.File)for(var i=n.length,o=Array(i),l=0,s=0;s<i;++s)!function(e,n){if(!t.options.allowDropFileTypes||-1!=h(t.options.allowDropFileTypes,e.type)){var s=new FileReader;s.onload=dn(t,function(){var e=s.result;if(/[\x00-\x08\x0e-\x1f]{2}/.test(e)&&(e=""),o[n]=e,++l==i){var a={from:r=U(t.doc,r),to:r,text:t.doc.splitLines(o.join(t.doc.lineSeparator())),origin:"paste"};Oi(t.doc,a),yi(t.doc,Rn(r,Bn(a)))}}),s.readAsText(e)}}(n[s],s);else{if(t.state.draggingText&&t.doc.sel.contains(r)>-1)return t.state.draggingText(e),void setTimeout(function(){return t.display.input.focus()},20);try{var a=e.dataTransfer.getData("Text");if(a){var u;if(t.state.draggingText&&!t.state.draggingText.copy&&(u=t.listSelections()),wi(t.doc,Rn(r,r)),u)for(var c=0;c<u.length;++c)Ei(t.doc,"",u[c].anchor,u[c].head,"drag");t.replaceSelection(a,"around","paste"),t.display.input.focus()}}catch(e){}}}}function qi(e,t){if(gl&&(!e.state.draggingText||+new Date-Hs<100))Fe(t);else if(!Me(e,t)&&!Ft(e.display,t)&&(t.dataTransfer.setData("Text",e.getSelection()),t.dataTransfer.effectAllowed="copyMove",t.dataTransfer.setDragImage&&!xl)){var r=n("img",null,null,"position: fixed; left: 0; top: 0;");r.src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",wl&&(r.width=r.height=1,e.display.wrapper.appendChild(r),r._top=r.offsetTop),t.dataTransfer.setDragImage(r,0,0),wl&&r.parentNode.removeChild(r)}}function Zi(e,t){var i=Sr(e,t);if(i){var o=document.createDocumentFragment();Mr(e,i,o),e.display.dragCursor||(e.display.dragCursor=n("div",null,"CodeMirror-cursors CodeMirror-dragcursors"),e.display.lineSpace.insertBefore(e.display.dragCursor,e.display.cursorDiv)),r(e.display.dragCursor,o)}}function Qi(e){e.display.dragCursor&&(e.display.lineSpace.removeChild(e.display.dragCursor),e.display.dragCursor=null)}function Ji(e){if(document.getElementsByClassName)for(var t=document.getElementsByClassName("CodeMirror"),r=0;r<t.length;r++){var n=t[r].CodeMirror;n&&e(n)}}function eo(){Fs||(to(),Fs=!0)}function to(){var e;Ql(window,"resize",function(){null==e&&(e=setTimeout(function(){e=null,Ji(ro)},100))}),Ql(window,"blur",function(){return Ji(Fr)})}function ro(e){var t=e.display;t.lastWrapHeight==t.wrapper.clientHeight&&t.lastWrapWidth==t.wrapper.clientWidth||(t.cachedCharWidth=t.cachedTextHeight=t.cachedPaddingH=null,t.scrollbarsClipped=!1,e.setSize())}function no(e){var t=e.split(/-(?!$)/);e=t[t.length-1];for(var r,n,i,o,l=0;l<t.length-1;l++){var s=t[l];if(/^(cmd|meta|m)$/i.test(s))o=!0;else if(/^a(lt)?$/i.test(s))r=!0;else if(/^(c|ctrl|control)$/i.test(s))n=!0;else{if(!/^s(hift)?$/i.test(s))throw new Error("Unrecognized modifier name: "+s);i=!0}}return r&&(e="Alt-"+e),n&&(e="Ctrl-"+e),o&&(e="Cmd-"+e),i&&(e="Shift-"+e),e}function io(e){var t={};for(var r in e)if(e.hasOwnProperty(r)){var n=e[r];if(/^(name|fallthrough|(de|at)tach)$/.test(r))continue;if("..."==n){delete e[r];continue}for(var i=v(r.split(" "),no),o=0;o<i.length;o++){var l=void 0,s=void 0;o==i.length-1?(s=i.join(" "),l=n):(s=i.slice(0,o+1).join(" "),l="...");var a=t[s];if(a){if(a!=l)throw new Error("Inconsistent bindings for "+s)}else t[s]=l}delete e[r]}for(var u in t)e[u]=t[u];return e}function oo(e,t,r,n){var i=(t=uo(t)).call?t.call(e,n):t[e];if(!1===i)return"nothing";if("..."===i)return"multi";if(null!=i&&r(i))return"handled";if(t.fallthrough){if("[object Array]"!=Object.prototype.toString.call(t.fallthrough))return oo(e,t.fallthrough,r,n);for(var o=0;o<t.fallthrough.length;o++){var l=oo(e,t.fallthrough[o],r,n);if(l)return l}}}function lo(e){var t="string"==typeof e?e:Es[e.keyCode];return"Ctrl"==t||"Alt"==t||"Shift"==t||"Mod"==t}function so(e,t,r){var n=e;return t.altKey&&"Alt"!=n&&(e="Alt-"+e),(Dl?t.metaKey:t.ctrlKey)&&"Ctrl"!=n&&(e="Ctrl-"+e),(Dl?t.ctrlKey:t.metaKey)&&"Cmd"!=n&&(e="Cmd-"+e),!r&&t.shiftKey&&"Shift"!=n&&(e="Shift-"+e),e}function ao(e,t){if(wl&&34==e.keyCode&&e.char)return!1;var r=Es[e.keyCode];return null!=r&&!e.altGraphKey&&so(r,e,t)}function uo(e){return"string"==typeof e?Rs[e]:e}function co(e,t){for(var r=e.doc.sel.ranges,n=[],i=0;i<r.length;i++){for(var o=t(r[i]);n.length&&P(o.from,g(n).to)<=0;){var l=n.pop();if(P(l.from,o.from)<0){o.from=l.from;break}}n.push(o)}hn(e,function(){for(var t=n.length-1;t>=0;t--)Ei(e.doc,"",n[t].from,n[t].to,"+delete");jr(e)})}function fo(e,t,r){var n=L(e.text,t+r,r);return n<0||n>e.text.length?null:n}function ho(e,t,r){var n=fo(e,t.ch,r);return null==n?null:new E(t.line,n,r<0?"after":"before")}function po(e,t,r,n,i){if(e){var o=Se(r,t.doc.direction);if(o){var l,s=i<0?g(o):o[0],a=i<0==(1==s.level)?"after":"before";if(s.level>0){var u=Xt(t,r);l=i<0?r.text.length-1:0;var c=Yt(t,u,l).top;l=k(function(e){return Yt(t,u,e).top==c},i<0==(1==s.level)?s.from:s.to-1,l),"before"==a&&(l=fo(r,l,1))}else l=i<0?s.to:s.from;return new E(n,l,a)}}return new E(n,i<0?r.text.length:0,i<0?"before":"after")}function go(e,t,r,n){var i=Se(t,e.doc.direction);if(!i)return ho(t,r,n);r.ch>=t.text.length?(r.ch=t.text.length,r.sticky="before"):r.ch<=0&&(r.ch=0,r.sticky="after");var o=Ce(i,r.ch,r.sticky),l=i[o];if("ltr"==e.doc.direction&&l.level%2==0&&(n>0?l.to>r.ch:l.from<r.ch))return ho(t,r,n);var s,a=function(e,r){return fo(t,e instanceof E?e.ch:e,r)},u=function(r){return e.options.lineWrapping?(s=s||Xt(e,t),hr(e,t,s,r)):{begin:0,end:t.text.length}},c=u("before"==r.sticky?a(r,-1):r.ch);if("rtl"==e.doc.direction||1==l.level){var f=1==l.level==n<0,h=a(r,f?1:-1);if(null!=h&&(f?h<=l.to&&h<=c.end:h>=l.from&&h>=c.begin)){var d=f?"before":"after";return new E(r.line,h,d)}}var p=function(e,t,n){for(var o=function(e,t){return t?new E(r.line,a(e,1),"before"):new E(r.line,e,"after")};e>=0&&e<i.length;e+=t){var l=i[e],s=t>0==(1!=l.level),u=s?n.begin:a(n.end,-1);if(l.from<=u&&u<l.to)return o(u,s);if(u=s?l.from:a(l.to,-1),n.begin<=u&&u<n.end)return o(u,s)}},g=p(o+n,n,c);if(g)return g;var v=n>0?c.end:a(c.begin,-1);return null==v||n>0&&v==t.text.length||!(g=p(n>0?0:i.length-1,n,u(v)))?null:g}function vo(e,t){var r=M(e.doc,t),n=fe(r);return n!=r&&(t=W(n)),po(!0,e,n,t,1)}function mo(e,t){var r=M(e.doc,t),n=he(r);return n!=r&&(t=W(n)),po(!0,e,r,t,-1)}function yo(e,t){var r=vo(e,t.line),n=M(e.doc,r.line),i=Se(n,e.doc.direction);if(!i||0==i[0].level){var o=Math.max(0,n.text.search(/\S/)),l=t.line==r.line&&t.ch<=o&&t.ch;return E(r.line,l?0:o,r.sticky)}return r}function bo(e,t,r){if("string"==typeof t&&!(t=Bs[t]))return!1;e.display.input.ensurePolled();var n=e.display.shift,i=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),r&&(e.display.shift=!1),i=t(e)!=Bl}finally{e.display.shift=n,e.state.suppressEdits=!1}return i}function wo(e,t,r){for(var n=0;n<e.state.keyMaps.length;n++){var i=oo(t,e.state.keyMaps[n],r,e);if(i)return i}return e.options.extraKeys&&oo(t,e.options.extraKeys,r,e)||oo(t,e.options.keyMap,r,e)}function xo(e,t,r,n){var i=e.state.keySeq;if(i){if(lo(t))return"handled";Gs.set(50,function(){e.state.keySeq==i&&(e.state.keySeq=null,e.display.input.reset())}),t=i+" "+t}var o=wo(e,t,n);return"multi"==o&&(e.state.keySeq=t),"handled"==o&&bt(e,"keyHandled",e,t,r),"handled"!=o&&"multi"!=o||(We(r),Ar(e)),i&&!o&&/\'$/.test(t)?(We(r),!0):!!o}function Co(e,t){var r=ao(t,!0);return!!r&&(t.shiftKey&&!e.state.keySeq?xo(e,"Shift-"+r,t,function(t){return bo(e,t,!0)})||xo(e,r,t,function(t){if("string"==typeof t?/^go[A-Z]/.test(t):t.motion)return bo(e,t)}):xo(e,r,t,function(t){return bo(e,t)}))}function So(e,t,r){return xo(e,"'"+r+"'",t,function(t){return bo(e,t,!0)})}function Lo(e){var t=this;if(t.curOp.focus=l(),!Me(t,e)){gl&&vl<11&&27==e.keyCode&&(e.returnValue=!1);var r=e.keyCode;t.display.shift=16==r||e.shiftKey;var n=Co(t,e);wl&&(Us=n?r:null,!n&&88==r&&!rs&&(Ml?e.metaKey:e.ctrlKey)&&t.replaceSelection("",null,"cut")),18!=r||/\bCodeMirror-crosshair\b/.test(t.display.lineDiv.className)||ko(t)}}function ko(e){function t(e){18!=e.keyCode&&e.altKey||(Fl(r,"CodeMirror-crosshair"),ke(document,"keyup",t),ke(document,"mouseover",t))}var r=e.display.lineDiv;s(r,"CodeMirror-crosshair"),Ql(document,"keyup",t),Ql(document,"mouseover",t)}function To(e){16==e.keyCode&&(this.doc.sel.shift=!1),Me(this,e)}function Mo(e){var t=this;if(!(Ft(t.display,e)||Me(t,e)||e.ctrlKey&&!e.altKey||Ml&&e.metaKey)){var r=e.keyCode,n=e.charCode;if(wl&&r==Us)return Us=null,void We(e);if(!wl||e.which&&!(e.which<10)||!Co(t,e)){var i=String.fromCharCode(null==n?r:n);"\b"!=i&&(So(t,e,i)||t.display.input.onKeyPress(e))}}}function No(e,t){var r=+new Date;return js&&js.compare(r,e,t)?(Ks=js=null,"triple"):Ks&&Ks.compare(r,e,t)?(js=new Vs(r,e,t),Ks=null,"double"):(Ks=new Vs(r,e,t),js=null,"single")}function Oo(e){var t=this,r=t.display;if(!(Me(t,e)||r.activeTouch&&r.input.supportsTouch()))if(r.input.ensurePolled(),r.shift=e.shiftKey,Ft(r,e))ml||(r.scroller.draggable=!1,setTimeout(function(){return r.scroller.draggable=!0},100));else if(!zo(t,e)){var n=Sr(t,e),i=Pe(e),o=n?No(n,i):"single";window.focus(),1==i&&t.state.selectingText&&t.state.selectingText(e),n&&Ao(t,i,n,o,e)||(1==i?n?Do(t,n,o,e):Ee(e)==r.scroller&&We(e):2==i?(n&&di(t.doc,n),setTimeout(function(){return r.input.focus()},20)):3==i&&(Hl?Ro(t,e):Dr(t)))}}function Ao(e,t,r,n,i){var o="Click";return"double"==n?o="Double"+o:"triple"==n&&(o="Triple"+o),o=(1==t?"Left":2==t?"Middle":"Right")+o,xo(e,so(o,i),i,function(t){if("string"==typeof t&&(t=Bs[t]),!t)return!1;var n=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),n=t(e,r)!=Bl}finally{e.state.suppressEdits=!1}return n})}function Wo(e,t,r){var n=e.getOption("configureMouse"),i=n?n(e,t,r):{};if(null==i.unit){var o=Nl?r.shiftKey&&r.metaKey:r.altKey;i.unit=o?"rectangle":"single"==t?"char":"double"==t?"word":"line"}return(null==i.extend||e.doc.extend)&&(i.extend=e.doc.extend||r.shiftKey),null==i.addNew&&(i.addNew=Ml?r.metaKey:r.ctrlKey),null==i.moveOnDrag&&(i.moveOnDrag=!(Ml?r.altKey:r.ctrlKey)),i}function Do(e,t,r,n){gl?setTimeout(u(Wr,e),0):e.curOp.focus=l();var i,o=Wo(e,r,n),s=e.doc.sel;e.options.dragDrop&&Jl&&!e.isReadOnly()&&"single"==r&&(i=s.contains(t))>-1&&(P((i=s.ranges[i]).from(),t)<0||t.xRel>0)&&(P(i.to(),t)>0||t.xRel<0)?Ho(e,n,t,o):Eo(e,n,t,o)}function Ho(e,t,r,n){var i=e.display,o=!1,l=dn(e,function(t){ml&&(i.scroller.draggable=!1),e.state.draggingText=!1,ke(document,"mouseup",l),ke(document,"mousemove",s),ke(i.scroller,"dragstart",a),ke(i.scroller,"drop",l),o||(We(t),n.addNew||di(e.doc,r,null,null,n.extend),ml||gl&&9==vl?setTimeout(function(){document.body.focus(),i.input.focus()},20):i.input.focus())}),s=function(e){o=o||Math.abs(t.clientX-e.clientX)+Math.abs(t.clientY-e.clientY)>=10},a=function(){return o=!0};ml&&(i.scroller.draggable=!0),e.state.draggingText=l,l.copy=!n.moveOnDrag,i.scroller.dragDrop&&i.scroller.dragDrop(),Ql(document,"mouseup",l),Ql(document,"mousemove",s),Ql(i.scroller,"dragstart",a),Ql(i.scroller,"drop",l),Dr(e),setTimeout(function(){return i.input.focus()},20)}function Fo(e,t,r){if("char"==r)return new Ts(t,t);if("word"==r)return e.findWordAt(t);if("line"==r)return new Ts(E(t.line,0),U(e.doc,E(t.line+1,0)));var n=r(e,t);return new Ts(n.from,n.to)}function Eo(e,t,r,n){function i(t){if(0!=P(m,t))if(m=t,"rectangle"==n.unit){for(var i=[],o=e.options.tabSize,l=f(M(u,r.line).text,r.ch,o),s=f(M(u,t.line).text,t.ch,o),a=Math.min(l,s),g=Math.max(l,s),v=Math.min(r.line,t.line),y=Math.min(e.lastLine(),Math.max(r.line,t.line));v<=y;v++){var b=M(u,v).text,w=d(b,a,o);a==g?i.push(new Ts(E(v,w),E(v,w))):b.length>w&&i.push(new Ts(E(v,w),E(v,d(b,g,o))))}i.length||i.push(new Ts(r,r)),bi(u,zn(p.ranges.slice(0,h).concat(i),h),{origin:"*mouse",scroll:!1}),e.scrollIntoView(t)}else{var x,C=c,S=Fo(e,t,n.unit),L=C.anchor;P(S.anchor,L)>0?(x=S.head,L=B(C.from(),S.anchor)):(x=S.anchor,L=R(C.to(),S.head));var k=p.ranges.slice(0);k[h]=Po(e,new Ts(U(u,L),x)),bi(u,zn(k,h),Ul)}}function o(t){var r=++b,s=Sr(e,t,!0,"rectangle"==n.unit);if(s)if(0!=P(s,m)){e.curOp.focus=l(),i(s);var c=Ir(a,u);(s.line>=c.to||s.line<c.from)&&setTimeout(dn(e,function(){b==r&&o(t)}),150)}else{var f=t.clientY<y.top?-20:t.clientY>y.bottom?20:0;f&&setTimeout(dn(e,function(){b==r&&(a.scroller.scrollTop+=f,o(t))}),50)}}function s(t){e.state.selectingText=!1,b=1/0,We(t),a.input.focus(),ke(document,"mousemove",w),ke(document,"mouseup",x),u.history.lastSelOrigin=null}var a=e.display,u=e.doc;We(t);var c,h,p=u.sel,g=p.ranges;if(n.addNew&&!n.extend?(h=u.sel.contains(r),c=h>-1?g[h]:new Ts(r,r)):(c=u.sel.primary(),h=u.sel.primIndex),"rectangle"==n.unit)n.addNew||(c=new Ts(r,r)),r=Sr(e,t,!0,!0),h=-1;else{var v=Fo(e,r,n.unit);c=n.extend?hi(c,v.anchor,v.head,n.extend):v}n.addNew?-1==h?(h=g.length,bi(u,zn(g.concat([c]),h),{scroll:!1,origin:"*mouse"})):g.length>1&&g[h].empty()&&"char"==n.unit&&!n.extend?(bi(u,zn(g.slice(0,h).concat(g.slice(h+1)),0),{scroll:!1,origin:"*mouse"}),p=u.sel):gi(u,h,c,Ul):(h=0,bi(u,new ks([c],0),Ul),p=u.sel);var m=r,y=a.wrapper.getBoundingClientRect(),b=0,w=dn(e,function(e){Pe(e)?o(e):s(e)}),x=dn(e,s);e.state.selectingText=x,Ql(document,"mousemove",w),Ql(document,"mouseup",x)}function Po(e,t){var r=t.anchor,n=t.head,i=M(e.doc,r.line);if(0==P(r,n)&&r.sticky==n.sticky)return t;var o=Se(i);if(!o)return t;var l=Ce(o,r.ch,r.sticky),s=o[l];if(s.from!=r.ch&&s.to!=r.ch)return t;var a=l+(s.from==r.ch==(1!=s.level)?0:1);if(0==a||a==o.length)return t;var u;if(n.line!=r.line)u=(n.line-r.line)*("ltr"==e.doc.direction?1:-1)>0;else{var c=Ce(o,n.ch,n.sticky),f=c-l||(n.ch-r.ch)*(1==s.level?-1:1);u=c==a-1||c==a?f<0:f>0}var h=o[a+(u?-1:0)],d=u==(1==h.level),p=d?h.from:h.to,g=d?"after":"before";return r.ch==p&&r.sticky==g?t:new Ts(new E(r.line,p,g),n)}function Io(e,t,r,n){var i,o;if(t.touches)i=t.touches[0].clientX,o=t.touches[0].clientY;else try{i=t.clientX,o=t.clientY}catch(t){return!1}if(i>=Math.floor(e.display.gutters.getBoundingClientRect().right))return!1;n&&We(t);var l=e.display,s=l.lineDiv.getBoundingClientRect();if(o>s.bottom||!Oe(e,r))return He(t);o-=s.top-l.viewOffset;for(var a=0;a<e.options.gutters.length;++a){var u=l.gutters.childNodes[a];if(u&&u.getBoundingClientRect().right>=i)return Te(e,r,e,D(e.doc,o),e.options.gutters[a],t),He(t)}}function zo(e,t){return Io(e,t,"gutterClick",!0)}function Ro(e,t){Ft(e.display,t)||Bo(e,t)||Me(e,t,"contextmenu")||e.display.input.onContextMenu(t)}function Bo(e,t){return!!Oe(e,"gutterContextMenu")&&Io(e,t,"gutterContextMenu",!1)}function Go(e){e.display.wrapper.className=e.display.wrapper.className.replace(/\s*cm-s-\S+/g,"")+e.options.theme.replace(/(^|\s)\s*/g," cm-s-"),er(e)}function Uo(e){Hn(e),vn(e),zr(e)}function Vo(e,t,r){if(!t!=!(r&&r!=Xs)){var n=e.display.dragFunctions,i=t?Ql:ke;i(e.display.scroller,"dragstart",n.start),i(e.display.scroller,"dragenter",n.enter),i(e.display.scroller,"dragover",n.over),i(e.display.scroller,"dragleave",n.leave),i(e.display.scroller,"drop",n.drop)}}function Ko(e){e.options.lineWrapping?(s(e.display.wrapper,"CodeMirror-wrap"),e.display.sizer.style.minWidth="",e.display.sizerWidth=null):(Fl(e.display.wrapper,"CodeMirror-wrap"),we(e)),Cr(e),vn(e),er(e),setTimeout(function(){return en(e)},100)}function jo(e,t){var r=this;if(!(this instanceof jo))return new jo(e,t);this.options=t=t?c(t):{},c(Ys,t,!1),Fn(t);var n=t.value;"string"==typeof n&&(n=new Ds(n,t.mode,null,t.lineSeparator,t.direction)),this.doc=n;var i=new jo.inputStyles[t.inputStyle](this),o=this.display=new T(e,n,i);o.wrapper.CodeMirror=this,Hn(this),Go(this),t.lineWrapping&&(this.display.wrapper.className+=" CodeMirror-wrap"),rn(this),this.state={keyMaps:[],overlays:[],modeGen:0,overwrite:!1,delayingBlurEvent:!1,focused:!1,suppressEdits:!1,pasteIncoming:!1,cutIncoming:!1,selectingText:!1,draggingText:!1,highlight:new Pl,keySeq:null,specialChars:null},t.autofocus&&!Tl&&o.input.focus(),gl&&vl<11&&setTimeout(function(){return r.display.input.reset(!0)},20),Xo(this),eo(),nn(this),this.curOp.forceUpdate=!0,qn(this,n),t.autofocus&&!Tl||this.hasFocus()?setTimeout(u(Hr,this),20):Fr(this);for(var l in _s)_s.hasOwnProperty(l)&&_s[l](r,t[l],Xs);Rr(this),t.finishInit&&t.finishInit(this);for(var s=0;s<$s.length;++s)$s[s](r);on(this),ml&&t.lineWrapping&&"optimizelegibility"==getComputedStyle(o.lineDiv).textRendering&&(o.lineDiv.style.textRendering="auto")}function Xo(e){function t(){i.activeTouch&&(o=setTimeout(function(){return i.activeTouch=null},1e3),(l=i.activeTouch).end=+new Date)}function r(e){if(1!=e.touches.length)return!1;var t=e.touches[0];return t.radiusX<=1&&t.radiusY<=1}function n(e,t){if(null==t.left)return!0;var r=t.left-e.left,n=t.top-e.top;return r*r+n*n>400}var i=e.display;Ql(i.scroller,"mousedown",dn(e,Oo)),gl&&vl<11?Ql(i.scroller,"dblclick",dn(e,function(t){if(!Me(e,t)){var r=Sr(e,t);if(r&&!zo(e,t)&&!Ft(e.display,t)){We(t);var n=e.findWordAt(r);di(e.doc,n.anchor,n.head)}}})):Ql(i.scroller,"dblclick",function(t){return Me(e,t)||We(t)}),Hl||Ql(i.scroller,"contextmenu",function(t){return Ro(e,t)});var o,l={end:0};Ql(i.scroller,"touchstart",function(t){if(!Me(e,t)&&!r(t)&&!zo(e,t)){i.input.ensurePolled(),clearTimeout(o);var n=+new Date;i.activeTouch={start:n,moved:!1,prev:n-l.end<=300?l:null},1==t.touches.length&&(i.activeTouch.left=t.touches[0].pageX,i.activeTouch.top=t.touches[0].pageY)}}),Ql(i.scroller,"touchmove",function(){i.activeTouch&&(i.activeTouch.moved=!0)}),Ql(i.scroller,"touchend",function(r){var o=i.activeTouch;if(o&&!Ft(i,r)&&null!=o.left&&!o.moved&&new Date-o.start<300){var l,s=e.coordsChar(i.activeTouch,"page");l=!o.prev||n(o,o.prev)?new Ts(s,s):!o.prev.prev||n(o,o.prev.prev)?e.findWordAt(s):new Ts(E(s.line,0),U(e.doc,E(s.line+1,0))),e.setSelection(l.anchor,l.head),e.focus(),We(r)}t()}),Ql(i.scroller,"touchcancel",t),Ql(i.scroller,"scroll",function(){i.scroller.clientHeight&&(qr(e,i.scroller.scrollTop),Qr(e,i.scroller.scrollLeft,!0),Te(e,"scroll",e))}),Ql(i.scroller,"mousewheel",function(t){return In(e,t)}),Ql(i.scroller,"DOMMouseScroll",function(t){return In(e,t)}),Ql(i.wrapper,"scroll",function(){return i.wrapper.scrollTop=i.wrapper.scrollLeft=0}),i.dragFunctions={enter:function(t){Me(e,t)||Fe(t)},over:function(t){Me(e,t)||(Zi(e,t),Fe(t))},start:function(t){return qi(e,t)},drop:dn(e,$i),leave:function(t){Me(e,t)||Qi(e)}};var s=i.input.getField();Ql(s,"keyup",function(t){return To.call(e,t)}),Ql(s,"keydown",dn(e,Lo)),Ql(s,"keypress",dn(e,Mo)),Ql(s,"focus",function(t){return Hr(e,t)}),Ql(s,"blur",function(t){return Fr(e,t)})}function Yo(e,t,r,n){var i,o=e.doc;null==r&&(r="add"),"smart"==r&&(o.mode.indent?i=$e(e,t).state:r="prev");var l=e.options.tabSize,s=M(o,t),a=f(s.text,null,l);s.stateAfter&&(s.stateAfter=null);var u,c=s.text.match(/^\s*/)[0];if(n||/\S/.test(s.text)){if("smart"==r&&((u=o.mode.indent(i,s.text.slice(c.length),s.text))==Bl||u>150)){if(!n)return;r="prev"}}else u=0,r="not";"prev"==r?u=t>o.first?f(M(o,t-1).text,null,l):0:"add"==r?u=a+e.options.indentUnit:"subtract"==r?u=a-e.options.indentUnit:"number"==typeof r&&(u=a+r),u=Math.max(0,u);var h="",d=0;if(e.options.indentWithTabs)for(var g=Math.floor(u/l);g;--g)d+=l,h+="\t";if(d<u&&(h+=p(u-d)),h!=c)return Ei(o,h,E(t,0),E(t,c.length),"+input"),s.stateAfter=null,!0;for(var v=0;v<o.sel.ranges.length;v++){var m=o.sel.ranges[v];if(m.head.line==t&&m.head.ch<c.length){var y=E(t,c.length);gi(o,v,new Ts(y,y));break}}}function _o(e){qs=e}function $o(e,t,r,n,i){var o=e.doc;e.display.shift=!1,n||(n=o.sel);var l=e.state.pasteIncoming||"paste"==i,s=es(t),a=null;if(l&&n.ranges.length>1)if(qs&&qs.text.join("\n")==t){if(n.ranges.length%qs.text.length==0){a=[];for(var u=0;u<qs.text.length;u++)a.push(o.splitLines(qs.text[u]))}}else s.length==n.ranges.length&&e.options.pasteLinesPerSelection&&(a=v(s,function(e){return[e]}));for(var c,f=n.ranges.length-1;f>=0;f--){var h=n.ranges[f],d=h.from(),p=h.to();h.empty()&&(r&&r>0?d=E(d.line,d.ch-r):e.state.overwrite&&!l?p=E(p.line,Math.min(M(o,p.line).text.length,p.ch+g(s).length)):qs&&qs.lineWise&&qs.text.join("\n")==t&&(d=p=E(d.line,0))),c=e.curOp.updateInput;var m={from:d,to:p,text:a?a[f%a.length]:s,origin:i||(l?"paste":e.state.cutIncoming?"cut":"+input")};Oi(e.doc,m),bt(e,"inputRead",e,m)}t&&!l&&Zo(e,t),jr(e),e.curOp.updateInput=c,e.curOp.typing=!0,e.state.pasteIncoming=e.state.cutIncoming=!1}function qo(e,t){var r=e.clipboardData&&e.clipboardData.getData("Text");if(r)return e.preventDefault(),t.isReadOnly()||t.options.disableInput||hn(t,function(){return $o(t,r,0,null,"paste")}),!0}function Zo(e,t){if(e.options.electricChars&&e.options.smartIndent)for(var r=e.doc.sel,n=r.ranges.length-1;n>=0;n--){var i=r.ranges[n];if(!(i.head.ch>100||n&&r.ranges[n-1].head.line==i.head.line)){var o=e.getModeAt(i.head),l=!1;if(o.electricChars){for(var s=0;s<o.electricChars.length;s++)if(t.indexOf(o.electricChars.charAt(s))>-1){l=Yo(e,i.head.line,"smart");break}}else o.electricInput&&o.electricInput.test(M(e.doc,i.head.line).text.slice(0,i.head.ch))&&(l=Yo(e,i.head.line,"smart"));l&&bt(e,"electricInput",e,i.head.line)}}}function Qo(e){for(var t=[],r=[],n=0;n<e.doc.sel.ranges.length;n++){var i=e.doc.sel.ranges[n].head.line,o={anchor:E(i,0),head:E(i+1,0)};r.push(o),t.push(e.getRange(o.anchor,o.head))}return{text:t,ranges:r}}function Jo(e,t){e.setAttribute("autocorrect","off"),e.setAttribute("autocapitalize","off"),e.setAttribute("spellcheck",!!t)}function el(){var e=n("textarea",null,null,"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none"),t=n("div",[e],null,"overflow: hidden; position: relative; width: 3px; height: 0px;");return ml?e.style.width="1000px":e.setAttribute("wrap","off"),Ll&&(e.style.border="1px solid black"),Jo(e),t}function tl(e,t,r,n,i){function o(){var n=t.line+r;return!(n<e.first||n>=e.first+e.size)&&(t=new E(n,t.ch,t.sticky),u=M(e,n))}function l(n){var l;if(null==(l=i?go(e.cm,u,t,r):ho(u,t,r))){if(n||!o())return!1;t=po(i,e.cm,u,t.line,r)}else t=l;return!0}var s=t,a=r,u=M(e,t.line);if("char"==n)l();else if("column"==n)l(!0);else if("word"==n||"group"==n)for(var c=null,f="group"==n,h=e.cm&&e.cm.getHelper(t,"wordChars"),d=!0;!(r<0)||l(!d);d=!1){var p=u.text.charAt(t.ch)||"\n",g=x(p,h)?"w":f&&"\n"==p?"n":!f||/\s/.test(p)?null:"p";if(!f||d||g||(g="s"),c&&c!=g){r<0&&(r=1,l(),t.sticky="after");break}if(g&&(c=g),r>0&&!l(!d))break}var v=ki(e,t,s,a,!0);return I(s,v)&&(v.hitSide=!0),v}function rl(e,t,r,n){var i,o=e.doc,l=t.left;if("page"==n){var s=Math.min(e.display.wrapper.clientHeight,window.innerHeight||document.documentElement.clientHeight),a=Math.max(s-.5*mr(e.display),3);i=(r>0?t.bottom:t.top)+r*a}else"line"==n&&(i=r>0?t.bottom+3:t.top-3);for(var u;(u=cr(e,l,i)).outside;){if(r<0?i<=0:i>=o.height){u.hitSide=!0;break}i+=5*r}return u}function nl(e,t){var r=jt(e,t.line);if(!r||r.hidden)return null;var n=M(e.doc,t.line),i=Ut(r,n,t.line),o=Se(n,e.doc.direction),l="left";o&&(l=Ce(o,t.ch)%2?"right":"left");var s=_t(i.map,t.ch,l);return s.offset="right"==s.collapse?s.end:s.start,s}function il(e){for(var t=e;t;t=t.parentNode)if(/CodeMirror-gutter-wrapper/.test(t.className))return!0;return!1}function ol(e,t){return t&&(e.bad=!0),e}function ll(e,t,r,n,i){function o(e){return function(t){return t.id==e}}function l(){c&&(u+=f,c=!1)}function s(e){e&&(l(),u+=e)}function a(t){if(1==t.nodeType){var r=t.getAttribute("cm-text");if(null!=r)return void s(r||t.textContent.replace(/\u200b/g,""));var u,h=t.getAttribute("cm-marker");if(h){var d=e.findMarks(E(n,0),E(i+1,0),o(+h));return void(d.length&&(u=d[0].find(0))&&s(N(e.doc,u.from,u.to).join(f)))}if("false"==t.getAttribute("contenteditable"))return;var p=/^(pre|div|p)$/i.test(t.nodeName);p&&l();for(var g=0;g<t.childNodes.length;g++)a(t.childNodes[g]);p&&(c=!0)}else 3==t.nodeType&&s(t.nodeValue)}for(var u="",c=!1,f=e.doc.lineSeparator();a(t),t!=r;)t=t.nextSibling;return u}function sl(e,t,r){var n;if(t==e.display.lineDiv){if(!(n=e.display.lineDiv.childNodes[r]))return ol(e.clipPos(E(e.display.viewTo-1)),!0);t=null,r=0}else for(n=t;;n=n.parentNode){if(!n||n==e.display.lineDiv)return null;if(n.parentNode&&n.parentNode==e.display.lineDiv)break}for(var i=0;i<e.display.view.length;i++){var o=e.display.view[i];if(o.node==n)return al(o,t,r)}}function al(e,t,r){function n(t,r,n){for(var i=-1;i<(f?f.length:0);i++)for(var o=i<0?c.map:f[i],l=0;l<o.length;l+=3){var s=o[l+2];if(s==t||s==r){var a=W(i<0?e.line:e.rest[i]),u=o[l]+n;return(n<0||s!=t)&&(u=o[l+(n?1:0)]),E(a,u)}}}var i=e.text.firstChild,l=!1;if(!t||!o(i,t))return ol(E(W(e.line),0),!0);if(t==i&&(l=!0,t=i.childNodes[r],r=0,!t)){var s=e.rest?g(e.rest):e.line;return ol(E(W(s),s.text.length),l)}var a=3==t.nodeType?t:null,u=t;for(a||1!=t.childNodes.length||3!=t.firstChild.nodeType||(a=t.firstChild,r&&(r=a.nodeValue.length));u.parentNode!=i;)u=u.parentNode;var c=e.measure,f=c.maps,h=n(a,u,r);if(h)return ol(h,l);for(var d=u.nextSibling,p=a?a.nodeValue.length-r:0;d;d=d.nextSibling){if(h=n(d,d.firstChild,0))return ol(E(h.line,h.ch-p),l);p+=d.textContent.length}for(var v=u.previousSibling,m=r;v;v=v.previousSibling){if(h=n(v,v.firstChild,-1))return ol(E(h.line,h.ch+m),l);m+=v.textContent.length}}var ul=navigator.userAgent,cl=navigator.platform,fl=/gecko\/\d/i.test(ul),hl=/MSIE \d/.test(ul),dl=/Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(ul),pl=/Edge\/(\d+)/.exec(ul),gl=hl||dl||pl,vl=gl&&(hl?document.documentMode||6:+(pl||dl)[1]),ml=!pl&&/WebKit\//.test(ul),yl=ml&&/Qt\/\d+\.\d+/.test(ul),bl=!pl&&/Chrome\//.test(ul),wl=/Opera\//.test(ul),xl=/Apple Computer/.test(navigator.vendor),Cl=/Mac OS X 1\d\D([8-9]|\d\d)\D/.test(ul),Sl=/PhantomJS/.test(ul),Ll=!pl&&/AppleWebKit/.test(ul)&&/Mobile\/\w+/.test(ul),kl=/Android/.test(ul),Tl=Ll||kl||/webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(ul),Ml=Ll||/Mac/.test(cl),Nl=/\bCrOS\b/.test(ul),Ol=/win/i.test(cl),Al=wl&&ul.match(/Version\/(\d*\.\d*)/);Al&&(Al=Number(Al[1])),Al&&Al>=15&&(wl=!1,ml=!0);var Wl,Dl=Ml&&(yl||wl&&(null==Al||Al<12.11)),Hl=fl||gl&&vl>=9,Fl=function(t,r){var n=t.className,i=e(r).exec(n);if(i){var o=n.slice(i.index+i[0].length);t.className=n.slice(0,i.index)+(o?i[1]+o:"")}};Wl=document.createRange?function(e,t,r,n){var i=document.createRange();return i.setEnd(n||e,r),i.setStart(e,t),i}:function(e,t,r){var n=document.body.createTextRange();try{n.moveToElementText(e.parentNode)}catch(e){return n}return n.collapse(!0),n.moveEnd("character",r),n.moveStart("character",t),n};var El=function(e){e.select()};Ll?El=function(e){e.selectionStart=0,e.selectionEnd=e.value.length}:gl&&(El=function(e){try{e.select()}catch(e){}});var Pl=function(){this.id=null};Pl.prototype.set=function(e,t){clearTimeout(this.id),this.id=setTimeout(t,e)};var Il,zl,Rl=30,Bl={toString:function(){return"CodeMirror.Pass"}},Gl={scroll:!1},Ul={origin:"*mouse"},Vl={origin:"+move"},Kl=[""],jl=/[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/,Xl=/[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/,Yl=!1,_l=!1,$l=null,ql=function(){function e(e){return e<=247?r.charAt(e):1424<=e&&e<=1524?"R":1536<=e&&e<=1785?n.charAt(e-1536):1774<=e&&e<=2220?"r":8192<=e&&e<=8203?"w":8204==e?"b":"L"}function t(e,t,r){this.level=e,this.from=t,this.to=r}var r="bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN",n="nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111",i=/[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/,o=/[stwN]/,l=/[LRr]/,s=/[Lb1n]/,a=/[1n]/;return function(r,n){var u="ltr"==n?"L":"R";if(0==r.length||"ltr"==n&&!i.test(r))return!1;for(var c=r.length,f=[],h=0;h<c;++h)f.push(e(r.charCodeAt(h)));for(var d=0,p=u;d<c;++d){var v=f[d];"m"==v?f[d]=p:p=v}for(var m=0,y=u;m<c;++m){var b=f[m];"1"==b&&"r"==y?f[m]="n":l.test(b)&&(y=b,"r"==b&&(f[m]="R"))}for(var w=1,x=f[0];w<c-1;++w){var C=f[w];"+"==C&&"1"==x&&"1"==f[w+1]?f[w]="1":","!=C||x!=f[w+1]||"1"!=x&&"n"!=x||(f[w]=x),x=C}for(var S=0;S<c;++S){var L=f[S];if(","==L)f[S]="N";else if("%"==L){var k=void 0;for(k=S+1;k<c&&"%"==f[k];++k);for(var T=S&&"!"==f[S-1]||k<c&&"1"==f[k]?"1":"N",M=S;M<k;++M)f[M]=T;S=k-1}}for(var N=0,O=u;N<c;++N){var A=f[N];"L"==O&&"1"==A?f[N]="L":l.test(A)&&(O=A)}for(var W=0;W<c;++W)if(o.test(f[W])){var D=void 0;for(D=W+1;D<c&&o.test(f[D]);++D);for(var H="L"==(W?f[W-1]:u),F=H==("L"==(D<c?f[D]:u))?H?"L":"R":u,E=W;E<D;++E)f[E]=F;W=D-1}for(var P,I=[],z=0;z<c;)if(s.test(f[z])){var R=z;for(++z;z<c&&s.test(f[z]);++z);I.push(new t(0,R,z))}else{var B=z,G=I.length;for(++z;z<c&&"L"!=f[z];++z);for(var U=B;U<z;)if(a.test(f[U])){B<U&&I.splice(G,0,new t(1,B,U));var V=U;for(++U;U<z&&a.test(f[U]);++U);I.splice(G,0,new t(2,V,U)),B=U}else++U;B<z&&I.splice(G,0,new t(1,B,z))}return 1==I[0].level&&(P=r.match(/^\s+/))&&(I[0].from=P[0].length,I.unshift(new t(0,0,P[0].length))),1==g(I).level&&(P=r.match(/\s+$/))&&(g(I).to-=P[0].length,I.push(new t(0,c-P[0].length,c))),"rtl"==n?I.reverse():I}}(),Zl=[],Ql=function(e,t,r){if(e.addEventListener)e.addEventListener(t,r,!1);else if(e.attachEvent)e.attachEvent("on"+t,r);else{var n=e._handlers||(e._handlers={});n[t]=(n[t]||Zl).concat(r)}},Jl=function(){if(gl&&vl<9)return!1;var e=n("div");return"draggable"in e||"dragDrop"in e}(),es=3!="\n\nb".split(/\n/).length?function(e){for(var t=0,r=[],n=e.length;t<=n;){var i=e.indexOf("\n",t);-1==i&&(i=e.length);var o=e.slice(t,"\r"==e.charAt(i-1)?i-1:i),l=o.indexOf("\r");-1!=l?(r.push(o.slice(0,l)),t+=l+1):(r.push(o),t=i+1)}return r}:function(e){return e.split(/\r\n?|\n/)},ts=window.getSelection?function(e){try{return e.selectionStart!=e.selectionEnd}catch(e){return!1}}:function(e){var t;try{t=e.ownerDocument.selection.createRange()}catch(e){}return!(!t||t.parentElement()!=e)&&0!=t.compareEndPoints("StartToEnd",t)},rs=function(){var e=n("div");return"oncopy"in e||(e.setAttribute("oncopy","return;"),"function"==typeof e.oncopy)}(),ns=null,is={},os={},ls={},ss=function(e,t,r){this.pos=this.start=0,this.string=e,this.tabSize=t||8,this.lastColumnPos=this.lastColumnValue=0,this.lineStart=0,this.lineOracle=r};ss.prototype.eol=function(){return this.pos>=this.string.length},ss.prototype.sol=function(){return this.pos==this.lineStart},ss.prototype.peek=function(){return this.string.charAt(this.pos)||void 0},ss.prototype.next=function(){if(this.pos<this.string.length)return this.string.charAt(this.pos++)},ss.prototype.eat=function(e){var t=this.string.charAt(this.pos);if("string"==typeof e?t==e:t&&(e.test?e.test(t):e(t)))return++this.pos,t},ss.prototype.eatWhile=function(e){for(var t=this.pos;this.eat(e););return this.pos>t},ss.prototype.eatSpace=function(){for(var e=this,t=this.pos;/[\s\u00a0]/.test(this.string.charAt(this.pos));)++e.pos;return this.pos>t},ss.prototype.skipToEnd=function(){this.pos=this.string.length},ss.prototype.skipTo=function(e){var t=this.string.indexOf(e,this.pos);if(t>-1)return this.pos=t,!0},ss.prototype.backUp=function(e){this.pos-=e},ss.prototype.column=function(){return this.lastColumnPos<this.start&&(this.lastColumnValue=f(this.string,this.start,this.tabSize,this.lastColumnPos,this.lastColumnValue),this.lastColumnPos=this.start),this.lastColumnValue-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.indentation=function(){return f(this.string,null,this.tabSize)-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.match=function(e,t,r){if("string"!=typeof e){var n=this.string.slice(this.pos).match(e);return n&&n.index>0?null:(n&&!1!==t&&(this.pos+=n[0].length),n)}var i=function(e){return r?e.toLowerCase():e};if(i(this.string.substr(this.pos,e.length))==i(e))return!1!==t&&(this.pos+=e.length),!0},ss.prototype.current=function(){return this.string.slice(this.start,this.pos)},ss.prototype.hideFirstChars=function(e,t){this.lineStart+=e;try{return t()}finally{this.lineStart-=e}},ss.prototype.lookAhead=function(e){var t=this.lineOracle;return t&&t.lookAhead(e)};var as=function(e,t){this.state=e,this.lookAhead=t},us=function(e,t,r,n){this.state=t,this.doc=e,this.line=r,this.maxLookAhead=n||0};us.prototype.lookAhead=function(e){var t=this.doc.getLine(this.line+e);return null!=t&&e>this.maxLookAhead&&(this.maxLookAhead=e),t},us.prototype.nextLine=function(){this.line++,this.maxLookAhead>0&&this.maxLookAhead--},us.fromSaved=function(e,t,r){return t instanceof as?new us(e,Ke(e.mode,t.state),r,t.lookAhead):new us(e,Ke(e.mode,t),r)},us.prototype.save=function(e){var t=!1!==e?Ke(this.doc.mode,this.state):this.state;return this.maxLookAhead>0?new as(t,this.maxLookAhead):t};var cs=function(e,t,r){this.start=e.start,this.end=e.pos,this.string=e.current(),this.type=t||null,this.state=r},fs=function(e,t,r){this.text=e,ne(this,t),this.height=r?r(this):1};fs.prototype.lineNo=function(){return W(this)},Ae(fs);var hs,ds={},ps={},gs=null,vs=null,ms={left:0,right:0,top:0,bottom:0},ys=function(e,t,r){this.cm=r;var i=this.vert=n("div",[n("div",null,null,"min-width: 1px")],"CodeMirror-vscrollbar"),o=this.horiz=n("div",[n("div",null,null,"height: 100%; min-height: 1px")],"CodeMirror-hscrollbar");e(i),e(o),Ql(i,"scroll",function(){i.clientHeight&&t(i.scrollTop,"vertical")}),Ql(o,"scroll",function(){o.clientWidth&&t(o.scrollLeft,"horizontal")}),this.checkedZeroWidth=!1,gl&&vl<8&&(this.horiz.style.minHeight=this.vert.style.minWidth="18px")};ys.prototype.update=function(e){var t=e.scrollWidth>e.clientWidth+1,r=e.scrollHeight>e.clientHeight+1,n=e.nativeBarWidth;if(r){this.vert.style.display="block",this.vert.style.bottom=t?n+"px":"0";var i=e.viewHeight-(t?n:0);this.vert.firstChild.style.height=Math.max(0,e.scrollHeight-e.clientHeight+i)+"px"}else this.vert.style.display="",this.vert.firstChild.style.height="0";if(t){this.horiz.style.display="block",this.horiz.style.right=r?n+"px":"0",this.horiz.style.left=e.barLeft+"px";var o=e.viewWidth-e.barLeft-(r?n:0);this.horiz.firstChild.style.width=Math.max(0,e.scrollWidth-e.clientWidth+o)+"px"}else this.horiz.style.display="",this.horiz.firstChild.style.width="0";return!this.checkedZeroWidth&&e.clientHeight>0&&(0==n&&this.zeroWidthHack(),this.checkedZeroWidth=!0),{right:r?n:0,bottom:t?n:0}},ys.prototype.setScrollLeft=function(e){this.horiz.scrollLeft!=e&&(this.horiz.scrollLeft=e),this.disableHoriz&&this.enableZeroWidthBar(this.horiz,this.disableHoriz,"horiz")},ys.prototype.setScrollTop=function(e){this.vert.scrollTop!=e&&(this.vert.scrollTop=e),this.disableVert&&this.enableZeroWidthBar(this.vert,this.disableVert,"vert")},ys.prototype.zeroWidthHack=function(){var e=Ml&&!Cl?"12px":"18px";this.horiz.style.height=this.vert.style.width=e,this.horiz.style.pointerEvents=this.vert.style.pointerEvents="none",this.disableHoriz=new Pl,this.disableVert=new Pl},ys.prototype.enableZeroWidthBar=function(e,t,r){function n(){var i=e.getBoundingClientRect();("vert"==r?document.elementFromPoint(i.right-1,(i.top+i.bottom)/2):document.elementFromPoint((i.right+i.left)/2,i.bottom-1))!=e?e.style.pointerEvents="none":t.set(1e3,n)}e.style.pointerEvents="auto",t.set(1e3,n)},ys.prototype.clear=function(){var e=this.horiz.parentNode;e.removeChild(this.horiz),e.removeChild(this.vert)};var bs=function(){};bs.prototype.update=function(){return{bottom:0,right:0}},bs.prototype.setScrollLeft=function(){},bs.prototype.setScrollTop=function(){},bs.prototype.clear=function(){};var ws={native:ys,null:bs},xs=0,Cs=function(e,t,r){var n=e.display;this.viewport=t,this.visible=Ir(n,e.doc,t),this.editorIsHidden=!n.wrapper.offsetWidth,this.wrapperHeight=n.wrapper.clientHeight,this.wrapperWidth=n.wrapper.clientWidth,this.oldDisplayWidth=Rt(e),this.force=r,this.dims=br(e),this.events=[]};Cs.prototype.signal=function(e,t){Oe(e,t)&&this.events.push(arguments)},Cs.prototype.finish=function(){for(var e=this,t=0;t<this.events.length;t++)Te.apply(null,e.events[t])};var Ss=0,Ls=null;gl?Ls=-.53:fl?Ls=15:bl?Ls=-.7:xl&&(Ls=-1/3);var ks=function(e,t){this.ranges=e,this.primIndex=t};ks.prototype.primary=function(){return this.ranges[this.primIndex]},ks.prototype.equals=function(e){var t=this;if(e==this)return!0;if(e.primIndex!=this.primIndex||e.ranges.length!=this.ranges.length)return!1;for(var r=0;r<this.ranges.length;r++){var n=t.ranges[r],i=e.ranges[r];if(!I(n.anchor,i.anchor)||!I(n.head,i.head))return!1}return!0},ks.prototype.deepCopy=function(){for(var e=this,t=[],r=0;r<this.ranges.length;r++)t[r]=new Ts(z(e.ranges[r].anchor),z(e.ranges[r].head));return new ks(t,this.primIndex)},ks.prototype.somethingSelected=function(){for(var e=this,t=0;t<this.ranges.length;t++)if(!e.ranges[t].empty())return!0;return!1},ks.prototype.contains=function(e,t){var r=this;t||(t=e);for(var n=0;n<this.ranges.length;n++){var i=r.ranges[n];if(P(t,i.from())>=0&&P(e,i.to())<=0)return n}return-1};var Ts=function(e,t){this.anchor=e,this.head=t};Ts.prototype.from=function(){return B(this.anchor,this.head)},Ts.prototype.to=function(){return R(this.anchor,this.head)},Ts.prototype.empty=function(){return this.head.line==this.anchor.line&&this.head.ch==this.anchor.ch},Bi.prototype={chunkSize:function(){return this.lines.length},removeInner:function(e,t){for(var r=this,n=e,i=e+t;n<i;++n){var o=r.lines[n];r.height-=o.height,ot(o),bt(o,"delete")}this.lines.splice(e,t)},collapse:function(e){e.push.apply(e,this.lines)},insertInner:function(e,t,r){var n=this;this.height+=r,this.lines=this.lines.slice(0,e).concat(t).concat(this.lines.slice(e));for(var i=0;i<t.length;++i)t[i].parent=n},iterN:function(e,t,r){for(var n=this,i=e+t;e<i;++e)if(r(n.lines[e]))return!0}},Gi.prototype={chunkSize:function(){return this.size},removeInner:function(e,t){var r=this;this.size-=t;for(var n=0;n<this.children.length;++n){var i=r.children[n],o=i.chunkSize();if(e<o){var l=Math.min(t,o-e),s=i.height;if(i.removeInner(e,l),r.height-=s-i.height,o==l&&(r.children.splice(n--,1),i.parent=null),0==(t-=l))break;e=0}else e-=o}if(this.size-t<25&&(this.children.length>1||!(this.children[0]instanceof Bi))){var a=[];this.collapse(a),this.children=[new Bi(a)],this.children[0].parent=this}},collapse:function(e){for(var t=this,r=0;r<this.children.length;++r)t.children[r].collapse(e)},insertInner:function(e,t,r){var n=this;this.size+=t.length,this.height+=r;for(var i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<=l){if(o.insertInner(e,t,r),o.lines&&o.lines.length>50){for(var s=o.lines.length%25+25,a=s;a<o.lines.length;){var u=new Bi(o.lines.slice(a,a+=25));o.height-=u.height,n.children.splice(++i,0,u),u.parent=n}o.lines=o.lines.slice(0,s),n.maybeSpill()}break}e-=l}},maybeSpill:function(){if(!(this.children.length<=10)){var e=this;do{var t=new Gi(e.children.splice(e.children.length-5,5));if(e.parent){e.size-=t.size,e.height-=t.height;var r=h(e.parent.children,e);e.parent.children.splice(r+1,0,t)}else{var n=new Gi(e.children);n.parent=e,e.children=[n,t],e=n}t.parent=e.parent}while(e.children.length>10);e.parent.maybeSpill()}},iterN:function(e,t,r){for(var n=this,i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<l){var s=Math.min(t,l-e);if(o.iterN(e,s,r))return!0;if(0==(t-=s))break;e=0}else e-=l}}};var Ms=function(e,t,r){var n=this;if(r)for(var i in r)r.hasOwnProperty(i)&&(n[i]=r[i]);this.doc=e,this.node=t};Ms.prototype.clear=function(){var e=this,t=this.doc.cm,r=this.line.widgets,n=this.line,i=W(n);if(null!=i&&r){for(var o=0;o<r.length;++o)r[o]==e&&r.splice(o--,1);r.length||(n.widgets=null);var l=Ht(this);A(n,Math.max(0,n.height-l)),t&&(hn(t,function(){Ui(t,n,-l),mn(t,i,"widget")}),bt(t,"lineWidgetCleared",t,this,i))}},Ms.prototype.changed=function(){var e=this,t=this.height,r=this.doc.cm,n=this.line;this.height=null;var i=Ht(this)-t;i&&(A(n,n.height+i),r&&hn(r,function(){r.curOp.forceUpdate=!0,Ui(r,n,i),bt(r,"lineWidgetChanged",r,e,W(n))}))},Ae(Ms);var Ns=0,Os=function(e,t){this.lines=[],this.type=t,this.doc=e,this.id=++Ns};Os.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){var t=this.doc.cm,r=t&&!t.curOp;if(r&&nn(t),Oe(this,"clear")){var n=this.find();n&&bt(this,"clear",n.from,n.to)}for(var i=null,o=null,l=0;l<this.lines.length;++l){var s=e.lines[l],a=_(s.markedSpans,e);t&&!e.collapsed?mn(t,W(s),"text"):t&&(null!=a.to&&(o=W(s)),null!=a.from&&(i=W(s))),s.markedSpans=$(s.markedSpans,a),null==a.from&&e.collapsed&&!ve(e.doc,s)&&t&&A(s,mr(t.display))}if(t&&this.collapsed&&!t.options.lineWrapping)for(var u=0;u<this.lines.length;++u){var c=fe(e.lines[u]),f=be(c);f>t.display.maxLineLength&&(t.display.maxLine=c,t.display.maxLineLength=f,t.display.maxLineChanged=!0)}null!=i&&t&&this.collapsed&&vn(t,i,o+1),this.lines.length=0,this.explicitlyCleared=!0,this.atomic&&this.doc.cantEdit&&(this.doc.cantEdit=!1,t&&Ci(t.doc)),t&&bt(t,"markerCleared",t,this,i,o),r&&on(t),this.parent&&this.parent.clear()}},Os.prototype.find=function(e,t){var r=this;null==e&&"bookmark"==this.type&&(e=1);for(var n,i,o=0;o<this.lines.length;++o){var l=r.lines[o],s=_(l.markedSpans,r);if(null!=s.from&&(n=E(t?l:W(l),s.from),-1==e))return n;if(null!=s.to&&(i=E(t?l:W(l),s.to),1==e))return i}return n&&{from:n,to:i}},Os.prototype.changed=function(){var e=this,t=this.find(-1,!0),r=this,n=this.doc.cm;t&&n&&hn(n,function(){var i=t.line,o=W(t.line),l=jt(n,o);if(l&&(Qt(l),n.curOp.selectionChanged=n.curOp.forceUpdate=!0),n.curOp.updateMaxLine=!0,!ve(r.doc,i)&&null!=r.height){var s=r.height;r.height=null;var a=Ht(r)-s;a&&A(i,i.height+a)}bt(n,"markerChanged",n,e)})},Os.prototype.attachLine=function(e){if(!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;t.maybeHiddenMarkers&&-1!=h(t.maybeHiddenMarkers,this)||(t.maybeUnhiddenMarkers||(t.maybeUnhiddenMarkers=[])).push(this)}this.lines.push(e)},Os.prototype.detachLine=function(e){if(this.lines.splice(h(this.lines,e),1),!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;(t.maybeHiddenMarkers||(t.maybeHiddenMarkers=[])).push(this)}},Ae(Os);var As=function(e,t){var r=this;this.markers=e,this.primary=t;for(var n=0;n<e.length;++n)e[n].parent=r};As.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){this.explicitlyCleared=!0;for(var t=0;t<this.markers.length;++t)e.markers[t].clear();bt(this,"clear")}},As.prototype.find=function(e,t){return this.primary.find(e,t)},Ae(As);var Ws=0,Ds=function(e,t,r,n,i){if(!(this instanceof Ds))return new Ds(e,t,r,n,i);null==r&&(r=0),Gi.call(this,[new Bi([new fs("",null)])]),this.first=r,this.scrollTop=this.scrollLeft=0,this.cantEdit=!1,this.cleanGeneration=1,this.modeFrontier=this.highlightFrontier=r;var o=E(r,0);this.sel=Rn(o),this.history=new Jn(null),this.id=++Ws,this.modeOption=t,this.lineSep=n,this.direction="rtl"==i?"rtl":"ltr",this.extend=!1,"string"==typeof e&&(e=this.splitLines(e)),_n(this,{from:o,to:o,text:e}),bi(this,Rn(o),Gl)};Ds.prototype=b(Gi.prototype,{constructor:Ds,iter:function(e,t,r){r?this.iterN(e-this.first,t-e,r):this.iterN(this.first,this.first+this.size,e)},insert:function(e,t){for(var r=0,n=0;n<t.length;++n)r+=t[n].height;this.insertInner(e-this.first,t,r)},remove:function(e,t){this.removeInner(e-this.first,t)},getValue:function(e){var t=O(this,this.first,this.first+this.size);return!1===e?t:t.join(e||this.lineSeparator())},setValue:gn(function(e){var t=E(this.first,0),r=this.first+this.size-1;Oi(this,{from:t,to:E(r,M(this,r).text.length),text:this.splitLines(e),origin:"setValue",full:!0},!0),this.cm&&Xr(this.cm,0,0),bi(this,Rn(t),Gl)}),replaceRange:function(e,t,r,n){Ei(this,e,t=U(this,t),r=r?U(this,r):t,n)},getRange:function(e,t,r){var n=N(this,U(this,e),U(this,t));return!1===r?n:n.join(r||this.lineSeparator())},getLine:function(e){var t=this.getLineHandle(e);return t&&t.text},getLineHandle:function(e){if(H(this,e))return M(this,e)},getLineNumber:function(e){return W(e)},getLineHandleVisualStart:function(e){return"number"==typeof e&&(e=M(this,e)),fe(e)},lineCount:function(){return this.size},firstLine:function(){return this.first},lastLine:function(){return this.first+this.size-1},clipPos:function(e){return U(this,e)},getCursor:function(e){var t=this.sel.primary();return null==e||"head"==e?t.head:"anchor"==e?t.anchor:"end"==e||"to"==e||!1===e?t.to():t.from()},listSelections:function(){return this.sel.ranges},somethingSelected:function(){return this.sel.somethingSelected()},setCursor:gn(function(e,t,r){vi(this,U(this,"number"==typeof e?E(e,t||0):e),null,r)}),setSelection:gn(function(e,t,r){vi(this,U(this,e),U(this,t||e),r)}),extendSelection:gn(function(e,t,r){di(this,U(this,e),t&&U(this,t),r)}),extendSelections:gn(function(e,t){pi(this,K(this,e),t)}),extendSelectionsBy:gn(function(e,t){pi(this,K(this,v(this.sel.ranges,e)),t)}),setSelections:gn(function(e,t,r){var n=this;if(e.length){for(var i=[],o=0;o<e.length;o++)i[o]=new Ts(U(n,e[o].anchor),U(n,e[o].head));null==t&&(t=Math.min(e.length-1,this.sel.primIndex)),bi(this,zn(i,t),r)}}),addSelection:gn(function(e,t,r){var n=this.sel.ranges.slice(0);n.push(new Ts(U(this,e),U(this,t||e))),bi(this,zn(n,n.length-1),r)}),getSelection:function(e){for(var t,r=this,n=this.sel.ranges,i=0;i<n.length;i++){var o=N(r,n[i].from(),n[i].to());t=t?t.concat(o):o}return!1===e?t:t.join(e||this.lineSeparator())},getSelections:function(e){for(var t=this,r=[],n=this.sel.ranges,i=0;i<n.length;i++){var o=N(t,n[i].from(),n[i].to());!1!==e&&(o=o.join(e||t.lineSeparator())),r[i]=o}return r},replaceSelection:function(e,t,r){for(var n=[],i=0;i<this.sel.ranges.length;i++)n[i]=e;this.replaceSelections(n,t,r||"+input")},replaceSelections:gn(function(e,t,r){for(var n=this,i=[],o=this.sel,l=0;l<o.ranges.length;l++){var s=o.ranges[l];i[l]={from:s.from(),to:s.to(),text:n.splitLines(e[l]),origin:r}}for(var a=t&&"end"!=t&&Kn(this,i,t),u=i.length-1;u>=0;u--)Oi(n,i[u]);a?yi(this,a):this.cm&&jr(this.cm)}),undo:gn(function(){Wi(this,"undo")}),redo:gn(function(){Wi(this,"redo")}),undoSelection:gn(function(){Wi(this,"undo",!0)}),redoSelection:gn(function(){Wi(this,"redo",!0)}),setExtending:function(e){this.extend=e},getExtending:function(){return this.extend},historySize:function(){for(var e=this.history,t=0,r=0,n=0;n<e.done.length;n++)e.done[n].ranges||++t;for(var i=0;i<e.undone.length;i++)e.undone[i].ranges||++r;return{undo:t,redo:r}},clearHistory:function(){this.history=new Jn(this.history.maxGeneration)},markClean:function(){this.cleanGeneration=this.changeGeneration(!0)},changeGeneration:function(e){return e&&(this.history.lastOp=this.history.lastSelOp=this.history.lastOrigin=null),this.history.generation},isClean:function(e){return this.history.generation==(e||this.cleanGeneration)},getHistory:function(){return{done:fi(this.history.done),undone:fi(this.history.undone)}},setHistory:function(e){var t=this.history=new Jn(this.history.maxGeneration);t.done=fi(e.done.slice(0),null,!0),t.undone=fi(e.undone.slice(0),null,!0)},setGutterMarker:gn(function(e,t,r){return Ri(this,e,"gutter",function(e){var n=e.gutterMarkers||(e.gutterMarkers={});return n[t]=r,!r&&C(n)&&(e.gutterMarkers=null),!0})}),clearGutter:gn(function(e){var t=this;this.iter(function(r){r.gutterMarkers&&r.gutterMarkers[e]&&Ri(t,r,"gutter",function(){return r.gutterMarkers[e]=null,C(r.gutterMarkers)&&(r.gutterMarkers=null),!0})})}),lineInfo:function(e){var t;if("number"==typeof e){if(!H(this,e))return null;if(t=e,!(e=M(this,e)))return null}else if(null==(t=W(e)))return null;return{line:t,handle:e,text:e.text,gutterMarkers:e.gutterMarkers,textClass:e.textClass,bgClass:e.bgClass,wrapClass:e.wrapClass,widgets:e.widgets}},addLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass";if(t[i]){if(e(n).test(t[i]))return!1;t[i]+=" "+n}else t[i]=n;return!0})}),removeLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass",o=t[i];if(!o)return!1;if(null==n)t[i]=null;else{var l=o.match(e(n));if(!l)return!1;var s=l.index+l[0].length;t[i]=o.slice(0,l.index)+(l.index&&s!=o.length?" ":"")+o.slice(s)||null}return!0})}),addLineWidget:gn(function(e,t,r){return Vi(this,e,t,r)}),removeLineWidget:function(e){e.clear()},markText:function(e,t,r){return Ki(this,U(this,e),U(this,t),r,r&&r.type||"range")},setBookmark:function(e,t){var r={replacedWith:t&&(null==t.nodeType?t.widget:t),insertLeft:t&&t.insertLeft,clearWhenEmpty:!1,shared:t&&t.shared,handleMouseEvents:t&&t.handleMouseEvents};return e=U(this,e),Ki(this,e,e,r,"bookmark")},findMarksAt:function(e){var t=[],r=M(this,(e=U(this,e)).line).markedSpans;if(r)for(var n=0;n<r.length;++n){var i=r[n];(null==i.from||i.from<=e.ch)&&(null==i.to||i.to>=e.ch)&&t.push(i.marker.parent||i.marker)}return t},findMarks:function(e,t,r){e=U(this,e),t=U(this,t);var n=[],i=e.line;return this.iter(e.line,t.line+1,function(o){var l=o.markedSpans;if(l)for(var s=0;s<l.length;s++){var a=l[s];null!=a.to&&i==e.line&&e.ch>=a.to||null==a.from&&i!=e.line||null!=a.from&&i==t.line&&a.from>=t.ch||r&&!r(a.marker)||n.push(a.marker.parent||a.marker)}++i}),n},getAllMarks:function(){var e=[];return this.iter(function(t){var r=t.markedSpans;if(r)for(var n=0;n<r.length;++n)null!=r[n].from&&e.push(r[n].marker)}),e},posFromIndex:function(e){var t,r=this.first,n=this.lineSeparator().length;return this.iter(function(i){var o=i.text.length+n;if(o>e)return t=e,!0;e-=o,++r}),U(this,E(r,t))},indexFromPos:function(e){var t=(e=U(this,e)).ch;if(e.line<this.first||e.ch<0)return 0;var r=this.lineSeparator().length;return this.iter(this.first,e.line,function(e){t+=e.text.length+r}),t},copy:function(e){var t=new Ds(O(this,this.first,this.first+this.size),this.modeOption,this.first,this.lineSep,this.direction);return t.scrollTop=this.scrollTop,t.scrollLeft=this.scrollLeft,t.sel=this.sel,t.extend=!1,e&&(t.history.undoDepth=this.history.undoDepth,t.setHistory(this.getHistory())),t},linkedDoc:function(e){e||(e={});var t=this.first,r=this.first+this.size;null!=e.from&&e.from>t&&(t=e.from),null!=e.to&&e.to<r&&(r=e.to);var n=new Ds(O(this,t,r),e.mode||this.modeOption,t,this.lineSep,this.direction);return e.sharedHist&&(n.history=this.history),(this.linked||(this.linked=[])).push({doc:n,sharedHist:e.sharedHist}),n.linked=[{doc:this,isParent:!0,sharedHist:e.sharedHist}],Yi(n,Xi(this)),n},unlinkDoc:function(e){var t=this;if(e instanceof jo&&(e=e.doc),this.linked)for(var r=0;r<this.linked.length;++r)if(t.linked[r].doc==e){t.linked.splice(r,1),e.unlinkDoc(t),_i(Xi(t));break}if(e.history==this.history){var n=[e.id];$n(e,function(e){return n.push(e.id)},!0),e.history=new Jn(null),e.history.done=fi(this.history.done,n),e.history.undone=fi(this.history.undone,n)}},iterLinkedDocs:function(e){$n(this,e)},getMode:function(){return this.mode},getEditor:function(){return this.cm},splitLines:function(e){return this.lineSep?e.split(this.lineSep):es(e)},lineSeparator:function(){return this.lineSep||"\n"},setDirection:gn(function(e){"rtl"!=e&&(e="ltr"),e!=this.direction&&(this.direction=e,this.iter(function(e){return e.order=null}),this.cm&&Qn(this.cm))})}),Ds.prototype.eachLine=Ds.prototype.iter;for(var Hs=0,Fs=!1,Es={3:"Enter",8:"Backspace",9:"Tab",13:"Enter",16:"Shift",17:"Ctrl",18:"Alt",19:"Pause",20:"CapsLock",27:"Esc",32:"Space",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"Left",38:"Up",39:"Right",40:"Down",44:"PrintScrn",45:"Insert",46:"Delete",59:";",61:"=",91:"Mod",92:"Mod",93:"Mod",106:"*",107:"=",109:"-",110:".",111:"/",127:"Delete",173:"-",186:";",187:"=",188:",",189:"-",190:".",191:"/",192:"`",219:"[",220:"\\",221:"]",222:"'",63232:"Up",63233:"Down",63234:"Left",63235:"Right",63272:"Delete",63273:"Home",63275:"End",63276:"PageUp",63277:"PageDown",63302:"Insert"},Ps=0;Ps<10;Ps++)Es[Ps+48]=Es[Ps+96]=String(Ps);for(var Is=65;Is<=90;Is++)Es[Is]=String.fromCharCode(Is);for(var zs=1;zs<=12;zs++)Es[zs+111]=Es[zs+63235]="F"+zs;var Rs={};Rs.basic={Left:"goCharLeft",Right:"goCharRight",Up:"goLineUp",Down:"goLineDown",End:"goLineEnd",Home:"goLineStartSmart",PageUp:"goPageUp",PageDown:"goPageDown",Delete:"delCharAfter",Backspace:"delCharBefore","Shift-Backspace":"delCharBefore",Tab:"defaultTab","Shift-Tab":"indentAuto",Enter:"newlineAndIndent",Insert:"toggleOverwrite",Esc:"singleSelection"},Rs.pcDefault={"Ctrl-A":"selectAll","Ctrl-D":"deleteLine","Ctrl-Z":"undo","Shift-Ctrl-Z":"redo","Ctrl-Y":"redo","Ctrl-Home":"goDocStart","Ctrl-End":"goDocEnd","Ctrl-Up":"goLineUp","Ctrl-Down":"goLineDown","Ctrl-Left":"goGroupLeft","Ctrl-Right":"goGroupRight","Alt-Left":"goLineStart","Alt-Right":"goLineEnd","Ctrl-Backspace":"delGroupBefore","Ctrl-Delete":"delGroupAfter","Ctrl-S":"save","Ctrl-F":"find","Ctrl-G":"findNext","Shift-Ctrl-G":"findPrev","Shift-Ctrl-F":"replace","Shift-Ctrl-R":"replaceAll","Ctrl-[":"indentLess","Ctrl-]":"indentMore","Ctrl-U":"undoSelection","Shift-Ctrl-U":"redoSelection","Alt-U":"redoSelection",fallthrough:"basic"},Rs.emacsy={"Ctrl-F":"goCharRight","Ctrl-B":"goCharLeft","Ctrl-P":"goLineUp","Ctrl-N":"goLineDown","Alt-F":"goWordRight","Alt-B":"goWordLeft","Ctrl-A":"goLineStart","Ctrl-E":"goLineEnd","Ctrl-V":"goPageDown","Shift-Ctrl-V":"goPageUp","Ctrl-D":"delCharAfter","Ctrl-H":"delCharBefore","Alt-D":"delWordAfter","Alt-Backspace":"delWordBefore","Ctrl-K":"killLine","Ctrl-T":"transposeChars","Ctrl-O":"openLine"},Rs.macDefault={"Cmd-A":"selectAll","Cmd-D":"deleteLine","Cmd-Z":"undo","Shift-Cmd-Z":"redo","Cmd-Y":"redo","Cmd-Home":"goDocStart","Cmd-Up":"goDocStart","Cmd-End":"goDocEnd","Cmd-Down":"goDocEnd","Alt-Left":"goGroupLeft","Alt-Right":"goGroupRight","Cmd-Left":"goLineLeft","Cmd-Right":"goLineRight","Alt-Backspace":"delGroupBefore","Ctrl-Alt-Backspace":"delGroupAfter","Alt-Delete":"delGroupAfter","Cmd-S":"save","Cmd-F":"find","Cmd-G":"findNext","Shift-Cmd-G":"findPrev","Cmd-Alt-F":"replace","Shift-Cmd-Alt-F":"replaceAll","Cmd-[":"indentLess","Cmd-]":"indentMore","Cmd-Backspace":"delWrappedLineLeft","Cmd-Delete":"delWrappedLineRight","Cmd-U":"undoSelection","Shift-Cmd-U":"redoSelection","Ctrl-Up":"goDocStart","Ctrl-Down":"goDocEnd",fallthrough:["basic","emacsy"]},Rs.default=Ml?Rs.macDefault:Rs.pcDefault;var Bs={selectAll:Mi,singleSelection:function(e){return e.setSelection(e.getCursor("anchor"),e.getCursor("head"),Gl)},killLine:function(e){return co(e,function(t){if(t.empty()){var r=M(e.doc,t.head.line).text.length;return t.head.ch==r&&t.head.line<e.lastLine()?{from:t.head,to:E(t.head.line+1,0)}:{from:t.head,to:E(t.head.line,r)}}return{from:t.from(),to:t.to()}})},deleteLine:function(e){return co(e,function(t){return{from:E(t.from().line,0),to:U(e.doc,E(t.to().line+1,0))}})},delLineLeft:function(e){return co(e,function(e){return{from:E(e.from().line,0),to:e.from()}})},delWrappedLineLeft:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5;return{from:e.coordsChar({left:0,top:r},"div"),to:t.from()}})},delWrappedLineRight:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5,n=e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div");return{from:t.from(),to:n}})},undo:function(e){return e.undo()},redo:function(e){return e.redo()},undoSelection:function(e){return e.undoSelection()},redoSelection:function(e){return e.redoSelection()},goDocStart:function(e){return e.extendSelection(E(e.firstLine(),0))},goDocEnd:function(e){return e.extendSelection(E(e.lastLine()))},goLineStart:function(e){return e.extendSelectionsBy(function(t){return vo(e,t.head.line)},{origin:"+move",bias:1})},goLineStartSmart:function(e){return e.extendSelectionsBy(function(t){return yo(e,t.head)},{origin:"+move",bias:1})},goLineEnd:function(e){return e.extendSelectionsBy(function(t){return mo(e,t.head.line)},{origin:"+move",bias:-1})},goLineRight:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div")},Vl)},goLineLeft:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:0,top:r},"div")},Vl)},goLineLeftSmart:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5,n=e.coordsChar({left:0,top:r},"div");return n.ch<e.getLine(n.line).search(/\S/)?yo(e,t.head):n},Vl)},goLineUp:function(e){return e.moveV(-1,"line")},goLineDown:function(e){return e.moveV(1,"line")},goPageUp:function(e){return e.moveV(-1,"page")},goPageDown:function(e){return e.moveV(1,"page")},goCharLeft:function(e){return e.moveH(-1,"char")},goCharRight:function(e){return e.moveH(1,"char")},goColumnLeft:function(e){return e.moveH(-1,"column")},goColumnRight:function(e){return e.moveH(1,"column")},goWordLeft:function(e){return e.moveH(-1,"word")},goGroupRight:function(e){return e.moveH(1,"group")},goGroupLeft:function(e){return e.moveH(-1,"group")},goWordRight:function(e){return e.moveH(1,"word")},delCharBefore:function(e){return e.deleteH(-1,"char")},delCharAfter:function(e){return e.deleteH(1,"char")},delWordBefore:function(e){return e.deleteH(-1,"word")},delWordAfter:function(e){return e.deleteH(1,"word")},delGroupBefore:function(e){return e.deleteH(-1,"group")},delGroupAfter:function(e){return e.deleteH(1,"group")},indentAuto:function(e){return e.indentSelection("smart")},indentMore:function(e){return e.indentSelection("add")},indentLess:function(e){return e.indentSelection("subtract")},insertTab:function(e){return e.replaceSelection("\t")},insertSoftTab:function(e){for(var t=[],r=e.listSelections(),n=e.options.tabSize,i=0;i<r.length;i++){var o=r[i].from(),l=f(e.getLine(o.line),o.ch,n);t.push(p(n-l%n))}e.replaceSelections(t)},defaultTab:function(e){e.somethingSelected()?e.indentSelection("add"):e.execCommand("insertTab")},transposeChars:function(e){return hn(e,function(){for(var t=e.listSelections(),r=[],n=0;n<t.length;n++)if(t[n].empty()){var i=t[n].head,o=M(e.doc,i.line).text;if(o)if(i.ch==o.length&&(i=new E(i.line,i.ch-1)),i.ch>0)i=new E(i.line,i.ch+1),e.replaceRange(o.charAt(i.ch-1)+o.charAt(i.ch-2),E(i.line,i.ch-2),i,"+transpose");else if(i.line>e.doc.first){var l=M(e.doc,i.line-1).text;l&&(i=new E(i.line,1),e.replaceRange(o.charAt(0)+e.doc.lineSeparator()+l.charAt(l.length-1),E(i.line-1,l.length-1),i,"+transpose"))}r.push(new Ts(i,i))}e.setSelections(r)})},newlineAndIndent:function(e){return hn(e,function(){for(var t=e.listSelections(),r=t.length-1;r>=0;r--)e.replaceRange(e.doc.lineSeparator(),t[r].anchor,t[r].head,"+input");t=e.listSelections();for(var n=0;n<t.length;n++)e.indentLine(t[n].from().line,null,!0);jr(e)})},openLine:function(e){return e.replaceSelection("\n","start")},toggleOverwrite:function(e){return e.toggleOverwrite()}},Gs=new Pl,Us=null,Vs=function(e,t,r){this.time=e,this.pos=t,this.button=r};Vs.prototype.compare=function(e,t,r){return this.time+400>e&&0==P(t,this.pos)&&r==this.button};var Ks,js,Xs={toString:function(){return"CodeMirror.Init"}},Ys={},_s={};jo.defaults=Ys,jo.optionHandlers=_s;var $s=[];jo.defineInitHook=function(e){return $s.push(e)};var qs=null,Zs=function(e){this.cm=e,this.lastAnchorNode=this.lastAnchorOffset=this.lastFocusNode=this.lastFocusOffset=null,this.polling=new Pl,this.composing=null,this.gracePeriod=!1,this.readDOMTimeout=null};Zs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()}),"cut"==e.type&&i.replaceSelection("",null,"cut");else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type&&i.operation(function(){i.setSelections(t.ranges,0,Gl),i.replaceSelection("",null,"cut")})}if(e.clipboardData){e.clipboardData.clearData();var r=qs.text.join("\n");if(e.clipboardData.setData("Text",r),e.clipboardData.getData("Text")==r)return void e.preventDefault()}var l=el(),s=l.firstChild;i.display.lineSpace.insertBefore(l,i.display.lineSpace.firstChild),s.value=qs.text.join("\n");var a=document.activeElement;El(s),setTimeout(function(){i.display.lineSpace.removeChild(l),a.focus(),a==o&&n.showPrimarySelection()},50)}}var r=this,n=this,i=n.cm,o=n.div=e.lineDiv;Jo(o,i.options.spellcheck),Ql(o,"paste",function(e){Me(i,e)||qo(e,i)||vl<=11&&setTimeout(dn(i,function(){return r.updateFromDOM()}),20)}),Ql(o,"compositionstart",function(e){r.composing={data:e.data,done:!1}}),Ql(o,"compositionupdate",function(e){r.composing||(r.composing={data:e.data,done:!1})}),Ql(o,"compositionend",function(e){r.composing&&(e.data!=r.composing.data&&r.readFromDOMSoon(),r.composing.done=!0)}),Ql(o,"touchstart",function(){return n.forceCompositionEnd()}),Ql(o,"input",function(){r.composing||r.readFromDOMSoon()}),Ql(o,"copy",t),Ql(o,"cut",t)},Zs.prototype.prepareSelection=function(){var e=Tr(this.cm,!1);return e.focus=this.cm.state.focused,e},Zs.prototype.showSelection=function(e,t){e&&this.cm.display.view.length&&((e.focus||t)&&this.showPrimarySelection(),this.showMultipleSelections(e))},Zs.prototype.showPrimarySelection=function(){var e=window.getSelection(),t=this.cm,r=t.doc.sel.primary(),n=r.from(),i=r.to();if(t.display.viewTo==t.display.viewFrom||n.line>=t.display.viewTo||i.line<t.display.viewFrom)e.removeAllRanges();else{var o=sl(t,e.anchorNode,e.anchorOffset),l=sl(t,e.focusNode,e.focusOffset);if(!o||o.bad||!l||l.bad||0!=P(B(o,l),n)||0!=P(R(o,l),i)){var s=t.display.view,a=n.line>=t.display.viewFrom&&nl(t,n)||{node:s[0].measure.map[2],offset:0},u=i.line<t.display.viewTo&&nl(t,i);if(!u){var c=s[s.length-1].measure,f=c.maps?c.maps[c.maps.length-1]:c.map;u={node:f[f.length-1],offset:f[f.length-2]-f[f.length-3]}}if(a&&u){var h,d=e.rangeCount&&e.getRangeAt(0);try{h=Wl(a.node,a.offset,u.offset,u.node)}catch(e){}h&&(!fl&&t.state.focused?(e.collapse(a.node,a.offset),h.collapsed||(e.removeAllRanges(),e.addRange(h))):(e.removeAllRanges(),e.addRange(h)),d&&null==e.anchorNode?e.addRange(d):fl&&this.startGracePeriod()),this.rememberSelection()}else e.removeAllRanges()}}},Zs.prototype.startGracePeriod=function(){var e=this;clearTimeout(this.gracePeriod),this.gracePeriod=setTimeout(function(){e.gracePeriod=!1,e.selectionChanged()&&e.cm.operation(function(){return e.cm.curOp.selectionChanged=!0})},20)},Zs.prototype.showMultipleSelections=function(e){r(this.cm.display.cursorDiv,e.cursors),r(this.cm.display.selectionDiv,e.selection)},Zs.prototype.rememberSelection=function(){var e=window.getSelection();this.lastAnchorNode=e.anchorNode,this.lastAnchorOffset=e.anchorOffset,this.lastFocusNode=e.focusNode,this.lastFocusOffset=e.focusOffset},Zs.prototype.selectionInEditor=function(){var e=window.getSelection();if(!e.rangeCount)return!1;var t=e.getRangeAt(0).commonAncestorContainer;return o(this.div,t)},Zs.prototype.focus=function(){"nocursor"!=this.cm.options.readOnly&&(this.selectionInEditor()||this.showSelection(this.prepareSelection(),!0),this.div.focus())},Zs.prototype.blur=function(){this.div.blur()},Zs.prototype.getField=function(){return this.div},Zs.prototype.supportsTouch=function(){return!0},Zs.prototype.receivedFocus=function(){function e(){t.cm.state.focused&&(t.pollSelection(),t.polling.set(t.cm.options.pollInterval,e))}var t=this;this.selectionInEditor()?this.pollSelection():hn(this.cm,function(){return t.cm.curOp.selectionChanged=!0}),this.polling.set(this.cm.options.pollInterval,e)},Zs.prototype.selectionChanged=function(){var e=window.getSelection();return e.anchorNode!=this.lastAnchorNode||e.anchorOffset!=this.lastAnchorOffset||e.focusNode!=this.lastFocusNode||e.focusOffset!=this.lastFocusOffset},Zs.prototype.pollSelection=function(){if(null==this.readDOMTimeout&&!this.gracePeriod&&this.selectionChanged()){var e=window.getSelection(),t=this.cm;if(kl&&bl&&this.cm.options.gutters.length&&il(e.anchorNode))return this.cm.triggerOnKeyDown({type:"keydown",keyCode:8,preventDefault:Math.abs}),this.blur(),void this.focus();if(!this.composing){this.rememberSelection();var r=sl(t,e.anchorNode,e.anchorOffset),n=sl(t,e.focusNode,e.focusOffset);r&&n&&hn(t,function(){bi(t.doc,Rn(r,n),Gl),(r.bad||n.bad)&&(t.curOp.selectionChanged=!0)})}}},Zs.prototype.pollContent=function(){null!=this.readDOMTimeout&&(clearTimeout(this.readDOMTimeout),this.readDOMTimeout=null);var e=this.cm,t=e.display,r=e.doc.sel.primary(),n=r.from(),i=r.to();if(0==n.ch&&n.line>e.firstLine()&&(n=E(n.line-1,M(e.doc,n.line-1).length)),i.ch==M(e.doc,i.line).text.length&&i.line<e.lastLine()&&(i=E(i.line+1,0)),n.line<t.viewFrom||i.line>t.viewTo-1)return!1;var o,l,s;n.line==t.viewFrom||0==(o=Lr(e,n.line))?(l=W(t.view[0].line),s=t.view[0].node):(l=W(t.view[o].line),s=t.view[o-1].node.nextSibling);var a,u,c=Lr(e,i.line);if(c==t.view.length-1?(a=t.viewTo-1,u=t.lineDiv.lastChild):(a=W(t.view[c+1].line)-1,u=t.view[c+1].node.previousSibling),!s)return!1;for(var f=e.doc.splitLines(ll(e,s,u,l,a)),h=N(e.doc,E(l,0),E(a,M(e.doc,a).text.length));f.length>1&&h.length>1;)if(g(f)==g(h))f.pop(),h.pop(),a--;else{if(f[0]!=h[0])break;f.shift(),h.shift(),l++}for(var d=0,p=0,v=f[0],m=h[0],y=Math.min(v.length,m.length);d<y&&v.charCodeAt(d)==m.charCodeAt(d);)++d;for(var b=g(f),w=g(h),x=Math.min(b.length-(1==f.length?d:0),w.length-(1==h.length?d:0));p<x&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)++p;if(1==f.length&&1==h.length&&l==n.line)for(;d&&d>n.ch&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)d--,p++;f[f.length-1]=b.slice(0,b.length-p).replace(/^\u200b+/,""),f[0]=f[0].slice(d).replace(/\u200b+$/,"");var C=E(l,d),S=E(a,h.length?g(h).length-p:0);return f.length>1||f[0]||P(C,S)?(Ei(e.doc,f,C,S,"+input"),!0):void 0},Zs.prototype.ensurePolled=function(){this.forceCompositionEnd()},Zs.prototype.reset=function(){this.forceCompositionEnd()},Zs.prototype.forceCompositionEnd=function(){this.composing&&(clearTimeout(this.readDOMTimeout),this.composing=null,this.updateFromDOM(),this.div.blur(),this.div.focus())},Zs.prototype.readFromDOMSoon=function(){var e=this;null==this.readDOMTimeout&&(this.readDOMTimeout=setTimeout(function(){if(e.readDOMTimeout=null,e.composing){if(!e.composing.done)return;e.composing=null}e.updateFromDOM()},80))},Zs.prototype.updateFromDOM=function(){var e=this;!this.cm.isReadOnly()&&this.pollContent()||hn(this.cm,function(){return vn(e.cm)})},Zs.prototype.setUneditable=function(e){e.contentEditable="false"},Zs.prototype.onKeyPress=function(e){0!=e.charCode&&(e.preventDefault(),this.cm.isReadOnly()||dn(this.cm,$o)(this.cm,String.fromCharCode(null==e.charCode?e.keyCode:e.charCode),0))},Zs.prototype.readOnlyChanged=function(e){this.div.contentEditable=String("nocursor"!=e)},Zs.prototype.onContextMenu=function(){},Zs.prototype.resetPosition=function(){},Zs.prototype.needsContentAttribute=!0;var Qs=function(e){this.cm=e,this.prevInput="",this.pollingFast=!1,this.polling=new Pl,this.hasSelection=!1,this.composing=null};Qs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()});else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type?i.setSelections(t.ranges,null,Gl):(n.prevInput="",l.value=t.text.join("\n"),El(l))}"cut"==e.type&&(i.state.cutIncoming=!0)}}var r=this,n=this,i=this.cm,o=this.wrapper=el(),l=this.textarea=o.firstChild;e.wrapper.insertBefore(o,e.wrapper.firstChild),Ll&&(l.style.width="0px"),Ql(l,"input",function(){gl&&vl>=9&&r.hasSelection&&(r.hasSelection=null),n.poll()}),Ql(l,"paste",function(e){Me(i,e)||qo(e,i)||(i.state.pasteIncoming=!0,n.fastPoll())}),Ql(l,"cut",t),Ql(l,"copy",t),Ql(e.scroller,"paste",function(t){Ft(e,t)||Me(i,t)||(i.state.pasteIncoming=!0,n.focus())}),Ql(e.lineSpace,"selectstart",function(t){Ft(e,t)||We(t)}),Ql(l,"compositionstart",function(){var e=i.getCursor("from");n.composing&&n.composing.range.clear(),n.composing={start:e,range:i.markText(e,i.getCursor("to"),{className:"CodeMirror-composing"})}}),Ql(l,"compositionend",function(){n.composing&&(n.poll(),n.composing.range.clear(),n.composing=null)})},Qs.prototype.prepareSelection=function(){var e=this.cm,t=e.display,r=e.doc,n=Tr(e);if(e.options.moveInputWithCursor){var i=sr(e,r.sel.primary().head,"div"),o=t.wrapper.getBoundingClientRect(),l=t.lineDiv.getBoundingClientRect();n.teTop=Math.max(0,Math.min(t.wrapper.clientHeight-10,i.top+l.top-o.top)),n.teLeft=Math.max(0,Math.min(t.wrapper.clientWidth-10,i.left+l.left-o.left))}return n},Qs.prototype.showSelection=function(e){var t=this.cm.display;r(t.cursorDiv,e.cursors),r(t.selectionDiv,e.selection),null!=e.teTop&&(this.wrapper.style.top=e.teTop+"px",this.wrapper.style.left=e.teLeft+"px")},Qs.prototype.reset=function(e){if(!this.contextMenuPending&&!this.composing){var t=this.cm;if(t.somethingSelected()){this.prevInput="";var r=t.getSelection();this.textarea.value=r,t.state.focused&&El(this.textarea),gl&&vl>=9&&(this.hasSelection=r)}else e||(this.prevInput=this.textarea.value="",gl&&vl>=9&&(this.hasSelection=null))}},Qs.prototype.getField=function(){return this.textarea},Qs.prototype.supportsTouch=function(){return!1},Qs.prototype.focus=function(){if("nocursor"!=this.cm.options.readOnly&&(!Tl||l()!=this.textarea))try{this.textarea.focus()}catch(e){}},Qs.prototype.blur=function(){this.textarea.blur()},Qs.prototype.resetPosition=function(){this.wrapper.style.top=this.wrapper.style.left=0},Qs.prototype.receivedFocus=function(){this.slowPoll()},Qs.prototype.slowPoll=function(){var e=this;this.pollingFast||this.polling.set(this.cm.options.pollInterval,function(){e.poll(),e.cm.state.focused&&e.slowPoll()})},Qs.prototype.fastPoll=function(){function e(){r.poll()||t?(r.pollingFast=!1,r.slowPoll()):(t=!0,r.polling.set(60,e))}var t=!1,r=this;r.pollingFast=!0,r.polling.set(20,e)},Qs.prototype.poll=function(){var e=this,t=this.cm,r=this.textarea,n=this.prevInput;if(this.contextMenuPending||!t.state.focused||ts(r)&&!n&&!this.composing||t.isReadOnly()||t.options.disableInput||t.state.keySeq)return!1;var i=r.value;if(i==n&&!t.somethingSelected())return!1;if(gl&&vl>=9&&this.hasSelection===i||Ml&&/[\uf700-\uf7ff]/.test(i))return t.display.input.reset(),!1;if(t.doc.sel==t.display.selForContextMenu){var o=i.charCodeAt(0);if(8203!=o||n||(n="​"),8666==o)return this.reset(),this.cm.execCommand("undo")}for(var l=0,s=Math.min(n.length,i.length);l<s&&n.charCodeAt(l)==i.charCodeAt(l);)++l;return hn(t,function(){$o(t,i.slice(l),n.length-l,null,e.composing?"*compose":null),i.length>1e3||i.indexOf("\n")>-1?r.value=e.prevInput="":e.prevInput=i,e.composing&&(e.composing.range.clear(),e.composing.range=t.markText(e.composing.start,t.getCursor("to"),{className:"CodeMirror-composing"}))}),!0},Qs.prototype.ensurePolled=function(){this.pollingFast&&this.poll()&&(this.pollingFast=!1)},Qs.prototype.onKeyPress=function(){gl&&vl>=9&&(this.hasSelection=null),this.fastPoll()},Qs.prototype.onContextMenu=function(e){function t(){if(null!=l.selectionStart){var e=i.somethingSelected(),t="​"+(e?l.value:"");l.value="⇚",l.value=t,n.prevInput=e?"":"​",l.selectionStart=1,l.selectionEnd=t.length,o.selForContextMenu=i.doc.sel}}function r(){if(n.contextMenuPending=!1,n.wrapper.style.cssText=c,l.style.cssText=u,gl&&vl<9&&o.scrollbars.setScrollTop(o.scroller.scrollTop=a),null!=l.selectionStart){(!gl||gl&&vl<9)&&t();var e=0,r=function(){o.selForContextMenu==i.doc.sel&&0==l.selectionStart&&l.selectionEnd>0&&"​"==n.prevInput?dn(i,Mi)(i):e++<10?o.detectingSelectAll=setTimeout(r,500):(o.selForContextMenu=null,o.input.reset())};o.detectingSelectAll=setTimeout(r,200)}}var n=this,i=n.cm,o=i.display,l=n.textarea,s=Sr(i,e),a=o.scroller.scrollTop;if(s&&!wl){i.options.resetSelectionOnContextMenu&&-1==i.doc.sel.contains(s)&&dn(i,bi)(i.doc,Rn(s),Gl);var u=l.style.cssText,c=n.wrapper.style.cssText;n.wrapper.style.cssText="position: absolute";var f=n.wrapper.getBoundingClientRect();l.style.cssText="position: absolute; width: 30px; height: 30px;\n      top: "+(e.clientY-f.top-5)+"px; left: "+(e.clientX-f.left-5)+"px;\n      z-index: 1000; background: "+(gl?"rgba(255, 255, 255, .05)":"transparent")+";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";var h;if(ml&&(h=window.scrollY),o.input.focus(),ml&&window.scrollTo(null,h),o.input.reset(),i.somethingSelected()||(l.value=n.prevInput=" "),n.contextMenuPending=!0,o.selForContextMenu=i.doc.sel,clearTimeout(o.detectingSelectAll),gl&&vl>=9&&t(),Hl){Fe(e);var d=function(){ke(window,"mouseup",d),setTimeout(r,20)};Ql(window,"mouseup",d)}else setTimeout(r,50)}},Qs.prototype.readOnlyChanged=function(e){e||this.reset(),this.textarea.disabled="nocursor"==e},Qs.prototype.setUneditable=function(){},Qs.prototype.needsContentAttribute=!1,function(e){function t(t,n,i,o){e.defaults[t]=n,i&&(r[t]=o?function(e,t,r){r!=Xs&&i(e,t,r)}:i)}var r=e.optionHandlers;e.defineOption=t,e.Init=Xs,t("value","",function(e,t){return e.setValue(t)},!0),t("mode",null,function(e,t){e.doc.modeOption=t,jn(e)},!0),t("indentUnit",2,jn,!0),t("indentWithTabs",!1),t("smartIndent",!0),t("tabSize",4,function(e){Xn(e),er(e),vn(e)},!0),t("lineSeparator",null,function(e,t){if(e.doc.lineSep=t,t){var r=[],n=e.doc.first;e.doc.iter(function(e){for(var i=0;;){var o=e.text.indexOf(t,i);if(-1==o)break;i=o+t.length,r.push(E(n,o))}n++});for(var i=r.length-1;i>=0;i--)Ei(e.doc,t,r[i],E(r[i].line,r[i].ch+t.length))}}),t("specialChars",/[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff]/g,function(e,t,r){e.state.specialChars=new RegExp(t.source+(t.test("\t")?"":"|\t"),"g"),r!=Xs&&e.refresh()}),t("specialCharPlaceholder",at,function(e){return e.refresh()},!0),t("electricChars",!0),t("inputStyle",Tl?"contenteditable":"textarea",function(){throw new Error("inputStyle can not (yet) be changed in a running editor")},!0),t("spellcheck",!1,function(e,t){return e.getInputField().spellcheck=t},!0),t("rtlMoveVisually",!Ol),t("wholeLineUpdateBefore",!0),t("theme","default",function(e){Go(e),Uo(e)},!0),t("keyMap","default",function(e,t,r){var n=uo(t),i=r!=Xs&&uo(r);i&&i.detach&&i.detach(e,n),n.attach&&n.attach(e,i||null)}),t("extraKeys",null),t("configureMouse",null),t("lineWrapping",!1,Ko,!0),t("gutters",[],function(e){Fn(e.options),Uo(e)},!0),t("fixedGutter",!0,function(e,t){e.display.gutters.style.left=t?wr(e.display)+"px":"0",e.refresh()},!0),t("coverGutterNextToScrollbar",!1,function(e){return en(e)},!0),t("scrollbarStyle","native",function(e){rn(e),en(e),e.display.scrollbars.setScrollTop(e.doc.scrollTop),e.display.scrollbars.setScrollLeft(e.doc.scrollLeft)},!0),t("lineNumbers",!1,function(e){Fn(e.options),Uo(e)},!0),t("firstLineNumber",1,Uo,!0),t("lineNumberFormatter",function(e){return e},Uo,!0),t("showCursorWhenSelecting",!1,kr,!0),t("resetSelectionOnContextMenu",!0),t("lineWiseCopyCut",!0),t("pasteLinesPerSelection",!0),t("readOnly",!1,function(e,t){"nocursor"==t&&(Fr(e),e.display.input.blur()),e.display.input.readOnlyChanged(t)}),t("disableInput",!1,function(e,t){t||e.display.input.reset()},!0),t("dragDrop",!0,Vo),t("allowDropFileTypes",null),t("cursorBlinkRate",530),t("cursorScrollMargin",0),t("cursorHeight",1,kr,!0),t("singleCursorHeightPerLine",!0,kr,!0),t("workTime",100),t("workDelay",100),t("flattenSpans",!0,Xn,!0),t("addModeClass",!1,Xn,!0),t("pollInterval",100),t("undoDepth",200,function(e,t){return e.doc.history.undoDepth=t}),t("historyEventDelay",1250),t("viewportMargin",10,function(e){return e.refresh()},!0),t("maxHighlightLength",1e4,Xn,!0),t("moveInputWithCursor",!0,function(e,t){t||e.display.input.resetPosition()}),t("tabindex",null,function(e,t){return e.display.input.getField().tabIndex=t||""}),t("autofocus",null),t("direction","ltr",function(e,t){return e.doc.setDirection(t)},!0)}(jo),function(e){var t=e.optionHandlers,r=e.helpers={};e.prototype={constructor:e,focus:function(){window.focus(),this.display.input.focus()},setOption:function(e,r){var n=this.options,i=n[e];n[e]==r&&"mode"!=e||(n[e]=r,t.hasOwnProperty(e)&&dn(this,t[e])(this,r,i),Te(this,"optionChange",this,e))},getOption:function(e){return this.options[e]},getDoc:function(){return this.doc},addKeyMap:function(e,t){this.state.keyMaps[t?"push":"unshift"](uo(e))},removeKeyMap:function(e){for(var t=this.state.keyMaps,r=0;r<t.length;++r)if(t[r]==e||t[r].name==e)return t.splice(r,1),!0},addOverlay:pn(function(t,r){var n=t.token?t:e.getMode(this.options,t);if(n.startState)throw new Error("Overlays may not be stateful.");m(this.state.overlays,{mode:n,modeSpec:t,opaque:r&&r.opaque,priority:r&&r.priority||0},function(e){return e.priority}),this.state.modeGen++,vn(this)}),removeOverlay:pn(function(e){for(var t=this,r=this.state.overlays,n=0;n<r.length;++n){var i=r[n].modeSpec;if(i==e||"string"==typeof e&&i.name==e)return r.splice(n,1),t.state.modeGen++,void vn(t)}}),indentLine:pn(function(e,t,r){"string"!=typeof t&&"number"!=typeof t&&(t=null==t?this.options.smartIndent?"smart":"prev":t?"add":"subtract"),H(this.doc,e)&&Yo(this,e,t,r)}),indentSelection:pn(function(e){for(var t=this,r=this.doc.sel.ranges,n=-1,i=0;i<r.length;i++){var o=r[i];if(o.empty())o.head.line>n&&(Yo(t,o.head.line,e,!0),n=o.head.line,i==t.doc.sel.primIndex&&jr(t));else{var l=o.from(),s=o.to(),a=Math.max(n,l.line);n=Math.min(t.lastLine(),s.line-(s.ch?0:1))+1;for(var u=a;u<n;++u)Yo(t,u,e);var c=t.doc.sel.ranges;0==l.ch&&r.length==c.length&&c[i].from().ch>0&&gi(t.doc,i,new Ts(l,c[i].to()),Gl)}}}),getTokenAt:function(e,t){return Je(this,e,t)},getLineTokens:function(e,t){return Je(this,E(e),t,!0)},getTokenTypeAt:function(e){e=U(this.doc,e);var t,r=_e(this,M(this.doc,e.line)),n=0,i=(r.length-1)/2,o=e.ch;if(0==o)t=r[2];else for(;;){var l=n+i>>1;if((l?r[2*l-1]:0)>=o)i=l;else{if(!(r[2*l+1]<o)){t=r[2*l+2];break}n=l+1}}var s=t?t.indexOf("overlay "):-1;return s<0?t:0==s?null:t.slice(0,s-1)},getModeAt:function(t){var r=this.doc.mode;return r.innerMode?e.innerMode(r,this.getTokenAt(t).state).mode:r},getHelper:function(e,t){return this.getHelpers(e,t)[0]},getHelpers:function(e,t){var n=this,i=[];if(!r.hasOwnProperty(t))return i;var o=r[t],l=this.getModeAt(e);if("string"==typeof l[t])o[l[t]]&&i.push(o[l[t]]);else if(l[t])for(var s=0;s<l[t].length;s++){var a=o[l[t][s]];a&&i.push(a)}else l.helperType&&o[l.helperType]?i.push(o[l.helperType]):o[l.name]&&i.push(o[l.name]);for(var u=0;u<o._global.length;u++){var c=o._global[u];c.pred(l,n)&&-1==h(i,c.val)&&i.push(c.val)}return i},getStateAfter:function(e,t){var r=this.doc;return e=G(r,null==e?r.first+r.size-1:e),$e(this,e+1,t).state},cursorCoords:function(e,t){var r,n=this.doc.sel.primary();return r=null==e?n.head:"object"==typeof e?U(this.doc,e):e?n.from():n.to(),sr(this,r,t||"page")},charCoords:function(e,t){return lr(this,U(this.doc,e),t||"page")},coordsChar:function(e,t){return e=or(this,e,t||"page"),cr(this,e.left,e.top)},lineAtHeight:function(e,t){return e=or(this,{top:e,left:0},t||"page").top,D(this.doc,e+this.display.viewOffset)},heightAtLine:function(e,t,r){var n,i=!1;if("number"==typeof e){var o=this.doc.first+this.doc.size-1;e<this.doc.first?e=this.doc.first:e>o&&(e=o,i=!0),n=M(this.doc,e)}else n=e;return ir(this,n,{top:0,left:0},t||"page",r||i).top+(i?this.doc.height-ye(n):0)},defaultTextHeight:function(){return mr(this.display)},defaultCharWidth:function(){return yr(this.display)},getViewport:function(){return{from:this.display.viewFrom,to:this.display.viewTo}},addWidget:function(e,t,r,n,i){var o=this.display,l=(e=sr(this,U(this.doc,e))).bottom,s=e.left;if(t.style.position="absolute",t.setAttribute("cm-ignore-events","true"),this.display.input.setUneditable(t),o.sizer.appendChild(t),"over"==n)l=e.top;else if("above"==n||"near"==n){var a=Math.max(o.wrapper.clientHeight,this.doc.height),u=Math.max(o.sizer.clientWidth,o.lineSpace.clientWidth);("above"==n||e.bottom+t.offsetHeight>a)&&e.top>t.offsetHeight?l=e.top-t.offsetHeight:e.bottom+t.offsetHeight<=a&&(l=e.bottom),s+t.offsetWidth>u&&(s=u-t.offsetWidth)}t.style.top=l+"px",t.style.left=t.style.right="","right"==i?(s=o.sizer.clientWidth-t.offsetWidth,t.style.right="0px"):("left"==i?s=0:"middle"==i&&(s=(o.sizer.clientWidth-t.offsetWidth)/2),t.style.left=s+"px"),r&&Ur(this,{left:s,top:l,right:s+t.offsetWidth,bottom:l+t.offsetHeight})},triggerOnKeyDown:pn(Lo),triggerOnKeyPress:pn(Mo),triggerOnKeyUp:To,triggerOnMouseDown:pn(Oo),execCommand:function(e){if(Bs.hasOwnProperty(e))return Bs[e].call(null,this)},triggerElectric:pn(function(e){Zo(this,e)}),findPosH:function(e,t,r,n){var i=this,o=1;t<0&&(o=-1,t=-t);for(var l=U(this.doc,e),s=0;s<t&&!(l=tl(i.doc,l,o,r,n)).hitSide;++s);return l},moveH:pn(function(e,t){var r=this;this.extendSelectionsBy(function(n){return r.display.shift||r.doc.extend||n.empty()?tl(r.doc,n.head,e,t,r.options.rtlMoveVisually):e<0?n.from():n.to()},Vl)}),deleteH:pn(function(e,t){var r=this.doc.sel,n=this.doc;r.somethingSelected()?n.replaceSelection("",null,"+delete"):co(this,function(r){var i=tl(n,r.head,e,t,!1);return e<0?{from:i,to:r.head}:{from:r.head,to:i}})}),findPosV:function(e,t,r,n){var i=this,o=1,l=n;t<0&&(o=-1,t=-t);for(var s=U(this.doc,e),a=0;a<t;++a){var u=sr(i,s,"div");if(null==l?l=u.left:u.left=l,(s=rl(i,u,o,r)).hitSide)break}return s},moveV:pn(function(e,t){var r=this,n=this.doc,i=[],o=!this.display.shift&&!n.extend&&n.sel.somethingSelected();if(n.extendSelectionsBy(function(l){if(o)return e<0?l.from():l.to();var s=sr(r,l.head,"div");null!=l.goalColumn&&(s.left=l.goalColumn),i.push(s.left);var a=rl(r,s,e,t);return"page"==t&&l==n.sel.primary()&&Kr(r,lr(r,a,"div").top-s.top),a},Vl),i.length)for(var l=0;l<n.sel.ranges.length;l++)n.sel.ranges[l].goalColumn=i[l]}),findWordAt:function(e){var t=M(this.doc,e.line).text,r=e.ch,n=e.ch;if(t){var i=this.getHelper(e,"wordChars");"before"!=e.sticky&&n!=t.length||!r?++n:--r;for(var o=t.charAt(r),l=x(o,i)?function(e){return x(e,i)}:/\s/.test(o)?function(e){return/\s/.test(e)}:function(e){return!/\s/.test(e)&&!x(e)};r>0&&l(t.charAt(r-1));)--r;for(;n<t.length&&l(t.charAt(n));)++n}return new Ts(E(e.line,r),E(e.line,n))},toggleOverwrite:function(e){null!=e&&e==this.state.overwrite||((this.state.overwrite=!this.state.overwrite)?s(this.display.cursorDiv,"CodeMirror-overwrite"):Fl(this.display.cursorDiv,"CodeMirror-overwrite"),Te(this,"overwriteToggle",this,this.state.overwrite))},hasFocus:function(){return this.display.input.getField()==l()},isReadOnly:function(){return!(!this.options.readOnly&&!this.doc.cantEdit)},scrollTo:pn(function(e,t){Xr(this,e,t)}),getScrollInfo:function(){var e=this.display.scroller;return{left:e.scrollLeft,top:e.scrollTop,height:e.scrollHeight-zt(this)-this.display.barHeight,width:e.scrollWidth-zt(this)-this.display.barWidth,clientHeight:Bt(this),clientWidth:Rt(this)}},scrollIntoView:pn(function(e,t){null==e?(e={from:this.doc.sel.primary().head,to:null},null==t&&(t=this.options.cursorScrollMargin)):"number"==typeof e?e={from:E(e,0),to:null}:null==e.from&&(e={from:e,to:null}),e.to||(e.to=e.from),e.margin=t||0,null!=e.from.line?Yr(this,e):$r(this,e.from,e.to,e.margin)}),setSize:pn(function(e,t){var r=this,n=function(e){return"number"==typeof e||/^\d+$/.test(String(e))?e+"px":e};null!=e&&(this.display.wrapper.style.width=n(e)),null!=t&&(this.display.wrapper.style.height=n(t)),this.options.lineWrapping&&Jt(this);var i=this.display.viewFrom;this.doc.iter(i,this.display.viewTo,function(e){if(e.widgets)for(var t=0;t<e.widgets.length;t++)if(e.widgets[t].noHScroll){mn(r,i,"widget");break}++i}),this.curOp.forceUpdate=!0,Te(this,"refresh",this)}),operation:function(e){return hn(this,e)},startOperation:function(){return nn(this)},endOperation:function(){return on(this)},refresh:pn(function(){var e=this.display.cachedTextHeight;vn(this),this.curOp.forceUpdate=!0,er(this),Xr(this,this.doc.scrollLeft,this.doc.scrollTop),Wn(this),(null==e||Math.abs(e-mr(this.display))>.5)&&Cr(this),Te(this,"refresh",this)}),swapDoc:pn(function(e){var t=this.doc;return t.cm=null,qn(this,e),er(this),this.display.input.reset(),Xr(this,e.scrollLeft,e.scrollTop),this.curOp.forceScroll=!0,bt(this,"swapDoc",this,t),t}),getInputField:function(){return this.display.input.getField()},getWrapperElement:function(){return this.display.wrapper},getScrollerElement:function(){return this.display.scroller},getGutterElement:function(){return this.display.gutters}},Ae(e),e.registerHelper=function(t,n,i){r.hasOwnProperty(t)||(r[t]=e[t]={_global:[]}),r[t][n]=i},e.registerGlobalHelper=function(t,n,i,o){e.registerHelper(t,n,o),r[t]._global.push({pred:i,val:o})}}(jo);var Js="iter insert remove copy getEditor constructor".split(" ");for(var ea in Ds.prototype)Ds.prototype.hasOwnProperty(ea)&&h(Js,ea)<0&&(jo.prototype[ea]=function(e){return function(){return e.apply(this.doc,arguments)}}(Ds.prototype[ea]));return Ae(Ds),jo.inputStyles={textarea:Qs,contenteditable:Zs},jo.defineMode=function(e){jo.defaults.mode||"null"==e||(jo.defaults.mode=e),Be.apply(this,arguments)},jo.defineMIME=function(e,t){os[e]=t},jo.defineMode("null",function(){return{token:function(e){return e.skipToEnd()}}}),jo.defineMIME("text/plain","null"),jo.defineExtension=function(e,t){jo.prototype[e]=t},jo.defineDocExtension=function(e,t){Ds.prototype[e]=t},jo.fromTextArea=function(e,t){function r(){e.value=a.getValue()}if(t=t?c(t):{},t.value=e.value,!t.tabindex&&e.tabIndex&&(t.tabindex=e.tabIndex),!t.placeholder&&e.placeholder&&(t.placeholder=e.placeholder),null==t.autofocus){var n=l();t.autofocus=n==e||null!=e.getAttribute("autofocus")&&n==document.body}var i;if(e.form&&(Ql(e.form,"submit",r),!t.leaveSubmitMethodAlone)){var o=e.form;i=o.submit;try{var s=o.submit=function(){r(),o.submit=i,o.submit(),o.submit=s}}catch(e){}}t.finishInit=function(t){t.save=r,t.getTextArea=function(){return e},t.toTextArea=function(){t.toTextArea=isNaN,r(),e.parentNode.removeChild(t.getWrapperElement()),e.style.display="",e.form&&(ke(e.form,"submit",r),"function"==typeof e.form.submit&&(e.form.submit=i))}},e.style.display="none";var a=jo(function(t){return e.parentNode.insertBefore(t,e.nextSibling)},t);return a},function(e){e.off=ke,e.on=Ql,e.wheelEventPixels=Pn,e.Doc=Ds,e.splitLines=es,e.countColumn=f,e.findColumn=d,e.isWordChar=w,e.Pass=Bl,e.signal=Te,e.Line=fs,e.changeEnd=Bn,e.scrollbarModel=ws,e.Pos=E,e.cmpPos=P,e.modes=is,e.mimeModes=os,e.resolveMode=Ge,e.getMode=Ue,e.modeExtensions=ls,e.extendMode=Ve,e.copyState=Ke,e.startState=Xe,e.innerMode=je,e.commands=Bs,e.keyMap=Rs,e.keyName=ao,e.isModifierKey=lo,e.lookupKey=oo,e.normalizeKeyMap=io,e.StringStream=ss,e.SharedTextMarker=As,e.TextMarker=Os,e.LineWidget=Ms,e.e_preventDefault=We,e.e_stopPropagation=De,e.e_stop=Fe,e.addClass=s,e.contains=o,e.rmClass=Fl,e.keyNames=Es}(jo),jo.version="5.30.0",jo});
      !function(e){"object"==typeof exports&&"object"==typeof module?e(require("../../lib/codemirror")):"function"==typeof define&&define.amd?define(["../../lib/codemirror"],e):e(CodeMirror)}(function(e){"use strict";function t(e,t,n,r,o,a){this.indented=e,this.column=t,this.type=n,this.info=r,this.align=o,this.prev=a}function n(e,n,r,o){var a=e.indented;return e.context&&"statement"==e.context.type&&"statement"!=r&&(a=e.context.indented),e.context=new t(a,n,r,o,null,e.context)}function r(e){var t=e.context.type;return")"!=t&&"]"!=t&&"}"!=t||(e.indented=e.context.indented),e.context=e.context.prev}function o(e,t,n){return"variable"==t.prevToken||"type"==t.prevToken||(!!/\S(?:[^- ]>|[*\]])\s*$|\*$/.test(e.string.slice(0,n))||(!(!t.typeAtEndOfLine||e.column()!=e.indentation())||void 0))}function a(e){for(;;){if(!e||"top"==e.type)return!0;if("}"==e.type&&"namespace"!=e.prev.info)return!1;e=e.prev}}function i(e){for(var t={},n=e.split(" "),r=0;r<n.length;++r)t[n[r]]=!0;return t}function l(e,t){return"function"==typeof e?e(t):e.propertyIsEnumerable(t)}function s(e,t){if(!t.startOfLine)return!1;for(var n,r=null;n=e.peek();){if("\\"==n&&e.match(/^.$/)){r=s;break}if("/"==n&&e.match(/^\/[\/\*]/,!1))break;e.next()}return t.tokenize=r,"meta"}function c(e,t){return"type"==t.prevToken&&"type"}function u(e){return e.eatWhile(/[\w\.']/),"number"}function d(e,t){if(e.backUp(1),e.match(/(R|u8R|uR|UR|LR)/)){var n=e.match(/"([^\s\\()]{0,16})\(/);return!!n&&(t.cpp11RawStringDelim=n[1],t.tokenize=m,m(e,t))}return e.match(/(u8|u|U|L)/)?!!e.match(/["']/,!1)&&"string":(e.next(),!1)}function f(e){var t=/(\w+)::~?(\w+)$/.exec(e);return t&&t[1]==t[2]}function p(e,t){for(var n;null!=(n=e.next());)if('"'==n&&!e.eat('"')){t.tokenize=null;break}return"string"}function m(e,t){var n=t.cpp11RawStringDelim.replace(/[^\w\s]/g,"\\$&");return e.match(new RegExp(".*?\\)"+n+'"'))?t.tokenize=null:e.skipToEnd(),"string"}function h(t,n){function r(e){if(e)for(var t in e)e.hasOwnProperty(t)&&o.push(t)}"string"==typeof t&&(t=[t]);var o=[];r(n.keywords),r(n.types),r(n.builtin),r(n.atoms),o.length&&(n.helperType=t[0],e.registerHelper("hintWords",t[0],o));for(var a=0;a<t.length;++a)e.defineMIME(t[a],n)}function g(e,t){for(var n=!1;!e.eol();){if(!n&&e.match('"""')){t.tokenize=null;break}n="\\"==e.next()&&!n}return"string"}function y(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!e&&!o&&t.match('"')){a=!0;break}if(e&&t.match('"""')){a=!0;break}r=t.next(),!o&&"$"==r&&t.match("{")&&t.skipTo("}"),o=!o&&"\\"==r&&!e}return!a&&e||(n.tokenize=null),"string"}}function x(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!o&&t.match('"')&&("single"==e||t.match('""'))){a=!0;break}if(!o&&t.match("``")){w=x(e),a=!0;break}r=t.next(),o="single"==e&&!o&&"\\"==r}return a&&(n.tokenize=null),"string"}}e.defineMode("clike",function(i,s){function c(e,t){var n=e.next();if(S[n]){var r=S[n](e,t);if(!1!==r)return r}if('"'==n||"'"==n)return t.tokenize=u(n),t.tokenize(e,t);if(D.test(n))return p=n,null;if(L.test(n)){if(e.backUp(1),e.match(I))return"number";e.next()}if("/"==n){if(e.eat("*"))return t.tokenize=d,d(e,t);if(e.eat("/"))return e.skipToEnd(),"comment"}if(F.test(n)){for(;!e.match(/^\/[\/*]/,!1)&&e.eat(F););return"operator"}if(e.eatWhile(z),P)for(;e.match(P);)e.eatWhile(z);var o=e.current();return l(x,o)?(l(w,o)&&(p="newstatement"),l(v,o)&&(m=!0),"keyword"):l(b,o)?"type":l(k,o)?(l(w,o)&&(p="newstatement"),"builtin"):l(_,o)?"atom":"variable"}function u(e){return function(t,n){for(var r,o=!1,a=!1;null!=(r=t.next());){if(r==e&&!o){a=!0;break}o=!o&&"\\"==r}return(a||!o&&!C)&&(n.tokenize=null),"string"}}function d(e,t){for(var n,r=!1;n=e.next();){if("/"==n&&r){t.tokenize=null;break}r="*"==n}return"comment"}function f(e,t){s.typeFirstDefinitions&&e.eol()&&a(t.context)&&(t.typeAtEndOfLine=o(e,t,e.pos))}var p,m,h=i.indentUnit,g=s.statementIndentUnit||h,y=s.dontAlignCalls,x=s.keywords||{},b=s.types||{},k=s.builtin||{},w=s.blockKeywords||{},v=s.defKeywords||{},_=s.atoms||{},S=s.hooks||{},C=s.multiLineStrings,T=!1!==s.indentStatements,M=!1!==s.indentSwitch,P=s.namespaceSeparator,D=s.isPunctuationChar||/[\[\]{}\(\),;\:\.]/,L=s.numberStart||/[\d\.]/,I=s.number||/^(?:0x[a-f\d]+|0b[01]+|(?:\d+\.?\d*|\.\d+)(?:e[-+]?\d+)?)(u|ll?|l|f)?/i,F=s.isOperatorChar||/[+\-*&%=<>!?|\/]/,z=s.isIdentifierChar||/[\w\$_\xa1-\uffff]/;return{startState:function(e){return{tokenize:null,context:new t((e||0)-h,0,"top",null,!1),indented:0,startOfLine:!0,prevToken:null}},token:function(e,t){var i=t.context;if(e.sol()&&(null==i.align&&(i.align=!1),t.indented=e.indentation(),t.startOfLine=!0),e.eatSpace())return f(e,t),null;p=m=null;var l=(t.tokenize||c)(e,t);if("comment"==l||"meta"==l)return l;if(null==i.align&&(i.align=!0),";"==p||":"==p||","==p&&e.match(/^\s*(?:\/\/.*)?$/,!1))for(;"statement"==t.context.type;)r(t);else if("{"==p)n(t,e.column(),"}");else if("["==p)n(t,e.column(),"]");else if("("==p)n(t,e.column(),")");else if("}"==p){for(;"statement"==i.type;)i=r(t);for("}"==i.type&&(i=r(t));"statement"==i.type;)i=r(t)}else p==i.type?r(t):T&&(("}"==i.type||"top"==i.type)&&";"!=p||"statement"==i.type&&"newstatement"==p)&&n(t,e.column(),"statement",e.current());if("variable"==l&&("def"==t.prevToken||s.typeFirstDefinitions&&o(e,t,e.start)&&a(t.context)&&e.match(/^\s*\(/,!1))&&(l="def"),S.token){var u=S.token(e,t,l);void 0!==u&&(l=u)}return"def"==l&&!1===s.styleDefs&&(l="variable"),t.startOfLine=!1,t.prevToken=m?"def":l||p,f(e,t),l},indent:function(t,n){if(t.tokenize!=c&&null!=t.tokenize||t.typeAtEndOfLine)return e.Pass;var r=t.context,o=n&&n.charAt(0);if("statement"==r.type&&"}"==o&&(r=r.prev),s.dontIndentStatements)for(;"statement"==r.type&&s.dontIndentStatements.test(r.info);)r=r.prev;if(S.indent){var a=S.indent(t,r,n);if("number"==typeof a)return a}var i=o==r.type,l=r.prev&&"switch"==r.prev.info;if(s.allmanIndentation&&/[{(]/.test(o)){for(;"top"!=r.type&&"}"!=r.type;)r=r.prev;return r.indented}return"statement"==r.type?r.indented+("{"==o?0:g):!r.align||y&&")"==r.type?")"!=r.type||i?r.indented+(i?0:h)+(i||!l||/^(?:case|default)\b/.test(n)?0:h):r.indented+g:r.column+(i?0:1)},electricInput:M?/^\s*(?:case .*?:|default:|\{\}?|\})$/:/^\s*[{}]$/,blockCommentStart:"/*",blockCommentEnd:"*/",lineComment:"//",fold:"brace"}});var b="auto if break case register continue return default do sizeof static else struct switch extern typedef union for goto while enum const volatile",k="int long char short double float unsigned signed void size_t ptrdiff_t";h(["text/x-csrc","text/x-c","text/x-chdr"],{name:"clike",keywords:i(b),types:i(k+" bool _Complex _Bool float_t double_t intptr_t intmax_t int8_t int16_t int32_t int64_t uintptr_t uintmax_t uint8_t uint16_t uint32_t uint64_t"),blockKeywords:i("case do else for if switch while struct"),defKeywords:i("struct"),typeFirstDefinitions:!0,atoms:i("null true false"),hooks:{"#":s,"*":c},modeProps:{fold:["brace","include"]}}),h(["text/x-c++src","text/x-c++hdr"],{name:"clike",keywords:i(b+" asm dynamic_cast namespace reinterpret_cast try explicit new static_cast typeid catch operator template typename class friend private this using const_cast inline public throw virtual delete mutable protected alignas alignof constexpr decltype nullptr noexcept thread_local final static_assert override"),types:i(k+" bool wchar_t"),blockKeywords:i("catch class do else finally for if struct switch try while"),defKeywords:i("class namespace struct enum union"),typeFirstDefinitions:!0,atoms:i("true false null"),dontIndentStatements:/^template$/,isIdentifierChar:/[\w\$_~\xa1-\uffff]/,hooks:{"#":s,"*":c,u:d,U:d,L:d,R:d,0:u,1:u,2:u,3:u,4:u,5:u,6:u,7:u,8:u,9:u,token:function(e,t,n){if("variable"==n&&"("==e.peek()&&(";"==t.prevToken||null==t.prevToken||"}"==t.prevToken)&&f(e.current()))return"def"}},namespaceSeparator:"::",modeProps:{fold:["brace","include"]}}),h("text/x-java",{name:"clike",keywords:i("abstract assert break case catch class const continue default do else enum extends final finally float for goto if implements import instanceof interface native new package private protected public return static strictfp super switch synchronized this throw throws transient try volatile while @interface"),types:i("byte short int long float double boolean char void Boolean Byte Character Double Float Integer Long Number Object Short String StringBuffer StringBuilder Void"),blockKeywords:i("catch class do else finally for if switch try while"),defKeywords:i("class interface package enum @interface"),typeFirstDefinitions:!0,atoms:i("true false null"),number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,hooks:{"@":function(e){return!e.match("interface",!1)&&(e.eatWhile(/[\w\$_]/),"meta")}},modeProps:{fold:["brace","import"]}}),h("text/x-csharp",{name:"clike",keywords:i("abstract as async await base break case catch checked class const continue default delegate do else enum event explicit extern finally fixed for foreach goto if implicit in interface internal is lock namespace new operator out override params private protected public readonly ref return sealed sizeof stackalloc static struct switch this throw try typeof unchecked unsafe using virtual void volatile while add alias ascending descending dynamic from get global group into join let orderby partial remove select set value var yield"),types:i("Action Boolean Byte Char DateTime DateTimeOffset Decimal Double Func Guid Int16 Int32 Int64 Object SByte Single String Task TimeSpan UInt16 UInt32 UInt64 bool byte char decimal double short int long object sbyte float string ushort uint ulong"),blockKeywords:i("catch class do else finally for foreach if struct switch try while"),defKeywords:i("class interface namespace struct var"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"@":function(e,t){return e.eat('"')?(t.tokenize=p,p(e,t)):(e.eatWhile(/[\w\$_]/),"meta")}}}),h("text/x-scala",{name:"clike",keywords:i("abstract case catch class def do else extends final finally for forSome if implicit import lazy match new null object override package private protected return sealed super this throw trait try type val var while with yield _ assert assume require print println printf readLine readBoolean readByte readShort readChar readInt readLong readFloat readDouble"),types:i("AnyVal App Application Array BufferedIterator BigDecimal BigInt Char Console Either Enumeration Equiv Error Exception Fractional Function IndexedSeq Int Integral Iterable Iterator List Map Numeric Nil NotNull Option Ordered Ordering PartialFunction PartialOrdering Product Proxy Range Responder Seq Serializable Set Specializable Stream StringBuilder StringContext Symbol Throwable Traversable TraversableOnce Tuple Unit Vector Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),multiLineStrings:!0,blockKeywords:i("catch class enum do else finally for forSome if match switch try while"),defKeywords:i("class enum def object package trait type val var"),atoms:i("true false null"),indentStatements:!1,indentSwitch:!1,isOperatorChar:/[+\-*&%=<>!?|\/#:@]/,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return!!e.match('""')&&(t.tokenize=g,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},"=":function(e,n){var r=n.context;return!("}"!=r.type||!r.align||!e.eat(">"))&&(n.context=new t(r.indented,r.column,r.type,r.info,null,r.prev),"operator")}},modeProps:{closeBrackets:{triples:'"'}}}),h("text/x-kotlin",{name:"clike",keywords:i("package as typealias class interface this super val var fun for is in This throw return break continue object if else while do try when !in !is as? file import where by get set abstract enum open inner override private public internal protected catch finally out final vararg reified dynamic companion constructor init sealed field property receiver param sparam lateinit data inline noinline tailrec external annotation crossinline const operator infix suspend"),types:i("Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),intendSwitch:!1,indentStatements:!1,multiLineStrings:!0,number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,blockKeywords:i("catch class do else finally for if where try while enum"),defKeywords:i("class val var object package interface fun"),atoms:i("true false null this"),hooks:{'"':function(e,t){return t.tokenize=y(e.match('""')),t.tokenize(e,t)}},modeProps:{closeBrackets:{triples:'"'}}}),h(["x-shader/x-vertex","x-shader/x-fragment"],{name:"clike",keywords:i("sampler1D sampler2D sampler3D samplerCube sampler1DShadow sampler2DShadow const attribute uniform varying break continue discard return for while do if else struct in out inout"),types:i("float int bool void vec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4 mat2 mat3 mat4"),blockKeywords:i("for while do if else struct"),builtin:i("radians degrees sin cos tan asin acos atan pow exp log exp2 sqrt inversesqrt abs sign floor ceil fract mod min max clamp mix step smoothstep length distance dot cross normalize ftransform faceforward reflect refract matrixCompMult lessThan lessThanEqual greaterThan greaterThanEqual equal notEqual any all not texture1D texture1DProj texture1DLod texture1DProjLod texture2D texture2DProj texture2DLod texture2DProjLod texture3D texture3DProj texture3DLod texture3DProjLod textureCube textureCubeLod shadow1D shadow2D shadow1DProj shadow2DProj shadow1DLod shadow2DLod shadow1DProjLod shadow2DProjLod dFdx dFdy fwidth noise1 noise2 noise3 noise4"),atoms:i("true false gl_FragColor gl_SecondaryColor gl_Normal gl_Vertex gl_MultiTexCoord0 gl_MultiTexCoord1 gl_MultiTexCoord2 gl_MultiTexCoord3 gl_MultiTexCoord4 gl_MultiTexCoord5 gl_MultiTexCoord6 gl_MultiTexCoord7 gl_FogCoord gl_PointCoord gl_Position gl_PointSize gl_ClipVertex gl_FrontColor gl_BackColor gl_FrontSecondaryColor gl_BackSecondaryColor gl_TexCoord gl_FogFragCoord gl_FragCoord gl_FrontFacing gl_FragData gl_FragDepth gl_ModelViewMatrix gl_ProjectionMatrix gl_ModelViewProjectionMatrix gl_TextureMatrix gl_NormalMatrix gl_ModelViewMatrixInverse gl_ProjectionMatrixInverse gl_ModelViewProjectionMatrixInverse gl_TexureMatrixTranspose gl_ModelViewMatrixInverseTranspose gl_ProjectionMatrixInverseTranspose gl_ModelViewProjectionMatrixInverseTranspose gl_TextureMatrixInverseTranspose gl_NormalScale gl_DepthRange gl_ClipPlane gl_Point gl_FrontMaterial gl_BackMaterial gl_LightSource gl_LightModel gl_FrontLightModelProduct gl_BackLightModelProduct gl_TextureColor gl_EyePlaneS gl_EyePlaneT gl_EyePlaneR gl_EyePlaneQ gl_FogParameters gl_MaxLights gl_MaxClipPlanes gl_MaxTextureUnits gl_MaxTextureCoords gl_MaxVertexAttribs gl_MaxVertexUniformComponents gl_MaxVaryingFloats gl_MaxVertexTextureImageUnits gl_MaxTextureImageUnits gl_MaxFragmentUniformComponents gl_MaxCombineTextureImageUnits gl_MaxDrawBuffers"),indentSwitch:!1,hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-nesc",{name:"clike",keywords:i(b+"as atomic async call command component components configuration event generic implementation includes interface module new norace nx_struct nx_union post provides signal task uses abstract extends"),types:i(k),blockKeywords:i("case do else for if switch while struct"),atoms:i("null true false"),hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-objectivec",{name:"clike",keywords:i(b+"inline restrict _Bool _Complex _Imaginary BOOL Class bycopy byref id IMP in inout nil oneway out Protocol SEL self super atomic nonatomic retain copy readwrite readonly"),types:i(k),atoms:i("YES NO NULL NILL ON OFF true false"),hooks:{"@":function(e){return e.eatWhile(/[\w\$]/),"keyword"},"#":s,indent:function(e,t,n){if("statement"==t.type&&/^@\w/.test(n))return t.indented}},modeProps:{fold:"brace"}}),h("text/x-squirrel",{name:"clike",keywords:i("base break clone continue const default delete enum extends function in class foreach local resume return this throw typeof yield constructor instanceof static"),types:i(k),blockKeywords:i("case catch class else for foreach if switch try while"),defKeywords:i("function local class"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"#":s},modeProps:{fold:["brace","include"]}});var w=null;h("text/x-ceylon",{name:"clike",keywords:i("abstracts alias assembly assert assign break case catch class continue dynamic else exists extends finally for function given if import in interface is let module new nonempty object of out outer package return satisfies super switch then this throw try value void while"),types:function(e){var t=e.charAt(0);return t===t.toUpperCase()&&t!==t.toLowerCase()},blockKeywords:i("case catch class dynamic else finally for function if interface module new object switch try while"),defKeywords:i("class dynamic function interface module object package value"),builtin:i("abstract actual aliased annotation by default deprecated doc final formal late license native optional sealed see serializable shared suppressWarnings tagged throws variable"),isPunctuationChar:/[\[\]{}\(\),;\:\.`]/,isOperatorChar:/[+\-*&%=<>!?|^~:\/]/,numberStart:/[\d#$]/,number:/^(?:#[\da-fA-F_]+|\$[01_]+|[\d_]+[kMGTPmunpf]?|[\d_]+\.[\d_]+(?:[eE][-+]?\d+|[kMGTPmunpf]|)|)/i,multiLineStrings:!0,typeFirstDefinitions:!0,atoms:i("true false null larger smaller equal empty finished"),indentSwitch:!1,styleDefs:!1,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return t.tokenize=x(e.match('""')?"triple":"single"),t.tokenize(e,t)},"`":function(e,t){return!(!w||!e.match("`"))&&(t.tokenize=w,w=null,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},token:function(e,t,n){if(("variable"==n||"type"==n)&&"."==t.prevToken)return"variable-2"}},modeProps:{fold:["brace","import"],closeBrackets:{triples:'"'}}})});
      // -------------------------------------------------------------------------
//  Part of the CodeChecker project, under the Apache License v2.0 with
//  LLVM Exceptions. See LICENSE for license information.
//  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
// -------------------------------------------------------------------------

var BugViewer = {
  _files : [],
  _reports : [],
  _lineWidgets : [],
  _navigationMenuItems : [],
  _sourceFileData : null,
  _currentReport : null,
  _lastBugEvent  : null,

  init : function (files, reports) {
    this._files = files;
    this._reports = reports;

    this.initEscapeChars();
  },

  initEscapeChars : function () {
    this.escapeChars = {
      ' ' : 'nbsp',
      '<' : 'lt',
      '>' : 'gt',
      '"' : 'quot',
      '&' : 'amp'
    };

    var regexString = '[';
    for (var key in this.escapeChars) {
      regexString += key;
    }
    regexString += ']';

    this.escapeRegExp = new RegExp( regexString, 'g');
  },

  escapeHTML : function (str) {
    var that = this;

    return str.replace(this.escapeRegExp, function (m) {
      return '&' + that.escapeChars[m] + ';';
    });
  },

  initByUrl : function () {
    if (!this._reports) return;

    var state = {};
    window.location.hash.substr(1).split('&').forEach(function (s) {
      var parts = s.split('=');
      state[parts[0]] = parts[1];
    });

    for (var key in this._reports) {
      var report = this._reports[key];
      if (report.reportHash === state['reportHash']) {
        this.navigate(report);
        return;
      }
    }

    this.navigate(this._reports[0]);
  },

  create : function () {
    this._content = document.getElementById('editor-wrapper');
    this._filepath = document.getElementById('file-path');
    this._checkerName = document.getElementById('checker-name');
    this._reviewStatusWrapper =
      document.getElementById('review-status-wrapper');
    this._reviewStatus = document.getElementById('review-status');
    this._editor = document.getElementById('editor');

    this._codeMirror = CodeMirror(this._editor, {
      mode: 'text/x-c++src',
      matchBrackets : true,
      lineNumbers : true,
      readOnly : true,
      foldGutter : true,
      extraKeys : {},
      viewportMargin : 100
    });

    this._createNavigationMenu();
  },

  navigate : function (report, item) {
    if (!item) {
      var items = this._navigationMenuItems.filter(function (navItem) {
        return navItem.report.reportHash === report.reportHash;
      });

      if (!items.length) return;

      item = items[0].widget;
    }

    this._selectedReport.classList.remove('active');
    this._selectedReport = item;
    this._selectedReport.classList.add('active');
    this.setReport(report);
  },

  _createNavigationMenu : function () {
    var that = this;

    var nav = document.getElementById('report-nav');
    var list = document.createElement('ul');
    this._reports.forEach(function (report) {
      var events = report['events'];
      var lastBugEvent = events[events.length - 1];
      var item = document.createElement('li');

      var severity = document.createElement('i');
      severity.className = 'severity-' + report.severity.toLowerCase();

      item.appendChild(severity);
      item.appendChild(document.createTextNode(lastBugEvent.message));

      item.addEventListener('click', function () {
        that.navigate(report, item);
      })
      list.appendChild(item);
      that._navigationMenuItems.push({ report : report, widget : item });
    });

    if (!this._selectedReport && list.childNodes.length) {
      this._selectedReport = list.childNodes[0];
      this._selectedReport.classList.add('active');
    }

    nav.appendChild(list);
  },

  setReport : function (report) {
    this._currentReport = report;
    var events = report['events'];
    var lastBugEvent = events[events.length - 1];
    this.setCurrentBugEvent(lastBugEvent, events.length - 1);
    this.setCheckerName(report.checkerName);
    this.setReviewStatus(report.reviewStatus);

    window.location.hash = '#reportHash=' + report.reportHash;
  },

  setCurrentBugEvent : function (event, idx) {
    this._currentBugEvent = event;
    this.setSourceFileData(this._files[event.location.file]);
    this.drawBugPath();

    this.jumpTo(event.location.line, 0);
    this.highlightBugEvent(event, idx);
  },

  highlightBugEvent : function (event, idx) {
    this._lineWidgets.forEach(function (widget) {
      var lineIdx = widget.node.getAttribute('idx');
      if (parseInt(lineIdx) === idx) {
        widget.node.classList.add('current');
      }
    });
  },

  setCheckerName : function (checkerName) {
    this._checkerName.innerHTML = checkerName;
  },

  setReviewStatus : function (status) {
    if (status) {
      var className =
        'review-status-' + status.toLowerCase().split(' ').join('-');
      this._reviewStatus.className = "review-status " + className;

      this._reviewStatus.innerHTML = status;
      this._reviewStatusWrapper.style.display = 'block';
    } else {
      this._reviewStatusWrapper.style.display = 'none';
    }
  },

  setSourceFileData : function (file) {
    if (this._sourceFileData && file.id === this._sourceFileData.id) {
      return;
    }

    this._sourceFileData = file;
    this._filepath.innerHTML = file.path;
    this._codeMirror.doc.setValue(file.content);
    this._refresh();
  },

  _refresh : function () {
    var that = this;
    setTimeout(function () {
      var fullHeight = parseInt(that._content.clientHeight);
      var headerHeight = that._filepath.clientHeight;

      that._codeMirror.setSize('auto', fullHeight - headerHeight);
      that._codeMirror.refresh();
    }, 200);
  },

  clearBubbles : function () {
    this._lineWidgets.forEach(function (widget) { widget.clear(); });
    this._lineWidgets = [];
  },

  getMessage : function (event, kind) {
    if (kind === 'macro') {
      var name = 'macro expansion' + (event.name ? ': ' + event.name : '');

      return '<span class="tag macro">' + name + '</span>'
        + this.escapeHTML(event.expansion).replace(/(?:\r\n|\r|\n)/g, '<br>');
    } else if (kind === 'note') {
      return '<span class="tag note">note</span>'
        +  this.escapeHTML(event.message).replace(/(?:\r\n|\r|\n)/g, '<br>');
    }
  },

  addExtraPathEvents : function (events, kind) {
    var that = this;

    if (!events) {
      return;
    }

    events.forEach(function (event) {
      if (event.location.file !== that._currentBugEvent.location.file) {
        return;
      }

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + kind);

      var msg = document.createElement('span');
      msg.innerHTML = that.getMessage(event, kind);
      element.appendChild(msg);

      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  drawBugPath : function () {
    var that = this;

    this.clearBubbles();

    this.addExtraPathEvents(this._currentReport.macros, 'macro');
    this.addExtraPathEvents(this._currentReport.notes, 'note');

    // Processing bug path events.
    var currentEvents = this._currentReport.events;
    currentEvents.forEach(function (event, step) {
      if (event.location.file !== that._currentBugEvent.location.file)
        return;

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';
      var type = step === currentEvents.length - 1 ? 'error' : 'info';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + type);
      element.setAttribute('idx', step);

      var enumeration = document.createElement('span');
      enumeration.setAttribute('class', 'checker-enum ' + type);
      enumeration.innerHTML = step + 1;

      if (currentEvents.length > 1)
        element.appendChild(enumeration);

      var prevBugEvent = step - 1;
      if (step > 0) {
        var prevBug = document.createElement('span');
        prevBug.setAttribute('class', 'arrow left-arrow');
        prevBug.addEventListener('click', function () {
          var event = currentEvents[prevBugEvent];
          that.setCurrentBugEvent(event, prevBugEvent);
        });
        element.appendChild(prevBug);
      }

      var msg = document.createElement('span');
      msg.innerHTML = that.escapeHTML(event.message)
        .replace(/(?:\r\n|\r|\n)/g, '<br>');

      element.appendChild(msg);

      var nextBugEvent = step + 1;
      if (nextBugEvent < currentEvents.length) {
        var nextBug = document.createElement('span');
        nextBug.setAttribute('class', 'arrow right-arrow');
        nextBug.addEventListener('click', function () {
          var event = currentEvents[nextBugEvent];
          that.setCurrentBugEvent(event, nextBugEvent);
        });
        element.appendChild(nextBug);
      }


      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  jumpTo : function (line, column) {
    var that = this;

    setTimeout(function () {
      var selPosPixel
        = that._codeMirror.charCoords({ line : line, ch : column }, 'local');
      var editorSize = {
        width  : that._editor.clientWidth,
        height : that._editor.clientHeight
      };

      that._codeMirror.scrollIntoView({
        top    : selPosPixel.top - 100,
        bottom : selPosPixel.top + editorSize.height - 150,
        left   : selPosPixel.left < editorSize.width - 100
               ? 0
               : selPosPixel.left - 50,
        right  : selPosPixel.left < editorSize.width - 100
               ? 10
               : selPosPixel.left + editorSize.width - 100
      });
    }, 0);
  }
}


      var data = {"files": {"3": {"id": 3, "path": "/home/vsts/work/1/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp", "content": "//===- BitcodeReader.cpp - Internal BitcodeReader implementation ----------===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#include \"llvm/Bitcode/BitcodeReader.h\"\n#include \"MetadataLoader.h\"\n#include \"ValueList.h\"\n#include \"llvm/ADT/APFloat.h\"\n#include \"llvm/ADT/APInt.h\"\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/ADT/DenseMap.h\"\n#include \"llvm/ADT/Optional.h\"\n#include \"llvm/ADT/STLExtras.h\"\n#include \"llvm/ADT/SmallString.h\"\n#include \"llvm/ADT/SmallVector.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/ADT/Triple.h\"\n#include \"llvm/ADT/Twine.h\"\n#include \"llvm/Bitcode/BitcodeCommon.h\"\n#include \"llvm/Bitcode/LLVMBitCodes.h\"\n#include \"llvm/Bitstream/BitstreamReader.h\"\n#include \"llvm/Config/llvm-config.h\"\n#include \"llvm/IR/Argument.h\"\n#include \"llvm/IR/Attributes.h\"\n#include \"llvm/IR/AutoUpgrade.h\"\n#include \"llvm/IR/BasicBlock.h\"\n#include \"llvm/IR/CallingConv.h\"\n#include \"llvm/IR/Comdat.h\"\n#include \"llvm/IR/Constant.h\"\n#include \"llvm/IR/Constants.h\"\n#include \"llvm/IR/DataLayout.h\"\n#include \"llvm/IR/DebugInfo.h\"\n#include \"llvm/IR/DebugInfoMetadata.h\"\n#include \"llvm/IR/DebugLoc.h\"\n#include \"llvm/IR/DerivedTypes.h\"\n#include \"llvm/IR/Function.h\"\n#include \"llvm/IR/GVMaterializer.h\"\n#include \"llvm/IR/GlobalAlias.h\"\n#include \"llvm/IR/GlobalIFunc.h\"\n#include \"llvm/IR/GlobalIndirectSymbol.h\"\n#include \"llvm/IR/GlobalObject.h\"\n#include \"llvm/IR/GlobalValue.h\"\n#include \"llvm/IR/GlobalVariable.h\"\n#include \"llvm/IR/InlineAsm.h\"\n#include \"llvm/IR/InstIterator.h\"\n#include \"llvm/IR/InstrTypes.h\"\n#include \"llvm/IR/Instruction.h\"\n#include \"llvm/IR/Instructions.h\"\n#include \"llvm/IR/Intrinsics.h\"\n#include \"llvm/IR/LLVMContext.h\"\n#include \"llvm/IR/Metadata.h\"\n#include \"llvm/IR/Module.h\"\n#include \"llvm/IR/ModuleSummaryIndex.h\"\n#include \"llvm/IR/Operator.h\"\n#include \"llvm/IR/Type.h\"\n#include \"llvm/IR/Value.h\"\n#include \"llvm/IR/Verifier.h\"\n#include \"llvm/Support/AtomicOrdering.h\"\n#include \"llvm/Support/Casting.h\"\n#include \"llvm/Support/CommandLine.h\"\n#include \"llvm/Support/Compiler.h\"\n#include \"llvm/Support/Debug.h\"\n#include \"llvm/Support/Error.h\"\n#include \"llvm/Support/ErrorHandling.h\"\n#include \"llvm/Support/ErrorOr.h\"\n#include \"llvm/Support/ManagedStatic.h\"\n#include \"llvm/Support/MathExtras.h\"\n#include \"llvm/Support/MemoryBuffer.h\"\n#include \"llvm/Support/raw_ostream.h\"\n#include <algorithm>\n#include <cassert>\n#include <cstddef>\n#include <cstdint>\n#include <deque>\n#include <map>\n#include <memory>\n#include <set>\n#include <string>\n#include <system_error>\n#include <tuple>\n#include <utility>\n#include <vector>\n\nusing namespace llvm;\n\nstatic cl::opt<bool> PrintSummaryGUIDs(\n    \"print-summary-global-ids\", cl::init(false), cl::Hidden,\n    cl::desc(\n        \"Print the global id for each value when reading the module summary\"));\n\nnamespace {\n\nenum {\n  SWITCH_INST_MAGIC = 0x4B5 // May 2012 => 1205 => Hex\n};\n\n} // end anonymous namespace\n\nstatic Error error(const Twine &Message) {\n  return make_error<StringError>(\n      Message, make_error_code(BitcodeError::CorruptedBitcode));\n}\n\nstatic Error hasInvalidBitcodeHeader(BitstreamCursor &Stream) {\n  if (!Stream.canSkipToPos(4))\n    return createStringError(std::errc::illegal_byte_sequence,\n                             \"file too small to contain bitcode header\");\n  for (unsigned C : {'B', 'C'})\n    if (Expected<SimpleBitstreamCursor::word_t> Res = Stream.Read(8)) {\n      if (Res.get() != C)\n        return createStringError(std::errc::illegal_byte_sequence,\n                                 \"file doesn't start with bitcode header\");\n    } else\n      return Res.takeError();\n  for (unsigned C : {0x0, 0xC, 0xE, 0xD})\n    if (Expected<SimpleBitstreamCursor::word_t> Res = Stream.Read(4)) {\n      if (Res.get() != C)\n        return createStringError(std::errc::illegal_byte_sequence,\n                                 \"file doesn't start with bitcode header\");\n    } else\n      return Res.takeError();\n  return Error::success();\n}\n\nstatic Expected<BitstreamCursor> initStream(MemoryBufferRef Buffer) {\n  const unsigned char *BufPtr = (const unsigned char *)Buffer.getBufferStart();\n  const unsigned char *BufEnd = BufPtr + Buffer.getBufferSize();\n\n  if (Buffer.getBufferSize() & 3)\n    return error(\"Invalid bitcode signature\");\n\n  // If we have a wrapper header, parse it and ignore the non-bc file contents.\n  // The magic number is 0x0B17C0DE stored in little endian.\n  if (isBitcodeWrapper(BufPtr, BufEnd))\n    if (SkipBitcodeWrapperHeader(BufPtr, BufEnd, true))\n      return error(\"Invalid bitcode wrapper header\");\n\n  BitstreamCursor Stream(ArrayRef<uint8_t>(BufPtr, BufEnd));\n  if (Error Err = hasInvalidBitcodeHeader(Stream))\n    return std::move(Err);\n\n  return std::move(Stream);\n}\n\n/// Convert a string from a record into an std::string, return true on failure.\ntemplate <typename StrTy>\nstatic bool convertToString(ArrayRef<uint64_t> Record, unsigned Idx,\n                            StrTy &Result) {\n  if (Idx > Record.size())\n    return true;\n\n  Result.append(Record.begin() + Idx, Record.end());\n  return false;\n}\n\n// Strip all the TBAA attachment for the module.\nstatic void stripTBAA(Module *M) {\n  for (auto &F : *M) {\n    if (F.isMaterializable())\n      continue;\n    for (auto &I : instructions(F))\n      I.setMetadata(LLVMContext::MD_tbaa, nullptr);\n  }\n}\n\n/// Read the \"IDENTIFICATION_BLOCK_ID\" block, do some basic enforcement on the\n/// \"epoch\" encoded in the bitcode, and return the producer name if any.\nstatic Expected<std::string> readIdentificationBlock(BitstreamCursor &Stream) {\n  if (Error Err = Stream.EnterSubBlock(bitc::IDENTIFICATION_BLOCK_ID))\n    return std::move(Err);\n\n  // Read all the records.\n  SmallVector<uint64_t, 64> Record;\n\n  std::string ProducerIdentification;\n\n  while (true) {\n    BitstreamEntry Entry;\n    if (Expected<BitstreamEntry> Res = Stream.advance())\n      Entry = Res.get();\n    else\n      return Res.takeError();\n\n    switch (Entry.Kind) {\n    default:\n    case BitstreamEntry::Error:\n      return error(\"Malformed block\");\n    case BitstreamEntry::EndBlock:\n      return ProducerIdentification;\n    case BitstreamEntry::Record:\n      // The interesting case.\n      break;\n    }\n\n    // Read a record.\n    Record.clear();\n    Expected<unsigned> MaybeBitCode = Stream.readRecord(Entry.ID, Record);\n    if (!MaybeBitCode)\n      return MaybeBitCode.takeError();\n    switch (MaybeBitCode.get()) {\n    default: // Default behavior: reject\n      return error(\"Invalid value\");\n    case bitc::IDENTIFICATION_CODE_STRING: // IDENTIFICATION: [strchr x N]\n      convertToString(Record, 0, ProducerIdentification);\n      break;\n    case bitc::IDENTIFICATION_CODE_EPOCH: { // EPOCH: [epoch#]\n      unsigned epoch = (unsigned)Record[0];\n      if (epoch != bitc::BITCODE_CURRENT_EPOCH) {\n        return error(\n          Twine(\"Incompatible epoch: Bitcode '\") + Twine(epoch) +\n          \"' vs current: '\" + Twine(bitc::BITCODE_CURRENT_EPOCH) + \"'\");\n      }\n    }\n    }\n  }\n}\n\nstatic Expected<std::string> readIdentificationCode(BitstreamCursor &Stream) {\n  // We expect a number of well-defined blocks, though we don't necessarily\n  // need to understand them all.\n  while (true) {\n    if (Stream.AtEndOfStream())\n      return \"\";\n\n    BitstreamEntry Entry;\n    if (Expected<BitstreamEntry> Res = Stream.advance())\n      Entry = std::move(Res.get());\n    else\n      return Res.takeError();\n\n    switch (Entry.Kind) {\n    case BitstreamEntry::EndBlock:\n    case BitstreamEntry::Error:\n      return error(\"Malformed block\");\n\n    case BitstreamEntry::SubBlock:\n      if (Entry.ID == bitc::IDENTIFICATION_BLOCK_ID)\n        return readIdentificationBlock(Stream);\n\n      // Ignore other sub-blocks.\n      if (Error Err = Stream.SkipBlock())\n        return std::move(Err);\n      continue;\n    case BitstreamEntry::Record:\n      if (Expected<unsigned> Skipped = Stream.skipRecord(Entry.ID))\n        continue;\n      else\n        return Skipped.takeError();\n    }\n  }\n}\n\nstatic Expected<bool> hasObjCCategoryInModule(BitstreamCursor &Stream) {\n  if (Error Err = Stream.EnterSubBlock(bitc::MODULE_BLOCK_ID))\n    return std::move(Err);\n\n  SmallVector<uint64_t, 64> Record;\n  // Read all the records for this module.\n\n  while (true) {\n    Expected<BitstreamEntry> MaybeEntry = Stream.advanceSkippingSubblocks();\n    if (!MaybeEntry)\n      return MaybeEntry.takeError();\n    BitstreamEntry Entry = MaybeEntry.get();\n\n    switch (Entry.Kind) {\n    case BitstreamEntry::SubBlock: // Handled for us already.\n    case BitstreamEntry::Error:\n      return error(\"Malformed block\");\n    case BitstreamEntry::EndBlock:\n      return false;\n    case BitstreamEntry::Record:\n      // The interesting case.\n      break;\n    }\n\n    // Read a record.\n    Expected<unsigned> MaybeRecord = Stream.readRecord(Entry.ID, Record);\n    if (!MaybeRecord)\n      return MaybeRecord.takeError();\n    switch (MaybeRecord.get()) {\n    default:\n      break; // Default behavior, ignore unknown content.\n    case bitc::MODULE_CODE_SECTIONNAME: { // SECTIONNAME: [strchr x N]\n      std::string S;\n      if (convertToString(Record, 0, S))\n        return error(\"Invalid record\");\n      // Check for the i386 and other (x86_64, ARM) conventions\n      if (S.find(\"__DATA,__objc_catlist\") != std::string::npos ||\n          S.find(\"__OBJC,__category\") != std::string::npos)\n        return true;\n      break;\n    }\n    }\n    Record.clear();\n  }\n  llvm_unreachable(\"Exit infinite loop\");\n}\n\nstatic Expected<bool> hasObjCCategory(BitstreamCursor &Stream) {\n  // We expect a number of well-defined blocks, though we don't necessarily\n  // need to understand them all.\n  while (true) {\n    BitstreamEntry Entry;\n    if (Expected<BitstreamEntry> Res = Stream.advance())\n      Entry = std::move(Res.get());\n    else\n      return Res.takeError();\n\n    switch (Entry.Kind) {\n    case BitstreamEntry::Error:\n      return error(\"Malformed block\");\n    case BitstreamEntry::EndBlock:\n      return false;\n\n    case BitstreamEntry::SubBlock:\n      if (Entry.ID == bitc::MODULE_BLOCK_ID)\n        return hasObjCCategoryInModule(Stream);\n\n      // Ignore other sub-blocks.\n      if (Error Err = Stream.SkipBlock())\n        return std::move(Err);\n      continue;\n\n    case BitstreamEntry::Record:\n      if (Expected<unsigned> Skipped = Stream.skipRecord(Entry.ID))\n        continue;\n      else\n        return Skipped.takeError();\n    }\n  }\n}\n\nstatic Expected<std::string> readModuleTriple(BitstreamCursor &Stream) {\n  if (Error Err = Stream.EnterSubBlock(bitc::MODULE_BLOCK_ID))\n    return std::move(Err);\n\n  SmallVector<uint64_t, 64> Record;\n\n  std::string Triple;\n\n  // Read all the records for this module.\n  while (true) {\n    Expected<BitstreamEntry> MaybeEntry = Stream.advanceSkippingSubblocks();\n    if (!MaybeEntry)\n      return MaybeEntry.takeError();\n    BitstreamEntry Entry = MaybeEntry.get();\n\n    switch (Entry.Kind) {\n    case BitstreamEntry::SubBlock: // Handled for us already.\n    case BitstreamEntry::Error:\n      return error(\"Malformed block\");\n    case BitstreamEntry::EndBlock:\n      return Triple;\n    case BitstreamEntry::Record:\n      // The interesting case.\n      break;\n    }\n\n    // Read a record.\n    Expected<unsigned> MaybeRecord = Stream.readRecord(Entry.ID, Record);\n    if (!MaybeRecord)\n      return MaybeRecord.takeError();\n    switch (MaybeRecord.get()) {\n    default: break;  // Default behavior, ignore unknown content.\n    case bitc::MODULE_CODE_TRIPLE: {  // TRIPLE: [strchr x N]\n      std::string S;\n      if (convertToString(Record, 0, S))\n        return error(\"Invalid record\");\n      Triple = S;\n      break;\n    }\n    }\n    Record.clear();\n  }\n  llvm_unreachable(\"Exit infinite loop\");\n}\n\nstatic Expected<std::string> readTriple(BitstreamCursor &Stream) {\n  // We expect a number of well-defined blocks, though we don't necessarily\n  // need to understand them all.\n  while (true) {\n    Expected<BitstreamEntry> MaybeEntry = Stream.advance();\n    if (!MaybeEntry)\n      return MaybeEntry.takeError();\n    BitstreamEntry Entry = MaybeEntry.get();\n\n    switch (Entry.Kind) {\n    case BitstreamEntry::Error:\n      return error(\"Malformed block\");\n    case BitstreamEntry::EndBlock:\n      return \"\";\n\n    case BitstreamEntry::SubBlock:\n      if (Entry.ID == bitc::MODULE_BLOCK_ID)\n        return readModuleTriple(Stream);\n\n      // Ignore other sub-blocks.\n      if (Error Err = Stream.SkipBlock())\n        return std::move(Err);\n      continue;\n\n    case BitstreamEntry::Record:\n      if (llvm::Expected<unsigned> Skipped = Stream.skipRecord(Entry.ID))\n        continue;\n      else\n        return Skipped.takeError();\n    }\n  }\n}\n\nnamespace {\n\nclass BitcodeReaderBase {\nprotected:\n  BitcodeReaderBase(BitstreamCursor Stream, StringRef Strtab)\n      : Stream(std::move(Stream)), Strtab(Strtab) {\n    this->Stream.setBlockInfo(&BlockInfo);\n  }\n\n  BitstreamBlockInfo BlockInfo;\n  BitstreamCursor Stream;\n  StringRef Strtab;\n\n  /// In version 2 of the bitcode we store names of global values and comdats in\n  /// a string table rather than in the VST.\n  bool UseStrtab = false;\n\n  Expected<unsigned> parseVersionRecord(ArrayRef<uint64_t> Record);\n\n  /// If this module uses a string table, pop the reference to the string table\n  /// and return the referenced string and the rest of the record. Otherwise\n  /// just return the record itself.\n  std::pair<StringRef, ArrayRef<uint64_t>>\n  readNameFromStrtab(ArrayRef<uint64_t> Record);\n\n  bool readBlockInfo();\n\n  // Contains an arbitrary and optional string identifying the bitcode producer\n  std::string ProducerIdentification;\n\n  Error error(const Twine &Message);\n};\n\n} // end anonymous namespace\n\nError BitcodeReaderBase::error(const Twine &Message) {\n  std::string FullMsg = Message.str();\n  if (!ProducerIdentification.empty())\n    FullMsg += \" (Producer: '\" + ProducerIdentification + \"' Reader: 'LLVM \" +\n               LLVM_VERSION_STRING \"')\";\n  return ::error(FullMsg);\n}\n\nExpected<unsigned>\nBitcodeReaderBase::parseVersionRecord(ArrayRef<uint64_t> Record) {\n  if (Record.empty())\n    return error(\"Invalid record\");\n  unsigned ModuleVersion = Record[0];\n  if (ModuleVersion > 2)\n    return error(\"Invalid value\");\n  UseStrtab = ModuleVersion >= 2;\n  return ModuleVersion;\n}\n\nstd::pair<StringRef, ArrayRef<uint64_t>>\nBitcodeReaderBase::readNameFromStrtab(ArrayRef<uint64_t> Record) {\n  if (!UseStrtab)\n    return {\"\", Record};\n  // Invalid reference. Let the caller complain about the record being empty.\n  if (Record[0] + Record[1] > Strtab.size())\n    return {\"\", {}};\n  return {StringRef(Strtab.data() + Record[0], Record[1]), Record.slice(2)};\n}\n\nnamespace {\n\nclass BitcodeReader : public BitcodeReaderBase, public GVMaterializer {\n  LLVMContext &Context;\n  Module *TheModule = nullptr;\n  // Next offset to start scanning for lazy parsing of function bodies.\n  uint64_t NextUnreadBit = 0;\n  // Last function offset found in the VST.\n  uint64_t LastFunctionBlockBit = 0;\n  bool SeenValueSymbolTable = false;\n  uint64_t VSTOffset = 0;\n\n  std::vector<std::string> SectionTable;\n  std::vector<std::string> GCTable;\n\n  std::vector<Type*> TypeList;\n  DenseMap<Function *, FunctionType *> FunctionTypes;\n  BitcodeReaderValueList ValueList;\n  Optional<MetadataLoader> MDLoader;\n  std::vector<Comdat *> ComdatList;\n  SmallVector<Instruction *, 64> InstructionList;\n\n  std::vector<std::pair<GlobalVariable *, unsigned>> GlobalInits;\n  std::vector<std::pair<GlobalIndirectSymbol *, unsigned>> IndirectSymbolInits;\n  std::vector<std::pair<Function *, unsigned>> FunctionPrefixes;\n  std::vector<std::pair<Function *, unsigned>> FunctionPrologues;\n  std::vector<std::pair<Function *, unsigned>> FunctionPersonalityFns;\n\n  /// The set of attributes by index.  Index zero in the file is for null, and\n  /// is thus not represented here.  As such all indices are off by one.\n  std::vector<AttributeList> MAttributes;\n\n  /// The set of attribute groups.\n  std::map<unsigned, AttributeList> MAttributeGroups;\n\n  /// While parsing a function body, this is a list of the basic blocks for the\n  /// function.\n  std::vector<BasicBlock*> FunctionBBs;\n\n  // When reading the module header, this list is populated with functions that\n  // have bodies later in the file.\n  std::vector<Function*> FunctionsWithBodies;\n\n  // When intrinsic functions are encountered which require upgrading they are\n  // stored here with their replacement function.\n  using UpdatedIntrinsicMap = DenseMap<Function *, Function *>;\n  UpdatedIntrinsicMap UpgradedIntrinsics;\n  // Intrinsics which were remangled because of types rename\n  UpdatedIntrinsicMap RemangledIntrinsics;\n\n  // Several operations happen after the module header has been read, but\n  // before function bodies are processed. This keeps track of whether\n  // we've done this yet.\n  bool SeenFirstFunctionBody = false;\n\n  /// When function bodies are initially scanned, this map contains info about\n  /// where to find deferred function body in the stream.\n  DenseMap<Function*, uint64_t> DeferredFunctionInfo;\n\n  /// When Metadata block is initially scanned when parsing the module, we may\n  /// choose to defer parsing of the metadata. This vector contains info about\n  /// which Metadata blocks are deferred.\n  std::vector<uint64_t> DeferredMetadataInfo;\n\n  /// These are basic blocks forward-referenced by block addresses.  They are\n  /// inserted lazily into functions when they're loaded.  The basic block ID is\n  /// its index into the vector.\n  DenseMap<Function *, std::vector<BasicBlock *>> BasicBlockFwdRefs;\n  std::deque<Function *> BasicBlockFwdRefQueue;\n\n  /// Indicates that we are using a new encoding for instruction operands where\n  /// most operands in the current FUNCTION_BLOCK are encoded relative to the\n  /// instruction number, for a more compact encoding.  Some instruction\n  /// operands are not relative to the instruction ID: basic block numbers, and\n  /// types. Once the old style function blocks have been phased out, we would\n  /// not need this flag.\n  bool UseRelativeIDs = false;\n\n  /// True if all functions will be materialized, negating the need to process\n  /// (e.g.) blockaddress forward references.\n  bool WillMaterializeAllForwardRefs = false;\n\n  bool StripDebugInfo = false;\n  TBAAVerifier TBAAVerifyHelper;\n\n  std::vector<std::string> BundleTags;\n  SmallVector<SyncScope::ID, 8> SSIDs;\n\npublic:\n  BitcodeReader(BitstreamCursor Stream, StringRef Strtab,\n                StringRef ProducerIdentification, LLVMContext &Context);\n\n  Error materializeForwardReferencedFunctions();\n\n  Error materialize(GlobalValue *GV) override;\n  Error materializeModule() override;\n  std::vector<StructType *> getIdentifiedStructTypes() const override;\n\n  /// Main interface to parsing a bitcode buffer.\n  /// \\returns true if an error occurred.\n  Error parseBitcodeInto(\n      Module *M, bool ShouldLazyLoadMetadata = false, bool IsImporting = false,\n      DataLayoutCallbackTy DataLayoutCallback = [](StringRef) { return None; });\n\n  static uint64_t decodeSignRotatedValue(uint64_t V);\n\n  /// Materialize any deferred Metadata block.\n  Error materializeMetadata() override;\n\n  void setStripDebugInfo() override;\n\nprivate:\n  std::vector<StructType *> IdentifiedStructTypes;\n  StructType *createIdentifiedStructType(LLVMContext &Context, StringRef Name);\n  StructType *createIdentifiedStructType(LLVMContext &Context);\n\n  /// Map all pointer types within \\param Ty to the opaque pointer\n  /// type in the same address space if opaque pointers are being\n  /// used, otherwise nop. This converts a bitcode-reader internal\n  /// type into one suitable for use in a Value.\n  Type *flattenPointerTypes(Type *Ty) {\n    return Ty;\n  }\n\n  /// Given a fully structured pointer type (i.e. not opaque), return\n  /// the flattened form of its element, suitable for use in a Value.\n  Type *getPointerElementFlatType(Type *Ty) {\n    return flattenPointerTypes(cast<PointerType>(Ty)->getElementType());\n  }\n\n  /// Given a fully structured pointer type, get its element type in\n  /// both fully structured form, and flattened form suitable for use\n  /// in a Value.\n  std::pair<Type *, Type *> getPointerElementTypes(Type *FullTy) {\n    Type *ElTy = cast<PointerType>(FullTy)->getElementType();\n    return std::make_pair(ElTy, flattenPointerTypes(ElTy));\n  }\n\n  /// Return the flattened type (suitable for use in a Value)\n  /// specified by the given \\param ID .\n  Type *getTypeByID(unsigned ID) {\n    return flattenPointerTypes(getFullyStructuredTypeByID(ID));\n  }\n\n  /// Return the fully structured (bitcode-reader internal) type\n  /// corresponding to the given \\param ID .\n  Type *getFullyStructuredTypeByID(unsigned ID);\n\n  Value *getFnValueByID(unsigned ID, Type *Ty, Type **FullTy = nullptr) {\n    if (Ty && Ty->isMetadataTy())\n      return MetadataAsValue::get(Ty->getContext(), getFnMetadataByID(ID));\n    return ValueList.getValueFwdRef(ID, Ty, FullTy);\n  }\n\n  Metadata *getFnMetadataByID(unsigned ID) {\n    return MDLoader->getMetadataFwdRefOrLoad(ID);\n  }\n\n  BasicBlock *getBasicBlock(unsigned ID) const {\n    if (ID >= FunctionBBs.size()) return nullptr; // Invalid ID\n    return FunctionBBs[ID];\n  }\n\n  AttributeList getAttributes(unsigned i) const {\n    if (i-1 < MAttributes.size())\n      return MAttributes[i-1];\n    return AttributeList();\n  }\n\n  /// Read a value/type pair out of the specified record from slot 'Slot'.\n  /// Increment Slot past the number of slots used in the record. Return true on\n  /// failure.\n  bool getValueTypePair(const SmallVectorImpl<uint64_t> &Record, unsigned &Slot,\n                        unsigned InstNum, Value *&ResVal,\n                        Type **FullTy = nullptr) {\n    if (Slot == Record.size()) return true;\n    unsigned ValNo = (unsigned)Record[Slot++];\n    // Adjust the ValNo, if it was encoded relative to the InstNum.\n    if (UseRelativeIDs)\n      ValNo = InstNum - ValNo;\n    if (ValNo < InstNum) {\n      // If this is not a forward reference, just return the value we already\n      // have.\n      ResVal = getFnValueByID(ValNo, nullptr, FullTy);\n      return ResVal == nullptr;\n    }\n    if (Slot == Record.size())\n      return true;\n\n    unsigned TypeNo = (unsigned)Record[Slot++];\n    ResVal = getFnValueByID(ValNo, getTypeByID(TypeNo));\n    if (FullTy)\n      *FullTy = getFullyStructuredTypeByID(TypeNo);\n    return ResVal == nullptr;\n  }\n\n  /// Read a value out of the specified record from slot 'Slot'. Increment Slot\n  /// past the number of slots used by the value in the record. Return true if\n  /// there is an error.\n  bool popValue(const SmallVectorImpl<uint64_t> &Record, unsigned &Slot,\n                unsigned InstNum, Type *Ty, Value *&ResVal) {\n    if (getValue(Record, Slot, InstNum, Ty, ResVal))\n      return true;\n    // All values currently take a single record slot.\n    ++Slot;\n    return false;\n  }\n\n  /// Like popValue, but does not increment the Slot number.\n  bool getValue(const SmallVectorImpl<uint64_t> &Record, unsigned Slot,\n                unsigned InstNum, Type *Ty, Value *&ResVal) {\n    ResVal = getValue(Record, Slot, InstNum, Ty);\n    return ResVal == nullptr;\n  }\n\n  /// Version of getValue that returns ResVal directly, or 0 if there is an\n  /// error.\n  Value *getValue(const SmallVectorImpl<uint64_t> &Record, unsigned Slot,\n                  unsigned InstNum, Type *Ty) {\n    if (Slot == Record.size()) return nullptr;\n    unsigned ValNo = (unsigned)Record[Slot];\n    // Adjust the ValNo, if it was encoded relative to the InstNum.\n    if (UseRelativeIDs)\n      ValNo = InstNum - ValNo;\n    return getFnValueByID(ValNo, Ty);\n  }\n\n  /// Like getValue, but decodes signed VBRs.\n  Value *getValueSigned(const SmallVectorImpl<uint64_t> &Record, unsigned Slot,\n                        unsigned InstNum, Type *Ty) {\n    if (Slot == Record.size()) return nullptr;\n    unsigned ValNo = (unsigned)decodeSignRotatedValue(Record[Slot]);\n    // Adjust the ValNo, if it was encoded relative to the InstNum.\n    if (UseRelativeIDs)\n      ValNo = InstNum - ValNo;\n    return getFnValueByID(ValNo, Ty);\n  }\n\n  /// Upgrades old-style typeless byval or sret attributes by adding the\n  /// corresponding argument's pointee type.\n  void propagateByValSRetTypes(CallBase *CB, ArrayRef<Type *> ArgsFullTys);\n\n  /// Converts alignment exponent (i.e. power of two (or zero)) to the\n  /// corresponding alignment to use. If alignment is too large, returns\n  /// a corresponding error code.\n  Error parseAlignmentValue(uint64_t Exponent, MaybeAlign &Alignment);\n  Error parseAttrKind(uint64_t Code, Attribute::AttrKind *Kind);\n  Error parseModule(\n      uint64_t ResumeBit, bool ShouldLazyLoadMetadata = false,\n      DataLayoutCallbackTy DataLayoutCallback = [](StringRef) { return None; });\n\n  Error parseComdatRecord(ArrayRef<uint64_t> Record);\n  Error parseGlobalVarRecord(ArrayRef<uint64_t> Record);\n  Error parseFunctionRecord(ArrayRef<uint64_t> Record);\n  Error parseGlobalIndirectSymbolRecord(unsigned BitCode,\n                                        ArrayRef<uint64_t> Record);\n\n  Error parseAttributeBlock();\n  Error parseAttributeGroupBlock();\n  Error parseTypeTable();\n  Error parseTypeTableBody();\n  Error parseOperandBundleTags();\n  Error parseSyncScopeNames();\n\n  Expected<Value *> recordValue(SmallVectorImpl<uint64_t> &Record,\n                                unsigned NameIndex, Triple &TT);\n  void setDeferredFunctionInfo(unsigned FuncBitcodeOffsetDelta, Function *F,\n                               ArrayRef<uint64_t> Record);\n  Error parseValueSymbolTable(uint64_t Offset = 0);\n  Error parseGlobalValueSymbolTable();\n  Error parseConstants();\n  Error rememberAndSkipFunctionBodies();\n  Error rememberAndSkipFunctionBody();\n  /// Save the positions of the Metadata blocks and skip parsing the blocks.\n  Error rememberAndSkipMetadata();\n  Error typeCheckLoadStoreInst(Type *ValType, Type *PtrType);\n  Error parseFunctionBody(Function *F);\n  Error globalCleanup();\n  Error resolveGlobalAndIndirectSymbolInits();\n  Error parseUseLists();\n  Error findFunctionInStream(\n      Function *F,\n      DenseMap<Function *, uint64_t>::iterator DeferredFunctionInfoIterator);\n\n  SyncScope::ID getDecodedSyncScopeID(unsigned Val);\n};\n\n/// Class to manage reading and parsing function summary index bitcode\n/// files/sections.\nclass ModuleSummaryIndexBitcodeReader : public BitcodeReaderBase {\n  /// The module index built during parsing.\n  ModuleSummaryIndex &TheIndex;\n\n  /// Indicates whether we have encountered a global value summary section\n  /// yet during parsing.\n  bool SeenGlobalValSummary = false;\n\n  /// Indicates whether we have already parsed the VST, used for error checking.\n  bool SeenValueSymbolTable = false;\n\n  /// Set to the offset of the VST recorded in the MODULE_CODE_VSTOFFSET record.\n  /// Used to enable on-demand parsing of the VST.\n  uint64_t VSTOffset = 0;\n\n  // Map to save ValueId to ValueInfo association that was recorded in the\n  // ValueSymbolTable. It is used after the VST is parsed to convert\n  // call graph edges read from the function summary from referencing\n  // callees by their ValueId to using the ValueInfo instead, which is how\n  // they are recorded in the summary index being built.\n  // We save a GUID which refers to the same global as the ValueInfo, but\n  // ignoring the linkage, i.e. for values other than local linkage they are\n  // identical.\n  DenseMap<unsigned, std::pair<ValueInfo, GlobalValue::GUID>>\n      ValueIdToValueInfoMap;\n\n  /// Map populated during module path string table parsing, from the\n  /// module ID to a string reference owned by the index's module\n  /// path string table, used to correlate with combined index\n  /// summary records.\n  DenseMap<uint64_t, StringRef> ModuleIdMap;\n\n  /// Original source file name recorded in a bitcode record.\n  std::string SourceFileName;\n\n  /// The string identifier given to this module by the client, normally the\n  /// path to the bitcode file.\n  StringRef ModulePath;\n\n  /// For per-module summary indexes, the unique numerical identifier given to\n  /// this module by the client.\n  unsigned ModuleId;\n\npublic:\n  ModuleSummaryIndexBitcodeReader(BitstreamCursor Stream, StringRef Strtab,\n                                  ModuleSummaryIndex &TheIndex,\n                                  StringRef ModulePath, unsigned ModuleId);\n\n  Error parseModule();\n\nprivate:\n  void setValueGUID(uint64_t ValueID, StringRef ValueName,\n                    GlobalValue::LinkageTypes Linkage,\n                    StringRef SourceFileName);\n  Error parseValueSymbolTable(\n      uint64_t Offset,\n      DenseMap<unsigned, GlobalValue::LinkageTypes> &ValueIdToLinkageMap);\n  std::vector<ValueInfo> makeRefList(ArrayRef<uint64_t> Record);\n  std::vector<FunctionSummary::EdgeTy> makeCallList(ArrayRef<uint64_t> Record,\n                                                    bool IsOldProfileFormat,\n                                                    bool HasProfile,\n                                                    bool HasRelBF);\n  Error parseEntireSummary(unsigned ID);\n  Error parseModuleStringTable();\n  void parseTypeIdCompatibleVtableSummaryRecord(ArrayRef<uint64_t> Record);\n  void parseTypeIdCompatibleVtableInfo(ArrayRef<uint64_t> Record, size_t &Slot,\n                                       TypeIdCompatibleVtableInfo &TypeId);\n  std::vector<FunctionSummary::ParamAccess>\n  parseParamAccesses(ArrayRef<uint64_t> Record);\n\n  std::pair<ValueInfo, GlobalValue::GUID>\n  getValueInfoFromValueId(unsigned ValueId);\n\n  void addThisModule();\n  ModuleSummaryIndex::ModuleInfo *getThisModule();\n};\n\n} // end anonymous namespace\n\nstd::error_code llvm::errorToErrorCodeAndEmitErrors(LLVMContext &Ctx,\n                                                    Error Err) {\n  if (Err) {\n    std::error_code EC;\n    handleAllErrors(std::move(Err), [&](ErrorInfoBase &EIB) {\n      EC = EIB.convertToErrorCode();\n      Ctx.emitError(EIB.message());\n    });\n    return EC;\n  }\n  return std::error_code();\n}\n\nBitcodeReader::BitcodeReader(BitstreamCursor Stream, StringRef Strtab,\n                             StringRef ProducerIdentification,\n                             LLVMContext &Context)\n    : BitcodeReaderBase(std::move(Stream), Strtab), Context(Context),\n      ValueList(Context, Stream.SizeInBytes()) {\n  this->ProducerIdentification = std::string(ProducerIdentification);\n}\n\nError BitcodeReader::materializeForwardReferencedFunctions() {\n  if (WillMaterializeAllForwardRefs)\n    return Error::success();\n\n  // Prevent recursion.\n  WillMaterializeAllForwardRefs = true;\n\n  while (!BasicBlockFwdRefQueue.empty()) {\n    Function *F = BasicBlockFwdRefQueue.front();\n    BasicBlockFwdRefQueue.pop_front();\n    assert(F && \"Expected valid function\");\n    if (!BasicBlockFwdRefs.count(F))\n      // Already materialized.\n      continue;\n\n    // Check for a function that isn't materializable to prevent an infinite\n    // loop.  When parsing a blockaddress stored in a global variable, there\n    // isn't a trivial way to check if a function will have a body without a\n    // linear search through FunctionsWithBodies, so just check it here.\n    if (!F->isMaterializable())\n      return error(\"Never resolved function from blockaddress\");\n\n    // Try to materialize F.\n    if (Error Err = materialize(F))\n      return Err;\n  }\n  assert(BasicBlockFwdRefs.empty() && \"Function missing from queue\");\n\n  // Reset state.\n  WillMaterializeAllForwardRefs = false;\n  return Error::success();\n}\n\n//===----------------------------------------------------------------------===//\n//  Helper functions to implement forward reference resolution, etc.\n//===----------------------------------------------------------------------===//\n\nstatic bool hasImplicitComdat(size_t Val) {\n  switch (Val) {\n  default:\n    return false;\n  case 1:  // Old WeakAnyLinkage\n  case 4:  // Old LinkOnceAnyLinkage\n  case 10: // Old WeakODRLinkage\n  case 11: // Old LinkOnceODRLinkage\n    return true;\n  }\n}\n\nstatic GlobalValue::LinkageTypes getDecodedLinkage(unsigned Val) {\n  switch (Val) {\n  default: // Map unknown/new linkages to external\n  case 0:\n    return GlobalValue::ExternalLinkage;\n  case 2:\n    return GlobalValue::AppendingLinkage;\n  case 3:\n    return GlobalValue::InternalLinkage;\n  case 5:\n    return GlobalValue::ExternalLinkage; // Obsolete DLLImportLinkage\n  case 6:\n    return GlobalValue::ExternalLinkage; // Obsolete DLLExportLinkage\n  case 7:\n    return GlobalValue::ExternalWeakLinkage;\n  case 8:\n    return GlobalValue::CommonLinkage;\n  case 9:\n    return GlobalValue::PrivateLinkage;\n  case 12:\n    return GlobalValue::AvailableExternallyLinkage;\n  case 13:\n    return GlobalValue::PrivateLinkage; // Obsolete LinkerPrivateLinkage\n  case 14:\n    return GlobalValue::PrivateLinkage; // Obsolete LinkerPrivateWeakLinkage\n  case 15:\n    return GlobalValue::ExternalLinkage; // Obsolete LinkOnceODRAutoHideLinkage\n  case 1: // Old value with implicit comdat.\n  case 16:\n    return GlobalValue::WeakAnyLinkage;\n  case 10: // Old value with implicit comdat.\n  case 17:\n    return GlobalValue::WeakODRLinkage;\n  case 4: // Old value with implicit comdat.\n  case 18:\n    return GlobalValue::LinkOnceAnyLinkage;\n  case 11: // Old value with implicit comdat.\n  case 19:\n    return GlobalValue::LinkOnceODRLinkage;\n  }\n}\n\nstatic FunctionSummary::FFlags getDecodedFFlags(uint64_t RawFlags) {\n  FunctionSummary::FFlags Flags;\n  Flags.ReadNone = RawFlags & 0x1;\n  Flags.ReadOnly = (RawFlags >> 1) & 0x1;\n  Flags.NoRecurse = (RawFlags >> 2) & 0x1;\n  Flags.ReturnDoesNotAlias = (RawFlags >> 3) & 0x1;\n  Flags.NoInline = (RawFlags >> 4) & 0x1;\n  Flags.AlwaysInline = (RawFlags >> 5) & 0x1;\n  return Flags;\n}\n\n// Decode the flags for GlobalValue in the summary. The bits for each attribute:\n//\n// linkage: [0,4), notEligibleToImport: 4, live: 5, local: 6, canAutoHide: 7,\n// visibility: [8, 10).\nstatic GlobalValueSummary::GVFlags getDecodedGVSummaryFlags(uint64_t RawFlags,\n                                                            uint64_t Version) {\n  // Summary were not emitted before LLVM 3.9, we don't need to upgrade Linkage\n  // like getDecodedLinkage() above. Any future change to the linkage enum and\n  // to getDecodedLinkage() will need to be taken into account here as above.\n  auto Linkage = GlobalValue::LinkageTypes(RawFlags & 0xF); // 4 bits\n  auto Visibility = GlobalValue::VisibilityTypes((RawFlags >> 8) & 3); // 2 bits\n  RawFlags = RawFlags >> 4;\n  bool NotEligibleToImport = (RawFlags & 0x1) || Version < 3;\n  // The Live flag wasn't introduced until version 3. For dead stripping\n  // to work correctly on earlier versions, we must conservatively treat all\n  // values as live.\n  bool Live = (RawFlags & 0x2) || Version < 3;\n  bool Local = (RawFlags & 0x4);\n  bool AutoHide = (RawFlags & 0x8);\n\n  return GlobalValueSummary::GVFlags(Linkage, Visibility, NotEligibleToImport,\n                                     Live, Local, AutoHide);\n}\n\n// Decode the flags for GlobalVariable in the summary\nstatic GlobalVarSummary::GVarFlags getDecodedGVarFlags(uint64_t RawFlags) {\n  return GlobalVarSummary::GVarFlags(\n      (RawFlags & 0x1) ? true : false, (RawFlags & 0x2) ? true : false,\n      (RawFlags & 0x4) ? true : false,\n      (GlobalObject::VCallVisibility)(RawFlags >> 3));\n}\n\nstatic GlobalValue::VisibilityTypes getDecodedVisibility(unsigned Val) {\n  switch (Val) {\n  default: // Map unknown visibilities to default.\n  case 0: return GlobalValue::DefaultVisibility;\n  case 1: return GlobalValue::HiddenVisibility;\n  case 2: return GlobalValue::ProtectedVisibility;\n  }\n}\n\nstatic GlobalValue::DLLStorageClassTypes\ngetDecodedDLLStorageClass(unsigned Val) {\n  switch (Val) {\n  default: // Map unknown values to default.\n  case 0: return GlobalValue::DefaultStorageClass;\n  case 1: return GlobalValue::DLLImportStorageClass;\n  case 2: return GlobalValue::DLLExportStorageClass;\n  }\n}\n\nstatic bool getDecodedDSOLocal(unsigned Val) {\n  switch(Val) {\n  default: // Map unknown values to preemptable.\n  case 0:  return false;\n  case 1:  return true;\n  }\n}\n\nstatic GlobalVariable::ThreadLocalMode getDecodedThreadLocalMode(unsigned Val) {\n  switch (Val) {\n    case 0: return GlobalVariable::NotThreadLocal;\n    default: // Map unknown non-zero value to general dynamic.\n    case 1: return GlobalVariable::GeneralDynamicTLSModel;\n    case 2: return GlobalVariable::LocalDynamicTLSModel;\n    case 3: return GlobalVariable::InitialExecTLSModel;\n    case 4: return GlobalVariable::LocalExecTLSModel;\n  }\n}\n\nstatic GlobalVariable::UnnamedAddr getDecodedUnnamedAddrType(unsigned Val) {\n  switch (Val) {\n    default: // Map unknown to UnnamedAddr::None.\n    case 0: return GlobalVariable::UnnamedAddr::None;\n    case 1: return GlobalVariable::UnnamedAddr::Global;\n    case 2: return GlobalVariable::UnnamedAddr::Local;\n  }\n}\n\nstatic int getDecodedCastOpcode(unsigned Val) {\n  switch (Val) {\n  default: return -1;\n  case bitc::CAST_TRUNC   : return Instruction::Trunc;\n  case bitc::CAST_ZEXT    : return Instruction::ZExt;\n  case bitc::CAST_SEXT    : return Instruction::SExt;\n  case bitc::CAST_FPTOUI  : return Instruction::FPToUI;\n  case bitc::CAST_FPTOSI  : return Instruction::FPToSI;\n  case bitc::CAST_UITOFP  : return Instruction::UIToFP;\n  case bitc::CAST_SITOFP  : return Instruction::SIToFP;\n  case bitc::CAST_FPTRUNC : return Instruction::FPTrunc;\n  case bitc::CAST_FPEXT   : return Instruction::FPExt;\n  case bitc::CAST_PTRTOINT: return Instruction::PtrToInt;\n  case bitc::CAST_INTTOPTR: return Instruction::IntToPtr;\n  case bitc::CAST_BITCAST : return Instruction::BitCast;\n  case bitc::CAST_ADDRSPACECAST: return Instruction::AddrSpaceCast;\n  }\n}\n\nstatic int getDecodedUnaryOpcode(unsigned Val, Type *Ty) {\n  bool IsFP = Ty->isFPOrFPVectorTy();\n  // UnOps are only valid for int/fp or vector of int/fp types\n  if (!IsFP && !Ty->isIntOrIntVectorTy())\n    return -1;\n\n  switch (Val) {\n  default:\n    return -1;\n  case bitc::UNOP_FNEG:\n    return IsFP ? Instruction::FNeg : -1;\n  }\n}\n\nstatic int getDecodedBinaryOpcode(unsigned Val, Type *Ty) {\n  bool IsFP = Ty->isFPOrFPVectorTy();\n  // BinOps are only valid for int/fp or vector of int/fp types\n  if (!IsFP && !Ty->isIntOrIntVectorTy())\n    return -1;\n\n  switch (Val) {\n  default:\n    return -1;\n  case bitc::BINOP_ADD:\n    return IsFP ? Instruction::FAdd : Instruction::Add;\n  case bitc::BINOP_SUB:\n    return IsFP ? Instruction::FSub : Instruction::Sub;\n  case bitc::BINOP_MUL:\n    return IsFP ? Instruction::FMul : Instruction::Mul;\n  case bitc::BINOP_UDIV:\n    return IsFP ? -1 : Instruction::UDiv;\n  case bitc::BINOP_SDIV:\n    return IsFP ? Instruction::FDiv : Instruction::SDiv;\n  case bitc::BINOP_UREM:\n    return IsFP ? -1 : Instruction::URem;\n  case bitc::BINOP_SREM:\n    return IsFP ? Instruction::FRem : Instruction::SRem;\n  case bitc::BINOP_SHL:\n    return IsFP ? -1 : Instruction::Shl;\n  case bitc::BINOP_LSHR:\n    return IsFP ? -1 : Instruction::LShr;\n  case bitc::BINOP_ASHR:\n    return IsFP ? -1 : Instruction::AShr;\n  case bitc::BINOP_AND:\n    return IsFP ? -1 : Instruction::And;\n  case bitc::BINOP_OR:\n    return IsFP ? -1 : Instruction::Or;\n  case bitc::BINOP_XOR:\n    return IsFP ? -1 : Instruction::Xor;\n  }\n}\n\nstatic AtomicRMWInst::BinOp getDecodedRMWOperation(unsigned Val) {\n  switch (Val) {\n  default: return AtomicRMWInst::BAD_BINOP;\n  case bitc::RMW_XCHG: return AtomicRMWInst::Xchg;\n  case bitc::RMW_ADD: return AtomicRMWInst::Add;\n  case bitc::RMW_SUB: return AtomicRMWInst::Sub;\n  case bitc::RMW_AND: return AtomicRMWInst::And;\n  case bitc::RMW_NAND: return AtomicRMWInst::Nand;\n  case bitc::RMW_OR: return AtomicRMWInst::Or;\n  case bitc::RMW_XOR: return AtomicRMWInst::Xor;\n  case bitc::RMW_MAX: return AtomicRMWInst::Max;\n  case bitc::RMW_MIN: return AtomicRMWInst::Min;\n  case bitc::RMW_UMAX: return AtomicRMWInst::UMax;\n  case bitc::RMW_UMIN: return AtomicRMWInst::UMin;\n  case bitc::RMW_FADD: return AtomicRMWInst::FAdd;\n  case bitc::RMW_FSUB: return AtomicRMWInst::FSub;\n  }\n}\n\nstatic AtomicOrdering getDecodedOrdering(unsigned Val) {\n  switch (Val) {\n  case bitc::ORDERING_NOTATOMIC: return AtomicOrdering::NotAtomic;\n  case bitc::ORDERING_UNORDERED: return AtomicOrdering::Unordered;\n  case bitc::ORDERING_MONOTONIC: return AtomicOrdering::Monotonic;\n  case bitc::ORDERING_ACQUIRE: return AtomicOrdering::Acquire;\n  case bitc::ORDERING_RELEASE: return AtomicOrdering::Release;\n  case bitc::ORDERING_ACQREL: return AtomicOrdering::AcquireRelease;\n  default: // Map unknown orderings to sequentially-consistent.\n  case bitc::ORDERING_SEQCST: return AtomicOrdering::SequentiallyConsistent;\n  }\n}\n\nstatic Comdat::SelectionKind getDecodedComdatSelectionKind(unsigned Val) {\n  switch (Val) {\n  default: // Map unknown selection kinds to any.\n  case bitc::COMDAT_SELECTION_KIND_ANY:\n    return Comdat::Any;\n  case bitc::COMDAT_SELECTION_KIND_EXACT_MATCH:\n    return Comdat::ExactMatch;\n  case bitc::COMDAT_SELECTION_KIND_LARGEST:\n    return Comdat::Largest;\n  case bitc::COMDAT_SELECTION_KIND_NO_DUPLICATES:\n    return Comdat::NoDuplicates;\n  case bitc::COMDAT_SELECTION_KIND_SAME_SIZE:\n    return Comdat::SameSize;\n  }\n}\n\nstatic FastMathFlags getDecodedFastMathFlags(unsigned Val) {\n  FastMathFlags FMF;\n  if (0 != (Val & bitc::UnsafeAlgebra))\n    FMF.setFast();\n  if (0 != (Val & bitc::AllowReassoc))\n    FMF.setAllowReassoc();\n  if (0 != (Val & bitc::NoNaNs))\n    FMF.setNoNaNs();\n  if (0 != (Val & bitc::NoInfs))\n    FMF.setNoInfs();\n  if (0 != (Val & bitc::NoSignedZeros))\n    FMF.setNoSignedZeros();\n  if (0 != (Val & bitc::AllowReciprocal))\n    FMF.setAllowReciprocal();\n  if (0 != (Val & bitc::AllowContract))\n    FMF.setAllowContract(true);\n  if (0 != (Val & bitc::ApproxFunc))\n    FMF.setApproxFunc();\n  return FMF;\n}\n\nstatic void upgradeDLLImportExportLinkage(GlobalValue *GV, unsigned Val) {\n  switch (Val) {\n  case 5: GV->setDLLStorageClass(GlobalValue::DLLImportStorageClass); break;\n  case 6: GV->setDLLStorageClass(GlobalValue::DLLExportStorageClass); break;\n  }\n}\n\nType *BitcodeReader::getFullyStructuredTypeByID(unsigned ID) {\n  // The type table size is always specified correctly.\n  if (ID >= TypeList.size())\n    return nullptr;\n\n  if (Type *Ty = TypeList[ID])\n    return Ty;\n\n  // If we have a forward reference, the only possible case is when it is to a\n  // named struct.  Just create a placeholder for now.\n  return TypeList[ID] = createIdentifiedStructType(Context);\n}\n\nStructType *BitcodeReader::createIdentifiedStructType(LLVMContext &Context,\n                                                      StringRef Name) {\n  auto *Ret = StructType::create(Context, Name);\n  IdentifiedStructTypes.push_back(Ret);\n  return Ret;\n}\n\nStructType *BitcodeReader::createIdentifiedStructType(LLVMContext &Context) {\n  auto *Ret = StructType::create(Context);\n  IdentifiedStructTypes.push_back(Ret);\n  return Ret;\n}\n\n//===----------------------------------------------------------------------===//\n//  Functions for parsing blocks from the bitcode file\n//===----------------------------------------------------------------------===//\n\nstatic uint64_t getRawAttributeMask(Attribute::AttrKind Val) {\n  switch (Val) {\n  case Attribute::EndAttrKinds:\n  case Attribute::EmptyKey:\n  case Attribute::TombstoneKey:\n    llvm_unreachable(\"Synthetic enumerators which should never get here\");\n\n  case Attribute::None:            return 0;\n  case Attribute::ZExt:            return 1 << 0;\n  case Attribute::SExt:            return 1 << 1;\n  case Attribute::NoReturn:        return 1 << 2;\n  case Attribute::InReg:           return 1 << 3;\n  case Attribute::StructRet:       return 1 << 4;\n  case Attribute::NoUnwind:        return 1 << 5;\n  case Attribute::NoAlias:         return 1 << 6;\n  case Attribute::ByVal:           return 1 << 7;\n  case Attribute::Nest:            return 1 << 8;\n  case Attribute::ReadNone:        return 1 << 9;\n  case Attribute::ReadOnly:        return 1 << 10;\n  case Attribute::NoInline:        return 1 << 11;\n  case Attribute::AlwaysInline:    return 1 << 12;\n  case Attribute::OptimizeForSize: return 1 << 13;\n  case Attribute::StackProtect:    return 1 << 14;\n  case Attribute::StackProtectReq: return 1 << 15;\n  case Attribute::Alignment:       return 31 << 16;\n  case Attribute::NoCapture:       return 1 << 21;\n  case Attribute::NoRedZone:       return 1 << 22;\n  case Attribute::NoImplicitFloat: return 1 << 23;\n  case Attribute::Naked:           return 1 << 24;\n  case Attribute::InlineHint:      return 1 << 25;\n  case Attribute::StackAlignment:  return 7 << 26;\n  case Attribute::ReturnsTwice:    return 1 << 29;\n  case Attribute::UWTable:         return 1 << 30;\n  case Attribute::NonLazyBind:     return 1U << 31;\n  case Attribute::SanitizeAddress: return 1ULL << 32;\n  case Attribute::MinSize:         return 1ULL << 33;\n  case Attribute::NoDuplicate:     return 1ULL << 34;\n  case Attribute::StackProtectStrong: return 1ULL << 35;\n  case Attribute::SanitizeThread:  return 1ULL << 36;\n  case Attribute::SanitizeMemory:  return 1ULL << 37;\n  case Attribute::NoBuiltin:       return 1ULL << 38;\n  case Attribute::Returned:        return 1ULL << 39;\n  case Attribute::Cold:            return 1ULL << 40;\n  case Attribute::Builtin:         return 1ULL << 41;\n  case Attribute::OptimizeNone:    return 1ULL << 42;\n  case Attribute::InAlloca:        return 1ULL << 43;\n  case Attribute::NonNull:         return 1ULL << 44;\n  case Attribute::JumpTable:       return 1ULL << 45;\n  case Attribute::Convergent:      return 1ULL << 46;\n  case Attribute::SafeStack:       return 1ULL << 47;\n  case Attribute::NoRecurse:       return 1ULL << 48;\n  case Attribute::InaccessibleMemOnly:         return 1ULL << 49;\n  case Attribute::InaccessibleMemOrArgMemOnly: return 1ULL << 50;\n  case Attribute::SwiftSelf:       return 1ULL << 51;\n  case Attribute::SwiftError:      return 1ULL << 52;\n  case Attribute::WriteOnly:       return 1ULL << 53;\n  case Attribute::Speculatable:    return 1ULL << 54;\n  case Attribute::StrictFP:        return 1ULL << 55;\n  case Attribute::SanitizeHWAddress: return 1ULL << 56;\n  case Attribute::NoCfCheck:       return 1ULL << 57;\n  case Attribute::OptForFuzzing:   return 1ULL << 58;\n  case Attribute::ShadowCallStack: return 1ULL << 59;\n  case Attribute::SpeculativeLoadHardening:\n    return 1ULL << 60;\n  case Attribute::ImmArg:\n    return 1ULL << 61;\n  case Attribute::WillReturn:\n    return 1ULL << 62;\n  case Attribute::NoFree:\n    return 1ULL << 63;\n  default:\n    // Other attributes are not supported in the raw format,\n    // as we ran out of space.\n    return 0;\n  }\n  llvm_unreachable(\"Unsupported attribute type\");\n}\n\nstatic void addRawAttributeValue(AttrBuilder &B, uint64_t Val) {\n  if (!Val) return;\n\n  for (Attribute::AttrKind I = Attribute::None; I != Attribute::EndAttrKinds;\n       I = Attribute::AttrKind(I + 1)) {\n    if (uint64_t A = (Val & getRawAttributeMask(I))) {\n      if (I == Attribute::Alignment)\n        B.addAlignmentAttr(1ULL << ((A >> 16) - 1));\n      else if (I == Attribute::StackAlignment)\n        B.addStackAlignmentAttr(1ULL << ((A >> 26)-1));\n      else\n        B.addAttribute(I);\n    }\n  }\n}\n\n/// This fills an AttrBuilder object with the LLVM attributes that have\n/// been decoded from the given integer. This function must stay in sync with\n/// 'encodeLLVMAttributesForBitcode'.\nstatic void decodeLLVMAttributesForBitcode(AttrBuilder &B,\n                                           uint64_t EncodedAttrs) {\n  // The alignment is stored as a 16-bit raw value from bits 31--16.  We shift\n  // the bits above 31 down by 11 bits.\n  unsigned Alignment = (EncodedAttrs & (0xffffULL << 16)) >> 16;\n  assert((!Alignment || isPowerOf2_32(Alignment)) &&\n         \"Alignment must be a power of two.\");\n\n  if (Alignment)\n    B.addAlignmentAttr(Alignment);\n  addRawAttributeValue(B, ((EncodedAttrs & (0xfffffULL << 32)) >> 11) |\n                          (EncodedAttrs & 0xffff));\n}\n\nError BitcodeReader::parseAttributeBlock() {\n  if (Error Err = Stream.EnterSubBlock(bitc::PARAMATTR_BLOCK_ID))\n    return Err;\n\n  if (!MAttributes.empty())\n    return error(\"Invalid multiple blocks\");\n\n  SmallVector<uint64_t, 64> Record;\n\n  SmallVector<AttributeList, 8> Attrs;\n\n  // Read all the records.\n  while (true) {\n    Expected<BitstreamEntry> MaybeEntry = Stream.advanceSkippingSubblocks();\n    if (!MaybeEntry)\n      return MaybeEntry.takeError();\n    BitstreamEntry Entry = MaybeEntry.get();\n\n    switch (Entry.Kind) {\n    case BitstreamEntry::SubBlock: // Handled for us already.\n    case BitstreamEntry::Error:\n      return error(\"Malformed block\");\n    case BitstreamEntry::EndBlock:\n      return Error::success();\n    case BitstreamEntry::Record:\n      // The interesting case.\n      break;\n    }\n\n    // Read a record.\n    Record.clear();\n    Expected<unsigned> MaybeRecord = Stream.readRecord(Entry.ID, Record);\n    if (!MaybeRecord)\n      return MaybeRecord.takeError();\n    switch (MaybeRecord.get()) {\n    default:  // Default behavior: ignore.\n      break;\n    case bitc::PARAMATTR_CODE_ENTRY_OLD: // ENTRY: [paramidx0, attr0, ...]\n      // Deprecated, but still needed to read old bitcode files.\n      if (Record.size() & 1)\n        return error(\"Invalid record\");\n\n      for (unsigned i = 0, e = Record.size(); i != e; i += 2) {\n        AttrBuilder B;\n        decodeLLVMAttributesForBitcode(B, Record[i+1]);\n        Attrs.push_back(AttributeList::get(Context, Record[i], B));\n      }\n\n      MAttributes.push_back(AttributeList::get(Context, Attrs));\n      Attrs.clear();\n      break;\n    case bitc::PARAMATTR_CODE_ENTRY: // ENTRY: [attrgrp0, attrgrp1, ...]\n      for (unsigned i = 0, e = Record.size(); i != e; ++i)\n        Attrs.push_back(MAttributeGroups[Record[i]]);\n\n      MAttributes.push_back(AttributeList::get(Context, Attrs));\n      Attrs.clear();\n      break;\n    }\n  }\n}\n\n// Returns Attribute::None on unrecognized codes.\nstatic Attribute::AttrKind getAttrFromCode(uint64_t Code) {\n  switch (Code) {\n  default:\n    return Attribute::None;\n  case bitc::ATTR_KIND_ALIGNMENT:\n    return Attribute::Alignment;\n  case bitc::ATTR_KIND_ALWAYS_INLINE:\n    return Attribute::AlwaysInline;\n  case bitc::ATTR_KIND_ARGMEMONLY:\n    return Attribute::ArgMemOnly;\n  case bitc::ATTR_KIND_BUILTIN:\n    return Attribute::Builtin;\n  case bitc::ATTR_KIND_BY_VAL:\n    return Attribute::ByVal;\n  case bitc::ATTR_KIND_IN_ALLOCA:\n    return Attribute::InAlloca;\n  case bitc::ATTR_KIND_COLD:\n    return Attribute::Cold;\n  case bitc::ATTR_KIND_CONVERGENT:\n    return Attribute::Convergent;\n  case bitc::ATTR_KIND_INACCESSIBLEMEM_ONLY:\n    return Attribute::InaccessibleMemOnly;\n  case bitc::ATTR_KIND_INACCESSIBLEMEM_OR_ARGMEMONLY:\n    return Attribute::InaccessibleMemOrArgMemOnly;\n  case bitc::ATTR_KIND_INLINE_HINT:\n    return Attribute::InlineHint;\n  case bitc::ATTR_KIND_IN_REG:\n    return Attribute::InReg;\n  case bitc::ATTR_KIND_JUMP_TABLE:\n    return Attribute::JumpTable;\n  case bitc::ATTR_KIND_MIN_SIZE:\n    return Attribute::MinSize;\n  case bitc::ATTR_KIND_NAKED:\n    return Attribute::Naked;\n  case bitc::ATTR_KIND_NEST:\n    return Attribute::Nest;\n  case bitc::ATTR_KIND_NO_ALIAS:\n    return Attribute::NoAlias;\n  case bitc::ATTR_KIND_NO_BUILTIN:\n    return Attribute::NoBuiltin;\n  case bitc::ATTR_KIND_NO_CALLBACK:\n    return Attribute::NoCallback;\n  case bitc::ATTR_KIND_NO_CAPTURE:\n    return Attribute::NoCapture;\n  case bitc::ATTR_KIND_NO_DUPLICATE:\n    return Attribute::NoDuplicate;\n  case bitc::ATTR_KIND_NOFREE:\n    return Attribute::NoFree;\n  case bitc::ATTR_KIND_NO_IMPLICIT_FLOAT:\n    return Attribute::NoImplicitFloat;\n  case bitc::ATTR_KIND_NO_INLINE:\n    return Attribute::NoInline;\n  case bitc::ATTR_KIND_NO_RECURSE:\n    return Attribute::NoRecurse;\n  case bitc::ATTR_KIND_NO_MERGE:\n    return Attribute::NoMerge;\n  case bitc::ATTR_KIND_NON_LAZY_BIND:\n    return Attribute::NonLazyBind;\n  case bitc::ATTR_KIND_NON_NULL:\n    return Attribute::NonNull;\n  case bitc::ATTR_KIND_DEREFERENCEABLE:\n    return Attribute::Dereferenceable;\n  case bitc::ATTR_KIND_DEREFERENCEABLE_OR_NULL:\n    return Attribute::DereferenceableOrNull;\n  case bitc::ATTR_KIND_ALLOC_SIZE:\n    return Attribute::AllocSize;\n  case bitc::ATTR_KIND_NO_RED_ZONE:\n    return Attribute::NoRedZone;\n  case bitc::ATTR_KIND_NO_RETURN:\n    return Attribute::NoReturn;\n  case bitc::ATTR_KIND_NOSYNC:\n    return Attribute::NoSync;\n  case bitc::ATTR_KIND_NOCF_CHECK:\n    return Attribute::NoCfCheck;\n  case bitc::ATTR_KIND_NO_UNWIND:\n    return Attribute::NoUnwind;\n  case bitc::ATTR_KIND_NULL_POINTER_IS_VALID:\n    return Attribute::NullPointerIsValid;\n  case bitc::ATTR_KIND_OPT_FOR_FUZZING:\n    return Attribute::OptForFuzzing;\n  case bitc::ATTR_KIND_OPTIMIZE_FOR_SIZE:\n    return Attribute::OptimizeForSize;\n  case bitc::ATTR_KIND_OPTIMIZE_NONE:\n    return Attribute::OptimizeNone;\n  case bitc::ATTR_KIND_READ_NONE:\n    return Attribute::ReadNone;\n  case bitc::ATTR_KIND_READ_ONLY:\n    return Attribute::ReadOnly;\n  case bitc::ATTR_KIND_RETURNED:\n    return Attribute::Returned;\n  case bitc::ATTR_KIND_RETURNS_TWICE:\n    return Attribute::ReturnsTwice;\n  case bitc::ATTR_KIND_S_EXT:\n    return Attribute::SExt;\n  case bitc::ATTR_KIND_SPECULATABLE:\n    return Attribute::Speculatable;\n  case bitc::ATTR_KIND_STACK_ALIGNMENT:\n    return Attribute::StackAlignment;\n  case bitc::ATTR_KIND_STACK_PROTECT:\n    return Attribute::StackProtect;\n  case bitc::ATTR_KIND_STACK_PROTECT_REQ:\n    return Attribute::StackProtectReq;\n  case bitc::ATTR_KIND_STACK_PROTECT_STRONG:\n    return Attribute::StackProtectStrong;\n  case bitc::ATTR_KIND_SAFESTACK:\n    return Attribute::SafeStack;\n  case bitc::ATTR_KIND_SHADOWCALLSTACK:\n    return Attribute::ShadowCallStack;\n  case bitc::ATTR_KIND_STRICT_FP:\n    return Attribute::StrictFP;\n  case bitc::ATTR_KIND_STRUCT_RET:\n    return Attribute::StructRet;\n  case bitc::ATTR_KIND_SANITIZE_ADDRESS:\n    return Attribute::SanitizeAddress;\n  case bitc::ATTR_KIND_SANITIZE_HWADDRESS:\n    return Attribute::SanitizeHWAddress;\n  case bitc::ATTR_KIND_SANITIZE_THREAD:\n    return Attribute::SanitizeThread;\n  case bitc::ATTR_KIND_SANITIZE_MEMORY:\n    return Attribute::SanitizeMemory;\n  case bitc::ATTR_KIND_SPECULATIVE_LOAD_HARDENING:\n    return Attribute::SpeculativeLoadHardening;\n  case bitc::ATTR_KIND_SWIFT_ERROR:\n    return Attribute::SwiftError;\n  case bitc::ATTR_KIND_SWIFT_SELF:\n    return Attribute::SwiftSelf;\n  case bitc::ATTR_KIND_UW_TABLE:\n    return Attribute::UWTable;\n  case bitc::ATTR_KIND_WILLRETURN:\n    return Attribute::WillReturn;\n  case bitc::ATTR_KIND_WRITEONLY:\n    return Attribute::WriteOnly;\n  case bitc::ATTR_KIND_Z_EXT:\n    return Attribute::ZExt;\n  case bitc::ATTR_KIND_IMMARG:\n    return Attribute::ImmArg;\n  case bitc::ATTR_KIND_SANITIZE_MEMTAG:\n    return Attribute::SanitizeMemTag;\n  case bitc::ATTR_KIND_PREALLOCATED:\n    return Attribute::Preallocated;\n  case bitc::ATTR_KIND_NOUNDEF:\n    return Attribute::NoUndef;\n  case bitc::ATTR_KIND_BYREF:\n    return Attribute::ByRef;\n  case bitc::ATTR_KIND_MUSTPROGRESS:\n    return Attribute::MustProgress;\n  case bitc::ATTR_KIND_HOT:\n    return Attribute::Hot;\n  }\n}\n\nError BitcodeReader::parseAlignmentValue(uint64_t Exponent,\n                                         MaybeAlign &Alignment) {\n  // Note: Alignment in bitcode files is incremented by 1, so that zero\n  // can be used for default alignment.\n  if (Exponent > Value::MaxAlignmentExponent + 1)\n    return error(\"Invalid alignment value\");\n  Alignment = decodeMaybeAlign(Exponent);\n  return Error::success();\n}\n\nError BitcodeReader::parseAttrKind(uint64_t Code, Attribute::AttrKind *Kind) {\n  *Kind = getAttrFromCode(Code);\n  if (*Kind == Attribute::None)\n    return error(\"Unknown attribute kind (\" + Twine(Code) + \")\");\n  return Error::success();\n}\n\nError BitcodeReader::parseAttributeGroupBlock() {\n  if (Error Err = Stream.EnterSubBlock(bitc::PARAMATTR_GROUP_BLOCK_ID))\n    return Err;\n\n  if (!MAttributeGroups.empty())\n    return error(\"Invalid multiple blocks\");\n\n  SmallVector<uint64_t, 64> Record;\n\n  // Read all the records.\n  while (true) {\n    Expected<BitstreamEntry> MaybeEntry = Stream.advanceSkippingSubblocks();\n    if (!MaybeEntry)\n      return MaybeEntry.takeError();\n    BitstreamEntry Entry = MaybeEntry.get();\n\n    switch (Entry.Kind) {\n    case BitstreamEntry::SubBlock: // Handled for us already.\n    case BitstreamEntry::Error:\n      return error(\"Malformed block\");\n    case BitstreamEntry::EndBlock:\n      return Error::success();\n    case BitstreamEntry::Record:\n      // The interesting case.\n      break;\n    }\n\n    // Read a record.\n    Record.clear();\n    Expected<unsigned> MaybeRecord = Stream.readRecord(Entry.ID, Record);\n    if (!MaybeRecord)\n      return MaybeRecord.takeError();\n    switch (MaybeRecord.get()) {\n    default:  // Default behavior: ignore.\n      break;\n    case bitc::PARAMATTR_GRP_CODE_ENTRY: { // ENTRY: [grpid, idx, a0, a1, ...]\n      if (Record.size() < 3)\n        return error(\"Invalid record\");\n\n      uint64_t GrpID = Record[0];\n      uint64_t Idx = Record[1]; // Index of the object this attribute refers to.\n\n      AttrBuilder B;\n      for (unsigned i = 2, e = Record.size(); i != e; ++i) {\n        if (Record[i] == 0) {        // Enum attribute\n          Attribute::AttrKind Kind;\n          if (Error Err = parseAttrKind(Record[++i], &Kind))\n            return Err;\n\n          // Upgrade old-style byval attribute to one with a type, even if it's\n          // nullptr. We will have to insert the real type when we associate\n          // this AttributeList with a function.\n          if (Kind == Attribute::ByVal)\n            B.addByValAttr(nullptr);\n          else if (Kind == Attribute::StructRet)\n            B.addStructRetAttr(nullptr);\n\n          B.addAttribute(Kind);\n        } else if (Record[i] == 1) { // Integer attribute\n          Attribute::AttrKind Kind;\n          if (Error Err = parseAttrKind(Record[++i], &Kind))\n            return Err;\n          if (Kind == Attribute::Alignment)\n            B.addAlignmentAttr(Record[++i]);\n          else if (Kind == Attribute::StackAlignment)\n            B.addStackAlignmentAttr(Record[++i]);\n          else if (Kind == Attribute::Dereferenceable)\n            B.addDereferenceableAttr(Record[++i]);\n          else if (Kind == Attribute::DereferenceableOrNull)\n            B.addDereferenceableOrNullAttr(Record[++i]);\n          else if (Kind == Attribute::AllocSize)\n            B.addAllocSizeAttrFromRawRepr(Record[++i]);\n        } else if (Record[i] == 3 || Record[i] == 4) { // String attribute\n          bool HasValue = (Record[i++] == 4);\n          SmallString<64> KindStr;\n          SmallString<64> ValStr;\n\n          while (Record[i] != 0 && i != e)\n            KindStr += Record[i++];\n          assert(Record[i] == 0 && \"Kind string not null terminated\");\n\n          if (HasValue) {\n            // Has a value associated with it.\n            ++i; // Skip the '0' that terminates the \"kind\" string.\n            while (Record[i] != 0 && i != e)\n              ValStr += Record[i++];\n            assert(Record[i] == 0 && \"Value string not null terminated\");\n          }\n\n          B.addAttribute(KindStr.str(), ValStr.str());\n        } else {\n          assert((Record[i] == 5 || Record[i] == 6) &&\n                 \"Invalid attribute group entry\");\n          bool HasType = Record[i] == 6;\n          Attribute::AttrKind Kind;\n          if (Error Err = parseAttrKind(Record[++i], &Kind))\n            return Err;\n          if (Kind == Attribute::ByVal) {\n            B.addByValAttr(HasType ? getTypeByID(Record[++i]) : nullptr);\n          } else if (Kind == Attribute::StructRet) {\n            B.addStructRetAttr(HasType ? getTypeByID(Record[++i]) : nullptr);\n          } else if (Kind == Attribute::ByRef) {\n            B.addByRefAttr(getTypeByID(Record[++i]));\n          } else if (Kind == Attribute::Preallocated) {\n            B.addPreallocatedAttr(getTypeByID(Record[++i]));\n          }\n        }\n      }\n\n      UpgradeAttributes(B);\n      MAttributeGroups[GrpID] = AttributeList::get(Context, Idx, B);\n      break;\n    }\n    }\n  }\n}\n\nError BitcodeReader::parseTypeTable() {\n  if (Error Err = Stream.EnterSubBlock(bitc::TYPE_BLOCK_ID_NEW))\n    return Err;\n\n  return parseTypeTableBody();\n}\n\nError BitcodeReader::parseTypeTableBody() {\n  if (!TypeList.empty())\n    return error(\"Invalid multiple blocks\");\n\n  SmallVector<uint64_t, 64> Record;\n  unsigned NumRecords = 0;\n\n  SmallString<64> TypeName;\n\n  // Read all the records for this type table.\n  while (true) {\n    Expected<BitstreamEntry> MaybeEntry = Stream.advanceSkippingSubblocks();\n    if (!MaybeEntry)\n      return MaybeEntry.takeError();\n    BitstreamEntry Entry = MaybeEntry.get();\n\n    switch (Entry.Kind) {\n    case BitstreamEntry::SubBlock: // Handled for us already.\n    case BitstreamEntry::Error:\n      return error(\"Malformed block\");\n    case BitstreamEntry::EndBlock:\n      if (NumRecords != TypeList.size())\n        return error(\"Malformed block\");\n      return Error::success();\n    case BitstreamEntry::Record:\n      // The interesting case.\n      break;\n    }\n\n    // Read a record.\n    Record.clear();\n    Type *ResultTy = nullptr;\n    Expected<unsigned> MaybeRecord = Stream.readRecord(Entry.ID, Record);\n    if (!MaybeRecord)\n      return MaybeRecord.takeError();\n    switch (MaybeRecord.get()) {\n    default:\n      return error(\"Invalid value\");\n    case bitc::TYPE_CODE_NUMENTRY: // TYPE_CODE_NUMENTRY: [numentries]\n      // TYPE_CODE_NUMENTRY contains a count of the number of types in the\n      // type list.  This allows us to reserve space.\n      if (Record.empty())\n        return error(\"Invalid record\");\n      TypeList.resize(Record[0]);\n      continue;\n    case bitc::TYPE_CODE_VOID:      // VOID\n      ResultTy = Type::getVoidTy(Context);\n      break;\n    case bitc::TYPE_CODE_HALF:     // HALF\n      ResultTy = Type::getHalfTy(Context);\n      break;\n    case bitc::TYPE_CODE_BFLOAT:    // BFLOAT\n      ResultTy = Type::getBFloatTy(Context);\n      break;\n    case bitc::TYPE_CODE_FLOAT:     // FLOAT\n      ResultTy = Type::getFloatTy(Context);\n      break;\n    case bitc::TYPE_CODE_DOUBLE:    // DOUBLE\n      ResultTy = Type::getDoubleTy(Context);\n      break;\n    case bitc::TYPE_CODE_X86_FP80:  // X86_FP80\n      ResultTy = Type::getX86_FP80Ty(Context);\n      break;\n    case bitc::TYPE_CODE_FP128:     // FP128\n      ResultTy = Type::getFP128Ty(Context);\n      break;\n    case bitc::TYPE_CODE_PPC_FP128: // PPC_FP128\n      ResultTy = Type::getPPC_FP128Ty(Context);\n      break;\n    case bitc::TYPE_CODE_LABEL:     // LABEL\n      ResultTy = Type::getLabelTy(Context);\n      break;\n    case bitc::TYPE_CODE_METADATA:  // METADATA\n      ResultTy = Type::getMetadataTy(Context);\n      break;\n    case bitc::TYPE_CODE_X86_MMX:   // X86_MMX\n      ResultTy = Type::getX86_MMXTy(Context);\n      break;\n    case bitc::TYPE_CODE_X86_AMX:   // X86_AMX\n      ResultTy = Type::getX86_AMXTy(Context);\n      break;\n    case bitc::TYPE_CODE_TOKEN:     // TOKEN\n      ResultTy = Type::getTokenTy(Context);\n      break;\n    case bitc::TYPE_CODE_INTEGER: { // INTEGER: [width]\n      if (Record.empty())\n        return error(\"Invalid record\");\n\n      uint64_t NumBits = Record[0];\n      if (NumBits < IntegerType::MIN_INT_BITS ||\n          NumBits > IntegerType::MAX_INT_BITS)\n        return error(\"Bitwidth for integer type out of range\");\n      ResultTy = IntegerType::get(Context, NumBits);\n      break;\n    }\n    case bitc::TYPE_CODE_POINTER: { // POINTER: [pointee type] or\n                                    //          [pointee type, address space]\n      if (Record.empty())\n        return error(\"Invalid record\");\n      unsigned AddressSpace = 0;\n      if (Record.size() == 2)\n        AddressSpace = Record[1];\n      ResultTy = getTypeByID(Record[0]);\n      if (!ResultTy ||\n          !PointerType::isValidElementType(ResultTy))\n        return error(\"Invalid type\");\n      ResultTy = PointerType::get(ResultTy, AddressSpace);\n      break;\n    }\n    case bitc::TYPE_CODE_FUNCTION_OLD: {\n      // Deprecated, but still needed to read old bitcode files.\n      // FUNCTION: [vararg, attrid, retty, paramty x N]\n      if (Record.size() < 3)\n        return error(\"Invalid record\");\n      SmallVector<Type*, 8> ArgTys;\n      for (unsigned i = 3, e = Record.size(); i != e; ++i) {\n        if (Type *T = getTypeByID(Record[i]))\n          ArgTys.push_back(T);\n        else\n          break;\n      }\n\n      ResultTy = getTypeByID(Record[2]);\n      if (!ResultTy || ArgTys.size() < Record.size()-3)\n        return error(\"Invalid type\");\n\n      ResultTy = FunctionType::get(ResultTy, ArgTys, Record[0]);\n      break;\n    }\n    case bitc::TYPE_CODE_FUNCTION: {\n      // FUNCTION: [vararg, retty, paramty x N]\n      if (Record.size() < 2)\n        return error(\"Invalid record\");\n      SmallVector<Type*, 8> ArgTys;\n      for (unsigned i = 2, e = Record.size(); i != e; ++i) {\n        if (Type *T = getTypeByID(Record[i])) {\n          if (!FunctionType::isValidArgumentType(T))\n            return error(\"Invalid function argument type\");\n          ArgTys.push_back(T);\n        }\n        else\n          break;\n      }\n\n      ResultTy = getTypeByID(Record[1]);\n      if (!ResultTy || ArgTys.size() < Record.size()-2)\n        return error(\"Invalid type\");\n\n      ResultTy = FunctionType::get(ResultTy, ArgTys, Record[0]);\n      break;\n    }\n    case bitc::TYPE_CODE_STRUCT_ANON: {  // STRUCT: [ispacked, eltty x N]\n      if (Record.empty())\n        return error(\"Invalid record\");\n      SmallVector<Type*, 8> EltTys;\n      for (unsigned i = 1, e = Record.size(); i != e; ++i) {\n        if (Type *T = getTypeByID(Record[i]))\n          EltTys.push_back(T);\n        else\n          break;\n      }\n      if (EltTys.size() != Record.size()-1)\n        return error(\"Invalid type\");\n      ResultTy = StructType::get(Context, EltTys, Record[0]);\n      break;\n    }\n    case bitc::TYPE_CODE_STRUCT_NAME:   // STRUCT_NAME: [strchr x N]\n      if (convertToString(Record, 0, TypeName))\n        return error(\"Invalid record\");\n      continue;\n\n    case bitc::TYPE_CODE_STRUCT_NAMED: { // STRUCT: [ispacked, eltty x N]\n      if (Record.empty())\n        return error(\"Invalid record\");\n\n      if (NumRecords >= TypeList.size())\n        return error(\"Invalid TYPE table\");\n\n      // Check to see if this was forward referenced, if so fill in the temp.\n      StructType *Res = cast_or_null<StructType>(TypeList[NumRecords]);\n      if (Res) {\n        Res->setName(TypeName);\n        TypeList[NumRecords] = nullptr;\n      } else  // Otherwise, create a new struct.\n        Res = createIdentifiedStructType(Context, TypeName);\n      TypeName.clear();\n\n      SmallVector<Type*, 8> EltTys;\n      for (unsigned i = 1, e = Record.size(); i != e; ++i) {\n        if (Type *T = getTypeByID(Record[i]))\n          EltTys.push_back(T);\n        else\n          break;\n      }\n      if (EltTys.size() != Record.size()-1)\n        return error(\"Invalid record\");\n      Res->setBody(EltTys, Record[0]);\n      ResultTy = Res;\n      break;\n    }\n    case bitc::TYPE_CODE_OPAQUE: {       // OPAQUE: []\n      if (Record.size() != 1)\n        return error(\"Invalid record\");\n\n      if (NumRecords >= TypeList.size())\n        return error(\"Invalid TYPE table\");\n\n      // Check to see if this was forward referenced, if so fill in the temp.\n      StructType *Res = cast_or_null<StructType>(TypeList[NumRecords]);\n      if (Res) {\n        Res->setName(TypeName);\n        TypeList[NumRecords] = nullptr;\n      } else  // Otherwise, create a new struct with no body.\n        Res = createIdentifiedStructType(Context, TypeName);\n      TypeName.clear();\n      ResultTy = Res;\n      break;\n    }\n    case bitc::TYPE_CODE_ARRAY:     // ARRAY: [numelts, eltty]\n      if (Record.size() < 2)\n        return error(\"Invalid record\");\n      ResultTy = getTypeByID(Record[1]);\n      if (!ResultTy || !ArrayType::isValidElementType(ResultTy))\n        return error(\"Invalid type\");\n      ResultTy = ArrayType::get(ResultTy, Record[0]);\n      break;\n    case bitc::TYPE_CODE_VECTOR:    // VECTOR: [numelts, eltty] or\n                                    //         [numelts, eltty, scalable]\n      if (Record.size() < 2)\n        return error(\"Invalid record\");\n      if (Record[0] == 0)\n        return error(\"Invalid vector length\");\n      ResultTy = getTypeByID(Record[1]);\n      if (!ResultTy || !StructType::isValidElementType(ResultTy))\n        return error(\"Invalid type\");\n      bool Scalable = Record.size() > 2 ? Record[2] : false;\n      ResultTy = VectorType::get(ResultTy, Record[0], Scalable);\n      break;\n    }\n\n    if (NumRecords >= TypeList.size())\n      return error(\"Invalid TYPE table\");\n    if (TypeList[NumRecords])\n      return error(\n          \"Invalid TYPE table: Only named structs can be forward referenced\");\n    assert(ResultTy && \"Didn't read a type?\");\n    TypeList[NumRecords++] = ResultTy;\n  }\n}\n\nError BitcodeReader::parseOperandBundleTags() {\n  if (Error Err = Stream.EnterSubBlock(bitc::OPERAND_BUNDLE_TAGS_BLOCK_ID))\n    return Err;\n\n  if (!BundleTags.empty())\n    return error(\"Invalid multiple blocks\");\n\n  SmallVector<uint64_t, 64> Record;\n\n  while (true) {\n    Expected<BitstreamEntry> MaybeEntry = Stream.advanceSkippingSubblocks();\n    if (!MaybeEntry)\n      return MaybeEntry.takeError();\n    BitstreamEntry Entry = MaybeEntry.get();\n\n    switch (Entry.Kind) {\n    case BitstreamEntry::SubBlock: // Handled for us already.\n    case BitstreamEntry::Error:\n      return error(\"Malformed block\");\n    case BitstreamEntry::EndBlock:\n      return Error::success();\n    case BitstreamEntry::Record:\n      // The interesting case.\n      break;\n    }\n\n    // Tags are implicitly mapped to integers by their order.\n\n    Expected<unsigned> MaybeRecord = Stream.readRecord(Entry.ID, Record);\n    if (!MaybeRecord)\n      return MaybeRecord.takeError();\n    if (MaybeRecord.get() != bitc::OPERAND_BUNDLE_TAG)\n      return error(\"Invalid record\");\n\n    // OPERAND_BUNDLE_TAG: [strchr x N]\n    BundleTags.emplace_back();\n    if (convertToString(Record, 0, BundleTags.back()))\n      return error(\"Invalid record\");\n    Record.clear();\n  }\n}\n\nError BitcodeReader::parseSyncScopeNames() {\n  if (Error Err = Stream.EnterSubBlock(bitc::SYNC_SCOPE_NAMES_BLOCK_ID))\n    return Err;\n\n  if (!SSIDs.empty())\n    return error(\"Invalid multiple synchronization scope names blocks\");\n\n  SmallVector<uint64_t, 64> Record;\n  while (true) {\n    Expected<BitstreamEntry> MaybeEntry = Stream.advanceSkippingSubblocks();\n    if (!MaybeEntry)\n      return MaybeEntry.takeError();\n    BitstreamEntry Entry = MaybeEntry.get();\n\n    switch (Entry.Kind) {\n    case BitstreamEntry::SubBlock: // Handled for us already.\n    case BitstreamEntry::Error:\n      return error(\"Malformed block\");\n    case BitstreamEntry::EndBlock:\n      if (SSIDs.empty())\n        return error(\"Invalid empty synchronization scope names block\");\n      return Error::success();\n    case BitstreamEntry::Record:\n      // The interesting case.\n      break;\n    }\n\n    // Synchronization scope names are implicitly mapped to synchronization\n    // scope IDs by their order.\n\n    Expected<unsigned> MaybeRecord = Stream.readRecord(Entry.ID, Record);\n    if (!MaybeRecord)\n      return MaybeRecord.takeError();\n    if (MaybeRecord.get() != bitc::SYNC_SCOPE_NAME)\n      return error(\"Invalid record\");\n\n    SmallString<16> SSN;\n    if (convertToString(Record, 0, SSN))\n      return error(\"Invalid record\");\n\n    SSIDs.push_back(Context.getOrInsertSyncScopeID(SSN));\n    Record.clear();\n  }\n}\n\n/// Associate a value with its name from the given index in the provided record.\nExpected<Value *> BitcodeReader::recordValue(SmallVectorImpl<uint64_t> &Record,\n                                             unsigned NameIndex, Triple &TT) {\n  SmallString<128> ValueName;\n  if (convertToString(Record, NameIndex, ValueName))\n    return error(\"Invalid record\");\n  unsigned ValueID = Record[0];\n  if (ValueID >= ValueList.size() || !ValueList[ValueID])\n    return error(\"Invalid record\");\n  Value *V = ValueList[ValueID];\n\n  StringRef NameStr(ValueName.data(), ValueName.size());\n  if (NameStr.find_first_of(0) != StringRef::npos)\n    return error(\"Invalid value name\");\n  V->setName(NameStr);\n  auto *GO = dyn_cast<GlobalObject>(V);\n  if (GO) {\n    if (GO->getComdat() == reinterpret_cast<Comdat *>(1)) {\n      if (TT.supportsCOMDAT())\n        GO->setComdat(TheModule->getOrInsertComdat(V->getName()));\n      else\n        GO->setComdat(nullptr);\n    }\n  }\n  return V;\n}\n\n/// Helper to note and return the current location, and jump to the given\n/// offset.\nstatic Expected<uint64_t> jumpToValueSymbolTable(uint64_t Offset,\n                                                 BitstreamCursor &Stream) {\n  // Save the current parsing location so we can jump back at the end\n  // of the VST read.\n  uint64_t CurrentBit = Stream.GetCurrentBitNo();\n  if (Error JumpFailed = Stream.JumpToBit(Offset * 32))\n    return std::move(JumpFailed);\n  Expected<BitstreamEntry> MaybeEntry = Stream.advance();\n  if (!MaybeEntry)\n    return MaybeEntry.takeError();\n  assert(MaybeEntry.get().Kind == BitstreamEntry::SubBlock);\n  assert(MaybeEntry.get().ID == bitc::VALUE_SYMTAB_BLOCK_ID);\n  return CurrentBit;\n}\n\nvoid BitcodeReader::setDeferredFunctionInfo(unsigned FuncBitcodeOffsetDelta,\n                                            Function *F,\n                                            ArrayRef<uint64_t> Record) {\n  // Note that we subtract 1 here because the offset is relative to one word\n  // before the start of the identification or module block, which was\n  // historically always the start of the regular bitcode header.\n  uint64_t FuncWordOffset = Record[1] - 1;\n  uint64_t FuncBitOffset = FuncWordOffset * 32;\n  DeferredFunctionInfo[F] = FuncBitOffset + FuncBitcodeOffsetDelta;\n  // Set the LastFunctionBlockBit to point to the last function block.\n  // Later when parsing is resumed after function materialization,\n  // we can simply skip that last function block.\n  if (FuncBitOffset > LastFunctionBlockBit)\n    LastFunctionBlockBit = FuncBitOffset;\n}\n\n/// Read a new-style GlobalValue symbol table.\nError BitcodeReader::parseGlobalValueSymbolTable() {\n  unsigned FuncBitcodeOffsetDelta =\n      Stream.getAbbrevIDWidth() + bitc::BlockIDWidth;\n\n  if (Error Err = Stream.EnterSubBlock(bitc::VALUE_SYMTAB_BLOCK_ID))\n    return Err;\n\n  SmallVector<uint64_t, 64> Record;\n  while (true) {\n    Expected<BitstreamEntry> MaybeEntry = Stream.advanceSkippingSubblocks();\n    if (!MaybeEntry)\n      return MaybeEntry.takeError();\n    BitstreamEntry Entry = MaybeEntry.get();\n\n    switch (Entry.Kind) {\n    case BitstreamEntry::SubBlock:\n    case BitstreamEntry::Error:\n      return error(\"Malformed block\");\n    case BitstreamEntry::EndBlock:\n      return Error::success();\n    case BitstreamEntry::Record:\n      break;\n    }\n\n    Record.clear();\n    Expected<unsigned> MaybeRecord = Stream.readRecord(Entry.ID, Record);\n    if (!MaybeRecord)\n      return MaybeRecord.takeError();\n    switch (MaybeRecord.get()) {\n    case bitc::VST_CODE_FNENTRY: // [valueid, offset]\n      setDeferredFunctionInfo(FuncBitcodeOffsetDelta,\n                              cast<Function>(ValueList[Record[0]]), Record);\n      break;\n    }\n  }\n}\n\n/// Parse the value symbol table at either the current parsing location or\n/// at the given bit offset if provided.\nError BitcodeReader::parseValueSymbolTable(uint64_t Offset) {\n  uint64_t CurrentBit;\n  // Pass in the Offset to distinguish between calling for the module-level\n  // VST (where we want to jump to the VST offset) and the function-level\n  // VST (where we don't).\n  if (Offset > 0) {\n    Expected<uint64_t> MaybeCurrentBit = jumpToValueSymbolTable(Offset, Stream);\n    if (!MaybeCurrentBit)\n      return MaybeCurrentBit.takeError();\n    CurrentBit = MaybeCurrentBit.get();\n    // If this module uses a string table, read this as a module-level VST.\n    if (UseStrtab) {\n      if (Error Err = parseGlobalValueSymbolTable())\n        return Err;\n      if (Error JumpFailed = Stream.JumpToBit(CurrentBit))\n        return JumpFailed;\n      return Error::success();\n    }\n    // Otherwise, the VST will be in a similar format to a function-level VST,\n    // and will contain symbol names.\n  }\n\n  // Compute the delta between the bitcode indices in the VST (the word offset\n  // to the word-aligned ENTER_SUBBLOCK for the function block, and that\n  // expected by the lazy reader. The reader's EnterSubBlock expects to have\n  // already read the ENTER_SUBBLOCK code (size getAbbrevIDWidth) and BlockID\n  // (size BlockIDWidth). Note that we access the stream's AbbrevID width here\n  // just before entering the VST subblock because: 1) the EnterSubBlock\n  // changes the AbbrevID width; 2) the VST block is nested within the same\n  // outer MODULE_BLOCK as the FUNCTION_BLOCKs and therefore have the same\n  // AbbrevID width before calling EnterSubBlock; and 3) when we want to\n  // jump to the FUNCTION_BLOCK using this offset later, we don't want\n  // to rely on the stream's AbbrevID width being that of the MODULE_BLOCK.\n  unsigned FuncBitcodeOffsetDelta =\n      Stream.getAbbrevIDWidth() + bitc::BlockIDWidth;\n\n  if (Error Err = Stream.EnterSubBlock(bitc::VALUE_SYMTAB_BLOCK_ID))\n    return Err;\n\n  SmallVector<uint64_t, 64> Record;\n\n  Triple TT(TheModule->getTargetTriple());\n\n  // Read all the records for this value table.\n  SmallString<128> ValueName;\n\n  while (true) {\n    Expected<BitstreamEntry> MaybeEntry = Stream.advanceSkippingSubblocks();\n    if (!MaybeEntry)\n      return MaybeEntry.takeError();\n    BitstreamEntry Entry = MaybeEntry.get();\n\n    switch (Entry.Kind) {\n    case BitstreamEntry::SubBlock: // Handled for us already.\n    case BitstreamEntry::Error:\n      return error(\"Malformed block\");\n    case BitstreamEntry::EndBlock:\n      if (Offset > 0)\n        if (Error JumpFailed = Stream.JumpToBit(CurrentBit))\n          return JumpFailed;\n      return Error::success();\n    case BitstreamEntry::Record:\n      // The interesting case.\n      break;\n    }\n\n    // Read a record.\n    Record.clear();\n    Expected<unsigned> MaybeRecord = Stream.readRecord(Entry.ID, Record);\n    if (!MaybeRecord)\n      return MaybeRecord.takeError();\n    switch (MaybeRecord.get()) {\n    default:  // Default behavior: unknown type.\n      break;\n    case bitc::VST_CODE_ENTRY: {  // VST_CODE_ENTRY: [valueid, namechar x N]\n      Expected<Value *> ValOrErr = recordValue(Record, 1, TT);\n      if (Error Err = ValOrErr.takeError())\n        return Err;\n      ValOrErr.get();\n      break;\n    }\n    case bitc::VST_CODE_FNENTRY: {\n      // VST_CODE_FNENTRY: [valueid, offset, namechar x N]\n      Expected<Value *> ValOrErr = recordValue(Record, 2, TT);\n      if (Error Err = ValOrErr.takeError())\n        return Err;\n      Value *V = ValOrErr.get();\n\n      // Ignore function offsets emitted for aliases of functions in older\n      // versions of LLVM.\n      if (auto *F = dyn_cast<Function>(V))\n        setDeferredFunctionInfo(FuncBitcodeOffsetDelta, F, Record);\n      break;\n    }\n    case bitc::VST_CODE_BBENTRY: {\n      if (convertToString(Record, 1, ValueName))\n        return error(\"Invalid record\");\n      BasicBlock *BB = getBasicBlock(Record[0]);\n      if (!BB)\n        return error(\"Invalid record\");\n\n      BB->setName(StringRef(ValueName.data(), ValueName.size()));\n      ValueName.clear();\n      break;\n    }\n    }\n  }\n}\n\n/// Decode a signed value stored with the sign bit in the LSB for dense VBR\n/// encoding.\nuint64_t BitcodeReader::decodeSignRotatedValue(uint64_t V) {\n  if ((V & 1) == 0)\n    return V >> 1;\n  if (V != 1)\n    return -(V >> 1);\n  // There is no such thing as -0 with integers.  \"-0\" really means MININT.\n  return 1ULL << 63;\n}\n\n/// Resolve all of the initializers for global values and aliases that we can.\nError BitcodeReader::resolveGlobalAndIndirectSymbolInits() {\n  std::vector<std::pair<GlobalVariable *, unsigned>> GlobalInitWorklist;\n  std::vector<std::pair<GlobalIndirectSymbol *, unsigned>>\n      IndirectSymbolInitWorklist;\n  std::vector<std::pair<Function *, unsigned>> FunctionPrefixWorklist;\n  std::vector<std::pair<Function *, unsigned>> FunctionPrologueWorklist;\n  std::vector<std::pair<Function *, unsigned>> FunctionPersonalityFnWorklist;\n\n  GlobalInitWorklist.swap(GlobalInits);\n  IndirectSymbolInitWorklist.swap(IndirectSymbolInits);\n  FunctionPrefixWorklist.swap(FunctionPrefixes);\n  FunctionPrologueWorklist.swap(FunctionPrologues);\n  FunctionPersonalityFnWorklist.swap(FunctionPersonalityFns);\n\n  while (!GlobalInitWorklist.empty()) {\n    unsigned ValID = GlobalInitWorklist.back().second;\n    if (ValID >= ValueList.size()) {\n      // Not ready to resolve this yet, it requires something later in the file.\n      GlobalInits.push_back(GlobalInitWorklist.back());\n    } else {\n      if (Constant *C = dyn_cast_or_null<Constant>(ValueList[ValID]))\n        GlobalInitWorklist.back().first->setInitializer(C);\n      else\n        return error(\"Expected a constant\");\n    }\n    GlobalInitWorklist.pop_back();\n  }\n\n  while (!IndirectSymbolInitWorklist.empty()) {\n    unsigned ValID = IndirectSymbolInitWorklist.back().second;\n    if (ValID >= ValueList.size()) {\n      IndirectSymbolInits.push_back(IndirectSymbolInitWorklist.back());\n    } else {\n      Constant *C = dyn_cast_or_null<Constant>(ValueList[ValID]);\n      if (!C)\n        return error(\"Expected a constant\");\n      GlobalIndirectSymbol *GIS = IndirectSymbolInitWorklist.back().first;\n      if (isa<GlobalAlias>(GIS) && C->getType() != GIS->getType())\n        return error(\"Alias and aliasee types don't match\");\n      GIS->setIndirectSymbol(C);\n    }\n    IndirectSymbolInitWorklist.pop_back();\n  }\n\n  while (!FunctionPrefixWorklist.empty()) {\n    unsigned ValID = FunctionPrefixWorklist.back().second;\n    if (ValID >= ValueList.size()) {\n      FunctionPrefixes.push_back(FunctionPrefixWorklist.back());\n    } else {\n      if (Constant *C = dyn_cast_or_null<Constant>(ValueList[ValID]))\n        FunctionPrefixWorklist.back().first->setPrefixData(C);\n      else\n        return error(\"Expected a constant\");\n    }\n    FunctionPrefixWorklist.pop_back();\n  }\n\n  while (!FunctionPrologueWorklist.empty()) {\n    unsigned ValID = FunctionPrologueWorklist.back().second;\n    if (ValID >= ValueList.size()) {\n      FunctionPrologues.push_back(FunctionPrologueWorklist.back());\n    } else {\n      if (Constant *C = dyn_cast_or_null<Constant>(ValueList[ValID]))\n        FunctionPrologueWorklist.back().first->setPrologueData(C);\n      else\n        return error(\"Expected a constant\");\n    }\n    FunctionPrologueWorklist.pop_back();\n  }\n\n  while (!FunctionPersonalityFnWorklist.empty()) {\n    unsigned ValID = FunctionPersonalityFnWorklist.back().second;\n    if (ValID >= ValueList.size()) {\n      FunctionPersonalityFns.push_back(FunctionPersonalityFnWorklist.back());\n    } else {\n      if (Constant *C = dyn_cast_or_null<Constant>(ValueList[ValID]))\n        FunctionPersonalityFnWorklist.back().first->setPersonalityFn(C);\n      else\n        return error(\"Expected a constant\");\n    }\n    FunctionPersonalityFnWorklist.pop_back();\n  }\n\n  return Error::success();\n}\n\nAPInt llvm::readWideAPInt(ArrayRef<uint64_t> Vals, unsigned TypeBits) {\n  SmallVector<uint64_t, 8> Words(Vals.size());\n  transform(Vals, Words.begin(),\n                 BitcodeReader::decodeSignRotatedValue);\n\n  return APInt(TypeBits, Words);\n}\n\nError BitcodeReader::parseConstants() {\n  if (Error Err = Stream.EnterSubBlock(bitc::CONSTANTS_BLOCK_ID))\n    return Err;\n\n  SmallVector<uint64_t, 64> Record;\n\n  // Read all the records for this value table.\n  Type *CurTy = Type::getInt32Ty(Context);\n  Type *CurFullTy = Type::getInt32Ty(Context);\n  unsigned NextCstNo = ValueList.size();\n\n  struct DelayedShufTy {\n    VectorType *OpTy;\n    VectorType *RTy;\n    Type *CurFullTy;\n    uint64_t Op0Idx;\n    uint64_t Op1Idx;\n    uint64_t Op2Idx;\n    unsigned CstNo;\n  };\n  std::vector<DelayedShufTy> DelayedShuffles;\n  while (true) {\n    Expected<BitstreamEntry> MaybeEntry = Stream.advanceSkippingSubblocks();\n    if (!MaybeEntry)\n      return MaybeEntry.takeError();\n    BitstreamEntry Entry = MaybeEntry.get();\n\n    switch (Entry.Kind) {\n    case BitstreamEntry::SubBlock: // Handled for us already.\n    case BitstreamEntry::Error:\n      return error(\"Malformed block\");\n    case BitstreamEntry::EndBlock:\n      // Once all the constants have been read, go through and resolve forward\n      // references.\n      //\n      // We have to treat shuffles specially because they don't have three\n      // operands anymore.  We need to convert the shuffle mask into an array,\n      // and we can't convert a forward reference.\n      for (auto &DelayedShuffle : DelayedShuffles) {\n        VectorType *OpTy = DelayedShuffle.OpTy;\n        VectorType *RTy = DelayedShuffle.RTy;\n        uint64_t Op0Idx = DelayedShuffle.Op0Idx;\n        uint64_t Op1Idx = DelayedShuffle.Op1Idx;\n        uint64_t Op2Idx = DelayedShuffle.Op2Idx;\n        uint64_t CstNo = DelayedShuffle.CstNo;\n        Constant *Op0 = ValueList.getConstantFwdRef(Op0Idx, OpTy);\n        Constant *Op1 = ValueList.getConstantFwdRef(Op1Idx, OpTy);\n        Type *ShufTy =\n            VectorType::get(Type::getInt32Ty(Context), RTy->getElementCount());\n        Constant *Op2 = ValueList.getConstantFwdRef(Op2Idx, ShufTy);\n        if (!ShuffleVectorInst::isValidOperands(Op0, Op1, Op2))\n          return error(\"Invalid shufflevector operands\");\n        SmallVector<int, 16> Mask;\n        ShuffleVectorInst::getShuffleMask(Op2, Mask);\n        Value *V = ConstantExpr::getShuffleVector(Op0, Op1, Mask);\n        ValueList.assignValue(V, CstNo, DelayedShuffle.CurFullTy);\n      }\n\n      if (NextCstNo != ValueList.size())\n        return error(\"Invalid constant reference\");\n\n      ValueList.resolveConstantForwardRefs();\n      return Error::success();\n    case BitstreamEntry::Record:\n      // The interesting case.\n      break;\n    }\n\n    // Read a record.\n    Record.clear();\n    Type *VoidType = Type::getVoidTy(Context);\n    Value *V = nullptr;\n    Expected<unsigned> MaybeBitCode = Stream.readRecord(Entry.ID, Record);\n    if (!MaybeBitCode)\n      return MaybeBitCode.takeError();\n    switch (unsigned BitCode = MaybeBitCode.get()) {\n    default:  // Default behavior: unknown constant\n    case bitc::CST_CODE_UNDEF:     // UNDEF\n      V = UndefValue::get(CurTy);\n      break;\n    case bitc::CST_CODE_POISON:    // POISON\n      V = PoisonValue::get(CurTy);\n      break;\n    case bitc::CST_CODE_SETTYPE:   // SETTYPE: [typeid]\n      if (Record.empty())\n        return error(\"Invalid record\");\n      if (Record[0] >= TypeList.size() || !TypeList[Record[0]])\n        return error(\"Invalid record\");\n      if (TypeList[Record[0]] == VoidType)\n        return error(\"Invalid constant type\");\n      CurFullTy = TypeList[Record[0]];\n      CurTy = flattenPointerTypes(CurFullTy);\n      continue;  // Skip the ValueList manipulation.\n    case bitc::CST_CODE_NULL:      // NULL\n      if (CurTy->isVoidTy() || CurTy->isFunctionTy() || CurTy->isLabelTy())\n        return error(\"Invalid type for a constant null value\");\n      V = Constant::getNullValue(CurTy);\n      break;\n    case bitc::CST_CODE_INTEGER:   // INTEGER: [intval]\n      if (!CurTy->isIntegerTy() || Record.empty())\n        return error(\"Invalid record\");\n      V = ConstantInt::get(CurTy, decodeSignRotatedValue(Record[0]));\n      break;\n    case bitc::CST_CODE_WIDE_INTEGER: {// WIDE_INTEGER: [n x intval]\n      if (!CurTy->isIntegerTy() || Record.empty())\n        return error(\"Invalid record\");\n\n      APInt VInt =\n          readWideAPInt(Record, cast<IntegerType>(CurTy)->getBitWidth());\n      V = ConstantInt::get(Context, VInt);\n\n      break;\n    }\n    case bitc::CST_CODE_FLOAT: {    // FLOAT: [fpval]\n      if (Record.empty())\n        return error(\"Invalid record\");\n      if (CurTy->isHalfTy())\n        V = ConstantFP::get(Context, APFloat(APFloat::IEEEhalf(),\n                                             APInt(16, (uint16_t)Record[0])));\n      else if (CurTy->isBFloatTy())\n        V = ConstantFP::get(Context, APFloat(APFloat::BFloat(),\n                                             APInt(16, (uint32_t)Record[0])));\n      else if (CurTy->isFloatTy())\n        V = ConstantFP::get(Context, APFloat(APFloat::IEEEsingle(),\n                                             APInt(32, (uint32_t)Record[0])));\n      else if (CurTy->isDoubleTy())\n        V = ConstantFP::get(Context, APFloat(APFloat::IEEEdouble(),\n                                             APInt(64, Record[0])));\n      else if (CurTy->isX86_FP80Ty()) {\n        // Bits are not stored the same way as a normal i80 APInt, compensate.\n        uint64_t Rearrange[2];\n        Rearrange[0] = (Record[1] & 0xffffLL) | (Record[0] << 16);\n        Rearrange[1] = Record[0] >> 48;\n        V = ConstantFP::get(Context, APFloat(APFloat::x87DoubleExtended(),\n                                             APInt(80, Rearrange)));\n      } else if (CurTy->isFP128Ty())\n        V = ConstantFP::get(Context, APFloat(APFloat::IEEEquad(),\n                                             APInt(128, Record)));\n      else if (CurTy->isPPC_FP128Ty())\n        V = ConstantFP::get(Context, APFloat(APFloat::PPCDoubleDouble(),\n                                             APInt(128, Record)));\n      else\n        V = UndefValue::get(CurTy);\n      break;\n    }\n\n    case bitc::CST_CODE_AGGREGATE: {// AGGREGATE: [n x value number]\n      if (Record.empty())\n        return error(\"Invalid record\");\n\n      unsigned Size = Record.size();\n      SmallVector<Constant*, 16> Elts;\n\n      if (StructType *STy = dyn_cast<StructType>(CurTy)) {\n        for (unsigned i = 0; i != Size; ++i)\n          Elts.push_back(ValueList.getConstantFwdRef(Record[i],\n                                                     STy->getElementType(i)));\n        V = ConstantStruct::get(STy, Elts);\n      } else if (ArrayType *ATy = dyn_cast<ArrayType>(CurTy)) {\n        Type *EltTy = ATy->getElementType();\n        for (unsigned i = 0; i != Size; ++i)\n          Elts.push_back(ValueList.getConstantFwdRef(Record[i], EltTy));\n        V = ConstantArray::get(ATy, Elts);\n      } else if (VectorType *VTy = dyn_cast<VectorType>(CurTy)) {\n        Type *EltTy = VTy->getElementType();\n        for (unsigned i = 0; i != Size; ++i)\n          Elts.push_back(ValueList.getConstantFwdRef(Record[i], EltTy));\n        V = ConstantVector::get(Elts);\n      } else {\n        V = UndefValue::get(CurTy);\n      }\n      break;\n    }\n    case bitc::CST_CODE_STRING:    // STRING: [values]\n    case bitc::CST_CODE_CSTRING: { // CSTRING: [values]\n      if (Record.empty())\n        return error(\"Invalid record\");\n\n      SmallString<16> Elts(Record.begin(), Record.end());\n      V = ConstantDataArray::getString(Context, Elts,\n                                       BitCode == bitc::CST_CODE_CSTRING);\n      break;\n    }\n    case bitc::CST_CODE_DATA: {// DATA: [n x value]\n      if (Record.empty())\n        return error(\"Invalid record\");\n\n      Type *EltTy;\n      if (auto *Array = dyn_cast<ArrayType>(CurTy))\n        EltTy = Array->getElementType();\n      else\n        EltTy = cast<VectorType>(CurTy)->getElementType();\n      if (EltTy->isIntegerTy(8)) {\n        SmallVector<uint8_t, 16> Elts(Record.begin(), Record.end());\n        if (isa<VectorType>(CurTy))\n          V = ConstantDataVector::get(Context, Elts);\n        else\n          V = ConstantDataArray::get(Context, Elts);\n      } else if (EltTy->isIntegerTy(16)) {\n        SmallVector<uint16_t, 16> Elts(Record.begin(), Record.end());\n        if (isa<VectorType>(CurTy))\n          V = ConstantDataVector::get(Context, Elts);\n        else\n          V = ConstantDataArray::get(Context, Elts);\n      } else if (EltTy->isIntegerTy(32)) {\n        SmallVector<uint32_t, 16> Elts(Record.begin(), Record.end());\n        if (isa<VectorType>(CurTy))\n          V = ConstantDataVector::get(Context, Elts);\n        else\n          V = ConstantDataArray::get(Context, Elts);\n      } else if (EltTy->isIntegerTy(64)) {\n        SmallVector<uint64_t, 16> Elts(Record.begin(), Record.end());\n        if (isa<VectorType>(CurTy))\n          V = ConstantDataVector::get(Context, Elts);\n        else\n          V = ConstantDataArray::get(Context, Elts);\n      } else if (EltTy->isHalfTy()) {\n        SmallVector<uint16_t, 16> Elts(Record.begin(), Record.end());\n        if (isa<VectorType>(CurTy))\n          V = ConstantDataVector::getFP(EltTy, Elts);\n        else\n          V = ConstantDataArray::getFP(EltTy, Elts);\n      } else if (EltTy->isBFloatTy()) {\n        SmallVector<uint16_t, 16> Elts(Record.begin(), Record.end());\n        if (isa<VectorType>(CurTy))\n          V = ConstantDataVector::getFP(EltTy, Elts);\n        else\n          V = ConstantDataArray::getFP(EltTy, Elts);\n      } else if (EltTy->isFloatTy()) {\n        SmallVector<uint32_t, 16> Elts(Record.begin(), Record.end());\n        if (isa<VectorType>(CurTy))\n          V = ConstantDataVector::getFP(EltTy, Elts);\n        else\n          V = ConstantDataArray::getFP(EltTy, Elts);\n      } else if (EltTy->isDoubleTy()) {\n        SmallVector<uint64_t, 16> Elts(Record.begin(), Record.end());\n        if (isa<VectorType>(CurTy))\n          V = ConstantDataVector::getFP(EltTy, Elts);\n        else\n          V = ConstantDataArray::getFP(EltTy, Elts);\n      } else {\n        return error(\"Invalid type for value\");\n      }\n      break;\n    }\n    case bitc::CST_CODE_CE_UNOP: {  // CE_UNOP: [opcode, opval]\n      if (Record.size() < 2)\n        return error(\"Invalid record\");\n      int Opc = getDecodedUnaryOpcode(Record[0], CurTy);\n      if (Opc < 0) {\n        V = UndefValue::get(CurTy);  // Unknown unop.\n      } else {\n        Constant *LHS = ValueList.getConstantFwdRef(Record[1], CurTy);\n        unsigned Flags = 0;\n        V = ConstantExpr::get(Opc, LHS, Flags);\n      }\n      break;\n    }\n    case bitc::CST_CODE_CE_BINOP: {  // CE_BINOP: [opcode, opval, opval]\n      if (Record.size() < 3)\n        return error(\"Invalid record\");\n      int Opc = getDecodedBinaryOpcode(Record[0], CurTy);\n      if (Opc < 0) {\n        V = UndefValue::get(CurTy);  // Unknown binop.\n      } else {\n        Constant *LHS = ValueList.getConstantFwdRef(Record[1], CurTy);\n        Constant *RHS = ValueList.getConstantFwdRef(Record[2], CurTy);\n        unsigned Flags = 0;\n        if (Record.size() >= 4) {\n          if (Opc == Instruction::Add ||\n              Opc == Instruction::Sub ||\n              Opc == Instruction::Mul ||\n              Opc == Instruction::Shl) {\n            if (Record[3] & (1 << bitc::OBO_NO_SIGNED_WRAP))\n              Flags |= OverflowingBinaryOperator::NoSignedWrap;\n            if (Record[3] & (1 << bitc::OBO_NO_UNSIGNED_WRAP))\n              Flags |= OverflowingBinaryOperator::NoUnsignedWrap;\n          } else if (Opc == Instruction::SDiv ||\n                     Opc == Instruction::UDiv ||\n                     Opc == Instruction::LShr ||\n                     Opc == Instruction::AShr) {\n            if (Record[3] & (1 << bitc::PEO_EXACT))\n              Flags |= SDivOperator::IsExact;\n          }\n        }\n        V = ConstantExpr::get(Opc, LHS, RHS, Flags);\n      }\n      break;\n    }\n    case bitc::CST_CODE_CE_CAST: {  // CE_CAST: [opcode, opty, opval]\n      if (Record.size() < 3)\n        return error(\"Invalid record\");\n      int Opc = getDecodedCastOpcode(Record[0]);\n      if (Opc < 0) {\n        V = UndefValue::get(CurTy);  // Unknown cast.\n      } else {\n        Type *OpTy = getTypeByID(Record[1]);\n        if (!OpTy)\n          return error(\"Invalid record\");\n        Constant *Op = ValueList.getConstantFwdRef(Record[2], OpTy);\n        V = UpgradeBitCastExpr(Opc, Op, CurTy);\n        if (!V) V = ConstantExpr::getCast(Opc, Op, CurTy);\n      }\n      break;\n    }\n    case bitc::CST_CODE_CE_INBOUNDS_GEP: // [ty, n x operands]\n    case bitc::CST_CODE_CE_GEP: // [ty, n x operands]\n    case bitc::CST_CODE_CE_GEP_WITH_INRANGE_INDEX: { // [ty, flags, n x\n                                                     // operands]\n      unsigned OpNum = 0;\n      Type *PointeeType = nullptr;\n      if (BitCode == bitc::CST_CODE_CE_GEP_WITH_INRANGE_INDEX ||\n          Record.size() % 2)\n        PointeeType = getTypeByID(Record[OpNum++]);\n\n      bool InBounds = false;\n      Optional<unsigned> InRangeIndex;\n      if (BitCode == bitc::CST_CODE_CE_GEP_WITH_INRANGE_INDEX) {\n        uint64_t Op = Record[OpNum++];\n        InBounds = Op & 1;\n        InRangeIndex = Op >> 1;\n      } else if (BitCode == bitc::CST_CODE_CE_INBOUNDS_GEP)\n        InBounds = true;\n\n      SmallVector<Constant*, 16> Elts;\n      Type *Elt0FullTy = nullptr;\n      while (OpNum != Record.size()) {\n        if (!Elt0FullTy)\n          Elt0FullTy = getFullyStructuredTypeByID(Record[OpNum]);\n        Type *ElTy = getTypeByID(Record[OpNum++]);\n        if (!ElTy)\n          return error(\"Invalid record\");\n        Elts.push_back(ValueList.getConstantFwdRef(Record[OpNum++], ElTy));\n      }\n\n      if (Elts.size() < 1)\n        return error(\"Invalid gep with no operands\");\n\n      Type *ImplicitPointeeType =\n          getPointerElementFlatType(Elt0FullTy->getScalarType());\n      if (!PointeeType)\n        PointeeType = ImplicitPointeeType;\n      else if (PointeeType != ImplicitPointeeType)\n        return error(\"Explicit gep operator type does not match pointee type \"\n                     \"of pointer operand\");\n\n      ArrayRef<Constant *> Indices(Elts.begin() + 1, Elts.end());\n      V = ConstantExpr::getGetElementPtr(PointeeType, Elts[0], Indices,\n                                         InBounds, InRangeIndex);\n      break;\n    }\n    case bitc::CST_CODE_CE_SELECT: {  // CE_SELECT: [opval#, opval#, opval#]\n      if (Record.size() < 3)\n        return error(\"Invalid record\");\n\n      Type *SelectorTy = Type::getInt1Ty(Context);\n\n      // The selector might be an i1, an <n x i1>, or a <vscale x n x i1>\n      // Get the type from the ValueList before getting a forward ref.\n      if (VectorType *VTy = dyn_cast<VectorType>(CurTy))\n        if (Value *V = ValueList[Record[0]])\n          if (SelectorTy != V->getType())\n            SelectorTy = VectorType::get(SelectorTy,\n                                         VTy->getElementCount());\n\n      V = ConstantExpr::getSelect(ValueList.getConstantFwdRef(Record[0],\n                                                              SelectorTy),\n                                  ValueList.getConstantFwdRef(Record[1],CurTy),\n                                  ValueList.getConstantFwdRef(Record[2],CurTy));\n      break;\n    }\n    case bitc::CST_CODE_CE_EXTRACTELT\n        : { // CE_EXTRACTELT: [opty, opval, opty, opval]\n      if (Record.size() < 3)\n        return error(\"Invalid record\");\n      VectorType *OpTy =\n        dyn_cast_or_null<VectorType>(getTypeByID(Record[0]));\n      if (!OpTy)\n        return error(\"Invalid record\");\n      Constant *Op0 = ValueList.getConstantFwdRef(Record[1], OpTy);\n      Constant *Op1 = nullptr;\n      if (Record.size() == 4) {\n        Type *IdxTy = getTypeByID(Record[2]);\n        if (!IdxTy)\n          return error(\"Invalid record\");\n        Op1 = ValueList.getConstantFwdRef(Record[3], IdxTy);\n      } else {\n        // Deprecated, but still needed to read old bitcode files.\n        Op1 = ValueList.getConstantFwdRef(Record[2], Type::getInt32Ty(Context));\n      }\n      if (!Op1)\n        return error(\"Invalid record\");\n      V = ConstantExpr::getExtractElement(Op0, Op1);\n      break;\n    }\n    case bitc::CST_CODE_CE_INSERTELT\n        : { // CE_INSERTELT: [opval, opval, opty, opval]\n      VectorType *OpTy = dyn_cast<VectorType>(CurTy);\n      if (Record.size() < 3 || !OpTy)\n        return error(\"Invalid record\");\n      Constant *Op0 = ValueList.getConstantFwdRef(Record[0], OpTy);\n      Constant *Op1 = ValueList.getConstantFwdRef(Record[1],\n                                                  OpTy->getElementType());\n      Constant *Op2 = nullptr;\n      if (Record.size() == 4) {\n        Type *IdxTy = getTypeByID(Record[2]);\n        if (!IdxTy)\n          return error(\"Invalid record\");\n        Op2 = ValueList.getConstantFwdRef(Record[3], IdxTy);\n      } else {\n        // Deprecated, but still needed to read old bitcode files.\n        Op2 = ValueList.getConstantFwdRef(Record[2], Type::getInt32Ty(Context));\n      }\n      if (!Op2)\n        return error(\"Invalid record\");\n      V = ConstantExpr::getInsertElement(Op0, Op1, Op2);\n      break;\n    }\n    case bitc::CST_CODE_CE_SHUFFLEVEC: { // CE_SHUFFLEVEC: [opval, opval, opval]\n      VectorType *OpTy = dyn_cast<VectorType>(CurTy);\n      if (Record.size() < 3 || !OpTy)\n        return error(\"Invalid record\");\n      DelayedShuffles.push_back(\n          {OpTy, OpTy, CurFullTy, Record[0], Record[1], Record[2], NextCstNo});\n      ++NextCstNo;\n      continue;\n    }\n    case bitc::CST_CODE_CE_SHUFVEC_EX: { // [opty, opval, opval, opval]\n      VectorType *RTy = dyn_cast<VectorType>(CurTy);\n      VectorType *OpTy =\n        dyn_cast_or_null<VectorType>(getTypeByID(Record[0]));\n      if (Record.size() < 4 || !RTy || !OpTy)\n        return error(\"Invalid record\");\n      DelayedShuffles.push_back(\n          {OpTy, RTy, CurFullTy, Record[1], Record[2], Record[3], NextCstNo});\n      ++NextCstNo;\n      continue;\n    }\n    case bitc::CST_CODE_CE_CMP: {     // CE_CMP: [opty, opval, opval, pred]\n      if (Record.size() < 4)\n        return error(\"Invalid record\");\n      Type *OpTy = getTypeByID(Record[0]);\n      if (!OpTy)\n        return error(\"Invalid record\");\n      Constant *Op0 = ValueList.getConstantFwdRef(Record[1], OpTy);\n      Constant *Op1 = ValueList.getConstantFwdRef(Record[2], OpTy);\n\n      if (OpTy->isFPOrFPVectorTy())\n        V = ConstantExpr::getFCmp(Record[3], Op0, Op1);\n      else\n        V = ConstantExpr::getICmp(Record[3], Op0, Op1);\n      break;\n    }\n    // This maintains backward compatibility, pre-asm dialect keywords.\n    // Deprecated, but still needed to read old bitcode files.\n    case bitc::CST_CODE_INLINEASM_OLD: {\n      if (Record.size() < 2)\n        return error(\"Invalid record\");\n      std::string AsmStr, ConstrStr;\n      bool HasSideEffects = Record[0] & 1;\n      bool IsAlignStack = Record[0] >> 1;\n      unsigned AsmStrSize = Record[1];\n      if (2+AsmStrSize >= Record.size())\n        return error(\"Invalid record\");\n      unsigned ConstStrSize = Record[2+AsmStrSize];\n      if (3+AsmStrSize+ConstStrSize > Record.size())\n        return error(\"Invalid record\");\n\n      for (unsigned i = 0; i != AsmStrSize; ++i)\n        AsmStr += (char)Record[2+i];\n      for (unsigned i = 0; i != ConstStrSize; ++i)\n        ConstrStr += (char)Record[3+AsmStrSize+i];\n      UpgradeInlineAsmString(&AsmStr);\n      V = InlineAsm::get(\n          cast<FunctionType>(getPointerElementFlatType(CurFullTy)), AsmStr,\n          ConstrStr, HasSideEffects, IsAlignStack);\n      break;\n    }\n    // This version adds support for the asm dialect keywords (e.g.,\n    // inteldialect).\n    case bitc::CST_CODE_INLINEASM: {\n      if (Record.size() < 2)\n        return error(\"Invalid record\");\n      std::string AsmStr, ConstrStr;\n      bool HasSideEffects = Record[0] & 1;\n      bool IsAlignStack = (Record[0] >> 1) & 1;\n      unsigned AsmDialect = Record[0] >> 2;\n      unsigned AsmStrSize = Record[1];\n      if (2+AsmStrSize >= Record.size())\n        return error(\"Invalid record\");\n      unsigned ConstStrSize = Record[2+AsmStrSize];\n      if (3+AsmStrSize+ConstStrSize > Record.size())\n        return error(\"Invalid record\");\n\n      for (unsigned i = 0; i != AsmStrSize; ++i)\n        AsmStr += (char)Record[2+i];\n      for (unsigned i = 0; i != ConstStrSize; ++i)\n        ConstrStr += (char)Record[3+AsmStrSize+i];\n      UpgradeInlineAsmString(&AsmStr);\n      V = InlineAsm::get(\n          cast<FunctionType>(getPointerElementFlatType(CurFullTy)), AsmStr,\n          ConstrStr, HasSideEffects, IsAlignStack,\n          InlineAsm::AsmDialect(AsmDialect));\n      break;\n    }\n    case bitc::CST_CODE_BLOCKADDRESS:{\n      if (Record.size() < 3)\n        return error(\"Invalid record\");\n      Type *FnTy = getTypeByID(Record[0]);\n      if (!FnTy)\n        return error(\"Invalid record\");\n      Function *Fn =\n        dyn_cast_or_null<Function>(ValueList.getConstantFwdRef(Record[1],FnTy));\n      if (!Fn)\n        return error(\"Invalid record\");\n\n      // If the function is already parsed we can insert the block address right\n      // away.\n      BasicBlock *BB;\n      unsigned BBID = Record[2];\n      if (!BBID)\n        // Invalid reference to entry block.\n        return error(\"Invalid ID\");\n      if (!Fn->empty()) {\n        Function::iterator BBI = Fn->begin(), BBE = Fn->end();\n        for (size_t I = 0, E = BBID; I != E; ++I) {\n          if (BBI == BBE)\n            return error(\"Invalid ID\");\n          ++BBI;\n        }\n        BB = &*BBI;\n      } else {\n        // Otherwise insert a placeholder and remember it so it can be inserted\n        // when the function is parsed.\n        auto &FwdBBs = BasicBlockFwdRefs[Fn];\n        if (FwdBBs.empty())\n          BasicBlockFwdRefQueue.push_back(Fn);\n        if (FwdBBs.size() < BBID + 1)\n          FwdBBs.resize(BBID + 1);\n        if (!FwdBBs[BBID])\n          FwdBBs[BBID] = BasicBlock::Create(Context);\n        BB = FwdBBs[BBID];\n      }\n      V = BlockAddress::get(Fn, BB);\n      break;\n    }\n    }\n\n    assert(V->getType() == flattenPointerTypes(CurFullTy) &&\n           \"Incorrect fully structured type provided for Constant\");\n    ValueList.assignValue(V, NextCstNo, CurFullTy);\n    ++NextCstNo;\n  }\n}\n\nError BitcodeReader::parseUseLists() {\n  if (Error Err = Stream.EnterSubBlock(bitc::USELIST_BLOCK_ID))\n    return Err;\n\n  // Read all the records.\n  SmallVector<uint64_t, 64> Record;\n\n  while (true) {\n    Expected<BitstreamEntry> MaybeEntry = Stream.advanceSkippingSubblocks();\n    if (!MaybeEntry)\n      return MaybeEntry.takeError();\n    BitstreamEntry Entry = MaybeEntry.get();\n\n    switch (Entry.Kind) {\n    case BitstreamEntry::SubBlock: // Handled for us already.\n    case BitstreamEntry::Error:\n      return error(\"Malformed block\");\n    case BitstreamEntry::EndBlock:\n      return Error::success();\n    case BitstreamEntry::Record:\n      // The interesting case.\n      break;\n    }\n\n    // Read a use list record.\n    Record.clear();\n    bool IsBB = false;\n    Expected<unsigned> MaybeRecord = Stream.readRecord(Entry.ID, Record);\n    if (!MaybeRecord)\n      return MaybeRecord.takeError();\n    switch (MaybeRecord.get()) {\n    default:  // Default behavior: unknown type.\n      break;\n    case bitc::USELIST_CODE_BB:\n      IsBB = true;\n      LLVM_FALLTHROUGH;\n    case bitc::USELIST_CODE_DEFAULT: {\n      unsigned RecordLength = Record.size();\n      if (RecordLength < 3)\n        // Records should have at least an ID and two indexes.\n        return error(\"Invalid record\");\n      unsigned ID = Record.pop_back_val();\n\n      Value *V;\n      if (IsBB) {\n        assert(ID < FunctionBBs.size() && \"Basic block not found\");\n        V = FunctionBBs[ID];\n      } else\n        V = ValueList[ID];\n      unsigned NumUses = 0;\n      SmallDenseMap<const Use *, unsigned, 16> Order;\n      for (const Use &U : V->materialized_uses()) {\n        if (++NumUses > Record.size())\n          break;\n        Order[&U] = Record[NumUses - 1];\n      }\n      if (Order.size() != Record.size() || NumUses > Record.size())\n        // Mismatches can happen if the functions are being materialized lazily\n        // (out-of-order), or a value has been upgraded.\n        break;\n\n      V->sortUseList([&](const Use &L, const Use &R) {\n        return Order.lookup(&L) < Order.lookup(&R);\n      });\n      break;\n    }\n    }\n  }\n}\n\n/// When we see the block for metadata, remember where it is and then skip it.\n/// This lets us lazily deserialize the metadata.\nError BitcodeReader::rememberAndSkipMetadata() {\n  // Save the current stream state.\n  uint64_t CurBit = Stream.GetCurrentBitNo();\n  DeferredMetadataInfo.push_back(CurBit);\n\n  // Skip over the block for now.\n  if (Error Err = Stream.SkipBlock())\n    return Err;\n  return Error::success();\n}\n\nError BitcodeReader::materializeMetadata() {\n  for (uint64_t BitPos : DeferredMetadataInfo) {\n    // Move the bit stream to the saved position.\n    if (Error JumpFailed = Stream.JumpToBit(BitPos))\n      return JumpFailed;\n    if (Error Err = MDLoader->parseModuleMetadata())\n      return Err;\n  }\n\n  // Upgrade \"Linker Options\" module flag to \"llvm.linker.options\" module-level\n  // metadata. Only upgrade if the new option doesn't exist to avoid upgrade\n  // multiple times.\n  if (!TheModule->getNamedMetadata(\"llvm.linker.options\")) {\n    if (Metadata *Val = TheModule->getModuleFlag(\"Linker Options\")) {\n      NamedMDNode *LinkerOpts =\n          TheModule->getOrInsertNamedMetadata(\"llvm.linker.options\");\n      for (const MDOperand &MDOptions : cast<MDNode>(Val)->operands())\n        LinkerOpts->addOperand(cast<MDNode>(MDOptions));\n    }\n  }\n\n  DeferredMetadataInfo.clear();\n  return Error::success();\n}\n\nvoid BitcodeReader::setStripDebugInfo() { StripDebugInfo = true; }\n\n/// When we see the block for a function body, remember where it is and then\n/// skip it.  This lets us lazily deserialize the functions.\nError BitcodeReader::rememberAndSkipFunctionBody() {\n  // Get the function we are talking about.\n  if (FunctionsWithBodies.empty())\n    return error(\"Insufficient function protos\");\n\n  Function *Fn = FunctionsWithBodies.back();\n  FunctionsWithBodies.pop_back();\n\n  // Save the current stream state.\n  uint64_t CurBit = Stream.GetCurrentBitNo();\n  assert(\n      (DeferredFunctionInfo[Fn] == 0 || DeferredFunctionInfo[Fn] == CurBit) &&\n      \"Mismatch between VST and scanned function offsets\");\n  DeferredFunctionInfo[Fn] = CurBit;\n\n  // Skip over the function block for now.\n  if (Error Err = Stream.SkipBlock())\n    return Err;\n  return Error::success();\n}\n\nError BitcodeReader::globalCleanup() {\n  // Patch the initializers for globals and aliases up.\n  if (Error Err = resolveGlobalAndIndirectSymbolInits())\n    return Err;\n  if (!GlobalInits.empty() || !IndirectSymbolInits.empty())\n    return error(\"Malformed global initializer set\");\n\n  // Look for intrinsic functions which need to be upgraded at some point\n  // and functions that need to have their function attributes upgraded.\n  for (Function &F : *TheModule) {\n    MDLoader->upgradeDebugIntrinsics(F);\n    Function *NewFn;\n    if (UpgradeIntrinsicFunction(&F, NewFn))\n      UpgradedIntrinsics[&F] = NewFn;\n    else if (auto Remangled = Intrinsic::remangleIntrinsicFunction(&F))\n      // Some types could be renamed during loading if several modules are\n      // loaded in the same LLVMContext (LTO scenario). In this case we should\n      // remangle intrinsics names as well.\n      RemangledIntrinsics[&F] = Remangled.getValue();\n    // Look for functions that rely on old function attribute behavior.\n    UpgradeFunctionAttributes(F);\n  }\n\n  // Look for global variables which need to be renamed.\n  std::vector<std::pair<GlobalVariable *, GlobalVariable *>> UpgradedVariables;\n  for (GlobalVariable &GV : TheModule->globals())\n    if (GlobalVariable *Upgraded = UpgradeGlobalVariable(&GV))\n      UpgradedVariables.emplace_back(&GV, Upgraded);\n  for (auto &Pair : UpgradedVariables) {\n    Pair.first->eraseFromParent();\n    TheModule->getGlobalList().push_back(Pair.second);\n  }\n\n  // Force deallocation of memory for these vectors to favor the client that\n  // want lazy deserialization.\n  std::vector<std::pair<GlobalVariable *, unsigned>>().swap(GlobalInits);\n  std::vector<std::pair<GlobalIndirectSymbol *, unsigned>>().swap(\n      IndirectSymbolInits);\n  return Error::success();\n}\n\n/// Support for lazy parsing of function bodies. This is required if we\n/// either have an old bitcode file without a VST forward declaration record,\n/// or if we have an anonymous function being materialized, since anonymous\n/// functions do not have a name and are therefore not in the VST.\nError BitcodeReader::rememberAndSkipFunctionBodies() {\n  if (Error JumpFailed = Stream.JumpToBit(NextUnreadBit))\n    return JumpFailed;\n\n  if (Stream.AtEndOfStream())\n    return error(\"Could not find function in stream\");\n\n  if (!SeenFirstFunctionBody)\n    return error(\"Trying to materialize functions before seeing function blocks\");\n\n  // An old bitcode file with the symbol table at the end would have\n  // finished the parse greedily.\n  assert(SeenValueSymbolTable);\n\n  SmallVector<uint64_t, 64> Record;\n\n  while (true) {\n    Expected<llvm::BitstreamEntry> MaybeEntry = Stream.advance();\n    if (!MaybeEntry)\n      return MaybeEntry.takeError();\n    llvm::BitstreamEntry Entry = MaybeEntry.get();\n\n    switch (Entry.Kind) {\n    default:\n      return error(\"Expect SubBlock\");\n    case BitstreamEntry::SubBlock:\n      switch (Entry.ID) {\n      default:\n        return error(\"Expect function block\");\n      case bitc::FUNCTION_BLOCK_ID:\n        if (Error Err = rememberAndSkipFunctionBody())\n          return Err;\n        NextUnreadBit = Stream.GetCurrentBitNo();\n        return Error::success();\n      }\n    }\n  }\n}\n\nbool BitcodeReaderBase::readBlockInfo() {\n  Expected<Optional<BitstreamBlockInfo>> MaybeNewBlockInfo =\n      Stream.ReadBlockInfoBlock();\n  if (!MaybeNewBlockInfo)\n    return true; // FIXME Handle the error.\n  Optional<BitstreamBlockInfo> NewBlockInfo =\n      std::move(MaybeNewBlockInfo.get());\n  if (!NewBlockInfo)\n    return true;\n  BlockInfo = std::move(*NewBlockInfo);\n  return false;\n}\n\nError BitcodeReader::parseComdatRecord(ArrayRef<uint64_t> Record) {\n  // v1: [selection_kind, name]\n  // v2: [strtab_offset, strtab_size, selection_kind]\n  StringRef Name;\n  std::tie(Name, Record) = readNameFromStrtab(Record);\n\n  if (Record.empty())\n    return error(\"Invalid record\");\n  Comdat::SelectionKind SK = getDecodedComdatSelectionKind(Record[0]);\n  std::string OldFormatName;\n  if (!UseStrtab) {\n    if (Record.size() < 2)\n      return error(\"Invalid record\");\n    unsigned ComdatNameSize = Record[1];\n    OldFormatName.reserve(ComdatNameSize);\n    for (unsigned i = 0; i != ComdatNameSize; ++i)\n      OldFormatName += (char)Record[2 + i];\n    Name = OldFormatName;\n  }\n  Comdat *C = TheModule->getOrInsertComdat(Name);\n  C->setSelectionKind(SK);\n  ComdatList.push_back(C);\n  return Error::success();\n}\n\nstatic void inferDSOLocal(GlobalValue *GV) {\n  // infer dso_local from linkage and visibility if it is not encoded.\n  if (GV->hasLocalLinkage() ||\n      (!GV->hasDefaultVisibility() && !GV->hasExternalWeakLinkage()))\n    GV->setDSOLocal(true);\n}\n\nError BitcodeReader::parseGlobalVarRecord(ArrayRef<uint64_t> Record) {\n  // v1: [pointer type, isconst, initid, linkage, alignment, section,\n  // visibility, threadlocal, unnamed_addr, externally_initialized,\n  // dllstorageclass, comdat, attributes, preemption specifier,\n  // partition strtab offset, partition strtab size] (name in VST)\n  // v2: [strtab_offset, strtab_size, v1]\n  StringRef Name;\n  std::tie(Name, Record) = readNameFromStrtab(Record);\n\n  if (Record.size() < 6)\n    return error(\"Invalid record\");\n  Type *FullTy = getFullyStructuredTypeByID(Record[0]);\n  Type *Ty = flattenPointerTypes(FullTy);\n  if (!Ty)\n    return error(\"Invalid record\");\n  bool isConstant = Record[1] & 1;\n  bool explicitType = Record[1] & 2;\n  unsigned AddressSpace;\n  if (explicitType) {\n    AddressSpace = Record[1] >> 2;\n  } else {\n    if (!Ty->isPointerTy())\n      return error(\"Invalid type for value\");\n    AddressSpace = cast<PointerType>(Ty)->getAddressSpace();\n    std::tie(FullTy, Ty) = getPointerElementTypes(FullTy);\n  }\n\n  uint64_t RawLinkage = Record[3];\n  GlobalValue::LinkageTypes Linkage = getDecodedLinkage(RawLinkage);\n  MaybeAlign Alignment;\n  if (Error Err = parseAlignmentValue(Record[4], Alignment))\n    return Err;\n  std::string Section;\n  if (Record[5]) {\n    if (Record[5] - 1 >= SectionTable.size())\n      return error(\"Invalid ID\");\n    Section = SectionTable[Record[5] - 1];\n  }\n  GlobalValue::VisibilityTypes Visibility = GlobalValue::DefaultVisibility;\n  // Local linkage must have default visibility.\n  // auto-upgrade `hidden` and `protected` for old bitcode.\n  if (Record.size() > 6 && !GlobalValue::isLocalLinkage(Linkage))\n    Visibility = getDecodedVisibility(Record[6]);\n\n  GlobalVariable::ThreadLocalMode TLM = GlobalVariable::NotThreadLocal;\n  if (Record.size() > 7)\n    TLM = getDecodedThreadLocalMode(Record[7]);\n\n  GlobalValue::UnnamedAddr UnnamedAddr = GlobalValue::UnnamedAddr::None;\n  if (Record.size() > 8)\n    UnnamedAddr = getDecodedUnnamedAddrType(Record[8]);\n\n  bool ExternallyInitialized = false;\n  if (Record.size() > 9)\n    ExternallyInitialized = Record[9];\n\n  GlobalVariable *NewGV =\n      new GlobalVariable(*TheModule, Ty, isConstant, Linkage, nullptr, Name,\n                         nullptr, TLM, AddressSpace, ExternallyInitialized);\n  NewGV->setAlignment(Alignment);\n  if (!Section.empty())\n    NewGV->setSection(Section);\n  NewGV->setVisibility(Visibility);\n  NewGV->setUnnamedAddr(UnnamedAddr);\n\n  if (Record.size() > 10)\n    NewGV->setDLLStorageClass(getDecodedDLLStorageClass(Record[10]));\n  else\n    upgradeDLLImportExportLinkage(NewGV, RawLinkage);\n\n  FullTy = PointerType::get(FullTy, AddressSpace);\n  assert(NewGV->getType() == flattenPointerTypes(FullTy) &&\n         \"Incorrect fully specified type for GlobalVariable\");\n  ValueList.push_back(NewGV, FullTy);\n\n  // Remember which value to use for the global initializer.\n  if (unsigned InitID = Record[2])\n    GlobalInits.push_back(std::make_pair(NewGV, InitID - 1));\n\n  if (Record.size() > 11) {\n    if (unsigned ComdatID = Record[11]) {\n      if (ComdatID > ComdatList.size())\n        return error(\"Invalid global variable comdat ID\");\n      NewGV->setComdat(ComdatList[ComdatID - 1]);\n    }\n  } else if (hasImplicitComdat(RawLinkage)) {\n    NewGV->setComdat(reinterpret_cast<Comdat *>(1));\n  }\n\n  if (Record.size() > 12) {\n    auto AS = getAttributes(Record[12]).getFnAttributes();\n    NewGV->setAttributes(AS);\n  }\n\n  if (Record.size() > 13) {\n    NewGV->setDSOLocal(getDecodedDSOLocal(Record[13]));\n  }\n  inferDSOLocal(NewGV);\n\n  // Check whether we have enough values to read a partition name.\n  if (Record.size() > 15)\n    NewGV->setPartition(StringRef(Strtab.data() + Record[14], Record[15]));\n\n  return Error::success();\n}\n\nError BitcodeReader::parseFunctionRecord(ArrayRef<uint64_t> Record) {\n  // v1: [type, callingconv, isproto, linkage, paramattr, alignment, section,\n  // visibility, gc, unnamed_addr, prologuedata, dllstorageclass, comdat,\n  // prefixdata,  personalityfn, preemption specifier, addrspace] (name in VST)\n  // v2: [strtab_offset, strtab_size, v1]\n  StringRef Name;\n  std::tie(Name, Record) = readNameFromStrtab(Record);\n\n  if (Record.size() < 8)\n    return error(\"Invalid record\");\n  Type *FullFTy = getFullyStructuredTypeByID(Record[0]);\n  Type *FTy = flattenPointerTypes(FullFTy);\n  if (!FTy)\n    return error(\"Invalid record\");\n  if (isa<PointerType>(FTy))\n    std::tie(FullFTy, FTy) = getPointerElementTypes(FullFTy);\n\n  if (!isa<FunctionType>(FTy))\n    return error(\"Invalid type for value\");\n  auto CC = static_cast<CallingConv::ID>(Record[1]);\n  if (CC & ~CallingConv::MaxID)\n    return error(\"Invalid calling convention ID\");\n\n  unsigned AddrSpace = TheModule->getDataLayout().getProgramAddressSpace();\n  if (Record.size() > 16)\n    AddrSpace = Record[16];\n\n  Function *Func =\n      Function::Create(cast<FunctionType>(FTy), GlobalValue::ExternalLinkage,\n                       AddrSpace, Name, TheModule);\n\n  assert(Func->getFunctionType() == flattenPointerTypes(FullFTy) &&\n         \"Incorrect fully specified type provided for function\");\n  FunctionTypes[Func] = cast<FunctionType>(FullFTy);\n\n  Func->setCallingConv(CC);\n  bool isProto = Record[2];\n  uint64_t RawLinkage = Record[3];\n  Func->setLinkage(getDecodedLinkage(RawLinkage));\n  Func->setAttributes(getAttributes(Record[4]));\n\n  // Upgrade any old-style byval or sret without a type by propagating the\n  // argument's pointee type. There should be no opaque pointers where the byval\n  // type is implicit.\n  for (unsigned i = 0; i != Func->arg_size(); ++i) {\n    for (Attribute::AttrKind Kind : {Attribute::ByVal, Attribute::StructRet}) {\n      if (!Func->hasParamAttribute(i, Kind))\n        continue;\n\n      Func->removeParamAttr(i, Kind);\n\n      Type *PTy = cast<FunctionType>(FullFTy)->getParamType(i);\n      Type *PtrEltTy = getPointerElementFlatType(PTy);\n      Attribute NewAttr =\n          Kind == Attribute::ByVal\n              ? Attribute::getWithByValType(Context, PtrEltTy)\n              : Attribute::getWithStructRetType(Context, PtrEltTy);\n      Func->addParamAttr(i, NewAttr);\n    }\n  }\n\n  MaybeAlign Alignment;\n  if (Error Err = parseAlignmentValue(Record[5], Alignment))\n    return Err;\n  Func->setAlignment(Alignment);\n  if (Record[6]) {\n    if (Record[6] - 1 >= SectionTable.size())\n      return error(\"Invalid ID\");\n    Func->setSection(SectionTable[Record[6] - 1]);\n  }\n  // Local linkage must have default visibility.\n  // auto-upgrade `hidden` and `protected` for old bitcode.\n  if (!Func->hasLocalLinkage())\n    Func->setVisibility(getDecodedVisibility(Record[7]));\n  if (Record.size() > 8 && Record[8]) {\n    if (Record[8] - 1 >= GCTable.size())\n      return error(\"Invalid ID\");\n    Func->setGC(GCTable[Record[8] - 1]);\n  }\n  GlobalValue::UnnamedAddr UnnamedAddr = GlobalValue::UnnamedAddr::None;\n  if (Record.size() > 9)\n    UnnamedAddr = getDecodedUnnamedAddrType(Record[9]);\n  Func->setUnnamedAddr(UnnamedAddr);\n  if (Record.size() > 10 && Record[10] != 0)\n    FunctionPrologues.push_back(std::make_pair(Func, Record[10] - 1));\n\n  if (Record.size() > 11)\n    Func->setDLLStorageClass(getDecodedDLLStorageClass(Record[11]));\n  else\n    upgradeDLLImportExportLinkage(Func, RawLinkage);\n\n  if (Record.size() > 12) {\n    if (unsigned ComdatID = Record[12]) {\n      if (ComdatID > ComdatList.size())\n        return error(\"Invalid function comdat ID\");\n      Func->setComdat(ComdatList[ComdatID - 1]);\n    }\n  } else if (hasImplicitComdat(RawLinkage)) {\n    Func->setComdat(reinterpret_cast<Comdat *>(1));\n  }\n\n  if (Record.size() > 13 && Record[13] != 0)\n    FunctionPrefixes.push_back(std::make_pair(Func, Record[13] - 1));\n\n  if (Record.size() > 14 && Record[14] != 0)\n    FunctionPersonalityFns.push_back(std::make_pair(Func, Record[14] - 1));\n\n  if (Record.size() > 15) {\n    Func->setDSOLocal(getDecodedDSOLocal(Record[15]));\n  }\n  inferDSOLocal(Func);\n\n  // Record[16] is the address space number.\n\n  // Check whether we have enough values to read a partition name.\n  if (Record.size() > 18)\n    Func->setPartition(StringRef(Strtab.data() + Record[17], Record[18]));\n\n  Type *FullTy = PointerType::get(FullFTy, AddrSpace);\n  assert(Func->getType() == flattenPointerTypes(FullTy) &&\n         \"Incorrect fully specified type provided for Function\");\n  ValueList.push_back(Func, FullTy);\n\n  // If this is a function with a body, remember the prototype we are\n  // creating now, so that we can match up the body with them later.\n  if (!isProto) {\n    Func->setIsMaterializable(true);\n    FunctionsWithBodies.push_back(Func);\n    DeferredFunctionInfo[Func] = 0;\n  }\n  return Error::success();\n}\n\nError BitcodeReader::parseGlobalIndirectSymbolRecord(\n    unsigned BitCode, ArrayRef<uint64_t> Record) {\n  // v1 ALIAS_OLD: [alias type, aliasee val#, linkage] (name in VST)\n  // v1 ALIAS: [alias type, addrspace, aliasee val#, linkage, visibility,\n  // dllstorageclass, threadlocal, unnamed_addr,\n  // preemption specifier] (name in VST)\n  // v1 IFUNC: [alias type, addrspace, aliasee val#, linkage,\n  // visibility, dllstorageclass, threadlocal, unnamed_addr,\n  // preemption specifier] (name in VST)\n  // v2: [strtab_offset, strtab_size, v1]\n  StringRef Name;\n  std::tie(Name, Record) = readNameFromStrtab(Record);\n\n  bool NewRecord = BitCode != bitc::MODULE_CODE_ALIAS_OLD;\n  if (Record.size() < (3 + (unsigned)NewRecord))\n    return error(\"Invalid record\");\n  unsigned OpNum = 0;\n  Type *FullTy = getFullyStructuredTypeByID(Record[OpNum++]);\n  Type *Ty = flattenPointerTypes(FullTy);\n  if (!Ty)\n    return error(\"Invalid record\");\n\n  unsigned AddrSpace;\n  if (!NewRecord) {\n    auto *PTy = dyn_cast<PointerType>(Ty);\n    if (!PTy)\n      return error(\"Invalid type for value\");\n    std::tie(FullTy, Ty) = getPointerElementTypes(FullTy);\n    AddrSpace = PTy->getAddressSpace();\n  } else {\n    AddrSpace = Record[OpNum++];\n  }\n\n  auto Val = Record[OpNum++];\n  auto Linkage = Record[OpNum++];\n  GlobalIndirectSymbol *NewGA;\n  if (BitCode == bitc::MODULE_CODE_ALIAS ||\n      BitCode == bitc::MODULE_CODE_ALIAS_OLD)\n    NewGA = GlobalAlias::create(Ty, AddrSpace, getDecodedLinkage(Linkage), Name,\n                                TheModule);\n  else\n    NewGA = GlobalIFunc::create(Ty, AddrSpace, getDecodedLinkage(Linkage), Name,\n                                nullptr, TheModule);\n\n  assert(NewGA->getValueType() == flattenPointerTypes(FullTy) &&\n         \"Incorrect fully structured type provided for GlobalIndirectSymbol\");\n  // Local linkage must have default visibility.\n  // auto-upgrade `hidden` and `protected` for old bitcode.\n  if (OpNum != Record.size()) {\n    auto VisInd = OpNum++;\n    if (!NewGA->hasLocalLinkage())\n      NewGA->setVisibility(getDecodedVisibility(Record[VisInd]));\n  }\n  if (BitCode == bitc::MODULE_CODE_ALIAS ||\n      BitCode == bitc::MODULE_CODE_ALIAS_OLD) {\n    if (OpNum != Record.size())\n      NewGA->setDLLStorageClass(getDecodedDLLStorageClass(Record[OpNum++]));\n    else\n      upgradeDLLImportExportLinkage(NewGA, Linkage);\n    if (OpNum != Record.size())\n      NewGA->setThreadLocalMode(getDecodedThreadLocalMode(Record[OpNum++]));\n    if (OpNum != Record.size())\n      NewGA->setUnnamedAddr(getDecodedUnnamedAddrType(Record[OpNum++]));\n  }\n  if (OpNum != Record.size())\n    NewGA->setDSOLocal(getDecodedDSOLocal(Record[OpNum++]));\n  inferDSOLocal(NewGA);\n\n  // Check whether we have enough values to read a partition name.\n  if (OpNum + 1 < Record.size()) {\n    NewGA->setPartition(\n        StringRef(Strtab.data() + Record[OpNum], Record[OpNum + 1]));\n    OpNum += 2;\n  }\n\n  FullTy = PointerType::get(FullTy, AddrSpace);\n  assert(NewGA->getType() == flattenPointerTypes(FullTy) &&\n         \"Incorrect fully structured type provided for GlobalIndirectSymbol\");\n  ValueList.push_back(NewGA, FullTy);\n  IndirectSymbolInits.push_back(std::make_pair(NewGA, Val));\n  return Error::success();\n}\n\nError BitcodeReader::parseModule(uint64_t ResumeBit,\n                                 bool ShouldLazyLoadMetadata,\n                                 DataLayoutCallbackTy DataLayoutCallback) {\n  if (ResumeBit) {\n    if (Error JumpFailed = Stream.JumpToBit(ResumeBit))\n      return JumpFailed;\n  } else if (Error Err = Stream.EnterSubBlock(bitc::MODULE_BLOCK_ID))\n    return Err;\n\n  SmallVector<uint64_t, 64> Record;\n\n  // Parts of bitcode parsing depend on the datalayout.  Make sure we\n  // finalize the datalayout before we run any of that code.\n  bool ResolvedDataLayout = false;\n  auto ResolveDataLayout = [&] {\n    if (ResolvedDataLayout)\n      return;\n\n    // datalayout and triple can't be parsed after this point.\n    ResolvedDataLayout = true;\n\n    // Upgrade data layout string.\n    std::string DL = llvm::UpgradeDataLayoutString(\n        TheModule->getDataLayoutStr(), TheModule->getTargetTriple());\n    TheModule->setDataLayout(DL);\n\n    if (auto LayoutOverride =\n            DataLayoutCallback(TheModule->getTargetTriple()))\n      TheModule->setDataLayout(*LayoutOverride);\n  };\n\n  // Read all the records for this module.\n  while (true) {\n    Expected<llvm::BitstreamEntry> MaybeEntry = Stream.advance();\n    if (!MaybeEntry)\n      return MaybeEntry.takeError();\n    llvm::BitstreamEntry Entry = MaybeEntry.get();\n\n    switch (Entry.Kind) {\n    case BitstreamEntry::Error:\n      return error(\"Malformed block\");\n    case BitstreamEntry::EndBlock:\n      ResolveDataLayout();\n      return globalCleanup();\n\n    case BitstreamEntry::SubBlock:\n      switch (Entry.ID) {\n      default:  // Skip unknown content.\n        if (Error Err = Stream.SkipBlock())\n          return Err;\n        break;\n      case bitc::BLOCKINFO_BLOCK_ID:\n        if (readBlockInfo())\n          return error(\"Malformed block\");\n        break;\n      case bitc::PARAMATTR_BLOCK_ID:\n        if (Error Err = parseAttributeBlock())\n          return Err;\n        break;\n      case bitc::PARAMATTR_GROUP_BLOCK_ID:\n        if (Error Err = parseAttributeGroupBlock())\n          return Err;\n        break;\n      case bitc::TYPE_BLOCK_ID_NEW:\n        if (Error Err = parseTypeTable())\n          return Err;\n        break;\n      case bitc::VALUE_SYMTAB_BLOCK_ID:\n        if (!SeenValueSymbolTable) {\n          // Either this is an old form VST without function index and an\n          // associated VST forward declaration record (which would have caused\n          // the VST to be jumped to and parsed before it was encountered\n          // normally in the stream), or there were no function blocks to\n          // trigger an earlier parsing of the VST.\n          assert(VSTOffset == 0 || FunctionsWithBodies.empty());\n          if (Error Err = parseValueSymbolTable())\n            return Err;\n          SeenValueSymbolTable = true;\n        } else {\n          // We must have had a VST forward declaration record, which caused\n          // the parser to jump to and parse the VST earlier.\n          assert(VSTOffset > 0);\n          if (Error Err = Stream.SkipBlock())\n            return Err;\n        }\n        break;\n      case bitc::CONSTANTS_BLOCK_ID:\n        if (Error Err = parseConstants())\n          return Err;\n        if (Error Err = resolveGlobalAndIndirectSymbolInits())\n          return Err;\n        break;\n      case bitc::METADATA_BLOCK_ID:\n        if (ShouldLazyLoadMetadata) {\n          if (Error Err = rememberAndSkipMetadata())\n            return Err;\n          break;\n        }\n        assert(DeferredMetadataInfo.empty() && \"Unexpected deferred metadata\");\n        if (Error Err = MDLoader->parseModuleMetadata())\n          return Err;\n        break;\n      case bitc::METADATA_KIND_BLOCK_ID:\n        if (Error Err = MDLoader->parseMetadataKinds())\n          return Err;\n        break;\n      case bitc::FUNCTION_BLOCK_ID:\n        ResolveDataLayout();\n\n        // If this is the first function body we've seen, reverse the\n        // FunctionsWithBodies list.\n        if (!SeenFirstFunctionBody) {\n          std::reverse(FunctionsWithBodies.begin(), FunctionsWithBodies.end());\n          if (Error Err = globalCleanup())\n            return Err;\n          SeenFirstFunctionBody = true;\n        }\n\n        if (VSTOffset > 0) {\n          // If we have a VST forward declaration record, make sure we\n          // parse the VST now if we haven't already. It is needed to\n          // set up the DeferredFunctionInfo vector for lazy reading.\n          if (!SeenValueSymbolTable) {\n            if (Error Err = BitcodeReader::parseValueSymbolTable(VSTOffset))\n              return Err;\n            SeenValueSymbolTable = true;\n            // Fall through so that we record the NextUnreadBit below.\n            // This is necessary in case we have an anonymous function that\n            // is later materialized. Since it will not have a VST entry we\n            // need to fall back to the lazy parse to find its offset.\n          } else {\n            // If we have a VST forward declaration record, but have already\n            // parsed the VST (just above, when the first function body was\n            // encountered here), then we are resuming the parse after\n            // materializing functions. The ResumeBit points to the\n            // start of the last function block recorded in the\n            // DeferredFunctionInfo map. Skip it.\n            if (Error Err = Stream.SkipBlock())\n              return Err;\n            continue;\n          }\n        }\n\n        // Support older bitcode files that did not have the function\n        // index in the VST, nor a VST forward declaration record, as\n        // well as anonymous functions that do not have VST entries.\n        // Build the DeferredFunctionInfo vector on the fly.\n        if (Error Err = rememberAndSkipFunctionBody())\n          return Err;\n\n        // Suspend parsing when we reach the function bodies. Subsequent\n        // materialization calls will resume it when necessary. If the bitcode\n        // file is old, the symbol table will be at the end instead and will not\n        // have been seen yet. In this case, just finish the parse now.\n        if (SeenValueSymbolTable) {\n          NextUnreadBit = Stream.GetCurrentBitNo();\n          // After the VST has been parsed, we need to make sure intrinsic name\n          // are auto-upgraded.\n          return globalCleanup();\n        }\n        break;\n      case bitc::USELIST_BLOCK_ID:\n        if (Error Err = parseUseLists())\n          return Err;\n        break;\n      case bitc::OPERAND_BUNDLE_TAGS_BLOCK_ID:\n        if (Error Err = parseOperandBundleTags())\n          return Err;\n        break;\n      case bitc::SYNC_SCOPE_NAMES_BLOCK_ID:\n        if (Error Err = parseSyncScopeNames())\n          return Err;\n        break;\n      }\n      continue;\n\n    case BitstreamEntry::Record:\n      // The interesting case.\n      break;\n    }\n\n    // Read a record.\n    Expected<unsigned> MaybeBitCode = Stream.readRecord(Entry.ID, Record);\n    if (!MaybeBitCode)\n      return MaybeBitCode.takeError();\n    switch (unsigned BitCode = MaybeBitCode.get()) {\n    default: break;  // Default behavior, ignore unknown content.\n    case bitc::MODULE_CODE_VERSION: {\n      Expected<unsigned> VersionOrErr = parseVersionRecord(Record);\n      if (!VersionOrErr)\n        return VersionOrErr.takeError();\n      UseRelativeIDs = *VersionOrErr >= 1;\n      break;\n    }\n    case bitc::MODULE_CODE_TRIPLE: {  // TRIPLE: [strchr x N]\n      if (ResolvedDataLayout)\n        return error(\"target triple too late in module\");\n      std::string S;\n      if (convertToString(Record, 0, S))\n        return error(\"Invalid record\");\n      TheModule->setTargetTriple(S);\n      break;\n    }\n    case bitc::MODULE_CODE_DATALAYOUT: {  // DATALAYOUT: [strchr x N]\n      if (ResolvedDataLayout)\n        return error(\"datalayout too late in module\");\n      std::string S;\n      if (convertToString(Record, 0, S))\n        return error(\"Invalid record\");\n      TheModule->setDataLayout(S);\n      break;\n    }\n    case bitc::MODULE_CODE_ASM: {  // ASM: [strchr x N]\n      std::string S;\n      if (convertToString(Record, 0, S))\n        return error(\"Invalid record\");\n      TheModule->setModuleInlineAsm(S);\n      break;\n    }\n    case bitc::MODULE_CODE_DEPLIB: {  // DEPLIB: [strchr x N]\n      // Deprecated, but still needed to read old bitcode files.\n      std::string S;\n      if (convertToString(Record, 0, S))\n        return error(\"Invalid record\");\n      // Ignore value.\n      break;\n    }\n    case bitc::MODULE_CODE_SECTIONNAME: {  // SECTIONNAME: [strchr x N]\n      std::string S;\n      if (convertToString(Record, 0, S))\n        return error(\"Invalid record\");\n      SectionTable.push_back(S);\n      break;\n    }\n    case bitc::MODULE_CODE_GCNAME: {  // SECTIONNAME: [strchr x N]\n      std::string S;\n      if (convertToString(Record, 0, S))\n        return error(\"Invalid record\");\n      GCTable.push_back(S);\n      break;\n    }\n    case bitc::MODULE_CODE_COMDAT:\n      if (Error Err = parseComdatRecord(Record))\n        return Err;\n      break;\n    case bitc::MODULE_CODE_GLOBALVAR:\n      if (Error Err = parseGlobalVarRecord(Record))\n        return Err;\n      break;\n    case bitc::MODULE_CODE_FUNCTION:\n      ResolveDataLayout();\n      if (Error Err = parseFunctionRecord(Record))\n        return Err;\n      break;\n    case bitc::MODULE_CODE_IFUNC:\n    case bitc::MODULE_CODE_ALIAS:\n    case bitc::MODULE_CODE_ALIAS_OLD:\n      if (Error Err = parseGlobalIndirectSymbolRecord(BitCode, Record))\n        return Err;\n      break;\n    /// MODULE_CODE_VSTOFFSET: [offset]\n    case bitc::MODULE_CODE_VSTOFFSET:\n      if (Record.empty())\n        return error(\"Invalid record\");\n      // Note that we subtract 1 here because the offset is relative to one word\n      // before the start of the identification or module block, which was\n      // historically always the start of the regular bitcode header.\n      VSTOffset = Record[0] - 1;\n      break;\n    /// MODULE_CODE_SOURCE_FILENAME: [namechar x N]\n    case bitc::MODULE_CODE_SOURCE_FILENAME:\n      SmallString<128> ValueName;\n      if (convertToString(Record, 0, ValueName))\n        return error(\"Invalid record\");\n      TheModule->setSourceFileName(ValueName);\n      break;\n    }\n    Record.clear();\n  }\n}\n\nError BitcodeReader::parseBitcodeInto(Module *M, bool ShouldLazyLoadMetadata,\n                                      bool IsImporting,\n                                      DataLayoutCallbackTy DataLayoutCallback) {\n  TheModule = M;\n  MDLoader = MetadataLoader(Stream, *M, ValueList, IsImporting,\n                            [&](unsigned ID) { return getTypeByID(ID); });\n  return parseModule(0, ShouldLazyLoadMetadata, DataLayoutCallback);\n}\n\nError BitcodeReader::typeCheckLoadStoreInst(Type *ValType, Type *PtrType) {\n  if (!isa<PointerType>(PtrType))\n    return error(\"Load/Store operand is not a pointer type\");\n  Type *ElemType = cast<PointerType>(PtrType)->getElementType();\n\n  if (ValType && ValType != ElemType)\n    return error(\"Explicit load/store type does not match pointee \"\n                 \"type of pointer operand\");\n  if (!PointerType::isLoadableOrStorableType(ElemType))\n    return error(\"Cannot load/store from pointer\");\n  return Error::success();\n}\n\nvoid BitcodeReader::propagateByValSRetTypes(CallBase *CB,\n                                            ArrayRef<Type *> ArgsFullTys) {\n  for (unsigned i = 0; i != CB->arg_size(); ++i) {\n    for (Attribute::AttrKind Kind : {Attribute::ByVal, Attribute::StructRet}) {\n      if (!CB->paramHasAttr(i, Kind))\n        continue;\n\n      CB->removeParamAttr(i, Kind);\n\n      Type *PtrEltTy = getPointerElementFlatType(ArgsFullTys[i]);\n      Attribute NewAttr =\n          Kind == Attribute::ByVal\n              ? Attribute::getWithByValType(Context, PtrEltTy)\n              : Attribute::getWithStructRetType(Context, PtrEltTy);\n      CB->addParamAttr(i, NewAttr);\n    }\n  }\n}\n\n/// Lazily parse the specified function body block.\nError BitcodeReader::parseFunctionBody(Function *F) {\n  if (Error Err = Stream.EnterSubBlock(bitc::FUNCTION_BLOCK_ID))\n    return Err;\n\n  // Unexpected unresolved metadata when parsing function.\n  if (MDLoader->hasFwdRefs())\n    return error(\"Invalid function metadata: incoming forward references\");\n\n  InstructionList.clear();\n  unsigned ModuleValueListSize = ValueList.size();\n  unsigned ModuleMDLoaderSize = MDLoader->size();\n\n  // Add all the function arguments to the value table.\n  unsigned ArgNo = 0;\n  FunctionType *FullFTy = FunctionTypes[F];\n  for (Argument &I : F->args()) {\n    assert(I.getType() == flattenPointerTypes(FullFTy->getParamType(ArgNo)) &&\n           \"Incorrect fully specified type for Function Argument\");\n    ValueList.push_back(&I, FullFTy->getParamType(ArgNo++));\n  }\n  unsigned NextValueNo = ValueList.size();\n  BasicBlock *CurBB = nullptr;\n  unsigned CurBBNo = 0;\n\n  DebugLoc LastLoc;\n  auto getLastInstruction = [&]() -> Instruction * {\n    if (CurBB && !CurBB->empty())\n      return &CurBB->back();\n    else if (CurBBNo && FunctionBBs[CurBBNo - 1] &&\n             !FunctionBBs[CurBBNo - 1]->empty())\n      return &FunctionBBs[CurBBNo - 1]->back();\n    return nullptr;\n  };\n\n  std::vector<OperandBundleDef> OperandBundles;\n\n  // Read all the records.\n  SmallVector<uint64_t, 64> Record;\n\n  while (true) {\n    Expected<llvm::BitstreamEntry> MaybeEntry = Stream.advance();\n    if (!MaybeEntry)\n      return MaybeEntry.takeError();\n    llvm::BitstreamEntry Entry = MaybeEntry.get();\n\n    switch (Entry.Kind) {\n    case BitstreamEntry::Error:\n      return error(\"Malformed block\");\n    case BitstreamEntry::EndBlock:\n      goto OutOfRecordLoop;\n\n    case BitstreamEntry::SubBlock:\n      switch (Entry.ID) {\n      default:  // Skip unknown content.\n        if (Error Err = Stream.SkipBlock())\n          return Err;\n        break;\n      case bitc::CONSTANTS_BLOCK_ID:\n        if (Error Err = parseConstants())\n          return Err;\n        NextValueNo = ValueList.size();\n        break;\n      case bitc::VALUE_SYMTAB_BLOCK_ID:\n        if (Error Err = parseValueSymbolTable())\n          return Err;\n        break;\n      case bitc::METADATA_ATTACHMENT_ID:\n        if (Error Err = MDLoader->parseMetadataAttachment(*F, InstructionList))\n          return Err;\n        break;\n      case bitc::METADATA_BLOCK_ID:\n        assert(DeferredMetadataInfo.empty() &&\n               \"Must read all module-level metadata before function-level\");\n        if (Error Err = MDLoader->parseFunctionMetadata())\n          return Err;\n        break;\n      case bitc::USELIST_BLOCK_ID:\n        if (Error Err = parseUseLists())\n          return Err;\n        break;\n      }\n      continue;\n\n    case BitstreamEntry::Record:\n      // The interesting case.\n      break;\n    }\n\n    // Read a record.\n    Record.clear();\n    Instruction *I = nullptr;\n    Type *FullTy = nullptr;\n    Expected<unsigned> MaybeBitCode = Stream.readRecord(Entry.ID, Record);\n    if (!MaybeBitCode)\n      return MaybeBitCode.takeError();\n    switch (unsigned BitCode = MaybeBitCode.get()) {\n    default: // Default behavior: reject\n      return error(\"Invalid value\");\n    case bitc::FUNC_CODE_DECLAREBLOCKS: {   // DECLAREBLOCKS: [nblocks]\n      if (Record.empty() || Record[0] == 0)\n        return error(\"Invalid record\");\n      // Create all the basic blocks for the function.\n      FunctionBBs.resize(Record[0]);\n\n      // See if anything took the address of blocks in this function.\n      auto BBFRI = BasicBlockFwdRefs.find(F);\n      if (BBFRI == BasicBlockFwdRefs.end()) {\n        for (unsigned i = 0, e = FunctionBBs.size(); i != e; ++i)\n          FunctionBBs[i] = BasicBlock::Create(Context, \"\", F);\n      } else {\n        auto &BBRefs = BBFRI->second;\n        // Check for invalid basic block references.\n        if (BBRefs.size() > FunctionBBs.size())\n          return error(\"Invalid ID\");\n        assert(!BBRefs.empty() && \"Unexpected empty array\");\n        assert(!BBRefs.front() && \"Invalid reference to entry block\");\n        for (unsigned I = 0, E = FunctionBBs.size(), RE = BBRefs.size(); I != E;\n             ++I)\n          if (I < RE && BBRefs[I]) {\n            BBRefs[I]->insertInto(F);\n            FunctionBBs[I] = BBRefs[I];\n          } else {\n            FunctionBBs[I] = BasicBlock::Create(Context, \"\", F);\n          }\n\n        // Erase from the table.\n        BasicBlockFwdRefs.erase(BBFRI);\n      }\n\n      CurBB = FunctionBBs[0];\n      continue;\n    }\n\n    case bitc::FUNC_CODE_DEBUG_LOC_AGAIN:  // DEBUG_LOC_AGAIN\n      // This record indicates that the last instruction is at the same\n      // location as the previous instruction with a location.\n      I = getLastInstruction();\n\n      if (!I)\n        return error(\"Invalid record\");\n      I->setDebugLoc(LastLoc);\n      I = nullptr;\n      continue;\n\n    case bitc::FUNC_CODE_DEBUG_LOC: {      // DEBUG_LOC: [line, col, scope, ia]\n      I = getLastInstruction();\n      if (!I || Record.size() < 4)\n        return error(\"Invalid record\");\n\n      unsigned Line = Record[0], Col = Record[1];\n      unsigned ScopeID = Record[2], IAID = Record[3];\n      bool isImplicitCode = Record.size() == 5 && Record[4];\n\n      MDNode *Scope = nullptr, *IA = nullptr;\n      if (ScopeID) {\n        Scope = dyn_cast_or_null<MDNode>(\n            MDLoader->getMetadataFwdRefOrLoad(ScopeID - 1));\n        if (!Scope)\n          return error(\"Invalid record\");\n      }\n      if (IAID) {\n        IA = dyn_cast_or_null<MDNode>(\n            MDLoader->getMetadataFwdRefOrLoad(IAID - 1));\n        if (!IA)\n          return error(\"Invalid record\");\n      }\n      LastLoc = DILocation::get(Scope->getContext(), Line, Col, Scope, IA,\n                                isImplicitCode);\n      I->setDebugLoc(LastLoc);\n      I = nullptr;\n      continue;\n    }\n    case bitc::FUNC_CODE_INST_UNOP: {    // UNOP: [opval, ty, opcode]\n      unsigned OpNum = 0;\n      Value *LHS;\n      if (getValueTypePair(Record, OpNum, NextValueNo, LHS) ||\n          OpNum+1 > Record.size())\n        return error(\"Invalid record\");\n\n      int Opc = getDecodedUnaryOpcode(Record[OpNum++], LHS->getType());\n      if (Opc == -1)\n        return error(\"Invalid record\");\n      I = UnaryOperator::Create((Instruction::UnaryOps)Opc, LHS);\n      InstructionList.push_back(I);\n      if (OpNum < Record.size()) {\n        if (isa<FPMathOperator>(I)) {\n          FastMathFlags FMF = getDecodedFastMathFlags(Record[OpNum]);\n          if (FMF.any())\n            I->setFastMathFlags(FMF);\n        }\n      }\n      break;\n    }\n    case bitc::FUNC_CODE_INST_BINOP: {    // BINOP: [opval, ty, opval, opcode]\n      unsigned OpNum = 0;\n      Value *LHS, *RHS;\n      if (getValueTypePair(Record, OpNum, NextValueNo, LHS) ||\n          popValue(Record, OpNum, NextValueNo, LHS->getType(), RHS) ||\n          OpNum+1 > Record.size())\n        return error(\"Invalid record\");\n\n      int Opc = getDecodedBinaryOpcode(Record[OpNum++], LHS->getType());\n      if (Opc == -1)\n        return error(\"Invalid record\");\n      I = BinaryOperator::Create((Instruction::BinaryOps)Opc, LHS, RHS);\n      InstructionList.push_back(I);\n      if (OpNum < Record.size()) {\n        if (Opc == Instruction::Add ||\n            Opc == Instruction::Sub ||\n            Opc == Instruction::Mul ||\n            Opc == Instruction::Shl) {\n          if (Record[OpNum] & (1 << bitc::OBO_NO_SIGNED_WRAP))\n            cast<BinaryOperator>(I)->setHasNoSignedWrap(true);\n          if (Record[OpNum] & (1 << bitc::OBO_NO_UNSIGNED_WRAP))\n            cast<BinaryOperator>(I)->setHasNoUnsignedWrap(true);\n        } else if (Opc == Instruction::SDiv ||\n                   Opc == Instruction::UDiv ||\n                   Opc == Instruction::LShr ||\n                   Opc == Instruction::AShr) {\n          if (Record[OpNum] & (1 << bitc::PEO_EXACT))\n            cast<BinaryOperator>(I)->setIsExact(true);\n        } else if (isa<FPMathOperator>(I)) {\n          FastMathFlags FMF = getDecodedFastMathFlags(Record[OpNum]);\n          if (FMF.any())\n            I->setFastMathFlags(FMF);\n        }\n\n      }\n      break;\n    }\n    case bitc::FUNC_CODE_INST_CAST: {    // CAST: [opval, opty, destty, castopc]\n      unsigned OpNum = 0;\n      Value *Op;\n      if (getValueTypePair(Record, OpNum, NextValueNo, Op) ||\n          OpNum+2 != Record.size())\n        return error(\"Invalid record\");\n\n      FullTy = getFullyStructuredTypeByID(Record[OpNum]);\n      Type *ResTy = flattenPointerTypes(FullTy);\n      int Opc = getDecodedCastOpcode(Record[OpNum + 1]);\n      if (Opc == -1 || !ResTy)\n        return error(\"Invalid record\");\n      Instruction *Temp = nullptr;\n      if ((I = UpgradeBitCastInst(Opc, Op, ResTy, Temp))) {\n        if (Temp) {\n          InstructionList.push_back(Temp);\n          assert(CurBB && \"No current BB?\");\n          CurBB->getInstList().push_back(Temp);\n        }\n      } else {\n        auto CastOp = (Instruction::CastOps)Opc;\n        if (!CastInst::castIsValid(CastOp, Op, ResTy))\n          return error(\"Invalid cast\");\n        I = CastInst::Create(CastOp, Op, ResTy);\n      }\n      InstructionList.push_back(I);\n      break;\n    }\n    case bitc::FUNC_CODE_INST_INBOUNDS_GEP_OLD:\n    case bitc::FUNC_CODE_INST_GEP_OLD:\n    case bitc::FUNC_CODE_INST_GEP: { // GEP: type, [n x operands]\n      unsigned OpNum = 0;\n\n      Type *Ty;\n      bool InBounds;\n\n      if (BitCode == bitc::FUNC_CODE_INST_GEP) {\n        InBounds = Record[OpNum++];\n        FullTy = getFullyStructuredTypeByID(Record[OpNum++]);\n        Ty = flattenPointerTypes(FullTy);\n      } else {\n        InBounds = BitCode == bitc::FUNC_CODE_INST_INBOUNDS_GEP_OLD;\n        Ty = nullptr;\n      }\n\n      Value *BasePtr;\n      Type *FullBaseTy = nullptr;\n      if (getValueTypePair(Record, OpNum, NextValueNo, BasePtr, &FullBaseTy))\n        return error(\"Invalid record\");\n\n      if (!Ty) {\n        std::tie(FullTy, Ty) =\n            getPointerElementTypes(FullBaseTy->getScalarType());\n      } else if (Ty != getPointerElementFlatType(FullBaseTy->getScalarType()))\n        return error(\n            \"Explicit gep type does not match pointee type of pointer operand\");\n\n      SmallVector<Value*, 16> GEPIdx;\n      while (OpNum != Record.size()) {\n        Value *Op;\n        if (getValueTypePair(Record, OpNum, NextValueNo, Op))\n          return error(\"Invalid record\");\n        GEPIdx.push_back(Op);\n      }\n\n      I = GetElementPtrInst::Create(Ty, BasePtr, GEPIdx);\n      FullTy = GetElementPtrInst::getGEPReturnType(FullTy, I, GEPIdx);\n\n      InstructionList.push_back(I);\n      if (InBounds)\n        cast<GetElementPtrInst>(I)->setIsInBounds(true);\n      break;\n    }\n\n    case bitc::FUNC_CODE_INST_EXTRACTVAL: {\n                                       // EXTRACTVAL: [opty, opval, n x indices]\n      unsigned OpNum = 0;\n      Value *Agg;\n      if (getValueTypePair(Record, OpNum, NextValueNo, Agg, &FullTy))\n        return error(\"Invalid record\");\n\n      unsigned RecSize = Record.size();\n      if (OpNum == RecSize)\n        return error(\"EXTRACTVAL: Invalid instruction with 0 indices\");\n\n      SmallVector<unsigned, 4> EXTRACTVALIdx;\n      for (; OpNum != RecSize; ++OpNum) {\n        bool IsArray = FullTy->isArrayTy();\n        bool IsStruct = FullTy->isStructTy();\n        uint64_t Index = Record[OpNum];\n\n        if (!IsStruct && !IsArray)\n          return error(\"EXTRACTVAL: Invalid type\");\n        if ((unsigned)Index != Index)\n          return error(\"Invalid value\");\n        if (IsStruct && Index >= FullTy->getStructNumElements())\n          return error(\"EXTRACTVAL: Invalid struct index\");\n        if (IsArray && Index >= FullTy->getArrayNumElements())\n          return error(\"EXTRACTVAL: Invalid array index\");\n        EXTRACTVALIdx.push_back((unsigned)Index);\n\n        if (IsStruct)\n          FullTy = FullTy->getStructElementType(Index);\n        else\n          FullTy = FullTy->getArrayElementType();\n      }\n\n      I = ExtractValueInst::Create(Agg, EXTRACTVALIdx);\n      InstructionList.push_back(I);\n      break;\n    }\n\n    case bitc::FUNC_CODE_INST_INSERTVAL: {\n                           // INSERTVAL: [opty, opval, opty, opval, n x indices]\n      unsigned OpNum = 0;\n      Value *Agg;\n      if (getValueTypePair(Record, OpNum, NextValueNo, Agg, &FullTy))\n        return error(\"Invalid record\");\n      Value *Val;\n      if (getValueTypePair(Record, OpNum, NextValueNo, Val))\n        return error(\"Invalid record\");\n\n      unsigned RecSize = Record.size();\n      if (OpNum == RecSize)\n        return error(\"INSERTVAL: Invalid instruction with 0 indices\");\n\n      SmallVector<unsigned, 4> INSERTVALIdx;\n      Type *CurTy = Agg->getType();\n      for (; OpNum != RecSize; ++OpNum) {\n        bool IsArray = CurTy->isArrayTy();\n        bool IsStruct = CurTy->isStructTy();\n        uint64_t Index = Record[OpNum];\n\n        if (!IsStruct && !IsArray)\n          return error(\"INSERTVAL: Invalid type\");\n        if ((unsigned)Index != Index)\n          return error(\"Invalid value\");\n        if (IsStruct && Index >= CurTy->getStructNumElements())\n          return error(\"INSERTVAL: Invalid struct index\");\n        if (IsArray && Index >= CurTy->getArrayNumElements())\n          return error(\"INSERTVAL: Invalid array index\");\n\n        INSERTVALIdx.push_back((unsigned)Index);\n        if (IsStruct)\n          CurTy = CurTy->getStructElementType(Index);\n        else\n          CurTy = CurTy->getArrayElementType();\n      }\n\n      if (CurTy != Val->getType())\n        return error(\"Inserted value type doesn't match aggregate type\");\n\n      I = InsertValueInst::Create(Agg, Val, INSERTVALIdx);\n      InstructionList.push_back(I);\n      break;\n    }\n\n    case bitc::FUNC_CODE_INST_SELECT: { // SELECT: [opval, ty, opval, opval]\n      // obsolete form of select\n      // handles select i1 ... in old bitcode\n      unsigned OpNum = 0;\n      Value *TrueVal, *FalseVal, *Cond;\n      if (getValueTypePair(Record, OpNum, NextValueNo, TrueVal, &FullTy) ||\n          popValue(Record, OpNum, NextValueNo, TrueVal->getType(), FalseVal) ||\n          popValue(Record, OpNum, NextValueNo, Type::getInt1Ty(Context), Cond))\n        return error(\"Invalid record\");\n\n      I = SelectInst::Create(Cond, TrueVal, FalseVal);\n      InstructionList.push_back(I);\n      break;\n    }\n\n    case bitc::FUNC_CODE_INST_VSELECT: {// VSELECT: [ty,opval,opval,predty,pred]\n      // new form of select\n      // handles select i1 or select [N x i1]\n      unsigned OpNum = 0;\n      Value *TrueVal, *FalseVal, *Cond;\n      if (getValueTypePair(Record, OpNum, NextValueNo, TrueVal, &FullTy) ||\n          popValue(Record, OpNum, NextValueNo, TrueVal->getType(), FalseVal) ||\n          getValueTypePair(Record, OpNum, NextValueNo, Cond))\n        return error(\"Invalid record\");\n\n      // select condition can be either i1 or [N x i1]\n      if (VectorType* vector_type =\n          dyn_cast<VectorType>(Cond->getType())) {\n        // expect <n x i1>\n        if (vector_type->getElementType() != Type::getInt1Ty(Context))\n          return error(\"Invalid type for value\");\n      } else {\n        // expect i1\n        if (Cond->getType() != Type::getInt1Ty(Context))\n          return error(\"Invalid type for value\");\n      }\n\n      I = SelectInst::Create(Cond, TrueVal, FalseVal);\n      InstructionList.push_back(I);\n      if (OpNum < Record.size() && isa<FPMathOperator>(I)) {\n        FastMathFlags FMF = getDecodedFastMathFlags(Record[OpNum]);\n        if (FMF.any())\n          I->setFastMathFlags(FMF);\n      }\n      break;\n    }\n\n    case bitc::FUNC_CODE_INST_EXTRACTELT: { // EXTRACTELT: [opty, opval, opval]\n      unsigned OpNum = 0;\n      Value *Vec, *Idx;\n      if (getValueTypePair(Record, OpNum, NextValueNo, Vec, &FullTy) ||\n          getValueTypePair(Record, OpNum, NextValueNo, Idx))\n        return error(\"Invalid record\");\n      if (!Vec->getType()->isVectorTy())\n        return error(\"Invalid type for value\");\n      I = ExtractElementInst::Create(Vec, Idx);\n      FullTy = cast<VectorType>(FullTy)->getElementType();\n      InstructionList.push_back(I);\n      break;\n    }\n\n    case bitc::FUNC_CODE_INST_INSERTELT: { // INSERTELT: [ty, opval,opval,opval]\n      unsigned OpNum = 0;\n      Value *Vec, *Elt, *Idx;\n      if (getValueTypePair(Record, OpNum, NextValueNo, Vec, &FullTy))\n        return error(\"Invalid record\");\n      if (!Vec->getType()->isVectorTy())\n        return error(\"Invalid type for value\");\n      if (popValue(Record, OpNum, NextValueNo,\n                   cast<VectorType>(Vec->getType())->getElementType(), Elt) ||\n          getValueTypePair(Record, OpNum, NextValueNo, Idx))\n        return error(\"Invalid record\");\n      I = InsertElementInst::Create(Vec, Elt, Idx);\n      InstructionList.push_back(I);\n      break;\n    }\n\n    case bitc::FUNC_CODE_INST_SHUFFLEVEC: {// SHUFFLEVEC: [opval,ty,opval,opval]\n      unsigned OpNum = 0;\n      Value *Vec1, *Vec2, *Mask;\n      if (getValueTypePair(Record, OpNum, NextValueNo, Vec1, &FullTy) ||\n          popValue(Record, OpNum, NextValueNo, Vec1->getType(), Vec2))\n        return error(\"Invalid record\");\n\n      if (getValueTypePair(Record, OpNum, NextValueNo, Mask))\n        return error(\"Invalid record\");\n      if (!Vec1->getType()->isVectorTy() || !Vec2->getType()->isVectorTy())\n        return error(\"Invalid type for value\");\n\n      I = new ShuffleVectorInst(Vec1, Vec2, Mask);\n      FullTy =\n          VectorType::get(cast<VectorType>(FullTy)->getElementType(),\n                          cast<VectorType>(Mask->getType())->getElementCount());\n      InstructionList.push_back(I);\n      break;\n    }\n\n    case bitc::FUNC_CODE_INST_CMP:   // CMP: [opty, opval, opval, pred]\n      // Old form of ICmp/FCmp returning bool\n      // Existed to differentiate between icmp/fcmp and vicmp/vfcmp which were\n      // both legal on vectors but had different behaviour.\n    case bitc::FUNC_CODE_INST_CMP2: { // CMP2: [opty, opval, opval, pred]\n      // FCmp/ICmp returning bool or vector of bool\n\n      unsigned OpNum = 0;\n      Value *LHS, *RHS;\n      if (getValueTypePair(Record, OpNum, NextValueNo, LHS) ||\n          popValue(Record, OpNum, NextValueNo, LHS->getType(), RHS))\n        return error(\"Invalid record\");\n\n      if (OpNum >= Record.size())\n        return error(\n            \"Invalid record: operand number exceeded available operands\");\n\n      unsigned PredVal = Record[OpNum];\n      bool IsFP = LHS->getType()->isFPOrFPVectorTy();\n      FastMathFlags FMF;\n      if (IsFP && Record.size() > OpNum+1)\n        FMF = getDecodedFastMathFlags(Record[++OpNum]);\n\n      if (OpNum+1 != Record.size())\n        return error(\"Invalid record\");\n\n      if (LHS->getType()->isFPOrFPVectorTy())\n        I = new FCmpInst((FCmpInst::Predicate)PredVal, LHS, RHS);\n      else\n        I = new ICmpInst((ICmpInst::Predicate)PredVal, LHS, RHS);\n\n      if (FMF.any())\n        I->setFastMathFlags(FMF);\n      InstructionList.push_back(I);\n      break;\n    }\n\n    case bitc::FUNC_CODE_INST_RET: // RET: [opty,opval<optional>]\n      {\n        unsigned Size = Record.size();\n        if (Size == 0) {\n          I = ReturnInst::Create(Context);\n          InstructionList.push_back(I);\n          break;\n        }\n\n        unsigned OpNum = 0;\n        Value *Op = nullptr;\n        if (getValueTypePair(Record, OpNum, NextValueNo, Op))\n          return error(\"Invalid record\");\n        if (OpNum != Record.size())\n          return error(\"Invalid record\");\n\n        I = ReturnInst::Create(Context, Op);\n        InstructionList.push_back(I);\n        break;\n      }\n    case bitc::FUNC_CODE_INST_BR: { // BR: [bb#, bb#, opval] or [bb#]\n      if (Record.size() != 1 && Record.size() != 3)\n        return error(\"Invalid record\");\n      BasicBlock *TrueDest = getBasicBlock(Record[0]);\n      if (!TrueDest)\n        return error(\"Invalid record\");\n\n      if (Record.size() == 1) {\n        I = BranchInst::Create(TrueDest);\n        InstructionList.push_back(I);\n      }\n      else {\n        BasicBlock *FalseDest = getBasicBlock(Record[1]);\n        Value *Cond = getValue(Record, 2, NextValueNo,\n                               Type::getInt1Ty(Context));\n        if (!FalseDest || !Cond)\n          return error(\"Invalid record\");\n        I = BranchInst::Create(TrueDest, FalseDest, Cond);\n        InstructionList.push_back(I);\n      }\n      break;\n    }\n    case bitc::FUNC_CODE_INST_CLEANUPRET: { // CLEANUPRET: [val] or [val,bb#]\n      if (Record.size() != 1 && Record.size() != 2)\n        return error(\"Invalid record\");\n      unsigned Idx = 0;\n      Value *CleanupPad =\n          getValue(Record, Idx++, NextValueNo, Type::getTokenTy(Context));\n      if (!CleanupPad)\n        return error(\"Invalid record\");\n      BasicBlock *UnwindDest = nullptr;\n      if (Record.size() == 2) {\n        UnwindDest = getBasicBlock(Record[Idx++]);\n        if (!UnwindDest)\n          return error(\"Invalid record\");\n      }\n\n      I = CleanupReturnInst::Create(CleanupPad, UnwindDest);\n      InstructionList.push_back(I);\n      break;\n    }\n    case bitc::FUNC_CODE_INST_CATCHRET: { // CATCHRET: [val,bb#]\n      if (Record.size() != 2)\n        return error(\"Invalid record\");\n      unsigned Idx = 0;\n      Value *CatchPad =\n          getValue(Record, Idx++, NextValueNo, Type::getTokenTy(Context));\n      if (!CatchPad)\n        return error(\"Invalid record\");\n      BasicBlock *BB = getBasicBlock(Record[Idx++]);\n      if (!BB)\n        return error(\"Invalid record\");\n\n      I = CatchReturnInst::Create(CatchPad, BB);\n      InstructionList.push_back(I);\n      break;\n    }\n    case bitc::FUNC_CODE_INST_CATCHSWITCH: { // CATCHSWITCH: [tok,num,(bb)*,bb?]\n      // We must have, at minimum, the outer scope and the number of arguments.\n      if (Record.size() < 2)\n        return error(\"Invalid record\");\n\n      unsigned Idx = 0;\n\n      Value *ParentPad =\n          getValue(Record, Idx++, NextValueNo, Type::getTokenTy(Context));\n\n      unsigned NumHandlers = Record[Idx++];\n\n      SmallVector<BasicBlock *, 2> Handlers;\n      for (unsigned Op = 0; Op != NumHandlers; ++Op) {\n        BasicBlock *BB = getBasicBlock(Record[Idx++]);\n        if (!BB)\n          return error(\"Invalid record\");\n        Handlers.push_back(BB);\n      }\n\n      BasicBlock *UnwindDest = nullptr;\n      if (Idx + 1 == Record.size()) {\n        UnwindDest = getBasicBlock(Record[Idx++]);\n        if (!UnwindDest)\n          return error(\"Invalid record\");\n      }\n\n      if (Record.size() != Idx)\n        return error(\"Invalid record\");\n\n      auto *CatchSwitch =\n          CatchSwitchInst::Create(ParentPad, UnwindDest, NumHandlers);\n      for (BasicBlock *Handler : Handlers)\n        CatchSwitch->addHandler(Handler);\n      I = CatchSwitch;\n      InstructionList.push_back(I);\n      break;\n    }\n    case bitc::FUNC_CODE_INST_CATCHPAD:\n    case bitc::FUNC_CODE_INST_CLEANUPPAD: { // [tok,num,(ty,val)*]\n      // We must have, at minimum, the outer scope and the number of arguments.\n      if (Record.size() < 2)\n        return error(\"Invalid record\");\n\n      unsigned Idx = 0;\n\n      Value *ParentPad =\n          getValue(Record, Idx++, NextValueNo, Type::getTokenTy(Context));\n\n      unsigned NumArgOperands = Record[Idx++];\n\n      SmallVector<Value *, 2> Args;\n      for (unsigned Op = 0; Op != NumArgOperands; ++Op) {\n        Value *Val;\n        if (getValueTypePair(Record, Idx, NextValueNo, Val))\n          return error(\"Invalid record\");\n        Args.push_back(Val);\n      }\n\n      if (Record.size() != Idx)\n        return error(\"Invalid record\");\n\n      if (BitCode == bitc::FUNC_CODE_INST_CLEANUPPAD)\n        I = CleanupPadInst::Create(ParentPad, Args);\n      else\n        I = CatchPadInst::Create(ParentPad, Args);\n      InstructionList.push_back(I);\n      break;\n    }\n    case bitc::FUNC_CODE_INST_SWITCH: { // SWITCH: [opty, op0, op1, ...]\n      // Check magic\n      if ((Record[0] >> 16) == SWITCH_INST_MAGIC) {\n        // \"New\" SwitchInst format with case ranges. The changes to write this\n        // format were reverted but we still recognize bitcode that uses it.\n        // Hopefully someday we will have support for case ranges and can use\n        // this format again.\n\n        Type *OpTy = getTypeByID(Record[1]);\n        unsigned ValueBitWidth = cast<IntegerType>(OpTy)->getBitWidth();\n\n        Value *Cond = getValue(Record, 2, NextValueNo, OpTy);\n        BasicBlock *Default = getBasicBlock(Record[3]);\n        if (!OpTy || !Cond || !Default)\n          return error(\"Invalid record\");\n\n        unsigned NumCases = Record[4];\n\n        SwitchInst *SI = SwitchInst::Create(Cond, Default, NumCases);\n        InstructionList.push_back(SI);\n\n        unsigned CurIdx = 5;\n        for (unsigned i = 0; i != NumCases; ++i) {\n          SmallVector<ConstantInt*, 1> CaseVals;\n          unsigned NumItems = Record[CurIdx++];\n          for (unsigned ci = 0; ci != NumItems; ++ci) {\n            bool isSingleNumber = Record[CurIdx++];\n\n            APInt Low;\n            unsigned ActiveWords = 1;\n            if (ValueBitWidth > 64)\n              ActiveWords = Record[CurIdx++];\n            Low = readWideAPInt(makeArrayRef(&Record[CurIdx], ActiveWords),\n                                ValueBitWidth);\n            CurIdx += ActiveWords;\n\n            if (!isSingleNumber) {\n              ActiveWords = 1;\n              if (ValueBitWidth > 64)\n                ActiveWords = Record[CurIdx++];\n              APInt High = readWideAPInt(\n                  makeArrayRef(&Record[CurIdx], ActiveWords), ValueBitWidth);\n              CurIdx += ActiveWords;\n\n              // FIXME: It is not clear whether values in the range should be\n              // compared as signed or unsigned values. The partially\n              // implemented changes that used this format in the past used\n              // unsigned comparisons.\n              for ( ; Low.ule(High); ++Low)\n                CaseVals.push_back(ConstantInt::get(Context, Low));\n            } else\n              CaseVals.push_back(ConstantInt::get(Context, Low));\n          }\n          BasicBlock *DestBB = getBasicBlock(Record[CurIdx++]);\n          for (SmallVector<ConstantInt*, 1>::iterator cvi = CaseVals.begin(),\n                 cve = CaseVals.end(); cvi != cve; ++cvi)\n            SI->addCase(*cvi, DestBB);\n        }\n        I = SI;\n        break;\n      }\n\n      // Old SwitchInst format without case ranges.\n\n      if (Record.size() < 3 || (Record.size() & 1) == 0)\n        return error(\"Invalid record\");\n      Type *OpTy = getTypeByID(Record[0]);\n      Value *Cond = getValue(Record, 1, NextValueNo, OpTy);\n      BasicBlock *Default = getBasicBlock(Record[2]);\n      if (!OpTy || !Cond || !Default)\n        return error(\"Invalid record\");\n      unsigned NumCases = (Record.size()-3)/2;\n      SwitchInst *SI = SwitchInst::Create(Cond, Default, NumCases);\n      InstructionList.push_back(SI);\n      for (unsigned i = 0, e = NumCases; i != e; ++i) {\n        ConstantInt *CaseVal =\n          dyn_cast_or_null<ConstantInt>(getFnValueByID(Record[3+i*2], OpTy));\n        BasicBlock *DestBB = getBasicBlock(Record[1+3+i*2]);\n        if (!CaseVal || !DestBB) {\n          delete SI;\n          return error(\"Invalid record\");\n        }\n        SI->addCase(CaseVal, DestBB);\n      }\n      I = SI;\n      break;\n    }\n    case bitc::FUNC_CODE_INST_INDIRECTBR: { // INDIRECTBR: [opty, op0, op1, ...]\n      if (Record.size() < 2)\n        return error(\"Invalid record\");\n      Type *OpTy = getTypeByID(Record[0]);\n      Value *Address = getValue(Record, 1, NextValueNo, OpTy);\n      if (!OpTy || !Address)\n        return error(\"Invalid record\");\n      unsigned NumDests = Record.size()-2;\n      IndirectBrInst *IBI = IndirectBrInst::Create(Address, NumDests);\n      InstructionList.push_back(IBI);\n      for (unsigned i = 0, e = NumDests; i != e; ++i) {\n        if (BasicBlock *DestBB = getBasicBlock(Record[2+i])) {\n          IBI->addDestination(DestBB);\n        } else {\n          delete IBI;\n          return error(\"Invalid record\");\n        }\n      }\n      I = IBI;\n      break;\n    }\n\n    case bitc::FUNC_CODE_INST_INVOKE: {\n      // INVOKE: [attrs, cc, normBB, unwindBB, fnty, op0,op1,op2, ...]\n      if (Record.size() < 4)\n        return error(\"Invalid record\");\n      unsigned OpNum = 0;\n      AttributeList PAL = getAttributes(Record[OpNum++]);\n      unsigned CCInfo = Record[OpNum++];\n      BasicBlock *NormalBB = getBasicBlock(Record[OpNum++]);\n      BasicBlock *UnwindBB = getBasicBlock(Record[OpNum++]);\n\n      FunctionType *FTy = nullptr;\n      FunctionType *FullFTy = nullptr;\n      if ((CCInfo >> 13) & 1) {\n        FullFTy =\n            dyn_cast<FunctionType>(getFullyStructuredTypeByID(Record[OpNum++]));\n        if (!FullFTy)\n          return error(\"Explicit invoke type is not a function type\");\n        FTy = cast<FunctionType>(flattenPointerTypes(FullFTy));\n      }\n\n      Value *Callee;\n      if (getValueTypePair(Record, OpNum, NextValueNo, Callee, &FullTy))\n        return error(\"Invalid record\");\n\n      PointerType *CalleeTy = dyn_cast<PointerType>(Callee->getType());\n      if (!CalleeTy)\n        return error(\"Callee is not a pointer\");\n      if (!FTy) {\n        FullFTy =\n            dyn_cast<FunctionType>(cast<PointerType>(FullTy)->getElementType());\n        if (!FullFTy)\n          return error(\"Callee is not of pointer to function type\");\n        FTy = cast<FunctionType>(flattenPointerTypes(FullFTy));\n      } else if (getPointerElementFlatType(FullTy) != FTy)\n        return error(\"Explicit invoke type does not match pointee type of \"\n                     \"callee operand\");\n      if (Record.size() < FTy->getNumParams() + OpNum)\n        return error(\"Insufficient operands to call\");\n\n      SmallVector<Value*, 16> Ops;\n      SmallVector<Type *, 16> ArgsFullTys;\n      for (unsigned i = 0, e = FTy->getNumParams(); i != e; ++i, ++OpNum) {\n        Ops.push_back(getValue(Record, OpNum, NextValueNo,\n                               FTy->getParamType(i)));\n        ArgsFullTys.push_back(FullFTy->getParamType(i));\n        if (!Ops.back())\n          return error(\"Invalid record\");\n      }\n\n      if (!FTy->isVarArg()) {\n        if (Record.size() != OpNum)\n          return error(\"Invalid record\");\n      } else {\n        // Read type/value pairs for varargs params.\n        while (OpNum != Record.size()) {\n          Value *Op;\n          Type *FullTy;\n          if (getValueTypePair(Record, OpNum, NextValueNo, Op, &FullTy))\n            return error(\"Invalid record\");\n          Ops.push_back(Op);\n          ArgsFullTys.push_back(FullTy);\n        }\n      }\n\n      I = InvokeInst::Create(FTy, Callee, NormalBB, UnwindBB, Ops,\n                             OperandBundles);\n      FullTy = FullFTy->getReturnType();\n      OperandBundles.clear();\n      InstructionList.push_back(I);\n      cast<InvokeInst>(I)->setCallingConv(\n          static_cast<CallingConv::ID>(CallingConv::MaxID & CCInfo));\n      cast<InvokeInst>(I)->setAttributes(PAL);\n      propagateByValSRetTypes(cast<CallBase>(I), ArgsFullTys);\n\n      break;\n    }\n    case bitc::FUNC_CODE_INST_RESUME: { // RESUME: [opval]\n      unsigned Idx = 0;\n      Value *Val = nullptr;\n      if (getValueTypePair(Record, Idx, NextValueNo, Val))\n        return error(\"Invalid record\");\n      I = ResumeInst::Create(Val);\n      InstructionList.push_back(I);\n      break;\n    }\n    case bitc::FUNC_CODE_INST_CALLBR: {\n      // CALLBR: [attr, cc, norm, transfs, fty, fnid, args]\n      unsigned OpNum = 0;\n      AttributeList PAL = getAttributes(Record[OpNum++]);\n      unsigned CCInfo = Record[OpNum++];\n\n      BasicBlock *DefaultDest = getBasicBlock(Record[OpNum++]);\n      unsigned NumIndirectDests = Record[OpNum++];\n      SmallVector<BasicBlock *, 16> IndirectDests;\n      for (unsigned i = 0, e = NumIndirectDests; i != e; ++i)\n        IndirectDests.push_back(getBasicBlock(Record[OpNum++]));\n\n      FunctionType *FTy = nullptr;\n      FunctionType *FullFTy = nullptr;\n      if ((CCInfo >> bitc::CALL_EXPLICIT_TYPE) & 1) {\n        FullFTy =\n            dyn_cast<FunctionType>(getFullyStructuredTypeByID(Record[OpNum++]));\n        if (!FullFTy)\n          return error(\"Explicit call type is not a function type\");\n        FTy = cast<FunctionType>(flattenPointerTypes(FullFTy));\n      }\n\n      Value *Callee;\n      if (getValueTypePair(Record, OpNum, NextValueNo, Callee, &FullTy))\n        return error(\"Invalid record\");\n\n      PointerType *OpTy = dyn_cast<PointerType>(Callee->getType());\n      if (!OpTy)\n        return error(\"Callee is not a pointer type\");\n      if (!FTy) {\n        FullFTy =\n            dyn_cast<FunctionType>(cast<PointerType>(FullTy)->getElementType());\n        if (!FullFTy)\n          return error(\"Callee is not of pointer to function type\");\n        FTy = cast<FunctionType>(flattenPointerTypes(FullFTy));\n      } else if (getPointerElementFlatType(FullTy) != FTy)\n        return error(\"Explicit call type does not match pointee type of \"\n                     \"callee operand\");\n      if (Record.size() < FTy->getNumParams() + OpNum)\n        return error(\"Insufficient operands to call\");\n\n      SmallVector<Value*, 16> Args;\n      // Read the fixed params.\n      for (unsigned i = 0, e = FTy->getNumParams(); i != e; ++i, ++OpNum) {\n        if (FTy->getParamType(i)->isLabelTy())\n          Args.push_back(getBasicBlock(Record[OpNum]));\n        else\n          Args.push_back(getValue(Record, OpNum, NextValueNo,\n                                  FTy->getParamType(i)));\n        if (!Args.back())\n          return error(\"Invalid record\");\n      }\n\n      // Read type/value pairs for varargs params.\n      if (!FTy->isVarArg()) {\n        if (OpNum != Record.size())\n          return error(\"Invalid record\");\n      } else {\n        while (OpNum != Record.size()) {\n          Value *Op;\n          if (getValueTypePair(Record, OpNum, NextValueNo, Op))\n            return error(\"Invalid record\");\n          Args.push_back(Op);\n        }\n      }\n\n      I = CallBrInst::Create(FTy, Callee, DefaultDest, IndirectDests, Args,\n                             OperandBundles);\n      FullTy = FullFTy->getReturnType();\n      OperandBundles.clear();\n      InstructionList.push_back(I);\n      cast<CallBrInst>(I)->setCallingConv(\n          static_cast<CallingConv::ID>((0x7ff & CCInfo) >> bitc::CALL_CCONV));\n      cast<CallBrInst>(I)->setAttributes(PAL);\n      break;\n    }\n    case bitc::FUNC_CODE_INST_UNREACHABLE: // UNREACHABLE\n      I = new UnreachableInst(Context);\n      InstructionList.push_back(I);\n      break;\n    case bitc::FUNC_CODE_INST_PHI: { // PHI: [ty, val0,bb0, ...]\n      if (Record.empty())\n        return error(\"Invalid record\");\n      // The first record specifies the type.\n      FullTy = getFullyStructuredTypeByID(Record[0]);\n      Type *Ty = flattenPointerTypes(FullTy);\n      if (!Ty)\n        return error(\"Invalid record\");\n\n      // Phi arguments are pairs of records of [value, basic block].\n      // There is an optional final record for fast-math-flags if this phi has a\n      // floating-point type.\n      size_t NumArgs = (Record.size() - 1) / 2;\n      PHINode *PN = PHINode::Create(Ty, NumArgs);\n      if ((Record.size() - 1) % 2 == 1 && !isa<FPMathOperator>(PN))\n        return error(\"Invalid record\");\n      InstructionList.push_back(PN);\n\n      for (unsigned i = 0; i != NumArgs; i++) {\n        Value *V;\n        // With the new function encoding, it is possible that operands have\n        // negative IDs (for forward references).  Use a signed VBR\n        // representation to keep the encoding small.\n        if (UseRelativeIDs)\n          V = getValueSigned(Record, i * 2 + 1, NextValueNo, Ty);\n        else\n          V = getValue(Record, i * 2 + 1, NextValueNo, Ty);\n        BasicBlock *BB = getBasicBlock(Record[i * 2 + 2]);\n        if (!V || !BB)\n          return error(\"Invalid record\");\n        PN->addIncoming(V, BB);\n      }\n      I = PN;\n\n      // If there are an even number of records, the final record must be FMF.\n      if (Record.size() % 2 == 0) {\n        assert(isa<FPMathOperator>(I) && \"Unexpected phi type\");\n        FastMathFlags FMF = getDecodedFastMathFlags(Record[Record.size() - 1]);\n        if (FMF.any())\n          I->setFastMathFlags(FMF);\n      }\n\n      break;\n    }\n\n    case bitc::FUNC_CODE_INST_LANDINGPAD:\n    case bitc::FUNC_CODE_INST_LANDINGPAD_OLD: {\n      // LANDINGPAD: [ty, val, val, num, (id0,val0 ...)?]\n      unsigned Idx = 0;\n      if (BitCode == bitc::FUNC_CODE_INST_LANDINGPAD) {\n        if (Record.size() < 3)\n          return error(\"Invalid record\");\n      } else {\n        assert(BitCode == bitc::FUNC_CODE_INST_LANDINGPAD_OLD);\n        if (Record.size() < 4)\n          return error(\"Invalid record\");\n      }\n      FullTy = getFullyStructuredTypeByID(Record[Idx++]);\n      Type *Ty = flattenPointerTypes(FullTy);\n      if (!Ty)\n        return error(\"Invalid record\");\n      if (BitCode == bitc::FUNC_CODE_INST_LANDINGPAD_OLD) {\n        Value *PersFn = nullptr;\n        if (getValueTypePair(Record, Idx, NextValueNo, PersFn))\n          return error(\"Invalid record\");\n\n        if (!F->hasPersonalityFn())\n          F->setPersonalityFn(cast<Constant>(PersFn));\n        else if (F->getPersonalityFn() != cast<Constant>(PersFn))\n          return error(\"Personality function mismatch\");\n      }\n\n      bool IsCleanup = !!Record[Idx++];\n      unsigned NumClauses = Record[Idx++];\n      LandingPadInst *LP = LandingPadInst::Create(Ty, NumClauses);\n      LP->setCleanup(IsCleanup);\n      for (unsigned J = 0; J != NumClauses; ++J) {\n        LandingPadInst::ClauseType CT =\n          LandingPadInst::ClauseType(Record[Idx++]); (void)CT;\n        Value *Val;\n\n        if (getValueTypePair(Record, Idx, NextValueNo, Val)) {\n          delete LP;\n          return error(\"Invalid record\");\n        }\n\n        assert((CT != LandingPadInst::Catch ||\n                !isa<ArrayType>(Val->getType())) &&\n               \"Catch clause has a invalid type!\");\n        assert((CT != LandingPadInst::Filter ||\n                isa<ArrayType>(Val->getType())) &&\n               \"Filter clause has invalid type!\");\n        LP->addClause(cast<Constant>(Val));\n      }\n\n      I = LP;\n      InstructionList.push_back(I);\n      break;\n    }\n\n    case bitc::FUNC_CODE_INST_ALLOCA: { // ALLOCA: [instty, opty, op, align]\n      if (Record.size() != 4)\n        return error(\"Invalid record\");\n      using APV = AllocaPackedValues;\n      const uint64_t Rec = Record[3];\n      const bool InAlloca = Bitfield::get<APV::UsedWithInAlloca>(Rec);\n      const bool SwiftError = Bitfield::get<APV::SwiftError>(Rec);\n      FullTy = getFullyStructuredTypeByID(Record[0]);\n      Type *Ty = flattenPointerTypes(FullTy);\n      if (!Bitfield::get<APV::ExplicitType>(Rec)) {\n        auto *PTy = dyn_cast_or_null<PointerType>(Ty);\n        if (!PTy)\n          return error(\"Old-style alloca with a non-pointer type\");\n        std::tie(FullTy, Ty) = getPointerElementTypes(FullTy);\n      }\n      Type *OpTy = getTypeByID(Record[1]);\n      Value *Size = getFnValueByID(Record[2], OpTy);\n      MaybeAlign Align;\n      if (Error Err =\n              parseAlignmentValue(Bitfield::get<APV::Align>(Rec), Align)) {\n        return Err;\n      }\n      if (!Ty || !Size)\n        return error(\"Invalid record\");\n\n      // FIXME: Make this an optional field.\n      const DataLayout &DL = TheModule->getDataLayout();\n      unsigned AS = DL.getAllocaAddrSpace();\n\n      SmallPtrSet<Type *, 4> Visited;\n      if (!Align && !Ty->isSized(&Visited))\n        return error(\"alloca of unsized type\");\n      if (!Align)\n        Align = DL.getPrefTypeAlign(Ty);\n\n      AllocaInst *AI = new AllocaInst(Ty, AS, Size, *Align);\n      AI->setUsedWithInAlloca(InAlloca);\n      AI->setSwiftError(SwiftError);\n      I = AI;\n      FullTy = PointerType::get(FullTy, AS);\n      InstructionList.push_back(I);\n      break;\n    }\n    case bitc::FUNC_CODE_INST_LOAD: { // LOAD: [opty, op, align, vol]\n      unsigned OpNum = 0;\n      Value *Op;\n      if (getValueTypePair(Record, OpNum, NextValueNo, Op, &FullTy) ||\n          (OpNum + 2 != Record.size() && OpNum + 3 != Record.size()))\n        return error(\"Invalid record\");\n\n      if (!isa<PointerType>(Op->getType()))\n        return error(\"Load operand is not a pointer type\");\n\n      Type *Ty = nullptr;\n      if (OpNum + 3 == Record.size()) {\n        FullTy = getFullyStructuredTypeByID(Record[OpNum++]);\n        Ty = flattenPointerTypes(FullTy);\n      } else\n        std::tie(FullTy, Ty) = getPointerElementTypes(FullTy);\n\n      if (Error Err = typeCheckLoadStoreInst(Ty, Op->getType()))\n        return Err;\n\n      MaybeAlign Align;\n      if (Error Err = parseAlignmentValue(Record[OpNum], Align))\n        return Err;\n      SmallPtrSet<Type *, 4> Visited;\n      if (!Align && !Ty->isSized(&Visited))\n        return error(\"load of unsized type\");\n      if (!Align)\n        Align = TheModule->getDataLayout().getABITypeAlign(Ty);\n      I = new LoadInst(Ty, Op, \"\", Record[OpNum + 1], *Align);\n      InstructionList.push_back(I);\n      break;\n    }\n    case bitc::FUNC_CODE_INST_LOADATOMIC: {\n       // LOADATOMIC: [opty, op, align, vol, ordering, ssid]\n      unsigned OpNum = 0;\n      Value *Op;\n      if (getValueTypePair(Record, OpNum, NextValueNo, Op, &FullTy) ||\n          (OpNum + 4 != Record.size() && OpNum + 5 != Record.size()))\n        return error(\"Invalid record\");\n\n      if (!isa<PointerType>(Op->getType()))\n        return error(\"Load operand is not a pointer type\");\n\n      Type *Ty = nullptr;\n      if (OpNum + 5 == Record.size()) {\n        FullTy = getFullyStructuredTypeByID(Record[OpNum++]);\n        Ty = flattenPointerTypes(FullTy);\n      } else\n        std::tie(FullTy, Ty) = getPointerElementTypes(FullTy);\n\n      if (Error Err = typeCheckLoadStoreInst(Ty, Op->getType()))\n        return Err;\n\n      AtomicOrdering Ordering = getDecodedOrdering(Record[OpNum + 2]);\n      if (Ordering == AtomicOrdering::NotAtomic ||\n          Ordering == AtomicOrdering::Release ||\n          Ordering == AtomicOrdering::AcquireRelease)\n        return error(\"Invalid record\");\n      if (Ordering != AtomicOrdering::NotAtomic && Record[OpNum] == 0)\n        return error(\"Invalid record\");\n      SyncScope::ID SSID = getDecodedSyncScopeID(Record[OpNum + 3]);\n\n      MaybeAlign Align;\n      if (Error Err = parseAlignmentValue(Record[OpNum], Align))\n        return Err;\n      if (!Align)\n        return error(\"Alignment missing from atomic load\");\n      I = new LoadInst(Ty, Op, \"\", Record[OpNum + 1], *Align, Ordering, SSID);\n      InstructionList.push_back(I);\n      break;\n    }\n    case bitc::FUNC_CODE_INST_STORE:\n    case bitc::FUNC_CODE_INST_STORE_OLD: { // STORE2:[ptrty, ptr, val, align, vol]\n      unsigned OpNum = 0;\n      Value *Val, *Ptr;\n      Type *FullTy;\n      if (getValueTypePair(Record, OpNum, NextValueNo, Ptr, &FullTy) ||\n          (BitCode == bitc::FUNC_CODE_INST_STORE\n               ? getValueTypePair(Record, OpNum, NextValueNo, Val)\n               : popValue(Record, OpNum, NextValueNo,\n                          getPointerElementFlatType(FullTy), Val)) ||\n          OpNum + 2 != Record.size())\n        return error(\"Invalid record\");\n\n      if (Error Err = typeCheckLoadStoreInst(Val->getType(), Ptr->getType()))\n        return Err;\n      MaybeAlign Align;\n      if (Error Err = parseAlignmentValue(Record[OpNum], Align))\n        return Err;\n      SmallPtrSet<Type *, 4> Visited;\n      if (!Align && !Val->getType()->isSized(&Visited))\n        return error(\"store of unsized type\");\n      if (!Align)\n        Align = TheModule->getDataLayout().getABITypeAlign(Val->getType());\n      I = new StoreInst(Val, Ptr, Record[OpNum + 1], *Align);\n      InstructionList.push_back(I);\n      break;\n    }\n    case bitc::FUNC_CODE_INST_STOREATOMIC:\n    case bitc::FUNC_CODE_INST_STOREATOMIC_OLD: {\n      // STOREATOMIC: [ptrty, ptr, val, align, vol, ordering, ssid]\n      unsigned OpNum = 0;\n      Value *Val, *Ptr;\n      Type *FullTy;\n      if (getValueTypePair(Record, OpNum, NextValueNo, Ptr, &FullTy) ||\n          !isa<PointerType>(Ptr->getType()) ||\n          (BitCode == bitc::FUNC_CODE_INST_STOREATOMIC\n               ? getValueTypePair(Record, OpNum, NextValueNo, Val)\n               : popValue(Record, OpNum, NextValueNo,\n                          getPointerElementFlatType(FullTy), Val)) ||\n          OpNum + 4 != Record.size())\n        return error(\"Invalid record\");\n\n      if (Error Err = typeCheckLoadStoreInst(Val->getType(), Ptr->getType()))\n        return Err;\n      AtomicOrdering Ordering = getDecodedOrdering(Record[OpNum + 2]);\n      if (Ordering == AtomicOrdering::NotAtomic ||\n          Ordering == AtomicOrdering::Acquire ||\n          Ordering == AtomicOrdering::AcquireRelease)\n        return error(\"Invalid record\");\n      SyncScope::ID SSID = getDecodedSyncScopeID(Record[OpNum + 3]);\n      if (Ordering != AtomicOrdering::NotAtomic && Record[OpNum] == 0)\n        return error(\"Invalid record\");\n\n      MaybeAlign Align;\n      if (Error Err = parseAlignmentValue(Record[OpNum], Align))\n        return Err;\n      if (!Align)\n        return error(\"Alignment missing from atomic store\");\n      I = new StoreInst(Val, Ptr, Record[OpNum + 1], *Align, Ordering, SSID);\n      InstructionList.push_back(I);\n      break;\n    }\n    case bitc::FUNC_CODE_INST_CMPXCHG_OLD: {\n      // CMPXCHG_OLD: [ptrty, ptr, cmp, val, vol, ordering, synchscope,\n      // failure_ordering?, weak?]\n      const size_t NumRecords = Record.size();\n      unsigned OpNum = 0;\n      Value *Ptr = nullptr;\n      if (getValueTypePair(Record, OpNum, NextValueNo, Ptr, &FullTy))\n        return error(\"Invalid record\");\n\n      if (!isa<PointerType>(Ptr->getType()))\n        return error(\"Cmpxchg operand is not a pointer type\");\n\n      Value *Cmp = nullptr;\n      if (popValue(Record, OpNum, NextValueNo,\n                   getPointerElementFlatType(FullTy), Cmp))\n        return error(\"Invalid record\");\n\n      FullTy = cast<PointerType>(FullTy)->getElementType();\n\n      Value *New = nullptr;\n      if (popValue(Record, OpNum, NextValueNo, Cmp->getType(), New) ||\n          NumRecords < OpNum + 3 || NumRecords > OpNum + 5)\n        return error(\"Invalid record\");\n\n      const AtomicOrdering SuccessOrdering =\n          getDecodedOrdering(Record[OpNum + 1]);\n      if (SuccessOrdering == AtomicOrdering::NotAtomic ||\n          SuccessOrdering == AtomicOrdering::Unordered)\n        return error(\"Invalid record\");\n\n      const SyncScope::ID SSID = getDecodedSyncScopeID(Record[OpNum + 2]);\n\n      if (Error Err = typeCheckLoadStoreInst(Cmp->getType(), Ptr->getType()))\n        return Err;\n\n      const AtomicOrdering FailureOrdering =\n          NumRecords < 7\n              ? AtomicCmpXchgInst::getStrongestFailureOrdering(SuccessOrdering)\n              : getDecodedOrdering(Record[OpNum + 3]);\n\n      const Align Alignment(\n          TheModule->getDataLayout().getTypeStoreSize(Cmp->getType()));\n\n      I = new AtomicCmpXchgInst(Ptr, Cmp, New, Alignment, SuccessOrdering,\n                                FailureOrdering, SSID);\n      cast<AtomicCmpXchgInst>(I)->setVolatile(Record[OpNum]);\n      FullTy = StructType::get(Context, {FullTy, Type::getInt1Ty(Context)});\n\n      if (NumRecords < 8) {\n        // Before weak cmpxchgs existed, the instruction simply returned the\n        // value loaded from memory, so bitcode files from that era will be\n        // expecting the first component of a modern cmpxchg.\n        CurBB->getInstList().push_back(I);\n        I = ExtractValueInst::Create(I, 0);\n        FullTy = cast<StructType>(FullTy)->getElementType(0);\n      } else {\n        cast<AtomicCmpXchgInst>(I)->setWeak(Record[OpNum + 4]);\n      }\n\n      InstructionList.push_back(I);\n      break;\n    }\n    case bitc::FUNC_CODE_INST_CMPXCHG: {\n      // CMPXCHG: [ptrty, ptr, cmp, val, vol, success_ordering, synchscope,\n      // failure_ordering, weak]\n      const size_t NumRecords = Record.size();\n      unsigned OpNum = 0;\n      Value *Ptr = nullptr;\n      if (getValueTypePair(Record, OpNum, NextValueNo, Ptr, &FullTy))\n        return error(\"Invalid record\");\n\n      if (!isa<PointerType>(Ptr->getType()))\n        return error(\"Cmpxchg operand is not a pointer type\");\n\n      Value *Cmp = nullptr;\n      if (getValueTypePair(Record, OpNum, NextValueNo, Cmp, &FullTy))\n        return error(\"Invalid record\");\n\n      Value *Val = nullptr;\n      if (popValue(Record, OpNum, NextValueNo, Cmp->getType(), Val) ||\n          NumRecords < OpNum + 3 || NumRecords > OpNum + 5)\n        return error(\"Invalid record\");\n\n      const AtomicOrdering SuccessOrdering =\n          getDecodedOrdering(Record[OpNum + 1]);\n      if (SuccessOrdering == AtomicOrdering::NotAtomic ||\n          SuccessOrdering == AtomicOrdering::Unordered)\n        return error(\"Invalid record\");\n\n      const SyncScope::ID SSID = getDecodedSyncScopeID(Record[OpNum + 2]);\n\n      if (Error Err = typeCheckLoadStoreInst(Cmp->getType(), Ptr->getType()))\n        return Err;\n\n      const AtomicOrdering FailureOrdering =\n          getDecodedOrdering(Record[OpNum + 3]);\n\n      const Align Alignment(\n          TheModule->getDataLayout().getTypeStoreSize(Cmp->getType()));\n\n      I = new AtomicCmpXchgInst(Ptr, Cmp, Val, Alignment, SuccessOrdering,\n                                FailureOrdering, SSID);\n      FullTy = StructType::get(Context, {FullTy, Type::getInt1Ty(Context)});\n      cast<AtomicCmpXchgInst>(I)->setVolatile(Record[OpNum]);\n      cast<AtomicCmpXchgInst>(I)->setWeak(Record[OpNum + 4]);\n\n      InstructionList.push_back(I);\n      break;\n    }\n    case bitc::FUNC_CODE_INST_ATOMICRMW: {\n      // ATOMICRMW:[ptrty, ptr, val, op, vol, ordering, ssid]\n      unsigned OpNum = 0;\n      Value *Ptr, *Val;\n      if (getValueTypePair(Record, OpNum, NextValueNo, Ptr, &FullTy) ||\n          !isa<PointerType>(Ptr->getType()) ||\n          popValue(Record, OpNum, NextValueNo,\n                   getPointerElementFlatType(FullTy), Val) ||\n          OpNum + 4 != Record.size())\n        return error(\"Invalid record\");\n      AtomicRMWInst::BinOp Operation = getDecodedRMWOperation(Record[OpNum]);\n      if (Operation < AtomicRMWInst::FIRST_BINOP ||\n          Operation > AtomicRMWInst::LAST_BINOP)\n        return error(\"Invalid record\");\n      AtomicOrdering Ordering = getDecodedOrdering(Record[OpNum + 2]);\n      if (Ordering == AtomicOrdering::NotAtomic ||\n          Ordering == AtomicOrdering::Unordered)\n        return error(\"Invalid record\");\n      SyncScope::ID SSID = getDecodedSyncScopeID(Record[OpNum + 3]);\n      Align Alignment(\n          TheModule->getDataLayout().getTypeStoreSize(Val->getType()));\n      I = new AtomicRMWInst(Operation, Ptr, Val, Alignment, Ordering, SSID);\n      FullTy = getPointerElementFlatType(FullTy);\n      cast<AtomicRMWInst>(I)->setVolatile(Record[OpNum+1]);\n      InstructionList.push_back(I);\n      break;\n    }\n    case bitc::FUNC_CODE_INST_FENCE: { // FENCE:[ordering, ssid]\n      if (2 != Record.size())\n        return error(\"Invalid record\");\n      AtomicOrdering Ordering = getDecodedOrdering(Record[0]);\n      if (Ordering == AtomicOrdering::NotAtomic ||\n          Ordering == AtomicOrdering::Unordered ||\n          Ordering == AtomicOrdering::Monotonic)\n        return error(\"Invalid record\");\n      SyncScope::ID SSID = getDecodedSyncScopeID(Record[1]);\n      I = new FenceInst(Context, Ordering, SSID);\n      InstructionList.push_back(I);\n      break;\n    }\n    case bitc::FUNC_CODE_INST_CALL: {\n      // CALL: [paramattrs, cc, fmf, fnty, fnid, arg0, arg1...]\n      if (Record.size() < 3)\n        return error(\"Invalid record\");\n\n      unsigned OpNum = 0;\n      AttributeList PAL = getAttributes(Record[OpNum++]);\n      unsigned CCInfo = Record[OpNum++];\n\n      FastMathFlags FMF;\n      if ((CCInfo >> bitc::CALL_FMF) & 1) {\n        FMF = getDecodedFastMathFlags(Record[OpNum++]);\n        if (!FMF.any())\n          return error(\"Fast math flags indicator set for call with no FMF\");\n      }\n\n      FunctionType *FTy = nullptr;\n      FunctionType *FullFTy = nullptr;\n      if ((CCInfo >> bitc::CALL_EXPLICIT_TYPE) & 1) {\n        FullFTy =\n            dyn_cast<FunctionType>(getFullyStructuredTypeByID(Record[OpNum++]));\n        if (!FullFTy)\n          return error(\"Explicit call type is not a function type\");\n        FTy = cast<FunctionType>(flattenPointerTypes(FullFTy));\n      }\n\n      Value *Callee;\n      if (getValueTypePair(Record, OpNum, NextValueNo, Callee, &FullTy))\n        return error(\"Invalid record\");\n\n      PointerType *OpTy = dyn_cast<PointerType>(Callee->getType());\n      if (!OpTy)\n        return error(\"Callee is not a pointer type\");\n      if (!FTy) {\n        FullFTy =\n            dyn_cast<FunctionType>(cast<PointerType>(FullTy)->getElementType());\n        if (!FullFTy)\n          return error(\"Callee is not of pointer to function type\");\n        FTy = cast<FunctionType>(flattenPointerTypes(FullFTy));\n      } else if (getPointerElementFlatType(FullTy) != FTy)\n        return error(\"Explicit call type does not match pointee type of \"\n                     \"callee operand\");\n      if (Record.size() < FTy->getNumParams() + OpNum)\n        return error(\"Insufficient operands to call\");\n\n      SmallVector<Value*, 16> Args;\n      SmallVector<Type*, 16> ArgsFullTys;\n      // Read the fixed params.\n      for (unsigned i = 0, e = FTy->getNumParams(); i != e; ++i, ++OpNum) {\n        if (FTy->getParamType(i)->isLabelTy())\n          Args.push_back(getBasicBlock(Record[OpNum]));\n        else\n          Args.push_back(getValue(Record, OpNum, NextValueNo,\n                                  FTy->getParamType(i)));\n        ArgsFullTys.push_back(FullFTy->getParamType(i));\n        if (!Args.back())\n          return error(\"Invalid record\");\n      }\n\n      // Read type/value pairs for varargs params.\n      if (!FTy->isVarArg()) {\n        if (OpNum != Record.size())\n          return error(\"Invalid record\");\n      } else {\n        while (OpNum != Record.size()) {\n          Value *Op;\n          Type *FullTy;\n          if (getValueTypePair(Record, OpNum, NextValueNo, Op, &FullTy))\n            return error(\"Invalid record\");\n          Args.push_back(Op);\n          ArgsFullTys.push_back(FullTy);\n        }\n      }\n\n      I = CallInst::Create(FTy, Callee, Args, OperandBundles);\n      FullTy = FullFTy->getReturnType();\n      OperandBundles.clear();\n      InstructionList.push_back(I);\n      cast<CallInst>(I)->setCallingConv(\n          static_cast<CallingConv::ID>((0x7ff & CCInfo) >> bitc::CALL_CCONV));\n      CallInst::TailCallKind TCK = CallInst::TCK_None;\n      if (CCInfo & 1 << bitc::CALL_TAIL)\n        TCK = CallInst::TCK_Tail;\n      if (CCInfo & (1 << bitc::CALL_MUSTTAIL))\n        TCK = CallInst::TCK_MustTail;\n      if (CCInfo & (1 << bitc::CALL_NOTAIL))\n        TCK = CallInst::TCK_NoTail;\n      cast<CallInst>(I)->setTailCallKind(TCK);\n      cast<CallInst>(I)->setAttributes(PAL);\n      propagateByValSRetTypes(cast<CallBase>(I), ArgsFullTys);\n      if (FMF.any()) {\n        if (!isa<FPMathOperator>(I))\n          return error(\"Fast-math-flags specified for call without \"\n                       \"floating-point scalar or vector return type\");\n        I->setFastMathFlags(FMF);\n      }\n      break;\n    }\n    case bitc::FUNC_CODE_INST_VAARG: { // VAARG: [valistty, valist, instty]\n      if (Record.size() < 3)\n        return error(\"Invalid record\");\n      Type *OpTy = getTypeByID(Record[0]);\n      Value *Op = getValue(Record, 1, NextValueNo, OpTy);\n      FullTy = getFullyStructuredTypeByID(Record[2]);\n      Type *ResTy = flattenPointerTypes(FullTy);\n      if (!OpTy || !Op || !ResTy)\n        return error(\"Invalid record\");\n      I = new VAArgInst(Op, ResTy);\n      InstructionList.push_back(I);\n      break;\n    }\n\n    case bitc::FUNC_CODE_OPERAND_BUNDLE: {\n      // A call or an invoke can be optionally prefixed with some variable\n      // number of operand bundle blocks.  These blocks are read into\n      // OperandBundles and consumed at the next call or invoke instruction.\n\n      if (Record.empty() || Record[0] >= BundleTags.size())\n        return error(\"Invalid record\");\n\n      std::vector<Value *> Inputs;\n\n      unsigned OpNum = 1;\n      while (OpNum != Record.size()) {\n        Value *Op;\n        if (getValueTypePair(Record, OpNum, NextValueNo, Op))\n          return error(\"Invalid record\");\n        Inputs.push_back(Op);\n      }\n\n      OperandBundles.emplace_back(BundleTags[Record[0]], std::move(Inputs));\n      continue;\n    }\n\n    case bitc::FUNC_CODE_INST_FREEZE: { // FREEZE: [opty,opval]\n      unsigned OpNum = 0;\n      Value *Op = nullptr;\n      if (getValueTypePair(Record, OpNum, NextValueNo, Op, &FullTy))\n        return error(\"Invalid record\");\n      if (OpNum != Record.size())\n        return error(\"Invalid record\");\n\n      I = new FreezeInst(Op);\n      InstructionList.push_back(I);\n      break;\n    }\n    }\n\n    // Add instruction to end of current BB.  If there is no current BB, reject\n    // this file.\n    if (!CurBB) {\n      I->deleteValue();\n      return error(\"Invalid instruction with no BB\");\n    }\n    if (!OperandBundles.empty()) {\n      I->deleteValue();\n      return error(\"Operand bundles found with no consumer\");\n    }\n    CurBB->getInstList().push_back(I);\n\n    // If this was a terminator instruction, move to the next block.\n    if (I->isTerminator()) {\n      ++CurBBNo;\n      CurBB = CurBBNo < FunctionBBs.size() ? FunctionBBs[CurBBNo] : nullptr;\n    }\n\n    // Non-void values get registered in the value table for future use.\n    if (!I->getType()->isVoidTy()) {\n      if (!FullTy) {\n        FullTy = I->getType();\n        assert(\n            !FullTy->isPointerTy() && !isa<StructType>(FullTy) &&\n            !isa<ArrayType>(FullTy) &&\n            (!isa<VectorType>(FullTy) ||\n             cast<VectorType>(FullTy)->getElementType()->isFloatingPointTy() ||\n             cast<VectorType>(FullTy)->getElementType()->isIntegerTy()) &&\n            \"Structured types must be assigned with corresponding non-opaque \"\n            \"pointer type\");\n      }\n\n      assert(I->getType() == flattenPointerTypes(FullTy) &&\n             \"Incorrect fully structured type provided for Instruction\");\n      ValueList.assignValue(I, NextValueNo++, FullTy);\n    }\n  }\n\nOutOfRecordLoop:\n\n  if (!OperandBundles.empty())\n    return error(\"Operand bundles found with no consumer\");\n\n  // Check the function list for unresolved values.\n  if (Argument *A = dyn_cast<Argument>(ValueList.back())) {\n    if (!A->getParent()) {\n      // We found at least one unresolved value.  Nuke them all to avoid leaks.\n      for (unsigned i = ModuleValueListSize, e = ValueList.size(); i != e; ++i){\n        if ((A = dyn_cast_or_null<Argument>(ValueList[i])) && !A->getParent()) {\n          A->replaceAllUsesWith(UndefValue::get(A->getType()));\n          delete A;\n        }\n      }\n      return error(\"Never resolved value found in function\");\n    }\n  }\n\n  // Unexpected unresolved metadata about to be dropped.\n  if (MDLoader->hasFwdRefs())\n    return error(\"Invalid function metadata: outgoing forward refs\");\n\n  // Trim the value list down to the size it was before we parsed this function.\n  ValueList.shrinkTo(ModuleValueListSize);\n  MDLoader->shrinkTo(ModuleMDLoaderSize);\n  std::vector<BasicBlock*>().swap(FunctionBBs);\n  return Error::success();\n}\n\n/// Find the function body in the bitcode stream\nError BitcodeReader::findFunctionInStream(\n    Function *F,\n    DenseMap<Function *, uint64_t>::iterator DeferredFunctionInfoIterator) {\n  while (DeferredFunctionInfoIterator->second == 0) {\n    // This is the fallback handling for the old format bitcode that\n    // didn't contain the function index in the VST, or when we have\n    // an anonymous function which would not have a VST entry.\n    // Assert that we have one of those two cases.\n    assert(VSTOffset == 0 || !F->hasName());\n    // Parse the next body in the stream and set its position in the\n    // DeferredFunctionInfo map.\n    if (Error Err = rememberAndSkipFunctionBodies())\n      return Err;\n  }\n  return Error::success();\n}\n\nSyncScope::ID BitcodeReader::getDecodedSyncScopeID(unsigned Val) {\n  if (Val == SyncScope::SingleThread || Val == SyncScope::System)\n    return SyncScope::ID(Val);\n  if (Val >= SSIDs.size())\n    return SyncScope::System; // Map unknown synchronization scopes to system.\n  return SSIDs[Val];\n}\n\n//===----------------------------------------------------------------------===//\n// GVMaterializer implementation\n//===----------------------------------------------------------------------===//\n\nError BitcodeReader::materialize(GlobalValue *GV) {\n  Function *F = dyn_cast<Function>(GV);\n  // If it's not a function or is already material, ignore the request.\n  if (!F || !F->isMaterializable())\n    return Error::success();\n\n  DenseMap<Function*, uint64_t>::iterator DFII = DeferredFunctionInfo.find(F);\n  assert(DFII != DeferredFunctionInfo.end() && \"Deferred function not found!\");\n  // If its position is recorded as 0, its body is somewhere in the stream\n  // but we haven't seen it yet.\n  if (DFII->second == 0)\n    if (Error Err = findFunctionInStream(F, DFII))\n      return Err;\n\n  // Materialize metadata before parsing any function bodies.\n  if (Error Err = materializeMetadata())\n    return Err;\n\n  // Move the bit stream to the saved position of the deferred function body.\n  if (Error JumpFailed = Stream.JumpToBit(DFII->second))\n    return JumpFailed;\n  if (Error Err = parseFunctionBody(F))\n    return Err;\n  F->setIsMaterializable(false);\n\n  if (StripDebugInfo)\n    stripDebugInfo(*F);\n\n  // Upgrade any old intrinsic calls in the function.\n  for (auto &I : UpgradedIntrinsics) {\n    for (auto UI = I.first->materialized_user_begin(), UE = I.first->user_end();\n         UI != UE;) {\n      User *U = *UI;\n      ++UI;\n      if (CallInst *CI = dyn_cast<CallInst>(U))\n        UpgradeIntrinsicCall(CI, I.second);\n    }\n  }\n\n  // Update calls to the remangled intrinsics\n  for (auto &I : RemangledIntrinsics)\n    for (auto UI = I.first->materialized_user_begin(), UE = I.first->user_end();\n         UI != UE;)\n      // Don't expect any other users than call sites\n      cast<CallBase>(*UI++)->setCalledFunction(I.second);\n\n  // Finish fn->subprogram upgrade for materialized functions.\n  if (DISubprogram *SP = MDLoader->lookupSubprogramForFunction(F))\n    F->setSubprogram(SP);\n\n  // Check if the TBAA Metadata are valid, otherwise we will need to strip them.\n  if (!MDLoader->isStrippingTBAA()) {\n    for (auto &I : instructions(F)) {\n      MDNode *TBAA = I.getMetadata(LLVMContext::MD_tbaa);\n      if (!TBAA || TBAAVerifyHelper.visitTBAAMetadata(I, TBAA))\n        continue;\n      MDLoader->setStripTBAA(true);\n      stripTBAA(F->getParent());\n    }\n  }\n\n  // \"Upgrade\" older incorrect branch weights by dropping them.\n  for (auto &I : instructions(F)) {\n    if (auto *MD = I.getMetadata(LLVMContext::MD_prof)) {\n      if (MD->getOperand(0) != nullptr && isa<MDString>(MD->getOperand(0))) {\n        MDString *MDS = cast<MDString>(MD->getOperand(0));\n        StringRef ProfName = MDS->getString();\n        // Check consistency of !prof branch_weights metadata.\n        if (!ProfName.equals(\"branch_weights\"))\n          continue;\n        unsigned ExpectedNumOperands = 0;\n        if (BranchInst *BI = dyn_cast<BranchInst>(&I))\n          ExpectedNumOperands = BI->getNumSuccessors();\n        else if (SwitchInst *SI = dyn_cast<SwitchInst>(&I))\n          ExpectedNumOperands = SI->getNumSuccessors();\n        else if (isa<CallInst>(&I))\n          ExpectedNumOperands = 1;\n        else if (IndirectBrInst *IBI = dyn_cast<IndirectBrInst>(&I))\n          ExpectedNumOperands = IBI->getNumDestinations();\n        else if (isa<SelectInst>(&I))\n          ExpectedNumOperands = 2;\n        else\n          continue; // ignore and continue.\n\n        // If branch weight doesn't match, just strip branch weight.\n        if (MD->getNumOperands() != 1 + ExpectedNumOperands)\n          I.setMetadata(LLVMContext::MD_prof, nullptr);\n      }\n    }\n  }\n\n  // Look for functions that rely on old function attribute behavior.\n  UpgradeFunctionAttributes(*F);\n\n  // Bring in any functions that this function forward-referenced via\n  // blockaddresses.\n  return materializeForwardReferencedFunctions();\n}\n\nError BitcodeReader::materializeModule() {\n  if (Error Err = materializeMetadata())\n    return Err;\n\n  // Promise to materialize all forward references.\n  WillMaterializeAllForwardRefs = true;\n\n  // Iterate over the module, deserializing any functions that are still on\n  // disk.\n  for (Function &F : *TheModule) {\n    if (Error Err = materialize(&F))\n      return Err;\n  }\n  // At this point, if there are any function bodies, parse the rest of\n  // the bits in the module past the last function block we have recorded\n  // through either lazy scanning or the VST.\n  if (LastFunctionBlockBit || NextUnreadBit)\n    if (Error Err = parseModule(LastFunctionBlockBit > NextUnreadBit\n                                    ? LastFunctionBlockBit\n                                    : NextUnreadBit))\n      return Err;\n\n  // Check that all block address forward references got resolved (as we\n  // promised above).\n  if (!BasicBlockFwdRefs.empty())\n    return error(\"Never resolved function from blockaddress\");\n\n  // Upgrade any intrinsic calls that slipped through (should not happen!) and\n  // delete the old functions to clean up. We can't do this unless the entire\n  // module is materialized because there could always be another function body\n  // with calls to the old function.\n  for (auto &I : UpgradedIntrinsics) {\n    for (auto *U : I.first->users()) {\n      if (CallInst *CI = dyn_cast<CallInst>(U))\n        UpgradeIntrinsicCall(CI, I.second);\n    }\n    if (!I.first->use_empty())\n      I.first->replaceAllUsesWith(I.second);\n    I.first->eraseFromParent();\n  }\n  UpgradedIntrinsics.clear();\n  // Do the same for remangled intrinsics\n  for (auto &I : RemangledIntrinsics) {\n    I.first->replaceAllUsesWith(I.second);\n    I.first->eraseFromParent();\n  }\n  RemangledIntrinsics.clear();\n\n  UpgradeDebugInfo(*TheModule);\n\n  UpgradeModuleFlags(*TheModule);\n\n  UpgradeARCRuntime(*TheModule);\n\n  return Error::success();\n}\n\nstd::vector<StructType *> BitcodeReader::getIdentifiedStructTypes() const {\n  return IdentifiedStructTypes;\n}\n\nModuleSummaryIndexBitcodeReader::ModuleSummaryIndexBitcodeReader(\n    BitstreamCursor Cursor, StringRef Strtab, ModuleSummaryIndex &TheIndex,\n    StringRef ModulePath, unsigned ModuleId)\n    : BitcodeReaderBase(std::move(Cursor), Strtab), TheIndex(TheIndex),\n      ModulePath(ModulePath), ModuleId(ModuleId) {}\n\nvoid ModuleSummaryIndexBitcodeReader::addThisModule() {\n  TheIndex.addModule(ModulePath, ModuleId);\n}\n\nModuleSummaryIndex::ModuleInfo *\nModuleSummaryIndexBitcodeReader::getThisModule() {\n  return TheIndex.getModule(ModulePath);\n}\n\nstd::pair<ValueInfo, GlobalValue::GUID>\nModuleSummaryIndexBitcodeReader::getValueInfoFromValueId(unsigned ValueId) {\n  auto VGI = ValueIdToValueInfoMap[ValueId];\n  assert(VGI.first);\n  return VGI;\n}\n\nvoid ModuleSummaryIndexBitcodeReader::setValueGUID(\n    uint64_t ValueID, StringRef ValueName, GlobalValue::LinkageTypes Linkage,\n    StringRef SourceFileName) {\n  std::string GlobalId =\n      GlobalValue::getGlobalIdentifier(ValueName, Linkage, SourceFileName);\n  auto ValueGUID = GlobalValue::getGUID(GlobalId);\n  auto OriginalNameID = ValueGUID;\n  if (GlobalValue::isLocalLinkage(Linkage))\n    OriginalNameID = GlobalValue::getGUID(ValueName);\n  if (PrintSummaryGUIDs)\n    dbgs() << \"GUID \" << ValueGUID << \"(\" << OriginalNameID << \") is \"\n           << ValueName << \"\\n\";\n\n  // UseStrtab is false for legacy summary formats and value names are\n  // created on stack. In that case we save the name in a string saver in\n  // the index so that the value name can be recorded.\n  ValueIdToValueInfoMap[ValueID] = std::make_pair(\n      TheIndex.getOrInsertValueInfo(\n          ValueGUID,\n          UseStrtab ? ValueName : TheIndex.saveString(ValueName)),\n      OriginalNameID);\n}\n\n// Specialized value symbol table parser used when reading module index\n// blocks where we don't actually create global values. The parsed information\n// is saved in the bitcode reader for use when later parsing summaries.\nError ModuleSummaryIndexBitcodeReader::parseValueSymbolTable(\n    uint64_t Offset,\n    DenseMap<unsigned, GlobalValue::LinkageTypes> &ValueIdToLinkageMap) {\n  // With a strtab the VST is not required to parse the summary.\n  if (UseStrtab)\n    return Error::success();\n\n  assert(Offset > 0 && \"Expected non-zero VST offset\");\n  Expected<uint64_t> MaybeCurrentBit = jumpToValueSymbolTable(Offset, Stream);\n  if (!MaybeCurrentBit)\n    return MaybeCurrentBit.takeError();\n  uint64_t CurrentBit = MaybeCurrentBit.get();\n\n  if (Error Err = Stream.EnterSubBlock(bitc::VALUE_SYMTAB_BLOCK_ID))\n    return Err;\n\n  SmallVector<uint64_t, 64> Record;\n\n  // Read all the records for this value table.\n  SmallString<128> ValueName;\n\n  while (true) {\n    Expected<BitstreamEntry> MaybeEntry = Stream.advanceSkippingSubblocks();\n    if (!MaybeEntry)\n      return MaybeEntry.takeError();\n    BitstreamEntry Entry = MaybeEntry.get();\n\n    switch (Entry.Kind) {\n    case BitstreamEntry::SubBlock: // Handled for us already.\n    case BitstreamEntry::Error:\n      return error(\"Malformed block\");\n    case BitstreamEntry::EndBlock:\n      // Done parsing VST, jump back to wherever we came from.\n      if (Error JumpFailed = Stream.JumpToBit(CurrentBit))\n        return JumpFailed;\n      return Error::success();\n    case BitstreamEntry::Record:\n      // The interesting case.\n      break;\n    }\n\n    // Read a record.\n    Record.clear();\n    Expected<unsigned> MaybeRecord = Stream.readRecord(Entry.ID, Record);\n    if (!MaybeRecord)\n      return MaybeRecord.takeError();\n    switch (MaybeRecord.get()) {\n    default: // Default behavior: ignore (e.g. VST_CODE_BBENTRY records).\n      break;\n    case bitc::VST_CODE_ENTRY: { // VST_CODE_ENTRY: [valueid, namechar x N]\n      if (convertToString(Record, 1, ValueName))\n        return error(\"Invalid record\");\n      unsigned ValueID = Record[0];\n      assert(!SourceFileName.empty());\n      auto VLI = ValueIdToLinkageMap.find(ValueID);\n      assert(VLI != ValueIdToLinkageMap.end() &&\n             \"No linkage found for VST entry?\");\n      auto Linkage = VLI->second;\n      setValueGUID(ValueID, ValueName, Linkage, SourceFileName);\n      ValueName.clear();\n      break;\n    }\n    case bitc::VST_CODE_FNENTRY: {\n      // VST_CODE_FNENTRY: [valueid, offset, namechar x N]\n      if (convertToString(Record, 2, ValueName))\n        return error(\"Invalid record\");\n      unsigned ValueID = Record[0];\n      assert(!SourceFileName.empty());\n      auto VLI = ValueIdToLinkageMap.find(ValueID);\n      assert(VLI != ValueIdToLinkageMap.end() &&\n             \"No linkage found for VST entry?\");\n      auto Linkage = VLI->second;\n      setValueGUID(ValueID, ValueName, Linkage, SourceFileName);\n      ValueName.clear();\n      break;\n    }\n    case bitc::VST_CODE_COMBINED_ENTRY: {\n      // VST_CODE_COMBINED_ENTRY: [valueid, refguid]\n      unsigned ValueID = Record[0];\n      GlobalValue::GUID RefGUID = Record[1];\n      // The \"original name\", which is the second value of the pair will be\n      // overriden later by a FS_COMBINED_ORIGINAL_NAME in the combined index.\n      ValueIdToValueInfoMap[ValueID] =\n          std::make_pair(TheIndex.getOrInsertValueInfo(RefGUID), RefGUID);\n      break;\n    }\n    }\n  }\n}\n\n// Parse just the blocks needed for building the index out of the module.\n// At the end of this routine the module Index is populated with a map\n// from global value id to GlobalValueSummary objects.\nError ModuleSummaryIndexBitcodeReader::parseModule() {\n  if (Error Err = Stream.EnterSubBlock(bitc::MODULE_BLOCK_ID))\n    return Err;\n\n  SmallVector<uint64_t, 64> Record;\n  DenseMap<unsigned, GlobalValue::LinkageTypes> ValueIdToLinkageMap;\n  unsigned ValueId = 0;\n\n  // Read the index for this module.\n  while (true) {\n    Expected<llvm::BitstreamEntry> MaybeEntry = Stream.advance();\n    if (!MaybeEntry)\n      return MaybeEntry.takeError();\n    llvm::BitstreamEntry Entry = MaybeEntry.get();\n\n    switch (Entry.Kind) {\n    case BitstreamEntry::Error:\n      return error(\"Malformed block\");\n    case BitstreamEntry::EndBlock:\n      return Error::success();\n\n    case BitstreamEntry::SubBlock:\n      switch (Entry.ID) {\n      default: // Skip unknown content.\n        if (Error Err = Stream.SkipBlock())\n          return Err;\n        break;\n      case bitc::BLOCKINFO_BLOCK_ID:\n        // Need to parse these to get abbrev ids (e.g. for VST)\n        if (readBlockInfo())\n          return error(\"Malformed block\");\n        break;\n      case bitc::VALUE_SYMTAB_BLOCK_ID:\n        // Should have been parsed earlier via VSTOffset, unless there\n        // is no summary section.\n        assert(((SeenValueSymbolTable && VSTOffset > 0) ||\n                !SeenGlobalValSummary) &&\n               \"Expected early VST parse via VSTOffset record\");\n        if (Error Err = Stream.SkipBlock())\n          return Err;\n        break;\n      case bitc::GLOBALVAL_SUMMARY_BLOCK_ID:\n      case bitc::FULL_LTO_GLOBALVAL_SUMMARY_BLOCK_ID:\n        // Add the module if it is a per-module index (has a source file name).\n        if (!SourceFileName.empty())\n          addThisModule();\n        assert(!SeenValueSymbolTable &&\n               \"Already read VST when parsing summary block?\");\n        // We might not have a VST if there were no values in the\n        // summary. An empty summary block generated when we are\n        // performing ThinLTO compiles so we don't later invoke\n        // the regular LTO process on them.\n        if (VSTOffset > 0) {\n          if (Error Err = parseValueSymbolTable(VSTOffset, ValueIdToLinkageMap))\n            return Err;\n          SeenValueSymbolTable = true;\n        }\n        SeenGlobalValSummary = true;\n        if (Error Err = parseEntireSummary(Entry.ID))\n          return Err;\n        break;\n      case bitc::MODULE_STRTAB_BLOCK_ID:\n        if (Error Err = parseModuleStringTable())\n          return Err;\n        break;\n      }\n      continue;\n\n    case BitstreamEntry::Record: {\n        Record.clear();\n        Expected<unsigned> MaybeBitCode = Stream.readRecord(Entry.ID, Record);\n        if (!MaybeBitCode)\n          return MaybeBitCode.takeError();\n        switch (MaybeBitCode.get()) {\n        default:\n          break; // Default behavior, ignore unknown content.\n        case bitc::MODULE_CODE_VERSION: {\n          if (Error Err = parseVersionRecord(Record).takeError())\n            return Err;\n          break;\n        }\n        /// MODULE_CODE_SOURCE_FILENAME: [namechar x N]\n        case bitc::MODULE_CODE_SOURCE_FILENAME: {\n          SmallString<128> ValueName;\n          if (convertToString(Record, 0, ValueName))\n            return error(\"Invalid record\");\n          SourceFileName = ValueName.c_str();\n          break;\n        }\n        /// MODULE_CODE_HASH: [5*i32]\n        case bitc::MODULE_CODE_HASH: {\n          if (Record.size() != 5)\n            return error(\"Invalid hash length \" + Twine(Record.size()).str());\n          auto &Hash = getThisModule()->second.second;\n          int Pos = 0;\n          for (auto &Val : Record) {\n            assert(!(Val >> 32) && \"Unexpected high bits set\");\n            Hash[Pos++] = Val;\n          }\n          break;\n        }\n        /// MODULE_CODE_VSTOFFSET: [offset]\n        case bitc::MODULE_CODE_VSTOFFSET:\n          if (Record.empty())\n            return error(\"Invalid record\");\n          // Note that we subtract 1 here because the offset is relative to one\n          // word before the start of the identification or module block, which\n          // was historically always the start of the regular bitcode header.\n          VSTOffset = Record[0] - 1;\n          break;\n        // v1 GLOBALVAR: [pointer type, isconst,     initid,       linkage, ...]\n        // v1 FUNCTION:  [type,         callingconv, isproto,      linkage, ...]\n        // v1 ALIAS:     [alias type,   addrspace,   aliasee val#, linkage, ...]\n        // v2: [strtab offset, strtab size, v1]\n        case bitc::MODULE_CODE_GLOBALVAR:\n        case bitc::MODULE_CODE_FUNCTION:\n        case bitc::MODULE_CODE_ALIAS: {\n          StringRef Name;\n          ArrayRef<uint64_t> GVRecord;\n          std::tie(Name, GVRecord) = readNameFromStrtab(Record);\n          if (GVRecord.size() <= 3)\n            return error(\"Invalid record\");\n          uint64_t RawLinkage = GVRecord[3];\n          GlobalValue::LinkageTypes Linkage = getDecodedLinkage(RawLinkage);\n          if (!UseStrtab) {\n            ValueIdToLinkageMap[ValueId++] = Linkage;\n            break;\n          }\n\n          setValueGUID(ValueId++, Name, Linkage, SourceFileName);\n          break;\n        }\n        }\n      }\n      continue;\n    }\n  }\n}\n\nstd::vector<ValueInfo>\nModuleSummaryIndexBitcodeReader::makeRefList(ArrayRef<uint64_t> Record) {\n  std::vector<ValueInfo> Ret;\n  Ret.reserve(Record.size());\n  for (uint64_t RefValueId : Record)\n    Ret.push_back(getValueInfoFromValueId(RefValueId).first);\n  return Ret;\n}\n\nstd::vector<FunctionSummary::EdgeTy>\nModuleSummaryIndexBitcodeReader::makeCallList(ArrayRef<uint64_t> Record,\n                                              bool IsOldProfileFormat,\n                                              bool HasProfile, bool HasRelBF) {\n  std::vector<FunctionSummary::EdgeTy> Ret;\n  Ret.reserve(Record.size());\n  for (unsigned I = 0, E = Record.size(); I != E; ++I) {\n    CalleeInfo::HotnessType Hotness = CalleeInfo::HotnessType::Unknown;\n    uint64_t RelBF = 0;\n    ValueInfo Callee = getValueInfoFromValueId(Record[I]).first;\n    if (IsOldProfileFormat) {\n      I += 1; // Skip old callsitecount field\n      if (HasProfile)\n        I += 1; // Skip old profilecount field\n    } else if (HasProfile)\n      Hotness = static_cast<CalleeInfo::HotnessType>(Record[++I]);\n    else if (HasRelBF)\n      RelBF = Record[++I];\n    Ret.push_back(FunctionSummary::EdgeTy{Callee, CalleeInfo(Hotness, RelBF)});\n  }\n  return Ret;\n}\n\nstatic void\nparseWholeProgramDevirtResolutionByArg(ArrayRef<uint64_t> Record, size_t &Slot,\n                                       WholeProgramDevirtResolution &Wpd) {\n  uint64_t ArgNum = Record[Slot++];\n  WholeProgramDevirtResolution::ByArg &B =\n      Wpd.ResByArg[{Record.begin() + Slot, Record.begin() + Slot + ArgNum}];\n  Slot += ArgNum;\n\n  B.TheKind =\n      static_cast<WholeProgramDevirtResolution::ByArg::Kind>(Record[Slot++]);\n  B.Info = Record[Slot++];\n  B.Byte = Record[Slot++];\n  B.Bit = Record[Slot++];\n}\n\nstatic void parseWholeProgramDevirtResolution(ArrayRef<uint64_t> Record,\n                                              StringRef Strtab, size_t &Slot,\n                                              TypeIdSummary &TypeId) {\n  uint64_t Id = Record[Slot++];\n  WholeProgramDevirtResolution &Wpd = TypeId.WPDRes[Id];\n\n  Wpd.TheKind = static_cast<WholeProgramDevirtResolution::Kind>(Record[Slot++]);\n  Wpd.SingleImplName = {Strtab.data() + Record[Slot],\n                        static_cast<size_t>(Record[Slot + 1])};\n  Slot += 2;\n\n  uint64_t ResByArgNum = Record[Slot++];\n  for (uint64_t I = 0; I != ResByArgNum; ++I)\n    parseWholeProgramDevirtResolutionByArg(Record, Slot, Wpd);\n}\n\nstatic void parseTypeIdSummaryRecord(ArrayRef<uint64_t> Record,\n                                     StringRef Strtab,\n                                     ModuleSummaryIndex &TheIndex) {\n  size_t Slot = 0;\n  TypeIdSummary &TypeId = TheIndex.getOrInsertTypeIdSummary(\n      {Strtab.data() + Record[Slot], static_cast<size_t>(Record[Slot + 1])});\n  Slot += 2;\n\n  TypeId.TTRes.TheKind = static_cast<TypeTestResolution::Kind>(Record[Slot++]);\n  TypeId.TTRes.SizeM1BitWidth = Record[Slot++];\n  TypeId.TTRes.AlignLog2 = Record[Slot++];\n  TypeId.TTRes.SizeM1 = Record[Slot++];\n  TypeId.TTRes.BitMask = Record[Slot++];\n  TypeId.TTRes.InlineBits = Record[Slot++];\n\n  while (Slot < Record.size())\n    parseWholeProgramDevirtResolution(Record, Strtab, Slot, TypeId);\n}\n\nstd::vector<FunctionSummary::ParamAccess>\nModuleSummaryIndexBitcodeReader::parseParamAccesses(ArrayRef<uint64_t> Record) {\n  auto ReadRange = [&]() {\n    APInt Lower(FunctionSummary::ParamAccess::RangeWidth,\n                BitcodeReader::decodeSignRotatedValue(Record.front()));\n    Record = Record.drop_front();\n    APInt Upper(FunctionSummary::ParamAccess::RangeWidth,\n                BitcodeReader::decodeSignRotatedValue(Record.front()));\n    Record = Record.drop_front();\n    ConstantRange Range{Lower, Upper};\n    assert(!Range.isFullSet());\n    assert(!Range.isUpperSignWrapped());\n    return Range;\n  };\n\n  std::vector<FunctionSummary::ParamAccess> PendingParamAccesses;\n  while (!Record.empty()) {\n    PendingParamAccesses.emplace_back();\n    FunctionSummary::ParamAccess &ParamAccess = PendingParamAccesses.back();\n    ParamAccess.ParamNo = Record.front();\n    Record = Record.drop_front();\n    ParamAccess.Use = ReadRange();\n    ParamAccess.Calls.resize(Record.front());\n    Record = Record.drop_front();\n    for (auto &Call : ParamAccess.Calls) {\n      Call.ParamNo = Record.front();\n      Record = Record.drop_front();\n      Call.Callee = getValueInfoFromValueId(Record.front()).first;\n      Record = Record.drop_front();\n      Call.Offsets = ReadRange();\n    }\n  }\n  return PendingParamAccesses;\n}\n\nvoid ModuleSummaryIndexBitcodeReader::parseTypeIdCompatibleVtableInfo(\n    ArrayRef<uint64_t> Record, size_t &Slot,\n    TypeIdCompatibleVtableInfo &TypeId) {\n  uint64_t Offset = Record[Slot++];\n  ValueInfo Callee = getValueInfoFromValueId(Record[Slot++]).first;\n  TypeId.push_back({Offset, Callee});\n}\n\nvoid ModuleSummaryIndexBitcodeReader::parseTypeIdCompatibleVtableSummaryRecord(\n    ArrayRef<uint64_t> Record) {\n  size_t Slot = 0;\n  TypeIdCompatibleVtableInfo &TypeId =\n      TheIndex.getOrInsertTypeIdCompatibleVtableSummary(\n          {Strtab.data() + Record[Slot],\n           static_cast<size_t>(Record[Slot + 1])});\n  Slot += 2;\n\n  while (Slot < Record.size())\n    parseTypeIdCompatibleVtableInfo(Record, Slot, TypeId);\n}\n\nstatic void setSpecialRefs(std::vector<ValueInfo> &Refs, unsigned ROCnt,\n                           unsigned WOCnt) {\n  // Readonly and writeonly refs are in the end of the refs list.\n  assert(ROCnt + WOCnt <= Refs.size());\n  unsigned FirstWORef = Refs.size() - WOCnt;\n  unsigned RefNo = FirstWORef - ROCnt;\n  for (; RefNo < FirstWORef; ++RefNo)\n    Refs[RefNo].setReadOnly();\n  for (; RefNo < Refs.size(); ++RefNo)\n    Refs[RefNo].setWriteOnly();\n}\n\n// Eagerly parse the entire summary block. This populates the GlobalValueSummary\n// objects in the index.\nError ModuleSummaryIndexBitcodeReader::parseEntireSummary(unsigned ID) {\n  if (Error Err = Stream.EnterSubBlock(ID))\n    return Err;\n  SmallVector<uint64_t, 64> Record;\n\n  // Parse version\n  {\n    Expected<BitstreamEntry> MaybeEntry = Stream.advanceSkippingSubblocks();\n    if (!MaybeEntry)\n      return MaybeEntry.takeError();\n    BitstreamEntry Entry = MaybeEntry.get();\n\n    if (Entry.Kind != BitstreamEntry::Record)\n      return error(\"Invalid Summary Block: record for version expected\");\n    Expected<unsigned> MaybeRecord = Stream.readRecord(Entry.ID, Record);\n    if (!MaybeRecord)\n      return MaybeRecord.takeError();\n    if (MaybeRecord.get() != bitc::FS_VERSION)\n      return error(\"Invalid Summary Block: version expected\");\n  }\n  const uint64_t Version = Record[0];\n  const bool IsOldProfileFormat = Version == 1;\n  if (Version < 1 || Version > ModuleSummaryIndex::BitcodeSummaryVersion)\n    return error(\"Invalid summary version \" + Twine(Version) +\n                 \". Version should be in the range [1-\" +\n                 Twine(ModuleSummaryIndex::BitcodeSummaryVersion) +\n                 \"].\");\n  Record.clear();\n\n  // Keep around the last seen summary to be used when we see an optional\n  // \"OriginalName\" attachement.\n  GlobalValueSummary *LastSeenSummary = nullptr;\n  GlobalValue::GUID LastSeenGUID = 0;\n\n  // We can expect to see any number of type ID information records before\n  // each function summary records; these variables store the information\n  // collected so far so that it can be used to create the summary object.\n  std::vector<GlobalValue::GUID> PendingTypeTests;\n  std::vector<FunctionSummary::VFuncId> PendingTypeTestAssumeVCalls,\n      PendingTypeCheckedLoadVCalls;\n  std::vector<FunctionSummary::ConstVCall> PendingTypeTestAssumeConstVCalls,\n      PendingTypeCheckedLoadConstVCalls;\n  std::vector<FunctionSummary::ParamAccess> PendingParamAccesses;\n\n  while (true) {\n    Expected<BitstreamEntry> MaybeEntry = Stream.advanceSkippingSubblocks();\n    if (!MaybeEntry)\n      return MaybeEntry.takeError();\n    BitstreamEntry Entry = MaybeEntry.get();\n\n    switch (Entry.Kind) {\n    case BitstreamEntry::SubBlock: // Handled for us already.\n    case BitstreamEntry::Error:\n      return error(\"Malformed block\");\n    case BitstreamEntry::EndBlock:\n      return Error::success();\n    case BitstreamEntry::Record:\n      // The interesting case.\n      break;\n    }\n\n    // Read a record. The record format depends on whether this\n    // is a per-module index or a combined index file. In the per-module\n    // case the records contain the associated value's ID for correlation\n    // with VST entries. In the combined index the correlation is done\n    // via the bitcode offset of the summary records (which were saved\n    // in the combined index VST entries). The records also contain\n    // information used for ThinLTO renaming and importing.\n    Record.clear();\n    Expected<unsigned> MaybeBitCode = Stream.readRecord(Entry.ID, Record);\n    if (!MaybeBitCode)\n      return MaybeBitCode.takeError();\n    switch (unsigned BitCode = MaybeBitCode.get()) {\n    default: // Default behavior: ignore.\n      break;\n    case bitc::FS_FLAGS: {  // [flags]\n      TheIndex.setFlags(Record[0]);\n      break;\n    }\n    case bitc::FS_VALUE_GUID: { // [valueid, refguid]\n      uint64_t ValueID = Record[0];\n      GlobalValue::GUID RefGUID = Record[1];\n      ValueIdToValueInfoMap[ValueID] =\n          std::make_pair(TheIndex.getOrInsertValueInfo(RefGUID), RefGUID);\n      break;\n    }\n    // FS_PERMODULE: [valueid, flags, instcount, fflags, numrefs,\n    //                numrefs x valueid, n x (valueid)]\n    // FS_PERMODULE_PROFILE: [valueid, flags, instcount, fflags, numrefs,\n    //                        numrefs x valueid,\n    //                        n x (valueid, hotness)]\n    // FS_PERMODULE_RELBF: [valueid, flags, instcount, fflags, numrefs,\n    //                      numrefs x valueid,\n    //                      n x (valueid, relblockfreq)]\n    case bitc::FS_PERMODULE:\n    case bitc::FS_PERMODULE_RELBF:\n    case bitc::FS_PERMODULE_PROFILE: {\n      unsigned ValueID = Record[0];\n      uint64_t RawFlags = Record[1];\n      unsigned InstCount = Record[2];\n      uint64_t RawFunFlags = 0;\n      unsigned NumRefs = Record[3];\n      unsigned NumRORefs = 0, NumWORefs = 0;\n      int RefListStartIndex = 4;\n      if (Version >= 4) {\n        RawFunFlags = Record[3];\n        NumRefs = Record[4];\n        RefListStartIndex = 5;\n        if (Version >= 5) {\n          NumRORefs = Record[5];\n          RefListStartIndex = 6;\n          if (Version >= 7) {\n            NumWORefs = Record[6];\n            RefListStartIndex = 7;\n          }\n        }\n      }\n\n      auto Flags = getDecodedGVSummaryFlags(RawFlags, Version);\n      // The module path string ref set in the summary must be owned by the\n      // index's module string table. Since we don't have a module path\n      // string table section in the per-module index, we create a single\n      // module path string table entry with an empty (0) ID to take\n      // ownership.\n      int CallGraphEdgeStartIndex = RefListStartIndex + NumRefs;\n      assert(Record.size() >= RefListStartIndex + NumRefs &&\n             \"Record size inconsistent with number of references\");\n      std::vector<ValueInfo> Refs = makeRefList(\n          ArrayRef<uint64_t>(Record).slice(RefListStartIndex, NumRefs));\n      bool HasProfile = (BitCode == bitc::FS_PERMODULE_PROFILE);\n      bool HasRelBF = (BitCode == bitc::FS_PERMODULE_RELBF);\n      std::vector<FunctionSummary::EdgeTy> Calls = makeCallList(\n          ArrayRef<uint64_t>(Record).slice(CallGraphEdgeStartIndex),\n          IsOldProfileFormat, HasProfile, HasRelBF);\n      setSpecialRefs(Refs, NumRORefs, NumWORefs);\n      auto FS = std::make_unique<FunctionSummary>(\n          Flags, InstCount, getDecodedFFlags(RawFunFlags), /*EntryCount=*/0,\n          std::move(Refs), std::move(Calls), std::move(PendingTypeTests),\n          std::move(PendingTypeTestAssumeVCalls),\n          std::move(PendingTypeCheckedLoadVCalls),\n          std::move(PendingTypeTestAssumeConstVCalls),\n          std::move(PendingTypeCheckedLoadConstVCalls),\n          std::move(PendingParamAccesses));\n      auto VIAndOriginalGUID = getValueInfoFromValueId(ValueID);\n      FS->setModulePath(getThisModule()->first());\n      FS->setOriginalName(VIAndOriginalGUID.second);\n      TheIndex.addGlobalValueSummary(VIAndOriginalGUID.first, std::move(FS));\n      break;\n    }\n    // FS_ALIAS: [valueid, flags, valueid]\n    // Aliases must be emitted (and parsed) after all FS_PERMODULE entries, as\n    // they expect all aliasee summaries to be available.\n    case bitc::FS_ALIAS: {\n      unsigned ValueID = Record[0];\n      uint64_t RawFlags = Record[1];\n      unsigned AliaseeID = Record[2];\n      auto Flags = getDecodedGVSummaryFlags(RawFlags, Version);\n      auto AS = std::make_unique<AliasSummary>(Flags);\n      // The module path string ref set in the summary must be owned by the\n      // index's module string table. Since we don't have a module path\n      // string table section in the per-module index, we create a single\n      // module path string table entry with an empty (0) ID to take\n      // ownership.\n      AS->setModulePath(getThisModule()->first());\n\n      auto AliaseeVI = getValueInfoFromValueId(AliaseeID).first;\n      auto AliaseeInModule = TheIndex.findSummaryInModule(AliaseeVI, ModulePath);\n      if (!AliaseeInModule)\n        return error(\"Alias expects aliasee summary to be parsed\");\n      AS->setAliasee(AliaseeVI, AliaseeInModule);\n\n      auto GUID = getValueInfoFromValueId(ValueID);\n      AS->setOriginalName(GUID.second);\n      TheIndex.addGlobalValueSummary(GUID.first, std::move(AS));\n      break;\n    }\n    // FS_PERMODULE_GLOBALVAR_INIT_REFS: [valueid, flags, varflags, n x valueid]\n    case bitc::FS_PERMODULE_GLOBALVAR_INIT_REFS: {\n      unsigned ValueID = Record[0];\n      uint64_t RawFlags = Record[1];\n      unsigned RefArrayStart = 2;\n      GlobalVarSummary::GVarFlags GVF(/* ReadOnly */ false,\n                                      /* WriteOnly */ false,\n                                      /* Constant */ false,\n                                      GlobalObject::VCallVisibilityPublic);\n      auto Flags = getDecodedGVSummaryFlags(RawFlags, Version);\n      if (Version >= 5) {\n        GVF = getDecodedGVarFlags(Record[2]);\n        RefArrayStart = 3;\n      }\n      std::vector<ValueInfo> Refs =\n          makeRefList(ArrayRef<uint64_t>(Record).slice(RefArrayStart));\n      auto FS =\n          std::make_unique<GlobalVarSummary>(Flags, GVF, std::move(Refs));\n      FS->setModulePath(getThisModule()->first());\n      auto GUID = getValueInfoFromValueId(ValueID);\n      FS->setOriginalName(GUID.second);\n      TheIndex.addGlobalValueSummary(GUID.first, std::move(FS));\n      break;\n    }\n    // FS_PERMODULE_VTABLE_GLOBALVAR_INIT_REFS: [valueid, flags, varflags,\n    //                        numrefs, numrefs x valueid,\n    //                        n x (valueid, offset)]\n    case bitc::FS_PERMODULE_VTABLE_GLOBALVAR_INIT_REFS: {\n      unsigned ValueID = Record[0];\n      uint64_t RawFlags = Record[1];\n      GlobalVarSummary::GVarFlags GVF = getDecodedGVarFlags(Record[2]);\n      unsigned NumRefs = Record[3];\n      unsigned RefListStartIndex = 4;\n      unsigned VTableListStartIndex = RefListStartIndex + NumRefs;\n      auto Flags = getDecodedGVSummaryFlags(RawFlags, Version);\n      std::vector<ValueInfo> Refs = makeRefList(\n          ArrayRef<uint64_t>(Record).slice(RefListStartIndex, NumRefs));\n      VTableFuncList VTableFuncs;\n      for (unsigned I = VTableListStartIndex, E = Record.size(); I != E; ++I) {\n        ValueInfo Callee = getValueInfoFromValueId(Record[I]).first;\n        uint64_t Offset = Record[++I];\n        VTableFuncs.push_back({Callee, Offset});\n      }\n      auto VS =\n          std::make_unique<GlobalVarSummary>(Flags, GVF, std::move(Refs));\n      VS->setModulePath(getThisModule()->first());\n      VS->setVTableFuncs(VTableFuncs);\n      auto GUID = getValueInfoFromValueId(ValueID);\n      VS->setOriginalName(GUID.second);\n      TheIndex.addGlobalValueSummary(GUID.first, std::move(VS));\n      break;\n    }\n    // FS_COMBINED: [valueid, modid, flags, instcount, fflags, numrefs,\n    //               numrefs x valueid, n x (valueid)]\n    // FS_COMBINED_PROFILE: [valueid, modid, flags, instcount, fflags, numrefs,\n    //                       numrefs x valueid, n x (valueid, hotness)]\n    case bitc::FS_COMBINED:\n    case bitc::FS_COMBINED_PROFILE: {\n      unsigned ValueID = Record[0];\n      uint64_t ModuleId = Record[1];\n      uint64_t RawFlags = Record[2];\n      unsigned InstCount = Record[3];\n      uint64_t RawFunFlags = 0;\n      uint64_t EntryCount = 0;\n      unsigned NumRefs = Record[4];\n      unsigned NumRORefs = 0, NumWORefs = 0;\n      int RefListStartIndex = 5;\n\n      if (Version >= 4) {\n        RawFunFlags = Record[4];\n        RefListStartIndex = 6;\n        size_t NumRefsIndex = 5;\n        if (Version >= 5) {\n          unsigned NumRORefsOffset = 1;\n          RefListStartIndex = 7;\n          if (Version >= 6) {\n            NumRefsIndex = 6;\n            EntryCount = Record[5];\n            RefListStartIndex = 8;\n            if (Version >= 7) {\n              RefListStartIndex = 9;\n              NumWORefs = Record[8];\n              NumRORefsOffset = 2;\n            }\n          }\n          NumRORefs = Record[RefListStartIndex - NumRORefsOffset];\n        }\n        NumRefs = Record[NumRefsIndex];\n      }\n\n      auto Flags = getDecodedGVSummaryFlags(RawFlags, Version);\n      int CallGraphEdgeStartIndex = RefListStartIndex + NumRefs;\n      assert(Record.size() >= RefListStartIndex + NumRefs &&\n             \"Record size inconsistent with number of references\");\n      std::vector<ValueInfo> Refs = makeRefList(\n          ArrayRef<uint64_t>(Record).slice(RefListStartIndex, NumRefs));\n      bool HasProfile = (BitCode == bitc::FS_COMBINED_PROFILE);\n      std::vector<FunctionSummary::EdgeTy> Edges = makeCallList(\n          ArrayRef<uint64_t>(Record).slice(CallGraphEdgeStartIndex),\n          IsOldProfileFormat, HasProfile, false);\n      ValueInfo VI = getValueInfoFromValueId(ValueID).first;\n      setSpecialRefs(Refs, NumRORefs, NumWORefs);\n      auto FS = std::make_unique<FunctionSummary>(\n          Flags, InstCount, getDecodedFFlags(RawFunFlags), EntryCount,\n          std::move(Refs), std::move(Edges), std::move(PendingTypeTests),\n          std::move(PendingTypeTestAssumeVCalls),\n          std::move(PendingTypeCheckedLoadVCalls),\n          std::move(PendingTypeTestAssumeConstVCalls),\n          std::move(PendingTypeCheckedLoadConstVCalls),\n          std::move(PendingParamAccesses));\n      LastSeenSummary = FS.get();\n      LastSeenGUID = VI.getGUID();\n      FS->setModulePath(ModuleIdMap[ModuleId]);\n      TheIndex.addGlobalValueSummary(VI, std::move(FS));\n      break;\n    }\n    // FS_COMBINED_ALIAS: [valueid, modid, flags, valueid]\n    // Aliases must be emitted (and parsed) after all FS_COMBINED entries, as\n    // they expect all aliasee summaries to be available.\n    case bitc::FS_COMBINED_ALIAS: {\n      unsigned ValueID = Record[0];\n      uint64_t ModuleId = Record[1];\n      uint64_t RawFlags = Record[2];\n      unsigned AliaseeValueId = Record[3];\n      auto Flags = getDecodedGVSummaryFlags(RawFlags, Version);\n      auto AS = std::make_unique<AliasSummary>(Flags);\n      LastSeenSummary = AS.get();\n      AS->setModulePath(ModuleIdMap[ModuleId]);\n\n      auto AliaseeVI = getValueInfoFromValueId(AliaseeValueId).first;\n      auto AliaseeInModule = TheIndex.findSummaryInModule(AliaseeVI, AS->modulePath());\n      AS->setAliasee(AliaseeVI, AliaseeInModule);\n\n      ValueInfo VI = getValueInfoFromValueId(ValueID).first;\n      LastSeenGUID = VI.getGUID();\n      TheIndex.addGlobalValueSummary(VI, std::move(AS));\n      break;\n    }\n    // FS_COMBINED_GLOBALVAR_INIT_REFS: [valueid, modid, flags, n x valueid]\n    case bitc::FS_COMBINED_GLOBALVAR_INIT_REFS: {\n      unsigned ValueID = Record[0];\n      uint64_t ModuleId = Record[1];\n      uint64_t RawFlags = Record[2];\n      unsigned RefArrayStart = 3;\n      GlobalVarSummary::GVarFlags GVF(/* ReadOnly */ false,\n                                      /* WriteOnly */ false,\n                                      /* Constant */ false,\n                                      GlobalObject::VCallVisibilityPublic);\n      auto Flags = getDecodedGVSummaryFlags(RawFlags, Version);\n      if (Version >= 5) {\n        GVF = getDecodedGVarFlags(Record[3]);\n        RefArrayStart = 4;\n      }\n      std::vector<ValueInfo> Refs =\n          makeRefList(ArrayRef<uint64_t>(Record).slice(RefArrayStart));\n      auto FS =\n          std::make_unique<GlobalVarSummary>(Flags, GVF, std::move(Refs));\n      LastSeenSummary = FS.get();\n      FS->setModulePath(ModuleIdMap[ModuleId]);\n      ValueInfo VI = getValueInfoFromValueId(ValueID).first;\n      LastSeenGUID = VI.getGUID();\n      TheIndex.addGlobalValueSummary(VI, std::move(FS));\n      break;\n    }\n    // FS_COMBINED_ORIGINAL_NAME: [original_name]\n    case bitc::FS_COMBINED_ORIGINAL_NAME: {\n      uint64_t OriginalName = Record[0];\n      if (!LastSeenSummary)\n        return error(\"Name attachment that does not follow a combined record\");\n      LastSeenSummary->setOriginalName(OriginalName);\n      TheIndex.addOriginalName(LastSeenGUID, OriginalName);\n      // Reset the LastSeenSummary\n      LastSeenSummary = nullptr;\n      LastSeenGUID = 0;\n      break;\n    }\n    case bitc::FS_TYPE_TESTS:\n      assert(PendingTypeTests.empty());\n      llvm::append_range(PendingTypeTests, Record);\n      break;\n\n    case bitc::FS_TYPE_TEST_ASSUME_VCALLS:\n      assert(PendingTypeTestAssumeVCalls.empty());\n      for (unsigned I = 0; I != Record.size(); I += 2)\n        PendingTypeTestAssumeVCalls.push_back({Record[I], Record[I+1]});\n      break;\n\n    case bitc::FS_TYPE_CHECKED_LOAD_VCALLS:\n      assert(PendingTypeCheckedLoadVCalls.empty());\n      for (unsigned I = 0; I != Record.size(); I += 2)\n        PendingTypeCheckedLoadVCalls.push_back({Record[I], Record[I+1]});\n      break;\n\n    case bitc::FS_TYPE_TEST_ASSUME_CONST_VCALL:\n      PendingTypeTestAssumeConstVCalls.push_back(\n          {{Record[0], Record[1]}, {Record.begin() + 2, Record.end()}});\n      break;\n\n    case bitc::FS_TYPE_CHECKED_LOAD_CONST_VCALL:\n      PendingTypeCheckedLoadConstVCalls.push_back(\n          {{Record[0], Record[1]}, {Record.begin() + 2, Record.end()}});\n      break;\n\n    case bitc::FS_CFI_FUNCTION_DEFS: {\n      std::set<std::string> &CfiFunctionDefs = TheIndex.cfiFunctionDefs();\n      for (unsigned I = 0; I != Record.size(); I += 2)\n        CfiFunctionDefs.insert(\n            {Strtab.data() + Record[I], static_cast<size_t>(Record[I + 1])});\n      break;\n    }\n\n    case bitc::FS_CFI_FUNCTION_DECLS: {\n      std::set<std::string> &CfiFunctionDecls = TheIndex.cfiFunctionDecls();\n      for (unsigned I = 0; I != Record.size(); I += 2)\n        CfiFunctionDecls.insert(\n            {Strtab.data() + Record[I], static_cast<size_t>(Record[I + 1])});\n      break;\n    }\n\n    case bitc::FS_TYPE_ID:\n      parseTypeIdSummaryRecord(Record, Strtab, TheIndex);\n      break;\n\n    case bitc::FS_TYPE_ID_METADATA:\n      parseTypeIdCompatibleVtableSummaryRecord(Record);\n      break;\n\n    case bitc::FS_BLOCK_COUNT:\n      TheIndex.addBlockCount(Record[0]);\n      break;\n\n    case bitc::FS_PARAM_ACCESS: {\n      PendingParamAccesses = parseParamAccesses(Record);\n      break;\n    }\n    }\n  }\n  llvm_unreachable(\"Exit infinite loop\");\n}\n\n// Parse the  module string table block into the Index.\n// This populates the ModulePathStringTable map in the index.\nError ModuleSummaryIndexBitcodeReader::parseModuleStringTable() {\n  if (Error Err = Stream.EnterSubBlock(bitc::MODULE_STRTAB_BLOCK_ID))\n    return Err;\n\n  SmallVector<uint64_t, 64> Record;\n\n  SmallString<128> ModulePath;\n  ModuleSummaryIndex::ModuleInfo *LastSeenModule = nullptr;\n\n  while (true) {\n    Expected<BitstreamEntry> MaybeEntry = Stream.advanceSkippingSubblocks();\n    if (!MaybeEntry)\n      return MaybeEntry.takeError();\n    BitstreamEntry Entry = MaybeEntry.get();\n\n    switch (Entry.Kind) {\n    case BitstreamEntry::SubBlock: // Handled for us already.\n    case BitstreamEntry::Error:\n      return error(\"Malformed block\");\n    case BitstreamEntry::EndBlock:\n      return Error::success();\n    case BitstreamEntry::Record:\n      // The interesting case.\n      break;\n    }\n\n    Record.clear();\n    Expected<unsigned> MaybeRecord = Stream.readRecord(Entry.ID, Record);\n    if (!MaybeRecord)\n      return MaybeRecord.takeError();\n    switch (MaybeRecord.get()) {\n    default: // Default behavior: ignore.\n      break;\n    case bitc::MST_CODE_ENTRY: {\n      // MST_ENTRY: [modid, namechar x N]\n      uint64_t ModuleId = Record[0];\n\n      if (convertToString(Record, 1, ModulePath))\n        return error(\"Invalid record\");\n\n      LastSeenModule = TheIndex.addModule(ModulePath, ModuleId);\n      ModuleIdMap[ModuleId] = LastSeenModule->first();\n\n      ModulePath.clear();\n      break;\n    }\n    /// MST_CODE_HASH: [5*i32]\n    case bitc::MST_CODE_HASH: {\n      if (Record.size() != 5)\n        return error(\"Invalid hash length \" + Twine(Record.size()).str());\n      if (!LastSeenModule)\n        return error(\"Invalid hash that does not follow a module path\");\n      int Pos = 0;\n      for (auto &Val : Record) {\n        assert(!(Val >> 32) && \"Unexpected high bits set\");\n        LastSeenModule->second.second[Pos++] = Val;\n      }\n      // Reset LastSeenModule to avoid overriding the hash unexpectedly.\n      LastSeenModule = nullptr;\n      break;\n    }\n    }\n  }\n  llvm_unreachable(\"Exit infinite loop\");\n}\n\nnamespace {\n\n// FIXME: This class is only here to support the transition to llvm::Error. It\n// will be removed once this transition is complete. Clients should prefer to\n// deal with the Error value directly, rather than converting to error_code.\nclass BitcodeErrorCategoryType : public std::error_category {\n  const char *name() const noexcept override {\n    return \"llvm.bitcode\";\n  }\n\n  std::string message(int IE) const override {\n    BitcodeError E = static_cast<BitcodeError>(IE);\n    switch (E) {\n    case BitcodeError::CorruptedBitcode:\n      return \"Corrupted bitcode\";\n    }\n    llvm_unreachable(\"Unknown error type!\");\n  }\n};\n\n} // end anonymous namespace\n\nstatic ManagedStatic<BitcodeErrorCategoryType> ErrorCategory;\n\nconst std::error_category &llvm::BitcodeErrorCategory() {\n  return *ErrorCategory;\n}\n\nstatic Expected<StringRef> readBlobInRecord(BitstreamCursor &Stream,\n                                            unsigned Block, unsigned RecordID) {\n  if (Error Err = Stream.EnterSubBlock(Block))\n    return std::move(Err);\n\n  StringRef Strtab;\n  while (true) {\n    Expected<llvm::BitstreamEntry> MaybeEntry = Stream.advance();\n    if (!MaybeEntry)\n      return MaybeEntry.takeError();\n    llvm::BitstreamEntry Entry = MaybeEntry.get();\n\n    switch (Entry.Kind) {\n    case BitstreamEntry::EndBlock:\n      return Strtab;\n\n    case BitstreamEntry::Error:\n      return error(\"Malformed block\");\n\n    case BitstreamEntry::SubBlock:\n      if (Error Err = Stream.SkipBlock())\n        return std::move(Err);\n      break;\n\n    case BitstreamEntry::Record:\n      StringRef Blob;\n      SmallVector<uint64_t, 1> Record;\n      Expected<unsigned> MaybeRecord =\n          Stream.readRecord(Entry.ID, Record, &Blob);\n      if (!MaybeRecord)\n        return MaybeRecord.takeError();\n      if (MaybeRecord.get() == RecordID)\n        Strtab = Blob;\n      break;\n    }\n  }\n}\n\n//===----------------------------------------------------------------------===//\n// External interface\n//===----------------------------------------------------------------------===//\n\nExpected<std::vector<BitcodeModule>>\nllvm::getBitcodeModuleList(MemoryBufferRef Buffer) {\n  auto FOrErr = getBitcodeFileContents(Buffer);\n  if (!FOrErr)\n    return FOrErr.takeError();\n  return std::move(FOrErr->Mods);\n}\n\nExpected<BitcodeFileContents>\nllvm::getBitcodeFileContents(MemoryBufferRef Buffer) {\n  Expected<BitstreamCursor> StreamOrErr = initStream(Buffer);\n  if (!StreamOrErr)\n    return StreamOrErr.takeError();\n  BitstreamCursor &Stream = *StreamOrErr;\n\n  BitcodeFileContents F;\n  while (true) {\n    uint64_t BCBegin = Stream.getCurrentByteNo();\n\n    // We may be consuming bitcode from a client that leaves garbage at the end\n    // of the bitcode stream (e.g. Apple's ar tool). If we are close enough to\n    // the end that there cannot possibly be another module, stop looking.\n    if (BCBegin + 8 >= Stream.getBitcodeBytes().size())\n      return F;\n\n    Expected<llvm::BitstreamEntry> MaybeEntry = Stream.advance();\n    if (!MaybeEntry)\n      return MaybeEntry.takeError();\n    llvm::BitstreamEntry Entry = MaybeEntry.get();\n\n    switch (Entry.Kind) {\n    case BitstreamEntry::EndBlock:\n    case BitstreamEntry::Error:\n      return error(\"Malformed block\");\n\n    case BitstreamEntry::SubBlock: {\n      uint64_t IdentificationBit = -1ull;\n      if (Entry.ID == bitc::IDENTIFICATION_BLOCK_ID) {\n        IdentificationBit = Stream.GetCurrentBitNo() - BCBegin * 8;\n        if (Error Err = Stream.SkipBlock())\n          return std::move(Err);\n\n        {\n          Expected<llvm::BitstreamEntry> MaybeEntry = Stream.advance();\n          if (!MaybeEntry)\n            return MaybeEntry.takeError();\n          Entry = MaybeEntry.get();\n        }\n\n        if (Entry.Kind != BitstreamEntry::SubBlock ||\n            Entry.ID != bitc::MODULE_BLOCK_ID)\n          return error(\"Malformed block\");\n      }\n\n      if (Entry.ID == bitc::MODULE_BLOCK_ID) {\n        uint64_t ModuleBit = Stream.GetCurrentBitNo() - BCBegin * 8;\n        if (Error Err = Stream.SkipBlock())\n          return std::move(Err);\n\n        F.Mods.push_back({Stream.getBitcodeBytes().slice(\n                              BCBegin, Stream.getCurrentByteNo() - BCBegin),\n                          Buffer.getBufferIdentifier(), IdentificationBit,\n                          ModuleBit});\n        continue;\n      }\n\n      if (Entry.ID == bitc::STRTAB_BLOCK_ID) {\n        Expected<StringRef> Strtab =\n            readBlobInRecord(Stream, bitc::STRTAB_BLOCK_ID, bitc::STRTAB_BLOB);\n        if (!Strtab)\n          return Strtab.takeError();\n        // This string table is used by every preceding bitcode module that does\n        // not have its own string table. A bitcode file may have multiple\n        // string tables if it was created by binary concatenation, for example\n        // with \"llvm-cat -b\".\n        for (auto I = F.Mods.rbegin(), E = F.Mods.rend(); I != E; ++I) {\n          if (!I->Strtab.empty())\n            break;\n          I->Strtab = *Strtab;\n        }\n        // Similarly, the string table is used by every preceding symbol table;\n        // normally there will be just one unless the bitcode file was created\n        // by binary concatenation.\n        if (!F.Symtab.empty() && F.StrtabForSymtab.empty())\n          F.StrtabForSymtab = *Strtab;\n        continue;\n      }\n\n      if (Entry.ID == bitc::SYMTAB_BLOCK_ID) {\n        Expected<StringRef> SymtabOrErr =\n            readBlobInRecord(Stream, bitc::SYMTAB_BLOCK_ID, bitc::SYMTAB_BLOB);\n        if (!SymtabOrErr)\n          return SymtabOrErr.takeError();\n\n        // We can expect the bitcode file to have multiple symbol tables if it\n        // was created by binary concatenation. In that case we silently\n        // ignore any subsequent symbol tables, which is fine because this is a\n        // low level function. The client is expected to notice that the number\n        // of modules in the symbol table does not match the number of modules\n        // in the input file and regenerate the symbol table.\n        if (F.Symtab.empty())\n          F.Symtab = *SymtabOrErr;\n        continue;\n      }\n\n      if (Error Err = Stream.SkipBlock())\n        return std::move(Err);\n      continue;\n    }\n    case BitstreamEntry::Record:\n      if (Expected<unsigned> StreamFailed = Stream.skipRecord(Entry.ID))\n        continue;\n      else\n        return StreamFailed.takeError();\n    }\n  }\n}\n\n/// Get a lazy one-at-time loading module from bitcode.\n///\n/// This isn't always used in a lazy context.  In particular, it's also used by\n/// \\a parseModule().  If this is truly lazy, then we need to eagerly pull\n/// in forward-referenced functions from block address references.\n///\n/// \\param[in] MaterializeAll Set to \\c true if we should materialize\n/// everything.\nExpected<std::unique_ptr<Module>>\nBitcodeModule::getModuleImpl(LLVMContext &Context, bool MaterializeAll,\n                             bool ShouldLazyLoadMetadata, bool IsImporting,\n                             DataLayoutCallbackTy DataLayoutCallback) {\n  BitstreamCursor Stream(Buffer);\n\n  std::string ProducerIdentification;\n  if (IdentificationBit != -1ull) {\n    if (Error JumpFailed = Stream.JumpToBit(IdentificationBit))\n      return std::move(JumpFailed);\n    Expected<std::string> ProducerIdentificationOrErr =\n        readIdentificationBlock(Stream);\n    if (!ProducerIdentificationOrErr)\n      return ProducerIdentificationOrErr.takeError();\n\n    ProducerIdentification = *ProducerIdentificationOrErr;\n  }\n\n  if (Error JumpFailed = Stream.JumpToBit(ModuleBit))\n    return std::move(JumpFailed);\n  auto *R = new BitcodeReader(std::move(Stream), Strtab, ProducerIdentification,\n                              Context);\n\n  std::unique_ptr<Module> M =\n      std::make_unique<Module>(ModuleIdentifier, Context);\n  M->setMaterializer(R);\n\n  // Delay parsing Metadata if ShouldLazyLoadMetadata is true.\n  if (Error Err = R->parseBitcodeInto(M.get(), ShouldLazyLoadMetadata,\n                                      IsImporting, DataLayoutCallback))\n    return std::move(Err);\n\n  if (MaterializeAll) {\n    // Read in the entire module, and destroy the BitcodeReader.\n    if (Error Err = M->materializeAll())\n      return std::move(Err);\n  } else {\n    // Resolve forward references from blockaddresses.\n    if (Error Err = R->materializeForwardReferencedFunctions())\n      return std::move(Err);\n  }\n  return std::move(M);\n}\n\nExpected<std::unique_ptr<Module>>\nBitcodeModule::getLazyModule(LLVMContext &Context, bool ShouldLazyLoadMetadata,\n                             bool IsImporting) {\n  return getModuleImpl(Context, false, ShouldLazyLoadMetadata, IsImporting,\n                       [](StringRef) { return None; });\n}\n\n// Parse the specified bitcode buffer and merge the index into CombinedIndex.\n// We don't use ModuleIdentifier here because the client may need to control the\n// module path used in the combined summary (e.g. when reading summaries for\n// regular LTO modules).\nError BitcodeModule::readSummary(ModuleSummaryIndex &CombinedIndex,\n                                 StringRef ModulePath, uint64_t ModuleId) {\n  BitstreamCursor Stream(Buffer);\n  if (Error JumpFailed = Stream.JumpToBit(ModuleBit))\n    return JumpFailed;\n\n  ModuleSummaryIndexBitcodeReader R(std::move(Stream), Strtab, CombinedIndex,\n                                    ModulePath, ModuleId);\n  return R.parseModule();\n}\n\n// Parse the specified bitcode buffer, returning the function info index.\nExpected<std::unique_ptr<ModuleSummaryIndex>> BitcodeModule::getSummary() {\n  BitstreamCursor Stream(Buffer);\n  if (Error JumpFailed = Stream.JumpToBit(ModuleBit))\n    return std::move(JumpFailed);\n\n  auto Index = std::make_unique<ModuleSummaryIndex>(/*HaveGVs=*/false);\n  ModuleSummaryIndexBitcodeReader R(std::move(Stream), Strtab, *Index,\n                                    ModuleIdentifier, 0);\n\n  if (Error Err = R.parseModule())\n    return std::move(Err);\n\n  return std::move(Index);\n}\n\nstatic Expected<bool> getEnableSplitLTOUnitFlag(BitstreamCursor &Stream,\n                                                unsigned ID) {\n  if (Error Err = Stream.EnterSubBlock(ID))\n    return std::move(Err);\n  SmallVector<uint64_t, 64> Record;\n\n  while (true) {\n    Expected<BitstreamEntry> MaybeEntry = Stream.advanceSkippingSubblocks();\n    if (!MaybeEntry)\n      return MaybeEntry.takeError();\n    BitstreamEntry Entry = MaybeEntry.get();\n\n    switch (Entry.Kind) {\n    case BitstreamEntry::SubBlock: // Handled for us already.\n    case BitstreamEntry::Error:\n      return error(\"Malformed block\");\n    case BitstreamEntry::EndBlock:\n      // If no flags record found, conservatively return true to mimic\n      // behavior before this flag was added.\n      return true;\n    case BitstreamEntry::Record:\n      // The interesting case.\n      break;\n    }\n\n    // Look for the FS_FLAGS record.\n    Record.clear();\n    Expected<unsigned> MaybeBitCode = Stream.readRecord(Entry.ID, Record);\n    if (!MaybeBitCode)\n      return MaybeBitCode.takeError();\n    switch (MaybeBitCode.get()) {\n    default: // Default behavior: ignore.\n      break;\n    case bitc::FS_FLAGS: { // [flags]\n      uint64_t Flags = Record[0];\n      // Scan flags.\n      assert(Flags <= 0x3f && \"Unexpected bits in flag\");\n\n      return Flags & 0x8;\n    }\n    }\n  }\n  llvm_unreachable(\"Exit infinite loop\");\n}\n\n// Check if the given bitcode buffer contains a global value summary block.\nExpected<BitcodeLTOInfo> BitcodeModule::getLTOInfo() {\n  BitstreamCursor Stream(Buffer);\n  if (Error JumpFailed = Stream.JumpToBit(ModuleBit))\n    return std::move(JumpFailed);\n\n  if (Error Err = Stream.EnterSubBlock(bitc::MODULE_BLOCK_ID))\n    return std::move(Err);\n\n  while (true) {\n    Expected<llvm::BitstreamEntry> MaybeEntry = Stream.advance();\n    if (!MaybeEntry)\n      return MaybeEntry.takeError();\n    llvm::BitstreamEntry Entry = MaybeEntry.get();\n\n    switch (Entry.Kind) {\n    case BitstreamEntry::Error:\n      return error(\"Malformed block\");\n    case BitstreamEntry::EndBlock:\n      return BitcodeLTOInfo{/*IsThinLTO=*/false, /*HasSummary=*/false,\n                            /*EnableSplitLTOUnit=*/false};\n\n    case BitstreamEntry::SubBlock:\n      if (Entry.ID == bitc::GLOBALVAL_SUMMARY_BLOCK_ID) {\n        Expected<bool> EnableSplitLTOUnit =\n            getEnableSplitLTOUnitFlag(Stream, Entry.ID);\n        if (!EnableSplitLTOUnit)\n          return EnableSplitLTOUnit.takeError();\n        return BitcodeLTOInfo{/*IsThinLTO=*/true, /*HasSummary=*/true,\n                              *EnableSplitLTOUnit};\n      }\n\n      if (Entry.ID == bitc::FULL_LTO_GLOBALVAL_SUMMARY_BLOCK_ID) {\n        Expected<bool> EnableSplitLTOUnit =\n            getEnableSplitLTOUnitFlag(Stream, Entry.ID);\n        if (!EnableSplitLTOUnit)\n          return EnableSplitLTOUnit.takeError();\n        return BitcodeLTOInfo{/*IsThinLTO=*/false, /*HasSummary=*/true,\n                              *EnableSplitLTOUnit};\n      }\n\n      // Ignore other sub-blocks.\n      if (Error Err = Stream.SkipBlock())\n        return std::move(Err);\n      continue;\n\n    case BitstreamEntry::Record:\n      if (Expected<unsigned> StreamFailed = Stream.skipRecord(Entry.ID))\n        continue;\n      else\n        return StreamFailed.takeError();\n    }\n  }\n}\n\nstatic Expected<BitcodeModule> getSingleModule(MemoryBufferRef Buffer) {\n  Expected<std::vector<BitcodeModule>> MsOrErr = getBitcodeModuleList(Buffer);\n  if (!MsOrErr)\n    return MsOrErr.takeError();\n\n  if (MsOrErr->size() != 1)\n    return error(\"Expected a single module\");\n\n  return (*MsOrErr)[0];\n}\n\nExpected<std::unique_ptr<Module>>\nllvm::getLazyBitcodeModule(MemoryBufferRef Buffer, LLVMContext &Context,\n                           bool ShouldLazyLoadMetadata, bool IsImporting) {\n  Expected<BitcodeModule> BM = getSingleModule(Buffer);\n  if (!BM)\n    return BM.takeError();\n\n  return BM->getLazyModule(Context, ShouldLazyLoadMetadata, IsImporting);\n}\n\nExpected<std::unique_ptr<Module>> llvm::getOwningLazyBitcodeModule(\n    std::unique_ptr<MemoryBuffer> &&Buffer, LLVMContext &Context,\n    bool ShouldLazyLoadMetadata, bool IsImporting) {\n  auto MOrErr = getLazyBitcodeModule(*Buffer, Context, ShouldLazyLoadMetadata,\n                                     IsImporting);\n  if (MOrErr)\n    (*MOrErr)->setOwnedMemoryBuffer(std::move(Buffer));\n  return MOrErr;\n}\n\nExpected<std::unique_ptr<Module>>\nBitcodeModule::parseModule(LLVMContext &Context,\n                           DataLayoutCallbackTy DataLayoutCallback) {\n  return getModuleImpl(Context, true, false, false, DataLayoutCallback);\n  // TODO: Restore the use-lists to the in-memory state when the bitcode was\n  // written.  We must defer until the Module has been fully materialized.\n}\n\nExpected<std::unique_ptr<Module>>\nllvm::parseBitcodeFile(MemoryBufferRef Buffer, LLVMContext &Context,\n                       DataLayoutCallbackTy DataLayoutCallback) {\n  Expected<BitcodeModule> BM = getSingleModule(Buffer);\n  if (!BM)\n    return BM.takeError();\n\n  return BM->parseModule(Context, DataLayoutCallback);\n}\n\nExpected<std::string> llvm::getBitcodeTargetTriple(MemoryBufferRef Buffer) {\n  Expected<BitstreamCursor> StreamOrErr = initStream(Buffer);\n  if (!StreamOrErr)\n    return StreamOrErr.takeError();\n\n  return readTriple(*StreamOrErr);\n}\n\nExpected<bool> llvm::isBitcodeContainingObjCCategory(MemoryBufferRef Buffer) {\n  Expected<BitstreamCursor> StreamOrErr = initStream(Buffer);\n  if (!StreamOrErr)\n    return StreamOrErr.takeError();\n\n  return hasObjCCategory(*StreamOrErr);\n}\n\nExpected<std::string> llvm::getBitcodeProducerString(MemoryBufferRef Buffer) {\n  Expected<BitstreamCursor> StreamOrErr = initStream(Buffer);\n  if (!StreamOrErr)\n    return StreamOrErr.takeError();\n\n  return readIdentificationCode(*StreamOrErr);\n}\n\nError llvm::readModuleSummaryIndex(MemoryBufferRef Buffer,\n                                   ModuleSummaryIndex &CombinedIndex,\n                                   uint64_t ModuleId) {\n  Expected<BitcodeModule> BM = getSingleModule(Buffer);\n  if (!BM)\n    return BM.takeError();\n\n  return BM->readSummary(CombinedIndex, BM->getModuleIdentifier(), ModuleId);\n}\n\nExpected<std::unique_ptr<ModuleSummaryIndex>>\nllvm::getModuleSummaryIndex(MemoryBufferRef Buffer) {\n  Expected<BitcodeModule> BM = getSingleModule(Buffer);\n  if (!BM)\n    return BM.takeError();\n\n  return BM->getSummary();\n}\n\nExpected<BitcodeLTOInfo> llvm::getBitcodeLTOInfo(MemoryBufferRef Buffer) {\n  Expected<BitcodeModule> BM = getSingleModule(Buffer);\n  if (!BM)\n    return BM.takeError();\n\n  return BM->getLTOInfo();\n}\n\nExpected<std::unique_ptr<ModuleSummaryIndex>>\nllvm::getModuleSummaryIndexForFile(StringRef Path,\n                                   bool IgnoreEmptyThinLTOIndexFile) {\n  ErrorOr<std::unique_ptr<MemoryBuffer>> FileOrErr =\n      MemoryBuffer::getFileOrSTDIN(Path);\n  if (!FileOrErr)\n    return errorCodeToError(FileOrErr.getError());\n  if (IgnoreEmptyThinLTOIndexFile && !(*FileOrErr)->getBufferSize())\n    return nullptr;\n  return getModuleSummaryIndex(**FileOrErr);\n}\n"}}, "reports": [{"events": [{"location": {"col": 34, "file": 3, "line": 5579}, "message": "the definition seen here"}, {"location": {"col": 3, "file": 3, "line": 813}, "message": "differing parameters are named here: ('Stream'), in definition: ('Cursor')"}, {"location": {"col": 3, "file": 3, "line": 813}, "message": "function '(anonymous namespace)::ModuleSummaryIndexBitcodeReader::ModuleSummaryIndexBitcodeReader' has a definition with different parameter names"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/lib/Bitcode/Reader/BitcodeReader.cpp", "reportHash": "170660ee7037f3ae1b8eeedacb79a41b", "checkerName": "readability-inconsistent-declaration-parameter-name", "reviewStatus": null, "severity": "STYLE"}]};
      window.onload = function() {
        if (!browserCompatible) {
          setNonCompatibleBrowserMessage();
        } else {
          BugViewer.init(data.files, data.reports);
          BugViewer.create();
          BugViewer.initByUrl();
        }
      };
    </script>
  </head>
  <body>
  <div class="container">
    <div id="content">
      <div id="side-bar">
        <div class="header">
          <a href="index.html" class="button">&#8249; Return to List</a>
        </div>
        <div id="report-nav">
          <div class="header">Reports</div>
        </div>
      </div>
      <div id="editor-wrapper">
        <div class="header">
          <div id="file">
            <span class="label">File:</span>
            <span id="file-path"></span>
          </div>
          <div id="checker">
            <span class="label">Checker name:</span>
            <span id="checker-name"></span>
          </div>
          <div id="review-status-wrapper">
            <span class="label">Review status:</span>
            <span id="review-status"></span>
          </div>
        </div>
        <div id="editor"></div>
      </div>
    </div>
  </div>
  </body>
</html>
