<!DOCTYPE html>
<html>
  <head>
    <title>Plist HTML Viewer</title>

    <meta charset="UTF-8">

    <style type="text/css">
      .CodeMirror{font-family:monospace;height:300px;color:#000;direction:ltr}.CodeMirror-lines{padding:4px 0}.CodeMirror pre{padding:0 4px}.CodeMirror-gutter-filler,.CodeMirror-scrollbar-filler{background-color:#fff}.CodeMirror-gutters{border-right:1px solid #ddd;background-color:#f7f7f7;white-space:nowrap}.CodeMirror-linenumber{padding:0 3px 0 5px;min-width:20px;text-align:right;color:#999;white-space:nowrap}.CodeMirror-guttermarker{color:#000}.CodeMirror-guttermarker-subtle{color:#999}.CodeMirror-cursor{border-left:1px solid #000;border-right:none;width:0}.CodeMirror div.CodeMirror-secondarycursor{border-left:1px solid silver}.cm-fat-cursor .CodeMirror-cursor{width:auto;border:0!important;background:#7e7}.cm-fat-cursor div.CodeMirror-cursors{z-index:1}.cm-animate-fat-cursor{width:auto;border:0;-webkit-animation:blink 1.06s steps(1) infinite;-moz-animation:blink 1.06s steps(1) infinite;animation:blink 1.06s steps(1) infinite;background-color:#7e7}@-moz-keyframes blink{50%{background-color:transparent}}@-webkit-keyframes blink{50%{background-color:transparent}}@keyframes blink{50%{background-color:transparent}}.cm-tab{display:inline-block;text-decoration:inherit}.CodeMirror-rulers{position:absolute;left:0;right:0;top:-50px;bottom:-20px;overflow:hidden}.CodeMirror-ruler{border-left:1px solid #ccc;top:0;bottom:0;position:absolute}.cm-s-default .cm-header{color:#00f}.cm-s-default .cm-quote{color:#090}.cm-negative{color:#d44}.cm-positive{color:#292}.cm-header,.cm-strong{font-weight:700}.cm-em{font-style:italic}.cm-link{text-decoration:underline}.cm-strikethrough{text-decoration:line-through}.cm-s-default .cm-keyword{color:#708}.cm-s-default .cm-atom{color:#219}.cm-s-default .cm-number{color:#164}.cm-s-default .cm-def{color:#00f}.cm-s-default .cm-variable-2{color:#05a}.cm-s-default .cm-type,.cm-s-default .cm-variable-3{color:#085}.cm-s-default .cm-comment{color:#a50}.cm-s-default .cm-string{color:#a11}.cm-s-default .cm-string-2{color:#f50}.cm-s-default .cm-meta{color:#555}.cm-s-default .cm-qualifier{color:#555}.cm-s-default .cm-builtin{color:#30a}.cm-s-default .cm-bracket{color:#997}.cm-s-default .cm-tag{color:#170}.cm-s-default .cm-attribute{color:#00c}.cm-s-default .cm-hr{color:#999}.cm-s-default .cm-link{color:#00c}.cm-s-default .cm-error{color:red}.cm-invalidchar{color:red}.CodeMirror-composing{border-bottom:2px solid}div.CodeMirror span.CodeMirror-matchingbracket{color:#0f0}div.CodeMirror span.CodeMirror-nonmatchingbracket{color:#f22}.CodeMirror-matchingtag{background:rgba(255,150,0,.3)}.CodeMirror-activeline-background{background:#e8f2ff}.CodeMirror{position:relative;overflow:hidden;background:#fff}.CodeMirror-scroll{overflow:scroll!important;margin-bottom:-30px;margin-right:-30px;padding-bottom:30px;height:100%;outline:0;position:relative}.CodeMirror-sizer{position:relative;border-right:30px solid transparent}.CodeMirror-gutter-filler,.CodeMirror-hscrollbar,.CodeMirror-scrollbar-filler,.CodeMirror-vscrollbar{position:absolute;z-index:6;display:none}.CodeMirror-vscrollbar{right:0;top:0;overflow-x:hidden;overflow-y:scroll}.CodeMirror-hscrollbar{bottom:0;left:0;overflow-y:hidden;overflow-x:scroll}.CodeMirror-scrollbar-filler{right:0;bottom:0}.CodeMirror-gutter-filler{left:0;bottom:0}.CodeMirror-gutters{position:absolute;left:0;top:0;min-height:100%;z-index:3}.CodeMirror-gutter{white-space:normal;height:100%;display:inline-block;vertical-align:top;margin-bottom:-30px}.CodeMirror-gutter-wrapper{position:absolute;z-index:4;background:0 0!important;border:none!important}.CodeMirror-gutter-background{position:absolute;top:0;bottom:0;z-index:4}.CodeMirror-gutter-elt{position:absolute;cursor:default;z-index:4}.CodeMirror-gutter-wrapper ::selection{background-color:transparent}.CodeMirror-gutter-wrapper ::-moz-selection{background-color:transparent}.CodeMirror-lines{cursor:text;min-height:1px}.CodeMirror pre{-moz-border-radius:0;-webkit-border-radius:0;border-radius:0;border-width:0;background:0 0;font-family:inherit;font-size:inherit;margin:0;white-space:pre;word-wrap:normal;line-height:inherit;color:inherit;z-index:2;position:relative;overflow:visible;-webkit-tap-highlight-color:transparent;-webkit-font-variant-ligatures:contextual;font-variant-ligatures:contextual}.CodeMirror-wrap pre{word-wrap:break-word;white-space:pre-wrap;word-break:normal}.CodeMirror-linebackground{position:absolute;left:0;right:0;top:0;bottom:0;z-index:0}.CodeMirror-linewidget{position:relative;z-index:2;overflow:auto}.CodeMirror-rtl pre{direction:rtl}.CodeMirror-code{outline:0}.CodeMirror-gutter,.CodeMirror-gutters,.CodeMirror-linenumber,.CodeMirror-scroll,.CodeMirror-sizer{-moz-box-sizing:content-box;box-sizing:content-box}.CodeMirror-measure{position:absolute;width:100%;height:0;overflow:hidden;visibility:hidden}.CodeMirror-cursor{position:absolute;pointer-events:none}.CodeMirror-measure pre{position:static}div.CodeMirror-cursors{visibility:hidden;position:relative;z-index:3}div.CodeMirror-dragcursors{visibility:visible}.CodeMirror-focused div.CodeMirror-cursors{visibility:visible}.CodeMirror-selected{background:#d9d9d9}.CodeMirror-focused .CodeMirror-selected{background:#d7d4f0}.CodeMirror-crosshair{cursor:crosshair}.CodeMirror-line::selection,.CodeMirror-line>span::selection,.CodeMirror-line>span>span::selection{background:#d7d4f0}.CodeMirror-line::-moz-selection,.CodeMirror-line>span::-moz-selection,.CodeMirror-line>span>span::-moz-selection{background:#d7d4f0}.cm-searching{background-color:#ffa;background-color:rgba(255,255,0,.4)}.cm-force-border{padding-right:.1px}@media print{.CodeMirror div.CodeMirror-cursors{visibility:hidden}}.cm-tab-wrap-hack:after{content:''}span.CodeMirror-selectedtext{background:0 0}
/*# sourceMappingURL=codemirror.min.css.map */

      .severity-low {
  background-color: #669603;
}

.severity-low:after {
  content : 'L';
}

.severity-unspecified {
  background-color: #666666;
}

.severity-unspecified:after {
  content : 'U';
}

.severity-style {
  background-color: #9932cc;
}

.severity-style:after {
  content : 'S';
}

.severity-medium {
  background-color: #a9d323;
  color: black;
}

.severity-medium:after {
  content : 'M';
}

.severity-high {
  background-color: #ffa800;
}

.severity-high:after {
  content : 'H';
}

.severity-critical {
  background-color: #e92625;
}

.severity-critical:after {
  content : 'C';
}

i[class*="severity-"] {
  line-height: normal;
  text-transform: capitalize;
  font-size: 0.8em;
  font-weight: bold;
  color: white;
  display: inline-block;
  width: 16px;
  height: 16px;
  text-align: center;
  font-family: sans-serif;
}

      html, body {
  width: 100%;
  height: 100%;
  padding: 0px;
  margin: 0px;
}

div.container {
  padding: 10px;
}

#content {
  height: 100%;
  display: block;
  overflow: hidden;
}

#content > div {
  margin: 10px;
  overflow: hidden;
  border: 1px solid #ddd;
  border-radius: 3px;
  overflow: hidden;
  height: 97%;
}

.button {
  background-color: #f1f1f1;
  text-decoration: none;
  display: inline-block;
  padding: 8px 16px;
  color: black;
  cursor: pointer;
}

.button:hover {
  background-color: #ddd;
  color: black;
}

.review-status {
  color: white;
  text-align: center;
}

.review-status-confirmed {
  background-color: #e92625;
}

.review-status-false-positive {
  background-color: grey;
}

.review-status-intentional {
  background-color: #669603;
}

      div.container {
  width: 100%;
  height: 100%;
  padding: 0px;
}

#editor-wrapper {
  margin: 10px;
}

#side-bar {
  float: left;
  width: 260px;
  margin: 0px;
}

#report-nav ul {
  list-style-type: none;
  padding: 0;
  margin: 0;
  overflow-y: auto;
  height: 100%;
}

#report-nav ul > li {
  padding: .4em;
  background-color: #fff;
  border-bottom: 1px solid rgba(0,0,0,.125);
  text-align: left;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

#report-nav ul > li.active {
  background-color: #427ea9;
  color: white;
}

#report-nav ul > li:hover {
  background-color: #427ea9;
  color: white;
  cursor: pointer;
}

#report-nav ul a {
  text-decoration: none;
}

#report-nav i[class*="severity-"] {
  margin-right: 5px;
}

.header {
  border-bottom: 1px solid lightgrey;
  font-family: monospace;
  padding: 10px;
  background-color: #fafbfc;
  border-bottom: 1px solid #e1e4e8;
  border-top-left-radius: 2px;
  border-top-right-radius: 2px;
}

#report-nav .header {
  font-weight: bold;
}

#editor-wrapper .header > div {
  padding-top: 2px;
}

#file-path,
#checker-name {
  color: #195ea2;
}

#review-status {
  padding: 0px 5px;
}

#file-path {
  font-family: monospace;
}

.check-msg {
  display: inline-block;
  padding: 3px 6px;
  margin: 1px;
  -webkit-border-radius: 5px;
  -moz-border-radius: 5px;
  border-radius: 5px;
}

.check-msg.info {
  color: #00546f;
  background-color: #bfdfe9;
  border: 1px solid #87a8b3;
}

.check-msg.error {
  background-color: #f2dede;
  color: #a94442;
  border: 1px solid #ebcccc;
}

.check-msg.macro {
  background-color: #d7dac2;
  color: #4f5c6d;
  border: 1px solid #d7dac2;
}

.check-msg.note {
  background-color: #d7d7d7;
  color: #4f5c6d;
  border: 1px solid #bfbfbf;
}

.check-msg.current {
  border: 2px dashed #3692ff;
}

.check-msg .tag {
  padding: 1px 5px;
  text-align: center;
  border-radius: 2px;
  margin-right: 5px;
  text-decoration: inherit;
}

.check-msg .tag.macro {
  background-color: #83876a;
  color: white;
  text-transform: capitalize;
}

.check-msg .tag.note {
  background-color: #9299a1;
  color: white;
  text-transform: capitalize;
}

.checker-enum {
  color: white;
  padding: 1px 5px;
  text-align: center;
  border-radius: 25px;
  margin-right: 5px;
  text-decoration: inherit;
}

.checker-enum.info {
  background-color: #427ea9;
}

.checker-enum.error {
  background-color: #a94442;
}

.arrow {
  border: solid black;
  border-width: 0 3px 3px 0;
  display: inline-block;
  padding: 3px;
  cursor: pointer;
  margin: 0px 5px;
}

.arrow:hover {
  border: solid #437ea8;
  border-width: 0 3px 3px 0;
}

.left-arrow {
  transform: rotate(135deg);
  -webkit-transform: rotate(135deg);
}

.right-arrow {
  transform: rotate(-45deg);
  -webkit-transform: rotate(-45deg);
}

    </style>

    <script type="text/javascript">
      function setNonCompatibleBrowserMessage() {
  document.body.innerHTML =
    '<h2 style="margin-left: 20px;">Your browser is not compatible with CodeChecker Viewer!</h2> \
     <p style="margin-left: 20px;">The version required for the following browsers are:</p> \
     <ul style="margin-left: 20px;"> \
     <li>Internet Explorer: version 9 or newer</li> \
     <li>Firefox: version 22.0 or newer</li> \
     </ul>';
}

// http://stackoverflow.com/questions/5916900/how-can-you-detect-the-version-of-a-browser
var browserVersion = (function(){
  var ua = navigator.userAgent, tem,
    M = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];

  if (/trident/i.test(M[1])) {
    tem = /\brv[ :]+(\d+)/g.exec(ua) || [];
    return 'IE ' + (tem[1] || '');
  }

  if (M[1] === 'Chrome') {
    tem = ua.match(/\b(OPR|Edge)\/(\d+)/);
    if (tem != null) return tem.slice(1).join(' ').replace('OPR', 'Opera');
  }

  M = M[2] ? [M[1], M[2]] : [navigator.appName, navigator.appVersion, '-?'];
  if ((tem = ua.match(/version\/(\d+)/i)) != null) M.splice(1, 1, tem[1]);
    return M.join(' ');
})();

var pos = browserVersion.indexOf(' ');
var browser = browserVersion.substr(0, pos);
var version = parseInt(browserVersion.substr(pos + 1));

var browserCompatible
  = browser === 'Firefox'
  ? version >= 22
  : browser === 'IE'
  ? version >= 9
  : true;


      /* MIT License

Copyright (C) 2017 by Marijn Haverbeke <marijnh@gmail.com> and others

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
 */
      !function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):e.CodeMirror=t()}(this,function(){"use strict";function e(e){return new RegExp("(^|\\s)"+e+"(?:$|\\s)\\s*")}function t(e){for(var t=e.childNodes.length;t>0;--t)e.removeChild(e.firstChild);return e}function r(e,r){return t(e).appendChild(r)}function n(e,t,r,n){var i=document.createElement(e);if(r&&(i.className=r),n&&(i.style.cssText=n),"string"==typeof t)i.appendChild(document.createTextNode(t));else if(t)for(var o=0;o<t.length;++o)i.appendChild(t[o]);return i}function i(e,t,r,i){var o=n(e,t,r,i);return o.setAttribute("role","presentation"),o}function o(e,t){if(3==t.nodeType&&(t=t.parentNode),e.contains)return e.contains(t);do{if(11==t.nodeType&&(t=t.host),t==e)return!0}while(t=t.parentNode)}function l(){var e;try{e=document.activeElement}catch(t){e=document.body||null}for(;e&&e.shadowRoot&&e.shadowRoot.activeElement;)e=e.shadowRoot.activeElement;return e}function s(t,r){var n=t.className;e(r).test(n)||(t.className+=(n?" ":"")+r)}function a(t,r){for(var n=t.split(" "),i=0;i<n.length;i++)n[i]&&!e(n[i]).test(r)&&(r+=" "+n[i]);return r}function u(e){var t=Array.prototype.slice.call(arguments,1);return function(){return e.apply(null,t)}}function c(e,t,r){t||(t={});for(var n in e)!e.hasOwnProperty(n)||!1===r&&t.hasOwnProperty(n)||(t[n]=e[n]);return t}function f(e,t,r,n,i){null==t&&-1==(t=e.search(/[^\s\u00a0]/))&&(t=e.length);for(var o=n||0,l=i||0;;){var s=e.indexOf("\t",o);if(s<0||s>=t)return l+(t-o);l+=s-o,l+=r-l%r,o=s+1}}function h(e,t){for(var r=0;r<e.length;++r)if(e[r]==t)return r;return-1}function d(e,t,r){for(var n=0,i=0;;){var o=e.indexOf("\t",n);-1==o&&(o=e.length);var l=o-n;if(o==e.length||i+l>=t)return n+Math.min(l,t-i);if(i+=o-n,i+=r-i%r,n=o+1,i>=t)return n}}function p(e){for(;Kl.length<=e;)Kl.push(g(Kl)+" ");return Kl[e]}function g(e){return e[e.length-1]}function v(e,t){for(var r=[],n=0;n<e.length;n++)r[n]=t(e[n],n);return r}function m(e,t,r){for(var n=0,i=r(t);n<e.length&&r(e[n])<=i;)n++;e.splice(n,0,t)}function y(){}function b(e,t){var r;return Object.create?r=Object.create(e):(y.prototype=e,r=new y),t&&c(t,r),r}function w(e){return/\w/.test(e)||e>""&&(e.toUpperCase()!=e.toLowerCase()||jl.test(e))}function x(e,t){return t?!!(t.source.indexOf("\\w")>-1&&w(e))||t.test(e):w(e)}function C(e){for(var t in e)if(e.hasOwnProperty(t)&&e[t])return!1;return!0}function S(e){return e.charCodeAt(0)>=768&&Xl.test(e)}function L(e,t,r){for(;(r<0?t>0:t<e.length)&&S(e.charAt(t));)t+=r;return t}function k(e,t,r){for(var n=t>r?-1:1;;){if(t==r)return t;var i=(t+r)/2,o=n<0?Math.ceil(i):Math.floor(i);if(o==t)return e(o)?t:r;e(o)?r=o:t=o+n}}function T(e,t,r){var o=this;this.input=r,o.scrollbarFiller=n("div",null,"CodeMirror-scrollbar-filler"),o.scrollbarFiller.setAttribute("cm-not-content","true"),o.gutterFiller=n("div",null,"CodeMirror-gutter-filler"),o.gutterFiller.setAttribute("cm-not-content","true"),o.lineDiv=i("div",null,"CodeMirror-code"),o.selectionDiv=n("div",null,null,"position: relative; z-index: 1"),o.cursorDiv=n("div",null,"CodeMirror-cursors"),o.measure=n("div",null,"CodeMirror-measure"),o.lineMeasure=n("div",null,"CodeMirror-measure"),o.lineSpace=i("div",[o.measure,o.lineMeasure,o.selectionDiv,o.cursorDiv,o.lineDiv],null,"position: relative; outline: none");var l=i("div",[o.lineSpace],"CodeMirror-lines");o.mover=n("div",[l],null,"position: relative"),o.sizer=n("div",[o.mover],"CodeMirror-sizer"),o.sizerWidth=null,o.heightForcer=n("div",null,null,"position: absolute; height: "+Rl+"px; width: 1px;"),o.gutters=n("div",null,"CodeMirror-gutters"),o.lineGutter=null,o.scroller=n("div",[o.sizer,o.heightForcer,o.gutters],"CodeMirror-scroll"),o.scroller.setAttribute("tabIndex","-1"),o.wrapper=n("div",[o.scrollbarFiller,o.gutterFiller,o.scroller],"CodeMirror"),gl&&vl<8&&(o.gutters.style.zIndex=-1,o.scroller.style.paddingRight=0),ml||fl&&Tl||(o.scroller.draggable=!0),e&&(e.appendChild?e.appendChild(o.wrapper):e(o.wrapper)),o.viewFrom=o.viewTo=t.first,o.reportedViewFrom=o.reportedViewTo=t.first,o.view=[],o.renderedView=null,o.externalMeasured=null,o.viewOffset=0,o.lastWrapHeight=o.lastWrapWidth=0,o.updateLineNumbers=null,o.nativeBarWidth=o.barHeight=o.barWidth=0,o.scrollbarsClipped=!1,o.lineNumWidth=o.lineNumInnerWidth=o.lineNumChars=null,o.alignWidgets=!1,o.cachedCharWidth=o.cachedTextHeight=o.cachedPaddingH=null,o.maxLine=null,o.maxLineLength=0,o.maxLineChanged=!1,o.wheelDX=o.wheelDY=o.wheelStartX=o.wheelStartY=null,o.shift=!1,o.selForContextMenu=null,o.activeTouch=null,r.init(o)}function M(e,t){if((t-=e.first)<0||t>=e.size)throw new Error("There is no line "+(t+e.first)+" in the document.");for(var r=e;!r.lines;)for(var n=0;;++n){var i=r.children[n],o=i.chunkSize();if(t<o){r=i;break}t-=o}return r.lines[t]}function N(e,t,r){var n=[],i=t.line;return e.iter(t.line,r.line+1,function(e){var o=e.text;i==r.line&&(o=o.slice(0,r.ch)),i==t.line&&(o=o.slice(t.ch)),n.push(o),++i}),n}function O(e,t,r){var n=[];return e.iter(t,r,function(e){n.push(e.text)}),n}function A(e,t){var r=t-e.height;if(r)for(var n=e;n;n=n.parent)n.height+=r}function W(e){if(null==e.parent)return null;for(var t=e.parent,r=h(t.lines,e),n=t.parent;n;t=n,n=n.parent)for(var i=0;n.children[i]!=t;++i)r+=n.children[i].chunkSize();return r+t.first}function D(e,t){var r=e.first;e:do{for(var n=0;n<e.children.length;++n){var i=e.children[n],o=i.height;if(t<o){e=i;continue e}t-=o,r+=i.chunkSize()}return r}while(!e.lines);for(var l=0;l<e.lines.length;++l){var s=e.lines[l].height;if(t<s)break;t-=s}return r+l}function H(e,t){return t>=e.first&&t<e.first+e.size}function F(e,t){return String(e.lineNumberFormatter(t+e.firstLineNumber))}function E(e,t,r){if(void 0===r&&(r=null),!(this instanceof E))return new E(e,t,r);this.line=e,this.ch=t,this.sticky=r}function P(e,t){return e.line-t.line||e.ch-t.ch}function I(e,t){return e.sticky==t.sticky&&0==P(e,t)}function z(e){return E(e.line,e.ch)}function R(e,t){return P(e,t)<0?t:e}function B(e,t){return P(e,t)<0?e:t}function G(e,t){return Math.max(e.first,Math.min(t,e.first+e.size-1))}function U(e,t){if(t.line<e.first)return E(e.first,0);var r=e.first+e.size-1;return t.line>r?E(r,M(e,r).text.length):V(t,M(e,t.line).text.length)}function V(e,t){var r=e.ch;return null==r||r>t?E(e.line,t):r<0?E(e.line,0):e}function K(e,t){for(var r=[],n=0;n<t.length;n++)r[n]=U(e,t[n]);return r}function j(){Yl=!0}function X(){_l=!0}function Y(e,t,r){this.marker=e,this.from=t,this.to=r}function _(e,t){if(e)for(var r=0;r<e.length;++r){var n=e[r];if(n.marker==t)return n}}function $(e,t){for(var r,n=0;n<e.length;++n)e[n]!=t&&(r||(r=[])).push(e[n]);return r}function q(e,t){e.markedSpans=e.markedSpans?e.markedSpans.concat([t]):[t],t.marker.attachLine(e)}function Z(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t)||o.from==t&&"bookmark"==l.type&&(!r||!o.marker.insertLeft)){var s=null==o.to||(l.inclusiveRight?o.to>=t:o.to>t);(n||(n=[])).push(new Y(l,o.from,s?null:o.to))}}return n}function Q(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.to||(l.inclusiveRight?o.to>=t:o.to>t)||o.from==t&&"bookmark"==l.type&&(!r||o.marker.insertLeft)){var s=null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t);(n||(n=[])).push(new Y(l,s?null:o.from-t,null==o.to?null:o.to-t))}}return n}function J(e,t){if(t.full)return null;var r=H(e,t.from.line)&&M(e,t.from.line).markedSpans,n=H(e,t.to.line)&&M(e,t.to.line).markedSpans;if(!r&&!n)return null;var i=t.from.ch,o=t.to.ch,l=0==P(t.from,t.to),s=Z(r,i,l),a=Q(n,o,l),u=1==t.text.length,c=g(t.text).length+(u?i:0);if(s)for(var f=0;f<s.length;++f){var h=s[f];if(null==h.to){var d=_(a,h.marker);d?u&&(h.to=null==d.to?null:d.to+c):h.to=i}}if(a)for(var p=0;p<a.length;++p){var v=a[p];null!=v.to&&(v.to+=c),null==v.from?_(s,v.marker)||(v.from=c,u&&(s||(s=[])).push(v)):(v.from+=c,u&&(s||(s=[])).push(v))}s&&(s=ee(s)),a&&a!=s&&(a=ee(a));var m=[s];if(!u){var y,b=t.text.length-2;if(b>0&&s)for(var w=0;w<s.length;++w)null==s[w].to&&(y||(y=[])).push(new Y(s[w].marker,null,null));for(var x=0;x<b;++x)m.push(y);m.push(a)}return m}function ee(e){for(var t=0;t<e.length;++t){var r=e[t];null!=r.from&&r.from==r.to&&!1!==r.marker.clearWhenEmpty&&e.splice(t--,1)}return e.length?e:null}function te(e,t,r){var n=null;if(e.iter(t.line,r.line+1,function(e){if(e.markedSpans)for(var t=0;t<e.markedSpans.length;++t){var r=e.markedSpans[t].marker;!r.readOnly||n&&-1!=h(n,r)||(n||(n=[])).push(r)}}),!n)return null;for(var i=[{from:t,to:r}],o=0;o<n.length;++o)for(var l=n[o],s=l.find(0),a=0;a<i.length;++a){var u=i[a];if(!(P(u.to,s.from)<0||P(u.from,s.to)>0)){var c=[a,1],f=P(u.from,s.from),d=P(u.to,s.to);(f<0||!l.inclusiveLeft&&!f)&&c.push({from:u.from,to:s.from}),(d>0||!l.inclusiveRight&&!d)&&c.push({from:s.to,to:u.to}),i.splice.apply(i,c),a+=c.length-3}}return i}function re(e){var t=e.markedSpans;if(t){for(var r=0;r<t.length;++r)t[r].marker.detachLine(e);e.markedSpans=null}}function ne(e,t){if(t){for(var r=0;r<t.length;++r)t[r].marker.attachLine(e);e.markedSpans=t}}function ie(e){return e.inclusiveLeft?-1:0}function oe(e){return e.inclusiveRight?1:0}function le(e,t){var r=e.lines.length-t.lines.length;if(0!=r)return r;var n=e.find(),i=t.find(),o=P(n.from,i.from)||ie(e)-ie(t);if(o)return-o;var l=P(n.to,i.to)||oe(e)-oe(t);return l||t.id-e.id}function se(e,t){var r,n=_l&&e.markedSpans;if(n)for(var i=void 0,o=0;o<n.length;++o)(i=n[o]).marker.collapsed&&null==(t?i.from:i.to)&&(!r||le(r,i.marker)<0)&&(r=i.marker);return r}function ae(e){return se(e,!0)}function ue(e){return se(e,!1)}function ce(e,t,r,n,i){var o=M(e,t),l=_l&&o.markedSpans;if(l)for(var s=0;s<l.length;++s){var a=l[s];if(a.marker.collapsed){var u=a.marker.find(0),c=P(u.from,r)||ie(a.marker)-ie(i),f=P(u.to,n)||oe(a.marker)-oe(i);if(!(c>=0&&f<=0||c<=0&&f>=0)&&(c<=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.to,r)>=0:P(u.to,r)>0)||c>=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.from,n)<=0:P(u.from,n)<0)))return!0}}}function fe(e){for(var t;t=ae(e);)e=t.find(-1,!0).line;return e}function he(e){for(var t;t=ue(e);)e=t.find(1,!0).line;return e}function de(e){for(var t,r;t=ue(e);)e=t.find(1,!0).line,(r||(r=[])).push(e);return r}function pe(e,t){var r=M(e,t),n=fe(r);return r==n?t:W(n)}function ge(e,t){if(t>e.lastLine())return t;var r,n=M(e,t);if(!ve(e,n))return t;for(;r=ue(n);)n=r.find(1,!0).line;return W(n)+1}function ve(e,t){var r=_l&&t.markedSpans;if(r)for(var n=void 0,i=0;i<r.length;++i)if((n=r[i]).marker.collapsed){if(null==n.from)return!0;if(!n.marker.widgetNode&&0==n.from&&n.marker.inclusiveLeft&&me(e,t,n))return!0}}function me(e,t,r){if(null==r.to){var n=r.marker.find(1,!0);return me(e,n.line,_(n.line.markedSpans,r.marker))}if(r.marker.inclusiveRight&&r.to==t.text.length)return!0;for(var i=void 0,o=0;o<t.markedSpans.length;++o)if((i=t.markedSpans[o]).marker.collapsed&&!i.marker.widgetNode&&i.from==r.to&&(null==i.to||i.to!=r.from)&&(i.marker.inclusiveLeft||r.marker.inclusiveRight)&&me(e,t,i))return!0}function ye(e){for(var t=0,r=(e=fe(e)).parent,n=0;n<r.lines.length;++n){var i=r.lines[n];if(i==e)break;t+=i.height}for(var o=r.parent;o;r=o,o=r.parent)for(var l=0;l<o.children.length;++l){var s=o.children[l];if(s==r)break;t+=s.height}return t}function be(e){if(0==e.height)return 0;for(var t,r=e.text.length,n=e;t=ae(n);){var i=t.find(0,!0);n=i.from.line,r+=i.from.ch-i.to.ch}for(n=e;t=ue(n);){var o=t.find(0,!0);r-=n.text.length-o.from.ch,r+=(n=o.to.line).text.length-o.to.ch}return r}function we(e){var t=e.display,r=e.doc;t.maxLine=M(r,r.first),t.maxLineLength=be(t.maxLine),t.maxLineChanged=!0,r.iter(function(e){var r=be(e);r>t.maxLineLength&&(t.maxLineLength=r,t.maxLine=e)})}function xe(e,t,r,n){if(!e)return n(t,r,"ltr",0);for(var i=!1,o=0;o<e.length;++o){var l=e[o];(l.from<r&&l.to>t||t==r&&l.to==t)&&(n(Math.max(l.from,t),Math.min(l.to,r),1==l.level?"rtl":"ltr",o),i=!0)}i||n(t,r,"ltr")}function Ce(e,t,r){var n;$l=null;for(var i=0;i<e.length;++i){var o=e[i];if(o.from<t&&o.to>t)return i;o.to==t&&(o.from!=o.to&&"before"==r?n=i:$l=i),o.from==t&&(o.from!=o.to&&"before"!=r?n=i:$l=i)}return null!=n?n:$l}function Se(e,t){var r=e.order;return null==r&&(r=e.order=ql(e.text,t)),r}function Le(e,t){return e._handlers&&e._handlers[t]||Zl}function ke(e,t,r){if(e.removeEventListener)e.removeEventListener(t,r,!1);else if(e.detachEvent)e.detachEvent("on"+t,r);else{var n=e._handlers,i=n&&n[t];if(i){var o=h(i,r);o>-1&&(n[t]=i.slice(0,o).concat(i.slice(o+1)))}}}function Te(e,t){var r=Le(e,t);if(r.length)for(var n=Array.prototype.slice.call(arguments,2),i=0;i<r.length;++i)r[i].apply(null,n)}function Me(e,t,r){return"string"==typeof t&&(t={type:t,preventDefault:function(){this.defaultPrevented=!0}}),Te(e,r||t.type,e,t),He(t)||t.codemirrorIgnore}function Ne(e){var t=e._handlers&&e._handlers.cursorActivity;if(t)for(var r=e.curOp.cursorActivityHandlers||(e.curOp.cursorActivityHandlers=[]),n=0;n<t.length;++n)-1==h(r,t[n])&&r.push(t[n])}function Oe(e,t){return Le(e,t).length>0}function Ae(e){e.prototype.on=function(e,t){Ql(this,e,t)},e.prototype.off=function(e,t){ke(this,e,t)}}function We(e){e.preventDefault?e.preventDefault():e.returnValue=!1}function De(e){e.stopPropagation?e.stopPropagation():e.cancelBubble=!0}function He(e){return null!=e.defaultPrevented?e.defaultPrevented:0==e.returnValue}function Fe(e){We(e),De(e)}function Ee(e){return e.target||e.srcElement}function Pe(e){var t=e.which;return null==t&&(1&e.button?t=1:2&e.button?t=3:4&e.button&&(t=2)),Ml&&e.ctrlKey&&1==t&&(t=3),t}function Ie(e){if(null==Il){var t=n("span","​");r(e,n("span",[t,document.createTextNode("x")])),0!=e.firstChild.offsetHeight&&(Il=t.offsetWidth<=1&&t.offsetHeight>2&&!(gl&&vl<8))}var i=Il?n("span","​"):n("span"," ",null,"display: inline-block; width: 1px; margin-right: -1px");return i.setAttribute("cm-text",""),i}function ze(e){if(null!=zl)return zl;var n=r(e,document.createTextNode("AخA")),i=Wl(n,0,1).getBoundingClientRect(),o=Wl(n,1,2).getBoundingClientRect();return t(e),!(!i||i.left==i.right)&&(zl=o.right-i.right<3)}function Re(e){if(null!=ns)return ns;var t=r(e,n("span","x")),i=t.getBoundingClientRect(),o=Wl(t,0,1).getBoundingClientRect();return ns=Math.abs(i.left-o.left)>1}function Be(e,t){arguments.length>2&&(t.dependencies=Array.prototype.slice.call(arguments,2)),is[e]=t}function Ge(e){if("string"==typeof e&&os.hasOwnProperty(e))e=os[e];else if(e&&"string"==typeof e.name&&os.hasOwnProperty(e.name)){var t=os[e.name];"string"==typeof t&&(t={name:t}),(e=b(t,e)).name=t.name}else{if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+xml$/.test(e))return Ge("application/xml");if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+json$/.test(e))return Ge("application/json")}return"string"==typeof e?{name:e}:e||{name:"null"}}function Ue(e,t){t=Ge(t);var r=is[t.name];if(!r)return Ue(e,"text/plain");var n=r(e,t);if(ls.hasOwnProperty(t.name)){var i=ls[t.name];for(var o in i)i.hasOwnProperty(o)&&(n.hasOwnProperty(o)&&(n["_"+o]=n[o]),n[o]=i[o])}if(n.name=t.name,t.helperType&&(n.helperType=t.helperType),t.modeProps)for(var l in t.modeProps)n[l]=t.modeProps[l];return n}function Ve(e,t){c(t,ls.hasOwnProperty(e)?ls[e]:ls[e]={})}function Ke(e,t){if(!0===t)return t;if(e.copyState)return e.copyState(t);var r={};for(var n in t){var i=t[n];i instanceof Array&&(i=i.concat([])),r[n]=i}return r}function je(e,t){for(var r;e.innerMode&&(r=e.innerMode(t))&&r.mode!=e;)t=r.state,e=r.mode;return r||{mode:e,state:t}}function Xe(e,t,r){return!e.startState||e.startState(t,r)}function Ye(e,t,r,n){var i=[e.state.modeGen],o={};tt(e,t.text,e.doc.mode,r,function(e,t){return i.push(e,t)},o,n);for(var l=r.state,s=0;s<e.state.overlays.length;++s)!function(n){var l=e.state.overlays[n],s=1,a=0;r.state=!0,tt(e,t.text,l.mode,r,function(e,t){for(var r=s;a<e;){var n=i[s];n>e&&i.splice(s,1,e,i[s+1],n),s+=2,a=Math.min(e,n)}if(t)if(l.opaque)i.splice(r,s-r,e,"overlay "+t),s=r+2;else for(;r<s;r+=2){var o=i[r+1];i[r+1]=(o?o+" ":"")+"overlay "+t}},o)}(s);return r.state=l,{styles:i,classes:o.bgClass||o.textClass?o:null}}function _e(e,t,r){if(!t.styles||t.styles[0]!=e.state.modeGen){var n=$e(e,W(t)),i=t.text.length>e.options.maxHighlightLength&&Ke(e.doc.mode,n.state),o=Ye(e,t,n);i&&(n.state=i),t.stateAfter=n.save(!i),t.styles=o.styles,o.classes?t.styleClasses=o.classes:t.styleClasses&&(t.styleClasses=null),r===e.doc.highlightFrontier&&(e.doc.modeFrontier=Math.max(e.doc.modeFrontier,++e.doc.highlightFrontier))}return t.styles}function $e(e,t,r){var n=e.doc,i=e.display;if(!n.mode.startState)return new us(n,!0,t);var o=rt(e,t,r),l=o>n.first&&M(n,o-1).stateAfter,s=l?us.fromSaved(n,l,o):new us(n,Xe(n.mode),o);return n.iter(o,t,function(r){qe(e,r.text,s);var n=s.line;r.stateAfter=n==t-1||n%5==0||n>=i.viewFrom&&n<i.viewTo?s.save():null,s.nextLine()}),r&&(n.modeFrontier=s.line),s}function qe(e,t,r,n){var i=e.doc.mode,o=new ss(t,e.options.tabSize,r);for(o.start=o.pos=n||0,""==t&&Ze(i,r.state);!o.eol();)Qe(i,o,r.state),o.start=o.pos}function Ze(e,t){if(e.blankLine)return e.blankLine(t);if(e.innerMode){var r=je(e,t);return r.mode.blankLine?r.mode.blankLine(r.state):void 0}}function Qe(e,t,r,n){for(var i=0;i<10;i++){n&&(n[0]=je(e,r).mode);var o=e.token(t,r);if(t.pos>t.start)return o}throw new Error("Mode "+e.name+" failed to advance stream.")}function Je(e,t,r,n){var i,o,l=e.doc,s=l.mode,a=M(l,(t=U(l,t)).line),u=$e(e,t.line,r),c=new ss(a.text,e.options.tabSize,u);for(n&&(o=[]);(n||c.pos<t.ch)&&!c.eol();)c.start=c.pos,i=Qe(s,c,u.state),n&&o.push(new cs(c,i,Ke(l.mode,u.state)));return n?o:new cs(c,i,u.state)}function et(e,t){if(e)for(;;){var r=e.match(/(?:^|\s+)line-(background-)?(\S+)/);if(!r)break;e=e.slice(0,r.index)+e.slice(r.index+r[0].length);var n=r[1]?"bgClass":"textClass";null==t[n]?t[n]=r[2]:new RegExp("(?:^|s)"+r[2]+"(?:$|s)").test(t[n])||(t[n]+=" "+r[2])}return e}function tt(e,t,r,n,i,o,l){var s=r.flattenSpans;null==s&&(s=e.options.flattenSpans);var a,u=0,c=null,f=new ss(t,e.options.tabSize,n),h=e.options.addModeClass&&[null];for(""==t&&et(Ze(r,n.state),o);!f.eol();){if(f.pos>e.options.maxHighlightLength?(s=!1,l&&qe(e,t,n,f.pos),f.pos=t.length,a=null):a=et(Qe(r,f,n.state,h),o),h){var d=h[0].name;d&&(a="m-"+(a?d+" "+a:d))}if(!s||c!=a){for(;u<f.start;)i(u=Math.min(f.start,u+5e3),c);c=a}f.start=f.pos}for(;u<f.pos;){var p=Math.min(f.pos,u+5e3);i(p,c),u=p}}function rt(e,t,r){for(var n,i,o=e.doc,l=r?-1:t-(e.doc.mode.innerMode?1e3:100),s=t;s>l;--s){if(s<=o.first)return o.first;var a=M(o,s-1),u=a.stateAfter;if(u&&(!r||s+(u instanceof as?u.lookAhead:0)<=o.modeFrontier))return s;var c=f(a.text,null,e.options.tabSize);(null==i||n>c)&&(i=s-1,n=c)}return i}function nt(e,t){if(e.modeFrontier=Math.min(e.modeFrontier,t),!(e.highlightFrontier<t-10)){for(var r=e.first,n=t-1;n>r;n--){var i=M(e,n).stateAfter;if(i&&(!(i instanceof as)||n+i.lookAhead<t)){r=n+1;break}}e.highlightFrontier=Math.min(e.highlightFrontier,r)}}function it(e,t,r,n){e.text=t,e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null),null!=e.order&&(e.order=null),re(e),ne(e,r);var i=n?n(e):1;i!=e.height&&A(e,i)}function ot(e){e.parent=null,re(e)}function lt(e,t){if(!e||/^\s*$/.test(e))return null;var r=t.addModeClass?ps:ds;return r[e]||(r[e]=e.replace(/\S+/g,"cm-$&"))}function st(e,t){var r=i("span",null,null,ml?"padding-right: .1px":null),n={pre:i("pre",[r],"CodeMirror-line"),content:r,col:0,pos:0,cm:e,trailingSpace:!1,splitSpaces:(gl||ml)&&e.getOption("lineWrapping")};t.measure={};for(var o=0;o<=(t.rest?t.rest.length:0);o++){var l=o?t.rest[o-1]:t.line,s=void 0;n.pos=0,n.addToken=ut,ze(e.display.measure)&&(s=Se(l,e.doc.direction))&&(n.addToken=ft(n.addToken,s)),n.map=[],dt(l,n,_e(e,l,t!=e.display.externalMeasured&&W(l))),l.styleClasses&&(l.styleClasses.bgClass&&(n.bgClass=a(l.styleClasses.bgClass,n.bgClass||"")),l.styleClasses.textClass&&(n.textClass=a(l.styleClasses.textClass,n.textClass||""))),0==n.map.length&&n.map.push(0,0,n.content.appendChild(Ie(e.display.measure))),0==o?(t.measure.map=n.map,t.measure.cache={}):((t.measure.maps||(t.measure.maps=[])).push(n.map),(t.measure.caches||(t.measure.caches=[])).push({}))}if(ml){var u=n.content.lastChild;(/\bcm-tab\b/.test(u.className)||u.querySelector&&u.querySelector(".cm-tab"))&&(n.content.className="cm-tab-wrap-hack")}return Te(e,"renderLine",e,t.line,n.pre),n.pre.className&&(n.textClass=a(n.pre.className,n.textClass||"")),n}function at(e){var t=n("span","•","cm-invalidchar");return t.title="\\u"+e.charCodeAt(0).toString(16),t.setAttribute("aria-label",t.title),t}function ut(e,t,r,i,o,l,s){if(t){var a,u=e.splitSpaces?ct(t,e.trailingSpace):t,c=e.cm.state.specialChars,f=!1;if(c.test(t)){a=document.createDocumentFragment();for(var h=0;;){c.lastIndex=h;var d=c.exec(t),g=d?d.index-h:t.length-h;if(g){var v=document.createTextNode(u.slice(h,h+g));gl&&vl<9?a.appendChild(n("span",[v])):a.appendChild(v),e.map.push(e.pos,e.pos+g,v),e.col+=g,e.pos+=g}if(!d)break;h+=g+1;var m=void 0;if("\t"==d[0]){var y=e.cm.options.tabSize,b=y-e.col%y;(m=a.appendChild(n("span",p(b),"cm-tab"))).setAttribute("role","presentation"),m.setAttribute("cm-text","\t"),e.col+=b}else"\r"==d[0]||"\n"==d[0]?((m=a.appendChild(n("span","\r"==d[0]?"␍":"␤","cm-invalidchar"))).setAttribute("cm-text",d[0]),e.col+=1):((m=e.cm.options.specialCharPlaceholder(d[0])).setAttribute("cm-text",d[0]),gl&&vl<9?a.appendChild(n("span",[m])):a.appendChild(m),e.col+=1);e.map.push(e.pos,e.pos+1,m),e.pos++}}else e.col+=t.length,a=document.createTextNode(u),e.map.push(e.pos,e.pos+t.length,a),gl&&vl<9&&(f=!0),e.pos+=t.length;if(e.trailingSpace=32==u.charCodeAt(t.length-1),r||i||o||f||s){var w=r||"";i&&(w+=i),o&&(w+=o);var x=n("span",[a],w,s);return l&&(x.title=l),e.content.appendChild(x)}e.content.appendChild(a)}}function ct(e,t){if(e.length>1&&!/  /.test(e))return e;for(var r=t,n="",i=0;i<e.length;i++){var o=e.charAt(i);" "!=o||!r||i!=e.length-1&&32!=e.charCodeAt(i+1)||(o=" "),n+=o,r=" "==o}return n}function ft(e,t){return function(r,n,i,o,l,s,a){i=i?i+" cm-force-border":"cm-force-border";for(var u=r.pos,c=u+n.length;;){for(var f=void 0,h=0;h<t.length&&!((f=t[h]).to>u&&f.from<=u);h++);if(f.to>=c)return e(r,n,i,o,l,s,a);e(r,n.slice(0,f.to-u),i,o,null,s,a),o=null,n=n.slice(f.to-u),u=f.to}}}function ht(e,t,r,n){var i=!n&&r.widgetNode;i&&e.map.push(e.pos,e.pos+t,i),!n&&e.cm.display.input.needsContentAttribute&&(i||(i=e.content.appendChild(document.createElement("span"))),i.setAttribute("cm-marker",r.id)),i&&(e.cm.display.input.setUneditable(i),e.content.appendChild(i)),e.pos+=t,e.trailingSpace=!1}function dt(e,t,r){var n=e.markedSpans,i=e.text,o=0;if(n)for(var l,s,a,u,c,f,h,d=i.length,p=0,g=1,v="",m=0;;){if(m==p){a=u=c=f=s="",h=null,m=1/0;for(var y=[],b=void 0,w=0;w<n.length;++w){var x=n[w],C=x.marker;"bookmark"==C.type&&x.from==p&&C.widgetNode?y.push(C):x.from<=p&&(null==x.to||x.to>p||C.collapsed&&x.to==p&&x.from==p)?(null!=x.to&&x.to!=p&&m>x.to&&(m=x.to,u=""),C.className&&(a+=" "+C.className),C.css&&(s=(s?s+";":"")+C.css),C.startStyle&&x.from==p&&(c+=" "+C.startStyle),C.endStyle&&x.to==m&&(b||(b=[])).push(C.endStyle,x.to),C.title&&!f&&(f=C.title),C.collapsed&&(!h||le(h.marker,C)<0)&&(h=x)):x.from>p&&m>x.from&&(m=x.from)}if(b)for(var S=0;S<b.length;S+=2)b[S+1]==m&&(u+=" "+b[S]);if(!h||h.from==p)for(var L=0;L<y.length;++L)ht(t,0,y[L]);if(h&&(h.from||0)==p){if(ht(t,(null==h.to?d+1:h.to)-p,h.marker,null==h.from),null==h.to)return;h.to==p&&(h=!1)}}if(p>=d)break;for(var k=Math.min(d,m);;){if(v){var T=p+v.length;if(!h){var M=T>k?v.slice(0,k-p):v;t.addToken(t,M,l?l+a:a,c,p+M.length==m?u:"",f,s)}if(T>=k){v=v.slice(k-p),p=k;break}p=T,c=""}v=i.slice(o,o=r[g++]),l=lt(r[g++],t.cm.options)}}else for(var N=1;N<r.length;N+=2)t.addToken(t,i.slice(o,o=r[N]),lt(r[N+1],t.cm.options))}function pt(e,t,r){this.line=t,this.rest=de(t),this.size=this.rest?W(g(this.rest))-r+1:1,this.node=this.text=null,this.hidden=ve(e,t)}function gt(e,t,r){for(var n,i=[],o=t;o<r;o=n){var l=new pt(e.doc,M(e.doc,o),o);n=o+l.size,i.push(l)}return i}function vt(e){gs?gs.ops.push(e):e.ownsGroup=gs={ops:[e],delayedCallbacks:[]}}function mt(e){var t=e.delayedCallbacks,r=0;do{for(;r<t.length;r++)t[r].call(null);for(var n=0;n<e.ops.length;n++){var i=e.ops[n];if(i.cursorActivityHandlers)for(;i.cursorActivityCalled<i.cursorActivityHandlers.length;)i.cursorActivityHandlers[i.cursorActivityCalled++].call(null,i.cm)}}while(r<t.length)}function yt(e,t){var r=e.ownsGroup;if(r)try{mt(r)}finally{gs=null,t(r)}}function bt(e,t){var r=Le(e,t);if(r.length){var n,i=Array.prototype.slice.call(arguments,2);gs?n=gs.delayedCallbacks:vs?n=vs:(n=vs=[],setTimeout(wt,0));for(var o=0;o<r.length;++o)!function(e){n.push(function(){return r[e].apply(null,i)})}(o)}}function wt(){var e=vs;vs=null;for(var t=0;t<e.length;++t)e[t]()}function xt(e,t,r,n){for(var i=0;i<t.changes.length;i++){var o=t.changes[i];"text"==o?kt(e,t):"gutter"==o?Mt(e,t,r,n):"class"==o?Tt(e,t):"widget"==o&&Nt(e,t,n)}t.changes=null}function Ct(e){return e.node==e.text&&(e.node=n("div",null,null,"position: relative"),e.text.parentNode&&e.text.parentNode.replaceChild(e.node,e.text),e.node.appendChild(e.text),gl&&vl<8&&(e.node.style.zIndex=2)),e.node}function St(e,t){var r=t.bgClass?t.bgClass+" "+(t.line.bgClass||""):t.line.bgClass;if(r&&(r+=" CodeMirror-linebackground"),t.background)r?t.background.className=r:(t.background.parentNode.removeChild(t.background),t.background=null);else if(r){var i=Ct(t);t.background=i.insertBefore(n("div",null,r),i.firstChild),e.display.input.setUneditable(t.background)}}function Lt(e,t){var r=e.display.externalMeasured;return r&&r.line==t.line?(e.display.externalMeasured=null,t.measure=r.measure,r.built):st(e,t)}function kt(e,t){var r=t.text.className,n=Lt(e,t);t.text==t.node&&(t.node=n.pre),t.text.parentNode.replaceChild(n.pre,t.text),t.text=n.pre,n.bgClass!=t.bgClass||n.textClass!=t.textClass?(t.bgClass=n.bgClass,t.textClass=n.textClass,Tt(e,t)):r&&(t.text.className=r)}function Tt(e,t){St(e,t),t.line.wrapClass?Ct(t).className=t.line.wrapClass:t.node!=t.text&&(t.node.className="");var r=t.textClass?t.textClass+" "+(t.line.textClass||""):t.line.textClass;t.text.className=r||""}function Mt(e,t,r,i){if(t.gutter&&(t.node.removeChild(t.gutter),t.gutter=null),t.gutterBackground&&(t.node.removeChild(t.gutterBackground),t.gutterBackground=null),t.line.gutterClass){var o=Ct(t);t.gutterBackground=n("div",null,"CodeMirror-gutter-background "+t.line.gutterClass,"left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px; width: "+i.gutterTotalWidth+"px"),e.display.input.setUneditable(t.gutterBackground),o.insertBefore(t.gutterBackground,t.text)}var l=t.line.gutterMarkers;if(e.options.lineNumbers||l){var s=Ct(t),a=t.gutter=n("div",null,"CodeMirror-gutter-wrapper","left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px");if(e.display.input.setUneditable(a),s.insertBefore(a,t.text),t.line.gutterClass&&(a.className+=" "+t.line.gutterClass),!e.options.lineNumbers||l&&l["CodeMirror-linenumbers"]||(t.lineNumber=a.appendChild(n("div",F(e.options,r),"CodeMirror-linenumber CodeMirror-gutter-elt","left: "+i.gutterLeft["CodeMirror-linenumbers"]+"px; width: "+e.display.lineNumInnerWidth+"px"))),l)for(var u=0;u<e.options.gutters.length;++u){var c=e.options.gutters[u],f=l.hasOwnProperty(c)&&l[c];f&&a.appendChild(n("div",[f],"CodeMirror-gutter-elt","left: "+i.gutterLeft[c]+"px; width: "+i.gutterWidth[c]+"px"))}}}function Nt(e,t,r){t.alignable&&(t.alignable=null);for(var n=t.node.firstChild,i=void 0;n;n=i)i=n.nextSibling,"CodeMirror-linewidget"==n.className&&t.node.removeChild(n);At(e,t,r)}function Ot(e,t,r,n){var i=Lt(e,t);return t.text=t.node=i.pre,i.bgClass&&(t.bgClass=i.bgClass),i.textClass&&(t.textClass=i.textClass),Tt(e,t),Mt(e,t,r,n),At(e,t,n),t.node}function At(e,t,r){if(Wt(e,t.line,t,r,!0),t.rest)for(var n=0;n<t.rest.length;n++)Wt(e,t.rest[n],t,r,!1)}function Wt(e,t,r,i,o){if(t.widgets)for(var l=Ct(r),s=0,a=t.widgets;s<a.length;++s){var u=a[s],c=n("div",[u.node],"CodeMirror-linewidget");u.handleMouseEvents||c.setAttribute("cm-ignore-events","true"),Dt(u,c,r,i),e.display.input.setUneditable(c),o&&u.above?l.insertBefore(c,r.gutter||r.text):l.appendChild(c),bt(u,"redraw")}}function Dt(e,t,r,n){if(e.noHScroll){(r.alignable||(r.alignable=[])).push(t);var i=n.wrapperWidth;t.style.left=n.fixedPos+"px",e.coverGutter||(i-=n.gutterTotalWidth,t.style.paddingLeft=n.gutterTotalWidth+"px"),t.style.width=i+"px"}e.coverGutter&&(t.style.zIndex=5,t.style.position="relative",e.noHScroll||(t.style.marginLeft=-n.gutterTotalWidth+"px"))}function Ht(e){if(null!=e.height)return e.height;var t=e.doc.cm;if(!t)return 0;if(!o(document.body,e.node)){var i="position: relative;";e.coverGutter&&(i+="margin-left: -"+t.display.gutters.offsetWidth+"px;"),e.noHScroll&&(i+="width: "+t.display.wrapper.clientWidth+"px;"),r(t.display.measure,n("div",[e.node],null,i))}return e.height=e.node.parentNode.offsetHeight}function Ft(e,t){for(var r=Ee(t);r!=e.wrapper;r=r.parentNode)if(!r||1==r.nodeType&&"true"==r.getAttribute("cm-ignore-events")||r.parentNode==e.sizer&&r!=e.mover)return!0}function Et(e){return e.lineSpace.offsetTop}function Pt(e){return e.mover.offsetHeight-e.lineSpace.offsetHeight}function It(e){if(e.cachedPaddingH)return e.cachedPaddingH;var t=r(e.measure,n("pre","x")),i=window.getComputedStyle?window.getComputedStyle(t):t.currentStyle,o={left:parseInt(i.paddingLeft),right:parseInt(i.paddingRight)};return isNaN(o.left)||isNaN(o.right)||(e.cachedPaddingH=o),o}function zt(e){return Rl-e.display.nativeBarWidth}function Rt(e){return e.display.scroller.clientWidth-zt(e)-e.display.barWidth}function Bt(e){return e.display.scroller.clientHeight-zt(e)-e.display.barHeight}function Gt(e,t,r){var n=e.options.lineWrapping,i=n&&Rt(e);if(!t.measure.heights||n&&t.measure.width!=i){var o=t.measure.heights=[];if(n){t.measure.width=i;for(var l=t.text.firstChild.getClientRects(),s=0;s<l.length-1;s++){var a=l[s],u=l[s+1];Math.abs(a.bottom-u.bottom)>2&&o.push((a.bottom+u.top)/2-r.top)}}o.push(r.bottom-r.top)}}function Ut(e,t,r){if(e.line==t)return{map:e.measure.map,cache:e.measure.cache};for(var n=0;n<e.rest.length;n++)if(e.rest[n]==t)return{map:e.measure.maps[n],cache:e.measure.caches[n]};for(var i=0;i<e.rest.length;i++)if(W(e.rest[i])>r)return{map:e.measure.maps[i],cache:e.measure.caches[i],before:!0}}function Vt(e,t){var n=W(t=fe(t)),i=e.display.externalMeasured=new pt(e.doc,t,n);i.lineN=n;var o=i.built=st(e,i);return i.text=o.pre,r(e.display.lineMeasure,o.pre),i}function Kt(e,t,r,n){return Yt(e,Xt(e,t),r,n)}function jt(e,t){if(t>=e.display.viewFrom&&t<e.display.viewTo)return e.display.view[Lr(e,t)];var r=e.display.externalMeasured;return r&&t>=r.lineN&&t<r.lineN+r.size?r:void 0}function Xt(e,t){var r=W(t),n=jt(e,r);n&&!n.text?n=null:n&&n.changes&&(xt(e,n,r,br(e)),e.curOp.forceUpdate=!0),n||(n=Vt(e,t));var i=Ut(n,t,r);return{line:t,view:n,rect:null,map:i.map,cache:i.cache,before:i.before,hasHeights:!1}}function Yt(e,t,r,n,i){t.before&&(r=-1);var o,l=r+(n||"");return t.cache.hasOwnProperty(l)?o=t.cache[l]:(t.rect||(t.rect=t.view.text.getBoundingClientRect()),t.hasHeights||(Gt(e,t.view,t.rect),t.hasHeights=!0),(o=qt(e,t,r,n)).bogus||(t.cache[l]=o)),{left:o.left,right:o.right,top:i?o.rtop:o.top,bottom:i?o.rbottom:o.bottom}}function _t(e,t,r){for(var n,i,o,l,s,a,u=0;u<e.length;u+=3)if(s=e[u],a=e[u+1],t<s?(i=0,o=1,l="left"):t<a?o=(i=t-s)+1:(u==e.length-3||t==a&&e[u+3]>t)&&(i=(o=a-s)-1,t>=a&&(l="right")),null!=i){if(n=e[u+2],s==a&&r==(n.insertLeft?"left":"right")&&(l=r),"left"==r&&0==i)for(;u&&e[u-2]==e[u-3]&&e[u-1].insertLeft;)n=e[2+(u-=3)],l="left";if("right"==r&&i==a-s)for(;u<e.length-3&&e[u+3]==e[u+4]&&!e[u+5].insertLeft;)n=e[(u+=3)+2],l="right";break}return{node:n,start:i,end:o,collapse:l,coverStart:s,coverEnd:a}}function $t(e,t){var r=ms;if("left"==t)for(var n=0;n<e.length&&(r=e[n]).left==r.right;n++);else for(var i=e.length-1;i>=0&&(r=e[i]).left==r.right;i--);return r}function qt(e,t,r,n){var i,o=_t(t.map,r,n),l=o.node,s=o.start,a=o.end,u=o.collapse;if(3==l.nodeType){for(var c=0;c<4;c++){for(;s&&S(t.line.text.charAt(o.coverStart+s));)--s;for(;o.coverStart+a<o.coverEnd&&S(t.line.text.charAt(o.coverStart+a));)++a;if((i=gl&&vl<9&&0==s&&a==o.coverEnd-o.coverStart?l.parentNode.getBoundingClientRect():$t(Wl(l,s,a).getClientRects(),n)).left||i.right||0==s)break;a=s,s-=1,u="right"}gl&&vl<11&&(i=Zt(e.display.measure,i))}else{s>0&&(u=n="right");var f;i=e.options.lineWrapping&&(f=l.getClientRects()).length>1?f["right"==n?f.length-1:0]:l.getBoundingClientRect()}if(gl&&vl<9&&!s&&(!i||!i.left&&!i.right)){var h=l.parentNode.getClientRects()[0];i=h?{left:h.left,right:h.left+yr(e.display),top:h.top,bottom:h.bottom}:ms}for(var d=i.top-t.rect.top,p=i.bottom-t.rect.top,g=(d+p)/2,v=t.view.measure.heights,m=0;m<v.length-1&&!(g<v[m]);m++);var y=m?v[m-1]:0,b=v[m],w={left:("right"==u?i.right:i.left)-t.rect.left,right:("left"==u?i.left:i.right)-t.rect.left,top:y,bottom:b};return i.left||i.right||(w.bogus=!0),e.options.singleCursorHeightPerLine||(w.rtop=d,w.rbottom=p),w}function Zt(e,t){if(!window.screen||null==screen.logicalXDPI||screen.logicalXDPI==screen.deviceXDPI||!Re(e))return t;var r=screen.logicalXDPI/screen.deviceXDPI,n=screen.logicalYDPI/screen.deviceYDPI;return{left:t.left*r,right:t.right*r,top:t.top*n,bottom:t.bottom*n}}function Qt(e){if(e.measure&&(e.measure.cache={},e.measure.heights=null,e.rest))for(var t=0;t<e.rest.length;t++)e.measure.caches[t]={}}function Jt(e){e.display.externalMeasure=null,t(e.display.lineMeasure);for(var r=0;r<e.display.view.length;r++)Qt(e.display.view[r])}function er(e){Jt(e),e.display.cachedCharWidth=e.display.cachedTextHeight=e.display.cachedPaddingH=null,e.options.lineWrapping||(e.display.maxLineChanged=!0),e.display.lineNumChars=null}function tr(){return bl&&kl?-(document.body.getBoundingClientRect().left-parseInt(getComputedStyle(document.body).marginLeft)):window.pageXOffset||(document.documentElement||document.body).scrollLeft}function rr(){return bl&&kl?-(document.body.getBoundingClientRect().top-parseInt(getComputedStyle(document.body).marginTop)):window.pageYOffset||(document.documentElement||document.body).scrollTop}function nr(e){var t=0;if(e.widgets)for(var r=0;r<e.widgets.length;++r)e.widgets[r].above&&(t+=Ht(e.widgets[r]));return t}function ir(e,t,r,n,i){if(!i){var o=nr(t);r.top+=o,r.bottom+=o}if("line"==n)return r;n||(n="local");var l=ye(t);if("local"==n?l+=Et(e.display):l-=e.display.viewOffset,"page"==n||"window"==n){var s=e.display.lineSpace.getBoundingClientRect();l+=s.top+("window"==n?0:rr());var a=s.left+("window"==n?0:tr());r.left+=a,r.right+=a}return r.top+=l,r.bottom+=l,r}function or(e,t,r){if("div"==r)return t;var n=t.left,i=t.top;if("page"==r)n-=tr(),i-=rr();else if("local"==r||!r){var o=e.display.sizer.getBoundingClientRect();n+=o.left,i+=o.top}var l=e.display.lineSpace.getBoundingClientRect();return{left:n-l.left,top:i-l.top}}function lr(e,t,r,n,i){return n||(n=M(e.doc,t.line)),ir(e,n,Kt(e,n,t.ch,i),r)}function sr(e,t,r,n,i,o){function l(t,l){var s=Yt(e,i,t,l?"right":"left",o);return l?s.left=s.right:s.right=s.left,ir(e,n,s,r)}function s(e,t,r){var n=1==a[t].level;return l(r?e-1:e,n!=r)}n=n||M(e.doc,t.line),i||(i=Xt(e,n));var a=Se(n,e.doc.direction),u=t.ch,c=t.sticky;if(u>=n.text.length?(u=n.text.length,c="before"):u<=0&&(u=0,c="after"),!a)return l("before"==c?u-1:u,"before"==c);var f=Ce(a,u,c),h=$l,d=s(u,f,"before"==c);return null!=h&&(d.other=s(u,h,"before"!=c)),d}function ar(e,t){var r=0;t=U(e.doc,t),e.options.lineWrapping||(r=yr(e.display)*t.ch);var n=M(e.doc,t.line),i=ye(n)+Et(e.display);return{left:r,right:r,top:i,bottom:i+n.height}}function ur(e,t,r,n,i){var o=E(e,t,r);return o.xRel=i,n&&(o.outside=!0),o}function cr(e,t,r){var n=e.doc;if((r+=e.display.viewOffset)<0)return ur(n.first,0,null,!0,-1);var i=D(n,r),o=n.first+n.size-1;if(i>o)return ur(n.first+n.size-1,M(n,o).text.length,null,!0,1);t<0&&(t=0);for(var l=M(n,i);;){var s=pr(e,l,i,t,r),a=ue(l),u=a&&a.find(0,!0);if(!a||!(s.ch>u.from.ch||s.ch==u.from.ch&&s.xRel>0))return s;i=W(l=u.to.line)}}function fr(e,t,r,n){n-=nr(t);var i=t.text.length,o=k(function(t){return Yt(e,r,t-1).bottom<=n},i,0);return i=k(function(t){return Yt(e,r,t).top>n},o,i),{begin:o,end:i}}function hr(e,t,r,n){return r||(r=Xt(e,t)),fr(e,t,r,ir(e,t,Yt(e,r,n),"line").top)}function dr(e,t,r,n){return!(e.bottom<=r)&&(e.top>r||(n?e.left:e.right)>t)}function pr(e,t,r,n,i){i-=ye(t);var o=Xt(e,t),l=nr(t),s=0,a=t.text.length,u=!0,c=Se(t,e.doc.direction);if(c){var f=(e.options.lineWrapping?vr:gr)(e,t,r,o,c,n,i);s=(u=1!=f.level)?f.from:f.to-1,a=u?f.to:f.from-1}var h,d,p=null,g=null,v=k(function(t){var r=Yt(e,o,t);return r.top+=l,r.bottom+=l,!!dr(r,n,i,!1)&&(r.top<=i&&r.left<=n&&(p=t,g=r),!0)},s,a),m=!1;if(g){var y=n-g.left<g.right-n,b=y==u;v=p+(b?0:1),d=b?"after":"before",h=y?g.left:g.right}else{u||v!=a&&v!=s||v++,d=0==v?"after":v==t.text.length?"before":Yt(e,o,v-(u?1:0)).bottom+l<=i==u?"after":"before";var w=sr(e,E(r,v,d),"line",t,o);h=w.left,m=i<w.top||i>=w.bottom}return v=L(t.text,v,1),ur(r,v,d,m,n-h)}function gr(e,t,r,n,i,o,l){var s=k(function(s){var a=i[s],u=1!=a.level;return dr(sr(e,E(r,u?a.to:a.from,u?"before":"after"),"line",t,n),o,l,!0)},0,i.length-1),a=i[s];if(s>0){var u=1!=a.level,c=sr(e,E(r,u?a.from:a.to,u?"after":"before"),"line",t,n);dr(c,o,l,!0)&&c.top>l&&(a=i[s-1])}return a}function vr(e,t,r,n,i,o,l){for(var s=fr(e,t,n,l),a=s.begin,u=s.end,c=null,f=null,h=0;h<i.length;h++){var d=i[h];if(!(d.from>=u||d.to<=a)){var p=Yt(e,n,1!=d.level?Math.min(u,d.to)-1:Math.max(a,d.from)).right,g=p<o?o-p+1e9:p-o;(!c||f>g)&&(c=d,f=g)}}return c||(c=i[i.length-1]),c.from<a&&(c={from:a,to:c.to,level:c.level}),c.to>u&&(c={from:c.from,to:u,level:c.level}),c}function mr(e){if(null!=e.cachedTextHeight)return e.cachedTextHeight;if(null==hs){hs=n("pre");for(var i=0;i<49;++i)hs.appendChild(document.createTextNode("x")),hs.appendChild(n("br"));hs.appendChild(document.createTextNode("x"))}r(e.measure,hs);var o=hs.offsetHeight/50;return o>3&&(e.cachedTextHeight=o),t(e.measure),o||1}function yr(e){if(null!=e.cachedCharWidth)return e.cachedCharWidth;var t=n("span","xxxxxxxxxx"),i=n("pre",[t]);r(e.measure,i);var o=t.getBoundingClientRect(),l=(o.right-o.left)/10;return l>2&&(e.cachedCharWidth=l),l||10}function br(e){for(var t=e.display,r={},n={},i=t.gutters.clientLeft,o=t.gutters.firstChild,l=0;o;o=o.nextSibling,++l)r[e.options.gutters[l]]=o.offsetLeft+o.clientLeft+i,n[e.options.gutters[l]]=o.clientWidth;return{fixedPos:wr(t),gutterTotalWidth:t.gutters.offsetWidth,gutterLeft:r,gutterWidth:n,wrapperWidth:t.wrapper.clientWidth}}function wr(e){return e.scroller.getBoundingClientRect().left-e.sizer.getBoundingClientRect().left}function xr(e){var t=mr(e.display),r=e.options.lineWrapping,n=r&&Math.max(5,e.display.scroller.clientWidth/yr(e.display)-3);return function(i){if(ve(e.doc,i))return 0;var o=0;if(i.widgets)for(var l=0;l<i.widgets.length;l++)i.widgets[l].height&&(o+=i.widgets[l].height);return r?o+(Math.ceil(i.text.length/n)||1)*t:o+t}}function Cr(e){var t=e.doc,r=xr(e);t.iter(function(e){var t=r(e);t!=e.height&&A(e,t)})}function Sr(e,t,r,n){var i=e.display;if(!r&&"true"==Ee(t).getAttribute("cm-not-content"))return null;var o,l,s=i.lineSpace.getBoundingClientRect();try{o=t.clientX-s.left,l=t.clientY-s.top}catch(t){return null}var a,u=cr(e,o,l);if(n&&1==u.xRel&&(a=M(e.doc,u.line).text).length==u.ch){var c=f(a,a.length,e.options.tabSize)-a.length;u=E(u.line,Math.max(0,Math.round((o-It(e.display).left)/yr(e.display))-c))}return u}function Lr(e,t){if(t>=e.display.viewTo)return null;if((t-=e.display.viewFrom)<0)return null;for(var r=e.display.view,n=0;n<r.length;n++)if((t-=r[n].size)<0)return n}function kr(e){e.display.input.showSelection(e.display.input.prepareSelection())}function Tr(e,t){void 0===t&&(t=!0);for(var r=e.doc,n={},i=n.cursors=document.createDocumentFragment(),o=n.selection=document.createDocumentFragment(),l=0;l<r.sel.ranges.length;l++)if(t||l!=r.sel.primIndex){var s=r.sel.ranges[l];if(!(s.from().line>=e.display.viewTo||s.to().line<e.display.viewFrom)){var a=s.empty();(a||e.options.showCursorWhenSelecting)&&Mr(e,s.head,i),a||Or(e,s,o)}}return n}function Mr(e,t,r){var i=sr(e,t,"div",null,null,!e.options.singleCursorHeightPerLine),o=r.appendChild(n("div"," ","CodeMirror-cursor"));if(o.style.left=i.left+"px",o.style.top=i.top+"px",o.style.height=Math.max(0,i.bottom-i.top)*e.options.cursorHeight+"px",i.other){var l=r.appendChild(n("div"," ","CodeMirror-cursor CodeMirror-secondarycursor"));l.style.display="",l.style.left=i.other.left+"px",l.style.top=i.other.top+"px",l.style.height=.85*(i.other.bottom-i.other.top)+"px"}}function Nr(e,t){return e.top-t.top||e.left-t.left}function Or(e,t,r){function i(e,t,r,i){t<0&&(t=0),t=Math.round(t),i=Math.round(i),a.appendChild(n("div",null,"CodeMirror-selected","position: absolute; left: "+e+"px;\n                             top: "+t+"px; width: "+(null==r?f-e:r)+"px;\n                             height: "+(i-t)+"px"))}function o(t,r,n){function o(r,n){return lr(e,E(t,r),"div",u,n)}var l,a,u=M(s,t),h=u.text.length,d=Se(u,s.direction);return xe(d,r||0,null==n?h:n,function(t,s,p,g){var v=o(t,"ltr"==p?"left":"right"),m=o(s-1,"ltr"==p?"right":"left");if("ltr"==p){var y=null==r&&0==t?c:v.left,b=null==n&&s==h?f:m.right;m.top-v.top<=3?i(y,m.top,b-y,m.bottom):(i(y,v.top,null,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top),i(c,m.top,m.right,m.bottom))}else if(t<s){var w=null==r&&0==t?f:v.right,x=null==n&&s==h?c:m.left;if(m.top-v.top<=3)i(x,m.top,w-x,m.bottom);else{var C=c;if(g){var S=hr(e,u,null,t).end;C=o(S-(/\s/.test(u.text.charAt(S-1))?2:1),"left").left}i(C,v.top,w-C,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top);var L=null;d.length,L=o(hr(e,u,null,s).begin,"right").right-x,i(x,m.top,L,m.bottom)}}(!l||Nr(v,l)<0)&&(l=v),Nr(m,l)<0&&(l=m),(!a||Nr(v,a)<0)&&(a=v),Nr(m,a)<0&&(a=m)}),{start:l,end:a}}var l=e.display,s=e.doc,a=document.createDocumentFragment(),u=It(e.display),c=u.left,f=Math.max(l.sizerWidth,Rt(e)-l.sizer.offsetLeft)-u.right,h=t.from(),d=t.to();if(h.line==d.line)o(h.line,h.ch,d.ch);else{var p=M(s,h.line),g=M(s,d.line),v=fe(p)==fe(g),m=o(h.line,h.ch,v?p.text.length+1:null).end,y=o(d.line,v?0:null,d.ch).start;v&&(m.top<y.top-2?(i(m.right,m.top,null,m.bottom),i(c,y.top,y.left,y.bottom)):i(m.right,m.top,y.left-m.right,m.bottom)),m.bottom<y.top&&i(c,m.bottom,null,y.top)}r.appendChild(a)}function Ar(e){if(e.state.focused){var t=e.display;clearInterval(t.blinker);var r=!0;t.cursorDiv.style.visibility="",e.options.cursorBlinkRate>0?t.blinker=setInterval(function(){return t.cursorDiv.style.visibility=(r=!r)?"":"hidden"},e.options.cursorBlinkRate):e.options.cursorBlinkRate<0&&(t.cursorDiv.style.visibility="hidden")}}function Wr(e){e.state.focused||(e.display.input.focus(),Hr(e))}function Dr(e){e.state.delayingBlurEvent=!0,setTimeout(function(){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1,Fr(e))},100)}function Hr(e,t){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1),"nocursor"!=e.options.readOnly&&(e.state.focused||(Te(e,"focus",e,t),e.state.focused=!0,s(e.display.wrapper,"CodeMirror-focused"),e.curOp||e.display.selForContextMenu==e.doc.sel||(e.display.input.reset(),ml&&setTimeout(function(){return e.display.input.reset(!0)},20)),e.display.input.receivedFocus()),Ar(e))}function Fr(e,t){e.state.delayingBlurEvent||(e.state.focused&&(Te(e,"blur",e,t),e.state.focused=!1,Fl(e.display.wrapper,"CodeMirror-focused")),clearInterval(e.display.blinker),setTimeout(function(){e.state.focused||(e.display.shift=!1)},150))}function Er(e){for(var t=e.display,r=t.lineDiv.offsetTop,n=0;n<t.view.length;n++){var i=t.view[n],o=void 0;if(!i.hidden){if(gl&&vl<8){var l=i.node.offsetTop+i.node.offsetHeight;o=l-r,r=l}else{var s=i.node.getBoundingClientRect();o=s.bottom-s.top}var a=i.line.height-o;if(o<2&&(o=mr(t)),(a>.005||a<-.005)&&(A(i.line,o),Pr(i.line),i.rest))for(var u=0;u<i.rest.length;u++)Pr(i.rest[u])}}}function Pr(e){if(e.widgets)for(var t=0;t<e.widgets.length;++t)e.widgets[t].height=e.widgets[t].node.parentNode.offsetHeight}function Ir(e,t,r){var n=r&&null!=r.top?Math.max(0,r.top):e.scroller.scrollTop;n=Math.floor(n-Et(e));var i=r&&null!=r.bottom?r.bottom:n+e.wrapper.clientHeight,o=D(t,n),l=D(t,i);if(r&&r.ensure){var s=r.ensure.from.line,a=r.ensure.to.line;s<o?(o=s,l=D(t,ye(M(t,s))+e.wrapper.clientHeight)):Math.min(a,t.lastLine())>=l&&(o=D(t,ye(M(t,a))-e.wrapper.clientHeight),l=a)}return{from:o,to:Math.max(l,o+1)}}function zr(e){var t=e.display,r=t.view;if(t.alignWidgets||t.gutters.firstChild&&e.options.fixedGutter){for(var n=wr(t)-t.scroller.scrollLeft+e.doc.scrollLeft,i=t.gutters.offsetWidth,o=n+"px",l=0;l<r.length;l++)if(!r[l].hidden){e.options.fixedGutter&&(r[l].gutter&&(r[l].gutter.style.left=o),r[l].gutterBackground&&(r[l].gutterBackground.style.left=o));var s=r[l].alignable;if(s)for(var a=0;a<s.length;a++)s[a].style.left=o}e.options.fixedGutter&&(t.gutters.style.left=n+i+"px")}}function Rr(e){if(!e.options.lineNumbers)return!1;var t=e.doc,r=F(e.options,t.first+t.size-1),i=e.display;if(r.length!=i.lineNumChars){var o=i.measure.appendChild(n("div",[n("div",r)],"CodeMirror-linenumber CodeMirror-gutter-elt")),l=o.firstChild.offsetWidth,s=o.offsetWidth-l;return i.lineGutter.style.width="",i.lineNumInnerWidth=Math.max(l,i.lineGutter.offsetWidth-s)+1,i.lineNumWidth=i.lineNumInnerWidth+s,i.lineNumChars=i.lineNumInnerWidth?r.length:-1,i.lineGutter.style.width=i.lineNumWidth+"px",Wn(e),!0}return!1}function Br(e,t){if(!Me(e,"scrollCursorIntoView")){var r=e.display,i=r.sizer.getBoundingClientRect(),o=null;if(t.top+i.top<0?o=!0:t.bottom+i.top>(window.innerHeight||document.documentElement.clientHeight)&&(o=!1),null!=o&&!Sl){var l=n("div","​",null,"position: absolute;\n                         top: "+(t.top-r.viewOffset-Et(e.display))+"px;\n                         height: "+(t.bottom-t.top+zt(e)+r.barHeight)+"px;\n                         left: "+t.left+"px; width: "+Math.max(2,t.right-t.left)+"px;");e.display.lineSpace.appendChild(l),l.scrollIntoView(o),e.display.lineSpace.removeChild(l)}}}function Gr(e,t,r,n){null==n&&(n=0);var i;e.options.lineWrapping||t!=r||(r="before"==(t=t.ch?E(t.line,"before"==t.sticky?t.ch-1:t.ch,"after"):t).sticky?E(t.line,t.ch+1,"before"):t);for(var o=0;o<5;o++){var l=!1,s=sr(e,t),a=r&&r!=t?sr(e,r):s,u=Vr(e,i={left:Math.min(s.left,a.left),top:Math.min(s.top,a.top)-n,right:Math.max(s.left,a.left),bottom:Math.max(s.bottom,a.bottom)+n}),c=e.doc.scrollTop,f=e.doc.scrollLeft;if(null!=u.scrollTop&&(qr(e,u.scrollTop),Math.abs(e.doc.scrollTop-c)>1&&(l=!0)),null!=u.scrollLeft&&(Qr(e,u.scrollLeft),Math.abs(e.doc.scrollLeft-f)>1&&(l=!0)),!l)break}return i}function Ur(e,t){var r=Vr(e,t);null!=r.scrollTop&&qr(e,r.scrollTop),null!=r.scrollLeft&&Qr(e,r.scrollLeft)}function Vr(e,t){var r=e.display,n=mr(e.display);t.top<0&&(t.top=0);var i=e.curOp&&null!=e.curOp.scrollTop?e.curOp.scrollTop:r.scroller.scrollTop,o=Bt(e),l={};t.bottom-t.top>o&&(t.bottom=t.top+o);var s=e.doc.height+Pt(r),a=t.top<n,u=t.bottom>s-n;if(t.top<i)l.scrollTop=a?0:t.top;else if(t.bottom>i+o){var c=Math.min(t.top,(u?s:t.bottom)-o);c!=i&&(l.scrollTop=c)}var f=e.curOp&&null!=e.curOp.scrollLeft?e.curOp.scrollLeft:r.scroller.scrollLeft,h=Rt(e)-(e.options.fixedGutter?r.gutters.offsetWidth:0),d=t.right-t.left>h;return d&&(t.right=t.left+h),t.left<10?l.scrollLeft=0:t.left<f?l.scrollLeft=Math.max(0,t.left-(d?0:10)):t.right>h+f-3&&(l.scrollLeft=t.right+(d?0:10)-h),l}function Kr(e,t){null!=t&&(_r(e),e.curOp.scrollTop=(null==e.curOp.scrollTop?e.doc.scrollTop:e.curOp.scrollTop)+t)}function jr(e){_r(e);var t=e.getCursor();e.curOp.scrollToPos={from:t,to:t,margin:e.options.cursorScrollMargin}}function Xr(e,t,r){null==t&&null==r||_r(e),null!=t&&(e.curOp.scrollLeft=t),null!=r&&(e.curOp.scrollTop=r)}function Yr(e,t){_r(e),e.curOp.scrollToPos=t}function _r(e){var t=e.curOp.scrollToPos;t&&(e.curOp.scrollToPos=null,$r(e,ar(e,t.from),ar(e,t.to),t.margin))}function $r(e,t,r,n){var i=Vr(e,{left:Math.min(t.left,r.left),top:Math.min(t.top,r.top)-n,right:Math.max(t.right,r.right),bottom:Math.max(t.bottom,r.bottom)+n});Xr(e,i.scrollLeft,i.scrollTop)}function qr(e,t){Math.abs(e.doc.scrollTop-t)<2||(fl||On(e,{top:t}),Zr(e,t,!0),fl&&On(e),Cn(e,100))}function Zr(e,t,r){t=Math.min(e.display.scroller.scrollHeight-e.display.scroller.clientHeight,t),(e.display.scroller.scrollTop!=t||r)&&(e.doc.scrollTop=t,e.display.scrollbars.setScrollTop(t),e.display.scroller.scrollTop!=t&&(e.display.scroller.scrollTop=t))}function Qr(e,t,r,n){t=Math.min(t,e.display.scroller.scrollWidth-e.display.scroller.clientWidth),(r?t==e.doc.scrollLeft:Math.abs(e.doc.scrollLeft-t)<2)&&!n||(e.doc.scrollLeft=t,zr(e),e.display.scroller.scrollLeft!=t&&(e.display.scroller.scrollLeft=t),e.display.scrollbars.setScrollLeft(t))}function Jr(e){var t=e.display,r=t.gutters.offsetWidth,n=Math.round(e.doc.height+Pt(e.display));return{clientHeight:t.scroller.clientHeight,viewHeight:t.wrapper.clientHeight,scrollWidth:t.scroller.scrollWidth,clientWidth:t.scroller.clientWidth,viewWidth:t.wrapper.clientWidth,barLeft:e.options.fixedGutter?r:0,docHeight:n,scrollHeight:n+zt(e)+t.barHeight,nativeBarWidth:t.nativeBarWidth,gutterWidth:r}}function en(e,t){t||(t=Jr(e));var r=e.display.barWidth,n=e.display.barHeight;tn(e,t);for(var i=0;i<4&&r!=e.display.barWidth||n!=e.display.barHeight;i++)r!=e.display.barWidth&&e.options.lineWrapping&&Er(e),tn(e,Jr(e)),r=e.display.barWidth,n=e.display.barHeight}function tn(e,t){var r=e.display,n=r.scrollbars.update(t);r.sizer.style.paddingRight=(r.barWidth=n.right)+"px",r.sizer.style.paddingBottom=(r.barHeight=n.bottom)+"px",r.heightForcer.style.borderBottom=n.bottom+"px solid transparent",n.right&&n.bottom?(r.scrollbarFiller.style.display="block",r.scrollbarFiller.style.height=n.bottom+"px",r.scrollbarFiller.style.width=n.right+"px"):r.scrollbarFiller.style.display="",n.bottom&&e.options.coverGutterNextToScrollbar&&e.options.fixedGutter?(r.gutterFiller.style.display="block",r.gutterFiller.style.height=n.bottom+"px",r.gutterFiller.style.width=t.gutterWidth+"px"):r.gutterFiller.style.display=""}function rn(e){e.display.scrollbars&&(e.display.scrollbars.clear(),e.display.scrollbars.addClass&&Fl(e.display.wrapper,e.display.scrollbars.addClass)),e.display.scrollbars=new ws[e.options.scrollbarStyle](function(t){e.display.wrapper.insertBefore(t,e.display.scrollbarFiller),Ql(t,"mousedown",function(){e.state.focused&&setTimeout(function(){return e.display.input.focus()},0)}),t.setAttribute("cm-not-content","true")},function(t,r){"horizontal"==r?Qr(e,t):qr(e,t)},e),e.display.scrollbars.addClass&&s(e.display.wrapper,e.display.scrollbars.addClass)}function nn(e){e.curOp={cm:e,viewChanged:!1,startHeight:e.doc.height,forceUpdate:!1,updateInput:null,typing:!1,changeObjs:null,cursorActivityHandlers:null,cursorActivityCalled:0,selectionChanged:!1,updateMaxLine:!1,scrollLeft:null,scrollTop:null,scrollToPos:null,focus:!1,id:++xs},vt(e.curOp)}function on(e){yt(e.curOp,function(e){for(var t=0;t<e.ops.length;t++)e.ops[t].cm.curOp=null;ln(e)})}function ln(e){for(var t=e.ops,r=0;r<t.length;r++)sn(t[r]);for(var n=0;n<t.length;n++)an(t[n]);for(var i=0;i<t.length;i++)un(t[i]);for(var o=0;o<t.length;o++)cn(t[o]);for(var l=0;l<t.length;l++)fn(t[l])}function sn(e){var t=e.cm,r=t.display;Ln(t),e.updateMaxLine&&we(t),e.mustUpdate=e.viewChanged||e.forceUpdate||null!=e.scrollTop||e.scrollToPos&&(e.scrollToPos.from.line<r.viewFrom||e.scrollToPos.to.line>=r.viewTo)||r.maxLineChanged&&t.options.lineWrapping,e.update=e.mustUpdate&&new Cs(t,e.mustUpdate&&{top:e.scrollTop,ensure:e.scrollToPos},e.forceUpdate)}function an(e){e.updatedDisplay=e.mustUpdate&&Mn(e.cm,e.update)}function un(e){var t=e.cm,r=t.display;e.updatedDisplay&&Er(t),e.barMeasure=Jr(t),r.maxLineChanged&&!t.options.lineWrapping&&(e.adjustWidthTo=Kt(t,r.maxLine,r.maxLine.text.length).left+3,t.display.sizerWidth=e.adjustWidthTo,e.barMeasure.scrollWidth=Math.max(r.scroller.clientWidth,r.sizer.offsetLeft+e.adjustWidthTo+zt(t)+t.display.barWidth),e.maxScrollLeft=Math.max(0,r.sizer.offsetLeft+e.adjustWidthTo-Rt(t))),(e.updatedDisplay||e.selectionChanged)&&(e.preparedSelection=r.input.prepareSelection())}function cn(e){var t=e.cm;null!=e.adjustWidthTo&&(t.display.sizer.style.minWidth=e.adjustWidthTo+"px",e.maxScrollLeft<t.doc.scrollLeft&&Qr(t,Math.min(t.display.scroller.scrollLeft,e.maxScrollLeft),!0),t.display.maxLineChanged=!1);var r=e.focus&&e.focus==l();e.preparedSelection&&t.display.input.showSelection(e.preparedSelection,r),(e.updatedDisplay||e.startHeight!=t.doc.height)&&en(t,e.barMeasure),e.updatedDisplay&&Dn(t,e.barMeasure),e.selectionChanged&&Ar(t),t.state.focused&&e.updateInput&&t.display.input.reset(e.typing),r&&Wr(e.cm)}function fn(e){var t=e.cm,r=t.display,n=t.doc;e.updatedDisplay&&Nn(t,e.update),null==r.wheelStartX||null==e.scrollTop&&null==e.scrollLeft&&!e.scrollToPos||(r.wheelStartX=r.wheelStartY=null),null!=e.scrollTop&&Zr(t,e.scrollTop,e.forceScroll),null!=e.scrollLeft&&Qr(t,e.scrollLeft,!0,!0),e.scrollToPos&&Br(t,Gr(t,U(n,e.scrollToPos.from),U(n,e.scrollToPos.to),e.scrollToPos.margin));var i=e.maybeHiddenMarkers,o=e.maybeUnhiddenMarkers;if(i)for(var l=0;l<i.length;++l)i[l].lines.length||Te(i[l],"hide");if(o)for(var s=0;s<o.length;++s)o[s].lines.length&&Te(o[s],"unhide");r.wrapper.offsetHeight&&(n.scrollTop=t.display.scroller.scrollTop),e.changeObjs&&Te(t,"changes",t,e.changeObjs),e.update&&e.update.finish()}function hn(e,t){if(e.curOp)return t();nn(e);try{return t()}finally{on(e)}}function dn(e,t){return function(){if(e.curOp)return t.apply(e,arguments);nn(e);try{return t.apply(e,arguments)}finally{on(e)}}}function pn(e){return function(){if(this.curOp)return e.apply(this,arguments);nn(this);try{return e.apply(this,arguments)}finally{on(this)}}}function gn(e){return function(){var t=this.cm;if(!t||t.curOp)return e.apply(this,arguments);nn(t);try{return e.apply(this,arguments)}finally{on(t)}}}function vn(e,t,r,n){null==t&&(t=e.doc.first),null==r&&(r=e.doc.first+e.doc.size),n||(n=0);var i=e.display;if(n&&r<i.viewTo&&(null==i.updateLineNumbers||i.updateLineNumbers>t)&&(i.updateLineNumbers=t),e.curOp.viewChanged=!0,t>=i.viewTo)_l&&pe(e.doc,t)<i.viewTo&&yn(e);else if(r<=i.viewFrom)_l&&ge(e.doc,r+n)>i.viewFrom?yn(e):(i.viewFrom+=n,i.viewTo+=n);else if(t<=i.viewFrom&&r>=i.viewTo)yn(e);else if(t<=i.viewFrom){var o=bn(e,r,r+n,1);o?(i.view=i.view.slice(o.index),i.viewFrom=o.lineN,i.viewTo+=n):yn(e)}else if(r>=i.viewTo){var l=bn(e,t,t,-1);l?(i.view=i.view.slice(0,l.index),i.viewTo=l.lineN):yn(e)}else{var s=bn(e,t,t,-1),a=bn(e,r,r+n,1);s&&a?(i.view=i.view.slice(0,s.index).concat(gt(e,s.lineN,a.lineN)).concat(i.view.slice(a.index)),i.viewTo+=n):yn(e)}var u=i.externalMeasured;u&&(r<u.lineN?u.lineN+=n:t<u.lineN+u.size&&(i.externalMeasured=null))}function mn(e,t,r){e.curOp.viewChanged=!0;var n=e.display,i=e.display.externalMeasured;if(i&&t>=i.lineN&&t<i.lineN+i.size&&(n.externalMeasured=null),!(t<n.viewFrom||t>=n.viewTo)){var o=n.view[Lr(e,t)];if(null!=o.node){var l=o.changes||(o.changes=[]);-1==h(l,r)&&l.push(r)}}}function yn(e){e.display.viewFrom=e.display.viewTo=e.doc.first,e.display.view=[],e.display.viewOffset=0}function bn(e,t,r,n){var i,o=Lr(e,t),l=e.display.view;if(!_l||r==e.doc.first+e.doc.size)return{index:o,lineN:r};for(var s=e.display.viewFrom,a=0;a<o;a++)s+=l[a].size;if(s!=t){if(n>0){if(o==l.length-1)return null;i=s+l[o].size-t,o++}else i=s-t;t+=i,r+=i}for(;pe(e.doc,r)!=r;){if(o==(n<0?0:l.length-1))return null;r+=n*l[o-(n<0?1:0)].size,o+=n}return{index:o,lineN:r}}function wn(e,t,r){var n=e.display;0==n.view.length||t>=n.viewTo||r<=n.viewFrom?(n.view=gt(e,t,r),n.viewFrom=t):(n.viewFrom>t?n.view=gt(e,t,n.viewFrom).concat(n.view):n.viewFrom<t&&(n.view=n.view.slice(Lr(e,t))),n.viewFrom=t,n.viewTo<r?n.view=n.view.concat(gt(e,n.viewTo,r)):n.viewTo>r&&(n.view=n.view.slice(0,Lr(e,r)))),n.viewTo=r}function xn(e){for(var t=e.display.view,r=0,n=0;n<t.length;n++){var i=t[n];i.hidden||i.node&&!i.changes||++r}return r}function Cn(e,t){e.doc.highlightFrontier<e.display.viewTo&&e.state.highlight.set(t,u(Sn,e))}function Sn(e){var t=e.doc;if(!(t.highlightFrontier>=e.display.viewTo)){var r=+new Date+e.options.workTime,n=$e(e,t.highlightFrontier),i=[];t.iter(n.line,Math.min(t.first+t.size,e.display.viewTo+500),function(o){if(n.line>=e.display.viewFrom){var l=o.styles,s=o.text.length>e.options.maxHighlightLength?Ke(t.mode,n.state):null,a=Ye(e,o,n,!0);s&&(n.state=s),o.styles=a.styles;var u=o.styleClasses,c=a.classes;c?o.styleClasses=c:u&&(o.styleClasses=null);for(var f=!l||l.length!=o.styles.length||u!=c&&(!u||!c||u.bgClass!=c.bgClass||u.textClass!=c.textClass),h=0;!f&&h<l.length;++h)f=l[h]!=o.styles[h];f&&i.push(n.line),o.stateAfter=n.save(),n.nextLine()}else o.text.length<=e.options.maxHighlightLength&&qe(e,o.text,n),o.stateAfter=n.line%5==0?n.save():null,n.nextLine();if(+new Date>r)return Cn(e,e.options.workDelay),!0}),t.highlightFrontier=n.line,t.modeFrontier=Math.max(t.modeFrontier,n.line),i.length&&hn(e,function(){for(var t=0;t<i.length;t++)mn(e,i[t],"text")})}}function Ln(e){var t=e.display;!t.scrollbarsClipped&&t.scroller.offsetWidth&&(t.nativeBarWidth=t.scroller.offsetWidth-t.scroller.clientWidth,t.heightForcer.style.height=zt(e)+"px",t.sizer.style.marginBottom=-t.nativeBarWidth+"px",t.sizer.style.borderRightWidth=zt(e)+"px",t.scrollbarsClipped=!0)}function kn(e){if(e.hasFocus())return null;var t=l();if(!t||!o(e.display.lineDiv,t))return null;var r={activeElt:t};if(window.getSelection){var n=window.getSelection();n.anchorNode&&n.extend&&o(e.display.lineDiv,n.anchorNode)&&(r.anchorNode=n.anchorNode,r.anchorOffset=n.anchorOffset,r.focusNode=n.focusNode,r.focusOffset=n.focusOffset)}return r}function Tn(e){if(e&&e.activeElt&&e.activeElt!=l()&&(e.activeElt.focus(),e.anchorNode&&o(document.body,e.anchorNode)&&o(document.body,e.focusNode))){var t=window.getSelection(),r=document.createRange();r.setEnd(e.anchorNode,e.anchorOffset),r.collapse(!1),t.removeAllRanges(),t.addRange(r),t.extend(e.focusNode,e.focusOffset)}}function Mn(e,r){var n=e.display,i=e.doc;if(r.editorIsHidden)return yn(e),!1;if(!r.force&&r.visible.from>=n.viewFrom&&r.visible.to<=n.viewTo&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo)&&n.renderedView==n.view&&0==xn(e))return!1;Rr(e)&&(yn(e),r.dims=br(e));var o=i.first+i.size,l=Math.max(r.visible.from-e.options.viewportMargin,i.first),s=Math.min(o,r.visible.to+e.options.viewportMargin);n.viewFrom<l&&l-n.viewFrom<20&&(l=Math.max(i.first,n.viewFrom)),n.viewTo>s&&n.viewTo-s<20&&(s=Math.min(o,n.viewTo)),_l&&(l=pe(e.doc,l),s=ge(e.doc,s));var a=l!=n.viewFrom||s!=n.viewTo||n.lastWrapHeight!=r.wrapperHeight||n.lastWrapWidth!=r.wrapperWidth;wn(e,l,s),n.viewOffset=ye(M(e.doc,n.viewFrom)),e.display.mover.style.top=n.viewOffset+"px";var u=xn(e);if(!a&&0==u&&!r.force&&n.renderedView==n.view&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo))return!1;var c=kn(e);return u>4&&(n.lineDiv.style.display="none"),An(e,n.updateLineNumbers,r.dims),u>4&&(n.lineDiv.style.display=""),n.renderedView=n.view,Tn(c),t(n.cursorDiv),t(n.selectionDiv),n.gutters.style.height=n.sizer.style.minHeight=0,a&&(n.lastWrapHeight=r.wrapperHeight,n.lastWrapWidth=r.wrapperWidth,Cn(e,400)),n.updateLineNumbers=null,!0}function Nn(e,t){for(var r=t.viewport,n=!0;(n&&e.options.lineWrapping&&t.oldDisplayWidth!=Rt(e)||(r&&null!=r.top&&(r={top:Math.min(e.doc.height+Pt(e.display)-Bt(e),r.top)}),t.visible=Ir(e.display,e.doc,r),!(t.visible.from>=e.display.viewFrom&&t.visible.to<=e.display.viewTo)))&&Mn(e,t);n=!1){Er(e);var i=Jr(e);kr(e),en(e,i),Dn(e,i),t.force=!1}t.signal(e,"update",e),e.display.viewFrom==e.display.reportedViewFrom&&e.display.viewTo==e.display.reportedViewTo||(t.signal(e,"viewportChange",e,e.display.viewFrom,e.display.viewTo),e.display.reportedViewFrom=e.display.viewFrom,e.display.reportedViewTo=e.display.viewTo)}function On(e,t){var r=new Cs(e,t);if(Mn(e,r)){Er(e),Nn(e,r);var n=Jr(e);kr(e),en(e,n),Dn(e,n),r.finish()}}function An(e,r,n){function i(t){var r=t.nextSibling;return ml&&Ml&&e.display.currentWheelTarget==t?t.style.display="none":t.parentNode.removeChild(t),r}for(var o=e.display,l=e.options.lineNumbers,s=o.lineDiv,a=s.firstChild,u=o.view,c=o.viewFrom,f=0;f<u.length;f++){var d=u[f];if(d.hidden);else if(d.node&&d.node.parentNode==s){for(;a!=d.node;)a=i(a);var p=l&&null!=r&&r<=c&&d.lineNumber;d.changes&&(h(d.changes,"gutter")>-1&&(p=!1),xt(e,d,c,n)),p&&(t(d.lineNumber),d.lineNumber.appendChild(document.createTextNode(F(e.options,c)))),a=d.node.nextSibling}else{var g=Ot(e,d,c,n);s.insertBefore(g,a)}c+=d.size}for(;a;)a=i(a)}function Wn(e){var t=e.display.gutters.offsetWidth;e.display.sizer.style.marginLeft=t+"px"}function Dn(e,t){e.display.sizer.style.minHeight=t.docHeight+"px",e.display.heightForcer.style.top=t.docHeight+"px",e.display.gutters.style.height=t.docHeight+e.display.barHeight+zt(e)+"px"}function Hn(e){var r=e.display.gutters,i=e.options.gutters;t(r);for(var o=0;o<i.length;++o){var l=i[o],s=r.appendChild(n("div",null,"CodeMirror-gutter "+l));"CodeMirror-linenumbers"==l&&(e.display.lineGutter=s,s.style.width=(e.display.lineNumWidth||1)+"px")}r.style.display=o?"":"none",Wn(e)}function Fn(e){var t=h(e.gutters,"CodeMirror-linenumbers");-1==t&&e.lineNumbers?e.gutters=e.gutters.concat(["CodeMirror-linenumbers"]):t>-1&&!e.lineNumbers&&(e.gutters=e.gutters.slice(0),e.gutters.splice(t,1))}function En(e){var t=e.wheelDeltaX,r=e.wheelDeltaY;return null==t&&e.detail&&e.axis==e.HORIZONTAL_AXIS&&(t=e.detail),null==r&&e.detail&&e.axis==e.VERTICAL_AXIS?r=e.detail:null==r&&(r=e.wheelDelta),{x:t,y:r}}function Pn(e){var t=En(e);return t.x*=Ls,t.y*=Ls,t}function In(e,t){var r=En(t),n=r.x,i=r.y,o=e.display,l=o.scroller,s=l.scrollWidth>l.clientWidth,a=l.scrollHeight>l.clientHeight;if(n&&s||i&&a){if(i&&Ml&&ml)e:for(var u=t.target,c=o.view;u!=l;u=u.parentNode)for(var f=0;f<c.length;f++)if(c[f].node==u){e.display.currentWheelTarget=u;break e}if(n&&!fl&&!wl&&null!=Ls)return i&&a&&qr(e,Math.max(0,l.scrollTop+i*Ls)),Qr(e,Math.max(0,l.scrollLeft+n*Ls)),(!i||i&&a)&&We(t),void(o.wheelStartX=null);if(i&&null!=Ls){var h=i*Ls,d=e.doc.scrollTop,p=d+o.wrapper.clientHeight;h<0?d=Math.max(0,d+h-50):p=Math.min(e.doc.height,p+h+50),On(e,{top:d,bottom:p})}Ss<20&&(null==o.wheelStartX?(o.wheelStartX=l.scrollLeft,o.wheelStartY=l.scrollTop,o.wheelDX=n,o.wheelDY=i,setTimeout(function(){if(null!=o.wheelStartX){var e=l.scrollLeft-o.wheelStartX,t=l.scrollTop-o.wheelStartY,r=t&&o.wheelDY&&t/o.wheelDY||e&&o.wheelDX&&e/o.wheelDX;o.wheelStartX=o.wheelStartY=null,r&&(Ls=(Ls*Ss+r)/(Ss+1),++Ss)}},200)):(o.wheelDX+=n,o.wheelDY+=i))}}function zn(e,t){var r=e[t];e.sort(function(e,t){return P(e.from(),t.from())}),t=h(e,r);for(var n=1;n<e.length;n++){var i=e[n],o=e[n-1];if(P(o.to(),i.from())>=0){var l=B(o.from(),i.from()),s=R(o.to(),i.to()),a=o.empty()?i.from()==i.head:o.from()==o.head;n<=t&&--t,e.splice(--n,2,new Ts(a?s:l,a?l:s))}}return new ks(e,t)}function Rn(e,t){return new ks([new Ts(e,t||e)],0)}function Bn(e){return e.text?E(e.from.line+e.text.length-1,g(e.text).length+(1==e.text.length?e.from.ch:0)):e.to}function Gn(e,t){if(P(e,t.from)<0)return e;if(P(e,t.to)<=0)return Bn(t);var r=e.line+t.text.length-(t.to.line-t.from.line)-1,n=e.ch;return e.line==t.to.line&&(n+=Bn(t).ch-t.to.ch),E(r,n)}function Un(e,t){for(var r=[],n=0;n<e.sel.ranges.length;n++){var i=e.sel.ranges[n];r.push(new Ts(Gn(i.anchor,t),Gn(i.head,t)))}return zn(r,e.sel.primIndex)}function Vn(e,t,r){return e.line==t.line?E(r.line,e.ch-t.ch+r.ch):E(r.line+(e.line-t.line),e.ch)}function Kn(e,t,r){for(var n=[],i=E(e.first,0),o=i,l=0;l<t.length;l++){var s=t[l],a=Vn(s.from,i,o),u=Vn(Bn(s),i,o);if(i=s.to,o=u,"around"==r){var c=e.sel.ranges[l],f=P(c.head,c.anchor)<0;n[l]=new Ts(f?u:a,f?a:u)}else n[l]=new Ts(a,a)}return new ks(n,e.sel.primIndex)}function jn(e){e.doc.mode=Ue(e.options,e.doc.modeOption),Xn(e)}function Xn(e){e.doc.iter(function(e){e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null)}),e.doc.modeFrontier=e.doc.highlightFrontier=e.doc.first,Cn(e,100),e.state.modeGen++,e.curOp&&vn(e)}function Yn(e,t){return 0==t.from.ch&&0==t.to.ch&&""==g(t.text)&&(!e.cm||e.cm.options.wholeLineUpdateBefore)}function _n(e,t,r,n){function i(e){return r?r[e]:null}function o(e,r,i){it(e,r,i,n),bt(e,"change",e,t)}function l(e,t){for(var r=[],o=e;o<t;++o)r.push(new fs(u[o],i(o),n));return r}var s=t.from,a=t.to,u=t.text,c=M(e,s.line),f=M(e,a.line),h=g(u),d=i(u.length-1),p=a.line-s.line;if(t.full)e.insert(0,l(0,u.length)),e.remove(u.length,e.size-u.length);else if(Yn(e,t)){var v=l(0,u.length-1);o(f,f.text,d),p&&e.remove(s.line,p),v.length&&e.insert(s.line,v)}else if(c==f)if(1==u.length)o(c,c.text.slice(0,s.ch)+h+c.text.slice(a.ch),d);else{var m=l(1,u.length-1);m.push(new fs(h+c.text.slice(a.ch),d,n)),o(c,c.text.slice(0,s.ch)+u[0],i(0)),e.insert(s.line+1,m)}else if(1==u.length)o(c,c.text.slice(0,s.ch)+u[0]+f.text.slice(a.ch),i(0)),e.remove(s.line+1,p);else{o(c,c.text.slice(0,s.ch)+u[0],i(0)),o(f,h+f.text.slice(a.ch),d);var y=l(1,u.length-1);p>1&&e.remove(s.line+1,p-1),e.insert(s.line+1,y)}bt(e,"change",e,t)}function $n(e,t,r){function n(e,i,o){if(e.linked)for(var l=0;l<e.linked.length;++l){var s=e.linked[l];if(s.doc!=i){var a=o&&s.sharedHist;r&&!a||(t(s.doc,a),n(s.doc,e,a))}}}n(e,null,!0)}function qn(e,t){if(t.cm)throw new Error("This document is already in use.");e.doc=t,t.cm=e,Cr(e),jn(e),Zn(e),e.options.lineWrapping||we(e),e.options.mode=t.modeOption,vn(e)}function Zn(e){("rtl"==e.doc.direction?s:Fl)(e.display.lineDiv,"CodeMirror-rtl")}function Qn(e){hn(e,function(){Zn(e),vn(e)})}function Jn(e){this.done=[],this.undone=[],this.undoDepth=1/0,this.lastModTime=this.lastSelTime=0,this.lastOp=this.lastSelOp=null,this.lastOrigin=this.lastSelOrigin=null,this.generation=this.maxGeneration=e||1}function ei(e,t){var r={from:z(t.from),to:Bn(t),text:N(e,t.from,t.to)};return si(e,r,t.from.line,t.to.line+1),$n(e,function(e){return si(e,r,t.from.line,t.to.line+1)},!0),r}function ti(e){for(;e.length&&g(e).ranges;)e.pop()}function ri(e,t){return t?(ti(e.done),g(e.done)):e.done.length&&!g(e.done).ranges?g(e.done):e.done.length>1&&!e.done[e.done.length-2].ranges?(e.done.pop(),g(e.done)):void 0}function ni(e,t,r,n){var i=e.history;i.undone.length=0;var o,l,s=+new Date;if((i.lastOp==n||i.lastOrigin==t.origin&&t.origin&&("+"==t.origin.charAt(0)&&e.cm&&i.lastModTime>s-e.cm.options.historyEventDelay||"*"==t.origin.charAt(0)))&&(o=ri(i,i.lastOp==n)))l=g(o.changes),0==P(t.from,t.to)&&0==P(t.from,l.to)?l.to=Bn(t):o.changes.push(ei(e,t));else{var a=g(i.done);for(a&&a.ranges||li(e.sel,i.done),o={changes:[ei(e,t)],generation:i.generation},i.done.push(o);i.done.length>i.undoDepth;)i.done.shift(),i.done[0].ranges||i.done.shift()}i.done.push(r),i.generation=++i.maxGeneration,i.lastModTime=i.lastSelTime=s,i.lastOp=i.lastSelOp=n,i.lastOrigin=i.lastSelOrigin=t.origin,l||Te(e,"historyAdded")}function ii(e,t,r,n){var i=t.charAt(0);return"*"==i||"+"==i&&r.ranges.length==n.ranges.length&&r.somethingSelected()==n.somethingSelected()&&new Date-e.history.lastSelTime<=(e.cm?e.cm.options.historyEventDelay:500)}function oi(e,t,r,n){var i=e.history,o=n&&n.origin;r==i.lastSelOp||o&&i.lastSelOrigin==o&&(i.lastModTime==i.lastSelTime&&i.lastOrigin==o||ii(e,o,g(i.done),t))?i.done[i.done.length-1]=t:li(t,i.done),i.lastSelTime=+new Date,i.lastSelOrigin=o,i.lastSelOp=r,n&&!1!==n.clearRedo&&ti(i.undone)}function li(e,t){var r=g(t);r&&r.ranges&&r.equals(e)||t.push(e)}function si(e,t,r,n){var i=t["spans_"+e.id],o=0;e.iter(Math.max(e.first,r),Math.min(e.first+e.size,n),function(r){r.markedSpans&&((i||(i=t["spans_"+e.id]={}))[o]=r.markedSpans),++o})}function ai(e){if(!e)return null;for(var t,r=0;r<e.length;++r)e[r].marker.explicitlyCleared?t||(t=e.slice(0,r)):t&&t.push(e[r]);return t?t.length?t:null:e}function ui(e,t){var r=t["spans_"+e.id];if(!r)return null;for(var n=[],i=0;i<t.text.length;++i)n.push(ai(r[i]));return n}function ci(e,t){var r=ui(e,t),n=J(e,t);if(!r)return n;if(!n)return r;for(var i=0;i<r.length;++i){var o=r[i],l=n[i];if(o&&l)e:for(var s=0;s<l.length;++s){for(var a=l[s],u=0;u<o.length;++u)if(o[u].marker==a.marker)continue e;o.push(a)}else l&&(r[i]=l)}return r}function fi(e,t,r){for(var n=[],i=0;i<e.length;++i){var o=e[i];if(o.ranges)n.push(r?ks.prototype.deepCopy.call(o):o);else{var l=o.changes,s=[];n.push({changes:s});for(var a=0;a<l.length;++a){var u=l[a],c=void 0;if(s.push({from:u.from,to:u.to,text:u.text}),t)for(var f in u)(c=f.match(/^spans_(\d+)$/))&&h(t,Number(c[1]))>-1&&(g(s)[f]=u[f],delete u[f])}}}return n}function hi(e,t,r,n){if(n){var i=e.anchor;if(r){var o=P(t,i)<0;o!=P(r,i)<0?(i=t,t=r):o!=P(t,r)<0&&(t=r)}return new Ts(i,t)}return new Ts(r||t,t)}function di(e,t,r,n,i){null==i&&(i=e.cm&&(e.cm.display.shift||e.extend)),bi(e,new ks([hi(e.sel.primary(),t,r,i)],0),n)}function pi(e,t,r){for(var n=[],i=e.cm&&(e.cm.display.shift||e.extend),o=0;o<e.sel.ranges.length;o++)n[o]=hi(e.sel.ranges[o],t[o],null,i);bi(e,zn(n,e.sel.primIndex),r)}function gi(e,t,r,n){var i=e.sel.ranges.slice(0);i[t]=r,bi(e,zn(i,e.sel.primIndex),n)}function vi(e,t,r,n){bi(e,Rn(t,r),n)}function mi(e,t,r){var n={ranges:t.ranges,update:function(t){var r=this;this.ranges=[];for(var n=0;n<t.length;n++)r.ranges[n]=new Ts(U(e,t[n].anchor),U(e,t[n].head))},origin:r&&r.origin};return Te(e,"beforeSelectionChange",e,n),e.cm&&Te(e.cm,"beforeSelectionChange",e.cm,n),n.ranges!=t.ranges?zn(n.ranges,n.ranges.length-1):t}function yi(e,t,r){var n=e.history.done,i=g(n);i&&i.ranges?(n[n.length-1]=t,wi(e,t,r)):bi(e,t,r)}function bi(e,t,r){wi(e,t,r),oi(e,e.sel,e.cm?e.cm.curOp.id:NaN,r)}function wi(e,t,r){(Oe(e,"beforeSelectionChange")||e.cm&&Oe(e.cm,"beforeSelectionChange"))&&(t=mi(e,t,r)),xi(e,Si(e,t,r&&r.bias||(P(t.primary().head,e.sel.primary().head)<0?-1:1),!0)),r&&!1===r.scroll||!e.cm||jr(e.cm)}function xi(e,t){t.equals(e.sel)||(e.sel=t,e.cm&&(e.cm.curOp.updateInput=e.cm.curOp.selectionChanged=!0,Ne(e.cm)),bt(e,"cursorActivity",e))}function Ci(e){xi(e,Si(e,e.sel,null,!1))}function Si(e,t,r,n){for(var i,o=0;o<t.ranges.length;o++){var l=t.ranges[o],s=t.ranges.length==e.sel.ranges.length&&e.sel.ranges[o],a=ki(e,l.anchor,s&&s.anchor,r,n),u=ki(e,l.head,s&&s.head,r,n);(i||a!=l.anchor||u!=l.head)&&(i||(i=t.ranges.slice(0,o)),i[o]=new Ts(a,u))}return i?zn(i,t.primIndex):t}function Li(e,t,r,n,i){var o=M(e,t.line);if(o.markedSpans)for(var l=0;l<o.markedSpans.length;++l){var s=o.markedSpans[l],a=s.marker;if((null==s.from||(a.inclusiveLeft?s.from<=t.ch:s.from<t.ch))&&(null==s.to||(a.inclusiveRight?s.to>=t.ch:s.to>t.ch))){if(i&&(Te(a,"beforeCursorEnter"),a.explicitlyCleared)){if(o.markedSpans){--l;continue}break}if(!a.atomic)continue;if(r){var u=a.find(n<0?1:-1),c=void 0;if((n<0?a.inclusiveRight:a.inclusiveLeft)&&(u=Ti(e,u,-n,u&&u.line==t.line?o:null)),u&&u.line==t.line&&(c=P(u,r))&&(n<0?c<0:c>0))return Li(e,u,t,n,i)}var f=a.find(n<0?-1:1);return(n<0?a.inclusiveLeft:a.inclusiveRight)&&(f=Ti(e,f,n,f.line==t.line?o:null)),f?Li(e,f,t,n,i):null}}return t}function ki(e,t,r,n,i){var o=n||1,l=Li(e,t,r,o,i)||!i&&Li(e,t,r,o,!0)||Li(e,t,r,-o,i)||!i&&Li(e,t,r,-o,!0);return l||(e.cantEdit=!0,E(e.first,0))}function Ti(e,t,r,n){return r<0&&0==t.ch?t.line>e.first?U(e,E(t.line-1)):null:r>0&&t.ch==(n||M(e,t.line)).text.length?t.line<e.first+e.size-1?E(t.line+1,0):null:new E(t.line,t.ch+r)}function Mi(e){e.setSelection(E(e.firstLine(),0),E(e.lastLine()),Gl)}function Ni(e,t,r){var n={canceled:!1,from:t.from,to:t.to,text:t.text,origin:t.origin,cancel:function(){return n.canceled=!0}};return r&&(n.update=function(t,r,i,o){t&&(n.from=U(e,t)),r&&(n.to=U(e,r)),i&&(n.text=i),void 0!==o&&(n.origin=o)}),Te(e,"beforeChange",e,n),e.cm&&Te(e.cm,"beforeChange",e.cm,n),n.canceled?null:{from:n.from,to:n.to,text:n.text,origin:n.origin}}function Oi(e,t,r){if(e.cm){if(!e.cm.curOp)return dn(e.cm,Oi)(e,t,r);if(e.cm.state.suppressEdits)return}if(!(Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"))||(t=Ni(e,t,!0))){var n=Yl&&!r&&te(e,t.from,t.to);if(n)for(var i=n.length-1;i>=0;--i)Ai(e,{from:n[i].from,to:n[i].to,text:i?[""]:t.text,origin:t.origin});else Ai(e,t)}}function Ai(e,t){if(1!=t.text.length||""!=t.text[0]||0!=P(t.from,t.to)){var r=Un(e,t);ni(e,t,r,e.cm?e.cm.curOp.id:NaN),Hi(e,t,r,J(e,t));var n=[];$n(e,function(e,r){r||-1!=h(n,e.history)||(zi(e.history,t),n.push(e.history)),Hi(e,t,null,J(e,t))})}}function Wi(e,t,r){if(!e.cm||!e.cm.state.suppressEdits||r){for(var n,i=e.history,o=e.sel,l="undo"==t?i.done:i.undone,s="undo"==t?i.undone:i.done,a=0;a<l.length&&(n=l[a],r?!n.ranges||n.equals(e.sel):n.ranges);a++);if(a!=l.length){for(i.lastOrigin=i.lastSelOrigin=null;(n=l.pop()).ranges;){if(li(n,s),r&&!n.equals(e.sel))return void bi(e,n,{clearRedo:!1});o=n}var u=[];li(o,s),s.push({changes:u,generation:i.generation}),i.generation=n.generation||++i.maxGeneration;for(var c=Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"),f=n.changes.length-1;f>=0;--f){var d=function(r){var i=n.changes[r];if(i.origin=t,c&&!Ni(e,i,!1))return l.length=0,{};u.push(ei(e,i));var o=r?Un(e,i):g(l);Hi(e,i,o,ci(e,i)),!r&&e.cm&&e.cm.scrollIntoView({from:i.from,to:Bn(i)});var s=[];$n(e,function(e,t){t||-1!=h(s,e.history)||(zi(e.history,i),s.push(e.history)),Hi(e,i,null,ci(e,i))})}(f);if(d)return d.v}}}}function Di(e,t){if(0!=t&&(e.first+=t,e.sel=new ks(v(e.sel.ranges,function(e){return new Ts(E(e.anchor.line+t,e.anchor.ch),E(e.head.line+t,e.head.ch))}),e.sel.primIndex),e.cm)){vn(e.cm,e.first,e.first-t,t);for(var r=e.cm.display,n=r.viewFrom;n<r.viewTo;n++)mn(e.cm,n,"gutter")}}function Hi(e,t,r,n){if(e.cm&&!e.cm.curOp)return dn(e.cm,Hi)(e,t,r,n);if(t.to.line<e.first)Di(e,t.text.length-1-(t.to.line-t.from.line));else if(!(t.from.line>e.lastLine())){if(t.from.line<e.first){var i=t.text.length-1-(e.first-t.from.line);Di(e,i),t={from:E(e.first,0),to:E(t.to.line+i,t.to.ch),text:[g(t.text)],origin:t.origin}}var o=e.lastLine();t.to.line>o&&(t={from:t.from,to:E(o,M(e,o).text.length),text:[t.text[0]],origin:t.origin}),t.removed=N(e,t.from,t.to),r||(r=Un(e,t)),e.cm?Fi(e.cm,t,n):_n(e,t,n),wi(e,r,Gl)}}function Fi(e,t,r){var n=e.doc,i=e.display,o=t.from,l=t.to,s=!1,a=o.line;e.options.lineWrapping||(a=W(fe(M(n,o.line))),n.iter(a,l.line+1,function(e){if(e==i.maxLine)return s=!0,!0})),n.sel.contains(t.from,t.to)>-1&&Ne(e),_n(n,t,r,xr(e)),e.options.lineWrapping||(n.iter(a,o.line+t.text.length,function(e){var t=be(e);t>i.maxLineLength&&(i.maxLine=e,i.maxLineLength=t,i.maxLineChanged=!0,s=!1)}),s&&(e.curOp.updateMaxLine=!0)),nt(n,o.line),Cn(e,400);var u=t.text.length-(l.line-o.line)-1;t.full?vn(e):o.line!=l.line||1!=t.text.length||Yn(e.doc,t)?vn(e,o.line,l.line+1,u):mn(e,o.line,"text");var c=Oe(e,"changes"),f=Oe(e,"change");if(f||c){var h={from:o,to:l,text:t.text,removed:t.removed,origin:t.origin};f&&bt(e,"change",e,h),c&&(e.curOp.changeObjs||(e.curOp.changeObjs=[])).push(h)}e.display.selForContextMenu=null}function Ei(e,t,r,n,i){if(n||(n=r),P(n,r)<0){var o;r=(o=[n,r])[0],n=o[1]}"string"==typeof t&&(t=e.splitLines(t)),Oi(e,{from:r,to:n,text:t,origin:i})}function Pi(e,t,r,n){r<e.line?e.line+=n:t<e.line&&(e.line=t,e.ch=0)}function Ii(e,t,r,n){for(var i=0;i<e.length;++i){var o=e[i],l=!0;if(o.ranges){o.copied||((o=e[i]=o.deepCopy()).copied=!0);for(var s=0;s<o.ranges.length;s++)Pi(o.ranges[s].anchor,t,r,n),Pi(o.ranges[s].head,t,r,n)}else{for(var a=0;a<o.changes.length;++a){var u=o.changes[a];if(r<u.from.line)u.from=E(u.from.line+n,u.from.ch),u.to=E(u.to.line+n,u.to.ch);else if(t<=u.to.line){l=!1;break}}l||(e.splice(0,i+1),i=0)}}}function zi(e,t){var r=t.from.line,n=t.to.line,i=t.text.length-(n-r)-1;Ii(e.done,r,n,i),Ii(e.undone,r,n,i)}function Ri(e,t,r,n){var i=t,o=t;return"number"==typeof t?o=M(e,G(e,t)):i=W(t),null==i?null:(n(o,i)&&e.cm&&mn(e.cm,i,r),o)}function Bi(e){var t=this;this.lines=e,this.parent=null;for(var r=0,n=0;n<e.length;++n)e[n].parent=t,r+=e[n].height;this.height=r}function Gi(e){var t=this;this.children=e;for(var r=0,n=0,i=0;i<e.length;++i){var o=e[i];r+=o.chunkSize(),n+=o.height,o.parent=t}this.size=r,this.height=n,this.parent=null}function Ui(e,t,r){ye(t)<(e.curOp&&e.curOp.scrollTop||e.doc.scrollTop)&&Kr(e,r)}function Vi(e,t,r,n){var i=new Ms(e,r,n),o=e.cm;return o&&i.noHScroll&&(o.display.alignWidgets=!0),Ri(e,t,"widget",function(t){var r=t.widgets||(t.widgets=[]);if(null==i.insertAt?r.push(i):r.splice(Math.min(r.length-1,Math.max(0,i.insertAt)),0,i),i.line=t,o&&!ve(e,t)){var n=ye(t)<e.scrollTop;A(t,t.height+Ht(i)),n&&Kr(o,i.height),o.curOp.forceUpdate=!0}return!0}),bt(o,"lineWidgetAdded",o,i,"number"==typeof t?t:W(t)),i}function Ki(e,t,r,n,o){if(n&&n.shared)return ji(e,t,r,n,o);if(e.cm&&!e.cm.curOp)return dn(e.cm,Ki)(e,t,r,n,o);var l=new Os(e,o),s=P(t,r);if(n&&c(n,l,!1),s>0||0==s&&!1!==l.clearWhenEmpty)return l;if(l.replacedWith&&(l.collapsed=!0,l.widgetNode=i("span",[l.replacedWith],"CodeMirror-widget"),n.handleMouseEvents||l.widgetNode.setAttribute("cm-ignore-events","true"),n.insertLeft&&(l.widgetNode.insertLeft=!0)),l.collapsed){if(ce(e,t.line,t,r,l)||t.line!=r.line&&ce(e,r.line,t,r,l))throw new Error("Inserting collapsed marker partially overlapping an existing one");X()}l.addToHistory&&ni(e,{from:t,to:r,origin:"markText"},e.sel,NaN);var a,u=t.line,f=e.cm;if(e.iter(u,r.line+1,function(e){f&&l.collapsed&&!f.options.lineWrapping&&fe(e)==f.display.maxLine&&(a=!0),l.collapsed&&u!=t.line&&A(e,0),q(e,new Y(l,u==t.line?t.ch:null,u==r.line?r.ch:null)),++u}),l.collapsed&&e.iter(t.line,r.line+1,function(t){ve(e,t)&&A(t,0)}),l.clearOnEnter&&Ql(l,"beforeCursorEnter",function(){return l.clear()}),l.readOnly&&(j(),(e.history.done.length||e.history.undone.length)&&e.clearHistory()),l.collapsed&&(l.id=++Ns,l.atomic=!0),f){if(a&&(f.curOp.updateMaxLine=!0),l.collapsed)vn(f,t.line,r.line+1);else if(l.className||l.title||l.startStyle||l.endStyle||l.css)for(var h=t.line;h<=r.line;h++)mn(f,h,"text");l.atomic&&Ci(f.doc),bt(f,"markerAdded",f,l)}return l}function ji(e,t,r,n,i){(n=c(n)).shared=!1;var o=[Ki(e,t,r,n,i)],l=o[0],s=n.widgetNode;return $n(e,function(e){s&&(n.widgetNode=s.cloneNode(!0)),o.push(Ki(e,U(e,t),U(e,r),n,i));for(var a=0;a<e.linked.length;++a)if(e.linked[a].isParent)return;l=g(o)}),new As(o,l)}function Xi(e){return e.findMarks(E(e.first,0),e.clipPos(E(e.lastLine())),function(e){return e.parent})}function Yi(e,t){for(var r=0;r<t.length;r++){var n=t[r],i=n.find(),o=e.clipPos(i.from),l=e.clipPos(i.to);if(P(o,l)){var s=Ki(e,o,l,n.primary,n.primary.type);n.markers.push(s),s.parent=n}}}function _i(e){for(var t=0;t<e.length;t++)!function(t){var r=e[t],n=[r.primary.doc];$n(r.primary.doc,function(e){return n.push(e)});for(var i=0;i<r.markers.length;i++){var o=r.markers[i];-1==h(n,o.doc)&&(o.parent=null,r.markers.splice(i--,1))}}(t)}function $i(e){var t=this;if(Qi(t),!Me(t,e)&&!Ft(t.display,e)){We(e),gl&&(Hs=+new Date);var r=Sr(t,e,!0),n=e.dataTransfer.files;if(r&&!t.isReadOnly())if(n&&n.length&&window.FileReader&&window.File)for(var i=n.length,o=Array(i),l=0,s=0;s<i;++s)!function(e,n){if(!t.options.allowDropFileTypes||-1!=h(t.options.allowDropFileTypes,e.type)){var s=new FileReader;s.onload=dn(t,function(){var e=s.result;if(/[\x00-\x08\x0e-\x1f]{2}/.test(e)&&(e=""),o[n]=e,++l==i){var a={from:r=U(t.doc,r),to:r,text:t.doc.splitLines(o.join(t.doc.lineSeparator())),origin:"paste"};Oi(t.doc,a),yi(t.doc,Rn(r,Bn(a)))}}),s.readAsText(e)}}(n[s],s);else{if(t.state.draggingText&&t.doc.sel.contains(r)>-1)return t.state.draggingText(e),void setTimeout(function(){return t.display.input.focus()},20);try{var a=e.dataTransfer.getData("Text");if(a){var u;if(t.state.draggingText&&!t.state.draggingText.copy&&(u=t.listSelections()),wi(t.doc,Rn(r,r)),u)for(var c=0;c<u.length;++c)Ei(t.doc,"",u[c].anchor,u[c].head,"drag");t.replaceSelection(a,"around","paste"),t.display.input.focus()}}catch(e){}}}}function qi(e,t){if(gl&&(!e.state.draggingText||+new Date-Hs<100))Fe(t);else if(!Me(e,t)&&!Ft(e.display,t)&&(t.dataTransfer.setData("Text",e.getSelection()),t.dataTransfer.effectAllowed="copyMove",t.dataTransfer.setDragImage&&!xl)){var r=n("img",null,null,"position: fixed; left: 0; top: 0;");r.src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",wl&&(r.width=r.height=1,e.display.wrapper.appendChild(r),r._top=r.offsetTop),t.dataTransfer.setDragImage(r,0,0),wl&&r.parentNode.removeChild(r)}}function Zi(e,t){var i=Sr(e,t);if(i){var o=document.createDocumentFragment();Mr(e,i,o),e.display.dragCursor||(e.display.dragCursor=n("div",null,"CodeMirror-cursors CodeMirror-dragcursors"),e.display.lineSpace.insertBefore(e.display.dragCursor,e.display.cursorDiv)),r(e.display.dragCursor,o)}}function Qi(e){e.display.dragCursor&&(e.display.lineSpace.removeChild(e.display.dragCursor),e.display.dragCursor=null)}function Ji(e){if(document.getElementsByClassName)for(var t=document.getElementsByClassName("CodeMirror"),r=0;r<t.length;r++){var n=t[r].CodeMirror;n&&e(n)}}function eo(){Fs||(to(),Fs=!0)}function to(){var e;Ql(window,"resize",function(){null==e&&(e=setTimeout(function(){e=null,Ji(ro)},100))}),Ql(window,"blur",function(){return Ji(Fr)})}function ro(e){var t=e.display;t.lastWrapHeight==t.wrapper.clientHeight&&t.lastWrapWidth==t.wrapper.clientWidth||(t.cachedCharWidth=t.cachedTextHeight=t.cachedPaddingH=null,t.scrollbarsClipped=!1,e.setSize())}function no(e){var t=e.split(/-(?!$)/);e=t[t.length-1];for(var r,n,i,o,l=0;l<t.length-1;l++){var s=t[l];if(/^(cmd|meta|m)$/i.test(s))o=!0;else if(/^a(lt)?$/i.test(s))r=!0;else if(/^(c|ctrl|control)$/i.test(s))n=!0;else{if(!/^s(hift)?$/i.test(s))throw new Error("Unrecognized modifier name: "+s);i=!0}}return r&&(e="Alt-"+e),n&&(e="Ctrl-"+e),o&&(e="Cmd-"+e),i&&(e="Shift-"+e),e}function io(e){var t={};for(var r in e)if(e.hasOwnProperty(r)){var n=e[r];if(/^(name|fallthrough|(de|at)tach)$/.test(r))continue;if("..."==n){delete e[r];continue}for(var i=v(r.split(" "),no),o=0;o<i.length;o++){var l=void 0,s=void 0;o==i.length-1?(s=i.join(" "),l=n):(s=i.slice(0,o+1).join(" "),l="...");var a=t[s];if(a){if(a!=l)throw new Error("Inconsistent bindings for "+s)}else t[s]=l}delete e[r]}for(var u in t)e[u]=t[u];return e}function oo(e,t,r,n){var i=(t=uo(t)).call?t.call(e,n):t[e];if(!1===i)return"nothing";if("..."===i)return"multi";if(null!=i&&r(i))return"handled";if(t.fallthrough){if("[object Array]"!=Object.prototype.toString.call(t.fallthrough))return oo(e,t.fallthrough,r,n);for(var o=0;o<t.fallthrough.length;o++){var l=oo(e,t.fallthrough[o],r,n);if(l)return l}}}function lo(e){var t="string"==typeof e?e:Es[e.keyCode];return"Ctrl"==t||"Alt"==t||"Shift"==t||"Mod"==t}function so(e,t,r){var n=e;return t.altKey&&"Alt"!=n&&(e="Alt-"+e),(Dl?t.metaKey:t.ctrlKey)&&"Ctrl"!=n&&(e="Ctrl-"+e),(Dl?t.ctrlKey:t.metaKey)&&"Cmd"!=n&&(e="Cmd-"+e),!r&&t.shiftKey&&"Shift"!=n&&(e="Shift-"+e),e}function ao(e,t){if(wl&&34==e.keyCode&&e.char)return!1;var r=Es[e.keyCode];return null!=r&&!e.altGraphKey&&so(r,e,t)}function uo(e){return"string"==typeof e?Rs[e]:e}function co(e,t){for(var r=e.doc.sel.ranges,n=[],i=0;i<r.length;i++){for(var o=t(r[i]);n.length&&P(o.from,g(n).to)<=0;){var l=n.pop();if(P(l.from,o.from)<0){o.from=l.from;break}}n.push(o)}hn(e,function(){for(var t=n.length-1;t>=0;t--)Ei(e.doc,"",n[t].from,n[t].to,"+delete");jr(e)})}function fo(e,t,r){var n=L(e.text,t+r,r);return n<0||n>e.text.length?null:n}function ho(e,t,r){var n=fo(e,t.ch,r);return null==n?null:new E(t.line,n,r<0?"after":"before")}function po(e,t,r,n,i){if(e){var o=Se(r,t.doc.direction);if(o){var l,s=i<0?g(o):o[0],a=i<0==(1==s.level)?"after":"before";if(s.level>0){var u=Xt(t,r);l=i<0?r.text.length-1:0;var c=Yt(t,u,l).top;l=k(function(e){return Yt(t,u,e).top==c},i<0==(1==s.level)?s.from:s.to-1,l),"before"==a&&(l=fo(r,l,1))}else l=i<0?s.to:s.from;return new E(n,l,a)}}return new E(n,i<0?r.text.length:0,i<0?"before":"after")}function go(e,t,r,n){var i=Se(t,e.doc.direction);if(!i)return ho(t,r,n);r.ch>=t.text.length?(r.ch=t.text.length,r.sticky="before"):r.ch<=0&&(r.ch=0,r.sticky="after");var o=Ce(i,r.ch,r.sticky),l=i[o];if("ltr"==e.doc.direction&&l.level%2==0&&(n>0?l.to>r.ch:l.from<r.ch))return ho(t,r,n);var s,a=function(e,r){return fo(t,e instanceof E?e.ch:e,r)},u=function(r){return e.options.lineWrapping?(s=s||Xt(e,t),hr(e,t,s,r)):{begin:0,end:t.text.length}},c=u("before"==r.sticky?a(r,-1):r.ch);if("rtl"==e.doc.direction||1==l.level){var f=1==l.level==n<0,h=a(r,f?1:-1);if(null!=h&&(f?h<=l.to&&h<=c.end:h>=l.from&&h>=c.begin)){var d=f?"before":"after";return new E(r.line,h,d)}}var p=function(e,t,n){for(var o=function(e,t){return t?new E(r.line,a(e,1),"before"):new E(r.line,e,"after")};e>=0&&e<i.length;e+=t){var l=i[e],s=t>0==(1!=l.level),u=s?n.begin:a(n.end,-1);if(l.from<=u&&u<l.to)return o(u,s);if(u=s?l.from:a(l.to,-1),n.begin<=u&&u<n.end)return o(u,s)}},g=p(o+n,n,c);if(g)return g;var v=n>0?c.end:a(c.begin,-1);return null==v||n>0&&v==t.text.length||!(g=p(n>0?0:i.length-1,n,u(v)))?null:g}function vo(e,t){var r=M(e.doc,t),n=fe(r);return n!=r&&(t=W(n)),po(!0,e,n,t,1)}function mo(e,t){var r=M(e.doc,t),n=he(r);return n!=r&&(t=W(n)),po(!0,e,r,t,-1)}function yo(e,t){var r=vo(e,t.line),n=M(e.doc,r.line),i=Se(n,e.doc.direction);if(!i||0==i[0].level){var o=Math.max(0,n.text.search(/\S/)),l=t.line==r.line&&t.ch<=o&&t.ch;return E(r.line,l?0:o,r.sticky)}return r}function bo(e,t,r){if("string"==typeof t&&!(t=Bs[t]))return!1;e.display.input.ensurePolled();var n=e.display.shift,i=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),r&&(e.display.shift=!1),i=t(e)!=Bl}finally{e.display.shift=n,e.state.suppressEdits=!1}return i}function wo(e,t,r){for(var n=0;n<e.state.keyMaps.length;n++){var i=oo(t,e.state.keyMaps[n],r,e);if(i)return i}return e.options.extraKeys&&oo(t,e.options.extraKeys,r,e)||oo(t,e.options.keyMap,r,e)}function xo(e,t,r,n){var i=e.state.keySeq;if(i){if(lo(t))return"handled";Gs.set(50,function(){e.state.keySeq==i&&(e.state.keySeq=null,e.display.input.reset())}),t=i+" "+t}var o=wo(e,t,n);return"multi"==o&&(e.state.keySeq=t),"handled"==o&&bt(e,"keyHandled",e,t,r),"handled"!=o&&"multi"!=o||(We(r),Ar(e)),i&&!o&&/\'$/.test(t)?(We(r),!0):!!o}function Co(e,t){var r=ao(t,!0);return!!r&&(t.shiftKey&&!e.state.keySeq?xo(e,"Shift-"+r,t,function(t){return bo(e,t,!0)})||xo(e,r,t,function(t){if("string"==typeof t?/^go[A-Z]/.test(t):t.motion)return bo(e,t)}):xo(e,r,t,function(t){return bo(e,t)}))}function So(e,t,r){return xo(e,"'"+r+"'",t,function(t){return bo(e,t,!0)})}function Lo(e){var t=this;if(t.curOp.focus=l(),!Me(t,e)){gl&&vl<11&&27==e.keyCode&&(e.returnValue=!1);var r=e.keyCode;t.display.shift=16==r||e.shiftKey;var n=Co(t,e);wl&&(Us=n?r:null,!n&&88==r&&!rs&&(Ml?e.metaKey:e.ctrlKey)&&t.replaceSelection("",null,"cut")),18!=r||/\bCodeMirror-crosshair\b/.test(t.display.lineDiv.className)||ko(t)}}function ko(e){function t(e){18!=e.keyCode&&e.altKey||(Fl(r,"CodeMirror-crosshair"),ke(document,"keyup",t),ke(document,"mouseover",t))}var r=e.display.lineDiv;s(r,"CodeMirror-crosshair"),Ql(document,"keyup",t),Ql(document,"mouseover",t)}function To(e){16==e.keyCode&&(this.doc.sel.shift=!1),Me(this,e)}function Mo(e){var t=this;if(!(Ft(t.display,e)||Me(t,e)||e.ctrlKey&&!e.altKey||Ml&&e.metaKey)){var r=e.keyCode,n=e.charCode;if(wl&&r==Us)return Us=null,void We(e);if(!wl||e.which&&!(e.which<10)||!Co(t,e)){var i=String.fromCharCode(null==n?r:n);"\b"!=i&&(So(t,e,i)||t.display.input.onKeyPress(e))}}}function No(e,t){var r=+new Date;return js&&js.compare(r,e,t)?(Ks=js=null,"triple"):Ks&&Ks.compare(r,e,t)?(js=new Vs(r,e,t),Ks=null,"double"):(Ks=new Vs(r,e,t),js=null,"single")}function Oo(e){var t=this,r=t.display;if(!(Me(t,e)||r.activeTouch&&r.input.supportsTouch()))if(r.input.ensurePolled(),r.shift=e.shiftKey,Ft(r,e))ml||(r.scroller.draggable=!1,setTimeout(function(){return r.scroller.draggable=!0},100));else if(!zo(t,e)){var n=Sr(t,e),i=Pe(e),o=n?No(n,i):"single";window.focus(),1==i&&t.state.selectingText&&t.state.selectingText(e),n&&Ao(t,i,n,o,e)||(1==i?n?Do(t,n,o,e):Ee(e)==r.scroller&&We(e):2==i?(n&&di(t.doc,n),setTimeout(function(){return r.input.focus()},20)):3==i&&(Hl?Ro(t,e):Dr(t)))}}function Ao(e,t,r,n,i){var o="Click";return"double"==n?o="Double"+o:"triple"==n&&(o="Triple"+o),o=(1==t?"Left":2==t?"Middle":"Right")+o,xo(e,so(o,i),i,function(t){if("string"==typeof t&&(t=Bs[t]),!t)return!1;var n=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),n=t(e,r)!=Bl}finally{e.state.suppressEdits=!1}return n})}function Wo(e,t,r){var n=e.getOption("configureMouse"),i=n?n(e,t,r):{};if(null==i.unit){var o=Nl?r.shiftKey&&r.metaKey:r.altKey;i.unit=o?"rectangle":"single"==t?"char":"double"==t?"word":"line"}return(null==i.extend||e.doc.extend)&&(i.extend=e.doc.extend||r.shiftKey),null==i.addNew&&(i.addNew=Ml?r.metaKey:r.ctrlKey),null==i.moveOnDrag&&(i.moveOnDrag=!(Ml?r.altKey:r.ctrlKey)),i}function Do(e,t,r,n){gl?setTimeout(u(Wr,e),0):e.curOp.focus=l();var i,o=Wo(e,r,n),s=e.doc.sel;e.options.dragDrop&&Jl&&!e.isReadOnly()&&"single"==r&&(i=s.contains(t))>-1&&(P((i=s.ranges[i]).from(),t)<0||t.xRel>0)&&(P(i.to(),t)>0||t.xRel<0)?Ho(e,n,t,o):Eo(e,n,t,o)}function Ho(e,t,r,n){var i=e.display,o=!1,l=dn(e,function(t){ml&&(i.scroller.draggable=!1),e.state.draggingText=!1,ke(document,"mouseup",l),ke(document,"mousemove",s),ke(i.scroller,"dragstart",a),ke(i.scroller,"drop",l),o||(We(t),n.addNew||di(e.doc,r,null,null,n.extend),ml||gl&&9==vl?setTimeout(function(){document.body.focus(),i.input.focus()},20):i.input.focus())}),s=function(e){o=o||Math.abs(t.clientX-e.clientX)+Math.abs(t.clientY-e.clientY)>=10},a=function(){return o=!0};ml&&(i.scroller.draggable=!0),e.state.draggingText=l,l.copy=!n.moveOnDrag,i.scroller.dragDrop&&i.scroller.dragDrop(),Ql(document,"mouseup",l),Ql(document,"mousemove",s),Ql(i.scroller,"dragstart",a),Ql(i.scroller,"drop",l),Dr(e),setTimeout(function(){return i.input.focus()},20)}function Fo(e,t,r){if("char"==r)return new Ts(t,t);if("word"==r)return e.findWordAt(t);if("line"==r)return new Ts(E(t.line,0),U(e.doc,E(t.line+1,0)));var n=r(e,t);return new Ts(n.from,n.to)}function Eo(e,t,r,n){function i(t){if(0!=P(m,t))if(m=t,"rectangle"==n.unit){for(var i=[],o=e.options.tabSize,l=f(M(u,r.line).text,r.ch,o),s=f(M(u,t.line).text,t.ch,o),a=Math.min(l,s),g=Math.max(l,s),v=Math.min(r.line,t.line),y=Math.min(e.lastLine(),Math.max(r.line,t.line));v<=y;v++){var b=M(u,v).text,w=d(b,a,o);a==g?i.push(new Ts(E(v,w),E(v,w))):b.length>w&&i.push(new Ts(E(v,w),E(v,d(b,g,o))))}i.length||i.push(new Ts(r,r)),bi(u,zn(p.ranges.slice(0,h).concat(i),h),{origin:"*mouse",scroll:!1}),e.scrollIntoView(t)}else{var x,C=c,S=Fo(e,t,n.unit),L=C.anchor;P(S.anchor,L)>0?(x=S.head,L=B(C.from(),S.anchor)):(x=S.anchor,L=R(C.to(),S.head));var k=p.ranges.slice(0);k[h]=Po(e,new Ts(U(u,L),x)),bi(u,zn(k,h),Ul)}}function o(t){var r=++b,s=Sr(e,t,!0,"rectangle"==n.unit);if(s)if(0!=P(s,m)){e.curOp.focus=l(),i(s);var c=Ir(a,u);(s.line>=c.to||s.line<c.from)&&setTimeout(dn(e,function(){b==r&&o(t)}),150)}else{var f=t.clientY<y.top?-20:t.clientY>y.bottom?20:0;f&&setTimeout(dn(e,function(){b==r&&(a.scroller.scrollTop+=f,o(t))}),50)}}function s(t){e.state.selectingText=!1,b=1/0,We(t),a.input.focus(),ke(document,"mousemove",w),ke(document,"mouseup",x),u.history.lastSelOrigin=null}var a=e.display,u=e.doc;We(t);var c,h,p=u.sel,g=p.ranges;if(n.addNew&&!n.extend?(h=u.sel.contains(r),c=h>-1?g[h]:new Ts(r,r)):(c=u.sel.primary(),h=u.sel.primIndex),"rectangle"==n.unit)n.addNew||(c=new Ts(r,r)),r=Sr(e,t,!0,!0),h=-1;else{var v=Fo(e,r,n.unit);c=n.extend?hi(c,v.anchor,v.head,n.extend):v}n.addNew?-1==h?(h=g.length,bi(u,zn(g.concat([c]),h),{scroll:!1,origin:"*mouse"})):g.length>1&&g[h].empty()&&"char"==n.unit&&!n.extend?(bi(u,zn(g.slice(0,h).concat(g.slice(h+1)),0),{scroll:!1,origin:"*mouse"}),p=u.sel):gi(u,h,c,Ul):(h=0,bi(u,new ks([c],0),Ul),p=u.sel);var m=r,y=a.wrapper.getBoundingClientRect(),b=0,w=dn(e,function(e){Pe(e)?o(e):s(e)}),x=dn(e,s);e.state.selectingText=x,Ql(document,"mousemove",w),Ql(document,"mouseup",x)}function Po(e,t){var r=t.anchor,n=t.head,i=M(e.doc,r.line);if(0==P(r,n)&&r.sticky==n.sticky)return t;var o=Se(i);if(!o)return t;var l=Ce(o,r.ch,r.sticky),s=o[l];if(s.from!=r.ch&&s.to!=r.ch)return t;var a=l+(s.from==r.ch==(1!=s.level)?0:1);if(0==a||a==o.length)return t;var u;if(n.line!=r.line)u=(n.line-r.line)*("ltr"==e.doc.direction?1:-1)>0;else{var c=Ce(o,n.ch,n.sticky),f=c-l||(n.ch-r.ch)*(1==s.level?-1:1);u=c==a-1||c==a?f<0:f>0}var h=o[a+(u?-1:0)],d=u==(1==h.level),p=d?h.from:h.to,g=d?"after":"before";return r.ch==p&&r.sticky==g?t:new Ts(new E(r.line,p,g),n)}function Io(e,t,r,n){var i,o;if(t.touches)i=t.touches[0].clientX,o=t.touches[0].clientY;else try{i=t.clientX,o=t.clientY}catch(t){return!1}if(i>=Math.floor(e.display.gutters.getBoundingClientRect().right))return!1;n&&We(t);var l=e.display,s=l.lineDiv.getBoundingClientRect();if(o>s.bottom||!Oe(e,r))return He(t);o-=s.top-l.viewOffset;for(var a=0;a<e.options.gutters.length;++a){var u=l.gutters.childNodes[a];if(u&&u.getBoundingClientRect().right>=i)return Te(e,r,e,D(e.doc,o),e.options.gutters[a],t),He(t)}}function zo(e,t){return Io(e,t,"gutterClick",!0)}function Ro(e,t){Ft(e.display,t)||Bo(e,t)||Me(e,t,"contextmenu")||e.display.input.onContextMenu(t)}function Bo(e,t){return!!Oe(e,"gutterContextMenu")&&Io(e,t,"gutterContextMenu",!1)}function Go(e){e.display.wrapper.className=e.display.wrapper.className.replace(/\s*cm-s-\S+/g,"")+e.options.theme.replace(/(^|\s)\s*/g," cm-s-"),er(e)}function Uo(e){Hn(e),vn(e),zr(e)}function Vo(e,t,r){if(!t!=!(r&&r!=Xs)){var n=e.display.dragFunctions,i=t?Ql:ke;i(e.display.scroller,"dragstart",n.start),i(e.display.scroller,"dragenter",n.enter),i(e.display.scroller,"dragover",n.over),i(e.display.scroller,"dragleave",n.leave),i(e.display.scroller,"drop",n.drop)}}function Ko(e){e.options.lineWrapping?(s(e.display.wrapper,"CodeMirror-wrap"),e.display.sizer.style.minWidth="",e.display.sizerWidth=null):(Fl(e.display.wrapper,"CodeMirror-wrap"),we(e)),Cr(e),vn(e),er(e),setTimeout(function(){return en(e)},100)}function jo(e,t){var r=this;if(!(this instanceof jo))return new jo(e,t);this.options=t=t?c(t):{},c(Ys,t,!1),Fn(t);var n=t.value;"string"==typeof n&&(n=new Ds(n,t.mode,null,t.lineSeparator,t.direction)),this.doc=n;var i=new jo.inputStyles[t.inputStyle](this),o=this.display=new T(e,n,i);o.wrapper.CodeMirror=this,Hn(this),Go(this),t.lineWrapping&&(this.display.wrapper.className+=" CodeMirror-wrap"),rn(this),this.state={keyMaps:[],overlays:[],modeGen:0,overwrite:!1,delayingBlurEvent:!1,focused:!1,suppressEdits:!1,pasteIncoming:!1,cutIncoming:!1,selectingText:!1,draggingText:!1,highlight:new Pl,keySeq:null,specialChars:null},t.autofocus&&!Tl&&o.input.focus(),gl&&vl<11&&setTimeout(function(){return r.display.input.reset(!0)},20),Xo(this),eo(),nn(this),this.curOp.forceUpdate=!0,qn(this,n),t.autofocus&&!Tl||this.hasFocus()?setTimeout(u(Hr,this),20):Fr(this);for(var l in _s)_s.hasOwnProperty(l)&&_s[l](r,t[l],Xs);Rr(this),t.finishInit&&t.finishInit(this);for(var s=0;s<$s.length;++s)$s[s](r);on(this),ml&&t.lineWrapping&&"optimizelegibility"==getComputedStyle(o.lineDiv).textRendering&&(o.lineDiv.style.textRendering="auto")}function Xo(e){function t(){i.activeTouch&&(o=setTimeout(function(){return i.activeTouch=null},1e3),(l=i.activeTouch).end=+new Date)}function r(e){if(1!=e.touches.length)return!1;var t=e.touches[0];return t.radiusX<=1&&t.radiusY<=1}function n(e,t){if(null==t.left)return!0;var r=t.left-e.left,n=t.top-e.top;return r*r+n*n>400}var i=e.display;Ql(i.scroller,"mousedown",dn(e,Oo)),gl&&vl<11?Ql(i.scroller,"dblclick",dn(e,function(t){if(!Me(e,t)){var r=Sr(e,t);if(r&&!zo(e,t)&&!Ft(e.display,t)){We(t);var n=e.findWordAt(r);di(e.doc,n.anchor,n.head)}}})):Ql(i.scroller,"dblclick",function(t){return Me(e,t)||We(t)}),Hl||Ql(i.scroller,"contextmenu",function(t){return Ro(e,t)});var o,l={end:0};Ql(i.scroller,"touchstart",function(t){if(!Me(e,t)&&!r(t)&&!zo(e,t)){i.input.ensurePolled(),clearTimeout(o);var n=+new Date;i.activeTouch={start:n,moved:!1,prev:n-l.end<=300?l:null},1==t.touches.length&&(i.activeTouch.left=t.touches[0].pageX,i.activeTouch.top=t.touches[0].pageY)}}),Ql(i.scroller,"touchmove",function(){i.activeTouch&&(i.activeTouch.moved=!0)}),Ql(i.scroller,"touchend",function(r){var o=i.activeTouch;if(o&&!Ft(i,r)&&null!=o.left&&!o.moved&&new Date-o.start<300){var l,s=e.coordsChar(i.activeTouch,"page");l=!o.prev||n(o,o.prev)?new Ts(s,s):!o.prev.prev||n(o,o.prev.prev)?e.findWordAt(s):new Ts(E(s.line,0),U(e.doc,E(s.line+1,0))),e.setSelection(l.anchor,l.head),e.focus(),We(r)}t()}),Ql(i.scroller,"touchcancel",t),Ql(i.scroller,"scroll",function(){i.scroller.clientHeight&&(qr(e,i.scroller.scrollTop),Qr(e,i.scroller.scrollLeft,!0),Te(e,"scroll",e))}),Ql(i.scroller,"mousewheel",function(t){return In(e,t)}),Ql(i.scroller,"DOMMouseScroll",function(t){return In(e,t)}),Ql(i.wrapper,"scroll",function(){return i.wrapper.scrollTop=i.wrapper.scrollLeft=0}),i.dragFunctions={enter:function(t){Me(e,t)||Fe(t)},over:function(t){Me(e,t)||(Zi(e,t),Fe(t))},start:function(t){return qi(e,t)},drop:dn(e,$i),leave:function(t){Me(e,t)||Qi(e)}};var s=i.input.getField();Ql(s,"keyup",function(t){return To.call(e,t)}),Ql(s,"keydown",dn(e,Lo)),Ql(s,"keypress",dn(e,Mo)),Ql(s,"focus",function(t){return Hr(e,t)}),Ql(s,"blur",function(t){return Fr(e,t)})}function Yo(e,t,r,n){var i,o=e.doc;null==r&&(r="add"),"smart"==r&&(o.mode.indent?i=$e(e,t).state:r="prev");var l=e.options.tabSize,s=M(o,t),a=f(s.text,null,l);s.stateAfter&&(s.stateAfter=null);var u,c=s.text.match(/^\s*/)[0];if(n||/\S/.test(s.text)){if("smart"==r&&((u=o.mode.indent(i,s.text.slice(c.length),s.text))==Bl||u>150)){if(!n)return;r="prev"}}else u=0,r="not";"prev"==r?u=t>o.first?f(M(o,t-1).text,null,l):0:"add"==r?u=a+e.options.indentUnit:"subtract"==r?u=a-e.options.indentUnit:"number"==typeof r&&(u=a+r),u=Math.max(0,u);var h="",d=0;if(e.options.indentWithTabs)for(var g=Math.floor(u/l);g;--g)d+=l,h+="\t";if(d<u&&(h+=p(u-d)),h!=c)return Ei(o,h,E(t,0),E(t,c.length),"+input"),s.stateAfter=null,!0;for(var v=0;v<o.sel.ranges.length;v++){var m=o.sel.ranges[v];if(m.head.line==t&&m.head.ch<c.length){var y=E(t,c.length);gi(o,v,new Ts(y,y));break}}}function _o(e){qs=e}function $o(e,t,r,n,i){var o=e.doc;e.display.shift=!1,n||(n=o.sel);var l=e.state.pasteIncoming||"paste"==i,s=es(t),a=null;if(l&&n.ranges.length>1)if(qs&&qs.text.join("\n")==t){if(n.ranges.length%qs.text.length==0){a=[];for(var u=0;u<qs.text.length;u++)a.push(o.splitLines(qs.text[u]))}}else s.length==n.ranges.length&&e.options.pasteLinesPerSelection&&(a=v(s,function(e){return[e]}));for(var c,f=n.ranges.length-1;f>=0;f--){var h=n.ranges[f],d=h.from(),p=h.to();h.empty()&&(r&&r>0?d=E(d.line,d.ch-r):e.state.overwrite&&!l?p=E(p.line,Math.min(M(o,p.line).text.length,p.ch+g(s).length)):qs&&qs.lineWise&&qs.text.join("\n")==t&&(d=p=E(d.line,0))),c=e.curOp.updateInput;var m={from:d,to:p,text:a?a[f%a.length]:s,origin:i||(l?"paste":e.state.cutIncoming?"cut":"+input")};Oi(e.doc,m),bt(e,"inputRead",e,m)}t&&!l&&Zo(e,t),jr(e),e.curOp.updateInput=c,e.curOp.typing=!0,e.state.pasteIncoming=e.state.cutIncoming=!1}function qo(e,t){var r=e.clipboardData&&e.clipboardData.getData("Text");if(r)return e.preventDefault(),t.isReadOnly()||t.options.disableInput||hn(t,function(){return $o(t,r,0,null,"paste")}),!0}function Zo(e,t){if(e.options.electricChars&&e.options.smartIndent)for(var r=e.doc.sel,n=r.ranges.length-1;n>=0;n--){var i=r.ranges[n];if(!(i.head.ch>100||n&&r.ranges[n-1].head.line==i.head.line)){var o=e.getModeAt(i.head),l=!1;if(o.electricChars){for(var s=0;s<o.electricChars.length;s++)if(t.indexOf(o.electricChars.charAt(s))>-1){l=Yo(e,i.head.line,"smart");break}}else o.electricInput&&o.electricInput.test(M(e.doc,i.head.line).text.slice(0,i.head.ch))&&(l=Yo(e,i.head.line,"smart"));l&&bt(e,"electricInput",e,i.head.line)}}}function Qo(e){for(var t=[],r=[],n=0;n<e.doc.sel.ranges.length;n++){var i=e.doc.sel.ranges[n].head.line,o={anchor:E(i,0),head:E(i+1,0)};r.push(o),t.push(e.getRange(o.anchor,o.head))}return{text:t,ranges:r}}function Jo(e,t){e.setAttribute("autocorrect","off"),e.setAttribute("autocapitalize","off"),e.setAttribute("spellcheck",!!t)}function el(){var e=n("textarea",null,null,"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none"),t=n("div",[e],null,"overflow: hidden; position: relative; width: 3px; height: 0px;");return ml?e.style.width="1000px":e.setAttribute("wrap","off"),Ll&&(e.style.border="1px solid black"),Jo(e),t}function tl(e,t,r,n,i){function o(){var n=t.line+r;return!(n<e.first||n>=e.first+e.size)&&(t=new E(n,t.ch,t.sticky),u=M(e,n))}function l(n){var l;if(null==(l=i?go(e.cm,u,t,r):ho(u,t,r))){if(n||!o())return!1;t=po(i,e.cm,u,t.line,r)}else t=l;return!0}var s=t,a=r,u=M(e,t.line);if("char"==n)l();else if("column"==n)l(!0);else if("word"==n||"group"==n)for(var c=null,f="group"==n,h=e.cm&&e.cm.getHelper(t,"wordChars"),d=!0;!(r<0)||l(!d);d=!1){var p=u.text.charAt(t.ch)||"\n",g=x(p,h)?"w":f&&"\n"==p?"n":!f||/\s/.test(p)?null:"p";if(!f||d||g||(g="s"),c&&c!=g){r<0&&(r=1,l(),t.sticky="after");break}if(g&&(c=g),r>0&&!l(!d))break}var v=ki(e,t,s,a,!0);return I(s,v)&&(v.hitSide=!0),v}function rl(e,t,r,n){var i,o=e.doc,l=t.left;if("page"==n){var s=Math.min(e.display.wrapper.clientHeight,window.innerHeight||document.documentElement.clientHeight),a=Math.max(s-.5*mr(e.display),3);i=(r>0?t.bottom:t.top)+r*a}else"line"==n&&(i=r>0?t.bottom+3:t.top-3);for(var u;(u=cr(e,l,i)).outside;){if(r<0?i<=0:i>=o.height){u.hitSide=!0;break}i+=5*r}return u}function nl(e,t){var r=jt(e,t.line);if(!r||r.hidden)return null;var n=M(e.doc,t.line),i=Ut(r,n,t.line),o=Se(n,e.doc.direction),l="left";o&&(l=Ce(o,t.ch)%2?"right":"left");var s=_t(i.map,t.ch,l);return s.offset="right"==s.collapse?s.end:s.start,s}function il(e){for(var t=e;t;t=t.parentNode)if(/CodeMirror-gutter-wrapper/.test(t.className))return!0;return!1}function ol(e,t){return t&&(e.bad=!0),e}function ll(e,t,r,n,i){function o(e){return function(t){return t.id==e}}function l(){c&&(u+=f,c=!1)}function s(e){e&&(l(),u+=e)}function a(t){if(1==t.nodeType){var r=t.getAttribute("cm-text");if(null!=r)return void s(r||t.textContent.replace(/\u200b/g,""));var u,h=t.getAttribute("cm-marker");if(h){var d=e.findMarks(E(n,0),E(i+1,0),o(+h));return void(d.length&&(u=d[0].find(0))&&s(N(e.doc,u.from,u.to).join(f)))}if("false"==t.getAttribute("contenteditable"))return;var p=/^(pre|div|p)$/i.test(t.nodeName);p&&l();for(var g=0;g<t.childNodes.length;g++)a(t.childNodes[g]);p&&(c=!0)}else 3==t.nodeType&&s(t.nodeValue)}for(var u="",c=!1,f=e.doc.lineSeparator();a(t),t!=r;)t=t.nextSibling;return u}function sl(e,t,r){var n;if(t==e.display.lineDiv){if(!(n=e.display.lineDiv.childNodes[r]))return ol(e.clipPos(E(e.display.viewTo-1)),!0);t=null,r=0}else for(n=t;;n=n.parentNode){if(!n||n==e.display.lineDiv)return null;if(n.parentNode&&n.parentNode==e.display.lineDiv)break}for(var i=0;i<e.display.view.length;i++){var o=e.display.view[i];if(o.node==n)return al(o,t,r)}}function al(e,t,r){function n(t,r,n){for(var i=-1;i<(f?f.length:0);i++)for(var o=i<0?c.map:f[i],l=0;l<o.length;l+=3){var s=o[l+2];if(s==t||s==r){var a=W(i<0?e.line:e.rest[i]),u=o[l]+n;return(n<0||s!=t)&&(u=o[l+(n?1:0)]),E(a,u)}}}var i=e.text.firstChild,l=!1;if(!t||!o(i,t))return ol(E(W(e.line),0),!0);if(t==i&&(l=!0,t=i.childNodes[r],r=0,!t)){var s=e.rest?g(e.rest):e.line;return ol(E(W(s),s.text.length),l)}var a=3==t.nodeType?t:null,u=t;for(a||1!=t.childNodes.length||3!=t.firstChild.nodeType||(a=t.firstChild,r&&(r=a.nodeValue.length));u.parentNode!=i;)u=u.parentNode;var c=e.measure,f=c.maps,h=n(a,u,r);if(h)return ol(h,l);for(var d=u.nextSibling,p=a?a.nodeValue.length-r:0;d;d=d.nextSibling){if(h=n(d,d.firstChild,0))return ol(E(h.line,h.ch-p),l);p+=d.textContent.length}for(var v=u.previousSibling,m=r;v;v=v.previousSibling){if(h=n(v,v.firstChild,-1))return ol(E(h.line,h.ch+m),l);m+=v.textContent.length}}var ul=navigator.userAgent,cl=navigator.platform,fl=/gecko\/\d/i.test(ul),hl=/MSIE \d/.test(ul),dl=/Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(ul),pl=/Edge\/(\d+)/.exec(ul),gl=hl||dl||pl,vl=gl&&(hl?document.documentMode||6:+(pl||dl)[1]),ml=!pl&&/WebKit\//.test(ul),yl=ml&&/Qt\/\d+\.\d+/.test(ul),bl=!pl&&/Chrome\//.test(ul),wl=/Opera\//.test(ul),xl=/Apple Computer/.test(navigator.vendor),Cl=/Mac OS X 1\d\D([8-9]|\d\d)\D/.test(ul),Sl=/PhantomJS/.test(ul),Ll=!pl&&/AppleWebKit/.test(ul)&&/Mobile\/\w+/.test(ul),kl=/Android/.test(ul),Tl=Ll||kl||/webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(ul),Ml=Ll||/Mac/.test(cl),Nl=/\bCrOS\b/.test(ul),Ol=/win/i.test(cl),Al=wl&&ul.match(/Version\/(\d*\.\d*)/);Al&&(Al=Number(Al[1])),Al&&Al>=15&&(wl=!1,ml=!0);var Wl,Dl=Ml&&(yl||wl&&(null==Al||Al<12.11)),Hl=fl||gl&&vl>=9,Fl=function(t,r){var n=t.className,i=e(r).exec(n);if(i){var o=n.slice(i.index+i[0].length);t.className=n.slice(0,i.index)+(o?i[1]+o:"")}};Wl=document.createRange?function(e,t,r,n){var i=document.createRange();return i.setEnd(n||e,r),i.setStart(e,t),i}:function(e,t,r){var n=document.body.createTextRange();try{n.moveToElementText(e.parentNode)}catch(e){return n}return n.collapse(!0),n.moveEnd("character",r),n.moveStart("character",t),n};var El=function(e){e.select()};Ll?El=function(e){e.selectionStart=0,e.selectionEnd=e.value.length}:gl&&(El=function(e){try{e.select()}catch(e){}});var Pl=function(){this.id=null};Pl.prototype.set=function(e,t){clearTimeout(this.id),this.id=setTimeout(t,e)};var Il,zl,Rl=30,Bl={toString:function(){return"CodeMirror.Pass"}},Gl={scroll:!1},Ul={origin:"*mouse"},Vl={origin:"+move"},Kl=[""],jl=/[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/,Xl=/[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/,Yl=!1,_l=!1,$l=null,ql=function(){function e(e){return e<=247?r.charAt(e):1424<=e&&e<=1524?"R":1536<=e&&e<=1785?n.charAt(e-1536):1774<=e&&e<=2220?"r":8192<=e&&e<=8203?"w":8204==e?"b":"L"}function t(e,t,r){this.level=e,this.from=t,this.to=r}var r="bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN",n="nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111",i=/[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/,o=/[stwN]/,l=/[LRr]/,s=/[Lb1n]/,a=/[1n]/;return function(r,n){var u="ltr"==n?"L":"R";if(0==r.length||"ltr"==n&&!i.test(r))return!1;for(var c=r.length,f=[],h=0;h<c;++h)f.push(e(r.charCodeAt(h)));for(var d=0,p=u;d<c;++d){var v=f[d];"m"==v?f[d]=p:p=v}for(var m=0,y=u;m<c;++m){var b=f[m];"1"==b&&"r"==y?f[m]="n":l.test(b)&&(y=b,"r"==b&&(f[m]="R"))}for(var w=1,x=f[0];w<c-1;++w){var C=f[w];"+"==C&&"1"==x&&"1"==f[w+1]?f[w]="1":","!=C||x!=f[w+1]||"1"!=x&&"n"!=x||(f[w]=x),x=C}for(var S=0;S<c;++S){var L=f[S];if(","==L)f[S]="N";else if("%"==L){var k=void 0;for(k=S+1;k<c&&"%"==f[k];++k);for(var T=S&&"!"==f[S-1]||k<c&&"1"==f[k]?"1":"N",M=S;M<k;++M)f[M]=T;S=k-1}}for(var N=0,O=u;N<c;++N){var A=f[N];"L"==O&&"1"==A?f[N]="L":l.test(A)&&(O=A)}for(var W=0;W<c;++W)if(o.test(f[W])){var D=void 0;for(D=W+1;D<c&&o.test(f[D]);++D);for(var H="L"==(W?f[W-1]:u),F=H==("L"==(D<c?f[D]:u))?H?"L":"R":u,E=W;E<D;++E)f[E]=F;W=D-1}for(var P,I=[],z=0;z<c;)if(s.test(f[z])){var R=z;for(++z;z<c&&s.test(f[z]);++z);I.push(new t(0,R,z))}else{var B=z,G=I.length;for(++z;z<c&&"L"!=f[z];++z);for(var U=B;U<z;)if(a.test(f[U])){B<U&&I.splice(G,0,new t(1,B,U));var V=U;for(++U;U<z&&a.test(f[U]);++U);I.splice(G,0,new t(2,V,U)),B=U}else++U;B<z&&I.splice(G,0,new t(1,B,z))}return 1==I[0].level&&(P=r.match(/^\s+/))&&(I[0].from=P[0].length,I.unshift(new t(0,0,P[0].length))),1==g(I).level&&(P=r.match(/\s+$/))&&(g(I).to-=P[0].length,I.push(new t(0,c-P[0].length,c))),"rtl"==n?I.reverse():I}}(),Zl=[],Ql=function(e,t,r){if(e.addEventListener)e.addEventListener(t,r,!1);else if(e.attachEvent)e.attachEvent("on"+t,r);else{var n=e._handlers||(e._handlers={});n[t]=(n[t]||Zl).concat(r)}},Jl=function(){if(gl&&vl<9)return!1;var e=n("div");return"draggable"in e||"dragDrop"in e}(),es=3!="\n\nb".split(/\n/).length?function(e){for(var t=0,r=[],n=e.length;t<=n;){var i=e.indexOf("\n",t);-1==i&&(i=e.length);var o=e.slice(t,"\r"==e.charAt(i-1)?i-1:i),l=o.indexOf("\r");-1!=l?(r.push(o.slice(0,l)),t+=l+1):(r.push(o),t=i+1)}return r}:function(e){return e.split(/\r\n?|\n/)},ts=window.getSelection?function(e){try{return e.selectionStart!=e.selectionEnd}catch(e){return!1}}:function(e){var t;try{t=e.ownerDocument.selection.createRange()}catch(e){}return!(!t||t.parentElement()!=e)&&0!=t.compareEndPoints("StartToEnd",t)},rs=function(){var e=n("div");return"oncopy"in e||(e.setAttribute("oncopy","return;"),"function"==typeof e.oncopy)}(),ns=null,is={},os={},ls={},ss=function(e,t,r){this.pos=this.start=0,this.string=e,this.tabSize=t||8,this.lastColumnPos=this.lastColumnValue=0,this.lineStart=0,this.lineOracle=r};ss.prototype.eol=function(){return this.pos>=this.string.length},ss.prototype.sol=function(){return this.pos==this.lineStart},ss.prototype.peek=function(){return this.string.charAt(this.pos)||void 0},ss.prototype.next=function(){if(this.pos<this.string.length)return this.string.charAt(this.pos++)},ss.prototype.eat=function(e){var t=this.string.charAt(this.pos);if("string"==typeof e?t==e:t&&(e.test?e.test(t):e(t)))return++this.pos,t},ss.prototype.eatWhile=function(e){for(var t=this.pos;this.eat(e););return this.pos>t},ss.prototype.eatSpace=function(){for(var e=this,t=this.pos;/[\s\u00a0]/.test(this.string.charAt(this.pos));)++e.pos;return this.pos>t},ss.prototype.skipToEnd=function(){this.pos=this.string.length},ss.prototype.skipTo=function(e){var t=this.string.indexOf(e,this.pos);if(t>-1)return this.pos=t,!0},ss.prototype.backUp=function(e){this.pos-=e},ss.prototype.column=function(){return this.lastColumnPos<this.start&&(this.lastColumnValue=f(this.string,this.start,this.tabSize,this.lastColumnPos,this.lastColumnValue),this.lastColumnPos=this.start),this.lastColumnValue-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.indentation=function(){return f(this.string,null,this.tabSize)-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.match=function(e,t,r){if("string"!=typeof e){var n=this.string.slice(this.pos).match(e);return n&&n.index>0?null:(n&&!1!==t&&(this.pos+=n[0].length),n)}var i=function(e){return r?e.toLowerCase():e};if(i(this.string.substr(this.pos,e.length))==i(e))return!1!==t&&(this.pos+=e.length),!0},ss.prototype.current=function(){return this.string.slice(this.start,this.pos)},ss.prototype.hideFirstChars=function(e,t){this.lineStart+=e;try{return t()}finally{this.lineStart-=e}},ss.prototype.lookAhead=function(e){var t=this.lineOracle;return t&&t.lookAhead(e)};var as=function(e,t){this.state=e,this.lookAhead=t},us=function(e,t,r,n){this.state=t,this.doc=e,this.line=r,this.maxLookAhead=n||0};us.prototype.lookAhead=function(e){var t=this.doc.getLine(this.line+e);return null!=t&&e>this.maxLookAhead&&(this.maxLookAhead=e),t},us.prototype.nextLine=function(){this.line++,this.maxLookAhead>0&&this.maxLookAhead--},us.fromSaved=function(e,t,r){return t instanceof as?new us(e,Ke(e.mode,t.state),r,t.lookAhead):new us(e,Ke(e.mode,t),r)},us.prototype.save=function(e){var t=!1!==e?Ke(this.doc.mode,this.state):this.state;return this.maxLookAhead>0?new as(t,this.maxLookAhead):t};var cs=function(e,t,r){this.start=e.start,this.end=e.pos,this.string=e.current(),this.type=t||null,this.state=r},fs=function(e,t,r){this.text=e,ne(this,t),this.height=r?r(this):1};fs.prototype.lineNo=function(){return W(this)},Ae(fs);var hs,ds={},ps={},gs=null,vs=null,ms={left:0,right:0,top:0,bottom:0},ys=function(e,t,r){this.cm=r;var i=this.vert=n("div",[n("div",null,null,"min-width: 1px")],"CodeMirror-vscrollbar"),o=this.horiz=n("div",[n("div",null,null,"height: 100%; min-height: 1px")],"CodeMirror-hscrollbar");e(i),e(o),Ql(i,"scroll",function(){i.clientHeight&&t(i.scrollTop,"vertical")}),Ql(o,"scroll",function(){o.clientWidth&&t(o.scrollLeft,"horizontal")}),this.checkedZeroWidth=!1,gl&&vl<8&&(this.horiz.style.minHeight=this.vert.style.minWidth="18px")};ys.prototype.update=function(e){var t=e.scrollWidth>e.clientWidth+1,r=e.scrollHeight>e.clientHeight+1,n=e.nativeBarWidth;if(r){this.vert.style.display="block",this.vert.style.bottom=t?n+"px":"0";var i=e.viewHeight-(t?n:0);this.vert.firstChild.style.height=Math.max(0,e.scrollHeight-e.clientHeight+i)+"px"}else this.vert.style.display="",this.vert.firstChild.style.height="0";if(t){this.horiz.style.display="block",this.horiz.style.right=r?n+"px":"0",this.horiz.style.left=e.barLeft+"px";var o=e.viewWidth-e.barLeft-(r?n:0);this.horiz.firstChild.style.width=Math.max(0,e.scrollWidth-e.clientWidth+o)+"px"}else this.horiz.style.display="",this.horiz.firstChild.style.width="0";return!this.checkedZeroWidth&&e.clientHeight>0&&(0==n&&this.zeroWidthHack(),this.checkedZeroWidth=!0),{right:r?n:0,bottom:t?n:0}},ys.prototype.setScrollLeft=function(e){this.horiz.scrollLeft!=e&&(this.horiz.scrollLeft=e),this.disableHoriz&&this.enableZeroWidthBar(this.horiz,this.disableHoriz,"horiz")},ys.prototype.setScrollTop=function(e){this.vert.scrollTop!=e&&(this.vert.scrollTop=e),this.disableVert&&this.enableZeroWidthBar(this.vert,this.disableVert,"vert")},ys.prototype.zeroWidthHack=function(){var e=Ml&&!Cl?"12px":"18px";this.horiz.style.height=this.vert.style.width=e,this.horiz.style.pointerEvents=this.vert.style.pointerEvents="none",this.disableHoriz=new Pl,this.disableVert=new Pl},ys.prototype.enableZeroWidthBar=function(e,t,r){function n(){var i=e.getBoundingClientRect();("vert"==r?document.elementFromPoint(i.right-1,(i.top+i.bottom)/2):document.elementFromPoint((i.right+i.left)/2,i.bottom-1))!=e?e.style.pointerEvents="none":t.set(1e3,n)}e.style.pointerEvents="auto",t.set(1e3,n)},ys.prototype.clear=function(){var e=this.horiz.parentNode;e.removeChild(this.horiz),e.removeChild(this.vert)};var bs=function(){};bs.prototype.update=function(){return{bottom:0,right:0}},bs.prototype.setScrollLeft=function(){},bs.prototype.setScrollTop=function(){},bs.prototype.clear=function(){};var ws={native:ys,null:bs},xs=0,Cs=function(e,t,r){var n=e.display;this.viewport=t,this.visible=Ir(n,e.doc,t),this.editorIsHidden=!n.wrapper.offsetWidth,this.wrapperHeight=n.wrapper.clientHeight,this.wrapperWidth=n.wrapper.clientWidth,this.oldDisplayWidth=Rt(e),this.force=r,this.dims=br(e),this.events=[]};Cs.prototype.signal=function(e,t){Oe(e,t)&&this.events.push(arguments)},Cs.prototype.finish=function(){for(var e=this,t=0;t<this.events.length;t++)Te.apply(null,e.events[t])};var Ss=0,Ls=null;gl?Ls=-.53:fl?Ls=15:bl?Ls=-.7:xl&&(Ls=-1/3);var ks=function(e,t){this.ranges=e,this.primIndex=t};ks.prototype.primary=function(){return this.ranges[this.primIndex]},ks.prototype.equals=function(e){var t=this;if(e==this)return!0;if(e.primIndex!=this.primIndex||e.ranges.length!=this.ranges.length)return!1;for(var r=0;r<this.ranges.length;r++){var n=t.ranges[r],i=e.ranges[r];if(!I(n.anchor,i.anchor)||!I(n.head,i.head))return!1}return!0},ks.prototype.deepCopy=function(){for(var e=this,t=[],r=0;r<this.ranges.length;r++)t[r]=new Ts(z(e.ranges[r].anchor),z(e.ranges[r].head));return new ks(t,this.primIndex)},ks.prototype.somethingSelected=function(){for(var e=this,t=0;t<this.ranges.length;t++)if(!e.ranges[t].empty())return!0;return!1},ks.prototype.contains=function(e,t){var r=this;t||(t=e);for(var n=0;n<this.ranges.length;n++){var i=r.ranges[n];if(P(t,i.from())>=0&&P(e,i.to())<=0)return n}return-1};var Ts=function(e,t){this.anchor=e,this.head=t};Ts.prototype.from=function(){return B(this.anchor,this.head)},Ts.prototype.to=function(){return R(this.anchor,this.head)},Ts.prototype.empty=function(){return this.head.line==this.anchor.line&&this.head.ch==this.anchor.ch},Bi.prototype={chunkSize:function(){return this.lines.length},removeInner:function(e,t){for(var r=this,n=e,i=e+t;n<i;++n){var o=r.lines[n];r.height-=o.height,ot(o),bt(o,"delete")}this.lines.splice(e,t)},collapse:function(e){e.push.apply(e,this.lines)},insertInner:function(e,t,r){var n=this;this.height+=r,this.lines=this.lines.slice(0,e).concat(t).concat(this.lines.slice(e));for(var i=0;i<t.length;++i)t[i].parent=n},iterN:function(e,t,r){for(var n=this,i=e+t;e<i;++e)if(r(n.lines[e]))return!0}},Gi.prototype={chunkSize:function(){return this.size},removeInner:function(e,t){var r=this;this.size-=t;for(var n=0;n<this.children.length;++n){var i=r.children[n],o=i.chunkSize();if(e<o){var l=Math.min(t,o-e),s=i.height;if(i.removeInner(e,l),r.height-=s-i.height,o==l&&(r.children.splice(n--,1),i.parent=null),0==(t-=l))break;e=0}else e-=o}if(this.size-t<25&&(this.children.length>1||!(this.children[0]instanceof Bi))){var a=[];this.collapse(a),this.children=[new Bi(a)],this.children[0].parent=this}},collapse:function(e){for(var t=this,r=0;r<this.children.length;++r)t.children[r].collapse(e)},insertInner:function(e,t,r){var n=this;this.size+=t.length,this.height+=r;for(var i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<=l){if(o.insertInner(e,t,r),o.lines&&o.lines.length>50){for(var s=o.lines.length%25+25,a=s;a<o.lines.length;){var u=new Bi(o.lines.slice(a,a+=25));o.height-=u.height,n.children.splice(++i,0,u),u.parent=n}o.lines=o.lines.slice(0,s),n.maybeSpill()}break}e-=l}},maybeSpill:function(){if(!(this.children.length<=10)){var e=this;do{var t=new Gi(e.children.splice(e.children.length-5,5));if(e.parent){e.size-=t.size,e.height-=t.height;var r=h(e.parent.children,e);e.parent.children.splice(r+1,0,t)}else{var n=new Gi(e.children);n.parent=e,e.children=[n,t],e=n}t.parent=e.parent}while(e.children.length>10);e.parent.maybeSpill()}},iterN:function(e,t,r){for(var n=this,i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<l){var s=Math.min(t,l-e);if(o.iterN(e,s,r))return!0;if(0==(t-=s))break;e=0}else e-=l}}};var Ms=function(e,t,r){var n=this;if(r)for(var i in r)r.hasOwnProperty(i)&&(n[i]=r[i]);this.doc=e,this.node=t};Ms.prototype.clear=function(){var e=this,t=this.doc.cm,r=this.line.widgets,n=this.line,i=W(n);if(null!=i&&r){for(var o=0;o<r.length;++o)r[o]==e&&r.splice(o--,1);r.length||(n.widgets=null);var l=Ht(this);A(n,Math.max(0,n.height-l)),t&&(hn(t,function(){Ui(t,n,-l),mn(t,i,"widget")}),bt(t,"lineWidgetCleared",t,this,i))}},Ms.prototype.changed=function(){var e=this,t=this.height,r=this.doc.cm,n=this.line;this.height=null;var i=Ht(this)-t;i&&(A(n,n.height+i),r&&hn(r,function(){r.curOp.forceUpdate=!0,Ui(r,n,i),bt(r,"lineWidgetChanged",r,e,W(n))}))},Ae(Ms);var Ns=0,Os=function(e,t){this.lines=[],this.type=t,this.doc=e,this.id=++Ns};Os.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){var t=this.doc.cm,r=t&&!t.curOp;if(r&&nn(t),Oe(this,"clear")){var n=this.find();n&&bt(this,"clear",n.from,n.to)}for(var i=null,o=null,l=0;l<this.lines.length;++l){var s=e.lines[l],a=_(s.markedSpans,e);t&&!e.collapsed?mn(t,W(s),"text"):t&&(null!=a.to&&(o=W(s)),null!=a.from&&(i=W(s))),s.markedSpans=$(s.markedSpans,a),null==a.from&&e.collapsed&&!ve(e.doc,s)&&t&&A(s,mr(t.display))}if(t&&this.collapsed&&!t.options.lineWrapping)for(var u=0;u<this.lines.length;++u){var c=fe(e.lines[u]),f=be(c);f>t.display.maxLineLength&&(t.display.maxLine=c,t.display.maxLineLength=f,t.display.maxLineChanged=!0)}null!=i&&t&&this.collapsed&&vn(t,i,o+1),this.lines.length=0,this.explicitlyCleared=!0,this.atomic&&this.doc.cantEdit&&(this.doc.cantEdit=!1,t&&Ci(t.doc)),t&&bt(t,"markerCleared",t,this,i,o),r&&on(t),this.parent&&this.parent.clear()}},Os.prototype.find=function(e,t){var r=this;null==e&&"bookmark"==this.type&&(e=1);for(var n,i,o=0;o<this.lines.length;++o){var l=r.lines[o],s=_(l.markedSpans,r);if(null!=s.from&&(n=E(t?l:W(l),s.from),-1==e))return n;if(null!=s.to&&(i=E(t?l:W(l),s.to),1==e))return i}return n&&{from:n,to:i}},Os.prototype.changed=function(){var e=this,t=this.find(-1,!0),r=this,n=this.doc.cm;t&&n&&hn(n,function(){var i=t.line,o=W(t.line),l=jt(n,o);if(l&&(Qt(l),n.curOp.selectionChanged=n.curOp.forceUpdate=!0),n.curOp.updateMaxLine=!0,!ve(r.doc,i)&&null!=r.height){var s=r.height;r.height=null;var a=Ht(r)-s;a&&A(i,i.height+a)}bt(n,"markerChanged",n,e)})},Os.prototype.attachLine=function(e){if(!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;t.maybeHiddenMarkers&&-1!=h(t.maybeHiddenMarkers,this)||(t.maybeUnhiddenMarkers||(t.maybeUnhiddenMarkers=[])).push(this)}this.lines.push(e)},Os.prototype.detachLine=function(e){if(this.lines.splice(h(this.lines,e),1),!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;(t.maybeHiddenMarkers||(t.maybeHiddenMarkers=[])).push(this)}},Ae(Os);var As=function(e,t){var r=this;this.markers=e,this.primary=t;for(var n=0;n<e.length;++n)e[n].parent=r};As.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){this.explicitlyCleared=!0;for(var t=0;t<this.markers.length;++t)e.markers[t].clear();bt(this,"clear")}},As.prototype.find=function(e,t){return this.primary.find(e,t)},Ae(As);var Ws=0,Ds=function(e,t,r,n,i){if(!(this instanceof Ds))return new Ds(e,t,r,n,i);null==r&&(r=0),Gi.call(this,[new Bi([new fs("",null)])]),this.first=r,this.scrollTop=this.scrollLeft=0,this.cantEdit=!1,this.cleanGeneration=1,this.modeFrontier=this.highlightFrontier=r;var o=E(r,0);this.sel=Rn(o),this.history=new Jn(null),this.id=++Ws,this.modeOption=t,this.lineSep=n,this.direction="rtl"==i?"rtl":"ltr",this.extend=!1,"string"==typeof e&&(e=this.splitLines(e)),_n(this,{from:o,to:o,text:e}),bi(this,Rn(o),Gl)};Ds.prototype=b(Gi.prototype,{constructor:Ds,iter:function(e,t,r){r?this.iterN(e-this.first,t-e,r):this.iterN(this.first,this.first+this.size,e)},insert:function(e,t){for(var r=0,n=0;n<t.length;++n)r+=t[n].height;this.insertInner(e-this.first,t,r)},remove:function(e,t){this.removeInner(e-this.first,t)},getValue:function(e){var t=O(this,this.first,this.first+this.size);return!1===e?t:t.join(e||this.lineSeparator())},setValue:gn(function(e){var t=E(this.first,0),r=this.first+this.size-1;Oi(this,{from:t,to:E(r,M(this,r).text.length),text:this.splitLines(e),origin:"setValue",full:!0},!0),this.cm&&Xr(this.cm,0,0),bi(this,Rn(t),Gl)}),replaceRange:function(e,t,r,n){Ei(this,e,t=U(this,t),r=r?U(this,r):t,n)},getRange:function(e,t,r){var n=N(this,U(this,e),U(this,t));return!1===r?n:n.join(r||this.lineSeparator())},getLine:function(e){var t=this.getLineHandle(e);return t&&t.text},getLineHandle:function(e){if(H(this,e))return M(this,e)},getLineNumber:function(e){return W(e)},getLineHandleVisualStart:function(e){return"number"==typeof e&&(e=M(this,e)),fe(e)},lineCount:function(){return this.size},firstLine:function(){return this.first},lastLine:function(){return this.first+this.size-1},clipPos:function(e){return U(this,e)},getCursor:function(e){var t=this.sel.primary();return null==e||"head"==e?t.head:"anchor"==e?t.anchor:"end"==e||"to"==e||!1===e?t.to():t.from()},listSelections:function(){return this.sel.ranges},somethingSelected:function(){return this.sel.somethingSelected()},setCursor:gn(function(e,t,r){vi(this,U(this,"number"==typeof e?E(e,t||0):e),null,r)}),setSelection:gn(function(e,t,r){vi(this,U(this,e),U(this,t||e),r)}),extendSelection:gn(function(e,t,r){di(this,U(this,e),t&&U(this,t),r)}),extendSelections:gn(function(e,t){pi(this,K(this,e),t)}),extendSelectionsBy:gn(function(e,t){pi(this,K(this,v(this.sel.ranges,e)),t)}),setSelections:gn(function(e,t,r){var n=this;if(e.length){for(var i=[],o=0;o<e.length;o++)i[o]=new Ts(U(n,e[o].anchor),U(n,e[o].head));null==t&&(t=Math.min(e.length-1,this.sel.primIndex)),bi(this,zn(i,t),r)}}),addSelection:gn(function(e,t,r){var n=this.sel.ranges.slice(0);n.push(new Ts(U(this,e),U(this,t||e))),bi(this,zn(n,n.length-1),r)}),getSelection:function(e){for(var t,r=this,n=this.sel.ranges,i=0;i<n.length;i++){var o=N(r,n[i].from(),n[i].to());t=t?t.concat(o):o}return!1===e?t:t.join(e||this.lineSeparator())},getSelections:function(e){for(var t=this,r=[],n=this.sel.ranges,i=0;i<n.length;i++){var o=N(t,n[i].from(),n[i].to());!1!==e&&(o=o.join(e||t.lineSeparator())),r[i]=o}return r},replaceSelection:function(e,t,r){for(var n=[],i=0;i<this.sel.ranges.length;i++)n[i]=e;this.replaceSelections(n,t,r||"+input")},replaceSelections:gn(function(e,t,r){for(var n=this,i=[],o=this.sel,l=0;l<o.ranges.length;l++){var s=o.ranges[l];i[l]={from:s.from(),to:s.to(),text:n.splitLines(e[l]),origin:r}}for(var a=t&&"end"!=t&&Kn(this,i,t),u=i.length-1;u>=0;u--)Oi(n,i[u]);a?yi(this,a):this.cm&&jr(this.cm)}),undo:gn(function(){Wi(this,"undo")}),redo:gn(function(){Wi(this,"redo")}),undoSelection:gn(function(){Wi(this,"undo",!0)}),redoSelection:gn(function(){Wi(this,"redo",!0)}),setExtending:function(e){this.extend=e},getExtending:function(){return this.extend},historySize:function(){for(var e=this.history,t=0,r=0,n=0;n<e.done.length;n++)e.done[n].ranges||++t;for(var i=0;i<e.undone.length;i++)e.undone[i].ranges||++r;return{undo:t,redo:r}},clearHistory:function(){this.history=new Jn(this.history.maxGeneration)},markClean:function(){this.cleanGeneration=this.changeGeneration(!0)},changeGeneration:function(e){return e&&(this.history.lastOp=this.history.lastSelOp=this.history.lastOrigin=null),this.history.generation},isClean:function(e){return this.history.generation==(e||this.cleanGeneration)},getHistory:function(){return{done:fi(this.history.done),undone:fi(this.history.undone)}},setHistory:function(e){var t=this.history=new Jn(this.history.maxGeneration);t.done=fi(e.done.slice(0),null,!0),t.undone=fi(e.undone.slice(0),null,!0)},setGutterMarker:gn(function(e,t,r){return Ri(this,e,"gutter",function(e){var n=e.gutterMarkers||(e.gutterMarkers={});return n[t]=r,!r&&C(n)&&(e.gutterMarkers=null),!0})}),clearGutter:gn(function(e){var t=this;this.iter(function(r){r.gutterMarkers&&r.gutterMarkers[e]&&Ri(t,r,"gutter",function(){return r.gutterMarkers[e]=null,C(r.gutterMarkers)&&(r.gutterMarkers=null),!0})})}),lineInfo:function(e){var t;if("number"==typeof e){if(!H(this,e))return null;if(t=e,!(e=M(this,e)))return null}else if(null==(t=W(e)))return null;return{line:t,handle:e,text:e.text,gutterMarkers:e.gutterMarkers,textClass:e.textClass,bgClass:e.bgClass,wrapClass:e.wrapClass,widgets:e.widgets}},addLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass";if(t[i]){if(e(n).test(t[i]))return!1;t[i]+=" "+n}else t[i]=n;return!0})}),removeLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass",o=t[i];if(!o)return!1;if(null==n)t[i]=null;else{var l=o.match(e(n));if(!l)return!1;var s=l.index+l[0].length;t[i]=o.slice(0,l.index)+(l.index&&s!=o.length?" ":"")+o.slice(s)||null}return!0})}),addLineWidget:gn(function(e,t,r){return Vi(this,e,t,r)}),removeLineWidget:function(e){e.clear()},markText:function(e,t,r){return Ki(this,U(this,e),U(this,t),r,r&&r.type||"range")},setBookmark:function(e,t){var r={replacedWith:t&&(null==t.nodeType?t.widget:t),insertLeft:t&&t.insertLeft,clearWhenEmpty:!1,shared:t&&t.shared,handleMouseEvents:t&&t.handleMouseEvents};return e=U(this,e),Ki(this,e,e,r,"bookmark")},findMarksAt:function(e){var t=[],r=M(this,(e=U(this,e)).line).markedSpans;if(r)for(var n=0;n<r.length;++n){var i=r[n];(null==i.from||i.from<=e.ch)&&(null==i.to||i.to>=e.ch)&&t.push(i.marker.parent||i.marker)}return t},findMarks:function(e,t,r){e=U(this,e),t=U(this,t);var n=[],i=e.line;return this.iter(e.line,t.line+1,function(o){var l=o.markedSpans;if(l)for(var s=0;s<l.length;s++){var a=l[s];null!=a.to&&i==e.line&&e.ch>=a.to||null==a.from&&i!=e.line||null!=a.from&&i==t.line&&a.from>=t.ch||r&&!r(a.marker)||n.push(a.marker.parent||a.marker)}++i}),n},getAllMarks:function(){var e=[];return this.iter(function(t){var r=t.markedSpans;if(r)for(var n=0;n<r.length;++n)null!=r[n].from&&e.push(r[n].marker)}),e},posFromIndex:function(e){var t,r=this.first,n=this.lineSeparator().length;return this.iter(function(i){var o=i.text.length+n;if(o>e)return t=e,!0;e-=o,++r}),U(this,E(r,t))},indexFromPos:function(e){var t=(e=U(this,e)).ch;if(e.line<this.first||e.ch<0)return 0;var r=this.lineSeparator().length;return this.iter(this.first,e.line,function(e){t+=e.text.length+r}),t},copy:function(e){var t=new Ds(O(this,this.first,this.first+this.size),this.modeOption,this.first,this.lineSep,this.direction);return t.scrollTop=this.scrollTop,t.scrollLeft=this.scrollLeft,t.sel=this.sel,t.extend=!1,e&&(t.history.undoDepth=this.history.undoDepth,t.setHistory(this.getHistory())),t},linkedDoc:function(e){e||(e={});var t=this.first,r=this.first+this.size;null!=e.from&&e.from>t&&(t=e.from),null!=e.to&&e.to<r&&(r=e.to);var n=new Ds(O(this,t,r),e.mode||this.modeOption,t,this.lineSep,this.direction);return e.sharedHist&&(n.history=this.history),(this.linked||(this.linked=[])).push({doc:n,sharedHist:e.sharedHist}),n.linked=[{doc:this,isParent:!0,sharedHist:e.sharedHist}],Yi(n,Xi(this)),n},unlinkDoc:function(e){var t=this;if(e instanceof jo&&(e=e.doc),this.linked)for(var r=0;r<this.linked.length;++r)if(t.linked[r].doc==e){t.linked.splice(r,1),e.unlinkDoc(t),_i(Xi(t));break}if(e.history==this.history){var n=[e.id];$n(e,function(e){return n.push(e.id)},!0),e.history=new Jn(null),e.history.done=fi(this.history.done,n),e.history.undone=fi(this.history.undone,n)}},iterLinkedDocs:function(e){$n(this,e)},getMode:function(){return this.mode},getEditor:function(){return this.cm},splitLines:function(e){return this.lineSep?e.split(this.lineSep):es(e)},lineSeparator:function(){return this.lineSep||"\n"},setDirection:gn(function(e){"rtl"!=e&&(e="ltr"),e!=this.direction&&(this.direction=e,this.iter(function(e){return e.order=null}),this.cm&&Qn(this.cm))})}),Ds.prototype.eachLine=Ds.prototype.iter;for(var Hs=0,Fs=!1,Es={3:"Enter",8:"Backspace",9:"Tab",13:"Enter",16:"Shift",17:"Ctrl",18:"Alt",19:"Pause",20:"CapsLock",27:"Esc",32:"Space",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"Left",38:"Up",39:"Right",40:"Down",44:"PrintScrn",45:"Insert",46:"Delete",59:";",61:"=",91:"Mod",92:"Mod",93:"Mod",106:"*",107:"=",109:"-",110:".",111:"/",127:"Delete",173:"-",186:";",187:"=",188:",",189:"-",190:".",191:"/",192:"`",219:"[",220:"\\",221:"]",222:"'",63232:"Up",63233:"Down",63234:"Left",63235:"Right",63272:"Delete",63273:"Home",63275:"End",63276:"PageUp",63277:"PageDown",63302:"Insert"},Ps=0;Ps<10;Ps++)Es[Ps+48]=Es[Ps+96]=String(Ps);for(var Is=65;Is<=90;Is++)Es[Is]=String.fromCharCode(Is);for(var zs=1;zs<=12;zs++)Es[zs+111]=Es[zs+63235]="F"+zs;var Rs={};Rs.basic={Left:"goCharLeft",Right:"goCharRight",Up:"goLineUp",Down:"goLineDown",End:"goLineEnd",Home:"goLineStartSmart",PageUp:"goPageUp",PageDown:"goPageDown",Delete:"delCharAfter",Backspace:"delCharBefore","Shift-Backspace":"delCharBefore",Tab:"defaultTab","Shift-Tab":"indentAuto",Enter:"newlineAndIndent",Insert:"toggleOverwrite",Esc:"singleSelection"},Rs.pcDefault={"Ctrl-A":"selectAll","Ctrl-D":"deleteLine","Ctrl-Z":"undo","Shift-Ctrl-Z":"redo","Ctrl-Y":"redo","Ctrl-Home":"goDocStart","Ctrl-End":"goDocEnd","Ctrl-Up":"goLineUp","Ctrl-Down":"goLineDown","Ctrl-Left":"goGroupLeft","Ctrl-Right":"goGroupRight","Alt-Left":"goLineStart","Alt-Right":"goLineEnd","Ctrl-Backspace":"delGroupBefore","Ctrl-Delete":"delGroupAfter","Ctrl-S":"save","Ctrl-F":"find","Ctrl-G":"findNext","Shift-Ctrl-G":"findPrev","Shift-Ctrl-F":"replace","Shift-Ctrl-R":"replaceAll","Ctrl-[":"indentLess","Ctrl-]":"indentMore","Ctrl-U":"undoSelection","Shift-Ctrl-U":"redoSelection","Alt-U":"redoSelection",fallthrough:"basic"},Rs.emacsy={"Ctrl-F":"goCharRight","Ctrl-B":"goCharLeft","Ctrl-P":"goLineUp","Ctrl-N":"goLineDown","Alt-F":"goWordRight","Alt-B":"goWordLeft","Ctrl-A":"goLineStart","Ctrl-E":"goLineEnd","Ctrl-V":"goPageDown","Shift-Ctrl-V":"goPageUp","Ctrl-D":"delCharAfter","Ctrl-H":"delCharBefore","Alt-D":"delWordAfter","Alt-Backspace":"delWordBefore","Ctrl-K":"killLine","Ctrl-T":"transposeChars","Ctrl-O":"openLine"},Rs.macDefault={"Cmd-A":"selectAll","Cmd-D":"deleteLine","Cmd-Z":"undo","Shift-Cmd-Z":"redo","Cmd-Y":"redo","Cmd-Home":"goDocStart","Cmd-Up":"goDocStart","Cmd-End":"goDocEnd","Cmd-Down":"goDocEnd","Alt-Left":"goGroupLeft","Alt-Right":"goGroupRight","Cmd-Left":"goLineLeft","Cmd-Right":"goLineRight","Alt-Backspace":"delGroupBefore","Ctrl-Alt-Backspace":"delGroupAfter","Alt-Delete":"delGroupAfter","Cmd-S":"save","Cmd-F":"find","Cmd-G":"findNext","Shift-Cmd-G":"findPrev","Cmd-Alt-F":"replace","Shift-Cmd-Alt-F":"replaceAll","Cmd-[":"indentLess","Cmd-]":"indentMore","Cmd-Backspace":"delWrappedLineLeft","Cmd-Delete":"delWrappedLineRight","Cmd-U":"undoSelection","Shift-Cmd-U":"redoSelection","Ctrl-Up":"goDocStart","Ctrl-Down":"goDocEnd",fallthrough:["basic","emacsy"]},Rs.default=Ml?Rs.macDefault:Rs.pcDefault;var Bs={selectAll:Mi,singleSelection:function(e){return e.setSelection(e.getCursor("anchor"),e.getCursor("head"),Gl)},killLine:function(e){return co(e,function(t){if(t.empty()){var r=M(e.doc,t.head.line).text.length;return t.head.ch==r&&t.head.line<e.lastLine()?{from:t.head,to:E(t.head.line+1,0)}:{from:t.head,to:E(t.head.line,r)}}return{from:t.from(),to:t.to()}})},deleteLine:function(e){return co(e,function(t){return{from:E(t.from().line,0),to:U(e.doc,E(t.to().line+1,0))}})},delLineLeft:function(e){return co(e,function(e){return{from:E(e.from().line,0),to:e.from()}})},delWrappedLineLeft:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5;return{from:e.coordsChar({left:0,top:r},"div"),to:t.from()}})},delWrappedLineRight:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5,n=e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div");return{from:t.from(),to:n}})},undo:function(e){return e.undo()},redo:function(e){return e.redo()},undoSelection:function(e){return e.undoSelection()},redoSelection:function(e){return e.redoSelection()},goDocStart:function(e){return e.extendSelection(E(e.firstLine(),0))},goDocEnd:function(e){return e.extendSelection(E(e.lastLine()))},goLineStart:function(e){return e.extendSelectionsBy(function(t){return vo(e,t.head.line)},{origin:"+move",bias:1})},goLineStartSmart:function(e){return e.extendSelectionsBy(function(t){return yo(e,t.head)},{origin:"+move",bias:1})},goLineEnd:function(e){return e.extendSelectionsBy(function(t){return mo(e,t.head.line)},{origin:"+move",bias:-1})},goLineRight:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div")},Vl)},goLineLeft:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:0,top:r},"div")},Vl)},goLineLeftSmart:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5,n=e.coordsChar({left:0,top:r},"div");return n.ch<e.getLine(n.line).search(/\S/)?yo(e,t.head):n},Vl)},goLineUp:function(e){return e.moveV(-1,"line")},goLineDown:function(e){return e.moveV(1,"line")},goPageUp:function(e){return e.moveV(-1,"page")},goPageDown:function(e){return e.moveV(1,"page")},goCharLeft:function(e){return e.moveH(-1,"char")},goCharRight:function(e){return e.moveH(1,"char")},goColumnLeft:function(e){return e.moveH(-1,"column")},goColumnRight:function(e){return e.moveH(1,"column")},goWordLeft:function(e){return e.moveH(-1,"word")},goGroupRight:function(e){return e.moveH(1,"group")},goGroupLeft:function(e){return e.moveH(-1,"group")},goWordRight:function(e){return e.moveH(1,"word")},delCharBefore:function(e){return e.deleteH(-1,"char")},delCharAfter:function(e){return e.deleteH(1,"char")},delWordBefore:function(e){return e.deleteH(-1,"word")},delWordAfter:function(e){return e.deleteH(1,"word")},delGroupBefore:function(e){return e.deleteH(-1,"group")},delGroupAfter:function(e){return e.deleteH(1,"group")},indentAuto:function(e){return e.indentSelection("smart")},indentMore:function(e){return e.indentSelection("add")},indentLess:function(e){return e.indentSelection("subtract")},insertTab:function(e){return e.replaceSelection("\t")},insertSoftTab:function(e){for(var t=[],r=e.listSelections(),n=e.options.tabSize,i=0;i<r.length;i++){var o=r[i].from(),l=f(e.getLine(o.line),o.ch,n);t.push(p(n-l%n))}e.replaceSelections(t)},defaultTab:function(e){e.somethingSelected()?e.indentSelection("add"):e.execCommand("insertTab")},transposeChars:function(e){return hn(e,function(){for(var t=e.listSelections(),r=[],n=0;n<t.length;n++)if(t[n].empty()){var i=t[n].head,o=M(e.doc,i.line).text;if(o)if(i.ch==o.length&&(i=new E(i.line,i.ch-1)),i.ch>0)i=new E(i.line,i.ch+1),e.replaceRange(o.charAt(i.ch-1)+o.charAt(i.ch-2),E(i.line,i.ch-2),i,"+transpose");else if(i.line>e.doc.first){var l=M(e.doc,i.line-1).text;l&&(i=new E(i.line,1),e.replaceRange(o.charAt(0)+e.doc.lineSeparator()+l.charAt(l.length-1),E(i.line-1,l.length-1),i,"+transpose"))}r.push(new Ts(i,i))}e.setSelections(r)})},newlineAndIndent:function(e){return hn(e,function(){for(var t=e.listSelections(),r=t.length-1;r>=0;r--)e.replaceRange(e.doc.lineSeparator(),t[r].anchor,t[r].head,"+input");t=e.listSelections();for(var n=0;n<t.length;n++)e.indentLine(t[n].from().line,null,!0);jr(e)})},openLine:function(e){return e.replaceSelection("\n","start")},toggleOverwrite:function(e){return e.toggleOverwrite()}},Gs=new Pl,Us=null,Vs=function(e,t,r){this.time=e,this.pos=t,this.button=r};Vs.prototype.compare=function(e,t,r){return this.time+400>e&&0==P(t,this.pos)&&r==this.button};var Ks,js,Xs={toString:function(){return"CodeMirror.Init"}},Ys={},_s={};jo.defaults=Ys,jo.optionHandlers=_s;var $s=[];jo.defineInitHook=function(e){return $s.push(e)};var qs=null,Zs=function(e){this.cm=e,this.lastAnchorNode=this.lastAnchorOffset=this.lastFocusNode=this.lastFocusOffset=null,this.polling=new Pl,this.composing=null,this.gracePeriod=!1,this.readDOMTimeout=null};Zs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()}),"cut"==e.type&&i.replaceSelection("",null,"cut");else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type&&i.operation(function(){i.setSelections(t.ranges,0,Gl),i.replaceSelection("",null,"cut")})}if(e.clipboardData){e.clipboardData.clearData();var r=qs.text.join("\n");if(e.clipboardData.setData("Text",r),e.clipboardData.getData("Text")==r)return void e.preventDefault()}var l=el(),s=l.firstChild;i.display.lineSpace.insertBefore(l,i.display.lineSpace.firstChild),s.value=qs.text.join("\n");var a=document.activeElement;El(s),setTimeout(function(){i.display.lineSpace.removeChild(l),a.focus(),a==o&&n.showPrimarySelection()},50)}}var r=this,n=this,i=n.cm,o=n.div=e.lineDiv;Jo(o,i.options.spellcheck),Ql(o,"paste",function(e){Me(i,e)||qo(e,i)||vl<=11&&setTimeout(dn(i,function(){return r.updateFromDOM()}),20)}),Ql(o,"compositionstart",function(e){r.composing={data:e.data,done:!1}}),Ql(o,"compositionupdate",function(e){r.composing||(r.composing={data:e.data,done:!1})}),Ql(o,"compositionend",function(e){r.composing&&(e.data!=r.composing.data&&r.readFromDOMSoon(),r.composing.done=!0)}),Ql(o,"touchstart",function(){return n.forceCompositionEnd()}),Ql(o,"input",function(){r.composing||r.readFromDOMSoon()}),Ql(o,"copy",t),Ql(o,"cut",t)},Zs.prototype.prepareSelection=function(){var e=Tr(this.cm,!1);return e.focus=this.cm.state.focused,e},Zs.prototype.showSelection=function(e,t){e&&this.cm.display.view.length&&((e.focus||t)&&this.showPrimarySelection(),this.showMultipleSelections(e))},Zs.prototype.showPrimarySelection=function(){var e=window.getSelection(),t=this.cm,r=t.doc.sel.primary(),n=r.from(),i=r.to();if(t.display.viewTo==t.display.viewFrom||n.line>=t.display.viewTo||i.line<t.display.viewFrom)e.removeAllRanges();else{var o=sl(t,e.anchorNode,e.anchorOffset),l=sl(t,e.focusNode,e.focusOffset);if(!o||o.bad||!l||l.bad||0!=P(B(o,l),n)||0!=P(R(o,l),i)){var s=t.display.view,a=n.line>=t.display.viewFrom&&nl(t,n)||{node:s[0].measure.map[2],offset:0},u=i.line<t.display.viewTo&&nl(t,i);if(!u){var c=s[s.length-1].measure,f=c.maps?c.maps[c.maps.length-1]:c.map;u={node:f[f.length-1],offset:f[f.length-2]-f[f.length-3]}}if(a&&u){var h,d=e.rangeCount&&e.getRangeAt(0);try{h=Wl(a.node,a.offset,u.offset,u.node)}catch(e){}h&&(!fl&&t.state.focused?(e.collapse(a.node,a.offset),h.collapsed||(e.removeAllRanges(),e.addRange(h))):(e.removeAllRanges(),e.addRange(h)),d&&null==e.anchorNode?e.addRange(d):fl&&this.startGracePeriod()),this.rememberSelection()}else e.removeAllRanges()}}},Zs.prototype.startGracePeriod=function(){var e=this;clearTimeout(this.gracePeriod),this.gracePeriod=setTimeout(function(){e.gracePeriod=!1,e.selectionChanged()&&e.cm.operation(function(){return e.cm.curOp.selectionChanged=!0})},20)},Zs.prototype.showMultipleSelections=function(e){r(this.cm.display.cursorDiv,e.cursors),r(this.cm.display.selectionDiv,e.selection)},Zs.prototype.rememberSelection=function(){var e=window.getSelection();this.lastAnchorNode=e.anchorNode,this.lastAnchorOffset=e.anchorOffset,this.lastFocusNode=e.focusNode,this.lastFocusOffset=e.focusOffset},Zs.prototype.selectionInEditor=function(){var e=window.getSelection();if(!e.rangeCount)return!1;var t=e.getRangeAt(0).commonAncestorContainer;return o(this.div,t)},Zs.prototype.focus=function(){"nocursor"!=this.cm.options.readOnly&&(this.selectionInEditor()||this.showSelection(this.prepareSelection(),!0),this.div.focus())},Zs.prototype.blur=function(){this.div.blur()},Zs.prototype.getField=function(){return this.div},Zs.prototype.supportsTouch=function(){return!0},Zs.prototype.receivedFocus=function(){function e(){t.cm.state.focused&&(t.pollSelection(),t.polling.set(t.cm.options.pollInterval,e))}var t=this;this.selectionInEditor()?this.pollSelection():hn(this.cm,function(){return t.cm.curOp.selectionChanged=!0}),this.polling.set(this.cm.options.pollInterval,e)},Zs.prototype.selectionChanged=function(){var e=window.getSelection();return e.anchorNode!=this.lastAnchorNode||e.anchorOffset!=this.lastAnchorOffset||e.focusNode!=this.lastFocusNode||e.focusOffset!=this.lastFocusOffset},Zs.prototype.pollSelection=function(){if(null==this.readDOMTimeout&&!this.gracePeriod&&this.selectionChanged()){var e=window.getSelection(),t=this.cm;if(kl&&bl&&this.cm.options.gutters.length&&il(e.anchorNode))return this.cm.triggerOnKeyDown({type:"keydown",keyCode:8,preventDefault:Math.abs}),this.blur(),void this.focus();if(!this.composing){this.rememberSelection();var r=sl(t,e.anchorNode,e.anchorOffset),n=sl(t,e.focusNode,e.focusOffset);r&&n&&hn(t,function(){bi(t.doc,Rn(r,n),Gl),(r.bad||n.bad)&&(t.curOp.selectionChanged=!0)})}}},Zs.prototype.pollContent=function(){null!=this.readDOMTimeout&&(clearTimeout(this.readDOMTimeout),this.readDOMTimeout=null);var e=this.cm,t=e.display,r=e.doc.sel.primary(),n=r.from(),i=r.to();if(0==n.ch&&n.line>e.firstLine()&&(n=E(n.line-1,M(e.doc,n.line-1).length)),i.ch==M(e.doc,i.line).text.length&&i.line<e.lastLine()&&(i=E(i.line+1,0)),n.line<t.viewFrom||i.line>t.viewTo-1)return!1;var o,l,s;n.line==t.viewFrom||0==(o=Lr(e,n.line))?(l=W(t.view[0].line),s=t.view[0].node):(l=W(t.view[o].line),s=t.view[o-1].node.nextSibling);var a,u,c=Lr(e,i.line);if(c==t.view.length-1?(a=t.viewTo-1,u=t.lineDiv.lastChild):(a=W(t.view[c+1].line)-1,u=t.view[c+1].node.previousSibling),!s)return!1;for(var f=e.doc.splitLines(ll(e,s,u,l,a)),h=N(e.doc,E(l,0),E(a,M(e.doc,a).text.length));f.length>1&&h.length>1;)if(g(f)==g(h))f.pop(),h.pop(),a--;else{if(f[0]!=h[0])break;f.shift(),h.shift(),l++}for(var d=0,p=0,v=f[0],m=h[0],y=Math.min(v.length,m.length);d<y&&v.charCodeAt(d)==m.charCodeAt(d);)++d;for(var b=g(f),w=g(h),x=Math.min(b.length-(1==f.length?d:0),w.length-(1==h.length?d:0));p<x&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)++p;if(1==f.length&&1==h.length&&l==n.line)for(;d&&d>n.ch&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)d--,p++;f[f.length-1]=b.slice(0,b.length-p).replace(/^\u200b+/,""),f[0]=f[0].slice(d).replace(/\u200b+$/,"");var C=E(l,d),S=E(a,h.length?g(h).length-p:0);return f.length>1||f[0]||P(C,S)?(Ei(e.doc,f,C,S,"+input"),!0):void 0},Zs.prototype.ensurePolled=function(){this.forceCompositionEnd()},Zs.prototype.reset=function(){this.forceCompositionEnd()},Zs.prototype.forceCompositionEnd=function(){this.composing&&(clearTimeout(this.readDOMTimeout),this.composing=null,this.updateFromDOM(),this.div.blur(),this.div.focus())},Zs.prototype.readFromDOMSoon=function(){var e=this;null==this.readDOMTimeout&&(this.readDOMTimeout=setTimeout(function(){if(e.readDOMTimeout=null,e.composing){if(!e.composing.done)return;e.composing=null}e.updateFromDOM()},80))},Zs.prototype.updateFromDOM=function(){var e=this;!this.cm.isReadOnly()&&this.pollContent()||hn(this.cm,function(){return vn(e.cm)})},Zs.prototype.setUneditable=function(e){e.contentEditable="false"},Zs.prototype.onKeyPress=function(e){0!=e.charCode&&(e.preventDefault(),this.cm.isReadOnly()||dn(this.cm,$o)(this.cm,String.fromCharCode(null==e.charCode?e.keyCode:e.charCode),0))},Zs.prototype.readOnlyChanged=function(e){this.div.contentEditable=String("nocursor"!=e)},Zs.prototype.onContextMenu=function(){},Zs.prototype.resetPosition=function(){},Zs.prototype.needsContentAttribute=!0;var Qs=function(e){this.cm=e,this.prevInput="",this.pollingFast=!1,this.polling=new Pl,this.hasSelection=!1,this.composing=null};Qs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()});else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type?i.setSelections(t.ranges,null,Gl):(n.prevInput="",l.value=t.text.join("\n"),El(l))}"cut"==e.type&&(i.state.cutIncoming=!0)}}var r=this,n=this,i=this.cm,o=this.wrapper=el(),l=this.textarea=o.firstChild;e.wrapper.insertBefore(o,e.wrapper.firstChild),Ll&&(l.style.width="0px"),Ql(l,"input",function(){gl&&vl>=9&&r.hasSelection&&(r.hasSelection=null),n.poll()}),Ql(l,"paste",function(e){Me(i,e)||qo(e,i)||(i.state.pasteIncoming=!0,n.fastPoll())}),Ql(l,"cut",t),Ql(l,"copy",t),Ql(e.scroller,"paste",function(t){Ft(e,t)||Me(i,t)||(i.state.pasteIncoming=!0,n.focus())}),Ql(e.lineSpace,"selectstart",function(t){Ft(e,t)||We(t)}),Ql(l,"compositionstart",function(){var e=i.getCursor("from");n.composing&&n.composing.range.clear(),n.composing={start:e,range:i.markText(e,i.getCursor("to"),{className:"CodeMirror-composing"})}}),Ql(l,"compositionend",function(){n.composing&&(n.poll(),n.composing.range.clear(),n.composing=null)})},Qs.prototype.prepareSelection=function(){var e=this.cm,t=e.display,r=e.doc,n=Tr(e);if(e.options.moveInputWithCursor){var i=sr(e,r.sel.primary().head,"div"),o=t.wrapper.getBoundingClientRect(),l=t.lineDiv.getBoundingClientRect();n.teTop=Math.max(0,Math.min(t.wrapper.clientHeight-10,i.top+l.top-o.top)),n.teLeft=Math.max(0,Math.min(t.wrapper.clientWidth-10,i.left+l.left-o.left))}return n},Qs.prototype.showSelection=function(e){var t=this.cm.display;r(t.cursorDiv,e.cursors),r(t.selectionDiv,e.selection),null!=e.teTop&&(this.wrapper.style.top=e.teTop+"px",this.wrapper.style.left=e.teLeft+"px")},Qs.prototype.reset=function(e){if(!this.contextMenuPending&&!this.composing){var t=this.cm;if(t.somethingSelected()){this.prevInput="";var r=t.getSelection();this.textarea.value=r,t.state.focused&&El(this.textarea),gl&&vl>=9&&(this.hasSelection=r)}else e||(this.prevInput=this.textarea.value="",gl&&vl>=9&&(this.hasSelection=null))}},Qs.prototype.getField=function(){return this.textarea},Qs.prototype.supportsTouch=function(){return!1},Qs.prototype.focus=function(){if("nocursor"!=this.cm.options.readOnly&&(!Tl||l()!=this.textarea))try{this.textarea.focus()}catch(e){}},Qs.prototype.blur=function(){this.textarea.blur()},Qs.prototype.resetPosition=function(){this.wrapper.style.top=this.wrapper.style.left=0},Qs.prototype.receivedFocus=function(){this.slowPoll()},Qs.prototype.slowPoll=function(){var e=this;this.pollingFast||this.polling.set(this.cm.options.pollInterval,function(){e.poll(),e.cm.state.focused&&e.slowPoll()})},Qs.prototype.fastPoll=function(){function e(){r.poll()||t?(r.pollingFast=!1,r.slowPoll()):(t=!0,r.polling.set(60,e))}var t=!1,r=this;r.pollingFast=!0,r.polling.set(20,e)},Qs.prototype.poll=function(){var e=this,t=this.cm,r=this.textarea,n=this.prevInput;if(this.contextMenuPending||!t.state.focused||ts(r)&&!n&&!this.composing||t.isReadOnly()||t.options.disableInput||t.state.keySeq)return!1;var i=r.value;if(i==n&&!t.somethingSelected())return!1;if(gl&&vl>=9&&this.hasSelection===i||Ml&&/[\uf700-\uf7ff]/.test(i))return t.display.input.reset(),!1;if(t.doc.sel==t.display.selForContextMenu){var o=i.charCodeAt(0);if(8203!=o||n||(n="​"),8666==o)return this.reset(),this.cm.execCommand("undo")}for(var l=0,s=Math.min(n.length,i.length);l<s&&n.charCodeAt(l)==i.charCodeAt(l);)++l;return hn(t,function(){$o(t,i.slice(l),n.length-l,null,e.composing?"*compose":null),i.length>1e3||i.indexOf("\n")>-1?r.value=e.prevInput="":e.prevInput=i,e.composing&&(e.composing.range.clear(),e.composing.range=t.markText(e.composing.start,t.getCursor("to"),{className:"CodeMirror-composing"}))}),!0},Qs.prototype.ensurePolled=function(){this.pollingFast&&this.poll()&&(this.pollingFast=!1)},Qs.prototype.onKeyPress=function(){gl&&vl>=9&&(this.hasSelection=null),this.fastPoll()},Qs.prototype.onContextMenu=function(e){function t(){if(null!=l.selectionStart){var e=i.somethingSelected(),t="​"+(e?l.value:"");l.value="⇚",l.value=t,n.prevInput=e?"":"​",l.selectionStart=1,l.selectionEnd=t.length,o.selForContextMenu=i.doc.sel}}function r(){if(n.contextMenuPending=!1,n.wrapper.style.cssText=c,l.style.cssText=u,gl&&vl<9&&o.scrollbars.setScrollTop(o.scroller.scrollTop=a),null!=l.selectionStart){(!gl||gl&&vl<9)&&t();var e=0,r=function(){o.selForContextMenu==i.doc.sel&&0==l.selectionStart&&l.selectionEnd>0&&"​"==n.prevInput?dn(i,Mi)(i):e++<10?o.detectingSelectAll=setTimeout(r,500):(o.selForContextMenu=null,o.input.reset())};o.detectingSelectAll=setTimeout(r,200)}}var n=this,i=n.cm,o=i.display,l=n.textarea,s=Sr(i,e),a=o.scroller.scrollTop;if(s&&!wl){i.options.resetSelectionOnContextMenu&&-1==i.doc.sel.contains(s)&&dn(i,bi)(i.doc,Rn(s),Gl);var u=l.style.cssText,c=n.wrapper.style.cssText;n.wrapper.style.cssText="position: absolute";var f=n.wrapper.getBoundingClientRect();l.style.cssText="position: absolute; width: 30px; height: 30px;\n      top: "+(e.clientY-f.top-5)+"px; left: "+(e.clientX-f.left-5)+"px;\n      z-index: 1000; background: "+(gl?"rgba(255, 255, 255, .05)":"transparent")+";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";var h;if(ml&&(h=window.scrollY),o.input.focus(),ml&&window.scrollTo(null,h),o.input.reset(),i.somethingSelected()||(l.value=n.prevInput=" "),n.contextMenuPending=!0,o.selForContextMenu=i.doc.sel,clearTimeout(o.detectingSelectAll),gl&&vl>=9&&t(),Hl){Fe(e);var d=function(){ke(window,"mouseup",d),setTimeout(r,20)};Ql(window,"mouseup",d)}else setTimeout(r,50)}},Qs.prototype.readOnlyChanged=function(e){e||this.reset(),this.textarea.disabled="nocursor"==e},Qs.prototype.setUneditable=function(){},Qs.prototype.needsContentAttribute=!1,function(e){function t(t,n,i,o){e.defaults[t]=n,i&&(r[t]=o?function(e,t,r){r!=Xs&&i(e,t,r)}:i)}var r=e.optionHandlers;e.defineOption=t,e.Init=Xs,t("value","",function(e,t){return e.setValue(t)},!0),t("mode",null,function(e,t){e.doc.modeOption=t,jn(e)},!0),t("indentUnit",2,jn,!0),t("indentWithTabs",!1),t("smartIndent",!0),t("tabSize",4,function(e){Xn(e),er(e),vn(e)},!0),t("lineSeparator",null,function(e,t){if(e.doc.lineSep=t,t){var r=[],n=e.doc.first;e.doc.iter(function(e){for(var i=0;;){var o=e.text.indexOf(t,i);if(-1==o)break;i=o+t.length,r.push(E(n,o))}n++});for(var i=r.length-1;i>=0;i--)Ei(e.doc,t,r[i],E(r[i].line,r[i].ch+t.length))}}),t("specialChars",/[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff]/g,function(e,t,r){e.state.specialChars=new RegExp(t.source+(t.test("\t")?"":"|\t"),"g"),r!=Xs&&e.refresh()}),t("specialCharPlaceholder",at,function(e){return e.refresh()},!0),t("electricChars",!0),t("inputStyle",Tl?"contenteditable":"textarea",function(){throw new Error("inputStyle can not (yet) be changed in a running editor")},!0),t("spellcheck",!1,function(e,t){return e.getInputField().spellcheck=t},!0),t("rtlMoveVisually",!Ol),t("wholeLineUpdateBefore",!0),t("theme","default",function(e){Go(e),Uo(e)},!0),t("keyMap","default",function(e,t,r){var n=uo(t),i=r!=Xs&&uo(r);i&&i.detach&&i.detach(e,n),n.attach&&n.attach(e,i||null)}),t("extraKeys",null),t("configureMouse",null),t("lineWrapping",!1,Ko,!0),t("gutters",[],function(e){Fn(e.options),Uo(e)},!0),t("fixedGutter",!0,function(e,t){e.display.gutters.style.left=t?wr(e.display)+"px":"0",e.refresh()},!0),t("coverGutterNextToScrollbar",!1,function(e){return en(e)},!0),t("scrollbarStyle","native",function(e){rn(e),en(e),e.display.scrollbars.setScrollTop(e.doc.scrollTop),e.display.scrollbars.setScrollLeft(e.doc.scrollLeft)},!0),t("lineNumbers",!1,function(e){Fn(e.options),Uo(e)},!0),t("firstLineNumber",1,Uo,!0),t("lineNumberFormatter",function(e){return e},Uo,!0),t("showCursorWhenSelecting",!1,kr,!0),t("resetSelectionOnContextMenu",!0),t("lineWiseCopyCut",!0),t("pasteLinesPerSelection",!0),t("readOnly",!1,function(e,t){"nocursor"==t&&(Fr(e),e.display.input.blur()),e.display.input.readOnlyChanged(t)}),t("disableInput",!1,function(e,t){t||e.display.input.reset()},!0),t("dragDrop",!0,Vo),t("allowDropFileTypes",null),t("cursorBlinkRate",530),t("cursorScrollMargin",0),t("cursorHeight",1,kr,!0),t("singleCursorHeightPerLine",!0,kr,!0),t("workTime",100),t("workDelay",100),t("flattenSpans",!0,Xn,!0),t("addModeClass",!1,Xn,!0),t("pollInterval",100),t("undoDepth",200,function(e,t){return e.doc.history.undoDepth=t}),t("historyEventDelay",1250),t("viewportMargin",10,function(e){return e.refresh()},!0),t("maxHighlightLength",1e4,Xn,!0),t("moveInputWithCursor",!0,function(e,t){t||e.display.input.resetPosition()}),t("tabindex",null,function(e,t){return e.display.input.getField().tabIndex=t||""}),t("autofocus",null),t("direction","ltr",function(e,t){return e.doc.setDirection(t)},!0)}(jo),function(e){var t=e.optionHandlers,r=e.helpers={};e.prototype={constructor:e,focus:function(){window.focus(),this.display.input.focus()},setOption:function(e,r){var n=this.options,i=n[e];n[e]==r&&"mode"!=e||(n[e]=r,t.hasOwnProperty(e)&&dn(this,t[e])(this,r,i),Te(this,"optionChange",this,e))},getOption:function(e){return this.options[e]},getDoc:function(){return this.doc},addKeyMap:function(e,t){this.state.keyMaps[t?"push":"unshift"](uo(e))},removeKeyMap:function(e){for(var t=this.state.keyMaps,r=0;r<t.length;++r)if(t[r]==e||t[r].name==e)return t.splice(r,1),!0},addOverlay:pn(function(t,r){var n=t.token?t:e.getMode(this.options,t);if(n.startState)throw new Error("Overlays may not be stateful.");m(this.state.overlays,{mode:n,modeSpec:t,opaque:r&&r.opaque,priority:r&&r.priority||0},function(e){return e.priority}),this.state.modeGen++,vn(this)}),removeOverlay:pn(function(e){for(var t=this,r=this.state.overlays,n=0;n<r.length;++n){var i=r[n].modeSpec;if(i==e||"string"==typeof e&&i.name==e)return r.splice(n,1),t.state.modeGen++,void vn(t)}}),indentLine:pn(function(e,t,r){"string"!=typeof t&&"number"!=typeof t&&(t=null==t?this.options.smartIndent?"smart":"prev":t?"add":"subtract"),H(this.doc,e)&&Yo(this,e,t,r)}),indentSelection:pn(function(e){for(var t=this,r=this.doc.sel.ranges,n=-1,i=0;i<r.length;i++){var o=r[i];if(o.empty())o.head.line>n&&(Yo(t,o.head.line,e,!0),n=o.head.line,i==t.doc.sel.primIndex&&jr(t));else{var l=o.from(),s=o.to(),a=Math.max(n,l.line);n=Math.min(t.lastLine(),s.line-(s.ch?0:1))+1;for(var u=a;u<n;++u)Yo(t,u,e);var c=t.doc.sel.ranges;0==l.ch&&r.length==c.length&&c[i].from().ch>0&&gi(t.doc,i,new Ts(l,c[i].to()),Gl)}}}),getTokenAt:function(e,t){return Je(this,e,t)},getLineTokens:function(e,t){return Je(this,E(e),t,!0)},getTokenTypeAt:function(e){e=U(this.doc,e);var t,r=_e(this,M(this.doc,e.line)),n=0,i=(r.length-1)/2,o=e.ch;if(0==o)t=r[2];else for(;;){var l=n+i>>1;if((l?r[2*l-1]:0)>=o)i=l;else{if(!(r[2*l+1]<o)){t=r[2*l+2];break}n=l+1}}var s=t?t.indexOf("overlay "):-1;return s<0?t:0==s?null:t.slice(0,s-1)},getModeAt:function(t){var r=this.doc.mode;return r.innerMode?e.innerMode(r,this.getTokenAt(t).state).mode:r},getHelper:function(e,t){return this.getHelpers(e,t)[0]},getHelpers:function(e,t){var n=this,i=[];if(!r.hasOwnProperty(t))return i;var o=r[t],l=this.getModeAt(e);if("string"==typeof l[t])o[l[t]]&&i.push(o[l[t]]);else if(l[t])for(var s=0;s<l[t].length;s++){var a=o[l[t][s]];a&&i.push(a)}else l.helperType&&o[l.helperType]?i.push(o[l.helperType]):o[l.name]&&i.push(o[l.name]);for(var u=0;u<o._global.length;u++){var c=o._global[u];c.pred(l,n)&&-1==h(i,c.val)&&i.push(c.val)}return i},getStateAfter:function(e,t){var r=this.doc;return e=G(r,null==e?r.first+r.size-1:e),$e(this,e+1,t).state},cursorCoords:function(e,t){var r,n=this.doc.sel.primary();return r=null==e?n.head:"object"==typeof e?U(this.doc,e):e?n.from():n.to(),sr(this,r,t||"page")},charCoords:function(e,t){return lr(this,U(this.doc,e),t||"page")},coordsChar:function(e,t){return e=or(this,e,t||"page"),cr(this,e.left,e.top)},lineAtHeight:function(e,t){return e=or(this,{top:e,left:0},t||"page").top,D(this.doc,e+this.display.viewOffset)},heightAtLine:function(e,t,r){var n,i=!1;if("number"==typeof e){var o=this.doc.first+this.doc.size-1;e<this.doc.first?e=this.doc.first:e>o&&(e=o,i=!0),n=M(this.doc,e)}else n=e;return ir(this,n,{top:0,left:0},t||"page",r||i).top+(i?this.doc.height-ye(n):0)},defaultTextHeight:function(){return mr(this.display)},defaultCharWidth:function(){return yr(this.display)},getViewport:function(){return{from:this.display.viewFrom,to:this.display.viewTo}},addWidget:function(e,t,r,n,i){var o=this.display,l=(e=sr(this,U(this.doc,e))).bottom,s=e.left;if(t.style.position="absolute",t.setAttribute("cm-ignore-events","true"),this.display.input.setUneditable(t),o.sizer.appendChild(t),"over"==n)l=e.top;else if("above"==n||"near"==n){var a=Math.max(o.wrapper.clientHeight,this.doc.height),u=Math.max(o.sizer.clientWidth,o.lineSpace.clientWidth);("above"==n||e.bottom+t.offsetHeight>a)&&e.top>t.offsetHeight?l=e.top-t.offsetHeight:e.bottom+t.offsetHeight<=a&&(l=e.bottom),s+t.offsetWidth>u&&(s=u-t.offsetWidth)}t.style.top=l+"px",t.style.left=t.style.right="","right"==i?(s=o.sizer.clientWidth-t.offsetWidth,t.style.right="0px"):("left"==i?s=0:"middle"==i&&(s=(o.sizer.clientWidth-t.offsetWidth)/2),t.style.left=s+"px"),r&&Ur(this,{left:s,top:l,right:s+t.offsetWidth,bottom:l+t.offsetHeight})},triggerOnKeyDown:pn(Lo),triggerOnKeyPress:pn(Mo),triggerOnKeyUp:To,triggerOnMouseDown:pn(Oo),execCommand:function(e){if(Bs.hasOwnProperty(e))return Bs[e].call(null,this)},triggerElectric:pn(function(e){Zo(this,e)}),findPosH:function(e,t,r,n){var i=this,o=1;t<0&&(o=-1,t=-t);for(var l=U(this.doc,e),s=0;s<t&&!(l=tl(i.doc,l,o,r,n)).hitSide;++s);return l},moveH:pn(function(e,t){var r=this;this.extendSelectionsBy(function(n){return r.display.shift||r.doc.extend||n.empty()?tl(r.doc,n.head,e,t,r.options.rtlMoveVisually):e<0?n.from():n.to()},Vl)}),deleteH:pn(function(e,t){var r=this.doc.sel,n=this.doc;r.somethingSelected()?n.replaceSelection("",null,"+delete"):co(this,function(r){var i=tl(n,r.head,e,t,!1);return e<0?{from:i,to:r.head}:{from:r.head,to:i}})}),findPosV:function(e,t,r,n){var i=this,o=1,l=n;t<0&&(o=-1,t=-t);for(var s=U(this.doc,e),a=0;a<t;++a){var u=sr(i,s,"div");if(null==l?l=u.left:u.left=l,(s=rl(i,u,o,r)).hitSide)break}return s},moveV:pn(function(e,t){var r=this,n=this.doc,i=[],o=!this.display.shift&&!n.extend&&n.sel.somethingSelected();if(n.extendSelectionsBy(function(l){if(o)return e<0?l.from():l.to();var s=sr(r,l.head,"div");null!=l.goalColumn&&(s.left=l.goalColumn),i.push(s.left);var a=rl(r,s,e,t);return"page"==t&&l==n.sel.primary()&&Kr(r,lr(r,a,"div").top-s.top),a},Vl),i.length)for(var l=0;l<n.sel.ranges.length;l++)n.sel.ranges[l].goalColumn=i[l]}),findWordAt:function(e){var t=M(this.doc,e.line).text,r=e.ch,n=e.ch;if(t){var i=this.getHelper(e,"wordChars");"before"!=e.sticky&&n!=t.length||!r?++n:--r;for(var o=t.charAt(r),l=x(o,i)?function(e){return x(e,i)}:/\s/.test(o)?function(e){return/\s/.test(e)}:function(e){return!/\s/.test(e)&&!x(e)};r>0&&l(t.charAt(r-1));)--r;for(;n<t.length&&l(t.charAt(n));)++n}return new Ts(E(e.line,r),E(e.line,n))},toggleOverwrite:function(e){null!=e&&e==this.state.overwrite||((this.state.overwrite=!this.state.overwrite)?s(this.display.cursorDiv,"CodeMirror-overwrite"):Fl(this.display.cursorDiv,"CodeMirror-overwrite"),Te(this,"overwriteToggle",this,this.state.overwrite))},hasFocus:function(){return this.display.input.getField()==l()},isReadOnly:function(){return!(!this.options.readOnly&&!this.doc.cantEdit)},scrollTo:pn(function(e,t){Xr(this,e,t)}),getScrollInfo:function(){var e=this.display.scroller;return{left:e.scrollLeft,top:e.scrollTop,height:e.scrollHeight-zt(this)-this.display.barHeight,width:e.scrollWidth-zt(this)-this.display.barWidth,clientHeight:Bt(this),clientWidth:Rt(this)}},scrollIntoView:pn(function(e,t){null==e?(e={from:this.doc.sel.primary().head,to:null},null==t&&(t=this.options.cursorScrollMargin)):"number"==typeof e?e={from:E(e,0),to:null}:null==e.from&&(e={from:e,to:null}),e.to||(e.to=e.from),e.margin=t||0,null!=e.from.line?Yr(this,e):$r(this,e.from,e.to,e.margin)}),setSize:pn(function(e,t){var r=this,n=function(e){return"number"==typeof e||/^\d+$/.test(String(e))?e+"px":e};null!=e&&(this.display.wrapper.style.width=n(e)),null!=t&&(this.display.wrapper.style.height=n(t)),this.options.lineWrapping&&Jt(this);var i=this.display.viewFrom;this.doc.iter(i,this.display.viewTo,function(e){if(e.widgets)for(var t=0;t<e.widgets.length;t++)if(e.widgets[t].noHScroll){mn(r,i,"widget");break}++i}),this.curOp.forceUpdate=!0,Te(this,"refresh",this)}),operation:function(e){return hn(this,e)},startOperation:function(){return nn(this)},endOperation:function(){return on(this)},refresh:pn(function(){var e=this.display.cachedTextHeight;vn(this),this.curOp.forceUpdate=!0,er(this),Xr(this,this.doc.scrollLeft,this.doc.scrollTop),Wn(this),(null==e||Math.abs(e-mr(this.display))>.5)&&Cr(this),Te(this,"refresh",this)}),swapDoc:pn(function(e){var t=this.doc;return t.cm=null,qn(this,e),er(this),this.display.input.reset(),Xr(this,e.scrollLeft,e.scrollTop),this.curOp.forceScroll=!0,bt(this,"swapDoc",this,t),t}),getInputField:function(){return this.display.input.getField()},getWrapperElement:function(){return this.display.wrapper},getScrollerElement:function(){return this.display.scroller},getGutterElement:function(){return this.display.gutters}},Ae(e),e.registerHelper=function(t,n,i){r.hasOwnProperty(t)||(r[t]=e[t]={_global:[]}),r[t][n]=i},e.registerGlobalHelper=function(t,n,i,o){e.registerHelper(t,n,o),r[t]._global.push({pred:i,val:o})}}(jo);var Js="iter insert remove copy getEditor constructor".split(" ");for(var ea in Ds.prototype)Ds.prototype.hasOwnProperty(ea)&&h(Js,ea)<0&&(jo.prototype[ea]=function(e){return function(){return e.apply(this.doc,arguments)}}(Ds.prototype[ea]));return Ae(Ds),jo.inputStyles={textarea:Qs,contenteditable:Zs},jo.defineMode=function(e){jo.defaults.mode||"null"==e||(jo.defaults.mode=e),Be.apply(this,arguments)},jo.defineMIME=function(e,t){os[e]=t},jo.defineMode("null",function(){return{token:function(e){return e.skipToEnd()}}}),jo.defineMIME("text/plain","null"),jo.defineExtension=function(e,t){jo.prototype[e]=t},jo.defineDocExtension=function(e,t){Ds.prototype[e]=t},jo.fromTextArea=function(e,t){function r(){e.value=a.getValue()}if(t=t?c(t):{},t.value=e.value,!t.tabindex&&e.tabIndex&&(t.tabindex=e.tabIndex),!t.placeholder&&e.placeholder&&(t.placeholder=e.placeholder),null==t.autofocus){var n=l();t.autofocus=n==e||null!=e.getAttribute("autofocus")&&n==document.body}var i;if(e.form&&(Ql(e.form,"submit",r),!t.leaveSubmitMethodAlone)){var o=e.form;i=o.submit;try{var s=o.submit=function(){r(),o.submit=i,o.submit(),o.submit=s}}catch(e){}}t.finishInit=function(t){t.save=r,t.getTextArea=function(){return e},t.toTextArea=function(){t.toTextArea=isNaN,r(),e.parentNode.removeChild(t.getWrapperElement()),e.style.display="",e.form&&(ke(e.form,"submit",r),"function"==typeof e.form.submit&&(e.form.submit=i))}},e.style.display="none";var a=jo(function(t){return e.parentNode.insertBefore(t,e.nextSibling)},t);return a},function(e){e.off=ke,e.on=Ql,e.wheelEventPixels=Pn,e.Doc=Ds,e.splitLines=es,e.countColumn=f,e.findColumn=d,e.isWordChar=w,e.Pass=Bl,e.signal=Te,e.Line=fs,e.changeEnd=Bn,e.scrollbarModel=ws,e.Pos=E,e.cmpPos=P,e.modes=is,e.mimeModes=os,e.resolveMode=Ge,e.getMode=Ue,e.modeExtensions=ls,e.extendMode=Ve,e.copyState=Ke,e.startState=Xe,e.innerMode=je,e.commands=Bs,e.keyMap=Rs,e.keyName=ao,e.isModifierKey=lo,e.lookupKey=oo,e.normalizeKeyMap=io,e.StringStream=ss,e.SharedTextMarker=As,e.TextMarker=Os,e.LineWidget=Ms,e.e_preventDefault=We,e.e_stopPropagation=De,e.e_stop=Fe,e.addClass=s,e.contains=o,e.rmClass=Fl,e.keyNames=Es}(jo),jo.version="5.30.0",jo});
      !function(e){"object"==typeof exports&&"object"==typeof module?e(require("../../lib/codemirror")):"function"==typeof define&&define.amd?define(["../../lib/codemirror"],e):e(CodeMirror)}(function(e){"use strict";function t(e,t,n,r,o,a){this.indented=e,this.column=t,this.type=n,this.info=r,this.align=o,this.prev=a}function n(e,n,r,o){var a=e.indented;return e.context&&"statement"==e.context.type&&"statement"!=r&&(a=e.context.indented),e.context=new t(a,n,r,o,null,e.context)}function r(e){var t=e.context.type;return")"!=t&&"]"!=t&&"}"!=t||(e.indented=e.context.indented),e.context=e.context.prev}function o(e,t,n){return"variable"==t.prevToken||"type"==t.prevToken||(!!/\S(?:[^- ]>|[*\]])\s*$|\*$/.test(e.string.slice(0,n))||(!(!t.typeAtEndOfLine||e.column()!=e.indentation())||void 0))}function a(e){for(;;){if(!e||"top"==e.type)return!0;if("}"==e.type&&"namespace"!=e.prev.info)return!1;e=e.prev}}function i(e){for(var t={},n=e.split(" "),r=0;r<n.length;++r)t[n[r]]=!0;return t}function l(e,t){return"function"==typeof e?e(t):e.propertyIsEnumerable(t)}function s(e,t){if(!t.startOfLine)return!1;for(var n,r=null;n=e.peek();){if("\\"==n&&e.match(/^.$/)){r=s;break}if("/"==n&&e.match(/^\/[\/\*]/,!1))break;e.next()}return t.tokenize=r,"meta"}function c(e,t){return"type"==t.prevToken&&"type"}function u(e){return e.eatWhile(/[\w\.']/),"number"}function d(e,t){if(e.backUp(1),e.match(/(R|u8R|uR|UR|LR)/)){var n=e.match(/"([^\s\\()]{0,16})\(/);return!!n&&(t.cpp11RawStringDelim=n[1],t.tokenize=m,m(e,t))}return e.match(/(u8|u|U|L)/)?!!e.match(/["']/,!1)&&"string":(e.next(),!1)}function f(e){var t=/(\w+)::~?(\w+)$/.exec(e);return t&&t[1]==t[2]}function p(e,t){for(var n;null!=(n=e.next());)if('"'==n&&!e.eat('"')){t.tokenize=null;break}return"string"}function m(e,t){var n=t.cpp11RawStringDelim.replace(/[^\w\s]/g,"\\$&");return e.match(new RegExp(".*?\\)"+n+'"'))?t.tokenize=null:e.skipToEnd(),"string"}function h(t,n){function r(e){if(e)for(var t in e)e.hasOwnProperty(t)&&o.push(t)}"string"==typeof t&&(t=[t]);var o=[];r(n.keywords),r(n.types),r(n.builtin),r(n.atoms),o.length&&(n.helperType=t[0],e.registerHelper("hintWords",t[0],o));for(var a=0;a<t.length;++a)e.defineMIME(t[a],n)}function g(e,t){for(var n=!1;!e.eol();){if(!n&&e.match('"""')){t.tokenize=null;break}n="\\"==e.next()&&!n}return"string"}function y(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!e&&!o&&t.match('"')){a=!0;break}if(e&&t.match('"""')){a=!0;break}r=t.next(),!o&&"$"==r&&t.match("{")&&t.skipTo("}"),o=!o&&"\\"==r&&!e}return!a&&e||(n.tokenize=null),"string"}}function x(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!o&&t.match('"')&&("single"==e||t.match('""'))){a=!0;break}if(!o&&t.match("``")){w=x(e),a=!0;break}r=t.next(),o="single"==e&&!o&&"\\"==r}return a&&(n.tokenize=null),"string"}}e.defineMode("clike",function(i,s){function c(e,t){var n=e.next();if(S[n]){var r=S[n](e,t);if(!1!==r)return r}if('"'==n||"'"==n)return t.tokenize=u(n),t.tokenize(e,t);if(D.test(n))return p=n,null;if(L.test(n)){if(e.backUp(1),e.match(I))return"number";e.next()}if("/"==n){if(e.eat("*"))return t.tokenize=d,d(e,t);if(e.eat("/"))return e.skipToEnd(),"comment"}if(F.test(n)){for(;!e.match(/^\/[\/*]/,!1)&&e.eat(F););return"operator"}if(e.eatWhile(z),P)for(;e.match(P);)e.eatWhile(z);var o=e.current();return l(x,o)?(l(w,o)&&(p="newstatement"),l(v,o)&&(m=!0),"keyword"):l(b,o)?"type":l(k,o)?(l(w,o)&&(p="newstatement"),"builtin"):l(_,o)?"atom":"variable"}function u(e){return function(t,n){for(var r,o=!1,a=!1;null!=(r=t.next());){if(r==e&&!o){a=!0;break}o=!o&&"\\"==r}return(a||!o&&!C)&&(n.tokenize=null),"string"}}function d(e,t){for(var n,r=!1;n=e.next();){if("/"==n&&r){t.tokenize=null;break}r="*"==n}return"comment"}function f(e,t){s.typeFirstDefinitions&&e.eol()&&a(t.context)&&(t.typeAtEndOfLine=o(e,t,e.pos))}var p,m,h=i.indentUnit,g=s.statementIndentUnit||h,y=s.dontAlignCalls,x=s.keywords||{},b=s.types||{},k=s.builtin||{},w=s.blockKeywords||{},v=s.defKeywords||{},_=s.atoms||{},S=s.hooks||{},C=s.multiLineStrings,T=!1!==s.indentStatements,M=!1!==s.indentSwitch,P=s.namespaceSeparator,D=s.isPunctuationChar||/[\[\]{}\(\),;\:\.]/,L=s.numberStart||/[\d\.]/,I=s.number||/^(?:0x[a-f\d]+|0b[01]+|(?:\d+\.?\d*|\.\d+)(?:e[-+]?\d+)?)(u|ll?|l|f)?/i,F=s.isOperatorChar||/[+\-*&%=<>!?|\/]/,z=s.isIdentifierChar||/[\w\$_\xa1-\uffff]/;return{startState:function(e){return{tokenize:null,context:new t((e||0)-h,0,"top",null,!1),indented:0,startOfLine:!0,prevToken:null}},token:function(e,t){var i=t.context;if(e.sol()&&(null==i.align&&(i.align=!1),t.indented=e.indentation(),t.startOfLine=!0),e.eatSpace())return f(e,t),null;p=m=null;var l=(t.tokenize||c)(e,t);if("comment"==l||"meta"==l)return l;if(null==i.align&&(i.align=!0),";"==p||":"==p||","==p&&e.match(/^\s*(?:\/\/.*)?$/,!1))for(;"statement"==t.context.type;)r(t);else if("{"==p)n(t,e.column(),"}");else if("["==p)n(t,e.column(),"]");else if("("==p)n(t,e.column(),")");else if("}"==p){for(;"statement"==i.type;)i=r(t);for("}"==i.type&&(i=r(t));"statement"==i.type;)i=r(t)}else p==i.type?r(t):T&&(("}"==i.type||"top"==i.type)&&";"!=p||"statement"==i.type&&"newstatement"==p)&&n(t,e.column(),"statement",e.current());if("variable"==l&&("def"==t.prevToken||s.typeFirstDefinitions&&o(e,t,e.start)&&a(t.context)&&e.match(/^\s*\(/,!1))&&(l="def"),S.token){var u=S.token(e,t,l);void 0!==u&&(l=u)}return"def"==l&&!1===s.styleDefs&&(l="variable"),t.startOfLine=!1,t.prevToken=m?"def":l||p,f(e,t),l},indent:function(t,n){if(t.tokenize!=c&&null!=t.tokenize||t.typeAtEndOfLine)return e.Pass;var r=t.context,o=n&&n.charAt(0);if("statement"==r.type&&"}"==o&&(r=r.prev),s.dontIndentStatements)for(;"statement"==r.type&&s.dontIndentStatements.test(r.info);)r=r.prev;if(S.indent){var a=S.indent(t,r,n);if("number"==typeof a)return a}var i=o==r.type,l=r.prev&&"switch"==r.prev.info;if(s.allmanIndentation&&/[{(]/.test(o)){for(;"top"!=r.type&&"}"!=r.type;)r=r.prev;return r.indented}return"statement"==r.type?r.indented+("{"==o?0:g):!r.align||y&&")"==r.type?")"!=r.type||i?r.indented+(i?0:h)+(i||!l||/^(?:case|default)\b/.test(n)?0:h):r.indented+g:r.column+(i?0:1)},electricInput:M?/^\s*(?:case .*?:|default:|\{\}?|\})$/:/^\s*[{}]$/,blockCommentStart:"/*",blockCommentEnd:"*/",lineComment:"//",fold:"brace"}});var b="auto if break case register continue return default do sizeof static else struct switch extern typedef union for goto while enum const volatile",k="int long char short double float unsigned signed void size_t ptrdiff_t";h(["text/x-csrc","text/x-c","text/x-chdr"],{name:"clike",keywords:i(b),types:i(k+" bool _Complex _Bool float_t double_t intptr_t intmax_t int8_t int16_t int32_t int64_t uintptr_t uintmax_t uint8_t uint16_t uint32_t uint64_t"),blockKeywords:i("case do else for if switch while struct"),defKeywords:i("struct"),typeFirstDefinitions:!0,atoms:i("null true false"),hooks:{"#":s,"*":c},modeProps:{fold:["brace","include"]}}),h(["text/x-c++src","text/x-c++hdr"],{name:"clike",keywords:i(b+" asm dynamic_cast namespace reinterpret_cast try explicit new static_cast typeid catch operator template typename class friend private this using const_cast inline public throw virtual delete mutable protected alignas alignof constexpr decltype nullptr noexcept thread_local final static_assert override"),types:i(k+" bool wchar_t"),blockKeywords:i("catch class do else finally for if struct switch try while"),defKeywords:i("class namespace struct enum union"),typeFirstDefinitions:!0,atoms:i("true false null"),dontIndentStatements:/^template$/,isIdentifierChar:/[\w\$_~\xa1-\uffff]/,hooks:{"#":s,"*":c,u:d,U:d,L:d,R:d,0:u,1:u,2:u,3:u,4:u,5:u,6:u,7:u,8:u,9:u,token:function(e,t,n){if("variable"==n&&"("==e.peek()&&(";"==t.prevToken||null==t.prevToken||"}"==t.prevToken)&&f(e.current()))return"def"}},namespaceSeparator:"::",modeProps:{fold:["brace","include"]}}),h("text/x-java",{name:"clike",keywords:i("abstract assert break case catch class const continue default do else enum extends final finally float for goto if implements import instanceof interface native new package private protected public return static strictfp super switch synchronized this throw throws transient try volatile while @interface"),types:i("byte short int long float double boolean char void Boolean Byte Character Double Float Integer Long Number Object Short String StringBuffer StringBuilder Void"),blockKeywords:i("catch class do else finally for if switch try while"),defKeywords:i("class interface package enum @interface"),typeFirstDefinitions:!0,atoms:i("true false null"),number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,hooks:{"@":function(e){return!e.match("interface",!1)&&(e.eatWhile(/[\w\$_]/),"meta")}},modeProps:{fold:["brace","import"]}}),h("text/x-csharp",{name:"clike",keywords:i("abstract as async await base break case catch checked class const continue default delegate do else enum event explicit extern finally fixed for foreach goto if implicit in interface internal is lock namespace new operator out override params private protected public readonly ref return sealed sizeof stackalloc static struct switch this throw try typeof unchecked unsafe using virtual void volatile while add alias ascending descending dynamic from get global group into join let orderby partial remove select set value var yield"),types:i("Action Boolean Byte Char DateTime DateTimeOffset Decimal Double Func Guid Int16 Int32 Int64 Object SByte Single String Task TimeSpan UInt16 UInt32 UInt64 bool byte char decimal double short int long object sbyte float string ushort uint ulong"),blockKeywords:i("catch class do else finally for foreach if struct switch try while"),defKeywords:i("class interface namespace struct var"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"@":function(e,t){return e.eat('"')?(t.tokenize=p,p(e,t)):(e.eatWhile(/[\w\$_]/),"meta")}}}),h("text/x-scala",{name:"clike",keywords:i("abstract case catch class def do else extends final finally for forSome if implicit import lazy match new null object override package private protected return sealed super this throw trait try type val var while with yield _ assert assume require print println printf readLine readBoolean readByte readShort readChar readInt readLong readFloat readDouble"),types:i("AnyVal App Application Array BufferedIterator BigDecimal BigInt Char Console Either Enumeration Equiv Error Exception Fractional Function IndexedSeq Int Integral Iterable Iterator List Map Numeric Nil NotNull Option Ordered Ordering PartialFunction PartialOrdering Product Proxy Range Responder Seq Serializable Set Specializable Stream StringBuilder StringContext Symbol Throwable Traversable TraversableOnce Tuple Unit Vector Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),multiLineStrings:!0,blockKeywords:i("catch class enum do else finally for forSome if match switch try while"),defKeywords:i("class enum def object package trait type val var"),atoms:i("true false null"),indentStatements:!1,indentSwitch:!1,isOperatorChar:/[+\-*&%=<>!?|\/#:@]/,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return!!e.match('""')&&(t.tokenize=g,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},"=":function(e,n){var r=n.context;return!("}"!=r.type||!r.align||!e.eat(">"))&&(n.context=new t(r.indented,r.column,r.type,r.info,null,r.prev),"operator")}},modeProps:{closeBrackets:{triples:'"'}}}),h("text/x-kotlin",{name:"clike",keywords:i("package as typealias class interface this super val var fun for is in This throw return break continue object if else while do try when !in !is as? file import where by get set abstract enum open inner override private public internal protected catch finally out final vararg reified dynamic companion constructor init sealed field property receiver param sparam lateinit data inline noinline tailrec external annotation crossinline const operator infix suspend"),types:i("Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),intendSwitch:!1,indentStatements:!1,multiLineStrings:!0,number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,blockKeywords:i("catch class do else finally for if where try while enum"),defKeywords:i("class val var object package interface fun"),atoms:i("true false null this"),hooks:{'"':function(e,t){return t.tokenize=y(e.match('""')),t.tokenize(e,t)}},modeProps:{closeBrackets:{triples:'"'}}}),h(["x-shader/x-vertex","x-shader/x-fragment"],{name:"clike",keywords:i("sampler1D sampler2D sampler3D samplerCube sampler1DShadow sampler2DShadow const attribute uniform varying break continue discard return for while do if else struct in out inout"),types:i("float int bool void vec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4 mat2 mat3 mat4"),blockKeywords:i("for while do if else struct"),builtin:i("radians degrees sin cos tan asin acos atan pow exp log exp2 sqrt inversesqrt abs sign floor ceil fract mod min max clamp mix step smoothstep length distance dot cross normalize ftransform faceforward reflect refract matrixCompMult lessThan lessThanEqual greaterThan greaterThanEqual equal notEqual any all not texture1D texture1DProj texture1DLod texture1DProjLod texture2D texture2DProj texture2DLod texture2DProjLod texture3D texture3DProj texture3DLod texture3DProjLod textureCube textureCubeLod shadow1D shadow2D shadow1DProj shadow2DProj shadow1DLod shadow2DLod shadow1DProjLod shadow2DProjLod dFdx dFdy fwidth noise1 noise2 noise3 noise4"),atoms:i("true false gl_FragColor gl_SecondaryColor gl_Normal gl_Vertex gl_MultiTexCoord0 gl_MultiTexCoord1 gl_MultiTexCoord2 gl_MultiTexCoord3 gl_MultiTexCoord4 gl_MultiTexCoord5 gl_MultiTexCoord6 gl_MultiTexCoord7 gl_FogCoord gl_PointCoord gl_Position gl_PointSize gl_ClipVertex gl_FrontColor gl_BackColor gl_FrontSecondaryColor gl_BackSecondaryColor gl_TexCoord gl_FogFragCoord gl_FragCoord gl_FrontFacing gl_FragData gl_FragDepth gl_ModelViewMatrix gl_ProjectionMatrix gl_ModelViewProjectionMatrix gl_TextureMatrix gl_NormalMatrix gl_ModelViewMatrixInverse gl_ProjectionMatrixInverse gl_ModelViewProjectionMatrixInverse gl_TexureMatrixTranspose gl_ModelViewMatrixInverseTranspose gl_ProjectionMatrixInverseTranspose gl_ModelViewProjectionMatrixInverseTranspose gl_TextureMatrixInverseTranspose gl_NormalScale gl_DepthRange gl_ClipPlane gl_Point gl_FrontMaterial gl_BackMaterial gl_LightSource gl_LightModel gl_FrontLightModelProduct gl_BackLightModelProduct gl_TextureColor gl_EyePlaneS gl_EyePlaneT gl_EyePlaneR gl_EyePlaneQ gl_FogParameters gl_MaxLights gl_MaxClipPlanes gl_MaxTextureUnits gl_MaxTextureCoords gl_MaxVertexAttribs gl_MaxVertexUniformComponents gl_MaxVaryingFloats gl_MaxVertexTextureImageUnits gl_MaxTextureImageUnits gl_MaxFragmentUniformComponents gl_MaxCombineTextureImageUnits gl_MaxDrawBuffers"),indentSwitch:!1,hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-nesc",{name:"clike",keywords:i(b+"as atomic async call command component components configuration event generic implementation includes interface module new norace nx_struct nx_union post provides signal task uses abstract extends"),types:i(k),blockKeywords:i("case do else for if switch while struct"),atoms:i("null true false"),hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-objectivec",{name:"clike",keywords:i(b+"inline restrict _Bool _Complex _Imaginary BOOL Class bycopy byref id IMP in inout nil oneway out Protocol SEL self super atomic nonatomic retain copy readwrite readonly"),types:i(k),atoms:i("YES NO NULL NILL ON OFF true false"),hooks:{"@":function(e){return e.eatWhile(/[\w\$]/),"keyword"},"#":s,indent:function(e,t,n){if("statement"==t.type&&/^@\w/.test(n))return t.indented}},modeProps:{fold:"brace"}}),h("text/x-squirrel",{name:"clike",keywords:i("base break clone continue const default delete enum extends function in class foreach local resume return this throw typeof yield constructor instanceof static"),types:i(k),blockKeywords:i("case catch class else for foreach if switch try while"),defKeywords:i("function local class"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"#":s},modeProps:{fold:["brace","include"]}});var w=null;h("text/x-ceylon",{name:"clike",keywords:i("abstracts alias assembly assert assign break case catch class continue dynamic else exists extends finally for function given if import in interface is let module new nonempty object of out outer package return satisfies super switch then this throw try value void while"),types:function(e){var t=e.charAt(0);return t===t.toUpperCase()&&t!==t.toLowerCase()},blockKeywords:i("case catch class dynamic else finally for function if interface module new object switch try while"),defKeywords:i("class dynamic function interface module object package value"),builtin:i("abstract actual aliased annotation by default deprecated doc final formal late license native optional sealed see serializable shared suppressWarnings tagged throws variable"),isPunctuationChar:/[\[\]{}\(\),;\:\.`]/,isOperatorChar:/[+\-*&%=<>!?|^~:\/]/,numberStart:/[\d#$]/,number:/^(?:#[\da-fA-F_]+|\$[01_]+|[\d_]+[kMGTPmunpf]?|[\d_]+\.[\d_]+(?:[eE][-+]?\d+|[kMGTPmunpf]|)|)/i,multiLineStrings:!0,typeFirstDefinitions:!0,atoms:i("true false null larger smaller equal empty finished"),indentSwitch:!1,styleDefs:!1,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return t.tokenize=x(e.match('""')?"triple":"single"),t.tokenize(e,t)},"`":function(e,t){return!(!w||!e.match("`"))&&(t.tokenize=w,w=null,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},token:function(e,t,n){if(("variable"==n||"type"==n)&&"."==t.prevToken)return"variable-2"}},modeProps:{fold:["brace","import"],closeBrackets:{triples:'"'}}})});
      // -------------------------------------------------------------------------
//  Part of the CodeChecker project, under the Apache License v2.0 with
//  LLVM Exceptions. See LICENSE for license information.
//  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
// -------------------------------------------------------------------------

var BugViewer = {
  _files : [],
  _reports : [],
  _lineWidgets : [],
  _navigationMenuItems : [],
  _sourceFileData : null,
  _currentReport : null,
  _lastBugEvent  : null,

  init : function (files, reports) {
    this._files = files;
    this._reports = reports;

    this.initEscapeChars();
  },

  initEscapeChars : function () {
    this.escapeChars = {
      ' ' : 'nbsp',
      '<' : 'lt',
      '>' : 'gt',
      '"' : 'quot',
      '&' : 'amp'
    };

    var regexString = '[';
    for (var key in this.escapeChars) {
      regexString += key;
    }
    regexString += ']';

    this.escapeRegExp = new RegExp( regexString, 'g');
  },

  escapeHTML : function (str) {
    var that = this;

    return str.replace(this.escapeRegExp, function (m) {
      return '&' + that.escapeChars[m] + ';';
    });
  },

  initByUrl : function () {
    if (!this._reports) return;

    var state = {};
    window.location.hash.substr(1).split('&').forEach(function (s) {
      var parts = s.split('=');
      state[parts[0]] = parts[1];
    });

    for (var key in this._reports) {
      var report = this._reports[key];
      if (report.reportHash === state['reportHash']) {
        this.navigate(report);
        return;
      }
    }

    this.navigate(this._reports[0]);
  },

  create : function () {
    this._content = document.getElementById('editor-wrapper');
    this._filepath = document.getElementById('file-path');
    this._checkerName = document.getElementById('checker-name');
    this._reviewStatusWrapper =
      document.getElementById('review-status-wrapper');
    this._reviewStatus = document.getElementById('review-status');
    this._editor = document.getElementById('editor');

    this._codeMirror = CodeMirror(this._editor, {
      mode: 'text/x-c++src',
      matchBrackets : true,
      lineNumbers : true,
      readOnly : true,
      foldGutter : true,
      extraKeys : {},
      viewportMargin : 100
    });

    this._createNavigationMenu();
  },

  navigate : function (report, item) {
    if (!item) {
      var items = this._navigationMenuItems.filter(function (navItem) {
        return navItem.report.reportHash === report.reportHash;
      });

      if (!items.length) return;

      item = items[0].widget;
    }

    this._selectedReport.classList.remove('active');
    this._selectedReport = item;
    this._selectedReport.classList.add('active');
    this.setReport(report);
  },

  _createNavigationMenu : function () {
    var that = this;

    var nav = document.getElementById('report-nav');
    var list = document.createElement('ul');
    this._reports.forEach(function (report) {
      var events = report['events'];
      var lastBugEvent = events[events.length - 1];
      var item = document.createElement('li');

      var severity = document.createElement('i');
      severity.className = 'severity-' + report.severity.toLowerCase();

      item.appendChild(severity);
      item.appendChild(document.createTextNode(lastBugEvent.message));

      item.addEventListener('click', function () {
        that.navigate(report, item);
      })
      list.appendChild(item);
      that._navigationMenuItems.push({ report : report, widget : item });
    });

    if (!this._selectedReport && list.childNodes.length) {
      this._selectedReport = list.childNodes[0];
      this._selectedReport.classList.add('active');
    }

    nav.appendChild(list);
  },

  setReport : function (report) {
    this._currentReport = report;
    var events = report['events'];
    var lastBugEvent = events[events.length - 1];
    this.setCurrentBugEvent(lastBugEvent, events.length - 1);
    this.setCheckerName(report.checkerName);
    this.setReviewStatus(report.reviewStatus);

    window.location.hash = '#reportHash=' + report.reportHash;
  },

  setCurrentBugEvent : function (event, idx) {
    this._currentBugEvent = event;
    this.setSourceFileData(this._files[event.location.file]);
    this.drawBugPath();

    this.jumpTo(event.location.line, 0);
    this.highlightBugEvent(event, idx);
  },

  highlightBugEvent : function (event, idx) {
    this._lineWidgets.forEach(function (widget) {
      var lineIdx = widget.node.getAttribute('idx');
      if (parseInt(lineIdx) === idx) {
        widget.node.classList.add('current');
      }
    });
  },

  setCheckerName : function (checkerName) {
    this._checkerName.innerHTML = checkerName;
  },

  setReviewStatus : function (status) {
    if (status) {
      var className =
        'review-status-' + status.toLowerCase().split(' ').join('-');
      this._reviewStatus.className = "review-status " + className;

      this._reviewStatus.innerHTML = status;
      this._reviewStatusWrapper.style.display = 'block';
    } else {
      this._reviewStatusWrapper.style.display = 'none';
    }
  },

  setSourceFileData : function (file) {
    if (this._sourceFileData && file.id === this._sourceFileData.id) {
      return;
    }

    this._sourceFileData = file;
    this._filepath.innerHTML = file.path;
    this._codeMirror.doc.setValue(file.content);
    this._refresh();
  },

  _refresh : function () {
    var that = this;
    setTimeout(function () {
      var fullHeight = parseInt(that._content.clientHeight);
      var headerHeight = that._filepath.clientHeight;

      that._codeMirror.setSize('auto', fullHeight - headerHeight);
      that._codeMirror.refresh();
    }, 200);
  },

  clearBubbles : function () {
    this._lineWidgets.forEach(function (widget) { widget.clear(); });
    this._lineWidgets = [];
  },

  getMessage : function (event, kind) {
    if (kind === 'macro') {
      var name = 'macro expansion' + (event.name ? ': ' + event.name : '');

      return '<span class="tag macro">' + name + '</span>'
        + this.escapeHTML(event.expansion).replace(/(?:\r\n|\r|\n)/g, '<br>');
    } else if (kind === 'note') {
      return '<span class="tag note">note</span>'
        +  this.escapeHTML(event.message).replace(/(?:\r\n|\r|\n)/g, '<br>');
    }
  },

  addExtraPathEvents : function (events, kind) {
    var that = this;

    if (!events) {
      return;
    }

    events.forEach(function (event) {
      if (event.location.file !== that._currentBugEvent.location.file) {
        return;
      }

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + kind);

      var msg = document.createElement('span');
      msg.innerHTML = that.getMessage(event, kind);
      element.appendChild(msg);

      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  drawBugPath : function () {
    var that = this;

    this.clearBubbles();

    this.addExtraPathEvents(this._currentReport.macros, 'macro');
    this.addExtraPathEvents(this._currentReport.notes, 'note');

    // Processing bug path events.
    var currentEvents = this._currentReport.events;
    currentEvents.forEach(function (event, step) {
      if (event.location.file !== that._currentBugEvent.location.file)
        return;

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';
      var type = step === currentEvents.length - 1 ? 'error' : 'info';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + type);
      element.setAttribute('idx', step);

      var enumeration = document.createElement('span');
      enumeration.setAttribute('class', 'checker-enum ' + type);
      enumeration.innerHTML = step + 1;

      if (currentEvents.length > 1)
        element.appendChild(enumeration);

      var prevBugEvent = step - 1;
      if (step > 0) {
        var prevBug = document.createElement('span');
        prevBug.setAttribute('class', 'arrow left-arrow');
        prevBug.addEventListener('click', function () {
          var event = currentEvents[prevBugEvent];
          that.setCurrentBugEvent(event, prevBugEvent);
        });
        element.appendChild(prevBug);
      }

      var msg = document.createElement('span');
      msg.innerHTML = that.escapeHTML(event.message)
        .replace(/(?:\r\n|\r|\n)/g, '<br>');

      element.appendChild(msg);

      var nextBugEvent = step + 1;
      if (nextBugEvent < currentEvents.length) {
        var nextBug = document.createElement('span');
        nextBug.setAttribute('class', 'arrow right-arrow');
        nextBug.addEventListener('click', function () {
          var event = currentEvents[nextBugEvent];
          that.setCurrentBugEvent(event, nextBugEvent);
        });
        element.appendChild(nextBug);
      }


      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  jumpTo : function (line, column) {
    var that = this;

    setTimeout(function () {
      var selPosPixel
        = that._codeMirror.charCoords({ line : line, ch : column }, 'local');
      var editorSize = {
        width  : that._editor.clientWidth,
        height : that._editor.clientHeight
      };

      that._codeMirror.scrollIntoView({
        top    : selPosPixel.top - 100,
        bottom : selPosPixel.top + editorSize.height - 150,
        left   : selPosPixel.left < editorSize.width - 100
               ? 0
               : selPosPixel.left - 50,
        right  : selPosPixel.left < editorSize.width - 100
               ? 10
               : selPosPixel.left + editorSize.width - 100
      });
    }, 0);
  }
}


      var data = {"files": {"0": {"id": 0, "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Breakpoint/StoppointHitCounter.h", "content": "//===-- StoppointHitCounter.h -----------------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLDB_BREAKPOINT_STOPPOINT_HIT_COUNTER_H\n#define LLDB_BREAKPOINT_STOPPOINT_HIT_COUNTER_H\n\n#include <assert.h>\n#include <cstdint>\n#include <limits>\n\n#include \"lldb/Utility/LLDBAssert.h\"\n\nnamespace lldb_private {\n\nclass StoppointHitCounter {\npublic:\n  uint32_t GetValue() const { return m_hit_count; }\n\n  void Increment(uint32_t difference = 1) {\n    lldbassert(std::numeric_limits<uint32_t>::max() - m_hit_count >= difference);\n    m_hit_count += difference;\n  }\n\n  void Decrement(uint32_t difference = 1) {\n    lldbassert(m_hit_count >= difference);\n    m_hit_count -= difference;\n  }\n\n  void Reset() { m_hit_count = 0; }\n\nprivate:\n  /// Number of times this breakpoint/watchpoint has been hit.\n  uint32_t m_hit_count = 0;\n};\n\n} // namespace lldb_private\n\n#endif // LLDB_BREAKPOINT_STOPPOINT_HIT_COUNTER_H\n"}, "1": {"id": 1, "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Core/Address.h", "content": "//===-- Address.h -----------------------------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLDB_CORE_ADDRESS_H\n#define LLDB_CORE_ADDRESS_H\n\n#include \"lldb/lldb-defines.h\"\n#include \"lldb/lldb-forward.h\"\n#include \"lldb/lldb-private-enumerations.h\"\n#include \"lldb/lldb-types.h\"\n\n#include <stddef.h>\n#include <stdint.h>\n\nnamespace lldb_private {\nclass Block;\nclass CompileUnit;\nclass ExecutionContextScope;\nclass Function;\nclass SectionList;\nclass Stream;\nclass Symbol;\nclass SymbolContext;\nclass Target;\nstruct LineEntry;\n\n/// \\class Address Address.h \"lldb/Core/Address.h\"\n/// A section + offset based address class.\n///\n/// The Address class allows addresses to be relative to a section that can\n/// move during runtime due to images (executables, shared libraries, bundles,\n/// frameworks) being loaded at different addresses than the addresses found\n/// in the object file that represents them on disk. There are currently two\n/// types of addresses for a section:\n///     \\li file addresses\n///     \\li load addresses\n///\n/// File addresses represent the virtual addresses that are in the \"on disk\"\n/// object files. These virtual addresses are converted to be relative to\n/// unique sections scoped to the object file so that when/if the addresses\n/// slide when the images are loaded/unloaded in memory, we can easily track\n/// these changes without having to update every object (compile unit ranges,\n/// line tables, function address ranges, lexical block and inlined subroutine\n/// address ranges, global and static variables) each time an image is loaded\n/// or unloaded.\n///\n/// Load addresses represent the virtual addresses where each section ends up\n/// getting loaded at runtime. Before executing a program, it is common for\n/// all of the load addresses to be unresolved. When a DynamicLoader plug-in\n/// receives notification that shared libraries have been loaded/unloaded, the\n/// load addresses of the main executable and any images (shared libraries)\n/// will be  resolved/unresolved. When this happens, breakpoints that are in\n/// one of these sections can be set/cleared.\nclass Address {\npublic:\n  /// Dump styles allow the Address::Dump(Stream *,DumpStyle) const function\n  /// to display Address contents in a variety of ways.\n  enum DumpStyle {\n    /// Invalid dump style.\n    DumpStyleInvalid,\n    /// Display as the section name + offset.\n    /// \\code\n    /// // address for printf in libSystem.B.dylib as a section name + offset\n    /// libSystem.B.dylib.__TEXT.__text + 0x0005cfdf\n    /// \\endcode\n    DumpStyleSectionNameOffset,\n    /// Display as the section pointer + offset (debug output).\n    /// \\code\n    /// // address for printf in libSystem.B.dylib as a section pointer +\n    /// offset (lldb::Section *)0x35cc50 + 0x000000000005cfdf\n    /// \\endcode\n    DumpStyleSectionPointerOffset,\n    /// Display as the file address (if any).\n    /// \\code\n    /// // address for printf in libSystem.B.dylib as a file address\n    /// 0x000000000005dcff\n    /// \\endcode\n    ///\n    DumpStyleFileAddress,\n    /// Display as the file address with the module name prepended (if any).\n    /// \\code\n    /// // address for printf in libSystem.B.dylib as a file address\n    /// libSystem.B.dylib[0x000000000005dcff]\n    /// \\endcode\n    DumpStyleModuleWithFileAddress,\n    /// Display as the load address (if resolved).\n    /// \\code\n    /// // address for printf in libSystem.B.dylib as a load address\n    /// 0x00007fff8306bcff\n    /// \\endcode\n    DumpStyleLoadAddress,\n    /// Display the details about what an address resolves to. This can be\n    /// anything from a symbol context summary (module, function/symbol, and\n    /// file and line), to information about what the pointer points to if the\n    /// address is in a section (section of pointers, c strings, etc).\n    DumpStyleResolvedDescription,\n    DumpStyleResolvedDescriptionNoModule,\n    DumpStyleResolvedDescriptionNoFunctionArguments,\n    /// Elide the function name; display an offset into the current function.\n    /// Used primarily in disassembly symbolication\n    DumpStyleNoFunctionName,\n    /// Detailed symbol context information for an address for all symbol\n    /// context members.\n    DumpStyleDetailedSymbolContext,\n    /// Dereference a pointer at the current address and then lookup the\n    /// dereferenced address using DumpStyleResolvedDescription\n    DumpStyleResolvedPointerDescription\n  };\n\n  /// Default constructor.\n  ///\n  /// Initialize with a invalid section (NULL) and an invalid offset\n  /// (LLDB_INVALID_ADDRESS).\n  Address() : m_section_wp(), m_offset(LLDB_INVALID_ADDRESS) {}\n\n  /// Copy constructor\n  ///\n  /// Makes a copy of the another Address object \\a rhs.\n  ///\n  /// \\param[in] rhs\n  ///     A const Address object reference to copy.\n  Address(const Address &rhs)\n      : m_section_wp(rhs.m_section_wp), m_offset(rhs.m_offset) {}\n\n  /// Construct with a section pointer and offset.\n  ///\n  /// Initialize the address with the supplied \\a section and \\a offset.\n  ///\n  /// \\param[in] section_sp\n  ///     A section pointer to a valid lldb::Section, or NULL if the\n  ///     address doesn't have a section or will get resolved later.\n  ///\n  /// \\param[in] offset\n  ///     The offset in bytes into \\a section.\n  Address(const lldb::SectionSP &section_sp, lldb::addr_t offset)\n      : m_section_wp(), // Don't init with section_sp in case section_sp is\n                        // invalid (the weak_ptr will throw)\n        m_offset(offset) {\n    if (section_sp)\n      m_section_wp = section_sp;\n  }\n\n  /// Construct with a virtual address and section list.\n  ///\n  /// Initialize and resolve the address with the supplied virtual address \\a\n  /// file_addr.\n  ///\n  /// \\param[in] file_addr\n  ///     A virtual file address.\n  ///\n  /// \\param[in] section_list\n  ///     A list of sections, one of which may contain the \\a file_addr.\n  Address(lldb::addr_t file_addr, const SectionList *section_list);\n\n  Address(lldb::addr_t abs_addr);\n\n/// Assignment operator.\n///\n/// Copies the address value from another Address object \\a rhs into \\a this\n/// object.\n///\n/// \\param[in] rhs\n///     A const Address object reference to copy.\n///\n/// \\return\n///     A const Address object reference to \\a this.\n  const Address &operator=(const Address &rhs);\n\n  /// Clear the object's state.\n  ///\n  /// Sets the section to an invalid value (NULL) and an invalid offset\n  /// (LLDB_INVALID_ADDRESS).\n  void Clear() {\n    m_section_wp.reset();\n    m_offset = LLDB_INVALID_ADDRESS;\n  }\n\n  /// Compare two Address objects.\n  ///\n  /// \\param[in] lhs\n  ///     The Left Hand Side const Address object reference.\n  ///\n  /// \\param[in] rhs\n  ///     The Right Hand Side const Address object reference.\n  ///\n  /// \\return\n  ///     -1 if lhs < rhs\n  ///     0 if lhs == rhs\n  ///     1 if lhs > rhs\n  static int CompareFileAddress(const Address &lhs, const Address &rhs);\n\n  static int CompareLoadAddress(const Address &lhs, const Address &rhs,\n                                Target *target);\n\n  static int CompareModulePointerAndOffset(const Address &lhs,\n                                           const Address &rhs);\n\n  // For use with std::map, std::multi_map\n  class ModulePointerAndOffsetLessThanFunctionObject {\n  public:\n    ModulePointerAndOffsetLessThanFunctionObject() = default;\n\n    bool operator()(const Address &a, const Address &b) const {\n      return Address::CompareModulePointerAndOffset(a, b) < 0;\n    }\n  };\n\n  /// Dump a description of this object to a Stream.\n  ///\n  /// Dump a description of the contents of this object to the supplied stream\n  /// \\a s. There are many ways to display a section offset based address, and\n  /// \\a style lets the user choose.\n  ///\n  /// \\param[in] s\n  ///     The stream to which to dump the object description.\n  ///\n  /// \\param[in] style\n  ///     The display style for the address.\n  ///\n  /// \\param[in] fallback_style\n  ///     The display style for the address.\n  ///\n  /// \\return\n  ///     Returns \\b true if the address was able to be displayed.\n  ///     File and load addresses may be unresolved and it may not be\n  ///     possible to display a valid value, \\b false will be returned\n  ///     in such cases.\n  ///\n  /// \\see Address::DumpStyle\n  bool Dump(Stream *s, ExecutionContextScope *exe_scope, DumpStyle style,\n            DumpStyle fallback_style = DumpStyleInvalid,\n            uint32_t addr_byte_size = UINT32_MAX) const;\n\n  AddressClass GetAddressClass() const;\n\n  /// Get the file address.\n  ///\n  /// If an address comes from a file on disk that has section relative\n  /// addresses, then it has a virtual address that is relative to unique\n  /// section in the object file.\n  ///\n  /// \\return\n  ///     The valid file virtual address, or LLDB_INVALID_ADDRESS if\n  ///     the address doesn't have a file virtual address (image is\n  ///     from memory only with no representation on disk).\n  lldb::addr_t GetFileAddress() const;\n\n  /// Get the load address.\n  ///\n  /// If an address comes from a file on disk that has section relative\n  /// addresses, then it has a virtual address that is relative to unique\n  /// section in the object file. Sections get resolved at runtime by\n  /// DynamicLoader plug-ins as images (executables and shared libraries) get\n  /// loaded/unloaded. If a section is loaded, then the load address can be\n  /// resolved.\n  ///\n  /// \\return\n  ///     The valid load virtual address, or LLDB_INVALID_ADDRESS if\n  ///     the address is currently not loaded.\n  lldb::addr_t GetLoadAddress(Target *target) const;\n\n  /// Get the load address as a callable code load address.\n  ///\n  /// This function will first resolve its address to a load address. Then, if\n  /// the address turns out to be in code address, return the load address\n  /// that would be required to call or return to. The address might have\n  /// extra bits set (bit zero will be set to Thumb functions for an ARM\n  /// target) that are required when changing the program counter to setting a\n  /// return address.\n  ///\n  /// \\return\n  ///     The valid load virtual address, or LLDB_INVALID_ADDRESS if\n  ///     the address is currently not loaded.\n  lldb::addr_t GetCallableLoadAddress(Target *target,\n                                      bool is_indirect = false) const;\n\n  /// Get the load address as an opcode load address.\n  ///\n  /// This function will first resolve its address to a load address. Then, if\n  /// the address turns out to be in code address, return the load address for\n  /// an opcode. This address object might have extra bits set (bit zero will\n  /// be set to Thumb functions for an\n  /// ARM target) that are required for changing the program counter\n  /// and this function will remove any bits that are intended for these\n  /// special purposes. The result of this function can be used to safely\n  /// write a software breakpoint trap to memory.\n  ///\n  /// \\return\n  ///     The valid load virtual address with extra callable bits\n  ///     removed, or LLDB_INVALID_ADDRESS if the address is currently\n  ///     not loaded.\n  lldb::addr_t GetOpcodeLoadAddress(\n      Target *target,\n      AddressClass addr_class = AddressClass::eInvalid) const;\n\n  /// Get the section relative offset value.\n  ///\n  /// \\return\n  ///     The current offset, or LLDB_INVALID_ADDRESS if this address\n  ///     doesn't contain a valid offset.\n  lldb::addr_t GetOffset() const { return m_offset; }\n\n  /// Check if an address is section offset.\n  ///\n  /// When converting a virtual file or load address into a section offset\n  /// based address, we often need to know if, given a section list, if the\n  /// address was able to be converted to section offset. This function\n  /// returns true if the current value contained in this object is section\n  /// offset based.\n  ///\n  /// \\return\n  ///     Returns \\b true if the address has a valid section and\n  ///     offset, \\b false otherwise.\n  bool IsSectionOffset() const {\n    return IsValid() && (GetSection().get() != nullptr);\n  }\n\n  /// Check if the object state is valid.\n  ///\n  /// A valid Address object contains either a section pointer and\n  /// offset (for section offset based addresses), or just a valid offset\n  /// (for absolute addresses that have no section).\n  ///\n  /// \\return\n  ///     Returns \\b true if the offset is valid, \\b false\n  ///     otherwise.\n  bool IsValid() const { return m_offset != LLDB_INVALID_ADDRESS; }\n\n  /// Get the memory cost of this object.\n  ///\n  /// \\return\n  ///     The number of bytes that this object occupies in memory.\n  size_t MemorySize() const;\n\n  /// Resolve a file virtual address using a section list.\n  ///\n  /// Given a list of sections, attempt to resolve \\a addr as an offset into\n  /// one of the file sections.\n  ///\n  /// \\return\n  ///     Returns \\b true if \\a addr was able to be resolved, \\b false\n  ///     otherwise.\n  bool ResolveAddressUsingFileSections(lldb::addr_t addr,\n                                       const SectionList *sections);\n\n  /// Resolve this address to its containing function and optionally get\n  /// that function's address range.\n  ///\n  /// \\param[out] sym_ctx\n  ///     The symbol context describing the function in which this address lies\n  ///\n  /// \\parm[out] addr_range_ptr\n  ///     Pointer to the AddressRange to fill in with the function's address\n  ///     range.  Caller may pass null if they don't need the address range.\n  ///\n  /// \\return\n  ///     Returns \\b false if the function/symbol could not be resolved\n  ///     or if the address range was requested and could not be resolved;\n  ///     returns \\b true otherwise.\n  bool ResolveFunctionScope(lldb_private::SymbolContext &sym_ctx,\n                            lldb_private::AddressRange *addr_range_ptr = nullptr);\n\n  /// Set the address to represent \\a load_addr.\n  ///\n  /// The address will attempt to find a loaded section within \\a target that\n  /// contains \\a load_addr. If successful, this address object will have a\n  /// valid section and offset. Else this address object will have no section\n  /// (NULL) and the offset will be \\a load_addr.\n  ///\n  /// \\param[in] load_addr\n  ///     A load address from a current process.\n  ///\n  /// \\param[in] target\n  ///     The target to use when trying resolve the address into\n  ///     a section + offset. The Target's SectionLoadList object\n  ///     is used to resolve the address.\n  ///\n  /// \\param[in] allow_section_end\n  ///     If true, treat an address pointing to the end of the module as\n  ///     belonging to that module.\n  ///\n  /// \\return\n  ///     Returns \\b true if the load address was resolved to be\n  ///     section/offset, \\b false otherwise. It is often ok for an\n  ///     address to not resolve to a section in a module, this often\n  ///     happens for JIT'ed code, or any load addresses on the stack\n  ///     or heap.\n  bool SetLoadAddress(lldb::addr_t load_addr, Target *target,\n                      bool allow_section_end = false);\n\n  bool SetOpcodeLoadAddress(\n      lldb::addr_t load_addr, Target *target,\n      AddressClass addr_class = AddressClass::eInvalid,\n      bool allow_section_end = false);\n\n  bool SetCallableLoadAddress(lldb::addr_t load_addr, Target *target);\n\n  /// Get accessor for the module for this address.\n  ///\n  /// \\return\n  ///     Returns the Module pointer that this address is an offset\n  ///     in, or NULL if this address doesn't belong in a module, or\n  ///     isn't resolved yet.\n  lldb::ModuleSP GetModule() const;\n\n  /// Get const accessor for the section.\n  ///\n  /// \\return\n  ///     Returns the const lldb::Section pointer that this address is an\n  ///     offset in, or NULL if this address is absolute.\n  lldb::SectionSP GetSection() const { return m_section_wp.lock(); }\n\n  /// Set accessor for the offset.\n  ///\n  /// \\param[in] offset\n  ///     A new offset value for this object.\n  ///\n  /// \\return\n  ///     Returns \\b true if the offset changed, \\b false otherwise.\n  bool SetOffset(lldb::addr_t offset) {\n    bool changed = m_offset != offset;\n    m_offset = offset;\n    return changed;\n  }\n\n  void SetRawAddress(lldb::addr_t addr) {\n    m_section_wp.reset();\n    m_offset = addr;\n  }\n\n  bool Slide(int64_t offset) {\n    if (m_offset != LLDB_INVALID_ADDRESS) {\n      m_offset += offset;\n      return true;\n    }\n    return false;\n  }\n\n  /// Set accessor for the section.\n  ///\n  /// \\param[in] section_sp\n  ///     A new lldb::Section pointer to use as the section base. Can\n  ///     be NULL for absolute addresses that are not relative to\n  ///     any section.\n  void SetSection(const lldb::SectionSP &section_sp) {\n    m_section_wp = section_sp;\n  }\n\n  void ClearSection() { m_section_wp.reset(); }\n\n  /// Reconstruct a symbol context from an address.\n  ///\n  /// This class doesn't inherit from SymbolContextScope because many address\n  /// objects have short lifespans. Address objects that are section offset\n  /// can reconstruct their symbol context by looking up the address in the\n  /// module found in the section.\n  ///\n  /// \\see SymbolContextScope::CalculateSymbolContext(SymbolContext*)\n  uint32_t CalculateSymbolContext(SymbolContext *sc,\n                                  lldb::SymbolContextItem resolve_scope =\n                                      lldb::eSymbolContextEverything) const;\n\n  lldb::ModuleSP CalculateSymbolContextModule() const;\n\n  CompileUnit *CalculateSymbolContextCompileUnit() const;\n\n  Function *CalculateSymbolContextFunction() const;\n\n  Block *CalculateSymbolContextBlock() const;\n\n  Symbol *CalculateSymbolContextSymbol() const;\n\n  bool CalculateSymbolContextLineEntry(LineEntry &line_entry) const;\n\n  // Returns true if the section should be valid, but isn't because the shared\n  // pointer to the section can't be reconstructed from a weak pointer that\n  // contains a valid weak reference to a section. Returns false if the section\n  // weak pointer has no reference to a section, or if the section is still\n  // valid\n  bool SectionWasDeleted() const;\n\nprotected:\n  // Member variables.\n  lldb::SectionWP m_section_wp; ///< The section for the address, can be NULL.\n  lldb::addr_t m_offset; ///< Offset into section if \\a m_section_wp is valid...\n\n  // Returns true if the m_section_wp once had a reference to a valid section\n  // shared pointer, but no longer does. This can happen if we have an address\n  // from a module that gets unloaded and deleted. This function should only be\n  // called if GetSection() returns an empty shared pointer and you want to\n  // know if this address used to have a valid section.\n  bool SectionWasDeletedPrivate() const;\n};\n\n// NOTE: Be careful using this operator. It can correctly compare two\n// addresses from the same Module correctly. It can't compare two addresses\n// from different modules in any meaningful way, but it will compare the module\n// pointers.\n//\n// To sum things up:\n// - works great for addresses within the same module - it works for addresses\n// across multiple modules, but don't expect the\n//   address results to make much sense\n//\n// This basically lets Address objects be used in ordered collection classes.\nbool operator<(const Address &lhs, const Address &rhs);\nbool operator>(const Address &lhs, const Address &rhs);\nbool operator==(const Address &lhs, const Address &rhs);\nbool operator!=(const Address &lhs, const Address &rhs);\n\n} // namespace lldb_private\n\n#endif // LLDB_CORE_ADDRESS_H\n"}, "2": {"id": 2, "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Core/Architecture.h", "content": "//===-- Architecture.h ------------------------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLDB_CORE_ARCHITECTURE_H\n#define LLDB_CORE_ARCHITECTURE_H\n\n#include \"lldb/Core/PluginInterface.h\"\n\nnamespace lldb_private {\n\nclass Architecture : public PluginInterface {\npublic:\n  /// This is currently intended to handle cases where a\n  /// program stops at an instruction that won't get executed and it\n  /// allows the stop reason, like \"breakpoint hit\", to be replaced\n  /// with a different stop reason like \"no stop reason\".\n  ///\n  /// This is specifically used for ARM in Thumb code when we stop in\n  /// an IT instruction (if/then/else) where the instruction won't get\n  /// executed and therefore it wouldn't be correct to show the program\n  /// stopped at the current PC. The code is generic and applies to all\n  /// ARM CPUs.\n  virtual void OverrideStopInfo(Thread &thread) const = 0;\n\n  /// This method is used to get the number of bytes that should be\n  /// skipped, from function start address, to reach the first\n  /// instruction after the prologue. If overrode, it must return\n  /// non-zero only if the current address matches one of the known\n  /// function entry points.\n  ///\n  /// This method is called only if the standard platform-independent\n  /// code fails to get the number of bytes to skip, giving the plugin\n  /// a chance to try to find the missing info.\n  ///\n  /// This is specifically used for PPC64, where functions may have\n  /// more than one entry point, global and local, so both should\n  /// be compared with current address, in order to find out the\n  /// number of bytes that should be skipped, in case we are stopped\n  /// at either function entry point.\n  virtual size_t GetBytesToSkip(Symbol &func, const Address &curr_addr) const {\n    return 0;\n  }\n\n  /// Adjust function breakpoint address, if needed. In some cases,\n  /// the function start address is not the right place to set the\n  /// breakpoint, specially in functions with multiple entry points.\n  ///\n  /// This is specifically used for PPC64, for functions that have\n  /// both a global and a local entry point. In this case, the\n  /// breakpoint is adjusted to the first function address reached\n  /// by both entry points.\n  virtual void AdjustBreakpointAddress(const Symbol &func,\n                                       Address &addr) const {}\n\n\n  /// Get \\a load_addr as a callable code load address for this target\n  ///\n  /// Take \\a load_addr and potentially add any address bits that are\n  /// needed to make the address callable. For ARM this can set bit\n  /// zero (if it already isn't) if \\a load_addr is a thumb function.\n  /// If \\a addr_class is set to AddressClass::eInvalid, then the address\n  /// adjustment will always happen. If it is set to an address class\n  /// that doesn't have code in it, LLDB_INVALID_ADDRESS will be\n  /// returned.\n  virtual lldb::addr_t GetCallableLoadAddress(\n      lldb::addr_t addr, AddressClass addr_class = AddressClass::eInvalid) const {\n    return addr;\n  }\n\n  /// Get \\a load_addr as an opcode for this target.\n  ///\n  /// Take \\a load_addr and potentially strip any address bits that are\n  /// needed to make the address point to an opcode. For ARM this can\n  /// clear bit zero (if it already isn't) if \\a load_addr is a\n  /// thumb function and load_addr is in code.\n  /// If \\a addr_class is set to AddressClass::eInvalid, then the address\n  /// adjustment will always happen. If it is set to an address class\n  /// that doesn't have code in it, LLDB_INVALID_ADDRESS will be\n  /// returned.\n\n  virtual lldb::addr_t GetOpcodeLoadAddress(\n      lldb::addr_t addr, AddressClass addr_class = AddressClass::eInvalid) const {\n    return addr;\n  }\n\n  // Get load_addr as breakable load address for this target. Take a addr and\n  // check if for any reason there is a better address than this to put a\n  // breakpoint on. If there is then return that address. For MIPS, if\n  // instruction at addr is a delay slot instruction then this method will find\n  // the address of its previous instruction and return that address.\n  virtual lldb::addr_t GetBreakableLoadAddress(lldb::addr_t addr,\n                                               Target &target) const {\n    return addr;\n  }\n};\n\n} // namespace lldb_private\n\n#endif // LLDB_CORE_ARCHITECTURE_H\n"}, "3": {"id": 3, "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Core/Disassembler.h", "content": "//===-- Disassembler.h ------------------------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLDB_CORE_DISASSEMBLER_H\n#define LLDB_CORE_DISASSEMBLER_H\n\n#include \"lldb/Core/Address.h\"\n#include \"lldb/Core/EmulateInstruction.h\"\n#include \"lldb/Core/FormatEntity.h\"\n#include \"lldb/Core/Opcode.h\"\n#include \"lldb/Core/PluginInterface.h\"\n#include \"lldb/Interpreter/OptionValue.h\"\n#include \"lldb/Symbol/LineEntry.h\"\n#include \"lldb/Target/ExecutionContext.h\"\n#include \"lldb/Utility/ArchSpec.h\"\n#include \"lldb/Utility/ConstString.h\"\n#include \"lldb/Utility/FileSpec.h\"\n#include \"lldb/lldb-defines.h\"\n#include \"lldb/lldb-forward.h\"\n#include \"lldb/lldb-private-enumerations.h\"\n#include \"lldb/lldb-types.h\"\n\n#include \"llvm/ADT/StringRef.h\"\n\n#include <functional>\n#include <map>\n#include <memory>\n#include <set>\n#include <string>\n#include <vector>\n\n#include <stddef.h>\n#include <stdint.h>\n#include <stdio.h>\n\nnamespace llvm {\ntemplate <typename T> class SmallVectorImpl;\n}\n\nnamespace lldb_private {\nclass AddressRange;\nclass DataExtractor;\nclass Debugger;\nclass Disassembler;\nclass Module;\nclass StackFrame;\nclass Stream;\nclass SymbolContext;\nclass SymbolContextList;\nclass Target;\nstruct RegisterInfo;\n\nclass Instruction {\npublic:\n  Instruction(const Address &address,\n              AddressClass addr_class = AddressClass::eInvalid);\n\n  virtual ~Instruction();\n\n  const Address &GetAddress() const { return m_address; }\n\n  const char *GetMnemonic(const ExecutionContext *exe_ctx) {\n    CalculateMnemonicOperandsAndCommentIfNeeded(exe_ctx);\n    return m_opcode_name.c_str();\n  }\n\n  const char *GetOperands(const ExecutionContext *exe_ctx) {\n    CalculateMnemonicOperandsAndCommentIfNeeded(exe_ctx);\n    return m_mnemonics.c_str();\n  }\n\n  const char *GetComment(const ExecutionContext *exe_ctx) {\n    CalculateMnemonicOperandsAndCommentIfNeeded(exe_ctx);\n    return m_comment.c_str();\n  }\n\n  virtual void\n  CalculateMnemonicOperandsAndComment(const ExecutionContext *exe_ctx) = 0;\n\n  AddressClass GetAddressClass();\n\n  void SetAddress(const Address &addr) {\n    // Invalidate the address class to lazily discover it if we need to.\n    m_address_class = AddressClass::eInvalid;\n    m_address = addr;\n  }\n\n  /// Dump the text representation of this Instruction to a Stream\n  ///\n  /// Print the (optional) address, (optional) bytes, opcode,\n  /// operands, and instruction comments to a stream.\n  ///\n  /// \\param[in] s\n  ///     The Stream to add the text to.\n  ///\n  /// \\param[in] show_address\n  ///     Whether the address (using disassembly_addr_format_spec formatting)\n  ///     should be printed.\n  ///\n  /// \\param[in] show_bytes\n  ///     Whether the bytes of the assembly instruction should be printed.\n  ///\n  /// \\param[in] max_opcode_byte_size\n  ///     The size (in bytes) of the largest instruction in the list that\n  ///     we are printing (for text justification/alignment purposes)\n  ///     Only needed if show_bytes is true.\n  ///\n  /// \\param[in] exe_ctx\n  ///     The current execution context, if available.  May be used in\n  ///     the assembling of the operands+comments for this instruction.\n  ///     Pass NULL if not applicable.\n  ///\n  /// \\param[in] sym_ctx\n  ///     The SymbolContext for this instruction.\n  ///     Pass NULL if not available/computed.\n  ///     Only needed if show_address is true.\n  ///\n  /// \\param[in] prev_sym_ctx\n  ///     The SymbolContext for the previous instruction.  Depending on\n  ///     the disassembly address format specification, a change in\n  ///     Symbol / Function may mean that a line is printed with the new\n  ///     symbol/function name.\n  ///     Pass NULL if unavailable, or if this is the first instruction of\n  ///     the InstructionList.\n  ///     Only needed if show_address is true.\n  ///\n  /// \\param[in] disassembly_addr_format\n  ///     The format specification for how addresses are printed.\n  ///     Only needed if show_address is true.\n  ///\n  /// \\param[in] max_address_text_size\n  ///     The length of the longest address string at the start of the\n  ///     disassembly line that will be printed (the\n  ///     Debugger::FormatDisassemblerAddress() string)\n  ///     so this method can properly align the instruction opcodes.\n  ///     May be 0 to indicate no indentation/alignment of the opcodes.\n  virtual void Dump(Stream *s, uint32_t max_opcode_byte_size, bool show_address,\n                    bool show_bytes, const ExecutionContext *exe_ctx,\n                    const SymbolContext *sym_ctx,\n                    const SymbolContext *prev_sym_ctx,\n                    const FormatEntity::Entry *disassembly_addr_format,\n                    size_t max_address_text_size);\n\n  virtual bool DoesBranch() = 0;\n\n  virtual bool HasDelaySlot();\n\n  bool CanSetBreakpoint ();\n\n  virtual size_t Decode(const Disassembler &disassembler,\n                        const DataExtractor &data,\n                        lldb::offset_t data_offset) = 0;\n\n  virtual void SetDescription(llvm::StringRef) {\n  } // May be overridden in sub-classes that have descriptions.\n\n  lldb::OptionValueSP ReadArray(FILE *in_file, Stream *out_stream,\n                                OptionValue::Type data_type);\n\n  lldb::OptionValueSP ReadDictionary(FILE *in_file, Stream *out_stream);\n\n  bool DumpEmulation(const ArchSpec &arch);\n\n  virtual bool TestEmulation(Stream *stream, const char *test_file_name);\n\n  bool Emulate(const ArchSpec &arch, uint32_t evaluate_options, void *baton,\n               EmulateInstruction::ReadMemoryCallback read_mem_callback,\n               EmulateInstruction::WriteMemoryCallback write_mem_calback,\n               EmulateInstruction::ReadRegisterCallback read_reg_callback,\n               EmulateInstruction::WriteRegisterCallback write_reg_callback);\n\n  const Opcode &GetOpcode() const { return m_opcode; }\n\n  uint32_t GetData(DataExtractor &data);\n\n  struct Operand {\n    enum class Type {\n      Invalid = 0,\n      Register,\n      Immediate,\n      Dereference,\n      Sum,\n      Product\n    } m_type = Type::Invalid;\n    std::vector<Operand> m_children;\n    lldb::addr_t m_immediate = 0;\n    ConstString m_register;\n    bool m_negative = false;\n    bool m_clobbered = false;\n\n    bool IsValid() { return m_type != Type::Invalid; }\n\n    static Operand BuildRegister(ConstString &r);\n    static Operand BuildImmediate(lldb::addr_t imm, bool neg);\n    static Operand BuildImmediate(int64_t imm);\n    static Operand BuildDereference(const Operand &ref);\n    static Operand BuildSum(const Operand &lhs, const Operand &rhs);\n    static Operand BuildProduct(const Operand &lhs, const Operand &rhs);\n  };\n\n  virtual bool ParseOperands(llvm::SmallVectorImpl<Operand> &operands) {\n    return false;\n  }\n\n  virtual bool IsCall() { return false; }\n\nprotected:\n  Address m_address; // The section offset address of this instruction\n                     // We include an address class in the Instruction class to\n                     // allow the instruction specify the\n                     // AddressClass::eCodeAlternateISA (currently used for\n                     // thumb), and also to specify data (AddressClass::eData).\n                     // The usual value will be AddressClass::eCode, but often\n                     // when disassembling memory, you might run into data.\n                     // This can help us to disassemble appropriately.\nprivate:\n  AddressClass m_address_class; // Use GetAddressClass () accessor function!\n\nprotected:\n  Opcode m_opcode; // The opcode for this instruction\n  std::string m_opcode_name;\n  std::string m_mnemonics;\n  std::string m_comment;\n  bool m_calculated_strings;\n\n  void\n  CalculateMnemonicOperandsAndCommentIfNeeded(const ExecutionContext *exe_ctx) {\n    if (!m_calculated_strings) {\n      m_calculated_strings = true;\n      CalculateMnemonicOperandsAndComment(exe_ctx);\n    }\n  }\n};\n\nnamespace OperandMatchers {\nstd::function<bool(const Instruction::Operand &)>\nMatchBinaryOp(std::function<bool(const Instruction::Operand &)> base,\n              std::function<bool(const Instruction::Operand &)> left,\n              std::function<bool(const Instruction::Operand &)> right);\n\nstd::function<bool(const Instruction::Operand &)>\nMatchUnaryOp(std::function<bool(const Instruction::Operand &)> base,\n             std::function<bool(const Instruction::Operand &)> child);\n\nstd::function<bool(const Instruction::Operand &)>\nMatchRegOp(const RegisterInfo &info);\n\nstd::function<bool(const Instruction::Operand &)> FetchRegOp(ConstString &reg);\n\nstd::function<bool(const Instruction::Operand &)> MatchImmOp(int64_t imm);\n\nstd::function<bool(const Instruction::Operand &)> FetchImmOp(int64_t &imm);\n\nstd::function<bool(const Instruction::Operand &)>\nMatchOpType(Instruction::Operand::Type type);\n}\n\nclass InstructionList {\npublic:\n  InstructionList();\n  ~InstructionList();\n\n  size_t GetSize() const;\n\n  uint32_t GetMaxOpcocdeByteSize() const;\n\n  lldb::InstructionSP GetInstructionAtIndex(size_t idx) const;\n\n  /// Get the instruction at the given address.\n  ///\n  /// \\return\n  ///    A valid \\a InstructionSP if the address could be found, or null\n  ///    otherwise.\n  lldb::InstructionSP GetInstructionAtAddress(const Address &addr);\n\n  //------------------------------------------------------------------\n  /// Get the index of the next branch instruction.\n  ///\n  /// Given a list of instructions, find the next branch instruction\n  /// in the list by returning an index.\n  ///\n  /// @param[in] start\n  ///     The instruction index of the first instruction to check.\n  ///\n  /// @param[in] ignore_calls\n  ///     It true, then fine the first branch instruction that isn't\n  ///     a function call (a branch that calls and returns to the next\n  ///     instruction). If false, find the instruction index of any \n  ///     branch in the list.\n  ///     \n  /// @param[out] found_calls\n  ///     If non-null, this will be set to true if any calls were found in \n  ///     extending the range.\n  ///    \n  /// @return\n  ///     The instruction index of the first branch that is at or past\n  ///     \\a start. Returns UINT32_MAX if no matching branches are \n  ///     found.\n  //------------------------------------------------------------------\n  uint32_t GetIndexOfNextBranchInstruction(uint32_t start,\n                                           bool ignore_calls,\n                                           bool *found_calls) const;\n\n  uint32_t GetIndexOfInstructionAtLoadAddress(lldb::addr_t load_addr,\n                                              Target &target);\n\n  uint32_t GetIndexOfInstructionAtAddress(const Address &addr);\n\n  void Clear();\n\n  void Append(lldb::InstructionSP &inst_sp);\n\n  void Dump(Stream *s, bool show_address, bool show_bytes,\n            const ExecutionContext *exe_ctx);\n\nprivate:\n  typedef std::vector<lldb::InstructionSP> collection;\n  typedef collection::iterator iterator;\n  typedef collection::const_iterator const_iterator;\n\n  collection m_instructions;\n};\n\nclass PseudoInstruction : public Instruction {\npublic:\n  PseudoInstruction();\n\n  ~PseudoInstruction() override;\n\n  bool DoesBranch() override;\n\n  bool HasDelaySlot() override;\n\n  void CalculateMnemonicOperandsAndComment(\n      const ExecutionContext *exe_ctx) override {\n    // TODO: fill this in and put opcode name into Instruction::m_opcode_name,\n    // mnemonic into Instruction::m_mnemonics, and any comment into\n    // Instruction::m_comment\n  }\n\n  size_t Decode(const Disassembler &disassembler, const DataExtractor &data,\n                lldb::offset_t data_offset) override;\n\n  void SetOpcode(size_t opcode_size, void *opcode_data);\n\n  void SetDescription(llvm::StringRef description) override;\n\nprotected:\n  std::string m_description;\n\n  PseudoInstruction(const PseudoInstruction &) = delete;\n  const PseudoInstruction &operator=(const PseudoInstruction &) = delete;\n};\n\nclass Disassembler : public std::enable_shared_from_this<Disassembler>,\n                     public PluginInterface {\npublic:\n  enum {\n    eOptionNone = 0u,\n    eOptionShowBytes = (1u << 0),\n    eOptionRawOuput = (1u << 1),\n    eOptionMarkPCSourceLine = (1u << 2), // Mark the source line that contains\n                                         // the current PC (mixed mode only)\n    eOptionMarkPCAddress =\n        (1u << 3) // Mark the disassembly line the contains the PC\n  };\n\n  enum HexImmediateStyle {\n    eHexStyleC,\n    eHexStyleAsm,\n  };\n\n  // FindPlugin should be lax about the flavor string (it is too annoying to\n  // have various internal uses of the disassembler fail because the global\n  // flavor string gets set wrong. Instead, if you get a flavor string you\n  // don't understand, use the default.  Folks who care to check can use the\n  // FlavorValidForArchSpec method on the disassembler they got back.\n  static lldb::DisassemblerSP\n  FindPlugin(const ArchSpec &arch, const char *flavor, const char *plugin_name);\n\n  // This version will use the value in the Target settings if flavor is NULL;\n  static lldb::DisassemblerSP FindPluginForTarget(const Target &target,\n                                                  const ArchSpec &arch,\n                                                  const char *flavor,\n                                                  const char *plugin_name);\n\n  struct Limit {\n    enum { Bytes, Instructions } kind;\n    lldb::addr_t value;\n  };\n\n  static lldb::DisassemblerSP\n  DisassembleRange(const ArchSpec &arch, const char *plugin_name,\n                   const char *flavor, Target &target,\n                   const AddressRange &disasm_range, bool prefer_file_cache);\n\n  static lldb::DisassemblerSP\n  DisassembleBytes(const ArchSpec &arch, const char *plugin_name,\n                   const char *flavor, const Address &start, const void *bytes,\n                   size_t length, uint32_t max_num_instructions,\n                   bool data_from_file);\n\n  static bool Disassemble(Debugger &debugger, const ArchSpec &arch,\n                          const char *plugin_name, const char *flavor,\n                          const ExecutionContext &exe_ctx, const Address &start,\n                          Limit limit, bool mixed_source_and_assembly,\n                          uint32_t num_mixed_context_lines, uint32_t options,\n                          Stream &strm);\n\n  static bool Disassemble(Debugger &debugger, const ArchSpec &arch,\n                          StackFrame &frame, Stream &strm);\n\n  // Constructors and Destructors\n  Disassembler(const ArchSpec &arch, const char *flavor);\n  ~Disassembler() override;\n\n  void PrintInstructions(Debugger &debugger, const ArchSpec &arch,\n                         const ExecutionContext &exe_ctx,\n                         bool mixed_source_and_assembly,\n                         uint32_t num_mixed_context_lines, uint32_t options,\n                         Stream &strm);\n\n  size_t ParseInstructions(Target &target, Address address, Limit limit,\n                           Stream *error_strm_ptr, bool prefer_file_cache);\n\n  virtual size_t DecodeInstructions(const Address &base_addr,\n                                    const DataExtractor &data,\n                                    lldb::offset_t data_offset,\n                                    size_t num_instructions, bool append,\n                                    bool data_from_file) = 0;\n\n  InstructionList &GetInstructionList();\n\n  const InstructionList &GetInstructionList() const;\n\n  const ArchSpec &GetArchitecture() const { return m_arch; }\n\n  const char *GetFlavor() const { return m_flavor.c_str(); }\n\n  virtual bool FlavorValidForArchSpec(const lldb_private::ArchSpec &arch,\n                                      const char *flavor) = 0;\n\nprotected:\n  // SourceLine and SourceLinesToDisplay structures are only used in the mixed\n  // source and assembly display methods internal to this class.\n\n  struct SourceLine {\n    FileSpec file;\n    uint32_t line;\n    uint32_t column;\n\n    SourceLine() : file(), line(LLDB_INVALID_LINE_NUMBER), column(0) {}\n\n    bool operator==(const SourceLine &rhs) const {\n      return file == rhs.file && line == rhs.line && rhs.column == column;\n    }\n\n    bool operator!=(const SourceLine &rhs) const {\n      return file != rhs.file || line != rhs.line || column != rhs.column;\n    }\n\n    bool IsValid() const { return line != LLDB_INVALID_LINE_NUMBER; }\n  };\n\n  struct SourceLinesToDisplay {\n    std::vector<SourceLine> lines;\n\n    // index of the \"current\" source line, if we want to highlight that when\n    // displaying the source lines.  (as opposed to the surrounding source\n    // lines provided to give context)\n    size_t current_source_line;\n\n    // Whether to print a blank line at the end of the source lines.\n    bool print_source_context_end_eol;\n\n    SourceLinesToDisplay()\n        : lines(), current_source_line(-1), print_source_context_end_eol(true) {\n    }\n  };\n\n  // Get the function's declaration line number, hopefully a line number\n  // earlier than the opening curly brace at the start of the function body.\n  static SourceLine GetFunctionDeclLineEntry(const SymbolContext &sc);\n\n  // Add the provided SourceLine to the map of filenames-to-source-lines-seen.\n  static void AddLineToSourceLineTables(\n      SourceLine &line,\n      std::map<FileSpec, std::set<uint32_t>> &source_lines_seen);\n\n  // Given a source line, determine if we should print it when we're doing\n  // mixed source & assembly output. We're currently using the\n  // target.process.thread.step-avoid-regexp setting (which is used for\n  // stepping over inlined STL functions by default) to determine what source\n  // lines to avoid showing.\n  //\n  // Returns true if this source line should be elided (if the source line\n  // should not be displayed).\n  static bool\n  ElideMixedSourceAndDisassemblyLine(const ExecutionContext &exe_ctx,\n                                     const SymbolContext &sc, SourceLine &line);\n\n  static bool\n  ElideMixedSourceAndDisassemblyLine(const ExecutionContext &exe_ctx,\n                                     const SymbolContext &sc, LineEntry &line) {\n    SourceLine sl;\n    sl.file = line.file;\n    sl.line = line.line;\n    sl.column = line.column;\n    return ElideMixedSourceAndDisassemblyLine(exe_ctx, sc, sl);\n  };\n\n  // Classes that inherit from Disassembler can see and modify these\n  ArchSpec m_arch;\n  InstructionList m_instruction_list;\n  lldb::addr_t m_base_addr;\n  std::string m_flavor;\n\nprivate:\n  // For Disassembler only\n  Disassembler(const Disassembler &) = delete;\n  const Disassembler &operator=(const Disassembler &) = delete;\n};\n\n} // namespace lldb_private\n\n#endif // LLDB_CORE_DISASSEMBLER_H\n"}, "4": {"id": 4, "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Core/EmulateInstruction.h", "content": "//===-- EmulateInstruction.h ------------------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLDB_CORE_EMULATEINSTRUCTION_H\n#define LLDB_CORE_EMULATEINSTRUCTION_H\n\n#include <string>\n\n#include \"lldb/Core/Address.h\"\n#include \"lldb/Core/Opcode.h\"\n#include \"lldb/Core/PluginInterface.h\"\n#include \"lldb/Utility/ArchSpec.h\"\n#include \"lldb/lldb-defines.h\"\n#include \"lldb/lldb-enumerations.h\"\n#include \"lldb/lldb-private-enumerations.h\"\n#include \"lldb/lldb-private-types.h\"\n#include \"lldb/lldb-types.h\"\n\n#include <stddef.h>\n#include <stdint.h>\n\nnamespace lldb_private {\nclass OptionValueDictionary;\nclass RegisterContext;\nclass RegisterValue;\nclass Stream;\nclass Target;\nclass UnwindPlan;\n\n/// \\class EmulateInstruction EmulateInstruction.h\n/// \"lldb/Core/EmulateInstruction.h\"\n/// A class that allows emulation of CPU opcodes.\n///\n/// This class is a plug-in interface that is accessed through the standard\n/// static FindPlugin function call in the EmulateInstruction class. The\n/// FindPlugin takes a target triple and returns a new object if there is a\n/// plug-in that supports the architecture and OS. Four callbacks and a baton\n/// are provided. The four callbacks are read register, write register, read\n/// memory and write memory.\n///\n/// This class is currently designed for these main use cases: - Auto\n/// generation of Call Frame Information (CFI) from assembly code - Predicting\n/// single step breakpoint locations - Emulating instructions for breakpoint\n/// traps\n///\n/// Objects can be asked to read an instruction which will cause a call to the\n/// read register callback to get the PC, followed by a read memory call to\n/// read the opcode. If ReadInstruction () returns true, then a call to\n/// EmulateInstruction::EvaluateInstruction () can be made. At this point the\n/// EmulateInstruction subclass will use all of the callbacks to emulate an\n/// instruction.\n///\n/// Clients that provide the callbacks can either do the read/write\n/// registers/memory to actually emulate the instruction on a real or virtual\n/// CPU, or watch for the EmulateInstruction::Context which is context for the\n/// read/write register/memory which explains why the callback is being\n/// called. Examples of a context are: \"pushing register 3 onto the stack at\n/// offset -12\", or \"adjusting stack pointer by -16\". This extra context\n/// allows the generation of\n/// CFI information from assembly code without having to actually do\n/// the read/write register/memory.\n///\n/// Clients must be prepared that not all instructions for an Instruction Set\n/// Architecture (ISA) will be emulated.\n///\n/// Subclasses at the very least should implement the instructions that save\n/// and restore registers onto the stack and adjustment to the stack pointer.\n/// By just implementing a few instructions for an ISA that are the typical\n/// prologue opcodes, you can then generate CFI using a class that will soon\n/// be available.\n///\n/// Implementing all of the instructions that affect the PC can then allow\n/// single step prediction support.\n///\n/// Implementing all of the instructions allows for emulation of opcodes for\n/// breakpoint traps and will pave the way for \"thread centric\" debugging. The\n/// current debugging model is \"process centric\" where all threads must be\n/// stopped when any thread is stopped; when hitting software breakpoints we\n/// must disable the breakpoint by restoring the original breakpoint opcode,\n/// single stepping and restoring the breakpoint trap. If all threads were\n/// allowed to run then other threads could miss the breakpoint.\n///\n/// This class centralizes the code that usually is done in separate code\n/// paths in a debugger (single step prediction, finding save restore\n/// locations of registers for unwinding stack frame variables) and emulating\n/// the instruction is just a bonus.\n\nclass EmulateInstruction : public PluginInterface {\npublic:\n  static EmulateInstruction *FindPlugin(const ArchSpec &arch,\n                                        InstructionType supported_inst_type,\n                                        const char *plugin_name);\n\n  enum ContextType {\n    eContextInvalid = 0,\n    // Read an instruction opcode from memory\n    eContextReadOpcode,\n\n    // Usually used for writing a register value whose source value is an\n    // immediate\n    eContextImmediate,\n\n    // Exclusively used when saving a register to the stack as part of the\n    // prologue\n    eContextPushRegisterOnStack,\n\n    // Exclusively used when restoring a register off the stack as part of the\n    // epilogue\n    eContextPopRegisterOffStack,\n\n    // Add or subtract a value from the stack\n    eContextAdjustStackPointer,\n\n    // Adjust the frame pointer for the current frame\n    eContextSetFramePointer,\n\n    // Typically in an epilogue sequence.  Copy the frame pointer back into the\n    // stack pointer, use SP for CFA calculations again.\n    eContextRestoreStackPointer,\n\n    // Add or subtract a value from a base address register (other than SP)\n    eContextAdjustBaseRegister,\n\n    // Add or subtract a value from the PC or store a value to the PC.\n    eContextAdjustPC,\n\n    // Used in WriteRegister callbacks to indicate where the\n    eContextRegisterPlusOffset,\n\n    // Used in WriteMemory callback to indicate where the data came from\n    eContextRegisterStore,\n\n    eContextRegisterLoad,\n\n    // Used when performing a PC-relative branch where the\n    eContextRelativeBranchImmediate,\n\n    // Used when performing an absolute branch where the\n    eContextAbsoluteBranchRegister,\n\n    // Used when performing a supervisor call to an operating system to provide\n    // a service:\n    eContextSupervisorCall,\n\n    // Used when performing a MemU operation to read the PC-relative offset\n    // from an address.\n    eContextTableBranchReadMemory,\n\n    // Used when random bits are written into a register\n    eContextWriteRegisterRandomBits,\n\n    // Used when random bits are written to memory\n    eContextWriteMemoryRandomBits,\n\n    eContextArithmetic,\n\n    eContextAdvancePC,\n\n    eContextReturnFromException\n  };\n\n  enum InfoType {\n    eInfoTypeRegisterPlusOffset,\n    eInfoTypeRegisterPlusIndirectOffset,\n    eInfoTypeRegisterToRegisterPlusOffset,\n    eInfoTypeRegisterToRegisterPlusIndirectOffset,\n    eInfoTypeRegisterRegisterOperands,\n    eInfoTypeOffset,\n    eInfoTypeRegister,\n    eInfoTypeImmediate,\n    eInfoTypeImmediateSigned,\n    eInfoTypeAddress,\n    eInfoTypeISAAndImmediate,\n    eInfoTypeISAAndImmediateSigned,\n    eInfoTypeISA,\n    eInfoTypeNoArgs\n  } InfoType;\n\n  struct Context {\n    ContextType type;\n    enum InfoType info_type;\n    union {\n      struct RegisterPlusOffset {\n        RegisterInfo reg;      // base register\n        int64_t signed_offset; // signed offset added to base register\n      } RegisterPlusOffset;\n\n      struct RegisterPlusIndirectOffset {\n        RegisterInfo base_reg;   // base register number\n        RegisterInfo offset_reg; // offset register kind\n      } RegisterPlusIndirectOffset;\n\n      struct RegisterToRegisterPlusOffset {\n        RegisterInfo data_reg; // source/target register for data\n        RegisterInfo base_reg; // base register for address calculation\n        int64_t offset;        // offset for address calculation\n      } RegisterToRegisterPlusOffset;\n\n      struct RegisterToRegisterPlusIndirectOffset {\n        RegisterInfo base_reg;   // base register for address calculation\n        RegisterInfo offset_reg; // offset register for address calculation\n        RegisterInfo data_reg;   // source/target register for data\n      } RegisterToRegisterPlusIndirectOffset;\n\n      struct RegisterRegisterOperands {\n        RegisterInfo\n            operand1; // register containing first operand for binary op\n        RegisterInfo\n            operand2; // register containing second operand for binary op\n      } RegisterRegisterOperands;\n\n      int64_t signed_offset; // signed offset by which to adjust self (for\n                             // registers only)\n\n      RegisterInfo reg; // plain register\n\n      uint64_t unsigned_immediate; // unsigned immediate value\n      int64_t signed_immediate;    // signed immediate value\n\n      lldb::addr_t address; // direct address\n\n      struct ISAAndImmediate {\n        uint32_t isa;\n        uint32_t unsigned_data32; // immediate data\n      } ISAAndImmediate;\n\n      struct ISAAndImmediateSigned {\n        uint32_t isa;\n        int32_t signed_data32; // signed immediate data\n      } ISAAndImmediateSigned;\n\n      uint32_t isa;\n    } info;\n\n    Context() : type(eContextInvalid), info_type(eInfoTypeNoArgs) {}\n\n    void SetRegisterPlusOffset(RegisterInfo base_reg, int64_t signed_offset) {\n      info_type = eInfoTypeRegisterPlusOffset;\n      info.RegisterPlusOffset.reg = base_reg;\n      info.RegisterPlusOffset.signed_offset = signed_offset;\n    }\n\n    void SetRegisterPlusIndirectOffset(RegisterInfo base_reg,\n                                       RegisterInfo offset_reg) {\n      info_type = eInfoTypeRegisterPlusIndirectOffset;\n      info.RegisterPlusIndirectOffset.base_reg = base_reg;\n      info.RegisterPlusIndirectOffset.offset_reg = offset_reg;\n    }\n\n    void SetRegisterToRegisterPlusOffset(RegisterInfo data_reg,\n                                         RegisterInfo base_reg,\n                                         int64_t offset) {\n      info_type = eInfoTypeRegisterToRegisterPlusOffset;\n      info.RegisterToRegisterPlusOffset.data_reg = data_reg;\n      info.RegisterToRegisterPlusOffset.base_reg = base_reg;\n      info.RegisterToRegisterPlusOffset.offset = offset;\n    }\n\n    void SetRegisterToRegisterPlusIndirectOffset(RegisterInfo base_reg,\n                                                 RegisterInfo offset_reg,\n                                                 RegisterInfo data_reg) {\n      info_type = eInfoTypeRegisterToRegisterPlusIndirectOffset;\n      info.RegisterToRegisterPlusIndirectOffset.base_reg = base_reg;\n      info.RegisterToRegisterPlusIndirectOffset.offset_reg = offset_reg;\n      info.RegisterToRegisterPlusIndirectOffset.data_reg = data_reg;\n    }\n\n    void SetRegisterRegisterOperands(RegisterInfo op1_reg,\n                                     RegisterInfo op2_reg) {\n      info_type = eInfoTypeRegisterRegisterOperands;\n      info.RegisterRegisterOperands.operand1 = op1_reg;\n      info.RegisterRegisterOperands.operand2 = op2_reg;\n    }\n\n    void SetOffset(int64_t signed_offset) {\n      info_type = eInfoTypeOffset;\n      info.signed_offset = signed_offset;\n    }\n\n    void SetRegister(RegisterInfo reg) {\n      info_type = eInfoTypeRegister;\n      info.reg = reg;\n    }\n\n    void SetImmediate(uint64_t immediate) {\n      info_type = eInfoTypeImmediate;\n      info.unsigned_immediate = immediate;\n    }\n\n    void SetImmediateSigned(int64_t signed_immediate) {\n      info_type = eInfoTypeImmediateSigned;\n      info.signed_immediate = signed_immediate;\n    }\n\n    void SetAddress(lldb::addr_t address) {\n      info_type = eInfoTypeAddress;\n      info.address = address;\n    }\n    void SetISAAndImmediate(uint32_t isa, uint32_t data) {\n      info_type = eInfoTypeISAAndImmediate;\n      info.ISAAndImmediate.isa = isa;\n      info.ISAAndImmediate.unsigned_data32 = data;\n    }\n\n    void SetISAAndImmediateSigned(uint32_t isa, int32_t data) {\n      info_type = eInfoTypeISAAndImmediateSigned;\n      info.ISAAndImmediateSigned.isa = isa;\n      info.ISAAndImmediateSigned.signed_data32 = data;\n    }\n\n    void SetISA(uint32_t isa) {\n      info_type = eInfoTypeISA;\n      info.isa = isa;\n    }\n\n    void SetNoArgs() { info_type = eInfoTypeNoArgs; }\n\n    void Dump(Stream &s, EmulateInstruction *instruction) const;\n  };\n\n  typedef size_t (*ReadMemoryCallback)(EmulateInstruction *instruction,\n                                       void *baton, const Context &context,\n                                       lldb::addr_t addr, void *dst,\n                                       size_t length);\n\n  typedef size_t (*WriteMemoryCallback)(EmulateInstruction *instruction,\n                                        void *baton, const Context &context,\n                                        lldb::addr_t addr, const void *dst,\n                                        size_t length);\n\n  typedef bool (*ReadRegisterCallback)(EmulateInstruction *instruction,\n                                       void *baton,\n                                       const RegisterInfo *reg_info,\n                                       RegisterValue &reg_value);\n\n  typedef bool (*WriteRegisterCallback)(EmulateInstruction *instruction,\n                                        void *baton, const Context &context,\n                                        const RegisterInfo *reg_info,\n                                        const RegisterValue &reg_value);\n\n  // Type to represent the condition of an instruction. The UINT32 value is\n  // reserved for the unconditional case and all other value can be used in an\n  // architecture dependent way.\n  typedef uint32_t InstructionCondition;\n  static const InstructionCondition UnconditionalCondition = UINT32_MAX;\n\n  EmulateInstruction(const ArchSpec &arch);\n\n  ~EmulateInstruction() override = default;\n\n  // Mandatory overrides\n  virtual bool\n  SupportsEmulatingInstructionsOfType(InstructionType inst_type) = 0;\n\n  virtual bool SetTargetTriple(const ArchSpec &arch) = 0;\n\n  virtual bool ReadInstruction() = 0;\n\n  virtual bool EvaluateInstruction(uint32_t evaluate_options) = 0;\n\n  virtual InstructionCondition GetInstructionCondition() {\n    return UnconditionalCondition;\n  }\n\n  virtual bool TestEmulation(Stream *out_stream, ArchSpec &arch,\n                             OptionValueDictionary *test_data) = 0;\n\n  virtual bool GetRegisterInfo(lldb::RegisterKind reg_kind, uint32_t reg_num,\n                               RegisterInfo &reg_info) = 0;\n\n  // Optional overrides\n  virtual bool SetInstruction(const Opcode &insn_opcode,\n                              const Address &inst_addr, Target *target);\n\n  virtual bool CreateFunctionEntryUnwind(UnwindPlan &unwind_plan);\n\n  static const char *TranslateRegister(lldb::RegisterKind reg_kind,\n                                       uint32_t reg_num, std::string &reg_name);\n\n  // RegisterInfo variants\n  bool ReadRegister(const RegisterInfo *reg_info, RegisterValue &reg_value);\n\n  uint64_t ReadRegisterUnsigned(const RegisterInfo *reg_info,\n                                uint64_t fail_value, bool *success_ptr);\n\n  bool WriteRegister(const Context &context, const RegisterInfo *ref_info,\n                     const RegisterValue &reg_value);\n\n  bool WriteRegisterUnsigned(const Context &context,\n                             const RegisterInfo *reg_info, uint64_t reg_value);\n\n  // Register kind and number variants\n  bool ReadRegister(lldb::RegisterKind reg_kind, uint32_t reg_num,\n                    RegisterValue &reg_value);\n\n  bool WriteRegister(const Context &context, lldb::RegisterKind reg_kind,\n                     uint32_t reg_num, const RegisterValue &reg_value);\n\n  uint64_t ReadRegisterUnsigned(lldb::RegisterKind reg_kind, uint32_t reg_num,\n                                uint64_t fail_value, bool *success_ptr);\n\n  bool WriteRegisterUnsigned(const Context &context,\n                             lldb::RegisterKind reg_kind, uint32_t reg_num,\n                             uint64_t reg_value);\n\n  size_t ReadMemory(const Context &context, lldb::addr_t addr, void *dst,\n                    size_t dst_len);\n\n  uint64_t ReadMemoryUnsigned(const Context &context, lldb::addr_t addr,\n                              size_t byte_size, uint64_t fail_value,\n                              bool *success_ptr);\n\n  bool WriteMemory(const Context &context, lldb::addr_t addr, const void *src,\n                   size_t src_len);\n\n  bool WriteMemoryUnsigned(const Context &context, lldb::addr_t addr,\n                           uint64_t uval, size_t uval_byte_size);\n\n  uint32_t GetAddressByteSize() const { return m_arch.GetAddressByteSize(); }\n\n  lldb::ByteOrder GetByteOrder() const { return m_arch.GetByteOrder(); }\n\n  const Opcode &GetOpcode() const { return m_opcode; }\n\n  lldb::addr_t GetAddress() const { return m_addr; }\n\n  const ArchSpec &GetArchitecture() const { return m_arch; }\n\n  static size_t ReadMemoryFrame(EmulateInstruction *instruction, void *baton,\n                                const Context &context, lldb::addr_t addr,\n                                void *dst, size_t length);\n\n  static size_t WriteMemoryFrame(EmulateInstruction *instruction, void *baton,\n                                 const Context &context, lldb::addr_t addr,\n                                 const void *dst, size_t length);\n\n  static bool ReadRegisterFrame(EmulateInstruction *instruction, void *baton,\n                                const RegisterInfo *reg_info,\n                                RegisterValue &reg_value);\n\n  static bool WriteRegisterFrame(EmulateInstruction *instruction, void *baton,\n                                 const Context &context,\n                                 const RegisterInfo *reg_info,\n                                 const RegisterValue &reg_value);\n\n  static size_t ReadMemoryDefault(EmulateInstruction *instruction, void *baton,\n                                  const Context &context, lldb::addr_t addr,\n                                  void *dst, size_t length);\n\n  static size_t WriteMemoryDefault(EmulateInstruction *instruction, void *baton,\n                                   const Context &context, lldb::addr_t addr,\n                                   const void *dst, size_t length);\n\n  static bool ReadRegisterDefault(EmulateInstruction *instruction, void *baton,\n                                  const RegisterInfo *reg_info,\n                                  RegisterValue &reg_value);\n\n  static bool WriteRegisterDefault(EmulateInstruction *instruction, void *baton,\n                                   const Context &context,\n                                   const RegisterInfo *reg_info,\n                                   const RegisterValue &reg_value);\n\n  void SetBaton(void *baton);\n\n  void SetCallbacks(ReadMemoryCallback read_mem_callback,\n                    WriteMemoryCallback write_mem_callback,\n                    ReadRegisterCallback read_reg_callback,\n                    WriteRegisterCallback write_reg_callback);\n\n  void SetReadMemCallback(ReadMemoryCallback read_mem_callback);\n\n  void SetWriteMemCallback(WriteMemoryCallback write_mem_callback);\n\n  void SetReadRegCallback(ReadRegisterCallback read_reg_callback);\n\n  void SetWriteRegCallback(WriteRegisterCallback write_reg_callback);\n\n  static bool GetBestRegisterKindAndNumber(const RegisterInfo *reg_info,\n                                           lldb::RegisterKind &reg_kind,\n                                           uint32_t &reg_num);\n\n  static uint32_t GetInternalRegisterNumber(RegisterContext *reg_ctx,\n                                            const RegisterInfo &reg_info);\n\nprotected:\n  ArchSpec m_arch;\n  void *m_baton = nullptr;\n  ReadMemoryCallback m_read_mem_callback = &ReadMemoryDefault;\n  WriteMemoryCallback m_write_mem_callback = &WriteMemoryDefault;\n  ReadRegisterCallback m_read_reg_callback = &ReadRegisterDefault;\n  WriteRegisterCallback m_write_reg_callback = &WriteRegisterDefault;\n  lldb::addr_t m_addr = LLDB_INVALID_ADDRESS;\n  Opcode m_opcode;\n\nprivate:\n  // For EmulateInstruction only\n  EmulateInstruction(const EmulateInstruction &) = delete;\n  const EmulateInstruction &operator=(const EmulateInstruction &) = delete;\n};\n\n} // namespace lldb_private\n\n#endif // LLDB_CORE_EMULATEINSTRUCTION_H\n"}, "5": {"id": 5, "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Core/FileSpecList.h", "content": "//===-- FileSpecList.h ------------------------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLDB_CORE_FILESPECLIST_H\n#define LLDB_CORE_FILESPECLIST_H\n#if defined(__cplusplus)\n\n#include \"lldb/Utility/FileSpec.h\"\n\n#include <vector>\n\n#include <stddef.h>\n\nnamespace lldb_private {\nclass Stream;\n\n/// \\class FileSpecList FileSpecList.h \"lldb/Core/FileSpecList.h\"\n/// A file collection class.\n///\n/// A class that contains a mutable list of FileSpec objects.\nclass FileSpecList {\npublic:\n  typedef std::vector<FileSpec> collection;\n  typedef collection::const_iterator const_iterator;\n\n  /// Default constructor.\n  ///\n  /// Initialize this object with an empty file list.\n  FileSpecList();\n\n  /// Copy constructor.\n  FileSpecList(const FileSpecList &rhs) = default;\n\n  /// Move constructor\n  FileSpecList(FileSpecList &&rhs) = default;\n\n  /// Initialize this object from a vector of FileSpecs\n  FileSpecList(std::vector<FileSpec> &&rhs) : m_files(std::move(rhs)) {}\n\n  /// Destructor.\n  ~FileSpecList();\n\n  /// Assignment operator.\n  ///\n  /// Replace the file list in this object with the file list from \\a rhs.\n  ///\n  /// \\param[in] rhs\n  ///     A file list object to copy.\n  ///\n  /// \\return\n  ///     A const reference to this object.\n  FileSpecList &operator=(const FileSpecList &rhs) = default;\n\n  /// Move-assignment operator.\n  FileSpecList &operator=(FileSpecList &&rhs) = default;\n\n  /// Append a FileSpec object to the list.\n  ///\n  /// Appends \\a file to the end of the file list.\n  ///\n  /// \\param[in] file\n  ///     A new file to append to this file list.\n  void Append(const FileSpec &file);\n\n  /// Append a FileSpec object if unique.\n  ///\n  /// Appends \\a file to the end of the file list if it doesn't already exist\n  /// in the file list.\n  ///\n  /// \\param[in] file\n  ///     A new file to append to this file list.\n  ///\n  /// \\return\n  ///     \\b true if the file was appended, \\b false otherwise.\n  bool AppendIfUnique(const FileSpec &file);\n\n  /// Inserts a new FileSpec into the FileSpecList constructed in-place with\n  /// the given arguments.\n  ///\n  /// \\param[in] args\n  ///     Arguments to create the FileSpec\n  template <class... Args> void EmplaceBack(Args &&... args) {\n    m_files.emplace_back(std::forward<Args>(args)...);\n  }\n\n  /// Clears the file list.\n  void Clear();\n\n  /// Dumps the file list to the supplied stream pointer \"s\".\n  ///\n  /// \\param[in] s\n  ///     The stream that will be used to dump the object description.\n  void Dump(Stream *s, const char *separator_cstr = \"\\n\") const;\n\n  /// Find a file index.\n  ///\n  /// Find the index of the file in the file spec list that matches \\a file\n  /// starting \\a idx entries into the file spec list.\n  ///\n  /// \\param[in] idx\n  ///     An index into the file list.\n  ///\n  /// \\param[in] file\n  ///     The file specification to search for.\n  ///\n  /// \\param[in] full\n  ///     Should FileSpec::Equal be called with \"full\" true or false.\n  ///\n  /// \\return\n  ///     The index of the file that matches \\a file if it is found,\n  ///     else UINT32_MAX is returned.\n  size_t FindFileIndex(size_t idx, const FileSpec &file, bool full) const;\n\n  /// Get file at index.\n  ///\n  /// Gets a file from the file list. If \\a idx is not a valid index, an empty\n  /// FileSpec object will be returned. The file objects that are returned can\n  /// be tested using FileSpec::operator void*().\n  ///\n  /// \\param[in] idx\n  ///     An index into the file list.\n  ///\n  /// \\return\n  ///     A copy of the FileSpec object at index \\a idx. If \\a idx\n  ///     is out of range, then an empty FileSpec object will be\n  ///     returned.\n  const FileSpec &GetFileSpecAtIndex(size_t idx) const;\n\n  /// Get file specification pointer at index.\n  ///\n  /// Gets a file from the file list. The file objects that are returned can\n  /// be tested using FileSpec::operator void*().\n  ///\n  /// \\param[in] idx\n  ///     An index into the file list.\n  ///\n  /// \\return\n  ///     A pointer to a contained FileSpec object at index \\a idx.\n  ///     If \\a idx is out of range, then an NULL is returned.\n  const FileSpec *GetFileSpecPointerAtIndex(size_t idx) const;\n\n  /// Get the memory cost of this object.\n  ///\n  /// Return the size in bytes that this object takes in memory. This returns\n  /// the size in bytes of this object, not any shared string values it may\n  /// refer to.\n  ///\n  /// \\return\n  ///     The number of bytes that this object occupies in memory.\n  ///\n  /// \\see ConstString::StaticMemorySize ()\n  size_t MemorySize() const;\n\n  bool IsEmpty() const { return m_files.empty(); }\n\n  /// Get the number of files in the file list.\n  ///\n  /// \\return\n  ///     The number of files in the file spec list.\n  size_t GetSize() const;\n\n  bool Insert(size_t idx, const FileSpec &file) {\n    if (idx < m_files.size()) {\n      m_files.insert(m_files.begin() + idx, file);\n      return true;\n    } else if (idx == m_files.size()) {\n      m_files.push_back(file);\n      return true;\n    }\n    return false;\n  }\n\n  bool Replace(size_t idx, const FileSpec &file) {\n    if (idx < m_files.size()) {\n      m_files[idx] = file;\n      return true;\n    }\n    return false;\n  }\n\n  bool Remove(size_t idx) {\n    if (idx < m_files.size()) {\n      m_files.erase(m_files.begin() + idx);\n      return true;\n    }\n    return false;\n  }\n\n  static size_t GetFilesMatchingPartialPath(const char *path, bool dir_okay,\n                                            FileSpecList &matches);\n\n  const_iterator begin() const { return m_files.begin(); }\n  const_iterator end() const { return m_files.end(); }\n\nprotected:\n  collection m_files; ///< A collection of FileSpec objects.\n};\n\n} // namespace lldb_private\n\n#endif // #if defined(__cplusplus)\n#endif // LLDB_CORE_FILESPECLIST_H\n"}, "6": {"id": 6, "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Core/Mangled.h", "content": "//===-- Mangled.h -----------------------------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLDB_CORE_MANGLED_H\n#define LLDB_CORE_MANGLED_H\n#if defined(__cplusplus)\n\n#include \"lldb/lldb-enumerations.h\"\n#include \"lldb/lldb-forward.h\"\n\n#include \"lldb/Utility/ConstString.h\"\n\n#include \"llvm/ADT/StringRef.h\"\n\n#include <memory>\n#include <stddef.h>\n\nnamespace lldb_private {\n\n/// \\class Mangled Mangled.h \"lldb/Core/Mangled.h\"\n/// A class that handles mangled names.\n///\n/// Designed to handle mangled names. The demangled version of any names will\n/// be computed when the demangled name is accessed through the Demangled()\n/// acccessor. This class can also tokenize the demangled version of the name\n/// for powerful searches. Functions and symbols could make instances of this\n/// class for their mangled names. Uniqued string pools are used for the\n/// mangled, demangled, and token string values to allow for faster\n/// comparisons and for efficient memory use.\nclass Mangled {\npublic:\n  enum NamePreference {\n    ePreferMangled,\n    ePreferDemangled,\n    ePreferDemangledWithoutArguments\n  };\n\n  enum ManglingScheme {\n    eManglingSchemeNone = 0,\n    eManglingSchemeMSVC,\n    eManglingSchemeItanium\n  };\n\n  /// Default constructor.\n  ///\n  /// Initialize with both mangled and demangled names empty.\n  Mangled() = default;\n\n  /// Construct with name.\n  ///\n  /// Constructor with an optional string and auto-detect if \\a name is\n  /// mangled or not.\n  ///\n  /// \\param[in] name\n  ///     The already const name to copy into this object.\n  explicit Mangled(ConstString name);\n\n  explicit Mangled(llvm::StringRef name);\n\n  /// Convert to pointer operator.\n  ///\n  /// This allows code to check a Mangled object to see if it contains a valid\n  /// mangled name using code such as:\n  ///\n  /// \\code\n  /// Mangled mangled(...);\n  /// if (mangled)\n  /// { ...\n  /// \\endcode\n  ///\n  /// \\return\n  ///     A pointer to this object if either the mangled or unmangled\n  ///     name is set, NULL otherwise.\n  operator void *() const;\n\n  /// Logical NOT operator.\n  ///\n  /// This allows code to check a Mangled object to see if it contains an\n  /// empty mangled name using code such as:\n  ///\n  /// \\code\n  /// Mangled mangled(...);\n  /// if (!mangled)\n  /// { ...\n  /// \\endcode\n  ///\n  /// \\return\n  ///     Returns \\b true if the object has an empty mangled and\n  ///     unmangled name, \\b false otherwise.\n  bool operator!() const;\n\n  /// Clear the mangled and demangled values.\n  void Clear();\n\n  /// Compare the mangled string values\n  ///\n  /// Compares the Mangled::GetName() string in \\a lhs and \\a rhs.\n  ///\n  /// \\param[in] lhs\n  ///     A const reference to the Left Hand Side object to compare.\n  ///\n  /// \\param[in] rhs\n  ///     A const reference to the Right Hand Side object to compare.\n  ///\n  /// \\return\n  ///     -1 if \\a lhs is less than \\a rhs\n  ///     0 if \\a lhs is equal to \\a rhs\n  ///     1 if \\a lhs is greater than \\a rhs\n  static int Compare(const Mangled &lhs, const Mangled &rhs);\n\n  /// Dump a description of this object to a Stream \\a s.\n  ///\n  /// Dump a Mangled object to stream \\a s. We don't force our demangled name\n  /// to be computed currently (we don't use the accessor).\n  ///\n  /// \\param[in] s\n  ///     The stream to which to dump the object description.\n  void Dump(Stream *s) const;\n\n  /// Dump a debug description of this object to a Stream \\a s.\n  ///\n  /// \\param[in] s\n  ///     The stream to which to dump the object description.\n  void DumpDebug(Stream *s) const;\n\n  /// Demangled name get accessor.\n  ///\n  /// \\return\n  ///     A const reference to the demangled name string object.\n  ConstString GetDemangledName() const;\n\n  /// Display demangled name get accessor.\n  ///\n  /// \\return\n  ///     A const reference to the display demangled name string object.\n  ConstString GetDisplayDemangledName() const;\n\n  void SetDemangledName(ConstString name) { m_demangled = name; }\n\n  void SetMangledName(ConstString name) { m_mangled = name; }\n\n  /// Mangled name get accessor.\n  ///\n  /// \\return\n  ///     A reference to the mangled name string object.\n  ConstString &GetMangledName() { return m_mangled; }\n\n  /// Mangled name get accessor.\n  ///\n  /// \\return\n  ///     A const reference to the mangled name string object.\n  ConstString GetMangledName() const { return m_mangled; }\n\n  /// Best name get accessor.\n  ///\n  /// \\param[in] preference\n  ///     Which name would you prefer to get?\n  ///\n  /// \\return\n  ///     A const reference to the preferred name string object if this\n  ///     object has a valid name of that kind, else a const reference to the\n  ///     other name is returned.\n  ConstString GetName(NamePreference preference = ePreferDemangled) const;\n\n  /// Check if \"name\" matches either the mangled or demangled name.\n  ///\n  /// \\param[in] name\n  ///     A name to match against both strings.\n  ///\n  /// \\return\n  ///     \\b True if \\a name matches either name, \\b false otherwise.\n  bool NameMatches(ConstString name) const {\n    if (m_mangled == name)\n      return true;\n    return GetDemangledName() == name;\n  }\n  bool NameMatches(const RegularExpression &regex) const;\n\n  /// Get the memory cost of this object.\n  ///\n  /// Return the size in bytes that this object takes in memory. This returns\n  /// the size in bytes of this object, not any shared string values it may\n  /// refer to.\n  ///\n  /// \\return\n  ///     The number of bytes that this object occupies in memory.\n  ///\n  /// \\see ConstString::StaticMemorySize ()\n  size_t MemorySize() const;\n\n  /// Set the string value in this object.\n  ///\n  /// If \\a is_mangled is \\b true, then the mangled named is set to \\a name,\n  /// else the demangled name is set to \\a name.\n  ///\n  /// \\param[in] name\n  ///     The already const version of the name for this object.\n  ///\n  /// \\param[in] is_mangled\n  ///     If \\b true then \\a name is a mangled name, if \\b false then\n  ///     \\a name is demangled.\n  void SetValue(ConstString name, bool is_mangled);\n\n  /// Set the string value in this object.\n  ///\n  /// This version auto detects if the string is mangled by inspecting the\n  /// string value and looking for common mangling prefixes.\n  ///\n  /// \\param[in] name\n  ///     The already const version of the name for this object.\n  void SetValue(ConstString name);\n\n  /// Try to guess the language from the mangling.\n  ///\n  /// For a mangled name to have a language it must have both a mangled and a\n  /// demangled name and it can be guessed from the mangling what the language\n  /// is.  Note: this will return C++ for any language that uses Itanium ABI\n  /// mangling.\n  ///\n  /// Standard C function names will return eLanguageTypeUnknown because they\n  /// aren't mangled and it isn't clear what language the name represents\n  /// (there will be no mangled name).\n  ///\n  /// \\return\n  ///     The language for the mangled/demangled name, eLanguageTypeUnknown\n  ///     if there is no mangled or demangled counterpart.\n  lldb::LanguageType GuessLanguage() const;\n\n  /// Function signature for filtering mangled names.\n  using SkipMangledNameFn = bool(llvm::StringRef, ManglingScheme);\n\n  /// Trigger explicit demangling to obtain rich mangling information. This is\n  /// optimized for batch processing while populating a name index. To get the\n  /// pure demangled name string for a single entity, use GetDemangledName()\n  /// instead.\n  ///\n  /// For names that match the Itanium mangling scheme, this uses LLVM's\n  /// ItaniumPartialDemangler. All other names fall back to LLDB's builtin\n  /// parser currently.\n  ///\n  /// This function is thread-safe when used with different \\a context\n  /// instances in different threads.\n  ///\n  /// \\param[in] context\n  ///     The context for this function. A single instance can be stack-\n  ///     allocated in the caller's frame and used for multiple calls.\n  ///\n  /// \\param[in] skip_mangled_name\n  ///     A filtering function for skipping entities based on name and mangling\n  ///     scheme. This can be null if unused.\n  ///\n  /// \\return\n  ///     True on success, false otherwise.\n  bool DemangleWithRichManglingInfo(RichManglingContext &context,\n                                    SkipMangledNameFn *skip_mangled_name);\n\n  /// Try to identify the mangling scheme used.\n  /// \\param[in] name\n  ///     The name we are attempting to identify the mangling scheme for.\n  ///\n  /// \\return\n  ///     eManglingSchemeNone if no known mangling scheme could be identified\n  ///     for s, otherwise the enumerator for the mangling scheme detected.\n  static Mangled::ManglingScheme GetManglingScheme(llvm::StringRef const name);\n\nprivate:\n  /// Mangled member variables.\n  ConstString m_mangled;           ///< The mangled version of the name\n  mutable ConstString m_demangled; ///< Mutable so we can get it on demand with\n                                   ///a const version of this object\n};\n\nStream &operator<<(Stream &s, const Mangled &obj);\n\n} // namespace lldb_private\n\n#endif // #if defined(__cplusplus)\n#endif // LLDB_CORE_MANGLED_H\n"}, "7": {"id": 7, "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Core/ModuleList.h", "content": "//===-- ModuleList.h --------------------------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLDB_CORE_MODULELIST_H\n#define LLDB_CORE_MODULELIST_H\n\n#include \"lldb/Core/Address.h\"\n#include \"lldb/Core/ModuleSpec.h\"\n#include \"lldb/Core/UserSettingsController.h\"\n#include \"lldb/Utility/FileSpec.h\"\n#include \"lldb/Utility/Iterable.h\"\n#include \"lldb/Utility/Status.h\"\n#include \"lldb/lldb-enumerations.h\"\n#include \"lldb/lldb-forward.h\"\n#include \"lldb/lldb-types.h\"\n\n#include \"llvm/ADT/DenseSet.h\"\n#include \"llvm/Support/RWMutex.h\"\n\n#include <functional>\n#include <list>\n#include <mutex>\n#include <vector>\n\n#include <stddef.h>\n#include <stdint.h>\n\nnamespace lldb_private {\nclass ConstString;\nclass FileSpecList;\nclass Function;\nclass Log;\nclass Module;\nclass RegularExpression;\nclass Stream;\nclass SymbolContext;\nclass SymbolContextList;\nclass SymbolFile;\nclass Target;\nclass TypeList;\nclass UUID;\nclass VariableList;\n\nclass ModuleListProperties : public Properties {\n  mutable llvm::sys::RWMutex m_symlink_paths_mutex;\n  PathMappingList m_symlink_paths;\n\n  void UpdateSymlinkMappings();\n\npublic:\n  ModuleListProperties();\n\n  FileSpec GetClangModulesCachePath() const;\n  bool SetClangModulesCachePath(const FileSpec &path);\n  bool GetEnableExternalLookup() const;\n  bool SetEnableExternalLookup(bool new_value);\n\n  PathMappingList GetSymlinkMappings() const;\n};\n\n/// \\class ModuleList ModuleList.h \"lldb/Core/ModuleList.h\"\n/// A collection class for Module objects.\n///\n/// Modules in the module collection class are stored as reference counted\n/// shared pointers to Module objects.\nclass ModuleList {\npublic:\n  class Notifier {\n  public:\n    virtual ~Notifier() = default;\n\n    virtual void NotifyModuleAdded(const ModuleList &module_list,\n                                   const lldb::ModuleSP &module_sp) = 0;\n    virtual void NotifyModuleRemoved(const ModuleList &module_list,\n                                     const lldb::ModuleSP &module_sp) = 0;\n    virtual void NotifyModuleUpdated(const ModuleList &module_list,\n                                     const lldb::ModuleSP &old_module_sp,\n                                     const lldb::ModuleSP &new_module_sp) = 0;\n    virtual void NotifyWillClearList(const ModuleList &module_list) = 0;\n\n    virtual void NotifyModulesRemoved(lldb_private::ModuleList &module_list) = 0;\n  };\n\n  /// Default constructor.\n  ///\n  /// Creates an empty list of Module objects.\n  ModuleList();\n\n  /// Copy Constructor.\n  ///\n  /// Creates a new module list object with a copy of the modules from \\a rhs.\n  ///\n  /// \\param[in] rhs\n  ///     Another module list object.\n  ModuleList(const ModuleList &rhs);\n\n  ModuleList(ModuleList::Notifier *notifier);\n\n  /// Destructor.\n  ~ModuleList();\n\n  /// Assignment operator.\n  ///\n  /// Copies the module list from \\a rhs into this list.\n  ///\n  /// \\param[in] rhs\n  ///     Another module list object.\n  ///\n  /// \\return\n  ///     A const reference to this object.\n  const ModuleList &operator=(const ModuleList &rhs);\n\n  /// Append a module to the module list.\n  ///\n  /// \\param[in] module_sp\n  ///     A shared pointer to a module to add to this collection.\n  ///\n  /// \\param[in] notify\n  ///     If true, and a notifier function is set, the notifier function\n  ///     will be called.  Defaults to true.\n  ///\n  ///     When this ModuleList is the Target's ModuleList, the notifier\n  ///     function is Target::ModulesDidLoad -- the call to\n  ///     ModulesDidLoad may be deferred when adding multiple Modules\n  ///     to the Target, but it must be called at the end,\n  ///     before resuming execution.\n  void Append(const lldb::ModuleSP &module_sp, bool notify = true);\n\n  /// Append a module to the module list and remove any equivalent modules.\n  /// Equivalent modules are ones whose file, platform file and architecture\n  /// matches.\n  ///\n  /// Replaces the module to the collection.\n  ///\n  /// \\param[in] module_sp\n  ///     A shared pointer to a module to replace in this collection.\n  ///\n  /// \\param[in] old_modules\n  ///     Optional pointer to a vector which, if provided, will have shared\n  ///     pointers to the replaced module(s) appended to it.\n  void ReplaceEquivalent(\n      const lldb::ModuleSP &module_sp,\n      llvm::SmallVectorImpl<lldb::ModuleSP> *old_modules = nullptr);\n\n  /// Append a module to the module list, if it is not already there.\n  ///\n  /// \\param[in] notify\n  ///     If true, and a notifier function is set, the notifier function\n  ///     will be called.  Defaults to true.\n  ///\n  ///     When this ModuleList is the Target's ModuleList, the notifier\n  ///     function is Target::ModulesDidLoad -- the call to\n  ///     ModulesDidLoad may be deferred when adding multiple Modules\n  ///     to the Target, but it must be called at the end,\n  ///     before resuming execution.\n  bool AppendIfNeeded(const lldb::ModuleSP &module_sp, bool notify = true);\n\n  void Append(const ModuleList &module_list);\n\n  bool AppendIfNeeded(const ModuleList &module_list);\n\n  bool ReplaceModule(const lldb::ModuleSP &old_module_sp,\n                     const lldb::ModuleSP &new_module_sp);\n\n  /// Clear the object's state.\n  ///\n  /// Clears the list of modules and releases a reference to each module\n  /// object and if the reference count goes to zero, the module will be\n  /// deleted.\n  void Clear();\n\n  /// Clear the object's state.\n  ///\n  /// Clears the list of modules and releases a reference to each module\n  /// object and if the reference count goes to zero, the module will be\n  /// deleted. Also release all memory that might be held by any collection\n  /// classes (like std::vector)\n  void Destroy();\n\n  /// Dump the description of each module contained in this list.\n  ///\n  /// Dump the description of each module contained in this list to the\n  /// supplied stream \\a s.\n  ///\n  /// \\param[in] s\n  ///     The stream to which to dump the object description.\n  ///\n  /// \\see Module::Dump(Stream *) const\n  void Dump(Stream *s) const;\n\n  void LogUUIDAndPaths(Log *log, const char *prefix_cstr);\n\n  std::recursive_mutex &GetMutex() const { return m_modules_mutex; }\n\n  size_t GetIndexForModule(const Module *module) const;\n\n  /// Get the module shared pointer for the module at index \\a idx.\n  ///\n  /// \\param[in] idx\n  ///     An index into this module collection.\n  ///\n  /// \\return\n  ///     A shared pointer to a Module which can contain NULL if\n  ///     \\a idx is out of range.\n  ///\n  /// \\see ModuleList::GetSize()\n  lldb::ModuleSP GetModuleAtIndex(size_t idx) const;\n\n  /// Get the module shared pointer for the module at index \\a idx without\n  /// acquiring the ModuleList mutex.  This MUST already have been acquired\n  /// with ModuleList::GetMutex and locked for this call to be safe.\n  ///\n  /// \\param[in] idx\n  ///     An index into this module collection.\n  ///\n  /// \\return\n  ///     A shared pointer to a Module which can contain NULL if\n  ///     \\a idx is out of range.\n  ///\n  /// \\see ModuleList::GetSize()\n  lldb::ModuleSP GetModuleAtIndexUnlocked(size_t idx) const;\n\n  /// Get the module pointer for the module at index \\a idx.\n  ///\n  /// \\param[in] idx\n  ///     An index into this module collection.\n  ///\n  /// \\return\n  ///     A pointer to a Module which can by nullptr if \\a idx is out\n  ///     of range.\n  ///\n  /// \\see ModuleList::GetSize()\n  Module *GetModulePointerAtIndex(size_t idx) const;\n\n  /// Find compile units by partial or full path.\n  ///\n  /// Finds all compile units that match \\a path in all of the modules and\n  /// returns the results in \\a sc_list.\n  ///\n  /// \\param[in] path\n  ///     The name of the compile unit we are looking for.\n  ///\n  /// \\param[out] sc_list\n  ///     A symbol context list that gets filled in with all of the\n  ///     matches.\n  void FindCompileUnits(const FileSpec &path, SymbolContextList &sc_list) const;\n\n  /// \\see Module::FindFunctions ()\n  void FindFunctions(ConstString name, lldb::FunctionNameType name_type_mask,\n                     bool include_symbols, bool include_inlines,\n                     SymbolContextList &sc_list) const;\n\n  /// \\see Module::FindFunctionSymbols ()\n  void FindFunctionSymbols(ConstString name,\n                           lldb::FunctionNameType name_type_mask,\n                           SymbolContextList &sc_list);\n\n  /// \\see Module::FindFunctions ()\n  void FindFunctions(const RegularExpression &name, bool include_symbols,\n                     bool include_inlines, SymbolContextList &sc_list);\n\n  /// Find global and static variables by name.\n  ///\n  /// \\param[in] name\n  ///     The name of the global or static variable we are looking\n  ///     for.\n  ///\n  /// \\param[in] max_matches\n  ///     Allow the number of matches to be limited to \\a\n  ///     max_matches. Specify UINT32_MAX to get all possible matches.\n  ///\n  /// \\param[in] variable_list\n  ///     A list of variables that gets the matches appended to.\n  void FindGlobalVariables(ConstString name, size_t max_matches,\n                           VariableList &variable_list) const;\n\n  /// Find global and static variables by regular expression.\n  ///\n  /// \\param[in] regex\n  ///     A regular expression to use when matching the name.\n  ///\n  /// \\param[in] max_matches\n  ///     Allow the number of matches to be limited to \\a\n  ///     max_matches. Specify UINT32_MAX to get all possible matches.\n  ///\n  /// \\param[in] variable_list\n  ///     A list of variables that gets the matches appended to.\n  void FindGlobalVariables(const RegularExpression &regex, size_t max_matches,\n                           VariableList &variable_list) const;\n\n  /// Finds the first module whose file specification matches \\a file_spec.\n  ///\n  /// \\param[in] module_spec\n  ///     A file specification object to match against the Module's\n  ///     file specifications. If \\a file_spec does not have\n  ///     directory information, matches will occur by matching only\n  ///     the basename of any modules in this list. If this value is\n  ///     NULL, then file specifications won't be compared when\n  ///     searching for matching modules.\n  ///\n  /// \\param[out] matching_module_list\n  ///     A module list that gets filled in with any modules that\n  ///     match the search criteria.\n  void FindModules(const ModuleSpec &module_spec,\n                   ModuleList &matching_module_list) const;\n\n  lldb::ModuleSP FindModule(const Module *module_ptr) const;\n\n  // Find a module by UUID\n  //\n  // The UUID value for a module is extracted from the ObjectFile and is the\n  // MD5 checksum, or a smarter object file equivalent, so finding modules by\n  // UUID values is very efficient and accurate.\n  lldb::ModuleSP FindModule(const UUID &uuid) const;\n\n  lldb::ModuleSP FindFirstModule(const ModuleSpec &module_spec) const;\n\n  void FindSymbolsWithNameAndType(ConstString name,\n                                  lldb::SymbolType symbol_type,\n                                  SymbolContextList &sc_list) const;\n\n  void FindSymbolsMatchingRegExAndType(const RegularExpression &regex,\n                                       lldb::SymbolType symbol_type,\n                                       SymbolContextList &sc_list) const;\n\n  /// Find types by name.\n  ///\n  /// \\param[in] search_first\n  ///     If non-null, this module will be searched before any other\n  ///     modules.\n  ///\n  /// \\param[in] name\n  ///     The name of the type we are looking for.\n  ///\n  /// \\param[in] max_matches\n  ///     Allow the number of matches to be limited to \\a\n  ///     max_matches. Specify UINT32_MAX to get all possible matches.\n  ///\n  /// \\param[out] types\n  ///     A type list gets populated with any matches.\n  ///\n  void FindTypes(Module *search_first, ConstString name,\n                 bool name_is_fully_qualified, size_t max_matches,\n                 llvm::DenseSet<SymbolFile *> &searched_symbol_files,\n                 TypeList &types) const;\n\n  bool FindSourceFile(const FileSpec &orig_spec, FileSpec &new_spec) const;\n\n  /// Find addresses by file/line\n  ///\n  /// \\param[in] target_sp\n  ///     The target the addresses are desired for.\n  ///\n  /// \\param[in] file\n  ///     Source file to locate.\n  ///\n  /// \\param[in] line\n  ///     Source line to locate.\n  ///\n  /// \\param[in] function\n  ///     Optional filter function. Addresses within this function will be\n  ///     added to the 'local' list. All others will be added to the 'extern'\n  ///     list.\n  ///\n  /// \\param[out] output_local\n  ///     All matching addresses within 'function'\n  ///\n  /// \\param[out] output_extern\n  ///     All matching addresses not within 'function'\n  void FindAddressesForLine(const lldb::TargetSP target_sp,\n                            const FileSpec &file, uint32_t line,\n                            Function *function,\n                            std::vector<Address> &output_local,\n                            std::vector<Address> &output_extern);\n\n  /// Remove a module from the module list.\n  ///\n  /// \\param[in] module_sp\n  ///     A shared pointer to a module to remove from this collection.\n  ///\n  /// \\param[in] notify\n  ///     If true, and a notifier function is set, the notifier function\n  ///     will be called.  Defaults to true.\n  ///\n  ///     When this ModuleList is the Target's ModuleList, the notifier\n  ///     function is Target::ModulesDidUnload -- the call to\n  ///     ModulesDidUnload may be deferred when removing multiple Modules\n  ///     from the Target, but it must be called at the end,\n  ///     before resuming execution.\n  bool Remove(const lldb::ModuleSP &module_sp, bool notify = true);\n\n  size_t Remove(ModuleList &module_list);\n\n  bool RemoveIfOrphaned(const Module *module_ptr);\n\n  size_t RemoveOrphans(bool mandatory);\n\n  bool ResolveFileAddress(lldb::addr_t vm_addr, Address &so_addr) const;\n\n  /// \\copydoc Module::ResolveSymbolContextForAddress (const Address\n  /// &,uint32_t,SymbolContext&)\n  uint32_t ResolveSymbolContextForAddress(const Address &so_addr,\n                                          lldb::SymbolContextItem resolve_scope,\n                                          SymbolContext &sc) const;\n\n  /// \\copydoc Module::ResolveSymbolContextForFilePath (const char\n  /// *,uint32_t,bool,uint32_t,SymbolContextList&)\n  uint32_t ResolveSymbolContextForFilePath(\n      const char *file_path, uint32_t line, bool check_inlines,\n      lldb::SymbolContextItem resolve_scope, SymbolContextList &sc_list) const;\n\n  /// \\copydoc Module::ResolveSymbolContextsForFileSpec (const FileSpec\n  /// &,uint32_t,bool,uint32_t,SymbolContextList&)\n  uint32_t ResolveSymbolContextsForFileSpec(\n      const FileSpec &file_spec, uint32_t line, bool check_inlines,\n      lldb::SymbolContextItem resolve_scope, SymbolContextList &sc_list) const;\n\n  /// Gets the size of the module list.\n  ///\n  /// \\return\n  ///     The number of modules in the module list.\n  size_t GetSize() const;\n  bool IsEmpty() const { return !GetSize(); }\n\n  bool LoadScriptingResourcesInTarget(Target *target, std::list<Status> &errors,\n                                      Stream *feedback_stream = nullptr,\n                                      bool continue_on_error = true);\n\n  static ModuleListProperties &GetGlobalModuleListProperties();\n\n  static bool ModuleIsInCache(const Module *module_ptr);\n\n  static Status\n  GetSharedModule(const ModuleSpec &module_spec, lldb::ModuleSP &module_sp,\n                  const FileSpecList *module_search_paths_ptr,\n                  llvm::SmallVectorImpl<lldb::ModuleSP> *old_modules,\n                  bool *did_create_ptr, bool always_create = false);\n\n  static bool RemoveSharedModule(lldb::ModuleSP &module_sp);\n\n  static void FindSharedModules(const ModuleSpec &module_spec,\n                                ModuleList &matching_module_list);\n\n  static size_t RemoveOrphanSharedModules(bool mandatory);\n\n  static bool RemoveSharedModuleIfOrphaned(const Module *module_ptr);\n\n  void ForEach(std::function<bool(const lldb::ModuleSP &module_sp)> const\n                   &callback) const;\n\nprotected:\n  // Class typedefs.\n  typedef std::vector<lldb::ModuleSP>\n      collection; ///< The module collection type.\n\n  void AppendImpl(const lldb::ModuleSP &module_sp, bool use_notifier = true);\n\n  bool RemoveImpl(const lldb::ModuleSP &module_sp, bool use_notifier = true);\n\n  collection::iterator RemoveImpl(collection::iterator pos,\n                                  bool use_notifier = true);\n\n  void ClearImpl(bool use_notifier = true);\n\n  // Member variables.\n  collection m_modules; ///< The collection of modules.\n  mutable std::recursive_mutex m_modules_mutex;\n\n  Notifier *m_notifier;\n\npublic:\n  typedef LockingAdaptedIterable<collection, lldb::ModuleSP, vector_adapter,\n                                 std::recursive_mutex>\n      ModuleIterable;\n  ModuleIterable Modules() const {\n    return ModuleIterable(m_modules, GetMutex());\n  }\n\n  typedef AdaptedIterable<collection, lldb::ModuleSP, vector_adapter>\n      ModuleIterableNoLocking;\n  ModuleIterableNoLocking ModulesNoLocking() const {\n    return ModuleIterableNoLocking(m_modules);\n  }\n};\n\n} // namespace lldb_private\n\n#endif // LLDB_CORE_MODULELIST_H\n"}, "8": {"id": 8, "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Core/ModuleSpec.h", "content": "//===-- ModuleSpec.h --------------------------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLDB_CORE_MODULESPEC_H\n#define LLDB_CORE_MODULESPEC_H\n\n#include \"lldb/Host/FileSystem.h\"\n#include \"lldb/Target/PathMappingList.h\"\n#include \"lldb/Utility/ArchSpec.h\"\n#include \"lldb/Utility/FileSpec.h\"\n#include \"lldb/Utility/Stream.h\"\n#include \"lldb/Utility/UUID.h\"\n\n#include \"llvm/Support/Chrono.h\"\n\n#include <mutex>\n#include <vector>\n\nnamespace lldb_private {\n\nclass ModuleSpec {\npublic:\n  ModuleSpec()\n      : m_file(), m_platform_file(), m_symbol_file(), m_arch(), m_uuid(),\n        m_object_name(), m_object_offset(0), m_object_size(0),\n        m_source_mappings() {}\n\n  /// If the \\param data argument is passed, its contents will be used\n  /// as the module contents instead of trying to read them from\n  /// \\param file_spec.\n  ModuleSpec(const FileSpec &file_spec, const UUID &uuid = UUID(),\n             lldb::DataBufferSP data = lldb::DataBufferSP())\n      : m_file(file_spec), m_platform_file(), m_symbol_file(), m_arch(),\n        m_uuid(uuid), m_object_name(), m_object_offset(0), m_source_mappings(),\n        m_data(data) {\n    if (data)\n      m_object_size = data->GetByteSize();\n    else if (m_file)\n      m_object_size = FileSystem::Instance().GetByteSize(file_spec);\n  }\n\n  ModuleSpec(const FileSpec &file_spec, const ArchSpec &arch)\n      : m_file(file_spec), m_platform_file(), m_symbol_file(), m_arch(arch),\n        m_uuid(), m_object_name(), m_object_offset(0),\n        m_object_size(FileSystem::Instance().GetByteSize(file_spec)),\n        m_source_mappings() {}\n\n  FileSpec *GetFileSpecPtr() { return (m_file ? &m_file : nullptr); }\n\n  const FileSpec *GetFileSpecPtr() const {\n    return (m_file ? &m_file : nullptr);\n  }\n\n  FileSpec &GetFileSpec() { return m_file; }\n\n  const FileSpec &GetFileSpec() const { return m_file; }\n\n  FileSpec *GetPlatformFileSpecPtr() {\n    return (m_platform_file ? &m_platform_file : nullptr);\n  }\n\n  const FileSpec *GetPlatformFileSpecPtr() const {\n    return (m_platform_file ? &m_platform_file : nullptr);\n  }\n\n  FileSpec &GetPlatformFileSpec() { return m_platform_file; }\n\n  const FileSpec &GetPlatformFileSpec() const { return m_platform_file; }\n\n  FileSpec *GetSymbolFileSpecPtr() {\n    return (m_symbol_file ? &m_symbol_file : nullptr);\n  }\n\n  const FileSpec *GetSymbolFileSpecPtr() const {\n    return (m_symbol_file ? &m_symbol_file : nullptr);\n  }\n\n  FileSpec &GetSymbolFileSpec() { return m_symbol_file; }\n\n  const FileSpec &GetSymbolFileSpec() const { return m_symbol_file; }\n\n  ArchSpec *GetArchitecturePtr() {\n    return (m_arch.IsValid() ? &m_arch : nullptr);\n  }\n\n  const ArchSpec *GetArchitecturePtr() const {\n    return (m_arch.IsValid() ? &m_arch : nullptr);\n  }\n\n  ArchSpec &GetArchitecture() { return m_arch; }\n\n  const ArchSpec &GetArchitecture() const { return m_arch; }\n\n  UUID *GetUUIDPtr() { return (m_uuid.IsValid() ? &m_uuid : nullptr); }\n\n  const UUID *GetUUIDPtr() const {\n    return (m_uuid.IsValid() ? &m_uuid : nullptr);\n  }\n\n  UUID &GetUUID() { return m_uuid; }\n\n  const UUID &GetUUID() const { return m_uuid; }\n\n  ConstString &GetObjectName() { return m_object_name; }\n\n  ConstString GetObjectName() const { return m_object_name; }\n\n  uint64_t GetObjectOffset() const { return m_object_offset; }\n\n  void SetObjectOffset(uint64_t object_offset) {\n    m_object_offset = object_offset;\n  }\n\n  uint64_t GetObjectSize() const { return m_object_size; }\n\n  void SetObjectSize(uint64_t object_size) { m_object_size = object_size; }\n\n  llvm::sys::TimePoint<> &GetObjectModificationTime() {\n    return m_object_mod_time;\n  }\n\n  const llvm::sys::TimePoint<> &GetObjectModificationTime() const {\n    return m_object_mod_time;\n  }\n\n  PathMappingList &GetSourceMappingList() const { return m_source_mappings; }\n\n  lldb::DataBufferSP GetData() const { return m_data; }\n\n  void Clear() {\n    m_file.Clear();\n    m_platform_file.Clear();\n    m_symbol_file.Clear();\n    m_arch.Clear();\n    m_uuid.Clear();\n    m_object_name.Clear();\n    m_object_offset = 0;\n    m_object_size = 0;\n    m_source_mappings.Clear(false);\n    m_object_mod_time = llvm::sys::TimePoint<>();\n  }\n\n  explicit operator bool() const {\n    if (m_file)\n      return true;\n    if (m_platform_file)\n      return true;\n    if (m_symbol_file)\n      return true;\n    if (m_arch.IsValid())\n      return true;\n    if (m_uuid.IsValid())\n      return true;\n    if (m_object_name)\n      return true;\n    if (m_object_size)\n      return true;\n    if (m_object_mod_time != llvm::sys::TimePoint<>())\n      return true;\n    return false;\n  }\n\n  void Dump(Stream &strm) const {\n    bool dumped_something = false;\n    if (m_file) {\n      strm.PutCString(\"file = '\");\n      strm << m_file;\n      strm.PutCString(\"'\");\n      dumped_something = true;\n    }\n    if (m_platform_file) {\n      if (dumped_something)\n        strm.PutCString(\", \");\n      strm.PutCString(\"platform_file = '\");\n      strm << m_platform_file;\n      strm.PutCString(\"'\");\n      dumped_something = true;\n    }\n    if (m_symbol_file) {\n      if (dumped_something)\n        strm.PutCString(\", \");\n      strm.PutCString(\"symbol_file = '\");\n      strm << m_symbol_file;\n      strm.PutCString(\"'\");\n      dumped_something = true;\n    }\n    if (m_arch.IsValid()) {\n      if (dumped_something)\n        strm.PutCString(\", \");\n      strm.Printf(\"arch = \");\n      m_arch.DumpTriple(strm.AsRawOstream());\n      dumped_something = true;\n    }\n    if (m_uuid.IsValid()) {\n      if (dumped_something)\n        strm.PutCString(\", \");\n      strm.PutCString(\"uuid = \");\n      m_uuid.Dump(&strm);\n      dumped_something = true;\n    }\n    if (m_object_name) {\n      if (dumped_something)\n        strm.PutCString(\", \");\n      strm.Printf(\"object_name = %s\", m_object_name.GetCString());\n      dumped_something = true;\n    }\n    if (m_object_offset > 0) {\n      if (dumped_something)\n        strm.PutCString(\", \");\n      strm.Printf(\"object_offset = %\" PRIu64, m_object_offset);\n      dumped_something = true;\n    }\n    if (m_object_size > 0) {\n      if (dumped_something)\n        strm.PutCString(\", \");\n      strm.Printf(\"object size = %\" PRIu64, m_object_size);\n      dumped_something = true;\n    }\n    if (m_object_mod_time != llvm::sys::TimePoint<>()) {\n      if (dumped_something)\n        strm.PutCString(\", \");\n      strm.Format(\"object_mod_time = {0:x+}\",\n                  uint64_t(llvm::sys::toTimeT(m_object_mod_time)));\n    }\n  }\n\n  bool Matches(const ModuleSpec &match_module_spec,\n               bool exact_arch_match) const {\n    if (match_module_spec.GetUUIDPtr() &&\n        match_module_spec.GetUUID() != GetUUID())\n      return false;\n    if (match_module_spec.GetObjectName() &&\n        match_module_spec.GetObjectName() != GetObjectName())\n      return false;\n    if (!FileSpec::Match(match_module_spec.GetFileSpec(), GetFileSpec()))\n      return false;\n    if (GetPlatformFileSpec() &&\n        !FileSpec::Match(match_module_spec.GetPlatformFileSpec(),\n                         GetPlatformFileSpec())) {\n      return false;\n    }\n    // Only match the symbol file spec if there is one in this ModuleSpec\n    if (GetSymbolFileSpec() &&\n        !FileSpec::Match(match_module_spec.GetSymbolFileSpec(),\n                         GetSymbolFileSpec())) {\n      return false;\n    }\n    if (match_module_spec.GetArchitecturePtr()) {\n      if (exact_arch_match) {\n        if (!GetArchitecture().IsExactMatch(\n                match_module_spec.GetArchitecture()))\n          return false;\n      } else {\n        if (!GetArchitecture().IsCompatibleMatch(\n                match_module_spec.GetArchitecture()))\n          return false;\n      }\n    }\n    return true;\n  }\n\nprotected:\n  FileSpec m_file;\n  FileSpec m_platform_file;\n  FileSpec m_symbol_file;\n  ArchSpec m_arch;\n  UUID m_uuid;\n  ConstString m_object_name;\n  uint64_t m_object_offset;\n  uint64_t m_object_size;\n  llvm::sys::TimePoint<> m_object_mod_time;\n  mutable PathMappingList m_source_mappings;\n  lldb::DataBufferSP m_data = {};\n};\n\nclass ModuleSpecList {\npublic:\n  ModuleSpecList() : m_specs(), m_mutex() {}\n\n  ModuleSpecList(const ModuleSpecList &rhs) : m_specs(), m_mutex() {\n    std::lock_guard<std::recursive_mutex> lhs_guard(m_mutex);\n    std::lock_guard<std::recursive_mutex> rhs_guard(rhs.m_mutex);\n    m_specs = rhs.m_specs;\n  }\n\n  ~ModuleSpecList() = default;\n\n  ModuleSpecList &operator=(const ModuleSpecList &rhs) {\n    if (this != &rhs) {\n      std::lock(m_mutex, rhs.m_mutex);\n      std::lock_guard<std::recursive_mutex> lhs_guard(m_mutex, std::adopt_lock);\n      std::lock_guard<std::recursive_mutex> rhs_guard(rhs.m_mutex, \n                                                      std::adopt_lock);\n      m_specs = rhs.m_specs;\n    }\n    return *this;\n  }\n\n  size_t GetSize() const {\n    std::lock_guard<std::recursive_mutex> guard(m_mutex);\n    return m_specs.size();\n  }\n\n  void Clear() {\n    std::lock_guard<std::recursive_mutex> guard(m_mutex);\n    m_specs.clear();\n  }\n\n  void Append(const ModuleSpec &spec) {\n    std::lock_guard<std::recursive_mutex> guard(m_mutex);\n    m_specs.push_back(spec);\n  }\n\n  void Append(const ModuleSpecList &rhs) {\n    std::lock_guard<std::recursive_mutex> lhs_guard(m_mutex);\n    std::lock_guard<std::recursive_mutex> rhs_guard(rhs.m_mutex);\n    m_specs.insert(m_specs.end(), rhs.m_specs.begin(), rhs.m_specs.end());\n  }\n\n  // The index \"i\" must be valid and this can't be used in multi-threaded code\n  // as no mutex lock is taken.\n  ModuleSpec &GetModuleSpecRefAtIndex(size_t i) { return m_specs[i]; }\n\n  bool GetModuleSpecAtIndex(size_t i, ModuleSpec &module_spec) const {\n    std::lock_guard<std::recursive_mutex> guard(m_mutex);\n    if (i < m_specs.size()) {\n      module_spec = m_specs[i];\n      return true;\n    }\n    module_spec.Clear();\n    return false;\n  }\n\n  bool FindMatchingModuleSpec(const ModuleSpec &module_spec,\n                              ModuleSpec &match_module_spec) const {\n    std::lock_guard<std::recursive_mutex> guard(m_mutex);\n    bool exact_arch_match = true;\n    for (auto spec : m_specs) {\n      if (spec.Matches(module_spec, exact_arch_match)) {\n        match_module_spec = spec;\n        return true;\n      }\n    }\n\n    // If there was an architecture, retry with a compatible arch\n    if (module_spec.GetArchitecturePtr()) {\n      exact_arch_match = false;\n      for (auto spec : m_specs) {\n        if (spec.Matches(module_spec, exact_arch_match)) {\n          match_module_spec = spec;\n          return true;\n        }\n      }\n    }\n    match_module_spec.Clear();\n    return false;\n  }\n\n  void FindMatchingModuleSpecs(const ModuleSpec &module_spec,\n                               ModuleSpecList &matching_list) const {\n    std::lock_guard<std::recursive_mutex> guard(m_mutex);\n    bool exact_arch_match = true;\n    const size_t initial_match_count = matching_list.GetSize();\n    for (auto spec : m_specs) {\n      if (spec.Matches(module_spec, exact_arch_match))\n        matching_list.Append(spec);\n    }\n\n    // If there was an architecture, retry with a compatible arch if no matches\n    // were found\n    if (module_spec.GetArchitecturePtr() &&\n        (initial_match_count == matching_list.GetSize())) {\n      exact_arch_match = false;\n      for (auto spec : m_specs) {\n        if (spec.Matches(module_spec, exact_arch_match))\n          matching_list.Append(spec);\n      }\n    }\n  }\n\n  void Dump(Stream &strm) {\n    std::lock_guard<std::recursive_mutex> guard(m_mutex);\n    uint32_t idx = 0;\n    for (auto spec : m_specs) {\n      strm.Printf(\"[%u] \", idx);\n      spec.Dump(strm);\n      strm.EOL();\n      ++idx;\n    }\n  }\n\nprotected:\n  typedef std::vector<ModuleSpec> collection; ///< The module collection type.\n  collection m_specs;                         ///< The collection of modules.\n  mutable std::recursive_mutex m_mutex;\n};\n\n} // namespace lldb_private\n\n#endif // LLDB_CORE_MODULESPEC_H\n"}, "9": {"id": 9, "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Core/Opcode.h", "content": "//===-- Opcode.h ------------------------------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLDB_CORE_OPCODE_H\n#define LLDB_CORE_OPCODE_H\n\n#include \"lldb/Utility/Endian.h\"\n#include \"lldb/lldb-enumerations.h\"\n\n#include \"llvm/Support/SwapByteOrder.h\"\n\n#include <assert.h>\n#include <stdint.h>\n#include <string.h>\n\nnamespace lldb {\nclass SBInstruction;\n}\n\nnamespace lldb_private {\nclass DataExtractor;\nclass Stream;\n\nclass Opcode {\npublic:\n  enum Type {\n    eTypeInvalid,\n    eType8,\n    eType16,\n    eType16_2, // a 32-bit Thumb instruction, made up of two words\n    eType32,\n    eType64,\n    eTypeBytes\n  };\n\n  Opcode() : m_byte_order(lldb::eByteOrderInvalid), m_type(eTypeInvalid) {}\n\n  Opcode(uint8_t inst, lldb::ByteOrder order)\n      : m_byte_order(order), m_type(eType8) {\n    m_data.inst8 = inst;\n  }\n\n  Opcode(uint16_t inst, lldb::ByteOrder order)\n      : m_byte_order(order), m_type(eType16) {\n    m_data.inst16 = inst;\n  }\n\n  Opcode(uint32_t inst, lldb::ByteOrder order)\n      : m_byte_order(order), m_type(eType32) {\n    m_data.inst32 = inst;\n  }\n\n  Opcode(uint64_t inst, lldb::ByteOrder order)\n      : m_byte_order(order), m_type(eType64) {\n    m_data.inst64 = inst;\n  }\n\n  Opcode(uint8_t *bytes, size_t length)\n      : m_byte_order(lldb::eByteOrderInvalid) {\n    SetOpcodeBytes(bytes, length);\n  }\n\n  void Clear() {\n    m_byte_order = lldb::eByteOrderInvalid;\n    m_type = Opcode::eTypeInvalid;\n  }\n\n  Opcode::Type GetType() const { return m_type; }\n\n  uint8_t GetOpcode8(uint8_t invalid_opcode = UINT8_MAX) const {\n    switch (m_type) {\n    case Opcode::eTypeInvalid:\n      break;\n    case Opcode::eType8:\n      return m_data.inst8;\n    case Opcode::eType16:\n      break;\n    case Opcode::eType16_2:\n      break;\n    case Opcode::eType32:\n      break;\n    case Opcode::eType64:\n      break;\n    case Opcode::eTypeBytes:\n      break;\n    }\n    return invalid_opcode;\n  }\n\n  uint16_t GetOpcode16(uint16_t invalid_opcode = UINT16_MAX) const {\n    switch (m_type) {\n    case Opcode::eTypeInvalid:\n      break;\n    case Opcode::eType8:\n      return m_data.inst8;\n    case Opcode::eType16:\n      return GetEndianSwap() ? llvm::ByteSwap_16(m_data.inst16) : m_data.inst16;\n    case Opcode::eType16_2:\n      break;\n    case Opcode::eType32:\n      break;\n    case Opcode::eType64:\n      break;\n    case Opcode::eTypeBytes:\n      break;\n    }\n    return invalid_opcode;\n  }\n\n  uint32_t GetOpcode32(uint32_t invalid_opcode = UINT32_MAX) const {\n    switch (m_type) {\n    case Opcode::eTypeInvalid:\n      break;\n    case Opcode::eType8:\n      return m_data.inst8;\n    case Opcode::eType16:\n      return GetEndianSwap() ? llvm::ByteSwap_16(m_data.inst16) : m_data.inst16;\n    case Opcode::eType16_2: // passthrough\n    case Opcode::eType32:\n      return GetEndianSwap() ? llvm::ByteSwap_32(m_data.inst32) : m_data.inst32;\n    case Opcode::eType64:\n      break;\n    case Opcode::eTypeBytes:\n      break;\n    }\n    return invalid_opcode;\n  }\n\n  uint64_t GetOpcode64(uint64_t invalid_opcode = UINT64_MAX) const {\n    switch (m_type) {\n    case Opcode::eTypeInvalid:\n      break;\n    case Opcode::eType8:\n      return m_data.inst8;\n    case Opcode::eType16:\n      return GetEndianSwap() ? llvm::ByteSwap_16(m_data.inst16) : m_data.inst16;\n    case Opcode::eType16_2: // passthrough\n    case Opcode::eType32:\n      return GetEndianSwap() ? llvm::ByteSwap_32(m_data.inst32) : m_data.inst32;\n    case Opcode::eType64:\n      return GetEndianSwap() ? llvm::ByteSwap_64(m_data.inst64) : m_data.inst64;\n    case Opcode::eTypeBytes:\n      break;\n    }\n    return invalid_opcode;\n  }\n\n  void SetOpcode8(uint8_t inst, lldb::ByteOrder order) {\n    m_type = eType8;\n    m_data.inst8 = inst;\n    m_byte_order = order;\n  }\n\n  void SetOpcode16(uint16_t inst, lldb::ByteOrder order) {\n    m_type = eType16;\n    m_data.inst16 = inst;\n    m_byte_order = order;\n  }\n\n  void SetOpcode16_2(uint32_t inst, lldb::ByteOrder order) {\n    m_type = eType16_2;\n    m_data.inst32 = inst;\n    m_byte_order = order;\n  }\n\n  void SetOpcode32(uint32_t inst, lldb::ByteOrder order) {\n    m_type = eType32;\n    m_data.inst32 = inst;\n    m_byte_order = order;\n  }\n\n  void SetOpcode64(uint64_t inst, lldb::ByteOrder order) {\n    m_type = eType64;\n    m_data.inst64 = inst;\n    m_byte_order = order;\n  }\n\n  void SetOpcodeBytes(const void *bytes, size_t length) {\n    if (bytes != nullptr && length > 0) {\n      m_type = eTypeBytes;\n      m_data.inst.length = length;\n      assert(length < sizeof(m_data.inst.bytes));\n      memcpy(m_data.inst.bytes, bytes, length);\n      m_byte_order = lldb::eByteOrderInvalid;\n    } else {\n      m_type = eTypeInvalid;\n      m_data.inst.length = 0;\n    }\n  }\n\n  int Dump(Stream *s, uint32_t min_byte_width);\n\n  const void *GetOpcodeBytes() const {\n    return ((m_type == Opcode::eTypeBytes) ? m_data.inst.bytes : nullptr);\n  }\n\n  uint32_t GetByteSize() const {\n    switch (m_type) {\n    case Opcode::eTypeInvalid:\n      break;\n    case Opcode::eType8:\n      return sizeof(m_data.inst8);\n    case Opcode::eType16:\n      return sizeof(m_data.inst16);\n    case Opcode::eType16_2: // passthrough\n    case Opcode::eType32:\n      return sizeof(m_data.inst32);\n    case Opcode::eType64:\n      return sizeof(m_data.inst64);\n    case Opcode::eTypeBytes:\n      return m_data.inst.length;\n    }\n    return 0;\n  }\n\n  // Get the opcode exactly as it would be laid out in memory.\n  uint32_t GetData(DataExtractor &data) const;\n\nprotected:\n  friend class lldb::SBInstruction;\n\n  const void *GetOpcodeDataBytes() const {\n    switch (m_type) {\n    case Opcode::eTypeInvalid:\n      break;\n    case Opcode::eType8:\n      return &m_data.inst8;\n    case Opcode::eType16:\n      return &m_data.inst16;\n    case Opcode::eType16_2: // passthrough\n    case Opcode::eType32:\n      return &m_data.inst32;\n    case Opcode::eType64:\n      return &m_data.inst64;\n    case Opcode::eTypeBytes:\n      return m_data.inst.bytes;\n    }\n    return nullptr;\n  }\n\n  lldb::ByteOrder GetDataByteOrder() const;\n\n  bool GetEndianSwap() const {\n    return (m_byte_order == lldb::eByteOrderBig &&\n            endian::InlHostByteOrder() == lldb::eByteOrderLittle) ||\n           (m_byte_order == lldb::eByteOrderLittle &&\n            endian::InlHostByteOrder() == lldb::eByteOrderBig);\n  }\n\n  lldb::ByteOrder m_byte_order;\n\n  Opcode::Type m_type;\n  union {\n    uint8_t inst8;\n    uint16_t inst16;\n    uint32_t inst32;\n    uint64_t inst64;\n    struct {\n      uint8_t bytes[16]; // This must be big enough to handle any opcode for any\n                         // supported target.\n      uint8_t length;\n    } inst;\n  } m_data;\n};\n\n} // namespace lldb_private\n\n#endif // LLDB_CORE_OPCODE_H\n"}, "10": {"id": 10, "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Core/UniqueCStringMap.h", "content": "//===-- UniqueCStringMap.h --------------------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLDB_CORE_UNIQUECSTRINGMAP_H\n#define LLDB_CORE_UNIQUECSTRINGMAP_H\n\n#include <algorithm>\n#include <vector>\n\n#include \"lldb/Utility/ConstString.h\"\n#include \"lldb/Utility/RegularExpression.h\"\n\nnamespace lldb_private {\n\n// Templatized uniqued string map.\n//\n// This map is useful for mapping unique C string names to values of type T.\n// Each \"const char *\" name added must be unique for a given\n// C string value. ConstString::GetCString() can provide such strings.\n// Any other string table that has guaranteed unique values can also be used.\ntemplate <typename T> class UniqueCStringMap {\npublic:\n  struct Entry {\n    Entry(ConstString cstr, const T &v) : cstring(cstr), value(v) {}\n\n    ConstString cstring;\n    T value;\n  };\n\n  typedef std::vector<Entry> collection;\n  typedef typename collection::iterator iterator;\n  typedef typename collection::const_iterator const_iterator;\n\n  // Call this function multiple times to add a bunch of entries to this map,\n  // then later call UniqueCStringMap<T>::Sort() before doing any searches by\n  // name.\n  void Append(ConstString unique_cstr, const T &value) {\n    m_map.push_back(typename UniqueCStringMap<T>::Entry(unique_cstr, value));\n  }\n\n  void Append(const Entry &e) { m_map.push_back(e); }\n\n  void Clear() { m_map.clear(); }\n\n  // Get an entries by index in a variety of forms.\n  //\n  // The caller is responsible for ensuring that the collection does not change\n  // during while using the returned values.\n  bool GetValueAtIndex(uint32_t idx, T &value) const {\n    if (idx < m_map.size()) {\n      value = m_map[idx].value;\n      return true;\n    }\n    return false;\n  }\n\n  ConstString GetCStringAtIndexUnchecked(uint32_t idx) const {\n    return m_map[idx].cstring;\n  }\n\n  // Use this function if you have simple types in your map that you can easily\n  // copy when accessing values by index.\n  T GetValueAtIndexUnchecked(uint32_t idx) const { return m_map[idx].value; }\n\n  // Use this function if you have complex types in your map that you don't\n  // want to copy when accessing values by index.\n  const T &GetValueRefAtIndexUnchecked(uint32_t idx) const {\n    return m_map[idx].value;\n  }\n\n  ConstString GetCStringAtIndex(uint32_t idx) const {\n    return ((idx < m_map.size()) ? m_map[idx].cstring : ConstString());\n  }\n\n  // Find the value for the unique string in the map.\n  //\n  // Return the value for \\a unique_cstr if one is found, return \\a fail_value\n  // otherwise. This method works well for simple type\n  // T values and only if there is a sensible failure value that can\n  // be returned and that won't match any existing values.\n  T Find(ConstString unique_cstr, T fail_value) const {\n    auto pos = llvm::lower_bound(m_map, unique_cstr, Compare());\n    if (pos != m_map.end() && pos->cstring == unique_cstr)\n      return pos->value;\n    return fail_value;\n  }\n\n  // Get a pointer to the first entry that matches \"name\". nullptr will be\n  // returned if there is no entry that matches \"name\".\n  //\n  // The caller is responsible for ensuring that the collection does not change\n  // during while using the returned pointer.\n  const Entry *FindFirstValueForName(ConstString unique_cstr) const {\n    auto pos = llvm::lower_bound(m_map, unique_cstr, Compare());\n    if (pos != m_map.end() && pos->cstring == unique_cstr)\n      return &(*pos);\n    return nullptr;\n  }\n\n  // Get a pointer to the next entry that matches \"name\" from a previously\n  // returned Entry pointer. nullptr will be returned if there is no subsequent\n  // entry that matches \"name\".\n  //\n  // The caller is responsible for ensuring that the collection does not change\n  // during while using the returned pointer.\n  const Entry *FindNextValueForName(const Entry *entry_ptr) const {\n    if (!m_map.empty()) {\n      const Entry *first_entry = &m_map[0];\n      const Entry *after_last_entry = first_entry + m_map.size();\n      const Entry *next_entry = entry_ptr + 1;\n      if (first_entry <= next_entry && next_entry < after_last_entry) {\n        if (next_entry->cstring == entry_ptr->cstring)\n          return next_entry;\n      }\n    }\n    return nullptr;\n  }\n\n  size_t GetValues(ConstString unique_cstr, std::vector<T> &values) const {\n    const size_t start_size = values.size();\n\n    for (const Entry &entry : llvm::make_range(std::equal_range(\n             m_map.begin(), m_map.end(), unique_cstr, Compare())))\n      values.push_back(entry.value);\n\n    return values.size() - start_size;\n  }\n\n  size_t GetValues(const RegularExpression &regex,\n                   std::vector<T> &values) const {\n    const size_t start_size = values.size();\n\n    const_iterator pos, end = m_map.end();\n    for (pos = m_map.begin(); pos != end; ++pos) {\n      if (regex.Execute(pos->cstring.GetCString()))\n        values.push_back(pos->value);\n    }\n\n    return values.size() - start_size;\n  }\n\n  // Get the total number of entries in this map.\n  size_t GetSize() const { return m_map.size(); }\n\n  // Returns true if this map is empty.\n  bool IsEmpty() const { return m_map.empty(); }\n\n  // Reserve memory for at least \"n\" entries in the map. This is useful to call\n  // when you know you will be adding a lot of entries using\n  // UniqueCStringMap::Append() (which should be followed by a call to\n  // UniqueCStringMap::Sort()) or to UniqueCStringMap::Insert().\n  void Reserve(size_t n) { m_map.reserve(n); }\n\n  // Sort the unsorted contents in this map. A typical code flow would be:\n  // size_t approximate_num_entries = ....\n  // UniqueCStringMap<uint32_t> my_map;\n  // my_map.Reserve (approximate_num_entries);\n  // for (...)\n  // {\n  //      my_map.Append (UniqueCStringMap::Entry(GetName(...), GetValue(...)));\n  // }\n  // my_map.Sort();\n  void Sort() { llvm::sort(m_map.begin(), m_map.end(), Compare()); }\n\n  // Since we are using a vector to contain our items it will always double its\n  // memory consumption as things are added to the vector, so if you intend to\n  // keep a UniqueCStringMap around and have a lot of entries in the map, you\n  // will want to call this function to create a new vector and copy _only_ the\n  // exact size needed as part of the finalization of the string map.\n  void SizeToFit() {\n    if (m_map.size() < m_map.capacity()) {\n      collection temp(m_map.begin(), m_map.end());\n      m_map.swap(temp);\n    }\n  }\n\n  iterator begin() { return m_map.begin(); }\n  iterator end() { return m_map.end(); }\n  const_iterator begin() const { return m_map.begin(); }\n  const_iterator end() const { return m_map.end(); }\n\n  // Range-based for loop for all entries of the specified ConstString name.\n  llvm::iterator_range<const_iterator>\n  equal_range(ConstString unique_cstr) const {\n    return llvm::make_range(\n        std::equal_range(m_map.begin(), m_map.end(), unique_cstr, Compare()));\n  };\n\nprotected:\n  struct Compare {\n    bool operator()(const Entry &lhs, const Entry &rhs) {\n      return operator()(lhs.cstring, rhs.cstring);\n    }\n\n    bool operator()(const Entry &lhs, ConstString rhs) {\n      return operator()(lhs.cstring, rhs);\n    }\n\n    bool operator()(ConstString lhs, const Entry &rhs) {\n      return operator()(lhs, rhs.cstring);\n    }\n\n    // This is only for uniqueness, not lexicographical ordering, so we can\n    // just compare pointers. *However*, comparing pointers from different\n    // allocations is UB, so we need compare their integral values instead.\n    bool operator()(ConstString lhs, ConstString rhs) {\n      return uintptr_t(lhs.GetCString()) < uintptr_t(rhs.GetCString());\n    }\n  };\n  collection m_map;\n};\n\n} // namespace lldb_private\n\n#endif // LLDB_CORE_UNIQUECSTRINGMAP_H\n"}, "11": {"id": 11, "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Core/ValueObject.h", "content": "//===-- ValueObject.h -------------------------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLDB_CORE_VALUEOBJECT_H\n#define LLDB_CORE_VALUEOBJECT_H\n\n#include \"lldb/Core/Value.h\"\n#include \"lldb/Symbol/CompilerType.h\"\n#include \"lldb/Symbol/Type.h\"\n#include \"lldb/Target/ExecutionContext.h\"\n#include \"lldb/Target/Process.h\"\n#include \"lldb/Utility/ConstString.h\"\n#include \"lldb/Utility/DataExtractor.h\"\n#include \"lldb/Utility/SharedCluster.h\"\n#include \"lldb/Utility/Status.h\"\n#include \"lldb/Utility/UserID.h\"\n#include \"lldb/lldb-defines.h\"\n#include \"lldb/lldb-enumerations.h\"\n#include \"lldb/lldb-forward.h\"\n#include \"lldb/lldb-private-enumerations.h\"\n#include \"lldb/lldb-types.h\"\n\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/ADT/Optional.h\"\n#include \"llvm/ADT/SmallVector.h\"\n#include \"llvm/ADT/StringRef.h\"\n\n#include <functional>\n#include <initializer_list>\n#include <map>\n#include <mutex>\n#include <string>\n#include <utility>\n\n#include <stddef.h>\n#include <stdint.h>\n\nnamespace lldb_private {\nclass Declaration;\nclass DumpValueObjectOptions;\nclass EvaluateExpressionOptions;\nclass ExecutionContextScope;\nclass Log;\nclass Scalar;\nclass Stream;\nclass SymbolContextScope;\nclass TypeFormatImpl;\nclass TypeSummaryImpl;\nclass TypeSummaryOptions;\n\n/// ValueObject:\n///\n/// This abstract class provides an interface to a particular value, be it a\n/// register, a local or global variable,\n/// that is evaluated in some particular scope.  The ValueObject also has the\n/// capability of being the \"child\" of\n/// some other variable object, and in turn of having children.\n/// If a ValueObject is a root variable object - having no parent - then it must\n/// be constructed with respect to some\n/// particular ExecutionContextScope.  If it is a child, it inherits the\n/// ExecutionContextScope from its parent.\n/// The ValueObject will update itself if necessary before fetching its value,\n/// summary, object description, etc.\n/// But it will always update itself in the ExecutionContextScope with which it\n/// was originally created.\n\n/// A brief note on life cycle management for ValueObjects.  This is a little\n/// tricky because a ValueObject can contain\n/// various other ValueObjects - the Dynamic Value, its children, the\n/// dereference value, etc.  Any one of these can be\n/// handed out as a shared pointer, but for that contained value object to be\n/// valid, the root object and potentially other\n/// of the value objects need to stay around.\n/// We solve this problem by handing out shared pointers to the Value Object and\n/// any of its dependents using a shared\n/// ClusterManager.  This treats each shared pointer handed out for the entire\n/// cluster as a reference to the whole\n/// cluster.  The whole cluster will stay around until the last reference is\n/// released.\n///\n/// The ValueObject mostly handle this automatically, if a value object is made\n/// with a Parent ValueObject, then it adds\n/// itself to the ClusterManager of the parent.\n\n/// It does mean that external to the ValueObjects we should only ever make\n/// available ValueObjectSP's, never ValueObjects\n/// or pointers to them.  So all the \"Root level\" ValueObject derived\n/// constructors should be private, and\n/// should implement a Create function that new's up object and returns a Shared\n/// Pointer that it gets from the GetSP() method.\n///\n/// However, if you are making an derived ValueObject that will be contained in\n/// a parent value object, you should just\n/// hold onto a pointer to it internally, and by virtue of passing the parent\n/// ValueObject into its constructor, it will\n/// be added to the ClusterManager for the parent.  Then if you ever hand out a\n/// Shared Pointer to the contained ValueObject,\n/// just do so by calling GetSP() on the contained object.\n\nclass ValueObject {\npublic:\n  enum GetExpressionPathFormat {\n    eGetExpressionPathFormatDereferencePointers = 1,\n    eGetExpressionPathFormatHonorPointers\n  };\n\n  enum ValueObjectRepresentationStyle {\n    eValueObjectRepresentationStyleValue = 1,\n    eValueObjectRepresentationStyleSummary,\n    eValueObjectRepresentationStyleLanguageSpecific,\n    eValueObjectRepresentationStyleLocation,\n    eValueObjectRepresentationStyleChildrenCount,\n    eValueObjectRepresentationStyleType,\n    eValueObjectRepresentationStyleName,\n    eValueObjectRepresentationStyleExpressionPath\n  };\n\n  enum ExpressionPathScanEndReason {\n    /// Out of data to parse.\n    eExpressionPathScanEndReasonEndOfString = 1,\n    /// Child element not found.\n    eExpressionPathScanEndReasonNoSuchChild,\n    /// (Synthetic) child  element not found.\n    eExpressionPathScanEndReasonNoSuchSyntheticChild,\n    /// [] only allowed for arrays.\n    eExpressionPathScanEndReasonEmptyRangeNotAllowed,\n    /// . used when -> should be used.\n    eExpressionPathScanEndReasonDotInsteadOfArrow,\n    /// -> used when . should be used.\n    eExpressionPathScanEndReasonArrowInsteadOfDot,\n    /// ObjC ivar expansion not allowed.\n    eExpressionPathScanEndReasonFragileIVarNotAllowed,\n    /// [] not allowed by options.\n    eExpressionPathScanEndReasonRangeOperatorNotAllowed,\n    /// [] not valid on objects  other than scalars, pointers or arrays.\n    eExpressionPathScanEndReasonRangeOperatorInvalid,\n    /// [] is good for arrays,  but I cannot parse it.\n    eExpressionPathScanEndReasonArrayRangeOperatorMet,\n    /// [] is good for bitfields, but I cannot parse after it.\n    eExpressionPathScanEndReasonBitfieldRangeOperatorMet,\n    /// Something is malformed in he expression.\n    eExpressionPathScanEndReasonUnexpectedSymbol,\n    /// Impossible to apply &  operator.\n    eExpressionPathScanEndReasonTakingAddressFailed,\n    /// Impossible to apply *  operator.\n    eExpressionPathScanEndReasonDereferencingFailed,\n    /// [] was expanded into a  VOList.\n    eExpressionPathScanEndReasonRangeOperatorExpanded,\n    /// getting the synthetic children failed.\n    eExpressionPathScanEndReasonSyntheticValueMissing,\n    eExpressionPathScanEndReasonUnknown = 0xFFFF\n  };\n\n  enum ExpressionPathEndResultType {\n    /// Anything but...\n    eExpressionPathEndResultTypePlain = 1,\n    /// A bitfield.\n    eExpressionPathEndResultTypeBitfield,\n    /// A range [low-high].\n    eExpressionPathEndResultTypeBoundedRange,\n    /// A range [].\n    eExpressionPathEndResultTypeUnboundedRange,\n    /// Several items in a VOList.\n    eExpressionPathEndResultTypeValueObjectList,\n    eExpressionPathEndResultTypeInvalid = 0xFFFF\n  };\n\n  enum ExpressionPathAftermath {\n    /// Just return it.\n    eExpressionPathAftermathNothing = 1,\n    /// Dereference the target.\n    eExpressionPathAftermathDereference,\n    /// Take target's address.\n    eExpressionPathAftermathTakeAddress\n  };\n\n  enum ClearUserVisibleDataItems {\n    eClearUserVisibleDataItemsNothing = 1u << 0,\n    eClearUserVisibleDataItemsValue = 1u << 1,\n    eClearUserVisibleDataItemsSummary = 1u << 2,\n    eClearUserVisibleDataItemsLocation = 1u << 3,\n    eClearUserVisibleDataItemsDescription = 1u << 4,\n    eClearUserVisibleDataItemsSyntheticChildren = 1u << 5,\n    eClearUserVisibleDataItemsAllStrings =\n        eClearUserVisibleDataItemsValue | eClearUserVisibleDataItemsSummary |\n        eClearUserVisibleDataItemsLocation |\n        eClearUserVisibleDataItemsDescription,\n    eClearUserVisibleDataItemsAll = 0xFFFF\n  };\n\n  struct GetValueForExpressionPathOptions {\n    enum class SyntheticChildrenTraversal {\n      None,\n      ToSynthetic,\n      FromSynthetic,\n      Both\n    };\n\n    bool m_check_dot_vs_arrow_syntax;\n    bool m_no_fragile_ivar;\n    bool m_allow_bitfields_syntax;\n    SyntheticChildrenTraversal m_synthetic_children_traversal;\n\n    GetValueForExpressionPathOptions(\n        bool dot = false, bool no_ivar = false, bool bitfield = true,\n        SyntheticChildrenTraversal synth_traverse =\n            SyntheticChildrenTraversal::ToSynthetic)\n        : m_check_dot_vs_arrow_syntax(dot), m_no_fragile_ivar(no_ivar),\n          m_allow_bitfields_syntax(bitfield),\n          m_synthetic_children_traversal(synth_traverse) {}\n\n    GetValueForExpressionPathOptions &DoCheckDotVsArrowSyntax() {\n      m_check_dot_vs_arrow_syntax = true;\n      return *this;\n    }\n\n    GetValueForExpressionPathOptions &DontCheckDotVsArrowSyntax() {\n      m_check_dot_vs_arrow_syntax = false;\n      return *this;\n    }\n\n    GetValueForExpressionPathOptions &DoAllowFragileIVar() {\n      m_no_fragile_ivar = false;\n      return *this;\n    }\n\n    GetValueForExpressionPathOptions &DontAllowFragileIVar() {\n      m_no_fragile_ivar = true;\n      return *this;\n    }\n\n    GetValueForExpressionPathOptions &DoAllowBitfieldSyntax() {\n      m_allow_bitfields_syntax = true;\n      return *this;\n    }\n\n    GetValueForExpressionPathOptions &DontAllowBitfieldSyntax() {\n      m_allow_bitfields_syntax = false;\n      return *this;\n    }\n\n    GetValueForExpressionPathOptions &\n    SetSyntheticChildrenTraversal(SyntheticChildrenTraversal traverse) {\n      m_synthetic_children_traversal = traverse;\n      return *this;\n    }\n\n    static const GetValueForExpressionPathOptions DefaultOptions() {\n      static GetValueForExpressionPathOptions g_default_options;\n\n      return g_default_options;\n    }\n  };\n\n  class EvaluationPoint {\n  public:\n    EvaluationPoint();\n\n    EvaluationPoint(ExecutionContextScope *exe_scope,\n                    bool use_selected = false);\n\n    EvaluationPoint(const EvaluationPoint &rhs);\n\n    ~EvaluationPoint();\n\n    const ExecutionContextRef &GetExecutionContextRef() const {\n      return m_exe_ctx_ref;\n    }\n\n    void SetIsConstant() {\n      SetUpdated();\n      m_mod_id.SetInvalid();\n    }\n\n    bool IsConstant() const { return !m_mod_id.IsValid(); }\n\n    ProcessModID GetModID() const { return m_mod_id; }\n\n    void SetUpdateID(ProcessModID new_id) { m_mod_id = new_id; }\n\n    void SetNeedsUpdate() { m_needs_update = true; }\n\n    void SetUpdated();\n\n    bool NeedsUpdating(bool accept_invalid_exe_ctx) {\n      SyncWithProcessState(accept_invalid_exe_ctx);\n      return m_needs_update;\n    }\n\n    bool IsValid() {\n      const bool accept_invalid_exe_ctx = false;\n      if (!m_mod_id.IsValid())\n        return false;\n      else if (SyncWithProcessState(accept_invalid_exe_ctx)) {\n        if (!m_mod_id.IsValid())\n          return false;\n      }\n      return true;\n    }\n\n    void SetInvalid() {\n      // Use the stop id to mark us as invalid, leave the thread id and the\n      // stack id around for logging and history purposes.\n      m_mod_id.SetInvalid();\n\n      // Can't update an invalid state.\n      m_needs_update = false;\n    }\n\n  private:\n    bool SyncWithProcessState(bool accept_invalid_exe_ctx);\n\n    ProcessModID m_mod_id; // This is the stop id when this ValueObject was last\n                           // evaluated.\n    ExecutionContextRef m_exe_ctx_ref;\n    bool m_needs_update;\n  };\n\n  virtual ~ValueObject();\n\n  const EvaluationPoint &GetUpdatePoint() const { return m_update_point; }\n\n  EvaluationPoint &GetUpdatePoint() { return m_update_point; }\n\n  const ExecutionContextRef &GetExecutionContextRef() const {\n    return m_update_point.GetExecutionContextRef();\n  }\n\n  lldb::TargetSP GetTargetSP() const {\n    return m_update_point.GetExecutionContextRef().GetTargetSP();\n  }\n\n  lldb::ProcessSP GetProcessSP() const {\n    return m_update_point.GetExecutionContextRef().GetProcessSP();\n  }\n\n  lldb::ThreadSP GetThreadSP() const {\n    return m_update_point.GetExecutionContextRef().GetThreadSP();\n  }\n\n  lldb::StackFrameSP GetFrameSP() const {\n    return m_update_point.GetExecutionContextRef().GetFrameSP();\n  }\n\n  void SetNeedsUpdate();\n\n  CompilerType GetCompilerType() { return MaybeCalculateCompleteType(); }\n\n  // this vends a TypeImpl that is useful at the SB API layer\n  virtual TypeImpl GetTypeImpl() { return TypeImpl(GetCompilerType()); }\n\n  virtual bool CanProvideValue();\n\n  // Subclasses must implement the functions below.\n  virtual llvm::Optional<uint64_t> GetByteSize() = 0;\n\n  virtual lldb::ValueType GetValueType() const = 0;\n\n  // Subclasses can implement the functions below.\n  virtual ConstString GetTypeName() { return GetCompilerType().GetTypeName(); }\n\n  virtual ConstString GetDisplayTypeName() { return GetTypeName(); }\n\n  virtual ConstString GetQualifiedTypeName() {\n    return GetCompilerType().GetTypeName();\n  }\n\n  virtual lldb::LanguageType GetObjectRuntimeLanguage() {\n    return GetCompilerType().GetMinimumLanguage();\n  }\n\n  virtual uint32_t\n  GetTypeInfo(CompilerType *pointee_or_element_compiler_type = nullptr) {\n    return GetCompilerType().GetTypeInfo(pointee_or_element_compiler_type);\n  }\n\n  virtual bool IsPointerType() { return GetCompilerType().IsPointerType(); }\n\n  virtual bool IsArrayType() { return GetCompilerType().IsArrayType(); }\n\n  virtual bool IsScalarType() { return GetCompilerType().IsScalarType(); }\n\n  virtual bool IsPointerOrReferenceType() {\n    return GetCompilerType().IsPointerOrReferenceType();\n  }\n\n  virtual bool IsPossibleDynamicType();\n\n  bool IsNilReference();\n\n  bool IsUninitializedReference();\n\n  virtual bool IsBaseClass() { return false; }\n\n  bool IsBaseClass(uint32_t &depth);\n\n  virtual bool IsDereferenceOfParent() { return false; }\n\n  bool IsIntegerType(bool &is_signed) {\n    return GetCompilerType().IsIntegerType(is_signed);\n  }\n\n  virtual void GetExpressionPath(\n      Stream &s,\n      GetExpressionPathFormat = eGetExpressionPathFormatDereferencePointers);\n\n  lldb::ValueObjectSP GetValueForExpressionPath(\n      llvm::StringRef expression,\n      ExpressionPathScanEndReason *reason_to_stop = nullptr,\n      ExpressionPathEndResultType *final_value_type = nullptr,\n      const GetValueForExpressionPathOptions &options =\n          GetValueForExpressionPathOptions::DefaultOptions(),\n      ExpressionPathAftermath *final_task_on_target = nullptr);\n\n  virtual bool IsInScope() { return true; }\n\n  virtual lldb::offset_t GetByteOffset() { return 0; }\n\n  virtual uint32_t GetBitfieldBitSize() { return 0; }\n\n  virtual uint32_t GetBitfieldBitOffset() { return 0; }\n\n  bool IsBitfield() {\n    return (GetBitfieldBitSize() != 0) || (GetBitfieldBitOffset() != 0);\n  }\n\n  virtual bool IsArrayItemForPointer() {\n    return m_flags.m_is_array_item_for_pointer;\n  }\n\n  virtual const char *GetValueAsCString();\n\n  virtual bool GetValueAsCString(const lldb_private::TypeFormatImpl &format,\n                                 std::string &destination);\n\n  bool GetValueAsCString(lldb::Format format, std::string &destination);\n\n  virtual uint64_t GetValueAsUnsigned(uint64_t fail_value,\n                                      bool *success = nullptr);\n\n  virtual int64_t GetValueAsSigned(int64_t fail_value, bool *success = nullptr);\n\n  virtual bool SetValueFromCString(const char *value_str, Status &error);\n\n  /// Return the module associated with this value object in case the value is\n  /// from an executable file and might have its data in sections of the file.\n  /// This can be used for variables.\n  virtual lldb::ModuleSP GetModule();\n\n  ValueObject *GetRoot();\n\n  /// Given a ValueObject, loop over itself and its parent, and its parent's\n  /// parent, .. until either the given callback returns false, or you end up at\n  /// a null pointer\n  ValueObject *FollowParentChain(std::function<bool(ValueObject *)>);\n\n  virtual bool GetDeclaration(Declaration &decl);\n\n  // The functions below should NOT be modified by subclasses\n  const Status &GetError();\n\n  ConstString GetName() const { return m_name; }\n\n  /// Returns a unique id for this ValueObject.\n  lldb::user_id_t GetID() const { return m_id.GetID(); }\n\n  virtual lldb::ValueObjectSP GetChildAtIndex(size_t idx, bool can_create);\n\n  // this will always create the children if necessary\n  lldb::ValueObjectSP GetChildAtIndexPath(llvm::ArrayRef<size_t> idxs,\n                                          size_t *index_of_error = nullptr);\n\n  lldb::ValueObjectSP\n  GetChildAtIndexPath(llvm::ArrayRef<std::pair<size_t, bool>> idxs,\n                      size_t *index_of_error = nullptr);\n\n  // this will always create the children if necessary\n  lldb::ValueObjectSP GetChildAtNamePath(llvm::ArrayRef<ConstString> names,\n                                         ConstString *name_of_error = nullptr);\n\n  lldb::ValueObjectSP\n  GetChildAtNamePath(llvm::ArrayRef<std::pair<ConstString, bool>> names,\n                     ConstString *name_of_error = nullptr);\n\n  virtual lldb::ValueObjectSP GetChildMemberWithName(ConstString name,\n                                                     bool can_create);\n\n  virtual size_t GetIndexOfChildWithName(ConstString name);\n\n  size_t GetNumChildren(uint32_t max = UINT32_MAX);\n\n  const Value &GetValue() const { return m_value; }\n\n  Value &GetValue() { return m_value; }\n\n  virtual bool ResolveValue(Scalar &scalar);\n\n  // return 'false' whenever you set the error, otherwise callers may assume\n  // true means everything is OK - this will break breakpoint conditions among\n  // potentially a few others\n  virtual bool IsLogicalTrue(Status &error);\n\n  virtual const char *GetLocationAsCString() {\n    return GetLocationAsCStringImpl(m_value, m_data);\n  }\n\n  const char *\n  GetSummaryAsCString(lldb::LanguageType lang = lldb::eLanguageTypeUnknown);\n\n  bool\n  GetSummaryAsCString(TypeSummaryImpl *summary_ptr, std::string &destination,\n                      lldb::LanguageType lang = lldb::eLanguageTypeUnknown);\n\n  bool GetSummaryAsCString(std::string &destination,\n                           const TypeSummaryOptions &options);\n\n  bool GetSummaryAsCString(TypeSummaryImpl *summary_ptr,\n                           std::string &destination,\n                           const TypeSummaryOptions &options);\n\n  const char *GetObjectDescription();\n\n  bool HasSpecialPrintableRepresentation(\n      ValueObjectRepresentationStyle val_obj_display,\n      lldb::Format custom_format);\n\n  enum class PrintableRepresentationSpecialCases : bool {\n    eDisable = false,\n    eAllow = true\n  };\n\n  bool\n  DumpPrintableRepresentation(Stream &s,\n                              ValueObjectRepresentationStyle val_obj_display =\n                                  eValueObjectRepresentationStyleSummary,\n                              lldb::Format custom_format = lldb::eFormatInvalid,\n                              PrintableRepresentationSpecialCases special =\n                                  PrintableRepresentationSpecialCases::eAllow,\n                              bool do_dump_error = true);\n  bool GetValueIsValid() const { return m_flags.m_value_is_valid; }\n\n  // If you call this on a newly created ValueObject, it will always return\n  // false.\n  bool GetValueDidChange() { return m_flags.m_value_did_change; }\n\n  bool UpdateValueIfNeeded(bool update_format = true);\n\n  bool UpdateFormatsIfNeeded();\n\n  lldb::ValueObjectSP GetSP() { return m_manager->GetSharedPointer(this); }\n\n  /// Change the name of the current ValueObject. Should *not* be used from a\n  /// synthetic child provider as it would change the name of the non synthetic\n  /// child as well.\n  void SetName(ConstString name) { m_name = name; }\n\n  virtual lldb::addr_t GetAddressOf(bool scalar_is_load_address = true,\n                                    AddressType *address_type = nullptr);\n\n  lldb::addr_t GetPointerValue(AddressType *address_type = nullptr);\n\n  lldb::ValueObjectSP GetSyntheticChild(ConstString key) const;\n\n  lldb::ValueObjectSP GetSyntheticArrayMember(size_t index, bool can_create);\n\n  lldb::ValueObjectSP GetSyntheticBitFieldChild(uint32_t from, uint32_t to,\n                                                bool can_create);\n\n  lldb::ValueObjectSP GetSyntheticExpressionPathChild(const char *expression,\n                                                      bool can_create);\n\n  virtual lldb::ValueObjectSP\n  GetSyntheticChildAtOffset(uint32_t offset, const CompilerType &type,\n                            bool can_create,\n                            ConstString name_const_str = ConstString());\n\n  virtual lldb::ValueObjectSP\n  GetSyntheticBase(uint32_t offset, const CompilerType &type, bool can_create,\n                   ConstString name_const_str = ConstString());\n\n  virtual lldb::ValueObjectSP GetDynamicValue(lldb::DynamicValueType valueType);\n\n  lldb::DynamicValueType GetDynamicValueType();\n\n  virtual lldb::ValueObjectSP GetStaticValue() { return GetSP(); }\n\n  virtual lldb::ValueObjectSP GetNonSyntheticValue() { return GetSP(); }\n\n  lldb::ValueObjectSP GetSyntheticValue();\n\n  virtual bool HasSyntheticValue();\n\n  virtual bool IsSynthetic() { return false; }\n\n  lldb::ValueObjectSP\n  GetQualifiedRepresentationIfAvailable(lldb::DynamicValueType dynValue,\n                                        bool synthValue);\n\n  virtual lldb::ValueObjectSP CreateConstantValue(ConstString name);\n\n  virtual lldb::ValueObjectSP Dereference(Status &error);\n\n  /// Creates a copy of the ValueObject with a new name and setting the current\n  /// ValueObject as its parent. It should be used when we want to change the\n  /// name of a ValueObject without modifying the actual ValueObject itself\n  /// (e.g. sythetic child provider).\n  virtual lldb::ValueObjectSP Clone(ConstString new_name);\n\n  virtual lldb::ValueObjectSP AddressOf(Status &error);\n\n  virtual lldb::addr_t GetLiveAddress() { return LLDB_INVALID_ADDRESS; }\n\n  virtual void SetLiveAddress(lldb::addr_t addr = LLDB_INVALID_ADDRESS,\n                              AddressType address_type = eAddressTypeLoad) {}\n\n  virtual lldb::ValueObjectSP Cast(const CompilerType &compiler_type);\n\n  virtual lldb::ValueObjectSP CastPointerType(const char *name,\n                                              CompilerType &ast_type);\n\n  virtual lldb::ValueObjectSP CastPointerType(const char *name,\n                                              lldb::TypeSP &type_sp);\n\n  // The backing bits of this value object were updated, clear any descriptive\n  // string, so we know we have to refetch them.\n  virtual void ValueUpdated() {\n    ClearUserVisibleData(eClearUserVisibleDataItemsValue |\n                         eClearUserVisibleDataItemsSummary |\n                         eClearUserVisibleDataItemsDescription);\n  }\n\n  virtual bool IsDynamic() { return false; }\n\n  virtual bool DoesProvideSyntheticValue() { return false; }\n\n  virtual bool IsSyntheticChildrenGenerated() {\n    return m_flags.m_is_synthetic_children_generated;\n  }\n\n  virtual void SetSyntheticChildrenGenerated(bool b) {\n    m_flags.m_is_synthetic_children_generated = b;\n  }\n\n  virtual SymbolContextScope *GetSymbolContextScope();\n\n  void Dump(Stream &s);\n\n  void Dump(Stream &s, const DumpValueObjectOptions &options);\n\n  static lldb::ValueObjectSP\n  CreateValueObjectFromExpression(llvm::StringRef name,\n                                  llvm::StringRef expression,\n                                  const ExecutionContext &exe_ctx);\n\n  static lldb::ValueObjectSP\n  CreateValueObjectFromExpression(llvm::StringRef name,\n                                  llvm::StringRef expression,\n                                  const ExecutionContext &exe_ctx,\n                                  const EvaluateExpressionOptions &options);\n\n  static lldb::ValueObjectSP\n  CreateValueObjectFromAddress(llvm::StringRef name, uint64_t address,\n                               const ExecutionContext &exe_ctx,\n                               CompilerType type);\n\n  static lldb::ValueObjectSP\n  CreateValueObjectFromData(llvm::StringRef name, const DataExtractor &data,\n                            const ExecutionContext &exe_ctx, CompilerType type);\n\n  lldb::ValueObjectSP Persist();\n\n  /// Returns true if this is a char* or a char[] if it is a char* and\n  /// check_pointer is true, it also checks that the pointer is valid.\n  bool IsCStringContainer(bool check_pointer = false);\n\n  std::pair<size_t, bool>\n  ReadPointedString(lldb::DataBufferSP &buffer_sp, Status &error,\n                    uint32_t max_length = 0, bool honor_array = true,\n                    lldb::Format item_format = lldb::eFormatCharArray);\n\n  virtual size_t GetPointeeData(DataExtractor &data, uint32_t item_idx = 0,\n                                uint32_t item_count = 1);\n\n  virtual uint64_t GetData(DataExtractor &data, Status &error);\n\n  virtual bool SetData(DataExtractor &data, Status &error);\n\n  virtual bool GetIsConstant() const { return m_update_point.IsConstant(); }\n\n  bool NeedsUpdating() {\n    const bool accept_invalid_exe_ctx =\n        (CanUpdateWithInvalidExecutionContext() == eLazyBoolYes);\n    return m_update_point.NeedsUpdating(accept_invalid_exe_ctx);\n  }\n\n  void SetIsConstant() { m_update_point.SetIsConstant(); }\n\n  lldb::Format GetFormat() const;\n\n  virtual void SetFormat(lldb::Format format) {\n    if (format != m_format)\n      ClearUserVisibleData(eClearUserVisibleDataItemsValue);\n    m_format = format;\n  }\n\n  virtual lldb::LanguageType GetPreferredDisplayLanguage();\n\n  void SetPreferredDisplayLanguage(lldb::LanguageType lt) {\n    m_preferred_display_language = lt;\n  }\n\n  lldb::TypeSummaryImplSP GetSummaryFormat() {\n    UpdateFormatsIfNeeded();\n    return m_type_summary_sp;\n  }\n\n  void SetSummaryFormat(lldb::TypeSummaryImplSP format) {\n    m_type_summary_sp = std::move(format);\n    ClearUserVisibleData(eClearUserVisibleDataItemsSummary);\n  }\n\n  void SetValueFormat(lldb::TypeFormatImplSP format) {\n    m_type_format_sp = std::move(format);\n    ClearUserVisibleData(eClearUserVisibleDataItemsValue);\n  }\n\n  lldb::TypeFormatImplSP GetValueFormat() {\n    UpdateFormatsIfNeeded();\n    return m_type_format_sp;\n  }\n\n  void SetSyntheticChildren(const lldb::SyntheticChildrenSP &synth_sp) {\n    if (synth_sp.get() == m_synthetic_children_sp.get())\n      return;\n    ClearUserVisibleData(eClearUserVisibleDataItemsSyntheticChildren);\n    m_synthetic_children_sp = synth_sp;\n  }\n\n  lldb::SyntheticChildrenSP GetSyntheticChildren() {\n    UpdateFormatsIfNeeded();\n    return m_synthetic_children_sp;\n  }\n\n  // Use GetParent for display purposes, but if you want to tell the parent to\n  // update itself then use m_parent.  The ValueObjectDynamicValue's parent is\n  // not the correct parent for displaying, they are really siblings, so for\n  // display it needs to route through to its grandparent.\n  virtual ValueObject *GetParent() { return m_parent; }\n\n  virtual const ValueObject *GetParent() const { return m_parent; }\n\n  ValueObject *GetNonBaseClassParent();\n\n  void SetAddressTypeOfChildren(AddressType at) {\n    m_address_type_of_ptr_or_ref_children = at;\n  }\n\n  AddressType GetAddressTypeOfChildren();\n\n  void SetHasCompleteType() {\n    m_flags.m_did_calculate_complete_objc_class_type = true;\n  }\n\n  /// Find out if a ValueObject might have children.\n  ///\n  /// This call is much more efficient than CalculateNumChildren() as\n  /// it doesn't need to complete the underlying type. This is designed\n  /// to be used in a UI environment in order to detect if the\n  /// disclosure triangle should be displayed or not.\n  ///\n  /// This function returns true for class, union, structure,\n  /// pointers, references, arrays and more. Again, it does so without\n  /// doing any expensive type completion.\n  ///\n  /// \\return\n  ///     Returns \\b true if the ValueObject might have children, or \\b\n  ///     false otherwise.\n  virtual bool MightHaveChildren();\n\n  virtual lldb::VariableSP GetVariable() { return nullptr; }\n\n  virtual bool IsRuntimeSupportValue();\n\n  virtual uint64_t GetLanguageFlags() { return m_language_flags; }\n\n  virtual void SetLanguageFlags(uint64_t flags) { m_language_flags = flags; }\n\nprotected:\n  typedef ClusterManager<ValueObject> ValueObjectManager;\n\n  class ChildrenManager {\n  public:\n    ChildrenManager() : m_mutex(), m_children(), m_children_count(0) {}\n\n    bool HasChildAtIndex(size_t idx) {\n      std::lock_guard<std::recursive_mutex> guard(m_mutex);\n      return (m_children.find(idx) != m_children.end());\n    }\n\n    ValueObject *GetChildAtIndex(size_t idx) {\n      std::lock_guard<std::recursive_mutex> guard(m_mutex);\n      const auto iter = m_children.find(idx);\n      return ((iter == m_children.end()) ? nullptr : iter->second);\n    }\n\n    void SetChildAtIndex(size_t idx, ValueObject *valobj) {\n      // we do not need to be mutex-protected to make a pair\n      ChildrenPair pair(idx, valobj);\n      std::lock_guard<std::recursive_mutex> guard(m_mutex);\n      m_children.insert(pair);\n    }\n\n    void SetChildrenCount(size_t count) { Clear(count); }\n\n    size_t GetChildrenCount() { return m_children_count; }\n\n    void Clear(size_t new_count = 0) {\n      std::lock_guard<std::recursive_mutex> guard(m_mutex);\n      m_children_count = new_count;\n      m_children.clear();\n    }\n\n  private:\n    typedef std::map<size_t, ValueObject *> ChildrenMap;\n    typedef ChildrenMap::iterator ChildrenIterator;\n    typedef ChildrenMap::value_type ChildrenPair;\n    std::recursive_mutex m_mutex;\n    ChildrenMap m_children;\n    size_t m_children_count;\n  };\n\n  // Classes that inherit from ValueObject can see and modify these\n\n  /// The parent value object, or nullptr if this has no parent.\n  ValueObject *m_parent = nullptr;\n  /// The root of the hierarchy for this ValueObject (or nullptr if never\n  /// calculated).\n  ValueObject *m_root = nullptr;\n  /// Stores both the stop id and the full context at which this value was last\n  /// updated.  When we are asked to update the value object, we check whether\n  /// the context & stop id are the same before updating.\n  EvaluationPoint m_update_point;\n  /// The name of this object.\n  ConstString m_name;\n  /// A data extractor that can be used to extract the value.\n  DataExtractor m_data;\n  Value m_value;\n  /// An error object that can describe any errors that occur when updating\n  /// values.\n  Status m_error;\n  /// Cached value string that will get cleared if/when the value is updated.\n  std::string m_value_str;\n  /// Cached old value string from the last time the value was gotten\n  std::string m_old_value_str;\n  /// Cached location string that will get cleared if/when the value is updated.\n  std::string m_location_str;\n  /// Cached summary string that will get cleared if/when the value is updated.\n  std::string m_summary_str;\n  /// Cached result of the \"object printer\". This differs from the summary\n  /// in that the summary is consed up by us, the object_desc_string is builtin.\n  std::string m_object_desc_str;\n  /// If the type of the value object should be overridden, the type to impose.\n  CompilerType m_override_type;\n\n  /// This object is managed by the root object (any ValueObject that gets\n  /// created without a parent.) The manager gets passed through all the\n  /// generations of dependent objects, and will keep the whole cluster of\n  /// objects alive as long as a shared pointer to any of them has been handed\n  /// out. Shared pointers to value objects must always be made with the GetSP\n  /// method.\n  ValueObjectManager *m_manager = nullptr;\n\n  ChildrenManager m_children;\n  std::map<ConstString, ValueObject *> m_synthetic_children;\n\n  ValueObject *m_dynamic_value = nullptr;\n  ValueObject *m_synthetic_value = nullptr;\n  ValueObject *m_deref_valobj = nullptr;\n\n  /// We have to hold onto a shared  pointer to this one because it is created\n  /// as an independent ValueObjectConstResult, which isn't managed by us.\n  lldb::ValueObjectSP m_addr_of_valobj_sp;\n\n  lldb::Format m_format = lldb::eFormatDefault;\n  lldb::Format m_last_format = lldb::eFormatDefault;\n  uint32_t m_last_format_mgr_revision = 0;\n  lldb::TypeSummaryImplSP m_type_summary_sp;\n  lldb::TypeFormatImplSP m_type_format_sp;\n  lldb::SyntheticChildrenSP m_synthetic_children_sp;\n  ProcessModID m_user_id_of_forced_summary;\n  AddressType m_address_type_of_ptr_or_ref_children = eAddressTypeInvalid;\n\n  llvm::SmallVector<uint8_t, 16> m_value_checksum;\n\n  lldb::LanguageType m_preferred_display_language = lldb::eLanguageTypeUnknown;\n\n  uint64_t m_language_flags = 0;\n\n  /// Unique identifier for every value object.\n  UserID m_id;\n\n  // Utility class for initializing all bitfields in ValueObject's constructors.\n  // FIXME: This could be done via default initializers once we have C++20.\n  struct Bitflags {\n    bool m_value_is_valid : 1, m_value_did_change : 1,\n        m_children_count_valid : 1, m_old_value_valid : 1,\n        m_is_deref_of_parent : 1, m_is_array_item_for_pointer : 1,\n        m_is_bitfield_for_scalar : 1, m_is_child_at_offset : 1,\n        m_is_getting_summary : 1, m_did_calculate_complete_objc_class_type : 1,\n        m_is_synthetic_children_generated : 1;\n    Bitflags() {\n      m_value_is_valid = false;\n      m_value_did_change = false;\n      m_children_count_valid = false;\n      m_old_value_valid = false;\n      m_is_deref_of_parent = false;\n      m_is_array_item_for_pointer = false;\n      m_is_bitfield_for_scalar = false;\n      m_is_child_at_offset = false;\n      m_is_getting_summary = false;\n      m_did_calculate_complete_objc_class_type = false;\n      m_is_synthetic_children_generated = false;\n    }\n  } m_flags;\n\n  friend class ValueObjectChild;\n  friend class ExpressionVariable;     // For SetName\n  friend class Target;                 // For SetName\n  friend class ValueObjectConstResultImpl;\n  friend class ValueObjectSynthetic; // For ClearUserVisibleData\n\n  /// Use this constructor to create a \"root variable object\".  The ValueObject\n  /// will be locked to this context through-out its lifespan.\n  ValueObject(ExecutionContextScope *exe_scope, ValueObjectManager &manager,\n              AddressType child_ptr_or_ref_addr_type = eAddressTypeLoad);\n\n  /// Use this constructor to create a ValueObject owned by another ValueObject.\n  /// It will inherit the ExecutionContext of its parent.\n  ValueObject(ValueObject &parent);\n\n  ValueObjectManager *GetManager() { return m_manager; }\n\n  virtual bool UpdateValue() = 0;\n\n  virtual LazyBool CanUpdateWithInvalidExecutionContext() {\n    return eLazyBoolCalculate;\n  }\n\n  virtual void CalculateDynamicValue(lldb::DynamicValueType use_dynamic);\n\n  virtual lldb::DynamicValueType GetDynamicValueTypeImpl() {\n    return lldb::eNoDynamicValues;\n  }\n\n  virtual bool HasDynamicValueTypeInfo() { return false; }\n\n  virtual void CalculateSyntheticValue();\n\n  /// Should only be called by ValueObject::GetChildAtIndex().\n  ///\n  /// \\return A ValueObject managed by this ValueObject's manager.\n  virtual ValueObject *CreateChildAtIndex(size_t idx,\n                                          bool synthetic_array_member,\n                                          int32_t synthetic_index);\n\n  /// Should only be called by ValueObject::GetNumChildren().\n  virtual size_t CalculateNumChildren(uint32_t max = UINT32_MAX) = 0;\n\n  void SetNumChildren(size_t num_children);\n\n  void SetValueDidChange(bool value_changed) {\n    m_flags.m_value_did_change = value_changed;\n  }\n\n  void SetValueIsValid(bool valid) { m_flags.m_value_is_valid = valid; }\n\n  void ClearUserVisibleData(\n      uint32_t items = ValueObject::eClearUserVisibleDataItemsAllStrings);\n\n  void AddSyntheticChild(ConstString key, ValueObject *valobj);\n\n  DataExtractor &GetDataExtractor();\n\n  void ClearDynamicTypeInformation();\n\n  // Subclasses must implement the functions below.\n\n  virtual CompilerType GetCompilerTypeImpl() = 0;\n\n  const char *GetLocationAsCStringImpl(const Value &value,\n                                       const DataExtractor &data);\n\n  bool IsChecksumEmpty() { return m_value_checksum.empty(); }\n\n  void SetPreferredDisplayLanguageIfNeeded(lldb::LanguageType);\n\nprotected:\n  virtual void DoUpdateChildrenAddressType(ValueObject &valobj) { return; };\n\nprivate:\n  virtual CompilerType MaybeCalculateCompleteType();\n  void UpdateChildrenAddressType() {\n    GetRoot()->DoUpdateChildrenAddressType(*this);\n  }\n\n  lldb::ValueObjectSP GetValueForExpressionPath_Impl(\n      llvm::StringRef expression_cstr,\n      ExpressionPathScanEndReason *reason_to_stop,\n      ExpressionPathEndResultType *final_value_type,\n      const GetValueForExpressionPathOptions &options,\n      ExpressionPathAftermath *final_task_on_target);\n\n  ValueObject(const ValueObject &) = delete;\n  const ValueObject &operator=(const ValueObject &) = delete;\n};\n\n} // namespace lldb_private\n\n#endif // LLDB_CORE_VALUEOBJECT_H\n"}, "12": {"id": 12, "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/DataFormatters/FormatClasses.h", "content": "//===-- FormatClasses.h -----------------------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLDB_DATAFORMATTERS_FORMATCLASSES_H\n#define LLDB_DATAFORMATTERS_FORMATCLASSES_H\n\n#include <functional>\n#include <memory>\n#include <string>\n#include <vector>\n\n#include \"lldb/DataFormatters/TypeFormat.h\"\n#include \"lldb/DataFormatters/TypeSummary.h\"\n#include \"lldb/DataFormatters/TypeSynthetic.h\"\n#include \"lldb/Symbol/CompilerType.h\"\n#include \"lldb/Symbol/Type.h\"\n#include \"lldb/lldb-enumerations.h\"\n#include \"lldb/lldb-public.h\"\n\nnamespace lldb_private {\n\nclass HardcodedFormatters {\npublic:\n  template <typename FormatterType>\n  using HardcodedFormatterFinder =\n      std::function<typename FormatterType::SharedPointer(\n          lldb_private::ValueObject &, lldb::DynamicValueType,\n          FormatManager &)>;\n\n  template <typename FormatterType>\n  using HardcodedFormatterFinders =\n      std::vector<HardcodedFormatterFinder<FormatterType>>;\n\n  typedef HardcodedFormatterFinders<TypeFormatImpl> HardcodedFormatFinder;\n  typedef HardcodedFormatterFinders<TypeSummaryImpl> HardcodedSummaryFinder;\n  typedef HardcodedFormatterFinders<SyntheticChildren> HardcodedSyntheticFinder;\n};\n\nclass FormattersMatchCandidate {\npublic:\n  FormattersMatchCandidate(ConstString name, bool strip_ptr,\n                           bool strip_ref, bool strip_tydef)\n      : m_type_name(name), m_stripped_pointer(strip_ptr),\n        m_stripped_reference(strip_ref), m_stripped_typedef(strip_tydef) {}\n\n  ~FormattersMatchCandidate() = default;\n\n  ConstString GetTypeName() const { return m_type_name; }\n\n  bool DidStripPointer() const { return m_stripped_pointer; }\n\n  bool DidStripReference() const { return m_stripped_reference; }\n\n  bool DidStripTypedef() const { return m_stripped_typedef; }\n\n  template <class Formatter>\n  bool IsMatch(const std::shared_ptr<Formatter> &formatter_sp) const {\n    if (!formatter_sp)\n      return false;\n    if (formatter_sp->Cascades() == false && DidStripTypedef())\n      return false;\n    if (formatter_sp->SkipsPointers() && DidStripPointer())\n      return false;\n    if (formatter_sp->SkipsReferences() && DidStripReference())\n      return false;\n    return true;\n  }\n\nprivate:\n  ConstString m_type_name;\n  bool m_stripped_pointer;\n  bool m_stripped_reference;\n  bool m_stripped_typedef;\n};\n\ntypedef std::vector<FormattersMatchCandidate> FormattersMatchVector;\ntypedef std::vector<lldb::LanguageType> CandidateLanguagesVector;\n\nclass FormattersMatchData {\npublic:\n  FormattersMatchData(ValueObject &, lldb::DynamicValueType);\n\n  FormattersMatchVector GetMatchesVector();\n\n  ConstString GetTypeForCache();\n\n  CandidateLanguagesVector GetCandidateLanguages();\n\n  ValueObject &GetValueObject();\n\n  lldb::DynamicValueType GetDynamicValueType();\n\nprivate:\n  ValueObject &m_valobj;\n  lldb::DynamicValueType m_dynamic_value_type;\n  std::pair<FormattersMatchVector, bool> m_formatters_match_vector;\n  ConstString m_type_for_cache;\n  CandidateLanguagesVector m_candidate_languages;\n};\n\nclass TypeNameSpecifierImpl {\npublic:\n  TypeNameSpecifierImpl() : m_is_regex(false), m_type() {}\n\n  TypeNameSpecifierImpl(llvm::StringRef name, bool is_regex)\n      : m_is_regex(is_regex), m_type() {\n    m_type.m_type_name = std::string(name);\n  }\n\n  // if constructing with a given type, is_regex cannot be true since we are\n  // giving an exact type to match\n  TypeNameSpecifierImpl(lldb::TypeSP type) : m_is_regex(false), m_type() {\n    if (type) {\n      m_type.m_type_name = std::string(type->GetName().GetStringRef());\n      m_type.m_compiler_type = type->GetForwardCompilerType();\n    }\n  }\n\n  TypeNameSpecifierImpl(CompilerType type) : m_is_regex(false), m_type() {\n    if (type.IsValid()) {\n      m_type.m_type_name.assign(type.GetTypeName().GetCString());\n      m_type.m_compiler_type = type;\n    }\n  }\n\n  const char *GetName() {\n    if (m_type.m_type_name.size())\n      return m_type.m_type_name.c_str();\n    return nullptr;\n  }\n\n  CompilerType GetCompilerType() {\n    if (m_type.m_compiler_type.IsValid())\n      return m_type.m_compiler_type;\n    return CompilerType();\n  }\n\n  bool IsRegex() { return m_is_regex; }\n\nprivate:\n  bool m_is_regex;\n  // TODO: Replace this with TypeAndOrName.\n  struct TypeOrName {\n    std::string m_type_name;\n    CompilerType m_compiler_type;\n  };\n  TypeOrName m_type;\n\n  TypeNameSpecifierImpl(const TypeNameSpecifierImpl &) = delete;\n  const TypeNameSpecifierImpl &\n  operator=(const TypeNameSpecifierImpl &) = delete;\n};\n\n} // namespace lldb_private\n\n#endif // LLDB_DATAFORMATTERS_FORMATCLASSES_H\n"}, "13": {"id": 13, "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/DataFormatters/FormattersContainer.h", "content": "//===-- FormattersContainer.h -----------------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLDB_DATAFORMATTERS_FORMATTERSCONTAINER_H\n#define LLDB_DATAFORMATTERS_FORMATTERSCONTAINER_H\n\n#include <functional>\n#include <map>\n#include <memory>\n#include <mutex>\n#include <string>\n\n#include \"lldb/lldb-public.h\"\n\n#include \"lldb/Core/ValueObject.h\"\n#include \"lldb/DataFormatters/FormatClasses.h\"\n#include \"lldb/DataFormatters/TypeFormat.h\"\n#include \"lldb/DataFormatters/TypeSummary.h\"\n#include \"lldb/DataFormatters/TypeSynthetic.h\"\n#include \"lldb/Symbol/CompilerType.h\"\n#include \"lldb/Utility/RegularExpression.h\"\n#include \"lldb/Utility/StringLexer.h\"\n\nnamespace lldb_private {\n\nclass IFormatChangeListener {\npublic:\n  virtual ~IFormatChangeListener() = default;\n\n  virtual void Changed() = 0;\n\n  virtual uint32_t GetCurrentRevision() = 0;\n};\n\n/// Class for matching type names.\nclass TypeMatcher {\n  RegularExpression m_type_name_regex;\n  ConstString m_type_name;\n  /// False if m_type_name_regex should be used for matching. False if this is\n  /// just matching by comparing with m_type_name string.\n  bool m_is_regex;\n\n  // if the user tries to add formatters for, say, \"struct Foo\" those will not\n  // match any type because of the way we strip qualifiers from typenames this\n  // method looks for the case where the user is adding a\n  // \"class\",\"struct\",\"enum\" or \"union\" Foo and strips the unnecessary qualifier\n  static ConstString StripTypeName(ConstString type) {\n    if (type.IsEmpty())\n      return type;\n\n    std::string type_cstr(type.AsCString());\n    StringLexer type_lexer(type_cstr);\n\n    type_lexer.AdvanceIf(\"class \");\n    type_lexer.AdvanceIf(\"enum \");\n    type_lexer.AdvanceIf(\"struct \");\n    type_lexer.AdvanceIf(\"union \");\n\n    while (type_lexer.NextIf({' ', '\\t', '\\v', '\\f'}).first)\n      ;\n\n    return ConstString(type_lexer.GetUnlexed());\n  }\n\npublic:\n  TypeMatcher() = delete;\n  /// Creates a matcher that accepts any type with exactly the given type name.\n  TypeMatcher(ConstString type_name)\n      : m_type_name(type_name), m_is_regex(false) {}\n  /// Creates a matcher that accepts any type matching the given regex.\n  TypeMatcher(RegularExpression regex)\n      : m_type_name_regex(std::move(regex)), m_is_regex(true) {}\n\n  /// True iff this matches the given type name.\n  bool Matches(ConstString type_name) const {\n    if (m_is_regex)\n      return m_type_name_regex.Execute(type_name.GetStringRef());\n    return m_type_name == type_name ||\n           StripTypeName(m_type_name) == StripTypeName(type_name);\n  }\n\n  /// Returns the underlying match string for this TypeMatcher.\n  ConstString GetMatchString() const {\n    if (m_is_regex)\n      return ConstString(m_type_name_regex.GetText());\n    return StripTypeName(m_type_name);\n  }\n\n  /// Returns true if this TypeMatcher and the given one were most created by\n  /// the same match string.\n  /// The main purpose of this function is to find existing TypeMatcher\n  /// instances by the user input that created them. This is necessary as LLDB\n  /// allows referencing existing TypeMatchers in commands by the user input\n  /// that originally created them:\n  /// (lldb) type summary add --summary-string \\\"A\\\" -x TypeName\n  /// (lldb) type summary delete TypeName\n  bool CreatedBySameMatchString(TypeMatcher other) const {\n    return GetMatchString() == other.GetMatchString();\n  }\n};\n\ntemplate <typename ValueType> class FormattersContainer {\npublic:\n  typedef typename std::shared_ptr<ValueType> ValueSP;\n  typedef std::vector<std::pair<TypeMatcher, ValueSP>> MapType;\n  typedef std::function<bool(const TypeMatcher &, const ValueSP &)>\n      ForEachCallback;\n  typedef typename std::shared_ptr<FormattersContainer<ValueType>>\n      SharedPointer;\n\n  friend class TypeCategoryImpl;\n\n  FormattersContainer(IFormatChangeListener *lst) : listener(lst) {}\n\n  void Add(TypeMatcher matcher, const ValueSP &entry) {\n    if (listener)\n      entry->GetRevision() = listener->GetCurrentRevision();\n    else\n      entry->GetRevision() = 0;\n\n    std::lock_guard<std::recursive_mutex> guard(m_map_mutex);\n    Delete(matcher);\n    m_map.emplace_back(std::move(matcher), std::move(entry));\n    if (listener)\n      listener->Changed();\n  }\n\n  bool Delete(TypeMatcher matcher) {\n    std::lock_guard<std::recursive_mutex> guard(m_map_mutex);\n    for (auto iter = m_map.begin(); iter != m_map.end(); ++iter)\n      if (iter->first.CreatedBySameMatchString(matcher)) {\n        m_map.erase(iter);\n        if (listener)\n          listener->Changed();\n        return true;\n      }\n    return false;\n  }\n\n  bool Get(ConstString type, ValueSP &entry) {\n    std::lock_guard<std::recursive_mutex> guard(m_map_mutex);\n    for (auto &formatter : llvm::reverse(m_map)) {\n      if (formatter.first.Matches(type)) {\n        entry = formatter.second;\n        return true;\n      }\n    }\n    return false;\n  }\n\n  bool GetExact(TypeMatcher matcher, ValueSP &entry) {\n    std::lock_guard<std::recursive_mutex> guard(m_map_mutex);\n    for (const auto &pos : m_map)\n      if (pos.first.CreatedBySameMatchString(matcher)) {\n        entry = pos.second;\n        return true;\n      }\n    return false;\n  }\n\n  ValueSP GetAtIndex(size_t index) {\n    std::lock_guard<std::recursive_mutex> guard(m_map_mutex);\n    if (index >= m_map.size())\n      return ValueSP();\n    return m_map[index].second;\n  }\n\n  lldb::TypeNameSpecifierImplSP GetTypeNameSpecifierAtIndex(size_t index) {\n    std::lock_guard<std::recursive_mutex> guard(m_map_mutex);\n    if (index >= m_map.size())\n      return lldb::TypeNameSpecifierImplSP();\n    TypeMatcher type_matcher = m_map[index].first;\n    return std::make_shared<TypeNameSpecifierImpl>(\n        type_matcher.GetMatchString().GetStringRef(), true);\n  }\n\n  void Clear() {\n    std::lock_guard<std::recursive_mutex> guard(m_map_mutex);\n    m_map.clear();\n    if (listener)\n      listener->Changed();\n  }\n\n  void ForEach(ForEachCallback callback) {\n    if (callback) {\n      std::lock_guard<std::recursive_mutex> guard(m_map_mutex);\n      for (const auto &pos : m_map) {\n        const TypeMatcher &type = pos.first;\n        if (!callback(type, pos.second))\n          break;\n      }\n    }\n  }\n\n  uint32_t GetCount() {\n    std::lock_guard<std::recursive_mutex> guard(m_map_mutex);\n    return m_map.size();\n  }\n\n  void AutoComplete(CompletionRequest &request) {\n    ForEach([&request](const TypeMatcher &matcher, const ValueSP &value) {\n      request.TryCompleteCurrentArg(matcher.GetMatchString().GetStringRef());\n      return true;\n    });\n  }\n\nprotected:\n  FormattersContainer(const FormattersContainer &) = delete;\n  const FormattersContainer &operator=(const FormattersContainer &) = delete;\n\n  bool Get(const FormattersMatchVector &candidates, ValueSP &entry) {\n    for (const FormattersMatchCandidate &candidate : candidates) {\n      if (Get(candidate.GetTypeName(), entry)) {\n        if (candidate.IsMatch(entry) == false) {\n          entry.reset();\n          continue;\n        } else {\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n\n  MapType m_map;\n  std::recursive_mutex m_map_mutex;\n  IFormatChangeListener *listener;\n};\n\n} // namespace lldb_private\n\n#endif // LLDB_DATAFORMATTERS_FORMATTERSCONTAINER_H\n"}, "14": {"id": 14, "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/DataFormatters/TypeCategory.h", "content": "//===-- TypeCategory.h ------------------------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLDB_DATAFORMATTERS_TYPECATEGORY_H\n#define LLDB_DATAFORMATTERS_TYPECATEGORY_H\n\n#include <initializer_list>\n#include <memory>\n#include <mutex>\n#include <string>\n#include <vector>\n\n#include \"lldb/lldb-enumerations.h\"\n#include \"lldb/lldb-public.h\"\n\n#include \"lldb/DataFormatters/FormatClasses.h\"\n#include \"lldb/DataFormatters/FormattersContainer.h\"\n\nnamespace lldb_private {\n\ntemplate <typename FormatterImpl> class FormatterContainerPair {\npublic:\n  typedef FormattersContainer<FormatterImpl> ExactMatchContainer;\n  typedef FormattersContainer<FormatterImpl> RegexMatchContainer;\n\n  typedef TypeMatcher ExactMatchMap;\n  typedef TypeMatcher RegexMatchMap;\n\n  typedef typename ExactMatchContainer::ValueSP MapValueType;\n\n  typedef typename ExactMatchContainer::SharedPointer ExactMatchContainerSP;\n  typedef typename RegexMatchContainer::SharedPointer RegexMatchContainerSP;\n\n  typedef\n      typename ExactMatchContainer::ForEachCallback ExactMatchForEachCallback;\n  typedef\n      typename RegexMatchContainer::ForEachCallback RegexMatchForEachCallback;\n\n  FormatterContainerPair(IFormatChangeListener *clist)\n      : m_exact_sp(new ExactMatchContainer(clist)),\n        m_regex_sp(new RegexMatchContainer(clist)) {}\n\n  ~FormatterContainerPair() = default;\n\n  ExactMatchContainerSP GetExactMatch() const { return m_exact_sp; }\n\n  RegexMatchContainerSP GetRegexMatch() const { return m_regex_sp; }\n\n  uint32_t GetCount() {\n    return GetExactMatch()->GetCount() + GetRegexMatch()->GetCount();\n  }\n\nprivate:\n  ExactMatchContainerSP m_exact_sp;\n  RegexMatchContainerSP m_regex_sp;\n};\n\nclass TypeCategoryImpl {\nprivate:\n  typedef FormatterContainerPair<TypeFormatImpl> FormatContainer;\n  typedef FormatterContainerPair<TypeSummaryImpl> SummaryContainer;\n  typedef FormatterContainerPair<TypeFilterImpl> FilterContainer;\n  typedef FormatterContainerPair<SyntheticChildren> SynthContainer;\n\npublic:\n  typedef uint16_t FormatCategoryItems;\n  static const uint16_t ALL_ITEM_TYPES = UINT16_MAX;\n\n  typedef FormatContainer::ExactMatchContainerSP FormatContainerSP;\n  typedef FormatContainer::RegexMatchContainerSP RegexFormatContainerSP;\n\n  typedef SummaryContainer::ExactMatchContainerSP SummaryContainerSP;\n  typedef SummaryContainer::RegexMatchContainerSP RegexSummaryContainerSP;\n\n  typedef FilterContainer::ExactMatchContainerSP FilterContainerSP;\n  typedef FilterContainer::RegexMatchContainerSP RegexFilterContainerSP;\n\n  typedef SynthContainer::ExactMatchContainerSP SynthContainerSP;\n  typedef SynthContainer::RegexMatchContainerSP RegexSynthContainerSP;\n\n  template <typename T> class ForEachCallbacks {\n  public:\n    ForEachCallbacks() = default;\n    ~ForEachCallbacks() = default;\n\n    template <typename U = TypeFormatImpl>\n    typename std::enable_if<std::is_same<U, T>::value, ForEachCallbacks &>::type\n    SetExact(FormatContainer::ExactMatchForEachCallback callback) {\n      m_format_exact = std::move(callback);\n      return *this;\n    }\n    template <typename U = TypeFormatImpl>\n    typename std::enable_if<std::is_same<U, T>::value, ForEachCallbacks &>::type\n    SetWithRegex(FormatContainer::RegexMatchForEachCallback callback) {\n      m_format_regex = std::move(callback);\n      return *this;\n    }\n\n    template <typename U = TypeSummaryImpl>\n    typename std::enable_if<std::is_same<U, T>::value, ForEachCallbacks &>::type\n    SetExact(SummaryContainer::ExactMatchForEachCallback callback) {\n      m_summary_exact = std::move(callback);\n      return *this;\n    }\n    template <typename U = TypeSummaryImpl>\n    typename std::enable_if<std::is_same<U, T>::value, ForEachCallbacks &>::type\n    SetWithRegex(SummaryContainer::RegexMatchForEachCallback callback) {\n      m_summary_regex = std::move(callback);\n      return *this;\n    }\n\n    template <typename U = TypeFilterImpl>\n    typename std::enable_if<std::is_same<U, T>::value, ForEachCallbacks &>::type\n    SetExact(FilterContainer::ExactMatchForEachCallback callback) {\n      m_filter_exact = std::move(callback);\n      return *this;\n    }\n    template <typename U = TypeFilterImpl>\n    typename std::enable_if<std::is_same<U, T>::value, ForEachCallbacks &>::type\n    SetWithRegex(FilterContainer::RegexMatchForEachCallback callback) {\n      m_filter_regex = std::move(callback);\n      return *this;\n    }\n\n    template <typename U = SyntheticChildren>\n    typename std::enable_if<std::is_same<U, T>::value, ForEachCallbacks &>::type\n    SetExact(SynthContainer::ExactMatchForEachCallback callback) {\n      m_synth_exact = std::move(callback);\n      return *this;\n    }\n    template <typename U = SyntheticChildren>\n    typename std::enable_if<std::is_same<U, T>::value, ForEachCallbacks &>::type\n    SetWithRegex(SynthContainer::RegexMatchForEachCallback callback) {\n      m_synth_regex = std::move(callback);\n      return *this;\n    }\n\n    FormatContainer::ExactMatchForEachCallback GetFormatExactCallback() const {\n      return m_format_exact;\n    }\n    FormatContainer::RegexMatchForEachCallback GetFormatRegexCallback() const {\n      return m_format_regex;\n    }\n\n    SummaryContainer::ExactMatchForEachCallback\n    GetSummaryExactCallback() const {\n      return m_summary_exact;\n    }\n    SummaryContainer::RegexMatchForEachCallback\n    GetSummaryRegexCallback() const {\n      return m_summary_regex;\n    }\n\n    FilterContainer::ExactMatchForEachCallback GetFilterExactCallback() const {\n      return m_filter_exact;\n    }\n    FilterContainer::RegexMatchForEachCallback GetFilterRegexCallback() const {\n      return m_filter_regex;\n    }\n\n    SynthContainer::ExactMatchForEachCallback GetSynthExactCallback() const {\n      return m_synth_exact;\n    }\n    SynthContainer::RegexMatchForEachCallback GetSynthRegexCallback() const {\n      return m_synth_regex;\n    }\n\n  private:\n    FormatContainer::ExactMatchForEachCallback m_format_exact;\n    FormatContainer::RegexMatchForEachCallback m_format_regex;\n\n    SummaryContainer::ExactMatchForEachCallback m_summary_exact;\n    SummaryContainer::RegexMatchForEachCallback m_summary_regex;\n\n    FilterContainer::ExactMatchForEachCallback m_filter_exact;\n    FilterContainer::RegexMatchForEachCallback m_filter_regex;\n\n    SynthContainer::ExactMatchForEachCallback m_synth_exact;\n    SynthContainer::RegexMatchForEachCallback m_synth_regex;\n  };\n\n  TypeCategoryImpl(IFormatChangeListener *clist, ConstString name);\n\n  template <typename T> void ForEach(const ForEachCallbacks<T> &foreach) {\n    GetTypeFormatsContainer()->ForEach(foreach.GetFormatExactCallback());\n    GetRegexTypeFormatsContainer()->ForEach(foreach.GetFormatRegexCallback());\n\n    GetTypeSummariesContainer()->ForEach(foreach.GetSummaryExactCallback());\n    GetRegexTypeSummariesContainer()->ForEach(\n        foreach.GetSummaryRegexCallback());\n\n    GetTypeFiltersContainer()->ForEach(foreach.GetFilterExactCallback());\n    GetRegexTypeFiltersContainer()->ForEach(foreach.GetFilterRegexCallback());\n\n    GetTypeSyntheticsContainer()->ForEach(foreach.GetSynthExactCallback());\n    GetRegexTypeSyntheticsContainer()->ForEach(foreach.GetSynthRegexCallback());\n  }\n\n  FormatContainerSP GetTypeFormatsContainer() {\n    return m_format_cont.GetExactMatch();\n  }\n\n  RegexFormatContainerSP GetRegexTypeFormatsContainer() {\n    return m_format_cont.GetRegexMatch();\n  }\n\n  FormatContainer &GetFormatContainer() { return m_format_cont; }\n\n  SummaryContainerSP GetTypeSummariesContainer() {\n    return m_summary_cont.GetExactMatch();\n  }\n\n  RegexSummaryContainerSP GetRegexTypeSummariesContainer() {\n    return m_summary_cont.GetRegexMatch();\n  }\n\n  SummaryContainer &GetSummaryContainer() { return m_summary_cont; }\n\n  FilterContainerSP GetTypeFiltersContainer() {\n    return m_filter_cont.GetExactMatch();\n  }\n\n  RegexFilterContainerSP GetRegexTypeFiltersContainer() {\n    return m_filter_cont.GetRegexMatch();\n  }\n\n  FilterContainer &GetFilterContainer() { return m_filter_cont; }\n\n  FormatContainer::MapValueType\n  GetFormatForType(lldb::TypeNameSpecifierImplSP type_sp);\n\n  SummaryContainer::MapValueType\n  GetSummaryForType(lldb::TypeNameSpecifierImplSP type_sp);\n\n  FilterContainer::MapValueType\n  GetFilterForType(lldb::TypeNameSpecifierImplSP type_sp);\n\n  SynthContainer::MapValueType\n  GetSyntheticForType(lldb::TypeNameSpecifierImplSP type_sp);\n\n  lldb::TypeNameSpecifierImplSP\n  GetTypeNameSpecifierForFormatAtIndex(size_t index);\n\n  lldb::TypeNameSpecifierImplSP\n  GetTypeNameSpecifierForSummaryAtIndex(size_t index);\n\n  FormatContainer::MapValueType GetFormatAtIndex(size_t index);\n\n  SummaryContainer::MapValueType GetSummaryAtIndex(size_t index);\n\n  FilterContainer::MapValueType GetFilterAtIndex(size_t index);\n\n  lldb::TypeNameSpecifierImplSP\n  GetTypeNameSpecifierForFilterAtIndex(size_t index);\n\n  SynthContainerSP GetTypeSyntheticsContainer() {\n    return m_synth_cont.GetExactMatch();\n  }\n\n  RegexSynthContainerSP GetRegexTypeSyntheticsContainer() {\n    return m_synth_cont.GetRegexMatch();\n  }\n\n  SynthContainer &GetSyntheticsContainer() { return m_synth_cont; }\n\n  SynthContainer::MapValueType GetSyntheticAtIndex(size_t index);\n\n  lldb::TypeNameSpecifierImplSP\n  GetTypeNameSpecifierForSyntheticAtIndex(size_t index);\n\n  bool IsEnabled() const { return m_enabled; }\n\n  uint32_t GetEnabledPosition() {\n    if (!m_enabled)\n      return UINT32_MAX;\n    else\n      return m_enabled_position;\n  }\n\n  bool Get(lldb::LanguageType lang, const FormattersMatchVector &candidates,\n           lldb::TypeFormatImplSP &entry);\n\n  bool Get(lldb::LanguageType lang, const FormattersMatchVector &candidates,\n           lldb::TypeSummaryImplSP &entry);\n\n  bool Get(lldb::LanguageType lang, const FormattersMatchVector &candidates,\n           lldb::SyntheticChildrenSP &entry);\n\n  void Clear(FormatCategoryItems items = ALL_ITEM_TYPES);\n\n  bool Delete(ConstString name, FormatCategoryItems items = ALL_ITEM_TYPES);\n\n  uint32_t GetCount(FormatCategoryItems items = ALL_ITEM_TYPES);\n\n  const char *GetName() { return m_name.GetCString(); }\n\n  size_t GetNumLanguages();\n\n  lldb::LanguageType GetLanguageAtIndex(size_t idx);\n\n  void AddLanguage(lldb::LanguageType lang);\n\n  std::string GetDescription();\n\n  bool AnyMatches(ConstString type_name,\n                  FormatCategoryItems items = ALL_ITEM_TYPES,\n                  bool only_enabled = true,\n                  const char **matching_category = nullptr,\n                  FormatCategoryItems *matching_type = nullptr);\n\n  typedef std::shared_ptr<TypeCategoryImpl> SharedPointer;\n\nprivate:\n  FormatContainer m_format_cont;\n  SummaryContainer m_summary_cont;\n  FilterContainer m_filter_cont;\n  SynthContainer m_synth_cont;\n\n  bool m_enabled;\n\n  IFormatChangeListener *m_change_listener;\n\n  std::recursive_mutex m_mutex;\n\n  ConstString m_name;\n\n  std::vector<lldb::LanguageType> m_languages;\n\n  uint32_t m_enabled_position;\n\n  void Enable(bool value, uint32_t position);\n\n  void Disable() { Enable(false, UINT32_MAX); }\n\n  bool IsApplicable(lldb::LanguageType lang);\n\n  uint32_t GetLastEnabledPosition() { return m_enabled_position; }\n\n  void SetEnabledPosition(uint32_t p) { m_enabled_position = p; }\n\n  friend class FormatManager;\n  friend class LanguageCategory;\n  friend class TypeCategoryMap;\n\n  friend class FormattersContainer<TypeFormatImpl>;\n\n  friend class FormattersContainer<TypeSummaryImpl>;\n\n  friend class FormattersContainer<TypeFilterImpl>;\n\n  friend class FormattersContainer<ScriptedSyntheticChildren>;\n};\n\n} // namespace lldb_private\n\n#endif // LLDB_DATAFORMATTERS_TYPECATEGORY_H\n"}, "15": {"id": 15, "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Host/Host.h", "content": "//===-- Host.h --------------------------------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLDB_HOST_HOST_H\n#define LLDB_HOST_HOST_H\n\n#include \"lldb/Host/File.h\"\n#include \"lldb/Host/HostThread.h\"\n#include \"lldb/Utility/Environment.h\"\n#include \"lldb/Utility/FileSpec.h\"\n#include \"lldb/Utility/Timeout.h\"\n#include \"lldb/lldb-private-forward.h\"\n#include \"lldb/lldb-private.h\"\n#include <cerrno>\n#include <map>\n#include <stdarg.h>\n#include <string>\n#include <type_traits>\n\nnamespace lldb_private {\n\nclass FileAction;\nclass ProcessLaunchInfo;\nclass ProcessInstanceInfo;\nclass ProcessInstanceInfoMatch;\ntypedef std::vector<ProcessInstanceInfo> ProcessInstanceInfoList;\n\n// Exit Type for inferior processes\nstruct WaitStatus {\n  enum Type : uint8_t {\n    Exit,   // The status represents the return code from normal\n            // program exit (i.e. WIFEXITED() was true)\n    Signal, // The status represents the signal number that caused\n            // the program to exit (i.e. WIFSIGNALED() was true)\n    Stop,   // The status represents the signal number that caused the\n            // program to stop (i.e. WIFSTOPPED() was true)\n  };\n\n  Type type;\n  uint8_t status;\n\n  WaitStatus(Type type, uint8_t status) : type(type), status(status) {}\n\n  static WaitStatus Decode(int wstatus);\n};\n\ninline bool operator==(WaitStatus a, WaitStatus b) {\n  return a.type == b.type && a.status == b.status;\n}\n\ninline bool operator!=(WaitStatus a, WaitStatus b) { return !(a == b); }\n\n/// \\class Host Host.h \"lldb/Host/Host.h\"\n/// A class that provides host computer information.\n///\n/// Host is a class that answers information about the host operating system.\nclass Host {\npublic:\n  typedef std::function<bool(\n      lldb::pid_t pid, bool exited,\n      int signal,  // Zero for no signal\n      int status)> // Exit value of process if signal is zero\n      MonitorChildProcessCallback;\n\n  /// Start monitoring a child process.\n  ///\n  /// Allows easy monitoring of child processes. \\a callback will be called\n  /// when the child process exits or if it gets a signal. The callback will\n  /// only be called with signals if \\a monitor_signals is \\b true. \\a\n  /// callback will usually be called from another thread so the callback\n  /// function must be thread safe.\n  ///\n  /// When the callback gets called, the return value indicates if monitoring\n  /// should stop. If \\b true is returned from \\a callback the information\n  /// will be removed. If \\b false is returned then monitoring will continue.\n  /// If the child process exits, the monitoring will automatically stop after\n  /// the callback returned regardless of the callback return value.\n  ///\n  /// \\param[in] callback\n  ///     A function callback to call when a child receives a signal\n  ///     (if \\a monitor_signals is true) or a child exits.\n  ///\n  /// \\param[in] pid\n  ///     The process ID of a child process to monitor, -1 for all\n  ///     processes.\n  ///\n  /// \\param[in] monitor_signals\n  ///     If \\b true the callback will get called when the child\n  ///     process gets a signal. If \\b false, the callback will only\n  ///     get called if the child process exits.\n  ///\n  /// \\return\n  ///     A thread handle that can be used to cancel the thread that\n  ///     was spawned to monitor \\a pid.\n  ///\n  /// \\see static void Host::StopMonitoringChildProcess (uint32_t)\n  static llvm::Expected<HostThread>\n  StartMonitoringChildProcess(const MonitorChildProcessCallback &callback,\n                              lldb::pid_t pid, bool monitor_signals);\n\n  enum SystemLogType { eSystemLogWarning, eSystemLogError };\n\n  static void SystemLog(SystemLogType type, const char *format, ...)\n      __attribute__((format(printf, 2, 3)));\n\n  static void SystemLog(SystemLogType type, const char *format, va_list args);\n\n  /// Get the process ID for the calling process.\n  ///\n  /// \\return\n  ///     The process ID for the current process.\n  static lldb::pid_t GetCurrentProcessID();\n\n  static void Kill(lldb::pid_t pid, int signo);\n\n  /// Get the thread token (the one returned by ThreadCreate when the thread\n  /// was created) for the calling thread in the current process.\n  ///\n  /// \\return\n  ///     The thread token for the calling thread in the current process.\n  static lldb::thread_t GetCurrentThread();\n\n  static const char *GetSignalAsCString(int signo);\n\n  /// Given an address in the current process (the process that is running the\n  /// LLDB code), return the name of the module that it comes from. This can\n  /// be useful when you need to know the path to the shared library that your\n  /// code is running in for loading resources that are relative to your\n  /// binary.\n  ///\n  /// \\param[in] host_addr\n  ///     The pointer to some code in the current process.\n  ///\n  /// \\return\n  ///     \\b A file spec with the module that contains \\a host_addr,\n  ///     which may be invalid if \\a host_addr doesn't fall into\n  ///     any valid module address range.\n  static FileSpec GetModuleFileSpecForHostAddress(const void *host_addr);\n\n  /// If you have an executable that is in a bundle and want to get back to\n  /// the bundle directory from the path itself, this function will change a\n  /// path to a file within a bundle to the bundle directory itself.\n  ///\n  /// \\param[in] file\n  ///     A file spec that might point to a file in a bundle.\n  ///\n  /// \\param[out] bundle_directory\n  ///     An object will be filled in with the bundle directory for\n  ///     the bundle when \\b true is returned. Otherwise \\a file is\n  ///     left untouched and \\b false is returned.\n  ///\n  /// \\return\n  ///     \\b true if \\a file was resolved in \\a bundle_directory,\n  ///     \\b false otherwise.\n  static bool GetBundleDirectory(const FileSpec &file,\n                                 FileSpec &bundle_directory);\n\n  /// When executable files may live within a directory, where the directory\n  /// represents an executable bundle (like the MacOSX app bundles), then\n  /// locate the executable within the containing bundle.\n  ///\n  /// \\param[in,out] file\n  ///     A file spec that currently points to the bundle that will\n  ///     be filled in with the executable path within the bundle\n  ///     if \\b true is returned. Otherwise \\a file is left untouched.\n  ///\n  /// \\return\n  ///     \\b true if \\a file was resolved, \\b false if this function\n  ///     was not able to resolve the path.\n  static bool ResolveExecutableInBundle(FileSpec &file);\n\n  static uint32_t FindProcesses(const ProcessInstanceInfoMatch &match_info,\n                                ProcessInstanceInfoList &proc_infos);\n\n  typedef std::map<lldb::pid_t, bool> TidMap;\n  typedef std::pair<lldb::pid_t, bool> TidPair;\n  static bool FindProcessThreads(const lldb::pid_t pid, TidMap &tids_to_attach);\n\n  static bool GetProcessInfo(lldb::pid_t pid, ProcessInstanceInfo &proc_info);\n\n  /// Launch the process specified in launch_info. The monitoring callback in\n  /// launch_info must be set, and it will be called when the process\n  /// terminates.\n  static Status LaunchProcess(ProcessLaunchInfo &launch_info);\n\n  /// Perform expansion of the command-line for this launch info This can\n  /// potentially involve wildcard expansion\n  /// environment variable replacement, and whatever other\n  /// argument magic the platform defines as part of its typical\n  /// user experience\n  static Status ShellExpandArguments(ProcessLaunchInfo &launch_info);\n\n  /// Run a shell command.\n  /// \\arg command  shouldn't be empty\n  /// \\arg working_dir Pass empty FileSpec to use the current working directory\n  /// \\arg status_ptr  Pass NULL if you don't want the process exit status\n  /// \\arg signo_ptr   Pass NULL if you don't want the signal that caused the\n  ///                  process to exit\n  /// \\arg command_output  Pass NULL if you don't want the command output\n  /// \\arg hide_stderr if this is false, redirect stderr to stdout\n  static Status RunShellCommand(llvm::StringRef command,\n                                const FileSpec &working_dir, int *status_ptr,\n                                int *signo_ptr, std::string *command_output,\n                                const Timeout<std::micro> &timeout,\n                                bool run_in_shell = true,\n                                bool hide_stderr = false);\n\n  /// Run a shell command.\n  /// \\arg shell  Pass an empty string if you want to use the default shell\n  /// interpreter \\arg command \\arg working_dir  Pass empty FileSpec to use the\n  /// current working directory \\arg status_ptr   Pass NULL if you don't want\n  /// the process exit status \\arg signo_ptr    Pass NULL if you don't want the\n  /// signal that caused\n  ///                   the process to exit\n  /// \\arg command_output  Pass NULL if you don't want the command output\n  /// \\arg hide_stderr  If this is \\b false, redirect stderr to stdout\n  static Status RunShellCommand(llvm::StringRef shell, llvm::StringRef command,\n                                const FileSpec &working_dir, int *status_ptr,\n                                int *signo_ptr, std::string *command_output,\n                                const Timeout<std::micro> &timeout,\n                                bool run_in_shell = true,\n                                bool hide_stderr = false);\n\n  /// Run a shell command.\n  /// \\arg working_dir Pass empty FileSpec to use the current working directory\n  /// \\arg status_ptr  Pass NULL if you don't want the process exit status\n  /// \\arg signo_ptr   Pass NULL if you don't want the signal that caused the\n  ///                  process to exit\n  /// \\arg command_output  Pass NULL if you don't want the command output\n  /// \\arg hide_stderr if this is false, redirect stderr to stdout\n  static Status RunShellCommand(const Args &args, const FileSpec &working_dir,\n                                int *status_ptr, int *signo_ptr,\n                                std::string *command_output,\n                                const Timeout<std::micro> &timeout,\n                                bool run_in_shell = true,\n                                bool hide_stderr = false);\n\n  /// Run a shell command.\n  /// \\arg shell            Pass an empty string if you want to use the default\n  /// shell interpreter \\arg command \\arg working_dir Pass empty FileSpec to use\n  /// the current working directory \\arg status_ptr    Pass NULL if you don't\n  /// want the process exit status \\arg signo_ptr     Pass NULL if you don't\n  /// want the signal that caused the\n  ///               process to exit\n  /// \\arg command_output  Pass NULL if you don't want the command output\n  /// \\arg hide_stderr If this is \\b false, redirect stderr to stdout\n  static Status RunShellCommand(llvm::StringRef shell, const Args &args,\n                                const FileSpec &working_dir, int *status_ptr,\n                                int *signo_ptr, std::string *command_output,\n                                const Timeout<std::micro> &timeout,\n                                bool run_in_shell = true,\n                                bool hide_stderr = false);\n\n  static bool OpenFileInExternalEditor(const FileSpec &file_spec,\n                                       uint32_t line_no);\n\n  static Environment GetEnvironment();\n\n  static std::unique_ptr<Connection>\n  CreateDefaultConnection(llvm::StringRef url);\n\nprotected:\n  static uint32_t FindProcessesImpl(const ProcessInstanceInfoMatch &match_info,\n                                    ProcessInstanceInfoList &proc_infos);\n};\n\n} // namespace lldb_private\n\nnamespace llvm {\ntemplate <> struct format_provider<lldb_private::WaitStatus> {\n  /// Options = \"\" gives a human readable description of the status Options =\n  /// \"g\" gives a gdb-remote protocol status (e.g., X09)\n  static void format(const lldb_private::WaitStatus &WS, raw_ostream &OS,\n                     llvm::StringRef Options);\n};\n} // namespace llvm\n\n#endif // LLDB_HOST_HOST_H\n"}, "16": {"id": 16, "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Host/HostThread.h", "content": "//===-- HostThread.h --------------------------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLDB_HOST_HOSTTHREAD_H\n#define LLDB_HOST_HOSTTHREAD_H\n\n#include \"lldb/Host/HostNativeThreadForward.h\"\n#include \"lldb/Utility/Status.h\"\n#include \"lldb/lldb-types.h\"\n\n#include <memory>\n\nnamespace lldb_private {\n\nclass HostNativeThreadBase;\n\n/// \\class HostInfo HostInfo.h \"lldb/Host/HostThread.h\"\n/// A class that represents a thread running inside of a process on the\n///        local machine.\n///\n/// HostThread allows querying and manipulation of threads running on the host\n/// machine.\n///\nclass HostThread {\npublic:\n  HostThread();\n  HostThread(lldb::thread_t thread);\n\n  Status Join(lldb::thread_result_t *result);\n  Status Cancel();\n  void Reset();\n  lldb::thread_t Release();\n\n  bool IsJoinable() const;\n  HostNativeThread &GetNativeThread();\n  const HostNativeThread &GetNativeThread() const;\n  lldb::thread_result_t GetResult() const;\n\n  bool EqualsThread(lldb::thread_t thread) const;\n\nprivate:\n  std::shared_ptr<HostNativeThreadBase> m_native_thread;\n};\n}\n\n#endif\n"}, "17": {"id": 17, "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Host/ProcessLaunchInfo.h", "content": "//===-- ProcessLaunchInfo.h -------------------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLDB_HOST_PROCESSLAUNCHINFO_H\n#define LLDB_HOST_PROCESSLAUNCHINFO_H\n\n// C++ Headers\n#include <string>\n\n// LLDB Headers\n#include \"lldb/Utility/Flags.h\"\n\n#include \"lldb/Host/FileAction.h\"\n#include \"lldb/Host/Host.h\"\n#include \"lldb/Host/PseudoTerminal.h\"\n#include \"lldb/Utility/FileSpec.h\"\n#include \"lldb/Utility/ProcessInfo.h\"\n\nnamespace lldb_private {\n\n// ProcessLaunchInfo\n//\n// Describes any information that is required to launch a process.\n\nclass ProcessLaunchInfo : public ProcessInfo {\npublic:\n  ProcessLaunchInfo();\n\n  ProcessLaunchInfo(const FileSpec &stdin_file_spec,\n                    const FileSpec &stdout_file_spec,\n                    const FileSpec &stderr_file_spec,\n                    const FileSpec &working_dir, uint32_t launch_flags);\n\n  void AppendFileAction(const FileAction &info) {\n    m_file_actions.push_back(info);\n  }\n\n  bool AppendCloseFileAction(int fd);\n\n  bool AppendDuplicateFileAction(int fd, int dup_fd);\n\n  bool AppendOpenFileAction(int fd, const FileSpec &file_spec, bool read,\n                            bool write);\n\n  bool AppendSuppressFileAction(int fd, bool read, bool write);\n\n  // Redirect stdin/stdout/stderr to a pty, if no action for the respective file\n  // descriptor is specified. (So if stdin and stdout already have file actions,\n  // but stderr doesn't, then only stderr will be redirected to a pty.)\n  llvm::Error SetUpPtyRedirection();\n\n  size_t GetNumFileActions() const { return m_file_actions.size(); }\n\n  const FileAction *GetFileActionAtIndex(size_t idx) const;\n\n  const FileAction *GetFileActionForFD(int fd) const;\n\n  Flags &GetFlags() { return m_flags; }\n\n  const Flags &GetFlags() const { return m_flags; }\n\n  const FileSpec &GetWorkingDirectory() const;\n\n  void SetWorkingDirectory(const FileSpec &working_dir);\n\n  const char *GetProcessPluginName() const;\n\n  void SetProcessPluginName(llvm::StringRef plugin);\n\n  const FileSpec &GetShell() const;\n\n  void SetShell(const FileSpec &shell);\n\n  uint32_t GetResumeCount() const { return m_resume_count; }\n\n  void SetResumeCount(uint32_t c) { m_resume_count = c; }\n\n  bool GetLaunchInSeparateProcessGroup() const {\n    return m_flags.Test(lldb::eLaunchFlagLaunchInSeparateProcessGroup);\n  }\n\n  void SetLaunchInSeparateProcessGroup(bool separate);\n\n  bool GetShellExpandArguments() const {\n    return m_flags.Test(lldb::eLaunchFlagShellExpandArguments);\n  }\n\n  void SetShellExpandArguments(bool expand);\n\n  void Clear();\n\n  bool ConvertArgumentsForLaunchingInShell(Status &error, bool will_debug,\n                                           bool first_arg_is_full_shell_command,\n                                           uint32_t num_resumes);\n\n  void\n  SetMonitorProcessCallback(const Host::MonitorChildProcessCallback &callback,\n                            bool monitor_signals);\n\n  Host::MonitorChildProcessCallback GetMonitorProcessCallback() const {\n    return m_monitor_callback;\n  }\n\n  /// A Monitor callback which does not take any action on process events. Use\n  /// this if you don't need to take any particular action when the process\n  /// terminates, but you still need to reap it.\n  static bool NoOpMonitorCallback(lldb::pid_t pid, bool exited, int signal,\n                                  int status);\n\n  bool GetMonitorSignals() const { return m_monitor_signals; }\n\n  // If the LaunchInfo has a monitor callback, then arrange to monitor the\n  // process. Return true if the LaunchInfo has taken care of monitoring the\n  // process, and false if the caller might want to monitor the process\n  // themselves.\n\n  bool MonitorProcess() const;\n\n  PseudoTerminal &GetPTY() { return *m_pty; }\n\n  // Get and set the actual listener that will be used for the process events\n  lldb::ListenerSP GetListener() const { return m_listener_sp; }\n\n  void SetListener(const lldb::ListenerSP &listener_sp) {\n    m_listener_sp = listener_sp;\n  }\n\n  lldb::ListenerSP GetHijackListener() const { return m_hijack_listener_sp; }\n\n  void SetHijackListener(const lldb::ListenerSP &listener_sp) {\n    m_hijack_listener_sp = listener_sp;\n  }\n\n  void SetLaunchEventData(const char *data) { m_event_data.assign(data); }\n\n  const char *GetLaunchEventData() const { return m_event_data.c_str(); }\n\n  void SetDetachOnError(bool enable);\n\n  bool GetDetachOnError() const {\n    return m_flags.Test(lldb::eLaunchFlagDetachOnError);\n  }\n\nprotected:\n  FileSpec m_working_dir;\n  std::string m_plugin_name;\n  FileSpec m_shell;\n  Flags m_flags; // Bitwise OR of bits from lldb::LaunchFlags\n  std::vector<FileAction> m_file_actions; // File actions for any other files\n  std::shared_ptr<PseudoTerminal> m_pty;\n  uint32_t m_resume_count; // How many times do we resume after launching\n  Host::MonitorChildProcessCallback m_monitor_callback;\n  void *m_monitor_callback_baton;\n  bool m_monitor_signals;\n  std::string m_event_data; // A string passed to the plugin launch, having no\n                            // meaning to the upper levels of lldb.\n  lldb::ListenerSP m_listener_sp;\n  lldb::ListenerSP m_hijack_listener_sp;\n};\n}\n\n#endif // LLDB_HOST_PROCESSLAUNCHINFO_H\n"}, "18": {"id": 18, "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Symbol/CompilerDecl.h", "content": "//===-- CompilerDecl.h ------------------------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLDB_SYMBOL_COMPILERDECL_H\n#define LLDB_SYMBOL_COMPILERDECL_H\n\n#include \"lldb/Symbol/CompilerType.h\"\n#include \"lldb/Utility/ConstString.h\"\n#include \"lldb/lldb-private.h\"\n\nnamespace lldb_private {\n\n/// Represents a generic declaration such as a function declaration.\n///\n/// This class serves as an abstraction for a declaration inside one of the\n/// TypeSystems implemented by the language plugins. It does not have any actual\n/// logic in it but only stores an opaque pointer and a pointer to the\n/// TypeSystem that gives meaning to this opaque pointer. All methods of this\n/// class should call their respective method in the TypeSystem interface and\n/// pass the opaque pointer along.\n///\n/// \\see lldb_private::TypeSystem\nclass CompilerDecl {\npublic:\n  // Constructors and Destructors\n  CompilerDecl() = default;\n\n  /// Creates a CompilerDecl with the given TypeSystem and opaque pointer.\n  ///\n  /// This constructor should only be called from the respective TypeSystem\n  /// implementation.\n  CompilerDecl(TypeSystem *type_system, void *decl)\n      : m_type_system(type_system), m_opaque_decl(decl) {}\n\n  // Tests\n\n  explicit operator bool() const { return IsValid(); }\n\n  bool operator<(const CompilerDecl &rhs) const {\n    if (m_type_system == rhs.m_type_system)\n      return m_opaque_decl < rhs.m_opaque_decl;\n    return m_type_system < rhs.m_type_system;\n  }\n\n  bool IsValid() const {\n    return m_type_system != nullptr && m_opaque_decl != nullptr;\n  }\n\n  // Accessors\n\n  TypeSystem *GetTypeSystem() const { return m_type_system; }\n\n  void *GetOpaqueDecl() const { return m_opaque_decl; }\n\n  void SetDecl(TypeSystem *type_system, void *decl) {\n    m_type_system = type_system;\n    m_opaque_decl = decl;\n  }\n\n  void Clear() {\n    m_type_system = nullptr;\n    m_opaque_decl = nullptr;\n  }\n\n  ConstString GetName() const;\n\n  ConstString GetMangledName() const;\n\n  CompilerDeclContext GetDeclContext() const;\n\n  // If this decl represents a function, return the return type\n  CompilerType GetFunctionReturnType() const;\n\n  // If this decl represents a function, return the number of arguments for the\n  // function\n  size_t GetNumFunctionArguments() const;\n\n  // If this decl represents a function, return the argument type given a zero\n  // based argument index\n  CompilerType GetFunctionArgumentType(size_t arg_idx) const;\n\nprivate:\n  TypeSystem *m_type_system = nullptr;\n  void *m_opaque_decl = nullptr;\n};\n\nbool operator==(const CompilerDecl &lhs, const CompilerDecl &rhs);\nbool operator!=(const CompilerDecl &lhs, const CompilerDecl &rhs);\n\n} // namespace lldb_private\n\n#endif // LLDB_SYMBOL_COMPILERDECL_H\n"}, "19": {"id": 19, "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Symbol/CompilerDeclContext.h", "content": "//===-- CompilerDeclContext.h -----------------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLDB_SYMBOL_COMPILERDECLCONTEXT_H\n#define LLDB_SYMBOL_COMPILERDECLCONTEXT_H\n\n#include <vector>\n\n#include \"lldb/Utility/ConstString.h\"\n#include \"lldb/lldb-private.h\"\n\nnamespace lldb_private {\n\n/// Represents a generic declaration context in a program. A declaration context\n/// is data structure that contains declarations (e.g. namespaces).\n///\n/// This class serves as an abstraction for a declaration context inside one of\n/// the TypeSystems implemented by the language plugins. It does not have any\n/// actual logic in it but only stores an opaque pointer and a pointer to the\n/// TypeSystem that gives meaning to this opaque pointer. All methods of this\n/// class should call their respective method in the TypeSystem interface and\n/// pass the opaque pointer along.\n///\n/// \\see lldb_private::TypeSystem\nclass CompilerDeclContext {\npublic:\n  /// Constructs an invalid CompilerDeclContext.\n  CompilerDeclContext() = default;\n\n  /// Constructs a CompilerDeclContext with the given opaque decl context\n  /// and its respective TypeSystem instance.\n  ///\n  /// This constructor should only be called from the respective TypeSystem\n  /// implementation.\n  ///\n  /// \\see lldb_private::TypeSystemClang::CreateDeclContext(clang::DeclContext*)\n  CompilerDeclContext(TypeSystem *type_system, void *decl_ctx)\n      : m_type_system(type_system), m_opaque_decl_ctx(decl_ctx) {}\n\n  // Tests\n\n  explicit operator bool() const { return IsValid(); }\n\n  bool operator<(const CompilerDeclContext &rhs) const {\n    if (m_type_system == rhs.m_type_system)\n      return m_opaque_decl_ctx < rhs.m_opaque_decl_ctx;\n    return m_type_system < rhs.m_type_system;\n  }\n\n  bool IsValid() const {\n    return m_type_system != nullptr && m_opaque_decl_ctx != nullptr;\n  }\n\n  std::vector<CompilerDecl> FindDeclByName(ConstString name,\n                                           const bool ignore_using_decls);\n\n  /// Checks if this decl context represents a method of a class.\n  ///\n  /// \\param[out] language_ptr\n  ///     If non NULL and \\b true is returned from this function,\n  ///     this will indicate if the language that respresents the method.\n  ///\n  /// \\param[out] is_instance_method_ptr\n  ///     If non NULL and \\b true is returned from this function,\n  ///     this will indicate if the method is an instance function (true)\n  ///     or a class method (false indicating the function is static, or\n  ///     doesn't require an instance of the class to be called).\n  ///\n  /// \\param[out] language_object_name_ptr\n  ///     If non NULL and \\b true is returned from this function,\n  ///     this will indicate if implicit object name for the language\n  ///     like \"this\" for C++, and \"self\" for Objective C.\n  ///\n  /// \\return\n  ///     Returns true if this is a decl context that represents a method\n  ///     in a struct, union or class.\n  bool IsClassMethod(lldb::LanguageType *language_ptr,\n                     bool *is_instance_method_ptr,\n                     ConstString *language_object_name_ptr);\n\n  /// Check if the given other decl context is contained in the lookup\n  /// of this decl context (for example because the other context is a nested\n  /// inline namespace).\n  ///\n  /// @param[in] other\n  ///     The other decl context for which we should check if it is contained\n  ///     in the lookoup of this context.\n  ///\n  /// @return\n  ///     Returns true iff the other decl context is contained in the lookup\n  ///     of this decl context.\n  bool IsContainedInLookup(CompilerDeclContext other) const;\n\n  // Accessors\n\n  TypeSystem *GetTypeSystem() const { return m_type_system; }\n\n  void *GetOpaqueDeclContext() const { return m_opaque_decl_ctx; }\n\n  void SetDeclContext(TypeSystem *type_system, void *decl_ctx) {\n    m_type_system = type_system;\n    m_opaque_decl_ctx = decl_ctx;\n  }\n\n  void Clear() {\n    m_type_system = nullptr;\n    m_opaque_decl_ctx = nullptr;\n  }\n\n  ConstString GetName() const;\n\n  ConstString GetScopeQualifiedName() const;\n\nprivate:\n  TypeSystem *m_type_system = nullptr;\n  void *m_opaque_decl_ctx = nullptr;\n};\n\nbool operator==(const CompilerDeclContext &lhs, const CompilerDeclContext &rhs);\nbool operator!=(const CompilerDeclContext &lhs, const CompilerDeclContext &rhs);\n\n} // namespace lldb_private\n\n#endif // LLDB_SYMBOL_COMPILERDECLCONTEXT_H\n"}, "20": {"id": 20, "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Symbol/CompilerType.h", "content": "//===-- CompilerType.h ------------------------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLDB_SYMBOL_COMPILERTYPE_H\n#define LLDB_SYMBOL_COMPILERTYPE_H\n\n#include <functional>\n#include <string>\n#include <vector>\n\n#include \"lldb/lldb-private.h\"\n#include \"llvm/ADT/APSInt.h\"\n\nnamespace lldb_private {\n\nclass DataExtractor;\n\n/// Generic representation of a type in a programming language.\n///\n/// This class serves as an abstraction for a type inside one of the TypeSystems\n/// implemented by the language plugins. It does not have any actual logic in it\n/// but only stores an opaque pointer and a pointer to the TypeSystem that\n/// gives meaning to this opaque pointer. All methods of this class should call\n/// their respective method in the TypeSystem interface and pass the opaque\n/// pointer along.\n///\n/// \\see lldb_private::TypeSystem\nclass CompilerType {\npublic:\n  /// Creates a CompilerType with the given TypeSystem and opaque compiler type.\n  ///\n  /// This constructor should only be called from the respective TypeSystem\n  /// implementation.\n  ///\n  /// \\see lldb_private::TypeSystemClang::GetType(clang::QualType)\n  CompilerType(TypeSystem *type_system, lldb::opaque_compiler_type_t type)\n      : m_type(type), m_type_system(type_system) {\n    assert(Verify() && \"verification failed\");\n  }\n\n  CompilerType(const CompilerType &rhs)\n      : m_type(rhs.m_type), m_type_system(rhs.m_type_system) {}\n\n  CompilerType() = default;\n\n  /// Operators.\n  /// \\{\n  const CompilerType &operator=(const CompilerType &rhs) {\n    m_type = rhs.m_type;\n    m_type_system = rhs.m_type_system;\n    return *this;\n  }\n\n  bool operator<(const CompilerType &rhs) const {\n    if (m_type_system == rhs.m_type_system)\n      return m_type < rhs.m_type;\n    return m_type_system < rhs.m_type_system;\n  }\n  /// \\}\n\n  /// Tests.\n  /// \\{\n  explicit operator bool() const {\n    return m_type != nullptr && m_type_system != nullptr;\n  }\n\n  bool IsValid() const { return m_type != nullptr && m_type_system != nullptr; }\n\n  bool IsArrayType(CompilerType *element_type = nullptr,\n                   uint64_t *size = nullptr,\n                   bool *is_incomplete = nullptr) const;\n\n  bool IsVectorType(CompilerType *element_type = nullptr,\n                    uint64_t *size = nullptr) const;\n\n  bool IsArrayOfScalarType() const;\n\n  bool IsAggregateType() const;\n\n  bool IsAnonymousType() const;\n\n  bool IsScopedEnumerationType() const;\n\n  bool IsBeingDefined() const;\n\n  bool IsCharType() const;\n\n  bool IsCompleteType() const;\n\n  bool IsConst() const;\n\n  bool IsCStringType(uint32_t &length) const;\n\n  bool IsDefined() const;\n\n  bool IsFloatingPointType(uint32_t &count, bool &is_complex) const;\n\n  bool IsFunctionType() const;\n\n  uint32_t IsHomogeneousAggregate(CompilerType *base_type_ptr) const;\n\n  size_t GetNumberOfFunctionArguments() const;\n\n  CompilerType GetFunctionArgumentAtIndex(const size_t index) const;\n\n  bool IsVariadicFunctionType() const;\n\n  bool IsFunctionPointerType() const;\n\n  bool\n  IsBlockPointerType(CompilerType *function_pointer_type_ptr = nullptr) const;\n\n  bool IsIntegerType(bool &is_signed) const;\n\n  bool IsEnumerationType(bool &is_signed) const;\n\n  bool IsIntegerOrEnumerationType(bool &is_signed) const;\n\n  bool IsPolymorphicClass() const;\n\n  /// \\param target_type    Can pass nullptr.\n  bool IsPossibleDynamicType(CompilerType *target_type, bool check_cplusplus,\n                             bool check_objc) const;\n\n  bool IsPointerToScalarType() const;\n\n  bool IsRuntimeGeneratedType() const;\n\n  bool IsPointerType(CompilerType *pointee_type = nullptr) const;\n\n  bool IsPointerOrReferenceType(CompilerType *pointee_type = nullptr) const;\n\n  bool IsReferenceType(CompilerType *pointee_type = nullptr,\n                       bool *is_rvalue = nullptr) const;\n\n  bool ShouldTreatScalarValueAsAddress() const;\n\n  bool IsScalarType() const;\n\n  bool IsTypedefType() const;\n\n  bool IsVoidType() const;\n  /// \\}\n\n  /// Type Completion.\n  /// \\{\n  bool GetCompleteType() const;\n  /// \\}\n\n  /// AST related queries.\n  /// \\{\n  size_t GetPointerByteSize() const;\n  /// \\}\n\n  /// Accessors.\n  /// \\{\n  TypeSystem *GetTypeSystem() const { return m_type_system; }\n\n  ConstString GetTypeName() const;\n\n  ConstString GetDisplayTypeName() const;\n\n  uint32_t\n  GetTypeInfo(CompilerType *pointee_or_element_compiler_type = nullptr) const;\n\n  lldb::LanguageType GetMinimumLanguage();\n\n  lldb::opaque_compiler_type_t GetOpaqueQualType() const { return m_type; }\n\n  lldb::TypeClass GetTypeClass() const;\n\n  void SetCompilerType(TypeSystem *type_system,\n                       lldb::opaque_compiler_type_t type);\n\n  unsigned GetTypeQualifiers() const;\n  /// \\}\n\n  /// Creating related types.\n  /// \\{\n  CompilerType GetArrayElementType(ExecutionContextScope *exe_scope) const;\n\n  CompilerType GetArrayType(uint64_t size) const;\n\n  CompilerType GetCanonicalType() const;\n\n  CompilerType GetFullyUnqualifiedType() const;\n\n  CompilerType GetEnumerationIntegerType() const;\n\n  /// Returns -1 if this isn't a function of if the function doesn't\n  /// have a prototype Returns a value >= 0 if there is a prototype.\n  int GetFunctionArgumentCount() const;\n\n  CompilerType GetFunctionArgumentTypeAtIndex(size_t idx) const;\n\n  CompilerType GetFunctionReturnType() const;\n\n  size_t GetNumMemberFunctions() const;\n\n  TypeMemberFunctionImpl GetMemberFunctionAtIndex(size_t idx);\n\n  /// If this type is a reference to a type (L value or R value reference),\n  /// return a new type with the reference removed, else return the current type\n  /// itself.\n  CompilerType GetNonReferenceType() const;\n\n  /// If this type is a pointer type, return the type that the pointer points\n  /// to, else return an invalid type.\n  CompilerType GetPointeeType() const;\n\n  /// Return a new CompilerType that is a pointer to this type\n  CompilerType GetPointerType() const;\n\n  /// Return a new CompilerType that is a L value reference to this type if this\n  /// type is valid and the type system supports L value references, else return\n  /// an invalid type.\n  CompilerType GetLValueReferenceType() const;\n\n  /// Return a new CompilerType that is a R value reference to this type if this\n  /// type is valid and the type system supports R value references, else return\n  /// an invalid type.\n  CompilerType GetRValueReferenceType() const;\n\n  /// Return a new CompilerType adds a const modifier to this type if this type\n  /// is valid and the type system supports const modifiers, else return an\n  /// invalid type.\n  CompilerType AddConstModifier() const;\n\n  /// Return a new CompilerType adds a volatile modifier to this type if this\n  /// type is valid and the type system supports volatile modifiers, else return\n  /// an invalid type.\n  CompilerType AddVolatileModifier() const;\n\n  /// Return a new CompilerType that is the atomic type of this type. If this\n  /// type is not valid or the type system doesn't support atomic types, this\n  /// returns an invalid type.\n  CompilerType GetAtomicType() const;\n\n  /// Return a new CompilerType adds a restrict modifier to this type if this\n  /// type is valid and the type system supports restrict modifiers, else return\n  /// an invalid type.\n  CompilerType AddRestrictModifier() const;\n\n  /// Create a typedef to this type using \"name\" as the name of the typedef this\n  /// type is valid and the type system supports typedefs, else return an\n  /// invalid type.\n  /// \\param payload   The typesystem-specific \\p lldb::Type payload.\n  CompilerType CreateTypedef(const char *name,\n                             const CompilerDeclContext &decl_ctx,\n                             uint32_t payload) const;\n\n  /// If the current object represents a typedef type, get the underlying type\n  CompilerType GetTypedefedType() const;\n\n  /// Create related types using the current type's AST\n  CompilerType GetBasicTypeFromAST(lldb::BasicType basic_type) const;\n  /// \\}\n\n  /// Exploring the type.\n  /// \\{\n  struct IntegralTemplateArgument;\n\n  /// Return the size of the type in bytes.\n  llvm::Optional<uint64_t> GetByteSize(ExecutionContextScope *exe_scope) const;\n  /// Return the size of the type in bits.\n  llvm::Optional<uint64_t> GetBitSize(ExecutionContextScope *exe_scope) const;\n\n  lldb::Encoding GetEncoding(uint64_t &count) const;\n\n  lldb::Format GetFormat() const;\n\n  llvm::Optional<size_t>\n  GetTypeBitAlign(ExecutionContextScope *exe_scope) const;\n\n  uint32_t GetNumChildren(bool omit_empty_base_classes,\n                          const ExecutionContext *exe_ctx) const;\n\n  lldb::BasicType GetBasicTypeEnumeration() const;\n\n  static lldb::BasicType GetBasicTypeEnumeration(ConstString name);\n\n  /// If this type is an enumeration, iterate through all of its enumerators\n  /// using a callback. If the callback returns true, keep iterating, else abort\n  /// the iteration.\n  void ForEachEnumerator(\n      std::function<bool(const CompilerType &integer_type, ConstString name,\n                         const llvm::APSInt &value)> const &callback) const;\n\n  uint32_t GetNumFields() const;\n\n  CompilerType GetFieldAtIndex(size_t idx, std::string &name,\n                               uint64_t *bit_offset_ptr,\n                               uint32_t *bitfield_bit_size_ptr,\n                               bool *is_bitfield_ptr) const;\n\n  uint32_t GetNumDirectBaseClasses() const;\n\n  uint32_t GetNumVirtualBaseClasses() const;\n\n  CompilerType GetDirectBaseClassAtIndex(size_t idx,\n                                         uint32_t *bit_offset_ptr) const;\n\n  CompilerType GetVirtualBaseClassAtIndex(size_t idx,\n                                          uint32_t *bit_offset_ptr) const;\n\n  uint32_t GetIndexOfFieldWithName(const char *name,\n                                   CompilerType *field_compiler_type = nullptr,\n                                   uint64_t *bit_offset_ptr = nullptr,\n                                   uint32_t *bitfield_bit_size_ptr = nullptr,\n                                   bool *is_bitfield_ptr = nullptr) const;\n\n  CompilerType GetChildCompilerTypeAtIndex(\n      ExecutionContext *exe_ctx, size_t idx, bool transparent_pointers,\n      bool omit_empty_base_classes, bool ignore_array_bounds,\n      std::string &child_name, uint32_t &child_byte_size,\n      int32_t &child_byte_offset, uint32_t &child_bitfield_bit_size,\n      uint32_t &child_bitfield_bit_offset, bool &child_is_base_class,\n      bool &child_is_deref_of_parent, ValueObject *valobj,\n      uint64_t &language_flags) const;\n\n  /// Lookup a child given a name. This function will match base class names and\n  /// member member names in \"clang_type\" only, not descendants.\n  uint32_t GetIndexOfChildWithName(const char *name,\n                                   bool omit_empty_base_classes) const;\n\n  /// Lookup a child member given a name. This function will match member names\n  /// only and will descend into \"clang_type\" children in search for the first\n  /// member in this class, or any base class that matches \"name\".\n  /// TODO: Return all matches for a given name by returning a\n  /// vector<vector<uint32_t>>\n  /// so we catch all names that match a given child name, not just the first.\n  size_t\n  GetIndexOfChildMemberWithName(const char *name, bool omit_empty_base_classes,\n                                std::vector<uint32_t> &child_indexes) const;\n\n  size_t GetNumTemplateArguments() const;\n\n  lldb::TemplateArgumentKind GetTemplateArgumentKind(size_t idx) const;\n  CompilerType GetTypeTemplateArgument(size_t idx) const;\n\n  /// Returns the value of the template argument and its type.\n  llvm::Optional<IntegralTemplateArgument>\n  GetIntegralTemplateArgument(size_t idx) const;\n\n  CompilerType GetTypeForFormatters() const;\n\n  LazyBool ShouldPrintAsOneLiner(ValueObject *valobj) const;\n\n  bool IsMeaninglessWithoutDynamicResolution() const;\n  /// \\}\n\n  /// Dumping types.\n  /// \\{\n#ifndef NDEBUG\n  /// Convenience LLVM-style dump method for use in the debugger only.\n  /// Don't call this function from actual code.\n  LLVM_DUMP_METHOD void dump() const;\n#endif\n\n  void DumpValue(ExecutionContext *exe_ctx, Stream *s, lldb::Format format,\n                 const DataExtractor &data, lldb::offset_t data_offset,\n                 size_t data_byte_size, uint32_t bitfield_bit_size,\n                 uint32_t bitfield_bit_offset, bool show_types,\n                 bool show_summary, bool verbose, uint32_t depth);\n\n  bool DumpTypeValue(Stream *s, lldb::Format format, const DataExtractor &data,\n                     lldb::offset_t data_offset, size_t data_byte_size,\n                     uint32_t bitfield_bit_size, uint32_t bitfield_bit_offset,\n                     ExecutionContextScope *exe_scope);\n\n  void DumpSummary(ExecutionContext *exe_ctx, Stream *s,\n                   const DataExtractor &data, lldb::offset_t data_offset,\n                   size_t data_byte_size);\n\n  /// Dump to stdout.\n  void DumpTypeDescription(lldb::DescriptionLevel level =\n                           lldb::eDescriptionLevelFull) const;\n\n  /// Print a description of the type to a stream. The exact implementation\n  /// varies, but the expectation is that eDescriptionLevelFull returns a\n  /// source-like representation of the type, whereas eDescriptionLevelVerbose\n  /// does a dump of the underlying AST if applicable.\n  void DumpTypeDescription(Stream *s, lldb::DescriptionLevel level =\n                                          lldb::eDescriptionLevelFull) const;\n  /// \\}\n\n  bool GetValueAsScalar(const DataExtractor &data, lldb::offset_t data_offset,\n                        size_t data_byte_size, Scalar &value,\n                        ExecutionContextScope *exe_scope) const;\n  void Clear() {\n    m_type = nullptr;\n    m_type_system = nullptr;\n  }\n\nprivate:\n#ifndef NDEBUG\n  /// If the type is valid, ask the TypeSystem to verify the integrity\n  /// of the type to catch CompilerTypes that mix and match invalid\n  /// TypeSystem/Opaque type pairs.\n  bool Verify() const;\n#endif\n\n  lldb::opaque_compiler_type_t m_type = nullptr;\n  TypeSystem *m_type_system = nullptr;\n};\n\nbool operator==(const CompilerType &lhs, const CompilerType &rhs);\nbool operator!=(const CompilerType &lhs, const CompilerType &rhs);\n\nstruct CompilerType::IntegralTemplateArgument {\n  llvm::APSInt value;\n  CompilerType type;\n};\n\n} // namespace lldb_private\n\n#endif // LLDB_SYMBOL_COMPILERTYPE_H\n"}, "21": {"id": 21, "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Symbol/Declaration.h", "content": "//===-- Declaration.h -------------------------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLDB_SYMBOL_DECLARATION_H\n#define LLDB_SYMBOL_DECLARATION_H\n\n#include \"lldb/Utility/FileSpec.h\"\n#include \"lldb/lldb-private.h\"\n\nnamespace lldb_private {\n\n/// \\class Declaration Declaration.h \"lldb/Symbol/Declaration.h\"\n/// A class that describes the declaration location of a\n///        lldb object.\n///\n/// The declarations include the file specification, line number, and the\n/// column info and can help track where functions, blocks, inlined functions,\n/// types, variables, any many other debug core objects were declared.\nclass Declaration {\npublic:\n  /// Default constructor.\n  Declaration()\n      : m_file(), m_line(0)\n#ifdef LLDB_ENABLE_DECLARATION_COLUMNS\n        ,\n        m_column(0)\n#endif\n  {\n  }\n\n  /// Construct with file specification, and optional line and column.\n  ///\n  /// \\param[in] file_spec\n  ///     The file specification that describes where this was\n  ///     declared.\n  ///\n  /// \\param[in] line\n  ///     The line number that describes where this was declared. Set\n  ///     to zero if there is no line number information.\n  ///\n  /// \\param[in] column\n  ///     The column number that describes where this was declared.\n  ///     Set to zero if there is no column number information.\n  Declaration(const FileSpec &file_spec, uint32_t line = 0, uint32_t column = 0)\n      : m_file(file_spec), m_line(line)\n#ifdef LLDB_ENABLE_DECLARATION_COLUMNS\n        ,\n        m_column(column)\n#endif\n  {\n  }\n\n  /// Construct with a pointer to another Declaration object.\n  Declaration(const Declaration *decl_ptr)\n      : m_file(), m_line(0)\n#ifdef LLDB_ENABLE_DECLARATION_COLUMNS\n        ,\n        m_column(0)\n#endif\n  {\n    if (decl_ptr)\n      *this = *decl_ptr;\n  }\n\n  /// Clear the object's state.\n  ///\n  /// Sets the file specification to be empty, and the line and column to\n  /// zero.\n  void Clear() {\n    m_file.Clear();\n    m_line = 0;\n#ifdef LLDB_ENABLE_DECLARATION_COLUMNS\n    m_column = 0;\n#endif\n  }\n\n  /// Compare two declaration objects.\n  ///\n  /// Compares the two file specifications from \\a lhs and \\a rhs. If the file\n  /// specifications are equal, then continue to compare the line number and\n  /// column numbers respectively.\n  ///\n  /// \\param[in] lhs\n  ///     The Left Hand Side const Declaration object reference.\n  ///\n  /// \\param[in] rhs\n  ///     The Right Hand Side const Declaration object reference.\n  ///\n  /// \\return\n  ///     -1 if lhs < rhs\n  ///     0 if lhs == rhs\n  ///     1 if lhs > rhs\n  static int Compare(const Declaration &lhs, const Declaration &rhs);\n\n  /// Checks if this object has the same file and line as another declaration\n  /// object.\n  ///\n  /// \\param[in] declaration\n  ///     The const Declaration object to compare with.\n  ///\n  /// \\return\n  ///     Returns \\b true if \\b declaration is at the same file and\n  ///     line, \\b false otherwise.\n  bool FileAndLineEqual(const Declaration &declaration) const;\n\n  /// Dump a description of this object to a Stream.\n  ///\n  /// Dump a description of the contents of this object to the supplied stream\n  /// \\a s.\n  ///\n  /// \\param[in] s\n  ///     The stream to which to dump the object description.\n  void Dump(Stream *s, bool show_fullpaths) const;\n\n  bool DumpStopContext(Stream *s, bool show_fullpaths) const;\n  /// Get accessor for the declaration column number.\n  ///\n  /// \\return\n  ///     Non-zero indicates a valid column number, zero indicates no\n  ///     column information is available.\n  uint32_t GetColumn() const {\n#ifdef LLDB_ENABLE_DECLARATION_COLUMNS\n    return m_column;\n#else\n    return 0;\n#endif\n  }\n\n  /// Get accessor for file specification.\n  ///\n  /// \\return\n  ///     A reference to the file specification object.\n  FileSpec &GetFile() { return m_file; }\n\n  /// Get const accessor for file specification.\n  ///\n  /// \\return\n  ///     A const reference to the file specification object.\n  const FileSpec &GetFile() const { return m_file; }\n\n  /// Get accessor for the declaration line number.\n  ///\n  /// \\return\n  ///     Non-zero indicates a valid line number, zero indicates no\n  ///     line information is available.\n  uint32_t GetLine() const { return m_line; }\n\n  bool IsValid() const { return m_file && m_line != 0; }\n\n  /// Get the memory cost of this object.\n  ///\n  /// \\return\n  ///     The number of bytes that this object occupies in memory.\n  ///     The returned value does not include the bytes for any\n  ///     shared string values.\n  ///\n  /// \\see ConstString::StaticMemorySize ()\n  size_t MemorySize() const;\n\n  /// Set accessor for the declaration column number.\n  ///\n  /// \\param[in] column\n  ///     Non-zero indicates a valid column number, zero indicates no\n  ///     column information is available.\n  void SetColumn(uint32_t column) {\n#ifdef LLDB_ENABLE_DECLARATION_COLUMNS\n    m_column = col;\n#endif\n  }\n\n  /// Set accessor for the declaration file specification.\n  ///\n  /// \\param[in] file_spec\n  ///     The new declaration file specification.\n  void SetFile(const FileSpec &file_spec) { m_file = file_spec; }\n\n  /// Set accessor for the declaration line number.\n  ///\n  /// \\param[in] line\n  ///     Non-zero indicates a valid line number, zero indicates no\n  ///     line information is available.\n  void SetLine(uint32_t line) { m_line = line; }\n\nprotected:\n  /// Member variables.\n  FileSpec m_file; ///< The file specification that points to the\n                   ///< source file where the declaration occurred.\n  uint32_t m_line; ///< Non-zero values indicates a valid line number,\n                   ///< zero indicates no line number information is available.\n#ifdef LLDB_ENABLE_DECLARATION_COLUMNS\n  uint32_t m_column; ///< Non-zero values indicates a valid column number,\n                     ///< zero indicates no column information is available.\n#endif\n};\n\nbool operator==(const Declaration &lhs, const Declaration &rhs);\n\n} // namespace lldb_private\n\n#endif // LLDB_SYMBOL_DECLARATION_H\n"}, "22": {"id": 22, "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Symbol/LineEntry.h", "content": "//===-- LineEntry.h ---------------------------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLDB_SYMBOL_LINEENTRY_H\n#define LLDB_SYMBOL_LINEENTRY_H\n\n#include \"lldb/Core/AddressRange.h\"\n#include \"lldb/Utility/FileSpec.h\"\n#include \"lldb/lldb-private.h\"\n\nnamespace lldb_private {\n\n/// \\class LineEntry LineEntry.h \"lldb/Symbol/LineEntry.h\"\n/// A line table entry class.\nstruct LineEntry {\n  /// Default constructor.\n  ///\n  /// Initialize all member variables to invalid values.\n  LineEntry();\n\n  LineEntry(const lldb::SectionSP &section_sp, lldb::addr_t section_offset,\n            lldb::addr_t byte_size, const FileSpec &file, uint32_t _line,\n            uint16_t _column, bool _is_start_of_statement,\n            bool _is_start_of_basic_block, bool _is_prologue_end,\n            bool _is_epilogue_begin, bool _is_terminal_entry);\n\n  /// Clear the object's state.\n  ///\n  /// Clears all member variables to invalid values.\n  void Clear();\n\n  /// Dump a description of this object to a Stream.\n  ///\n  /// Dump a description of the contents of this object to the supplied stream\n  /// \\a s.\n  ///\n  /// \\param[in] s\n  ///     The stream to which to dump the object description.\n  ///\n  /// \\param[in] show_file\n  ///     If \\b true, display the filename with the line entry which\n  ///     requires that the compile unit object \\a comp_unit be a\n  ///     valid pointer.\n  ///\n  /// \\param[in] style\n  ///     The display style for the section offset address.\n  ///\n  /// \\return\n  ///     Returns \\b true if the address was able to be displayed\n  ///     using \\a style. File and load addresses may be unresolved\n  ///     and it may not be possible to display a valid address value.\n  ///     Returns \\b false if the address was not able to be properly\n  ///     dumped.\n  ///\n  /// \\see Address::DumpStyle\n  bool Dump(Stream *s, Target *target, bool show_file, Address::DumpStyle style,\n            Address::DumpStyle fallback_style, bool show_range) const;\n\n  bool GetDescription(Stream *s, lldb::DescriptionLevel level, CompileUnit *cu,\n                      Target *target, bool show_address_only) const;\n\n  /// Dumps information specific to a process that stops at this line entry to\n  /// the supplied stream \\a s.\n  ///\n  /// \\param[in] s\n  ///     The stream to which to dump the object description.\n  ///\n  /// \\return\n  ///     Returns \\b true if the file and line were properly dumped,\n  ///     \\b false otherwise.\n  bool DumpStopContext(Stream *s, bool show_fullpaths) const;\n\n  /// Check if a line entry object is valid.\n  ///\n  /// \\return\n  ///     Returns \\b true if the line entry contains a valid section\n  ///     offset address, file index, and line number, \\b false\n  ///     otherwise.\n  bool IsValid() const;\n\n  /// Compare two LineEntry objects.\n  ///\n  /// \\param[in] lhs\n  ///     The Left Hand Side const LineEntry object reference.\n  ///\n  /// \\param[in] rhs\n  ///     The Right Hand Side const LineEntry object reference.\n  ///\n  /// \\return\n  ///     -1 if lhs < rhs\n  ///     0 if lhs == rhs\n  ///     1 if lhs > rhs\n  static int Compare(const LineEntry &lhs, const LineEntry &rhs);\n\n  /// Give the range for this LineEntry + any additional LineEntries for this\n  /// same source line that are contiguous.\n  ///\n  /// A compiler may emit multiple line entries for a single source line,\n  /// e.g. to indicate subexpressions at different columns.  This method will\n  /// get the AddressRange for all of the LineEntries for this source line\n  /// that are contiguous.\n  //\n  /// Line entries with a line number of 0 are treated specially - these are\n  /// compiler-generated line table entries that the user did not write in\n  /// their source code, and we want to skip past in the debugger. If this\n  /// LineEntry is for line 32, and the following LineEntry is for line 0, we\n  /// will extend the range to include the AddressRange of the line 0\n  /// LineEntry (and it will include the range of the following LineEntries\n  /// that match either 32 or 0.)\n  ///\n  /// When \\b include_inlined_functions is \\b true inlined functions with\n  /// a call site at this LineEntry will also be included in the complete\n  /// range.\n  ///\n  /// If the initial LineEntry this method is called on is a line #0, only the\n  /// range of continuous LineEntries with line #0 will be included in the\n  /// complete range.\n  ///\n  /// @param[in] include_inlined_functions\n  ///     Whether to include inlined functions at the same line or not.\n  ///\n  /// \\return\n  ///     The contiguous AddressRange for this source line.\n  AddressRange\n  GetSameLineContiguousAddressRange(bool include_inlined_functions) const;\n\n  /// Apply file mappings from target.source-map to the LineEntry's file.\n  ///\n  /// \\param[in] target_sp\n  ///     Shared pointer to the target this LineEntry belongs to.\n  void ApplyFileMappings(lldb::TargetSP target_sp);\n\n  // Member variables.\n  AddressRange range; ///< The section offset address range for this line entry.\n  FileSpec file; ///< The source file, possibly mapped by the target.source-map\n                 ///setting\n  FileSpec original_file; ///< The original source file, from debug info.\n  uint32_t line; ///< The source line number, or zero if there is no line number\n                 ///information.\n  uint16_t column; ///< The column number of the source line, or zero if there\n                   ///is no column information.\n  uint16_t is_start_of_statement : 1, ///< Indicates this entry is the beginning\n                                      ///of a statement.\n      is_start_of_basic_block : 1, ///< Indicates this entry is the beginning of\n                                   ///a basic block.\n      is_prologue_end : 1,   ///< Indicates this entry is one (of possibly many)\n                             ///where execution should be suspended for an entry\n                             ///breakpoint of a function.\n      is_epilogue_begin : 1, ///< Indicates this entry is one (of possibly many)\n                             ///where execution should be suspended for an exit\n                             ///breakpoint of a function.\n      is_terminal_entry : 1; ///< Indicates this entry is that of the first byte\n                             ///after the end of a sequence of target machine\n                             ///instructions.\n};\n\n/// Less than operator.\n///\n/// \\param[in] lhs\n///     The Left Hand Side const LineEntry object reference.\n///\n/// \\param[in] rhs\n///     The Right Hand Side const LineEntry object reference.\n///\n/// \\return\n///     Returns \\b true if lhs < rhs, false otherwise.\nbool operator<(const LineEntry &lhs, const LineEntry &rhs);\n\n} // namespace lldb_private\n\n#endif // LLDB_SYMBOL_LINEENTRY_H\n"}, "23": {"id": 23, "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Symbol/Symtab.h", "content": "//===-- Symtab.h ------------------------------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLDB_SYMBOL_SYMTAB_H\n#define LLDB_SYMBOL_SYMTAB_H\n\n#include \"lldb/Core/UniqueCStringMap.h\"\n#include \"lldb/Symbol/Symbol.h\"\n#include \"lldb/Utility/RangeMap.h\"\n#include \"lldb/lldb-private.h\"\n#include <mutex>\n#include <vector>\n\nnamespace lldb_private {\n\nclass Symtab {\npublic:\n  typedef std::vector<uint32_t> IndexCollection;\n  typedef UniqueCStringMap<uint32_t> NameToIndexMap;\n\n  enum Debug {\n    eDebugNo,  // Not a debug symbol\n    eDebugYes, // A debug symbol\n    eDebugAny\n  };\n\n  enum Visibility { eVisibilityAny, eVisibilityExtern, eVisibilityPrivate };\n\n  Symtab(ObjectFile *objfile);\n  ~Symtab();\n\n  void PreloadSymbols();\n  void Reserve(size_t count);\n  Symbol *Resize(size_t count);\n  uint32_t AddSymbol(const Symbol &symbol);\n  size_t GetNumSymbols() const;\n  void SectionFileAddressesChanged();\n  void\n  Dump(Stream *s, Target *target, SortOrder sort_type,\n       Mangled::NamePreference name_preference = Mangled::ePreferDemangled);\n  void Dump(Stream *s, Target *target, std::vector<uint32_t> &indexes,\n            Mangled::NamePreference name_preference =\n                Mangled::ePreferDemangled) const;\n  uint32_t GetIndexForSymbol(const Symbol *symbol) const;\n  std::recursive_mutex &GetMutex() { return m_mutex; }\n  Symbol *FindSymbolByID(lldb::user_id_t uid) const;\n  Symbol *SymbolAtIndex(size_t idx);\n  const Symbol *SymbolAtIndex(size_t idx) const;\n  Symbol *FindSymbolWithType(lldb::SymbolType symbol_type,\n                             Debug symbol_debug_type,\n                             Visibility symbol_visibility, uint32_t &start_idx);\n  /// Get the parent symbol for the given symbol.\n  ///\n  /// Many symbols in symbol tables are scoped by other symbols that\n  /// contain one or more symbol. This function will look for such a\n  /// containing symbol and return it if there is one.\n  const Symbol *GetParent(Symbol *symbol) const;\n  uint32_t AppendSymbolIndexesWithType(lldb::SymbolType symbol_type,\n                                       std::vector<uint32_t> &indexes,\n                                       uint32_t start_idx = 0,\n                                       uint32_t end_index = UINT32_MAX) const;\n  uint32_t AppendSymbolIndexesWithTypeAndFlagsValue(\n      lldb::SymbolType symbol_type, uint32_t flags_value,\n      std::vector<uint32_t> &indexes, uint32_t start_idx = 0,\n      uint32_t end_index = UINT32_MAX) const;\n  uint32_t AppendSymbolIndexesWithType(lldb::SymbolType symbol_type,\n                                       Debug symbol_debug_type,\n                                       Visibility symbol_visibility,\n                                       std::vector<uint32_t> &matches,\n                                       uint32_t start_idx = 0,\n                                       uint32_t end_index = UINT32_MAX) const;\n  uint32_t AppendSymbolIndexesWithName(ConstString symbol_name,\n                                       std::vector<uint32_t> &matches);\n  uint32_t AppendSymbolIndexesWithName(ConstString symbol_name,\n                                       Debug symbol_debug_type,\n                                       Visibility symbol_visibility,\n                                       std::vector<uint32_t> &matches);\n  uint32_t AppendSymbolIndexesWithNameAndType(ConstString symbol_name,\n                                              lldb::SymbolType symbol_type,\n                                              std::vector<uint32_t> &matches);\n  uint32_t AppendSymbolIndexesWithNameAndType(ConstString symbol_name,\n                                              lldb::SymbolType symbol_type,\n                                              Debug symbol_debug_type,\n                                              Visibility symbol_visibility,\n                                              std::vector<uint32_t> &matches);\n  uint32_t\n  AppendSymbolIndexesMatchingRegExAndType(const RegularExpression &regex,\n                                          lldb::SymbolType symbol_type,\n                                          std::vector<uint32_t> &indexes);\n  uint32_t AppendSymbolIndexesMatchingRegExAndType(\n      const RegularExpression &regex, lldb::SymbolType symbol_type,\n      Debug symbol_debug_type, Visibility symbol_visibility,\n      std::vector<uint32_t> &indexes);\n  void FindAllSymbolsWithNameAndType(ConstString name,\n                                     lldb::SymbolType symbol_type,\n                                     std::vector<uint32_t> &symbol_indexes);\n  void FindAllSymbolsWithNameAndType(ConstString name,\n                                     lldb::SymbolType symbol_type,\n                                     Debug symbol_debug_type,\n                                     Visibility symbol_visibility,\n                                     std::vector<uint32_t> &symbol_indexes);\n  void FindAllSymbolsMatchingRexExAndType(\n      const RegularExpression &regex, lldb::SymbolType symbol_type,\n      Debug symbol_debug_type, Visibility symbol_visibility,\n      std::vector<uint32_t> &symbol_indexes);\n  Symbol *FindFirstSymbolWithNameAndType(ConstString name,\n                                         lldb::SymbolType symbol_type,\n                                         Debug symbol_debug_type,\n                                         Visibility symbol_visibility);\n  Symbol *FindSymbolAtFileAddress(lldb::addr_t file_addr);\n  Symbol *FindSymbolContainingFileAddress(lldb::addr_t file_addr);\n  void ForEachSymbolContainingFileAddress(\n      lldb::addr_t file_addr, std::function<bool(Symbol *)> const &callback);\n  void FindFunctionSymbols(ConstString name, uint32_t name_type_mask,\n                           SymbolContextList &sc_list);\n  void CalculateSymbolSizes();\n\n  void SortSymbolIndexesByValue(std::vector<uint32_t> &indexes,\n                                bool remove_duplicates) const;\n\n  static void DumpSymbolHeader(Stream *s);\n\n  void Finalize() {\n    // Shrink to fit the symbols so we don't waste memory\n    if (m_symbols.capacity() > m_symbols.size()) {\n      collection new_symbols(m_symbols.begin(), m_symbols.end());\n      m_symbols.swap(new_symbols);\n    }\n  }\n\n  void AppendSymbolNamesToMap(const IndexCollection &indexes,\n                              bool add_demangled, bool add_mangled,\n                              NameToIndexMap &name_to_index_map) const;\n\n  ObjectFile *GetObjectFile() { return m_objfile; }\n\nprotected:\n  typedef std::vector<Symbol> collection;\n  typedef collection::iterator iterator;\n  typedef collection::const_iterator const_iterator;\n  class FileRangeToIndexMapCompare {\n  public:\n    FileRangeToIndexMapCompare(const Symtab &symtab) : m_symtab(symtab) {}\n    bool operator()(const uint32_t a_data, const uint32_t b_data) const {\n      return rank(a_data) > rank(b_data);\n    }\n\n  private:\n    // How much preferred is this symbol?\n    int rank(const uint32_t data) const {\n      const Symbol &symbol = *m_symtab.SymbolAtIndex(data);\n      if (symbol.IsExternal())\n        return 3;\n      if (symbol.IsWeak())\n        return 2;\n      if (symbol.IsDebug())\n        return 0;\n      return 1;\n    }\n    const Symtab &m_symtab;\n  };\n  typedef RangeDataVector<lldb::addr_t, lldb::addr_t, uint32_t, 0,\n                          FileRangeToIndexMapCompare>\n      FileRangeToIndexMap;\n  void InitNameIndexes();\n  void InitAddressIndexes();\n\n  ObjectFile *m_objfile;\n  collection m_symbols;\n  FileRangeToIndexMap m_file_addr_to_index;\n  UniqueCStringMap<uint32_t> m_name_to_index;\n  UniqueCStringMap<uint32_t> m_basename_to_index;\n  UniqueCStringMap<uint32_t> m_method_to_index;\n  UniqueCStringMap<uint32_t> m_selector_to_index;\n  mutable std::recursive_mutex\n      m_mutex; // Provide thread safety for this symbol table\n  bool m_file_addr_to_index_computed : 1, m_name_indexes_computed : 1;\n\nprivate:\n  bool CheckSymbolAtIndex(size_t idx, Debug symbol_debug_type,\n                          Visibility symbol_visibility) const {\n    switch (symbol_debug_type) {\n    case eDebugNo:\n      if (m_symbols[idx].IsDebug())\n        return false;\n      break;\n\n    case eDebugYes:\n      if (!m_symbols[idx].IsDebug())\n        return false;\n      break;\n\n    case eDebugAny:\n      break;\n    }\n\n    switch (symbol_visibility) {\n    case eVisibilityAny:\n      return true;\n\n    case eVisibilityExtern:\n      return m_symbols[idx].IsExternal();\n\n    case eVisibilityPrivate:\n      return !m_symbols[idx].IsExternal();\n    }\n    return false;\n  }\n\n  void SymbolIndicesToSymbolContextList(std::vector<uint32_t> &symbol_indexes,\n                                        SymbolContextList &sc_list);\n\n  void RegisterMangledNameEntry(\n      uint32_t value, std::set<const char *> &class_contexts,\n      std::vector<std::pair<NameToIndexMap::Entry, const char *>> &backlog,\n      RichManglingContext &rmc);\n\n  void RegisterBacklogEntry(const NameToIndexMap::Entry &entry,\n                            const char *decl_context,\n                            const std::set<const char *> &class_contexts);\n\n  Symtab(const Symtab &) = delete;\n  const Symtab &operator=(const Symtab &) = delete;\n};\n\n} // namespace lldb_private\n\n#endif // LLDB_SYMBOL_SYMTAB_H\n"}, "24": {"id": 24, "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Symbol/Type.h", "content": "//===-- Type.h --------------------------------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLDB_SYMBOL_TYPE_H\n#define LLDB_SYMBOL_TYPE_H\n\n#include \"lldb/Symbol/CompilerDecl.h\"\n#include \"lldb/Symbol/CompilerType.h\"\n#include \"lldb/Symbol/Declaration.h\"\n#include \"lldb/Utility/ConstString.h\"\n#include \"lldb/Utility/UserID.h\"\n#include \"lldb/lldb-private.h\"\n\n#include \"llvm/ADT/APSInt.h\"\n\n#include <set>\n\nnamespace lldb_private {\n\n/// CompilerContext allows an array of these items to be passed to perform\n/// detailed lookups in SymbolVendor and SymbolFile functions.\nstruct CompilerContext {\n  CompilerContext(CompilerContextKind t, ConstString n) : kind(t), name(n) {}\n\n  bool operator==(const CompilerContext &rhs) const {\n    return kind == rhs.kind && name == rhs.name;\n  }\n  bool operator!=(const CompilerContext &rhs) const { return !(*this == rhs); }\n\n  void Dump() const;\n\n  CompilerContextKind kind;\n  ConstString name;\n};\n\n/// Match \\p context_chain against \\p pattern, which may contain \"Any\"\n/// kinds. The \\p context_chain should *not* contain any \"Any\" kinds.\nbool contextMatches(llvm::ArrayRef<CompilerContext> context_chain,\n                    llvm::ArrayRef<CompilerContext> pattern);\n\nclass SymbolFileType : public std::enable_shared_from_this<SymbolFileType>,\n                       public UserID {\npublic:\n  SymbolFileType(SymbolFile &symbol_file, lldb::user_id_t uid)\n      : UserID(uid), m_symbol_file(symbol_file) {}\n\n  SymbolFileType(SymbolFile &symbol_file, const lldb::TypeSP &type_sp);\n\n  ~SymbolFileType() {}\n\n  Type *operator->() { return GetType(); }\n\n  Type *GetType();\n  SymbolFile &GetSymbolFile() const { return m_symbol_file; }\n\nprotected:\n  SymbolFile &m_symbol_file;\n  lldb::TypeSP m_type_sp;\n};\n\nclass Type : public std::enable_shared_from_this<Type>, public UserID {\npublic:\n  enum EncodingDataType {\n    eEncodingInvalid,\n    eEncodingIsUID,      ///< This type is the type whose UID is m_encoding_uid\n    eEncodingIsConstUID, ///< This type is the type whose UID is m_encoding_uid\n                         /// with the const qualifier added\n    eEncodingIsRestrictUID, ///< This type is the type whose UID is\n                            /// m_encoding_uid with the restrict qualifier added\n    eEncodingIsVolatileUID, ///< This type is the type whose UID is\n                            /// m_encoding_uid with the volatile qualifier added\n    eEncodingIsTypedefUID,  ///< This type is pointer to a type whose UID is\n                            /// m_encoding_uid\n    eEncodingIsPointerUID,  ///< This type is pointer to a type whose UID is\n                            /// m_encoding_uid\n    eEncodingIsLValueReferenceUID, ///< This type is L value reference to a type\n                                   /// whose UID is m_encoding_uid\n    eEncodingIsRValueReferenceUID, ///< This type is R value reference to a type\n                                   /// whose UID is m_encoding_uid,\n    eEncodingIsAtomicUID,          ///< This type is the type whose UID is\n                                   /// m_encoding_uid as an atomic type.\n    eEncodingIsSyntheticUID\n  };\n\n  enum class ResolveState : unsigned char {\n    Unresolved = 0,\n    Forward = 1,\n    Layout = 2,\n    Full = 3\n  };\n\n  Type(lldb::user_id_t uid, SymbolFile *symbol_file, ConstString name,\n       llvm::Optional<uint64_t> byte_size, SymbolContextScope *context,\n       lldb::user_id_t encoding_uid, EncodingDataType encoding_uid_type,\n       const Declaration &decl, const CompilerType &compiler_qual_type,\n       ResolveState compiler_type_resolve_state, uint32_t opaque_payload = 0);\n\n  // This makes an invalid type.  Used for functions that return a Type when\n  // they get an error.\n  Type();\n\n  void Dump(Stream *s, bool show_context,\n            lldb::DescriptionLevel level = lldb::eDescriptionLevelFull);\n\n  void DumpTypeName(Stream *s);\n\n  /// Since Type instances only keep a \"SymbolFile *\" internally, other classes\n  /// like TypeImpl need make sure the module is still around before playing\n  /// with\n  /// Type instances. They can store a weak pointer to the Module;\n  lldb::ModuleSP GetModule();\n\n  /// GetModule may return module for compile unit's object file.\n  /// GetExeModule returns module for executable object file that contains\n  /// compile unit where type was actualy defined.\n  /// GetModule and GetExeModule may return the same value.\n  lldb::ModuleSP GetExeModule();\n\n  void GetDescription(Stream *s, lldb::DescriptionLevel level, bool show_name,\n                      ExecutionContextScope *exe_scope);\n\n  SymbolFile *GetSymbolFile() { return m_symbol_file; }\n  const SymbolFile *GetSymbolFile() const { return m_symbol_file; }\n\n  ConstString GetName();\n\n  llvm::Optional<uint64_t> GetByteSize(ExecutionContextScope *exe_scope);\n\n  uint32_t GetNumChildren(bool omit_empty_base_classes);\n\n  bool IsAggregateType();\n\n  bool IsValidType() { return m_encoding_uid_type != eEncodingInvalid; }\n\n  bool IsTypedef() { return m_encoding_uid_type == eEncodingIsTypedefUID; }\n\n  lldb::TypeSP GetTypedefType();\n\n  ConstString GetName() const { return m_name; }\n\n  ConstString GetQualifiedName();\n\n  void DumpValue(ExecutionContext *exe_ctx, Stream *s,\n                 const DataExtractor &data, uint32_t data_offset,\n                 bool show_type, bool show_summary, bool verbose,\n                 lldb::Format format = lldb::eFormatDefault);\n\n  bool DumpValueInMemory(ExecutionContext *exe_ctx, Stream *s,\n                         lldb::addr_t address, AddressType address_type,\n                         bool show_types, bool show_summary, bool verbose);\n\n  bool ReadFromMemory(ExecutionContext *exe_ctx, lldb::addr_t address,\n                      AddressType address_type, DataExtractor &data);\n\n  bool WriteToMemory(ExecutionContext *exe_ctx, lldb::addr_t address,\n                     AddressType address_type, DataExtractor &data);\n\n  bool GetIsDeclaration() const;\n\n  void SetIsDeclaration(bool b);\n\n  bool GetIsExternal() const;\n\n  void SetIsExternal(bool b);\n\n  lldb::Format GetFormat();\n\n  lldb::Encoding GetEncoding(uint64_t &count);\n\n  SymbolContextScope *GetSymbolContextScope() { return m_context; }\n  const SymbolContextScope *GetSymbolContextScope() const { return m_context; }\n  void SetSymbolContextScope(SymbolContextScope *context) {\n    m_context = context;\n  }\n\n  const lldb_private::Declaration &GetDeclaration() const;\n\n  // Get the clang type, and resolve definitions for any\n  // class/struct/union/enum types completely.\n  CompilerType GetFullCompilerType();\n\n  // Get the clang type, and resolve definitions enough so that the type could\n  // have layout performed. This allows ptrs and refs to\n  // class/struct/union/enum types remain forward declarations.\n  CompilerType GetLayoutCompilerType();\n\n  // Get the clang type and leave class/struct/union/enum types as forward\n  // declarations if they haven't already been fully defined.\n  CompilerType GetForwardCompilerType();\n\n  static int Compare(const Type &a, const Type &b);\n\n  // From a fully qualified typename, split the type into the type basename and\n  // the remaining type scope (namespaces/classes).\n  static bool GetTypeScopeAndBasename(const llvm::StringRef& name,\n                                      llvm::StringRef &scope,\n                                      llvm::StringRef &basename,\n                                      lldb::TypeClass &type_class);\n  void SetEncodingType(Type *encoding_type) { m_encoding_type = encoding_type; }\n\n  uint32_t GetEncodingMask();\n\n  typedef uint32_t Payload;\n  /// Return the language-specific payload.\n  Payload GetPayload() { return m_payload; }\n  /// Return the language-specific payload.\n  void SetPayload(Payload opaque_payload) { m_payload = opaque_payload; }\n\nprotected:\n  ConstString m_name;\n  SymbolFile *m_symbol_file;\n  /// The symbol context in which this type is defined.\n  SymbolContextScope *m_context;\n  Type *m_encoding_type;\n  lldb::user_id_t m_encoding_uid;\n  EncodingDataType m_encoding_uid_type;\n  uint64_t m_byte_size : 63;\n  uint64_t m_byte_size_has_value : 1;\n  Declaration m_decl;\n  CompilerType m_compiler_type;\n  ResolveState m_compiler_type_resolve_state;\n  /// Language-specific flags.\n  Payload m_payload;\n\n  Type *GetEncodingType();\n\n  bool ResolveCompilerType(ResolveState compiler_type_resolve_state);\n};\n\n// the two classes here are used by the public API as a backend to the SBType\n// and SBTypeList classes\n\nclass TypeImpl {\npublic:\n  TypeImpl() = default;\n\n  ~TypeImpl() {}\n\n  TypeImpl(const lldb::TypeSP &type_sp);\n\n  TypeImpl(const CompilerType &compiler_type);\n\n  TypeImpl(const lldb::TypeSP &type_sp, const CompilerType &dynamic);\n\n  TypeImpl(const CompilerType &compiler_type, const CompilerType &dynamic);\n\n  void SetType(const lldb::TypeSP &type_sp);\n\n  void SetType(const CompilerType &compiler_type);\n\n  void SetType(const lldb::TypeSP &type_sp, const CompilerType &dynamic);\n\n  void SetType(const CompilerType &compiler_type, const CompilerType &dynamic);\n\n  bool operator==(const TypeImpl &rhs) const;\n\n  bool operator!=(const TypeImpl &rhs) const;\n\n  bool IsValid() const;\n\n  explicit operator bool() const;\n\n  void Clear();\n\n  lldb::ModuleSP GetModule() const;\n\n  ConstString GetName() const;\n\n  ConstString GetDisplayTypeName() const;\n\n  TypeImpl GetPointerType() const;\n\n  TypeImpl GetPointeeType() const;\n\n  TypeImpl GetReferenceType() const;\n\n  TypeImpl GetTypedefedType() const;\n\n  TypeImpl GetDereferencedType() const;\n\n  TypeImpl GetUnqualifiedType() const;\n\n  TypeImpl GetCanonicalType() const;\n\n  CompilerType GetCompilerType(bool prefer_dynamic);\n\n  TypeSystem *GetTypeSystem(bool prefer_dynamic);\n\n  bool GetDescription(lldb_private::Stream &strm,\n                      lldb::DescriptionLevel description_level);\n\nprivate:\n  bool CheckModule(lldb::ModuleSP &module_sp) const;\n  bool CheckExeModule(lldb::ModuleSP &module_sp) const;\n  bool CheckModuleCommon(const lldb::ModuleWP &input_module_wp,\n                         lldb::ModuleSP &module_sp) const;\n\n  lldb::ModuleWP m_module_wp;\n  lldb::ModuleWP m_exe_module_wp;\n  CompilerType m_static_type;\n  CompilerType m_dynamic_type;\n};\n\nclass TypeListImpl {\npublic:\n  TypeListImpl() : m_content() {}\n\n  void Append(const lldb::TypeImplSP &type) { m_content.push_back(type); }\n\n  class AppendVisitor {\n  public:\n    AppendVisitor(TypeListImpl &type_list) : m_type_list(type_list) {}\n\n    void operator()(const lldb::TypeImplSP &type) { m_type_list.Append(type); }\n\n  private:\n    TypeListImpl &m_type_list;\n  };\n\n  void Append(const lldb_private::TypeList &type_list);\n\n  lldb::TypeImplSP GetTypeAtIndex(size_t idx) {\n    lldb::TypeImplSP type_sp;\n    if (idx < GetSize())\n      type_sp = m_content[idx];\n    return type_sp;\n  }\n\n  size_t GetSize() { return m_content.size(); }\n\nprivate:\n  std::vector<lldb::TypeImplSP> m_content;\n};\n\nclass TypeMemberImpl {\npublic:\n  TypeMemberImpl()\n      : m_type_impl_sp(), m_bit_offset(0), m_name(), m_bitfield_bit_size(0),\n        m_is_bitfield(false)\n\n  {}\n\n  TypeMemberImpl(const lldb::TypeImplSP &type_impl_sp, uint64_t bit_offset,\n                 ConstString name, uint32_t bitfield_bit_size = 0,\n                 bool is_bitfield = false)\n      : m_type_impl_sp(type_impl_sp), m_bit_offset(bit_offset), m_name(name),\n        m_bitfield_bit_size(bitfield_bit_size), m_is_bitfield(is_bitfield) {}\n\n  TypeMemberImpl(const lldb::TypeImplSP &type_impl_sp, uint64_t bit_offset)\n      : m_type_impl_sp(type_impl_sp), m_bit_offset(bit_offset), m_name(),\n        m_bitfield_bit_size(0), m_is_bitfield(false) {\n    if (m_type_impl_sp)\n      m_name = m_type_impl_sp->GetName();\n  }\n\n  const lldb::TypeImplSP &GetTypeImpl() { return m_type_impl_sp; }\n\n  ConstString GetName() const { return m_name; }\n\n  uint64_t GetBitOffset() const { return m_bit_offset; }\n\n  uint32_t GetBitfieldBitSize() const { return m_bitfield_bit_size; }\n\n  void SetBitfieldBitSize(uint32_t bitfield_bit_size) {\n    m_bitfield_bit_size = bitfield_bit_size;\n  }\n\n  bool GetIsBitfield() const { return m_is_bitfield; }\n\n  void SetIsBitfield(bool is_bitfield) { m_is_bitfield = is_bitfield; }\n\nprotected:\n  lldb::TypeImplSP m_type_impl_sp;\n  uint64_t m_bit_offset;\n  ConstString m_name;\n  uint32_t m_bitfield_bit_size; // Bit size for bitfield members only\n  bool m_is_bitfield;\n};\n\n///\n/// Sometimes you can find the name of the type corresponding to an object, but\n/// we don't have debug\n/// information for it.  If that is the case, you can return one of these\n/// objects, and then if it\n/// has a full type, you can use that, but if not at least you can print the\n/// name for informational\n/// purposes.\n///\n\nclass TypeAndOrName {\npublic:\n  TypeAndOrName() = default;\n  TypeAndOrName(lldb::TypeSP &type_sp);\n  TypeAndOrName(const CompilerType &compiler_type);\n  TypeAndOrName(const char *type_str);\n  TypeAndOrName(ConstString &type_const_string);\n\n  bool operator==(const TypeAndOrName &other) const;\n\n  bool operator!=(const TypeAndOrName &other) const;\n\n  ConstString GetName() const;\n\n  CompilerType GetCompilerType() const { return m_compiler_type; }\n\n  void SetName(ConstString type_name);\n\n  void SetName(const char *type_name_cstr);\n\n  void SetTypeSP(lldb::TypeSP type_sp);\n\n  void SetCompilerType(CompilerType compiler_type);\n\n  bool IsEmpty() const;\n\n  bool HasName() const;\n\n  bool HasCompilerType() const;\n\n  bool HasType() const { return HasCompilerType(); }\n\n  void Clear();\n\n  explicit operator bool() { return !IsEmpty(); }\n\nprivate:\n  CompilerType m_compiler_type;\n  ConstString m_type_name;\n};\n\nclass TypeMemberFunctionImpl {\npublic:\n  TypeMemberFunctionImpl()\n      : m_type(), m_decl(), m_name(), m_kind(lldb::eMemberFunctionKindUnknown) {\n  }\n\n  TypeMemberFunctionImpl(const CompilerType &type, const CompilerDecl &decl,\n                         const std::string &name,\n                         const lldb::MemberFunctionKind &kind)\n      : m_type(type), m_decl(decl), m_name(name), m_kind(kind) {}\n\n  bool IsValid();\n\n  ConstString GetName() const;\n\n  ConstString GetMangledName() const;\n\n  CompilerType GetType() const;\n\n  CompilerType GetReturnType() const;\n\n  size_t GetNumArguments() const;\n\n  CompilerType GetArgumentAtIndex(size_t idx) const;\n\n  lldb::MemberFunctionKind GetKind() const;\n\n  bool GetDescription(Stream &stream);\n\nprotected:\n  std::string GetPrintableTypeName();\n\nprivate:\n  CompilerType m_type;\n  CompilerDecl m_decl;\n  ConstString m_name;\n  lldb::MemberFunctionKind m_kind;\n};\n\nclass TypeEnumMemberImpl {\npublic:\n  TypeEnumMemberImpl()\n      : m_integer_type_sp(), m_name(\"<invalid>\"), m_value(), m_valid(false) {}\n\n  TypeEnumMemberImpl(const lldb::TypeImplSP &integer_type_sp,\n                     ConstString name, const llvm::APSInt &value);\n\n  TypeEnumMemberImpl(const TypeEnumMemberImpl &rhs) = default;\n\n  TypeEnumMemberImpl &operator=(const TypeEnumMemberImpl &rhs);\n\n  bool IsValid() { return m_valid; }\n\n  ConstString GetName() const { return m_name; }\n\n  const lldb::TypeImplSP &GetIntegerType() const { return m_integer_type_sp; }\n\n  uint64_t GetValueAsUnsigned() const { return m_value.getZExtValue(); }\n\n  int64_t GetValueAsSigned() const { return m_value.getSExtValue(); }\n\nprotected:\n  lldb::TypeImplSP m_integer_type_sp;\n  ConstString m_name;\n  llvm::APSInt m_value;\n  bool m_valid;\n};\n\nclass TypeEnumMemberListImpl {\npublic:\n  TypeEnumMemberListImpl() : m_content() {}\n\n  void Append(const lldb::TypeEnumMemberImplSP &type) {\n    m_content.push_back(type);\n  }\n\n  void Append(const lldb_private::TypeEnumMemberListImpl &type_list);\n\n  lldb::TypeEnumMemberImplSP GetTypeEnumMemberAtIndex(size_t idx) {\n    lldb::TypeEnumMemberImplSP enum_member;\n    if (idx < GetSize())\n      enum_member = m_content[idx];\n    return enum_member;\n  }\n\n  size_t GetSize() { return m_content.size(); }\n\nprivate:\n  std::vector<lldb::TypeEnumMemberImplSP> m_content;\n};\n\n} // namespace lldb_private\n\n#endif // LLDB_SYMBOL_TYPE_H\n"}, "25": {"id": 25, "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Symbol/TypeSystem.h", "content": "//===-- TypeSystem.h ------------------------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLDB_SYMBOL_TYPESYSTEM_H\n#define LLDB_SYMBOL_TYPESYSTEM_H\n\n#include <functional>\n#include <map>\n#include <mutex>\n#include <string>\n\n#include \"llvm/ADT/APFloat.h\"\n#include \"llvm/ADT/APSInt.h\"\n#include \"llvm/ADT/SmallBitVector.h\"\n#include \"llvm/Support/Casting.h\"\n#include \"llvm/Support/Error.h\"\n\n#include \"lldb/Core/PluginInterface.h\"\n#include \"lldb/Expression/Expression.h\"\n#include \"lldb/Symbol/CompilerDecl.h\"\n#include \"lldb/Symbol/CompilerDeclContext.h\"\n#include \"lldb/lldb-private.h\"\n\nclass DWARFDIE;\nclass DWARFASTParser;\nclass PDBASTParser;\n\nnamespace lldb_private {\n\n/// A SmallBitVector that represents a set of source languages (\\p\n/// lldb::LanguageType).  Each lldb::LanguageType is represented by\n/// the bit with the position of its enumerator. The largest\n/// LanguageType is < 64, so this is space-efficient and on 64-bit\n/// architectures a LanguageSet can be completely stack-allocated.\nstruct LanguageSet {\n  llvm::SmallBitVector bitvector;\n  LanguageSet();\n\n  /// If the set contains a single language only, return it.\n  llvm::Optional<lldb::LanguageType> GetSingularLanguage();\n  void Insert(lldb::LanguageType language);\n  bool Empty() const;\n  size_t Size() const;\n  bool operator[](unsigned i) const;\n};\n\n/// Interface for representing a type system.\n///\n/// Implemented by language plugins to define the type system for a given\n/// language.\n///\n/// This interface extensively used opaque pointers to prevent that generic\n/// LLDB code has dependencies on language plugins. The type and semantics of\n/// these opaque pointers are defined by the TypeSystem implementation inside\n/// the respective language plugin. Opaque pointers from one TypeSystem\n/// instance should never be passed to a different TypeSystem instance (even\n/// when the language plugin for both TypeSystem instances is the same).\n///\n/// Most of the functions in this class should not be called directly but only\n/// called by their respective counterparts in CompilerType, CompilerDecl and\n/// CompilerDeclContext.\n///\n/// \\see lldb_private::CompilerType\n/// \\see lldb_private::CompilerDecl\n/// \\see lldb_private::CompilerDeclContext\nclass TypeSystem : public PluginInterface {\npublic:\n  // Constructors and Destructors\n  ~TypeSystem() override;\n\n  // LLVM RTTI support\n  virtual bool isA(const void *ClassID) const = 0;\n\n  static lldb::TypeSystemSP CreateInstance(lldb::LanguageType language,\n                                           Module *module);\n\n  static lldb::TypeSystemSP CreateInstance(lldb::LanguageType language,\n                                           Target *target);\n\n  // Free up any resources associated with this TypeSystem.  Done before\n  // removing all the TypeSystems from the TypeSystemMap.\n  virtual void Finalize() {}\n\n  virtual DWARFASTParser *GetDWARFParser() { return nullptr; }\n  virtual PDBASTParser *GetPDBParser() { return nullptr; }\n\n  virtual SymbolFile *GetSymbolFile() const { return m_sym_file; }\n\n  // Returns true if the symbol file changed during the set accessor.\n  virtual void SetSymbolFile(SymbolFile *sym_file) { m_sym_file = sym_file; }\n\n  // CompilerDecl functions\n  virtual ConstString DeclGetName(void *opaque_decl) = 0;\n\n  virtual ConstString DeclGetMangledName(void *opaque_decl);\n\n  virtual CompilerDeclContext DeclGetDeclContext(void *opaque_decl);\n\n  virtual CompilerType DeclGetFunctionReturnType(void *opaque_decl);\n\n  virtual size_t DeclGetFunctionNumArguments(void *opaque_decl);\n\n  virtual CompilerType DeclGetFunctionArgumentType(void *opaque_decl,\n                                                   size_t arg_idx);\n\n  virtual CompilerType GetTypeForDecl(void *opaque_decl) = 0;\n\n  // CompilerDeclContext functions\n\n  virtual std::vector<CompilerDecl>\n  DeclContextFindDeclByName(void *opaque_decl_ctx, ConstString name,\n                            const bool ignore_imported_decls);\n\n  virtual ConstString DeclContextGetName(void *opaque_decl_ctx) = 0;\n\n  virtual ConstString\n  DeclContextGetScopeQualifiedName(void *opaque_decl_ctx) = 0;\n\n  virtual bool DeclContextIsClassMethod(\n      void *opaque_decl_ctx, lldb::LanguageType *language_ptr,\n      bool *is_instance_method_ptr, ConstString *language_object_name_ptr) = 0;\n\n  virtual bool DeclContextIsContainedInLookup(void *opaque_decl_ctx,\n                                              void *other_opaque_decl_ctx) = 0;\n\n  // Tests\n#ifndef NDEBUG\n  /// Verify the integrity of the type to catch CompilerTypes that mix\n  /// and match invalid TypeSystem/Opaque type pairs.\n  virtual bool Verify(lldb::opaque_compiler_type_t type) = 0;\n#endif\n\n  virtual bool IsArrayType(lldb::opaque_compiler_type_t type,\n                           CompilerType *element_type, uint64_t *size,\n                           bool *is_incomplete) = 0;\n\n  virtual bool IsAggregateType(lldb::opaque_compiler_type_t type) = 0;\n\n  virtual bool IsAnonymousType(lldb::opaque_compiler_type_t type);\n\n  virtual bool IsCharType(lldb::opaque_compiler_type_t type) = 0;\n\n  virtual bool IsCompleteType(lldb::opaque_compiler_type_t type) = 0;\n\n  virtual bool IsDefined(lldb::opaque_compiler_type_t type) = 0;\n\n  virtual bool IsFloatingPointType(lldb::opaque_compiler_type_t type,\n                                   uint32_t &count, bool &is_complex) = 0;\n\n  virtual bool IsFunctionType(lldb::opaque_compiler_type_t type) = 0;\n\n  virtual size_t\n  GetNumberOfFunctionArguments(lldb::opaque_compiler_type_t type) = 0;\n\n  virtual CompilerType\n  GetFunctionArgumentAtIndex(lldb::opaque_compiler_type_t type,\n                             const size_t index) = 0;\n\n  virtual bool IsFunctionPointerType(lldb::opaque_compiler_type_t type) = 0;\n\n  virtual bool IsBlockPointerType(lldb::opaque_compiler_type_t type,\n                                  CompilerType *function_pointer_type_ptr) = 0;\n\n  virtual bool IsIntegerType(lldb::opaque_compiler_type_t type,\n                             bool &is_signed) = 0;\n\n  virtual bool IsEnumerationType(lldb::opaque_compiler_type_t type,\n                                 bool &is_signed) {\n    is_signed = false;\n    return false;\n  }\n\n  virtual bool IsScopedEnumerationType(lldb::opaque_compiler_type_t type) = 0;\n\n  virtual bool IsPossibleDynamicType(lldb::opaque_compiler_type_t type,\n                                     CompilerType *target_type, // Can pass NULL\n                                     bool check_cplusplus, bool check_objc) = 0;\n\n  virtual bool IsPointerType(lldb::opaque_compiler_type_t type,\n                             CompilerType *pointee_type) = 0;\n\n  virtual bool IsScalarType(lldb::opaque_compiler_type_t type) = 0;\n\n  virtual bool IsVoidType(lldb::opaque_compiler_type_t type) = 0;\n\n  virtual bool CanPassInRegisters(const CompilerType &type) = 0;\n\n  // TypeSystems can support more than one language\n  virtual bool SupportsLanguage(lldb::LanguageType language) = 0;\n\n  // Type Completion\n\n  virtual bool GetCompleteType(lldb::opaque_compiler_type_t type) = 0;\n\n  // AST related queries\n\n  virtual uint32_t GetPointerByteSize() = 0;\n\n  // Accessors\n\n  virtual ConstString GetTypeName(lldb::opaque_compiler_type_t type) = 0;\n\n  virtual ConstString GetDisplayTypeName(lldb::opaque_compiler_type_t type) = 0;\n\n  virtual uint32_t\n  GetTypeInfo(lldb::opaque_compiler_type_t type,\n              CompilerType *pointee_or_element_compiler_type) = 0;\n\n  virtual lldb::LanguageType\n  GetMinimumLanguage(lldb::opaque_compiler_type_t type) = 0;\n\n  virtual lldb::TypeClass GetTypeClass(lldb::opaque_compiler_type_t type) = 0;\n\n  // Creating related types\n\n  virtual CompilerType\n  GetArrayElementType(lldb::opaque_compiler_type_t type,\n                      ExecutionContextScope *exe_scope) = 0;\n\n  virtual CompilerType GetArrayType(lldb::opaque_compiler_type_t type,\n                                    uint64_t size);\n\n  virtual CompilerType GetCanonicalType(lldb::opaque_compiler_type_t type) = 0;\n\n  virtual CompilerType\n  GetEnumerationIntegerType(lldb::opaque_compiler_type_t type) = 0;\n\n  // Returns -1 if this isn't a function of if the function doesn't have a\n  // prototype Returns a value >= 0 if there is a prototype.\n  virtual int GetFunctionArgumentCount(lldb::opaque_compiler_type_t type) = 0;\n\n  virtual CompilerType\n  GetFunctionArgumentTypeAtIndex(lldb::opaque_compiler_type_t type,\n                                 size_t idx) = 0;\n\n  virtual CompilerType\n  GetFunctionReturnType(lldb::opaque_compiler_type_t type) = 0;\n\n  virtual size_t GetNumMemberFunctions(lldb::opaque_compiler_type_t type) = 0;\n\n  virtual TypeMemberFunctionImpl\n  GetMemberFunctionAtIndex(lldb::opaque_compiler_type_t type, size_t idx) = 0;\n\n  virtual CompilerType GetPointeeType(lldb::opaque_compiler_type_t type) = 0;\n\n  virtual CompilerType GetPointerType(lldb::opaque_compiler_type_t type) = 0;\n\n  virtual CompilerType\n  GetLValueReferenceType(lldb::opaque_compiler_type_t type);\n\n  virtual CompilerType\n  GetRValueReferenceType(lldb::opaque_compiler_type_t type);\n\n  virtual CompilerType GetAtomicType(lldb::opaque_compiler_type_t type);\n\n  virtual CompilerType AddConstModifier(lldb::opaque_compiler_type_t type);\n\n  virtual CompilerType AddVolatileModifier(lldb::opaque_compiler_type_t type);\n\n  virtual CompilerType AddRestrictModifier(lldb::opaque_compiler_type_t type);\n\n  /// \\param opaque_payload      The m_payload field of Type, which may\n  /// carry TypeSystem-specific extra information.\n  virtual CompilerType CreateTypedef(lldb::opaque_compiler_type_t type,\n                                     const char *name,\n                                     const CompilerDeclContext &decl_ctx,\n                                     uint32_t opaque_payload);\n\n  // Exploring the type\n\n  virtual const llvm::fltSemantics &GetFloatTypeSemantics(size_t byte_size) = 0;\n\n  virtual llvm::Optional<uint64_t>\n  GetBitSize(lldb::opaque_compiler_type_t type,\n             ExecutionContextScope *exe_scope) = 0;\n\n  virtual lldb::Encoding GetEncoding(lldb::opaque_compiler_type_t type,\n                                     uint64_t &count) = 0;\n\n  virtual lldb::Format GetFormat(lldb::opaque_compiler_type_t type) = 0;\n\n  virtual uint32_t GetNumChildren(lldb::opaque_compiler_type_t type,\n                                  bool omit_empty_base_classes,\n                                  const ExecutionContext *exe_ctx) = 0;\n\n  virtual CompilerType GetBuiltinTypeByName(ConstString name);\n\n  virtual lldb::BasicType\n  GetBasicTypeEnumeration(lldb::opaque_compiler_type_t type) = 0;\n\n  virtual void ForEachEnumerator(\n      lldb::opaque_compiler_type_t type,\n      std::function<bool(const CompilerType &integer_type,\n                         ConstString name,\n                         const llvm::APSInt &value)> const &callback) {}\n\n  virtual uint32_t GetNumFields(lldb::opaque_compiler_type_t type) = 0;\n\n  virtual CompilerType GetFieldAtIndex(lldb::opaque_compiler_type_t type,\n                                       size_t idx, std::string &name,\n                                       uint64_t *bit_offset_ptr,\n                                       uint32_t *bitfield_bit_size_ptr,\n                                       bool *is_bitfield_ptr) = 0;\n\n  virtual uint32_t\n  GetNumDirectBaseClasses(lldb::opaque_compiler_type_t type) = 0;\n\n  virtual uint32_t\n  GetNumVirtualBaseClasses(lldb::opaque_compiler_type_t type) = 0;\n\n  virtual CompilerType\n  GetDirectBaseClassAtIndex(lldb::opaque_compiler_type_t type, size_t idx,\n                            uint32_t *bit_offset_ptr) = 0;\n\n  virtual CompilerType\n  GetVirtualBaseClassAtIndex(lldb::opaque_compiler_type_t type, size_t idx,\n                             uint32_t *bit_offset_ptr) = 0;\n\n  virtual CompilerType GetChildCompilerTypeAtIndex(\n      lldb::opaque_compiler_type_t type, ExecutionContext *exe_ctx, size_t idx,\n      bool transparent_pointers, bool omit_empty_base_classes,\n      bool ignore_array_bounds, std::string &child_name,\n      uint32_t &child_byte_size, int32_t &child_byte_offset,\n      uint32_t &child_bitfield_bit_size, uint32_t &child_bitfield_bit_offset,\n      bool &child_is_base_class, bool &child_is_deref_of_parent,\n      ValueObject *valobj, uint64_t &language_flags) = 0;\n\n  // Lookup a child given a name. This function will match base class names and\n  // member member names in \"clang_type\" only, not descendants.\n  virtual uint32_t GetIndexOfChildWithName(lldb::opaque_compiler_type_t type,\n                                           const char *name,\n                                           bool omit_empty_base_classes) = 0;\n\n  // Lookup a child member given a name. This function will match member names\n  // only and will descend into \"clang_type\" children in search for the first\n  // member in this class, or any base class that matches \"name\".\n  // TODO: Return all matches for a given name by returning a\n  // vector<vector<uint32_t>>\n  // so we catch all names that match a given child name, not just the first.\n  virtual size_t\n  GetIndexOfChildMemberWithName(lldb::opaque_compiler_type_t type,\n                                const char *name, bool omit_empty_base_classes,\n                                std::vector<uint32_t> &child_indexes) = 0;\n\n  virtual size_t GetNumTemplateArguments(lldb::opaque_compiler_type_t type);\n\n  virtual lldb::TemplateArgumentKind\n  GetTemplateArgumentKind(lldb::opaque_compiler_type_t type, size_t idx);\n  virtual CompilerType GetTypeTemplateArgument(lldb::opaque_compiler_type_t type,\n                                           size_t idx);\n  virtual llvm::Optional<CompilerType::IntegralTemplateArgument>\n  GetIntegralTemplateArgument(lldb::opaque_compiler_type_t type, size_t idx);\n\n  // Dumping types\n\n#ifndef NDEBUG\n  /// Convenience LLVM-style dump method for use in the debugger only.\n  LLVM_DUMP_METHOD virtual void\n  dump(lldb::opaque_compiler_type_t type) const = 0;\n#endif\n  \n  virtual void DumpValue(lldb::opaque_compiler_type_t type,\n                         ExecutionContext *exe_ctx, Stream *s,\n                         lldb::Format format, const DataExtractor &data,\n                         lldb::offset_t data_offset, size_t data_byte_size,\n                         uint32_t bitfield_bit_size,\n                         uint32_t bitfield_bit_offset, bool show_types,\n                         bool show_summary, bool verbose, uint32_t depth) = 0;\n\n  virtual bool DumpTypeValue(lldb::opaque_compiler_type_t type, Stream *s,\n                             lldb::Format format, const DataExtractor &data,\n                             lldb::offset_t data_offset, size_t data_byte_size,\n                             uint32_t bitfield_bit_size,\n                             uint32_t bitfield_bit_offset,\n                             ExecutionContextScope *exe_scope) = 0;\n\n  /// Dump the type to stdout.\n  virtual void DumpTypeDescription(\n      lldb::opaque_compiler_type_t type,\n      lldb::DescriptionLevel level = lldb::eDescriptionLevelFull) = 0;\n\n  /// Print a description of the type to a stream. The exact implementation\n  /// varies, but the expectation is that eDescriptionLevelFull returns a\n  /// source-like representation of the type, whereas eDescriptionLevelVerbose\n  /// does a dump of the underlying AST if applicable.\n  virtual void DumpTypeDescription(\n      lldb::opaque_compiler_type_t type, Stream *s,\n      lldb::DescriptionLevel level = lldb::eDescriptionLevelFull) = 0;\n\n  // TODO: These methods appear unused. Should they be removed?\n\n  virtual bool IsRuntimeGeneratedType(lldb::opaque_compiler_type_t type) = 0;\n\n  virtual void DumpSummary(lldb::opaque_compiler_type_t type,\n                           ExecutionContext *exe_ctx, Stream *s,\n                           const DataExtractor &data,\n                           lldb::offset_t data_offset,\n                           size_t data_byte_size) = 0;\n\n  // TODO: Determine if these methods should move to TypeSystemClang.\n\n  virtual bool IsPointerOrReferenceType(lldb::opaque_compiler_type_t type,\n                                        CompilerType *pointee_type) = 0;\n\n  virtual unsigned GetTypeQualifiers(lldb::opaque_compiler_type_t type) = 0;\n\n  virtual bool IsCStringType(lldb::opaque_compiler_type_t type,\n                             uint32_t &length) = 0;\n\n  virtual llvm::Optional<size_t>\n  GetTypeBitAlign(lldb::opaque_compiler_type_t type,\n                  ExecutionContextScope *exe_scope) = 0;\n\n  virtual CompilerType GetBasicTypeFromAST(lldb::BasicType basic_type) = 0;\n\n  virtual CompilerType\n  GetBuiltinTypeForEncodingAndBitSize(lldb::Encoding encoding,\n                                      size_t bit_size) = 0;\n\n  virtual bool IsBeingDefined(lldb::opaque_compiler_type_t type) = 0;\n\n  virtual bool IsConst(lldb::opaque_compiler_type_t type) = 0;\n\n  virtual uint32_t IsHomogeneousAggregate(lldb::opaque_compiler_type_t type,\n                                          CompilerType *base_type_ptr) = 0;\n\n  virtual bool IsPolymorphicClass(lldb::opaque_compiler_type_t type) = 0;\n\n  virtual bool IsTypedefType(lldb::opaque_compiler_type_t type) = 0;\n\n  // If the current object represents a typedef type, get the underlying type\n  virtual CompilerType GetTypedefedType(lldb::opaque_compiler_type_t type) = 0;\n\n  virtual bool IsVectorType(lldb::opaque_compiler_type_t type,\n                            CompilerType *element_type, uint64_t *size) = 0;\n\n  virtual CompilerType\n  GetFullyUnqualifiedType(lldb::opaque_compiler_type_t type) = 0;\n\n  virtual CompilerType\n  GetNonReferenceType(lldb::opaque_compiler_type_t type) = 0;\n\n  virtual bool IsReferenceType(lldb::opaque_compiler_type_t type,\n                               CompilerType *pointee_type, bool *is_rvalue) = 0;\n\n  virtual bool\n  ShouldTreatScalarValueAsAddress(lldb::opaque_compiler_type_t type) {\n    return IsPointerOrReferenceType(type, nullptr);\n  }\n\n  virtual UserExpression *\n  GetUserExpression(llvm::StringRef expr, llvm::StringRef prefix,\n                    lldb::LanguageType language,\n                    Expression::ResultType desired_type,\n                    const EvaluateExpressionOptions &options,\n                    ValueObject *ctx_obj) {\n    return nullptr;\n  }\n\n  virtual FunctionCaller *GetFunctionCaller(const CompilerType &return_type,\n                                            const Address &function_address,\n                                            const ValueList &arg_value_list,\n                                            const char *name) {\n    return nullptr;\n  }\n\n  virtual std::unique_ptr<UtilityFunction>\n  CreateUtilityFunction(std::string text, std::string name);\n\n  virtual PersistentExpressionState *GetPersistentExpressionState() {\n    return nullptr;\n  }\n\n  virtual CompilerType GetTypeForFormatters(void *type);\n\n  virtual LazyBool ShouldPrintAsOneLiner(void *type, ValueObject *valobj);\n\n  // Type systems can have types that are placeholder types, which are meant to\n  // indicate the presence of a type, but offer no actual information about\n  // said types, and leave the burden of actually figuring type information out\n  // to dynamic type resolution. For instance a language with a generics\n  // system, can use placeholder types to indicate \"type argument goes here\",\n  // without promising uniqueness of the placeholder, nor attaching any\n  // actually idenfiable information to said placeholder. This API allows type\n  // systems to tell LLDB when such a type has been encountered In response,\n  // the debugger can react by not using this type as a cache entry in any\n  // type-specific way For instance, LLDB will currently not cache any\n  // formatters that are discovered on such a type as attributable to the\n  // meaningless type itself, instead preferring to use the dynamic type\n  virtual bool IsMeaninglessWithoutDynamicResolution(void *type);\n\nprotected:\n  SymbolFile *m_sym_file = nullptr;\n};\n\nclass TypeSystemMap {\npublic:\n  TypeSystemMap();\n  ~TypeSystemMap();\n\n  // Clear calls Finalize on all the TypeSystems managed by this map, and then\n  // empties the map.\n  void Clear();\n\n  // Iterate through all of the type systems that are created. Return true from\n  // callback to keep iterating, false to stop iterating.\n  void ForEach(std::function<bool(TypeSystem *)> const &callback);\n\n  llvm::Expected<TypeSystem &>\n  GetTypeSystemForLanguage(lldb::LanguageType language, Module *module,\n                           bool can_create);\n\n  llvm::Expected<TypeSystem &>\n  GetTypeSystemForLanguage(lldb::LanguageType language, Target *target,\n                           bool can_create);\n\nprotected:\n  typedef std::map<lldb::LanguageType, lldb::TypeSystemSP> collection;\n  mutable std::mutex m_mutex; ///< A mutex to keep this object happy in\n                              ///multi-threaded environments.\n  collection m_map;\n  bool m_clear_in_progress;\n\nprivate:\n  typedef llvm::function_ref<lldb::TypeSystemSP()> CreateCallback;\n  /// Finds the type system for the given language. If no type system could be\n  /// found for a language and a CreateCallback was provided, the value returned\n  /// by the callback will be treated as the TypeSystem for the language.\n  ///\n  /// \\param language The language for which the type system should be found.\n  /// \\param create_callback A callback that will be called if no previously\n  ///                        created TypeSystem that fits the given language\n  ///                        could found. Can be omitted if a non-existent\n  ///                        type system should be treated as an error instead.\n  /// \\return The found type system or an error.\n  llvm::Expected<TypeSystem &> GetTypeSystemForLanguage(\n      lldb::LanguageType language,\n      llvm::Optional<CreateCallback> create_callback = llvm::None);\n};\n\n} // namespace lldb_private\n\n#endif // LLDB_SYMBOL_TYPESYSTEM_H\n"}, "26": {"id": 26, "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Target/InstrumentationRuntime.h", "content": "//===-- InstrumentationRuntime.h --------------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLDB_TARGET_INSTRUMENTATIONRUNTIME_H\n#define LLDB_TARGET_INSTRUMENTATIONRUNTIME_H\n\n#include <map>\n#include <vector>\n\n#include \"lldb/Core/PluginInterface.h\"\n#include \"lldb/Utility/StructuredData.h\"\n#include \"lldb/lldb-forward.h\"\n#include \"lldb/lldb-private.h\"\n#include \"lldb/lldb-types.h\"\n\nnamespace lldb_private {\n\ntypedef std::map<lldb::InstrumentationRuntimeType,\n                 lldb::InstrumentationRuntimeSP>\n    InstrumentationRuntimeCollection;\n\nclass InstrumentationRuntime\n    : public std::enable_shared_from_this<InstrumentationRuntime>,\n      public PluginInterface {\n  /// The instrumented process.\n  lldb::ProcessWP m_process_wp;\n\n  /// The module containing the instrumentation runtime.\n  lldb::ModuleSP m_runtime_module;\n\n  /// The breakpoint in the instrumentation runtime.\n  lldb::user_id_t m_breakpoint_id;\n\n  /// Indicates whether or not breakpoints have been registered in the\n  /// instrumentation runtime.\n  bool m_is_active;\n\nprotected:\n  InstrumentationRuntime(const lldb::ProcessSP &process_sp)\n      : m_process_wp(), m_runtime_module(), m_breakpoint_id(0),\n        m_is_active(false) {\n    if (process_sp)\n      m_process_wp = process_sp;\n  }\n\n  lldb::ProcessSP GetProcessSP() { return m_process_wp.lock(); }\n\n  lldb::ModuleSP GetRuntimeModuleSP() { return m_runtime_module; }\n\n  void SetRuntimeModuleSP(lldb::ModuleSP module_sp) {\n    m_runtime_module = std::move(module_sp);\n  }\n\n  lldb::user_id_t GetBreakpointID() const { return m_breakpoint_id; }\n\n  void SetBreakpointID(lldb::user_id_t ID) { m_breakpoint_id = ID; }\n\n  void SetActive(bool IsActive) { m_is_active = IsActive; }\n\n  /// Return a regular expression which can be used to identify a valid version\n  /// of the runtime library.\n  virtual const RegularExpression &GetPatternForRuntimeLibrary() = 0;\n\n  /// Check whether \\p module_sp corresponds to a valid runtime library.\n  virtual bool CheckIfRuntimeIsValid(const lldb::ModuleSP module_sp) = 0;\n\n  /// Register a breakpoint in the runtime library and perform any other\n  /// necessary initialization. The runtime library\n  /// is guaranteed to be loaded.\n  virtual void Activate() = 0;\n\npublic:\n  static void ModulesDidLoad(lldb_private::ModuleList &module_list,\n                             Process *process,\n                             InstrumentationRuntimeCollection &runtimes);\n\n  /// Look for the instrumentation runtime in \\p module_list. Register and\n  /// activate the runtime if this hasn't already\n  /// been done.\n  void ModulesDidLoad(lldb_private::ModuleList &module_list);\n\n  bool IsActive() const { return m_is_active; }\n\n  virtual lldb::ThreadCollectionSP\n  GetBacktracesFromExtendedStopInfo(StructuredData::ObjectSP info);\n};\n\n} // namespace lldb_private\n\n#endif // LLDB_TARGET_INSTRUMENTATIONRUNTIME_H\n"}, "27": {"id": 27, "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Target/Process.h", "content": "//===-- Process.h -----------------------------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLDB_TARGET_PROCESS_H\n#define LLDB_TARGET_PROCESS_H\n\n#include \"lldb/Host/Config.h\"\n\n#include <limits.h>\n\n#include <chrono>\n#include <list>\n#include <memory>\n#include <mutex>\n#include <string>\n#include <unordered_set>\n#include <vector>\n\n#include \"lldb/Breakpoint/BreakpointSiteList.h\"\n#include \"lldb/Core/Communication.h\"\n#include \"lldb/Core/LoadedModuleInfoList.h\"\n#include \"lldb/Core/PluginInterface.h\"\n#include \"lldb/Core/ThreadSafeValue.h\"\n#include \"lldb/Core/UserSettingsController.h\"\n#include \"lldb/Host/HostThread.h\"\n#include \"lldb/Host/ProcessLaunchInfo.h\"\n#include \"lldb/Host/ProcessRunLock.h\"\n#include \"lldb/Symbol/ObjectFile.h\"\n#include \"lldb/Target/ExecutionContextScope.h\"\n#include \"lldb/Target/InstrumentationRuntime.h\"\n#include \"lldb/Target/Memory.h\"\n#include \"lldb/Target/QueueList.h\"\n#include \"lldb/Target/ThreadList.h\"\n#include \"lldb/Target/ThreadPlanStack.h\"\n#include \"lldb/Target/Trace.h\"\n#include \"lldb/Utility/ArchSpec.h\"\n#include \"lldb/Utility/Broadcaster.h\"\n#include \"lldb/Utility/Event.h\"\n#include \"lldb/Utility/Listener.h\"\n#include \"lldb/Utility/NameMatches.h\"\n#include \"lldb/Utility/ProcessInfo.h\"\n#include \"lldb/Utility/Status.h\"\n#include \"lldb/Utility/StructuredData.h\"\n#include \"lldb/Utility/TraceOptions.h\"\n#include \"lldb/Utility/UnimplementedError.h\"\n#include \"lldb/Utility/UserIDResolver.h\"\n#include \"lldb/lldb-private.h\"\n\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/Support/Threading.h\"\n#include \"llvm/Support/VersionTuple.h\"\n\nnamespace lldb_private {\n\ntemplate <typename B, typename S> struct Range;\n\nclass ProcessExperimentalProperties : public Properties {\npublic:\n  ProcessExperimentalProperties();\n};\n\nclass ProcessProperties : public Properties {\npublic:\n  // Pass nullptr for \"process\" if the ProcessProperties are to be the global\n  // copy\n  ProcessProperties(lldb_private::Process *process);\n\n  ~ProcessProperties() override;\n\n  bool GetDisableMemoryCache() const;\n  uint64_t GetMemoryCacheLineSize() const;\n  Args GetExtraStartupCommands() const;\n  void SetExtraStartupCommands(const Args &args);\n  FileSpec GetPythonOSPluginPath() const;\n  void SetPythonOSPluginPath(const FileSpec &file);\n  bool GetIgnoreBreakpointsInExpressions() const;\n  void SetIgnoreBreakpointsInExpressions(bool ignore);\n  bool GetUnwindOnErrorInExpressions() const;\n  void SetUnwindOnErrorInExpressions(bool ignore);\n  bool GetStopOnSharedLibraryEvents() const;\n  void SetStopOnSharedLibraryEvents(bool stop);\n  bool GetDetachKeepsStopped() const;\n  void SetDetachKeepsStopped(bool keep_stopped);\n  bool GetWarningsOptimization() const;\n  bool GetWarningsUnsupportedLanguage() const;\n  bool GetStopOnExec() const;\n  std::chrono::seconds GetUtilityExpressionTimeout() const;\n  bool GetOSPluginReportsAllThreads() const;\n  void SetOSPluginReportsAllThreads(bool does_report);\n  bool GetSteppingRunsAllThreads() const;\n\nprotected:\n  Process *m_process; // Can be nullptr for global ProcessProperties\n  std::unique_ptr<ProcessExperimentalProperties> m_experimental_properties_up;\n};\n\ntypedef std::shared_ptr<ProcessProperties> ProcessPropertiesSP;\n\n// ProcessAttachInfo\n//\n// Describes any information that is required to attach to a process.\n\nclass ProcessAttachInfo : public ProcessInstanceInfo {\npublic:\n  ProcessAttachInfo()\n      : ProcessInstanceInfo(), m_listener_sp(), m_hijack_listener_sp(),\n        m_plugin_name(), m_resume_count(0), m_wait_for_launch(false),\n        m_ignore_existing(true), m_continue_once_attached(false),\n        m_detach_on_error(true), m_async(false) {}\n\n  ProcessAttachInfo(const ProcessLaunchInfo &launch_info)\n      : ProcessInstanceInfo(), m_listener_sp(), m_hijack_listener_sp(),\n        m_plugin_name(), m_resume_count(0), m_wait_for_launch(false),\n        m_ignore_existing(true), m_continue_once_attached(false),\n        m_detach_on_error(true), m_async(false) {\n    ProcessInfo::operator=(launch_info);\n    SetProcessPluginName(launch_info.GetProcessPluginName());\n    SetResumeCount(launch_info.GetResumeCount());\n    SetListener(launch_info.GetListener());\n    SetHijackListener(launch_info.GetHijackListener());\n    m_detach_on_error = launch_info.GetDetachOnError();\n  }\n\n  bool GetWaitForLaunch() const { return m_wait_for_launch; }\n\n  void SetWaitForLaunch(bool b) { m_wait_for_launch = b; }\n\n  bool GetAsync() const { return m_async; }\n\n  void SetAsync(bool b) { m_async = b; }\n\n  bool GetIgnoreExisting() const { return m_ignore_existing; }\n\n  void SetIgnoreExisting(bool b) { m_ignore_existing = b; }\n\n  bool GetContinueOnceAttached() const { return m_continue_once_attached; }\n\n  void SetContinueOnceAttached(bool b) { m_continue_once_attached = b; }\n\n  uint32_t GetResumeCount() const { return m_resume_count; }\n\n  void SetResumeCount(uint32_t c) { m_resume_count = c; }\n\n  const char *GetProcessPluginName() const {\n    return (m_plugin_name.empty() ? nullptr : m_plugin_name.c_str());\n  }\n\n  void SetProcessPluginName(llvm::StringRef plugin) {\n    m_plugin_name = std::string(plugin);\n  }\n\n  void Clear() {\n    ProcessInstanceInfo::Clear();\n    m_plugin_name.clear();\n    m_resume_count = 0;\n    m_wait_for_launch = false;\n    m_ignore_existing = true;\n    m_continue_once_attached = false;\n  }\n\n  bool ProcessInfoSpecified() const {\n    if (GetExecutableFile())\n      return true;\n    if (GetProcessID() != LLDB_INVALID_PROCESS_ID)\n      return true;\n    if (GetParentProcessID() != LLDB_INVALID_PROCESS_ID)\n      return true;\n    return false;\n  }\n\n  lldb::ListenerSP GetHijackListener() const { return m_hijack_listener_sp; }\n\n  void SetHijackListener(const lldb::ListenerSP &listener_sp) {\n    m_hijack_listener_sp = listener_sp;\n  }\n\n  bool GetDetachOnError() const { return m_detach_on_error; }\n\n  void SetDetachOnError(bool enable) { m_detach_on_error = enable; }\n\n  // Get and set the actual listener that will be used for the process events\n  lldb::ListenerSP GetListener() const { return m_listener_sp; }\n\n  void SetListener(const lldb::ListenerSP &listener_sp) {\n    m_listener_sp = listener_sp;\n  }\n\n  lldb::ListenerSP GetListenerForProcess(Debugger &debugger);\n\nprotected:\n  lldb::ListenerSP m_listener_sp;\n  lldb::ListenerSP m_hijack_listener_sp;\n  std::string m_plugin_name;\n  uint32_t m_resume_count; // How many times do we resume after launching\n  bool m_wait_for_launch;\n  bool m_ignore_existing;\n  bool m_continue_once_attached; // Supports the use-case scenario of\n                                 // immediately continuing the process once\n                                 // attached.\n  bool m_detach_on_error; // If we are debugging remotely, instruct the stub to\n                          // detach rather than killing the target on error.\n  bool m_async; // Use an async attach where we start the attach and return\n                // immediately (used by GUI programs with --waitfor so they can\n                // call SBProcess::Stop() to cancel attach)\n};\n\n// This class tracks the Modification state of the process.  Things that can\n// currently modify the program are running the program (which will up the\n// StopID) and writing memory (which will up the MemoryID.)\n// FIXME: Should we also include modification of register states?\n\nclass ProcessModID {\n  friend bool operator==(const ProcessModID &lhs, const ProcessModID &rhs);\n\npublic:\n  ProcessModID()\n      : m_stop_id(0), m_last_natural_stop_id(0), m_resume_id(0), m_memory_id(0),\n        m_last_user_expression_resume(0), m_running_user_expression(false),\n        m_running_utility_function(0) {}\n\n  ProcessModID(const ProcessModID &rhs)\n      : m_stop_id(rhs.m_stop_id), m_memory_id(rhs.m_memory_id) {}\n\n  const ProcessModID &operator=(const ProcessModID &rhs) {\n    if (this != &rhs) {\n      m_stop_id = rhs.m_stop_id;\n      m_memory_id = rhs.m_memory_id;\n    }\n    return *this;\n  }\n\n  ~ProcessModID() = default;\n\n  void BumpStopID() {\n    m_stop_id++;\n    if (!IsLastResumeForUserExpression())\n      m_last_natural_stop_id++;\n  }\n\n  void BumpMemoryID() { m_memory_id++; }\n\n  void BumpResumeID() {\n    m_resume_id++;\n    if (m_running_user_expression > 0)\n      m_last_user_expression_resume = m_resume_id;\n  }\n\n  bool IsRunningUtilityFunction() const {\n    return m_running_utility_function > 0;\n  }\n\n  uint32_t GetStopID() const { return m_stop_id; }\n  uint32_t GetLastNaturalStopID() const { return m_last_natural_stop_id; }\n  uint32_t GetMemoryID() const { return m_memory_id; }\n  uint32_t GetResumeID() const { return m_resume_id; }\n  uint32_t GetLastUserExpressionResumeID() const {\n    return m_last_user_expression_resume;\n  }\n\n  bool MemoryIDEqual(const ProcessModID &compare) const {\n    return m_memory_id == compare.m_memory_id;\n  }\n\n  bool StopIDEqual(const ProcessModID &compare) const {\n    return m_stop_id == compare.m_stop_id;\n  }\n\n  void SetInvalid() { m_stop_id = UINT32_MAX; }\n\n  bool IsValid() const { return m_stop_id != UINT32_MAX; }\n\n  bool IsLastResumeForUserExpression() const {\n    // If we haven't yet resumed the target, then it can't be for a user\n    // expression...\n    if (m_resume_id == 0)\n      return false;\n\n    return m_resume_id == m_last_user_expression_resume;\n  }\n\n  void SetRunningUserExpression(bool on) {\n    if (on)\n      m_running_user_expression++;\n    else\n      m_running_user_expression--;\n  }\n\n  void SetRunningUtilityFunction(bool on) {\n    if (on)\n      m_running_utility_function++;\n    else {\n      assert(m_running_utility_function > 0 &&\n             \"Called SetRunningUtilityFunction(false) without calling \"\n             \"SetRunningUtilityFunction(true) before?\");\n      m_running_utility_function--;\n    }\n  }\n\n  void SetStopEventForLastNaturalStopID(lldb::EventSP event_sp) {\n    m_last_natural_stop_event = std::move(event_sp);\n  }\n\n  lldb::EventSP GetStopEventForStopID(uint32_t stop_id) const {\n    if (stop_id == m_last_natural_stop_id)\n      return m_last_natural_stop_event;\n    return lldb::EventSP();\n  }\n\nprivate:\n  uint32_t m_stop_id;\n  uint32_t m_last_natural_stop_id;\n  uint32_t m_resume_id;\n  uint32_t m_memory_id;\n  uint32_t m_last_user_expression_resume;\n  uint32_t m_running_user_expression;\n  uint32_t m_running_utility_function;\n  lldb::EventSP m_last_natural_stop_event;\n};\n\ninline bool operator==(const ProcessModID &lhs, const ProcessModID &rhs) {\n  if (lhs.StopIDEqual(rhs) && lhs.MemoryIDEqual(rhs))\n    return true;\n  else\n    return false;\n}\n\ninline bool operator!=(const ProcessModID &lhs, const ProcessModID &rhs) {\n  return (!lhs.StopIDEqual(rhs) || !lhs.MemoryIDEqual(rhs));\n}\n\n/// \\class Process Process.h \"lldb/Target/Process.h\"\n/// A plug-in interface definition class for debugging a process.\nclass Process : public std::enable_shared_from_this<Process>,\n                public ProcessProperties,\n                public Broadcaster,\n                public ExecutionContextScope,\n                public PluginInterface {\n  friend class FunctionCaller; // For WaitForStateChangeEventsPrivate\n  friend class Debugger; // For PopProcessIOHandler and ProcessIOHandlerIsActive\n  friend class DynamicLoader; // For LoadOperatingSystemPlugin\n  friend class ProcessEventData;\n  friend class StopInfo;\n  friend class Target;\n  friend class ThreadList;\n\npublic:\n  /// Broadcaster event bits definitions.\n  enum {\n    eBroadcastBitStateChanged = (1 << 0),\n    eBroadcastBitInterrupt = (1 << 1),\n    eBroadcastBitSTDOUT = (1 << 2),\n    eBroadcastBitSTDERR = (1 << 3),\n    eBroadcastBitProfileData = (1 << 4),\n    eBroadcastBitStructuredData = (1 << 5),\n  };\n\n  enum {\n    eBroadcastInternalStateControlStop = (1 << 0),\n    eBroadcastInternalStateControlPause = (1 << 1),\n    eBroadcastInternalStateControlResume = (1 << 2)\n  };\n\n  /// Process warning types.\n  enum Warnings { eWarningsOptimization = 1, eWarningsUnsupportedLanguage = 2 };\n\n  typedef Range<lldb::addr_t, lldb::addr_t> LoadRange;\n  // We use a read/write lock to allow on or more clients to access the process\n  // state while the process is stopped (reader). We lock the write lock to\n  // control access to the process while it is running (readers, or clients\n  // that want the process stopped can block waiting for the process to stop,\n  // or just try to lock it to see if they can immediately access the stopped\n  // process. If the try read lock fails, then the process is running.\n  typedef ProcessRunLock::ProcessRunLocker StopLocker;\n\n  // These two functions fill out the Broadcaster interface:\n\n  static ConstString &GetStaticBroadcasterClass();\n\n  ConstString &GetBroadcasterClass() const override {\n    return GetStaticBroadcasterClass();\n  }\n\n/// A notification structure that can be used by clients to listen\n/// for changes in a process's lifetime.\n///\n/// \\see RegisterNotificationCallbacks (const Notifications&) @see\n/// UnregisterNotificationCallbacks (const Notifications&)\n  typedef struct {\n    void *baton;\n    void (*initialize)(void *baton, Process *process);\n    void (*process_state_changed)(void *baton, Process *process,\n                                  lldb::StateType state);\n  } Notifications;\n\n  class ProcessEventData : public EventData {\n    friend class Process;\n\n  public:\n    ProcessEventData();\n    ProcessEventData(const lldb::ProcessSP &process, lldb::StateType state);\n\n    ~ProcessEventData() override;\n\n    static ConstString GetFlavorString();\n\n    ConstString GetFlavor() const override;\n\n    lldb::ProcessSP GetProcessSP() const { return m_process_wp.lock(); }\n\n    lldb::StateType GetState() const { return m_state; }\n    bool GetRestarted() const { return m_restarted; }\n\n    size_t GetNumRestartedReasons() { return m_restarted_reasons.size(); }\n\n    const char *GetRestartedReasonAtIndex(size_t idx) {\n      return ((idx < m_restarted_reasons.size())\n                  ? m_restarted_reasons[idx].c_str()\n                  : nullptr);\n    }\n\n    bool GetInterrupted() const { return m_interrupted; }\n\n    void Dump(Stream *s) const override;\n\n    virtual bool ShouldStop(Event *event_ptr, bool &found_valid_stopinfo);\n\n    void DoOnRemoval(Event *event_ptr) override;\n\n    static const Process::ProcessEventData *\n    GetEventDataFromEvent(const Event *event_ptr);\n\n    static lldb::ProcessSP GetProcessFromEvent(const Event *event_ptr);\n\n    static lldb::StateType GetStateFromEvent(const Event *event_ptr);\n\n    static bool GetRestartedFromEvent(const Event *event_ptr);\n\n    static size_t GetNumRestartedReasons(const Event *event_ptr);\n\n    static const char *GetRestartedReasonAtIndex(const Event *event_ptr,\n                                                 size_t idx);\n\n    static void AddRestartedReason(Event *event_ptr, const char *reason);\n\n    static void SetRestartedInEvent(Event *event_ptr, bool new_value);\n\n    static bool GetInterruptedFromEvent(const Event *event_ptr);\n\n    static void SetInterruptedInEvent(Event *event_ptr, bool new_value);\n\n    static bool SetUpdateStateOnRemoval(Event *event_ptr);\n\n  private:\n    void SetUpdateStateOnRemoval() { m_update_state++; }\n\n    void SetRestarted(bool new_value) { m_restarted = new_value; }\n\n    void SetInterrupted(bool new_value) { m_interrupted = new_value; }\n\n    void AddRestartedReason(const char *reason) {\n      m_restarted_reasons.push_back(reason);\n    }\n\n    lldb::ProcessWP m_process_wp;\n    lldb::StateType m_state;\n    std::vector<std::string> m_restarted_reasons;\n    bool m_restarted; // For \"eStateStopped\" events, this is true if the target\n                      // was automatically restarted.\n    int m_update_state;\n    bool m_interrupted;\n\n    ProcessEventData(const ProcessEventData &) = delete;\n    const ProcessEventData &operator=(const ProcessEventData &) = delete;\n  };\n\n  /// Construct with a shared pointer to a target, and the Process listener.\n  /// Uses the Host UnixSignalsSP by default.\n  Process(lldb::TargetSP target_sp, lldb::ListenerSP listener_sp);\n\n  /// Construct with a shared pointer to a target, the Process listener, and\n  /// the appropriate UnixSignalsSP for the process.\n  Process(lldb::TargetSP target_sp, lldb::ListenerSP listener_sp,\n          const lldb::UnixSignalsSP &unix_signals_sp);\n\n  /// Destructor.\n  ///\n  /// The destructor is virtual since this class is designed to be inherited\n  /// from by the plug-in instance.\n  ~Process() override;\n\n  static void SettingsInitialize();\n\n  static void SettingsTerminate();\n\n  static const ProcessPropertiesSP &GetGlobalProperties();\n\n  /// Find a Process plug-in that can debug \\a module using the currently\n  /// selected architecture.\n  ///\n  /// Scans all loaded plug-in interfaces that implement versions of the\n  /// Process plug-in interface and returns the first instance that can debug\n  /// the file.\n  ///\n  /// \\see Process::CanDebug ()\n  static lldb::ProcessSP FindPlugin(lldb::TargetSP target_sp,\n                                    llvm::StringRef plugin_name,\n                                    lldb::ListenerSP listener_sp,\n                                    const FileSpec *crash_file_path,\n                                    bool can_connect);\n\n  /// Static function that can be used with the \\b host function\n  /// Host::StartMonitoringChildProcess ().\n  ///\n  /// This function can be used by lldb_private::Process subclasses when they\n  /// want to watch for a local process and have its exit status automatically\n  /// set when the host child process exits. Subclasses should call\n  /// Host::StartMonitoringChildProcess () with:\n  ///     callback = Process::SetHostProcessExitStatus\n  ///     pid = Process::GetID()\n  ///     monitor_signals = false\n  static bool\n  SetProcessExitStatus(lldb::pid_t pid, // The process ID we want to monitor\n                       bool exited,\n                       int signo,   // Zero for no signal\n                       int status); // Exit value of process if signal is zero\n\n  lldb::ByteOrder GetByteOrder() const;\n\n  uint32_t GetAddressByteSize() const;\n\n  /// Sets the stored pid.\n  ///\n  /// This does not change the pid of underlying process.\n  lldb::pid_t GetID() const { return m_pid; }\n\n  /// Returns the pid of the process or LLDB_INVALID_PROCESS_ID if there is\n  /// no known pid.\n  void SetID(lldb::pid_t new_pid) { m_pid = new_pid; }\n\n  uint32_t GetUniqueID() const { return m_process_unique_id; }\n\n  /// Check if a plug-in instance can debug the file in \\a module.\n  ///\n  /// Each plug-in is given a chance to say whether it can debug the file in\n  /// \\a module. If the Process plug-in instance can debug a file on the\n  /// current system, it should return \\b true.\n  ///\n  /// \\return\n  ///     Returns \\b true if this Process plug-in instance can\n  ///     debug the executable, \\b false otherwise.\n  virtual bool CanDebug(lldb::TargetSP target,\n                        bool plugin_specified_by_name) = 0;\n\n  /// This object is about to be destroyed, do any necessary cleanup.\n  ///\n  /// Subclasses that override this method should always call this superclass\n  /// method.\n  virtual void Finalize();\n\n  /// Return whether this object is valid (i.e. has not been finalized.)\n  ///\n  /// \\return\n  ///     Returns \\b true if this Process has not been finalized\n  ///     and \\b false otherwise.\n  bool IsValid() const { return !m_finalizing; }\n\n  /// Return a multi-word command object that can be used to expose plug-in\n  /// specific commands.\n  ///\n  /// This object will be used to resolve plug-in commands and can be\n  /// triggered by a call to:\n  ///\n  ///     (lldb) process command <args>\n  ///\n  /// \\return\n  ///     A CommandObject which can be one of the concrete subclasses\n  ///     of CommandObject like CommandObjectRaw, CommandObjectParsed,\n  ///     or CommandObjectMultiword.\n  virtual CommandObject *GetPluginCommandObject() { return nullptr; }\n\n  /// Launch a new process.\n  ///\n  /// Launch a new process by spawning a new process using the target object's\n  /// executable module's file as the file to launch.\n  ///\n  /// This function is not meant to be overridden by Process subclasses. It\n  /// will first call Process::WillLaunch (Module *) and if that returns \\b\n  /// true, Process::DoLaunch (Module*, char const *[],char const *[],const\n  /// char *,const char *, const char *) will be called to actually do the\n  /// launching. If DoLaunch returns \\b true, then Process::DidLaunch() will\n  /// be called.\n  ///\n  /// \\param[in] launch_info\n  ///     Details regarding the environment, STDIN/STDOUT/STDERR\n  ///     redirection, working path, etc. related to the requested launch.\n  ///\n  /// \\return\n  ///     An error object. Call GetID() to get the process ID if\n  ///     the error object is success.\n  virtual Status Launch(ProcessLaunchInfo &launch_info);\n\n  virtual Status LoadCore();\n\n  virtual Status DoLoadCore() {\n    Status error;\n    error.SetErrorStringWithFormat(\n        \"error: %s does not support loading core files.\",\n        GetPluginName().GetCString());\n    return error;\n  }\n\n  // FUTURE WORK: GetLoadImageUtilityFunction are the first use we've\n  // had of having other plugins cache data in the Process.  This is handy for\n  // long-living plugins - like the Platform - which manage interactions whose\n  // lifetime is governed by the Process lifetime.  If we find we need to do\n  // this more often, we should construct a general solution to the problem.\n  // The consensus suggestion was that we have a token based registry in the\n  // Process. Some undecided questions are  (1) who manages the tokens.  It's\n  // probably best that you add the element  and get back a token that\n  // represents it.  That will avoid collisions.  But there may be some utility\n  // in the registerer controlling the token? (2) whether the thing added\n  // should be simply owned by Process, and just go away when it does (3)\n  // whether the registree should be notified of the Process' demise.\n  //\n  // We are postponing designing this till we have at least a second use case.\n  /// Get the cached UtilityFunction that assists in loading binary images\n  /// into the process.\n  ///\n  /// \\param[in] platform\n  ///     The platform fetching the UtilityFunction.\n  /// \\param[in] factory\n  ///     A function that will be called only once per-process in a\n  ///     thread-safe way to create the UtilityFunction if it has not\n  ///     been initialized yet.\n  ///\n  /// \\return\n  ///     The cached utility function or null if the platform is not the\n  ///     same as the target's platform.\n  UtilityFunction *GetLoadImageUtilityFunction(\n      Platform *platform,\n      llvm::function_ref<std::unique_ptr<UtilityFunction>()> factory);\n\n  /// Get the dynamic loader plug-in for this process.\n  ///\n  /// The default action is to let the DynamicLoader plug-ins check the main\n  /// executable and the DynamicLoader will select itself automatically.\n  /// Subclasses can override this if inspecting the executable is not\n  /// desired, or if Process subclasses can only use a specific DynamicLoader\n  /// plug-in.\n  virtual DynamicLoader *GetDynamicLoader();\n\n  // Returns AUXV structure found in many ELF-based environments.\n  //\n  // The default action is to return an empty data buffer.\n  //\n  // \\return\n  //    A data extractor containing the contents of the AUXV data.\n  virtual DataExtractor GetAuxvData();\n\n  /// Sometimes processes know how to retrieve and load shared libraries. This\n  /// is normally done by DynamicLoader plug-ins, but sometimes the connection\n  /// to the process allows retrieving this information. The dynamic loader\n  /// plug-ins can use this function if they can't determine the current\n  /// shared library load state.\n  ///\n  /// \\return\n  ///    A status object indicating if the operation was sucessful or not.\n  virtual llvm::Error LoadModules() {\n    return llvm::make_error<llvm::StringError>(\"Not implemented.\",\n                                               llvm::inconvertibleErrorCode());\n  }\n\n  /// Query remote GDBServer for a detailed loaded library list\n  /// \\return\n  ///    The list of modules currently loaded by the process, or an error.\n  virtual llvm::Expected<LoadedModuleInfoList> GetLoadedModuleList() {\n    return llvm::createStringError(llvm::inconvertibleErrorCode(),\n                                   \"Not implemented\");\n  }\n\nprotected:\n  virtual JITLoaderList &GetJITLoaders();\n\npublic:\n  /// Get the system runtime plug-in for this process.\n  ///\n  /// \\return\n  ///   Returns a pointer to the SystemRuntime plugin for this Process\n  ///   if one is available.  Else returns nullptr.\n  virtual SystemRuntime *GetSystemRuntime();\n\n  /// Attach to an existing process using the process attach info.\n  ///\n  /// This function is not meant to be overridden by Process subclasses. It\n  /// will first call WillAttach (lldb::pid_t) or WillAttach (const char *),\n  /// and if that returns \\b true, DoAttach (lldb::pid_t) or DoAttach (const\n  /// char *) will be called to actually do the attach. If DoAttach returns \\b\n  /// true, then Process::DidAttach() will be called.\n  ///\n  /// \\param[in] attach_info\n  ///     The process attach info.\n  ///\n  /// \\return\n  ///     Returns \\a pid if attaching was successful, or\n  ///     LLDB_INVALID_PROCESS_ID if attaching fails.\n  virtual Status Attach(ProcessAttachInfo &attach_info);\n\n  /// Attach to a remote system via a URL\n  ///\n  /// \\param[in] remote_url\n  ///     The URL format that we are connecting to.\n  ///\n  /// \\return\n  ///     Returns an error object.\n  virtual Status ConnectRemote(llvm::StringRef remote_url);\n\n  bool GetShouldDetach() const { return m_should_detach; }\n\n  void SetShouldDetach(bool b) { m_should_detach = b; }\n\n  /// Get the image vector for the current process.\n  ///\n  /// \\return\n  ///     The constant reference to the member m_image_tokens.\n  const std::vector<lldb::addr_t>& GetImageTokens() { return m_image_tokens; }\n\n  /// Get the image information address for the current process.\n  ///\n  /// Some runtimes have system functions that can help dynamic loaders locate\n  /// the dynamic loader information needed to observe shared libraries being\n  /// loaded or unloaded. This function is in the Process interface (as\n  /// opposed to the DynamicLoader interface) to ensure that remote debugging\n  /// can take advantage of this functionality.\n  ///\n  /// \\return\n  ///     The address of the dynamic loader information, or\n  ///     LLDB_INVALID_ADDRESS if this is not supported by this\n  ///     interface.\n  virtual lldb::addr_t GetImageInfoAddress();\n\n  /// Called when the process is about to broadcast a public stop.\n  ///\n  /// There are public and private stops. Private stops are when the process\n  /// is doing things like stepping and the client doesn't need to know about\n  /// starts and stop that implement a thread plan. Single stepping over a\n  /// source line in code might end up being implemented by one or more\n  /// process starts and stops. Public stops are when clients will be notified\n  /// that the process is stopped. These events typically trigger UI updates\n  /// (thread stack frames to be displayed, variables to be displayed, and\n  /// more). This function can be overriden and allows process subclasses to\n  /// do something before the eBroadcastBitStateChanged event is sent to\n  /// public clients.\n  virtual void WillPublicStop() {}\n\n/// Register for process and thread notifications.\n///\n/// Clients can register notification callbacks by filling out a\n/// Process::Notifications structure and calling this function.\n///\n/// \\param[in] callbacks\n///     A structure that contains the notification baton and\n///     callback functions.\n///\n/// \\see Process::Notifications\n  void RegisterNotificationCallbacks(const Process::Notifications &callbacks);\n\n/// Unregister for process and thread notifications.\n///\n/// Clients can unregister notification callbacks by passing a copy of the\n/// original baton and callbacks in \\a callbacks.\n///\n/// \\param[in] callbacks\n///     A structure that contains the notification baton and\n///     callback functions.\n///\n/// \\return\n///     Returns \\b true if the notification callbacks were\n///     successfully removed from the process, \\b false otherwise.\n///\n/// \\see Process::Notifications\n  bool UnregisterNotificationCallbacks(const Process::Notifications &callbacks);\n\n  //==================================================================\n  // Built in Process Control functions\n  //==================================================================\n  /// Resumes all of a process's threads as configured using the Thread run\n  /// control functions.\n  ///\n  /// Threads for a process should be updated with one of the run control\n  /// actions (resume, step, or suspend) that they should take when the\n  /// process is resumed. If no run control action is given to a thread it\n  /// will be resumed by default.\n  ///\n  /// This function is not meant to be overridden by Process subclasses. This\n  /// function will take care of disabling any breakpoints that threads may be\n  /// stopped at, single stepping, and re-enabling breakpoints, and enabling\n  /// the basic flow control that the plug-in instances need not worry about.\n  ///\n  /// N.B. This function also sets the Write side of the Run Lock, which is\n  /// unset when the corresponding stop event is pulled off the Public Event\n  /// Queue.  If you need to resume the process without setting the Run Lock,\n  /// use PrivateResume (though you should only do that from inside the\n  /// Process class.\n  ///\n  /// \\return\n  ///     Returns an error object.\n  ///\n  /// \\see Thread:Resume()\n  /// \\see Thread:Step()\n  /// \\see Thread:Suspend()\n  Status Resume();\n\n  Status ResumeSynchronous(Stream *stream);\n\n  /// Halts a running process.\n  ///\n  /// This function is not meant to be overridden by Process subclasses. If\n  /// the process is successfully halted, a eStateStopped process event with\n  /// GetInterrupted will be broadcast.  If false, we will halt the process\n  /// with no events generated by the halt.\n  ///\n  /// \\param[in] clear_thread_plans\n  ///     If true, when the process stops, clear all thread plans.\n  ///\n  /// \\param[in] use_run_lock\n  ///     Whether to release the run lock after the stop.\n  ///\n  /// \\return\n  ///     Returns an error object.  If the error is empty, the process is\n  ///     halted.\n  ///     otherwise the halt has failed.\n  Status Halt(bool clear_thread_plans = false, bool use_run_lock = true);\n\n  /// Detaches from a running or stopped process.\n  ///\n  /// This function is not meant to be overridden by Process subclasses.\n  ///\n  /// \\param[in] keep_stopped\n  ///     If true, don't resume the process on detach.\n  ///\n  /// \\return\n  ///     Returns an error object.\n  Status Detach(bool keep_stopped);\n\n  /// Kills the process and shuts down all threads that were spawned to track\n  /// and monitor the process.\n  ///\n  /// This function is not meant to be overridden by Process subclasses.\n  ///\n  /// \\param[in] force_kill\n  ///     Whether lldb should force a kill (instead of a detach) from\n  ///     the inferior process.  Normally if lldb launched a binary and\n  ///     Destory is called, lldb kills it.  If lldb attached to a\n  ///     running process and Destory is called, lldb detaches.  If\n  ///     this behavior needs to be over-ridden, this is the bool that\n  ///     can be used.\n  ///\n  /// \\return\n  ///     Returns an error object.\n  Status Destroy(bool force_kill);\n\n  /// Sends a process a UNIX signal \\a signal.\n  ///\n  /// This function is not meant to be overridden by Process subclasses.\n  ///\n  /// \\return\n  ///     Returns an error object.\n  Status Signal(int signal);\n\n  void SetUnixSignals(lldb::UnixSignalsSP &&signals_sp);\n\n  const lldb::UnixSignalsSP &GetUnixSignals();\n\n  //==================================================================\n  // Plug-in Process Control Overrides\n  //==================================================================\n\n  /// Called before attaching to a process.\n  ///\n  /// Allow Process plug-ins to execute some code before attaching a process.\n  ///\n  /// \\return\n  ///     Returns an error object.\n  virtual Status WillAttachToProcessWithID(lldb::pid_t pid) { return Status(); }\n\n  /// Called before attaching to a process.\n  ///\n  /// Allow Process plug-ins to execute some code before attaching a process.\n  ///\n  /// \\return\n  ///     Returns an error object.\n  virtual Status WillAttachToProcessWithName(const char *process_name,\n                                             bool wait_for_launch) {\n    return Status();\n  }\n\n  /// Attach to a remote system via a URL\n  ///\n  /// \\param[in] remote_url\n  ///     The URL format that we are connecting to.\n  ///\n  /// \\return\n  ///     Returns an error object.\n  virtual Status DoConnectRemote(llvm::StringRef remote_url) {\n    Status error;\n    error.SetErrorString(\"remote connections are not supported\");\n    return error;\n  }\n\n  /// Attach to an existing process using a process ID.\n  ///\n  /// \\param[in] pid\n  ///     The process ID that we should attempt to attach to.\n  ///\n  /// \\param[in] attach_info\n  ///     Information on how to do the attach. For example, GetUserID()\n  ///     will return the uid to attach as.\n  ///\n  /// \\return\n  ///     Returns a successful Status attaching was successful, or\n  ///     an appropriate (possibly platform-specific) error code if\n  ///     attaching fails.\n  /// hanming : need flag\n  virtual Status DoAttachToProcessWithID(lldb::pid_t pid,\n                                         const ProcessAttachInfo &attach_info) {\n    Status error;\n    error.SetErrorStringWithFormat(\n        \"error: %s does not support attaching to a process by pid\",\n        GetPluginName().GetCString());\n    return error;\n  }\n\n  /// Attach to an existing process using a partial process name.\n  ///\n  /// \\param[in] process_name\n  ///     The name of the process to attach to.\n  ///\n  /// \\param[in] attach_info\n  ///     Information on how to do the attach. For example, GetUserID()\n  ///     will return the uid to attach as.\n  ///\n  /// \\return\n  ///     Returns a successful Status attaching was successful, or\n  ///     an appropriate (possibly platform-specific) error code if\n  ///     attaching fails.\n  virtual Status\n  DoAttachToProcessWithName(const char *process_name,\n                            const ProcessAttachInfo &attach_info) {\n    Status error;\n    error.SetErrorString(\"attach by name is not supported\");\n    return error;\n  }\n\n  /// Called after attaching a process.\n  ///\n  /// \\param[in] process_arch\n  ///     If you can figure out the process architecture after attach, fill it\n  ///     in here.\n  ///\n  /// Allow Process plug-ins to execute some code after attaching to a\n  /// process.\n  virtual void DidAttach(ArchSpec &process_arch) { process_arch.Clear(); }\n\n  /// Called after a process re-execs itself.\n  ///\n  /// Allow Process plug-ins to execute some code after a process has exec'ed\n  /// itself. Subclasses typically should override DoDidExec() as the\n  /// lldb_private::Process class needs to remove its dynamic loader, runtime,\n  /// ABI and other plug-ins, as well as unload all shared libraries.\n  virtual void DidExec();\n\n  /// Subclasses of Process should implement this function if they need to do\n  /// anything after a process exec's itself.\n  virtual void DoDidExec() {}\n\n  /// Called before launching to a process.\n  ///\n  /// Allow Process plug-ins to execute some code before launching a process.\n  ///\n  /// \\return\n  ///     Returns an error object.\n  virtual Status WillLaunch(Module *module) { return Status(); }\n\n  /// Launch a new process.\n  ///\n  /// Launch a new process by spawning a new process using \\a exe_module's\n  /// file as the file to launch. Launch details are provided in \\a\n  /// launch_info.\n  ///\n  /// \\param[in] exe_module\n  ///     The module from which to extract the file specification and\n  ///     launch.\n  ///\n  /// \\param[in] launch_info\n  ///     Details (e.g. arguments, stdio redirection, etc.) for the\n  ///     requested launch.\n  ///\n  /// \\return\n  ///     An Status instance indicating success or failure of the\n  ///     operation.\n  virtual Status DoLaunch(Module *exe_module, ProcessLaunchInfo &launch_info) {\n    Status error;\n    error.SetErrorStringWithFormat(\n        \"error: %s does not support launching processes\",\n        GetPluginName().GetCString());\n    return error;\n  }\n\n  /// Called after launching a process.\n  ///\n  /// Allow Process plug-ins to execute some code after launching a process.\n  virtual void DidLaunch() {}\n\n  /// Called before resuming to a process.\n  ///\n  /// Allow Process plug-ins to execute some code before resuming a process.\n  ///\n  /// \\return\n  ///     Returns an error object.\n  virtual Status WillResume() { return Status(); }\n\n  /// Resumes all of a process's threads as configured using the Thread run\n  /// control functions.\n  ///\n  /// Threads for a process should be updated with one of the run control\n  /// actions (resume, step, or suspend) that they should take when the\n  /// process is resumed. If no run control action is given to a thread it\n  /// will be resumed by default.\n  ///\n  /// \\return\n  ///     Returns \\b true if the process successfully resumes using\n  ///     the thread run control actions, \\b false otherwise.\n  ///\n  /// \\see Thread:Resume()\n  /// \\see Thread:Step()\n  /// \\see Thread:Suspend()\n  virtual Status DoResume() {\n    Status error;\n    error.SetErrorStringWithFormat(\n        \"error: %s does not support resuming processes\",\n        GetPluginName().GetCString());\n    return error;\n  }\n\n  /// Called after resuming a process.\n  ///\n  /// Allow Process plug-ins to execute some code after resuming a process.\n  virtual void DidResume() {}\n\n  /// Called before halting to a process.\n  ///\n  /// Allow Process plug-ins to execute some code before halting a process.\n  ///\n  /// \\return\n  ///     Returns an error object.\n  virtual Status WillHalt() { return Status(); }\n\n  /// Halts a running process.\n  ///\n  /// DoHalt must produce one and only one stop StateChanged event if it\n  /// actually stops the process.  If the stop happens through some natural\n  /// event (for instance a SIGSTOP), then forwarding that event will do.\n  /// Otherwise, you must generate the event manually. This function is called\n  /// from the context of the private state thread.\n  ///\n  /// \\param[out] caused_stop\n  ///     If true, then this Halt caused the stop, otherwise, the\n  ///     process was already stopped.\n  ///\n  /// \\return\n  ///     Returns \\b true if the process successfully halts, \\b false\n  ///     otherwise.\n  virtual Status DoHalt(bool &caused_stop) {\n    Status error;\n    error.SetErrorStringWithFormat(\n        \"error: %s does not support halting processes\",\n        GetPluginName().GetCString());\n    return error;\n  }\n\n  /// Called after halting a process.\n  ///\n  /// Allow Process plug-ins to execute some code after halting a process.\n  virtual void DidHalt() {}\n\n  /// Called before detaching from a process.\n  ///\n  /// Allow Process plug-ins to execute some code before detaching from a\n  /// process.\n  ///\n  /// \\return\n  ///     Returns an error object.\n  virtual Status WillDetach() { return Status(); }\n\n  /// Detaches from a running or stopped process.\n  ///\n  /// \\return\n  ///     Returns \\b true if the process successfully detaches, \\b\n  ///     false otherwise.\n  virtual Status DoDetach(bool keep_stopped) {\n    Status error;\n    error.SetErrorStringWithFormat(\n        \"error: %s does not support detaching from processes\",\n        GetPluginName().GetCString());\n    return error;\n  }\n\n  /// Called after detaching from a process.\n  ///\n  /// Allow Process plug-ins to execute some code after detaching from a\n  /// process.\n  virtual void DidDetach() {}\n\n  virtual bool DetachRequiresHalt() { return false; }\n\n  /// Called before sending a signal to a process.\n  ///\n  /// Allow Process plug-ins to execute some code before sending a signal to a\n  /// process.\n  ///\n  /// \\return\n  ///     Returns no error if it is safe to proceed with a call to\n  ///     Process::DoSignal(int), otherwise an error describing what\n  ///     prevents the signal from being sent.\n  virtual Status WillSignal() { return Status(); }\n\n  /// Sends a process a UNIX signal \\a signal.\n  ///\n  /// \\return\n  ///     Returns an error object.\n  virtual Status DoSignal(int signal) {\n    Status error;\n    error.SetErrorStringWithFormat(\n        \"error: %s does not support sending signals to processes\",\n        GetPluginName().GetCString());\n    return error;\n  }\n\n  virtual Status WillDestroy() { return Status(); }\n\n  virtual Status DoDestroy() = 0;\n\n  virtual void DidDestroy() {}\n\n  virtual bool DestroyRequiresHalt() { return true; }\n\n  /// Called after sending a signal to a process.\n  ///\n  /// Allow Process plug-ins to execute some code after sending a signal to a\n  /// process.\n  virtual void DidSignal() {}\n\n  /// Currently called as part of ShouldStop.\n  /// FIXME: Should really happen when the target stops before the\n  /// event is taken from the queue...\n  ///\n  /// This callback is called as the event\n  /// is about to be queued up to allow Process plug-ins to execute some code\n  /// prior to clients being notified that a process was stopped. Common\n  /// operations include updating the thread list, invalidating any thread\n  /// state (registers, stack, etc) prior to letting the notification go out.\n  ///\n  virtual void RefreshStateAfterStop() = 0;\n\n  /// Sometimes the connection to a process can detect the host OS version\n  /// that the process is running on. The current platform should be checked\n  /// first in case the platform is connected, but clients can fall back onto\n  /// this function if the platform fails to identify the host OS version. The\n  /// platform should be checked first in case you are running a simulator\n  /// platform that might itself be running natively, but have different\n  /// heuristics for figuring out which OS is is emulating.\n  ///\n  /// \\return\n  ///     Returns the version tuple of the host OS. In case of failure an empty\n  ///     VersionTuple is returner.\n  virtual llvm::VersionTuple GetHostOSVersion() { return llvm::VersionTuple(); }\n\n  /// \\return the macCatalyst version of the host OS.\n  virtual llvm::VersionTuple GetHostMacCatalystVersion() { return {}; }\n\n  /// Get the target object pointer for this module.\n  ///\n  /// \\return\n  ///     A Target object pointer to the target that owns this\n  ///     module.\n  Target &GetTarget() { return *m_target_wp.lock(); }\n\n  /// Get the const target object pointer for this module.\n  ///\n  /// \\return\n  ///     A const Target object pointer to the target that owns this\n  ///     module.\n  const Target &GetTarget() const { return *m_target_wp.lock(); }\n\n  /// Flush all data in the process.\n  ///\n  /// Flush the memory caches, all threads, and any other cached data in the\n  /// process.\n  ///\n  /// This function can be called after a world changing event like adding a\n  /// new symbol file, or after the process makes a large context switch (from\n  /// boot ROM to booted into an OS).\n  void Flush();\n\n  /// Get accessor for the current process state.\n  ///\n  /// \\return\n  ///     The current state of the process.\n  ///\n  /// \\see lldb::StateType\n  lldb::StateType GetState();\n\n  lldb::ExpressionResults\n  RunThreadPlan(ExecutionContext &exe_ctx, lldb::ThreadPlanSP &thread_plan_sp,\n                const EvaluateExpressionOptions &options,\n                DiagnosticManager &diagnostic_manager);\n\n  static const char *ExecutionResultAsCString(lldb::ExpressionResults result);\n\n  void GetStatus(Stream &ostrm);\n\n  size_t GetThreadStatus(Stream &ostrm, bool only_threads_with_stop_reason,\n                         uint32_t start_frame, uint32_t num_frames,\n                         uint32_t num_frames_with_source,\n                         bool stop_format);\n\n  void SendAsyncInterrupt();\n\n  // Notify this process class that modules got loaded.\n  //\n  // If subclasses override this method, they must call this version before\n  // doing anything in the subclass version of the function.\n  virtual void ModulesDidLoad(ModuleList &module_list);\n\n  /// Retrieve the list of shared libraries that are loaded for this process\n  /// This method is used on pre-macOS 10.12, pre-iOS 10, pre-tvOS 10, pre-\n  /// watchOS 3 systems.  The following two methods are for newer versions of\n  /// those OSes.\n  ///\n  /// For certain platforms, the time it takes for the DynamicLoader plugin to\n  /// read all of the shared libraries out of memory over a slow communication\n  /// channel may be too long.  In that instance, the gdb-remote stub may be\n  /// able to retrieve the necessary information about the solibs out of\n  /// memory and return a concise summary sufficient for the DynamicLoader\n  /// plugin.\n  ///\n  /// \\param [in] image_list_address\n  ///     The address where the table of shared libraries is stored in memory,\n  ///     if that is appropriate for this platform.  Else this may be\n  ///     passed as LLDB_INVALID_ADDRESS.\n  ///\n  /// \\param [in] image_count\n  ///     The number of shared libraries that are present in this process, if\n  ///     that is appropriate for this platofrm  Else this may be passed as\n  ///     LLDB_INVALID_ADDRESS.\n  ///\n  /// \\return\n  ///     A StructuredDataSP object which, if non-empty, will contain the\n  ///     information the DynamicLoader needs to get the initial scan of\n  ///     solibs resolved.\n  virtual lldb_private::StructuredData::ObjectSP\n  GetLoadedDynamicLibrariesInfos(lldb::addr_t image_list_address,\n                                 lldb::addr_t image_count) {\n    return StructuredData::ObjectSP();\n  }\n\n  // On macOS 10.12, tvOS 10, iOS 10, watchOS 3 and newer, debugserver can\n  // return the full list of loaded shared libraries without needing any input.\n  virtual lldb_private::StructuredData::ObjectSP\n  GetLoadedDynamicLibrariesInfos() {\n    return StructuredData::ObjectSP();\n  }\n\n  // On macOS 10.12, tvOS 10, iOS 10, watchOS 3 and newer, debugserver can\n  // return information about binaries given their load addresses.\n  virtual lldb_private::StructuredData::ObjectSP GetLoadedDynamicLibrariesInfos(\n      const std::vector<lldb::addr_t> &load_addresses) {\n    return StructuredData::ObjectSP();\n  }\n\n  // Get information about the library shared cache, if that exists\n  //\n  // On macOS 10.12, tvOS 10, iOS 10, watchOS 3 and newer, debugserver can\n  // return information about the library shared cache (a set of standard\n  // libraries that are loaded at the same location for all processes on a\n  // system) in use.\n  virtual lldb_private::StructuredData::ObjectSP GetSharedCacheInfo() {\n    return StructuredData::ObjectSP();\n  }\n\n  /// Print a user-visible warning about a module being built with\n  /// optimization\n  ///\n  /// Prints a async warning message to the user one time per Module where a\n  /// function is found that was compiled with optimization, per Process.\n  ///\n  /// \\param [in] sc\n  ///     A SymbolContext with eSymbolContextFunction and eSymbolContextModule\n  ///     pre-computed.\n  void PrintWarningOptimization(const SymbolContext &sc);\n\n  /// Print a user-visible warning about a function written in a\n  /// language that this version of LLDB doesn't support.\n  ///\n  /// \\see PrintWarningOptimization\n  void PrintWarningUnsupportedLanguage(const SymbolContext &sc);\n\n  virtual bool GetProcessInfo(ProcessInstanceInfo &info);\n\n  /// Get the exit status for a process.\n  ///\n  /// \\return\n  ///     The process's return code, or -1 if the current process\n  ///     state is not eStateExited.\n  int GetExitStatus();\n\n  /// Get a textual description of what the process exited.\n  ///\n  /// \\return\n  ///     The textual description of why the process exited, or nullptr\n  ///     if there is no description available.\n  const char *GetExitDescription();\n\n  virtual void DidExit() {}\n\n  /// Get the Modification ID of the process.\n  ///\n  /// \\return\n  ///     The modification ID of the process.\n  ProcessModID GetModID() const { return m_mod_id; }\n\n  const ProcessModID &GetModIDRef() const { return m_mod_id; }\n\n  uint32_t GetStopID() const { return m_mod_id.GetStopID(); }\n\n  uint32_t GetResumeID() const { return m_mod_id.GetResumeID(); }\n\n  uint32_t GetLastUserExpressionResumeID() const {\n    return m_mod_id.GetLastUserExpressionResumeID();\n  }\n\n  uint32_t GetLastNaturalStopID() const {\n    return m_mod_id.GetLastNaturalStopID();\n  }\n\n  lldb::EventSP GetStopEventForStopID(uint32_t stop_id) const {\n    return m_mod_id.GetStopEventForStopID(stop_id);\n  }\n\n  /// Set accessor for the process exit status (return code).\n  ///\n  /// Sometimes a child exits and the exit can be detected by global functions\n  /// (signal handler for SIGCHLD for example). This accessor allows the exit\n  /// status to be set from an external source.\n  ///\n  /// Setting this will cause a eStateExited event to be posted to the process\n  /// event queue.\n  ///\n  /// \\param[in] exit_status\n  ///     The value for the process's return code.\n  ///\n  /// \\see lldb::StateType\n  virtual bool SetExitStatus(int exit_status, const char *cstr);\n\n  /// Check if a process is still alive.\n  ///\n  /// \\return\n  ///     Returns \\b true if the process is still valid, \\b false\n  ///     otherwise.\n  virtual bool IsAlive();\n\n  virtual bool IsLiveDebugSession() const { return true; };\n\n  /// Before lldb detaches from a process, it warns the user that they are\n  /// about to lose their debug session. In some cases, this warning doesn't\n  /// need to be emitted -- for instance, with core file debugging where the\n  /// user can reconstruct the \"state\" by simply re-running the debugger on\n  /// the core file.\n  ///\n  /// \\return\n  ///     Returns \\b true if the user should be warned about detaching from\n  ///     this process.\n  virtual bool WarnBeforeDetach() const { return true; }\n\n  /// Read of memory from a process.\n  ///\n  /// This function will read memory from the current process's address space\n  /// and remove any traps that may have been inserted into the memory.\n  ///\n  /// This function is not meant to be overridden by Process subclasses, the\n  /// subclasses should implement Process::DoReadMemory (lldb::addr_t, size_t,\n  /// void *).\n  ///\n  /// \\param[in] vm_addr\n  ///     A virtual load address that indicates where to start reading\n  ///     memory from.\n  ///\n  /// \\param[out] buf\n  ///     A byte buffer that is at least \\a size bytes long that\n  ///     will receive the memory bytes.\n  ///\n  /// \\param[in] size\n  ///     The number of bytes to read.\n  ///\n  /// \\param[out] error\n  ///     An error that indicates the success or failure of this\n  ///     operation. If error indicates success (error.Success()),\n  ///     then the value returned can be trusted, otherwise zero\n  ///     will be returned.\n  ///\n  /// \\return\n  ///     The number of bytes that were actually read into \\a buf. If\n  ///     the returned number is greater than zero, yet less than \\a\n  ///     size, then this function will get called again with \\a\n  ///     vm_addr, \\a buf, and \\a size updated appropriately. Zero is\n  ///     returned in the case of an error.\n  virtual size_t ReadMemory(lldb::addr_t vm_addr, void *buf, size_t size,\n                            Status &error);\n\n  /// Read of memory from a process.\n  ///\n  /// This function has the same semantics of ReadMemory except that it\n  /// bypasses caching.\n  ///\n  /// \\param[in] vm_addr\n  ///     A virtual load address that indicates where to start reading\n  ///     memory from.\n  ///\n  /// \\param[out] buf\n  ///     A byte buffer that is at least \\a size bytes long that\n  ///     will receive the memory bytes.\n  ///\n  /// \\param[in] size\n  ///     The number of bytes to read.\n  ///\n  /// \\param[out] error\n  ///     An error that indicates the success or failure of this\n  ///     operation. If error indicates success (error.Success()),\n  ///     then the value returned can be trusted, otherwise zero\n  ///     will be returned.\n  ///\n  /// \\return\n  ///     The number of bytes that were actually read into \\a buf. If\n  ///     the returned number is greater than zero, yet less than \\a\n  ///     size, then this function will get called again with \\a\n  ///     vm_addr, \\a buf, and \\a size updated appropriately. Zero is\n  ///     returned in the case of an error.\n  size_t ReadMemoryFromInferior(lldb::addr_t vm_addr, void *buf, size_t size,\n                                Status &error);\n\n  /// Read a NULL terminated string from memory\n  ///\n  /// This function will read a cache page at a time until a NULL string\n  /// terminator is found. It will stop reading if an aligned sequence of NULL\n  /// termination \\a type_width bytes is not found before reading \\a\n  /// cstr_max_len bytes.  The results are always guaranteed to be NULL\n  /// terminated, and that no more than (max_bytes - type_width) bytes will be\n  /// read.\n  ///\n  /// \\param[in] vm_addr\n  ///     The virtual load address to start the memory read.\n  ///\n  /// \\param[in] str\n  ///     A character buffer containing at least max_bytes.\n  ///\n  /// \\param[in] max_bytes\n  ///     The maximum number of bytes to read.\n  ///\n  /// \\param[in] error\n  ///     The error status of the read operation.\n  ///\n  /// \\param[in] type_width\n  ///     The size of the null terminator (1 to 4 bytes per\n  ///     character).  Defaults to 1.\n  ///\n  /// \\return\n  ///     The error status or the number of bytes prior to the null terminator.\n  size_t ReadStringFromMemory(lldb::addr_t vm_addr, char *str, size_t max_bytes,\n                              Status &error, size_t type_width = 1);\n\n  /// Read a NULL terminated C string from memory\n  ///\n  /// This function will read a cache page at a time until the NULL\n  /// C string terminator is found. It will stop reading if the NULL\n  /// termination byte isn't found before reading \\a cstr_max_len bytes, and\n  /// the results are always guaranteed to be NULL terminated (at most\n  /// cstr_max_len - 1 bytes will be read).\n  size_t ReadCStringFromMemory(lldb::addr_t vm_addr, char *cstr,\n                               size_t cstr_max_len, Status &error);\n\n  size_t ReadCStringFromMemory(lldb::addr_t vm_addr, std::string &out_str,\n                               Status &error);\n\n  /// Reads an unsigned integer of the specified byte size from process\n  /// memory.\n  ///\n  /// \\param[in] load_addr\n  ///     A load address of the integer to read.\n  ///\n  /// \\param[in] byte_size\n  ///     The size in byte of the integer to read.\n  ///\n  /// \\param[in] fail_value\n  ///     The value to return if we fail to read an integer.\n  ///\n  /// \\param[out] error\n  ///     An error that indicates the success or failure of this\n  ///     operation. If error indicates success (error.Success()),\n  ///     then the value returned can be trusted, otherwise zero\n  ///     will be returned.\n  ///\n  /// \\return\n  ///     The unsigned integer that was read from the process memory\n  ///     space. If the integer was smaller than a uint64_t, any\n  ///     unused upper bytes will be zero filled. If the process\n  ///     byte order differs from the host byte order, the integer\n  ///     value will be appropriately byte swapped into host byte\n  ///     order.\n  uint64_t ReadUnsignedIntegerFromMemory(lldb::addr_t load_addr,\n                                         size_t byte_size, uint64_t fail_value,\n                                         Status &error);\n\n  int64_t ReadSignedIntegerFromMemory(lldb::addr_t load_addr, size_t byte_size,\n                                      int64_t fail_value, Status &error);\n\n  lldb::addr_t ReadPointerFromMemory(lldb::addr_t vm_addr, Status &error);\n\n  bool WritePointerToMemory(lldb::addr_t vm_addr, lldb::addr_t ptr_value,\n                            Status &error);\n\n  /// Actually do the writing of memory to a process.\n  ///\n  /// \\param[in] vm_addr\n  ///     A virtual load address that indicates where to start writing\n  ///     memory to.\n  ///\n  /// \\param[in] buf\n  ///     A byte buffer that is at least \\a size bytes long that\n  ///     contains the data to write.\n  ///\n  /// \\param[in] size\n  ///     The number of bytes to write.\n  ///\n  /// \\param[out] error\n  ///     An error value in case the memory write fails.\n  ///\n  /// \\return\n  ///     The number of bytes that were actually written.\n  virtual size_t DoWriteMemory(lldb::addr_t vm_addr, const void *buf,\n                               size_t size, Status &error) {\n    error.SetErrorStringWithFormat(\n        \"error: %s does not support writing to processes\",\n        GetPluginName().GetCString());\n    return 0;\n  }\n\n  /// Write all or part of a scalar value to memory.\n  ///\n  /// The value contained in \\a scalar will be swapped to match the byte order\n  /// of the process that is being debugged. If \\a size is less than the size\n  /// of scalar, the least significant \\a size bytes from scalar will be\n  /// written. If \\a size is larger than the byte size of scalar, then the\n  /// extra space will be padded with zeros and the scalar value will be\n  /// placed in the least significant bytes in memory.\n  ///\n  /// \\param[in] vm_addr\n  ///     A virtual load address that indicates where to start writing\n  ///     memory to.\n  ///\n  /// \\param[in] scalar\n  ///     The scalar to write to the debugged process.\n  ///\n  /// \\param[in] size\n  ///     This value can be smaller or larger than the scalar value\n  ///     itself. If \\a size is smaller than the size of \\a scalar,\n  ///     the least significant bytes in \\a scalar will be used. If\n  ///     \\a size is larger than the byte size of \\a scalar, then\n  ///     the extra space will be padded with zeros. If \\a size is\n  ///     set to UINT32_MAX, then the size of \\a scalar will be used.\n  ///\n  /// \\param[out] error\n  ///     An error value in case the memory write fails.\n  ///\n  /// \\return\n  ///     The number of bytes that were actually written.\n  size_t WriteScalarToMemory(lldb::addr_t vm_addr, const Scalar &scalar,\n                             size_t size, Status &error);\n\n  size_t ReadScalarIntegerFromMemory(lldb::addr_t addr, uint32_t byte_size,\n                                     bool is_signed, Scalar &scalar,\n                                     Status &error);\n\n  /// Write memory to a process.\n  ///\n  /// This function will write memory to the current process's address space\n  /// and maintain any traps that might be present due to software\n  /// breakpoints.\n  ///\n  /// This function is not meant to be overridden by Process subclasses, the\n  /// subclasses should implement Process::DoWriteMemory (lldb::addr_t,\n  /// size_t, void *).\n  ///\n  /// \\param[in] vm_addr\n  ///     A virtual load address that indicates where to start writing\n  ///     memory to.\n  ///\n  /// \\param[in] buf\n  ///     A byte buffer that is at least \\a size bytes long that\n  ///     contains the data to write.\n  ///\n  /// \\param[in] size\n  ///     The number of bytes to write.\n  ///\n  /// \\return\n  ///     The number of bytes that were actually written.\n  // TODO: change this to take an ArrayRef<uint8_t>\n  size_t WriteMemory(lldb::addr_t vm_addr, const void *buf, size_t size,\n                     Status &error);\n\n  /// Actually allocate memory in the process.\n  ///\n  /// This function will allocate memory in the process's address space.  This\n  /// can't rely on the generic function calling mechanism, since that\n  /// requires this function.\n  ///\n  /// \\param[in] size\n  ///     The size of the allocation requested.\n  ///\n  /// \\return\n  ///     The address of the allocated buffer in the process, or\n  ///     LLDB_INVALID_ADDRESS if the allocation failed.\n\n  virtual lldb::addr_t DoAllocateMemory(size_t size, uint32_t permissions,\n                                        Status &error) {\n    error.SetErrorStringWithFormat(\n        \"error: %s does not support allocating in the debug process\",\n        GetPluginName().GetCString());\n    return LLDB_INVALID_ADDRESS;\n  }\n\n  virtual Status WriteObjectFile(std::vector<ObjectFile::LoadableData> entries);\n\n  /// The public interface to allocating memory in the process.\n  ///\n  /// This function will allocate memory in the process's address space.  This\n  /// can't rely on the generic function calling mechanism, since that\n  /// requires this function.\n  ///\n  /// \\param[in] size\n  ///     The size of the allocation requested.\n  ///\n  /// \\param[in] permissions\n  ///     Or together any of the lldb::Permissions bits.  The permissions on\n  ///     a given memory allocation can't be changed after allocation.  Note\n  ///     that a block that isn't set writable can still be written on from\n  ///     lldb,\n  ///     just not by the process itself.\n  ///\n  /// \\param[in,out] error\n  ///     An error object to fill in if things go wrong.\n  /// \\return\n  ///     The address of the allocated buffer in the process, or\n  ///     LLDB_INVALID_ADDRESS if the allocation failed.\n  lldb::addr_t AllocateMemory(size_t size, uint32_t permissions, Status &error);\n\n  /// The public interface to allocating memory in the process, this also\n  /// clears the allocated memory.\n  ///\n  /// This function will allocate memory in the process's address space.  This\n  /// can't rely on the generic function calling mechanism, since that\n  /// requires this function.\n  ///\n  /// \\param[in] size\n  ///     The size of the allocation requested.\n  ///\n  /// \\param[in] permissions\n  ///     Or together any of the lldb::Permissions bits.  The permissions on\n  ///     a given memory allocation can't be changed after allocation.  Note\n  ///     that a block that isn't set writable can still be written on from\n  ///     lldb,\n  ///     just not by the process itself.\n  ///\n  /// \\param[in,out] error\n  ///     An error object to fill in if things go wrong.\n  ///\n  /// \\return\n  ///     The address of the allocated buffer in the process, or\n  ///     LLDB_INVALID_ADDRESS if the allocation failed.\n\n  lldb::addr_t CallocateMemory(size_t size, uint32_t permissions,\n                               Status &error);\n\n  /// Resolve dynamically loaded indirect functions.\n  ///\n  /// \\param[in] address\n  ///     The load address of the indirect function to resolve.\n  ///\n  /// \\param[out] error\n  ///     An error value in case the resolve fails.\n  ///\n  /// \\return\n  ///     The address of the resolved function.\n  ///     LLDB_INVALID_ADDRESS if the resolution failed.\n  virtual lldb::addr_t ResolveIndirectFunction(const Address *address,\n                                               Status &error);\n\n  /// Locate the memory region that contains load_addr.\n  ///\n  /// If load_addr is within the address space the process has mapped\n  /// range_info will be filled in with the start and end of that range as\n  /// well as the permissions for that range and range_info.GetMapped will\n  /// return true.\n  ///\n  /// If load_addr is outside any mapped region then range_info will have its\n  /// start address set to load_addr and the end of the range will indicate\n  /// the start of the next mapped range or be set to LLDB_INVALID_ADDRESS if\n  /// there are no valid mapped ranges between load_addr and the end of the\n  /// process address space.\n  ///\n  /// GetMemoryRegionInfo will only return an error if it is unimplemented for\n  /// the current process.\n  ///\n  /// \\param[in] load_addr\n  ///     The load address to query the range_info for.\n  ///\n  /// \\param[out] range_info\n  ///     An range_info value containing the details of the range.\n  ///\n  /// \\return\n  ///     An error value.\n  virtual Status GetMemoryRegionInfo(lldb::addr_t load_addr,\n                                     MemoryRegionInfo &range_info) {\n    Status error;\n    error.SetErrorString(\"Process::GetMemoryRegionInfo() not supported\");\n    return error;\n  }\n\n  /// Obtain all the mapped memory regions within this process.\n  ///\n  /// \\param[out] region_list\n  ///     A vector to contain MemoryRegionInfo objects for all mapped\n  ///     ranges.\n  ///\n  /// \\return\n  ///     An error value.\n  virtual Status\n  GetMemoryRegions(lldb_private::MemoryRegionInfos &region_list);\n\n  virtual Status GetWatchpointSupportInfo(uint32_t &num) {\n    Status error;\n    num = 0;\n    error.SetErrorString(\"Process::GetWatchpointSupportInfo() not supported\");\n    return error;\n  }\n\n  virtual Status GetWatchpointSupportInfo(uint32_t &num, bool &after) {\n    Status error;\n    num = 0;\n    after = true;\n    error.SetErrorString(\"Process::GetWatchpointSupportInfo() not supported\");\n    return error;\n  }\n\n  lldb::ModuleSP ReadModuleFromMemory(const FileSpec &file_spec,\n                                      lldb::addr_t header_addr,\n                                      size_t size_to_read = 512);\n\n  /// Attempt to get the attributes for a region of memory in the process.\n  ///\n  /// It may be possible for the remote debug server to inspect attributes for\n  /// a region of memory in the process, such as whether there is a valid page\n  /// of memory at a given address or whether that page is\n  /// readable/writable/executable by the process.\n  ///\n  /// \\param[in] load_addr\n  ///     The address of interest in the process.\n  ///\n  /// \\param[out] permissions\n  ///     If this call returns successfully, this bitmask will have\n  ///     its Permissions bits set to indicate whether the region is\n  ///     readable/writable/executable.  If this call fails, the\n  ///     bitmask values are undefined.\n  ///\n  /// \\return\n  ///     Returns true if it was able to determine the attributes of the\n  ///     memory region.  False if not.\n  virtual bool GetLoadAddressPermissions(lldb::addr_t load_addr,\n                                         uint32_t &permissions);\n\n  /// Determines whether executing JIT-compiled code in this process is\n  /// possible.\n  ///\n  /// \\return\n  ///     True if execution of JIT code is possible; false otherwise.\n  bool CanJIT();\n\n  /// Sets whether executing JIT-compiled code in this process is possible.\n  ///\n  /// \\param[in] can_jit\n  ///     True if execution of JIT code is possible; false otherwise.\n  void SetCanJIT(bool can_jit);\n\n  /// Determines whether executing function calls using the interpreter is\n  /// possible for this process.\n  ///\n  /// \\return\n  ///     True if possible; false otherwise.\n  bool CanInterpretFunctionCalls() { return m_can_interpret_function_calls; }\n\n  /// Sets whether executing function calls using the interpreter is possible\n  /// for this process.\n  ///\n  /// \\param[in] can_interpret_function_calls\n  ///     True if possible; false otherwise.\n  void SetCanInterpretFunctionCalls(bool can_interpret_function_calls) {\n    m_can_interpret_function_calls = can_interpret_function_calls;\n  }\n\n  /// Sets whether executing code in this process is possible. This could be\n  /// either through JIT or interpreting.\n  ///\n  /// \\param[in] can_run_code\n  ///     True if execution of code is possible; false otherwise.\n  void SetCanRunCode(bool can_run_code);\n\n  /// Actually deallocate memory in the process.\n  ///\n  /// This function will deallocate memory in the process's address space that\n  /// was allocated with AllocateMemory.\n  ///\n  /// \\param[in] ptr\n  ///     A return value from AllocateMemory, pointing to the memory you\n  ///     want to deallocate.\n  ///\n  /// \\return\n  ///     \\btrue if the memory was deallocated, \\bfalse otherwise.\n  virtual Status DoDeallocateMemory(lldb::addr_t ptr) {\n    Status error;\n    error.SetErrorStringWithFormat(\n        \"error: %s does not support deallocating in the debug process\",\n        GetPluginName().GetCString());\n    return error;\n  }\n\n  /// The public interface to deallocating memory in the process.\n  ///\n  /// This function will deallocate memory in the process's address space that\n  /// was allocated with AllocateMemory.\n  ///\n  /// \\param[in] ptr\n  ///     A return value from AllocateMemory, pointing to the memory you\n  ///     want to deallocate.\n  ///\n  /// \\return\n  ///     \\btrue if the memory was deallocated, \\bfalse otherwise.\n  Status DeallocateMemory(lldb::addr_t ptr);\n\n  /// Get any available STDOUT.\n  ///\n  /// Calling this method is a valid operation only if all of the following\n  /// conditions are true: 1) The process was launched, and not attached to.\n  /// 2) The process was not launched with eLaunchFlagDisableSTDIO. 3) The\n  /// process was launched without supplying a valid file path\n  ///    for STDOUT.\n  ///\n  /// Note that the implementation will probably need to start a read thread\n  /// in the background to make sure that the pipe is drained and the STDOUT\n  /// buffered appropriately, to prevent the process from deadlocking trying\n  /// to write to a full buffer.\n  ///\n  /// Events will be queued indicating that there is STDOUT available that can\n  /// be retrieved using this function.\n  ///\n  /// \\param[out] buf\n  ///     A buffer that will receive any STDOUT bytes that are\n  ///     currently available.\n  ///\n  /// \\param[in] buf_size\n  ///     The size in bytes for the buffer \\a buf.\n  ///\n  /// \\return\n  ///     The number of bytes written into \\a buf. If this value is\n  ///     equal to \\a buf_size, another call to this function should\n  ///     be made to retrieve more STDOUT data.\n  virtual size_t GetSTDOUT(char *buf, size_t buf_size, Status &error);\n\n  /// Get any available STDERR.\n  ///\n  /// Calling this method is a valid operation only if all of the following\n  /// conditions are true: 1) The process was launched, and not attached to.\n  /// 2) The process was not launched with eLaunchFlagDisableSTDIO. 3) The\n  /// process was launched without supplying a valid file path\n  ///    for STDERR.\n  ///\n  /// Note that the implementation will probably need to start a read thread\n  /// in the background to make sure that the pipe is drained and the STDERR\n  /// buffered appropriately, to prevent the process from deadlocking trying\n  /// to write to a full buffer.\n  ///\n  /// Events will be queued indicating that there is STDERR available that can\n  /// be retrieved using this function.\n  ///\n  /// \\param[in] buf\n  ///     A buffer that will receive any STDERR bytes that are\n  ///     currently available.\n  ///\n  /// \\param[out] buf_size\n  ///     The size in bytes for the buffer \\a buf.\n  ///\n  /// \\return\n  ///     The number of bytes written into \\a buf. If this value is\n  ///     equal to \\a buf_size, another call to this function should\n  ///     be made to retrieve more STDERR data.\n  virtual size_t GetSTDERR(char *buf, size_t buf_size, Status &error);\n\n  /// Puts data into this process's STDIN.\n  ///\n  /// Calling this method is a valid operation only if all of the following\n  /// conditions are true: 1) The process was launched, and not attached to.\n  /// 2) The process was not launched with eLaunchFlagDisableSTDIO. 3) The\n  /// process was launched without supplying a valid file path\n  ///    for STDIN.\n  ///\n  /// \\param[in] buf\n  ///     A buffer that contains the data to write to the process's STDIN.\n  ///\n  /// \\param[in] buf_size\n  ///     The size in bytes for the buffer \\a buf.\n  ///\n  /// \\return\n  ///     The number of bytes written into \\a buf. If this value is\n  ///     less than \\a buf_size, another call to this function should\n  ///     be made to write the rest of the data.\n  virtual size_t PutSTDIN(const char *buf, size_t buf_size, Status &error) {\n    error.SetErrorString(\"stdin unsupported\");\n    return 0;\n  }\n\n  /// Get any available profile data.\n  ///\n  /// \\param[out] buf\n  ///     A buffer that will receive any profile data bytes that are\n  ///     currently available.\n  ///\n  /// \\param[out] buf_size\n  ///     The size in bytes for the buffer \\a buf.\n  ///\n  /// \\return\n  ///     The number of bytes written into \\a buf. If this value is\n  ///     equal to \\a buf_size, another call to this function should\n  ///     be made to retrieve more profile data.\n  virtual size_t GetAsyncProfileData(char *buf, size_t buf_size, Status &error);\n\n  // Process Breakpoints\n  size_t GetSoftwareBreakpointTrapOpcode(BreakpointSite *bp_site);\n\n  virtual Status EnableBreakpointSite(BreakpointSite *bp_site) {\n    Status error;\n    error.SetErrorStringWithFormat(\n        \"error: %s does not support enabling breakpoints\",\n        GetPluginName().GetCString());\n    return error;\n  }\n\n  virtual Status DisableBreakpointSite(BreakpointSite *bp_site) {\n    Status error;\n    error.SetErrorStringWithFormat(\n        \"error: %s does not support disabling breakpoints\",\n        GetPluginName().GetCString());\n    return error;\n  }\n\n  // This is implemented completely using the lldb::Process API. Subclasses\n  // don't need to implement this function unless the standard flow of read\n  // existing opcode, write breakpoint opcode, verify breakpoint opcode doesn't\n  // work for a specific process plug-in.\n  virtual Status EnableSoftwareBreakpoint(BreakpointSite *bp_site);\n\n  // This is implemented completely using the lldb::Process API. Subclasses\n  // don't need to implement this function unless the standard flow of\n  // restoring original opcode in memory and verifying the restored opcode\n  // doesn't work for a specific process plug-in.\n  virtual Status DisableSoftwareBreakpoint(BreakpointSite *bp_site);\n\n  BreakpointSiteList &GetBreakpointSiteList();\n\n  const BreakpointSiteList &GetBreakpointSiteList() const;\n\n  void DisableAllBreakpointSites();\n\n  Status ClearBreakpointSiteByID(lldb::user_id_t break_id);\n\n  lldb::break_id_t CreateBreakpointSite(const lldb::BreakpointLocationSP &owner,\n                                        bool use_hardware);\n\n  Status DisableBreakpointSiteByID(lldb::user_id_t break_id);\n\n  Status EnableBreakpointSiteByID(lldb::user_id_t break_id);\n\n  // BreakpointLocations use RemoveOwnerFromBreakpointSite to remove themselves\n  // from the owner's list of this breakpoint sites.\n  void RemoveOwnerFromBreakpointSite(lldb::user_id_t owner_id,\n                                     lldb::user_id_t owner_loc_id,\n                                     lldb::BreakpointSiteSP &bp_site_sp);\n\n  // Process Watchpoints (optional)\n  virtual Status EnableWatchpoint(Watchpoint *wp, bool notify = true);\n\n  virtual Status DisableWatchpoint(Watchpoint *wp, bool notify = true);\n\n  // Thread Queries\n\n  /// Update the thread list.\n  ///\n  /// This method performs some general clean up before invoking\n  /// \\a DoUpdateThreadList, which should be implemented by each\n  /// process plugin.\n  ///\n  /// \\return\n  ///     \\b true if the new thread list could be generated, \\b false otherwise.\n  bool UpdateThreadList(ThreadList &old_thread_list,\n                        ThreadList &new_thread_list);\n\n  void UpdateThreadListIfNeeded();\n\n  ThreadList &GetThreadList() { return m_thread_list; }\n\n  // When ExtendedBacktraces are requested, the HistoryThreads that are created\n  // need an owner -- they're saved here in the Process.  The threads in this\n  // list are not iterated over - driver programs need to request the extended\n  // backtrace calls starting from a root concrete thread one by one.\n  ThreadList &GetExtendedThreadList() { return m_extended_thread_list; }\n\n  ThreadList::ThreadIterable Threads() { return m_thread_list.Threads(); }\n\n  uint32_t GetNextThreadIndexID(uint64_t thread_id);\n\n  lldb::ThreadSP CreateOSPluginThread(lldb::tid_t tid, lldb::addr_t context);\n\n  // Returns true if an index id has been assigned to a thread.\n  bool HasAssignedIndexIDToThread(uint64_t sb_thread_id);\n\n  // Given a thread_id, it will assign a more reasonable index id for display\n  // to the user. If the thread_id has previously been assigned, the same index\n  // id will be used.\n  uint32_t AssignIndexIDToThread(uint64_t thread_id);\n\n  // Queue Queries\n\n  void UpdateQueueListIfNeeded();\n\n  QueueList &GetQueueList() {\n    UpdateQueueListIfNeeded();\n    return m_queue_list;\n  }\n\n  QueueList::QueueIterable Queues() {\n    UpdateQueueListIfNeeded();\n    return m_queue_list.Queues();\n  }\n\n  // Event Handling\n  lldb::StateType GetNextEvent(lldb::EventSP &event_sp);\n\n  // Returns the process state when it is stopped. If specified, event_sp_ptr\n  // is set to the event which triggered the stop. If wait_always = false, and\n  // the process is already stopped, this function returns immediately. If the\n  // process is hijacked and use_run_lock is true (the default), then this\n  // function releases the run lock after the stop. Setting use_run_lock to\n  // false will avoid this behavior.\n  lldb::StateType\n  WaitForProcessToStop(const Timeout<std::micro> &timeout,\n                       lldb::EventSP *event_sp_ptr = nullptr,\n                       bool wait_always = true,\n                       lldb::ListenerSP hijack_listener = lldb::ListenerSP(),\n                       Stream *stream = nullptr, bool use_run_lock = true);\n\n  uint32_t GetIOHandlerID() const { return m_iohandler_sync.GetValue(); }\n\n  /// Waits for the process state to be running within a given msec timeout.\n  ///\n  /// The main purpose of this is to implement an interlock waiting for\n  /// HandlePrivateEvent to push an IOHandler.\n  ///\n  /// \\param[in] timeout\n  ///     The maximum time length to wait for the process to transition to the\n  ///     eStateRunning state.\n  void SyncIOHandler(uint32_t iohandler_id, const Timeout<std::micro> &timeout);\n\n  lldb::StateType GetStateChangedEvents(\n      lldb::EventSP &event_sp, const Timeout<std::micro> &timeout,\n      lldb::ListenerSP\n          hijack_listener); // Pass an empty ListenerSP to use builtin listener\n\n  /// Centralize the code that handles and prints descriptions for process\n  /// state changes.\n  ///\n  /// \\param[in] event_sp\n  ///     The process state changed event\n  ///\n  /// \\param[in] stream\n  ///     The output stream to get the state change description\n  ///\n  /// \\param[in,out] pop_process_io_handler\n  ///     If this value comes in set to \\b true, then pop the Process IOHandler\n  ///     if needed.\n  ///     Else this variable will be set to \\b true or \\b false to indicate if\n  ///     the process\n  ///     needs to have its process IOHandler popped.\n  ///\n  /// \\return\n  ///     \\b true if the event describes a process state changed event, \\b false\n  ///     otherwise.\n  static bool HandleProcessStateChangedEvent(const lldb::EventSP &event_sp,\n                                             Stream *stream,\n                                             bool &pop_process_io_handler);\n\n  Event *PeekAtStateChangedEvents();\n\n  class ProcessEventHijacker {\n  public:\n    ProcessEventHijacker(Process &process, lldb::ListenerSP listener_sp)\n        : m_process(process) {\n      m_process.HijackProcessEvents(std::move(listener_sp));\n    }\n\n    ~ProcessEventHijacker() { m_process.RestoreProcessEvents(); }\n\n  private:\n    Process &m_process;\n  };\n\n  friend class ProcessEventHijacker;\n  friend class ProcessProperties;\n  /// If you need to ensure that you and only you will hear about some public\n  /// event, then make a new listener, set to listen to process events, and\n  /// then call this with that listener.  Then you will have to wait on that\n  /// listener explicitly for events (rather than using the GetNextEvent &\n  /// WaitFor* calls above.  Be sure to call RestoreProcessEvents when you are\n  /// done.\n  ///\n  /// \\param[in] listener_sp\n  ///     This is the new listener to whom all process events will be delivered.\n  ///\n  /// \\return\n  ///     Returns \\b true if the new listener could be installed,\n  ///     \\b false otherwise.\n  bool HijackProcessEvents(lldb::ListenerSP listener_sp);\n\n  /// Restores the process event broadcasting to its normal state.\n  ///\n  void RestoreProcessEvents();\n\n  bool StateChangedIsHijackedForSynchronousResume();\n\n  bool StateChangedIsExternallyHijacked();\n\n  const lldb::ABISP &GetABI();\n\n  OperatingSystem *GetOperatingSystem() { return m_os_up.get(); }\n\n  std::vector<LanguageRuntime *> GetLanguageRuntimes();\n\n  LanguageRuntime *GetLanguageRuntime(lldb::LanguageType language);\n\n  bool IsPossibleDynamicValue(ValueObject &in_value);\n\n  bool IsRunning() const;\n\n  DynamicCheckerFunctions *GetDynamicCheckers() {\n    return m_dynamic_checkers_up.get();\n  }\n\n  void SetDynamicCheckers(DynamicCheckerFunctions *dynamic_checkers);\n\n/// Prune ThreadPlanStacks for unreported threads.\n///\n/// \\param[in] tid\n///     The tid whose Plan Stack we are seeking to prune.\n///\n/// \\return\n///     \\b true if the TID is found or \\b false if not.\nbool PruneThreadPlansForTID(lldb::tid_t tid);\n\n/// Prune ThreadPlanStacks for all unreported threads.\nvoid PruneThreadPlans();\n\n  /// Find the thread plan stack associated with thread with \\a tid.\n  ///\n  /// \\param[in] tid\n  ///     The tid whose Plan Stack we are seeking.\n  ///\n  /// \\return\n  ///     Returns a ThreadPlan if the TID is found or nullptr if not.\n  ThreadPlanStack *FindThreadPlans(lldb::tid_t tid);\n\n  /// Dump the thread plans associated with thread with \\a tid.\n  ///\n  /// \\param[in,out] strm\n  ///     The stream to which to dump the output\n  ///\n  /// \\param[in] tid\n  ///     The tid whose Plan Stack we are dumping\n  ///\n  /// \\param[in] desc_level\n  ///     How much detail to dump\n  ///\n  /// \\param[in] internal\n  ///     If \\b true dump all plans, if false only user initiated plans\n  ///\n  /// \\param[in] condense_trivial\n  ///     If true, only dump a header if the plan stack is just the base plan.\n  ///\n  /// \\param[in] skip_unreported_plans\n  ///     If true, only dump a plan if it is currently backed by an\n  ///     lldb_private::Thread *.\n  ///\n  /// \\return\n  ///     Returns \\b true if TID was found, \\b false otherwise\n  bool DumpThreadPlansForTID(Stream &strm, lldb::tid_t tid,\n                             lldb::DescriptionLevel desc_level, bool internal,\n                             bool condense_trivial, bool skip_unreported_plans);\n\n  /// Dump all the thread plans for this process.\n  ///\n  /// \\param[in,out] strm\n  ///     The stream to which to dump the output\n  ///\n  /// \\param[in] desc_level\n  ///     How much detail to dump\n  ///\n  /// \\param[in] internal\n  ///     If \\b true dump all plans, if false only user initiated plans\n  ///\n  /// \\param[in] condense_trivial\n  ///     If true, only dump a header if the plan stack is just the base plan.\n  ///\n  /// \\param[in] skip_unreported_plans\n  ///     If true, skip printing all thread plan stacks that don't currently\n  ///     have a backing lldb_private::Thread *.\n  void DumpThreadPlans(Stream &strm, lldb::DescriptionLevel desc_level,\n                       bool internal, bool condense_trivial,\n                       bool skip_unreported_plans);\n\n  /// Call this to set the lldb in the mode where it breaks on new thread\n  /// creations, and then auto-restarts.  This is useful when you are trying\n  /// to run only one thread, but either that thread or the kernel is creating\n  /// new threads in the process.  If you stop when the thread is created, you\n  /// can immediately suspend it, and keep executing only the one thread you\n  /// intend.\n  ///\n  /// \\return\n  ///     Returns \\b true if we were able to start up the notification\n  ///     \\b false otherwise.\n  virtual bool StartNoticingNewThreads() { return true; }\n\n  /// Call this to turn off the stop & notice new threads mode.\n  ///\n  /// \\return\n  ///     Returns \\b true if we were able to start up the notification\n  ///     \\b false otherwise.\n  virtual bool StopNoticingNewThreads() { return true; }\n\n  void SetRunningUserExpression(bool on);\n  void SetRunningUtilityFunction(bool on);\n\n  // lldb::ExecutionContextScope pure virtual functions\n  lldb::TargetSP CalculateTarget() override;\n\n  lldb::ProcessSP CalculateProcess() override { return shared_from_this(); }\n\n  lldb::ThreadSP CalculateThread() override { return lldb::ThreadSP(); }\n\n  lldb::StackFrameSP CalculateStackFrame() override {\n    return lldb::StackFrameSP();\n  }\n\n  void CalculateExecutionContext(ExecutionContext &exe_ctx) override;\n\n  void SetSTDIOFileDescriptor(int file_descriptor);\n\n  // Add a permanent region of memory that should never be read or written to.\n  // This can be used to ensure that memory reads or writes to certain areas of\n  // memory never end up being sent to the DoReadMemory or DoWriteMemory\n  // functions which can improve performance.\n  void AddInvalidMemoryRegion(const LoadRange &region);\n\n  // Remove a permanent region of memory that should never be read or written\n  // to that was previously added with AddInvalidMemoryRegion.\n  bool RemoveInvalidMemoryRange(const LoadRange &region);\n\n  // If the setup code of a thread plan needs to do work that might involve\n  // calling a function in the target, it should not do that work directly in\n  // one of the thread plan functions (DidPush/WillResume) because such work\n  // needs to be handled carefully.  Instead, put that work in a\n  // PreResumeAction callback, and register it with the process.  It will get\n  // done before the actual \"DoResume\" gets called.\n\n  typedef bool(PreResumeActionCallback)(void *);\n\n  void AddPreResumeAction(PreResumeActionCallback callback, void *baton);\n\n  bool RunPreResumeActions();\n\n  void ClearPreResumeActions();\n\n  void ClearPreResumeAction(PreResumeActionCallback callback, void *baton);\n\n  ProcessRunLock &GetRunLock();\n\n  bool CurrentThreadIsPrivateStateThread();\n\n  virtual Status SendEventData(const char *data) {\n    Status return_error(\"Sending an event is not supported for this process.\");\n    return return_error;\n  }\n\n  lldb::ThreadCollectionSP GetHistoryThreads(lldb::addr_t addr);\n\n  lldb::InstrumentationRuntimeSP\n  GetInstrumentationRuntime(lldb::InstrumentationRuntimeType type);\n\n  /// Try to fetch the module specification for a module with the given file\n  /// name and architecture. Process sub-classes have to override this method\n  /// if they support platforms where the Platform object can't get the module\n  /// spec for all module.\n  ///\n  /// \\param[in] module_file_spec\n  ///     The file name of the module to get specification for.\n  ///\n  /// \\param[in] arch\n  ///     The architecture of the module to get specification for.\n  ///\n  /// \\param[out] module_spec\n  ///     The fetched module specification if the return value is\n  ///     \\b true, unchanged otherwise.\n  ///\n  /// \\return\n  ///     Returns \\b true if the module spec fetched successfully,\n  ///     \\b false otherwise.\n  virtual bool GetModuleSpec(const FileSpec &module_file_spec,\n                             const ArchSpec &arch, ModuleSpec &module_spec);\n\n  virtual void PrefetchModuleSpecs(llvm::ArrayRef<FileSpec> module_file_specs,\n                                   const llvm::Triple &triple) {}\n\n  /// Try to find the load address of a file.\n  /// The load address is defined as the address of the first memory region\n  /// what contains data mapped from the specified file.\n  ///\n  /// \\param[in] file\n  ///     The name of the file whose load address we are looking for\n  ///\n  /// \\param[out] is_loaded\n  ///     \\b True if the file is loaded into the memory and false\n  ///     otherwise.\n  ///\n  /// \\param[out] load_addr\n  ///     The load address of the file if it is loaded into the\n  ///     processes address space, LLDB_INVALID_ADDRESS otherwise.\n  virtual Status GetFileLoadAddress(const FileSpec &file, bool &is_loaded,\n                                    lldb::addr_t &load_addr) {\n    return Status(\"Not supported\");\n  }\n\n  size_t AddImageToken(lldb::addr_t image_ptr);\n\n  lldb::addr_t GetImagePtrFromToken(size_t token) const;\n\n  void ResetImageToken(size_t token);\n\n  /// Find the next branch instruction to set a breakpoint on\n  ///\n  /// When instruction stepping through a source line, instead of stepping\n  /// through each instruction, we can put a breakpoint on the next branch\n  /// instruction (within the range of instructions we are stepping through)\n  /// and continue the process to there, yielding significant performance\n  /// benefits over instruction stepping.\n  ///\n  /// \\param[in] default_stop_addr\n  ///     The address of the instruction where lldb would put a\n  ///     breakpoint normally.\n  ///\n  /// \\param[in] range_bounds\n  ///     The range which the breakpoint must be contained within.\n  ///     Typically a source line.\n  ///\n  /// \\return\n  ///     The address of the next branch instruction, or the end of\n  ///     the range provided in range_bounds.  If there are any\n  ///     problems with the disassembly or getting the instructions,\n  ///     the original default_stop_addr will be returned.\n  Address AdvanceAddressToNextBranchInstruction(Address default_stop_addr,\n                                                AddressRange range_bounds);\n\n  /// Configure asynchronous structured data feature.\n  ///\n  /// Each Process type that supports using an asynchronous StructuredData\n  /// feature should implement this to enable/disable/configure the feature.\n  /// The default implementation here will always return an error indiciating\n  /// the feature is unsupported.\n  ///\n  /// StructuredDataPlugin implementations will call this to configure a\n  /// feature that has been reported as being supported.\n  ///\n  /// \\param[in] type_name\n  ///     The StructuredData type name as previously discovered by\n  ///     the Process-derived instance.\n  ///\n  /// \\param[in] config_sp\n  ///     Configuration data for the feature being enabled.  This config\n  ///     data, which may be null, will be passed along to the feature\n  ///     to process.  The feature will dictate whether this is a dictionary,\n  ///     an array or some other object.  If the feature needs to be\n  ///     set up properly before it can be enabled, then the config should\n  ///     also take an enable/disable flag.\n  ///\n  /// \\return\n  ///     Returns the result of attempting to configure the feature.\n  virtual Status\n  ConfigureStructuredData(ConstString type_name,\n                          const StructuredData::ObjectSP &config_sp);\n\n  /// Broadcasts the given structured data object from the given plugin.\n  ///\n  /// StructuredDataPlugin instances can use this to optionally broadcast any\n  /// of their data if they want to make it available for clients.  The data\n  /// will come in on the structured data event bit\n  /// (eBroadcastBitStructuredData).\n  ///\n  /// \\param[in] object_sp\n  ///     The structured data object to broadcast.\n  ///\n  /// \\param[in] plugin_sp\n  ///     The plugin that will be reported in the event's plugin\n  ///     parameter.\n  void BroadcastStructuredData(const StructuredData::ObjectSP &object_sp,\n                               const lldb::StructuredDataPluginSP &plugin_sp);\n\n  /// Returns the StructuredDataPlugin associated with a given type name, if\n  /// there is one.\n  ///\n  /// There will only be a plugin for a given StructuredDataType if the\n  /// debugged process monitor claims that the feature is supported. This is\n  /// one way to tell whether a feature is available.\n  ///\n  /// \\return\n  ///     The plugin if one is available for the specified feature;\n  ///     otherwise, returns an empty shared pointer.\n  lldb::StructuredDataPluginSP\n  GetStructuredDataPlugin(ConstString type_name) const;\n\n  /// Starts tracing with the configuration provided in options. To enable\n  /// tracing on the complete process the thread_id in the options should be\n  /// set to LLDB_INVALID_THREAD_ID. The API returns a user_id which is needed\n  /// by other API's that manipulate the trace instance. The handling of\n  /// erroneous or unsupported configuration is left to the trace technology\n  /// implementations in the server, as they could be returned as an error, or\n  /// rounded to a valid configuration to start tracing. In the later case the\n  /// GetTraceConfig should supply the actual used trace configuration.\n  virtual lldb::user_id_t StartTrace(const TraceOptions &options,\n                                     Status &error) {\n    error.SetErrorString(\"Not implemented\");\n    return LLDB_INVALID_UID;\n  }\n\n  /// Stops the tracing instance leading to deletion of the trace data. The\n  /// tracing instance is identified by the user_id which is obtained when\n  /// tracing was started from the StartTrace. In case tracing of the complete\n  /// process needs to be stopped the thread_id should be set to\n  /// LLDB_INVALID_THREAD_ID. In the other case that tracing on an individual\n  /// thread needs to be stopped a thread_id can be supplied.\n  virtual Status StopTrace(lldb::user_id_t uid, lldb::tid_t thread_id) {\n    return Status(\"Not implemented\");\n  }\n\n  /// Provides the trace data as raw bytes. A buffer needs to be supplied to\n  /// copy the trace data. The exact behavior of this API may vary across\n  /// trace technology, as some may support partial reading of the trace data\n  /// from a specified offset while some may not. The thread_id should be used\n  /// to select a particular thread for trace extraction.\n  virtual Status GetData(lldb::user_id_t uid, lldb::tid_t thread_id,\n                         llvm::MutableArrayRef<uint8_t> &buffer,\n                         size_t offset = 0) {\n    return Status(\"Not implemented\");\n  }\n\n  /// Similar API as above except for obtaining meta data\n  virtual Status GetMetaData(lldb::user_id_t uid, lldb::tid_t thread_id,\n                             llvm::MutableArrayRef<uint8_t> &buffer,\n                             size_t offset = 0) {\n    return Status(\"Not implemented\");\n  }\n\n  /// API to obtain the trace configuration used by a trace instance.\n  /// Configurations that may be specific to some trace technology should be\n  /// stored in the custom parameters. The options are transported to the\n  /// server, which shall interpret accordingly. The thread_id can be\n  /// specified in the options to obtain the configuration used by a specific\n  /// thread. The thread_id specified should also match the uid otherwise an\n  /// error will be returned.\n  virtual Status GetTraceConfig(lldb::user_id_t uid, TraceOptions &options) {\n    return Status(\"Not implemented\");\n  }\n\n  ///  Get the processor tracing type supported for this process.\n  ///  Responses might be different depending on the architecture and\n  ///  capabilities of the underlying OS.\n  ///\n  ///  \\return\n  ///     The supported trace type or an \\a llvm::Error if tracing is\n  ///     not supported for the inferior.\n  virtual llvm::Expected<TraceTypeInfo> GetSupportedTraceType();\n\n  // This calls a function of the form \"void * (*)(void)\".\n  bool CallVoidArgVoidPtrReturn(const Address *address,\n                                lldb::addr_t &returned_func,\n                                bool trap_exceptions = false);\n\nprotected:\n  /// Update the thread list following process plug-in's specific logic.\n  ///\n  /// This method should only be invoked by \\a UpdateThreadList.\n  ///\n  /// \\return\n  ///     \\b true if the new thread list could be generated, \\b false otherwise.\n  virtual bool DoUpdateThreadList(ThreadList &old_thread_list,\n                                  ThreadList &new_thread_list) = 0;\n\n  /// Actually do the reading of memory from a process.\n  ///\n  /// Subclasses must override this function and can return fewer bytes than\n  /// requested when memory requests are too large. This class will break up\n  /// the memory requests and keep advancing the arguments along as needed.\n  ///\n  /// \\param[in] vm_addr\n  ///     A virtual load address that indicates where to start reading\n  ///     memory from.\n  ///\n  /// \\param[in] size\n  ///     The number of bytes to read.\n  ///\n  /// \\param[out] buf\n  ///     A byte buffer that is at least \\a size bytes long that\n  ///     will receive the memory bytes.\n  ///\n  /// \\param[out] error\n  ///     An error that indicates the success or failure of this\n  ///     operation. If error indicates success (error.Success()),\n  ///     then the value returned can be trusted, otherwise zero\n  ///     will be returned.\n  ///\n  /// \\return\n  ///     The number of bytes that were actually read into \\a buf.\n  ///     Zero is returned in the case of an error.\n  virtual size_t DoReadMemory(lldb::addr_t vm_addr, void *buf, size_t size,\n                              Status &error) = 0;\n\n  void SetState(lldb::EventSP &event_sp);\n\n  lldb::StateType GetPrivateState();\n\n  /// The \"private\" side of resuming a process.  This doesn't alter the state\n  /// of m_run_lock, but just causes the process to resume.\n  ///\n  /// \\return\n  ///     An Status object describing the success or failure of the resume.\n  Status PrivateResume();\n\n  // Called internally\n  void CompleteAttach();\n\n  /// Print a user-visible warning one time per Process\n  ///\n  /// A facility for printing a warning to the user once per repeat_key.\n  ///\n  /// warning_type is from the Process::Warnings enums. repeat_key is a\n  /// pointer value that will be used to ensure that the warning message is\n  /// not printed multiple times.  For instance, with a warning about a\n  /// function being optimized, you can pass the CompileUnit pointer to have\n  /// the warning issued for only the first function in a CU, or the Function\n  /// pointer to have it issued once for every function, or a Module pointer\n  /// to have it issued once per Module.\n  ///\n  /// Classes outside Process should call a specific PrintWarning method so\n  /// that the warning strings are all centralized in Process, instead of\n  /// calling PrintWarning() directly.\n  ///\n  /// \\param [in] warning_type\n  ///     One of the types defined in Process::Warnings.\n  ///\n  /// \\param [in] repeat_key\n  ///     A pointer value used to ensure that the warning is only printed once.\n  ///     May be nullptr, indicating that the warning is printed unconditionally\n  ///     every time.\n  ///\n  /// \\param [in] fmt\n  ///     printf style format string\n  void PrintWarning(uint64_t warning_type, const void *repeat_key,\n                    const char *fmt, ...) __attribute__((format(printf, 4, 5)));\n\n  // NextEventAction provides a way to register an action on the next event\n  // that is delivered to this process.  There is currently only one next event\n  // action allowed in the process at one time.  If a new \"NextEventAction\" is\n  // added while one is already present, the old action will be discarded (with\n  // HandleBeingUnshipped called after it is discarded.)\n  //\n  // If you want to resume the process as a result of a resume action, call\n  // RequestResume, don't call Resume directly.\n  class NextEventAction {\n  public:\n    enum EventActionResult {\n      eEventActionSuccess,\n      eEventActionRetry,\n      eEventActionExit\n    };\n\n    NextEventAction(Process *process) : m_process(process) {}\n\n    virtual ~NextEventAction() = default;\n\n    virtual EventActionResult PerformAction(lldb::EventSP &event_sp) = 0;\n    virtual void HandleBeingUnshipped() {}\n    virtual EventActionResult HandleBeingInterrupted() = 0;\n    virtual const char *GetExitString() = 0;\n    void RequestResume() { m_process->m_resume_requested = true; }\n\n  protected:\n    Process *m_process;\n  };\n\n  void SetNextEventAction(Process::NextEventAction *next_event_action) {\n    if (m_next_event_action_up.get())\n      m_next_event_action_up->HandleBeingUnshipped();\n\n    m_next_event_action_up.reset(next_event_action);\n  }\n\n  // This is the completer for Attaching:\n  class AttachCompletionHandler : public NextEventAction {\n  public:\n    AttachCompletionHandler(Process *process, uint32_t exec_count);\n\n    ~AttachCompletionHandler() override = default;\n\n    EventActionResult PerformAction(lldb::EventSP &event_sp) override;\n    EventActionResult HandleBeingInterrupted() override;\n    const char *GetExitString() override;\n\n  private:\n    uint32_t m_exec_count;\n    std::string m_exit_string;\n  };\n\n  bool PrivateStateThreadIsValid() const {\n    lldb::StateType state = m_private_state.GetValue();\n    return state != lldb::eStateInvalid && state != lldb::eStateDetached &&\n           state != lldb::eStateExited && m_private_state_thread.IsJoinable();\n  }\n\n  void ForceNextEventDelivery() { m_force_next_event_delivery = true; }\n\n  /// Loads any plugins associated with asynchronous structured data and maps\n  /// the relevant supported type name to the plugin.\n  ///\n  /// Processes can receive asynchronous structured data from the process\n  /// monitor.  This method will load and map any structured data plugins that\n  /// support the given set of supported type names. Later, if any of these\n  /// features are enabled, the process monitor is free to generate\n  /// asynchronous structured data.  The data must come in as a single \\b\n  /// StructuredData::Dictionary.  That dictionary must have a string field\n  /// named 'type', with a value that equals the relevant type name string\n  /// (one of the values in \\b supported_type_names).\n  ///\n  /// \\param[in] supported_type_names\n  ///     An array of zero or more type names.  Each must be unique.\n  ///     For each entry in the list, a StructuredDataPlugin will be\n  ///     searched for that supports the structured data type name.\n  void MapSupportedStructuredDataPlugins(\n      const StructuredData::Array &supported_type_names);\n\n  /// Route the incoming structured data dictionary to the right plugin.\n  ///\n  /// The incoming structured data must be a dictionary, and it must have a\n  /// key named 'type' that stores a string value.  The string value must be\n  /// the name of the structured data feature that knows how to handle it.\n  ///\n  /// \\param[in] object_sp\n  ///     When non-null and pointing to a dictionary, the 'type'\n  ///     key's string value is used to look up the plugin that\n  ///     was registered for that structured data type.  It then\n  ///     calls the following method on the StructuredDataPlugin\n  ///     instance:\n  ///\n  ///     virtual void\n  ///     HandleArrivalOfStructuredData(Process &process,\n  ///                                   ConstString type_name,\n  ///                                   const StructuredData::ObjectSP\n  ///                                   &object_sp)\n  ///\n  /// \\return\n  ///     True if the structured data was routed to a plugin; otherwise,\n  ///     false.\n  bool RouteAsyncStructuredData(const StructuredData::ObjectSP object_sp);\n\n  // Type definitions\n  typedef std::map<lldb::LanguageType, lldb::LanguageRuntimeSP>\n      LanguageRuntimeCollection;\n  typedef std::unordered_set<const void *> WarningsPointerSet;\n  typedef std::map<uint64_t, WarningsPointerSet> WarningsCollection;\n\n  struct PreResumeCallbackAndBaton {\n    bool (*callback)(void *);\n    void *baton;\n    PreResumeCallbackAndBaton(PreResumeActionCallback in_callback,\n                              void *in_baton)\n        : callback(in_callback), baton(in_baton) {}\n    bool operator== (const PreResumeCallbackAndBaton &rhs) {\n      return callback == rhs.callback && baton == rhs.baton;\n    }\n  };\n\n  using StructuredDataPluginMap =\n      std::map<ConstString, lldb::StructuredDataPluginSP>;\n\n  // Member variables\n  std::weak_ptr<Target> m_target_wp; ///< The target that owns this process.\n  lldb::pid_t m_pid = LLDB_INVALID_PROCESS_ID;\n  ThreadSafeValue<lldb::StateType> m_public_state;\n  ThreadSafeValue<lldb::StateType>\n      m_private_state;                     // The actual state of our process\n  Broadcaster m_private_state_broadcaster; // This broadcaster feeds state\n                                           // changed events into the private\n                                           // state thread's listener.\n  Broadcaster m_private_state_control_broadcaster; // This is the control\n                                                   // broadcaster, used to\n                                                   // pause, resume & stop the\n                                                   // private state thread.\n  lldb::ListenerSP m_private_state_listener_sp; // This is the listener for the\n                                                // private state thread.\n  HostThread m_private_state_thread; ///< Thread ID for the thread that watches\n                                     ///internal state events\n  ProcessModID m_mod_id; ///< Tracks the state of the process over stops and\n                         ///other alterations.\n  uint32_t m_process_unique_id; ///< Each lldb_private::Process class that is\n                                ///created gets a unique integer ID that\n                                ///increments with each new instance\n  uint32_t m_thread_index_id;   ///< Each thread is created with a 1 based index\n                                ///that won't get re-used.\n  std::map<uint64_t, uint32_t> m_thread_id_to_index_id_map;\n  int m_exit_status; ///< The exit status of the process, or -1 if not set.\n  std::string m_exit_string; ///< A textual description of why a process exited.\n  std::mutex m_exit_status_mutex; ///< Mutex so m_exit_status m_exit_string can\n                                  ///be safely accessed from multiple threads\n  std::recursive_mutex m_thread_mutex;\n  ThreadList m_thread_list_real; ///< The threads for this process as are known\n                                 ///to the protocol we are debugging with\n  ThreadList m_thread_list; ///< The threads for this process as the user will\n                            ///see them. This is usually the same as\n  ///< m_thread_list_real, but might be different if there is an OS plug-in\n  ///creating memory threads\n  ThreadPlanStackMap m_thread_plans; ///< This is the list of thread plans for\n                                     /// threads in m_thread_list, as well as\n                                     /// threads we knew existed, but haven't\n                                     /// determined that they have died yet.\n  ThreadList m_extended_thread_list; ///< Owner for extended threads that may be\n                                     ///generated, cleared on natural stops\n  uint32_t m_extended_thread_stop_id; ///< The natural stop id when\n                                      ///extended_thread_list was last updated\n  QueueList\n      m_queue_list; ///< The list of libdispatch queues at a given stop point\n  uint32_t m_queue_list_stop_id; ///< The natural stop id when queue list was\n                                 ///last fetched\n  std::vector<Notifications> m_notifications; ///< The list of notifications\n                                              ///that this process can deliver.\n  std::vector<lldb::addr_t> m_image_tokens;\n  lldb::ListenerSP m_listener_sp; ///< Shared pointer to the listener used for\n                                  ///public events.  Can not be empty.\n  BreakpointSiteList m_breakpoint_site_list; ///< This is the list of breakpoint\n                                             ///locations we intend to insert in\n                                             ///the target.\n  lldb::DynamicLoaderUP m_dyld_up;\n  lldb::JITLoaderListUP m_jit_loaders_up;\n  lldb::DynamicCheckerFunctionsUP m_dynamic_checkers_up; ///< The functions used\n                                                         /// by the expression\n                                                         /// parser to validate\n                                                         /// data that\n                                                         /// expressions use.\n  lldb::OperatingSystemUP m_os_up;\n  lldb::SystemRuntimeUP m_system_runtime_up;\n  lldb::UnixSignalsSP\n      m_unix_signals_sp; /// This is the current signal set for this process.\n  lldb::ABISP m_abi_sp;\n  lldb::IOHandlerSP m_process_input_reader;\n  Communication m_stdio_communication;\n  std::recursive_mutex m_stdio_communication_mutex;\n  bool m_stdin_forward; /// Remember if stdin must be forwarded to remote debug\n                        /// server\n  std::string m_stdout_data;\n  std::string m_stderr_data;\n  std::recursive_mutex m_profile_data_comm_mutex;\n  std::vector<std::string> m_profile_data;\n  Predicate<uint32_t> m_iohandler_sync;\n  MemoryCache m_memory_cache;\n  AllocatedMemoryCache m_allocated_memory_cache;\n  bool m_should_detach; /// Should we detach if the process object goes away\n                        /// with an explicit call to Kill or Detach?\n  LanguageRuntimeCollection m_language_runtimes;\n  std::recursive_mutex m_language_runtimes_mutex;\n  InstrumentationRuntimeCollection m_instrumentation_runtimes;\n  std::unique_ptr<NextEventAction> m_next_event_action_up;\n  std::vector<PreResumeCallbackAndBaton> m_pre_resume_actions;\n  ProcessRunLock m_public_run_lock;\n  ProcessRunLock m_private_run_lock;\n  bool m_currently_handling_do_on_removals;\n  bool m_resume_requested; // If m_currently_handling_event or\n                           // m_currently_handling_do_on_removals are true,\n                           // Resume will only request a resume, using this\n                           // flag to check.\n\n  /// This is set at the beginning of Process::Finalize() to stop functions\n  /// from looking up or creating things during or after a finalize call.\n  std::atomic<bool> m_finalizing;\n\n  bool m_clear_thread_plans_on_stop;\n  bool m_force_next_event_delivery;\n  lldb::StateType m_last_broadcast_state; /// This helps with the Public event\n                                          /// coalescing in\n                                          /// ShouldBroadcastEvent.\n  std::map<lldb::addr_t, lldb::addr_t> m_resolved_indirect_addresses;\n  bool m_destroy_in_process;\n  bool m_can_interpret_function_calls;  // Some targets, e.g the OSX kernel,\n                                        // don't support the ability to modify\n                                        // the stack.\n  WarningsCollection m_warnings_issued; // A set of object pointers which have\n                                        // already had warnings printed\n  std::mutex m_run_thread_plan_lock;\n  StructuredDataPluginMap m_structured_data_plugin_map;\n\n  enum { eCanJITDontKnow = 0, eCanJITYes, eCanJITNo } m_can_jit;\n\n  std::unique_ptr<UtilityFunction> m_dlopen_utility_func_up;\n  llvm::once_flag m_dlopen_utility_func_flag_once;\n\n  size_t RemoveBreakpointOpcodesFromBuffer(lldb::addr_t addr, size_t size,\n                                           uint8_t *buf) const;\n\n  void SynchronouslyNotifyStateChanged(lldb::StateType state);\n\n  void SetPublicState(lldb::StateType new_state, bool restarted);\n\n  void SetPrivateState(lldb::StateType state);\n\n  bool StartPrivateStateThread(bool is_secondary_thread = false);\n\n  void StopPrivateStateThread();\n\n  void PausePrivateStateThread();\n\n  void ResumePrivateStateThread();\n\nprivate:\n  struct PrivateStateThreadArgs {\n    PrivateStateThreadArgs(Process *p, bool s)\n        : process(p), is_secondary_thread(s){};\n    Process *process;\n    bool is_secondary_thread;\n  };\n\n  // arg is a pointer to a new'ed PrivateStateThreadArgs structure.\n  // PrivateStateThread will free it for you.\n  static lldb::thread_result_t PrivateStateThread(void *arg);\n\n  // The starts up the private state thread that will watch for events from the\n  // debugee. Pass true for is_secondary_thread in the case where you have to\n  // temporarily spin up a secondary state thread to handle events from a hand-\n  // called function on the primary private state thread.\n\n  lldb::thread_result_t RunPrivateStateThread(bool is_secondary_thread);\n\nprotected:\n  void HandlePrivateEvent(lldb::EventSP &event_sp);\n\n  Status HaltPrivate();\n\n  lldb::StateType WaitForProcessStopPrivate(lldb::EventSP &event_sp,\n                                            const Timeout<std::micro> &timeout);\n\n  // This waits for both the state change broadcaster, and the control\n  // broadcaster. If control_only, it only waits for the control broadcaster.\n\n  bool GetEventsPrivate(lldb::EventSP &event_sp,\n                        const Timeout<std::micro> &timeout, bool control_only);\n\n  lldb::StateType\n  GetStateChangedEventsPrivate(lldb::EventSP &event_sp,\n                               const Timeout<std::micro> &timeout);\n\n  size_t WriteMemoryPrivate(lldb::addr_t addr, const void *buf, size_t size,\n                            Status &error);\n\n  void AppendSTDOUT(const char *s, size_t len);\n\n  void AppendSTDERR(const char *s, size_t len);\n\n  void BroadcastAsyncProfileData(const std::string &one_profile_data);\n\n  static void STDIOReadThreadBytesReceived(void *baton, const void *src,\n                                           size_t src_len);\n\n  bool PushProcessIOHandler();\n\n  bool PopProcessIOHandler();\n\n  bool ProcessIOHandlerIsActive();\n\n  bool ProcessIOHandlerExists() const {\n    return static_cast<bool>(m_process_input_reader);\n  }\n\n  Status StopForDestroyOrDetach(lldb::EventSP &exit_event_sp);\n\n  virtual Status UpdateAutomaticSignalFiltering();\n\n  void LoadOperatingSystemPlugin(bool flush);\n\nprivate:\n  Status DestroyImpl(bool force_kill);\n\n  /// This is the part of the event handling that for a process event. It\n  /// decides what to do with the event and returns true if the event needs to\n  /// be propagated to the user, and false otherwise. If the event is not\n  /// propagated, this call will most likely set the target to executing\n  /// again. There is only one place where this call should be called,\n  /// HandlePrivateEvent. Don't call it from anywhere else...\n  ///\n  /// \\param[in] event_ptr\n  ///     This is the event we are handling.\n  ///\n  /// \\return\n  ///     Returns \\b true if the event should be reported to the\n  ///     user, \\b false otherwise.\n  bool ShouldBroadcastEvent(Event *event_ptr);\n\n  void ControlPrivateStateThread(uint32_t signal);\n\n  Process(const Process &) = delete;\n  const Process &operator=(const Process &) = delete;\n};\n\n/// RAII guard that should be acquired when an utility function is called within\n/// a given process.\nclass UtilityFunctionScope {\n  Process *m_process;\n\npublic:\n  UtilityFunctionScope(Process *p) : m_process(p) {\n    if (m_process)\n      m_process->SetRunningUtilityFunction(true);\n  }\n  ~UtilityFunctionScope() {\n    if (m_process)\n      m_process->SetRunningUtilityFunction(false);\n  }\n};\n\n} // namespace lldb_private\n\n#endif // LLDB_TARGET_PROCESS_H\n"}, "28": {"id": 28, "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Target/Target.h", "content": "//===-- Target.h ------------------------------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLDB_TARGET_TARGET_H\n#define LLDB_TARGET_TARGET_H\n\n#include <list>\n#include <map>\n#include <memory>\n#include <string>\n#include <vector>\n\n#include \"lldb/Breakpoint/BreakpointList.h\"\n#include \"lldb/Breakpoint/BreakpointName.h\"\n#include \"lldb/Breakpoint/WatchpointList.h\"\n#include \"lldb/Core/Architecture.h\"\n#include \"lldb/Core/Disassembler.h\"\n#include \"lldb/Core/ModuleList.h\"\n#include \"lldb/Core/UserSettingsController.h\"\n#include \"lldb/Expression/Expression.h\"\n#include \"lldb/Host/ProcessLaunchInfo.h\"\n#include \"lldb/Symbol/TypeSystem.h\"\n#include \"lldb/Target/ExecutionContextScope.h\"\n#include \"lldb/Target/PathMappingList.h\"\n#include \"lldb/Target/SectionLoadHistory.h\"\n#include \"lldb/Target/ThreadSpec.h\"\n#include \"lldb/Utility/ArchSpec.h\"\n#include \"lldb/Utility/Broadcaster.h\"\n#include \"lldb/Utility/LLDBAssert.h\"\n#include \"lldb/Utility/Timeout.h\"\n#include \"lldb/lldb-public.h\"\n\nnamespace lldb_private {\n\nclass ClangModulesDeclVendor;\n\nOptionEnumValues GetDynamicValueTypes();\n\nenum InlineStrategy {\n  eInlineBreakpointsNever = 0,\n  eInlineBreakpointsHeaders,\n  eInlineBreakpointsAlways\n};\n\nenum LoadScriptFromSymFile {\n  eLoadScriptFromSymFileTrue,\n  eLoadScriptFromSymFileFalse,\n  eLoadScriptFromSymFileWarn\n};\n\nenum LoadCWDlldbinitFile {\n  eLoadCWDlldbinitTrue,\n  eLoadCWDlldbinitFalse,\n  eLoadCWDlldbinitWarn\n};\n\nenum LoadDependentFiles {\n  eLoadDependentsDefault,\n  eLoadDependentsYes,\n  eLoadDependentsNo,\n};\n\nenum ImportStdModule {\n  eImportStdModuleFalse,\n  eImportStdModuleFallback,\n  eImportStdModuleTrue,\n};\n\nclass TargetExperimentalProperties : public Properties {\npublic:\n  TargetExperimentalProperties();\n};\n\nclass TargetProperties : public Properties {\npublic:\n  TargetProperties(Target *target);\n\n  ~TargetProperties() override;\n\n  ArchSpec GetDefaultArchitecture() const;\n\n  void SetDefaultArchitecture(const ArchSpec &arch);\n\n  bool GetMoveToNearestCode() const;\n\n  lldb::DynamicValueType GetPreferDynamicValue() const;\n\n  bool SetPreferDynamicValue(lldb::DynamicValueType d);\n\n  bool GetPreloadSymbols() const;\n\n  void SetPreloadSymbols(bool b);\n\n  bool GetDisableASLR() const;\n\n  void SetDisableASLR(bool b);\n\n  bool GetInheritTCC() const;\n\n  void SetInheritTCC(bool b);\n\n  bool GetDetachOnError() const;\n\n  void SetDetachOnError(bool b);\n\n  bool GetDisableSTDIO() const;\n\n  void SetDisableSTDIO(bool b);\n\n  const char *GetDisassemblyFlavor() const;\n\n  InlineStrategy GetInlineStrategy() const;\n\n  llvm::StringRef GetArg0() const;\n\n  void SetArg0(llvm::StringRef arg);\n\n  bool GetRunArguments(Args &args) const;\n\n  void SetRunArguments(const Args &args);\n\n  Environment GetEnvironment() const;\n  void SetEnvironment(Environment env);\n\n  bool GetSkipPrologue() const;\n\n  PathMappingList &GetSourcePathMap() const;\n\n  FileSpecList GetExecutableSearchPaths();\n\n  void AppendExecutableSearchPaths(const FileSpec &);\n\n  FileSpecList GetDebugFileSearchPaths();\n\n  FileSpecList GetClangModuleSearchPaths();\n\n  bool GetEnableAutoImportClangModules() const;\n\n  ImportStdModule GetImportStdModule() const;\n\n  bool GetEnableAutoApplyFixIts() const;\n\n  uint64_t GetNumberOfRetriesWithFixits() const;\n\n  bool GetEnableNotifyAboutFixIts() const;\n\n  bool GetEnableSaveObjects() const;\n\n  bool GetEnableSyntheticValue() const;\n\n  uint32_t GetMaxZeroPaddingInFloatFormat() const;\n\n  uint32_t GetMaximumNumberOfChildrenToDisplay() const;\n\n  uint32_t GetMaximumSizeOfStringSummary() const;\n\n  uint32_t GetMaximumMemReadSize() const;\n\n  FileSpec GetStandardInputPath() const;\n  FileSpec GetStandardErrorPath() const;\n  FileSpec GetStandardOutputPath() const;\n\n  void SetStandardInputPath(llvm::StringRef path);\n  void SetStandardOutputPath(llvm::StringRef path);\n  void SetStandardErrorPath(llvm::StringRef path);\n\n  void SetStandardInputPath(const char *path) = delete;\n  void SetStandardOutputPath(const char *path) = delete;\n  void SetStandardErrorPath(const char *path) = delete;\n\n  bool GetBreakpointsConsultPlatformAvoidList();\n\n  lldb::LanguageType GetLanguage() const;\n\n  llvm::StringRef GetExpressionPrefixContents();\n\n  uint64_t GetExprErrorLimit() const;\n\n  bool GetUseHexImmediates() const;\n\n  bool GetUseFastStepping() const;\n\n  bool GetDisplayExpressionsInCrashlogs() const;\n\n  LoadScriptFromSymFile GetLoadScriptFromSymbolFile() const;\n\n  LoadCWDlldbinitFile GetLoadCWDlldbinitFile() const;\n\n  Disassembler::HexImmediateStyle GetHexImmediateStyle() const;\n\n  MemoryModuleLoadLevel GetMemoryModuleLoadLevel() const;\n\n  bool GetUserSpecifiedTrapHandlerNames(Args &args) const;\n\n  void SetUserSpecifiedTrapHandlerNames(const Args &args);\n\n  bool GetNonStopModeEnabled() const;\n\n  void SetNonStopModeEnabled(bool b);\n\n  bool GetDisplayRuntimeSupportValues() const;\n\n  void SetDisplayRuntimeSupportValues(bool b);\n\n  bool GetDisplayRecognizedArguments() const;\n\n  void SetDisplayRecognizedArguments(bool b);\n\n  const ProcessLaunchInfo &GetProcessLaunchInfo() const;\n\n  void SetProcessLaunchInfo(const ProcessLaunchInfo &launch_info);\n\n  bool GetInjectLocalVariables(ExecutionContext *exe_ctx) const;\n\n  void SetInjectLocalVariables(ExecutionContext *exe_ctx, bool b);\n\n  void SetRequireHardwareBreakpoints(bool b);\n\n  bool GetRequireHardwareBreakpoints() const;\n\n  bool GetAutoInstallMainExecutable() const;\n\n  void UpdateLaunchInfoFromProperties();\n\n  void SetDebugUtilityExpression(bool debug);\n\n  bool GetDebugUtilityExpression() const;\n\nprivate:\n  // Callbacks for m_launch_info.\n  void Arg0ValueChangedCallback();\n  void RunArgsValueChangedCallback();\n  void EnvVarsValueChangedCallback();\n  void InputPathValueChangedCallback();\n  void OutputPathValueChangedCallback();\n  void ErrorPathValueChangedCallback();\n  void DetachOnErrorValueChangedCallback();\n  void DisableASLRValueChangedCallback();\n  void InheritTCCValueChangedCallback();\n  void DisableSTDIOValueChangedCallback();\n\n  Environment ComputeEnvironment() const;\n\n  // Member variables.\n  ProcessLaunchInfo m_launch_info;\n  std::unique_ptr<TargetExperimentalProperties> m_experimental_properties_up;\n  Target *m_target;\n};\n\nclass EvaluateExpressionOptions {\npublic:\n// MSVC has a bug here that reports C4268: 'const' static/global data\n// initialized with compiler generated default constructor fills the object\n// with zeros. Confirmed that MSVC is *not* zero-initializing, it's just a\n// bogus warning.\n#if defined(_MSC_VER)\n#pragma warning(push)\n#pragma warning(disable : 4268)\n#endif\n  static constexpr std::chrono::milliseconds default_timeout{500};\n#if defined(_MSC_VER)\n#pragma warning(pop)\n#endif\n\n  static constexpr ExecutionPolicy default_execution_policy =\n      eExecutionPolicyOnlyWhenNeeded;\n\n  EvaluateExpressionOptions() = default;\n\n  ExecutionPolicy GetExecutionPolicy() const { return m_execution_policy; }\n\n  void SetExecutionPolicy(ExecutionPolicy policy = eExecutionPolicyAlways) {\n    m_execution_policy = policy;\n  }\n\n  lldb::LanguageType GetLanguage() const { return m_language; }\n\n  void SetLanguage(lldb::LanguageType language) { m_language = language; }\n\n  bool DoesCoerceToId() const { return m_coerce_to_id; }\n\n  const char *GetPrefix() const {\n    return (m_prefix.empty() ? nullptr : m_prefix.c_str());\n  }\n\n  void SetPrefix(const char *prefix) {\n    if (prefix && prefix[0])\n      m_prefix = prefix;\n    else\n      m_prefix.clear();\n  }\n\n  void SetCoerceToId(bool coerce = true) { m_coerce_to_id = coerce; }\n\n  bool DoesUnwindOnError() const { return m_unwind_on_error; }\n\n  void SetUnwindOnError(bool unwind = false) { m_unwind_on_error = unwind; }\n\n  bool DoesIgnoreBreakpoints() const { return m_ignore_breakpoints; }\n\n  void SetIgnoreBreakpoints(bool ignore = false) {\n    m_ignore_breakpoints = ignore;\n  }\n\n  bool DoesKeepInMemory() const { return m_keep_in_memory; }\n\n  void SetKeepInMemory(bool keep = true) { m_keep_in_memory = keep; }\n\n  lldb::DynamicValueType GetUseDynamic() const { return m_use_dynamic; }\n\n  void\n  SetUseDynamic(lldb::DynamicValueType dynamic = lldb::eDynamicCanRunTarget) {\n    m_use_dynamic = dynamic;\n  }\n\n  const Timeout<std::micro> &GetTimeout() const { return m_timeout; }\n\n  void SetTimeout(const Timeout<std::micro> &timeout) { m_timeout = timeout; }\n\n  const Timeout<std::micro> &GetOneThreadTimeout() const {\n    return m_one_thread_timeout;\n  }\n\n  void SetOneThreadTimeout(const Timeout<std::micro> &timeout) {\n    m_one_thread_timeout = timeout;\n  }\n\n  bool GetTryAllThreads() const { return m_try_others; }\n\n  void SetTryAllThreads(bool try_others = true) { m_try_others = try_others; }\n\n  bool GetStopOthers() const { return m_stop_others; }\n\n  void SetStopOthers(bool stop_others = true) { m_stop_others = stop_others; }\n\n  bool GetDebug() const { return m_debug; }\n\n  void SetDebug(bool b) {\n    m_debug = b;\n    if (m_debug)\n      m_generate_debug_info = true;\n  }\n\n  bool GetGenerateDebugInfo() const { return m_generate_debug_info; }\n\n  void SetGenerateDebugInfo(bool b) { m_generate_debug_info = b; }\n\n  bool GetColorizeErrors() const { return m_ansi_color_errors; }\n\n  void SetColorizeErrors(bool b) { m_ansi_color_errors = b; }\n\n  bool GetTrapExceptions() const { return m_trap_exceptions; }\n\n  void SetTrapExceptions(bool b) { m_trap_exceptions = b; }\n\n  bool GetREPLEnabled() const { return m_repl; }\n\n  void SetREPLEnabled(bool b) { m_repl = b; }\n\n  void SetCancelCallback(lldb::ExpressionCancelCallback callback, void *baton) {\n    m_cancel_callback_baton = baton;\n    m_cancel_callback = callback;\n  }\n\n  bool InvokeCancelCallback(lldb::ExpressionEvaluationPhase phase) const {\n    return ((m_cancel_callback != nullptr)\n                ? m_cancel_callback(phase, m_cancel_callback_baton)\n                : false);\n  }\n\n  // Allows the expression contents to be remapped to point to the specified\n  // file and line using #line directives.\n  void SetPoundLine(const char *path, uint32_t line) const {\n    if (path && path[0]) {\n      m_pound_line_file = path;\n      m_pound_line_line = line;\n    } else {\n      m_pound_line_file.clear();\n      m_pound_line_line = 0;\n    }\n  }\n\n  const char *GetPoundLineFilePath() const {\n    return (m_pound_line_file.empty() ? nullptr : m_pound_line_file.c_str());\n  }\n\n  uint32_t GetPoundLineLine() const { return m_pound_line_line; }\n\n  void SetResultIsInternal(bool b) { m_result_is_internal = b; }\n\n  bool GetResultIsInternal() const { return m_result_is_internal; }\n\n  void SetAutoApplyFixIts(bool b) { m_auto_apply_fixits = b; }\n\n  bool GetAutoApplyFixIts() const { return m_auto_apply_fixits; }\n\n  void SetRetriesWithFixIts(uint64_t number_of_retries) {\n    m_retries_with_fixits = number_of_retries;\n  }\n\n  uint64_t GetRetriesWithFixIts() const { return m_retries_with_fixits; }\n\n  bool IsForUtilityExpr() const { return m_running_utility_expression; }\n\n  void SetIsForUtilityExpr(bool b) { m_running_utility_expression = b; }\n\nprivate:\n  ExecutionPolicy m_execution_policy = default_execution_policy;\n  lldb::LanguageType m_language = lldb::eLanguageTypeUnknown;\n  std::string m_prefix;\n  bool m_coerce_to_id = false;\n  bool m_unwind_on_error = true;\n  bool m_ignore_breakpoints = false;\n  bool m_keep_in_memory = false;\n  bool m_try_others = true;\n  bool m_stop_others = true;\n  bool m_debug = false;\n  bool m_trap_exceptions = true;\n  bool m_repl = false;\n  bool m_generate_debug_info = false;\n  bool m_ansi_color_errors = false;\n  bool m_result_is_internal = false;\n  bool m_auto_apply_fixits = true;\n  uint64_t m_retries_with_fixits = 1;\n  /// True if the executed code should be treated as utility code that is only\n  /// used by LLDB internally.\n  bool m_running_utility_expression = false;\n\n  lldb::DynamicValueType m_use_dynamic = lldb::eNoDynamicValues;\n  Timeout<std::micro> m_timeout = default_timeout;\n  Timeout<std::micro> m_one_thread_timeout = llvm::None;\n  lldb::ExpressionCancelCallback m_cancel_callback = nullptr;\n  void *m_cancel_callback_baton = nullptr;\n  // If m_pound_line_file is not empty and m_pound_line_line is non-zero, use\n  // #line %u \"%s\" before the expression content to remap where the source\n  // originates\n  mutable std::string m_pound_line_file;\n  mutable uint32_t m_pound_line_line;\n};\n\n// Target\nclass Target : public std::enable_shared_from_this<Target>,\n               public TargetProperties,\n               public Broadcaster,\n               public ExecutionContextScope,\n               public ModuleList::Notifier {\npublic:\n  friend class TargetList;\n  friend class Debugger;\n\n  /// Broadcaster event bits definitions.\n  enum {\n    eBroadcastBitBreakpointChanged = (1 << 0),\n    eBroadcastBitModulesLoaded = (1 << 1),\n    eBroadcastBitModulesUnloaded = (1 << 2),\n    eBroadcastBitWatchpointChanged = (1 << 3),\n    eBroadcastBitSymbolsLoaded = (1 << 4)\n  };\n\n  // These two functions fill out the Broadcaster interface:\n\n  static ConstString &GetStaticBroadcasterClass();\n\n  ConstString &GetBroadcasterClass() const override {\n    return GetStaticBroadcasterClass();\n  }\n\n  // This event data class is for use by the TargetList to broadcast new target\n  // notifications.\n  class TargetEventData : public EventData {\n  public:\n    TargetEventData(const lldb::TargetSP &target_sp);\n\n    TargetEventData(const lldb::TargetSP &target_sp,\n                    const ModuleList &module_list);\n\n    ~TargetEventData() override;\n\n    static ConstString GetFlavorString();\n\n    ConstString GetFlavor() const override {\n      return TargetEventData::GetFlavorString();\n    }\n\n    void Dump(Stream *s) const override;\n\n    static const TargetEventData *GetEventDataFromEvent(const Event *event_ptr);\n\n    static lldb::TargetSP GetTargetFromEvent(const Event *event_ptr);\n\n    static ModuleList GetModuleListFromEvent(const Event *event_ptr);\n\n    const lldb::TargetSP &GetTarget() const { return m_target_sp; }\n\n    const ModuleList &GetModuleList() const { return m_module_list; }\n\n  private:\n    lldb::TargetSP m_target_sp;\n    ModuleList m_module_list;\n\n    TargetEventData(const TargetEventData &) = delete;\n    const TargetEventData &operator=(const TargetEventData &) = delete;\n  };\n\n  ~Target() override;\n\n  static void SettingsInitialize();\n\n  static void SettingsTerminate();\n\n  static FileSpecList GetDefaultExecutableSearchPaths();\n\n  static FileSpecList GetDefaultDebugFileSearchPaths();\n\n  static ArchSpec GetDefaultArchitecture();\n\n  static void SetDefaultArchitecture(const ArchSpec &arch);\n\n  bool IsDummyTarget() const { return m_is_dummy_target; }\n\n  /// Find a binary on the system and return its Module,\n  /// or return an existing Module that is already in the Target.\n  ///\n  /// Given a ModuleSpec, find a binary satisifying that specification,\n  /// or identify a matching Module already present in the Target,\n  /// and return a shared pointer to it.\n  ///\n  /// \\param[in] module_spec\n  ///     The criteria that must be matched for the binary being loaded.\n  ///     e.g. UUID, architecture, file path.\n  ///\n  /// \\param[in] notify\n  ///     If notify is true, and the Module is new to this Target,\n  ///     Target::ModulesDidLoad will be called.\n  ///     If notify is false, it is assumed that the caller is adding\n  ///     multiple Modules and will call ModulesDidLoad with the\n  ///     full list at the end.\n  ///     ModulesDidLoad must be called when a Module/Modules have\n  ///     been added to the target, one way or the other.\n  ///\n  /// \\param[out] error_ptr\n  ///     Optional argument, pointing to a Status object to fill in\n  ///     with any results / messages while attempting to find/load\n  ///     this binary.  Many callers will be internal functions that\n  ///     will handle / summarize the failures in a custom way and\n  ///     don't use these messages.\n  ///\n  /// \\return\n  ///     An empty ModuleSP will be returned if no matching file\n  ///     was found.  If error_ptr was non-nullptr, an error message\n  ///     will likely be provided.\n  lldb::ModuleSP GetOrCreateModule(const ModuleSpec &module_spec, bool notify,\n                                   Status *error_ptr = nullptr);\n\n  // Settings accessors\n\n  static const lldb::TargetPropertiesSP &GetGlobalProperties();\n\n  std::recursive_mutex &GetAPIMutex();\n\n  void DeleteCurrentProcess();\n\n  void CleanupProcess();\n\n  /// Dump a description of this object to a Stream.\n  ///\n  /// Dump a description of the contents of this object to the\n  /// supplied stream \\a s. The dumped content will be only what has\n  /// been loaded or parsed up to this point at which this function\n  /// is called, so this is a good way to see what has been parsed\n  /// in a target.\n  ///\n  /// \\param[in] s\n  ///     The stream to which to dump the object description.\n  void Dump(Stream *s, lldb::DescriptionLevel description_level);\n\n  // If listener_sp is null, the listener of the owning Debugger object will be\n  // used.\n  const lldb::ProcessSP &CreateProcess(lldb::ListenerSP listener_sp,\n                                       llvm::StringRef plugin_name,\n                                       const FileSpec *crash_file,\n                                       bool can_connect);\n\n  const lldb::ProcessSP &GetProcessSP() const;\n\n  bool IsValid() { return m_valid; }\n\n  void Destroy();\n\n  Status Launch(ProcessLaunchInfo &launch_info,\n                Stream *stream); // Optional stream to receive first stop info\n\n  Status Attach(ProcessAttachInfo &attach_info,\n                Stream *stream); // Optional stream to receive first stop info\n\n  // This part handles the breakpoints.\n\n  BreakpointList &GetBreakpointList(bool internal = false);\n\n  const BreakpointList &GetBreakpointList(bool internal = false) const;\n\n  lldb::BreakpointSP GetLastCreatedBreakpoint() {\n    return m_last_created_breakpoint;\n  }\n\n  lldb::BreakpointSP GetBreakpointByID(lldb::break_id_t break_id);\n\n  // Use this to create a file and line breakpoint to a given module or all\n  // module it is nullptr\n  lldb::BreakpointSP CreateBreakpoint(const FileSpecList *containingModules,\n                                      const FileSpec &file, uint32_t line_no,\n                                      uint32_t column, lldb::addr_t offset,\n                                      LazyBool check_inlines,\n                                      LazyBool skip_prologue, bool internal,\n                                      bool request_hardware,\n                                      LazyBool move_to_nearest_code);\n\n  // Use this to create breakpoint that matches regex against the source lines\n  // in files given in source_file_list: If function_names is non-empty, also\n  // filter by function after the matches are made.\n  lldb::BreakpointSP CreateSourceRegexBreakpoint(\n      const FileSpecList *containingModules,\n      const FileSpecList *source_file_list,\n      const std::unordered_set<std::string> &function_names,\n      RegularExpression source_regex, bool internal, bool request_hardware,\n      LazyBool move_to_nearest_code);\n\n  // Use this to create a breakpoint from a load address\n  lldb::BreakpointSP CreateBreakpoint(lldb::addr_t load_addr, bool internal,\n                                      bool request_hardware);\n\n  // Use this to create a breakpoint from a load address and a module file spec\n  lldb::BreakpointSP CreateAddressInModuleBreakpoint(lldb::addr_t file_addr,\n                                                     bool internal,\n                                                     const FileSpec *file_spec,\n                                                     bool request_hardware);\n\n  // Use this to create Address breakpoints:\n  lldb::BreakpointSP CreateBreakpoint(const Address &addr, bool internal,\n                                      bool request_hardware);\n\n  // Use this to create a function breakpoint by regexp in\n  // containingModule/containingSourceFiles, or all modules if it is nullptr\n  // When \"skip_prologue is set to eLazyBoolCalculate, we use the current\n  // target setting, else we use the values passed in\n  lldb::BreakpointSP CreateFuncRegexBreakpoint(\n      const FileSpecList *containingModules,\n      const FileSpecList *containingSourceFiles, RegularExpression func_regexp,\n      lldb::LanguageType requested_language, LazyBool skip_prologue,\n      bool internal, bool request_hardware);\n\n  // Use this to create a function breakpoint by name in containingModule, or\n  // all modules if it is nullptr When \"skip_prologue is set to\n  // eLazyBoolCalculate, we use the current target setting, else we use the\n  // values passed in. func_name_type_mask is or'ed values from the\n  // FunctionNameType enum.\n  lldb::BreakpointSP CreateBreakpoint(\n      const FileSpecList *containingModules,\n      const FileSpecList *containingSourceFiles, const char *func_name,\n      lldb::FunctionNameType func_name_type_mask, lldb::LanguageType language,\n      lldb::addr_t offset, LazyBool skip_prologue, bool internal,\n      bool request_hardware);\n\n  lldb::BreakpointSP\n  CreateExceptionBreakpoint(enum lldb::LanguageType language, bool catch_bp,\n                            bool throw_bp, bool internal,\n                            Args *additional_args = nullptr,\n                            Status *additional_args_error = nullptr);\n\n  lldb::BreakpointSP CreateScriptedBreakpoint(\n      const llvm::StringRef class_name, const FileSpecList *containingModules,\n      const FileSpecList *containingSourceFiles, bool internal,\n      bool request_hardware, StructuredData::ObjectSP extra_args_sp,\n      Status *creation_error = nullptr);\n\n  // This is the same as the func_name breakpoint except that you can specify a\n  // vector of names.  This is cheaper than a regular expression breakpoint in\n  // the case where you just want to set a breakpoint on a set of names you\n  // already know. func_name_type_mask is or'ed values from the\n  // FunctionNameType enum.\n  lldb::BreakpointSP CreateBreakpoint(\n      const FileSpecList *containingModules,\n      const FileSpecList *containingSourceFiles, const char *func_names[],\n      size_t num_names, lldb::FunctionNameType func_name_type_mask,\n      lldb::LanguageType language, lldb::addr_t offset, LazyBool skip_prologue,\n      bool internal, bool request_hardware);\n\n  lldb::BreakpointSP\n  CreateBreakpoint(const FileSpecList *containingModules,\n                   const FileSpecList *containingSourceFiles,\n                   const std::vector<std::string> &func_names,\n                   lldb::FunctionNameType func_name_type_mask,\n                   lldb::LanguageType language, lldb::addr_t m_offset,\n                   LazyBool skip_prologue, bool internal,\n                   bool request_hardware);\n\n  // Use this to create a general breakpoint:\n  lldb::BreakpointSP CreateBreakpoint(lldb::SearchFilterSP &filter_sp,\n                                      lldb::BreakpointResolverSP &resolver_sp,\n                                      bool internal, bool request_hardware,\n                                      bool resolve_indirect_symbols);\n\n  // Use this to create a watchpoint:\n  lldb::WatchpointSP CreateWatchpoint(lldb::addr_t addr, size_t size,\n                                      const CompilerType *type, uint32_t kind,\n                                      Status &error);\n\n  lldb::WatchpointSP GetLastCreatedWatchpoint() {\n    return m_last_created_watchpoint;\n  }\n\n  WatchpointList &GetWatchpointList() { return m_watchpoint_list; }\n\n  // Manages breakpoint names:\n  void AddNameToBreakpoint(BreakpointID &id, const char *name, Status &error);\n\n  void AddNameToBreakpoint(lldb::BreakpointSP &bp_sp, const char *name,\n                           Status &error);\n\n  void RemoveNameFromBreakpoint(lldb::BreakpointSP &bp_sp, ConstString name);\n\n  BreakpointName *FindBreakpointName(ConstString name, bool can_create,\n                                     Status &error);\n\n  void DeleteBreakpointName(ConstString name);\n\n  void ConfigureBreakpointName(BreakpointName &bp_name,\n                               const BreakpointOptions &options,\n                               const BreakpointName::Permissions &permissions);\n  void ApplyNameToBreakpoints(BreakpointName &bp_name);\n\n  // This takes ownership of the name obj passed in.\n  void AddBreakpointName(BreakpointName *bp_name);\n\n  void GetBreakpointNames(std::vector<std::string> &names);\n\n  // This call removes ALL breakpoints regardless of permission.\n  void RemoveAllBreakpoints(bool internal_also = false);\n\n  // This removes all the breakpoints, but obeys the ePermDelete on them.\n  void RemoveAllowedBreakpoints();\n\n  void DisableAllBreakpoints(bool internal_also = false);\n\n  void DisableAllowedBreakpoints();\n\n  void EnableAllBreakpoints(bool internal_also = false);\n\n  void EnableAllowedBreakpoints();\n\n  bool DisableBreakpointByID(lldb::break_id_t break_id);\n\n  bool EnableBreakpointByID(lldb::break_id_t break_id);\n\n  bool RemoveBreakpointByID(lldb::break_id_t break_id);\n\n  // The flag 'end_to_end', default to true, signifies that the operation is\n  // performed end to end, for both the debugger and the debuggee.\n\n  bool RemoveAllWatchpoints(bool end_to_end = true);\n\n  bool DisableAllWatchpoints(bool end_to_end = true);\n\n  bool EnableAllWatchpoints(bool end_to_end = true);\n\n  bool ClearAllWatchpointHitCounts();\n\n  bool ClearAllWatchpointHistoricValues();\n\n  bool IgnoreAllWatchpoints(uint32_t ignore_count);\n\n  bool DisableWatchpointByID(lldb::watch_id_t watch_id);\n\n  bool EnableWatchpointByID(lldb::watch_id_t watch_id);\n\n  bool RemoveWatchpointByID(lldb::watch_id_t watch_id);\n\n  bool IgnoreWatchpointByID(lldb::watch_id_t watch_id, uint32_t ignore_count);\n\n  Status SerializeBreakpointsToFile(const FileSpec &file,\n                                    const BreakpointIDList &bp_ids,\n                                    bool append);\n\n  Status CreateBreakpointsFromFile(const FileSpec &file,\n                                   BreakpointIDList &new_bps);\n\n  Status CreateBreakpointsFromFile(const FileSpec &file,\n                                   std::vector<std::string> &names,\n                                   BreakpointIDList &new_bps);\n\n  /// Get \\a load_addr as a callable code load address for this target\n  ///\n  /// Take \\a load_addr and potentially add any address bits that are\n  /// needed to make the address callable. For ARM this can set bit\n  /// zero (if it already isn't) if \\a load_addr is a thumb function.\n  /// If \\a addr_class is set to AddressClass::eInvalid, then the address\n  /// adjustment will always happen. If it is set to an address class\n  /// that doesn't have code in it, LLDB_INVALID_ADDRESS will be\n  /// returned.\n  lldb::addr_t GetCallableLoadAddress(\n      lldb::addr_t load_addr,\n      AddressClass addr_class = AddressClass::eInvalid) const;\n\n  /// Get \\a load_addr as an opcode for this target.\n  ///\n  /// Take \\a load_addr and potentially strip any address bits that are\n  /// needed to make the address point to an opcode. For ARM this can\n  /// clear bit zero (if it already isn't) if \\a load_addr is a\n  /// thumb function and load_addr is in code.\n  /// If \\a addr_class is set to AddressClass::eInvalid, then the address\n  /// adjustment will always happen. If it is set to an address class\n  /// that doesn't have code in it, LLDB_INVALID_ADDRESS will be\n  /// returned.\n  lldb::addr_t\n  GetOpcodeLoadAddress(lldb::addr_t load_addr,\n                       AddressClass addr_class = AddressClass::eInvalid) const;\n\n  // Get load_addr as breakable load address for this target. Take a addr and\n  // check if for any reason there is a better address than this to put a\n  // breakpoint on. If there is then return that address. For MIPS, if\n  // instruction at addr is a delay slot instruction then this method will find\n  // the address of its previous instruction and return that address.\n  lldb::addr_t GetBreakableLoadAddress(lldb::addr_t addr);\n\n  void ModulesDidLoad(ModuleList &module_list);\n\n  void ModulesDidUnload(ModuleList &module_list, bool delete_locations);\n\n  void SymbolsDidLoad(ModuleList &module_list);\n\n  void ClearModules(bool delete_locations);\n\n  /// Called as the last function in Process::DidExec().\n  ///\n  /// Process::DidExec() will clear a lot of state in the process,\n  /// then try to reload a dynamic loader plugin to discover what\n  /// binaries are currently available and then this function should\n  /// be called to allow the target to do any cleanup after everything\n  /// has been figured out. It can remove breakpoints that no longer\n  /// make sense as the exec might have changed the target\n  /// architecture, and unloaded some modules that might get deleted.\n  void DidExec();\n\n  /// Gets the module for the main executable.\n  ///\n  /// Each process has a notion of a main executable that is the file\n  /// that will be executed or attached to. Executable files can have\n  /// dependent modules that are discovered from the object files, or\n  /// discovered at runtime as things are dynamically loaded.\n  ///\n  /// \\return\n  ///     The shared pointer to the executable module which can\n  ///     contains a nullptr Module object if no executable has been\n  ///     set.\n  ///\n  /// \\see DynamicLoader\n  /// \\see ObjectFile::GetDependentModules (FileSpecList&)\n  /// \\see Process::SetExecutableModule(lldb::ModuleSP&)\n  lldb::ModuleSP GetExecutableModule();\n\n  Module *GetExecutableModulePointer();\n\n  /// Set the main executable module.\n  ///\n  /// Each process has a notion of a main executable that is the file\n  /// that will be executed or attached to. Executable files can have\n  /// dependent modules that are discovered from the object files, or\n  /// discovered at runtime as things are dynamically loaded.\n  ///\n  /// Setting the executable causes any of the current dependent\n  /// image information to be cleared and replaced with the static\n  /// dependent image information found by calling\n  /// ObjectFile::GetDependentModules (FileSpecList&) on the main\n  /// executable and any modules on which it depends. Calling\n  /// Process::GetImages() will return the newly found images that\n  /// were obtained from all of the object files.\n  ///\n  /// \\param[in] module_sp\n  ///     A shared pointer reference to the module that will become\n  ///     the main executable for this process.\n  ///\n  /// \\param[in] load_dependent_files\n  ///     If \\b true then ask the object files to track down any\n  ///     known dependent files.\n  ///\n  /// \\see ObjectFile::GetDependentModules (FileSpecList&)\n  /// \\see Process::GetImages()\n  void SetExecutableModule(\n      lldb::ModuleSP &module_sp,\n      LoadDependentFiles load_dependent_files = eLoadDependentsDefault);\n\n  bool LoadScriptingResources(std::list<Status> &errors,\n                              Stream *feedback_stream = nullptr,\n                              bool continue_on_error = true) {\n    return m_images.LoadScriptingResourcesInTarget(\n        this, errors, feedback_stream, continue_on_error);\n  }\n\n  /// Get accessor for the images for this process.\n  ///\n  /// Each process has a notion of a main executable that is the file\n  /// that will be executed or attached to. Executable files can have\n  /// dependent modules that are discovered from the object files, or\n  /// discovered at runtime as things are dynamically loaded. After\n  /// a main executable has been set, the images will contain a list\n  /// of all the files that the executable depends upon as far as the\n  /// object files know. These images will usually contain valid file\n  /// virtual addresses only. When the process is launched or attached\n  /// to, the DynamicLoader plug-in will discover where these images\n  /// were loaded in memory and will resolve the load virtual\n  /// addresses is each image, and also in images that are loaded by\n  /// code.\n  ///\n  /// \\return\n  ///     A list of Module objects in a module list.\n  const ModuleList &GetImages() const { return m_images; }\n\n  ModuleList &GetImages() { return m_images; }\n\n  /// Return whether this FileSpec corresponds to a module that should be\n  /// considered for general searches.\n  ///\n  /// This API will be consulted by the SearchFilterForUnconstrainedSearches\n  /// and any module that returns \\b true will not be searched.  Note the\n  /// SearchFilterForUnconstrainedSearches is the search filter that\n  /// gets used in the CreateBreakpoint calls when no modules is provided.\n  ///\n  /// The target call at present just consults the Platform's call of the\n  /// same name.\n  ///\n  /// \\param[in] module_spec\n  ///     Path to the module.\n  ///\n  /// \\return \\b true if the module should be excluded, \\b false otherwise.\n  bool ModuleIsExcludedForUnconstrainedSearches(const FileSpec &module_spec);\n\n  /// Return whether this module should be considered for general searches.\n  ///\n  /// This API will be consulted by the SearchFilterForUnconstrainedSearches\n  /// and any module that returns \\b true will not be searched.  Note the\n  /// SearchFilterForUnconstrainedSearches is the search filter that\n  /// gets used in the CreateBreakpoint calls when no modules is provided.\n  ///\n  /// The target call at present just consults the Platform's call of the\n  /// same name.\n  ///\n  /// FIXME: When we get time we should add a way for the user to set modules\n  /// that they\n  /// don't want searched, in addition to or instead of the platform ones.\n  ///\n  /// \\param[in] module_sp\n  ///     A shared pointer reference to the module that checked.\n  ///\n  /// \\return \\b true if the module should be excluded, \\b false otherwise.\n  bool\n  ModuleIsExcludedForUnconstrainedSearches(const lldb::ModuleSP &module_sp);\n\n  const ArchSpec &GetArchitecture() const { return m_arch.GetSpec(); }\n\n  /// Set the architecture for this target.\n  ///\n  /// If the current target has no Images read in, then this just sets the\n  /// architecture, which will be used to select the architecture of the\n  /// ExecutableModule when that is set. If the current target has an\n  /// ExecutableModule, then calling SetArchitecture with a different\n  /// architecture from the currently selected one will reset the\n  /// ExecutableModule to that slice of the file backing the ExecutableModule.\n  /// If the file backing the ExecutableModule does not contain a fork of this\n  /// architecture, then this code will return false, and the architecture\n  /// won't be changed. If the input arch_spec is the same as the already set\n  /// architecture, this is a no-op.\n  ///\n  /// \\param[in] arch_spec\n  ///     The new architecture.\n  ///\n  /// \\param[in] set_platform\n  ///     If \\b true, then the platform will be adjusted if the currently\n  ///     selected platform is not compatible with the architecture being set.\n  ///     If \\b false, then just the architecture will be set even if the\n  ///     currently selected platform isn't compatible (in case it might be\n  ///     manually set following this function call).\n  ///\n  /// \\return\n  ///     \\b true if the architecture was successfully set, \\bfalse otherwise.\n  bool SetArchitecture(const ArchSpec &arch_spec, bool set_platform = false);\n\n  bool MergeArchitecture(const ArchSpec &arch_spec);\n\n  Architecture *GetArchitecturePlugin() const { return m_arch.GetPlugin(); }\n\n  Debugger &GetDebugger() { return m_debugger; }\n\n  size_t ReadMemoryFromFileCache(const Address &addr, void *dst, size_t dst_len,\n                                 Status &error);\n\n  // Reading memory through the target allows us to skip going to the process\n  // for reading memory if possible and it allows us to try and read from any\n  // constant sections in our object files on disk. If you always want live\n  // program memory, read straight from the process. If you possibly want to\n  // read from const sections in object files, read from the target. This\n  // version of ReadMemory will try and read memory from the process if the\n  // process is alive. The order is:\n  // 1 - if (prefer_file_cache == true) then read from object file cache\n  // 2 - if there is a valid process, try and read from its memory\n  // 3 - if (prefer_file_cache == false) then read from object file cache\n  size_t ReadMemory(const Address &addr, bool prefer_file_cache, void *dst,\n                    size_t dst_len, Status &error,\n                    lldb::addr_t *load_addr_ptr = nullptr);\n\n  size_t ReadCStringFromMemory(const Address &addr, std::string &out_str,\n                               Status &error);\n\n  size_t ReadCStringFromMemory(const Address &addr, char *dst,\n                               size_t dst_max_len, Status &result_error);\n\n  size_t ReadScalarIntegerFromMemory(const Address &addr,\n                                     bool prefer_file_cache, uint32_t byte_size,\n                                     bool is_signed, Scalar &scalar,\n                                     Status &error);\n\n  uint64_t ReadUnsignedIntegerFromMemory(const Address &addr,\n                                         bool prefer_file_cache,\n                                         size_t integer_byte_size,\n                                         uint64_t fail_value, Status &error);\n\n  bool ReadPointerFromMemory(const Address &addr, bool prefer_file_cache,\n                             Status &error, Address &pointer_addr);\n\n  SectionLoadList &GetSectionLoadList() {\n    return m_section_load_history.GetCurrentSectionLoadList();\n  }\n\n  static Target *GetTargetFromContexts(const ExecutionContext *exe_ctx_ptr,\n                                       const SymbolContext *sc_ptr);\n\n  // lldb::ExecutionContextScope pure virtual functions\n  lldb::TargetSP CalculateTarget() override;\n\n  lldb::ProcessSP CalculateProcess() override;\n\n  lldb::ThreadSP CalculateThread() override;\n\n  lldb::StackFrameSP CalculateStackFrame() override;\n\n  void CalculateExecutionContext(ExecutionContext &exe_ctx) override;\n\n  PathMappingList &GetImageSearchPathList();\n\n  llvm::Expected<TypeSystem &>\n  GetScratchTypeSystemForLanguage(lldb::LanguageType language,\n                                  bool create_on_demand = true);\n\n  std::vector<TypeSystem *> GetScratchTypeSystems(bool create_on_demand = true);\n\n  PersistentExpressionState *\n  GetPersistentExpressionStateForLanguage(lldb::LanguageType language);\n\n  // Creates a UserExpression for the given language, the rest of the\n  // parameters have the same meaning as for the UserExpression constructor.\n  // Returns a new-ed object which the caller owns.\n\n  UserExpression *\n  GetUserExpressionForLanguage(llvm::StringRef expr, llvm::StringRef prefix,\n                               lldb::LanguageType language,\n                               Expression::ResultType desired_type,\n                               const EvaluateExpressionOptions &options,\n                               ValueObject *ctx_obj, Status &error);\n\n  // Creates a FunctionCaller for the given language, the rest of the\n  // parameters have the same meaning as for the FunctionCaller constructor.\n  // Since a FunctionCaller can't be\n  // IR Interpreted, it makes no sense to call this with an\n  // ExecutionContextScope that lacks\n  // a Process.\n  // Returns a new-ed object which the caller owns.\n\n  FunctionCaller *GetFunctionCallerForLanguage(lldb::LanguageType language,\n                                               const CompilerType &return_type,\n                                               const Address &function_address,\n                                               const ValueList &arg_value_list,\n                                               const char *name, Status &error);\n\n  /// Creates and installs a UtilityFunction for the given language.\n  llvm::Expected<std::unique_ptr<UtilityFunction>>\n  CreateUtilityFunction(std::string expression, std::string name,\n                        lldb::LanguageType language, ExecutionContext &exe_ctx);\n\n  // Install any files through the platform that need be to installed prior to\n  // launching or attaching.\n  Status Install(ProcessLaunchInfo *launch_info);\n\n  bool ResolveFileAddress(lldb::addr_t load_addr, Address &so_addr);\n\n  bool ResolveLoadAddress(lldb::addr_t load_addr, Address &so_addr,\n                          uint32_t stop_id = SectionLoadHistory::eStopIDNow);\n\n  bool SetSectionLoadAddress(const lldb::SectionSP &section,\n                             lldb::addr_t load_addr,\n                             bool warn_multiple = false);\n\n  size_t UnloadModuleSections(const lldb::ModuleSP &module_sp);\n\n  size_t UnloadModuleSections(const ModuleList &module_list);\n\n  bool SetSectionUnloaded(const lldb::SectionSP &section_sp);\n\n  bool SetSectionUnloaded(const lldb::SectionSP &section_sp,\n                          lldb::addr_t load_addr);\n\n  void ClearAllLoadedSections();\n\n  /// Set the \\a Trace object containing processor trace information of this\n  /// target.\n  ///\n  /// \\param[in] trace_sp\n  ///   The trace object.\n  void SetTrace(const lldb::TraceSP &trace_sp);\n\n  /// Get the \\a Trace object containing processor trace information of this\n  /// target.\n  ///\n  /// \\return\n  ///   The trace object. It might be undefined.\n  const lldb::TraceSP &GetTrace();\n\n  // Since expressions results can persist beyond the lifetime of a process,\n  // and the const expression results are available after a process is gone, we\n  // provide a way for expressions to be evaluated from the Target itself. If\n  // an expression is going to be run, then it should have a frame filled in in\n  // the execution context.\n  lldb::ExpressionResults EvaluateExpression(\n      llvm::StringRef expression, ExecutionContextScope *exe_scope,\n      lldb::ValueObjectSP &result_valobj_sp,\n      const EvaluateExpressionOptions &options = EvaluateExpressionOptions(),\n      std::string *fixed_expression = nullptr, ValueObject *ctx_obj = nullptr);\n\n  lldb::ExpressionVariableSP GetPersistentVariable(ConstString name);\n\n  lldb::addr_t GetPersistentSymbol(ConstString name);\n\n  /// This method will return the address of the starting function for\n  /// this binary, e.g. main() or its equivalent.  This can be used as\n  /// an address of a function that is not called once a binary has\n  /// started running - e.g. as a return address for inferior function\n  /// calls that are unambiguous completion of the function call, not\n  /// called during the course of the inferior function code running.\n  ///\n  /// If no entry point can be found, an invalid address is returned.\n  ///\n  /// \\param [out] err\n  ///     This object will be set to failure if no entry address could\n  ///     be found, and may contain a helpful error message.\n  //\n  /// \\return\n  ///     Returns the entry address for this program, or an error\n  ///     if none can be found.\n  llvm::Expected<lldb_private::Address> GetEntryPointAddress();\n\n  // Target Stop Hooks\n  class StopHook : public UserID {\n  public:\n    StopHook(const StopHook &rhs);\n    virtual ~StopHook() = default;\n\n    enum class StopHookKind  : uint32_t { CommandBased = 0, ScriptBased };\n    enum class StopHookResult : uint32_t {\n      KeepStopped = 0,\n      RequestContinue,\n      AlreadyContinued\n    };\n\n    lldb::TargetSP &GetTarget() { return m_target_sp; }\n\n    // Set the specifier.  The stop hook will own the specifier, and is\n    // responsible for deleting it when we're done.\n    void SetSpecifier(SymbolContextSpecifier *specifier);\n\n    SymbolContextSpecifier *GetSpecifier() { return m_specifier_sp.get(); }\n\n    bool ExecutionContextPasses(const ExecutionContext &exe_ctx);\n\n    // Called on stop, this gets passed the ExecutionContext for each \"stop\n    // with a reason\" thread.  It should add to the stream whatever text it\n    // wants to show the user, and return False to indicate it wants the target\n    // not to stop.\n    virtual StopHookResult HandleStop(ExecutionContext &exe_ctx,\n                                      lldb::StreamSP output) = 0;\n\n    // Set the Thread Specifier.  The stop hook will own the thread specifier,\n    // and is responsible for deleting it when we're done.\n    void SetThreadSpecifier(ThreadSpec *specifier);\n\n    ThreadSpec *GetThreadSpecifier() { return m_thread_spec_up.get(); }\n\n    bool IsActive() { return m_active; }\n\n    void SetIsActive(bool is_active) { m_active = is_active; }\n\n    void SetAutoContinue(bool auto_continue) {\n      m_auto_continue = auto_continue;\n    }\n\n    bool GetAutoContinue() const { return m_auto_continue; }\n\n    void GetDescription(Stream *s, lldb::DescriptionLevel level) const;\n    virtual void GetSubclassDescription(Stream *s,\n                                        lldb::DescriptionLevel level) const = 0;\n\n  protected:\n    lldb::TargetSP m_target_sp;\n    lldb::SymbolContextSpecifierSP m_specifier_sp;\n    std::unique_ptr<ThreadSpec> m_thread_spec_up;\n    bool m_active = true;\n    bool m_auto_continue = false;\n\n    StopHook(lldb::TargetSP target_sp, lldb::user_id_t uid);\n  };\n\n  class StopHookCommandLine : public StopHook {\n  public:\n    virtual ~StopHookCommandLine() = default;\n\n    StringList &GetCommands() { return m_commands; }\n    void SetActionFromString(const std::string &strings);\n    void SetActionFromStrings(const std::vector<std::string> &strings);\n\n    StopHookResult HandleStop(ExecutionContext &exc_ctx,\n                              lldb::StreamSP output_sp) override;\n    void GetSubclassDescription(Stream *s,\n                                lldb::DescriptionLevel level) const override;\n\n  private:\n    StringList m_commands;\n    // Use CreateStopHook to make a new empty stop hook. The GetCommandPointer\n    // and fill it with commands, and SetSpecifier to set the specifier shared\n    // pointer (can be null, that will match anything.)\n    StopHookCommandLine(lldb::TargetSP target_sp, lldb::user_id_t uid)\n        : StopHook(target_sp, uid) {}\n    friend class Target;\n  };\n\n  class StopHookScripted : public StopHook {\n  public:\n    virtual ~StopHookScripted() = default;\n    StopHookResult HandleStop(ExecutionContext &exc_ctx,\n                              lldb::StreamSP output) override;\n\n    Status SetScriptCallback(std::string class_name,\n                             StructuredData::ObjectSP extra_args_sp);\n\n    void GetSubclassDescription(Stream *s,\n                                lldb::DescriptionLevel level) const override;\n\n  private:\n    std::string m_class_name;\n    /// This holds the dictionary of keys & values that can be used to\n    /// parametrize any given callback's behavior.\n    StructuredDataImpl *m_extra_args; // We own this structured data,\n                                      // but the SD itself manages the UP.\n    /// This holds the python callback object.\n    StructuredData::GenericSP m_implementation_sp;\n\n    /// Use CreateStopHook to make a new empty stop hook. The GetCommandPointer\n    /// and fill it with commands, and SetSpecifier to set the specifier shared\n    /// pointer (can be null, that will match anything.)\n    StopHookScripted(lldb::TargetSP target_sp, lldb::user_id_t uid)\n        : StopHook(target_sp, uid) {}\n    friend class Target;\n  };\n\n  typedef std::shared_ptr<StopHook> StopHookSP;\n\n  /// Add an empty stop hook to the Target's stop hook list, and returns a\n  /// shared pointer to it in new_hook. Returns the id of the new hook.\n  StopHookSP CreateStopHook(StopHook::StopHookKind kind);\n\n  /// If you tried to create a stop hook, and that failed, call this to\n  /// remove the stop hook, as it will also reset the stop hook counter.\n  void UndoCreateStopHook(lldb::user_id_t uid);\n\n  // Runs the stop hooks that have been registered for this target.\n  // Returns true if the stop hooks cause the target to resume.\n  bool RunStopHooks();\n\n  size_t GetStopHookSize();\n\n  bool SetSuppresStopHooks(bool suppress) {\n    bool old_value = m_suppress_stop_hooks;\n    m_suppress_stop_hooks = suppress;\n    return old_value;\n  }\n\n  bool GetSuppressStopHooks() { return m_suppress_stop_hooks; }\n\n  bool RemoveStopHookByID(lldb::user_id_t uid);\n\n  void RemoveAllStopHooks();\n\n  StopHookSP GetStopHookByID(lldb::user_id_t uid);\n\n  bool SetStopHookActiveStateByID(lldb::user_id_t uid, bool active_state);\n\n  void SetAllStopHooksActiveState(bool active_state);\n\n  size_t GetNumStopHooks() const { return m_stop_hooks.size(); }\n\n  StopHookSP GetStopHookAtIndex(size_t index) {\n    if (index >= GetNumStopHooks())\n      return StopHookSP();\n    StopHookCollection::iterator pos = m_stop_hooks.begin();\n\n    while (index > 0) {\n      pos++;\n      index--;\n    }\n    return (*pos).second;\n  }\n\n  lldb::PlatformSP GetPlatform() { return m_platform_sp; }\n\n  void SetPlatform(const lldb::PlatformSP &platform_sp) {\n    m_platform_sp = platform_sp;\n  }\n\n  SourceManager &GetSourceManager();\n\n  ClangModulesDeclVendor *GetClangModulesDeclVendor();\n\n  // Methods.\n  lldb::SearchFilterSP\n  GetSearchFilterForModule(const FileSpec *containingModule);\n\n  lldb::SearchFilterSP\n  GetSearchFilterForModuleList(const FileSpecList *containingModuleList);\n\n  lldb::SearchFilterSP\n  GetSearchFilterForModuleAndCUList(const FileSpecList *containingModules,\n                                    const FileSpecList *containingSourceFiles);\n\n  lldb::REPLSP GetREPL(Status &err, lldb::LanguageType language,\n                       const char *repl_options, bool can_create);\n\n  void SetREPL(lldb::LanguageType language, lldb::REPLSP repl_sp);\n\n  StackFrameRecognizerManager &GetFrameRecognizerManager() {\n    return *m_frame_recognizer_manager_up;\n  }\n\nprotected:\n  /// Implementing of ModuleList::Notifier.\n\n  void NotifyModuleAdded(const ModuleList &module_list,\n                         const lldb::ModuleSP &module_sp) override;\n\n  void NotifyModuleRemoved(const ModuleList &module_list,\n                           const lldb::ModuleSP &module_sp) override;\n\n  void NotifyModuleUpdated(const ModuleList &module_list,\n                           const lldb::ModuleSP &old_module_sp,\n                           const lldb::ModuleSP &new_module_sp) override;\n\n  void NotifyWillClearList(const ModuleList &module_list) override;\n\n  void NotifyModulesRemoved(lldb_private::ModuleList &module_list) override;\n\n  class Arch {\n  public:\n    explicit Arch(const ArchSpec &spec);\n    const Arch &operator=(const ArchSpec &spec);\n\n    const ArchSpec &GetSpec() const { return m_spec; }\n    Architecture *GetPlugin() const { return m_plugin_up.get(); }\n\n  private:\n    ArchSpec m_spec;\n    std::unique_ptr<Architecture> m_plugin_up;\n  };\n  // Member variables.\n  Debugger &m_debugger;\n  lldb::PlatformSP m_platform_sp; ///< The platform for this target.\n  std::recursive_mutex m_mutex; ///< An API mutex that is used by the lldb::SB*\n                                /// classes make the SB interface thread safe\n  /// When the private state thread calls SB API's - usually because it is\n  /// running OS plugin or Python ThreadPlan code - it should not block on the\n  /// API mutex that is held by the code that kicked off the sequence of events\n  /// that led us to run the code.  We hand out this mutex instead when we\n  /// detect that code is running on the private state thread.\n  std::recursive_mutex m_private_mutex;\n  Arch m_arch;\n  ModuleList m_images; ///< The list of images for this process (shared\n                       /// libraries and anything dynamically loaded).\n  SectionLoadHistory m_section_load_history;\n  BreakpointList m_breakpoint_list;\n  BreakpointList m_internal_breakpoint_list;\n  using BreakpointNameList = std::map<ConstString, BreakpointName *>;\n  BreakpointNameList m_breakpoint_names;\n\n  lldb::BreakpointSP m_last_created_breakpoint;\n  WatchpointList m_watchpoint_list;\n  lldb::WatchpointSP m_last_created_watchpoint;\n  // We want to tightly control the process destruction process so we can\n  // correctly tear down everything that we need to, so the only class that\n  // knows about the process lifespan is this target class.\n  lldb::ProcessSP m_process_sp;\n  lldb::SearchFilterSP m_search_filter_sp;\n  PathMappingList m_image_search_paths;\n  TypeSystemMap m_scratch_type_system_map;\n\n  typedef std::map<lldb::LanguageType, lldb::REPLSP> REPLMap;\n  REPLMap m_repl_map;\n\n  std::unique_ptr<ClangModulesDeclVendor> m_clang_modules_decl_vendor_up;\n\n  lldb::SourceManagerUP m_source_manager_up;\n\n  typedef std::map<lldb::user_id_t, StopHookSP> StopHookCollection;\n  StopHookCollection m_stop_hooks;\n  lldb::user_id_t m_stop_hook_next_id;\n  bool m_valid;\n  bool m_suppress_stop_hooks;\n  bool m_is_dummy_target;\n  unsigned m_next_persistent_variable_index = 0;\n  /// An optional \\a lldb_private::Trace object containing processor trace\n  /// information of this target.\n  lldb::TraceSP m_trace_sp;\n  /// Stores the frame recognizers of this target.\n  lldb::StackFrameRecognizerManagerUP m_frame_recognizer_manager_up;\n\n  static void ImageSearchPathsChanged(const PathMappingList &path_list,\n                                      void *baton);\n\n  // Utilities for `statistics` command.\nprivate:\n  std::vector<uint32_t> m_stats_storage;\n  bool m_collecting_stats = false;\n\npublic:\n  void SetCollectingStats(bool v) { m_collecting_stats = v; }\n\n  bool GetCollectingStats() { return m_collecting_stats; }\n\n  void IncrementStats(lldb_private::StatisticKind key) {\n    if (!GetCollectingStats())\n      return;\n    lldbassert(key < lldb_private::StatisticKind::StatisticMax &&\n               \"invalid statistics!\");\n    m_stats_storage[key] += 1;\n  }\n\n  std::vector<uint32_t> GetStatistics() { return m_stats_storage; }\n\nprivate:\n  /// Construct with optional file and arch.\n  ///\n  /// This member is private. Clients must use\n  /// TargetList::CreateTarget(const FileSpec*, const ArchSpec*)\n  /// so all targets can be tracked from the central target list.\n  ///\n  /// \\see TargetList::CreateTarget(const FileSpec*, const ArchSpec*)\n  Target(Debugger &debugger, const ArchSpec &target_arch,\n         const lldb::PlatformSP &platform_sp, bool is_dummy_target);\n\n  // Helper function.\n  bool ProcessIsValid();\n\n  // Copy breakpoints, stop hooks and so forth from the dummy target:\n  void PrimeFromDummyTarget(Target &target);\n\n  void AddBreakpoint(lldb::BreakpointSP breakpoint_sp, bool internal);\n\n  void FinalizeFileActions(ProcessLaunchInfo &info);\n\n  Target(const Target &) = delete;\n  const Target &operator=(const Target &) = delete;\n};\n\n} // namespace lldb_private\n\n#endif // LLDB_TARGET_TARGET_H\n"}, "29": {"id": 29, "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Target/Thread.h", "content": "//===-- Thread.h ------------------------------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLDB_TARGET_THREAD_H\n#define LLDB_TARGET_THREAD_H\n\n#include <memory>\n#include <mutex>\n#include <string>\n#include <vector>\n\n#include \"lldb/Core/UserSettingsController.h\"\n#include \"lldb/Target/ExecutionContextScope.h\"\n#include \"lldb/Target/RegisterCheckpoint.h\"\n#include \"lldb/Target/StackFrameList.h\"\n#include \"lldb/Utility/Broadcaster.h\"\n#include \"lldb/Utility/CompletionRequest.h\"\n#include \"lldb/Utility/Event.h\"\n#include \"lldb/Utility/StructuredData.h\"\n#include \"lldb/Utility/UserID.h\"\n#include \"lldb/lldb-private.h\"\n\n#define LLDB_THREAD_MAX_STOP_EXC_DATA 8\n\nnamespace lldb_private {\n\nclass ThreadPlanStack;\n\nclass ThreadProperties : public Properties {\npublic:\n  ThreadProperties(bool is_global);\n\n  ~ThreadProperties() override;\n\n  /// The regular expression returned determines symbols that this\n  /// thread won't stop in during \"step-in\" operations.\n  ///\n  /// \\return\n  ///    A pointer to a regular expression to compare against symbols,\n  ///    or nullptr if all symbols are allowed.\n  ///\n  const RegularExpression *GetSymbolsToAvoidRegexp();\n\n  FileSpecList GetLibrariesToAvoid() const;\n\n  bool GetTraceEnabledState() const;\n\n  bool GetStepInAvoidsNoDebug() const;\n\n  bool GetStepOutAvoidsNoDebug() const;\n\n  uint64_t GetMaxBacktraceDepth() const;\n};\n\ntypedef std::shared_ptr<ThreadProperties> ThreadPropertiesSP;\n\nclass Thread : public std::enable_shared_from_this<Thread>,\n               public ThreadProperties,\n               public UserID,\n               public ExecutionContextScope,\n               public Broadcaster {\npublic:\n  /// Broadcaster event bits definitions.\n  enum {\n    eBroadcastBitStackChanged = (1 << 0),\n    eBroadcastBitThreadSuspended = (1 << 1),\n    eBroadcastBitThreadResumed = (1 << 2),\n    eBroadcastBitSelectedFrameChanged = (1 << 3),\n    eBroadcastBitThreadSelected = (1 << 4)\n  };\n\n  static ConstString &GetStaticBroadcasterClass();\n\n  ConstString &GetBroadcasterClass() const override {\n    return GetStaticBroadcasterClass();\n  }\n\n  class ThreadEventData : public EventData {\n  public:\n    ThreadEventData(const lldb::ThreadSP thread_sp);\n\n    ThreadEventData(const lldb::ThreadSP thread_sp, const StackID &stack_id);\n\n    ThreadEventData();\n\n    ~ThreadEventData() override;\n\n    static ConstString GetFlavorString();\n\n    ConstString GetFlavor() const override {\n      return ThreadEventData::GetFlavorString();\n    }\n\n    void Dump(Stream *s) const override;\n\n    static const ThreadEventData *GetEventDataFromEvent(const Event *event_ptr);\n\n    static lldb::ThreadSP GetThreadFromEvent(const Event *event_ptr);\n\n    static StackID GetStackIDFromEvent(const Event *event_ptr);\n\n    static lldb::StackFrameSP GetStackFrameFromEvent(const Event *event_ptr);\n\n    lldb::ThreadSP GetThread() const { return m_thread_sp; }\n\n    StackID GetStackID() const { return m_stack_id; }\n\n  private:\n    lldb::ThreadSP m_thread_sp;\n    StackID m_stack_id;\n\n    ThreadEventData(const ThreadEventData &) = delete;\n    const ThreadEventData &operator=(const ThreadEventData &) = delete;\n  };\n\n  struct ThreadStateCheckpoint {\n    uint32_t orig_stop_id; // Dunno if I need this yet but it is an interesting\n                           // bit of data.\n    lldb::StopInfoSP stop_info_sp; // You have to restore the stop info or you\n                                   // might continue with the wrong signals.\n    size_t m_completed_plan_checkpoint;\n    lldb::RegisterCheckpointSP\n        register_backup_sp; // You need to restore the registers, of course...\n    uint32_t current_inlined_depth;\n    lldb::addr_t current_inlined_pc;\n  };\n\n  /// Constructor\n  ///\n  /// \\param [in] use_invalid_index_id\n  ///     Optional parameter, defaults to false.  The only subclass that\n  ///     is likely to set use_invalid_index_id == true is the HistoryThread\n  ///     class.  In that case, the Thread we are constructing represents\n  ///     a thread from earlier in the program execution.  We may have the\n  ///     tid of the original thread that they represent but we don't want\n  ///     to reuse the IndexID of that thread, or create a new one.  If a\n  ///     client wants to know the original thread's IndexID, they should use\n  ///     Thread::GetExtendedBacktraceOriginatingIndexID().\n  Thread(Process &process, lldb::tid_t tid, bool use_invalid_index_id = false);\n\n  ~Thread() override;\n\n  static void SettingsInitialize();\n\n  static void SettingsTerminate();\n\n  static const ThreadPropertiesSP &GetGlobalProperties();\n\n  lldb::ProcessSP GetProcess() const { return m_process_wp.lock(); }\n\n  int GetResumeSignal() const { return m_resume_signal; }\n\n  void SetResumeSignal(int signal) { m_resume_signal = signal; }\n\n  lldb::StateType GetState() const;\n\n  void SetState(lldb::StateType state);\n\n  /// Sets the USER resume state for this thread.  If you set a thread to\n  /// suspended with\n  /// this API, it won't take part in any of the arbitration for ShouldResume,\n  /// and will stay\n  /// suspended even when other threads do get to run.\n  ///\n  /// N.B. This is not the state that is used internally by thread plans to\n  /// implement\n  /// staying on one thread while stepping over a breakpoint, etc.  The is the\n  /// TemporaryResume state, and if you are implementing some bit of strategy in\n  /// the stepping\n  /// machinery you should be using that state and not the user resume state.\n  ///\n  /// If you are just preparing all threads to run, you should not override the\n  /// threads that are\n  /// marked as suspended by the debugger.  In that case, pass override_suspend\n  /// = false.  If you want\n  /// to force the thread to run (e.g. the \"thread continue\" command, or are\n  /// resetting the state\n  /// (e.g. in SBThread::Resume()), then pass true to override_suspend.\n  void SetResumeState(lldb::StateType state, bool override_suspend = false) {\n    if (m_resume_state == lldb::eStateSuspended && !override_suspend)\n      return;\n    m_resume_state = state;\n  }\n\n  /// Gets the USER resume state for this thread.  This is not the same as what\n  /// this thread is going to do for any particular step, however if this thread\n  /// returns eStateSuspended, then the process control logic will never allow\n  /// this\n  /// thread to run.\n  ///\n  /// \\return\n  ///    The User resume state for this thread.\n  lldb::StateType GetResumeState() const { return m_resume_state; }\n\n  // This function is called on all the threads before \"ShouldResume\" and\n  // \"WillResume\" in case a thread needs to change its state before the\n  // ThreadList polls all the threads to figure out which ones actually will\n  // get to run and how.\n  void SetupForResume();\n\n  // Do not override this function, it is for thread plan logic only\n  bool ShouldResume(lldb::StateType resume_state);\n\n  // Override this to do platform specific tasks before resume.\n  virtual void WillResume(lldb::StateType resume_state) {}\n\n  // This clears generic thread state after a resume.  If you subclass this, be\n  // sure to call it.\n  virtual void DidResume();\n\n  // This notifies the thread when a private stop occurs.\n  virtual void DidStop();\n\n  virtual void RefreshStateAfterStop() = 0;\n\n  void SelectMostRelevantFrame();\n\n  std::string GetStopDescription();\n\n  std::string GetStopDescriptionRaw();\n\n  void WillStop();\n\n  bool ShouldStop(Event *event_ptr);\n\n  Vote ShouldReportStop(Event *event_ptr);\n\n  Vote ShouldReportRun(Event *event_ptr);\n\n  void Flush();\n\n  // Return whether this thread matches the specification in ThreadSpec.  This\n  // is a virtual method because at some point we may extend the thread spec\n  // with a platform specific dictionary of attributes, which then only the\n  // platform specific Thread implementation would know how to match.  For now,\n  // this just calls through to the ThreadSpec's ThreadPassesBasicTests method.\n  virtual bool MatchesSpec(const ThreadSpec *spec);\n\n  lldb::StopInfoSP GetStopInfo();\n\n  lldb::StopReason GetStopReason();\n\n  bool StopInfoIsUpToDate() const;\n\n  // This sets the stop reason to a \"blank\" stop reason, so you can call\n  // functions on the thread without having the called function run with\n  // whatever stop reason you stopped with.\n  void SetStopInfoToNothing();\n\n  bool ThreadStoppedForAReason();\n\n  static std::string RunModeAsString(lldb::RunMode mode);\n\n  static std::string StopReasonAsString(lldb::StopReason reason);\n\n  virtual const char *GetInfo() { return nullptr; }\n\n  /// Retrieve a dictionary of information about this thread\n  ///\n  /// On Mac OS X systems there may be voucher information.\n  /// The top level dictionary returned will have an \"activity\" key and the\n  /// value of the activity is a dictionary.  Keys in that dictionary will\n  /// be \"name\" and \"id\", among others.\n  /// There may also be \"trace_messages\" (an array) with each entry in that\n  /// array\n  /// being a dictionary (keys include \"message\" with the text of the trace\n  /// message).\n  StructuredData::ObjectSP GetExtendedInfo() {\n    if (!m_extended_info_fetched) {\n      m_extended_info = FetchThreadExtendedInfo();\n      m_extended_info_fetched = true;\n    }\n    return m_extended_info;\n  }\n\n  virtual const char *GetName() { return nullptr; }\n\n  virtual void SetName(const char *name) {}\n\n  /// Whether this thread can be associated with a libdispatch queue\n  ///\n  /// The Thread may know if it is associated with a libdispatch queue,\n  /// it may know definitively that it is NOT associated with a libdispatch\n  /// queue, or it may be unknown whether it is associated with a libdispatch\n  /// queue.\n  ///\n  /// \\return\n  ///     eLazyBoolNo if this thread is definitely not associated with a\n  ///     libdispatch queue (e.g. on a non-Darwin system where GCD aka\n  ///     libdispatch is not available).\n  ///\n  ///     eLazyBoolYes this thread is associated with a libdispatch queue.\n  ///\n  ///     eLazyBoolCalculate this thread may be associated with a libdispatch\n  ///     queue but the thread doesn't know one way or the other.\n  virtual lldb_private::LazyBool GetAssociatedWithLibdispatchQueue() {\n    return eLazyBoolNo;\n  }\n\n  virtual void SetAssociatedWithLibdispatchQueue(\n      lldb_private::LazyBool associated_with_libdispatch_queue) {}\n\n  /// Retrieve the Queue ID for the queue currently using this Thread\n  ///\n  /// If this Thread is doing work on behalf of a libdispatch/GCD queue,\n  /// retrieve the QueueID.\n  ///\n  /// This is a unique identifier for the libdispatch/GCD queue in a\n  /// process.  Often starting at 1 for the initial system-created\n  /// queues and incrementing, a QueueID will not be reused for a\n  /// different queue during the lifetime of a process.\n  ///\n  /// \\return\n  ///     A QueueID if the Thread subclass implements this, else\n  ///     LLDB_INVALID_QUEUE_ID.\n  virtual lldb::queue_id_t GetQueueID() { return LLDB_INVALID_QUEUE_ID; }\n\n  virtual void SetQueueID(lldb::queue_id_t new_val) {}\n\n  /// Retrieve the Queue name for the queue currently using this Thread\n  ///\n  /// If this Thread is doing work on behalf of a libdispatch/GCD queue,\n  /// retrieve the Queue name.\n  ///\n  /// \\return\n  ///     The Queue name, if the Thread subclass implements this, else\n  ///     nullptr.\n  virtual const char *GetQueueName() { return nullptr; }\n\n  virtual void SetQueueName(const char *name) {}\n\n  /// Retrieve the Queue kind for the queue currently using this Thread\n  ///\n  /// If this Thread is doing work on behalf of a libdispatch/GCD queue,\n  /// retrieve the Queue kind - either eQueueKindSerial or\n  /// eQueueKindConcurrent, indicating that this queue processes work\n  /// items serially or concurrently.\n  ///\n  /// \\return\n  ///     The Queue kind, if the Thread subclass implements this, else\n  ///     eQueueKindUnknown.\n  virtual lldb::QueueKind GetQueueKind() { return lldb::eQueueKindUnknown; }\n\n  virtual void SetQueueKind(lldb::QueueKind kind) {}\n\n  /// Retrieve the Queue for this thread, if any.\n  ///\n  /// \\return\n  ///     A QueueSP for the queue that is currently associated with this\n  ///     thread.\n  ///     An empty shared pointer indicates that this thread is not\n  ///     associated with a queue, or libdispatch queues are not\n  ///     supported on this target.\n  virtual lldb::QueueSP GetQueue() { return lldb::QueueSP(); }\n\n  /// Retrieve the address of the libdispatch_queue_t struct for queue\n  /// currently using this Thread\n  ///\n  /// If this Thread is doing work on behalf of a libdispatch/GCD queue,\n  /// retrieve the address of the libdispatch_queue_t structure describing\n  /// the queue.\n  ///\n  /// This address may be reused for different queues later in the Process\n  /// lifetime and should not be used to identify a queue uniquely.  Use\n  /// the GetQueueID() call for that.\n  ///\n  /// \\return\n  ///     The Queue's libdispatch_queue_t address if the Thread subclass\n  ///     implements this, else LLDB_INVALID_ADDRESS.\n  virtual lldb::addr_t GetQueueLibdispatchQueueAddress() {\n    return LLDB_INVALID_ADDRESS;\n  }\n\n  virtual void SetQueueLibdispatchQueueAddress(lldb::addr_t dispatch_queue_t) {}\n\n  /// Whether this Thread already has all the Queue information cached or not\n  ///\n  /// A Thread may be associated with a libdispatch work Queue at a given\n  /// public stop event.  If so, the thread can satisify requests like\n  /// GetQueueLibdispatchQueueAddress, GetQueueKind, GetQueueName, and\n  /// GetQueueID\n  /// either from information from the remote debug stub when it is initially\n  /// created, or it can query the SystemRuntime for that information.\n  ///\n  /// This method allows the SystemRuntime to discover if a thread has this\n  /// information already, instead of calling the thread to get the information\n  /// and having the thread call the SystemRuntime again.\n  virtual bool ThreadHasQueueInformation() const { return false; }\n\n  virtual uint32_t GetStackFrameCount() {\n    return GetStackFrameList()->GetNumFrames();\n  }\n\n  virtual lldb::StackFrameSP GetStackFrameAtIndex(uint32_t idx) {\n    return GetStackFrameList()->GetFrameAtIndex(idx);\n  }\n\n  virtual lldb::StackFrameSP\n  GetFrameWithConcreteFrameIndex(uint32_t unwind_idx);\n\n  bool DecrementCurrentInlinedDepth() {\n    return GetStackFrameList()->DecrementCurrentInlinedDepth();\n  }\n\n  uint32_t GetCurrentInlinedDepth() {\n    return GetStackFrameList()->GetCurrentInlinedDepth();\n  }\n\n  Status ReturnFromFrameWithIndex(uint32_t frame_idx,\n                                  lldb::ValueObjectSP return_value_sp,\n                                  bool broadcast = false);\n\n  Status ReturnFromFrame(lldb::StackFrameSP frame_sp,\n                         lldb::ValueObjectSP return_value_sp,\n                         bool broadcast = false);\n\n  Status JumpToLine(const FileSpec &file, uint32_t line,\n                    bool can_leave_function, std::string *warnings = nullptr);\n\n  virtual lldb::StackFrameSP GetFrameWithStackID(const StackID &stack_id) {\n    if (stack_id.IsValid())\n      return GetStackFrameList()->GetFrameWithStackID(stack_id);\n    return lldb::StackFrameSP();\n  }\n\n  uint32_t GetSelectedFrameIndex() {\n    return GetStackFrameList()->GetSelectedFrameIndex();\n  }\n\n  lldb::StackFrameSP GetSelectedFrame();\n\n  uint32_t SetSelectedFrame(lldb_private::StackFrame *frame,\n                            bool broadcast = false);\n\n  bool SetSelectedFrameByIndex(uint32_t frame_idx, bool broadcast = false);\n\n  bool SetSelectedFrameByIndexNoisily(uint32_t frame_idx,\n                                      Stream &output_stream);\n\n  void SetDefaultFileAndLineToSelectedFrame() {\n    GetStackFrameList()->SetDefaultFileAndLineToSelectedFrame();\n  }\n\n  virtual lldb::RegisterContextSP GetRegisterContext() = 0;\n\n  virtual lldb::RegisterContextSP\n  CreateRegisterContextForFrame(StackFrame *frame) = 0;\n\n  virtual void ClearStackFrames();\n\n  virtual bool SetBackingThread(const lldb::ThreadSP &thread_sp) {\n    return false;\n  }\n\n  virtual lldb::ThreadSP GetBackingThread() const { return lldb::ThreadSP(); }\n\n  virtual void ClearBackingThread() {\n    // Subclasses can use this function if a thread is actually backed by\n    // another thread. This is currently used for the OperatingSystem plug-ins\n    // where they might have a thread that is in memory, yet its registers are\n    // available through the lldb_private::Thread subclass for the current\n    // lldb_private::Process class. Since each time the process stops the\n    // backing threads for memory threads can change, we need a way to clear\n    // the backing thread for all memory threads each time we stop.\n  }\n\n  /// Dump \\a count instructions of the thread's \\a Trace starting at the \\a\n  /// start_position position in reverse order.\n  ///\n  /// The instructions are indexed in reverse order, which means that the \\a\n  /// start_position 0 represents the last instruction of the trace\n  /// chronologically.\n  ///\n  /// \\param[in] s\n  ///   The stream object where the instructions are printed.\n  ///\n  /// \\param[in] count\n  ///     The number of instructions to print.\n  ///\n  /// \\param[in] start_position\n  ///     The position of the first instruction to print.\n  void DumpTraceInstructions(Stream &s, size_t count,\n                             size_t start_position = 0) const;\n\n  // If stop_format is true, this will be the form used when we print stop\n  // info. If false, it will be the form we use for thread list and co.\n  void DumpUsingSettingsFormat(Stream &strm, uint32_t frame_idx,\n                               bool stop_format);\n\n  bool GetDescription(Stream &s, lldb::DescriptionLevel level,\n                      bool print_json_thread, bool print_json_stopinfo);\n\n  /// Default implementation for stepping into.\n  ///\n  /// This function is designed to be used by commands where the\n  /// process is publicly stopped.\n  ///\n  /// \\param[in] source_step\n  ///     If true and the frame has debug info, then do a source level\n  ///     step in, else do a single instruction step in.\n  ///\n  /// \\param[in] step_in_avoids_code_without_debug_info\n  ///     If \\a true, then avoid stepping into code that doesn't have\n  ///     debug info, else step into any code regardless of whether it\n  ///     has debug info.\n  ///\n  /// \\param[in] step_out_avoids_code_without_debug_info\n  ///     If \\a true, then if you step out to code with no debug info, keep\n  ///     stepping out till you get to code with debug info.\n  ///\n  /// \\return\n  ///     An error that describes anything that went wrong\n  virtual Status\n  StepIn(bool source_step,\n         LazyBool step_in_avoids_code_without_debug_info = eLazyBoolCalculate,\n         LazyBool step_out_avoids_code_without_debug_info = eLazyBoolCalculate);\n\n  /// Default implementation for stepping over.\n  ///\n  /// This function is designed to be used by commands where the\n  /// process is publicly stopped.\n  ///\n  /// \\param[in] source_step\n  ///     If true and the frame has debug info, then do a source level\n  ///     step over, else do a single instruction step over.\n  ///\n  /// \\return\n  ///     An error that describes anything that went wrong\n  virtual Status StepOver(\n      bool source_step,\n      LazyBool step_out_avoids_code_without_debug_info = eLazyBoolCalculate);\n\n  /// Default implementation for stepping out.\n  ///\n  /// This function is designed to be used by commands where the\n  /// process is publicly stopped.\n  ///\n  /// \\return\n  ///     An error that describes anything that went wrong\n  virtual Status StepOut();\n\n  /// Retrieves the per-thread data area.\n  /// Most OSs maintain a per-thread pointer (e.g. the FS register on\n  /// x64), which we return the value of here.\n  ///\n  /// \\return\n  ///     LLDB_INVALID_ADDRESS if not supported, otherwise the thread\n  ///     pointer value.\n  virtual lldb::addr_t GetThreadPointer();\n\n  /// Retrieves the per-module TLS block for a thread.\n  ///\n  /// \\param[in] module\n  ///     The module to query TLS data for.\n  ///\n  /// \\param[in] tls_file_addr\n  ///     The thread local address in module\n  /// \\return\n  ///     If the thread has TLS data allocated for the\n  ///     module, the address of the TLS block. Otherwise\n  ///     LLDB_INVALID_ADDRESS is returned.\n  virtual lldb::addr_t GetThreadLocalData(const lldb::ModuleSP module,\n                                          lldb::addr_t tls_file_addr);\n\n  /// Check whether this thread is safe to run functions\n  ///\n  /// The SystemRuntime may know of certain thread states (functions in\n  /// process of execution, for instance) which can make it unsafe for\n  /// functions to be called.\n  ///\n  /// \\return\n  ///     True if it is safe to call functions on this thread.\n  ///     False if function calls should be avoided on this thread.\n  virtual bool SafeToCallFunctions();\n\n  // Thread Plan Providers:\n  // This section provides the basic thread plans that the Process control\n  // machinery uses to run the target.  ThreadPlan.h provides more details on\n  // how this mechanism works. The thread provides accessors to a set of plans\n  // that perform basic operations. The idea is that particular Platform\n  // plugins can override these methods to provide the implementation of these\n  // basic operations appropriate to their environment.\n  //\n  // NB: All the QueueThreadPlanXXX providers return Shared Pointers to\n  // Thread plans.  This is useful so that you can modify the plans after\n  // creation in ways specific to that plan type.  Also, it is often necessary\n  // for ThreadPlans that utilize other ThreadPlans to implement their task to\n  // keep a shared pointer to the sub-plan. But besides that, the shared\n  // pointers should only be held onto by entities who live no longer than the\n  // thread containing the ThreadPlan.\n  // FIXME: If this becomes a problem, we can make a version that just returns a\n  // pointer,\n  // which it is clearly unsafe to hold onto, and a shared pointer version, and\n  // only allow ThreadPlan and Co. to use the latter.  That is made more\n  // annoying to do because there's no elegant way to friend a method to all\n  // sub-classes of a given class.\n  //\n\n  /// Queues the base plan for a thread.\n  /// The version returned by Process does some things that are useful,\n  /// like handle breakpoints and signals, so if you return a plugin specific\n  /// one you probably want to call through to the Process one for anything\n  /// your plugin doesn't explicitly handle.\n  ///\n  /// \\param[in] abort_other_plans\n  ///    \\b true if we discard the currently queued plans and replace them with\n  ///    this one.\n  ///    Otherwise this plan will go on the end of the plan stack.\n  ///\n  /// \\return\n  ///     A shared pointer to the newly queued thread plan, or nullptr if the\n  ///     plan could not be queued.\n  lldb::ThreadPlanSP QueueBasePlan(bool abort_other_plans);\n\n  /// Queues the plan used to step one instruction from the current PC of \\a\n  /// thread.\n  ///\n  /// \\param[in] step_over\n  ///    \\b true if we step over calls to functions, false if we step in.\n  ///\n  /// \\param[in] abort_other_plans\n  ///    \\b true if we discard the currently queued plans and replace them with\n  ///    this one.\n  ///    Otherwise this plan will go on the end of the plan stack.\n  ///\n  /// \\param[in] stop_other_threads\n  ///    \\b true if we will stop other threads while we single step this one.\n  ///\n  /// \\param[out] status\n  ///     A status with an error if queuing failed.\n  ///\n  /// \\return\n  ///     A shared pointer to the newly queued thread plan, or nullptr if the\n  ///     plan could not be queued.\n  virtual lldb::ThreadPlanSP QueueThreadPlanForStepSingleInstruction(\n      bool step_over, bool abort_other_plans, bool stop_other_threads,\n      Status &status);\n\n  /// Queues the plan used to step through an address range, stepping  over\n  /// function calls.\n  ///\n  /// \\param[in] abort_other_plans\n  ///    \\b true if we discard the currently queued plans and replace them with\n  ///    this one.\n  ///    Otherwise this plan will go on the end of the plan stack.\n  ///\n  /// \\param[in] type\n  ///    Type of step to do, only eStepTypeInto and eStepTypeOver are supported\n  ///    by this plan.\n  ///\n  /// \\param[in] range\n  ///    The address range to step through.\n  ///\n  /// \\param[in] addr_context\n  ///    When dealing with stepping through inlined functions the current PC is\n  ///    not enough information to know\n  ///    what \"step\" means.  For instance a series of nested inline functions\n  ///    might start at the same address.\n  //     The \\a addr_context provides the current symbol context the step\n  ///    is supposed to be out of.\n  //   FIXME: Currently unused.\n  ///\n  /// \\param[in] stop_other_threads\n  ///    \\b true if we will stop other threads while we single step this one.\n  ///\n  /// \\param[out] status\n  ///     A status with an error if queuing failed.\n  ///\n  /// \\param[in] step_out_avoids_code_without_debug_info\n  ///    If eLazyBoolYes, if the step over steps out it will continue to step\n  ///    out till it comes to a frame with debug info.\n  ///    If eLazyBoolCalculate, we will consult the default set in the thread.\n  ///\n  /// \\return\n  ///     A shared pointer to the newly queued thread plan, or nullptr if the\n  ///     plan could not be queued.\n  virtual lldb::ThreadPlanSP QueueThreadPlanForStepOverRange(\n      bool abort_other_plans, const AddressRange &range,\n      const SymbolContext &addr_context, lldb::RunMode stop_other_threads,\n      Status &status,\n      LazyBool step_out_avoids_code_without_debug_info = eLazyBoolCalculate);\n\n  // Helper function that takes a LineEntry to step, insted of an AddressRange.\n  // This may combine multiple LineEntries of the same source line number to\n  // step over a longer address range in a single operation.\n  virtual lldb::ThreadPlanSP QueueThreadPlanForStepOverRange(\n      bool abort_other_plans, const LineEntry &line_entry,\n      const SymbolContext &addr_context, lldb::RunMode stop_other_threads,\n      Status &status,\n      LazyBool step_out_avoids_code_without_debug_info = eLazyBoolCalculate);\n\n  /// Queues the plan used to step through an address range, stepping into\n  /// functions.\n  ///\n  /// \\param[in] abort_other_plans\n  ///    \\b true if we discard the currently queued plans and replace them with\n  ///    this one.\n  ///    Otherwise this plan will go on the end of the plan stack.\n  ///\n  /// \\param[in] type\n  ///    Type of step to do, only eStepTypeInto and eStepTypeOver are supported\n  ///    by this plan.\n  ///\n  /// \\param[in] range\n  ///    The address range to step through.\n  ///\n  /// \\param[in] addr_context\n  ///    When dealing with stepping through inlined functions the current PC is\n  ///    not enough information to know\n  ///    what \"step\" means.  For instance a series of nested inline functions\n  ///    might start at the same address.\n  //     The \\a addr_context provides the current symbol context the step\n  ///    is supposed to be out of.\n  //   FIXME: Currently unused.\n  ///\n  /// \\param[in] step_in_target\n  ///    Name if function we are trying to step into.  We will step out if we\n  ///    don't land in that function.\n  ///\n  /// \\param[in] stop_other_threads\n  ///    \\b true if we will stop other threads while we single step this one.\n  ///\n  /// \\param[out] status\n  ///     A status with an error if queuing failed.\n  ///\n  /// \\param[in] step_in_avoids_code_without_debug_info\n  ///    If eLazyBoolYes we will step out if we step into code with no debug\n  ///    info.\n  ///    If eLazyBoolCalculate we will consult the default set in the thread.\n  ///\n  /// \\param[in] step_out_avoids_code_without_debug_info\n  ///    If eLazyBoolYes, if the step over steps out it will continue to step\n  ///    out till it comes to a frame with debug info.\n  ///    If eLazyBoolCalculate, it will consult the default set in the thread.\n  ///\n  /// \\return\n  ///     A shared pointer to the newly queued thread plan, or nullptr if the\n  ///     plan could not be queued.\n  virtual lldb::ThreadPlanSP QueueThreadPlanForStepInRange(\n      bool abort_other_plans, const AddressRange &range,\n      const SymbolContext &addr_context, const char *step_in_target,\n      lldb::RunMode stop_other_threads, Status &status,\n      LazyBool step_in_avoids_code_without_debug_info = eLazyBoolCalculate,\n      LazyBool step_out_avoids_code_without_debug_info = eLazyBoolCalculate);\n\n  // Helper function that takes a LineEntry to step, insted of an AddressRange.\n  // This may combine multiple LineEntries of the same source line number to\n  // step over a longer address range in a single operation.\n  virtual lldb::ThreadPlanSP QueueThreadPlanForStepInRange(\n      bool abort_other_plans, const LineEntry &line_entry,\n      const SymbolContext &addr_context, const char *step_in_target,\n      lldb::RunMode stop_other_threads, Status &status,\n      LazyBool step_in_avoids_code_without_debug_info = eLazyBoolCalculate,\n      LazyBool step_out_avoids_code_without_debug_info = eLazyBoolCalculate);\n\n  /// Queue the plan used to step out of the function at the current PC of\n  /// \\a thread.\n  ///\n  /// \\param[in] abort_other_plans\n  ///    \\b true if we discard the currently queued plans and replace them with\n  ///    this one.\n  ///    Otherwise this plan will go on the end of the plan stack.\n  ///\n  /// \\param[in] addr_context\n  ///    When dealing with stepping through inlined functions the current PC is\n  ///    not enough information to know\n  ///    what \"step\" means.  For instance a series of nested inline functions\n  ///    might start at the same address.\n  //     The \\a addr_context provides the current symbol context the step\n  ///    is supposed to be out of.\n  //   FIXME: Currently unused.\n  ///\n  /// \\param[in] first_insn\n  ///     \\b true if this is the first instruction of a function.\n  ///\n  /// \\param[in] stop_other_threads\n  ///    \\b true if we will stop other threads while we single step this one.\n  ///\n  /// \\param[in] report_stop_vote\n  ///    See standard meanings for the stop & run votes in ThreadPlan.h.\n  ///\n  /// \\param[in] report_run_vote\n  ///    See standard meanings for the stop & run votes in ThreadPlan.h.\n  ///\n  /// \\param[out] status\n  ///     A status with an error if queuing failed.\n  ///\n  /// \\param[in] step_out_avoids_code_without_debug_info\n  ///    If eLazyBoolYes, if the step over steps out it will continue to step\n  ///    out till it comes to a frame with debug info.\n  ///    If eLazyBoolCalculate, it will consult the default set in the thread.\n  ///\n  /// \\return\n  ///     A shared pointer to the newly queued thread plan, or nullptr if the\n  ///     plan could not be queued.\n  virtual lldb::ThreadPlanSP QueueThreadPlanForStepOut(\n      bool abort_other_plans, SymbolContext *addr_context, bool first_insn,\n      bool stop_other_threads, Vote report_stop_vote, Vote report_run_vote,\n      uint32_t frame_idx, Status &status,\n      LazyBool step_out_avoids_code_without_debug_info = eLazyBoolCalculate);\n\n  /// Queue the plan used to step out of the function at the current PC of\n  /// a thread.  This version does not consult the should stop here callback,\n  /// and should only\n  /// be used by other thread plans when they need to retain control of the step\n  /// out.\n  ///\n  /// \\param[in] abort_other_plans\n  ///    \\b true if we discard the currently queued plans and replace them with\n  ///    this one.\n  ///    Otherwise this plan will go on the end of the plan stack.\n  ///\n  /// \\param[in] addr_context\n  ///    When dealing with stepping through inlined functions the current PC is\n  ///    not enough information to know\n  ///    what \"step\" means.  For instance a series of nested inline functions\n  ///    might start at the same address.\n  //     The \\a addr_context provides the current symbol context the step\n  ///    is supposed to be out of.\n  //   FIXME: Currently unused.\n  ///\n  /// \\param[in] first_insn\n  ///     \\b true if this is the first instruction of a function.\n  ///\n  /// \\param[in] stop_other_threads\n  ///    \\b true if we will stop other threads while we single step this one.\n  ///\n  /// \\param[in] report_stop_vote\n  ///    See standard meanings for the stop & run votes in ThreadPlan.h.\n  ///\n  /// \\param[in] report_run_vote\n  ///    See standard meanings for the stop & run votes in ThreadPlan.h.\n  ///\n  /// \\param[in] frame_idx\n  ///     The fame index.\n  ///\n  /// \\param[out] status\n  ///     A status with an error if queuing failed.\n  ///\n  /// \\param[in] continue_to_next_branch\n  ///    Normally this will enqueue a plan that will put a breakpoint on the\n  ///    return address and continue\n  ///    to there.  If continue_to_next_branch is true, this is an operation not\n  ///    involving the user --\n  ///    e.g. stepping \"next\" in a source line and we instruction stepped into\n  ///    another function --\n  ///    so instead of putting a breakpoint on the return address, advance the\n  ///    breakpoint to the\n  ///    end of the source line that is doing the call, or until the next flow\n  ///    control instruction.\n  ///    If the return value from the function call is to be retrieved /\n  ///    displayed to the user, you must stop\n  ///    on the return address.  The return value may be stored in volatile\n  ///    registers which are overwritten\n  ///    before the next branch instruction.\n  ///\n  /// \\return\n  ///     A shared pointer to the newly queued thread plan, or nullptr if the\n  ///     plan could not be queued.\n  virtual lldb::ThreadPlanSP QueueThreadPlanForStepOutNoShouldStop(\n      bool abort_other_plans, SymbolContext *addr_context, bool first_insn,\n      bool stop_other_threads, Vote report_stop_vote, Vote report_run_vote,\n      uint32_t frame_idx, Status &status, bool continue_to_next_branch = false);\n\n  /// Gets the plan used to step through the code that steps from a function\n  /// call site at the current PC into the actual function call.\n  ///\n  /// \\param[in] return_stack_id\n  ///    The stack id that we will return to (by setting backstop breakpoints on\n  ///    the return\n  ///    address to that frame) if we fail to step through.\n  ///\n  /// \\param[in] abort_other_plans\n  ///    \\b true if we discard the currently queued plans and replace them with\n  ///    this one.\n  ///    Otherwise this plan will go on the end of the plan stack.\n  ///\n  /// \\param[in] stop_other_threads\n  ///    \\b true if we will stop other threads while we single step this one.\n  ///\n  /// \\param[out] status\n  ///     A status with an error if queuing failed.\n  ///\n  /// \\return\n  ///     A shared pointer to the newly queued thread plan, or nullptr if the\n  ///     plan could not be queued.\n  virtual lldb::ThreadPlanSP\n  QueueThreadPlanForStepThrough(StackID &return_stack_id,\n                                bool abort_other_plans, bool stop_other_threads,\n                                Status &status);\n\n  /// Gets the plan used to continue from the current PC.\n  /// This is a simple plan, mostly useful as a backstop when you are continuing\n  /// for some particular purpose.\n  ///\n  /// \\param[in] abort_other_plans\n  ///    \\b true if we discard the currently queued plans and replace them with\n  ///    this one.\n  ///    Otherwise this plan will go on the end of the plan stack.\n  ///\n  /// \\param[in] target_addr\n  ///    The address to which we're running.\n  ///\n  /// \\param[in] stop_other_threads\n  ///    \\b true if we will stop other threads while we single step this one.\n  ///\n  /// \\param[out] status\n  ///     A status with an error if queuing failed.\n  ///\n  /// \\return\n  ///     A shared pointer to the newly queued thread plan, or nullptr if the\n  ///     plan could not be queued.\n  virtual lldb::ThreadPlanSP\n  QueueThreadPlanForRunToAddress(bool abort_other_plans, Address &target_addr,\n                                 bool stop_other_threads, Status &status);\n\n  virtual lldb::ThreadPlanSP QueueThreadPlanForStepUntil(\n      bool abort_other_plans, lldb::addr_t *address_list, size_t num_addresses,\n      bool stop_others, uint32_t frame_idx, Status &status);\n\n  virtual lldb::ThreadPlanSP\n  QueueThreadPlanForStepScripted(bool abort_other_plans, const char *class_name,\n                                 StructuredData::ObjectSP extra_args_sp,\n                                 bool stop_other_threads, Status &status);\n\n  // Thread Plan accessors:\n\n  /// Format the thread plan information for auto completion.\n  ///\n  /// \\param[in] request\n  ///     The reference to the completion handler.\n  void AutoCompleteThreadPlans(CompletionRequest &request) const;\n\n  /// Gets the plan which will execute next on the plan stack.\n  ///\n  /// \\return\n  ///     A pointer to the next executed plan.\n  ThreadPlan *GetCurrentPlan() const;\n\n  /// Unwinds the thread stack for the innermost expression plan currently\n  /// on the thread plan stack.\n  ///\n  /// \\return\n  ///     An error if the thread plan could not be unwound.\n\n  Status UnwindInnermostExpression();\n\n  /// Gets the outer-most plan that was popped off the plan stack in the\n  /// most recent stop.  Useful for printing the stop reason accurately.\n  ///\n  /// \\return\n  ///     A pointer to the last completed plan.\n  lldb::ThreadPlanSP GetCompletedPlan() const;\n\n  /// Gets the outer-most return value from the completed plans\n  ///\n  /// \\return\n  ///     A ValueObjectSP, either empty if there is no return value,\n  ///     or containing the return value.\n  lldb::ValueObjectSP GetReturnValueObject() const;\n\n  /// Gets the outer-most expression variable from the completed plans\n  ///\n  /// \\return\n  ///     A ExpressionVariableSP, either empty if there is no\n  ///     plan completed an expression during the current stop\n  ///     or the expression variable that was made for the completed expression.\n  lldb::ExpressionVariableSP GetExpressionVariable() const;\n\n  ///  Checks whether the given plan is in the completed plans for this\n  ///  stop.\n  ///\n  /// \\param[in] plan\n  ///     Pointer to the plan you're checking.\n  ///\n  /// \\return\n  ///     Returns true if the input plan is in the completed plan stack,\n  ///     false otherwise.\n  bool IsThreadPlanDone(ThreadPlan *plan) const;\n\n  ///  Checks whether the given plan is in the discarded plans for this\n  ///  stop.\n  ///\n  /// \\param[in] plan\n  ///     Pointer to the plan you're checking.\n  ///\n  /// \\return\n  ///     Returns true if the input plan is in the discarded plan stack,\n  ///     false otherwise.\n  bool WasThreadPlanDiscarded(ThreadPlan *plan) const;\n\n  /// Check if we have completed plan to override breakpoint stop reason\n  ///\n  /// \\return\n  ///     Returns true if completed plan stack is not empty\n  ///     false otherwise.\n  bool CompletedPlanOverridesBreakpoint() const;\n\n  /// Queues a generic thread plan.\n  ///\n  /// \\param[in] plan_sp\n  ///    The plan to queue.\n  ///\n  /// \\param[in] abort_other_plans\n  ///    \\b true if we discard the currently queued plans and replace them with\n  ///    this one.\n  ///    Otherwise this plan will go on the end of the plan stack.\n  ///\n  /// \\return\n  ///     A pointer to the last completed plan.\n  Status QueueThreadPlan(lldb::ThreadPlanSP &plan_sp, bool abort_other_plans);\n\n  /// Discards the plans queued on the plan stack of the current thread.  This\n  /// is\n  /// arbitrated by the \"Master\" ThreadPlans, using the \"OkayToDiscard\" call.\n  //  But if \\a force is true, all thread plans are discarded.\n  void DiscardThreadPlans(bool force);\n\n  /// Discards the plans queued on the plan stack of the current thread up to\n  /// and\n  /// including up_to_plan_sp.\n  //\n  // \\param[in] up_to_plan_sp\n  //   Discard all plans up to and including this one.\n  void DiscardThreadPlansUpToPlan(lldb::ThreadPlanSP &up_to_plan_sp);\n\n  void DiscardThreadPlansUpToPlan(ThreadPlan *up_to_plan_ptr);\n\n  /// Discards the plans queued on the plan stack of the current thread up to\n  /// and\n  /// including the plan in that matches \\a thread_index counting only\n  /// the non-Private plans.\n  ///\n  /// \\param[in] thread_index\n  ///   Discard all plans up to and including this user plan given by this\n  ///   index.\n  ///\n  /// \\return\n  ///    \\b true if there was a thread plan with that user index, \\b false\n  ///    otherwise.\n  bool DiscardUserThreadPlansUpToIndex(uint32_t thread_index);\n\n  virtual bool CheckpointThreadState(ThreadStateCheckpoint &saved_state);\n\n  virtual bool\n  RestoreRegisterStateFromCheckpoint(ThreadStateCheckpoint &saved_state);\n\n  void RestoreThreadStateFromCheckpoint(ThreadStateCheckpoint &saved_state);\n\n  // Get the thread index ID. The index ID that is guaranteed to not be re-used\n  // by a process. They start at 1 and increase with each new thread. This\n  // allows easy command line access by a unique ID that is easier to type than\n  // the actual system thread ID.\n  uint32_t GetIndexID() const;\n\n  // Get the originating thread's index ID.\n  // In the case of an \"extended\" thread -- a thread which represents the stack\n  // that enqueued/spawned work that is currently executing -- we need to\n  // provide the IndexID of the thread that actually did this work.  We don't\n  // want to just masquerade as that thread's IndexID by using it in our own\n  // IndexID because that way leads to madness - but the driver program which\n  // is iterating over extended threads may ask for the OriginatingThreadID to\n  // display that information to the user.\n  // Normal threads will return the same thing as GetIndexID();\n  virtual uint32_t GetExtendedBacktraceOriginatingIndexID() {\n    return GetIndexID();\n  }\n\n  // The API ID is often the same as the Thread::GetID(), but not in all cases.\n  // Thread::GetID() is the user visible thread ID that clients would want to\n  // see. The API thread ID is the thread ID that is used when sending data\n  // to/from the debugging protocol.\n  virtual lldb::user_id_t GetProtocolID() const { return GetID(); }\n\n  // lldb::ExecutionContextScope pure virtual functions\n  lldb::TargetSP CalculateTarget() override;\n\n  lldb::ProcessSP CalculateProcess() override;\n\n  lldb::ThreadSP CalculateThread() override;\n\n  lldb::StackFrameSP CalculateStackFrame() override;\n\n  void CalculateExecutionContext(ExecutionContext &exe_ctx) override;\n\n  lldb::StackFrameSP\n  GetStackFrameSPForStackFramePtr(StackFrame *stack_frame_ptr);\n\n  size_t GetStatus(Stream &strm, uint32_t start_frame, uint32_t num_frames,\n                   uint32_t num_frames_with_source, bool stop_format,\n                   bool only_stacks = false);\n\n  size_t GetStackFrameStatus(Stream &strm, uint32_t first_frame,\n                             uint32_t num_frames, bool show_frame_info,\n                             uint32_t num_frames_with_source);\n\n  // We need a way to verify that even though we have a thread in a shared\n  // pointer that the object itself is still valid. Currently this won't be the\n  // case if DestroyThread() was called. DestroyThread is called when a thread\n  // has been removed from the Process' thread list.\n  bool IsValid() const { return !m_destroy_called; }\n\n  // Sets and returns a valid stop info based on the process stop ID and the\n  // current thread plan. If the thread stop ID does not match the process'\n  // stop ID, the private stop reason is not set and an invalid StopInfoSP may\n  // be returned.\n  //\n  // NOTE: This function must be called before the current thread plan is\n  // moved to the completed plan stack (in Thread::ShouldStop()).\n  //\n  // NOTE: If subclasses override this function, ensure they do not overwrite\n  // the m_actual_stop_info if it is valid.  The stop info may be a\n  // \"checkpointed and restored\" stop info, so if it is still around it is\n  // right even if you have not calculated this yourself, or if it disagrees\n  // with what you might have calculated.\n  virtual lldb::StopInfoSP GetPrivateStopInfo();\n\n  // Calculate the stop info that will be shown to lldb clients.  For instance,\n  // a \"step out\" is implemented by running to a breakpoint on the function\n  // return PC, so the process plugin initially sets the stop info to a\n  // StopInfoBreakpoint. But once we've run the ShouldStop machinery, we\n  // discover that there's a completed ThreadPlanStepOut, and that's really\n  // the StopInfo we want to show.  That will happen naturally the next\n  // time GetStopInfo is called, but if you want to force the replacement,\n  // you can call this.\n\n  void CalculatePublicStopInfo();\n\n  // Ask the thread subclass to set its stop info.\n  //\n  // Thread subclasses should call Thread::SetStopInfo(...) with the reason the\n  // thread stopped.\n  //\n  // \\return\n  //      True if Thread::SetStopInfo(...) was called, false otherwise.\n  virtual bool CalculateStopInfo() = 0;\n\n  // Gets the temporary resume state for a thread.\n  //\n  // This value gets set in each thread by complex debugger logic in\n  // Thread::ShouldResume() and an appropriate thread resume state will get set\n  // in each thread every time the process is resumed prior to calling\n  // Process::DoResume(). The lldb_private::Process subclass should adhere to\n  // the thread resume state request which will be one of:\n  //\n  //  eStateRunning   - thread will resume when process is resumed\n  //  eStateStepping  - thread should step 1 instruction and stop when process\n  //                    is resumed\n  //  eStateSuspended - thread should not execute any instructions when\n  //                    process is resumed\n  lldb::StateType GetTemporaryResumeState() const {\n    return m_temporary_resume_state;\n  }\n\n  void SetStopInfo(const lldb::StopInfoSP &stop_info_sp);\n\n  void ResetStopInfo();\n\n  void SetShouldReportStop(Vote vote);\n\n  /// Sets the extended backtrace token for this thread\n  ///\n  /// Some Thread subclasses may maintain a token to help with providing\n  /// an extended backtrace.  The SystemRuntime plugin will set/request this.\n  ///\n  /// \\param [in] token The extended backtrace token.\n  virtual void SetExtendedBacktraceToken(uint64_t token) {}\n\n  /// Gets the extended backtrace token for this thread\n  ///\n  /// Some Thread subclasses may maintain a token to help with providing\n  /// an extended backtrace.  The SystemRuntime plugin will set/request this.\n  ///\n  /// \\return\n  ///     The token needed by the SystemRuntime to create an extended backtrace.\n  ///     LLDB_INVALID_ADDRESS is returned if no token is available.\n  virtual uint64_t GetExtendedBacktraceToken() { return LLDB_INVALID_ADDRESS; }\n\n  lldb::ValueObjectSP GetCurrentException();\n\n  lldb::ThreadSP GetCurrentExceptionBacktrace();\n\nprotected:\n  friend class ThreadPlan;\n  friend class ThreadList;\n  friend class ThreadEventData;\n  friend class StackFrameList;\n  friend class StackFrame;\n  friend class OperatingSystem;\n\n  // This is necessary to make sure thread assets get destroyed while the\n  // thread is still in good shape to call virtual thread methods.  This must\n  // be called by classes that derive from Thread in their destructor.\n  virtual void DestroyThread();\n\n  ThreadPlanStack &GetPlans() const;\n\n  void PushPlan(lldb::ThreadPlanSP plan_sp);\n\n  void PopPlan();\n\n  void DiscardPlan();\n\n  ThreadPlan *GetPreviousPlan(ThreadPlan *plan) const;\n\n  virtual Unwind &GetUnwinder();\n\n  // Check to see whether the thread is still at the last breakpoint hit that\n  // stopped it.\n  virtual bool IsStillAtLastBreakpointHit();\n\n  // Some threads are threads that are made up by OperatingSystem plugins that\n  // are threads that exist and are context switched out into memory. The\n  // OperatingSystem plug-in need a ways to know if a thread is \"real\" or made\n  // up.\n  virtual bool IsOperatingSystemPluginThread() const { return false; }\n\n  // Subclasses that have a way to get an extended info dictionary for this\n  // thread should fill\n  virtual lldb_private::StructuredData::ObjectSP FetchThreadExtendedInfo() {\n    return StructuredData::ObjectSP();\n  }\n\n  lldb::StackFrameListSP GetStackFrameList();\n\n  void SetTemporaryResumeState(lldb::StateType new_state) {\n    m_temporary_resume_state = new_state;\n  }\n\n  void FrameSelectedCallback(lldb_private::StackFrame *frame);\n\n  // Classes that inherit from Process can see and modify these\n  lldb::ProcessWP m_process_wp;    ///< The process that owns this thread.\n  lldb::StopInfoSP m_stop_info_sp; ///< The private stop reason for this thread\n  uint32_t m_stop_info_stop_id; // This is the stop id for which the StopInfo is\n                                // valid.  Can use this so you know that\n  // the thread's m_stop_info_sp is current and you don't have to fetch it\n  // again\n  uint32_t m_stop_info_override_stop_id; // The stop ID containing the last time\n                                         // the stop info was checked against\n                                         // the stop info override\n  const uint32_t m_index_id; ///< A unique 1 based index assigned to each thread\n                             ///for easy UI/command line access.\n  lldb::RegisterContextSP m_reg_context_sp; ///< The register context for this\n                                            ///thread's current register state.\n  lldb::StateType m_state;                  ///< The state of our process.\n  mutable std::recursive_mutex\n      m_state_mutex;       ///< Multithreaded protection for m_state.\n  mutable std::recursive_mutex\n      m_frame_mutex; ///< Multithreaded protection for m_state.\n  lldb::StackFrameListSP m_curr_frames_sp; ///< The stack frames that get lazily\n                                           ///populated after a thread stops.\n  lldb::StackFrameListSP m_prev_frames_sp; ///< The previous stack frames from\n                                           ///the last time this thread stopped.\n  int m_resume_signal; ///< The signal that should be used when continuing this\n                       ///thread.\n  lldb::StateType m_resume_state; ///< This state is used to force a thread to\n                                  ///be suspended from outside the ThreadPlan\n                                  ///logic.\n  lldb::StateType m_temporary_resume_state; ///< This state records what the\n                                            ///thread was told to do by the\n                                            ///thread plan logic for the current\n                                            ///resume.\n  /// It gets set in Thread::ShouldResume.\n  std::unique_ptr<lldb_private::Unwind> m_unwinder_up;\n  bool m_destroy_called; // This is used internally to make sure derived Thread\n                         // classes call DestroyThread.\n  LazyBool m_override_should_notify;\n  mutable std::unique_ptr<ThreadPlanStack> m_null_plan_stack_up;\n\nprivate:\n  bool m_extended_info_fetched; // Have we tried to retrieve the m_extended_info\n                                // for this thread?\n  StructuredData::ObjectSP m_extended_info; // The extended info for this thread\n\n  void BroadcastSelectedFrameChange(StackID &new_frame_id);\n\n  Thread(const Thread &) = delete;\n  const Thread &operator=(const Thread &) = delete;\n};\n\n} // namespace lldb_private\n\n#endif // LLDB_TARGET_THREAD_H\n"}, "30": {"id": 30, "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Target/ThreadSpec.h", "content": "//===-- ThreadSpec.h --------------------------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLDB_TARGET_THREADSPEC_H\n#define LLDB_TARGET_THREADSPEC_H\n\n#include \"lldb/Utility/StructuredData.h\"\n#include \"lldb/lldb-private.h\"\n#include <string>\n\nnamespace lldb_private {\n\n// Note: For now the thread spec has only fixed elements -\n//   Thread ID\n//   Thread Index\n//   Thread Name\n//   Thread Queue Name\n//\n//  But if we need more generality, we can hang a key/value map off of this\n//  structure.\n//  That's why the thread matches spec test is done as a virtual method in\n//  Thread::MatchesSpec,\n//  since it is the native thread that would know how to interpret the keys.\n//  I was going to do the Queue Name this way out of sheer orneriness, but that\n//  seems a\n//  sufficiently general concept, so I put it in here on its own.\n\nclass ThreadSpec {\npublic:\n  ThreadSpec();\n\n  static std::unique_ptr<ThreadSpec>\n  CreateFromStructuredData(const StructuredData::Dictionary &data_dict,\n                           Status &error);\n\n  StructuredData::ObjectSP SerializeToStructuredData();\n\n  static const char *GetSerializationKey() { return \"ThreadSpec\"; }\n\n  void SetIndex(uint32_t index) { m_index = index; }\n\n  void SetTID(lldb::tid_t tid) { m_tid = tid; }\n\n  void SetName(llvm::StringRef name) { m_name = std::string(name); }\n\n  void SetQueueName(llvm::StringRef queue_name) {\n    m_queue_name = std::string(queue_name);\n  }\n\n  uint32_t GetIndex() const { return m_index; }\n\n  lldb::tid_t GetTID() const { return m_tid; }\n\n  const char *GetName() const;\n\n  const char *GetQueueName() const;\n\n  bool TIDMatches(lldb::tid_t thread_id) const {\n    if (m_tid == LLDB_INVALID_THREAD_ID || thread_id == LLDB_INVALID_THREAD_ID)\n      return true;\n    else\n      return thread_id == m_tid;\n  }\n\n  bool TIDMatches(Thread &thread) const;\n\n  bool IndexMatches(uint32_t index) const {\n    if (m_index == UINT32_MAX || index == UINT32_MAX)\n      return true;\n    else\n      return index == m_index;\n  }\n\n  bool IndexMatches(Thread &thread) const;\n\n  bool NameMatches(const char *name) const {\n    if (m_name.empty())\n      return true;\n    else if (name == nullptr)\n      return false;\n    else\n      return m_name == name;\n  }\n\n  bool NameMatches(Thread &thread) const;\n\n  bool QueueNameMatches(const char *queue_name) const {\n    if (m_queue_name.empty())\n      return true;\n    else if (queue_name == nullptr)\n      return false;\n    else\n      return m_queue_name == queue_name;\n  }\n\n  bool QueueNameMatches(Thread &thread) const;\n\n  bool ThreadPassesBasicTests(Thread &thread) const;\n\n  bool HasSpecification() const;\n\n  void GetDescription(Stream *s, lldb::DescriptionLevel level) const;\n\nprivate:\n  enum class OptionNames {\n    ThreadIndex = 0,\n    ThreadID,\n    ThreadName,\n    QueueName,\n    LastOptionName\n  };\n  static const char *g_option_names[(size_t)OptionNames::LastOptionName];\n\n  static const char *GetKey(OptionNames enum_value) {\n    return g_option_names[(size_t) enum_value];\n  }\n\n  uint32_t m_index;\n  lldb::tid_t m_tid;\n  std::string m_name;\n  std::string m_queue_name;\n};\n\n} // namespace lldb_private\n\n#endif // LLDB_TARGET_THREADSPEC_H\n"}, "31": {"id": 31, "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Target/Trace.h", "content": "//===-- Trace.h -------------------------------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLDB_TARGET_TRACE_H\n#define LLDB_TARGET_TRACE_H\n\n#include \"llvm/Support/JSON.h\"\n\n#include \"lldb/Core/PluginInterface.h\"\n#include \"lldb/Utility/ArchSpec.h\"\n#include \"lldb/Utility/UnimplementedError.h\"\n#include \"lldb/lldb-private.h\"\n\nnamespace lldb_private {\n\n/// \\class Trace Trace.h \"lldb/Target/Trace.h\"\n/// A plug-in interface definition class for trace information.\n///\n/// Trace plug-ins allow processor trace information to be loaded into LLDB so\n/// that the data can be dumped, used for reverse and forward stepping to allow\n/// introspection into the reason your process crashed or found its way to its\n/// current state.\n///\n/// Trace information can be loaded into a target without a process to allow\n/// introspection of the trace information during post mortem analysis, such as\n/// when loading core files.\n///\n/// Processor trace information can also be fetched through the process\n/// interfaces during a live debug session if your process supports gathering\n/// this information.\n///\n/// In order to support live tracing, the name of the plug-in should match the\n/// name of the tracing type returned by the gdb-remote packet\n/// \\a jLLDBTraceSupportedType.\nclass Trace : public PluginInterface,\n              public std::enable_shared_from_this<Trace> {\npublic:\n  enum class TraceDirection {\n    Forwards = 0,\n    Backwards,\n  };\n\n  /// Dump the trace data that this plug-in has access to.\n  ///\n  /// This function will dump all of the trace data for all threads in a user\n  /// readable format. Options for dumping can be added as this API is iterated\n  /// on.\n  ///\n  /// \\param[in] s\n  ///     A stream object to dump the information to.\n  virtual void Dump(Stream *s) const = 0;\n\n  /// Find a trace plug-in using JSON data.\n  ///\n  /// When loading trace data from disk, the information for the trace data\n  /// can be contained in multiple files and require plug-in specific\n  /// information about the CPU. Using data like JSON provides an\n  /// easy way to specify all of the settings and information that we will need\n  /// to load trace data into LLDB. This structured data can include:\n  ///   - The plug-in name (this allows a specific plug-in to be selected)\n  ///   - Architecture or target triple\n  ///   - one or more paths to the trace data file on disk\n  ///     - core trace data\n  ///     - thread events or related information\n  ///   - shared library load information to use for this trace data that\n  ///     allows a target to be created so the trace information can be\n  ///     symbolicated so that the trace information can be displayed to the\n  ///     user\n  ///     - shared library path\n  ///     - load address\n  ///     - information on how to fetch the shared library\n  ///       - path to locally cached file on disk\n  ///       - URL to download the file\n  ///   - Any information needed to load the trace file\n  ///     - CPU information\n  ///     - Custom plug-in information needed to decode the trace information\n  ///       correctly.\n  ///\n  /// \\param[in] debugger\n  ///     The debugger instance where new Targets will be created as part of the\n  ///     JSON data parsing.\n  ///\n  /// \\param[in] trace_session_file\n  ///     The contents of the trace session file describing the trace session.\n  ///     See \\a TraceSessionFileParser::BuildSchema for more information about\n  ///     the schema of this JSON file.\n  ///\n  /// \\param[in] session_file_dir\n  ///     The path to the directory that contains the session file. It's used to\n  ///     resolved relative paths in the session file.\n  static llvm::Expected<lldb::TraceSP>\n  FindPlugin(Debugger &debugger, const llvm::json::Value &trace_session_file,\n             llvm::StringRef session_file_dir);\n\n  /// Get the schema of a Trace plug-in given its name.\n  ///\n  /// \\param[in] plugin_name\n  ///     Name of the trace plugin.\n  static llvm::Expected<llvm::StringRef>\n  FindPluginSchema(llvm::StringRef plugin_name);\n\n  /// \\return\n  ///     The JSON schema of this Trace plug-in.\n  virtual llvm::StringRef GetSchema() = 0;\n\n  /// Each decoded thread contains a cursor to the current position the user is\n  /// stopped at. When reverse debugging, each operation like reverse-next or\n  /// reverse-continue will move this cursor, which is then picked by any\n  /// subsequent dump or reverse operation.\n  ///\n  /// The initial position for this cursor is the last element of the thread,\n  /// which is the most recent chronologically.\n  ///\n  /// \\return\n  ///     The current position of the thread's trace or \\b 0 if empty.\n  virtual size_t GetCursorPosition(const Thread &thread) = 0;\n\n  /// Dump \\a count instructions of the given thread's trace ending at the\n  /// given \\a end_position position.\n  ///\n  /// The instructions are printed along with their indices or positions, which\n  /// are increasing chronologically. This means that the \\a index 0 represents\n  /// the oldest instruction of the trace chronologically.\n  ///\n  /// \\param[in] thread\n  ///     The thread whose trace will be dumped.\n  ///\n  /// \\param[in] s\n  ///     The stream object where the instructions are printed.\n  ///\n  /// \\param[in] count\n  ///     The number of instructions to print.\n  ///\n  /// \\param[in] end_position\n  ///     The position of the last instruction to print.\n  ///\n  /// \\param[in] raw\n  ///     Dump only instruction addresses without disassembly nor symbol\n  ///     information.\n  void DumpTraceInstructions(Thread &thread, Stream &s, size_t count,\n                             size_t end_position, bool raw);\n\n  /// Run the provided callback on the instructions of the trace of the given\n  /// thread.\n  ///\n  /// The instructions will be traversed starting at the given \\a position\n  /// sequentially until the callback returns \\b false, in which case no more\n  /// instructions are inspected.\n  ///\n  /// The purpose of this method is to allow inspecting traced instructions\n  /// without exposing the internal representation of how they are stored on\n  /// memory.\n  ///\n  /// \\param[in] thread\n  ///     The thread whose trace will be traversed.\n  ///\n  /// \\param[in] position\n  ///     The instruction position to start iterating on.\n  ///\n  /// \\param[in] direction\n  ///     If \\b TraceDirection::Forwards, then then instructions will be\n  ///     traversed forwards chronologically, i.e. with incrementing indices. If\n  ///     \\b TraceDirection::Backwards, the traversal is done backwards\n  ///     chronologically, i.e. with decrementing indices.\n  ///\n  /// \\param[in] callback\n  ///     The callback to execute on each instruction. If it returns \\b false,\n  ///     the iteration stops.\n  virtual void TraverseInstructions(\n      const Thread &thread, size_t position, TraceDirection direction,\n      std::function<bool(size_t index, llvm::Expected<lldb::addr_t> load_addr)>\n          callback) = 0;\n\n  /// Stop tracing a live thread\n  ///\n  /// \\param[in] thread\n  ///     The thread object to stop tracing.\n  ///\n  /// \\return\n  ///     An \\a llvm::Error if stopping tracing failed, or \\b\n  ///     llvm::Error::success() otherwise.\n  virtual llvm::Error StopTracingThread(const Thread &thread) {\n    return llvm::make_error<UnimplementedError>();\n  }\n\n  /// Get the number of available instructions in the trace of the given thread.\n  ///\n  /// \\param[in] thread\n  ///     The thread whose trace will be inspected.\n  ///\n  /// \\return\n  ///     The total number of instructions in the trace.\n  virtual size_t GetInstructionCount(const Thread &thread) = 0;\n};\n\n} // namespace lldb_private\n\n#endif // LLDB_TARGET_TRACE_H\n"}, "32": {"id": 32, "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Utility/Args.h", "content": "//===-- Args.h --------------------------------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLDB_UTILITY_ARGS_H\n#define LLDB_UTILITY_ARGS_H\n\n#include \"lldb/Utility/Environment.h\"\n#include \"lldb/lldb-private-types.h\"\n#include \"lldb/lldb-types.h\"\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/Support/YAMLTraits.h\"\n#include <string>\n#include <utility>\n#include <vector>\n\nnamespace lldb_private {\n\n/// \\class Args Args.h \"lldb/Utility/Args.h\"\n/// A command line argument class.\n///\n/// The Args class is designed to be fed a command line. The command line is\n/// copied into an internal buffer and then split up into arguments. Arguments\n/// are space delimited if there are no quotes (single, double, or backtick\n/// quotes) surrounding the argument. Spaces can be escaped using a \\\n/// character to avoid having to surround an argument that contains a space\n/// with quotes.\nclass Args {\npublic:\n  struct ArgEntry {\n  private:\n    friend class Args;\n    friend struct llvm::yaml::MappingTraits<Args>;\n    friend struct llvm::yaml::MappingTraits<Args::ArgEntry>;\n\n    std::unique_ptr<char[]> ptr;\n    char quote;\n\n    char *data() { return ptr.get(); }\n\n  public:\n    ArgEntry() = default;\n    ArgEntry(llvm::StringRef str, char quote);\n\n    llvm::StringRef ref() const { return c_str(); }\n    const char *c_str() const { return ptr.get(); }\n\n    /// Returns true if this argument was quoted in any way.\n    bool IsQuoted() const { return quote != '\\0'; }\n    char GetQuoteChar() const { return quote; }\n  };\n\n  /// Construct with an option command string.\n  ///\n  /// \\param[in] command\n  ///     A NULL terminated command that will be copied and split up\n  ///     into arguments.\n  ///\n  /// \\see Args::SetCommandString(llvm::StringRef)\n  Args(llvm::StringRef command = llvm::StringRef());\n\n  Args(const Args &rhs);\n  explicit Args(const StringList &list);\n  explicit Args(llvm::ArrayRef<llvm::StringRef> args);\n\n  Args &operator=(const Args &rhs);\n\n  /// Destructor.\n  ~Args();\n\n  explicit Args(const Environment &env) : Args() {\n    SetArguments(const_cast<const char **>(env.getEnvp().get()));\n  }\n\n  explicit operator Environment() const { return GetConstArgumentVector(); }\n\n  /// Dump all entries to the stream \\a s using label \\a label_name.\n  ///\n  /// If label_name is nullptr, the dump operation is skipped.\n  ///\n  /// \\param[in] s\n  ///     The stream to which to dump all arguments in the argument\n  ///     vector.\n  /// \\param[in] label_name\n  ///     The label_name to use as the label printed for each\n  ///     entry of the args like so:\n  ///       {label_name}[{index}]={value}\n  void Dump(Stream &s, const char *label_name = \"argv\") const;\n\n  /// Sets the command string contained by this object.\n  ///\n  /// The command string will be copied and split up into arguments that can\n  /// be accessed via the accessor functions.\n  ///\n  /// \\param[in] command\n  ///     A command StringRef that will be copied and split up\n  ///     into arguments.\n  ///\n  /// \\see Args::GetArgumentCount() const\n  /// \\see Args::GetArgumentAtIndex (size_t) const @see\n  /// Args::GetArgumentVector () \\see Args::Shift () \\see Args::Unshift (const\n  /// char *)\n  void SetCommandString(llvm::StringRef command);\n\n  bool GetCommandString(std::string &command) const;\n\n  bool GetQuotedCommandString(std::string &command) const;\n\n  /// Gets the number of arguments left in this command object.\n  ///\n  /// \\return\n  ///     The number or arguments in this object.\n  size_t GetArgumentCount() const { return m_entries.size(); }\n\n  bool empty() const { return GetArgumentCount() == 0; }\n\n  /// Gets the NULL terminated C string argument pointer for the argument at\n  /// index \\a idx.\n  ///\n  /// \\return\n  ///     The NULL terminated C string argument pointer if \\a idx is a\n  ///     valid argument index, NULL otherwise.\n  const char *GetArgumentAtIndex(size_t idx) const;\n\n  llvm::ArrayRef<ArgEntry> entries() const { return m_entries; }\n\n  using const_iterator = std::vector<ArgEntry>::const_iterator;\n\n  const_iterator begin() const { return m_entries.begin(); }\n  const_iterator end() const { return m_entries.end(); }\n\n  size_t size() const { return GetArgumentCount(); }\n  const ArgEntry &operator[](size_t n) const { return m_entries[n]; }\n\n  /// Gets the argument vector.\n  ///\n  /// The value returned by this function can be used by any function that\n  /// takes and vector. The return value is just like \\a argv in the standard\n  /// C entry point function:\n  ///     \\code\n  ///         int main (int argc, const char **argv);\n  ///     \\endcode\n  ///\n  /// \\return\n  ///     An array of NULL terminated C string argument pointers that\n  ///     also has a terminating NULL C string pointer\n  char **GetArgumentVector();\n\n  /// Gets the argument vector.\n  ///\n  /// The value returned by this function can be used by any function that\n  /// takes and vector. The return value is just like \\a argv in the standard\n  /// C entry point function:\n  ///     \\code\n  ///         int main (int argc, const char **argv);\n  ///     \\endcode\n  ///\n  /// \\return\n  ///     An array of NULL terminate C string argument pointers that\n  ///     also has a terminating NULL C string pointer\n  const char **GetConstArgumentVector() const;\n\n  /// Gets the argument as an ArrayRef. Note that the return value does *not*\n  /// have a nullptr const char * at the end, as the size of the list is\n  /// embedded in the ArrayRef object.\n  llvm::ArrayRef<const char *> GetArgumentArrayRef() const {\n    return llvm::makeArrayRef(m_argv).drop_back();\n  }\n\n  /// Appends a new argument to the end of the list argument list.\n  ///\n  /// \\param[in] arg_str\n  ///     The new argument.\n  ///\n  /// \\param[in] quote_char\n  ///     If the argument was originally quoted, put in the quote char here.\n  void AppendArgument(llvm::StringRef arg_str, char quote_char = '\\0');\n\n  void AppendArguments(const Args &rhs);\n\n  void AppendArguments(const char **argv);\n\n  /// Insert the argument value at index \\a idx to \\a arg_str.\n  ///\n  /// \\param[in] idx\n  ///     The index of where to insert the argument.\n  ///\n  /// \\param[in] arg_str\n  ///     The new argument.\n  ///\n  /// \\param[in] quote_char\n  ///     If the argument was originally quoted, put in the quote char here.\n  void InsertArgumentAtIndex(size_t idx, llvm::StringRef arg_str,\n                             char quote_char = '\\0');\n\n  /// Replaces the argument value at index \\a idx to \\a arg_str if \\a idx is\n  /// a valid argument index.\n  ///\n  /// \\param[in] idx\n  ///     The index of the argument that will have its value replaced.\n  ///\n  /// \\param[in] arg_str\n  ///     The new argument.\n  ///\n  /// \\param[in] quote_char\n  ///     If the argument was originally quoted, put in the quote char here.\n  void ReplaceArgumentAtIndex(size_t idx, llvm::StringRef arg_str,\n                              char quote_char = '\\0');\n\n  /// Deletes the argument value at index\n  /// if \\a idx is a valid argument index.\n  ///\n  /// \\param[in] idx\n  ///     The index of the argument that will have its value replaced.\n  ///\n  void DeleteArgumentAtIndex(size_t idx);\n\n  /// Sets the argument vector value, optionally copying all arguments into an\n  /// internal buffer.\n  ///\n  /// Sets the arguments to match those found in \\a argv. All argument strings\n  /// will be copied into an internal buffers.\n  //\n  //  FIXME: Handle the quote character somehow.\n  void SetArguments(size_t argc, const char **argv);\n\n  void SetArguments(const char **argv);\n\n  /// Shifts the first argument C string value of the array off the argument\n  /// array.\n  ///\n  /// The string value will be freed, so a copy of the string should be made\n  /// by calling Args::GetArgumentAtIndex (size_t) const first and copying the\n  /// returned value before calling Args::Shift().\n  ///\n  /// \\see Args::GetArgumentAtIndex (size_t) const\n  void Shift();\n\n  /// Inserts a class owned copy of \\a arg_str at the beginning of the\n  /// argument vector.\n  ///\n  /// A copy \\a arg_str will be made.\n  ///\n  /// \\param[in] arg_str\n  ///     The argument to push on the front of the argument stack.\n  ///\n  /// \\param[in] quote_char\n  ///     If the argument was originally quoted, put in the quote char here.\n  void Unshift(llvm::StringRef arg_str, char quote_char = '\\0');\n\n  /// Clear the arguments.\n  ///\n  /// For re-setting or blanking out the list of arguments.\n  void Clear();\n\n  static lldb::Encoding\n  StringToEncoding(llvm::StringRef s,\n                   lldb::Encoding fail_value = lldb::eEncodingInvalid);\n\n  static uint32_t StringToGenericRegister(llvm::StringRef s);\n\n  static std::string GetShellSafeArgument(const FileSpec &shell,\n                                          llvm::StringRef unsafe_arg);\n\n  /// EncodeEscapeSequences will change the textual representation of common\n  /// escape sequences like \"\\n\" (two characters) into a single '\\n'. It does\n  /// this for all of the supported escaped sequences and for the \\0ooo (octal)\n  /// and \\xXX (hex). The resulting \"dst\" string will contain the character\n  /// versions of all supported escape sequences. The common supported escape\n  /// sequences are: \"\\a\", \"\\b\", \"\\f\", \"\\n\", \"\\r\", \"\\t\", \"\\v\", \"\\'\", \"\\\"\", \"\\\\\".\n  static void EncodeEscapeSequences(const char *src, std::string &dst);\n\n  /// ExpandEscapeSequences will change a string of possibly non-printable\n  /// characters and expand them into text. So '\\n' will turn into two\n  /// characters like \"\\n\" which is suitable for human reading. When a character\n  /// is not printable and isn't one of the common in escape sequences listed in\n  /// the help for EncodeEscapeSequences, then it will be encoded as octal.\n  /// Printable characters are left alone.\n  static void ExpandEscapedCharacters(const char *src, std::string &dst);\n\n  static std::string EscapeLLDBCommandArgument(const std::string &arg,\n                                               char quote_char);\n\nprivate:\n  friend struct llvm::yaml::MappingTraits<Args>;\n\n  std::vector<ArgEntry> m_entries;\n  /// The arguments as C strings with a trailing nullptr element.\n  ///\n  /// These strings are owned by the ArgEntry object in m_entries with the\n  /// same index.\n  std::vector<char *> m_argv;\n};\n\n/// \\class OptionsWithRaw Args.h \"lldb/Utility/Args.h\"\n/// A pair of an option list with a 'raw' string as a suffix.\n///\n/// This class works similar to Args, but handles the case where we have a\n/// trailing string that shouldn't be interpreted as a list of arguments but\n/// preserved as is. It is also only useful for handling command line options\n/// (e.g. '-foo bar -i0') that start with a dash.\n///\n/// The leading option list is optional. If the first non-space character\n/// in the string starts with a dash, and the string contains an argument\n/// that is an unquoted double dash (' -- '), then everything up to the double\n/// dash is parsed as a list of arguments. Everything after the double dash\n/// is interpreted as the raw suffix string. Note that the space behind the\n/// double dash is not part of the raw suffix.\n///\n/// All strings not matching the above format as considered to be just a raw\n/// string without any options.\n///\n/// \\see Args\nclass OptionsWithRaw {\npublic:\n  /// Parse the given string as a list of optional arguments with a raw suffix.\n  ///\n  /// See the class description for a description of the input format.\n  ///\n  /// \\param[in] argument_string\n  ///     The string that should be parsed.\n  explicit OptionsWithRaw(llvm::StringRef argument_string);\n\n  /// Returns true if there are any arguments before the raw suffix.\n  bool HasArgs() const { return m_has_args; }\n\n  /// Returns the list of arguments.\n  ///\n  /// You can only call this method if HasArgs returns true.\n  Args &GetArgs() {\n    assert(m_has_args);\n    return m_args;\n  }\n\n  /// Returns the list of arguments.\n  ///\n  /// You can only call this method if HasArgs returns true.\n  const Args &GetArgs() const {\n    assert(m_has_args);\n    return m_args;\n  }\n\n  /// Returns the part of the input string that was used for parsing the\n  /// argument list. This string also includes the double dash that is used\n  /// for separating the argument list from the suffix.\n  ///\n  /// You can only call this method if HasArgs returns true.\n  llvm::StringRef GetArgStringWithDelimiter() const {\n    assert(m_has_args);\n    return m_arg_string_with_delimiter;\n  }\n\n  /// Returns the part of the input string that was used for parsing the\n  /// argument list.\n  ///\n  /// You can only call this method if HasArgs returns true.\n  llvm::StringRef GetArgString() const {\n    assert(m_has_args);\n    return m_arg_string;\n  }\n\n  /// Returns the raw suffix part of the parsed string.\n  const std::string &GetRawPart() const { return m_suffix; }\n\nprivate:\n  void SetFromString(llvm::StringRef arg_string);\n\n  /// Keeps track if we have parsed and stored any arguments.\n  bool m_has_args = false;\n  Args m_args;\n  llvm::StringRef m_arg_string;\n  llvm::StringRef m_arg_string_with_delimiter;\n\n  // FIXME: This should be a StringRef, but some of the calling code expect a\n  // C string here so only a real std::string is possible.\n  std::string m_suffix;\n};\n\n} // namespace lldb_private\n\nnamespace llvm {\nnamespace yaml {\ntemplate <> struct MappingTraits<lldb_private::Args::ArgEntry> {\n  class NormalizedArgEntry {\n  public:\n    NormalizedArgEntry(IO &) {}\n    NormalizedArgEntry(IO &, lldb_private::Args::ArgEntry &entry)\n        : value(entry.ref()), quote(entry.quote) {}\n    lldb_private::Args::ArgEntry denormalize(IO &) {\n      return lldb_private::Args::ArgEntry(value, quote);\n    }\n    StringRef value;\n    uint8_t quote;\n  };\n  static void mapping(IO &io, lldb_private::Args::ArgEntry &v);\n};\ntemplate <> struct MappingTraits<lldb_private::Args> {\n  static void mapping(IO &io, lldb_private::Args &v);\n};\n} // namespace yaml\n} // namespace llvm\n\nLLVM_YAML_IS_SEQUENCE_VECTOR(lldb_private::Args::ArgEntry)\n\n#endif // LLDB_UTILITY_ARGS_H\n"}, "33": {"id": 33, "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Utility/Baton.h", "content": "//===-- Baton.h -------------------------------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLDB_UTILITY_BATON_H\n#define LLDB_UTILITY_BATON_H\n\n#include \"lldb/lldb-enumerations.h\"\n#include \"lldb/lldb-public.h\"\n\n#include \"llvm/Support/raw_ostream.h\"\n\n#include <memory>\n\nnamespace lldb_private {\nclass Stream;\n}\n\nnamespace lldb_private {\n\n/// \\class Baton Baton.h \"lldb/Core/Baton.h\"\n/// A class designed to wrap callback batons so they can cleanup\n///        any acquired resources\n///\n/// This class is designed to be used by any objects that have a callback\n/// function that takes a baton where the baton might need to\n/// free/delete/close itself.\n///\n/// The default behavior is to not free anything. Subclasses can free any\n/// needed resources in their destructors.\nclass Baton {\npublic:\n  Baton() {}\n  virtual ~Baton() {}\n\n  virtual void *data() = 0;\n\n  virtual void GetDescription(llvm::raw_ostream &s,\n                              lldb::DescriptionLevel level,\n                              unsigned indentation) const = 0;\n};\n\nclass UntypedBaton : public Baton {\npublic:\n  UntypedBaton(void *Data) : m_data(Data) {}\n  ~UntypedBaton() override {\n    // The default destructor for an untyped baton does NOT attempt to clean up\n    // anything in m_data.\n  }\n\n  void *data() override { return m_data; }\n  void GetDescription(llvm::raw_ostream &s, lldb::DescriptionLevel level,\n                      unsigned indentation) const override;\n\n  void *m_data; // Leave baton public for easy access\n};\n\ntemplate <typename T> class TypedBaton : public Baton {\npublic:\n  explicit TypedBaton(std::unique_ptr<T> Item) : Item(std::move(Item)) {}\n\n  T *getItem() { return Item.get(); }\n  const T *getItem() const { return Item.get(); }\n\n  void *data() override { return Item.get(); }\n  void GetDescription(llvm::raw_ostream &s, lldb::DescriptionLevel level,\n                      unsigned indentation) const override {}\n\nprotected:\n  std::unique_ptr<T> Item;\n};\n\n} // namespace lldb_private\n\n#endif // LLDB_UTILITY_BATON_H\n"}, "34": {"id": 34, "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Utility/CompletionRequest.h", "content": "//===-- CompletionRequest.h -------------------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLDB_UTILITY_COMPLETIONREQUEST_H\n#define LLDB_UTILITY_COMPLETIONREQUEST_H\n\n#include \"lldb/Utility/Args.h\"\n#include \"lldb/Utility/LLDBAssert.h\"\n#include \"lldb/Utility/StringList.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/ADT/StringSet.h\"\n\nnamespace lldb_private {\nenum class CompletionMode {\n  /// The current token has been completed. The client should indicate this\n  /// to the user (usually this is done by adding a trailing space behind the\n  /// token).\n  /// Example: \"command sub\" -> \"command subcommand \" (note the trailing space).\n  Normal,\n  /// The current token has been partially completed. This means that we found\n  /// a completion, but that the token is still incomplete. Examples\n  /// for this are file paths, where we want to complete \"/bi\" to \"/bin/\", but\n  /// the file path token is still incomplete after the completion. Clients\n  /// should not indicate to the user that this is a full completion (e.g. by\n  /// not inserting the usual trailing space after a successful completion).\n  /// Example: \"file /us\" -> \"file /usr/\" (note the missing trailing space).\n  Partial,\n  /// The full line has been rewritten by the completion.\n  /// Example: \"alias name\" -> \"other_command full_name\".\n  RewriteLine,\n};\n\nclass CompletionResult {\npublic:\n  /// A single completion and all associated data.\n  class Completion {\n\n    /// The actual text that should be completed. The meaning of this text\n    /// is defined by the CompletionMode.\n    /// \\see m_mode\n    std::string m_completion;\n    /// The description that should be displayed to the user alongside the\n    /// completion text.\n    std::string m_descripton;\n    CompletionMode m_mode;\n\n  public:\n    Completion(llvm::StringRef completion, llvm::StringRef description,\n               CompletionMode mode)\n        : m_completion(completion.str()), m_descripton(description.str()),\n          m_mode(mode) {}\n    const std::string &GetCompletion() const { return m_completion; }\n    const std::string &GetDescription() const { return m_descripton; }\n    CompletionMode GetMode() const { return m_mode; }\n\n    /// Generates a string that uniquely identifies this completion result.\n    std::string GetUniqueKey() const;\n  };\n\nprivate:\n  /// List of found completions.\n  std::vector<Completion> m_results;\n\n  /// A set of the unique keys of all found completions so far. Used to filter\n  /// out duplicates.\n  /// \\see CompletionResult::Completion::GetUniqueKey\n  llvm::StringSet<> m_added_values;\n\npublic:\n  void AddResult(llvm::StringRef completion, llvm::StringRef description,\n                 CompletionMode mode);\n\n  llvm::ArrayRef<Completion> GetResults() const { return m_results; }\n\n  /// Adds all collected completion matches to the given list.\n  /// The list will be cleared before the results are added. The number of\n  /// results here is guaranteed to be equal to GetNumberOfResults().\n  void GetMatches(StringList &matches) const;\n\n  /// Adds all collected completion descriptions to the given list.\n  /// The list will be cleared before the results are added. The number of\n  /// results here is guaranteed to be equal to GetNumberOfResults().\n  void GetDescriptions(StringList &descriptions) const;\n\n  std::size_t GetNumberOfResults() const { return m_results.size(); }\n};\n\n/// \\class CompletionRequest CompletionRequest.h\n///   \"lldb/Utility/ArgCompletionRequest.h\"\n///\n/// Contains all information necessary to complete an incomplete command\n/// for the user. Will be filled with the generated completions by the different\n/// completions functions.\n///\nclass CompletionRequest {\npublic:\n  /// Constructs a completion request.\n  ///\n  /// \\param [in] command_line\n  ///     The command line the user has typed at this point.\n  ///\n  /// \\param [in] raw_cursor_pos\n  ///     The position of the cursor in the command line string. Index 0 means\n  ///     the cursor is at the start of the line. The completion starts from\n  ///     this cursor position.\n  ///\n  /// \\param [out] result\n  ///     The CompletionResult that will be filled with the results after this\n  ///     request has been handled.\n  CompletionRequest(llvm::StringRef command_line, unsigned raw_cursor_pos,\n                    CompletionResult &result);\n\n  /// Returns the raw user input used to create this CompletionRequest cut off\n  /// at the cursor position. The cursor will be at the end of the raw line.\n  llvm::StringRef GetRawLine() const {\n    return m_command.substr(0, GetRawCursorPos());\n  }\n\n  /// Returns the full raw user input used to create this CompletionRequest.\n  /// This string is not cut off at the cursor position and will include\n  /// characters behind the cursor position.\n  ///\n  /// You should most likely *not* use this function unless the characters\n  /// behind the cursor position influence the completion.\n  llvm::StringRef GetRawLineWithUnusedSuffix() const { return m_command; }\n\n  unsigned GetRawCursorPos() const { return m_raw_cursor_pos; }\n\n  const Args &GetParsedLine() const { return m_parsed_line; }\n\n  Args &GetParsedLine() { return m_parsed_line; }\n\n  const Args::ArgEntry &GetParsedArg() {\n    return GetParsedLine()[GetCursorIndex()];\n  }\n\n  /// Drops the first argument from the argument list.\n  void ShiftArguments() {\n    m_cursor_index--;\n    m_parsed_line.Shift();\n  }\n\n  /// Adds an empty argument at the end of the argument list and moves\n  /// the cursor to this new argument.\n  void AppendEmptyArgument() {\n    m_parsed_line.AppendArgument(llvm::StringRef());\n    m_cursor_index++;\n    m_cursor_char_position = 0;\n  }\n\n  size_t GetCursorIndex() const { return m_cursor_index; }\n\n  /// Adds a possible completion string. If the completion was already\n  /// suggested before, it will not be added to the list of results. A copy of\n  /// the suggested completion is stored, so the given string can be free'd\n  /// afterwards.\n  ///\n  /// \\param completion The suggested completion.\n  /// \\param description An optional description of the completion string. The\n  ///     description will be displayed to the user alongside the completion.\n  /// \\param mode The CompletionMode for this completion.\n  void AddCompletion(llvm::StringRef completion,\n                     llvm::StringRef description = \"\",\n                     CompletionMode mode = CompletionMode::Normal) {\n    m_result.AddResult(completion, description, mode);\n  }\n\n  /// Adds a possible completion string if the completion would complete the\n  /// current argument.\n  ///\n  /// \\param completion The suggested completion.\n  /// \\param description An optional description of the completion string. The\n  ///     description will be displayed to the user alongside the completion.\n  template <CompletionMode M = CompletionMode::Normal>\n  void TryCompleteCurrentArg(llvm::StringRef completion,\n                             llvm::StringRef description = \"\") {\n    // Trying to rewrite the whole line while checking for the current\n    // argument never makes sense. Completion modes are always hardcoded, so\n    // this can be a static_assert.\n    static_assert(M != CompletionMode::RewriteLine,\n                  \"Shouldn't rewrite line with this function\");\n    if (completion.startswith(GetCursorArgumentPrefix()))\n      AddCompletion(completion, description, M);\n  }\n\n  /// Adds multiple possible completion strings.\n  ///\n  /// \\param completions The list of completions.\n  ///\n  /// \\see AddCompletion\n  void AddCompletions(const StringList &completions) {\n    for (const std::string &completion : completions)\n      AddCompletion(completion);\n  }\n\n  /// Adds multiple possible completion strings alongside their descriptions.\n  ///\n  /// The number of completions and descriptions must be identical.\n  ///\n  /// \\param completions The list of completions.\n  /// \\param descriptions The list of descriptions.\n  ///\n  /// \\see AddCompletion\n  void AddCompletions(const StringList &completions,\n                      const StringList &descriptions) {\n    lldbassert(completions.GetSize() == descriptions.GetSize());\n    for (std::size_t i = 0; i < completions.GetSize(); ++i)\n      AddCompletion(completions.GetStringAtIndex(i),\n                    descriptions.GetStringAtIndex(i));\n  }\n\n  llvm::StringRef GetCursorArgumentPrefix() const {\n    return GetParsedLine().GetArgumentAtIndex(GetCursorIndex());\n  }\n\nprivate:\n  /// The raw command line we are supposed to complete.\n  llvm::StringRef m_command;\n  /// The cursor position in m_command.\n  unsigned m_raw_cursor_pos;\n  /// The command line parsed as arguments.\n  Args m_parsed_line;\n  /// The index of the argument in which the completion cursor is.\n  size_t m_cursor_index;\n  /// The cursor position in the argument indexed by m_cursor_index.\n  size_t m_cursor_char_position;\n\n  /// The result this request is supposed to fill out.\n  /// We keep this object private to ensure that no backend can in any way\n  /// depend on already calculated completions (which would make debugging and\n  /// testing them much more complicated).\n  CompletionResult &m_result;\n};\n\n} // namespace lldb_private\n\n#endif // LLDB_UTILITY_COMPLETIONREQUEST_H\n"}, "35": {"id": 35, "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Utility/DataBuffer.h", "content": "//===-- DataBuffer.h --------------------------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLDB_UTILITY_DATABUFFER_H\n#define LLDB_UTILITY_DATABUFFER_H\n#if defined(__cplusplus)\n\n#include <stdint.h>\n#include <string.h>\n\n#include \"lldb/lldb-types.h\"\n\n#include \"llvm/ADT/ArrayRef.h\"\n\nnamespace lldb_private {\n\n/// \\class DataBuffer DataBuffer.h \"lldb/Core/DataBuffer.h\"\n/// A pure virtual protocol class for abstracted data buffers.\n///\n/// DataBuffer is an abstract class that gets packaged into a shared pointer\n/// that can use to implement various ways to store data (on the heap, memory\n/// mapped, cached inferior memory). It gets used by DataExtractor so many\n/// DataExtractor objects can share the same data and sub-ranges of that\n/// shared data, and the last object that contains a reference to the shared\n/// data will free it.\n///\n/// Subclasses can implement as many different constructors or member\n/// functions that allow data to be stored in the object's buffer prior to\n/// handing the shared data to clients that use these buffers.\n///\n/// All subclasses must override all of the pure virtual functions as they are\n/// used by clients to access the data. Having a common interface allows\n/// different ways of storing data, yet using it in one common way.\n///\n/// This class currently expects all data to be available without any extra\n/// calls being made, but we can modify it to optionally get data on demand\n/// with some extra function calls to load the data before it gets accessed.\nclass DataBuffer {\npublic:\n  /// Destructor\n  ///\n  /// The destructor is virtual as other classes will inherit from this class\n  /// and be downcast to the DataBuffer pure virtual interface. The virtual\n  /// destructor ensures that destructing the base class will destruct the\n  /// class that inherited from it correctly.\n  virtual ~DataBuffer() {}\n\n  /// Get a pointer to the data.\n  ///\n  /// \\return\n  ///     A pointer to the bytes owned by this object, or NULL if the\n  ///     object contains no bytes.\n  virtual uint8_t *GetBytes() = 0;\n\n  /// Get a const pointer to the data.\n  ///\n  /// \\return\n  ///     A const pointer to the bytes owned by this object, or NULL\n  ///     if the object contains no bytes.\n  virtual const uint8_t *GetBytes() const = 0;\n\n  /// Get the number of bytes in the data buffer.\n  ///\n  /// \\return\n  ///     The number of bytes this object currently contains.\n  virtual lldb::offset_t GetByteSize() const = 0;\n\n  llvm::ArrayRef<uint8_t> GetData() const {\n    return llvm::ArrayRef<uint8_t>(GetBytes(), GetByteSize());\n  }\n\n  llvm::MutableArrayRef<uint8_t> GetData() {\n    return llvm::MutableArrayRef<uint8_t>(GetBytes(), GetByteSize());\n  }\n};\n\nclass DataBufferUnowned : public DataBuffer {\npublic:\n  DataBufferUnowned(uint8_t *bytes, lldb::offset_t size)\n      : m_bytes(bytes), m_size(size) {}\n\n  uint8_t *GetBytes() override { return m_bytes; }\n  const uint8_t *GetBytes() const override { return m_bytes; }\n  lldb::offset_t GetByteSize() const override { return m_size; }\n\nprivate:\n  uint8_t *m_bytes;\n  lldb::offset_t m_size;\n};\n\n} // namespace lldb_private\n\n#endif /// #if defined(__cplusplus)\n#endif // LLDB_UTILITY_DATABUFFER_H\n"}, "36": {"id": 36, "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Utility/Environment.h", "content": "//===-- Environment.h -------------------------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLDB_UTILITY_ENVIRONMENT_H\n#define LLDB_UTILITY_ENVIRONMENT_H\n\n#include \"llvm/ADT/StringMap.h\"\n#include \"llvm/Support/Allocator.h\"\n#include \"llvm/Support/FormatProviders.h\"\n\nnamespace lldb_private {\n\nclass Environment : private llvm::StringMap<std::string> {\n  using Base = llvm::StringMap<std::string>;\n\npublic:\n  class Envp {\n  public:\n    Envp(Envp &&RHS) = default;\n    Envp &operator=(Envp &&RHS) = default;\n\n    char *const *get() const { return Data; }\n    operator char *const *() const { return get(); }\n\n  private:\n    explicit Envp(const Environment &Env);\n    char *make_entry(llvm::StringRef Key, llvm::StringRef Value);\n    Envp(const Envp &) = delete;\n    Envp &operator=(const Envp &) = delete;\n    friend class Environment;\n\n    llvm::BumpPtrAllocator Allocator;\n    char **Data;\n  };\n\n  using Base::const_iterator;\n  using Base::iterator;\n  using Base::value_type;\n\n  using Base::begin;\n  using Base::clear;\n  using Base::count;\n  using Base::empty;\n  using Base::end;\n  using Base::erase;\n  using Base::find;\n  using Base::insert;\n  using Base::insert_or_assign;\n  using Base::lookup;\n  using Base::size;\n  using Base::try_emplace;\n  using Base::operator[];\n\n  Environment() : Base() {}\n  Environment(const Environment &RHS) : Base(RHS) {}\n  Environment(Environment &&RHS) : Base(std::move(RHS)) {}\n  Environment(char *const *Env)\n      : Environment(const_cast<const char *const *>(Env)) {}\n  Environment(const char *const *Env);\n\n  Environment &operator=(Environment RHS) {\n    Base::operator=(std::move(RHS));\n    return *this;\n  }\n\n  std::pair<iterator, bool> insert(llvm::StringRef KeyEqValue) {\n    auto Split = KeyEqValue.split('=');\n    return insert(std::make_pair(Split.first, std::string(Split.second)));\n  }\n\n  void insert(const_iterator first, const_iterator last);\n\n  Envp getEnvp() const { return Envp(*this); }\n\n  static std::string compose(const value_type &KeyValue) {\n    return (KeyValue.first() + \"=\" + KeyValue.second).str();\n  }\n};\n\n} // namespace lldb_private\n\nnamespace llvm {\ntemplate <> struct format_provider<lldb_private::Environment> {\n  static void format(const lldb_private::Environment &Env, raw_ostream &Stream,\n                     StringRef Style) {\n    for (const auto &KV : Env)\n      Stream << \"env[\" << KV.first() << \"] = \" << KV.second << \"\\n\";\n  }\n};\n} // namespace llvm\n\n#endif // LLDB_UTILITY_ENVIRONMENT_H\n"}, "38": {"id": 38, "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Utility/Iterable.h", "content": "//===-- Iterable.h ----------------------------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLDB_UTILITY_ITERABLE_H\n#define LLDB_UTILITY_ITERABLE_H\n\n#include <utility>\n\n\nnamespace lldb_private {\n\ntemplate <typename I, typename E> E map_adapter(I &iter) {\n  return iter->second;\n}\n\ntemplate <typename I, typename E> E vector_adapter(I &iter) { return *iter; }\n\ntemplate <typename I, typename E> E list_adapter(I &iter) { return *iter; }\n\ntemplate <typename C, typename E, E (*A)(typename C::const_iterator &)>\nclass AdaptedConstIterator {\npublic:\n  typedef typename C::const_iterator BackingIterator;\n\n  // Wrapping constructor\n  AdaptedConstIterator(BackingIterator backing_iterator)\n      : m_iter(backing_iterator) {}\n\n  // Default-constructible\n  AdaptedConstIterator() : m_iter() {}\n\n  // Copy-constructible\n  AdaptedConstIterator(const AdaptedConstIterator &rhs) : m_iter(rhs.m_iter) {}\n\n  // Copy-assignable\n  AdaptedConstIterator &operator=(const AdaptedConstIterator &rhs) {\n    m_iter = rhs.m_iter;\n    return *this;\n  }\n\n  // Destructible\n  ~AdaptedConstIterator() = default;\n\n  // Comparable\n  bool operator==(const AdaptedConstIterator &rhs) {\n    return m_iter == rhs.m_iter;\n  }\n\n  bool operator!=(const AdaptedConstIterator &rhs) {\n    return m_iter != rhs.m_iter;\n  }\n\n  // Rvalue dereferenceable\n  E operator*() { return (*A)(m_iter); }\n\n  E operator->() { return (*A)(m_iter); }\n\n  // Offset dereferenceable\n  E operator[](typename BackingIterator::difference_type offset) {\n    return AdaptedConstIterator(m_iter + offset);\n  }\n\n  // Incrementable\n  AdaptedConstIterator &operator++() {\n    m_iter++;\n    return *this;\n  }\n\n  // Decrementable\n  AdaptedConstIterator &operator--() {\n    m_iter--;\n    return *this;\n  }\n\n  // Compound assignment\n  AdaptedConstIterator &\n  operator+=(typename BackingIterator::difference_type offset) {\n    m_iter += offset;\n    return *this;\n  }\n\n  AdaptedConstIterator &\n  operator-=(typename BackingIterator::difference_type offset) {\n    m_iter -= offset;\n    return *this;\n  }\n\n  // Arithmetic\n  AdaptedConstIterator\n  operator+(typename BackingIterator::difference_type offset) {\n    return AdaptedConstIterator(m_iter + offset);\n  }\n\n  AdaptedConstIterator\n  operator-(typename BackingIterator::difference_type offset) {\n    return AdaptedConstIterator(m_iter - offset);\n  }\n\n  // Comparable\n  bool operator<(AdaptedConstIterator &rhs) { return m_iter < rhs.m_iter; }\n\n  bool operator<=(AdaptedConstIterator &rhs) { return m_iter <= rhs.m_iter; }\n\n  bool operator>(AdaptedConstIterator &rhs) { return m_iter > rhs.m_iter; }\n\n  bool operator>=(AdaptedConstIterator &rhs) { return m_iter >= rhs.m_iter; }\n\n  template <typename C1, typename E1, E1 (*A1)(typename C1::const_iterator &)>\n  friend AdaptedConstIterator<C1, E1, A1>\n  operator+(typename C1::const_iterator::difference_type,\n            AdaptedConstIterator<C1, E1, A1> &);\n\n  template <typename C1, typename E1, E1 (*A1)(typename C1::const_iterator &)>\n  friend typename C1::const_iterator::difference_type\n  operator-(AdaptedConstIterator<C1, E1, A1> &,\n            AdaptedConstIterator<C1, E1, A1> &);\n\n  template <typename C1, typename E1, E1 (*A1)(typename C1::const_iterator &)>\n  friend void swap(AdaptedConstIterator<C1, E1, A1> &,\n                   AdaptedConstIterator<C1, E1, A1> &);\n\nprivate:\n  BackingIterator m_iter;\n};\n\ntemplate <typename C, typename E, E (*A)(typename C::const_iterator &)>\nAdaptedConstIterator<C, E, A> operator+(\n    typename AdaptedConstIterator<C, E, A>::BackingIterator::difference_type\n        offset,\n    AdaptedConstIterator<C, E, A> &rhs) {\n  return rhs.operator+(offset);\n}\n\ntemplate <typename C, typename E, E (*A)(typename C::const_iterator &)>\ntypename AdaptedConstIterator<C, E, A>::BackingIterator::difference_type\noperator-(AdaptedConstIterator<C, E, A> &lhs,\n          AdaptedConstIterator<C, E, A> &rhs) {\n  return (lhs.m_iter - rhs.m_iter);\n}\n\ntemplate <typename C, typename E, E (*A)(typename C::const_iterator &)>\nvoid swap(AdaptedConstIterator<C, E, A> &lhs,\n          AdaptedConstIterator<C, E, A> &rhs) {\n  std::swap(lhs.m_iter, rhs.m_iter);\n}\n\ntemplate <typename C, typename E, E (*A)(typename C::const_iterator &)>\nclass AdaptedIterable {\nprivate:\n  const C &m_container;\n\npublic:\n  AdaptedIterable(const C &container) : m_container(container) {}\n\n  AdaptedConstIterator<C, E, A> begin() {\n    return AdaptedConstIterator<C, E, A>(m_container.begin());\n  }\n\n  AdaptedConstIterator<C, E, A> end() {\n    return AdaptedConstIterator<C, E, A>(m_container.end());\n  }\n};\n\ntemplate <typename C, typename E, E (*A)(typename C::const_iterator &),\n          typename MutexType>\nclass LockingAdaptedIterable : public AdaptedIterable<C, E, A> {\npublic:\n  LockingAdaptedIterable(const C &container, MutexType &mutex)\n      : AdaptedIterable<C, E, A>(container), m_mutex(&mutex) {\n    m_mutex->lock();\n  }\n\n  LockingAdaptedIterable(LockingAdaptedIterable &&rhs)\n      : AdaptedIterable<C, E, A>(rhs), m_mutex(rhs.m_mutex) {\n    rhs.m_mutex = nullptr;\n  }\n\n  ~LockingAdaptedIterable() {\n    if (m_mutex)\n      m_mutex->unlock();\n  }\n\nprivate:\n  MutexType *m_mutex = nullptr;\n\n  LockingAdaptedIterable(const LockingAdaptedIterable &) = delete;\n  LockingAdaptedIterable &operator=(const LockingAdaptedIterable &) = delete;\n};\n\n} // namespace lldb_private\n\n#endif // LLDB_UTILITY_ITERABLE_H\n"}, "39": {"id": 39, "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Utility/ProcessInfo.h", "content": "//===-- ProcessInfo.h -------------------------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLDB_UTILITY_PROCESSINFO_H\n#define LLDB_UTILITY_PROCESSINFO_H\n\n#include \"lldb/Utility/ArchSpec.h\"\n#include \"lldb/Utility/Args.h\"\n#include \"lldb/Utility/Environment.h\"\n#include \"lldb/Utility/FileSpec.h\"\n#include \"lldb/Utility/NameMatches.h\"\n#include \"llvm/Support/YAMLTraits.h\"\n#include <vector>\n\nnamespace lldb_private {\n\nclass UserIDResolver;\n\n// ProcessInfo\n//\n// A base class for information for a process. This can be used to fill\n// out information for a process prior to launching it, or it can be used for\n// an instance of a process and can be filled in with the existing values for\n// that process.\nclass ProcessInfo {\npublic:\n  ProcessInfo();\n\n  ProcessInfo(const char *name, const ArchSpec &arch, lldb::pid_t pid);\n\n  void Clear();\n\n  const char *GetName() const;\n\n  llvm::StringRef GetNameAsStringRef() const;\n\n  FileSpec &GetExecutableFile() { return m_executable; }\n\n  void SetExecutableFile(const FileSpec &exe_file,\n                         bool add_exe_file_as_first_arg);\n\n  const FileSpec &GetExecutableFile() const { return m_executable; }\n\n  uint32_t GetUserID() const { return m_uid; }\n\n  uint32_t GetGroupID() const { return m_gid; }\n\n  bool UserIDIsValid() const { return m_uid != UINT32_MAX; }\n\n  bool GroupIDIsValid() const { return m_gid != UINT32_MAX; }\n\n  void SetUserID(uint32_t uid) { m_uid = uid; }\n\n  void SetGroupID(uint32_t gid) { m_gid = gid; }\n\n  ArchSpec &GetArchitecture() { return m_arch; }\n\n  const ArchSpec &GetArchitecture() const { return m_arch; }\n\n  void SetArchitecture(const ArchSpec &arch) { m_arch = arch; }\n\n  lldb::pid_t GetProcessID() const { return m_pid; }\n\n  void SetProcessID(lldb::pid_t pid) { m_pid = pid; }\n\n  bool ProcessIDIsValid() const { return m_pid != LLDB_INVALID_PROCESS_ID; }\n\n  void Dump(Stream &s, Platform *platform) const;\n\n  Args &GetArguments() { return m_arguments; }\n\n  const Args &GetArguments() const { return m_arguments; }\n\n  llvm::StringRef GetArg0() const;\n\n  void SetArg0(llvm::StringRef arg);\n\n  void SetArguments(const Args &args, bool first_arg_is_executable);\n\n  void SetArguments(char const **argv, bool first_arg_is_executable);\n\n  Environment &GetEnvironment() { return m_environment; }\n  const Environment &GetEnvironment() const { return m_environment; }\n\nprotected:\n  template <class T> friend struct llvm::yaml::MappingTraits;\n  FileSpec m_executable;\n  std::string m_arg0; // argv[0] if supported. If empty, then use m_executable.\n  // Not all process plug-ins support specifying an argv[0] that differs from\n  // the resolved platform executable (which is in m_executable)\n  Args m_arguments; // All program arguments except argv[0]\n  Environment m_environment;\n  uint32_t m_uid;\n  uint32_t m_gid;\n  ArchSpec m_arch;\n  lldb::pid_t m_pid;\n};\n\n// ProcessInstanceInfo\n//\n// Describes an existing process and any discoverable information that pertains\n// to that process.\nclass ProcessInstanceInfo : public ProcessInfo {\npublic:\n  ProcessInstanceInfo()\n      : ProcessInfo(), m_euid(UINT32_MAX), m_egid(UINT32_MAX),\n        m_parent_pid(LLDB_INVALID_PROCESS_ID) {}\n\n  ProcessInstanceInfo(const char *name, const ArchSpec &arch, lldb::pid_t pid)\n      : ProcessInfo(name, arch, pid), m_euid(UINT32_MAX), m_egid(UINT32_MAX),\n        m_parent_pid(LLDB_INVALID_PROCESS_ID) {}\n\n  void Clear() {\n    ProcessInfo::Clear();\n    m_euid = UINT32_MAX;\n    m_egid = UINT32_MAX;\n    m_parent_pid = LLDB_INVALID_PROCESS_ID;\n  }\n\n  uint32_t GetEffectiveUserID() const { return m_euid; }\n\n  uint32_t GetEffectiveGroupID() const { return m_egid; }\n\n  bool EffectiveUserIDIsValid() const { return m_euid != UINT32_MAX; }\n\n  bool EffectiveGroupIDIsValid() const { return m_egid != UINT32_MAX; }\n\n  void SetEffectiveUserID(uint32_t uid) { m_euid = uid; }\n\n  void SetEffectiveGroupID(uint32_t gid) { m_egid = gid; }\n\n  lldb::pid_t GetParentProcessID() const { return m_parent_pid; }\n\n  void SetParentProcessID(lldb::pid_t pid) { m_parent_pid = pid; }\n\n  bool ParentProcessIDIsValid() const {\n    return m_parent_pid != LLDB_INVALID_PROCESS_ID;\n  }\n\n  void Dump(Stream &s, UserIDResolver &resolver) const;\n\n  static void DumpTableHeader(Stream &s, bool show_args, bool verbose);\n\n  void DumpAsTableRow(Stream &s, UserIDResolver &resolver, bool show_args,\n                      bool verbose) const;\n\nprotected:\n  friend struct llvm::yaml::MappingTraits<ProcessInstanceInfo>;\n  uint32_t m_euid;\n  uint32_t m_egid;\n  lldb::pid_t m_parent_pid;\n};\n\ntypedef std::vector<ProcessInstanceInfo> ProcessInstanceInfoList;\n\n// ProcessInstanceInfoMatch\n//\n// A class to help matching one ProcessInstanceInfo to another.\n\nclass ProcessInstanceInfoMatch {\npublic:\n  ProcessInstanceInfoMatch()\n      : m_match_info(), m_name_match_type(NameMatch::Ignore),\n        m_match_all_users(false) {}\n\n  ProcessInstanceInfoMatch(const char *process_name,\n                           NameMatch process_name_match_type)\n      : m_match_info(), m_name_match_type(process_name_match_type),\n        m_match_all_users(false) {\n    m_match_info.GetExecutableFile().SetFile(process_name,\n                                             FileSpec::Style::native);\n  }\n\n  ProcessInstanceInfo &GetProcessInfo() { return m_match_info; }\n\n  const ProcessInstanceInfo &GetProcessInfo() const { return m_match_info; }\n\n  bool GetMatchAllUsers() const { return m_match_all_users; }\n\n  void SetMatchAllUsers(bool b) { m_match_all_users = b; }\n\n  NameMatch GetNameMatchType() const { return m_name_match_type; }\n\n  void SetNameMatchType(NameMatch name_match_type) {\n    m_name_match_type = name_match_type;\n  }\n\n  /// Return true iff the architecture in this object matches arch_spec.\n  bool ArchitectureMatches(const ArchSpec &arch_spec) const;\n\n  /// Return true iff the process name in this object matches process_name.\n  bool NameMatches(const char *process_name) const;\n\n  /// Return true iff the process ID and parent process IDs in this object match\n  /// the ones in proc_info.\n  bool ProcessIDsMatch(const ProcessInstanceInfo &proc_info) const;\n\n  /// Return true iff the (both effective and real) user and group IDs in this\n  /// object match the ones in proc_info.\n  bool UserIDsMatch(const ProcessInstanceInfo &proc_info) const;\n\n  bool Matches(const ProcessInstanceInfo &proc_info) const;\n\n  bool MatchAllProcesses() const;\n  void Clear();\n\nprotected:\n  ProcessInstanceInfo m_match_info;\n  NameMatch m_name_match_type;\n  bool m_match_all_users;\n};\n\nnamespace repro {\nllvm::Optional<ProcessInstanceInfoList> GetReplayProcessInstanceInfoList();\n} // namespace repro\n} // namespace lldb_private\n\nLLVM_YAML_IS_SEQUENCE_VECTOR(lldb_private::ProcessInstanceInfo)\n\nnamespace llvm {\nnamespace yaml {\ntemplate <> struct MappingTraits<lldb_private::ProcessInstanceInfo> {\n  static void mapping(IO &io, lldb_private::ProcessInstanceInfo &PII);\n};\n} // namespace yaml\n} // namespace llvm\n\n#endif // LLDB_UTILITY_PROCESSINFO_H\n"}, "40": {"id": 40, "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Utility/RegularExpression.h", "content": "//===-- RegularExpression.h -------------------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLDB_UTILITY_REGULAREXPRESSION_H\n#define LLDB_UTILITY_REGULAREXPRESSION_H\n\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/Support/Error.h\"\n#include \"llvm/Support/Regex.h\"\n\nnamespace lldb_private {\n\nclass RegularExpression {\npublic:\n  /// The default constructor that initializes the object state such that it\n  /// contains no compiled regular expression.\n  RegularExpression() = default;\n\n  /// Constructor for a regular expression.\n  ///\n  /// Compile a regular expression using the supplied regular expression text.\n  /// The compiled regular expression lives in this object so that it can be\n  /// readily used for regular expression matches. Execute() can be called\n  /// after the regular expression is compiled.\n  ///\n  /// \\param[in] string\n  ///     An llvm::StringRef that represents the regular expression to compile.\n  //      String is not referenced anymore after the object is constructed.\n  explicit RegularExpression(llvm::StringRef string);\n\n  ~RegularExpression() = default;\n\n  RegularExpression(const RegularExpression &rhs);\n  RegularExpression(RegularExpression &&rhs) = default;\n\n  RegularExpression &operator=(RegularExpression &&rhs) = default;\n  RegularExpression &operator=(const RegularExpression &rhs) = default;\n\n  /// Execute a regular expression match using the compiled regular expression\n  /// that is already in this object against the given \\a string. If any parens\n  /// are used for regular expression matches.\n  ///\n  /// \\param[in] string\n  ///     The string to match against the compile regular expression.\n  ///\n  /// \\param[out] matches\n  ///     A pointer to a SmallVector to hold the matches.\n  ///\n  /// \\return\n  ///     true if \\a string matches the compiled regular expression, false\n  ///     otherwise incl. the case regular exression failed to compile.\n  bool Execute(llvm::StringRef string,\n               llvm::SmallVectorImpl<llvm::StringRef> *matches = nullptr) const;\n\n  /// Access the regular expression text.\n  ///\n  /// \\return\n  ///     The NULL terminated C string that was used to compile the\n  ///     current regular expression\n  llvm::StringRef GetText() const;\n\n  /// Test if this object contains a valid regular expression.\n  ///\n  /// \\return\n  ///     true if the regular expression compiled and is ready for execution,\n  ///     false otherwise.\n  bool IsValid() const;\n\n  /// Return an error if the regular expression failed to compile.\n  ///\n  /// \\return\n  ///     A string error if the regular expression failed to compile, success\n  ///     otherwise.\n  llvm::Error GetError() const;\n\n  bool operator==(const RegularExpression &rhs) const {\n    return GetText() == rhs.GetText();\n  }\n\nprivate:\n  /// A copy of the original regular expression text.\n  std::string m_regex_text;\n  /// The compiled regular expression.\n  mutable llvm::Regex m_regex;\n};\n\n} // namespace lldb_private\n\n#endif // LLDB_UTILITY_REGULAREXPRESSION_H\n"}, "41": {"id": 41, "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Utility/Scalar.h", "content": "//===-- Scalar.h ------------------------------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLDB_UTILITY_SCALAR_H\n#define LLDB_UTILITY_SCALAR_H\n\n#include \"lldb/Utility/LLDBAssert.h\"\n#include \"lldb/Utility/Status.h\"\n#include \"lldb/lldb-enumerations.h\"\n#include \"lldb/lldb-private-types.h\"\n#include \"llvm/ADT/APFloat.h\"\n#include \"llvm/ADT/APSInt.h\"\n#include <cstddef>\n#include <cstdint>\n#include <utility>\n\nnamespace lldb_private {\n\nclass DataExtractor;\nclass Stream;\n\n#define NUM_OF_WORDS_INT128 2\n#define BITWIDTH_INT128 128\n\n// A class designed to hold onto values and their corresponding types.\n// Operators are defined and Scalar objects will correctly promote their types\n// and values before performing these operations. Type promotion currently\n// follows the ANSI C type promotion rules.\nclass Scalar {\n  template<typename T>\n  static llvm::APSInt MakeAPSInt(T v) {\n    static_assert(std::is_integral<T>::value, \"\");\n    static_assert(sizeof(T) <= sizeof(uint64_t), \"Conversion loses precision!\");\n    return llvm::APSInt(\n        llvm::APInt(sizeof(T) * 8, uint64_t(v), std::is_signed<T>::value),\n        std::is_unsigned<T>::value);\n  }\n\npublic:\n  enum Type {\n    e_void = 0,\n    e_int,\n    e_float,\n  };\n\n  // Constructors and Destructors\n  Scalar() : m_type(e_void), m_float(0.0f) {}\n  Scalar(int v) : m_type(e_int), m_integer(MakeAPSInt(v)), m_float(0.0f) {}\n  Scalar(unsigned int v)\n      : m_type(e_int), m_integer(MakeAPSInt(v)), m_float(0.0f) {}\n  Scalar(long v) : m_type(e_int), m_integer(MakeAPSInt(v)), m_float(0.0f) {}\n  Scalar(unsigned long v)\n      : m_type(e_int), m_integer(MakeAPSInt(v)), m_float(0.0f) {}\n  Scalar(long long v)\n      : m_type(e_int), m_integer(MakeAPSInt(v)), m_float(0.0f) {}\n  Scalar(unsigned long long v)\n      : m_type(e_int), m_integer(MakeAPSInt(v)), m_float(0.0f) {}\n  Scalar(float v) : m_type(e_float), m_float(v) {}\n  Scalar(double v) : m_type(e_float), m_float(v) {}\n  Scalar(long double v) : m_type(e_float), m_float(double(v)) {\n    bool ignore;\n    m_float.convert(llvm::APFloat::x87DoubleExtended(),\n                    llvm::APFloat::rmNearestTiesToEven, &ignore);\n  }\n  Scalar(llvm::APInt v)\n      : m_type(e_int), m_integer(std::move(v), false), m_float(0.0f) {}\n  Scalar(llvm::APSInt v)\n      : m_type(e_int), m_integer(std::move(v)), m_float(0.0f) {}\n\n  bool SignExtend(uint32_t bit_pos);\n\n  bool ExtractBitfield(uint32_t bit_size, uint32_t bit_offset);\n\n  bool SetBit(uint32_t bit);\n\n  bool ClearBit(uint32_t bit);\n\n  /// Store the binary representation of this value into the given storage.\n  /// Exactly GetByteSize() bytes will be stored, and the buffer must be large\n  /// enough to hold this data.\n  void GetBytes(llvm::MutableArrayRef<uint8_t> storage) const;\n\n  size_t GetByteSize() const;\n\n  bool GetData(DataExtractor &data, size_t limit_byte_size = UINT32_MAX) const;\n\n  size_t GetAsMemoryData(void *dst, size_t dst_len,\n                         lldb::ByteOrder dst_byte_order, Status &error) const;\n\n  bool IsZero() const;\n\n  void Clear() {\n    m_type = e_void;\n    m_integer.clearAllBits();\n  }\n\n  const char *GetTypeAsCString() const { return GetValueTypeAsCString(m_type); }\n\n  void GetValue(Stream *s, bool show_type) const;\n\n  bool IsValid() const { return (m_type >= e_int) && (m_type <= e_float); }\n\n  /// Convert to an integer with \\p bits and the given signedness.\n  void TruncOrExtendTo(uint16_t bits, bool sign);\n\n  bool IntegralPromote(uint16_t bits, bool sign);\n  bool FloatPromote(const llvm::fltSemantics &semantics);\n\n  bool IsSigned() const;\n  bool MakeSigned();\n\n  bool MakeUnsigned();\n\n  static const char *GetValueTypeAsCString(Scalar::Type value_type);\n\n  // All operators can benefits from the implicit conversions that will happen\n  // automagically by the compiler, so no temporary objects will need to be\n  // created. As a result, we currently don't need a variety of overloaded set\n  // value accessors.\n  Scalar &operator+=(Scalar rhs);\n  Scalar &operator<<=(const Scalar &rhs); // Shift left\n  Scalar &operator>>=(const Scalar &rhs); // Shift right (arithmetic)\n  Scalar &operator&=(const Scalar &rhs);\n\n  // Shifts the current value to the right without maintaining the current sign\n  // of the value (if it is signed).\n  bool ShiftRightLogical(const Scalar &rhs); // Returns true on success\n\n  // Takes the absolute value of the current value if it is signed, else the\n  // value remains unchanged. Returns false if the contained value has a void\n  // type.\n  bool AbsoluteValue(); // Returns true on success\n  // Negates the current value (even for unsigned values). Returns false if the\n  // contained value has a void type.\n  bool UnaryNegate(); // Returns true on success\n  // Inverts all bits in the current value as long as it isn't void or a\n  // float/double/long double type. Returns false if the contained value has a\n  // void/float/double/long double type, else the value is inverted and true is\n  // returned.\n  bool OnesComplement(); // Returns true on success\n\n  // Access the type of the current value.\n  Scalar::Type GetType() const { return m_type; }\n\n  // Returns a casted value of the current contained data without modifying the\n  // current value. FAIL_VALUE will be returned if the type of the value is\n  // void or invalid.\n  int SInt(int fail_value = 0) const;\n\n  unsigned char UChar(unsigned char fail_value = 0) const;\n\n  signed char SChar(signed char fail_value = 0) const;\n\n  unsigned short UShort(unsigned short fail_value = 0) const;\n\n  short SShort(short fail_value = 0) const;\n\n  unsigned int UInt(unsigned int fail_value = 0) const;\n\n  long SLong(long fail_value = 0) const;\n\n  unsigned long ULong(unsigned long fail_value = 0) const;\n\n  long long SLongLong(long long fail_value = 0) const;\n\n  unsigned long long ULongLong(unsigned long long fail_value = 0) const;\n\n  llvm::APInt SInt128(const llvm::APInt &fail_value) const;\n\n  llvm::APInt UInt128(const llvm::APInt &fail_value) const;\n\n  float Float(float fail_value = 0.0f) const;\n\n  double Double(double fail_value = 0.0) const;\n\n  long double LongDouble(long double fail_value = 0.0) const;\n\n  Status SetValueFromCString(const char *s, lldb::Encoding encoding,\n                             size_t byte_size);\n\n  Status SetValueFromData(const DataExtractor &data, lldb::Encoding encoding,\n                          size_t byte_size);\n\nprotected:\n  Scalar::Type m_type;\n  llvm::APSInt m_integer;\n  llvm::APFloat m_float;\n\n  template <typename T> T GetAs(T fail_value) const;\n\n  static Type PromoteToMaxType(Scalar &lhs, Scalar &rhs);\n\n  using PromotionKey = std::tuple<Type, unsigned, bool>;\n  PromotionKey GetPromoKey() const;\n\n  static PromotionKey GetFloatPromoKey(const llvm::fltSemantics &semantics);\n\nprivate:\n  friend const Scalar operator+(const Scalar &lhs, const Scalar &rhs);\n  friend const Scalar operator-(Scalar lhs, Scalar rhs);\n  friend const Scalar operator/(Scalar lhs, Scalar rhs);\n  friend const Scalar operator*(Scalar lhs, Scalar rhs);\n  friend const Scalar operator&(Scalar lhs, Scalar rhs);\n  friend const Scalar operator|(Scalar lhs, Scalar rhs);\n  friend const Scalar operator%(Scalar lhs, Scalar rhs);\n  friend const Scalar operator^(Scalar lhs, Scalar rhs);\n  friend const Scalar operator<<(const Scalar &lhs, const Scalar &rhs);\n  friend const Scalar operator>>(const Scalar &lhs, const Scalar &rhs);\n  friend bool operator==(Scalar lhs, Scalar rhs);\n  friend bool operator!=(const Scalar &lhs, const Scalar &rhs);\n  friend bool operator<(Scalar lhs, Scalar rhs);\n  friend bool operator<=(const Scalar &lhs, const Scalar &rhs);\n  friend bool operator>(const Scalar &lhs, const Scalar &rhs);\n  friend bool operator>=(const Scalar &lhs, const Scalar &rhs);\n};\n\n// Split out the operators into a format where the compiler will be able to\n// implicitly convert numbers into Scalar objects.\n//\n// This allows code like:\n//      Scalar two(2);\n//      Scalar four = two * 2;\n//      Scalar eight = 2 * four;    // This would cause an error if the\n//                                  // operator* was implemented as a\n//                                  // member function.\n// SEE:\n//  Item 19 of \"Effective C++ Second Edition\" by Scott Meyers\n//  Differentiate among members functions, non-member functions, and\n//  friend functions\nconst Scalar operator+(const Scalar &lhs, const Scalar &rhs);\nconst Scalar operator-(Scalar lhs, Scalar rhs);\nconst Scalar operator/(Scalar lhs, Scalar rhs);\nconst Scalar operator*(Scalar lhs, Scalar rhs);\nconst Scalar operator&(Scalar lhs, Scalar rhs);\nconst Scalar operator|(Scalar lhs, Scalar rhs);\nconst Scalar operator%(Scalar lhs, Scalar rhs);\nconst Scalar operator^(Scalar lhs, Scalar rhs);\nconst Scalar operator<<(const Scalar &lhs, const Scalar &rhs);\nconst Scalar operator>>(const Scalar &lhs, const Scalar &rhs);\nbool operator==(Scalar lhs, Scalar rhs);\nbool operator!=(const Scalar &lhs, const Scalar &rhs);\nbool operator<(Scalar lhs, Scalar rhs);\nbool operator<=(const Scalar &lhs, const Scalar &rhs);\nbool operator>(const Scalar &lhs, const Scalar &rhs);\nbool operator>=(const Scalar &lhs, const Scalar &rhs);\n\nllvm::raw_ostream &operator<<(llvm::raw_ostream &os, const Scalar &scalar);\n\n} // namespace lldb_private\n\n#endif // LLDB_UTILITY_SCALAR_H\n"}, "43": {"id": 43, "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Utility/StructuredData.h", "content": "//===-- StructuredData.h ----------------------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLDB_UTILITY_STRUCTUREDDATA_H\n#define LLDB_UTILITY_STRUCTUREDDATA_H\n\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/Support/JSON.h\"\n\n#include \"lldb/Utility/ConstString.h\"\n#include \"lldb/Utility/FileSpec.h\"\n#include \"lldb/Utility/Stream.h\"\n#include \"lldb/lldb-enumerations.h\"\n\n#include <cassert>\n#include <cstddef>\n#include <cstdint>\n#include <functional>\n#include <map>\n#include <memory>\n#include <string>\n#include <type_traits>\n#include <utility>\n#include <vector>\n\nnamespace lldb_private {\nclass Status;\n}\n\nnamespace lldb_private {\n\n/// \\class StructuredData StructuredData.h \"lldb/Utility/StructuredData.h\"\n/// A class which can hold structured data\n///\n/// The StructuredData class is designed to hold the data from a JSON or plist\n/// style file -- a serialized data structure with dictionaries (maps,\n/// hashes), arrays, and concrete values like integers, floating point\n/// numbers, strings, booleans.\n///\n/// StructuredData does not presuppose any knowledge of the schema for the\n/// data it is holding; it can parse JSON data, for instance, and other parts\n/// of lldb can iterate through the parsed data set to find keys and values\n/// that may be present.\n\nclass StructuredData {\npublic:\n  class Object;\n  class Array;\n  class Integer;\n  class Float;\n  class Boolean;\n  class String;\n  class Dictionary;\n  class Generic;\n\n  typedef std::shared_ptr<Object> ObjectSP;\n  typedef std::shared_ptr<Array> ArraySP;\n  typedef std::shared_ptr<Integer> IntegerSP;\n  typedef std::shared_ptr<Float> FloatSP;\n  typedef std::shared_ptr<Boolean> BooleanSP;\n  typedef std::shared_ptr<String> StringSP;\n  typedef std::shared_ptr<Dictionary> DictionarySP;\n  typedef std::shared_ptr<Generic> GenericSP;\n\n  class Object : public std::enable_shared_from_this<Object> {\n  public:\n    Object(lldb::StructuredDataType t = lldb::eStructuredDataTypeInvalid)\n        : m_type(t) {}\n\n    virtual ~Object() = default;\n\n    virtual bool IsValid() const { return true; }\n\n    virtual void Clear() { m_type = lldb::eStructuredDataTypeInvalid; }\n\n    lldb::StructuredDataType GetType() const { return m_type; }\n\n    void SetType(lldb::StructuredDataType t) { m_type = t; }\n\n    Array *GetAsArray() {\n      return ((m_type == lldb::eStructuredDataTypeArray)\n                  ? static_cast<Array *>(this)\n                  : nullptr);\n    }\n\n    Dictionary *GetAsDictionary() {\n      return ((m_type == lldb::eStructuredDataTypeDictionary)\n                  ? static_cast<Dictionary *>(this)\n                  : nullptr);\n    }\n\n    Integer *GetAsInteger() {\n      return ((m_type == lldb::eStructuredDataTypeInteger)\n                  ? static_cast<Integer *>(this)\n                  : nullptr);\n    }\n\n    uint64_t GetIntegerValue(uint64_t fail_value = 0) {\n      Integer *integer = GetAsInteger();\n      return ((integer != nullptr) ? integer->GetValue() : fail_value);\n    }\n\n    Float *GetAsFloat() {\n      return ((m_type == lldb::eStructuredDataTypeFloat)\n                  ? static_cast<Float *>(this)\n                  : nullptr);\n    }\n\n    double GetFloatValue(double fail_value = 0.0) {\n      Float *f = GetAsFloat();\n      return ((f != nullptr) ? f->GetValue() : fail_value);\n    }\n\n    Boolean *GetAsBoolean() {\n      return ((m_type == lldb::eStructuredDataTypeBoolean)\n                  ? static_cast<Boolean *>(this)\n                  : nullptr);\n    }\n\n    bool GetBooleanValue(bool fail_value = false) {\n      Boolean *b = GetAsBoolean();\n      return ((b != nullptr) ? b->GetValue() : fail_value);\n    }\n\n    String *GetAsString() {\n      return ((m_type == lldb::eStructuredDataTypeString)\n                  ? static_cast<String *>(this)\n                  : nullptr);\n    }\n\n    llvm::StringRef GetStringValue(const char *fail_value = nullptr) {\n      String *s = GetAsString();\n      if (s)\n        return s->GetValue();\n\n      return fail_value;\n    }\n\n    Generic *GetAsGeneric() {\n      return ((m_type == lldb::eStructuredDataTypeGeneric)\n                  ? static_cast<Generic *>(this)\n                  : nullptr);\n    }\n\n    ObjectSP GetObjectForDotSeparatedPath(llvm::StringRef path);\n\n    void DumpToStdout(bool pretty_print = true) const;\n\n    virtual void Serialize(llvm::json::OStream &s) const = 0;\n\n    void Dump(lldb_private::Stream &s, bool pretty_print = true) const {\n      llvm::json::OStream jso(s.AsRawOstream(), pretty_print ? 2 : 0);\n      Serialize(jso);\n    }\n\n  private:\n    lldb::StructuredDataType m_type;\n  };\n\n  class Array : public Object {\n  public:\n    Array() : Object(lldb::eStructuredDataTypeArray) {}\n\n    ~Array() override = default;\n\n    bool\n    ForEach(std::function<bool(Object *object)> const &foreach_callback) const {\n      for (const auto &object_sp : m_items) {\n        if (!foreach_callback(object_sp.get()))\n          return false;\n      }\n      return true;\n    }\n\n    size_t GetSize() const { return m_items.size(); }\n\n    ObjectSP operator[](size_t idx) {\n      if (idx < m_items.size())\n        return m_items[idx];\n      return ObjectSP();\n    }\n\n    ObjectSP GetItemAtIndex(size_t idx) const {\n      assert(idx < GetSize());\n      if (idx < m_items.size())\n        return m_items[idx];\n      return ObjectSP();\n    }\n\n    template <class IntType>\n    bool GetItemAtIndexAsInteger(size_t idx, IntType &result) const {\n      ObjectSP value_sp = GetItemAtIndex(idx);\n      if (value_sp.get()) {\n        if (auto int_value = value_sp->GetAsInteger()) {\n          result = static_cast<IntType>(int_value->GetValue());\n          return true;\n        }\n      }\n      return false;\n    }\n\n    template <class IntType>\n    bool GetItemAtIndexAsInteger(size_t idx, IntType &result,\n                                 IntType default_val) const {\n      bool success = GetItemAtIndexAsInteger(idx, result);\n      if (!success)\n        result = default_val;\n      return success;\n    }\n\n    bool GetItemAtIndexAsString(size_t idx, llvm::StringRef &result) const {\n      ObjectSP value_sp = GetItemAtIndex(idx);\n      if (value_sp.get()) {\n        if (auto string_value = value_sp->GetAsString()) {\n          result = string_value->GetValue();\n          return true;\n        }\n      }\n      return false;\n    }\n\n    bool GetItemAtIndexAsString(size_t idx, llvm::StringRef &result,\n                                llvm::StringRef default_val) const {\n      bool success = GetItemAtIndexAsString(idx, result);\n      if (!success)\n        result = default_val;\n      return success;\n    }\n\n    bool GetItemAtIndexAsString(size_t idx, ConstString &result) const {\n      ObjectSP value_sp = GetItemAtIndex(idx);\n      if (value_sp.get()) {\n        if (auto string_value = value_sp->GetAsString()) {\n          result = ConstString(string_value->GetValue());\n          return true;\n        }\n      }\n      return false;\n    }\n\n    bool GetItemAtIndexAsString(size_t idx, ConstString &result,\n                                const char *default_val) const {\n      bool success = GetItemAtIndexAsString(idx, result);\n      if (!success)\n        result.SetCString(default_val);\n      return success;\n    }\n\n    bool GetItemAtIndexAsDictionary(size_t idx, Dictionary *&result) const {\n      result = nullptr;\n      ObjectSP value_sp = GetItemAtIndex(idx);\n      if (value_sp.get()) {\n        result = value_sp->GetAsDictionary();\n        return (result != nullptr);\n      }\n      return false;\n    }\n\n    bool GetItemAtIndexAsArray(size_t idx, Array *&result) const {\n      result = nullptr;\n      ObjectSP value_sp = GetItemAtIndex(idx);\n      if (value_sp.get()) {\n        result = value_sp->GetAsArray();\n        return (result != nullptr);\n      }\n      return false;\n    }\n\n    void Push(const ObjectSP &item) { m_items.push_back(item); }\n\n    void AddItem(const ObjectSP &item) { m_items.push_back(item); }\n\n    void Serialize(llvm::json::OStream &s) const override;\n\n  protected:\n    typedef std::vector<ObjectSP> collection;\n    collection m_items;\n  };\n\n  class Integer : public Object {\n  public:\n    Integer(uint64_t i = 0)\n        : Object(lldb::eStructuredDataTypeInteger), m_value(i) {}\n\n    ~Integer() override = default;\n\n    void SetValue(uint64_t value) { m_value = value; }\n\n    uint64_t GetValue() { return m_value; }\n\n    void Serialize(llvm::json::OStream &s) const override;\n\n  protected:\n    uint64_t m_value;\n  };\n\n  class Float : public Object {\n  public:\n    Float(double d = 0.0)\n        : Object(lldb::eStructuredDataTypeFloat), m_value(d) {}\n\n    ~Float() override = default;\n\n    void SetValue(double value) { m_value = value; }\n\n    double GetValue() { return m_value; }\n\n    void Serialize(llvm::json::OStream &s) const override;\n\n  protected:\n    double m_value;\n  };\n\n  class Boolean : public Object {\n  public:\n    Boolean(bool b = false)\n        : Object(lldb::eStructuredDataTypeBoolean), m_value(b) {}\n\n    ~Boolean() override = default;\n\n    void SetValue(bool value) { m_value = value; }\n\n    bool GetValue() { return m_value; }\n\n    void Serialize(llvm::json::OStream &s) const override;\n\n  protected:\n    bool m_value;\n  };\n\n  class String : public Object {\n  public:\n    String() : Object(lldb::eStructuredDataTypeString) {}\n    explicit String(llvm::StringRef S)\n        : Object(lldb::eStructuredDataTypeString), m_value(S) {}\n\n    void SetValue(llvm::StringRef S) { m_value = std::string(S); }\n\n    llvm::StringRef GetValue() { return m_value; }\n\n    void Serialize(llvm::json::OStream &s) const override;\n\n  protected:\n    std::string m_value;\n  };\n\n  class Dictionary : public Object {\n  public:\n    Dictionary() : Object(lldb::eStructuredDataTypeDictionary), m_dict() {}\n\n    ~Dictionary() override = default;\n\n    size_t GetSize() const { return m_dict.size(); }\n\n    void ForEach(std::function<bool(ConstString key, Object *object)> const\n                     &callback) const {\n      for (const auto &pair : m_dict) {\n        if (!callback(pair.first, pair.second.get()))\n          break;\n      }\n    }\n\n    ObjectSP GetKeys() const {\n      auto object_sp = std::make_shared<Array>();\n      collection::const_iterator iter;\n      for (iter = m_dict.begin(); iter != m_dict.end(); ++iter) {\n        auto key_object_sp = std::make_shared<String>();\n        key_object_sp->SetValue(iter->first.AsCString());\n        object_sp->Push(key_object_sp);\n      }\n      return object_sp;\n    }\n\n    ObjectSP GetValueForKey(llvm::StringRef key) const {\n      ObjectSP value_sp;\n      if (!key.empty()) {\n        ConstString key_cs(key);\n        collection::const_iterator iter = m_dict.find(key_cs);\n        if (iter != m_dict.end())\n          value_sp = iter->second;\n      }\n      return value_sp;\n    }\n\n    bool GetValueForKeyAsBoolean(llvm::StringRef key, bool &result) const {\n      bool success = false;\n      ObjectSP value_sp = GetValueForKey(key);\n      if (value_sp.get()) {\n        Boolean *result_ptr = value_sp->GetAsBoolean();\n        if (result_ptr) {\n          result = result_ptr->GetValue();\n          success = true;\n        }\n      }\n      return success;\n    }\n    template <class IntType>\n    bool GetValueForKeyAsInteger(llvm::StringRef key, IntType &result) const {\n      ObjectSP value_sp = GetValueForKey(key);\n      if (value_sp) {\n        if (auto int_value = value_sp->GetAsInteger()) {\n          result = static_cast<IntType>(int_value->GetValue());\n          return true;\n        }\n      }\n      return false;\n    }\n\n    template <class IntType>\n    bool GetValueForKeyAsInteger(llvm::StringRef key, IntType &result,\n                                 IntType default_val) const {\n      bool success = GetValueForKeyAsInteger<IntType>(key, result);\n      if (!success)\n        result = default_val;\n      return success;\n    }\n\n    bool GetValueForKeyAsString(llvm::StringRef key,\n                                llvm::StringRef &result) const {\n      ObjectSP value_sp = GetValueForKey(key);\n      if (value_sp.get()) {\n        if (auto string_value = value_sp->GetAsString()) {\n          result = string_value->GetValue();\n          return true;\n        }\n      }\n      return false;\n    }\n\n    bool GetValueForKeyAsString(llvm::StringRef key, llvm::StringRef &result,\n                                const char *default_val) const {\n      bool success = GetValueForKeyAsString(key, result);\n      if (!success) {\n        if (default_val)\n          result = default_val;\n        else\n          result = llvm::StringRef();\n      }\n      return success;\n    }\n\n    bool GetValueForKeyAsString(llvm::StringRef key,\n                                ConstString &result) const {\n      ObjectSP value_sp = GetValueForKey(key);\n      if (value_sp.get()) {\n        if (auto string_value = value_sp->GetAsString()) {\n          result = ConstString(string_value->GetValue());\n          return true;\n        }\n      }\n      return false;\n    }\n\n    bool GetValueForKeyAsString(llvm::StringRef key, ConstString &result,\n                                const char *default_val) const {\n      bool success = GetValueForKeyAsString(key, result);\n      if (!success)\n        result.SetCString(default_val);\n      return success;\n    }\n\n    bool GetValueForKeyAsDictionary(llvm::StringRef key,\n                                    Dictionary *&result) const {\n      result = nullptr;\n      ObjectSP value_sp = GetValueForKey(key);\n      if (value_sp.get()) {\n        result = value_sp->GetAsDictionary();\n        return (result != nullptr);\n      }\n      return false;\n    }\n\n    bool GetValueForKeyAsArray(llvm::StringRef key, Array *&result) const {\n      result = nullptr;\n      ObjectSP value_sp = GetValueForKey(key);\n      if (value_sp.get()) {\n        result = value_sp->GetAsArray();\n        return (result != nullptr);\n      }\n      return false;\n    }\n\n    bool HasKey(llvm::StringRef key) const {\n      ConstString key_cs(key);\n      collection::const_iterator search = m_dict.find(key_cs);\n      return search != m_dict.end();\n    }\n\n    void AddItem(llvm::StringRef key, ObjectSP value_sp) {\n      ConstString key_cs(key);\n      m_dict[key_cs] = std::move(value_sp);\n    }\n\n    void AddIntegerItem(llvm::StringRef key, uint64_t value) {\n      AddItem(key, std::make_shared<Integer>(value));\n    }\n\n    void AddFloatItem(llvm::StringRef key, double value) {\n      AddItem(key, std::make_shared<Float>(value));\n    }\n\n    void AddStringItem(llvm::StringRef key, llvm::StringRef value) {\n      AddItem(key, std::make_shared<String>(std::move(value)));\n    }\n\n    void AddBooleanItem(llvm::StringRef key, bool value) {\n      AddItem(key, std::make_shared<Boolean>(value));\n    }\n\n    void Serialize(llvm::json::OStream &s) const override;\n\n  protected:\n    typedef std::map<ConstString, ObjectSP> collection;\n    collection m_dict;\n  };\n\n  class Null : public Object {\n  public:\n    Null() : Object(lldb::eStructuredDataTypeNull) {}\n\n    ~Null() override = default;\n\n    bool IsValid() const override { return false; }\n\n    void Serialize(llvm::json::OStream &s) const override;\n  };\n\n  class Generic : public Object {\n  public:\n    explicit Generic(void *object = nullptr)\n        : Object(lldb::eStructuredDataTypeGeneric), m_object(object) {}\n\n    void SetValue(void *value) { m_object = value; }\n\n    void *GetValue() const { return m_object; }\n\n    bool IsValid() const override { return m_object != nullptr; }\n\n    void Serialize(llvm::json::OStream &s) const override;\n\n  private:\n    void *m_object;\n  };\n\n  static ObjectSP ParseJSON(const std::string &json_text);\n  static ObjectSP ParseJSONFromFile(const FileSpec &file, Status &error);\n};\n\n} // namespace lldb_private\n\n#endif // LLDB_UTILITY_STRUCTUREDDATA_H\n"}, "44": {"id": 44, "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Utility/TraceOptions.h", "content": "//===-- TraceOptions.h ------------------------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLDB_UTILITY_TRACEOPTIONS_H\n#define LLDB_UTILITY_TRACEOPTIONS_H\n\n#include \"lldb/lldb-defines.h\"\n#include \"lldb/lldb-enumerations.h\"\n\n#include \"lldb/Utility/StructuredData.h\"\n\nnamespace lldb_private {\n\n/// This struct represents a tracing technology.\nstruct TraceTypeInfo {\n  /// The name of the technology, e.g. intel-pt or arm-coresight.\n  ///\n  /// In order for a Trace plug-in (see \\a lldb_private::Trace.h) to support the\n  /// trace technology given by this struct, it should match its name with this\n  /// field.\n  std::string name;\n  /// A description for the technology.\n  std::string description;\n};\n\nclass TraceOptions {\npublic:\n  TraceOptions() : m_trace_params(new StructuredData::Dictionary()) {}\n\n  const StructuredData::DictionarySP &getTraceParams() const {\n    return m_trace_params;\n  }\n\n  lldb::TraceType getType() const { return m_type; }\n\n  uint64_t getTraceBufferSize() const { return m_trace_buffer_size; }\n\n  uint64_t getMetaDataBufferSize() const { return m_meta_data_buffer_size; }\n\n  void setTraceParams(const StructuredData::DictionarySP &dict_obj) {\n    m_trace_params = dict_obj;\n  }\n\n  void setType(lldb::TraceType type) { m_type = type; }\n\n  void setTraceBufferSize(uint64_t size) { m_trace_buffer_size = size; }\n\n  void setMetaDataBufferSize(uint64_t size) { m_meta_data_buffer_size = size; }\n\n  void setThreadID(lldb::tid_t thread_id) { m_thread_id = thread_id; }\n\n  lldb::tid_t getThreadID() const { return m_thread_id; }\n\nprivate:\n  lldb::TraceType m_type;\n  uint64_t m_trace_buffer_size;\n  uint64_t m_meta_data_buffer_size;\n  lldb::tid_t m_thread_id;\n\n  /// m_trace_params is meant to hold any custom parameters\n  /// apart from meta buffer size and trace size.\n  /// The interpretation of such parameters is left to\n  /// the lldb-server.\n  StructuredData::DictionarySP m_trace_params;\n};\n}\n\nnamespace llvm {\nnamespace json {\n\nbool fromJSON(const Value &value, lldb_private::TraceTypeInfo &info, Path path);\n\n} // namespace json\n} // namespace llvm\n\n#endif // LLDB_UTILITY_TRACEOPTIONS_H\n"}, "45": {"id": 45, "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Utility/UUID.h", "content": "//===-- UUID.h --------------------------------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLDB_UTILITY_UUID_H\n#define LLDB_UTILITY_UUID_H\n\n#include \"llvm/ADT/ArrayRef.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/Support/Endian.h\"\n#include <stddef.h>\n#include <stdint.h>\n#include <string>\n\nnamespace lldb_private {\n\n  class Stream;\n\nclass UUID {\npublic:\n  UUID() = default;\n\n  // Reference:\n  // https://crashpad.chromium.org/doxygen/structcrashpad_1_1CodeViewRecordPDB70.html\n  struct CvRecordPdb70 {\n    struct {\n      llvm::support::ulittle32_t Data1;\n      llvm::support::ulittle16_t Data2;\n      llvm::support::ulittle16_t Data3;\n      uint8_t Data4[8];\n    } Uuid;\n    llvm::support::ulittle32_t Age;\n    // char PDBFileName[];\n  };\n\n  /// Create a UUID from CvRecordPdb70.\n  static UUID fromCvRecord(CvRecordPdb70 debug_info);\n\n  /// Creates a UUID from the data pointed to by the bytes argument. No special\n  /// significance is attached to any of the values.\n  static UUID fromData(const void *bytes, uint32_t num_bytes) {\n    if (bytes)\n      return fromData({reinterpret_cast<const uint8_t *>(bytes), num_bytes});\n    return UUID();\n  }\n\n  /// Creates a uuid from the data pointed to by the bytes argument. No special\n  /// significance is attached to any of the values.\n  static UUID fromData(llvm::ArrayRef<uint8_t> bytes) { return UUID(bytes); }\n\n  /// Creates a UUID from the data pointed to by the bytes argument. Data\n  /// consisting purely of zero bytes is treated as an invalid UUID.\n  static UUID fromOptionalData(const void *bytes, uint32_t num_bytes) {\n    if (bytes)\n      return fromOptionalData(\n          {reinterpret_cast<const uint8_t *>(bytes), num_bytes});\n    return UUID();\n  }\n\n  /// Creates a UUID from the data pointed to by the bytes argument. Data\n  /// consisting purely of zero bytes is treated as an invalid UUID.\n  static UUID fromOptionalData(llvm::ArrayRef<uint8_t> bytes) {\n    if (llvm::all_of(bytes, [](uint8_t b) { return b == 0; }))\n      return UUID();\n    return UUID(bytes);\n  }\n\n  void Clear() { m_bytes.clear(); }\n\n  void Dump(Stream *s) const;\n\n  llvm::ArrayRef<uint8_t> GetBytes() const { return m_bytes; }\n\n  explicit operator bool() const { return IsValid(); }\n  bool IsValid() const { return !m_bytes.empty(); }\n\n  std::string GetAsString(llvm::StringRef separator = \"-\") const;\n\n  bool SetFromStringRef(llvm::StringRef str);\n\n  // Same as SetFromStringRef, but if the resultant UUID is all 0 bytes, set the\n  // UUID to invalid.\n  bool SetFromOptionalStringRef(llvm::StringRef str);\n\n  /// Decode as many UUID bytes as possible from the C string \\a cstr.\n  ///\n  /// \\param[in] str\n  ///     An llvm::StringRef that points at a UUID string value (no leading\n  ///     spaces). The string must contain only hex characters and optionally\n  ///     can contain the '-' sepearators.\n  ///\n  /// \\param[in] uuid_bytes\n  ///     A buffer of bytes that will contain a full or partially decoded UUID.\n  ///\n  /// \\return\n  ///     The original string, with all decoded bytes removed.\n  static llvm::StringRef\n  DecodeUUIDBytesFromString(llvm::StringRef str,\n                            llvm::SmallVectorImpl<uint8_t> &uuid_bytes);\n\nprivate:\n  UUID(llvm::ArrayRef<uint8_t> bytes) : m_bytes(bytes.begin(), bytes.end()) {}\n\n  // GNU ld generates 20-byte build-ids. Size chosen to avoid heap allocations\n  // for this case.\n  llvm::SmallVector<uint8_t, 20> m_bytes;\n\n  friend bool operator==(const UUID &LHS, const UUID &RHS) {\n    return LHS.m_bytes == RHS.m_bytes;\n  }\n  friend bool operator!=(const UUID &LHS, const UUID &RHS) {\n    return !(LHS == RHS);\n  }\n  friend bool operator<(const UUID &LHS, const UUID &RHS) {\n    return LHS.m_bytes < RHS.m_bytes;\n  }\n  friend bool operator<=(const UUID &LHS, const UUID &RHS) {\n    return !(RHS < LHS);\n  }\n  friend bool operator>(const UUID &LHS, const UUID &RHS) { return RHS < LHS; }\n  friend bool operator>=(const UUID &LHS, const UUID &RHS) {\n    return !(LHS < RHS);\n  }\n};\n} // namespace lldb_private\n\n#endif // LLDB_UTILITY_UUID_H\n"}, "46": {"id": 46, "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Utility/UnimplementedError.h", "content": "//===-- UnimplementedError.h ------------------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLDB_UTILITY_UNIMPLEMENTEDERROR_H\n#define LLDB_UTILITY_UNIMPLEMENTEDERROR_H\n\n#include \"llvm/Support/Errc.h\"\n#include \"llvm/Support/Error.h\"\n\nnamespace lldb_private {\nclass UnimplementedError : public llvm::ErrorInfo<UnimplementedError> {\npublic:\n  static char ID;\n\n  void log(llvm::raw_ostream &OS) const override { OS << \"Not implemented\"; }\n\n  std::error_code convertToErrorCode() const override {\n    return llvm::errc::not_supported;\n  };\n};\n} // namespace lldb_private\n\n#endif // LLDB_UTILITY_UNIMPLEMENTEDERROR_H\n"}, "47": {"id": 47, "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/lldb-private-types.h", "content": "//===-- lldb-private-types.h ------------------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLDB_LLDB_PRIVATE_TYPES_H\n#define LLDB_LLDB_PRIVATE_TYPES_H\n\n#if defined(__cplusplus)\n\n#include \"lldb/lldb-private.h\"\n\n#include \"llvm/ADT/ArrayRef.h\"\n\nnamespace llvm {\nnamespace sys {\nclass DynamicLibrary;\n}\n}\n\nnamespace lldb_private {\nclass Platform;\nclass ExecutionContext;\n\ntypedef llvm::sys::DynamicLibrary (*LoadPluginCallbackType)(\n    const lldb::DebuggerSP &debugger_sp, const FileSpec &spec, Status &error);\n\n/// Every register is described in detail including its name, alternate name\n/// (optional), encoding, size in bytes and the default display format.\nstruct RegisterInfo {\n  /// Name of this register, can't be NULL.\n  const char *name;\n  /// Alternate name of this register, can be NULL.\n  const char *alt_name;\n  /// Size in bytes of the register.\n  uint32_t byte_size;\n  /// The byte offset in the register context data where this register's\n  /// value is found.\n  /// This is optional, and can be 0 if a particular RegisterContext does not\n  /// need to address its registers by byte offset.\n  uint32_t byte_offset;\n  /// Encoding of the register bits.\n  lldb::Encoding encoding;\n  /// Default display format.\n  lldb::Format format;\n  /// Holds all of the various register numbers for all register kinds.\n  uint32_t kinds[lldb::kNumRegisterKinds]; //\n  /// List of registers (terminated with LLDB_INVALID_REGNUM). If this value is\n  /// not null, all registers in this list will be read first, at which point\n  /// the value for this register will be valid. For example, the value list\n  /// for ah would be eax (x86) or rax (x64).\n  uint32_t *value_regs; //\n  /// List of registers (terminated with LLDB_INVALID_REGNUM). If this value is\n  /// not null, all registers in this list will be invalidated when the value of\n  /// this register changes. For example, the invalidate list for eax would be\n  /// rax ax, ah, and al.\n  uint32_t *invalidate_regs;\n  /// A DWARF expression that when evaluated gives the byte size of this\n  /// register.\n  const uint8_t *dynamic_size_dwarf_expr_bytes;\n  /// The length of the DWARF expression in bytes in the\n  /// dynamic_size_dwarf_expr_bytes member.\n  size_t dynamic_size_dwarf_len;\n\n  llvm::ArrayRef<uint8_t> data(const uint8_t *context_base) const {\n    return llvm::ArrayRef<uint8_t>(context_base + byte_offset, byte_size);\n  }\n\n  llvm::MutableArrayRef<uint8_t> mutable_data(uint8_t *context_base) const {\n    return llvm::MutableArrayRef<uint8_t>(context_base + byte_offset,\n                                          byte_size);\n  }\n};\n\n/// Registers are grouped into register sets\nstruct RegisterSet {\n  /// Name of this register set.\n  const char *name;\n  /// A short name for this register set.\n  const char *short_name;\n  /// The number of registers in REGISTERS array below.\n  size_t num_registers;\n  /// An array of register indices in this set. The values in this array are\n  /// *indices* (not register numbers) into a particular RegisterContext's\n  /// register array.  For example, if eax is defined at index 4 for a\n  /// particular RegisterContext, eax would be included in this RegisterSet by\n  /// adding the value 4.  Not by adding the value lldb_eax_i386.\n  const uint32_t *registers;\n};\n\nstruct OptionEnumValueElement {\n  int64_t value;\n  const char *string_value;\n  const char *usage;\n};\n\nusing OptionEnumValues = llvm::ArrayRef<OptionEnumValueElement>;\n\nstruct OptionValidator {\n  virtual ~OptionValidator() {}\n  virtual bool IsValid(Platform &platform,\n                       const ExecutionContext &target) const = 0;\n  virtual const char *ShortConditionString() const = 0;\n  virtual const char *LongConditionString() const = 0;\n};\n\ntypedef struct type128 { uint64_t x[2]; } type128;\ntypedef struct type256 { uint64_t x[4]; } type256;\n\n} // namespace lldb_private\n\n#endif // #if defined(__cplusplus)\n\n#endif // LLDB_LLDB_PRIVATE_TYPES_H\n"}, "48": {"id": 48, "path": "/home/vsts/work/1/llvm-project/lldb/source/Plugins/Language/CPlusPlus/LibCxxVariant.cpp", "content": "//===-- LibCxxVariant.cpp -------------------------------------------------===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#include \"LibCxxVariant.h\"\n#include \"lldb/DataFormatters/FormattersHelpers.h\"\n\n#include \"llvm/ADT/Optional.h\"\n#include \"llvm/ADT/ScopeExit.h\"\n\nusing namespace lldb;\nusing namespace lldb_private;\n\n// libc++ variant implementation contains two members that we care about both\n// are contained in the __impl member.\n// - __index which tells us which of the variadic template types is the active\n//   type for the variant\n// - __data is a variadic union which recursively contains itself as member\n//   which refers to the tailing variadic types.\n//   - __head which refers to the leading non pack type\n//     - __value refers to the actual value contained\n//   - __tail which refers to the remaining pack types\n//\n// e.g. given std::variant<int,double,char> v1\n//\n// (lldb) frame var -R v1.__impl.__data\n//(... __union<... 0, int, double, char>) v1.__impl.__data = {\n// ...\n//  __head = {\n//    __value = ...\n//  }\n//  __tail = {\n//  ...\n//    __head = {\n//      __value = ...\n//    }\n//    __tail = {\n//    ...\n//      __head = {\n//        __value = ...\n//  ...\n//\n// So given\n// - __index equal to 0 the active value is contained in\n//\n//     __data.__head.__value\n//\n// - __index equal to 1 the active value is contained in\n//\n//     __data.__tail.__head.__value\n//\n// - __index equal to 2 the active value is contained in\n//\n//      __data.__tail.__tail.__head.__value\n//\n\nnamespace {\n// libc++ std::variant index could have one of three states\n// 1) Valid, we can obtain it and its not variant_npos\n// 2) Invalid, we can't obtain it or it is not a type we expect\n// 3) NPos, its value is variant_npos which means the variant has no value\nenum class LibcxxVariantIndexValidity { Valid, Invalid, NPos };\n\nLibcxxVariantIndexValidity\nLibcxxVariantGetIndexValidity(ValueObjectSP &impl_sp) {\n  ValueObjectSP index_sp(\n      impl_sp->GetChildMemberWithName(ConstString(\"__index\"), true));\n\n  if (!index_sp)\n    return LibcxxVariantIndexValidity::Invalid;\n\n  int64_t index_value = index_sp->GetValueAsSigned(0);\n\n  if (index_value == -1)\n    return LibcxxVariantIndexValidity::NPos;\n\n  return LibcxxVariantIndexValidity::Valid;\n}\n\nllvm::Optional<uint64_t> LibcxxVariantIndexValue(ValueObjectSP &impl_sp) {\n  ValueObjectSP index_sp(\n      impl_sp->GetChildMemberWithName(ConstString(\"__index\"), true));\n\n  if (!index_sp)\n    return {};\n\n  return {index_sp->GetValueAsUnsigned(0)};\n}\n\nValueObjectSP LibcxxVariantGetNthHead(ValueObjectSP &impl_sp, uint64_t index) {\n  ValueObjectSP data_sp(\n      impl_sp->GetChildMemberWithName(ConstString(\"__data\"), true));\n\n  if (!data_sp)\n    return ValueObjectSP{};\n\n  ValueObjectSP current_level = data_sp;\n  for (uint64_t n = index; n != 0; --n) {\n    ValueObjectSP tail_sp(\n        current_level->GetChildMemberWithName(ConstString(\"__tail\"), true));\n\n    if (!tail_sp)\n      return ValueObjectSP{};\n\n    current_level = tail_sp;\n  }\n\n  return current_level->GetChildMemberWithName(ConstString(\"__head\"), true);\n}\n} // namespace\n\nnamespace lldb_private {\nnamespace formatters {\nbool LibcxxVariantSummaryProvider(ValueObject &valobj, Stream &stream,\n                                  const TypeSummaryOptions &options) {\n  ValueObjectSP valobj_sp(valobj.GetNonSyntheticValue());\n  if (!valobj_sp)\n    return false;\n\n  ValueObjectSP impl_sp(\n      valobj_sp->GetChildMemberWithName(ConstString(\"__impl\"), true));\n\n  if (!impl_sp)\n    return false;\n\n  LibcxxVariantIndexValidity validity = LibcxxVariantGetIndexValidity(impl_sp);\n\n  if (validity == LibcxxVariantIndexValidity::Invalid)\n    return false;\n\n  if (validity == LibcxxVariantIndexValidity::NPos) {\n    stream.Printf(\" No Value\");\n    return true;\n  }\n\n  auto optional_index_value = LibcxxVariantIndexValue(impl_sp);\n\n  if (!optional_index_value)\n    return false;\n\n  uint64_t index_value = *optional_index_value;\n\n  ValueObjectSP nth_head = LibcxxVariantGetNthHead(impl_sp, index_value);\n\n  if (!nth_head)\n    return false;\n\n  CompilerType head_type = nth_head->GetCompilerType();\n\n  if (!head_type)\n    return false;\n\n  CompilerType template_type = head_type.GetTypeTemplateArgument(1);\n\n  if (!template_type)\n    return false;\n\n  stream << \" Active Type = \" << template_type.GetDisplayTypeName() << \" \";\n\n  return true;\n}\n} // namespace formatters\n} // namespace lldb_private\n\nnamespace {\nclass VariantFrontEnd : public SyntheticChildrenFrontEnd {\npublic:\n  VariantFrontEnd(ValueObject &valobj) : SyntheticChildrenFrontEnd(valobj) {\n    Update();\n  }\n\n  size_t GetIndexOfChildWithName(ConstString name) override {\n    return formatters::ExtractIndexFromString(name.GetCString());\n  }\n\n  bool MightHaveChildren() override { return true; }\n  bool Update() override;\n  size_t CalculateNumChildren() override { return m_size; }\n  ValueObjectSP GetChildAtIndex(size_t idx) override;\n\nprivate:\n  size_t m_size = 0;\n};\n} // namespace\n\nbool VariantFrontEnd::Update() {\n  m_size = 0;\n  ValueObjectSP impl_sp(\n      m_backend.GetChildMemberWithName(ConstString(\"__impl\"), true));\n  if (!impl_sp)\n    return false;\n\n  LibcxxVariantIndexValidity validity = LibcxxVariantGetIndexValidity(impl_sp);\n\n  if (validity == LibcxxVariantIndexValidity::Invalid)\n    return false;\n\n  if (validity == LibcxxVariantIndexValidity::NPos)\n    return true;\n\n  m_size = 1;\n\n  return false;\n}\n\nValueObjectSP VariantFrontEnd::GetChildAtIndex(size_t idx) {\n  if (idx >= m_size)\n    return ValueObjectSP();\n\n  ValueObjectSP impl_sp(\n      m_backend.GetChildMemberWithName(ConstString(\"__impl\"), true));\n\n  auto optional_index_value = LibcxxVariantIndexValue(impl_sp);\n\n  if (!optional_index_value)\n    return ValueObjectSP();\n\n  uint64_t index_value = *optional_index_value;\n\n  ValueObjectSP nth_head = LibcxxVariantGetNthHead(impl_sp, index_value);\n\n  if (!nth_head)\n    return ValueObjectSP();\n\n  CompilerType head_type = nth_head->GetCompilerType();\n\n  if (!head_type)\n    return ValueObjectSP();\n\n  CompilerType template_type = head_type.GetTypeTemplateArgument(1);\n\n  if (!template_type)\n    return ValueObjectSP();\n\n  ValueObjectSP head_value(\n      nth_head->GetChildMemberWithName(ConstString(\"__value\"), true));\n\n  if (!head_value)\n    return ValueObjectSP();\n\n  return head_value->Clone(ConstString(\"Value\"));\n}\n\nSyntheticChildrenFrontEnd *\nformatters::LibcxxVariantFrontEndCreator(CXXSyntheticChildren *,\n                                         lldb::ValueObjectSP valobj_sp) {\n  if (valobj_sp)\n    return new VariantFrontEnd(*valobj_sp);\n  return nullptr;\n}\n"}, "54": {"id": 54, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/DenseMap.h", "content": "//===- llvm/ADT/DenseMap.h - Dense probed hash table ------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file defines the DenseMap class.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_ADT_DENSEMAP_H\n#define LLVM_ADT_DENSEMAP_H\n\n#include \"llvm/ADT/DenseMapInfo.h\"\n#include \"llvm/ADT/EpochTracker.h\"\n#include \"llvm/Support/AlignOf.h\"\n#include \"llvm/Support/Compiler.h\"\n#include \"llvm/Support/MathExtras.h\"\n#include \"llvm/Support/MemAlloc.h\"\n#include \"llvm/Support/ReverseIteration.h\"\n#include \"llvm/Support/type_traits.h\"\n#include <algorithm>\n#include <cassert>\n#include <cstddef>\n#include <cstring>\n#include <initializer_list>\n#include <iterator>\n#include <new>\n#include <type_traits>\n#include <utility>\n\nnamespace llvm {\n\nnamespace detail {\n\n// We extend a pair to allow users to override the bucket type with their own\n// implementation without requiring two members.\ntemplate <typename KeyT, typename ValueT>\nstruct DenseMapPair : public std::pair<KeyT, ValueT> {\n  using std::pair<KeyT, ValueT>::pair;\n\n  KeyT &getFirst() { return std::pair<KeyT, ValueT>::first; }\n  const KeyT &getFirst() const { return std::pair<KeyT, ValueT>::first; }\n  ValueT &getSecond() { return std::pair<KeyT, ValueT>::second; }\n  const ValueT &getSecond() const { return std::pair<KeyT, ValueT>::second; }\n};\n\n} // end namespace detail\n\ntemplate <typename KeyT, typename ValueT,\n          typename KeyInfoT = DenseMapInfo<KeyT>,\n          typename Bucket = llvm::detail::DenseMapPair<KeyT, ValueT>,\n          bool IsConst = false>\nclass DenseMapIterator;\n\ntemplate <typename DerivedT, typename KeyT, typename ValueT, typename KeyInfoT,\n          typename BucketT>\nclass DenseMapBase : public DebugEpochBase {\n  template <typename T>\n  using const_arg_type_t = typename const_pointer_or_const_ref<T>::type;\n\npublic:\n  using size_type = unsigned;\n  using key_type = KeyT;\n  using mapped_type = ValueT;\n  using value_type = BucketT;\n\n  using iterator = DenseMapIterator<KeyT, ValueT, KeyInfoT, BucketT>;\n  using const_iterator =\n      DenseMapIterator<KeyT, ValueT, KeyInfoT, BucketT, true>;\n\n  inline iterator begin() {\n    // When the map is empty, avoid the overhead of advancing/retreating past\n    // empty buckets.\n    if (empty())\n      return end();\n    if (shouldReverseIterate<KeyT>())\n      return makeIterator(getBucketsEnd() - 1, getBuckets(), *this);\n    return makeIterator(getBuckets(), getBucketsEnd(), *this);\n  }\n  inline iterator end() {\n    return makeIterator(getBucketsEnd(), getBucketsEnd(), *this, true);\n  }\n  inline const_iterator begin() const {\n    if (empty())\n      return end();\n    if (shouldReverseIterate<KeyT>())\n      return makeConstIterator(getBucketsEnd() - 1, getBuckets(), *this);\n    return makeConstIterator(getBuckets(), getBucketsEnd(), *this);\n  }\n  inline const_iterator end() const {\n    return makeConstIterator(getBucketsEnd(), getBucketsEnd(), *this, true);\n  }\n\n  LLVM_NODISCARD bool empty() const {\n    return getNumEntries() == 0;\n  }\n  unsigned size() const { return getNumEntries(); }\n\n  /// Grow the densemap so that it can contain at least \\p NumEntries items\n  /// before resizing again.\n  void reserve(size_type NumEntries) {\n    auto NumBuckets = getMinBucketToReserveForEntries(NumEntries);\n    incrementEpoch();\n    if (NumBuckets > getNumBuckets())\n      grow(NumBuckets);\n  }\n\n  void clear() {\n    incrementEpoch();\n    if (getNumEntries() == 0 && getNumTombstones() == 0) return;\n\n    // If the capacity of the array is huge, and the # elements used is small,\n    // shrink the array.\n    if (getNumEntries() * 4 < getNumBuckets() && getNumBuckets() > 64) {\n      shrink_and_clear();\n      return;\n    }\n\n    const KeyT EmptyKey = getEmptyKey(), TombstoneKey = getTombstoneKey();\n    if (std::is_trivially_destructible<ValueT>::value) {\n      // Use a simpler loop when values don't need destruction.\n      for (BucketT *P = getBuckets(), *E = getBucketsEnd(); P != E; ++P)\n        P->getFirst() = EmptyKey;\n    } else {\n      unsigned NumEntries = getNumEntries();\n      for (BucketT *P = getBuckets(), *E = getBucketsEnd(); P != E; ++P) {\n        if (!KeyInfoT::isEqual(P->getFirst(), EmptyKey)) {\n          if (!KeyInfoT::isEqual(P->getFirst(), TombstoneKey)) {\n            P->getSecond().~ValueT();\n            --NumEntries;\n          }\n          P->getFirst() = EmptyKey;\n        }\n      }\n      assert(NumEntries == 0 && \"Node count imbalance!\");\n    }\n    setNumEntries(0);\n    setNumTombstones(0);\n  }\n\n  /// Return 1 if the specified key is in the map, 0 otherwise.\n  size_type count(const_arg_type_t<KeyT> Val) const {\n    const BucketT *TheBucket;\n    return LookupBucketFor(Val, TheBucket) ? 1 : 0;\n  }\n\n  iterator find(const_arg_type_t<KeyT> Val) {\n    BucketT *TheBucket;\n    if (LookupBucketFor(Val, TheBucket))\n      return makeIterator(TheBucket,\n                          shouldReverseIterate<KeyT>() ? getBuckets()\n                                                       : getBucketsEnd(),\n                          *this, true);\n    return end();\n  }\n  const_iterator find(const_arg_type_t<KeyT> Val) const {\n    const BucketT *TheBucket;\n    if (LookupBucketFor(Val, TheBucket))\n      return makeConstIterator(TheBucket,\n                               shouldReverseIterate<KeyT>() ? getBuckets()\n                                                            : getBucketsEnd(),\n                               *this, true);\n    return end();\n  }\n\n  /// Alternate version of find() which allows a different, and possibly\n  /// less expensive, key type.\n  /// The DenseMapInfo is responsible for supplying methods\n  /// getHashValue(LookupKeyT) and isEqual(LookupKeyT, KeyT) for each key\n  /// type used.\n  template<class LookupKeyT>\n  iterator find_as(const LookupKeyT &Val) {\n    BucketT *TheBucket;\n    if (LookupBucketFor(Val, TheBucket))\n      return makeIterator(TheBucket,\n                          shouldReverseIterate<KeyT>() ? getBuckets()\n                                                       : getBucketsEnd(),\n                          *this, true);\n    return end();\n  }\n  template<class LookupKeyT>\n  const_iterator find_as(const LookupKeyT &Val) const {\n    const BucketT *TheBucket;\n    if (LookupBucketFor(Val, TheBucket))\n      return makeConstIterator(TheBucket,\n                               shouldReverseIterate<KeyT>() ? getBuckets()\n                                                            : getBucketsEnd(),\n                               *this, true);\n    return end();\n  }\n\n  /// lookup - Return the entry for the specified key, or a default\n  /// constructed value if no such entry exists.\n  ValueT lookup(const_arg_type_t<KeyT> Val) const {\n    const BucketT *TheBucket;\n    if (LookupBucketFor(Val, TheBucket))\n      return TheBucket->getSecond();\n    return ValueT();\n  }\n\n  // Inserts key,value pair into the map if the key isn't already in the map.\n  // If the key is already in the map, it returns false and doesn't update the\n  // value.\n  std::pair<iterator, bool> insert(const std::pair<KeyT, ValueT> &KV) {\n    return try_emplace(KV.first, KV.second);\n  }\n\n  // Inserts key,value pair into the map if the key isn't already in the map.\n  // If the key is already in the map, it returns false and doesn't update the\n  // value.\n  std::pair<iterator, bool> insert(std::pair<KeyT, ValueT> &&KV) {\n    return try_emplace(std::move(KV.first), std::move(KV.second));\n  }\n\n  // Inserts key,value pair into the map if the key isn't already in the map.\n  // The value is constructed in-place if the key is not in the map, otherwise\n  // it is not moved.\n  template <typename... Ts>\n  std::pair<iterator, bool> try_emplace(KeyT &&Key, Ts &&... Args) {\n    BucketT *TheBucket;\n    if (LookupBucketFor(Key, TheBucket))\n      return std::make_pair(makeIterator(TheBucket,\n                                         shouldReverseIterate<KeyT>()\n                                             ? getBuckets()\n                                             : getBucketsEnd(),\n                                         *this, true),\n                            false); // Already in map.\n\n    // Otherwise, insert the new element.\n    TheBucket =\n        InsertIntoBucket(TheBucket, std::move(Key), std::forward<Ts>(Args)...);\n    return std::make_pair(makeIterator(TheBucket,\n                                       shouldReverseIterate<KeyT>()\n                                           ? getBuckets()\n                                           : getBucketsEnd(),\n                                       *this, true),\n                          true);\n  }\n\n  // Inserts key,value pair into the map if the key isn't already in the map.\n  // The value is constructed in-place if the key is not in the map, otherwise\n  // it is not moved.\n  template <typename... Ts>\n  std::pair<iterator, bool> try_emplace(const KeyT &Key, Ts &&... Args) {\n    BucketT *TheBucket;\n    if (LookupBucketFor(Key, TheBucket))\n      return std::make_pair(makeIterator(TheBucket,\n                                         shouldReverseIterate<KeyT>()\n                                             ? getBuckets()\n                                             : getBucketsEnd(),\n                                         *this, true),\n                            false); // Already in map.\n\n    // Otherwise, insert the new element.\n    TheBucket = InsertIntoBucket(TheBucket, Key, std::forward<Ts>(Args)...);\n    return std::make_pair(makeIterator(TheBucket,\n                                       shouldReverseIterate<KeyT>()\n                                           ? getBuckets()\n                                           : getBucketsEnd(),\n                                       *this, true),\n                          true);\n  }\n\n  /// Alternate version of insert() which allows a different, and possibly\n  /// less expensive, key type.\n  /// The DenseMapInfo is responsible for supplying methods\n  /// getHashValue(LookupKeyT) and isEqual(LookupKeyT, KeyT) for each key\n  /// type used.\n  template <typename LookupKeyT>\n  std::pair<iterator, bool> insert_as(std::pair<KeyT, ValueT> &&KV,\n                                      const LookupKeyT &Val) {\n    BucketT *TheBucket;\n    if (LookupBucketFor(Val, TheBucket))\n      return std::make_pair(makeIterator(TheBucket,\n                                         shouldReverseIterate<KeyT>()\n                                             ? getBuckets()\n                                             : getBucketsEnd(),\n                                         *this, true),\n                            false); // Already in map.\n\n    // Otherwise, insert the new element.\n    TheBucket = InsertIntoBucketWithLookup(TheBucket, std::move(KV.first),\n                                           std::move(KV.second), Val);\n    return std::make_pair(makeIterator(TheBucket,\n                                       shouldReverseIterate<KeyT>()\n                                           ? getBuckets()\n                                           : getBucketsEnd(),\n                                       *this, true),\n                          true);\n  }\n\n  /// insert - Range insertion of pairs.\n  template<typename InputIt>\n  void insert(InputIt I, InputIt E) {\n    for (; I != E; ++I)\n      insert(*I);\n  }\n\n  bool erase(const KeyT &Val) {\n    BucketT *TheBucket;\n    if (!LookupBucketFor(Val, TheBucket))\n      return false; // not in map.\n\n    TheBucket->getSecond().~ValueT();\n    TheBucket->getFirst() = getTombstoneKey();\n    decrementNumEntries();\n    incrementNumTombstones();\n    return true;\n  }\n  void erase(iterator I) {\n    BucketT *TheBucket = &*I;\n    TheBucket->getSecond().~ValueT();\n    TheBucket->getFirst() = getTombstoneKey();\n    decrementNumEntries();\n    incrementNumTombstones();\n  }\n\n  value_type& FindAndConstruct(const KeyT &Key) {\n    BucketT *TheBucket;\n    if (LookupBucketFor(Key, TheBucket))\n      return *TheBucket;\n\n    return *InsertIntoBucket(TheBucket, Key);\n  }\n\n  ValueT &operator[](const KeyT &Key) {\n    return FindAndConstruct(Key).second;\n  }\n\n  value_type& FindAndConstruct(KeyT &&Key) {\n    BucketT *TheBucket;\n    if (LookupBucketFor(Key, TheBucket))\n      return *TheBucket;\n\n    return *InsertIntoBucket(TheBucket, std::move(Key));\n  }\n\n  ValueT &operator[](KeyT &&Key) {\n    return FindAndConstruct(std::move(Key)).second;\n  }\n\n  /// isPointerIntoBucketsArray - Return true if the specified pointer points\n  /// somewhere into the DenseMap's array of buckets (i.e. either to a key or\n  /// value in the DenseMap).\n  bool isPointerIntoBucketsArray(const void *Ptr) const {\n    return Ptr >= getBuckets() && Ptr < getBucketsEnd();\n  }\n\n  /// getPointerIntoBucketsArray() - Return an opaque pointer into the buckets\n  /// array.  In conjunction with the previous method, this can be used to\n  /// determine whether an insertion caused the DenseMap to reallocate.\n  const void *getPointerIntoBucketsArray() const { return getBuckets(); }\n\nprotected:\n  DenseMapBase() = default;\n\n  void destroyAll() {\n    if (getNumBuckets() == 0) // Nothing to do.\n      return;\n\n    const KeyT EmptyKey = getEmptyKey(), TombstoneKey = getTombstoneKey();\n    for (BucketT *P = getBuckets(), *E = getBucketsEnd(); P != E; ++P) {\n      if (!KeyInfoT::isEqual(P->getFirst(), EmptyKey) &&\n          !KeyInfoT::isEqual(P->getFirst(), TombstoneKey))\n        P->getSecond().~ValueT();\n      P->getFirst().~KeyT();\n    }\n  }\n\n  void initEmpty() {\n    setNumEntries(0);\n    setNumTombstones(0);\n\n    assert((getNumBuckets() & (getNumBuckets()-1)) == 0 &&\n           \"# initial buckets must be a power of two!\");\n    const KeyT EmptyKey = getEmptyKey();\n    for (BucketT *B = getBuckets(), *E = getBucketsEnd(); B != E; ++B)\n      ::new (&B->getFirst()) KeyT(EmptyKey);\n  }\n\n  /// Returns the number of buckets to allocate to ensure that the DenseMap can\n  /// accommodate \\p NumEntries without need to grow().\n  unsigned getMinBucketToReserveForEntries(unsigned NumEntries) {\n    // Ensure that \"NumEntries * 4 < NumBuckets * 3\"\n    if (NumEntries == 0)\n      return 0;\n    // +1 is required because of the strict equality.\n    // For example if NumEntries is 48, we need to return 401.\n    return NextPowerOf2(NumEntries * 4 / 3 + 1);\n  }\n\n  void moveFromOldBuckets(BucketT *OldBucketsBegin, BucketT *OldBucketsEnd) {\n    initEmpty();\n\n    // Insert all the old elements.\n    const KeyT EmptyKey = getEmptyKey();\n    const KeyT TombstoneKey = getTombstoneKey();\n    for (BucketT *B = OldBucketsBegin, *E = OldBucketsEnd; B != E; ++B) {\n      if (!KeyInfoT::isEqual(B->getFirst(), EmptyKey) &&\n          !KeyInfoT::isEqual(B->getFirst(), TombstoneKey)) {\n        // Insert the key/value into the new table.\n        BucketT *DestBucket;\n        bool FoundVal = LookupBucketFor(B->getFirst(), DestBucket);\n        (void)FoundVal; // silence warning.\n        assert(!FoundVal && \"Key already in new map?\");\n        DestBucket->getFirst() = std::move(B->getFirst());\n        ::new (&DestBucket->getSecond()) ValueT(std::move(B->getSecond()));\n        incrementNumEntries();\n\n        // Free the value.\n        B->getSecond().~ValueT();\n      }\n      B->getFirst().~KeyT();\n    }\n  }\n\n  template <typename OtherBaseT>\n  void copyFrom(\n      const DenseMapBase<OtherBaseT, KeyT, ValueT, KeyInfoT, BucketT> &other) {\n    assert(&other != this);\n    assert(getNumBuckets() == other.getNumBuckets());\n\n    setNumEntries(other.getNumEntries());\n    setNumTombstones(other.getNumTombstones());\n\n    if (std::is_trivially_copyable<KeyT>::value &&\n        std::is_trivially_copyable<ValueT>::value)\n      memcpy(reinterpret_cast<void *>(getBuckets()), other.getBuckets(),\n             getNumBuckets() * sizeof(BucketT));\n    else\n      for (size_t i = 0; i < getNumBuckets(); ++i) {\n        ::new (&getBuckets()[i].getFirst())\n            KeyT(other.getBuckets()[i].getFirst());\n        if (!KeyInfoT::isEqual(getBuckets()[i].getFirst(), getEmptyKey()) &&\n            !KeyInfoT::isEqual(getBuckets()[i].getFirst(), getTombstoneKey()))\n          ::new (&getBuckets()[i].getSecond())\n              ValueT(other.getBuckets()[i].getSecond());\n      }\n  }\n\n  static unsigned getHashValue(const KeyT &Val) {\n    return KeyInfoT::getHashValue(Val);\n  }\n\n  template<typename LookupKeyT>\n  static unsigned getHashValue(const LookupKeyT &Val) {\n    return KeyInfoT::getHashValue(Val);\n  }\n\n  static const KeyT getEmptyKey() {\n    static_assert(std::is_base_of<DenseMapBase, DerivedT>::value,\n                  \"Must pass the derived type to this template!\");\n    return KeyInfoT::getEmptyKey();\n  }\n\n  static const KeyT getTombstoneKey() {\n    return KeyInfoT::getTombstoneKey();\n  }\n\nprivate:\n  iterator makeIterator(BucketT *P, BucketT *E,\n                        DebugEpochBase &Epoch,\n                        bool NoAdvance=false) {\n    if (shouldReverseIterate<KeyT>()) {\n      BucketT *B = P == getBucketsEnd() ? getBuckets() : P + 1;\n      return iterator(B, E, Epoch, NoAdvance);\n    }\n    return iterator(P, E, Epoch, NoAdvance);\n  }\n\n  const_iterator makeConstIterator(const BucketT *P, const BucketT *E,\n                                   const DebugEpochBase &Epoch,\n                                   const bool NoAdvance=false) const {\n    if (shouldReverseIterate<KeyT>()) {\n      const BucketT *B = P == getBucketsEnd() ? getBuckets() : P + 1;\n      return const_iterator(B, E, Epoch, NoAdvance);\n    }\n    return const_iterator(P, E, Epoch, NoAdvance);\n  }\n\n  unsigned getNumEntries() const {\n    return static_cast<const DerivedT *>(this)->getNumEntries();\n  }\n\n  void setNumEntries(unsigned Num) {\n    static_cast<DerivedT *>(this)->setNumEntries(Num);\n  }\n\n  void incrementNumEntries() {\n    setNumEntries(getNumEntries() + 1);\n  }\n\n  void decrementNumEntries() {\n    setNumEntries(getNumEntries() - 1);\n  }\n\n  unsigned getNumTombstones() const {\n    return static_cast<const DerivedT *>(this)->getNumTombstones();\n  }\n\n  void setNumTombstones(unsigned Num) {\n    static_cast<DerivedT *>(this)->setNumTombstones(Num);\n  }\n\n  void incrementNumTombstones() {\n    setNumTombstones(getNumTombstones() + 1);\n  }\n\n  void decrementNumTombstones() {\n    setNumTombstones(getNumTombstones() - 1);\n  }\n\n  const BucketT *getBuckets() const {\n    return static_cast<const DerivedT *>(this)->getBuckets();\n  }\n\n  BucketT *getBuckets() {\n    return static_cast<DerivedT *>(this)->getBuckets();\n  }\n\n  unsigned getNumBuckets() const {\n    return static_cast<const DerivedT *>(this)->getNumBuckets();\n  }\n\n  BucketT *getBucketsEnd() {\n    return getBuckets() + getNumBuckets();\n  }\n\n  const BucketT *getBucketsEnd() const {\n    return getBuckets() + getNumBuckets();\n  }\n\n  void grow(unsigned AtLeast) {\n    static_cast<DerivedT *>(this)->grow(AtLeast);\n  }\n\n  void shrink_and_clear() {\n    static_cast<DerivedT *>(this)->shrink_and_clear();\n  }\n\n  template <typename KeyArg, typename... ValueArgs>\n  BucketT *InsertIntoBucket(BucketT *TheBucket, KeyArg &&Key,\n                            ValueArgs &&... Values) {\n    TheBucket = InsertIntoBucketImpl(Key, Key, TheBucket);\n\n    TheBucket->getFirst() = std::forward<KeyArg>(Key);\n    ::new (&TheBucket->getSecond()) ValueT(std::forward<ValueArgs>(Values)...);\n    return TheBucket;\n  }\n\n  template <typename LookupKeyT>\n  BucketT *InsertIntoBucketWithLookup(BucketT *TheBucket, KeyT &&Key,\n                                      ValueT &&Value, LookupKeyT &Lookup) {\n    TheBucket = InsertIntoBucketImpl(Key, Lookup, TheBucket);\n\n    TheBucket->getFirst() = std::move(Key);\n    ::new (&TheBucket->getSecond()) ValueT(std::move(Value));\n    return TheBucket;\n  }\n\n  template <typename LookupKeyT>\n  BucketT *InsertIntoBucketImpl(const KeyT &Key, const LookupKeyT &Lookup,\n                                BucketT *TheBucket) {\n    incrementEpoch();\n\n    // If the load of the hash table is more than 3/4, or if fewer than 1/8 of\n    // the buckets are empty (meaning that many are filled with tombstones),\n    // grow the table.\n    //\n    // The later case is tricky.  For example, if we had one empty bucket with\n    // tons of tombstones, failing lookups (e.g. for insertion) would have to\n    // probe almost the entire table until it found the empty bucket.  If the\n    // table completely filled with tombstones, no lookup would ever succeed,\n    // causing infinite loops in lookup.\n    unsigned NewNumEntries = getNumEntries() + 1;\n    unsigned NumBuckets = getNumBuckets();\n    if (LLVM_UNLIKELY(NewNumEntries * 4 >= NumBuckets * 3)) {\n      this->grow(NumBuckets * 2);\n      LookupBucketFor(Lookup, TheBucket);\n      NumBuckets = getNumBuckets();\n    } else if (LLVM_UNLIKELY(NumBuckets-(NewNumEntries+getNumTombstones()) <=\n                             NumBuckets/8)) {\n      this->grow(NumBuckets);\n      LookupBucketFor(Lookup, TheBucket);\n    }\n    assert(TheBucket);\n\n    // Only update the state after we've grown our bucket space appropriately\n    // so that when growing buckets we have self-consistent entry count.\n    incrementNumEntries();\n\n    // If we are writing over a tombstone, remember this.\n    const KeyT EmptyKey = getEmptyKey();\n    if (!KeyInfoT::isEqual(TheBucket->getFirst(), EmptyKey))\n      decrementNumTombstones();\n\n    return TheBucket;\n  }\n\n  /// LookupBucketFor - Lookup the appropriate bucket for Val, returning it in\n  /// FoundBucket.  If the bucket contains the key and a value, this returns\n  /// true, otherwise it returns a bucket with an empty marker or tombstone and\n  /// returns false.\n  template<typename LookupKeyT>\n  bool LookupBucketFor(const LookupKeyT &Val,\n                       const BucketT *&FoundBucket) const {\n    const BucketT *BucketsPtr = getBuckets();\n    const unsigned NumBuckets = getNumBuckets();\n\n    if (NumBuckets == 0) {\n      FoundBucket = nullptr;\n      return false;\n    }\n\n    // FoundTombstone - Keep track of whether we find a tombstone while probing.\n    const BucketT *FoundTombstone = nullptr;\n    const KeyT EmptyKey = getEmptyKey();\n    const KeyT TombstoneKey = getTombstoneKey();\n    assert(!KeyInfoT::isEqual(Val, EmptyKey) &&\n           !KeyInfoT::isEqual(Val, TombstoneKey) &&\n           \"Empty/Tombstone value shouldn't be inserted into map!\");\n\n    unsigned BucketNo = getHashValue(Val) & (NumBuckets-1);\n    unsigned ProbeAmt = 1;\n    while (true) {\n      const BucketT *ThisBucket = BucketsPtr + BucketNo;\n      // Found Val's bucket?  If so, return it.\n      if (LLVM_LIKELY(KeyInfoT::isEqual(Val, ThisBucket->getFirst()))) {\n        FoundBucket = ThisBucket;\n        return true;\n      }\n\n      // If we found an empty bucket, the key doesn't exist in the set.\n      // Insert it and return the default value.\n      if (LLVM_LIKELY(KeyInfoT::isEqual(ThisBucket->getFirst(), EmptyKey))) {\n        // If we've already seen a tombstone while probing, fill it in instead\n        // of the empty bucket we eventually probed to.\n        FoundBucket = FoundTombstone ? FoundTombstone : ThisBucket;\n        return false;\n      }\n\n      // If this is a tombstone, remember it.  If Val ends up not in the map, we\n      // prefer to return it than something that would require more probing.\n      if (KeyInfoT::isEqual(ThisBucket->getFirst(), TombstoneKey) &&\n          !FoundTombstone)\n        FoundTombstone = ThisBucket;  // Remember the first tombstone found.\n\n      // Otherwise, it's a hash collision or a tombstone, continue quadratic\n      // probing.\n      BucketNo += ProbeAmt++;\n      BucketNo &= (NumBuckets-1);\n    }\n  }\n\n  template <typename LookupKeyT>\n  bool LookupBucketFor(const LookupKeyT &Val, BucketT *&FoundBucket) {\n    const BucketT *ConstFoundBucket;\n    bool Result = const_cast<const DenseMapBase *>(this)\n      ->LookupBucketFor(Val, ConstFoundBucket);\n    FoundBucket = const_cast<BucketT *>(ConstFoundBucket);\n    return Result;\n  }\n\npublic:\n  /// Return the approximate size (in bytes) of the actual map.\n  /// This is just the raw memory used by DenseMap.\n  /// If entries are pointers to objects, the size of the referenced objects\n  /// are not included.\n  size_t getMemorySize() const {\n    return getNumBuckets() * sizeof(BucketT);\n  }\n};\n\n/// Equality comparison for DenseMap.\n///\n/// Iterates over elements of LHS confirming that each (key, value) pair in LHS\n/// is also in RHS, and that no additional pairs are in RHS.\n/// Equivalent to N calls to RHS.find and N value comparisons. Amortized\n/// complexity is linear, worst case is O(N^2) (if every hash collides).\ntemplate <typename DerivedT, typename KeyT, typename ValueT, typename KeyInfoT,\n          typename BucketT>\nbool operator==(\n    const DenseMapBase<DerivedT, KeyT, ValueT, KeyInfoT, BucketT> &LHS,\n    const DenseMapBase<DerivedT, KeyT, ValueT, KeyInfoT, BucketT> &RHS) {\n  if (LHS.size() != RHS.size())\n    return false;\n\n  for (auto &KV : LHS) {\n    auto I = RHS.find(KV.first);\n    if (I == RHS.end() || I->second != KV.second)\n      return false;\n  }\n\n  return true;\n}\n\n/// Inequality comparison for DenseMap.\n///\n/// Equivalent to !(LHS == RHS). See operator== for performance notes.\ntemplate <typename DerivedT, typename KeyT, typename ValueT, typename KeyInfoT,\n          typename BucketT>\nbool operator!=(\n    const DenseMapBase<DerivedT, KeyT, ValueT, KeyInfoT, BucketT> &LHS,\n    const DenseMapBase<DerivedT, KeyT, ValueT, KeyInfoT, BucketT> &RHS) {\n  return !(LHS == RHS);\n}\n\ntemplate <typename KeyT, typename ValueT,\n          typename KeyInfoT = DenseMapInfo<KeyT>,\n          typename BucketT = llvm::detail::DenseMapPair<KeyT, ValueT>>\nclass DenseMap : public DenseMapBase<DenseMap<KeyT, ValueT, KeyInfoT, BucketT>,\n                                     KeyT, ValueT, KeyInfoT, BucketT> {\n  friend class DenseMapBase<DenseMap, KeyT, ValueT, KeyInfoT, BucketT>;\n\n  // Lift some types from the dependent base class into this class for\n  // simplicity of referring to them.\n  using BaseT = DenseMapBase<DenseMap, KeyT, ValueT, KeyInfoT, BucketT>;\n\n  BucketT *Buckets;\n  unsigned NumEntries;\n  unsigned NumTombstones;\n  unsigned NumBuckets;\n\npublic:\n  /// Create a DenseMap with an optional \\p InitialReserve that guarantee that\n  /// this number of elements can be inserted in the map without grow()\n  explicit DenseMap(unsigned InitialReserve = 0) { init(InitialReserve); }\n\n  DenseMap(const DenseMap &other) : BaseT() {\n    init(0);\n    copyFrom(other);\n  }\n\n  DenseMap(DenseMap &&other) : BaseT() {\n    init(0);\n    swap(other);\n  }\n\n  template<typename InputIt>\n  DenseMap(const InputIt &I, const InputIt &E) {\n    init(std::distance(I, E));\n    this->insert(I, E);\n  }\n\n  DenseMap(std::initializer_list<typename BaseT::value_type> Vals) {\n    init(Vals.size());\n    this->insert(Vals.begin(), Vals.end());\n  }\n\n  ~DenseMap() {\n    this->destroyAll();\n    deallocate_buffer(Buckets, sizeof(BucketT) * NumBuckets, alignof(BucketT));\n  }\n\n  void swap(DenseMap& RHS) {\n    this->incrementEpoch();\n    RHS.incrementEpoch();\n    std::swap(Buckets, RHS.Buckets);\n    std::swap(NumEntries, RHS.NumEntries);\n    std::swap(NumTombstones, RHS.NumTombstones);\n    std::swap(NumBuckets, RHS.NumBuckets);\n  }\n\n  DenseMap& operator=(const DenseMap& other) {\n    if (&other != this)\n      copyFrom(other);\n    return *this;\n  }\n\n  DenseMap& operator=(DenseMap &&other) {\n    this->destroyAll();\n    deallocate_buffer(Buckets, sizeof(BucketT) * NumBuckets, alignof(BucketT));\n    init(0);\n    swap(other);\n    return *this;\n  }\n\n  void copyFrom(const DenseMap& other) {\n    this->destroyAll();\n    deallocate_buffer(Buckets, sizeof(BucketT) * NumBuckets, alignof(BucketT));\n    if (allocateBuckets(other.NumBuckets)) {\n      this->BaseT::copyFrom(other);\n    } else {\n      NumEntries = 0;\n      NumTombstones = 0;\n    }\n  }\n\n  void init(unsigned InitNumEntries) {\n    auto InitBuckets = BaseT::getMinBucketToReserveForEntries(InitNumEntries);\n    if (allocateBuckets(InitBuckets)) {\n      this->BaseT::initEmpty();\n    } else {\n      NumEntries = 0;\n      NumTombstones = 0;\n    }\n  }\n\n  void grow(unsigned AtLeast) {\n    unsigned OldNumBuckets = NumBuckets;\n    BucketT *OldBuckets = Buckets;\n\n    allocateBuckets(std::max<unsigned>(64, static_cast<unsigned>(NextPowerOf2(AtLeast-1))));\n    assert(Buckets);\n    if (!OldBuckets) {\n      this->BaseT::initEmpty();\n      return;\n    }\n\n    this->moveFromOldBuckets(OldBuckets, OldBuckets+OldNumBuckets);\n\n    // Free the old table.\n    deallocate_buffer(OldBuckets, sizeof(BucketT) * OldNumBuckets,\n                      alignof(BucketT));\n  }\n\n  void shrink_and_clear() {\n    unsigned OldNumBuckets = NumBuckets;\n    unsigned OldNumEntries = NumEntries;\n    this->destroyAll();\n\n    // Reduce the number of buckets.\n    unsigned NewNumBuckets = 0;\n    if (OldNumEntries)\n      NewNumBuckets = std::max(64, 1 << (Log2_32_Ceil(OldNumEntries) + 1));\n    if (NewNumBuckets == NumBuckets) {\n      this->BaseT::initEmpty();\n      return;\n    }\n\n    deallocate_buffer(Buckets, sizeof(BucketT) * OldNumBuckets,\n                      alignof(BucketT));\n    init(NewNumBuckets);\n  }\n\nprivate:\n  unsigned getNumEntries() const {\n    return NumEntries;\n  }\n\n  void setNumEntries(unsigned Num) {\n    NumEntries = Num;\n  }\n\n  unsigned getNumTombstones() const {\n    return NumTombstones;\n  }\n\n  void setNumTombstones(unsigned Num) {\n    NumTombstones = Num;\n  }\n\n  BucketT *getBuckets() const {\n    return Buckets;\n  }\n\n  unsigned getNumBuckets() const {\n    return NumBuckets;\n  }\n\n  bool allocateBuckets(unsigned Num) {\n    NumBuckets = Num;\n    if (NumBuckets == 0) {\n      Buckets = nullptr;\n      return false;\n    }\n\n    Buckets = static_cast<BucketT *>(\n        allocate_buffer(sizeof(BucketT) * NumBuckets, alignof(BucketT)));\n    return true;\n  }\n};\n\ntemplate <typename KeyT, typename ValueT, unsigned InlineBuckets = 4,\n          typename KeyInfoT = DenseMapInfo<KeyT>,\n          typename BucketT = llvm::detail::DenseMapPair<KeyT, ValueT>>\nclass SmallDenseMap\n    : public DenseMapBase<\n          SmallDenseMap<KeyT, ValueT, InlineBuckets, KeyInfoT, BucketT>, KeyT,\n          ValueT, KeyInfoT, BucketT> {\n  friend class DenseMapBase<SmallDenseMap, KeyT, ValueT, KeyInfoT, BucketT>;\n\n  // Lift some types from the dependent base class into this class for\n  // simplicity of referring to them.\n  using BaseT = DenseMapBase<SmallDenseMap, KeyT, ValueT, KeyInfoT, BucketT>;\n\n  static_assert(isPowerOf2_64(InlineBuckets),\n                \"InlineBuckets must be a power of 2.\");\n\n  unsigned Small : 1;\n  unsigned NumEntries : 31;\n  unsigned NumTombstones;\n\n  struct LargeRep {\n    BucketT *Buckets;\n    unsigned NumBuckets;\n  };\n\n  /// A \"union\" of an inline bucket array and the struct representing\n  /// a large bucket. This union will be discriminated by the 'Small' bit.\n  AlignedCharArrayUnion<BucketT[InlineBuckets], LargeRep> storage;\n\npublic:\n  explicit SmallDenseMap(unsigned NumInitBuckets = 0) {\n    init(NumInitBuckets);\n  }\n\n  SmallDenseMap(const SmallDenseMap &other) : BaseT() {\n    init(0);\n    copyFrom(other);\n  }\n\n  SmallDenseMap(SmallDenseMap &&other) : BaseT() {\n    init(0);\n    swap(other);\n  }\n\n  template<typename InputIt>\n  SmallDenseMap(const InputIt &I, const InputIt &E) {\n    init(NextPowerOf2(std::distance(I, E)));\n    this->insert(I, E);\n  }\n\n  ~SmallDenseMap() {\n    this->destroyAll();\n    deallocateBuckets();\n  }\n\n  void swap(SmallDenseMap& RHS) {\n    unsigned TmpNumEntries = RHS.NumEntries;\n    RHS.NumEntries = NumEntries;\n    NumEntries = TmpNumEntries;\n    std::swap(NumTombstones, RHS.NumTombstones);\n\n    const KeyT EmptyKey = this->getEmptyKey();\n    const KeyT TombstoneKey = this->getTombstoneKey();\n    if (Small && RHS.Small) {\n      // If we're swapping inline bucket arrays, we have to cope with some of\n      // the tricky bits of DenseMap's storage system: the buckets are not\n      // fully initialized. Thus we swap every key, but we may have\n      // a one-directional move of the value.\n      for (unsigned i = 0, e = InlineBuckets; i != e; ++i) {\n        BucketT *LHSB = &getInlineBuckets()[i],\n                *RHSB = &RHS.getInlineBuckets()[i];\n        bool hasLHSValue = (!KeyInfoT::isEqual(LHSB->getFirst(), EmptyKey) &&\n                            !KeyInfoT::isEqual(LHSB->getFirst(), TombstoneKey));\n        bool hasRHSValue = (!KeyInfoT::isEqual(RHSB->getFirst(), EmptyKey) &&\n                            !KeyInfoT::isEqual(RHSB->getFirst(), TombstoneKey));\n        if (hasLHSValue && hasRHSValue) {\n          // Swap together if we can...\n          std::swap(*LHSB, *RHSB);\n          continue;\n        }\n        // Swap separately and handle any asymmetry.\n        std::swap(LHSB->getFirst(), RHSB->getFirst());\n        if (hasLHSValue) {\n          ::new (&RHSB->getSecond()) ValueT(std::move(LHSB->getSecond()));\n          LHSB->getSecond().~ValueT();\n        } else if (hasRHSValue) {\n          ::new (&LHSB->getSecond()) ValueT(std::move(RHSB->getSecond()));\n          RHSB->getSecond().~ValueT();\n        }\n      }\n      return;\n    }\n    if (!Small && !RHS.Small) {\n      std::swap(getLargeRep()->Buckets, RHS.getLargeRep()->Buckets);\n      std::swap(getLargeRep()->NumBuckets, RHS.getLargeRep()->NumBuckets);\n      return;\n    }\n\n    SmallDenseMap &SmallSide = Small ? *this : RHS;\n    SmallDenseMap &LargeSide = Small ? RHS : *this;\n\n    // First stash the large side's rep and move the small side across.\n    LargeRep TmpRep = std::move(*LargeSide.getLargeRep());\n    LargeSide.getLargeRep()->~LargeRep();\n    LargeSide.Small = true;\n    // This is similar to the standard move-from-old-buckets, but the bucket\n    // count hasn't actually rotated in this case. So we have to carefully\n    // move construct the keys and values into their new locations, but there\n    // is no need to re-hash things.\n    for (unsigned i = 0, e = InlineBuckets; i != e; ++i) {\n      BucketT *NewB = &LargeSide.getInlineBuckets()[i],\n              *OldB = &SmallSide.getInlineBuckets()[i];\n      ::new (&NewB->getFirst()) KeyT(std::move(OldB->getFirst()));\n      OldB->getFirst().~KeyT();\n      if (!KeyInfoT::isEqual(NewB->getFirst(), EmptyKey) &&\n          !KeyInfoT::isEqual(NewB->getFirst(), TombstoneKey)) {\n        ::new (&NewB->getSecond()) ValueT(std::move(OldB->getSecond()));\n        OldB->getSecond().~ValueT();\n      }\n    }\n\n    // The hard part of moving the small buckets across is done, just move\n    // the TmpRep into its new home.\n    SmallSide.Small = false;\n    new (SmallSide.getLargeRep()) LargeRep(std::move(TmpRep));\n  }\n\n  SmallDenseMap& operator=(const SmallDenseMap& other) {\n    if (&other != this)\n      copyFrom(other);\n    return *this;\n  }\n\n  SmallDenseMap& operator=(SmallDenseMap &&other) {\n    this->destroyAll();\n    deallocateBuckets();\n    init(0);\n    swap(other);\n    return *this;\n  }\n\n  void copyFrom(const SmallDenseMap& other) {\n    this->destroyAll();\n    deallocateBuckets();\n    Small = true;\n    if (other.getNumBuckets() > InlineBuckets) {\n      Small = false;\n      new (getLargeRep()) LargeRep(allocateBuckets(other.getNumBuckets()));\n    }\n    this->BaseT::copyFrom(other);\n  }\n\n  void init(unsigned InitBuckets) {\n    Small = true;\n    if (InitBuckets > InlineBuckets) {\n      Small = false;\n      new (getLargeRep()) LargeRep(allocateBuckets(InitBuckets));\n    }\n    this->BaseT::initEmpty();\n  }\n\n  void grow(unsigned AtLeast) {\n    if (AtLeast > InlineBuckets)\n      AtLeast = std::max<unsigned>(64, NextPowerOf2(AtLeast-1));\n\n    if (Small) {\n      // First move the inline buckets into a temporary storage.\n      AlignedCharArrayUnion<BucketT[InlineBuckets]> TmpStorage;\n      BucketT *TmpBegin = reinterpret_cast<BucketT *>(&TmpStorage);\n      BucketT *TmpEnd = TmpBegin;\n\n      // Loop over the buckets, moving non-empty, non-tombstones into the\n      // temporary storage. Have the loop move the TmpEnd forward as it goes.\n      const KeyT EmptyKey = this->getEmptyKey();\n      const KeyT TombstoneKey = this->getTombstoneKey();\n      for (BucketT *P = getBuckets(), *E = P + InlineBuckets; P != E; ++P) {\n        if (!KeyInfoT::isEqual(P->getFirst(), EmptyKey) &&\n            !KeyInfoT::isEqual(P->getFirst(), TombstoneKey)) {\n          assert(size_t(TmpEnd - TmpBegin) < InlineBuckets &&\n                 \"Too many inline buckets!\");\n          ::new (&TmpEnd->getFirst()) KeyT(std::move(P->getFirst()));\n          ::new (&TmpEnd->getSecond()) ValueT(std::move(P->getSecond()));\n          ++TmpEnd;\n          P->getSecond().~ValueT();\n        }\n        P->getFirst().~KeyT();\n      }\n\n      // AtLeast == InlineBuckets can happen if there are many tombstones,\n      // and grow() is used to remove them. Usually we always switch to the\n      // large rep here.\n      if (AtLeast > InlineBuckets) {\n        Small = false;\n        new (getLargeRep()) LargeRep(allocateBuckets(AtLeast));\n      }\n      this->moveFromOldBuckets(TmpBegin, TmpEnd);\n      return;\n    }\n\n    LargeRep OldRep = std::move(*getLargeRep());\n    getLargeRep()->~LargeRep();\n    if (AtLeast <= InlineBuckets) {\n      Small = true;\n    } else {\n      new (getLargeRep()) LargeRep(allocateBuckets(AtLeast));\n    }\n\n    this->moveFromOldBuckets(OldRep.Buckets, OldRep.Buckets+OldRep.NumBuckets);\n\n    // Free the old table.\n    deallocate_buffer(OldRep.Buckets, sizeof(BucketT) * OldRep.NumBuckets,\n                      alignof(BucketT));\n  }\n\n  void shrink_and_clear() {\n    unsigned OldSize = this->size();\n    this->destroyAll();\n\n    // Reduce the number of buckets.\n    unsigned NewNumBuckets = 0;\n    if (OldSize) {\n      NewNumBuckets = 1 << (Log2_32_Ceil(OldSize) + 1);\n      if (NewNumBuckets > InlineBuckets && NewNumBuckets < 64u)\n        NewNumBuckets = 64;\n    }\n    if ((Small && NewNumBuckets <= InlineBuckets) ||\n        (!Small && NewNumBuckets == getLargeRep()->NumBuckets)) {\n      this->BaseT::initEmpty();\n      return;\n    }\n\n    deallocateBuckets();\n    init(NewNumBuckets);\n  }\n\nprivate:\n  unsigned getNumEntries() const {\n    return NumEntries;\n  }\n\n  void setNumEntries(unsigned Num) {\n    // NumEntries is hardcoded to be 31 bits wide.\n    assert(Num < (1U << 31) && \"Cannot support more than 1<<31 entries\");\n    NumEntries = Num;\n  }\n\n  unsigned getNumTombstones() const {\n    return NumTombstones;\n  }\n\n  void setNumTombstones(unsigned Num) {\n    NumTombstones = Num;\n  }\n\n  const BucketT *getInlineBuckets() const {\n    assert(Small);\n    // Note that this cast does not violate aliasing rules as we assert that\n    // the memory's dynamic type is the small, inline bucket buffer, and the\n    // 'storage' is a POD containing a char buffer.\n    return reinterpret_cast<const BucketT *>(&storage);\n  }\n\n  BucketT *getInlineBuckets() {\n    return const_cast<BucketT *>(\n      const_cast<const SmallDenseMap *>(this)->getInlineBuckets());\n  }\n\n  const LargeRep *getLargeRep() const {\n    assert(!Small);\n    // Note, same rule about aliasing as with getInlineBuckets.\n    return reinterpret_cast<const LargeRep *>(&storage);\n  }\n\n  LargeRep *getLargeRep() {\n    return const_cast<LargeRep *>(\n      const_cast<const SmallDenseMap *>(this)->getLargeRep());\n  }\n\n  const BucketT *getBuckets() const {\n    return Small ? getInlineBuckets() : getLargeRep()->Buckets;\n  }\n\n  BucketT *getBuckets() {\n    return const_cast<BucketT *>(\n      const_cast<const SmallDenseMap *>(this)->getBuckets());\n  }\n\n  unsigned getNumBuckets() const {\n    return Small ? InlineBuckets : getLargeRep()->NumBuckets;\n  }\n\n  void deallocateBuckets() {\n    if (Small)\n      return;\n\n    deallocate_buffer(getLargeRep()->Buckets,\n                      sizeof(BucketT) * getLargeRep()->NumBuckets,\n                      alignof(BucketT));\n    getLargeRep()->~LargeRep();\n  }\n\n  LargeRep allocateBuckets(unsigned Num) {\n    assert(Num > InlineBuckets && \"Must allocate more buckets than are inline\");\n    LargeRep Rep = {static_cast<BucketT *>(allocate_buffer(\n                        sizeof(BucketT) * Num, alignof(BucketT))),\n                    Num};\n    return Rep;\n  }\n};\n\ntemplate <typename KeyT, typename ValueT, typename KeyInfoT, typename Bucket,\n          bool IsConst>\nclass DenseMapIterator : DebugEpochBase::HandleBase {\n  friend class DenseMapIterator<KeyT, ValueT, KeyInfoT, Bucket, true>;\n  friend class DenseMapIterator<KeyT, ValueT, KeyInfoT, Bucket, false>;\n\npublic:\n  using difference_type = ptrdiff_t;\n  using value_type =\n      typename std::conditional<IsConst, const Bucket, Bucket>::type;\n  using pointer = value_type *;\n  using reference = value_type &;\n  using iterator_category = std::forward_iterator_tag;\n\nprivate:\n  pointer Ptr = nullptr;\n  pointer End = nullptr;\n\npublic:\n  DenseMapIterator() = default;\n\n  DenseMapIterator(pointer Pos, pointer E, const DebugEpochBase &Epoch,\n                   bool NoAdvance = false)\n      : DebugEpochBase::HandleBase(&Epoch), Ptr(Pos), End(E) {\n    assert(isHandleInSync() && \"invalid construction!\");\n\n    if (NoAdvance) return;\n    if (shouldReverseIterate<KeyT>()) {\n      RetreatPastEmptyBuckets();\n      return;\n    }\n    AdvancePastEmptyBuckets();\n  }\n\n  // Converting ctor from non-const iterators to const iterators. SFINAE'd out\n  // for const iterator destinations so it doesn't end up as a user defined copy\n  // constructor.\n  template <bool IsConstSrc,\n            typename = std::enable_if_t<!IsConstSrc && IsConst>>\n  DenseMapIterator(\n      const DenseMapIterator<KeyT, ValueT, KeyInfoT, Bucket, IsConstSrc> &I)\n      : DebugEpochBase::HandleBase(I), Ptr(I.Ptr), End(I.End) {}\n\n  reference operator*() const {\n    assert(isHandleInSync() && \"invalid iterator access!\");\n    assert(Ptr != End && \"dereferencing end() iterator\");\n    if (shouldReverseIterate<KeyT>())\n      return Ptr[-1];\n    return *Ptr;\n  }\n  pointer operator->() const {\n    assert(isHandleInSync() && \"invalid iterator access!\");\n    assert(Ptr != End && \"dereferencing end() iterator\");\n    if (shouldReverseIterate<KeyT>())\n      return &(Ptr[-1]);\n    return Ptr;\n  }\n\n  friend bool operator==(const DenseMapIterator &LHS,\n                         const DenseMapIterator &RHS) {\n    assert((!LHS.Ptr || LHS.isHandleInSync()) && \"handle not in sync!\");\n    assert((!RHS.Ptr || RHS.isHandleInSync()) && \"handle not in sync!\");\n    assert(LHS.getEpochAddress() == RHS.getEpochAddress() &&\n           \"comparing incomparable iterators!\");\n    return LHS.Ptr == RHS.Ptr;\n  }\n\n  friend bool operator!=(const DenseMapIterator &LHS,\n                         const DenseMapIterator &RHS) {\n    return !(LHS == RHS);\n  }\n\n  inline DenseMapIterator& operator++() {  // Preincrement\n    assert(isHandleInSync() && \"invalid iterator access!\");\n    assert(Ptr != End && \"incrementing end() iterator\");\n    if (shouldReverseIterate<KeyT>()) {\n      --Ptr;\n      RetreatPastEmptyBuckets();\n      return *this;\n    }\n    ++Ptr;\n    AdvancePastEmptyBuckets();\n    return *this;\n  }\n  DenseMapIterator operator++(int) {  // Postincrement\n    assert(isHandleInSync() && \"invalid iterator access!\");\n    DenseMapIterator tmp = *this; ++*this; return tmp;\n  }\n\nprivate:\n  void AdvancePastEmptyBuckets() {\n    assert(Ptr <= End);\n    const KeyT Empty = KeyInfoT::getEmptyKey();\n    const KeyT Tombstone = KeyInfoT::getTombstoneKey();\n\n    while (Ptr != End && (KeyInfoT::isEqual(Ptr->getFirst(), Empty) ||\n                          KeyInfoT::isEqual(Ptr->getFirst(), Tombstone)))\n      ++Ptr;\n  }\n\n  void RetreatPastEmptyBuckets() {\n    assert(Ptr >= End);\n    const KeyT Empty = KeyInfoT::getEmptyKey();\n    const KeyT Tombstone = KeyInfoT::getTombstoneKey();\n\n    while (Ptr != End && (KeyInfoT::isEqual(Ptr[-1].getFirst(), Empty) ||\n                          KeyInfoT::isEqual(Ptr[-1].getFirst(), Tombstone)))\n      --Ptr;\n  }\n};\n\ntemplate <typename KeyT, typename ValueT, typename KeyInfoT>\ninline size_t capacity_in_bytes(const DenseMap<KeyT, ValueT, KeyInfoT> &X) {\n  return X.getMemorySize();\n}\n\n} // end namespace llvm\n\n#endif // LLVM_ADT_DENSEMAP_H\n"}, "62": {"id": 62, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/ScopeExit.h", "content": "//===- llvm/ADT/ScopeExit.h - Execute code at scope exit --------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file defines the make_scope_exit function, which executes user-defined\n// cleanup logic at scope exit.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_ADT_SCOPEEXIT_H\n#define LLVM_ADT_SCOPEEXIT_H\n\n#include \"llvm/Support/Compiler.h\"\n\n#include <type_traits>\n#include <utility>\n\nnamespace llvm {\nnamespace detail {\n\ntemplate <typename Callable> class scope_exit {\n  Callable ExitFunction;\n  bool Engaged = true; // False once moved-from or release()d.\n\npublic:\n  template <typename Fp>\n  explicit scope_exit(Fp &&F) : ExitFunction(std::forward<Fp>(F)) {}\n\n  scope_exit(scope_exit &&Rhs)\n      : ExitFunction(std::move(Rhs.ExitFunction)), Engaged(Rhs.Engaged) {\n    Rhs.release();\n  }\n  scope_exit(const scope_exit &) = delete;\n  scope_exit &operator=(scope_exit &&) = delete;\n  scope_exit &operator=(const scope_exit &) = delete;\n\n  void release() { Engaged = false; }\n\n  ~scope_exit() {\n    if (Engaged)\n      ExitFunction();\n  }\n};\n\n} // end namespace detail\n\n// Keeps the callable object that is passed in, and execute it at the\n// destruction of the returned object (usually at the scope exit where the\n// returned object is kept).\n//\n// Interface is specified by p0052r2.\ntemplate <typename Callable>\nLLVM_NODISCARD detail::scope_exit<typename std::decay<Callable>::type>\nmake_scope_exit(Callable &&F) {\n  return detail::scope_exit<typename std::decay<Callable>::type>(\n      std::forward<Callable>(F));\n}\n\n} // end namespace llvm\n\n#endif\n"}, "63": {"id": 63, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/SmallBitVector.h", "content": "//===- llvm/ADT/SmallBitVector.h - 'Normally small' bit vectors -*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file implements the SmallBitVector class.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_ADT_SMALLBITVECTOR_H\n#define LLVM_ADT_SMALLBITVECTOR_H\n\n#include \"llvm/ADT/BitVector.h\"\n#include \"llvm/ADT/iterator_range.h\"\n#include \"llvm/Support/MathExtras.h\"\n#include <algorithm>\n#include <cassert>\n#include <climits>\n#include <cstddef>\n#include <cstdint>\n#include <limits>\n#include <utility>\n\nnamespace llvm {\n\n/// This is a 'bitvector' (really, a variable-sized bit array), optimized for\n/// the case when the array is small. It contains one pointer-sized field, which\n/// is directly used as a plain collection of bits when possible, or as a\n/// pointer to a larger heap-allocated array when necessary. This allows normal\n/// \"small\" cases to be fast without losing generality for large inputs.\nclass SmallBitVector {\n  // TODO: In \"large\" mode, a pointer to a BitVector is used, leading to an\n  // unnecessary level of indirection. It would be more efficient to use a\n  // pointer to memory containing size, allocation size, and the array of bits.\n  uintptr_t X = 1;\n\n  enum {\n    // The number of bits in this class.\n    NumBaseBits = sizeof(uintptr_t) * CHAR_BIT,\n\n    // One bit is used to discriminate between small and large mode. The\n    // remaining bits are used for the small-mode representation.\n    SmallNumRawBits = NumBaseBits - 1,\n\n    // A few more bits are used to store the size of the bit set in small mode.\n    // Theoretically this is a ceil-log2. These bits are encoded in the most\n    // significant bits of the raw bits.\n    SmallNumSizeBits = (NumBaseBits == 32 ? 5 :\n                        NumBaseBits == 64 ? 6 :\n                        SmallNumRawBits),\n\n    // The remaining bits are used to store the actual set in small mode.\n    SmallNumDataBits = SmallNumRawBits - SmallNumSizeBits\n  };\n\n  static_assert(NumBaseBits == 64 || NumBaseBits == 32,\n                \"Unsupported word size\");\n\npublic:\n  using size_type = unsigned;\n\n  // Encapsulation of a single bit.\n  class reference {\n    SmallBitVector &TheVector;\n    unsigned BitPos;\n\n  public:\n    reference(SmallBitVector &b, unsigned Idx) : TheVector(b), BitPos(Idx) {}\n\n    reference(const reference&) = default;\n\n    reference& operator=(reference t) {\n      *this = bool(t);\n      return *this;\n    }\n\n    reference& operator=(bool t) {\n      if (t)\n        TheVector.set(BitPos);\n      else\n        TheVector.reset(BitPos);\n      return *this;\n    }\n\n    operator bool() const {\n      return const_cast<const SmallBitVector &>(TheVector).operator[](BitPos);\n    }\n  };\n\nprivate:\n  BitVector *getPointer() const {\n    assert(!isSmall());\n    return reinterpret_cast<BitVector *>(X);\n  }\n\n  void switchToSmall(uintptr_t NewSmallBits, size_t NewSize) {\n    X = 1;\n    setSmallSize(NewSize);\n    setSmallBits(NewSmallBits);\n  }\n\n  void switchToLarge(BitVector *BV) {\n    X = reinterpret_cast<uintptr_t>(BV);\n    assert(!isSmall() && \"Tried to use an unaligned pointer\");\n  }\n\n  // Return all the bits used for the \"small\" representation; this includes\n  // bits for the size as well as the element bits.\n  uintptr_t getSmallRawBits() const {\n    assert(isSmall());\n    return X >> 1;\n  }\n\n  void setSmallRawBits(uintptr_t NewRawBits) {\n    assert(isSmall());\n    X = (NewRawBits << 1) | uintptr_t(1);\n  }\n\n  // Return the size.\n  size_t getSmallSize() const { return getSmallRawBits() >> SmallNumDataBits; }\n\n  void setSmallSize(size_t Size) {\n    setSmallRawBits(getSmallBits() | (Size << SmallNumDataBits));\n  }\n\n  // Return the element bits.\n  uintptr_t getSmallBits() const {\n    return getSmallRawBits() & ~(~uintptr_t(0) << getSmallSize());\n  }\n\n  void setSmallBits(uintptr_t NewBits) {\n    setSmallRawBits((NewBits & ~(~uintptr_t(0) << getSmallSize())) |\n                    (getSmallSize() << SmallNumDataBits));\n  }\n\npublic:\n  /// Creates an empty bitvector.\n  SmallBitVector() = default;\n\n  /// Creates a bitvector of specified number of bits. All bits are initialized\n  /// to the specified value.\n  explicit SmallBitVector(unsigned s, bool t = false) {\n    if (s <= SmallNumDataBits)\n      switchToSmall(t ? ~uintptr_t(0) : 0, s);\n    else\n      switchToLarge(new BitVector(s, t));\n  }\n\n  /// SmallBitVector copy ctor.\n  SmallBitVector(const SmallBitVector &RHS) {\n    if (RHS.isSmall())\n      X = RHS.X;\n    else\n      switchToLarge(new BitVector(*RHS.getPointer()));\n  }\n\n  SmallBitVector(SmallBitVector &&RHS) : X(RHS.X) {\n    RHS.X = 1;\n  }\n\n  ~SmallBitVector() {\n    if (!isSmall())\n      delete getPointer();\n  }\n\n  using const_set_bits_iterator = const_set_bits_iterator_impl<SmallBitVector>;\n  using set_iterator = const_set_bits_iterator;\n\n  const_set_bits_iterator set_bits_begin() const {\n    return const_set_bits_iterator(*this);\n  }\n\n  const_set_bits_iterator set_bits_end() const {\n    return const_set_bits_iterator(*this, -1);\n  }\n\n  iterator_range<const_set_bits_iterator> set_bits() const {\n    return make_range(set_bits_begin(), set_bits_end());\n  }\n\n  bool isSmall() const { return X & uintptr_t(1); }\n\n  /// Tests whether there are no bits in this bitvector.\n  bool empty() const {\n    return isSmall() ? getSmallSize() == 0 : getPointer()->empty();\n  }\n\n  /// Returns the number of bits in this bitvector.\n  size_t size() const {\n    return isSmall() ? getSmallSize() : getPointer()->size();\n  }\n\n  /// Returns the number of bits which are set.\n  size_type count() const {\n    if (isSmall()) {\n      uintptr_t Bits = getSmallBits();\n      return countPopulation(Bits);\n    }\n    return getPointer()->count();\n  }\n\n  /// Returns true if any bit is set.\n  bool any() const {\n    if (isSmall())\n      return getSmallBits() != 0;\n    return getPointer()->any();\n  }\n\n  /// Returns true if all bits are set.\n  bool all() const {\n    if (isSmall())\n      return getSmallBits() == (uintptr_t(1) << getSmallSize()) - 1;\n    return getPointer()->all();\n  }\n\n  /// Returns true if none of the bits are set.\n  bool none() const {\n    if (isSmall())\n      return getSmallBits() == 0;\n    return getPointer()->none();\n  }\n\n  /// Returns the index of the first set bit, -1 if none of the bits are set.\n  int find_first() const {\n    if (isSmall()) {\n      uintptr_t Bits = getSmallBits();\n      if (Bits == 0)\n        return -1;\n      return countTrailingZeros(Bits);\n    }\n    return getPointer()->find_first();\n  }\n\n  int find_last() const {\n    if (isSmall()) {\n      uintptr_t Bits = getSmallBits();\n      if (Bits == 0)\n        return -1;\n      return NumBaseBits - countLeadingZeros(Bits) - 1;\n    }\n    return getPointer()->find_last();\n  }\n\n  /// Returns the index of the first unset bit, -1 if all of the bits are set.\n  int find_first_unset() const {\n    if (isSmall()) {\n      if (count() == getSmallSize())\n        return -1;\n\n      uintptr_t Bits = getSmallBits();\n      return countTrailingOnes(Bits);\n    }\n    return getPointer()->find_first_unset();\n  }\n\n  int find_last_unset() const {\n    if (isSmall()) {\n      if (count() == getSmallSize())\n        return -1;\n\n      uintptr_t Bits = getSmallBits();\n      // Set unused bits.\n      Bits |= ~uintptr_t(0) << getSmallSize();\n      return NumBaseBits - countLeadingOnes(Bits) - 1;\n    }\n    return getPointer()->find_last_unset();\n  }\n\n  /// Returns the index of the next set bit following the \"Prev\" bit.\n  /// Returns -1 if the next set bit is not found.\n  int find_next(unsigned Prev) const {\n    if (isSmall()) {\n      uintptr_t Bits = getSmallBits();\n      // Mask off previous bits.\n      Bits &= ~uintptr_t(0) << (Prev + 1);\n      if (Bits == 0 || Prev + 1 >= getSmallSize())\n        return -1;\n      return countTrailingZeros(Bits);\n    }\n    return getPointer()->find_next(Prev);\n  }\n\n  /// Returns the index of the next unset bit following the \"Prev\" bit.\n  /// Returns -1 if the next unset bit is not found.\n  int find_next_unset(unsigned Prev) const {\n    if (isSmall()) {\n      uintptr_t Bits = getSmallBits();\n      // Mask in previous bits.\n      Bits |= (uintptr_t(1) << (Prev + 1)) - 1;\n      // Mask in unused bits.\n      Bits |= ~uintptr_t(0) << getSmallSize();\n\n      if (Bits == ~uintptr_t(0) || Prev + 1 >= getSmallSize())\n        return -1;\n      return countTrailingOnes(Bits);\n    }\n    return getPointer()->find_next_unset(Prev);\n  }\n\n  /// find_prev - Returns the index of the first set bit that precedes the\n  /// the bit at \\p PriorTo.  Returns -1 if all previous bits are unset.\n  int find_prev(unsigned PriorTo) const {\n    if (isSmall()) {\n      if (PriorTo == 0)\n        return -1;\n\n      --PriorTo;\n      uintptr_t Bits = getSmallBits();\n      Bits &= maskTrailingOnes<uintptr_t>(PriorTo + 1);\n      if (Bits == 0)\n        return -1;\n\n      return NumBaseBits - countLeadingZeros(Bits) - 1;\n    }\n    return getPointer()->find_prev(PriorTo);\n  }\n\n  /// Clear all bits.\n  void clear() {\n    if (!isSmall())\n      delete getPointer();\n    switchToSmall(0, 0);\n  }\n\n  /// Grow or shrink the bitvector.\n  void resize(unsigned N, bool t = false) {\n    if (!isSmall()) {\n      getPointer()->resize(N, t);\n    } else if (SmallNumDataBits >= N) {\n      uintptr_t NewBits = t ? ~uintptr_t(0) << getSmallSize() : 0;\n      setSmallSize(N);\n      setSmallBits(NewBits | getSmallBits());\n    } else {\n      BitVector *BV = new BitVector(N, t);\n      uintptr_t OldBits = getSmallBits();\n      for (size_t i = 0, e = getSmallSize(); i != e; ++i)\n        (*BV)[i] = (OldBits >> i) & 1;\n      switchToLarge(BV);\n    }\n  }\n\n  void reserve(unsigned N) {\n    if (isSmall()) {\n      if (N > SmallNumDataBits) {\n        uintptr_t OldBits = getSmallRawBits();\n        size_t SmallSize = getSmallSize();\n        BitVector *BV = new BitVector(SmallSize);\n        for (size_t i = 0; i < SmallSize; ++i)\n          if ((OldBits >> i) & 1)\n            BV->set(i);\n        BV->reserve(N);\n        switchToLarge(BV);\n      }\n    } else {\n      getPointer()->reserve(N);\n    }\n  }\n\n  // Set, reset, flip\n  SmallBitVector &set() {\n    if (isSmall())\n      setSmallBits(~uintptr_t(0));\n    else\n      getPointer()->set();\n    return *this;\n  }\n\n  SmallBitVector &set(unsigned Idx) {\n    if (isSmall()) {\n      assert(Idx <= static_cast<unsigned>(\n                        std::numeric_limits<uintptr_t>::digits) &&\n             \"undefined behavior\");\n      setSmallBits(getSmallBits() | (uintptr_t(1) << Idx));\n    }\n    else\n      getPointer()->set(Idx);\n    return *this;\n  }\n\n  /// Efficiently set a range of bits in [I, E)\n  SmallBitVector &set(unsigned I, unsigned E) {\n    assert(I <= E && \"Attempted to set backwards range!\");\n    assert(E <= size() && \"Attempted to set out-of-bounds range!\");\n    if (I == E) return *this;\n    if (isSmall()) {\n      uintptr_t EMask = ((uintptr_t)1) << E;\n      uintptr_t IMask = ((uintptr_t)1) << I;\n      uintptr_t Mask = EMask - IMask;\n      setSmallBits(getSmallBits() | Mask);\n    } else\n      getPointer()->set(I, E);\n    return *this;\n  }\n\n  SmallBitVector &reset() {\n    if (isSmall())\n      setSmallBits(0);\n    else\n      getPointer()->reset();\n    return *this;\n  }\n\n  SmallBitVector &reset(unsigned Idx) {\n    if (isSmall())\n      setSmallBits(getSmallBits() & ~(uintptr_t(1) << Idx));\n    else\n      getPointer()->reset(Idx);\n    return *this;\n  }\n\n  /// Efficiently reset a range of bits in [I, E)\n  SmallBitVector &reset(unsigned I, unsigned E) {\n    assert(I <= E && \"Attempted to reset backwards range!\");\n    assert(E <= size() && \"Attempted to reset out-of-bounds range!\");\n    if (I == E) return *this;\n    if (isSmall()) {\n      uintptr_t EMask = ((uintptr_t)1) << E;\n      uintptr_t IMask = ((uintptr_t)1) << I;\n      uintptr_t Mask = EMask - IMask;\n      setSmallBits(getSmallBits() & ~Mask);\n    } else\n      getPointer()->reset(I, E);\n    return *this;\n  }\n\n  SmallBitVector &flip() {\n    if (isSmall())\n      setSmallBits(~getSmallBits());\n    else\n      getPointer()->flip();\n    return *this;\n  }\n\n  SmallBitVector &flip(unsigned Idx) {\n    if (isSmall())\n      setSmallBits(getSmallBits() ^ (uintptr_t(1) << Idx));\n    else\n      getPointer()->flip(Idx);\n    return *this;\n  }\n\n  // No argument flip.\n  SmallBitVector operator~() const {\n    return SmallBitVector(*this).flip();\n  }\n\n  // Indexing.\n  reference operator[](unsigned Idx) {\n    assert(Idx < size() && \"Out-of-bounds Bit access.\");\n    return reference(*this, Idx);\n  }\n\n  bool operator[](unsigned Idx) const {\n    assert(Idx < size() && \"Out-of-bounds Bit access.\");\n    if (isSmall())\n      return ((getSmallBits() >> Idx) & 1) != 0;\n    return getPointer()->operator[](Idx);\n  }\n\n  bool test(unsigned Idx) const {\n    return (*this)[Idx];\n  }\n\n  // Push single bit to end of vector.\n  void push_back(bool Val) {\n    resize(size() + 1, Val);\n  }\n\n  /// Test if any common bits are set.\n  bool anyCommon(const SmallBitVector &RHS) const {\n    if (isSmall() && RHS.isSmall())\n      return (getSmallBits() & RHS.getSmallBits()) != 0;\n    if (!isSmall() && !RHS.isSmall())\n      return getPointer()->anyCommon(*RHS.getPointer());\n\n    for (unsigned i = 0, e = std::min(size(), RHS.size()); i != e; ++i)\n      if (test(i) && RHS.test(i))\n        return true;\n    return false;\n  }\n\n  // Comparison operators.\n  bool operator==(const SmallBitVector &RHS) const {\n    if (size() != RHS.size())\n      return false;\n    if (isSmall() && RHS.isSmall())\n      return getSmallBits() == RHS.getSmallBits();\n    else if (!isSmall() && !RHS.isSmall())\n      return *getPointer() == *RHS.getPointer();\n    else {\n      for (size_t i = 0, e = size(); i != e; ++i) {\n        if ((*this)[i] != RHS[i])\n          return false;\n      }\n      return true;\n    }\n  }\n\n  bool operator!=(const SmallBitVector &RHS) const {\n    return !(*this == RHS);\n  }\n\n  // Intersection, union, disjoint union.\n  // FIXME BitVector::operator&= does not resize the LHS but this does\n  SmallBitVector &operator&=(const SmallBitVector &RHS) {\n    resize(std::max(size(), RHS.size()));\n    if (isSmall() && RHS.isSmall())\n      setSmallBits(getSmallBits() & RHS.getSmallBits());\n    else if (!isSmall() && !RHS.isSmall())\n      getPointer()->operator&=(*RHS.getPointer());\n    else {\n      size_t i, e;\n      for (i = 0, e = std::min(size(), RHS.size()); i != e; ++i)\n        (*this)[i] = test(i) && RHS.test(i);\n      for (e = size(); i != e; ++i)\n        reset(i);\n    }\n    return *this;\n  }\n\n  /// Reset bits that are set in RHS. Same as *this &= ~RHS.\n  SmallBitVector &reset(const SmallBitVector &RHS) {\n    if (isSmall() && RHS.isSmall())\n      setSmallBits(getSmallBits() & ~RHS.getSmallBits());\n    else if (!isSmall() && !RHS.isSmall())\n      getPointer()->reset(*RHS.getPointer());\n    else\n      for (unsigned i = 0, e = std::min(size(), RHS.size()); i != e; ++i)\n        if (RHS.test(i))\n          reset(i);\n\n    return *this;\n  }\n\n  /// Check if (This - RHS) is zero. This is the same as reset(RHS) and any().\n  bool test(const SmallBitVector &RHS) const {\n    if (isSmall() && RHS.isSmall())\n      return (getSmallBits() & ~RHS.getSmallBits()) != 0;\n    if (!isSmall() && !RHS.isSmall())\n      return getPointer()->test(*RHS.getPointer());\n\n    unsigned i, e;\n    for (i = 0, e = std::min(size(), RHS.size()); i != e; ++i)\n      if (test(i) && !RHS.test(i))\n        return true;\n\n    for (e = size(); i != e; ++i)\n      if (test(i))\n        return true;\n\n    return false;\n  }\n\n  SmallBitVector &operator|=(const SmallBitVector &RHS) {\n    resize(std::max(size(), RHS.size()));\n    if (isSmall() && RHS.isSmall())\n      setSmallBits(getSmallBits() | RHS.getSmallBits());\n    else if (!isSmall() && !RHS.isSmall())\n      getPointer()->operator|=(*RHS.getPointer());\n    else {\n      for (size_t i = 0, e = RHS.size(); i != e; ++i)\n        (*this)[i] = test(i) || RHS.test(i);\n    }\n    return *this;\n  }\n\n  SmallBitVector &operator^=(const SmallBitVector &RHS) {\n    resize(std::max(size(), RHS.size()));\n    if (isSmall() && RHS.isSmall())\n      setSmallBits(getSmallBits() ^ RHS.getSmallBits());\n    else if (!isSmall() && !RHS.isSmall())\n      getPointer()->operator^=(*RHS.getPointer());\n    else {\n      for (size_t i = 0, e = RHS.size(); i != e; ++i)\n        (*this)[i] = test(i) != RHS.test(i);\n    }\n    return *this;\n  }\n\n  SmallBitVector &operator<<=(unsigned N) {\n    if (isSmall())\n      setSmallBits(getSmallBits() << N);\n    else\n      getPointer()->operator<<=(N);\n    return *this;\n  }\n\n  SmallBitVector &operator>>=(unsigned N) {\n    if (isSmall())\n      setSmallBits(getSmallBits() >> N);\n    else\n      getPointer()->operator>>=(N);\n    return *this;\n  }\n\n  // Assignment operator.\n  const SmallBitVector &operator=(const SmallBitVector &RHS) {\n    if (isSmall()) {\n      if (RHS.isSmall())\n        X = RHS.X;\n      else\n        switchToLarge(new BitVector(*RHS.getPointer()));\n    } else {\n      if (!RHS.isSmall())\n        *getPointer() = *RHS.getPointer();\n      else {\n        delete getPointer();\n        X = RHS.X;\n      }\n    }\n    return *this;\n  }\n\n  const SmallBitVector &operator=(SmallBitVector &&RHS) {\n    if (this != &RHS) {\n      clear();\n      swap(RHS);\n    }\n    return *this;\n  }\n\n  void swap(SmallBitVector &RHS) {\n    std::swap(X, RHS.X);\n  }\n\n  /// Add '1' bits from Mask to this vector. Don't resize.\n  /// This computes \"*this |= Mask\".\n  void setBitsInMask(const uint32_t *Mask, unsigned MaskWords = ~0u) {\n    if (isSmall())\n      applyMask<true, false>(Mask, MaskWords);\n    else\n      getPointer()->setBitsInMask(Mask, MaskWords);\n  }\n\n  /// Clear any bits in this vector that are set in Mask. Don't resize.\n  /// This computes \"*this &= ~Mask\".\n  void clearBitsInMask(const uint32_t *Mask, unsigned MaskWords = ~0u) {\n    if (isSmall())\n      applyMask<false, false>(Mask, MaskWords);\n    else\n      getPointer()->clearBitsInMask(Mask, MaskWords);\n  }\n\n  /// Add a bit to this vector for every '0' bit in Mask. Don't resize.\n  /// This computes \"*this |= ~Mask\".\n  void setBitsNotInMask(const uint32_t *Mask, unsigned MaskWords = ~0u) {\n    if (isSmall())\n      applyMask<true, true>(Mask, MaskWords);\n    else\n      getPointer()->setBitsNotInMask(Mask, MaskWords);\n  }\n\n  /// Clear a bit in this vector for every '0' bit in Mask. Don't resize.\n  /// This computes \"*this &= Mask\".\n  void clearBitsNotInMask(const uint32_t *Mask, unsigned MaskWords = ~0u) {\n    if (isSmall())\n      applyMask<false, true>(Mask, MaskWords);\n    else\n      getPointer()->clearBitsNotInMask(Mask, MaskWords);\n  }\n\n  void invalid() {\n    assert(empty());\n    X = (uintptr_t)-1;\n  }\n  bool isInvalid() const { return X == (uintptr_t)-1; }\n\n  ArrayRef<uintptr_t> getData(uintptr_t &Store) const {\n    if (!isSmall())\n      return getPointer()->getData();\n    Store = getSmallBits();\n    return makeArrayRef(Store);\n  }\n\nprivate:\n  template <bool AddBits, bool InvertMask>\n  void applyMask(const uint32_t *Mask, unsigned MaskWords) {\n    assert(MaskWords <= sizeof(uintptr_t) && \"Mask is larger than base!\");\n    uintptr_t M = Mask[0];\n    if (NumBaseBits == 64)\n      M |= uint64_t(Mask[1]) << 32;\n    if (InvertMask)\n      M = ~M;\n    if (AddBits)\n      setSmallBits(getSmallBits() | M);\n    else\n      setSmallBits(getSmallBits() & ~M);\n  }\n};\n\ninline SmallBitVector\noperator&(const SmallBitVector &LHS, const SmallBitVector &RHS) {\n  SmallBitVector Result(LHS);\n  Result &= RHS;\n  return Result;\n}\n\ninline SmallBitVector\noperator|(const SmallBitVector &LHS, const SmallBitVector &RHS) {\n  SmallBitVector Result(LHS);\n  Result |= RHS;\n  return Result;\n}\n\ninline SmallBitVector\noperator^(const SmallBitVector &LHS, const SmallBitVector &RHS) {\n  SmallBitVector Result(LHS);\n  Result ^= RHS;\n  return Result;\n}\n\ntemplate <> struct DenseMapInfo<SmallBitVector> {\n  static inline SmallBitVector getEmptyKey() { return SmallBitVector(); }\n  static inline SmallBitVector getTombstoneKey() {\n    SmallBitVector V;\n    V.invalid();\n    return V;\n  }\n  static unsigned getHashValue(const SmallBitVector &V) {\n    uintptr_t Store;\n    return DenseMapInfo<std::pair<unsigned, ArrayRef<uintptr_t>>>::getHashValue(\n        std::make_pair(V.size(), V.getData(Store)));\n  }\n  static bool isEqual(const SmallBitVector &LHS, const SmallBitVector &RHS) {\n    if (LHS.isInvalid() || RHS.isInvalid())\n      return LHS.isInvalid() == RHS.isInvalid();\n    return LHS == RHS;\n  }\n};\n} // end namespace llvm\n\nnamespace std {\n\n/// Implement std::swap in terms of BitVector swap.\ninline void\nswap(llvm::SmallBitVector &LHS, llvm::SmallBitVector &RHS) {\n  LHS.swap(RHS);\n}\n\n} // end namespace std\n\n#endif // LLVM_ADT_SMALLBITVECTOR_H\n"}, "69": {"id": 69, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/StringSet.h", "content": "//===- StringSet.h - An efficient set built on StringMap --------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n//  StringSet - A set-like wrapper for the StringMap.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_ADT_STRINGSET_H\n#define LLVM_ADT_STRINGSET_H\n\n#include \"llvm/ADT/StringMap.h\"\n\nnamespace llvm {\n\n/// StringSet - A wrapper for StringMap that provides set-like functionality.\ntemplate <class AllocatorTy = MallocAllocator>\nclass StringSet : public StringMap<NoneType, AllocatorTy> {\n  using Base = StringMap<NoneType, AllocatorTy>;\n\npublic:\n  StringSet() = default;\n  StringSet(std::initializer_list<StringRef> initializer) {\n    for (StringRef str : initializer)\n      insert(str);\n  }\n  explicit StringSet(AllocatorTy a) : Base(a) {}\n\n  std::pair<typename Base::iterator, bool> insert(StringRef key) {\n    return Base::try_emplace(key);\n  }\n\n  template <typename InputIt>\n  void insert(const InputIt &begin, const InputIt &end) {\n    for (auto it = begin; it != end; ++it)\n      insert(*it);\n  }\n\n  template <typename ValueTy>\n  std::pair<typename Base::iterator, bool>\n  insert(const StringMapEntry<ValueTy> &mapEntry) {\n    return insert(mapEntry.getKey());\n  }\n\n  /// Check if the set contains the given \\c key.\n  bool contains(StringRef key) const { return Base::FindKey(key) != -1; }\n};\n\n} // end namespace llvm\n\n#endif // LLVM_ADT_STRINGSET_H\n"}, "77": {"id": 77, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/DataExtractor.h", "content": "//===-- DataExtractor.h -----------------------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_SUPPORT_DATAEXTRACTOR_H\n#define LLVM_SUPPORT_DATAEXTRACTOR_H\n\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/Support/DataTypes.h\"\n#include \"llvm/Support/Error.h\"\n\nnamespace llvm {\n\n/// An auxiliary type to facilitate extraction of 3-byte entities.\nstruct Uint24 {\n  uint8_t Bytes[3];\n  Uint24(uint8_t U) {\n    Bytes[0] = Bytes[1] = Bytes[2] = U;\n  }\n  Uint24(uint8_t U0, uint8_t U1, uint8_t U2) {\n    Bytes[0] = U0; Bytes[1] = U1; Bytes[2] = U2;\n  }\n  uint32_t getAsUint32(bool IsLittleEndian) const {\n    int LoIx = IsLittleEndian ? 0 : 2;\n    return Bytes[LoIx] + (Bytes[1] << 8) + (Bytes[2-LoIx] << 16);\n  }\n};\n\nusing uint24_t = Uint24;\nstatic_assert(sizeof(uint24_t) == 3, \"sizeof(uint24_t) != 3\");\n\n/// Needed by swapByteOrder().\ninline uint24_t getSwappedBytes(uint24_t C) {\n  return uint24_t(C.Bytes[2], C.Bytes[1], C.Bytes[0]);\n}\n\nclass DataExtractor {\n  StringRef Data;\n  uint8_t IsLittleEndian;\n  uint8_t AddressSize;\npublic:\n  /// A class representing a position in a DataExtractor, as well as any error\n  /// encountered during extraction. It enables one to extract a sequence of\n  /// values without error-checking and then checking for errors in bulk at the\n  /// end. The class holds an Error object, so failing to check the result of\n  /// the parse will result in a runtime error. The error flag is sticky and\n  /// will cause all subsequent extraction functions to fail without even\n  /// attempting to parse and without updating the Cursor offset. After clearing\n  /// the error flag, one can again use the Cursor object for parsing.\n  class Cursor {\n    uint64_t Offset;\n    Error Err;\n\n    friend class DataExtractor;\n\n  public:\n    /// Construct a cursor for extraction from the given offset.\n    explicit Cursor(uint64_t Offset) : Offset(Offset), Err(Error::success()) {}\n\n    /// Checks whether the cursor is valid (i.e. no errors were encountered). In\n    /// case of errors, this does not clear the error flag -- one must call\n    /// takeError() instead.\n    explicit operator bool() { return !Err; }\n\n    /// Return the current position of this Cursor. In the error state this is\n    /// the position of the Cursor before the first error was encountered.\n    uint64_t tell() const { return Offset; }\n\n    /// Return error contained inside this Cursor, if any. Clears the internal\n    /// Cursor state.\n    Error takeError() { return std::move(Err); }\n  };\n\n  /// Construct with a buffer that is owned by the caller.\n  ///\n  /// This constructor allows us to use data that is owned by the\n  /// caller. The data must stay around as long as this object is\n  /// valid.\n  DataExtractor(StringRef Data, bool IsLittleEndian, uint8_t AddressSize)\n    : Data(Data), IsLittleEndian(IsLittleEndian), AddressSize(AddressSize) {}\n  DataExtractor(ArrayRef<uint8_t> Data, bool IsLittleEndian,\n                uint8_t AddressSize)\n      : Data(StringRef(reinterpret_cast<const char *>(Data.data()),\n                       Data.size())),\n        IsLittleEndian(IsLittleEndian), AddressSize(AddressSize) {}\n\n  /// Get the data pointed to by this extractor.\n  StringRef getData() const { return Data; }\n  /// Get the endianness for this extractor.\n  bool isLittleEndian() const { return IsLittleEndian; }\n  /// Get the address size for this extractor.\n  uint8_t getAddressSize() const { return AddressSize; }\n  /// Set the address size for this extractor.\n  void setAddressSize(uint8_t Size) { AddressSize = Size; }\n\n  /// Extract a C string from \\a *offset_ptr.\n  ///\n  /// Returns a pointer to a C String from the data at the offset\n  /// pointed to by \\a offset_ptr. A variable length NULL terminated C\n  /// string will be extracted and the \\a offset_ptr will be\n  /// updated with the offset of the byte that follows the NULL\n  /// terminator byte.\n  ///\n  /// @param[in,out] OffsetPtr\n  ///     A pointer to an offset within the data that will be advanced\n  ///     by the appropriate number of bytes if the value is extracted\n  ///     correctly. If the offset is out of bounds or there are not\n  ///     enough bytes to extract this value, the offset will be left\n  ///     unmodified.\n  ///\n  /// @param[in,out] Err\n  ///     A pointer to an Error object. Upon return the Error object is set to\n  ///     indicate the result (success/failure) of the function. If the Error\n  ///     object is already set when calling this function, no extraction is\n  ///     performed.\n  ///\n  /// @return\n  ///     A pointer to the C string value in the data. If the offset\n  ///     pointed to by \\a offset_ptr is out of bounds, or if the\n  ///     offset plus the length of the C string is out of bounds,\n  ///     NULL will be returned.\n  const char *getCStr(uint64_t *OffsetPtr, Error *Err = nullptr) const {\n    return getCStrRef(OffsetPtr, Err).data();\n  }\n\n  /// Extract a C string from the location given by the cursor. In case of an\n  /// extraction error, or if the cursor is already in an error state, a\n  /// nullptr is returned.\n  const char *getCStr(Cursor &C) const { return getCStrRef(C).data(); }\n\n  /// Extract a C string from \\a *offset_ptr.\n  ///\n  /// Returns a StringRef for the C String from the data at the offset\n  /// pointed to by \\a offset_ptr. A variable length NULL terminated C\n  /// string will be extracted and the \\a offset_ptr will be\n  /// updated with the offset of the byte that follows the NULL\n  /// terminator byte.\n  ///\n  /// \\param[in,out] OffsetPtr\n  ///     A pointer to an offset within the data that will be advanced\n  ///     by the appropriate number of bytes if the value is extracted\n  ///     correctly. If the offset is out of bounds or there are not\n  ///     enough bytes to extract this value, the offset will be left\n  ///     unmodified.\n  ///\n  /// @param[in,out] Err\n  ///     A pointer to an Error object. Upon return the Error object is set to\n  ///     indicate the result (success/failure) of the function. If the Error\n  ///     object is already set when calling this function, no extraction is\n  ///     performed.\n  ///\n  /// \\return\n  ///     A StringRef for the C string value in the data. If the offset\n  ///     pointed to by \\a offset_ptr is out of bounds, or if the\n  ///     offset plus the length of the C string is out of bounds,\n  ///     a default-initialized StringRef will be returned.\n  StringRef getCStrRef(uint64_t *OffsetPtr, Error *Err = nullptr) const;\n\n  /// Extract a C string (as a StringRef) from the location given by the cursor.\n  /// In case of an extraction error, or if the cursor is already in an error\n  /// state, a default-initialized StringRef is returned.\n  StringRef getCStrRef(Cursor &C) const {\n    return getCStrRef(&C.Offset, &C.Err);\n  }\n\n  /// Extract a fixed length string from \\a *OffsetPtr and consume \\a Length\n  /// bytes.\n  ///\n  /// Returns a StringRef for the string from the data at the offset\n  /// pointed to by \\a OffsetPtr. A fixed length C string will be extracted\n  /// and the \\a OffsetPtr will be advanced by \\a Length bytes.\n  ///\n  /// \\param[in,out] OffsetPtr\n  ///     A pointer to an offset within the data that will be advanced\n  ///     by the appropriate number of bytes if the value is extracted\n  ///     correctly. If the offset is out of bounds or there are not\n  ///     enough bytes to extract this value, the offset will be left\n  ///     unmodified.\n  ///\n  /// \\param[in] Length\n  ///     The length of the fixed length string to extract. If there are not\n  ///     enough bytes in the data to extract the full string, the offset will\n  ///     be left unmodified.\n  ///\n  /// \\param[in] TrimChars\n  ///     A set of characters to trim from the end of the string. Fixed length\n  ///     strings are commonly either NULL terminated by one or more zero\n  ///     bytes. Some clients have one or more spaces at the end of the string,\n  ///     but a good default is to trim the NULL characters.\n  ///\n  /// \\return\n  ///     A StringRef for the C string value in the data. If the offset\n  ///     pointed to by \\a OffsetPtr is out of bounds, or if the\n  ///     offset plus the length of the C string is out of bounds,\n  ///     a default-initialized StringRef will be returned.\n  StringRef getFixedLengthString(uint64_t *OffsetPtr,\n      uint64_t Length, StringRef TrimChars = {\"\\0\", 1}) const;\n\n  /// Extract a fixed number of bytes from the specified offset.\n  ///\n  /// Returns a StringRef for the bytes from the data at the offset\n  /// pointed to by \\a OffsetPtr. A fixed length C string will be extracted\n  /// and the \\a OffsetPtr will be advanced by \\a Length bytes.\n  ///\n  /// \\param[in,out] OffsetPtr\n  ///     A pointer to an offset within the data that will be advanced\n  ///     by the appropriate number of bytes if the value is extracted\n  ///     correctly. If the offset is out of bounds or there are not\n  ///     enough bytes to extract this value, the offset will be left\n  ///     unmodified.\n  ///\n  /// \\param[in] Length\n  ///     The number of bytes to extract. If there are not enough bytes in the\n  ///     data to extract all of the bytes, the offset will be left unmodified.\n  ///\n  /// @param[in,out] Err\n  ///     A pointer to an Error object. Upon return the Error object is set to\n  ///     indicate the result (success/failure) of the function. If the Error\n  ///     object is already set when calling this function, no extraction is\n  ///     performed.\n  ///\n  /// \\return\n  ///     A StringRef for the extracted bytes. If the offset pointed to by\n  ///     \\a OffsetPtr is out of bounds, or if the offset plus the length\n  ///     is out of bounds, a default-initialized StringRef will be returned.\n  StringRef getBytes(uint64_t *OffsetPtr, uint64_t Length,\n                     Error *Err = nullptr) const;\n\n  /// Extract a fixed number of bytes from the location given by the cursor. In\n  /// case of an extraction error, or if the cursor is already in an error\n  /// state, a default-initialized StringRef is returned.\n  StringRef getBytes(Cursor &C, uint64_t Length) {\n    return getBytes(&C.Offset, Length, &C.Err);\n  }\n\n  /// Extract an unsigned integer of size \\a byte_size from \\a\n  /// *offset_ptr.\n  ///\n  /// Extract a single unsigned integer value and update the offset\n  /// pointed to by \\a offset_ptr. The size of the extracted integer\n  /// is specified by the \\a byte_size argument. \\a byte_size should\n  /// have a value greater than or equal to one and less than or equal\n  /// to eight since the return value is 64 bits wide. Any\n  /// \\a byte_size values less than 1 or greater than 8 will result in\n  /// nothing being extracted, and zero being returned.\n  ///\n  /// @param[in,out] offset_ptr\n  ///     A pointer to an offset within the data that will be advanced\n  ///     by the appropriate number of bytes if the value is extracted\n  ///     correctly. If the offset is out of bounds or there are not\n  ///     enough bytes to extract this value, the offset will be left\n  ///     unmodified.\n  ///\n  /// @param[in] byte_size\n  ///     The size in byte of the integer to extract.\n  ///\n  /// @param[in,out] Err\n  ///     A pointer to an Error object. Upon return the Error object is set to\n  ///     indicate the result (success/failure) of the function. If the Error\n  ///     object is already set when calling this function, no extraction is\n  ///     performed.\n  ///\n  /// @return\n  ///     The unsigned integer value that was extracted, or zero on\n  ///     failure.\n  uint64_t getUnsigned(uint64_t *offset_ptr, uint32_t byte_size,\n                       Error *Err = nullptr) const;\n\n  /// Extract an unsigned integer of the given size from the location given by\n  /// the cursor. In case of an extraction error, or if the cursor is already in\n  /// an error state, zero is returned.\n  uint64_t getUnsigned(Cursor &C, uint32_t Size) const {\n    return getUnsigned(&C.Offset, Size, &C.Err);\n  }\n\n  /// Extract an signed integer of size \\a byte_size from \\a *offset_ptr.\n  ///\n  /// Extract a single signed integer value (sign extending if required)\n  /// and update the offset pointed to by \\a offset_ptr. The size of\n  /// the extracted integer is specified by the \\a byte_size argument.\n  /// \\a byte_size should have a value greater than or equal to one\n  /// and less than or equal to eight since the return value is 64\n  /// bits wide. Any \\a byte_size values less than 1 or greater than\n  /// 8 will result in nothing being extracted, and zero being returned.\n  ///\n  /// @param[in,out] offset_ptr\n  ///     A pointer to an offset within the data that will be advanced\n  ///     by the appropriate number of bytes if the value is extracted\n  ///     correctly. If the offset is out of bounds or there are not\n  ///     enough bytes to extract this value, the offset will be left\n  ///     unmodified.\n  ///\n  /// @param[in] size\n  ///     The size in bytes of the integer to extract.\n  ///\n  /// @return\n  ///     The sign extended signed integer value that was extracted,\n  ///     or zero on failure.\n  int64_t getSigned(uint64_t *offset_ptr, uint32_t size) const;\n\n  //------------------------------------------------------------------\n  /// Extract an pointer from \\a *offset_ptr.\n  ///\n  /// Extract a single pointer from the data and update the offset\n  /// pointed to by \\a offset_ptr. The size of the extracted pointer\n  /// is \\a getAddressSize(), so the address size has to be\n  /// set correctly prior to extracting any pointer values.\n  ///\n  /// @param[in,out] offset_ptr\n  ///     A pointer to an offset within the data that will be advanced\n  ///     by the appropriate number of bytes if the value is extracted\n  ///     correctly. If the offset is out of bounds or there are not\n  ///     enough bytes to extract this value, the offset will be left\n  ///     unmodified.\n  ///\n  /// @return\n  ///     The extracted pointer value as a 64 integer.\n  uint64_t getAddress(uint64_t *offset_ptr) const {\n    return getUnsigned(offset_ptr, AddressSize);\n  }\n\n  /// Extract a pointer-sized unsigned integer from the location given by the\n  /// cursor. In case of an extraction error, or if the cursor is already in\n  /// an error state, zero is returned.\n  uint64_t getAddress(Cursor &C) const { return getUnsigned(C, AddressSize); }\n\n  /// Extract a uint8_t value from \\a *offset_ptr.\n  ///\n  /// Extract a single uint8_t from the binary data at the offset\n  /// pointed to by \\a offset_ptr, and advance the offset on success.\n  ///\n  /// @param[in,out] offset_ptr\n  ///     A pointer to an offset within the data that will be advanced\n  ///     by the appropriate number of bytes if the value is extracted\n  ///     correctly. If the offset is out of bounds or there are not\n  ///     enough bytes to extract this value, the offset will be left\n  ///     unmodified.\n  ///\n  /// @param[in,out] Err\n  ///     A pointer to an Error object. Upon return the Error object is set to\n  ///     indicate the result (success/failure) of the function. If the Error\n  ///     object is already set when calling this function, no extraction is\n  ///     performed.\n  ///\n  /// @return\n  ///     The extracted uint8_t value.\n  uint8_t getU8(uint64_t *offset_ptr, Error *Err = nullptr) const;\n\n  /// Extract a single uint8_t value from the location given by the cursor. In\n  /// case of an extraction error, or if the cursor is already in an error\n  /// state, zero is returned.\n  uint8_t getU8(Cursor &C) const { return getU8(&C.Offset, &C.Err); }\n\n  /// Extract \\a count uint8_t values from \\a *offset_ptr.\n  ///\n  /// Extract \\a count uint8_t values from the binary data at the\n  /// offset pointed to by \\a offset_ptr, and advance the offset on\n  /// success. The extracted values are copied into \\a dst.\n  ///\n  /// @param[in,out] offset_ptr\n  ///     A pointer to an offset within the data that will be advanced\n  ///     by the appropriate number of bytes if the value is extracted\n  ///     correctly. If the offset is out of bounds or there are not\n  ///     enough bytes to extract this value, the offset will be left\n  ///     unmodified.\n  ///\n  /// @param[out] dst\n  ///     A buffer to copy \\a count uint8_t values into. \\a dst must\n  ///     be large enough to hold all requested data.\n  ///\n  /// @param[in] count\n  ///     The number of uint8_t values to extract.\n  ///\n  /// @return\n  ///     \\a dst if all values were properly extracted and copied,\n  ///     NULL otherise.\n  uint8_t *getU8(uint64_t *offset_ptr, uint8_t *dst, uint32_t count) const;\n\n  /// Extract \\a Count uint8_t values from the location given by the cursor and\n  /// store them into the destination buffer. In case of an extraction error, or\n  /// if the cursor is already in an error state, a nullptr is returned and the\n  /// destination buffer is left unchanged.\n  uint8_t *getU8(Cursor &C, uint8_t *Dst, uint32_t Count) const;\n\n  /// Extract \\a Count uint8_t values from the location given by the cursor and\n  /// store them into the destination vector. The vector is resized to fit the\n  /// extracted data. In case of an extraction error, or if the cursor is\n  /// already in an error state, the destination vector is left unchanged and\n  /// cursor is placed into an error state.\n  void getU8(Cursor &C, SmallVectorImpl<uint8_t> &Dst, uint32_t Count) const {\n    if (isValidOffsetForDataOfSize(C.Offset, Count))\n      Dst.resize(Count);\n\n    // This relies on the fact that getU8 will not attempt to write to the\n    // buffer if isValidOffsetForDataOfSize(C.Offset, Count) is false.\n    getU8(C, Dst.data(), Count);\n  }\n\n  //------------------------------------------------------------------\n  /// Extract a uint16_t value from \\a *offset_ptr.\n  ///\n  /// Extract a single uint16_t from the binary data at the offset\n  /// pointed to by \\a offset_ptr, and update the offset on success.\n  ///\n  /// @param[in,out] offset_ptr\n  ///     A pointer to an offset within the data that will be advanced\n  ///     by the appropriate number of bytes if the value is extracted\n  ///     correctly. If the offset is out of bounds or there are not\n  ///     enough bytes to extract this value, the offset will be left\n  ///     unmodified.\n  ///\n  /// @param[in,out] Err\n  ///     A pointer to an Error object. Upon return the Error object is set to\n  ///     indicate the result (success/failure) of the function. If the Error\n  ///     object is already set when calling this function, no extraction is\n  ///     performed.\n  ///\n  /// @return\n  ///     The extracted uint16_t value.\n  //------------------------------------------------------------------\n  uint16_t getU16(uint64_t *offset_ptr, Error *Err = nullptr) const;\n\n  /// Extract a single uint16_t value from the location given by the cursor. In\n  /// case of an extraction error, or if the cursor is already in an error\n  /// state, zero is returned.\n  uint16_t getU16(Cursor &C) const { return getU16(&C.Offset, &C.Err); }\n\n  /// Extract \\a count uint16_t values from \\a *offset_ptr.\n  ///\n  /// Extract \\a count uint16_t values from the binary data at the\n  /// offset pointed to by \\a offset_ptr, and advance the offset on\n  /// success. The extracted values are copied into \\a dst.\n  ///\n  /// @param[in,out] offset_ptr\n  ///     A pointer to an offset within the data that will be advanced\n  ///     by the appropriate number of bytes if the value is extracted\n  ///     correctly. If the offset is out of bounds or there are not\n  ///     enough bytes to extract this value, the offset will be left\n  ///     unmodified.\n  ///\n  /// @param[out] dst\n  ///     A buffer to copy \\a count uint16_t values into. \\a dst must\n  ///     be large enough to hold all requested data.\n  ///\n  /// @param[in] count\n  ///     The number of uint16_t values to extract.\n  ///\n  /// @return\n  ///     \\a dst if all values were properly extracted and copied,\n  ///     NULL otherise.\n  uint16_t *getU16(uint64_t *offset_ptr, uint16_t *dst, uint32_t count) const;\n\n  /// Extract a 24-bit unsigned value from \\a *offset_ptr and return it\n  /// in a uint32_t.\n  ///\n  /// Extract 3 bytes from the binary data at the offset pointed to by\n  /// \\a offset_ptr, construct a uint32_t from them and update the offset\n  /// on success.\n  ///\n  /// @param[in,out] OffsetPtr\n  ///     A pointer to an offset within the data that will be advanced\n  ///     by the 3 bytes if the value is extracted correctly. If the offset\n  ///     is out of bounds or there are not enough bytes to extract this value,\n  ///     the offset will be left unmodified.\n  ///\n  /// @param[in,out] Err\n  ///     A pointer to an Error object. Upon return the Error object is set to\n  ///     indicate the result (success/failure) of the function. If the Error\n  ///     object is already set when calling this function, no extraction is\n  ///     performed.\n  ///\n  /// @return\n  ///     The extracted 24-bit value represented in a uint32_t.\n  uint32_t getU24(uint64_t *OffsetPtr, Error *Err = nullptr) const;\n\n  /// Extract a single 24-bit unsigned value from the location given by the\n  /// cursor. In case of an extraction error, or if the cursor is already in an\n  /// error state, zero is returned.\n  uint32_t getU24(Cursor &C) const { return getU24(&C.Offset, &C.Err); }\n\n  /// Extract a uint32_t value from \\a *offset_ptr.\n  ///\n  /// Extract a single uint32_t from the binary data at the offset\n  /// pointed to by \\a offset_ptr, and update the offset on success.\n  ///\n  /// @param[in,out] offset_ptr\n  ///     A pointer to an offset within the data that will be advanced\n  ///     by the appropriate number of bytes if the value is extracted\n  ///     correctly. If the offset is out of bounds or there are not\n  ///     enough bytes to extract this value, the offset will be left\n  ///     unmodified.\n  ///\n  /// @param[in,out] Err\n  ///     A pointer to an Error object. Upon return the Error object is set to\n  ///     indicate the result (success/failure) of the function. If the Error\n  ///     object is already set when calling this function, no extraction is\n  ///     performed.\n  ///\n  /// @return\n  ///     The extracted uint32_t value.\n  uint32_t getU32(uint64_t *offset_ptr, Error *Err = nullptr) const;\n\n  /// Extract a single uint32_t value from the location given by the cursor. In\n  /// case of an extraction error, or if the cursor is already in an error\n  /// state, zero is returned.\n  uint32_t getU32(Cursor &C) const { return getU32(&C.Offset, &C.Err); }\n\n  /// Extract \\a count uint32_t values from \\a *offset_ptr.\n  ///\n  /// Extract \\a count uint32_t values from the binary data at the\n  /// offset pointed to by \\a offset_ptr, and advance the offset on\n  /// success. The extracted values are copied into \\a dst.\n  ///\n  /// @param[in,out] offset_ptr\n  ///     A pointer to an offset within the data that will be advanced\n  ///     by the appropriate number of bytes if the value is extracted\n  ///     correctly. If the offset is out of bounds or there are not\n  ///     enough bytes to extract this value, the offset will be left\n  ///     unmodified.\n  ///\n  /// @param[out] dst\n  ///     A buffer to copy \\a count uint32_t values into. \\a dst must\n  ///     be large enough to hold all requested data.\n  ///\n  /// @param[in] count\n  ///     The number of uint32_t values to extract.\n  ///\n  /// @return\n  ///     \\a dst if all values were properly extracted and copied,\n  ///     NULL otherise.\n  uint32_t *getU32(uint64_t *offset_ptr, uint32_t *dst, uint32_t count) const;\n\n  /// Extract a uint64_t value from \\a *offset_ptr.\n  ///\n  /// Extract a single uint64_t from the binary data at the offset\n  /// pointed to by \\a offset_ptr, and update the offset on success.\n  ///\n  /// @param[in,out] offset_ptr\n  ///     A pointer to an offset within the data that will be advanced\n  ///     by the appropriate number of bytes if the value is extracted\n  ///     correctly. If the offset is out of bounds or there are not\n  ///     enough bytes to extract this value, the offset will be left\n  ///     unmodified.\n  ///\n  /// @param[in,out] Err\n  ///     A pointer to an Error object. Upon return the Error object is set to\n  ///     indicate the result (success/failure) of the function. If the Error\n  ///     object is already set when calling this function, no extraction is\n  ///     performed.\n  ///\n  /// @return\n  ///     The extracted uint64_t value.\n  uint64_t getU64(uint64_t *offset_ptr, Error *Err = nullptr) const;\n\n  /// Extract a single uint64_t value from the location given by the cursor. In\n  /// case of an extraction error, or if the cursor is already in an error\n  /// state, zero is returned.\n  uint64_t getU64(Cursor &C) const { return getU64(&C.Offset, &C.Err); }\n\n  /// Extract \\a count uint64_t values from \\a *offset_ptr.\n  ///\n  /// Extract \\a count uint64_t values from the binary data at the\n  /// offset pointed to by \\a offset_ptr, and advance the offset on\n  /// success. The extracted values are copied into \\a dst.\n  ///\n  /// @param[in,out] offset_ptr\n  ///     A pointer to an offset within the data that will be advanced\n  ///     by the appropriate number of bytes if the value is extracted\n  ///     correctly. If the offset is out of bounds or there are not\n  ///     enough bytes to extract this value, the offset will be left\n  ///     unmodified.\n  ///\n  /// @param[out] dst\n  ///     A buffer to copy \\a count uint64_t values into. \\a dst must\n  ///     be large enough to hold all requested data.\n  ///\n  /// @param[in] count\n  ///     The number of uint64_t values to extract.\n  ///\n  /// @return\n  ///     \\a dst if all values were properly extracted and copied,\n  ///     NULL otherise.\n  uint64_t *getU64(uint64_t *offset_ptr, uint64_t *dst, uint32_t count) const;\n\n  /// Extract a signed LEB128 value from \\a *offset_ptr.\n  ///\n  /// Extracts an signed LEB128 number from this object's data\n  /// starting at the offset pointed to by \\a offset_ptr. The offset\n  /// pointed to by \\a offset_ptr will be updated with the offset of\n  /// the byte following the last extracted byte.\n  ///\n  /// @param[in,out] OffsetPtr\n  ///     A pointer to an offset within the data that will be advanced\n  ///     by the appropriate number of bytes if the value is extracted\n  ///     correctly. If the offset is out of bounds or there are not\n  ///     enough bytes to extract this value, the offset will be left\n  ///     unmodified.\n  ///\n  /// @param[in,out] Err\n  ///     A pointer to an Error object. Upon return the Error object is set to\n  ///     indicate the result (success/failure) of the function. If the Error\n  ///     object is already set when calling this function, no extraction is\n  ///     performed.\n  ///\n  /// @return\n  ///     The extracted signed integer value.\n  int64_t getSLEB128(uint64_t *OffsetPtr, Error *Err = nullptr) const;\n\n  /// Extract an signed LEB128 value from the location given by the cursor.\n  /// In case of an extraction error, or if the cursor is already in an error\n  /// state, zero is returned.\n  int64_t getSLEB128(Cursor &C) const { return getSLEB128(&C.Offset, &C.Err); }\n\n  /// Extract a unsigned LEB128 value from \\a *offset_ptr.\n  ///\n  /// Extracts an unsigned LEB128 number from this object's data\n  /// starting at the offset pointed to by \\a offset_ptr. The offset\n  /// pointed to by \\a offset_ptr will be updated with the offset of\n  /// the byte following the last extracted byte.\n  ///\n  /// @param[in,out] offset_ptr\n  ///     A pointer to an offset within the data that will be advanced\n  ///     by the appropriate number of bytes if the value is extracted\n  ///     correctly. If the offset is out of bounds or there are not\n  ///     enough bytes to extract this value, the offset will be left\n  ///     unmodified.\n  ///\n  /// @param[in,out] Err\n  ///     A pointer to an Error object. Upon return the Error object is set to\n  ///     indicate the result (success/failure) of the function. If the Error\n  ///     object is already set when calling this function, no extraction is\n  ///     performed.\n  ///\n  /// @return\n  ///     The extracted unsigned integer value.\n  uint64_t getULEB128(uint64_t *offset_ptr, llvm::Error *Err = nullptr) const;\n\n  /// Extract an unsigned LEB128 value from the location given by the cursor.\n  /// In case of an extraction error, or if the cursor is already in an error\n  /// state, zero is returned.\n  uint64_t getULEB128(Cursor &C) const { return getULEB128(&C.Offset, &C.Err); }\n\n  /// Advance the Cursor position by the given number of bytes. No-op if the\n  /// cursor is in an error state.\n  void skip(Cursor &C, uint64_t Length) const;\n\n  /// Return true iff the cursor is at the end of the buffer, regardless of the\n  /// error state of the cursor. The only way both eof and error states can be\n  /// true is if one attempts a read while the cursor is at the very end of the\n  /// data buffer.\n  bool eof(const Cursor &C) const { return size() == C.Offset; }\n\n  /// Test the validity of \\a offset.\n  ///\n  /// @return\n  ///     \\b true if \\a offset is a valid offset into the data in this\n  ///     object, \\b false otherwise.\n  bool isValidOffset(uint64_t offset) const { return size() > offset; }\n\n  /// Test the availability of \\a length bytes of data from \\a offset.\n  ///\n  /// @return\n  ///     \\b true if \\a offset is a valid offset and there are \\a\n  ///     length bytes available at that offset, \\b false otherwise.\n  bool isValidOffsetForDataOfSize(uint64_t offset, uint64_t length) const {\n    return offset + length >= offset && isValidOffset(offset + length - 1);\n  }\n\n  /// Test the availability of enough bytes of data for a pointer from\n  /// \\a offset. The size of a pointer is \\a getAddressSize().\n  ///\n  /// @return\n  ///     \\b true if \\a offset is a valid offset and there are enough\n  ///     bytes for a pointer available at that offset, \\b false\n  ///     otherwise.\n  bool isValidOffsetForAddress(uint64_t offset) const {\n    return isValidOffsetForDataOfSize(offset, AddressSize);\n  }\n\n  /// Return the number of bytes in the underlying buffer.\n  size_t size() const { return Data.size(); }\n\nprotected:\n  // Make it possible for subclasses to access these fields without making them\n  // public.\n  static uint64_t &getOffset(Cursor &C) { return C.Offset; }\n  static Error &getError(Cursor &C) { return C.Err; }\n\nprivate:\n  /// If it is possible to read \\a Size bytes at offset \\a Offset, returns \\b\n  /// true. Otherwise, returns \\b false. If \\a E is not nullptr, also sets the\n  /// error object to indicate an error.\n  bool prepareRead(uint64_t Offset, uint64_t Size, Error *E) const;\n\n  template <typename T> T getU(uint64_t *OffsetPtr, Error *Err) const;\n  template <typename T>\n  T *getUs(uint64_t *OffsetPtr, T *Dst, uint32_t Count, Error *Err) const;\n};\n\n} // namespace llvm\n\n#endif\n"}, "81": {"id": 81, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/FileCollector.h", "content": "//===-- FileCollector.h -----------------------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_SUPPORT_FILECOLLECTOR_H\n#define LLVM_SUPPORT_FILECOLLECTOR_H\n\n#include \"llvm/ADT/SmallVector.h\"\n#include \"llvm/ADT/StringMap.h\"\n#include \"llvm/ADT/StringSet.h\"\n#include \"llvm/Support/VirtualFileSystem.h\"\n#include <mutex>\n#include <string>\n\nnamespace llvm {\nclass FileCollectorFileSystem;\nclass Twine;\n\nclass FileCollectorBase {\npublic:\n  FileCollectorBase();\n  virtual ~FileCollectorBase();\n\n  void addFile(const Twine &file);\n  void addDirectory(const Twine &Dir);\n\nprotected:\n  bool markAsSeen(StringRef Path) {\n    if (Path.empty())\n      return false;\n    return Seen.insert(Path).second;\n  }\n\n  virtual void addFileImpl(StringRef SrcPath) = 0;\n\n  virtual llvm::vfs::directory_iterator\n  addDirectoryImpl(const llvm::Twine &Dir,\n                   IntrusiveRefCntPtr<vfs::FileSystem> FS,\n                   std::error_code &EC) = 0;\n\n  /// Synchronizes access to internal data structures.\n  std::mutex Mutex;\n\n  /// Tracks already seen files so they can be skipped.\n  StringSet<> Seen;\n};\n\n/// Captures file system interaction and generates data to be later replayed\n/// with the RedirectingFileSystem.\n///\n/// For any file that gets accessed we eventually create:\n/// - a copy of the file inside Root\n/// - a record in RedirectingFileSystem mapping that maps:\n///   current real path -> path to the copy in Root\n///\n/// That intent is that later when the mapping is used by RedirectingFileSystem\n/// it simulates the state of FS that we collected.\n///\n/// We generate file copies and mapping lazily - see writeMapping and copyFiles.\n/// We don't try to capture the state of the file at the exact time when it's\n/// accessed. Files might get changed, deleted ... we record only the \"final\"\n/// state.\n///\n/// In order to preserve the relative topology of files we use their real paths\n/// as relative paths inside of the Root.\nclass FileCollector : public FileCollectorBase {\npublic:\n  /// Helper utility that encapsulates the logic for canonicalizing a virtual\n  /// path and a path to copy from.\n  class PathCanonicalizer {\n  public:\n    struct PathStorage {\n      SmallString<256> CopyFrom;\n      SmallString<256> VirtualPath;\n    };\n\n    /// Canonicalize a pair of virtual and real paths.\n    PathStorage canonicalize(StringRef SrcPath);\n\n  private:\n    /// Replace with a (mostly) real path, or don't modify. Resolves symlinks\n    /// in the directory, using \\a CachedDirs to avoid redundant lookups, but\n    /// leaves the filename as a possible symlink.\n    void updateWithRealPath(SmallVectorImpl<char> &Path);\n\n    StringMap<std::string> CachedDirs;\n  };\n\n  /// \\p Root is the directory where collected files are will be stored.\n  /// \\p OverlayRoot is VFS mapping root.\n  /// \\p Root directory gets created in copyFiles unless it already exists.\n  FileCollector(std::string Root, std::string OverlayRoot);\n\n  /// Write the yaml mapping (for the VFS) to the given file.\n  std::error_code writeMapping(StringRef MappingFile);\n\n  /// Copy the files into the root directory.\n  ///\n  /// When StopOnError is true (the default) we abort as soon as one file\n  /// cannot be copied. This is relatively common, for example when a file was\n  /// removed after it was added to the mapping.\n  std::error_code copyFiles(bool StopOnError = true);\n\n  /// Create a VFS that uses \\p Collector to collect files accessed via \\p\n  /// BaseFS.\n  static IntrusiveRefCntPtr<vfs::FileSystem>\n  createCollectorVFS(IntrusiveRefCntPtr<vfs::FileSystem> BaseFS,\n                     std::shared_ptr<FileCollector> Collector);\n\nprivate:\n  friend FileCollectorFileSystem;\n\n  void addFileToMapping(StringRef VirtualPath, StringRef RealPath) {\n    if (sys::fs::is_directory(VirtualPath))\n      VFSWriter.addDirectoryMapping(VirtualPath, RealPath);\n    else\n      VFSWriter.addFileMapping(VirtualPath, RealPath);\n  }\n\nprotected:\n  void addFileImpl(StringRef SrcPath) override;\n\n  llvm::vfs::directory_iterator\n  addDirectoryImpl(const llvm::Twine &Dir,\n                   IntrusiveRefCntPtr<vfs::FileSystem> FS,\n                   std::error_code &EC) override;\n\n  /// The directory where collected files are copied to in copyFiles().\n  const std::string Root;\n\n  /// The root directory where the VFS overlay lives.\n  const std::string OverlayRoot;\n\n  /// The yaml mapping writer.\n  vfs::YAMLVFSWriter VFSWriter;\n\n  /// Helper utility for canonicalizing paths.\n  PathCanonicalizer Canonicalizer;\n};\n\n} // end namespace llvm\n\n#endif // LLVM_SUPPORT_FILECOLLECTOR_H\n"}, "85": {"id": 85, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/JSON.h", "content": "//===--- JSON.h - JSON values, parsing and serialization -------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===---------------------------------------------------------------------===//\n///\n/// \\file\n/// This file supports working with JSON data.\n///\n/// It comprises:\n///\n/// - classes which hold dynamically-typed parsed JSON structures\n///   These are value types that can be composed, inspected, and modified.\n///   See json::Value, and the related types json::Object and json::Array.\n///\n/// - functions to parse JSON text into Values, and to serialize Values to text.\n///   See parse(), operator<<, and format_provider.\n///\n/// - a convention and helpers for mapping between json::Value and user-defined\n///   types. See fromJSON(), ObjectMapper, and the class comment on Value.\n///\n/// - an output API json::OStream which can emit JSON without materializing\n///   all structures as json::Value.\n///\n/// Typically, JSON data would be read from an external source, parsed into\n/// a Value, and then converted into some native data structure before doing\n/// real work on it. (And vice versa when writing).\n///\n/// Other serialization mechanisms you may consider:\n///\n/// - YAML is also text-based, and more human-readable than JSON. It's a more\n///   complex format and data model, and YAML parsers aren't ubiquitous.\n///   YAMLParser.h is a streaming parser suitable for parsing large documents\n///   (including JSON, as YAML is a superset). It can be awkward to use\n///   directly. YAML I/O (YAMLTraits.h) provides data mapping that is more\n///   declarative than the toJSON/fromJSON conventions here.\n///\n/// - LLVM bitstream is a space- and CPU- efficient binary format. Typically it\n///   encodes LLVM IR (\"bitcode\"), but it can be a container for other data.\n///   Low-level reader/writer libraries are in Bitstream/Bitstream*.h\n///\n//===---------------------------------------------------------------------===//\n\n#ifndef LLVM_SUPPORT_JSON_H\n#define LLVM_SUPPORT_JSON_H\n\n#include \"llvm/ADT/DenseMap.h\"\n#include \"llvm/ADT/SmallVector.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/Support/Error.h\"\n#include \"llvm/Support/FormatVariadic.h\"\n#include \"llvm/Support/raw_ostream.h\"\n#include <map>\n\nnamespace llvm {\nnamespace json {\n\n// === String encodings ===\n//\n// JSON strings are character sequences (not byte sequences like std::string).\n// We need to know the encoding, and for simplicity only support UTF-8.\n//\n//   - When parsing, invalid UTF-8 is a syntax error like any other\n//\n//   - When creating Values from strings, callers must ensure they are UTF-8.\n//        with asserts on, invalid UTF-8 will crash the program\n//        with asserts off, we'll substitute the replacement character (U+FFFD)\n//     Callers can use json::isUTF8() and json::fixUTF8() for validation.\n//\n//   - When retrieving strings from Values (e.g. asString()), the result will\n//     always be valid UTF-8.\n\n/// Returns true if \\p S is valid UTF-8, which is required for use as JSON.\n/// If it returns false, \\p Offset is set to a byte offset near the first error.\nbool isUTF8(llvm::StringRef S, size_t *ErrOffset = nullptr);\n/// Replaces invalid UTF-8 sequences in \\p S with the replacement character\n/// (U+FFFD). The returned string is valid UTF-8.\n/// This is much slower than isUTF8, so test that first.\nstd::string fixUTF8(llvm::StringRef S);\n\nclass Array;\nclass ObjectKey;\nclass Value;\ntemplate <typename T> Value toJSON(const llvm::Optional<T> &Opt);\n\n/// An Object is a JSON object, which maps strings to heterogenous JSON values.\n/// It simulates DenseMap<ObjectKey, Value>. ObjectKey is a maybe-owned string.\nclass Object {\n  using Storage = DenseMap<ObjectKey, Value, llvm::DenseMapInfo<StringRef>>;\n  Storage M;\n\npublic:\n  using key_type = ObjectKey;\n  using mapped_type = Value;\n  using value_type = Storage::value_type;\n  using iterator = Storage::iterator;\n  using const_iterator = Storage::const_iterator;\n\n  Object() = default;\n  // KV is a trivial key-value struct for list-initialization.\n  // (using std::pair forces extra copies).\n  struct KV;\n  explicit Object(std::initializer_list<KV> Properties);\n\n  iterator begin() { return M.begin(); }\n  const_iterator begin() const { return M.begin(); }\n  iterator end() { return M.end(); }\n  const_iterator end() const { return M.end(); }\n\n  bool empty() const { return M.empty(); }\n  size_t size() const { return M.size(); }\n\n  void clear() { M.clear(); }\n  std::pair<iterator, bool> insert(KV E);\n  template <typename... Ts>\n  std::pair<iterator, bool> try_emplace(const ObjectKey &K, Ts &&... Args) {\n    return M.try_emplace(K, std::forward<Ts>(Args)...);\n  }\n  template <typename... Ts>\n  std::pair<iterator, bool> try_emplace(ObjectKey &&K, Ts &&... Args) {\n    return M.try_emplace(std::move(K), std::forward<Ts>(Args)...);\n  }\n  bool erase(StringRef K);\n  void erase(iterator I) { M.erase(I); }\n\n  iterator find(StringRef K) { return M.find_as(K); }\n  const_iterator find(StringRef K) const { return M.find_as(K); }\n  // operator[] acts as if Value was default-constructible as null.\n  Value &operator[](const ObjectKey &K);\n  Value &operator[](ObjectKey &&K);\n  // Look up a property, returning nullptr if it doesn't exist.\n  Value *get(StringRef K);\n  const Value *get(StringRef K) const;\n  // Typed accessors return None/nullptr if\n  //   - the property doesn't exist\n  //   - or it has the wrong type\n  llvm::Optional<std::nullptr_t> getNull(StringRef K) const;\n  llvm::Optional<bool> getBoolean(StringRef K) const;\n  llvm::Optional<double> getNumber(StringRef K) const;\n  llvm::Optional<int64_t> getInteger(StringRef K) const;\n  llvm::Optional<llvm::StringRef> getString(StringRef K) const;\n  const json::Object *getObject(StringRef K) const;\n  json::Object *getObject(StringRef K);\n  const json::Array *getArray(StringRef K) const;\n  json::Array *getArray(StringRef K);\n};\nbool operator==(const Object &LHS, const Object &RHS);\ninline bool operator!=(const Object &LHS, const Object &RHS) {\n  return !(LHS == RHS);\n}\n\n/// An Array is a JSON array, which contains heterogeneous JSON values.\n/// It simulates std::vector<Value>.\nclass Array {\n  std::vector<Value> V;\n\npublic:\n  using value_type = Value;\n  using iterator = std::vector<Value>::iterator;\n  using const_iterator = std::vector<Value>::const_iterator;\n\n  Array() = default;\n  explicit Array(std::initializer_list<Value> Elements);\n  template <typename Collection> explicit Array(const Collection &C) {\n    for (const auto &V : C)\n      emplace_back(V);\n  }\n\n  Value &operator[](size_t I) { return V[I]; }\n  const Value &operator[](size_t I) const { return V[I]; }\n  Value &front() { return V.front(); }\n  const Value &front() const { return V.front(); }\n  Value &back() { return V.back(); }\n  const Value &back() const { return V.back(); }\n  Value *data() { return V.data(); }\n  const Value *data() const { return V.data(); }\n\n  iterator begin() { return V.begin(); }\n  const_iterator begin() const { return V.begin(); }\n  iterator end() { return V.end(); }\n  const_iterator end() const { return V.end(); }\n\n  bool empty() const { return V.empty(); }\n  size_t size() const { return V.size(); }\n  void reserve(size_t S) { V.reserve(S); }\n\n  void clear() { V.clear(); }\n  void push_back(const Value &E) { V.push_back(E); }\n  void push_back(Value &&E) { V.push_back(std::move(E)); }\n  template <typename... Args> void emplace_back(Args &&... A) {\n    V.emplace_back(std::forward<Args>(A)...);\n  }\n  void pop_back() { V.pop_back(); }\n  // FIXME: insert() takes const_iterator since C++11, old libstdc++ disagrees.\n  iterator insert(iterator P, const Value &E) { return V.insert(P, E); }\n  iterator insert(iterator P, Value &&E) {\n    return V.insert(P, std::move(E));\n  }\n  template <typename It> iterator insert(iterator P, It A, It Z) {\n    return V.insert(P, A, Z);\n  }\n  template <typename... Args> iterator emplace(const_iterator P, Args &&... A) {\n    return V.emplace(P, std::forward<Args>(A)...);\n  }\n\n  friend bool operator==(const Array &L, const Array &R) { return L.V == R.V; }\n};\ninline bool operator!=(const Array &L, const Array &R) { return !(L == R); }\n\n/// A Value is an JSON value of unknown type.\n/// They can be copied, but should generally be moved.\n///\n/// === Composing values ===\n///\n/// You can implicitly construct Values from:\n///   - strings: std::string, SmallString, formatv, StringRef, char*\n///              (char*, and StringRef are references, not copies!)\n///   - numbers\n///   - booleans\n///   - null: nullptr\n///   - arrays: {\"foo\", 42.0, false}\n///   - serializable things: types with toJSON(const T&)->Value, found by ADL\n///\n/// They can also be constructed from object/array helpers:\n///   - json::Object is a type like map<ObjectKey, Value>\n///   - json::Array is a type like vector<Value>\n/// These can be list-initialized, or used to build up collections in a loop.\n/// json::ary(Collection) converts all items in a collection to Values.\n///\n/// === Inspecting values ===\n///\n/// Each Value is one of the JSON kinds:\n///   null    (nullptr_t)\n///   boolean (bool)\n///   number  (double or int64)\n///   string  (StringRef)\n///   array   (json::Array)\n///   object  (json::Object)\n///\n/// The kind can be queried directly, or implicitly via the typed accessors:\n///   if (Optional<StringRef> S = E.getAsString()\n///     assert(E.kind() == Value::String);\n///\n/// Array and Object also have typed indexing accessors for easy traversal:\n///   Expected<Value> E = parse(R\"( {\"options\": {\"font\": \"sans-serif\"}} )\");\n///   if (Object* O = E->getAsObject())\n///     if (Object* Opts = O->getObject(\"options\"))\n///       if (Optional<StringRef> Font = Opts->getString(\"font\"))\n///         assert(Opts->at(\"font\").kind() == Value::String);\n///\n/// === Converting JSON values to C++ types ===\n///\n/// The convention is to have a deserializer function findable via ADL:\n///     fromJSON(const json::Value&, T&, Path) -> bool\n///\n/// The return value indicates overall success, and Path is used for precise\n/// error reporting. (The Path::Root passed in at the top level fromJSON call\n/// captures any nested error and can render it in context).\n/// If conversion fails, fromJSON calls Path::report() and immediately returns.\n/// This ensures that the first fatal error survives.\n///\n/// Deserializers are provided for:\n///   - bool\n///   - int and int64_t\n///   - double\n///   - std::string\n///   - vector<T>, where T is deserializable\n///   - map<string, T>, where T is deserializable\n///   - Optional<T>, where T is deserializable\n/// ObjectMapper can help writing fromJSON() functions for object types.\n///\n/// For conversion in the other direction, the serializer function is:\n///    toJSON(const T&) -> json::Value\n/// If this exists, then it also allows constructing Value from T, and can\n/// be used to serialize vector<T>, map<string, T>, and Optional<T>.\n///\n/// === Serialization ===\n///\n/// Values can be serialized to JSON:\n///   1) raw_ostream << Value                    // Basic formatting.\n///   2) raw_ostream << formatv(\"{0}\", Value)    // Basic formatting.\n///   3) raw_ostream << formatv(\"{0:2}\", Value)  // Pretty-print with indent 2.\n///\n/// And parsed:\n///   Expected<Value> E = json::parse(\"[1, 2, null]\");\n///   assert(E && E->kind() == Value::Array);\nclass Value {\npublic:\n  enum Kind {\n    Null,\n    Boolean,\n    /// Number values can store both int64s and doubles at full precision,\n    /// depending on what they were constructed/parsed from.\n    Number,\n    String,\n    Array,\n    Object,\n  };\n\n  // It would be nice to have Value() be null. But that would make {} null too.\n  Value(const Value &M) { copyFrom(M); }\n  Value(Value &&M) { moveFrom(std::move(M)); }\n  Value(std::initializer_list<Value> Elements);\n  Value(json::Array &&Elements) : Type(T_Array) {\n    create<json::Array>(std::move(Elements));\n  }\n  template <typename Elt>\n  Value(const std::vector<Elt> &C) : Value(json::Array(C)) {}\n  Value(json::Object &&Properties) : Type(T_Object) {\n    create<json::Object>(std::move(Properties));\n  }\n  template <typename Elt>\n  Value(const std::map<std::string, Elt> &C) : Value(json::Object(C)) {}\n  // Strings: types with value semantics. Must be valid UTF-8.\n  Value(std::string V) : Type(T_String) {\n    if (LLVM_UNLIKELY(!isUTF8(V))) {\n      assert(false && \"Invalid UTF-8 in value used as JSON\");\n      V = fixUTF8(std::move(V));\n    }\n    create<std::string>(std::move(V));\n  }\n  Value(const llvm::SmallVectorImpl<char> &V)\n      : Value(std::string(V.begin(), V.end())) {}\n  Value(const llvm::formatv_object_base &V) : Value(V.str()) {}\n  // Strings: types with reference semantics. Must be valid UTF-8.\n  Value(StringRef V) : Type(T_StringRef) {\n    create<llvm::StringRef>(V);\n    if (LLVM_UNLIKELY(!isUTF8(V))) {\n      assert(false && \"Invalid UTF-8 in value used as JSON\");\n      *this = Value(fixUTF8(V));\n    }\n  }\n  Value(const char *V) : Value(StringRef(V)) {}\n  Value(std::nullptr_t) : Type(T_Null) {}\n  // Boolean (disallow implicit conversions).\n  // (The last template parameter is a dummy to keep templates distinct.)\n  template <typename T,\n            typename = std::enable_if_t<std::is_same<T, bool>::value>,\n            bool = false>\n  Value(T B) : Type(T_Boolean) {\n    create<bool>(B);\n  }\n  // Integers (except boolean). Must be non-narrowing convertible to int64_t.\n  template <typename T, typename = std::enable_if_t<std::is_integral<T>::value>,\n            typename = std::enable_if_t<!std::is_same<T, bool>::value>>\n  Value(T I) : Type(T_Integer) {\n    create<int64_t>(int64_t{I});\n  }\n  // Floating point. Must be non-narrowing convertible to double.\n  template <typename T,\n            typename = std::enable_if_t<std::is_floating_point<T>::value>,\n            double * = nullptr>\n  Value(T D) : Type(T_Double) {\n    create<double>(double{D});\n  }\n  // Serializable types: with a toJSON(const T&)->Value function, found by ADL.\n  template <typename T,\n            typename = std::enable_if_t<std::is_same<\n                Value, decltype(toJSON(*(const T *)nullptr))>::value>,\n            Value * = nullptr>\n  Value(const T &V) : Value(toJSON(V)) {}\n\n  Value &operator=(const Value &M) {\n    destroy();\n    copyFrom(M);\n    return *this;\n  }\n  Value &operator=(Value &&M) {\n    destroy();\n    moveFrom(std::move(M));\n    return *this;\n  }\n  ~Value() { destroy(); }\n\n  Kind kind() const {\n    switch (Type) {\n    case T_Null:\n      return Null;\n    case T_Boolean:\n      return Boolean;\n    case T_Double:\n    case T_Integer:\n      return Number;\n    case T_String:\n    case T_StringRef:\n      return String;\n    case T_Object:\n      return Object;\n    case T_Array:\n      return Array;\n    }\n    llvm_unreachable(\"Unknown kind\");\n  }\n\n  // Typed accessors return None/nullptr if the Value is not of this type.\n  llvm::Optional<std::nullptr_t> getAsNull() const {\n    if (LLVM_LIKELY(Type == T_Null))\n      return nullptr;\n    return llvm::None;\n  }\n  llvm::Optional<bool> getAsBoolean() const {\n    if (LLVM_LIKELY(Type == T_Boolean))\n      return as<bool>();\n    return llvm::None;\n  }\n  llvm::Optional<double> getAsNumber() const {\n    if (LLVM_LIKELY(Type == T_Double))\n      return as<double>();\n    if (LLVM_LIKELY(Type == T_Integer))\n      return as<int64_t>();\n    return llvm::None;\n  }\n  // Succeeds if the Value is a Number, and exactly representable as int64_t.\n  llvm::Optional<int64_t> getAsInteger() const {\n    if (LLVM_LIKELY(Type == T_Integer))\n      return as<int64_t>();\n    if (LLVM_LIKELY(Type == T_Double)) {\n      double D = as<double>();\n      if (LLVM_LIKELY(std::modf(D, &D) == 0.0 &&\n                      D >= double(std::numeric_limits<int64_t>::min()) &&\n                      D <= double(std::numeric_limits<int64_t>::max())))\n        return D;\n    }\n    return llvm::None;\n  }\n  llvm::Optional<llvm::StringRef> getAsString() const {\n    if (Type == T_String)\n      return llvm::StringRef(as<std::string>());\n    if (LLVM_LIKELY(Type == T_StringRef))\n      return as<llvm::StringRef>();\n    return llvm::None;\n  }\n  const json::Object *getAsObject() const {\n    return LLVM_LIKELY(Type == T_Object) ? &as<json::Object>() : nullptr;\n  }\n  json::Object *getAsObject() {\n    return LLVM_LIKELY(Type == T_Object) ? &as<json::Object>() : nullptr;\n  }\n  const json::Array *getAsArray() const {\n    return LLVM_LIKELY(Type == T_Array) ? &as<json::Array>() : nullptr;\n  }\n  json::Array *getAsArray() {\n    return LLVM_LIKELY(Type == T_Array) ? &as<json::Array>() : nullptr;\n  }\n\nprivate:\n  void destroy();\n  void copyFrom(const Value &M);\n  // We allow moving from *const* Values, by marking all members as mutable!\n  // This hack is needed to support initializer-list syntax efficiently.\n  // (std::initializer_list<T> is a container of const T).\n  void moveFrom(const Value &&M);\n  friend class Array;\n  friend class Object;\n\n  template <typename T, typename... U> void create(U &&... V) {\n    new (reinterpret_cast<T *>(&Union)) T(std::forward<U>(V)...);\n  }\n  template <typename T> T &as() const {\n    // Using this two-step static_cast via void * instead of reinterpret_cast\n    // silences a -Wstrict-aliasing false positive from GCC6 and earlier.\n    void *Storage = static_cast<void *>(&Union);\n    return *static_cast<T *>(Storage);\n  }\n\n  friend class OStream;\n\n  enum ValueType : char {\n    T_Null,\n    T_Boolean,\n    T_Double,\n    T_Integer,\n    T_StringRef,\n    T_String,\n    T_Object,\n    T_Array,\n  };\n  // All members mutable, see moveFrom().\n  mutable ValueType Type;\n  mutable llvm::AlignedCharArrayUnion<bool, double, int64_t, llvm::StringRef,\n                                      std::string, json::Array, json::Object>\n      Union;\n  friend bool operator==(const Value &, const Value &);\n};\n\nbool operator==(const Value &, const Value &);\ninline bool operator!=(const Value &L, const Value &R) { return !(L == R); }\n\n/// ObjectKey is a used to capture keys in Object. Like Value but:\n///   - only strings are allowed\n///   - it's optimized for the string literal case (Owned == nullptr)\n/// Like Value, strings must be UTF-8. See isUTF8 documentation for details.\nclass ObjectKey {\npublic:\n  ObjectKey(const char *S) : ObjectKey(StringRef(S)) {}\n  ObjectKey(std::string S) : Owned(new std::string(std::move(S))) {\n    if (LLVM_UNLIKELY(!isUTF8(*Owned))) {\n      assert(false && \"Invalid UTF-8 in value used as JSON\");\n      *Owned = fixUTF8(std::move(*Owned));\n    }\n    Data = *Owned;\n  }\n  ObjectKey(llvm::StringRef S) : Data(S) {\n    if (LLVM_UNLIKELY(!isUTF8(Data))) {\n      assert(false && \"Invalid UTF-8 in value used as JSON\");\n      *this = ObjectKey(fixUTF8(S));\n    }\n  }\n  ObjectKey(const llvm::SmallVectorImpl<char> &V)\n      : ObjectKey(std::string(V.begin(), V.end())) {}\n  ObjectKey(const llvm::formatv_object_base &V) : ObjectKey(V.str()) {}\n\n  ObjectKey(const ObjectKey &C) { *this = C; }\n  ObjectKey(ObjectKey &&C) : ObjectKey(static_cast<const ObjectKey &&>(C)) {}\n  ObjectKey &operator=(const ObjectKey &C) {\n    if (C.Owned) {\n      Owned.reset(new std::string(*C.Owned));\n      Data = *Owned;\n    } else {\n      Data = C.Data;\n    }\n    return *this;\n  }\n  ObjectKey &operator=(ObjectKey &&) = default;\n\n  operator llvm::StringRef() const { return Data; }\n  std::string str() const { return Data.str(); }\n\nprivate:\n  // FIXME: this is unneccesarily large (3 pointers). Pointer + length + owned\n  // could be 2 pointers at most.\n  std::unique_ptr<std::string> Owned;\n  llvm::StringRef Data;\n};\n\ninline bool operator==(const ObjectKey &L, const ObjectKey &R) {\n  return llvm::StringRef(L) == llvm::StringRef(R);\n}\ninline bool operator!=(const ObjectKey &L, const ObjectKey &R) {\n  return !(L == R);\n}\ninline bool operator<(const ObjectKey &L, const ObjectKey &R) {\n  return StringRef(L) < StringRef(R);\n}\n\nstruct Object::KV {\n  ObjectKey K;\n  Value V;\n};\n\ninline Object::Object(std::initializer_list<KV> Properties) {\n  for (const auto &P : Properties) {\n    auto R = try_emplace(P.K, nullptr);\n    if (R.second)\n      R.first->getSecond().moveFrom(std::move(P.V));\n  }\n}\ninline std::pair<Object::iterator, bool> Object::insert(KV E) {\n  return try_emplace(std::move(E.K), std::move(E.V));\n}\ninline bool Object::erase(StringRef K) {\n  return M.erase(ObjectKey(K));\n}\n\n/// A \"cursor\" marking a position within a Value.\n/// The Value is a tree, and this is the path from the root to the current node.\n/// This is used to associate errors with particular subobjects.\nclass Path {\npublic:\n  class Root;\n\n  /// Records that the value at the current path is invalid.\n  /// Message is e.g. \"expected number\" and becomes part of the final error.\n  /// This overwrites any previously written error message in the root.\n  void report(llvm::StringLiteral Message);\n\n  /// The root may be treated as a Path.\n  Path(Root &R) : Parent(nullptr), Seg(&R) {}\n  /// Derives a path for an array element: this[Index]\n  Path index(unsigned Index) const { return Path(this, Segment(Index)); }\n  /// Derives a path for an object field: this.Field\n  Path field(StringRef Field) const { return Path(this, Segment(Field)); }\n\nprivate:\n  /// One element in a JSON path: an object field (.foo) or array index [27].\n  /// Exception: the root Path encodes a pointer to the Path::Root.\n  class Segment {\n    uintptr_t Pointer;\n    unsigned Offset;\n\n  public:\n    Segment() = default;\n    Segment(Root *R) : Pointer(reinterpret_cast<uintptr_t>(R)) {}\n    Segment(llvm::StringRef Field)\n        : Pointer(reinterpret_cast<uintptr_t>(Field.data())),\n          Offset(static_cast<unsigned>(Field.size())) {}\n    Segment(unsigned Index) : Pointer(0), Offset(Index) {}\n\n    bool isField() const { return Pointer != 0; }\n    StringRef field() const {\n      return StringRef(reinterpret_cast<const char *>(Pointer), Offset);\n    }\n    unsigned index() const { return Offset; }\n    Root *root() const { return reinterpret_cast<Root *>(Pointer); }\n  };\n\n  const Path *Parent;\n  Segment Seg;\n\n  Path(const Path *Parent, Segment S) : Parent(Parent), Seg(S) {}\n};\n\n/// The root is the trivial Path to the root value.\n/// It also stores the latest reported error and the path where it occurred.\nclass Path::Root {\n  llvm::StringRef Name;\n  llvm::StringLiteral ErrorMessage;\n  std::vector<Path::Segment> ErrorPath; // Only valid in error state. Reversed.\n\n  friend void Path::report(llvm::StringLiteral Message);\n\npublic:\n  Root(llvm::StringRef Name = \"\") : Name(Name), ErrorMessage(\"\") {}\n  // No copy/move allowed as there are incoming pointers.\n  Root(Root &&) = delete;\n  Root &operator=(Root &&) = delete;\n  Root(const Root &) = delete;\n  Root &operator=(const Root &) = delete;\n\n  /// Returns the last error reported, or else a generic error.\n  Error getError() const;\n  /// Print the root value with the error shown inline as a comment.\n  /// Unrelated parts of the value are elided for brevity, e.g.\n  ///   {\n  ///      \"id\": 42,\n  ///      \"name\": /* expected string */ null,\n  ///      \"properties\": { ... }\n  ///   }\n  void printErrorContext(const Value &, llvm::raw_ostream &) const;\n};\n\n// Standard deserializers are provided for primitive types.\n// See comments on Value.\ninline bool fromJSON(const Value &E, std::string &Out, Path P) {\n  if (auto S = E.getAsString()) {\n    Out = std::string(*S);\n    return true;\n  }\n  P.report(\"expected string\");\n  return false;\n}\ninline bool fromJSON(const Value &E, int &Out, Path P) {\n  if (auto S = E.getAsInteger()) {\n    Out = *S;\n    return true;\n  }\n  P.report(\"expected integer\");\n  return false;\n}\ninline bool fromJSON(const Value &E, int64_t &Out, Path P) {\n  if (auto S = E.getAsInteger()) {\n    Out = *S;\n    return true;\n  }\n  P.report(\"expected integer\");\n  return false;\n}\ninline bool fromJSON(const Value &E, double &Out, Path P) {\n  if (auto S = E.getAsNumber()) {\n    Out = *S;\n    return true;\n  }\n  P.report(\"expected number\");\n  return false;\n}\ninline bool fromJSON(const Value &E, bool &Out, Path P) {\n  if (auto S = E.getAsBoolean()) {\n    Out = *S;\n    return true;\n  }\n  P.report(\"expected boolean\");\n  return false;\n}\ninline bool fromJSON(const Value &E, std::nullptr_t &Out, Path P) {\n  if (auto S = E.getAsNull()) {\n    Out = *S;\n    return true;\n  }\n  P.report(\"expected null\");\n  return false;\n}\ntemplate <typename T>\nbool fromJSON(const Value &E, llvm::Optional<T> &Out, Path P) {\n  if (E.getAsNull()) {\n    Out = llvm::None;\n    return true;\n  }\n  T Result;\n  if (!fromJSON(E, Result, P))\n    return false;\n  Out = std::move(Result);\n  return true;\n}\ntemplate <typename T>\nbool fromJSON(const Value &E, std::vector<T> &Out, Path P) {\n  if (auto *A = E.getAsArray()) {\n    Out.clear();\n    Out.resize(A->size());\n    for (size_t I = 0; I < A->size(); ++I)\n      if (!fromJSON((*A)[I], Out[I], P.index(I)))\n        return false;\n    return true;\n  }\n  P.report(\"expected array\");\n  return false;\n}\ntemplate <typename T>\nbool fromJSON(const Value &E, std::map<std::string, T> &Out, Path P) {\n  if (auto *O = E.getAsObject()) {\n    Out.clear();\n    for (const auto &KV : *O)\n      if (!fromJSON(KV.second, Out[std::string(llvm::StringRef(KV.first))],\n                    P.field(KV.first)))\n        return false;\n    return true;\n  }\n  P.report(\"expected object\");\n  return false;\n}\n\n// Allow serialization of Optional<T> for supported T.\ntemplate <typename T> Value toJSON(const llvm::Optional<T> &Opt) {\n  return Opt ? Value(*Opt) : Value(nullptr);\n}\n\n/// Helper for mapping JSON objects onto protocol structs.\n///\n/// Example:\n/// \\code\n///   bool fromJSON(const Value &E, MyStruct &R, Path P) {\n///     ObjectMapper O(E, P);\n///     // When returning false, error details were already reported.\n///     return O && O.map(\"mandatory_field\", R.MandatoryField) &&\n///         O.mapOptional(\"optional_field\", R.OptionalField);\n///   }\n/// \\endcode\nclass ObjectMapper {\npublic:\n  /// If O is not an object, this mapper is invalid and an error is reported.\n  ObjectMapper(const Value &E, Path P) : O(E.getAsObject()), P(P) {\n    if (!O)\n      P.report(\"expected object\");\n  }\n\n  /// True if the expression is an object.\n  /// Must be checked before calling map().\n  operator bool() const { return O; }\n\n  /// Maps a property to a field.\n  /// If the property is missing or invalid, reports an error.\n  template <typename T> bool map(StringLiteral Prop, T &Out) {\n    assert(*this && \"Must check this is an object before calling map()\");\n    if (const Value *E = O->get(Prop))\n      return fromJSON(*E, Out, P.field(Prop));\n    P.field(Prop).report(\"missing value\");\n    return false;\n  }\n\n  /// Maps a property to a field, if it exists.\n  /// If the property exists and is invalid, reports an error.\n  /// (Optional requires special handling, because missing keys are OK).\n  template <typename T> bool map(StringLiteral Prop, llvm::Optional<T> &Out) {\n    assert(*this && \"Must check this is an object before calling map()\");\n    if (const Value *E = O->get(Prop))\n      return fromJSON(*E, Out, P.field(Prop));\n    Out = llvm::None;\n    return true;\n  }\n\n  /// Maps a property to a field, if it exists.\n  /// If the property exists and is invalid, reports an error.\n  /// If the property does not exist, Out is unchanged.\n  template <typename T> bool mapOptional(StringLiteral Prop, T &Out) {\n    assert(*this && \"Must check this is an object before calling map()\");\n    if (const Value *E = O->get(Prop))\n      return fromJSON(*E, Out, P.field(Prop));\n    return true;\n  }\n\nprivate:\n  const Object *O;\n  Path P;\n};\n\n/// Parses the provided JSON source, or returns a ParseError.\n/// The returned Value is self-contained and owns its strings (they do not refer\n/// to the original source).\nllvm::Expected<Value> parse(llvm::StringRef JSON);\n\nclass ParseError : public llvm::ErrorInfo<ParseError> {\n  const char *Msg;\n  unsigned Line, Column, Offset;\n\npublic:\n  static char ID;\n  ParseError(const char *Msg, unsigned Line, unsigned Column, unsigned Offset)\n      : Msg(Msg), Line(Line), Column(Column), Offset(Offset) {}\n  void log(llvm::raw_ostream &OS) const override {\n    OS << llvm::formatv(\"[{0}:{1}, byte={2}]: {3}\", Line, Column, Offset, Msg);\n  }\n  std::error_code convertToErrorCode() const override {\n    return llvm::inconvertibleErrorCode();\n  }\n};\n\n/// Version of parse() that converts the parsed value to the type T.\n/// RootName describes the root object and is used in error messages.\ntemplate <typename T>\nExpected<T> parse(const llvm::StringRef &JSON, const char *RootName = \"\") {\n  auto V = parse(JSON);\n  if (!V)\n    return V.takeError();\n  Path::Root R(RootName);\n  T Result;\n  if (fromJSON(*V, Result, R))\n    return std::move(Result);\n  return R.getError();\n}\n\n/// json::OStream allows writing well-formed JSON without materializing\n/// all structures as json::Value ahead of time.\n/// It's faster, lower-level, and less safe than OS << json::Value.\n/// It also allows emitting more constructs, such as comments.\n///\n/// Only one \"top-level\" object can be written to a stream.\n/// Simplest usage involves passing lambdas (Blocks) to fill in containers:\n///\n///   json::OStream J(OS);\n///   J.array([&]{\n///     for (const Event &E : Events)\n///       J.object([&] {\n///         J.attribute(\"timestamp\", int64_t(E.Time));\n///         J.attributeArray(\"participants\", [&] {\n///           for (const Participant &P : E.Participants)\n///             J.value(P.toString());\n///         });\n///       });\n///   });\n///\n/// This would produce JSON like:\n///\n///   [\n///     {\n///       \"timestamp\": 19287398741,\n///       \"participants\": [\n///         \"King Kong\",\n///         \"Miley Cyrus\",\n///         \"Cleopatra\"\n///       ]\n///     },\n///     ...\n///   ]\n///\n/// The lower level begin/end methods (arrayBegin()) are more flexible but\n/// care must be taken to pair them correctly:\n///\n///   json::OStream J(OS);\n//    J.arrayBegin();\n///   for (const Event &E : Events) {\n///     J.objectBegin();\n///     J.attribute(\"timestamp\", int64_t(E.Time));\n///     J.attributeBegin(\"participants\");\n///     for (const Participant &P : E.Participants)\n///       J.value(P.toString());\n///     J.attributeEnd();\n///     J.objectEnd();\n///   }\n///   J.arrayEnd();\n///\n/// If the call sequence isn't valid JSON, asserts will fire in debug mode.\n/// This can be mismatched begin()/end() pairs, trying to emit attributes inside\n/// an array, and so on.\n/// With asserts disabled, this is undefined behavior.\nclass OStream {\n public:\n  using Block = llvm::function_ref<void()>;\n  // If IndentSize is nonzero, output is pretty-printed.\n  explicit OStream(llvm::raw_ostream &OS, unsigned IndentSize = 0)\n      : OS(OS), IndentSize(IndentSize) {\n    Stack.emplace_back();\n  }\n  ~OStream() {\n    assert(Stack.size() == 1 && \"Unmatched begin()/end()\");\n    assert(Stack.back().Ctx == Singleton);\n    assert(Stack.back().HasValue && \"Did not write top-level value\");\n  }\n\n  /// Flushes the underlying ostream. OStream does not buffer internally.\n  void flush() { OS.flush(); }\n\n  // High level functions to output a value.\n  // Valid at top-level (exactly once), in an attribute value (exactly once),\n  // or in an array (any number of times).\n\n  /// Emit a self-contained value (number, string, vector<string> etc).\n  void value(const Value &V);\n  /// Emit an array whose elements are emitted in the provided Block.\n  void array(Block Contents) {\n    arrayBegin();\n    Contents();\n    arrayEnd();\n  }\n  /// Emit an object whose elements are emitted in the provided Block.\n  void object(Block Contents) {\n    objectBegin();\n    Contents();\n    objectEnd();\n  }\n  /// Emit an externally-serialized value.\n  /// The caller must write exactly one valid JSON value to the provided stream.\n  /// No validation or formatting of this value occurs.\n  void rawValue(llvm::function_ref<void(raw_ostream &)> Contents) {\n    rawValueBegin();\n    Contents(OS);\n    rawValueEnd();\n  }\n  void rawValue(llvm::StringRef Contents) {\n    rawValue([&](raw_ostream &OS) { OS << Contents; });\n  }\n  /// Emit a JavaScript comment associated with the next printed value.\n  /// The string must be valid until the next attribute or value is emitted.\n  /// Comments are not part of standard JSON, and many parsers reject them!\n  void comment(llvm::StringRef);\n\n  // High level functions to output object attributes.\n  // Valid only within an object (any number of times).\n\n  /// Emit an attribute whose value is self-contained (number, vector<int> etc).\n  void attribute(llvm::StringRef Key, const Value& Contents) {\n    attributeImpl(Key, [&] { value(Contents); });\n  }\n  /// Emit an attribute whose value is an array with elements from the Block.\n  void attributeArray(llvm::StringRef Key, Block Contents) {\n    attributeImpl(Key, [&] { array(Contents); });\n  }\n  /// Emit an attribute whose value is an object with attributes from the Block.\n  void attributeObject(llvm::StringRef Key, Block Contents) {\n    attributeImpl(Key, [&] { object(Contents); });\n  }\n\n  // Low-level begin/end functions to output arrays, objects, and attributes.\n  // Must be correctly paired. Allowed contexts are as above.\n\n  void arrayBegin();\n  void arrayEnd();\n  void objectBegin();\n  void objectEnd();\n  void attributeBegin(llvm::StringRef Key);\n  void attributeEnd();\n  raw_ostream &rawValueBegin();\n  void rawValueEnd();\n\nprivate:\n  void attributeImpl(llvm::StringRef Key, Block Contents) {\n    attributeBegin(Key);\n    Contents();\n    attributeEnd();\n  }\n\n  void valueBegin();\n  void flushComment();\n  void newline();\n\n  enum Context {\n    Singleton, // Top level, or object attribute.\n    Array,\n    Object,\n    RawValue, // External code writing a value to OS directly.\n  };\n  struct State {\n    Context Ctx = Singleton;\n    bool HasValue = false;\n  };\n  llvm::SmallVector<State, 16> Stack; // Never empty.\n  llvm::StringRef PendingComment;\n  llvm::raw_ostream &OS;\n  unsigned IndentSize;\n  unsigned Indent = 0;\n};\n\n/// Serializes this Value to JSON, writing it to the provided stream.\n/// The formatting is compact (no extra whitespace) and deterministic.\n/// For pretty-printing, use the formatv() format_provider below.\ninline llvm::raw_ostream &operator<<(llvm::raw_ostream &OS, const Value &V) {\n  OStream(OS).value(V);\n  return OS;\n}\n} // namespace json\n\n/// Allow printing json::Value with formatv().\n/// The default style is basic/compact formatting, like operator<<.\n/// A format string like formatv(\"{0:2}\", Value) pretty-prints with indent 2.\ntemplate <> struct format_provider<llvm::json::Value> {\n  static void format(const llvm::json::Value &, raw_ostream &, StringRef);\n};\n} // namespace llvm\n\n#endif\n"}, "93": {"id": 93, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/YAMLParser.h", "content": "//===- YAMLParser.h - Simple YAML parser ------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n//  This is a YAML 1.2 parser.\n//\n//  See http://www.yaml.org/spec/1.2/spec.html for the full standard.\n//\n//  This currently does not implement the following:\n//    * Multi-line literal folding.\n//    * Tag resolution.\n//    * UTF-16.\n//    * BOMs anywhere other than the first Unicode scalar value in the file.\n//\n//  The most important class here is Stream. This represents a YAML stream with\n//  0, 1, or many documents.\n//\n//  SourceMgr sm;\n//  StringRef input = getInput();\n//  yaml::Stream stream(input, sm);\n//\n//  for (yaml::document_iterator di = stream.begin(), de = stream.end();\n//       di != de; ++di) {\n//    yaml::Node *n = di->getRoot();\n//    if (n) {\n//      // Do something with n...\n//    } else\n//      break;\n//  }\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_SUPPORT_YAMLPARSER_H\n#define LLVM_SUPPORT_YAMLPARSER_H\n\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/Support/Allocator.h\"\n#include \"llvm/Support/SMLoc.h\"\n#include \"llvm/Support/SourceMgr.h\"\n#include <cassert>\n#include <cstddef>\n#include <iterator>\n#include <map>\n#include <memory>\n#include <string>\n#include <system_error>\n\nnamespace llvm {\n\nclass MemoryBufferRef;\nclass raw_ostream;\nclass Twine;\n\nnamespace yaml {\n\nclass Document;\nclass document_iterator;\nclass Node;\nclass Scanner;\nstruct Token;\n\n/// Dump all the tokens in this stream to OS.\n/// \\returns true if there was an error, false otherwise.\nbool dumpTokens(StringRef Input, raw_ostream &);\n\n/// Scans all tokens in input without outputting anything. This is used\n///        for benchmarking the tokenizer.\n/// \\returns true if there was an error, false otherwise.\nbool scanTokens(StringRef Input);\n\n/// Escape \\a Input for a double quoted scalar; if \\p EscapePrintable\n/// is true, all UTF8 sequences will be escaped, if \\p EscapePrintable is\n/// false, those UTF8 sequences encoding printable unicode scalars will not be\n/// escaped, but emitted verbatim.\nstd::string escape(StringRef Input, bool EscapePrintable = true);\n\n/// Parse \\p S as a bool according to https://yaml.org/type/bool.html.\nllvm::Optional<bool> parseBool(StringRef S);\n\n/// This class represents a YAML stream potentially containing multiple\n///        documents.\nclass Stream {\npublic:\n  /// This keeps a reference to the string referenced by \\p Input.\n  Stream(StringRef Input, SourceMgr &, bool ShowColors = true,\n         std::error_code *EC = nullptr);\n\n  Stream(MemoryBufferRef InputBuffer, SourceMgr &, bool ShowColors = true,\n         std::error_code *EC = nullptr);\n  ~Stream();\n\n  document_iterator begin();\n  document_iterator end();\n  void skip();\n  bool failed();\n\n  bool validate() {\n    skip();\n    return !failed();\n  }\n\n  void printError(Node *N, const Twine &Msg,\n                  SourceMgr::DiagKind Kind = SourceMgr::DK_Error);\n  void printError(const SMRange &Range, const Twine &Msg,\n                  SourceMgr::DiagKind Kind = SourceMgr::DK_Error);\n\nprivate:\n  friend class Document;\n\n  std::unique_ptr<Scanner> scanner;\n  std::unique_ptr<Document> CurrentDoc;\n};\n\n/// Abstract base class for all Nodes.\nclass Node {\n  virtual void anchor();\n\npublic:\n  enum NodeKind {\n    NK_Null,\n    NK_Scalar,\n    NK_BlockScalar,\n    NK_KeyValue,\n    NK_Mapping,\n    NK_Sequence,\n    NK_Alias\n  };\n\n  Node(unsigned int Type, std::unique_ptr<Document> &, StringRef Anchor,\n       StringRef Tag);\n\n  // It's not safe to copy YAML nodes; the document is streamed and the position\n  // is part of the state.\n  Node(const Node &) = delete;\n  void operator=(const Node &) = delete;\n\n  void *operator new(size_t Size, BumpPtrAllocator &Alloc,\n                     size_t Alignment = 16) noexcept {\n    return Alloc.Allocate(Size, Alignment);\n  }\n\n  void operator delete(void *Ptr, BumpPtrAllocator &Alloc,\n                       size_t Size) noexcept {\n    Alloc.Deallocate(Ptr, Size, 0);\n  }\n\n  void operator delete(void *) noexcept = delete;\n\n  /// Get the value of the anchor attached to this node. If it does not\n  ///        have one, getAnchor().size() will be 0.\n  StringRef getAnchor() const { return Anchor; }\n\n  /// Get the tag as it was written in the document. This does not\n  ///   perform tag resolution.\n  StringRef getRawTag() const { return Tag; }\n\n  /// Get the verbatium tag for a given Node. This performs tag resoluton\n  ///   and substitution.\n  std::string getVerbatimTag() const;\n\n  SMRange getSourceRange() const { return SourceRange; }\n  void setSourceRange(SMRange SR) { SourceRange = SR; }\n\n  // These functions forward to Document and Scanner.\n  Token &peekNext();\n  Token getNext();\n  Node *parseBlockNode();\n  BumpPtrAllocator &getAllocator();\n  void setError(const Twine &Message, Token &Location) const;\n  bool failed() const;\n\n  virtual void skip() {}\n\n  unsigned int getType() const { return TypeID; }\n\nprotected:\n  std::unique_ptr<Document> &Doc;\n  SMRange SourceRange;\n\n  ~Node() = default;\n\nprivate:\n  unsigned int TypeID;\n  StringRef Anchor;\n  /// The tag as typed in the document.\n  StringRef Tag;\n};\n\n/// A null value.\n///\n/// Example:\n///   !!null null\nclass NullNode final : public Node {\n  void anchor() override;\n\npublic:\n  NullNode(std::unique_ptr<Document> &D)\n      : Node(NK_Null, D, StringRef(), StringRef()) {}\n\n  static bool classof(const Node *N) { return N->getType() == NK_Null; }\n};\n\n/// A scalar node is an opaque datum that can be presented as a\n///        series of zero or more Unicode scalar values.\n///\n/// Example:\n///   Adena\nclass ScalarNode final : public Node {\n  void anchor() override;\n\npublic:\n  ScalarNode(std::unique_ptr<Document> &D, StringRef Anchor, StringRef Tag,\n             StringRef Val)\n      : Node(NK_Scalar, D, Anchor, Tag), Value(Val) {\n    SMLoc Start = SMLoc::getFromPointer(Val.begin());\n    SMLoc End = SMLoc::getFromPointer(Val.end());\n    SourceRange = SMRange(Start, End);\n  }\n\n  // Return Value without any escaping or folding or other fun YAML stuff. This\n  // is the exact bytes that are contained in the file (after conversion to\n  // utf8).\n  StringRef getRawValue() const { return Value; }\n\n  /// Gets the value of this node as a StringRef.\n  ///\n  /// \\param Storage is used to store the content of the returned StringRef if\n  ///        it requires any modification from how it appeared in the source.\n  ///        This happens with escaped characters and multi-line literals.\n  StringRef getValue(SmallVectorImpl<char> &Storage) const;\n\n  static bool classof(const Node *N) {\n    return N->getType() == NK_Scalar;\n  }\n\nprivate:\n  StringRef Value;\n\n  StringRef unescapeDoubleQuoted(StringRef UnquotedValue,\n                                 StringRef::size_type Start,\n                                 SmallVectorImpl<char> &Storage) const;\n};\n\n/// A block scalar node is an opaque datum that can be presented as a\n///        series of zero or more Unicode scalar values.\n///\n/// Example:\n///   |\n///     Hello\n///     World\nclass BlockScalarNode final : public Node {\n  void anchor() override;\n\npublic:\n  BlockScalarNode(std::unique_ptr<Document> &D, StringRef Anchor, StringRef Tag,\n                  StringRef Value, StringRef RawVal)\n      : Node(NK_BlockScalar, D, Anchor, Tag), Value(Value) {\n    SMLoc Start = SMLoc::getFromPointer(RawVal.begin());\n    SMLoc End = SMLoc::getFromPointer(RawVal.end());\n    SourceRange = SMRange(Start, End);\n  }\n\n  /// Gets the value of this node as a StringRef.\n  StringRef getValue() const { return Value; }\n\n  static bool classof(const Node *N) {\n    return N->getType() == NK_BlockScalar;\n  }\n\nprivate:\n  StringRef Value;\n};\n\n/// A key and value pair. While not technically a Node under the YAML\n///        representation graph, it is easier to treat them this way.\n///\n/// TODO: Consider making this not a child of Node.\n///\n/// Example:\n///   Section: .text\nclass KeyValueNode final : public Node {\n  void anchor() override;\n\npublic:\n  KeyValueNode(std::unique_ptr<Document> &D)\n      : Node(NK_KeyValue, D, StringRef(), StringRef()) {}\n\n  /// Parse and return the key.\n  ///\n  /// This may be called multiple times.\n  ///\n  /// \\returns The key, or nullptr if failed() == true.\n  Node *getKey();\n\n  /// Parse and return the value.\n  ///\n  /// This may be called multiple times.\n  ///\n  /// \\returns The value, or nullptr if failed() == true.\n  Node *getValue();\n\n  void skip() override {\n    if (Node *Key = getKey()) {\n      Key->skip();\n      if (Node *Val = getValue())\n        Val->skip();\n    }\n  }\n\n  static bool classof(const Node *N) {\n    return N->getType() == NK_KeyValue;\n  }\n\nprivate:\n  Node *Key = nullptr;\n  Node *Value = nullptr;\n};\n\n/// This is an iterator abstraction over YAML collections shared by both\n///        sequences and maps.\n///\n/// BaseT must have a ValueT* member named CurrentEntry and a member function\n/// increment() which must set CurrentEntry to 0 to create an end iterator.\ntemplate <class BaseT, class ValueT>\nclass basic_collection_iterator\n    : public std::iterator<std::input_iterator_tag, ValueT> {\npublic:\n  basic_collection_iterator() = default;\n  basic_collection_iterator(BaseT *B) : Base(B) {}\n\n  ValueT *operator->() const {\n    assert(Base && Base->CurrentEntry && \"Attempted to access end iterator!\");\n    return Base->CurrentEntry;\n  }\n\n  ValueT &operator*() const {\n    assert(Base && Base->CurrentEntry &&\n           \"Attempted to dereference end iterator!\");\n    return *Base->CurrentEntry;\n  }\n\n  operator ValueT *() const {\n    assert(Base && Base->CurrentEntry && \"Attempted to access end iterator!\");\n    return Base->CurrentEntry;\n  }\n\n  /// Note on EqualityComparable:\n  ///\n  /// The iterator is not re-entrant,\n  /// it is meant to be used for parsing YAML on-demand\n  /// Once iteration started - it can point only to one entry at a time\n  /// hence Base.CurrentEntry and Other.Base.CurrentEntry are equal\n  /// iff Base and Other.Base are equal.\n  bool operator==(const basic_collection_iterator &Other) const {\n    if (Base && (Base == Other.Base)) {\n      assert((Base->CurrentEntry == Other.Base->CurrentEntry)\n             && \"Equal Bases expected to point to equal Entries\");\n    }\n\n    return Base == Other.Base;\n  }\n\n  bool operator!=(const basic_collection_iterator &Other) const {\n    return !(Base == Other.Base);\n  }\n\n  basic_collection_iterator &operator++() {\n    assert(Base && \"Attempted to advance iterator past end!\");\n    Base->increment();\n    // Create an end iterator.\n    if (!Base->CurrentEntry)\n      Base = nullptr;\n    return *this;\n  }\n\nprivate:\n  BaseT *Base = nullptr;\n};\n\n// The following two templates are used for both MappingNode and Sequence Node.\ntemplate <class CollectionType>\ntypename CollectionType::iterator begin(CollectionType &C) {\n  assert(C.IsAtBeginning && \"You may only iterate over a collection once!\");\n  C.IsAtBeginning = false;\n  typename CollectionType::iterator ret(&C);\n  ++ret;\n  return ret;\n}\n\ntemplate <class CollectionType> void skip(CollectionType &C) {\n  // TODO: support skipping from the middle of a parsed collection ;/\n  assert((C.IsAtBeginning || C.IsAtEnd) && \"Cannot skip mid parse!\");\n  if (C.IsAtBeginning)\n    for (typename CollectionType::iterator i = begin(C), e = C.end(); i != e;\n         ++i)\n      i->skip();\n}\n\n/// Represents a YAML map created from either a block map for a flow map.\n///\n/// This parses the YAML stream as increment() is called.\n///\n/// Example:\n///   Name: _main\n///   Scope: Global\nclass MappingNode final : public Node {\n  void anchor() override;\n\npublic:\n  enum MappingType {\n    MT_Block,\n    MT_Flow,\n    MT_Inline ///< An inline mapping node is used for \"[key: value]\".\n  };\n\n  MappingNode(std::unique_ptr<Document> &D, StringRef Anchor, StringRef Tag,\n              MappingType MT)\n      : Node(NK_Mapping, D, Anchor, Tag), Type(MT) {}\n\n  friend class basic_collection_iterator<MappingNode, KeyValueNode>;\n\n  using iterator = basic_collection_iterator<MappingNode, KeyValueNode>;\n\n  template <class T> friend typename T::iterator yaml::begin(T &);\n  template <class T> friend void yaml::skip(T &);\n\n  iterator begin() { return yaml::begin(*this); }\n\n  iterator end() { return iterator(); }\n\n  void skip() override { yaml::skip(*this); }\n\n  static bool classof(const Node *N) {\n    return N->getType() == NK_Mapping;\n  }\n\nprivate:\n  MappingType Type;\n  bool IsAtBeginning = true;\n  bool IsAtEnd = false;\n  KeyValueNode *CurrentEntry = nullptr;\n\n  void increment();\n};\n\n/// Represents a YAML sequence created from either a block sequence for a\n///        flow sequence.\n///\n/// This parses the YAML stream as increment() is called.\n///\n/// Example:\n///   - Hello\n///   - World\nclass SequenceNode final : public Node {\n  void anchor() override;\n\npublic:\n  enum SequenceType {\n    ST_Block,\n    ST_Flow,\n    // Use for:\n    //\n    // key:\n    // - val1\n    // - val2\n    //\n    // As a BlockMappingEntry and BlockEnd are not created in this case.\n    ST_Indentless\n  };\n\n  SequenceNode(std::unique_ptr<Document> &D, StringRef Anchor, StringRef Tag,\n               SequenceType ST)\n      : Node(NK_Sequence, D, Anchor, Tag), SeqType(ST) {}\n\n  friend class basic_collection_iterator<SequenceNode, Node>;\n\n  using iterator = basic_collection_iterator<SequenceNode, Node>;\n\n  template <class T> friend typename T::iterator yaml::begin(T &);\n  template <class T> friend void yaml::skip(T &);\n\n  void increment();\n\n  iterator begin() { return yaml::begin(*this); }\n\n  iterator end() { return iterator(); }\n\n  void skip() override { yaml::skip(*this); }\n\n  static bool classof(const Node *N) {\n    return N->getType() == NK_Sequence;\n  }\n\nprivate:\n  SequenceType SeqType;\n  bool IsAtBeginning = true;\n  bool IsAtEnd = false;\n  bool WasPreviousTokenFlowEntry = true; // Start with an imaginary ','.\n  Node *CurrentEntry = nullptr;\n};\n\n/// Represents an alias to a Node with an anchor.\n///\n/// Example:\n///   *AnchorName\nclass AliasNode final : public Node {\n  void anchor() override;\n\npublic:\n  AliasNode(std::unique_ptr<Document> &D, StringRef Val)\n      : Node(NK_Alias, D, StringRef(), StringRef()), Name(Val) {}\n\n  StringRef getName() const { return Name; }\n\n  static bool classof(const Node *N) { return N->getType() == NK_Alias; }\n\nprivate:\n  StringRef Name;\n};\n\n/// A YAML Stream is a sequence of Documents. A document contains a root\n///        node.\nclass Document {\npublic:\n  Document(Stream &ParentStream);\n\n  /// Root for parsing a node. Returns a single node.\n  Node *parseBlockNode();\n\n  /// Finish parsing the current document and return true if there are\n  ///        more. Return false otherwise.\n  bool skip();\n\n  /// Parse and return the root level node.\n  Node *getRoot() {\n    if (Root)\n      return Root;\n    return Root = parseBlockNode();\n  }\n\n  const std::map<StringRef, StringRef> &getTagMap() const { return TagMap; }\n\nprivate:\n  friend class Node;\n  friend class document_iterator;\n\n  /// Stream to read tokens from.\n  Stream &stream;\n\n  /// Used to allocate nodes to. All are destroyed without calling their\n  ///        destructor when the document is destroyed.\n  BumpPtrAllocator NodeAllocator;\n\n  /// The root node. Used to support skipping a partially parsed\n  ///        document.\n  Node *Root;\n\n  /// Maps tag prefixes to their expansion.\n  std::map<StringRef, StringRef> TagMap;\n\n  Token &peekNext();\n  Token getNext();\n  void setError(const Twine &Message, Token &Location) const;\n  bool failed() const;\n\n  /// Parse %BLAH directives and return true if any were encountered.\n  bool parseDirectives();\n\n  /// Parse %YAML\n  void parseYAMLDirective();\n\n  /// Parse %TAG\n  void parseTAGDirective();\n\n  /// Consume the next token and error if it is not \\a TK.\n  bool expectToken(int TK);\n};\n\n/// Iterator abstraction for Documents over a Stream.\nclass document_iterator {\npublic:\n  document_iterator() = default;\n  document_iterator(std::unique_ptr<Document> &D) : Doc(&D) {}\n\n  bool operator==(const document_iterator &Other) const {\n    if (isAtEnd() || Other.isAtEnd())\n      return isAtEnd() && Other.isAtEnd();\n\n    return Doc == Other.Doc;\n  }\n  bool operator!=(const document_iterator &Other) const {\n    return !(*this == Other);\n  }\n\n  document_iterator operator++() {\n    assert(Doc && \"incrementing iterator past the end.\");\n    if (!(*Doc)->skip()) {\n      Doc->reset(nullptr);\n    } else {\n      Stream &S = (*Doc)->stream;\n      Doc->reset(new Document(S));\n    }\n    return *this;\n  }\n\n  Document &operator*() { return *Doc->get(); }\n\n  std::unique_ptr<Document> &operator->() { return *Doc; }\n\nprivate:\n  bool isAtEnd() const { return !Doc || !*Doc; }\n\n  std::unique_ptr<Document> *Doc = nullptr;\n};\n\n} // end namespace yaml\n\n} // end namespace llvm\n\n#endif // LLVM_SUPPORT_YAMLPARSER_H\n"}, "94": {"id": 94, "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/YAMLTraits.h", "content": "//===- llvm/Support/YAMLTraits.h --------------------------------*- C++ -*-===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef LLVM_SUPPORT_YAMLTRAITS_H\n#define LLVM_SUPPORT_YAMLTRAITS_H\n\n#include \"llvm/ADT/Optional.h\"\n#include \"llvm/ADT/SmallVector.h\"\n#include \"llvm/ADT/StringExtras.h\"\n#include \"llvm/ADT/StringMap.h\"\n#include \"llvm/ADT/StringRef.h\"\n#include \"llvm/ADT/Twine.h\"\n#include \"llvm/Support/AlignOf.h\"\n#include \"llvm/Support/Allocator.h\"\n#include \"llvm/Support/Endian.h\"\n#include \"llvm/Support/Regex.h\"\n#include \"llvm/Support/SMLoc.h\"\n#include \"llvm/Support/SourceMgr.h\"\n#include \"llvm/Support/VersionTuple.h\"\n#include \"llvm/Support/YAMLParser.h\"\n#include \"llvm/Support/raw_ostream.h\"\n#include <cassert>\n#include <cctype>\n#include <cstddef>\n#include <cstdint>\n#include <iterator>\n#include <map>\n#include <memory>\n#include <new>\n#include <string>\n#include <system_error>\n#include <type_traits>\n#include <vector>\n\nnamespace llvm {\nnamespace yaml {\n\nenum class NodeKind : uint8_t {\n  Scalar,\n  Map,\n  Sequence,\n};\n\nstruct EmptyContext {};\n\n/// This class should be specialized by any type that needs to be converted\n/// to/from a YAML mapping.  For example:\n///\n///     struct MappingTraits<MyStruct> {\n///       static void mapping(IO &io, MyStruct &s) {\n///         io.mapRequired(\"name\", s.name);\n///         io.mapRequired(\"size\", s.size);\n///         io.mapOptional(\"age\",  s.age);\n///       }\n///     };\ntemplate<class T>\nstruct MappingTraits {\n  // Must provide:\n  // static void mapping(IO &io, T &fields);\n  // Optionally may provide:\n  // static std::string validate(IO &io, T &fields);\n  //\n  // The optional flow flag will cause generated YAML to use a flow mapping\n  // (e.g. { a: 0, b: 1 }):\n  // static const bool flow = true;\n};\n\n/// This class is similar to MappingTraits<T> but allows you to pass in\n/// additional context for each map operation.  For example:\n///\n///     struct MappingContextTraits<MyStruct, MyContext> {\n///       static void mapping(IO &io, MyStruct &s, MyContext &c) {\n///         io.mapRequired(\"name\", s.name);\n///         io.mapRequired(\"size\", s.size);\n///         io.mapOptional(\"age\",  s.age);\n///         ++c.TimesMapped;\n///       }\n///     };\ntemplate <class T, class Context> struct MappingContextTraits {\n  // Must provide:\n  // static void mapping(IO &io, T &fields, Context &Ctx);\n  // Optionally may provide:\n  // static std::string validate(IO &io, T &fields, Context &Ctx);\n  //\n  // The optional flow flag will cause generated YAML to use a flow mapping\n  // (e.g. { a: 0, b: 1 }):\n  // static const bool flow = true;\n};\n\n/// This class should be specialized by any integral type that converts\n/// to/from a YAML scalar where there is a one-to-one mapping between\n/// in-memory values and a string in YAML.  For example:\n///\n///     struct ScalarEnumerationTraits<Colors> {\n///         static void enumeration(IO &io, Colors &value) {\n///           io.enumCase(value, \"red\",   cRed);\n///           io.enumCase(value, \"blue\",  cBlue);\n///           io.enumCase(value, \"green\", cGreen);\n///         }\n///       };\ntemplate <typename T, typename Enable = void> struct ScalarEnumerationTraits {\n  // Must provide:\n  // static void enumeration(IO &io, T &value);\n};\n\n/// This class should be specialized by any integer type that is a union\n/// of bit values and the YAML representation is a flow sequence of\n/// strings.  For example:\n///\n///      struct ScalarBitSetTraits<MyFlags> {\n///        static void bitset(IO &io, MyFlags &value) {\n///          io.bitSetCase(value, \"big\",   flagBig);\n///          io.bitSetCase(value, \"flat\",  flagFlat);\n///          io.bitSetCase(value, \"round\", flagRound);\n///        }\n///      };\ntemplate <typename T, typename Enable = void> struct ScalarBitSetTraits {\n  // Must provide:\n  // static void bitset(IO &io, T &value);\n};\n\n/// Describe which type of quotes should be used when quoting is necessary.\n/// Some non-printable characters need to be double-quoted, while some others\n/// are fine with simple-quoting, and some don't need any quoting.\nenum class QuotingType { None, Single, Double };\n\n/// This class should be specialized by type that requires custom conversion\n/// to/from a yaml scalar.  For example:\n///\n///    template<>\n///    struct ScalarTraits<MyType> {\n///      static void output(const MyType &val, void*, llvm::raw_ostream &out) {\n///        // stream out custom formatting\n///        out << llvm::format(\"%x\", val);\n///      }\n///      static StringRef input(StringRef scalar, void*, MyType &value) {\n///        // parse scalar and set `value`\n///        // return empty string on success, or error string\n///        return StringRef();\n///      }\n///      static QuotingType mustQuote(StringRef) { return QuotingType::Single; }\n///    };\ntemplate <typename T, typename Enable = void> struct ScalarTraits {\n  // Must provide:\n  //\n  // Function to write the value as a string:\n  // static void output(const T &value, void *ctxt, llvm::raw_ostream &out);\n  //\n  // Function to convert a string to a value.  Returns the empty\n  // StringRef on success or an error string if string is malformed:\n  // static StringRef input(StringRef scalar, void *ctxt, T &value);\n  //\n  // Function to determine if the value should be quoted.\n  // static QuotingType mustQuote(StringRef);\n};\n\n/// This class should be specialized by type that requires custom conversion\n/// to/from a YAML literal block scalar. For example:\n///\n///    template <>\n///    struct BlockScalarTraits<MyType> {\n///      static void output(const MyType &Value, void*, llvm::raw_ostream &Out)\n///      {\n///        // stream out custom formatting\n///        Out << Value;\n///      }\n///      static StringRef input(StringRef Scalar, void*, MyType &Value) {\n///        // parse scalar and set `value`\n///        // return empty string on success, or error string\n///        return StringRef();\n///      }\n///    };\ntemplate <typename T>\nstruct BlockScalarTraits {\n  // Must provide:\n  //\n  // Function to write the value as a string:\n  // static void output(const T &Value, void *ctx, llvm::raw_ostream &Out);\n  //\n  // Function to convert a string to a value.  Returns the empty\n  // StringRef on success or an error string if string is malformed:\n  // static StringRef input(StringRef Scalar, void *ctxt, T &Value);\n  //\n  // Optional:\n  // static StringRef inputTag(T &Val, std::string Tag)\n  // static void outputTag(const T &Val, raw_ostream &Out)\n};\n\n/// This class should be specialized by type that requires custom conversion\n/// to/from a YAML scalar with optional tags. For example:\n///\n///    template <>\n///    struct TaggedScalarTraits<MyType> {\n///      static void output(const MyType &Value, void*, llvm::raw_ostream\n///      &ScalarOut, llvm::raw_ostream &TagOut)\n///      {\n///        // stream out custom formatting including optional Tag\n///        Out << Value;\n///      }\n///      static StringRef input(StringRef Scalar, StringRef Tag, void*, MyType\n///      &Value) {\n///        // parse scalar and set `value`\n///        // return empty string on success, or error string\n///        return StringRef();\n///      }\n///      static QuotingType mustQuote(const MyType &Value, StringRef) {\n///        return QuotingType::Single;\n///      }\n///    };\ntemplate <typename T> struct TaggedScalarTraits {\n  // Must provide:\n  //\n  // Function to write the value and tag as strings:\n  // static void output(const T &Value, void *ctx, llvm::raw_ostream &ScalarOut,\n  // llvm::raw_ostream &TagOut);\n  //\n  // Function to convert a string to a value.  Returns the empty\n  // StringRef on success or an error string if string is malformed:\n  // static StringRef input(StringRef Scalar, StringRef Tag, void *ctxt, T\n  // &Value);\n  //\n  // Function to determine if the value should be quoted.\n  // static QuotingType mustQuote(const T &Value, StringRef Scalar);\n};\n\n/// This class should be specialized by any type that needs to be converted\n/// to/from a YAML sequence.  For example:\n///\n///    template<>\n///    struct SequenceTraits<MyContainer> {\n///      static size_t size(IO &io, MyContainer &seq) {\n///        return seq.size();\n///      }\n///      static MyType& element(IO &, MyContainer &seq, size_t index) {\n///        if ( index >= seq.size() )\n///          seq.resize(index+1);\n///        return seq[index];\n///      }\n///    };\ntemplate<typename T, typename EnableIf = void>\nstruct SequenceTraits {\n  // Must provide:\n  // static size_t size(IO &io, T &seq);\n  // static T::value_type& element(IO &io, T &seq, size_t index);\n  //\n  // The following is option and will cause generated YAML to use\n  // a flow sequence (e.g. [a,b,c]).\n  // static const bool flow = true;\n};\n\n/// This class should be specialized by any type for which vectors of that\n/// type need to be converted to/from a YAML sequence.\ntemplate<typename T, typename EnableIf = void>\nstruct SequenceElementTraits {\n  // Must provide:\n  // static const bool flow;\n};\n\n/// This class should be specialized by any type that needs to be converted\n/// to/from a list of YAML documents.\ntemplate<typename T>\nstruct DocumentListTraits {\n  // Must provide:\n  // static size_t size(IO &io, T &seq);\n  // static T::value_type& element(IO &io, T &seq, size_t index);\n};\n\n/// This class should be specialized by any type that needs to be converted\n/// to/from a YAML mapping in the case where the names of the keys are not known\n/// in advance, e.g. a string map.\ntemplate <typename T>\nstruct CustomMappingTraits {\n  // static void inputOne(IO &io, StringRef key, T &elem);\n  // static void output(IO &io, T &elem);\n};\n\n/// This class should be specialized by any type that can be represented as\n/// a scalar, map, or sequence, decided dynamically. For example:\n///\n///    typedef std::unique_ptr<MyBase> MyPoly;\n///\n///    template<>\n///    struct PolymorphicTraits<MyPoly> {\n///      static NodeKind getKind(const MyPoly &poly) {\n///        return poly->getKind();\n///      }\n///      static MyScalar& getAsScalar(MyPoly &poly) {\n///        if (!poly || !isa<MyScalar>(poly))\n///          poly.reset(new MyScalar());\n///        return *cast<MyScalar>(poly.get());\n///      }\n///      // ...\n///    };\ntemplate <typename T> struct PolymorphicTraits {\n  // Must provide:\n  // static NodeKind getKind(const T &poly);\n  // static scalar_type &getAsScalar(T &poly);\n  // static map_type &getAsMap(T &poly);\n  // static sequence_type &getAsSequence(T &poly);\n};\n\n// Only used for better diagnostics of missing traits\ntemplate <typename T>\nstruct MissingTrait;\n\n// Test if ScalarEnumerationTraits<T> is defined on type T.\ntemplate <class T>\nstruct has_ScalarEnumerationTraits\n{\n  using Signature_enumeration = void (*)(class IO&, T&);\n\n  template <typename U>\n  static char test(SameType<Signature_enumeration, &U::enumeration>*);\n\n  template <typename U>\n  static double test(...);\n\n  static bool const value =\n    (sizeof(test<ScalarEnumerationTraits<T>>(nullptr)) == 1);\n};\n\n// Test if ScalarBitSetTraits<T> is defined on type T.\ntemplate <class T>\nstruct has_ScalarBitSetTraits\n{\n  using Signature_bitset = void (*)(class IO&, T&);\n\n  template <typename U>\n  static char test(SameType<Signature_bitset, &U::bitset>*);\n\n  template <typename U>\n  static double test(...);\n\n  static bool const value = (sizeof(test<ScalarBitSetTraits<T>>(nullptr)) == 1);\n};\n\n// Test if ScalarTraits<T> is defined on type T.\ntemplate <class T>\nstruct has_ScalarTraits\n{\n  using Signature_input = StringRef (*)(StringRef, void*, T&);\n  using Signature_output = void (*)(const T&, void*, raw_ostream&);\n  using Signature_mustQuote = QuotingType (*)(StringRef);\n\n  template <typename U>\n  static char test(SameType<Signature_input, &U::input> *,\n                   SameType<Signature_output, &U::output> *,\n                   SameType<Signature_mustQuote, &U::mustQuote> *);\n\n  template <typename U>\n  static double test(...);\n\n  static bool const value =\n      (sizeof(test<ScalarTraits<T>>(nullptr, nullptr, nullptr)) == 1);\n};\n\n// Test if BlockScalarTraits<T> is defined on type T.\ntemplate <class T>\nstruct has_BlockScalarTraits\n{\n  using Signature_input = StringRef (*)(StringRef, void *, T &);\n  using Signature_output = void (*)(const T &, void *, raw_ostream &);\n\n  template <typename U>\n  static char test(SameType<Signature_input, &U::input> *,\n                   SameType<Signature_output, &U::output> *);\n\n  template <typename U>\n  static double test(...);\n\n  static bool const value =\n      (sizeof(test<BlockScalarTraits<T>>(nullptr, nullptr)) == 1);\n};\n\n// Test if TaggedScalarTraits<T> is defined on type T.\ntemplate <class T> struct has_TaggedScalarTraits {\n  using Signature_input = StringRef (*)(StringRef, StringRef, void *, T &);\n  using Signature_output = void (*)(const T &, void *, raw_ostream &,\n                                    raw_ostream &);\n  using Signature_mustQuote = QuotingType (*)(const T &, StringRef);\n\n  template <typename U>\n  static char test(SameType<Signature_input, &U::input> *,\n                   SameType<Signature_output, &U::output> *,\n                   SameType<Signature_mustQuote, &U::mustQuote> *);\n\n  template <typename U> static double test(...);\n\n  static bool const value =\n      (sizeof(test<TaggedScalarTraits<T>>(nullptr, nullptr, nullptr)) == 1);\n};\n\n// Test if MappingContextTraits<T> is defined on type T.\ntemplate <class T, class Context> struct has_MappingTraits {\n  using Signature_mapping = void (*)(class IO &, T &, Context &);\n\n  template <typename U>\n  static char test(SameType<Signature_mapping, &U::mapping>*);\n\n  template <typename U>\n  static double test(...);\n\n  static bool const value =\n      (sizeof(test<MappingContextTraits<T, Context>>(nullptr)) == 1);\n};\n\n// Test if MappingTraits<T> is defined on type T.\ntemplate <class T> struct has_MappingTraits<T, EmptyContext> {\n  using Signature_mapping = void (*)(class IO &, T &);\n\n  template <typename U>\n  static char test(SameType<Signature_mapping, &U::mapping> *);\n\n  template <typename U> static double test(...);\n\n  static bool const value = (sizeof(test<MappingTraits<T>>(nullptr)) == 1);\n};\n\n// Test if MappingContextTraits<T>::validate() is defined on type T.\ntemplate <class T, class Context> struct has_MappingValidateTraits {\n  using Signature_validate = std::string (*)(class IO &, T &, Context &);\n\n  template <typename U>\n  static char test(SameType<Signature_validate, &U::validate>*);\n\n  template <typename U>\n  static double test(...);\n\n  static bool const value =\n      (sizeof(test<MappingContextTraits<T, Context>>(nullptr)) == 1);\n};\n\n// Test if MappingTraits<T>::validate() is defined on type T.\ntemplate <class T> struct has_MappingValidateTraits<T, EmptyContext> {\n  using Signature_validate = std::string (*)(class IO &, T &);\n\n  template <typename U>\n  static char test(SameType<Signature_validate, &U::validate> *);\n\n  template <typename U> static double test(...);\n\n  static bool const value = (sizeof(test<MappingTraits<T>>(nullptr)) == 1);\n};\n\n// Test if SequenceTraits<T> is defined on type T.\ntemplate <class T>\nstruct has_SequenceMethodTraits\n{\n  using Signature_size = size_t (*)(class IO&, T&);\n\n  template <typename U>\n  static char test(SameType<Signature_size, &U::size>*);\n\n  template <typename U>\n  static double test(...);\n\n  static bool const value =  (sizeof(test<SequenceTraits<T>>(nullptr)) == 1);\n};\n\n// Test if CustomMappingTraits<T> is defined on type T.\ntemplate <class T>\nstruct has_CustomMappingTraits\n{\n  using Signature_input = void (*)(IO &io, StringRef key, T &v);\n\n  template <typename U>\n  static char test(SameType<Signature_input, &U::inputOne>*);\n\n  template <typename U>\n  static double test(...);\n\n  static bool const value =\n      (sizeof(test<CustomMappingTraits<T>>(nullptr)) == 1);\n};\n\n// has_FlowTraits<int> will cause an error with some compilers because\n// it subclasses int.  Using this wrapper only instantiates the\n// real has_FlowTraits only if the template type is a class.\ntemplate <typename T, bool Enabled = std::is_class<T>::value>\nclass has_FlowTraits\n{\npublic:\n   static const bool value = false;\n};\n\n// Some older gcc compilers don't support straight forward tests\n// for members, so test for ambiguity cause by the base and derived\n// classes both defining the member.\ntemplate <class T>\nstruct has_FlowTraits<T, true>\n{\n  struct Fallback { bool flow; };\n  struct Derived : T, Fallback { };\n\n  template<typename C>\n  static char (&f(SameType<bool Fallback::*, &C::flow>*))[1];\n\n  template<typename C>\n  static char (&f(...))[2];\n\n  static bool const value = sizeof(f<Derived>(nullptr)) == 2;\n};\n\n// Test if SequenceTraits<T> is defined on type T\ntemplate<typename T>\nstruct has_SequenceTraits : public std::integral_constant<bool,\n                                      has_SequenceMethodTraits<T>::value > { };\n\n// Test if DocumentListTraits<T> is defined on type T\ntemplate <class T>\nstruct has_DocumentListTraits\n{\n  using Signature_size = size_t (*)(class IO &, T &);\n\n  template <typename U>\n  static char test(SameType<Signature_size, &U::size>*);\n\n  template <typename U>\n  static double test(...);\n\n  static bool const value = (sizeof(test<DocumentListTraits<T>>(nullptr))==1);\n};\n\ntemplate <class T> struct has_PolymorphicTraits {\n  using Signature_getKind = NodeKind (*)(const T &);\n\n  template <typename U>\n  static char test(SameType<Signature_getKind, &U::getKind> *);\n\n  template <typename U> static double test(...);\n\n  static bool const value = (sizeof(test<PolymorphicTraits<T>>(nullptr)) == 1);\n};\n\ninline bool isNumeric(StringRef S) {\n  const static auto skipDigits = [](StringRef Input) {\n    return Input.drop_front(\n        std::min(Input.find_first_not_of(\"0123456789\"), Input.size()));\n  };\n\n  // Make S.front() and S.drop_front().front() (if S.front() is [+-]) calls\n  // safe.\n  if (S.empty() || S.equals(\"+\") || S.equals(\"-\"))\n    return false;\n\n  if (S.equals(\".nan\") || S.equals(\".NaN\") || S.equals(\".NAN\"))\n    return true;\n\n  // Infinity and decimal numbers can be prefixed with sign.\n  StringRef Tail = (S.front() == '-' || S.front() == '+') ? S.drop_front() : S;\n\n  // Check for infinity first, because checking for hex and oct numbers is more\n  // expensive.\n  if (Tail.equals(\".inf\") || Tail.equals(\".Inf\") || Tail.equals(\".INF\"))\n    return true;\n\n  // Section 10.3.2 Tag Resolution\n  // YAML 1.2 Specification prohibits Base 8 and Base 16 numbers prefixed with\n  // [-+], so S should be used instead of Tail.\n  if (S.startswith(\"0o\"))\n    return S.size() > 2 &&\n           S.drop_front(2).find_first_not_of(\"01234567\") == StringRef::npos;\n\n  if (S.startswith(\"0x\"))\n    return S.size() > 2 && S.drop_front(2).find_first_not_of(\n                               \"0123456789abcdefABCDEF\") == StringRef::npos;\n\n  // Parse float: [-+]? (\\. [0-9]+ | [0-9]+ (\\. [0-9]* )?) ([eE] [-+]? [0-9]+)?\n  S = Tail;\n\n  // Handle cases when the number starts with '.' and hence needs at least one\n  // digit after dot (as opposed by number which has digits before the dot), but\n  // doesn't have one.\n  if (S.startswith(\".\") &&\n      (S.equals(\".\") ||\n       (S.size() > 1 && std::strchr(\"0123456789\", S[1]) == nullptr)))\n    return false;\n\n  if (S.startswith(\"E\") || S.startswith(\"e\"))\n    return false;\n\n  enum ParseState {\n    Default,\n    FoundDot,\n    FoundExponent,\n  };\n  ParseState State = Default;\n\n  S = skipDigits(S);\n\n  // Accept decimal integer.\n  if (S.empty())\n    return true;\n\n  if (S.front() == '.') {\n    State = FoundDot;\n    S = S.drop_front();\n  } else if (S.front() == 'e' || S.front() == 'E') {\n    State = FoundExponent;\n    S = S.drop_front();\n  } else {\n    return false;\n  }\n\n  if (State == FoundDot) {\n    S = skipDigits(S);\n    if (S.empty())\n      return true;\n\n    if (S.front() == 'e' || S.front() == 'E') {\n      State = FoundExponent;\n      S = S.drop_front();\n    } else {\n      return false;\n    }\n  }\n\n  assert(State == FoundExponent && \"Should have found exponent at this point.\");\n  if (S.empty())\n    return false;\n\n  if (S.front() == '+' || S.front() == '-') {\n    S = S.drop_front();\n    if (S.empty())\n      return false;\n  }\n\n  return skipDigits(S).empty();\n}\n\ninline bool isNull(StringRef S) {\n  return S.equals(\"null\") || S.equals(\"Null\") || S.equals(\"NULL\") ||\n         S.equals(\"~\");\n}\n\ninline bool isBool(StringRef S) {\n  // FIXME: using parseBool is causing multiple tests to fail.\n  return S.equals(\"true\") || S.equals(\"True\") || S.equals(\"TRUE\") ||\n         S.equals(\"false\") || S.equals(\"False\") || S.equals(\"FALSE\");\n}\n\n// 5.1. Character Set\n// The allowed character range explicitly excludes the C0 control block #x0-#x1F\n// (except for TAB #x9, LF #xA, and CR #xD which are allowed), DEL #x7F, the C1\n// control block #x80-#x9F (except for NEL #x85 which is allowed), the surrogate\n// block #xD800-#xDFFF, #xFFFE, and #xFFFF.\ninline QuotingType needsQuotes(StringRef S) {\n  if (S.empty())\n    return QuotingType::Single;\n\n  QuotingType MaxQuotingNeeded = QuotingType::None;\n  if (isSpace(static_cast<unsigned char>(S.front())) ||\n      isSpace(static_cast<unsigned char>(S.back())))\n    MaxQuotingNeeded = QuotingType::Single;\n  if (isNull(S))\n    MaxQuotingNeeded = QuotingType::Single;\n  if (isBool(S))\n    MaxQuotingNeeded = QuotingType::Single;\n  if (isNumeric(S))\n    MaxQuotingNeeded = QuotingType::Single;\n\n  // 7.3.3 Plain Style\n  // Plain scalars must not begin with most indicators, as this would cause\n  // ambiguity with other YAML constructs.\n  static constexpr char Indicators[] = R\"(-?:\\,[]{}#&*!|>'\"%@`)\";\n  if (S.find_first_of(Indicators) == 0)\n    MaxQuotingNeeded = QuotingType::Single;\n\n  for (unsigned char C : S) {\n    // Alphanum is safe.\n    if (isAlnum(C))\n      continue;\n\n    switch (C) {\n    // Safe scalar characters.\n    case '_':\n    case '-':\n    case '^':\n    case '.':\n    case ',':\n    case ' ':\n    // TAB (0x9) is allowed in unquoted strings.\n    case 0x9:\n      continue;\n    // LF(0xA) and CR(0xD) may delimit values and so require at least single\n    // quotes. LLVM YAML parser cannot handle single quoted multiline so use\n    // double quoting to produce valid YAML.\n    case 0xA:\n    case 0xD:\n      return QuotingType::Double;\n    // DEL (0x7F) are excluded from the allowed character range.\n    case 0x7F:\n      return QuotingType::Double;\n    // Forward slash is allowed to be unquoted, but we quote it anyway.  We have\n    // many tests that use FileCheck against YAML output, and this output often\n    // contains paths.  If we quote backslashes but not forward slashes then\n    // paths will come out either quoted or unquoted depending on which platform\n    // the test is run on, making FileCheck comparisons difficult.\n    case '/':\n    default: {\n      // C0 control block (0x0 - 0x1F) is excluded from the allowed character\n      // range.\n      if (C <= 0x1F)\n        return QuotingType::Double;\n\n      // Always double quote UTF-8.\n      if ((C & 0x80) != 0)\n        return QuotingType::Double;\n\n      // The character is not safe, at least simple quoting needed.\n      MaxQuotingNeeded = QuotingType::Single;\n    }\n    }\n  }\n\n  return MaxQuotingNeeded;\n}\n\ntemplate <typename T, typename Context>\nstruct missingTraits\n    : public std::integral_constant<bool,\n                                    !has_ScalarEnumerationTraits<T>::value &&\n                                        !has_ScalarBitSetTraits<T>::value &&\n                                        !has_ScalarTraits<T>::value &&\n                                        !has_BlockScalarTraits<T>::value &&\n                                        !has_TaggedScalarTraits<T>::value &&\n                                        !has_MappingTraits<T, Context>::value &&\n                                        !has_SequenceTraits<T>::value &&\n                                        !has_CustomMappingTraits<T>::value &&\n                                        !has_DocumentListTraits<T>::value &&\n                                        !has_PolymorphicTraits<T>::value> {};\n\ntemplate <typename T, typename Context>\nstruct validatedMappingTraits\n    : public std::integral_constant<\n          bool, has_MappingTraits<T, Context>::value &&\n                    has_MappingValidateTraits<T, Context>::value> {};\n\ntemplate <typename T, typename Context>\nstruct unvalidatedMappingTraits\n    : public std::integral_constant<\n          bool, has_MappingTraits<T, Context>::value &&\n                    !has_MappingValidateTraits<T, Context>::value> {};\n\n// Base class for Input and Output.\nclass IO {\npublic:\n  IO(void *Ctxt = nullptr);\n  virtual ~IO();\n\n  virtual bool outputting() const = 0;\n\n  virtual unsigned beginSequence() = 0;\n  virtual bool preflightElement(unsigned, void *&) = 0;\n  virtual void postflightElement(void*) = 0;\n  virtual void endSequence() = 0;\n  virtual bool canElideEmptySequence() = 0;\n\n  virtual unsigned beginFlowSequence() = 0;\n  virtual bool preflightFlowElement(unsigned, void *&) = 0;\n  virtual void postflightFlowElement(void*) = 0;\n  virtual void endFlowSequence() = 0;\n\n  virtual bool mapTag(StringRef Tag, bool Default=false) = 0;\n  virtual void beginMapping() = 0;\n  virtual void endMapping() = 0;\n  virtual bool preflightKey(const char*, bool, bool, bool &, void *&) = 0;\n  virtual void postflightKey(void*) = 0;\n  virtual std::vector<StringRef> keys() = 0;\n\n  virtual void beginFlowMapping() = 0;\n  virtual void endFlowMapping() = 0;\n\n  virtual void beginEnumScalar() = 0;\n  virtual bool matchEnumScalar(const char*, bool) = 0;\n  virtual bool matchEnumFallback() = 0;\n  virtual void endEnumScalar() = 0;\n\n  virtual bool beginBitSetScalar(bool &) = 0;\n  virtual bool bitSetMatch(const char*, bool) = 0;\n  virtual void endBitSetScalar() = 0;\n\n  virtual void scalarString(StringRef &, QuotingType) = 0;\n  virtual void blockScalarString(StringRef &) = 0;\n  virtual void scalarTag(std::string &) = 0;\n\n  virtual NodeKind getNodeKind() = 0;\n\n  virtual void setError(const Twine &) = 0;\n  virtual void setAllowUnknownKeys(bool Allow);\n\n  template <typename T>\n  void enumCase(T &Val, const char* Str, const T ConstVal) {\n    if ( matchEnumScalar(Str, outputting() && Val == ConstVal) ) {\n      Val = ConstVal;\n    }\n  }\n\n  // allow anonymous enum values to be used with LLVM_YAML_STRONG_TYPEDEF\n  template <typename T>\n  void enumCase(T &Val, const char* Str, const uint32_t ConstVal) {\n    if ( matchEnumScalar(Str, outputting() && Val == static_cast<T>(ConstVal)) ) {\n      Val = ConstVal;\n    }\n  }\n\n  template <typename FBT, typename T>\n  void enumFallback(T &Val) {\n    if (matchEnumFallback()) {\n      EmptyContext Context;\n      // FIXME: Force integral conversion to allow strong typedefs to convert.\n      FBT Res = static_cast<typename FBT::BaseType>(Val);\n      yamlize(*this, Res, true, Context);\n      Val = static_cast<T>(static_cast<typename FBT::BaseType>(Res));\n    }\n  }\n\n  template <typename T>\n  void bitSetCase(T &Val, const char* Str, const T ConstVal) {\n    if ( bitSetMatch(Str, outputting() && (Val & ConstVal) == ConstVal) ) {\n      Val = static_cast<T>(Val | ConstVal);\n    }\n  }\n\n  // allow anonymous enum values to be used with LLVM_YAML_STRONG_TYPEDEF\n  template <typename T>\n  void bitSetCase(T &Val, const char* Str, const uint32_t ConstVal) {\n    if ( bitSetMatch(Str, outputting() && (Val & ConstVal) == ConstVal) ) {\n      Val = static_cast<T>(Val | ConstVal);\n    }\n  }\n\n  template <typename T>\n  void maskedBitSetCase(T &Val, const char *Str, T ConstVal, T Mask) {\n    if (bitSetMatch(Str, outputting() && (Val & Mask) == ConstVal))\n      Val = Val | ConstVal;\n  }\n\n  template <typename T>\n  void maskedBitSetCase(T &Val, const char *Str, uint32_t ConstVal,\n                        uint32_t Mask) {\n    if (bitSetMatch(Str, outputting() && (Val & Mask) == ConstVal))\n      Val = Val | ConstVal;\n  }\n\n  void *getContext() const;\n  void setContext(void *);\n\n  template <typename T> void mapRequired(const char *Key, T &Val) {\n    EmptyContext Ctx;\n    this->processKey(Key, Val, true, Ctx);\n  }\n\n  template <typename T, typename Context>\n  void mapRequired(const char *Key, T &Val, Context &Ctx) {\n    this->processKey(Key, Val, true, Ctx);\n  }\n\n  template <typename T> void mapOptional(const char *Key, T &Val) {\n    EmptyContext Ctx;\n    mapOptionalWithContext(Key, Val, Ctx);\n  }\n\n  template <typename T, typename DefaultT>\n  void mapOptional(const char *Key, T &Val, const DefaultT &Default) {\n    EmptyContext Ctx;\n    mapOptionalWithContext(Key, Val, Default, Ctx);\n  }\n\n  template <typename T, typename Context>\n  std::enable_if_t<has_SequenceTraits<T>::value, void>\n  mapOptionalWithContext(const char *Key, T &Val, Context &Ctx) {\n    // omit key/value instead of outputting empty sequence\n    if (this->canElideEmptySequence() && !(Val.begin() != Val.end()))\n      return;\n    this->processKey(Key, Val, false, Ctx);\n  }\n\n  template <typename T, typename Context>\n  void mapOptionalWithContext(const char *Key, Optional<T> &Val, Context &Ctx) {\n    this->processKeyWithDefault(Key, Val, Optional<T>(), /*Required=*/false,\n                                Ctx);\n  }\n\n  template <typename T, typename Context>\n  std::enable_if_t<!has_SequenceTraits<T>::value, void>\n  mapOptionalWithContext(const char *Key, T &Val, Context &Ctx) {\n    this->processKey(Key, Val, false, Ctx);\n  }\n\n  template <typename T, typename Context, typename DefaultT>\n  void mapOptionalWithContext(const char *Key, T &Val, const DefaultT &Default,\n                              Context &Ctx) {\n    static_assert(std::is_convertible<DefaultT, T>::value,\n                  \"Default type must be implicitly convertible to value type!\");\n    this->processKeyWithDefault(Key, Val, static_cast<const T &>(Default),\n                                false, Ctx);\n  }\n\nprivate:\n  template <typename T, typename Context>\n  void processKeyWithDefault(const char *Key, Optional<T> &Val,\n                             const Optional<T> &DefaultValue, bool Required,\n                             Context &Ctx);\n\n  template <typename T, typename Context>\n  void processKeyWithDefault(const char *Key, T &Val, const T &DefaultValue,\n                             bool Required, Context &Ctx) {\n    void *SaveInfo;\n    bool UseDefault;\n    const bool sameAsDefault = outputting() && Val == DefaultValue;\n    if ( this->preflightKey(Key, Required, sameAsDefault, UseDefault,\n                                                                  SaveInfo) ) {\n      yamlize(*this, Val, Required, Ctx);\n      this->postflightKey(SaveInfo);\n    }\n    else {\n      if ( UseDefault )\n        Val = DefaultValue;\n    }\n  }\n\n  template <typename T, typename Context>\n  void processKey(const char *Key, T &Val, bool Required, Context &Ctx) {\n    void *SaveInfo;\n    bool UseDefault;\n    if ( this->preflightKey(Key, Required, false, UseDefault, SaveInfo) ) {\n      yamlize(*this, Val, Required, Ctx);\n      this->postflightKey(SaveInfo);\n    }\n  }\n\nprivate:\n  void *Ctxt;\n};\n\nnamespace detail {\n\ntemplate <typename T, typename Context>\nvoid doMapping(IO &io, T &Val, Context &Ctx) {\n  MappingContextTraits<T, Context>::mapping(io, Val, Ctx);\n}\n\ntemplate <typename T> void doMapping(IO &io, T &Val, EmptyContext &Ctx) {\n  MappingTraits<T>::mapping(io, Val);\n}\n\n} // end namespace detail\n\ntemplate <typename T>\nstd::enable_if_t<has_ScalarEnumerationTraits<T>::value, void>\nyamlize(IO &io, T &Val, bool, EmptyContext &Ctx) {\n  io.beginEnumScalar();\n  ScalarEnumerationTraits<T>::enumeration(io, Val);\n  io.endEnumScalar();\n}\n\ntemplate <typename T>\nstd::enable_if_t<has_ScalarBitSetTraits<T>::value, void>\nyamlize(IO &io, T &Val, bool, EmptyContext &Ctx) {\n  bool DoClear;\n  if ( io.beginBitSetScalar(DoClear) ) {\n    if ( DoClear )\n      Val = T();\n    ScalarBitSetTraits<T>::bitset(io, Val);\n    io.endBitSetScalar();\n  }\n}\n\ntemplate <typename T>\nstd::enable_if_t<has_ScalarTraits<T>::value, void> yamlize(IO &io, T &Val, bool,\n                                                           EmptyContext &Ctx) {\n  if ( io.outputting() ) {\n    std::string Storage;\n    raw_string_ostream Buffer(Storage);\n    ScalarTraits<T>::output(Val, io.getContext(), Buffer);\n    StringRef Str = Buffer.str();\n    io.scalarString(Str, ScalarTraits<T>::mustQuote(Str));\n  }\n  else {\n    StringRef Str;\n    io.scalarString(Str, ScalarTraits<T>::mustQuote(Str));\n    StringRef Result = ScalarTraits<T>::input(Str, io.getContext(), Val);\n    if ( !Result.empty() ) {\n      io.setError(Twine(Result));\n    }\n  }\n}\n\ntemplate <typename T>\nstd::enable_if_t<has_BlockScalarTraits<T>::value, void>\nyamlize(IO &YamlIO, T &Val, bool, EmptyContext &Ctx) {\n  if (YamlIO.outputting()) {\n    std::string Storage;\n    raw_string_ostream Buffer(Storage);\n    BlockScalarTraits<T>::output(Val, YamlIO.getContext(), Buffer);\n    StringRef Str = Buffer.str();\n    YamlIO.blockScalarString(Str);\n  } else {\n    StringRef Str;\n    YamlIO.blockScalarString(Str);\n    StringRef Result =\n        BlockScalarTraits<T>::input(Str, YamlIO.getContext(), Val);\n    if (!Result.empty())\n      YamlIO.setError(Twine(Result));\n  }\n}\n\ntemplate <typename T>\nstd::enable_if_t<has_TaggedScalarTraits<T>::value, void>\nyamlize(IO &io, T &Val, bool, EmptyContext &Ctx) {\n  if (io.outputting()) {\n    std::string ScalarStorage, TagStorage;\n    raw_string_ostream ScalarBuffer(ScalarStorage), TagBuffer(TagStorage);\n    TaggedScalarTraits<T>::output(Val, io.getContext(), ScalarBuffer,\n                                  TagBuffer);\n    io.scalarTag(TagBuffer.str());\n    StringRef ScalarStr = ScalarBuffer.str();\n    io.scalarString(ScalarStr,\n                    TaggedScalarTraits<T>::mustQuote(Val, ScalarStr));\n  } else {\n    std::string Tag;\n    io.scalarTag(Tag);\n    StringRef Str;\n    io.scalarString(Str, QuotingType::None);\n    StringRef Result =\n        TaggedScalarTraits<T>::input(Str, Tag, io.getContext(), Val);\n    if (!Result.empty()) {\n      io.setError(Twine(Result));\n    }\n  }\n}\n\ntemplate <typename T, typename Context>\nstd::enable_if_t<validatedMappingTraits<T, Context>::value, void>\nyamlize(IO &io, T &Val, bool, Context &Ctx) {\n  if (has_FlowTraits<MappingTraits<T>>::value)\n    io.beginFlowMapping();\n  else\n    io.beginMapping();\n  if (io.outputting()) {\n    std::string Err = MappingTraits<T>::validate(io, Val);\n    if (!Err.empty()) {\n      errs() << Err << \"\\n\";\n      assert(Err.empty() && \"invalid struct trying to be written as yaml\");\n    }\n  }\n  detail::doMapping(io, Val, Ctx);\n  if (!io.outputting()) {\n    std::string Err = MappingTraits<T>::validate(io, Val);\n    if (!Err.empty())\n      io.setError(Err);\n  }\n  if (has_FlowTraits<MappingTraits<T>>::value)\n    io.endFlowMapping();\n  else\n    io.endMapping();\n}\n\ntemplate <typename T, typename Context>\nstd::enable_if_t<unvalidatedMappingTraits<T, Context>::value, void>\nyamlize(IO &io, T &Val, bool, Context &Ctx) {\n  if (has_FlowTraits<MappingTraits<T>>::value) {\n    io.beginFlowMapping();\n    detail::doMapping(io, Val, Ctx);\n    io.endFlowMapping();\n  } else {\n    io.beginMapping();\n    detail::doMapping(io, Val, Ctx);\n    io.endMapping();\n  }\n}\n\ntemplate <typename T>\nstd::enable_if_t<has_CustomMappingTraits<T>::value, void>\nyamlize(IO &io, T &Val, bool, EmptyContext &Ctx) {\n  if ( io.outputting() ) {\n    io.beginMapping();\n    CustomMappingTraits<T>::output(io, Val);\n    io.endMapping();\n  } else {\n    io.beginMapping();\n    for (StringRef key : io.keys())\n      CustomMappingTraits<T>::inputOne(io, key, Val);\n    io.endMapping();\n  }\n}\n\ntemplate <typename T>\nstd::enable_if_t<has_PolymorphicTraits<T>::value, void>\nyamlize(IO &io, T &Val, bool, EmptyContext &Ctx) {\n  switch (io.outputting() ? PolymorphicTraits<T>::getKind(Val)\n                          : io.getNodeKind()) {\n  case NodeKind::Scalar:\n    return yamlize(io, PolymorphicTraits<T>::getAsScalar(Val), true, Ctx);\n  case NodeKind::Map:\n    return yamlize(io, PolymorphicTraits<T>::getAsMap(Val), true, Ctx);\n  case NodeKind::Sequence:\n    return yamlize(io, PolymorphicTraits<T>::getAsSequence(Val), true, Ctx);\n  }\n}\n\ntemplate <typename T>\nstd::enable_if_t<missingTraits<T, EmptyContext>::value, void>\nyamlize(IO &io, T &Val, bool, EmptyContext &Ctx) {\n  char missing_yaml_trait_for_type[sizeof(MissingTrait<T>)];\n}\n\ntemplate <typename T, typename Context>\nstd::enable_if_t<has_SequenceTraits<T>::value, void>\nyamlize(IO &io, T &Seq, bool, Context &Ctx) {\n  if ( has_FlowTraits< SequenceTraits<T>>::value ) {\n    unsigned incnt = io.beginFlowSequence();\n    unsigned count = io.outputting() ? SequenceTraits<T>::size(io, Seq) : incnt;\n    for(unsigned i=0; i < count; ++i) {\n      void *SaveInfo;\n      if ( io.preflightFlowElement(i, SaveInfo) ) {\n        yamlize(io, SequenceTraits<T>::element(io, Seq, i), true, Ctx);\n        io.postflightFlowElement(SaveInfo);\n      }\n    }\n    io.endFlowSequence();\n  }\n  else {\n    unsigned incnt = io.beginSequence();\n    unsigned count = io.outputting() ? SequenceTraits<T>::size(io, Seq) : incnt;\n    for(unsigned i=0; i < count; ++i) {\n      void *SaveInfo;\n      if ( io.preflightElement(i, SaveInfo) ) {\n        yamlize(io, SequenceTraits<T>::element(io, Seq, i), true, Ctx);\n        io.postflightElement(SaveInfo);\n      }\n    }\n    io.endSequence();\n  }\n}\n\ntemplate<>\nstruct ScalarTraits<bool> {\n  static void output(const bool &, void* , raw_ostream &);\n  static StringRef input(StringRef, void *, bool &);\n  static QuotingType mustQuote(StringRef) { return QuotingType::None; }\n};\n\ntemplate<>\nstruct ScalarTraits<StringRef> {\n  static void output(const StringRef &, void *, raw_ostream &);\n  static StringRef input(StringRef, void *, StringRef &);\n  static QuotingType mustQuote(StringRef S) { return needsQuotes(S); }\n};\n\ntemplate<>\nstruct ScalarTraits<std::string> {\n  static void output(const std::string &, void *, raw_ostream &);\n  static StringRef input(StringRef, void *, std::string &);\n  static QuotingType mustQuote(StringRef S) { return needsQuotes(S); }\n};\n\ntemplate<>\nstruct ScalarTraits<uint8_t> {\n  static void output(const uint8_t &, void *, raw_ostream &);\n  static StringRef input(StringRef, void *, uint8_t &);\n  static QuotingType mustQuote(StringRef) { return QuotingType::None; }\n};\n\ntemplate<>\nstruct ScalarTraits<uint16_t> {\n  static void output(const uint16_t &, void *, raw_ostream &);\n  static StringRef input(StringRef, void *, uint16_t &);\n  static QuotingType mustQuote(StringRef) { return QuotingType::None; }\n};\n\ntemplate<>\nstruct ScalarTraits<uint32_t> {\n  static void output(const uint32_t &, void *, raw_ostream &);\n  static StringRef input(StringRef, void *, uint32_t &);\n  static QuotingType mustQuote(StringRef) { return QuotingType::None; }\n};\n\ntemplate<>\nstruct ScalarTraits<uint64_t> {\n  static void output(const uint64_t &, void *, raw_ostream &);\n  static StringRef input(StringRef, void *, uint64_t &);\n  static QuotingType mustQuote(StringRef) { return QuotingType::None; }\n};\n\ntemplate<>\nstruct ScalarTraits<int8_t> {\n  static void output(const int8_t &, void *, raw_ostream &);\n  static StringRef input(StringRef, void *, int8_t &);\n  static QuotingType mustQuote(StringRef) { return QuotingType::None; }\n};\n\ntemplate<>\nstruct ScalarTraits<int16_t> {\n  static void output(const int16_t &, void *, raw_ostream &);\n  static StringRef input(StringRef, void *, int16_t &);\n  static QuotingType mustQuote(StringRef) { return QuotingType::None; }\n};\n\ntemplate<>\nstruct ScalarTraits<int32_t> {\n  static void output(const int32_t &, void *, raw_ostream &);\n  static StringRef input(StringRef, void *, int32_t &);\n  static QuotingType mustQuote(StringRef) { return QuotingType::None; }\n};\n\ntemplate<>\nstruct ScalarTraits<int64_t> {\n  static void output(const int64_t &, void *, raw_ostream &);\n  static StringRef input(StringRef, void *, int64_t &);\n  static QuotingType mustQuote(StringRef) { return QuotingType::None; }\n};\n\ntemplate<>\nstruct ScalarTraits<float> {\n  static void output(const float &, void *, raw_ostream &);\n  static StringRef input(StringRef, void *, float &);\n  static QuotingType mustQuote(StringRef) { return QuotingType::None; }\n};\n\ntemplate<>\nstruct ScalarTraits<double> {\n  static void output(const double &, void *, raw_ostream &);\n  static StringRef input(StringRef, void *, double &);\n  static QuotingType mustQuote(StringRef) { return QuotingType::None; }\n};\n\n// For endian types, we use existing scalar Traits class for the underlying\n// type.  This way endian aware types are supported whenever the traits are\n// defined for the underlying type.\ntemplate <typename value_type, support::endianness endian, size_t alignment>\nstruct ScalarTraits<support::detail::packed_endian_specific_integral<\n                        value_type, endian, alignment>,\n                    std::enable_if_t<has_ScalarTraits<value_type>::value>> {\n  using endian_type =\n      support::detail::packed_endian_specific_integral<value_type, endian,\n                                                       alignment>;\n\n  static void output(const endian_type &E, void *Ctx, raw_ostream &Stream) {\n    ScalarTraits<value_type>::output(static_cast<value_type>(E), Ctx, Stream);\n  }\n\n  static StringRef input(StringRef Str, void *Ctx, endian_type &E) {\n    value_type V;\n    auto R = ScalarTraits<value_type>::input(Str, Ctx, V);\n    E = static_cast<endian_type>(V);\n    return R;\n  }\n\n  static QuotingType mustQuote(StringRef Str) {\n    return ScalarTraits<value_type>::mustQuote(Str);\n  }\n};\n\ntemplate <typename value_type, support::endianness endian, size_t alignment>\nstruct ScalarEnumerationTraits<\n    support::detail::packed_endian_specific_integral<value_type, endian,\n                                                     alignment>,\n    std::enable_if_t<has_ScalarEnumerationTraits<value_type>::value>> {\n  using endian_type =\n      support::detail::packed_endian_specific_integral<value_type, endian,\n                                                       alignment>;\n\n  static void enumeration(IO &io, endian_type &E) {\n    value_type V = E;\n    ScalarEnumerationTraits<value_type>::enumeration(io, V);\n    E = V;\n  }\n};\n\ntemplate <typename value_type, support::endianness endian, size_t alignment>\nstruct ScalarBitSetTraits<\n    support::detail::packed_endian_specific_integral<value_type, endian,\n                                                     alignment>,\n    std::enable_if_t<has_ScalarBitSetTraits<value_type>::value>> {\n  using endian_type =\n      support::detail::packed_endian_specific_integral<value_type, endian,\n                                                       alignment>;\n  static void bitset(IO &io, endian_type &E) {\n    value_type V = E;\n    ScalarBitSetTraits<value_type>::bitset(io, V);\n    E = V;\n  }\n};\n\n// Utility for use within MappingTraits<>::mapping() method\n// to [de]normalize an object for use with YAML conversion.\ntemplate <typename TNorm, typename TFinal>\nstruct MappingNormalization {\n  MappingNormalization(IO &i_o, TFinal &Obj)\n      : io(i_o), BufPtr(nullptr), Result(Obj) {\n    if ( io.outputting() ) {\n      BufPtr = new (&Buffer) TNorm(io, Obj);\n    }\n    else {\n      BufPtr = new (&Buffer) TNorm(io);\n    }\n  }\n\n  ~MappingNormalization() {\n    if ( ! io.outputting() ) {\n      Result = BufPtr->denormalize(io);\n    }\n    BufPtr->~TNorm();\n  }\n\n  TNorm* operator->() { return BufPtr; }\n\nprivate:\n  using Storage = AlignedCharArrayUnion<TNorm>;\n\n  Storage       Buffer;\n  IO           &io;\n  TNorm        *BufPtr;\n  TFinal       &Result;\n};\n\n// Utility for use within MappingTraits<>::mapping() method\n// to [de]normalize an object for use with YAML conversion.\ntemplate <typename TNorm, typename TFinal>\nstruct MappingNormalizationHeap {\n  MappingNormalizationHeap(IO &i_o, TFinal &Obj, BumpPtrAllocator *allocator)\n    : io(i_o), Result(Obj) {\n    if ( io.outputting() ) {\n      BufPtr = new (&Buffer) TNorm(io, Obj);\n    }\n    else if (allocator) {\n      BufPtr = allocator->Allocate<TNorm>();\n      new (BufPtr) TNorm(io);\n    } else {\n      BufPtr = new TNorm(io);\n    }\n  }\n\n  ~MappingNormalizationHeap() {\n    if ( io.outputting() ) {\n      BufPtr->~TNorm();\n    }\n    else {\n      Result = BufPtr->denormalize(io);\n    }\n  }\n\n  TNorm* operator->() { return BufPtr; }\n\nprivate:\n  using Storage = AlignedCharArrayUnion<TNorm>;\n\n  Storage       Buffer;\n  IO           &io;\n  TNorm        *BufPtr = nullptr;\n  TFinal       &Result;\n};\n\n///\n/// The Input class is used to parse a yaml document into in-memory structs\n/// and vectors.\n///\n/// It works by using YAMLParser to do a syntax parse of the entire yaml\n/// document, then the Input class builds a graph of HNodes which wraps\n/// each yaml Node.  The extra layer is buffering.  The low level yaml\n/// parser only lets you look at each node once.  The buffering layer lets\n/// you search and interate multiple times.  This is necessary because\n/// the mapRequired() method calls may not be in the same order\n/// as the keys in the document.\n///\nclass Input : public IO {\npublic:\n  // Construct a yaml Input object from a StringRef and optional\n  // user-data. The DiagHandler can be specified to provide\n  // alternative error reporting.\n  Input(StringRef InputContent,\n        void *Ctxt = nullptr,\n        SourceMgr::DiagHandlerTy DiagHandler = nullptr,\n        void *DiagHandlerCtxt = nullptr);\n  Input(MemoryBufferRef Input,\n        void *Ctxt = nullptr,\n        SourceMgr::DiagHandlerTy DiagHandler = nullptr,\n        void *DiagHandlerCtxt = nullptr);\n  ~Input() override;\n\n  // Check if there was an syntax or semantic error during parsing.\n  std::error_code error();\n\nprivate:\n  bool outputting() const override;\n  bool mapTag(StringRef, bool) override;\n  void beginMapping() override;\n  void endMapping() override;\n  bool preflightKey(const char *, bool, bool, bool &, void *&) override;\n  void postflightKey(void *) override;\n  std::vector<StringRef> keys() override;\n  void beginFlowMapping() override;\n  void endFlowMapping() override;\n  unsigned beginSequence() override;\n  void endSequence() override;\n  bool preflightElement(unsigned index, void *&) override;\n  void postflightElement(void *) override;\n  unsigned beginFlowSequence() override;\n  bool preflightFlowElement(unsigned , void *&) override;\n  void postflightFlowElement(void *) override;\n  void endFlowSequence() override;\n  void beginEnumScalar() override;\n  bool matchEnumScalar(const char*, bool) override;\n  bool matchEnumFallback() override;\n  void endEnumScalar() override;\n  bool beginBitSetScalar(bool &) override;\n  bool bitSetMatch(const char *, bool ) override;\n  void endBitSetScalar() override;\n  void scalarString(StringRef &, QuotingType) override;\n  void blockScalarString(StringRef &) override;\n  void scalarTag(std::string &) override;\n  NodeKind getNodeKind() override;\n  void setError(const Twine &message) override;\n  bool canElideEmptySequence() override;\n\n  class HNode {\n    virtual void anchor();\n\n  public:\n    HNode(Node *n) : _node(n) { }\n    virtual ~HNode() = default;\n\n    static bool classof(const HNode *) { return true; }\n\n    Node *_node;\n  };\n\n  class EmptyHNode : public HNode {\n    void anchor() override;\n\n  public:\n    EmptyHNode(Node *n) : HNode(n) { }\n\n    static bool classof(const HNode *n) { return NullNode::classof(n->_node); }\n\n    static bool classof(const EmptyHNode *) { return true; }\n  };\n\n  class ScalarHNode : public HNode {\n    void anchor() override;\n\n  public:\n    ScalarHNode(Node *n, StringRef s) : HNode(n), _value(s) { }\n\n    StringRef value() const { return _value; }\n\n    static bool classof(const HNode *n) {\n      return ScalarNode::classof(n->_node) ||\n             BlockScalarNode::classof(n->_node);\n    }\n\n    static bool classof(const ScalarHNode *) { return true; }\n\n  protected:\n    StringRef _value;\n  };\n\n  class MapHNode : public HNode {\n    void anchor() override;\n\n  public:\n    MapHNode(Node *n) : HNode(n) { }\n\n    static bool classof(const HNode *n) {\n      return MappingNode::classof(n->_node);\n    }\n\n    static bool classof(const MapHNode *) { return true; }\n\n    using NameToNodeAndLoc =\n        StringMap<std::pair<std::unique_ptr<HNode>, SMRange>>;\n\n    NameToNodeAndLoc Mapping;\n    SmallVector<std::string, 6> ValidKeys;\n  };\n\n  class SequenceHNode : public HNode {\n    void anchor() override;\n\n  public:\n    SequenceHNode(Node *n) : HNode(n) { }\n\n    static bool classof(const HNode *n) {\n      return SequenceNode::classof(n->_node);\n    }\n\n    static bool classof(const SequenceHNode *) { return true; }\n\n    std::vector<std::unique_ptr<HNode>> Entries;\n  };\n\n  std::unique_ptr<Input::HNode> createHNodes(Node *node);\n  void setError(HNode *hnode, const Twine &message);\n  void setError(Node *node, const Twine &message);\n  void setError(const SMRange &Range, const Twine &message);\n\n  void reportWarning(HNode *hnode, const Twine &message);\n  void reportWarning(Node *hnode, const Twine &message);\n  void reportWarning(const SMRange &Range, const Twine &message);\n\npublic:\n  // These are only used by operator>>. They could be private\n  // if those templated things could be made friends.\n  bool setCurrentDocument();\n  bool nextDocument();\n\n  /// Returns the current node that's being parsed by the YAML Parser.\n  const Node *getCurrentNode() const;\n\n  void setAllowUnknownKeys(bool Allow) override;\n\nprivate:\n  SourceMgr                           SrcMgr; // must be before Strm\n  std::unique_ptr<llvm::yaml::Stream> Strm;\n  std::unique_ptr<HNode>              TopNode;\n  std::error_code                     EC;\n  BumpPtrAllocator                    StringAllocator;\n  document_iterator                   DocIterator;\n  std::vector<bool>                   BitValuesUsed;\n  HNode *CurrentNode = nullptr;\n  bool                                ScalarMatchFound = false;\n  bool AllowUnknownKeys = false;\n};\n\n///\n/// The Output class is used to generate a yaml document from in-memory structs\n/// and vectors.\n///\nclass Output : public IO {\npublic:\n  Output(raw_ostream &, void *Ctxt = nullptr, int WrapColumn = 70);\n  ~Output() override;\n\n  /// Set whether or not to output optional values which are equal\n  /// to the default value.  By default, when outputting if you attempt\n  /// to write a value that is equal to the default, the value gets ignored.\n  /// Sometimes, it is useful to be able to see these in the resulting YAML\n  /// anyway.\n  void setWriteDefaultValues(bool Write) { WriteDefaultValues = Write; }\n\n  bool outputting() const override;\n  bool mapTag(StringRef, bool) override;\n  void beginMapping() override;\n  void endMapping() override;\n  bool preflightKey(const char *key, bool, bool, bool &, void *&) override;\n  void postflightKey(void *) override;\n  std::vector<StringRef> keys() override;\n  void beginFlowMapping() override;\n  void endFlowMapping() override;\n  unsigned beginSequence() override;\n  void endSequence() override;\n  bool preflightElement(unsigned, void *&) override;\n  void postflightElement(void *) override;\n  unsigned beginFlowSequence() override;\n  bool preflightFlowElement(unsigned, void *&) override;\n  void postflightFlowElement(void *) override;\n  void endFlowSequence() override;\n  void beginEnumScalar() override;\n  bool matchEnumScalar(const char*, bool) override;\n  bool matchEnumFallback() override;\n  void endEnumScalar() override;\n  bool beginBitSetScalar(bool &) override;\n  bool bitSetMatch(const char *, bool ) override;\n  void endBitSetScalar() override;\n  void scalarString(StringRef &, QuotingType) override;\n  void blockScalarString(StringRef &) override;\n  void scalarTag(std::string &) override;\n  NodeKind getNodeKind() override;\n  void setError(const Twine &message) override;\n  bool canElideEmptySequence() override;\n\n  // These are only used by operator<<. They could be private\n  // if that templated operator could be made a friend.\n  void beginDocuments();\n  bool preflightDocument(unsigned);\n  void postflightDocument();\n  void endDocuments();\n\nprivate:\n  void output(StringRef s);\n  void outputUpToEndOfLine(StringRef s);\n  void newLineCheck(bool EmptySequence = false);\n  void outputNewLine();\n  void paddedKey(StringRef key);\n  void flowKey(StringRef Key);\n\n  enum InState {\n    inSeqFirstElement,\n    inSeqOtherElement,\n    inFlowSeqFirstElement,\n    inFlowSeqOtherElement,\n    inMapFirstKey,\n    inMapOtherKey,\n    inFlowMapFirstKey,\n    inFlowMapOtherKey\n  };\n\n  static bool inSeqAnyElement(InState State);\n  static bool inFlowSeqAnyElement(InState State);\n  static bool inMapAnyKey(InState State);\n  static bool inFlowMapAnyKey(InState State);\n\n  raw_ostream &Out;\n  int WrapColumn;\n  SmallVector<InState, 8> StateStack;\n  int Column = 0;\n  int ColumnAtFlowStart = 0;\n  int ColumnAtMapFlowStart = 0;\n  bool NeedBitValueComma = false;\n  bool NeedFlowSequenceComma = false;\n  bool EnumerationMatchFound = false;\n  bool WriteDefaultValues = false;\n  StringRef Padding;\n  StringRef PaddingBeforeContainer;\n};\n\ntemplate <typename T, typename Context>\nvoid IO::processKeyWithDefault(const char *Key, Optional<T> &Val,\n                               const Optional<T> &DefaultValue, bool Required,\n                               Context &Ctx) {\n  assert(DefaultValue.hasValue() == false &&\n         \"Optional<T> shouldn't have a value!\");\n  void *SaveInfo;\n  bool UseDefault = true;\n  const bool sameAsDefault = outputting() && !Val.hasValue();\n  if (!outputting() && !Val.hasValue())\n    Val = T();\n  if (Val.hasValue() &&\n      this->preflightKey(Key, Required, sameAsDefault, UseDefault, SaveInfo)) {\n\n    // When reading an Optional<X> key from a YAML description, we allow the\n    // special \"<none>\" value, which can be used to specify that no value was\n    // requested, i.e. the DefaultValue will be assigned. The DefaultValue is\n    // usually None.\n    bool IsNone = false;\n    if (!outputting())\n      if (auto *Node = dyn_cast<ScalarNode>(((Input *)this)->getCurrentNode()))\n        // We use rtrim to ignore possible white spaces that might exist when a\n        // comment is present on the same line.\n        IsNone = Node->getRawValue().rtrim(' ') == \"<none>\";\n\n    if (IsNone)\n      Val = DefaultValue;\n    else\n      yamlize(*this, Val.getValue(), Required, Ctx);\n    this->postflightKey(SaveInfo);\n  } else {\n    if (UseDefault)\n      Val = DefaultValue;\n  }\n}\n\n/// YAML I/O does conversion based on types. But often native data types\n/// are just a typedef of built in intergral types (e.g. int).  But the C++\n/// type matching system sees through the typedef and all the typedefed types\n/// look like a built in type. This will cause the generic YAML I/O conversion\n/// to be used. To provide better control over the YAML conversion, you can\n/// use this macro instead of typedef.  It will create a class with one field\n/// and automatic conversion operators to and from the base type.\n/// Based on BOOST_STRONG_TYPEDEF\n#define LLVM_YAML_STRONG_TYPEDEF(_base, _type)                                 \\\n    struct _type {                                                             \\\n        _type() = default;                                                     \\\n        _type(const _base v) : value(v) {}                                     \\\n        _type(const _type &v) = default;                                       \\\n        _type &operator=(const _type &rhs) = default;                          \\\n        _type &operator=(const _base &rhs) { value = rhs; return *this; }      \\\n        operator const _base & () const { return value; }                      \\\n        bool operator==(const _type &rhs) const { return value == rhs.value; } \\\n        bool operator==(const _base &rhs) const { return value == rhs; }       \\\n        bool operator<(const _type &rhs) const { return value < rhs.value; }   \\\n        _base value;                                                           \\\n        using BaseType = _base;                                                \\\n    };\n\n///\n/// Use these types instead of uintXX_t in any mapping to have\n/// its yaml output formatted as hexadecimal.\n///\nLLVM_YAML_STRONG_TYPEDEF(uint8_t, Hex8)\nLLVM_YAML_STRONG_TYPEDEF(uint16_t, Hex16)\nLLVM_YAML_STRONG_TYPEDEF(uint32_t, Hex32)\nLLVM_YAML_STRONG_TYPEDEF(uint64_t, Hex64)\n\ntemplate<>\nstruct ScalarTraits<Hex8> {\n  static void output(const Hex8 &, void *, raw_ostream &);\n  static StringRef input(StringRef, void *, Hex8 &);\n  static QuotingType mustQuote(StringRef) { return QuotingType::None; }\n};\n\ntemplate<>\nstruct ScalarTraits<Hex16> {\n  static void output(const Hex16 &, void *, raw_ostream &);\n  static StringRef input(StringRef, void *, Hex16 &);\n  static QuotingType mustQuote(StringRef) { return QuotingType::None; }\n};\n\ntemplate<>\nstruct ScalarTraits<Hex32> {\n  static void output(const Hex32 &, void *, raw_ostream &);\n  static StringRef input(StringRef, void *, Hex32 &);\n  static QuotingType mustQuote(StringRef) { return QuotingType::None; }\n};\n\ntemplate<>\nstruct ScalarTraits<Hex64> {\n  static void output(const Hex64 &, void *, raw_ostream &);\n  static StringRef input(StringRef, void *, Hex64 &);\n  static QuotingType mustQuote(StringRef) { return QuotingType::None; }\n};\n\ntemplate <> struct ScalarTraits<VersionTuple> {\n  static void output(const VersionTuple &Value, void *, llvm::raw_ostream &Out);\n  static StringRef input(StringRef, void *, VersionTuple &);\n  static QuotingType mustQuote(StringRef) { return QuotingType::None; }\n};\n\n// Define non-member operator>> so that Input can stream in a document list.\ntemplate <typename T>\ninline std::enable_if_t<has_DocumentListTraits<T>::value, Input &>\noperator>>(Input &yin, T &docList) {\n  int i = 0;\n  EmptyContext Ctx;\n  while ( yin.setCurrentDocument() ) {\n    yamlize(yin, DocumentListTraits<T>::element(yin, docList, i), true, Ctx);\n    if ( yin.error() )\n      return yin;\n    yin.nextDocument();\n    ++i;\n  }\n  return yin;\n}\n\n// Define non-member operator>> so that Input can stream in a map as a document.\ntemplate <typename T>\ninline std::enable_if_t<has_MappingTraits<T, EmptyContext>::value, Input &>\noperator>>(Input &yin, T &docMap) {\n  EmptyContext Ctx;\n  yin.setCurrentDocument();\n  yamlize(yin, docMap, true, Ctx);\n  return yin;\n}\n\n// Define non-member operator>> so that Input can stream in a sequence as\n// a document.\ntemplate <typename T>\ninline std::enable_if_t<has_SequenceTraits<T>::value, Input &>\noperator>>(Input &yin, T &docSeq) {\n  EmptyContext Ctx;\n  if (yin.setCurrentDocument())\n    yamlize(yin, docSeq, true, Ctx);\n  return yin;\n}\n\n// Define non-member operator>> so that Input can stream in a block scalar.\ntemplate <typename T>\ninline std::enable_if_t<has_BlockScalarTraits<T>::value, Input &>\noperator>>(Input &In, T &Val) {\n  EmptyContext Ctx;\n  if (In.setCurrentDocument())\n    yamlize(In, Val, true, Ctx);\n  return In;\n}\n\n// Define non-member operator>> so that Input can stream in a string map.\ntemplate <typename T>\ninline std::enable_if_t<has_CustomMappingTraits<T>::value, Input &>\noperator>>(Input &In, T &Val) {\n  EmptyContext Ctx;\n  if (In.setCurrentDocument())\n    yamlize(In, Val, true, Ctx);\n  return In;\n}\n\n// Define non-member operator>> so that Input can stream in a polymorphic type.\ntemplate <typename T>\ninline std::enable_if_t<has_PolymorphicTraits<T>::value, Input &>\noperator>>(Input &In, T &Val) {\n  EmptyContext Ctx;\n  if (In.setCurrentDocument())\n    yamlize(In, Val, true, Ctx);\n  return In;\n}\n\n// Provide better error message about types missing a trait specialization\ntemplate <typename T>\ninline std::enable_if_t<missingTraits<T, EmptyContext>::value, Input &>\noperator>>(Input &yin, T &docSeq) {\n  char missing_yaml_trait_for_type[sizeof(MissingTrait<T>)];\n  return yin;\n}\n\n// Define non-member operator<< so that Output can stream out document list.\ntemplate <typename T>\ninline std::enable_if_t<has_DocumentListTraits<T>::value, Output &>\noperator<<(Output &yout, T &docList) {\n  EmptyContext Ctx;\n  yout.beginDocuments();\n  const size_t count = DocumentListTraits<T>::size(yout, docList);\n  for(size_t i=0; i < count; ++i) {\n    if ( yout.preflightDocument(i) ) {\n      yamlize(yout, DocumentListTraits<T>::element(yout, docList, i), true,\n              Ctx);\n      yout.postflightDocument();\n    }\n  }\n  yout.endDocuments();\n  return yout;\n}\n\n// Define non-member operator<< so that Output can stream out a map.\ntemplate <typename T>\ninline std::enable_if_t<has_MappingTraits<T, EmptyContext>::value, Output &>\noperator<<(Output &yout, T &map) {\n  EmptyContext Ctx;\n  yout.beginDocuments();\n  if ( yout.preflightDocument(0) ) {\n    yamlize(yout, map, true, Ctx);\n    yout.postflightDocument();\n  }\n  yout.endDocuments();\n  return yout;\n}\n\n// Define non-member operator<< so that Output can stream out a sequence.\ntemplate <typename T>\ninline std::enable_if_t<has_SequenceTraits<T>::value, Output &>\noperator<<(Output &yout, T &seq) {\n  EmptyContext Ctx;\n  yout.beginDocuments();\n  if ( yout.preflightDocument(0) ) {\n    yamlize(yout, seq, true, Ctx);\n    yout.postflightDocument();\n  }\n  yout.endDocuments();\n  return yout;\n}\n\n// Define non-member operator<< so that Output can stream out a block scalar.\ntemplate <typename T>\ninline std::enable_if_t<has_BlockScalarTraits<T>::value, Output &>\noperator<<(Output &Out, T &Val) {\n  EmptyContext Ctx;\n  Out.beginDocuments();\n  if (Out.preflightDocument(0)) {\n    yamlize(Out, Val, true, Ctx);\n    Out.postflightDocument();\n  }\n  Out.endDocuments();\n  return Out;\n}\n\n// Define non-member operator<< so that Output can stream out a string map.\ntemplate <typename T>\ninline std::enable_if_t<has_CustomMappingTraits<T>::value, Output &>\noperator<<(Output &Out, T &Val) {\n  EmptyContext Ctx;\n  Out.beginDocuments();\n  if (Out.preflightDocument(0)) {\n    yamlize(Out, Val, true, Ctx);\n    Out.postflightDocument();\n  }\n  Out.endDocuments();\n  return Out;\n}\n\n// Define non-member operator<< so that Output can stream out a polymorphic\n// type.\ntemplate <typename T>\ninline std::enable_if_t<has_PolymorphicTraits<T>::value, Output &>\noperator<<(Output &Out, T &Val) {\n  EmptyContext Ctx;\n  Out.beginDocuments();\n  if (Out.preflightDocument(0)) {\n    // FIXME: The parser does not support explicit documents terminated with a\n    // plain scalar; the end-marker is included as part of the scalar token.\n    assert(PolymorphicTraits<T>::getKind(Val) != NodeKind::Scalar && \"plain scalar documents are not supported\");\n    yamlize(Out, Val, true, Ctx);\n    Out.postflightDocument();\n  }\n  Out.endDocuments();\n  return Out;\n}\n\n// Provide better error message about types missing a trait specialization\ntemplate <typename T>\ninline std::enable_if_t<missingTraits<T, EmptyContext>::value, Output &>\noperator<<(Output &yout, T &seq) {\n  char missing_yaml_trait_for_type[sizeof(MissingTrait<T>)];\n  return yout;\n}\n\ntemplate <bool B> struct IsFlowSequenceBase {};\ntemplate <> struct IsFlowSequenceBase<true> { static const bool flow = true; };\n\ntemplate <typename T, bool Flow>\nstruct SequenceTraitsImpl : IsFlowSequenceBase<Flow> {\nprivate:\n  using type = typename T::value_type;\n\npublic:\n  static size_t size(IO &io, T &seq) { return seq.size(); }\n\n  static type &element(IO &io, T &seq, size_t index) {\n    if (index >= seq.size())\n      seq.resize(index + 1);\n    return seq[index];\n  }\n};\n\n// Simple helper to check an expression can be used as a bool-valued template\n// argument.\ntemplate <bool> struct CheckIsBool { static const bool value = true; };\n\n// If T has SequenceElementTraits, then vector<T> and SmallVector<T, N> have\n// SequenceTraits that do the obvious thing.\ntemplate <typename T>\nstruct SequenceTraits<\n    std::vector<T>,\n    std::enable_if_t<CheckIsBool<SequenceElementTraits<T>::flow>::value>>\n    : SequenceTraitsImpl<std::vector<T>, SequenceElementTraits<T>::flow> {};\ntemplate <typename T, unsigned N>\nstruct SequenceTraits<\n    SmallVector<T, N>,\n    std::enable_if_t<CheckIsBool<SequenceElementTraits<T>::flow>::value>>\n    : SequenceTraitsImpl<SmallVector<T, N>, SequenceElementTraits<T>::flow> {};\ntemplate <typename T>\nstruct SequenceTraits<\n    SmallVectorImpl<T>,\n    std::enable_if_t<CheckIsBool<SequenceElementTraits<T>::flow>::value>>\n    : SequenceTraitsImpl<SmallVectorImpl<T>, SequenceElementTraits<T>::flow> {};\n\n// Sequences of fundamental types use flow formatting.\ntemplate <typename T>\nstruct SequenceElementTraits<T,\n                             std::enable_if_t<std::is_fundamental<T>::value>> {\n  static const bool flow = true;\n};\n\n// Sequences of strings use block formatting.\ntemplate<> struct SequenceElementTraits<std::string> {\n  static const bool flow = false;\n};\ntemplate<> struct SequenceElementTraits<StringRef> {\n  static const bool flow = false;\n};\ntemplate<> struct SequenceElementTraits<std::pair<std::string, std::string>> {\n  static const bool flow = false;\n};\n\n/// Implementation of CustomMappingTraits for std::map<std::string, T>.\ntemplate <typename T> struct StdMapStringCustomMappingTraitsImpl {\n  using map_type = std::map<std::string, T>;\n\n  static void inputOne(IO &io, StringRef key, map_type &v) {\n    io.mapRequired(key.str().c_str(), v[std::string(key)]);\n  }\n\n  static void output(IO &io, map_type &v) {\n    for (auto &p : v)\n      io.mapRequired(p.first.c_str(), p.second);\n  }\n};\n\n} // end namespace yaml\n} // end namespace llvm\n\n#define LLVM_YAML_IS_SEQUENCE_VECTOR_IMPL(TYPE, FLOW)                          \\\n  namespace llvm {                                                             \\\n  namespace yaml {                                                             \\\n  static_assert(                                                               \\\n      !std::is_fundamental<TYPE>::value &&                                     \\\n      !std::is_same<TYPE, std::string>::value &&                               \\\n      !std::is_same<TYPE, llvm::StringRef>::value,                             \\\n      \"only use LLVM_YAML_IS_SEQUENCE_VECTOR for types you control\");          \\\n  template <> struct SequenceElementTraits<TYPE> {                             \\\n    static const bool flow = FLOW;                                             \\\n  };                                                                           \\\n  }                                                                            \\\n  }\n\n/// Utility for declaring that a std::vector of a particular type\n/// should be considered a YAML sequence.\n#define LLVM_YAML_IS_SEQUENCE_VECTOR(type)                                     \\\n  LLVM_YAML_IS_SEQUENCE_VECTOR_IMPL(type, false)\n\n/// Utility for declaring that a std::vector of a particular type\n/// should be considered a YAML flow sequence.\n#define LLVM_YAML_IS_FLOW_SEQUENCE_VECTOR(type)                                \\\n  LLVM_YAML_IS_SEQUENCE_VECTOR_IMPL(type, true)\n\n#define LLVM_YAML_DECLARE_MAPPING_TRAITS(Type)                                 \\\n  namespace llvm {                                                             \\\n  namespace yaml {                                                             \\\n  template <> struct MappingTraits<Type> {                                     \\\n    static void mapping(IO &IO, Type &Obj);                                    \\\n  };                                                                           \\\n  }                                                                            \\\n  }\n\n#define LLVM_YAML_DECLARE_ENUM_TRAITS(Type)                                    \\\n  namespace llvm {                                                             \\\n  namespace yaml {                                                             \\\n  template <> struct ScalarEnumerationTraits<Type> {                           \\\n    static void enumeration(IO &io, Type &Value);                              \\\n  };                                                                           \\\n  }                                                                            \\\n  }\n\n#define LLVM_YAML_DECLARE_BITSET_TRAITS(Type)                                  \\\n  namespace llvm {                                                             \\\n  namespace yaml {                                                             \\\n  template <> struct ScalarBitSetTraits<Type> {                                \\\n    static void bitset(IO &IO, Type &Options);                                 \\\n  };                                                                           \\\n  }                                                                            \\\n  }\n\n#define LLVM_YAML_DECLARE_SCALAR_TRAITS(Type, MustQuote)                       \\\n  namespace llvm {                                                             \\\n  namespace yaml {                                                             \\\n  template <> struct ScalarTraits<Type> {                                      \\\n    static void output(const Type &Value, void *ctx, raw_ostream &Out);        \\\n    static StringRef input(StringRef Scalar, void *ctxt, Type &Value);         \\\n    static QuotingType mustQuote(StringRef) { return MustQuote; }              \\\n  };                                                                           \\\n  }                                                                            \\\n  }\n\n/// Utility for declaring that a std::vector of a particular type\n/// should be considered a YAML document list.\n#define LLVM_YAML_IS_DOCUMENT_LIST_VECTOR(_type)                               \\\n  namespace llvm {                                                             \\\n  namespace yaml {                                                             \\\n  template <unsigned N>                                                        \\\n  struct DocumentListTraits<SmallVector<_type, N>>                             \\\n      : public SequenceTraitsImpl<SmallVector<_type, N>, false> {};            \\\n  template <>                                                                  \\\n  struct DocumentListTraits<std::vector<_type>>                                \\\n      : public SequenceTraitsImpl<std::vector<_type>, false> {};               \\\n  }                                                                            \\\n  }\n\n/// Utility for declaring that std::map<std::string, _type> should be considered\n/// a YAML map.\n#define LLVM_YAML_IS_STRING_MAP(_type)                                         \\\n  namespace llvm {                                                             \\\n  namespace yaml {                                                             \\\n  template <>                                                                  \\\n  struct CustomMappingTraits<std::map<std::string, _type>>                     \\\n      : public StdMapStringCustomMappingTraitsImpl<_type> {};                  \\\n  }                                                                            \\\n  }\n\nLLVM_YAML_IS_FLOW_SEQUENCE_VECTOR(llvm::yaml::Hex64)\nLLVM_YAML_IS_FLOW_SEQUENCE_VECTOR(llvm::yaml::Hex32)\nLLVM_YAML_IS_FLOW_SEQUENCE_VECTOR(llvm::yaml::Hex16)\nLLVM_YAML_IS_FLOW_SEQUENCE_VECTOR(llvm::yaml::Hex8)\n\n#endif // LLVM_SUPPORT_YAMLTRAITS_H\n"}}, "reports": [{"events": [{"location": {"col": 7, "file": 0, "line": 20}, "message": "'StoppointHitCounter' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Breakpoint/StoppointHitCounter.h", "reportHash": "c98a806967cc71b47b267e446ec09a36", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 1, "line": 204}, "message": "'ModulePointerAndOffsetLessThanFunctionObject' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Core/Address.h", "reportHash": "0270059516dc15d2d24255d3b62df232", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 2, "line": 16}, "message": "'Architecture' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Core/Architecture.h", "reportHash": "44840105be6437754b8b73d8ca848fe7", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 3, "line": 181}, "message": "'Operand' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Core/Disassembler.h", "reportHash": "319478ce323c2e33e9335316e630bbe3", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 3, "line": 452}, "message": "'SourceLine' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Core/Disassembler.h", "reportHash": "25e7f3aae75d07120c98f6e17f9c39c2", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 3, "line": 470}, "message": "'SourceLinesToDisplay' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Core/Disassembler.h", "reportHash": "9dd27260046c6e398b23e369a53e0ecd", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 4, "line": 187}, "message": "'' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Core/EmulateInstruction.h", "reportHash": "6106a45f6aa200d6f86fe3c25284c35a", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 14, "file": 4, "line": 188}, "message": "'RegisterPlusOffset' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Core/EmulateInstruction.h", "reportHash": "c2b2f610784dd8aaf6da23c2f4dc88ff", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 14, "file": 4, "line": 193}, "message": "'RegisterPlusIndirectOffset' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Core/EmulateInstruction.h", "reportHash": "76eaba6cf21df69e45fe615334a46832", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 14, "file": 4, "line": 198}, "message": "'RegisterToRegisterPlusOffset' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Core/EmulateInstruction.h", "reportHash": "b921482a1b4c59a6817bec674899fc9c", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 14, "file": 4, "line": 204}, "message": "'RegisterToRegisterPlusIndirectOffset' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Core/EmulateInstruction.h", "reportHash": "75dac1bdc45292c433c5005b8526a2a3", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 14, "file": 4, "line": 210}, "message": "'RegisterRegisterOperands' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Core/EmulateInstruction.h", "reportHash": "aab6d70a33a7e55f47a0506bc4007b93", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 14, "file": 4, "line": 227}, "message": "'ISAAndImmediate' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Core/EmulateInstruction.h", "reportHash": "43b57ad5798725c069950cc1d63a1f6c", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 14, "file": 4, "line": 232}, "message": "'ISAAndImmediateSigned' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Core/EmulateInstruction.h", "reportHash": "7091c5cc246c2c4577e0b9640b0a4a1f", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 5, "line": 40}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 5, "line": 40}, "message": "'FileSpecList' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Core/FileSpecList.h", "reportHash": "146d3e2be3e4face07513c6382113e32", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 6, "line": 35}, "message": "'Mangled' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Core/Mangled.h", "reportHash": "5b2f746452b687a06f7740e95d527ced", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 7, "line": 49}, "message": "'ModuleListProperties' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Core/ModuleList.h", "reportHash": "aa0cb968f96fe999bac4d090d2d4efc6", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 8, "line": 26}, "message": "'ModuleSpec' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Core/ModuleSpec.h", "reportHash": "3064bf1b2946e1cb6f5eb37eb1ab51a6", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 9, "line": 29}, "message": "'Opcode' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Core/Opcode.h", "reportHash": "4cb25409be06eab44bb58defea68f7bc", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 9, "line": 258}, "message": "'' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Core/Opcode.h", "reportHash": "e50595b6cd96b94777e1d69281d5e66c", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 9, "line": 263}, "message": "'' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Core/Opcode.h", "reportHash": "9e7dbbe4795a27706f708fb8639b3744", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 29, "file": 10, "line": 26}, "message": "'UniqueCStringMap' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Core/UniqueCStringMap.h", "reportHash": "e11783ebb22cf65467d7c0e89b38b853", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 11, "line": 196}, "message": "'GetValueForExpressionPathOptions' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Core/ValueObject.h", "reportHash": "bcb4490cfe13cb170e0e14494c85dd5b", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 11, "line": 796}, "message": "'ChildrenManager' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Core/ValueObject.h", "reportHash": "3e6116861f3bdb4f5e24bda944ef17b9", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 12, "line": 84}, "message": "'FormattersMatchData' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/DataFormatters/FormatClasses.h", "reportHash": "86990a9384f6933d8c3f14ce0c5421b5", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 12, "line": 148}, "message": "'TypeOrName' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/DataFormatters/FormatClasses.h", "reportHash": "4f852cd874f47a6f1e69bd34f37deb7c", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 13, "line": 41}, "message": "'TypeMatcher' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/DataFormatters/FormattersContainer.h", "reportHash": "c353d8737d56fa1ac2c85c84fb7ba37a", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 14, "line": 63}, "message": "'TypeCategoryImpl' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/DataFormatters/TypeCategory.h", "reportHash": "9682c83c76504fa6a940d0e285d4dfc9", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 15, "line": 34}, "message": "'WaitStatus' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Host/Host.h", "reportHash": "3685179b86c4a7aae2b16f4d97ce160d", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 16, "line": 29}, "message": "'HostThread' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Host/HostThread.h", "reportHash": "1894653438037a39bce63b20fcd2f918", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 17, "line": 30}, "message": "'ProcessLaunchInfo' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Host/ProcessLaunchInfo.h", "reportHash": "4fedd2a766f3e3d8b8938ed0a72324b7", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 18, "line": 28}, "message": "'CompilerDecl' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Symbol/CompilerDecl.h", "reportHash": "ba895fb77af933d3e96b1f9a6e9482a6", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 19, "line": 30}, "message": "'CompilerDeclContext' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Symbol/CompilerDeclContext.h", "reportHash": "3d6786748e76733a0ce7ace942d6b041", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 22, "file": 20, "line": 415}, "message": "'IntegralTemplateArgument' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Symbol/CompilerType.h", "reportHash": "0503158b05bee4f665dcee1eef2bc549", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 21, "line": 24}, "message": "'Declaration' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Symbol/Declaration.h", "reportHash": "4e580315304b21fc2c95be8bb90aa747", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 22, "line": 20}, "message": "'LineEntry' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Symbol/LineEntry.h", "reportHash": "037bd39d6cec49c6f604f5a3809ecce1", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 23, "line": 146}, "message": "'FileRangeToIndexMapCompare' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Symbol/Symtab.h", "reportHash": "f1b949cd1799752ecaa7e8341e0115ae", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 24, "line": 66}, "message": "'Type' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Symbol/Type.h", "reportHash": "f883d926c5363d543f33abc68dc77c3e", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 24, "line": 309}, "message": "'TypeListImpl' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Symbol/Type.h", "reportHash": "6bec104ea665e31a71aabec374cb31dc", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 24, "line": 340}, "message": "'TypeMemberImpl' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Symbol/Type.h", "reportHash": "a433c695b403030d5227cf1805868bd6", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 24, "line": 395}, "message": "'TypeAndOrName' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Symbol/Type.h", "reportHash": "498c16790e352975cfdf089caac85c2c", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 24, "line": 436}, "message": "'TypeMemberFunctionImpl' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Symbol/Type.h", "reportHash": "b2253c9c720b86e6d148c76473367cf6", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 24, "line": 504}, "message": "'TypeEnumMemberListImpl' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Symbol/Type.h", "reportHash": "436b0cbd475295224de983cff536787b", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 25, "line": 40}, "message": "'LanguageSet' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Symbol/TypeSystem.h", "reportHash": "230c9546e44bfe41b8cc12385fcaabd4", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 26, "line": 27}, "message": "'InstrumentationRuntime' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Target/InstrumentationRuntime.h", "reportHash": "52334c4ef5e576b342645937b45de9a2", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 27, "line": 62}, "message": "'ProcessExperimentalProperties' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Target/Process.h", "reportHash": "43b6aa0a856b0549197e0b6e05f5f9f7", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 27, "line": 108}, "message": "'ProcessAttachInfo' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Target/Process.h", "reportHash": "93826af9d6a297db36bdd4d55cbf0ad7", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 28, "line": 74}, "message": "'TargetExperimentalProperties' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Target/Target.h", "reportHash": "32c0d9ed7aafce8a8ed5b2be67355952", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 28, "line": 255}, "message": "'EvaluateExpressionOptions' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Target/Target.h", "reportHash": "9e253e591cb35e57dcfa118071553096", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 28, "line": 1371}, "message": "'Arch' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Target/Target.h", "reportHash": "b6a126578df75e763a0567d336a86a67", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 10, "file": 29, "line": 121}, "message": "'ThreadStateCheckpoint' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Target/Thread.h", "reportHash": "a1edd6595a87746bd0c129acc0e4053b", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 30, "line": 33}, "message": "'ThreadSpec' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Target/ThreadSpec.h", "reportHash": "dbdbbe1e0ea76f2a710ddbc869b58965", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 31, "line": 40}, "message": "'Trace' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Target/Trace.h", "reportHash": "4f57af91aa8658ff438688c50776ab0e", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 32, "line": 319}, "message": "'OptionsWithRaw' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Utility/Args.h", "reportHash": "6b69f3a2d8d6c142ae7187c2a55594a6", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 29, "file": 33, "line": 62}, "message": "'TypedBaton' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Utility/Baton.h", "reportHash": "f5673886190fef8086b15e3fd888bff8", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 34, "line": 38}, "message": "'CompletionResult' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Utility/CompletionRequest.h", "reportHash": "a81f5de01a4c1d1c4ca9ebce3bb3785a", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 34, "line": 41}, "message": "'Completion' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Utility/CompletionRequest.h", "reportHash": "0e76a917600974686fa3c6beae2ce013", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 34, "line": 100}, "message": "'CompletionRequest' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Utility/CompletionRequest.h", "reportHash": "bc9bb9aea7b3ad68e54ada149d3a57f0", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 35, "line": 82}, "message": "'DataBufferUnowned' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Utility/DataBuffer.h", "reportHash": "e0a8e3823b218af867bf5cc66a11e80e", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 5, "file": 36, "line": 24}, "message": "mark 'noexcept'"}, {"location": {"col": 5, "file": 36, "line": 24}, "message": "'Envp' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Utility/Environment.h", "reportHash": "787df511a343e041f2398b68bc1b8932", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 36, "line": 61}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 36, "line": 61}, "message": "'Environment' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Utility/Environment.h", "reportHash": "4d188b11ac09094f6f633ecbc6183de0", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 38, "line": 153}, "message": "'AdaptedIterable' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Utility/Iterable.h", "reportHash": "efac39292356784855e3e4efba4ba9a1", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 38, "line": 178}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 38, "line": 178}, "message": "'LockingAdaptedIterable' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Utility/Iterable.h", "reportHash": "1617bea86e729811a5473a723306c7cc", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 38, "line": 178}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 38, "line": 178}, "message": "'LockingAdaptedIterable<C, E, A, MutexType>' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Utility/Iterable.h", "reportHash": "a05bd73d71e0c75f36453da64d3fadd7", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 39, "line": 30}, "message": "'ProcessInfo' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Utility/ProcessInfo.h", "reportHash": "4914bf4b4927ad994c04244fcfa24832", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 39, "line": 108}, "message": "'ProcessInstanceInfo' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Utility/ProcessInfo.h", "reportHash": "5e13dc205a821a272cdcbe0e57308924", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 40, "line": 39}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 40, "line": 39}, "message": "'RegularExpression' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Utility/RegularExpression.h", "reportHash": "f46af28c0ce54cd8922c219420e9b6b0", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 41, "line": 34}, "message": "'Scalar' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Utility/Scalar.h", "reportHash": "6a3633b7bb7fec06eb172f65355c21f8", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 43, "line": 336}, "message": "'String' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Utility/StructuredData.h", "reportHash": "737dd0aaaaa8e5bec3821db9d8f8e5af", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 43, "line": 533}, "message": "'Generic' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Utility/StructuredData.h", "reportHash": "5258d864539b043dcbb3668a2a3a58ef", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 44, "line": 20}, "message": "'TraceTypeInfo' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Utility/TraceOptions.h", "reportHash": "948784edb2634ece69c4efe7768a01a7", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 44, "line": 31}, "message": "'TraceOptions' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Utility/TraceOptions.h", "reportHash": "72bfa200885544b7d32f9e103b7cb987", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 45, "line": 23}, "message": "'UUID' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Utility/UUID.h", "reportHash": "6db59ab894267182b81fb53f0b5c66dd", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 46, "line": 16}, "message": "'UnimplementedError' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/Utility/UnimplementedError.h", "reportHash": "3bfd66fb426f020e17f41f5caf9ee5e4", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 47, "line": 33}, "message": "'RegisterInfo' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lldb/include/lldb/lldb-private-types.h", "reportHash": "af752c740e5bddd9e48f8190f62f917d", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 48, "line": 170}, "message": "'VariantFrontEnd' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lldb/source/Plugins/Language/CPlusPlus/LibCxxVariant.cpp", "reportHash": "073081209057ae2237a05380bec0d0be", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 54, "line": 60}, "message": "'DenseMapBase' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/DenseMap.h", "reportHash": "8f5b7d70f1d605ce7d4e686d0a7f0122", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 62, "line": 33}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 62, "line": 33}, "message": "'scope_exit<Callable>' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/ScopeExit.h", "reportHash": "2fc73b85277ce2f28af2c569c5cece98", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 63, "line": 160}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 63, "line": 160}, "message": "'SmallBitVector' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/SmallBitVector.h", "reportHash": "baa63e5e222a9066aeaae406e0f93da0", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 69, "line": 22}, "message": "'StringSet' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/ADT/StringSet.h", "reportHash": "219e55a017600177d75d54a8b857fb2b", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 77, "line": 41}, "message": "'DataExtractor' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/DataExtractor.h", "reportHash": "6bcc29be6b9e579a964062624e08ed08", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 81, "line": 70}, "message": "'FileCollector' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/FileCollector.h", "reportHash": "054a5b798dc745ff8bf162d65751bd7e", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 81, "line": 74}, "message": "'PathCanonicalizer' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/FileCollector.h", "reportHash": "73ed07606891b16781bccdece149179f", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 85, "line": 90}, "message": "'Object' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/JSON.h", "reportHash": "6f3a49c3ddfab6b3052e1c5d5f3de016", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 85, "line": 304}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 85, "line": 304}, "message": "'Value' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/JSON.h", "reportHash": "282b2efd9a56a5d5566f2012bcbe254d", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 85, "line": 516}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 85, "line": 516}, "message": "'ObjectKey' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/JSON.h", "reportHash": "ce45b13b33466a327e7a8d1fe2dc57cc", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 16, "file": 85, "line": 548}, "message": "'KV' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/JSON.h", "reportHash": "4bd91d11335b1e9635b37946044eadcc", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 3, "file": 85, "line": 627}, "message": "mark 'noexcept'"}, {"location": {"col": 3, "file": 85, "line": 627}, "message": "'Root' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/JSON.h", "reportHash": "9a874a84e07c3a3251b581b4a77d63ea", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 93, "line": 197}, "message": "'NullNode' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/YAMLParser.h", "reportHash": "f6ed954d3ba17bec36a1fd89cc99c4be", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 93, "line": 212}, "message": "'ScalarNode' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/YAMLParser.h", "reportHash": "40ae8466d4493c621c8590a55a5fecac", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 93, "line": 255}, "message": "'BlockScalarNode' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/YAMLParser.h", "reportHash": "471d394b478907740614e59dc48eddbe", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 93, "line": 285}, "message": "'KeyValueNode' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/YAMLParser.h", "reportHash": "40b70fe576c6ebd7cf8c4649e77f51a8", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 93, "line": 410}, "message": "'MappingNode' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/YAMLParser.h", "reportHash": "623ec40a03b35e4673f03baf63a1a894", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 93, "line": 458}, "message": "'SequenceNode' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/YAMLParser.h", "reportHash": "51f5d88b17bd2dcd22519e301e3b49f4", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 93, "line": 510}, "message": "'AliasNode' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/YAMLParser.h", "reportHash": "9f8a2b676e5e1b0ee236fbc4811915aa", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 93, "line": 527}, "message": "'Document' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/YAMLParser.h", "reportHash": "c8ee46dffa304541bbf2799cff8ac388", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 93, "line": 584}, "message": "'document_iterator' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/YAMLParser.h", "reportHash": "871650a936312b1c16575c07dc103eb3", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 8, "file": 94, "line": 49}, "message": "'EmptyContext' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/YAMLTraits.h", "reportHash": "35827bc094ec47558a19b1cc86484186", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 94, "line": 1435}, "message": "'EmptyHNode' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/YAMLTraits.h", "reportHash": "629309f53502f4efa3490c9e8ee31584", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 94, "line": 1446}, "message": "'ScalarHNode' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/YAMLTraits.h", "reportHash": "a6480bd147be119ecfac546090dc5bc7", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 94, "line": 1465}, "message": "'MapHNode' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/YAMLTraits.h", "reportHash": "7fb620bdff0c4fd06d4fd5c4faf2bd9d", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 9, "file": 94, "line": 1484}, "message": "'SequenceHNode' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/llvm/include/llvm/Support/YAMLTraits.h", "reportHash": "3bef4c917465d1b9bd3cb51019ad78f5", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}]};
      window.onload = function() {
        if (!browserCompatible) {
          setNonCompatibleBrowserMessage();
        } else {
          BugViewer.init(data.files, data.reports);
          BugViewer.create();
          BugViewer.initByUrl();
        }
      };
    </script>
  </head>
  <body>
  <div class="container">
    <div id="content">
      <div id="side-bar">
        <div class="header">
          <a href="index.html" class="button">&#8249; Return to List</a>
        </div>
        <div id="report-nav">
          <div class="header">Reports</div>
        </div>
      </div>
      <div id="editor-wrapper">
        <div class="header">
          <div id="file">
            <span class="label">File:</span>
            <span id="file-path"></span>
          </div>
          <div id="checker">
            <span class="label">Checker name:</span>
            <span id="checker-name"></span>
          </div>
          <div id="review-status-wrapper">
            <span class="label">Review status:</span>
            <span id="review-status"></span>
          </div>
        </div>
        <div id="editor"></div>
      </div>
    </div>
  </div>
  </body>
</html>
