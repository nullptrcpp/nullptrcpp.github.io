<!DOCTYPE html>
<html>
  <head>
    <title>Plist HTML Viewer</title>

    <meta charset="UTF-8">

    <style type="text/css">
      .CodeMirror{font-family:monospace;height:300px;color:#000;direction:ltr}.CodeMirror-lines{padding:4px 0}.CodeMirror pre{padding:0 4px}.CodeMirror-gutter-filler,.CodeMirror-scrollbar-filler{background-color:#fff}.CodeMirror-gutters{border-right:1px solid #ddd;background-color:#f7f7f7;white-space:nowrap}.CodeMirror-linenumber{padding:0 3px 0 5px;min-width:20px;text-align:right;color:#999;white-space:nowrap}.CodeMirror-guttermarker{color:#000}.CodeMirror-guttermarker-subtle{color:#999}.CodeMirror-cursor{border-left:1px solid #000;border-right:none;width:0}.CodeMirror div.CodeMirror-secondarycursor{border-left:1px solid silver}.cm-fat-cursor .CodeMirror-cursor{width:auto;border:0!important;background:#7e7}.cm-fat-cursor div.CodeMirror-cursors{z-index:1}.cm-animate-fat-cursor{width:auto;border:0;-webkit-animation:blink 1.06s steps(1) infinite;-moz-animation:blink 1.06s steps(1) infinite;animation:blink 1.06s steps(1) infinite;background-color:#7e7}@-moz-keyframes blink{50%{background-color:transparent}}@-webkit-keyframes blink{50%{background-color:transparent}}@keyframes blink{50%{background-color:transparent}}.cm-tab{display:inline-block;text-decoration:inherit}.CodeMirror-rulers{position:absolute;left:0;right:0;top:-50px;bottom:-20px;overflow:hidden}.CodeMirror-ruler{border-left:1px solid #ccc;top:0;bottom:0;position:absolute}.cm-s-default .cm-header{color:#00f}.cm-s-default .cm-quote{color:#090}.cm-negative{color:#d44}.cm-positive{color:#292}.cm-header,.cm-strong{font-weight:700}.cm-em{font-style:italic}.cm-link{text-decoration:underline}.cm-strikethrough{text-decoration:line-through}.cm-s-default .cm-keyword{color:#708}.cm-s-default .cm-atom{color:#219}.cm-s-default .cm-number{color:#164}.cm-s-default .cm-def{color:#00f}.cm-s-default .cm-variable-2{color:#05a}.cm-s-default .cm-type,.cm-s-default .cm-variable-3{color:#085}.cm-s-default .cm-comment{color:#a50}.cm-s-default .cm-string{color:#a11}.cm-s-default .cm-string-2{color:#f50}.cm-s-default .cm-meta{color:#555}.cm-s-default .cm-qualifier{color:#555}.cm-s-default .cm-builtin{color:#30a}.cm-s-default .cm-bracket{color:#997}.cm-s-default .cm-tag{color:#170}.cm-s-default .cm-attribute{color:#00c}.cm-s-default .cm-hr{color:#999}.cm-s-default .cm-link{color:#00c}.cm-s-default .cm-error{color:red}.cm-invalidchar{color:red}.CodeMirror-composing{border-bottom:2px solid}div.CodeMirror span.CodeMirror-matchingbracket{color:#0f0}div.CodeMirror span.CodeMirror-nonmatchingbracket{color:#f22}.CodeMirror-matchingtag{background:rgba(255,150,0,.3)}.CodeMirror-activeline-background{background:#e8f2ff}.CodeMirror{position:relative;overflow:hidden;background:#fff}.CodeMirror-scroll{overflow:scroll!important;margin-bottom:-30px;margin-right:-30px;padding-bottom:30px;height:100%;outline:0;position:relative}.CodeMirror-sizer{position:relative;border-right:30px solid transparent}.CodeMirror-gutter-filler,.CodeMirror-hscrollbar,.CodeMirror-scrollbar-filler,.CodeMirror-vscrollbar{position:absolute;z-index:6;display:none}.CodeMirror-vscrollbar{right:0;top:0;overflow-x:hidden;overflow-y:scroll}.CodeMirror-hscrollbar{bottom:0;left:0;overflow-y:hidden;overflow-x:scroll}.CodeMirror-scrollbar-filler{right:0;bottom:0}.CodeMirror-gutter-filler{left:0;bottom:0}.CodeMirror-gutters{position:absolute;left:0;top:0;min-height:100%;z-index:3}.CodeMirror-gutter{white-space:normal;height:100%;display:inline-block;vertical-align:top;margin-bottom:-30px}.CodeMirror-gutter-wrapper{position:absolute;z-index:4;background:0 0!important;border:none!important}.CodeMirror-gutter-background{position:absolute;top:0;bottom:0;z-index:4}.CodeMirror-gutter-elt{position:absolute;cursor:default;z-index:4}.CodeMirror-gutter-wrapper ::selection{background-color:transparent}.CodeMirror-gutter-wrapper ::-moz-selection{background-color:transparent}.CodeMirror-lines{cursor:text;min-height:1px}.CodeMirror pre{-moz-border-radius:0;-webkit-border-radius:0;border-radius:0;border-width:0;background:0 0;font-family:inherit;font-size:inherit;margin:0;white-space:pre;word-wrap:normal;line-height:inherit;color:inherit;z-index:2;position:relative;overflow:visible;-webkit-tap-highlight-color:transparent;-webkit-font-variant-ligatures:contextual;font-variant-ligatures:contextual}.CodeMirror-wrap pre{word-wrap:break-word;white-space:pre-wrap;word-break:normal}.CodeMirror-linebackground{position:absolute;left:0;right:0;top:0;bottom:0;z-index:0}.CodeMirror-linewidget{position:relative;z-index:2;overflow:auto}.CodeMirror-rtl pre{direction:rtl}.CodeMirror-code{outline:0}.CodeMirror-gutter,.CodeMirror-gutters,.CodeMirror-linenumber,.CodeMirror-scroll,.CodeMirror-sizer{-moz-box-sizing:content-box;box-sizing:content-box}.CodeMirror-measure{position:absolute;width:100%;height:0;overflow:hidden;visibility:hidden}.CodeMirror-cursor{position:absolute;pointer-events:none}.CodeMirror-measure pre{position:static}div.CodeMirror-cursors{visibility:hidden;position:relative;z-index:3}div.CodeMirror-dragcursors{visibility:visible}.CodeMirror-focused div.CodeMirror-cursors{visibility:visible}.CodeMirror-selected{background:#d9d9d9}.CodeMirror-focused .CodeMirror-selected{background:#d7d4f0}.CodeMirror-crosshair{cursor:crosshair}.CodeMirror-line::selection,.CodeMirror-line>span::selection,.CodeMirror-line>span>span::selection{background:#d7d4f0}.CodeMirror-line::-moz-selection,.CodeMirror-line>span::-moz-selection,.CodeMirror-line>span>span::-moz-selection{background:#d7d4f0}.cm-searching{background-color:#ffa;background-color:rgba(255,255,0,.4)}.cm-force-border{padding-right:.1px}@media print{.CodeMirror div.CodeMirror-cursors{visibility:hidden}}.cm-tab-wrap-hack:after{content:''}span.CodeMirror-selectedtext{background:0 0}
/*# sourceMappingURL=codemirror.min.css.map */

      .severity-low {
  background-color: #669603;
}

.severity-low:after {
  content : 'L';
}

.severity-unspecified {
  background-color: #666666;
}

.severity-unspecified:after {
  content : 'U';
}

.severity-style {
  background-color: #9932cc;
}

.severity-style:after {
  content : 'S';
}

.severity-medium {
  background-color: #a9d323;
  color: black;
}

.severity-medium:after {
  content : 'M';
}

.severity-high {
  background-color: #ffa800;
}

.severity-high:after {
  content : 'H';
}

.severity-critical {
  background-color: #e92625;
}

.severity-critical:after {
  content : 'C';
}

i[class*="severity-"] {
  line-height: normal;
  text-transform: capitalize;
  font-size: 0.8em;
  font-weight: bold;
  color: white;
  display: inline-block;
  width: 16px;
  height: 16px;
  text-align: center;
  font-family: sans-serif;
}

      html, body {
  width: 100%;
  height: 100%;
  padding: 0px;
  margin: 0px;
}

div.container {
  padding: 10px;
}

#content {
  height: 100%;
  display: block;
  overflow: hidden;
}

#content > div {
  margin: 10px;
  overflow: hidden;
  border: 1px solid #ddd;
  border-radius: 3px;
  overflow: hidden;
  height: 97%;
}

.button {
  background-color: #f1f1f1;
  text-decoration: none;
  display: inline-block;
  padding: 8px 16px;
  color: black;
  cursor: pointer;
}

.button:hover {
  background-color: #ddd;
  color: black;
}

.review-status {
  color: white;
  text-align: center;
}

.review-status-confirmed {
  background-color: #e92625;
}

.review-status-false-positive {
  background-color: grey;
}

.review-status-intentional {
  background-color: #669603;
}

      div.container {
  width: 100%;
  height: 100%;
  padding: 0px;
}

#editor-wrapper {
  margin: 10px;
}

#side-bar {
  float: left;
  width: 260px;
  margin: 0px;
}

#report-nav ul {
  list-style-type: none;
  padding: 0;
  margin: 0;
  overflow-y: auto;
  height: 100%;
}

#report-nav ul > li {
  padding: .4em;
  background-color: #fff;
  border-bottom: 1px solid rgba(0,0,0,.125);
  text-align: left;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

#report-nav ul > li.active {
  background-color: #427ea9;
  color: white;
}

#report-nav ul > li:hover {
  background-color: #427ea9;
  color: white;
  cursor: pointer;
}

#report-nav ul a {
  text-decoration: none;
}

#report-nav i[class*="severity-"] {
  margin-right: 5px;
}

.header {
  border-bottom: 1px solid lightgrey;
  font-family: monospace;
  padding: 10px;
  background-color: #fafbfc;
  border-bottom: 1px solid #e1e4e8;
  border-top-left-radius: 2px;
  border-top-right-radius: 2px;
}

#report-nav .header {
  font-weight: bold;
}

#editor-wrapper .header > div {
  padding-top: 2px;
}

#file-path,
#checker-name {
  color: #195ea2;
}

#review-status {
  padding: 0px 5px;
}

#file-path {
  font-family: monospace;
}

.check-msg {
  display: inline-block;
  padding: 3px 6px;
  margin: 1px;
  -webkit-border-radius: 5px;
  -moz-border-radius: 5px;
  border-radius: 5px;
}

.check-msg.info {
  color: #00546f;
  background-color: #bfdfe9;
  border: 1px solid #87a8b3;
}

.check-msg.error {
  background-color: #f2dede;
  color: #a94442;
  border: 1px solid #ebcccc;
}

.check-msg.macro {
  background-color: #d7dac2;
  color: #4f5c6d;
  border: 1px solid #d7dac2;
}

.check-msg.note {
  background-color: #d7d7d7;
  color: #4f5c6d;
  border: 1px solid #bfbfbf;
}

.check-msg.current {
  border: 2px dashed #3692ff;
}

.check-msg .tag {
  padding: 1px 5px;
  text-align: center;
  border-radius: 2px;
  margin-right: 5px;
  text-decoration: inherit;
}

.check-msg .tag.macro {
  background-color: #83876a;
  color: white;
  text-transform: capitalize;
}

.check-msg .tag.note {
  background-color: #9299a1;
  color: white;
  text-transform: capitalize;
}

.checker-enum {
  color: white;
  padding: 1px 5px;
  text-align: center;
  border-radius: 25px;
  margin-right: 5px;
  text-decoration: inherit;
}

.checker-enum.info {
  background-color: #427ea9;
}

.checker-enum.error {
  background-color: #a94442;
}

.arrow {
  border: solid black;
  border-width: 0 3px 3px 0;
  display: inline-block;
  padding: 3px;
  cursor: pointer;
  margin: 0px 5px;
}

.arrow:hover {
  border: solid #437ea8;
  border-width: 0 3px 3px 0;
}

.left-arrow {
  transform: rotate(135deg);
  -webkit-transform: rotate(135deg);
}

.right-arrow {
  transform: rotate(-45deg);
  -webkit-transform: rotate(-45deg);
}

    </style>

    <script type="text/javascript">
      function setNonCompatibleBrowserMessage() {
  document.body.innerHTML =
    '<h2 style="margin-left: 20px;">Your browser is not compatible with CodeChecker Viewer!</h2> \
     <p style="margin-left: 20px;">The version required for the following browsers are:</p> \
     <ul style="margin-left: 20px;"> \
     <li>Internet Explorer: version 9 or newer</li> \
     <li>Firefox: version 22.0 or newer</li> \
     </ul>';
}

// http://stackoverflow.com/questions/5916900/how-can-you-detect-the-version-of-a-browser
var browserVersion = (function(){
  var ua = navigator.userAgent, tem,
    M = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];

  if (/trident/i.test(M[1])) {
    tem = /\brv[ :]+(\d+)/g.exec(ua) || [];
    return 'IE ' + (tem[1] || '');
  }

  if (M[1] === 'Chrome') {
    tem = ua.match(/\b(OPR|Edge)\/(\d+)/);
    if (tem != null) return tem.slice(1).join(' ').replace('OPR', 'Opera');
  }

  M = M[2] ? [M[1], M[2]] : [navigator.appName, navigator.appVersion, '-?'];
  if ((tem = ua.match(/version\/(\d+)/i)) != null) M.splice(1, 1, tem[1]);
    return M.join(' ');
})();

var pos = browserVersion.indexOf(' ');
var browser = browserVersion.substr(0, pos);
var version = parseInt(browserVersion.substr(pos + 1));

var browserCompatible
  = browser === 'Firefox'
  ? version >= 22
  : browser === 'IE'
  ? version >= 9
  : true;


      /* MIT License

Copyright (C) 2017 by Marijn Haverbeke <marijnh@gmail.com> and others

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
 */
      !function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):e.CodeMirror=t()}(this,function(){"use strict";function e(e){return new RegExp("(^|\\s)"+e+"(?:$|\\s)\\s*")}function t(e){for(var t=e.childNodes.length;t>0;--t)e.removeChild(e.firstChild);return e}function r(e,r){return t(e).appendChild(r)}function n(e,t,r,n){var i=document.createElement(e);if(r&&(i.className=r),n&&(i.style.cssText=n),"string"==typeof t)i.appendChild(document.createTextNode(t));else if(t)for(var o=0;o<t.length;++o)i.appendChild(t[o]);return i}function i(e,t,r,i){var o=n(e,t,r,i);return o.setAttribute("role","presentation"),o}function o(e,t){if(3==t.nodeType&&(t=t.parentNode),e.contains)return e.contains(t);do{if(11==t.nodeType&&(t=t.host),t==e)return!0}while(t=t.parentNode)}function l(){var e;try{e=document.activeElement}catch(t){e=document.body||null}for(;e&&e.shadowRoot&&e.shadowRoot.activeElement;)e=e.shadowRoot.activeElement;return e}function s(t,r){var n=t.className;e(r).test(n)||(t.className+=(n?" ":"")+r)}function a(t,r){for(var n=t.split(" "),i=0;i<n.length;i++)n[i]&&!e(n[i]).test(r)&&(r+=" "+n[i]);return r}function u(e){var t=Array.prototype.slice.call(arguments,1);return function(){return e.apply(null,t)}}function c(e,t,r){t||(t={});for(var n in e)!e.hasOwnProperty(n)||!1===r&&t.hasOwnProperty(n)||(t[n]=e[n]);return t}function f(e,t,r,n,i){null==t&&-1==(t=e.search(/[^\s\u00a0]/))&&(t=e.length);for(var o=n||0,l=i||0;;){var s=e.indexOf("\t",o);if(s<0||s>=t)return l+(t-o);l+=s-o,l+=r-l%r,o=s+1}}function h(e,t){for(var r=0;r<e.length;++r)if(e[r]==t)return r;return-1}function d(e,t,r){for(var n=0,i=0;;){var o=e.indexOf("\t",n);-1==o&&(o=e.length);var l=o-n;if(o==e.length||i+l>=t)return n+Math.min(l,t-i);if(i+=o-n,i+=r-i%r,n=o+1,i>=t)return n}}function p(e){for(;Kl.length<=e;)Kl.push(g(Kl)+" ");return Kl[e]}function g(e){return e[e.length-1]}function v(e,t){for(var r=[],n=0;n<e.length;n++)r[n]=t(e[n],n);return r}function m(e,t,r){for(var n=0,i=r(t);n<e.length&&r(e[n])<=i;)n++;e.splice(n,0,t)}function y(){}function b(e,t){var r;return Object.create?r=Object.create(e):(y.prototype=e,r=new y),t&&c(t,r),r}function w(e){return/\w/.test(e)||e>""&&(e.toUpperCase()!=e.toLowerCase()||jl.test(e))}function x(e,t){return t?!!(t.source.indexOf("\\w")>-1&&w(e))||t.test(e):w(e)}function C(e){for(var t in e)if(e.hasOwnProperty(t)&&e[t])return!1;return!0}function S(e){return e.charCodeAt(0)>=768&&Xl.test(e)}function L(e,t,r){for(;(r<0?t>0:t<e.length)&&S(e.charAt(t));)t+=r;return t}function k(e,t,r){for(var n=t>r?-1:1;;){if(t==r)return t;var i=(t+r)/2,o=n<0?Math.ceil(i):Math.floor(i);if(o==t)return e(o)?t:r;e(o)?r=o:t=o+n}}function T(e,t,r){var o=this;this.input=r,o.scrollbarFiller=n("div",null,"CodeMirror-scrollbar-filler"),o.scrollbarFiller.setAttribute("cm-not-content","true"),o.gutterFiller=n("div",null,"CodeMirror-gutter-filler"),o.gutterFiller.setAttribute("cm-not-content","true"),o.lineDiv=i("div",null,"CodeMirror-code"),o.selectionDiv=n("div",null,null,"position: relative; z-index: 1"),o.cursorDiv=n("div",null,"CodeMirror-cursors"),o.measure=n("div",null,"CodeMirror-measure"),o.lineMeasure=n("div",null,"CodeMirror-measure"),o.lineSpace=i("div",[o.measure,o.lineMeasure,o.selectionDiv,o.cursorDiv,o.lineDiv],null,"position: relative; outline: none");var l=i("div",[o.lineSpace],"CodeMirror-lines");o.mover=n("div",[l],null,"position: relative"),o.sizer=n("div",[o.mover],"CodeMirror-sizer"),o.sizerWidth=null,o.heightForcer=n("div",null,null,"position: absolute; height: "+Rl+"px; width: 1px;"),o.gutters=n("div",null,"CodeMirror-gutters"),o.lineGutter=null,o.scroller=n("div",[o.sizer,o.heightForcer,o.gutters],"CodeMirror-scroll"),o.scroller.setAttribute("tabIndex","-1"),o.wrapper=n("div",[o.scrollbarFiller,o.gutterFiller,o.scroller],"CodeMirror"),gl&&vl<8&&(o.gutters.style.zIndex=-1,o.scroller.style.paddingRight=0),ml||fl&&Tl||(o.scroller.draggable=!0),e&&(e.appendChild?e.appendChild(o.wrapper):e(o.wrapper)),o.viewFrom=o.viewTo=t.first,o.reportedViewFrom=o.reportedViewTo=t.first,o.view=[],o.renderedView=null,o.externalMeasured=null,o.viewOffset=0,o.lastWrapHeight=o.lastWrapWidth=0,o.updateLineNumbers=null,o.nativeBarWidth=o.barHeight=o.barWidth=0,o.scrollbarsClipped=!1,o.lineNumWidth=o.lineNumInnerWidth=o.lineNumChars=null,o.alignWidgets=!1,o.cachedCharWidth=o.cachedTextHeight=o.cachedPaddingH=null,o.maxLine=null,o.maxLineLength=0,o.maxLineChanged=!1,o.wheelDX=o.wheelDY=o.wheelStartX=o.wheelStartY=null,o.shift=!1,o.selForContextMenu=null,o.activeTouch=null,r.init(o)}function M(e,t){if((t-=e.first)<0||t>=e.size)throw new Error("There is no line "+(t+e.first)+" in the document.");for(var r=e;!r.lines;)for(var n=0;;++n){var i=r.children[n],o=i.chunkSize();if(t<o){r=i;break}t-=o}return r.lines[t]}function N(e,t,r){var n=[],i=t.line;return e.iter(t.line,r.line+1,function(e){var o=e.text;i==r.line&&(o=o.slice(0,r.ch)),i==t.line&&(o=o.slice(t.ch)),n.push(o),++i}),n}function O(e,t,r){var n=[];return e.iter(t,r,function(e){n.push(e.text)}),n}function A(e,t){var r=t-e.height;if(r)for(var n=e;n;n=n.parent)n.height+=r}function W(e){if(null==e.parent)return null;for(var t=e.parent,r=h(t.lines,e),n=t.parent;n;t=n,n=n.parent)for(var i=0;n.children[i]!=t;++i)r+=n.children[i].chunkSize();return r+t.first}function D(e,t){var r=e.first;e:do{for(var n=0;n<e.children.length;++n){var i=e.children[n],o=i.height;if(t<o){e=i;continue e}t-=o,r+=i.chunkSize()}return r}while(!e.lines);for(var l=0;l<e.lines.length;++l){var s=e.lines[l].height;if(t<s)break;t-=s}return r+l}function H(e,t){return t>=e.first&&t<e.first+e.size}function F(e,t){return String(e.lineNumberFormatter(t+e.firstLineNumber))}function E(e,t,r){if(void 0===r&&(r=null),!(this instanceof E))return new E(e,t,r);this.line=e,this.ch=t,this.sticky=r}function P(e,t){return e.line-t.line||e.ch-t.ch}function I(e,t){return e.sticky==t.sticky&&0==P(e,t)}function z(e){return E(e.line,e.ch)}function R(e,t){return P(e,t)<0?t:e}function B(e,t){return P(e,t)<0?e:t}function G(e,t){return Math.max(e.first,Math.min(t,e.first+e.size-1))}function U(e,t){if(t.line<e.first)return E(e.first,0);var r=e.first+e.size-1;return t.line>r?E(r,M(e,r).text.length):V(t,M(e,t.line).text.length)}function V(e,t){var r=e.ch;return null==r||r>t?E(e.line,t):r<0?E(e.line,0):e}function K(e,t){for(var r=[],n=0;n<t.length;n++)r[n]=U(e,t[n]);return r}function j(){Yl=!0}function X(){_l=!0}function Y(e,t,r){this.marker=e,this.from=t,this.to=r}function _(e,t){if(e)for(var r=0;r<e.length;++r){var n=e[r];if(n.marker==t)return n}}function $(e,t){for(var r,n=0;n<e.length;++n)e[n]!=t&&(r||(r=[])).push(e[n]);return r}function q(e,t){e.markedSpans=e.markedSpans?e.markedSpans.concat([t]):[t],t.marker.attachLine(e)}function Z(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t)||o.from==t&&"bookmark"==l.type&&(!r||!o.marker.insertLeft)){var s=null==o.to||(l.inclusiveRight?o.to>=t:o.to>t);(n||(n=[])).push(new Y(l,o.from,s?null:o.to))}}return n}function Q(e,t,r){var n;if(e)for(var i=0;i<e.length;++i){var o=e[i],l=o.marker;if(null==o.to||(l.inclusiveRight?o.to>=t:o.to>t)||o.from==t&&"bookmark"==l.type&&(!r||o.marker.insertLeft)){var s=null==o.from||(l.inclusiveLeft?o.from<=t:o.from<t);(n||(n=[])).push(new Y(l,s?null:o.from-t,null==o.to?null:o.to-t))}}return n}function J(e,t){if(t.full)return null;var r=H(e,t.from.line)&&M(e,t.from.line).markedSpans,n=H(e,t.to.line)&&M(e,t.to.line).markedSpans;if(!r&&!n)return null;var i=t.from.ch,o=t.to.ch,l=0==P(t.from,t.to),s=Z(r,i,l),a=Q(n,o,l),u=1==t.text.length,c=g(t.text).length+(u?i:0);if(s)for(var f=0;f<s.length;++f){var h=s[f];if(null==h.to){var d=_(a,h.marker);d?u&&(h.to=null==d.to?null:d.to+c):h.to=i}}if(a)for(var p=0;p<a.length;++p){var v=a[p];null!=v.to&&(v.to+=c),null==v.from?_(s,v.marker)||(v.from=c,u&&(s||(s=[])).push(v)):(v.from+=c,u&&(s||(s=[])).push(v))}s&&(s=ee(s)),a&&a!=s&&(a=ee(a));var m=[s];if(!u){var y,b=t.text.length-2;if(b>0&&s)for(var w=0;w<s.length;++w)null==s[w].to&&(y||(y=[])).push(new Y(s[w].marker,null,null));for(var x=0;x<b;++x)m.push(y);m.push(a)}return m}function ee(e){for(var t=0;t<e.length;++t){var r=e[t];null!=r.from&&r.from==r.to&&!1!==r.marker.clearWhenEmpty&&e.splice(t--,1)}return e.length?e:null}function te(e,t,r){var n=null;if(e.iter(t.line,r.line+1,function(e){if(e.markedSpans)for(var t=0;t<e.markedSpans.length;++t){var r=e.markedSpans[t].marker;!r.readOnly||n&&-1!=h(n,r)||(n||(n=[])).push(r)}}),!n)return null;for(var i=[{from:t,to:r}],o=0;o<n.length;++o)for(var l=n[o],s=l.find(0),a=0;a<i.length;++a){var u=i[a];if(!(P(u.to,s.from)<0||P(u.from,s.to)>0)){var c=[a,1],f=P(u.from,s.from),d=P(u.to,s.to);(f<0||!l.inclusiveLeft&&!f)&&c.push({from:u.from,to:s.from}),(d>0||!l.inclusiveRight&&!d)&&c.push({from:s.to,to:u.to}),i.splice.apply(i,c),a+=c.length-3}}return i}function re(e){var t=e.markedSpans;if(t){for(var r=0;r<t.length;++r)t[r].marker.detachLine(e);e.markedSpans=null}}function ne(e,t){if(t){for(var r=0;r<t.length;++r)t[r].marker.attachLine(e);e.markedSpans=t}}function ie(e){return e.inclusiveLeft?-1:0}function oe(e){return e.inclusiveRight?1:0}function le(e,t){var r=e.lines.length-t.lines.length;if(0!=r)return r;var n=e.find(),i=t.find(),o=P(n.from,i.from)||ie(e)-ie(t);if(o)return-o;var l=P(n.to,i.to)||oe(e)-oe(t);return l||t.id-e.id}function se(e,t){var r,n=_l&&e.markedSpans;if(n)for(var i=void 0,o=0;o<n.length;++o)(i=n[o]).marker.collapsed&&null==(t?i.from:i.to)&&(!r||le(r,i.marker)<0)&&(r=i.marker);return r}function ae(e){return se(e,!0)}function ue(e){return se(e,!1)}function ce(e,t,r,n,i){var o=M(e,t),l=_l&&o.markedSpans;if(l)for(var s=0;s<l.length;++s){var a=l[s];if(a.marker.collapsed){var u=a.marker.find(0),c=P(u.from,r)||ie(a.marker)-ie(i),f=P(u.to,n)||oe(a.marker)-oe(i);if(!(c>=0&&f<=0||c<=0&&f>=0)&&(c<=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.to,r)>=0:P(u.to,r)>0)||c>=0&&(a.marker.inclusiveRight&&i.inclusiveLeft?P(u.from,n)<=0:P(u.from,n)<0)))return!0}}}function fe(e){for(var t;t=ae(e);)e=t.find(-1,!0).line;return e}function he(e){for(var t;t=ue(e);)e=t.find(1,!0).line;return e}function de(e){for(var t,r;t=ue(e);)e=t.find(1,!0).line,(r||(r=[])).push(e);return r}function pe(e,t){var r=M(e,t),n=fe(r);return r==n?t:W(n)}function ge(e,t){if(t>e.lastLine())return t;var r,n=M(e,t);if(!ve(e,n))return t;for(;r=ue(n);)n=r.find(1,!0).line;return W(n)+1}function ve(e,t){var r=_l&&t.markedSpans;if(r)for(var n=void 0,i=0;i<r.length;++i)if((n=r[i]).marker.collapsed){if(null==n.from)return!0;if(!n.marker.widgetNode&&0==n.from&&n.marker.inclusiveLeft&&me(e,t,n))return!0}}function me(e,t,r){if(null==r.to){var n=r.marker.find(1,!0);return me(e,n.line,_(n.line.markedSpans,r.marker))}if(r.marker.inclusiveRight&&r.to==t.text.length)return!0;for(var i=void 0,o=0;o<t.markedSpans.length;++o)if((i=t.markedSpans[o]).marker.collapsed&&!i.marker.widgetNode&&i.from==r.to&&(null==i.to||i.to!=r.from)&&(i.marker.inclusiveLeft||r.marker.inclusiveRight)&&me(e,t,i))return!0}function ye(e){for(var t=0,r=(e=fe(e)).parent,n=0;n<r.lines.length;++n){var i=r.lines[n];if(i==e)break;t+=i.height}for(var o=r.parent;o;r=o,o=r.parent)for(var l=0;l<o.children.length;++l){var s=o.children[l];if(s==r)break;t+=s.height}return t}function be(e){if(0==e.height)return 0;for(var t,r=e.text.length,n=e;t=ae(n);){var i=t.find(0,!0);n=i.from.line,r+=i.from.ch-i.to.ch}for(n=e;t=ue(n);){var o=t.find(0,!0);r-=n.text.length-o.from.ch,r+=(n=o.to.line).text.length-o.to.ch}return r}function we(e){var t=e.display,r=e.doc;t.maxLine=M(r,r.first),t.maxLineLength=be(t.maxLine),t.maxLineChanged=!0,r.iter(function(e){var r=be(e);r>t.maxLineLength&&(t.maxLineLength=r,t.maxLine=e)})}function xe(e,t,r,n){if(!e)return n(t,r,"ltr",0);for(var i=!1,o=0;o<e.length;++o){var l=e[o];(l.from<r&&l.to>t||t==r&&l.to==t)&&(n(Math.max(l.from,t),Math.min(l.to,r),1==l.level?"rtl":"ltr",o),i=!0)}i||n(t,r,"ltr")}function Ce(e,t,r){var n;$l=null;for(var i=0;i<e.length;++i){var o=e[i];if(o.from<t&&o.to>t)return i;o.to==t&&(o.from!=o.to&&"before"==r?n=i:$l=i),o.from==t&&(o.from!=o.to&&"before"!=r?n=i:$l=i)}return null!=n?n:$l}function Se(e,t){var r=e.order;return null==r&&(r=e.order=ql(e.text,t)),r}function Le(e,t){return e._handlers&&e._handlers[t]||Zl}function ke(e,t,r){if(e.removeEventListener)e.removeEventListener(t,r,!1);else if(e.detachEvent)e.detachEvent("on"+t,r);else{var n=e._handlers,i=n&&n[t];if(i){var o=h(i,r);o>-1&&(n[t]=i.slice(0,o).concat(i.slice(o+1)))}}}function Te(e,t){var r=Le(e,t);if(r.length)for(var n=Array.prototype.slice.call(arguments,2),i=0;i<r.length;++i)r[i].apply(null,n)}function Me(e,t,r){return"string"==typeof t&&(t={type:t,preventDefault:function(){this.defaultPrevented=!0}}),Te(e,r||t.type,e,t),He(t)||t.codemirrorIgnore}function Ne(e){var t=e._handlers&&e._handlers.cursorActivity;if(t)for(var r=e.curOp.cursorActivityHandlers||(e.curOp.cursorActivityHandlers=[]),n=0;n<t.length;++n)-1==h(r,t[n])&&r.push(t[n])}function Oe(e,t){return Le(e,t).length>0}function Ae(e){e.prototype.on=function(e,t){Ql(this,e,t)},e.prototype.off=function(e,t){ke(this,e,t)}}function We(e){e.preventDefault?e.preventDefault():e.returnValue=!1}function De(e){e.stopPropagation?e.stopPropagation():e.cancelBubble=!0}function He(e){return null!=e.defaultPrevented?e.defaultPrevented:0==e.returnValue}function Fe(e){We(e),De(e)}function Ee(e){return e.target||e.srcElement}function Pe(e){var t=e.which;return null==t&&(1&e.button?t=1:2&e.button?t=3:4&e.button&&(t=2)),Ml&&e.ctrlKey&&1==t&&(t=3),t}function Ie(e){if(null==Il){var t=n("span","​");r(e,n("span",[t,document.createTextNode("x")])),0!=e.firstChild.offsetHeight&&(Il=t.offsetWidth<=1&&t.offsetHeight>2&&!(gl&&vl<8))}var i=Il?n("span","​"):n("span"," ",null,"display: inline-block; width: 1px; margin-right: -1px");return i.setAttribute("cm-text",""),i}function ze(e){if(null!=zl)return zl;var n=r(e,document.createTextNode("AخA")),i=Wl(n,0,1).getBoundingClientRect(),o=Wl(n,1,2).getBoundingClientRect();return t(e),!(!i||i.left==i.right)&&(zl=o.right-i.right<3)}function Re(e){if(null!=ns)return ns;var t=r(e,n("span","x")),i=t.getBoundingClientRect(),o=Wl(t,0,1).getBoundingClientRect();return ns=Math.abs(i.left-o.left)>1}function Be(e,t){arguments.length>2&&(t.dependencies=Array.prototype.slice.call(arguments,2)),is[e]=t}function Ge(e){if("string"==typeof e&&os.hasOwnProperty(e))e=os[e];else if(e&&"string"==typeof e.name&&os.hasOwnProperty(e.name)){var t=os[e.name];"string"==typeof t&&(t={name:t}),(e=b(t,e)).name=t.name}else{if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+xml$/.test(e))return Ge("application/xml");if("string"==typeof e&&/^[\w\-]+\/[\w\-]+\+json$/.test(e))return Ge("application/json")}return"string"==typeof e?{name:e}:e||{name:"null"}}function Ue(e,t){t=Ge(t);var r=is[t.name];if(!r)return Ue(e,"text/plain");var n=r(e,t);if(ls.hasOwnProperty(t.name)){var i=ls[t.name];for(var o in i)i.hasOwnProperty(o)&&(n.hasOwnProperty(o)&&(n["_"+o]=n[o]),n[o]=i[o])}if(n.name=t.name,t.helperType&&(n.helperType=t.helperType),t.modeProps)for(var l in t.modeProps)n[l]=t.modeProps[l];return n}function Ve(e,t){c(t,ls.hasOwnProperty(e)?ls[e]:ls[e]={})}function Ke(e,t){if(!0===t)return t;if(e.copyState)return e.copyState(t);var r={};for(var n in t){var i=t[n];i instanceof Array&&(i=i.concat([])),r[n]=i}return r}function je(e,t){for(var r;e.innerMode&&(r=e.innerMode(t))&&r.mode!=e;)t=r.state,e=r.mode;return r||{mode:e,state:t}}function Xe(e,t,r){return!e.startState||e.startState(t,r)}function Ye(e,t,r,n){var i=[e.state.modeGen],o={};tt(e,t.text,e.doc.mode,r,function(e,t){return i.push(e,t)},o,n);for(var l=r.state,s=0;s<e.state.overlays.length;++s)!function(n){var l=e.state.overlays[n],s=1,a=0;r.state=!0,tt(e,t.text,l.mode,r,function(e,t){for(var r=s;a<e;){var n=i[s];n>e&&i.splice(s,1,e,i[s+1],n),s+=2,a=Math.min(e,n)}if(t)if(l.opaque)i.splice(r,s-r,e,"overlay "+t),s=r+2;else for(;r<s;r+=2){var o=i[r+1];i[r+1]=(o?o+" ":"")+"overlay "+t}},o)}(s);return r.state=l,{styles:i,classes:o.bgClass||o.textClass?o:null}}function _e(e,t,r){if(!t.styles||t.styles[0]!=e.state.modeGen){var n=$e(e,W(t)),i=t.text.length>e.options.maxHighlightLength&&Ke(e.doc.mode,n.state),o=Ye(e,t,n);i&&(n.state=i),t.stateAfter=n.save(!i),t.styles=o.styles,o.classes?t.styleClasses=o.classes:t.styleClasses&&(t.styleClasses=null),r===e.doc.highlightFrontier&&(e.doc.modeFrontier=Math.max(e.doc.modeFrontier,++e.doc.highlightFrontier))}return t.styles}function $e(e,t,r){var n=e.doc,i=e.display;if(!n.mode.startState)return new us(n,!0,t);var o=rt(e,t,r),l=o>n.first&&M(n,o-1).stateAfter,s=l?us.fromSaved(n,l,o):new us(n,Xe(n.mode),o);return n.iter(o,t,function(r){qe(e,r.text,s);var n=s.line;r.stateAfter=n==t-1||n%5==0||n>=i.viewFrom&&n<i.viewTo?s.save():null,s.nextLine()}),r&&(n.modeFrontier=s.line),s}function qe(e,t,r,n){var i=e.doc.mode,o=new ss(t,e.options.tabSize,r);for(o.start=o.pos=n||0,""==t&&Ze(i,r.state);!o.eol();)Qe(i,o,r.state),o.start=o.pos}function Ze(e,t){if(e.blankLine)return e.blankLine(t);if(e.innerMode){var r=je(e,t);return r.mode.blankLine?r.mode.blankLine(r.state):void 0}}function Qe(e,t,r,n){for(var i=0;i<10;i++){n&&(n[0]=je(e,r).mode);var o=e.token(t,r);if(t.pos>t.start)return o}throw new Error("Mode "+e.name+" failed to advance stream.")}function Je(e,t,r,n){var i,o,l=e.doc,s=l.mode,a=M(l,(t=U(l,t)).line),u=$e(e,t.line,r),c=new ss(a.text,e.options.tabSize,u);for(n&&(o=[]);(n||c.pos<t.ch)&&!c.eol();)c.start=c.pos,i=Qe(s,c,u.state),n&&o.push(new cs(c,i,Ke(l.mode,u.state)));return n?o:new cs(c,i,u.state)}function et(e,t){if(e)for(;;){var r=e.match(/(?:^|\s+)line-(background-)?(\S+)/);if(!r)break;e=e.slice(0,r.index)+e.slice(r.index+r[0].length);var n=r[1]?"bgClass":"textClass";null==t[n]?t[n]=r[2]:new RegExp("(?:^|s)"+r[2]+"(?:$|s)").test(t[n])||(t[n]+=" "+r[2])}return e}function tt(e,t,r,n,i,o,l){var s=r.flattenSpans;null==s&&(s=e.options.flattenSpans);var a,u=0,c=null,f=new ss(t,e.options.tabSize,n),h=e.options.addModeClass&&[null];for(""==t&&et(Ze(r,n.state),o);!f.eol();){if(f.pos>e.options.maxHighlightLength?(s=!1,l&&qe(e,t,n,f.pos),f.pos=t.length,a=null):a=et(Qe(r,f,n.state,h),o),h){var d=h[0].name;d&&(a="m-"+(a?d+" "+a:d))}if(!s||c!=a){for(;u<f.start;)i(u=Math.min(f.start,u+5e3),c);c=a}f.start=f.pos}for(;u<f.pos;){var p=Math.min(f.pos,u+5e3);i(p,c),u=p}}function rt(e,t,r){for(var n,i,o=e.doc,l=r?-1:t-(e.doc.mode.innerMode?1e3:100),s=t;s>l;--s){if(s<=o.first)return o.first;var a=M(o,s-1),u=a.stateAfter;if(u&&(!r||s+(u instanceof as?u.lookAhead:0)<=o.modeFrontier))return s;var c=f(a.text,null,e.options.tabSize);(null==i||n>c)&&(i=s-1,n=c)}return i}function nt(e,t){if(e.modeFrontier=Math.min(e.modeFrontier,t),!(e.highlightFrontier<t-10)){for(var r=e.first,n=t-1;n>r;n--){var i=M(e,n).stateAfter;if(i&&(!(i instanceof as)||n+i.lookAhead<t)){r=n+1;break}}e.highlightFrontier=Math.min(e.highlightFrontier,r)}}function it(e,t,r,n){e.text=t,e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null),null!=e.order&&(e.order=null),re(e),ne(e,r);var i=n?n(e):1;i!=e.height&&A(e,i)}function ot(e){e.parent=null,re(e)}function lt(e,t){if(!e||/^\s*$/.test(e))return null;var r=t.addModeClass?ps:ds;return r[e]||(r[e]=e.replace(/\S+/g,"cm-$&"))}function st(e,t){var r=i("span",null,null,ml?"padding-right: .1px":null),n={pre:i("pre",[r],"CodeMirror-line"),content:r,col:0,pos:0,cm:e,trailingSpace:!1,splitSpaces:(gl||ml)&&e.getOption("lineWrapping")};t.measure={};for(var o=0;o<=(t.rest?t.rest.length:0);o++){var l=o?t.rest[o-1]:t.line,s=void 0;n.pos=0,n.addToken=ut,ze(e.display.measure)&&(s=Se(l,e.doc.direction))&&(n.addToken=ft(n.addToken,s)),n.map=[],dt(l,n,_e(e,l,t!=e.display.externalMeasured&&W(l))),l.styleClasses&&(l.styleClasses.bgClass&&(n.bgClass=a(l.styleClasses.bgClass,n.bgClass||"")),l.styleClasses.textClass&&(n.textClass=a(l.styleClasses.textClass,n.textClass||""))),0==n.map.length&&n.map.push(0,0,n.content.appendChild(Ie(e.display.measure))),0==o?(t.measure.map=n.map,t.measure.cache={}):((t.measure.maps||(t.measure.maps=[])).push(n.map),(t.measure.caches||(t.measure.caches=[])).push({}))}if(ml){var u=n.content.lastChild;(/\bcm-tab\b/.test(u.className)||u.querySelector&&u.querySelector(".cm-tab"))&&(n.content.className="cm-tab-wrap-hack")}return Te(e,"renderLine",e,t.line,n.pre),n.pre.className&&(n.textClass=a(n.pre.className,n.textClass||"")),n}function at(e){var t=n("span","•","cm-invalidchar");return t.title="\\u"+e.charCodeAt(0).toString(16),t.setAttribute("aria-label",t.title),t}function ut(e,t,r,i,o,l,s){if(t){var a,u=e.splitSpaces?ct(t,e.trailingSpace):t,c=e.cm.state.specialChars,f=!1;if(c.test(t)){a=document.createDocumentFragment();for(var h=0;;){c.lastIndex=h;var d=c.exec(t),g=d?d.index-h:t.length-h;if(g){var v=document.createTextNode(u.slice(h,h+g));gl&&vl<9?a.appendChild(n("span",[v])):a.appendChild(v),e.map.push(e.pos,e.pos+g,v),e.col+=g,e.pos+=g}if(!d)break;h+=g+1;var m=void 0;if("\t"==d[0]){var y=e.cm.options.tabSize,b=y-e.col%y;(m=a.appendChild(n("span",p(b),"cm-tab"))).setAttribute("role","presentation"),m.setAttribute("cm-text","\t"),e.col+=b}else"\r"==d[0]||"\n"==d[0]?((m=a.appendChild(n("span","\r"==d[0]?"␍":"␤","cm-invalidchar"))).setAttribute("cm-text",d[0]),e.col+=1):((m=e.cm.options.specialCharPlaceholder(d[0])).setAttribute("cm-text",d[0]),gl&&vl<9?a.appendChild(n("span",[m])):a.appendChild(m),e.col+=1);e.map.push(e.pos,e.pos+1,m),e.pos++}}else e.col+=t.length,a=document.createTextNode(u),e.map.push(e.pos,e.pos+t.length,a),gl&&vl<9&&(f=!0),e.pos+=t.length;if(e.trailingSpace=32==u.charCodeAt(t.length-1),r||i||o||f||s){var w=r||"";i&&(w+=i),o&&(w+=o);var x=n("span",[a],w,s);return l&&(x.title=l),e.content.appendChild(x)}e.content.appendChild(a)}}function ct(e,t){if(e.length>1&&!/  /.test(e))return e;for(var r=t,n="",i=0;i<e.length;i++){var o=e.charAt(i);" "!=o||!r||i!=e.length-1&&32!=e.charCodeAt(i+1)||(o=" "),n+=o,r=" "==o}return n}function ft(e,t){return function(r,n,i,o,l,s,a){i=i?i+" cm-force-border":"cm-force-border";for(var u=r.pos,c=u+n.length;;){for(var f=void 0,h=0;h<t.length&&!((f=t[h]).to>u&&f.from<=u);h++);if(f.to>=c)return e(r,n,i,o,l,s,a);e(r,n.slice(0,f.to-u),i,o,null,s,a),o=null,n=n.slice(f.to-u),u=f.to}}}function ht(e,t,r,n){var i=!n&&r.widgetNode;i&&e.map.push(e.pos,e.pos+t,i),!n&&e.cm.display.input.needsContentAttribute&&(i||(i=e.content.appendChild(document.createElement("span"))),i.setAttribute("cm-marker",r.id)),i&&(e.cm.display.input.setUneditable(i),e.content.appendChild(i)),e.pos+=t,e.trailingSpace=!1}function dt(e,t,r){var n=e.markedSpans,i=e.text,o=0;if(n)for(var l,s,a,u,c,f,h,d=i.length,p=0,g=1,v="",m=0;;){if(m==p){a=u=c=f=s="",h=null,m=1/0;for(var y=[],b=void 0,w=0;w<n.length;++w){var x=n[w],C=x.marker;"bookmark"==C.type&&x.from==p&&C.widgetNode?y.push(C):x.from<=p&&(null==x.to||x.to>p||C.collapsed&&x.to==p&&x.from==p)?(null!=x.to&&x.to!=p&&m>x.to&&(m=x.to,u=""),C.className&&(a+=" "+C.className),C.css&&(s=(s?s+";":"")+C.css),C.startStyle&&x.from==p&&(c+=" "+C.startStyle),C.endStyle&&x.to==m&&(b||(b=[])).push(C.endStyle,x.to),C.title&&!f&&(f=C.title),C.collapsed&&(!h||le(h.marker,C)<0)&&(h=x)):x.from>p&&m>x.from&&(m=x.from)}if(b)for(var S=0;S<b.length;S+=2)b[S+1]==m&&(u+=" "+b[S]);if(!h||h.from==p)for(var L=0;L<y.length;++L)ht(t,0,y[L]);if(h&&(h.from||0)==p){if(ht(t,(null==h.to?d+1:h.to)-p,h.marker,null==h.from),null==h.to)return;h.to==p&&(h=!1)}}if(p>=d)break;for(var k=Math.min(d,m);;){if(v){var T=p+v.length;if(!h){var M=T>k?v.slice(0,k-p):v;t.addToken(t,M,l?l+a:a,c,p+M.length==m?u:"",f,s)}if(T>=k){v=v.slice(k-p),p=k;break}p=T,c=""}v=i.slice(o,o=r[g++]),l=lt(r[g++],t.cm.options)}}else for(var N=1;N<r.length;N+=2)t.addToken(t,i.slice(o,o=r[N]),lt(r[N+1],t.cm.options))}function pt(e,t,r){this.line=t,this.rest=de(t),this.size=this.rest?W(g(this.rest))-r+1:1,this.node=this.text=null,this.hidden=ve(e,t)}function gt(e,t,r){for(var n,i=[],o=t;o<r;o=n){var l=new pt(e.doc,M(e.doc,o),o);n=o+l.size,i.push(l)}return i}function vt(e){gs?gs.ops.push(e):e.ownsGroup=gs={ops:[e],delayedCallbacks:[]}}function mt(e){var t=e.delayedCallbacks,r=0;do{for(;r<t.length;r++)t[r].call(null);for(var n=0;n<e.ops.length;n++){var i=e.ops[n];if(i.cursorActivityHandlers)for(;i.cursorActivityCalled<i.cursorActivityHandlers.length;)i.cursorActivityHandlers[i.cursorActivityCalled++].call(null,i.cm)}}while(r<t.length)}function yt(e,t){var r=e.ownsGroup;if(r)try{mt(r)}finally{gs=null,t(r)}}function bt(e,t){var r=Le(e,t);if(r.length){var n,i=Array.prototype.slice.call(arguments,2);gs?n=gs.delayedCallbacks:vs?n=vs:(n=vs=[],setTimeout(wt,0));for(var o=0;o<r.length;++o)!function(e){n.push(function(){return r[e].apply(null,i)})}(o)}}function wt(){var e=vs;vs=null;for(var t=0;t<e.length;++t)e[t]()}function xt(e,t,r,n){for(var i=0;i<t.changes.length;i++){var o=t.changes[i];"text"==o?kt(e,t):"gutter"==o?Mt(e,t,r,n):"class"==o?Tt(e,t):"widget"==o&&Nt(e,t,n)}t.changes=null}function Ct(e){return e.node==e.text&&(e.node=n("div",null,null,"position: relative"),e.text.parentNode&&e.text.parentNode.replaceChild(e.node,e.text),e.node.appendChild(e.text),gl&&vl<8&&(e.node.style.zIndex=2)),e.node}function St(e,t){var r=t.bgClass?t.bgClass+" "+(t.line.bgClass||""):t.line.bgClass;if(r&&(r+=" CodeMirror-linebackground"),t.background)r?t.background.className=r:(t.background.parentNode.removeChild(t.background),t.background=null);else if(r){var i=Ct(t);t.background=i.insertBefore(n("div",null,r),i.firstChild),e.display.input.setUneditable(t.background)}}function Lt(e,t){var r=e.display.externalMeasured;return r&&r.line==t.line?(e.display.externalMeasured=null,t.measure=r.measure,r.built):st(e,t)}function kt(e,t){var r=t.text.className,n=Lt(e,t);t.text==t.node&&(t.node=n.pre),t.text.parentNode.replaceChild(n.pre,t.text),t.text=n.pre,n.bgClass!=t.bgClass||n.textClass!=t.textClass?(t.bgClass=n.bgClass,t.textClass=n.textClass,Tt(e,t)):r&&(t.text.className=r)}function Tt(e,t){St(e,t),t.line.wrapClass?Ct(t).className=t.line.wrapClass:t.node!=t.text&&(t.node.className="");var r=t.textClass?t.textClass+" "+(t.line.textClass||""):t.line.textClass;t.text.className=r||""}function Mt(e,t,r,i){if(t.gutter&&(t.node.removeChild(t.gutter),t.gutter=null),t.gutterBackground&&(t.node.removeChild(t.gutterBackground),t.gutterBackground=null),t.line.gutterClass){var o=Ct(t);t.gutterBackground=n("div",null,"CodeMirror-gutter-background "+t.line.gutterClass,"left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px; width: "+i.gutterTotalWidth+"px"),e.display.input.setUneditable(t.gutterBackground),o.insertBefore(t.gutterBackground,t.text)}var l=t.line.gutterMarkers;if(e.options.lineNumbers||l){var s=Ct(t),a=t.gutter=n("div",null,"CodeMirror-gutter-wrapper","left: "+(e.options.fixedGutter?i.fixedPos:-i.gutterTotalWidth)+"px");if(e.display.input.setUneditable(a),s.insertBefore(a,t.text),t.line.gutterClass&&(a.className+=" "+t.line.gutterClass),!e.options.lineNumbers||l&&l["CodeMirror-linenumbers"]||(t.lineNumber=a.appendChild(n("div",F(e.options,r),"CodeMirror-linenumber CodeMirror-gutter-elt","left: "+i.gutterLeft["CodeMirror-linenumbers"]+"px; width: "+e.display.lineNumInnerWidth+"px"))),l)for(var u=0;u<e.options.gutters.length;++u){var c=e.options.gutters[u],f=l.hasOwnProperty(c)&&l[c];f&&a.appendChild(n("div",[f],"CodeMirror-gutter-elt","left: "+i.gutterLeft[c]+"px; width: "+i.gutterWidth[c]+"px"))}}}function Nt(e,t,r){t.alignable&&(t.alignable=null);for(var n=t.node.firstChild,i=void 0;n;n=i)i=n.nextSibling,"CodeMirror-linewidget"==n.className&&t.node.removeChild(n);At(e,t,r)}function Ot(e,t,r,n){var i=Lt(e,t);return t.text=t.node=i.pre,i.bgClass&&(t.bgClass=i.bgClass),i.textClass&&(t.textClass=i.textClass),Tt(e,t),Mt(e,t,r,n),At(e,t,n),t.node}function At(e,t,r){if(Wt(e,t.line,t,r,!0),t.rest)for(var n=0;n<t.rest.length;n++)Wt(e,t.rest[n],t,r,!1)}function Wt(e,t,r,i,o){if(t.widgets)for(var l=Ct(r),s=0,a=t.widgets;s<a.length;++s){var u=a[s],c=n("div",[u.node],"CodeMirror-linewidget");u.handleMouseEvents||c.setAttribute("cm-ignore-events","true"),Dt(u,c,r,i),e.display.input.setUneditable(c),o&&u.above?l.insertBefore(c,r.gutter||r.text):l.appendChild(c),bt(u,"redraw")}}function Dt(e,t,r,n){if(e.noHScroll){(r.alignable||(r.alignable=[])).push(t);var i=n.wrapperWidth;t.style.left=n.fixedPos+"px",e.coverGutter||(i-=n.gutterTotalWidth,t.style.paddingLeft=n.gutterTotalWidth+"px"),t.style.width=i+"px"}e.coverGutter&&(t.style.zIndex=5,t.style.position="relative",e.noHScroll||(t.style.marginLeft=-n.gutterTotalWidth+"px"))}function Ht(e){if(null!=e.height)return e.height;var t=e.doc.cm;if(!t)return 0;if(!o(document.body,e.node)){var i="position: relative;";e.coverGutter&&(i+="margin-left: -"+t.display.gutters.offsetWidth+"px;"),e.noHScroll&&(i+="width: "+t.display.wrapper.clientWidth+"px;"),r(t.display.measure,n("div",[e.node],null,i))}return e.height=e.node.parentNode.offsetHeight}function Ft(e,t){for(var r=Ee(t);r!=e.wrapper;r=r.parentNode)if(!r||1==r.nodeType&&"true"==r.getAttribute("cm-ignore-events")||r.parentNode==e.sizer&&r!=e.mover)return!0}function Et(e){return e.lineSpace.offsetTop}function Pt(e){return e.mover.offsetHeight-e.lineSpace.offsetHeight}function It(e){if(e.cachedPaddingH)return e.cachedPaddingH;var t=r(e.measure,n("pre","x")),i=window.getComputedStyle?window.getComputedStyle(t):t.currentStyle,o={left:parseInt(i.paddingLeft),right:parseInt(i.paddingRight)};return isNaN(o.left)||isNaN(o.right)||(e.cachedPaddingH=o),o}function zt(e){return Rl-e.display.nativeBarWidth}function Rt(e){return e.display.scroller.clientWidth-zt(e)-e.display.barWidth}function Bt(e){return e.display.scroller.clientHeight-zt(e)-e.display.barHeight}function Gt(e,t,r){var n=e.options.lineWrapping,i=n&&Rt(e);if(!t.measure.heights||n&&t.measure.width!=i){var o=t.measure.heights=[];if(n){t.measure.width=i;for(var l=t.text.firstChild.getClientRects(),s=0;s<l.length-1;s++){var a=l[s],u=l[s+1];Math.abs(a.bottom-u.bottom)>2&&o.push((a.bottom+u.top)/2-r.top)}}o.push(r.bottom-r.top)}}function Ut(e,t,r){if(e.line==t)return{map:e.measure.map,cache:e.measure.cache};for(var n=0;n<e.rest.length;n++)if(e.rest[n]==t)return{map:e.measure.maps[n],cache:e.measure.caches[n]};for(var i=0;i<e.rest.length;i++)if(W(e.rest[i])>r)return{map:e.measure.maps[i],cache:e.measure.caches[i],before:!0}}function Vt(e,t){var n=W(t=fe(t)),i=e.display.externalMeasured=new pt(e.doc,t,n);i.lineN=n;var o=i.built=st(e,i);return i.text=o.pre,r(e.display.lineMeasure,o.pre),i}function Kt(e,t,r,n){return Yt(e,Xt(e,t),r,n)}function jt(e,t){if(t>=e.display.viewFrom&&t<e.display.viewTo)return e.display.view[Lr(e,t)];var r=e.display.externalMeasured;return r&&t>=r.lineN&&t<r.lineN+r.size?r:void 0}function Xt(e,t){var r=W(t),n=jt(e,r);n&&!n.text?n=null:n&&n.changes&&(xt(e,n,r,br(e)),e.curOp.forceUpdate=!0),n||(n=Vt(e,t));var i=Ut(n,t,r);return{line:t,view:n,rect:null,map:i.map,cache:i.cache,before:i.before,hasHeights:!1}}function Yt(e,t,r,n,i){t.before&&(r=-1);var o,l=r+(n||"");return t.cache.hasOwnProperty(l)?o=t.cache[l]:(t.rect||(t.rect=t.view.text.getBoundingClientRect()),t.hasHeights||(Gt(e,t.view,t.rect),t.hasHeights=!0),(o=qt(e,t,r,n)).bogus||(t.cache[l]=o)),{left:o.left,right:o.right,top:i?o.rtop:o.top,bottom:i?o.rbottom:o.bottom}}function _t(e,t,r){for(var n,i,o,l,s,a,u=0;u<e.length;u+=3)if(s=e[u],a=e[u+1],t<s?(i=0,o=1,l="left"):t<a?o=(i=t-s)+1:(u==e.length-3||t==a&&e[u+3]>t)&&(i=(o=a-s)-1,t>=a&&(l="right")),null!=i){if(n=e[u+2],s==a&&r==(n.insertLeft?"left":"right")&&(l=r),"left"==r&&0==i)for(;u&&e[u-2]==e[u-3]&&e[u-1].insertLeft;)n=e[2+(u-=3)],l="left";if("right"==r&&i==a-s)for(;u<e.length-3&&e[u+3]==e[u+4]&&!e[u+5].insertLeft;)n=e[(u+=3)+2],l="right";break}return{node:n,start:i,end:o,collapse:l,coverStart:s,coverEnd:a}}function $t(e,t){var r=ms;if("left"==t)for(var n=0;n<e.length&&(r=e[n]).left==r.right;n++);else for(var i=e.length-1;i>=0&&(r=e[i]).left==r.right;i--);return r}function qt(e,t,r,n){var i,o=_t(t.map,r,n),l=o.node,s=o.start,a=o.end,u=o.collapse;if(3==l.nodeType){for(var c=0;c<4;c++){for(;s&&S(t.line.text.charAt(o.coverStart+s));)--s;for(;o.coverStart+a<o.coverEnd&&S(t.line.text.charAt(o.coverStart+a));)++a;if((i=gl&&vl<9&&0==s&&a==o.coverEnd-o.coverStart?l.parentNode.getBoundingClientRect():$t(Wl(l,s,a).getClientRects(),n)).left||i.right||0==s)break;a=s,s-=1,u="right"}gl&&vl<11&&(i=Zt(e.display.measure,i))}else{s>0&&(u=n="right");var f;i=e.options.lineWrapping&&(f=l.getClientRects()).length>1?f["right"==n?f.length-1:0]:l.getBoundingClientRect()}if(gl&&vl<9&&!s&&(!i||!i.left&&!i.right)){var h=l.parentNode.getClientRects()[0];i=h?{left:h.left,right:h.left+yr(e.display),top:h.top,bottom:h.bottom}:ms}for(var d=i.top-t.rect.top,p=i.bottom-t.rect.top,g=(d+p)/2,v=t.view.measure.heights,m=0;m<v.length-1&&!(g<v[m]);m++);var y=m?v[m-1]:0,b=v[m],w={left:("right"==u?i.right:i.left)-t.rect.left,right:("left"==u?i.left:i.right)-t.rect.left,top:y,bottom:b};return i.left||i.right||(w.bogus=!0),e.options.singleCursorHeightPerLine||(w.rtop=d,w.rbottom=p),w}function Zt(e,t){if(!window.screen||null==screen.logicalXDPI||screen.logicalXDPI==screen.deviceXDPI||!Re(e))return t;var r=screen.logicalXDPI/screen.deviceXDPI,n=screen.logicalYDPI/screen.deviceYDPI;return{left:t.left*r,right:t.right*r,top:t.top*n,bottom:t.bottom*n}}function Qt(e){if(e.measure&&(e.measure.cache={},e.measure.heights=null,e.rest))for(var t=0;t<e.rest.length;t++)e.measure.caches[t]={}}function Jt(e){e.display.externalMeasure=null,t(e.display.lineMeasure);for(var r=0;r<e.display.view.length;r++)Qt(e.display.view[r])}function er(e){Jt(e),e.display.cachedCharWidth=e.display.cachedTextHeight=e.display.cachedPaddingH=null,e.options.lineWrapping||(e.display.maxLineChanged=!0),e.display.lineNumChars=null}function tr(){return bl&&kl?-(document.body.getBoundingClientRect().left-parseInt(getComputedStyle(document.body).marginLeft)):window.pageXOffset||(document.documentElement||document.body).scrollLeft}function rr(){return bl&&kl?-(document.body.getBoundingClientRect().top-parseInt(getComputedStyle(document.body).marginTop)):window.pageYOffset||(document.documentElement||document.body).scrollTop}function nr(e){var t=0;if(e.widgets)for(var r=0;r<e.widgets.length;++r)e.widgets[r].above&&(t+=Ht(e.widgets[r]));return t}function ir(e,t,r,n,i){if(!i){var o=nr(t);r.top+=o,r.bottom+=o}if("line"==n)return r;n||(n="local");var l=ye(t);if("local"==n?l+=Et(e.display):l-=e.display.viewOffset,"page"==n||"window"==n){var s=e.display.lineSpace.getBoundingClientRect();l+=s.top+("window"==n?0:rr());var a=s.left+("window"==n?0:tr());r.left+=a,r.right+=a}return r.top+=l,r.bottom+=l,r}function or(e,t,r){if("div"==r)return t;var n=t.left,i=t.top;if("page"==r)n-=tr(),i-=rr();else if("local"==r||!r){var o=e.display.sizer.getBoundingClientRect();n+=o.left,i+=o.top}var l=e.display.lineSpace.getBoundingClientRect();return{left:n-l.left,top:i-l.top}}function lr(e,t,r,n,i){return n||(n=M(e.doc,t.line)),ir(e,n,Kt(e,n,t.ch,i),r)}function sr(e,t,r,n,i,o){function l(t,l){var s=Yt(e,i,t,l?"right":"left",o);return l?s.left=s.right:s.right=s.left,ir(e,n,s,r)}function s(e,t,r){var n=1==a[t].level;return l(r?e-1:e,n!=r)}n=n||M(e.doc,t.line),i||(i=Xt(e,n));var a=Se(n,e.doc.direction),u=t.ch,c=t.sticky;if(u>=n.text.length?(u=n.text.length,c="before"):u<=0&&(u=0,c="after"),!a)return l("before"==c?u-1:u,"before"==c);var f=Ce(a,u,c),h=$l,d=s(u,f,"before"==c);return null!=h&&(d.other=s(u,h,"before"!=c)),d}function ar(e,t){var r=0;t=U(e.doc,t),e.options.lineWrapping||(r=yr(e.display)*t.ch);var n=M(e.doc,t.line),i=ye(n)+Et(e.display);return{left:r,right:r,top:i,bottom:i+n.height}}function ur(e,t,r,n,i){var o=E(e,t,r);return o.xRel=i,n&&(o.outside=!0),o}function cr(e,t,r){var n=e.doc;if((r+=e.display.viewOffset)<0)return ur(n.first,0,null,!0,-1);var i=D(n,r),o=n.first+n.size-1;if(i>o)return ur(n.first+n.size-1,M(n,o).text.length,null,!0,1);t<0&&(t=0);for(var l=M(n,i);;){var s=pr(e,l,i,t,r),a=ue(l),u=a&&a.find(0,!0);if(!a||!(s.ch>u.from.ch||s.ch==u.from.ch&&s.xRel>0))return s;i=W(l=u.to.line)}}function fr(e,t,r,n){n-=nr(t);var i=t.text.length,o=k(function(t){return Yt(e,r,t-1).bottom<=n},i,0);return i=k(function(t){return Yt(e,r,t).top>n},o,i),{begin:o,end:i}}function hr(e,t,r,n){return r||(r=Xt(e,t)),fr(e,t,r,ir(e,t,Yt(e,r,n),"line").top)}function dr(e,t,r,n){return!(e.bottom<=r)&&(e.top>r||(n?e.left:e.right)>t)}function pr(e,t,r,n,i){i-=ye(t);var o=Xt(e,t),l=nr(t),s=0,a=t.text.length,u=!0,c=Se(t,e.doc.direction);if(c){var f=(e.options.lineWrapping?vr:gr)(e,t,r,o,c,n,i);s=(u=1!=f.level)?f.from:f.to-1,a=u?f.to:f.from-1}var h,d,p=null,g=null,v=k(function(t){var r=Yt(e,o,t);return r.top+=l,r.bottom+=l,!!dr(r,n,i,!1)&&(r.top<=i&&r.left<=n&&(p=t,g=r),!0)},s,a),m=!1;if(g){var y=n-g.left<g.right-n,b=y==u;v=p+(b?0:1),d=b?"after":"before",h=y?g.left:g.right}else{u||v!=a&&v!=s||v++,d=0==v?"after":v==t.text.length?"before":Yt(e,o,v-(u?1:0)).bottom+l<=i==u?"after":"before";var w=sr(e,E(r,v,d),"line",t,o);h=w.left,m=i<w.top||i>=w.bottom}return v=L(t.text,v,1),ur(r,v,d,m,n-h)}function gr(e,t,r,n,i,o,l){var s=k(function(s){var a=i[s],u=1!=a.level;return dr(sr(e,E(r,u?a.to:a.from,u?"before":"after"),"line",t,n),o,l,!0)},0,i.length-1),a=i[s];if(s>0){var u=1!=a.level,c=sr(e,E(r,u?a.from:a.to,u?"after":"before"),"line",t,n);dr(c,o,l,!0)&&c.top>l&&(a=i[s-1])}return a}function vr(e,t,r,n,i,o,l){for(var s=fr(e,t,n,l),a=s.begin,u=s.end,c=null,f=null,h=0;h<i.length;h++){var d=i[h];if(!(d.from>=u||d.to<=a)){var p=Yt(e,n,1!=d.level?Math.min(u,d.to)-1:Math.max(a,d.from)).right,g=p<o?o-p+1e9:p-o;(!c||f>g)&&(c=d,f=g)}}return c||(c=i[i.length-1]),c.from<a&&(c={from:a,to:c.to,level:c.level}),c.to>u&&(c={from:c.from,to:u,level:c.level}),c}function mr(e){if(null!=e.cachedTextHeight)return e.cachedTextHeight;if(null==hs){hs=n("pre");for(var i=0;i<49;++i)hs.appendChild(document.createTextNode("x")),hs.appendChild(n("br"));hs.appendChild(document.createTextNode("x"))}r(e.measure,hs);var o=hs.offsetHeight/50;return o>3&&(e.cachedTextHeight=o),t(e.measure),o||1}function yr(e){if(null!=e.cachedCharWidth)return e.cachedCharWidth;var t=n("span","xxxxxxxxxx"),i=n("pre",[t]);r(e.measure,i);var o=t.getBoundingClientRect(),l=(o.right-o.left)/10;return l>2&&(e.cachedCharWidth=l),l||10}function br(e){for(var t=e.display,r={},n={},i=t.gutters.clientLeft,o=t.gutters.firstChild,l=0;o;o=o.nextSibling,++l)r[e.options.gutters[l]]=o.offsetLeft+o.clientLeft+i,n[e.options.gutters[l]]=o.clientWidth;return{fixedPos:wr(t),gutterTotalWidth:t.gutters.offsetWidth,gutterLeft:r,gutterWidth:n,wrapperWidth:t.wrapper.clientWidth}}function wr(e){return e.scroller.getBoundingClientRect().left-e.sizer.getBoundingClientRect().left}function xr(e){var t=mr(e.display),r=e.options.lineWrapping,n=r&&Math.max(5,e.display.scroller.clientWidth/yr(e.display)-3);return function(i){if(ve(e.doc,i))return 0;var o=0;if(i.widgets)for(var l=0;l<i.widgets.length;l++)i.widgets[l].height&&(o+=i.widgets[l].height);return r?o+(Math.ceil(i.text.length/n)||1)*t:o+t}}function Cr(e){var t=e.doc,r=xr(e);t.iter(function(e){var t=r(e);t!=e.height&&A(e,t)})}function Sr(e,t,r,n){var i=e.display;if(!r&&"true"==Ee(t).getAttribute("cm-not-content"))return null;var o,l,s=i.lineSpace.getBoundingClientRect();try{o=t.clientX-s.left,l=t.clientY-s.top}catch(t){return null}var a,u=cr(e,o,l);if(n&&1==u.xRel&&(a=M(e.doc,u.line).text).length==u.ch){var c=f(a,a.length,e.options.tabSize)-a.length;u=E(u.line,Math.max(0,Math.round((o-It(e.display).left)/yr(e.display))-c))}return u}function Lr(e,t){if(t>=e.display.viewTo)return null;if((t-=e.display.viewFrom)<0)return null;for(var r=e.display.view,n=0;n<r.length;n++)if((t-=r[n].size)<0)return n}function kr(e){e.display.input.showSelection(e.display.input.prepareSelection())}function Tr(e,t){void 0===t&&(t=!0);for(var r=e.doc,n={},i=n.cursors=document.createDocumentFragment(),o=n.selection=document.createDocumentFragment(),l=0;l<r.sel.ranges.length;l++)if(t||l!=r.sel.primIndex){var s=r.sel.ranges[l];if(!(s.from().line>=e.display.viewTo||s.to().line<e.display.viewFrom)){var a=s.empty();(a||e.options.showCursorWhenSelecting)&&Mr(e,s.head,i),a||Or(e,s,o)}}return n}function Mr(e,t,r){var i=sr(e,t,"div",null,null,!e.options.singleCursorHeightPerLine),o=r.appendChild(n("div"," ","CodeMirror-cursor"));if(o.style.left=i.left+"px",o.style.top=i.top+"px",o.style.height=Math.max(0,i.bottom-i.top)*e.options.cursorHeight+"px",i.other){var l=r.appendChild(n("div"," ","CodeMirror-cursor CodeMirror-secondarycursor"));l.style.display="",l.style.left=i.other.left+"px",l.style.top=i.other.top+"px",l.style.height=.85*(i.other.bottom-i.other.top)+"px"}}function Nr(e,t){return e.top-t.top||e.left-t.left}function Or(e,t,r){function i(e,t,r,i){t<0&&(t=0),t=Math.round(t),i=Math.round(i),a.appendChild(n("div",null,"CodeMirror-selected","position: absolute; left: "+e+"px;\n                             top: "+t+"px; width: "+(null==r?f-e:r)+"px;\n                             height: "+(i-t)+"px"))}function o(t,r,n){function o(r,n){return lr(e,E(t,r),"div",u,n)}var l,a,u=M(s,t),h=u.text.length,d=Se(u,s.direction);return xe(d,r||0,null==n?h:n,function(t,s,p,g){var v=o(t,"ltr"==p?"left":"right"),m=o(s-1,"ltr"==p?"right":"left");if("ltr"==p){var y=null==r&&0==t?c:v.left,b=null==n&&s==h?f:m.right;m.top-v.top<=3?i(y,m.top,b-y,m.bottom):(i(y,v.top,null,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top),i(c,m.top,m.right,m.bottom))}else if(t<s){var w=null==r&&0==t?f:v.right,x=null==n&&s==h?c:m.left;if(m.top-v.top<=3)i(x,m.top,w-x,m.bottom);else{var C=c;if(g){var S=hr(e,u,null,t).end;C=o(S-(/\s/.test(u.text.charAt(S-1))?2:1),"left").left}i(C,v.top,w-C,v.bottom),v.bottom<m.top&&i(c,v.bottom,null,m.top);var L=null;d.length,L=o(hr(e,u,null,s).begin,"right").right-x,i(x,m.top,L,m.bottom)}}(!l||Nr(v,l)<0)&&(l=v),Nr(m,l)<0&&(l=m),(!a||Nr(v,a)<0)&&(a=v),Nr(m,a)<0&&(a=m)}),{start:l,end:a}}var l=e.display,s=e.doc,a=document.createDocumentFragment(),u=It(e.display),c=u.left,f=Math.max(l.sizerWidth,Rt(e)-l.sizer.offsetLeft)-u.right,h=t.from(),d=t.to();if(h.line==d.line)o(h.line,h.ch,d.ch);else{var p=M(s,h.line),g=M(s,d.line),v=fe(p)==fe(g),m=o(h.line,h.ch,v?p.text.length+1:null).end,y=o(d.line,v?0:null,d.ch).start;v&&(m.top<y.top-2?(i(m.right,m.top,null,m.bottom),i(c,y.top,y.left,y.bottom)):i(m.right,m.top,y.left-m.right,m.bottom)),m.bottom<y.top&&i(c,m.bottom,null,y.top)}r.appendChild(a)}function Ar(e){if(e.state.focused){var t=e.display;clearInterval(t.blinker);var r=!0;t.cursorDiv.style.visibility="",e.options.cursorBlinkRate>0?t.blinker=setInterval(function(){return t.cursorDiv.style.visibility=(r=!r)?"":"hidden"},e.options.cursorBlinkRate):e.options.cursorBlinkRate<0&&(t.cursorDiv.style.visibility="hidden")}}function Wr(e){e.state.focused||(e.display.input.focus(),Hr(e))}function Dr(e){e.state.delayingBlurEvent=!0,setTimeout(function(){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1,Fr(e))},100)}function Hr(e,t){e.state.delayingBlurEvent&&(e.state.delayingBlurEvent=!1),"nocursor"!=e.options.readOnly&&(e.state.focused||(Te(e,"focus",e,t),e.state.focused=!0,s(e.display.wrapper,"CodeMirror-focused"),e.curOp||e.display.selForContextMenu==e.doc.sel||(e.display.input.reset(),ml&&setTimeout(function(){return e.display.input.reset(!0)},20)),e.display.input.receivedFocus()),Ar(e))}function Fr(e,t){e.state.delayingBlurEvent||(e.state.focused&&(Te(e,"blur",e,t),e.state.focused=!1,Fl(e.display.wrapper,"CodeMirror-focused")),clearInterval(e.display.blinker),setTimeout(function(){e.state.focused||(e.display.shift=!1)},150))}function Er(e){for(var t=e.display,r=t.lineDiv.offsetTop,n=0;n<t.view.length;n++){var i=t.view[n],o=void 0;if(!i.hidden){if(gl&&vl<8){var l=i.node.offsetTop+i.node.offsetHeight;o=l-r,r=l}else{var s=i.node.getBoundingClientRect();o=s.bottom-s.top}var a=i.line.height-o;if(o<2&&(o=mr(t)),(a>.005||a<-.005)&&(A(i.line,o),Pr(i.line),i.rest))for(var u=0;u<i.rest.length;u++)Pr(i.rest[u])}}}function Pr(e){if(e.widgets)for(var t=0;t<e.widgets.length;++t)e.widgets[t].height=e.widgets[t].node.parentNode.offsetHeight}function Ir(e,t,r){var n=r&&null!=r.top?Math.max(0,r.top):e.scroller.scrollTop;n=Math.floor(n-Et(e));var i=r&&null!=r.bottom?r.bottom:n+e.wrapper.clientHeight,o=D(t,n),l=D(t,i);if(r&&r.ensure){var s=r.ensure.from.line,a=r.ensure.to.line;s<o?(o=s,l=D(t,ye(M(t,s))+e.wrapper.clientHeight)):Math.min(a,t.lastLine())>=l&&(o=D(t,ye(M(t,a))-e.wrapper.clientHeight),l=a)}return{from:o,to:Math.max(l,o+1)}}function zr(e){var t=e.display,r=t.view;if(t.alignWidgets||t.gutters.firstChild&&e.options.fixedGutter){for(var n=wr(t)-t.scroller.scrollLeft+e.doc.scrollLeft,i=t.gutters.offsetWidth,o=n+"px",l=0;l<r.length;l++)if(!r[l].hidden){e.options.fixedGutter&&(r[l].gutter&&(r[l].gutter.style.left=o),r[l].gutterBackground&&(r[l].gutterBackground.style.left=o));var s=r[l].alignable;if(s)for(var a=0;a<s.length;a++)s[a].style.left=o}e.options.fixedGutter&&(t.gutters.style.left=n+i+"px")}}function Rr(e){if(!e.options.lineNumbers)return!1;var t=e.doc,r=F(e.options,t.first+t.size-1),i=e.display;if(r.length!=i.lineNumChars){var o=i.measure.appendChild(n("div",[n("div",r)],"CodeMirror-linenumber CodeMirror-gutter-elt")),l=o.firstChild.offsetWidth,s=o.offsetWidth-l;return i.lineGutter.style.width="",i.lineNumInnerWidth=Math.max(l,i.lineGutter.offsetWidth-s)+1,i.lineNumWidth=i.lineNumInnerWidth+s,i.lineNumChars=i.lineNumInnerWidth?r.length:-1,i.lineGutter.style.width=i.lineNumWidth+"px",Wn(e),!0}return!1}function Br(e,t){if(!Me(e,"scrollCursorIntoView")){var r=e.display,i=r.sizer.getBoundingClientRect(),o=null;if(t.top+i.top<0?o=!0:t.bottom+i.top>(window.innerHeight||document.documentElement.clientHeight)&&(o=!1),null!=o&&!Sl){var l=n("div","​",null,"position: absolute;\n                         top: "+(t.top-r.viewOffset-Et(e.display))+"px;\n                         height: "+(t.bottom-t.top+zt(e)+r.barHeight)+"px;\n                         left: "+t.left+"px; width: "+Math.max(2,t.right-t.left)+"px;");e.display.lineSpace.appendChild(l),l.scrollIntoView(o),e.display.lineSpace.removeChild(l)}}}function Gr(e,t,r,n){null==n&&(n=0);var i;e.options.lineWrapping||t!=r||(r="before"==(t=t.ch?E(t.line,"before"==t.sticky?t.ch-1:t.ch,"after"):t).sticky?E(t.line,t.ch+1,"before"):t);for(var o=0;o<5;o++){var l=!1,s=sr(e,t),a=r&&r!=t?sr(e,r):s,u=Vr(e,i={left:Math.min(s.left,a.left),top:Math.min(s.top,a.top)-n,right:Math.max(s.left,a.left),bottom:Math.max(s.bottom,a.bottom)+n}),c=e.doc.scrollTop,f=e.doc.scrollLeft;if(null!=u.scrollTop&&(qr(e,u.scrollTop),Math.abs(e.doc.scrollTop-c)>1&&(l=!0)),null!=u.scrollLeft&&(Qr(e,u.scrollLeft),Math.abs(e.doc.scrollLeft-f)>1&&(l=!0)),!l)break}return i}function Ur(e,t){var r=Vr(e,t);null!=r.scrollTop&&qr(e,r.scrollTop),null!=r.scrollLeft&&Qr(e,r.scrollLeft)}function Vr(e,t){var r=e.display,n=mr(e.display);t.top<0&&(t.top=0);var i=e.curOp&&null!=e.curOp.scrollTop?e.curOp.scrollTop:r.scroller.scrollTop,o=Bt(e),l={};t.bottom-t.top>o&&(t.bottom=t.top+o);var s=e.doc.height+Pt(r),a=t.top<n,u=t.bottom>s-n;if(t.top<i)l.scrollTop=a?0:t.top;else if(t.bottom>i+o){var c=Math.min(t.top,(u?s:t.bottom)-o);c!=i&&(l.scrollTop=c)}var f=e.curOp&&null!=e.curOp.scrollLeft?e.curOp.scrollLeft:r.scroller.scrollLeft,h=Rt(e)-(e.options.fixedGutter?r.gutters.offsetWidth:0),d=t.right-t.left>h;return d&&(t.right=t.left+h),t.left<10?l.scrollLeft=0:t.left<f?l.scrollLeft=Math.max(0,t.left-(d?0:10)):t.right>h+f-3&&(l.scrollLeft=t.right+(d?0:10)-h),l}function Kr(e,t){null!=t&&(_r(e),e.curOp.scrollTop=(null==e.curOp.scrollTop?e.doc.scrollTop:e.curOp.scrollTop)+t)}function jr(e){_r(e);var t=e.getCursor();e.curOp.scrollToPos={from:t,to:t,margin:e.options.cursorScrollMargin}}function Xr(e,t,r){null==t&&null==r||_r(e),null!=t&&(e.curOp.scrollLeft=t),null!=r&&(e.curOp.scrollTop=r)}function Yr(e,t){_r(e),e.curOp.scrollToPos=t}function _r(e){var t=e.curOp.scrollToPos;t&&(e.curOp.scrollToPos=null,$r(e,ar(e,t.from),ar(e,t.to),t.margin))}function $r(e,t,r,n){var i=Vr(e,{left:Math.min(t.left,r.left),top:Math.min(t.top,r.top)-n,right:Math.max(t.right,r.right),bottom:Math.max(t.bottom,r.bottom)+n});Xr(e,i.scrollLeft,i.scrollTop)}function qr(e,t){Math.abs(e.doc.scrollTop-t)<2||(fl||On(e,{top:t}),Zr(e,t,!0),fl&&On(e),Cn(e,100))}function Zr(e,t,r){t=Math.min(e.display.scroller.scrollHeight-e.display.scroller.clientHeight,t),(e.display.scroller.scrollTop!=t||r)&&(e.doc.scrollTop=t,e.display.scrollbars.setScrollTop(t),e.display.scroller.scrollTop!=t&&(e.display.scroller.scrollTop=t))}function Qr(e,t,r,n){t=Math.min(t,e.display.scroller.scrollWidth-e.display.scroller.clientWidth),(r?t==e.doc.scrollLeft:Math.abs(e.doc.scrollLeft-t)<2)&&!n||(e.doc.scrollLeft=t,zr(e),e.display.scroller.scrollLeft!=t&&(e.display.scroller.scrollLeft=t),e.display.scrollbars.setScrollLeft(t))}function Jr(e){var t=e.display,r=t.gutters.offsetWidth,n=Math.round(e.doc.height+Pt(e.display));return{clientHeight:t.scroller.clientHeight,viewHeight:t.wrapper.clientHeight,scrollWidth:t.scroller.scrollWidth,clientWidth:t.scroller.clientWidth,viewWidth:t.wrapper.clientWidth,barLeft:e.options.fixedGutter?r:0,docHeight:n,scrollHeight:n+zt(e)+t.barHeight,nativeBarWidth:t.nativeBarWidth,gutterWidth:r}}function en(e,t){t||(t=Jr(e));var r=e.display.barWidth,n=e.display.barHeight;tn(e,t);for(var i=0;i<4&&r!=e.display.barWidth||n!=e.display.barHeight;i++)r!=e.display.barWidth&&e.options.lineWrapping&&Er(e),tn(e,Jr(e)),r=e.display.barWidth,n=e.display.barHeight}function tn(e,t){var r=e.display,n=r.scrollbars.update(t);r.sizer.style.paddingRight=(r.barWidth=n.right)+"px",r.sizer.style.paddingBottom=(r.barHeight=n.bottom)+"px",r.heightForcer.style.borderBottom=n.bottom+"px solid transparent",n.right&&n.bottom?(r.scrollbarFiller.style.display="block",r.scrollbarFiller.style.height=n.bottom+"px",r.scrollbarFiller.style.width=n.right+"px"):r.scrollbarFiller.style.display="",n.bottom&&e.options.coverGutterNextToScrollbar&&e.options.fixedGutter?(r.gutterFiller.style.display="block",r.gutterFiller.style.height=n.bottom+"px",r.gutterFiller.style.width=t.gutterWidth+"px"):r.gutterFiller.style.display=""}function rn(e){e.display.scrollbars&&(e.display.scrollbars.clear(),e.display.scrollbars.addClass&&Fl(e.display.wrapper,e.display.scrollbars.addClass)),e.display.scrollbars=new ws[e.options.scrollbarStyle](function(t){e.display.wrapper.insertBefore(t,e.display.scrollbarFiller),Ql(t,"mousedown",function(){e.state.focused&&setTimeout(function(){return e.display.input.focus()},0)}),t.setAttribute("cm-not-content","true")},function(t,r){"horizontal"==r?Qr(e,t):qr(e,t)},e),e.display.scrollbars.addClass&&s(e.display.wrapper,e.display.scrollbars.addClass)}function nn(e){e.curOp={cm:e,viewChanged:!1,startHeight:e.doc.height,forceUpdate:!1,updateInput:null,typing:!1,changeObjs:null,cursorActivityHandlers:null,cursorActivityCalled:0,selectionChanged:!1,updateMaxLine:!1,scrollLeft:null,scrollTop:null,scrollToPos:null,focus:!1,id:++xs},vt(e.curOp)}function on(e){yt(e.curOp,function(e){for(var t=0;t<e.ops.length;t++)e.ops[t].cm.curOp=null;ln(e)})}function ln(e){for(var t=e.ops,r=0;r<t.length;r++)sn(t[r]);for(var n=0;n<t.length;n++)an(t[n]);for(var i=0;i<t.length;i++)un(t[i]);for(var o=0;o<t.length;o++)cn(t[o]);for(var l=0;l<t.length;l++)fn(t[l])}function sn(e){var t=e.cm,r=t.display;Ln(t),e.updateMaxLine&&we(t),e.mustUpdate=e.viewChanged||e.forceUpdate||null!=e.scrollTop||e.scrollToPos&&(e.scrollToPos.from.line<r.viewFrom||e.scrollToPos.to.line>=r.viewTo)||r.maxLineChanged&&t.options.lineWrapping,e.update=e.mustUpdate&&new Cs(t,e.mustUpdate&&{top:e.scrollTop,ensure:e.scrollToPos},e.forceUpdate)}function an(e){e.updatedDisplay=e.mustUpdate&&Mn(e.cm,e.update)}function un(e){var t=e.cm,r=t.display;e.updatedDisplay&&Er(t),e.barMeasure=Jr(t),r.maxLineChanged&&!t.options.lineWrapping&&(e.adjustWidthTo=Kt(t,r.maxLine,r.maxLine.text.length).left+3,t.display.sizerWidth=e.adjustWidthTo,e.barMeasure.scrollWidth=Math.max(r.scroller.clientWidth,r.sizer.offsetLeft+e.adjustWidthTo+zt(t)+t.display.barWidth),e.maxScrollLeft=Math.max(0,r.sizer.offsetLeft+e.adjustWidthTo-Rt(t))),(e.updatedDisplay||e.selectionChanged)&&(e.preparedSelection=r.input.prepareSelection())}function cn(e){var t=e.cm;null!=e.adjustWidthTo&&(t.display.sizer.style.minWidth=e.adjustWidthTo+"px",e.maxScrollLeft<t.doc.scrollLeft&&Qr(t,Math.min(t.display.scroller.scrollLeft,e.maxScrollLeft),!0),t.display.maxLineChanged=!1);var r=e.focus&&e.focus==l();e.preparedSelection&&t.display.input.showSelection(e.preparedSelection,r),(e.updatedDisplay||e.startHeight!=t.doc.height)&&en(t,e.barMeasure),e.updatedDisplay&&Dn(t,e.barMeasure),e.selectionChanged&&Ar(t),t.state.focused&&e.updateInput&&t.display.input.reset(e.typing),r&&Wr(e.cm)}function fn(e){var t=e.cm,r=t.display,n=t.doc;e.updatedDisplay&&Nn(t,e.update),null==r.wheelStartX||null==e.scrollTop&&null==e.scrollLeft&&!e.scrollToPos||(r.wheelStartX=r.wheelStartY=null),null!=e.scrollTop&&Zr(t,e.scrollTop,e.forceScroll),null!=e.scrollLeft&&Qr(t,e.scrollLeft,!0,!0),e.scrollToPos&&Br(t,Gr(t,U(n,e.scrollToPos.from),U(n,e.scrollToPos.to),e.scrollToPos.margin));var i=e.maybeHiddenMarkers,o=e.maybeUnhiddenMarkers;if(i)for(var l=0;l<i.length;++l)i[l].lines.length||Te(i[l],"hide");if(o)for(var s=0;s<o.length;++s)o[s].lines.length&&Te(o[s],"unhide");r.wrapper.offsetHeight&&(n.scrollTop=t.display.scroller.scrollTop),e.changeObjs&&Te(t,"changes",t,e.changeObjs),e.update&&e.update.finish()}function hn(e,t){if(e.curOp)return t();nn(e);try{return t()}finally{on(e)}}function dn(e,t){return function(){if(e.curOp)return t.apply(e,arguments);nn(e);try{return t.apply(e,arguments)}finally{on(e)}}}function pn(e){return function(){if(this.curOp)return e.apply(this,arguments);nn(this);try{return e.apply(this,arguments)}finally{on(this)}}}function gn(e){return function(){var t=this.cm;if(!t||t.curOp)return e.apply(this,arguments);nn(t);try{return e.apply(this,arguments)}finally{on(t)}}}function vn(e,t,r,n){null==t&&(t=e.doc.first),null==r&&(r=e.doc.first+e.doc.size),n||(n=0);var i=e.display;if(n&&r<i.viewTo&&(null==i.updateLineNumbers||i.updateLineNumbers>t)&&(i.updateLineNumbers=t),e.curOp.viewChanged=!0,t>=i.viewTo)_l&&pe(e.doc,t)<i.viewTo&&yn(e);else if(r<=i.viewFrom)_l&&ge(e.doc,r+n)>i.viewFrom?yn(e):(i.viewFrom+=n,i.viewTo+=n);else if(t<=i.viewFrom&&r>=i.viewTo)yn(e);else if(t<=i.viewFrom){var o=bn(e,r,r+n,1);o?(i.view=i.view.slice(o.index),i.viewFrom=o.lineN,i.viewTo+=n):yn(e)}else if(r>=i.viewTo){var l=bn(e,t,t,-1);l?(i.view=i.view.slice(0,l.index),i.viewTo=l.lineN):yn(e)}else{var s=bn(e,t,t,-1),a=bn(e,r,r+n,1);s&&a?(i.view=i.view.slice(0,s.index).concat(gt(e,s.lineN,a.lineN)).concat(i.view.slice(a.index)),i.viewTo+=n):yn(e)}var u=i.externalMeasured;u&&(r<u.lineN?u.lineN+=n:t<u.lineN+u.size&&(i.externalMeasured=null))}function mn(e,t,r){e.curOp.viewChanged=!0;var n=e.display,i=e.display.externalMeasured;if(i&&t>=i.lineN&&t<i.lineN+i.size&&(n.externalMeasured=null),!(t<n.viewFrom||t>=n.viewTo)){var o=n.view[Lr(e,t)];if(null!=o.node){var l=o.changes||(o.changes=[]);-1==h(l,r)&&l.push(r)}}}function yn(e){e.display.viewFrom=e.display.viewTo=e.doc.first,e.display.view=[],e.display.viewOffset=0}function bn(e,t,r,n){var i,o=Lr(e,t),l=e.display.view;if(!_l||r==e.doc.first+e.doc.size)return{index:o,lineN:r};for(var s=e.display.viewFrom,a=0;a<o;a++)s+=l[a].size;if(s!=t){if(n>0){if(o==l.length-1)return null;i=s+l[o].size-t,o++}else i=s-t;t+=i,r+=i}for(;pe(e.doc,r)!=r;){if(o==(n<0?0:l.length-1))return null;r+=n*l[o-(n<0?1:0)].size,o+=n}return{index:o,lineN:r}}function wn(e,t,r){var n=e.display;0==n.view.length||t>=n.viewTo||r<=n.viewFrom?(n.view=gt(e,t,r),n.viewFrom=t):(n.viewFrom>t?n.view=gt(e,t,n.viewFrom).concat(n.view):n.viewFrom<t&&(n.view=n.view.slice(Lr(e,t))),n.viewFrom=t,n.viewTo<r?n.view=n.view.concat(gt(e,n.viewTo,r)):n.viewTo>r&&(n.view=n.view.slice(0,Lr(e,r)))),n.viewTo=r}function xn(e){for(var t=e.display.view,r=0,n=0;n<t.length;n++){var i=t[n];i.hidden||i.node&&!i.changes||++r}return r}function Cn(e,t){e.doc.highlightFrontier<e.display.viewTo&&e.state.highlight.set(t,u(Sn,e))}function Sn(e){var t=e.doc;if(!(t.highlightFrontier>=e.display.viewTo)){var r=+new Date+e.options.workTime,n=$e(e,t.highlightFrontier),i=[];t.iter(n.line,Math.min(t.first+t.size,e.display.viewTo+500),function(o){if(n.line>=e.display.viewFrom){var l=o.styles,s=o.text.length>e.options.maxHighlightLength?Ke(t.mode,n.state):null,a=Ye(e,o,n,!0);s&&(n.state=s),o.styles=a.styles;var u=o.styleClasses,c=a.classes;c?o.styleClasses=c:u&&(o.styleClasses=null);for(var f=!l||l.length!=o.styles.length||u!=c&&(!u||!c||u.bgClass!=c.bgClass||u.textClass!=c.textClass),h=0;!f&&h<l.length;++h)f=l[h]!=o.styles[h];f&&i.push(n.line),o.stateAfter=n.save(),n.nextLine()}else o.text.length<=e.options.maxHighlightLength&&qe(e,o.text,n),o.stateAfter=n.line%5==0?n.save():null,n.nextLine();if(+new Date>r)return Cn(e,e.options.workDelay),!0}),t.highlightFrontier=n.line,t.modeFrontier=Math.max(t.modeFrontier,n.line),i.length&&hn(e,function(){for(var t=0;t<i.length;t++)mn(e,i[t],"text")})}}function Ln(e){var t=e.display;!t.scrollbarsClipped&&t.scroller.offsetWidth&&(t.nativeBarWidth=t.scroller.offsetWidth-t.scroller.clientWidth,t.heightForcer.style.height=zt(e)+"px",t.sizer.style.marginBottom=-t.nativeBarWidth+"px",t.sizer.style.borderRightWidth=zt(e)+"px",t.scrollbarsClipped=!0)}function kn(e){if(e.hasFocus())return null;var t=l();if(!t||!o(e.display.lineDiv,t))return null;var r={activeElt:t};if(window.getSelection){var n=window.getSelection();n.anchorNode&&n.extend&&o(e.display.lineDiv,n.anchorNode)&&(r.anchorNode=n.anchorNode,r.anchorOffset=n.anchorOffset,r.focusNode=n.focusNode,r.focusOffset=n.focusOffset)}return r}function Tn(e){if(e&&e.activeElt&&e.activeElt!=l()&&(e.activeElt.focus(),e.anchorNode&&o(document.body,e.anchorNode)&&o(document.body,e.focusNode))){var t=window.getSelection(),r=document.createRange();r.setEnd(e.anchorNode,e.anchorOffset),r.collapse(!1),t.removeAllRanges(),t.addRange(r),t.extend(e.focusNode,e.focusOffset)}}function Mn(e,r){var n=e.display,i=e.doc;if(r.editorIsHidden)return yn(e),!1;if(!r.force&&r.visible.from>=n.viewFrom&&r.visible.to<=n.viewTo&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo)&&n.renderedView==n.view&&0==xn(e))return!1;Rr(e)&&(yn(e),r.dims=br(e));var o=i.first+i.size,l=Math.max(r.visible.from-e.options.viewportMargin,i.first),s=Math.min(o,r.visible.to+e.options.viewportMargin);n.viewFrom<l&&l-n.viewFrom<20&&(l=Math.max(i.first,n.viewFrom)),n.viewTo>s&&n.viewTo-s<20&&(s=Math.min(o,n.viewTo)),_l&&(l=pe(e.doc,l),s=ge(e.doc,s));var a=l!=n.viewFrom||s!=n.viewTo||n.lastWrapHeight!=r.wrapperHeight||n.lastWrapWidth!=r.wrapperWidth;wn(e,l,s),n.viewOffset=ye(M(e.doc,n.viewFrom)),e.display.mover.style.top=n.viewOffset+"px";var u=xn(e);if(!a&&0==u&&!r.force&&n.renderedView==n.view&&(null==n.updateLineNumbers||n.updateLineNumbers>=n.viewTo))return!1;var c=kn(e);return u>4&&(n.lineDiv.style.display="none"),An(e,n.updateLineNumbers,r.dims),u>4&&(n.lineDiv.style.display=""),n.renderedView=n.view,Tn(c),t(n.cursorDiv),t(n.selectionDiv),n.gutters.style.height=n.sizer.style.minHeight=0,a&&(n.lastWrapHeight=r.wrapperHeight,n.lastWrapWidth=r.wrapperWidth,Cn(e,400)),n.updateLineNumbers=null,!0}function Nn(e,t){for(var r=t.viewport,n=!0;(n&&e.options.lineWrapping&&t.oldDisplayWidth!=Rt(e)||(r&&null!=r.top&&(r={top:Math.min(e.doc.height+Pt(e.display)-Bt(e),r.top)}),t.visible=Ir(e.display,e.doc,r),!(t.visible.from>=e.display.viewFrom&&t.visible.to<=e.display.viewTo)))&&Mn(e,t);n=!1){Er(e);var i=Jr(e);kr(e),en(e,i),Dn(e,i),t.force=!1}t.signal(e,"update",e),e.display.viewFrom==e.display.reportedViewFrom&&e.display.viewTo==e.display.reportedViewTo||(t.signal(e,"viewportChange",e,e.display.viewFrom,e.display.viewTo),e.display.reportedViewFrom=e.display.viewFrom,e.display.reportedViewTo=e.display.viewTo)}function On(e,t){var r=new Cs(e,t);if(Mn(e,r)){Er(e),Nn(e,r);var n=Jr(e);kr(e),en(e,n),Dn(e,n),r.finish()}}function An(e,r,n){function i(t){var r=t.nextSibling;return ml&&Ml&&e.display.currentWheelTarget==t?t.style.display="none":t.parentNode.removeChild(t),r}for(var o=e.display,l=e.options.lineNumbers,s=o.lineDiv,a=s.firstChild,u=o.view,c=o.viewFrom,f=0;f<u.length;f++){var d=u[f];if(d.hidden);else if(d.node&&d.node.parentNode==s){for(;a!=d.node;)a=i(a);var p=l&&null!=r&&r<=c&&d.lineNumber;d.changes&&(h(d.changes,"gutter")>-1&&(p=!1),xt(e,d,c,n)),p&&(t(d.lineNumber),d.lineNumber.appendChild(document.createTextNode(F(e.options,c)))),a=d.node.nextSibling}else{var g=Ot(e,d,c,n);s.insertBefore(g,a)}c+=d.size}for(;a;)a=i(a)}function Wn(e){var t=e.display.gutters.offsetWidth;e.display.sizer.style.marginLeft=t+"px"}function Dn(e,t){e.display.sizer.style.minHeight=t.docHeight+"px",e.display.heightForcer.style.top=t.docHeight+"px",e.display.gutters.style.height=t.docHeight+e.display.barHeight+zt(e)+"px"}function Hn(e){var r=e.display.gutters,i=e.options.gutters;t(r);for(var o=0;o<i.length;++o){var l=i[o],s=r.appendChild(n("div",null,"CodeMirror-gutter "+l));"CodeMirror-linenumbers"==l&&(e.display.lineGutter=s,s.style.width=(e.display.lineNumWidth||1)+"px")}r.style.display=o?"":"none",Wn(e)}function Fn(e){var t=h(e.gutters,"CodeMirror-linenumbers");-1==t&&e.lineNumbers?e.gutters=e.gutters.concat(["CodeMirror-linenumbers"]):t>-1&&!e.lineNumbers&&(e.gutters=e.gutters.slice(0),e.gutters.splice(t,1))}function En(e){var t=e.wheelDeltaX,r=e.wheelDeltaY;return null==t&&e.detail&&e.axis==e.HORIZONTAL_AXIS&&(t=e.detail),null==r&&e.detail&&e.axis==e.VERTICAL_AXIS?r=e.detail:null==r&&(r=e.wheelDelta),{x:t,y:r}}function Pn(e){var t=En(e);return t.x*=Ls,t.y*=Ls,t}function In(e,t){var r=En(t),n=r.x,i=r.y,o=e.display,l=o.scroller,s=l.scrollWidth>l.clientWidth,a=l.scrollHeight>l.clientHeight;if(n&&s||i&&a){if(i&&Ml&&ml)e:for(var u=t.target,c=o.view;u!=l;u=u.parentNode)for(var f=0;f<c.length;f++)if(c[f].node==u){e.display.currentWheelTarget=u;break e}if(n&&!fl&&!wl&&null!=Ls)return i&&a&&qr(e,Math.max(0,l.scrollTop+i*Ls)),Qr(e,Math.max(0,l.scrollLeft+n*Ls)),(!i||i&&a)&&We(t),void(o.wheelStartX=null);if(i&&null!=Ls){var h=i*Ls,d=e.doc.scrollTop,p=d+o.wrapper.clientHeight;h<0?d=Math.max(0,d+h-50):p=Math.min(e.doc.height,p+h+50),On(e,{top:d,bottom:p})}Ss<20&&(null==o.wheelStartX?(o.wheelStartX=l.scrollLeft,o.wheelStartY=l.scrollTop,o.wheelDX=n,o.wheelDY=i,setTimeout(function(){if(null!=o.wheelStartX){var e=l.scrollLeft-o.wheelStartX,t=l.scrollTop-o.wheelStartY,r=t&&o.wheelDY&&t/o.wheelDY||e&&o.wheelDX&&e/o.wheelDX;o.wheelStartX=o.wheelStartY=null,r&&(Ls=(Ls*Ss+r)/(Ss+1),++Ss)}},200)):(o.wheelDX+=n,o.wheelDY+=i))}}function zn(e,t){var r=e[t];e.sort(function(e,t){return P(e.from(),t.from())}),t=h(e,r);for(var n=1;n<e.length;n++){var i=e[n],o=e[n-1];if(P(o.to(),i.from())>=0){var l=B(o.from(),i.from()),s=R(o.to(),i.to()),a=o.empty()?i.from()==i.head:o.from()==o.head;n<=t&&--t,e.splice(--n,2,new Ts(a?s:l,a?l:s))}}return new ks(e,t)}function Rn(e,t){return new ks([new Ts(e,t||e)],0)}function Bn(e){return e.text?E(e.from.line+e.text.length-1,g(e.text).length+(1==e.text.length?e.from.ch:0)):e.to}function Gn(e,t){if(P(e,t.from)<0)return e;if(P(e,t.to)<=0)return Bn(t);var r=e.line+t.text.length-(t.to.line-t.from.line)-1,n=e.ch;return e.line==t.to.line&&(n+=Bn(t).ch-t.to.ch),E(r,n)}function Un(e,t){for(var r=[],n=0;n<e.sel.ranges.length;n++){var i=e.sel.ranges[n];r.push(new Ts(Gn(i.anchor,t),Gn(i.head,t)))}return zn(r,e.sel.primIndex)}function Vn(e,t,r){return e.line==t.line?E(r.line,e.ch-t.ch+r.ch):E(r.line+(e.line-t.line),e.ch)}function Kn(e,t,r){for(var n=[],i=E(e.first,0),o=i,l=0;l<t.length;l++){var s=t[l],a=Vn(s.from,i,o),u=Vn(Bn(s),i,o);if(i=s.to,o=u,"around"==r){var c=e.sel.ranges[l],f=P(c.head,c.anchor)<0;n[l]=new Ts(f?u:a,f?a:u)}else n[l]=new Ts(a,a)}return new ks(n,e.sel.primIndex)}function jn(e){e.doc.mode=Ue(e.options,e.doc.modeOption),Xn(e)}function Xn(e){e.doc.iter(function(e){e.stateAfter&&(e.stateAfter=null),e.styles&&(e.styles=null)}),e.doc.modeFrontier=e.doc.highlightFrontier=e.doc.first,Cn(e,100),e.state.modeGen++,e.curOp&&vn(e)}function Yn(e,t){return 0==t.from.ch&&0==t.to.ch&&""==g(t.text)&&(!e.cm||e.cm.options.wholeLineUpdateBefore)}function _n(e,t,r,n){function i(e){return r?r[e]:null}function o(e,r,i){it(e,r,i,n),bt(e,"change",e,t)}function l(e,t){for(var r=[],o=e;o<t;++o)r.push(new fs(u[o],i(o),n));return r}var s=t.from,a=t.to,u=t.text,c=M(e,s.line),f=M(e,a.line),h=g(u),d=i(u.length-1),p=a.line-s.line;if(t.full)e.insert(0,l(0,u.length)),e.remove(u.length,e.size-u.length);else if(Yn(e,t)){var v=l(0,u.length-1);o(f,f.text,d),p&&e.remove(s.line,p),v.length&&e.insert(s.line,v)}else if(c==f)if(1==u.length)o(c,c.text.slice(0,s.ch)+h+c.text.slice(a.ch),d);else{var m=l(1,u.length-1);m.push(new fs(h+c.text.slice(a.ch),d,n)),o(c,c.text.slice(0,s.ch)+u[0],i(0)),e.insert(s.line+1,m)}else if(1==u.length)o(c,c.text.slice(0,s.ch)+u[0]+f.text.slice(a.ch),i(0)),e.remove(s.line+1,p);else{o(c,c.text.slice(0,s.ch)+u[0],i(0)),o(f,h+f.text.slice(a.ch),d);var y=l(1,u.length-1);p>1&&e.remove(s.line+1,p-1),e.insert(s.line+1,y)}bt(e,"change",e,t)}function $n(e,t,r){function n(e,i,o){if(e.linked)for(var l=0;l<e.linked.length;++l){var s=e.linked[l];if(s.doc!=i){var a=o&&s.sharedHist;r&&!a||(t(s.doc,a),n(s.doc,e,a))}}}n(e,null,!0)}function qn(e,t){if(t.cm)throw new Error("This document is already in use.");e.doc=t,t.cm=e,Cr(e),jn(e),Zn(e),e.options.lineWrapping||we(e),e.options.mode=t.modeOption,vn(e)}function Zn(e){("rtl"==e.doc.direction?s:Fl)(e.display.lineDiv,"CodeMirror-rtl")}function Qn(e){hn(e,function(){Zn(e),vn(e)})}function Jn(e){this.done=[],this.undone=[],this.undoDepth=1/0,this.lastModTime=this.lastSelTime=0,this.lastOp=this.lastSelOp=null,this.lastOrigin=this.lastSelOrigin=null,this.generation=this.maxGeneration=e||1}function ei(e,t){var r={from:z(t.from),to:Bn(t),text:N(e,t.from,t.to)};return si(e,r,t.from.line,t.to.line+1),$n(e,function(e){return si(e,r,t.from.line,t.to.line+1)},!0),r}function ti(e){for(;e.length&&g(e).ranges;)e.pop()}function ri(e,t){return t?(ti(e.done),g(e.done)):e.done.length&&!g(e.done).ranges?g(e.done):e.done.length>1&&!e.done[e.done.length-2].ranges?(e.done.pop(),g(e.done)):void 0}function ni(e,t,r,n){var i=e.history;i.undone.length=0;var o,l,s=+new Date;if((i.lastOp==n||i.lastOrigin==t.origin&&t.origin&&("+"==t.origin.charAt(0)&&e.cm&&i.lastModTime>s-e.cm.options.historyEventDelay||"*"==t.origin.charAt(0)))&&(o=ri(i,i.lastOp==n)))l=g(o.changes),0==P(t.from,t.to)&&0==P(t.from,l.to)?l.to=Bn(t):o.changes.push(ei(e,t));else{var a=g(i.done);for(a&&a.ranges||li(e.sel,i.done),o={changes:[ei(e,t)],generation:i.generation},i.done.push(o);i.done.length>i.undoDepth;)i.done.shift(),i.done[0].ranges||i.done.shift()}i.done.push(r),i.generation=++i.maxGeneration,i.lastModTime=i.lastSelTime=s,i.lastOp=i.lastSelOp=n,i.lastOrigin=i.lastSelOrigin=t.origin,l||Te(e,"historyAdded")}function ii(e,t,r,n){var i=t.charAt(0);return"*"==i||"+"==i&&r.ranges.length==n.ranges.length&&r.somethingSelected()==n.somethingSelected()&&new Date-e.history.lastSelTime<=(e.cm?e.cm.options.historyEventDelay:500)}function oi(e,t,r,n){var i=e.history,o=n&&n.origin;r==i.lastSelOp||o&&i.lastSelOrigin==o&&(i.lastModTime==i.lastSelTime&&i.lastOrigin==o||ii(e,o,g(i.done),t))?i.done[i.done.length-1]=t:li(t,i.done),i.lastSelTime=+new Date,i.lastSelOrigin=o,i.lastSelOp=r,n&&!1!==n.clearRedo&&ti(i.undone)}function li(e,t){var r=g(t);r&&r.ranges&&r.equals(e)||t.push(e)}function si(e,t,r,n){var i=t["spans_"+e.id],o=0;e.iter(Math.max(e.first,r),Math.min(e.first+e.size,n),function(r){r.markedSpans&&((i||(i=t["spans_"+e.id]={}))[o]=r.markedSpans),++o})}function ai(e){if(!e)return null;for(var t,r=0;r<e.length;++r)e[r].marker.explicitlyCleared?t||(t=e.slice(0,r)):t&&t.push(e[r]);return t?t.length?t:null:e}function ui(e,t){var r=t["spans_"+e.id];if(!r)return null;for(var n=[],i=0;i<t.text.length;++i)n.push(ai(r[i]));return n}function ci(e,t){var r=ui(e,t),n=J(e,t);if(!r)return n;if(!n)return r;for(var i=0;i<r.length;++i){var o=r[i],l=n[i];if(o&&l)e:for(var s=0;s<l.length;++s){for(var a=l[s],u=0;u<o.length;++u)if(o[u].marker==a.marker)continue e;o.push(a)}else l&&(r[i]=l)}return r}function fi(e,t,r){for(var n=[],i=0;i<e.length;++i){var o=e[i];if(o.ranges)n.push(r?ks.prototype.deepCopy.call(o):o);else{var l=o.changes,s=[];n.push({changes:s});for(var a=0;a<l.length;++a){var u=l[a],c=void 0;if(s.push({from:u.from,to:u.to,text:u.text}),t)for(var f in u)(c=f.match(/^spans_(\d+)$/))&&h(t,Number(c[1]))>-1&&(g(s)[f]=u[f],delete u[f])}}}return n}function hi(e,t,r,n){if(n){var i=e.anchor;if(r){var o=P(t,i)<0;o!=P(r,i)<0?(i=t,t=r):o!=P(t,r)<0&&(t=r)}return new Ts(i,t)}return new Ts(r||t,t)}function di(e,t,r,n,i){null==i&&(i=e.cm&&(e.cm.display.shift||e.extend)),bi(e,new ks([hi(e.sel.primary(),t,r,i)],0),n)}function pi(e,t,r){for(var n=[],i=e.cm&&(e.cm.display.shift||e.extend),o=0;o<e.sel.ranges.length;o++)n[o]=hi(e.sel.ranges[o],t[o],null,i);bi(e,zn(n,e.sel.primIndex),r)}function gi(e,t,r,n){var i=e.sel.ranges.slice(0);i[t]=r,bi(e,zn(i,e.sel.primIndex),n)}function vi(e,t,r,n){bi(e,Rn(t,r),n)}function mi(e,t,r){var n={ranges:t.ranges,update:function(t){var r=this;this.ranges=[];for(var n=0;n<t.length;n++)r.ranges[n]=new Ts(U(e,t[n].anchor),U(e,t[n].head))},origin:r&&r.origin};return Te(e,"beforeSelectionChange",e,n),e.cm&&Te(e.cm,"beforeSelectionChange",e.cm,n),n.ranges!=t.ranges?zn(n.ranges,n.ranges.length-1):t}function yi(e,t,r){var n=e.history.done,i=g(n);i&&i.ranges?(n[n.length-1]=t,wi(e,t,r)):bi(e,t,r)}function bi(e,t,r){wi(e,t,r),oi(e,e.sel,e.cm?e.cm.curOp.id:NaN,r)}function wi(e,t,r){(Oe(e,"beforeSelectionChange")||e.cm&&Oe(e.cm,"beforeSelectionChange"))&&(t=mi(e,t,r)),xi(e,Si(e,t,r&&r.bias||(P(t.primary().head,e.sel.primary().head)<0?-1:1),!0)),r&&!1===r.scroll||!e.cm||jr(e.cm)}function xi(e,t){t.equals(e.sel)||(e.sel=t,e.cm&&(e.cm.curOp.updateInput=e.cm.curOp.selectionChanged=!0,Ne(e.cm)),bt(e,"cursorActivity",e))}function Ci(e){xi(e,Si(e,e.sel,null,!1))}function Si(e,t,r,n){for(var i,o=0;o<t.ranges.length;o++){var l=t.ranges[o],s=t.ranges.length==e.sel.ranges.length&&e.sel.ranges[o],a=ki(e,l.anchor,s&&s.anchor,r,n),u=ki(e,l.head,s&&s.head,r,n);(i||a!=l.anchor||u!=l.head)&&(i||(i=t.ranges.slice(0,o)),i[o]=new Ts(a,u))}return i?zn(i,t.primIndex):t}function Li(e,t,r,n,i){var o=M(e,t.line);if(o.markedSpans)for(var l=0;l<o.markedSpans.length;++l){var s=o.markedSpans[l],a=s.marker;if((null==s.from||(a.inclusiveLeft?s.from<=t.ch:s.from<t.ch))&&(null==s.to||(a.inclusiveRight?s.to>=t.ch:s.to>t.ch))){if(i&&(Te(a,"beforeCursorEnter"),a.explicitlyCleared)){if(o.markedSpans){--l;continue}break}if(!a.atomic)continue;if(r){var u=a.find(n<0?1:-1),c=void 0;if((n<0?a.inclusiveRight:a.inclusiveLeft)&&(u=Ti(e,u,-n,u&&u.line==t.line?o:null)),u&&u.line==t.line&&(c=P(u,r))&&(n<0?c<0:c>0))return Li(e,u,t,n,i)}var f=a.find(n<0?-1:1);return(n<0?a.inclusiveLeft:a.inclusiveRight)&&(f=Ti(e,f,n,f.line==t.line?o:null)),f?Li(e,f,t,n,i):null}}return t}function ki(e,t,r,n,i){var o=n||1,l=Li(e,t,r,o,i)||!i&&Li(e,t,r,o,!0)||Li(e,t,r,-o,i)||!i&&Li(e,t,r,-o,!0);return l||(e.cantEdit=!0,E(e.first,0))}function Ti(e,t,r,n){return r<0&&0==t.ch?t.line>e.first?U(e,E(t.line-1)):null:r>0&&t.ch==(n||M(e,t.line)).text.length?t.line<e.first+e.size-1?E(t.line+1,0):null:new E(t.line,t.ch+r)}function Mi(e){e.setSelection(E(e.firstLine(),0),E(e.lastLine()),Gl)}function Ni(e,t,r){var n={canceled:!1,from:t.from,to:t.to,text:t.text,origin:t.origin,cancel:function(){return n.canceled=!0}};return r&&(n.update=function(t,r,i,o){t&&(n.from=U(e,t)),r&&(n.to=U(e,r)),i&&(n.text=i),void 0!==o&&(n.origin=o)}),Te(e,"beforeChange",e,n),e.cm&&Te(e.cm,"beforeChange",e.cm,n),n.canceled?null:{from:n.from,to:n.to,text:n.text,origin:n.origin}}function Oi(e,t,r){if(e.cm){if(!e.cm.curOp)return dn(e.cm,Oi)(e,t,r);if(e.cm.state.suppressEdits)return}if(!(Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"))||(t=Ni(e,t,!0))){var n=Yl&&!r&&te(e,t.from,t.to);if(n)for(var i=n.length-1;i>=0;--i)Ai(e,{from:n[i].from,to:n[i].to,text:i?[""]:t.text,origin:t.origin});else Ai(e,t)}}function Ai(e,t){if(1!=t.text.length||""!=t.text[0]||0!=P(t.from,t.to)){var r=Un(e,t);ni(e,t,r,e.cm?e.cm.curOp.id:NaN),Hi(e,t,r,J(e,t));var n=[];$n(e,function(e,r){r||-1!=h(n,e.history)||(zi(e.history,t),n.push(e.history)),Hi(e,t,null,J(e,t))})}}function Wi(e,t,r){if(!e.cm||!e.cm.state.suppressEdits||r){for(var n,i=e.history,o=e.sel,l="undo"==t?i.done:i.undone,s="undo"==t?i.undone:i.done,a=0;a<l.length&&(n=l[a],r?!n.ranges||n.equals(e.sel):n.ranges);a++);if(a!=l.length){for(i.lastOrigin=i.lastSelOrigin=null;(n=l.pop()).ranges;){if(li(n,s),r&&!n.equals(e.sel))return void bi(e,n,{clearRedo:!1});o=n}var u=[];li(o,s),s.push({changes:u,generation:i.generation}),i.generation=n.generation||++i.maxGeneration;for(var c=Oe(e,"beforeChange")||e.cm&&Oe(e.cm,"beforeChange"),f=n.changes.length-1;f>=0;--f){var d=function(r){var i=n.changes[r];if(i.origin=t,c&&!Ni(e,i,!1))return l.length=0,{};u.push(ei(e,i));var o=r?Un(e,i):g(l);Hi(e,i,o,ci(e,i)),!r&&e.cm&&e.cm.scrollIntoView({from:i.from,to:Bn(i)});var s=[];$n(e,function(e,t){t||-1!=h(s,e.history)||(zi(e.history,i),s.push(e.history)),Hi(e,i,null,ci(e,i))})}(f);if(d)return d.v}}}}function Di(e,t){if(0!=t&&(e.first+=t,e.sel=new ks(v(e.sel.ranges,function(e){return new Ts(E(e.anchor.line+t,e.anchor.ch),E(e.head.line+t,e.head.ch))}),e.sel.primIndex),e.cm)){vn(e.cm,e.first,e.first-t,t);for(var r=e.cm.display,n=r.viewFrom;n<r.viewTo;n++)mn(e.cm,n,"gutter")}}function Hi(e,t,r,n){if(e.cm&&!e.cm.curOp)return dn(e.cm,Hi)(e,t,r,n);if(t.to.line<e.first)Di(e,t.text.length-1-(t.to.line-t.from.line));else if(!(t.from.line>e.lastLine())){if(t.from.line<e.first){var i=t.text.length-1-(e.first-t.from.line);Di(e,i),t={from:E(e.first,0),to:E(t.to.line+i,t.to.ch),text:[g(t.text)],origin:t.origin}}var o=e.lastLine();t.to.line>o&&(t={from:t.from,to:E(o,M(e,o).text.length),text:[t.text[0]],origin:t.origin}),t.removed=N(e,t.from,t.to),r||(r=Un(e,t)),e.cm?Fi(e.cm,t,n):_n(e,t,n),wi(e,r,Gl)}}function Fi(e,t,r){var n=e.doc,i=e.display,o=t.from,l=t.to,s=!1,a=o.line;e.options.lineWrapping||(a=W(fe(M(n,o.line))),n.iter(a,l.line+1,function(e){if(e==i.maxLine)return s=!0,!0})),n.sel.contains(t.from,t.to)>-1&&Ne(e),_n(n,t,r,xr(e)),e.options.lineWrapping||(n.iter(a,o.line+t.text.length,function(e){var t=be(e);t>i.maxLineLength&&(i.maxLine=e,i.maxLineLength=t,i.maxLineChanged=!0,s=!1)}),s&&(e.curOp.updateMaxLine=!0)),nt(n,o.line),Cn(e,400);var u=t.text.length-(l.line-o.line)-1;t.full?vn(e):o.line!=l.line||1!=t.text.length||Yn(e.doc,t)?vn(e,o.line,l.line+1,u):mn(e,o.line,"text");var c=Oe(e,"changes"),f=Oe(e,"change");if(f||c){var h={from:o,to:l,text:t.text,removed:t.removed,origin:t.origin};f&&bt(e,"change",e,h),c&&(e.curOp.changeObjs||(e.curOp.changeObjs=[])).push(h)}e.display.selForContextMenu=null}function Ei(e,t,r,n,i){if(n||(n=r),P(n,r)<0){var o;r=(o=[n,r])[0],n=o[1]}"string"==typeof t&&(t=e.splitLines(t)),Oi(e,{from:r,to:n,text:t,origin:i})}function Pi(e,t,r,n){r<e.line?e.line+=n:t<e.line&&(e.line=t,e.ch=0)}function Ii(e,t,r,n){for(var i=0;i<e.length;++i){var o=e[i],l=!0;if(o.ranges){o.copied||((o=e[i]=o.deepCopy()).copied=!0);for(var s=0;s<o.ranges.length;s++)Pi(o.ranges[s].anchor,t,r,n),Pi(o.ranges[s].head,t,r,n)}else{for(var a=0;a<o.changes.length;++a){var u=o.changes[a];if(r<u.from.line)u.from=E(u.from.line+n,u.from.ch),u.to=E(u.to.line+n,u.to.ch);else if(t<=u.to.line){l=!1;break}}l||(e.splice(0,i+1),i=0)}}}function zi(e,t){var r=t.from.line,n=t.to.line,i=t.text.length-(n-r)-1;Ii(e.done,r,n,i),Ii(e.undone,r,n,i)}function Ri(e,t,r,n){var i=t,o=t;return"number"==typeof t?o=M(e,G(e,t)):i=W(t),null==i?null:(n(o,i)&&e.cm&&mn(e.cm,i,r),o)}function Bi(e){var t=this;this.lines=e,this.parent=null;for(var r=0,n=0;n<e.length;++n)e[n].parent=t,r+=e[n].height;this.height=r}function Gi(e){var t=this;this.children=e;for(var r=0,n=0,i=0;i<e.length;++i){var o=e[i];r+=o.chunkSize(),n+=o.height,o.parent=t}this.size=r,this.height=n,this.parent=null}function Ui(e,t,r){ye(t)<(e.curOp&&e.curOp.scrollTop||e.doc.scrollTop)&&Kr(e,r)}function Vi(e,t,r,n){var i=new Ms(e,r,n),o=e.cm;return o&&i.noHScroll&&(o.display.alignWidgets=!0),Ri(e,t,"widget",function(t){var r=t.widgets||(t.widgets=[]);if(null==i.insertAt?r.push(i):r.splice(Math.min(r.length-1,Math.max(0,i.insertAt)),0,i),i.line=t,o&&!ve(e,t)){var n=ye(t)<e.scrollTop;A(t,t.height+Ht(i)),n&&Kr(o,i.height),o.curOp.forceUpdate=!0}return!0}),bt(o,"lineWidgetAdded",o,i,"number"==typeof t?t:W(t)),i}function Ki(e,t,r,n,o){if(n&&n.shared)return ji(e,t,r,n,o);if(e.cm&&!e.cm.curOp)return dn(e.cm,Ki)(e,t,r,n,o);var l=new Os(e,o),s=P(t,r);if(n&&c(n,l,!1),s>0||0==s&&!1!==l.clearWhenEmpty)return l;if(l.replacedWith&&(l.collapsed=!0,l.widgetNode=i("span",[l.replacedWith],"CodeMirror-widget"),n.handleMouseEvents||l.widgetNode.setAttribute("cm-ignore-events","true"),n.insertLeft&&(l.widgetNode.insertLeft=!0)),l.collapsed){if(ce(e,t.line,t,r,l)||t.line!=r.line&&ce(e,r.line,t,r,l))throw new Error("Inserting collapsed marker partially overlapping an existing one");X()}l.addToHistory&&ni(e,{from:t,to:r,origin:"markText"},e.sel,NaN);var a,u=t.line,f=e.cm;if(e.iter(u,r.line+1,function(e){f&&l.collapsed&&!f.options.lineWrapping&&fe(e)==f.display.maxLine&&(a=!0),l.collapsed&&u!=t.line&&A(e,0),q(e,new Y(l,u==t.line?t.ch:null,u==r.line?r.ch:null)),++u}),l.collapsed&&e.iter(t.line,r.line+1,function(t){ve(e,t)&&A(t,0)}),l.clearOnEnter&&Ql(l,"beforeCursorEnter",function(){return l.clear()}),l.readOnly&&(j(),(e.history.done.length||e.history.undone.length)&&e.clearHistory()),l.collapsed&&(l.id=++Ns,l.atomic=!0),f){if(a&&(f.curOp.updateMaxLine=!0),l.collapsed)vn(f,t.line,r.line+1);else if(l.className||l.title||l.startStyle||l.endStyle||l.css)for(var h=t.line;h<=r.line;h++)mn(f,h,"text");l.atomic&&Ci(f.doc),bt(f,"markerAdded",f,l)}return l}function ji(e,t,r,n,i){(n=c(n)).shared=!1;var o=[Ki(e,t,r,n,i)],l=o[0],s=n.widgetNode;return $n(e,function(e){s&&(n.widgetNode=s.cloneNode(!0)),o.push(Ki(e,U(e,t),U(e,r),n,i));for(var a=0;a<e.linked.length;++a)if(e.linked[a].isParent)return;l=g(o)}),new As(o,l)}function Xi(e){return e.findMarks(E(e.first,0),e.clipPos(E(e.lastLine())),function(e){return e.parent})}function Yi(e,t){for(var r=0;r<t.length;r++){var n=t[r],i=n.find(),o=e.clipPos(i.from),l=e.clipPos(i.to);if(P(o,l)){var s=Ki(e,o,l,n.primary,n.primary.type);n.markers.push(s),s.parent=n}}}function _i(e){for(var t=0;t<e.length;t++)!function(t){var r=e[t],n=[r.primary.doc];$n(r.primary.doc,function(e){return n.push(e)});for(var i=0;i<r.markers.length;i++){var o=r.markers[i];-1==h(n,o.doc)&&(o.parent=null,r.markers.splice(i--,1))}}(t)}function $i(e){var t=this;if(Qi(t),!Me(t,e)&&!Ft(t.display,e)){We(e),gl&&(Hs=+new Date);var r=Sr(t,e,!0),n=e.dataTransfer.files;if(r&&!t.isReadOnly())if(n&&n.length&&window.FileReader&&window.File)for(var i=n.length,o=Array(i),l=0,s=0;s<i;++s)!function(e,n){if(!t.options.allowDropFileTypes||-1!=h(t.options.allowDropFileTypes,e.type)){var s=new FileReader;s.onload=dn(t,function(){var e=s.result;if(/[\x00-\x08\x0e-\x1f]{2}/.test(e)&&(e=""),o[n]=e,++l==i){var a={from:r=U(t.doc,r),to:r,text:t.doc.splitLines(o.join(t.doc.lineSeparator())),origin:"paste"};Oi(t.doc,a),yi(t.doc,Rn(r,Bn(a)))}}),s.readAsText(e)}}(n[s],s);else{if(t.state.draggingText&&t.doc.sel.contains(r)>-1)return t.state.draggingText(e),void setTimeout(function(){return t.display.input.focus()},20);try{var a=e.dataTransfer.getData("Text");if(a){var u;if(t.state.draggingText&&!t.state.draggingText.copy&&(u=t.listSelections()),wi(t.doc,Rn(r,r)),u)for(var c=0;c<u.length;++c)Ei(t.doc,"",u[c].anchor,u[c].head,"drag");t.replaceSelection(a,"around","paste"),t.display.input.focus()}}catch(e){}}}}function qi(e,t){if(gl&&(!e.state.draggingText||+new Date-Hs<100))Fe(t);else if(!Me(e,t)&&!Ft(e.display,t)&&(t.dataTransfer.setData("Text",e.getSelection()),t.dataTransfer.effectAllowed="copyMove",t.dataTransfer.setDragImage&&!xl)){var r=n("img",null,null,"position: fixed; left: 0; top: 0;");r.src="data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==",wl&&(r.width=r.height=1,e.display.wrapper.appendChild(r),r._top=r.offsetTop),t.dataTransfer.setDragImage(r,0,0),wl&&r.parentNode.removeChild(r)}}function Zi(e,t){var i=Sr(e,t);if(i){var o=document.createDocumentFragment();Mr(e,i,o),e.display.dragCursor||(e.display.dragCursor=n("div",null,"CodeMirror-cursors CodeMirror-dragcursors"),e.display.lineSpace.insertBefore(e.display.dragCursor,e.display.cursorDiv)),r(e.display.dragCursor,o)}}function Qi(e){e.display.dragCursor&&(e.display.lineSpace.removeChild(e.display.dragCursor),e.display.dragCursor=null)}function Ji(e){if(document.getElementsByClassName)for(var t=document.getElementsByClassName("CodeMirror"),r=0;r<t.length;r++){var n=t[r].CodeMirror;n&&e(n)}}function eo(){Fs||(to(),Fs=!0)}function to(){var e;Ql(window,"resize",function(){null==e&&(e=setTimeout(function(){e=null,Ji(ro)},100))}),Ql(window,"blur",function(){return Ji(Fr)})}function ro(e){var t=e.display;t.lastWrapHeight==t.wrapper.clientHeight&&t.lastWrapWidth==t.wrapper.clientWidth||(t.cachedCharWidth=t.cachedTextHeight=t.cachedPaddingH=null,t.scrollbarsClipped=!1,e.setSize())}function no(e){var t=e.split(/-(?!$)/);e=t[t.length-1];for(var r,n,i,o,l=0;l<t.length-1;l++){var s=t[l];if(/^(cmd|meta|m)$/i.test(s))o=!0;else if(/^a(lt)?$/i.test(s))r=!0;else if(/^(c|ctrl|control)$/i.test(s))n=!0;else{if(!/^s(hift)?$/i.test(s))throw new Error("Unrecognized modifier name: "+s);i=!0}}return r&&(e="Alt-"+e),n&&(e="Ctrl-"+e),o&&(e="Cmd-"+e),i&&(e="Shift-"+e),e}function io(e){var t={};for(var r in e)if(e.hasOwnProperty(r)){var n=e[r];if(/^(name|fallthrough|(de|at)tach)$/.test(r))continue;if("..."==n){delete e[r];continue}for(var i=v(r.split(" "),no),o=0;o<i.length;o++){var l=void 0,s=void 0;o==i.length-1?(s=i.join(" "),l=n):(s=i.slice(0,o+1).join(" "),l="...");var a=t[s];if(a){if(a!=l)throw new Error("Inconsistent bindings for "+s)}else t[s]=l}delete e[r]}for(var u in t)e[u]=t[u];return e}function oo(e,t,r,n){var i=(t=uo(t)).call?t.call(e,n):t[e];if(!1===i)return"nothing";if("..."===i)return"multi";if(null!=i&&r(i))return"handled";if(t.fallthrough){if("[object Array]"!=Object.prototype.toString.call(t.fallthrough))return oo(e,t.fallthrough,r,n);for(var o=0;o<t.fallthrough.length;o++){var l=oo(e,t.fallthrough[o],r,n);if(l)return l}}}function lo(e){var t="string"==typeof e?e:Es[e.keyCode];return"Ctrl"==t||"Alt"==t||"Shift"==t||"Mod"==t}function so(e,t,r){var n=e;return t.altKey&&"Alt"!=n&&(e="Alt-"+e),(Dl?t.metaKey:t.ctrlKey)&&"Ctrl"!=n&&(e="Ctrl-"+e),(Dl?t.ctrlKey:t.metaKey)&&"Cmd"!=n&&(e="Cmd-"+e),!r&&t.shiftKey&&"Shift"!=n&&(e="Shift-"+e),e}function ao(e,t){if(wl&&34==e.keyCode&&e.char)return!1;var r=Es[e.keyCode];return null!=r&&!e.altGraphKey&&so(r,e,t)}function uo(e){return"string"==typeof e?Rs[e]:e}function co(e,t){for(var r=e.doc.sel.ranges,n=[],i=0;i<r.length;i++){for(var o=t(r[i]);n.length&&P(o.from,g(n).to)<=0;){var l=n.pop();if(P(l.from,o.from)<0){o.from=l.from;break}}n.push(o)}hn(e,function(){for(var t=n.length-1;t>=0;t--)Ei(e.doc,"",n[t].from,n[t].to,"+delete");jr(e)})}function fo(e,t,r){var n=L(e.text,t+r,r);return n<0||n>e.text.length?null:n}function ho(e,t,r){var n=fo(e,t.ch,r);return null==n?null:new E(t.line,n,r<0?"after":"before")}function po(e,t,r,n,i){if(e){var o=Se(r,t.doc.direction);if(o){var l,s=i<0?g(o):o[0],a=i<0==(1==s.level)?"after":"before";if(s.level>0){var u=Xt(t,r);l=i<0?r.text.length-1:0;var c=Yt(t,u,l).top;l=k(function(e){return Yt(t,u,e).top==c},i<0==(1==s.level)?s.from:s.to-1,l),"before"==a&&(l=fo(r,l,1))}else l=i<0?s.to:s.from;return new E(n,l,a)}}return new E(n,i<0?r.text.length:0,i<0?"before":"after")}function go(e,t,r,n){var i=Se(t,e.doc.direction);if(!i)return ho(t,r,n);r.ch>=t.text.length?(r.ch=t.text.length,r.sticky="before"):r.ch<=0&&(r.ch=0,r.sticky="after");var o=Ce(i,r.ch,r.sticky),l=i[o];if("ltr"==e.doc.direction&&l.level%2==0&&(n>0?l.to>r.ch:l.from<r.ch))return ho(t,r,n);var s,a=function(e,r){return fo(t,e instanceof E?e.ch:e,r)},u=function(r){return e.options.lineWrapping?(s=s||Xt(e,t),hr(e,t,s,r)):{begin:0,end:t.text.length}},c=u("before"==r.sticky?a(r,-1):r.ch);if("rtl"==e.doc.direction||1==l.level){var f=1==l.level==n<0,h=a(r,f?1:-1);if(null!=h&&(f?h<=l.to&&h<=c.end:h>=l.from&&h>=c.begin)){var d=f?"before":"after";return new E(r.line,h,d)}}var p=function(e,t,n){for(var o=function(e,t){return t?new E(r.line,a(e,1),"before"):new E(r.line,e,"after")};e>=0&&e<i.length;e+=t){var l=i[e],s=t>0==(1!=l.level),u=s?n.begin:a(n.end,-1);if(l.from<=u&&u<l.to)return o(u,s);if(u=s?l.from:a(l.to,-1),n.begin<=u&&u<n.end)return o(u,s)}},g=p(o+n,n,c);if(g)return g;var v=n>0?c.end:a(c.begin,-1);return null==v||n>0&&v==t.text.length||!(g=p(n>0?0:i.length-1,n,u(v)))?null:g}function vo(e,t){var r=M(e.doc,t),n=fe(r);return n!=r&&(t=W(n)),po(!0,e,n,t,1)}function mo(e,t){var r=M(e.doc,t),n=he(r);return n!=r&&(t=W(n)),po(!0,e,r,t,-1)}function yo(e,t){var r=vo(e,t.line),n=M(e.doc,r.line),i=Se(n,e.doc.direction);if(!i||0==i[0].level){var o=Math.max(0,n.text.search(/\S/)),l=t.line==r.line&&t.ch<=o&&t.ch;return E(r.line,l?0:o,r.sticky)}return r}function bo(e,t,r){if("string"==typeof t&&!(t=Bs[t]))return!1;e.display.input.ensurePolled();var n=e.display.shift,i=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),r&&(e.display.shift=!1),i=t(e)!=Bl}finally{e.display.shift=n,e.state.suppressEdits=!1}return i}function wo(e,t,r){for(var n=0;n<e.state.keyMaps.length;n++){var i=oo(t,e.state.keyMaps[n],r,e);if(i)return i}return e.options.extraKeys&&oo(t,e.options.extraKeys,r,e)||oo(t,e.options.keyMap,r,e)}function xo(e,t,r,n){var i=e.state.keySeq;if(i){if(lo(t))return"handled";Gs.set(50,function(){e.state.keySeq==i&&(e.state.keySeq=null,e.display.input.reset())}),t=i+" "+t}var o=wo(e,t,n);return"multi"==o&&(e.state.keySeq=t),"handled"==o&&bt(e,"keyHandled",e,t,r),"handled"!=o&&"multi"!=o||(We(r),Ar(e)),i&&!o&&/\'$/.test(t)?(We(r),!0):!!o}function Co(e,t){var r=ao(t,!0);return!!r&&(t.shiftKey&&!e.state.keySeq?xo(e,"Shift-"+r,t,function(t){return bo(e,t,!0)})||xo(e,r,t,function(t){if("string"==typeof t?/^go[A-Z]/.test(t):t.motion)return bo(e,t)}):xo(e,r,t,function(t){return bo(e,t)}))}function So(e,t,r){return xo(e,"'"+r+"'",t,function(t){return bo(e,t,!0)})}function Lo(e){var t=this;if(t.curOp.focus=l(),!Me(t,e)){gl&&vl<11&&27==e.keyCode&&(e.returnValue=!1);var r=e.keyCode;t.display.shift=16==r||e.shiftKey;var n=Co(t,e);wl&&(Us=n?r:null,!n&&88==r&&!rs&&(Ml?e.metaKey:e.ctrlKey)&&t.replaceSelection("",null,"cut")),18!=r||/\bCodeMirror-crosshair\b/.test(t.display.lineDiv.className)||ko(t)}}function ko(e){function t(e){18!=e.keyCode&&e.altKey||(Fl(r,"CodeMirror-crosshair"),ke(document,"keyup",t),ke(document,"mouseover",t))}var r=e.display.lineDiv;s(r,"CodeMirror-crosshair"),Ql(document,"keyup",t),Ql(document,"mouseover",t)}function To(e){16==e.keyCode&&(this.doc.sel.shift=!1),Me(this,e)}function Mo(e){var t=this;if(!(Ft(t.display,e)||Me(t,e)||e.ctrlKey&&!e.altKey||Ml&&e.metaKey)){var r=e.keyCode,n=e.charCode;if(wl&&r==Us)return Us=null,void We(e);if(!wl||e.which&&!(e.which<10)||!Co(t,e)){var i=String.fromCharCode(null==n?r:n);"\b"!=i&&(So(t,e,i)||t.display.input.onKeyPress(e))}}}function No(e,t){var r=+new Date;return js&&js.compare(r,e,t)?(Ks=js=null,"triple"):Ks&&Ks.compare(r,e,t)?(js=new Vs(r,e,t),Ks=null,"double"):(Ks=new Vs(r,e,t),js=null,"single")}function Oo(e){var t=this,r=t.display;if(!(Me(t,e)||r.activeTouch&&r.input.supportsTouch()))if(r.input.ensurePolled(),r.shift=e.shiftKey,Ft(r,e))ml||(r.scroller.draggable=!1,setTimeout(function(){return r.scroller.draggable=!0},100));else if(!zo(t,e)){var n=Sr(t,e),i=Pe(e),o=n?No(n,i):"single";window.focus(),1==i&&t.state.selectingText&&t.state.selectingText(e),n&&Ao(t,i,n,o,e)||(1==i?n?Do(t,n,o,e):Ee(e)==r.scroller&&We(e):2==i?(n&&di(t.doc,n),setTimeout(function(){return r.input.focus()},20)):3==i&&(Hl?Ro(t,e):Dr(t)))}}function Ao(e,t,r,n,i){var o="Click";return"double"==n?o="Double"+o:"triple"==n&&(o="Triple"+o),o=(1==t?"Left":2==t?"Middle":"Right")+o,xo(e,so(o,i),i,function(t){if("string"==typeof t&&(t=Bs[t]),!t)return!1;var n=!1;try{e.isReadOnly()&&(e.state.suppressEdits=!0),n=t(e,r)!=Bl}finally{e.state.suppressEdits=!1}return n})}function Wo(e,t,r){var n=e.getOption("configureMouse"),i=n?n(e,t,r):{};if(null==i.unit){var o=Nl?r.shiftKey&&r.metaKey:r.altKey;i.unit=o?"rectangle":"single"==t?"char":"double"==t?"word":"line"}return(null==i.extend||e.doc.extend)&&(i.extend=e.doc.extend||r.shiftKey),null==i.addNew&&(i.addNew=Ml?r.metaKey:r.ctrlKey),null==i.moveOnDrag&&(i.moveOnDrag=!(Ml?r.altKey:r.ctrlKey)),i}function Do(e,t,r,n){gl?setTimeout(u(Wr,e),0):e.curOp.focus=l();var i,o=Wo(e,r,n),s=e.doc.sel;e.options.dragDrop&&Jl&&!e.isReadOnly()&&"single"==r&&(i=s.contains(t))>-1&&(P((i=s.ranges[i]).from(),t)<0||t.xRel>0)&&(P(i.to(),t)>0||t.xRel<0)?Ho(e,n,t,o):Eo(e,n,t,o)}function Ho(e,t,r,n){var i=e.display,o=!1,l=dn(e,function(t){ml&&(i.scroller.draggable=!1),e.state.draggingText=!1,ke(document,"mouseup",l),ke(document,"mousemove",s),ke(i.scroller,"dragstart",a),ke(i.scroller,"drop",l),o||(We(t),n.addNew||di(e.doc,r,null,null,n.extend),ml||gl&&9==vl?setTimeout(function(){document.body.focus(),i.input.focus()},20):i.input.focus())}),s=function(e){o=o||Math.abs(t.clientX-e.clientX)+Math.abs(t.clientY-e.clientY)>=10},a=function(){return o=!0};ml&&(i.scroller.draggable=!0),e.state.draggingText=l,l.copy=!n.moveOnDrag,i.scroller.dragDrop&&i.scroller.dragDrop(),Ql(document,"mouseup",l),Ql(document,"mousemove",s),Ql(i.scroller,"dragstart",a),Ql(i.scroller,"drop",l),Dr(e),setTimeout(function(){return i.input.focus()},20)}function Fo(e,t,r){if("char"==r)return new Ts(t,t);if("word"==r)return e.findWordAt(t);if("line"==r)return new Ts(E(t.line,0),U(e.doc,E(t.line+1,0)));var n=r(e,t);return new Ts(n.from,n.to)}function Eo(e,t,r,n){function i(t){if(0!=P(m,t))if(m=t,"rectangle"==n.unit){for(var i=[],o=e.options.tabSize,l=f(M(u,r.line).text,r.ch,o),s=f(M(u,t.line).text,t.ch,o),a=Math.min(l,s),g=Math.max(l,s),v=Math.min(r.line,t.line),y=Math.min(e.lastLine(),Math.max(r.line,t.line));v<=y;v++){var b=M(u,v).text,w=d(b,a,o);a==g?i.push(new Ts(E(v,w),E(v,w))):b.length>w&&i.push(new Ts(E(v,w),E(v,d(b,g,o))))}i.length||i.push(new Ts(r,r)),bi(u,zn(p.ranges.slice(0,h).concat(i),h),{origin:"*mouse",scroll:!1}),e.scrollIntoView(t)}else{var x,C=c,S=Fo(e,t,n.unit),L=C.anchor;P(S.anchor,L)>0?(x=S.head,L=B(C.from(),S.anchor)):(x=S.anchor,L=R(C.to(),S.head));var k=p.ranges.slice(0);k[h]=Po(e,new Ts(U(u,L),x)),bi(u,zn(k,h),Ul)}}function o(t){var r=++b,s=Sr(e,t,!0,"rectangle"==n.unit);if(s)if(0!=P(s,m)){e.curOp.focus=l(),i(s);var c=Ir(a,u);(s.line>=c.to||s.line<c.from)&&setTimeout(dn(e,function(){b==r&&o(t)}),150)}else{var f=t.clientY<y.top?-20:t.clientY>y.bottom?20:0;f&&setTimeout(dn(e,function(){b==r&&(a.scroller.scrollTop+=f,o(t))}),50)}}function s(t){e.state.selectingText=!1,b=1/0,We(t),a.input.focus(),ke(document,"mousemove",w),ke(document,"mouseup",x),u.history.lastSelOrigin=null}var a=e.display,u=e.doc;We(t);var c,h,p=u.sel,g=p.ranges;if(n.addNew&&!n.extend?(h=u.sel.contains(r),c=h>-1?g[h]:new Ts(r,r)):(c=u.sel.primary(),h=u.sel.primIndex),"rectangle"==n.unit)n.addNew||(c=new Ts(r,r)),r=Sr(e,t,!0,!0),h=-1;else{var v=Fo(e,r,n.unit);c=n.extend?hi(c,v.anchor,v.head,n.extend):v}n.addNew?-1==h?(h=g.length,bi(u,zn(g.concat([c]),h),{scroll:!1,origin:"*mouse"})):g.length>1&&g[h].empty()&&"char"==n.unit&&!n.extend?(bi(u,zn(g.slice(0,h).concat(g.slice(h+1)),0),{scroll:!1,origin:"*mouse"}),p=u.sel):gi(u,h,c,Ul):(h=0,bi(u,new ks([c],0),Ul),p=u.sel);var m=r,y=a.wrapper.getBoundingClientRect(),b=0,w=dn(e,function(e){Pe(e)?o(e):s(e)}),x=dn(e,s);e.state.selectingText=x,Ql(document,"mousemove",w),Ql(document,"mouseup",x)}function Po(e,t){var r=t.anchor,n=t.head,i=M(e.doc,r.line);if(0==P(r,n)&&r.sticky==n.sticky)return t;var o=Se(i);if(!o)return t;var l=Ce(o,r.ch,r.sticky),s=o[l];if(s.from!=r.ch&&s.to!=r.ch)return t;var a=l+(s.from==r.ch==(1!=s.level)?0:1);if(0==a||a==o.length)return t;var u;if(n.line!=r.line)u=(n.line-r.line)*("ltr"==e.doc.direction?1:-1)>0;else{var c=Ce(o,n.ch,n.sticky),f=c-l||(n.ch-r.ch)*(1==s.level?-1:1);u=c==a-1||c==a?f<0:f>0}var h=o[a+(u?-1:0)],d=u==(1==h.level),p=d?h.from:h.to,g=d?"after":"before";return r.ch==p&&r.sticky==g?t:new Ts(new E(r.line,p,g),n)}function Io(e,t,r,n){var i,o;if(t.touches)i=t.touches[0].clientX,o=t.touches[0].clientY;else try{i=t.clientX,o=t.clientY}catch(t){return!1}if(i>=Math.floor(e.display.gutters.getBoundingClientRect().right))return!1;n&&We(t);var l=e.display,s=l.lineDiv.getBoundingClientRect();if(o>s.bottom||!Oe(e,r))return He(t);o-=s.top-l.viewOffset;for(var a=0;a<e.options.gutters.length;++a){var u=l.gutters.childNodes[a];if(u&&u.getBoundingClientRect().right>=i)return Te(e,r,e,D(e.doc,o),e.options.gutters[a],t),He(t)}}function zo(e,t){return Io(e,t,"gutterClick",!0)}function Ro(e,t){Ft(e.display,t)||Bo(e,t)||Me(e,t,"contextmenu")||e.display.input.onContextMenu(t)}function Bo(e,t){return!!Oe(e,"gutterContextMenu")&&Io(e,t,"gutterContextMenu",!1)}function Go(e){e.display.wrapper.className=e.display.wrapper.className.replace(/\s*cm-s-\S+/g,"")+e.options.theme.replace(/(^|\s)\s*/g," cm-s-"),er(e)}function Uo(e){Hn(e),vn(e),zr(e)}function Vo(e,t,r){if(!t!=!(r&&r!=Xs)){var n=e.display.dragFunctions,i=t?Ql:ke;i(e.display.scroller,"dragstart",n.start),i(e.display.scroller,"dragenter",n.enter),i(e.display.scroller,"dragover",n.over),i(e.display.scroller,"dragleave",n.leave),i(e.display.scroller,"drop",n.drop)}}function Ko(e){e.options.lineWrapping?(s(e.display.wrapper,"CodeMirror-wrap"),e.display.sizer.style.minWidth="",e.display.sizerWidth=null):(Fl(e.display.wrapper,"CodeMirror-wrap"),we(e)),Cr(e),vn(e),er(e),setTimeout(function(){return en(e)},100)}function jo(e,t){var r=this;if(!(this instanceof jo))return new jo(e,t);this.options=t=t?c(t):{},c(Ys,t,!1),Fn(t);var n=t.value;"string"==typeof n&&(n=new Ds(n,t.mode,null,t.lineSeparator,t.direction)),this.doc=n;var i=new jo.inputStyles[t.inputStyle](this),o=this.display=new T(e,n,i);o.wrapper.CodeMirror=this,Hn(this),Go(this),t.lineWrapping&&(this.display.wrapper.className+=" CodeMirror-wrap"),rn(this),this.state={keyMaps:[],overlays:[],modeGen:0,overwrite:!1,delayingBlurEvent:!1,focused:!1,suppressEdits:!1,pasteIncoming:!1,cutIncoming:!1,selectingText:!1,draggingText:!1,highlight:new Pl,keySeq:null,specialChars:null},t.autofocus&&!Tl&&o.input.focus(),gl&&vl<11&&setTimeout(function(){return r.display.input.reset(!0)},20),Xo(this),eo(),nn(this),this.curOp.forceUpdate=!0,qn(this,n),t.autofocus&&!Tl||this.hasFocus()?setTimeout(u(Hr,this),20):Fr(this);for(var l in _s)_s.hasOwnProperty(l)&&_s[l](r,t[l],Xs);Rr(this),t.finishInit&&t.finishInit(this);for(var s=0;s<$s.length;++s)$s[s](r);on(this),ml&&t.lineWrapping&&"optimizelegibility"==getComputedStyle(o.lineDiv).textRendering&&(o.lineDiv.style.textRendering="auto")}function Xo(e){function t(){i.activeTouch&&(o=setTimeout(function(){return i.activeTouch=null},1e3),(l=i.activeTouch).end=+new Date)}function r(e){if(1!=e.touches.length)return!1;var t=e.touches[0];return t.radiusX<=1&&t.radiusY<=1}function n(e,t){if(null==t.left)return!0;var r=t.left-e.left,n=t.top-e.top;return r*r+n*n>400}var i=e.display;Ql(i.scroller,"mousedown",dn(e,Oo)),gl&&vl<11?Ql(i.scroller,"dblclick",dn(e,function(t){if(!Me(e,t)){var r=Sr(e,t);if(r&&!zo(e,t)&&!Ft(e.display,t)){We(t);var n=e.findWordAt(r);di(e.doc,n.anchor,n.head)}}})):Ql(i.scroller,"dblclick",function(t){return Me(e,t)||We(t)}),Hl||Ql(i.scroller,"contextmenu",function(t){return Ro(e,t)});var o,l={end:0};Ql(i.scroller,"touchstart",function(t){if(!Me(e,t)&&!r(t)&&!zo(e,t)){i.input.ensurePolled(),clearTimeout(o);var n=+new Date;i.activeTouch={start:n,moved:!1,prev:n-l.end<=300?l:null},1==t.touches.length&&(i.activeTouch.left=t.touches[0].pageX,i.activeTouch.top=t.touches[0].pageY)}}),Ql(i.scroller,"touchmove",function(){i.activeTouch&&(i.activeTouch.moved=!0)}),Ql(i.scroller,"touchend",function(r){var o=i.activeTouch;if(o&&!Ft(i,r)&&null!=o.left&&!o.moved&&new Date-o.start<300){var l,s=e.coordsChar(i.activeTouch,"page");l=!o.prev||n(o,o.prev)?new Ts(s,s):!o.prev.prev||n(o,o.prev.prev)?e.findWordAt(s):new Ts(E(s.line,0),U(e.doc,E(s.line+1,0))),e.setSelection(l.anchor,l.head),e.focus(),We(r)}t()}),Ql(i.scroller,"touchcancel",t),Ql(i.scroller,"scroll",function(){i.scroller.clientHeight&&(qr(e,i.scroller.scrollTop),Qr(e,i.scroller.scrollLeft,!0),Te(e,"scroll",e))}),Ql(i.scroller,"mousewheel",function(t){return In(e,t)}),Ql(i.scroller,"DOMMouseScroll",function(t){return In(e,t)}),Ql(i.wrapper,"scroll",function(){return i.wrapper.scrollTop=i.wrapper.scrollLeft=0}),i.dragFunctions={enter:function(t){Me(e,t)||Fe(t)},over:function(t){Me(e,t)||(Zi(e,t),Fe(t))},start:function(t){return qi(e,t)},drop:dn(e,$i),leave:function(t){Me(e,t)||Qi(e)}};var s=i.input.getField();Ql(s,"keyup",function(t){return To.call(e,t)}),Ql(s,"keydown",dn(e,Lo)),Ql(s,"keypress",dn(e,Mo)),Ql(s,"focus",function(t){return Hr(e,t)}),Ql(s,"blur",function(t){return Fr(e,t)})}function Yo(e,t,r,n){var i,o=e.doc;null==r&&(r="add"),"smart"==r&&(o.mode.indent?i=$e(e,t).state:r="prev");var l=e.options.tabSize,s=M(o,t),a=f(s.text,null,l);s.stateAfter&&(s.stateAfter=null);var u,c=s.text.match(/^\s*/)[0];if(n||/\S/.test(s.text)){if("smart"==r&&((u=o.mode.indent(i,s.text.slice(c.length),s.text))==Bl||u>150)){if(!n)return;r="prev"}}else u=0,r="not";"prev"==r?u=t>o.first?f(M(o,t-1).text,null,l):0:"add"==r?u=a+e.options.indentUnit:"subtract"==r?u=a-e.options.indentUnit:"number"==typeof r&&(u=a+r),u=Math.max(0,u);var h="",d=0;if(e.options.indentWithTabs)for(var g=Math.floor(u/l);g;--g)d+=l,h+="\t";if(d<u&&(h+=p(u-d)),h!=c)return Ei(o,h,E(t,0),E(t,c.length),"+input"),s.stateAfter=null,!0;for(var v=0;v<o.sel.ranges.length;v++){var m=o.sel.ranges[v];if(m.head.line==t&&m.head.ch<c.length){var y=E(t,c.length);gi(o,v,new Ts(y,y));break}}}function _o(e){qs=e}function $o(e,t,r,n,i){var o=e.doc;e.display.shift=!1,n||(n=o.sel);var l=e.state.pasteIncoming||"paste"==i,s=es(t),a=null;if(l&&n.ranges.length>1)if(qs&&qs.text.join("\n")==t){if(n.ranges.length%qs.text.length==0){a=[];for(var u=0;u<qs.text.length;u++)a.push(o.splitLines(qs.text[u]))}}else s.length==n.ranges.length&&e.options.pasteLinesPerSelection&&(a=v(s,function(e){return[e]}));for(var c,f=n.ranges.length-1;f>=0;f--){var h=n.ranges[f],d=h.from(),p=h.to();h.empty()&&(r&&r>0?d=E(d.line,d.ch-r):e.state.overwrite&&!l?p=E(p.line,Math.min(M(o,p.line).text.length,p.ch+g(s).length)):qs&&qs.lineWise&&qs.text.join("\n")==t&&(d=p=E(d.line,0))),c=e.curOp.updateInput;var m={from:d,to:p,text:a?a[f%a.length]:s,origin:i||(l?"paste":e.state.cutIncoming?"cut":"+input")};Oi(e.doc,m),bt(e,"inputRead",e,m)}t&&!l&&Zo(e,t),jr(e),e.curOp.updateInput=c,e.curOp.typing=!0,e.state.pasteIncoming=e.state.cutIncoming=!1}function qo(e,t){var r=e.clipboardData&&e.clipboardData.getData("Text");if(r)return e.preventDefault(),t.isReadOnly()||t.options.disableInput||hn(t,function(){return $o(t,r,0,null,"paste")}),!0}function Zo(e,t){if(e.options.electricChars&&e.options.smartIndent)for(var r=e.doc.sel,n=r.ranges.length-1;n>=0;n--){var i=r.ranges[n];if(!(i.head.ch>100||n&&r.ranges[n-1].head.line==i.head.line)){var o=e.getModeAt(i.head),l=!1;if(o.electricChars){for(var s=0;s<o.electricChars.length;s++)if(t.indexOf(o.electricChars.charAt(s))>-1){l=Yo(e,i.head.line,"smart");break}}else o.electricInput&&o.electricInput.test(M(e.doc,i.head.line).text.slice(0,i.head.ch))&&(l=Yo(e,i.head.line,"smart"));l&&bt(e,"electricInput",e,i.head.line)}}}function Qo(e){for(var t=[],r=[],n=0;n<e.doc.sel.ranges.length;n++){var i=e.doc.sel.ranges[n].head.line,o={anchor:E(i,0),head:E(i+1,0)};r.push(o),t.push(e.getRange(o.anchor,o.head))}return{text:t,ranges:r}}function Jo(e,t){e.setAttribute("autocorrect","off"),e.setAttribute("autocapitalize","off"),e.setAttribute("spellcheck",!!t)}function el(){var e=n("textarea",null,null,"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none"),t=n("div",[e],null,"overflow: hidden; position: relative; width: 3px; height: 0px;");return ml?e.style.width="1000px":e.setAttribute("wrap","off"),Ll&&(e.style.border="1px solid black"),Jo(e),t}function tl(e,t,r,n,i){function o(){var n=t.line+r;return!(n<e.first||n>=e.first+e.size)&&(t=new E(n,t.ch,t.sticky),u=M(e,n))}function l(n){var l;if(null==(l=i?go(e.cm,u,t,r):ho(u,t,r))){if(n||!o())return!1;t=po(i,e.cm,u,t.line,r)}else t=l;return!0}var s=t,a=r,u=M(e,t.line);if("char"==n)l();else if("column"==n)l(!0);else if("word"==n||"group"==n)for(var c=null,f="group"==n,h=e.cm&&e.cm.getHelper(t,"wordChars"),d=!0;!(r<0)||l(!d);d=!1){var p=u.text.charAt(t.ch)||"\n",g=x(p,h)?"w":f&&"\n"==p?"n":!f||/\s/.test(p)?null:"p";if(!f||d||g||(g="s"),c&&c!=g){r<0&&(r=1,l(),t.sticky="after");break}if(g&&(c=g),r>0&&!l(!d))break}var v=ki(e,t,s,a,!0);return I(s,v)&&(v.hitSide=!0),v}function rl(e,t,r,n){var i,o=e.doc,l=t.left;if("page"==n){var s=Math.min(e.display.wrapper.clientHeight,window.innerHeight||document.documentElement.clientHeight),a=Math.max(s-.5*mr(e.display),3);i=(r>0?t.bottom:t.top)+r*a}else"line"==n&&(i=r>0?t.bottom+3:t.top-3);for(var u;(u=cr(e,l,i)).outside;){if(r<0?i<=0:i>=o.height){u.hitSide=!0;break}i+=5*r}return u}function nl(e,t){var r=jt(e,t.line);if(!r||r.hidden)return null;var n=M(e.doc,t.line),i=Ut(r,n,t.line),o=Se(n,e.doc.direction),l="left";o&&(l=Ce(o,t.ch)%2?"right":"left");var s=_t(i.map,t.ch,l);return s.offset="right"==s.collapse?s.end:s.start,s}function il(e){for(var t=e;t;t=t.parentNode)if(/CodeMirror-gutter-wrapper/.test(t.className))return!0;return!1}function ol(e,t){return t&&(e.bad=!0),e}function ll(e,t,r,n,i){function o(e){return function(t){return t.id==e}}function l(){c&&(u+=f,c=!1)}function s(e){e&&(l(),u+=e)}function a(t){if(1==t.nodeType){var r=t.getAttribute("cm-text");if(null!=r)return void s(r||t.textContent.replace(/\u200b/g,""));var u,h=t.getAttribute("cm-marker");if(h){var d=e.findMarks(E(n,0),E(i+1,0),o(+h));return void(d.length&&(u=d[0].find(0))&&s(N(e.doc,u.from,u.to).join(f)))}if("false"==t.getAttribute("contenteditable"))return;var p=/^(pre|div|p)$/i.test(t.nodeName);p&&l();for(var g=0;g<t.childNodes.length;g++)a(t.childNodes[g]);p&&(c=!0)}else 3==t.nodeType&&s(t.nodeValue)}for(var u="",c=!1,f=e.doc.lineSeparator();a(t),t!=r;)t=t.nextSibling;return u}function sl(e,t,r){var n;if(t==e.display.lineDiv){if(!(n=e.display.lineDiv.childNodes[r]))return ol(e.clipPos(E(e.display.viewTo-1)),!0);t=null,r=0}else for(n=t;;n=n.parentNode){if(!n||n==e.display.lineDiv)return null;if(n.parentNode&&n.parentNode==e.display.lineDiv)break}for(var i=0;i<e.display.view.length;i++){var o=e.display.view[i];if(o.node==n)return al(o,t,r)}}function al(e,t,r){function n(t,r,n){for(var i=-1;i<(f?f.length:0);i++)for(var o=i<0?c.map:f[i],l=0;l<o.length;l+=3){var s=o[l+2];if(s==t||s==r){var a=W(i<0?e.line:e.rest[i]),u=o[l]+n;return(n<0||s!=t)&&(u=o[l+(n?1:0)]),E(a,u)}}}var i=e.text.firstChild,l=!1;if(!t||!o(i,t))return ol(E(W(e.line),0),!0);if(t==i&&(l=!0,t=i.childNodes[r],r=0,!t)){var s=e.rest?g(e.rest):e.line;return ol(E(W(s),s.text.length),l)}var a=3==t.nodeType?t:null,u=t;for(a||1!=t.childNodes.length||3!=t.firstChild.nodeType||(a=t.firstChild,r&&(r=a.nodeValue.length));u.parentNode!=i;)u=u.parentNode;var c=e.measure,f=c.maps,h=n(a,u,r);if(h)return ol(h,l);for(var d=u.nextSibling,p=a?a.nodeValue.length-r:0;d;d=d.nextSibling){if(h=n(d,d.firstChild,0))return ol(E(h.line,h.ch-p),l);p+=d.textContent.length}for(var v=u.previousSibling,m=r;v;v=v.previousSibling){if(h=n(v,v.firstChild,-1))return ol(E(h.line,h.ch+m),l);m+=v.textContent.length}}var ul=navigator.userAgent,cl=navigator.platform,fl=/gecko\/\d/i.test(ul),hl=/MSIE \d/.test(ul),dl=/Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(ul),pl=/Edge\/(\d+)/.exec(ul),gl=hl||dl||pl,vl=gl&&(hl?document.documentMode||6:+(pl||dl)[1]),ml=!pl&&/WebKit\//.test(ul),yl=ml&&/Qt\/\d+\.\d+/.test(ul),bl=!pl&&/Chrome\//.test(ul),wl=/Opera\//.test(ul),xl=/Apple Computer/.test(navigator.vendor),Cl=/Mac OS X 1\d\D([8-9]|\d\d)\D/.test(ul),Sl=/PhantomJS/.test(ul),Ll=!pl&&/AppleWebKit/.test(ul)&&/Mobile\/\w+/.test(ul),kl=/Android/.test(ul),Tl=Ll||kl||/webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(ul),Ml=Ll||/Mac/.test(cl),Nl=/\bCrOS\b/.test(ul),Ol=/win/i.test(cl),Al=wl&&ul.match(/Version\/(\d*\.\d*)/);Al&&(Al=Number(Al[1])),Al&&Al>=15&&(wl=!1,ml=!0);var Wl,Dl=Ml&&(yl||wl&&(null==Al||Al<12.11)),Hl=fl||gl&&vl>=9,Fl=function(t,r){var n=t.className,i=e(r).exec(n);if(i){var o=n.slice(i.index+i[0].length);t.className=n.slice(0,i.index)+(o?i[1]+o:"")}};Wl=document.createRange?function(e,t,r,n){var i=document.createRange();return i.setEnd(n||e,r),i.setStart(e,t),i}:function(e,t,r){var n=document.body.createTextRange();try{n.moveToElementText(e.parentNode)}catch(e){return n}return n.collapse(!0),n.moveEnd("character",r),n.moveStart("character",t),n};var El=function(e){e.select()};Ll?El=function(e){e.selectionStart=0,e.selectionEnd=e.value.length}:gl&&(El=function(e){try{e.select()}catch(e){}});var Pl=function(){this.id=null};Pl.prototype.set=function(e,t){clearTimeout(this.id),this.id=setTimeout(t,e)};var Il,zl,Rl=30,Bl={toString:function(){return"CodeMirror.Pass"}},Gl={scroll:!1},Ul={origin:"*mouse"},Vl={origin:"+move"},Kl=[""],jl=/[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/,Xl=/[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/,Yl=!1,_l=!1,$l=null,ql=function(){function e(e){return e<=247?r.charAt(e):1424<=e&&e<=1524?"R":1536<=e&&e<=1785?n.charAt(e-1536):1774<=e&&e<=2220?"r":8192<=e&&e<=8203?"w":8204==e?"b":"L"}function t(e,t,r){this.level=e,this.from=t,this.to=r}var r="bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN",n="nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111",i=/[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/,o=/[stwN]/,l=/[LRr]/,s=/[Lb1n]/,a=/[1n]/;return function(r,n){var u="ltr"==n?"L":"R";if(0==r.length||"ltr"==n&&!i.test(r))return!1;for(var c=r.length,f=[],h=0;h<c;++h)f.push(e(r.charCodeAt(h)));for(var d=0,p=u;d<c;++d){var v=f[d];"m"==v?f[d]=p:p=v}for(var m=0,y=u;m<c;++m){var b=f[m];"1"==b&&"r"==y?f[m]="n":l.test(b)&&(y=b,"r"==b&&(f[m]="R"))}for(var w=1,x=f[0];w<c-1;++w){var C=f[w];"+"==C&&"1"==x&&"1"==f[w+1]?f[w]="1":","!=C||x!=f[w+1]||"1"!=x&&"n"!=x||(f[w]=x),x=C}for(var S=0;S<c;++S){var L=f[S];if(","==L)f[S]="N";else if("%"==L){var k=void 0;for(k=S+1;k<c&&"%"==f[k];++k);for(var T=S&&"!"==f[S-1]||k<c&&"1"==f[k]?"1":"N",M=S;M<k;++M)f[M]=T;S=k-1}}for(var N=0,O=u;N<c;++N){var A=f[N];"L"==O&&"1"==A?f[N]="L":l.test(A)&&(O=A)}for(var W=0;W<c;++W)if(o.test(f[W])){var D=void 0;for(D=W+1;D<c&&o.test(f[D]);++D);for(var H="L"==(W?f[W-1]:u),F=H==("L"==(D<c?f[D]:u))?H?"L":"R":u,E=W;E<D;++E)f[E]=F;W=D-1}for(var P,I=[],z=0;z<c;)if(s.test(f[z])){var R=z;for(++z;z<c&&s.test(f[z]);++z);I.push(new t(0,R,z))}else{var B=z,G=I.length;for(++z;z<c&&"L"!=f[z];++z);for(var U=B;U<z;)if(a.test(f[U])){B<U&&I.splice(G,0,new t(1,B,U));var V=U;for(++U;U<z&&a.test(f[U]);++U);I.splice(G,0,new t(2,V,U)),B=U}else++U;B<z&&I.splice(G,0,new t(1,B,z))}return 1==I[0].level&&(P=r.match(/^\s+/))&&(I[0].from=P[0].length,I.unshift(new t(0,0,P[0].length))),1==g(I).level&&(P=r.match(/\s+$/))&&(g(I).to-=P[0].length,I.push(new t(0,c-P[0].length,c))),"rtl"==n?I.reverse():I}}(),Zl=[],Ql=function(e,t,r){if(e.addEventListener)e.addEventListener(t,r,!1);else if(e.attachEvent)e.attachEvent("on"+t,r);else{var n=e._handlers||(e._handlers={});n[t]=(n[t]||Zl).concat(r)}},Jl=function(){if(gl&&vl<9)return!1;var e=n("div");return"draggable"in e||"dragDrop"in e}(),es=3!="\n\nb".split(/\n/).length?function(e){for(var t=0,r=[],n=e.length;t<=n;){var i=e.indexOf("\n",t);-1==i&&(i=e.length);var o=e.slice(t,"\r"==e.charAt(i-1)?i-1:i),l=o.indexOf("\r");-1!=l?(r.push(o.slice(0,l)),t+=l+1):(r.push(o),t=i+1)}return r}:function(e){return e.split(/\r\n?|\n/)},ts=window.getSelection?function(e){try{return e.selectionStart!=e.selectionEnd}catch(e){return!1}}:function(e){var t;try{t=e.ownerDocument.selection.createRange()}catch(e){}return!(!t||t.parentElement()!=e)&&0!=t.compareEndPoints("StartToEnd",t)},rs=function(){var e=n("div");return"oncopy"in e||(e.setAttribute("oncopy","return;"),"function"==typeof e.oncopy)}(),ns=null,is={},os={},ls={},ss=function(e,t,r){this.pos=this.start=0,this.string=e,this.tabSize=t||8,this.lastColumnPos=this.lastColumnValue=0,this.lineStart=0,this.lineOracle=r};ss.prototype.eol=function(){return this.pos>=this.string.length},ss.prototype.sol=function(){return this.pos==this.lineStart},ss.prototype.peek=function(){return this.string.charAt(this.pos)||void 0},ss.prototype.next=function(){if(this.pos<this.string.length)return this.string.charAt(this.pos++)},ss.prototype.eat=function(e){var t=this.string.charAt(this.pos);if("string"==typeof e?t==e:t&&(e.test?e.test(t):e(t)))return++this.pos,t},ss.prototype.eatWhile=function(e){for(var t=this.pos;this.eat(e););return this.pos>t},ss.prototype.eatSpace=function(){for(var e=this,t=this.pos;/[\s\u00a0]/.test(this.string.charAt(this.pos));)++e.pos;return this.pos>t},ss.prototype.skipToEnd=function(){this.pos=this.string.length},ss.prototype.skipTo=function(e){var t=this.string.indexOf(e,this.pos);if(t>-1)return this.pos=t,!0},ss.prototype.backUp=function(e){this.pos-=e},ss.prototype.column=function(){return this.lastColumnPos<this.start&&(this.lastColumnValue=f(this.string,this.start,this.tabSize,this.lastColumnPos,this.lastColumnValue),this.lastColumnPos=this.start),this.lastColumnValue-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.indentation=function(){return f(this.string,null,this.tabSize)-(this.lineStart?f(this.string,this.lineStart,this.tabSize):0)},ss.prototype.match=function(e,t,r){if("string"!=typeof e){var n=this.string.slice(this.pos).match(e);return n&&n.index>0?null:(n&&!1!==t&&(this.pos+=n[0].length),n)}var i=function(e){return r?e.toLowerCase():e};if(i(this.string.substr(this.pos,e.length))==i(e))return!1!==t&&(this.pos+=e.length),!0},ss.prototype.current=function(){return this.string.slice(this.start,this.pos)},ss.prototype.hideFirstChars=function(e,t){this.lineStart+=e;try{return t()}finally{this.lineStart-=e}},ss.prototype.lookAhead=function(e){var t=this.lineOracle;return t&&t.lookAhead(e)};var as=function(e,t){this.state=e,this.lookAhead=t},us=function(e,t,r,n){this.state=t,this.doc=e,this.line=r,this.maxLookAhead=n||0};us.prototype.lookAhead=function(e){var t=this.doc.getLine(this.line+e);return null!=t&&e>this.maxLookAhead&&(this.maxLookAhead=e),t},us.prototype.nextLine=function(){this.line++,this.maxLookAhead>0&&this.maxLookAhead--},us.fromSaved=function(e,t,r){return t instanceof as?new us(e,Ke(e.mode,t.state),r,t.lookAhead):new us(e,Ke(e.mode,t),r)},us.prototype.save=function(e){var t=!1!==e?Ke(this.doc.mode,this.state):this.state;return this.maxLookAhead>0?new as(t,this.maxLookAhead):t};var cs=function(e,t,r){this.start=e.start,this.end=e.pos,this.string=e.current(),this.type=t||null,this.state=r},fs=function(e,t,r){this.text=e,ne(this,t),this.height=r?r(this):1};fs.prototype.lineNo=function(){return W(this)},Ae(fs);var hs,ds={},ps={},gs=null,vs=null,ms={left:0,right:0,top:0,bottom:0},ys=function(e,t,r){this.cm=r;var i=this.vert=n("div",[n("div",null,null,"min-width: 1px")],"CodeMirror-vscrollbar"),o=this.horiz=n("div",[n("div",null,null,"height: 100%; min-height: 1px")],"CodeMirror-hscrollbar");e(i),e(o),Ql(i,"scroll",function(){i.clientHeight&&t(i.scrollTop,"vertical")}),Ql(o,"scroll",function(){o.clientWidth&&t(o.scrollLeft,"horizontal")}),this.checkedZeroWidth=!1,gl&&vl<8&&(this.horiz.style.minHeight=this.vert.style.minWidth="18px")};ys.prototype.update=function(e){var t=e.scrollWidth>e.clientWidth+1,r=e.scrollHeight>e.clientHeight+1,n=e.nativeBarWidth;if(r){this.vert.style.display="block",this.vert.style.bottom=t?n+"px":"0";var i=e.viewHeight-(t?n:0);this.vert.firstChild.style.height=Math.max(0,e.scrollHeight-e.clientHeight+i)+"px"}else this.vert.style.display="",this.vert.firstChild.style.height="0";if(t){this.horiz.style.display="block",this.horiz.style.right=r?n+"px":"0",this.horiz.style.left=e.barLeft+"px";var o=e.viewWidth-e.barLeft-(r?n:0);this.horiz.firstChild.style.width=Math.max(0,e.scrollWidth-e.clientWidth+o)+"px"}else this.horiz.style.display="",this.horiz.firstChild.style.width="0";return!this.checkedZeroWidth&&e.clientHeight>0&&(0==n&&this.zeroWidthHack(),this.checkedZeroWidth=!0),{right:r?n:0,bottom:t?n:0}},ys.prototype.setScrollLeft=function(e){this.horiz.scrollLeft!=e&&(this.horiz.scrollLeft=e),this.disableHoriz&&this.enableZeroWidthBar(this.horiz,this.disableHoriz,"horiz")},ys.prototype.setScrollTop=function(e){this.vert.scrollTop!=e&&(this.vert.scrollTop=e),this.disableVert&&this.enableZeroWidthBar(this.vert,this.disableVert,"vert")},ys.prototype.zeroWidthHack=function(){var e=Ml&&!Cl?"12px":"18px";this.horiz.style.height=this.vert.style.width=e,this.horiz.style.pointerEvents=this.vert.style.pointerEvents="none",this.disableHoriz=new Pl,this.disableVert=new Pl},ys.prototype.enableZeroWidthBar=function(e,t,r){function n(){var i=e.getBoundingClientRect();("vert"==r?document.elementFromPoint(i.right-1,(i.top+i.bottom)/2):document.elementFromPoint((i.right+i.left)/2,i.bottom-1))!=e?e.style.pointerEvents="none":t.set(1e3,n)}e.style.pointerEvents="auto",t.set(1e3,n)},ys.prototype.clear=function(){var e=this.horiz.parentNode;e.removeChild(this.horiz),e.removeChild(this.vert)};var bs=function(){};bs.prototype.update=function(){return{bottom:0,right:0}},bs.prototype.setScrollLeft=function(){},bs.prototype.setScrollTop=function(){},bs.prototype.clear=function(){};var ws={native:ys,null:bs},xs=0,Cs=function(e,t,r){var n=e.display;this.viewport=t,this.visible=Ir(n,e.doc,t),this.editorIsHidden=!n.wrapper.offsetWidth,this.wrapperHeight=n.wrapper.clientHeight,this.wrapperWidth=n.wrapper.clientWidth,this.oldDisplayWidth=Rt(e),this.force=r,this.dims=br(e),this.events=[]};Cs.prototype.signal=function(e,t){Oe(e,t)&&this.events.push(arguments)},Cs.prototype.finish=function(){for(var e=this,t=0;t<this.events.length;t++)Te.apply(null,e.events[t])};var Ss=0,Ls=null;gl?Ls=-.53:fl?Ls=15:bl?Ls=-.7:xl&&(Ls=-1/3);var ks=function(e,t){this.ranges=e,this.primIndex=t};ks.prototype.primary=function(){return this.ranges[this.primIndex]},ks.prototype.equals=function(e){var t=this;if(e==this)return!0;if(e.primIndex!=this.primIndex||e.ranges.length!=this.ranges.length)return!1;for(var r=0;r<this.ranges.length;r++){var n=t.ranges[r],i=e.ranges[r];if(!I(n.anchor,i.anchor)||!I(n.head,i.head))return!1}return!0},ks.prototype.deepCopy=function(){for(var e=this,t=[],r=0;r<this.ranges.length;r++)t[r]=new Ts(z(e.ranges[r].anchor),z(e.ranges[r].head));return new ks(t,this.primIndex)},ks.prototype.somethingSelected=function(){for(var e=this,t=0;t<this.ranges.length;t++)if(!e.ranges[t].empty())return!0;return!1},ks.prototype.contains=function(e,t){var r=this;t||(t=e);for(var n=0;n<this.ranges.length;n++){var i=r.ranges[n];if(P(t,i.from())>=0&&P(e,i.to())<=0)return n}return-1};var Ts=function(e,t){this.anchor=e,this.head=t};Ts.prototype.from=function(){return B(this.anchor,this.head)},Ts.prototype.to=function(){return R(this.anchor,this.head)},Ts.prototype.empty=function(){return this.head.line==this.anchor.line&&this.head.ch==this.anchor.ch},Bi.prototype={chunkSize:function(){return this.lines.length},removeInner:function(e,t){for(var r=this,n=e,i=e+t;n<i;++n){var o=r.lines[n];r.height-=o.height,ot(o),bt(o,"delete")}this.lines.splice(e,t)},collapse:function(e){e.push.apply(e,this.lines)},insertInner:function(e,t,r){var n=this;this.height+=r,this.lines=this.lines.slice(0,e).concat(t).concat(this.lines.slice(e));for(var i=0;i<t.length;++i)t[i].parent=n},iterN:function(e,t,r){for(var n=this,i=e+t;e<i;++e)if(r(n.lines[e]))return!0}},Gi.prototype={chunkSize:function(){return this.size},removeInner:function(e,t){var r=this;this.size-=t;for(var n=0;n<this.children.length;++n){var i=r.children[n],o=i.chunkSize();if(e<o){var l=Math.min(t,o-e),s=i.height;if(i.removeInner(e,l),r.height-=s-i.height,o==l&&(r.children.splice(n--,1),i.parent=null),0==(t-=l))break;e=0}else e-=o}if(this.size-t<25&&(this.children.length>1||!(this.children[0]instanceof Bi))){var a=[];this.collapse(a),this.children=[new Bi(a)],this.children[0].parent=this}},collapse:function(e){for(var t=this,r=0;r<this.children.length;++r)t.children[r].collapse(e)},insertInner:function(e,t,r){var n=this;this.size+=t.length,this.height+=r;for(var i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<=l){if(o.insertInner(e,t,r),o.lines&&o.lines.length>50){for(var s=o.lines.length%25+25,a=s;a<o.lines.length;){var u=new Bi(o.lines.slice(a,a+=25));o.height-=u.height,n.children.splice(++i,0,u),u.parent=n}o.lines=o.lines.slice(0,s),n.maybeSpill()}break}e-=l}},maybeSpill:function(){if(!(this.children.length<=10)){var e=this;do{var t=new Gi(e.children.splice(e.children.length-5,5));if(e.parent){e.size-=t.size,e.height-=t.height;var r=h(e.parent.children,e);e.parent.children.splice(r+1,0,t)}else{var n=new Gi(e.children);n.parent=e,e.children=[n,t],e=n}t.parent=e.parent}while(e.children.length>10);e.parent.maybeSpill()}},iterN:function(e,t,r){for(var n=this,i=0;i<this.children.length;++i){var o=n.children[i],l=o.chunkSize();if(e<l){var s=Math.min(t,l-e);if(o.iterN(e,s,r))return!0;if(0==(t-=s))break;e=0}else e-=l}}};var Ms=function(e,t,r){var n=this;if(r)for(var i in r)r.hasOwnProperty(i)&&(n[i]=r[i]);this.doc=e,this.node=t};Ms.prototype.clear=function(){var e=this,t=this.doc.cm,r=this.line.widgets,n=this.line,i=W(n);if(null!=i&&r){for(var o=0;o<r.length;++o)r[o]==e&&r.splice(o--,1);r.length||(n.widgets=null);var l=Ht(this);A(n,Math.max(0,n.height-l)),t&&(hn(t,function(){Ui(t,n,-l),mn(t,i,"widget")}),bt(t,"lineWidgetCleared",t,this,i))}},Ms.prototype.changed=function(){var e=this,t=this.height,r=this.doc.cm,n=this.line;this.height=null;var i=Ht(this)-t;i&&(A(n,n.height+i),r&&hn(r,function(){r.curOp.forceUpdate=!0,Ui(r,n,i),bt(r,"lineWidgetChanged",r,e,W(n))}))},Ae(Ms);var Ns=0,Os=function(e,t){this.lines=[],this.type=t,this.doc=e,this.id=++Ns};Os.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){var t=this.doc.cm,r=t&&!t.curOp;if(r&&nn(t),Oe(this,"clear")){var n=this.find();n&&bt(this,"clear",n.from,n.to)}for(var i=null,o=null,l=0;l<this.lines.length;++l){var s=e.lines[l],a=_(s.markedSpans,e);t&&!e.collapsed?mn(t,W(s),"text"):t&&(null!=a.to&&(o=W(s)),null!=a.from&&(i=W(s))),s.markedSpans=$(s.markedSpans,a),null==a.from&&e.collapsed&&!ve(e.doc,s)&&t&&A(s,mr(t.display))}if(t&&this.collapsed&&!t.options.lineWrapping)for(var u=0;u<this.lines.length;++u){var c=fe(e.lines[u]),f=be(c);f>t.display.maxLineLength&&(t.display.maxLine=c,t.display.maxLineLength=f,t.display.maxLineChanged=!0)}null!=i&&t&&this.collapsed&&vn(t,i,o+1),this.lines.length=0,this.explicitlyCleared=!0,this.atomic&&this.doc.cantEdit&&(this.doc.cantEdit=!1,t&&Ci(t.doc)),t&&bt(t,"markerCleared",t,this,i,o),r&&on(t),this.parent&&this.parent.clear()}},Os.prototype.find=function(e,t){var r=this;null==e&&"bookmark"==this.type&&(e=1);for(var n,i,o=0;o<this.lines.length;++o){var l=r.lines[o],s=_(l.markedSpans,r);if(null!=s.from&&(n=E(t?l:W(l),s.from),-1==e))return n;if(null!=s.to&&(i=E(t?l:W(l),s.to),1==e))return i}return n&&{from:n,to:i}},Os.prototype.changed=function(){var e=this,t=this.find(-1,!0),r=this,n=this.doc.cm;t&&n&&hn(n,function(){var i=t.line,o=W(t.line),l=jt(n,o);if(l&&(Qt(l),n.curOp.selectionChanged=n.curOp.forceUpdate=!0),n.curOp.updateMaxLine=!0,!ve(r.doc,i)&&null!=r.height){var s=r.height;r.height=null;var a=Ht(r)-s;a&&A(i,i.height+a)}bt(n,"markerChanged",n,e)})},Os.prototype.attachLine=function(e){if(!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;t.maybeHiddenMarkers&&-1!=h(t.maybeHiddenMarkers,this)||(t.maybeUnhiddenMarkers||(t.maybeUnhiddenMarkers=[])).push(this)}this.lines.push(e)},Os.prototype.detachLine=function(e){if(this.lines.splice(h(this.lines,e),1),!this.lines.length&&this.doc.cm){var t=this.doc.cm.curOp;(t.maybeHiddenMarkers||(t.maybeHiddenMarkers=[])).push(this)}},Ae(Os);var As=function(e,t){var r=this;this.markers=e,this.primary=t;for(var n=0;n<e.length;++n)e[n].parent=r};As.prototype.clear=function(){var e=this;if(!this.explicitlyCleared){this.explicitlyCleared=!0;for(var t=0;t<this.markers.length;++t)e.markers[t].clear();bt(this,"clear")}},As.prototype.find=function(e,t){return this.primary.find(e,t)},Ae(As);var Ws=0,Ds=function(e,t,r,n,i){if(!(this instanceof Ds))return new Ds(e,t,r,n,i);null==r&&(r=0),Gi.call(this,[new Bi([new fs("",null)])]),this.first=r,this.scrollTop=this.scrollLeft=0,this.cantEdit=!1,this.cleanGeneration=1,this.modeFrontier=this.highlightFrontier=r;var o=E(r,0);this.sel=Rn(o),this.history=new Jn(null),this.id=++Ws,this.modeOption=t,this.lineSep=n,this.direction="rtl"==i?"rtl":"ltr",this.extend=!1,"string"==typeof e&&(e=this.splitLines(e)),_n(this,{from:o,to:o,text:e}),bi(this,Rn(o),Gl)};Ds.prototype=b(Gi.prototype,{constructor:Ds,iter:function(e,t,r){r?this.iterN(e-this.first,t-e,r):this.iterN(this.first,this.first+this.size,e)},insert:function(e,t){for(var r=0,n=0;n<t.length;++n)r+=t[n].height;this.insertInner(e-this.first,t,r)},remove:function(e,t){this.removeInner(e-this.first,t)},getValue:function(e){var t=O(this,this.first,this.first+this.size);return!1===e?t:t.join(e||this.lineSeparator())},setValue:gn(function(e){var t=E(this.first,0),r=this.first+this.size-1;Oi(this,{from:t,to:E(r,M(this,r).text.length),text:this.splitLines(e),origin:"setValue",full:!0},!0),this.cm&&Xr(this.cm,0,0),bi(this,Rn(t),Gl)}),replaceRange:function(e,t,r,n){Ei(this,e,t=U(this,t),r=r?U(this,r):t,n)},getRange:function(e,t,r){var n=N(this,U(this,e),U(this,t));return!1===r?n:n.join(r||this.lineSeparator())},getLine:function(e){var t=this.getLineHandle(e);return t&&t.text},getLineHandle:function(e){if(H(this,e))return M(this,e)},getLineNumber:function(e){return W(e)},getLineHandleVisualStart:function(e){return"number"==typeof e&&(e=M(this,e)),fe(e)},lineCount:function(){return this.size},firstLine:function(){return this.first},lastLine:function(){return this.first+this.size-1},clipPos:function(e){return U(this,e)},getCursor:function(e){var t=this.sel.primary();return null==e||"head"==e?t.head:"anchor"==e?t.anchor:"end"==e||"to"==e||!1===e?t.to():t.from()},listSelections:function(){return this.sel.ranges},somethingSelected:function(){return this.sel.somethingSelected()},setCursor:gn(function(e,t,r){vi(this,U(this,"number"==typeof e?E(e,t||0):e),null,r)}),setSelection:gn(function(e,t,r){vi(this,U(this,e),U(this,t||e),r)}),extendSelection:gn(function(e,t,r){di(this,U(this,e),t&&U(this,t),r)}),extendSelections:gn(function(e,t){pi(this,K(this,e),t)}),extendSelectionsBy:gn(function(e,t){pi(this,K(this,v(this.sel.ranges,e)),t)}),setSelections:gn(function(e,t,r){var n=this;if(e.length){for(var i=[],o=0;o<e.length;o++)i[o]=new Ts(U(n,e[o].anchor),U(n,e[o].head));null==t&&(t=Math.min(e.length-1,this.sel.primIndex)),bi(this,zn(i,t),r)}}),addSelection:gn(function(e,t,r){var n=this.sel.ranges.slice(0);n.push(new Ts(U(this,e),U(this,t||e))),bi(this,zn(n,n.length-1),r)}),getSelection:function(e){for(var t,r=this,n=this.sel.ranges,i=0;i<n.length;i++){var o=N(r,n[i].from(),n[i].to());t=t?t.concat(o):o}return!1===e?t:t.join(e||this.lineSeparator())},getSelections:function(e){for(var t=this,r=[],n=this.sel.ranges,i=0;i<n.length;i++){var o=N(t,n[i].from(),n[i].to());!1!==e&&(o=o.join(e||t.lineSeparator())),r[i]=o}return r},replaceSelection:function(e,t,r){for(var n=[],i=0;i<this.sel.ranges.length;i++)n[i]=e;this.replaceSelections(n,t,r||"+input")},replaceSelections:gn(function(e,t,r){for(var n=this,i=[],o=this.sel,l=0;l<o.ranges.length;l++){var s=o.ranges[l];i[l]={from:s.from(),to:s.to(),text:n.splitLines(e[l]),origin:r}}for(var a=t&&"end"!=t&&Kn(this,i,t),u=i.length-1;u>=0;u--)Oi(n,i[u]);a?yi(this,a):this.cm&&jr(this.cm)}),undo:gn(function(){Wi(this,"undo")}),redo:gn(function(){Wi(this,"redo")}),undoSelection:gn(function(){Wi(this,"undo",!0)}),redoSelection:gn(function(){Wi(this,"redo",!0)}),setExtending:function(e){this.extend=e},getExtending:function(){return this.extend},historySize:function(){for(var e=this.history,t=0,r=0,n=0;n<e.done.length;n++)e.done[n].ranges||++t;for(var i=0;i<e.undone.length;i++)e.undone[i].ranges||++r;return{undo:t,redo:r}},clearHistory:function(){this.history=new Jn(this.history.maxGeneration)},markClean:function(){this.cleanGeneration=this.changeGeneration(!0)},changeGeneration:function(e){return e&&(this.history.lastOp=this.history.lastSelOp=this.history.lastOrigin=null),this.history.generation},isClean:function(e){return this.history.generation==(e||this.cleanGeneration)},getHistory:function(){return{done:fi(this.history.done),undone:fi(this.history.undone)}},setHistory:function(e){var t=this.history=new Jn(this.history.maxGeneration);t.done=fi(e.done.slice(0),null,!0),t.undone=fi(e.undone.slice(0),null,!0)},setGutterMarker:gn(function(e,t,r){return Ri(this,e,"gutter",function(e){var n=e.gutterMarkers||(e.gutterMarkers={});return n[t]=r,!r&&C(n)&&(e.gutterMarkers=null),!0})}),clearGutter:gn(function(e){var t=this;this.iter(function(r){r.gutterMarkers&&r.gutterMarkers[e]&&Ri(t,r,"gutter",function(){return r.gutterMarkers[e]=null,C(r.gutterMarkers)&&(r.gutterMarkers=null),!0})})}),lineInfo:function(e){var t;if("number"==typeof e){if(!H(this,e))return null;if(t=e,!(e=M(this,e)))return null}else if(null==(t=W(e)))return null;return{line:t,handle:e,text:e.text,gutterMarkers:e.gutterMarkers,textClass:e.textClass,bgClass:e.bgClass,wrapClass:e.wrapClass,widgets:e.widgets}},addLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass";if(t[i]){if(e(n).test(t[i]))return!1;t[i]+=" "+n}else t[i]=n;return!0})}),removeLineClass:gn(function(t,r,n){return Ri(this,t,"gutter"==r?"gutter":"class",function(t){var i="text"==r?"textClass":"background"==r?"bgClass":"gutter"==r?"gutterClass":"wrapClass",o=t[i];if(!o)return!1;if(null==n)t[i]=null;else{var l=o.match(e(n));if(!l)return!1;var s=l.index+l[0].length;t[i]=o.slice(0,l.index)+(l.index&&s!=o.length?" ":"")+o.slice(s)||null}return!0})}),addLineWidget:gn(function(e,t,r){return Vi(this,e,t,r)}),removeLineWidget:function(e){e.clear()},markText:function(e,t,r){return Ki(this,U(this,e),U(this,t),r,r&&r.type||"range")},setBookmark:function(e,t){var r={replacedWith:t&&(null==t.nodeType?t.widget:t),insertLeft:t&&t.insertLeft,clearWhenEmpty:!1,shared:t&&t.shared,handleMouseEvents:t&&t.handleMouseEvents};return e=U(this,e),Ki(this,e,e,r,"bookmark")},findMarksAt:function(e){var t=[],r=M(this,(e=U(this,e)).line).markedSpans;if(r)for(var n=0;n<r.length;++n){var i=r[n];(null==i.from||i.from<=e.ch)&&(null==i.to||i.to>=e.ch)&&t.push(i.marker.parent||i.marker)}return t},findMarks:function(e,t,r){e=U(this,e),t=U(this,t);var n=[],i=e.line;return this.iter(e.line,t.line+1,function(o){var l=o.markedSpans;if(l)for(var s=0;s<l.length;s++){var a=l[s];null!=a.to&&i==e.line&&e.ch>=a.to||null==a.from&&i!=e.line||null!=a.from&&i==t.line&&a.from>=t.ch||r&&!r(a.marker)||n.push(a.marker.parent||a.marker)}++i}),n},getAllMarks:function(){var e=[];return this.iter(function(t){var r=t.markedSpans;if(r)for(var n=0;n<r.length;++n)null!=r[n].from&&e.push(r[n].marker)}),e},posFromIndex:function(e){var t,r=this.first,n=this.lineSeparator().length;return this.iter(function(i){var o=i.text.length+n;if(o>e)return t=e,!0;e-=o,++r}),U(this,E(r,t))},indexFromPos:function(e){var t=(e=U(this,e)).ch;if(e.line<this.first||e.ch<0)return 0;var r=this.lineSeparator().length;return this.iter(this.first,e.line,function(e){t+=e.text.length+r}),t},copy:function(e){var t=new Ds(O(this,this.first,this.first+this.size),this.modeOption,this.first,this.lineSep,this.direction);return t.scrollTop=this.scrollTop,t.scrollLeft=this.scrollLeft,t.sel=this.sel,t.extend=!1,e&&(t.history.undoDepth=this.history.undoDepth,t.setHistory(this.getHistory())),t},linkedDoc:function(e){e||(e={});var t=this.first,r=this.first+this.size;null!=e.from&&e.from>t&&(t=e.from),null!=e.to&&e.to<r&&(r=e.to);var n=new Ds(O(this,t,r),e.mode||this.modeOption,t,this.lineSep,this.direction);return e.sharedHist&&(n.history=this.history),(this.linked||(this.linked=[])).push({doc:n,sharedHist:e.sharedHist}),n.linked=[{doc:this,isParent:!0,sharedHist:e.sharedHist}],Yi(n,Xi(this)),n},unlinkDoc:function(e){var t=this;if(e instanceof jo&&(e=e.doc),this.linked)for(var r=0;r<this.linked.length;++r)if(t.linked[r].doc==e){t.linked.splice(r,1),e.unlinkDoc(t),_i(Xi(t));break}if(e.history==this.history){var n=[e.id];$n(e,function(e){return n.push(e.id)},!0),e.history=new Jn(null),e.history.done=fi(this.history.done,n),e.history.undone=fi(this.history.undone,n)}},iterLinkedDocs:function(e){$n(this,e)},getMode:function(){return this.mode},getEditor:function(){return this.cm},splitLines:function(e){return this.lineSep?e.split(this.lineSep):es(e)},lineSeparator:function(){return this.lineSep||"\n"},setDirection:gn(function(e){"rtl"!=e&&(e="ltr"),e!=this.direction&&(this.direction=e,this.iter(function(e){return e.order=null}),this.cm&&Qn(this.cm))})}),Ds.prototype.eachLine=Ds.prototype.iter;for(var Hs=0,Fs=!1,Es={3:"Enter",8:"Backspace",9:"Tab",13:"Enter",16:"Shift",17:"Ctrl",18:"Alt",19:"Pause",20:"CapsLock",27:"Esc",32:"Space",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"Left",38:"Up",39:"Right",40:"Down",44:"PrintScrn",45:"Insert",46:"Delete",59:";",61:"=",91:"Mod",92:"Mod",93:"Mod",106:"*",107:"=",109:"-",110:".",111:"/",127:"Delete",173:"-",186:";",187:"=",188:",",189:"-",190:".",191:"/",192:"`",219:"[",220:"\\",221:"]",222:"'",63232:"Up",63233:"Down",63234:"Left",63235:"Right",63272:"Delete",63273:"Home",63275:"End",63276:"PageUp",63277:"PageDown",63302:"Insert"},Ps=0;Ps<10;Ps++)Es[Ps+48]=Es[Ps+96]=String(Ps);for(var Is=65;Is<=90;Is++)Es[Is]=String.fromCharCode(Is);for(var zs=1;zs<=12;zs++)Es[zs+111]=Es[zs+63235]="F"+zs;var Rs={};Rs.basic={Left:"goCharLeft",Right:"goCharRight",Up:"goLineUp",Down:"goLineDown",End:"goLineEnd",Home:"goLineStartSmart",PageUp:"goPageUp",PageDown:"goPageDown",Delete:"delCharAfter",Backspace:"delCharBefore","Shift-Backspace":"delCharBefore",Tab:"defaultTab","Shift-Tab":"indentAuto",Enter:"newlineAndIndent",Insert:"toggleOverwrite",Esc:"singleSelection"},Rs.pcDefault={"Ctrl-A":"selectAll","Ctrl-D":"deleteLine","Ctrl-Z":"undo","Shift-Ctrl-Z":"redo","Ctrl-Y":"redo","Ctrl-Home":"goDocStart","Ctrl-End":"goDocEnd","Ctrl-Up":"goLineUp","Ctrl-Down":"goLineDown","Ctrl-Left":"goGroupLeft","Ctrl-Right":"goGroupRight","Alt-Left":"goLineStart","Alt-Right":"goLineEnd","Ctrl-Backspace":"delGroupBefore","Ctrl-Delete":"delGroupAfter","Ctrl-S":"save","Ctrl-F":"find","Ctrl-G":"findNext","Shift-Ctrl-G":"findPrev","Shift-Ctrl-F":"replace","Shift-Ctrl-R":"replaceAll","Ctrl-[":"indentLess","Ctrl-]":"indentMore","Ctrl-U":"undoSelection","Shift-Ctrl-U":"redoSelection","Alt-U":"redoSelection",fallthrough:"basic"},Rs.emacsy={"Ctrl-F":"goCharRight","Ctrl-B":"goCharLeft","Ctrl-P":"goLineUp","Ctrl-N":"goLineDown","Alt-F":"goWordRight","Alt-B":"goWordLeft","Ctrl-A":"goLineStart","Ctrl-E":"goLineEnd","Ctrl-V":"goPageDown","Shift-Ctrl-V":"goPageUp","Ctrl-D":"delCharAfter","Ctrl-H":"delCharBefore","Alt-D":"delWordAfter","Alt-Backspace":"delWordBefore","Ctrl-K":"killLine","Ctrl-T":"transposeChars","Ctrl-O":"openLine"},Rs.macDefault={"Cmd-A":"selectAll","Cmd-D":"deleteLine","Cmd-Z":"undo","Shift-Cmd-Z":"redo","Cmd-Y":"redo","Cmd-Home":"goDocStart","Cmd-Up":"goDocStart","Cmd-End":"goDocEnd","Cmd-Down":"goDocEnd","Alt-Left":"goGroupLeft","Alt-Right":"goGroupRight","Cmd-Left":"goLineLeft","Cmd-Right":"goLineRight","Alt-Backspace":"delGroupBefore","Ctrl-Alt-Backspace":"delGroupAfter","Alt-Delete":"delGroupAfter","Cmd-S":"save","Cmd-F":"find","Cmd-G":"findNext","Shift-Cmd-G":"findPrev","Cmd-Alt-F":"replace","Shift-Cmd-Alt-F":"replaceAll","Cmd-[":"indentLess","Cmd-]":"indentMore","Cmd-Backspace":"delWrappedLineLeft","Cmd-Delete":"delWrappedLineRight","Cmd-U":"undoSelection","Shift-Cmd-U":"redoSelection","Ctrl-Up":"goDocStart","Ctrl-Down":"goDocEnd",fallthrough:["basic","emacsy"]},Rs.default=Ml?Rs.macDefault:Rs.pcDefault;var Bs={selectAll:Mi,singleSelection:function(e){return e.setSelection(e.getCursor("anchor"),e.getCursor("head"),Gl)},killLine:function(e){return co(e,function(t){if(t.empty()){var r=M(e.doc,t.head.line).text.length;return t.head.ch==r&&t.head.line<e.lastLine()?{from:t.head,to:E(t.head.line+1,0)}:{from:t.head,to:E(t.head.line,r)}}return{from:t.from(),to:t.to()}})},deleteLine:function(e){return co(e,function(t){return{from:E(t.from().line,0),to:U(e.doc,E(t.to().line+1,0))}})},delLineLeft:function(e){return co(e,function(e){return{from:E(e.from().line,0),to:e.from()}})},delWrappedLineLeft:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5;return{from:e.coordsChar({left:0,top:r},"div"),to:t.from()}})},delWrappedLineRight:function(e){return co(e,function(t){var r=e.charCoords(t.head,"div").top+5,n=e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div");return{from:t.from(),to:n}})},undo:function(e){return e.undo()},redo:function(e){return e.redo()},undoSelection:function(e){return e.undoSelection()},redoSelection:function(e){return e.redoSelection()},goDocStart:function(e){return e.extendSelection(E(e.firstLine(),0))},goDocEnd:function(e){return e.extendSelection(E(e.lastLine()))},goLineStart:function(e){return e.extendSelectionsBy(function(t){return vo(e,t.head.line)},{origin:"+move",bias:1})},goLineStartSmart:function(e){return e.extendSelectionsBy(function(t){return yo(e,t.head)},{origin:"+move",bias:1})},goLineEnd:function(e){return e.extendSelectionsBy(function(t){return mo(e,t.head.line)},{origin:"+move",bias:-1})},goLineRight:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:e.display.lineDiv.offsetWidth+100,top:r},"div")},Vl)},goLineLeft:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5;return e.coordsChar({left:0,top:r},"div")},Vl)},goLineLeftSmart:function(e){return e.extendSelectionsBy(function(t){var r=e.cursorCoords(t.head,"div").top+5,n=e.coordsChar({left:0,top:r},"div");return n.ch<e.getLine(n.line).search(/\S/)?yo(e,t.head):n},Vl)},goLineUp:function(e){return e.moveV(-1,"line")},goLineDown:function(e){return e.moveV(1,"line")},goPageUp:function(e){return e.moveV(-1,"page")},goPageDown:function(e){return e.moveV(1,"page")},goCharLeft:function(e){return e.moveH(-1,"char")},goCharRight:function(e){return e.moveH(1,"char")},goColumnLeft:function(e){return e.moveH(-1,"column")},goColumnRight:function(e){return e.moveH(1,"column")},goWordLeft:function(e){return e.moveH(-1,"word")},goGroupRight:function(e){return e.moveH(1,"group")},goGroupLeft:function(e){return e.moveH(-1,"group")},goWordRight:function(e){return e.moveH(1,"word")},delCharBefore:function(e){return e.deleteH(-1,"char")},delCharAfter:function(e){return e.deleteH(1,"char")},delWordBefore:function(e){return e.deleteH(-1,"word")},delWordAfter:function(e){return e.deleteH(1,"word")},delGroupBefore:function(e){return e.deleteH(-1,"group")},delGroupAfter:function(e){return e.deleteH(1,"group")},indentAuto:function(e){return e.indentSelection("smart")},indentMore:function(e){return e.indentSelection("add")},indentLess:function(e){return e.indentSelection("subtract")},insertTab:function(e){return e.replaceSelection("\t")},insertSoftTab:function(e){for(var t=[],r=e.listSelections(),n=e.options.tabSize,i=0;i<r.length;i++){var o=r[i].from(),l=f(e.getLine(o.line),o.ch,n);t.push(p(n-l%n))}e.replaceSelections(t)},defaultTab:function(e){e.somethingSelected()?e.indentSelection("add"):e.execCommand("insertTab")},transposeChars:function(e){return hn(e,function(){for(var t=e.listSelections(),r=[],n=0;n<t.length;n++)if(t[n].empty()){var i=t[n].head,o=M(e.doc,i.line).text;if(o)if(i.ch==o.length&&(i=new E(i.line,i.ch-1)),i.ch>0)i=new E(i.line,i.ch+1),e.replaceRange(o.charAt(i.ch-1)+o.charAt(i.ch-2),E(i.line,i.ch-2),i,"+transpose");else if(i.line>e.doc.first){var l=M(e.doc,i.line-1).text;l&&(i=new E(i.line,1),e.replaceRange(o.charAt(0)+e.doc.lineSeparator()+l.charAt(l.length-1),E(i.line-1,l.length-1),i,"+transpose"))}r.push(new Ts(i,i))}e.setSelections(r)})},newlineAndIndent:function(e){return hn(e,function(){for(var t=e.listSelections(),r=t.length-1;r>=0;r--)e.replaceRange(e.doc.lineSeparator(),t[r].anchor,t[r].head,"+input");t=e.listSelections();for(var n=0;n<t.length;n++)e.indentLine(t[n].from().line,null,!0);jr(e)})},openLine:function(e){return e.replaceSelection("\n","start")},toggleOverwrite:function(e){return e.toggleOverwrite()}},Gs=new Pl,Us=null,Vs=function(e,t,r){this.time=e,this.pos=t,this.button=r};Vs.prototype.compare=function(e,t,r){return this.time+400>e&&0==P(t,this.pos)&&r==this.button};var Ks,js,Xs={toString:function(){return"CodeMirror.Init"}},Ys={},_s={};jo.defaults=Ys,jo.optionHandlers=_s;var $s=[];jo.defineInitHook=function(e){return $s.push(e)};var qs=null,Zs=function(e){this.cm=e,this.lastAnchorNode=this.lastAnchorOffset=this.lastFocusNode=this.lastFocusOffset=null,this.polling=new Pl,this.composing=null,this.gracePeriod=!1,this.readDOMTimeout=null};Zs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()}),"cut"==e.type&&i.replaceSelection("",null,"cut");else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type&&i.operation(function(){i.setSelections(t.ranges,0,Gl),i.replaceSelection("",null,"cut")})}if(e.clipboardData){e.clipboardData.clearData();var r=qs.text.join("\n");if(e.clipboardData.setData("Text",r),e.clipboardData.getData("Text")==r)return void e.preventDefault()}var l=el(),s=l.firstChild;i.display.lineSpace.insertBefore(l,i.display.lineSpace.firstChild),s.value=qs.text.join("\n");var a=document.activeElement;El(s),setTimeout(function(){i.display.lineSpace.removeChild(l),a.focus(),a==o&&n.showPrimarySelection()},50)}}var r=this,n=this,i=n.cm,o=n.div=e.lineDiv;Jo(o,i.options.spellcheck),Ql(o,"paste",function(e){Me(i,e)||qo(e,i)||vl<=11&&setTimeout(dn(i,function(){return r.updateFromDOM()}),20)}),Ql(o,"compositionstart",function(e){r.composing={data:e.data,done:!1}}),Ql(o,"compositionupdate",function(e){r.composing||(r.composing={data:e.data,done:!1})}),Ql(o,"compositionend",function(e){r.composing&&(e.data!=r.composing.data&&r.readFromDOMSoon(),r.composing.done=!0)}),Ql(o,"touchstart",function(){return n.forceCompositionEnd()}),Ql(o,"input",function(){r.composing||r.readFromDOMSoon()}),Ql(o,"copy",t),Ql(o,"cut",t)},Zs.prototype.prepareSelection=function(){var e=Tr(this.cm,!1);return e.focus=this.cm.state.focused,e},Zs.prototype.showSelection=function(e,t){e&&this.cm.display.view.length&&((e.focus||t)&&this.showPrimarySelection(),this.showMultipleSelections(e))},Zs.prototype.showPrimarySelection=function(){var e=window.getSelection(),t=this.cm,r=t.doc.sel.primary(),n=r.from(),i=r.to();if(t.display.viewTo==t.display.viewFrom||n.line>=t.display.viewTo||i.line<t.display.viewFrom)e.removeAllRanges();else{var o=sl(t,e.anchorNode,e.anchorOffset),l=sl(t,e.focusNode,e.focusOffset);if(!o||o.bad||!l||l.bad||0!=P(B(o,l),n)||0!=P(R(o,l),i)){var s=t.display.view,a=n.line>=t.display.viewFrom&&nl(t,n)||{node:s[0].measure.map[2],offset:0},u=i.line<t.display.viewTo&&nl(t,i);if(!u){var c=s[s.length-1].measure,f=c.maps?c.maps[c.maps.length-1]:c.map;u={node:f[f.length-1],offset:f[f.length-2]-f[f.length-3]}}if(a&&u){var h,d=e.rangeCount&&e.getRangeAt(0);try{h=Wl(a.node,a.offset,u.offset,u.node)}catch(e){}h&&(!fl&&t.state.focused?(e.collapse(a.node,a.offset),h.collapsed||(e.removeAllRanges(),e.addRange(h))):(e.removeAllRanges(),e.addRange(h)),d&&null==e.anchorNode?e.addRange(d):fl&&this.startGracePeriod()),this.rememberSelection()}else e.removeAllRanges()}}},Zs.prototype.startGracePeriod=function(){var e=this;clearTimeout(this.gracePeriod),this.gracePeriod=setTimeout(function(){e.gracePeriod=!1,e.selectionChanged()&&e.cm.operation(function(){return e.cm.curOp.selectionChanged=!0})},20)},Zs.prototype.showMultipleSelections=function(e){r(this.cm.display.cursorDiv,e.cursors),r(this.cm.display.selectionDiv,e.selection)},Zs.prototype.rememberSelection=function(){var e=window.getSelection();this.lastAnchorNode=e.anchorNode,this.lastAnchorOffset=e.anchorOffset,this.lastFocusNode=e.focusNode,this.lastFocusOffset=e.focusOffset},Zs.prototype.selectionInEditor=function(){var e=window.getSelection();if(!e.rangeCount)return!1;var t=e.getRangeAt(0).commonAncestorContainer;return o(this.div,t)},Zs.prototype.focus=function(){"nocursor"!=this.cm.options.readOnly&&(this.selectionInEditor()||this.showSelection(this.prepareSelection(),!0),this.div.focus())},Zs.prototype.blur=function(){this.div.blur()},Zs.prototype.getField=function(){return this.div},Zs.prototype.supportsTouch=function(){return!0},Zs.prototype.receivedFocus=function(){function e(){t.cm.state.focused&&(t.pollSelection(),t.polling.set(t.cm.options.pollInterval,e))}var t=this;this.selectionInEditor()?this.pollSelection():hn(this.cm,function(){return t.cm.curOp.selectionChanged=!0}),this.polling.set(this.cm.options.pollInterval,e)},Zs.prototype.selectionChanged=function(){var e=window.getSelection();return e.anchorNode!=this.lastAnchorNode||e.anchorOffset!=this.lastAnchorOffset||e.focusNode!=this.lastFocusNode||e.focusOffset!=this.lastFocusOffset},Zs.prototype.pollSelection=function(){if(null==this.readDOMTimeout&&!this.gracePeriod&&this.selectionChanged()){var e=window.getSelection(),t=this.cm;if(kl&&bl&&this.cm.options.gutters.length&&il(e.anchorNode))return this.cm.triggerOnKeyDown({type:"keydown",keyCode:8,preventDefault:Math.abs}),this.blur(),void this.focus();if(!this.composing){this.rememberSelection();var r=sl(t,e.anchorNode,e.anchorOffset),n=sl(t,e.focusNode,e.focusOffset);r&&n&&hn(t,function(){bi(t.doc,Rn(r,n),Gl),(r.bad||n.bad)&&(t.curOp.selectionChanged=!0)})}}},Zs.prototype.pollContent=function(){null!=this.readDOMTimeout&&(clearTimeout(this.readDOMTimeout),this.readDOMTimeout=null);var e=this.cm,t=e.display,r=e.doc.sel.primary(),n=r.from(),i=r.to();if(0==n.ch&&n.line>e.firstLine()&&(n=E(n.line-1,M(e.doc,n.line-1).length)),i.ch==M(e.doc,i.line).text.length&&i.line<e.lastLine()&&(i=E(i.line+1,0)),n.line<t.viewFrom||i.line>t.viewTo-1)return!1;var o,l,s;n.line==t.viewFrom||0==(o=Lr(e,n.line))?(l=W(t.view[0].line),s=t.view[0].node):(l=W(t.view[o].line),s=t.view[o-1].node.nextSibling);var a,u,c=Lr(e,i.line);if(c==t.view.length-1?(a=t.viewTo-1,u=t.lineDiv.lastChild):(a=W(t.view[c+1].line)-1,u=t.view[c+1].node.previousSibling),!s)return!1;for(var f=e.doc.splitLines(ll(e,s,u,l,a)),h=N(e.doc,E(l,0),E(a,M(e.doc,a).text.length));f.length>1&&h.length>1;)if(g(f)==g(h))f.pop(),h.pop(),a--;else{if(f[0]!=h[0])break;f.shift(),h.shift(),l++}for(var d=0,p=0,v=f[0],m=h[0],y=Math.min(v.length,m.length);d<y&&v.charCodeAt(d)==m.charCodeAt(d);)++d;for(var b=g(f),w=g(h),x=Math.min(b.length-(1==f.length?d:0),w.length-(1==h.length?d:0));p<x&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)++p;if(1==f.length&&1==h.length&&l==n.line)for(;d&&d>n.ch&&b.charCodeAt(b.length-p-1)==w.charCodeAt(w.length-p-1);)d--,p++;f[f.length-1]=b.slice(0,b.length-p).replace(/^\u200b+/,""),f[0]=f[0].slice(d).replace(/\u200b+$/,"");var C=E(l,d),S=E(a,h.length?g(h).length-p:0);return f.length>1||f[0]||P(C,S)?(Ei(e.doc,f,C,S,"+input"),!0):void 0},Zs.prototype.ensurePolled=function(){this.forceCompositionEnd()},Zs.prototype.reset=function(){this.forceCompositionEnd()},Zs.prototype.forceCompositionEnd=function(){this.composing&&(clearTimeout(this.readDOMTimeout),this.composing=null,this.updateFromDOM(),this.div.blur(),this.div.focus())},Zs.prototype.readFromDOMSoon=function(){var e=this;null==this.readDOMTimeout&&(this.readDOMTimeout=setTimeout(function(){if(e.readDOMTimeout=null,e.composing){if(!e.composing.done)return;e.composing=null}e.updateFromDOM()},80))},Zs.prototype.updateFromDOM=function(){var e=this;!this.cm.isReadOnly()&&this.pollContent()||hn(this.cm,function(){return vn(e.cm)})},Zs.prototype.setUneditable=function(e){e.contentEditable="false"},Zs.prototype.onKeyPress=function(e){0!=e.charCode&&(e.preventDefault(),this.cm.isReadOnly()||dn(this.cm,$o)(this.cm,String.fromCharCode(null==e.charCode?e.keyCode:e.charCode),0))},Zs.prototype.readOnlyChanged=function(e){this.div.contentEditable=String("nocursor"!=e)},Zs.prototype.onContextMenu=function(){},Zs.prototype.resetPosition=function(){},Zs.prototype.needsContentAttribute=!0;var Qs=function(e){this.cm=e,this.prevInput="",this.pollingFast=!1,this.polling=new Pl,this.hasSelection=!1,this.composing=null};Qs.prototype.init=function(e){function t(e){if(!Me(i,e)){if(i.somethingSelected())_o({lineWise:!1,text:i.getSelections()});else{if(!i.options.lineWiseCopyCut)return;var t=Qo(i);_o({lineWise:!0,text:t.text}),"cut"==e.type?i.setSelections(t.ranges,null,Gl):(n.prevInput="",l.value=t.text.join("\n"),El(l))}"cut"==e.type&&(i.state.cutIncoming=!0)}}var r=this,n=this,i=this.cm,o=this.wrapper=el(),l=this.textarea=o.firstChild;e.wrapper.insertBefore(o,e.wrapper.firstChild),Ll&&(l.style.width="0px"),Ql(l,"input",function(){gl&&vl>=9&&r.hasSelection&&(r.hasSelection=null),n.poll()}),Ql(l,"paste",function(e){Me(i,e)||qo(e,i)||(i.state.pasteIncoming=!0,n.fastPoll())}),Ql(l,"cut",t),Ql(l,"copy",t),Ql(e.scroller,"paste",function(t){Ft(e,t)||Me(i,t)||(i.state.pasteIncoming=!0,n.focus())}),Ql(e.lineSpace,"selectstart",function(t){Ft(e,t)||We(t)}),Ql(l,"compositionstart",function(){var e=i.getCursor("from");n.composing&&n.composing.range.clear(),n.composing={start:e,range:i.markText(e,i.getCursor("to"),{className:"CodeMirror-composing"})}}),Ql(l,"compositionend",function(){n.composing&&(n.poll(),n.composing.range.clear(),n.composing=null)})},Qs.prototype.prepareSelection=function(){var e=this.cm,t=e.display,r=e.doc,n=Tr(e);if(e.options.moveInputWithCursor){var i=sr(e,r.sel.primary().head,"div"),o=t.wrapper.getBoundingClientRect(),l=t.lineDiv.getBoundingClientRect();n.teTop=Math.max(0,Math.min(t.wrapper.clientHeight-10,i.top+l.top-o.top)),n.teLeft=Math.max(0,Math.min(t.wrapper.clientWidth-10,i.left+l.left-o.left))}return n},Qs.prototype.showSelection=function(e){var t=this.cm.display;r(t.cursorDiv,e.cursors),r(t.selectionDiv,e.selection),null!=e.teTop&&(this.wrapper.style.top=e.teTop+"px",this.wrapper.style.left=e.teLeft+"px")},Qs.prototype.reset=function(e){if(!this.contextMenuPending&&!this.composing){var t=this.cm;if(t.somethingSelected()){this.prevInput="";var r=t.getSelection();this.textarea.value=r,t.state.focused&&El(this.textarea),gl&&vl>=9&&(this.hasSelection=r)}else e||(this.prevInput=this.textarea.value="",gl&&vl>=9&&(this.hasSelection=null))}},Qs.prototype.getField=function(){return this.textarea},Qs.prototype.supportsTouch=function(){return!1},Qs.prototype.focus=function(){if("nocursor"!=this.cm.options.readOnly&&(!Tl||l()!=this.textarea))try{this.textarea.focus()}catch(e){}},Qs.prototype.blur=function(){this.textarea.blur()},Qs.prototype.resetPosition=function(){this.wrapper.style.top=this.wrapper.style.left=0},Qs.prototype.receivedFocus=function(){this.slowPoll()},Qs.prototype.slowPoll=function(){var e=this;this.pollingFast||this.polling.set(this.cm.options.pollInterval,function(){e.poll(),e.cm.state.focused&&e.slowPoll()})},Qs.prototype.fastPoll=function(){function e(){r.poll()||t?(r.pollingFast=!1,r.slowPoll()):(t=!0,r.polling.set(60,e))}var t=!1,r=this;r.pollingFast=!0,r.polling.set(20,e)},Qs.prototype.poll=function(){var e=this,t=this.cm,r=this.textarea,n=this.prevInput;if(this.contextMenuPending||!t.state.focused||ts(r)&&!n&&!this.composing||t.isReadOnly()||t.options.disableInput||t.state.keySeq)return!1;var i=r.value;if(i==n&&!t.somethingSelected())return!1;if(gl&&vl>=9&&this.hasSelection===i||Ml&&/[\uf700-\uf7ff]/.test(i))return t.display.input.reset(),!1;if(t.doc.sel==t.display.selForContextMenu){var o=i.charCodeAt(0);if(8203!=o||n||(n="​"),8666==o)return this.reset(),this.cm.execCommand("undo")}for(var l=0,s=Math.min(n.length,i.length);l<s&&n.charCodeAt(l)==i.charCodeAt(l);)++l;return hn(t,function(){$o(t,i.slice(l),n.length-l,null,e.composing?"*compose":null),i.length>1e3||i.indexOf("\n")>-1?r.value=e.prevInput="":e.prevInput=i,e.composing&&(e.composing.range.clear(),e.composing.range=t.markText(e.composing.start,t.getCursor("to"),{className:"CodeMirror-composing"}))}),!0},Qs.prototype.ensurePolled=function(){this.pollingFast&&this.poll()&&(this.pollingFast=!1)},Qs.prototype.onKeyPress=function(){gl&&vl>=9&&(this.hasSelection=null),this.fastPoll()},Qs.prototype.onContextMenu=function(e){function t(){if(null!=l.selectionStart){var e=i.somethingSelected(),t="​"+(e?l.value:"");l.value="⇚",l.value=t,n.prevInput=e?"":"​",l.selectionStart=1,l.selectionEnd=t.length,o.selForContextMenu=i.doc.sel}}function r(){if(n.contextMenuPending=!1,n.wrapper.style.cssText=c,l.style.cssText=u,gl&&vl<9&&o.scrollbars.setScrollTop(o.scroller.scrollTop=a),null!=l.selectionStart){(!gl||gl&&vl<9)&&t();var e=0,r=function(){o.selForContextMenu==i.doc.sel&&0==l.selectionStart&&l.selectionEnd>0&&"​"==n.prevInput?dn(i,Mi)(i):e++<10?o.detectingSelectAll=setTimeout(r,500):(o.selForContextMenu=null,o.input.reset())};o.detectingSelectAll=setTimeout(r,200)}}var n=this,i=n.cm,o=i.display,l=n.textarea,s=Sr(i,e),a=o.scroller.scrollTop;if(s&&!wl){i.options.resetSelectionOnContextMenu&&-1==i.doc.sel.contains(s)&&dn(i,bi)(i.doc,Rn(s),Gl);var u=l.style.cssText,c=n.wrapper.style.cssText;n.wrapper.style.cssText="position: absolute";var f=n.wrapper.getBoundingClientRect();l.style.cssText="position: absolute; width: 30px; height: 30px;\n      top: "+(e.clientY-f.top-5)+"px; left: "+(e.clientX-f.left-5)+"px;\n      z-index: 1000; background: "+(gl?"rgba(255, 255, 255, .05)":"transparent")+";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";var h;if(ml&&(h=window.scrollY),o.input.focus(),ml&&window.scrollTo(null,h),o.input.reset(),i.somethingSelected()||(l.value=n.prevInput=" "),n.contextMenuPending=!0,o.selForContextMenu=i.doc.sel,clearTimeout(o.detectingSelectAll),gl&&vl>=9&&t(),Hl){Fe(e);var d=function(){ke(window,"mouseup",d),setTimeout(r,20)};Ql(window,"mouseup",d)}else setTimeout(r,50)}},Qs.prototype.readOnlyChanged=function(e){e||this.reset(),this.textarea.disabled="nocursor"==e},Qs.prototype.setUneditable=function(){},Qs.prototype.needsContentAttribute=!1,function(e){function t(t,n,i,o){e.defaults[t]=n,i&&(r[t]=o?function(e,t,r){r!=Xs&&i(e,t,r)}:i)}var r=e.optionHandlers;e.defineOption=t,e.Init=Xs,t("value","",function(e,t){return e.setValue(t)},!0),t("mode",null,function(e,t){e.doc.modeOption=t,jn(e)},!0),t("indentUnit",2,jn,!0),t("indentWithTabs",!1),t("smartIndent",!0),t("tabSize",4,function(e){Xn(e),er(e),vn(e)},!0),t("lineSeparator",null,function(e,t){if(e.doc.lineSep=t,t){var r=[],n=e.doc.first;e.doc.iter(function(e){for(var i=0;;){var o=e.text.indexOf(t,i);if(-1==o)break;i=o+t.length,r.push(E(n,o))}n++});for(var i=r.length-1;i>=0;i--)Ei(e.doc,t,r[i],E(r[i].line,r[i].ch+t.length))}}),t("specialChars",/[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff]/g,function(e,t,r){e.state.specialChars=new RegExp(t.source+(t.test("\t")?"":"|\t"),"g"),r!=Xs&&e.refresh()}),t("specialCharPlaceholder",at,function(e){return e.refresh()},!0),t("electricChars",!0),t("inputStyle",Tl?"contenteditable":"textarea",function(){throw new Error("inputStyle can not (yet) be changed in a running editor")},!0),t("spellcheck",!1,function(e,t){return e.getInputField().spellcheck=t},!0),t("rtlMoveVisually",!Ol),t("wholeLineUpdateBefore",!0),t("theme","default",function(e){Go(e),Uo(e)},!0),t("keyMap","default",function(e,t,r){var n=uo(t),i=r!=Xs&&uo(r);i&&i.detach&&i.detach(e,n),n.attach&&n.attach(e,i||null)}),t("extraKeys",null),t("configureMouse",null),t("lineWrapping",!1,Ko,!0),t("gutters",[],function(e){Fn(e.options),Uo(e)},!0),t("fixedGutter",!0,function(e,t){e.display.gutters.style.left=t?wr(e.display)+"px":"0",e.refresh()},!0),t("coverGutterNextToScrollbar",!1,function(e){return en(e)},!0),t("scrollbarStyle","native",function(e){rn(e),en(e),e.display.scrollbars.setScrollTop(e.doc.scrollTop),e.display.scrollbars.setScrollLeft(e.doc.scrollLeft)},!0),t("lineNumbers",!1,function(e){Fn(e.options),Uo(e)},!0),t("firstLineNumber",1,Uo,!0),t("lineNumberFormatter",function(e){return e},Uo,!0),t("showCursorWhenSelecting",!1,kr,!0),t("resetSelectionOnContextMenu",!0),t("lineWiseCopyCut",!0),t("pasteLinesPerSelection",!0),t("readOnly",!1,function(e,t){"nocursor"==t&&(Fr(e),e.display.input.blur()),e.display.input.readOnlyChanged(t)}),t("disableInput",!1,function(e,t){t||e.display.input.reset()},!0),t("dragDrop",!0,Vo),t("allowDropFileTypes",null),t("cursorBlinkRate",530),t("cursorScrollMargin",0),t("cursorHeight",1,kr,!0),t("singleCursorHeightPerLine",!0,kr,!0),t("workTime",100),t("workDelay",100),t("flattenSpans",!0,Xn,!0),t("addModeClass",!1,Xn,!0),t("pollInterval",100),t("undoDepth",200,function(e,t){return e.doc.history.undoDepth=t}),t("historyEventDelay",1250),t("viewportMargin",10,function(e){return e.refresh()},!0),t("maxHighlightLength",1e4,Xn,!0),t("moveInputWithCursor",!0,function(e,t){t||e.display.input.resetPosition()}),t("tabindex",null,function(e,t){return e.display.input.getField().tabIndex=t||""}),t("autofocus",null),t("direction","ltr",function(e,t){return e.doc.setDirection(t)},!0)}(jo),function(e){var t=e.optionHandlers,r=e.helpers={};e.prototype={constructor:e,focus:function(){window.focus(),this.display.input.focus()},setOption:function(e,r){var n=this.options,i=n[e];n[e]==r&&"mode"!=e||(n[e]=r,t.hasOwnProperty(e)&&dn(this,t[e])(this,r,i),Te(this,"optionChange",this,e))},getOption:function(e){return this.options[e]},getDoc:function(){return this.doc},addKeyMap:function(e,t){this.state.keyMaps[t?"push":"unshift"](uo(e))},removeKeyMap:function(e){for(var t=this.state.keyMaps,r=0;r<t.length;++r)if(t[r]==e||t[r].name==e)return t.splice(r,1),!0},addOverlay:pn(function(t,r){var n=t.token?t:e.getMode(this.options,t);if(n.startState)throw new Error("Overlays may not be stateful.");m(this.state.overlays,{mode:n,modeSpec:t,opaque:r&&r.opaque,priority:r&&r.priority||0},function(e){return e.priority}),this.state.modeGen++,vn(this)}),removeOverlay:pn(function(e){for(var t=this,r=this.state.overlays,n=0;n<r.length;++n){var i=r[n].modeSpec;if(i==e||"string"==typeof e&&i.name==e)return r.splice(n,1),t.state.modeGen++,void vn(t)}}),indentLine:pn(function(e,t,r){"string"!=typeof t&&"number"!=typeof t&&(t=null==t?this.options.smartIndent?"smart":"prev":t?"add":"subtract"),H(this.doc,e)&&Yo(this,e,t,r)}),indentSelection:pn(function(e){for(var t=this,r=this.doc.sel.ranges,n=-1,i=0;i<r.length;i++){var o=r[i];if(o.empty())o.head.line>n&&(Yo(t,o.head.line,e,!0),n=o.head.line,i==t.doc.sel.primIndex&&jr(t));else{var l=o.from(),s=o.to(),a=Math.max(n,l.line);n=Math.min(t.lastLine(),s.line-(s.ch?0:1))+1;for(var u=a;u<n;++u)Yo(t,u,e);var c=t.doc.sel.ranges;0==l.ch&&r.length==c.length&&c[i].from().ch>0&&gi(t.doc,i,new Ts(l,c[i].to()),Gl)}}}),getTokenAt:function(e,t){return Je(this,e,t)},getLineTokens:function(e,t){return Je(this,E(e),t,!0)},getTokenTypeAt:function(e){e=U(this.doc,e);var t,r=_e(this,M(this.doc,e.line)),n=0,i=(r.length-1)/2,o=e.ch;if(0==o)t=r[2];else for(;;){var l=n+i>>1;if((l?r[2*l-1]:0)>=o)i=l;else{if(!(r[2*l+1]<o)){t=r[2*l+2];break}n=l+1}}var s=t?t.indexOf("overlay "):-1;return s<0?t:0==s?null:t.slice(0,s-1)},getModeAt:function(t){var r=this.doc.mode;return r.innerMode?e.innerMode(r,this.getTokenAt(t).state).mode:r},getHelper:function(e,t){return this.getHelpers(e,t)[0]},getHelpers:function(e,t){var n=this,i=[];if(!r.hasOwnProperty(t))return i;var o=r[t],l=this.getModeAt(e);if("string"==typeof l[t])o[l[t]]&&i.push(o[l[t]]);else if(l[t])for(var s=0;s<l[t].length;s++){var a=o[l[t][s]];a&&i.push(a)}else l.helperType&&o[l.helperType]?i.push(o[l.helperType]):o[l.name]&&i.push(o[l.name]);for(var u=0;u<o._global.length;u++){var c=o._global[u];c.pred(l,n)&&-1==h(i,c.val)&&i.push(c.val)}return i},getStateAfter:function(e,t){var r=this.doc;return e=G(r,null==e?r.first+r.size-1:e),$e(this,e+1,t).state},cursorCoords:function(e,t){var r,n=this.doc.sel.primary();return r=null==e?n.head:"object"==typeof e?U(this.doc,e):e?n.from():n.to(),sr(this,r,t||"page")},charCoords:function(e,t){return lr(this,U(this.doc,e),t||"page")},coordsChar:function(e,t){return e=or(this,e,t||"page"),cr(this,e.left,e.top)},lineAtHeight:function(e,t){return e=or(this,{top:e,left:0},t||"page").top,D(this.doc,e+this.display.viewOffset)},heightAtLine:function(e,t,r){var n,i=!1;if("number"==typeof e){var o=this.doc.first+this.doc.size-1;e<this.doc.first?e=this.doc.first:e>o&&(e=o,i=!0),n=M(this.doc,e)}else n=e;return ir(this,n,{top:0,left:0},t||"page",r||i).top+(i?this.doc.height-ye(n):0)},defaultTextHeight:function(){return mr(this.display)},defaultCharWidth:function(){return yr(this.display)},getViewport:function(){return{from:this.display.viewFrom,to:this.display.viewTo}},addWidget:function(e,t,r,n,i){var o=this.display,l=(e=sr(this,U(this.doc,e))).bottom,s=e.left;if(t.style.position="absolute",t.setAttribute("cm-ignore-events","true"),this.display.input.setUneditable(t),o.sizer.appendChild(t),"over"==n)l=e.top;else if("above"==n||"near"==n){var a=Math.max(o.wrapper.clientHeight,this.doc.height),u=Math.max(o.sizer.clientWidth,o.lineSpace.clientWidth);("above"==n||e.bottom+t.offsetHeight>a)&&e.top>t.offsetHeight?l=e.top-t.offsetHeight:e.bottom+t.offsetHeight<=a&&(l=e.bottom),s+t.offsetWidth>u&&(s=u-t.offsetWidth)}t.style.top=l+"px",t.style.left=t.style.right="","right"==i?(s=o.sizer.clientWidth-t.offsetWidth,t.style.right="0px"):("left"==i?s=0:"middle"==i&&(s=(o.sizer.clientWidth-t.offsetWidth)/2),t.style.left=s+"px"),r&&Ur(this,{left:s,top:l,right:s+t.offsetWidth,bottom:l+t.offsetHeight})},triggerOnKeyDown:pn(Lo),triggerOnKeyPress:pn(Mo),triggerOnKeyUp:To,triggerOnMouseDown:pn(Oo),execCommand:function(e){if(Bs.hasOwnProperty(e))return Bs[e].call(null,this)},triggerElectric:pn(function(e){Zo(this,e)}),findPosH:function(e,t,r,n){var i=this,o=1;t<0&&(o=-1,t=-t);for(var l=U(this.doc,e),s=0;s<t&&!(l=tl(i.doc,l,o,r,n)).hitSide;++s);return l},moveH:pn(function(e,t){var r=this;this.extendSelectionsBy(function(n){return r.display.shift||r.doc.extend||n.empty()?tl(r.doc,n.head,e,t,r.options.rtlMoveVisually):e<0?n.from():n.to()},Vl)}),deleteH:pn(function(e,t){var r=this.doc.sel,n=this.doc;r.somethingSelected()?n.replaceSelection("",null,"+delete"):co(this,function(r){var i=tl(n,r.head,e,t,!1);return e<0?{from:i,to:r.head}:{from:r.head,to:i}})}),findPosV:function(e,t,r,n){var i=this,o=1,l=n;t<0&&(o=-1,t=-t);for(var s=U(this.doc,e),a=0;a<t;++a){var u=sr(i,s,"div");if(null==l?l=u.left:u.left=l,(s=rl(i,u,o,r)).hitSide)break}return s},moveV:pn(function(e,t){var r=this,n=this.doc,i=[],o=!this.display.shift&&!n.extend&&n.sel.somethingSelected();if(n.extendSelectionsBy(function(l){if(o)return e<0?l.from():l.to();var s=sr(r,l.head,"div");null!=l.goalColumn&&(s.left=l.goalColumn),i.push(s.left);var a=rl(r,s,e,t);return"page"==t&&l==n.sel.primary()&&Kr(r,lr(r,a,"div").top-s.top),a},Vl),i.length)for(var l=0;l<n.sel.ranges.length;l++)n.sel.ranges[l].goalColumn=i[l]}),findWordAt:function(e){var t=M(this.doc,e.line).text,r=e.ch,n=e.ch;if(t){var i=this.getHelper(e,"wordChars");"before"!=e.sticky&&n!=t.length||!r?++n:--r;for(var o=t.charAt(r),l=x(o,i)?function(e){return x(e,i)}:/\s/.test(o)?function(e){return/\s/.test(e)}:function(e){return!/\s/.test(e)&&!x(e)};r>0&&l(t.charAt(r-1));)--r;for(;n<t.length&&l(t.charAt(n));)++n}return new Ts(E(e.line,r),E(e.line,n))},toggleOverwrite:function(e){null!=e&&e==this.state.overwrite||((this.state.overwrite=!this.state.overwrite)?s(this.display.cursorDiv,"CodeMirror-overwrite"):Fl(this.display.cursorDiv,"CodeMirror-overwrite"),Te(this,"overwriteToggle",this,this.state.overwrite))},hasFocus:function(){return this.display.input.getField()==l()},isReadOnly:function(){return!(!this.options.readOnly&&!this.doc.cantEdit)},scrollTo:pn(function(e,t){Xr(this,e,t)}),getScrollInfo:function(){var e=this.display.scroller;return{left:e.scrollLeft,top:e.scrollTop,height:e.scrollHeight-zt(this)-this.display.barHeight,width:e.scrollWidth-zt(this)-this.display.barWidth,clientHeight:Bt(this),clientWidth:Rt(this)}},scrollIntoView:pn(function(e,t){null==e?(e={from:this.doc.sel.primary().head,to:null},null==t&&(t=this.options.cursorScrollMargin)):"number"==typeof e?e={from:E(e,0),to:null}:null==e.from&&(e={from:e,to:null}),e.to||(e.to=e.from),e.margin=t||0,null!=e.from.line?Yr(this,e):$r(this,e.from,e.to,e.margin)}),setSize:pn(function(e,t){var r=this,n=function(e){return"number"==typeof e||/^\d+$/.test(String(e))?e+"px":e};null!=e&&(this.display.wrapper.style.width=n(e)),null!=t&&(this.display.wrapper.style.height=n(t)),this.options.lineWrapping&&Jt(this);var i=this.display.viewFrom;this.doc.iter(i,this.display.viewTo,function(e){if(e.widgets)for(var t=0;t<e.widgets.length;t++)if(e.widgets[t].noHScroll){mn(r,i,"widget");break}++i}),this.curOp.forceUpdate=!0,Te(this,"refresh",this)}),operation:function(e){return hn(this,e)},startOperation:function(){return nn(this)},endOperation:function(){return on(this)},refresh:pn(function(){var e=this.display.cachedTextHeight;vn(this),this.curOp.forceUpdate=!0,er(this),Xr(this,this.doc.scrollLeft,this.doc.scrollTop),Wn(this),(null==e||Math.abs(e-mr(this.display))>.5)&&Cr(this),Te(this,"refresh",this)}),swapDoc:pn(function(e){var t=this.doc;return t.cm=null,qn(this,e),er(this),this.display.input.reset(),Xr(this,e.scrollLeft,e.scrollTop),this.curOp.forceScroll=!0,bt(this,"swapDoc",this,t),t}),getInputField:function(){return this.display.input.getField()},getWrapperElement:function(){return this.display.wrapper},getScrollerElement:function(){return this.display.scroller},getGutterElement:function(){return this.display.gutters}},Ae(e),e.registerHelper=function(t,n,i){r.hasOwnProperty(t)||(r[t]=e[t]={_global:[]}),r[t][n]=i},e.registerGlobalHelper=function(t,n,i,o){e.registerHelper(t,n,o),r[t]._global.push({pred:i,val:o})}}(jo);var Js="iter insert remove copy getEditor constructor".split(" ");for(var ea in Ds.prototype)Ds.prototype.hasOwnProperty(ea)&&h(Js,ea)<0&&(jo.prototype[ea]=function(e){return function(){return e.apply(this.doc,arguments)}}(Ds.prototype[ea]));return Ae(Ds),jo.inputStyles={textarea:Qs,contenteditable:Zs},jo.defineMode=function(e){jo.defaults.mode||"null"==e||(jo.defaults.mode=e),Be.apply(this,arguments)},jo.defineMIME=function(e,t){os[e]=t},jo.defineMode("null",function(){return{token:function(e){return e.skipToEnd()}}}),jo.defineMIME("text/plain","null"),jo.defineExtension=function(e,t){jo.prototype[e]=t},jo.defineDocExtension=function(e,t){Ds.prototype[e]=t},jo.fromTextArea=function(e,t){function r(){e.value=a.getValue()}if(t=t?c(t):{},t.value=e.value,!t.tabindex&&e.tabIndex&&(t.tabindex=e.tabIndex),!t.placeholder&&e.placeholder&&(t.placeholder=e.placeholder),null==t.autofocus){var n=l();t.autofocus=n==e||null!=e.getAttribute("autofocus")&&n==document.body}var i;if(e.form&&(Ql(e.form,"submit",r),!t.leaveSubmitMethodAlone)){var o=e.form;i=o.submit;try{var s=o.submit=function(){r(),o.submit=i,o.submit(),o.submit=s}}catch(e){}}t.finishInit=function(t){t.save=r,t.getTextArea=function(){return e},t.toTextArea=function(){t.toTextArea=isNaN,r(),e.parentNode.removeChild(t.getWrapperElement()),e.style.display="",e.form&&(ke(e.form,"submit",r),"function"==typeof e.form.submit&&(e.form.submit=i))}},e.style.display="none";var a=jo(function(t){return e.parentNode.insertBefore(t,e.nextSibling)},t);return a},function(e){e.off=ke,e.on=Ql,e.wheelEventPixels=Pn,e.Doc=Ds,e.splitLines=es,e.countColumn=f,e.findColumn=d,e.isWordChar=w,e.Pass=Bl,e.signal=Te,e.Line=fs,e.changeEnd=Bn,e.scrollbarModel=ws,e.Pos=E,e.cmpPos=P,e.modes=is,e.mimeModes=os,e.resolveMode=Ge,e.getMode=Ue,e.modeExtensions=ls,e.extendMode=Ve,e.copyState=Ke,e.startState=Xe,e.innerMode=je,e.commands=Bs,e.keyMap=Rs,e.keyName=ao,e.isModifierKey=lo,e.lookupKey=oo,e.normalizeKeyMap=io,e.StringStream=ss,e.SharedTextMarker=As,e.TextMarker=Os,e.LineWidget=Ms,e.e_preventDefault=We,e.e_stopPropagation=De,e.e_stop=Fe,e.addClass=s,e.contains=o,e.rmClass=Fl,e.keyNames=Es}(jo),jo.version="5.30.0",jo});
      !function(e){"object"==typeof exports&&"object"==typeof module?e(require("../../lib/codemirror")):"function"==typeof define&&define.amd?define(["../../lib/codemirror"],e):e(CodeMirror)}(function(e){"use strict";function t(e,t,n,r,o,a){this.indented=e,this.column=t,this.type=n,this.info=r,this.align=o,this.prev=a}function n(e,n,r,o){var a=e.indented;return e.context&&"statement"==e.context.type&&"statement"!=r&&(a=e.context.indented),e.context=new t(a,n,r,o,null,e.context)}function r(e){var t=e.context.type;return")"!=t&&"]"!=t&&"}"!=t||(e.indented=e.context.indented),e.context=e.context.prev}function o(e,t,n){return"variable"==t.prevToken||"type"==t.prevToken||(!!/\S(?:[^- ]>|[*\]])\s*$|\*$/.test(e.string.slice(0,n))||(!(!t.typeAtEndOfLine||e.column()!=e.indentation())||void 0))}function a(e){for(;;){if(!e||"top"==e.type)return!0;if("}"==e.type&&"namespace"!=e.prev.info)return!1;e=e.prev}}function i(e){for(var t={},n=e.split(" "),r=0;r<n.length;++r)t[n[r]]=!0;return t}function l(e,t){return"function"==typeof e?e(t):e.propertyIsEnumerable(t)}function s(e,t){if(!t.startOfLine)return!1;for(var n,r=null;n=e.peek();){if("\\"==n&&e.match(/^.$/)){r=s;break}if("/"==n&&e.match(/^\/[\/\*]/,!1))break;e.next()}return t.tokenize=r,"meta"}function c(e,t){return"type"==t.prevToken&&"type"}function u(e){return e.eatWhile(/[\w\.']/),"number"}function d(e,t){if(e.backUp(1),e.match(/(R|u8R|uR|UR|LR)/)){var n=e.match(/"([^\s\\()]{0,16})\(/);return!!n&&(t.cpp11RawStringDelim=n[1],t.tokenize=m,m(e,t))}return e.match(/(u8|u|U|L)/)?!!e.match(/["']/,!1)&&"string":(e.next(),!1)}function f(e){var t=/(\w+)::~?(\w+)$/.exec(e);return t&&t[1]==t[2]}function p(e,t){for(var n;null!=(n=e.next());)if('"'==n&&!e.eat('"')){t.tokenize=null;break}return"string"}function m(e,t){var n=t.cpp11RawStringDelim.replace(/[^\w\s]/g,"\\$&");return e.match(new RegExp(".*?\\)"+n+'"'))?t.tokenize=null:e.skipToEnd(),"string"}function h(t,n){function r(e){if(e)for(var t in e)e.hasOwnProperty(t)&&o.push(t)}"string"==typeof t&&(t=[t]);var o=[];r(n.keywords),r(n.types),r(n.builtin),r(n.atoms),o.length&&(n.helperType=t[0],e.registerHelper("hintWords",t[0],o));for(var a=0;a<t.length;++a)e.defineMIME(t[a],n)}function g(e,t){for(var n=!1;!e.eol();){if(!n&&e.match('"""')){t.tokenize=null;break}n="\\"==e.next()&&!n}return"string"}function y(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!e&&!o&&t.match('"')){a=!0;break}if(e&&t.match('"""')){a=!0;break}r=t.next(),!o&&"$"==r&&t.match("{")&&t.skipTo("}"),o=!o&&"\\"==r&&!e}return!a&&e||(n.tokenize=null),"string"}}function x(e){return function(t,n){for(var r,o=!1,a=!1;!t.eol();){if(!o&&t.match('"')&&("single"==e||t.match('""'))){a=!0;break}if(!o&&t.match("``")){w=x(e),a=!0;break}r=t.next(),o="single"==e&&!o&&"\\"==r}return a&&(n.tokenize=null),"string"}}e.defineMode("clike",function(i,s){function c(e,t){var n=e.next();if(S[n]){var r=S[n](e,t);if(!1!==r)return r}if('"'==n||"'"==n)return t.tokenize=u(n),t.tokenize(e,t);if(D.test(n))return p=n,null;if(L.test(n)){if(e.backUp(1),e.match(I))return"number";e.next()}if("/"==n){if(e.eat("*"))return t.tokenize=d,d(e,t);if(e.eat("/"))return e.skipToEnd(),"comment"}if(F.test(n)){for(;!e.match(/^\/[\/*]/,!1)&&e.eat(F););return"operator"}if(e.eatWhile(z),P)for(;e.match(P);)e.eatWhile(z);var o=e.current();return l(x,o)?(l(w,o)&&(p="newstatement"),l(v,o)&&(m=!0),"keyword"):l(b,o)?"type":l(k,o)?(l(w,o)&&(p="newstatement"),"builtin"):l(_,o)?"atom":"variable"}function u(e){return function(t,n){for(var r,o=!1,a=!1;null!=(r=t.next());){if(r==e&&!o){a=!0;break}o=!o&&"\\"==r}return(a||!o&&!C)&&(n.tokenize=null),"string"}}function d(e,t){for(var n,r=!1;n=e.next();){if("/"==n&&r){t.tokenize=null;break}r="*"==n}return"comment"}function f(e,t){s.typeFirstDefinitions&&e.eol()&&a(t.context)&&(t.typeAtEndOfLine=o(e,t,e.pos))}var p,m,h=i.indentUnit,g=s.statementIndentUnit||h,y=s.dontAlignCalls,x=s.keywords||{},b=s.types||{},k=s.builtin||{},w=s.blockKeywords||{},v=s.defKeywords||{},_=s.atoms||{},S=s.hooks||{},C=s.multiLineStrings,T=!1!==s.indentStatements,M=!1!==s.indentSwitch,P=s.namespaceSeparator,D=s.isPunctuationChar||/[\[\]{}\(\),;\:\.]/,L=s.numberStart||/[\d\.]/,I=s.number||/^(?:0x[a-f\d]+|0b[01]+|(?:\d+\.?\d*|\.\d+)(?:e[-+]?\d+)?)(u|ll?|l|f)?/i,F=s.isOperatorChar||/[+\-*&%=<>!?|\/]/,z=s.isIdentifierChar||/[\w\$_\xa1-\uffff]/;return{startState:function(e){return{tokenize:null,context:new t((e||0)-h,0,"top",null,!1),indented:0,startOfLine:!0,prevToken:null}},token:function(e,t){var i=t.context;if(e.sol()&&(null==i.align&&(i.align=!1),t.indented=e.indentation(),t.startOfLine=!0),e.eatSpace())return f(e,t),null;p=m=null;var l=(t.tokenize||c)(e,t);if("comment"==l||"meta"==l)return l;if(null==i.align&&(i.align=!0),";"==p||":"==p||","==p&&e.match(/^\s*(?:\/\/.*)?$/,!1))for(;"statement"==t.context.type;)r(t);else if("{"==p)n(t,e.column(),"}");else if("["==p)n(t,e.column(),"]");else if("("==p)n(t,e.column(),")");else if("}"==p){for(;"statement"==i.type;)i=r(t);for("}"==i.type&&(i=r(t));"statement"==i.type;)i=r(t)}else p==i.type?r(t):T&&(("}"==i.type||"top"==i.type)&&";"!=p||"statement"==i.type&&"newstatement"==p)&&n(t,e.column(),"statement",e.current());if("variable"==l&&("def"==t.prevToken||s.typeFirstDefinitions&&o(e,t,e.start)&&a(t.context)&&e.match(/^\s*\(/,!1))&&(l="def"),S.token){var u=S.token(e,t,l);void 0!==u&&(l=u)}return"def"==l&&!1===s.styleDefs&&(l="variable"),t.startOfLine=!1,t.prevToken=m?"def":l||p,f(e,t),l},indent:function(t,n){if(t.tokenize!=c&&null!=t.tokenize||t.typeAtEndOfLine)return e.Pass;var r=t.context,o=n&&n.charAt(0);if("statement"==r.type&&"}"==o&&(r=r.prev),s.dontIndentStatements)for(;"statement"==r.type&&s.dontIndentStatements.test(r.info);)r=r.prev;if(S.indent){var a=S.indent(t,r,n);if("number"==typeof a)return a}var i=o==r.type,l=r.prev&&"switch"==r.prev.info;if(s.allmanIndentation&&/[{(]/.test(o)){for(;"top"!=r.type&&"}"!=r.type;)r=r.prev;return r.indented}return"statement"==r.type?r.indented+("{"==o?0:g):!r.align||y&&")"==r.type?")"!=r.type||i?r.indented+(i?0:h)+(i||!l||/^(?:case|default)\b/.test(n)?0:h):r.indented+g:r.column+(i?0:1)},electricInput:M?/^\s*(?:case .*?:|default:|\{\}?|\})$/:/^\s*[{}]$/,blockCommentStart:"/*",blockCommentEnd:"*/",lineComment:"//",fold:"brace"}});var b="auto if break case register continue return default do sizeof static else struct switch extern typedef union for goto while enum const volatile",k="int long char short double float unsigned signed void size_t ptrdiff_t";h(["text/x-csrc","text/x-c","text/x-chdr"],{name:"clike",keywords:i(b),types:i(k+" bool _Complex _Bool float_t double_t intptr_t intmax_t int8_t int16_t int32_t int64_t uintptr_t uintmax_t uint8_t uint16_t uint32_t uint64_t"),blockKeywords:i("case do else for if switch while struct"),defKeywords:i("struct"),typeFirstDefinitions:!0,atoms:i("null true false"),hooks:{"#":s,"*":c},modeProps:{fold:["brace","include"]}}),h(["text/x-c++src","text/x-c++hdr"],{name:"clike",keywords:i(b+" asm dynamic_cast namespace reinterpret_cast try explicit new static_cast typeid catch operator template typename class friend private this using const_cast inline public throw virtual delete mutable protected alignas alignof constexpr decltype nullptr noexcept thread_local final static_assert override"),types:i(k+" bool wchar_t"),blockKeywords:i("catch class do else finally for if struct switch try while"),defKeywords:i("class namespace struct enum union"),typeFirstDefinitions:!0,atoms:i("true false null"),dontIndentStatements:/^template$/,isIdentifierChar:/[\w\$_~\xa1-\uffff]/,hooks:{"#":s,"*":c,u:d,U:d,L:d,R:d,0:u,1:u,2:u,3:u,4:u,5:u,6:u,7:u,8:u,9:u,token:function(e,t,n){if("variable"==n&&"("==e.peek()&&(";"==t.prevToken||null==t.prevToken||"}"==t.prevToken)&&f(e.current()))return"def"}},namespaceSeparator:"::",modeProps:{fold:["brace","include"]}}),h("text/x-java",{name:"clike",keywords:i("abstract assert break case catch class const continue default do else enum extends final finally float for goto if implements import instanceof interface native new package private protected public return static strictfp super switch synchronized this throw throws transient try volatile while @interface"),types:i("byte short int long float double boolean char void Boolean Byte Character Double Float Integer Long Number Object Short String StringBuffer StringBuilder Void"),blockKeywords:i("catch class do else finally for if switch try while"),defKeywords:i("class interface package enum @interface"),typeFirstDefinitions:!0,atoms:i("true false null"),number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,hooks:{"@":function(e){return!e.match("interface",!1)&&(e.eatWhile(/[\w\$_]/),"meta")}},modeProps:{fold:["brace","import"]}}),h("text/x-csharp",{name:"clike",keywords:i("abstract as async await base break case catch checked class const continue default delegate do else enum event explicit extern finally fixed for foreach goto if implicit in interface internal is lock namespace new operator out override params private protected public readonly ref return sealed sizeof stackalloc static struct switch this throw try typeof unchecked unsafe using virtual void volatile while add alias ascending descending dynamic from get global group into join let orderby partial remove select set value var yield"),types:i("Action Boolean Byte Char DateTime DateTimeOffset Decimal Double Func Guid Int16 Int32 Int64 Object SByte Single String Task TimeSpan UInt16 UInt32 UInt64 bool byte char decimal double short int long object sbyte float string ushort uint ulong"),blockKeywords:i("catch class do else finally for foreach if struct switch try while"),defKeywords:i("class interface namespace struct var"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"@":function(e,t){return e.eat('"')?(t.tokenize=p,p(e,t)):(e.eatWhile(/[\w\$_]/),"meta")}}}),h("text/x-scala",{name:"clike",keywords:i("abstract case catch class def do else extends final finally for forSome if implicit import lazy match new null object override package private protected return sealed super this throw trait try type val var while with yield _ assert assume require print println printf readLine readBoolean readByte readShort readChar readInt readLong readFloat readDouble"),types:i("AnyVal App Application Array BufferedIterator BigDecimal BigInt Char Console Either Enumeration Equiv Error Exception Fractional Function IndexedSeq Int Integral Iterable Iterator List Map Numeric Nil NotNull Option Ordered Ordering PartialFunction PartialOrdering Product Proxy Range Responder Seq Serializable Set Specializable Stream StringBuilder StringContext Symbol Throwable Traversable TraversableOnce Tuple Unit Vector Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),multiLineStrings:!0,blockKeywords:i("catch class enum do else finally for forSome if match switch try while"),defKeywords:i("class enum def object package trait type val var"),atoms:i("true false null"),indentStatements:!1,indentSwitch:!1,isOperatorChar:/[+\-*&%=<>!?|\/#:@]/,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return!!e.match('""')&&(t.tokenize=g,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},"=":function(e,n){var r=n.context;return!("}"!=r.type||!r.align||!e.eat(">"))&&(n.context=new t(r.indented,r.column,r.type,r.info,null,r.prev),"operator")}},modeProps:{closeBrackets:{triples:'"'}}}),h("text/x-kotlin",{name:"clike",keywords:i("package as typealias class interface this super val var fun for is in This throw return break continue object if else while do try when !in !is as? file import where by get set abstract enum open inner override private public internal protected catch finally out final vararg reified dynamic companion constructor init sealed field property receiver param sparam lateinit data inline noinline tailrec external annotation crossinline const operator infix suspend"),types:i("Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),intendSwitch:!1,indentStatements:!1,multiLineStrings:!0,number:/^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,blockKeywords:i("catch class do else finally for if where try while enum"),defKeywords:i("class val var object package interface fun"),atoms:i("true false null this"),hooks:{'"':function(e,t){return t.tokenize=y(e.match('""')),t.tokenize(e,t)}},modeProps:{closeBrackets:{triples:'"'}}}),h(["x-shader/x-vertex","x-shader/x-fragment"],{name:"clike",keywords:i("sampler1D sampler2D sampler3D samplerCube sampler1DShadow sampler2DShadow const attribute uniform varying break continue discard return for while do if else struct in out inout"),types:i("float int bool void vec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4 mat2 mat3 mat4"),blockKeywords:i("for while do if else struct"),builtin:i("radians degrees sin cos tan asin acos atan pow exp log exp2 sqrt inversesqrt abs sign floor ceil fract mod min max clamp mix step smoothstep length distance dot cross normalize ftransform faceforward reflect refract matrixCompMult lessThan lessThanEqual greaterThan greaterThanEqual equal notEqual any all not texture1D texture1DProj texture1DLod texture1DProjLod texture2D texture2DProj texture2DLod texture2DProjLod texture3D texture3DProj texture3DLod texture3DProjLod textureCube textureCubeLod shadow1D shadow2D shadow1DProj shadow2DProj shadow1DLod shadow2DLod shadow1DProjLod shadow2DProjLod dFdx dFdy fwidth noise1 noise2 noise3 noise4"),atoms:i("true false gl_FragColor gl_SecondaryColor gl_Normal gl_Vertex gl_MultiTexCoord0 gl_MultiTexCoord1 gl_MultiTexCoord2 gl_MultiTexCoord3 gl_MultiTexCoord4 gl_MultiTexCoord5 gl_MultiTexCoord6 gl_MultiTexCoord7 gl_FogCoord gl_PointCoord gl_Position gl_PointSize gl_ClipVertex gl_FrontColor gl_BackColor gl_FrontSecondaryColor gl_BackSecondaryColor gl_TexCoord gl_FogFragCoord gl_FragCoord gl_FrontFacing gl_FragData gl_FragDepth gl_ModelViewMatrix gl_ProjectionMatrix gl_ModelViewProjectionMatrix gl_TextureMatrix gl_NormalMatrix gl_ModelViewMatrixInverse gl_ProjectionMatrixInverse gl_ModelViewProjectionMatrixInverse gl_TexureMatrixTranspose gl_ModelViewMatrixInverseTranspose gl_ProjectionMatrixInverseTranspose gl_ModelViewProjectionMatrixInverseTranspose gl_TextureMatrixInverseTranspose gl_NormalScale gl_DepthRange gl_ClipPlane gl_Point gl_FrontMaterial gl_BackMaterial gl_LightSource gl_LightModel gl_FrontLightModelProduct gl_BackLightModelProduct gl_TextureColor gl_EyePlaneS gl_EyePlaneT gl_EyePlaneR gl_EyePlaneQ gl_FogParameters gl_MaxLights gl_MaxClipPlanes gl_MaxTextureUnits gl_MaxTextureCoords gl_MaxVertexAttribs gl_MaxVertexUniformComponents gl_MaxVaryingFloats gl_MaxVertexTextureImageUnits gl_MaxTextureImageUnits gl_MaxFragmentUniformComponents gl_MaxCombineTextureImageUnits gl_MaxDrawBuffers"),indentSwitch:!1,hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-nesc",{name:"clike",keywords:i(b+"as atomic async call command component components configuration event generic implementation includes interface module new norace nx_struct nx_union post provides signal task uses abstract extends"),types:i(k),blockKeywords:i("case do else for if switch while struct"),atoms:i("null true false"),hooks:{"#":s},modeProps:{fold:["brace","include"]}}),h("text/x-objectivec",{name:"clike",keywords:i(b+"inline restrict _Bool _Complex _Imaginary BOOL Class bycopy byref id IMP in inout nil oneway out Protocol SEL self super atomic nonatomic retain copy readwrite readonly"),types:i(k),atoms:i("YES NO NULL NILL ON OFF true false"),hooks:{"@":function(e){return e.eatWhile(/[\w\$]/),"keyword"},"#":s,indent:function(e,t,n){if("statement"==t.type&&/^@\w/.test(n))return t.indented}},modeProps:{fold:"brace"}}),h("text/x-squirrel",{name:"clike",keywords:i("base break clone continue const default delete enum extends function in class foreach local resume return this throw typeof yield constructor instanceof static"),types:i(k),blockKeywords:i("case catch class else for foreach if switch try while"),defKeywords:i("function local class"),typeFirstDefinitions:!0,atoms:i("true false null"),hooks:{"#":s},modeProps:{fold:["brace","include"]}});var w=null;h("text/x-ceylon",{name:"clike",keywords:i("abstracts alias assembly assert assign break case catch class continue dynamic else exists extends finally for function given if import in interface is let module new nonempty object of out outer package return satisfies super switch then this throw try value void while"),types:function(e){var t=e.charAt(0);return t===t.toUpperCase()&&t!==t.toLowerCase()},blockKeywords:i("case catch class dynamic else finally for function if interface module new object switch try while"),defKeywords:i("class dynamic function interface module object package value"),builtin:i("abstract actual aliased annotation by default deprecated doc final formal late license native optional sealed see serializable shared suppressWarnings tagged throws variable"),isPunctuationChar:/[\[\]{}\(\),;\:\.`]/,isOperatorChar:/[+\-*&%=<>!?|^~:\/]/,numberStart:/[\d#$]/,number:/^(?:#[\da-fA-F_]+|\$[01_]+|[\d_]+[kMGTPmunpf]?|[\d_]+\.[\d_]+(?:[eE][-+]?\d+|[kMGTPmunpf]|)|)/i,multiLineStrings:!0,typeFirstDefinitions:!0,atoms:i("true false null larger smaller equal empty finished"),indentSwitch:!1,styleDefs:!1,hooks:{"@":function(e){return e.eatWhile(/[\w\$_]/),"meta"},'"':function(e,t){return t.tokenize=x(e.match('""')?"triple":"single"),t.tokenize(e,t)},"`":function(e,t){return!(!w||!e.match("`"))&&(t.tokenize=w,w=null,t.tokenize(e,t))},"'":function(e){return e.eatWhile(/[\w\$_\xa1-\uffff]/),"atom"},token:function(e,t,n){if(("variable"==n||"type"==n)&&"."==t.prevToken)return"variable-2"}},modeProps:{fold:["brace","import"],closeBrackets:{triples:'"'}}})});
      // -------------------------------------------------------------------------
//  Part of the CodeChecker project, under the Apache License v2.0 with
//  LLVM Exceptions. See LICENSE for license information.
//  SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
// -------------------------------------------------------------------------

var BugViewer = {
  _files : [],
  _reports : [],
  _lineWidgets : [],
  _navigationMenuItems : [],
  _sourceFileData : null,
  _currentReport : null,
  _lastBugEvent  : null,

  init : function (files, reports) {
    this._files = files;
    this._reports = reports;

    this.initEscapeChars();
  },

  initEscapeChars : function () {
    this.escapeChars = {
      ' ' : 'nbsp',
      '<' : 'lt',
      '>' : 'gt',
      '"' : 'quot',
      '&' : 'amp'
    };

    var regexString = '[';
    for (var key in this.escapeChars) {
      regexString += key;
    }
    regexString += ']';

    this.escapeRegExp = new RegExp( regexString, 'g');
  },

  escapeHTML : function (str) {
    var that = this;

    return str.replace(this.escapeRegExp, function (m) {
      return '&' + that.escapeChars[m] + ';';
    });
  },

  initByUrl : function () {
    if (!this._reports) return;

    var state = {};
    window.location.hash.substr(1).split('&').forEach(function (s) {
      var parts = s.split('=');
      state[parts[0]] = parts[1];
    });

    for (var key in this._reports) {
      var report = this._reports[key];
      if (report.reportHash === state['reportHash']) {
        this.navigate(report);
        return;
      }
    }

    this.navigate(this._reports[0]);
  },

  create : function () {
    this._content = document.getElementById('editor-wrapper');
    this._filepath = document.getElementById('file-path');
    this._checkerName = document.getElementById('checker-name');
    this._reviewStatusWrapper =
      document.getElementById('review-status-wrapper');
    this._reviewStatus = document.getElementById('review-status');
    this._editor = document.getElementById('editor');

    this._codeMirror = CodeMirror(this._editor, {
      mode: 'text/x-c++src',
      matchBrackets : true,
      lineNumbers : true,
      readOnly : true,
      foldGutter : true,
      extraKeys : {},
      viewportMargin : 100
    });

    this._createNavigationMenu();
  },

  navigate : function (report, item) {
    if (!item) {
      var items = this._navigationMenuItems.filter(function (navItem) {
        return navItem.report.reportHash === report.reportHash;
      });

      if (!items.length) return;

      item = items[0].widget;
    }

    this._selectedReport.classList.remove('active');
    this._selectedReport = item;
    this._selectedReport.classList.add('active');
    this.setReport(report);
  },

  _createNavigationMenu : function () {
    var that = this;

    var nav = document.getElementById('report-nav');
    var list = document.createElement('ul');
    this._reports.forEach(function (report) {
      var events = report['events'];
      var lastBugEvent = events[events.length - 1];
      var item = document.createElement('li');

      var severity = document.createElement('i');
      severity.className = 'severity-' + report.severity.toLowerCase();

      item.appendChild(severity);
      item.appendChild(document.createTextNode(lastBugEvent.message));

      item.addEventListener('click', function () {
        that.navigate(report, item);
      })
      list.appendChild(item);
      that._navigationMenuItems.push({ report : report, widget : item });
    });

    if (!this._selectedReport && list.childNodes.length) {
      this._selectedReport = list.childNodes[0];
      this._selectedReport.classList.add('active');
    }

    nav.appendChild(list);
  },

  setReport : function (report) {
    this._currentReport = report;
    var events = report['events'];
    var lastBugEvent = events[events.length - 1];
    this.setCurrentBugEvent(lastBugEvent, events.length - 1);
    this.setCheckerName(report.checkerName);
    this.setReviewStatus(report.reviewStatus);

    window.location.hash = '#reportHash=' + report.reportHash;
  },

  setCurrentBugEvent : function (event, idx) {
    this._currentBugEvent = event;
    this.setSourceFileData(this._files[event.location.file]);
    this.drawBugPath();

    this.jumpTo(event.location.line, 0);
    this.highlightBugEvent(event, idx);
  },

  highlightBugEvent : function (event, idx) {
    this._lineWidgets.forEach(function (widget) {
      var lineIdx = widget.node.getAttribute('idx');
      if (parseInt(lineIdx) === idx) {
        widget.node.classList.add('current');
      }
    });
  },

  setCheckerName : function (checkerName) {
    this._checkerName.innerHTML = checkerName;
  },

  setReviewStatus : function (status) {
    if (status) {
      var className =
        'review-status-' + status.toLowerCase().split(' ').join('-');
      this._reviewStatus.className = "review-status " + className;

      this._reviewStatus.innerHTML = status;
      this._reviewStatusWrapper.style.display = 'block';
    } else {
      this._reviewStatusWrapper.style.display = 'none';
    }
  },

  setSourceFileData : function (file) {
    if (this._sourceFileData && file.id === this._sourceFileData.id) {
      return;
    }

    this._sourceFileData = file;
    this._filepath.innerHTML = file.path;
    this._codeMirror.doc.setValue(file.content);
    this._refresh();
  },

  _refresh : function () {
    var that = this;
    setTimeout(function () {
      var fullHeight = parseInt(that._content.clientHeight);
      var headerHeight = that._filepath.clientHeight;

      that._codeMirror.setSize('auto', fullHeight - headerHeight);
      that._codeMirror.refresh();
    }, 200);
  },

  clearBubbles : function () {
    this._lineWidgets.forEach(function (widget) { widget.clear(); });
    this._lineWidgets = [];
  },

  getMessage : function (event, kind) {
    if (kind === 'macro') {
      var name = 'macro expansion' + (event.name ? ': ' + event.name : '');

      return '<span class="tag macro">' + name + '</span>'
        + this.escapeHTML(event.expansion).replace(/(?:\r\n|\r|\n)/g, '<br>');
    } else if (kind === 'note') {
      return '<span class="tag note">note</span>'
        +  this.escapeHTML(event.message).replace(/(?:\r\n|\r|\n)/g, '<br>');
    }
  },

  addExtraPathEvents : function (events, kind) {
    var that = this;

    if (!events) {
      return;
    }

    events.forEach(function (event) {
      if (event.location.file !== that._currentBugEvent.location.file) {
        return;
      }

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + kind);

      var msg = document.createElement('span');
      msg.innerHTML = that.getMessage(event, kind);
      element.appendChild(msg);

      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  drawBugPath : function () {
    var that = this;

    this.clearBubbles();

    this.addExtraPathEvents(this._currentReport.macros, 'macro');
    this.addExtraPathEvents(this._currentReport.notes, 'note');

    // Processing bug path events.
    var currentEvents = this._currentReport.events;
    currentEvents.forEach(function (event, step) {
      if (event.location.file !== that._currentBugEvent.location.file)
        return;

      var left =
        that._codeMirror.defaultCharWidth() * event.location.col + 'px';
      var type = step === currentEvents.length - 1 ? 'error' : 'info';

      var element = document.createElement('div');
      element.setAttribute('style', 'margin-left: ' + left);
      element.setAttribute('class', 'check-msg ' + type);
      element.setAttribute('idx', step);

      var enumeration = document.createElement('span');
      enumeration.setAttribute('class', 'checker-enum ' + type);
      enumeration.innerHTML = step + 1;

      if (currentEvents.length > 1)
        element.appendChild(enumeration);

      var prevBugEvent = step - 1;
      if (step > 0) {
        var prevBug = document.createElement('span');
        prevBug.setAttribute('class', 'arrow left-arrow');
        prevBug.addEventListener('click', function () {
          var event = currentEvents[prevBugEvent];
          that.setCurrentBugEvent(event, prevBugEvent);
        });
        element.appendChild(prevBug);
      }

      var msg = document.createElement('span');
      msg.innerHTML = that.escapeHTML(event.message)
        .replace(/(?:\r\n|\r|\n)/g, '<br>');

      element.appendChild(msg);

      var nextBugEvent = step + 1;
      if (nextBugEvent < currentEvents.length) {
        var nextBug = document.createElement('span');
        nextBug.setAttribute('class', 'arrow right-arrow');
        nextBug.addEventListener('click', function () {
          var event = currentEvents[nextBugEvent];
          that.setCurrentBugEvent(event, nextBugEvent);
        });
        element.appendChild(nextBug);
      }


      that._lineWidgets.push(that._codeMirror.addLineWidget(
        event.location.line - 1, element));
    });
  },

  jumpTo : function (line, column) {
    var that = this;

    setTimeout(function () {
      var selPosPixel
        = that._codeMirror.charCoords({ line : line, ch : column }, 'local');
      var editorSize = {
        width  : that._editor.clientWidth,
        height : that._editor.clientHeight
      };

      that._codeMirror.scrollIntoView({
        top    : selPosPixel.top - 100,
        bottom : selPosPixel.top + editorSize.height - 150,
        left   : selPosPixel.left < editorSize.width - 100
               ? 0
               : selPosPixel.left - 50,
        right  : selPosPixel.left < editorSize.width - 100
               ? 10
               : selPosPixel.left + editorSize.width - 100
      });
    }, 0);
  }
}


      var data = {"files": {"87": {"id": 87, "path": "/home/vsts/work/1/llvm-project/lldb/source/Plugins/TypeSystem/Clang/TypeSystemClang.cpp", "content": "//===-- TypeSystemClang.cpp -----------------------------------------------===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n\n#include \"TypeSystemClang.h\"\n\n#include \"llvm/Support/FormatAdapters.h\"\n#include \"llvm/Support/FormatVariadic.h\"\n\n#include <mutex>\n#include <string>\n#include <vector>\n\n#include \"clang/AST/ASTContext.h\"\n#include \"clang/AST/ASTImporter.h\"\n#include \"clang/AST/Attr.h\"\n#include \"clang/AST/CXXInheritance.h\"\n#include \"clang/AST/DeclObjC.h\"\n#include \"clang/AST/DeclTemplate.h\"\n#include \"clang/AST/Mangle.h\"\n#include \"clang/AST/RecordLayout.h\"\n#include \"clang/AST/Type.h\"\n#include \"clang/AST/VTableBuilder.h\"\n#include \"clang/Basic/Builtins.h\"\n#include \"clang/Basic/Diagnostic.h\"\n#include \"clang/Basic/FileManager.h\"\n#include \"clang/Basic/FileSystemOptions.h\"\n#include \"clang/Basic/LangStandard.h\"\n#include \"clang/Basic/SourceManager.h\"\n#include \"clang/Basic/TargetInfo.h\"\n#include \"clang/Basic/TargetOptions.h\"\n#include \"clang/Frontend/FrontendOptions.h\"\n#include \"clang/Lex/HeaderSearch.h\"\n#include \"clang/Lex/HeaderSearchOptions.h\"\n#include \"clang/Lex/ModuleMap.h\"\n#include \"clang/Sema/Sema.h\"\n\n#include \"llvm/Support/Signals.h\"\n#include \"llvm/Support/Threading.h\"\n\n#include \"Plugins/ExpressionParser/Clang/ClangASTImporter.h\"\n#include \"Plugins/ExpressionParser/Clang/ClangASTMetadata.h\"\n#include \"Plugins/ExpressionParser/Clang/ClangExternalASTSourceCallbacks.h\"\n#include \"Plugins/ExpressionParser/Clang/ClangFunctionCaller.h\"\n#include \"Plugins/ExpressionParser/Clang/ClangPersistentVariables.h\"\n#include \"Plugins/ExpressionParser/Clang/ClangUserExpression.h\"\n#include \"Plugins/ExpressionParser/Clang/ClangUtil.h\"\n#include \"Plugins/ExpressionParser/Clang/ClangUtilityFunction.h\"\n#include \"lldb/Utility/ArchSpec.h\"\n#include \"lldb/Utility/Flags.h\"\n\n#include \"lldb/Core/DumpDataExtractor.h\"\n#include \"lldb/Core/Module.h\"\n#include \"lldb/Core/PluginManager.h\"\n#include \"lldb/Core/StreamFile.h\"\n#include \"lldb/Core/ThreadSafeDenseMap.h\"\n#include \"lldb/Core/UniqueCStringMap.h\"\n#include \"lldb/Symbol/ObjectFile.h\"\n#include \"lldb/Symbol/SymbolFile.h\"\n#include \"lldb/Target/ExecutionContext.h\"\n#include \"lldb/Target/Language.h\"\n#include \"lldb/Target/Process.h\"\n#include \"lldb/Target/Target.h\"\n#include \"lldb/Utility/DataExtractor.h\"\n#include \"lldb/Utility/LLDBAssert.h\"\n#include \"lldb/Utility/Log.h\"\n#include \"lldb/Utility/RegularExpression.h\"\n#include \"lldb/Utility/Scalar.h\"\n\n#include \"Plugins/LanguageRuntime/ObjC/ObjCLanguageRuntime.h\"\n#include \"Plugins/SymbolFile/DWARF/DWARFASTParserClang.h\"\n#include \"Plugins/SymbolFile/PDB/PDBASTParser.h\"\n\n#include <stdio.h>\n\n#include <mutex>\n\nusing namespace lldb;\nusing namespace lldb_private;\nusing namespace clang;\nusing llvm::StringSwitch;\n\nLLDB_PLUGIN_DEFINE(TypeSystemClang)\n\nnamespace {\nstatic void VerifyDecl(clang::Decl *decl) {\n  assert(decl && \"VerifyDecl called with nullptr?\");\n#ifndef NDEBUG\n  // We don't care about the actual access value here but only want to trigger\n  // that Clang calls its internal Decl::AccessDeclContextSanity check.\n  decl->getAccess();\n#endif\n}\n\nstatic inline bool\nTypeSystemClangSupportsLanguage(lldb::LanguageType language) {\n  return language == eLanguageTypeUnknown || // Clang is the default type system\n         lldb_private::Language::LanguageIsC(language) ||\n         lldb_private::Language::LanguageIsCPlusPlus(language) ||\n         lldb_private::Language::LanguageIsObjC(language) ||\n         lldb_private::Language::LanguageIsPascal(language) ||\n         // Use Clang for Rust until there is a proper language plugin for it\n         language == eLanguageTypeRust ||\n         language == eLanguageTypeExtRenderScript ||\n         // Use Clang for D until there is a proper language plugin for it\n         language == eLanguageTypeD ||\n         // Open Dylan compiler debug info is designed to be Clang-compatible\n         language == eLanguageTypeDylan;\n}\n\n// Checks whether m1 is an overload of m2 (as opposed to an override). This is\n// called by addOverridesForMethod to distinguish overrides (which share a\n// vtable entry) from overloads (which require distinct entries).\nbool isOverload(clang::CXXMethodDecl *m1, clang::CXXMethodDecl *m2) {\n  // FIXME: This should detect covariant return types, but currently doesn't.\n  lldbassert(&m1->getASTContext() == &m2->getASTContext() &&\n             \"Methods should have the same AST context\");\n  clang::ASTContext &context = m1->getASTContext();\n\n  const auto *m1Type = llvm::cast<clang::FunctionProtoType>(\n      context.getCanonicalType(m1->getType()));\n\n  const auto *m2Type = llvm::cast<clang::FunctionProtoType>(\n      context.getCanonicalType(m2->getType()));\n\n  auto compareArgTypes = [&context](const clang::QualType &m1p,\n                                    const clang::QualType &m2p) {\n    return context.hasSameType(m1p.getUnqualifiedType(),\n                               m2p.getUnqualifiedType());\n  };\n\n  // FIXME: In C++14 and later, we can just pass m2Type->param_type_end()\n  //        as a fourth parameter to std::equal().\n  return (m1->getNumParams() != m2->getNumParams()) ||\n         !std::equal(m1Type->param_type_begin(), m1Type->param_type_end(),\n                     m2Type->param_type_begin(), compareArgTypes);\n}\n\n// If decl is a virtual method, walk the base classes looking for methods that\n// decl overrides. This table of overridden methods is used by IRGen to\n// determine the vtable layout for decl's parent class.\nvoid addOverridesForMethod(clang::CXXMethodDecl *decl) {\n  if (!decl->isVirtual())\n    return;\n\n  clang::CXXBasePaths paths;\n  llvm::SmallVector<clang::NamedDecl *, 4> decls;\n\n  auto find_overridden_methods =\n      [&decls, decl](const clang::CXXBaseSpecifier *specifier,\n                     clang::CXXBasePath &path) {\n        if (auto *base_record = llvm::dyn_cast<clang::CXXRecordDecl>(\n                specifier->getType()->getAs<clang::RecordType>()->getDecl())) {\n\n          clang::DeclarationName name = decl->getDeclName();\n\n          // If this is a destructor, check whether the base class destructor is\n          // virtual.\n          if (name.getNameKind() == clang::DeclarationName::CXXDestructorName)\n            if (auto *baseDtorDecl = base_record->getDestructor()) {\n              if (baseDtorDecl->isVirtual()) {\n                path.Decls = baseDtorDecl;\n                decls.push_back(baseDtorDecl);\n                return true;\n              } else\n                return false;\n            }\n\n          // Otherwise, search for name in the base class.\n          for (path.Decls = base_record->lookup(name); !path.Decls.empty();\n               path.Decls = path.Decls.slice(1)) {\n            if (auto *method_decl =\n                    llvm::dyn_cast<clang::CXXMethodDecl>(path.Decls.front()))\n              if (method_decl->isVirtual() && !isOverload(decl, method_decl)) {\n                path.Decls = method_decl;\n                decls.push_back(method_decl);\n                return true;\n              }\n          }\n        }\n\n        return false;\n      };\n\n  if (decl->getParent()->lookupInBases(find_overridden_methods, paths)) {\n    for (auto *overridden_decl : decls)\n      decl->addOverriddenMethod(\n          llvm::cast<clang::CXXMethodDecl>(overridden_decl));\n  }\n}\n}\n\nstatic lldb::addr_t GetVTableAddress(Process &process,\n                                     VTableContextBase &vtable_ctx,\n                                     ValueObject &valobj,\n                                     const ASTRecordLayout &record_layout) {\n  // Retrieve type info\n  CompilerType pointee_type;\n  CompilerType this_type(valobj.GetCompilerType());\n  uint32_t type_info = this_type.GetTypeInfo(&pointee_type);\n  if (!type_info)\n    return LLDB_INVALID_ADDRESS;\n\n  // Check if it's a pointer or reference\n  bool ptr_or_ref = false;\n  if (type_info & (eTypeIsPointer | eTypeIsReference)) {\n    ptr_or_ref = true;\n    type_info = pointee_type.GetTypeInfo();\n  }\n\n  // We process only C++ classes\n  const uint32_t cpp_class = eTypeIsClass | eTypeIsCPlusPlus;\n  if ((type_info & cpp_class) != cpp_class)\n    return LLDB_INVALID_ADDRESS;\n\n  // Calculate offset to VTable pointer\n  lldb::offset_t vbtable_ptr_offset =\n      vtable_ctx.isMicrosoft() ? record_layout.getVBPtrOffset().getQuantity()\n                               : 0;\n\n  if (ptr_or_ref) {\n    // We have a pointer / ref to object, so read\n    // VTable pointer from process memory\n\n    if (valobj.GetAddressTypeOfChildren() != eAddressTypeLoad)\n      return LLDB_INVALID_ADDRESS;\n\n    auto vbtable_ptr_addr = valobj.GetValueAsUnsigned(LLDB_INVALID_ADDRESS);\n    if (vbtable_ptr_addr == LLDB_INVALID_ADDRESS)\n      return LLDB_INVALID_ADDRESS;\n\n    vbtable_ptr_addr += vbtable_ptr_offset;\n\n    Status err;\n    return process.ReadPointerFromMemory(vbtable_ptr_addr, err);\n  }\n\n  // We have an object already read from process memory,\n  // so just extract VTable pointer from it\n\n  DataExtractor data;\n  Status err;\n  auto size = valobj.GetData(data, err);\n  if (err.Fail() || vbtable_ptr_offset + data.GetAddressByteSize() > size)\n    return LLDB_INVALID_ADDRESS;\n\n  return data.GetAddress(&vbtable_ptr_offset);\n}\n\nstatic int64_t ReadVBaseOffsetFromVTable(Process &process,\n                                         VTableContextBase &vtable_ctx,\n                                         lldb::addr_t vtable_ptr,\n                                         const CXXRecordDecl *cxx_record_decl,\n                                         const CXXRecordDecl *base_class_decl) {\n  if (vtable_ctx.isMicrosoft()) {\n    clang::MicrosoftVTableContext &msoft_vtable_ctx =\n        static_cast<clang::MicrosoftVTableContext &>(vtable_ctx);\n\n    // Get the index into the virtual base table. The\n    // index is the index in uint32_t from vbtable_ptr\n    const unsigned vbtable_index =\n        msoft_vtable_ctx.getVBTableIndex(cxx_record_decl, base_class_decl);\n    const lldb::addr_t base_offset_addr = vtable_ptr + vbtable_index * 4;\n    Status err;\n    return process.ReadSignedIntegerFromMemory(base_offset_addr, 4, INT64_MAX,\n                                               err);\n  }\n\n  clang::ItaniumVTableContext &itanium_vtable_ctx =\n      static_cast<clang::ItaniumVTableContext &>(vtable_ctx);\n\n  clang::CharUnits base_offset_offset =\n      itanium_vtable_ctx.getVirtualBaseOffsetOffset(cxx_record_decl,\n                                                    base_class_decl);\n  const lldb::addr_t base_offset_addr =\n      vtable_ptr + base_offset_offset.getQuantity();\n  const uint32_t base_offset_size = process.GetAddressByteSize();\n  Status err;\n  return process.ReadSignedIntegerFromMemory(base_offset_addr, base_offset_size,\n                                             INT64_MAX, err);\n}\n\nstatic bool GetVBaseBitOffset(VTableContextBase &vtable_ctx,\n                              ValueObject &valobj,\n                              const ASTRecordLayout &record_layout,\n                              const CXXRecordDecl *cxx_record_decl,\n                              const CXXRecordDecl *base_class_decl,\n                              int32_t &bit_offset) {\n  ExecutionContext exe_ctx(valobj.GetExecutionContextRef());\n  Process *process = exe_ctx.GetProcessPtr();\n  if (!process)\n    return false;\n\n  lldb::addr_t vtable_ptr =\n      GetVTableAddress(*process, vtable_ctx, valobj, record_layout);\n  if (vtable_ptr == LLDB_INVALID_ADDRESS)\n    return false;\n\n  auto base_offset = ReadVBaseOffsetFromVTable(\n      *process, vtable_ctx, vtable_ptr, cxx_record_decl, base_class_decl);\n  if (base_offset == INT64_MAX)\n    return false;\n\n  bit_offset = base_offset * 8;\n\n  return true;\n}\n\ntypedef lldb_private::ThreadSafeDenseMap<clang::ASTContext *, TypeSystemClang *>\n    ClangASTMap;\n\nstatic ClangASTMap &GetASTMap() {\n  static ClangASTMap *g_map_ptr = nullptr;\n  static llvm::once_flag g_once_flag;\n  llvm::call_once(g_once_flag, []() {\n    g_map_ptr = new ClangASTMap(); // leaked on purpose to avoid spins\n  });\n  return *g_map_ptr;\n}\n\nTypePayloadClang::TypePayloadClang(OptionalClangModuleID owning_module,\n                                   bool is_complete_objc_class)\n    : m_payload(owning_module.GetValue()) {\n  SetIsCompleteObjCClass(is_complete_objc_class);\n}\n\nvoid TypePayloadClang::SetOwningModule(OptionalClangModuleID id) {\n  assert(id.GetValue() < ObjCClassBit);\n  bool is_complete = IsCompleteObjCClass();\n  m_payload = id.GetValue();\n  SetIsCompleteObjCClass(is_complete);\n}\n\nstatic void SetMemberOwningModule(clang::Decl *member,\n                                  const clang::Decl *parent) {\n  if (!member || !parent)\n    return;\n\n  OptionalClangModuleID id(parent->getOwningModuleID());\n  if (!id.HasValue())\n    return;\n\n  member->setFromASTFile();\n  member->setOwningModuleID(id.GetValue());\n  member->setModuleOwnershipKind(clang::Decl::ModuleOwnershipKind::Visible);\n  if (llvm::isa<clang::NamedDecl>(member))\n    if (auto *dc = llvm::dyn_cast<clang::DeclContext>(parent)) {\n      dc->setHasExternalVisibleStorage(true);\n      // This triggers ExternalASTSource::FindExternalVisibleDeclsByName() to be\n      // called when searching for members.\n      dc->setHasExternalLexicalStorage(true);\n    }\n}\n\nchar TypeSystemClang::ID;\n\nbool TypeSystemClang::IsOperator(llvm::StringRef name,\n                                 clang::OverloadedOperatorKind &op_kind) {\n  // All operators have to start with \"operator\".\n  if (!name.consume_front(\"operator\"))\n    return false;\n\n  // Remember if there was a space after \"operator\". This is necessary to\n  // check for collisions with strangely named functions like \"operatorint()\".\n  bool space_after_operator = name.consume_front(\" \");\n\n  op_kind = StringSwitch<clang::OverloadedOperatorKind>(name)\n                .Case(\"+\", clang::OO_Plus)\n                .Case(\"+=\", clang::OO_PlusEqual)\n                .Case(\"++\", clang::OO_PlusPlus)\n                .Case(\"-\", clang::OO_Minus)\n                .Case(\"-=\", clang::OO_MinusEqual)\n                .Case(\"--\", clang::OO_MinusMinus)\n                .Case(\"->\", clang::OO_Arrow)\n                .Case(\"->*\", clang::OO_ArrowStar)\n                .Case(\"*\", clang::OO_Star)\n                .Case(\"*=\", clang::OO_StarEqual)\n                .Case(\"/\", clang::OO_Slash)\n                .Case(\"/=\", clang::OO_SlashEqual)\n                .Case(\"%\", clang::OO_Percent)\n                .Case(\"%=\", clang::OO_PercentEqual)\n                .Case(\"^\", clang::OO_Caret)\n                .Case(\"^=\", clang::OO_CaretEqual)\n                .Case(\"&\", clang::OO_Amp)\n                .Case(\"&=\", clang::OO_AmpEqual)\n                .Case(\"&&\", clang::OO_AmpAmp)\n                .Case(\"|\", clang::OO_Pipe)\n                .Case(\"|=\", clang::OO_PipeEqual)\n                .Case(\"||\", clang::OO_PipePipe)\n                .Case(\"~\", clang::OO_Tilde)\n                .Case(\"!\", clang::OO_Exclaim)\n                .Case(\"!=\", clang::OO_ExclaimEqual)\n                .Case(\"=\", clang::OO_Equal)\n                .Case(\"==\", clang::OO_EqualEqual)\n                .Case(\"<\", clang::OO_Less)\n                .Case(\"<<\", clang::OO_LessLess)\n                .Case(\"<<=\", clang::OO_LessLessEqual)\n                .Case(\"<=\", clang::OO_LessEqual)\n                .Case(\">\", clang::OO_Greater)\n                .Case(\">>\", clang::OO_GreaterGreater)\n                .Case(\">>=\", clang::OO_GreaterGreaterEqual)\n                .Case(\">=\", clang::OO_GreaterEqual)\n                .Case(\"()\", clang::OO_Call)\n                .Case(\"[]\", clang::OO_Subscript)\n                .Case(\",\", clang::OO_Comma)\n                .Default(clang::NUM_OVERLOADED_OPERATORS);\n\n  // We found a fitting operator, so we can exit now.\n  if (op_kind != clang::NUM_OVERLOADED_OPERATORS)\n    return true;\n\n  // After the \"operator \" or \"operator\" part is something unknown. This means\n  // it's either one of the named operators (new/delete), a conversion operator\n  // (e.g. operator bool) or a function which name starts with \"operator\"\n  // (e.g. void operatorbool).\n\n  // If it's a function that starts with operator it can't have a space after\n  // \"operator\" because identifiers can't contain spaces.\n  // E.g. \"operator int\" (conversion operator)\n  //  vs. \"operatorint\" (function with colliding name).\n  if (!space_after_operator)\n    return false; // not an operator.\n\n  // Now the operator is either one of the named operators or a conversion\n  // operator.\n  op_kind = StringSwitch<clang::OverloadedOperatorKind>(name)\n                .Case(\"new\", clang::OO_New)\n                .Case(\"new[]\", clang::OO_Array_New)\n                .Case(\"delete\", clang::OO_Delete)\n                .Case(\"delete[]\", clang::OO_Array_Delete)\n                // conversion operators hit this case.\n                .Default(clang::NUM_OVERLOADED_OPERATORS);\n\n  return true;\n}\n\nclang::AccessSpecifier\nTypeSystemClang::ConvertAccessTypeToAccessSpecifier(AccessType access) {\n  switch (access) {\n  default:\n    break;\n  case eAccessNone:\n    return AS_none;\n  case eAccessPublic:\n    return AS_public;\n  case eAccessPrivate:\n    return AS_private;\n  case eAccessProtected:\n    return AS_protected;\n  }\n  return AS_none;\n}\n\nstatic void ParseLangArgs(LangOptions &Opts, InputKind IK, const char *triple) {\n  // FIXME: Cleanup per-file based stuff.\n\n  // Set some properties which depend solely on the input kind; it would be\n  // nice to move these to the language standard, and have the driver resolve\n  // the input kind + language standard.\n  if (IK.getLanguage() == clang::Language::Asm) {\n    Opts.AsmPreprocessor = 1;\n  } else if (IK.isObjectiveC()) {\n    Opts.ObjC = 1;\n  }\n\n  LangStandard::Kind LangStd = LangStandard::lang_unspecified;\n\n  if (LangStd == LangStandard::lang_unspecified) {\n    // Based on the base language, pick one.\n    switch (IK.getLanguage()) {\n    case clang::Language::Unknown:\n    case clang::Language::LLVM_IR:\n    case clang::Language::RenderScript:\n      llvm_unreachable(\"Invalid input kind!\");\n    case clang::Language::OpenCL:\n      LangStd = LangStandard::lang_opencl10;\n      break;\n    case clang::Language::CUDA:\n      LangStd = LangStandard::lang_cuda;\n      break;\n    case clang::Language::Asm:\n    case clang::Language::C:\n    case clang::Language::ObjC:\n      LangStd = LangStandard::lang_gnu99;\n      break;\n    case clang::Language::CXX:\n    case clang::Language::ObjCXX:\n      LangStd = LangStandard::lang_gnucxx98;\n      break;\n    case clang::Language::HIP:\n      LangStd = LangStandard::lang_hip;\n      break;\n    }\n  }\n\n  const LangStandard &Std = LangStandard::getLangStandardForKind(LangStd);\n  Opts.LineComment = Std.hasLineComments();\n  Opts.C99 = Std.isC99();\n  Opts.CPlusPlus = Std.isCPlusPlus();\n  Opts.CPlusPlus11 = Std.isCPlusPlus11();\n  Opts.Digraphs = Std.hasDigraphs();\n  Opts.GNUMode = Std.isGNUMode();\n  Opts.GNUInline = !Std.isC99();\n  Opts.HexFloats = Std.hasHexFloats();\n  Opts.ImplicitInt = Std.hasImplicitInt();\n\n  Opts.WChar = true;\n\n  // OpenCL has some additional defaults.\n  if (LangStd == LangStandard::lang_opencl10) {\n    Opts.OpenCL = 1;\n    Opts.AltiVec = 1;\n    Opts.CXXOperatorNames = 1;\n    Opts.setLaxVectorConversions(LangOptions::LaxVectorConversionKind::All);\n  }\n\n  // OpenCL and C++ both have bool, true, false keywords.\n  Opts.Bool = Opts.OpenCL || Opts.CPlusPlus;\n\n  Opts.setValueVisibilityMode(DefaultVisibility);\n\n  // Mimicing gcc's behavior, trigraphs are only enabled if -trigraphs is\n  // specified, or -std is set to a conforming mode.\n  Opts.Trigraphs = !Opts.GNUMode;\n  Opts.CharIsSigned = ArchSpec(triple).CharIsSignedByDefault();\n  Opts.OptimizeSize = 0;\n\n  // FIXME: Eliminate this dependency.\n  //    unsigned Opt =\n  //    Args.hasArg(OPT_Os) ? 2 : getLastArgIntValue(Args, OPT_O, 0, Diags);\n  //    Opts.Optimize = Opt != 0;\n  unsigned Opt = 0;\n\n  // This is the __NO_INLINE__ define, which just depends on things like the\n  // optimization level and -fno-inline, not actually whether the backend has\n  // inlining enabled.\n  //\n  // FIXME: This is affected by other options (-fno-inline).\n  Opts.NoInlineDefine = !Opt;\n\n  // This is needed to allocate the extra space for the owning module\n  // on each decl.\n  Opts.ModulesLocalVisibility = 1;\n}\n\nTypeSystemClang::TypeSystemClang(llvm::StringRef name,\n                                 llvm::Triple target_triple) {\n  m_display_name = name.str();\n  if (!target_triple.str().empty())\n    SetTargetTriple(target_triple.str());\n  // The caller didn't pass an ASTContext so create a new one for this\n  // TypeSystemClang.\n  CreateASTContext();\n}\n\nTypeSystemClang::TypeSystemClang(llvm::StringRef name,\n                                 ASTContext &existing_ctxt) {\n  m_display_name = name.str();\n  SetTargetTriple(existing_ctxt.getTargetInfo().getTriple().str());\n\n  m_ast_up.reset(&existing_ctxt);\n  GetASTMap().Insert(&existing_ctxt, this);\n}\n\n// Destructor\nTypeSystemClang::~TypeSystemClang() { Finalize(); }\n\nConstString TypeSystemClang::GetPluginNameStatic() {\n  return ConstString(\"clang\");\n}\n\nConstString TypeSystemClang::GetPluginName() {\n  return TypeSystemClang::GetPluginNameStatic();\n}\n\nuint32_t TypeSystemClang::GetPluginVersion() { return 1; }\n\nlldb::TypeSystemSP TypeSystemClang::CreateInstance(lldb::LanguageType language,\n                                                   lldb_private::Module *module,\n                                                   Target *target) {\n  if (!TypeSystemClangSupportsLanguage(language))\n    return lldb::TypeSystemSP();\n  ArchSpec arch;\n  if (module)\n    arch = module->GetArchitecture();\n  else if (target)\n    arch = target->GetArchitecture();\n\n  if (!arch.IsValid())\n    return lldb::TypeSystemSP();\n\n  llvm::Triple triple = arch.GetTriple();\n  // LLVM wants this to be set to iOS or MacOSX; if we're working on\n  // a bare-boards type image, change the triple for llvm's benefit.\n  if (triple.getVendor() == llvm::Triple::Apple &&\n      triple.getOS() == llvm::Triple::UnknownOS) {\n    if (triple.getArch() == llvm::Triple::arm ||\n        triple.getArch() == llvm::Triple::aarch64 ||\n        triple.getArch() == llvm::Triple::aarch64_32 ||\n        triple.getArch() == llvm::Triple::thumb) {\n      triple.setOS(llvm::Triple::IOS);\n    } else {\n      triple.setOS(llvm::Triple::MacOSX);\n    }\n  }\n\n  if (module) {\n    std::string ast_name =\n        \"ASTContext for '\" + module->GetFileSpec().GetPath() + \"'\";\n    return std::make_shared<TypeSystemClang>(ast_name, triple);\n  } else if (target && target->IsValid())\n    return std::make_shared<ScratchTypeSystemClang>(*target, triple);\n  return lldb::TypeSystemSP();\n}\n\nLanguageSet TypeSystemClang::GetSupportedLanguagesForTypes() {\n  LanguageSet languages;\n  languages.Insert(lldb::eLanguageTypeC89);\n  languages.Insert(lldb::eLanguageTypeC);\n  languages.Insert(lldb::eLanguageTypeC11);\n  languages.Insert(lldb::eLanguageTypeC_plus_plus);\n  languages.Insert(lldb::eLanguageTypeC99);\n  languages.Insert(lldb::eLanguageTypeObjC);\n  languages.Insert(lldb::eLanguageTypeObjC_plus_plus);\n  languages.Insert(lldb::eLanguageTypeC_plus_plus_03);\n  languages.Insert(lldb::eLanguageTypeC_plus_plus_11);\n  languages.Insert(lldb::eLanguageTypeC11);\n  languages.Insert(lldb::eLanguageTypeC_plus_plus_14);\n  return languages;\n}\n\nLanguageSet TypeSystemClang::GetSupportedLanguagesForExpressions() {\n  LanguageSet languages;\n  languages.Insert(lldb::eLanguageTypeC_plus_plus);\n  languages.Insert(lldb::eLanguageTypeObjC_plus_plus);\n  languages.Insert(lldb::eLanguageTypeC_plus_plus_03);\n  languages.Insert(lldb::eLanguageTypeC_plus_plus_11);\n  languages.Insert(lldb::eLanguageTypeC_plus_plus_14);\n  return languages;\n}\n\nvoid TypeSystemClang::Initialize() {\n  PluginManager::RegisterPlugin(\n      GetPluginNameStatic(), \"clang base AST context plug-in\", CreateInstance,\n      GetSupportedLanguagesForTypes(), GetSupportedLanguagesForExpressions());\n}\n\nvoid TypeSystemClang::Terminate() {\n  PluginManager::UnregisterPlugin(CreateInstance);\n}\n\nvoid TypeSystemClang::Finalize() {\n  assert(m_ast_up);\n  GetASTMap().Erase(m_ast_up.get());\n  if (!m_ast_owned)\n    m_ast_up.release();\n\n  m_builtins_up.reset();\n  m_selector_table_up.reset();\n  m_identifier_table_up.reset();\n  m_target_info_up.reset();\n  m_target_options_rp.reset();\n  m_diagnostics_engine_up.reset();\n  m_source_manager_up.reset();\n  m_language_options_up.reset();\n}\n\nvoid TypeSystemClang::setSema(Sema *s) {\n  // Ensure that the new sema actually belongs to our ASTContext.\n  assert(s == nullptr || &s->getASTContext() == m_ast_up.get());\n  m_sema = s;\n}\n\nconst char *TypeSystemClang::GetTargetTriple() {\n  return m_target_triple.c_str();\n}\n\nvoid TypeSystemClang::SetTargetTriple(llvm::StringRef target_triple) {\n  m_target_triple = target_triple.str();\n}\n\nvoid TypeSystemClang::SetExternalSource(\n    llvm::IntrusiveRefCntPtr<ExternalASTSource> &ast_source_up) {\n  ASTContext &ast = getASTContext();\n  ast.setExternalSource(ast_source_up);\n  ast.getTranslationUnitDecl()->setHasExternalLexicalStorage(true);\n}\n\nASTContext &TypeSystemClang::getASTContext() {\n  assert(m_ast_up);\n  return *m_ast_up;\n}\n\nclass NullDiagnosticConsumer : public DiagnosticConsumer {\npublic:\n  NullDiagnosticConsumer() {\n    m_log = lldb_private::GetLogIfAllCategoriesSet(LIBLLDB_LOG_EXPRESSIONS);\n  }\n\n  void HandleDiagnostic(DiagnosticsEngine::Level DiagLevel,\n                        const clang::Diagnostic &info) override {\n    if (m_log) {\n      llvm::SmallVector<char, 32> diag_str(10);\n      info.FormatDiagnostic(diag_str);\n      diag_str.push_back('\\0');\n      LLDB_LOGF(m_log, \"Compiler diagnostic: %s\\n\", diag_str.data());\n    }\n  }\n\n  DiagnosticConsumer *clone(DiagnosticsEngine &Diags) const {\n    return new NullDiagnosticConsumer();\n  }\n\nprivate:\n  Log *m_log;\n};\n\nvoid TypeSystemClang::CreateASTContext() {\n  assert(!m_ast_up);\n  m_ast_owned = true;\n\n  m_language_options_up = std::make_unique<LangOptions>();\n  ParseLangArgs(*m_language_options_up, clang::Language::ObjCXX,\n                GetTargetTriple());\n\n  m_identifier_table_up =\n      std::make_unique<IdentifierTable>(*m_language_options_up, nullptr);\n  m_builtins_up = std::make_unique<Builtin::Context>();\n\n  m_selector_table_up = std::make_unique<SelectorTable>();\n\n  clang::FileSystemOptions file_system_options;\n  m_file_manager_up = std::make_unique<clang::FileManager>(\n      file_system_options, FileSystem::Instance().GetVirtualFileSystem());\n\n  llvm::IntrusiveRefCntPtr<DiagnosticIDs> diag_id_sp(new DiagnosticIDs());\n  m_diagnostics_engine_up =\n      std::make_unique<DiagnosticsEngine>(diag_id_sp, new DiagnosticOptions());\n\n  m_source_manager_up = std::make_unique<clang::SourceManager>(\n      *m_diagnostics_engine_up, *m_file_manager_up);\n  m_ast_up = std::make_unique<ASTContext>(\n      *m_language_options_up, *m_source_manager_up, *m_identifier_table_up,\n      *m_selector_table_up, *m_builtins_up);\n\n  m_diagnostic_consumer_up = std::make_unique<NullDiagnosticConsumer>();\n  m_ast_up->getDiagnostics().setClient(m_diagnostic_consumer_up.get(), false);\n\n  // This can be NULL if we don't know anything about the architecture or if\n  // the target for an architecture isn't enabled in the llvm/clang that we\n  // built\n  TargetInfo *target_info = getTargetInfo();\n  if (target_info)\n    m_ast_up->InitBuiltinTypes(*target_info);\n\n  GetASTMap().Insert(m_ast_up.get(), this);\n\n  llvm::IntrusiveRefCntPtr<clang::ExternalASTSource> ast_source_up(\n      new ClangExternalASTSourceCallbacks(*this));\n  SetExternalSource(ast_source_up);\n}\n\nTypeSystemClang *TypeSystemClang::GetASTContext(clang::ASTContext *ast) {\n  TypeSystemClang *clang_ast = GetASTMap().Lookup(ast);\n  return clang_ast;\n}\n\nclang::MangleContext *TypeSystemClang::getMangleContext() {\n  if (m_mangle_ctx_up == nullptr)\n    m_mangle_ctx_up.reset(getASTContext().createMangleContext());\n  return m_mangle_ctx_up.get();\n}\n\nstd::shared_ptr<clang::TargetOptions> &TypeSystemClang::getTargetOptions() {\n  if (m_target_options_rp == nullptr && !m_target_triple.empty()) {\n    m_target_options_rp = std::make_shared<clang::TargetOptions>();\n    if (m_target_options_rp != nullptr)\n      m_target_options_rp->Triple = m_target_triple;\n  }\n  return m_target_options_rp;\n}\n\nTargetInfo *TypeSystemClang::getTargetInfo() {\n  // target_triple should be something like \"x86_64-apple-macosx\"\n  if (m_target_info_up == nullptr && !m_target_triple.empty())\n    m_target_info_up.reset(TargetInfo::CreateTargetInfo(\n        getASTContext().getDiagnostics(), getTargetOptions()));\n  return m_target_info_up.get();\n}\n\n#pragma mark Basic Types\n\nstatic inline bool QualTypeMatchesBitSize(const uint64_t bit_size,\n                                          ASTContext &ast, QualType qual_type) {\n  uint64_t qual_type_bit_size = ast.getTypeSize(qual_type);\n  return qual_type_bit_size == bit_size;\n}\n\nCompilerType\nTypeSystemClang::GetBuiltinTypeForEncodingAndBitSize(Encoding encoding,\n                                                     size_t bit_size) {\n  ASTContext &ast = getASTContext();\n  switch (encoding) {\n  case eEncodingInvalid:\n    if (QualTypeMatchesBitSize(bit_size, ast, ast.VoidPtrTy))\n      return GetType(ast.VoidPtrTy);\n    break;\n\n  case eEncodingUint:\n    if (QualTypeMatchesBitSize(bit_size, ast, ast.UnsignedCharTy))\n      return GetType(ast.UnsignedCharTy);\n    if (QualTypeMatchesBitSize(bit_size, ast, ast.UnsignedShortTy))\n      return GetType(ast.UnsignedShortTy);\n    if (QualTypeMatchesBitSize(bit_size, ast, ast.UnsignedIntTy))\n      return GetType(ast.UnsignedIntTy);\n    if (QualTypeMatchesBitSize(bit_size, ast, ast.UnsignedLongTy))\n      return GetType(ast.UnsignedLongTy);\n    if (QualTypeMatchesBitSize(bit_size, ast, ast.UnsignedLongLongTy))\n      return GetType(ast.UnsignedLongLongTy);\n    if (QualTypeMatchesBitSize(bit_size, ast, ast.UnsignedInt128Ty))\n      return GetType(ast.UnsignedInt128Ty);\n    break;\n\n  case eEncodingSint:\n    if (QualTypeMatchesBitSize(bit_size, ast, ast.SignedCharTy))\n      return GetType(ast.SignedCharTy);\n    if (QualTypeMatchesBitSize(bit_size, ast, ast.ShortTy))\n      return GetType(ast.ShortTy);\n    if (QualTypeMatchesBitSize(bit_size, ast, ast.IntTy))\n      return GetType(ast.IntTy);\n    if (QualTypeMatchesBitSize(bit_size, ast, ast.LongTy))\n      return GetType(ast.LongTy);\n    if (QualTypeMatchesBitSize(bit_size, ast, ast.LongLongTy))\n      return GetType(ast.LongLongTy);\n    if (QualTypeMatchesBitSize(bit_size, ast, ast.Int128Ty))\n      return GetType(ast.Int128Ty);\n    break;\n\n  case eEncodingIEEE754:\n    if (QualTypeMatchesBitSize(bit_size, ast, ast.FloatTy))\n      return GetType(ast.FloatTy);\n    if (QualTypeMatchesBitSize(bit_size, ast, ast.DoubleTy))\n      return GetType(ast.DoubleTy);\n    if (QualTypeMatchesBitSize(bit_size, ast, ast.LongDoubleTy))\n      return GetType(ast.LongDoubleTy);\n    if (QualTypeMatchesBitSize(bit_size, ast, ast.HalfTy))\n      return GetType(ast.HalfTy);\n    break;\n\n  case eEncodingVector:\n    // Sanity check that bit_size is a multiple of 8's.\n    if (bit_size && !(bit_size & 0x7u))\n      return GetType(ast.getExtVectorType(ast.UnsignedCharTy, bit_size / 8));\n    break;\n  }\n\n  return CompilerType();\n}\n\nlldb::BasicType\nTypeSystemClang::GetBasicTypeEnumeration(ConstString name) {\n  if (name) {\n    typedef UniqueCStringMap<lldb::BasicType> TypeNameToBasicTypeMap;\n    static TypeNameToBasicTypeMap g_type_map;\n    static llvm::once_flag g_once_flag;\n    llvm::call_once(g_once_flag, []() {\n      // \"void\"\n      g_type_map.Append(ConstString(\"void\"), eBasicTypeVoid);\n\n      // \"char\"\n      g_type_map.Append(ConstString(\"char\"), eBasicTypeChar);\n      g_type_map.Append(ConstString(\"signed char\"), eBasicTypeSignedChar);\n      g_type_map.Append(ConstString(\"unsigned char\"), eBasicTypeUnsignedChar);\n      g_type_map.Append(ConstString(\"wchar_t\"), eBasicTypeWChar);\n      g_type_map.Append(ConstString(\"signed wchar_t\"), eBasicTypeSignedWChar);\n      g_type_map.Append(ConstString(\"unsigned wchar_t\"),\n                        eBasicTypeUnsignedWChar);\n      // \"short\"\n      g_type_map.Append(ConstString(\"short\"), eBasicTypeShort);\n      g_type_map.Append(ConstString(\"short int\"), eBasicTypeShort);\n      g_type_map.Append(ConstString(\"unsigned short\"), eBasicTypeUnsignedShort);\n      g_type_map.Append(ConstString(\"unsigned short int\"),\n                        eBasicTypeUnsignedShort);\n\n      // \"int\"\n      g_type_map.Append(ConstString(\"int\"), eBasicTypeInt);\n      g_type_map.Append(ConstString(\"signed int\"), eBasicTypeInt);\n      g_type_map.Append(ConstString(\"unsigned int\"), eBasicTypeUnsignedInt);\n      g_type_map.Append(ConstString(\"unsigned\"), eBasicTypeUnsignedInt);\n\n      // \"long\"\n      g_type_map.Append(ConstString(\"long\"), eBasicTypeLong);\n      g_type_map.Append(ConstString(\"long int\"), eBasicTypeLong);\n      g_type_map.Append(ConstString(\"unsigned long\"), eBasicTypeUnsignedLong);\n      g_type_map.Append(ConstString(\"unsigned long int\"),\n                        eBasicTypeUnsignedLong);\n\n      // \"long long\"\n      g_type_map.Append(ConstString(\"long long\"), eBasicTypeLongLong);\n      g_type_map.Append(ConstString(\"long long int\"), eBasicTypeLongLong);\n      g_type_map.Append(ConstString(\"unsigned long long\"),\n                        eBasicTypeUnsignedLongLong);\n      g_type_map.Append(ConstString(\"unsigned long long int\"),\n                        eBasicTypeUnsignedLongLong);\n\n      // \"int128\"\n      g_type_map.Append(ConstString(\"__int128_t\"), eBasicTypeInt128);\n      g_type_map.Append(ConstString(\"__uint128_t\"), eBasicTypeUnsignedInt128);\n\n      // Miscellaneous\n      g_type_map.Append(ConstString(\"bool\"), eBasicTypeBool);\n      g_type_map.Append(ConstString(\"float\"), eBasicTypeFloat);\n      g_type_map.Append(ConstString(\"double\"), eBasicTypeDouble);\n      g_type_map.Append(ConstString(\"long double\"), eBasicTypeLongDouble);\n      g_type_map.Append(ConstString(\"id\"), eBasicTypeObjCID);\n      g_type_map.Append(ConstString(\"SEL\"), eBasicTypeObjCSel);\n      g_type_map.Append(ConstString(\"nullptr\"), eBasicTypeNullPtr);\n      g_type_map.Sort();\n    });\n\n    return g_type_map.Find(name, eBasicTypeInvalid);\n  }\n  return eBasicTypeInvalid;\n}\n\nuint32_t TypeSystemClang::GetPointerByteSize() {\n  if (m_pointer_byte_size == 0)\n    if (auto size = GetBasicType(lldb::eBasicTypeVoid)\n                        .GetPointerType()\n                        .GetByteSize(nullptr))\n      m_pointer_byte_size = *size;\n  return m_pointer_byte_size;\n}\n\nCompilerType TypeSystemClang::GetBasicType(lldb::BasicType basic_type) {\n  clang::ASTContext &ast = getASTContext();\n\n  lldb::opaque_compiler_type_t clang_type =\n      GetOpaqueCompilerType(&ast, basic_type);\n\n  if (clang_type)\n    return CompilerType(this, clang_type);\n  return CompilerType();\n}\n\nCompilerType TypeSystemClang::GetBuiltinTypeForDWARFEncodingAndBitSize(\n    llvm::StringRef type_name, uint32_t dw_ate, uint32_t bit_size) {\n  ASTContext &ast = getASTContext();\n\n  switch (dw_ate) {\n  default:\n    break;\n\n  case DW_ATE_address:\n    if (QualTypeMatchesBitSize(bit_size, ast, ast.VoidPtrTy))\n      return GetType(ast.VoidPtrTy);\n    break;\n\n  case DW_ATE_boolean:\n    if (QualTypeMatchesBitSize(bit_size, ast, ast.BoolTy))\n      return GetType(ast.BoolTy);\n    if (QualTypeMatchesBitSize(bit_size, ast, ast.UnsignedCharTy))\n      return GetType(ast.UnsignedCharTy);\n    if (QualTypeMatchesBitSize(bit_size, ast, ast.UnsignedShortTy))\n      return GetType(ast.UnsignedShortTy);\n    if (QualTypeMatchesBitSize(bit_size, ast, ast.UnsignedIntTy))\n      return GetType(ast.UnsignedIntTy);\n    break;\n\n  case DW_ATE_lo_user:\n    // This has been seen to mean DW_AT_complex_integer\n    if (type_name.contains(\"complex\")) {\n      CompilerType complex_int_clang_type =\n          GetBuiltinTypeForDWARFEncodingAndBitSize(\"int\", DW_ATE_signed,\n                                                   bit_size / 2);\n      return GetType(\n          ast.getComplexType(ClangUtil::GetQualType(complex_int_clang_type)));\n    }\n    break;\n\n  case DW_ATE_complex_float:\n    if (QualTypeMatchesBitSize(bit_size, ast, ast.FloatComplexTy))\n      return GetType(ast.FloatComplexTy);\n    else if (QualTypeMatchesBitSize(bit_size, ast, ast.DoubleComplexTy))\n      return GetType(ast.DoubleComplexTy);\n    else if (QualTypeMatchesBitSize(bit_size, ast, ast.LongDoubleComplexTy))\n      return GetType(ast.LongDoubleComplexTy);\n    else {\n      CompilerType complex_float_clang_type =\n          GetBuiltinTypeForDWARFEncodingAndBitSize(\"float\", DW_ATE_float,\n                                                   bit_size / 2);\n      return GetType(\n          ast.getComplexType(ClangUtil::GetQualType(complex_float_clang_type)));\n    }\n    break;\n\n  case DW_ATE_float:\n    if (type_name == \"float\" &&\n        QualTypeMatchesBitSize(bit_size, ast, ast.FloatTy))\n      return GetType(ast.FloatTy);\n    if (type_name == \"double\" &&\n        QualTypeMatchesBitSize(bit_size, ast, ast.DoubleTy))\n      return GetType(ast.DoubleTy);\n    if (type_name == \"long double\" &&\n        QualTypeMatchesBitSize(bit_size, ast, ast.LongDoubleTy))\n      return GetType(ast.LongDoubleTy);\n    // Fall back to not requiring a name match\n    if (QualTypeMatchesBitSize(bit_size, ast, ast.FloatTy))\n      return GetType(ast.FloatTy);\n    if (QualTypeMatchesBitSize(bit_size, ast, ast.DoubleTy))\n      return GetType(ast.DoubleTy);\n    if (QualTypeMatchesBitSize(bit_size, ast, ast.LongDoubleTy))\n      return GetType(ast.LongDoubleTy);\n    if (QualTypeMatchesBitSize(bit_size, ast, ast.HalfTy))\n      return GetType(ast.HalfTy);\n    break;\n\n  case DW_ATE_signed:\n    if (!type_name.empty()) {\n      if (type_name == \"wchar_t\" &&\n          QualTypeMatchesBitSize(bit_size, ast, ast.WCharTy) &&\n          (getTargetInfo() &&\n           TargetInfo::isTypeSigned(getTargetInfo()->getWCharType())))\n        return GetType(ast.WCharTy);\n      if (type_name == \"void\" &&\n          QualTypeMatchesBitSize(bit_size, ast, ast.VoidTy))\n        return GetType(ast.VoidTy);\n      if (type_name.contains(\"long long\") &&\n          QualTypeMatchesBitSize(bit_size, ast, ast.LongLongTy))\n        return GetType(ast.LongLongTy);\n      if (type_name.contains(\"long\") &&\n          QualTypeMatchesBitSize(bit_size, ast, ast.LongTy))\n        return GetType(ast.LongTy);\n      if (type_name.contains(\"short\") &&\n          QualTypeMatchesBitSize(bit_size, ast, ast.ShortTy))\n        return GetType(ast.ShortTy);\n      if (type_name.contains(\"char\")) {\n        if (QualTypeMatchesBitSize(bit_size, ast, ast.CharTy))\n          return GetType(ast.CharTy);\n        if (QualTypeMatchesBitSize(bit_size, ast, ast.SignedCharTy))\n          return GetType(ast.SignedCharTy);\n      }\n      if (type_name.contains(\"int\")) {\n        if (QualTypeMatchesBitSize(bit_size, ast, ast.IntTy))\n          return GetType(ast.IntTy);\n        if (QualTypeMatchesBitSize(bit_size, ast, ast.Int128Ty))\n          return GetType(ast.Int128Ty);\n      }\n    }\n    // We weren't able to match up a type name, just search by size\n    if (QualTypeMatchesBitSize(bit_size, ast, ast.CharTy))\n      return GetType(ast.CharTy);\n    if (QualTypeMatchesBitSize(bit_size, ast, ast.ShortTy))\n      return GetType(ast.ShortTy);\n    if (QualTypeMatchesBitSize(bit_size, ast, ast.IntTy))\n      return GetType(ast.IntTy);\n    if (QualTypeMatchesBitSize(bit_size, ast, ast.LongTy))\n      return GetType(ast.LongTy);\n    if (QualTypeMatchesBitSize(bit_size, ast, ast.LongLongTy))\n      return GetType(ast.LongLongTy);\n    if (QualTypeMatchesBitSize(bit_size, ast, ast.Int128Ty))\n      return GetType(ast.Int128Ty);\n    break;\n\n  case DW_ATE_signed_char:\n    if (ast.getLangOpts().CharIsSigned && type_name == \"char\") {\n      if (QualTypeMatchesBitSize(bit_size, ast, ast.CharTy))\n        return GetType(ast.CharTy);\n    }\n    if (QualTypeMatchesBitSize(bit_size, ast, ast.SignedCharTy))\n      return GetType(ast.SignedCharTy);\n    break;\n\n  case DW_ATE_unsigned:\n    if (!type_name.empty()) {\n      if (type_name == \"wchar_t\") {\n        if (QualTypeMatchesBitSize(bit_size, ast, ast.WCharTy)) {\n          if (!(getTargetInfo() &&\n                TargetInfo::isTypeSigned(getTargetInfo()->getWCharType())))\n            return GetType(ast.WCharTy);\n        }\n      }\n      if (type_name.contains(\"long long\")) {\n        if (QualTypeMatchesBitSize(bit_size, ast, ast.UnsignedLongLongTy))\n          return GetType(ast.UnsignedLongLongTy);\n      } else if (type_name.contains(\"long\")) {\n        if (QualTypeMatchesBitSize(bit_size, ast, ast.UnsignedLongTy))\n          return GetType(ast.UnsignedLongTy);\n      } else if (type_name.contains(\"short\")) {\n        if (QualTypeMatchesBitSize(bit_size, ast, ast.UnsignedShortTy))\n          return GetType(ast.UnsignedShortTy);\n      } else if (type_name.contains(\"char\")) {\n        if (QualTypeMatchesBitSize(bit_size, ast, ast.UnsignedCharTy))\n          return GetType(ast.UnsignedCharTy);\n      } else if (type_name.contains(\"int\")) {\n        if (QualTypeMatchesBitSize(bit_size, ast, ast.UnsignedIntTy))\n          return GetType(ast.UnsignedIntTy);\n        if (QualTypeMatchesBitSize(bit_size, ast, ast.UnsignedInt128Ty))\n          return GetType(ast.UnsignedInt128Ty);\n      }\n    }\n    // We weren't able to match up a type name, just search by size\n    if (QualTypeMatchesBitSize(bit_size, ast, ast.UnsignedCharTy))\n      return GetType(ast.UnsignedCharTy);\n    if (QualTypeMatchesBitSize(bit_size, ast, ast.UnsignedShortTy))\n      return GetType(ast.UnsignedShortTy);\n    if (QualTypeMatchesBitSize(bit_size, ast, ast.UnsignedIntTy))\n      return GetType(ast.UnsignedIntTy);\n    if (QualTypeMatchesBitSize(bit_size, ast, ast.UnsignedLongTy))\n      return GetType(ast.UnsignedLongTy);\n    if (QualTypeMatchesBitSize(bit_size, ast, ast.UnsignedLongLongTy))\n      return GetType(ast.UnsignedLongLongTy);\n    if (QualTypeMatchesBitSize(bit_size, ast, ast.UnsignedInt128Ty))\n      return GetType(ast.UnsignedInt128Ty);\n    break;\n\n  case DW_ATE_unsigned_char:\n    if (!ast.getLangOpts().CharIsSigned && type_name == \"char\") {\n      if (QualTypeMatchesBitSize(bit_size, ast, ast.CharTy))\n        return GetType(ast.CharTy);\n    }\n    if (QualTypeMatchesBitSize(bit_size, ast, ast.UnsignedCharTy))\n      return GetType(ast.UnsignedCharTy);\n    if (QualTypeMatchesBitSize(bit_size, ast, ast.UnsignedShortTy))\n      return GetType(ast.UnsignedShortTy);\n    break;\n\n  case DW_ATE_imaginary_float:\n    break;\n\n  case DW_ATE_UTF:\n    switch (bit_size) {\n    case 8:\n      return GetType(ast.Char8Ty);\n    case 16:\n      return GetType(ast.Char16Ty);\n    case 32:\n      return GetType(ast.Char32Ty);\n    default:\n      if (!type_name.empty()) {\n        if (type_name == \"char16_t\")\n          return GetType(ast.Char16Ty);\n        if (type_name == \"char32_t\")\n          return GetType(ast.Char32Ty);\n        if (type_name == \"char8_t\")\n          return GetType(ast.Char8Ty);\n      }\n    }\n    break;\n  }\n  // This assert should fire for anything that we don't catch above so we know\n  // to fix any issues we run into.\n  if (!type_name.empty()) {\n    std::string type_name_str = type_name.str();\n    Host::SystemLog(Host::eSystemLogError,\n                    \"error: need to add support for DW_TAG_base_type '%s' \"\n                    \"encoded with DW_ATE = 0x%x, bit_size = %u\\n\",\n                    type_name_str.c_str(), dw_ate, bit_size);\n  } else {\n    Host::SystemLog(Host::eSystemLogError, \"error: need to add support for \"\n                                           \"DW_TAG_base_type encoded with \"\n                                           \"DW_ATE = 0x%x, bit_size = %u\\n\",\n                    dw_ate, bit_size);\n  }\n  return CompilerType();\n}\n\nCompilerType TypeSystemClang::GetCStringType(bool is_const) {\n  ASTContext &ast = getASTContext();\n  QualType char_type(ast.CharTy);\n\n  if (is_const)\n    char_type.addConst();\n\n  return GetType(ast.getPointerType(char_type));\n}\n\nbool TypeSystemClang::AreTypesSame(CompilerType type1, CompilerType type2,\n                                   bool ignore_qualifiers) {\n  TypeSystemClang *ast =\n      llvm::dyn_cast_or_null<TypeSystemClang>(type1.GetTypeSystem());\n  if (!ast || ast != type2.GetTypeSystem())\n    return false;\n\n  if (type1.GetOpaqueQualType() == type2.GetOpaqueQualType())\n    return true;\n\n  QualType type1_qual = ClangUtil::GetQualType(type1);\n  QualType type2_qual = ClangUtil::GetQualType(type2);\n\n  if (ignore_qualifiers) {\n    type1_qual = type1_qual.getUnqualifiedType();\n    type2_qual = type2_qual.getUnqualifiedType();\n  }\n\n  return ast->getASTContext().hasSameType(type1_qual, type2_qual);\n}\n\nCompilerType TypeSystemClang::GetTypeForDecl(void *opaque_decl) {\n  if (!opaque_decl)\n    return CompilerType();\n\n  clang::Decl *decl = static_cast<clang::Decl *>(opaque_decl);\n  if (auto *named_decl = llvm::dyn_cast<clang::NamedDecl>(decl))\n    return GetTypeForDecl(named_decl);\n  return CompilerType();\n}\n\nCompilerDeclContext TypeSystemClang::CreateDeclContext(DeclContext *ctx) {\n  // Check that the DeclContext actually belongs to this ASTContext.\n  assert(&ctx->getParentASTContext() == &getASTContext());\n  return CompilerDeclContext(this, ctx);\n}\n\nCompilerType TypeSystemClang::GetTypeForDecl(clang::NamedDecl *decl) {\n  if (clang::ObjCInterfaceDecl *interface_decl =\n      llvm::dyn_cast<clang::ObjCInterfaceDecl>(decl))\n    return GetTypeForDecl(interface_decl);\n  if (clang::TagDecl *tag_decl = llvm::dyn_cast<clang::TagDecl>(decl))\n    return GetTypeForDecl(tag_decl);\n  return CompilerType();\n}\n\nCompilerType TypeSystemClang::GetTypeForDecl(TagDecl *decl) {\n  return GetType(getASTContext().getTagDeclType(decl));\n}\n\nCompilerType TypeSystemClang::GetTypeForDecl(ObjCInterfaceDecl *decl) {\n  return GetType(getASTContext().getObjCInterfaceType(decl));\n}\n\n#pragma mark Structure, Unions, Classes\n\nvoid TypeSystemClang::SetOwningModule(clang::Decl *decl,\n                                      OptionalClangModuleID owning_module) {\n  if (!decl || !owning_module.HasValue())\n    return;\n\n  decl->setFromASTFile();\n  decl->setOwningModuleID(owning_module.GetValue());\n  decl->setModuleOwnershipKind(clang::Decl::ModuleOwnershipKind::Visible);\n}\n\nOptionalClangModuleID\nTypeSystemClang::GetOrCreateClangModule(llvm::StringRef name,\n                                        OptionalClangModuleID parent,\n                                        bool is_framework, bool is_explicit) {\n  // Get the external AST source which holds the modules.\n  auto *ast_source = llvm::dyn_cast_or_null<ClangExternalASTSourceCallbacks>(\n      getASTContext().getExternalSource());\n  assert(ast_source && \"external ast source was lost\");\n  if (!ast_source)\n    return {};\n\n  // Lazily initialize the module map.\n  if (!m_header_search_up) {\n    auto HSOpts = std::make_shared<clang::HeaderSearchOptions>();\n    m_header_search_up = std::make_unique<clang::HeaderSearch>(\n        HSOpts, *m_source_manager_up, *m_diagnostics_engine_up,\n        *m_language_options_up, m_target_info_up.get());\n    m_module_map_up = std::make_unique<clang::ModuleMap>(\n        *m_source_manager_up, *m_diagnostics_engine_up, *m_language_options_up,\n        m_target_info_up.get(), *m_header_search_up);\n  }\n\n  // Get or create the module context.\n  bool created;\n  clang::Module *module;\n  auto parent_desc = ast_source->getSourceDescriptor(parent.GetValue());\n  std::tie(module, created) = m_module_map_up->findOrCreateModule(\n      name, parent_desc ? parent_desc->getModuleOrNull() : nullptr,\n      is_framework, is_explicit);\n  if (!created)\n    return ast_source->GetIDForModule(module);\n\n  return ast_source->RegisterModule(module);\n}\n\nCompilerType TypeSystemClang::CreateRecordType(\n    clang::DeclContext *decl_ctx, OptionalClangModuleID owning_module,\n    AccessType access_type, llvm::StringRef name, int kind,\n    LanguageType language, ClangASTMetadata *metadata, bool exports_symbols) {\n  ASTContext &ast = getASTContext();\n\n  if (decl_ctx == nullptr)\n    decl_ctx = ast.getTranslationUnitDecl();\n\n  if (language == eLanguageTypeObjC ||\n      language == eLanguageTypeObjC_plus_plus) {\n    bool isForwardDecl = true;\n    bool isInternal = false;\n    return CreateObjCClass(name, decl_ctx, owning_module, isForwardDecl,\n                           isInternal, metadata);\n  }\n\n  // NOTE: Eventually CXXRecordDecl will be merged back into RecordDecl and\n  // we will need to update this code. I was told to currently always use the\n  // CXXRecordDecl class since we often don't know from debug information if\n  // something is struct or a class, so we default to always use the more\n  // complete definition just in case.\n\n  bool has_name = !name.empty();\n  CXXRecordDecl *decl = CXXRecordDecl::CreateDeserialized(ast, 0);\n  decl->setTagKind(static_cast<TagDecl::TagKind>(kind));\n  decl->setDeclContext(decl_ctx);\n  if (has_name)\n    decl->setDeclName(&ast.Idents.get(name));\n  SetOwningModule(decl, owning_module);\n\n  if (!has_name) {\n    // In C++ a lambda is also represented as an unnamed class. This is\n    // different from an *anonymous class* that the user wrote:\n    //\n    // struct A {\n    //  // anonymous class (GNU/MSVC extension)\n    //  struct {\n    //    int x;\n    //  };\n    //  // unnamed class within a class\n    //  struct {\n    //    int y;\n    //  } B;\n    // };\n    //\n    // void f() {\n    //    // unammed class outside of a class\n    //    struct {\n    //      int z;\n    //    } C;\n    // }\n    //\n    // Anonymous classes is a GNU/MSVC extension that clang supports. It\n    // requires the anonymous class be embedded within a class. So the new\n    // heuristic verifies this condition.\n    if (isa<CXXRecordDecl>(decl_ctx) && exports_symbols)\n      decl->setAnonymousStructOrUnion(true);\n  }\n\n  if (decl) {\n    if (metadata)\n      SetMetadata(decl, *metadata);\n\n    if (access_type != eAccessNone)\n      decl->setAccess(ConvertAccessTypeToAccessSpecifier(access_type));\n\n    if (decl_ctx)\n      decl_ctx->addDecl(decl);\n\n    return GetType(ast.getTagDeclType(decl));\n  }\n  return CompilerType();\n}\n\nnamespace {\n  bool IsValueParam(const clang::TemplateArgument &argument) {\n    return argument.getKind() == TemplateArgument::Integral;\n  }\n}\n\nstatic TemplateParameterList *CreateTemplateParameterList(\n    ASTContext &ast,\n    const TypeSystemClang::TemplateParameterInfos &template_param_infos,\n    llvm::SmallVector<NamedDecl *, 8> &template_param_decls) {\n  const bool parameter_pack = false;\n  const bool is_typename = false;\n  const unsigned depth = 0;\n  const size_t num_template_params = template_param_infos.args.size();\n  DeclContext *const decl_context =\n      ast.getTranslationUnitDecl(); // Is this the right decl context?,\n  for (size_t i = 0; i < num_template_params; ++i) {\n    const char *name = template_param_infos.names[i];\n\n    IdentifierInfo *identifier_info = nullptr;\n    if (name && name[0])\n      identifier_info = &ast.Idents.get(name);\n    if (IsValueParam(template_param_infos.args[i])) {\n      QualType template_param_type =\n          template_param_infos.args[i].getIntegralType();\n      template_param_decls.push_back(NonTypeTemplateParmDecl::Create(\n          ast, decl_context, SourceLocation(), SourceLocation(), depth, i,\n          identifier_info, template_param_type, parameter_pack,\n          ast.getTrivialTypeSourceInfo(template_param_type)));\n    } else {\n      template_param_decls.push_back(TemplateTypeParmDecl::Create(\n          ast, decl_context, SourceLocation(), SourceLocation(), depth, i,\n          identifier_info, is_typename, parameter_pack));\n    }\n  }\n\n  if (template_param_infos.packed_args) {\n    IdentifierInfo *identifier_info = nullptr;\n    if (template_param_infos.pack_name && template_param_infos.pack_name[0])\n      identifier_info = &ast.Idents.get(template_param_infos.pack_name);\n    const bool parameter_pack_true = true;\n\n    if (!template_param_infos.packed_args->args.empty() &&\n        IsValueParam(template_param_infos.packed_args->args[0])) {\n      QualType template_param_type =\n          template_param_infos.packed_args->args[0].getIntegralType();\n      template_param_decls.push_back(NonTypeTemplateParmDecl::Create(\n          ast, decl_context, SourceLocation(), SourceLocation(), depth,\n          num_template_params, identifier_info, template_param_type,\n          parameter_pack_true,\n          ast.getTrivialTypeSourceInfo(template_param_type)));\n    } else {\n      template_param_decls.push_back(TemplateTypeParmDecl::Create(\n          ast, decl_context, SourceLocation(), SourceLocation(), depth,\n          num_template_params, identifier_info, is_typename,\n          parameter_pack_true));\n    }\n  }\n  clang::Expr *const requires_clause = nullptr; // TODO: Concepts\n  TemplateParameterList *template_param_list = TemplateParameterList::Create(\n      ast, SourceLocation(), SourceLocation(), template_param_decls,\n      SourceLocation(), requires_clause);\n  return template_param_list;\n}\n\nclang::FunctionTemplateDecl *TypeSystemClang::CreateFunctionTemplateDecl(\n    clang::DeclContext *decl_ctx, OptionalClangModuleID owning_module,\n    clang::FunctionDecl *func_decl,\n    const TemplateParameterInfos &template_param_infos) {\n  //    /// Create a function template node.\n  ASTContext &ast = getASTContext();\n\n  llvm::SmallVector<NamedDecl *, 8> template_param_decls;\n  TemplateParameterList *template_param_list = CreateTemplateParameterList(\n      ast, template_param_infos, template_param_decls);\n  FunctionTemplateDecl *func_tmpl_decl =\n      FunctionTemplateDecl::CreateDeserialized(ast, 0);\n  func_tmpl_decl->setDeclContext(decl_ctx);\n  func_tmpl_decl->setLocation(func_decl->getLocation());\n  func_tmpl_decl->setDeclName(func_decl->getDeclName());\n  func_tmpl_decl->init(func_decl, template_param_list);\n  SetOwningModule(func_tmpl_decl, owning_module);\n\n  for (size_t i = 0, template_param_decl_count = template_param_decls.size();\n       i < template_param_decl_count; ++i) {\n    // TODO: verify which decl context we should put template_param_decls into..\n    template_param_decls[i]->setDeclContext(func_decl);\n  }\n  // Function templates inside a record need to have an access specifier.\n  // It doesn't matter what access specifier we give the template as LLDB\n  // anyway allows accessing everything inside a record.\n  if (decl_ctx->isRecord())\n    func_tmpl_decl->setAccess(clang::AccessSpecifier::AS_public);\n\n  return func_tmpl_decl;\n}\n\nvoid TypeSystemClang::CreateFunctionTemplateSpecializationInfo(\n    FunctionDecl *func_decl, clang::FunctionTemplateDecl *func_tmpl_decl,\n    const TemplateParameterInfos &infos) {\n  TemplateArgumentList *template_args_ptr =\n      TemplateArgumentList::CreateCopy(func_decl->getASTContext(), infos.args);\n\n  func_decl->setFunctionTemplateSpecialization(func_tmpl_decl,\n                                               template_args_ptr, nullptr);\n}\n\nClassTemplateDecl *TypeSystemClang::CreateClassTemplateDecl(\n    DeclContext *decl_ctx, OptionalClangModuleID owning_module,\n    lldb::AccessType access_type, const char *class_name, int kind,\n    const TemplateParameterInfos &template_param_infos) {\n  ASTContext &ast = getASTContext();\n\n  ClassTemplateDecl *class_template_decl = nullptr;\n  if (decl_ctx == nullptr)\n    decl_ctx = ast.getTranslationUnitDecl();\n\n  IdentifierInfo &identifier_info = ast.Idents.get(class_name);\n  DeclarationName decl_name(&identifier_info);\n\n  clang::DeclContext::lookup_result result = decl_ctx->lookup(decl_name);\n\n  for (NamedDecl *decl : result) {\n    class_template_decl = dyn_cast<clang::ClassTemplateDecl>(decl);\n    if (class_template_decl)\n      return class_template_decl;\n  }\n\n  llvm::SmallVector<NamedDecl *, 8> template_param_decls;\n\n  TemplateParameterList *template_param_list = CreateTemplateParameterList(\n      ast, template_param_infos, template_param_decls);\n\n  CXXRecordDecl *template_cxx_decl = CXXRecordDecl::CreateDeserialized(ast, 0);\n  template_cxx_decl->setTagKind(static_cast<TagDecl::TagKind>(kind));\n  // What decl context do we use here? TU? The actual decl context?\n  template_cxx_decl->setDeclContext(decl_ctx);\n  template_cxx_decl->setDeclName(decl_name);\n  SetOwningModule(template_cxx_decl, owning_module);\n\n  for (size_t i = 0, template_param_decl_count = template_param_decls.size();\n       i < template_param_decl_count; ++i) {\n    template_param_decls[i]->setDeclContext(template_cxx_decl);\n  }\n\n  // With templated classes, we say that a class is templated with\n  // specializations, but that the bare class has no functions.\n  // template_cxx_decl->startDefinition();\n  // template_cxx_decl->completeDefinition();\n\n  class_template_decl = ClassTemplateDecl::CreateDeserialized(ast, 0);\n  // What decl context do we use here? TU? The actual decl context?\n  class_template_decl->setDeclContext(decl_ctx);\n  class_template_decl->setDeclName(decl_name);\n  class_template_decl->init(template_cxx_decl, template_param_list);\n  template_cxx_decl->setDescribedClassTemplate(class_template_decl);\n  SetOwningModule(class_template_decl, owning_module);\n\n  if (class_template_decl) {\n    if (access_type != eAccessNone)\n      class_template_decl->setAccess(\n          ConvertAccessTypeToAccessSpecifier(access_type));\n\n    decl_ctx->addDecl(class_template_decl);\n\n    VerifyDecl(class_template_decl);\n  }\n\n  return class_template_decl;\n}\n\nTemplateTemplateParmDecl *\nTypeSystemClang::CreateTemplateTemplateParmDecl(const char *template_name) {\n  ASTContext &ast = getASTContext();\n\n  auto *decl_ctx = ast.getTranslationUnitDecl();\n\n  IdentifierInfo &identifier_info = ast.Idents.get(template_name);\n  llvm::SmallVector<NamedDecl *, 8> template_param_decls;\n\n  TypeSystemClang::TemplateParameterInfos template_param_infos;\n  TemplateParameterList *template_param_list = CreateTemplateParameterList(\n      ast, template_param_infos, template_param_decls);\n\n  // LLDB needs to create those decls only to be able to display a\n  // type that includes a template template argument. Only the name matters for\n  // this purpose, so we use dummy values for the other characteristics of the\n  // type.\n  return TemplateTemplateParmDecl::Create(\n      ast, decl_ctx, SourceLocation(),\n      /*Depth*/ 0, /*Position*/ 0,\n      /*IsParameterPack*/ false, &identifier_info, template_param_list);\n}\n\nClassTemplateSpecializationDecl *\nTypeSystemClang::CreateClassTemplateSpecializationDecl(\n    DeclContext *decl_ctx, OptionalClangModuleID owning_module,\n    ClassTemplateDecl *class_template_decl, int kind,\n    const TemplateParameterInfos &template_param_infos) {\n  ASTContext &ast = getASTContext();\n  llvm::SmallVector<clang::TemplateArgument, 2> args(\n      template_param_infos.args.size() +\n      (template_param_infos.packed_args ? 1 : 0));\n  std::copy(template_param_infos.args.begin(), template_param_infos.args.end(),\n            args.begin());\n  if (template_param_infos.packed_args) {\n    args[args.size() - 1] = TemplateArgument::CreatePackCopy(\n        ast, template_param_infos.packed_args->args);\n  }\n  ClassTemplateSpecializationDecl *class_template_specialization_decl =\n      ClassTemplateSpecializationDecl::CreateDeserialized(ast, 0);\n  class_template_specialization_decl->setTagKind(\n      static_cast<TagDecl::TagKind>(kind));\n  class_template_specialization_decl->setDeclContext(decl_ctx);\n  class_template_specialization_decl->setInstantiationOf(class_template_decl);\n  class_template_specialization_decl->setTemplateArgs(\n      TemplateArgumentList::CreateCopy(ast, args));\n  ast.getTypeDeclType(class_template_specialization_decl, nullptr);\n  class_template_specialization_decl->setDeclName(\n      class_template_decl->getDeclName());\n  SetOwningModule(class_template_specialization_decl, owning_module);\n  decl_ctx->addDecl(class_template_specialization_decl);\n\n  class_template_specialization_decl->setSpecializationKind(\n      TSK_ExplicitSpecialization);\n\n  return class_template_specialization_decl;\n}\n\nCompilerType TypeSystemClang::CreateClassTemplateSpecializationType(\n    ClassTemplateSpecializationDecl *class_template_specialization_decl) {\n  if (class_template_specialization_decl) {\n    ASTContext &ast = getASTContext();\n    return GetType(ast.getTagDeclType(class_template_specialization_decl));\n  }\n  return CompilerType();\n}\n\nstatic inline bool check_op_param(bool is_method,\n                                  clang::OverloadedOperatorKind op_kind,\n                                  bool unary, bool binary,\n                                  uint32_t num_params) {\n  // Special-case call since it can take any number of operands\n  if (op_kind == OO_Call)\n    return true;\n\n  // The parameter count doesn't include \"this\"\n  if (is_method)\n    ++num_params;\n  if (num_params == 1)\n    return unary;\n  if (num_params == 2)\n    return binary;\n  else\n    return false;\n}\n\nbool TypeSystemClang::CheckOverloadedOperatorKindParameterCount(\n    bool is_method, clang::OverloadedOperatorKind op_kind,\n    uint32_t num_params) {\n  switch (op_kind) {\n  default:\n    break;\n  // C++ standard allows any number of arguments to new/delete\n  case OO_New:\n  case OO_Array_New:\n  case OO_Delete:\n  case OO_Array_Delete:\n    return true;\n  }\n\n#define OVERLOADED_OPERATOR(Name, Spelling, Token, Unary, Binary, MemberOnly)  \\\n  case OO_##Name:                                                              \\\n    return check_op_param(is_method, op_kind, Unary, Binary, num_params);\n  switch (op_kind) {\n#include \"clang/Basic/OperatorKinds.def\"\n  default:\n    break;\n  }\n  return false;\n}\n\nclang::AccessSpecifier\nTypeSystemClang::UnifyAccessSpecifiers(clang::AccessSpecifier lhs,\n                                       clang::AccessSpecifier rhs) {\n  // Make the access equal to the stricter of the field and the nested field's\n  // access\n  if (lhs == AS_none || rhs == AS_none)\n    return AS_none;\n  if (lhs == AS_private || rhs == AS_private)\n    return AS_private;\n  if (lhs == AS_protected || rhs == AS_protected)\n    return AS_protected;\n  return AS_public;\n}\n\nbool TypeSystemClang::FieldIsBitfield(FieldDecl *field,\n                                      uint32_t &bitfield_bit_size) {\n  ASTContext &ast = getASTContext();\n  if (field == nullptr)\n    return false;\n\n  if (field->isBitField()) {\n    Expr *bit_width_expr = field->getBitWidth();\n    if (bit_width_expr) {\n      if (Optional<llvm::APSInt> bit_width_apsint =\n              bit_width_expr->getIntegerConstantExpr(ast)) {\n        bitfield_bit_size = bit_width_apsint->getLimitedValue(UINT32_MAX);\n        return true;\n      }\n    }\n  }\n  return false;\n}\n\nbool TypeSystemClang::RecordHasFields(const RecordDecl *record_decl) {\n  if (record_decl == nullptr)\n    return false;\n\n  if (!record_decl->field_empty())\n    return true;\n\n  // No fields, lets check this is a CXX record and check the base classes\n  const CXXRecordDecl *cxx_record_decl = dyn_cast<CXXRecordDecl>(record_decl);\n  if (cxx_record_decl) {\n    CXXRecordDecl::base_class_const_iterator base_class, base_class_end;\n    for (base_class = cxx_record_decl->bases_begin(),\n        base_class_end = cxx_record_decl->bases_end();\n         base_class != base_class_end; ++base_class) {\n      const CXXRecordDecl *base_class_decl = cast<CXXRecordDecl>(\n          base_class->getType()->getAs<RecordType>()->getDecl());\n      if (RecordHasFields(base_class_decl))\n        return true;\n    }\n  }\n  return false;\n}\n\n#pragma mark Objective-C Classes\n\nCompilerType TypeSystemClang::CreateObjCClass(\n    llvm::StringRef name, clang::DeclContext *decl_ctx,\n    OptionalClangModuleID owning_module, bool isForwardDecl, bool isInternal,\n    ClangASTMetadata *metadata) {\n  ASTContext &ast = getASTContext();\n  assert(!name.empty());\n  if (!decl_ctx)\n    decl_ctx = ast.getTranslationUnitDecl();\n\n  ObjCInterfaceDecl *decl = ObjCInterfaceDecl::CreateDeserialized(ast, 0);\n  decl->setDeclContext(decl_ctx);\n  decl->setDeclName(&ast.Idents.get(name));\n  /*isForwardDecl,*/\n  decl->setImplicit(isInternal);\n  SetOwningModule(decl, owning_module);\n\n  if (decl && metadata)\n    SetMetadata(decl, *metadata);\n\n  return GetType(ast.getObjCInterfaceType(decl));\n}\n\nstatic inline bool BaseSpecifierIsEmpty(const CXXBaseSpecifier *b) {\n  return !TypeSystemClang::RecordHasFields(b->getType()->getAsCXXRecordDecl());\n}\n\nuint32_t\nTypeSystemClang::GetNumBaseClasses(const CXXRecordDecl *cxx_record_decl,\n                                   bool omit_empty_base_classes) {\n  uint32_t num_bases = 0;\n  if (cxx_record_decl) {\n    if (omit_empty_base_classes) {\n      CXXRecordDecl::base_class_const_iterator base_class, base_class_end;\n      for (base_class = cxx_record_decl->bases_begin(),\n          base_class_end = cxx_record_decl->bases_end();\n           base_class != base_class_end; ++base_class) {\n        // Skip empty base classes\n        if (BaseSpecifierIsEmpty(base_class))\n          continue;\n        ++num_bases;\n      }\n    } else\n      num_bases = cxx_record_decl->getNumBases();\n  }\n  return num_bases;\n}\n\n#pragma mark Namespace Declarations\n\nNamespaceDecl *TypeSystemClang::GetUniqueNamespaceDeclaration(\n    const char *name, clang::DeclContext *decl_ctx,\n    OptionalClangModuleID owning_module, bool is_inline) {\n  NamespaceDecl *namespace_decl = nullptr;\n  ASTContext &ast = getASTContext();\n  TranslationUnitDecl *translation_unit_decl = ast.getTranslationUnitDecl();\n  if (!decl_ctx)\n    decl_ctx = translation_unit_decl;\n\n  if (name) {\n    IdentifierInfo &identifier_info = ast.Idents.get(name);\n    DeclarationName decl_name(&identifier_info);\n    clang::DeclContext::lookup_result result = decl_ctx->lookup(decl_name);\n    for (NamedDecl *decl : result) {\n      namespace_decl = dyn_cast<clang::NamespaceDecl>(decl);\n      if (namespace_decl)\n        return namespace_decl;\n    }\n\n    namespace_decl =\n        NamespaceDecl::Create(ast, decl_ctx, is_inline, SourceLocation(),\n                              SourceLocation(), &identifier_info, nullptr);\n\n    decl_ctx->addDecl(namespace_decl);\n  } else {\n    if (decl_ctx == translation_unit_decl) {\n      namespace_decl = translation_unit_decl->getAnonymousNamespace();\n      if (namespace_decl)\n        return namespace_decl;\n\n      namespace_decl =\n          NamespaceDecl::Create(ast, decl_ctx, false, SourceLocation(),\n                                SourceLocation(), nullptr, nullptr);\n      translation_unit_decl->setAnonymousNamespace(namespace_decl);\n      translation_unit_decl->addDecl(namespace_decl);\n      assert(namespace_decl == translation_unit_decl->getAnonymousNamespace());\n    } else {\n      NamespaceDecl *parent_namespace_decl = cast<NamespaceDecl>(decl_ctx);\n      if (parent_namespace_decl) {\n        namespace_decl = parent_namespace_decl->getAnonymousNamespace();\n        if (namespace_decl)\n          return namespace_decl;\n        namespace_decl =\n            NamespaceDecl::Create(ast, decl_ctx, false, SourceLocation(),\n                                  SourceLocation(), nullptr, nullptr);\n        parent_namespace_decl->setAnonymousNamespace(namespace_decl);\n        parent_namespace_decl->addDecl(namespace_decl);\n        assert(namespace_decl ==\n               parent_namespace_decl->getAnonymousNamespace());\n      } else {\n        assert(false && \"GetUniqueNamespaceDeclaration called with no name and \"\n                        \"no namespace as decl_ctx\");\n      }\n    }\n  }\n  // Note: namespaces can span multiple modules, so perhaps this isn't a good\n  // idea.\n  SetOwningModule(namespace_decl, owning_module);\n\n  VerifyDecl(namespace_decl);\n  return namespace_decl;\n}\n\nclang::BlockDecl *\nTypeSystemClang::CreateBlockDeclaration(clang::DeclContext *ctx,\n                                        OptionalClangModuleID owning_module) {\n  if (ctx) {\n    clang::BlockDecl *decl =\n        clang::BlockDecl::CreateDeserialized(getASTContext(), 0);\n    decl->setDeclContext(ctx);\n    ctx->addDecl(decl);\n    SetOwningModule(decl, owning_module);\n    return decl;\n  }\n  return nullptr;\n}\n\nclang::DeclContext *FindLCABetweenDecls(clang::DeclContext *left,\n                                        clang::DeclContext *right,\n                                        clang::DeclContext *root) {\n  if (root == nullptr)\n    return nullptr;\n\n  std::set<clang::DeclContext *> path_left;\n  for (clang::DeclContext *d = left; d != nullptr; d = d->getParent())\n    path_left.insert(d);\n\n  for (clang::DeclContext *d = right; d != nullptr; d = d->getParent())\n    if (path_left.find(d) != path_left.end())\n      return d;\n\n  return nullptr;\n}\n\nclang::UsingDirectiveDecl *TypeSystemClang::CreateUsingDirectiveDeclaration(\n    clang::DeclContext *decl_ctx, OptionalClangModuleID owning_module,\n    clang::NamespaceDecl *ns_decl) {\n  if (decl_ctx && ns_decl) {\n    auto *translation_unit = getASTContext().getTranslationUnitDecl();\n    clang::UsingDirectiveDecl *using_decl = clang::UsingDirectiveDecl::Create(\n          getASTContext(), decl_ctx, clang::SourceLocation(),\n          clang::SourceLocation(), clang::NestedNameSpecifierLoc(),\n          clang::SourceLocation(), ns_decl,\n          FindLCABetweenDecls(decl_ctx, ns_decl,\n                              translation_unit));\n      decl_ctx->addDecl(using_decl);\n      SetOwningModule(using_decl, owning_module);\n      return using_decl;\n  }\n  return nullptr;\n}\n\nclang::UsingDecl *\nTypeSystemClang::CreateUsingDeclaration(clang::DeclContext *current_decl_ctx,\n                                        OptionalClangModuleID owning_module,\n                                        clang::NamedDecl *target) {\n  if (current_decl_ctx && target) {\n    clang::UsingDecl *using_decl = clang::UsingDecl::Create(\n        getASTContext(), current_decl_ctx, clang::SourceLocation(),\n        clang::NestedNameSpecifierLoc(), clang::DeclarationNameInfo(), false);\n    SetOwningModule(using_decl, owning_module);\n    clang::UsingShadowDecl *shadow_decl = clang::UsingShadowDecl::Create(\n        getASTContext(), current_decl_ctx, clang::SourceLocation(), using_decl,\n        target);\n    SetOwningModule(shadow_decl, owning_module);\n    using_decl->addShadowDecl(shadow_decl);\n    current_decl_ctx->addDecl(using_decl);\n    return using_decl;\n  }\n  return nullptr;\n}\n\nclang::VarDecl *TypeSystemClang::CreateVariableDeclaration(\n    clang::DeclContext *decl_context, OptionalClangModuleID owning_module,\n    const char *name, clang::QualType type) {\n  if (decl_context) {\n    clang::VarDecl *var_decl =\n        clang::VarDecl::CreateDeserialized(getASTContext(), 0);\n    var_decl->setDeclContext(decl_context);\n    if (name && name[0])\n      var_decl->setDeclName(&getASTContext().Idents.getOwn(name));\n    var_decl->setType(type);\n    SetOwningModule(var_decl, owning_module);\n    var_decl->setAccess(clang::AS_public);\n    decl_context->addDecl(var_decl);\n    return var_decl;\n  }\n  return nullptr;\n}\n\nlldb::opaque_compiler_type_t\nTypeSystemClang::GetOpaqueCompilerType(clang::ASTContext *ast,\n                                       lldb::BasicType basic_type) {\n  switch (basic_type) {\n  case eBasicTypeVoid:\n    return ast->VoidTy.getAsOpaquePtr();\n  case eBasicTypeChar:\n    return ast->CharTy.getAsOpaquePtr();\n  case eBasicTypeSignedChar:\n    return ast->SignedCharTy.getAsOpaquePtr();\n  case eBasicTypeUnsignedChar:\n    return ast->UnsignedCharTy.getAsOpaquePtr();\n  case eBasicTypeWChar:\n    return ast->getWCharType().getAsOpaquePtr();\n  case eBasicTypeSignedWChar:\n    return ast->getSignedWCharType().getAsOpaquePtr();\n  case eBasicTypeUnsignedWChar:\n    return ast->getUnsignedWCharType().getAsOpaquePtr();\n  case eBasicTypeChar16:\n    return ast->Char16Ty.getAsOpaquePtr();\n  case eBasicTypeChar32:\n    return ast->Char32Ty.getAsOpaquePtr();\n  case eBasicTypeShort:\n    return ast->ShortTy.getAsOpaquePtr();\n  case eBasicTypeUnsignedShort:\n    return ast->UnsignedShortTy.getAsOpaquePtr();\n  case eBasicTypeInt:\n    return ast->IntTy.getAsOpaquePtr();\n  case eBasicTypeUnsignedInt:\n    return ast->UnsignedIntTy.getAsOpaquePtr();\n  case eBasicTypeLong:\n    return ast->LongTy.getAsOpaquePtr();\n  case eBasicTypeUnsignedLong:\n    return ast->UnsignedLongTy.getAsOpaquePtr();\n  case eBasicTypeLongLong:\n    return ast->LongLongTy.getAsOpaquePtr();\n  case eBasicTypeUnsignedLongLong:\n    return ast->UnsignedLongLongTy.getAsOpaquePtr();\n  case eBasicTypeInt128:\n    return ast->Int128Ty.getAsOpaquePtr();\n  case eBasicTypeUnsignedInt128:\n    return ast->UnsignedInt128Ty.getAsOpaquePtr();\n  case eBasicTypeBool:\n    return ast->BoolTy.getAsOpaquePtr();\n  case eBasicTypeHalf:\n    return ast->HalfTy.getAsOpaquePtr();\n  case eBasicTypeFloat:\n    return ast->FloatTy.getAsOpaquePtr();\n  case eBasicTypeDouble:\n    return ast->DoubleTy.getAsOpaquePtr();\n  case eBasicTypeLongDouble:\n    return ast->LongDoubleTy.getAsOpaquePtr();\n  case eBasicTypeFloatComplex:\n    return ast->FloatComplexTy.getAsOpaquePtr();\n  case eBasicTypeDoubleComplex:\n    return ast->DoubleComplexTy.getAsOpaquePtr();\n  case eBasicTypeLongDoubleComplex:\n    return ast->LongDoubleComplexTy.getAsOpaquePtr();\n  case eBasicTypeObjCID:\n    return ast->getObjCIdType().getAsOpaquePtr();\n  case eBasicTypeObjCClass:\n    return ast->getObjCClassType().getAsOpaquePtr();\n  case eBasicTypeObjCSel:\n    return ast->getObjCSelType().getAsOpaquePtr();\n  case eBasicTypeNullPtr:\n    return ast->NullPtrTy.getAsOpaquePtr();\n  default:\n    return nullptr;\n  }\n}\n\n#pragma mark Function Types\n\nclang::DeclarationName\nTypeSystemClang::GetDeclarationName(llvm::StringRef name,\n                                    const CompilerType &function_clang_type) {\n  clang::OverloadedOperatorKind op_kind = clang::NUM_OVERLOADED_OPERATORS;\n  if (!IsOperator(name, op_kind) || op_kind == clang::NUM_OVERLOADED_OPERATORS)\n    return DeclarationName(&getASTContext().Idents.get(\n        name)); // Not operator, but a regular function.\n\n  // Check the number of operator parameters. Sometimes we have seen bad DWARF\n  // that doesn't correctly describe operators and if we try to create a method\n  // and add it to the class, clang will assert and crash, so we need to make\n  // sure things are acceptable.\n  clang::QualType method_qual_type(ClangUtil::GetQualType(function_clang_type));\n  const clang::FunctionProtoType *function_type =\n      llvm::dyn_cast<clang::FunctionProtoType>(method_qual_type.getTypePtr());\n  if (function_type == nullptr)\n    return clang::DeclarationName();\n\n  const bool is_method = false;\n  const unsigned int num_params = function_type->getNumParams();\n  if (!TypeSystemClang::CheckOverloadedOperatorKindParameterCount(\n          is_method, op_kind, num_params))\n    return clang::DeclarationName();\n\n  return getASTContext().DeclarationNames.getCXXOperatorName(op_kind);\n}\n\nPrintingPolicy TypeSystemClang::GetTypePrintingPolicy() {\n  clang::PrintingPolicy printing_policy(getASTContext().getPrintingPolicy());\n  printing_policy.SuppressTagKeyword = true;\n  // Inline namespaces are important for some type formatters (e.g., libc++\n  // and libstdc++ are differentiated by their inline namespaces).\n  printing_policy.SuppressInlineNamespace = false;\n  printing_policy.SuppressUnwrittenScope = false;\n  // Default arguments are also always important for type formatters. Otherwise\n  // we would need to always specify two type names for the setups where we do\n  // know the default arguments and where we don't know default arguments.\n  //\n  // For example, without this we would need to have formatters for both:\n  //   std::basic_string<char>\n  // and\n  //   std::basic_string<char, std::char_traits<char>, std::allocator<char> >\n  // to support setups where LLDB was able to reconstruct default arguments\n  // (and we then would have suppressed them from the type name) and also setups\n  // where LLDB wasn't able to reconstruct the default arguments.\n  printing_policy.SuppressDefaultTemplateArgs = false;\n  return printing_policy;\n}\n\nstd::string TypeSystemClang::GetTypeNameForDecl(const NamedDecl *named_decl) {\n  clang::PrintingPolicy printing_policy = GetTypePrintingPolicy();\n  std::string result;\n  llvm::raw_string_ostream os(result);\n  named_decl->printQualifiedName(os, printing_policy);\n  return result;\n}\n\nFunctionDecl *TypeSystemClang::CreateFunctionDeclaration(\n    clang::DeclContext *decl_ctx, OptionalClangModuleID owning_module,\n    llvm::StringRef name, const CompilerType &function_clang_type,\n    clang::StorageClass storage, bool is_inline) {\n  FunctionDecl *func_decl = nullptr;\n  ASTContext &ast = getASTContext();\n  if (!decl_ctx)\n    decl_ctx = ast.getTranslationUnitDecl();\n\n  const bool hasWrittenPrototype = true;\n  const bool isConstexprSpecified = false;\n\n  clang::DeclarationName declarationName =\n      GetDeclarationName(name, function_clang_type);\n  func_decl = FunctionDecl::CreateDeserialized(ast, 0);\n  func_decl->setDeclContext(decl_ctx);\n  func_decl->setDeclName(declarationName);\n  func_decl->setType(ClangUtil::GetQualType(function_clang_type));\n  func_decl->setStorageClass(storage);\n  func_decl->setInlineSpecified(is_inline);\n  func_decl->setHasWrittenPrototype(hasWrittenPrototype);\n  func_decl->setConstexprKind(isConstexprSpecified\n                                  ? ConstexprSpecKind::Constexpr\n                                  : ConstexprSpecKind::Unspecified);\n  SetOwningModule(func_decl, owning_module);\n  if (func_decl)\n    decl_ctx->addDecl(func_decl);\n\n  VerifyDecl(func_decl);\n\n  return func_decl;\n}\n\nCompilerType\nTypeSystemClang::CreateFunctionType(const CompilerType &result_type,\n                                    const CompilerType *args, unsigned num_args,\n                                    bool is_variadic, unsigned type_quals,\n                                    clang::CallingConv cc) {\n  if (!result_type || !ClangUtil::IsClangType(result_type))\n    return CompilerType(); // invalid return type\n\n  std::vector<QualType> qual_type_args;\n  if (num_args > 0 && args == nullptr)\n    return CompilerType(); // invalid argument array passed in\n\n  // Verify that all arguments are valid and the right type\n  for (unsigned i = 0; i < num_args; ++i) {\n    if (args[i]) {\n      // Make sure we have a clang type in args[i] and not a type from another\n      // language whose name might match\n      const bool is_clang_type = ClangUtil::IsClangType(args[i]);\n      lldbassert(is_clang_type);\n      if (is_clang_type)\n        qual_type_args.push_back(ClangUtil::GetQualType(args[i]));\n      else\n        return CompilerType(); //  invalid argument type (must be a clang type)\n    } else\n      return CompilerType(); // invalid argument type (empty)\n  }\n\n  // TODO: Detect calling convention in DWARF?\n  FunctionProtoType::ExtProtoInfo proto_info;\n  proto_info.ExtInfo = cc;\n  proto_info.Variadic = is_variadic;\n  proto_info.ExceptionSpec = EST_None;\n  proto_info.TypeQuals = clang::Qualifiers::fromFastMask(type_quals);\n  proto_info.RefQualifier = RQ_None;\n\n  return GetType(getASTContext().getFunctionType(\n      ClangUtil::GetQualType(result_type), qual_type_args, proto_info));\n}\n\nParmVarDecl *TypeSystemClang::CreateParameterDeclaration(\n    clang::DeclContext *decl_ctx, OptionalClangModuleID owning_module,\n    const char *name, const CompilerType &param_type, int storage,\n    bool add_decl) {\n  ASTContext &ast = getASTContext();\n  auto *decl = ParmVarDecl::CreateDeserialized(ast, 0);\n  decl->setDeclContext(decl_ctx);\n  if (name && name[0])\n    decl->setDeclName(&ast.Idents.get(name));\n  decl->setType(ClangUtil::GetQualType(param_type));\n  decl->setStorageClass(static_cast<clang::StorageClass>(storage));\n  SetOwningModule(decl, owning_module);\n  if (add_decl)\n    decl_ctx->addDecl(decl);\n\n  return decl;\n}\n\nvoid TypeSystemClang::SetFunctionParameters(FunctionDecl *function_decl,\n                                            ParmVarDecl **params,\n                                            unsigned num_params) {\n  if (function_decl)\n    function_decl->setParams(ArrayRef<ParmVarDecl *>(params, num_params));\n}\n\nCompilerType\nTypeSystemClang::CreateBlockPointerType(const CompilerType &function_type) {\n  QualType block_type = m_ast_up->getBlockPointerType(\n      clang::QualType::getFromOpaquePtr(function_type.GetOpaqueQualType()));\n\n  return GetType(block_type);\n}\n\n#pragma mark Array Types\n\nCompilerType TypeSystemClang::CreateArrayType(const CompilerType &element_type,\n                                              size_t element_count,\n                                              bool is_vector) {\n  if (element_type.IsValid()) {\n    ASTContext &ast = getASTContext();\n\n    if (is_vector) {\n      return GetType(ast.getExtVectorType(ClangUtil::GetQualType(element_type),\n                                          element_count));\n    } else {\n\n      llvm::APInt ap_element_count(64, element_count);\n      if (element_count == 0) {\n        return GetType(ast.getIncompleteArrayType(\n            ClangUtil::GetQualType(element_type), clang::ArrayType::Normal, 0));\n      } else {\n        return GetType(ast.getConstantArrayType(\n            ClangUtil::GetQualType(element_type), ap_element_count, nullptr,\n            clang::ArrayType::Normal, 0));\n      }\n    }\n  }\n  return CompilerType();\n}\n\nCompilerType TypeSystemClang::CreateStructForIdentifier(\n    ConstString type_name,\n    const std::initializer_list<std::pair<const char *, CompilerType>>\n        &type_fields,\n    bool packed) {\n  CompilerType type;\n  if (!type_name.IsEmpty() &&\n      (type = GetTypeForIdentifier<clang::CXXRecordDecl>(type_name))\n          .IsValid()) {\n    lldbassert(0 && \"Trying to create a type for an existing name\");\n    return type;\n  }\n\n  type = CreateRecordType(nullptr, OptionalClangModuleID(), lldb::eAccessPublic,\n                          type_name.GetCString(), clang::TTK_Struct,\n                          lldb::eLanguageTypeC);\n  StartTagDeclarationDefinition(type);\n  for (const auto &field : type_fields)\n    AddFieldToRecordType(type, field.first, field.second, lldb::eAccessPublic,\n                         0);\n  if (packed)\n    SetIsPacked(type);\n  CompleteTagDeclarationDefinition(type);\n  return type;\n}\n\nCompilerType TypeSystemClang::GetOrCreateStructForIdentifier(\n    ConstString type_name,\n    const std::initializer_list<std::pair<const char *, CompilerType>>\n        &type_fields,\n    bool packed) {\n  CompilerType type;\n  if ((type = GetTypeForIdentifier<clang::CXXRecordDecl>(type_name)).IsValid())\n    return type;\n\n  return CreateStructForIdentifier(type_name, type_fields, packed);\n}\n\n#pragma mark Enumeration Types\n\nCompilerType TypeSystemClang::CreateEnumerationType(\n    const char *name, clang::DeclContext *decl_ctx,\n    OptionalClangModuleID owning_module, const Declaration &decl,\n    const CompilerType &integer_clang_type, bool is_scoped) {\n  // TODO: Do something intelligent with the Declaration object passed in\n  // like maybe filling in the SourceLocation with it...\n  ASTContext &ast = getASTContext();\n\n  // TODO: ask about these...\n  //    const bool IsFixed = false;\n  EnumDecl *enum_decl = EnumDecl::CreateDeserialized(ast, 0);\n  enum_decl->setDeclContext(decl_ctx);\n  if (name && name[0])\n    enum_decl->setDeclName(&ast.Idents.get(name));\n  enum_decl->setScoped(is_scoped);\n  enum_decl->setScopedUsingClassTag(is_scoped);\n  enum_decl->setFixed(false);\n  SetOwningModule(enum_decl, owning_module);\n  if (enum_decl) {\n    if (decl_ctx)\n      decl_ctx->addDecl(enum_decl);\n\n    // TODO: check if we should be setting the promotion type too?\n    enum_decl->setIntegerType(ClangUtil::GetQualType(integer_clang_type));\n\n    enum_decl->setAccess(AS_public); // TODO respect what's in the debug info\n\n    return GetType(ast.getTagDeclType(enum_decl));\n  }\n  return CompilerType();\n}\n\nCompilerType TypeSystemClang::GetIntTypeFromBitSize(size_t bit_size,\n                                                    bool is_signed) {\n  clang::ASTContext &ast = getASTContext();\n\n  if (is_signed) {\n    if (bit_size == ast.getTypeSize(ast.SignedCharTy))\n      return GetType(ast.SignedCharTy);\n\n    if (bit_size == ast.getTypeSize(ast.ShortTy))\n      return GetType(ast.ShortTy);\n\n    if (bit_size == ast.getTypeSize(ast.IntTy))\n      return GetType(ast.IntTy);\n\n    if (bit_size == ast.getTypeSize(ast.LongTy))\n      return GetType(ast.LongTy);\n\n    if (bit_size == ast.getTypeSize(ast.LongLongTy))\n      return GetType(ast.LongLongTy);\n\n    if (bit_size == ast.getTypeSize(ast.Int128Ty))\n      return GetType(ast.Int128Ty);\n  } else {\n    if (bit_size == ast.getTypeSize(ast.UnsignedCharTy))\n      return GetType(ast.UnsignedCharTy);\n\n    if (bit_size == ast.getTypeSize(ast.UnsignedShortTy))\n      return GetType(ast.UnsignedShortTy);\n\n    if (bit_size == ast.getTypeSize(ast.UnsignedIntTy))\n      return GetType(ast.UnsignedIntTy);\n\n    if (bit_size == ast.getTypeSize(ast.UnsignedLongTy))\n      return GetType(ast.UnsignedLongTy);\n\n    if (bit_size == ast.getTypeSize(ast.UnsignedLongLongTy))\n      return GetType(ast.UnsignedLongLongTy);\n\n    if (bit_size == ast.getTypeSize(ast.UnsignedInt128Ty))\n      return GetType(ast.UnsignedInt128Ty);\n  }\n  return CompilerType();\n}\n\nCompilerType TypeSystemClang::GetPointerSizedIntType(bool is_signed) {\n  return GetIntTypeFromBitSize(\n      getASTContext().getTypeSize(getASTContext().VoidPtrTy), is_signed);\n}\n\nvoid TypeSystemClang::DumpDeclContextHiearchy(clang::DeclContext *decl_ctx) {\n  if (decl_ctx) {\n    DumpDeclContextHiearchy(decl_ctx->getParent());\n\n    clang::NamedDecl *named_decl = llvm::dyn_cast<clang::NamedDecl>(decl_ctx);\n    if (named_decl) {\n      printf(\"%20s: %s\\n\", decl_ctx->getDeclKindName(),\n             named_decl->getDeclName().getAsString().c_str());\n    } else {\n      printf(\"%20s\\n\", decl_ctx->getDeclKindName());\n    }\n  }\n}\n\nvoid TypeSystemClang::DumpDeclHiearchy(clang::Decl *decl) {\n  if (decl == nullptr)\n    return;\n  DumpDeclContextHiearchy(decl->getDeclContext());\n\n  clang::RecordDecl *record_decl = llvm::dyn_cast<clang::RecordDecl>(decl);\n  if (record_decl) {\n    printf(\"%20s: %s%s\\n\", decl->getDeclKindName(),\n           record_decl->getDeclName().getAsString().c_str(),\n           record_decl->isInjectedClassName() ? \" (injected class name)\" : \"\");\n\n  } else {\n    clang::NamedDecl *named_decl = llvm::dyn_cast<clang::NamedDecl>(decl);\n    if (named_decl) {\n      printf(\"%20s: %s\\n\", decl->getDeclKindName(),\n             named_decl->getDeclName().getAsString().c_str());\n    } else {\n      printf(\"%20s\\n\", decl->getDeclKindName());\n    }\n  }\n}\n\nbool TypeSystemClang::DeclsAreEquivalent(clang::Decl *lhs_decl,\n                                         clang::Decl *rhs_decl) {\n  if (lhs_decl && rhs_decl) {\n    // Make sure the decl kinds match first\n    const clang::Decl::Kind lhs_decl_kind = lhs_decl->getKind();\n    const clang::Decl::Kind rhs_decl_kind = rhs_decl->getKind();\n\n    if (lhs_decl_kind == rhs_decl_kind) {\n      // Now check that the decl contexts kinds are all equivalent before we\n      // have to check any names of the decl contexts...\n      clang::DeclContext *lhs_decl_ctx = lhs_decl->getDeclContext();\n      clang::DeclContext *rhs_decl_ctx = rhs_decl->getDeclContext();\n      if (lhs_decl_ctx && rhs_decl_ctx) {\n        while (true) {\n          if (lhs_decl_ctx && rhs_decl_ctx) {\n            const clang::Decl::Kind lhs_decl_ctx_kind =\n                lhs_decl_ctx->getDeclKind();\n            const clang::Decl::Kind rhs_decl_ctx_kind =\n                rhs_decl_ctx->getDeclKind();\n            if (lhs_decl_ctx_kind == rhs_decl_ctx_kind) {\n              lhs_decl_ctx = lhs_decl_ctx->getParent();\n              rhs_decl_ctx = rhs_decl_ctx->getParent();\n\n              if (lhs_decl_ctx == nullptr && rhs_decl_ctx == nullptr)\n                break;\n            } else\n              return false;\n          } else\n            return false;\n        }\n\n        // Now make sure the name of the decls match\n        clang::NamedDecl *lhs_named_decl =\n            llvm::dyn_cast<clang::NamedDecl>(lhs_decl);\n        clang::NamedDecl *rhs_named_decl =\n            llvm::dyn_cast<clang::NamedDecl>(rhs_decl);\n        if (lhs_named_decl && rhs_named_decl) {\n          clang::DeclarationName lhs_decl_name = lhs_named_decl->getDeclName();\n          clang::DeclarationName rhs_decl_name = rhs_named_decl->getDeclName();\n          if (lhs_decl_name.getNameKind() == rhs_decl_name.getNameKind()) {\n            if (lhs_decl_name.getAsString() != rhs_decl_name.getAsString())\n              return false;\n          } else\n            return false;\n        } else\n          return false;\n\n        // We know that the decl context kinds all match, so now we need to\n        // make sure the names match as well\n        lhs_decl_ctx = lhs_decl->getDeclContext();\n        rhs_decl_ctx = rhs_decl->getDeclContext();\n        while (true) {\n          switch (lhs_decl_ctx->getDeclKind()) {\n          case clang::Decl::TranslationUnit:\n            // We don't care about the translation unit names\n            return true;\n          default: {\n            clang::NamedDecl *lhs_named_decl =\n                llvm::dyn_cast<clang::NamedDecl>(lhs_decl_ctx);\n            clang::NamedDecl *rhs_named_decl =\n                llvm::dyn_cast<clang::NamedDecl>(rhs_decl_ctx);\n            if (lhs_named_decl && rhs_named_decl) {\n              clang::DeclarationName lhs_decl_name =\n                  lhs_named_decl->getDeclName();\n              clang::DeclarationName rhs_decl_name =\n                  rhs_named_decl->getDeclName();\n              if (lhs_decl_name.getNameKind() == rhs_decl_name.getNameKind()) {\n                if (lhs_decl_name.getAsString() != rhs_decl_name.getAsString())\n                  return false;\n              } else\n                return false;\n            } else\n              return false;\n          } break;\n          }\n          lhs_decl_ctx = lhs_decl_ctx->getParent();\n          rhs_decl_ctx = rhs_decl_ctx->getParent();\n        }\n      }\n    }\n  }\n  return false;\n}\nbool TypeSystemClang::GetCompleteDecl(clang::ASTContext *ast,\n                                      clang::Decl *decl) {\n  if (!decl)\n    return false;\n\n  ExternalASTSource *ast_source = ast->getExternalSource();\n\n  if (!ast_source)\n    return false;\n\n  if (clang::TagDecl *tag_decl = llvm::dyn_cast<clang::TagDecl>(decl)) {\n    if (tag_decl->isCompleteDefinition())\n      return true;\n\n    if (!tag_decl->hasExternalLexicalStorage())\n      return false;\n\n    ast_source->CompleteType(tag_decl);\n\n    return !tag_decl->getTypeForDecl()->isIncompleteType();\n  } else if (clang::ObjCInterfaceDecl *objc_interface_decl =\n                 llvm::dyn_cast<clang::ObjCInterfaceDecl>(decl)) {\n    if (objc_interface_decl->getDefinition())\n      return true;\n\n    if (!objc_interface_decl->hasExternalLexicalStorage())\n      return false;\n\n    ast_source->CompleteType(objc_interface_decl);\n\n    return !objc_interface_decl->getTypeForDecl()->isIncompleteType();\n  } else {\n    return false;\n  }\n}\n\nvoid TypeSystemClang::SetMetadataAsUserID(const clang::Decl *decl,\n                                          user_id_t user_id) {\n  ClangASTMetadata meta_data;\n  meta_data.SetUserID(user_id);\n  SetMetadata(decl, meta_data);\n}\n\nvoid TypeSystemClang::SetMetadataAsUserID(const clang::Type *type,\n                                          user_id_t user_id) {\n  ClangASTMetadata meta_data;\n  meta_data.SetUserID(user_id);\n  SetMetadata(type, meta_data);\n}\n\nvoid TypeSystemClang::SetMetadata(const clang::Decl *object,\n                                  ClangASTMetadata &metadata) {\n  m_decl_metadata[object] = metadata;\n}\n\nvoid TypeSystemClang::SetMetadata(const clang::Type *object,\n                                  ClangASTMetadata &metadata) {\n  m_type_metadata[object] = metadata;\n}\n\nClangASTMetadata *TypeSystemClang::GetMetadata(const clang::Decl *object) {\n  auto It = m_decl_metadata.find(object);\n  if (It != m_decl_metadata.end())\n    return &It->second;\n  return nullptr;\n}\n\nClangASTMetadata *TypeSystemClang::GetMetadata(const clang::Type *object) {\n  auto It = m_type_metadata.find(object);\n  if (It != m_type_metadata.end())\n    return &It->second;\n  return nullptr;\n}\n\nbool TypeSystemClang::SetTagTypeKind(clang::QualType tag_qual_type,\n                                     int kind) const {\n  const clang::Type *clang_type = tag_qual_type.getTypePtr();\n  if (clang_type) {\n    const clang::TagType *tag_type = llvm::dyn_cast<clang::TagType>(clang_type);\n    if (tag_type) {\n      clang::TagDecl *tag_decl =\n          llvm::dyn_cast<clang::TagDecl>(tag_type->getDecl());\n      if (tag_decl) {\n        tag_decl->setTagKind((clang::TagDecl::TagKind)kind);\n        return true;\n      }\n    }\n  }\n  return false;\n}\n\nbool TypeSystemClang::SetDefaultAccessForRecordFields(\n    clang::RecordDecl *record_decl, int default_accessibility,\n    int *assigned_accessibilities, size_t num_assigned_accessibilities) {\n  if (record_decl) {\n    uint32_t field_idx;\n    clang::RecordDecl::field_iterator field, field_end;\n    for (field = record_decl->field_begin(),\n        field_end = record_decl->field_end(), field_idx = 0;\n         field != field_end; ++field, ++field_idx) {\n      // If no accessibility was assigned, assign the correct one\n      if (field_idx < num_assigned_accessibilities &&\n          assigned_accessibilities[field_idx] == clang::AS_none)\n        field->setAccess((clang::AccessSpecifier)default_accessibility);\n    }\n    return true;\n  }\n  return false;\n}\n\nclang::DeclContext *\nTypeSystemClang::GetDeclContextForType(const CompilerType &type) {\n  return GetDeclContextForType(ClangUtil::GetQualType(type));\n}\n\n/// Aggressively desugar the provided type, skipping past various kinds of\n/// syntactic sugar and other constructs one typically wants to ignore.\n/// The \\p mask argument allows one to skip certain kinds of simplifications,\n/// when one wishes to handle a certain kind of type directly.\nstatic QualType\nRemoveWrappingTypes(QualType type, ArrayRef<clang::Type::TypeClass> mask = {}) {\n  while (true) {\n    if (find(mask, type->getTypeClass()) != mask.end())\n      return type;\n    switch (type->getTypeClass()) {\n    // This is not fully correct as _Atomic is more than sugar, but it is\n    // sufficient for the purposes we care about.\n    case clang::Type::Atomic:\n      type = cast<clang::AtomicType>(type)->getValueType();\n      break;\n    case clang::Type::Auto:\n    case clang::Type::Decltype:\n    case clang::Type::Elaborated:\n    case clang::Type::Paren:\n    case clang::Type::SubstTemplateTypeParm:\n    case clang::Type::TemplateSpecialization:\n    case clang::Type::Typedef:\n    case clang::Type::TypeOf:\n    case clang::Type::TypeOfExpr:\n      type = type->getLocallyUnqualifiedSingleStepDesugaredType();\n      break;\n    default:\n      return type;\n    }\n  }\n}\n\nclang::DeclContext *\nTypeSystemClang::GetDeclContextForType(clang::QualType type) {\n  if (type.isNull())\n    return nullptr;\n\n  clang::QualType qual_type = RemoveWrappingTypes(type.getCanonicalType());\n  const clang::Type::TypeClass type_class = qual_type->getTypeClass();\n  switch (type_class) {\n  case clang::Type::ObjCInterface:\n    return llvm::cast<clang::ObjCObjectType>(qual_type.getTypePtr())\n        ->getInterface();\n  case clang::Type::ObjCObjectPointer:\n    return GetDeclContextForType(\n        llvm::cast<clang::ObjCObjectPointerType>(qual_type.getTypePtr())\n            ->getPointeeType());\n  case clang::Type::Record:\n    return llvm::cast<clang::RecordType>(qual_type)->getDecl();\n  case clang::Type::Enum:\n    return llvm::cast<clang::EnumType>(qual_type)->getDecl();\n  default:\n    break;\n  }\n  // No DeclContext in this type...\n  return nullptr;\n}\n\nstatic bool GetCompleteQualType(clang::ASTContext *ast,\n                                clang::QualType qual_type,\n                                bool allow_completion = true) {\n  qual_type = RemoveWrappingTypes(qual_type);\n  const clang::Type::TypeClass type_class = qual_type->getTypeClass();\n  switch (type_class) {\n  case clang::Type::ConstantArray:\n  case clang::Type::IncompleteArray:\n  case clang::Type::VariableArray: {\n    const clang::ArrayType *array_type =\n        llvm::dyn_cast<clang::ArrayType>(qual_type.getTypePtr());\n\n    if (array_type)\n      return GetCompleteQualType(ast, array_type->getElementType(),\n                                 allow_completion);\n  } break;\n  case clang::Type::Record: {\n    clang::CXXRecordDecl *cxx_record_decl = qual_type->getAsCXXRecordDecl();\n    if (cxx_record_decl) {\n      if (cxx_record_decl->hasExternalLexicalStorage()) {\n        const bool is_complete = cxx_record_decl->isCompleteDefinition();\n        const bool fields_loaded =\n            cxx_record_decl->hasLoadedFieldsFromExternalStorage();\n        if (is_complete && fields_loaded)\n          return true;\n\n        if (!allow_completion)\n          return false;\n\n        // Call the field_begin() accessor to for it to use the external source\n        // to load the fields...\n        clang::ExternalASTSource *external_ast_source =\n            ast->getExternalSource();\n        if (external_ast_source) {\n          external_ast_source->CompleteType(cxx_record_decl);\n          if (cxx_record_decl->isCompleteDefinition()) {\n            cxx_record_decl->field_begin();\n            cxx_record_decl->setHasLoadedFieldsFromExternalStorage(true);\n          }\n        }\n      }\n    }\n    const clang::TagType *tag_type =\n        llvm::cast<clang::TagType>(qual_type.getTypePtr());\n    return !tag_type->isIncompleteType();\n  } break;\n\n  case clang::Type::Enum: {\n    const clang::TagType *tag_type =\n        llvm::dyn_cast<clang::TagType>(qual_type.getTypePtr());\n    if (tag_type) {\n      clang::TagDecl *tag_decl = tag_type->getDecl();\n      if (tag_decl) {\n        if (tag_decl->getDefinition())\n          return true;\n\n        if (!allow_completion)\n          return false;\n\n        if (tag_decl->hasExternalLexicalStorage()) {\n          if (ast) {\n            clang::ExternalASTSource *external_ast_source =\n                ast->getExternalSource();\n            if (external_ast_source) {\n              external_ast_source->CompleteType(tag_decl);\n              return !tag_type->isIncompleteType();\n            }\n          }\n        }\n        return false;\n      }\n    }\n\n  } break;\n  case clang::Type::ObjCObject:\n  case clang::Type::ObjCInterface: {\n    const clang::ObjCObjectType *objc_class_type =\n        llvm::dyn_cast<clang::ObjCObjectType>(qual_type);\n    if (objc_class_type) {\n      clang::ObjCInterfaceDecl *class_interface_decl =\n          objc_class_type->getInterface();\n      // We currently can't complete objective C types through the newly added\n      // ASTContext because it only supports TagDecl objects right now...\n      if (class_interface_decl) {\n        if (class_interface_decl->getDefinition())\n          return true;\n\n        if (!allow_completion)\n          return false;\n\n        if (class_interface_decl->hasExternalLexicalStorage()) {\n          if (ast) {\n            clang::ExternalASTSource *external_ast_source =\n                ast->getExternalSource();\n            if (external_ast_source) {\n              external_ast_source->CompleteType(class_interface_decl);\n              return !objc_class_type->isIncompleteType();\n            }\n          }\n        }\n        return false;\n      }\n    }\n  } break;\n\n  case clang::Type::Attributed:\n    return GetCompleteQualType(\n        ast, llvm::cast<clang::AttributedType>(qual_type)->getModifiedType(),\n        allow_completion);\n\n  default:\n    break;\n  }\n\n  return true;\n}\n\nstatic clang::ObjCIvarDecl::AccessControl\nConvertAccessTypeToObjCIvarAccessControl(AccessType access) {\n  switch (access) {\n  case eAccessNone:\n    return clang::ObjCIvarDecl::None;\n  case eAccessPublic:\n    return clang::ObjCIvarDecl::Public;\n  case eAccessPrivate:\n    return clang::ObjCIvarDecl::Private;\n  case eAccessProtected:\n    return clang::ObjCIvarDecl::Protected;\n  case eAccessPackage:\n    return clang::ObjCIvarDecl::Package;\n  }\n  return clang::ObjCIvarDecl::None;\n}\n\n// Tests\n\n#ifndef NDEBUG\nbool TypeSystemClang::Verify(lldb::opaque_compiler_type_t type) {\n  return !type || llvm::isa<clang::Type>(GetQualType(type).getTypePtr());\n}\n#endif\n\nbool TypeSystemClang::IsAggregateType(lldb::opaque_compiler_type_t type) {\n  clang::QualType qual_type(RemoveWrappingTypes(GetCanonicalQualType(type)));\n\n  const clang::Type::TypeClass type_class = qual_type->getTypeClass();\n  switch (type_class) {\n  case clang::Type::IncompleteArray:\n  case clang::Type::VariableArray:\n  case clang::Type::ConstantArray:\n  case clang::Type::ExtVector:\n  case clang::Type::Vector:\n  case clang::Type::Record:\n  case clang::Type::ObjCObject:\n  case clang::Type::ObjCInterface:\n    return true;\n  default:\n    break;\n  }\n  // The clang type does have a value\n  return false;\n}\n\nbool TypeSystemClang::IsAnonymousType(lldb::opaque_compiler_type_t type) {\n  clang::QualType qual_type(RemoveWrappingTypes(GetCanonicalQualType(type)));\n\n  const clang::Type::TypeClass type_class = qual_type->getTypeClass();\n  switch (type_class) {\n  case clang::Type::Record: {\n    if (const clang::RecordType *record_type =\n            llvm::dyn_cast_or_null<clang::RecordType>(\n                qual_type.getTypePtrOrNull())) {\n      if (const clang::RecordDecl *record_decl = record_type->getDecl()) {\n        return record_decl->isAnonymousStructOrUnion();\n      }\n    }\n    break;\n  }\n  default:\n    break;\n  }\n  // The clang type does have a value\n  return false;\n}\n\nbool TypeSystemClang::IsArrayType(lldb::opaque_compiler_type_t type,\n                                  CompilerType *element_type_ptr,\n                                  uint64_t *size, bool *is_incomplete) {\n  clang::QualType qual_type(RemoveWrappingTypes(GetCanonicalQualType(type)));\n\n  const clang::Type::TypeClass type_class = qual_type->getTypeClass();\n  switch (type_class) {\n  default:\n    break;\n\n  case clang::Type::ConstantArray:\n    if (element_type_ptr)\n      element_type_ptr->SetCompilerType(\n          this, llvm::cast<clang::ConstantArrayType>(qual_type)\n                    ->getElementType()\n                    .getAsOpaquePtr());\n    if (size)\n      *size = llvm::cast<clang::ConstantArrayType>(qual_type)\n                  ->getSize()\n                  .getLimitedValue(ULLONG_MAX);\n    if (is_incomplete)\n      *is_incomplete = false;\n    return true;\n\n  case clang::Type::IncompleteArray:\n    if (element_type_ptr)\n      element_type_ptr->SetCompilerType(\n          this, llvm::cast<clang::IncompleteArrayType>(qual_type)\n                    ->getElementType()\n                    .getAsOpaquePtr());\n    if (size)\n      *size = 0;\n    if (is_incomplete)\n      *is_incomplete = true;\n    return true;\n\n  case clang::Type::VariableArray:\n    if (element_type_ptr)\n      element_type_ptr->SetCompilerType(\n          this, llvm::cast<clang::VariableArrayType>(qual_type)\n                    ->getElementType()\n                    .getAsOpaquePtr());\n    if (size)\n      *size = 0;\n    if (is_incomplete)\n      *is_incomplete = false;\n    return true;\n\n  case clang::Type::DependentSizedArray:\n    if (element_type_ptr)\n      element_type_ptr->SetCompilerType(\n          this, llvm::cast<clang::DependentSizedArrayType>(qual_type)\n                    ->getElementType()\n                    .getAsOpaquePtr());\n    if (size)\n      *size = 0;\n    if (is_incomplete)\n      *is_incomplete = false;\n    return true;\n  }\n  if (element_type_ptr)\n    element_type_ptr->Clear();\n  if (size)\n    *size = 0;\n  if (is_incomplete)\n    *is_incomplete = false;\n  return false;\n}\n\nbool TypeSystemClang::IsVectorType(lldb::opaque_compiler_type_t type,\n                                   CompilerType *element_type, uint64_t *size) {\n  clang::QualType qual_type(GetCanonicalQualType(type));\n\n  const clang::Type::TypeClass type_class = qual_type->getTypeClass();\n  switch (type_class) {\n  case clang::Type::Vector: {\n    const clang::VectorType *vector_type =\n        qual_type->getAs<clang::VectorType>();\n    if (vector_type) {\n      if (size)\n        *size = vector_type->getNumElements();\n      if (element_type)\n        *element_type = GetType(vector_type->getElementType());\n    }\n    return true;\n  } break;\n  case clang::Type::ExtVector: {\n    const clang::ExtVectorType *ext_vector_type =\n        qual_type->getAs<clang::ExtVectorType>();\n    if (ext_vector_type) {\n      if (size)\n        *size = ext_vector_type->getNumElements();\n      if (element_type)\n        *element_type =\n            CompilerType(this, ext_vector_type->getElementType().getAsOpaquePtr());\n    }\n    return true;\n  }\n  default:\n    break;\n  }\n  return false;\n}\n\nbool TypeSystemClang::IsRuntimeGeneratedType(\n    lldb::opaque_compiler_type_t type) {\n  clang::DeclContext *decl_ctx = GetDeclContextForType(GetQualType(type));\n  if (!decl_ctx)\n    return false;\n\n  if (!llvm::isa<clang::ObjCInterfaceDecl>(decl_ctx))\n    return false;\n\n  clang::ObjCInterfaceDecl *result_iface_decl =\n      llvm::dyn_cast<clang::ObjCInterfaceDecl>(decl_ctx);\n\n  ClangASTMetadata *ast_metadata = GetMetadata(result_iface_decl);\n  if (!ast_metadata)\n    return false;\n  return (ast_metadata->GetISAPtr() != 0);\n}\n\nbool TypeSystemClang::IsCharType(lldb::opaque_compiler_type_t type) {\n  return GetQualType(type).getUnqualifiedType()->isCharType();\n}\n\nbool TypeSystemClang::IsCompleteType(lldb::opaque_compiler_type_t type) {\n  const bool allow_completion = false;\n  return GetCompleteQualType(&getASTContext(), GetQualType(type),\n                             allow_completion);\n}\n\nbool TypeSystemClang::IsConst(lldb::opaque_compiler_type_t type) {\n  return GetQualType(type).isConstQualified();\n}\n\nbool TypeSystemClang::IsCStringType(lldb::opaque_compiler_type_t type,\n                                    uint32_t &length) {\n  CompilerType pointee_or_element_clang_type;\n  length = 0;\n  Flags type_flags(GetTypeInfo(type, &pointee_or_element_clang_type));\n\n  if (!pointee_or_element_clang_type.IsValid())\n    return false;\n\n  if (type_flags.AnySet(eTypeIsArray | eTypeIsPointer)) {\n    if (pointee_or_element_clang_type.IsCharType()) {\n      if (type_flags.Test(eTypeIsArray)) {\n        // We know the size of the array and it could be a C string since it is\n        // an array of characters\n        length = llvm::cast<clang::ConstantArrayType>(\n                     GetCanonicalQualType(type).getTypePtr())\n                     ->getSize()\n                     .getLimitedValue();\n      }\n      return true;\n    }\n  }\n  return false;\n}\n\nbool TypeSystemClang::IsFunctionType(lldb::opaque_compiler_type_t type) {\n  if (type) {\n    clang::QualType qual_type = RemoveWrappingTypes(GetCanonicalQualType(type));\n\n    if (qual_type->isFunctionType()) {\n      return true;\n    }\n\n    const clang::Type::TypeClass type_class = qual_type->getTypeClass();\n    switch (type_class) {\n    default:\n      break;\n    case clang::Type::LValueReference:\n    case clang::Type::RValueReference: {\n      const clang::ReferenceType *reference_type =\n          llvm::cast<clang::ReferenceType>(qual_type.getTypePtr());\n      if (reference_type)\n        return IsFunctionType(\n            reference_type->getPointeeType().getAsOpaquePtr());\n    } break;\n    }\n  }\n  return false;\n}\n\n// Used to detect \"Homogeneous Floating-point Aggregates\"\nuint32_t\nTypeSystemClang::IsHomogeneousAggregate(lldb::opaque_compiler_type_t type,\n                                        CompilerType *base_type_ptr) {\n  if (!type)\n    return 0;\n\n  clang::QualType qual_type(RemoveWrappingTypes(GetCanonicalQualType(type)));\n  const clang::Type::TypeClass type_class = qual_type->getTypeClass();\n  switch (type_class) {\n  case clang::Type::Record:\n    if (GetCompleteType(type)) {\n      const clang::CXXRecordDecl *cxx_record_decl =\n          qual_type->getAsCXXRecordDecl();\n      if (cxx_record_decl) {\n        if (cxx_record_decl->getNumBases() || cxx_record_decl->isDynamicClass())\n          return 0;\n      }\n      const clang::RecordType *record_type =\n          llvm::cast<clang::RecordType>(qual_type.getTypePtr());\n      if (record_type) {\n        const clang::RecordDecl *record_decl = record_type->getDecl();\n        if (record_decl) {\n          // We are looking for a structure that contains only floating point\n          // types\n          clang::RecordDecl::field_iterator field_pos,\n              field_end = record_decl->field_end();\n          uint32_t num_fields = 0;\n          bool is_hva = false;\n          bool is_hfa = false;\n          clang::QualType base_qual_type;\n          uint64_t base_bitwidth = 0;\n          for (field_pos = record_decl->field_begin(); field_pos != field_end;\n               ++field_pos) {\n            clang::QualType field_qual_type = field_pos->getType();\n            uint64_t field_bitwidth = getASTContext().getTypeSize(qual_type);\n            if (field_qual_type->isFloatingType()) {\n              if (field_qual_type->isComplexType())\n                return 0;\n              else {\n                if (num_fields == 0)\n                  base_qual_type = field_qual_type;\n                else {\n                  if (is_hva)\n                    return 0;\n                  is_hfa = true;\n                  if (field_qual_type.getTypePtr() !=\n                      base_qual_type.getTypePtr())\n                    return 0;\n                }\n              }\n            } else if (field_qual_type->isVectorType() ||\n                       field_qual_type->isExtVectorType()) {\n              if (num_fields == 0) {\n                base_qual_type = field_qual_type;\n                base_bitwidth = field_bitwidth;\n              } else {\n                if (is_hfa)\n                  return 0;\n                is_hva = true;\n                if (base_bitwidth != field_bitwidth)\n                  return 0;\n                if (field_qual_type.getTypePtr() != base_qual_type.getTypePtr())\n                  return 0;\n              }\n            } else\n              return 0;\n            ++num_fields;\n          }\n          if (base_type_ptr)\n            *base_type_ptr = CompilerType(this, base_qual_type.getAsOpaquePtr());\n          return num_fields;\n        }\n      }\n    }\n    break;\n\n  default:\n    break;\n  }\n  return 0;\n}\n\nsize_t TypeSystemClang::GetNumberOfFunctionArguments(\n    lldb::opaque_compiler_type_t type) {\n  if (type) {\n    clang::QualType qual_type(GetCanonicalQualType(type));\n    const clang::FunctionProtoType *func =\n        llvm::dyn_cast<clang::FunctionProtoType>(qual_type.getTypePtr());\n    if (func)\n      return func->getNumParams();\n  }\n  return 0;\n}\n\nCompilerType\nTypeSystemClang::GetFunctionArgumentAtIndex(lldb::opaque_compiler_type_t type,\n                                            const size_t index) {\n  if (type) {\n    clang::QualType qual_type(GetQualType(type));\n    const clang::FunctionProtoType *func =\n        llvm::dyn_cast<clang::FunctionProtoType>(qual_type.getTypePtr());\n    if (func) {\n      if (index < func->getNumParams())\n        return CompilerType(this, func->getParamType(index).getAsOpaquePtr());\n    }\n  }\n  return CompilerType();\n}\n\nbool TypeSystemClang::IsFunctionPointerType(lldb::opaque_compiler_type_t type) {\n  if (type) {\n    clang::QualType qual_type = RemoveWrappingTypes(GetCanonicalQualType(type));\n\n    if (qual_type->isFunctionPointerType())\n      return true;\n\n    const clang::Type::TypeClass type_class = qual_type->getTypeClass();\n    switch (type_class) {\n    default:\n      break;\n\n    case clang::Type::LValueReference:\n    case clang::Type::RValueReference: {\n      const clang::ReferenceType *reference_type =\n          llvm::cast<clang::ReferenceType>(qual_type.getTypePtr());\n      if (reference_type)\n        return IsFunctionPointerType(\n            reference_type->getPointeeType().getAsOpaquePtr());\n    } break;\n    }\n  }\n  return false;\n}\n\nbool TypeSystemClang::IsBlockPointerType(\n    lldb::opaque_compiler_type_t type,\n    CompilerType *function_pointer_type_ptr) {\n  if (type) {\n    clang::QualType qual_type = RemoveWrappingTypes(GetCanonicalQualType(type));\n\n    if (qual_type->isBlockPointerType()) {\n      if (function_pointer_type_ptr) {\n        const clang::BlockPointerType *block_pointer_type =\n            qual_type->getAs<clang::BlockPointerType>();\n        QualType pointee_type = block_pointer_type->getPointeeType();\n        QualType function_pointer_type = m_ast_up->getPointerType(pointee_type);\n        *function_pointer_type_ptr =\n            CompilerType(this, function_pointer_type.getAsOpaquePtr());\n      }\n      return true;\n    }\n\n    const clang::Type::TypeClass type_class = qual_type->getTypeClass();\n    switch (type_class) {\n    default:\n      break;\n\n    case clang::Type::LValueReference:\n    case clang::Type::RValueReference: {\n      const clang::ReferenceType *reference_type =\n          llvm::cast<clang::ReferenceType>(qual_type.getTypePtr());\n      if (reference_type)\n        return IsBlockPointerType(\n            reference_type->getPointeeType().getAsOpaquePtr(),\n            function_pointer_type_ptr);\n    } break;\n    }\n  }\n  return false;\n}\n\nbool TypeSystemClang::IsIntegerType(lldb::opaque_compiler_type_t type,\n                                    bool &is_signed) {\n  if (!type)\n    return false;\n\n  clang::QualType qual_type(GetCanonicalQualType(type));\n  const clang::BuiltinType *builtin_type =\n      llvm::dyn_cast<clang::BuiltinType>(qual_type->getCanonicalTypeInternal());\n\n  if (builtin_type) {\n    if (builtin_type->isInteger()) {\n      is_signed = builtin_type->isSignedInteger();\n      return true;\n    }\n  }\n\n  return false;\n}\n\nbool TypeSystemClang::IsEnumerationType(lldb::opaque_compiler_type_t type,\n                                        bool &is_signed) {\n  if (type) {\n    const clang::EnumType *enum_type = llvm::dyn_cast<clang::EnumType>(\n        GetCanonicalQualType(type)->getCanonicalTypeInternal());\n\n    if (enum_type) {\n      IsIntegerType(enum_type->getDecl()->getIntegerType().getAsOpaquePtr(),\n                    is_signed);\n      return true;\n    }\n  }\n\n  return false;\n}\n\nbool TypeSystemClang::IsScopedEnumerationType(\n    lldb::opaque_compiler_type_t type) {\n  if (type) {\n    const clang::EnumType *enum_type = llvm::dyn_cast<clang::EnumType>(\n        GetCanonicalQualType(type)->getCanonicalTypeInternal());\n\n    if (enum_type) {\n      return enum_type->isScopedEnumeralType();\n    }\n  }\n\n  return false;\n}\n\nbool TypeSystemClang::IsPointerType(lldb::opaque_compiler_type_t type,\n                                    CompilerType *pointee_type) {\n  if (type) {\n    clang::QualType qual_type = RemoveWrappingTypes(GetCanonicalQualType(type));\n    const clang::Type::TypeClass type_class = qual_type->getTypeClass();\n    switch (type_class) {\n    case clang::Type::Builtin:\n      switch (llvm::cast<clang::BuiltinType>(qual_type)->getKind()) {\n      default:\n        break;\n      case clang::BuiltinType::ObjCId:\n      case clang::BuiltinType::ObjCClass:\n        return true;\n      }\n      return false;\n    case clang::Type::ObjCObjectPointer:\n      if (pointee_type)\n        pointee_type->SetCompilerType(\n            this, llvm::cast<clang::ObjCObjectPointerType>(qual_type)\n                      ->getPointeeType()\n                      .getAsOpaquePtr());\n      return true;\n    case clang::Type::BlockPointer:\n      if (pointee_type)\n        pointee_type->SetCompilerType(\n            this, llvm::cast<clang::BlockPointerType>(qual_type)\n                      ->getPointeeType()\n                      .getAsOpaquePtr());\n      return true;\n    case clang::Type::Pointer:\n      if (pointee_type)\n        pointee_type->SetCompilerType(this,\n                                      llvm::cast<clang::PointerType>(qual_type)\n                                          ->getPointeeType()\n                                          .getAsOpaquePtr());\n      return true;\n    case clang::Type::MemberPointer:\n      if (pointee_type)\n        pointee_type->SetCompilerType(\n            this, llvm::cast<clang::MemberPointerType>(qual_type)\n                      ->getPointeeType()\n                      .getAsOpaquePtr());\n      return true;\n    default:\n      break;\n    }\n  }\n  if (pointee_type)\n    pointee_type->Clear();\n  return false;\n}\n\nbool TypeSystemClang::IsPointerOrReferenceType(\n    lldb::opaque_compiler_type_t type, CompilerType *pointee_type) {\n  if (type) {\n    clang::QualType qual_type = RemoveWrappingTypes(GetCanonicalQualType(type));\n    const clang::Type::TypeClass type_class = qual_type->getTypeClass();\n    switch (type_class) {\n    case clang::Type::Builtin:\n      switch (llvm::cast<clang::BuiltinType>(qual_type)->getKind()) {\n      default:\n        break;\n      case clang::BuiltinType::ObjCId:\n      case clang::BuiltinType::ObjCClass:\n        return true;\n      }\n      return false;\n    case clang::Type::ObjCObjectPointer:\n      if (pointee_type)\n        pointee_type->SetCompilerType(\n            this, llvm::cast<clang::ObjCObjectPointerType>(qual_type)\n                                 ->getPointeeType().getAsOpaquePtr());\n      return true;\n    case clang::Type::BlockPointer:\n      if (pointee_type)\n        pointee_type->SetCompilerType(\n            this, llvm::cast<clang::BlockPointerType>(qual_type)\n                      ->getPointeeType()\n                      .getAsOpaquePtr());\n      return true;\n    case clang::Type::Pointer:\n      if (pointee_type)\n        pointee_type->SetCompilerType(this,\n                                      llvm::cast<clang::PointerType>(qual_type)\n                                          ->getPointeeType()\n                                          .getAsOpaquePtr());\n      return true;\n    case clang::Type::MemberPointer:\n      if (pointee_type)\n        pointee_type->SetCompilerType(\n            this, llvm::cast<clang::MemberPointerType>(qual_type)\n                      ->getPointeeType()\n                      .getAsOpaquePtr());\n      return true;\n    case clang::Type::LValueReference:\n      if (pointee_type)\n        pointee_type->SetCompilerType(\n            this, llvm::cast<clang::LValueReferenceType>(qual_type)\n                      ->desugar()\n                      .getAsOpaquePtr());\n      return true;\n    case clang::Type::RValueReference:\n      if (pointee_type)\n        pointee_type->SetCompilerType(\n            this, llvm::cast<clang::RValueReferenceType>(qual_type)\n                      ->desugar()\n                      .getAsOpaquePtr());\n      return true;\n    default:\n      break;\n    }\n  }\n  if (pointee_type)\n    pointee_type->Clear();\n  return false;\n}\n\nbool TypeSystemClang::IsReferenceType(lldb::opaque_compiler_type_t type,\n                                      CompilerType *pointee_type,\n                                      bool *is_rvalue) {\n  if (type) {\n    clang::QualType qual_type = RemoveWrappingTypes(GetCanonicalQualType(type));\n    const clang::Type::TypeClass type_class = qual_type->getTypeClass();\n\n    switch (type_class) {\n    case clang::Type::LValueReference:\n      if (pointee_type)\n        pointee_type->SetCompilerType(\n            this, llvm::cast<clang::LValueReferenceType>(qual_type)\n                      ->desugar()\n                      .getAsOpaquePtr());\n      if (is_rvalue)\n        *is_rvalue = false;\n      return true;\n    case clang::Type::RValueReference:\n      if (pointee_type)\n        pointee_type->SetCompilerType(\n            this, llvm::cast<clang::RValueReferenceType>(qual_type)\n                      ->desugar()\n                      .getAsOpaquePtr());\n      if (is_rvalue)\n        *is_rvalue = true;\n      return true;\n\n    default:\n      break;\n    }\n  }\n  if (pointee_type)\n    pointee_type->Clear();\n  return false;\n}\n\nbool TypeSystemClang::IsFloatingPointType(lldb::opaque_compiler_type_t type,\n                                          uint32_t &count, bool &is_complex) {\n  if (type) {\n    clang::QualType qual_type(GetCanonicalQualType(type));\n\n    if (const clang::BuiltinType *BT = llvm::dyn_cast<clang::BuiltinType>(\n            qual_type->getCanonicalTypeInternal())) {\n      clang::BuiltinType::Kind kind = BT->getKind();\n      if (kind >= clang::BuiltinType::Float &&\n          kind <= clang::BuiltinType::LongDouble) {\n        count = 1;\n        is_complex = false;\n        return true;\n      }\n    } else if (const clang::ComplexType *CT =\n                   llvm::dyn_cast<clang::ComplexType>(\n                       qual_type->getCanonicalTypeInternal())) {\n      if (IsFloatingPointType(CT->getElementType().getAsOpaquePtr(), count,\n                              is_complex)) {\n        count = 2;\n        is_complex = true;\n        return true;\n      }\n    } else if (const clang::VectorType *VT = llvm::dyn_cast<clang::VectorType>(\n                   qual_type->getCanonicalTypeInternal())) {\n      if (IsFloatingPointType(VT->getElementType().getAsOpaquePtr(), count,\n                              is_complex)) {\n        count = VT->getNumElements();\n        is_complex = false;\n        return true;\n      }\n    }\n  }\n  count = 0;\n  is_complex = false;\n  return false;\n}\n\nbool TypeSystemClang::IsDefined(lldb::opaque_compiler_type_t type) {\n  if (!type)\n    return false;\n\n  clang::QualType qual_type(GetQualType(type));\n  const clang::TagType *tag_type =\n      llvm::dyn_cast<clang::TagType>(qual_type.getTypePtr());\n  if (tag_type) {\n    clang::TagDecl *tag_decl = tag_type->getDecl();\n    if (tag_decl)\n      return tag_decl->isCompleteDefinition();\n    return false;\n  } else {\n    const clang::ObjCObjectType *objc_class_type =\n        llvm::dyn_cast<clang::ObjCObjectType>(qual_type);\n    if (objc_class_type) {\n      clang::ObjCInterfaceDecl *class_interface_decl =\n          objc_class_type->getInterface();\n      if (class_interface_decl)\n        return class_interface_decl->getDefinition() != nullptr;\n      return false;\n    }\n  }\n  return true;\n}\n\nbool TypeSystemClang::IsObjCClassType(const CompilerType &type) {\n  if (ClangUtil::IsClangType(type)) {\n    clang::QualType qual_type(ClangUtil::GetCanonicalQualType(type));\n\n    const clang::ObjCObjectPointerType *obj_pointer_type =\n        llvm::dyn_cast<clang::ObjCObjectPointerType>(qual_type);\n\n    if (obj_pointer_type)\n      return obj_pointer_type->isObjCClassType();\n  }\n  return false;\n}\n\nbool TypeSystemClang::IsObjCObjectOrInterfaceType(const CompilerType &type) {\n  if (ClangUtil::IsClangType(type))\n    return ClangUtil::GetCanonicalQualType(type)->isObjCObjectOrInterfaceType();\n  return false;\n}\n\nbool TypeSystemClang::IsClassType(lldb::opaque_compiler_type_t type) {\n  if (!type)\n    return false;\n  clang::QualType qual_type(GetCanonicalQualType(type));\n  const clang::Type::TypeClass type_class = qual_type->getTypeClass();\n  return (type_class == clang::Type::Record);\n}\n\nbool TypeSystemClang::IsEnumType(lldb::opaque_compiler_type_t type) {\n  if (!type)\n    return false;\n  clang::QualType qual_type(GetCanonicalQualType(type));\n  const clang::Type::TypeClass type_class = qual_type->getTypeClass();\n  return (type_class == clang::Type::Enum);\n}\n\nbool TypeSystemClang::IsPolymorphicClass(lldb::opaque_compiler_type_t type) {\n  if (type) {\n    clang::QualType qual_type(GetCanonicalQualType(type));\n    const clang::Type::TypeClass type_class = qual_type->getTypeClass();\n    switch (type_class) {\n    case clang::Type::Record:\n      if (GetCompleteType(type)) {\n        const clang::RecordType *record_type =\n            llvm::cast<clang::RecordType>(qual_type.getTypePtr());\n        const clang::RecordDecl *record_decl = record_type->getDecl();\n        if (record_decl) {\n          const clang::CXXRecordDecl *cxx_record_decl =\n              llvm::dyn_cast<clang::CXXRecordDecl>(record_decl);\n          if (cxx_record_decl)\n            return cxx_record_decl->isPolymorphic();\n        }\n      }\n      break;\n\n    default:\n      break;\n    }\n  }\n  return false;\n}\n\nbool TypeSystemClang::IsPossibleDynamicType(lldb::opaque_compiler_type_t type,\n                                            CompilerType *dynamic_pointee_type,\n                                            bool check_cplusplus,\n                                            bool check_objc) {\n  clang::QualType pointee_qual_type;\n  if (type) {\n    clang::QualType qual_type = RemoveWrappingTypes(GetCanonicalQualType(type));\n    bool success = false;\n    const clang::Type::TypeClass type_class = qual_type->getTypeClass();\n    switch (type_class) {\n    case clang::Type::Builtin:\n      if (check_objc &&\n          llvm::cast<clang::BuiltinType>(qual_type)->getKind() ==\n              clang::BuiltinType::ObjCId) {\n        if (dynamic_pointee_type)\n          dynamic_pointee_type->SetCompilerType(this, type);\n        return true;\n      }\n      break;\n\n    case clang::Type::ObjCObjectPointer:\n      if (check_objc) {\n        if (const auto *objc_pointee_type =\n                qual_type->getPointeeType().getTypePtrOrNull()) {\n          if (const auto *objc_object_type =\n                  llvm::dyn_cast_or_null<clang::ObjCObjectType>(\n                      objc_pointee_type)) {\n            if (objc_object_type->isObjCClass())\n              return false;\n          }\n        }\n        if (dynamic_pointee_type)\n          dynamic_pointee_type->SetCompilerType(\n              this, llvm::cast<clang::ObjCObjectPointerType>(qual_type)\n                        ->getPointeeType()\n                        .getAsOpaquePtr());\n        return true;\n      }\n      break;\n\n    case clang::Type::Pointer:\n      pointee_qual_type =\n          llvm::cast<clang::PointerType>(qual_type)->getPointeeType();\n      success = true;\n      break;\n\n    case clang::Type::LValueReference:\n    case clang::Type::RValueReference:\n      pointee_qual_type =\n          llvm::cast<clang::ReferenceType>(qual_type)->getPointeeType();\n      success = true;\n      break;\n\n    default:\n      break;\n    }\n\n    if (success) {\n      // Check to make sure what we are pointing too is a possible dynamic C++\n      // type We currently accept any \"void *\" (in case we have a class that\n      // has been watered down to an opaque pointer) and virtual C++ classes.\n      const clang::Type::TypeClass pointee_type_class =\n          pointee_qual_type.getCanonicalType()->getTypeClass();\n      switch (pointee_type_class) {\n      case clang::Type::Builtin:\n        switch (llvm::cast<clang::BuiltinType>(pointee_qual_type)->getKind()) {\n        case clang::BuiltinType::UnknownAny:\n        case clang::BuiltinType::Void:\n          if (dynamic_pointee_type)\n            dynamic_pointee_type->SetCompilerType(\n                this, pointee_qual_type.getAsOpaquePtr());\n          return true;\n        default:\n          break;\n        }\n        break;\n\n      case clang::Type::Record:\n        if (check_cplusplus) {\n          clang::CXXRecordDecl *cxx_record_decl =\n              pointee_qual_type->getAsCXXRecordDecl();\n          if (cxx_record_decl) {\n            bool is_complete = cxx_record_decl->isCompleteDefinition();\n\n            if (is_complete)\n              success = cxx_record_decl->isDynamicClass();\n            else {\n              ClangASTMetadata *metadata = GetMetadata(cxx_record_decl);\n              if (metadata)\n                success = metadata->GetIsDynamicCXXType();\n              else {\n                is_complete = GetType(pointee_qual_type).GetCompleteType();\n                if (is_complete)\n                  success = cxx_record_decl->isDynamicClass();\n                else\n                  success = false;\n              }\n            }\n\n            if (success) {\n              if (dynamic_pointee_type)\n                dynamic_pointee_type->SetCompilerType(\n                    this, pointee_qual_type.getAsOpaquePtr());\n              return true;\n            }\n          }\n        }\n        break;\n\n      case clang::Type::ObjCObject:\n      case clang::Type::ObjCInterface:\n        if (check_objc) {\n          if (dynamic_pointee_type)\n            dynamic_pointee_type->SetCompilerType(\n                this, pointee_qual_type.getAsOpaquePtr());\n          return true;\n        }\n        break;\n\n      default:\n        break;\n      }\n    }\n  }\n  if (dynamic_pointee_type)\n    dynamic_pointee_type->Clear();\n  return false;\n}\n\nbool TypeSystemClang::IsScalarType(lldb::opaque_compiler_type_t type) {\n  if (!type)\n    return false;\n\n  return (GetTypeInfo(type, nullptr) & eTypeIsScalar) != 0;\n}\n\nbool TypeSystemClang::IsTypedefType(lldb::opaque_compiler_type_t type) {\n  if (!type)\n    return false;\n  return RemoveWrappingTypes(GetQualType(type), {clang::Type::Typedef})\n             ->getTypeClass() == clang::Type::Typedef;\n}\n\nbool TypeSystemClang::IsVoidType(lldb::opaque_compiler_type_t type) {\n  if (!type)\n    return false;\n  return GetCanonicalQualType(type)->isVoidType();\n}\n\nbool TypeSystemClang::CanPassInRegisters(const CompilerType &type) {\n  if (auto *record_decl =\n      TypeSystemClang::GetAsRecordDecl(type)) {\n    return record_decl->canPassInRegisters();\n  }\n  return false;\n}\n\nbool TypeSystemClang::SupportsLanguage(lldb::LanguageType language) {\n  return TypeSystemClangSupportsLanguage(language);\n}\n\nOptional<std::string>\nTypeSystemClang::GetCXXClassName(const CompilerType &type) {\n  if (!type)\n    return llvm::None;\n\n  clang::QualType qual_type(ClangUtil::GetCanonicalQualType(type));\n  if (qual_type.isNull())\n    return llvm::None;\n\n  clang::CXXRecordDecl *cxx_record_decl = qual_type->getAsCXXRecordDecl();\n  if (!cxx_record_decl)\n    return llvm::None;\n\n  return std::string(cxx_record_decl->getIdentifier()->getNameStart());\n}\n\nbool TypeSystemClang::IsCXXClassType(const CompilerType &type) {\n  if (!type)\n    return false;\n\n  clang::QualType qual_type(ClangUtil::GetCanonicalQualType(type));\n  return !qual_type.isNull() && qual_type->getAsCXXRecordDecl() != nullptr;\n}\n\nbool TypeSystemClang::IsBeingDefined(lldb::opaque_compiler_type_t type) {\n  if (!type)\n    return false;\n  clang::QualType qual_type(GetCanonicalQualType(type));\n  const clang::TagType *tag_type = llvm::dyn_cast<clang::TagType>(qual_type);\n  if (tag_type)\n    return tag_type->isBeingDefined();\n  return false;\n}\n\nbool TypeSystemClang::IsObjCObjectPointerType(const CompilerType &type,\n                                              CompilerType *class_type_ptr) {\n  if (!ClangUtil::IsClangType(type))\n    return false;\n\n  clang::QualType qual_type(ClangUtil::GetCanonicalQualType(type));\n\n  if (!qual_type.isNull() && qual_type->isObjCObjectPointerType()) {\n    if (class_type_ptr) {\n      if (!qual_type->isObjCClassType() && !qual_type->isObjCIdType()) {\n        const clang::ObjCObjectPointerType *obj_pointer_type =\n            llvm::dyn_cast<clang::ObjCObjectPointerType>(qual_type);\n        if (obj_pointer_type == nullptr)\n          class_type_ptr->Clear();\n        else\n          class_type_ptr->SetCompilerType(\n              type.GetTypeSystem(),\n              clang::QualType(obj_pointer_type->getInterfaceType(), 0)\n                  .getAsOpaquePtr());\n      }\n    }\n    return true;\n  }\n  if (class_type_ptr)\n    class_type_ptr->Clear();\n  return false;\n}\n\n// Type Completion\n\nbool TypeSystemClang::GetCompleteType(lldb::opaque_compiler_type_t type) {\n  if (!type)\n    return false;\n  const bool allow_completion = true;\n  return GetCompleteQualType(&getASTContext(), GetQualType(type),\n                             allow_completion);\n}\n\nConstString TypeSystemClang::GetTypeName(lldb::opaque_compiler_type_t type) {\n  if (!type)\n    return ConstString();\n\n  clang::QualType qual_type(GetQualType(type));\n\n  // Remove certain type sugar from the name. Sugar such as elaborated types\n  // or template types which only serve to improve diagnostics shouldn't\n  // act as their own types from the user's perspective (e.g., formatter\n  // shouldn't format a variable differently depending on how the ser has\n  // specified the type. '::Type' and 'Type' should behave the same).\n  // Typedefs and atomic derived types are not removed as they are actually\n  // useful for identifiying specific types.\n  qual_type = RemoveWrappingTypes(qual_type,\n                                  {clang::Type::Typedef, clang::Type::Atomic});\n\n  // For a typedef just return the qualified name.\n  if (const auto *typedef_type = qual_type->getAs<clang::TypedefType>()) {\n    const clang::TypedefNameDecl *typedef_decl = typedef_type->getDecl();\n    return ConstString(GetTypeNameForDecl(typedef_decl));\n  }\n\n  return ConstString(qual_type.getAsString(GetTypePrintingPolicy()));\n}\n\nConstString\nTypeSystemClang::GetDisplayTypeName(lldb::opaque_compiler_type_t type) {\n  if (!type)\n    return ConstString();\n\n  clang::QualType qual_type(GetQualType(type));\n  clang::PrintingPolicy printing_policy(getASTContext().getPrintingPolicy());\n  printing_policy.SuppressTagKeyword = true;\n  printing_policy.SuppressScope = false;\n  printing_policy.SuppressUnwrittenScope = true;\n  printing_policy.SuppressInlineNamespace = true;\n  return ConstString(qual_type.getAsString(printing_policy));\n}\n\nuint32_t\nTypeSystemClang::GetTypeInfo(lldb::opaque_compiler_type_t type,\n                             CompilerType *pointee_or_element_clang_type) {\n  if (!type)\n    return 0;\n\n  if (pointee_or_element_clang_type)\n    pointee_or_element_clang_type->Clear();\n\n  clang::QualType qual_type =\n      RemoveWrappingTypes(GetQualType(type), {clang::Type::Typedef});\n\n  const clang::Type::TypeClass type_class = qual_type->getTypeClass();\n  switch (type_class) {\n  case clang::Type::Attributed:\n    return GetTypeInfo(\n        qual_type->getAs<clang::AttributedType>()\n            ->getModifiedType().getAsOpaquePtr(),\n        pointee_or_element_clang_type);\n  case clang::Type::Builtin: {\n    const clang::BuiltinType *builtin_type = llvm::dyn_cast<clang::BuiltinType>(\n        qual_type->getCanonicalTypeInternal());\n\n    uint32_t builtin_type_flags = eTypeIsBuiltIn | eTypeHasValue;\n    switch (builtin_type->getKind()) {\n    case clang::BuiltinType::ObjCId:\n    case clang::BuiltinType::ObjCClass:\n      if (pointee_or_element_clang_type)\n        pointee_or_element_clang_type->SetCompilerType(\n            this, getASTContext().ObjCBuiltinClassTy.getAsOpaquePtr());\n      builtin_type_flags |= eTypeIsPointer | eTypeIsObjC;\n      break;\n\n    case clang::BuiltinType::ObjCSel:\n      if (pointee_or_element_clang_type)\n        pointee_or_element_clang_type->SetCompilerType(\n            this, getASTContext().CharTy.getAsOpaquePtr());\n      builtin_type_flags |= eTypeIsPointer | eTypeIsObjC;\n      break;\n\n    case clang::BuiltinType::Bool:\n    case clang::BuiltinType::Char_U:\n    case clang::BuiltinType::UChar:\n    case clang::BuiltinType::WChar_U:\n    case clang::BuiltinType::Char16:\n    case clang::BuiltinType::Char32:\n    case clang::BuiltinType::UShort:\n    case clang::BuiltinType::UInt:\n    case clang::BuiltinType::ULong:\n    case clang::BuiltinType::ULongLong:\n    case clang::BuiltinType::UInt128:\n    case clang::BuiltinType::Char_S:\n    case clang::BuiltinType::SChar:\n    case clang::BuiltinType::WChar_S:\n    case clang::BuiltinType::Short:\n    case clang::BuiltinType::Int:\n    case clang::BuiltinType::Long:\n    case clang::BuiltinType::LongLong:\n    case clang::BuiltinType::Int128:\n    case clang::BuiltinType::Float:\n    case clang::BuiltinType::Double:\n    case clang::BuiltinType::LongDouble:\n      builtin_type_flags |= eTypeIsScalar;\n      if (builtin_type->isInteger()) {\n        builtin_type_flags |= eTypeIsInteger;\n        if (builtin_type->isSignedInteger())\n          builtin_type_flags |= eTypeIsSigned;\n      } else if (builtin_type->isFloatingPoint())\n        builtin_type_flags |= eTypeIsFloat;\n      break;\n    default:\n      break;\n    }\n    return builtin_type_flags;\n  }\n\n  case clang::Type::BlockPointer:\n    if (pointee_or_element_clang_type)\n      pointee_or_element_clang_type->SetCompilerType(\n          this, qual_type->getPointeeType().getAsOpaquePtr());\n    return eTypeIsPointer | eTypeHasChildren | eTypeIsBlock;\n\n  case clang::Type::Complex: {\n    uint32_t complex_type_flags =\n        eTypeIsBuiltIn | eTypeHasValue | eTypeIsComplex;\n    const clang::ComplexType *complex_type = llvm::dyn_cast<clang::ComplexType>(\n        qual_type->getCanonicalTypeInternal());\n    if (complex_type) {\n      clang::QualType complex_element_type(complex_type->getElementType());\n      if (complex_element_type->isIntegerType())\n        complex_type_flags |= eTypeIsFloat;\n      else if (complex_element_type->isFloatingType())\n        complex_type_flags |= eTypeIsInteger;\n    }\n    return complex_type_flags;\n  } break;\n\n  case clang::Type::ConstantArray:\n  case clang::Type::DependentSizedArray:\n  case clang::Type::IncompleteArray:\n  case clang::Type::VariableArray:\n    if (pointee_or_element_clang_type)\n      pointee_or_element_clang_type->SetCompilerType(\n          this, llvm::cast<clang::ArrayType>(qual_type.getTypePtr())\n                    ->getElementType()\n                    .getAsOpaquePtr());\n    return eTypeHasChildren | eTypeIsArray;\n\n  case clang::Type::DependentName:\n    return 0;\n  case clang::Type::DependentSizedExtVector:\n    return eTypeHasChildren | eTypeIsVector;\n  case clang::Type::DependentTemplateSpecialization:\n    return eTypeIsTemplate;\n\n  case clang::Type::Enum:\n    if (pointee_or_element_clang_type)\n      pointee_or_element_clang_type->SetCompilerType(\n          this, llvm::cast<clang::EnumType>(qual_type)\n                    ->getDecl()\n                    ->getIntegerType()\n                    .getAsOpaquePtr());\n    return eTypeIsEnumeration | eTypeHasValue;\n\n  case clang::Type::FunctionProto:\n    return eTypeIsFuncPrototype | eTypeHasValue;\n  case clang::Type::FunctionNoProto:\n    return eTypeIsFuncPrototype | eTypeHasValue;\n  case clang::Type::InjectedClassName:\n    return 0;\n\n  case clang::Type::LValueReference:\n  case clang::Type::RValueReference:\n    if (pointee_or_element_clang_type)\n      pointee_or_element_clang_type->SetCompilerType(\n          this, llvm::cast<clang::ReferenceType>(qual_type.getTypePtr())\n                    ->getPointeeType()\n                    .getAsOpaquePtr());\n    return eTypeHasChildren | eTypeIsReference | eTypeHasValue;\n\n  case clang::Type::MemberPointer:\n    return eTypeIsPointer | eTypeIsMember | eTypeHasValue;\n\n  case clang::Type::ObjCObjectPointer:\n    if (pointee_or_element_clang_type)\n      pointee_or_element_clang_type->SetCompilerType(\n          this, qual_type->getPointeeType().getAsOpaquePtr());\n    return eTypeHasChildren | eTypeIsObjC | eTypeIsClass | eTypeIsPointer |\n           eTypeHasValue;\n\n  case clang::Type::ObjCObject:\n    return eTypeHasChildren | eTypeIsObjC | eTypeIsClass;\n  case clang::Type::ObjCInterface:\n    return eTypeHasChildren | eTypeIsObjC | eTypeIsClass;\n\n  case clang::Type::Pointer:\n    if (pointee_or_element_clang_type)\n      pointee_or_element_clang_type->SetCompilerType(\n          this, qual_type->getPointeeType().getAsOpaquePtr());\n    return eTypeHasChildren | eTypeIsPointer | eTypeHasValue;\n\n  case clang::Type::Record:\n    if (qual_type->getAsCXXRecordDecl())\n      return eTypeHasChildren | eTypeIsClass | eTypeIsCPlusPlus;\n    else\n      return eTypeHasChildren | eTypeIsStructUnion;\n    break;\n  case clang::Type::SubstTemplateTypeParm:\n    return eTypeIsTemplate;\n  case clang::Type::TemplateTypeParm:\n    return eTypeIsTemplate;\n  case clang::Type::TemplateSpecialization:\n    return eTypeIsTemplate;\n\n  case clang::Type::Typedef:\n    return eTypeIsTypedef | GetType(llvm::cast<clang::TypedefType>(qual_type)\n                                        ->getDecl()\n                                        ->getUnderlyingType())\n                                .GetTypeInfo(pointee_or_element_clang_type);\n  case clang::Type::UnresolvedUsing:\n    return 0;\n\n  case clang::Type::ExtVector:\n  case clang::Type::Vector: {\n    uint32_t vector_type_flags = eTypeHasChildren | eTypeIsVector;\n    const clang::VectorType *vector_type = llvm::dyn_cast<clang::VectorType>(\n        qual_type->getCanonicalTypeInternal());\n    if (vector_type) {\n      if (vector_type->isIntegerType())\n        vector_type_flags |= eTypeIsFloat;\n      else if (vector_type->isFloatingType())\n        vector_type_flags |= eTypeIsInteger;\n    }\n    return vector_type_flags;\n  }\n  default:\n    return 0;\n  }\n  return 0;\n}\n\nlldb::LanguageType\nTypeSystemClang::GetMinimumLanguage(lldb::opaque_compiler_type_t type) {\n  if (!type)\n    return lldb::eLanguageTypeC;\n\n  // If the type is a reference, then resolve it to what it refers to first:\n  clang::QualType qual_type(GetCanonicalQualType(type).getNonReferenceType());\n  if (qual_type->isAnyPointerType()) {\n    if (qual_type->isObjCObjectPointerType())\n      return lldb::eLanguageTypeObjC;\n    if (qual_type->getPointeeCXXRecordDecl())\n      return lldb::eLanguageTypeC_plus_plus;\n\n    clang::QualType pointee_type(qual_type->getPointeeType());\n    if (pointee_type->getPointeeCXXRecordDecl())\n      return lldb::eLanguageTypeC_plus_plus;\n    if (pointee_type->isObjCObjectOrInterfaceType())\n      return lldb::eLanguageTypeObjC;\n    if (pointee_type->isObjCClassType())\n      return lldb::eLanguageTypeObjC;\n    if (pointee_type.getTypePtr() ==\n        getASTContext().ObjCBuiltinIdTy.getTypePtr())\n      return lldb::eLanguageTypeObjC;\n  } else {\n    if (qual_type->isObjCObjectOrInterfaceType())\n      return lldb::eLanguageTypeObjC;\n    if (qual_type->getAsCXXRecordDecl())\n      return lldb::eLanguageTypeC_plus_plus;\n    switch (qual_type->getTypeClass()) {\n    default:\n      break;\n    case clang::Type::Builtin:\n      switch (llvm::cast<clang::BuiltinType>(qual_type)->getKind()) {\n      default:\n      case clang::BuiltinType::Void:\n      case clang::BuiltinType::Bool:\n      case clang::BuiltinType::Char_U:\n      case clang::BuiltinType::UChar:\n      case clang::BuiltinType::WChar_U:\n      case clang::BuiltinType::Char16:\n      case clang::BuiltinType::Char32:\n      case clang::BuiltinType::UShort:\n      case clang::BuiltinType::UInt:\n      case clang::BuiltinType::ULong:\n      case clang::BuiltinType::ULongLong:\n      case clang::BuiltinType::UInt128:\n      case clang::BuiltinType::Char_S:\n      case clang::BuiltinType::SChar:\n      case clang::BuiltinType::WChar_S:\n      case clang::BuiltinType::Short:\n      case clang::BuiltinType::Int:\n      case clang::BuiltinType::Long:\n      case clang::BuiltinType::LongLong:\n      case clang::BuiltinType::Int128:\n      case clang::BuiltinType::Float:\n      case clang::BuiltinType::Double:\n      case clang::BuiltinType::LongDouble:\n        break;\n\n      case clang::BuiltinType::NullPtr:\n        return eLanguageTypeC_plus_plus;\n\n      case clang::BuiltinType::ObjCId:\n      case clang::BuiltinType::ObjCClass:\n      case clang::BuiltinType::ObjCSel:\n        return eLanguageTypeObjC;\n\n      case clang::BuiltinType::Dependent:\n      case clang::BuiltinType::Overload:\n      case clang::BuiltinType::BoundMember:\n      case clang::BuiltinType::UnknownAny:\n        break;\n      }\n      break;\n    case clang::Type::Typedef:\n      return GetType(llvm::cast<clang::TypedefType>(qual_type)\n                         ->getDecl()\n                         ->getUnderlyingType())\n          .GetMinimumLanguage();\n    }\n  }\n  return lldb::eLanguageTypeC;\n}\n\nlldb::TypeClass\nTypeSystemClang::GetTypeClass(lldb::opaque_compiler_type_t type) {\n  if (!type)\n    return lldb::eTypeClassInvalid;\n\n  clang::QualType qual_type =\n      RemoveWrappingTypes(GetQualType(type), {clang::Type::Typedef});\n\n  switch (qual_type->getTypeClass()) {\n  case clang::Type::Atomic:\n  case clang::Type::Auto:\n  case clang::Type::Decltype:\n  case clang::Type::Elaborated:\n  case clang::Type::Paren:\n  case clang::Type::TypeOf:\n  case clang::Type::TypeOfExpr:\n    llvm_unreachable(\"Handled in RemoveWrappingTypes!\");\n  case clang::Type::UnaryTransform:\n    break;\n  case clang::Type::FunctionNoProto:\n    return lldb::eTypeClassFunction;\n  case clang::Type::FunctionProto:\n    return lldb::eTypeClassFunction;\n  case clang::Type::IncompleteArray:\n    return lldb::eTypeClassArray;\n  case clang::Type::VariableArray:\n    return lldb::eTypeClassArray;\n  case clang::Type::ConstantArray:\n    return lldb::eTypeClassArray;\n  case clang::Type::DependentSizedArray:\n    return lldb::eTypeClassArray;\n  case clang::Type::DependentSizedExtVector:\n    return lldb::eTypeClassVector;\n  case clang::Type::DependentVector:\n    return lldb::eTypeClassVector;\n  case clang::Type::ExtVector:\n    return lldb::eTypeClassVector;\n  case clang::Type::Vector:\n    return lldb::eTypeClassVector;\n  case clang::Type::Builtin:\n  // Ext-Int is just an integer type.\n  case clang::Type::ExtInt:\n  case clang::Type::DependentExtInt:\n    return lldb::eTypeClassBuiltin;\n  case clang::Type::ObjCObjectPointer:\n    return lldb::eTypeClassObjCObjectPointer;\n  case clang::Type::BlockPointer:\n    return lldb::eTypeClassBlockPointer;\n  case clang::Type::Pointer:\n    return lldb::eTypeClassPointer;\n  case clang::Type::LValueReference:\n    return lldb::eTypeClassReference;\n  case clang::Type::RValueReference:\n    return lldb::eTypeClassReference;\n  case clang::Type::MemberPointer:\n    return lldb::eTypeClassMemberPointer;\n  case clang::Type::Complex:\n    if (qual_type->isComplexType())\n      return lldb::eTypeClassComplexFloat;\n    else\n      return lldb::eTypeClassComplexInteger;\n  case clang::Type::ObjCObject:\n    return lldb::eTypeClassObjCObject;\n  case clang::Type::ObjCInterface:\n    return lldb::eTypeClassObjCInterface;\n  case clang::Type::Record: {\n    const clang::RecordType *record_type =\n        llvm::cast<clang::RecordType>(qual_type.getTypePtr());\n    const clang::RecordDecl *record_decl = record_type->getDecl();\n    if (record_decl->isUnion())\n      return lldb::eTypeClassUnion;\n    else if (record_decl->isStruct())\n      return lldb::eTypeClassStruct;\n    else\n      return lldb::eTypeClassClass;\n  } break;\n  case clang::Type::Enum:\n    return lldb::eTypeClassEnumeration;\n  case clang::Type::Typedef:\n    return lldb::eTypeClassTypedef;\n  case clang::Type::UnresolvedUsing:\n    break;\n\n  case clang::Type::Attributed:\n    break;\n  case clang::Type::TemplateTypeParm:\n    break;\n  case clang::Type::SubstTemplateTypeParm:\n    break;\n  case clang::Type::SubstTemplateTypeParmPack:\n    break;\n  case clang::Type::InjectedClassName:\n    break;\n  case clang::Type::DependentName:\n    break;\n  case clang::Type::DependentTemplateSpecialization:\n    break;\n  case clang::Type::PackExpansion:\n    break;\n\n  case clang::Type::TemplateSpecialization:\n    break;\n  case clang::Type::DeducedTemplateSpecialization:\n    break;\n  case clang::Type::Pipe:\n    break;\n\n  // pointer type decayed from an array or function type.\n  case clang::Type::Decayed:\n    break;\n  case clang::Type::Adjusted:\n    break;\n  case clang::Type::ObjCTypeParam:\n    break;\n\n  case clang::Type::DependentAddressSpace:\n    break;\n  case clang::Type::MacroQualified:\n    break;\n\n  // Matrix types that we're not sure how to display at the moment.\n  case clang::Type::ConstantMatrix:\n  case clang::Type::DependentSizedMatrix:\n    break;\n  }\n  // We don't know hot to display this type...\n  return lldb::eTypeClassOther;\n}\n\nunsigned TypeSystemClang::GetTypeQualifiers(lldb::opaque_compiler_type_t type) {\n  if (type)\n    return GetQualType(type).getQualifiers().getCVRQualifiers();\n  return 0;\n}\n\n// Creating related types\n\nCompilerType\nTypeSystemClang::GetArrayElementType(lldb::opaque_compiler_type_t type,\n                                     ExecutionContextScope *exe_scope) {\n  if (type) {\n    clang::QualType qual_type(GetQualType(type));\n\n    const clang::Type *array_eletype =\n        qual_type.getTypePtr()->getArrayElementTypeNoTypeQual();\n\n    if (!array_eletype)\n      return CompilerType();\n\n    return GetType(clang::QualType(array_eletype, 0));\n  }\n  return CompilerType();\n}\n\nCompilerType TypeSystemClang::GetArrayType(lldb::opaque_compiler_type_t type,\n                                           uint64_t size) {\n  if (type) {\n    clang::QualType qual_type(GetCanonicalQualType(type));\n    clang::ASTContext &ast_ctx = getASTContext();\n    if (size != 0)\n      return GetType(ast_ctx.getConstantArrayType(\n          qual_type, llvm::APInt(64, size), nullptr,\n          clang::ArrayType::ArraySizeModifier::Normal, 0));\n    else\n      return GetType(ast_ctx.getIncompleteArrayType(\n          qual_type, clang::ArrayType::ArraySizeModifier::Normal, 0));\n  }\n\n  return CompilerType();\n}\n\nCompilerType\nTypeSystemClang::GetCanonicalType(lldb::opaque_compiler_type_t type) {\n  if (type)\n    return GetType(GetCanonicalQualType(type));\n  return CompilerType();\n}\n\nstatic clang::QualType GetFullyUnqualifiedType_Impl(clang::ASTContext *ast,\n                                                    clang::QualType qual_type) {\n  if (qual_type->isPointerType())\n    qual_type = ast->getPointerType(\n        GetFullyUnqualifiedType_Impl(ast, qual_type->getPointeeType()));\n  else\n    qual_type = qual_type.getUnqualifiedType();\n  qual_type.removeLocalConst();\n  qual_type.removeLocalRestrict();\n  qual_type.removeLocalVolatile();\n  return qual_type;\n}\n\nCompilerType\nTypeSystemClang::GetFullyUnqualifiedType(lldb::opaque_compiler_type_t type) {\n  if (type)\n    return GetType(\n        GetFullyUnqualifiedType_Impl(&getASTContext(), GetQualType(type)));\n  return CompilerType();\n}\n\nCompilerType\nTypeSystemClang::GetEnumerationIntegerType(lldb::opaque_compiler_type_t type) {\n  if (type)\n    return GetEnumerationIntegerType(GetType(GetCanonicalQualType(type)));\n  return CompilerType();\n}\n\nint TypeSystemClang::GetFunctionArgumentCount(\n    lldb::opaque_compiler_type_t type) {\n  if (type) {\n    const clang::FunctionProtoType *func =\n        llvm::dyn_cast<clang::FunctionProtoType>(GetCanonicalQualType(type));\n    if (func)\n      return func->getNumParams();\n  }\n  return -1;\n}\n\nCompilerType TypeSystemClang::GetFunctionArgumentTypeAtIndex(\n    lldb::opaque_compiler_type_t type, size_t idx) {\n  if (type) {\n    const clang::FunctionProtoType *func =\n        llvm::dyn_cast<clang::FunctionProtoType>(GetQualType(type));\n    if (func) {\n      const uint32_t num_args = func->getNumParams();\n      if (idx < num_args)\n        return GetType(func->getParamType(idx));\n    }\n  }\n  return CompilerType();\n}\n\nCompilerType\nTypeSystemClang::GetFunctionReturnType(lldb::opaque_compiler_type_t type) {\n  if (type) {\n    clang::QualType qual_type(GetQualType(type));\n    const clang::FunctionProtoType *func =\n        llvm::dyn_cast<clang::FunctionProtoType>(qual_type.getTypePtr());\n    if (func)\n      return GetType(func->getReturnType());\n  }\n  return CompilerType();\n}\n\nsize_t\nTypeSystemClang::GetNumMemberFunctions(lldb::opaque_compiler_type_t type) {\n  size_t num_functions = 0;\n  if (type) {\n    clang::QualType qual_type = RemoveWrappingTypes(GetCanonicalQualType(type));\n    switch (qual_type->getTypeClass()) {\n    case clang::Type::Record:\n      if (GetCompleteQualType(&getASTContext(), qual_type)) {\n        const clang::RecordType *record_type =\n            llvm::cast<clang::RecordType>(qual_type.getTypePtr());\n        const clang::RecordDecl *record_decl = record_type->getDecl();\n        assert(record_decl);\n        const clang::CXXRecordDecl *cxx_record_decl =\n            llvm::dyn_cast<clang::CXXRecordDecl>(record_decl);\n        if (cxx_record_decl)\n          num_functions = std::distance(cxx_record_decl->method_begin(),\n                                        cxx_record_decl->method_end());\n      }\n      break;\n\n    case clang::Type::ObjCObjectPointer: {\n      const clang::ObjCObjectPointerType *objc_class_type =\n          qual_type->getAs<clang::ObjCObjectPointerType>();\n      const clang::ObjCInterfaceType *objc_interface_type =\n          objc_class_type->getInterfaceType();\n      if (objc_interface_type &&\n          GetCompleteType(static_cast<lldb::opaque_compiler_type_t>(\n              const_cast<clang::ObjCInterfaceType *>(objc_interface_type)))) {\n        clang::ObjCInterfaceDecl *class_interface_decl =\n            objc_interface_type->getDecl();\n        if (class_interface_decl) {\n          num_functions = std::distance(class_interface_decl->meth_begin(),\n                                        class_interface_decl->meth_end());\n        }\n      }\n      break;\n    }\n\n    case clang::Type::ObjCObject:\n    case clang::Type::ObjCInterface:\n      if (GetCompleteType(type)) {\n        const clang::ObjCObjectType *objc_class_type =\n            llvm::dyn_cast<clang::ObjCObjectType>(qual_type.getTypePtr());\n        if (objc_class_type) {\n          clang::ObjCInterfaceDecl *class_interface_decl =\n              objc_class_type->getInterface();\n          if (class_interface_decl)\n            num_functions = std::distance(class_interface_decl->meth_begin(),\n                                          class_interface_decl->meth_end());\n        }\n      }\n      break;\n\n    default:\n      break;\n    }\n  }\n  return num_functions;\n}\n\nTypeMemberFunctionImpl\nTypeSystemClang::GetMemberFunctionAtIndex(lldb::opaque_compiler_type_t type,\n                                          size_t idx) {\n  std::string name;\n  MemberFunctionKind kind(MemberFunctionKind::eMemberFunctionKindUnknown);\n  CompilerType clang_type;\n  CompilerDecl clang_decl;\n  if (type) {\n    clang::QualType qual_type = RemoveWrappingTypes(GetCanonicalQualType(type));\n    switch (qual_type->getTypeClass()) {\n    case clang::Type::Record:\n      if (GetCompleteQualType(&getASTContext(), qual_type)) {\n        const clang::RecordType *record_type =\n            llvm::cast<clang::RecordType>(qual_type.getTypePtr());\n        const clang::RecordDecl *record_decl = record_type->getDecl();\n        assert(record_decl);\n        const clang::CXXRecordDecl *cxx_record_decl =\n            llvm::dyn_cast<clang::CXXRecordDecl>(record_decl);\n        if (cxx_record_decl) {\n          auto method_iter = cxx_record_decl->method_begin();\n          auto method_end = cxx_record_decl->method_end();\n          if (idx <\n              static_cast<size_t>(std::distance(method_iter, method_end))) {\n            std::advance(method_iter, idx);\n            clang::CXXMethodDecl *cxx_method_decl =\n                method_iter->getCanonicalDecl();\n            if (cxx_method_decl) {\n              name = cxx_method_decl->getDeclName().getAsString();\n              if (cxx_method_decl->isStatic())\n                kind = lldb::eMemberFunctionKindStaticMethod;\n              else if (llvm::isa<clang::CXXConstructorDecl>(cxx_method_decl))\n                kind = lldb::eMemberFunctionKindConstructor;\n              else if (llvm::isa<clang::CXXDestructorDecl>(cxx_method_decl))\n                kind = lldb::eMemberFunctionKindDestructor;\n              else\n                kind = lldb::eMemberFunctionKindInstanceMethod;\n              clang_type = GetType(cxx_method_decl->getType());\n              clang_decl = GetCompilerDecl(cxx_method_decl);\n            }\n          }\n        }\n      }\n      break;\n\n    case clang::Type::ObjCObjectPointer: {\n      const clang::ObjCObjectPointerType *objc_class_type =\n          qual_type->getAs<clang::ObjCObjectPointerType>();\n      const clang::ObjCInterfaceType *objc_interface_type =\n          objc_class_type->getInterfaceType();\n      if (objc_interface_type &&\n          GetCompleteType(static_cast<lldb::opaque_compiler_type_t>(\n              const_cast<clang::ObjCInterfaceType *>(objc_interface_type)))) {\n        clang::ObjCInterfaceDecl *class_interface_decl =\n            objc_interface_type->getDecl();\n        if (class_interface_decl) {\n          auto method_iter = class_interface_decl->meth_begin();\n          auto method_end = class_interface_decl->meth_end();\n          if (idx <\n              static_cast<size_t>(std::distance(method_iter, method_end))) {\n            std::advance(method_iter, idx);\n            clang::ObjCMethodDecl *objc_method_decl =\n                method_iter->getCanonicalDecl();\n            if (objc_method_decl) {\n              clang_decl = GetCompilerDecl(objc_method_decl);\n              name = objc_method_decl->getSelector().getAsString();\n              if (objc_method_decl->isClassMethod())\n                kind = lldb::eMemberFunctionKindStaticMethod;\n              else\n                kind = lldb::eMemberFunctionKindInstanceMethod;\n            }\n          }\n        }\n      }\n      break;\n    }\n\n    case clang::Type::ObjCObject:\n    case clang::Type::ObjCInterface:\n      if (GetCompleteType(type)) {\n        const clang::ObjCObjectType *objc_class_type =\n            llvm::dyn_cast<clang::ObjCObjectType>(qual_type.getTypePtr());\n        if (objc_class_type) {\n          clang::ObjCInterfaceDecl *class_interface_decl =\n              objc_class_type->getInterface();\n          if (class_interface_decl) {\n            auto method_iter = class_interface_decl->meth_begin();\n            auto method_end = class_interface_decl->meth_end();\n            if (idx <\n                static_cast<size_t>(std::distance(method_iter, method_end))) {\n              std::advance(method_iter, idx);\n              clang::ObjCMethodDecl *objc_method_decl =\n                  method_iter->getCanonicalDecl();\n              if (objc_method_decl) {\n                clang_decl = GetCompilerDecl(objc_method_decl);\n                name = objc_method_decl->getSelector().getAsString();\n                if (objc_method_decl->isClassMethod())\n                  kind = lldb::eMemberFunctionKindStaticMethod;\n                else\n                  kind = lldb::eMemberFunctionKindInstanceMethod;\n              }\n            }\n          }\n        }\n      }\n      break;\n\n    default:\n      break;\n    }\n  }\n\n  if (kind == eMemberFunctionKindUnknown)\n    return TypeMemberFunctionImpl();\n  else\n    return TypeMemberFunctionImpl(clang_type, clang_decl, name, kind);\n}\n\nCompilerType\nTypeSystemClang::GetNonReferenceType(lldb::opaque_compiler_type_t type) {\n  if (type)\n    return GetType(GetQualType(type).getNonReferenceType());\n  return CompilerType();\n}\n\nCompilerType\nTypeSystemClang::GetPointeeType(lldb::opaque_compiler_type_t type) {\n  if (type) {\n    clang::QualType qual_type(GetQualType(type));\n    return GetType(qual_type.getTypePtr()->getPointeeType());\n  }\n  return CompilerType();\n}\n\nCompilerType\nTypeSystemClang::GetPointerType(lldb::opaque_compiler_type_t type) {\n  if (type) {\n    clang::QualType qual_type(GetQualType(type));\n\n    switch (qual_type.getDesugaredType(getASTContext())->getTypeClass()) {\n    case clang::Type::ObjCObject:\n    case clang::Type::ObjCInterface:\n      return GetType(getASTContext().getObjCObjectPointerType(qual_type));\n\n    default:\n      return GetType(getASTContext().getPointerType(qual_type));\n    }\n  }\n  return CompilerType();\n}\n\nCompilerType\nTypeSystemClang::GetLValueReferenceType(lldb::opaque_compiler_type_t type) {\n  if (type)\n    return GetType(getASTContext().getLValueReferenceType(GetQualType(type)));\n  else\n    return CompilerType();\n}\n\nCompilerType\nTypeSystemClang::GetRValueReferenceType(lldb::opaque_compiler_type_t type) {\n  if (type)\n    return GetType(getASTContext().getRValueReferenceType(GetQualType(type)));\n  else\n    return CompilerType();\n}\n\nCompilerType TypeSystemClang::GetAtomicType(lldb::opaque_compiler_type_t type) {\n  if (!type)\n    return CompilerType();\n  return GetType(getASTContext().getAtomicType(GetQualType(type)));\n}\n\nCompilerType\nTypeSystemClang::AddConstModifier(lldb::opaque_compiler_type_t type) {\n  if (type) {\n    clang::QualType result(GetQualType(type));\n    result.addConst();\n    return GetType(result);\n  }\n  return CompilerType();\n}\n\nCompilerType\nTypeSystemClang::AddVolatileModifier(lldb::opaque_compiler_type_t type) {\n  if (type) {\n    clang::QualType result(GetQualType(type));\n    result.addVolatile();\n    return GetType(result);\n  }\n  return CompilerType();\n}\n\nCompilerType\nTypeSystemClang::AddRestrictModifier(lldb::opaque_compiler_type_t type) {\n  if (type) {\n    clang::QualType result(GetQualType(type));\n    result.addRestrict();\n    return GetType(result);\n  }\n  return CompilerType();\n}\n\nCompilerType TypeSystemClang::CreateTypedef(\n    lldb::opaque_compiler_type_t type, const char *typedef_name,\n    const CompilerDeclContext &compiler_decl_ctx, uint32_t payload) {\n  if (type && typedef_name && typedef_name[0]) {\n    clang::ASTContext &clang_ast = getASTContext();\n    clang::QualType qual_type(GetQualType(type));\n\n    clang::DeclContext *decl_ctx =\n        TypeSystemClang::DeclContextGetAsDeclContext(compiler_decl_ctx);\n    if (!decl_ctx)\n      decl_ctx = getASTContext().getTranslationUnitDecl();\n\n    clang::TypedefDecl *decl =\n        clang::TypedefDecl::CreateDeserialized(clang_ast, 0);\n    decl->setDeclContext(decl_ctx);\n    decl->setDeclName(&clang_ast.Idents.get(typedef_name));\n    decl->setTypeSourceInfo(clang_ast.getTrivialTypeSourceInfo(qual_type));\n    decl_ctx->addDecl(decl);\n    SetOwningModule(decl, TypePayloadClang(payload).GetOwningModule());\n\n    clang::TagDecl *tdecl = nullptr;\n    if (!qual_type.isNull()) {\n      if (const clang::RecordType *rt = qual_type->getAs<clang::RecordType>())\n        tdecl = rt->getDecl();\n      if (const clang::EnumType *et = qual_type->getAs<clang::EnumType>())\n        tdecl = et->getDecl();\n    }\n\n    // Check whether this declaration is an anonymous struct, union, or enum,\n    // hidden behind a typedef. If so, we try to check whether we have a\n    // typedef tag to attach to the original record declaration\n    if (tdecl && !tdecl->getIdentifier() && !tdecl->getTypedefNameForAnonDecl())\n      tdecl->setTypedefNameForAnonDecl(decl);\n\n    decl->setAccess(clang::AS_public); // TODO respect proper access specifier\n\n    // Get a uniqued clang::QualType for the typedef decl type\n    return GetType(clang_ast.getTypedefType(decl));\n  }\n  return CompilerType();\n}\n\nCompilerType\nTypeSystemClang::GetTypedefedType(lldb::opaque_compiler_type_t type) {\n  if (type) {\n    const clang::TypedefType *typedef_type = llvm::dyn_cast<clang::TypedefType>(\n        RemoveWrappingTypes(GetQualType(type), {clang::Type::Typedef}));\n    if (typedef_type)\n      return GetType(typedef_type->getDecl()->getUnderlyingType());\n  }\n  return CompilerType();\n}\n\n// Create related types using the current type's AST\n\nCompilerType TypeSystemClang::GetBasicTypeFromAST(lldb::BasicType basic_type) {\n  return TypeSystemClang::GetBasicType(basic_type);\n}\n// Exploring the type\n\nconst llvm::fltSemantics &\nTypeSystemClang::GetFloatTypeSemantics(size_t byte_size) {\n  clang::ASTContext &ast = getASTContext();\n  const size_t bit_size = byte_size * 8;\n  if (bit_size == ast.getTypeSize(ast.FloatTy))\n    return ast.getFloatTypeSemantics(ast.FloatTy);\n  else if (bit_size == ast.getTypeSize(ast.DoubleTy))\n    return ast.getFloatTypeSemantics(ast.DoubleTy);\n  else if (bit_size == ast.getTypeSize(ast.LongDoubleTy))\n    return ast.getFloatTypeSemantics(ast.LongDoubleTy);\n  else if (bit_size == ast.getTypeSize(ast.HalfTy))\n    return ast.getFloatTypeSemantics(ast.HalfTy);\n  return llvm::APFloatBase::Bogus();\n}\n\nOptional<uint64_t>\nTypeSystemClang::GetBitSize(lldb::opaque_compiler_type_t type,\n                            ExecutionContextScope *exe_scope) {\n  if (GetCompleteType(type)) {\n    clang::QualType qual_type(GetCanonicalQualType(type));\n    const clang::Type::TypeClass type_class = qual_type->getTypeClass();\n    switch (type_class) {\n    case clang::Type::Record:\n      if (GetCompleteType(type))\n        return getASTContext().getTypeSize(qual_type);\n      else\n        return None;\n      break;\n\n    case clang::Type::ObjCInterface:\n    case clang::Type::ObjCObject: {\n      ExecutionContext exe_ctx(exe_scope);\n      Process *process = exe_ctx.GetProcessPtr();\n      if (process) {\n        ObjCLanguageRuntime *objc_runtime = ObjCLanguageRuntime::Get(*process);\n        if (objc_runtime) {\n          uint64_t bit_size = 0;\n          if (objc_runtime->GetTypeBitSize(GetType(qual_type), bit_size))\n            return bit_size;\n        }\n      } else {\n        static bool g_printed = false;\n        if (!g_printed) {\n          StreamString s;\n          DumpTypeDescription(type, &s);\n\n          llvm::outs() << \"warning: trying to determine the size of type \";\n          llvm::outs() << s.GetString() << \"\\n\";\n          llvm::outs() << \"without a valid ExecutionContext. this is not \"\n                          \"reliable. please file a bug against LLDB.\\n\";\n          llvm::outs() << \"backtrace:\\n\";\n          llvm::sys::PrintStackTrace(llvm::outs());\n          llvm::outs() << \"\\n\";\n          g_printed = true;\n        }\n      }\n    }\n      LLVM_FALLTHROUGH;\n    default:\n      const uint32_t bit_size = getASTContext().getTypeSize(qual_type);\n      if (bit_size == 0) {\n        if (qual_type->isIncompleteArrayType())\n          return getASTContext().getTypeSize(\n              qual_type->getArrayElementTypeNoTypeQual()\n                  ->getCanonicalTypeUnqualified());\n      }\n      if (qual_type->isObjCObjectOrInterfaceType())\n        return bit_size +\n               getASTContext().getTypeSize(getASTContext().ObjCBuiltinClassTy);\n      // Function types actually have a size of 0, that's not an error.\n      if (qual_type->isFunctionProtoType())\n        return bit_size;\n      if (bit_size)\n        return bit_size;\n    }\n  }\n  return None;\n}\n\nllvm::Optional<size_t>\nTypeSystemClang::GetTypeBitAlign(lldb::opaque_compiler_type_t type,\n                                 ExecutionContextScope *exe_scope) {\n  if (GetCompleteType(type))\n    return getASTContext().getTypeAlign(GetQualType(type));\n  return {};\n}\n\nlldb::Encoding TypeSystemClang::GetEncoding(lldb::opaque_compiler_type_t type,\n                                            uint64_t &count) {\n  if (!type)\n    return lldb::eEncodingInvalid;\n\n  count = 1;\n  clang::QualType qual_type = RemoveWrappingTypes(GetCanonicalQualType(type));\n\n  switch (qual_type->getTypeClass()) {\n  case clang::Type::Atomic:\n  case clang::Type::Auto:\n  case clang::Type::Decltype:\n  case clang::Type::Elaborated:\n  case clang::Type::Paren:\n  case clang::Type::Typedef:\n  case clang::Type::TypeOf:\n  case clang::Type::TypeOfExpr:\n    llvm_unreachable(\"Handled in RemoveWrappingTypes!\");\n\n  case clang::Type::UnaryTransform:\n    break;\n\n  case clang::Type::FunctionNoProto:\n  case clang::Type::FunctionProto:\n    break;\n\n  case clang::Type::IncompleteArray:\n  case clang::Type::VariableArray:\n    break;\n\n  case clang::Type::ConstantArray:\n    break;\n\n  case clang::Type::DependentVector:\n  case clang::Type::ExtVector:\n  case clang::Type::Vector:\n    // TODO: Set this to more than one???\n    break;\n\n  case clang::Type::ExtInt:\n  case clang::Type::DependentExtInt:\n    return qual_type->isUnsignedIntegerType() ? lldb::eEncodingUint\n                                              : lldb::eEncodingSint;\n\n  case clang::Type::Builtin:\n    switch (llvm::cast<clang::BuiltinType>(qual_type)->getKind()) {\n    case clang::BuiltinType::Void:\n      break;\n\n    case clang::BuiltinType::Bool:\n    case clang::BuiltinType::Char_S:\n    case clang::BuiltinType::SChar:\n    case clang::BuiltinType::WChar_S:\n    case clang::BuiltinType::Short:\n    case clang::BuiltinType::Int:\n    case clang::BuiltinType::Long:\n    case clang::BuiltinType::LongLong:\n    case clang::BuiltinType::Int128:\n      return lldb::eEncodingSint;\n\n    case clang::BuiltinType::Char_U:\n    case clang::BuiltinType::UChar:\n    case clang::BuiltinType::WChar_U:\n    case clang::BuiltinType::Char8:\n    case clang::BuiltinType::Char16:\n    case clang::BuiltinType::Char32:\n    case clang::BuiltinType::UShort:\n    case clang::BuiltinType::UInt:\n    case clang::BuiltinType::ULong:\n    case clang::BuiltinType::ULongLong:\n    case clang::BuiltinType::UInt128:\n      return lldb::eEncodingUint;\n\n    // Fixed point types. Note that they are currently ignored.\n    case clang::BuiltinType::ShortAccum:\n    case clang::BuiltinType::Accum:\n    case clang::BuiltinType::LongAccum:\n    case clang::BuiltinType::UShortAccum:\n    case clang::BuiltinType::UAccum:\n    case clang::BuiltinType::ULongAccum:\n    case clang::BuiltinType::ShortFract:\n    case clang::BuiltinType::Fract:\n    case clang::BuiltinType::LongFract:\n    case clang::BuiltinType::UShortFract:\n    case clang::BuiltinType::UFract:\n    case clang::BuiltinType::ULongFract:\n    case clang::BuiltinType::SatShortAccum:\n    case clang::BuiltinType::SatAccum:\n    case clang::BuiltinType::SatLongAccum:\n    case clang::BuiltinType::SatUShortAccum:\n    case clang::BuiltinType::SatUAccum:\n    case clang::BuiltinType::SatULongAccum:\n    case clang::BuiltinType::SatShortFract:\n    case clang::BuiltinType::SatFract:\n    case clang::BuiltinType::SatLongFract:\n    case clang::BuiltinType::SatUShortFract:\n    case clang::BuiltinType::SatUFract:\n    case clang::BuiltinType::SatULongFract:\n      break;\n\n    case clang::BuiltinType::Half:\n    case clang::BuiltinType::Float:\n    case clang::BuiltinType::Float16:\n    case clang::BuiltinType::Float128:\n    case clang::BuiltinType::Double:\n    case clang::BuiltinType::LongDouble:\n    case clang::BuiltinType::BFloat16:\n      return lldb::eEncodingIEEE754;\n\n    case clang::BuiltinType::ObjCClass:\n    case clang::BuiltinType::ObjCId:\n    case clang::BuiltinType::ObjCSel:\n      return lldb::eEncodingUint;\n\n    case clang::BuiltinType::NullPtr:\n      return lldb::eEncodingUint;\n\n    case clang::BuiltinType::Kind::ARCUnbridgedCast:\n    case clang::BuiltinType::Kind::BoundMember:\n    case clang::BuiltinType::Kind::BuiltinFn:\n    case clang::BuiltinType::Kind::Dependent:\n    case clang::BuiltinType::Kind::OCLClkEvent:\n    case clang::BuiltinType::Kind::OCLEvent:\n    case clang::BuiltinType::Kind::OCLImage1dRO:\n    case clang::BuiltinType::Kind::OCLImage1dWO:\n    case clang::BuiltinType::Kind::OCLImage1dRW:\n    case clang::BuiltinType::Kind::OCLImage1dArrayRO:\n    case clang::BuiltinType::Kind::OCLImage1dArrayWO:\n    case clang::BuiltinType::Kind::OCLImage1dArrayRW:\n    case clang::BuiltinType::Kind::OCLImage1dBufferRO:\n    case clang::BuiltinType::Kind::OCLImage1dBufferWO:\n    case clang::BuiltinType::Kind::OCLImage1dBufferRW:\n    case clang::BuiltinType::Kind::OCLImage2dRO:\n    case clang::BuiltinType::Kind::OCLImage2dWO:\n    case clang::BuiltinType::Kind::OCLImage2dRW:\n    case clang::BuiltinType::Kind::OCLImage2dArrayRO:\n    case clang::BuiltinType::Kind::OCLImage2dArrayWO:\n    case clang::BuiltinType::Kind::OCLImage2dArrayRW:\n    case clang::BuiltinType::Kind::OCLImage2dArrayDepthRO:\n    case clang::BuiltinType::Kind::OCLImage2dArrayDepthWO:\n    case clang::BuiltinType::Kind::OCLImage2dArrayDepthRW:\n    case clang::BuiltinType::Kind::OCLImage2dArrayMSAARO:\n    case clang::BuiltinType::Kind::OCLImage2dArrayMSAAWO:\n    case clang::BuiltinType::Kind::OCLImage2dArrayMSAARW:\n    case clang::BuiltinType::Kind::OCLImage2dArrayMSAADepthRO:\n    case clang::BuiltinType::Kind::OCLImage2dArrayMSAADepthWO:\n    case clang::BuiltinType::Kind::OCLImage2dArrayMSAADepthRW:\n    case clang::BuiltinType::Kind::OCLImage2dDepthRO:\n    case clang::BuiltinType::Kind::OCLImage2dDepthWO:\n    case clang::BuiltinType::Kind::OCLImage2dDepthRW:\n    case clang::BuiltinType::Kind::OCLImage2dMSAARO:\n    case clang::BuiltinType::Kind::OCLImage2dMSAAWO:\n    case clang::BuiltinType::Kind::OCLImage2dMSAARW:\n    case clang::BuiltinType::Kind::OCLImage2dMSAADepthRO:\n    case clang::BuiltinType::Kind::OCLImage2dMSAADepthWO:\n    case clang::BuiltinType::Kind::OCLImage2dMSAADepthRW:\n    case clang::BuiltinType::Kind::OCLImage3dRO:\n    case clang::BuiltinType::Kind::OCLImage3dWO:\n    case clang::BuiltinType::Kind::OCLImage3dRW:\n    case clang::BuiltinType::Kind::OCLQueue:\n    case clang::BuiltinType::Kind::OCLReserveID:\n    case clang::BuiltinType::Kind::OCLSampler:\n    case clang::BuiltinType::Kind::OMPArraySection:\n    case clang::BuiltinType::Kind::OMPArrayShaping:\n    case clang::BuiltinType::Kind::OMPIterator:\n    case clang::BuiltinType::Kind::Overload:\n    case clang::BuiltinType::Kind::PseudoObject:\n    case clang::BuiltinType::Kind::UnknownAny:\n      break;\n\n    case clang::BuiltinType::OCLIntelSubgroupAVCMcePayload:\n    case clang::BuiltinType::OCLIntelSubgroupAVCImePayload:\n    case clang::BuiltinType::OCLIntelSubgroupAVCRefPayload:\n    case clang::BuiltinType::OCLIntelSubgroupAVCSicPayload:\n    case clang::BuiltinType::OCLIntelSubgroupAVCMceResult:\n    case clang::BuiltinType::OCLIntelSubgroupAVCImeResult:\n    case clang::BuiltinType::OCLIntelSubgroupAVCRefResult:\n    case clang::BuiltinType::OCLIntelSubgroupAVCSicResult:\n    case clang::BuiltinType::OCLIntelSubgroupAVCImeResultSingleRefStreamout:\n    case clang::BuiltinType::OCLIntelSubgroupAVCImeResultDualRefStreamout:\n    case clang::BuiltinType::OCLIntelSubgroupAVCImeSingleRefStreamin:\n    case clang::BuiltinType::OCLIntelSubgroupAVCImeDualRefStreamin:\n      break;\n\n    // PowerPC -- Matrix Multiply Assist\n    case clang::BuiltinType::VectorPair:\n    case clang::BuiltinType::VectorQuad:\n      break;\n\n    // ARM -- Scalable Vector Extension\n    case clang::BuiltinType::SveBool:\n    case clang::BuiltinType::SveInt8:\n    case clang::BuiltinType::SveInt8x2:\n    case clang::BuiltinType::SveInt8x3:\n    case clang::BuiltinType::SveInt8x4:\n    case clang::BuiltinType::SveInt16:\n    case clang::BuiltinType::SveInt16x2:\n    case clang::BuiltinType::SveInt16x3:\n    case clang::BuiltinType::SveInt16x4:\n    case clang::BuiltinType::SveInt32:\n    case clang::BuiltinType::SveInt32x2:\n    case clang::BuiltinType::SveInt32x3:\n    case clang::BuiltinType::SveInt32x4:\n    case clang::BuiltinType::SveInt64:\n    case clang::BuiltinType::SveInt64x2:\n    case clang::BuiltinType::SveInt64x3:\n    case clang::BuiltinType::SveInt64x4:\n    case clang::BuiltinType::SveUint8:\n    case clang::BuiltinType::SveUint8x2:\n    case clang::BuiltinType::SveUint8x3:\n    case clang::BuiltinType::SveUint8x4:\n    case clang::BuiltinType::SveUint16:\n    case clang::BuiltinType::SveUint16x2:\n    case clang::BuiltinType::SveUint16x3:\n    case clang::BuiltinType::SveUint16x4:\n    case clang::BuiltinType::SveUint32:\n    case clang::BuiltinType::SveUint32x2:\n    case clang::BuiltinType::SveUint32x3:\n    case clang::BuiltinType::SveUint32x4:\n    case clang::BuiltinType::SveUint64:\n    case clang::BuiltinType::SveUint64x2:\n    case clang::BuiltinType::SveUint64x3:\n    case clang::BuiltinType::SveUint64x4:\n    case clang::BuiltinType::SveFloat16:\n    case clang::BuiltinType::SveBFloat16:\n    case clang::BuiltinType::SveBFloat16x2:\n    case clang::BuiltinType::SveBFloat16x3:\n    case clang::BuiltinType::SveBFloat16x4:\n    case clang::BuiltinType::SveFloat16x2:\n    case clang::BuiltinType::SveFloat16x3:\n    case clang::BuiltinType::SveFloat16x4:\n    case clang::BuiltinType::SveFloat32:\n    case clang::BuiltinType::SveFloat32x2:\n    case clang::BuiltinType::SveFloat32x3:\n    case clang::BuiltinType::SveFloat32x4:\n    case clang::BuiltinType::SveFloat64:\n    case clang::BuiltinType::SveFloat64x2:\n    case clang::BuiltinType::SveFloat64x3:\n    case clang::BuiltinType::SveFloat64x4:\n      break;\n\n    // RISC-V V builtin types.\n    case clang::BuiltinType::RvvInt8mf8:\n    case clang::BuiltinType::RvvInt8mf4:\n    case clang::BuiltinType::RvvInt8mf2:\n    case clang::BuiltinType::RvvInt8m1:\n    case clang::BuiltinType::RvvInt8m2:\n    case clang::BuiltinType::RvvInt8m4:\n    case clang::BuiltinType::RvvInt8m8:\n    case clang::BuiltinType::RvvUint8mf8:\n    case clang::BuiltinType::RvvUint8mf4:\n    case clang::BuiltinType::RvvUint8mf2:\n    case clang::BuiltinType::RvvUint8m1:\n    case clang::BuiltinType::RvvUint8m2:\n    case clang::BuiltinType::RvvUint8m4:\n    case clang::BuiltinType::RvvUint8m8:\n    case clang::BuiltinType::RvvInt16mf4:\n    case clang::BuiltinType::RvvInt16mf2:\n    case clang::BuiltinType::RvvInt16m1:\n    case clang::BuiltinType::RvvInt16m2:\n    case clang::BuiltinType::RvvInt16m4:\n    case clang::BuiltinType::RvvInt16m8:\n    case clang::BuiltinType::RvvUint16mf4:\n    case clang::BuiltinType::RvvUint16mf2:\n    case clang::BuiltinType::RvvUint16m1:\n    case clang::BuiltinType::RvvUint16m2:\n    case clang::BuiltinType::RvvUint16m4:\n    case clang::BuiltinType::RvvUint16m8:\n    case clang::BuiltinType::RvvInt32mf2:\n    case clang::BuiltinType::RvvInt32m1:\n    case clang::BuiltinType::RvvInt32m2:\n    case clang::BuiltinType::RvvInt32m4:\n    case clang::BuiltinType::RvvInt32m8:\n    case clang::BuiltinType::RvvUint32mf2:\n    case clang::BuiltinType::RvvUint32m1:\n    case clang::BuiltinType::RvvUint32m2:\n    case clang::BuiltinType::RvvUint32m4:\n    case clang::BuiltinType::RvvUint32m8:\n    case clang::BuiltinType::RvvInt64m1:\n    case clang::BuiltinType::RvvInt64m2:\n    case clang::BuiltinType::RvvInt64m4:\n    case clang::BuiltinType::RvvInt64m8:\n    case clang::BuiltinType::RvvUint64m1:\n    case clang::BuiltinType::RvvUint64m2:\n    case clang::BuiltinType::RvvUint64m4:\n    case clang::BuiltinType::RvvUint64m8:\n    case clang::BuiltinType::RvvFloat16mf4:\n    case clang::BuiltinType::RvvFloat16mf2:\n    case clang::BuiltinType::RvvFloat16m1:\n    case clang::BuiltinType::RvvFloat16m2:\n    case clang::BuiltinType::RvvFloat16m4:\n    case clang::BuiltinType::RvvFloat16m8:\n    case clang::BuiltinType::RvvFloat32mf2:\n    case clang::BuiltinType::RvvFloat32m1:\n    case clang::BuiltinType::RvvFloat32m2:\n    case clang::BuiltinType::RvvFloat32m4:\n    case clang::BuiltinType::RvvFloat32m8:\n    case clang::BuiltinType::RvvFloat64m1:\n    case clang::BuiltinType::RvvFloat64m2:\n    case clang::BuiltinType::RvvFloat64m4:\n    case clang::BuiltinType::RvvFloat64m8:\n    case clang::BuiltinType::RvvBool1:\n    case clang::BuiltinType::RvvBool2:\n    case clang::BuiltinType::RvvBool4:\n    case clang::BuiltinType::RvvBool8:\n    case clang::BuiltinType::RvvBool16:\n    case clang::BuiltinType::RvvBool32:\n    case clang::BuiltinType::RvvBool64:\n      break;\n\n    case clang::BuiltinType::IncompleteMatrixIdx:\n      break;\n    }\n    break;\n  // All pointer types are represented as unsigned integer encodings. We may\n  // nee to add a eEncodingPointer if we ever need to know the difference\n  case clang::Type::ObjCObjectPointer:\n  case clang::Type::BlockPointer:\n  case clang::Type::Pointer:\n  case clang::Type::LValueReference:\n  case clang::Type::RValueReference:\n  case clang::Type::MemberPointer:\n    return lldb::eEncodingUint;\n  case clang::Type::Complex: {\n    lldb::Encoding encoding = lldb::eEncodingIEEE754;\n    if (qual_type->isComplexType())\n      encoding = lldb::eEncodingIEEE754;\n    else {\n      const clang::ComplexType *complex_type =\n          qual_type->getAsComplexIntegerType();\n      if (complex_type)\n        encoding = GetType(complex_type->getElementType()).GetEncoding(count);\n      else\n        encoding = lldb::eEncodingSint;\n    }\n    count = 2;\n    return encoding;\n  }\n\n  case clang::Type::ObjCInterface:\n    break;\n  case clang::Type::Record:\n    break;\n  case clang::Type::Enum:\n    return lldb::eEncodingSint;\n  case clang::Type::DependentSizedArray:\n  case clang::Type::DependentSizedExtVector:\n  case clang::Type::UnresolvedUsing:\n  case clang::Type::Attributed:\n  case clang::Type::TemplateTypeParm:\n  case clang::Type::SubstTemplateTypeParm:\n  case clang::Type::SubstTemplateTypeParmPack:\n  case clang::Type::InjectedClassName:\n  case clang::Type::DependentName:\n  case clang::Type::DependentTemplateSpecialization:\n  case clang::Type::PackExpansion:\n  case clang::Type::ObjCObject:\n\n  case clang::Type::TemplateSpecialization:\n  case clang::Type::DeducedTemplateSpecialization:\n  case clang::Type::Adjusted:\n  case clang::Type::Pipe:\n    break;\n\n  // pointer type decayed from an array or function type.\n  case clang::Type::Decayed:\n    break;\n  case clang::Type::ObjCTypeParam:\n    break;\n\n  case clang::Type::DependentAddressSpace:\n    break;\n  case clang::Type::MacroQualified:\n    break;\n\n  case clang::Type::ConstantMatrix:\n  case clang::Type::DependentSizedMatrix:\n    break;\n  }\n  count = 0;\n  return lldb::eEncodingInvalid;\n}\n\nlldb::Format TypeSystemClang::GetFormat(lldb::opaque_compiler_type_t type) {\n  if (!type)\n    return lldb::eFormatDefault;\n\n  clang::QualType qual_type = RemoveWrappingTypes(GetCanonicalQualType(type));\n\n  switch (qual_type->getTypeClass()) {\n  case clang::Type::Atomic:\n  case clang::Type::Auto:\n  case clang::Type::Decltype:\n  case clang::Type::Elaborated:\n  case clang::Type::Paren:\n  case clang::Type::Typedef:\n  case clang::Type::TypeOf:\n  case clang::Type::TypeOfExpr:\n    llvm_unreachable(\"Handled in RemoveWrappingTypes!\");\n  case clang::Type::UnaryTransform:\n    break;\n\n  case clang::Type::FunctionNoProto:\n  case clang::Type::FunctionProto:\n    break;\n\n  case clang::Type::IncompleteArray:\n  case clang::Type::VariableArray:\n    break;\n\n  case clang::Type::ConstantArray:\n    return lldb::eFormatVoid; // no value\n\n  case clang::Type::DependentVector:\n  case clang::Type::ExtVector:\n  case clang::Type::Vector:\n    break;\n\n  case clang::Type::ExtInt:\n  case clang::Type::DependentExtInt:\n    return qual_type->isUnsignedIntegerType() ? lldb::eFormatUnsigned\n                                              : lldb::eFormatDecimal;\n\n  case clang::Type::Builtin:\n    switch (llvm::cast<clang::BuiltinType>(qual_type)->getKind()) {\n    case clang::BuiltinType::UnknownAny:\n    case clang::BuiltinType::Void:\n    case clang::BuiltinType::BoundMember:\n      break;\n\n    case clang::BuiltinType::Bool:\n      return lldb::eFormatBoolean;\n    case clang::BuiltinType::Char_S:\n    case clang::BuiltinType::SChar:\n    case clang::BuiltinType::WChar_S:\n    case clang::BuiltinType::Char_U:\n    case clang::BuiltinType::UChar:\n    case clang::BuiltinType::WChar_U:\n      return lldb::eFormatChar;\n    case clang::BuiltinType::Char16:\n      return lldb::eFormatUnicode16;\n    case clang::BuiltinType::Char32:\n      return lldb::eFormatUnicode32;\n    case clang::BuiltinType::UShort:\n      return lldb::eFormatUnsigned;\n    case clang::BuiltinType::Short:\n      return lldb::eFormatDecimal;\n    case clang::BuiltinType::UInt:\n      return lldb::eFormatUnsigned;\n    case clang::BuiltinType::Int:\n      return lldb::eFormatDecimal;\n    case clang::BuiltinType::ULong:\n      return lldb::eFormatUnsigned;\n    case clang::BuiltinType::Long:\n      return lldb::eFormatDecimal;\n    case clang::BuiltinType::ULongLong:\n      return lldb::eFormatUnsigned;\n    case clang::BuiltinType::LongLong:\n      return lldb::eFormatDecimal;\n    case clang::BuiltinType::UInt128:\n      return lldb::eFormatUnsigned;\n    case clang::BuiltinType::Int128:\n      return lldb::eFormatDecimal;\n    case clang::BuiltinType::Half:\n    case clang::BuiltinType::Float:\n    case clang::BuiltinType::Double:\n    case clang::BuiltinType::LongDouble:\n      return lldb::eFormatFloat;\n    default:\n      return lldb::eFormatHex;\n    }\n    break;\n  case clang::Type::ObjCObjectPointer:\n    return lldb::eFormatHex;\n  case clang::Type::BlockPointer:\n    return lldb::eFormatHex;\n  case clang::Type::Pointer:\n    return lldb::eFormatHex;\n  case clang::Type::LValueReference:\n  case clang::Type::RValueReference:\n    return lldb::eFormatHex;\n  case clang::Type::MemberPointer:\n    break;\n  case clang::Type::Complex: {\n    if (qual_type->isComplexType())\n      return lldb::eFormatComplex;\n    else\n      return lldb::eFormatComplexInteger;\n  }\n  case clang::Type::ObjCInterface:\n    break;\n  case clang::Type::Record:\n    break;\n  case clang::Type::Enum:\n    return lldb::eFormatEnum;\n  case clang::Type::DependentSizedArray:\n  case clang::Type::DependentSizedExtVector:\n  case clang::Type::UnresolvedUsing:\n  case clang::Type::Attributed:\n  case clang::Type::TemplateTypeParm:\n  case clang::Type::SubstTemplateTypeParm:\n  case clang::Type::SubstTemplateTypeParmPack:\n  case clang::Type::InjectedClassName:\n  case clang::Type::DependentName:\n  case clang::Type::DependentTemplateSpecialization:\n  case clang::Type::PackExpansion:\n  case clang::Type::ObjCObject:\n\n  case clang::Type::TemplateSpecialization:\n  case clang::Type::DeducedTemplateSpecialization:\n  case clang::Type::Adjusted:\n  case clang::Type::Pipe:\n    break;\n\n  // pointer type decayed from an array or function type.\n  case clang::Type::Decayed:\n    break;\n  case clang::Type::ObjCTypeParam:\n    break;\n\n  case clang::Type::DependentAddressSpace:\n    break;\n  case clang::Type::MacroQualified:\n    break;\n\n  // Matrix types we're not sure how to display yet.\n  case clang::Type::ConstantMatrix:\n  case clang::Type::DependentSizedMatrix:\n    break;\n  }\n  // We don't know hot to display this type...\n  return lldb::eFormatBytes;\n}\n\nstatic bool ObjCDeclHasIVars(clang::ObjCInterfaceDecl *class_interface_decl,\n                             bool check_superclass) {\n  while (class_interface_decl) {\n    if (class_interface_decl->ivar_size() > 0)\n      return true;\n\n    if (check_superclass)\n      class_interface_decl = class_interface_decl->getSuperClass();\n    else\n      break;\n  }\n  return false;\n}\n\nstatic Optional<SymbolFile::ArrayInfo>\nGetDynamicArrayInfo(TypeSystemClang &ast, SymbolFile *sym_file,\n                    clang::QualType qual_type,\n                    const ExecutionContext *exe_ctx) {\n  if (qual_type->isIncompleteArrayType())\n    if (auto *metadata = ast.GetMetadata(qual_type.getTypePtr()))\n      return sym_file->GetDynamicArrayInfoForUID(metadata->GetUserID(),\n                                                 exe_ctx);\n  return llvm::None;\n}\n\nuint32_t TypeSystemClang::GetNumChildren(lldb::opaque_compiler_type_t type,\n                                         bool omit_empty_base_classes,\n                                         const ExecutionContext *exe_ctx) {\n  if (!type)\n    return 0;\n\n  uint32_t num_children = 0;\n  clang::QualType qual_type(RemoveWrappingTypes(GetQualType(type)));\n  const clang::Type::TypeClass type_class = qual_type->getTypeClass();\n  switch (type_class) {\n  case clang::Type::Builtin:\n    switch (llvm::cast<clang::BuiltinType>(qual_type)->getKind()) {\n    case clang::BuiltinType::ObjCId:    // child is Class\n    case clang::BuiltinType::ObjCClass: // child is Class\n      num_children = 1;\n      break;\n\n    default:\n      break;\n    }\n    break;\n\n  case clang::Type::Complex:\n    return 0;\n  case clang::Type::Record:\n    if (GetCompleteQualType(&getASTContext(), qual_type)) {\n      const clang::RecordType *record_type =\n          llvm::cast<clang::RecordType>(qual_type.getTypePtr());\n      const clang::RecordDecl *record_decl = record_type->getDecl();\n      assert(record_decl);\n      const clang::CXXRecordDecl *cxx_record_decl =\n          llvm::dyn_cast<clang::CXXRecordDecl>(record_decl);\n      if (cxx_record_decl) {\n        if (omit_empty_base_classes) {\n          // Check each base classes to see if it or any of its base classes\n          // contain any fields. This can help limit the noise in variable\n          // views by not having to show base classes that contain no members.\n          clang::CXXRecordDecl::base_class_const_iterator base_class,\n              base_class_end;\n          for (base_class = cxx_record_decl->bases_begin(),\n              base_class_end = cxx_record_decl->bases_end();\n               base_class != base_class_end; ++base_class) {\n            const clang::CXXRecordDecl *base_class_decl =\n                llvm::cast<clang::CXXRecordDecl>(\n                    base_class->getType()\n                        ->getAs<clang::RecordType>()\n                        ->getDecl());\n\n            // Skip empty base classes\n            if (!TypeSystemClang::RecordHasFields(base_class_decl))\n              continue;\n\n            num_children++;\n          }\n        } else {\n          // Include all base classes\n          num_children += cxx_record_decl->getNumBases();\n        }\n      }\n      clang::RecordDecl::field_iterator field, field_end;\n      for (field = record_decl->field_begin(),\n          field_end = record_decl->field_end();\n           field != field_end; ++field)\n        ++num_children;\n    }\n    break;\n\n  case clang::Type::ObjCObject:\n  case clang::Type::ObjCInterface:\n    if (GetCompleteQualType(&getASTContext(), qual_type)) {\n      const clang::ObjCObjectType *objc_class_type =\n          llvm::dyn_cast<clang::ObjCObjectType>(qual_type.getTypePtr());\n      assert(objc_class_type);\n      if (objc_class_type) {\n        clang::ObjCInterfaceDecl *class_interface_decl =\n            objc_class_type->getInterface();\n\n        if (class_interface_decl) {\n\n          clang::ObjCInterfaceDecl *superclass_interface_decl =\n              class_interface_decl->getSuperClass();\n          if (superclass_interface_decl) {\n            if (omit_empty_base_classes) {\n              if (ObjCDeclHasIVars(superclass_interface_decl, true))\n                ++num_children;\n            } else\n              ++num_children;\n          }\n\n          num_children += class_interface_decl->ivar_size();\n        }\n      }\n    }\n    break;\n\n  case clang::Type::LValueReference:\n  case clang::Type::RValueReference:\n  case clang::Type::ObjCObjectPointer: {\n    CompilerType pointee_clang_type(GetPointeeType(type));\n\n    uint32_t num_pointee_children = 0;\n    if (pointee_clang_type.IsAggregateType())\n      num_pointee_children =\n          pointee_clang_type.GetNumChildren(omit_empty_base_classes, exe_ctx);\n    // If this type points to a simple type, then it has 1 child\n    if (num_pointee_children == 0)\n      num_children = 1;\n    else\n      num_children = num_pointee_children;\n  } break;\n\n  case clang::Type::Vector:\n  case clang::Type::ExtVector:\n    num_children =\n        llvm::cast<clang::VectorType>(qual_type.getTypePtr())->getNumElements();\n    break;\n\n  case clang::Type::ConstantArray:\n    num_children = llvm::cast<clang::ConstantArrayType>(qual_type.getTypePtr())\n                       ->getSize()\n                       .getLimitedValue();\n    break;\n  case clang::Type::IncompleteArray:\n    if (auto array_info =\n            GetDynamicArrayInfo(*this, GetSymbolFile(), qual_type, exe_ctx))\n      // Only 1-dimensional arrays are supported.\n      num_children = array_info->element_orders.size()\n                         ? array_info->element_orders.back()\n                         : 0;\n    break;\n\n  case clang::Type::Pointer: {\n    const clang::PointerType *pointer_type =\n        llvm::cast<clang::PointerType>(qual_type.getTypePtr());\n    clang::QualType pointee_type(pointer_type->getPointeeType());\n    CompilerType pointee_clang_type(GetType(pointee_type));\n    uint32_t num_pointee_children = 0;\n    if (pointee_clang_type.IsAggregateType())\n      num_pointee_children =\n          pointee_clang_type.GetNumChildren(omit_empty_base_classes, exe_ctx);\n    if (num_pointee_children == 0) {\n      // We have a pointer to a pointee type that claims it has no children. We\n      // will want to look at\n      num_children = GetNumPointeeChildren(pointee_type);\n    } else\n      num_children = num_pointee_children;\n  } break;\n\n  default:\n    break;\n  }\n  return num_children;\n}\n\nCompilerType TypeSystemClang::GetBuiltinTypeByName(ConstString name) {\n  return GetBasicType(GetBasicTypeEnumeration(name));\n}\n\nlldb::BasicType\nTypeSystemClang::GetBasicTypeEnumeration(lldb::opaque_compiler_type_t type) {\n  if (type) {\n    clang::QualType qual_type(GetQualType(type));\n    const clang::Type::TypeClass type_class = qual_type->getTypeClass();\n    if (type_class == clang::Type::Builtin) {\n      switch (llvm::cast<clang::BuiltinType>(qual_type)->getKind()) {\n      case clang::BuiltinType::Void:\n        return eBasicTypeVoid;\n      case clang::BuiltinType::Bool:\n        return eBasicTypeBool;\n      case clang::BuiltinType::Char_S:\n        return eBasicTypeSignedChar;\n      case clang::BuiltinType::Char_U:\n        return eBasicTypeUnsignedChar;\n      case clang::BuiltinType::Char16:\n        return eBasicTypeChar16;\n      case clang::BuiltinType::Char32:\n        return eBasicTypeChar32;\n      case clang::BuiltinType::UChar:\n        return eBasicTypeUnsignedChar;\n      case clang::BuiltinType::SChar:\n        return eBasicTypeSignedChar;\n      case clang::BuiltinType::WChar_S:\n        return eBasicTypeSignedWChar;\n      case clang::BuiltinType::WChar_U:\n        return eBasicTypeUnsignedWChar;\n      case clang::BuiltinType::Short:\n        return eBasicTypeShort;\n      case clang::BuiltinType::UShort:\n        return eBasicTypeUnsignedShort;\n      case clang::BuiltinType::Int:\n        return eBasicTypeInt;\n      case clang::BuiltinType::UInt:\n        return eBasicTypeUnsignedInt;\n      case clang::BuiltinType::Long:\n        return eBasicTypeLong;\n      case clang::BuiltinType::ULong:\n        return eBasicTypeUnsignedLong;\n      case clang::BuiltinType::LongLong:\n        return eBasicTypeLongLong;\n      case clang::BuiltinType::ULongLong:\n        return eBasicTypeUnsignedLongLong;\n      case clang::BuiltinType::Int128:\n        return eBasicTypeInt128;\n      case clang::BuiltinType::UInt128:\n        return eBasicTypeUnsignedInt128;\n\n      case clang::BuiltinType::Half:\n        return eBasicTypeHalf;\n      case clang::BuiltinType::Float:\n        return eBasicTypeFloat;\n      case clang::BuiltinType::Double:\n        return eBasicTypeDouble;\n      case clang::BuiltinType::LongDouble:\n        return eBasicTypeLongDouble;\n\n      case clang::BuiltinType::NullPtr:\n        return eBasicTypeNullPtr;\n      case clang::BuiltinType::ObjCId:\n        return eBasicTypeObjCID;\n      case clang::BuiltinType::ObjCClass:\n        return eBasicTypeObjCClass;\n      case clang::BuiltinType::ObjCSel:\n        return eBasicTypeObjCSel;\n      default:\n        return eBasicTypeOther;\n      }\n    }\n  }\n  return eBasicTypeInvalid;\n}\n\nvoid TypeSystemClang::ForEachEnumerator(\n    lldb::opaque_compiler_type_t type,\n    std::function<bool(const CompilerType &integer_type,\n                       ConstString name,\n                       const llvm::APSInt &value)> const &callback) {\n  const clang::EnumType *enum_type =\n      llvm::dyn_cast<clang::EnumType>(GetCanonicalQualType(type));\n  if (enum_type) {\n    const clang::EnumDecl *enum_decl = enum_type->getDecl();\n    if (enum_decl) {\n      CompilerType integer_type = GetType(enum_decl->getIntegerType());\n\n      clang::EnumDecl::enumerator_iterator enum_pos, enum_end_pos;\n      for (enum_pos = enum_decl->enumerator_begin(),\n          enum_end_pos = enum_decl->enumerator_end();\n           enum_pos != enum_end_pos; ++enum_pos) {\n        ConstString name(enum_pos->getNameAsString().c_str());\n        if (!callback(integer_type, name, enum_pos->getInitVal()))\n          break;\n      }\n    }\n  }\n}\n\n#pragma mark Aggregate Types\n\nuint32_t TypeSystemClang::GetNumFields(lldb::opaque_compiler_type_t type) {\n  if (!type)\n    return 0;\n\n  uint32_t count = 0;\n  clang::QualType qual_type(RemoveWrappingTypes(GetCanonicalQualType(type)));\n  const clang::Type::TypeClass type_class = qual_type->getTypeClass();\n  switch (type_class) {\n  case clang::Type::Record:\n    if (GetCompleteType(type)) {\n      const clang::RecordType *record_type =\n          llvm::dyn_cast<clang::RecordType>(qual_type.getTypePtr());\n      if (record_type) {\n        clang::RecordDecl *record_decl = record_type->getDecl();\n        if (record_decl) {\n          uint32_t field_idx = 0;\n          clang::RecordDecl::field_iterator field, field_end;\n          for (field = record_decl->field_begin(),\n              field_end = record_decl->field_end();\n               field != field_end; ++field)\n            ++field_idx;\n          count = field_idx;\n        }\n      }\n    }\n    break;\n\n  case clang::Type::ObjCObjectPointer: {\n    const clang::ObjCObjectPointerType *objc_class_type =\n        qual_type->getAs<clang::ObjCObjectPointerType>();\n    const clang::ObjCInterfaceType *objc_interface_type =\n        objc_class_type->getInterfaceType();\n    if (objc_interface_type &&\n        GetCompleteType(static_cast<lldb::opaque_compiler_type_t>(\n            const_cast<clang::ObjCInterfaceType *>(objc_interface_type)))) {\n      clang::ObjCInterfaceDecl *class_interface_decl =\n          objc_interface_type->getDecl();\n      if (class_interface_decl) {\n        count = class_interface_decl->ivar_size();\n      }\n    }\n    break;\n  }\n\n  case clang::Type::ObjCObject:\n  case clang::Type::ObjCInterface:\n    if (GetCompleteType(type)) {\n      const clang::ObjCObjectType *objc_class_type =\n          llvm::dyn_cast<clang::ObjCObjectType>(qual_type.getTypePtr());\n      if (objc_class_type) {\n        clang::ObjCInterfaceDecl *class_interface_decl =\n            objc_class_type->getInterface();\n\n        if (class_interface_decl)\n          count = class_interface_decl->ivar_size();\n      }\n    }\n    break;\n\n  default:\n    break;\n  }\n  return count;\n}\n\nstatic lldb::opaque_compiler_type_t\nGetObjCFieldAtIndex(clang::ASTContext *ast,\n                    clang::ObjCInterfaceDecl *class_interface_decl, size_t idx,\n                    std::string &name, uint64_t *bit_offset_ptr,\n                    uint32_t *bitfield_bit_size_ptr, bool *is_bitfield_ptr) {\n  if (class_interface_decl) {\n    if (idx < (class_interface_decl->ivar_size())) {\n      clang::ObjCInterfaceDecl::ivar_iterator ivar_pos,\n          ivar_end = class_interface_decl->ivar_end();\n      uint32_t ivar_idx = 0;\n\n      for (ivar_pos = class_interface_decl->ivar_begin(); ivar_pos != ivar_end;\n           ++ivar_pos, ++ivar_idx) {\n        if (ivar_idx == idx) {\n          const clang::ObjCIvarDecl *ivar_decl = *ivar_pos;\n\n          clang::QualType ivar_qual_type(ivar_decl->getType());\n\n          name.assign(ivar_decl->getNameAsString());\n\n          if (bit_offset_ptr) {\n            const clang::ASTRecordLayout &interface_layout =\n                ast->getASTObjCInterfaceLayout(class_interface_decl);\n            *bit_offset_ptr = interface_layout.getFieldOffset(ivar_idx);\n          }\n\n          const bool is_bitfield = ivar_pos->isBitField();\n\n          if (bitfield_bit_size_ptr) {\n            *bitfield_bit_size_ptr = 0;\n\n            if (is_bitfield && ast) {\n              clang::Expr *bitfield_bit_size_expr = ivar_pos->getBitWidth();\n              clang::Expr::EvalResult result;\n              if (bitfield_bit_size_expr &&\n                  bitfield_bit_size_expr->EvaluateAsInt(result, *ast)) {\n                llvm::APSInt bitfield_apsint = result.Val.getInt();\n                *bitfield_bit_size_ptr = bitfield_apsint.getLimitedValue();\n              }\n            }\n          }\n          if (is_bitfield_ptr)\n            *is_bitfield_ptr = is_bitfield;\n\n          return ivar_qual_type.getAsOpaquePtr();\n        }\n      }\n    }\n  }\n  return nullptr;\n}\n\nCompilerType TypeSystemClang::GetFieldAtIndex(lldb::opaque_compiler_type_t type,\n                                              size_t idx, std::string &name,\n                                              uint64_t *bit_offset_ptr,\n                                              uint32_t *bitfield_bit_size_ptr,\n                                              bool *is_bitfield_ptr) {\n  if (!type)\n    return CompilerType();\n\n  clang::QualType qual_type(RemoveWrappingTypes(GetCanonicalQualType(type)));\n  const clang::Type::TypeClass type_class = qual_type->getTypeClass();\n  switch (type_class) {\n  case clang::Type::Record:\n    if (GetCompleteType(type)) {\n      const clang::RecordType *record_type =\n          llvm::cast<clang::RecordType>(qual_type.getTypePtr());\n      const clang::RecordDecl *record_decl = record_type->getDecl();\n      uint32_t field_idx = 0;\n      clang::RecordDecl::field_iterator field, field_end;\n      for (field = record_decl->field_begin(),\n          field_end = record_decl->field_end();\n           field != field_end; ++field, ++field_idx) {\n        if (idx == field_idx) {\n          // Print the member type if requested\n          // Print the member name and equal sign\n          name.assign(field->getNameAsString());\n\n          // Figure out the type byte size (field_type_info.first) and\n          // alignment (field_type_info.second) from the AST context.\n          if (bit_offset_ptr) {\n            const clang::ASTRecordLayout &record_layout =\n                getASTContext().getASTRecordLayout(record_decl);\n            *bit_offset_ptr = record_layout.getFieldOffset(field_idx);\n          }\n\n          const bool is_bitfield = field->isBitField();\n\n          if (bitfield_bit_size_ptr) {\n            *bitfield_bit_size_ptr = 0;\n\n            if (is_bitfield) {\n              clang::Expr *bitfield_bit_size_expr = field->getBitWidth();\n              clang::Expr::EvalResult result;\n              if (bitfield_bit_size_expr &&\n                  bitfield_bit_size_expr->EvaluateAsInt(result,\n                                                        getASTContext())) {\n                llvm::APSInt bitfield_apsint = result.Val.getInt();\n                *bitfield_bit_size_ptr = bitfield_apsint.getLimitedValue();\n              }\n            }\n          }\n          if (is_bitfield_ptr)\n            *is_bitfield_ptr = is_bitfield;\n\n          return GetType(field->getType());\n        }\n      }\n    }\n    break;\n\n  case clang::Type::ObjCObjectPointer: {\n    const clang::ObjCObjectPointerType *objc_class_type =\n        qual_type->getAs<clang::ObjCObjectPointerType>();\n    const clang::ObjCInterfaceType *objc_interface_type =\n        objc_class_type->getInterfaceType();\n    if (objc_interface_type &&\n        GetCompleteType(static_cast<lldb::opaque_compiler_type_t>(\n            const_cast<clang::ObjCInterfaceType *>(objc_interface_type)))) {\n      clang::ObjCInterfaceDecl *class_interface_decl =\n          objc_interface_type->getDecl();\n      if (class_interface_decl) {\n        return CompilerType(\n            this, GetObjCFieldAtIndex(&getASTContext(), class_interface_decl,\n                                      idx, name, bit_offset_ptr,\n                                      bitfield_bit_size_ptr, is_bitfield_ptr));\n      }\n    }\n    break;\n  }\n\n  case clang::Type::ObjCObject:\n  case clang::Type::ObjCInterface:\n    if (GetCompleteType(type)) {\n      const clang::ObjCObjectType *objc_class_type =\n          llvm::dyn_cast<clang::ObjCObjectType>(qual_type.getTypePtr());\n      assert(objc_class_type);\n      if (objc_class_type) {\n        clang::ObjCInterfaceDecl *class_interface_decl =\n            objc_class_type->getInterface();\n        return CompilerType(\n            this, GetObjCFieldAtIndex(&getASTContext(), class_interface_decl,\n                                      idx, name, bit_offset_ptr,\n                                      bitfield_bit_size_ptr, is_bitfield_ptr));\n      }\n    }\n    break;\n\n  default:\n    break;\n  }\n  return CompilerType();\n}\n\nuint32_t\nTypeSystemClang::GetNumDirectBaseClasses(lldb::opaque_compiler_type_t type) {\n  uint32_t count = 0;\n  clang::QualType qual_type = RemoveWrappingTypes(GetCanonicalQualType(type));\n  const clang::Type::TypeClass type_class = qual_type->getTypeClass();\n  switch (type_class) {\n  case clang::Type::Record:\n    if (GetCompleteType(type)) {\n      const clang::CXXRecordDecl *cxx_record_decl =\n          qual_type->getAsCXXRecordDecl();\n      if (cxx_record_decl)\n        count = cxx_record_decl->getNumBases();\n    }\n    break;\n\n  case clang::Type::ObjCObjectPointer:\n    count = GetPointeeType(type).GetNumDirectBaseClasses();\n    break;\n\n  case clang::Type::ObjCObject:\n    if (GetCompleteType(type)) {\n      const clang::ObjCObjectType *objc_class_type =\n          qual_type->getAsObjCQualifiedInterfaceType();\n      if (objc_class_type) {\n        clang::ObjCInterfaceDecl *class_interface_decl =\n            objc_class_type->getInterface();\n\n        if (class_interface_decl && class_interface_decl->getSuperClass())\n          count = 1;\n      }\n    }\n    break;\n  case clang::Type::ObjCInterface:\n    if (GetCompleteType(type)) {\n      const clang::ObjCInterfaceType *objc_interface_type =\n          qual_type->getAs<clang::ObjCInterfaceType>();\n      if (objc_interface_type) {\n        clang::ObjCInterfaceDecl *class_interface_decl =\n            objc_interface_type->getInterface();\n\n        if (class_interface_decl && class_interface_decl->getSuperClass())\n          count = 1;\n      }\n    }\n    break;\n\n  default:\n    break;\n  }\n  return count;\n}\n\nuint32_t\nTypeSystemClang::GetNumVirtualBaseClasses(lldb::opaque_compiler_type_t type) {\n  uint32_t count = 0;\n  clang::QualType qual_type = RemoveWrappingTypes(GetCanonicalQualType(type));\n  const clang::Type::TypeClass type_class = qual_type->getTypeClass();\n  switch (type_class) {\n  case clang::Type::Record:\n    if (GetCompleteType(type)) {\n      const clang::CXXRecordDecl *cxx_record_decl =\n          qual_type->getAsCXXRecordDecl();\n      if (cxx_record_decl)\n        count = cxx_record_decl->getNumVBases();\n    }\n    break;\n\n  default:\n    break;\n  }\n  return count;\n}\n\nCompilerType TypeSystemClang::GetDirectBaseClassAtIndex(\n    lldb::opaque_compiler_type_t type, size_t idx, uint32_t *bit_offset_ptr) {\n  clang::QualType qual_type = RemoveWrappingTypes(GetCanonicalQualType(type));\n  const clang::Type::TypeClass type_class = qual_type->getTypeClass();\n  switch (type_class) {\n  case clang::Type::Record:\n    if (GetCompleteType(type)) {\n      const clang::CXXRecordDecl *cxx_record_decl =\n          qual_type->getAsCXXRecordDecl();\n      if (cxx_record_decl) {\n        uint32_t curr_idx = 0;\n        clang::CXXRecordDecl::base_class_const_iterator base_class,\n            base_class_end;\n        for (base_class = cxx_record_decl->bases_begin(),\n            base_class_end = cxx_record_decl->bases_end();\n             base_class != base_class_end; ++base_class, ++curr_idx) {\n          if (curr_idx == idx) {\n            if (bit_offset_ptr) {\n              const clang::ASTRecordLayout &record_layout =\n                  getASTContext().getASTRecordLayout(cxx_record_decl);\n              const clang::CXXRecordDecl *base_class_decl =\n                  llvm::cast<clang::CXXRecordDecl>(\n                      base_class->getType()\n                          ->getAs<clang::RecordType>()\n                          ->getDecl());\n              if (base_class->isVirtual())\n                *bit_offset_ptr =\n                    record_layout.getVBaseClassOffset(base_class_decl)\n                        .getQuantity() *\n                    8;\n              else\n                *bit_offset_ptr =\n                    record_layout.getBaseClassOffset(base_class_decl)\n                        .getQuantity() *\n                    8;\n            }\n            return GetType(base_class->getType());\n          }\n        }\n      }\n    }\n    break;\n\n  case clang::Type::ObjCObjectPointer:\n    return GetPointeeType(type).GetDirectBaseClassAtIndex(idx, bit_offset_ptr);\n\n  case clang::Type::ObjCObject:\n    if (idx == 0 && GetCompleteType(type)) {\n      const clang::ObjCObjectType *objc_class_type =\n          qual_type->getAsObjCQualifiedInterfaceType();\n      if (objc_class_type) {\n        clang::ObjCInterfaceDecl *class_interface_decl =\n            objc_class_type->getInterface();\n\n        if (class_interface_decl) {\n          clang::ObjCInterfaceDecl *superclass_interface_decl =\n              class_interface_decl->getSuperClass();\n          if (superclass_interface_decl) {\n            if (bit_offset_ptr)\n              *bit_offset_ptr = 0;\n            return GetType(getASTContext().getObjCInterfaceType(\n                superclass_interface_decl));\n          }\n        }\n      }\n    }\n    break;\n  case clang::Type::ObjCInterface:\n    if (idx == 0 && GetCompleteType(type)) {\n      const clang::ObjCObjectType *objc_interface_type =\n          qual_type->getAs<clang::ObjCInterfaceType>();\n      if (objc_interface_type) {\n        clang::ObjCInterfaceDecl *class_interface_decl =\n            objc_interface_type->getInterface();\n\n        if (class_interface_decl) {\n          clang::ObjCInterfaceDecl *superclass_interface_decl =\n              class_interface_decl->getSuperClass();\n          if (superclass_interface_decl) {\n            if (bit_offset_ptr)\n              *bit_offset_ptr = 0;\n            return GetType(getASTContext().getObjCInterfaceType(\n                superclass_interface_decl));\n          }\n        }\n      }\n    }\n    break;\n\n  default:\n    break;\n  }\n  return CompilerType();\n}\n\nCompilerType TypeSystemClang::GetVirtualBaseClassAtIndex(\n    lldb::opaque_compiler_type_t type, size_t idx, uint32_t *bit_offset_ptr) {\n  clang::QualType qual_type = RemoveWrappingTypes(GetCanonicalQualType(type));\n  const clang::Type::TypeClass type_class = qual_type->getTypeClass();\n  switch (type_class) {\n  case clang::Type::Record:\n    if (GetCompleteType(type)) {\n      const clang::CXXRecordDecl *cxx_record_decl =\n          qual_type->getAsCXXRecordDecl();\n      if (cxx_record_decl) {\n        uint32_t curr_idx = 0;\n        clang::CXXRecordDecl::base_class_const_iterator base_class,\n            base_class_end;\n        for (base_class = cxx_record_decl->vbases_begin(),\n            base_class_end = cxx_record_decl->vbases_end();\n             base_class != base_class_end; ++base_class, ++curr_idx) {\n          if (curr_idx == idx) {\n            if (bit_offset_ptr) {\n              const clang::ASTRecordLayout &record_layout =\n                  getASTContext().getASTRecordLayout(cxx_record_decl);\n              const clang::CXXRecordDecl *base_class_decl =\n                  llvm::cast<clang::CXXRecordDecl>(\n                      base_class->getType()\n                          ->getAs<clang::RecordType>()\n                          ->getDecl());\n              *bit_offset_ptr =\n                  record_layout.getVBaseClassOffset(base_class_decl)\n                      .getQuantity() *\n                  8;\n            }\n            return GetType(base_class->getType());\n          }\n        }\n      }\n    }\n    break;\n\n  default:\n    break;\n  }\n  return CompilerType();\n}\n\n// If a pointer to a pointee type (the clang_type arg) says that it has no\n// children, then we either need to trust it, or override it and return a\n// different result. For example, an \"int *\" has one child that is an integer,\n// but a function pointer doesn't have any children. Likewise if a Record type\n// claims it has no children, then there really is nothing to show.\nuint32_t TypeSystemClang::GetNumPointeeChildren(clang::QualType type) {\n  if (type.isNull())\n    return 0;\n\n  clang::QualType qual_type = RemoveWrappingTypes(type.getCanonicalType());\n  const clang::Type::TypeClass type_class = qual_type->getTypeClass();\n  switch (type_class) {\n  case clang::Type::Builtin:\n    switch (llvm::cast<clang::BuiltinType>(qual_type)->getKind()) {\n    case clang::BuiltinType::UnknownAny:\n    case clang::BuiltinType::Void:\n    case clang::BuiltinType::NullPtr:\n    case clang::BuiltinType::OCLEvent:\n    case clang::BuiltinType::OCLImage1dRO:\n    case clang::BuiltinType::OCLImage1dWO:\n    case clang::BuiltinType::OCLImage1dRW:\n    case clang::BuiltinType::OCLImage1dArrayRO:\n    case clang::BuiltinType::OCLImage1dArrayWO:\n    case clang::BuiltinType::OCLImage1dArrayRW:\n    case clang::BuiltinType::OCLImage1dBufferRO:\n    case clang::BuiltinType::OCLImage1dBufferWO:\n    case clang::BuiltinType::OCLImage1dBufferRW:\n    case clang::BuiltinType::OCLImage2dRO:\n    case clang::BuiltinType::OCLImage2dWO:\n    case clang::BuiltinType::OCLImage2dRW:\n    case clang::BuiltinType::OCLImage2dArrayRO:\n    case clang::BuiltinType::OCLImage2dArrayWO:\n    case clang::BuiltinType::OCLImage2dArrayRW:\n    case clang::BuiltinType::OCLImage3dRO:\n    case clang::BuiltinType::OCLImage3dWO:\n    case clang::BuiltinType::OCLImage3dRW:\n    case clang::BuiltinType::OCLSampler:\n      return 0;\n    case clang::BuiltinType::Bool:\n    case clang::BuiltinType::Char_U:\n    case clang::BuiltinType::UChar:\n    case clang::BuiltinType::WChar_U:\n    case clang::BuiltinType::Char16:\n    case clang::BuiltinType::Char32:\n    case clang::BuiltinType::UShort:\n    case clang::BuiltinType::UInt:\n    case clang::BuiltinType::ULong:\n    case clang::BuiltinType::ULongLong:\n    case clang::BuiltinType::UInt128:\n    case clang::BuiltinType::Char_S:\n    case clang::BuiltinType::SChar:\n    case clang::BuiltinType::WChar_S:\n    case clang::BuiltinType::Short:\n    case clang::BuiltinType::Int:\n    case clang::BuiltinType::Long:\n    case clang::BuiltinType::LongLong:\n    case clang::BuiltinType::Int128:\n    case clang::BuiltinType::Float:\n    case clang::BuiltinType::Double:\n    case clang::BuiltinType::LongDouble:\n    case clang::BuiltinType::Dependent:\n    case clang::BuiltinType::Overload:\n    case clang::BuiltinType::ObjCId:\n    case clang::BuiltinType::ObjCClass:\n    case clang::BuiltinType::ObjCSel:\n    case clang::BuiltinType::BoundMember:\n    case clang::BuiltinType::Half:\n    case clang::BuiltinType::ARCUnbridgedCast:\n    case clang::BuiltinType::PseudoObject:\n    case clang::BuiltinType::BuiltinFn:\n    case clang::BuiltinType::OMPArraySection:\n      return 1;\n    default:\n      return 0;\n    }\n    break;\n\n  case clang::Type::Complex:\n    return 1;\n  case clang::Type::Pointer:\n    return 1;\n  case clang::Type::BlockPointer:\n    return 0; // If block pointers don't have debug info, then no children for\n              // them\n  case clang::Type::LValueReference:\n    return 1;\n  case clang::Type::RValueReference:\n    return 1;\n  case clang::Type::MemberPointer:\n    return 0;\n  case clang::Type::ConstantArray:\n    return 0;\n  case clang::Type::IncompleteArray:\n    return 0;\n  case clang::Type::VariableArray:\n    return 0;\n  case clang::Type::DependentSizedArray:\n    return 0;\n  case clang::Type::DependentSizedExtVector:\n    return 0;\n  case clang::Type::Vector:\n    return 0;\n  case clang::Type::ExtVector:\n    return 0;\n  case clang::Type::FunctionProto:\n    return 0; // When we function pointers, they have no children...\n  case clang::Type::FunctionNoProto:\n    return 0; // When we function pointers, they have no children...\n  case clang::Type::UnresolvedUsing:\n    return 0;\n  case clang::Type::Record:\n    return 0;\n  case clang::Type::Enum:\n    return 1;\n  case clang::Type::TemplateTypeParm:\n    return 1;\n  case clang::Type::SubstTemplateTypeParm:\n    return 1;\n  case clang::Type::TemplateSpecialization:\n    return 1;\n  case clang::Type::InjectedClassName:\n    return 0;\n  case clang::Type::DependentName:\n    return 1;\n  case clang::Type::DependentTemplateSpecialization:\n    return 1;\n  case clang::Type::ObjCObject:\n    return 0;\n  case clang::Type::ObjCInterface:\n    return 0;\n  case clang::Type::ObjCObjectPointer:\n    return 1;\n  default:\n    break;\n  }\n  return 0;\n}\n\nCompilerType TypeSystemClang::GetChildCompilerTypeAtIndex(\n    lldb::opaque_compiler_type_t type, ExecutionContext *exe_ctx, size_t idx,\n    bool transparent_pointers, bool omit_empty_base_classes,\n    bool ignore_array_bounds, std::string &child_name,\n    uint32_t &child_byte_size, int32_t &child_byte_offset,\n    uint32_t &child_bitfield_bit_size, uint32_t &child_bitfield_bit_offset,\n    bool &child_is_base_class, bool &child_is_deref_of_parent,\n    ValueObject *valobj, uint64_t &language_flags) {\n  if (!type)\n    return CompilerType();\n\n  auto get_exe_scope = [&exe_ctx]() {\n    return exe_ctx ? exe_ctx->GetBestExecutionContextScope() : nullptr;\n  };\n\n  clang::QualType parent_qual_type(\n      RemoveWrappingTypes(GetCanonicalQualType(type)));\n  const clang::Type::TypeClass parent_type_class =\n      parent_qual_type->getTypeClass();\n  child_bitfield_bit_size = 0;\n  child_bitfield_bit_offset = 0;\n  child_is_base_class = false;\n  language_flags = 0;\n\n  const bool idx_is_valid =\n      idx < GetNumChildren(type, omit_empty_base_classes, exe_ctx);\n  int32_t bit_offset;\n  switch (parent_type_class) {\n  case clang::Type::Builtin:\n    if (idx_is_valid) {\n      switch (llvm::cast<clang::BuiltinType>(parent_qual_type)->getKind()) {\n      case clang::BuiltinType::ObjCId:\n      case clang::BuiltinType::ObjCClass:\n        child_name = \"isa\";\n        child_byte_size =\n            getASTContext().getTypeSize(getASTContext().ObjCBuiltinClassTy) /\n            CHAR_BIT;\n        return GetType(getASTContext().ObjCBuiltinClassTy);\n\n      default:\n        break;\n      }\n    }\n    break;\n\n  case clang::Type::Record:\n    if (idx_is_valid && GetCompleteType(type)) {\n      const clang::RecordType *record_type =\n          llvm::cast<clang::RecordType>(parent_qual_type.getTypePtr());\n      const clang::RecordDecl *record_decl = record_type->getDecl();\n      assert(record_decl);\n      const clang::ASTRecordLayout &record_layout =\n          getASTContext().getASTRecordLayout(record_decl);\n      uint32_t child_idx = 0;\n\n      const clang::CXXRecordDecl *cxx_record_decl =\n          llvm::dyn_cast<clang::CXXRecordDecl>(record_decl);\n      if (cxx_record_decl) {\n        // We might have base classes to print out first\n        clang::CXXRecordDecl::base_class_const_iterator base_class,\n            base_class_end;\n        for (base_class = cxx_record_decl->bases_begin(),\n            base_class_end = cxx_record_decl->bases_end();\n             base_class != base_class_end; ++base_class) {\n          const clang::CXXRecordDecl *base_class_decl = nullptr;\n\n          // Skip empty base classes\n          if (omit_empty_base_classes) {\n            base_class_decl = llvm::cast<clang::CXXRecordDecl>(\n                base_class->getType()->getAs<clang::RecordType>()->getDecl());\n            if (!TypeSystemClang::RecordHasFields(base_class_decl))\n              continue;\n          }\n\n          if (idx == child_idx) {\n            if (base_class_decl == nullptr)\n              base_class_decl = llvm::cast<clang::CXXRecordDecl>(\n                  base_class->getType()->getAs<clang::RecordType>()->getDecl());\n\n            if (base_class->isVirtual()) {\n              bool handled = false;\n              if (valobj) {\n                clang::VTableContextBase *vtable_ctx =\n                    getASTContext().getVTableContext();\n                if (vtable_ctx)\n                  handled = GetVBaseBitOffset(*vtable_ctx, *valobj,\n                                              record_layout, cxx_record_decl,\n                                              base_class_decl, bit_offset);\n              }\n              if (!handled)\n                bit_offset = record_layout.getVBaseClassOffset(base_class_decl)\n                                 .getQuantity() *\n                             8;\n            } else\n              bit_offset = record_layout.getBaseClassOffset(base_class_decl)\n                               .getQuantity() *\n                           8;\n\n            // Base classes should be a multiple of 8 bits in size\n            child_byte_offset = bit_offset / 8;\n            CompilerType base_class_clang_type = GetType(base_class->getType());\n            child_name = base_class_clang_type.GetTypeName().AsCString(\"\");\n            Optional<uint64_t> size =\n                base_class_clang_type.GetBitSize(get_exe_scope());\n            if (!size)\n              return {};\n            uint64_t base_class_clang_type_bit_size = *size;\n\n            // Base classes bit sizes should be a multiple of 8 bits in size\n            assert(base_class_clang_type_bit_size % 8 == 0);\n            child_byte_size = base_class_clang_type_bit_size / 8;\n            child_is_base_class = true;\n            return base_class_clang_type;\n          }\n          // We don't increment the child index in the for loop since we might\n          // be skipping empty base classes\n          ++child_idx;\n        }\n      }\n      // Make sure index is in range...\n      uint32_t field_idx = 0;\n      clang::RecordDecl::field_iterator field, field_end;\n      for (field = record_decl->field_begin(),\n          field_end = record_decl->field_end();\n           field != field_end; ++field, ++field_idx, ++child_idx) {\n        if (idx == child_idx) {\n          // Print the member type if requested\n          // Print the member name and equal sign\n          child_name.assign(field->getNameAsString());\n\n          // Figure out the type byte size (field_type_info.first) and\n          // alignment (field_type_info.second) from the AST context.\n          CompilerType field_clang_type = GetType(field->getType());\n          assert(field_idx < record_layout.getFieldCount());\n          Optional<uint64_t> size =\n              field_clang_type.GetByteSize(get_exe_scope());\n          if (!size)\n            return {};\n          child_byte_size = *size;\n          const uint32_t child_bit_size = child_byte_size * 8;\n\n          // Figure out the field offset within the current struct/union/class\n          // type\n          bit_offset = record_layout.getFieldOffset(field_idx);\n          if (FieldIsBitfield(*field, child_bitfield_bit_size)) {\n            child_bitfield_bit_offset = bit_offset % child_bit_size;\n            const uint32_t child_bit_offset =\n                bit_offset - child_bitfield_bit_offset;\n            child_byte_offset = child_bit_offset / 8;\n          } else {\n            child_byte_offset = bit_offset / 8;\n          }\n\n          return field_clang_type;\n        }\n      }\n    }\n    break;\n\n  case clang::Type::ObjCObject:\n  case clang::Type::ObjCInterface:\n    if (idx_is_valid && GetCompleteType(type)) {\n      const clang::ObjCObjectType *objc_class_type =\n          llvm::dyn_cast<clang::ObjCObjectType>(parent_qual_type.getTypePtr());\n      assert(objc_class_type);\n      if (objc_class_type) {\n        uint32_t child_idx = 0;\n        clang::ObjCInterfaceDecl *class_interface_decl =\n            objc_class_type->getInterface();\n\n        if (class_interface_decl) {\n\n          const clang::ASTRecordLayout &interface_layout =\n              getASTContext().getASTObjCInterfaceLayout(class_interface_decl);\n          clang::ObjCInterfaceDecl *superclass_interface_decl =\n              class_interface_decl->getSuperClass();\n          if (superclass_interface_decl) {\n            if (omit_empty_base_classes) {\n              CompilerType base_class_clang_type =\n                  GetType(getASTContext().getObjCInterfaceType(\n                      superclass_interface_decl));\n              if (base_class_clang_type.GetNumChildren(omit_empty_base_classes,\n                                                       exe_ctx) > 0) {\n                if (idx == 0) {\n                  clang::QualType ivar_qual_type(\n                      getASTContext().getObjCInterfaceType(\n                          superclass_interface_decl));\n\n                  child_name.assign(\n                      superclass_interface_decl->getNameAsString());\n\n                  clang::TypeInfo ivar_type_info =\n                      getASTContext().getTypeInfo(ivar_qual_type.getTypePtr());\n\n                  child_byte_size = ivar_type_info.Width / 8;\n                  child_byte_offset = 0;\n                  child_is_base_class = true;\n\n                  return GetType(ivar_qual_type);\n                }\n\n                ++child_idx;\n              }\n            } else\n              ++child_idx;\n          }\n\n          const uint32_t superclass_idx = child_idx;\n\n          if (idx < (child_idx + class_interface_decl->ivar_size())) {\n            clang::ObjCInterfaceDecl::ivar_iterator ivar_pos,\n                ivar_end = class_interface_decl->ivar_end();\n\n            for (ivar_pos = class_interface_decl->ivar_begin();\n                 ivar_pos != ivar_end; ++ivar_pos) {\n              if (child_idx == idx) {\n                clang::ObjCIvarDecl *ivar_decl = *ivar_pos;\n\n                clang::QualType ivar_qual_type(ivar_decl->getType());\n\n                child_name.assign(ivar_decl->getNameAsString());\n\n                clang::TypeInfo ivar_type_info =\n                    getASTContext().getTypeInfo(ivar_qual_type.getTypePtr());\n\n                child_byte_size = ivar_type_info.Width / 8;\n\n                // Figure out the field offset within the current\n                // struct/union/class type For ObjC objects, we can't trust the\n                // bit offset we get from the Clang AST, since that doesn't\n                // account for the space taken up by unbacked properties, or\n                // from the changing size of base classes that are newer than\n                // this class. So if we have a process around that we can ask\n                // about this object, do so.\n                child_byte_offset = LLDB_INVALID_IVAR_OFFSET;\n                Process *process = nullptr;\n                if (exe_ctx)\n                  process = exe_ctx->GetProcessPtr();\n                if (process) {\n                  ObjCLanguageRuntime *objc_runtime =\n                      ObjCLanguageRuntime::Get(*process);\n                  if (objc_runtime != nullptr) {\n                    CompilerType parent_ast_type = GetType(parent_qual_type);\n                    child_byte_offset = objc_runtime->GetByteOffsetForIvar(\n                        parent_ast_type, ivar_decl->getNameAsString().c_str());\n                  }\n                }\n\n                // Setting this to INT32_MAX to make sure we don't compute it\n                // twice...\n                bit_offset = INT32_MAX;\n\n                if (child_byte_offset ==\n                    static_cast<int32_t>(LLDB_INVALID_IVAR_OFFSET)) {\n                  bit_offset = interface_layout.getFieldOffset(child_idx -\n                                                               superclass_idx);\n                  child_byte_offset = bit_offset / 8;\n                }\n\n                // Note, the ObjC Ivar Byte offset is just that, it doesn't\n                // account for the bit offset of a bitfield within its\n                // containing object.  So regardless of where we get the byte\n                // offset from, we still need to get the bit offset for\n                // bitfields from the layout.\n\n                if (FieldIsBitfield(ivar_decl, child_bitfield_bit_size)) {\n                  if (bit_offset == INT32_MAX)\n                    bit_offset = interface_layout.getFieldOffset(\n                        child_idx - superclass_idx);\n\n                  child_bitfield_bit_offset = bit_offset % 8;\n                }\n                return GetType(ivar_qual_type);\n              }\n              ++child_idx;\n            }\n          }\n        }\n      }\n    }\n    break;\n\n  case clang::Type::ObjCObjectPointer:\n    if (idx_is_valid) {\n      CompilerType pointee_clang_type(GetPointeeType(type));\n\n      if (transparent_pointers && pointee_clang_type.IsAggregateType()) {\n        child_is_deref_of_parent = false;\n        bool tmp_child_is_deref_of_parent = false;\n        return pointee_clang_type.GetChildCompilerTypeAtIndex(\n            exe_ctx, idx, transparent_pointers, omit_empty_base_classes,\n            ignore_array_bounds, child_name, child_byte_size, child_byte_offset,\n            child_bitfield_bit_size, child_bitfield_bit_offset,\n            child_is_base_class, tmp_child_is_deref_of_parent, valobj,\n            language_flags);\n      } else {\n        child_is_deref_of_parent = true;\n        const char *parent_name =\n            valobj ? valobj->GetName().GetCString() : nullptr;\n        if (parent_name) {\n          child_name.assign(1, '*');\n          child_name += parent_name;\n        }\n\n        // We have a pointer to an simple type\n        if (idx == 0 && pointee_clang_type.GetCompleteType()) {\n          if (Optional<uint64_t> size =\n                  pointee_clang_type.GetByteSize(get_exe_scope())) {\n            child_byte_size = *size;\n            child_byte_offset = 0;\n            return pointee_clang_type;\n          }\n        }\n      }\n    }\n    break;\n\n  case clang::Type::Vector:\n  case clang::Type::ExtVector:\n    if (idx_is_valid) {\n      const clang::VectorType *array =\n          llvm::cast<clang::VectorType>(parent_qual_type.getTypePtr());\n      if (array) {\n        CompilerType element_type = GetType(array->getElementType());\n        if (element_type.GetCompleteType()) {\n          char element_name[64];\n          ::snprintf(element_name, sizeof(element_name), \"[%\" PRIu64 \"]\",\n                     static_cast<uint64_t>(idx));\n          child_name.assign(element_name);\n          if (Optional<uint64_t> size =\n                  element_type.GetByteSize(get_exe_scope())) {\n            child_byte_size = *size;\n            child_byte_offset = (int32_t)idx * (int32_t)child_byte_size;\n            return element_type;\n          }\n        }\n      }\n    }\n    break;\n\n  case clang::Type::ConstantArray:\n  case clang::Type::IncompleteArray:\n    if (ignore_array_bounds || idx_is_valid) {\n      const clang::ArrayType *array = GetQualType(type)->getAsArrayTypeUnsafe();\n      if (array) {\n        CompilerType element_type = GetType(array->getElementType());\n        if (element_type.GetCompleteType()) {\n          child_name = std::string(llvm::formatv(\"[{0}]\", idx));\n          if (Optional<uint64_t> size =\n                  element_type.GetByteSize(get_exe_scope())) {\n            child_byte_size = *size;\n            child_byte_offset = (int32_t)idx * (int32_t)child_byte_size;\n            return element_type;\n          }\n        }\n      }\n    }\n    break;\n\n  case clang::Type::Pointer: {\n    CompilerType pointee_clang_type(GetPointeeType(type));\n\n    // Don't dereference \"void *\" pointers\n    if (pointee_clang_type.IsVoidType())\n      return CompilerType();\n\n    if (transparent_pointers && pointee_clang_type.IsAggregateType()) {\n      child_is_deref_of_parent = false;\n      bool tmp_child_is_deref_of_parent = false;\n      return pointee_clang_type.GetChildCompilerTypeAtIndex(\n          exe_ctx, idx, transparent_pointers, omit_empty_base_classes,\n          ignore_array_bounds, child_name, child_byte_size, child_byte_offset,\n          child_bitfield_bit_size, child_bitfield_bit_offset,\n          child_is_base_class, tmp_child_is_deref_of_parent, valobj,\n          language_flags);\n    } else {\n      child_is_deref_of_parent = true;\n\n      const char *parent_name =\n          valobj ? valobj->GetName().GetCString() : nullptr;\n      if (parent_name) {\n        child_name.assign(1, '*');\n        child_name += parent_name;\n      }\n\n      // We have a pointer to an simple type\n      if (idx == 0) {\n        if (Optional<uint64_t> size =\n                pointee_clang_type.GetByteSize(get_exe_scope())) {\n          child_byte_size = *size;\n          child_byte_offset = 0;\n          return pointee_clang_type;\n        }\n      }\n    }\n    break;\n  }\n\n  case clang::Type::LValueReference:\n  case clang::Type::RValueReference:\n    if (idx_is_valid) {\n      const clang::ReferenceType *reference_type =\n          llvm::cast<clang::ReferenceType>(parent_qual_type.getTypePtr());\n      CompilerType pointee_clang_type =\n          GetType(reference_type->getPointeeType());\n      if (transparent_pointers && pointee_clang_type.IsAggregateType()) {\n        child_is_deref_of_parent = false;\n        bool tmp_child_is_deref_of_parent = false;\n        return pointee_clang_type.GetChildCompilerTypeAtIndex(\n            exe_ctx, idx, transparent_pointers, omit_empty_base_classes,\n            ignore_array_bounds, child_name, child_byte_size, child_byte_offset,\n            child_bitfield_bit_size, child_bitfield_bit_offset,\n            child_is_base_class, tmp_child_is_deref_of_parent, valobj,\n            language_flags);\n      } else {\n        const char *parent_name =\n            valobj ? valobj->GetName().GetCString() : nullptr;\n        if (parent_name) {\n          child_name.assign(1, '&');\n          child_name += parent_name;\n        }\n\n        // We have a pointer to an simple type\n        if (idx == 0) {\n          if (Optional<uint64_t> size =\n                  pointee_clang_type.GetByteSize(get_exe_scope())) {\n            child_byte_size = *size;\n            child_byte_offset = 0;\n            return pointee_clang_type;\n          }\n        }\n      }\n    }\n    break;\n\n  default:\n    break;\n  }\n  return CompilerType();\n}\n\nstatic uint32_t GetIndexForRecordBase(const clang::RecordDecl *record_decl,\n                                      const clang::CXXBaseSpecifier *base_spec,\n                                      bool omit_empty_base_classes) {\n  uint32_t child_idx = 0;\n\n  const clang::CXXRecordDecl *cxx_record_decl =\n      llvm::dyn_cast<clang::CXXRecordDecl>(record_decl);\n\n  if (cxx_record_decl) {\n    clang::CXXRecordDecl::base_class_const_iterator base_class, base_class_end;\n    for (base_class = cxx_record_decl->bases_begin(),\n        base_class_end = cxx_record_decl->bases_end();\n         base_class != base_class_end; ++base_class) {\n      if (omit_empty_base_classes) {\n        if (BaseSpecifierIsEmpty(base_class))\n          continue;\n      }\n\n      if (base_class == base_spec)\n        return child_idx;\n      ++child_idx;\n    }\n  }\n\n  return UINT32_MAX;\n}\n\nstatic uint32_t GetIndexForRecordChild(const clang::RecordDecl *record_decl,\n                                       clang::NamedDecl *canonical_decl,\n                                       bool omit_empty_base_classes) {\n  uint32_t child_idx = TypeSystemClang::GetNumBaseClasses(\n      llvm::dyn_cast<clang::CXXRecordDecl>(record_decl),\n      omit_empty_base_classes);\n\n  clang::RecordDecl::field_iterator field, field_end;\n  for (field = record_decl->field_begin(), field_end = record_decl->field_end();\n       field != field_end; ++field, ++child_idx) {\n    if (field->getCanonicalDecl() == canonical_decl)\n      return child_idx;\n  }\n\n  return UINT32_MAX;\n}\n\n// Look for a child member (doesn't include base classes, but it does include\n// their members) in the type hierarchy. Returns an index path into\n// \"clang_type\" on how to reach the appropriate member.\n//\n//    class A\n//    {\n//    public:\n//        int m_a;\n//        int m_b;\n//    };\n//\n//    class B\n//    {\n//    };\n//\n//    class C :\n//        public B,\n//        public A\n//    {\n//    };\n//\n// If we have a clang type that describes \"class C\", and we wanted to looked\n// \"m_b\" in it:\n//\n// With omit_empty_base_classes == false we would get an integer array back\n// with: { 1,  1 } The first index 1 is the child index for \"class A\" within\n// class C The second index 1 is the child index for \"m_b\" within class A\n//\n// With omit_empty_base_classes == true we would get an integer array back\n// with: { 0,  1 } The first index 0 is the child index for \"class A\" within\n// class C (since class B doesn't have any members it doesn't count) The second\n// index 1 is the child index for \"m_b\" within class A\n\nsize_t TypeSystemClang::GetIndexOfChildMemberWithName(\n    lldb::opaque_compiler_type_t type, const char *name,\n    bool omit_empty_base_classes, std::vector<uint32_t> &child_indexes) {\n  if (type && name && name[0]) {\n    clang::QualType qual_type = RemoveWrappingTypes(GetCanonicalQualType(type));\n    const clang::Type::TypeClass type_class = qual_type->getTypeClass();\n    switch (type_class) {\n    case clang::Type::Record:\n      if (GetCompleteType(type)) {\n        const clang::RecordType *record_type =\n            llvm::cast<clang::RecordType>(qual_type.getTypePtr());\n        const clang::RecordDecl *record_decl = record_type->getDecl();\n\n        assert(record_decl);\n        uint32_t child_idx = 0;\n\n        const clang::CXXRecordDecl *cxx_record_decl =\n            llvm::dyn_cast<clang::CXXRecordDecl>(record_decl);\n\n        // Try and find a field that matches NAME\n        clang::RecordDecl::field_iterator field, field_end;\n        llvm::StringRef name_sref(name);\n        for (field = record_decl->field_begin(),\n            field_end = record_decl->field_end();\n             field != field_end; ++field, ++child_idx) {\n          llvm::StringRef field_name = field->getName();\n          if (field_name.empty()) {\n            CompilerType field_type = GetType(field->getType());\n            child_indexes.push_back(child_idx);\n            if (field_type.GetIndexOfChildMemberWithName(\n                    name, omit_empty_base_classes, child_indexes))\n              return child_indexes.size();\n            child_indexes.pop_back();\n\n          } else if (field_name.equals(name_sref)) {\n            // We have to add on the number of base classes to this index!\n            child_indexes.push_back(\n                child_idx + TypeSystemClang::GetNumBaseClasses(\n                                cxx_record_decl, omit_empty_base_classes));\n            return child_indexes.size();\n          }\n        }\n\n        if (cxx_record_decl) {\n          const clang::RecordDecl *parent_record_decl = cxx_record_decl;\n\n          // Didn't find things easily, lets let clang do its thang...\n          clang::IdentifierInfo &ident_ref =\n              getASTContext().Idents.get(name_sref);\n          clang::DeclarationName decl_name(&ident_ref);\n\n          clang::CXXBasePaths paths;\n          if (cxx_record_decl->lookupInBases(\n                  [decl_name](const clang::CXXBaseSpecifier *specifier,\n                              clang::CXXBasePath &path) {\n                    path.Decls =\n                        specifier->getType()->getAsCXXRecordDecl()->lookup(\n                            decl_name);\n                    return !path.Decls.empty();\n                  },\n                  paths)) {\n            clang::CXXBasePaths::const_paths_iterator path,\n                path_end = paths.end();\n            for (path = paths.begin(); path != path_end; ++path) {\n              const size_t num_path_elements = path->size();\n              for (size_t e = 0; e < num_path_elements; ++e) {\n                clang::CXXBasePathElement elem = (*path)[e];\n\n                child_idx = GetIndexForRecordBase(parent_record_decl, elem.Base,\n                                                  omit_empty_base_classes);\n                if (child_idx == UINT32_MAX) {\n                  child_indexes.clear();\n                  return 0;\n                } else {\n                  child_indexes.push_back(child_idx);\n                  parent_record_decl = llvm::cast<clang::RecordDecl>(\n                      elem.Base->getType()\n                          ->getAs<clang::RecordType>()\n                          ->getDecl());\n                }\n              }\n              for (clang::NamedDecl *path_decl : path->Decls) {\n                child_idx = GetIndexForRecordChild(\n                    parent_record_decl, path_decl, omit_empty_base_classes);\n                if (child_idx == UINT32_MAX) {\n                  child_indexes.clear();\n                  return 0;\n                } else {\n                  child_indexes.push_back(child_idx);\n                }\n              }\n            }\n            return child_indexes.size();\n          }\n        }\n      }\n      break;\n\n    case clang::Type::ObjCObject:\n    case clang::Type::ObjCInterface:\n      if (GetCompleteType(type)) {\n        llvm::StringRef name_sref(name);\n        const clang::ObjCObjectType *objc_class_type =\n            llvm::dyn_cast<clang::ObjCObjectType>(qual_type.getTypePtr());\n        assert(objc_class_type);\n        if (objc_class_type) {\n          uint32_t child_idx = 0;\n          clang::ObjCInterfaceDecl *class_interface_decl =\n              objc_class_type->getInterface();\n\n          if (class_interface_decl) {\n            clang::ObjCInterfaceDecl::ivar_iterator ivar_pos,\n                ivar_end = class_interface_decl->ivar_end();\n            clang::ObjCInterfaceDecl *superclass_interface_decl =\n                class_interface_decl->getSuperClass();\n\n            for (ivar_pos = class_interface_decl->ivar_begin();\n                 ivar_pos != ivar_end; ++ivar_pos, ++child_idx) {\n              const clang::ObjCIvarDecl *ivar_decl = *ivar_pos;\n\n              if (ivar_decl->getName().equals(name_sref)) {\n                if ((!omit_empty_base_classes && superclass_interface_decl) ||\n                    (omit_empty_base_classes &&\n                     ObjCDeclHasIVars(superclass_interface_decl, true)))\n                  ++child_idx;\n\n                child_indexes.push_back(child_idx);\n                return child_indexes.size();\n              }\n            }\n\n            if (superclass_interface_decl) {\n              // The super class index is always zero for ObjC classes, so we\n              // push it onto the child indexes in case we find an ivar in our\n              // superclass...\n              child_indexes.push_back(0);\n\n              CompilerType superclass_clang_type =\n                  GetType(getASTContext().getObjCInterfaceType(\n                      superclass_interface_decl));\n              if (superclass_clang_type.GetIndexOfChildMemberWithName(\n                      name, omit_empty_base_classes, child_indexes)) {\n                // We did find an ivar in a superclass so just return the\n                // results!\n                return child_indexes.size();\n              }\n\n              // We didn't find an ivar matching \"name\" in our superclass, pop\n              // the superclass zero index that we pushed on above.\n              child_indexes.pop_back();\n            }\n          }\n        }\n      }\n      break;\n\n    case clang::Type::ObjCObjectPointer: {\n      CompilerType objc_object_clang_type = GetType(\n          llvm::cast<clang::ObjCObjectPointerType>(qual_type.getTypePtr())\n              ->getPointeeType());\n      return objc_object_clang_type.GetIndexOfChildMemberWithName(\n          name, omit_empty_base_classes, child_indexes);\n    } break;\n\n    case clang::Type::ConstantArray: {\n      //                const clang::ConstantArrayType *array =\n      //                llvm::cast<clang::ConstantArrayType>(parent_qual_type.getTypePtr());\n      //                const uint64_t element_count =\n      //                array->getSize().getLimitedValue();\n      //\n      //                if (idx < element_count)\n      //                {\n      //                    std::pair<uint64_t, unsigned> field_type_info =\n      //                    ast->getTypeInfo(array->getElementType());\n      //\n      //                    char element_name[32];\n      //                    ::snprintf (element_name, sizeof (element_name),\n      //                    \"%s[%u]\", parent_name ? parent_name : \"\", idx);\n      //\n      //                    child_name.assign(element_name);\n      //                    assert(field_type_info.first % 8 == 0);\n      //                    child_byte_size = field_type_info.first / 8;\n      //                    child_byte_offset = idx * child_byte_size;\n      //                    return array->getElementType().getAsOpaquePtr();\n      //                }\n    } break;\n\n    //        case clang::Type::MemberPointerType:\n    //            {\n    //                MemberPointerType *mem_ptr_type =\n    //                llvm::cast<MemberPointerType>(qual_type.getTypePtr());\n    //                clang::QualType pointee_type =\n    //                mem_ptr_type->getPointeeType();\n    //\n    //                if (TypeSystemClang::IsAggregateType\n    //                (pointee_type.getAsOpaquePtr()))\n    //                {\n    //                    return GetIndexOfChildWithName (ast,\n    //                                                    mem_ptr_type->getPointeeType().getAsOpaquePtr(),\n    //                                                    name);\n    //                }\n    //            }\n    //            break;\n    //\n    case clang::Type::LValueReference:\n    case clang::Type::RValueReference: {\n      const clang::ReferenceType *reference_type =\n          llvm::cast<clang::ReferenceType>(qual_type.getTypePtr());\n      clang::QualType pointee_type(reference_type->getPointeeType());\n      CompilerType pointee_clang_type = GetType(pointee_type);\n\n      if (pointee_clang_type.IsAggregateType()) {\n        return pointee_clang_type.GetIndexOfChildMemberWithName(\n            name, omit_empty_base_classes, child_indexes);\n      }\n    } break;\n\n    case clang::Type::Pointer: {\n      CompilerType pointee_clang_type(GetPointeeType(type));\n\n      if (pointee_clang_type.IsAggregateType()) {\n        return pointee_clang_type.GetIndexOfChildMemberWithName(\n            name, omit_empty_base_classes, child_indexes);\n      }\n    } break;\n\n    default:\n      break;\n    }\n  }\n  return 0;\n}\n\n// Get the index of the child of \"clang_type\" whose name matches. This function\n// doesn't descend into the children, but only looks one level deep and name\n// matches can include base class names.\n\nuint32_t\nTypeSystemClang::GetIndexOfChildWithName(lldb::opaque_compiler_type_t type,\n                                         const char *name,\n                                         bool omit_empty_base_classes) {\n  if (type && name && name[0]) {\n    clang::QualType qual_type = RemoveWrappingTypes(GetCanonicalQualType(type));\n\n    const clang::Type::TypeClass type_class = qual_type->getTypeClass();\n\n    switch (type_class) {\n    case clang::Type::Record:\n      if (GetCompleteType(type)) {\n        const clang::RecordType *record_type =\n            llvm::cast<clang::RecordType>(qual_type.getTypePtr());\n        const clang::RecordDecl *record_decl = record_type->getDecl();\n\n        assert(record_decl);\n        uint32_t child_idx = 0;\n\n        const clang::CXXRecordDecl *cxx_record_decl =\n            llvm::dyn_cast<clang::CXXRecordDecl>(record_decl);\n\n        if (cxx_record_decl) {\n          clang::CXXRecordDecl::base_class_const_iterator base_class,\n              base_class_end;\n          for (base_class = cxx_record_decl->bases_begin(),\n              base_class_end = cxx_record_decl->bases_end();\n               base_class != base_class_end; ++base_class) {\n            // Skip empty base classes\n            clang::CXXRecordDecl *base_class_decl =\n                llvm::cast<clang::CXXRecordDecl>(\n                    base_class->getType()\n                        ->getAs<clang::RecordType>()\n                        ->getDecl());\n            if (omit_empty_base_classes &&\n                !TypeSystemClang::RecordHasFields(base_class_decl))\n              continue;\n\n            CompilerType base_class_clang_type = GetType(base_class->getType());\n            std::string base_class_type_name(\n                base_class_clang_type.GetTypeName().AsCString(\"\"));\n            if (base_class_type_name == name)\n              return child_idx;\n            ++child_idx;\n          }\n        }\n\n        // Try and find a field that matches NAME\n        clang::RecordDecl::field_iterator field, field_end;\n        llvm::StringRef name_sref(name);\n        for (field = record_decl->field_begin(),\n            field_end = record_decl->field_end();\n             field != field_end; ++field, ++child_idx) {\n          if (field->getName().equals(name_sref))\n            return child_idx;\n        }\n      }\n      break;\n\n    case clang::Type::ObjCObject:\n    case clang::Type::ObjCInterface:\n      if (GetCompleteType(type)) {\n        llvm::StringRef name_sref(name);\n        const clang::ObjCObjectType *objc_class_type =\n            llvm::dyn_cast<clang::ObjCObjectType>(qual_type.getTypePtr());\n        assert(objc_class_type);\n        if (objc_class_type) {\n          uint32_t child_idx = 0;\n          clang::ObjCInterfaceDecl *class_interface_decl =\n              objc_class_type->getInterface();\n\n          if (class_interface_decl) {\n            clang::ObjCInterfaceDecl::ivar_iterator ivar_pos,\n                ivar_end = class_interface_decl->ivar_end();\n            clang::ObjCInterfaceDecl *superclass_interface_decl =\n                class_interface_decl->getSuperClass();\n\n            for (ivar_pos = class_interface_decl->ivar_begin();\n                 ivar_pos != ivar_end; ++ivar_pos, ++child_idx) {\n              const clang::ObjCIvarDecl *ivar_decl = *ivar_pos;\n\n              if (ivar_decl->getName().equals(name_sref)) {\n                if ((!omit_empty_base_classes && superclass_interface_decl) ||\n                    (omit_empty_base_classes &&\n                     ObjCDeclHasIVars(superclass_interface_decl, true)))\n                  ++child_idx;\n\n                return child_idx;\n              }\n            }\n\n            if (superclass_interface_decl) {\n              if (superclass_interface_decl->getName().equals(name_sref))\n                return 0;\n            }\n          }\n        }\n      }\n      break;\n\n    case clang::Type::ObjCObjectPointer: {\n      CompilerType pointee_clang_type = GetType(\n          llvm::cast<clang::ObjCObjectPointerType>(qual_type.getTypePtr())\n              ->getPointeeType());\n      return pointee_clang_type.GetIndexOfChildWithName(\n          name, omit_empty_base_classes);\n    } break;\n\n    case clang::Type::ConstantArray: {\n      //                const clang::ConstantArrayType *array =\n      //                llvm::cast<clang::ConstantArrayType>(parent_qual_type.getTypePtr());\n      //                const uint64_t element_count =\n      //                array->getSize().getLimitedValue();\n      //\n      //                if (idx < element_count)\n      //                {\n      //                    std::pair<uint64_t, unsigned> field_type_info =\n      //                    ast->getTypeInfo(array->getElementType());\n      //\n      //                    char element_name[32];\n      //                    ::snprintf (element_name, sizeof (element_name),\n      //                    \"%s[%u]\", parent_name ? parent_name : \"\", idx);\n      //\n      //                    child_name.assign(element_name);\n      //                    assert(field_type_info.first % 8 == 0);\n      //                    child_byte_size = field_type_info.first / 8;\n      //                    child_byte_offset = idx * child_byte_size;\n      //                    return array->getElementType().getAsOpaquePtr();\n      //                }\n    } break;\n\n    //        case clang::Type::MemberPointerType:\n    //            {\n    //                MemberPointerType *mem_ptr_type =\n    //                llvm::cast<MemberPointerType>(qual_type.getTypePtr());\n    //                clang::QualType pointee_type =\n    //                mem_ptr_type->getPointeeType();\n    //\n    //                if (TypeSystemClang::IsAggregateType\n    //                (pointee_type.getAsOpaquePtr()))\n    //                {\n    //                    return GetIndexOfChildWithName (ast,\n    //                                                    mem_ptr_type->getPointeeType().getAsOpaquePtr(),\n    //                                                    name);\n    //                }\n    //            }\n    //            break;\n    //\n    case clang::Type::LValueReference:\n    case clang::Type::RValueReference: {\n      const clang::ReferenceType *reference_type =\n          llvm::cast<clang::ReferenceType>(qual_type.getTypePtr());\n      CompilerType pointee_type = GetType(reference_type->getPointeeType());\n\n      if (pointee_type.IsAggregateType()) {\n        return pointee_type.GetIndexOfChildWithName(name,\n                                                    omit_empty_base_classes);\n      }\n    } break;\n\n    case clang::Type::Pointer: {\n      const clang::PointerType *pointer_type =\n          llvm::cast<clang::PointerType>(qual_type.getTypePtr());\n      CompilerType pointee_type = GetType(pointer_type->getPointeeType());\n\n      if (pointee_type.IsAggregateType()) {\n        return pointee_type.GetIndexOfChildWithName(name,\n                                                    omit_empty_base_classes);\n      } else {\n        //                    if (parent_name)\n        //                    {\n        //                        child_name.assign(1, '*');\n        //                        child_name += parent_name;\n        //                    }\n        //\n        //                    // We have a pointer to an simple type\n        //                    if (idx == 0)\n        //                    {\n        //                        std::pair<uint64_t, unsigned> clang_type_info\n        //                        = ast->getTypeInfo(pointee_type);\n        //                        assert(clang_type_info.first % 8 == 0);\n        //                        child_byte_size = clang_type_info.first / 8;\n        //                        child_byte_offset = 0;\n        //                        return pointee_type.getAsOpaquePtr();\n        //                    }\n      }\n    } break;\n\n    default:\n      break;\n    }\n  }\n  return UINT32_MAX;\n}\n\nsize_t\nTypeSystemClang::GetNumTemplateArguments(lldb::opaque_compiler_type_t type) {\n  if (!type)\n    return 0;\n\n  clang::QualType qual_type = RemoveWrappingTypes(GetCanonicalQualType(type));\n  const clang::Type::TypeClass type_class = qual_type->getTypeClass();\n  switch (type_class) {\n  case clang::Type::Record:\n    if (GetCompleteType(type)) {\n      const clang::CXXRecordDecl *cxx_record_decl =\n          qual_type->getAsCXXRecordDecl();\n      if (cxx_record_decl) {\n        const clang::ClassTemplateSpecializationDecl *template_decl =\n            llvm::dyn_cast<clang::ClassTemplateSpecializationDecl>(\n                cxx_record_decl);\n        if (template_decl)\n          return template_decl->getTemplateArgs().size();\n      }\n    }\n    break;\n\n  default:\n    break;\n  }\n\n  return 0;\n}\n\nconst clang::ClassTemplateSpecializationDecl *\nTypeSystemClang::GetAsTemplateSpecialization(\n    lldb::opaque_compiler_type_t type) {\n  if (!type)\n    return nullptr;\n\n  clang::QualType qual_type(RemoveWrappingTypes(GetCanonicalQualType(type)));\n  const clang::Type::TypeClass type_class = qual_type->getTypeClass();\n  switch (type_class) {\n  case clang::Type::Record: {\n    if (! GetCompleteType(type))\n      return nullptr;\n    const clang::CXXRecordDecl *cxx_record_decl =\n        qual_type->getAsCXXRecordDecl();\n    if (!cxx_record_decl)\n      return nullptr;\n    return llvm::dyn_cast<clang::ClassTemplateSpecializationDecl>(\n        cxx_record_decl);\n  }\n\n  default:\n    return nullptr;\n  }\n}\n\nlldb::TemplateArgumentKind\nTypeSystemClang::GetTemplateArgumentKind(lldb::opaque_compiler_type_t type,\n                                         size_t arg_idx) {\n  const clang::ClassTemplateSpecializationDecl *template_decl =\n      GetAsTemplateSpecialization(type);\n  if (! template_decl || arg_idx >= template_decl->getTemplateArgs().size())\n    return eTemplateArgumentKindNull;\n\n  switch (template_decl->getTemplateArgs()[arg_idx].getKind()) {\n  case clang::TemplateArgument::Null:\n    return eTemplateArgumentKindNull;\n\n  case clang::TemplateArgument::NullPtr:\n    return eTemplateArgumentKindNullPtr;\n\n  case clang::TemplateArgument::Type:\n    return eTemplateArgumentKindType;\n\n  case clang::TemplateArgument::Declaration:\n    return eTemplateArgumentKindDeclaration;\n\n  case clang::TemplateArgument::Integral:\n    return eTemplateArgumentKindIntegral;\n\n  case clang::TemplateArgument::Template:\n    return eTemplateArgumentKindTemplate;\n\n  case clang::TemplateArgument::TemplateExpansion:\n    return eTemplateArgumentKindTemplateExpansion;\n\n  case clang::TemplateArgument::Expression:\n    return eTemplateArgumentKindExpression;\n\n  case clang::TemplateArgument::Pack:\n    return eTemplateArgumentKindPack;\n  }\n  llvm_unreachable(\"Unhandled clang::TemplateArgument::ArgKind\");\n}\n\nCompilerType\nTypeSystemClang::GetTypeTemplateArgument(lldb::opaque_compiler_type_t type,\n                                         size_t idx) {\n  const clang::ClassTemplateSpecializationDecl *template_decl =\n      GetAsTemplateSpecialization(type);\n  if (!template_decl || idx >= template_decl->getTemplateArgs().size())\n    return CompilerType();\n\n  const clang::TemplateArgument &template_arg =\n      template_decl->getTemplateArgs()[idx];\n  if (template_arg.getKind() != clang::TemplateArgument::Type)\n    return CompilerType();\n\n  return GetType(template_arg.getAsType());\n}\n\nOptional<CompilerType::IntegralTemplateArgument>\nTypeSystemClang::GetIntegralTemplateArgument(lldb::opaque_compiler_type_t type,\n                                             size_t idx) {\n  const clang::ClassTemplateSpecializationDecl *template_decl =\n      GetAsTemplateSpecialization(type);\n  if (! template_decl || idx >= template_decl->getTemplateArgs().size())\n    return llvm::None;\n\n  const clang::TemplateArgument &template_arg =\n      template_decl->getTemplateArgs()[idx];\n  if (template_arg.getKind() != clang::TemplateArgument::Integral)\n    return llvm::None;\n\n  return {\n      {template_arg.getAsIntegral(), GetType(template_arg.getIntegralType())}};\n}\n\nCompilerType TypeSystemClang::GetTypeForFormatters(void *type) {\n  if (type)\n    return ClangUtil::RemoveFastQualifiers(CompilerType(this, type));\n  return CompilerType();\n}\n\nclang::EnumDecl *TypeSystemClang::GetAsEnumDecl(const CompilerType &type) {\n  const clang::EnumType *enutype =\n      llvm::dyn_cast<clang::EnumType>(ClangUtil::GetCanonicalQualType(type));\n  if (enutype)\n    return enutype->getDecl();\n  return nullptr;\n}\n\nclang::RecordDecl *TypeSystemClang::GetAsRecordDecl(const CompilerType &type) {\n  const clang::RecordType *record_type =\n      llvm::dyn_cast<clang::RecordType>(ClangUtil::GetCanonicalQualType(type));\n  if (record_type)\n    return record_type->getDecl();\n  return nullptr;\n}\n\nclang::TagDecl *TypeSystemClang::GetAsTagDecl(const CompilerType &type) {\n  return ClangUtil::GetAsTagDecl(type);\n}\n\nclang::TypedefNameDecl *\nTypeSystemClang::GetAsTypedefDecl(const CompilerType &type) {\n  const clang::TypedefType *typedef_type =\n      llvm::dyn_cast<clang::TypedefType>(ClangUtil::GetQualType(type));\n  if (typedef_type)\n    return typedef_type->getDecl();\n  return nullptr;\n}\n\nclang::CXXRecordDecl *\nTypeSystemClang::GetAsCXXRecordDecl(lldb::opaque_compiler_type_t type) {\n  return GetCanonicalQualType(type)->getAsCXXRecordDecl();\n}\n\nclang::ObjCInterfaceDecl *\nTypeSystemClang::GetAsObjCInterfaceDecl(const CompilerType &type) {\n  const clang::ObjCObjectType *objc_class_type =\n      llvm::dyn_cast<clang::ObjCObjectType>(\n          ClangUtil::GetCanonicalQualType(type));\n  if (objc_class_type)\n    return objc_class_type->getInterface();\n  return nullptr;\n}\n\nclang::FieldDecl *TypeSystemClang::AddFieldToRecordType(\n    const CompilerType &type, llvm::StringRef name,\n    const CompilerType &field_clang_type, AccessType access,\n    uint32_t bitfield_bit_size) {\n  if (!type.IsValid() || !field_clang_type.IsValid())\n    return nullptr;\n  TypeSystemClang *ast =\n      llvm::dyn_cast_or_null<TypeSystemClang>(type.GetTypeSystem());\n  if (!ast)\n    return nullptr;\n  clang::ASTContext &clang_ast = ast->getASTContext();\n  clang::IdentifierInfo *ident = nullptr;\n  if (!name.empty())\n    ident = &clang_ast.Idents.get(name);\n\n  clang::FieldDecl *field = nullptr;\n\n  clang::Expr *bit_width = nullptr;\n  if (bitfield_bit_size != 0) {\n    llvm::APInt bitfield_bit_size_apint(clang_ast.getTypeSize(clang_ast.IntTy),\n                                        bitfield_bit_size);\n    bit_width = new (clang_ast)\n        clang::IntegerLiteral(clang_ast, bitfield_bit_size_apint,\n                              clang_ast.IntTy, clang::SourceLocation());\n  }\n\n  clang::RecordDecl *record_decl = ast->GetAsRecordDecl(type);\n  if (record_decl) {\n    field = clang::FieldDecl::CreateDeserialized(clang_ast, 0);\n    field->setDeclContext(record_decl);\n    field->setDeclName(ident);\n    field->setType(ClangUtil::GetQualType(field_clang_type));\n    if (bit_width)\n      field->setBitWidth(bit_width);\n    SetMemberOwningModule(field, record_decl);\n\n    if (name.empty()) {\n      // Determine whether this field corresponds to an anonymous struct or\n      // union.\n      if (const clang::TagType *TagT =\n              field->getType()->getAs<clang::TagType>()) {\n        if (clang::RecordDecl *Rec =\n                llvm::dyn_cast<clang::RecordDecl>(TagT->getDecl()))\n          if (!Rec->getDeclName()) {\n            Rec->setAnonymousStructOrUnion(true);\n            field->setImplicit();\n          }\n      }\n    }\n\n    if (field) {\n      field->setAccess(\n          TypeSystemClang::ConvertAccessTypeToAccessSpecifier(access));\n\n      record_decl->addDecl(field);\n\n      VerifyDecl(field);\n    }\n  } else {\n    clang::ObjCInterfaceDecl *class_interface_decl =\n        ast->GetAsObjCInterfaceDecl(type);\n\n    if (class_interface_decl) {\n      const bool is_synthesized = false;\n\n      field_clang_type.GetCompleteType();\n\n      auto *ivar = clang::ObjCIvarDecl::CreateDeserialized(clang_ast, 0);\n      ivar->setDeclContext(class_interface_decl);\n      ivar->setDeclName(ident);\n      ivar->setType(ClangUtil::GetQualType(field_clang_type));\n      ivar->setAccessControl(ConvertAccessTypeToObjCIvarAccessControl(access));\n      if (bit_width)\n        ivar->setBitWidth(bit_width);\n      ivar->setSynthesize(is_synthesized);\n      field = ivar;\n      SetMemberOwningModule(field, class_interface_decl);\n\n      if (field) {\n        class_interface_decl->addDecl(field);\n\n        VerifyDecl(field);\n      }\n    }\n  }\n  return field;\n}\n\nvoid TypeSystemClang::BuildIndirectFields(const CompilerType &type) {\n  if (!type)\n    return;\n\n  TypeSystemClang *ast = llvm::dyn_cast<TypeSystemClang>(type.GetTypeSystem());\n  if (!ast)\n    return;\n\n  clang::RecordDecl *record_decl = ast->GetAsRecordDecl(type);\n\n  if (!record_decl)\n    return;\n\n  typedef llvm::SmallVector<clang::IndirectFieldDecl *, 1> IndirectFieldVector;\n\n  IndirectFieldVector indirect_fields;\n  clang::RecordDecl::field_iterator field_pos;\n  clang::RecordDecl::field_iterator field_end_pos = record_decl->field_end();\n  clang::RecordDecl::field_iterator last_field_pos = field_end_pos;\n  for (field_pos = record_decl->field_begin(); field_pos != field_end_pos;\n       last_field_pos = field_pos++) {\n    if (field_pos->isAnonymousStructOrUnion()) {\n      clang::QualType field_qual_type = field_pos->getType();\n\n      const clang::RecordType *field_record_type =\n          field_qual_type->getAs<clang::RecordType>();\n\n      if (!field_record_type)\n        continue;\n\n      clang::RecordDecl *field_record_decl = field_record_type->getDecl();\n\n      if (!field_record_decl)\n        continue;\n\n      for (clang::RecordDecl::decl_iterator\n               di = field_record_decl->decls_begin(),\n               de = field_record_decl->decls_end();\n           di != de; ++di) {\n        if (clang::FieldDecl *nested_field_decl =\n                llvm::dyn_cast<clang::FieldDecl>(*di)) {\n          clang::NamedDecl **chain =\n              new (ast->getASTContext()) clang::NamedDecl *[2];\n          chain[0] = *field_pos;\n          chain[1] = nested_field_decl;\n          clang::IndirectFieldDecl *indirect_field =\n              clang::IndirectFieldDecl::Create(\n                  ast->getASTContext(), record_decl, clang::SourceLocation(),\n                  nested_field_decl->getIdentifier(),\n                  nested_field_decl->getType(), {chain, 2});\n          SetMemberOwningModule(indirect_field, record_decl);\n\n          indirect_field->setImplicit();\n\n          indirect_field->setAccess(TypeSystemClang::UnifyAccessSpecifiers(\n              field_pos->getAccess(), nested_field_decl->getAccess()));\n\n          indirect_fields.push_back(indirect_field);\n        } else if (clang::IndirectFieldDecl *nested_indirect_field_decl =\n                       llvm::dyn_cast<clang::IndirectFieldDecl>(*di)) {\n          size_t nested_chain_size =\n              nested_indirect_field_decl->getChainingSize();\n          clang::NamedDecl **chain = new (ast->getASTContext())\n              clang::NamedDecl *[nested_chain_size + 1];\n          chain[0] = *field_pos;\n\n          int chain_index = 1;\n          for (clang::IndirectFieldDecl::chain_iterator\n                   nci = nested_indirect_field_decl->chain_begin(),\n                   nce = nested_indirect_field_decl->chain_end();\n               nci < nce; ++nci) {\n            chain[chain_index] = *nci;\n            chain_index++;\n          }\n\n          clang::IndirectFieldDecl *indirect_field =\n              clang::IndirectFieldDecl::Create(\n                  ast->getASTContext(), record_decl, clang::SourceLocation(),\n                  nested_indirect_field_decl->getIdentifier(),\n                  nested_indirect_field_decl->getType(),\n                  {chain, nested_chain_size + 1});\n          SetMemberOwningModule(indirect_field, record_decl);\n\n          indirect_field->setImplicit();\n\n          indirect_field->setAccess(TypeSystemClang::UnifyAccessSpecifiers(\n              field_pos->getAccess(), nested_indirect_field_decl->getAccess()));\n\n          indirect_fields.push_back(indirect_field);\n        }\n      }\n    }\n  }\n\n  // Check the last field to see if it has an incomplete array type as its last\n  // member and if it does, the tell the record decl about it\n  if (last_field_pos != field_end_pos) {\n    if (last_field_pos->getType()->isIncompleteArrayType())\n      record_decl->hasFlexibleArrayMember();\n  }\n\n  for (IndirectFieldVector::iterator ifi = indirect_fields.begin(),\n                                     ife = indirect_fields.end();\n       ifi < ife; ++ifi) {\n    record_decl->addDecl(*ifi);\n  }\n}\n\nvoid TypeSystemClang::SetIsPacked(const CompilerType &type) {\n  if (type) {\n    TypeSystemClang *ast =\n        llvm::dyn_cast<TypeSystemClang>(type.GetTypeSystem());\n    if (ast) {\n      clang::RecordDecl *record_decl = GetAsRecordDecl(type);\n\n      if (!record_decl)\n        return;\n\n      record_decl->addAttr(\n          clang::PackedAttr::CreateImplicit(ast->getASTContext()));\n    }\n  }\n}\n\nclang::VarDecl *TypeSystemClang::AddVariableToRecordType(\n    const CompilerType &type, llvm::StringRef name,\n    const CompilerType &var_type, AccessType access) {\n  if (!type.IsValid() || !var_type.IsValid())\n    return nullptr;\n\n  TypeSystemClang *ast = llvm::dyn_cast<TypeSystemClang>(type.GetTypeSystem());\n  if (!ast)\n    return nullptr;\n\n  clang::RecordDecl *record_decl = ast->GetAsRecordDecl(type);\n  if (!record_decl)\n    return nullptr;\n\n  clang::VarDecl *var_decl = nullptr;\n  clang::IdentifierInfo *ident = nullptr;\n  if (!name.empty())\n    ident = &ast->getASTContext().Idents.get(name);\n\n  var_decl = clang::VarDecl::CreateDeserialized(ast->getASTContext(), 0);\n  var_decl->setDeclContext(record_decl);\n  var_decl->setDeclName(ident);\n  var_decl->setType(ClangUtil::GetQualType(var_type));\n  var_decl->setStorageClass(clang::SC_Static);\n  SetMemberOwningModule(var_decl, record_decl);\n  if (!var_decl)\n    return nullptr;\n\n  var_decl->setAccess(\n      TypeSystemClang::ConvertAccessTypeToAccessSpecifier(access));\n  record_decl->addDecl(var_decl);\n\n  VerifyDecl(var_decl);\n\n  return var_decl;\n}\n\nvoid TypeSystemClang::SetIntegerInitializerForVariable(\n    VarDecl *var, const llvm::APInt &init_value) {\n  assert(!var->hasInit() && \"variable already initialized\");\n\n  clang::ASTContext &ast = var->getASTContext();\n  QualType qt = var->getType();\n  assert(qt->isIntegralOrEnumerationType() &&\n         \"only integer or enum types supported\");\n  // If the variable is an enum type, take the underlying integer type as\n  // the type of the integer literal.\n  if (const EnumType *enum_type = llvm::dyn_cast<EnumType>(qt.getTypePtr())) {\n    const EnumDecl *enum_decl = enum_type->getDecl();\n    qt = enum_decl->getIntegerType();\n  }\n  var->setInit(IntegerLiteral::Create(ast, init_value, qt.getUnqualifiedType(),\n                                      SourceLocation()));\n}\n\nvoid TypeSystemClang::SetFloatingInitializerForVariable(\n    clang::VarDecl *var, const llvm::APFloat &init_value) {\n  assert(!var->hasInit() && \"variable already initialized\");\n\n  clang::ASTContext &ast = var->getASTContext();\n  QualType qt = var->getType();\n  assert(qt->isFloatingType() && \"only floating point types supported\");\n  var->setInit(FloatingLiteral::Create(\n      ast, init_value, true, qt.getUnqualifiedType(), SourceLocation()));\n}\n\nclang::CXXMethodDecl *TypeSystemClang::AddMethodToCXXRecordType(\n    lldb::opaque_compiler_type_t type, llvm::StringRef name,\n    const char *mangled_name, const CompilerType &method_clang_type,\n    lldb::AccessType access, bool is_virtual, bool is_static, bool is_inline,\n    bool is_explicit, bool is_attr_used, bool is_artificial) {\n  if (!type || !method_clang_type.IsValid() || name.empty())\n    return nullptr;\n\n  clang::QualType record_qual_type(GetCanonicalQualType(type));\n\n  clang::CXXRecordDecl *cxx_record_decl =\n      record_qual_type->getAsCXXRecordDecl();\n\n  if (cxx_record_decl == nullptr)\n    return nullptr;\n\n  clang::QualType method_qual_type(ClangUtil::GetQualType(method_clang_type));\n\n  clang::CXXMethodDecl *cxx_method_decl = nullptr;\n\n  clang::DeclarationName decl_name(&getASTContext().Idents.get(name));\n\n  const clang::FunctionType *function_type =\n      llvm::dyn_cast<clang::FunctionType>(method_qual_type.getTypePtr());\n\n  if (function_type == nullptr)\n    return nullptr;\n\n  const clang::FunctionProtoType *method_function_prototype(\n      llvm::dyn_cast<clang::FunctionProtoType>(function_type));\n\n  if (!method_function_prototype)\n    return nullptr;\n\n  unsigned int num_params = method_function_prototype->getNumParams();\n\n  clang::CXXDestructorDecl *cxx_dtor_decl(nullptr);\n  clang::CXXConstructorDecl *cxx_ctor_decl(nullptr);\n\n  if (is_artificial)\n    return nullptr; // skip everything artificial\n\n  const clang::ExplicitSpecifier explicit_spec(\n      nullptr /*expr*/, is_explicit ? clang::ExplicitSpecKind::ResolvedTrue\n                                    : clang::ExplicitSpecKind::ResolvedFalse);\n\n  if (name.startswith(\"~\")) {\n    cxx_dtor_decl =\n        clang::CXXDestructorDecl::CreateDeserialized(getASTContext(), 0);\n    cxx_dtor_decl->setDeclContext(cxx_record_decl);\n    cxx_dtor_decl->setDeclName(\n        getASTContext().DeclarationNames.getCXXDestructorName(\n            getASTContext().getCanonicalType(record_qual_type)));\n    cxx_dtor_decl->setType(method_qual_type);\n    cxx_dtor_decl->setImplicit(is_artificial);\n    cxx_dtor_decl->setInlineSpecified(is_inline);\n    cxx_dtor_decl->setConstexprKind(ConstexprSpecKind::Unspecified);\n    cxx_method_decl = cxx_dtor_decl;\n  } else if (decl_name == cxx_record_decl->getDeclName()) {\n    cxx_ctor_decl = clang::CXXConstructorDecl::CreateDeserialized(\n        getASTContext(), 0, 0);\n    cxx_ctor_decl->setDeclContext(cxx_record_decl);\n    cxx_ctor_decl->setDeclName(\n        getASTContext().DeclarationNames.getCXXConstructorName(\n            getASTContext().getCanonicalType(record_qual_type)));\n    cxx_ctor_decl->setType(method_qual_type);\n    cxx_ctor_decl->setImplicit(is_artificial);\n    cxx_ctor_decl->setInlineSpecified(is_inline);\n    cxx_ctor_decl->setConstexprKind(ConstexprSpecKind::Unspecified);\n    cxx_ctor_decl->setNumCtorInitializers(0);\n    cxx_ctor_decl->setExplicitSpecifier(explicit_spec);\n    cxx_method_decl = cxx_ctor_decl;\n  } else {\n    clang::StorageClass SC = is_static ? clang::SC_Static : clang::SC_None;\n    clang::OverloadedOperatorKind op_kind = clang::NUM_OVERLOADED_OPERATORS;\n\n    if (IsOperator(name, op_kind)) {\n      if (op_kind != clang::NUM_OVERLOADED_OPERATORS) {\n        // Check the number of operator parameters. Sometimes we have seen bad\n        // DWARF that doesn't correctly describe operators and if we try to\n        // create a method and add it to the class, clang will assert and\n        // crash, so we need to make sure things are acceptable.\n        const bool is_method = true;\n        if (!TypeSystemClang::CheckOverloadedOperatorKindParameterCount(\n                is_method, op_kind, num_params))\n          return nullptr;\n        cxx_method_decl =\n            clang::CXXMethodDecl::CreateDeserialized(getASTContext(), 0);\n        cxx_method_decl->setDeclContext(cxx_record_decl);\n        cxx_method_decl->setDeclName(\n            getASTContext().DeclarationNames.getCXXOperatorName(op_kind));\n        cxx_method_decl->setType(method_qual_type);\n        cxx_method_decl->setStorageClass(SC);\n        cxx_method_decl->setInlineSpecified(is_inline);\n        cxx_method_decl->setConstexprKind(ConstexprSpecKind::Unspecified);\n      } else if (num_params == 0) {\n        // Conversion operators don't take params...\n        auto *cxx_conversion_decl =\n            clang::CXXConversionDecl::CreateDeserialized(getASTContext(), 0);\n        cxx_conversion_decl->setDeclContext(cxx_record_decl);\n        cxx_conversion_decl->setDeclName(\n            getASTContext().DeclarationNames.getCXXConversionFunctionName(\n                getASTContext().getCanonicalType(\n                    function_type->getReturnType())));\n        cxx_conversion_decl->setType(method_qual_type);\n        cxx_conversion_decl->setInlineSpecified(is_inline);\n        cxx_conversion_decl->setExplicitSpecifier(explicit_spec);\n        cxx_conversion_decl->setConstexprKind(ConstexprSpecKind::Unspecified);\n        cxx_method_decl = cxx_conversion_decl;\n      }\n    }\n\n    if (cxx_method_decl == nullptr) {\n      cxx_method_decl =\n          clang::CXXMethodDecl::CreateDeserialized(getASTContext(), 0);\n      cxx_method_decl->setDeclContext(cxx_record_decl);\n      cxx_method_decl->setDeclName(decl_name);\n      cxx_method_decl->setType(method_qual_type);\n      cxx_method_decl->setInlineSpecified(is_inline);\n      cxx_method_decl->setStorageClass(SC);\n      cxx_method_decl->setConstexprKind(ConstexprSpecKind::Unspecified);\n    }\n  }\n  SetMemberOwningModule(cxx_method_decl, cxx_record_decl);\n\n  clang::AccessSpecifier access_specifier =\n      TypeSystemClang::ConvertAccessTypeToAccessSpecifier(access);\n\n  cxx_method_decl->setAccess(access_specifier);\n  cxx_method_decl->setVirtualAsWritten(is_virtual);\n\n  if (is_attr_used)\n    cxx_method_decl->addAttr(clang::UsedAttr::CreateImplicit(getASTContext()));\n\n  if (mangled_name != nullptr) {\n    cxx_method_decl->addAttr(clang::AsmLabelAttr::CreateImplicit(\n        getASTContext(), mangled_name, /*literal=*/false));\n  }\n\n  // Populate the method decl with parameter decls\n\n  llvm::SmallVector<clang::ParmVarDecl *, 12> params;\n\n  for (unsigned param_index = 0; param_index < num_params; ++param_index) {\n    params.push_back(clang::ParmVarDecl::Create(\n        getASTContext(), cxx_method_decl, clang::SourceLocation(),\n        clang::SourceLocation(),\n        nullptr, // anonymous\n        method_function_prototype->getParamType(param_index), nullptr,\n        clang::SC_None, nullptr));\n  }\n\n  cxx_method_decl->setParams(llvm::ArrayRef<clang::ParmVarDecl *>(params));\n\n  cxx_record_decl->addDecl(cxx_method_decl);\n\n  // Sometimes the debug info will mention a constructor (default/copy/move),\n  // destructor, or assignment operator (copy/move) but there won't be any\n  // version of this in the code. So we check if the function was artificially\n  // generated and if it is trivial and this lets the compiler/backend know\n  // that it can inline the IR for these when it needs to and we can avoid a\n  // \"missing function\" error when running expressions.\n\n  if (is_artificial) {\n    if (cxx_ctor_decl && ((cxx_ctor_decl->isDefaultConstructor() &&\n                           cxx_record_decl->hasTrivialDefaultConstructor()) ||\n                          (cxx_ctor_decl->isCopyConstructor() &&\n                           cxx_record_decl->hasTrivialCopyConstructor()) ||\n                          (cxx_ctor_decl->isMoveConstructor() &&\n                           cxx_record_decl->hasTrivialMoveConstructor()))) {\n      cxx_ctor_decl->setDefaulted();\n      cxx_ctor_decl->setTrivial(true);\n    } else if (cxx_dtor_decl) {\n      if (cxx_record_decl->hasTrivialDestructor()) {\n        cxx_dtor_decl->setDefaulted();\n        cxx_dtor_decl->setTrivial(true);\n      }\n    } else if ((cxx_method_decl->isCopyAssignmentOperator() &&\n                cxx_record_decl->hasTrivialCopyAssignment()) ||\n               (cxx_method_decl->isMoveAssignmentOperator() &&\n                cxx_record_decl->hasTrivialMoveAssignment())) {\n      cxx_method_decl->setDefaulted();\n      cxx_method_decl->setTrivial(true);\n    }\n  }\n\n  VerifyDecl(cxx_method_decl);\n\n  return cxx_method_decl;\n}\n\nvoid TypeSystemClang::AddMethodOverridesForCXXRecordType(\n    lldb::opaque_compiler_type_t type) {\n  if (auto *record = GetAsCXXRecordDecl(type))\n    for (auto *method : record->methods())\n      addOverridesForMethod(method);\n}\n\n#pragma mark C++ Base Classes\n\nstd::unique_ptr<clang::CXXBaseSpecifier>\nTypeSystemClang::CreateBaseClassSpecifier(lldb::opaque_compiler_type_t type,\n                                          AccessType access, bool is_virtual,\n                                          bool base_of_class) {\n  if (!type)\n    return nullptr;\n\n  return std::make_unique<clang::CXXBaseSpecifier>(\n      clang::SourceRange(), is_virtual, base_of_class,\n      TypeSystemClang::ConvertAccessTypeToAccessSpecifier(access),\n      getASTContext().getTrivialTypeSourceInfo(GetQualType(type)),\n      clang::SourceLocation());\n}\n\nbool TypeSystemClang::TransferBaseClasses(\n    lldb::opaque_compiler_type_t type,\n    std::vector<std::unique_ptr<clang::CXXBaseSpecifier>> bases) {\n  if (!type)\n    return false;\n  clang::CXXRecordDecl *cxx_record_decl = GetAsCXXRecordDecl(type);\n  if (!cxx_record_decl)\n    return false;\n  std::vector<clang::CXXBaseSpecifier *> raw_bases;\n  raw_bases.reserve(bases.size());\n\n  // Clang will make a copy of them, so it's ok that we pass pointers that we're\n  // about to destroy.\n  for (auto &b : bases)\n    raw_bases.push_back(b.get());\n  cxx_record_decl->setBases(raw_bases.data(), raw_bases.size());\n  return true;\n}\n\nbool TypeSystemClang::SetObjCSuperClass(\n    const CompilerType &type, const CompilerType &superclass_clang_type) {\n  TypeSystemClang *ast =\n      llvm::dyn_cast_or_null<TypeSystemClang>(type.GetTypeSystem());\n  if (!ast)\n    return false;\n  clang::ASTContext &clang_ast = ast->getASTContext();\n\n  if (type && superclass_clang_type.IsValid() &&\n      superclass_clang_type.GetTypeSystem() == type.GetTypeSystem()) {\n    clang::ObjCInterfaceDecl *class_interface_decl =\n        GetAsObjCInterfaceDecl(type);\n    clang::ObjCInterfaceDecl *super_interface_decl =\n        GetAsObjCInterfaceDecl(superclass_clang_type);\n    if (class_interface_decl && super_interface_decl) {\n      class_interface_decl->setSuperClass(clang_ast.getTrivialTypeSourceInfo(\n          clang_ast.getObjCInterfaceType(super_interface_decl)));\n      return true;\n    }\n  }\n  return false;\n}\n\nbool TypeSystemClang::AddObjCClassProperty(\n    const CompilerType &type, const char *property_name,\n    const CompilerType &property_clang_type, clang::ObjCIvarDecl *ivar_decl,\n    const char *property_setter_name, const char *property_getter_name,\n    uint32_t property_attributes, ClangASTMetadata *metadata) {\n  if (!type || !property_clang_type.IsValid() || property_name == nullptr ||\n      property_name[0] == '\\0')\n    return false;\n  TypeSystemClang *ast = llvm::dyn_cast<TypeSystemClang>(type.GetTypeSystem());\n  if (!ast)\n    return false;\n  clang::ASTContext &clang_ast = ast->getASTContext();\n\n  clang::ObjCInterfaceDecl *class_interface_decl = GetAsObjCInterfaceDecl(type);\n  if (!class_interface_decl)\n    return false;\n\n  CompilerType property_clang_type_to_access;\n\n  if (property_clang_type.IsValid())\n    property_clang_type_to_access = property_clang_type;\n  else if (ivar_decl)\n    property_clang_type_to_access = ast->GetType(ivar_decl->getType());\n\n  if (!class_interface_decl || !property_clang_type_to_access.IsValid())\n    return false;\n\n  clang::TypeSourceInfo *prop_type_source;\n  if (ivar_decl)\n    prop_type_source = clang_ast.getTrivialTypeSourceInfo(ivar_decl->getType());\n  else\n    prop_type_source = clang_ast.getTrivialTypeSourceInfo(\n        ClangUtil::GetQualType(property_clang_type));\n\n  clang::ObjCPropertyDecl *property_decl =\n      clang::ObjCPropertyDecl::CreateDeserialized(clang_ast, 0);\n  property_decl->setDeclContext(class_interface_decl);\n  property_decl->setDeclName(&clang_ast.Idents.get(property_name));\n  property_decl->setType(ivar_decl\n                             ? ivar_decl->getType()\n                             : ClangUtil::GetQualType(property_clang_type),\n                         prop_type_source);\n  SetMemberOwningModule(property_decl, class_interface_decl);\n\n  if (!property_decl)\n    return false;\n\n  if (metadata)\n    ast->SetMetadata(property_decl, *metadata);\n\n  class_interface_decl->addDecl(property_decl);\n\n  clang::Selector setter_sel, getter_sel;\n\n  if (property_setter_name) {\n    std::string property_setter_no_colon(property_setter_name,\n                                         strlen(property_setter_name) - 1);\n    clang::IdentifierInfo *setter_ident =\n        &clang_ast.Idents.get(property_setter_no_colon);\n    setter_sel = clang_ast.Selectors.getSelector(1, &setter_ident);\n  } else if (!(property_attributes & DW_APPLE_PROPERTY_readonly)) {\n    std::string setter_sel_string(\"set\");\n    setter_sel_string.push_back(::toupper(property_name[0]));\n    setter_sel_string.append(&property_name[1]);\n    clang::IdentifierInfo *setter_ident =\n        &clang_ast.Idents.get(setter_sel_string);\n    setter_sel = clang_ast.Selectors.getSelector(1, &setter_ident);\n  }\n  property_decl->setSetterName(setter_sel);\n  property_decl->setPropertyAttributes(ObjCPropertyAttribute::kind_setter);\n\n  if (property_getter_name != nullptr) {\n    clang::IdentifierInfo *getter_ident =\n        &clang_ast.Idents.get(property_getter_name);\n    getter_sel = clang_ast.Selectors.getSelector(0, &getter_ident);\n  } else {\n    clang::IdentifierInfo *getter_ident = &clang_ast.Idents.get(property_name);\n    getter_sel = clang_ast.Selectors.getSelector(0, &getter_ident);\n  }\n  property_decl->setGetterName(getter_sel);\n  property_decl->setPropertyAttributes(ObjCPropertyAttribute::kind_getter);\n\n  if (ivar_decl)\n    property_decl->setPropertyIvarDecl(ivar_decl);\n\n  if (property_attributes & DW_APPLE_PROPERTY_readonly)\n    property_decl->setPropertyAttributes(ObjCPropertyAttribute::kind_readonly);\n  if (property_attributes & DW_APPLE_PROPERTY_readwrite)\n    property_decl->setPropertyAttributes(ObjCPropertyAttribute::kind_readwrite);\n  if (property_attributes & DW_APPLE_PROPERTY_assign)\n    property_decl->setPropertyAttributes(ObjCPropertyAttribute::kind_assign);\n  if (property_attributes & DW_APPLE_PROPERTY_retain)\n    property_decl->setPropertyAttributes(ObjCPropertyAttribute::kind_retain);\n  if (property_attributes & DW_APPLE_PROPERTY_copy)\n    property_decl->setPropertyAttributes(ObjCPropertyAttribute::kind_copy);\n  if (property_attributes & DW_APPLE_PROPERTY_nonatomic)\n    property_decl->setPropertyAttributes(ObjCPropertyAttribute::kind_nonatomic);\n  if (property_attributes & ObjCPropertyAttribute::kind_nullability)\n    property_decl->setPropertyAttributes(\n        ObjCPropertyAttribute::kind_nullability);\n  if (property_attributes & ObjCPropertyAttribute::kind_null_resettable)\n    property_decl->setPropertyAttributes(\n        ObjCPropertyAttribute::kind_null_resettable);\n  if (property_attributes & ObjCPropertyAttribute::kind_class)\n    property_decl->setPropertyAttributes(ObjCPropertyAttribute::kind_class);\n\n  const bool isInstance =\n      (property_attributes & ObjCPropertyAttribute::kind_class) == 0;\n\n  clang::ObjCMethodDecl *getter = nullptr;\n  if (!getter_sel.isNull())\n    getter = isInstance ? class_interface_decl->lookupInstanceMethod(getter_sel)\n                        : class_interface_decl->lookupClassMethod(getter_sel);\n  if (!getter_sel.isNull() && !getter) {\n    const bool isVariadic = false;\n    const bool isPropertyAccessor = true;\n    const bool isSynthesizedAccessorStub = false;\n    const bool isImplicitlyDeclared = true;\n    const bool isDefined = false;\n    const clang::ObjCMethodDecl::ImplementationControl impControl =\n        clang::ObjCMethodDecl::None;\n    const bool HasRelatedResultType = false;\n\n    getter = clang::ObjCMethodDecl::CreateDeserialized(clang_ast, 0);\n    getter->setDeclName(getter_sel);\n    getter->setReturnType(ClangUtil::GetQualType(property_clang_type_to_access));\n    getter->setDeclContext(class_interface_decl);\n    getter->setInstanceMethod(isInstance);\n    getter->setVariadic(isVariadic);\n    getter->setPropertyAccessor(isPropertyAccessor);\n    getter->setSynthesizedAccessorStub(isSynthesizedAccessorStub);\n    getter->setImplicit(isImplicitlyDeclared);\n    getter->setDefined(isDefined);\n    getter->setDeclImplementation(impControl);\n    getter->setRelatedResultType(HasRelatedResultType);\n    SetMemberOwningModule(getter, class_interface_decl);\n\n    if (getter) {\n      if (metadata)\n        ast->SetMetadata(getter, *metadata);\n\n      getter->setMethodParams(clang_ast, llvm::ArrayRef<clang::ParmVarDecl *>(),\n                              llvm::ArrayRef<clang::SourceLocation>());\n      class_interface_decl->addDecl(getter);\n    }\n  }\n  if (getter) {\n    getter->setPropertyAccessor(true);\n    property_decl->setGetterMethodDecl(getter);\n  }\n\n  clang::ObjCMethodDecl *setter = nullptr;\n    setter = isInstance ? class_interface_decl->lookupInstanceMethod(setter_sel)\n                        : class_interface_decl->lookupClassMethod(setter_sel);\n  if (!setter_sel.isNull() && !setter) {\n    clang::QualType result_type = clang_ast.VoidTy;\n    const bool isVariadic = false;\n    const bool isPropertyAccessor = true;\n    const bool isSynthesizedAccessorStub = false;\n    const bool isImplicitlyDeclared = true;\n    const bool isDefined = false;\n    const clang::ObjCMethodDecl::ImplementationControl impControl =\n        clang::ObjCMethodDecl::None;\n    const bool HasRelatedResultType = false;\n\n    setter = clang::ObjCMethodDecl::CreateDeserialized(clang_ast, 0);\n    setter->setDeclName(setter_sel);\n    setter->setReturnType(result_type);\n    setter->setDeclContext(class_interface_decl);\n    setter->setInstanceMethod(isInstance);\n    setter->setVariadic(isVariadic);\n    setter->setPropertyAccessor(isPropertyAccessor);\n    setter->setSynthesizedAccessorStub(isSynthesizedAccessorStub);\n    setter->setImplicit(isImplicitlyDeclared);\n    setter->setDefined(isDefined);\n    setter->setDeclImplementation(impControl);\n    setter->setRelatedResultType(HasRelatedResultType);\n    SetMemberOwningModule(setter, class_interface_decl);\n\n    if (setter) {\n      if (metadata)\n        ast->SetMetadata(setter, *metadata);\n\n      llvm::SmallVector<clang::ParmVarDecl *, 1> params;\n      params.push_back(clang::ParmVarDecl::Create(\n          clang_ast, setter, clang::SourceLocation(), clang::SourceLocation(),\n          nullptr, // anonymous\n          ClangUtil::GetQualType(property_clang_type_to_access), nullptr,\n          clang::SC_Auto, nullptr));\n\n      setter->setMethodParams(clang_ast,\n                              llvm::ArrayRef<clang::ParmVarDecl *>(params),\n                              llvm::ArrayRef<clang::SourceLocation>());\n\n      class_interface_decl->addDecl(setter);\n    }\n  }\n  if (setter) {\n    setter->setPropertyAccessor(true);\n    property_decl->setSetterMethodDecl(setter);\n  }\n\n  return true;\n}\n\nbool TypeSystemClang::IsObjCClassTypeAndHasIVars(const CompilerType &type,\n                                                 bool check_superclass) {\n  clang::ObjCInterfaceDecl *class_interface_decl = GetAsObjCInterfaceDecl(type);\n  if (class_interface_decl)\n    return ObjCDeclHasIVars(class_interface_decl, check_superclass);\n  return false;\n}\n\nclang::ObjCMethodDecl *TypeSystemClang::AddMethodToObjCObjectType(\n    const CompilerType &type,\n    const char *name, // the full symbol name as seen in the symbol table\n                      // (lldb::opaque_compiler_type_t type, \"-[NString\n                      // stringWithCString:]\")\n    const CompilerType &method_clang_type, lldb::AccessType access,\n    bool is_artificial, bool is_variadic, bool is_objc_direct_call) {\n  if (!type || !method_clang_type.IsValid())\n    return nullptr;\n\n  clang::ObjCInterfaceDecl *class_interface_decl = GetAsObjCInterfaceDecl(type);\n\n  if (class_interface_decl == nullptr)\n    return nullptr;\n  TypeSystemClang *lldb_ast =\n      llvm::dyn_cast<TypeSystemClang>(type.GetTypeSystem());\n  if (lldb_ast == nullptr)\n    return nullptr;\n  clang::ASTContext &ast = lldb_ast->getASTContext();\n\n  const char *selector_start = ::strchr(name, ' ');\n  if (selector_start == nullptr)\n    return nullptr;\n\n  selector_start++;\n  llvm::SmallVector<clang::IdentifierInfo *, 12> selector_idents;\n\n  size_t len = 0;\n  const char *start;\n\n  unsigned num_selectors_with_args = 0;\n  for (start = selector_start; start && *start != '\\0' && *start != ']';\n       start += len) {\n    len = ::strcspn(start, \":]\");\n    bool has_arg = (start[len] == ':');\n    if (has_arg)\n      ++num_selectors_with_args;\n    selector_idents.push_back(&ast.Idents.get(llvm::StringRef(start, len)));\n    if (has_arg)\n      len += 1;\n  }\n\n  if (selector_idents.size() == 0)\n    return nullptr;\n\n  clang::Selector method_selector = ast.Selectors.getSelector(\n      num_selectors_with_args ? selector_idents.size() : 0,\n      selector_idents.data());\n\n  clang::QualType method_qual_type(ClangUtil::GetQualType(method_clang_type));\n\n  // Populate the method decl with parameter decls\n  const clang::Type *method_type(method_qual_type.getTypePtr());\n\n  if (method_type == nullptr)\n    return nullptr;\n\n  const clang::FunctionProtoType *method_function_prototype(\n      llvm::dyn_cast<clang::FunctionProtoType>(method_type));\n\n  if (!method_function_prototype)\n    return nullptr;\n\n  const bool isInstance = (name[0] == '-');\n  const bool isVariadic = is_variadic;\n  const bool isPropertyAccessor = false;\n  const bool isSynthesizedAccessorStub = false;\n  /// Force this to true because we don't have source locations.\n  const bool isImplicitlyDeclared = true;\n  const bool isDefined = false;\n  const clang::ObjCMethodDecl::ImplementationControl impControl =\n      clang::ObjCMethodDecl::None;\n  const bool HasRelatedResultType = false;\n\n  const unsigned num_args = method_function_prototype->getNumParams();\n\n  if (num_args != num_selectors_with_args)\n    return nullptr; // some debug information is corrupt.  We are not going to\n                    // deal with it.\n\n  auto *objc_method_decl = clang::ObjCMethodDecl::CreateDeserialized(ast, 0);\n  objc_method_decl->setDeclName(method_selector);\n  objc_method_decl->setReturnType(method_function_prototype->getReturnType());\n  objc_method_decl->setDeclContext(\n      lldb_ast->GetDeclContextForType(ClangUtil::GetQualType(type)));\n  objc_method_decl->setInstanceMethod(isInstance);\n  objc_method_decl->setVariadic(isVariadic);\n  objc_method_decl->setPropertyAccessor(isPropertyAccessor);\n  objc_method_decl->setSynthesizedAccessorStub(isSynthesizedAccessorStub);\n  objc_method_decl->setImplicit(isImplicitlyDeclared);\n  objc_method_decl->setDefined(isDefined);\n  objc_method_decl->setDeclImplementation(impControl);\n  objc_method_decl->setRelatedResultType(HasRelatedResultType);\n  SetMemberOwningModule(objc_method_decl, class_interface_decl);\n\n  if (objc_method_decl == nullptr)\n    return nullptr;\n\n  if (num_args > 0) {\n    llvm::SmallVector<clang::ParmVarDecl *, 12> params;\n\n    for (unsigned param_index = 0; param_index < num_args; ++param_index) {\n      params.push_back(clang::ParmVarDecl::Create(\n          ast, objc_method_decl, clang::SourceLocation(),\n          clang::SourceLocation(),\n          nullptr, // anonymous\n          method_function_prototype->getParamType(param_index), nullptr,\n          clang::SC_Auto, nullptr));\n    }\n\n    objc_method_decl->setMethodParams(\n        ast, llvm::ArrayRef<clang::ParmVarDecl *>(params),\n        llvm::ArrayRef<clang::SourceLocation>());\n  }\n\n  if (is_objc_direct_call) {\n    // Add a the objc_direct attribute to the declaration we generate that\n    // we generate a direct method call for this ObjCMethodDecl.\n    objc_method_decl->addAttr(\n        clang::ObjCDirectAttr::CreateImplicit(ast, SourceLocation()));\n    // Usually Sema is creating implicit parameters (e.g., self) when it\n    // parses the method. We don't have a parsing Sema when we build our own\n    // AST here so we manually need to create these implicit parameters to\n    // make the direct call code generation happy.\n    objc_method_decl->createImplicitParams(ast, class_interface_decl);\n  }\n\n  class_interface_decl->addDecl(objc_method_decl);\n\n  VerifyDecl(objc_method_decl);\n\n  return objc_method_decl;\n}\n\nbool TypeSystemClang::SetHasExternalStorage(lldb::opaque_compiler_type_t type,\n                                            bool has_extern) {\n  if (!type)\n    return false;\n\n  clang::QualType qual_type(RemoveWrappingTypes(GetCanonicalQualType(type)));\n\n  const clang::Type::TypeClass type_class = qual_type->getTypeClass();\n  switch (type_class) {\n  case clang::Type::Record: {\n    clang::CXXRecordDecl *cxx_record_decl = qual_type->getAsCXXRecordDecl();\n    if (cxx_record_decl) {\n      cxx_record_decl->setHasExternalLexicalStorage(has_extern);\n      cxx_record_decl->setHasExternalVisibleStorage(has_extern);\n      return true;\n    }\n  } break;\n\n  case clang::Type::Enum: {\n    clang::EnumDecl *enum_decl =\n        llvm::cast<clang::EnumType>(qual_type)->getDecl();\n    if (enum_decl) {\n      enum_decl->setHasExternalLexicalStorage(has_extern);\n      enum_decl->setHasExternalVisibleStorage(has_extern);\n      return true;\n    }\n  } break;\n\n  case clang::Type::ObjCObject:\n  case clang::Type::ObjCInterface: {\n    const clang::ObjCObjectType *objc_class_type =\n        llvm::dyn_cast<clang::ObjCObjectType>(qual_type.getTypePtr());\n    assert(objc_class_type);\n    if (objc_class_type) {\n      clang::ObjCInterfaceDecl *class_interface_decl =\n          objc_class_type->getInterface();\n\n      if (class_interface_decl) {\n        class_interface_decl->setHasExternalLexicalStorage(has_extern);\n        class_interface_decl->setHasExternalVisibleStorage(has_extern);\n        return true;\n      }\n    }\n  } break;\n\n  default:\n    break;\n  }\n  return false;\n}\n\n#pragma mark TagDecl\n\nbool TypeSystemClang::StartTagDeclarationDefinition(const CompilerType &type) {\n  clang::QualType qual_type(ClangUtil::GetQualType(type));\n  if (!qual_type.isNull()) {\n    const clang::TagType *tag_type = qual_type->getAs<clang::TagType>();\n    if (tag_type) {\n      clang::TagDecl *tag_decl = tag_type->getDecl();\n      if (tag_decl) {\n        tag_decl->startDefinition();\n        return true;\n      }\n    }\n\n    const clang::ObjCObjectType *object_type =\n        qual_type->getAs<clang::ObjCObjectType>();\n    if (object_type) {\n      clang::ObjCInterfaceDecl *interface_decl = object_type->getInterface();\n      if (interface_decl) {\n        interface_decl->startDefinition();\n        return true;\n      }\n    }\n  }\n  return false;\n}\n\nbool TypeSystemClang::CompleteTagDeclarationDefinition(\n    const CompilerType &type) {\n  clang::QualType qual_type(ClangUtil::GetQualType(type));\n  if (qual_type.isNull())\n    return false;\n\n  // Make sure we use the same methodology as\n  // TypeSystemClang::StartTagDeclarationDefinition() as to how we start/end\n  // the definition.\n  const clang::TagType *tag_type = qual_type->getAs<clang::TagType>();\n  if (tag_type) {\n    clang::TagDecl *tag_decl = tag_type->getDecl();\n\n    if (auto *cxx_record_decl = llvm::dyn_cast<CXXRecordDecl>(tag_decl)) {\n      // If we have a move constructor declared but no copy constructor we\n      // need to explicitly mark it as deleted. Usually Sema would do this for\n      // us in Sema::DeclareImplicitCopyConstructor but we don't have a Sema\n      // when building an AST from debug information.\n      // See also:\n      // C++11 [class.copy]p7, p18:\n      //  If the class definition declares a move constructor or move assignment\n      //  operator, an implicitly declared copy constructor or copy assignment\n      //  operator is defined as deleted.\n      if (cxx_record_decl->hasUserDeclaredMoveConstructor() ||\n          cxx_record_decl->hasUserDeclaredMoveAssignment()) {\n        if (cxx_record_decl->needsImplicitCopyConstructor())\n          cxx_record_decl->setImplicitCopyConstructorIsDeleted();\n        if (cxx_record_decl->needsImplicitCopyAssignment())\n          cxx_record_decl->setImplicitCopyAssignmentIsDeleted();\n      }\n\n      if (!cxx_record_decl->isCompleteDefinition())\n        cxx_record_decl->completeDefinition();\n      cxx_record_decl->setHasLoadedFieldsFromExternalStorage(true);\n      cxx_record_decl->setHasExternalLexicalStorage(false);\n      cxx_record_decl->setHasExternalVisibleStorage(false);\n      return true;\n    }\n  }\n\n  const clang::EnumType *enutype = qual_type->getAs<clang::EnumType>();\n\n  if (!enutype)\n    return false;\n  clang::EnumDecl *enum_decl = enutype->getDecl();\n\n  if (enum_decl->isCompleteDefinition())\n    return true;\n\n  TypeSystemClang *lldb_ast =\n      llvm::dyn_cast<TypeSystemClang>(type.GetTypeSystem());\n  if (lldb_ast == nullptr)\n    return false;\n  clang::ASTContext &ast = lldb_ast->getASTContext();\n\n  /// TODO This really needs to be fixed.\n\n  QualType integer_type(enum_decl->getIntegerType());\n  if (!integer_type.isNull()) {\n    unsigned NumPositiveBits = 1;\n    unsigned NumNegativeBits = 0;\n\n    clang::QualType promotion_qual_type;\n    // If the enum integer type is less than an integer in bit width,\n    // then we must promote it to an integer size.\n    if (ast.getTypeSize(enum_decl->getIntegerType()) <\n        ast.getTypeSize(ast.IntTy)) {\n      if (enum_decl->getIntegerType()->isSignedIntegerType())\n        promotion_qual_type = ast.IntTy;\n      else\n        promotion_qual_type = ast.UnsignedIntTy;\n    } else\n      promotion_qual_type = enum_decl->getIntegerType();\n\n    enum_decl->completeDefinition(enum_decl->getIntegerType(),\n                                  promotion_qual_type, NumPositiveBits,\n                                  NumNegativeBits);\n  }\n  return true;\n}\n\nclang::EnumConstantDecl *TypeSystemClang::AddEnumerationValueToEnumerationType(\n    const CompilerType &enum_type, const Declaration &decl, const char *name,\n    const llvm::APSInt &value) {\n\n  if (!enum_type || ConstString(name).IsEmpty())\n    return nullptr;\n\n  lldbassert(enum_type.GetTypeSystem() == static_cast<TypeSystem *>(this));\n\n  lldb::opaque_compiler_type_t enum_opaque_compiler_type =\n      enum_type.GetOpaqueQualType();\n\n  if (!enum_opaque_compiler_type)\n    return nullptr;\n\n  clang::QualType enum_qual_type(\n      GetCanonicalQualType(enum_opaque_compiler_type));\n\n  const clang::Type *clang_type = enum_qual_type.getTypePtr();\n\n  if (!clang_type)\n    return nullptr;\n\n  const clang::EnumType *enutype = llvm::dyn_cast<clang::EnumType>(clang_type);\n\n  if (!enutype)\n    return nullptr;\n\n  clang::EnumConstantDecl *enumerator_decl =\n      clang::EnumConstantDecl::CreateDeserialized(getASTContext(), 0);\n  enumerator_decl->setDeclContext(enutype->getDecl());\n  if (name && name[0])\n    enumerator_decl->setDeclName(&getASTContext().Idents.get(name));\n  enumerator_decl->setType(clang::QualType(enutype, 0));\n  enumerator_decl->setInitVal(value);\n  SetMemberOwningModule(enumerator_decl, enutype->getDecl());\n\n  if (!enumerator_decl)\n    return nullptr;\n\n  enutype->getDecl()->addDecl(enumerator_decl);\n\n  VerifyDecl(enumerator_decl);\n  return enumerator_decl;\n}\n\nclang::EnumConstantDecl *TypeSystemClang::AddEnumerationValueToEnumerationType(\n    const CompilerType &enum_type, const Declaration &decl, const char *name,\n    int64_t enum_value, uint32_t enum_value_bit_size) {\n  CompilerType underlying_type = GetEnumerationIntegerType(enum_type);\n  bool is_signed = false;\n  underlying_type.IsIntegerType(is_signed);\n\n  llvm::APSInt value(enum_value_bit_size, is_signed);\n  value = enum_value;\n\n  return AddEnumerationValueToEnumerationType(enum_type, decl, name, value);\n}\n\nCompilerType TypeSystemClang::GetEnumerationIntegerType(CompilerType type) {\n  clang::QualType qt(ClangUtil::GetQualType(type));\n  const clang::Type *clang_type = qt.getTypePtrOrNull();\n  const auto *enum_type = llvm::dyn_cast_or_null<clang::EnumType>(clang_type);\n  if (!enum_type)\n    return CompilerType();\n\n  return GetType(enum_type->getDecl()->getIntegerType());\n}\n\nCompilerType\nTypeSystemClang::CreateMemberPointerType(const CompilerType &type,\n                                         const CompilerType &pointee_type) {\n  if (type && pointee_type.IsValid() &&\n      type.GetTypeSystem() == pointee_type.GetTypeSystem()) {\n    TypeSystemClang *ast =\n        llvm::dyn_cast<TypeSystemClang>(type.GetTypeSystem());\n    if (!ast)\n      return CompilerType();\n    return ast->GetType(ast->getASTContext().getMemberPointerType(\n        ClangUtil::GetQualType(pointee_type),\n        ClangUtil::GetQualType(type).getTypePtr()));\n  }\n  return CompilerType();\n}\n\n// Dumping types\n#define DEPTH_INCREMENT 2\n\n#ifndef NDEBUG\nLLVM_DUMP_METHOD void\nTypeSystemClang::dump(lldb::opaque_compiler_type_t type) const {\n  if (!type)\n    return;\n  clang::QualType qual_type(GetQualType(type));\n  qual_type.dump();\n}\n#endif\n\nvoid TypeSystemClang::Dump(Stream &s) {\n  Decl *tu = Decl::castFromDeclContext(GetTranslationUnitDecl());\n  tu->dump(s.AsRawOstream());\n}\n\nvoid TypeSystemClang::DumpFromSymbolFile(Stream &s,\n                                         llvm::StringRef symbol_name) {\n  SymbolFile *symfile = GetSymbolFile();\n\n  if (!symfile)\n    return;\n\n  lldb_private::TypeList type_list;\n  symfile->GetTypes(nullptr, eTypeClassAny, type_list);\n  size_t ntypes = type_list.GetSize();\n\n  for (size_t i = 0; i < ntypes; ++i) {\n    TypeSP type = type_list.GetTypeAtIndex(i);\n\n    if (!symbol_name.empty())\n      if (symbol_name != type->GetName().GetStringRef())\n        continue;\n\n    s << type->GetName().AsCString() << \"\\n\";\n\n    CompilerType full_type = type->GetFullCompilerType();\n    if (clang::TagDecl *tag_decl = GetAsTagDecl(full_type)) {\n      tag_decl->dump(s.AsRawOstream());\n      continue;\n    }\n    if (clang::TypedefNameDecl *typedef_decl = GetAsTypedefDecl(full_type)) {\n      typedef_decl->dump(s.AsRawOstream());\n      continue;\n    }\n    if (auto *objc_obj = llvm::dyn_cast<clang::ObjCObjectType>(\n            ClangUtil::GetQualType(full_type).getTypePtr())) {\n      if (clang::ObjCInterfaceDecl *interface_decl = objc_obj->getInterface()) {\n        interface_decl->dump(s.AsRawOstream());\n        continue;\n      }\n    }\n    GetCanonicalQualType(full_type.GetOpaqueQualType())\n        .dump(s.AsRawOstream(), getASTContext());\n  }\n}\n\nvoid TypeSystemClang::DumpValue(\n    lldb::opaque_compiler_type_t type, ExecutionContext *exe_ctx, Stream *s,\n    lldb::Format format, const lldb_private::DataExtractor &data,\n    lldb::offset_t data_byte_offset, size_t data_byte_size,\n    uint32_t bitfield_bit_size, uint32_t bitfield_bit_offset, bool show_types,\n    bool show_summary, bool verbose, uint32_t depth) {\n  if (!type)\n    return;\n\n  clang::QualType qual_type(GetQualType(type));\n  switch (qual_type->getTypeClass()) {\n  case clang::Type::Record:\n    if (GetCompleteType(type)) {\n      const clang::RecordType *record_type =\n          llvm::cast<clang::RecordType>(qual_type.getTypePtr());\n      const clang::RecordDecl *record_decl = record_type->getDecl();\n      assert(record_decl);\n      uint32_t field_bit_offset = 0;\n      uint32_t field_byte_offset = 0;\n      const clang::ASTRecordLayout &record_layout =\n          getASTContext().getASTRecordLayout(record_decl);\n      uint32_t child_idx = 0;\n\n      const clang::CXXRecordDecl *cxx_record_decl =\n          llvm::dyn_cast<clang::CXXRecordDecl>(record_decl);\n      if (cxx_record_decl) {\n        // We might have base classes to print out first\n        clang::CXXRecordDecl::base_class_const_iterator base_class,\n            base_class_end;\n        for (base_class = cxx_record_decl->bases_begin(),\n            base_class_end = cxx_record_decl->bases_end();\n             base_class != base_class_end; ++base_class) {\n          const clang::CXXRecordDecl *base_class_decl =\n              llvm::cast<clang::CXXRecordDecl>(\n                  base_class->getType()->getAs<clang::RecordType>()->getDecl());\n\n          // Skip empty base classes\n          if (!verbose && !TypeSystemClang::RecordHasFields(base_class_decl))\n            continue;\n\n          if (base_class->isVirtual())\n            field_bit_offset =\n                record_layout.getVBaseClassOffset(base_class_decl)\n                    .getQuantity() *\n                8;\n          else\n            field_bit_offset = record_layout.getBaseClassOffset(base_class_decl)\n                                   .getQuantity() *\n                               8;\n          field_byte_offset = field_bit_offset / 8;\n          assert(field_bit_offset % 8 == 0);\n          if (child_idx == 0)\n            s->PutChar('{');\n          else\n            s->PutChar(',');\n\n          clang::QualType base_class_qual_type = base_class->getType();\n          std::string base_class_type_name(base_class_qual_type.getAsString());\n\n          // Indent and print the base class type name\n          s->Format(\"\\n{0}{1}\", llvm::fmt_repeat(\" \", depth + DEPTH_INCREMENT),\n                    base_class_type_name);\n\n          clang::TypeInfo base_class_type_info =\n              getASTContext().getTypeInfo(base_class_qual_type);\n\n          // Dump the value of the member\n          CompilerType base_clang_type = GetType(base_class_qual_type);\n          base_clang_type.DumpValue(\n              exe_ctx,\n              s, // Stream to dump to\n              base_clang_type\n                  .GetFormat(), // The format with which to display the member\n              data, // Data buffer containing all bytes for this type\n              data_byte_offset + field_byte_offset, // Offset into \"data\" where\n                                                    // to grab value from\n              base_class_type_info.Width / 8, // Size of this type in bytes\n              0,                              // Bitfield bit size\n              0,                              // Bitfield bit offset\n              show_types,   // Boolean indicating if we should show the variable\n                            // types\n              show_summary, // Boolean indicating if we should show a summary\n                            // for the current type\n              verbose,      // Verbose output?\n              depth + DEPTH_INCREMENT); // Scope depth for any types that have\n                                        // children\n\n          ++child_idx;\n        }\n      }\n      uint32_t field_idx = 0;\n      clang::RecordDecl::field_iterator field, field_end;\n      for (field = record_decl->field_begin(),\n          field_end = record_decl->field_end();\n           field != field_end; ++field, ++field_idx, ++child_idx) {\n        // Print the starting squiggly bracket (if this is the first member) or\n        // comma (for member 2 and beyond) for the struct/union/class member.\n        if (child_idx == 0)\n          s->PutChar('{');\n        else\n          s->PutChar(',');\n\n        // Indent\n        s->Printf(\"\\n%*s\", depth + DEPTH_INCREMENT, \"\");\n\n        clang::QualType field_type = field->getType();\n        // Print the member type if requested\n        // Figure out the type byte size (field_type_info.first) and alignment\n        // (field_type_info.second) from the AST context.\n        clang::TypeInfo field_type_info =\n            getASTContext().getTypeInfo(field_type);\n        assert(field_idx < record_layout.getFieldCount());\n        // Figure out the field offset within the current struct/union/class\n        // type\n        field_bit_offset = record_layout.getFieldOffset(field_idx);\n        field_byte_offset = field_bit_offset / 8;\n        uint32_t field_bitfield_bit_size = 0;\n        uint32_t field_bitfield_bit_offset = 0;\n        if (FieldIsBitfield(*field, field_bitfield_bit_size))\n          field_bitfield_bit_offset = field_bit_offset % 8;\n\n        if (show_types) {\n          std::string field_type_name(field_type.getAsString());\n          if (field_bitfield_bit_size > 0)\n            s->Printf(\"(%s:%u) \", field_type_name.c_str(),\n                      field_bitfield_bit_size);\n          else\n            s->Printf(\"(%s) \", field_type_name.c_str());\n        }\n        // Print the member name and equal sign\n        s->Printf(\"%s = \", field->getNameAsString().c_str());\n\n        // Dump the value of the member\n        CompilerType field_clang_type = GetType(field_type);\n        field_clang_type.DumpValue(\n            exe_ctx,\n            s, // Stream to dump to\n            field_clang_type\n                .GetFormat(), // The format with which to display the member\n            data,             // Data buffer containing all bytes for this type\n            data_byte_offset + field_byte_offset, // Offset into \"data\" where to\n                                                  // grab value from\n            field_type_info.Width / 8,            // Size of this type in bytes\n            field_bitfield_bit_size,              // Bitfield bit size\n            field_bitfield_bit_offset,            // Bitfield bit offset\n            show_types,   // Boolean indicating if we should show the variable\n                          // types\n            show_summary, // Boolean indicating if we should show a summary for\n                          // the current type\n            verbose,      // Verbose output?\n            depth + DEPTH_INCREMENT); // Scope depth for any types that have\n                                      // children\n      }\n\n      // Indent the trailing squiggly bracket\n      if (child_idx > 0)\n        s->Printf(\"\\n%*s}\", depth, \"\");\n    }\n    return;\n\n  case clang::Type::Enum:\n    if (GetCompleteType(type)) {\n      const clang::EnumType *enutype =\n          llvm::cast<clang::EnumType>(qual_type.getTypePtr());\n      const clang::EnumDecl *enum_decl = enutype->getDecl();\n      assert(enum_decl);\n      clang::EnumDecl::enumerator_iterator enum_pos, enum_end_pos;\n      lldb::offset_t offset = data_byte_offset;\n      const int64_t enum_value = data.GetMaxU64Bitfield(\n          &offset, data_byte_size, bitfield_bit_size, bitfield_bit_offset);\n      for (enum_pos = enum_decl->enumerator_begin(),\n          enum_end_pos = enum_decl->enumerator_end();\n           enum_pos != enum_end_pos; ++enum_pos) {\n        if (enum_pos->getInitVal() == enum_value) {\n          s->Printf(\"%s\", enum_pos->getNameAsString().c_str());\n          return;\n        }\n      }\n      // If we have gotten here we didn't get find the enumerator in the enum\n      // decl, so just print the integer.\n      s->Printf(\"%\" PRIi64, enum_value);\n    }\n    return;\n\n  case clang::Type::ConstantArray: {\n    const clang::ConstantArrayType *array =\n        llvm::cast<clang::ConstantArrayType>(qual_type.getTypePtr());\n    bool is_array_of_characters = false;\n    clang::QualType element_qual_type = array->getElementType();\n\n    const clang::Type *canonical_type =\n        element_qual_type->getCanonicalTypeInternal().getTypePtr();\n    if (canonical_type)\n      is_array_of_characters = canonical_type->isCharType();\n\n    const uint64_t element_count = array->getSize().getLimitedValue();\n\n    clang::TypeInfo field_type_info =\n        getASTContext().getTypeInfo(element_qual_type);\n\n    uint32_t element_idx = 0;\n    uint32_t element_offset = 0;\n    uint64_t element_byte_size = field_type_info.Width / 8;\n    uint32_t element_stride = element_byte_size;\n\n    if (is_array_of_characters) {\n      s->PutChar('\"');\n      DumpDataExtractor(data, s, data_byte_offset, lldb::eFormatChar,\n                        element_byte_size, element_count, UINT32_MAX,\n                        LLDB_INVALID_ADDRESS, 0, 0);\n      s->PutChar('\"');\n      return;\n    } else {\n      CompilerType element_clang_type = GetType(element_qual_type);\n      lldb::Format element_format = element_clang_type.GetFormat();\n\n      for (element_idx = 0; element_idx < element_count; ++element_idx) {\n        // Print the starting squiggly bracket (if this is the first member) or\n        // comman (for member 2 and beyong) for the struct/union/class member.\n        if (element_idx == 0)\n          s->PutChar('{');\n        else\n          s->PutChar(',');\n\n        // Indent and print the index\n        s->Printf(\"\\n%*s[%u] \", depth + DEPTH_INCREMENT, \"\", element_idx);\n\n        // Figure out the field offset within the current struct/union/class\n        // type\n        element_offset = element_idx * element_stride;\n\n        // Dump the value of the member\n        element_clang_type.DumpValue(\n            exe_ctx,\n            s,              // Stream to dump to\n            element_format, // The format with which to display the element\n            data,           // Data buffer containing all bytes for this type\n            data_byte_offset +\n                element_offset, // Offset into \"data\" where to grab value from\n            element_byte_size,  // Size of this type in bytes\n            0,                  // Bitfield bit size\n            0,                  // Bitfield bit offset\n            show_types,   // Boolean indicating if we should show the variable\n                          // types\n            show_summary, // Boolean indicating if we should show a summary for\n                          // the current type\n            verbose,      // Verbose output?\n            depth + DEPTH_INCREMENT); // Scope depth for any types that have\n                                      // children\n      }\n\n      // Indent the trailing squiggly bracket\n      if (element_idx > 0)\n        s->Printf(\"\\n%*s}\", depth, \"\");\n    }\n  }\n    return;\n\n  case clang::Type::Typedef: {\n    clang::QualType typedef_qual_type =\n        llvm::cast<clang::TypedefType>(qual_type)\n            ->getDecl()\n            ->getUnderlyingType();\n\n    CompilerType typedef_clang_type = GetType(typedef_qual_type);\n    lldb::Format typedef_format = typedef_clang_type.GetFormat();\n    clang::TypeInfo typedef_type_info =\n        getASTContext().getTypeInfo(typedef_qual_type);\n    uint64_t typedef_byte_size = typedef_type_info.Width / 8;\n\n    return typedef_clang_type.DumpValue(\n        exe_ctx,\n        s,                   // Stream to dump to\n        typedef_format,      // The format with which to display the element\n        data,                // Data buffer containing all bytes for this type\n        data_byte_offset,    // Offset into \"data\" where to grab value from\n        typedef_byte_size,   // Size of this type in bytes\n        bitfield_bit_size,   // Bitfield bit size\n        bitfield_bit_offset, // Bitfield bit offset\n        show_types,   // Boolean indicating if we should show the variable types\n        show_summary, // Boolean indicating if we should show a summary for the\n                      // current type\n        verbose,      // Verbose output?\n        depth);       // Scope depth for any types that have children\n  } break;\n\n  case clang::Type::Auto: {\n    clang::QualType elaborated_qual_type =\n        llvm::cast<clang::AutoType>(qual_type)->getDeducedType();\n    CompilerType elaborated_clang_type = GetType(elaborated_qual_type);\n    lldb::Format elaborated_format = elaborated_clang_type.GetFormat();\n    clang::TypeInfo elaborated_type_info =\n        getASTContext().getTypeInfo(elaborated_qual_type);\n    uint64_t elaborated_byte_size = elaborated_type_info.Width / 8;\n\n    return elaborated_clang_type.DumpValue(\n        exe_ctx,\n        s,                    // Stream to dump to\n        elaborated_format,    // The format with which to display the element\n        data,                 // Data buffer containing all bytes for this type\n        data_byte_offset,     // Offset into \"data\" where to grab value from\n        elaborated_byte_size, // Size of this type in bytes\n        bitfield_bit_size,    // Bitfield bit size\n        bitfield_bit_offset,  // Bitfield bit offset\n        show_types,   // Boolean indicating if we should show the variable types\n        show_summary, // Boolean indicating if we should show a summary for the\n                      // current type\n        verbose,      // Verbose output?\n        depth);       // Scope depth for any types that have children\n  } break;\n\n  case clang::Type::Elaborated: {\n    clang::QualType elaborated_qual_type =\n        llvm::cast<clang::ElaboratedType>(qual_type)->getNamedType();\n    CompilerType elaborated_clang_type = GetType(elaborated_qual_type);\n    lldb::Format elaborated_format = elaborated_clang_type.GetFormat();\n    clang::TypeInfo elaborated_type_info =\n        getASTContext().getTypeInfo(elaborated_qual_type);\n    uint64_t elaborated_byte_size = elaborated_type_info.Width / 8;\n\n    return elaborated_clang_type.DumpValue(\n        exe_ctx,\n        s,                    // Stream to dump to\n        elaborated_format,    // The format with which to display the element\n        data,                 // Data buffer containing all bytes for this type\n        data_byte_offset,     // Offset into \"data\" where to grab value from\n        elaborated_byte_size, // Size of this type in bytes\n        bitfield_bit_size,    // Bitfield bit size\n        bitfield_bit_offset,  // Bitfield bit offset\n        show_types,   // Boolean indicating if we should show the variable types\n        show_summary, // Boolean indicating if we should show a summary for the\n                      // current type\n        verbose,      // Verbose output?\n        depth);       // Scope depth for any types that have children\n  } break;\n\n  case clang::Type::Paren: {\n    clang::QualType desugar_qual_type =\n        llvm::cast<clang::ParenType>(qual_type)->desugar();\n    CompilerType desugar_clang_type = GetType(desugar_qual_type);\n\n    lldb::Format desugar_format = desugar_clang_type.GetFormat();\n    clang::TypeInfo desugar_type_info =\n        getASTContext().getTypeInfo(desugar_qual_type);\n    uint64_t desugar_byte_size = desugar_type_info.Width / 8;\n\n    return desugar_clang_type.DumpValue(\n        exe_ctx,\n        s,                   // Stream to dump to\n        desugar_format,      // The format with which to display the element\n        data,                // Data buffer containing all bytes for this type\n        data_byte_offset,    // Offset into \"data\" where to grab value from\n        desugar_byte_size,   // Size of this type in bytes\n        bitfield_bit_size,   // Bitfield bit size\n        bitfield_bit_offset, // Bitfield bit offset\n        show_types,   // Boolean indicating if we should show the variable types\n        show_summary, // Boolean indicating if we should show a summary for the\n                      // current type\n        verbose,      // Verbose output?\n        depth);       // Scope depth for any types that have children\n  } break;\n\n  default:\n    // We are down to a scalar type that we just need to display.\n    DumpDataExtractor(data, s, data_byte_offset, format, data_byte_size, 1,\n                      UINT32_MAX, LLDB_INVALID_ADDRESS, bitfield_bit_size,\n                      bitfield_bit_offset);\n\n    if (show_summary)\n      DumpSummary(type, exe_ctx, s, data, data_byte_offset, data_byte_size);\n    break;\n  }\n}\n\nstatic bool DumpEnumValue(const clang::QualType &qual_type, Stream *s,\n                          const DataExtractor &data, lldb::offset_t byte_offset,\n                          size_t byte_size, uint32_t bitfield_bit_offset,\n                          uint32_t bitfield_bit_size) {\n  const clang::EnumType *enutype =\n      llvm::cast<clang::EnumType>(qual_type.getTypePtr());\n  const clang::EnumDecl *enum_decl = enutype->getDecl();\n  assert(enum_decl);\n  lldb::offset_t offset = byte_offset;\n  const uint64_t enum_svalue = data.GetMaxS64Bitfield(\n      &offset, byte_size, bitfield_bit_size, bitfield_bit_offset);\n  bool can_be_bitfield = true;\n  uint64_t covered_bits = 0;\n  int num_enumerators = 0;\n\n  // Try to find an exact match for the value.\n  // At the same time, we're applying a heuristic to determine whether we want\n  // to print this enum as a bitfield. We're likely dealing with a bitfield if\n  // every enumerator is either a one bit value or a superset of the previous\n  // enumerators. Also 0 doesn't make sense when the enumerators are used as\n  // flags.\n  for (auto *enumerator : enum_decl->enumerators()) {\n    uint64_t val = enumerator->getInitVal().getSExtValue();\n    val = llvm::SignExtend64(val, 8*byte_size);\n    if (llvm::countPopulation(val) != 1 && (val & ~covered_bits) != 0)\n      can_be_bitfield = false;\n    covered_bits |= val;\n    ++num_enumerators;\n    if (val == enum_svalue) {\n      // Found an exact match, that's all we need to do.\n      s->PutCString(enumerator->getNameAsString());\n      return true;\n    }\n  }\n\n  // Unsigned values make more sense for flags.\n  offset = byte_offset;\n  const uint64_t enum_uvalue = data.GetMaxU64Bitfield(\n      &offset, byte_size, bitfield_bit_size, bitfield_bit_offset);\n\n  // No exact match, but we don't think this is a bitfield. Print the value as\n  // decimal.\n  if (!can_be_bitfield) {\n    if (qual_type->isSignedIntegerOrEnumerationType())\n      s->Printf(\"%\" PRIi64, enum_svalue);\n    else\n      s->Printf(\"%\" PRIu64, enum_uvalue);\n    return true;\n  }\n\n  uint64_t remaining_value = enum_uvalue;\n  std::vector<std::pair<uint64_t, llvm::StringRef>> values;\n  values.reserve(num_enumerators);\n  for (auto *enumerator : enum_decl->enumerators())\n    if (auto val = enumerator->getInitVal().getZExtValue())\n      values.emplace_back(val, enumerator->getName());\n\n  // Sort in reverse order of the number of the population count,  so that in\n  // `enum {A, B, ALL = A|B }` we visit ALL first. Use a stable sort so that\n  // A | C where A is declared before C is displayed in this order.\n  std::stable_sort(values.begin(), values.end(), [](const auto &a, const auto &b) {\n        return llvm::countPopulation(a.first) > llvm::countPopulation(b.first);\n      });\n\n  for (const auto &val : values) {\n    if ((remaining_value & val.first) != val.first)\n      continue;\n    remaining_value &= ~val.first;\n    s->PutCString(val.second);\n    if (remaining_value)\n      s->PutCString(\" | \");\n  }\n\n  // If there is a remainder that is not covered by the value, print it as hex.\n  if (remaining_value)\n    s->Printf(\"0x%\" PRIx64, remaining_value);\n\n  return true;\n}\n\nbool TypeSystemClang::DumpTypeValue(\n    lldb::opaque_compiler_type_t type, Stream *s, lldb::Format format,\n    const lldb_private::DataExtractor &data, lldb::offset_t byte_offset,\n    size_t byte_size, uint32_t bitfield_bit_size, uint32_t bitfield_bit_offset,\n    ExecutionContextScope *exe_scope) {\n  if (!type)\n    return false;\n  if (IsAggregateType(type)) {\n    return false;\n  } else {\n    clang::QualType qual_type(GetQualType(type));\n\n    const clang::Type::TypeClass type_class = qual_type->getTypeClass();\n\n    if (type_class == clang::Type::Elaborated) {\n      qual_type = llvm::cast<clang::ElaboratedType>(qual_type)->getNamedType();\n      return DumpTypeValue(qual_type.getAsOpaquePtr(), s, format, data, byte_offset, byte_size,\n                           bitfield_bit_size, bitfield_bit_offset, exe_scope);\n    }\n\n    switch (type_class) {\n    case clang::Type::Typedef: {\n      clang::QualType typedef_qual_type =\n          llvm::cast<clang::TypedefType>(qual_type)\n              ->getDecl()\n              ->getUnderlyingType();\n      CompilerType typedef_clang_type = GetType(typedef_qual_type);\n      if (format == eFormatDefault)\n        format = typedef_clang_type.GetFormat();\n      clang::TypeInfo typedef_type_info =\n          getASTContext().getTypeInfo(typedef_qual_type);\n      uint64_t typedef_byte_size = typedef_type_info.Width / 8;\n\n      return typedef_clang_type.DumpTypeValue(\n          s,\n          format,            // The format with which to display the element\n          data,              // Data buffer containing all bytes for this type\n          byte_offset,       // Offset into \"data\" where to grab value from\n          typedef_byte_size, // Size of this type in bytes\n          bitfield_bit_size, // Size in bits of a bitfield value, if zero don't\n                             // treat as a bitfield\n          bitfield_bit_offset, // Offset in bits of a bitfield value if\n                               // bitfield_bit_size != 0\n          exe_scope);\n    } break;\n\n    case clang::Type::Enum:\n      // If our format is enum or default, show the enumeration value as its\n      // enumeration string value, else just display it as requested.\n      if ((format == eFormatEnum || format == eFormatDefault) &&\n          GetCompleteType(type))\n        return DumpEnumValue(qual_type, s, data, byte_offset, byte_size,\n                             bitfield_bit_offset, bitfield_bit_size);\n      // format was not enum, just fall through and dump the value as\n      // requested....\n      LLVM_FALLTHROUGH;\n\n    default:\n      // We are down to a scalar type that we just need to display.\n      {\n        uint32_t item_count = 1;\n        // A few formats, we might need to modify our size and count for\n        // depending\n        // on how we are trying to display the value...\n        switch (format) {\n        default:\n        case eFormatBoolean:\n        case eFormatBinary:\n        case eFormatComplex:\n        case eFormatCString: // NULL terminated C strings\n        case eFormatDecimal:\n        case eFormatEnum:\n        case eFormatHex:\n        case eFormatHexUppercase:\n        case eFormatFloat:\n        case eFormatOctal:\n        case eFormatOSType:\n        case eFormatUnsigned:\n        case eFormatPointer:\n        case eFormatVectorOfChar:\n        case eFormatVectorOfSInt8:\n        case eFormatVectorOfUInt8:\n        case eFormatVectorOfSInt16:\n        case eFormatVectorOfUInt16:\n        case eFormatVectorOfSInt32:\n        case eFormatVectorOfUInt32:\n        case eFormatVectorOfSInt64:\n        case eFormatVectorOfUInt64:\n        case eFormatVectorOfFloat32:\n        case eFormatVectorOfFloat64:\n        case eFormatVectorOfUInt128:\n          break;\n\n        case eFormatChar:\n        case eFormatCharPrintable:\n        case eFormatCharArray:\n        case eFormatBytes:\n        case eFormatBytesWithASCII:\n          item_count = byte_size;\n          byte_size = 1;\n          break;\n\n        case eFormatUnicode16:\n          item_count = byte_size / 2;\n          byte_size = 2;\n          break;\n\n        case eFormatUnicode32:\n          item_count = byte_size / 4;\n          byte_size = 4;\n          break;\n        }\n        return DumpDataExtractor(data, s, byte_offset, format, byte_size,\n                                 item_count, UINT32_MAX, LLDB_INVALID_ADDRESS,\n                                 bitfield_bit_size, bitfield_bit_offset,\n                                 exe_scope);\n      }\n      break;\n    }\n  }\n  return false;\n}\n\nvoid TypeSystemClang::DumpSummary(lldb::opaque_compiler_type_t type,\n                                  ExecutionContext *exe_ctx, Stream *s,\n                                  const lldb_private::DataExtractor &data,\n                                  lldb::offset_t data_byte_offset,\n                                  size_t data_byte_size) {\n  uint32_t length = 0;\n  if (IsCStringType(type, length)) {\n    if (exe_ctx) {\n      Process *process = exe_ctx->GetProcessPtr();\n      if (process) {\n        lldb::offset_t offset = data_byte_offset;\n        lldb::addr_t pointer_address = data.GetMaxU64(&offset, data_byte_size);\n        std::vector<uint8_t> buf;\n        if (length > 0)\n          buf.resize(length);\n        else\n          buf.resize(256);\n\n        DataExtractor cstr_data(&buf.front(), buf.size(),\n                                process->GetByteOrder(), 4);\n        buf.back() = '\\0';\n        size_t bytes_read;\n        size_t total_cstr_len = 0;\n        Status error;\n        while ((bytes_read = process->ReadMemory(pointer_address, &buf.front(),\n                                                 buf.size(), error)) > 0) {\n          const size_t len = strlen((const char *)&buf.front());\n          if (len == 0)\n            break;\n          if (total_cstr_len == 0)\n            s->PutCString(\" \\\"\");\n          DumpDataExtractor(cstr_data, s, 0, lldb::eFormatChar, 1, len,\n                            UINT32_MAX, LLDB_INVALID_ADDRESS, 0, 0);\n          total_cstr_len += len;\n          if (len < buf.size())\n            break;\n          pointer_address += total_cstr_len;\n        }\n        if (total_cstr_len > 0)\n          s->PutChar('\"');\n      }\n    }\n  }\n}\n\nvoid TypeSystemClang::DumpTypeDescription(lldb::opaque_compiler_type_t type,\n                                          lldb::DescriptionLevel level) {\n  StreamFile s(stdout, false);\n  DumpTypeDescription(type, &s, level);\n\n  CompilerType ct(this, type);\n  const clang::Type *clang_type = ClangUtil::GetQualType(ct).getTypePtr();\n  ClangASTMetadata *metadata = GetMetadata(clang_type);\n  if (metadata) {\n    metadata->Dump(&s);\n  }\n}\n\nvoid TypeSystemClang::DumpTypeDescription(lldb::opaque_compiler_type_t type,\n                                          Stream *s,\n                                          lldb::DescriptionLevel level) {\n  if (type) {\n    clang::QualType qual_type =\n        RemoveWrappingTypes(GetQualType(type), {clang::Type::Typedef});\n\n    llvm::SmallVector<char, 1024> buf;\n    llvm::raw_svector_ostream llvm_ostrm(buf);\n\n    const clang::Type::TypeClass type_class = qual_type->getTypeClass();\n    switch (type_class) {\n    case clang::Type::ObjCObject:\n    case clang::Type::ObjCInterface: {\n      GetCompleteType(type);\n\n      auto *objc_class_type =\n          llvm::dyn_cast<clang::ObjCObjectType>(qual_type.getTypePtr());\n      assert(objc_class_type);\n      if (!objc_class_type)\n        break;\n      clang::ObjCInterfaceDecl *class_interface_decl =\n            objc_class_type->getInterface();\n      if (!class_interface_decl)\n        break;\n      if (level == eDescriptionLevelVerbose)\n        class_interface_decl->dump(llvm_ostrm);\n      else\n        class_interface_decl->print(llvm_ostrm,\n                                    getASTContext().getPrintingPolicy(),\n                                    s->GetIndentLevel());\n    } break;\n\n    case clang::Type::Typedef: {\n      auto *typedef_type = qual_type->getAs<clang::TypedefType>();\n      if (!typedef_type)\n        break;\n      const clang::TypedefNameDecl *typedef_decl = typedef_type->getDecl();\n      if (level == eDescriptionLevelVerbose)\n        typedef_decl->dump(llvm_ostrm);\n      else {\n        std::string clang_typedef_name(GetTypeNameForDecl(typedef_decl));\n        if (!clang_typedef_name.empty()) {\n          s->PutCString(\"typedef \");\n          s->PutCString(clang_typedef_name);\n        }\n      }\n    } break;\n\n    case clang::Type::Record: {\n      GetCompleteType(type);\n\n      auto *record_type = llvm::cast<clang::RecordType>(qual_type.getTypePtr());\n      const clang::RecordDecl *record_decl = record_type->getDecl();\n      if (level == eDescriptionLevelVerbose)\n        record_decl->dump(llvm_ostrm);\n      else {\n        if (auto *cxx_record_decl =\n                llvm::dyn_cast<clang::CXXRecordDecl>(record_decl))\n          cxx_record_decl->print(llvm_ostrm,\n                                 getASTContext().getPrintingPolicy(),\n                                 s->GetIndentLevel());\n        else\n          record_decl->print(llvm_ostrm, getASTContext().getPrintingPolicy(),\n                             s->GetIndentLevel());\n      }\n    } break;\n\n    default: {\n      if (auto *tag_type =\n              llvm::dyn_cast<clang::TagType>(qual_type.getTypePtr())) {\n        if (clang::TagDecl *tag_decl = tag_type->getDecl()) {\n          if (level == eDescriptionLevelVerbose)\n            tag_decl->dump(llvm_ostrm);\n          else\n            tag_decl->print(llvm_ostrm, 0);\n        }\n      } else {\n        if (level == eDescriptionLevelVerbose)\n          qual_type->dump(llvm_ostrm, getASTContext());\n        else {\n          std::string clang_type_name(qual_type.getAsString());\n          if (!clang_type_name.empty())\n            s->PutCString(clang_type_name);\n        }\n      }\n    }\n    }\n\n    if (buf.size() > 0) {\n      s->Write(buf.data(), buf.size());\n    }\n}\n}\n\nvoid TypeSystemClang::DumpTypeName(const CompilerType &type) {\n  if (ClangUtil::IsClangType(type)) {\n    clang::QualType qual_type(\n        ClangUtil::GetCanonicalQualType(ClangUtil::RemoveFastQualifiers(type)));\n\n    const clang::Type::TypeClass type_class = qual_type->getTypeClass();\n    switch (type_class) {\n    case clang::Type::Record: {\n      const clang::CXXRecordDecl *cxx_record_decl =\n          qual_type->getAsCXXRecordDecl();\n      if (cxx_record_decl)\n        printf(\"class %s\", cxx_record_decl->getName().str().c_str());\n    } break;\n\n    case clang::Type::Enum: {\n      clang::EnumDecl *enum_decl =\n          llvm::cast<clang::EnumType>(qual_type)->getDecl();\n      if (enum_decl) {\n        printf(\"enum %s\", enum_decl->getName().str().c_str());\n      }\n    } break;\n\n    case clang::Type::ObjCObject:\n    case clang::Type::ObjCInterface: {\n      const clang::ObjCObjectType *objc_class_type =\n          llvm::dyn_cast<clang::ObjCObjectType>(qual_type);\n      if (objc_class_type) {\n        clang::ObjCInterfaceDecl *class_interface_decl =\n            objc_class_type->getInterface();\n        // We currently can't complete objective C types through the newly\n        // added ASTContext because it only supports TagDecl objects right\n        // now...\n        if (class_interface_decl)\n          printf(\"@class %s\", class_interface_decl->getName().str().c_str());\n      }\n    } break;\n\n    case clang::Type::Typedef:\n      printf(\"typedef %s\", llvm::cast<clang::TypedefType>(qual_type)\n                               ->getDecl()\n                               ->getName()\n                               .str()\n                               .c_str());\n      break;\n\n    case clang::Type::Auto:\n      printf(\"auto \");\n      return DumpTypeName(CompilerType(type.GetTypeSystem(),\n                                       llvm::cast<clang::AutoType>(qual_type)\n                                           ->getDeducedType()\n                                           .getAsOpaquePtr()));\n\n    case clang::Type::Elaborated:\n      printf(\"elaborated \");\n      return DumpTypeName(CompilerType(\n          type.GetTypeSystem(), llvm::cast<clang::ElaboratedType>(qual_type)\n                                    ->getNamedType()\n                                    .getAsOpaquePtr()));\n\n    case clang::Type::Paren:\n      printf(\"paren \");\n      return DumpTypeName(CompilerType(\n          type.GetTypeSystem(),\n          llvm::cast<clang::ParenType>(qual_type)->desugar().getAsOpaquePtr()));\n\n    default:\n      printf(\"TypeSystemClang::DumpTypeName() type_class = %u\", type_class);\n      break;\n    }\n  }\n}\n\nclang::ClassTemplateDecl *TypeSystemClang::ParseClassTemplateDecl(\n    clang::DeclContext *decl_ctx, OptionalClangModuleID owning_module,\n    lldb::AccessType access_type, const char *parent_name, int tag_decl_kind,\n    const TypeSystemClang::TemplateParameterInfos &template_param_infos) {\n  if (template_param_infos.IsValid()) {\n    std::string template_basename(parent_name);\n    template_basename.erase(template_basename.find('<'));\n\n    return CreateClassTemplateDecl(decl_ctx, owning_module, access_type,\n                                   template_basename.c_str(), tag_decl_kind,\n                                   template_param_infos);\n  }\n  return nullptr;\n}\n\nvoid TypeSystemClang::CompleteTagDecl(clang::TagDecl *decl) {\n  SymbolFile *sym_file = GetSymbolFile();\n  if (sym_file) {\n    CompilerType clang_type = GetTypeForDecl(decl);\n    if (clang_type)\n      sym_file->CompleteType(clang_type);\n  }\n}\n\nvoid TypeSystemClang::CompleteObjCInterfaceDecl(\n    clang::ObjCInterfaceDecl *decl) {\n  SymbolFile *sym_file = GetSymbolFile();\n  if (sym_file) {\n    CompilerType clang_type = GetTypeForDecl(decl);\n    if (clang_type)\n      sym_file->CompleteType(clang_type);\n  }\n}\n\nDWARFASTParser *TypeSystemClang::GetDWARFParser() {\n  if (!m_dwarf_ast_parser_up)\n    m_dwarf_ast_parser_up = std::make_unique<DWARFASTParserClang>(*this);\n  return m_dwarf_ast_parser_up.get();\n}\n\nPDBASTParser *TypeSystemClang::GetPDBParser() {\n  if (!m_pdb_ast_parser_up)\n    m_pdb_ast_parser_up = std::make_unique<PDBASTParser>(*this);\n  return m_pdb_ast_parser_up.get();\n}\n\nbool TypeSystemClang::LayoutRecordType(\n    const clang::RecordDecl *record_decl, uint64_t &bit_size,\n    uint64_t &alignment,\n    llvm::DenseMap<const clang::FieldDecl *, uint64_t> &field_offsets,\n    llvm::DenseMap<const clang::CXXRecordDecl *, clang::CharUnits>\n        &base_offsets,\n    llvm::DenseMap<const clang::CXXRecordDecl *, clang::CharUnits>\n        &vbase_offsets) {\n  lldb_private::ClangASTImporter *importer = nullptr;\n  if (m_dwarf_ast_parser_up)\n    importer = &m_dwarf_ast_parser_up->GetClangASTImporter();\n  if (!importer && m_pdb_ast_parser_up)\n    importer = &m_pdb_ast_parser_up->GetClangASTImporter();\n  if (!importer)\n    return false;\n\n  return importer->LayoutRecordType(record_decl, bit_size, alignment,\n                                    field_offsets, base_offsets, vbase_offsets);\n}\n\n// CompilerDecl override functions\n\nConstString TypeSystemClang::DeclGetName(void *opaque_decl) {\n  if (opaque_decl) {\n    clang::NamedDecl *nd =\n        llvm::dyn_cast<NamedDecl>((clang::Decl *)opaque_decl);\n    if (nd != nullptr)\n      return ConstString(nd->getDeclName().getAsString());\n  }\n  return ConstString();\n}\n\nConstString TypeSystemClang::DeclGetMangledName(void *opaque_decl) {\n  if (opaque_decl) {\n    clang::NamedDecl *nd =\n        llvm::dyn_cast<clang::NamedDecl>((clang::Decl *)opaque_decl);\n    if (nd != nullptr && !llvm::isa<clang::ObjCMethodDecl>(nd)) {\n      clang::MangleContext *mc = getMangleContext();\n      if (mc && mc->shouldMangleCXXName(nd)) {\n        llvm::SmallVector<char, 1024> buf;\n        llvm::raw_svector_ostream llvm_ostrm(buf);\n        if (llvm::isa<clang::CXXConstructorDecl>(nd)) {\n          mc->mangleName(\n              clang::GlobalDecl(llvm::dyn_cast<clang::CXXConstructorDecl>(nd),\n                                Ctor_Complete),\n              llvm_ostrm);\n        } else if (llvm::isa<clang::CXXDestructorDecl>(nd)) {\n          mc->mangleName(\n              clang::GlobalDecl(llvm::dyn_cast<clang::CXXDestructorDecl>(nd),\n                                Dtor_Complete),\n              llvm_ostrm);\n        } else {\n          mc->mangleName(nd, llvm_ostrm);\n        }\n        if (buf.size() > 0)\n          return ConstString(buf.data(), buf.size());\n      }\n    }\n  }\n  return ConstString();\n}\n\nCompilerDeclContext TypeSystemClang::DeclGetDeclContext(void *opaque_decl) {\n  if (opaque_decl)\n    return CreateDeclContext(((clang::Decl *)opaque_decl)->getDeclContext());\n  return CompilerDeclContext();\n}\n\nCompilerType TypeSystemClang::DeclGetFunctionReturnType(void *opaque_decl) {\n  if (clang::FunctionDecl *func_decl =\n          llvm::dyn_cast<clang::FunctionDecl>((clang::Decl *)opaque_decl))\n    return GetType(func_decl->getReturnType());\n  if (clang::ObjCMethodDecl *objc_method =\n          llvm::dyn_cast<clang::ObjCMethodDecl>((clang::Decl *)opaque_decl))\n    return GetType(objc_method->getReturnType());\n  else\n    return CompilerType();\n}\n\nsize_t TypeSystemClang::DeclGetFunctionNumArguments(void *opaque_decl) {\n  if (clang::FunctionDecl *func_decl =\n          llvm::dyn_cast<clang::FunctionDecl>((clang::Decl *)opaque_decl))\n    return func_decl->param_size();\n  if (clang::ObjCMethodDecl *objc_method =\n          llvm::dyn_cast<clang::ObjCMethodDecl>((clang::Decl *)opaque_decl))\n    return objc_method->param_size();\n  else\n    return 0;\n}\n\nCompilerType TypeSystemClang::DeclGetFunctionArgumentType(void *opaque_decl,\n                                                          size_t idx) {\n  if (clang::FunctionDecl *func_decl =\n          llvm::dyn_cast<clang::FunctionDecl>((clang::Decl *)opaque_decl)) {\n    if (idx < func_decl->param_size()) {\n      ParmVarDecl *var_decl = func_decl->getParamDecl(idx);\n      if (var_decl)\n        return GetType(var_decl->getOriginalType());\n    }\n  } else if (clang::ObjCMethodDecl *objc_method =\n                 llvm::dyn_cast<clang::ObjCMethodDecl>(\n                     (clang::Decl *)opaque_decl)) {\n    if (idx < objc_method->param_size())\n      return GetType(objc_method->parameters()[idx]->getOriginalType());\n  }\n  return CompilerType();\n}\n\n// CompilerDeclContext functions\n\nstd::vector<CompilerDecl> TypeSystemClang::DeclContextFindDeclByName(\n    void *opaque_decl_ctx, ConstString name, const bool ignore_using_decls) {\n  std::vector<CompilerDecl> found_decls;\n  if (opaque_decl_ctx) {\n    DeclContext *root_decl_ctx = (DeclContext *)opaque_decl_ctx;\n    std::set<DeclContext *> searched;\n    std::multimap<DeclContext *, DeclContext *> search_queue;\n    SymbolFile *symbol_file = GetSymbolFile();\n\n    for (clang::DeclContext *decl_context = root_decl_ctx;\n         decl_context != nullptr && found_decls.empty();\n         decl_context = decl_context->getParent()) {\n      search_queue.insert(std::make_pair(decl_context, decl_context));\n\n      for (auto it = search_queue.find(decl_context); it != search_queue.end();\n           it++) {\n        if (!searched.insert(it->second).second)\n          continue;\n        symbol_file->ParseDeclsForContext(\n            CreateDeclContext(it->second));\n\n        for (clang::Decl *child : it->second->decls()) {\n          if (clang::UsingDirectiveDecl *ud =\n                  llvm::dyn_cast<clang::UsingDirectiveDecl>(child)) {\n            if (ignore_using_decls)\n              continue;\n            clang::DeclContext *from = ud->getCommonAncestor();\n            if (searched.find(ud->getNominatedNamespace()) == searched.end())\n              search_queue.insert(\n                  std::make_pair(from, ud->getNominatedNamespace()));\n          } else if (clang::UsingDecl *ud =\n                         llvm::dyn_cast<clang::UsingDecl>(child)) {\n            if (ignore_using_decls)\n              continue;\n            for (clang::UsingShadowDecl *usd : ud->shadows()) {\n              clang::Decl *target = usd->getTargetDecl();\n              if (clang::NamedDecl *nd =\n                      llvm::dyn_cast<clang::NamedDecl>(target)) {\n                IdentifierInfo *ii = nd->getIdentifier();\n                if (ii != nullptr &&\n                    ii->getName().equals(name.AsCString(nullptr)))\n                  found_decls.push_back(GetCompilerDecl(nd));\n              }\n            }\n          } else if (clang::NamedDecl *nd =\n                         llvm::dyn_cast<clang::NamedDecl>(child)) {\n            IdentifierInfo *ii = nd->getIdentifier();\n            if (ii != nullptr && ii->getName().equals(name.AsCString(nullptr)))\n              found_decls.push_back(GetCompilerDecl(nd));\n          }\n        }\n      }\n    }\n  }\n  return found_decls;\n}\n\n// Look for child_decl_ctx's lookup scope in frame_decl_ctx and its parents,\n// and return the number of levels it took to find it, or\n// LLDB_INVALID_DECL_LEVEL if not found.  If the decl was imported via a using\n// declaration, its name and/or type, if set, will be used to check that the\n// decl found in the scope is a match.\n//\n// The optional name is required by languages (like C++) to handle using\n// declarations like:\n//\n//     void poo();\n//     namespace ns {\n//         void foo();\n//         void goo();\n//     }\n//     void bar() {\n//         using ns::foo;\n//         // CountDeclLevels returns 0 for 'foo', 1 for 'poo', and\n//         // LLDB_INVALID_DECL_LEVEL for 'goo'.\n//     }\n//\n// The optional type is useful in the case that there's a specific overload\n// that we're looking for that might otherwise be shadowed, like:\n//\n//     void foo(int);\n//     namespace ns {\n//         void foo();\n//     }\n//     void bar() {\n//         using ns::foo;\n//         // CountDeclLevels returns 0 for { 'foo', void() },\n//         // 1 for { 'foo', void(int) }, and\n//         // LLDB_INVALID_DECL_LEVEL for { 'foo', void(int, int) }.\n//     }\n//\n// NOTE: Because file statics are at the TranslationUnit along with globals, a\n// function at file scope will return the same level as a function at global\n// scope. Ideally we'd like to treat the file scope as an additional scope just\n// below the global scope.  More work needs to be done to recognise that, if\n// the decl we're trying to look up is static, we should compare its source\n// file with that of the current scope and return a lower number for it.\nuint32_t TypeSystemClang::CountDeclLevels(clang::DeclContext *frame_decl_ctx,\n                                          clang::DeclContext *child_decl_ctx,\n                                          ConstString *child_name,\n                                          CompilerType *child_type) {\n  if (frame_decl_ctx) {\n    std::set<DeclContext *> searched;\n    std::multimap<DeclContext *, DeclContext *> search_queue;\n    SymbolFile *symbol_file = GetSymbolFile();\n\n    // Get the lookup scope for the decl we're trying to find.\n    clang::DeclContext *parent_decl_ctx = child_decl_ctx->getParent();\n\n    // Look for it in our scope's decl context and its parents.\n    uint32_t level = 0;\n    for (clang::DeclContext *decl_ctx = frame_decl_ctx; decl_ctx != nullptr;\n         decl_ctx = decl_ctx->getParent()) {\n      if (!decl_ctx->isLookupContext())\n        continue;\n      if (decl_ctx == parent_decl_ctx)\n        // Found it!\n        return level;\n      search_queue.insert(std::make_pair(decl_ctx, decl_ctx));\n      for (auto it = search_queue.find(decl_ctx); it != search_queue.end();\n           it++) {\n        if (searched.find(it->second) != searched.end())\n          continue;\n\n        // Currently DWARF has one shared translation unit for all Decls at top\n        // level, so this would erroneously find using statements anywhere.  So\n        // don't look at the top-level translation unit.\n        // TODO fix this and add a testcase that depends on it.\n\n        if (llvm::isa<clang::TranslationUnitDecl>(it->second))\n          continue;\n\n        searched.insert(it->second);\n        symbol_file->ParseDeclsForContext(\n            CreateDeclContext(it->second));\n\n        for (clang::Decl *child : it->second->decls()) {\n          if (clang::UsingDirectiveDecl *ud =\n                  llvm::dyn_cast<clang::UsingDirectiveDecl>(child)) {\n            clang::DeclContext *ns = ud->getNominatedNamespace();\n            if (ns == parent_decl_ctx)\n              // Found it!\n              return level;\n            clang::DeclContext *from = ud->getCommonAncestor();\n            if (searched.find(ns) == searched.end())\n              search_queue.insert(std::make_pair(from, ns));\n          } else if (child_name) {\n            if (clang::UsingDecl *ud =\n                    llvm::dyn_cast<clang::UsingDecl>(child)) {\n              for (clang::UsingShadowDecl *usd : ud->shadows()) {\n                clang::Decl *target = usd->getTargetDecl();\n                clang::NamedDecl *nd = llvm::dyn_cast<clang::NamedDecl>(target);\n                if (!nd)\n                  continue;\n                // Check names.\n                IdentifierInfo *ii = nd->getIdentifier();\n                if (ii == nullptr ||\n                    !ii->getName().equals(child_name->AsCString(nullptr)))\n                  continue;\n                // Check types, if one was provided.\n                if (child_type) {\n                  CompilerType clang_type = GetTypeForDecl(nd);\n                  if (!AreTypesSame(clang_type, *child_type,\n                                    /*ignore_qualifiers=*/true))\n                    continue;\n                }\n                // Found it!\n                return level;\n              }\n            }\n          }\n        }\n      }\n      ++level;\n    }\n  }\n  return LLDB_INVALID_DECL_LEVEL;\n}\n\nConstString TypeSystemClang::DeclContextGetName(void *opaque_decl_ctx) {\n  if (opaque_decl_ctx) {\n    clang::NamedDecl *named_decl =\n        llvm::dyn_cast<clang::NamedDecl>((clang::DeclContext *)opaque_decl_ctx);\n    if (named_decl)\n      return ConstString(named_decl->getName());\n  }\n  return ConstString();\n}\n\nConstString\nTypeSystemClang::DeclContextGetScopeQualifiedName(void *opaque_decl_ctx) {\n  if (opaque_decl_ctx) {\n    clang::NamedDecl *named_decl =\n        llvm::dyn_cast<clang::NamedDecl>((clang::DeclContext *)opaque_decl_ctx);\n    if (named_decl)\n      return ConstString(GetTypeNameForDecl(named_decl));\n  }\n  return ConstString();\n}\n\nbool TypeSystemClang::DeclContextIsClassMethod(\n    void *opaque_decl_ctx, lldb::LanguageType *language_ptr,\n    bool *is_instance_method_ptr, ConstString *language_object_name_ptr) {\n  if (opaque_decl_ctx) {\n    clang::DeclContext *decl_ctx = (clang::DeclContext *)opaque_decl_ctx;\n    if (ObjCMethodDecl *objc_method =\n            llvm::dyn_cast<clang::ObjCMethodDecl>(decl_ctx)) {\n      if (is_instance_method_ptr)\n        *is_instance_method_ptr = objc_method->isInstanceMethod();\n      if (language_ptr)\n        *language_ptr = eLanguageTypeObjC;\n      if (language_object_name_ptr)\n        language_object_name_ptr->SetCString(\"self\");\n      return true;\n    } else if (CXXMethodDecl *cxx_method =\n                   llvm::dyn_cast<clang::CXXMethodDecl>(decl_ctx)) {\n      if (is_instance_method_ptr)\n        *is_instance_method_ptr = cxx_method->isInstance();\n      if (language_ptr)\n        *language_ptr = eLanguageTypeC_plus_plus;\n      if (language_object_name_ptr)\n        language_object_name_ptr->SetCString(\"this\");\n      return true;\n    } else if (clang::FunctionDecl *function_decl =\n                   llvm::dyn_cast<clang::FunctionDecl>(decl_ctx)) {\n      ClangASTMetadata *metadata = GetMetadata(function_decl);\n      if (metadata && metadata->HasObjectPtr()) {\n        if (is_instance_method_ptr)\n          *is_instance_method_ptr = true;\n        if (language_ptr)\n          *language_ptr = eLanguageTypeObjC;\n        if (language_object_name_ptr)\n          language_object_name_ptr->SetCString(metadata->GetObjectPtrName());\n        return true;\n      }\n    }\n  }\n  return false;\n}\n\nbool TypeSystemClang::DeclContextIsContainedInLookup(\n    void *opaque_decl_ctx, void *other_opaque_decl_ctx) {\n  auto *decl_ctx = (clang::DeclContext *)opaque_decl_ctx;\n  auto *other = (clang::DeclContext *)other_opaque_decl_ctx;\n\n  do {\n    // A decl context always includes its own contents in its lookup.\n    if (decl_ctx == other)\n      return true;\n\n    // If we have an inline namespace, then the lookup of the parent context\n    // also includes the inline namespace contents.\n  } while (other->isInlineNamespace() && (other = other->getParent()));\n\n  return false;\n}\n\nstatic bool IsClangDeclContext(const CompilerDeclContext &dc) {\n  return dc.IsValid() && isa<TypeSystemClang>(dc.GetTypeSystem());\n}\n\nclang::DeclContext *\nTypeSystemClang::DeclContextGetAsDeclContext(const CompilerDeclContext &dc) {\n  if (IsClangDeclContext(dc))\n    return (clang::DeclContext *)dc.GetOpaqueDeclContext();\n  return nullptr;\n}\n\nObjCMethodDecl *\nTypeSystemClang::DeclContextGetAsObjCMethodDecl(const CompilerDeclContext &dc) {\n  if (IsClangDeclContext(dc))\n    return llvm::dyn_cast<clang::ObjCMethodDecl>(\n        (clang::DeclContext *)dc.GetOpaqueDeclContext());\n  return nullptr;\n}\n\nCXXMethodDecl *\nTypeSystemClang::DeclContextGetAsCXXMethodDecl(const CompilerDeclContext &dc) {\n  if (IsClangDeclContext(dc))\n    return llvm::dyn_cast<clang::CXXMethodDecl>(\n        (clang::DeclContext *)dc.GetOpaqueDeclContext());\n  return nullptr;\n}\n\nclang::FunctionDecl *\nTypeSystemClang::DeclContextGetAsFunctionDecl(const CompilerDeclContext &dc) {\n  if (IsClangDeclContext(dc))\n    return llvm::dyn_cast<clang::FunctionDecl>(\n        (clang::DeclContext *)dc.GetOpaqueDeclContext());\n  return nullptr;\n}\n\nclang::NamespaceDecl *\nTypeSystemClang::DeclContextGetAsNamespaceDecl(const CompilerDeclContext &dc) {\n  if (IsClangDeclContext(dc))\n    return llvm::dyn_cast<clang::NamespaceDecl>(\n        (clang::DeclContext *)dc.GetOpaqueDeclContext());\n  return nullptr;\n}\n\nClangASTMetadata *\nTypeSystemClang::DeclContextGetMetaData(const CompilerDeclContext &dc,\n                                        const Decl *object) {\n  TypeSystemClang *ast = llvm::cast<TypeSystemClang>(dc.GetTypeSystem());\n  return ast->GetMetadata(object);\n}\n\nclang::ASTContext *\nTypeSystemClang::DeclContextGetTypeSystemClang(const CompilerDeclContext &dc) {\n  TypeSystemClang *ast =\n      llvm::dyn_cast_or_null<TypeSystemClang>(dc.GetTypeSystem());\n  if (ast)\n    return &ast->getASTContext();\n  return nullptr;\n}\n\nnamespace {\n/// A specialized scratch AST used within ScratchTypeSystemClang.\n/// These are the ASTs backing the different IsolatedASTKinds. They behave\n/// like a normal ScratchTypeSystemClang but they don't own their own\n/// persistent  storage or target reference.\nclass SpecializedScratchAST : public TypeSystemClang {\npublic:\n  /// \\param name The display name of the TypeSystemClang instance.\n  /// \\param triple The triple used for the TypeSystemClang instance.\n  /// \\param ast_source The ClangASTSource that should be used to complete\n  ///                   type information.\n  SpecializedScratchAST(llvm::StringRef name, llvm::Triple triple,\n                        std::unique_ptr<ClangASTSource> ast_source)\n      : TypeSystemClang(name, triple),\n        m_scratch_ast_source_up(std::move(ast_source)) {\n    // Setup the ClangASTSource to complete this AST.\n    m_scratch_ast_source_up->InstallASTContext(*this);\n    llvm::IntrusiveRefCntPtr<clang::ExternalASTSource> proxy_ast_source(\n        m_scratch_ast_source_up->CreateProxy());\n    SetExternalSource(proxy_ast_source);\n  }\n\n  /// The ExternalASTSource that performs lookups and completes types.\n  std::unique_ptr<ClangASTSource> m_scratch_ast_source_up;\n};\n} // namespace\n\nchar ScratchTypeSystemClang::ID;\nconst llvm::NoneType ScratchTypeSystemClang::DefaultAST = llvm::None;\n\nScratchTypeSystemClang::ScratchTypeSystemClang(Target &target,\n                                               llvm::Triple triple)\n    : TypeSystemClang(\"scratch ASTContext\", triple), m_triple(triple),\n      m_target_wp(target.shared_from_this()),\n      m_persistent_variables(new ClangPersistentVariables) {\n  m_scratch_ast_source_up = CreateASTSource();\n  m_scratch_ast_source_up->InstallASTContext(*this);\n  llvm::IntrusiveRefCntPtr<clang::ExternalASTSource> proxy_ast_source(\n      m_scratch_ast_source_up->CreateProxy());\n  SetExternalSource(proxy_ast_source);\n}\n\nvoid ScratchTypeSystemClang::Finalize() {\n  TypeSystemClang::Finalize();\n  m_scratch_ast_source_up.reset();\n}\n\nTypeSystemClang *\nScratchTypeSystemClang::GetForTarget(Target &target,\n                                     llvm::Optional<IsolatedASTKind> ast_kind,\n                                     bool create_on_demand) {\n  auto type_system_or_err = target.GetScratchTypeSystemForLanguage(\n      lldb::eLanguageTypeC, create_on_demand);\n  if (auto err = type_system_or_err.takeError()) {\n    LLDB_LOG_ERROR(lldb_private::GetLogIfAnyCategoriesSet(LIBLLDB_LOG_TARGET),\n                   std::move(err), \"Couldn't get scratch TypeSystemClang\");\n    return nullptr;\n  }\n  ScratchTypeSystemClang &scratch_ast =\n      llvm::cast<ScratchTypeSystemClang>(type_system_or_err.get());\n  // If no dedicated sub-AST was requested, just return the main AST.\n  if (ast_kind == DefaultAST)\n    return &scratch_ast;\n  // Search the sub-ASTs.\n  return &scratch_ast.GetIsolatedAST(*ast_kind);\n}\n\nUserExpression *ScratchTypeSystemClang::GetUserExpression(\n    llvm::StringRef expr, llvm::StringRef prefix, lldb::LanguageType language,\n    Expression::ResultType desired_type,\n    const EvaluateExpressionOptions &options, ValueObject *ctx_obj) {\n  TargetSP target_sp = m_target_wp.lock();\n  if (!target_sp)\n    return nullptr;\n\n  return new ClangUserExpression(*target_sp.get(), expr, prefix, language,\n                                 desired_type, options, ctx_obj);\n}\n\nFunctionCaller *ScratchTypeSystemClang::GetFunctionCaller(\n    const CompilerType &return_type, const Address &function_address,\n    const ValueList &arg_value_list, const char *name) {\n  TargetSP target_sp = m_target_wp.lock();\n  if (!target_sp)\n    return nullptr;\n\n  Process *process = target_sp->GetProcessSP().get();\n  if (!process)\n    return nullptr;\n\n  return new ClangFunctionCaller(*process, return_type, function_address,\n                                 arg_value_list, name);\n}\n\nstd::unique_ptr<UtilityFunction>\nScratchTypeSystemClang::CreateUtilityFunction(std::string text,\n                                              std::string name) {\n  TargetSP target_sp = m_target_wp.lock();\n  if (!target_sp)\n    return {};\n\n  return std::make_unique<ClangUtilityFunction>(\n      *target_sp.get(), std::move(text), std::move(name),\n      target_sp->GetDebugUtilityExpression());\n}\n\nPersistentExpressionState *\nScratchTypeSystemClang::GetPersistentExpressionState() {\n  return m_persistent_variables.get();\n}\n\nvoid ScratchTypeSystemClang::ForgetSource(ASTContext *src_ctx,\n                                          ClangASTImporter &importer) {\n  // Remove it as a source from the main AST.\n  importer.ForgetSource(&getASTContext(), src_ctx);\n  // Remove it as a source from all created sub-ASTs.\n  for (const auto &a : m_isolated_asts)\n    importer.ForgetSource(&a.second->getASTContext(), src_ctx);\n}\n\nstd::unique_ptr<ClangASTSource> ScratchTypeSystemClang::CreateASTSource() {\n  return std::make_unique<ClangASTSource>(\n      m_target_wp.lock()->shared_from_this(),\n      m_persistent_variables->GetClangASTImporter());\n}\n\nstatic llvm::StringRef\nGetSpecializedASTName(ScratchTypeSystemClang::IsolatedASTKind feature) {\n  switch (feature) {\n  case ScratchTypeSystemClang::IsolatedASTKind::CppModules:\n    return \"scratch ASTContext for C++ module types\";\n  }\n  llvm_unreachable(\"Unimplemented ASTFeature kind?\");\n}\n\nTypeSystemClang &ScratchTypeSystemClang::GetIsolatedAST(\n    ScratchTypeSystemClang::IsolatedASTKind feature) {\n  auto found_ast = m_isolated_asts.find(feature);\n  if (found_ast != m_isolated_asts.end())\n    return *found_ast->second;\n\n  // Couldn't find the requested sub-AST, so create it now.\n  std::unique_ptr<TypeSystemClang> new_ast;\n  new_ast.reset(new SpecializedScratchAST(GetSpecializedASTName(feature),\n                                          m_triple, CreateASTSource()));\n  m_isolated_asts[feature] = std::move(new_ast);\n  return *m_isolated_asts[feature];\n}\n"}}, "reports": [{"events": [{"location": {"col": 7, "file": 87, "line": 698}, "message": "'NullDiagnosticConsumer' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lldb/source/Plugins/TypeSystem/Clang/TypeSystemClang.cpp", "reportHash": "24cfdcb801fd3e191189b8d19af5f49a", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}, {"events": [{"location": {"col": 7, "file": 87, "line": 9624}, "message": "'SpecializedScratchAST' should be marked noexcept"}], "macros": [], "notes": [], "path": "/home/vsts/work/1/llvm-project/lldb/source/Plugins/TypeSystem/Clang/TypeSystemClang.cpp", "reportHash": "e3f1956f4c18951cb4732b7487db8b3a", "checkerName": "cppcoreguidelines-noexcept", "reviewStatus": null, "severity": "UNSPECIFIED"}]};
      window.onload = function() {
        if (!browserCompatible) {
          setNonCompatibleBrowserMessage();
        } else {
          BugViewer.init(data.files, data.reports);
          BugViewer.create();
          BugViewer.initByUrl();
        }
      };
    </script>
  </head>
  <body>
  <div class="container">
    <div id="content">
      <div id="side-bar">
        <div class="header">
          <a href="index.html" class="button">&#8249; Return to List</a>
        </div>
        <div id="report-nav">
          <div class="header">Reports</div>
        </div>
      </div>
      <div id="editor-wrapper">
        <div class="header">
          <div id="file">
            <span class="label">File:</span>
            <span id="file-path"></span>
          </div>
          <div id="checker">
            <span class="label">Checker name:</span>
            <span id="checker-name"></span>
          </div>
          <div id="review-status-wrapper">
            <span class="label">Review status:</span>
            <span id="review-status"></span>
          </div>
        </div>
        <div id="editor"></div>
      </div>
    </div>
  </div>
  </body>
</html>
